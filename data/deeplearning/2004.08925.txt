0
2
0
2

r
p
A
9
1

]
E
N
.
s
c
[

1
v
5
2
9
8
0
.
4
0
0
2
:
v
i
X
r
a

Tree Echo State Autoencoders with Grammars

Benjamin Paaßen, Irena Koprinska, and Kalina Yacef

School of Computer Science, The University of Sydney∗

Preprint of the IJCNN 2020 paper Paassen et al. [2020] as provided by the authors.†

Abstract

Tree data occurs in many forms, such as computer programs, chemical molecules, or natural lan-
guage. Unfortunately, the non-vectorial and discrete nature of trees makes it challenging to construct
functions with tree-formed output, complicating tasks such as optimization or time series prediction.
Autoencoders address this challenge by mapping trees to a vectorial latent space, where tasks are eas-
ier to solve, and then mapping the solution back to a tree structure. However, existing autoencoding
approaches for tree data fail to take the speciﬁc grammatical structure of tree domains into account
and rely on deep learning, thus requiring large training datasets and long training times.
In this
paper, we propose tree echo state autoencoders (TES-AE), which are guided by a tree grammar and
can be trained within seconds by virtue of reservoir computing. In our evaluation on three datasets,
we demonstrate that our proposed approach is not only much faster than a state-of-the-art deep
learning autoencoding approach (D-VAE) but also has less autoencoding error if little data and time
is given.

Keywords:

echo state networks, regular tree grammars, reservoir computing, autoencoders, trees

1 Introduction

Trees constitute an important data structure in a wide range of ﬁelds, describing diverse data such
as computer programs [Aho et al., 2006], chemical molecules [Weininger, 1988], or natural language
[Knight and Graehl, 2005]. In recent years, machine learning on these kinds of data has made considerable
process, especially for classiﬁcation and regression tasks [Gallicchio and Micheli, 2013, Kipf and Welling,
2017, Paaßen et al., 2018a]. In these cases, a machine learning model maps from trees to a scalar or vec-
torial output (encoding). The converse direction, mapping a vector back to a tree (decoding), however, is
less well investigated, although such decoders would be highly useful for tasks such as generative models
for trees, the optimization of tree structures, or time series prediction on trees [Paaßen et al., 2019]. In
particular, a decoder for trees could help to optimize molecular structures [Kusner et al., 2017], or to
provide hints to students in intelligent tutoring systems [Paaßen et al., 2018b].

Prior work on decoders for structured data can be roughly partitioned into two groups. First, decoders
for full or acyclic graphs [Liu et al., 2018, You et al., 2018, Bacciu et al., 2019, Zhang et al., 2019], which
use deep recurrent neural networks to generate a graph one node or edge at a time until a full graph is
completed. The drawback of these approaches is that they fail to take the speciﬁc structure of trees into
account and thus may generate structures that are not trees. Furthermore, they do not take grammatical
knowledge about the domain into account, which would be available for all aforementioned examples
[Aho et al., 2006, Weininger, 1988, Knight and Graehl, 2005], and could thus be a useful prior.

∗Funding by the German Research Foundation (DFG) under grant number PA 3460/1-1 is gratefully acknowledged.

Online supplement with source code at https://gitlab.com/bpaassen/tree_echo_state_autoencoders .

†© 2020 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other uses,
in any current or future media, including reprinting/republishing this material for advertising or promotional purposes,
creating new collective works, for resale or redistribution to servers or lists, or reuse of any copyrighted component of this
work in other works.

1

 
 
 
 
 
 
Preprint of Paassen et al. [2020] provided by the authors.

2

tree

encoder

decoder

tree’

∧

code

∧

x

¬

φ

~x

ψ

x¬

y

y

classiﬁcation
regression
dimensionality reduction

generation
time series prediction
optimization

Figure 1: An illustration of a tree encoder/decoder architecture and the applications for the code (classi-
ﬁcation, regression, dimensionality reduction) and the decoded tree (generation, optimization, time series
prediction).

The second group are decoders that take grammar information into account [Kusner et al., 2017,
Dai et al., 2018], but are at present limited to string data instead of trees. Furthermore, both groups rely
on deep neural networks for training which require large datasets and long training times.

Our key contribution in this paper are tree echo state autoencoders (TES-AE), a novel autoencoder
architecture speciﬁcally dedicated to tree data, which uses grammatical knowledge and can be trained
within seconds using a standard support vector machine solver [Cortes and Vapnik, 1995, Pedregosa et al.,
2011]. Our approach is based on tree echo state networks [Gallicchio and Micheli, 2013] for encoding and
analogous networks for decoding, where we keep all neural network parameters ﬁxed except for the ﬁnal
decoding layer. In our proposed model, this ﬁnal layer decides which grammar rule to apply in each step
of the decoding process. In our experiments on three datasets we show that our autoencoding approach
can outperform deep variational autoencoders for acyclic graphs (D-VAE) [Zhang et al., 2019] in terms
of training time and autoencoding error, if little data and little training time is available. Further, we
show that TES-AEs outperform sequential echo state networks for this application and that the TES-AE
coding space is suitable for tree optimization, achieving similar results as [Kusner et al., 2017].

In the following, we cover related work in more detail and recap background knowledge regarding
regular tree grammars, before we describe our proposed architecture in depth, explain our experiments
and results, and conclude with a summary of our ﬁndings.

2 Related Work

2.1 Tree Encoding

Most prior work on machine learning for trees can be grouped into neural network approaches (e.g.
[Sperduti and Starita, 1997, Hammer et al., 2004, Gallicchio and Micheli, 2013]) and tree kernel ap-
proaches (e.g. [Collins and Duﬀy, 2002, Aiolli et al., 2015]). In both cases, a tree ˆx is ﬁrst mapped to a
vectorial representation φ(ˆx) = ~x, which is then used to complete a machine learning task, such as classiﬁ-
cation [Sperduti and Starita, 1997], regression [Gallicchio and Micheli, 2013], or dimensionality reduction
[Hammer et al., 2004]. We call the mapping φ an encoder for trees and we call ~x the code of ˆx (refer
to Figure 1, left). In more detail, recursive neural networks [Sperduti and Starita, 1997, Hammer et al.,
2004, Gallicchio and Micheli, 2013] encode trees by deﬁning a function f which maps a node label and a
(perhaps ordered) set of child encodings to an encoding for the parent node. The overall encoding φ is then
computed via recursion. For example, the tree ˆx = ∧(x, ¬(y)) from Figure 1 would be recursively encoded
as φ(ˆx) = f (∧, {φ(x), φ(¬(y))}), where φ(x) = f (x, ∅) and φ(¬(y)) = f (¬, {φ(y)}) = f (¬, {f (y, ∅)}). We
follow this recursive encoding scheme in our work but adapt it slightly to be better aligned with a
grammar.

Preprint of Paassen et al. [2020] provided by the authors.

3

2.2 Tree Decoding

While an encoder is suﬃcient to perform machine learning tasks with vectorial output, many interesting
tasks require a decoder ψ as well, i.e. a mapping from the vector space back to the space of trees (refer
to Figure 1, right). For example, we can address time series prediction by encoding a tree ˆx as a vector
φ(ˆx), predicting the next state of the vector φ(ˆx) + ~δ, and then decoding back to the next state of the
tree ψ(φ(ˆx) + ~δ) [Paaßen et al., 2018b]; we can construct new trees by sampling a vector ~x in the latent
space and then mapping back to a tree structure ψ(~x) [Bacciu et al., 2019]; and we can optimize trees by
varying the representation in the latent space ~x such that some objective function ℓ(ψ(~x)) on the decoded
tree ψ(~x) is optimized [Kusner et al., 2017].

Training a decoder for trees is considerably harder compared to an encoder because the dimensionality
of the vector space (and hence the number of neurons in the model) needs to scale exponentially with
the tree depth to distinguish all possible trees in a domain [Hammer, 2002]. Accordingly, only few
scholars to date have attempted to tackle the problem of tree decoding [Paaßen et al., 2019]. Most
who did are concerned with the more general problem of graph decoding by generating a graph one
node/edge at a time via a deep recurrent neural network [Liu et al., 2018, You et al., 2018, Bacciu et al.,
In more detail, these approaches treat a graph as a sequence of node and
2019, Zhang et al., 2019].
edge insertions and attempt to reproduce this sequence with a recurrent neural network. The most
applicable of these works to our setting are variational autoencoders for directed acyclic graphs (D-VAE)
[Zhang et al., 2019] because trees are a subclass of acyclic graphs and thus the architectural bias towards
acyclicity should help D-VAEs in reconstructing trees.

Note that our proposed model is similar to these approaches in that we also equate a tree with a
sequence of actions, namely a sequence of production rules in a regular tree grammar. However, we
do not apply a recurrent neural network but follow the recursive structure of the tree. Further, by
considering grammar rules instead of general node and edge insertions, our output trees are guaranteed
to be syntactically correct whereas existing graph decoders may violate syntactic rules or produce data
that is not tree-formed at all.

With respect to the reliance on grammars, our approach resembles the work of [Kusner et al., 2017]
who also suggested to guide a decoder by a grammar. Also like [Kusner et al., 2017], we train our
networks to achieve autoencoding, i.e. we wish to train a ψ that acts as an inverse of an encoder φ on the
training data. However, we consider tree data instead of string data and use recursive networks instead
of (time-)convolutional networks.

2.3 Echo State Networks

A ﬁnal and crucial diﬀerence to all previous work lies in our choice of training scheme. While all afore-
mentioned approaches use gradient descent across the entire network, we base our approach on the
reservoir computing literature (e.g. [Jaeger and Haas, 2004, Rodan and Tiňo, 2012]). More precisely, we
use a slightly varied version of the tree echo state network [Gallicchio and Micheli, 2013] as encoder and
decoder, where all internal parameters are initialized randomly, then pre-processed to ensure eventual
forgetting of inputs [Jaeger and Haas, 2004], but kept ﬁxed afterwards. We only train the ﬁnal layer that
decides which grammar rule to take in each step of the decoding. Because of this, our training problem
becomes convex and easy to solve. In particular, we can use a straightforward support vector machine
solver [Cortes and Vapnik, 1995, Pedregosa et al., 2011] to train the output layer. Our main contribution
to the reservoir computing literature is that we propose not only an encoder, but a decoder model for
trees.

2.4 Regular tree grammars

Our approach strongly relies on regular tree grammars [Brainerd, 1969, Comon et al., 2008], such that we
now take some time to describe them in more detail, albeit in a simpliﬁed notation to ease understanding.
First, we deﬁne a tree ˆx over some ﬁnite alphabet Σ as an expression x(ˆy1, . . . , ˆyk), where x ∈ Σ and
where ˆy1, . . . , ˆyk are also trees over Σ, which we call the children of ˆx. Note that k may be zero, in which
case we call the tree a leaf. For example, for Σ = {∧, ∨, ¬, x, y}, x(), ∨(x(), y()), ¬(x()), and ∧() are all
trees over Σ, where x() and ∧() are leaves. Per convention, we omit the empty brackets for leaves.

Note that our deﬁnition of trees is very liberal and includes many instances that may be nonsensical
according to the rules of the domain. To restrict the space of possible trees to a more sensible subset,

Preprint of Paassen et al. [2020] provided by the authors.

4

we use regular tree grammars. We deﬁne a regular tree grammar as a 4-tuple G = (Φ, Σ, R, S), where
Φ is a ﬁnite set of nonterminal symbols, Σ is a ﬁnite set of terminal symbols, S ∈ Φ is a special
nonterminal symbol which we call the starting symbol, and R is a ﬁnite set of production rules of the
form A → x(B1, . . . , Bk) where A, B1, . . . , Bk ∈ Φ and x ∈ Σ.

We say that a tree ˆy over Φ ∪ Σ can be derived in one step via grammar G from another tree ˆx over
Φ ∪ Σ, if there exists a production rule A → x(B1, . . . , Bk) and a leaf A in ˆx, such that replacing A with
x(B1, . . . , Bk) yields ˆy. Generalizing this deﬁnition, we say that a tree ˆy can be derived in T steps via
grammar G from another tree ˆx, if there exists a sequence of trees ˆz0 → . . . → ˆzT such that ˆz0 = ˆx,
ˆzT = ˆy, and ˆzt can be derived in one step via grammar G from ˆzt−1 for all t > 0. Finally, we deﬁne the tree
language L(G) as the set of all trees ˆx over Σ which can be derived in T steps from the starting symbol S
for any T ∈ N. As an example, consider the regular tree grammar in Figure 3, left. The tree ∧(x, ¬(y))
can be derived in 4 steps from S via the sequence S → ∧(S, S) → ∧(x, S) → ∧(x, ¬(S)) → ∧(x, ¬(y)).

An important property of regular tree grammars is that they can be parsed eﬃciently using tree
automata [Brainerd, 1969, Comon et al., 2008]. This is especially easy to see for a subclass of regular
tree grammars, which we call deterministic. We deﬁne a regular tree grammar as deterministic if no two
production rules have the same right-hand-side. For these grammars, we can parse a tree ˆx = x(ˆy1, . . . , yk)
via the following recursive function: First, we parse all children of ˆx. This will return a nonterminal
symbol Bi for every child ˆyi and a sequence of rules deriving ˆyi from Bi. After that, we simply have
to check whether a rule of the form A → x(B1, . . . , Bk) exists in our grammar.
If so, we return the
nonterminal symbol A and the concatenation of this rule and all rule sequences for the children. If not,
the parse ends because the tree is not part of the tree language. We utilize this scheme later for encoding
in Algorithm 1.

3 Method

Our aim in this paper is to construct an autoencoder for trees that exploits grammatical knowledge for
the tree domain. More precisely, for a given regular tree grammar G we would like to obtain an encoder
φ : L(G) → Rn for some n ∈ N and a decoder ψ : Rn → L(G), such that for as many trees ˆx ∈ L(G)
as possible, ˆx is close to ψ(φ(ˆx)). To achieve this goal, we introduce two approaches. We start with
a sequence-to-sequence learning approach following the architecture of [Sutskever et al., 2014] and then
continue with an approach based on tree echo state networks [Gallicchio and Micheli, 2013], which we
describe in terms of encoding, decoding, and training.

3.1 Sequence-to-sequence learning

Sequence-to-sequence learning is a neural network architecture introduced by [Sutskever et al., 2014],
which translates an input sequence to an output sequence, potentially of diﬀerent length. The architecture
features two recurrent neural networks, an encoding network f : Rl × Rn → Rn, a decoding network
g : Rl × Rn → Rn, and an output function h : Rn → Rl for some input dimensionality l and encoding
dimensionality n. The encoding network translates the input time series ~y1, . . . , ~yT ∈ Rl into an encoding
vector ~xT by means of the equation ~xt = f (~yt, ~xt−1) where ~x0 = ~0, i.e. a vector of n zeros. This encoding
is then used to generate the output time series ~z1, . . . , ~zT ′ as follows. We ﬁrst set the initial decoding state
as ˜x1 = ~xT and then generate the ﬁrst output as ~z1 = h(˜x1). All remaining decoding states are generated
via ˜xt = g(~zt−1, ˜xt−1) and all remaining outputs via ~zt = h(˜xt) until ~zt is a special end-of-sequence token,
whereupon the process stops.

To apply the sequence-to-sequence learning framework to tree data, we ﬁrst translate an input tree ˆx
into a sequence of production rules, which we represent via one-hot codes, then encode this sequence via
the encoder network, decode it to a sequence of one-hot codes, translate these back to production rules,
and ﬁnally produce the decoded tree using these rules.

Figure 2 illustrates the approach for the example tree ∧(x, ¬(y)) and the example grammar from
Figure 3. Recall that our example tree can be derived from the starting symbol S via the sequence S →1
∧(S, S) →4 ∧(x, S) →3 ∧(x, ¬(S)) →5 ∧(x, ¬(y)), where we indexed each arrow by its corresponding
production rule according to the numbering from Figure 3. Accordingly, the tree is equivalent to the
production rule sequence (1, 4, 3, 5), which we represent by one-hot codes in the second row of Figure 2.
We then apply the encoding network f four times to achieve an overall encoding ~x4 of our input sequence,

Preprint of Paassen et al. [2020] provided by the authors.

5

S → ∧(S, S)

S → x

S → ¬(S)

S → y

(1, 0, 0, 0, 0, 0) (0, 0, 0, 1, 0, 0) (0, 0, 1, 0, 0, 0) (0, 0, 0, 0, 1, 0)

~x0 = ~0

f

~x1

f

~x2

f

~x3

f
~x4 = ˜x1

h

g

˜x2

h

g

˜x3

h

g

˜x4

h

g

˜x5

h

(1, 0, 0, 0, 0, 0) (0, 0, 0, 1, 0, 0) (0, 0, 1, 0, 0, 0) (0, 0, 0, 0, 1, 0) (0, 0, 0, 0, 0, 1)

S → ∧(S, S)

S → x

S → ¬(S)

S → y

EOS

Figure 2: An illustration of the sequence-to-sequence autoencoding architecture for the example tree
∧(x, ¬(y)) and the regular tree grammar from Figure 3. Top: The rule sequence generating the tree;
second row: the translation of the rule sequence into one-hot-coding; third row: the sequence of encoding
and decoding states; last row: the output series of one-hot codings.

(cid:1)

U · ~yt + W · ~xt−1
(cid:0)

which we then plug in our decoder as initial state ˜x1. From this initial state, our output function h predicts
the ﬁrst element ~y1 of our output rule sequence, which is then fed back into the decoding network g to
generate the second state ˜x2, and so on until h predicts the special end-of-sequence token (0, 0, 0, 0, 0, 1).
In our case, we implement both f and g as recurrent neural networks with the equations ~xt =
, and the
f (~yt, ~xt−1) = tanh
(cid:1)
output function as a linear function ~zt = h(˜xt) = V · ˜xt. Note that the matrices U , W , and V are
parameters of our model. Following the reservoir computing paradigm [Jaeger and Haas, 2004], we do
not train the matrices U or W but initialize them as cycle reservoir with jumps [Rodan and Tiňo, 2012]
and then keep them ﬁxed. Note that we use the same matrices U and W for f and g. Next, we
generate for each tree in the training data the decoding state sequence ˜x1, . . . , ˜xT +1 via teacher forcing,
U · ~yt−1 + W · ˜xt−1
, using ~yt−1 as input argument instead of ~zt−1. Finally, we train the
i.e. ˜xt = tanh
(cid:1)
(cid:0)
matrix V via linear regression on the training data

U · ~zt−1 + W · ˜xt−1
(cid:0)

and ˜xt = g(~zt−1, ˜xt−1) = tanh

(cid:8)
While this approach is already functional in principle, we expect it to fail for reasonably large input
trees. This is because our network needs to remember rule applications a long time ago to correctly
predict the next production rule. Echo state networks, however, focus on intense short-term memory
instead of long-term memory [Jaeger and Haas, 2004, Farkaš et al., 2016]. Accordingly, we now attempt
to reduce the number of time steps between encoding and decoding by working along the tree structure
instead of ﬂattening it to a sequence beforehand.

(˜xt, ~yt)|t ∈ {1, . . . , T }

.
(cid:9)

3.2 Tree Encoding

To encode a tree, we follow the parsing scheme for (deterministic) regular tree grammars outlined in
the background section. More formally, let G = (Φ, Σ, R, S) be a regular tree grammar. Then, for each
∈ R, we deﬁne a function fr : Rn×k → Rn, such that we can
grammar rule r =
construct the encoding φ(ˆx) of a tree ˆx = x(ˆy1, . . . , ˆyk) recursively as

A → x(B1, . . . , Bk)
(cid:1)
(cid:0)

φ(ˆx) = fr(cid:16)φ(ˆy1), . . . , φ(ˆyk)(cid:17)

(1)

The precise algorithm for encoding is outlined in Algorithm 1. An example is shown in Figure 3. In the
example, we start with the entire tree ∧(x, ¬(y)) and pass downward through the tree until we reach the
ﬁrst leaf, which is x. We parse this leaf using the fourth grammar rule S → x, such that our encoding
function returns the the nonterminal S, the rule sequence (4), and the vector encoding φ(x) = f4().
We perform the same scheme for the leaf y, yielding the nonterminal S, the rule sequence (5), and the
encoding f5(). We then proceed with the partially parsed subtree ¬(S), which we can parse using the
third rule S → ¬(S), yielding the nonterminal S, the rule sequence (3, 5), and the encoding f3(f5()).
This leaves the tree ∧(S, S), which we can parse using the ﬁrst rule, yielding the nonterminal S, the rule
sequence (1, 4, 3, 5), and the overall encoding φ(∧(x, ¬(y))) = f1(f4(), f3(f5())).

Preprint of Paassen et al. [2020] provided by the authors.

6

Algorithm 1 An algorithm to encode and parse trees according to a deterministic regular tree grammar
G = (Φ, Σ, R, S) and encoding functions fr for each rule r ∈ R. The algorithm receives a tree as input
and returns a nonterminal symbol, a rule sequence that generates the tree from that nonterminal symbol,
and a vectorial encoding.

function encode(a tree ˆx = x(ˆy1, . . . , ˆyk))

for j ∈ {1, . . . , k} do

Bj, (rj,1, . . . , rj,Tj ), ~yj ← encode(ˆyj).

end for
if ∃A ∈ Φ : A → x(B1, . . . , Bk) ∈ R then

r ←
return A, (r, r1,1, . . . , rk,Tk ), fr(~y1, . . . , ~yk).

A → x(B1, . . . , Bk)
(cid:1)

(cid:0)

.

else

Error; ˆx is not in L(G).

end if
end function

G = (cid:16)Φ = {S}, Σ = {∧, ∨, ¬, x, y},

1
R = {S → ∧(S, S)

2
, S → ∨(S, S)

,

S, (4), f4()

¬

S, (4), f4()

¬

S, (4), f4()

S, (3, 5), f3(f5())

3
S → ¬(S)

4
, S → x

, S → y

5

}, S(cid:17)

y

S, (5), f5()

S, (1, 4, 3, 5), f1(f4(), f3(f5()))

∧

∧

∧

Figure 3: An illustration of the encoding algorithm 1 for the tree ∧(x, ¬(y)). Left: The tree grammar
with enumerated rules (number labels in upper index). From center to right: Each step of the encoding
process with the ﬁnal result highlighted with a box. During encoding, each node is replaced with a triple
of a nonterminal label, a sequence of grammar rules (here as numbers), and a vectorial encoding (here
abstracted via function symbols).

Preprint of Paassen et al. [2020] provided by the authors.

We implement each of the functions fr as a single-layer feedforward neural network, i.e.

fr(~y1, . . . , ~yk) = tanh (cid:16)

W r

1 · ~y1 + . . . + W r

k · ~yk + ~br

(cid:17)

7

(2)

1 , . . . , W r

k and the bias vector ~br ∈ Rn are parameters of fr. Following the
where the n × n matrices W r
reservoir computing paradigm, we do not train these parameters but keep them ﬁxed [Jaeger and Haas,
2004]. In more detail, we initialize a β ∈ (0, 1] fraction of the entries for each matrix as standard normally
distributed random numbers, and then enforce a spectral radius of ρ ∈ (0, 1). We ﬁll the bias vectors
with normally distributed random numbers with zero mean and standard deviation ρ. Note that the
coding dimensionality n, as well as the sparsity β and the spectral radius ρ are hyper-parameters of our
approach.

We remark in passing that the reservoir computing paradigm would suggest that each of the reservoir
matrices W r
j is universal [Jaeger and Haas, 2004, Rodan and Tiňo, 2012]. Accordingly, one could assume
that it suﬃces to initialize one reservoir matrix and re-use it across the entire model instead of initializing a
separate matrix for each argument of each rule. However, using the same reservoir for all input arguments
, which is now an order-invariant function with respect
collapses Equation 2 to tanh
to the input and, as such, strictly less powerful. Still, we will consider this version as a baseline in our
experiments later on.

W · (~x1 + . . . + ~xk)
(cid:1)
(cid:0)

3.3 Tree Decoding

For decoding, we emulate the production process of a regular tree grammar. We begin with the starting
symbol S and the vectorial code ~x for the tree to be decoded. Then, we let a classiﬁer hS : Rn → R
decide which of the possible rules r = S → x(B1, . . . , Bk) with S on the left-hand-side we should apply.
Next, we decode ~x into vectorial codes ~y1, . . . , ~yk for the children. For this step, we use decoding functions
j : Rn → Rn that should extract the information for the jth child from ~x. We then repeat this scheme
gr
recursively until all nonterminal symbols are decoded. We present the decoding scheme more formally in
Algorithm 2.

As an example, consider Figure 4. We start at the top with the vector code for the entire tree and
the starting nonterminal S. The classiﬁer hS then selects the ﬁrst rule S → ∧(S, S) (top right) to apply.
Based on this selection, we know that we need to use the decoding functions g1
2 to obtain vectorial
codings ~y1 and ~y2 for the new children. We then apply the same scheme to the newly created vector
codes and nonterminals until the entire tree is decoded.

1 and g1

Algorithm 2 An algorithm to decode vectors to trees according to a regular tree grammar G =
(Φ, Σ, R, S), classiﬁers hA : Rn → R for each nonterminal A ∈ Φ, and decoding functions gr
j for each rule
r ∈ R and each of its arguments j. The function receives a vector and a nonterminal symbol as input
and returns a decoded tree.

function decode(a vector ~x ∈ Rn, a nonterminal A ∈ Φ)

← hA(~x).

r =
for j ∈ {1, . . . , k} do

A → x(B1, . . . , Bk)
(cid:0)
(cid:1)
~yj ← gr
ˆyj ← decode(~yj, Bj).
~x ← ~x − ~yj.

j (~x).

end for
return x(ˆy1, . . . , ˆyk).

end function

Just as before, we implement the decoding functions gr
j (~x) = tanh(W r

j · ~x + ~br
neural networks, i.e.: gr
parameters of the model. We apply the same initialization scheme for the matrices W r
~br
j as during encoding, and keep the parameters ﬁxed after initialization.

j ), where the matrices W r

j : Rn → Rn using single-layer feedforward
j are
j and the vectors

j and the bias vectors ~br

Preprint of Paassen et al. [2020] provided by the authors.

8

~x, S

hS

g1
1
~y1, S

S → x

hS

g1
2
~y2, S
g3
1

~y2,1, S

hS

hS

S → ∧(S, S)

S → ¬(S)

S → y

Figure 4: An illustration of the decoding algorithm 2 for the tree ∧(x, ¬(y)) (from top to bottom).

3.4 Training

In our model, we only need to train the rule classiﬁers hA for every nonterminal A. For training these
classiﬁers, we need to know the encoding vectors ~x for every nonterminal during the decoding process.
In particular,
Fortunately, we can compute these vectors for our training data using teacher forcing.
recall that Algorithm 1 does not only yield the encoding for the tree, but also a rule sequence that
generates the tree. This sequence contains the desired outputs for all our classiﬁers. Furthermore,
we can use this sequence to decide which rules to apply during decoding, such that we can complete
the entire decoding process without relying on the classiﬁers’ outputs. We describe the details of this
computation in Algorithm 3. Note that this algorithm executes Algorithm 1 ﬁrst and then executes a
modiﬁed version of Algorithm 2 where the decision of the rule classiﬁers hA is replaced by the ground
truth rule sequence. The training data sets DA can be accumulated across an entire training set of
trees and then be used to train the rule classiﬁers hA.
In the example from Figure 4, the training
data would be DS = {(~x, 1), (~y1, 4), (~y2, 3), (~y2,1, 5)} because we should execute the ﬁrst rule when we
encounter the encoding ~x, the fourth rule when we encounter ~y1 = g1
1 (~x), the third rule when we encounter
2 (~x − ~y1), and the ﬁfth rule when we encounter ~y2,1 = g3
~y1 = g1
1 (~y2).

Algorithm 3 An algorithm to generate training data for the rule classiﬁers hA from a tree ˆx according
to a regular tree grammar G = (Φ, Σ, R, S). The algorithm receives a tree ˆx as input and returns a set of
training data for each nonterminal symbol A ∈ Φ.

function train(a tree ˆx)

A, (r1, . . . , rT ), ~x ← encode(ˆx).
Initialize a stack S with ~x on top.
Initialize an empty set DA for each A ∈ Φ.
for t ← 1, . . . , T do

Let rt = A → x(B1, . . . , Bk).
Pop ~xt from the top of S.
Add (~xt, rt) to DA.
for j ← k, . . . , 1 do

j (~xt).

~yj ← grt
Push ~yj onto S.
~xt ← ~xt − ~yj.

end for

end for
return {DA|A ∈ Φ}.

end function

As classiﬁers hA for each nonterminal A ∈ Φ we employ a standard support vector machine [Cortes and Vapnik,

1995].

4 Experiments

In our experimental evaluation we compare four models. First, a variational autoencoder for directed
acyclic graphs (D-VAE) as proposed by [Zhang et al., 2019]; second, the sequence-to-sequence autoen-

Preprint of Paassen et al. [2020] provided by the authors.

9

Table 1: Statistics of the three datasets.

statistic

Boolean

expressions

pysort

no. of trees
no. of nonterminals |Φ|
no. of terminals |Σ|
no. of rules |R|
avg. tree size

500
1
5
5
5.3

500
1
9
9
9.06

51
12
54
54
64.41

coder from Section 3.1, which we call echo-state autoencoder (ES-AE ); third, our tree echo state auto-
enocoder with shared reservoir matrix across all rules (S-TES-AE ); and fourth, our tree echo state
autoencoder with separate weight matrices for each rule (TES-AE ). Generally, we expect the D-VAE
model to do better than all our reservoir computing models because it can adjust all weights instead of
just the output weights. However, we expect that training a D-VAE takes much longer. Between our
echo state models, we expect the TES-AE to do better than the S-TES-AE and the S-TES-AE to do
better than the ES-AE, in alignment with our arguments in Section 3.

We evaluate each model on three datasets. First, a dataset of Boolean expressions (Boolean), which
we generate by applying random rules of the grammar in Figure 3 until at most three binary operators
(and/or) are present.

Second, a dataset of function expressions (expressions) as described by [Kusner et al., 2017]. The
grammar for this dataset is G = ({S}, {+, ∗, /, sin, exp, x, 1, 2, 3}, {S → +(S, S), S → ∗(S, S), S →
/(S, S), S → sin(S), S → exp(S), S → x, S → 1, S → 2, S → 3}, S). We sample expressions by adding one
binary operator to one unary operator to one unary with a binary argument, e.g. 3 ∗ x + sin(x) + exp(2/x),
which is consistent with the training data generated by [Kusner et al., 2017].

Third, a dataset of 51 python programs (pysort ) implementing the insertion sort algorithm or parts
of it. The dataset can be found in the online supplement1. The grammar is the full python language
grammar as documented on https://docs.python.org/3/library/ast.html. The statistics for all
datasets are listed in Table 1.

For the D-VAE model, we used the authors’ reference implementation2. We implemented all echo
state models in python using scikit-learn [Pedregosa et al., 2011] as support vector machine solver. All
implementations are available in the online supplement1. We ran all experiments on a consumer-grade
laptop with Intel core i7 CPU.

4.1 Autoencoding

We ﬁrst evaluate the models in terms of their capacity for autoencoding. As measure of performance, we
m
i=1 d(ˆxi, ψ[φ(ˆxi)])2, where
consider the root mean square error (RMSE), in particular the formula q
ˆxi are the test trees, φ and ψ are the en- and decoding functions of the respective model, and d is the
tree edit distance [Zhang and Shasha, 1989].

1
m P

For the D-VAE model we used the same experimental parameters as in the original paper [Zhang et al.,
2019] because the long training times made hyperparameter optimization prohibitive. However, we used
less epochs (50) and higher learning rate (10−3) to further limit training time. For the echo state
models, we ﬁxed the number of neurons to 256 to achieve a fair comparison between the models and
optimized all other hyperparameters on extra validation data. In particular, for Boolean and expressions
we sampled 100 additional training trees and 100 additional test trees speciﬁcally for hyperparameter
optimization. For pysort we randomly removed 5 training trees and 5 test trees from the main dataset
for hyperparameter optimization. The optimization itself was a random search with 50 trials for Boolean
and expressions and 20 trials for pysort. The precise ranges for each hyper-parameter can be found in
the online supplement1.

For the evaluation itself, we performed a cross-validation with 20 folds on Boolean and expressions
and 10 folds on pysort. To keep training times manageable, we evaluated the D-VAE model only once

1https://gitlab.com/bpaassen/tree_echo_state_autoencoders
2https://github.com/muhanzhang/D-VAE

Preprint of Paassen et al. [2020] provided by the authors.

10

Table 2: Accuracy of all models in terms of RMSE on autoencoding the test data (± standard deviation,
except for D-VAE, which was evaluated only once)

dataset

D-VAE

ES-AE

S-TES-AE

TES-AE

Boolean
expressions
pysort

4.62
5.81
52.07

3.64 ± 0.44
3.87 ± 0.61
64.86 ± 7.00

3.25 ± 0.39
2.65 ± 0.23
16.97 ± 4.30

2.84 ± 0.49
1.69 ± 0.21
17.49 ± 5.04

Table 3: Training time in seconds (± standard deviation, except for D-VAE which it was evaluated only
once).

dataset

D-VAE

ES-AE

S-TES-AE

TES-AE

Boolean
expressions
pysort

757.1
1201.76
13991.5

1.26 ± 0.04
0.85 ± 0.01
0.47 ± 0.02

2.44 ± 0.07
3.37 ± 0.10
0.63 ± 0.11

3.29 ± 0.22
5.06 ± 0.06
10.83 ± 0.76

with a 10% test data split.

We report the RMSEs for all models and all datasets in Table 2. As expected, the S-TES-AE model
clearly outperforms the ES-AE model on all data sets and the TES-AE model outperforms the S-TES-AE
model on the ﬁrst two datasets. These diﬀerences are statistically signiﬁcant in a Wilcoxon sign-rank
test with p < 0.05 after Bonferroni correction. On the pysort dataset, the performance of TES-AE and
S-TES-AE is statistically indistinguishable. Surprisingly, the D-VAE model performed worse than both
tree echo state models on all datasets, which is likely caused by the small amount of training data, the
short training time, and, most of all, the lack of grammatical knowledge encoded in the network. In
particular, we observe that only 34% of the decoded Boolean formulae, 9% of the decoded mathematical
expressions, and none of the decoded python programs conformed to the respective grammar. However,
the architectural bias of D-VAE was suﬃcient to at least achieve a tree structure for 100% of the Boolean
formulae, 95% for the mathematical expressions, and three of ﬁve python programs.

To check how training time inﬂuenced the results, we trained the D-VAE model on the Boolean dataset
again with 300 epochs (just above 2.5 hours of training time), resulting in an RMSE of 3.70 and 42%
grammatical correctness, which is still considerably worse than the TES-AE model.

Regarding runtimes (refer to Table 3), we observe that ES-AE and S-TES-AE are comparably fast on
the Boolean and pysort datasets but the latter is factor 3 slower on the expressions dataset. Furthermore,
TES-AE is considerably slower on all datasets than S-TES-AE (factors 1.5 on the ﬁrst two datasets and
factor 15 on the pysort dataset). This is to be expected as setting up more parameters including a matrix
decomposition for the spectral radius computation for each parameter matrix is expensive. Further, the
parameter matrices for cycle reservoir with jumps [Rodan and Tiňo, 2012] are sparser than our Gaussian
In all cases, however, the
random number initialization, making ES-AE and S-TES-AE even faster.
overall runtime remains within a few seconds time. This is in stark contrast to the D-VAE model, which
took over 10 minutes to train on the Boolean dataset, over 20 minutes for the expressions dataset, and
over 3 hours for the pysort dataset.

4.2 Optimization

Next, we evaluated the capacity for tree optimization in the coding space. For the Boolean dataset, we
considered the logical evaluation of the formula, assuming that x is true and y is false. We assign a score
of 0 if the formula evaluates to false and otherwise as the number of fulﬁlled ∧ terms in the formula.
For example, ∧(x, ¬(y)) would evaluate to 1 because there is one fulﬁlled ’and’ but ∧(y, ∧(x, x)) would
evaluate to 0 because the entire formula evaluates to false.

For the expressions dataset, we used the performance measure of [Kusner et al., 2017], i.e. we evaluated
the arithmetic expressions for 1000 linearly spaced values of x between −10 and +10 and computed the
logarithm of one plus the mean square error to the ground truth function 1/3 + x + sin(x · x).

Preprint of Paassen et al. [2020] provided by the authors.

11

Table 4: The optimized tree and its score for all models for the Boolean and expressions datasets. For
Boolean, higher scores are better and for expressions, lower scores are better.

model

optimal expression

score

Boolean

ES-AE
s-TES-AE
TES-AE

∧(∧(∨(∧(x, x), x), x), ∧(x, ∧(x, ∧(x, x))))
∧(∧(∨(y, x), x), ∧(x, x))
∨(¬(∨(y, ∧(∧(x, x), x))), ∧(∧(∧(y, x)), x))

6
3
3

expressions

ES-AE
s-TES-AE
TES-AE

+(x, /(1, *(1, 3)))
+(/(1, 3), +(x, sin(*(x, x))))
+(x, +(sin(3), sin(*(x, x))))

0.391
0
0.036

x

y

∧

∨

¬

x

∨

y

∧

Figure 5: Left: A t-SNE visualization of the coding space of the TES-AE model on the Boolean dataset.
Each cluster in the visualization is labelled with the root symbol of all trees in the cluster. Right: A
t-SNE visualization of only trees with ¬ at the root; clusters are labelled with the symbol below the root.

Because our coding space was quite high-dimensional (n = 256), we did not perform Bayesian opti-
mization as suggested by [Kusner et al., 2017] but used a Covariance Matrix Adaptation Evolutionary
Strategy (CMA-ES) instead, namely the reference implementation of the python cma package3. To be
comparable with [Kusner et al., 2017], we limited the computational budget to the same value, namely
750 overall function evaluations, which we distributed onto 15 iterations with 50 evaluations each.

The results are shown in Table 4. Note that the results for D-VAE are missing because CMA-ES
failed to generate any grammatical tree which could have been evaluated. Regarding the results of the
echo state models, we note that the sequential echo state autoencoder (ES-AE) performed best on the
Boolean dataset by extrapolating beyond the training data and using seven binary operators instead of
the three that were present in the training data. The TES-AE model also extrapolated, but with less
success. Only the S-TES-AE model remained within the boundaries of the training data and achieved
the best possible value within it.

Regarding the expression dataset, both TES-AE variations found a solution at least as good as the
grammar variational autoencoder of [Kusner et al., 2017] and the s-TES-AE model even found the ground
truth. Overall, the s-TES-AE model appears to be best suited for optimization on these tasks.

4.3 Coding Spaces

If we inspect the encoding spaces of the TES-AE model in more detail, we observe clusters dependent
on root symbol of the tree. For example, Figure 5 (left) shows a t-SNE dimensionality reduction of the
Boolean dataset as encoded by the TES-AE model with each cluster labelled with the root symbol. In
Figure 5 (right), we observe that the ¬ cluster further spreads into clusters according to the symbol
just below the root. This fractal coding is consistent with prior work on recurrent networks with small
weights, which have been shown to code fractally based on the most recent symbol [Tiňo and Hammer,
2003].

3https://github.com/CMA-ES/pycma

Preprint of Paassen et al. [2020] provided by the authors.

12

5 Conclusion

In this paper, we introduced tree echo state autoencoders (TES-AE), a novel neural network architecture
to implement autoencoding for trees without the need for deep learning. In particular, we used regular
tree grammars to express our trees as sequences of grammar rules and then employed echo state networks
and tree echo state networks for encoding and decoding.
In our experiments on three datasets, we
found that a TES-AE outperformed a variational auto-encoder for acyclic graphs (D-VAE) in terms
of autoencoding error on small datasets with limited training time. Further, we showed that TES-AE
signiﬁcantly outperform a sequential version of the model (ES-AE) and that separate parameters for each
grammar rule outperform shared parameters. Our results also showed that a few seconds suﬃced to train
our model even for a large grammar and large trees, whereas D-VAE training, even with a small number
of epochs, took ten minutes to several hours. Finally, we observed that optimization in the TES-AE
coding space performed similarly compared to past reference results [Kusner et al., 2017].

Future research could investigate how well our autoencoders are suitable to time series prediction,
how memory capacity results translate to the tree domain, how to apply our architecture to trees with
real-valued nodes, and whether our proposed echo state sequence-to-sequence learning model using echo
state networks is suitable to solve sequence tasks that currently require deep learning.

References

Alfred Aho, Monica Lam, Ravi Sethi, and Jeﬀrey Ullman. Compilers: Principles, Techniques, and Tools.

Addison Wesley, Boston, MA, USA, 2 edition, 2006.

Fabio Aiolli, Giovanni Da San Martino, and Alessandro Sperduti. An eﬃcient topological distance-based
tree kernel. IEEE Transactions on Neural Networks and Learning Systems, 26(5):1115–1120, 2015.
doi:10.1109/TNNLS.2014.2329331.

Davide Bacciu, Alessio Micheli,

and Marco Podda.

edge

prediction.

tial
ropean
https://www.elen.ucl.ac.be/Proceedings/esann/esannpdf/es2019-107.pdf.

Symposium on Artiﬁcial Neural Networks

In Michel Verleysen,

(ESANN 2019),

editor,

Graph
Proceedings

generation
of

by

sequen-
27th Eu-
URL

the
2019.

Walter S. Brainerd. Tree generating regular systems. Information and Control, 14(2):217 – 231, 1969.

doi:10.1016/S0019-9958(69)90065-5.

Michael Collins and Nigel Duﬀy.

New ranking algorithms for parsing and tagging: Kernels
over discrete structures, and the voted perceptron.
In Proceedings of the 40th Annual Meet-
ing of the Association for Computational Linguistics (ACL 2002), pages 263–270, 2002. URL
http://www.aclweb.org/anthology/P02-1034.pdf.

H. Comon, M. Dauchet, R. Gilleron, C. Löding, F. Jacquemard, D. Lugiez, S. Tison, and
URL

Tree Automata Techniques and Applications.

inria gforge, 2008.

M. Tommasi.
http://tata.gforge.inria.fr/.

Corinna Cortes and Vladimir Vapnik. Support-vector networks. Machine Learning, 20(3):273–297, Sep

1995. doi:10.1007/BF00994018.

Hanjun Dai, Yingtao Tian, Bo Dai, Steven Skiena, and Le Song.

the 6th International Conference on Learning Representations (ICLR 2018), 2018.

Syntax-directed variational
In Yoshua Bengio and Yann LeCun, editors, Proceedings
URL

autoencoder for structured data.
of
https://openreview.net/forum?id=SyqShMZRb.

Igor Farkaš, Radomír Bosák, and Peter Gergeľ. Computational analysis of memory capacity in echo state

networks. Neural Networks, 83:109 – 120, 2016. doi:10.1016/j.neunet.2016.07.012.

Claudio Gallicchio and Alessio Micheli. Tree echo state networks. Neurocomputing, 101:319 – 337, 2013.

doi:10.1016/j.neucom.2012.08.017.

Barbara Hammer. Recurrent networks for structured data - A unifying approach and its properties.

Cognitive Systems Research, 3(2):145 – 165, 2002. doi:10.1016/S1389-0417(01)00056-0.

Preprint of Paassen et al. [2020] provided by the authors.

13

Barbara Hammer, Alessio Micheli, Alessandro Sperduti, and Marc Strickert. Recursive self-organizing

network models. Neural Networks, 17(8):1061 – 1085, 2004. doi:10.1016/j.neunet.2004.06.009.

Herbert Jaeger and Harald Haas. Harnessing nonlinearity: Predicting chaotic systems and saving energy

in wireless communication. Science, 304(5667):78–80, 2004. doi:10.1126/science.1091277.

Thomas Kipf and Max Welling. Semi-supervised classiﬁcation with graph convolutional networks. In
Yoshua Bengio and Yann LeCun, editors, Proceedings of the 5th International Conference on Learning
Representations (ICLR 2017), 2017. URL https://openreview.net/forum?id=SJU4ayYgl.

Kevin Knight and Jonathan Graehl. An overview of probabilistic tree transducers for natural language
processing. In Alexander Gelbukh, editor, Computational Linguistics and Intelligent Text Processing,
pages 1–24. Springer Berlin Heidelberg, 2005.

Matt J. Kusner, Brooks Paige, and José Miguel Hernández-Lobato. Grammar variational au-
the 34th In-
URL

toencoder.
ternational Conference on Machine Learning (ICML 2017), pages 1945–1954, 2017.
http://proceedings.mlr.press/v70/kusner17a.html.

In Doina Precup and Yee Whye Teh,

editors, Proceedings of

Qi Liu, Miltiadis Allamanis, Marc Brockschmidt, and Alexander Gaunt. Constrained graph varia-
tional autoencoders for molecule design.
In S. Bengio, H. Wallach, H. Larochelle, K. Grauman,
N. Cesa-Bianchi, and R. Garnett, editors, Proceedings of the 31st International Conference on
Advances in Neural Information Processing Systems (NeurIPS 2018), pages 7795–7804. 2018. URL
http://papers.nips.cc/paper/8005-constrained-graph-variational-autoencoders-for-molecule-design.pdf.

Benjamin Paassen, Irena Koprinska, and Kalina Yacef. Tree echo state autoencoders with grammars. In
Asim Roy, editor, Proceedings of the 2020 International Joint Conference on Neural Networks (IJCNN
2020), 2020. accepted.

Benjamin Paaßen, Claudio Gallicchio, Alessio Micheli, and Barbara Hammer.

tance Learning via Adaptive Symbol Embeddings.
itors, Proceedings of
volume 80 of Proceedings of Machine Learning Research, pages 3973–3982, 2018a.
http://proceedings.mlr.press/v80/paassen18a.html.

Tree Edit Dis-
In Jennifer Dy and Andreas Krause, ed-
the 35th International Conference on Machine Learning (ICML 2018),
URL

Benjamin Paaßen, Barbara Hammer, Thomas Price, Tiﬀany Barnes, Sebastian Gross, and
The continuous hint factory - providing hints in vast and sparsely pop-
URL

Niels Pinkwart.
ulated edit distance spaces.
https://jedm.educationaldatamining.org/index.php/JEDM/article/view/158.

Journal of Educational Datamining, 10(1):1–35, 2018b.

Benjamin Paaßen, Claudio Gallicchio, Alessio Micheli, and Alessandro Sperduti. Embeddings and repre-
sentation learning for structured data. In Michel Verleysen, editor, Proceedings of the 27th European
Symposium on Artiﬁcial Neural Networks, Computational Intelligence and Machine Learning (ESANN
2019), pages 85–94, 2019. URL https://arxiv.org/abs/1905.06147.

F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Pretten-
hofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, and
E. Duchesnay. Scikit-learn: Machine learning in Python. Journal of Machine Learning Research, 12:
2825–2830, 2011.

Ali Rodan and Peter Tiňo. Simple deterministically constructed cycle reservoirs with regular jumps.

Neural Computation, 24(7):1822–1852, 2012. doi:10.1162/NECO_a_00297.

Alessandro Sperduti and Antonina Starita. Supervised neural networks for the classiﬁcation of structures.

IEEE Transactions on Neural Networks, 8(3):714–735, 1997. doi:10.1109/72.572108.

Ilya Sutskever, Oriol Vinyals,

and Quoc V Le.

Sequence

to sequence

neural networks.
Neural
http://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural.

the 27th International Conference on Advances
(NeurIPS 2014), pages 3104–3112,

In Proceedings of
Information Processing Systems

2014.

learning with
in
URL

Preprint of Paassen et al. [2020] provided by the authors.

14

Peter Tiňo and Barbara Hammer. Architectural bias in recurrent neural networks: Fractal analysis.

Neural Computation, 15(8):1931–1957, 2003. doi:10.1162/08997660360675099.

David Weininger. Smiles, a chemical language and information system. 1. introduction to methodology
and encoding rules. Journal of Chemical Information and Computer Sciences, 28(1):31–36, 1988.
doi:10.1021/ci00057a005.

Jiaxuan You, Rex Ying, Xiang Ren, William Hamilton, and Jure Leskovec. GraphRNN: Generating real-
istic graphs with deep auto-regressive models. In Jennifer Dy and Andreas Krause, editors, Proceedings
of the 35th International Conference on Machine Learning (ICML 2018), pages 5708–5717, 2018. URL
http://proceedings.mlr.press/v80/you18a.html.

Kaizhong Zhang and Dennis Shasha. Simple fast algorithms for the editing distance between trees and

related problems. SIAM Journal on Computing, 18(6):1245–1262, 1989. doi:10.1137/0218082.

Muhan Zhang, Shali Jiang, Zhicheng Cui, Roman Garnett, and Yixin Chen. D-vae: A varia-
tional autoencoder for directed acyclic graphs.
In H. Wallach, H. Larochelle, A. Beygelzimer,
F. d'Alché-Buc, E. Fox, and R. Garnett, editors, Proceedings of the 32nd International Conference on
Advances in Neural Information Processing Systems (NeurIPS 2019), pages 1586–1598. 2019. URL
http://papers.nips.cc/paper/8437-d-vae-a-variational-autoencoder-for-directed-acyclic-graphs.pdf.

