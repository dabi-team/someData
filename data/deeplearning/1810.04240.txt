Deep Neural Network Compression for Aircraft
Collision Avoidance Systems

Kyle D. Julian1 and Mykel J. Kochenderfer2 and Michael P. Owen3

8
1
0
2

t
c
O
9

]

G
L
.
s
c
[

1
v
0
4
2
4
0
.
0
1
8
1
:
v
i
X
r
a

Abstract—One approach to designing decision making logic for
an aircraft collision avoidance system frames the problem as a
Markov decision process and optimizes the system using dynamic
programming. The resulting collision avoidance strategy can be
represented as a numeric table. This methodology has been used
in the development of the Airborne Collision Avoidance System X
(ACAS X) family of collision avoidance systems for manned and
unmanned aircraft, but the high dimensionality of the state space
leads to very large tables. To improve storage efﬁciency, a deep
neural network is used to approximate the table. With the use of
an asymmetric loss function and a gradient descent algorithm, the
parameters for this network can be trained to provide accurate
estimates of table values while preserving the relative preferences
of the possible advisories for each state. By training multiple
networks to represent subtables, the network also decreases the
required runtime for computing the collision avoidance advisory.
Simulation studies show that the network improves the safety
and efﬁciency of the collision avoidance system. Because only the
network parameters need to be stored, the required storage space
is reduced by a factor of 1000, enabling the collision avoidance
system to operate using current avionics systems.

I. INTRODUCTION

Decades of research have explored a variety of approaches
to designing decision making logic for aircraft collision
avoidance systems for both manned and unmanned aircraft
[1]. Recent work on formulating the problem of collision
avoidance as a partially observable Markov decision process
(POMDP) has led to the development of the Airborne Collision
Avoidance System X (ACAS X) family of collision avoidance
systems [2], [3], [4]. The version for manned aircraft, ACAS
Xa, is expected to become the next international standard for
large commercial transport and cargo aircraft. The variant for
unmanned aircraft, ACAS Xu, uses dynamic programming to
determine horizontal or vertical resolution advisories in order
to avoid collisions while minimizing disruptive alerts. ACAS
Xu was successfully ﬂight tested in 2014 using NASA’s Ikhana
aircraft [5].

The dynamic programming process for creating the ACAS
Xu horizontal decision making logic results in a large numeric
lookup table that contains scores associated with different
maneuvers from millions of different discrete states. The
table is extremely large, requiring hundreds of gigabytes of

1Kyle D. Julian is a Ph.D. candidate in the Department of Aero-
and Astronautics, Stanford University, Stanford, CA, 94305

nautics
kjulian3@stanford.edu

2Mykel J. Kochenderfer is an Assistant Professor in the Department of
Aeronautics and Astronautics, Stanford University, Stanford, CA, 94305
mykel@stanford.edu

3Michael P. Owen is a member of

the Technical Staff at Lincoln
Laboratory, Massachusetts Institute of Technology, Lexington, MA, 02421
michael.owen@ll.mit.edu

ﬂoating point storage. A simple technique to reduce the size
of the score table is to downsample the table after dynamic
programming. To minimize the degradation in decision quality,
states are removed in areas where the variation between values
in the table are smooth. The downsampling reduces the size
of the table by a factor of 180 from that produced by dynamic
programming. For the rest of this paper, the downsampled
ACAS Xu horizontal
table is referred to as the baseline,
original table.

Even after downsampling, the current table requires over
2GB of ﬂoating point storage, too large for certiﬁed avionics
systems [6]. Although modern hardware can handle 2GB of
storage, the certiﬁcation process for aircraft computer hard-
ware is expensive and time-consuming, so a solution capable
of running on legacy hardware is desired [7]. While there is
no formal limit for ﬂoating point storage on legacy avionics, a
representation occupying less than 120MB would be sufﬁcient.
For an earlier version of ACAS Xa, block compression was
introduced to take advantage of the fact that, for many discrete
states, the scores for the available actions are identical [8]. One
critical contribution of that work was the observation that the
table could be stored in IEEE half-precision with no apprecia-
ble loss of performance. Block compression was adequate for
the ACAS Xa tables that limit advisories to vertical maneuvers,
but the ACAS Xu tables for horizontal maneuvers are much
larger. Recent work explored a new algorithm that exploits the
score table’s natural symmetry to remove redundancy within
the table [9]. However, results showed that this compression
algorithm could not achieve sufﬁcient reduction in storage
before compromising performance.

Discretized score tables like this can be represented as
Gaussian processes [10] or kd-trees [11]. Decision trees offer
a way to compress the table by organizing the data into a tree
structure to remove table redundancy. In addition a decision
tree can increase compression by simplifying areas of the table
with low variance, although this will result in a lossy compres-
sion. Decision trees are a popular machine learning algorithm
and have been applied to numerous problems including land
cover classiﬁcation and energy consumption prediction [12],
[13].

Other approaches to compressing the table seek to ﬁnd a
robust nonlinear function approximation that represents the
table. Linear regression is popular for smaller datasets, but
this approach does not generalize well for large datasets with
many more examples than features. Support Vector Machines
(SVM) are also a popular regression algorithm. By storing
only the supporting vectors found by the algorithm, less data
would need to be stored, effectively compressing the dataset.

 
 
 
 
 
 
However, SVMs struggle with large datasets. Solving the SVM
quadratic program has computational cost that scales at least
with the square of the number of examples [14]. Because the
ACAS Xu table has millions of entries, SVMs would not be
effective in regressing the score table.

Neural networks, which can serve as a robust global func-
tion approximator when trained using supervised learning,
can represent large datasets and are trained efﬁciently. Neural
networks have been employed for regression applications in
the aerospace ﬁeld since the 1990s, including aircraft control
systems, aircraft design, and impact detection on structural
panels [15], [16], [17]. These applications use datasets with
only a few hundred training examples, so small neural net-
works with one or two hidden layers are effective. However,
to accurately represent 2GB of ﬂoating point values, a larger
network is required.

Recent works have shown that deep neural networks, or
neural networks with more than two hidden layers, represent
data more efﬁciently than shallow networks. It can be shown
that the number of linear regions represented by neural net-
works grows exponentially with the depth and polynomially
with the layer size, so a deeper network can represent more
information than a shallow network [18]. In addition, it was
shown that a three-layer network cannot be approximated
by a two-layer to arbitrary accuracy unless the layer size is
expanded exponentially [19]. Previously, neural networks were
limited in depth due to activation saturation problems when
using sigmoid activation functions [20], but a new piecewise-
linear activation function, rectiﬁed linear units (ReLUs), were
shown to be well suited for training deep neural networks
[21]. These advancements enable neural networks to efﬁciently
regress large amounts of data like the ACAS Xu collision
avoidance table.

This paper explores the use of deep neural networks for
compressing the score table without loss of performance as
measured by a set of safety and operational metrics. Using
an asymmetric loss function during training ensures that the
approximation is able to maintain the actions recommended
by the original table while providing good estimates of the
original score table values, but the required runtime is signiﬁ-
cantly increased. Methods for eliminating the runtime increase
are explored that lead to an approach that produces advisories
more quickly than the original table. Further studies into ﬁne-
tuning the network training process enable the neural network
to predict table values with even greater accuracy.

Standard safety and operational performance metrics were
used to evaluate the network performance in simulation. These
metrics are calculated by simulating millions of encounters
with varied encounter geometries and sensor noise. Although
the deep neural network reduces the required memory by a
factor of 1000, it also improves the performance of the ACAS
Xu system on most performance metrics evaluated in this
paper with only one operational metric slightly degraded. The
neural network representation is a continuous function that
smooths out artifacts from interpolation of the original discrete
representation, allowing the network to surpass the system it
was trained to represent.

Section II provides an overview of the score table used in

the ACAS Xu horizontal logic. Section III explores common
machine learning approaches. Section IV describes the deep
neural network approach to table compression. Section V
discusses ways to ensure online computation does not increase
required runtime. Section VI discusses techniques for making
the table easier for the neural network to regress. Section
VII discusses performance results computed in simulation.
Conclusions are presented in Section VIII.

II. SCORE TABLE

The ACAS Xu score table associates values to combinations
of actions and state variables. The actions in the score table
are the horizontal resolution advisories given to the ownship.
These advisories tell the vehicle either it is Clear-of-Conﬂict
(COC) or that it should turn left or right at one of two speciﬁed
heading rates, 1.5 deg/s (weak) or 3.0 deg/s (strong). Hence,
there are ﬁve possible actions: COC, weak left (WL), weak
right (WR), strong left (SL), and strong right (SR).

There are seven state variables that deﬁne an aircraft en-

counter [4]:

1) ρ (ft): Distance from ownship to intruder
2) θ (rad): Angle to intruder relative to ownship heading

direction

3) ψ (rad): Heading angle of intruder relative to ownship

heading direction

4) vown (ft/s): Speed of ownship
5) vint (ft/s): Speed of intruder
6) τ (sec): Time until loss of vertical separation
7) aprev (deg/s): Previous advisory

ψ

vint

Intruder

vown

ρ

Ownship
θ

Fig. 1. Geometry for ACAS Xu horizontal logic table

The ﬁrst ﬁve state variables describe the geometry of a 2D
encounter between two aircraft, as seen in Fig. 1. In addition,
τ describes the encounter geometry vertically and extends
the encounter geometries to 3D. Lastly, aprev speciﬁes the
previous advisory to enable consistency when choosing the
next advisory. The state variables are discretized, forming a
seven dimensional grid with 120 million discrete points.

The optimal advisory for a given state can be extracted from
the score table. If Q is the real-valued function associated with
the eight-dimensional score table, then the optimal action is

a∗ = arg max

a

Q(ρ, θ, ψ, vown, vint, τ, aprev, a)

(1)

Furthermore, Equation (1) deﬁnes the score table’s policy by
mapping all possible states to actions. In general, the values
of the state variables, as determined by the sensors in real
time, do not fall exactly on the grid points, in which case
nearest-neighbor interpolation is used.

Since the surveillance sensors used by the aircraft are
imperfect, there may be uncertainty in the current state mea-
surement. To improve the robustness of the system to this
uncertainty [22], ACAS Xu uses an unscented Kalman ﬁlter
[23] to arrive at a set of weighted state-space samples. These
weighted samples can then be used to compute the best action:
(cid:88)

a∗ = arg max

b(s(i))Q(s(i), a)

(2)

a

i
where s(i) is the ith state sample and b(s(i)) is its associated
weight.

Although the state space speciﬁes an encounter with a single
intruder, multi-intruder encounters can use the same collision
avoidance table by using utility fusion [4]. The action scores
can be computed for each intruder and then fused into a
single action by considering only the worst-case intruder or
by summing the action scores for each intruder and taking
the action with the best score [4]. Therefore, representing the
collision avoidance policy as action scores allows the single
intruder policy to be extended to multi-intruder scenarios.

III. BASELINE TABLE REGRESSION METHODS

With 600 million ﬂoating point numbers, the table requires
over 2GB of storage. Compression algorithms that exploit
table symmetries to reduce redundancies could not adequately
compress the large score table [8], [9]. As a result, machine
learning algorithms for lossy compression were explored.

Linear regression works well for small datasets, but with
120 million training examples and only seven features, a linear
mapping from features to output values will be too simple to
be accurate. Linear regression approximates the table values
as ˆy = XW , where the weights W can be optimized to
minimize the squared error using W = (X T X)−1X T y. After
calculating the weights, the root mean squared error (RMSE)
is 17.9, which is approximately the standard deviation of the
table values. A more complex model is necessary for this
application.

Although Support Vector Machines (SVM) can represent
complex data, SVMs regress very slowly for large datasets,
rendering them a poor choice for this application with a
large number of training examples [14]. Image compression
algorithms like JPEG2000 or Huffman encoding can enable
efﬁcient storage and transmission of data ﬁles, but the data
will have to be uncompressed and loaded into memory at
runtime. Furthermore, the entire dataset must be loaded into
memory to enable multi-intruder tracking, so the compressed
representation must efﬁciently represent the entire table.

With these considerations, decision trees are the best al-
ternative to a neural network approach. Decision trees are
a popular regression algorithm and work well given large
data sets. The size of the decision trees can be controlled by
setting a maximum depth of the tree. At each level in the
decision tree, an input variable is compared with a threshold,

splitting the table data into two different sets. These decision
nodes are chosen to minimize the variance in the split datasets
through use of the Gini impurity [24]. The algorithm begins
by determining the root decision and then builds the tree layer
by layer until the maximum depth is reached. The ﬁnal layer
is composed of leaf nodes, which store the average scores
of the data in the leaf node. When making a prediction, a
new state is passed through the decision tree, splitting at each
decision node until arriving at a leaf node where the stored
values become the predicted values.

The amount of storage required to represent the decision
tree can be computed by multiplying the number of nodes
in the tree with the size of each node. Decision nodes will
need to store the decision feature and threshold as well as
pointers to children nodes, while leaf nodes will need to store
the estimated table values. While larger trees can represent
the score table more accurately, they require more storage.
The Scikit-learn machine learning library was used to create
decision trees for the ACAS Xu score table [25].

One way to assess the quality of the compression is to
plot the actions recommended by the original table and the
compressed strategies. Because the input space is seven di-
mensional, the plots only show variations in ρ and θ, which are
converted to Cartesian coordinates, while the other inputs are
constant. Figure 2 shows top-down views of encounters with
the ownship centered at the origin and ﬂying in the direction
indicated while the intruder vehicle is ﬂying in the direction
shown by the aircraft in the upper right corner of the plots.
The color at each point in the plot shows the advisory the
collision avoidance system would issue if the intruder were
at that location. Figure 2 shows the policy plots of regressed
decision trees of different sizes. Increasing the maximum depth
improves accuracy, although there are still errors between the
decision tree and original policy.

In addition, aggregate metrics were computed to assess
compression quality. The decision trees can be used to predict
the scores for every discretized state represented by original
table. By comparing the predicted scores with the original
table scores,
the root mean squared error (RMSE) of the
values can be computed. In addition, the overall policy error is
calculated using Eq. (1) and comparing the optimal actions of
the decision tree and original table. The tradeoff between tree
size and compression error is plotted in Fig. 3. Using decision
trees that are at most 100 MB in size, the RMSE exceeds 3.0
with a policy error rate of over 6%, which could result in
signiﬁcant changes to system performance. By contrast, the
neural network representation, as discussed in the remainder
of this paper, can accurately represent the table values with
only 2.4 MB of storage.

IV. NEURAL NETWORK COMPRESSION

This section explains the development of a deep neural

network approximation of the score table.

A. Neural Network Formulation

Rather than storing all of the table scores explicitly or using
a tree approximation, the values of the table can be represented

(a)

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

20

10

0

(b)

20

10

0

WR

WL

COC

SR

SL

(c)

20

10

0

(d)

20

10

0

0

10

20

0

10

20

0

10

20

0

10

20

Downrange (kft)

Downrange (kft)

Downrange (kft)

Downrange (kft)

Fig. 2. Policies for (a) original table, (b) 2.56MB decision tree, (c) 19.4MB decision tree, and (d) 126MB decision tree

Decision Tree
Original Table
Neural Network

100

102

101
Tree Size (MB)

103

Decision Tree
Original Table
Neural Network

s
e
r
o
c
S

f
o

E
S
M
R

6

4

2

0

y
c
i
l
o
P

n
i

r
o
r
r
E

t
n
e
c
r
e
P

20

10

0

100

102

101
Tree Size (MB)

103

Fig. 3. Decision tree Pareto frontiers for accuracy in scores (top) and policy
(bottom)

as a nonlinear, parametric function that takes as input the val-
ues of the state variables and outputs the scores of the various
actions. Instead of storing the table itself, only the parameters
of the function need to be stored, which could signiﬁcantly
decrease the amount of storage required to represent the table.
Deep neural networks are large, nonlinear functions that can be
trained to approximate complex multidimensional target data
[26]. A feed-forward neural network is composed of inputs
that are weighted and summed into a layer of perceptrons.
The value at each perceptron then passes through an activation
function before being weighted and summed again to form
the next
layer of perceptrons. In a deep neural network,
there are multiple layers, called hidden layers, before reaching
the last layer, or output layer, which represents the function

Input
Layer

Hidden
Layer 1

Hidden
Layer 2

Output
Layer

Σ

Σ

Σ

Σ

Σ

Σ

Σ

Σ

Σ

Σ

Σ

Σ

Σ

Σ

Σ

Σ

Σ

QCOC

QWL

QWR

QSL

QSR

ρ

θ

ψ

vown

vint

τ

aprev

Fig. 4. Neural network diagram

approximation for the score table. The weights and biases of
the network can be trained so that a given set of inputs will
accurately compute the score table values. The choices of the
neural network architecture and features can help the network
to train quickly and accurately. Figure 4 shows an example
diagram of a fully-connected network with two hidden layers
and rectiﬁed linear unit activations (ReLU) [27], which only
allow positive inputs to pass through to the next layer.

The deep neural network uses fully-connected feed-forward
layers with ReLU activation after each hidden layer. The
network has seven inputs, one for each of the seven state
variables. The output layer consists of ﬁve output nodes, one
for each possible advisory: QCOC, QWL, QWR, QSL, and QSR.
With this approach, one forward pass through the network
computes the score values for each of the ﬁve advisories.

B. Loss Function

Initially, the network parameters are random, and the net-
work performs poorly. A loss function is used to compute
the network error, and the gradient of the loss is back-
propagated through the network to update network parameters
and improve performance. For typical regression problems,
is simple,
mean squared error (MSE) is used because it

differentiable, and fast
to compute. When applied to the
problem of learning score table values, MSE gives accurate
approximations. However, there is no longer a guarantee that
the optimal advisory remains the same. For many of the states
in the score table, the difference between the scores of the ﬁrst
and second best advisories is relatively small. When MSE fails
to maintain the order of the actions, the network’s collision
avoidance strategy can be very different from that of the
original table.

Predicting the optimal action given a set of inputs is
a classiﬁcation problem often solved with categorical cross
entropy loss [28]. This approach can predict optimal actions
well, but there is no regard for representing the score values.
It is important to capture the score values too in order to
compute the optimal advisory over a weighted set of states
using Eq. (2).

it

To get the numeric accuracy of MSE with the classiﬁ-
cation accuracy of categorical cross entropy, an asymmetric
version of MSE was used. Asymmetric loss functions have
been used to train neural networks when positive or negative
errors are not identical [29]. The asymmetric loss function
for collision avoidance, shown in Fig. 5 is based on MSE,
but
increases the penalty by a factor when the neural
network under-estimates the score of optimal advisories or
over-estimates the score of sub-optimal advisories. The factor
applied to the optimal advisory is four times greater than the
suboptimal advisories to balance the fact that there are four
sub-optimal advisories for every optimal advisory. Because
the network parameters are updated to minimize the loss, the
neural network attempts to eliminate any errors in the score
predictions. If the network predictions have small errors, the
asymmetric loss function encourages the network to over-
estimate the scores of the optimal advisories while under-
estimating the scores of suboptimal advisories, which will
not change the policy when using Eq. (1). Therefore, the
asymmetric loss function encourages the neural network to
maintain the optimal advisories of the score table while also
learning accurate representations of the table values.

20

15

s
s
o
L

10

5

0
−1

Optimal Advisories
Suboptimal Advisories

−0.5

0

0.5

1

Score Estimate Error

Fig. 5. Asymmetric loss function penalties

The advantage of the asymmetric loss function over regular
MSE can be visualized through the confusion matrices shown
in Fig. 6. Each row is normalized to add up to 100% and
represents the percentage of states where the neural network

selected a particular advisory given the advisory of the original
table.

y
r
o
s
i
v
d
A
e
l
b
a
T

e
r
o
c
S

SR

WR

COC

WL

SL

SL WL COC WR SR

SL WL COC WR SR

Network Advisory

Network Advisory

100%

80%

60%

40%

20%

0%

Fig. 6. Confusion matrices for nominal (left) and asymmetric (right) MSE
losses

The entries on the main diagonal represent the percentage of
advisories correctly classiﬁed by the neural network, while the
off-diagonal entries show mis-classiﬁcations. For the turning
advisories, the asymmetric loss function is much better at
maintaining advisories and achieves on-diagonal percentages
of 90–94% while the nominal MSE loss function maintains
advisories only 72–74% of the time.

C. Model Architecture

Optimizing the network architecture can be challenging
because there are many parameters to vary and evaluation
of the different architectures can be slow. One important
consideration in training deep neural networks is to select
and tune the optimizer used to update the parameters and
weights of the network. Different optimizers were evaluated
including RMSprop [30], Adagrad [31], Adadelta [32], and
Adam [33]. A variant of Adam, known as AdaMax [33],
proved to learn the quickest without becoming stuck in local
optima. In addition, AdaMax requires relatively little tuning
of parameters because it uses estimates of the lower-order
moments of the gradient to anneal the step size of the gradient
descent [33].

After selecting AdaMax for the optimizer, different network
architectures were investigated. A baseline architecture was
chosen with ﬁve hidden layers and a set of layer sizes that is
larger early in the network and tapers to smaller layer sizes
towards the end of the network. This approach allows for the
network to ﬁnd increasingly more abstract representations of
the data, similar to the approach with convolutional neural
networks in image classiﬁcation [26]. The layer sizes were also
chosen so that the total number of parameters in the network
would be around 600,000, as this would mean the table
could be compressed to occupy only a few megabytes when
using ﬂoating point precision. To test the baseline architecture,
the number of hidden layers was varied to see the effect
on the regression performance, but six hidden layers proved
to give the best results with additional layers yielding little
improvement. Figure 7 shows the network loss during training
for the different network optimizers and number of layers. As
a result of this study, a neural network with six hidden layers
and AdaMax optimization was chosen.

s
s
o
L

e
g
a
r
e
v
A

10−2

10−3

10−4

10−5

10−6

0

10−4

s
s
o
L

e
g
a
r
e
v
A

10−5

Adadelta
Adagrad
AdaMax
RMSprop
Adam

TABLE I
SIMULATION COMPARISON

Representation

P(NMAC)

P(Alert)

P(Reversal) Relative
Runtime

Original Table
Neural Network

1.546×10−4
1.272×10−4

0.55485
0.53128

0.007438
0.006903

1×
50×

100

200

300

Number of Training Epochs

3 HL
4 HL
5 HL
6 HL
7 HL

10−6

0

200

400

600

Number of Training Epochs

Fig. 7. Training curves for different optimizers (top) and number of hidden
layers (bottom)

D. Implementation

The deep neural network was trained in Python using the
Keras library [34] running on top of Theano [35]. To reduce
training time, the deep neural network was trained using an
NVIDIA DIGITS DevBox with four Titan X GPUs. Before
training, the score table and inputs were normalized to have
zero mean and unit range, which helps the network train more
quickly [36]. For each training epoch, the table data was
shufﬂed and passed through the network in batches of 216
samples. The network was trained for 1200 training epochs
over the course of four days.

E. Results

Figure 8 shows the policies for three different encounter
geometries. Figure 8 illustrates that increasing τ shrinks the
strong alerting region because the aircraft have greater vertical
separation, and changing aprev to WR yields a policy that
favors right turns in order to reduce reversals. Qualitatively
the plots show that the neural network is a continuous ap-
proximation of the discrete table, which uses nearest-neighbor
interpolation. Overall compression quality is computed by
evaluating the network at each discrete state in the table
and comparing the predicted scores to the table scores. The
network’s predictions have RMSE of 0.923 with a policy error

of 2.02%, which is lower than all but the largest baseline
decision trees shown in Fig. 3. Given that the neural network
requires only 2.4 MB of ﬂoating point storage, the neural
network method is an efﬁcient and accurate compression
approach.

To evaluate operational performance of the neural network,
the network was evaluated in 1.5 million simulated 3D encoun-
ters with varied encounter conﬁgurations and sensor noise.
Overall performance metrics were computed from the simu-
lation results that quantify the overall safety and efﬁciency of
the system. Four performance metrics were considered with
the desire to minimize all four metrics:

1) P(NMAC): the probability of a near mid-air collision
2) P(Alert): the probability that the system will give an alert
3) P(Reversal): the probability that the system will reverse

the direction of its advisory

4) Relative Runtime: required runtime to compute an ad-

visory, normalized to the original score table

The aggregate results from the simulations are shown in
Table I. The neural network outperforms the table in the three
performance probability metrics. However, due to the large
amount of computation required to compute the score values
using the deep neural network, the runtime is increased by a
factor of 50. This is a signiﬁcant increase that is addressed in
the next section.

In addition the score table was modiﬁed to optimize for a
new parameter: P(Split), the probability that the turning alerts
given by the system will be split by COC advisories. This
behavior is undesirable because the system alerted that the
encounter was clear of conﬂict before the threat was ﬁnished.
It was found that the existing score table had issues with large
numbers of split advisories, so the values were updated to
address this issue. As a result, the neural networks presented in
the remainder of this work use the updated table and optimize
for P(Split).

V. IMPROVING NETWORK RUNTIME

As described in the previous section, a large increase
in runtime is a signiﬁcant drawback of the neural network
compression. Although each forward propagation requires an
average of 0.6 ms of computation on a modern computer,
this computation will be performed on slower legacy avionics
systems. In addition, multiple states in a weighted set must
be evaluated, and look-aheads to determine duration of an
advisory further increase the number of evaluated points.
Furthermore, the system must be able to handle encounters
where up to 30 intruders are present, which means hundreds of
forward propagations and any additional computation must be
able to run within the allotted one second between advisories.

10

0

−10

10

0

−10

(a)

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

(b)

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

(c)

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

30

20

10

0

Score Table

Neural Network

SR
SL

WR

WL

10

0

COC

−10

0

10

20

30

0

10

20

30

Score Table

Neural Network

10

0

−10

0

10

20

30

0

10

20

30

Score Table

Neural Network

30

20

10

0

0

10

20

30

40

0

10

20

30

40

Downrange (kft)

Downrange (kft)

Fig. 8. Policy plots of the original table and neural network representation for (a) head-on encounter with aprev = COC and τ = 0s, (b) head-on encounter
with aprev = COC and τ = 20s, and (c) a 90◦ encounter with aprev = WR and τ = 0s

To enable the neural network to run in real time in the most
stressing scenarios, the increase in computation time must be
eliminated. This section presents two methods for reducing
required runtime of the neural network.

A. Network Pruning

The ﬁrst approach to speed network evaluations reduces the
number of computations performed by the network by making
the network sparse. Experiments in making computer vision
networks sparse show that 90% of network connections can
be removed without degrading network performance [37]. If
similar results can be achieved on the ACAS Xu networks,
then runtime required can be reduced by up to a factor of 10,
though the actual speedup factor will be lower due to overhead
associated with a sparse representation. Although this speedup
is not enough to entirely eliminate the runtime increase, this
could still contribute signiﬁcantly to runtime reduction.

Pruning the networks is an iterative process that removes
a small fraction of the network connections and then retrains
the network to adjust the remaining connections. Removing
too many connections at once could have a serious impact on
the network’s performance, so this implementation removes
only 2% of the network connections at a time. In addition,

4

3

2

1

0

10

8

6

4

2

0

E
S
M
R

y
c
i
l
o
P

n
i

r
o
r
r
E

t
n
e
c
r
e
P

0

10

20

30

40

50

60

70

80

90

0

10

20

30

40

50

60

70

80

90

Percent Pruned

Fig. 9. RMSE of network predictions (top) and policy error rate (bottom) for
pruned networks

the network’s least important connections should be removed
ﬁrst. One metric for identifying unimportant connections is the

(a)

10

0

−10

(d)

10

0

−10

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

SR

SL

WR

WL

COC

(b)

10

0

−10

(c)

10

0

−10

0

20

40

0

20

40

0

20

40

(e)

10

0

−10

(f)

10

0

−10

0

20

40

0

20

40

0

20

40

Downrange (kft)

Downrange (kft)

Downrange (kft)

Fig. 10. Policy plots for (a) the original table as well as the neural networks with (b) 0%, (c) 20%, (d) 40%, (e) 60%, and (f) 80% of connections pruned

magnitude of the connection’s weight. Connections with low
magnitude weight likely have little impact on the network’s
output, so ﬁxing the weight to zero will have the smallest
impact on the network output.

The RMSE and policy error rates are plotted as a function
of pruning in Fig. 9. With 60% of connections pruned, the
RMSE and policy error rate have both doubled, and further
pruning increases the network errors. In addition, plotting the
pruned policies demonstrates how pruning affects the network.
Figure 10 shows the policy plot of a head-on encounter. The
policy changes seen in Fig. 9 are sporadic and global, which
is expected for a neural network where weight changes in
early layers can have an impact on all values in future layers.
While pruning 40% of the connections yields only minor
policy changes, there are more signiﬁcant changes when 60%
is pruned. If pruning increases to 80%, the policy changes
drastically, and likely the performance of the 80% pruned
network will be degraded. Therefore,
the network can be
pruned up to 60% of the network weights before seeing
major changes in the policy. This result suggests that the
ACAS Xu networks are dense compared to computer vision
networks. Due to the additional overhead for using a sparse
representation, pruning only 60% of weights will not achieve
much speedup, so another approach will be required.

B. Multiple Small Neural Networks

The second method for speeding up network computation
uses an array of smaller networks rather than one large
network. The training data of the neural network can be
divided such that each network approximates distinct parts
of the state space. Only one of the small networks is used
to evaluate each state, which leads to a runtime speedup.
The training data was split into 45 separate datasets by using
the 45 different combinations of τ and aprev, and a separate

network was trained on each dataset. Because the networks
are trained on a factor of 45 less data, the networks can be
made smaller, and smaller networks require less computation.
To fully eliminate the ﬁfty-fold runtime increase, the networks
were made approximately 50 times smaller. Some degradation
to performance might be expected, since the networks can
no longer generalize between τ and aprev, but as shown in
this paper, performance does not degrade much. An example
policy plot is shown in Fig. 11, which shows that the smaller
networks can approximate the table well.

SR

SL

WR

WL

0

10

20

30

COC

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

10

0

−10

10

0

−10

0

10

20

30

Downrange (kft)

Fig. 11. Policy plots of original table (top) and smaller neural network
(bottom)

(a)

40

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

20

0

(b)

40

20

0

(c)

40

20

0

0

20

40

0

20

40

0

20

40

Downrange (kft)

Downrange (kft)

Downrange (kft)

0

−10

−20

−30

Fig. 12. With the COC penalty included, (a) shows the COC scores for the original table, (b) shows the neural network scores evaluated at the table cutpoints,
and (c) shows the COC score errors

The small networks have 6 hidden layers of 45 hidden units
each, giving each network approximately 11000 parameters.
Since the total number of parameters in all 45 networks
is approximately the same as the single large network, this
approach will not increase the memory or storage requirement.
Furthermore, training time required for each network is much
smaller than training a single large network. Training each
network requires approximately 2 hours, and because each
network is trained separately, the networks can be trained
in parallel on all available GPUs. With four Titan X GPUs,
training a new batch of networks can be done in a day, which
is also an improvement over training a single large network.
This method results in an overall runtime speed up of 3% over
the original table runtime, so the network pruning technique
was not used.

VI. IMPROVING NETWORK TRAINING

After training the array of small networks, simulations were
conducted to compute the overall performance metrics. As
reported in Section VII, the performance of the network in
simulation shows more work is required to improve the neural
network compression. This section presents two methods for
improving the quality of the network training data. These
adjustments do not change the overall score values the network
attempts to represent, but instead ﬁnds ways to make the data
easier to represent in a neural network format.

A. Removing Table Discontinuity

Although neural networks work well as universal function
approximators, for a limited network size, some target data
is easier to regress. For example, using a neural network
to regress data with large discontinuities will generate more
loss than smooth target data because networks represent con-
tinuous functions. If large discontinuities are present, more
connection weight and neuron activations will be required to
produce the large jump, and this might disrupt the network’s
performance for other areas of the state space. Removing such
discontinuities will allow the neural network to achieve better
performance on the entire data set.

When regressing the score table, large jumps in score values
were found that make network regression more error prone.

When aprev is not COC, and projected straight trajectories of
both aircraft results in minimum separation under 4000ft at
the closest-point-of-approach (CPA), an additional penalty is
added to the COC action. This penalty prevents the system
from ending alerts too early when the aircraft are still on
course for collision. While other penalty functions used to
generate the score table spread to nearby states and create
smooth changes in score values, this penalty does not. If the
COC action is taken, then the next time step’s aprev will be
COC, and the penalty will not be applied again. As a result,
the penalty does not spread to neighboring states and remains
within the region in which it is applied.

Figure 12 plots the original table’s COC score value in a
similar plot to the previous policy plots. The ﬁgure is a top-
down plot with the ownship at the origin and the intruder
traveling perpendicular to the ownship. At each point in the
ﬁrst two plots, the value of the COC action is shown. The
original table has a dark band extending outwards, which
represents the states where this COC penalty was applied. In
states far away from the intruder, the COC score outside the
band is approximately zero, while the values in the band are
at most -15.0. The result is a large discontinuity in the value
function that is problematic for neural network regression.
As shown in the middle plot in Fig. 12, the neural network
does not represent the band well, especially far away from
the ownship. The rightmost plot shows the error in the neural
network representation, and it is clear there are large errors
throughout the plot.

One solution to this issue is to remove the COC penalty
from the network training data and apply the penalty to the
network output values. Because the penalty does not spread
to other states in the score table, the penalty can be easily
removed and reapplied by computing the minimum distance
at CPA (dCPA) and time to CPA (tCPA) as

dx = vint cos(ψ) − vown
dy = vint sin(ψ)

tCPA = (−r cos(θ)dx − r sin(θ)dy)/(dx2 + dy2)

x(cid:48) = r cos(θ) + tCPAdx
y(cid:48) = r sin(θ) + tCPAdy

(3)

(4)

(5)

(6)

(7)

(a)

40

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

20

0

(b)

40

20

0

(c)

40

20

0

0

20

40

0

20

40

0

20

40

Downrange (kft)

Downrange (kft)

Downrange (kft)

0

−10

−20

−30

Fig. 13. With the COC penalty removed, (a) shows the COC scores for the original table, (b) shows the neural network scores evaluated at the table cutpoints,
and (c) shows the COC score errors

dCPA =

(cid:112)

x(cid:48)2 + y(cid:48)2

(8)

The COC score when the penalty is removed is shown in
the left plot of Fig. 13, which shows that the band of low
score values seen in Fig. 12 has been removed. As a result,
the network trained to represent this score table is a better ﬁt,
as shown in the rightmost plot of Fig. 13. Even the neural
network values at close range are more accurate. Because the
training data is more easily represented in some parts of the
state space and neural networks are global approximators, the
entire score table is regressed more accurately.

B. Training with Online Costs

Figure 14 shows the ﬁltered table and neural network
policies when the COC penalty is added back to the COC
score. The table and network policies match well, yet the
simulation results still show more reversals than expected
when using the network. Further investigation revealed that the
table values are modiﬁed using online costs before being used
in the system. The online costs deterministically modify the
table values used in the collision avoidance system, allowing
a designer to tune the system and optimize performance. One
important online cost decreases the score of COC and weak
turning advisories when the previous advisory is a strong
turning advisory, which is applied to prevent the system from
ending strong alerts too early. If the system stops alerting too
early, then the system may need to alert again in the future,
which will lead to split advisories and possibly reversals. The
left two plots of Fig. 15 shows the table and neural network
policies when the online costs are applied. While the table’s
policy changes to increase the area of strong alerts around
the ownship, the neural network does not change as much.
As a result, the online costs cannot tune the neural network
performance like the original table, and the neural network is
likely to see more reversals and split advisories.

The inability of the neural network to change its policy
with online costs results from the loss function used to
optimize network weights. The asymmetric mean squared error
loss encourages the network to under-estimate the scores of
suboptimal actions and over-estimate the score of the optimal
action. As a result, the score gap between the optimal action
and next best action widens, which makes the network policy

SR

WR

COC

SR

SL

0

10

20

30

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

30

20

10

0

30

20

10

0

0

10

20

30

Downrange (kft)

Fig. 14. Policy plots with COC penalty added to COC score for the original
table (top) and the neural network (bottom)

more difﬁcult to change with online costs. A simple solution to
this issue is to calculate the desired policy from the table with
online costs added, and then use this policy to determine the
optimal action when calculating the network loss. When the
network is trained with this approach, the resulting network
policy with online costs applied better matches the table policy,
as seen in the right plot of Fig. 15.

VII. RESULTS

To evaluate the neural network with new performance metric
measuring the probability of split advisories, P(Split),
the
table and neural network were simulated with an encounter
set of 10 million 3D encounters with different encounter
geometries and sensor noise. Table II shows a comparison of
the performance metrics for the different neural networks con-
sidered in this paper. With each update to the neural network
compression method, the overall neural network performance

(a)

)
t
f
k
(

e
g
n
a
r
s
s
o
r
C

30

20

10

0

SR

SL

SR

WR

COC

(b)

30

20

10

0

(c)

30

20

10

0

0

10

20

30

0

10

20

30

0

10

20

30

Downrange (kft)

Downrange (kft)

Downrange (kft)

Fig. 15. Policies with online costs added for (a) the original table, (b) the neural network trained without online costs, and (c) the neural network trained
with online costs

TABLE II
SIMULATION COMPARISON

Compression

P(NMAC)

P(Alert)

P(Reversal)

P(Split)

Relative Runtime

Updated Table
Nominal Network Array
Networks without COC Penalty
Networks with Online Costs

1.472 × 10−4
1.846 × 10−4
1.564 × 10−4
1.451 × 10−4

0.6705
0.5668
0.6098
0.6513

0.0270
0.0475
0.0435
0.0314

0.0969
0.0701
0.0754
0.0801

1×
0.97×
0.97×
0.97×

becomes more similar to the updated table. The ﬁnal version
of the neural network compression outperforms the table in all
metrics except P(Reversal), for which there is a slight increase.
However, the system performs well overall and results in a
slightly faster runtime than the original table.

Figure 16 shows top-down views of trajectories taken by
aircraft in two example encounters, and although the advisories
are horizontal, the vertical separation between the ownship
and intruder aircraft
is considered by the system through
the τ parameter. The intruder aircraft follows its own ﬂight
path while the ownship follows either the table or neural
network collision avoidance system. The advisories given by
the collision avoidance systems are represented by the arrows.
In the ﬁrst encounter, the neural network collision avoidance
system alerts the ownship seven seconds earlier than the
score table, which allows the aircraft to avoid a near mid-air
collision. In the second encounter, the neural network chooses
a different turning direction than the score table and avoids
a near mid-air collision. As a continuous function, the neural
network learns a better interpolation than the nearest-neighbor
interpolation used by the original score table, allowing the
network to outperform the original table in some cases.

The neural network collision avoidance system is also
effective in multi-intruder scenarios through utility fusion,
which combines the individual decisions when each intruder
is considered separately to generate an overall decision for the
ownship [4]. Figure 17 shows an example scenario with ten
aircraft all using the neural network collision avoidance policy.
The aircraft positions and velocities are randomly initialized
and commanded to ﬂy straight unless the neural network
alerts the aircraft to turn. The aircraft ﬂy for 80 seconds,
and all ten aircraft are safely routed around each other with
a minimum separation of 5564 ft. A few aircraft experience

15

10

5

0

−5

−10

)
t
f
k
(

h
t
r
o
N

5

0

)
t
f
k
(

h
t
r
o
N

−5

−10

−15

−10

Intruder
Ownship (Table)
Ownship (Network)

−10

−5

0

East (kft)

Intruder
Ownship (Table)
Ownship (Network)

0

10

20

East (kft)

Fig. 16. Two simulated encounter trajectories

)
t
f
k
(

h
t
r
o
N

20

0

−20

−20

0

20

East (kft)

Fig. 17. A simulated multi-intruder encounter trajectories

reversals in their turning direction as collisions with different
intruders become more imminent, illustrating that the neural
network can safely maneuver aircraft through multi-intruder
encounters.

While simulations can check the network performance in
millions of states, simulations are not enough to guarantee
the network will behave correctly in all possible states. One
method for verifying the neural network representation is to
use formal methods to prove properties about the network.
The Reluplex algorithm represents neural networks with ReLU
activations as a system of equations and uses a simplex method
to ﬁnd a set of inputs to satisfy a desired output constraint [38].
If no set of inputs can be found, then it is guaranteed that no set
of inputs exist that satisfy the condition. This approach can be
used to verify that the network will always alert if an intruder
is nearby, for example. The use of neural networks in safety-
critical certiﬁed avionics is unprecedented, but future work
with Reluplex could provide a method for veriﬁcation and
certiﬁcation of neural networks in aircraft collision avoidance
systems.

VIII. CONCLUSIONS

The unmanned variant of the Airborne Collision Avoidance
System X (ACAS Xu) makes decisions using an optimized
score table, but the table is too large to be used in current
avionics systems. A deep neural network representation was
trained to approximate the table, maintaining optimal advi-
sories while also approximating table values. Simulation shows
that the compression algorithms perform as well as the original
table. By factoring the table into subtables to train multiple
small networks, the network’s required runtime was reduced to
the level of the original table lookups. By investigating areas of
the state space where the networks represent the table poorly,
the network training was modiﬁed to allow the network to
train more easily, resulting in a more accurate representation
of the original table. The neural network representation can
table without degrading
be used in place of the original

performance, enabling the collision avoidance system to be
used in existing avionics hardware. If avionics systems with
greater storage capacity become available, then this neural
network compression approach will allow an even larger and
more complex collision avoidance policy to be efﬁciently
represented.

ACKNOWLEDGMENTS

This work is sponsored by the Federal Aviation Administra-
tion under U.S. Air Force contract no. FA8721-05-C-002. The
authors wish to thank Neal Suchy for his support. Opinions,
interpretations, conclusions, and recommendations are those
of the authors and are not necessarily endorsed by the U.S.
Government.

REFERENCES

[1] J. K. Kuchar and L. C. Yang, “A review of conﬂict detection and
resolution modeling methods,” IEEE Transactions on Intelligent Trans-
portation Systems, vol. 1, no. 4, pp. 179–189, 2000.

[2] M. J. Kochenderfer, “Optimized airborne collision avoidance,” in Deci-
sion Making under Uncertainty: Theory and Application. MIT Press,
2015, ch. 10, pp. 249–273.

[3] M. J. Kochenderfer, J. E. Holland, and J. P. Chryssanthacopoulos, “Next
generation airborne collision avoidance system,” Lincoln Laboratory
Journal, vol. 19, no. 1, pp. 17–33, 2012.

J. P. Chryssanthacopoulos,

[4] M.

J. Kochenderfer
collision

and
avoidance

airborne
Massachusetts
Project
http://www.ll.mit.edu/mission/aviation/publications/publication-ﬁles/
atc-reports/Kochenderfer 2011 ATC-371 WW-21458.pdf

through
Technology,
2011.

Lincoln
[Online].

ATC-371,

dynamic

Institute

Report

of

“Robust
programming,”
Laboratory,
Available:

[5] M. Marston and G. Baca, “ACAS-Xu initial self-separation ﬂight
tests,” http://ntrs.nasa.gov/search.jsp?R=20150008347, NASA, Tech.
Rep. DFRC-E-DAA-TN22968, 2015. [Online]. Available: http://hdl.
handle.net/2060/20150008347

[6] W. Youn and B.-j. Yi, “Software and hardware certiﬁcation of safety-
critical avionic systems: A comparison study,” Computer Standards &
Interfaces, vol. 36, no. 6, pp. 889–898, 2014.

[7] K. Statler, “Opinion: World needs seamless aviation certiﬁcation
2017.
http://aviationweek.com/commercial-aviation/

standards,” Aviation Week & Space Technology, Nov
[Online].
opinion-world-needs-seamless-aviation-certiﬁcation-standards

Available:

[8] M. J. Kochenderfer and N. Monath, “Compression of optimal value func-
tions for Markov decision processes,” in Data Compression Conference,
2013.

[9] K. D. Julian, J. Lopez, J. S. Brush, M. P. Owen, and M. J. Kochenderfer,
“Policy compression for aircraft collision avoidance systems,” in Digital
Avionics Systems Conference (DASC), 2016.

[10] Y. Engel, S. Mannor, and R. Meir, “Reinforcement

learning with
Gaussian processes,” in International Conference on Machine Learning
(ICML), 2005, pp. 201–208.

[11] R. Munos and A. Moore, “Variable resolution discretization in optimal
control,” Machine Learning, vol. 49, no. 2, pp. 291–323, 2002.
[12] M. Pal and P. M. Mather, “An assessment of the effectiveness of
decision tree methods for land cover classiﬁcation,” Remote Sensing
of Environment, vol. 86, no. 4, pp. 554–565, 2003.

[13] G. K. Tso and K. K. Yau, “Predicting electricity energy consumption: A
comparison of regression analysis, decision tree and neural networks,”
Energy, vol. 32, no. 9, pp. 1761–1768, 2007.

[14] A. Bordes, S. Ertekin, J. Weston, and L. Bottou, “Fast kernel classiﬁers
with online and active learning,” Journal of Machine Learning Research,
vol. 6, pp. 1579–1619, Sep 2005.

[15] B. S. Kim and A. J. Calise, “Nonlinear ﬂight control using neural
networks,” AIAA Journal on Guidance, Control, and Dynamics, vol. 20,
no. 1, pp. 26–33, 1997.

[16] M. Norgaard, C. C. Jorgensen, and J. C. Ross, “Neural network
prediction of new aircraft design coefﬁcients,” NASA, Technical Report
[Online]. Available: https://ntrs.nasa.gov/
NASA-TM-112197, 1997.
archive/nasa/casi.ntrs.nasa.gov/19970023478.pdf

[17] K. Worden and G. Manson, “The application of machine learning to
structural health monitoring,” Philosophical Transactions of the Royal
Society of London A: Mathematical, Physical and Engineering Sciences,
vol. 365, no. 1851, pp. 515–537, 2007.

[18] G. F. Montufar, R. Pascanu, K. Cho, and Y. Bengio, “On the number
of linear regions of deep neural networks,” in Advances in Neural
Information Processing Systems (NIPS), 2014, pp. 2924–2932.

[19] R. Eldan and O. Shamir, “The power of depth for feedforward neural
networks,” in Conference on Learning Theory, 2016, pp. 907–940.
[20] X. Glorot and Y. Bengio, “Understanding the difﬁculty of training deep
feedforward neural networks,” in International Conference on Artiﬁcial
Intelligence and Statistics, 2010, pp. 249–256.

[21] X. Glorot, A. Bordes, and Y. Bengio, “Deep sparse rectiﬁer neural
networks,” in International Conference on Artiﬁcial Intelligence and
Statistics, 2011, pp. 315–323.

[22] J. P. Chryssanthacopoulos and M. J. Kochenderfer, “Accounting for state
uncertainty in collision avoidance,” AIAA Journal on Guidance, Control,
and Dynamics, vol. 34, no. 4, pp. 951–960, 2011.

[23] S. Julier and J. Uhlmann, “Unscented ﬁltering and nonlinear estimation,”

Proceedings of the IEEE, vol. 92, no. 3, pp. 401–422, 2004.

[24] R. I. Lerman and S. Yitzhaki, “A note on the calculation and interpreta-
tion of the gini index,” Economics Letters, vol. 15, no. 3-4, pp. 363–368,
1984.

[25] F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion,
O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg et al.,
“Scikit-learn: Machine learning in python,” Journal of Machine Learning
Research, vol. 12, no. Oct, pp. 2825–2830, 2011.

[26] A. Krizhevsky, I. Sutskever, and G. E. Hinton, “Imagenet classiﬁcation
with deep convolutional neural networks,” in Advances in Neural Infor-
mation Processing Systems (NIPS), 2012, pp. 1097–1105.

[27] G. E. Dahl, T. N. Sainath, and G. E. Hinton, “Improving deep neural net-
works for lvcsr using rectiﬁed linear units and dropout,” in International
Conference on Acoustics, Speech, and Signal Processing (ICASSP).
IEEE, 2013, pp. 8609–8613.

[28] G. P. Zhang, “Neural networks for classiﬁcation: a survey,” IEEE
Transactions on Systems, Man, and Cybernetics, Part C: Applications
and Reviews, vol. 30, no. 4, pp. 451–462, 2000.

[29] S. F. Crone, “Training artiﬁcial neural networks for time series prediction
using asymmetric cost functions,” in International Conference on Neural
Information Processing (ICONIP), vol. 5, 2002, pp. 2374–2380.
[30] T. Tieleman and G. Hinton, “Lecture 6.5-rmsprop: Divide the gradient
by a running average of its recent magnitude,” COURSERA: Neural
Networks for Machine Learning, 2012.

[31] J. Duchi, E. Hazan, and Y. Singer, “Adaptive subgradient methods
for online learning and stochastic optimization,” Journal of Machine
Learning Research, vol. 12, pp. 2121–2159, 2011.

[32] M. D. Zeiler, “Adadelta: an adaptive learning rate method,” arXiv

preprint arXiv:1212.5701, 2012.

[33] D. Kingma and J. Ba, “Adam: A method for stochastic optimization,”
in International Conference on Learning Representations, 2015.
[34] F. Chollet, “Keras: Deep learning library for Theano and TensorFlow,”

2015. [Online]. Available: keras.io

[35] Theano Development Team, “Theano: A Python framework for fast com-
putation of mathematical expressions,” arXiv preprint arXiv:1605.02688,
2016.

[36] Y. A. LeCun, L. Bottou, G. B. Orr, and K.-R. M¨uller, “Efﬁcient back-
prop,” in Neural Networks: Tricks of the Trade, 2nd ed., G. Montavon,
G. B. Orr, and K.-R. M¨uller, Eds. Berlin: Springer, 2012, pp. 9–48.

[37] S. Han, H. Mao, and W. J. Dally, “Deep compression: Compressing deep
neural networks with pruning, trained quantization and huffman coding,”
in International Conference on Learning Representations.
IEEE, May
2016.

[38] G. Katz, C. Barrett, D. L. Dill, K. Julian, and M. J. Kochenderfer,
“Reluplex: An efﬁcient smt solver for verifying deep neural networks,”
in International Conference on Computer Aided Veriﬁcation. Springer,
2017, pp. 97–117.

