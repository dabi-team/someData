Molding CNNs for text: non-linear, non-consecutive convolutions

Tao Lei, Regina Barzilay, and Tommi Jaakkola
Computer Science and Artiﬁcial Intelligence Laboratory
Massachusetts Institute of Technology
{taolei, regina, tommi}@csail.mit.edu

5
1
0
2

g
u
A
8
1

]
L
C
.
s
c
[

2
v
2
1
1
4
0
.
8
0
5
1
:
v
i
X
r
a

Abstract

The success of deep learning often de-
rives from well-chosen operational build-
ing blocks.
In this work, we revise the
temporal convolution operation in CNNs
to better adapt it to text processing.
In-
stead of concatenating word representa-
tions, we appeal to tensor algebra and use
low-rank n-gram tensors to directly exploit
interactions between words already at the
convolution stage. Moreover, we extend
the n-gram convolution to non-consecutive
words to recognize patterns with interven-
ing words. Through a combination of low-
rank tensors, and pattern weighting, we
can efﬁciently evaluate the resulting con-
volution operation via dynamic program-
ming. We test the resulting architecture on
standard sentiment classiﬁcation and news
categorization tasks. Our model achieves
state-of-the-art performance both in terms
of accuracy and training speed. For in-
stance, we obtain 51.2% accuracy on the
ﬁne-grained sentiment classiﬁcation task.1

1

Introduction

Deep learning methods and convolutional neural
networks (CNNs) among them have become de
facto top performing techniques across a range
of NLP tasks such as sentiment classiﬁcation,
question-answering, and semantic parsing. As
methods, they require only limited domain knowl-
edge to reach respectable performance with in-
creasing data and computation, yet permit easy
architectural and operational variations so as to
ﬁne tune them to speciﬁc applications to reach top
performance. Indeed, their success is often con-
tingent on speciﬁc architectural and operational
choices.

1Our code and data are available at https://github.

com/taolei87/text_convnet

CNNs for text applications make use of tem-
Similar
poral convolution operators or ﬁlters.
to image processing, they are applied at multi-
ple resolutions, interspersed with non-linearities
and pooling. The convolution operation itself is
a linear mapping over “n-gram vectors” obtained
by concatenating consecutive word (or character)
representations. We argue that this basic build-
ing block can be improved in two important re-
spects. First, the power of n-grams derives pre-
cisely from multi-way interactions and these are
clearly missed (initially) with linear operations on
stacked n-gram vectors. Non-linear interactions
within a local context have been shown to improve
empirical performance in various tasks (Mitchell
and Lapata, 2008; Kartsaklis et al., 2012; Socher
et al., 2013). Second, many useful patterns are
expressed as non-consecutive phrases, such as se-
mantically close multi-word expressions (e.g.,“not
that good”, “not nearly as good”).
In typical
CNNs, such expressions would have to come to-
gether and emerge as useful patterns after several
layers of processing.

We propose to use a feature mapping operation
based on tensor products instead of linear opera-
tions on stacked vectors. This enables us to di-
rectly tap into non-linear interactions between ad-
jacent word feature vectors (Socher et al., 2013;
Lei et al., 2014). To offset the accompanying
parametric explosion we maintain a low-rank rep-
resentation of the tensor parameters. Moreover,
we show that this feature mapping can be applied
to all possible non-consecutive n-grams in the se-
quence with an exponentially decaying weight de-
pending on the length of the span. Owing to the
low rank representation of the tensor, this oper-
ation can be performed efﬁciently in linear time
with respect to the sequence length via dynamic
programming. Similar to traditional convolution
operations, our non-linear feature mapping can be
applied successively at multiple levels.

 
 
 
 
 
 
We evaluate the proposed architecture in the
context of sentence sentiment classiﬁcation and
news categorization. On the Stanford Sentiment
Treebank dataset, our model obtains state-of-the-
art performance among a variety of neural net-
works in terms of both accuracy and training
cost. Our model achieves 51.2% accuracy on ﬁne-
grained classiﬁcation and 88.6% on binary clas-
siﬁcation, outperforming the best published num-
bers obtained by a deep recursive model (Tai et al.,
2015) and a convolutional model (Kim, 2014). On
the Chinese news categorization task, our model
achieves 80.0% accuracy, while the closest base-
line achieves 79.2%.

2 Related Work

Deep neural networks have recently brought about
signiﬁcant advancements in various natural lan-
guage processing tasks, such as language model-
ing (Bengio et al., 2003; Mikolov et al., 2010),
sentiment analysis (Socher et al., 2013;
Iyyer
et al., 2015; Le and Zuidema, 2015), syntactic
parsing (Collobert and Weston, 2008; Socher et
al., 2011a; Chen and Manning, 2014) and ma-
chine translation (Bahdanau et al., 2014; Devlin
et al., 2014; Sutskever et al., 2014). Models
applied in these tasks exhibit signiﬁcant archi-
tectural differences, ranging from recurrent neu-
ral networks (Mikolov et al., 2010; Kalchbrenner
and Blunsom, 2013) to recursive models (Pollack,
1990; K¨uchler and Goller, 1996), and including
convolutional neural nets (Collobert and Weston,
2008; Collobert et al., 2011; Yih et al., 2014; Shen
et al., 2014; Kalchbrenner et al., 2014; Zhang and
LeCun, 2015).

Our model most closely relates to the latter.
Since these models have originally been developed
for computer vision (LeCun et al., 1998), their
application to NLP tasks introduced a number of
modiﬁcations. For instance, Collobert et al. (2011)
use the max-over-time pooling operation to aggre-
gate the features over the input sequence. This
variant has been successfully applied to seman-
tic parsing (Yih et al., 2014) and information re-
trieval (Shen et al., 2014; Gao et al., 2014). Kalch-
brenner et al. (2014) instead propose (dynamic)
k-max pooling operation for modeling sentences.
In addition, Kim (2014) combines CNNs of dif-
ferent ﬁlter widths and either static or ﬁne-tuned
word vectors. In contrast to the traditional CNN
models, our method considers non-consecutive n-

grams thereby expanding the representation ca-
pacity of the model. Moreover, our model cap-
tures non-linear interactions within n-gram snip-
pets through the use of tensors, moving beyond
direct linear projection operator used in standard
CNNs. As our experiments demonstrate these ad-
vancements result in improved performance.

3 Background

Let x ∈ RL×d be the input sequence such as a
document or sentence. Here L is the length of the
sequence and each xi ∈ Rd is a vector represent-
ing the ith word. The (consecutive) n-gram vector
ending at position j is obtained by simply concate-
nating the corresponding word vectors

vj = [xj−n+1; xj−n+2; · · · ; xj]

Out-of-index words are simply set to all zeros.

The traditional convolution operator is parame-
terized by ﬁlter matrix m ∈ Rnd×h which can be
thought of as n smaller ﬁlter matrices applied to
each xi in vector vj. The operator maps each n-
gram vector vj in the input sequence to m(cid:62)vj ∈
Rh so that the input sequence x is transformed into
a sequence of feature representations,

(cid:104)

m(cid:62)v1, · · · , m(cid:62)vL

(cid:105)

∈ RL×h

The resulting feature values are often passed
through non-linearities such as the hyper-tangent
(element-wise) as well as aggregated or reduced
by “sum-over” or “max-pooling” operations for
later (similar stages) of processing.

The overall architecture can be easily modiﬁed
by replacing the basic n-gram vectors and the con-
volution operation with other feature mappings.
Indeed, we appeal to tensor algebra to introduce a
non-linear feature mapping that operates on non-
consecutive n-grams.

4 Model

N-gram tensor Typical n−gram feature map-
pings where concatenated word vectors are
mapped linearly to feature coordinates may be in-
sufﬁcient to directly capture relevant information
in the n−gram. As a remedy, we replace concate-
nation with a tensor product. Consider a 3-gram
(x1, x2, x3) and the corresponding tensor product
x1 ⊗ x2 ⊗ x3. The tensor product is a 3-way ar-
ray of coordinate interactions such that each ijk

entry of the tensor is given by the product of the
corresponding coordinates of the word vectors

(x1 ⊗ x2 ⊗ x3)ijk = x1i · x2j · x3k

Here ⊗ denotes the tensor product operator. The
tensor product of a 2-gram analogously gives a
two-way array or matrix x1 ⊗ x2 ∈ Rd×d. The n-
gram tensor can be seen as a direct generalization
of the typical concatenated vector2.

Tensor-based feature mapping Since each n-
gram in the sequence is now expanded into a
high-dimensional tensor using tensor products, the
set of ﬁlters are analogously maintained as high-
order tensors. In other words, our ﬁlters are linear
mappings over the higher dimensional interaction
terms rather than the original word coordinates.

Consider again mapping a 3-gram (x1, x2, x3)
into a feature representation. Each ﬁlter is a 3-way
tensor with dimensions d × d × d. The set of h ﬁl-
ters, denoted as T , is a 4-way tensor of dimension
d × d × d × h, where each d3 slice of T repre-
sents a single ﬁlter and h is the number of such
ﬁlters, i.e., the feature dimension. The resulting
h−dimensional feature representation z ∈ Rh for
the 3-gram (x1, x2, x3) is obtained by multiplying
the ﬁlter T and the 3-gram tensor as follows. The
lth coordinate of z is given by

zl =

=

(cid:88)

ijk
(cid:88)

ijk

Tijkl · (x1 ⊗ x2 ⊗ x3)ijk

Tijkl · x1i · x2j · x3k

(1)

The formula is equivalent to summing over all
the third-order polynomial interaction terms where
tensor T stores the coefﬁcients.

Directly maintaining the ﬁlters as full tensors
leads to parametric explosion. Indeed, the size of
the tensor T (i.e. h × dn) would be too large even
for typical low-dimensional word vectors where,
e.g., d = 300. To this end, we assume a low-rank
factorization of the tensor T, represented in the
Kruskal form. Speciﬁcally, T is decomposed into
a sum of h rank-1 tensors

T =

h
(cid:88)

i=1

Pi ⊗ Qi ⊗ Ri ⊗ Oi

2To see this, consider word vectors with a “bias” term
(cid:48) = [xi; 1]. The tensor product of n such vectors includes
xi
the concatenated vector as a subset of tensor entries but, in
addition, contains all up to nth-order interaction terms.

where P, Q, R ∈ Rh×d and O ∈ Rh×h are four
smaller parameter matrices. Pi (similarly Qi, Ri
and Oi) denotes the ith row of the matrix. Note
that, for simplicity, we have assumed that the num-
ber of rank-1 components in the decomposition
is equal to the feature dimension h. Plugging
the low-rank factorization into Eq.(1), the feature-
mapping can be rewritten in a vector form as

z = O(cid:62) (Px1 (cid:12) Qx2 (cid:12) Rx3)

(2)

where (cid:12) is the element-wise product such that,
e.g., (a (cid:12) b)k = ak × bk for a, b ∈ Rm. Note
that while Px1 (similarly Qx2 and Rx3) is a lin-
ear mapping from each word x1 (similarly x2 and
x3) into a h-dimensional feature space, higher or-
der terms arise from the element-wise products.

Non-consecutive n-gram features Traditional
convolution uses consecutive n-grams in the fea-
ture map. Non-consecutive n-grams may nev-
ertheless be helpful since phrases such as “not
good”, “not so good” and “not nearly as good” ex-
press similar sentiments but involve variable spac-
ings between the key words. Variable spacings are
not effectively captured by ﬁxed n-grams.

We apply the feature-mapping in a weighted
manner to all n-grams thereby gaining access to
patterns such as “not ... good”. Let z[i, j, k] ∈ Rh
denote the feature representation corresponding to
a 3-gram (xi, xj, xk) of words in positions i, j,
and k along the sequence. This vector is calcu-
lated analogously to Eq.(2),

z[i, j, k] = O(cid:62) (Pxi (cid:12) Qxj (cid:12) Rxk)

aggregate

these vectors

into an
We will
h−dimensional
feature representation at each
position in the sequence. The idea is similar to
neural bag-of-words models where the feature
representation for a document or sentence is
obtained by averaging (or summing) of all the
word vectors. In our case, we deﬁne the aggregate
representation z3[k] in position k as the weighted
sum of all 3-gram feature representations ending
at position k, i.e.,

z3[k] =

=

(cid:88)

i<j<k
(cid:88)

i<j<k

z[i, j, k] · λ(k−j−1)+(j−i−1)

z[i, j, k] · λk−i−2

(3)

where λ ∈ [0, 1) is a decay factor that down-
weights 3-grams with longer spans (i.e., 3-grams

that skip more in-between words). As λ → 0
all non-consecutive 3-grams are omitted, z3[k] =
z[k − 2, k − 1, k], and the model acts like a
traditional model with only consecutive n-grams.
When λ > 0, however, z3[k] is a weighted aver-
age of many 3-grams with variable spans.

Aggregating features via dynamic program-
ming Directly calculating z3[·] according to
Eq.(3) by enumerating all 3-grams would require
O(L3) feature-mapping operations. We can, how-
ever, evaluate the features more efﬁciently by re-
lying on the associative and distributive properties
of the feature operation in Eq.(2).

Let f3[k] be a dynamic programming table rep-
resenting the sum of 3-gram feature representa-
tions before multiplying with matrix O. That is,
z3[k] = O(cid:62)f3[k] or, equivalently,

f3[k] =

(cid:88)

i<j<k

λk−i−2 · (Pxi (cid:12) Qxj (cid:12) Rxk)

We can analogously deﬁne f1[i] and f2[j] for 1-
grams and 2-grams,

f1[i] = Pxi
(cid:88)

f2[j] =

i<j

λj−i−1 · (Pxi (cid:12) Qxj)

These dynamic programming tables can be calcu-
lated recursively according to the following for-
mulas:

f1[i] = Pxi
s1[i] = λ · s1[i − 1] + f1[i]

f2[j] = s1[j − 1] (cid:12) Qxj
s2[j] = λ · s2[j − 1] + f2[j]

f3[k] = s2[k − 1] (cid:12) Rxk

z[k] = O(cid:62) (f1[k] + f2[k] + f3[k])

where s1[·] and s2[·] are two auxiliary tables. The
resulting z[·] is the sum of 1, 2, and 3-gram fea-
tures. We found that aggregating the 1,2 and 3-
gram features in this manner works better than us-
ing 3-gram features alone. Overall, the n-gram
feature aggregation can be performed in O(Ln)
matrix multiplication/addition operations, and re-
mains linear in the sequence length.

The overall architecture The dynamic pro-
gramming algorithm described above maps the
original input sequence to a sequence of feature
representations z = z[1 : L] ∈ RL×h. As in
standard convolutional architectures, the resulting
sequence can be used in multiple ways. One can
directly aggregate it to a classiﬁer or expose it to
non-linear element-wise transformations and use
it as an input to another sequence-to-sequence fea-
ture mapping.

The simplest strategy (adopted in neural bag-
of-words models) would be to average the fea-
ture representations and pass the resulting aver-
aged vector directly to a softmax output unit

¯z =

1
L

L
(cid:88)

i=1

z[i]

˜y = softmax

(cid:16)

(cid:17)
W(cid:62) ¯z

Our architecture, as illustrated in Figure 1, in-
cludes two additional reﬁnements. First, we add
a non-linear activation function after each feature
representation, i.e. z(cid:48) = ReLU (z + b), where b
is a bias vector and ReLU is the rectiﬁed linear
unit function. Second, we stack multiple tensor-
based feature mapping layers. That is, the input
sequence x is ﬁrst processed into a feature se-
quence and passed through the non-linear trans-
formation to obtain z(1). The resulting feature
sequence z(1) is then analogously processed by
another layer, parameterized by a different set of
feature-mapping matrices P, · · · , O, to obtain a
higher-level feature sequence z(2), and so on. The
output feature representations of all these layers
are averaged within each layer and concatenated
as shown in Figure 1. The ﬁnal prediction is there-
fore obtained on the basis of features across the
levels.

5 Learning the Model

Following standard practices, we train our model
by minimizing the cross-entropy error on a given
training set. For a single training sequence x and
the corresponding gold label y ∈ [0, 1]m, the error
is deﬁned as,

loss (x, y) =

m
(cid:88)

l=1

yl log (˜yl)

where m is the number of possible output label.

The set of model parameters (e.g. P, · · · , O
in each layer) are updated via stochastic gradient

Figure 1: Illustration of the model architecture. The input is represented as a matrix where each row is a
d-dimensional word vector. Several feature map layers (as described in Section 4) are stacked, mapping
the input into different levels of feature representations. The features are averaged within each layer and
then concatenated. Finally a softmax layer is applied to obtain the prediction output.

descent using AdaGrad algorithm (Duchi et al.,
2011).

(cid:104)

Initialization We initialize matrices P, Q, R
from uniform distribution
and

(cid:105)
−(cid:112)3/d, (cid:112)3/d
(cid:104)
(cid:105)
−(cid:112)3/h, (cid:112)3/h
similarly O ∼ U
. In this way,
each row of the matrices is an unit vector in expec-
tation, and each rank-1 ﬁlter slice has unit variance
as well,

E (cid:2)(cid:107)Pi ⊗ Qi ⊗ Ri ⊗ Oi(cid:107)2(cid:3) = 1

In addition, the parameter matrix W in the soft-
max output layer is initialized as zeros, and the
bias vectors b for ReLU activation units are ini-
tialized to a small positive constant 0.01.

Regularization We apply two common tech-
niques to avoid overﬁtting during training. First,
we add L2 regularization to all parameter values
with the same regularization weight. In addition,
we randomly dropout (Hinton et al., 2012) units
on the output feature representations z(i) at each
level.

6 Experimental Setup

Datasets We evaluate our model on sentence
sentiment classiﬁcation task and news categoriza-
tion task. For sentiment classiﬁcation, we use the
Stanford Sentiment Treebank benchmark (Socher
et al., 2013).
The dataset consists of 11855
parsed English sentences annotated at both the
root (i.e. sentence) level and the phrase level us-
ing 5-class ﬁne-grained labels. We use the stan-

dard 8544/1101/2210 split for training, develop-
ment and testing respectively. Following previ-
ous work, we also evaluate our model on the bi-
nary classiﬁcation variant of this benchmark, ig-
noring all neutral sentences. The binary version
has 6920/872/1821 sentences for training, devel-
opment and testing.

For the news categorization task, we evaluate on
Sogou Chinese news corpora.3 The dataset con-
tains 10 different news categories in total, includ-
ing Finance, Sports, Technology and Automobile
etc. We use 79520 documents for training, 9940
for development and 9940 for testing. To obtain
Chinese word boundaries, we use LTP-Cloud4, an
open-source Chinese NLP platform.

the standard SVM
Baselines We implement
method and the neural bag-of-words model
NBoW as baseline methods in both tasks. To as-
sess the proposed tensor-based feature map, we
also implement a convolutional neural network
model CNN by replacing our ﬁlter with traditional
linear ﬁlter. The rest of the framework (such as
feature averaging and concatenation) remains the
same.

In addition, we compare our model with a wide
range of top-performing models on the sentence
sentiment classiﬁcation task. Most of these mod-
els fall into either the category of recursive neural
networks (RNNs) or the category of convolutional
neural networks (CNNs). The recursive neural

3http://www.sogou.com/labs/dl/c.html
4http://www.ltp-cloud.com/intro/en/
https://github.com/HIT-SCIR/ltp

The$movie$was$fantas/c$!$softmax(outputinput(xfeature*mapslow.level(featureshigh.level(features……average*and*concatenate$Model

RNN
RNTN
DRNN
RLSTM
DCNN
CNN-MC
CNN
PVEC
DAN
SVM
NBoW
Ours

+ phrase labels

Fine-grained
Test
Dev
43.2
45.7
49.8
51.0
48.5
47.4
47.2
48.7
48.2
38.3
44.5
50.6
51.2

40.1
45.1
49.5
53.4

48.8

Binary

Time (in seconds)

Dev

85.7

78.6
80.7
87.0
88.9

Test
82.4
85.4
86.8
88.0
86.9
88.1
86.2
87.8
86.8
81.3
82.0
87.0
88.6

per epoch
-
1657
431
140
-
2452
32
-
73
-
1
28
445

per 10k samples
-
1939
504
164
-
156
37
-
5
-
1
33
28

Table 1: Comparison between our model and other baseline methods on Stanford Sentiment Treebank.
The top block lists recursive neural network models, the second block are convolutional network mod-
els and the third block contains other baseline methods, including the paragraph-vector model (Le and
Mikolov, 2014), the deep averaging network model (Iyyer et al., 2015) and our implementation of neural
bag-of-words. The training time of baseline methods is taken from (Iyyer et al., 2015) or directly from
the authors. For our implementations, timings were performed on a single core of a 2.6GHz Intel i7
processor.

network baselines include standard RNN (Socher
et al., 2011b), RNTN with a small core tensor in
the composition function (Socher et al., 2013), the
deep recursive model DRNN (Irsoy and Cardie,
2014) and the most recent recursive model using
long-short-term-memory units RLSTM (Tai et al.,
2015). These recursive models assume the in-
put sentences are represented as parse trees. As
a beneﬁt, they can readily utilize annotations at
In contrast, convolutional neu-
the phrase level.
ral networks are trained on sequence-level, taking
the original sequence and its label as training in-
put. Such convolutional baselines include the dy-
namic CNN with k-max pooling DCNN (Kalch-
brenner et al., 2014) and the convolutional model
with multi-channel CNN-MC by Kim (2014). To
leverage the phrase-level annotations in the Stan-
ford Sentiment Treebank, all phrases and the cor-
responding labels are added as separate instances
when training the sequence models. We follow
this strategy and report results with and without
phrase annotations.

Word vectors The word vectors are pre-trained
on much larger unannotated corpora to achieve
better generalization given limited amount of
training data (Turian et al., 2010).
In particu-
lar, for the English sentiment classiﬁcation task,

we use the publicly available 300-dimensional
GloVe word vectors trained on the Common Crawl
with 840B tokens (Pennington et al., 2014). This
choice of word vectors follows most recent work,
such as DAN (Iyyer et al., 2015) and RLSTM (Tai
et al., 2015). For Chinese news categorization,
there is no widely-used publicly available word
vectors. Therefore, we run word2vec (Mikolov
et al., 2013) to train 200-dimensional word vec-
tors on the 1.6 million Chinese news articles. Both
word vectors are normalized to unit norm (i.e.
(cid:107)w(cid:107)2
2 = 1) and are ﬁxed in the experiments with-
out ﬁne-tuning.

Hyperparameter setting We perform an exten-
sive search on the hyperparameters of our full
model, our implementation of the CNN model
(with linear ﬁlters), and the SVM baseline. For
our model and the CNN model, the initial learn-
ing rate of AdaGrad is ﬁxed to 0.01 for sentiment
classiﬁcation and 0.1 for news categorization, and
the L2 regularization weight is ﬁxed to 1e − 5
and 1e − 6 respectively based on preliminary runs.
The rest of the hyperparameters are randomly cho-
sen as follows: number of feature-mapping lay-
ers ∈ {1, 2, 3}, n-gram order n ∈ {2, 3}, hidden
feature dimension h ∈ {50, 100, 200}, dropout
probability ∈ {0.0, 0.1, 0.3, 0.5}, and length de-

cay λ ∈ {0.0, 0.3, 0.5}. We run each conﬁg-
uration 3 times to explore different random ini-
tializations. For the SVM baseline, we tune L2
regularization weight C ∈ {0.01, 0.1, 1.0, 10.0},
word cut-off frequency ∈ {1, 2, 3, 5} (i.e. pruning
words appearing less than this times) and n-gram
feature order n ∈ {1, 2, 3}.

Implementation details The source code is
implemented in Python using the Theano li-
brary (Bergstra et al., 2010), a ﬂexible lin-
ear algebra compiler that can optimize user-
speciﬁed computations (models) with efﬁcient
automatic low-level implementations,
including
(back-propagated) gradient calculation.

7 Results

7.1 Overall Performance

Table 1 presents the performance of our model
and other baseline methods on Stanford Sentiment
Treebank benchmark. Our full model obtains the
highest accuracy on both the development and test
sets. Speciﬁcally, it achieves 51.2% and 88.6%
test accuracies on ﬁne-grained and binary tasks re-
spectively5. As shown in Table 2, our model per-
formance is relatively stable – it remains high ac-
curacies with around 0.5% standard deviation un-
der different initializations and dropout rates.

Our full model is also several times faster than
other top-performing models. For example, the
convolutional model with multi-channel (CNN-
MC) runs over 2400 seconds per training epoch.
In contrast, our full model (with 3 feature layers)
runs on average 28 seconds with only root labels
and on average 445 seconds with all labels.

Our results also show that the CNN model,
where our feature map is replaced with traditional
linear map, performs worse than our full model.
This observation conﬁrms the importance of the
proposed non-linear,
tensor-based feature map-
ping. The CNN model also lags behind the DCNN
and CNN-MC baselines, since the latter two pro-
pose several advancements over standard CNN.

Table 3 reports the results of SVM, NBoW and
our model on the news categorization task. Since
the dataset is much larger compared to the senti-
ment dataset (80K documents vs. 8.5K sentences),
the SVM method is a competitive baseline.
It
achieves 78.5% accuracy compared to 74.4% and

5Best hyperparameter conﬁguration based on dev accu-
racy: 3 layers, 3-gram tensors (n=3), feature dimension d =
200 and length decay λ = 0.5

Fine-grained

Binary

Dataset
Dev
Test
Dev
Test

Accuracy
52.5 (±0.5) %
51.4 (±0.6) %
88.4 (±0.3) %
88.4 (±0.5) %

Table 2: Analysis of average accuracy and stan-
dard deviation of our model on sentiment classiﬁ-
cation task.

Model
SVM (1-gram)
SVM (2-gram)
SVM (3-gram)
NBoW
CNN
Ours

Dev Acc. Test Acc.

77.5
78.2
78.2
74.4
79.5
80.0

77.4
78.0
78.5
74.4
79.2
80.0

Table 3: Performance of various methods on Chi-
nese news categorization task. Our model obtains
better results than the SVM, NBoW and traditional
CNN baselines.

79.2% obtained by the neural bag-of-words model
and CNN model. In contrast, our model obtains
80.0% accuracy on both the development and test
sets, outperforming the three baselines by a 0.8%
absolute margin. The best hyperparameter con-
ﬁguration in this task uses less feature layers and
lower n-gram order (speciﬁcally, 2 layers and n =
2) compared to the sentiment classiﬁcation task.
We hypothesize that the difference is due to the
nature of the two tasks: the document classiﬁca-
tion task requires to handle less compositions or
context interactions than sentiment analysis.

7.2 Hyperparameter Analysis

We next investigate the impact of hyperparame-
ters in our model performance. We use the mod-
els trained on ﬁne-grained sentiment classiﬁcation
task with only root labels.

Number of layers We plot the ﬁne-grained sen-
timent classiﬁcation accuracies obtained during
hyperparameter grid search. Figure 2 illustrates
how the number of feature layers impacts the
model performance. As shown in the ﬁgure,
adding higher-level features clearly improves the
classiﬁcation accuracy across various hyperpa-
rameter settings and initializations.

Non-consecutive n-gram features We also an-
alyze the effect of modeling non-consecutive n-

(1) positive prediction

(2) negative prediction

(3) negative prediction

(4) positive prediction

(5) negative prediction

(6) negative prediction (ground truth: negative)

(7) positive prediction (ground truth: positive)

Figure 5: Example sentences and their sentiments predicted by our model trained with root labels. The
predicted sentiment scores at each word position are plotted. Examples (1)-(5) are synthetic inputs, (6)
and (7) are two real inputs from the test set. Our model successfully identiﬁes negation, double negation
and phrases with different sentiment in one sentence.

Figure 2: Dev accuracy (x-axis) and test accuracy
(y-axis) of independent runs of our model on ﬁne-
grained sentiment classiﬁcation task. Deeper ar-
chitectures achieve better accuracies.

grams. Figure 3 splits the model accuracies ac-
cording to the choice of span decaying factor λ.
Note when λ = 0, the model applies feature ex-
tractions to consecutive n-grams only. As shown
in Figure 3, this setting leads to consistent perfor-
mance drop. This result conﬁrms the importance
of handling non-consecutive n-gram patterns.

Non-linear activation Finally, we verify the ef-
fectiveness of rectiﬁed linear unit activation func-

Figure 3: Comparison of our model variations
in sentiment classiﬁcation task when considering
consecutive n-grams only (decaying factor λ = 0)
and when considering non-consecutive n-grams
(λ > 0). Modeling non-consecutive n-gram fea-
tures leads to better performance.

tion (ReLU) by comparing it with no activation (or
identity activation f (x) = x). As shown in Fig-
ure 4, our model with ReLU activation generally
outperforms its variant without ReLU. The obser-
vation is consistent with previous work on convo-
lutional neural networks and other neural network
models.

Table 1themovieisnotgoodthe0.25movie0.25is0.08not-1.91good-1.00the0.25movie0.25is0.08not-1.91bad1.99the0.25movie0.25is0.08neither-1.99good-0.95nor-1.97bad1.75the0.25movie0.25is0.08bad12the0.25movie0.25is0.08good1.99-2-1012themovieisnotgood-2-1012themovieisnotbad-2-1012themovieisneithergoodnorbad-2-1012themovieisbad-2-1012themovieisgoodTable 1themovieisnotgoodthe0.25movie0.25is0.08not-1.91good-1.00the0.25movie0.25is0.08not-1.91bad1.99the0.25movie0.25is0.08neither-1.99good-0.95nor-1.97bad1.75the0.25movie0.25is0.08bad12the0.25movie0.25is0.08good1.99-2-1012themovieisnotgood-2-1012themovieisnotbad-2-1012themovieisneithergoodnorbad-2-1012themovieisbad-2-1012themovieisgoodTable 1themovieisnotgoodthe0.25movie0.25is0.08not-1.91good-1.00the0.25movie0.25is0.08not-1.91bad1.99the0.25movie0.25is0.08neither-1.99good-0.95nor-1.97bad1.75the0.25movie0.25is0.08bad12the0.25movie0.25is0.08good1.99okay10.34but0not10.51good10.04-2-1012themovieisnotgood-2-1012themovieisnotbad-2-1012themovieisneithergoodnorbad-2-1012themovieisbad-2-1012themovieisgood-2-1012okaybutnotgoodTable 1themovieisnotgoodthe0.25movie0.25is0.08not-1.91good-1.00the0.25movie0.25is0.08not-1.91bad1.99the0.25movie0.25is0.08neither-1.99good-0.95nor-1.97bad1.75the0.25movie0.25is0.08bad12the0.25movie0.25is0.08good1.99okay10.34but0not10.51good10.04-2-1012themovieisnotgood-2-1012themovieisnotbad-2-1012themovieisneithergoodnorbad-2-1012themovieisbad-2-1012themovieisgood-2-1012okaybutnotgoodTable 1themovieisnotgoodthe0.25movie0.25is0.08not-1.91good-1.00the0.25movie0.25is0.08not-1.91bad1.99the0.25movie0.25is0.08neither-1.99good-0.95nor-1.97bad1.75the0.25movie0.25is0.08bad12the0.25movie0.25is0.08good1.99okay10.34but0not10.51good10.04-2-1012themovieisnotgood-2-1012themovieisnotbad-2-1012themovieisneithergoodnorbad-2-1012themovieisbad-2-1012themovieisgood-2-1012okaybutnotgoodno#1.56movement#0.81,0.09no#1.97yuks0.08,0.46not#0.58much#0.85of#1.01anything#1.43.#1.01-2-1012nomovement,noyuks,notmuchofanything.too#0.94bad#1.99,#0.88but0.06thanks1.39to1.16some1.07lovely1.93..1.98..1.79and1.91several1.77ﬁne1.98..2,2it0.42‘s#0.72not#0.99a#1.02total0.7loss1.32.0.97-2-1012toobad,butthankstosomelovely....andseveralﬁne..,it‘snotatotalloss.Table 11 layer2 layers3 layers0.4450.46920.4460.47380.44690.47690.44780.46290.44870.46880.45050.47010.45050.46920.45050.46650.45140.46880.45230.46970.45230.4620.45230.47060.45230.46520.45230.46880.45320.46650.45320.47560.45410.45340.45410.46520.4550.46520.4550.46330.45690.4670.45690.4760.45780.46790.45780.46920.45870.45380.45870.48010.45870.47010.45960.45880.45960.47150.46140.45570.46140.47190.46140.47510.46230.45750.46320.47470.46410.46790.46410.47290.4650.47010.4650.4710.46590.46880.46590.47740.46590.47240.46590.46920.46680.46880.46780.47240.46780.48510.46780.47510.46870.46610.47320.47920.46320.4810.47140.48420.47140.490.47140.47690.47140.48280.47230.46740.47230.48280.47320.45930.47320.48140.47320.46970.4750.46380.4750.47780.47590.48870.47590.48870.47590.47830.47590.46920.47680.47010.47680.490.47680.48420.47770.48240.47870.4760.47960.47470.47960.49820.47960.4860.48140.47420.48140.49590.48230.47290.48410.48010.4850.47190.48590.48640.48770.48730.48770.50090.46680.49320.46960.47240.46960.49190.47050.49050.47140.48690.47230.46650.47230.4810.47230.48730.47320.49050.47410.47830.47590.47690.47590.47780.47680.48960.47870.48510.47960.48010.48050.50810.48050.48690.48050.49640.48050.48820.48140.49320.48140.49550.48230.46610.48230.46520.48230.48190.48320.47190.48320.47870.48320.48910.48320.47690.48320.49860.4850.49640.48590.4760.48590.49860.48680.4860.48770.49590.48860.48780.48960.46020.48960.49370.49140.47650.49230.49860.4950.506344.5%46.1%47.8%49.4%51.0%43.5%45.1%46.8%48.4%50.0%1 layer2 layers3 layersdecay=0.0decay=0.3decay=0.50.45870.47240.46230.47740.46320.45930.4650.48640.46590.47650.46680.47960.46780.47150.46870.48050.46960.48050.46960.48640.47050.45480.47050.47290.47140.46520.47140.46290.47230.47870.47230.49820.47230.47870.47230.46060.47320.47650.47320.47010.4750.48010.47590.46880.47590.46610.47680.48370.47680.46520.47770.45570.47770.45880.47770.46880.47770.49860.47870.46330.47960.4710.48050.48910.46320.4810.46680.49320.46960.47240.47050.49050.47140.48420.47140.490.47140.48690.47140.47690.47230.46650.47230.4810.47230.46740.47230.48280.47320.46970.47320.49050.4750.47780.47590.46920.47680.48960.47680.490.47680.48420.47870.4760.47960.47470.47960.4860.48050.50810.48050.48690.48050.48820.48140.49320.48230.47290.48230.46610.48230.46520.48320.48910.48590.4760.48590.48640.48860.48780.48960.46020.4950.50630.46960.49190.47140.48280.47230.48730.47320.45930.47320.48140.47410.47830.4750.46380.47590.47690.47590.48870.47590.48870.47590.47830.47590.47780.47680.47010.47770.48240.47870.48510.47960.49820.47960.48010.48050.49640.48140.47420.48140.49590.48140.49550.48230.48190.48320.47190.48320.47870.48320.47690.48320.49860.48410.48010.4850.47190.4850.49640.48590.49860.48680.4860.48770.48730.48770.49590.48770.50090.48960.49370.49140.47650.49230.498644.5%46.1%47.8%49.4%51.0%45.0%46.3%47.5%48.8%50.0%decay=0.0decay=0.3decay=0.5acknowledge the support of the U.S. Army Re-
search Ofﬁce under grant number W911NF-10-1-
0533. The work is developed in collaboration with
the Arabic Language Technologies (ALT) group at
Qatar Computing Research Institute (QCRI). Any
opinions, ﬁndings, conclusions, or recommenda-
tions expressed in this paper are those of the au-
thors, and do not necessarily reﬂect the views of
the funding organizations.

References

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2014. Neural machine translation by jointly
arXiv preprint
learning to align and translate.
arXiv:1409.0473.

Yoshua Bengio, R´ejean Ducharme, Pascal Vincent, and
Christian Janvin. 2003. A neural probabilistic lan-
guage model. The Journal of Machine Learning Re-
search, 3:1137–1155.

James Bergstra, Olivier Breuleux, Fr´ed´eric Bastien,
Pascal Lamblin, Razvan Pascanu, Guillaume Des-
jardins, Joseph Turian, David Warde-Farley, and
Yoshua Bengio.
a CPU and
In Proceedings
GPU math expression compiler.
of the Python for Scientiﬁc Computing Conference
(SciPy).

Theano:

2010.

Danqi Chen and Christopher D Manning. 2014. A fast
and accurate dependency parser using neural net-
In Proceedings of the 2014 Conference on
works.
Empirical Methods in Natural Language Processing
(EMNLP), pages 740–750.

R. Collobert and J. Weston. 2008. A uniﬁed architec-
ture for natural language processing: Deep neural
networks with multitask learning. In International
Conference on Machine Learning, ICML.

Ronan Collobert, Jason Weston, L´eon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
The Journal of Machine Learning Re-
scratch.
search, 12:2493–2537.

Jacob Devlin, Rabih Zbib, Zhongqiang Huang, Thomas
Lamar, Richard Schwartz, and John Makhoul. 2014.
Fast and robust neural network joint models for sta-
tistical machine translation. In 52nd Annual Meet-
ing of the Association for Computational Linguis-
tics.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive subgradient methods for online learning
and stochastic optimization. The Journal of Ma-
chine Learning Research, 12:2121–2159.

Jianfeng Gao, Patrick Pantel, Michael Gamon, Xi-
aodong He, Li Deng, and Yelong Shen. 2014. Mod-
eling interestingness with deep neural networks. In

Figure 4: Applying ReLU activation on top of
tensor-based feature mapping leads to better per-
formance in sentiment classiﬁcation task. Runs
with no activation are plotted as blue circles.

7.3 Example Predictions

Figure 5 gives examples of input sentences and
the corresponding predictions of our model in
ﬁne-grained sentiment classiﬁcation. To see how
our model captures the sentiment at different lo-
cal context, we apply the learned softmax ac-
tivation to the extracted features at each posi-
tion without taking the average. That is, for
each index i, we obtain the local sentiment p =
softmax (cid:0)W(cid:62) (cid:0)z(1)[i] ⊕ z(2)[i] ⊕ z(3)[i](cid:1)(cid:1). We
plot the expected sentiment scores (cid:80)2
s=−2 s · p(s),
where a score of 2 means “very positive”, 0 means
“neutral” and -2 means “very negative”. As shown
in the ﬁgure, our model successfully learns nega-
tion and double negation. The model also iden-
tiﬁes positive and negative segments appearing in
the sentence.

8 Conclusion

We proposed a feature mapping operator for con-
volutional neural networks by modeling n-gram
interactions based on tensor product and evaluat-
ing all non-consecutive n-gram vectors. The as-
sociated parameters are maintained as a low-rank
tensor, which leads to efﬁcient feature extraction
via dynamic programming. The model achieves
top performance on standard sentiment classiﬁca-
tion and document categorization tasks.

Acknowledgments

We thank Kai Sheng Tai, Mohit Iyyer and Jordan
Boyd-Graber for answering questions about their
paper. We also thank Yoon Kim, the MIT NLP
group and the reviewers for their comments. We

NoneReLU0.46960.47240.47140.47690.47140.48280.47230.46650.47230.4810.47230.48730.47230.46740.47230.48280.47320.45930.47320.46970.47410.47830.4750.46380.4750.47780.47590.47690.47590.48870.47590.47830.47590.46920.47590.47780.47680.47010.47680.48960.47770.48240.47870.4760.47870.48510.47960.47470.47960.48010.48050.48690.48140.47420.48230.47290.48230.46610.48230.46520.48230.48190.48320.47190.48320.47870.48320.48910.48320.47690.4850.47190.48590.4760.48770.48730.48960.46020.49140.47650.46320.4810.46680.49320.46960.49190.47050.49050.47140.48420.47140.490.47140.48690.47320.48140.47320.49050.47590.48870.47680.490.47680.48420.47960.49820.47960.4860.48050.50810.48050.49640.48050.48820.48140.49590.48140.49320.48140.49550.48320.49860.48410.48010.4850.49640.48590.49860.48590.48640.48680.4860.48770.49590.48770.50090.48860.48780.48960.49370.49230.49860.4950.506344.5%46.1%47.8%49.4%51.0%46.0%47.0%48.0%49.0%50.0%NoneReLUProceedings of the 2013 Conference on Empirical
Methods in Natural Language Processing.

Geoffrey E Hinton, Nitish Srivastava, Alex Krizhevsky,
Ilya Sutskever, and Ruslan R Salakhutdinov. 2012.
Improving neural networks by preventing co-
arXiv preprint
adaptation of feature detectors.
arXiv:1207.0580.

Ozan Irsoy and Claire Cardie. 2014. Deep recursive
neural networks for compositionality in language.
In Advances in Neural Information Processing Sys-
tems.

Mohit Iyyer, Varun Manjunatha, Jordan Boyd-Graber,
and Hal Daume III. 2015. Deep unordered compo-
sition rivals syntactic methods for text classiﬁcation.
In Association for Computational Linguistics.

Nal Kalchbrenner and Phil Blunsom. 2013. Recurrent
In Proceedings of
continuous translation models.
the 2013 Conference on Empirical Methods in Nat-
ural Language Processing (EMNLP 2013), pages
1700–1709.

Nal Kalchbrenner, Edward Grefenstette, and Phil Blun-
som. 2014. A convolutional neural network for
modelling sentences. In Proceedings of the 52th An-
nual Meeting of the Association for Computational
Linguistics.

Dimitri Kartsaklis, Mehrnoosh Sadrzadeh, and Stephen
Pulman.
2012. A uniﬁed sentence space for
categorical distributional-compositional semantics:
Theory and experiments. In In Proceedings of COL-
ING: Posters.

Yoon Kim. 2014. Convolutional neural networks for
In Proceedings of the Em-
sentence classiﬁcation.
piricial Methods in Natural Language Processing
(EMNLP 2014).

Andreas K¨uchler and Christoph Goller. 1996. Induc-
tive learning in symbolic domains using structure-
In KI-96: Ad-
driven recurrent neural networks.
vances in Artiﬁcial Intelligence, pages 183–197.

Quoc Le and Tomas Mikolov. 2014. Distributed repre-
sentations of sentences and documents. In Proceed-
ings of the 31st International Conference on Ma-
chine Learning (ICML-14), pages 1188–1196.

Phong Le and Willem Zuidema. 2015. Compositional
distributional semantics with long short term mem-
ory. In Proceedings of Joint Conference on Lexical
and Computational Semantics (*SEM).

Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. 1998.
Gradient-based learning applied to document recog-
nition. Proceedings of the IEEE, 86(11):2278–2324,
November.

Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and
Tommi Jaakkola. 2014. Low-rank tensors for scor-
In Proceedings of the
ing dependency structures.

52th Annual Meeting of the Association for Compu-
tational Linguistics. Association for Computational
Linguistics.

Tomas Mikolov, Martin Karaﬁ´at, Lukas Burget, Jan
Cernock`y, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In IN-
TERSPEECH 2010, 11th Annual Conference of the
International Speech Communication Association,
Makuhari, Chiba, Japan, September 26-30, 2010,
pages 1045–1048.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey
Dean. 2013. Efﬁcient estimation of word represen-
tations in vector space. CoRR.

Jeff Mitchell and Mirella Lapata. 2008. Vector-based
In ACL, pages

models of semantic composition.
236–244.

Jeffrey Pennington, Richard Socher, and Christopher D
Manning. 2014. Glove: Global vectors for word
representation. volume 12.

Jordan B Pollack. 1990. Recursive distributed repre-

sentations. Artiﬁcial Intelligence, 46:77–105.

Yelong Shen, Xiaodong He, Jianfeng Gao, Li Deng,
and Gr´egoire Mesnil. 2014. Learning semantic rep-
resentations using convolutional neural networks for
web search. In Proceedings of the companion publi-
cation of the 23rd international conference on World
wide web companion, pages 373–374. International
World Wide Web Conferences Steering Committee.

Richard Socher, Cliff C. Lin, Andrew Y. Ng, and
Christopher D. Manning. 2011a. Parsing natural
scenes and natural language with recursive neural
networks. In Proceedings of the 26th International
Conference on Machine Learning (ICML).

Richard Socher, Jeffrey Pennington, Eric H Huang,
Andrew Y Ng, and Christopher D Manning. 2011b.
Semi-supervised recursive autoencoders for predict-
In Proceedings of the
ing sentiment distributions.
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 151–161. Association for
Computational Linguistics.

Richard Socher, Alex Perelygin, Jean Wu, Jason
Chuang, Christopher D. Manning, Andrew Y. Ng,
and Christopher Potts. 2013. Recursive deep mod-
els for semantic compositionality over a sentiment
treebank. In Proceedings of the 2013 Conference on
Empirical Methods in Natural Language Process-
ing, pages 1631–1642, October.

Ilya Sutskever, Oriol Vinyals, and Quoc VV Le. 2014.
Sequence to sequence learning with neural net-
works. In Advances in Neural Information Process-
ing Systems, pages 3104–3112.

Kai Sheng Tai, Richard Socher, and Christopher D
Manning. 2015. Improved semantic representations
from tree-structured long short-term memory net-
works. In Proceedings of the 53th Annual Meeting
of the Association for Computational Linguistics.

Joseph Turian, Lev Ratinov, and Yoshua Bengio. 2010.
Word representations: A simple and general method
for semi-supervised learning. In Proceedings of the
48th Annual Meeting of the Association for Compu-
tational Linguistics, ACL ’10. Association for Com-
putational Linguistics.

Wen-tau Yih, Xiaodong He, and Christopher Meek.
2014. Semantic parsing for single-relation question
answering. In Proceedings of ACL.

Xiang Zhang and Yann LeCun. 2015. Text understand-
ing from scratch. arXiv preprint arXiv:1502.01710.

