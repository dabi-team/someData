8
1
0
2

c
e
D
3

]

G
L
.
s
c
[

1
v
4
0
8
0
0
.
2
1
8
1
:
v
i
X
r
a

Deep Inverse Optimization

Yingcong Tan1, Andrew Delong2, and Daria Terekhov1

1 Department of Mechanical, Industrial and Aerospace Engineering,
Concordia University
t yingco@encs.concordia.ca
daria.terekhov@concordia.ca
2 andrew.delong@gmail.com

Abstract. Given a set of observations generated by an optimization pro-
cess, the goal of inverse optimization is to determine likely parameters
of that process. We cast inverse optimization as a form of deep learning.
Our method, called deep inverse optimization, is to unroll an iterative
optimization process and then use backpropagation to learn parameters
that generate the observations. We demonstrate that by backpropagating
through the interior point algorithm we can learn the coeﬃcients deter-
mining the cost vector and the constraints, independently or jointly, for
both non-parametric and parametric linear programs, starting from one
or multiple observations. With this approach, inverse optimization can
leverage concepts and algorithms from deep learning.

Keywords: inverse optimization · deep learning · interior point

1

Introduction

The potential for synergy between optimization and machine learning is well-
recognized [6], with recent examples including [8,18,26]. Our work uses machine
learning for inverse optimization. Consider a parametric linear optimization
problem, PLP(u, w):

minimize
x

c(u, w)(cid:48)x

subject to A(u, w)x ≤ b(u, w),

(1)

where x ∈ Rd and c(u, w) ∈ Rd, A(u, w) ∈ Rd×m and b(u, w) ∈ Rm are
all functions of features u and weights w. Let xn
tru be an optimal solution to
PLP(un, wtru). Given a set of observed optimal solutions, {x1
tru, x2
tru},
for observed conditions {u1, u2, . . . , uN }, the goal of inverse optimization (IO)
is to determine values of optimization process parameters w that generated the
observed optimal solutions. Applications of IO range from medicine (e.g., imput-
ing the importance of treatment sub-objectives from clinically-approved radio-
therapy plans [11]) to energy (e.g., predicting the behaviour of price-responsive
customers [31]).

tru, . . . , xN

Fundamentally, IO problems are learning problems: each un is a feature vec-
tru is its corresponding target; the goal is to learn model parameters

tor and xn

 
 
 
 
 
 
2

Y. Tan et al.

w that minimize some loss function. In this paper, we cast inverse optimization
as a form of deep learning. Our method, called deep inverse optimization, is to
unroll an iterative optimization process and then use backpropagation to learn
model parameters that generate the observations/targets.

Fig. 1. Three IO learning tasks in non-parametric and parametric linear programs.

Figure 1 shows the actual result of applying our deep IO method to three
inverse optimization learning tasks. The top panel illustrates the non-parametric,
single-point variant of model (1) — the case when exactly one xtru is given — a
classical problem in IO (see [1,12]). In Figure 1 (i), only c needs to be learned:
starting from an initial cost vector cini, our method ﬁnds clrn which makes xtru an
optimal solution of the LP by minimizing (cid:107)xtru −xlrn(cid:107)2. In Figure 1 (ii), starting
from cini, Aini and bini, our approach ﬁnds clrn, Alrn and blrn which make xtru
an optimal solution of the learned LP through minimizing (cid:107)xtru − xlrn(cid:107)2.

Figure 1 (iii) shows learning w = [w0, w1] for the parametric problem instance

minimize
x

cos(w0 + w1u)x1 + sin(w0 + w1u)x2

subject to − x1 ≤ 0.2w0u,

− x2 ≤ −0.2w1u,
w0x1 + (1 + 1

3 w1u)x2 ≤ w0 + 0.1u.

(2)

c(u, wtru)True parametric LPInitial parametric LPLearned parametric LP(i) Learning c onlyciniclrnctruxtruc(u, wini)c(u, wlrn)(ii) Learning c, A, b jointlyxlrnxinix(u , wtru)loss = 0.45loss = 0.00clrnctrucinixtru(iii) Learning weights w of a parametric LP from multiple pointsDeep Inverse Optimization

3

Starting from wini = [0.2, 0.4] with a loss (mean squared error) of 0.45, our
method is able to ﬁnd wlrn = [1.0, 1.0] with a loss of zero, thereby making xn
tru
optimal solutions of (2) for u values {−1.5, −0.5, 0.5, 1.5}. Given newly observed
u values, in this example wlrn would predict correct decisions. In other words,
the learned model generalizes well.

The contributions of this paper are as follows. We propose a general frame-
work for inverse optimization based on deep learning. This framework is applica-
ble to learning coeﬃcients of the objective function and constraints, individually
or jointly; minimizing a general loss function; learning from a single or multiple
observations; and solving both non-parametric and parametric problems. As a
proof of concept, we demonstrate that our method obtains eﬀectively zero loss
on many randomly generated linear programs for all three types of learning tasks
shown in Figure 1, and always improves the loss signiﬁcantly. Such a numerical
study on randomly generated non-parameteric and parametric linear programs
with multiple learnable parameters has not previously been published for any
IO method in the literature. Finally, to the best of our knowledge, we are the
ﬁrst to use unrolling and backpropagation for constrained inverse optimization.
We explain how our approach diﬀers from methods in inverse optimization
and machine learning in Section 2. We present our deep IO framework in Sec-
tion 3 and our experimental results in Section 4. Section 5 discusses both the
generality and the limitations of our work, and Section 6 concludes the paper.

2 Related Work

The goal of our paper is to develop a general-purpose IO approach that is ap-
plicable to problems for which theoretical guarantees or eﬃcient exact opti-
mization approaches are diﬃcult or impossible to develop. Naturally, such a
general-purpose approach will not be the method of choice for all classes of IO
problems. In particular, for non-parametric linear programs, closed-form solu-
tions for learning the c vector (Figure 1 (i)) and for learning the constraint
coeﬃcients have been derived by Chan et al. [12,14] and Chan and Kaw [13],
respectively. However, learning objective and constraint coeﬃcients jointly (Fig-
ure 1 (ii)) has, to date, received little attention. To the best of our knowledge,
this task has been investigated only by Troutt et al. [36,37], who referred to it
as linear system identiﬁcation, using a maximum likelihood approach. However,
their approach was limited to two dimensions [37] or required the coeﬃcients to
be non-negative [36].

In the parametric optimization setting, Keshavarz et al. [22] develop an opti-
mization model that encodes KKT optimality conditions for imputing objective
function coeﬃcients of a convex optimization problem. Aswani et al. [3] focus
on the same problem under the assumption of noisy measurements, developing
a bilevel problem and two algorithms which are shown to maintain statistical
consistency. Saez-Gallego and Morales [31] address the case of learning c and
b jointly in a parametric setting where the b vector is assumed to be an aﬃne
function of a regressor. The general case of learning the weights of a parametric

4

Y. Tan et al.

linear optimization problem (1) where c, A and b are functions of u (Figure 1
(iii)) has not been addressed in the literature.

Recent work in machine learning [4,5,16] views inverse optimization through
the lens of online learning, where new observations appear over time rather than
as one batch. Our approach may be applicable in online settings, but we focus
on generality in the batch setting and do not investigate real-time cases.

Methodologically, our unrolling strategy is similar to McLaurin et al. [24]
who directly optimize the hyperparameters of a neural network training pro-
cedure with gradient descent. Conceptually, the closest papers to our work are
by Amos and Kolter [2] and Donti, Amos and Kolter [17]. However, these pa-
pers are written independently of the inverse optimization literature. Amos and
Kolter [2] present the OptNet framework, which integrates a quadratic optimiza-
tion layer in a deep neural network. The gradients for updating the coeﬃcients
of the optimization problem are derived through implicit diﬀerentiation. This
approach involves taking matrix diﬀerentials of the KKT conditions for the op-
timization problem in question, while our strategy is based on allowing a deep
learning framework to unroll an existing optimization procedure. Their method
has eﬃciency advantages, while our unrolling approach is easily applicable, in-
cluding to processes for which the KKT conditions may not hold or are diﬃcult
to implicitly diﬀerentiate. We include a more in-depth discussion in Section 5.

3 Deep Learning Framework for Inverse Optimization

The problems studied in inverse optimization are learning problems: given fea-
tures un and corresponding targets xn
tru, the goal is to learn parameters of a
forward optimization model that generate xn
tru as its optimal solutions. A com-
plementary view is that inverse optimization is a learning technique specialized
to the case when the observed data is coming from an optimization process.
Given this perspective on inverse optimization and motivated by the success of
deep learning for a variety of learning tasks in recent years (see [23]), this paper
develops a deep learning framework for inverse optimization problems.

Deep learning is a set techniques for training the parameters of a sequence
of transformations (layers) chained together. The more intermediate layers, the
‘deeper’ the architecture. We refer the reader to the textbook by Goodfellow,
Bengio and Courville [19] for additional details about deep learning. The features
of the intermediate layers can be trained/learned through backpropagation, an
automatic diﬀerentiation technique that computes the gradient of an output with
respect to its input through the layers of a neural network, starting from the ﬁnal
layer all the way to the initial one. This method eﬃciently computes an update
to the weights of the model [30]. Importantly, current machine learning libraries
such as PyTorch provide built-in backpropagation capabilities [28] that allow
for wider use of deep learning. Thus, our deep inverse optimization framework
iterates between solving the forward optimization problem using an iterative
optimization algorithm and backpropagating through the steps (layers) of that

algorithm to improve the estimates of learnable parameters (weights) of the
forward process.

Deep Inverse Optimization

5

Algorithm 1 Deep inverse optimization framework.

Input: wini; (un, xn
Output: wlrn

tru) for n = 1, .. N ,

∆w ← 0
for n in 1 .. N do

1: w ← wini
2: for s in 1 .. max steps do
3:
4:
5:
6:
7:
8:
9:
10:
11: end for
12: Return w

x ← FO(un, w)
(cid:96) ← L(x, xn
∆w ← ∆w + ∂(cid:96)
∂w

end for
β ← line search(w, α · ∆w
N )
w ← w − βα · ∆w
N

tru)

(cid:46) Solve forward problem
(cid:46) Compute loss
(cid:46) Accumulate gradient by backprop

(cid:46) Find safe step size
(cid:46) Update weights

Our approach, shown in Algorithm 1, takes the pairs (un, xn

tru), n = 1, .., N ,
as input, and starts by initializing w = wini. For each n, the forward optimization
problem (FO) is solved with the current weights (line 5), and the loss between
the resulting optimal solution x and xtru is computed (line 6). The gradient of
the loss function with respect to w is computed by backpropagation through
the layers of the forward process. In line 9, line search is used to determine
the step size, β, for updating the weights: β is reduced by half if infeasibility
or unboundedness is encountered until a value is found that will lead to loss
reduction or β < 10−8, in which case early algorithm termination is triggered.
Finally, in line 10, the weights are updated using the average gradient, step size
β, and α, a vector representing the component-wise learning rates for w.

Fig. 2. Deep inverse optimization framework.

Importantly, our framework is applicable in the context of any diﬀerentiable,
iterative forward optimization procedure. In principle, parameter gradients are

(i) IPM forward processc(u,w)x(u,wtru)x(1)x(u,w)x(2)uwc(u,w)A(u,w)b(u,w)x(1)x(2)x(u,w)(ii) Deep inverse optimization through IPMx(u,wtru)loss(u,w)...Newton stepforward instancefeasible pointfeaturesparamsgradient ∆wtargetbackprop6

Y. Tan et al.

automatically computable even with non-linear constraints or non-linear objec-
tives, so long as they can be expressed through standard diﬀerentiable primitives.
Our particular implementation uses the barrier interior point method (IPM) as
described by Boyd and Vandenberghe [9], as our forward optimization solver.
The IPM forward process is illustrated in Figure 2 (i): the central path taken
by IPM is illustrated for the current u and w, which deﬁne both the current
feasible region and the current c(u, w). As shown in Figure 2 (ii), backpropaga-
tion starts from the computation of the loss function between a (near) optimal
forward optimization solution x(u, w) and the target x(u, wtru) and proceeds
backward through all the steps of IPM, i.e., x(u, w) to x(1), the starting point of
IPM, to the forward instance parameters and ﬁnally w to compute ∆w. In prac-
tice, backpropagating all the way to x(1) may not be necessary for computing
accurate gradients; see Section 5.

The framework requires setting three main hyperparameters: wini, the initial
weight vector; max steps, the total number of steps allotted to the training;
and α, the learning rates for the diﬀerent components of w. The number of
additional hyperparameters depends on the forward optimization process.

4 Experimental Results

In this section, we demonstrate the application of our framework on randomly-
generated LPs for the three types of problems shown in Figure 1: learning c in
the non-parametric case; learning c, A and b together in the non-parametric
case; and learning w in the parametric case.

Implementation Our framework is implemented in Python, using PyTorch
version 0.4.1 and its built-in backpropagation capabilities [28]. All numerical op-
erations are carried out with PyTorch tensors and standard PyTorch primitives,
including the matrix inversion at the heart of the Newton step.

Hyperparameters We limit learning to max steps = 200 in all experiments.
Four additional hyperparameters are set in each experiment:

– (cid:15), which controls the precision and termination of IPM;
– t(0): the initial value of the barrier IPM sharpness parameter t;
– µ: the factor by which t is increased along the IPM central path;
– α: the vector of per-parameter learning rates, which in some experiments is

broken down into αc and αAb.

In all experiments, the (cid:15) hyperparameter is either a constant 10−5 or decays
exponentially from 0.1 to 10−5 during learning. The decay is a form of graduated
optimization [7], and tends to help performance when using the MSE loss.

Deep Inverse Optimization

7

Baseline LPs To generate problem instances, we ﬁrst create a set of baseline
LPs with d variables and m constraints by sampling at least d random points
from N (0, 1), and then construct the convex hull via the scipy.spatial.convexhull
package [29]. We generate 50 LP instances for each of the following six problem
sizes: d = 2 and m ∈ {4, 8, 16} and d = 10, m ∈ {20, 36, 80}. Our experi-
ments focus on inequality constraints. We observed that our method can work
for equality constrained instances, but we did not systematically evaluate equal-
ity constraints and we leave that for future work.

Fig. 3. Learning in non-parametric IO problems.

(i) Learning c only(ii) Learning c, A, b jointlyabsolute duality gapsquared errornumber of constraintsnumber of constraints2D instances10D instances2D instances10D instancesinilrn48162036804816203680target at vertextarget strictly feasibletarget infeasibleinilrninilrninilrn8

Y. Tan et al.

4.1 Non-Parametric

We ﬁrst demonstrate the performance of our method for learning c only, and
learning c, A and b jointly, on the single-point variant of model (1), i.e., when
a single optimal target xtru is given, a classical problem in IO [1]. We use two
loss functions, absolute duality gap (ADG) and squared error (SE), deﬁned as
follows:

ADG = c(cid:48)

lrn|xtru − xlrn|,

SE = (cid:107)xtru − xlrn(cid:107)2
2,

(3)

(4)

the ﬁrst of which is a classical performance metric in IO [11] and the second is
a standard metric in machine learning.

Learning c only To complete instance generation for this experiment, we ran-
domly select one vertex of the convex hull to be xtru for each of the 50 baseline
LP instances and for each of the six (m, d) combinations.

Initialization is done by sampling each parameter of cini from N (0, 1). We
implement a randomized grid search by sampling 20 random combinations of the
following three hyperparameter sets: t(0) ∈ {0.5, 1, 5, 10}, µ ∈ {1.5, 2, 5, 10, 20},
and αc ∈ {1, 10, 100, 1000}. As in other applications of deep learning, it is not
clear which hyperparameters will work best for a particular problem instance.
For each instance we run our algorithm with the same 20 hyperparameter com-
binations, reporting the best ﬁnal error values.

Figure 3 (i) shows the results of this experiment for ADG and SE loss. In
both cases, our method is able to reliably learn c: in fact, for all instances, the
ﬁnal error is under 10−4, while the majority of initial errors are above 10−1.
There is no clear pattern in the performance of the method as m and d change
for ADG; for SE, the ﬁnal loss is slightly bigger for higher d.

Learning c, A, b jointly Our approach to instance generation here is to start
with each baseline LP and generate a strictly feasible or infeasible target within
some reasonable proximity of an existing vertex. The algorithm is then forced
to learn a new c, A, b that generate the target, which is not an optimum for the
initial LP. To make this task more challenging, we also perturb c so that it is
not initialized too close to the optimal direction.

For each of the 50 baseline LP feasible regions, we generate a c ∼ N (0, 1)
and compute its optimal solution x∗. To generate an infeasible target we set
xtru = x∗ + η where η ∼ U [−0.2, 0.2]. We similarly generate a challenging cini by
corrupting c with noise from U [−0.2, 0.2]. To generate a strictly feasible target
near x∗, we set xtru = 0.9x∗ + 0.1x(cid:48) where x(cid:48) is a uniformly random point within
the feasible region generated by Dirichlet-weighted combination of all vertices;
this method was used because adding noise in 10 dimensions almost always
results in an infeasible target.

In summary, we generate new LP instances with the same feasible region as
the baseline LPs but a corrupted cini and one feasible and one infeasible target.

Deep Inverse Optimization

9

The goal is to demonstrate the ability of our algorithm to detect the change and
also move the constraints and objective so that the feasible/infeasible target
becomes a vertex optimum. For each of the six problem sizes, we randomly split
the 50 instances into two subsets, one with feasible and the other with infeasible
targets. For ADG loss we set (cid:15) = 10−5 and for SE we use the (cid:15) decay strategy.
In practice, this decay strategy is similar to putting emphasis on learning c in
the initial iterations and ending with emphasis on constraint learning.

The values of hyperparameters αc and αAb are independently selected from
{0.1, 1, 10} and concatenated into one learning rate vector α. We generate 20
diﬀerent hyperparameter combinations. We run our algorithm on each instance
with all hyperparameter combinations and record the value of the best trial.

Figure 3 (ii) shows the results of this experiment for ADG and SE loss. In
both cases, our method is able to learn model parameters that result in median
loss of under 10−4. For ADG, our method performs equally well for all problem
sizes, and there is not much diﬀerence in the ﬁnal loss for feasible and infeasible
targets. For SE, however, the ﬁnal loss is larger for higher d but decreases as
m increases. Furthermore, there is a visible diﬀerence in performance of the
method on feasible and infeasible points for 10-dimensional instances: learning
from infeasible targets becomes a more diﬃcult task.

4.2 Parametric

Several aspects of the experiment for parametric LPs are diﬀerent from the non-
parametric case. First, we train by minimizing MSE(w), deﬁned as

MSE(w) =

1
N

N
(cid:88)

n=1

(cid:107)x(un, wtru) − x(un, w)(cid:107)2
2.

(5)

We chose the mean of SE loss instead of the mean of ADG loss for the parametric
experiments because it is only zero if the targets are all feasible, which is not
necessarily required for ADG to be zero. This makes the SE loss more diﬃcult
from a learning point of view, but also leads to more intuitive notion of success.
See Section 5 for discussion. In the parametric case, we also assess how well the
learned PLP generalizes, by evaluating its MSE(wlrn) on a held-out test set.

To generate parametric problem instances, we again started from the baseline
LP feasible regions. To generate a true PLP, we used six weights to deﬁne linear
functions of u for all elements of c, all elements of b, and one random element in
each row of A. For example, for 2-dimensional problems with four constraints,
our instances have the following form:

minimize
x

(c1 + w1 + w2u)x1 + (c2 + w1 + w2u)x2




subject to





a11
a21
a31 + w3 + w4u a32
a41

a12 + w3 + w4u
a22 + w3 + w4u

a42 + w3 + w4u







b1 + w5 + w6u
b2 + w5 + w6u
b3 + w5 + w6u
b4 + w5 + w6u







(6)

≤





10

Y. Tan et al.

Speciﬁcally, the “true PLP” instances are generated by setting w1, w3, w5 = 0
and w2, w4, w6 ∼ N (0, 0.2). This ensures that when u = 0 the feasible region
of the true PLP matches the baseline LP. For each true PLP, we ﬁnd a range
[umin, umax] ⊆ [−1, 1] over which the resulting PLP remains bounded and fea-
sible. To ﬁnd this ‘safe’ range we evaluate u at increasingly large values and
try to solve the corresponding LP, expanding [umin, umax] if successful. For each
true PLP, we generate 20 equally spaced training points spanning [umin, umax].
We also sample 20 test points u sampled uniformly from [umin, umax]. We then
initialize learning from a corrupted PLP by setting wini = wtru + η where each
element of η ∼ U [−0.2, 0.2].

Hyperparameters are sampled as t(0) ∈ {0.5, 1, 5, 10}, µ ∈ {1.5, 2, 5, 10, 20}
and αAb ∈ {1, 10}, and αc is then chosen to be a factor of {0.01, 1, 100} times
αAb, i.e., a relative learning rate. Here, αc and αAb control the learning rate
of parameters within w that determine c and (A, b), respectively. In total, we
generate 20 diﬀerent hyperparameter combinations. We run our algorithm on
each instance with all hyperparameter combinations and record the best ﬁnal
error value. A constant value of (cid:15) = 10−5 is used.

Fig. 4. Learning in non-parametric IO problems.

We demonstrate the performance of our method on learning parametric LPs
of the form shown in (6) with d = 2, m = 8, and d = 10, m = 36. In Figure
4, we report two metrics evaluated on the training set, namely MSE(wini) and
MSE(wlrn), and one metric for the test set, MSE(wlrn). Figure 4 (iii) shows an
example of an instance with d = 2, m = 8 from the training set. We see that,
overall, our deep learning method works well on 2-dimensional problems with the
training and testing error both being much smaller than the initial error. In the
vast majority of cases the test error is also comparable to training error, though
there are a few cases where it is worse, which indicates a failure to generalize
well. For 10D instances, the algorithm signiﬁcantly improves MSE(wlrn) over the

initiallearned(i) 2D PLP instances    (8 constraints)squared errorinilrntest(ii) 10D PLP instances    (36 constraints)inilrntest(iii) 2D PLP instance exampleloss = 0.44loss = 0.00xtrunDeep Inverse Optimization

11

initialization MSE(wini), but in most cases fails to drive the loss to zero, either
due to local minima or slow convergence. Again, performance on the test set is
similar to that on training set.

5 Discussion

The conceptual message that we wish to reinforce is that inverse optimization
should be viewed as a form of deep learning, and that unrolling gives easy ac-
cess to the gradients of any parameter used directly or indirectly in the forward
optimization process. There are many aspects to this view that merit further
exploration. What kind of forward optimization processes can be inversely opti-
mized this way? Which ideas and algorithms from the deep learning community
will help? Are there aspects of IO that make gradient-based learning more chal-
lenging than in deep learning at large? Conclusive answers are beyond the scope
of this paper, but we discuss these and other questions below.

Generality and applicability. As a proof of concept, this paper uses linear
programming for the forward problems and IPM with barrier method as the
forward optimization process. In principle, the framework is applicable to any
forward process for which automatic diﬀerentiation can be applied. This obser-
vation does not mean that ours is the best approach for a specialized IO problem,
such as learning c from a single point [12] or multiple points within the same
feasible region [14], but it provides a new strategy.

The practical message of our paper is that, when faced with novel classes
or novel parameterizations of IO problems, the unrolling strategy provides con-
venient access to a suite of general-purpose gradient-based algorithms for solv-
ing the IO problem at hand. This strategy is made especially easy by deep
learning libraries that support dynamic ‘computation graphs’ such as PyTorch.
Researchers working within this framework can rapidly apply IO to many diﬀer-
entiable forward optimization processes, without having to derive the algorithm
for each case. Automatic diﬀerentiation and backpropagation have enabled a
new level of productivity for deep learning research, and they may do the same
for inverse optimization research. Applying deep inverse optimization does not
require expertise in deep learning itself.

We chose IPM as a forward process because the inner Newton step is dif-
ferentiable and because we expected the gradient to temperature parameter t
to have a stabilizing eﬀect on the gradient. For non-diﬀerentiable optimization
processes, it may still be possible to develop diﬀerentiable versions. In deep
learning, many advances have been made by developing diﬀerentiable versions
of traditionally discrete operations, such as memory addressing [20] or sampling
from a discrete distribution [25]. We believe the scope of diﬀerentiable forward
optimization processes may similarly be expanded over time.

Limitations and possible improvements. Deep IO inherits the limitations
of most gradient-based methods. If learning is initialized to the right “basin
of attraction”, it can proceed to a global optimum. Even then, the choice of

12

Y. Tan et al.

learning algorithm may be crucial. When implemented within a steepest descent
framework, as we have here, the learning procedure can get trapped in local
minima or exhibit very slow convergence. Such eﬀects are why most instances in
Figure 4 (ii) failed to achieve zero loss.

In deep learning with neural networks, poor local minima become exponen-
tially rare as the dimension of the learning problem increases [15,33]. A typical
strategy for training neural networks is therefore to over-parameterize (use a high
search dimension) and then use regularization to avoid over-ﬁtting to the data.
In deep IO, natural parameterizations of the forward process may not permit an
increase in dimension, or there may not be enough observations for regularization
to compensate, so local minima remain a potential obstacle. We believe train-
ing and regularization methods specialized to low-dimensional learning problems
such as by Sahoo et al. [32] may be applicable here.

We expect that other techniques from deep learning, and from gradient-based
optimization in general, will translate to deep IO. For example, optimization
techniques with second-order aspects such as momentum [35] and L-BFGS [10]
are readily available in deep learning frameworks. Other deep learning ‘tricks’
may be applicable to stabilizing deep IO. For example, we observe that, when
c is normal to a constraint, the gradient with respect to c can suddenly grow
very large. We stabilized this behaviour with line search, but a similar ‘explod-
ing gradient’ phenomenon exists when training deep recurrent neural networks,
and gradient clipping [27] is a popular way to stabilize training. A detailed in-
vestigation of applicable deep learning techniques is outside the scope of this
paper.

Deep IO may be more successful when the loss with respect to the forward
process can be annealed or ‘smoothed’ in a manner akin to graduated non-
convexity [7]. Our (cid:15)-decay strategy is an example of this, as discussed below.

Finally, it may be possible to develop hybrid approaches, combining gradient-

based learning with closed-form solutions or combinatorial algorithms.

Loss function and metric of success. One advantage of the deep inverse
optimization approach is that it is can accommodate various loss functions, or
combinations of loss functions, without special development or analysis. For
example one could substitute other p-norms, or losses that are robust to outliers,
and the gradient will be automatically available. This ﬂexibility may be valuable.
Special loss functions have been important in machine learning, especially for
structured output problems [21]. The decision variables of optimization processes
are likewise a form of structured output.

In this study we chose two classical loss functions: absolute duality gap and
squared error. The behaviour of our algorithm varied depending on the loss func-
tion used. Looking at Figure 3 (ii) it appears that deep IO performs better with
ADG loss than with SE loss when learning c, A, b jointly. However, this perfor-
mance is due to the theoretical property that ADG can be zero even when the
observed target point is arbitrarily infeasible [12]. With ADG, all the IO solver
needs to do is adjust c, A, b so that xlrn −xtru is orthogonal to c, which in no way
requires the learned model to be capable of generating xtru as an optimum. In

Deep Inverse Optimization

13

other words, ADG is meaningful mainly when the true feasible region is known,
as in Figure 3 (i). When the true region is unknown, SE prioritizes solutions that
directly generate the observations xn
tru, and may therefore be a more meaningful
loss function. That is why we used it for our parametric experiments depicted
in Figure 4.

Fig. 5. Loss surfaces for the feasible region and target shown in Figure 1 (i).

Minimizing the SE loss also appears to be more challenging for steepest
descent. To get a sense for the characteristics of ADG versus SE from the point
of view of varying c, consider Figure 5, which depicts the loss for the IO problem
in Figure 1 (i) using both high precision ((cid:15) = 10−5) and low precision ((cid:15) =
0.1, 0.01) for IPM. Because the ADG loss is directly dependent on c, the loss
varies smoothly even as the corresponding optimum x∗ stays ﬁxed. The SE
loss, in contrast, is piece-wise constant; an instantaneous perturbation of c will
almost never change the SE loss in the limit of (cid:15) → 0. Note that the gradients
derived by implicit diﬀerentiation [2] indicate ∂(cid:96)
∂c = 0 everywhere in the linear
case, which would mean c cannot be learned by gradient descent. IPM can
learn c nonetheless because the barrier sharpness parameter t smooths the loss,
especially at low values. The precision parameter (cid:15) limits the maximal sharpness
during forward optimization, and so the gradient ∂(cid:96)
∂c is not zero in practice,
especially when (cid:15) is weak. Notice that the SE loss surface becomes qualitatively
smoother, whereas ADG is not fundamentally changed. Also notice that when c
is normal to a constraint (when the optimal point is about to transition from one
point to another) the gradient ∂(cid:96)
∂c explodes even when the problem is smoothed.

Computational eﬃciency. Our paper is conceptual and focuses on ﬂexibility
and the likelihood of success, rather than computational eﬃciency. Many appli-
cations of IO are not real-time, and so we expect methods with running times
on the order of seconds or minutes to be of practical use. Still, we believe the
framework can be both ﬂexible and fast.

(i) ADG loss surface(ii) SE loss surfaceabsolute duality gapsquared errorangle of c vectorangle of c vector¼2¼0¼2¼0eps = 0.00001eps = 0.01eps = 0.00001eps = 0.114

Y. Tan et al.

Deep learning frameworks are GPU accelerated and scale well with the size
of an individual forward problem, so large instances are not a concern. A bigger
issue for GPUs is solving many small or moderate instances eﬃciently. Amos
and Kolter [2] developed a batch-mode GPU forward solver to address this.

What is more concerning for the unrolling strategy is that forward opti-
mization processes can be very deep, with hundreds or thousands of iterations.
Backpropagation requires keeping all the intermediate values of the forward pass
resident in memory, for later use in the backward pass. The computational cost
of backpropagation is comparable to that of the forward process, so there is no
asymptotic advantage to skipping the backwards pass. Although memory usage
was small in our instances, if the memory usage is linear with depth, then at
some depth the unrolling strategy will cease to be practical compared to Amos
and Kolter’s [2] implicit diﬀerentiation approach. However, we observed that for
IPM most of the gradient contribution comes from the ﬁnal ten Newton steps
before termination. In other words, there is a vanishing gradient with depth,
which means the gradient can be well-approximated in practice with truncated
backpropagation through time (see [34] for review), which uses a small constant
pool of memory regardless of depth.

In practice, we suggest that the unrolling approach is convenient during the
development and exploration phase of IO research. Once an IO model is proven
to work, it can potentially be made more eﬃcient by deriving the implicit gra-
dients [2] and comparing them to the unrolled implementation as a reference.
Still, more important than improving any of these constants is to use asymptot-
ically faster learning algorithms actively being developed in the deep learning
community.

6 Conclusion

We developed a deep learning framework for inverse optimization based on back-
propagation through an iterative forward optimization process. We illustrate the
potential of this framework via an implementation where the forward process is
the interior point barrier method. Our results on linear non-parametric and para-
metric problems show promising performance. To the best of our knowledge, this
paper is the ﬁrst to explicitly connect deep learning and inverse optimization.

References

1. Ahuja, R.K., Orlin, J.B.: Inverse optimization. Operations Research 49(5), 771–783

(2001)

2. Amos, B., Kolter, J.Z.: OptNet: Diﬀerentiable optimization as a layer in neural net-
works. In: Proceedings of the 34th International Conference on Machine Learning,
PMLR 70. pp. 136–145 (2017)

3. Aswani, A., Shen, Z.J., Siddiq, A.: Inverse optimization with noisy data. Operations

Research 63(3) (2018)

4. B¨armann, A., Martin, A., Pokutta, S., Schneider, O.: An online-learning approach

to inverse optimization. arXiv preprint arXiv:1810.12997 (2018)

Deep Inverse Optimization

15

5. B¨armann, A., Pokutta, S., Schneider, O.: Emulating the expert: Inverse optimiza-
tion through online learning. In: International Conference on Machine Learning.
pp. 400–410 (2017)

6. Bengio, Y., Lodi, A., Prouvost, A.: Machine learning for combinatorial optimiza-
tion: a methodological tour d’horizon. arXiv preprint arXiv:1811.06128 (2018)
7. Blake, A., Zisserman, A.: Visual Reconstruction. MIT Press, Cambridge, MA, USA

(1987)

8. Bonami, P., Lodi, A., Zarpellon, G.: Learning a classiﬁcation of mixed-integer
quadratic programming problems. In: International Conference on the Integration
of Constraint Programming, Artiﬁcial Intelligence, and Operations Research. pp.
595–604. Springer (2018)

9. Boyd, S., Vandenberghe, L.: Convex optimization. Cambridge university press

(2004)

10. Byrd, R.H., Lu, P., Nocedal, J., Zhu, C.: A limited memory algorithm for bound
constrained optimization. SIAM Journal on Scientiﬁc Computing 16(5), 1190–1208
(1995)

11. Chan, T.C.Y., Craig, T., Lee, T., Sharpe, M.B.: Generalized inverse multi-objective
optimization with application to cancer therapy. Operations Research 62(3), 680–
695 (2014)

12. Chan, T.C.Y., Lee, T., Terekhov, D.: Goodness of ﬁt in inverse optimization. Man-

agement Science (2018)

13. Chan, T.C.Y., Kaw, N.: Inverse optimization for the recovery of constraint param-

eters. arXiv preprint arXiv:1811.00726 (2018)

14. Chan, T.C.Y., Lee, T., Mahmood, R., Terekhov, D.: Multiple observations and
goodness of ﬁt in generalized inverse optimization. arXiv preprint arXiv:1804.04576
(2018)

15. Dauphin, Y.N., Pascanu, R., Gulcehre, C., Cho, K., Ganguli, S., Bengio, Y.: Iden-
tifying and attacking the saddle point problem in high-dimensional non-convex
optimization. In: Advances in neural information processing systems. pp. 2933–
2941 (2014)

16. Dong, C., Chen, Y., Zeng, B.: Generalized inverse optimization through online
learning. In: Advances in Neural Information Processing Systems. pp. 86–95 (2018)
17. Donti, P., Amos, B., Kolter, J.Z.: Task-based end-to-end model learning in stochas-
tic optimization. In: Advances in Neural Information Processing Systems. pp. 5484–
5494 (2017)

18. Fischetti, M., Jo, J.: Deep neural networks and mixed integer linear optimization.

Constraints pp. 1–14 (2018)

19. Goodfellow, I., Bengio, Y., Courville, A.: Deep Learning. MIT Press (2016), http:

//www.deeplearningbook.org

20. Graves, A., Wayne, G., Reynolds, M., Harley, T., Danihelka, I., Grabska-
Barwi´nska, A., Colmenarejo, S.G., Grefenstette, E., Ramalho, T., Agapiou, J.,
et al.: Hybrid computing using a neural network with dynamic external memory.
Nature 538(7626), 471 (2016)

21. Hazan, T., Keshet, J., McAllester, D.A.: Direct loss minimization for structured
prediction. In: Advances in Neural Information Processing Systems. pp. 1594–1602
(2010)

22. Keshavarz, A., Wang, Y., Boyd, S.: Imputing a convex objective function. In: 2011
IEEE International Symposium on Intelligent Control. pp. 613–619. IEEE (2011)

23. LeCun, Y., Bengio, Y., Hinton, G.: Deep learning. Nature 521, 436–444 (2015)

16

Y. Tan et al.

24. Maclaurin, D., Duvenaud, D., Adams, R.: Gradient-based hyperparameter op-
timization through reversible learning. In: International Conference on Machine
Learning. pp. 2113–2122 (2015)

25. Maddison, C.J., Mnih, A., Teh, Y.W.: The concrete distribution: A continuous

relaxation of discrete random variables. arXiv preprint arXiv:1611.00712 (2016)

26. Mahmood, R., Babier, A., McNiven, A., Diamant, A., Chan, T.C.Y.: Automated
treatment planning in radiation therapy using generative adversarial networks.
arXiv preprint arXiv:1807.06489 (2018)

27. Pascanu, R., Mikolov, T., Bengio, Y.: Understanding the exploding gradient prob-

lem. CoRR, abs/1211.5063 (2012)

28. Paszke, A., Gross, S., Chintala, S., Chanan, G., Yang, E., DeVito, Z., Lin, Z.,
Desmaison, A., Antiga, L., Lerer, A.: Automatic diﬀerentiation in PyTorch. In:
NeurIPS AutoDiﬀ Workshop (2017)

29. QHull

Library:

(2018),
reference/generated/scipy.spatial.ConvexHull.html,
November 2, 2018]

https://docs.scipy.org/doc/scipy-0.19.0/
accessed

[Online;

30. Rumelhart, D.E., Hinton, G.E., Williams, R.J.: Learning representations by back-

propagating errors. Nature 323(6088), 533–536 (1986)

31. Saez-Gallego, J., Morales, J.M.: Short-term forecasting of price-responsive loads

using inverse optimization. IEEE Transactions on Smart Grid (2017)

32. Sahoo, S.S., Lampert, C.H., Martius, G.: Learning equations for extrapolation and

control. In: International Conference on Machine Learning (ICML) (2018)

33. Soudry, D., Hoﬀer, E.: Exponentially vanishing sub-optimal local minima in mul-

tilayer neural networks. arXiv preprint arXiv:1702.05777 (2017)

34. Sutskever, I.: Training recurrent neural networks. University of Toronto Toronto,

Ontario, Canada (2013)

35. Sutskever, I., Martens, J., Dahl, G., Hinton, G.: On the importance of initializa-
tion and momentum in deep learning. In: International Conference on Machine
Learning. pp. 1139–1147 (2013)

36. Troutt, M.D., Brandyberry, A.A., Sohn, C., Tadisina, S.K.: Linear programming
system identiﬁcation: The general nonnegative parameters case. European Journal
of Operational Research 185(1), 63–75 (2008)

37. Troutt, M.D., Tadisina, S.K., Sohn, C., Brandyberry, A.A.: Linear programming
system identiﬁcation. European Journal of Operational Research 161(3), 663–672
(2005)

