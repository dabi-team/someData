2
2
0
2

r
a

M
1

]

G
L
.
s
c
[

3
v
8
1
2
3
0
.
0
1
8
1
:
v
i
X
r
a

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR
PROGRAMMING

DANIEL BIENSTOCK, GONZALO MUÑOZ, AND SEBASTIAN POKUTTA

Abstract. Deep learning has received much attention lately due to the impressive em-
pirical performance achieved by training algorithms. Consequently, a need for a better
theoretical understanding of these problems has become more evident in recent years. In
this work, using a uniﬁed framework, we show that there exists a polyhedron which en-
codes simultaneously all possible deep neural network training problems that can arise
from a given architecture, activation functions, loss function, and sample-size. Notably,
the size of the polyhedral representation depends only linearly on the sample-size, and a
better dependency on several other network parameters is unlikely (assuming 𝑃 ≠ 𝑁 𝑃).
Additionally, we use our polyhedral representation to obtain new and better computational
complexity results for training problems of well-known neural network architectures. Our
results provide a new perspective on training problems through the lens of polyhedral theory
and reveal a strong structure arising from these problems.

1. Introduction

Deep Learning is a powerful tool for modeling complex learning tasks. Its versatility
allows for nuanced architectures that capture various setups of interest and has demonstrated
a nearly unrivaled performance on learning tasks across many domains. This has recently
triggered a signiﬁcant interest in the theoretical analysis of training such networks. The
training problem is usually formulated as an empirical risk minimization problem (ERM)
that can be phrased as

(1)

𝐷

ℓ

𝑓

(

(

ˆ𝑥𝑖, 𝜙

, ˆ𝑦𝑖

)

,

)

1
𝐷

min
Φ
𝜙
∈
ˆ𝑥𝑖, ˆ𝑦𝑖

where ℓ is some loss function,

Õ𝑖=1
𝐷
𝑖=1 is an i.i.d. sample from some data distribution
Φ with Φ being the
D
parameter space of the considered architecture (e.g., network weights). The empirical risk
minimization problem is solved in lieu of the general risk minimization problem (GRM)

)
is a neural network architecture parameterized by 𝜙

, and 𝑓

∈

(

min
Φ
𝜙
∈
which is usually impossible to solve due to the inaccessibility of

) ∈D [

𝑥, 𝜙

, 𝑦

𝑥,𝑦

)]

ℓ

(

(

)

𝑓

(

𝔼

.

D

While most eﬀorts on handling (1) have been aimed at practical performance, much less
research has been conducted in understanding its theoretical diﬃculty from an optimization
standpoint. In particular, only few results account for the eﬀect of 𝐷, the sample size, in

(DB) Industrial Engineering and Operations Research, Columbia University, USA
(GM) Institute of Engineering Sciences, Universidad de O’Higgins, Chile
(SP) Zuse Institute Berlin, Germany
E-mail addresses: dano@columbia.edu, gonzalo.munoz@uoh.cl, pokutta@zib.de.
2020 Mathematics Subject Classiﬁcation. Primary: 90C05, 68T01, 52B05.
Key words and phrases. deep learning, linear programming, polyhedral theory.

1

 
 
 
 
 
 
2

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

the structure and hardness of (1). In this work, we contribute to the understanding of this
problem by showing there exists a polyhedral encoding of empirical risk minimization prob-
lems in (1) associated with the learning problems for various architectures with remarkable
features. For a given architecture and sample size, our polyhedron encodes approximately
all possible empirical risk minimization problems with that sample size simultaneously.
The size of the polyhedron is roughly (singly!) exponential in the input dimension and
in the parameter space dimension, but, notably, linear in the size of the sample. This
result provides a new perspective on training problems and also yields new bounds on the
computational complexity of various training problems from a uniﬁed approach.

1, 1

𝑚.

Throughout this work we assume both data and parameters to be well-scaled, which is
a common assumption and mainly serves to simplify the representation of our results; the
main assumption is the reasonable boundedness, which can be assumed without signiﬁcant
loss of generality as actual computations assume boundedness in any case (see also [25]
for arguments advocating the use of normalized coeﬃcients in neural networks). More
speciﬁcally, we assume Φ

𝑁 as well as

satisﬁes

1, 1

1, 1

𝑥, 𝑦

𝑥, 𝑦

𝑛

⊆ [−

]

(

) ∼ D

(

) ∈ [−

]

×

]

[−
1.1. Related Work. We are not aware of any encoding representing multiple training
problems simultaneously. However, given its implications on the training problems for
a ﬁxed sample, our work is related to [35], [20], and [4]. In [35] the authors show that
ℓ1-regularized networks can be learned improperly1 in polynomial time (with an expo-
nential architecture-dependent constant) for networks with ReLU-like activations. These
results were generalized by [20] to ReLU activations, but the running time obtained is not
polynomial. In contrast, [4] considered exact learning however only for one hidden layer.
To the best of our knowledge, the only work where a polyhedral approach is used to
analyze the computational complexity of training of neural networks is [4], where the
authors solve (1) for 1 hidden layer using a collection of convex optimization problems over
a polyhedral feasible region. In practice, even though the most common methods used for
tackling (1) are based on Stochastic Gradient Descent (SGD), there are some notable and
surprising examples where linear programming has been used to train neural networks. For
example, in [6, 7, 30, 27] the authors construct a 1-hidden layer network by sequentially
increasing the number of nodes of the hidden layer and solving linear programs to update
the weights, until a certain target loss is met.

Linear programming tools have also been used within SGD-type methods in order to
compute optimal step-sizes in the optimization of (1) [8] or to strictly enforce structure in
Φ using a Frank-Wolfe approach instead of SGD [28, 34] . Finally, a back-propagation-like
algorithm for training neural network, which solves Mixed-Integer Linear problems in each
layer, was recently proposed as an alternative to SGD [19].

Other notable uses of Mixed-Integer and Linear Programming technology in other
aspects of Deep Learning are include feature visualization [18], generating adversarial
examples [15, 18, 24], counting linear regions of a Deep Neural Network [31], performing
inference [2] and providing strong convex relaxations for trained neural networks [3].

We refer the reader to the book by [21] and the surveys by [17, 13, 33] for in-depth

descriptions and analyses of the most commonly used training neural networks.

1.2. Contribution. In this work, we consider neural networks with an arbitrary number of
layers 𝑘 and a wide range of activations, loss functions, and architectures. We ﬁrst establish
a general framework that yields a polyhedral representation of generic (regularized) ERM

1In improper learning the predictor may not be a neural network, but will behave similarly to one.

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

3

problems. Our approach is motivated by the work of [10] which describes schemes for
approximate reformulation of many non-convex optimization problems as linear programs.
Our results allow the encoding and analysis of various deep network setups simply by
plugging-in complexity measures for the constituting elements such as layer architecture,
activation functions, and loss functions.

(

=

ˆ𝑋, ˆ𝑌

ˆ𝑥𝑖, ˆ𝑦𝑖

𝐷
𝑖=1 there is a face

1.2.1. Polyhedral encoding of ERM problems. Given 𝜖 > 0 and a sample size 𝐷 there
exists a data-independent polytope (it can be written down before seeing the data) with the
following properties:
Solving the ERM problem to 𝜖-optimality in data-dependent faces. For every realized
𝑃 of said polytope such that optimizing
sample
ˆ𝑋 , ˆ𝑌 ⊆
F
)
ˆ𝑋 , ˆ𝑌 solves (1) to 𝜖-optimality returning a parametrization
certain linear function over
˜𝜙
Φ which is part of our hypothesis class. As such, the polytope has a build-once-solve-
many feature.
Size of the polytope. The size, measured as bit complexity, of the polytope is roughly
is a constant depending on ℓ, 𝑓 , and Φ that we will introduce
𝑂
L
later, 𝑛, 𝑚 are the dimensions of the data points, i.e., ˆ𝑥𝑖
,
and 𝑁 is the dimension of the parameter space Φ.

ℝ𝑚 for all 𝑖

ℝ𝑛 and ˆ𝑦𝑖

𝜖
L/

where

𝑚 𝐷

∈ [

((

𝐷

F

∈

∈

∈

2

𝑁

)

(

)

)

]

𝑛

+

+

It is important to mention that

measures certain Lipschitzness in the ERM training
problem. While not exactly requiring Lipschitz continuity in the same way, Lipschitz
constants have been used before for measuring training complexity in [20] and more recently
have been shown to be linked to generalization by [22].

L

We point out three important features of this polyhedral encoding. First, it has provable
optimality guarantees regarding the ERM problem and a size with linear dependency on
the sample size without assuming convexity of the optimization problem. Second, the
polytope encodes reasonable approximations of all possible data sets that can be given as
an input to the ERM problem. This in particular shows that our construction is not simply
𝑚,
discretizing space: if one considers a discretization of data contained in
the total number of possible data sets of size 𝐷 is exponential in 𝐷, which makes the linear
dependence on 𝐷 of the size of our polytope a remarkable feature. Finally, our approach
can be directly extended to handle commonly used regularizers (B). For ease of presentation
though we omit regularizers throughout our main discussions.

× [−

1, 1

1, 1

[−

]

]

𝑛

Remark 1.1. We remark that our goal is to provide new structural results regarding
training problems. Converting our approach into a training algorithm, while subject of
future research, will certainly take considerable eﬀorts. Nonetheless, we will rely on known
training algorithms with provable guarantees and their running times for providing a notion
of how good our results are. Note that this is a slightly unfair comparison to us, as training
algorithms are not data-independent as our encoding.

1.2.2. Complexity results for various network architectures. We apply our methodology
to various well-known neural network architectures by computing and plugging-in the
corresponding constituting elements into our uniﬁed results. We provide an overview of
our results in Table 1, where 𝑘 is the number of layers, 𝑤 is width of the network, 𝑛
𝑚
are the input/output dimensions and 𝑁 is the total number of parameters. In all results the
node computations are linear with bias term and normalized coeﬃcients, and activation
functions with Lipschitz constant at most 1 and with 0 as a ﬁxed point; these include ReLU,
Leaky ReLU, eLU, Tanh, among others.

/

4

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

Table 1. Summary of results for various architectures. DNN refers to a
fully-connected Deep Neural Network, CNN to a Convolutional Neural
Network and ResNet to a Residual Network. 𝐺 is the graph deﬁning the
Network and Δ is the maximum in-degree in 𝐺.

Type

Loss

𝑂
Absolute/Quadratic/Hinge
DNN
Cross Entropy w/ Soft-Max 𝑂
DNN
𝑂
Absolute/Quadratic/Hinge
CNN
𝑂
ResNet Absolute/Quadratic/Hinge
ResNet Cross Entropy w/ Soft-Max 𝑂

Size of polytope
𝑛

𝑚𝑤𝑂
(
𝑚 log
𝑚𝑤𝑂
𝑚Δ𝑂
(
𝑚 log

𝑘2

𝜖
) /
𝑤𝑂
𝑚
(
(cid:1)
)
(
𝑛
𝑘2
𝜖
(
) /
𝑘2
𝜖
) /
(cid:1)
Δ𝑂
𝑚
(cid:1)
)

(

𝑛

(

+
𝑘2

+

𝑚

𝑁 𝐷
𝑛
𝜖
) /
𝑁 𝐷
𝑚
+
(cid:1)
𝑁 𝐷
𝑛
𝜖
) /

+

+
𝑚

+
𝑘2

𝑚

+

𝑁 𝐷

+
(cid:1)

(cid:1)
𝑚
+
(cid:1)

+

𝑁 𝐷

(cid:1)

(cid:1)

(cid:1)

(cid:0)(cid:0)
(cid:0)(cid:0)
(cid:0)(cid:0)
(cid:0)(cid:0)
(cid:0)(cid:0)

Notes
𝑁 =
𝑁 =
𝑁

|
|
≪ |

𝐸
(
𝐸
(
𝐸

𝐺
)|
𝐺
)|
𝐺
)|

(

Certain improvements in the results in Table 1 can be obtained by further specifying if
the ERM problem corresponds to regression or classiﬁcation. Nonetheless, these improve-
ments are not especially signiﬁcant and in the interest of clarity and brevity we prefer to
provide a uniﬁed discussion.

The reader might wonder if the exponential dependence on the other parameters of our
polytope sizes can be improved, namely the input dimension 𝑛
𝑚, parameter space dimen-
sion 𝑁 and depth 𝑘. The dependence on the input dimension is unlikely to be improved due
to NP-hardness of training problems ([11, 12]) and obtaining a polynomial dependence on
the parameter space dimension or on the depth remains open [4].

+

The rest of this paper is organized as follows: in Section 2 we introduce the main tools
we use throughout the paper. These include the deﬁnition of treewidth and a generalization
of a result by [10]. In Section 3 we show how multiple ERM problems can be encoded
using a single polytope whose size depend only linearly in the sample-size. We also
analyze this polytope’s structure and show that its face structure are related to each possible
ERM problem.
In Section 4 we specialize our results to ERM problems arising from
Neural Networks by explicitly computing the resulting polytope size for various common
architectures. In Section 5 we show the sparsity of the network itself can be exploited to
obtain an improvement in the polyhedral encoding’s size. In Section 6 we show that our
LP generalizes well, in the sense that our benign dependency on the sample size allows
us to obtain a moderate-sized polyhedron that approximates the general risk minimization
problem. Finally, in Section 7 we conclude.

2. Preliminaries

In the following let
and 𝐸

𝐻

𝐻

𝑛

1, . . . , 𝑛

{
to denote the vertex-set and edge-set of 𝐻, respectively, and 𝛿𝐻

. Given a graph 𝐻, we will
𝑢

0, . . . , 𝑛

and

𝑛

}

{

}

]

[

]

[

use 𝑉
will be the set of edges incident to vertex 𝑢. We will need:

(

)

)

(

(

)

0 (cid:17)

(cid:17)

Deﬁnition 2.1. For 𝑔 :
the 𝑝-norm over
K
(whenever it exists).

as

L

K ⊆
𝑔
𝑝
)
(

ℝ𝑛
→
, satisfying

ℝ, we denote its Lipschitz constant with respect to
𝑔

𝑝 for all 𝑥, 𝑦

𝑔

𝑔

𝑥

𝑦

𝑦

𝑥

𝑝

|

(

) −

(

)| ≤ L

(

) k

−

k

∈ K

We next deﬁne the Lipschitz constant of an ERM problem with respect to the inﬁnity

norm.

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

5

Deﬁnition 2.2. Consider the ERM problem (1) with parameters 𝐷, Φ, ℓ, 𝑓 . We deﬁne the
Architecture Lipschitz Constant

as

(2)

over the domain

=

1, 1

[−

K

L (
𝑛

]

×

𝐷, Φ, ℓ, 𝑓
(cid:17)

L (
𝐷, Φ, ℓ, 𝑓

)

Φ

× [−

)
1, 1

L∞ (
𝑚.

]

ℓ

𝑓

,

(·

(

,

·)

·))

We emphasize that in (2) we are considering the data-dependent entries as variables as
well, and not only the parameters Φ as it is usually done in the literature. This subtlety will
become clear later.

Finally, in the following let 𝔼𝜔
with respect to the random variable 𝜔

Ω

∈

and 𝕍 𝜔
Ω
∈
Ω, respectively.

[·]

[·]
∈

denote the expectation and variance

Ï

2.1. Neural Networks. A neural network can be understood as a function 𝑓 deﬁned
ℝ𝑚. The directed graph
ℝ𝑛 to 𝑓
over a directed graph that maps inputs 𝑥
𝐺 =
𝑉, 𝐸
, which represents the network architecture, often naturally decomposes into
(
layers 𝑉 =
𝑉, where 𝑉0 is referred to as the input layer and 𝑉𝑘 as the
⊆
output layer. To all other layers we refer to as hidden layers.

0 𝑉𝑖 with 𝑉𝑖

) ∈

∈

∈[

𝑥

)

(

𝑘

]

𝑖

(

Each vertex 𝑣
𝑤, 𝑣

𝑉,
𝑘
0 has an associated set of in-nodes denoted by 𝛿+(
𝑉𝑖 with 𝑖
) ⊆
]
∈ [
∈
𝑉 deﬁned
and an associated set of out-nodes 𝛿−(
𝑣
𝛿+(
𝐸 for all 𝑤
so that
)
∈
) ∈
are the inputs (from data) and if 𝑖 = 𝑘, then 𝛿−(
analogously. If 𝑖 = 0, then 𝛿+(
𝑣
𝑣
are
)
the outputs of the network. These graphs do neither have to be acyclic (as in the case
of recurrent neural networks) nor does the layer decomposition imply that arcs are only
allowed between adjacent layers (as in the case of ResNets).
In feed-forward networks,
however, the graph is assumed to be acyclic.

) ⊆

𝑣

𝑣

)

]

𝑘

∈

∈ [

Each node 𝑣

𝑉 performs a node computation 𝑔𝑖

ℝ with
) | →
is typically a smooth function (often these are linear or aﬃne linear functions) and
ℝ with 𝑖
𝛿+(
𝑘
is
]
∈ [
= max
0, 𝑥
𝑥
)
}
{
(
is set to 𝑎𝑖
𝑘
for nodes in layer 𝑖
.
]
∈ [
𝑖
1
𝑗=0𝑉 𝑗, i.e.,
𝑣
−
) ⊆ ∪

𝑖
then the node activation is computed as 𝑎𝑖
→
a (not necessarily smooth) function (e.g., ReLU activations of the form 𝑎𝑖
and the value on all out-nodes 𝑤
𝛿+(
𝛿−(
In feed-forward networks, we can further assume that if 𝑣
∈
all arcs move forward in the layers.

𝛿+(
, where 𝑎𝑖 : ℝ

𝑣
)))
𝑉𝑖, then 𝛿+(

, where 𝑔𝑖 : ℝ |

𝛿+ (

)))

𝑔𝑖

𝑔𝑖

))

∈

𝑣

𝑣

𝑣

(

(

(

)

)

(

(

𝑣

2.2. Treewidth. Treewidth is an important graph-theoretical concept in the context of
solving optimization problems with ‘sparse’ structure. This parameter is used to measure
how tree-like the graph is, and its use will be the main workhorse behind our results

Deﬁnition 2.3. A tree-decomposition ([29]) of an undirected graph 𝐺 is a pair
where 𝑇 is a tree and 𝑄 =
𝑄𝑡
𝑇
such that
)}
: 𝑣
, the set
(i) For all 𝑣
(ii) For each
𝑉
𝐺
𝐸
such that
(
{
: 𝑡
The width of the decomposition is deﬁned as max
𝑄𝑡
𝐺 is the minimum width over all tree-decompositions of 𝐺.

forms a sub-tree 𝑇𝑣 of 𝑇, and
𝑇𝑢
1. The treewidth of

𝑉
(
∈
𝑇
𝑉
{
)
(
∈
there is a 𝑡

is a family of subsets of 𝑉

𝑉
∈
(
𝑢, 𝑣
{

𝑇, 𝑄

(

)

𝑄𝑡 , i.e., 𝑡

𝑢, 𝑣
𝑉

} ⊆
𝑇
(

)
} ∈

∈
𝑇
(

)} −

𝑇𝑣.

𝑄𝑡

: 𝑡

𝐺

𝐺

{|

∩

∈

∈

∈

}

{

)

)

(

)

𝑡

|

of a tree-decomposition

We refer to the 𝑄𝑡 as bags as customary. In addition to width, another important feature
.
)|
An alternative deﬁnition to Deﬁnition 2.3 of treewidth that the reader might ﬁnd useful
is the following; recall that a chordal graph is a graph where every induced cycle has length
exactly 3.

we use is the size of the tree-decomposition given by

𝑇, 𝑄

𝑉

𝑇

(

)

(

|

Deﬁnition 2.4. An undirected graph 𝐺 =
graph 𝐻 =

with 𝐸

(

𝐸 ′ and clique number

has treewidth
𝜔

1.

)

𝑉, 𝐸

𝑉, 𝐸 ′)

(

⊆

≤

+

𝜔 if there exists a chordal

≤

6

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

1

4

6

2

7

3

5

8

(a) Graph 𝐺

1 2
4

2 3
5

2 4
7

2 5
7

4 6
7

5 7
8

(b) A tree-decomposition of 𝐺 of width 2, with the
sets 𝑄𝑡 indicated inside each node of the tree.

Figure 1. Example of graph and valid tree-decomposition

𝐻 in the deﬁnition above is sometimes referred to as a chordal completion of 𝐺. In
Figure 1 we present an example of a graph and a valid tree-decomposition. The reader can
easily verify that the conditions of Deﬁnition 2.3 are met in this example. Moreover, using
Deﬁnition 2.4 one can verify that the treewidth of the graph in Figure 1 is exactly 2.

Two important folklore results we use are the following.

Lemma 2.5. Let 𝐺 be a graph with a valid tree-decomposition
exists a valid tree-decomposition

)
of width at most 𝜔 such that

(
Lemma 2.6. Let 𝐺 be a graph with a valid tree-decomposition
clique of 𝐺. Then there exists 𝑡

𝑇 such that 𝐾

𝑇 ′, 𝑄′)

𝑇,𝑄

(

(

𝑄𝑡 .

|
𝑇, 𝑄

)

(

𝑇 ′)| ∈
and 𝐾

of width 𝜔. Then there
.
𝑂
𝑉

𝐺

𝑉

(|

(
𝐺

)|)
a

)

𝑉

⊆

(

∈

⊆

2.3. Binary optimization problems with small treewidth. Here we discuss how to for-
mulate and solve binary optimization problems that exhibit sparsity in the form of small
treewidth. Consider a problem of the form

BO

)

(

min

s.t.

+

𝑐𝑇 𝑥
𝑓𝑖
𝑥
(
𝑔 𝑗
𝑥

(

𝑑𝑇 𝑦
0
= 𝑦 𝑗
𝑛,

) ≥
𝑥

)
0, 1

∈ {

}

𝑖

𝑗

𝑚

]
𝑝

]

∈ [

∈ [

where the 𝑓𝑖 and 𝑔 𝑗 are arbitrary functions that we access via a function value oracle.

of BO is the graph which
Deﬁnition 2.7. The intersection graph Γ
has a vertex for each 𝑥 variable and an edge for each pair of 𝑥 variables that appear in a
common constraint.

for an instance

[I]

I

Note that in the above deﬁnition we have ignored the 𝑦 variables which will be of great
importance later. The sparsity of a problem is now given by the treewidth of its intersection
graph and we obtain:

Theorem 2.8. Let
width 𝜔, there is an exact linear programming reformulation of
variables and constraints.

be an instance of BO. If Γ

[I]

I

I

has a tree-decomposition
𝑉
with 𝑂

2𝜔

(

(|

𝑇, 𝑄
(
𝑇

)| +

)
𝑝

of

))

(

Theorem 2.8 is a generalization of a theorem by [10] distinguishing the variables 𝑦,
which do not need to be binary in nature, but are fully determined by the binary variables
𝑥. A full proof is omitted as it is similar to the proof in [10]. For the sake of completeness,
we include a proof sketch below.

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

7

Proof. (sketch). Since the support of each 𝑓𝑖 induces a clique in the intersection graph,
𝑄 (Lemma 2.6). The same holds for each 𝑔 𝑗 .
there must exist a bag 𝑄 such that supp
We modify the tree-decomposition

𝑓𝑖
(
𝑇, 𝑄

) ⊆
to include the 𝑦 𝑗 variables the following way:
and add a new bag 𝑄′(
for each diﬀerent 𝑗. This
1, which has each

)

)

𝑗

𝑦 𝑗

]
∪ {

, choose a bag 𝑄 containing supp
and connected to 𝑄.

For each 𝑗
𝑝
∈ [
(
consisting of 𝑄
}
We do this for every 𝑗
, with a diﬀerent 𝑄 ′(
𝑇 ′, 𝑄′)
creates a new tree-decomposition
𝑗
variable 𝑦 𝑗 contained in a single bag 𝑄′(
𝑇 ′|
The size of the tree-decomposition is

𝑗
of width at most 𝜔
which is a leaf.
𝑝.

∈ [

| +

𝑔 𝑗

)
=

𝑇

𝑝

]

)

(

|

|

•

•

+

•

(

)

From here, we proceed as follows:

For each 𝑡

∈

•

𝑦 𝑗 for some 𝑗

𝑝

, we construct

𝑇 ′, if 𝑄 ′𝑡 ∋
𝑡 (cid:17)
𝑥, 𝑦
F
{(
𝑦 = 𝑔 𝑗

∈ [
]
ℝ :
×
0 for supp

𝑄𝑡

0, 1
, 𝑓𝑖

}
𝑥

) ∈ {
𝑥

(

)

(

) ≥

𝑓𝑖

(

) ⊆

𝑄′𝑡 }

{

𝑥

𝑄𝑡

0, 1

otherwise we simply construct
𝑡 (cid:17)
F

) ≥
∈ {
Note that these sets have size at most 2 |
We deﬁne variables 𝑋
at most 2𝜔
𝑉
𝑇 ′)|
(
𝑇 ′ and 𝑣
For each 𝑡

𝑌 , 𝑁
[

𝑓𝑖

𝑥

}

(

:

.

𝑄′𝑡 |.

|
∈

•

•

We formulate the following linear optimization problem

]

where 𝑌 , 𝑁 form a partition of 𝑄′𝑡1 ∩
𝑡 , we create a variable 𝜆𝑣 . These are at most 2𝜔

𝑄′𝑡2. These are

𝑉

|

.

𝑇 ′)|

(

∈ F

0 for supp

𝑓𝑖

(

) ⊆

.

𝑄′𝑡 }

LBO

)

(

min

𝑐𝑇 𝑥

s.t.

𝑑𝑇 𝑦

+
𝜆𝑣 = 1

𝜆𝑣

𝑣𝑖

Õ𝑣
𝑡
∈F

𝑌
Ö𝑖
∈

𝑁 (
Ö𝑖
∈

𝑡
∀

∈

𝑇 ′

1

𝑣𝑖

)

−

𝑌 , 𝑁

∀(

𝑄 ′𝑡 , 𝑡

𝑇 ′

∈

) ⊆

𝑇 ′, 𝑣

𝑇 ′, 𝑖

𝑡
∀
𝑡
∀

∈

∈

𝑡
∈ F
𝑄′𝑡 ∩ [

∈

𝑛

]

𝜆𝑣𝑔 𝑗

𝑣

)

(

𝑗

∀

𝑝

]

∈ [

Õ𝑣
𝑡
∈F
𝑌 , 𝑁
𝑋
[

]

=

0

𝜆𝑣
≥
𝑥𝑖 =

Õ𝑣
𝑡
∈F

𝑦 𝑗 =

𝜆𝑣 𝑣𝑖

Õ𝑣
∈F𝑄′ (

𝑗

)

𝑗

)

Note that the notation in the last constraint is justiﬁed since by construction supp
) ⊆
. The proof of the fact that LBO is equivalent to BO follows from the arguments by
𝑄′(
[10]. The key diﬀerence justifying the addition of the 𝑦 variables relies in the fact that they
, and thus in no intersection of two
only appear in leaves of the tree decomposition
bags. The gluing argument using variables 𝑋
then follows directly, as it is then only
needed for the 𝑥 variables to be binary.

𝑇 ′, 𝑄′)
]

(
𝑌 , 𝑁
[

𝑔 𝑗

(

We can substitute out the 𝑥 and 𝑦 variables and obtain a polytope whose variables are
variables and

. This produces a polytope with at most 2

2𝜔

𝑉

]
(
constraints. This proves the size of the polytope is 𝑂

·

|

𝑇 ′)|
2𝜔
(

𝑉

𝑇

(

(|

)| +

𝑝

))
(cid:3)

only 𝜆𝑣 and 𝑋
2𝜔
𝑉
1
2
(
)|
as required.

+

·

𝑌 , 𝑁
[
𝑇 ′)|
(

8

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

3. Approximation to ERM via a data-independent polytope

We now proceed to the construction of the data-independent polytope encoding multiple

ERM problem. As mentioned before, we assume Φ
1, 1
) ∼ D
]
𝑚 as normalization to simplify the exposition. Since
𝑛
satisﬁes
the BO problem only considers linear objective functions, we begin by reformulating the
ERM problem (1) in the following form:

𝑁 as well as

) ∈ [−

⊆ [−

× [−

1, 1

1, 1

𝑥, 𝑦

𝑥, 𝑦

]

]

(

(

(5)

1
𝐷

min
𝜙
∈

Φ (

𝐿𝑑

𝐷

Õ𝑑=1

𝐿𝑑 = ℓ

𝑓

(

(

ˆ𝑥 𝑑, 𝜙

, ˆ𝑦𝑑

)

) ∀

𝑑

𝐷

∈ [

])

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

3.1. Approximation of the feasible region via an 𝜖-grid. Motivated by this reformulation,
we study an approximation to the following set:

(6)

𝐷, Φ, ℓ, 𝑓

𝑆

(

=

)

{(

𝑥1, ... , 𝑥 𝐷, 𝑦1, ... , 𝑦𝐷, 𝜙, 𝐿

)

𝑥 𝑑, 𝜙

𝑓

(

(

, 𝑦𝑑
𝑛

,
)
𝑚,

+

)
1, 1

]

:𝐿𝑑 = ℓ
𝑥𝑖, 𝑦𝑖
(
Φ
𝜙

∈

) ∈ [−

}
ℝ with

The variables

(

𝑥𝑖, 𝑦𝑖

𝐷
𝑖=1 denote the data variables. Let 𝑟

1. Given
we can approximate 𝑟 as a sum of inverse powers of 2, within additive error
there exist values 𝑧ℎ
, so

with ℎ

0, 1

𝑁𝛾

≤

≤

−

∈

1

𝑟

)

1

log2 𝛾−

∈ (

0, 1

𝛾
proportional to 𝛾. For 𝑁𝛾 (cid:17)
that

)

⌈

∈ {

}

∈ [

]

⌉

(7)

2

1

−

+

·

𝑁𝛾

Õℎ=1

2−

ℎ𝑧ℎ

𝑟

1

2

·

+

≤ −

≤

𝑁𝛾

Õℎ=1

2−

ℎ𝑧ℎ

2𝛾

+

≤

1.

ℎ𝑧ℎ
Our strategy is now to approximately represent the 𝑥, 𝑦, 𝜙 variables as
where each 𝑧ℎ is a (new) binary variable. Deﬁne 𝜖 = 2𝛾
=
is the
architecture Lipschitz constant deﬁned in (2), and consider the following approximation of
𝑆

·
+
𝐷, Φ, ℓ, 𝑓
Í

𝐷, Φ, ℓ, 𝑓

, where

−
L (

L

L

2

1

𝐿𝛾
ℎ=1 2−
)

:

(
𝑆 𝜖

)

𝐷, Φ, ℓ, 𝑓

(

(cid:17)

)

(cid:8)

𝑥1, . . . , 𝑥 𝐷, 𝑦1, . . . , 𝑦𝐷, 𝜙, 𝐿
(
𝐿𝑑 = ℓ

, 𝑦𝑑

, 𝑑

)
𝐷

𝑓

0, 1

}

∈ {

: 𝑧

,

𝑁𝛾

𝑁

(

+

𝐷𝑛

+

𝐷𝑚

) , 𝜙

Φ,

∈

(

𝑥 𝑑, 𝜙
𝑁𝛾

)

(

)

∈ [

]

𝜙𝑖 =

2

1

−

+

𝑦𝑑
𝑖

=

2

1

−

+

𝑥 𝑑
𝑖

=

2

1

−

+

Õℎ=1
𝑁𝛾

Õℎ=1
𝑁𝛾

Õℎ=1

2−

ℎ𝑧 𝜙

𝑖,ℎ, 𝑖

𝑁

,

]

∈ [

2−

ℎ𝑧𝑦𝑑

𝑖,ℎ, 𝑑

, 𝑖

𝐷

]

𝑚

,

]

∈ [

∈ [

2−

ℎ𝑧𝑥𝑑

𝑖,ℎ, 𝑑

, 𝑖

𝐷

]

𝑛

]

∈ [

∈ [

.

Note that substituting out the 𝑥, 𝑦, 𝜙 using the equations of 𝑆 𝜖
sible region as BO. We can readily describe the error of the approximation of 𝑆
by 𝑆 𝜖

in the ERM problem (1) induced by the discretization:

𝐷, Φ, ℓ, 𝑓

)

(

, we obtain a fea-

𝐷, Φ, ℓ, 𝑓

(

)

(cid:9)
𝐷, Φ, ℓ, 𝑓

(

)

Lemma 3.1. Consider any
ists
𝜖.

ˆ𝑥1, . . . , ˆ𝑥 𝐷, ˆ𝑦1, . . . , ˆ𝑦𝐷, ˆ𝜙, ˆ𝐿

(

(

𝑥1, . . . , 𝑥 𝐷, 𝑦1, . . . , 𝑦𝐷, 𝜙, 𝐿

𝑆 𝜖

(

) ∈

𝐷, Φ, ℓ, 𝑓

)

) ∈
such that

𝑆

𝐷, Φ, ℓ, 𝑓
𝐷
𝑑=1 𝐿𝑑

(
1
𝐷

. Then, there ex-
𝐷
𝑑=1

ˆ𝐿𝑑

1
𝐷

)
−

≤

(cid:12)
(cid:12)

Í

Í

(cid:12)
(cid:12)

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

9

𝑥1, 𝑦1

𝜙1

𝑥2, 𝑦2

𝜙𝑁

𝜙2

𝑥𝐷, 𝑦𝐷

𝜙4

𝜙3

𝑥3, 𝑦3

(a) Intersection Graph of 𝑆 𝜖

𝐷, Φ, ℓ, 𝑓

(

)

𝜙
𝑥1, 𝑦1

𝜙
𝑥2, 𝑦2

𝜙
𝑥𝐷, 𝑦𝐷

· · ·

(b) Valid Tree-Decomposition

Figure 2. Intersection Graph and Tree-Decomposition of 𝑆 𝜖

𝐷, Φ, ℓ, 𝑓

(

)

Proof. Choose binary values ˜𝑧 so as to attain the approximation for variables 𝑥, 𝑦, 𝜙 as in
(7) and deﬁne ˆ𝑥, ˆ𝑦, ˆ𝜙, ˆ𝐿 from ˜𝑧 according to the deﬁnition of 𝑆 𝜖

𝐷, Φ, ℓ, 𝑓

. Since

𝜖

2𝛾 =

(

𝑑

𝐷

)

𝑥 𝑑, 𝑦𝑑, 𝜙

ˆ𝑥 𝑑, ˆ𝑦𝑑, ˆ𝜙
)

|

(

]

−

(cid:3)

(cid:13)
(cid:13)

L

𝐿𝑑

| ≤

) − (
ˆ𝐿𝑑

by Lipschitzness we obtain

∈ [
𝜖. The result then follows.

∞ ≤
(cid:13)
(cid:13)
3.2. Linear reformulation of the binary approximation. So far, we have phrased the
ERM problem (1) as a BO problem using a discretization of the continuous variables. This
in and of itself is neither insightful nor useful. In this section we will perform the key step,
reformulating the convex hull of 𝑆 𝜖

as a moderate-sized polytope.
)
𝐷, Φ, ℓ, 𝑓
using the 𝑧 variables, we can see
(
that the intersection graph of 𝑆 𝜖
𝑥, 𝑦, 𝜙
is given by Figure 2a, where we use
)
)
as stand-ins for corresponding the binary variables 𝑧𝑥, 𝑧𝑦, 𝑧 𝜙. Recall that the intersection
graph does not include the 𝐿 variables. It is not hard to see that a valid tree-decomposition
for this graph is given by Figure 2b. This tree-decomposition has size 𝐷 and width
𝑁
𝑚
𝑛
𝑁𝛾
variables). This yields our main
(
theorem:

𝐷, Φ, ℓ, 𝑓
variables in 𝑆 𝜖
𝐷, Φ, ℓ, 𝑓

1 (much less than the 𝑁𝛾

After replacing the

𝑥, 𝑦, 𝜙

𝐷𝑚

𝐷𝑛

) −

𝑁

+

+

+

+

(

)

)

(

)

(

(

(

Main Theorem 3.1. Let 𝐷
projection of a polytope with the following properties:
(a) The polytope has no more than 4𝐷

∈

2

𝑚

𝑛

+

+

ℕ be a given sample size. Then conv

𝑁 variables and 2𝐷

𝑆 𝜖

(

𝐷, Φ, ℓ, 𝑓

is the

))

2

2

𝜖
L/

)

(

𝑛

+

𝑚

+

𝑁

+

(

(

𝜖
L/

)

(

1

)

constraints. We refer to the resulting polytope as 𝑃𝑆𝜖 .
𝑚
𝑛
+

2

for 𝑂

(b) The polytope 𝑃𝑆𝜖 can be constructed in time 𝑂
𝑚
𝑁
evaluations of ℓ and 𝑓 .
+
)
ˆ𝑋, ˆ𝑌
=
𝐷
𝑖=1,

+
((
(c) For any sample
such that

𝜖
L/

ˆ𝑥𝑖, ˆ𝑦𝑖

ˆ𝑥𝑖, ˆ𝑦𝑖

2

(

)

(

)

(

)

𝑛

𝜖
L/

)

) ∈ [−

((

+

𝑁 𝐷

)

plus the time required

𝑛

+

𝑚, there is a face

1, 1

]

ˆ𝑋 , ˆ𝑌 of 𝑃𝑆𝜖

F

˜𝜙

∈

argmin

𝑓

ℓ

1
𝐷

𝐷
𝑖=1

n
𝑁 is an
, ˆ𝑦𝑖
ˆ𝑥𝑖, 𝜙∗)
1, 1
satisﬁes
optimal solution to the ERM problem (1) with input data
. This means that
(cid:12)
(cid:12)
solving an LP using an appropriate face of 𝑃𝑆𝜖 solves the ERM problem (1) within an
additive error 2𝜖.

, ˆ𝑦𝑖

(cid:1)(cid:12)
(cid:12)

Í

≤

ℓ

)

]

(

(

(

(

(cid:0)

𝑓

𝜙, 𝐿

) ∈

(
(cid:12)
(cid:12)
ˆ𝑥𝑖, ˜𝜙
(cid:12)
)

ˆ𝑋 , ˆ𝑌 )

proj
𝜙,𝐿 (F
o
2𝜖, where 𝜙∗ ∈ [−
ˆ𝑋, ˆ𝑌
)

(

𝐷

𝐿𝑖

1
𝐷

Õ𝑖=1
) −

(d) The face

ˆ𝑋 , ˆ𝑌 arises by simply substituting-in actual data for the data-variables 𝑥, 𝑦,
which determine the approximations 𝑧𝑥, 𝑧𝑦 and is used to ﬁxed variables in the descrip-
tion of 𝑃𝑆𝜖 .

F

Proof. Part (a) follows directly from Theorem 2.8 using 𝑁𝛾 =
tree-decomposition of Figure 2b, which implies

log

along with the
)⌉
𝑝 = 2𝐷 in this case. A proof of

𝜖
L/

𝑉

2

⌈

(

𝑇 ′)| +

(

|

10

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

parts (c) and (d) is given in the next subsection. For part (b) we analyze the construction
steps of the linear program deﬁned in proof of Theorem 2.8.

From the tree-decomposition detailed in Section 3.2, we see that data-dependent vari-
. Let us index the bags
𝑑 we construct in the
. Using this observation, we can

ables 𝑥, 𝑦, 𝐿 are partitioned in diﬀerent bags for each data 𝑑
𝐷
]
using 𝑑. Since all data variables have the same domain, the sets
proof of Theorem 2.8 will be the same for all 𝑑
construct the polytope as follows:

∈ [

∈ [

𝐷

F

]

(1) Fix, say, 𝑑 = 1 and enumerate all binary vectors corresponding to the discretization

of 𝑥1, 𝑦1, 𝜙.
(2) Compute ℓ

(
𝑓 and ℓ. This deﬁnes the set

(

)

)

𝑓

𝑥1, 𝜙

, 𝑦1

. This will take 𝑂

2

𝜖
L/

)

((

𝑛

+

𝑚

+

𝑁

)

function evaluations of

(3) Duplicate this set 𝐷 times, and associate each copy with a bag indexed by 𝑑
(4) For each 𝑑
(5) For each 𝑑

𝐷
𝐷
bags 𝑑 and 𝑑
1. This will create 𝑂
in the intersections are the discretized 𝜙 variables.

, create variables 𝑋
2

corresponding to the intersection of
variables, since the only variables

, and each 𝑣
1

𝑑 create a variable 𝜆𝑣.

𝑌 , 𝑁
]
[
𝑁
𝜖
L/

∈ [
∈ [
+

𝐷

.

]

∈ [

∈ F

]
−

((

]

)

)

1.

F

(6) Formulate LBO.

The only evaluations of ℓ and 𝑓 are performed in the construction of
1. As for the
additional computations, the bottleneck lies in creating all 𝜆 variables, which takes time
𝑂

𝑁 𝐷

F

𝑚

𝑛

2

.

𝜖
L/

)

((

+

+

)

(cid:3)

𝑛

2

Remark 3.2. Note that in step 1 of the polytope construction we are enumerating all possible
𝑚 are
discretized values of 𝑥1, 𝑦1, i.e., we are implicitly assuming all points in
𝑚 term in the polytope size estimation. If
possible inputs. This is reﬂected in the
𝜖
)
L/
one were to use another discretization method (or a diﬀerent “point generation” technique)
using more information about the input data, this term could be improved and the explicit
exponential dependency on the input dimension of the polytope size could be alleviated
signiﬁcantly. However, note that in a fully-connected neural network we have 𝑁
𝑚
and thus an implicit exponential dependency on the input dimension could remain unless
more structure is assumed. This is in line with the NP-hardness results. We leave the full
development of this potential improvement for future work.

1, 1

[−

≥

+

𝑛

(

]

𝑛

+

+

Note that the number of evaluations of ℓ and 𝑓 is independent of 𝐷. We would like to
further point out that we can provide an interesting reﬁnement of this theorem: if Φ has an
inherent network structure (as in the Neural Networks case) one can exploit treewidth-based
sparsity of the network itself. This would reduce the exponent in the polytope size to an
expression that depends on the sparsity of the network, instead of its size. We discuss this
in Section 5.

Remark 3.3. An additional important point arising from this new perspective on training
problems via linear programming comes from duality theory.
If one projects-out the
variables associated to the parameters 𝜙 in 𝑃𝑆𝜖 , the resulting projected polytope would
represent all possible samples of size 𝐷 and their achievable loss vector. This means that
there exists a dual certiﬁcate proving whether a loss vector, or average, is (approximately)
achievable by a sample, without using the 𝜙 variables.

3.3. Data-dependent faces of the data-independent polytope. We now proceed to show
how the ERM problem for a speciﬁc data set is encoded in a face of 𝑃𝑆𝜖 . This provides a
proof of points (c) and (d) in Theorem 3.1.

Additionally, for every 𝜙

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

11

)

(

=

)
(

=
(
ˆ𝑋, ˆ𝑌
)

Consider a ﬁxed data set

ˆ𝑋, ˆ𝑌
𝐷
ˆ𝑥𝑖, ˆ𝑦𝑖
𝑖=1 and let 𝜙∗ be an optimal solution to
. Since 𝑃𝑆𝜖 encodes “approximated” versions
the ERM problem with input data
of the possible samples, we begin by approximating
. Consider binary variables
𝑧 ˆ𝑥, 𝑧 ˆ𝑦 to attain the approximation (7) of the input data and deﬁne ˜𝑥, ˜𝑦 from 𝑧 ˆ𝑥, 𝑧 ˆ𝑦, i.e.,
˜𝑥 𝑑
𝑖

𝑁𝛾
ℎ=1 2−
ℝ𝐷 : 𝐿𝑑 = ℓ
𝑆
Í
)
(
and similarly as before deﬁne 𝑆 𝜖
to be its discretized version (on variables 𝜙).
)
The following Lemma shows the quality of approximation to the ERM problem obtained
˜𝑋, ˜𝑌 , Φ, ℓ, 𝑓
using 𝑆

𝑖,ℎ and similarly for ˜𝑦. Deﬁne
Φ
𝜙, 𝐿
{(
) ∈
˜𝑋, ˜𝑌, Φ, ℓ, 𝑓

(
and subsequently 𝑆 𝜖

˜𝑋, ˜𝑌, Φ, ℓ, 𝑓

˜𝑋, ˜𝑌, Φ, ℓ, 𝑓

˜𝑥 𝑑, 𝜙

ℎ𝑧 ˆ𝑥𝑑

ˆ𝑋, ˆ𝑌

, ˜𝑦𝑑

)}

×

−

=

+

1

2

(

(

)

(

)

𝑓

.

(

)
Lemma 3.4. For any
such that

𝜙, 𝐿

(

) ∈

𝑆

(

(

)

˜𝑋, ˜𝑌 , Φ, ℓ, 𝑓

there exists

𝜙′, 𝐿′) ∈

(

𝑆 𝜖

(

˜𝑋, ˜𝑌 , Φ, ℓ, 𝑓

)

)
𝐷

𝐿′𝑑

−

1
𝐷
Õ𝑑=1
𝜙′, 𝐿′) ∈
(
1
, ˆ𝑦𝑑
𝐷

) −

≤
(cid:12)
(cid:12)
(cid:12)
𝑆 𝜖
(cid:12)
(cid:12)
𝐷

(

Õ𝑑=1

𝐷

𝐿𝑑

1
𝐷

Õ𝑑=1
Φ, there exists

ˆ𝑥 𝑑, 𝜙

𝑓

ℓ

(

(

)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

𝐷

Õ𝑑=1

∈
1
𝐷

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

𝐿′𝑑

𝜖.

≤

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

𝜖.

˜𝑋, ˜𝑌, Φ, ℓ, 𝑓

such that

)

Proof. The ﬁrst inequality follows from the same proof as in Lemma 3.1. For the second
, ˜𝑦𝑑
inequality, let 𝜙′ be the binary approximation to 𝜙, and 𝐿′ deﬁned by 𝐿′𝑑
.
)
(cid:3)
Since ˜𝑥, ˜𝑦, 𝜙′ are approximations to ˆ𝑥, ˆ𝑦, 𝜙, the result follows from Lipschitzness.

˜𝑥 𝑑, 𝜙′)

= ℓ

(

(

𝑓

Lemma 3.5.

satisﬁes

ˆ𝜙, ˆ𝐿

(

) ∈

argmin

1
𝐷

(

𝐷

Õ𝑑=1

𝐿𝑑 :

𝜙, 𝐿

(

) ∈

𝑆 𝜖

(

˜𝑋, ˜𝑌 , Φ, ℓ, 𝑓

))

𝐷

1
𝐷

𝐷

ℓ

1
𝐷

ℓ

𝑓

(

(

ˆ𝑥 𝑑, 𝜙∗

, ˆ𝑦𝑑

)

) −

𝑓

ˆ𝑥 𝑑, ˆ𝜙
)

(

(

, ˆ𝑦𝑑

2𝜖.

≤

(cid:12)
(cid:12)
(cid:12)
Proof. Since ˆ𝜙
(cid:12)
(cid:12)
∈
𝐷
ately have 1
𝑑=1 ℓ
𝐷
) ≤
previous Lemma we know there exists

Õ𝑑=1
Φ, and 𝜙∗ is an optimal solution to the ERM problem, we immedi-
ˆ𝑥 𝑑, ˆ𝜙
, ˆ𝑦𝑑
. On the other hand, by the
)
˜𝑋, ˜𝑌 , Φ, ℓ, 𝑓
𝐷

ˆ𝑥 𝑑, 𝜙∗)

such that

𝑓
(
𝑆 𝜖

Õ𝑑=1

, ˆ𝑦𝑑

Í
𝐷

1
𝐷

𝐷

𝐷

(

(

(

(

)

𝑓

)(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

)
ˆ𝑥 𝑑, 𝜙∗

, ˆ𝑦𝑑

)

) −

1
𝐷

ˆ𝐿𝑑

Õ𝑑=1

(8)

𝜖

−

≤

=

≤

(9)

1
𝐷

1
𝐷

1
𝐷

Õ𝑑=1
𝐷

Õ𝑑=1
𝐷

Õ𝑑=1

ˆ𝑥 𝑑, 𝜙∗

𝑓

ℓ

(

(

ˆ𝑥 𝑑, 𝜙∗

𝑓

ℓ

(

(

ˆ𝑥 𝑑, 𝜙∗

𝑓

ℓ

(

(

)

)

)

, ˆ𝑦𝑑

) −

1
𝐷

, ˆ𝑦𝑑

) −

, ˆ𝑦𝑑

) −

1
𝐷

1
𝐷

𝐷
𝑑=1 ℓ
(
𝜙′, 𝐿′) ∈
Í
𝐿′𝑑 ≤

1
𝐷

Õ𝑑=1
𝐷

˜𝑥 𝑑, ˆ𝜙
)

𝑓

ℓ

(

(

Õ𝑑=1
𝐷

ℓ

Õ𝑑=1
, ˜𝑦𝑑

𝑓

(

(

)

𝑓

ℓ

(

ˆ𝑥 𝑑, ˆ𝜙
)

(

, ˆ𝑦𝑑

) +

𝜖.

The rightmost inequality in (8) follows from the optimality of ˆ𝐿 and (9) follows from
(cid:3)
Lipschitzness.

Note that since the objective is linear, the optimization problem in the previous Lemma
by its convex hull. Therefore the only missing

˜𝑋, ˜𝑌 , Φ, ℓ, 𝑓

is equivalent if we replace 𝑆 𝜖
link is the following result.

(

Õ𝑑=1

)

12

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

Lemma 3.6. conv

˜𝑋, ˜𝑌, Φ, ℓ, 𝑓

𝑆 𝜖

(

(

))

is the projection of a face of 𝑃𝑆𝜖

𝑆 𝜖

Proof. The proof follows from simply ﬁxing variables in the corresponding LBO that de-
scribes conv
𝑑, we simply need to make
))
components of 𝑣 do not correspond to ˜𝑋, ˜𝑌 . We know this is well
𝜆𝑣 = 0 whenever the
deﬁned, since ˜𝑋, ˜𝑌 are already discretized, thus there must be some 𝑣
𝑑 corresponding
to them.

𝐷, Φ, ℓ, 𝑓
𝑥, 𝑦

. For every 𝑑

and 𝑣

∈ F

∈ F

∈ [

𝐷

)

(

(

(

]

The structure of the resulting polytope is the same as LBO, so the fact that it is exactly
follows
(cid:3)

conv
from the fact that the procedure simply ﬁxed some inequalities to be tight.

follows. The fact that it is a face of conv

˜𝑋, ˜𝑌 , Φ, ℓ, 𝑓

𝐷, Φ, ℓ, 𝑓

𝑆 𝜖

𝑆 𝜖

))

))

(

(

(

(

1, 1

3.4. Data-dependent polytope? Before moving to the next section, we would like to dis-
cuss the importance of the data-independent feature of our construction. Constructing
a polytope for a speciﬁc data set is trivial: similarly to what we described in the previ-
ous sections, with the input data ﬁxed we can simply enumerate over a discretization of
Φ
𝑁 , and thus compute the (approximately) optimal solution in advance. A
data-dependent polytope would simply be a single vector, corresponding to the approxi-
mately optimal solution computed in the enumeration. The time needed to generate such
polytope is 𝑂
𝜖
2
(the number of possible discretized conﬁgurations) via at most
((
L/
𝑁 𝐷
𝑂
evaluations of ℓ and 𝑓 (one per each enumerated conﬁguration and data-
)
((
point).

𝜖
L/

⊆ [−

2

𝑁

)

)

]

)

This result is not particularly insightful, as it is based on a straight-forward enumeration
which takes a signiﬁcant amount of time, considering that it only serves one data set. On the
other hand, our result shows that by including the input data as a variable, we do not induce
an exponential term in the size of the data set 𝐷 and we can keep the number function
evaluations to be roughly the same.

4. Encoding results for feed-forward neural networks

We now proceed to deriving explicit results for speciﬁc architectures. This amounts to

using Theorem 3.1 with explicit computations of the architecture Lipchitz constant

.

L

◦

◦

𝜎

𝑇2

4.1. Fully-connected layers with ReLU activations and normalized coeﬃcients. We
consider a Deep Neural Network 𝑓

: ℝ𝑛
𝑇1, where 𝜎 is the ReLU activation function 𝜎

ℝ𝑚 with 𝑘 layers given by 𝑓 = 𝑇𝑘
𝜎
◦
→
𝑥
applied
· · · ◦
)
(
component-wise and each 𝑇𝑖 : ℝ𝑤𝑖
ℝ𝑤𝑖 is an aﬃne linear function. Here 𝑤0 = 𝑛
(𝑤 𝑘 = 𝑚) is the input (output) dimension of the network. We write 𝑇𝑖
𝑏𝑖 and
)
1 via normalization. Thus, if 𝑣 is a node in layer 𝑖, the
assume
k∞ ≤
ˆ𝑏, where ˆ𝑎 is a row of 𝐴𝑖 and ˆ𝑏
node computation performed in 𝑣 is of the form ˆ𝑎𝑇 𝑧
is a component of 𝑏𝑖. Note that in this case the parameter space dimension is exactly the
number of edges of the network. Hence, we use 𝑁 to represent the number of edges. We
begin with a short technical Lemma, with which we can immediately establish the following
corollary.

{
}
= 𝐴𝑖 𝑧

(cid:17) max

k∞ ≤

0, 𝑥

→

𝐴𝑖

𝑏𝑖

1,

1
−

+

+

◦

k

k

𝑧

(

Lemma 4.1. For every 𝑖
𝑈𝑖

1.
+

𝑘

1

]

−

∈ [

0 deﬁne 𝑈𝑖 =

𝑖
𝑗=0 𝑤 𝑗 . If

𝑧

k

k∞ ≤

𝑈𝑖 then

𝑇𝑖

k

1
+

(

𝑧

) k∞ ≤

Í

Proof. The result can be veriﬁed directly, since for 𝑎
𝑧𝑇 𝑎

𝑤

1.

𝑏

𝑧

|

+

| ≤

k

k∞ +

1, 1

]

∈ [−

𝑤 and 𝑏

∈ [−

1, 1

it holds
(cid:3)

]

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

13

Corollary 4.2. If Φ is the class of Neural Networks with 𝑘 layers, 𝑁 edges, ReLU activations,
can be formulated via a polytope of
and normalized coeﬃcients, then conv
𝑤𝑂
ℓ
size 𝑂
is the Lipschitz
ℓ
)
L∞(
((
𝑚. The polytope can be constructed in time
constant of ℓ
,
·)
(·
𝑘2
𝑤𝑂
𝑂
ℓ
(
)
)
evaluations of ℓ and 𝑓 .

𝜖
) /
(
+
)
𝑈𝑘 , 𝑈𝑘
over
[−
𝑁 𝐷
𝑚
𝑛
𝜖
+
) /

𝐷, Φ, ℓ, 𝑓
))
, where 𝑤 = max𝑖
∈[

]
plus the time required for 𝑂

0 𝑤𝑖 and

𝑁 𝐷
)
𝑚

𝜖
) /

× [−

L∞(

L∞(

L∞(

𝑤𝑂

1, 1

𝑆 𝜖

((

((

𝑘2

𝑘2

2

2

2

𝑚

𝑚

ℓ

𝑁

−

(

(

)

)

]

)

)

)

𝑛

𝑛

+

+

+

+

1

𝑘

(

]

𝑧, 𝑎, 𝑏

= 𝑧𝑇 𝑎

Proof. Proving that the architecture Lipschitz constant is 𝐿
) suﬃces. All node
computations take the form ℎ
; the only
+
diﬀerence is made in the domain of 𝑧, which varies from layer to layer. The 1-norm of the
gradient of ℎ is at most
1 which, in virtue of Lemma 4.1, implies
1
+
that a node computation on layer 𝑖 (with the weights considered variables) has Lipschitz
𝛾
constant at most
𝑈𝑖, 𝑈𝑖
and 𝑧

k
k
𝑗=0 2𝑤 𝑗 = 2 𝑤 𝑖
, it holds that

=: ˜𝑤𝑖. On the other hand, for

𝑎′, 𝑏′) k∞ ≤

∞ (
1, 1
]

𝑏 for 𝑎

∈ [−

∈ [−

) − (

𝑎, 𝑏

1, 1

≤ k

+ k

+
𝑤

k(

𝑤

+

+

𝑎

1

−
1

k

k

𝑧

𝑧

−

)

(

]

1

1

1

𝑖

1

𝑘2
𝑤𝑂
ℓ
(
)
𝑤 and 𝑏

∈ [−

]
Í
ℎ

|

𝑧, 𝑎, 𝑏

ℎ

(

) −

(

𝑧′, 𝑎′, 𝑏′

)| ≤

˜𝑤𝑖
𝑧
−
k(
˜𝑤𝑖 max

𝑧

𝑧′, 𝑎

𝑎′, 𝑏

−
𝑧′

, 𝛾

≤

{k

−

k∞

}

𝑏′

−

) k∞

which shows that the Lipschitz constants can be multiplied layer-by-layer to obtain the
overall architecture Lipschitz constant. Since ReLUs have Lipschitz constant equal to 1,
𝑘
𝑖=1 ˜𝑤𝑖 =
and
2, we conclude the architecture
(cid:3)
Lipschitz constant is 𝐿
(cid:0)

) , whenever 𝑤

= 𝑤𝑂
𝑘2
) .

2 𝑤 𝑖
+
𝑤
ℓ

𝑘
𝑖=1

≥

𝑘2

1

(

(

1

Î

Î

−
1
−
𝑤𝑂
(cid:1)
)

∞ (

To evaluate the quality of the polytope size in the previous lemma, we compare with the

following related algorithmic result.

Theorem 4.3. [4, Theorem 4.1] Let Φ be the class of Neural Networks with 1 hid-
den layer (𝑘 = 2), convex loss function ℓ, ReLU activations and output dimension
𝑚 = 1. There exists an algorithm to ﬁnd a global optimum of the ERM problem in
time 𝑂

2𝑤 𝐷 𝑛𝑤 poly

𝐷, 𝑛, 𝑤

.

(

(

))

In the same setting, our result provides a polytope of size

(10)

𝑂

2

((

L∞(

ℓ

)

𝑤𝑂

1
)

(

𝜖
/

)

𝑛

1
) (
+

(

𝑤

1
) 𝐷
+

)

Remark 4.4. We point out a few key diﬀerences of these two results: (a) One advantage
of our result is the benign dependency on 𝐷. Solving the training problem using an LP
with our polyhedral encoding has polynomial dependency on the data-size regardless of the
architecture. Moreover, our approach is able to construct a polytope that would work for
any sample. (b) The exponent in (10) is
𝑛𝑤, which is also present in Theorem 4.3. The
key diﬀerence is that we are able to swap the base of that exponential term for an expression
that does not depend on 𝐷. (c) We are able to handle any output dimension 𝑚 and any
number of layers 𝑘. (d) We do not assume convexity of the loss function ℓ, which causes
the resulting polytope size to depend on how well behaved ℓ is in terms of its Lipschitzness.
(e) The result of [4] has two advantages over our result: there is no boundedness assumption
on the coeﬃcients, and they are able to provide a globally optimal solution.

∼

4.2. ResNets, CNNs, and alternative activations. Corollary 4.2 can be generalized to
handle other architectures as well, as the key features we used before are the acyclic
structure of the network and the Lipschitz constant of the ReLU function.

Lemma 4.5. Let Φ be the class of feed-forward neural networks with 𝑘 layers, 𝑁 edges,
aﬃne node computations, 1-Lipschitz activation functions 𝑎𝑖 : ℝ
= 0,

ℝ such that 𝑎𝑖

0

→

(

)

14

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

2

and normalized coeﬃcients. Then conv
tope of size 𝑂
and
tope can be constructed in time 𝑂
𝑘2
𝑂

𝑆 𝜖
can be formulated via a poly-
(
(
𝑁 𝐷
Δ𝑂
, where Δ is the maximum vertex in-degree
(
)
𝑚. The poly-
over
,
is the Lipschitz constant of ℓ
[−
(·
·)
𝑘2
𝑛
Δ𝑂
plus the time required for
𝜖
ℓ
+
) /
)
)
evaluations of ℓ and 𝑓 .

𝑈𝑘, 𝑈𝑘
𝑁 𝐷
𝑚

𝐷, Φ, ℓ, 𝑓

𝜖
) /

× [−

L∞(

L∞(

L∞(

1, 1

Δ𝑂

]
)

((

((

))

𝑘2

2

𝑚

𝑚

𝑚

ℓ

ℓ

ℓ

𝑁

]

)

)

)

𝑛

𝑛

+

+

+

(

2

((

L∞(

)

(

𝜖
) /

)

+

+

)

Proof. The proof follows almost directly from the proof of Corollary 4.2. The two main
diﬀerences are (1) the input dimension of a node computation, which can be at most Δ
instead of 𝑤 and (2) the fact that an activation function 𝑎 with Lipchitz constant 1 and
that 𝑎
, thus the domain of each node computation computed
in Lemma 4.1 applies. The layer-by-layer argument can be applied as the network is
(cid:3)
feed-forward.

= 0 satisﬁes

)| ≤ |

0

𝑎

𝑧

𝑧

)

(

(

|

|

Corollary 4.6. The ERM problem (1) over Deep Residual Networks (ResNets) with 1-
whenever the
Lipschitz activations can be solved to 𝜖-optimality in time poly
network size and number of layers are ﬁxed.

𝜖, 𝐷
/

Δ, 1

)

(

Another interesting point can be made with respect to Convolutional Neural Networks
(CNN). In these, convolutional layers are included to signiﬁcantly reduce the number of
parameters involved. From a theoretical perspective, a CNN can be obtained by enforcing
certain parameters of a fully-connected DNN to be equal. This implies that Lemma 4.5
can also be applied to CNNs, with the key diﬀerence residing in parameter 𝑁, which is
the dimension of the parameter space and does not correspond to the number of edges in a
CNN.

4.3. Explicit Lipschitz constants of common loss functions. In the previous section
we speciﬁed our results —the size of the data-independent polytope— for feed-forward
ℓ
;
networks with 1-Lipschitz activation functions. However, we kept as a parameter
)
𝑘
𝑗=0 𝑤 𝑗 a valid
the Lipschitz constant of ℓ
bound on the output of the node computations, as proved in Lemma 4.1. Note that
𝑈𝑘

≤
In this section we compute this Lipschitz constant for various common loss functions. It
is important to mention that we are interested in the Lipschitznes of ℓ with respect to both
the output layer and the data-dependent variables as well —not a usual consideration in the
literature. These computations lead to the results reported in Table 1.

𝑚, with 𝑈𝑘 =

𝑈𝑘, 𝑈𝑘

× [−

L∞(

over

1, 1

1.
+

𝑤 𝑘

[−

Í

(·

·)

𝑚

]

]

,

Recall that a bound on the Lipschitz constant

ℓ

is given by sup𝑧,𝑦 k∇
2
2. In this case it is easy to see that

L∞(

)

𝑧, 𝑦

ℓ

(

) k

1.

Quadratic Loss ℓ

(

ℓ

𝑧, 𝑦

𝑧, 𝑦

=

𝑧

k
𝑧

)
1 = 4
k
=

𝑦

k

1

−
𝑦

4𝑚

𝑈𝑘

1

4𝑚

𝑤 𝑘

1
+

1

(

k∇

) k
𝑧, 𝑦

k
𝑦
Absolute Loss ℓ
k
Lipschitz constant with respect to the inﬁnity norm is at most 2𝑚.
Cross Entropy Loss with Soft-max Layer. In this case we include the Soft-max
computation in the deﬁnition of ℓ, therefore

In this case we can directly verify that the

≤
1.

) ≤

−
𝑧

−

+

+

k

(

(

(

)

)

•

•

•

where 𝑆

𝑧

)

(

is the Soft-max function deﬁned as

=

𝑧, 𝑦

ℓ

(

)

−

𝑦𝑖 log

𝑆

𝑧

(

𝑖

)

)

(

𝑚

Õ𝑖=1

𝑖 =

𝑆

𝑧

)

(

𝑒𝑧𝑖
𝑚
𝑗=1 𝑒𝑧 𝑗

.

Í

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

15

A folklore result is
𝜕ℓ

𝑧, 𝑦
(
𝜕𝑧𝑖

Additionally,

= 𝑆

)

𝑧

𝑖

)

(

−

𝑦𝑖

⇒

𝜕ℓ

𝑧, 𝑦
(
𝜕𝑧𝑖

(cid:12)
(cid:12)
(cid:12)
(cid:12)
𝑆

2.

≤

)

(cid:12)
(cid:12)
(cid:12)
(cid:12)

𝜕ℓ

𝑧, 𝑦

(
𝜕 𝑦𝑖

=

)

log

𝑧

𝑖

(
which in principle cannot be bounded. Nonetheless, since we are interested in the
domain

of 𝑧, we obtain

−

𝑈𝑘, 𝑈𝑘

)

)

(

[−

]

𝑖 =

𝑆

𝑧

)

(

𝑒𝑧𝑖
𝑚
𝑗=1 𝑒𝑧 𝑗 ≥

1
𝑚

2𝑈𝑘

𝑒−

⇒

𝜕ℓ

𝑧, 𝑦

=

)

(
𝜕 𝑦𝑖
(cid:12)
(cid:12)
ℓ
(cid:12)
) ≤
(cid:12)
= max
{

Í
−
2𝑚
1

log

𝑆

𝑧

(
(
𝑚
log
(
𝑧𝑇 𝑥, 0

(cid:12)
(cid:12)
𝑚
which implies that
(cid:12)
) +
(cid:12)
Hinge Loss ℓ
𝑧, 𝑦
. Using a similar argument as for the
}
Quadratic Loss, one can easily see that the Lipschitz constant with respect to the
𝑤 𝑘
inﬁnity norm is at most 𝑚

L∞(
)

2𝑤 𝑘

2𝑈𝑘

(
−

) ≤

log

) +

1
+

𝑚

1

1

)

(

(

(

.

.

𝑈𝑘

1
+

•

𝑖

)

) ≤

log

𝑚

(

2𝑈𝑘

) +
2𝑚

(

) ≤
5. ERM under Network Structure

+

+

)

(

So far we have considered general ERM problems exploiting only the structure of the
ERM induced by the ﬁnite sum formulations. We will now study ERM under Network
Structure, i.e., speciﬁcally ERM problems as they arise in the context of Neural Network
training. We will see that in the case of Neural Networks, we can exploit the sparsity of the
network itself to obtain better polyhedral formulations of conv

𝐷, Φ, ℓ, 𝑓

𝑆 𝜖

.

Suppose the network is deﬁned by a graph

( G).
G
By using additional auxiliary variables 𝑠 representing the node computations and activations,
we can describe 𝑆

, and recall that in this case, Φ

1, 1

]

𝐸

))
⊆ [−

(

(

𝐷, Φ, ℓ, 𝑓
)
=

𝐷, Φ, ℓ, 𝑓

(

in the following way:
𝑥1, . . . , 𝑥 𝐷, 𝑦1, . . . , 𝑦𝐷, 𝜙, 𝐿

𝑆

(

)

:

)

(
𝐿𝑑 = ℓ
(cid:8)
(
𝑠𝑖,𝑑
𝑣 = 𝑎 𝑣
𝑠0,𝑑 = 𝑥 𝑑
𝑥𝑖

𝑠𝑘,𝑑, 𝑦𝑑
𝑠𝑖

𝑔𝑣

)
−

(

(

1, 1

𝑛, 𝑦𝑖

1,𝑑 , 𝜙

𝛿+

𝑣

𝑣
))) ∀

(

(

∈

𝑉𝑖, 𝑖

𝑘

]

∈ [

∈ [−
The only diﬀerence with our original description of 𝑆
in (6) is that we explicitly
(cid:9)
“store” node computations in variables 𝑠. These new variables will allow us to better use
the structure of

∈ [−

]

)

(

.

Φ

.

1, 1

𝑚, 𝜙
]
∈
𝐷, Φ, ℓ, 𝑓

G

Assumption 5.1. To apply our approach in this context we need to further assume Φ to be
the class of Neural Networks with normalized coeﬃcients and bounded node computations.
This means that we restrict to the case when 𝑠

𝐷.

1, 1

𝑉

∈ [−

( G) |

] |

Under Assumption 5.1 we can easily derive an analog description of 𝑆 𝜖

𝐷, Φ, ℓ, 𝑓
)
using this node-based representation of 𝑆 𝜖
. In such description we also include
a binary representation of the auxiliary variables 𝑠. Let Γ be the intersection graph of
and Γ𝜙 be the sub-graph of Γ induced by variables 𝜙.
such a formulation of 𝑆 𝜖
)
of Γ𝜙 we can construct a tree-decomposition of Γ the
Using a tree-decomposition
following way:

𝐷, Φ, ℓ, 𝑓
𝑇, 𝑄

𝐷, Φ, ℓ, 𝑓

(

(

)

(

(

)

16

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

(1) We duplicate the decomposition 𝐷 times

𝑇 𝑖, 𝑄𝑖

(

)

𝐷
𝑖=1, where each

𝑇 𝑖, 𝑄𝑖

(

)

is a copy

(2) We connect the trees 𝑇 𝑖 in a way that the resulting graph is a tree (e.g., they can be

of

𝑇, 𝑄

.

(

)

simply concatenated one after the other).

(3) To each bag 𝑄𝑖

𝑇 𝑖 and 𝑖

𝑡 with 𝑡

∈ [
𝐿𝑑 and the binary variables associated with the discretization of 𝑥 𝑑, 𝑠·
This adds 𝑁𝛾
(G)| +
variable 𝑠 per data point per vertex of

, we add all the data-dependent variables
,𝑑, and 𝑦𝑑.
additional variables to each bag, as there is only one

𝑚

𝐷

𝑉

(|

+

∈

𝑛

)

]

.

It is not hard to see that this is a valid tree-decomposition of Γ, of size

𝐷 —since

the bags were duplicated 𝐷 times— and width 𝑁𝛾

𝑡𝑤

Γ𝜙

𝑉

𝑛

We now turn to providing a bound to 𝑡𝑤

(

(G)| +
. To this end we observe the following:

) + |

+

(

𝑇
|
𝑚

| ·
.
)

G

Γ𝜙

(

)

(1) The architecture variables 𝜙 are associated to edges of

. Moreover, two variables
𝐸 appear in a common constraint if and only if there is a vertex
∈
𝛿+(

G

𝑣

.
)
(2) This implies that Γ𝜙 is a sub-graph of the line graph of

∈

𝜙𝑒, 𝜙 𝑓 , with 𝑒, 𝑓
𝑣 such that 𝑒, 𝑓

G

. Recall that the line graph
and connecting two

of a graph
nodes whenever the respective edges share a common endpoint.

is obtained by creating a node for each edge of

G

G

The treewidth of a line graph is related to the treewidth of the base graph (see [9, 14, 5,
where Δ denotes the maximum vertex
Δ
, since Γ𝜙 has at most

23]). More speciﬁcally, 𝑡𝑤
(
degree. Additionally, using Lemma 2.5 we may assume
𝐸

nodes. Putting everything together we obtain:

(G))

(G)|

| ≤ |

(G)

Γ𝜙

) ∈

𝑡𝑤

𝑂

𝐸

𝑇

(

|

(G)|

|
Lemma 5.2. If there is an underlying network structure
𝐷, Φ, ℓ, 𝑓
node computations are bounded, then conv
with no more than

𝑆 𝜖

(

(

in the ERM problem and the
is the projection of a polytope

G
))

2𝐷

𝐸

(|

(G)| +

variables and no more than

𝑡 𝑤

𝑂

(

( G)

Δ

( G)+|

𝑉

( G) |+

𝑛

+

𝑚
)

2
L
𝜖

(cid:19)

1

)

(cid:18)

𝑡 𝑤

𝑂

(

( G)

Δ

( G)+|

𝑉

( G) |+

𝑛

+

𝑚
)

𝐷

𝐸

1

2

2
L
𝜖

(|

)  
constraints. Moreover, given a tree-decomposition of the network
constructed in time

(G)| +

(cid:19)

(cid:18)

𝑂

𝐷

(cid:16)
plus the time required for

𝐸

|

(G)| (

2

𝜖
L/

)

𝑡 𝑤

𝑂

(

( G)

Δ

( G)+|

𝑉

( G) |+

𝑛

+

𝑚
)

1

!

+

, the polytope can be

G

(cid:17)

𝑂

evaluations of ℓ and 𝑓 .

(G)| (

2

𝜖
L/

)

𝐸

|

(cid:16)

𝑡 𝑤

𝑂

(

( G)

Δ

( G)+|

𝑉

( G) |+

𝑛

+

𝑚
)

(cid:17)

6. Linear Programming-based Training Generalizes

In this section we show that the ERM solutions obtained via LP generalize to the General
Risk Minimization problem. Here we show generalization as customary in stochastic
optimization, exploiting the Lipschitzness of the model to be trained; we refer the interested
reader to [32] and [1] for an in-depth discussion.

Recall that the General Risk Minimization (GRM) is deﬁned as min𝜙

Φ 𝔼

min𝜙

∈

𝑥,𝑦

(

) ∈D [

𝑓

ℓ

(

(

𝑥, 𝜙

, 𝑦

)

)]

, where ℓ is some loss function,

𝑓

(cid:17)
Φ GRM
is a neural network

𝜙

)

(

∈

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

17

architecture with parameter space Φ, and
. We solve the ERM problem min𝜙

𝑚 drawn from the distribution
) ∈
𝐷
, 𝑦𝑖
𝑥𝑖, 𝜙
,
𝑖=1 ℓ
𝜙
)
)
(
)
(
D
𝐷
of size 𝐷.
instead, where
𝑖=1 is an i.i.d. sample from data distribution
We show in this section, for any 1 > 𝛼 > 0, 𝜖 > 0, we can choose a (reasonably small!)
sample size 𝐷, so that with probability 1

ℝ𝑛
+
(cid:17) min𝜙

(
Φ ERM𝑋 ,𝑌

𝛼 it holds:

𝑥𝑖, 𝑦𝑖

(
D

𝑋, 𝑌

𝑥, 𝑦

1
𝐷

Í

=

Φ

)

(

)

(

∈

∈

𝑓

GRM

¯𝜙

(

) ≤

GRM

𝜙

(

) +

6𝜖,

−
min
Φ
𝜙
∈

≤

Φ ERM𝑋 ,𝑌

max𝜙
∈
𝑋, 𝑌

where ¯𝜙
𝜖 is an 𝜖-approximate solution to ERM𝑋 ,𝑌 for i.i.d.-
. As the size of the polytope that we use for training only linearly
sampled data
depends on 𝐷, this also implies that we will have a linear program of reasonable size as a
function of 𝛼 and 𝜖.

) ∼ D

) +

𝜙

(

(

The following proposition summaries the generalization argument used in stochastic pro-
.

gramming as presented in [1] (see also [32]). Let 𝜎2 = max𝜙

Φ 𝕍

𝑥, 𝜙

, 𝑦

ℓ

𝑓

𝑥,𝑦

∈

(

) ∈D [

(

(

)

)]

Proposition 6.1. Consider the optimization problem

𝔼𝜔

min
𝑋
𝑥
∈

Ω

𝐹

𝑥, 𝛾

𝜔

,

[
is a random parameter with 𝜔
Ω

(
Ω a set of parameters, 𝑋
∈
ℝ is a function. Given i.i.d. samples 𝛾1, . . . , 𝛾𝐷 of 𝛾

))]

(

∈

𝜔
where 𝛾
(
and 𝐹 : 𝑋
→
ﬁnite sum problem

)
×

ℝ𝑛 a ﬁnite set,
, consider the

)

⊆
𝜔
(

1
𝐷

min
𝑋
𝑥
∈

𝐷
Õ𝑖
∈[

]

𝑥, 𝛾𝑖

𝐹

(

.

)

𝑋 is an 𝜖-approximate solution to (11), i.e., 1
𝐷

𝑖

𝐷

]

∈[

¯𝑥, 𝛾𝑖

𝐹

(

) ≤

min𝑥

1
𝐷

𝑋

∈

𝑖

𝐷

]

∈[

𝑥, 𝛾𝑖

𝐹

(

)+

(11)

If ¯𝑥
∈
𝜖 and

where 𝛼 > 0 and 𝜎2 = max𝑥

𝔼𝜔

Ω

∈

[

𝐹

(

𝑋 𝕍 𝜔

∈
¯𝑥, 𝛾

∈
𝜔

(

))] ≤

𝐷

Ω

≥

𝐹

[

4𝜎2
𝜖 2

𝑥, 𝛾

(
min
𝑋
𝑥
∈

Í
𝑋
|
𝛼

,

log |

𝜔
(
𝔼𝜔

))]
Ω

∈

, then with probability 1

𝑥, 𝛾

𝐹

[

(

𝜔

(

))] +

2𝜖.

Í

𝛼 it holds:

−

We now establish generalization by means of Proposition 6.1 and a straightforward
ℕ.
∈
Φ𝜈 with
the be architecture Lipschitz constant, as deﬁned in (2)

discretization argument. By assumption from above Φ
𝑁 be a 𝜈-net of Φ, i.e., for all 𝜙
Let Φ𝜈
¯𝜙
𝜙

1, 1
]
⊆ [−
𝜈. Furthermore let

]
Φ there exists ¯𝜙

𝑁 for some 𝑁

⊆ [−
∈

1, 1

Φ

∈

⊆
k∞ ≤

k
−
(or (15)).

L

Theorem 6.2. [Generalization] Let ¯𝜙
with 𝜖 > 0, i.e., ERM𝑋 ,𝑌
min𝜙

¯𝜙
) ≤

(

and 𝜎2 as above, then with probability 1
−
L
i.e., ¯𝜙 is a 6𝜖-approximate solution to min𝜙
∈

Φ be an 𝜖-approximate solution to min𝜙
∈
2
𝜖. If 𝐷
Φ ERM𝑋 ,𝑌
≥
¯𝜙
) ≤

𝜙
) +
𝛼 it holds GRM
Φ GRM

4𝜎2
𝜖 2
min𝜙

∈
L)/
𝛼
Φ GRM

log ( (

𝜙

(

(

∈

∈

.

𝑁

Φ ERM𝑋 ,𝑌
𝜖
, with
6𝜖,

𝜙

)

(

) +

𝜙

)

(

(
¯𝜙 be as above. With the choice 𝜈 (cid:17) 𝜖
𝜈 and hence by Lipschitzness,

)

Proof. Let
¯𝜙
˜𝜙

k

−

k∞ ≤

so that ERM𝑋 ,𝑌
probability 1

˜𝜙
) ≤

(

∈
𝛼 we have GRM

−

|
min𝜙

ERM𝑋 ,𝑌

¯𝜙
(
) −
Φ𝜈 ERM𝑋 ,𝑌
(
min𝜙

˜𝜙
) ≤

(

∈

ERM𝑋 ,𝑌

˜𝜙
)| ≤

(

𝜖,

𝜙
) +
Φ𝜈 GRM

2𝜖. As 𝐷
𝜙

log ( (

, with
4𝜖 by Proposition 6.1. If now

L)/
𝛼

≥

)

4𝜎2
𝜖 2

2

𝑁

𝜖

(

) +

, there exists ˜𝜙

Φ𝜈, so that

∈

/L

18

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

Φ𝜈 with

¯𝜙𝐺

k

−

˜𝜙𝐺

k∞ ≤

𝜈, by Lipschitzness we have

¯𝜙𝐺 = argmin𝜙
GRM

¯𝜙𝐺

𝜙
Φ GRM
(
∈
˜𝜙𝐺
GRM

and ˜𝜙𝐺

∈
𝜖. Now

|

(

) −

(
˜𝜙

GRM

(

) ≤

)
)| ≤
min
Φ𝜈
𝜙
∈
GRM

GRM

≤

GRM

𝜙

4𝜖

(

) +

) +
4𝜖

5𝜖

(

˜𝜙𝐺
¯𝜙𝐺

(by optimality)

(by Lipschitzness).

𝜈 it follows

Together with

|

GRM

≤
¯𝜙
) −
¯𝜙

(
GRM

(
GRM

) +
˜𝜙
)| ≤

(
GRM

(

) ≤

𝜖 as

˜𝜙

¯𝜙

¯𝜙𝐺

(

) +

k∞ ≤

k
−
6𝜖 = min
Φ
𝜙
∈

GRM

𝜙

(

) +

6𝜖,

which completes the proof.

(cid:3)

We are ready to formulate the following corollary combining Theorem 6.2 and Main

Theorem 3.1.

Corollary 6.3 (LP-based Training for General Risk Minimization). Let
be a data
distribution as above. Further, let 1 > 𝛼 > 0 and 𝜖 > 0, then there exists a linear
program with the following properties:

D

(a) The LP has size

𝑂

and can be constructed in time

2

𝜖
L/

)

(

𝑛

+

𝑚

+

𝑁

(cid:16)

4𝜎2
𝜖 2

(cid:18)

log (

𝑁

2

𝜖
L/
𝛼

)

(cid:19) (cid:17)

2

𝜖
L/

)

(

𝑛

+

𝑚

+

𝑁

𝑂

(cid:16)

4𝜎2
𝜖 2

(cid:18)
𝑛

𝑁

𝑚

+

+

2

log ((

𝑁

)

𝜖
L)/
𝛼

(cid:19) (cid:17)
evaluations of ℓ and 𝑓 , where

plus the time required for 𝑂
as above.

2

𝜖
L/

)

(

(b) With probability

1

(

−

𝛼

)

(cid:0)

it holds GRM

(cid:1)
¯𝜙
) ≤

(

min𝜙

Φ GRM

𝜙

∈

(

) +

optimal solution to the linear program obtained for the respective sample of
4𝜎2
𝜖 2

log ( (

L)/
𝛼

2

𝑁

.

𝜖

)

D

and 𝜎2

L
6𝜖, where ¯𝜙 is an
of size

Similar corollaries hold, combining Theorem 6.2 with the respective alternative state-
ments from Section 4. Of particular interest for what follows is the polytope size in the
case of a neural network with 𝑘 layers with width 𝑤, which becomes

(12)

𝑂

2

ℓ

)

L∞(

𝑘2

𝑤𝑂

(

)

𝜖
/

𝑛

+

𝑚

+

𝑁

4𝜎2

𝜖 2
/

log

2

((

L∞(

ℓ

)

𝑘2

𝑤𝑂

(

𝑁

)

𝜖
/

)

.

𝛼

)

/

(cid:0)(cid:0)

A closely related result regarding an approximation to the GRM problem for neural
networks is provided by [20] in the improper learning setting. The following corollary to
[20] (Corollary 4.5) can be directly obtained, rephrased to match our notation:

(cid:1)

(cid:1)

(cid:1)

(cid:0)

−

Theorem 6.4 ([20]). There exists an algorithm that outputs ˜𝜙 such that with probability
and loss function ℓ which is convex, 𝐿-Lipschitz in the ﬁrst
𝛼, for any distribution
1
D
𝜖, where Φ is
argument and 𝑏 bounded on
, GRM
min𝜙
the class of neural networks with 𝑘 hidden layers, width 𝑤, output dimension 𝑚 = 1, ReLU
activations and normalized weights. The algorithm runs in time at most

2√𝑤, √𝑤

Φ GRM

) ≤

) +

[−

˜𝜙

𝜙

(

]

(

∈

(13)

𝑛𝑂

1
) 2( (

(

𝐿

1
)
+

𝑤 𝑘

1
2 𝑘 𝜖 −
/

𝑘

)

log

𝛼

1

(

/

)

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

19

Remark 6.5. In contrast to the result of [20], we consider the proper learning setting,
In addition we point out key diﬀerences
where we actually obtain a neural network.
between Theorem 6.4 and the algorithmic version of our result when solving the LP in
Corollary 6.3 of size as (12): (a) In (13), the dependency on 𝑛 is better than in (12). (b) The
dependency on the Lipschitz constant is signiﬁcantly better in (12), although we are relying
on the Lipschitz constant with respect to all inputs of the loss function and in a potentially
larger domain. (c) The dependency on 𝜖 is also better in (12). (d) We are not assuming
convexity of ℓ and we consider general 𝑚. (e) The dependency on 𝑘 in (12) is much more
benign than the one in (13), which is doubly exponential.

Remark 6.6. A recent manuscript by [26] provides a similar algorithm to the one by [20] but
in the proper learning setting, for depth-2 ReLU networks with convex loss functions. The
1
running time of the algorithm (rephrased to match our notation) is
) .
Analogous to the comparison in Remark 6.5, we obtain a much better dependence with
respect to 𝜖 and we do not rely on convexity of the loss function or on constant depth of the
neural network.

1
) 2(

𝛼

𝑛

/

𝑂

𝑤

)

(

𝑂

/

𝜖

)

(

(

7. Conclusion and final remarks

We have showed that ERM problems admit a representation which encodes all possible
training problems in a single polytope whose size depends only linearly on the sample size
and possesses optimality guarantees. Moreover, we show that training is closely related
to the face structure of this data-independent polytope. As a byproduct, our contributions
also improve some of the best known algorithmic results for neural network training with
optimality/approximation guarantees.

These results shed new light on (theoretical) neural network training by bringing together
concepts of graph theory, polyhedral geometry, and non-convex optimization as a tool
for Deep Learning. Our data-independent polyhedral encoding, its data-dependent face
structure, and the fact that its size is only linear on the sample size reveal an interesting
interaction between diﬀerent training problems.

While a straightforward algorithmic use of our formulation is likely to be diﬃcult to
solve in practice, we believe the theoretical foundations we lay here can also have practical
implications in the Machine Learning community. All our architecture dependent terms
are worst-case bounds, which can be improved by assuming more structure. Additionally,
the history of Linear Programming has provided many important cases of extremely large
LPs that can be solved to near-optimality without necessarily generating the complete
description. In these, the theoretical understanding of the polyhedral structure is crucial to
drive the development of solution strategies.

Acknowledgements

Research reported in this paper was partially supported by NSF CAREER award CMMI-
1452463, ONR award GG012500 and the Institute for Data Valorization (IVADO). We
would also like to thank Shabbir Ahmed for the helpful pointers and discussions.

References

[1] Shabbir Ahmed. A Graduate Course on Stochastic Programming. preprint, 2017.
[2] Brandon Amos, Lei Xu, and J Zico Kolter. Input convex neural networks. In International Conference on

Machine Learning, pages 146–155, 2017.

20

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

[3] Ross Anderson, Joey Huchette, Christian Tjandraatmadja, and Juan Pablo Vielma. Strong convex relaxations
and mixed-integer programming formulations for trained neural networks. arXiv preprint arXiv:1811.01988,
2018.

[4] Raman Arora, Amitabh Basu, Poorya Mianjy, and Anribit Mukherjee. Understanding deep neural networks
with rectiﬁed linear units. to appear in Proceedings of ICLR 2018, arXiv preprint arXiv:1611.01491, 2018.
[5] Albert Atserias. On digraph coloring problems and treewidth duality. European Journal of Combinatorics,

29(4):796–820, 2008.

[6] Kristin P Bennett and Olvi L Mangasarian. Neural network training via linear programming. Technical

report, University of Wisconsin-Madison Department of Computer Sciences, 1990.

[7] Kristin P Bennett and Olvi L Mangasarian. Robust linear programming discrimination of two linearly

inseparable sets. Optimization methods and software, 1(1):23–34, 1992.

[8] Leonard Berrada, Andrew Zisserman, and M Pawan Kumar. Deep frank-wolfe for neural network optimiza-

tion. arXiv preprint arXiv:1811.07591, 2018.

[9] Dan Bienstock. On embedding graphs in trees. Journal of Combinatorial Theory, Series B, 49(1):103–136,

1990.

[10] Daniel Bienstock and Gonzalo Muñoz. Lp formulations for polynomial optimization problems. SIAM Journal

on Optimization, 28(2):1121–1150, 2018.

[11] Avrim L. Blum and Ronald L. Rivest. Training a 3-node neural network is np-complete. Neural Networks,

5(1):117 – 127, 1992.

[12] Digvĳay Boob, Santanu S Dey, and Guanghui Lan. Complexity of training relu neural network. arXiv

preprint arXiv:1809.10787, 2018.

[13] Léon Bottou, Frank E Curtis, and Jorge Nocedal. Optimization methods for large-scale machine learning.

Siam Review, 60(2):223–311, 2018.

[14] Gruia Calinescu, Cristina G Fernandes, and Bruce Reed. Multicuts in unweighted graphs and digraphs with
bounded degree and bounded tree-width. In Proceedings of the 6th Conference on Integer Programming and
Combinatorial Optimization (IPCO). Citeseer, 1998.

[15] Chih-Hong Cheng, Georg Nührenberg, and Harald Ruess. Maximum resilience of artiﬁcial neural networks.
In International Symposium on Automated Technology for Veriﬁcation and Analysis, pages 251–268. Springer,
2017.

[16] Matthieu Courbariaux, Itay Hubara, Daniel Soudry, Ran El-Yaniv, and Yoshua Bengio. Binarized neural
networks: Training deep neural networks with weights and activations constrained to+ 1 or-1. arXiv preprint
arXiv:1602.02830, 2016.

[17] Frank E Curtis and Katya Scheinberg. Optimization methods for supervised machine learning: From linear
models to deep learning. In Leading Developments from INFORMS Communities, pages 89–114. INFORMS,
2017.

[18] Matteo Fischetti and Jason Jo. Deep neural networks and mixed integer linear optimization. Constraints,

pages 1–14, 2018.

[19] Steﬀen Goebbels. Training of relu activated multilayerd neural networks with mixed integer linear programs.

Technical report, Hochschule Niederrhein, Fachbereich Elektrotechnik & Informatik, 2021.

[20] Surbhi Goel, Varun Kanade, Adam Klivans, and Justin Thaler. Reliably learning the relu in polynomial time.

In Conference on Learning Theory, pages 1004–1042, 2017.

[21] Ian Goodfellow, Yoshua Bengio, and Aaron Courville. Deep learning. MIT press, 2016.
[22] Henry Gouk, Eibe Frank, Bernhard Pfahringer, and Michael Cree. Regularisation of neural networks by

enforcing lipschitz continuity. arXiv preprint arXiv:1804.04368, 2018.

[23] Daniel J Harvey and David R Wood. The treewidth of line graphs. Journal of Combinatorial Theory, Series

B, 2018.

[24] Elias B Khalil, Amrita Gupta, and Bistra Dilkina. Combinatorial attacks on binarized neural networks. arXiv

preprint arXiv:1810.03538, 2018.

[25] Qianli Liao, Brando Miranda, Andrzej Banburski, Jack Hidary, and Tomaso Poggio. A surprising linear

relationship predicts test performance in deep networks. arXiv preprint arXiv:1807.09659, 2018.

[26] Pasin Manurangsi and Daniel Reichman. The computational complexity of training relu (s). arXiv preprint

arXiv:1810.04207, 2018.

[27] Somnath Mukhopadhyay, Asim Roy, Lark Sang Kim, and Sandeep Govil. A polynomial time algorithm for
generating neural networks for pattern classiﬁcation: Its stability properties and some test results. Neural
Computation, 5(2):317–330, 1993.

[28] Sebastian Pokutta, Christoph Spiegel, and Max Zimmer. Deep neural network training with frank-wolfe.

arXiv preprint arXiv:2010.07243, 2020.

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

21

[29] Neil Robertson and Paul D. Seymour. Graph minors II: Algorithmic aspects of tree-width. Journal of

Algorithms, 7:309 – 322, 1986.

[30] Asim Roy, Lark Sang Kim, and Somnath Mukhopadhyay. A polynomial time algorithm for the construction

and training of a class of multilayer perceptrons. Neural networks, 6(4):535–545, 1993.

[31] Thiago Serra, Christian Tjandraatmadja, and Srikumar Ramalingam. Bounding and counting linear regions

of deep neural networks. arXiv preprint arXiv:1711.02114, 2017.

[32] Alexander Shapiro, Darinka Dentcheva, and Andrzej Ruszczyński. Lectures on stochastic programming:

modeling and theory. SIAM, 2009.

[33] Stephen J Wright. Optimization algorithms for data analysis. The Mathematics of Data, 25:49, 2018.
[34] Jiahao Xie, Zebang Shen, Chao Zhang, Boyu Wang, and Hui Qian. Eﬃcient projection-free online meth-
ods with stochastic recursive gradient. In Proceedings of the AAAI Conference on Artiﬁcial Intelligence,
volume 34, pages 6446–6453, 2020.

[35] Yuchen Zhang, Jason D Lee, and Michael I Jordan. l1-regularized neural networks are improperly learnable

in polynomial time. In International Conference on Machine Learning, pages 993–1001, 2016.

Appendix A. Further definitions

A.1. Proper vs. improper learning. An important distinction is the type of solution to
the ERM that we allow. In this work we are considering proper learning, where we require
Φ, i.e., the model has to be from the considered model class
the solution to satisfy 𝜙
Ω, with
induced by Φ and takes the form 𝑓

∈

(·
ˆ𝑥𝑖, 𝜙∗

, 𝜙∗)
, ˆ𝑦𝑖

)

for some 𝜙∗ ∈
1
min
𝐷
Φ
𝜙
∈

𝐷

) ≤

Õ𝑖=1

1
𝐷

𝐷

Õ𝑖=1

𝑓

ℓ

(

(

𝑓

ℓ

(

(

ˆ𝑥𝑖, 𝜙

, ˆ𝑦𝑖

,

)

)

and this can be relaxed to 𝜖-approximate (proper) learning by allowing for an additive error
𝜖 > 0 in the above. In contrast, in improper learning we allow for a model 𝑔
, that cannot
Φ, satisfying
be obtained as 𝑓

with 𝜙

, 𝜙

(·)

(·

)

∈

1
𝐷

𝐷

Õ𝑖=1

ℓ

𝑔

(

(

ˆ𝑥𝑖

)

, ˆ𝑦𝑖

) ≤

1
𝐷

min
Φ
𝜙
∈

𝐷

Õ𝑖=1

𝑓

ℓ

(

(

ˆ𝑥𝑖, 𝜙

, ˆ𝑦𝑖

,

)

)

with a similar approximate version.

Appendix B. Regularized ERM

A common practice to avoid over-ﬁtting is the inclusion of regularizer terms in (1). This

leads to problems of the form

(14)

1
𝐷

min
Φ
𝜙
∈

𝐷

Õ𝑖=1

𝑓

ℓ

(

(

ˆ𝑥𝑖, 𝜙

, ˆ𝑦𝑖

)

𝜆 𝑅

𝜙

,

)

(

) +

(·)

where 𝑅
is a function, typically a norm, and 𝜆 > 0 is a parameter to control the
strength of the regularization. Regularization is generally used to promote generalization
and discourage over-ﬁtting of the obtained ERM solution. The reader might notice that our
arguments in Section 3 regarding the epigraph reformulation of the ERM problem and the
tree-decomposition of its intersection graph can be applied as well, since the regularizer
term does not add any extra interaction between the data-dependent variables.

The previous analysis extends immediately to the case with regularizers after appropriate

modiﬁcation of the architecture Lipschitz constant
Deﬁnition B.1. Consider a regularized ERM problem (14) with parameters 𝐷, Φ, ℓ, 𝑓 , 𝑅,
and 𝜆. We deﬁne its Architecture Lipschitz Constant

𝐷, Φ, ℓ, 𝑓 , 𝑅, 𝜆

to include 𝑅

(·)

as

L

.

(15)

over the domain

=

K

L (

[−

𝐷, Φ, ℓ, 𝑓 , 𝑅, 𝜆

1, 1

Φ

𝑛

]

×

× [−

(cid:17)

)
1, 1

𝑓

ℓ

(

L∞ (
𝑚.

]

L (
,

(·

·)

𝜆𝑅

,

·) +

(·))

)

22

PRINCIPLED DEEP NEURAL NETWORK TRAINING THROUGH LINEAR PROGRAMMING

Appendix C. Binarized Neural Networks

A Binarized activation unit (BiU) is parametrized by 𝑝

1 values 𝑏, 𝑎1, . . . , 𝑎 𝑝. Upon

a binary input vector 𝑧1, 𝑧2, . . . , 𝑧 𝑝 the output is binary value 𝑦 deﬁned by:

+

𝑦 = 1 if 𝑎𝑇 𝑧 > 𝑏,

and 𝑦 = 0 otherwise.

Now suppose we form a network using BiUs, possibly using diﬀerent values for the
parameter 𝑝.
In terms of the training problem we have a family of (binary) vectors
𝑥1, . . . , 𝑥 𝐷 in ℝ𝑛 and binary labels and corresponding binary label vectors 𝑦1, . . . , 𝑦𝐷 in
ℝ𝑚, and as before we want to solve the ERM problem (1). Here, the parametrization 𝜙
at each unit. In the speciﬁc case of a network with 2
refers to a choice for the pair
nodes in the ﬁrst layer and 1 node in the second layer, and 𝑚 = 1, [11] showed that it is
NP-hard to train the network so as to obtain zero loss, when 𝑛 = 𝐷. Moreover, the authors
𝑎, 𝑏
argued that even if the parameters
, the problem remains
NP-Hard. See [16] for an empirically eﬃcient training algorithm for BiUs.

are restricted to be in

𝑎, 𝑏

1, 1

{−

}

)

)

(

(

In this section we apply our techniques to the ERM problem (1) to obtain an exact
polynomial-size data-independent formulation for each ﬁxed network (but arbitrary 𝐷)
when the parameters

are restricted to be in

𝑎, 𝑏

1, 1

.

We begin by noticing that we can reformulate (1) using an epigraph formulation as in (5).
Moreover, since the data points in a BiU are binary, if we keep the data points as variables,
the resulting linear-objective optimization problem is a binary optimization problem as BO.
This allows us to claim the following:

{−

}

(

)

Theorem C.1. Consider a graph

G

, 𝑝

𝑂

ℕ and 𝐷
∈
2 𝑝

( G) | 𝐷

𝑉

|

(

∈
,

)

ℕ. There exists a polytope of size

such that any BiU ERM problem of the form (1) is equivalent to optimizing a linear function
plus the time required
over a face of 𝑃. Constructing the polytope takes time 𝑂
evaluations of 𝑓 and ℓ.
for 𝑂

( G) | 𝐷

2 𝑝

2 𝑝

𝑉

𝑉

)

(

|

(

|

( G) |)

Proof. The result follows from applying Theorem 2.8 directly to the epigraph formulation
of BiU keeping 𝑥 and 𝑦 as variables. In this case an approximation is not necessary. The
construction time and the data-independence follow along the same arguments used in the
(cid:3)
approximate setting before.

The following corollary is immediate.

Corollary C.2. The ERM problem (1) over BiUs can be solved in polynomial time for any
𝐷, whenever 𝑝 and the network structure

are ﬁxed.

G

