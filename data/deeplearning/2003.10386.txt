Incorporating Relational Background Knowledge into Reinforcement Learning
via Differentiable Inductive Logic Programming

Ali Payani 1 Faramarz Fekri 1

0
2
0
2

r
a

M
3
2

]

G
L
.
s
c
[

1
v
6
8
3
0
1
.
3
0
0
2
:
v
i
X
r
a

Abstract
Relational Reinforcement Learning (RRL) can of-
fers various desirable features. Most importantly,
it allows for incorporating expert knowledge into
the learning, and hence leading to much faster
learning and better generalization compared to
the standard deep reinforcement learning. How-
ever, most of the existing RRL approaches are ei-
ther incapable of incorporating expert background
knowledge (e.g., in the form of explicit predicate
language) or are not able to learn directly from
non-relational data such as image. In this paper,
we propose a novel deep RRL based on a differ-
entiable Inductive Logic Programming (ILP) that
can effectively learn relational information from
image and present the state of the environment as
ﬁrst order logic predicates. Additionally, it can
take the expert background knowledge and incor-
porate it into the learning problem using appro-
priate predicates. The differentiable ILP allows
an end to end optimization of the entire frame-
work for learning the policy in RRL. We show the
efﬁcacy of this novel RRL framework using envi-
ronments such as BoxWorld, GridWorld as well
as relational reasoning for the Sort-of-CLEVR
dataset.

1. Introduction

Relational Reinforcement Learning (RRL) has been investi-
gated in early 2000s by works such as (Bryant et al., 1999;
Dˇzeroski et al., 1998; 2001) among others. The main idea
behind RRL is to describe the environment in terms of ob-
jects and relations. One of the ﬁrst practical implementation
of this idea was proposed by (Dˇzeroski et al., 1998) and later
was improved in (Dˇzeroski et al., 2001) based on a modiﬁ-
cation to Q-Learning algorithm (Watkins & Dayan, 1992)
via the standard relational tree-learning algorithm TILDE

*Equal contribution 1Department of Electrical an Computer
Engineering, Georgia Institute of Technology. Correspondence to:
Ali Payani <payani@ece.gatech.edu>.

(Blockeel & De Raedt, 1998). As shown in (Dˇzeroski et al.,
2001), the RRL system allows for very natural and human
readable decision making and policy evaluations. More
importantly, the use of variables in ILP system, makes it
possible to learn generally formed policies and strategies.
Since these policies and actions are not directly associated
with any particular instance and entity, this approach leads
to a generalization capability beyond what is possible in
most typical RL systems. Generally speaking RRL frame-
work offers several beneﬁts over the traditional RL: (i) The
learned policy is usually human interpretable, and hence
can be viewed, veriﬁed and even tweaked by an expert ob-
server. (ii) The learned program can generalize better than
the classical RL counterpart. (iii) Since the language for the
state representation is chosen by the expert, it is possible
to incorporate inductive biases into learning. This can be a
signiﬁcant improvement in complex problems as it might
be used to manipulate the agent to choose certain actions
without accessing the reward function, (iv) It allows for the
incorporation of higher level concepts and prior background
knowledge.

In recent years and with the advent of the new deep learning
techniques, signiﬁcant progress has been made to the classi-
cal Q-learning RL framework. By using algorithms such as
deep Q-learning and its variants (Mnih et al., 2013; Van Has-
selt et al., 2016), as well as Policy learning algorithms such
A2C and A3C (Mnih et al., 2016), more complex problems
are now been tackled. However, the classical RRL frame-
work cannot be easily employed to tackle large scale and
complex scenes that exist in recent RL problems. Since
standard RRL framework is in not usually able to learn
from complex visual scenes and cannot be easily combined
with differentiable deep neural In particular, none of the
inherent beneﬁts of RRL have been materialized in the deep
learning frameworks thus far. This is because existing RRL
frameworks usually are not designed to learn from complex
visual scenes and cannot be easily combined with differen-
tiable deep neural networks. In (Payani & Fekri, 2019) a
novel ILP solver was introduced which uses Neural-Logical
Network (NLN) (Payani & Fekri, 2018) for constructing a
differentiable neural-logic ILP solver (dNL-ILP). The key
aspect of this dNL-ILP solver is a differentiable deduction
engine which is at the core of the proposed RRL framework.

 
 
 
 
 
 
Fc
1
0
1
1

xi mi
0
0
1
0
0
1
1
1

(a)

Fd
0
0
0
1

xi mi
0
0
1
0
0
1
1
1

(b)

Figure 1. Connected graph example

Figure 2. Truth table of Fc(·) and Fd(·) functions

As such, the resulting differentiable RRL framework can be
used similar to deep RL in an end-to-end learning paradigm,
trainable via the typical gradient optimizers. Further, in con-
trast to the early RRL frameworks, this framework is ﬂexible
and can learn from ambiguous and fuzzy information. Fi-
nally, it can be combined with deep learning techniques
such as CNNs to extract relational information from the
visual scenes. In the next section we brieﬂy introduce the
differentiable dNL-ILP solver. In section, 3 we show how
this framework can be used to design a differentiable RRL
framework. Experiments will be presented next, followed
by the conclusion.

2. Differentiable ILP via neural logic

networks

In this section, we brieﬂy present the basic design of the
differentiable dNL-ILP which is at the core of the pro-
posed RRL. More detailed presentation of dNL-ILP could
be found in (Payani & Fekri, 2019). Logic programming is
a paradigm in which we use formal logic (and usually ﬁrst-
order-logic) to describe relations between facts and rules of
a program domain. In logic programming, rules are usually
written as clauses of the form H ← B1, B2, . . . , Bm, where
H is called head of the clause and B1, B2, . . . , Bm is called
body of the clause. A clause of this form expresses that if
all the atoms Bi in the body are true, the head is neces-
sarily true. Each of the terms H and B is made of atoms.
Each atom is created by applying an n-ary Boolean func-
tion called predicate to some constants or variables. A
predicate states the relation between some variables or
constants in the logic program. We use lowercase letters
for constants (instances) and uppercase letters for variables.
To avoid technical details, we consider a simple logic pro-
gram. Assume that a directed graph is deﬁned using a series
of facts in the form of edge(X,Y) where for example
edge(a,b) states that there is an edge from node a to the
node b. As an example, the graph in Fig. 1 can be repre-
sented as {edge(a,b), edge(b,c), edge(c,d),
edge(d,b)}. Assume that our task is to learn the
cnt(X,Y) predicate from a series of examples, where
cnt(X,Y) is true if there is a directed path from node X to
node Y. The set of positive examples in graph depicted in
Fig. 1 is P = {cnt(a,b), cnt(a,c), cnt(a,d),
cnt(b,b),cnt(b,c), cnt(b,d),...}. Similarly

the set of negative examples N includes atoms such as
{cnt(a,a),cnt(b,a),...}.

It is easy to verify that the predicate cnt deﬁned as be-
low satisﬁes all the provided examples (entails the positive
examples and rejects the negative one):

cnt(X,Y) ← edge(X,Y)
cnt(X,Y) ← edge(X,Z), cnt(Z,Y)

(1)

In fact by applying each of the above two rules to the
constants in the program we can produce all the conse-
quences of such hypothesis If we allow for formulas with
3 variables (X,Y,Z) as in (1), we can easily enumer-
ate all the possible symbolic atoms that could be used
in the body of each clause.
In our working example,
this corresponds to Icnt ={edge(X,X), edge(X,Y),
edge(X,Z), ..., cnt(Z,Y), cnt(Z,Z)}. As
the size of the problem grows, considering all the possi-
bilities becomes unfeasible. Consequently, almost all ILP
systems use some form of rule templates to reduce the possi-
ble combinations. For example, the dILP (Evans & Grefen-
stette, 2018) model, allows for the clauses (in the body)
of at most two atoms in each clause predicate. In (Payani
& Fekri, 2019), a novel approach was introduced to allevi-
ate the above limitation and to allow for learning arbitrary
complex predicate formulas. The main idea behind this
approach is to use multiplicative neurons (Payani & Fekri,
2018) that are capable of learning and representing Boolean
logic. Consider the fuzzy notion of Boolean algebra where
fuzzy Boolean value are represented as a real value in range
[0, 1], where True and False are represented by 1 and 0, re-
spectively. Let ¯x be the logical ‘NOT’ of x. Let xxxn ∈ {0, 1}n
be the input vector for a logical neuron. we can associate
a trainable Boolean membership weight mi to each input
elements xi from vector xxxn. Consider Boolean function
Fc(xi, mi) with the truth table as in Fig. 2a which is able to
include (exclude) each element xi in (out of) the conjunction
function fcon j(xxxn). This design ensures the incorporation of
each element xi in the conjunction function only when the
corresponding membership weight mi is 1. Consequently,
the neural conjunction function fcon j can be deﬁned as:

fcon j(xxxn) =

Fc(xi, mi)

n
∏
i=1

where,

Fc(xi, mi) = ximi = 1 − mi(1 − xi)

(2)

Likewise, a neural disjunction function fdis j(xxxn) can be
deﬁned using the auxiliary function Fd with the truth table
as in Fig. 2b. By cascading a layer of N neural conjunction
functions with a layer of N neural disjunction functions,
we can construct a differentiable function to be used for
representing and learning a Boolean Disjunctive Normal
Form (DNF).

dNL-ILP employs these differentiable Boolean functions
(e.g. dNL-DNF) to represent and learn predicate functions.
Each dNL function can be seen as a parameterized sym-
bolic formula where the (fuzzy) contribution of each symbol
(atom) in the learned hypothesis is controlled by the train-
able membership weights (e.g., wi where mi = sigmoid(wi)).
If we start from the background facts ( e.g. all the ground-
ings of predicate edge(X,Y) in the graph example and
apply the parameterized hypothesis we arrive at some new
consequences (e.g., forward chaining). After repeating this
process to obtain all possible consequences, we can update
the parameters in dNL by minimizing the cross entropy be-
tween the desired outcome (provided positive and negative
examples) and the deduced consequences.

An ILP description of a problem in this framework consist
of these elements:

1. The set of constants in the program. In example of Fig.

1, this consists of C ={a,b,c,d}

2. The set of background facts.

In the graph
example above this consists of groundings of
i.e., B ={edge(a,b),
predicate edge(X,Y),
edge(b,c), edge(c,d), edge(d,b)}

3. The deﬁnition of auxiliary predicates. In the simple
example of graph we did not include any auxiliary
predicates. However, in more complex example they
would greatly reduce the complexity of the problem.

4. The signature of the target hypothesis. In the graph
example, This signature indicates the target hypothesis
is 2-ary predicate cnt(X,Y) and in the symbolic rep-
resentation of this Boolean function we are allowed to
use three variables X,Y,Z.

In addition to the aforementioned elements, some param-
eters such as intial values for the membership weights
(mi = sigmoid(wi)), as well as the number of steps of for-
ward chaining should be provided. Furthermore, in dNL-ILP
the memberships are fuzzy Boolean values between 0 and 1.
As shown in (Payani & Fekri, 2019), for ambiguous prob-
lems where a deﬁnite Boolean hypothesis may not be found
which could satisfy all the examples, there is no guaranty
that the membership weights converge to zero or 1. In appli-
cations where our only goal is to ﬁnd a successful hypothesis
this result is satisfactory. However, if the interpretability of

the learned hypothesis is by itself a goal in learning, we may
need to encourage the membership weights to converge to 0
and 1 by adding a penalty term:

interpretability penalty ∝ mi(1 − mi)

(3)

3. Relational Reinforcement Learning via

dNL-ILP

Early works on RRL (Dˇzeroski et al., 2001; Van Otterlo,
2005) mainly relied on access to the explicit representation
of states and actions in terms of relational predicate lan-
guage. In the most successful instances of these approaches,
a regression tree algorithm is usually used in combination
with a modiﬁed version of Q-Learning algorithms. The fun-
damental limitation of the traditional RRL approaches is that
the employed ILP solvers are not differentiable. Therefore,
those approaches are typically only applicable the problems
for which the explicit relational representation of states and
actions is provided. Alternatively, deep RL models, due to
recent advancement in deep networks, have been success-
fully applied to the much more complex problems. These
models are able to learn from raw images without relying
on any access to the explicit representation of the scene.
However, the existing RRL counterparts are falling behind
such desirable developments in deep RL.

In this paper, we establish that differentiable dNL-ILP pro-
vides a platform to combine RRL with deep learning meth-
ods, constructing a new RRL framework with the best of
both worlds. This new RRL system allows the model to
learn from the complex visual information received from the
environment and extract intermediate explicit relational rep-
resentation from the raw images by using the typical deep
learning models such as convolutional networks. Although
the dNL-ILP can also be used to formulate RL algorithms
such as deep Q-learning, we focus only on deep policy gra-
dient learning algorithm. This formulation is very desirable
because it makes the learned policy to be interpretable by
human. One of the other advantages of using policy gradi-
ent in our RRL framework is that it enables us to restrict
actions according to some rules obtained either from human
preferences or from problem requirements. This in turn
makes it possible to account for human preferences or to
avoid certain pitfalls, e.g., as in safe AI.

In our RRL framework, although we use the generic formula-
tion of the policy gradient with the ability to learn stochastic
policy, certain key aspects are different from the traditional
deep policy gradient methods, namely state representation,
language bias and action representation. In the following,
we will explain these concepts in the context of BoxWorld
game. In this game, the agent’s task is to learn how to stack
the boxes on top of each other (in a certain order). For il-
lustration, consider the simpliﬁed version of the game as in

Figure 3. States representation in the form of predicates in BoxWorld game, before and after an action

Fig.3 where there are only three boxes labeled as a,b, and
c. A box can be on top of another or on the floor. A box
can be moved if it is not covered by another box and can
be either placed on the ﬂoor or on top of another uncovered
box. For this game, the environment state can be fully ex-
plained via the predicate on(X,Y). Fig. 3 shows the state
representation of the scene before and after an action (indi-
cated by the predicate move(c,b)). In the following we
discuss each distinct elements of the proposed framework
using the BoxWorld environment. Fig. 4 displays the overall
design of our proposed RRL framework. In the following
we discuss the elements of this RRL system.

3.1. State Representation

In the previous approaches to the RRL (Dˇzeroski et al.,
1998; 2001; Jiang & Luo, 2019), state of the environment
is expressed in an explicit relational format in the form of
predicate logic. This signiﬁcantly limits the applicability of
RRL in complex environments where such representations
are not available. Our goal in this section is to develop a
method in which the explicit representation of states can
be learned via typical deep learning techniques in a form
that will support the policy learning via our differentiable
dNL-ILP. As a result, we can utilize the various beneﬁts
of the RRL discipline without being restricted only to the
environments with explicitly represented states.

For example, consider the BoxWorld environment ex-
plained earlier where the predicate on(X,Y) is used to
represent the state explicitly in the relational form (as
shown in Fig.3). Past works in RRL relied on access
to explicit relational representation of states, i.e., all the
groundings of the state representation predicates. Since
this example has 4 constants, i.e. C ={a,b,c,floor},
these groundings would be the binary values (‘true’ or
‘false’) for the atoms on(a,a), on(a,b), on(a,c),
on(a,floor), ..., on(floor,floor).
In re-
cent years, extracting relational information from visual
scenes has been investigated. Fig. 6 shows two types of
relational representation extracted from images in (Santoro
et al., 2017). The idea is to ﬁrst process the images through
multiple CNN networks. The last layer of the convolutional
network chain is treated as the feature vector and is usu-
ally augmented with some non-local information such as

absolute position of each point in the ﬁnal layer of the CNN
network. This feature map is then fed into a relational learn-
ing unit which is tasked with extracting non-local features.
Various techniques have been then introduced recently for
learning these non-local information from the local fea-
ture maps, namely, self attention network models (Vaswani
et al., 2017; Santoro et al., 2017) as well as graph networks
(Narayanan et al., 2017; Allamanis et al., 2017). Unfortu-
nately, none of the resulting presentations from past works
is in the form of predicates needed in ILP.

In our approach, we use similar networks discussed earlier to
extract non-local information. However given the relational
nature of state representation in our RRL model, we consider
three strategies in order to facilitate learning the desired
relational state from images. Namely:

1. Finding a suitable state representation: In our Box-
World example, we used the on(X,Y) to represent
the state of the environment. However, learning this
predicate requires inferring relation among various ob-
jects in the scene. As shown by previous works (e.g.,
(Santoro et al., 2017)), this is a difﬁcult task even in the
context of a fully supervised setting (i.e., all the labels
are provided) which is not applicable here. Alterna-
tively, we propose to use lower-level relation for state
representation and build higher level representation via
predicate language. In the game of BoxWorld as an ex-
ample, we can describe states by the respective position
of each box. In particular, we deﬁne two predicates
posH(X,Y) and posV(X,Y) such that variable X
is associated with the individual box, whereas Y in-
dicate horizontal or vertical coordinates of the box,
respectively. Fig. 5 shows how this new lower-level
representations can be transformed into the higher level
description by the appropriate predicate language:

on(X, Y) ← posH(X, Z), posH(Y, T),

inc(T, Z), sameH(X, Y)

sameH(X, Y) ← posH(X, Z), posH(Y, Z)

(4)

2. State constraints: When applicable, we may incorpo-
rate relational constraint in the form of a penalty term
in the loss function. For example, in our BoxWorld ex-
ample we can notice that posY(ﬂoor) should be always

Figure 4. Learning explicit relational information from images in our proposed RRL; Images are processed to obtain explicit representation
and dNL-ILP engine learns and expresses the desired policy (actions)

Figure 5. Transforming low-level state representation to high-level form via auxiliary predicates

0. In general, the choice of relational language makes
it possible to pose constraints based on our knowledge
regarding the scene. Enforcing these constraints does
not necessarily speed up the learning as we will show
in the BoxWorld experiment in Section 4.1. However,
it will ensure that the (learned) state representation and
consequently the learned relational policy resemble our
desired structure of the problem.

3. Semi-supervised setting: While it is not desirable
to label every single scene that may happen during
learning, in most cases it is possible to provide a few
labeled scene to help the model to learn the desired
state representation faster. These reference points can
then be incorporated to the loss function to encourage
the network to learn a representation that matches to
those provided labeled scenes. We have used a similar
approach in Asterix experiment (see appendix D) to
signiﬁcantly increase the speed of learning.

3.2. Action Representation

We formulate the policy gradient in a form that allows the
learning of the actions via one (or multiple) target predi-
cates. These predicates exploit the background facts, the
state representation predicates, as well as auxiliary predi-
cates to incorporate higher level concepts. In a typical Deep
policy gradient (DPG) learning, the probability distributions
of actions are usually learned by applying a multi layer per-
ception with a softmax activation function in the last layer.
In our proposed RRL, the action probability distributions
can usually be directly associated with groundings of an
appropriate predicate. For example, in BoxWorld example
in Fig.3, we deﬁne a predicate move(A,B) and associate

the actions of the agent with the groundings of this predi-
cate. In an ideal case, where there is deterministic solution
to the RRL problem, the predicate move(A,B) may be
learned in such a way that, at each state, only the grounding
(corresponding to the correct action) would result 1 (’true’)
and all the other groundings of this predicate become 0.
In such a scenario, the agent will follow the learned logic
deterministically. Alternatively, we may get more than one
grounding with value equal to 1 or we get some fuzzy val-
ues in the range of [0, 1]. In those cases, we estimate the
probability distribution of actions similar to the standard
deep policy learning by applying a softmax function to
the valuation vector of the learned predicate move (i.e., the
value of move(X,Y) for X,Y∈ {a,b,c,floor}).

4. Experiments

In this section we explore the features of the proposed RRL
framework via several examples. We have implemented1
the models using Tensorﬂow (Abadi et al., 2016).

4.1. BoxWorld Experiment

BoxWorld environment has been widely used as a bench-
mark in past RRL systems (Dˇzeroski et al., 2001; Van Ot-
terlo, 2005; Jiang & Luo, 2019). In these systems the state
of the environment is usually given as an explicitly relational
data via groundings of the predicate on(X,Y). While ILP
based systems are usually able to solve variations of this
environments, they rely on explicit representation of state
and they cannot infer the state from the image. Here, we

1The python implementation of the algorithms in this paper is

available at https://github.com/dnlRRL2020/RRL

(a) A sample from CLEVER datset

(b) A sample from sort-of-CLEVER dat-
set

Figure 6. Extracting relational information from visual scene (Santoro et al., 2017)

consider the task of stacking boxes on top of each other.
We increase the difﬁculty of the problem compared to the
previous examples (Dˇzeroski et al., 2001; Van Otterlo, 2005;
Jiang & Luo, 2019) by considering the order of boxes and
requiring that the stack is formed on top of the blue box
(the blue box should be on the ﬂoor). To make sure the
models learn generalization, we randomly place boxes on
the ﬂoor in the beginning of each episode. We consider up
to 5 boxes. Hence, the scene constants in our ILP setup
is the set {a,b,c,d,e,floor}. The dimension of the
observation images is 64x64x3 and no explicit relational
information is available for the agents. The action space
for the problem involving n boxes is (n + 1) × (n + 1) corre-
sponding to all possibilities of moving a box (or the ﬂoor)
on top of another box or the ﬂoor. Obviously some of the
actions are not permitted, e.g., placing the ﬂoor on top of a
box or moving a box that is already covered by another box.

Comparing to Baseline:
In the ﬁrst experiment, we com-
pare the performance of the proposed RRL technique to a
baseline. For the baseline we consider standard deep A2C
(with up to 10 agents) and we use the implementation in
stable-baseline library (Hill et al., 2018). We con-
sidered both MLP and CNN policies for the deep RL but we
report the results for the CNN policy because of its superior
performance. For the proposed RRL system, we use two
convolutional layers with the kernel size of 3 and strides of 2
with tanh activation function. We apply two layers of MLP
with softmax activation functions to learn the ground-
ings of the predicates posH(X,Y) and posV(X,Y). Our
presumed grid is (n + 1) × (n + 1) and we allow for posi-
tional constants {0,1,...,n} to represent the locations
in the grid in our ILP setting. As constraint we add penalty
terms to make sure posV(floor,0) is True. We use
vanilla gradient policy learning and to generate actions we
deﬁne a learnable hypothesis predicate move(X,Y). Since
we have n + 1 box constants (including ﬂoor), the ground-
ings of this hypothesis correspond to the (n + 1) × (n + 1)
possible actions. Since the value of these groundings in

dNL-ILP will be between 0 and 1, we generate softmax
logits by multiplying these outputs by a large constant c
(e.g., c = 10). For the target predicate move(X,Y), we
allows for 6 rules in learning ( corresponding to dNL-DNF
function with 6 disjunctions). The complete list of aux-
iliary predicates and parameters and weights used in the
two models are given in appendix A. As indicated in Fig.
5 and deﬁned in (4), we introduce predicate on(X,Y) as
a function of the low-level state representation predicates
posV(X,Y) and posH(X,Y). We also introduce higher
level concepts using these predicates to deﬁne the aboveness
(i.e., above(X,Y)) as well as isCovered(X,Y). Fig.
7 compares the average success per episode for the two mod-
els for the two cases of n = 4 and n = 5. The results shows
that for the case of n = 4, both models are able to learn a
successful policy after around 7000 episodes. For the more
difﬁcult case of n = 5, our proposed approach converges
after around 20K episodes whereas it takes more than 130K
episodes for the A2C approach to converge, and even then
it ﬂuctuates and does not always succeed.

Effect of background knowledge: Contrary to the stan-
dard deep RL, in an RRL approach, we can introduce our
prior knowledge into the problem via the powerful predi-
cate language. By deﬁning the structure of the problem via
ILP, we can explicitly introduce inductive biases (Battaglia
et al., 2018) which would restrict the possible form of the
solution. We can speed up the learning process or shape
the possible learnable actions even further by incorporat-
ing background knowledge. To examine the impact of the
background knowledge on the speed of learning, we con-
sider three cases for the BoxWorld problem involving n = 4
boxes. The baseline model (RRL1) is as described before.
In RRL2, we add another auxiliary predicate which deﬁnes
the movable states as:

movable(X,Y) ← ¬isCovered(X), ¬isCovered(Y),
¬same(A,B), ¬isﬂoor(X), ¬on(X,Y)

Figure 7. Comparing deep A2C and the proposed model on Box-
World task

Figure 8. Effect of background knowledge on learning BoxWorld

where ¬ indicates the negate of a term.
In the third
model (RRL3), we go one step further, and we force the
target predicate move(X,Y) to incorporate the predicate
movable(X,Y) in each of the conjunction terms. Fig.
8 compares the learning performance of these models in
terms of average success rate (between [0,1]) vs the number
of episodes.

Interpretability:
In the previous experiments, we did not
consider the interpretability of the learned hypothesis. Since
all the weights are fuzzy values, even though the learned
hypothesis is still a parameterized symbolic function, it
does not necessarily represent a valid Boolean formula. To
achieve an interpretable result we add a small penalty as
described in (3). We also add a few more state constraints to
make sure the learned representation follow our presumed
grid notations (see Appendix A for details). The learned
action predicate is found as:

move(X, Y) ← moveable(X, Y), ¬lower(X, Y)
move(X, Y) ← moveable(X, Y), isBlue(Y)
lower(X, Y) ← posV(X, Z), posV(Y, T), lessthan(Z, T)

Figure 9. GridWorld environment (Zambaldi et al., 2018)

4.2. GridWorld Experiment

We use the GridWorld environment introduced in (Zam-
baldi et al., 2018) for this experiment. This environment is
consisted of a 12 × 12 grid with keys and boxes randomly
scattered. It also have an agent, represented by a single dark
gray square box. The boxes are represented by two adjacent
colors. The square on the right represents the boxs lock type
whose color indicates which key can be used to open that
lock. The square on the left indicates the content of the box
which is inaccessible while the box is locked. The agent
must collect the key before accessing the box. When the
agent has a key, provided that it walks over the lock box
with the same color as its key, it can open the lock box, and
then it must enter to the left box to acquire the new key
which is inside the left box. The agent cannot get the new
key prior to successfully opening the lock box on the right
side of the key box. The goal is for the agent to open the
gem box colored as white. We consider two difﬁculty levels.
In the simple scenario, there is no (dead-end) branch. In
the more difﬁcult version, there can be one branch of dead
end. An example of the environment and the branching
scenarios is depicted in Fig. 9. This is a very difﬁcult task
involving complex reasoning. Indeed, in the original work
it was shown that a multi agent A3C combined with a non-
local learning attention model could only start to learn after
processing 5 × 108 episodes. To make this problem easier
to tackle, we modify the action space to include the location
of any point in the grid instead of directional actions. Given
this deﬁnition of the problem, the agent’s task is to give the
location of the next move inside the rectangular grid. Hence,
the dimension of the action space is 144 = 12 × 12. For this
environment, we deﬁne the predicates color(X,Y,C),
where X,Y ∈ {1, . . . 12}, C ∈ {1, . . . , 10} and hasKey(C)
to represent the state. Here, variables X,Y denote the co-
ordinates, and the variable C is for the color. Similar to
the BoxWorld game, we included a few auxiliary predi-
cates such as isBackground(X,Y), isAgent(X,Y)

4.3. Relational Reasoning

Combining dNL-ILP with standard deep learning techniques
is not limited to the RRL settings. In fact, the same approach
can be used in other areas in which we wish to reason about
the relations of objects. To showcase this, we consider
the relational reasoning task involving the Sort-of-CLEVR
(Santoro et al., 2017) dataset. This dataset (See Fig.6b)
consists of 2D images of some colored objects. The shape
fo each object is either a rectangle or a circle and each
image contains up to 6 objects. The questions are hard-
coded as ﬁxed-length binary strings. Questions are either
non-relational (e.g, ”what is the color of the green object?”)
or relational (e.g., ”what is the shape of the nearest object
to the green object?”). In (Santoro et al., 2017), the authors
combined a CNN generated feature map with a special type
of attention based non-local network in order to solve the
problem. We use the same CNN network and similar to
the GridWorld experiment, we learn the state representation
using predicate color(X,Y,C) (the color of each cell in
the grid) as well as isCircle(X,Y) which learn if the
shape of an object is circle or not. Our proposed approach
reaches the accuracy of 99% on this dataset compared to the
94% for the non-local approach presented in (Santoro et al.,
2017). The details of the model and the list of predicates in
our ILP implementation is given in appendix C.

5. Conclusion

In this paper, we proposed a novel deep Relational Rein-
forcement Learning (RRL) model based on a differentiable
Inductive Logic Programming (ILP) that can effectively
learn relational information from image. We showed how
this model can take the expert background knowledge and
incorporate it into the learning problem using appropriate
predicates. The differentiable ILP allows an end to end
optimization of the entire framework for learning the pol-
icy in RRL. We showed the performance of the proposed
RRL framework using environments such as BoxWorld and
GridWorld.

References

Abadi, M., Barham, P., Chen, J., Chen, Z., Davis, A., Dean,
J., Devin, M., Ghemawat, S., Irving, G., Isard, M., et al.
Tensorﬂow: A system for large-scale machine learning.
In 12th {USENIX} Symposium on Operating Systems
Design and Implementation ({OSDI} 16), pp. 265–283,
2016.

Allamanis, M., Brockschmidt, M., and Khademi, M. Learn-
ing to represent programs with graphs. arXiv preprint
arXiv:1711.00740, 2017.

Battaglia, P. W., Hamrick, J. B., Bapst, V., Sanchez-

Figure 10. Effect of background knowledge on learning GridWorld

and isGem(X,Y) as part of the background knowledge.
The representational power of ILP allows us to incorpo-
rate our prior knowledge about the problem into the model.
As such we can include some higher level auxiliary helper
predicates such as :

isItem(X, Y) ← ¬isBackground(X, Y), ¬isAgent(X, Y)
locked(X, Y) ← isItem(X, Y), isItem(X,Z), inc(Y, Z)

where predicate inc(X,Y) deﬁnes increments for integers
(i.e., inc(n,n+1) is true for every integer n). The list of
all auxiliary predicates used in this experiment as well as the
parameters of the neural networks used in this experiment
are given in Appendix B. Similar to previous experiments
we consider two models, an A2C agent as the baseline and
our proposed RRL model using the ILP language described
in Appendix B. We listed the number of episodes it takes

Table 1. Number of training episodes required for convergence

model

Without Branch With Branch

proposed RRL
A2C

700
> 108

4500
> 108

to converge in each setting in Table1. As the results suggest,
the proposed approach can learn the solution in both settings
very fast. On the contrary, the standard deep A2C was not
able to converge after 108 episodes. This example restates
the fact that incorporating our prior knowledge regarding
the problem can signiﬁcantly speed up the learning process.

Further, similar to the BoxWorld experiment, we study the
importance of our background knowledge in the learning.
In the ﬁrst task (RRL1), we evaluate our model on the
non-branching task by enforcing the action to include the
isItem(X,Y ) predicate. In RRL2, we do not enforce this.
As shown in Fig10, RRL1 model learns 4 times faster than
RRL2. Arguably, this is because, enforcing the inclusion of
isItem(X,Y ) in the action hypothesis reduces the possibility
of exploring irrelevant moves (i.e., moving to a location
without any item).

Gonzalez, A., Zambaldi, V., Malinowski, M., Tacchetti,
A., Raposo, D., Santoro, A., Faulkner, R., et al. Rela-
tional inductive biases, deep learning, and graph networks.
arXiv preprint arXiv:1806.01261, 2018.

Payani, A. and Fekri, F. Decoding ldpc codes on binary
erasure channels using deep recurrent neural-logic layers.
In Turbo Codes and Iterative Information Processing
(ISTC), 2018 International Symposium On. IEEE, 2018.

Blockeel, H. and De Raedt, L. Top-down induction of ﬁrst-
order logical decision trees. Artiﬁcial intelligence, 101
(1-2):285–297, 1998.

Payani, A. and Fekri, F. Inductive logic programming via
differentiable deep neural logic networks. arXiv preprint
arXiv:1906.03523, 2019.

Santoro, A., Raposo, D., Barrett, D. G., Malinowski, M.,
Pascanu, R., Battaglia, P., and Lillicrap, T. A simple neu-
ral network module for relational reasoning. In Advances
in neural information processing systems, pp. 4967–4976,
2017.

Van Hasselt, H., Guez, A., and Silver, D. Deep reinforce-
ment learning with double q-learning. In Thirtieth AAAI
Conference on Artiﬁcial Intelligence, 2016.

Van Otterlo, M. A survey of reinforcement learning in rela-
tional domains. Centre for Telematics and Information
Technology (CTIT) University of Twente, Tech. Rep, 2005.

Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones,
L., Gomez, A. N., Kaiser, Ł., and Polosukhin, I. Atten-
tion is all you need. In Advances in neural information
processing systems, pp. 5998–6008, 2017.

Watkins, C. J. and Dayan, P. Q-learning. Machine learning,

8(3-4):279–292, 1992.

Zambaldi, V., Raposo, D., Santoro, A., Bapst, V., Li, Y.,
Babuschkin, I., Tuyls, K., Reichert, D., Lillicrap, T.,
Lockhart, E., et al. Relational deep reinforcement learn-
ing. arXiv preprint arXiv:1806.01830, 2018.

Bryant, C., Muggleton, S., Page, C., Sternberg, M., et al.
Combining active learning with inductive logic program-
ming to close the loop in machine learning. In AISB99
Symposium on AI and Scientiﬁc Creativity, pp. 59–64.
Citeseer, 1999.

Dˇzeroski, S., De Raedt, L., and Blockeel, H. Relational
reinforcement learning. In International Conference on
Inductive Logic Programming, pp. 11–22. Springer, 1998.

Dˇzeroski, S., De Raedt, L., and Driessens, K. Relational
reinforcement learning. Machine learning, 43(1-2):7–52,
2001.

Evans, R. and Grefenstette, E. Learning explanatory rules
from noisy data. Journal of Artiﬁcial Intelligence Re-
search, 61:1–64, 2018.

Hessel, M., Modayil, J., van Hasselt, H., Schaul, T., Ostro-
vski, G., Dabney, W., Horgan, D., Piot, B., Azar, M., and
Silver, D. Rainbow: Combining improvements in deep
reinforcement learning, 2017.

Hill, A., Rafﬁn, A., Ernestus, M., Gleave, A., Kanervisto, A.,
Traore, R., Dhariwal, P., Hesse, C., Klimov, O., Nichol,
A., Plappert, M., Radford, A., Schulman, J., Sidor, S.,
and Wu, Y. Stable baselines. https://github.com/
hill-a/stable-baselines, 2018.

Jiang, Z. and Luo, S. Neural logic reinforcement learning,

2019.

Mnih, V., Kavukcuoglu, K., Silver, D., Graves, A.,
Antonoglou, I., Wierstra, D., and Riedmiller, M. Playing
atari with deep reinforcement learning. arXiv preprint
arXiv:1312.5602, 2013.

Mnih, V., Badia, A. P., Mirza, M., Graves, A., Lillicrap,
T., Harley, T., Silver, D., and Kavukcuoglu, K. Asyn-
chronous methods for deep reinforcement learning. In
International conference on machine learning, pp. 1928–
1937, 2016.

Narayanan, A., Chandramohan, M., Venkatesan, R., Chen,
L., Liu, Y., and Jaiswal, S.
graph2vec: Learning
distributed representations of graphs. arXiv preprint
arXiv:1707.05005, 2017.

A. BoxWorld Experiment

For the problem consists of n box, we need n + 1 constants of type box (note that we consider the ﬂoor as one of the boxes in
our problem deﬁnition). Additionally, we deﬁne numerical constants {0, . . . , n} to represent box coordinates using in posH
and posV predicates. For the numerical constants we deﬁne orderings via extensional predicates lt/2 and inc/2. For the
box constants, we deﬁne two extensional predicates same/2 and isBlue/1. Here, by p/N we mean predicate p of arity N
(i.e., p has N arguments). Since these are extensional predicates, their truth values are ﬁxed in the beginning of the program
via the background facts. For example, for predicate inc/2 which deﬁnes the increment by one for the natural numbers, we
need to set these background facts the beginning: {inc(0,1), inc(1,2),...,inc(n-1,n)}. Similarly, for the
predicate lt (short for lessThan) this set includes items such as {lt(0,1), lt(0,2),...,lt(n-1,n)}. It is worth
noting that introducing predicates such as isBlue for boxes does not mean we already know which box is the blue one
(the target box that needs to be ﬁrst box in the stack). This predicate merely provides a way for the system to distinguish
between boxes. Since in our learned predicates we can only use symbolic atoms (predicates with variables) and in dNL-ILP
implementation, no constant is allowed in forming the hypothesis, this method allows for referring to an speciﬁc constant in
the learned action predicates. Here, for example, we make an assumption that box a in our list of constants corresponds
to the blue box via the background fact isBlue(a). Table 3 explains all extensional predicates as well as those helper
auxiliary predicates that was used in our BoxWorld program.

So far in our discussions, we have not distinguished between the type of variables. However, in the dNL-ILP implementation,
the type of each variable should be speciﬁed in the signature of each deﬁned predicate. This allows the dNL-ILP to use
only valid combination of variables to generate the symbolic formulas. In the BoxWorld experiment, we have two types of
constants Tb and Tp referring to the box and numeric constants, respectively. In Table3, for each deﬁned predicate, the list of
variables and their corresponding types are given, where for example X(Tp) states that the type of variable X is Tp.

For clarity, Table 3 is divided into two sections. In the top section the constants are deﬁned. In the other section, 4 groups of
predicates are presented: (i) state representation predicates that their groundings are learned from image, (ii) extensional
predicates which are solely deﬁned by background facts, (iii) auxiliary predicates and, (iv) the signature for the target
predicate that is used to represent the actions in the policy gradient scheme. To learn the policy, we used discount factor of
0.7, and we use ADAM optimizer with learning rate of 0.002. We set the maximum number of steps for each episode to 20.
To learn the feature map, we used two layers of CNNs with kernel size of 5 and strides of 3 and we applied fully connected
layers with softmax activation functions to learn the groundings of the state representation predicates posH and posV.

B. GridWorld Experiment

In the GridWorld experiment, we distinguish between constants used for vertical and horizontal coordinates as shown Table
4. This reduces the number of possible symbolic atoms and makes the convergence faster. We also deﬁne 10 constants of
type Tc to represent each of the 10 possible colors for the grid cells in the scene. The complete list of all the extensional and
auxiliary predicates for this program is listed in Table 4. In this task, to incorporate our knowledge about the problem, we
deﬁne the concept of item via predicate isItem(X,Y). Using this deﬁnition, an item represents any of the the cells that
are neither background nor agent. By incorporating this concept, we can further deﬁne higher level concepts via locked
and isLock predicates which deﬁne the two adjacent items as a locked item and its corresponding key, respectively. The
dimension of the observation image is 112x112x3. We consider two types of networks to extract grid colors from the image.
In the ﬁrst method, we apply three layers of convolutional network with kernel sizes of [5, 3, 3] and strides of 2 for all. We
use relu activation function apply batch normalization after each layer. The number of features in each layer are set to 24.
We take the feature map of size 14 × 14 × 24 and apply two layers MLP with dimensions of 64 and 10 (10 is the the number
of color constants) and activation functions of relu and softmax, to generate the grounding matrix G (the dimension of
G is 14x14x10). As can be seen in Fig 11, the current key is located at the top left border. We extract the grounding for
predicate hasKey from the value of G[0, 0, :] and the groundings of the predicate color by discarding the border elements
from G (i.e., G[1..12, 1..12, :]).

Alternatively, and because of the simplicity of the environment, instead of using CNNs, we may take the center of each box
to directly create the feature map of size 14 × 14 × 3 and then apply the MLP to generate the groundings. In our experiments
we tested both scenarios. Using the CNN approach the speed of convergence in our method was around 2 times slower. For
the A2C algorithm, we could not solve the problem using either of these approaches. We set the maximum number of steps
in an episode to 50 and we use learning rate of .001. For our models, we use discount factor of 0.9 and for the A2C we
tested various numbers in range of 0.9 to 0.99 to ﬁnd the best solution.

Figure 11. An example GridWorld scene

Table 2. Flat index for a grid of 4 by 4 used in relational learning task

0
4
8
12

1
5
9
13

2
6
10
14

3
7
11
15

C. Relational Reasoning Experiment

This task was introduced as a benchmark for learning relational information from images in (Santoro et al., 2017). In this
task, the objects of two types (circle or rectangle) and in 6 different colors are randomly placed in a 4x4 grid and questions
like ’is the blue object circle’ or ’what is the color of nearest object to blue’ should be answered. To formulate this problem
via ILP, instead of using grid coordinates (vertical and horizontal positions as in past experiments) we consider a ﬂat index
as can be seen in Table 2. As such, we will have 16 positional constants of type Tp to represent grid positions as well as 6
constants of type Tc to represent the color of each object. In the original problem in (Santoro et al., 2017), a question is
represented as binary vector of length 11. The ﬁrst 6 bits represent the one-hot representation of the color of the object in
question. The next 5 bits represent one of the ﬁve possible types of questions, i.e., ’is it a circle or a rectangle’ and ’the
color of the nearest object?’ for example.

We deﬁne a nullary predicate for each of 11 possible bits in the question via predicates isQ0(),. . . ,isQ10(). Similar to to
the original paper we use 4 layers of CNNs with relu activation function and batch normalization to obtain a feature map
of size 4x4X24. We use kernel size of 5 and strides of [3,3,2,2] for each of the layers. By applying fully connected layers to
the feature map, we learn the groundings of predicates color(X,Y,Z), isObject(X,Y) and isCircle(X,Y). We
deﬁne some auxiliary predicates as shown in Table 5. For each of the 10 possible answers, we create one nullary predicate.
The vector of size 10 that is created by the the groundings of these 10 predicates (i.e., isAnswer0(), . . . ) are then used
to calculate the cross entropy loss between the network output and the provided ground truth. We need to mention that
in the deﬁnition of the auxiliary predicate qa(X), we exploit our prior knowledge regarding the fact that the ﬁrst 6 bits
of the question vector correspond to the colors of the object. Without introducing this predicate, the convergence of our
model is signiﬁcantly slower. For example, while by incorporating this predicate we need around 30000 training samples for
convergence, it would take than 200000 training samples without this predicate.

D. Asterix Experiment

In Asterix game (an Atari 2600 game), the player controls a unit called Asterix to collect as many objects as possible while
avoiding deadly predators. Even though it is a rather simple game, many standard RL algorithms score signiﬁcantly below
the human level. for example, as reported in (Hessel et al., 2017), DQN and A3C achieve the scores of 3170 and 22140 on
average, respectively even after processing hundreds of millions of frames. Here, our goal is not to outperform the current
approaches. Instead, we demonstrate that by using a very simple language for describing the problem, an agent can achieve
scores in the range of 30K-40K with only a few thousands of training scenes. For this game we consider the active part of
the scene as a 8x12 grid. For simplicity, we consider only 4 types of objects; agent, left to right moving predator, right to

Figure 12. Score during training in Astreix experiment

left moving predator and ﬁnally the food objects. The dimension of the input image is 128x144. We use 4 convolutional
layers with strides of [(2,3),(2,1),(2,2),(2,2)] and kernel size of 5 to generate a feature map of size 8x12x48. By applying 4
fully connected layers with softmax activation function we learn the groundings of the predicates corresponding to the
four types of objects, i.e., O1(X,Y),. . . ,O4(X,Y). The complete list of predicates for this experiment is listed in Table
6. We learn 5 nullary predicates corresponding to the 5 direction of moves (i.e., no move, left,right,up,down) and use the
same policy gradient learning approach as before. The notable auxiliary predicates in the chosen language are the 4 helper
predicates that deﬁne bad moves. For example, badMoveUp() states that an upward move is bad when there is a predator
in the close neighborhood of the agent and in the top row. Similarly, badMoveLeft() is deﬁned to state that when a
predator is coming from left side of an agent, it is a bad idea to move left.

However, given the complexity of the scene and the existence of some overlappings between the objects, learning the
representation of the state is not as easy as the previously explored experiments. To help the agent learn the presumed grid
presentation, we provide a set of labeled scene (a semi-supervised approach) and we penalize the objective function using
the loss that is calculated between these labels and the learned representation. Fig. 12 shows the learning curve for two
cases of the using 20 and 50 randomly generated labeled scenes. In the case of 50 provided labels, the agent ﬁnally learns to
score around 30-40K each episodes. Please note that we did not include all the possible objects that are encountered during
later stages of the game and we use a simplistic representation and language just to to demonstrate the application of RRL
framework in more complex scenarios.

Table 3. ILP deﬁnition of the BoxWorld

Constants Description
Tb
Tp

box constants
coordinate position constants

Values
{a, b, c, d, ﬂoor}
{0, 1, 2, . . . , n}

Predicate

Variables

Deﬁnition

posH(X,Y)
posV(X,Y)

isFloor(X)
isBlue(X)
isV1(X)
inc(X,Y)
lt(X,Y)

X(Tb), Y(Tp)
X(Tb), Y(Tp)

X(Tb)
X(Tb)
X(Tp)
X(Tp), Y(Tp)
X(Tp), Y(Tp)

learned from Image
learned from Image

isFloor(ﬂoor)
isBlue(a)
isV1(1)
inc(0,1), inc(1,2), . . . , inc(n-1,n)
lt(0,1), lt(0,2), . . . , lt(n-1,n)

X(Tb), Y(Tb)
same(X,Y)
X(Tb), Y(Tb), Z(Tp)
sameH(X,Y)
X(Tb), Y(Tb), Z(Tp)
sameV(X,Y)
X(Tb), Y(Tb), Z(Tp), T(Tp)
above(X,Y)
X(Tb), Y(Tb), Z(Tp), T(Tp)
below(X,Y)
X(Tb), Y(Tb), Z(Tp),T(Tp)
on(X,Y)
X(Tb), Y(Tb)
isCovered(X)
moveable(X,Y) X(Tb), Y(Tb)

same(a,a), same(b,b), . . . , same(ﬂoor,ﬂoor)
posH(X,Z), posH(Y,Z)
posV(X,Z), posV(Y,Z)
sameH(X,Y), posV(X,Z), posV(Y,T), lt(T,Z)
sameH(X,Y), posV(X,Z), posV(Y,T), lt(Z,T)
sameH(X,Y), posV(X,Z), posV(Y,T), inc(T,Z)
On(Y,X), ¬isFloor(X)
¬isCovered(X), ¬isCovered(Y), ¬same(A,B), ¬isﬂoor(X), ¬on(X,Y)

move(X,Y)

X(Tb), Y(Tb), Z(Tp),T(Tp)

Action predicate that is learned via policy gradient

Table 4. ILP deﬁnition of the GridWorld
Values
{0,1,2,. . . ,11}
{0,1,2,. . . ,11}
{0,1,2,. . . ,9}

vertical coordinates
horizontal coordinates
cell color code

Constants Description
Tv
Th
Tc

Predicate

Variables

Deﬁnition

color(X,Y,Z)
hasKey(X)

X(Tv), Y(Th), Z(Tc)
X(Tc)

learned from Image
Learned from Image

incH(X,Y)
isC0(X)
isC1(X)
isC2(X)

X(Th)
X(Tc)
X(Tc)
X(Tc)

incH(0,1),. . . ,incH(10,11)
isC0(0)
isC1(1)
isC2(2)

X(Tv), X(Th), Z(Tc)
isBK(X,Y)
isAgent(X,Y) X(Tv), X(Th), Z(Tc)
X(Tv), X(Th), Z(Tc)
isGem(X,Y)
X(Tv), X(Th)
isItem(X,Y)
X(Tv), X(Th), Z(Th)
locked(X)
X(Tv), X(Th), Z(Th)
isLock(X)

color(X,Y,Z), isC0(Z)
color(X,Y,Z), isC1(Z)
color(X,Y,Z), isC2(Z)
¬ isBK(X,Y), ¬ isAgent(X,Y),
isItem(X,Y), isItem(X,Z), incH(Y,Z)
isItem(X,Y), isItem(X,Z), incH(Z,Y)

move(X,Y)

X(Tv), Y(Th), Z(Tc) Action predicate that is learned via policy gradient

Table 5. ILP deﬁnition of the relational reasoning task

Constants Description
Tp
Tc

Flat position of items in a 4 by 4 grid
color of an item

Values
{0,1,2,. . . ,15}
{0,1,2,. . . ,5}

Predicate

Variables

Deﬁnition

isQ0()
. . .
isQ10()
color(X,Y)
isCircle(X,Y)
isObject(X,Y)

X(Tp), Y(Tc)
X(Tp)
X(Tp)

Given as a binary value
. . .
Given as a binary value
Learned from Image
Learned from Image
Learned from Image

equal(X,Y)

X(Tp), Y(Tp)

equal(0,0),. . . ,incH(15,15)

lt(X,Y)

left(X)
right(X)
top(X)
bottom(X)

X(Tp), Y(Tp), Z(Tp)

true if distance between grid cells corresponding to X and Y
is less than distance between X and Z (see Table 2)

X(Tp)
X(Tp)
X(Tp)
X(Tp)

left(0),left(1),. . . ,left(12),left(13)
right(2),right(3),. . . ,right(14),right(15)
top(0),left(1),. . . ,left(6),left(7)
bottom(8),left(9),. . . ,left(14),left(15)

X(Tp), X(Tp), Z(Tp)
closer(X,Y,Z)
X(Tp), X(Tp), Z(Tp)
farther(X,Y,Z)
X(Tp), X(Tp), Z(Tp)
notClosest(X,Y)
notFarthest(X,Y) X(Tp), X(Tp), Z(Tp)

isObject(X), isObject(Y), isObject(Z), lt(X,Y,Z)
isObject(X), isObject(Y), isObject(Z), gt(X,Y,Z)
closer(X,Z,Y)
farther(X,Z,Y)

qa(X)

X(Tp), Y(Tc)

isQ0(), color(X,Y), isC0(Y)
isQ1(), color(X,Y), isC1(Y)
isQ2(), color(X,Y), isC2(Y)
isQ3(), color(X,Y), isC3(Y)
isQ4(), color(X,Y), isC4(Y)
isQ5(), color(X,Y), isC5(Y)

isAnswer0()
. . .
isAnswer9()

X(Tp), Y(Tp)
. . .
X(Tp), Y(Tp)

The learned hypothesis : Is answer is 0
. . .
The learned hypothesis : Is answer is 9

Table 6. ILP deﬁnition of the Asterix experiment

Constants Description
Tv
Th

vertical coordinates
horizontal coordinates

Values
{0,1,2,. . . ,8}
{0,1,2,. . . ,12}

Predicate

O1(X,Y)
O2(X,Y)
O3(X,Y)
O4(X,Y)

isV0(X)
isV11(X)
isH0(X)
isH7(X)
incV(X,Y)
ltH(X,Y)
closeH(X,Y)

agentH(X)
agentV(X)

Variables

X(Tv), Y(Th),
X(Tv), Y(Th),
X(Tv), Y(Th),
X(Tv), Y(Th),

X(Tv)
X(Tv)
X(Th)
X(Th)
X(Tv), X(Tv)
X(Th), X(Th)
X(Th), Y(Th)

X(Tv), Y(Th)
X(Th), Y(Tv)

Deﬁnition

learned from Image : objects of type agent
learned from Image : objects of type L2R predator
learned from Image : objects of type R2L predator
learned from Image : objects of type food

isV(0)
isV11(11)
isH0(0)
isH7(7)
incV(0,1), . . . ,incV(6,7)
ltH(0,1),ltH(0,2), . . . ,ltH(11,12)
true if |X −Y | ≤ 2

O1(X,X)
O1(Y,X)

predator(X,Y)

X(Tv), Y(Th)

X(Tv)
agent()
X(Tv), Y(Th), Z(Tv), T(Th)
badMoveUp()
badMoveDown() X(Tv), Y(Th), Z(Tv), T(Th)
X(Tv), Y(Th), Z(Th)
badMoveLeft()
badMoveRight() X(Tv), Y(Th), Z(Th)

O2(X,X)
O3(X,Y)
agentV(X)
O1(X,Y), predator(Z,T), incV(Z,X), closeH(Y,T)
O1(X,Y), predator(Z,T), incV(X,Z), closeH(Y,T)
O1(X,Y), O2(X,Z), ltH(Z,Y), closeH(Z,Y)
O1(X,Y), O3(X,Z), ltH(Y,Z), closeH(Z,Y)

moveUp()
moveDown()
moveLeft()
moveRight()
moveNOOP()

X(Tv), Y(Th), Z(Tv), T(Th), Action predicate that is learned via policy gradient
X(Tv), Y(Th), Z(Tv), T(Th), Action predicate that is learned via policy gradient
X(Tv), Y(Th), Z(Tv), T(Th), Action predicate that is learned via policy gradient
X(Tv), Y(Th), Z(Tv), T(Th), Action predicate that is learned via policy gradient
X(Tv), Y(Th), Z(Tv), T(Th), Action predicate that is learned via policy gradient

