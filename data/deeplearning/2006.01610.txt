0
2
0
2

n
u
J

2

]
I

A
.
s
c
[

1
v
0
1
6
1
0
.
6
0
0
2
:
v
i
X
r
a

Combining Reinforcement Learning
and Constraint Programming
for Combinatorial Optimization

Quentin Cappart1,2, Thierry Moisan2, Louis-Martin Rousseau1,
Isabeau Prémont-Schwarz2, and Andre Cire3
1 Ecole Polytechnique de Montréal, Montreal, Canada
2 Element AI, Montreal, Canada
3 University of Toronto Scarborough, Toronto, Canada
{quentin.cappart,louis-martin.rousseau}@polymtl.ca
thierry.moisan@elementai.com
isabeau@cryptolab.net
andre.cire@rotman.utoronto.ca

Abstract

Combinatorial optimization has found applications in numerous ﬁelds, from
aerospace to transportation planning and economics. The goal is to ﬁnd an optimal
solution among a ﬁnite set of possibilities. The well-known challenge one faces
with combinatorial optimization is the state-space explosion problem: the number
of possibilities grows exponentially with the problem size, which makes solving
intractable for large problems. In the last years, deep reinforcement learning (DRL)
has shown its promise for designing good heuristics dedicated to solve NP-hard
combinatorial optimization problems. However, current approaches have two short-
comings: (1) they mainly focus on the standard travelling salesman problem and
they cannot be easily extended to other problems, and (2) they only provide an
approximate solution with no systematic ways to improve it or to prove optimality.
In another context, constraint programming (CP) is a generic tool to solve com-
binatorial optimization problems. Based on a complete search procedure, it will
always ﬁnd the optimal solution if we allow an execution time large enough. A
critical design choice, that makes CP non-trivial to use in practice, is the branching
decision, directing how the search space is explored. In this work, we propose a
general and hybrid approach, based on DRL and CP, for solving combinatorial opti-
mization problems. The core of our approach is based on a dynamic programming
formulation, that acts as a bridge between both techniques. We experimentally
show that our solver is efﬁcient to solve two challenging problems: the traveling
salesman problem with time windows, and the 4-moments portfolio optimization
problem. Results obtained show that the framework introduced outperforms the
stand-alone RL and CP solutions, while being competitive with industrial solvers.

1

Introduction

The design of efﬁcient algorithms for solving NP-hard problems, such as combinatorial optimization
problems (COPs), has long been an active ﬁeld of research [63]. Broadly speaking, there exist two
main families of approaches for solving COPs, each of them having pros and cons. On the one hand,
exact algorithms are based on a complete and clever enumeration of the solutions space [35, 48]. Such
algorithms will eventually ﬁnd the optimal solution, but they may be prohibitive for solving large
instances because of the exponential increase of the execution time. That being said, well-designed

Preprint. Under review.

 
 
 
 
 
 
exact algorithms can nevertheless be used to obtain sub-optimal solutions by interrupting the search
before its termination. This ﬂexibility makes exact methods appealing and practical, and as such
they constitute the core of modern optimization solvers as CPLEX [17], Gurobi [41], or Gecode [55].
It is the case of constraint programming (CP) [48], which has the additional asset to be a generic
tool that can be used to solve a large variety of COPs, whereas mixed integer programming (MIP)
[10] solvers only deal with linear problems and limited non-linear cases. A critical design choice
in CP is the branching strategy, i.e., directing how the search space must be explored. Naturally,
well-designed heuristics are more likely to discover promising solutions, whereas bad heuristics may
bring the search into a fruitless subpart of the solution space. In general, the choice of an appropriate
branching strategy is non-trivial and their design is a hot topic in the CP community [42, 19, 34].

On the other hand, heuristic algorithms [1, 21] are incomplete methods that can compute solutions
efﬁciently, but are not able to prove the optimality of a solution. They also often require substantial
problem-speciﬁc knowledge for building them. In the last years, deep reinforcement learning (DRL)
[52, 3] has shown its promise to obtain high-quality approximate solutions to some NP-hard COPs
[8, 32, 18, 33]. Once a model has been trained, the execution time is typically negligible in practice.
The good results obtained suggest that DRL is a promising new tool for ﬁnding efﬁciently good
approximate solutions to NP-hard problems, provided that (1) we know the distribution of problem
instances and (2) that we have enough instances sampled from this distribution for training the model.
Nonetheless, current methods have shortcomings. Firstly, they are mainly dedicated to solve a speciﬁc
problem, as the travelling salesman problem (TSP), with the noteworthy exception of Khalil et al.
[32] that tackle three other graph-based problems, and of Kool et al. [33] that target routing problems.
Secondly, they are only designed to act as a constructive heuristic, and come with no systematic ways
to improve the solutions obtained, unlike complete methods, such as CP.

As both exact approaches and learning-based heuristics have strengths and weaknesses, a natural
question arises: How can we leverage these strengths together in order to build a better tool to solve
combinatorial optimization problems ? In this work, we show that it can be successfully done by the
combination of reinforcement learning and constraint programming, using dynamic programming
as a bridge between both techniques. Dynamic programming (DP) [7], which has found successful
applications in many ﬁelds [23, 56, 54, 22], is an important technique for modelling COPs. In its
simplest form, DP consists in breaking a problem into sub-problems that are linked together through
a recursive formulation (i.e., the well-known Bellman equation). The main issue with exact DP is the
so-called curse of dimensionality: the number of generated sub-problems grows exponentially, to the
point that it becomes infeasible to store all of them in memory.

This paper proposes a generic and complete solver, based on DRL and CP, in order to solve COPs
that can be modelled using DP. To the best of our knowledge, it is the ﬁrst work that proposes to
embed a learned heuristic directly inside a CP solver. Our detailed contributions are as follows: (1)
A new encoding able to express a DP model of a COP into a RL environment and a CP model; (2)
The use of two standard RL training procedures, deep Q-learning and proximal policy optimization,
for learning an appropriate CP branching strategy. The training is done using randomly generated
instances sampled from a similar distribution to those we want to solve; (3) The integration of the
learned branching strategies on three CP search strategies, namely branch-and-bound, iterative limited
discrepancy search and restart based search; (4) Promising results on two challenging COPs, namely
the travelling salesman problem with time windows, and the 4-moments portfolio optimization; (5)
The open-source release of our code and models, in order to ease the future research in this ﬁeld1.

In general, as there are no underlying hypothesis such as linearity or convexity, a DP cannot be
trivially encoded and solved by standard integer programming techniques [11]. It is one of the reasons
that drove us to consider CP for the encoding. The next section presents the hybrid solving process
that we designed. Then, experiments on the two case studies are carried out. Finally, a discussion on
the current limitations of the approach and the next research opportunities are proposed.

2 A Unifying Representation Combining Learning and Searching

Because of the state-space explosion, solving NP-hard COPs remains a challenge. In this paper, we
propose a generic and complete solver, based on DRL and CP, in order to solve COPs that can be
modelled using DP. This section describes the complete architecture of the framework we propose. A

1https://github.com/qcappart/hybrid-cp-rl-solver

2

high-level picture of the architecture is shown in Figure 1. It is divided into three parts: the learning
phase, the solving phase and the unifying representation, acting as a bridge between the two phases.
Each part contains several components. Green blocks and arrows represent the original contributions
of this work and blue blocks corresponds to known algorithms that we adapted for our framework.

Figure 1: Overview of our framework for solving COPs.

2.1 Dynamic Programming Model

Dynamic programming (DP) [7] is a technique combining both mathematical modeling and computer
programming for solving complex optimization problems, such as NP-hard problems. In its simplest
form, it consists in breaking a problem into sub-problems and to link them through a recursive
formulation. The initial problem is then solved recursively, and the optimal values of the decision
variables are recovered successively by tracking back the information already computed. Let us
consider a general COP Q : {max f (x) : x ∈ X ⊆ Zn}, where xi with i ∈ n are n discrete variables
that must be assigned in order to maximize a function f (x). In the DP terminology, the decision
variables of Q are referred to as the controls (xi). They take value from their domain D(xi), and
enforce a transition (T : S × X → S) from a state (si) to another one (si+1) where S is the set
of states. The initial state (s1) is known and a transition is done at each stage (i ∈ {1, . . . , n})
until all the variables have been assigned. Besides, a reward (R : S × X → R) is induced after
each transition. Finally, a DP model can also contain validity conditions (V : S × X → {0, 1})
and dominance rules (P : S × X → {0, 1}) that restrict the set of feasible actions. The difference
between both is that validity conditions are mandatory to ensure the correctness of the DP model
(V (s, x) = 0 ⇔ T (s, x) = ⊥) whereas the dominance rules are only used for efﬁciency purposes
(P (s, x) = 0 ⇒ T (s, x) = ⊥), where ⇔, ⇒, and ⊥ represent the equivalence, the implication,
and the unfeasible state, respectively. A DP model for a COP can then be modelled as a tuple
(cid:104)S, X, T, R, V, P (cid:105). The problem can be solved recursively using Bellman Equation, where gi : X →
R is a state-value function representing the optimal reward of being at state si at stage i:

gi(si) = max

(cid:110)

R(si, xi) + gi+1

(cid:0)T (si, xi)(cid:1)(cid:111)

∀i ∈ {1..n} s.t. T (si, xi) (cid:54)= ⊥

(1)

The reward is equal to zero for the ﬁnal state (gn+1(sn+1) = 0) and is backtracked until g1(s1) has
been computed. This last value gives the optimal cost of Q. Then, by tracing the values assigned to the
variables xi, the optimal solution is recovered. Unfortunately, DP suffers from the well-known curse
of dimensionality, which prevents its use when dealing with problems involving large state/control
spaces. A partial solution to this problem is to prune dominated actions (P (s, x) = 0). An action is
dominated if it is valid according to the recursive formulation, but is (1) either strictly worse than
another action, or (2) it cannot lead to a feasible solution. In practice, pruning such dominated actions
can have a huge impact on the size of the search space, but identifying them is not trivial as assessing
those two conditions precisely is problem-dependent. Besides, even after pruning the dominated
actions, the size of the state-action space may still be too large to be completely explored in practice.

3

Learning phaseUnifying representationSolving phaseTraining instances(randomly generated)Evaluated instancesCombinatorial optimization problemDynamic programming ModelValue-selection heuristicReinforcement learningConstraint programmingEnvironmentAgentModelSearchDominance pruningrulesSolution2.2 RL Encoding

An introduction to reinforcement learning is proposed in Appendix A. Note that all the sets used to
deﬁne an RL environment are written using a larger size font. Encoding the DP formulation into
a RL environment requires to deﬁne, adequately, the set of states, the set of actions, the transition
function, and the reward function, as the tuple (cid:104)S, A, T, R(cid:105) from the DP model (cid:104)S, X, T, R, V, P (cid:105) and
a speciﬁc instance Qp of the COP that we are considering. The initial state of the RL environment
corresponds to the ﬁrst stage of the DP model, where no variable has been assigned yet.

State For each stage i of the DP model, we deﬁne the RL state si as the pair (Qp, si), where si ∈ S
is the DP state at the same stage i, and Qp is the problem instance we are considering. Note that
the second part of the state (si) is dynamic, as it depends on the current stage i in the DP model, or
similarly, to the current time-step of the RL episode, whereas the ﬁrst part (Qp) is static as it remains
the same for the whole episode. In practice, each state is embedded into a tensor of features, as it
serves as input of a neural network.

Action Given a state si from the DP model at stage i and its control xi, an action ai ∈ A at a state
si has a one-to-one relationship with the control xi. The action ai can be done if and only if xi is
valid under the DP model. The idea is to allow only actions that are consistent with regards to the DP
model, the validity conditions, and the eventual dominance conditions. Formally, the set of feasible
actions A at stage i are as follows: Ai = (cid:8)vi

(cid:12)
(cid:12) vi ∈ D(xi) ∧ V (si, vi) = 1 ∧ P (si, vi) = 1(cid:9)

Transition The RL transition T gives the state si+1 from si and ai in the same way as the transition
function T of the DP model gives a state si+1 from a previous state si and a control value vi. Formally,
we have the deterministic transition: si+1 = T(si, ai) = (cid:0)Qp, T (si, ai)(cid:1) = (cid:0)Qp, T (si, vi)(cid:1).

Reward An initial idea for designing the RL reward function R is to use the reward function R of
the DP model using the current state si and the action ai that has been selected. However, performing
a sequence of actions in a DP subject to validity conditions can lead to a state with no solutions,
which must be avoided. Such a situation happens when a state with no action is reached whereas at
least one control x ∈ X has not been assigned to a value v. Finding ﬁrst a feasible solution must then
be prioritized over maximizing the DP reward and is not considered with this simple form of the RL
reward. Based on this, two properties must be satisﬁed in order to ensure that the reward will drive
the RL agent to the optimal solution of the COP: (1) the reward collected through an episode e1 must
be lesser than the reward of an episode e2 if the COP solution of e1 is worse than the one obtained
with e2, and (2) the total reward collected through an episode giving an unfeasible solution must be
lesser than the reward of any episode giving a feasible solution. By doing so, we ensure that the RL
agent has incentive to ﬁnd, ﬁrst, feasible solutions, and, then, ﬁnding the best ones. The reward we
designed is as follows : R(s, a) = ρ × (cid:0)1 + |UB(Qp)| + R(s, a)(cid:1); where UB(Qp) corresponds to an
upper bound of the objective value that can be reached for the COP Qp. The term 1 + |UB(Qp)| is a
constant factor that gives a strict upper bound on the reward of any solution of the DP and drives the
agent to progress into a feasible solution ﬁrst. The absolute value ensures that the term is positive and
is used to negate the effect of negative rewards that may lead the agent to stop the episode as soon
as possible. The second term R(s, a) forces then the agent to ﬁnd the best feasible solution. Finally,
a scaling factor ρ ∈ R can also be added in order to compress the space of rewards into a smaller
interval value near zero. Note that for DP models having only feasible solutions, the ﬁrst term can be
omitted.

2.3 Learning Algorithm

We implemented two different agents, one based on a value-based method (DQN) and a second one
based on policy gradient (PPO). In both cases, the agent is used to parametrize the weight vector
(w) of a neural network giving either the Q-values (DQN), or the policy probabilities (PPO). The
training is done using randomly generated instances sampled from a similar distribution to those we
want to solve. It is important to mention that this learning procedure makes the assumption that we
have a generator able to create random instances (Qp) that follows the same distribution that the ones
we want to tackle, or a sufﬁcient number of similar instances from past data. Such an assumption is
common in the vast majority of works tackling NP-hard problems using ML [32, 33, 15].

4

2.4 Neural Network Architecture

In order to ensure the genericity and the efﬁciency of the framework, we have two requirements for
designing the neural network architecture: (1) be able to handle instances of the same COPs, but that
have a different number of variables (i.e., able to operate on non-ﬁxed dimensional feature vectors)
and (2) be invariant to input permutations. In other words, encoding variables x1, x2, and x3 should
produce the same prediction as encoding x3, x1, and x2. A ﬁrst option is to embed the variables into
a set transformer architecture [37], that ensures these two requirements. Besides, many COPs also
have a natural graph structure that can be exploited. For such a reason, we also considered another
embedding based on graph attention network (GAT) [59]. The embedding, either obtained using
GAT or set transformer, can then be used as an input of a feed-forward network to get a prediction.
Case studies will show a practical application of both architectures. For the DQN network, the
dimension of the last layer output corresponds to the total number of actions for the COP and output
an estimation of the Q-values for each of them. The output is then masked in order to remove the
unfeasible actions. Concerning PPO, distinct networks for the actor and the critic are built. The last
layer on the critic output only a single value. Concerning the actor, it is similar as the DQN case but a
softmax selection is used after the last layer in order to obtain the probability to select each action.

2.5 CP Encoding

An introduction to constraint programming is proposed in Appendix B. Note that the teletype font
is used to refer to CP notations. This section describes how a DP formulation can be encoded in a CP
model. Modeling a problem using CP consists in deﬁning the tuple (cid:104)X, D, C, O(cid:105) where X is the set of
variables, D(X) is the set of domains, C is the set of constraints, and O is the objective function. Let us
consider the DP formulation (cid:104)S, X, T, R, V, P (cid:105) with also n the number of stages.

Variables and domains We make a distinction between the decision variables, on which the search
is performed, and the auxiliary variables that are linked to the decision variables, but that are not
branched on during the search. The encoding involves two variables per stage: (1) xs
i ∈ X is an
auxiliary variable representing the current state at stage i whereas (2) xa
i ∈ X is a decision variable
representing the action done at this state, similarly to the regular decomposition [45]. Besides, a
last auxiliary variable is considered for the stage n + 1, which represents the ﬁnal state of the system.
In the optimal solution, the variables thus indicate the best state that can be reached at each stage, and
the best action to select as well.

Constraints The constraints of our encoding have two purposes. Firstly, they must ensure the
consistency of the DP formulation. It is done (1) by setting the initial state to a value (e.g., (cid:15)), (2)
by linking the state of each stage to the previous one through the transition function (T ), and ﬁnally
(3) by enforcing each transition to be valid, in the sense that they can only generate a feasible state
of the system. Secondly, other constraints are added in order to remove dominated actions and the
subsequent states. In the CP terminology, such constraints are called redundant constraint, they
do not change the semantic of the model, but speed-up the search. The constraints inferred by our
encoding are as follows, where validityCondition and dominanceCondition are both Boolean
functions detecting non-valid transitions and dominated actions, respectively.

xs
1 = (cid:15)
i , xa
i+1 = T (xs
xs
i )
validityCondition(xs
dominanceCondition(xs

i , xa
i )
i , xa
i )

(Setting initial state)
∀i ∈ {1, . . . , n}
(Enforcing transitions)
∀i ∈ {1, . . . , n} (Keeping valid transitions)
∀i ∈ {1, . . . , n} (Pruning dominated states)

Objective function The goal is to maximize the accumulated sum of rewards generated through
i )(cid:1). Note that the
the transition (R : S × A → R) during the n stages: maxxa
i , xa
optimization and branching selection is done only on the decision variables (xa).

i=1 R(xs

(cid:0) (cid:80)n

2.6 Search Strategy

From the same DP formulation, we are able to (1) build a RL environment in order to learn the best
actions to perform, and (2) state a CP model of the same problem. This consistency is at the heart
of the framework. This section shows how the knowledge learned during the training phase can be

5

transferred into the CP search. We considered three standard CP speciﬁc search strategy: depth-ﬁrst
branch-and-bound search (BaB), and iterative limited discrepancy search (ILDS), that are able to
leverage knowledge learned with a value-based method as DQN, and restart based search (RBS),
working together with policy gradient methods. The remaining of this section presents how to plug
a model learned with DQN inside the BaB-search of a CP solver. The description of the two other
contributions (ILDS with DQN, and RBS with PPO) are available in Appendices C and D.

2.6.1 Depth-First Branch-and-Bound Search with DQN

This search works in a depth-ﬁrst fashion. When a feasible solution has been found, a new constraint
ensuring that the next solution has to be better than the current one is added. In case of an unfeasible
solution due to an empty domain reached, the search is backtracked to the previous decision. With
this procedure, and provided that the whole search space has been explored, the last solution found
is then proven to be optimal. This search requires a good heuristic for the value-selection. This
can be achieved by a value-based RL agent, such as DQN. After the training, the agent gives a
parametrized state-action value function ˆQ(s, a, w), and a greedy policy can be used for the value-
selection heuristic, which is intended to be of a high, albeit non-optimal, quality. The variable
ordering must follow the same order as the DP model in order to keep the consistency with both
encoding. As highlighted in other works [15], an appropriate variable ordering has an important
impact when solving DPs. However, such an analysis goes beyond the scope of this work.

v := peek(K, s)

Algorithm 1: BaB-DQN Search Procedure.
(cid:46) Pre: Qp is a COP having a DP formulation.
(cid:46) Pre: w is a trained weight vector.
(cid:104)X, D, C, O(cid:105) := CPEncoding(Qp)
K = ∅
Ψ := BaB-search((cid:104)X, D, C, O(cid:105))
while Ψ is not completed do
s := encodeStateRL(Ψ)
x := takeFirstNonAssignedVar(X)
if s ∈ K then

The complete search procedure (BaB-DQN) is
presented in Algorithm 1, taking as input a COP
Qp, and a pre-trained model with the weight vec-
tor w. First, the optimization problem Qp in en-
coded into a CP model. Then, a new BaB-search
Ψ is initialized and executed on the generated
CP model. Until the search is not completed,
a RL state s is obtained from the current CP
state (encodeStateRL). The ﬁrst non-assigned
variable xi of the DP is selected and is assigned
to the value maximizing the state-action value
function ˆQ(s, a, w). All the search mechanisms
inherent of a CP solver but not related to our
contribution (propagation, backtracking, etc.),
are abstracted in the branchAndUpdate func-
tion. Finally, the best solution found during the
search is returned. We enriched this procedure
with a cache mechanism (K). During the search,
it happens that similar states are reached more
than once [16]. In order to avoid recomputing
the Q-values, one can store the Q-values related
to a state already computed and reuse them if
the state is reached again. In the worst-case, all the action-value combinations have to be tested. This
gives the upper bound O(dm), where m is the number of actions of the DP model and d the maximal
domain size. Note that this bound is standard in a CP solver. As the algorithm is based on DFS, the
worst-case space complexity is O(d × m + |K|), where |K| is the cache size.

end
K := K ∪ {(cid:104)s, v(cid:105)}
branchAndUpdate(Ψ, x, v)

end
return bestSolution(Ψ)

v := argmaxu∈D(x)

ˆQ(s, u, w)

else

3 Experimental Results

The goal of the experiments is to evaluate the efﬁciency of the framework for computing solutions
of challenging COPs having a DP formulation. To do so, comparisons of our three learning-based
search procedures (BaB-DQN, ILDS-DQN, RBS-PPO) with a standard CP formulation (CP-model),
stand-alone RL algorithms (DQN, PPO), and industrial solvers are performed. Two NP-hard problems
are considered in the main manuscript: the travelling salesman problem with time windows (TSPTW),
involving non-linear constraints, and the 4-moments portfolio optimization problem (PORT), which
has a non-linear objective. In order to ease the future research in this ﬁeld and to ensure reproducibility,
the implementation, the models, the results, and the hyper-parameters used are released with the
permissive MIT open-source license. Algorithms used for training have been implemented in

6

Python and Pytorch [43] is used for designing the neural networks. Library DGL [61] is used for
implementing graph embedding, and SetTransformer [37] for set embedding. The CP solver used
is Gecode [55], which has the beneﬁt to be open-source and to offer a lot of freedom for designing
new search procedures. As Gecode is implemented in C++, an operability interface with Python
code is required. It is done using Pybind11 [29]. Training time is limited to 48 hours, memory
consumption to 32 GB and 1 GPU (Tesla V100-SXM2-32GB) is used per model. A new model
is recorded after each 100 episodes of the RL algorithm and the model achieving the best average
reward on a validation set of 100 instances generated in the same way as for the training is selected.
The ﬁnal evaluation is done on 100 other instances (still randomly generated in the same manner)
using Intel Xeon E5-2650 CPU with 32GB of RAM and a time limit of 60 minutes.

3.1 Travelling Salesman Problem with Time Windows (TSPTW)

Detailed information about this case study and the baselines used for comparison is proposed in
Appendix E. In short, OR-Tools is an industrial solver developed by Google, PPO uses a beam-
search decoding of width 64, and CP-nearest solves the DP formulation with CP, but without
the learning part. A nearest insertion heuristic is used for the value-selection instead. Results
are summarized in Table 1. First of all, we can observe that OR-Tools, CP-model, and DQN are
signiﬁcantly outperformed by the hybrid approaches. Good results are nevertheless achieved by
CP-nearest, and PPO. We observe that the former is better to prove optimality, whereas the latter is
better to discover feasible solutions. However, when the size of instances increases, both methods
have more difﬁculties to solve the problem and are also outperformed by the hybrid methods, which
are both efﬁcient to ﬁnd solutions and to prove optimality. Among the hybrid approaches, we observe
that DQN-based searches give the best results, both in ﬁnding solutions and in proving optimality.

We also note that caching the predictions is useful. Indeed, the learned heuristics are costly to use,
as the execution time to ﬁnish the search is larger when the cache is disabled. For comparison, the
average execution time of a value-selection without caching is 34 milliseconds for BaB-DQN (100
cities), and goes down to 0.16 milliseconds when caching is enabled. For CP-nearest, the average
time is 0.004 milliseconds. It is interesting to see that, even being signiﬁcantly slower than the
heuristic, the hybrid approach is able to give the best results.

Table 1: Results for TSPTW. Methods with (cid:63) indicate that caching is used, Success reports the
number of instances where at least a solution has been found (among 100), Opt. reports the number of
instances where the optimality has been proven (among 100), and Time reports the average execution
time to complete the search (in minutes, and only including the instances where the search has been
completed; when the search has been completed for no instance t.o. (timeout) is indicated.
20 cities

Approaches

100 cities

50 cities

Type

Name

Success Opt. Time

Success Opt. Time

Success Opt. Time

Constraint programming

Reinforcement learning

Hybrid (no cache)

Hybrid (with cache)

OR-Tools
CP-model
CP-nearest

DQN
PPO

BaB-DQN
ILDS-DQN
RBS-PPO
BaB-DQN(cid:63)
ILDS-DQN(cid:63)
RBS-PPO(cid:63)

100
100
100

100
100

100
100
100

100
100
100

0
100
100

0
0

100
100
100

100
100
100

< 1
< 1
< 1

< 1
< 1

< 1
< 1
< 1

< 1
< 1
< 1

0
0
99

0
100

100
100
100

100
100
100

0
0
99

0
0

99
100
80

100
100
99

t.o.
t.o.
6

< 1
5

2
2
12

< 1
1
2

0
0
0

0
21

100
100
100

100
100
100

0
0
0

0
0

52
53
0

91
90
11

t.o.
t.o.
t.o.

< 1
46

20
39
t.o.

15
15
32

3.2

4-Moments Portfolio Optimization (PORT)

Detailed information about this case study is proposed in Appendix F. In short, Knitro and APOPT
are two general non-linear solvers. Given that the problem is non-convex, these solvers are not able
to prove optimality as they may be blocked in local optima. The results are summarized in Table
2. Let us ﬁrst consider the continuous case. For the smallest instances, we observe that BaB-DQN(cid:63),
ILDS-DQN(cid:63), and CP-model achieve the best results, although only BaB-DQN(cid:63) has been able to prove

7

optimality for all the instances. For larger instances, the non-linear solvers achieve the best results,
but are nevertheless closely followed by RBS-PPO(cid:63). When the coefﬁcients of variables are ﬂoored
(discrete case), the objective function is not continuous anymore, making the problem harder for
non-linear solvers, which often exploit information from derivatives for the solving process. Such
a variant is not supported by APOPT. Interestingly, the hybrid approaches do not suffer from this
limitation, as no assumption on the DP formulation is done beforehand. Indeed, ILDS-DQN(cid:63) and
BaB-DQN(cid:63) achieve the best results for the smallest instances and RBS-PPO(cid:63) for the larger ones.

Table 2: Results for PORT. Best results are highlighted, Sol. reports the best average objective proﬁt
reached, Opt. reports the number of instances where the optimality has been proven (among 100).

Approaches

Continuous coefﬁcients

Discrete coefﬁcients

Type

Non-linear solver

Constraint programming

Reinforcement learning

Hybrid (with cache)

Name

KNITRO
APOPT

CP-model
DQN
PPO
BaB-DQN(cid:63)
ILDS-DQN(cid:63)
RBS-PPO(cid:63)

20 items

50 items

100 items

20 items

50 items

100 items

Sol.

Opt.

Sol.

Opt.

Sol.

Opt.

Sol.

Opt.

Sol.

Opt.

Sol.

Opt.

343.79
342.62

356.49
306.71
344.95

356.49
356.49
356.35

0
0

98
0
0

100
1
0

1128.92
1127.71

1028.82
879.68
1123.18

1047.13
1067.20
1126.09

0
0

0
0
0

0
0
0

2683.55
2678.48

2562.59
2568.31
2662.88

2634.33
2639.18
2674.96

0
0

0
0
0

0
0
0

211.60
-

359.81
309.17
347.85

359.81
359.81
359.69

0
-

100
0
0

100
100
0

1039.25
-

1040.30
882.17
1126.06

1067.37
1084.21
1129.53

0
-

0
0
0

0
0
0

2635.15
-

2575.64
2570.81
2665.68

2641.22
2652.53
2679.57

0
-

0
0
0

0
0
0

4 Discussion and Limitations

First of all, let us highlight that this work is not the ﬁrst one attempting to use ML for guiding the
decision process of combinatorial optimization solvers [26]. According to the survey and taxonomy
of Bengio et al. [9], this kind of approach belongs to the third class (Machine learning alongside
optimization algorithms) of ML approaches for solving COPs. It is for instance the case of [20],
which propose to augment branch-and-bound procedures using imitation learning. However, their
approach requires supervised learning and is only limited to (integer) linear problems. The differences
we have with this work are that (1) we focus on COPs modelled as a DP, and (2) the training is entirely
based on RL. Thanks to CP, the framework can solve a large range of problems, as the TSPTW,
involving non-linear combinatorial constraints, or the portfolio optimization problem, involving a
non-linear objective function. Note that we nevertheless need a generator of instances, or enough
historical data of the same distribution, in order to train the models. Besides its expressiveness, and
in contrast to most of the related works solving the problem end-to-end [8, 33, 18, 30], our approach
is able to deal with problems where ﬁnding a feasible solution is difﬁcult and is able to provide
optimality proofs. This was considered by Bengio et al. as an important challenge in learning-based
methods for combinatorial optimization [9].

In most situations, experiments show that our approach can obtain more and better solutions than
the other methods with a smaller execution time. However, they also highlighted that resorting to a
neural network prediction is an expensive operation to perform inside a solver, as it has to be called
numerous times during the solving process. It is currently a bottleneck, especially if we would like to
consider larger instances. It is why caching, despite being a simple mechanism, is important. Another
possibility is to reduce the complexity of the neural network by compressing its knowledge, which
can for instance be done using knowledge-distillation [28] or by building a more compact equivalent
network [51]. Note that the Pybind11 binding between the Python and C++ code is also a source of
inefﬁciency. Another solution would be to implement the whole framework into a single, efﬁcient,
and expressive enough, programming language.

5 Conclusion

The goal of combinatorial optimization is to ﬁnd an optimal solution among a ﬁnite set of possibilities.
There are many practical and industrial applications of COPs, and efﬁciently solving them directly
results in a better utilization of resources and a reduction of costs. However, since the number
of possibilities grows exponentially with the problem size, solving is often intractable for large
instances. In this paper, we propose a hybrid approach, based on both deep reinforcement learning
and constraint programming, for solving COPs that can be formulated as a dynamic program. To do

8

so, we introduced an encoding able to express a DP model into a reinforcement learning environment
and a constraint programming model. Then, the learning part can be carried out with reinforcement
learning, and the solving part with constraint programming. The experiments carried out on the
travelling salesman problem with time windows and the 4-moments portfolio optimization problem
show that this framework is competitive with standard approaches and industrial solvers for instances
up to 100 variables. These results suggest that the framework may be a promising new avenue for
solving challenging combinatorial optimization problems.

References

[1] Emile Aarts and Jan Karel Lenstra. Local search in combinatorial optimization. Princeton

University Press, 2003.

[2] Alexander Aiken. Set constraints: Results, applications and future directions. In International
Workshop on Principles and Practice of Constraint Programming, pages 326–335. Springer,
1994.

[3] Kai Arulkumaran, Marc Peter Deisenroth, Miles Brundage, and Anil Anthony Bharath. A brief

survey of deep reinforcement learning. CoRR, abs/1708.05866, 2017.

[4] Alper Atamtürk and Vishnu Narayanan. Polymatroids and mean-risk minimization in discrete

optimization. Operations Research Letters, 36(5):618–622, 2008.

[5] Logan DR Beal, Daniel C Hill, R Abraham Martin, and John D Hedengren. Gekko optimization

suite. Processes, 6(8):106, 2018.

[6] Nicolas Beldiceanu, Mats Carlsson, and Jean-Xavier Rampon. Global constraint catalog, 2010.
[7] Richard Bellman. Dynamic programming. Science, 153(3731):34–37, 1966.
[8] Irwan Bello, Hieu Pham, Quoc V Le, Mohammad Norouzi, and Samy Bengio. Neural combina-
torial optimization with reinforcement learning. arXiv preprint arXiv:1611.09940, 2016.
[9] Yoshua Bengio, Andrea Lodi, and Antoine Prouvost. Machine learning for combinatorial
optimization: a methodological tour d’horizon. arXiv preprint arXiv:1811.06128, 2018.
[10] Michel Bénichou, Jean-Michel Gauthier, Paul Girodet, Gerard Hentges, Gerard Ribière, and
O Vincent. Experiments in mixed-integer linear programming. Mathematical Programming,
1(1):76–94, 1971.

[11] David Bergman and Andre A Cire. Discrete nonlinear optimization by state-space decomposi-

tions. Management Science, 64(10):4700–4720, 2018.

[12] Christian Bessiere. Arc-consistency and arc-consistency again. Artiﬁcial intelligence, 65(1):179–

190, 1994.

[13] Christian Bessiere. Constraint propagation. In Foundations of Artiﬁcial Intelligence, volume 2,

pages 29–83. Elsevier, 2006.

[14] Cameron B Browne, Edward Powley, Daniel Whitehouse, Simon M Lucas, Peter I Cowling,
Philipp Rohlfshagen, Stephen Tavener, Diego Perez, Spyridon Samothrakis, and Simon Colton.
A survey of monte carlo tree search methods. IEEE Transactions on Computational Intelligence
and AI in games, 4(1):1–43, 2012.

[15] Quentin Cappart, Emmanuel Goutierre, David Bergman, and Louis-Martin Rousseau. Improving
optimization bounds using machine learning: Decision diagrams meet deep reinforcement
learning. In Proceedings of the AAAI Conference on Artiﬁcial Intelligence, volume 33, pages
1443–1451, 2019.

[16] Geoffrey Chu, Maria Garcia de La Banda, and Peter J Stuckey. Automatically exploiting
subproblem equivalence in constraint programming. In International Conference on Integra-
tion of Artiﬁcial Intelligence (AI) and Operations Research (OR) Techniques in Constraint
Programming, pages 71–86. Springer, 2010.

[17] IBM ILOG Cplex. V12. 1: User’s manual for cplex. International Business Machines Corpora-

tion, 46(53):157, 2009.

[18] Michel Deudon, Pierre Cournut, Alexandre Lacoste, Yossiri Adulyasak, and Louis-Martin
Rousseau. Learning heuristics for the tsp by policy gradient. In International conference on the
integration of constraint programming, artiﬁcial intelligence, and operations research, pages
170–181. Springer, 2018.

9

[19] Jean-Guillaume Fages and Charles Prud’Homme. Making the ﬁrst solution good! In 2017 IEEE
29th International Conference on Tools with Artiﬁcial Intelligence (ICTAI), pages 1073–1077.
IEEE, 2017.

[20] Maxime Gasse, Didier Chételat, Nicola Ferroni, Laurent Charlin, and Andrea Lodi. Exact
combinatorial optimization with graph convolutional neural networks. In Advances in Neural
Information Processing Systems, pages 15554–15566, 2019.

[21] Michel Gendreau and Jean-Yves Potvin. Metaheuristics in combinatorial optimization. Annals

of Operations Research, 140(1):189–213, 2005.

[22] Taha Ghasempour and Benjamin Heydecker. Adaptive railway trafﬁc control using approximate
dynamic programming. Transportation Research Part C: Emerging Technologies, 2019.
[23] Gregory A Godfrey and Warren B Powell. An adaptive dynamic programming algorithm for
dynamic ﬂeet management, i: Single period travel times. Transportation Science, 36(1):21–39,
2002.

[24] David Ha and Jürgen Schmidhuber. World models. arXiv preprint arXiv:1803.10122, 2018.
[25] William D Harvey and Matthew L Ginsberg. Limited discrepancy search. In IJCAI (1), pages

607–615, 1995.

[26] He He, Hal Daume III, and Jason M Eisner. Learning to search in branch and bound algorithms.
In Z. Ghahramani, M. Welling, C. Cortes, N. D. Lawrence, and K. Q. Weinberger, editors,
Advances in Neural Information Processing Systems 27, pages 3293–3301. Curran Associates,
Inc., 2014.

[27] J Hedengren, J Mojica, W Cole, and T Edgar. Apopt: Minlp solver for differential and algebraic
systems with benchmark testing. In Proceedings of the INFORMS National Meeting, Phoenix,
AZ, USA, volume 1417, page 47, 2012.

[28] Geoffrey Hinton, Oriol Vinyals, and Jeff Dean. Distilling the knowledge in a neural network.

arXiv preprint arXiv:1503.02531, 2015.

[29] Wenzel Jakob, Jason Rhinelander, and Dean Moldovan. pybind11–seamless operability between

c++ 11 and python, 2017.

[30] Chaitanya K Joshi, Thomas Laurent, and Xavier Bresson. An efﬁcient graph convolutional
network technique for the travelling salesman problem. arXiv preprint arXiv:1906.01227, 2019.
[31] Latife Genç Kaya and John N Hooker. A ﬁlter for the circuit constraint. In International
Conference on Principles and Practice of Constraint Programming, pages 706–710. Springer,
2006.

[32] Elias Khalil, Hanjun Dai, Yuyu Zhang, Bistra Dilkina, and Le Song. Learning combinatorial
optimization algorithms over graphs. In Advances in Neural Information Processing Systems,
pages 6348–6358, 2017.

[33] Wouter Kool, Herke Van Hoof, and Max Welling. Attention, learn to solve routing problems!

arXiv preprint arXiv:1803.08475, 2018.

[34] Philippe Laborie. Objective landscapes for constraint programming. In International Conference
on the Integration of Constraint Programming, Artiﬁcial Intelligence, and Operations Research,
pages 387–402. Springer, 2018.

[35] Eugene L Lawler and David E Wood. Branch-and-bound methods: A survey. Operations

research, 14(4):699–719, 1966.

[36] Yann LeCun, Yoshua Bengio, and Geoffrey Hinton. Deep learning. nature, 521(7553):436–444,

2015.

[37] Juho Lee, Yoonho Lee, Jungtaek Kim, Adam R Kosiorek, Seungjin Choi, and Yee Whye Teh.
Set transformer: A framework for attention-based permutation-invariant neural networks. arXiv
preprint arXiv:1810.00825, 2018.

[38] Michael Luby, Alistair Sinclair, and David Zuckerman. Optimal speedup of las vegas algorithms.

Information Processing Letters, 47(4):173–180, 1993.

[39] Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan
Wierstra, and Martin Riedmiller. Playing atari with deep reinforcement learning. arXiv preprint
arXiv:1312.5602, 2013.

10

[40] Anusha Nagabandi, Gregory Kahn, Ronald S Fearing, and Sergey Levine. Neural network
dynamics for model-based deep reinforcement learning with model-free ﬁne-tuning. In 2018
IEEE International Conference on Robotics and Automation (ICRA), pages 7559–7566. IEEE,
2018.

[41] Gurobi Optimization. Inc.,“gurobi optimizer reference manual,” 2015, 2014.
[42] Anthony Palmieri, Jean-Charles Régin, and Pierre Schaus. Parallel strategies selection. In
International Conference on Principles and Practice of Constraint Programming, pages 388–
404. Springer, 2016.

[43] Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan,
Trevor Killeen, Zeming Lin, Natalia Gimelshein, Luca Antiga, et al. Pytorch: An imperative
style, high-performance deep learning library. In Advances in Neural Information Processing
Systems, pages 8024–8035, 2019.

[44] Jing Peng and Ronald J Williams. Incremental multi-step q-learning. In Machine Learning

Proceedings 1994, pages 226–232. Elsevier, 1994.

[45] Gilles Pesant. A regular language membership constraint for ﬁnite sequences of variables. In
International conference on principles and practice of constraint programming, pages 482–495.
Springer, 2004.

[46] Jean-Charles Régin. A ﬁltering algorithm for constraints of difference in csps.

In AAAI,

volume 94, pages 362–367, 1994.

[47] Jean-Charles Régin. Global constraints: A survey. In Hybrid optimization, pages 63–134.

Springer, 2011.

[48] Francesca Rossi, Peter Van Beek, and Toby Walsh. Handbook of constraint programming.

Elsevier, 2006.

[49] Tom Schaul, John Quan, Ioannis Antonoglou, and David Silver. Prioritized experience replay.

CoRR, abs/1511.05952, 2015.

[50] John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal

policy optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.

[51] Thiago Serra, Abhinav Kumar, and Srikumar Ramalingam. Lossless compression of deep neural

networks. arXiv preprint arXiv:2001.00218, 2020.

[52] Richard S Sutton, Andrew G Barto, et al. Introduction to reinforcement learning, volume 135.

MIT press Cambridge, 1998.

[53] Richard S Sutton, David A McAllester, Satinder P Singh, and Yishay Mansour. Policy gradient
In Advances in neural

methods for reinforcement learning with function approximation.
information processing systems, pages 1057–1063, 2000.

[54] Yufei Tang, Chaoxu Mu, and Haibo He. Near-space aerospace vehicles attitude control based
on adaptive dynamic programming and sliding mode control. In 2017 International Joint
Conference on Neural Networks (IJCNN), pages 1347–1353. IEEE, 2017.

[55] Gecode Team. Gecode: Generic constraint development environment, 2006, 2008.
[56] Nikolas Topaloglou, Hercules Vladimirou, and Stavros A Zenios. A dynamic stochastic
programming model for international portfolio management. European Journal of Operational
Research, 185(3):1501–1524, 2008.

[57] John N Tsitsiklis. Special cases of traveling salesman and repairman problems with time

windows. Networks, 22(3):263–282, 1992.

[58] Pascal Van Hentenryck, Yves Deville, and Choh-Man Teng. A generic arc-consistency algorithm

and its specializations. Artiﬁcial intelligence, 57(2-3):291–321, 1992.

[59] Petar Veliˇckovi´c, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua

Bengio. Graph attention networks. arXiv preprint arXiv:1710.10903, 2017.

[60] Richard A Waltz and Jorge Nocedal. Knitro 2.0 user’s manual. Ziena Optimization, Inc.[en

ligne] disponible sur http://www. ziena. com (September, 2010), 7:33–34, 2004.

[61] Minjie Wang, Lingfan Yu, Da Zheng, Quan Gan, Yu Gai, Zihao Ye, Mufei Li, Jinjing Zhou,
Qi Huang, Chao Ma, et al. Deep graph library: Towards efﬁcient and scalable deep learning on
graphs. arXiv preprint arXiv:1909.01315, 2019.

11

[62] Christopher JCH Watkins and Peter Dayan. Q-learning. Machine learning, 8(3-4):279–292,

1992.

[63] Laurence A Wolsey and George L Nemhauser. Integer and combinatorial optimization, vol-

ume 55. John Wiley & Sons, 1999.

12

A Technical Background on Reinforcement Learning

Let (cid:104)S, A, T, R(cid:105) be a tuple representing a deterministic couple agent-environment where S in the
set of states in the environment, A is the set of actions that the agent can do, T : S × A → S
is the transition function leading the agent from one state to another given the action taken, and
R : S × A → R is the reward function of taking an action from a speciﬁc state. The behavior of
an agent is deﬁned by a policy π : S → A, describing the action to be taken given a speciﬁc state.
The goal of an agent is to learn a policy maximizing the accumulated sum of rewards (eventually
discounted) during its lifetime deﬁned by a sequence of states st ∈ S with t ∈ [1, Θ] and Θ the
episode length. Such a sequence is called an episode, where sΘ is the terminal state. The return
after time step t is deﬁned as follows: Gt = (cid:80)Θ
k=t R(sk, ak). Note that we omitted the standard
discounting factor, because the weight of all decisions have the same importance when solving COPs
that do not have a temporal aspect.

In a deterministic environment, the quality of taking an action a from a state s under a policy π is
deﬁned by the action-value function Qπ(st, at) = Gt. Similarly, the return of a state s is deﬁned
by the state-value function V π(s) = (cid:80)
a∈A Qπ(s, a)π(a|s). The problem is to ﬁnd a policy that
maximizes the ﬁnal return: π(cid:63) = argmaxπQπ(s, a) ∀s ∈ S and ∀a ∈ A. However, the number
of combinations increases exponentially with the number of states and actions, which makes this
problem intractable. There exist in the literature a tremendous number of approaches for solving this
problem, the many very successful ones are based on deep learning [36] and are referred to as deep
reinforcement learning (DRL) [3].

Apart from hybrid approaches such as Monte-Carlo tree search [14] and model-based approaches
that are dedicated to learn the environment [40, 24], there exist two families of reinforcement learning
algorithms: (1) the value-based methods, where the goal is to learn an action-value function ˆQ and
then to select the actions with high value, and (2) the policy-based methods, where the policy ˆπ is
learned directly.

In this paper, we consider two algorithms, deep Q-learning (DQN) [39], a value-based method, and
proximal policy gradient (PPO) [50], a policy-gradient based method. The idea of DQN is to use a
deep neural network to approximate the action-value function Q and to use it through a Q-learning
algorithm [62]. This provides an estimator ˆQ(s, a, w) ≈ Q(s, a), where w is a learned weight vector
ˆQ(s, a, w) is then used for selecting the actions. In
parametrizing ˆQ. The greedy policy argmaxa
practice, the standard DQN algorithm is improved by several mechanisms in order to speed-up
learning and to increase stability [44, 49].

Conversely, the goal of policy gradient methods, as PPO, is to learn an estimation ˆπ(s, w) ≈ π(s)
of the policy that maximizes V π(s0), the expected return of the initial state. In practice, it is often
(cid:2)∇w ln π(a|s, w)Qπ(s, a)(cid:3). The
computed using the policy gradient theorem [53]: ∇π(V π(s0)) = Eπ
expectation Eπ indicates the empirical average over a set of samples that are obtained by following
the current policy π. This theorem provides a suited form to improve the policy through gradient
ascent, by parametrizing the weight vector w. Unlike the DQN algorithm, the policy obtained with
policy gradient methods keeps a stochastic aspect. Based on the policy gradient theorem, the main
idea of PPO is to avoid parameter updates that change the policy too much during the gradient ascent.
It empirically results in improved stability during training.

13

B Technical Background on Constraint Programming

Constraint programming (CP) [48] is a general framework proposing simple and efﬁcient algorithmic
solutions to COPs. Such as mixed integer programming (MIP), and in contrast to heuristic and local
search methods, CP is a complete approach for solving COPs, which can prove the optimality of the
solutions found. Considering a minimization problem, a CP model is a tuple (cid:104)X, D, C, O(cid:105), where X is
the set of variables, D(X) is the set of domains, that contain possible values for the variables, C is the
set of constraints, that restrict assignments of values to variables, and O is an objective function. The
goal is to choose a value for each variable of X from D which satisﬁes all the constraints of C and that
maximizes the objective O.

Finding feasible solutions essentially consists of an exhaustive enumeration of all the possible
assignments of values to variables until the best solution has been found. The search tree grows
up exponentially with the number of variables during this process, meaning that the complete
enumeration of solutions is intractable for large problems. To cope with this issue, the CP search is
ﬁrst improved by a mechanism called propagation, having the responsibility to reduce the number of
possible combinations and then the search tree size. Given the current domains of the variables and a
constraint c, the propagation of c removes from the domains the values that cannot be part of the
ﬁnal solution because of the violation of c. This process is repeated at each domain change and for
each constraint until no more value can be removed from the domains. This procedure is commonly
referred to as the ﬁx-point algorithm. The efﬁciency and the success of a CP solver is mainly due to
the quality of their propagators, i.e., the algorithms performing the propagation for each constraint,
the variety of available constraints, and their expressiveness. A tremendous amount of work has been
dedicated to the implementation of efﬁcient propagators for constraints [58, 12, 13]. Among them,
global constraints [47] are constraints that capture a relation between a non-ﬁxed number of variables.
At the time of writing, the global constraints catalog reports more than 400 different existing global
constraints [6]. For instance, a well-known global constraint is allDifferent(X), enforcing each
variable in X to take a different value [46]. Other examples are the set constraints [2], that enable
users to build variables having a set structure and to state constraints on them (union, intersection,
difference, etc.), or the circuit constraint [31], enforcing a valid Hamiltonian tour across a set of
variables. Then, Unlike MIP solvers that are restricted to linear constraints, one asset of CP is its
ability to handle any kind of constraints, even non-linear.

The search is commonly done in a depth-ﬁrst fashion, together with branch-and-bound [35]. When
a feasible solution has been found, a new constraint ensuring that the next solution has to be better
than the current one is added. In case of an unfeasible solution due to an empty domain reached,
the search is backtracked to the previous decision. With this procedure, and provided that the whole
search space has been explored, the last solution found is then proven to be optimal. A drawback of
this strategy is that backtracks occurs at the last levels of the tree search. Hence, the early choices are
rarely reconsidered. However that CP offers a great ﬂexibility in the search procedure, and allows
other kinds of searches such as limited discrepancy search [25] or strategy based on restarts. The
last design choices when using CP is the variable-selection and value-selection heuristics. During
the search, what variable must be considered ﬁrst when branching ? Similarly, what value should be
tested ﬁrst. As a guideline, the values that are the most promising should be assigned ﬁrst. Although
crucial for constrained satisfaction problems, the impact of the variable ordering has a smaller impact
on the search when dealing with COPs and is not analyzed in this work. The choice of an appropriate
value ordering heuristic is non-trivial and their design is a hot topic in the CP community [19, 34].

14

C Iterative Limited Discrepancy Search with DQN

Iterative limited discrepancy search (ILDS) [25] is a search strategy commonly used when we have
a good prior on the quality of the value selection heuristic used for driving the search. The idea
is to restrict the number of decisions deviating from the heuristic choices (i.e., a discrepancy) by
a threshold. By doing so, the search will explore a subset of solutions that are likely to be good
according to the heuristic while giving a chance to reconsider the heuristic selection which may be
sub-optimal. This mechanism is often enriched with a procedure that iteratively increases the number
of discrepancies allowed once a level has been fully explored.

As ILDS requires a good heuristic for the value-selection, it is complementary with a value-based RL
agent, such as DQN. After the training, the agent gives a parametrized state-action value function
ˆQ(s, a, w), and the greedy policy argmaxa
ˆQ(s, a, w) can be used for the value-selection heuristic,
which is intended to be of a high, albeit non-optimal, quality. The variable ordering must follow the
same order as the DP model in order to keep the consistency with both encoding.

The complete search procedure we designed (ILDS-DQN) is presented in Algorithm 2, taking as
input a COP Q, a pre-trained model with the weight vector w, and an iteration threshold I for
the ILDS. First, the optimization problem Q in encoded into a CP model. Then, for each number
i ∈ {1, . . . , I} of discrepancies allowed, a new search Ψ is initialized and executed on Q. Until
the search is not completed, a RL state s is obtained from the current CP state (encodeStateRL).
The ﬁrst non-assigned variable xi of the DP is selected and is assigned to the value maximizing the
state-action value function ˆQ(s, a, w). All the search mechanisms inherent of a CP solver but not
related to our contribution (propagation, backtracking, etc.), are abstracted in the branchAndUpdate
function. Finally, the best solution found during the search is returned. The cache mechanism (K)
introduced for the BaB search is reused. The worst-case bounds are the same as in Algorithm 1:
O(dm) for the time complexity, and O(d × m + |K|) for the space complexity, where m is the
number of actions of the DP model, d is the maximal domain size, and |K| is the cache size.

Algorithm 2: ILDS-DQN Search Procedure.
(cid:46) Pre: Qp is a COP having a DP formulation.
(cid:46) Pre: w is a trained weight vector.
(cid:46) Pre: I is the threshold of the iterative LDS.

(cid:104)X, D, C, O(cid:105) := CPEncoding(Qp)
c(cid:63) = −∞, K = ∅
for i from 0 to I do

Ψ := LDS-search((cid:104)X, D, C, O(cid:105), i)
while Ψ is not completed do
s := encodeStateRL(Ψ)
x := takeFirstNonAssignedVar(X)
if s ∈ K then

v := peek(K, s)

else

v := argmaxu∈D(x)

ˆQ(s, u, w)

end
K := K ∪ {(cid:104)s, v(cid:105)}
branchAndUpdate(Ψ, x, v)

end
c(cid:63) := max (cid:0)c(cid:63), bestSolution(Ψ)(cid:1)

end
return c(cid:63)

15

D Restart-Based Search with PPO

Restart-based search (RBS) is another search strategy, which involves multiple restarts to enforce a
suitable level of exploration. The idea is to execute the search, to stop it when a given threshold is
reached (i.e., execution time, number of nodes explored, number of failures, etc.), and to restart it.
Such a procedure works only if the search has some randomness in it, or if new information is added
along the search runs. Otherwise, the exploration will only consider similar sub-trees. A popular
design choice is to schedule the restart on the Luby sequence [38], using the number of failures for
the threshold, and branch-and-bound for creating the search tree.

The sequence starts with a threshold of 1. Each next parts of the sequence is the entire previous
sequence with the last value of the previous sequence doubled. With a size of 15, the luby sequence
is the following: (cid:104)1, 1, 2, 1, 1, 2, 4, 1, 1, 2, 1, 1, 2, 4, 8(cid:105). The sequence can also be scaled with a factor
σ, multiplying each element. As a controlled randomness is a key component of this search, it can
naturally be used with a policy π(s, w) parametrized with a policy gradient algorithm. By doing
so, the heuristic randomly selects a value among the feasible ones, and according to the probability
distribution of the policy through a softmax function. It is also possible to control the exploration
level by tuning the softmax function with a standard Boltzmann temperature τ . The complete search
process is depicted in Algorithm 3. Note that the cache mechanism is reused in order to store the
vector of action probabilities for a given state. The worst-case bounds are the same as in Algorithm 1:
O(dm) for the time complexity, and O(d × m + |K|) for the space complexity, where m is the
number of actions of the DP model, d is the maximal domain size and, |K| is the cache size.

Algorithm 3: RBS-PPO Search Procedure.
(cid:46) Pre: Qp is a COP having a DP formulation.
(cid:46) Pre: w is a trained weight vector.
(cid:46) Pre: I is the number of restarts to do.
(cid:46) Pre: σ is the Luby scale factor.
(cid:46) Pre: τ is the softmax temperature.

(cid:104)X, D, C, O(cid:105) := CPEncoding(Qp)
c(cid:63) = −∞, K = ∅
for i from 0 to I do
L = Luby(σ, i)
Ψ := BaB-search((cid:104)X, D, C, O(cid:105), L)
while Ψ is not completed do
s := encodeStateRL(Ψ)
x := takeFirstNonAssignedVar(X)
if s ∈ K then

p := peek(K, s)

else

p := π(s, w)

end
K := K ∪ {(cid:104)s, p(cid:105)}
v ∼D(x) softmaxSelection(p, τ )
branchAndUpdate(Ψ, x, v)

end
c(cid:63) := max (cid:0)c(cid:63), bestSolution(Ψ)(cid:1)

end
return c(cid:63)

16

E Travelling Salesman Problem with Time Windows (TSPTW)

The travelling salesman problem with time windows (TSPTW) is an extension of the standard
travelling salesman problem (TSP). Given an instance of n customers, it consists in ﬁnding a
minimum cost Hamiltonian tour starting and ending at a given depot and visiting all customers (or
similarly, cities). Each customer i is deﬁned by a position (xi and yi for the 2D case), and a time
window ([li, ui]), deﬁning the time slot where he can be visited. Each customer can and must be
visited once and the travel time between two customers i and j is deﬁned by di,j. Note that a customer
can be visited before the beginning of its time windows but, in this case, the service has to wait.
No customers can be serviced after its time windows, and solutions that fail to serve all the clients
are considered infeasible. Finally, there is no time windows associated to the depot. The goal is to
minimize the sum of the travel distances. Although the search space of the TSPTW is smaller than
for the TSP, the time constraints make the problem more difﬁcult to solve in practice [57].

E.1 Dynamic Programming Model

Given an instance of n customers, the DP model has n + 1 stages where the last state corresponds to
the solution obtained. Without loss of generality, we assume that the depot is associated to the ﬁrst
customer (i = 1). A state si ∈ S at stage i is composed of three entities: (1) the set of remaining
customers that still have to be visited (mi ∈ P(cid:0){2, ..., n}(cid:1), with P the powerset of all the customers
without including the depot), (2) the last customer that has been serviced (vi ∈ {1..n}), and (3) the
current time (ti ∈ N+). An action ai ∈ {1..n} performed at stage i corresponds to the service of
customer i. The reward R(si, ai) is, in fact, a penalty and corresponds to the travel time between
two customers (R(si, ai) = −dvi,ai). Note that an additional penalty for coming back to the depot
(R(sn+1) = −dvn+1,1) must also be considered. The DP model we built is as follows.

s1 = (cid:8)m1 = {2..n}, v1 = 1, t1 = 0(cid:9)

mi+1 = mi \ ai
vi+1 = ai
ti+1 = max (cid:0)ti + dvi,ai, lai
V1 : ai ∈ mi
V2 : uai ≥ ti + dvi,ai
P : (cid:0)ti ≥ uj

(cid:1) ⇒ (cid:0)j /∈ mi

(cid:1)

(cid:1)

(Initial state deﬁnition)
∀i ∈ {1..n} (Transition function for mi)
∀i ∈ {1..n} (Transition function for vi)
(Transition function for ti)
∀i ∈ {1..n}
∀i ∈ {1..n}
(First validity condition)
∀i ∈ {1..n} (Second validity condition)

∀i, j ∈ {1..n}

(Dominance pruning)

The initial state enforces to start at the depot at time t = 0 and that all the customers (excepting the
depot) must be visited. When an action is done (i.e., servicing a customer), the state is updated as
follows: (1) the client does not have to be visited anymore, (2) he becomes the last visited client, and
(3) the current time is updated according to the problem deﬁnition. A action is valid if it satisﬁes two
validity conditions: (1) he must be in the set of the non-visited clients, and (2) given the current time,
it is possible to visit the client without exceeding the time windows. The non-mandatory dominance
rule (R) removes from mi all the clients having the time windows exceeded. By doing so, the search
space is reduced. Finally, the objective function is to minimize the sum of the travel time.

E.2 Instance Generation

For an instance of n customers, the coordinates xi and yi are sampled uniformly at random in a
grid of size 100 × 100. The rounded 2D Euclidean distances is used for the travel time between
1002 + 1002 ≈ 144. Time
two locations. The largest distance separating two customers is then
windows are also randomly generated but we ensure that the values selected will allow at least one
feasible solution. To do so, we generate the time windows as follows. Let W be the maximal time
window length allowed and G the maximal gap between two consecutive time windows. We ﬁrst
generate a random permutation of all the customers. It constitutes the feasible solution we want to
preserve. Then, the time windows are computed as follows: li+1 ∼ U[di,i+1 + li, di,i+1 + li + G],
and ui+1 ∼ U[li+1, li+1 + W ], with l1 = 0 (i.e., the depot) and di,i+1 the distance between two
consecutive customers in the tour. It is important to note that this feasible solution is not known by
the solvers, which only receive the customers coordinates and the time windows bounds. Without
loss of generality, the values 100 and 10 are used for W and G.

√

17

E.3 Neural Architecture

A TSPTW instance can naturally be represented by a fully connected graph, where the vertices
are the customers, and the (weighted) edges express the distances between them. Therefore, the
features representing an instance should reﬂect the combinatorial structure of the graph. To do so, a
graph attention network (GAT) [59] is used in order to produce an embedding for each node of the
graph. Few fully connected layers are then added on top of the embedding. For the DQN case, the
dimension of the last layer output corresponds to the number of possible actions (i.e., the number
of customers) and output an estimation of the Q-values for each of them. Concerning PPO, two
distinct networks are built, one for the actor, and the second one for the critic. A GAT embedding is
also used and is similar for both. The critic uses a max pooling between the ﬁnal node embedding
and the fully connected layers. The last layer on the critic outputs only a single value. Concerning
the actor, it is similar as the DQN case but a softmax selection is used after the last layer in order
to obtain a probability to select each action. Note that the output of the softmax and of the DQN
network are masked in order to allow only the valid actions to be selected. Implementation is done
using Pytorch [43] and DGL [61]. Each customer i is represented by 4 static and 2 dynamic features.
Static features are the coordinates of the nodes (xi, yi) and the lower and upper bounds value of
the time windows (li, ui). The dynamic features are related to the DP model. Both are binary
values and indicate if the customer still has to be serviced, and, if the customer if the last one that
has been serviced. Edges have only a single feature, namely the distances between two customers
(di,j). All the features are then divided by their highest possible value. The hyper-parameters
used are summarized in Table 3. The ranges have been determined using this reference (https:
//github.com/llSourcell/Unity_ML_Agents/blob/master/docs) and the values have been
ﬁxed by grid searches on subsets of parameters in order to keep the number of combinations tractable.
The selection has been made when training on the 20-cities case, and the hyper-parameters were
reused for the larger instances, except for the softmax temperature that has been tuned for each size.

Table 3: Hyper-parameter values for TSPTW models.

Parameter

Range tested

DQN-based methods

PPO-based method

20 cities

50 cities

100 cities

20 cities

50 cities

100 cities

Batch size
Learning rate
# GAT layers
Embedding dimension
# Hidden layers
Hidden layers dimension
Reward scaling

{32, 64, 128}
{0.001, 0.0001, 0.00001}
{4}
{32, 64, 128}
{2, 3, 4}
{32, 64, 128}
{0.001}

32
0.0001
4
32
2
32
0.001

32
0.0001
4
32
2
32
0.001

Softmax temperature
n-step

{2, 5, 7, 10}
Episode length

Entropy value
Cliping value
Udpate timestep
# Epochs per update
RBS temperature
Luby scaling factor

{0.1, 0.01, 0.001}
{0.1, 0.2, 0.3}
{2048}
{2, 3, 4}
{1, 2, 3, 4, 5}
{20, 21, . . . , 29}

10
20

-
-
-
-
-
-

10
50

-
-
-
-
-
-

32
0.0001
4
32
2
32
0.001

10
100

-
-
-
-
-
-

64
0.0001
4
128
4
128
0.001

-
-

0.001
0.1
2048
3
20
128

64
0.0001
4
128
4
128
0.001

-
-

0.001
0.1
2048
3
20
128

64
0.0001
4
128
4
128
0.001

-
-

0.001
0.1
2048
3
20
128

E.4 Baselines used for Comparison

OR-Tools A hybrid model based on constraint programming and local search using OR-Tools

solver. We reuse the VRPTW example of the documentation2, with only one vehicle.

DQN Solution obtained using the standard DQN algorithm with the greedy selection policy.
PPO Best solution obtained using PPO with a beam-search decoding of size 64.
CP-Model A standard constraint programming formulation3, that leverages global constraints

(allDifferent, circuit, and increasing). It is solved with Gecode [55].

Nearest A model based on the above DP formulation and uses the ILDS search strategy with
a selection based on the closest next customer instead of the DQN prediction. It is also
modelled and solved with Gecode [55],

2https://developers.google.com/optimization/routing/vrptw
3http://www.hakank.org/minizinc/tsptw.mzn

18

F 4-Moments Portfolio Optimization Problem (PORT)

In the 4-moments portfolio optimization problem (PORT) [4, 11], an investor has to select a com-
bination of investments that provides the best trade-off between the expected return and different
measures of ﬁnancial risk. Given a set of n investments, each with a speciﬁc cost (ai), an expected
return (µi), a standard deviation (σi), a skewness (γi), and a kurtosis (κi), the goal of the portfolio
optimization problem is to ﬁnd a portfolio with a large positive expected return and skewness, but
with a large negative variance and kurtosis, provided that the total investment cost is below its budget
B. Besides, the importance of each ﬁnancial characteristic is weighted (λ1, λ2, λ3, and λ4) according
to the preference of the investor. Let xi be a binary variable associated to each investment, indicating
whether or not the investment is included in the portfolio. The standard problem is expressed as
follows:

(cid:32)

maximize

λ1

n
(cid:88)

i=1

µixi − λ2

(cid:118)
(cid:117)
(cid:117)
2
(cid:116)

n
(cid:88)

i=1

σ2
i xi + λ3

(cid:118)
(cid:117)
(cid:117)
3
(cid:116)

n
(cid:88)

i=1

γ3
i xi − λ4

(cid:118)
(cid:117)
(cid:117)
4
(cid:116)

n
(cid:88)

i=1

(cid:33)

κ4
i xi

subject to

n
(cid:88)

aixi ≤ B

i=1
xi ∈ {0, 1}

(2)

∀i ∈ {1..n}

∀i ∈ {1..n}

Note that it is a discrete non-linear programming problem, and that the objective function, taken
as-is, is non-convex. Solving this problem using a integer programming solver is non-trivial and
requires advanced decomposition methods [11]. Another option is to use a general non-linear solver
as Knitro [60], or APOPT [27]. However, as this formulation is non-convex, such solvers will not
be able to prove optimality. To do so, a convex reformulation of the problem is required. In this
work, we also consider a discrete variant of this problem, where the ﬂoor function is applied on all
the roots of Equation (2). By doing so, all the coefﬁcients are integers. This variant is especially hard
for general non-linear solvers, as we break the linearity of the objective function and increase the risk
of getting a poor local optimum.

F.1 Dynamic Programming Model

Given an instance of n items, the DP model has n + 1 stages where the last state corresponds to
the ﬁnal solution obtained. The idea of the DP model is to consider at each investment successively
(one per stage) and to decide if it must be inserted into the portfolio. A state si ∈ N+ at stage i only
consists of the current cost of the investments in the portfolio. An action ai ∈ {0, 1} performed at
stage i corresponds to the selection, or not, of the investment i. The reward corresponds to the ﬁnal
objective function value (Equation (2)) provided that we are at the last stage (i.e., all the variables
have been assigned). Otherwise, it is equal to zero. Then, only the ﬁnal reward is considered. The DP
model, with a validity condition ensuring that the budget B is never exceeded, is as follows:

s1 = 0

si+1 = si + aibi

V1 : si + aibi ≤ B

F.2 Instance Generation

(Initial state deﬁnition)
∀i ∈ {1..n} (Transition function for mi)
∀i ∈ {1..n}
(Validity condition)

Instances are generated in a similar fashion as [4, 11]. For an instance of n investments, the costs bi
and the expected return µi are sampled uniformly from 0 to 100. The maximum budget B is set at
0.5 × (cid:80)n
i=1 bi. The other ﬁnancial terms (σi, γi, and κi) are sampled uniformly from 0 to µi. Finally,
λi = 1, and λ2 = λ3 = λ4 = 5.

F.3 Neural Architecture

Unlike the TSPTW, the portfolio optimization problem has no graph structure. For this reason, we
have considered for this problem an architecture based on sets (SetTransformer) [37] which has
the beneﬁt to be permutation invariant. Then, processing an instance with the items {i1, i2, i3}

19

produce the same output as {i3, i2, i1}, {i3, i1, i2}, or {i1, i3, i2}. SetTransformer ﬁrst produces
an embedding for each item. Then, few fully connected layers are added on the top of the embedding
to produce the output. Like the TSPTW, the architecture differs slightly according to the RL
algorithm used (DQN or PPO). Implementation is done using Pytorch and the SetTransformer
code proposed in [37] is reused. Each item is represented by 5 static and 4 dynamic features. Static
features are the costs (bi), and the coefﬁcient of each item according to the objective function
(Equation (2)): µi, σ2
i . The dynamic features are related to the current state inside the
DP model. First, we have three binary values and indicates (1) if the investment i has already been
considered by the DP model, (2) if the investment i is the one that is considered at the current stage,
and (3) if the insertion of investment i will exceed the budget. Finally, the last feature indicates
the remaining budget allowed, minus all the costs. All non-binary features are ﬁnally divided by
their highest possible value. The hyper-parameters used are summarized in Table 4 and the selection
follows the same procedure as for the TSPTW case study. Note that the embedding dimension of 40
has been reused from the initial SetTransformer implementation.

i , and κ4

i , γ3

Table 4: Hyper-parameter values for PORT models.

Parameter

Range tested

DQN-based methods

PPO-based method

20 items

50 items

100 items

20 items

50 items

100 items

Batch size
Learning rate
Embedding dimension
# Hidden layers
Hidden layers dimension
Reward scaling

{32, 64, 128}
{0.001, 0.0001, 0.00001}
{40}
{2, 3, 4}
{32, 64, 128}
{0.001}

64
0.00001
40
2
128
0.001

32
0.00001
40
2
128
0.001

Softmax temperature
n-step

{2, 5, 7, 10}
{5, 10, Episode length}

10
20

Entropy value
Cliping value
Udpate timestep
# Epochs per udpate
RBS temperature
Luby scaling factor

{0.1, 0.01, 0.001}
{0.1, 0.2, 0.3}
{2048}
{2, 3, 4}
{1, 2, 3, 4, 5}
{20, 21, . . . , 29}

-
-
-
-
-
-

2
50

-
-
-
-
-
-

32
0.00001
40
2
128
0.001

10
100

-
-
-
-
-
-

128
0.0001
40
2
128
0.001

-
-

0.001
0.1
2048
4
1
1

32
0.0001
40
2
128
0.001

-
-

0.001
0.1
2048
4
1
1

64
0.0001
40
2
128
0.001

-
-

0.001
0.1
2048
4
1
1

F.4 Baselines used for Comparison

Knitro Knitro is a commercial software package for solving large scale nonlinear mathematical
optimization problems [60]. The parameters used are the default ones of the solver.
APOPT APOPT is another solver able to solve large scale optimization problems, such as mixed
integer non-linear programs. We used this solver with the GEKKO python interface [5]. The
parameters used are the default ones.

DQN Solution obtained using the standard DQN algorithm with the greedy selection policy.
PPO Best solution obtained using PPO with a beam-search decoding of size 64.
CP-Model A CP formulation of the model presented in Equation (2). It is solved with Gecode [55].

20

