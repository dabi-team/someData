A Visual Programming Paradigm for Abstract Deep
Learning Model Development
Srikanth Tamilselvam,† Naveen Panwar,† Shreya Khare,†
Rahul Aralikatte,‡ Anush Sankaran,† Senthil Mani,†
†IBM Research, ‡University of Copenhagen

9
1
0
2

g
u
A
9
1

]

C
H
.
s
c
[

2
v
6
8
4
2
0
.
5
0
9
1
:
v
i
X
r
a

ABSTRACT
Deep learning is one of the fastest growing technologies in
computer science with a plethora of applications. But this un-
precedented growth has so far been limited to the consumption
of deep learning experts. The primary challenge being a steep
learning curve for learning the programming libraries and the
lack of intuitive systems enabling non-experts to consume
deep learning. Towards this goal, we study the effectiveness
of a “no-code" paradigm for designing deep learning models.
Particularly, a visual drag-and-drop interface is found more
efﬁcient when compared with the traditional programming
and alternative visual programming paradigms. We conduct
user studies of different expertise levels to measure the entry
level barrier and the developer load across different program-
ming paradigms. We obtain a System Usability Scale (SUS)
of 90 and a NASA Task Load index (TLX) score of 21 for
the proposed visual programming compared to 68 and 52,
respectively, for the traditional programming methods.

ACM Classiﬁcation Keywords
D.1.7 PROGRAMMING TECHNIQUES (E): Visual Pro-
gramming; I.2.2 ARTIFICIAL INTELLIGENCE: Automatic
Programming—Program synthesis; D.2.2 SOFTWARE EN-
GINEERING: Design Tools and Techniques—User interfaces

Author Keywords
Deep Learning, Visual Programming, drag-and-drop interface,
auto programming

INTRODUCTION
Deep learning (DL) is one of the most pervasive and break-
through technologies of the previous decade [26]. Automation
has progressed signiﬁcantly in various application domains
such as self-driving cars [12] [13] [19], ﬂight control systems
[28], and medical diagnosis [22] [16] primarily due to the ad-
vent of deep learning technology. According to Gartner, 80%
of the data scientists will have DL in their toolkits by 2018 1.
With this sudden explosion of DL, there is a requirement for
current software engineers and data scientists to learn and up-
skill themselves in a short span of time. However, DL model
authoring has been a skill that is currently restricted only to
experts 2. The democratization of DL model development has
been inhibited due to the following challenges:

1. High Initial Learning Curve: There is a steep learning
curve involved in understanding the fundamentals of deep

1https://www.gartner.com/newsroom/id/3804363
2https://www.kdnuggets.com/2018/01/
democratizing-ai-deep-learning-machine-learning-dell-emc.
html

learning and the syntax nuances of multiple deep learning
authoring libraries. There is a lack of intuitive systems to
author DL models in an easy fashion.

2. Lack of Interaction across Libraries: Different program-
ming libraries exist for DL implementation such as Keras3,
Tensorﬂow4, PyTorch5, Caffe6. However, there is limited
interoperability across these libraries that enables a model
designed and trained in one speciﬁc library to be accessible
and re-usable across libraries.

3. Theoretical Knowledge: Theory of deep learning has a
strong mathematical prior. Additionally, the ability of mak-
ing the right architecture choices and hyper-parameter pref-
erences comes with practice and experience.

Sankaran et al. [25] studied the challenges faced by a DL devel-
oper by conducting a qualitative survey among 100 software
engineers from varying backgrounds. 83% of the participants
responded that it took them about 3 − 4 days to implement a
deep learning model, given the model design and choice to use
any DL library. Interestingly, 86% of those respondents had
rated themselves as highest in “programming ability". Thus,
even good programmers ﬁnd it challenging to implement and
author deep learning models. This motivates the need for an
efﬁcient and intuitive method for developing deep learning
models. The survey also showed that more than 92% of the
respondents wanted an interoperability framework to convert
the code and model implemented in one library into another
library. In the recent past, a few open source uniﬁed libraries
were made available in the community such as Open Neural
Network Exchange (ONNX) [10], nGraph from Intel [4], and
Neural Network Exchange Format (NNEF) [8]. These uniﬁed
frameworks provide a standard, library agnostics represen-
tation of deep learning models. Despite the availability of
such standardized frameworks, the ease in adoption of DL for
non-expert users and rapid prototyping for expert users still
remains a challenge.

In this research, we develop an easy to use visual programming
paradigm and an Integrated Development Environment (IDE)
for intuitive designing and authoring of deep learning models.
This DL-IDE aims to democratize deep learning model devel-
opment for software engineers and data scientists by offering a
“no-code" designing platform and reducing the learning curve.

3https://keras.io/
4https://www.tensorflow.org/
5https://pytorch.org/
6https://caffe2.ai/

 
 
 
 
 
 
Tool

UI
Designing
Limited
Weka [17]
No
Digits [9]
Yes
Aetros [3]
Yes
Fabrik [1]
No
Tensorboard [11]
No
Azure ML
Yes
NN Console [7]
No
Activis [20]
Netron [5]
No
Deep Cognition [2] Yes
Yes
Machine UI [6]
DL-IDE (proposed) Yes

Model
Visualization
Limited
Yes
No
Yes
Yes
No
Yes
Yes
Yes
Yes
Yes
Yes

Code
Available
Yes
No
Yes
Yes
No
No
No
No
No
No
Yes
Yes

Multi-library
support

No
No
No
Yes
No
No
No
No
No
No
No
Yes

Training
Dashboard
Yes
Yes
Yes
No
Yes
Yes
Yes
No
No
Yes
Yes
Yes

Inference
API

Yes
No
No
No
No
No
No
No
No
Yes
No
Yes

Table 1: Comparison of different tools and frameworks in the literature that enables easy and quick development of deep learning
models.

Fundamentally, any deep learning model design can be vi-
sualized as a graph data structure with a collection of nodes
as computational layers and each layer having a list of hyper-
parameters. To ease designing of such models, the DL-IDE has
a drag-and-drop framework to visually design the deep learn-
ing model. The layer connections and the layer parameters
could be set through the user interface minimizing the need
for coding. DL-IDE represents the designed deep learning
model as an abstract representation called Neural Language
Deﬁnition Standard (NLDS) enabling execution ready code to
be generated in multiple libraries such as Tensorﬂow, Keras,
PyTorch, and Caffe. To study the effectiveness of the proposed
DL-IDE, we conducted usability study among 18 intermediate
and expert deep learning developers, comparing the visual
method and programming method for designing deep learn-
ing models. The primary aim of the user study is to verify
the hypothesis that, in comparison with the traditional coding
method for designing deep learning models, the visual pro-
gramming [23] method is better in terms of ease-of-use, ease
in adoption, and decreases the prototyping efforts. The key
research contributions can be summarized as follows:

1. Visual DL-IDE: A visual programming IDE enabling “no-
code" intuitive way of designing deep learning models7.

2. Neural Language Deﬁnition Standard (NLDS): An ab-
stract representation capturing all the required parameters
of a DL model, independent of the underlying implementa-
tion library (Tensorﬂow, PyTorch etc.) or language.

3. Static Model Validation: An extensive collection of man-
ually curated rules to automatically validate the design pa-
rameters of a deep learning model in real-time, performed
on top of NLDS.

7To abide to the double blind format of the paper, only screenshots
of the system is made available. The entire system will be made
publicly available upon the acceptance of the paper.

4. Multiple Library Code Generation: Adopting Model
Driven Development of generating bug free, execution ready
code in multiple libraries from NLDS representation. Cur-
rently, we support Tensorﬂow v1.4, Keras v2.1, PyTorch
v0.3, and Caffe v1.0.

5. System Usability Study: A user study is conducted with
18 intermediate and expert deep lear ning developers to
assess, and compare the traditional programming method
with the proposed visual drag-and-drop user interface.

The rest of the paper is organized as follows: Section 2 pro-
vides a literature survey comparing the DL-IDE with other
abstract visual programming tools. Section 3 details the de-
sign goals and the system architecture of the proposed deep
learning IDE. Section 4 explains the user study setup and the
data collection process. Section 5 analyzes the experimental
results from the user study. Section 6 discusses the design
implications of our study setup, and Section 7 concludes this
research work discussing some potential future extensions.

RELATED WORK
The main requirements for any deep learning tool to be usable
can be summarized into three major categories:

• Design and Visualization: This includes features such as
intuitive designing and construction of deep learning mod-
els, visualization of pre-designed models, and dashboarding
of model logs during training.

• Elimination of need to code: This includes features such
as automatic source code generation, support for multiple
libraries, and import from existing codebases.

• Production-ready capabilities: This includes features
such as efﬁciently training the model, support for easy in-
ference, and fast and scalable deployment.

Most of today’s tools are aimed at addressing one or at most
two of these categories. Table 1 summarizes the various tools

features. The concept of easy designing of models dates back
to Weka [17]. Weka was “no-code" method for designing tradi-
tional machine learning tasks having limited support for neural
networks. It provides a dashboard for visualizing training met-
rics and a Java-based API for inference. NVIDIA DIGITS [9]
was the ﬁrst deep learning speciﬁc tool to provide an user
interface to perform tasks like data loading and one-click train-
ing. However, it is only possible to train pre-built networks
and it does not have the capability to design models from
scratch. More recently, tools like Google’s Tensorboard [11]
is often used as a supplement to visualize Tensorﬂow models
and Netron [5] is used to visualize existing models coded in
various libraries.

Though these visualization tools help, there is still a need
to visually author a new model from scratch and not just
visualize an existing model. There is a need for an end-to-end
system aimed to seamlessly integrating the design and training
procedures. Sony’s Neural Network Console [7], Aetros [3],
Deep Cognition [2], Fabrik [1], and Machine UI [6] provide
an intuitive drag-and-drop based interface to design custom
deep learning models. They also have a compute backend to
train the designed models and present the training metrics in a
real-time dashboard. Although, new models could be designed
using the drag-and-drop interface, most of these do not allow
the corresponding execution ready code to be downloaded.
These tools use their own compute backend for training but
users often refuse to use such tools as uploading conﬁdential
data into these third party services is conﬂicting.

Thus it can be observed that, though there exists multiple tools
which perform one or more tasks sufﬁciently, there is a require-
ment to address the problem as a whole with an end-to-end
perspective. Therefore, we created DL-IDE which supports
visual authoring, generation of code in multiple existing li-
braries, and download design (NLDS) as well as code for DL
model development.

DEEP LEARNING IDE (DL-IDE) SYSTEM ARCHITECTURE
Software developers implement deep learning models by fol-
lowing the DL architecture details documented in research
papers, blogs among others. Commonly, these deep learn-
ing models and its parameters are expressed either as a ﬂow
diagram or in a tabular format, as shown in Figure 1a and
1b. These architectural information are transformed into a
program (code) by the developers. Currently, this coding task
is time taking, laborious, and requires expert level skill [25].
Motivated from these challenges, our aim is to design an IDE
for deep learning where models are implemented in the same
way as it is represented in documents and research papers;
visually. The design goals of the proposed DL-IDE would be
as follows:

1. A visual “no-code" designer to reduce the entry level barrier

for DL programming.

2. A drag-and-drop interface to design DL models as a combi-
nation of nodes (layers) and connections, corresponding to
visual designs represented in research papers.

3. A real-time validation service to verify the designed model

and provide speciﬁc feedback for easy debugging

(a) Flow ﬁgure [27]

(b) Tabular format [24]

Figure 1: Two popular methods for expressing deep learning
model design in research papers, presentations, and documents.
Developers typically implement the models by following these
representations.

4. An abstract DL-library independent representation of deep
learning model, to enable interoperability across libraries
and platforms.

5. Export executable code from the visually constructed DL

model in the library of user’s choice.

The DL-IDE system, shown in Figure 2, consist of four main
components: (i) visual drag-and-drop designer, (ii) abstract
intermediate representation generator, (iii) a real-time model
design validator, and (iv) code generator in multiple libraries.

Visual Designer
User interacts with our system through the designer com-
ponent, which consists of two sub-components. The “DL-
modeler" sub-component provides a drag-and-drop canvas for
the user to author a DL model. It also provides a palette of
available layers on the left and a section for displaying a de-
tailed documentation on the right as shown in Figure 4. This
palette groups layers performing similar function to ease devel-
opment of a model for a new user. A user can drag drag layers,
conﬁgure its properties, and connect them to create a deep
neural network in a language/library agnostic manner. When
a user selects a layer from the palette, the system provides
an initial default conﬁguration of the parameters, which user
can update based on the design needs. The system performs
real-time validation of the model being designed and displays
messages/errors and potential solutions on the right side sec-
tion of the “DL-modeler". The “Dashboard" sub-component
provides a real-time view of the model’s training progress.
The user can choose the metrics to be plotted as a graph in the
dashboard, view various parameters, and hyper-parameters of
the training experiment along with visualization of training
data.

Figure 2: The overall system architecture and the components of the proposed deep learning IDE, DL-IDE.

Figure 3: An example of the Neural Layer Deﬁnition Standard (NLDS) for the popular LSTM layer, along with their corresponding
Caffe Prototxt and Keras python code.

Figure 4: The visual drag-and-drop canvas user interface of the DL-IDE.

Neural Layer Deﬁnition Standard
A deep learning model is a sequential or non-sequential col-
lection of different transformations performed on the input
data to obtain the output. Each transformation, called as a
layer, is the fundamental building block of a deep learning
model. Neural Language Deﬁnition Standard (NLDS) is a
standard, abstract representation of deep learning model that
is agnostic of the underlying library. The NLDS deﬁnition of
a deep neural network is a JSON object contains three main
parts:

• Layer deﬁnitions: deﬁnes the parameters of every layer in

the network.

• Layer links: deﬁnes how the layers are connected to each

other.

• Hyperparameter deﬁnitions: deﬁnes model level param-
eters which deﬁne some characteristic properties of the
model as a whole.

These three parts of the NLDS captures all aspects of a model’s
design. Individual library transformers can be written on top of
the NLDS deﬁnition to import and export execution ready code
across multiple libraries. For example, a tensorﬂow code could
be parsed to extract the NLDS deﬁnition of the DL model, us-
ing which a PyTorch code can be generated. Thus, a lossless
conversion could be performed across libraries through NLDS,
as a model driven development strategy. An example NLDS
for the popular LSTM layer and its corresponding Caffe Pro-
totxt and Keras python code is shown in Fig. 3.

DL Static Design Validation
The validation component, validates the model being con-
structed in the “DL-modeler". For every update of the DL
model design in the drag-and-drop interface, the validation
component checks the correctness of the overall model. Any
warnings or errors are displayed as a pop-up on the validation
section of the user interface. User cannot progress to the next
stages of code download or training, if the constructed model
is not successfully validated. Validation of a DL design hap-
pens in ﬁve levels: (1) basic NLDS structure validation, (2)
layer level parameter validation, (3) static design validation
for ensuring valid next and previous layers for every layer,
(4) ﬂow design validation, ensuring the data ﬂow through the
model, and (5) platform (target library) speciﬁc validation. For
example, if a Convolution2D layer is added without providing
the number of ﬁlters, the validation component would prompt
to provide the compulsory parameters. If a Dense layer is
added after Convolution2D layer, the validation component
would prompt that a Dense could not be added after a Convo-
lution 2D layer, and also recommend a solution of adding a
ﬂatten layer in between.

Multiple Library Code Generation
Once the constructed model is validated, the user can either
opt to generate and download the source code of the model
in a desired library or push the model for training. In the
ﬁrst case, the source code for the model is generated in the
library of user’s choice for download. This gives the ﬂexibility
to the user to use this tool for authoring the model in their
preferred library of choice and train them in the environment
of their choosing. In the second case, the model is converted

into the preferred library’s code and pushed to the default
back-end GPU cluster for training. Currently, the tool support
three libraries namely TensorFlow, Keras, Pytorch for code
generation.

The GPU cluster can be considered as a pluggable extension to
the IDE and is not one of its integral part as it can be replaced
by any external cloud GPU service such as AWS8 or Google
Cloud9. The main purpose of this component is to train the
model on the data provided by the user. The “execution en-
gine" of this component contains GPU hardware and wrappers
for low-level ﬁrmware like CUDA which come out-of-the-box.
The “log manager" is a custom component which continuously
monitors the training logs for certain metrics identiﬁed by the
user. These metric values are streamed to the UI dashboard
and plotted as graphs. After the training is completed, the
trained model is deployed and an API is exposed to the user
for inference.

DESIGNING USER STUDY
To study the usability and the efﬁciency of the proposed visual
drag-and-drop programming paradigm for DL, we conducted
a user study to compare the proposed system with traditional
programming paradigm and other alternative visual program-
ming paradigms.

Different Programming Paradigms
It can be observed from Figure 1b that a DL model’s design
could be represented in a tabular format, as well. Hence, it
is worthwhile to study whether a visual tabular interface is
efﬁcient and easy for authoring DL models. To compare DL-
IDE with the tabular representation of designing deep learning
models, a visual tabular interface is designed as shown in
Figure 5. Overall in the user study, the participants were given
three different views to implement deep learning models:

1. View #1 - Code: Traditional coding method for imple-
menting deep learning models. As a common standard,
Microsoft Visual Studio Code 10 is used as the Python IDE.
The participants were allowed to use the DL library that
they are most ﬂuent with, among the following: Keras,
Tensorﬂow, PyTorch, Caffe.

2. View #2 - Tabular: Tabular way of designing a deep learn-

ing model, as shown in Figure 5.

3. View #3 - DL-IDE (drag-and-drop): The proposed sys-
tem to design a deep learning model like a graph structure
using a drag-and-drop interface, as shown in Figure 4.

To avoid any bias, the participants had no prior on the motive
of the experiments or on the view of interest.

Participants
The user study was conducted among 18 participants who are
students from different universities. All the participants are
required to have basic knowledge of developing deep learning
models, in addition, to being efﬁcient in python programming.

8https://aws.amazon.com/
9https://cloud.google.com/
10https://code.visualstudio.com/

Further, none of the participants had any prior afﬁliation with
any of the authors and the purpose of the study remained
anonymous.

The participants ﬁlled an qualitative survey providing demo-
graphic details and their technical competence along with
DL preferences. The participants comprised of 11 male and
7 female participants whose age range is between 19 − 24.
Furthermore, the participants were highly comfortable with
Python programming language and 15 participants rated them-
selves as 3 or more out of 5 in deep learning implementation.

To better characterise the outcome of our study, the 18 partic-
ipants are divided either as expert or intermediate based on
their answers to the following eight questions from the survey:

(A) Are you aware of Python language ? Ans: Yes/No

(B) How would you rate your comfort in Python? Scale: 1-5

(C) How would would rate your comfort in implementing Deep

Learning algorithms? Scale: 1-5

(D) Have you designed Deep Learning models as part of a

project and/or paper ? Ans: Yes/No

(E) How many deep learning models have you designed?

(F) How comfortable are you in designing Deep Learning?

Scale: 1-5

(G) Have you come across Deep Learning model in research

publications (papers)? An: Yes/No

(H) How many deep learning model designs have you come

across in research publications (papers) ?

An expertise score, S, is calculated for every user using all the
above eight information, with the equation below,

Expertise Score, S = A ∗ B + D ∗ (C + F) ∗ E + G ∗ H (1)

The median of the expertise score is computed and all those
participants above the median score are labeled experts while
those below are labeled intermediate. The expertise score
ranged between 19 − 264 with a median of 36. There were in
total 9 expert and 9 intermediate users in our study.

Experimental Procedure
The experiment involves participating users to implement three
deep learning model designs. Details of these models are listed
below as three tasks:

1. Task #1: Implementing a 13 layer deep convolutional neu-
ral network (CNN) model on ImageNet [15] image dataset
with Conv2D, Pool2D, TanH, ReLU, Flatten, Dense, and
Softmax as the set of unique layers.

2. Task #2: Implementing a 16 layer deep convolutional neu-
ral network (CNN) model on CIFAR-10 [21] image dataset
with Conv2D, Pool2D, ReLU, Flatten, Dense, and Softmax
as the set of unique layers.

3. Task #3: Implementing a 6 layer deep recurrent neural
network (RNN) model on text classiﬁcation dataset with

Figure 5: The tabular representation based UI system to design deep learning models.

Embedding, LSTM, Dense, and Softmax as the set of unique
layers.

To avoid any known model bias, popular deep learning models
were ignored for this study and the above three novel models
were designed from scratch. Based on the author’s experience
in deep learning, they are also of equal difﬁculty level in
implementation.

Each participant was asked to perform three experiments: Ex-
periment 1, Experiment 2, and Experiment 3 where, in each
experiment, they implemented one of the three tasks in one of
the three views. To counter for the learning effect, the task-
view combination for all 18 participants were randomly chosen
upfront. Overall, 54 experiments were conducted among 18
participants.

A time limit of 15 minutes was provided to perform each exper-
iment, and the participants were given the choice to continue
or give up if it goes beyond 15 minutes. An instruction sheet
with detailed verbose instructions of the implementation task
was provided in a written form before the start the task. A
demo video explaining the features of each view was played to
the participant just before performing the corresponding task.
Additionally, users had access to internet throughout the ex-
periment, and there were no restriction on referring to sources
in the internet to complete the task. Throughout the task, one
interviewer stayed in the room to help with infrastructural or
operational needs, however she did not indulge in any techni-
cal discussion with the participant. All participants were given
the same laptop and infrastructure to complete the task. Each
study lasted around 60 minutes and the participants were pro-
vided with refreshments. To increase the competitive nature
of the tasks, the top three participants were promised a reward
of 20 USD. The instructions sheets and videos, the qualitative
survery results and the task-view combination of all the 18
participants is available here https://dl-ide.github.io/.

At the end of each experiment, two different surveys were
conducted: (1) System Usability Scale (SUS) [14] to study

for usability of the corresponding view, and (2) NASA Task
Load Index (TLX) [18] to study the experimental task load.
Also, the time taken for the participant to complete a particular
experiment is noted along with the entire screen recording of
the activities.

RESULTS OF USER STUDY
The results of study are analyzed and summarized in this
section.

Analysis of Accuracy and Time Taken
Each of the 9 expert and 9 intermediate participants performed
one experiment in each of the three views: code, tabular, and
DL-IDE. We analzye the responses and results by answering
5 research questions.

RQ1: “Does the visual drag-and-drop view enable users to
implement the deep learning models more accurately?". The

Figure 6: Plot showing the successful attempts by 9 expert and
9 intermediate participants in each of the three views: code,
tabular, and DL-IDE.

(a) All experiments

(b) Only successful experiments

Figure 7: Plot showing the mean time duration by all users in doing in the experiments across the three different views: code,
tabular, DL-IDE. The restricted time provided to the participants is 15 minutes (900 seconds) though they were later given a choice
to take additional inﬁnite time to ﬁnish the task.

(a) Successful experiments

(a) All experiments

(b) Mean time duration

(b) Only successful experiments

Figure 8: Plot showing the successful attempts and the mean
time taken by 11 male and 7 female participants to perform
experiments in three different views: code, tabular, DL-IDE.

Figure 9: Plots showing the mean time duration taken by the
18 participants in doing the tasks in experiment 1, 2, 3 in all
the three views.

of the success outcome of the experiment, the mean time taken
for coding is much more than the visual methods of designing
deep learning models. The mean time taken for implementing
deep leaning models using either of visual programming view
is in the range of 8.9 − 11.8 minutes (536 − 705 seconds)
while for the traditional programming view the mean time
taken is 27.4 − 35 minutes (1646 − 2098 seconds). Though
the mean time taken in tabular view is similar to DL-IDE, the
success rate of designing accurate deep learning designs in the
DL-IDE view is much higher (more than 70%) as debugging
model designs is much more intuitive and natural.

RQ3: “Is DL-IDE suited well for both intermediate and expert
users in implementing deep learning models?".

From Figure 7a, it can be observed that the mean time duration
to implement deep learning models for intermediate partici-
pants (1646s) is much higher than for expert users (1245s), for
code view. However, using DL-IDE the difference in mean
time duration is reduced to 705s for intermediate users and
560s for expert users. It can also be observed that in DL-IDE,
the variance of time taken is comparable irrespective of user
expertise, showing that DL-IDE caters to all the users equally
irrespective of their prior expertise in deep learning.

RQ4: “Does participant’s gender affect the outcome of the
experiments?".

Figure 8a and Figure 8b capture the successful attempts and
the mean time duration in performing the experiments across
gender. The mean time spent by all the participants is similar
in all the views. Also, gender does not act as a biasing factor
in successful completion of the experiment as there is no
signiﬁcant difference across the gender.

RQ5: “Is there a learning bias displayed by the participants
based on the sequence in which tasks are performed?".

Figure 9a and Figure 9b attempts to address an important
question of whether the sequence in which the views are pre-
sented to the participant affect the mean time to complete the
experiment. Mean time across all the experiments is highly
similar for DL-IDE and tabular views demonstrating that the
order does not affect the performance. However, it can be
observed in Figure 9a that the mean coding time is higher if it
is presented as Experiment 1 compared to when it is presented
as Experiment 2 and Experiment 3. This can be attributed
to the human tendency to spend more time in completing the
task for the initial experiments than for the later experiments,
where there is a tendency to give up in lesser time. Figure 9b
shows that even in successful experiments, the order does not
affect the time performance in DL-IDE and tabular views. For
coding view, there were no successful attempts in Experiment
2 and Experiment 3.

System Usability Scale (SUS)
To study the usability of the three views, System Usability
Scale (SUS) [14] was used. It consists of a set of 10 questions
with every alternate question having a positive and negative
intent. Each question has ﬁve different choices ranging from
strongly agree to strongly disagree. SUS is known to work
with smaller sample sizes, as well. A SUS score of 68 is con-

Figure 10: Mean SUS score obtained for the three different
views: code, tabular, and DL-IDE.

accuracy of the task was veriﬁed by executing the implemented
deep learning model from each of the three views.

As observed from Figure 6, 17 of the 18 participants were able
to ﬁnish the task successfully using the DL-IDE view, while
only 4 participants were able to implement the task using the
code view (traditional programming) and only 8 participants
were successful with the tabular view. Note that this result
is despite providing inﬁnite time beyond the instructed 15
minutes to ﬁnish the experiment. Thus, it is safe to conclude
that almost 78% (14/18) participants gave up without being
able to complete the deep learning model implementation
using coding. Out of these 18 participants, 11 coded using
Keras, 5 using Tensorﬂow, 2 used PyTorch. Irrespective of the
choice of the implementation library, it can be observed that
programming view remained a challenge.

Another reason for the higher success rate in DL-IDE can be
attributed to the static validation component developed as a
part of our system. Manually observing the screen record-
ings of the experiments, we noted that more often participants
found it highly challenging to debug the error in their imple-
mented code and that majorly inﬂuenced them to give up. The
validation component provided easy guidance with precise
message and highlighted speciﬁc layers for the users to ﬁx
the bugs, improving the success rate for implementing deep
learning models in DL-IDE.

Also, preference for DL-IDE is supported by the qualitative
survey conducted prior to the experiments where the partici-
pants where asked the question, “When reading in research pa-
pers, what style of deep learning model representation would
you prefer?" with choices as (a) Tabular rows and columns,
or (b) Flow Figure as an Image, or (c) others. 15 of the 18
participants preferred deep learning models being represented
as a “Flow Figure" which is the representation in DL-IDE.

RQ2: “Can deep learning models be implemented much faster
using the visual drag-and-drop view?".

Figure 7a depicts the mean and the standard deviation for time
duration, spent by participants in performing the experiments
across different views. Figure 7b depicts the mean time taken
and the standard deviation of only those experiments which
were successfully completed by the participants. Irrespective

other views, as DL-IDE provides easy to use drag-and-drop
interface to create the deep learning models. The study also
illustrates the frustration of the participants while performing
the experiments, where less effort and less demand of mental
and physical activity leads users to less frustration. The mean
workload follows the same footprint as other workload ﬁgures
and based on overall score we can conclude code view has the
highest workload than the tabular view or DL-IDE view.

DESIGN IMPLICATIONS
The results obtained in the user study are in favour of the
proposed DL-IDE in terms of successful completion of tasks
(94%), time required to perform a task (9 − 12 minutes), sys-
tem usability (SUS score of 90), and least workload (NASA
TLX of 21). However, the obtained results may not be gener-
alizable and the design study had a few implications, summa-
rized as follows:

1. The user study is conducted using a set of 18 participants

from a restricted demography and age group.

2. The participants are students selected at random from var-
ious universities. The prerequisites for a student to par-
ticipate in the user study were proﬁciency in python and
minimum development knowledge in deep learning. Stu-
dents who had done a couple of projects in deep learning
turned out to be experts and those who have done only one
or two projects turned out to be intermediate in our group of
participants. However, researchers in deep learning could
be the actual set of experts and studies have to be conducted
using them to verify if similar results could be extrapolated.
With the existing user studies, it is safe to conclude that
a visual drag-and-drop based DL-IDE aids users in better
implementing deep learning models.

3. The primary purpose of this research paper is to method-
ically study and compare visual programming paradigm
(drag-and-drop) vs. traditional programming paradigm in
deep learning implementation. DL-IDE is one of the few
drag-and-drop frameworks in the literature for deep learning
implementation, with enhanced features such as (1) Neural
Language Deﬁnition Standard (NLDS), (2) static design
validation service, and (3) multiple library code genera-
tion. Comparing different drag-and-drop frameworks for
implementing deep learning models is out of scope for this
research work and is considered as a future study.

On the positive side, the results obtained from the studies
conducted in this research has some strong, impacting impli-
cations on the research and development in the deep learning
community. The major implications are summarized below:

1. Owing to the graphical structure of deep learning models, it
is established that a visual drag-and-drop framework could
be an efﬁcient platform for implementing deep learning
models compared to the traditional programming paradigm.
This encourages the developers of libraries such as Keras,
Tensorﬂow, PyTorch to align and support visual program-
ming frameworks.

2. For students and beginners, the drag-and-drop framework
provides an easy, smooth, and conﬁdent route to adapt deep

Figure 11: Plots describing the overall mean NASA TLX score
as well as the NASA TLX score for each of the six dimensions
for all the three views.

sidered average and any system with a SUS score of above 68
is considered usable. The SUS questionnaire was conducted
for every participant at the end of every experiment. Figure 10
indicates the mean SUS score computed for the different views
based on the user expertise. It can be observed that the coding
view has an average SUS score of 60 for the intermediate par-
ticipants and 68 for the experts based on their feedback. Thus,
even for experts the usability of the system is just average.
However, the average SUS score for DL-IDE is 90 and 89
for intermediate and experts respectively, the highest in our
studies. From our study, we can infer that the drag-and-drop
interface in DL-IDE can be considered as the highly usable
system for both intermediate and experts, alike.

NASA TLX Results
NASA Task Load Index (TLX) [18] is a popular tool used
to measure the perceived workload of a user after perform-
ing a speciﬁc task. The questionnaire is multidimensional,
measuring the workload impact across six different dimen-
sions. The participants were provided with the NASA TLX
The plot in Figure 11 captures the overall workload faced by
the participants averaged along the six different dimensions.
From the results obtained on the individual dimensions, we
observe that the mental demand such as looking, calculating,
and searching required by the code view is signiﬁcantly high
as users often have to refer documentation or check syntax or
perform layer size calculation. DL-IDE view has least demand
for mental strength as it provides easy to use interface for
fundamental deep learning functionalities. The physical de-
mands such as typing, scrolling, and clicking are less required
in DL-IDE and tabular view as compared to code view. Both
the visual programming views have lesser physical demand,
as they don’t involve much of typing and window switching.
Both the visual programming interfaces require less temporal
demand, as the time to create or implement layers and connect
them in these views are less. Further, participants were not
satisﬁed with their performance in code view and tabular view.
The key reason of high dissatisfaction is that they could not
complete the experiments in given time which we observed
from them as feedback post experiments. Effort required to
design a deep learning model in DL-IDE is less compared to

learning with very low initial learning curve. Additionally,
such visual tools could be used as effective teaching tools
in classrooms to intuitively explain the design choices in a
deep learning model.

3. With the growing requirement of having deep learning as
a skill for software engineers, industries are looking at up-
skilling hundreds (may be thousands) of their existing soft-
ware engineers and data scientists. DL-IDE could enable
this transition at industry level, democratizing deep learning
implementation for novice software engineers.

4. Existing implementation of research papers and algorithms
are mostly available in only a single library offering very
little scope for interoperability into other libraries. With the
aid of DL-IDE and abstract NLDS representation, standard-
ization of deep learning models could be obtained. Research
papers could make available their implementation in stan-
dard NLDS format and different users could generate the
same implementation in different libraries of their choice.
Furthermore, the ﬂow ﬁgure used in research papers could
be standardized as the visual drag-and-drop screenshot to
make research papers more uniform and easy to read.

CONCLUSION AND FUTURE WORKS
In the recent years, deep learning has been the driving force for
most of the popular AI applications such as speech recognition,
image processing, and natural language processing. Therefore,
a lot of aspiring developers, students, and enterprises are want-
ing to solve different problems using deep learning. However,
the democratization of deep learning is not truly achieved and
remains a tool for the experts because of the (1) high initial
learning curve, (2) lack of interaction across existing deep
learning libraries, and (3) need for theoretical deep learning
knowledge.

To address these challenges, in this research work we presented
DL-IDE, an intuitive drag-and-drop based user interface for
visually constructing deep learning models. The tool provides
an end-to-end development capability including model design-
ing from scratch, model design validation, code generation in
multiple libraries, model training to deployment, and model
inference. Further, we validated the usability of our system by
conducting comprehensive experiments with 18 participants
on three different tasks of equal difﬁculty using three different
set of tools (views). The participants were able to success-
fully complete the implementation task 94% of the times using
DL-IDE, however, only 22% of the times using the traditional
programming method with any library of their choice. On an
average, participants took about 9 − 12 minutes to implement
the tasks using DL-IDE, while successful participants took
more than 27 minutes to implement the tasks using program-
ming. DL-IDE obtained a System Usability Scale (SUS) score
of 90 compared to a score of 68 for programming, establishing
the ease and usability of DL-IDE. DL-IDE obtained the least
NASA-TLX workload index of 21 compared with a index
value of 55 for traditional programming.

studies could be conducted on a more diverse set of partici-
pants and experts to obtain more generalizable conclusions.

REFERENCES

1. 2018. Cloud-CV/Fabrik: Collaboratively build, visualize,

and design neural nets in browser.
https://github.com/Cloud-CV/Fabrik. (2018). (Accessed
on 05/11/2018).

2. 2018. DeepCognition - Become an AI-Powered

Organization Today. http://deepcognition.ai/. (2018).
(Accessed on 05/11/2018).

3. 2018. Home // AETROS - enterprise deep learning

platform, tools and services. https://aetros.com/. (2018).
(Accessed on 05/11/2018).

4. 2018. Intel nGraph - Intel AI.

https://ai.intel.com/intel-ngraph/. (2018). (Accessed
on 05/15/2018).

5. 2018. lutzroeder/Netron: Visualizer for deep learning and

machine learning models.
https://github.com/lutzroeder/Netron. (2018).
(Accessed on 05/11/2018).

6. 2018. Machine UI. https://machineui.co/. (2018).

(Accessed on 05/11/2018).

7. 2018a. Neural Network Console. https://dl.sony.com/.

(2018). (Accessed on 05/11/2018).

8. 2018b. Neural Network Exchange Format. https://www.
khronos.org/registry/NNEF/specs/1.0/nnef-1.0.pdf.
(2018). (Accessed on 05/15/2018).

9. 2018. NVIDIA DIGITS | NVIDIA Developer.

https://developer.nvidia.com/digits. (2018). (Accessed
on 05/11/2018).

10. 2018. ONNX. https://onnx.ai/. (2018). (Accessed on

05/15/2018).

11. 2018. TensorBoard: Visualizing Learning | TensorFlow.

https://www.tensorflow.org/programmers_guide/
summaries_and_tensorboard. (2018). (Accessed on
05/11/2018).

12. Anelia Angelova, Alex Krizhevsky, Vincent Vanhoucke,
Abhijit S Ogale, and Dave Ferguson. 2015. Real-Time
Pedestrian Detection with Deep Network Cascades.. In
BMVC, Vol. 2. 4.

13. Mariusz Bojarski, Davide Del Testa, Daniel

Dworakowski, Bernhard Firner, Beat Flepp, Prasoon
Goyal, Lawrence D Jackel, Mathew Monfort, Urs Muller,
Jiakai Zhang, and others. 2016. End to end learning for
self-driving cars. arXiv preprint arXiv:1604.07316
(2016).

14. John Brooke and others. 1996. SUS-A quick and dirty

usability scale. Usability evaluation in industry 189, 194
(1996), 4–7.

As there exists multiple drag-and-drop frameworks in the liter-
ature, it would be interesting to compare and study the multiple
frameworks in terms of efﬁciency and usability. Also, user

15. J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L.

Fei-Fei. 2009. ImageNet: A Large-Scale Hierarchical
Image Database. (2009).

autonomous aerial vehicles with mpc-guided policy
search. In Robotics and Automation (ICRA), 2016 IEEE
International Conference on. IEEE, 528–535.

16. Andre Esteva, Brett Kuprel, Roberto A Novoa, Justin Ko,
Susan M Swetter, Helen M Blau, and Sebastian Thrun.
2017. Dermatologist-level classiﬁcation of skin cancer
with deep neural networks. Nature 542, 7639 (2017), 115.

17. Eibe Frank, Mark A. Hall, and Ian H. Witten. 2016. The
WEKA Workbench. Online Appendix for "Data Mining:
Practical Machine Learning Tools and Techniques",
Morgan Kaufmann, Fourth Edition. (2016).

18. Sandra G Hart and Lowell E Staveland. 1988.

Development of NASA-TLX (Task Load Index): Results
of empirical and theoretical research. In Advances in
psychology. Vol. 52. Elsevier, 139–183.

19. Brody Huval, Tao Wang, Sameep Tandon, Jeff Kiske,
Will Song, Joel Pazhayampallil, Mykhaylo Andriluka,
Pranav Rajpurkar, Toki Migimatsu, Royce Cheng-Yue,
and others. 2015. An empirical evaluation of deep
learning on highway driving. arXiv preprint
arXiv:1504.01716 (2015).

20. Minsuk Kahng, Pierre Y. Andrews, Aditya Kalro, and

Duen Horng Chau. 2017. ActiVis: Visual Exploration of
Industry-Scale Deep Neural Network Models. CoRR
abs/1704.01942 (2017). http://arxiv.org/abs/1704.01942

21. Alex Krizhevsky, Vinod Nair, and Geoffrey Hinton. 2014.

CIFAR-10 (Canadian Institute for Advanced Research).
(2014). http://www.cs.toronto.edu/~kriz/cifar.html

22. Fausto Milletari, Nassir Navab, and Seyed-Ahmad
Ahmadi. 2016. V-net: Fully convolutional neural
networks for volumetric medical image segmentation. In
3D Vision (3DV), 2016 Fourth International Conference
on. IEEE, 565–571.

23. Brad A Myers. 1990. Taxonomies of visual programming
and program visualization. Journal of Visual Languages
& Computing 1, 1 (1990), 97–123.

24. Omkar M Parkhi, Andrea Vedaldi, Andrew Zisserman,

and others. 2015. Deep Face Recognition.. In BMVC,
Vol. 1. 6.

25. Anush Sankaran, Rahul Aralikatte, Senthil Mani, Shreya
Khare, Naveen Panwar, and Neelamadhav Gantayat.
2017. DARVIZ: Deep Abstract Representation,
Visualization, and Veriﬁcation of Deep Learning Models.
In Proceedings of the 39th International Conference on
Software Engineering: New Ideas and Emerging Results
Track (ICSE-NIER ’17). IEEE Press, Piscataway, NJ,
USA, 47–50. DOI:
http://dx.doi.org/10.1109/ICSE-NIER.2017.13

26. Terrence Joseph Sejnowski. 2018. The Deep Learning

Revolution. MIT Press.

27. Yi Sun, Xiaogang Wang, and Xiaoou Tang. 2014. Deep
learning face representation from predicting 10,000
classes. In Proceedings of the IEEE Conference on
Computer Vision and Pattern Recognition. 1891–1898.

28. Tianhao Zhang, Gregory Kahn, Sergey Levine, and Pieter

Abbeel. 2016. Learning deep control policies for

