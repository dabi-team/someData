5
1
0
2

l
u
J

9

]

V
C
.
s
c
[

1
v
0
8
3
2
0
.
7
0
5
1
:
v
i
X
r
a

Learning Structured Ordinal Measures for Video based Face Recognition

Ran Hea, Tieniu Tana, Larry Davisb, and Zhenan Suna
aInstitute of Automation, Chinese Academy of Science. Beijing, China 100190.
bUniversity of Maryland. College Park, MD, USA 20742.
{rhe,tnt,znsun}@nlpr.ia.ac.cn, lsd@umiacs.umd.edu

Abstract

This paper presents a structured ordinal measure method
for video-based face recognition that simultaneously learns
ordinal ﬁlters and structured ordinal features. The prob-
lem is posed as a non-convex integer program problem that
includes two parts. The ﬁrst part learns stable ordinal ﬁl-
ters to project video data into a large-margin ordinal space.
The second seeks self-correcting and discrete codes by bal-
ancing the projected data and a rank-one ordinal matrix in
a structured low-rank way. Unsupervised and supervised
structures are considered for the ordinal matrix. In addi-
tion, as a complement to hierarchical structures, deep fea-
ture representations are integrated into our method to en-
hance coding stability. An alternating minimization method
is employed to handle the discrete and low-rank constraints,
yielding high-quality codes that capture prior structures
well. Experimental results on three commonly used face
video databases show that our method with a simple vot-
ing classiﬁer can achieve state-of-the-art recognition rates
using fewer features and samples.

1. Introduction

Video-sharing websites are a fast-growing platform that
allows internet users to distribute their video clips. There
are often a large number of face videos in these websites.
How to index, retrieve, and classify these face videos has
become an active research topic in the area of video-based
face recognition (VFR). Current VFR methods often per-
form recognition based on hundreds or thousands of ﬂoat-
ing point features, and store almost every face sample from
a video clip. Since there can be (many) thousands of face
samples in a video clip, high-dimensional dense features
and large-scale registered samples result in tremendously
large time and space complexity, which becomes a compu-
tational bottleneck when applying VFR methods to video-
sharing websites.

Recently, binary code representations have drawn much
attention in biometric recognition [5][21][27] and large

scale image retrieval [26][13][24]. Among these binary
coding methods, codes constructed from ordinal measures
(OM) are one representative method. Ordinal measures [31]
are common in human perceptual judgments.
It is easy
and natural for humans to rank or order the heights of two
persons, although it is hard to estimate their precise differ-
ences [33]. Ordinal measures were originally used in social
science [31] and then introduced to computer vision.

In biometrics, an OM is deﬁned as the relative ordering
of some property - for example, the average brightness of
two adjacent regions (with 1 coding A ≻ B and 0 cod-
ing A ≺ B) or the relative ordering of two color channels
within the same region. Ordinal ﬁlters with a number of
tunable parameters, are methods to analyze the ordinal mea-
sures of image features. The Haar wavelet and quadratic
spline wavelet can be regarded as typical ordinal ﬁlters. Or-
dinal features are the binary codes of image features ob-
tained by thresholding ordinal ﬁlters. Fig. 1 plots a simple
illustration of OM.

In prior work, the set of handcrafted ordinal ﬁlters is cho-
sen to correspond to some family of coherent patterns - like
Gabor ﬁlters. The space of ordinal ﬁlters can therefore be
quite large as the tunable parameters - scale, frequency, ori-
entation - are varied, each giving rise to a potential ordinal
feature. Different feature selection methods [32][33][40]
have been used for OM to select a stable subset from the
over-complete ordinal features. The term ’stable’ indicates
that the ﬂoating point features generated by an ordinal ﬁlter
from the same class are expected to have large margins so
that the corresponding ordinal features (binary codes) are
robust to intra-class variations during binarization.

Motivated by the success of OM in iris [32], palm-
print [33] and face recognition [5], we present what we re-
fer to as a structured ordinal measure (SOM) method for
video-to-video face recognition. Different from previous
handcrafted OM methods, SOM simultaneously learns or-
dinal ﬁlters (SVM’s) and structured ordinal features (binary
codes) from video data as shown in Fig. 1. Considering that
face appearances in video clips contain several facial varia-
tions and are similar in adjacent frames, we design the ordi-

1

 
 
 
 
 
 
Figure 1. An illustration of structured ordinal measures. Ordinal measure of visual relationship between two regions [32][33]. Previous
OM methods apply feature selection methods to select over-complete ordinal features (binary codes) that are generated by handcrafted
ordinal ﬁlters. SOM simultaneously seeks ordinal ﬁlters and optimal ordinal features in a data-driven way, makes the learned features
low-rank and enforces an optimal ordinal matrix for classiﬁcation. In SOM, one binary code of a sample can be corrected according to the
codes of similar samples.

nal features of SOM to be stable and self-correcting binary
codes. Stability indicates that the learned ordinal features
are required to have large margins and to be clustered. The
self-correcting character indicates that binary code of one
frame depends not only on its corresponding ordinal ﬁlter
(or coding function) but also on the binary values of sim-
ilar (typically nearby in time) face samples. Because face
images in a video clip often lie in a union of multiple linear
subspaces [7][43], the features (binary code) assigned to the
subset of faces from a single linear subspace should be simi-
lar. These binary codes can be potentially corrected by each
other through a low-rank constraint on the matrix of con-
structed codes. One of the main advantages of our method
is that it simultaneously reduces the number of dense fea-
tures and eliminates redundant samples1.

We will formulate the SOM problem as a non-convex in-
teger program problem that mainly includes two parts. The
ﬁrst part learns stable ordinal ﬁlters to project video data
into a space in which the ﬁltered data are separable with
a maximum margin. This can be viewed as an instance of
maximum margin clustering (MMC) [41]. The second ﬁnds
self-correcting binary codes by balancing the projected real-
value data and a rank-one ordinal matrix in a structured
low-rank way. Unsupervised and supervised structures are
considered for the ordinal matrix. We also integrate CNN
feature representations into our method to enhance stabil-
ity. An alternating optimization method provides an efﬁ-
cient discrete solution to deal with the discrete and low-rank
constraints imposed on binary ordinal features. In addition,
a simple voting classiﬁer with a self-correcting process is

1Getting rid of redundant samples is important during both training and
testing. In a video clip, the face can remain unchanging for long periods of
time and that would bias the models towards that appearance.

proposed to efﬁciently compress and classify video clips.
Experimental results on three commonly used face video
databases show that our SOM method can achieve state-of-
the-art recognition results using fewer features and samples.
Compared to previous binary coding methods for still im-
ages (face or iris), SOM more efﬁciently utilizes the low-
rank property of video data and hence is potentially useful
for VFR problems.

There are three major contributions of this work:

1) By employing the optimal ordinal matrices as output
structures, SOM encourages ordinal features from the same
class to have similar binary codes. To the best of our knowl-
edge, SOM is the ﬁrst algorithm that learns binary codes (or
hashing) using output structures.

2) Assuming that face images of a video clip lie in
a union of linear subspaces, we propose a self-correcting
method to discretely binarize both gallery and probe videos.
Our method utilizes the continuous information in videos
and hence is effective for VFR tasks.

3) As a by-product of SOM, we show that using a sim-
ple voting classiﬁer improves over competing and com-
plex classiﬁcation models on ﬁne grained datasets like the
YouTube Celebrities dataset and offers an impressive com-
pression ratio of CNN ﬂoating point features (20% face
samples and 64-bit binary codes).

The rest of this paper is organized as follows. We brieﬂy
review some recent advances on binary coding methods in
Section 2. In Section 3 and Section 4, we present the de-
tails of SOM and the optimal ordinal matrices respectively.
Section 5 provides experimental results, prior to summary
in Section 6.

2. Related work

Since OM methods are an instance of binary appearance
features, we brieﬂy review some recent advances on binary
coding methods.

2.1. Biometric recognition

In biometrics, binary feature representation methods of-
ten focus on directly computing local image patches by the
ﬁlters to generate binary codes. Local binary patterns (LBP)
and ordinal measures are two representative binary features.
There are many variations of these two features [5][21]. The
deﬁnition and properties of OM in the context of biometrics
can be found in [32].

Although OM’s has been successfully applied to biomet-
rics, there are still two open issues for OM. The ﬁrst issue is
the design of ordinal ﬁlters. The existing ordinal ﬁlters are
often handcrafted. But handcrafted ordinal ﬁlters are too
simple to represent complex human vision structures [23].
In addition, to improve stability and accuracy, these ﬁlters
often contain a large number of parameters based on dis-
tance, scale and location, resulting in a potential feature set
of OM. This naturally leads to the second issue, i.e., how to
select the optimal set of ordinal features. Although various
feature selection methods [32][40][33] have been employed
to improve selection results, it is still difﬁcult for a feature
selection algorithm to select the optimal set from the over-
complete set of OM.

Recently, data-driven binary feature methods, which
learn local image ﬁlters from data, have drawn much atten-
tion. Cao et al. [4] utilized unsupervised methods (random-
projection trees and PCA trees) to learn binary represen-
tations. Lei et al. [21] proposed a LBP-like discriminant
face descriptor (DFD) by combining image ﬁltering, pat-
tern sampling and encoding. Chan et al. [6] combined cas-
cade PCA, binary code learning and block-wise histograms
to learn a deep network. Lu et al. [27] proposed a com-
pact binary face descriptor (CBFD) to remove the redun-
dancy information of face images. Although these methods
indeed boost recognition performance on some challenging
databases, their learned features are often high dimensional.
For example, the dimensionality of histogram feature vec-
tors of DFD and CBFD are 50,176 and 32,000 respectively.
High dimensional and dense representations make these
data-driven methods not applicable to VFR problems.

2.2. Image retrieval

Learning binary codes (’hashing’) has been a key
step to facilitate large-scale image retrieval.
In im-
age retrieval, the terminology ’hashing’ refers to learning
compact binary codes with Hamming distance computa-
tion. Similarity-sensitive hashing or locality-sensitive hash-
ing algorithms [38][19], graph-based hashing [25], semi-
supervised learning [34], support vector machine [28][30],

[24] and
Riemannian manifold [22], decision trees
deep learning [13][39] have been studied to map high-
dimensional data into a low-dimensional Hamming space.
The authors in [25][30] argued that the degraded perfor-
mance of hashing methods is due to the optimization proce-
dures used to achieve discrete binary codes. Hence [25][30]
tried to enforce binary constraints to directly obtain discrete
codes [25][30]. A brief review of hashing methods for im-
age search can be found in [13][35].

These hashing methods are often used for image search
and retrieval but they may not achieve the highest accuracy
for VFR problems. For example, the constraints in [25]
maximize the information from each binary code over all
the samples in a training set. However, adjacent face sam-
ples in a video clip often have nearly the same appearance
so that these samples can have similar binary codes. In ad-
dition, to the best of our knowledge, there is no existing
hashing methods that address image-set problems [8].

3. Structured ordinal measures (SOM)

3.1. Motivation

Consider a training set X from C classes, which consists
of n biometric samples xj (1 ≤ j ≤ n) in a high dimen-
sional Euclidean space Rd. The goal of previous OM meth-
ods is to identify ordinal ﬁlters over X to nonlinearly map
each xj to m ordinal features (an m-bit binary code). Since
ordinal ﬁlters typically have a number of tunable parame-
ters and so determine a huge set of possible ordinal features,
various feature selection methods have been used to select
the m ordinal features. The selected ordinal features of all
samples form a binary matrix B = [b1, . . . , bn] ∈ Rm×n,
referred to as an ordinal matrix. Previous OM methods se-
lect ordinal ﬁlters one by one (using a greedy approach) and
hence neglect the output structure of ordinal features. For
example, video data are often low-rank.

In biometrics, since intra-class variations of biometric
samples are often very large, good ordinal measures should
generate similar binary codes for the samples from one sub-
ject. In addition, a large difference between two quantities
will result in more stable binary features. For example, the
greater the color difference between two image regions, the
more easily humans order their relative brightness (1 or 0);
and the greater the height difference between two persons,
the more easily humans rank their relative heights.

To obtain stable ordinal features, we introduce the fol-

lowing minimization problem for OM,

min
W,ξ,B

µξ + λ1 kW k2 +

kBck∗

Pc

(1)

s.t. Bij(wT

i Xj) ≥ 1 − ξij ,
ξij ≥ 0, Bij ∈ {−1, 1}

where µ and λ1 are constants, and k.k∗ denotes the matrix

trace norm (i.e., the sum of its singular values). Bc repre-
sents all ordinal features from the c-th class. The parameter
matrix W = [w1, . . . , wm] ∈ Rd×m represents a set of or-
dinal ﬁlters. As deﬁned in Section 2, a parameter matrix
W contains a set of ordinal ﬁlters only if W can result in
consistent orders for the samples from the same class, e.g.,
W T X generates an ordinal matrix as in Fig 2. In contrast
to the binary coding methods [32][21][27] that are based on
local image patches, (1) directly uses the whole image as an
input to ﬁnd compact codes2. More important, (1) aims to
simultaneously seek ordinal ﬁlters (W ) and optimal ordinal
features (B).

The low-rank constraint in (1) encourages the ordinal
features from the same class to be correlated. This con-
straint reduces the redundancy of video data and corrects
some binary codes whose corresponding values (W T X) are
close to SVM’s separating hyperplanes. We also want to
enforce that the learned B is close to the optimal ordinal
(binary) matrix for classiﬁcation, resulting in the following
minimization problem,

min
W,ξ,B
s.t. Bij(wT

µξ + λ1 kW k2 +

2
kBck∗ + λ2 kB − Sk
F (2)

Pc

i Xj) ≥ 1 − ξij , ξij ≥ 0, Bij ∈ {−1, 1}

where S ∈ Rm×n is a prior ordinal matrix that deﬁnes a
desired output structure for ordinal features. We postpone
discussion of the design of S until Section 4. Since the
OM problem in (2) imposes an output structure on ordinal
ﬁlter learning, we refer to the problem in (2) as learning a
structured ordinal measure.

Even without the structured low-rank constraint, (2) is
difﬁcult to solve [41]. Unlike supervised SVM that can
be formulated as a convex optimization problem, (2), even
without the structured low-rank constraint, is still a non-
convex integer optimization problem. It is an instance of
maximum margin clustering [41]. To simplify the mini-
mization of (2), we relax (2) by introducing an equality con-
straint on B as follows,

min µξ + λ1 kW k2 +

Pc

kBck∗ + λ2 kB − Sk

2
2
F + kEk
F

s.t. B = W T X + E, Bij ∈ {−1, 1} ,

(3)

Bij(wT

i Xj) ≥ 1 − ξij , ξij ≥ 0

where E ∈ Rm×n is an error term to reduce the loss dur-
2
2
ing binarization. Since kB − Sk
F , (3)
F =
actually seeks discrete binary codes by balancing ﬂoating
point data W T X and a rank-one ordinal matrix Sc in a
structured low-rank way.

Pc kBc − Sck

2In face recognition, dividing a face image into small patches can cap-
ture nonlinear facial variations well and so improves recognition rates. The
learned ﬁlters in (1) can also be applied to local patches as in previous bi-
nary coding methods.

Our SOM formulation in (3) has two major advantages:
1) the introduction of the low-rank constraint and error term
makes SOM more ﬂexible during binarization. The learned
binary codes depend on their corresponding ﬂoating point
values as well as prior structures. Different from the binary
codes that are directly generated by ordinal ﬁlters or hashing
functions, the binary codes of SOM can be self-corrected by
the structure constraints, resulting in self-correcting codes.
2) Since Sc is a rank-one matrix, λ2 plays the role of con-
trolling the number of learning samples. The rank-one ma-
trix indicates that there is only one unique sample in this
matrix. The larger the value of λ2, the more Bc resem-
bles Sc. In practice, the rank of Bc will be larger than one
because a face video clip often contains several face varia-
tions.

3.2. Optimization

The optimization problem in (3) is a hard computational
problem (non-convex integer optimization), which belongs
to the class of maximum margin clustering problems [41].
Fortunately, we do not need to ﬁnd the global minimum be-
cause local minima produce good ordinal features. Hence
we can decompose the non-convex problem in (3) into sub-
problems as in MMC. A local minimum can be obtained
by solving a series of SVM training and binary code learn-
ing problems. An overview of our iterative algorithm is as
follows.

First, ﬁxing variables B and E, we minimize (3) w.r.t.
variables W and ξ, resulting in a multiple linear SVM prob-
lem in (4) (one for each ordinal feature) [10]. To learn the
i-th SVM 3, the columns of X and the elements of the ith
row of B are used as training data and labels respectively.

µξ + λ1 kW k2

(4)

min
W,ξ
s.t. Bij (wT

i Xj) ≥ 1 − ξij, ξij ≥ 0

Second, ﬁxing variables W and ξ, (3) takes the following
form w.r.t. B and E,

min
B,E Pc

kBck∗ + λ2 kB − Sk

2
F + kEk

2
F

(5)

s.t. B = A + E, Bij ∈ {−1, 1}

where A = W {t+1}T X. By substituting the equality con-
straint into the objective function of (5), we can reformulate
(5) as follows,

2
kA − Bk
F +

min
B

Pc

2
kBck∗ + λ2 kB − Sk
F

(6)

s.t. Bij ∈ {−1, 1}

Since ||.||2
F is separable, the solution of (6) can be indepen-
dently obtained by minimizing the following subproblem

3The ℓ1 regularized linear SVM is implemented by LIBLINEAR:

http://www.csie.ntu.edu.tw/˜cjlin/libsvm

for each class c,

3.3. Classiﬁcation

kAc − Bck

2
F + kBck∗ + λ2 kBc − Sck

2
F

(7)

min
Bc

s.t. Bc

ij ∈ {−1, 1}

To minimize the low-rank problem in (7), we ﬁrst need to
introduce a variational formulation for the trace norm [14],

Lemma 1 Let B ∈ Rm×n. The trace norm of B is equal
to:

kBk∗ = 1

2 inf
L≥0

tr

BT L−1B
(cid:0)

(cid:1)

+ tr(L)

(8)

and the inﬁmum is attained for L = (BBT )1/2.

Using this lemma, we can reformulate (7) as,

min
Bc

min
L≥0

kAc − Bck

2

F + tr(BcT L−1Bc)

(9)

2
+λ2 kBc − Sck

F + tr(L) s.t. Bc

ij ∈ {−1, 1}

The problem in (9) can be alternately minimized. When L
is ﬁxed, we can use the discrete cyclic coordinate descent
method to obtain Bc bit by bit. For simplicity, we develop
a simple and direct method to ﬁnd Bc. That is, disregarding
the integer constraint, the solution of Bc takes the following
form by setting the derivative of (9) w.r.t. Bc equal to zero,

Bc = ((1 + λ2)I + L−1)\(Ac + λ2Sc).

(10)

Given a ﬂoating point Bc in one iteration, we can use the
sign function sgn(.) to obtain binary-value sgn(Bc). Ex-
perimental results show that the learned binary codes are
good enough for VFR. Algorithm 1 summarizes the pro-
cedure to learn structured ordinal ﬁlters. λ2 is set to 0.1
throughout this paper.

Algorithm 1: Learning structured ordinal ﬁlters

Input: Data matrix X ∈ Rd×n and ordinal matrix

S ∈ Rm×n

Output: Ordinal Filters W ∈ Rd×m

1: repeat
2:

Train m linear-SVMs to update W using Bt−1 as
training labels.
Compute A = {W t}T X.
repeat

Compute L = (BcBcT )1/2.
Compute Bc via (10).
Let Bc = sgn(Bc).

3:
4:

5:

6:
7:

8:

until The variation of B is smaller than a threshold.
t=t+1.

9:
10: until The variation of B is smaller than a threshold.

When applying SOM (or binary code learning methods)
to biometric recognition, SOM must generate ordinal fea-
tures for any data sample beyond the sample points in the
training set X. Given a new probe dataset X p, a hashing
algorithm H with parameter W typically applies the sign
W (X p) to obtain
function sgn(.) to the hashing function f H
W (X p)).
the binary codes [25][30], i.e., BH = sgn(f H

VFR can be viewed as an image-set classiﬁcation/retrival
problem [8]. The samples in a probe (or gallery) dataset are
from a video clip and so have a low-rank structure. Hence,
instead of using the sign function, we propose a low-rank
method to construct the binary codes for a probe video as
follows,

2

F + kBk∗o
B nkEk
min
W (X p) + E, Bij ∈ {−1, 1}

s.t. B = f H

(11)

Compared to directly using the sign function sgn(.) to ob-
tain binary codes, (11) utilizes a low-rank prior to ﬁnd bi-
nary codes. This makes the binary codes B not only depend
on the function f H
W (.). The values in B can be potentially
changed (or corrected) by each other due to the low-rank
constraint. (11) is a sub-problem of (7) when λ2 is set to
zero. Hence (11) can be alternatively minimized as (7).

Given the binary codes constructed from (11), a simple
nearest neighbor classiﬁer for each unique code in B (since
many samples can be mapped to the same code by the op-
timization) with voting is used as classiﬁer to report recog-
nition rates. The class label of the majority class in a video
sequence is taken as the ﬁnal class label of this sequence.
In addition, since the low-rank constraint in (11) tends to
make the column samples in B correlated, it also tends to
reduce the number of different samples in B. We intro-
duce the term compression ratio of samples for VFR, i.e.,
compression ratio = the number of unique samples/ the total
number of samples. A lower compression ratio of an algo-
rithm indicates that the algorithm needs less storage space
(and as a consequence less computational time).

In addition, since there is no a rank-one constraint in (11)
(compared to (2)), compression ratio will tend to be high as
the number of desired bits increases. If some priors of the
rank of a video clip are given or a lower compression ratio
is required, we can further impose a rank constraint on (11),
resulting in the following minimization problem,

W (X p) − B
f H

min

B (cid:13)
(cid:13)

2
(cid:13)
(cid:13)

F

s.t. rank(B) ≤ r, Bij ∈ {−1, 1}

(12)

where rank(.) is the matrix rank operator and r is con-
stant. The rank constraint in (12) makes the rank of B is
smaller than r. That is, all binary samples can be linearly

represented by r binary vectors. As a result, the number of
unique samples is potentially related to r.

4. Ordinal matrices for classiﬁcation

In this section, we discuss the design of the optimal ordi-
nal matrices in (2). Then we discuss combining deep feature
representation to improve the stability of SOM.

4.1. The optimal ordinal matrix

We begin the study of the optimal ordinal matrix S for
(2) with a two-class problem. We expect that all intra-class
and inter-class sample pairs of binary codes are well sepa-
rated with a large margin, i.e.,

J(B) = 1

µ1 X
ci6=cj

kbi − bjk0 − 1

µ2 X
ci=cj

kbi − bjk0

(13)

where B = [b1, . . . , bn] ∈ Rm×n is a binary matrix, µ1
and µ2 are the numbers of extra-class and intra-class pairs
respectively, and k.k0 is the counting norm (i.e., the number
of nonzero entries in a vector or matrix). Each row of BT
corresponds to the binary code of one data item. The ﬁrst
term of (13) rewards items from difference classes having
large Hamming distance, while the second term penalizes
items from the same class having small Hamming distance.
The maximization of J(B) is NP-hard. By analyzing J(B),
we make the following two observations on its optimal so-
lution,

Proposition 1 The maximum value of J(B) is equal to the
number of bits (m), i.e., maxB J(B) ≤ m.

Proof. According to the deﬁnition of the ℓ0 norm, we can
easily derive that maxB(J(B)) < m. In addition, when ˆB
satisﬁes,

a) For ∀i, j, k and ci

6= cj,

if bik

6= bjk,

then

1
λ1 Pci6=cj

1
λ2 Pci=cj

kbi − bjk0 = m;

kbi − bjk0 = 0,

b) For ∀i, j, k and ci = cj,

if bik = bjk,

then

we obtain J( ˆB) = m (Fig. 2 (a) gives an example of ˆB).
Hence maxB J(B) ≤ m.

Proposition 2 If there exists a ˆB such that J( ˆB) = m, the
ˆB satisﬁes the following two conditions. (a) All the samples
in each class have a unique binary code. (b) The sample
code of one class is orthogonal to that of the other class.
Proof. If ci = cj and bik 6= bjk, then
kbi − bjk0 > 0

Pci=cj

so that J(B) < m. Since bik ∈ {0, 1} and kbi − bjk0 = m
for ci 6= cj, bT
i bj = 0. Hence bi is orthogonal to bj when
ci 6= cj and J(B) = m.

(a)

(b)

(c)

Figure 2. Three types of the optimal ordinal matrices. (a) The opti-
mal ordinal matrix for a two-class problem. (b) Unsupervised ordi-
nal matrix constructed via appearance information. Binary codes
of all samples from the same class are arbitrary but unique and
identical. (c) Supervised ordinal matrix via the spectral matrix of
linear discriminant analysis [3].

From Propositions 1 and 2, we can easily obtain the
optimal ordinal matrix for a two-class problem as shown
in Fig. 2 (a). Previous ordinal feature selection meth-
ods [32][33] actually select ordinal ﬁlters one by one so that
the selected ﬁlters generate codes like in Fig. 2 (a). When
there are multiple classes, the problem of determining the
optimal binary codes becomes complex. Inspired by Propo-
sitions 1 and 2, we consider two types of ordinal matrices
to approximate the optimal ordinal matrix (shown in Fig. 2
(b)-(c)).

For the unsupervised ordinal matrix, we just require that
the binary codes of each class be unique. There are many
ways to generate informative binary codes for this case, e.g.,
random binary codes and Hadamard codes [16]. Since or-
dinal ﬁlters perform learning based on human face appear-
ances, we also expect that the unsupervised ordinal matrix
would capture useful appearance information of video data.
To accomplish this, we apply the unsupervised version of
Iterative Quantization (PCA-ITQ) [12] to the mean faces
of each class to generate the corresponding unique binary
code for each class. Then, the unsupervised ordinal matrix
contains appearance information while the binary codes of
different classes are largely uncorrelated.

For the supervised ordinal matrix, we simply employ
the spectral matrix of linear discriminant analysis [3] (the
regression target of multi-class linear regression). In this
spectral matrix, the binary codes of the samples from any
one class have just one bit set, which deﬁne the orders of a
class. Since this spectral matrix contains discriminative in-
formation, the ordinal matrix will contain supervised infor-
mation if this spectral matrix is used as the ordinal matrix.
However, the code length of this spectral matrix can be only
C. If code lengths larger than C are needed, we can obtain
longer binary codes by combining the spectral matrix with
the unsupervised ordinal matrix.

4.2. Deep Feature Representations

Since there are large variations of intra-class samples
in uncontrolled VFR environments, it is often difﬁcult to
use one type of local appearance features to obtain satisfac-
tory recognition results. Hence, biometric researchers of-
ten combine several local feature to improve generalization
ability and recognition performance.
In [44], Gabor and
LBP were combined to enhance the representation power
In [5], Gabor ordinal measures
of the spatial histogram.
were proposed to improve distinctiveness of Gabor features
and robustness of OM’s. In [21][6], different techniques are
combined together to achieve state-of-the-art results.

Inspired by the success of the combination of several
appearance features, we couple SOM with deeply learned
features from convolutional neural networks (CNN) [9] to
improve coding stability. Beneﬁting from CNN’s deep ar-
chitecture and supervised learning approach [2], CNN’s can
efﬁciently deal with large amounts of data and generate a
hierarchical and discriminative feature representation. The
use of deeply learned features makes the learned ordinal
features contain not only the prior structure from data but
also the hierarchical structure of local image patches.

The CNN network implemented by Alex4 is used as our
deep architecture. This CNN ﬁrst feeds gray scale images
to two convolutional layers, each followed by a normal-
ization layer and a max-pooling layer. Then, two locally
connected layers are connected to the output of the second
max-pooling layer, and ﬁnally to a C-way soft-max regres-
sion layer (C is the number of classes) that produces a dis-
tribution over class labels. The inputs to this network are
the cropped gray scale face images without any preprocess-
ing. The last C-way soft-max regression layer provides su-
pervised information for learning face representations. The
outputs of the last locally connected layers are employed as
deep feature representations.

5. Experiments

In video-sharing websites, there are a large number of
face videos, each of which contains hundreds of face im-
ages. Using binary features to represent these face im-
ages will signiﬁcantly save computational power and stor-
age space. Hence, VFR is a good test platform to evalu-
ate SOM. All experiments are run 10 times by repeating
the random selection of training/testing set. For all binary
code methods, the simple nearest neighbor classiﬁer for
each unique code in the probe set with voting is used as
a classiﬁer to report recognition rates.

5.1. Methods

We systematically compare SOM with popular tech-
niques from three categories. SOM1 and SOM2 indicate

4https://code.google.com/p/cuda-convnet/

Algorithm 1 using the last two structures from Fig. 2 (b)-
(c) respectively. For SOM2, the bits from the optimal ma-
trix for SOM1 is appended to that for SOM2 as discussed in
Section 4 if code length is larger than the number of classes.
For the ﬁrst category, we compare SOM with state-of-
the-art data-driven binary feature methods in biometrics,
including discriminant face descriptor (DFD) [21], Gabor
ordinal measures (GOM) [5], and compact binary face de-
scriptor (CBFD) [27]. As in [27], cosine distance is used
for the three methods to achieve their best recognition accu-
racy. Since the feature dimensions of DFD and CBFD are
too high, whitened PCA (WPCA) is applied to reduce their
feature dimensions to 1000 [27].

For the second category, we compare SOM with pop-
ular hashing methods, including locality sensitive hashing
(LSH) [11], iterative quantization (ITQ) [12], kernel-based
supervised hashing (KSH) [26], fast supervised hashing
(FastH) [24], and supervised discrete hashing (SDH) [30].
For ITQ, its supervised version (CCA-ITQ) and unsuper-
vised version (PCA-ITQ) are included. PCA is used as a
preprocessing step for CCA-ITQ. For SDH, we use the no-
tation SDH-n to indicate that SDH uses image pixels rather
than nonlinear RBF kernel mapping as its input. Hamming
distance is computed on each pair of face samples in train-
ing/testing sets.

For the last category, we compare SOM with pop-
including discriminative canonical
ular VFR methods,
[18], manifold discriminant anal-
correlations (DCC)
ysis (MDA)
sparse approximated nearest point
[37],
(SANP) [1], sparse representation for video (SRV) and
its kernelized version KSRV [7], covariance discrimina-
tive learning (Cov+PLS) [36], jointly learning dictionary
and subspace structure (JLDSS) [43], image sets alignment
(ImgSets) [8], regularized nearest points (RNP) [42], and
mean sequence sparse representation-based classiﬁcation
(MSSRC) [29]. As in [42][29][7][43] , we directly cited the
best recognition rates of these methods from the literature.

5.2. Databases

Three commonly used face video datasets are used to

evaluate different methods, including,

The Honda/UCSD dataset [20] is composed of 59
video sequences of 20 subjects. The sequences of each sub-
ject contain pose and expression variations. The lengths of
the sequences vary from 12 to 645. Fig. 3 (a) shows cropped
images from this dataset. We follow the standard train-
ing/testing conﬁguration in [37][1][36][43]: 20 sequences
are used for training and the remaining 39 sequences for
testing. All video frames are used to report classiﬁcation
results. Since there are only 39 testing sequences, the
improvement of recognition rates is 2.6% ({1/39}*100%)
when one additional sequence is correctly classiﬁed.

(a) the Honda/UCSD dataset

(b) the CMU Mobo dataset

(c) the YouTube Celebrities dataset

Figure 3. Cropped facial images of three different subjects in the three video databases respectively.

)

%
0
0
1
(

t

e
a
r

n
o

i
t
i

n
g
o
c
e
R

85

84

83

82

81

80

79

78

77

76
10

−2

SOM1−64
SOM1−32

−1

10
λ
2

(a)

40

)

%
0
0
1
(
o

i
t

a
r

i

n
o
s
s
e
r
p
m
o
C

35

30

25

20

SOM1−64
SOM1−32

0
10

−2

10

0
10

−1

10
λ
2

(b)

)

%
0
0
1
(
e

t

a
r
n
o

i
t
i

n
g
o
c
e
R

88

86

84

82

80

78

76

SOM1

SOM1−n

SOM2

SOM2−n

40

60

80
Number of bits

100

120

)

%
0
0
1
(

o
i
t
a
r

i

n
o
s
s
e
r
p
m
o
C

60

50

40

30

20

10

0

SOM1
SOM1−n
SOM2
SOM2−n

40

60

80
Number of bits

100

120

(c)

(d)

Figure 4. Recognition rates and compression ratios of SOM under different parameter setting. (a) Recognition rates as a function of λ2.
(b) Compression ratios of samples as a function of λ2. (c) Average recognition rates with or without (11). SOM-n indicates that the SOM
method without using (11). (d) Average compression ratios of samples with or without (11).

The Mobo (Motion of Body) dataset [15] was origi-
nally published for human pose identiﬁcation. It contains
96 sequences of 24 different subjects walking on a tread-
mill. Each subject has four video sequences corresponding
to four walking patterns respectively. These patterns (slow,
fast, inclined, and carrying a ball) were captured using mul-
tiple cameras. Fig. 3 (b) shows some cropped images from
three subjects. We follow the standard training/testing con-
ﬁguration in [37][1][36][43]. One video was randomly cho-
sen as training and the remaining three for testing. The im-
provement of recognition rates is (1.4% = 1/72*100%) if
one additional video sequence is correctly classiﬁed.

The YouTube Celebrities dataset [17] contains 1910
video clips of 47 human subjects (actors, actresses, and
politicians) from the YouTube website. Roughly 41 clips
were segmented from 3 unique videos for each person.
These clips are mostly low resolution and highly com-
pressed. Each facial image is cropped to size 30 × 30 as
shown in Fig. 3 (c). This dataset is challenging because it
contains large facial variations (e.g., pose, illumination and
expressions) and tracking errors in the cropped faces. Fol-
lowing the standard setup, the testing dataset is composed
of 6 test clips, 2 from each unique video, per person. The
remaining clips were used as the input to the CNN to learn
a 1152-D feature representation. One frame of video (one
single image) is fed into the CNN at a time. We randomly
selected 3 training clips, 1 from each unique video.

5.3. Algorithmic Analysis

Since our SOM method consists of several parts to im-
prove performance, we investigate the effectiveness of each

part on the YouTube Celebrities dataset. To simplify param-
eter setting, we directly use the default parameter setting of
µ and λ1 in the LIBLINEAR SVM source code. Hence
there is only one parameter λ2 to control the effectiveness
of output structures.

Fig. 4 (a) and (b) show recognition rates and compres-
sion ratios of samples as a function of λ2 respectively. Ex-
perimental results are from one single run. The lower com-
pression ratio of an algorithm is, the better the algorithm
is. We observe that parameter λ2 affects both recognition
rates and compression ratios. When λ2 is a large, the output
2
F dominates (5). If λ2 is sufﬁciently
structure term kB − Sk
large, the optimal solution of B will equal the ordinal ma-
trix S, which indicates directly using S as the class labels
of SVM to perform binary code learning. When λ2 tends
to be zero, (5) becomes maximum margin clustering [41].
That is, we seek a global ordinal ﬁlter matrix W to group
the samples from the same class into several clusters.

Since Sc is a rank-one matrix, B will be a rank-one ma-
trix if B is equal to S. In VFR problems, a video clip often
contains many face variations so that it is difﬁcult to use one
binary vector to represent all face variations. From Fig. 4
(b), we also observe that the rank of the learned B is larger
than 1. Hence, to keep the diversity of learned B, it is not
a good strategy to directly use S as the class labels of SVM
or to set λ2 to a large value, although a larger λ2 will result
in better compression. Meanwhile, setting λ2 too small will
also damage performance. If λ2 tends to zero, there will
be no structure constraints to ensure that the learned ordinal
features are similar to the optimal ordinal matrix for classi-
ﬁcation. Hence, the performance of SOM will decrease in

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
100

95

90

85

80

100

90

80

70

60

50

)

%
0
0
1
(
e
a
r

t

n
o

i
t
i

n
g
o
c
e
R

)

%
0
0
1
(
e
a
r

t

d
e
s
s
e
r
p
m
o
C

CCA−ITQ
PCA−ITQ
SH
LSH
KSH
FastH
SDH
SDH−n
SOM1
SOM2

)

%
0
0
1
(

t

e
a
r
n
o

i
t
i

n
g
o
c
e
R

96

94

92

90

88

86

84

40

60

80
Number of bits

100

120

(b) Mobo

CCA−ITQ
PCA−ITQ
SH
LSH
KSH
FastH
SDH
SDH−n
SOM1
SOM2

50

100

150

200

250

Number of bits

(a) Honda

)

%
0
0
1
(
e
a
r

t

n
o

i
t
i

n
g
o
c
e
R

90

85

80

75

70

65

60

55

50

40

60

80
Number of bits

100

120

(c) Youtube

Figure 5. Recognition rates of different binary code learning methods.

CCA−ITQ
PCA−ITQ
SH
LSH
KSH
FastH
SDH
SDH−n
SOM1
SOM2

)

%
0
0
1
(

e
t
a
r

d
e
s
s
e
r
p
m
o
C

100

90

80

70

60

50

40

30

20

10

40

50

100

150

200

250

Number of bits

(a) Honda

CCA−ITQ
PCA−ITQ
SH
LSH
KSH
FastH
SDH
SDH−n
SOM1
SOM2

)

%
0
0
1
(
e
t
a
r
d
e
s
s
e
r
p
m
o
C

100

80

60

40

20

0

120

40

60

80
Number of bits

100

120

(c) Youtube

60

80
Number of bits

100

(b) Mobo

CCA−ITQ
PCA−ITQ
SH
LSH
KSH
FastH
SDH
SDH−n
SOM1
SOM2
CNN fea

CCA−ITQ
PCA−ITQ
SH
LSH
KSH
FastH
SDH
SDH−n
SOM1
SOM2

Figure 6. Compression ratios of different binary code learning methods on the three testing sets. Compression ratio = the number of unique
samples/ the total number of samples. The lower compression ratio an algorithm has, the better the algorithm is.

)

%
0
0
1
(
e
t
a
r

d
e
s
s
e
r
p
m
o
C

100

80

60

40

20

0

CCA−ITQ
PCA−ITQ
SH
LSH
KSH
FastH
SDH
SDH−n
SOM1
SOM2

)

%
0
0
1
(
e
t
a
r

d
e
s
s
e
r
p
m
o
C

100

90

80

70

60

50

40

30

20

10

50

100

150

200

250

Number of bits

40

60

80
Number of bits

100

120

(a) Honda

(b) Mobo

CCA−ITQ
PCA−ITQ
SH
LSH
KSH
FastH
SDH
SDH−n
SOM1
SOM2

)

%
0
0
1
(

e
t
a
r
d
e
s
s
e
r
p
m
o
C

100

80

60

40

20

0

40

60

80
Number of bits

100

120

(c) Youtube

CCA−ITQ
PCA−ITQ
SH
LSH
KSH
FastH
SDH
SDH−n
SOM1
SOM2

Figure 7. Compression ratios of different binary code learning methods on the three training sets.

terms of both recognition rates and compression ratios.

5.4. Comparisons to binary code methods

Fig. 4 (b) and (c) show recognition rates and com-
pression ratios of samples without using (11) respectively.
SOM-n indicates that the SOM method uses sgn(.) func-
tion to obtain binary codes rather than using (11). We ob-
serve that using (11) further improves recognition rates and
reduces compression ratios. This indicates that our SOM
methods can correct some binary codes such that the learned
codes become correlated. Since video data often contain a
large number of face samples, it is impossible to make face
samples uncorrelated as assumed by hashing methods. Re-
ducing the redundancy of video data should be helpful for
performance. We also observe that the improvement using
(11) is not signiﬁcant. We regard these results as reasonable
because CNN features have powerful ability to learn dis-
criminative representations. Since the binary codes learned
by SOMs are discriminative enough on CNN features, there
is a limited potential to further improve performance.

Table 1 and Figures 5,6,7 show recognition rates and
compression ratios of different binary code learning meth-
ods on the three video face databases. From these results,
we make several observations:

High-dimensional and dense features are powerful for
VFR. Three binary feature representation methods (GOM,
CBFD and DFD) obtain the highest recognition rate (close
to 100%) on the Honda dataset, and comparable recognition
rates on the other two datasets. However, the best recog-
nition rates of these three methods are obtained by cosine
distance rather than Hamming distance. Dense feature rep-
resentations will result in very high computational costs for
VFR. For the Honda dataset, we can see that longer codes
will lead to better recognition rates. The recognition rates of
CCA-ITQ, LSH, FastH, SOM1 and SOM2 increase quickly
as the number of bits increases.

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Methods(dim)
GOM(2560)
CBFD(32000)
DFD(50176)

RR

Honda
CS1

Mobo
CS2
CS1
99.0% 100.0% 100.0% 92.6% 99.7% 100.0% 68.1% 99.3% 99.3%
99.5% 99.4% 100.0% 95.1% 100.0% 100.0% 66.3% 99.3% 99.3%
99.2% 100.0% 100.0% 93.6% 100.0% 100.0% 64.7% 99.3% 99.3%

Youtube
CS1

CS2

CS2

RR

RR

Table 1. Experimental results of three state-of-the-art binary feature representation methods. ’RR’, ’CS1’ and ’CS2’ indicate recognition
rate, compression ratio on the testing set, and compression ratio on the training set respectively.

Compared to the hashing methods designed for image
retrieval, SOM methods are more effective for VFR. On all
three databases, SOM methods achieve the highest recogni-
tion rates, and consistently outperform their hashing com-
petitors. This may be because SOM methods can utilize
and preserve the structure information from face videos.
Since SOM2 considers discriminative binary codes in its
prior structure, SOM2 performs better than SOM1 on the
last two databases. On the YouTube database, since CNN
features capture face variations well, SOM methods obtain
state-of-the-art recognition rates compared to the complex
classiﬁcation models (e.g., image set models). It should be
noted that the results for these other models are not based on
CNN features, and their performance should improve if they
were applied to those features. More important, SOM meth-
ods use 64-bit binary features to obtain a better result than
directly using CNN features in a nearest neighbor recog-
nition framework, which offers an impressive compression
ratio of 1152-dim CNN features.

Binary code learning methods provide a potential way
to reduce the number of registered samples. Since there
are many face samples in a video clip, a lower compres-
sion ratio of an algorithm indicates that the algorithm needs
smaller storage space and computational time. Since PCA-
ITQ and CCA-ITQ aim to quantize the face samples so
that they are uncorrelated, they should learn different binary
codes for different samples. However, their compression ra-
tios on the training and testing sets are smaller than 100%.
This indicates that there are some samples to have the same
binary code, which makes the uncorrelated constraints work
not well. In addition, compression ratios of different meth-
ods on the training set seem to be lower than those on the
testing set. This indicates that there are large difference be-
tween the videos in the training and testing set so that the
learned coding functions more accurately capture the facial
variations in the training set than those in the testing set.

FastH, SDH, SOM1 and SOM2 obtain lower com-
pression ratios than other methods, which indicates that
these methods can reduce intra-class variations. On the
Honda and Youtube databases, SDH’s performance seems
to mainly beneﬁt from its nonlinear RBF kernel mapping
and anchor points, which forces the data to be similar to
anchor points, resulting in low compression ratios. With-
out the nonlinear mapping, SDHn performs no better than

other methods. Since the nonlinear RBF kernel mapping is
an independent step for SDH, this data mapping can also
be integrated into other methods as a preprocessing step if
applicable. In contrast to SDH, SOM methods employ low-
rank constraints to naturally group data to different clusters
(or anchor points).

The optimal ordinal matrix for classiﬁcation plays an
important role for SOM. Although SOM1 and SOM2 are
both minimized by Algorithm 1, they perform differently
in terms of recognition rate and compression ratio. This
is because SOM makes use of ordinal matrices as output
structures that are helpful for classiﬁcation. Different output
structures result in different characteristic SOM’s. Finding
or deﬁning the optimal ordinal matrix is still an open prob-
lem for ordinal measure and hashing. The coding theory
from information theory [16] may provide useful insights
for binary code learning methods.

5.5. Comparisons to VFR methods

In this subsection, we compare the proposed SOM meth-
ods with prevalent VFR methods that are based on hun-
dreds of ﬂoating point features. Fig. 8 (a) plots the average
recognition rates of different VFR methods on the Honda
dataset. The interval between two dashed lines indicates
the improvement in recognition rates (2.6%) if one addi-
tional video sequence is correctly classiﬁed. The highest
recognition rate achieved by SOM is 98.7% at 256 bits. We
observe that the recognition rates of most of the compared
methods are between 97.4% and 100%. This indicates that
there is at most one misclassiﬁed sequence in the randomly
selected subsets. These results also show that we can use
only binary features and achieve state-of-the-art results on
the Honda dataset.

Fig. 8 (b) plots the average recognition rates of different
VFR methods on the CUM Mobo dataset. The interval be-
tween two dash lines indicates the improvement of recog-
nition rates (1.4% = 1/72*100%) if one additional video
sequence is correctly classiﬁed. RNP achieves the high-
est recognition rate 97.4%±1.5%. In contrast, the recog-
nition rate of SOM is 97.1%. This indicates that RNP out-
performs SOM in some random selection cases but not in
other cases. The reason is probably that SOM simply uses
a nearest neighbor classiﬁer with voting. Since SOM is a
binary feature representation method and RNP is an image

(a) Honda

(b) Mobo

(c) Youtube

Figure 8. Recognition rates of different VFR methods on the three video databases. The interval between two dashed lines indicates the
improvement of recognition rates if one additional video sequence is correctly classiﬁed.

set method, we consider the result of SOM to be compara-
ble to that of state-of-the-art VFR methods. In addition, an
image set algorithm can also be applied to ordinal features
to further improve accuracy.

Fig. 8 (c) plots the average recognition rates of differ-
ent VFR methods on the Youtube dataset. We observe that
MSSRC and SOM are the two best methods on this data
set. Their average recognition rates are 80.8% and 87.0%
respectively. The accuracy improvement of SOM against
MSSRC is more than 6%. The high accuracy of MSSRC
is due to its robust tracker that successfully tracked 92% of
the videos as compared to the 80% tracked by other meth-
ods. Since the low quality of video frames incurred by the
high compression rate generates large tracking errors and
noise in the cropped faces [1], a good tracker should signiﬁ-
cantly improve recognition accuracy. However, SOM did
not use any preprocessing techniques (such as histogram
equalization or an enhanced tracker). These results show
that using a simple voting classiﬁer can improve over the
complex VFR models on the ﬁne grained YouTube dataset.
In addition, SOM can use a 64-bit representation to achieve
a better recognition result than 1152-D ﬂoating point CNN
representation, which offers an impressive compression ra-
tio over CNN features.

6. Conclusion

We introduced the problem of designing data-driven or-
dinal structures for ordinal measures learning, and devel-
oped a structured ordinal measure method for video-based
face recognition. By reformulating the problem in terms
of an implied equivalence relation, we posed the learn-
ing problem as a non-convex integer program problem that
mainly includes two parts. The ﬁrst part learns stable ordi-
nal ﬁlters to project video data into a large-margin ordinal
space. The second seeks self-correcting and discrete codes
by balancing the projected data and a rank-one ordinal ma-
trix in a structured low-rank way. Unsupervised and super-

vised structures are considered for the ordinal matrix. We
developed an alternating minimization method to efﬁciently
minimize the proposed non-convex formulation. Experi-
mental results demonstrate that our SOM methods provide
state-of-the-art results with fewer features and samples on
three commonly used video face databases.

The future work lies in two directions. First, our results
show that the proposed output structures (the optimal ordi-
nal matrices) are useful for video-based face recognition.
Hence one direction is to design or learn optimal ordinal
matrix based on various facial attributes, which have been
shown to further improve recognition rates. Second, our
results also show that SOM can efﬁciently compress redun-
dant samples, resulting in a small set of unique samples.
During classiﬁcation, these unique samples can be treated
as representative samples or anchor points to represent all
video samples. Hence another potential direction is to ap-
ply the proposed method to the area of representative sam-
ple learning.

References

[1] Y. H. amd A. Mian and R. Owens. Sparse approximated
nearest points for image classiﬁcation. In ICCV, 2011. 7, 8,
11

[2] Y. Bengio, A. Courville, and P. Vincent. Representation
IEEE TPAMI,

learning: A review and new perspectives.
35(8):1798–1828, 2013. 7

[3] D. Cai, X. He, and J. Han. Spectral regression for efﬁcient
regularized subspace learning. In ICCV, pages 1–7, 2007. 6
[4] Z. Cao, Q. Yin, X. Tang, and J. Sun. Face recognition with

learning-based descriptor. In CVPR, 2010. 3

[5] Z. Chai, Z. Sun, H. M. Vazquez, R. He, and T. Tan. Gabor
ordinal measures for face recognition. IEEE TIFS, 9(1):14–
26, 2014. 1, 3, 7

[6] T.-H. Chan, K. Jia, S. Gao, J. Lu, Z. Zeng, and Y. Ma.
PCANet: A simple deep learning baseline for image clas-
siﬁcation? arXiv:1404.3606v2, pages 1–16, 2014. 3, 7

[27] J. Lu, V. E. Liong, X. Zhou, and J. Zhou. Learning compact
IEEE TPAMI,

binary face descriptor for face recognition.
preprint, 2015. 1, 3, 4, 7

[28] Y. Mu, G. Hua, W. Fan, and S.-F. Chang. Hash-svm: Scal-
able kernel machines for large-scale visual classiﬁcation. In
CVPR, 2014. 3

[29] E. G. Ortiz, A. Wright, and M. Shah. Face recognition
in movie trailers via mean sequence sparse representation-
based classiﬁcation. In CVPR, 2013. 7

[30] F. Shen, C. Shen, W. Liu, and H. T. Shen. Supervised discrete

hashing. In CVPR, 2015. 3, 5, 7

[31] S. Stevens. On the theory of scales of measurement. Science,

103(2684):677–680, 1946. 1

[32] Z. Sun and T. Tan. Ordinal measures for iris recognition.

IEEE TPAMI, 31(12):2211–2226, 2009. 1, 2, 3, 4, 6

[33] Z. Sun, L. Wang, and T. Tan. Ordinal feature selection for
iris and palmprint recognition. IEEE TIP, 23(9):3922–3934,
2014. 1, 2, 3, 6

[34] J. Wang, S. Kumar, and S. F. Chang. Semi-supervised hash-

ing for scalable image retrieval. In CVPR, 2010. 3

[35] J. Wang, H. T. Shen, J. Song, and J. Ji. Hashing for similarity

search: A survey. arXiv:1408.2927, 2014. 3

[36] R. Wang, H. Guo, L. Davis, and Q. Dai. Covariance discrim-
inative learning: A natural and efﬁcient approach to image
set classiﬁcation. In CVPR, 2012. 7, 8

[37] R. Wang, S. G. Shan, X. L. Chen, and W. Gao. Manifold-
manifold distance with application to face recognition based
on image set. In CVPR, 2008. 7, 8

[38] Y. Weiss, A. Torralba, and R. Fergus. Spectral hashing. In

NIPS, pages 1753–1760, 2009. 3

[39] R. Xia, Y. Pan, H. Lai, C. Liu, and S. Yan. Supervised hash-
ing for image retrieval via image representation learning. In
AAAI, pages 2156–2162, 2014. 3

[40] L. Xiao, R. He, Z. Sun, and T. Tan. Coupled feature selection
for cross-sensor iris recognition. In BTAS, 2013. 1, 3
[41] L. Xu, J. Neufeld, B. Larson, and D. Schuurmans. Maximum

margin clustering. In NIPS, 2004. 2, 4, 8

[42] M. Yang, P. Zhu, L. V. Gool, and L. Zhang. Face recognition
based on regularized nearest points between image sets. In
Automatic Face and Gesture Recognition, 2013. 7

[43] G. Zhang, R. He, and L. Davis. Jointly learning dictionary
and subspace structure for video-based face recognition. In
ACCV, 2014. 2, 7, 8

[44] W. Zhang, S. Shan, W. Gao, X. Chen, and H. Zhang. Lo-
cal gabor binary pattern histogram sequence (LGBPHS): A
novel non-statistical model for face representation and recog-
nition. In ICCV, 2005. 7

[7] Y. C. Chen, V. Patel, S. Shekhar, R. Chellappa, and
P. Phillips. Video-based face recognition via joint sparse
representation. In Automatic Face and Gesture Recognition,
2013. 2, 7

[8] Z. Cui, H. Zhang, S. Lao, and X. Chen. Image sets alignment
for video-based face recognition. In CVPR, 2012. 3, 5, 7
[9] Y. L. Cun, B. Boser, J. S. Denker, D. Henderson, R. E.
Howard, W. Hubbard, and L. D. Jackel. Hand-written digit
recognition with a back-propagation network. In NIPS, 1990.
7

[10] R.-E. Fan, K.-W. Chang, C.-J. Hsieh, X.-R. Wang, and C.-
J. Lin. Liblinear: A library for large linear classiﬁcation.
JMLR, 9:1871–1874, 2008. 4

[11] A. Gionis, P. Indyk, and R. Motwani. Similarity search in

high dimensions via hashing. In VLDB, 1999. 7

[12] Y. Gong and S. Lazebnik.

Iterative quantization: A pro-
crustean approach to learning binary codes. In CVPR, 2011.
6, 7

[13] K. Grauman and R. Fergus. Learning binary hash codes for
large-scale image search. Machine Learning for Computer
Vision, 411:49–87, 2013. 1, 3

[14] E. Grave, G. Obozinski, and F. Bach. Trace lasso: a trace
norm regularization for correlated designs. In NIPS, 2011. 5
[15] R. Gross and J. Shi. The cmu motion of body (mobo)
database. Technical report, Technical Report CMU-RI-TR-
01-18, Robotics Inst., 2001. 8

[16] A. Hedayat and W. D. Wallis. Hadamard matrices and their
applications. The Annals of Statistics, 6:1184–1238, 1978.
6, 10

[17] M. Kim, S. Kumar, V. Pavlovic, and Rowley. Face tracking
and recognition with visual constraints in real-world videos.
In CVPR, 2008. 8

[18] T. Kim, O. Arandjelovic, and R. Cipolla. Discriminative
learning and recognition of image set classes using canon-
ical correlations. IEEE TPAMI, 29:1005–1018, 2007. 7
[19] B. Kulis and K. Grauman. Kernelized locality-sensitive
hashing for scalable image search. In ICCV, 2009. 3
[20] K. Lee, J. Ho, M. Yang, and D. Kriegman. Video-based
face recognition using probabilistic appearance manifolds.
In CVPR, 2003. 7

[21] Z. Lei, M. Pietikainen, and S. Z. Li. Learning discriminant
face descriptor. IEEE TPAMI, 36(2):289–302, 2014. 1, 3, 4,
7

[22] Y. Li, R. Wang, Z. Huang, S. Shan, and X. Chen. Face
video retrieval with image query via hashing across eu-
clidean space and riemannian manifold. In CVPR, 2015. 3

[23] S. Liao, Z. Lei, S. Z. Li, X. Yuan, and R. He. Structured
ordinal features for appearance-based object representation.
In Analysis and Modeling of Faces and Gestures, 2007. 3

[24] G. Lin, C. Shen, Q. Shi, A. van den Hengel, and D. Suter.
Fast supervised hashing with decision trees for high-
dimensional data. In CVPR, 2014. 1, 3, 7

[25] W. Liu, C. Mu, S. Kumar, and S.-F. Chang. Discrete graph

hashing. In NIPS, pages 3419–3427, 2014. 3, 5

[26] W. Liu, J. Wang, R. Ji, Y. Jiang, and S. Chang. Supervised
hashing with kernels. In CVPR, pages 2074–2081, 2012. 1,
7

