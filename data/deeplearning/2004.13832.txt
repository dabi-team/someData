This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

Towards an evolutionary-based approach for
natural language processing

Luca Manzoni1, Domagoj Jakobovic2, Luca Mariot3, Stjepan Picek3,
and Mauro Castelli4

1Dipartimento di Matematica e Geoscienze, Universit degli Studi di Trieste, Via
Valerio 12/1, 34127 Trieste, Italy ,
lmanzoni@units.it
2Faculty of Electrical Engineering and Computing, University of Zagreb, Unska
3, Zagreb, Croatia ,
domagoj.jakobovic@fer.hr
3Cyber Security Research Group, Delft University of Technology,, Mekelweg 2,
Delft, The Netherlands ,
{l.mariot,s.picek}@tudelft.nl
4NOVA Information Management School (NOVA IMS), Universidade Nova de
Lisboa, Campus de Campolide, 1070-312, Lisbon, Portugal ,
mcastelli@novaims.unl.pt

April 30, 2020

Abstract

Tasks related to Natural Language Processing (NLP) have recently been
the focus of a large research endeavor by the machine learning community.
The increased interest in this area is mainly due to the success of deep
learning methods. Genetic Programming (GP), however, was not under
the spotlight with respect to NLP tasks. Here, we propose a ﬁrst proof-of-
concept that combines GP with the well established NLP tool word2vec
for the next word prediction task. The main idea is that, once words have
been moved into a vector space, traditional GP operators can successfully
work on vectors, thus producing meaningful words as the output. To assess
the suitability of this approach, we perform an experimental evaluation
on a set of existing newspaper headlines. Individuals resulting from this
(pre-)training phase can be employed as the initial population in other
NLP tasks, like sentence generation, which will be the focus of future
investigations, possibly employing adversarial co-evolutionary approaches.

Keywords Genetic Programming · Natural Language Processing · Next

word prediction

0
2
0
2

r
p
A
3
2

]
L
C
.
s
c
[

1
v
2
3
8
3
1
.
4
0
0
2
:
v
i
X
r
a

 
 
 
 
 
 
This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

1

Introduction

Natural language processing (NLP) is a branch of artiﬁcial intelligence that
analyzes naturally occurring texts to achieve human-like language processing
for diﬀerent applications [10]. With the increasing popularity of deep learning,
NLP is nowadays a hot research topic in the scientiﬁc community, and several
contributions (mainly based on neural models) appeared in recent years [26].
Next word prediction is one of the most important tasks in this research ﬁeld,
and, given a sequence of words, it aims at predicting what word comes next. The
importance of this task is motivated by the vast amount of applications in which
it appears, including the composition of text and/or emails as well as ad-hoc
applications designed to help people with physical disabilities to communicate [1].
The next word prediction problem can be addressed by considering diﬀerent
techniques [14]. The simplest approach is the one that takes into account words
and their respective frequencies [13]. In this case, when a user entered the ﬁrst
characters of a word, the system suggests the most probable words beginning
with the same character (or characters). While this method is simple to be
implemented, it relies on standard word frequencies, thus ignoring the lexicon of
diﬀerent users. Thus, to obtain better suggestions, it is necessary to update the
system once the user has entered a signiﬁcant amount of text [25].

A diﬀerent method to address the next word prediction problem takes into
account the probability of appearance of each word after the one previously
entered. In other words, instead of considering the simple information about
words’ frequencies, this approach uses a two-dimensional table containing the
conditional probability of the word wj appearing after the word wi was entered.
While this approach results in better prediction with respect to the one based
only on words’ frequencies, it has an important limitation associated with the
size of the table that must be stored. Additionally, as pointed out in [14], it is
diﬃcult to adapt the system to the user’s vocabulary when the dimensions of
the table are ﬁxed. Hence, this approach is commonly used in combination with
the previous one, and the table only stores the most probable word-pairs.

A diﬀerent method considers the syntactic information inherent to natural
languages to address the next word prediction task [24]. To implement this
idea, we need two pieces of information: the ﬁrst one is the probability of
appearance of each word, while the second is the relative probability of appearance
of every syntactic category after each syntactic category. By exploiting the
syntactic information associated with the language, this approach results in
better predictions with respect to the ones achieved by the aforementioned
methods. The main limitation of this approach is the presence of words with
ambiguous categories, that may signiﬁcantly aﬀect the quality of the prediction
as well as the subsequent predictions [14]. A diﬀerent approach is based on the
analysis of sentences by the use of grammars and by applying NLP techniques
to obtain the categories with the highest probability of appearance [15].

Nowadays, the most common and successful approaches to deal with NLP
tasks are based on the use of deep learning techniques. This is mostly due to
the ability of deep learning in modeling the recursivity of human language that
is composed of words and sentences with a certain structure. Deep learning
(especially recurrent neural models), can capture the sequence information more
eﬀectively compared to other existing techniques. The reader is referred to [26]
and [2] for a complete review of the existing deep learning-based approaches in

2

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

the ﬁeld of NLP.

Despite the existence of diﬀerent techniques dedicated to the next word
prediction task, the use of evolutionary algorithms was not fully explored. In
particular, Genetic Programming (GP) was applied to diﬀerent tasks in the
context of NLP [5], but no speciﬁc eﬀort was dedicated to this prediction task.
Considering the ability of GP to address problems over diﬀerent domains
and its ability to explore search spaces characterized by a high-dimensionality,
in this paper, we answer this call by presenting a GP-based system for the
next word prediction problem. The choice of using GP is also motivated by the
fact that it can provide information that cannot be extracted from a black-box
model, thus providing a more interpretable model. The ability of GP to provide
human-understandable solutions is particularly useful in the context of this
application because it may provide interesting hints about the nature of the
language and the learning process of GP. Additionally, this task can be addressed
by building rules from the set of words in input, and GP was successfully used
to generate rules-based models [6] for problems over diﬀerent domains. Thus
it is reasonable to investigate the potential of GP in addressing the next word
prediction task.

This paper is organized as follows: related works are presented in Section 2,
while the proposed method for next word prediction with GP is described in
Section 3. The experimental settings and results are presented in Section 4 and
discussed in Section 5. Section 6 concludes the paper and highlight some possible
directions for future research.

2 Related Works

This section reviews the use of Genetic Programming for addressing diﬀerent
tasks in the ﬁeld of natural language processing. While this research ﬁeld is
nowadays dominated by the use of deep learning models, we decided to restrict
our attention to the GP-based techniques that represent the method explored in
this paper.

The ﬁrst applications of GP in the ﬁeld of NLP were mostly related to the
identiﬁcation of the semantic structure of the language. The main reason relies
on the fact that the syntax-tree representation used in GP is similar to the one
commonly employed to describe the syntax of a language [5]. Thus, it comes
naturally to use GP for the task of identifying the syntactic structures of the lan-
guage. One of the ﬁrst studies in this area was proposed in [22], where the author
employed GP to address a parser failure problem in speech-to-speech machine
translation. In the same research direction, Araujo [3] proposed a GP-based
system for natural language parsing. The system was subsequently improved
by considering a multi-objective formulation for simultaneous performance of
language tagging and parsing [4].

Other works where GP was used for NLP tasks took into consideration the
generation of regular expressions. Regular expressions are important in the
ﬁeld of NLP due to their ability to represent string patterns precisely. In [7],
Bartoli and coauthors applied GP for extracting regular expressions for entity
extraction applications. They designed a multi-objective GP-based system to
automatically create a regular expression for a task that was represented through
a set of examples. Experimental results demonstrated the suitability of the

3

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

system they proposed, with the GP-based approach outperforming the existing
techniques already tested on the same datasets. Subsequently, in [8], Bartoli
and coauthors described an active learning approach where the user acts as an
oracle. They assessed the performance of this approach on the same datasets
used in [7], and they demonstrated that the active learning approach might
reduce the computational cost by requiring a lower amount of user annotations.
Another task where GP was employed is the search and extraction of semantic
relationships in texts, which is especially relevant in the medical domain. In
this domain, GP was used to identify sentences that contain descriptions of
interactions between genes and proteins [9]. More in detail, GP was employed to
obtain a model of syntax patterns composed of part-of-speech tags. The model
consisted of a set of automatically learned regular expressions, following the idea
developed in [7].

Other works focused on the entity linking task, the identiﬁcation of the
diﬀerent ways in which the same entity is mentioned in the texts. To address
this task, Carvalho and coauthors [11] used GP to ﬁnd eﬀective functions that
can identify, in a data repository, entries referring to the same entity despite
typos. Experimental results demonstrated that GP was able to outperform
the state-of-the-art SVM-based approach over real-world data. Subsequently, a
combination of GP and active learning was proposed in [16] to address the same
problem, and the results demonstrated the beneﬁcial eﬀect of combining active
learning with GP.

Moving to the task of natural language generation, Manurung and coau-
thors [19] developed a GP system for generating poetry with a certain meter or
patterns in the rhythm, while Kim and coauthors [17] developed a GP system
for generating answers that an agent must provide to users’ queries. These are
the only GP-based contributions in the ﬁeld of natural language generation, and
they cover very speciﬁc domains. Additionally, in these works, GP is used to
represent the grammars that must be evolved.

For a complete review of the applications of GP in the NLP ﬁeld, the reader

is referred to [5].

3 Next word Prediction with GP

In this section, we describe how to adapt GP to work with words both at the
input and the output levels and how to manipulate them. In particular, we
tackle the problem of next word prediction, where, given an initial sequence
of words, possibly of ﬁxed length k, we want to predict the next word in the
sequence. Since we need to produce a word, we have to perform text generation
via GP. To accomplish that, we need to tackle multiple obstacles; speciﬁcally,
there are the following points to be taken care of:

• Input representation. How can the input words be represented in a

suitable way for GP?

• Functional operators. What operations can be performed on the repre-

sentation of the words?

• Output interpretation. How can we decode the output of a GP individ-

ual and interpret it as a word?

4

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

Figure 1: A graphical depiction of the process employed: conversion of the input
word into vectors (1), evaluation of the GP tree (2), and conversion of the output
vector into a word by ﬁnding the most similar word in the vocabulary (3). The
ﬁtness can be computed by computing the similarity between the target and
output of the GP tree (4) directly.

These three questions must be addressed, and are all related to the same problem
of deciding in which genotypic space GP has to work. In particular, the input
representation will inﬂuence which kind of operations one can perform, and the
operations will also dictate how the output will be decoded.

Behind our approach to all three problems lies the adoption of an embedding,
where words are embedded into a vector space, usually Rd for some dimension
d. Among the existing embedding methods, one that has risen to prominence
since its inception in 2013 is word2vec [20]. The algorithm takes as input a large
corpus of text and produces an embedding where each word of the corpus is
represented as a real-valued vector, with the property that words sharing similar
contexts will be near in their vector representation. Usually, the size of the space
Rd in which the words are embedded is between 100 and 1 000, but we will see
that, in the case of GP, a lower dimensionality appears to help. Notice that we
assume that all necessary words, both for the input and the output, are present
in the original corpus used to train the word2vec model. That is, the GP trees
only receive inputs and produce the output only from a ﬁxed vocabulary.

We are now going to detail our approach to solve all three previously high-
lighted obstacles. A graphical representation of the entire process is given in
Figure 1.

Input representation

Given a sentence of ﬁxed length k consisting of the words w1, . . . , wk, we map
each word to its corresponding vector via a word2vec embedding to interpret
the sentence as an input to a GP individual. Therefore, we now have k vectors
(cid:126)w1, . . . , (cid:126)wk ∈ Rd, where d is the dimension of the embedding. Without loss of
generality, we consider all vectors to be of unitary length, that is || (cid:126)wi||2 = 1 for
all 1 ≤ i ≤ k.

Functional operators

Once the input encoding as unitary vectors in Rd has been deﬁned, it is necessary
to deﬁne the set of functional symbols to employ. A ﬁrst requirement is that the

5

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

output of each operation should itself be a unitary vector in Rd. If we consider
some of the common binary GP operators as used in symbolic regression, i.e., +,
−, ×, and protected division (÷), they can all be extended to work on vectors.
Given two vectors (cid:126)u and (cid:126)v in Rd, a binary operator ◦ : R × R → R can be
extended to a binary operation (cid:126)◦ : Rd × Rd → Rd by applying it component-wise
as follows:

((cid:126)u (cid:126)◦ (cid:126)v)i = (cid:126)ui ◦ (cid:126)vi

∀1 ≤ i ≤ n .

We can further restrict the output vector to be of unitary length by normalizing
it, as long as its length is not null. This allows us to deﬁne the operator
(cid:126)◦1 : Rd × Rd → Rd as:

((cid:126)u (cid:126)◦1 (cid:126)v) =

((cid:126)u (cid:126)◦ (cid:126)v)i
||(cid:126)u (cid:126)◦ (cid:126)v||2

∀1 ≤ i ≤ n .

The same procedure can then be extended to unary operators, such as squaring,
or even to operators of higher arity, by component-wise evaluation followed by
normalization.

By performing this extension process on the classical GP operators, we are
then able to produce unitary vectors in Rd as output whenever vectors in Rd
are given as input.

Output interpretation

To obtain a word as the ﬁnal output of our tree, one has to return from the
embedding produced by word2vec to the actual set of words. Let us consider
the vocabulary V consisting of the m distinct words w1, . . . , wm occurring
in the corpus used to generate the embedding, and their respective vectors
(cid:126)V = { (cid:126)w1, . . . , (cid:126)wm}. The output of a GP tree is a vector (cid:126)v ∈ Rd, which might
not be an element of (cid:126)V , and, in practice, it will almost never be. Therefore, we
assign to (cid:126)v the word corresponding to the vector (cid:126)u ∈ { (cid:126)w1 . . . (cid:126)wm} which is most
similar to (cid:126)v. In the case of word embeddings, a common measure of similarity is
the cosine similarity, corresponding to the cosine of the angle formed between
the two vectors (cid:126)u and (cid:126)v, which is deﬁned as:

sim((cid:126)u, (cid:126)v) =

(cid:80)n

i=1 (cid:126)ui(cid:126)vi
||(cid:126)u||2||(cid:126)v||2

.

Since cosine is between −1 and 1 and maximal when the two vectors coincide, we
will need to select, among the words in the vocabulary, the one whose embedding
has the highest similarity to (cid:126)v.

Computation of the ﬁtness

Given a set of h ﬁtness cases, each one of the form ((w1, . . . , wk), wk+1), where
w1, . . . , wk ∈ V are the input words and wk+1 ∈ V is the target output, the
ﬁtness of a GP individual T is computed as the average of the cosine similarity
between the output of T and (cid:126)wk+1. Since we are considering cosine similarity,
the ﬁtness is to be maximized.

There is, however, a possible ambiguity in this deﬁnition: one can consider
the output of T either as the vector (cid:126)v obtained before re-interpreting the output

6

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

as a word, or the word wi from the vocabulary obtained after “decoding” the
vector (cid:126)v. The two approaches might produce diﬀerent results, but the second
one, while arguably more “precise” (i.e., by considering the output of the entire
system and not only of T ), is also more computationally intensive, since a na¨ıve
implementation requires the computation of the cosine similarity with all words
in the vocabulary for each ﬁtness case. Therefore, we have selected the ﬁrst
method to compute the ﬁtness. That is, for each ﬁtness case we compute the
output (cid:126)v of T and sim((cid:126)v, (cid:126)wk+1). The sum of these values across all ﬁtness cases
is then averaged to produce the ﬁnal ﬁtness value of T .

4 Experiments

In this section, we describe the experimental setting adopted to test our GP
algorithm, along with a brief description of the text dataset used to train the
GP trees for the next word prediction task. We then report and discuss the
results obtained during the training and the test phase.

4.1 Experimental Setting

Recall that the optimization goal is to evolve a population of GP trees that take
as input the ﬁrst words of a sentence and predict the next word to complete
the sentence. For our experiments, we considered the Million News Headlines
(MNH) dataset [18], which contains headlines collected from the Australian
Broadcasting Corporation over 17 years from 2003 to 2019. In particular, for
our experiments, we ﬁxed the problem instance to headlines of six words, which
amounts to 267 292 training examples in the MNH dataset. Therefore, the
prediction task of the trees evolved through GP was to generate the vector for
the sixth word of these headlines by considering as input the ﬁrst ﬁve words of
the headline.

For the pre-training phase, we used word2vec to generate six diﬀerent em-
beddings Ed ⊆ Rd of the whole MNH dataset, with dimension d ranging in the
set {10, 15, 20, 25, 50, 100}. This was done to investigate whether the dimension
of the embedding space inﬂuenced the training performance of GP. For the
embedding, we employed the default parameters of word2vec, except for the
size (which was a value in {0, 15, 20, 25, 50, 100}), and the min count which was
set to 1, in order to insert all words in the vocabulary. Notice that this means
that very infrequent words will not have a semantically “good” representation as
vectors. Finally, the number of iterations was increased to 20, and the number
of threads to 16.

The input variables at the terminal nodes of the trees evolved by GP rep-
resented the vectors corresponding to the ﬁrst words of a sentence under the
considered embedding. The set of functionals for the internal nodes of the trees
included sum, subtraction, multiplication, and protected division as binary oper-
ators, and squaring and square root as unary operators. Recall that all operators
are pointwise evaluated, i.e., they are applied separately on each coordinate of the
input vectors. We adopted a steady-state breeding strategy using a tournament
selection operator of size t = 3, where the two candidates with the highest ﬁtness
are mated through crossover, and the resulting child tree replaces the worst
individual in the tournament after being mutated. For the variation operators,

7

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

we employed simple subtree crossover, uniform crossover, size fair, one-point,
and context preserving crossover, randomly selected at each generation, while
for mutation, we used simple subtree mutation [21]. To prevent bloat, we forced
a maximum depth on our GP trees equal to 5, i.e., the number of input words.
Further, we considered a population of P = 500 individuals and a mutation
probability of pµ = 0.3, and we used a maximum budget of f it = 100 000
ﬁtness evaluations as a termination criterion. All these parameters were selected
after a preliminary tuning phase, where we observed that perturbing the above
values did not yield any signiﬁcant diﬀerence in performances. In particular, we
detected no substantial increase in the ﬁtness value of the best solution after
the 100 000 evaluations cap. Finally, each experiment was repeated for R = 30
independent runs, each time using a diﬀerent training set. The training set for
each experimental run was determined by sampling one-hundredth of a random
shuﬄe of the 267 292 headlines with six words. Thus, each training set was
composed of T = 2 672 sentences.

4.2 Training Phase Results

The ﬁrst question that we addressed in our training experiments is whether the
trees evolved by GP actually learned a model of the MNH dataset, under the em-
beddings produced by word2vec. To this end, for each embedding dimension, we
compared the following distributions approximated by our R = 30 experimental
runs:

• The ﬁtness value of the best GP individual in the population before the
ﬁrst generation takes place (i.e., after randomly initializing the population)
and at the end of the experimental run (Figure 2).

• The ﬁtness value of the best GP individual at the end of the experimental

run and the ﬁtness value of the best random predictor (Figure 3).

In particular, the best random predictor was determined as follows. Given a
training set of T = 2 672 six-words headlines, for each embedding dimension
d ∈ {10, 15, 20, 25, 50, 100} we generated P = 500 sets of T random vectors,
and used them to predict the sixth word of the headlines. Stated diﬀerently,
we employed these vectors as random surrogates for the outputs of the GP
individuals over the training set. Subsequently, we scored each of the P sets of
vectors by applying the same ﬁtness function used for GP, and the set achieving
the highest ﬁtness was selected as the best random predictor. We repeated this
experiment for R = 30 times, using the same training sets employed for the GP
experimental runs. Remark that the best random predictors just described are
diﬀerent from the best individuals obtained by randomly initializing the GP
population: indeed, the latter are GP trees that, although having a random
structure, read the ﬁrst ﬁve words of a sentence to predict the next one, while
the former are random vectors completely independent from the content of the
sentences.

The boxplots of Figures 2 and 3 clearly conﬁrm that the trees evolved by GP
are learning a model of the training sets considered in the experimental runs. As a
matter of fact, for all considered dimensions, the ﬁtness of the ﬁnal best individual
is always higher than that of both the best individual after initialization and the

8

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

Figure 2: Best GP ﬁtness at the ﬁrst and last generation.

best random predictor. More speciﬁcally, the diﬀerence between the ﬁnal best
individual and the random predictor is much more signiﬁcant, as Figure 3 shows.
The second question that we investigated was whether a correlation exists
between the dimension d of the embedding space produced by word2vec and the
ﬁtness of the ﬁnal best individual bred by GP. In particular, one can see from
Figure 3 that the lower the dimension of the embedding, the higher is the ﬁtness
attained by the best individual in the population. Although this ﬁnding is in
stark contrast with the common NLP practice based on deep learning models,
where the involved word2vec embeddings usually have hundreds of dimensions,
this is a reasonable outcome for our GP algorithm. In fact, one can expect that
a GP tree has an easier time in overﬁtting a training set of a couple of thousands
of samples over a lower-dimensional space rather than on a higher-dimensional
one since we enforce a maximum depth of the tree equal to the number of input
words. Considering the relatively small size of our text corpus, it could be the
case that the word2vec embeddings with lower dimensions produce vectors that
are more closely packed, thus making overﬁtting easy for a compact GP tree. On
the other hand, for the embeddings of higher dimension, the resulting vectors
could be sparser, and thus harder to handle for small trees.

At ﬁrst glance, this overﬁtting hypothesis seems to indicate that the GP trees
evolved over lower dimensional embeddings fare worse on the test set. For this
reason, we performed a preliminary validation test on a small random sample
of 50 headlines of six words. Surprisingly, we remarked that the best GP trees
evolved over the higher dimensional embeddings (i.e., d = 50, 100) resulted in
a completely uninteresting behavior, since they learned to predict only one of
the ﬁrst ﬁve words seen in input to complete the sentence, almost always the
ﬁrst one. On the contrary, although the GP trees trained with the embeddings
of dimension 10, 15, 20, and 25 failed to predict the original target words in the
sample, nevertheless, they completed the sentences more creatively, producing
plausible headlines in some cases. To further corroborate this observation, we
compared the distribution of the best individuals evolved by GP with the trivial

9

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

Figure 3: Best GP and random generation ﬁtness values.

generators that always predict the ﬁrst and the ﬁfth word of a sentence, using
the same training sets adopted for GP. For each considered dimension, Figures 4
and 5 report the boxplots of the ﬁtness values attained by the best GP trees
and the ”ﬁrst-word” and ”last-word” predictors, respectively. One can notice
from Figure 4, that the boxplots for the “ﬁrst-word” predictor and the best
GP individual obtained over dimension d = 100 are quite close to each other,
thereby providing further evidence that this is the behavior learned by those
GP trees over the higher dimensional embeddings. On the contrary, there is
a clear diﬀerence between the distribution of the best GP individuals and the
ﬁrst-word predictor for lower dimensions, showing that the ﬁtness of the former
is much higher than that scored by the latter. Hence, this seems to indicate
that allowing to overﬁt the training data over a lower-dimensional embedding is
beneﬁcial to evolve GP trees that predict meaningful completions.

A ﬁnal remark that can be drawn from the previous plots is that the dis-
tributions of the best ﬁtness values obtained by GP at the ﬁnal generation are
not widely dispersed. Indeed, especially for high dimensions, the ﬁrst and third
quartiles are quite close to the median best ﬁtness. The only remarkable diﬀer-
ence is in the lower dimensional embeddings, where there is a wider diﬀerence
between the minimum and the maximum best ﬁtness. Nonetheless, this seems
to indicate that the best GP trees evolved over a speciﬁc embedding learn the
same prediction model. This hypothesis is also supported by our preliminary
validation test, since for each dimension d the best individuals obtained over the
R = 30 runs completed the 50 headlines approximately in the same way, almost
always by predicting the same word for each sentence.

4.3 Testing Phase Results

To better investigate the prediction models learned by the trees evolved with GP
over the training set, we performed a more systematic testing phase designed as
follows. For each of the considered six embedding dimensions, we selected the

10

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

Figure 4: Best GP and ”ﬁrst-predictor” ﬁtness values.

best GP tree with the highest ﬁtness among the 30 experimental runs. Table 1
reports the algebraic expressions of the best-selected individuals together with
their sizes, while Figure 6 depicts the tree of the best-selected individual for
dimension d = 10 as an example. Notice that in Table 1, we displayed the
non-simpliﬁed expression of the trees since the output of each internal node
undergoes normalization, which would have burdened the notation if we included
it in the simpliﬁed formulae. Next, we tested each selected individual over
a random test sample of 10 000 headlines of six words from the MNH dataset.
Analogously to the preliminary validation step described in the previous section,
we evaluated the GP tree over the embedding vectors corresponding to the ﬁrst
ﬁve words for each sentence in the test set, thus obtaining a sixth vector in
output. Since this output vector does not correspond in general to a word of
our corpus under the considered word2vec embedding, the predicted word is the
one whose embedding vector has the highest cosine similarity with the output
vector. Finally, for each sentence, we computed the cosine similarity between the
predicted word and the original sixth word. Cosine similarity of 1 thus means
that the GP tree predicts exactly the original sixth word of a headline. However,
remark that predicting the original word is not the main task of the models
encoded by the GP trees since each headline can be completed in many ways
that are both syntactically and semantically valid. In general, we observed that
high values of cosine similarity usually correspond to meaningful completions of
the headlines.

Figure 7 reports the boxplots of the distributions of similarity between
predicted and original word over the test sample of 10 000 headlines. One can see
from the plots that the initial ﬁndings suggested by the training phase results are
conﬁrmed. Indeed, the cosine similarity between predicted and original words
obtained by the GP trees trained over higher-dimensional embeddings is lower
than the similarity achieved by trees that were evolved over the lower-dimensional
embeddings. In particular, it can be remarked that the outliers are arranged
rather symmetrically: while for lower dimensions they are all focused below the

11

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

Figure 5: Best GP and ”last-predictor” ﬁtness values.

bottom whisker, for dimension d = 50 and d = 100 they are almost all above
the top one. On the other hand, the GP trees trained over dimension up to 20
consistently reach higher values of cosine similarity.

As we remarked in the previous section, the GP individuals predicting a ﬁnal
word having a high cosine similarity with the original word often resulted in
meaningful headlines, when considering a small test set of 50 sentences, and
we observed the same behavior also over the larger test set of 10 000 sentences.
Table 2 reports a small selection of headlines completed by the best GP individual
of dimension 10 on the test set, together with the original word and the associated
cosine similarity. In particular, we chose among predictions that reached a cosine
similarity of at least 0.8. It can be seen from the table that in most cases the
meaning of the original sentence is completely changed by the prediction. Indeed,
only for three sentences the predicted word is a synonym of the original one
(see houses–homes, robberies–heist and funds–funding). However, all resulting
headlines are plausible, and one can observe that the predicted word is always
related to a similar context with respect to the original word. For example, in
the last example of Table 2 the predicted word refers to a generic place (towns),
while the original ﬁnal word is the name of a region (Victoria). Moreover, the
third and the eight examples suggest that the model learned by the GP tree is
also able to discriminate between diﬀerent contexts when the same word occurs
in the input. In fact, in the third sentence, the word tax has been matched with
changes instead of review, hence preserving the political overtone of the headline.
Contrarily, in the eight sentence the GP tree paired tax with bureaucracy in
place of rates, thus remaining on a more administrative/economic context.

5 Discussion

The results presented in the previous two sections suggest that, to some extent,
GP can learn a language model from a text dataset by leveraging the embedding

12

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

Size Expression

d

10

15

27

38

20

39

25

48

50

36

100

27

√

√

√

0) − ((

2))+
w2))))

2) + (w4 + (w4 · w4)))))

w3 · w3))))
0) + (w1 + w1)) + (w1 + w4))+

(((w2 + (w4 + w0)) + ((w4 + w1) + w2
((w3 + w2
w2 − (w1 · w4)) ·
(((((w4 + w0) + (w3 + w2)) + (w1 + (w2 · w2)))+
(w3 + (w4 + w4))) + ((((w0 + w0) + w2)−
(w4 · (w3 − w4))) + (w1 + (
(((((w3 + w0) + w2
((((w4 + w0) + (w2 + w0)) + (w4 + w2))+
(((w3 + w0) + w2
(((((w4 · w4) + (w4 + w0)) + ((w1 + w3)+
(w4 + w2))) + ((w2
((((w1 + w3) + (w4 + w0)) + (w2 + w0))+
(((w2 − w1) · (w2 − w1)) + w2)))
((((w4 + (w3 + w0)) + (w1 − w2
(w0 + w1)) + w2)) + ((w2 + (w4 + w0))+
((w3 + w0) + ((w2 − w3) · (w1 + w3)))))
((((w0 + (w3 · w3)) + w2
1) + (w2 + w1))+
((((w4 + w0) + w3) + w2
1) − (w4 · (w1 − w4))))

3 + w1) + (w0 + (w0 + w4))))+

3)) + ((w4+

Table 1: Algebraic expressions and sizes of the best GP individuals tested for
each embedding dimension.

produced by word2vec. We now summarize our main ﬁndings, framing them
in a critical perspective to address the advantages and the shortcomings of the
approach proposed in this paper.

Learning vs. Exact Prediction

We have observed that GP does not usually predict the exact missing word in a
sentence, i.e., an exact prediction. However, we do not consider this a signiﬁcant
problem. In fact, there are multiple reasonable ways to complete sentences, and
a dataset might itself contain multiple endings for the same sentence. What we
are more interested in is the ability of GP to produce a meaningful completion
of a sentence. This ability is, in some sense, more interesting. It shows that
GP has learned to “navigate” the space given by the word2vec embedding and
produce results that align with the semantics of the sentences.

Dimensionality and Fitness

One interesting observation from the experiments is that the dimensionality of
the embedding has a large inﬂuence on the behavior of GP. First of all, the
increase in the ﬁtness values can be partially dictated purely by geometrical
eﬀects; in fact, the average ﬁtness for the trivial predictors (that predict only the
ﬁrst or last word of a sentence) also increases. However, the increase in ﬁtness
obtained by GP is higher, showing that lower-dimensional spaces might be easier
to manipulate by this kind of GP. Furthermore, the size of the embeddings

13

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

+

+

−

+

+

+

×

w2

+

+

(·)2

w3

w0

w4

w1

w4

w2

√

·

w0

−

√

·

×

√

·

w2

w2

w1

w4

Figure 6: GP tree of the best individual evolved for dimension d = 10 during
one of the runs.

Predicted headline

Regional education to fund youth preschool
Aerial footage of ﬂooded Townsville houses
Greens renew call for tax changes
Napthine to launch new Portland rail
4 charged over 10000 jewellery robberies
Vanstone defends land rights act overhaul
Community urged to seek infrastructure funds
Govt. pressured on company tax bureaucracy
Petition urges probe into abattoir maintenance
Rain does little for central towns

Original

allowance
homes
review
marina
heist
changes
funding
rates
closure
Victoria

Table 2: Examples of test headlines completed by the best GP individual of
dimension 10.

used in this work is quite small compared to the ones usually employed, which
can have up to hundreds of dimensions. The motivation for GP preferring
lower-dimensional spaces is an interesting topic for future investigations.

6 Conclusions and Future Works

In this paper, we introduced a new approach to perform an NLP task, namely
next word prediction, using GP combined with the word embeddings produced
by word2vec. This combination required a way to manipulate vectors via GP
(both as inputs and as outputs), to subsequently be able to “go back” from the
embedding and generate words via GP. We have tested our approach on The
Million News Headlines dataset. To check that the GP trees were not learning
only trivial functions of the input, we have compared their ﬁtness with random
and trivial predictors, showing that GP is actually learning a model of the
language represented by the dataset. By looking at how unseen sentences were
completed, we found that, for dimension 10, a median cosine similarity around

14

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

Figure 7: Distributions of similarity between predicted and original word over
the test set.

0.5 was obtained, and, among the word generated, reasonable completions were
usually obtained. While the results of this work do not top the current state of
the art, our approach shows that GP is a promising technique for this kind of
task, opening many research directions and improvements that, hopefully, will
bring GP among the top techniques in NLP. In fact, we are only moving toward
a possible application of GP to NLP tasks. Here, we mention some possible
directions for future research; the list is by no means exhaustive, but it should
provide an ample spectrum of possible improvements.

We have only employed operators that are pointwise adaptations of the
classical GP operators. An immediate improvement would be to add operators
that are speciﬁc for arrays of unitary length, such as rotations and other linear
transformations.

The GP trees employed are deterministic; if we have two sentences that agree
everywhere except for the word to be predicted, it is impossible to generate
them in a stochastic way. Therefore, an immediate extension is to make the
generation probabilistic. There are multiple ways to accomplish this; among
them, one possibility is to use an entire set of trees for constructing the word
and picking a single tree randomly each time a word needs to be generated.

We also tested our approach only on a single dataset of headlines, and we also
restricted the training to a subset of it. It is essential to extend the approach to
a larger number of datasets; this will require multiple improvements in terms
of scalability of the GP algorithm, and possibly in terms of the management of
low-frequency words, which could also be treated as “unknown” tokens.

While next word prediction has been the focus of this work, our approach
can be extended to generate longer texts by using a “sliding window” methods:
given the words w1, . . . , wk, the word wk+1 is predicted as usual; then, the words
w2, . . . , wk+1 are used to generate wk+2, and so on. Clearly, such an approach
does not keep any internal state in the GP tree, and it leverages only on the last
k words. Therefore, it would be interesting to add a “memory” feature to GP,

15

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

similarly to LSTM networks [23, 12].

Finally, to evaluate the quality of the generated words or sentences, a com-
petitive (or “adversarial”) co-evolution could be employed, where there is a
population of trees that act as the generators of sentences, while another pop-
ulation contains trees that act as discriminators between real and generated
sentences.

Acknowledgments

This work was partially supported by national funds through FCT (Funda¸c˜ao para
a Ciˆencia e a Tecnologia) by the project GADgET (DSAIPA/DS/0022/2018) and
AICE (DSAIPA/DS/0113/2019). Mauro Castelli acknowledges ﬁnancial support
from the Slovenian Research Agency (Javna Agencija za Raziskovalno Dejavnost
RS) under the research core funding No. P5-0410. Luca Mariot acknowledges
ﬁnancial support from COST Action CA15140 – Improving Applicability of
Nature-Inspired Optimisation by Joining Theory and Practice (ImAppNIO).

References

[1] H. Al-Mubaid and P. Chen. Application of word prediction and disambigua-
tion to improve text entry for people with physical disabilities (assistive
technology). International Journal of Social and Humanistic Computing,
1(1):10–27, 2008.

[2] B. Alshemali and J. Kalita. Improving the reliability of deep neural networks

in nlp: A review. Knowledge-Based Systems, page 105210, 2019.

[3] L. Araujo. Genetic programming for natural language parsing. In European
Conference on Genetic Programming, pages 230–239. Springer, 2004.

[4] L. Araujo. Multiobjective genetic programming for natural language parsing
and tagging. In T. P. Runarsson, H.-G. Beyer, E. Burke, J. J. Merelo-
Guerv´os, L. D. Whitley, and X. Yao, editors, Parallel Problem Solving from
Nature - PPSN IX, pages 433–442. Springer, 2006.

[5] L. Araujo. Genetic programming for natural language processing. Genetic

Programming and Evolvable Machines, pages 1–22, 2019.

[6] W. Banzhaf, R. S. Olson, W. Tozier, and R. Riolo. Genetic Programming

Theory and Practice XVI. Springer, 2019.

[7] A. Bartoli, G. Davanzo, A. De Lorenzo, E. Medvet, and E. Sorio. Automatic
synthesis of regular expressions from examples. Computer, 47(12):72–80,
2014.

[8] A. Bartoli, A. De Lorenzo, E. Medvet, and F. Tarlao. Active learning of
regular expressions for entity extraction. IEEE transactions on cybernetics,
48(3):1067–1080, 2017.

[9] A. Bartoli, A. De Lorenzo, E. Medvet, F. Tarlao, and M. Virgolin. Evo-
lutionary learning of syntax patterns for genic interaction extraction. In

16

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

Proceedings of the 2015 Annual Conference on Genetic and Evolutionary
Computation, pages 1183–1190, 2015.

[10] R. Dale, H. Moisl, and H. Somers. Handbook of natural language processing.

CRC Press, 2000.

[11] M. G. De Carvalho, A. H. Laender, M. A. Gon¸calves, and A. S. da Silva. A
genetic programming approach to record deduplication. IEEE Transactions
on Knowledge and Data Engineering, 24(3):399–412, 2010.

[12] M. Ebner. Distributed storage and recall of sentences. Bio-Algorithms and

Med-Systems, 13(2):89–101, 2017.

[13] N. Garay and J. Abascal. Using statistical and syntactic information in
word prediction for input speed enhancement. Information Systems Design
and Hypermedia, pages 223–230, 1994.

[14] N. Garay-Vitoria and J. Abascal. Text prediction systems: a survey. Uni-

versal Access in the Information Society, 4(3):188–203, 2006.

[15] N. Garay-Vitoria and J. Gonzalez-Abascal. Intelligent word-prediction to
enhance text input rate (a syntactic analysis-based word-prediction aid for
people with severe motor and speech disability). In Proceedings of the 2nd
international conference on Intelligent user interfaces, pages 241–244, 1997.

[16] R. Isele and C. Bizer. Active learning of expressive linkage rules using

genetic programming. Journal of web semantics, 23:2–15, 2013.

[17] K.-M. Kim, S.-S. Lim, and S.-B. Cho. User adaptive answers generation
for conversational agent using genetic programming. In International Con-
ference on Intelligent Data Engineering and Automated Learning, pages
813–819. Springer, 2004.

[18] R. Kulkarni. A Million News Headlines, 2018. Accessed on February 1st,

2020.

[19] R. Manurung, G. Ritchie, and H. S. Thompson. An implementation of a
ﬂexible author-reviewer model of generation using genetic algorithms. In
Proceedings of the 22nd Paciﬁc Asia Conference on Language, Information
and Computation, pages 272–281, 2008.

[20] T. Mikolov, K. Chen, G. Corrado, and J. Dean. Eﬃcient estimation of word
representations in vector space. In ICLR (Workshop Poster), 2013.

[21] R. Poli, W. B. Langdon, and N. F. McPhee. A Field Guide to Genetic

Programming. lulu.com, 2008.

[22] C. P. Ros´e. A genetic programming approach for robust language interpre-

tation. Advances in genetic programming, 3:67–88, 1999.

[23] M. Sundermeyer, R. Schl¨uter, and H. Ney. Lstm neural networks for
language modeling. In Thirteenth annual conference of the international
speech communication association, 2012.

17

This is a pre-print version of an article accepted for publication at the Genetic and Evolutionary

Computation Conference – GECCO 2020

[24] A. L. Swiﬃn, J. L. Arnott, and A. F. Newell. The use of syntax in a
predictive communication aid for the physically handicapped.
In 10th
Annual Conference on Rehabilitation Technology, pages 124–126. RESNA-
Association for the Advancement of Rehabilitation Technology, 1987.

[25] H. Venkatagiri. Eﬃciency of lexical prediction as a communication accelera-
tion technique. Augmentative and Alternative Communication, 9(3):161–167,
1993.

[26] T. Young, D. Hazarika, S. Poria, and E. Cambria. Recent trends in deep
learning based natural language processing. IEEE Computational intelli-
gence magazine, 13(3):55–75, 2018.

18

