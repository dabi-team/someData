8
1
0
2

n
a
J

1
1

]

C
D
.
s
c
[

1
v
5
5
8
3
0
.
1
0
8
1
:
v
i
X
r
a

MXNET-MPI: Embedding MPI parallelism in Parameter Server
Task Model for scaling Deep Learning

Amith R Mamidala, Georgios Kollias, Fausto
Artico

IBM T J Watson Research Center
Yorktown Heights, New York, USA

amithr,gkollias,fausto.artico@us.ibm.com

Chris Ward

IBM, Hursley Park
Hursley, UK

tjcw@us.ibm.com

ABSTRACT

ACM Reference format:

Existing Deep Learning frameworks exclusively use either
Parameter Server(PS) approach or MPI parallelism. In this
paper, we discuss the drawbacks of such approaches and pro-
pose a generic framework supporting both PS and MPI pro-
gramming paradigms, co-existing at the same time. The key
advantage of the new model is to embed the scaling ben-
eﬁts of MPI parallelism into the loosely coupled PS task
model. Apart from providing a practical usage model of MPI
in cloud, such framework allows for novel communication
avoiding algorithms that do parameter averaging in Stochas-
tic Gradient Descent(SGD) approaches. We show how MPI
and PS models can synergestically apply algorithms such
as Elastic SGD to improve the rate of convergence against
existing approaches. These new algorithms directly help scal-
ing SGD clusterwide. Further, we also optimize the critical
component of the framework, namely global aggregation or
allreduce using a novel concept of tensor collectives. These
treat a group of vectors on a node as a single object allowing
for the existing single vector algorithms to be directly appli-
cable. We back our claims with suﬃcient emperical evidence
using large scale ImageNet 1K data. Our framework is built
upon MXNET but the design is generic and can be adapted
to other popular DL infrastructures.

KEYWORDS

Deep Learning, Parameter Server, MPI, SGD, Scaling

Permission to make digital or hard copies of all or part of this work
for personal or classroom use is granted without fee provided that
copies are not made or distributed for proﬁt or commercial advan-
tage and that copies bear this notice and the full citation on the ﬁrst
page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy
otherwise, or republish, to post on servers or to redistribute to lists,
requires prior speciﬁc permission and/or a fee. Request permissions
from permissions@acm.org.
Conference’17, Washington, DC, USA
© 2018 ACM. 978-x-xxxx-xxxx-x/YY/MM. . . $15.00
DOI: 10.1145/nnnnnnn.nnnnnnn

Amith R Mamidala, Georgios Kollias, Fausto Artico and Chris
Ward. 2018. MXNET-MPI: Embedding MPI parallelism in Pa-
rameter Server Task Model for scaling Deep Learning. In Pro-
ceedings of ACM Conference, Washington, DC, USA, July 2017
(Conference’17), 12 pages.

DOI: 10.1145/nnnnnnn.nnnnnnn

1 INTRODUCTION

As Deep Learning(DL) continues its dominance in a mul-
titude of disciplines such as Image Classiﬁcation, Speech
Recognition and Natural Language Processing, the need for
DL systems of scale to reduce training times gains utmost
importance. With scientists exploring newer and scalable al-
gorithms, innovation in DL infrastructure and frameworks
is critical to realize their potential on massively large super-
computers. For example, clusters of GPUs interconnected by
high performance networks are being deployed and a major
emphasis is on cloud to lower costs [2, 3, 6, 8]. Also, future
generation machines such as Sierra and Summit[1] would de-
ploy thousands of nodes featuring IBM Power9 processors
with multiple NVIDIA Volta GPUs per node interconnected
by fast InﬁniBand networks.

Almost all of the existing DL frameworks adopt either a
Parameter Server (PS) approach or use MPI parallelism to
scale DL algorithms. MXNET [14], TensorFlow [19] use PS.
CNTK [4], Caﬀee [12, 20, 28] use MPI parallelism. The core
computation done in these algorithms is a parallel Stochastic
Gradient Descent or SGD. In the loosely coupled task model
of PS approach, parallel SGD faces issues such as network
hot-spots and slow convergence due to parameter staleness
at scale. However, it is ubiquitous in cloud computing as it
is inherently fault tolerant and elastic. On the other hand,
MPI has been proven to deliver performance at scale but
lacks a good fault-tolerant support, though ULFM [18] and
its implementations [22, 23, 37],are promising steps in this
direction. Also, dynamic sizing of MPI jobs poses several con-
straints [13]. Both represent opposite ends of the program-
ming space and considerable eﬃciencies can be achieved by
using both at the same time.

 
 
 
 
 
 
Further, as number of workers doing parallel SGD increase,
the algorithm and the system imposes a restriction on how
much scaling is permissible without degrading the perfor-
mance of the algorithm. For example, one of the important
parameter of the SGD is the mini-batch size which cannot
be indeﬁnitely increased due to drop in the accuracy [21, 35]
and reduced parallel eﬃciencies due to increasing commu-
nication costs [30]. Hence, a very important and pertinent
question to ask is are the existing DL frameworks suitable
for cluster wide scaling?

A crucial step for performance in SGD is the aggregation of
gradient or parameter vectors of the model from each GPU
and across the nodes. With the architectures oﬀering new
CPU, GPU topologies interconnected by high bandwidth
networks such as NVLINK[1] can the existing collective al-
gorithms operating on one vector per worker still apply?

In this paper, we focus on these issues. In particular,

1) We design, implement, evaluate a MXNET based frame-
work supporting both PS and MPI parallelism at the same
time by embedding MPI based collective primitives in the
computation graph. The central idea is to make an inde-
pendent MPI_COMM_WORLD job client to the PS. The
number of clients is tunable, oﬀering knobs for a smooth
transition from PS on one end to pure MPI on the other
end. This generic design oﬀers ﬂexibility to work with a va-
riety of algorithms across traditional HPC and cloud based
infrastructures.

2) Using large scale ImageNet 1K [47] we demonstrate the
key beneﬁts of our approach, namely better scaling by reduc-
ing network contention and alleviating parameter staleness.
The new model allows this by reducing number of clients
and instead scaling each client. Compared to the default PS
approach, our method improves the time per epoch by six
times and also improves the rate of convergence at the same
time.

3) We design a new MPI Elastic SGD algorithm allowing
synchronous SGD methods within a MPI communicator and
asynchronous lazy update of parameters outside. This allows
new opportunities for scaling DL algorithms cluster wide. On
the ImageNet we show more than 2X improvement in rate of
convergence compared to all the major approaches of parallel
SGD.

4) We demonstrate a new class of multi-node tensor collec-
tives. The central idea used in these primitives is to design
collective operations around a GPU tensor per worker in-
stead of a single vector per GPU. Using our optimizations,
we arrive at validation accuracies over 0.72 for the complete
ImageNet 1K training on a IBM Minsky cluster [9].

We now describe the SGD optimization method, the funda-
mental numerical gradient optimization used in almost all
the popular frameworks.

2

2 SGD

In this section, we explain the major issues in parallel and
distributed SGD. This motivates the need for appropriate
MPI adaptations of these algorithms for scaling.

2.1 Mini-Batch SGD

In a mini-batch SGD, the entire data is divided into several
mini-batches, collectively known as the “epoch". The com-
putation iterates over the epoch, one mini-batch at a time.
The model parameters at iteration t, wt are updated by an
increment ∆w to get the parameters for the next iteration.
wt+1 = wt + ∆w
(1)
∆w is computed as ∆w = −ηg, where g is the gradient, η is
a hyper parameter called as the learning rate. For the deep
learning models, the model parameters and gradients are as-
sociated with the diﬀerent network links across the layers.
The gradients are obtained after doing a forward pass and
then an auto-diﬀerentiation in the backward step. The ﬁnal
gradient, g is the average of all the gradients obtained from
the data samples in a mini-batch. Also, since the gradients
are obtained as soon as a backward step for a layer is com-
puted, these can be aggregated in parallel with the backward
phase of the previous layer for parallel SGD described below.

2.2 Parallel SGD

In parallel SGD[39, 44, 46], each worker processes an inde-
pendent portion of the data set. The many versions of the
parallel SGDs diﬀer in the manner gradients and parameters
are computed and how the mini-batches are constructed. In
parallel synchronous SGD, the mini-batch is divided across
all the workers and all workers wait for global average of lo-
cally computed gradients, g before computing the next set
of parameters, wt+1, equation 1. In asynchronous form, each
worker gets a separate mini-batch and doesn’t aggregate gra-
dients from other workers. After every iteration, it interacts
with a PS only to push the locally computed averaged gra-
dient, g and pull the latest parameters,wt+1 for their next
mini-batch [31]. Please note that we use PS interchangeably
to mean the model and also refer to the parameter servers
of the framework.
New algorithms such as Elastic Averaging[48], Federated Av-
eraging [40] allow further decoupling with the PS. In stead of
interacting with PS after every iteration, they compute the
weights locally and use PS to lazily compute the average of
weights wt rather than gradients for the next mini-batch. For
elastic averaging, the PS stores an additional set of model
weights called as center variables, ˜w. The update 2 is done
on the server and 3 is done on the client. α is another hy-
per parameter, like the learning rate of SGD, passed to the
algorithm.

˜wt+1 = ˜wt + α ∗ (cid:0)wt − ˜wt(cid:1)
wt+1 = wt − α ∗ (cid:0)wt − ˜wt(cid:1)

(2)

(3)

2.3

Issues with Parallel SGD

3 DL USING MXNET

We now explain the diﬀerent issues with parallel SGDs.
Network Contention: One of the major issues faced with Syn-
chronous SGD is the network hot spot as a single incoming
link to a server is shared across multiple workers [27]. As the
PS model scales, using multiple servers alleviates the con-
tention at the server side. However, the number of workers
still poses a challenge. In Fire-Caﬀe [33], a hierarchical tree
approach is used to aggregate the gradients from the workers.
However, these approaches do not utilize all the underlying
communication links and are heavily dependent on the net-
work topology of the machine. Instead, MPI solves the prob-
lem by deploying state-of-the-art parallel algorithms which
can adapt to any underlying topology. Thus, grouping work-
ers into logical MPI cliques as shown in ﬁgure 1 signiﬁcantly
resolves contention on PS.

forms of SGD face the issue of

Parameter Staleness: As the number of workers increases,
asynchronous
stale-
ness [25, 49], which inhibit a fast rate of convergence.
Grouping workers
into MPI clients potentially oﬀers
two immediate advantages: a) It reduces the variance
the gradient updates by eﬀectively increasing the
of
mini_batch_size [24]. In [42], the number of
iterations
to converge is halved as the mini_batch_size is doubled.
b) reduces total number of workers. Depending on the
algorithm and the distribution of data, one or both the
factors improve the rate. For example, the MPI elastic
averaging algorithms studied in this paper beneﬁt from
both. Such models oﬀer potential to scale to a full scale
machine comprising of thousands of GPUs.

Memory Pressure and Batch Size: One of the main issues in
the implementation of DL systems is memory pressure [29,
45], which keeps growing as the number of levels of the
network increase. This restricts the choice of batch size of
a DL worker to smaller values as the total memory per
worker is dictated by the hardware. There are ineﬃcien-
cies using smaller batch sizes. Grouping workers to larger
batches should improve performance as long as the batch
sizes falls within algorithmic stipulated limits. Moreover, the
new framework also allows the ﬂexibility to decouple depen-
dency between the model mini batch size and memory limits
per worker, allowing for a possibility of porting models across
diﬀerent hardware architectures.

We come up with a general framework using MPI and PS
that addresses these challenges. The existing approaches
have either dealt with one or another but to the best of
our knowledge, there is no architecture that addresses all of
these in a holistic fashion. We use MXNET to demonstrate
the new model but the design proposed is ﬂexible and
can be adapted to diﬀerent architectures. MXNET[14]
framework, deployed by Amazon in the cloud, is actively
developed providing convenient abstractions at many higher
level languages [26, 38].

3

MXNET uses a declarative computation graph to express the
diﬀerent computations of the DL network and an imperative
KVStore to allow for parallelization of deep learning models.

3.1 Computation Graph and Execution Model

A declarative model expresses the neural network com-
putation as a graph with all the data ﬂow dependencies.
The computation is not immediately executed but rather
optimized for eﬃciency in memory usage and runtime.
Internally, a dependency engine tracks all the operations
that can be executed in parallel using the data ﬂow
graph. The MXNET dependency engine is generic and
can schedule any operation, provided it is tagged with
explicit read and write dependencies, shown below. An
operation like a = b + 1 can be performed by constructing
the following lamda function and pushing to the engine:
Engine.push(lambda:a.data=b.data+1, read=[b.tag],
mutate=[a.tag]).
As we describe in the next section, these lamda functions
become key constructs to oﬄoad MPI communications and
integrate into the data ﬂow graph.

3.2 KVStore based Aggregation

The network parameter and the gradients are expressed
as multi-dimensional tensors, implemented as ndarrays in
MXNET. Being a data parallel model, the data for a worker
is further split across all local GPUs. Hence, there are N
such tensors per worker, one per GPU and N GPUs per
worker. As described in 2, parallel SGD needs to aggregate
gradients across all the GPUs before taking the next step.
A similar global aggregation needs to be done across all the
workers for solving a synchronous SGD.

The KVStore API provides access to a distributed <key,
value> at the PS. For every mini-batch, the worker com-
putes relevant local updates about the model and uses the
KVStore Push and Pull API to synchronize them to a glob-
ally visible set of model variables at PS. Both primitives take
a list of keys and list of values. The python snippet in ﬁgure
2 illustrates the semantics of the operation. As shown in the
ﬁgure, three keys are initialized in the KVStore to tensors of
a default shape and value (line 2). In the DL algorithm, these
keys would correspond to the model weights and initialized
to random values using a given distribution. A tensor list
is a succinct representation of the tensors across each level,
identiﬁed by the key and also one from each GPU of the
worker(line4). The push operation (line 6) ﬁrst locally aggre-
gates all the tensors of the same key before pushing to the
distributed KVStore. The pull fetches the tensor from the
KVStore server corresponding to the given key and copies it
to all relevant tensors in tensorlist (line 7).
The KVStore API also permits remotely conﬁguring the
server to use diﬀerent SGD optimizations like momentum

PARAMETER SERVER + MPI MODEL

PARAMETER SERVERS

scheduler

SERVER PROCESSES

MPI CLIENT 0

MPI CLIENT 1

MPI CLIENT 2

COMM_WORLD

COMM_WORLD

#servers

#workers

#clients

LAUNCHER

WORKER

PROCESSES

LSF

RESOURCE

MANAGER

BSUB(mpirun client 0)

Figure 1: MPI + Parameter server

1
2
3
4
5
6
7
8

keys=[1,3,9]
kvstore . init (keys,

[mxnet.ndarray.ones(shape)]∗len(keys))

tensorlist =[mxnet.ndarray.ones(shape,gpu)

for gpu in gpus]∗len (keys)

kvstore .push(keys, tensorlist )
kvstore . pull (keys, tensorlist )
kvstore .set_optimizer(algorithm)

Figure 2

SGD, AdaGrad(line 8). We use this to design the elastic av-
eraging technique in MXNET-MPI, described in section 5.

4 KVSTORE-MPI FRAMEWORK

The basic idea to make the MPI and PS model co-exist is
to design a hybrid KVStore-MPI framework extending the
existing set of KVStore APIs discussed earlier. In this sec-
tion we discuss the various design issues to realize the model
shown in Figure 1 using this new framework.

4.1 MPI+PS System Architecture

4.1.1 Namespaces. Each worker in the integrated model
has identities in two independent namespaces: PS and MPI.
In order to do aggregation operations across the workers
belonging to the same client, the worker invokes the MPI
call usings its MPI rank. For PS updates, it uses its unique
name and rank in the PS namespace. In MXNET, each task
is either a scheduler, server or a worker as shown in the ﬁgure.
In the PS namespace, the scheduler is connected to all the
workers and the servers. And each worker is connected to
all the servers. MPI Communicators on the other hand are

4

created only among the workers belonging to the same client.
We explain how a client is constructed below.

4.1.2

Job Launch. We use IBM’s LSF [10] administered
cluster as our underlying core infrastructure. A launcher is
executed on the front end node of the cluster and speciﬁed
the following parameters: #workers, #servers and #clients.
The launcher computes the number of workers in each client
using this information. It always launches a MXNET sched-
uler task ﬁrst as it listens for all the incoming connections
from workers and servers. The address of the scheduler and
port information is broad casted to all tasks via the launcher
when it spawns them so that connections between the work-
ers and servers can be established. The launcher uses LSF’s
bsub command to launch each client as a separate job. In our
case, each of these jobs start using mpirun. LSF transpar-
ently manages what hosts to pick the job. Further, #servers
can be tunable, with #servers equal to zero for pure MPI
jobs.

4.2 Embedding MPI in the Computation Graph

Except for creation of KVStore, all the other API calls use
C++11 lambda functions to "oﬄoad" MPI communication
to the dependency engine thread in a manner similar to as
shown in section 3. The operations are enqueued in order to
avoid deadlocks.

4.2.1 KVStore.create("type"). MPI version of KVStore
is constructed by passing appropriate type to the function.
Apart from the existing synchronous and asynchronous
version supported by MXNET, the additional types would
be Synchronous-MPI and Asynchronous-MPI. We provide
more details in the following section on how these are used.
For MPI, all the workers call MPI_Init() to create their
own MPI_COMM_WORLD and become a single MPI

PUSH, PULL from individual workers

PUSH from MPI Communicator

PULL from MPI Communicator

SERVER
GROUP

SERVER
GROUP

SERVER
GROUP

Scheduler

Scheduler

REDUCE/ALLREDUCE

BROADCAST

(cid:1)(cid:1)
(cid:0)(cid:0)
(cid:0)(cid:0)
(cid:1)(cid:1)
(cid:0)(cid:0)
(cid:1)(cid:1)

(cid:1)(cid:1)
(cid:0)(cid:0)
(cid:0)(cid:0)
(cid:1)(cid:1)

Scheduler

(cid:1)(cid:1)
(cid:0)(cid:0)
(cid:0)(cid:0)
(cid:1)(cid:1)
(cid:0)(cid:0)
(cid:1)(cid:1)

(cid:1)(cid:1)
(cid:0)(cid:0)
(cid:0)(cid:0)
(cid:1)(cid:1)

WORKER GROUP

COMM_WORLDS

COMM WORLDS

Figure 3: Primitives: push and pull

client. When there are servers, the rank 0 in PS name space,
initializes the values of all the keys on the servers which are
subsequently pulled by the rest of the workers. When there
are no servers, we use MPI_Bcast to initialize the weights
across all the workers.

4.2.2 KVStore.push(key, src_tensor_list). In this call, all
the workers with rank 0 act as the masters that communicate
with the server. In the Push API, tensor allreduce is ﬁrst
used to aggregate the gradients across the workers in its
communicator. The master then uses the native MXNET
C++11 call, ZPush to push the result to the server. The
entire operation is coded as a lambda function and pushed
to the engine, along with the necessary read dependencies
shown in Figure 4. In [20], the authors also use threaded
progress to overlap computation and communication. Their
approach is speciﬁc to the implementation and doesn’t use
dependency tracking.

auto push_to_servers = [this, key, vals ]() {
allreduce ( vals .data, vals . len , vals .type , comm);
if (mpi_rank == 0)ZPush(key, vals.data, vals.len, NULL);
}

1
2
3
4
5 Engine.Push(push_to_servers, read_deps(vals.tag), mutate(none));

Figure 4

4.2.3 KVStore.pull(key, dst_tensor_list). In the Pull API,
the master worker calls broadcast after pulling the value
from the KVStore, as shown in ﬁgure 5. This is coded as an-
other nested C++11 lambda function passed into the ZPull
API for master whose mpi_rank is zero. Meanwhile, all the
others call broadcast.

auto pull_from_servers = [this, key, vals ]() {
if (mpi_rank == 0)

1
2
3 ZPull(key, vals .data, vals . len ,
4
5
6
7 Engine.Push(pull_from_servers, read_deps(none), mutate(vals.tag));

[ vals , comm](){bcast(vals.data, vals . len , vals .type ,0, comm)});
else bcast ( vals .data, vals . len , vals .type , 0, comm));
};

Figure 5

5 KVSTORE-MPI DISTRIBUTED

ALGORITHMS

In this section, we show python pseudo codes that each
worker in a mpi client executes in the new framework for
the three main algorithms discussed in section 2.

Synchronous SGD(SGD): In MXNET, each worker is as-
signed a set of data batches, each with a ﬁxed batch_size
which it iterates on. The batch_size is a scheduling unit
of MXNET and is diﬀerent from the mini_batch_size of
the algorithm. As shown in ﬁgure 6, the executor oﬄoads
the declarative computation graph to the engines on line 4.
The Push and Pull integrate into this engine by explicitly
mentioning the dependencies for scheduling as shown in the
previous section. In the default PS, the servers aggregate
all the gradients issued by the worker. However, using MPI
the gradients are ﬁrst aggregated in the respective clients
before being pushed to the servers. The mini_batch_size
for synchronous SGD, is num_workers ∗ batch_size (line
10). For the pure MPI mode, without servers, the Push
and Pull calls are replaced by the new PushPull API and
optimized using tensor allreduce.

4.2.4 KVStore.pushpull(key, src_tensor_list, dst_tensor_list).

This is a new API added into MXNET with help from
MXNET team, that fuses the Push and Pull
into one
call. This oﬀers a convenient interface amenable to MPI
acceleration. Instead of calling the ZPush, ZPull APIs we
directly call tensor allreduce, described in section 7.3.

Asynchronous SGD(ASGD): In this method, the MPI Client
executes the asynchronous SGD algorithm and updates the
parameter values as shown in Figure 7. The speciﬁc optimiza-
tion function is shipped to the server on line 2 along with
the scaling associated with the mini_batch_size. In the
MPI version, this is equal to num_workers_per_client ∗

5

Executor. Forward_backward(net.symbol, net.params,

net. grads , batch)

1 Kvstore.Create("Synchronous−MPI")
for epoch in range(num_epochs):
2
for batch in train_data:
3
4
5
6
7
8
9
10
11 Executor.ValidationAccuracy(test_batch)

Kvstore.Push(key, net. grads [key])
Kvstore.Pull(key, net. grads [key])

SGD.Update(net.params, net.grads,

for key in range(num_tensors):

rescale =1/mini_batch_size)

and 12 respectively in the ﬁgure. In our experiments, the
INTERVAL is set to 64. The mini_batch_size is equal to
num_workers_per_client ∗ batch_size.

6 TENSOR COLLECTIVES

In this section, we describe the design of tensor allreduce that
is exclusively used to aggregate gradients from the GPUs
across the cluster.

Figure 6

6.1 Tensor Operations

batch_size. The client pushes the locally computed gradi-
ents within the communicator and pulls back the new pa-
rameter values after the server has ﬁnished updating them.

for batch in train_data:

for epoch in range(num_epochs):

1 Kvstore.Create("Asynchronous−MPI")
2 Kvstore.set_optimizer(SGD, rescale=1/mini_batch_size)
3
4
5
6
7
8
9

Kvstore.Push(key, net. grads [key])
Kvstore.Pull(key, net.params[key])

Executor.Forward_backward(net.symbol, net.params,

for key in range(num_tensors):

net. grads , batch)

10 Executor.ValidationAccuracy(test_batch)

Figure 7

Executor.Forward_backward(net.symbol, net.params,

for batch in train_data:

iter = 0
for epoch in range(num_epochs):

1 Kvstore.Create("Asynchronous−MPI")
2 Kvstore.set_optimizer( Elastic1 , rescale =alpha)
3
4
5
6
7
8
9
10
11
12
13
14
15 Executor.ValidationAccuracy(test_batch)

for key in range(num_tensors):
if ( iter %INTERVAL == 0):

Kvstore.Push(key, net.params[key])
Kvstore.Pull(key, net. centers [key])
Elastic2 .( net.params[key], net. centers [key ], rescale =alpha)
SGD.Update(net.params, net.grads, rescale =1/mini_batch_size))
iter = iter + 1

net.grads , batch)

Figure 8

Asynchronous Elastic SGD(ESGD): As shown in Figure 8,
the MPI client computes SGD within its communicator. The
model parameters are pushed/pulled from the server after
a certain number of iterations using elastic averaging dis-
cussed in section 2.2. Elastic1 is done by the server based on
equation 2 and it updates the center variables. The second
equation 3 is done by the MPI client using Elastic2 updat-
ing its local model parameters. It is shown in the steps 2

6

We deﬁne a tensor to be a grouping of vectors, one from each
GPU such that communication operations within a tensor
are extremely fast and are expected to scale well as more vec-
tors are added. This is possible because of the growing band-
widths of NVLINK interconnecting the GPUs and launching
cuda kernels directly on the GPUs for doing the operation.
For example, the widely used NCCL exclusively uses special
kernels to do all the diﬀerent kinds of operations within the
tensor, important being reduce, allreduce, bcast and reduce-
scatter. Moreover, for multi-node collectives, thinking about
group of vectors as a single unit allows applying several well
known collective algorithms that have been used only on one
vector at a time.

This is especially true on the IBM Minsky machines.
Figure 10 shows the architecture of a Minsky node. Each
node consists of two sockets and is directly connected to
two NVIDIA P100 Pascal GPUs with independent NVLINK
links. The two GPUs are also directly connected to each
other using another NVLINK. Essentially, the CPU and
the two GPUs in a socket form a 3-clique. Future machines
would also allow for a 4-clique conﬁguration where all the
compute elements are directly connected to each other
using NVLINK. We exploit this property to simultaneously
operate on vectors from each GPU, collectively a tensor.

6.2 Bucket Algorithms

One of the popular choice for designing bandwidth optimized
large message collectives is to use bucket algorithms. These
algorithms use a logical ring which is well known to work in a
wide variety of cluster topologies [34, 43]. In these algorithms,
an allreduce is implemented by a reduce-scatter followed by
allgather. It has been proven that these algorithms reach the
lower bound for bandwidths. The total cost of the operation
is (cid:0)p − 1(cid:1)α+2 p−1
p nγ. α is the latency term, β is the
bandwidth cost per byte and γ is the compute cost per byte.
n is the total number of bytes used in the operation. For
reduce-scatter, the buﬀer from each process is partitioned
into nearly equal parts and after the operation, each process
holds a piece of the ﬁnal reduced sum in its partition.

p nβ + p−1

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

6.3 Bucket Algorithms on IBM Minsky GPU

tensors

On Minsky nodes, the ring connecting every GPU is not
optimal. As shown in the ﬁgure, data has to be explicitly
copied into the GPU from the host memory as network can-
not reach the GPU memory via NVLINK. This would add
two extra hops and double the time per ring step. Instead,
all our rings use only the host memories. As we show in sec-
tion 7, we obtain very high bandwidths for the tensor reduc-
tion and broadcast operations from host memories. Further,
the number of hops of the ring is halved as we group the two
GPUs from each socket to form a tensor under one worker.

6.3.1 Tensor Allgather. To design this operation, we re-
write the ring algorithm used in OpenMPI [16] to handle
CPU and GPU memories. A pair of buﬀers is used, one for
receiving data from the left neighbor and the other to send
data to the right neighbor. In addition to sending the data to
its neighbor, we also invoke the broadcast operation from the
host buﬀer to the tensor to overlap the two. Our implementa-
tion is organized as a generic GPU tensor library of routines
on top of MPI. The tensor library can either use NCCL [15]
or custom implementations tailored to IBM’s node architec-
ture. For example, to broadcast the tensor on Minsky from
host, we invoke two simultaneous cudaMemcpyAsync() [5]
calls as the topology allows two diﬀerent links to the GPUs.

p
2

−1
p
2

the compute cost now becomes

6.3.2 Tensor Reduce-Scatter. This operation uses the
standard bucket algorithm used for buﬀers in the host
memory with one main diﬀerence. Instead of reducing a
partition of the buﬀer with the incoming data, a partition
of the tensor is used as shown in the ﬁgure 10. However,
nγNV where γNV is
the reduction cost over NVLINK. We further optimize
the operation by overlapping this compute cost with the
network transfer. Overlapping this operation within a single
ring is not possible as the next communication step of the
ring depends on the result of the previous reduction. Thus,
we design a multi-ring algorithm where the reduction of
the next ring is overlapped with the network transfer of
the current ring. The complete tensor_allreduce operation
is described in ﬁgure 9. The buﬀer is split equally among
the rings and allreduce[ring] operates on the portion of
the buﬀer assigned to it. It uses non blocking GpuStart()
routines to launch the CUDA kernels simultaneously with
network transfers.

uint64_t ring = 0;
allreduce [ ring ]. GpuStart(buﬀer [ ring ], step [ ring ]);

while ( step [NUM_RINGS−2] <= size){

nextbuf = buﬀer [( ring+1)%NUM_RINGS];
nextstep = step[( ring+1)%NUM_RINGS];
nextring = (ring+1)%NUM_RINGS;
allreduce [ nextring ]. GpuStart(nextbuf,nextstep );
buﬀer [ ring ] = allreduce [ ring ]. GpuWait();
if ( step [ ring ] != size ){

buﬀer [ ring ] =
allreduce [ ring ]. SendRecv(buﬀer[ ring ], step [ ring ]);

}
step [ ring]++;
ring=(ring+1)%NUM_RINGS;

}

buﬀer [ ring ] = allreduce [ ring ]. GpuWait();
for (unsigned ring = 0; ring < NUM_RINGS; ring++) {

allreduce [ ring ]. allgather ( buﬀer [ ring ]);

}

Figure 9

We ran our tests on two experimental testbeds. Each worker
is a process running on a socket and connected to two
GPUs.

testbed1: We use a total of 8 dual-socket power8 nodes
with 2 Kepler GPUs attached to each socket.The nodes are
connected using InﬁniBand ConnectX-4 adapters. Using
this testbed, we demonstrate the utility of combining MPI
and PS models. The batch size used is 128 per worker,
capped by GPU memory constraints. The following modes
of parallelization of model are compared:
1)dist-SGD: Uses default PS tasks, all executing synchro-
nous SGD
2)dist-ASGD: Uses default PS tasks, all executing asynchro-
nous SGD
3)dist-ESGD: Uses default PS tasks, all executing asynchro-
nous ESGD
4)mpi-SGD: Uses MPI+PS where gradients are
syn-
chronously aggregated ﬁrst at the MPI clients and next at
the PS.
5)mpi-ASGD: Uses MPI+PS with gradients synchronously
aggregated at the MPI Clients but pushed asynchronously
to the PS
6)mpi-ESGD: Uses MPI+PS with asynchronous elastic
averaging, where the model is computed at the MPI Clients
but elastically averaged asynchronously at the PS.

7 EVALUATION

In this section, we explain the training eﬃciencies obtained
using the new model of MPI + PS on ImageNet 1K.
ImageNet 1K contains about 1.2M images with 1000 classes.
The total size of the training data used is 336GB and
test data is 13GB. We use the latest network, Residual
networks(resnet) [32] using 50 layers for image classiﬁcation.

7

testbed2: Comprises of 32 IBM Minsky Power8 nodes with
4 NVIDIA Pascal GPUs on each node connected with Inﬁni-
Band CX5 adapters. On this testbed, we demonstrate the
tensor collectives and also show the scaling behavior of Ima-
geNet training using the optimizations proposed.

The following metrics are used to measure the performance
of our approaches:

GPU 0

P8 SOCKET

NVLINK1

NVLINK1

NVLINK1

HOST MEMORY

P8

To IB

P8 SOCKET

GPU TENSOR

GPU TENSOR

GPU 1

GPU 0

GPU 1

NVLINK1

NVLINK1

NVLINK1

(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)

(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)

(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)

(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)
(cid:1)(cid:1)(cid:1)(cid:1)
(cid:0)(cid:0)(cid:0)(cid:0)

FROM NEIGHBOR

FROM NEIGHBOR

Powwer BUS

P8

HOST MEMORY

TO NEIGHBOR

TO NEIGHBOR

To IB

Four Process Ring with two GPUs per process, only two processes shown

Figure 10: Tensor Allreduce: ring

a) Epoch Time: It’s time taken by the workers to train the
model over the mini-batches of the epoch assigned to it. For
multiple workers, we take the average time over all the work-
ers.

b) Validation Accuracy: The accuracy obtained by using the
model on the the separate test samples, done after every
epoch.

7.1 KVStore-MPI SGD & ASGD

Figure 11 shows the ImageNet validation results vs time. On
testbed1, we run 12 DL workers two per node using 6 nodes.
The two servers are run on the two remaining nodes. From
the ﬁgure, mpi-SGD trains signiﬁcantly faster than dist-SGD
and mpi-ASGD faster than dist-ASGD. As observed from
the ﬁgure 12, using mpi removes the contention, which re-
duces the time taken for an epoch by the mpi clients vis-a-vis
their counterparts. We use two mpi clients with 6 DL work-
ers each interacting with the same two servers. The hot spot
is transferred to the mpi client which is better equipped to
solve the problem. Also, though the mpi-ASGD is the fastest
in the epoch time, it converges slower than mpi-SGD. This
is attributed to staleness [49] where the worker uses param-
eters from older time steps to compute the gradients. An-
other factor attributing to the fast convergence of mpi-SGD
is the increase in mini_batch_size as eﬀectively gradients
from 12 workers are averaged which reduces the variance in
updates [24, 42]. Thus, MPI can be used eﬀectively with PS
models and the design used in the paper can be replicated
in data centers considerably lowering the barrier of adoption
of MPI into cloud.

7.2 KVStore-MPI ESGD

From the previous section, we saw that mpi-SGD is outper-
forming the rest. However, the scaling of mpi-SGD is depen-
dent upon the communication bandwidth available for each
worker. Even if the problem is weak scaled across nodes keep-
ing batch size the same, the communication cost is expected
to increase as the total communication bytes remains the

y
c
a
r
u
c
c
a

n
o
i
t
a
d

i
l

a
V

0.5

0.4

0.3

0.2

0.1

0.0

0

dist-SGD

dist-ASGD

mpi-SGD

mpi-ASGD

5000

10000

15000

20000

25000

time (secs)

Figure 11: dist-vs-MPI SGD optimizations

)
s
c
e
s
(

e
m

i
t

h
c
o
p
e

e
g
a
r
e
v
A

7000

6000

5000

4000

3000

2000

1000

0

D

dist-S G

D

dist-A S G

D

m pi-S G

D

m pi-A S G

D

m pi-E S G

D

dist-E S G

Figure 12: Imagenet Avg Epoch time (seconds)

same. After a while, adding extra nodes would oﬀer no ben-
eﬁt [42], as we also see in section 7. The problem is further
exacerbated due to the rapid increase in ﬂop count of modern
day GPUs [41]. Thus, having communication avoiding algo-
rithms is extremely helpful if we were to scale cluster wide.

8

 
 
 
 
y
c
a
r
u
c
c
a

n
o
i
t
a
d

i
l

a
V

0.5

0.4

0.3

0.2

0.1

0.0

0

mpi-SGD

mpi-ASGD

mpi-ESGD

dist-ESGD

5000

10000

15000

20000

25000

time (secs)

Figure 13: KVStore-MPI based SGD optimizations

ESGD meets this objective. Figure 13 shows the comparison
of two ESGD approaches compared to mpi-SGD, mpi-ASGD.
The mpi-ESGD approach performs the best compared to the
rest. Here, we use two MPI clients doing independent SGD
within the communicators but loosely synchronizing with the
PS. Using mpi-ESGD family of protocols provides a path to
scale to a full machine. This is seen clearly from ﬁgure 14
with mpi-ESGD out performing mpi-SGD, reaching 0.67 val-
idation accuracy for a multiple epoch run.

It can also be seen that dist-ESGD, with 12 workers is doing
the worst of all, in spite of having the same average epoch
time as mpi-ESGD with two clients. This is because using
the mpi-ESGD model allows us to restrict the number of
workers and yet allow the scaling of each worker so that
staleness is minimized and the optimization algorithm can
take advantage of larger mini batch sizes. However, not all
application domains and data sets favor increasing the batch
size [35], where dist-ESGD would help. This motivates the
need for a generic framework as done in this study.

y
c
a
r
u
c
c
a

n
o
i
t
a
d

i
l

a
V

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

0.0

0

mpi-SGD

mpi-ESGD

10000

20000

30000

40000

50000

60000

70000

time (secs)

Figure 14: Impact of MPI ESGD

)
c
e
s
/
s
e
g
a
m

i
(

e
t
a
R

7000

6000

5000

4000

3000

2000

1000

0

reg-IBMGpu  (weak scaling)
ring-IBMGpu (strong scaling)
ring-IBMGpu (weak scaling)

2

4

8

Number of nodes

Figure 15: Resnet-50 Scaling behavior

y
c
a
r
u
c
c
a

n
o
i
t
a
d

i
l

a
V

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

0.0

0

resnet-50-bs-2048-np-32

resnet-50-bs-1024-np-32

resnet-50-bs-4096-np-64

5000

10000

15000

20000

25000

30000

35000

time (secs)

Figure 16: Resnet-50 Learning curves

7.3 Tensor Allreduce

For doing reductions into host memory, we use either NCCL
or IBMGpu, the direct implementation using cuda kernels
for doing math. In this approach, the two vectors of the ten-
sor, one on each GPU are split into half and two kernels
are launched on the two GPUs to add each in parallel as
shown in the ﬁgure 10. This allows us to achieve a reduc-
tion bandwidth of 30 GB/sec with the ﬁnal result put back
in the host memory. The upper bound would be the write
b/w of memory which is 38.4 GB/sec/socket. With NCCL,
we achieve 12 GB/sec with one set of communicators and 15
GB/sec with two sets of communicators. NCCL uses only one
thread block where as IBMGpu uses all 112 thread blocks
with 1024 threads to keep multiple read/write requests in
ﬂight. For broadcast, both IBMGpu and NCCL achieve a
b/w of 28 GB/sec. We use the GPU reduction and broadcast
routines as a building block to evaluate the diﬀerent design
options of doing tensor allreduce and pick the best among
them. The diﬀerent approaches studied are: a) ring-IBMGpu

9

 
 
 
 
design discussed in section 7.3 using two rings,b)ring-NCCL
using NCCL with one ring as NCCL operations are blocking
in nature, c) omp_ring-IBMGpu, where the design is simi-
lar to the ﬁrst two, except that the entire buﬀer is reduced
into the host memory and then the host based bucket algo-
rithm is applied with the ﬁnal results copied back into the
GPU. We use 8 OMP threads for data reductions and d)
reg-IBMGpu, where the data is reduced into host memory
and then the default MPI_Allreduce is used, followed by a
broadcast, with pipelining across the three stages.

As shown in ﬁgures 17, 18, 19 the IBMGpu ring is doing
the best. Apart from using one thread block, another reason
for lower NCCL bandwidth is the use of only one NVLINK
while doing reduce. For very large messages, the performance
gap diminishes across the three as the memory bandwidth
becomes the bottleneck. We also see that on Minsky ma-
chines we out perform Baidu’s ring implementation connect-
ing every GPU, ﬁgure 20 by a factor of six, for the same
number of GPUs. We also run large scale ImageNet runs us-
ing resnet-50 on testbed2 with #servers=0, and using mpi-
SGD. Our optimizations are nearly twice as fast than using
the default, reg-IBMGpu approach, with weak scaling do-
ing the best of all, ﬁgure 15. For strong scaling, the batch
size is recursively halved where as it remains constant for
weak scaling. Figure 16 shows the model convergence with
our optimized MPI implementation over MXNET and we
observe over 0.72 model accuracy, which is the current state-
of-the-art. We use an initial learning rate of 0.5 instead of
the default 0.1 because of using a larger batch size.

omp_ring-IBMGpu

ring-IBMGpu

ring-NCCL

reg-IBMGpu

0.020

0.015

0.010

0.005

)
s
c
e
s
(

e
m

i
t

0.000

2

8

32

Number of nodes

Figure 17: 4MB(Message Size)

8 CONCLUSION

In this paper, we described a hybrid MPI + PS model with
a ﬂexibility to allow scaling diﬀerent DL optimization meth-
ods. Though the existing framework supports data paral-
lelism, it can be readily extended to model parallelism. For
example, in MPI-ESGD, the parameters can be computed

omp_ring-IBMGpu

ring-IBMGpu

ring-NCCL

reg-IBMGpu

2

8

32

Number of nodes

Figure 18: 16MB(Message Size)

omp_ring-IBMGpu

ring-IBMGpu

ring-NCCL

reg-IBMGpu

2

8

32

Number of nodes

Figure 19: 64MB(Message Size)

ring-IBMGpu (4)

ring-IBMGpu (8)

ring-IBMGpu (16)

Baidu (4)

Baidu (8)

Baidu (16)

)
s
c
e
s
(

e
m

i
t

0.045

0.040

0.035

0.030

0.025

0.020

0.015

0.010

0.005

0.000

)
s
c
e
s
(

e
m

i
t

0.18

0.16

0.14

0.12

0.10

0.08

0.06

0.04

0.02

0.00

0.45

0.40

0.35

0.30

0.25

0.20

0.15

0.10

0.05

)
s
c
e
s
(

e
m

i
t

y
c
n
e
t
a
L

0.00

0.0

0.5

1.0

1.5
Message size (bytes)

2.0

2.5

3.0

1e8

Figure 20: IBMRing-vs-BaiduRing

using model parallel optimizations. Also, the framework en-
ables a path for MPI to be useful in cloud based scenar-
ios as it inherits all the task based model attributes needed

10

 
 
 
 
 
for fault-tolerance and elasticity. LSF also allows for auto-
matic restart of mpi jobs [11] thus permitting fault recovery.
Importantly, by embedding MPI into the python modules,
the framework allows the user to focus on the algorithms
and not deal with explicit MPI parallelization. In this as-
pect, it is similar to the existing popular frameworks such
as Spark [17, 36], Hadoop [7]. Moreover, using MPI as the
communication glue oﬀers portability and performance for
distributed DL optimizations across system and hardware
architectures. Finally, the tensor collectives applied to the
Minsky architecture are generic and can be readily applied
to other GPU based systems.

REFERENCES

[1] 2016. CORAL.

http://www.nextplatform.com/2016/04/04/

eyes-ibm-future-supercomputing-push. (2016).
[2] 2017. AWS. https://aws.amazon.com/. (2017).
[3] 2017.

Azure.

http://www.nvidia.com/object/

gpu-accelerated-microsoft-azure.html. (2017).

[4] 2017. CNTK. https://github.com/Microsoft/CNTK. (2017).
[5] 2017. CUDA. http://horacio9573.no-ip.org/cuda/index.html.

(2017).

[6] 2017. Google Cloud. https://cloud.google.com/gpu/. (2017).
[7] 2017. Hadoop. http://hadoop.apache.org/. (2017).
[8] 2017.

IBM Cloud. https://www.ibm.com/cloud-computing/.

(2017).

[9] 2017.

IBM Minsky.

https://www.hpcwire.com/2016/09/08/

ibm-debuts-power8-chip-nvlink-3-new-systems/. (2017).

[10] 2017. LSF. https://www.ibm.com/support/knowledgecenter/

SSETD49.1.3/lsfusersguide/chaplsfabout.html. (2017).

[11] 2017.

LSF restarting job.

https://www.ibm.com/support/
knowledgecenter/SSETD49.1.3/lsfadmin/jobrequeueautoconﬁg.
html. (2017).

[12] 2017.

mpi-caﬀe.

https://computing.ece.vt.edu/~steﬂee/

mpi-caﬀe.html. (2017).

[13] 2017. MPI Resize. https://www.arcos.inf.uc3m.es/wp-content/

uploads/sites/47/2017/02/wg3-E3.1-v1.0.pdf. (2017).

[14] 2017. MXNET. http://mxnet.io/. (2017).
[15] 2017. NCCL. https://github.com/NVIDIA/nccl. (2017).
[16] 2017. OpenMPI. https://www.open-mpi.org/. (2017).
[17] 2017. Spark. http://spark.apache.org/. (2017).
[18] 2017. ULFM. http://fault-tolerance.org/. (2017).
[19] Martín Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy
Davis, Jeﬀrey Dean, Matthieu Devin, Sanjay Ghemawat, Ge-
oﬀrey Irving, Michael Isard, and others. 2016. TensorFlow:
A system for large-scale machine learning.
arXiv preprint
arXiv:1605.08695 (2016).

[20] Ammar Ahmad Awan, Khaled Hamidouche, Jahanzeb Maqbool
Hashmi, and Dhabaleswar K. Panda. 2017. S-Caﬀe: Co-designing
MPI Runtimes and Caﬀe for Scalable Deep Learning on Mod-
ern GPU Clusters. In Proceedings of the 22Nd ACM SIGPLAN
Symposium on Principles and Practice of Parallel Program-
ming (PPoPP ’17). ACM, New York, NY, USA, 193–205. DOI:
https://doi.org/10.1145/3018743.3018769

[21] Yoshua Bengio. 2012. Practical recommendations for gradient-
based training of deep architectures. CoRR abs/1206.5533
(2012). http://arxiv.org/abs/1206.5533

[22] Wesley Bland, Aurelien Bouteiller, Thomas Hérault, Joshua
Hursey, George Bosilca, and Jack J. Dongarra. 2013. An eval-
uation of User-Level Failure Mitigation support in MPI. Com-
puting 95, 12 (2013), 1171–1184. DOI:https://doi.org/10.1007/
s00607-013-0331-3

[23] Wesley Bland, Huiwei Lu, Sangmin Seo, and Pavan Balaji. 2015.
Lessons Learned Implementing User-Level Failure Mitigation
in MPICH. In 15th IEEE/ACM International Symposium on
Cluster, Cloud and Grid Computing, CCGrid 2015, Shenzhen,
China, May 4-7, 2015. 1123–1126. DOI:https://doi.org/10.1109/
CCGrid.2015.51

[24] L. Bottou, F. E. Curtis, and J. Nocedal. 2016. Optimization
Methods for Large-Scale Machine Learning. ArXiv e-prints
(June 2016). arXiv:stat.ML/1606.04838

11

[25] Longbing Cao, Chengqi Zhang, Thorsten Joachims, Geoﬀrey I.
Webb, Dragos D. Margineantu, and Graham Williams (Eds.).
2015. Proceedings of the 21th ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining, Sydney,
NSW, Australia, August 10-13, 2015. ACM. http://dl.acm.org/
citation.cfm?id=2783258

[26] Tianqi Chen, Mu Li, Yutian Li, Min Lin, Naiyan Wang, Min-
jie Wang, Tianjun Xiao, Bing Xu, Chiyuan Zhang, and Zheng
Zhang. 2015. Mxnet: A ﬂexible and eﬃcient machine learning
library for heterogeneous distributed systems. arXiv preprint
arXiv:1512.01274 (2015).

[27] Trishul Chilimbi, Yutaka Suzue, Johnson Apacible, and Karthik
Project Adam: Building an Eﬃ-
Kalyanaraman. 2014.
cient and Scalable Deep Learning Training System. In 11th
USENIX Symposium on Operating Systems Design and
Implementation (OSDI 14). USENIX Association, Broom-
ﬁeld, CO, 571–582. https://www.usenix.org/conference/osdi14/
technical-sessions/presentation/chilimbi

[28] Adam Coates, Brody Huval, Tao Wang, David J. Wu, Andrew Y.
Ng, and Bryan Catanzaro. 2013. Deep Learning with COTS
HPC Systems. In Proceedings of the 30th International Con-
ference on International Conference on Machine Learning -
Volume 28 (ICML’13). JMLR.org, III–1337–III–1345. http://dl.
acm.org/citation.cfm?id=3042817.3043086

[29] Henggang Cui, Hao Zhang, Gregory R. Ganger, Phillip B. Gib-
bons, and Eric P. Xing. 2016. GeePS: Scalable Deep Learning on
Distributed GPUs with a GPU-specialized Parameter Server. In
Proceedings of the Eleventh European Conference on Computer
Systems (EuroSys ’16). ACM, New York, NY, USA, Article 4,
16 pages. DOI:https://doi.org/10.1145/2901318.2901323

[30] Dipankar Das, Sasikanth Avancha, Dheevatsa Mudigere,
Karthikeyan Vaidyanathan, Srinivas Sridharan, Dhiraj D.
Kalamkar, Bharat Kaul, and Pradeep Dubey. 2016. Distributed
Deep Learning Using Synchronous Stochastic Gradient Descent.
CoRR abs/1602.06709 (2016). http://arxiv.org/abs/1602.06709
[31] Jeﬀrey Dean, Greg S. Corrado, Rajat Monga, Kai Chen,
Matthieu Devin, Quoc V. Le, Mark Z. Mao, Marc’Aurelio Ran-
zato, Andrew Senior, Paul Tucker, Ke Yang, and Andrew Y. Ng.
2012. Large Scale Distributed Deep Networks. In Proceedings of
the 25th International Conference on Neural Information Pro-
cessing Systems (NIPS’12). Curran Associates Inc., USA, 1223–
1231. http://dl.acm.org/citation.cfm?id=2999134.2999271
[32] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.
2015. Deep Residual Learning for Image Recognition. CoRR
abs/1512.03385 (2015). http://arxiv.org/abs/1512.03385

[33] Forrest N. Iandola, Khalid Ashraf, Matthew W. Moskewicz,
and Kurt Keutzer. 2015. FireCaﬀe: near-linear acceleration
of deep neural network training on compute clusters. CoRR
http://dblp.uni-trier.de/db/journals/
abs/1511.00175 (2015).
corr/corr1511.html#IandolaAMK15

[34] Nikhil Jain and Yogish Sabharwal. 2010. Optimal Bucket Algo-
rithms for Large MPI Collectives on Torus Interconnects. In Pro-
ceedings of the 24th ACM International Conference on Super-
computing (ICS ’10). ACM, New York, NY, USA, 27–36. DOI:
https://doi.org/10.1145/1810085.1810093

[35] Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge Nocedal,
Mikhail Smelyanskiy, and Ping Tak Peter Tang. 2016. On Large-
Batch Training for Deep Learning: Generalization Gap and Sharp
Minima. CoRR abs/1609.04836 (2016). http://arxiv.org/abs/
1609.04836

[36] Hanjoo Kim, Jaehong Park, Jaehee Jang, and Sungroh Yoon.
2016. DeepSpark: Spark-Based Deep Learning Supporting Asyn-
arXiv preprint
chronous Updates and Caﬀe Compatibility.
arXiv:1602.08191 (2016).

[37] Ignacio Laguna, David F. Richards, Todd Gamblin, Martin
Schulz, and Bronis R. de Supinski. 2014. Evaluating User-Level
Fault Tolerance for MPI Applications. In Proceedings of the 21st
European MPI Users’ Group Meeting (EuroMPI/ASIA ’14).
ACM, New York, NY, USA, Article 57, 6 pages. DOI:https://
doi.org/10.1145/2642769.2642775

[38] Mu Li, David G Andersen, Alex J Smola, and Kai Yu. 2014.
Communication eﬃcient distributed machine learning with the
parameter server. In Advances in Neural Information Process-
ing Systems. 19–27.

[39] Xiangru Lian, Yijun Huang, Yuncheng Li, and Ji Liu. 2015. Asyn-
chronous parallel stochastic gradient for nonconvex optimization.

In Advances in Neural Information Processing Systems. 2737–
2745.

[40] H. Brendan McMahan, Eider Moore, Daniel Ramage, and
Blaise Aguera y Arcas. 2016. Communication-Eﬃcient Learn-
ing of Deep Networks from Decentralized Data. (2016). http://
arxiv.org/abs/1602.05629

[41] John D. Owens, Mike Houston, David Luebke, Simon Green,
John E. Stone, and James C. Phillips. 2008. GPU Computing.
Proc. IEEE 96, 5 (May 2008), 879–899.

[42] Xinghao Pan, Jianmin Chen, Rajat Monga, Samy Bengio, and
Rafal Józefowicz. 2017. Revisiting Distributed Synchronous SGD.
CoRR abs/1702.05800 (2017). http://arxiv.org/abs/1702.05800
[43] Pitch Patarasuk and Xin Yuan. 2009. Bandwidth optimal all-
reduce algorithms for clusters of workstations. J. Parallel Dis-
DOI:https://doi.org/10.
trib. Comput. 69, 2 (2009), 117–124.
1016/j.jpdc.2008.09.002

[44] Benjamin Recht, Christopher Re, Stephen Wright, and Feng Niu.
2011. Hogwild: A lock-free approach to parallelizing stochastic
gradient descent. In Advances in Neural Information Processing
Systems. 693–701.

[45] Minsoo Rhu, Natalia Gimelshein, Jason Clemons, Arslan Zul-
ﬁqar, and Stephen W. Keckler. 2016. Virtualizing Deep Neural
Networks for Memory-Eﬃcient Neural Network Design. CoRR
abs/1602.08124 (2016). http://arxiv.org/abs/1602.08124

[46] Sebastian Ruder. 2016. An overview of gradient descent opti-

mization algorithms. arXiv preprint arXiv:1609.04747 (2016).
[47] Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev
Satheesh, Sean Ma, Zhiheng Huang, Andrej Karpathy, Aditya
Khosla, Michael Bernstein, Alexander C. Berg, and Li Fei-Fei.
2015. ImageNet Large Scale Visual Recognition Challenge. In-
ternational Journal of Computer Vision (IJCV) 115, 3 (2015),
211–252. DOI:https://doi.org/10.1007/s11263-015-0816-y
[48] Sixin Zhang, Anna E Choromanska, and Yann LeCun. 2015.
Deep learning with elastic averaging SGD. In Advances in Neu-
ral Information Processing Systems. 685–693.

[49] Wei Zhang, Suyog Gupta, Xiangru Lian, and Ji Liu. 2015.
Staleness-aware Async-SGD for Distributed Deep Learning.
CoRR abs/1511.05950 (2015). http://arxiv.org/abs/1511.05950

12

