Efﬁcient Execution of Quantized Deep Learning
Models: A Compiler Approach

Animesh Jain1, Shoubhik Bhattacharya1, Masahiro Masuda2, Vin Sharma1, and Yida Wang1

1Amazon Web Services, 2Edgecortix Inc.

0
2
0
2

n
u
J

8
1

]

C
D
.
s
c
[

1
v
6
2
2
0
1
.
6
0
0
2
:
v
i
X
r
a

Abstract—A growing number of applications implement pre-
dictive functions using deep learning models, which require heavy
use of compute and memory. For deep learning workloads to
run well on a broad range of systems from cloud-scale clusters
to low-power edge devices, they need to use available compute
and memory resources more efﬁciently. One popular technique
for increasing resource efﬁciency is 8-bit integer quantization,
in which 32-bit ﬂoating point numbers (fp32) are represented
using shorter 8-bit integer numbers. Although deep learning
frameworks such as TensorFlow, TFLite, MXNet, and PyTorch
enable developers to quantize models with only a small drop in
accuracy, they are not well suited to execute quantized models
on a variety of hardware platforms. For example, TFLite is
optimized to run inference on ARM CPU edge devices but
it does not have efﬁcient support for Intel CPUs and Nvidia
GPUs. In this paper, we address the challenges of executing
quantized deep learning models on diverse hardware platforms
by proposing an augmented compiler approach. A deep learning
compiler such as Apache TVM can enable the efﬁcient execution
of model from various frameworks on various targets. Many deep
learning compilers today, however, are designed primarily for
fp32 computation and cannot optimize a pre-quantized INT8
model. To address this issue, we created a new dialect called
Quantized Neural Network (QNN) that extends the compiler’s
internal representation with a quantization context. With this
quantization context, the compiler can generate efﬁcient code
for pre-quantized models on various hardware platforms. As
implemented in Apache TVM, we observe that
the QNN-
augmented deep learning compiler achieves speedups of 2.35×,
2.15×, 1.35× and 1.40× on Intel Xeon Cascade Lake CPUs,
Nvidia Tesla T4 GPUs, ARM Cortex-A CPUs on Raspberry Pi3
and Pi4 respectively against well optimized fp32 execution. The
use of QNN with compilation of pre-quantized models enables
developers to achieve model execution performance comparable
to the state-of-the-art framework-speciﬁc solutions but on a wider
range of hardware platforms.

A. Background

I. INTRODUCTION

The effectiveness of deep learning in image processing
and natural language processing tasks has led to the devel-
opment of a growing number of applications that run deep
learning models on a wide range of systems, from cloud-
scale clusters to resource-limited edge-devices [1,2,3,4]. The
widespread use of deep learning frameworks such as Tensor-
ﬂow [5], PyTorch [6] and MXNet [7] drives the applications
of deep learning. These frameworks enable model developers
to quickly build, train, and deploy models on many hardware
platforms. The frameworks provide a set of operators, where
each operator represents a mathematical computation, e.g.,
convolution2D (referred to as conv2d), ReLU (rectiﬁed linear
unit), batch normalization etc. These operators are typically

converted to machine code using a hardware-speciﬁc library,
e.g., Intel DNNL [8] and Nvidia CuDNN [9].

In general, deep learning models require substantial com-
pute and memory resources [3,4], which can burden even
powerful servers leave alone low-power edge devices. Re-
searchers have implemented various techniques – algorithms,
software, hardware – to reduce the compute and memory
burden [4,10,11] of deep learning models to simplify their
development and deployment [12,13].

Among these techniques, quantization is a promising and
well-studied approach. Quantization represents ﬂoating point
32-bit (fp32) numbers, which are used frequently in the deep
learning models, with integer 8-bits (int8) [11,14,15], reduc-
ing the memory footprint by a factor of four. The most widely-
used form of integer quantization is uniform quantization [11],
where an fp32 tensor (Af p32) is represented with a quantized
int8 tensor (QA) along with quantization attributes - scale
(scaleA) and zero point (zpA) as shown below

Af p32 = scaleA ∗ (QA − zpA)

(1)

Quantization enables a model to consume fewer compute and
memory resources while keeping its accuracy close to that
of the unquantized model (where the inputs and parameters
are represented in fp32). We have observed that int8
quantization is most widely used in the real world because
(1) prior works have shown that int8 representation works
well empirically in preserving model accuracy [11,14,15]; (2)
popular hardware platforms like Intel CPUs, Nvidia GPUs, and
ARM CPUs are introducing low-level instructions support to
perform int8 data type computation efﬁciently.

As a result, deep learning frameworks have of late started to
implement uniform int8 quantization. Most of these efforts
have focused on retaining accuracy [11,14,15]. For example,
instead of scalar scale in Equation 1, we can use per-channel
scale to get more ﬁne-grained quantization [16]. Similarly,
we can use symmetric or asymmetric quantization based on
the value of zero points and choose a suitable performance-
accuracy trade-off [11].

However, there is very little focus on the broad deploy-
ment and efﬁcient execution of these framework-quantized
models (hereafter referred to as pre-quantized models) on a
variety of platforms (server and edge). This paper tackles the
challenges associated with model inference. Speciﬁcally, this
paper presents a universally applicable approach to execute
pre-quantized models from deep learning frameworks (e.g.

 
 
 
 
 
 
TFLite, MXNet, PyTorch) efﬁciently on a variety of hardware
platforms (e.g. Intel CPUs, Nvidia GPUs, ARM CPUs).

B. Quantization in Deep Learning Frameworks

Adding support for the execution of pre-quantized models
in each deep learning framework is not an efﬁcient use of
developer time. First, there are several popular frameworks
in widespread use, which means that the same effort must
be duplicated across multiple frameworks. Second, a model
is trained and quantized in a framework, it can only run
in the same framework on the hardware that the framework
supports; i.e. an MXNet model quantized on Intel CPUs cannot
run in TFLite on ARM CPUs. Third, a framework typically
handles quantization by adding new quantized operators, e.g.,
TFLite has quantized operators such as quantized conv2d,
quantized add. However, adding quantized operators to a
framework does not automatically enable the framework to
execute pre-quantized models efﬁciently. There are several
obstacles facing a framework.
• Lack of Kernel Library Support. Frameworks typically
rely on high-performance kernel libraries (e.g. Intel DNNL
and Nvidia CuDNN) to process computationally-intensive
operators. When a new operator is added to the framework,
libraries integrated with the framework must
the kernel
add corresponding support this new operator. Without that
support,
the quantized model either cannot run well or
cannot run at all.

• Per-operator Overhead. Operators in the framework are
tightly coupled. The best use of a new operator requires
corresponding rules and updates across the framework op-
timization toolchain. For example, one might want to fuse
quantized conv2d with a requantize operator.

• Diverse Hardware Platforms. Most critically, the hardware
platforms have varying levels of support for quantization.
Each platform often has speciﬁc requirements for these new
operators, e.g., Intel CPUs with x86 architecture prefer the
input data types of the quantized conv2d to be uint8 × int8
due to the Intel Vector Neural Network Instructions (VNNI)
requirement [17]. Similarly, CPUs in ARMv8 architecture
have special instructions to accelerate the int16 multiply-
accumulate, while ARMv8.2 CPUs introduce DOT instruc-
tion to directly speed up int8 multiply-accumulate [18].
These requirements percolate up to the framework opera-
tors, making it difﬁcult for a framework to support many
hardware platforms evenly.

In a nutshell, the quantization mechanism in deep learning
frameworks ensures the accuracy of quantized models but is
insufﬁcient to ensure their efﬁciency on a variety of hardware
platforms. The lack of a framework-agnostic toolchain capable
of executing pre-quantized models on a variety of hardware
platforms limits their deployment at scale.

C. Quantization in Deep Learning Compilers

The emergence of deep learning compilers (hereafter re-
ferred to as DL compilers) such as Apache TVM [19],
Facebook Glow [20] and Google XLA [21], has re-framed

the challenge of deploying deep learning models on vari-
ous hardware platforms. A DL compiler typically converts
a model expressed in a framework-speciﬁc representation
into a common intermediate representation (IR). The DL
compiler then successively lowers the graph from the graph-
level to the tensor-level. In the graph-level IR, the compiler
optimizes the computation graph of the model. In the tensor-
level IR, it optimizes the loop structure of tensor operators,
which represent the vertices of the computation graph. After
successive optimizations, the DL compiler eventually lowers
the model to the machine code of a hardware platform using
established low-level code generation modules such as LLVM
and NVCC. Therefore, compared to deep learning frameworks,
deep learning compilers are more effective at handling the
multiplicity of front-ends (frameworks) and back-ends (hard-
ware platforms), thereby simplifying the deployment of deep
learning models [19,22].

However, current work on DL compilers is based mostly
on the fp32 data type. Although some compilers support the
generation and optimization of quantized operators [20,23],
none have focused on compiling and executing pre-quantized
models. If a quantized operator is added naively to a deep
learning compiler, the new operator must be added across all
the IRs. In the graph-level, we need new rules for these new
operators. In the tensor-level, we need new computations and
possibly new kernel implementations for each platform. The
effort could be mitigated somewhat by the overlap between
fp32 and quantized operator kernel implementation. Never-
theless, the naive approach to adding quantized operators to the
compiler would severely limit the pace at which quantization
could be applied to deep learning models.

D. Quantized Neural Network Dialect

This paper proposes QNN (Quantized Neural Network) as
a graph-level IR dialect that can augment any deep learning
compiler. This approach offers an end-to-end solution to read
a pre-quantized model and run it across a variety of hardware
platforms while reusing most of the existing DL compiler
infrastructure. QNN dialect acts as a slightly higher-level IR
on top of graph-level IR, speciﬁcally designed for handling
quantized networks. We add new operators in QNN dialect,
but we do not deﬁne any graph- or tensor-level optimizations
for them. Instead, these operators are lowered to a sequence
of DL compiler’s existing operators, which already have well-
deﬁned graph- and tensor-level optimizations. QNN operators
represent quantization constructs at a higher level than the DL
compiler’s graph-level IR, making QNN a quantization-aware
IR.

QNN dialect,

therefore, enables reuse of almost all of
the existing infrastructure, allowing us to quickly add new
hardware platforms, and to focus on kernel implementation
of only those operators that are affected signiﬁcantly by the
integer operations (like using VNNI instructions for Intel x86).
Additionally, we can deﬁne new QNN dialect optimization
passes to transform the graph to suit a particular hardware
platform, e.g., adding a QNN requantize operator before QNN
conv2d to satisfy Intel VNNI uint8 x int8 data type

requirements. By reusing existing DL compiler infrastructure,
QNN dialect reduces the developer efforts needed to efﬁciently
execute pre-quantized models on many hardware platforms.
We implemented QNN dialect on top of the open-source deep
learning compiler Apache TVM1.

Speciﬁcally, the contributions of this paper are

• QNN Dialect. QNN dialect, a graph-level IR dialect de-
signed to complement deep learning compilers, enables the
efﬁcient execution of pre-quantized models on a variety of
hardware platforms without cumbersome manual efforts.
• Quantization-aware Graph Optimizations. We augment
QNN with quantization-aware graph level optimization
mechanisms, enabling the graph to meet the requirements
imposed by different instruction sets (like uint8 x int8 for
Intel VNNI).

• Comprehensive Real System Evaluation. We demonstrate
that using QNN along with the corresponding graph op-
timizations, we can compile pre-quantized models from
TFLite, MXNet and PyTorch on Intel CPUs, Nvidia GPUs
and ARM CPUs equipped on both servers and edge devices
and achieve state-of-the-art performance.
Experiments show that, with the assistance of QNN, a deep
learning compiler, speciﬁcally Apache TVM, is able to take
pre-quantized models deﬁned in TFLite, MXNet and PyTorch,
and execute them efﬁciently on different hardware platforms,
with an average speedup of 2.35×, 2.15× on Intel Xeon
Cascade Lake and Nvidia T4 servers, and 1.35× and 1.40× on
ARM Raspberry Pi3 and Pi4 edge devices, compared to tuned
TVM fp32 baseline. Generalizability aside, QNN achieves
performance comparable to the best state-of-the-art solutions
provided by the deep learning frameworks, while also provid-
ing better hardware platform coverage than the frameworks.
To the best of our knowledge, this is the ﬁrst uniﬁed effort
to enable DL compilers for a comprehensive quantized deep
learning models support. We have open sourced the QNN
work2, which is also used in production.

II. PROBLEM SETTING

A. Challenges

Quantization is an essential

technique for reducing the
compute and memory demand on hardware by replacing the
compute data type from fp32 to lower-bit integers such as
int8. There is an acute need for a software mechanism that
can enable developers to take advantage of quantization easily
and rapidly with as little developer effort as possible. However,
building such a mechanism requires that we overcome three
major challenges:
Multiple Frameworks. Developers build neural networks
in the framework with which they are most comfortable.
In practice today, developers in academia and industry use
a variety of frameworks to produce pre-quantized models.
Therefore, a good solution must be able to handle models
from multiple frameworks.

1https://tvm.apache.org/
2https://tvm.apache.org/docs/tutorials/frontend/deploy prequantized.html

Quantization Approaches
Asymmetric Quantization
Symmetric Quantization
Per-channel Quantization

TFLite MXNet
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)

Hardware Platforms
Nvidia GPU
Intel CPU
ARM CPU

TFLite MXNet

(cid:51)
(cid:51)

(cid:51)

PyTorch
(cid:51)
(cid:51)
(cid:51)

PyTorch

(cid:51)
(cid:51)

QNN
(cid:51)
(cid:51)
(cid:51)

QNN
(cid:51)
(cid:51)
(cid:51)

TABLE I: Frameworks have different degrees of support for
uniform int8 quantization. More importantly, they do not sup-
port all available hardware platforms with good performance.
Our solution is designed to eliminate the complexity and effort
of supporting all quantization approaches across a variety of
hardware platforms with good performance.

Multiple Quantization Approaches.
In Section I-A we
brieﬂy discussed various quantization approaches (e.g. sym-
metric, asymmetric, per-channel, etc.) that developers can
choose according to the needs of their application. A good
solution must be expressive enough to represent different types
of quantization approaches.
Multiple Hardware Platforms. Finally, a good solution must
be able to run pre-quantized models on a variety of devices
across a wide range of compute capabilities. Wherever avail-
able, the solution must provide the ability to use fast integer
instructions such as Intel VNNI or Nvidia DP4A instructions.
Currently, developers extend the functionality of deep learn-
ing frameworks to process quantized models. In Section I-B,
we argued that frameworks have tight coupling of operators
and back-end hardware libraries. This leads to operators that
are atomic, i.e., they are not decomposable, making it difﬁcult
to efﬁciently execute them on many platforms. We further
substantiate this in Table I showing that frameworks have ei-
ther limited quantization support or limited hardware support.
Therefore, existing deep learning frameworks do not present
a good solution to tackle all three challenges.

B. Observations

While the state-of-the-art framework-based approaches fail
to tackle the challenges of executing pre-quantized models
efﬁciently, the emerging crop of deep learning compilers is
promising. DL compilers typically have a framework-agnostic
graph-level intermediate representation (IR). We can convert
a model from any framework to this IR, solving the ﬁrst
challenge of framework multiplicity. We can also use different
types of quantization approaches in a DL compiler, which
addresses the second challenge. Finally, DL compilers rely on
established code generators like LLVM and NVCC to cover a
broad range of hardware platforms, solving the third challenge.
However, an ideal solution must address all these challenges
without burdening the developer with extra effort. Because
DL compilers were originally designed to compile models in
fp32 data type, they don’t support quantized operators and
the corresponding optimizations. As mentioned in Section I-C,
simply adding new quantized operators requires a lot of effort
across both graph- and tensor-level IRs. This again severely
limits how rapidly we can deploy quantized models on to
various hardware platforms.

In solving this problem, our key observation is that the
computation of a quantized operator can be easily represented
as a sequence of simpler operators (in contrast to frameworks
where the quantized operators are atomic and cannot be
decomposed). We illustrate this with an example of a quantized
conv2d operator below, in which ◦ denotes a convolution
computation.

Cf p32 = Af p32 ◦ Bf p32

= [scaleA ∗ (QA − zpA)] ◦ [scaleB ∗ (QB − zpB)]
= scaleA ∗ scaleB ∗ QC

(2)

In Equation 2, Af p32, Bf p32 are input tensors and Cf p32 is the
conv2d output tensor, all in fp32 data type. We ﬁrst replace
the fp32 tensors with quantized tensors using Equation 1
and then expand the computation. Further, we observe in
Equation 3 that quantized conv2d can be further broken down
into four terms. Here, k, c, r and s represent output channels,
input channels, ﬁlter height, and ﬁlter width respectively, and
n, h, w represent batch size, output height, and output width
respectively. We will show the exact sequence of operations
in Section III-B.

QC(n, k, h, w) =

−

−

+

(cid:88)

c,r,s
(cid:88)

c,r,s
(cid:88)

c,r,s
(cid:88)

c,r,s

QA(n, c, h + r, w + s) ∗ QB(k, c, r, s)

zpA ∗ QB(k, c, r, s)

zpB ∗ QA(n, c, h + r, w + s)

zpA ∗ zpB

(3)

We observe that all the quantized operators can be eas-
ily decomposed to simpler, existing operators. In contrast,
frameworks have a tight coupling between operators and back-
end libraries that prevents such decomposition. Although the
decomposition of quantized operators increases the size of the
computation graph initially, we can now reuse the graph- and
tensor-level optimizations that the DL compilers provide for
models in fp32 data type. For example, we can reuse the
graph fusion optimization pass to ﬁnd and fuse a sequence of
operators because we already have the fusion rules for existing
operators. Similarly at the tensor-level, we can reuse optimized
kernel implementations for many simple operators like integer
addition or multiplication, and rely on code generators like
LLVM/NVCC, signiﬁcantly reducing developer effort.

The little effort that developers do spend can be focused
on the operators that need attention due to the int8 data
type. For example, for Intel CPUs, a developer can focus on
writing graph-level optimizations to satisfy its uint8 × int8
data type requirement and write kernel implementations us-
ing Intel VNNI instructions for quantized conv2d operator.
Similarly, for ARMv8, one can focus only on graph- and

Fig. 1: Design of QNN with deep learning compiler - Devel-
oper adds new QNN operators with just the description of how
they can be lowered to existing graph-level (Relay) operators.
Framework parsers use QNN ops to convert the graph to
Relay/QNN graph. QNN infrastructure then runs a series of
quantization-aware graph-level optimizations, ﬁnally produces
Relay-only graph (no QNN operators). These operators are
then lowered to the machine code using the TVM schedules
for different hardware platforms.

tensor-level optimizations to use the fast int16 multiply-
accumulate instructions. The rest of the graph- and tensor-level
optimizations can be left to the DL compiler infrastructure.

Based on these observations, our solution is the Quan-
tized Neural Networks (QNN), a graph-level dialect with
quantization context that simpliﬁes the efﬁcient execution of
pre-quantized models on a variety of hardware platforms as
shown in Table I. The QNN dialect enables developers to
deﬁne a quantized operator simply as a sequence of existing
DL compiler operators. Additionally,
it allows graph-level
optimizations with quantization context to help satisfy the data
type requirements imposed by the instruction sets. Therefore,
augmented by QNN, DL compilers can make use of quanti-
zation across multiple hardware platforms.

III. DESIGN AND IMPLEMENTATION
In this section, we ﬁrst give an overview of QNN dialect
and how it ﬁts in the existing DL compiler infrastructure,
followed by the design and implementation of different QNN
dialect components. We build QNN dialect on top of Apache
TVM [19] - an open source deep learning compiler. We
will use the TVM terminology to describe the design details
with necessary explanation. TVM stack has two levels of IR
- a graph-level IR called Relay [24] and a tensor-level IR
(hereinafter referred to as tensor IR). QNN dialect is based
on the Relay IR, allowing developers to reuse a large portion
of existing TVM infrastructure.

An overview of the complete design is shown in Figure 1.
A developer ﬁrst adds a new QNN operator along with the
description of how this operator can be lowered to a sequence
of existing Relay (or graph-level) operators. Typically, QNN
operators correspond to quantized operators deﬁned in the

Framework Pre-quantized GraphMXNet ParserTFLiteParserQNN GraphQNN passesRelay passesTarget-optimized Int8 Relay GraphIntel x86scheduleARM CPUscheduleNvidia GPUschedule… platform schedulesRelay Integer GraphPyTorchParserQNN opsParsers use QNN opsdeep learning framework. A framework parser parses the
framework model
to produce a framework-agnostic graph
which is the mix of QNN and Relay operators. Since QNN is
a Relay dialect, QNN and Relay operators can co-exist in the
same graph.

This is followed by QNN graph-level optimizations. We
implement two QNN passes - QNN Legalize and QNN Canon-
icalize. QNN optimization passes, just like any graph-level
optimization passes, allow graph transformation. However, the
key difference is that QNN dialect is a quantization-aware IR,
i.e. QNN operators have quantization scales, zero points and
data type, which is not the case with later Relay passes. The
quantization context is helpful to perform hardware-speciﬁc
transformation (also known as legalization) in QNN Legalize,
for example, to satisfy the data type requirements imposed
the second QNN pass - QNN
by instruction set. Further,
Canonicalize pass - converts QNN operators into a sequence
of Relay-only operators using a developer-provided sequence.
Therefore, QNN Canonicalize pass acts as a boundary after
which graph-level quantization context is absent.

From here on, we can reuse the existing TVM infrastructure.
We ﬁrst run Relay optimizations, for example, dead code
elimination and graph fusion. After Relay optimizations, each
fused operator is then lowered to tensor IR, where it goes
through another set of tensor-level optimization passes. Here,
a developer can focus on only those operators that require extra
attention due to int8 data type and customize the kernel im-
plementation for each platform. Finally, the optimized tensor
IR is compiled to machine code using off-the-shelf compilers
like LLVM/NVCC.

QNN is designed to reduce the developer effort by reusing
a large portions of existing DL compiler infrastructure and
quickly shifting the developer focus to only those items that
are signiﬁcantly affected by int8 data type. Figure 1 color
codes the new efforts required to augment a DL compiler with
QNN using black boxes - QNN operators, framework parser,
QNN optimization passes and integer operator schedules.

A. QNN Operators and Framework Parsers

QNN operators act as wrappers, i.e., a developer simply
deﬁnes how a QNN operator can be represented as a sequence
of existing Relay operators. As a result, a developer does
not have to add any loop-level tensor IR description of any
new QNN operator. This developer provided sequence is used
by the QNN Canonicalize pass to convert QNN operators to
sequences of Relay-only operators.

In order to narrow down the set of QNN operators to
support, we ﬁrst collected quantized operators from the most
widely used frameworks - TFLite, MXNet and PyTorch. We
observed that the same operator name can mean different
computation manners for different frameworks. For example,
TFLite quantized conv2d operator performs int8 convolu-
tion, requantization of output tensor, ReLU and bias addition
in a single operator. The quantized conv2d operator of MXNet
goes one step further in aggressive fusion, fusing residual
addition operations and folding batch normalization.

Fig. 2: Example of TFLite quantized conv2d operator parsing -
TFLite con2d has multiple operators fused internally. We parse
it to a sequence of QNN and existing Relay operators - QNN
conv2d followed by Relay bias add. Then the tensor values are
clipped by pre-deﬁned output minimum and maximum values.
Finally, we call the QNN requantize operator to go back to
int8 datatype.

To address this computation boundary mismatch, we came
up with suitable QNN operators to express different compu-
tations for all the mainstream frameworks and all their quan-
tized operators. When necessary, we created ﬁner-grain QNN
operators. Essentially, one framework quantized operator can
map to a sequence of one or many QNN/Relay operators. We
illustrate this idea with the help of an example of conversion
of TFLite quantized conv2d operator in Figure 2.

We use a sequence of QNN conv2d, Relay bias add, Relay
clip and QNN requantize operator to parse the TFLite quan-
tized conv2d operator. We deﬁne QNN conv2d computation
such that it only handles the quantized tensors and adjustments
for zero points as shown in Equation 3. For scale handling,
we created another QNN operator called requantize, which is
extensively used in quantized models to convert one quantized
tensor with some scale and zero point to another quantized
tensor with another scale and zero point (more details in
Section III-B).

A developer, in a similar manner, can follow the computa-
tion of a quantized framework operator and can represent it
as a sequence of Relay operators with low effort. We added
support for different types of quantization approaches in this
manner. After the infrastructure was in place, we found that
implementing weight per-channel quantization took less than a
week of developer effort with QNN dialect requiring no extra
work in tensor IR.

B. QNN Canonicalization Pass

Figure 1 shows how TVM stack iteratively optimizes the
QNN graph after framework parsing is complete. There are
two QNN optimization passes - QNN Canonicalize and QNN
Legalize. Note that a developer can add more QNN opti-
mization passes if necessary. In this paper, we discuss above
two passes which we found sufﬁcient to support a variety

TFLitequantized conv2dQNN conv2dQBiasQAzpAQBzpBscaleout= scaleCzpout= zpCInputs to TFLitequantized conv2d•Data tensor –QA, zpA, scaleA•Weight tensor –QA, zpA, scaleA•Output params–zpC, scaleC•Bias tensor -QBias•Activation min/max•out_act_min•out_act_maxOutput tensor -QCRelay bias_addRelay clipout_act_minout_act_maxQNN Requantizezpin= 0Output tensor -QCscalein= scaleA* scaleBof hardware platforms. In this subsection, we discuss QNN
Canonicalize. We will discuss QNN Legalize in the next
section.

QNN Canonicalize pass converts QNN ops into a sequence
of Relay operators using the lowering sequence deﬁned by the
developer. Therefore, QNN Canonicalize pass acts as a bound-
ary after which graph-level quantization context is absent,
and we reuse existing Relay and tensor-level infrastructure.
QNN provides infrastructure where a developer can specify the
lowering of a QNN operator to a sequence of Relay operators.
This has to be done on an operator-by-operator basis. The
difﬁculty of lowering varies between operators. Here, we show
examples of canonicalizing three operators - QNN pooling,
QNN conv2d and QNN requantize. The operators are chosen
to give a ﬂavor of complexity and share low-level observations
and insights about operator designs.
QNN Pooling Operator - QNN pooling operator canonical-
ization requires simple lowering. All the framework quantized
pooling operators have the same scale and zero point for
pooling input and output tensors. This simpliﬁes lowering for
quantized pooling as shown below:

Bf p32 = AvgP ool(Af p32)
scale ∗ (QB − zp) = scale ∗ AvgP ool(QA − zp)
QB = AvgP ool(QA)

(4)

We can skip scale and zero point handling (as they are equal)
and just perform average pooling operation. In the pooling op-
eration, we have to be careful about rounding during division
and upcast the inputs to int16 to avoid overﬂow/underﬂow
while accumulation.
QNN Convolution Operator - As mentioned in Section III-A,
we only handle convolution of quantized tensors and ad-
justments due to zero points (no scale handling) in QNN
conv2d operator. As shown earlier in Equation 3, QNN conv2d
operator can be decomposed into four terms. Each term can
be represented using Relay operators. Term 1 is simply Relay
conv2d over quantized int8 input
tensors. Term 2 can be
lowered by performing a reduce sum operation on weight
tensor across c, r, s dimension. Term 3 performs a sliding
window reduction on input data quantized tensor, which can be
represented by pool2d, reduce sum and multiplication operator.
And term 4 is just a multiplication of constants.

We have to be careful about zero points because fp32
number 0.0 is represented by zero point in the quantized ten-
sor (which can also be inferred from Equation 1). Therefore,
padding a quantized input tensor in QNN conv2d translates
to padding the tensor with zero point. We also have to take
care of reshapes to match tensor shapes or allow broadcasting
whenever possible. We further observe that term 2 and term 4
are compile-time constants - term 2 is dependent on the weight
tensor, which is constant for DNN inference. Speciﬁcally, the
ﬁnal QNN-to-Relay canonicalization is shown in Figure 3.

An alternative lowering can be similar to QNN pooling,
where we ﬁrst subtract zero points and then perform conv2d
over subtracted tensors as shown in Equation 2. However,
in this case the tensors have to be upcast to int16 before

Fig. 3: QNN Conv2D canonicalization - QNN Conv2d is low-
ered across the four terms as described in Equation 3. Reshape
and cast operators are added to ensure that tensor shapes and
data type match while combining the terms. Compile-time
constant terms - Term 2 and Term 4 - are subtracted ﬁrst to
perform constant folding.

subtracting zero points, causing the ﬁnal convolution to happen
on int16 tensors instead of int8 tensors. For devices that
have fast int8 datatype computation support, like Intel VNNI
and Nvidia DP4A, this prevents us from using the relevant
int8 instructions. However for ARMv8 that has a fast int16
multiply-accumulate instruction,
this lowering gives better
performance. QNN Legalize pass, described later, allows this
customization for different hardware platforms.
QNN Requantize Operator - QNN conv2d operator is
typically followed by a requantize operator (also shown in
Figure 2). Requantize operator changes one quantized tensor
representation to another, i.e, we represent the input quantized
tensor with new scale and zero point. This can be mathemat-
ically written as follows, where QA and QB are input and
output quantized tensors respectively.

scaleB ∗ (QB − zpB) = scaleA ∗ (QA − zpa)
QB = [(scaleA/scaleB) ∗ (QA − zpa)] + zpB

(5)

Note that scales here are of fp32 data type, leading to a
ﬂoating point multiplication of requantize scale and quantized
tensor, which later will have to be converted back to integer
data type. This back-and-forth data type conversion can cause
severe performance degradation. To solve this problem, we
borrow the idea from TFLite requantize operation [11] to
use a ﬁxed point multiplication as a proxy for ﬂoating point
multiplication. An important detail in the implementation is
the rounding of ﬁxed point multiplication. Different frame-
works choose different rounding methods, which results in
minor end-to-end model accuracy differences as shown in the
evaluation later.

C. QNN Legalize Pass

QNN optimization passes,

like Relay passes, allow
graph transformations. However, the key difference is that
QNN passes have quantization context, e.g., QNN conv2d
operators have scale and zero points for the input tensors. The

just

conv2dQBQAzpACast(“int32”)Sum(axis=[1,2,3])ReshapeMultiplyCast(“int32”)multiplyAvg_pool2dSum(axis=[1])MultiplyMultiplyQBzpBQAzpAzpACRSTerm 1Term 2Term 3Term 4Term 2Term 4SubtractTerm 1Term 3SubtractAddQNN conv2d outputquantization context is helpful to perform hardware-speciﬁc
graph-IR transformations to satisfy the data type restrictions
imposed by the hardware instruction set. We call this pass
QNN Legalize pass. Legalization is a common compilation
pass that transforms an IR for a speciﬁc platform to use the
instructions natively supported by the platform. QNN Legalize
pass allows developers to easily perform these quantization-
aware platform-speciﬁc graph optimizations. Its backbone is
built on existing Relay infrastructure that allows customization
of graph optimization for hardware platforms.

For example, TFLite pre-quantized graphs have uint8 ×
uint8 inputs for the quantized conv2d operator. However,
Intel VNNI instructions-based platforms impose uint8 × int8
data type requirement. QNN Legalize pass bridges this gap
in a developer-friendly manner by allowing one to insert a
requantize operator before the second operand of conv2d,
converting the data type from uint8 to int8. For ARMv8-
based devices, on the other hand, we observe that LLVM
performs better code generation if the input tensors are of
int16 datattype instead of int8 datatype, and utilizes fast
int16 multiply-accumulate instruction (vmlal). Therefore,
QNN Legalize performs a graph transformation to insert data
type upcasting before both operands of the QNN conv2d
operator, changing the QNN conv2d input data type to int16.

D. TVM Schedules for Integer Operators

As shown in Figure 1, after Relay optimization passes have
been applied, each fused operator is then lowered to machine
code via TVM tensor IR. For many simple operators, like
addition or ReLU, that do not have any data reuse, there is not
much room for further optimization in addition to relying on
off-the-shelf code generators like LLVM/NVCC to get perfor-
mant machine code. However, operators like conv2d or matmul
(matrix multiplication) require speciﬁc tensor IR optimizations
(also known as a compute and schedule implementation in
the context of TVM) to efﬁciently exploit data reuse. This
optimization effort needs to be done for every platform due to
drastic architectural differences.

QNN infrastructure quickly shifts the developer focus to
only those operators that need extra attention due to integer
computations. For example, we can reuse existing TVM sched-
ules for integer pooling, vector addition, ReLU etc. This is
in contrast to frameworks, where a new quantized operator
(which handles scale and zero points internally) need to be im-
plemented separately. For the operators signiﬁcantly affected
by the integer computation, we can write speciﬁc schedules
for them to utilize the fast integer instructions provide by
the hardware to get desirable performance. We present our
observations regarding the usage of these instructions across
both server and edge devices.
Intel VNNI - TVM relies on off-the-shelf code generators
to generate good quality code. However in some cases, it
might be difﬁcult for LLVM to use the right instructions
automatically. For example, Intel VNNI instruction performs
a vector dot-product of 4 int8 values and accumulate them
into int32, potentially achieve 4× speedup over fp32
computation. However, by now LLVM is still unable to detect

this macro pattern from LLVM IR to replace with proper Intel
VNNI instructions. Therefore, in this case a developer can
directly embed the LLVM intrinsics in the TVM tensor IR. We
used this feature to write high performance TVM schedules
for integer convolution operators for Intel CPUs.
ARM Edge Devices - In contrast to Intel VNNI, the Rasp-
berry Pi edge devices, based on ARMv8 architecture, do not
have hardware support for fast int8 dot product instruction.
However, ARMv8 ISA has a fast int16 multiply-accumulate
instruction (vmlal) that can perform dot product of 2 16-bit
values and accumulate in 32-bit. We observe that LLVM picks
up the vmlal instructions for code generation if the input
tensors are of int16 datatype instead of int8. Therefore,
we use QNN Legalize pass to insert the up-casting operations
before the QNN conv2d operators for ARMv8-based devices.
Nvidia GPUs - Similar to Intel VNNI, Nvidia has a DP4A
instruction to speedup 8-bit integer computation. Recently,
Nvidia has also introduced tensor cores to achieve even further
speedup. In this work, we leverage the already existing Nvidia
DP4A TVM schedule. Note that given TVM abstractions, in
future, a developer can just focus on the TVM schedule for
convolution using Tensor Cores, and easily replace the DP4A
schedule with the new schedule. Writing TVM schedule using
Tensor Core is beyond the scope of this paper.

Overall, QNN is designed to augment DL compilers, in our
case, Apache TVM, to deploy pre-quantized models efﬁciently
across many hardware devices with low developer effort. In
cases where we need extra attention due to speciﬁc integer
instructions, QNN can still reduce a signiﬁcant portion of
developer’s time and effort by reusing the existing TVM
infrastructure.

IV. EVALUATION

This section evaluates our proposed QNN solution by an-

swering the following questions:
1) As a sanity check, is QNN able to compile pre-quantized
models to achieve similar model accuracy numbers com-
pared to the framework solutions?

2) What is the performance of QNN-compiled pre-quantized
models, in comparison to the original models in fp32?
3) Can QNN get the on-par, if not better, performance on
pre-quantized models compared to the framework solutions
while covering more hardware platforms than frameworks?
4) How does QNN perform in compiling a newly designed

pre-quantized model?

A. Experimental Setup

Frameworks. We evaluate QNN across all the available pre-
quantized models in TFLite (version 1.13) [25], MXNet (ver-
sion 1.6) [26] and PyTorch (version 1.4) [27]. We implement
QNN on top of open-source Apache TVM (version 0.6) [19].
Note that different frameworks support different sets of pre-
quantized models as listed in Table I, while QNN-augmented
TVM is able to compile all of them.
Server Platforms. We evaluate QNN on two server platforms
on Amazon EC2 - Intel 24-core Xeon Cascade Lake CPU
equipped at EC2 C5.12xlarge instance and Nvidia T4 GPU

Top5 Accuracy (%)

QNN-TVM Baseline

Quantized Model

resnet-18
resnet-50
resnet-50-v1b
resnet-101
resnet-152
inception-v3
inception-bn
mobilenet-v1
mobilenet-v2

inception-v1
inception-v2
inception-v3
inception-v4
mobilenet-v1
mobilenet-v2

resnet-18
resnet-50
inception-v3
googlenet
mobilenet-v2

89.02
92.6
92.6
93.06
92.52
93.52
90.38
90.09
89.45

Top1 Accuracy (%)
Baseline
MXNet Pre-quantized Models
69.86
69.76
76.16
76.13
76.56
76.66
76.97
77.13
75.75
75.99
77.28
77.84
71.79
71.96
71.13
71.27
70.35
70.14
TFLite Pre-quantized Models
69.6
70.1
73.3
73.5
77.3
77.5
79.6
79.5
70.1
70.0
70.8
70.9
PyTorch Pre-quantized Models
69.63
69.49
75.84
75.88
77.28
77.65
69.37
69.59
70.61
70.43

89.8
91.4
93.7
93.90
89.0
89.9

88.67
92.64
93.36
89.34
89.48

QNN-TVM

89.05
92.73
92.6
93.09
92.12
93.32
90.25
90.16
89.52

89.5
91.3
93.6
94.2
89.0
90.1

88.47
92.67
93.18
89.28
89.44

Fig. 4: QNN on Server - QNN takes advantage of fast int8
instructions to achieve signiﬁcant speedup against TVM fp32
tuned baseline for both Intel Cascade lake and Nvidia T4
servers.

TABLE II: QNN achieves accuracy parity across all
the
mainstream frameworks – MXNet, TFLite and PyTorch – pre-
quantized models.

at EC2 G4.xlarge instance. Both processors have hardware
support for speeding up int8 computations - Intel VNNI
and Nvidia DP4A instructions. The Nvidia T4 GPU also has
recently introduced Tensor Cores. However, for this evaluation
we only use DP4A instructions. Using Tensor Cores is an
orthogonal effort to this paper (refer to Section III-D).
Edge Devices. We evaluate QNN on two popular edge devices
- Raspberry Pi3 (in-order ARM Cortex A53) and Raspberry
Pi4 (out-of-order ARM Cortex A72). In contrast to our server
platforms, Raspberry Pi devices do not have any fast int8
computation instructions. Instead, they have 16-bit multiply-
accumulate instructions (vmlal) that
leads to better data
packing in registers.

B. Deploying QNN across Frameworks

First of all, we evaluate the effectiveness of QNN in achiev-
ing a wide framework coverage. Since each framework has
its own preferred choice of quantization approach (asymmet-
ric, symmetric, per-channel), we simultaneously evaluate the
ability of QNN to represent different quantization approaches.
Speciﬁcally, we compare the accuracy of pre-quantized models
achieved by the frameworks and QNN-augmented TVM stack.
We measure the accuracy over 10k images from the Imagenet
validation dataset [28] and show the ﬁndings in Table II.

We observe that QNN achieves accuracy parity for all
pre-quantized models across the frameworks with minor dif-
ferences. As explained in Section III-B,
these differences
mainly attribute to the rounding operations in ﬁxed point
multiplication of the requantize operator. Different frameworks
use different rounding methods, leading to small differences
in ﬁnal accuracy.

Fig. 5: QNN at edge - QNN enables easy deployment across
the edge devices as well. We see performance speedup for
both in-order (A53) and out-of-order (A72) ARM cores. The
red cross shows that fp32 resnet-152 model execution was
out of memory, while QNN int8 execution succeeded.

C. Deploying QNN Across Server and Edge Devices

QNN is designed to enable efﬁcient deployment of pre-
quantized models across a variety of hardware platforms with
different types of computing capabilities. In this subsection,
we evaluate QNN effectiveness in performance speedup and
memory footprint reduction, when it is deployed across our
server and edge devices.
Performance Improvements. In this experiment, we compile
the original MXNet models (in fp32) and their counterpart
pre-quantized model (in int8) using QNN-augmented TVM
stack. We execute each compiled model for 2000 images
(batch size 1) and measure the average end-to-end latency.
We also perform auto-tuning [29] to ensure high performance
for both original and pre-quantized models.

We compare the performance of TVM-compiled original
models (referred to as TVM-fp32) and QNN-augmented
TVM-compiled MXNet pre-quantized models (referred to as
QNN-int8). There are two reasons for choosing this baseline.
First, no framework can run across all
the platforms we
are targeting, making TVM-fp32 a good baseline. Second,
MXNet has the largest number of available pre-quantized
models amongst all the frameworks, enabling wider model
coverage evaluation. The same observation applies to pre-
quantized models of TFLite and PyTorch. We present the
results for server-class platforms and edge-devices in Figure
4 and Figure 5 respectively. We observe very low standard
deviation amongst 2000 runs, and therefore omit the error bars
in the barplots.

resnet−18resnet−50resnet−50_v1bresnet−101resnet−152inception−v3inception−bnmobilenet−v1mobilenet−v2Geomeanresnet−18resnet−50resnet−50_v1bresnet−101resnet−152inception−v3inception−bnmobilenet−v1mobilenet−v2Geomean0.5 x1 x1.5 x2 x2.5 x3 x3.5 x4 xSpeedup against TVM−FP32Intel Cascade LakeNvidia T4 GPUresnet−18resnet−50resnet−50_v1bresnet−101resnet−152inception−v3inception−bnmobilenet−v1mobilenet−v2Geomeanresnet−18resnet−50resnet−50_v1bresnet−101resnet−152inception−v3inception−bnmobilenet−v1mobilenet−v2Geomean0.6 x0.8 x1 x1.2 x1.4 x1.6 x1.8 x2 x2.2 xSpeedup against TVM−FP32Raspberry Pi3Raspberry Pi4Fig. 6: Breakdown of runtime memory footprint across weights and intermediate feature maps. Intermediate feature also play a
considerable role in deciding the total memory footprint reduction. For Intel and Nvidia servers, QNN-int8 reduces the total
memory footprint by 67-74%. For ARM, we currently upcast weights to int16 to use ARM fast vmlal instruction, resulting
in 50% (or 2×) footprint reduction.

For servers, we observe signiﬁcant performance improve-
ments for both Intel Cascade Lake CPU and Nvidia T4 GPU
servers as shown in Figure 4. Both processors have support
for fast int8 dot-product operations - Intel VNNI and Nvidia
DP4A instructions. We also observe lower than expected
speedup for resnet-152 and mobilenet models. For resnet-152,
MXNet decided to keep the batch normalization operator in
fp32 to retain accuracy, causing frequent data type conver-
sions and hurting performance. For mobilenet models, TVM
stack currently lacks good depthwise convolution schedules
(kernel implementation) using fast int8 instructions. Overall,
we observe that QNN-int8 achieves an average speedup of
2.35× and 2.13× for Intel Cascade Lake CPU and Nvidia T4
GPU respectively compared to TVM-fp32.

Similarly for edge devices, we observe signiﬁcant speedups
as shown in Figure 5. In contrast to servers, our edge devices
do not have fast int8 instructions, leading to lower speedups
than observed in servers. However, these devices have fast
int16 multiply-accumulate instructions (vmlal). We observe
that LLVM generates highly vectorized and vector register-
packed code using vmlal
instructions, efﬁciently utilizing
convolution data reuse and achieving better performance than
fp32 models. Additionally, we observe that TVM-fp32
resnet-152 model goes out of memory due to large weight size
in Pi3 (shown by cross in the ﬁgure). QNN-int8 on the other
hand, due to smaller memory footprint, can execute the model.
Similar to servers, mobilenet models observe sub-optimal
performance due to the lack of good TVM schedules for
depthwise convolution operator. Overall, QNN-int8 achieves
an average speedup of 1.35× and 1.40× for ARM Raspberry
Pi3 and Pi4 respectively compared to TVM-fp32.

Note that, although mobilenet models show lower than
expected performance speedup, QNN allows developers to
just focus on implementing better TVM schedules for depth-
wise convolution operator, while reusing the existing TVM
infrastructure for both graph- and tensor-level optimizations,
enabling rapid deployment with less developer efforts.
Memory Footprint Reduction. In this experiment, we eval-
uate QNN effectiveness in reducing the runtime memory
footprint. We compare the total runtime memory footprint for
TVM-fp32 and QNN-int8 models for all the hosted MXNet

models across all hardware platforms. We present the ﬁndings
in Figure 6, showing QNN-int8 total memory footprint as a
percentage of total TVM-fp32 footprint. We also break down
total memory footprint into 2 categories - weights (also known
as parameters) and intermediate feature maps (also known as
activations or intermediate outputs). In contrast to prior works
that only show weight memory footprint reduction [11,14], we
analyze total memory footprint.

We observe that different models have different memory
footprint reduction depending on the contribution of interme-
diate feature maps to total memory footprint. As opposed to
weights that have been pre-quantized to int8 and achieve
close to 4× memory footprint reduction, the intermediate fea-
tures maps that can also be in int32 data type, observe less
than 4× memory reduction. For example, mobilenet models
have larger contribution of intermediate feature maps, overall
reducing the footprint to 33% (or 3× footprint reduction).

We also observe that in edge devices, weights of QNN-
int8 see only 50% memory footprint reduction (much less
than expected 75% or 4×). This is because we upcast
the weights to int16 to use ARM fast int16 multiply-
accumulate vmlal instruction. Note that this overhead is un-
avoidable. TVM stack runs a constant evaluation pass that con-
verts the int8 pre-quantized weights to int16 at compile-
time. If we disable constant evaluation optimization pass and
keep the weights in int8, the tensor with upcast weights in
int16 datatype will still be the part of total memory footprint,
still keeping the total memory footprint same. Therefore, we
measure total memory footprint to accurately assess the total
memory footprint reduction.

D. QNN Comparison with Frameworks

Next, we compare the performance between QNN and
frameworks of executing pre-quantized models. As shown in
Table I, frameworks do not have efﬁcient pre-quantized model
execution support for all hardware platforms. Therefore, we
execute all the hosted pre-quantized models for each frame-
work on the hardware platforms it supports, and compare the
performance with the same models compiled and executed by
QNN-augmented TVM. Therefore, this evaluation compares
our work against the best available baseline. We do not show

resnet−18resnet−50resnet−50_v1bresnet−101resnet−152inception−v3inception−bnmobilenet−v1mobilenet−v2resnet−18resnet−50resnet−50_v1bresnet−101resnet−152inception−v3inception−bnmobilenet−v1mobilenet−v2resnet−18resnet−50resnet−50_v1bresnet−101resnet−152inception−v3inception−bnmobilenet−v1mobilenet−v2resnet−18resnet−50resnet−50_v1bresnet−101resnet−152inception−v3inception−bnmobilenet−v1mobilenet−v20 %20 %40 %60 %80 %100 %Runtime memory footprintnormalized to TVM−FP32WeightsIntermediate feature mapsIntel Cascade LakeNvidia T4 GPURaspberry Pi3Raspberry Pi4Fig. 7: MXNet vs QNN - QNN achieves an average speedup
of 1.09× against highly hand-tuned Intel DNNL execution
of pre-quantized models. The red cross signiﬁes that MXNet
does not have good support of running pre-quantized models
on ARM and Nvidia devices.

Fig. 9: PyTorch vs QNN - QNN achieves 7.85× speedups
on Intel Cascade Lake against PyTorch-FBGEMM. PyTorch-
QNNPACK does not support multi-threading on Raspberry
Pi4. QNN is 20% slower on average for single thread and
2.95× faster for four threads execution.

given its scope, TFLite does not have good performance
on Intel CPUs and Nvidia GPUs. For example, we observe
that our solution is over 10× faster on Intel Cascade Lake
CPUs against TFLite execution for resnet-50 model. There-
fore, we do not show comparison of QNN-augmented TVM
with TFLite on Intel and Nvidia devices. In this experiment,
we measure the performance of QNN-augmented TVM and
TFLite execution for all TFLite pre-quantized models on
Raspberry Pi4.

The ﬁndings of this experiment are shown in Figure 8,
demonstrating as QNN-augmented TVM speedup against
TFLite performance. We observe that TFLite is faster than
QNN-augmented TVM for all cases. Overall, QNN-augmented
TVM is 14% (or 1.16×) slower than TFLite on average. This
is because of hand-tuned assembly implementations for int8
conv2d and depthwise operators in TFLite. With the help of
improving int8 ARM schedules which is out of scope of this
paper, we should be able to close this gap.
PyTorch Framework. PyTorch relies on hand-written assem-
bly implementations - FBGEMM [31] for Intel CPUs and on
QNNPACK [32] for ARM mobile devices - to achieve high
performance for pre-quantized models. PyTorch does not have
any support for executing pre-quantized models efﬁciently
on Nvidia GPUs. In this experiment, we measure end-to-
end performance of PyTorch and QNN-augmented TVM for
all hosted PyTorch pre-quantized models on Intel Cascade
Lake CPU and ARM Raspberry Pi4. The ﬁndings of this
experiment are shown in Figure 9, demonstrating speedup of
QNN-augmented TVM normalized to PyTorch performance.
We observe that QNN-augmented TVM achieves high
speedups across all the models against PyTorch-FBGEMM
execution on Intel Cascade lake servers, with up to 12.2×
for resnet-18 and an average of 7.85×. PyTorch community
could work on improving these numbers, but
in general,
it highlights the effectiveness of QNN-augmented TVM in
quickly achieving high performance.

We found that PyTorch does not use multiple threads
for QNNPACK on non-Android or iOS devices including
Raspberry Pi4. Therefore, we show comparison with TVM
single thread performance in addition to TVM four threads
performance. We observe that, similar to our ﬁndings with
TFLite, there is room of improvement for better ARM sched-

Fig. 8: TFLite vs QNN - Currently QNN is on average 15%
slower than TFLite for pre-quantized models on ARM devices
because of hand-written tuned assembly implementations for
operators. The red cross signiﬁes that TFLite does not have
good support of running pre-quantized models on Intel and
Nvidia devices.

comparison on GPU platforms, because TFLite and PyTorch
do not support pre-quantized model execution on GPUs, while
MXNet supports but with suboptimal performance [30].
MXNet Framework. MXNet framework presents the best
baseline for Intel CPUs because it relies on Intel DNNL that
has hand-written x86 assembly implementations. For example,
Intel DNNL uses Intel VNNI instructions to achieve high
performance for int8 data type convolution or matrix mul-
tiplication operators. The performance of executing quantized
models on Nvidia GPUs in MXNet framework is under-
optimized, and MXNet does not have a backend to generate
high performance ARM machine code. Therefore, we can not
compare QNN with MXNet on Nvidia and ARM platforms
but just focus on Intel CPUs.

Figure 7 summarizes the end-to-end performance com-
parison between MXNet and our solution. Overall, we ob-
serve QNN-int8 achieves 1.09× speedup against MXNet
on Intel Cascade Lake CPU, with a maximum of 1.43× for
inception-bn. We observe slowdown for resnet-50, and resnet-
50 v1b models. We suspect this is because Intel DNNL has
customized the optimization for resnet models due to their
popularity. However, for other less popular models, we observe
signiﬁcant speedup.
TFLite Framework. TFLite framework has been designed
to mainly focus on edge devices. TFLite uses hand-tuned
implementation for int8 operator on ARM devices. However,

resnet−18resnet−50resnet−50_v1bresnet−101resnet−152inception−v3inception−bnmobilenet−v1mobilenet−v2Geomeanmodelmodel0.6 x0.7 x0.8 x0.9 x1 x1.1 x1.2 x1.3 x1.4 x1.5 xSpeedup vs MXNet−MKLDNNIntel Cascade LakeNvidia T4ARM Pimodelmodelinception−v1inception−v2inception−v3inception−v4mobilenet−v1mobilenet−v2Geomean0.6 x0.7 x0.8 x0.9 x1 x1.1 x1.2 x1.3 x1.4 x1.5 xSpeedup vs TFLiteIntel CascadeNvidia T4ARM Raspberry Pi4resnet−18resnet−50inception−v3googlenetmobilenet−v2Geomeanmodel0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 xSpeedup vs PyTorchIntel Cascade LakeNvidiaIntel Cascade LakeT412.2resnet−18resnet−50inception−v3googlenetmobilenet−v2Geomean0 x0.5 x1 x1.5 x2 x2.5 x3 x3.5 x4 x4.5 x5 xARM Raspberry Pi41 thread4 threadsules overall. Overall, QNN is 20% slower in the single-thread
apples-to-apples comparison but 2.95× faster if all four cores
are used.

E. QNN Effectiveness on a New Model

Lastly, we present a scenario where we use QNN to compile
and execute a new unseen pre-quantized model. Our new
model is an in-house built keyword detection model, which
is executed on a resource-constrained edge device, to detect
speciﬁc keywords or triggers in human speech. Typically,
these models are executed very frequently on the device to
capture the keywords. Therefore, it is imperative to have both
low latency and resource utilization for this model so that
we can co-execute other applications on the same device
simultaneously.

To reduce the latency, we employed framework quantization
to quantize the model and then compiled the model for
ARM Cortex A53 (Raspberry Pi3) edge device using QNN-
augmented TVM (QNN-int8). For evaluation, our baseline
is the fp32 model compiled and executed via TVM (TVM-
fp32). We observe that, without any extra developer efforts,
QNN-int8 was 2.0× and 2.7× faster than TVM-fp32
for single-threaded and multi-threaded execution (4 threads),
while achieving 50% total runtime memory footprint reduction
and no accuracy loss. This shows that a QNN-augmented deep
learning compiler is effective in rapidly deploying new models
on new devices with low developer efforts.

V. RELATED WORK

8-bit Integer Quantization. 8-bit
integer quantization is
the most widely adopted quantization technique because of
prevalence of int8 data type computation support in the
commodity hardware platforms. 8-bit integer quantization has
also been shown to retain model accuracy with relatively less
efforts compared to more aggressive quantization. TFLite 8-
bit integer quantization, designed primarily for ARM-based
edge devices, was one of the ﬁrst large-scale effort and set the
industry standard for integer quantization [33]. There is a large
body of prior work to retain model accuracy for quantization,
which can be broken into two categories - Post-training
quantization and Quantization-aware training [11,34,35]. Post-
training quantization starts from an already trained fp32
model and uses calibration on a cross-validation dataset to
ﬁnd suitable quantization parameters [34,35]. Research has
shown that post-training quantization achieves good accuracy
for 8-bit quantization. More aggressive quantization requires
quantization-aware training. Our approach can leverage all of
these research to get a pre-quantized model, and eases its
deployment on many hardware platforms.
Deep Learning Frameworks. Deep learning frameworks, like
Tensorﬂow, PyTorch and MXNet, have been at the forefront
of deep learning revolution. These frameworks rely on pre-
built backend hardware libraries for high-performance ma-
chine code - Intel DNNL [36], Nvidia CuDNN [9] and ARM
ACL [37]. These backend libraries have hand-optimized kernel
implementations to achieve high performance on different
platforms. Most of these frameworks use int8 quantization to

support lightweight model inference on commodity hardware.
A user also has a choice of using symmetric, asymmetric
or per-channel quantization approaches to ﬁnd a suitable
performance-accuracy tradeoff. However, as shown in Table I,
frameworks are not well suited to deploy the models across
many hardware platforms. QNN dialect is designed to leverage
the extensive work done by the frameworks in quantizing the
models and retaining accuracy, and solve the challenges to ease
the deployment of pre-quantized models on many platforms
with low developer efforts.
Deep Learning Compilers. Deep learning compilers have
gained popularity in past few years to design a ﬂexible
approach for optimizing and deploying deep learning models.
Some of the DL compilers support optimization and code gen-
eration for multiple hardware platforms - Apache TVM [19],
there are
Glow [20] and XLA [21]. On the other hand,
compilers focusing on only one class of hardware platforms -
Intel nGraph [38], ARM NN [39] and Nvidia TensorRT [9,40].
There has also been recent efforts in improving the compiler
design for supporting deep learning hardware accelerators, for
example, in Apache TVM [19], Glow [20], PlaidML [41]
with stripe IR [42] and MLIR [43]. Quantization support in
deep learning compilers has picked up pace very recently and
therefore good support is limited to the compilers focusing on
a single class of hardware platform - nGraph, TensorRT and
ARM NN. This limitation prevents us from rapidly deploying
models on many platforms with single uniﬁed toolchain. Our
work on the QNN dialect is designed to complement the
existing DL compilers to solve this challenge. We observe
that QNN-augmented DL compiler compiles pre-quantized
models from multiple frameworks, supports different types
of quantization approaches and enables deployment on many
hardware platforms with low developer efforts.

VI. CONCLUSION

In this paper, we offer a universal solution to the challenge
of efﬁciently executing pre-quantized models from a variety
of frameworks across a variety of hardware platforms while
keeping developer effort low. We note that most deep learning
frameworks help developers quantize models but fall short
at supporting the efﬁcient execution of models on multiple
platforms. This is due to the tight coupling of framework
operators and back-end hardware libraries, which hinders the
use of quantization. We tackle the problem using the notion
of a deep learning compiler enhanced with a new graph-level
dialect called Quantized Neural Network (QNN). The QNN
dialect provides a quantization context that can augment any
existing deep learning compiler (e.g. Apache TVM, Glow,
XLA). QNN simpliﬁes the effort of efﬁciently executing pre-
quantized models on variety of hardware devices. We observe
that our QNN-augmented deep learning compiler achieves
speedups of 2.35×, 2.15×, 1.35× and 1.40× on Intel Xeon
Cascade Lake CPUs, Nvidia Tesla T4 GPUs, ARM Cortex-
A CPUs on Raspberry Pi3 and Pi4 respectively relative to
fp32 execution. QNN also achieves comparable performance
against the state-of-the-art framework’s solutions for executing

pre-quantized models while providing much better coverage of
hardware platforms.

REFERENCES

[1] J. Devlin, M. Chang, K. Lee, and K. Toutanova, “BERT: pre-training
of deep bidirectional transformers for language understanding,” CoRR,
vol. abs/1810.04805, 2018.

[2] K. He, X. Zhang, S. Ren, and J. Sun, “Deep residual learning for image

recognition,” CoRR, 2015.

[3] K. Hazelwood, S. Bird, D. Brooks, S. Chintala, U. Diril, D. Dzhulgakov,
M. Fawzy, B. Jia, Y. Jia, A. Kalro et al., “Applied machine learning
at facebook: A datacenter infrastructure perspective,” in 2018 IEEE
International Symposium on High Performance Computer Architecture
(HPCA), 2018.

[4] N. P. Jouppi, C. Young, N. Patil, D. Patterson, G. Agrawal, R. Bajwa,
S. Bates, S. Bhatia, N. Boden, A. Borchers et al., “In-datacenter
performance analysis of a tensor processing unit,” in Proceedings of
the 44th Annual International Symposium on Computer Architecture,
2017.

[5] M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S.
Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow,
A. Harp, G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur,
J. Levenberg, D. Man´e, R. Monga, S. Moore, D. Murray, C. Olah,
M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker,
V. Vanhoucke, V. Vasudevan, F. Vi´egas, O. Vinyals, P. Warden, M. Wat-
tenberg, M. Wicke, Y. Yu, and X. Zheng, “TensorFlow: Large-scale
machine learning on heterogeneous systems,” 2015.

[6] A. Paszke, S. Gross, F. Massa, A. Lerer, J. Bradbury, G. Chanan,
T. Killeen, Z. Lin, N. Gimelshein, L. Antiga, A. Desmaison, A. Kopf,
E. Yang, Z. DeVito, M. Raison, A. Tejani, S. Chilamkurthy, B. Steiner,
L. Fang, J. Bai, and S. Chintala, “Pytorch: An imperative style, high-
performance deep learning library,” in Advances in Neural Information
Processing Systems 32, 2019.

[7] T. Chen, M. Li, Y. Li, M. Lin, N. Wang, M. Wang, T. Xiao, B. Xu,
C. Zhang, and Z. Zhang, “Mxnet: A ﬂexible and efﬁcient machine
learning library for heterogeneous distributed systems,” CoRR, 2015.
[8] “Intel MKLDNN,” https://github.com/intel/mkl-dnn, accessed: 2020-02-

10.

[9] S. Chetlur, C. Woolley, P. Vandermersch, J. Cohen, J. Tran, B. Catanzaro,
and E. Shelhamer, “cudnn: Efﬁcient primitives for deep learning,” CoRR,
vol. abs/1410.0759, 2014.

[10] J. Hu, L. Shen, and G. Sun, “Squeeze-and-excitation networks,” in
Proceedings of the IEEE conference on computer vision and pattern
recognition, 2018.

[11] B. Jacob, S. Kligys, B. Chen, M. Zhu, M. Tang, A. G. Howard, H. Adam,
and D. Kalenichenko, “Quantization and training of neural networks for
efﬁcient integer-arithmetic-only inference,” CoRR, vol. abs/1712.05877,
2017.

[12] Z. Jiang, T. Chen, and M. Li, “Efﬁcient deep learning inference on edge
devices,” in Proceedings of ACM Conference on Systems and Machine
Learning (SysML18), 2018.

[13] L. Wang, Z. Chen, Y. Liu, Y. Wang, L. Zheng, M. Li, and Y. Wang,
“A uniﬁed optimization approach for cnn model inference on integrated
gpus,” in Proceedings of the 48th International Conference on Parallel
Processing, 2019, pp. 1–10.

[14] D. Lin, S. Talathi, and S. Annapureddy, “Fixed point quantization of
deep convolutional networks,” in International Conference on Machine
Learning, 2016, pp. 2849–2858.

[15] J. Wu, C. Leng, Y. Wang, Q. Hu, and J. Cheng, “Quantized convolutional
the IEEE
neural networks for mobile devices,” in Proceedings of
Conference on Computer Vision and Pattern Recognition, 2016, pp.
4820–4828.

[16] R. Krishnamoorthi, “Quantizing deep convolutional networks

for
inference: A whitepaper,” 2018. [Online]. Available: http:

efﬁcient
//arxiv.org/abs/1806.08342
VNNI

[17] “Intel

instruction,”

https://software.intel.com/en-us/ai/

deep-learning-boost, accessed: 2020-02-10.

DOTI

[18] “ARM

https://community.arm.com/

instruction,”
developer/tools-software/tools/b/tools-software-ides-blog/posts/
exploring-the-arm-dot-product-instructions, accessed: 2020-02-10.
[19] T. Chen, T. Moreau, Z. Jiang, L. Zheng, E. Yan, H. Shen, M. Cowan,
L. Wang, Y. Hu, L. Ceze, C. Guestrin, and A. Krishnamurthy, “TVM:
An automated end-to-end optimizing compiler for deep learning,” in
USENIX Symposium on Operating Systems Design and Implementation
(OSDI), 2018.

[20] N. Rotem, J. Fix, S. Abdulrasool, S. Deng, R. Dzhabarov, J. Hegeman,
R. Levenstein, B. Maher, N. Satish, J. Olesen, J. Park, A. Rakhov, and
M. Smelyanskiy, “Glow: Graph lowering compiler techniques for neural
networks,” CoRR, vol. abs/1805.00907, 2018.

[21] “XLA: Optimizing compiler

for machine learning,” https://www.

tensorﬂow.org/xla, accessed: 2020-02-10.

[22] Y. Liu, Y. Wang, R. Yu, M. Li, V. Sharma, and Y. Wang, “Optimizing
{CNN} model inference on cpus,” in 2019 {USENIX} Annual Technical
Conference ({USENIX}{ATC} 19), 2019, pp. 1025–1040.

[23] M. Cowan, T. Moreau, T. Chen, J. Bornholt, and L. Ceze, “Automatic
generation of high-performance quantized machine learning kernels,” in
Proceedings of the 18th ACM/IEEE International Symposium on Code
Generation and Optimization, 2020, pp. 305–316.

[24] J. Roesch, S. Lyubomirsky, M. Kirisame, J. Pollock, L. Weber, Z. Jiang,
T. Chen, T. Moreau, and Z. Tatlock, “Relay: A high-level compiler for
deep learning,” arXiv preprint arXiv:1904.08368, 2019.

[25] “TFLite hosted pre-quantized models.” [Online]. Available: https:

//www.tensorﬂow.org/lite/guide/hosted{ }models

[26] “MXNet pre-quantized models.” [Online]. Available: https://github.com/

apache/incubator-mxnet/tree/master/example/quantization

[27] “PyTorch pre-quantized models.” [Online]. Available: https://github.

com/pytorch/vision/tree/master/references/classiﬁcation

[28] J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei, “Imagenet:
A large-scale hierarchical image database,” in 2009 IEEE conference on
computer vision and pattern recognition.

Ieee, 2009, pp. 248–255.

[29] T. Chen, L. Zheng, E. Q. Yan, Z. Jiang, T. Moreau, L. Ceze, C. Guestrin,
and A. Krishnamurthy, “Learning to optimize tensor programs,” CoRR,
2018. [Online]. Available: http://arxiv.org/abs/1805.08166

[30] “Model quantization with calibration.” [Online]. Available: https:

//github.com/apache/incubator-mxnet/pull/9552

[31] B. Protonu and D. Summer, “Open-sourcing fbgemm for state-of-the-art
server-side inference.” [Online]. Available: https://engineering.fb.com/
ml-applications/fbgemm/
[32] W. Y. Dukhan Marat

“Qnnpack: Open source
and L. Hao,
library for optimized mobile deep learning.” [Online]. Available:
https://engineering.fb.com/ml-applications/qnnpack/

[33] B. Jacob, S. Kligys, B. Chen, M. Zhu, M. Tang, A. Howard, H. Adam,
and D. Kalenichenko, “Quantization and training of neural networks for
efﬁcient integer-arithmetic-only inference,” in The IEEE Conference on
Computer Vision and Pattern Recognition (CVPR), June 2018.
v1.2.0
for

[34] “Apache*
math
tel
apache-mxnet-v120-released-with-intel-optimized-cpu-backend.

intel
(in-
https://software.intel.com/en-us/articles/

optimized
neural

with
networks

mkl-dnn),”

mxnet*

library

kernel

deep

[35] “Low
able:
2019/presentation/s9659-inference-at-reduced-precision-on-gpus.pdf

precision
Avail-
https://developer.download.nvidia.com/video/gputechconf/gtc/

inference

[Online].

gpus.”

on

[36] “Deep neural network library (dnnl).” [Online]. Available: https:

//github.com/intel/mkl-dnn
library.”

[37] “ARM compute

[Online]. Available: https://github.com/

ARM-software/ComputeLibrary

[38] S. Cyphers, A. K. Bansal, A. Bhiwandiwalla, J. Bobba, M. Brookhart,
A. Chakraborty, W. Constable, C. Convey, L. Cook, O. Kanawi, R. Kim-
ball, J. Knight, N. Korovaiko, V. K. Vijay, Y. Lao, C. R. Lishka,
J. Menon, J. Myers, S. A. Narayana, A. Procter, and T. J. Webb, “Intel
ngraph: An intermediate representation, compiler, and executor for deep
learning,” CoRR, vol. abs/1801.08058, 2018.

[39] “Arm NN.” [Online]. Available: https://github.com/ARM-software/

armnn
[40] Nvidia,

“8

bit

[Online].
http://on-demand.gputechconf.com/gtc/2017/presentation/

TensorRT.”

inference

with

Available:
s7310-8-bit-inferencewith-tensorrt.pdf

[41] “plaidml: A platform for making deep learning work everywhere.”

[Online]. Available: https://github.com/plaidml/plaidml

[42] T. Zerrell and J. Bruestle, “Stripe: Tensor compilation via the
nested polyhedral model,” CoRR, vol. abs/1903.06498, 2019. [Online].
Available: http://arxiv.org/abs/1903.06498

[43] C. Lattner and J. Pienaar, “Mlir primer: A compiler infrastructure for

the end of moores law,” 2019.

