0
2
0
2

b
e
F
6

]
L
P
.
s
c
[

1
v
5
4
1
2
0
.
2
0
0
2
:
v
i
X
r
a

PolyScientist: Automatic Loop Transformations
Combined with Microkernels for Optimization of
Deep Learning Primitives

Sanket Tavarageri
Intel Labs
sanket.tavarageri@intel.com

Alexander Heinecke
Intel Labs
alexander.heinecke@intel.com

Sasikanth Avancha
Intel Labs
sasikanth.avancha@intel.com

Gagandeep Goyal
IIT Hyderabad
cs19mtech01003@iith.ac.in

Ramakrishna Upadrasta
IIT Hyderabad
ramakrishna@iith.ac.in

Bharat Kaul
Intel Labs
bharat.kaul@intel.com

Abstract
At the heart of deep learning training and inferencing are
computationally intensive primitives such as convolutions
which form the building blocks of deep neural networks.
Researchers have taken two distinct approaches to creating
high performance implementations of deep learning kernels,
namely, 1) library development exemplified by Intel MKL-
DNN for CPUs, 2) automatic compilation represented by the
TensorFlow XLA compiler. The two approaches have their
drawbacks: even though a custom built library can deliver
very good performance, the cost and time of development
of the library can be high. Additionally, hand coding of a
plethora of operators for performance is not scalable over
the long term as more and more deep learning operators get
invented. Automatic compilation of kernels is attractive but
in practice, till date, automatically generated implementa-
tions lag expert coded kernels in performance by orders of
magnitude.

In this paper, we develop a hybrid solution to the develop-
ment of deep learning kernels that achieves the best of both
worlds: the expert coded microkernels are utilized for the
innermost loops of kernels that exploit the vector register
files, and vector units of modern CPUs effectively, and we
use the advanced polyhedral compilation technology to au-
tomatically tune the outer loops for performance. We design
a novel polyhedral model based data reuse algorithm to opti-
mize the outer loops of the kernel. The overall effect of this
combined approach will be that 1) the library development
effort is reduced to writing of only a small number of tiny
kernels that occur commonly in deep learning workloads,
and thus library development is made scalable; 2) automatic
compilation with the use of expert-coded microkernels will
achieve state-of-the art high performance. Through exper-
imental evaluation on an important class of deep learning
primitives namely convolutions, we demonstrate that the
approach we develop attains the same levels of performance
as Intel MKL-DNN, a hand coded deep learning library.

1 Introduction
Deep learning has revolutionized many spheres of human
activity, examples of which include, speech recognition [24],
image recognition [23, 28], web search [1], language transla-
tion [42], conversational artificial intelligence [14] etc. Train-
ing and inferencing using deep neural networks (DNNs) that
lie at the heart of deep learning are computationally inten-
sive tasks. Because of the importance of deep learning and
the need to speed up training and inferencing, custom chips
such as Google TPUs, Intel Nervana chips, NVIDIA Tensor-
Cores have been built. On the software side, frameworks
such as TensorFlow, PyTorch, Intel MKL-DNN have been
created to allow data scientists to write high performing
deep learning code in an efficient manner. However, all these
frameworks use manually optimized primitives to deliver
high performance.

The proliferation of computer architectures and the in-
vention of a variety of deep learning kernels has brought
to the fore the need to generate high performing kernel im-
plementations that undergird deep learning automatically.
Existing automatic compilation, and auto-tuning techniques
[4, 6–8, 10, 12, 13, 21, 27, 31, 35, 36, 38] are inadequate to
match the performance of hand-tuned library implementa-
tions – later on in the paper we show that the state-of-the-art
compiler generated code can lag library implementations on
CPUs by as much as ~10X or more. The main reason for the
failure of automatic compiler techniques in achieving very
high performance levels needed is that the sophistication
in the CPU microarchitecture has increased over successive
generations of CPUs (data prefetching, speculative execution,
vector units, deep memory hierarchies, complex cache re-
placement algorithms etc). Consequently, the cost functions
used to optimize code are unable to capture the nitty-gritties
of the underlying architectures, and therefore are unable to
derive the most effective execution schedules. Auto-tuning is
an alternative approach where one explores a large number
of program variants and selects the best performing version,
sidestepping the complexity of deriving a cost function that

1

 
 
 
 
 
 
adequately models the intricacies of the underlying hard-
ware architecture. However, auto-tuning is expensive and
furthermore, it may fall short of manually created library in
performance [4].

In this paper, we develop an approach that combines man-
ually optimized microkernels with automatic compilation
techniques. The inner most loops of kernels will be replaced
with microkernels and the outer loops will be automatically
optimized. It has been shown that 95% of all deep learning
applications running in the data centers today have a recur-
ring pattern in the inner most loops, namely blocked matrix
multiplication [17, 26]. Therefore, if a microkernel such as
that of matrix multiplication that exploits the vector units
of modern microprocessors effectively is used for the inner
most loops, and the outer loops are compiled to use the multi-
level caches of the hardware system well, then the resulting
performance will be very high and will be competitive with
that of a hand-tuned library.

We use a code-generator to create a number of program
variants - n in number - for a given program. The generated
code variants are then analyzed by our novel data reuse al-
gorithm – PolyScientist to characterize their cache behavior.
We have developed a relative ranking algorithm which ranks
the n variants based on their potential performance. The
top k variants are selected and are run on the target hard-
ware and the best performing program version is discovered.
Thus, PolyScientist narrows down the number of variants to
actually run on the target architecture from n to a small, man-
ageable k (k << n). Through our experimental evaluation on
convolutions of a range of popular and the state-of-the-art
image recognition models, we show that the top k variants
picked are some of the best performing variants, and the
realized performance is close to and in many cases, higher
than that of Intel MKL-DNN library [2], a hand-tuned library
for deep learning kernels.

The contributions of the paper are the following:

• To the best of our knowledge, this is the first work
that examines the use of microkernels and automatic
compilation techniques in an integrated manner.
• A novel cache data reuse analysis to characterize a
loop nest’s behavior with respect to a multi-level cache
hierarchy is presented.

• We describe a relative ranking heuristic that takes the
compiler generated statistics and the system parame-
ters, i.e., cache sizes and ranks the program variants
based on their potential performance.

• We conduct extensive experiments to demonstrate the
efficacy of the developed system in being able to pro-
duce high performance on deep learning kernels.

reuse analysis and a poly-ranking system to rank the can-
didate program variants in terms of performance. Section 6
details the experimental evaluation conducted. The related
work is discussed in Section 7 while Section 8 presents the
conclusion of this work.

2 Motivation
The deep learning primitives are computationally intensive
and most of the neural network training and inferencing
time is spent in them. However, for different layers of the
deep neural networks, the optimizations (e.g., loop order,
tile sizes in tiled code etc) that need to applied are different.
Using a version of the code optimized for one layer of a neu-
ral network for all others would yield poor performance. It
is this need for custom design for different layers of neural
networks (the number of layers in a deep neural network can
be large) is what makes generating efficient code for deep
learning primitives a challenging problem. To illustrate the
need for such tailored loop optimizations we consider the
convolution layers of the Fast R-CNN model [19], one of the
leading image recognition CNN models. We generate four
variants of convolution code which differ only in the loop
order and the rest of the loop structure remains the same for
all of them (more details are provided in §6) and measure per-
formance on a 28-core Intel(R) Xeon(R) Platinum 8280 (a.k.a
Cascade Lake) CPU server. Figure 1 shows the normalized
performance of the code variants on 25 convolution layers
of Fast R-CNN: the performance is normalized with respect
to the highest performing code among the four variants.

From Figure 1, we observe that the performance of differ-
ent versions of the code varies widely from layer to layer.
A convolution layer differs from another convolution layer
in problem sizes – image sizes, channel widths, filter sizes,
strides, and padding. The code version v2 has high perfor-
mance from layer 1 through 19, and is subpar from layer 20
to 27. The efficiencies of the other versions viz., v1, v3, and
v4 are much more widely varying. Using the methodology
detailed in the rest of the paper, the compiler technology
we have developed – the PolyScientist, we are able to ef-
fectively analyze the four code variants and pick the best
performing variant whose performance is shown in Figure
2. The performance achieved by PolyScientist picked code is
close to the highest performance among the four variants for
all 25 layers of Fast R-CNN. Thus using PolyScientist, using
compile-time static analysis alone, we will be able to auto-
matically identify and apply the loop optimizations required
for each layer of a deep neural network in order to achieve
the best performance.

The rest of the paper is organized as follows. The over-
all architecture of the PolyScientist system is presented in
Section 3. Section 4 describes preliminary concepts that will
be used later on. In Section 5, we develop the cache data

3 Overall System Architecture
Figure 3 shows the overall system design. The input to the
system is, the loop nest to be optimized – L along with
the microkernel that forms the inner-most loops. The loop

2

Figure 1. Performance of four code variants on layers of fas-
trcnn CNN model on a 28-core Intel Cascade Lake server

Figure 2. Performance of four code variants on layers of fas-
trcnn CNN model on a 28-core Intel Cascade Lake server

Figure 3. The PolyScientist system

based specification of the microkernel – M is substituted in
the code for further analysis. The resulting loop structure
– L ′ is regular. The code generator takes the loop nest L ′
and generators a large number of program variants while
keeping the inner most loops that correspond to M intact.
For each generated code variant, the working set sizes are
computed as described in §5.1. The statistics calculated for
all the variants are then input to the poly-ranking algorithm
described in §5.2 and it picks the top k best performing
versions. The original microkernels are inserted back into
the code of the k picks. The top performing variants selected
analytically are now run on the target architecture and and
best performing code among the k loop nests is determined.
Microkernel Specification The microkernel function
call is annotated with a pragma compiler directive which
contains the loop-based functionally equivalent code. The
microkernel function call is substituted with the loop based
code for the compiler analysis in a pre-processing pass. When
the cache data reuse analysis and ranking of the code vari-
ants are done, in a post-processing pass, the loop-based inner
most loops are replaced with the call to the microkernel.

f o r

( i = 0 ;
f o r

i ++ )

i < M;

{
j < N ;
j + + )
( k = 0 ; k < K ; k ++ )

( j = 0 ;
f o r
C[ i ] [ j ] += A[ i ] [ k ]

{

{
∗ B [ k ] [ j ] ;

}

}

}

Figure 4. Matrix multiplication code

4 Preliminaries
4.1 Notation

We use the polyhedral model [16], which is an advanced
mathematical framework to reason about dependences and
loop transformations, to develop our data reuse algorithm.
We use the Integer Set Library [40] for performing polyhedral
operations in this work and we use the same notation as
used in ISL to elucidate the concepts and the algorithm. The
matrix multiplication code shown in Figure 4 will be used to
illustrate the workings of the data reuse analysis.

3

Loop nest + MicrokernelE.g., convolution + gemmLoop variant generatorPolyScientistTarget architectureHigh Performance primitiven versionstop k versionsSystem Configuration: Cache SizesSets A set is a tuple of variables xi s along with a collection
of constraints ck s defined on the tuple variables.

s = {[x1, . . . , xn] : c1 ∧ . . . cm }
The iteration spaces of loop nests are represented by sets.
The iteration space of the loop in Figure 4 is defined as the
following set.
I = {S[i, j, k] : 0 <= i < M ∧ 0 <= j < N ∧ 0 <= k < K }

Relations A relation is a mapping from input tuple vari-
ables xi s to output tuple variables yj s. In addition, a set of
constraints ck s can be defined for a relation place constraints
on the input/output tuple variables.

r = {[x1, . . . , xn] (cid:55)→ [y1, . . . , ym] : c1, . . . , cp }
The read and write access functions of a loop nest can be
modeled with relations. The read relations in the Figure 4
code are shown below.

r1 = {S[i, j, k] (cid:55)→ C[i, j]}
r2 = {S[i, j, k] (cid:55)→ A[i, k]}
r3 = {S[i, j, k] (cid:55)→ B[k, j]}

The sole write relation in the loop is:

w1 = S[i, j, k] (cid:55)→ C[i, j].

Apply operation When a relation r is applied on a set s,
the domain of r will be intersected with s and the resulting
range will be a new set s ′. The set s ′ is said to be the result of
the apply operation. The operation is mathematically defined
as:

((cid:174)y ∈ s ′) ⇐⇒ (∃(cid:174)x s.t ((cid:174)x ∈ s ∧ (cid:174)x (cid:55)→ (cid:174)y) ∈ r )
The data footprint of the loop can be computed by applying

read and write relations on the iteration space set:

r1(I ) ∪ r2(I ) ∪ r3(I ) ∪ w1(I )

4.2 Polyhedral dependences

The exact data dependences in loop nests can be computed in
the polyhedral model and are expressed as maps from source
iterations to target iterations involved in the dependence. For
cache data reuse analysis developed in §5, we consider four
kinds of dependences – Read-After-Read (RAR), Read-After-
Write (RAW, a.k.a flow), Write-After-Read (WAR, a.k.a anti),
and Write-After-Write (WAW). The data dependencies of the
matrix multiplication code in Figure 4 are shown below.

d1 ={S[i, j, k] (cid:55)→ S[i ′, j ′, k ′] : i ′ = i ∧ j ′ = j ∧ k < k ′ < K }
d2 ={S[i, j, k] (cid:55)→ S[i ′, j ′, k ′] : i ′ = i ∧ k ′ = k ∧ j < j ′ < N }
d3 ={S[i, j, k] (cid:55)→ S[i ′, j ′, k ′] : j ′ = j ∧ k ′ = k ∧ i < i ′ < M }

The dependence d2 is induced by array reference A[i][k].
An element of array A, say A[0][0] which is accessed in
source iteration [i = 0, j = 0, k = 0] gets reused in target
iterations [i ′ = 0, j ′ > 0, k ′ = 0]. The source to target itera-
tion relationships such as this are expressed in a parametric
fashion as the relation d2.

5 Cache Data Reuse Analysis
We develop a polyhedral model based cache data reuse anal-
ysis to characterize a loop-nest’s behavior with respect to a
given cache hierarchy. The analysis computes the various ex-
isting data reuses of a program and then for the input cache
hierarchy determines which data reuses are exploitable at
various levels of cache.

5.1 Working set size computation

Each data dependence in a loop is also a case of data reuse –
the source and target iterations involved in the dependence
touch the same data element and therefore, the data is reused.
For a data dependence and hence data reuse to be realizable in
a given level of cache, all the data elements accessed between
the source and target iterations of the dependence – the
working set – have to be retained in the cache so that when
the execution reaches the target iteration, the data element(s)
used in the source iteration will still be present in the cache.

Algorithm 1: Compute working set sizes
Input: Loop nest: L
Output: The working set sizes: W Sall

1 {Iteration space: I, Read relations: rr ead , Write

relations: rwr it e , Schedule: δ } ← Parse the loop nest
L

2 {DRAR, DRAW , DW AR, DW AW } ← Compute

read-after-read, read-after-write, write-after-read,
write-after-write dependences of L

3 Dall ← DRAR ∪ DRAW ∪ DW AR ∪ DW AW
4 W Sall ← ∅

/* Iterate through all dependences to compute the

working set sizes

*/

5 for d ∈ Dall do
6

Isour ce ← lexmin dom d
Imin_t ar ← lexmin d(Isour ce )
Imax _t ar ← lexmax d(Isour ce )
Imin_W S ← (I <<= Imin_t ar ) − (I << Isour ce )
Imax _W S ← (I <<= Imax _t ar ) − (I << Isour ce )
W Smin ← |rr ead (Imin_W S ) ∪ rwr it e (Imin_W S )|
W Smax ← |rr ead (Imax _W S ) ∪ rwr it e (Imax _W S )|
Add W Smin and W Smax to W Sall

7

8

9

10

11

12

13

Algorithm 1 computes all the working sets of the input
loop nest. First, the input C source file is parsed using the

4

Polyhedral Extraction Tool (PET) [41] to obtain the polyhe-
dral representation of the program, namely iteration space of
the loop nest, read and write relations and the schedule (line
1). The exact (and not transitive) RAR, RAW, WAR, WAW
dependences are then computed and a union of all the four
kinds of dependences is formed (line 2 and 3). The task now is
to compute the working set size for each dependence which
is carried out from line 5 through 13. For a given dependence,
we consider a representative source – the first iteration (lex-
icographically) of all the source iterations (line 6). We can
now compute the target iterations for the lexicographically
first/minimum iteration. If the data element that is used in
the source iteration is used in multiple subsequent iterations
then there may be multiple target iterations for the same
source iteration. Therefore, the working sets to exploit the
data reuse may vary. For this reason, we compute the first
(or lexicographically minimum) and last (lexicographically
maximum) iterations of the target iterations (line 7 and 8).
The intervening iterations between source and the first tar-
get iteration are determined (line 9). Similarly, the iterations
between source and the target iteration are derived (line
10). The working sets will be the union of all the read and
written data elements between the source and the first/last
iterations of the target iteration set (line 11 and 12). Corre-
spondingly, for a dependence we compute two working set
sizes – W Smin and W Smax , if there are multiple target itera-
tions for a source iteration in a given dependence. What this
means is, in order to be able to exploit at least one data reuse
arising from the dependence d, the cache memory should
be capacious enough to hold at least W Smin data elements.
If all the data reuses are to be realized – till the last target
iteration, then the cache should of size equal to W Smax in
terms of the datatype’s elements.

We illustrate the operation of the algorithm using the
running example in Figure 4. Let us examine the dependence:
d2 = {S[i, j, k] (cid:55)→ S[i ′, j ′, k ′] : i ′ = i ∧ k ′ = k ∧ j < j ′ < N }
Of all the source iterations, the first/lexicographically mini-
mum iteration is:

Isour ce = {S[i = 0, j = 0, k = 0]}
Its target iterations are: {S[i = 0, j, k = 0] : 0 < j < N }
Among the target iterations, the first one is:

Imin_t ar = {S[i = 0, j = 1, k = 0]}

and the last one is:

Imax _t ar = {S3[i = 0, j = N − 1, k = 0]}
The number of data elements of the three arrays – A, B, C
accessed between Isour ce and Imin_t ar is derived by applying
the read and write relations on the intervening iteration set
and it is:

W Smin = 2K + 3
The K elements of array A – A[0][0, 1, . . . , K − 1], the
K + 1 elements of array B – B[0, 1, . . . , K − 1][0] and B[0][1],

and finally 2 elements of array C – C[0][0], C[0][1] accessed
between the source iteration S[i = 0, j = 0, k = 0] and the
target iteration Imin_t ar = S[i = 0, j = 1, k = 0] lead to the
W Smin size of 2K + 3.

The maximum working set size – the size of the data

touched between Isour ce and Imax _t ar is:

W Smax = N × K + N + 1
TheW Smax size is arrived at by counting the number of array
elements accessed between the source iteration - S[i = 0, j =
0, k = 0] and the target iteration - Imax _t ar = {S3[i = 0, j =
N − 1, k = 0]}. As far as array A is concerned, K elements
of it – A[0][0, 1, . . . , K − 1] are read. Array B’s elements –
B[0, 1, . . . , K − 1][0, 1, . . . , N − 2] plus B[0][N − 1] are read
which total K × (N − 1) + 1. N elements of array C are
read and written – C[0][0, 1, . . . , N − 1]. Therefore, a total
of N × K + N + 1 are read and written.

5.2 Poly-ranking algorithm

Algorithm 2: Compute working set sizes w.r.t cache
sizes
Input: The working set sizes: W Sall ,
Cache sizes: SizeL1, . . . SizeLn
Output: Working set sizes per cache:
W S Li for i = 1, . . . , n,

Memory working set size: W Smem
1 Initialize W S Li to 0 for i = 1, . . . , n,
2 Sort working set sizes in W Sall from smallest to

largest

3 for W Sj ∈ W Sall do
4

for SizeLi ∈ SizeL1, . . . SizeLn do

if (W Sj + W S Li ) ≤ SizeLi then

W S Li = W S Li + W Sj
break

5

6

7

8 Add the working sets W Sj ∈ W Sall that do not fit any

cache to W Smem

Figure 5. The DNN architecture for ranking of code variants

5

We have built a code generator to emit a number of pro-
gram variants. The code generator creates the loop variants
by applying tiling and loop interchange program transforma-
tions. The tile sizes are varied as well. The working set size
computation analysis –§5.1 is performed on each program
version generated. Among the many variants generated, the
poly-ranking algorithm described below picks the top k best
performing versions, where k is a parameter. In this work,
we pick the top 1 variant the code generator produces, i.e.,
k = 1.

If the working set size corresponding to a data reuse in the
program is smaller than the cache size then the data reuse is
exploitable in the cache. The poly-ranking system considers
caches at different levels (typically L1, L2, and L3) and for
each data reuse, determines at what level of cache hierarchy
is the data reuse realizable. Algorithm 2 shows the steps to
determine the cumulative working set sizes at each level of
cache. The inputs to the algorithm are the working set sizes
computed for a loop nest, and the cache sizes of the target
system. The algorithm determines the fastest level of cache
where the working set size corresponding to each data reuse
fits and adds it to that cache’s working set size. The working
set sizes that fit in a particular level of cache Li are denoted
by W S Li . If a working set does not fit in any cache, then the
data reuse happens out of the main memory. Consequently,
the memory’s working set size is updated.

5.2.1 Performance cost model based ranking

The running time of the loop is directly related to the la-
tency of the cache where the data reuse occurs as well as
the working set size. Furthermore, the running time is in-
versely related to the bandwidth of the cache. Based on these
observations, we define the following cost function:

C = (cid:213)
Li

W S Li ×

lat Li
bw Li

+ W Smem ×

latmem
bwmem

(1)

The latency of cache Li is lat Li while its bandwidth is
denoted by bw Li . For each code variant generated, we run
the cache data reuse analysis and calculate the above cost
function. Then, the variants are ranked in the decreasing
order of the value of the cost function: the lower the value,
the higher is its assumed performance, and higher is its rank.

5.2.2 DNN-based ranking algorithm

We explore the use of deep neural networks (DNNs) for
ranking code variants. For the purposes of training the DNN
model, we collect the performance data of code variants
generated and the statistics as outputted by Algorithm 2 –
working set sizes at different levels of the memory hierarchy.
We train the DNN model to perform relative ordering of
two code variants. We then use a tournament based ranking
system to assign ranks to the different code versions created
– we play each code variant against every other code variant.

For each variant, we record the number of wins it has accu-
mulated. We then rank the variants based on the number of
wins – the higher the number of wins, the higher the rank.
Figure 5 shows the architecture of the DNN. We normalize
the compiler generated statistics of two code variants in
the following fashion and input them to the DNN. We sum
the working set sizes of the two variants together: sum =
v1 L1 +v1 L2 +v1 L3 +v1 mem +v2 L1 +v2 L2 +v2 L3 +v2 mem
and divide the individual statistic by this sum. The rationale
for considering the sum of the two statistics together is that
if one of the variants is creating higher volume working set
sizes then its statistics should appear bigger to the DNN. This
is because the smaller the working set sizes, we can expect
higher performance. Therefore, for the DNN to learn the
relative performances of the two variants, it is crucial that it
sees the relative sizes of the working set sizes. Normalizing
each variant individually (by considering the sum of statistics
of one variant alone) would not bring out the differences in
the absolute values of working set sizes of the two variants
at different cache levels.

We use four intermediate layers of 64, 32, 16, 8 neurons
respectively. We use relu, relu, softsign, and relu activation
functions for the four intermediate layers. The output layer
consists of two neurons and we use the softmax function
for the output layer. The values of the two output neurons,
because of the use of softmax function, sum to 1. If the output
value is above a threshold - θ , we consider it a 1, otherwise a 0.
If the first neuron fires a 1, then the first variant is considered
the winner. If the second neuron fires a 1, then the second
variant is considered the winner. If both of them are zero
because none of them are above the threshold, then it is
a draw between the two variants. In this work, we set the
threshold θ to 0.6.

We experimented with deeper models as well. However,
the depth beyond four layers did not have any discernible
effect on accuracy.

6 Experimental Evaluation
We conduct experiments to evaluate the efficacy of the Poly-
Scientist system which combines loop optimizations with
expert-coded kernels. Since the aim of PolyScientist is to
achieve performance competitive with manually optimized
code and at the same time retaining the attractiveness of an
automatic compiler, we gauge the performance of PolySci-
entist against a state-of-the-art library created specifically
for deep learning networks – the latest version of Intel MKL-
DNN [2] viz., v1.0.4 and against the compiler generated code
using the Intel icc compiler of version 19.0.3.199.

6.1 Set up

We use the PolyScientist system to optimize the convolu-
tions of Resnet-50 [23], Fast R-CNN (fastrcnn) [19], Mask
R-CNN (maskrcnn) [22], Xception (xception) [11], You Only

6

#pragma omp p a r a l l e l
f o r

( img = 0 ;

{
( o f m _ t i l e = 0 ; o f m _ t i l e < nOfm / GEMM_BLOCK ; ++ o f m _ t i l e )

img < nImg ; ++img )

{

f o r

f o r p r i v a t e ( o f m _ t i l e ,

i f m _ t i l e ,

i j , o j , k j , k i ,

i i )

f o r

( i f m _ t i l e = 0 ;

i f m _ t i l e < nIfm / GEMM_BLOCK ; ++ i f m _ t i l e )

{

f o r

( o j = 0 ; o j < o f h ; ++ o j )

{

i j = o j
f o r

∗ STRIDE_H ;

( k j = 0 ; k j < kh ; ++ k j )

{

f o r

( k i = 0 ; k i < kw ; ++ k i )

{

/ ∗ GEMM o p e r a t i o n b e g i n s

∗ /

f o r

( o i = 0 ; o i < ofw ; ++ o i )

{

i i = o i
f o r

∗ STRIDE_W ;

( ofm = 0 ; ofm < GEMM_BLOCK ; ++ofm )
f o r

i f m < GEMM_BLOCK ; ++ i f m )
o u t p u t [ img ] [ o f m _ t i l e ] [ o j ] [ o i ] [ ofm ] +=

( i f m = 0 ;

{

{

f i l t e r [ o f m _ t i l e ] [ i f m _ t i l e ] [ k j ] [ k i ] [ i f m ] [ ofm ]
∗

i n p u t [ img ] [ i f m _ t i l e ] [ i j + k j ] [ i i + k i ] [ i f m ] ;

}

}

}

/ ∗ GEMM o p e r a t i o n e n d s

∗ /

}

}

}

}

}

}

Figure 6. The 2-D Convolution code

Look Once v2 (yolov2) [30], MobileNets (mobilenet) [25],
AlexNet (alexnet) [29], OverFeat (overfeat) [32] GoogLeNet
v1 and v3 [34], and (googlenetv1, googlenetv3), the popular
and the state-of-the-art image recognition neural network
models. We also gather the performance results from the
hand-coded, highly optimized Intel MKL-DNN library for
the same convolutions. In this work, we evaluate the perfor-
mance benefits of the PolyScientist system on CPUs. Since in
today’s datacenters, CPUs are predominantly used for infer-
ence tasks partly due to latency considerations, we study the
performance of forward-pass convolutions which are used
in the inference tasks while performing image recognition.
Figure 6 shows the convolution code with the GEMM (ma-
trix multiplication) microkernel replaced with the equivalent
C code. The shown code is data tiled in the input and output
channel dimensions. The convolution code has a matrix mul-
tiplication operation (denoted GEMM in the code) embedded
in it. The loops corresponding to matrix multiplication are
moved to the inner most positions so that matrix multipli-
cation is performed on the fastest varying dimensions of

7

the arrays. We use the performance obtained using the code
shown in 6 as the baseline.

We use the LIBXSMM [3] implementation for matrix mul-
tiplication – the microkernel. PolyScientist performs outer
loop optimization around the call to the matrix multiplica-
tion microkernel by loop reordering and tiling using various
tile sizes. We show the performance obtained by inserting
the LIBXSMM microkernel in the code listed in Figure 6
under the banner of Microkernel in the subsequent perfor-
mance graphs. Comparing the performance of Microkernel
with PolyScientist will show the need to perform outer loop
tuning as done by PolyScientist to obtain high performance
for all layers and for all models.

The experiments are run on the latest Intel servers – In-
tel(R) Xeon(R) Platinum 8280 (Cascade Lake) CPU servers
running at the frequency of 2.70GHz. Each processor has
28 cores, 32KB private L1 cache, 1MB private L2 cache, and
39MB shared L3 cache. Each program is run a 1000 times and
the average performance across those runs is reported in the

Figure 7. Performance of Resnet-50 layers on a 28-core Intel
Cascade Lake server

Figure 8. Performance distribution of code variants for Resnet-
50 layers on a 28-core Intel Cascade Lake server

Figure 9. Performance of fastrcnn layers on a 28-core Intel
Cascade Lake server

Figure 10. Performance distribution of code variants for fas-
trcnn layers on a 28-core Intel Cascade Lake server

Figure 11. Performance of maskrcnn layers on a 28-core Intel
Cascade Lake server

Figure 12. Performance distribution of code variants for
maskrcnn layers on a 28-core Intel Cascade Lake server

paper. The machine has a 512-bit SIMD vector unit and sup-
ports AVX-512 vector instructions. Consequently, 16 floating
point arithmetic operations can be performed at a time (each
floating point number is 32 bits long, and therefore, 16 float-
ing point numbers make up 512 bits: 32×16 = 512). Since the
microkernel vectorizes along the input and output channel
loops (i f m and o f m loops in the code), to fully utilize the
vector unit, the input and output channel widths have to be
16 or multiples of 16. In the CNN models considered, 86% of
the convolutions meet this criterion and those convolutions

are selected for experimental evaluation. The peak single
precision floating point performance of a Cascade Lake pro-
cessor is ~3,300 GFLOPS/s. We set the mini-batch size to 28
and use data parallelism: the convolution operator is applied
on 28 images simultaneously.

To train a DNN model for performing ranking of code
variants as described in §5.2.2, we use 70% of the experimen-
tal data collected (to avoid overfitting). We create a single
DNN model using data from all CNN models and use it to
rank variants across the CNN models.

8

Figure 13. Performance of xception layers on a 28-core Intel
Cascade Lake server

Figure 14. Performance distribution of code variants for xcep-
tion layers on a 28-core Intel Cascade Lake server

Figure 15. Performance of yolov2 layers on a 28-core Intel
Cascade Lake server

Figure 16. Performance distribution of code variants for
yolov2 layers on a 28-core Intel Cascade Lake server

Figure 17. Performance of mobilenet layers on a 28-core Intel
Cascade Lake server

Figure 18. Performance distribution of code variants for mo-
bilenet layers on a 28-core Intel Cascade Lake server

Figure 19. Performance of alexnet layers on a 28-core Intel
Cascade Lake server

Figure 20. Performance distribution of code variants for
alexnet layers on a 28-core Intel Cascade Lake server

9

Figure 21. Performance of overfeat layers on a 28-core Intel
Cascade Lake server

Figure 22. Performance distribution of code variants for over-
feat layers on a 28-core Intel Cascade Lake server

Figure 23. Performance of googlenetv1 layers on a 28-core
Intel Cascade Lake server

Figure 24. Performance distribution of code variants for
googlenetv1 layers on a 28-core Intel Cascade Lake server

Figure 25. Performance of googlenetv3 layers on a 28-core
Intel Cascade Lake server

Figure 26. Performance distribution of code variants for
googlenetv3 layers on a 28-core Intel Cascade Lake server

6.2 Experimental Results

Figure 7 shows the performance in terms of GFLOPS/s (Giga
Floating point Operations per second) of the baseline code,
PolyScientist, Microkernel and MKL-DNN on convolutions
of Resnet-50. The PolyScientist performance shown is the
performance of the top code variant selected using the cost
modeling based poly-ranking algorithm described in §5.2.1.
The performance of PolyScientist over the baseline is 5X to
10X for all layers. The higher performance of PolyScientist
is due to 1) the use of optimized GEMM microkernel and

2) the optimization of outer loops around the call to the mi-
crokernel. In most cases, PolyScientist closely matches the
performance of MKL-DNN library. In several instances, Poly-
Scientist outperforms MKL-DNN, notably for layers with
IDs 15, 16, and 17 where the performance gain is 11%. On
some layers such as layer 1, MKL-DNN fares better. This
is explained by customizations for specific problem sizes
including insertion of careful data prefetching instructions
in the MKL-DNN library code. In contrast, PolyScientist’s
approach is automatic and in the case of Resnet-50, we ob-
serve that we are able to attain the same performance levels

10

Table 1. The geometric average of the performance of layers
of various models in GFLOPS/s on a 28-core Intel Cascade
Lake server

Model

Resnet-50
fastrcnn
maskrcnn
xception
yolov2
mobilenet
alexnet
overfeat
googlenetv1
googlenetv3

Baseline

PolyScientist

PolySct.-DNN MKL-DNN

391
390
336
348
387
333
418
331
241
291

2448
2305
1988
2276
2503
2217
2751
2621
2322
2480

2463
2312
2052
2292
2551
2247
2779
2644
2377
2492

2459
2511
2243
2595
2547
2440
2563
2534
2276
2547

as MKL-DNN. The geometric average of GFLOPS/s numbers
are also shown in the graph. We report the geometric aver-
age of performance results in Table 1 as well for Resnet-50
and all other CNN models. For Resnet-50, we observe that
performance of Microkernel and PolyScientist is similar in-
dicating that the original loop order shown in Figure 6 gets
good performance.

Figure 8 shows the performance distribution of code vari-
ants generated for each layer of Resnet-50. The performance
is normalized with respect to that of the best performing
variant found empirically. The crux of the PolyScientist tech-
nology presented in the paper is to rank a given set of code
variants using compile-time static analysis. Therefore, the
closer the performance of the PolyScientist picked version is
to the maximum performance seen by any code variant ex-
plored, the more efficacious the PolyScientist algorithms are.
In the graph, we show the minimum performance observed,
the maximum performance seen, the performance of the code
picked per the poly-ranking algorithm (§5.2.1) – PolyScien-
tist and the performance of the code picked per the DNN
based ranking algorithm (§5.2.2) – PolyScientist-DNN. We
note that the performance of PolyScientist version is close to
the maximum performance in most layers save layer 19. Even
though in terms of cache behavior (PolyScientist primarily
models the cache behavior), the variant selected by PolySci-
entist may be the best, other factors such as prefetching, TLB
behavior etc may cause their performance to be lower than
those of other variants. The minimum performance seen
i.e., the performance of the worst code variant, varies across
layers – for layer 12 through 19, the minimum performance
is much farther from the maximum performance. For the
initial layers however, the different code variants generated
perform similarly. In all cases, we note that PolyScientist per-
forms significantly better than the worst variant including
layer 19 where PolyScientist picked code is 14% slower than
the best performing version and is 28% higher performing

11

than the worst variant. We observe that there is no consider-
able difference in the performance achieved by cost model
based ranking method – PolyScientist, and the DNN based
ranking method – PolyScientist-DNN.

The performance achieved by different methods for con-
volutions of fastrcnn is shown in Figure 9. The performance
of PolyScientist vis-a-vis the baseline code is anywhere be-
tween 4X and 11X across layers. PolyScientist performance
is close to the MKL-DNN’s. For some layers such as layer 11,
PolyScientist is 9% faster while for a few layers notably layer
1, and 3, MKL-DNN performs better. In this case of fastrcnn,
we see that PolyScientist outperforms Microkernel significantly
clearly showing the need for outer loop tuning in addition to
having a high performance implementation of matrix multi-
plication in the inner most loops. PolyScientist picked code
achieves ~2X performance gains over the code with the de-
fault loop order for layers 4, 7, 8, 10, and 11 while for layer 25,
PolyScientist is 56% higher performing. Across all layers of
fastrcnn, PolyScientist improves the performance by 28% on
average. Figure 10 shows the performance distribution for
all layers of fastrcnn. Here, we see that the performance dis-
tribution is great: the difference between the performance of
the best and the worst code variant seen is vast for all layers
except layer 18. We observe that PolyScientist is able to pick
a variant whose performance is close to the performance of
the best performing version.

From Figure 11 through Figure 26, we show the perfor-
mance achieved by various systems and the performance
distribution of code variants seen for all other CNN mod-
els, namely, maskrcnn, xception, yolov2, mobilenet, alexnet,
overfeat, googlenetv1, and finally googlenetv3. In Figure 11
we observe that the performance of two layers of maskrcnn
– layer 31, and 32 is very low compared to the machine peak.
The reason is, the image sizes for the two layers are 7X7
and 1X1 respectively. Consequently, the amount of work
that each core has to perform is less and therefore, MKL-
DNN and PolyScientist are not able to attain performance
close to the machine peak. For maskrcnn too, we discover
that the default loop order – Microkerenel, leaves a lot of
performance on the table: for layers 4, 5, 6, 9, 10, 14, 15, Poly-
Scientist gets more than 2X extra performance compared to
only the use of the microkernel. For layer 7, PolyScientist
is 3X higher performing than Microkernel. Across all layers
of maskrcnn, the average performance benefit is 41%. In
Figure 14, we see that PolyScientist picks the right variant
for all layers for xception. For yolov2 from Figure 15, we
note that PolyScientist performance closely matches that of
MKL-DNN and through Figure 16, we see there is a great
spread in performance of various code variants run. In mo-
bilenet, PolyScientist is as high performing as MKL-DNN
(Figure 17). Further, the different code variants perform very
similarly for all layers of mobilenet (Figure 18). In alexnet,
we hardly see any difference in the relative performance
across the layers – Figure 20. In overfeat, PolyScientist is

slightly higher performing than MKL-DNN and the perfor-
mance spread is fair among different code variants generated
(Figures 19, and 20). googlenetv1 and googlenetv3 feature
many more unique layers and PolyScientist’s performance
is slightly better than MKL-DNN’s for googlenetv1 and is
slightly worse for googlenetv3 (Figures 23, and 23).

Table 1 shows the average performance of the four systems
– baseline, PolyScientist, PolyScientist-DNN, and MKL-DNN
for various CNN models. The performance of PolyScientist-
DNN is consistently slightly better than that of PolyScientist.
Further, PolyScientist achieves magnitudes of higher perfor-
mance compared to the baseline code and is very competitive
with respect to the hand crafted MKL-DNN library code. In
fact, PolyScientist outperforms MKL-DNN in the case of
alexnet, overfeat, and googlenetv1.

7 Related Work
Researchers have developed auto parallelization and pro-
gram transformation systems to automatically transform
code to achieve high performance [7, 27]. The state-of-the-
art polyhedral compiler – Pluto [7] derives a schedule for
the code that attempts to minimize data reuse distances.
The effect of the Pluto transformation will be that the it-
erations that use the same data will be executed close to
each other in time and therefore, it will be cache friendly.
However, Pluto’s performance can be far from what we can
achieve with the use of microkernels that exploit the vec-
tor hardware effectively and by doing outer loop tuning in
the way we have developed this work. Our initial experi-
mental evaluation comparing our work with Pluto revealed
that its performance can be off by as much as 100X. Kong et
al. [27] develop a framework to decompose a program into
sub-parts and use customized criteria (as opposed to using a
single objective function) – such as stride optimization, outer
loop optimization, inner loop optimization to transform code.
They show that their work without tiling transformation is
able to achieve comparable results to that of Pluto.

Compile-time modeling of cache behavior and in particu-
lar calculating the number of cache misses has been an active
area of research [5, 18, 20]. The researchers have demon-
strated good accuracy in predicting the number of cache
misses on simulators. The modern computer architectures
employ a hash based scheme to map memory addresses to
cache sets [44] which breaks the assumptions behind the
cache miss analysis. Consequently, their usefulness in mod-
eling the performance of programs will suffer. In the present
work, we model the behavior of caches as well. However, we
do not model cache misses rather we consider data reuses
and determine the size of cache needed to exploit the data
reuses under conservative conditions. We ignore streaming
accesses as their misses in cache will not be crucial in the
resulting performance. Because of the these techniques, we
show that we are able to accurately rank code variants in

12

terms of performance. Latte [39] is a domain specific lan-
guage and run time for coding of deep neural networks.
Latte relies on pattern matching to transform code patterns
to library calls. For example, when a convolution operation
is recognized, a library call is made to the CPU-specific li-
brary, say Intel MKL-DNN. Our work in this paper could be
complementary to that of Latte where instead of relying on
an external hand coded library, Latte could be made to use
PolyScientist for high performance implementations of deep
learning primitives.

Strout et al [33] introduce the novel concept of universal
occupancy vector (UOV) for storage optimization — expand
the arrays to a minimal degree so that the false dependences
are eliminated paving the way for better scheduling of the
code. Thies et al [37] develop methods to find a good sched-
ule when the storage mapping is fixed and vice versa. Ding
et al [15] introduce approximate reuse distance analysis and
sampling based profiling to predict whether a given applica-
tion exhibits regular data accesses or irregular data accesses.
Xiang et al [43] develop a theory of locality and show how
different locality metrics are related to each other.

Autotuning systems using parametric tiling [6, 13, 21, 31,
35, 36] perform tile size exploration with tiled code gener-
ated with tile sizes as parameters (rather than hard-coded tile
sizes). The parametric tiling technology reduces the code gen-
eration time during auto-tuning as the same code can be used
for multiple tile size explorations. AutoTVM [10] is targeted
at accelerating deep learning workloads and uses machine
learning to guide auto-tuning of deep learning primitives.
Tiramisu [4] is a polyhedral model based compiler frame-
work that introduces a scheduling language to allow the
programmer to explore various program transformations.
Active Harmony [12] determines the parameters that are
critical for performance among the set of parameters that
need to be auto-tuned in a given application and focuses on
optimizing them first in order to accelerate the process of
auto-tuning. CHiLL [8] is a compiler framework that assists
an auto-tuner in generating code for schedules expressed
in a high level language. Tiwari et al [38] combine Active-
Harmony and CHiLL to systematically explore the space
of program transformations. All of the above auto-tuning
systems, while useful, incur a huge expense in terms of com-
putation cost and time. The compiler algorithm developed
in the paper narrows down the search space to only a small
number of code variants thereby saving the auto-tuning cost.
TVM [9], a compiler for deep learning, introduces the
concept of tensorization, where a unit of computation can
be replaced with a microkernel written using hardware in-
trinsics. The TVM tensorization tool can be complementary
to our work – our work can be leveraged within TVM to
perform optimization of outer loops around tensorized code,
much like how we optimize code around the microkernel in
this paper.

8 Conclusion
In this paper, we presented a novel cache data reuse algo-
rithm. We leverage the reuse analysis to perform relative
ordering of program variants. Using these techniques, we
develop a framework to generate high performing code for
deep learning primitives. The framework also integrates the
expert-coded microkernels, further enabling the develop-
ment of high performing code that achieves performance
nearly identical to that of a hand-coded library. The pre-
sented methodology will allow the creation of deep learning
kernels in an automated fashion easing the burden of writing
hand-tuned libraries and at the same time, realizing state-
of-the-art efficiencies in utilizing modern dense processing
engines.

References
[1] [n. d.]. Google is AI first: 12 AI projects powering Google products.
https://blog.aimultiple.com/ai-is-already-at-the-heart-of-google/
[2] [n. d.]. Intel(R) Math Kernel Library for Deep Neural Networks. https:

//intel.github.io/mkl-dnn/

[3] [n. d.]. Library targeting Intel Architecture for specialized dense
and sparse matrix operations, and deep learning primitives. https:
//github.com/hfp/libxsmm

[4] Riyadh Baghdadi, Jessica Ray, Malek Ben Romdhane, Emanuele
Del Sozzo, Abdurrahman Akkas, Yunming Zhang, Patricia Suriana,
Shoaib Kamil, and Saman Amarasinghe. 2019. Tiramisu: A polyhe-
dral compiler for expressing fast and portable code. In Proceedings of
the 2019 IEEE/ACM International Symposium on Code Generation and
Optimization. IEEE Press, 193–205.

[5] Wenlei Bao, Sriram Krishnamoorthy, Louis-Noel Pouchet, and P Sa-
dayappan. 2017. Analytical modeling of cache behavior for affine
programs. Proceedings of the ACM on Programming Languages 2, POPL
(2017), 32.

[6] Muthu Manikandan Baskaran, Albert Hartono, Sanket Tavarageri,
Thomas Henretty, Jagannathan Ramanujam, and Ponnuswamy Sa-
dayappan. 2010. Parameterized tiling revisited. In Proceedings of the
8th annual IEEE/ACM international symposium on Code generation and
optimization. ACM, 200–209.

[7] Uday Bondhugula, Albert Hartono, J. Ramanujam, and P. Sadayappan.
2008. A Practical Automatic Polyhedral Program Optimization System.
In ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI).

[8] Chun Chen. 2007. Model-guided empirical optimization for memory

hierarchy. University of Southern California.

[9] Tianqi Chen, Thierry Moreau, Ziheng Jiang, Lianmin Zheng, Eddie Yan,
Haichen Shen, Meghan Cowan, Leyuan Wang, Yuwei Hu, Luis Ceze,
et al. 2018. {TVM}: An automated end-to-end optimizing compiler
for deep learning. In 13th {USENIX} Symposium on Operating Systems
Design and Implementation ({OSDI} 18). 578–594.

[10] Tianqi Chen, Lianmin Zheng, Eddie Yan, Ziheng Jiang, Thierry Moreau,
Luis Ceze, Carlos Guestrin, and Arvind Krishnamurthy. 2018. Learn-
ing to optimize tensor programs. In Advances in Neural Information
Processing Systems. 3389–3400.

[11] François Chollet. 2016. Xception: Deep Learning with Depthwise
Separable Convolutions. CoRR abs/1610.02357 (2016). arXiv:1610.02357
http://arxiv.org/abs/1610.02357

[12] I-Hsin Chung, Jeffrey K Hollingsworth, et al. 2004. Using information
from prior runs to improve automated tuning systems. In Proceedings
of the 2004 ACM/IEEE conference on Supercomputing. IEEE Computer
Society, 30.

[13] Alain Darte, Alexandre Isoard, et al. 2014. Parametric tiling with

inter-tile data reuse. IMPACT 2014 (2014).

[14] Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova.
2018. Bert: Pre-training of deep bidirectional transformers for language
understanding. arXiv preprint arXiv:1810.04805 (2018).

[15] Chen Ding and Yutao Zhong. 2003. Predicting Whole-program Locality
Through Reuse Distance Analysis. SIGPLAN Not. 38, 5 (May 2003),
245–257. https://doi.org/10.1145/780822.781159

[16] Paul Feautrier. 1996. Automatic parallelization in the polytope model.

In The Data Parallel Programming Model. Springer, 79–103.

[17] Evangelos Georganas, Kunal Banerjee, Dhiraj Kalamkar, Sasikanth
Avancha, Anand Venkat, Michael Anderson, Greg Henry, Hans Pabst,
and Alexander Heinecke. 2019. High-Performance Deep Learning via
a Single Building Block. arXiv preprint arXiv:1906.06440 (2019).
[18] Somnath Ghosh, Margaret Martonosi, and Sharad Malik. 1997. Cache
miss equations: An analytical representation of cache misses. In Inter-
national Conference on Supercomputing. Citeseer, 317–324.
[19] Ross Girshick. 2015. Fast R-CNN. arXiv:cs.CV/1504.08083
[20] Tobias Gysi, Tobias Grosser, Laurin Brandner, and Torsten Hoefler.
2019. A fast analytical model of fully associative caches. In Proceedings
of the 40th ACM SIGPLAN Conference on Programming Language Design
and Implementation. ACM, 816–829.

[21] Albert Hartono, Muthu Manikandan Baskaran, Cédric Bastoul, Albert
Cohen, Sriram Krishnamoorthy, Boyana Norris, Jagannathan Ramanu-
jam, and Ponnuswamy Sadayappan. 2009. Parametric multi-level tiling
of imperfectly nested loops. In Proceedings of the 23rd international
conference on Supercomputing. ACM, 147–157.

[22] Kaiming He, Georgia Gkioxari, Piotr Dollár, and Ross B. Girshick.
2017. Mask R-CNN. CoRR abs/1703.06870 (2017). arXiv:1703.06870
http://arxiv.org/abs/1703.06870

[23] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. 2016. Deep
residual learning for image recognition. In Proceedings of the IEEE
conference on computer vision and pattern recognition. 770–778.
[24] Geoffrey Hinton, Li Deng, Dong Yu, George Dahl, Abdel-rahman Mo-
hamed, Navdeep Jaitly, Andrew Senior, Vincent Vanhoucke, Patrick
Nguyen, Brian Kingsbury, et al. 2012. Deep neural networks for acous-
tic modeling in speech recognition. IEEE Signal processing magazine
29 (2012).

[25] Andrew G. Howard, Menglong Zhu, Bo Chen, Dmitry Kalenichenko,
Weijun Wang, Tobias Weyand, Marco Andreetto, and Hartwig Adam.
2017. MobileNets: Efficient Convolutional Neural Networks for Mobile
Vision Applications. CoRR abs/1704.04861 (2017). arXiv:1704.04861
http://arxiv.org/abs/1704.04861

[26] Norman P Jouppi, Cliff Young, Nishant Patil, David Patterson, Gaurav
Agrawal, Raminder Bajwa, Sarah Bates, Suresh Bhatia, Nan Boden,
In-datacenter performance analysis of a
Al Borchers, et al. 2017.
tensor processing unit. In 2017 ACM/IEEE 44th Annual International
Symposium on Computer Architecture (ISCA). IEEE, 1–12.

[27] Martin Kong and Louis-Noël Pouchet. 2019. Model-driven Transfor-
mations for Multi- and Many-core CPUs. In Proceedings of the 40th
ACM SIGPLAN Conference on Programming Language Design and Im-
plementation (PLDI 2019). https://doi.org/10.1145/3314221.3314653

[28] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. 2012. Imagenet
classification with deep convolutional neural networks. In Advances
in neural information processing systems. 1097–1105.

[29] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E. Hinton. 2012. Ima-
geNet Classification with Deep Convolutional Neural Networks. In
Proceedings of the 25th International Conference on Neural Information
Processing Systems - Volume 1 (NIPS’12). Curran Associates Inc., USA,
1097–1105. http://dl.acm.org/citation.cfm?id=2999134.2999257
[30] Joseph Redmon, Santosh Kumar Divvala, Ross B. Girshick, and Ali
Farhadi. 2015. You Only Look Once: Unified, Real-Time Object
Detection. CoRR abs/1506.02640 (2015).
arXiv:1506.02640 http:
//arxiv.org/abs/1506.02640

13

[31] Lakshminarayanan Renganarayanan, DaeGon Kim, Sanjay Rajopad-
hye, and Michelle Mills Strout. 2007. Parameterized tiled loops for free.
In ACM SIGPLAN Notices, Vol. 42. ACM, 405–414.

[32] Pierre Sermanet, David Eigen, Xiang Zhang, Michaël Mathieu, Rob
Fergus, and Yann LeCun. 2013. OverFeat: Integrated recognition,
localization and detection using convolutional networks. arXiv preprint
arXiv:1312.6229 (2013).

[33] Michelle Mills Strout, Larry Carter, Jeanne Ferrante, and Beth Simon.
1998. Schedule-independent Storage Mapping for Loops. In Proceed-
ings of the Eighth International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS VIII). ACM,
New York, NY, USA, 24–33. https://doi.org/10.1145/291069.291015

[34] Christian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet, Scott Reed,
Dragomir Anguelov, Dumitru Erhan, Vincent Vanhoucke, and Andrew
Rabinovich. 2015. Going Deeper with Convolutions. In Computer
Vision and Pattern Recognition (CVPR). http://arxiv.org/abs/1409.4842
[35] Sanket Tavarageri, Albert Hartono, Muthu Baskaran, Louis-Noël
Pouchet, J Ramanujam, and P Sadayappan. 2010. Parametric tiling
of affine loop nests. In Proc. 15th Workshop on Compilers for Parallel
Computers. Vienna, Austria.

[36] Sanket Tavarageri, J Ramanujam, and P Sadayappan. 2013. Adaptive
parallel tiled code generation and accelerated auto-tuning. The In-
ternational Journal of High Performance Computing Applications 27, 4
(2013), 412–425.

[37] William Thies, Frédéric Vivien, and Saman Amarasinghe. 2007. A Step
Towards Unifying Schedule and Storage Optimization. ACM Trans.
Program. Lang. Syst. 29, 6, Article 34 (Oct. 2007). https://doi.org/10.
1145/1286821.1286825

[38] Ananta Tiwari, Chun Chen, Jacqueline Chame, Mary Hall, and Jef-
frey K Hollingsworth. 2009. A scalable auto-tuning framework for
compiler optimization. In 2009 IEEE International Symposium on Paral-
lel & Distributed Processing. IEEE, 1–12.

[39] Leonard Truong, Rajkishore Barik, Ehsan Totoni, Hai Liu, Chick
Markley, Armando Fox, and Tatiana Shpeisman. 2016. Latte: A Lan-
guage, Compiler, and Runtime for Elegant and Efficient Deep Neural
Networks. In Proceedings of the 37th ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation (PLDI ’16). ACM, New
York, NY, USA, 209–223. https://doi.org/10.1145/2908080.2908105
[40] Sven Verdoolaege. 2010. isl: An integer set library for the polyhedral
model. In International Congress on Mathematical Software. Springer,
299–302.

[41] Sven Verdoolaege and Tobias Grosser. 2012. Polyhedral Extraction
Tool. In Second Int. Workshop on Polyhedral Compilation Techniques
(IMPACT’12). Paris, France.

[42] Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V Le, Mohammad
Norouzi, Wolfgang Macherey, Maxim Krikun, Yuan Cao, Qin Gao,
Klaus Macherey, et al. 2016. Google’s neural machine translation
system: Bridging the gap between human and machine translation.
arXiv preprint arXiv:1609.08144 (2016).

[43] Xiaoya Xiang, Chen Ding, Hao Luo, and Bin Bao. 2013. HOTL: A
Higher Order Theory of Locality. SIGPLAN Not. 48, 4 (March 2013),
343–356. https://doi.org/10.1145/2499368.2451153

[44] Yuval Yarom, Qian Ge, Fangfei Liu, Ruby B Lee, and Gernot Heiser.
2015. Mapping the Intel Last-Level Cache. IACR Cryptology ePrint
Archive 2015 (2015), 905.

14

