Programmatically Interpretable Reinforcement Learning

Abhinav Verma 1 Vijayaraghavan Murali 1 Rishabh Singh 2 Pushmeet Kohli 3 Swarat Chaudhuri 1

9
1
0
2

r
p
A
0
1

]

G
L
.
s
c
[

3
v
7
7
4
2
0
.
4
0
8
1
:
v
i
X
r
a

Abstract

We present a reinforcement learning framework,
called Programmatically Interpretable Reinforce-
ment Learning (PIRL), that is designed to gen-
erate interpretable and veriﬁable agent policies.
Unlike the popular Deep Reinforcement Learn-
ing (DRL) paradigm, which represents policies
by neural networks, PIRL represents policies us-
ing a high-level, domain-speciﬁc programming
language. Such programmatic policies have the
beneﬁts of being more easily interpreted than
neural networks, and being amenable to veri-
ﬁcation by symbolic methods. We propose a
new method, called Neurally Directed Program
Search (NDPS), for solving the challenging non-
smooth optimization problem of ﬁnding a pro-
grammatic policy with maximal reward. NDPS
works by ﬁrst learning a neural policy network
using DRL, and then performing a local search
over programmatic policies that seeks to mini-
mize a distance from this neural “oracle”. We
evaluate NDPS on the task of learning to drive
a simulated car in the TORCS car-racing envi-
ronment. We demonstrate that NDPS is able to
discover human-readable policies that pass some
signiﬁcant performance bars. We also show that
PIRL policies can have smoother trajectories, and
can be more easily transferred to environments
not encountered during training, than correspond-
ing policies discovered by DRL.

1. Introduction

Deep reinforcement learning (DRL) has had a massive im-
pact on the ﬁeld of machine learning and has led to re-
markable successes in the solution of many challenging
tasks (Mnih et al., 2015; Silver et al., 2016; 2017). While
neural networks have been shown to be very effective in

1Rice University 2Google Brain 3Deepmind. Correspondence

to: Abhinav Verma <averma@rice.edu>.

Proceedings of the 35 th International Conference on Machine
Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018
by the author(s).

learning good policies, the expressivity of these models
makes them difﬁcult to interpret or to be checked for con-
sistency for some desired properties, and casts a cloud over
the use of such representations in safety-critical applica-
tions.

Motivated to overcome this problem, we propose a learn-
ing framework, called Programmatically Interpretable Re-
inforcement Learning (PIRL)1, that is based on the idea of
learning policies that are represented in a human-readable
language. The PIRL framework is parameterized on a high-
level programming language for policies. A problem in-
stance in PIRL is similar to a one in traditional RL, but also
includes a (policy) sketch that syntactically deﬁnes a set of
programmatic policies in this language. The objective is to
ﬁnd a program in this set with maximal long-term reward.

Intuitively,
the policy programming language and the
sketch characterize what we consider “interpretable”. In
addition to interpretability, the syntactic restriction on poli-
cies has three key beneﬁts. First, the language can be used
to implicitly encode the learner’s inductive bias that will
be used for generalization. Second, the language can allow
effective pruning of undesired policies to make the search
for a good policy more efﬁcient. Finally, it allows us to use
symbolic program veriﬁcation techniques to formally rea-
son about the learned policies and check consistency with
correctness properties. At the same time, policies in PIRL
can have rich semantics, for example allowing actions to
depend on events far back in history.

A key technical challenge in PIRL is that the space of poli-
cies permitted in an instance can be vast and nonsmooth,
making optimization extremely challenging. To address
this, we propose a new algorithm called Neurally Directed
Program Synthesis (NDPS). The algorithm ﬁrst uses DRL
to compute a neural policy network that has high perfor-
mance, but may not be expressible in the policy language.
This network is then used to direct a local search over
In each iteration of this search,
programmatic policies.
we maintain a set of “interesting” inputs, and update the
program so as to minimize the distance between its out-
puts and the outputs of the neural policy (an “oracle”) on
these inputs. The set of interesting inputs is updated as
the search progresses. This strategy, inspired by imitation

1PIRL is pronounced Pi-R-L (as in π-RL)

 
 
 
 
 
 
Programmatically Interpretable Reinforcement Learning

learning (Ross et al., 2011; Schaal, 1999), allows us to per-
form direct policy search in a highly nonsmooth policy
space.

We evaluate our approach in the task of learning to
drive a simulated car in the TORCS car-racing environ-
ment (Wymann et al., 2014), as well as three classic con-
trol games (we discuss the former in the main paper, and
the latter in the Appendix). Experiments demonstrate that
NDPS is able to ﬁnd interpretable policies that, while not
as performant as the policies computed by DRL, pass some
signiﬁcant performance bars. Speciﬁcally, in TORCS, our
policy sketch allows an unbounded set of programs with
branches guarded by unknown conditions, each branch
representing a Proportional-Integral-Derivative (PID) con-
troller ( ˚Astr¨om & H¨agglund, 1995) with unknown parame-
ters. The policy we obtain can successfully complete a lap
of the race, and the use of the neural oracle is key to do-
ing so. Our results also suggest that a well-designed sketch
can serve as a regularizer. Due to constraints imposed by
the sketch, the policies for TORCS that NDPS learns lead
to smoother trajectories than the corresponding neural poli-
cies, and can tolerate greater noise. The policies are also
more easily transferred to new domains, in particular race
tracks not seen during training. Finally, we show, using sev-
eral properties, that the programmatic policies that we dis-
cover are amenable to veriﬁcation using off-the-shelf sym-
bolic techniques.

2. Programmatically Interpretable

Reinforcement Learning

In this section, we formalize the problem of programmati-
cally interpretable reinforcement learning (PIRL).

We model a reinforcement learning setting as a Partially
Observable Markov Decision Process (POMDP) M =
(S, A, O, T (·|s, a), Z(·|s), r, Init , γ). Here, S is the set of
(environment) states. A is the set of actions that the learn-
ing agent can perform, and O is the set of observations
about the current state that the agent can make. An agent ac-
tion a at the state s causes the environment state to change
probabilistically, and the destination state follows the dis-
tribution T (·|s, a). The probability that the agent makes
an observation o at state s is Z(o|s). The reward that the
agent receives on performing action a in state s is given
by r(s, a). Init is the initial distribution over environment
states. Finally, 0 < γ < 1 is a real constant that is used to
deﬁne the agent’s aggregate reward over time.

A history of M is a sequence h = o0, a0, . . . , ak−1, ok,
where oi and ai are, respectively, the agent’s observation
and action at the i-th time step. Let HM be the set of his-
tories in M . A policy is a function π : HM → A that
maps each history as above to an action ak. For each pol-

icy, we can deﬁne a set of histories that are possible when
the agent follows π. We assume a mechanism to simulate
the POMDP and sample histories that are possible under a
policy. The policy also induces a distribution over possi-
ble rewards Ri that the agent receives at the i-th time step.
The agent’s expected aggregate reward under π is given by
i=0 γiRi]. The goal in reinforcement learn-
R(π) = E[P
ing is to discover a policy π∗ that maximizes R(π).

∞

A Programming Language for Policies. The distinctive
feature of PIRL is that policies here are expressed in a high-
level, domain-speciﬁc programming language. Such a lan-
guage can be deﬁned in many ways. However, to facilitate
search through the space of programs expressible in the lan-
guage, it is desirable for the language to express computa-
tions as compactly and canonically as possible. Because of
this, we propose to express parameterized policies using a
functional language based on a small number of side-effect-
free combinators. It is known from prior work on program
synthesis (Feser et al., 2015) that such languages offer nat-
ural advantages in program synthesis.

We collectively refer to observations and actions, as well as
auxiliary integers and reals generated during computation,
as atoms. Our language considers two kinds of data: atoms
and sequences of atoms (including histories). We assume a
ﬁnite set of basic operators over atoms that is rich enough
to capture all common operations on observations and ac-
tions.

Figure 1 shows the syntax of this language. The nontermi-
nals E and x represent expressions that evaluate to atoms
and histories, respectively. We sketch the semantics of the
various language constructs below.

• c ranges over a universe of numerical constants, and

⊕ is a basic operator;

• peek (x, i) returns the observation from the i-th time
step from a history x, and peek (x, −1) is used as
shorthand for the most recent observation;

• fold is a standard higher-order combinators over se-

quences with the semantics:
fold(f, [e1, . . . , ek], e) = f (ek, f (ek−1, ...f (e1, e)))

• x, x1, x2 are variables. As usual, unbound variables

are assumed to be inputs.

The language comes with a type system that distinguishes
between different types of atoms, and ensures that language
constructs are used consistently. The type system can catch
common errors, such as applying peek (x, k + 1) to a
history of size k. This type system identiﬁes a set of ex-
pressions whose inputs are histories and outputs are actions.

Programmatically Interpretable Reinforcement Learning

E ::= c | x | ⊕(E1, . . . , Ek) | peek (x, i) |

fold ((λx1, x2. E1), α)

sketch:

Figure1. Syntax of the policy language.

These expressions are known as programmatic policies, or
simply programs.

The combinator over sequences, fold, will be operating
over histories in our programs. Since histories can be of
variable lengths, we restrict these combinators to operate
on only the last n elements of a sequence, for some ﬁxed n.
This restriction provides us the ability to use these combi-
nators in a consistent manner.

Sketches. Discovering an optimal programmatic policy
from the vast space of legitimate programs is typically im-
practical without some prior on the shape of target poli-
cies. PIRL allows the speciﬁcation of such priors through
instance-speciﬁc syntactic models called sketches.

We deﬁne a sketch as a grammar of expressions over atoms
and sequences of atoms. The sketch places restrictions on
the kinds of basic operators that will be considered during
policy search. Formally, the sketch is obtained by restrict-
ing the grammar in Figure 1. The set of programs permitted
by a sketch S is denoted by [[S]].

PIRL. The PIRL problem can now be stated as follows.
Suppose we are given a POMDP M and a sketch S. Our
goal is to ﬁnd a program e∗ ∈ [[S]] with optimal reward:

e∗ = arg max

e∈[[S]]

R(e).

(1)

P ::= peek((ǫ − hi), −1)
::= fold(+, ǫ − hi)
I
D ::= peek(hi, −2) − peek(hi, −1)
C ::= c1 ∗ P + c2 ∗ I + c3 ∗ D
B ::= c0 + c1 ∗ peek(h1, −1) + . . .

· · · + ck ∗ peek(hm, −1) > 0 |
B1 or B2 | B1 and B2
E ::= C | if B then E1 else E2.

Here, E represents programs permitted by the sketch. The
program’s input is a history h. We assume that this
sequence is split into a set of sequences {h1, . . . , hm},
where hi is the sequence of observations from the i-th
of m sensors. The sensor’s most recent reading is given
by peek(hk, −1), and its second most recent reading is
peek(hk, −2). The operators +, −, ∗, >, and if-then-else
are as usual. The program (optionally) evaluates a set of
boolean conditions (B) over the current sensor readings,
then chooses among a set of discretized PID controllers,
represented by C. In the deﬁnition of C, P is the propor-
tional term, I is the discretized integral term (calculated
via a fold), and D is a ﬁnite-difference approximation of
the derivative term, ǫ is a known constant and represents a
ﬁxed target for the controller, (ǫ − hi) performs an element-
wise operation on the sequence hi. The symbols ci are
real-valued parameters. Recall that the fold acts over a
ﬁxed-sized window on the history, and hence can be used
as a discrete approximation of the integral term in a PID
controller.

The program in Figure 2 shows the body of a policy for ac-
celeration that the NDPS algorithm ﬁnds given this sketch
in the TORCS car racing environment. The program’s in-
put consists of histories for 29 sensors; however, only two
of them, TrackPos and RPM, are actually used in the pro-
gram. While the sensor TrackPos (for the position of the
car relative to the track axis) is used to decide which con-
troller to use, only the RPM sensor is needed to calculate the
acceleration.

Example. Now we consider a concrete example of PIRL,
considered in more detail in Section 5.

3. Neurally Directed Program Search

Suppose our goal is to make a (simulated) car complete
laps on a track. We want to do so by learning policies for
tasks like steering and acceleration. Suppose we know that
we could get well-behaved policies by using PID control —
speciﬁcally, by switching back and forth between a set of
PID controllers. However, we do not know the parameters
of these controllers, and neither do we know the conditions
under which we should switch from one controller to an-
other. We can express this knowledge using the following

Imitating a Neural Policy Oracle. The NDPS algorithm
is a direct policy search that is guided by a neural “oracle”.
Searching over policies is a standard approach in reinforce-
ment learning. However, the nonsmoothness of the space
of programmatic policies poses a fundamental challenge to
the use of such an approach in PIRL. For example, a con-
ceivable way of solving the search problem would be to
deﬁne a neighborhood relation over programs and perform
local search. However, in practice, the objective R(e) of

Programmatically Interpretable Reinforcement Learning

if (0.001 − peek(hTrackPos, −1) > 0) and (0.001 + peek(hTrackPos, −1) > 0)

then 3.97 ∗ peek((0.44 − hRPM), −1) + 0.01 ∗ fold(+, (0.44 − hRPM)) + 48.79 ∗ (peek(hRPM, −2) − peek(hRPM, −1))
else 3.97 ∗ peek((0.40 − hRPM), −1) + 0.01 ∗ fold(+, (0.40 − hRPM)) + 48.79 ∗ (peek(hRPM, −2) − peek(hRPM, −1))

Figure2. A programmatic policy for acceleration, automatically discovered by the NDPS algorithm. hRPM and hTrackPos represent histories
for the RPM and TrackPos sensors, respectively.

such a search can vary irregularly, leading to poor perfor-
mance (see Section 5 for experimental results on this).

In contrast, NDPS starts by using DRL to compute a neural
policy oracle eN for the given environment. This policy is
an approximation of the programmatic policy that we seek
to ﬁnd. To a ﬁrst approximation, NDPS is a local search
over programmatic policies that seeks to ﬁnd a program e∗
that closely imitates the behavior of eN . The main intuition
here is that distance from eN is a simpler objective than
the reward function R(e), which aggregates rewards over
a lengthy time horizon. This approach can be seen to be a
form of imitation learning (Schaal, 1999).
The distance between eN and the estimate e of e∗ in a
search iteration is deﬁned as d(eN , e) = Ph∈Hke(h) −
eN (h)k, where H is a set of “interesting” inputs (histories)
and k·k is a suitable norm. During the iteration, we search
the neighborhood of e for a program e′ that minimizes this
distance. At the end of the iteration, e′ becomes the new
estimate for e∗.

Input Augmentation. One challenge in the algorithm is
that under the policy e, the agent may encounter histories
that are not possible under eN , or any of the programs en-
countered in previous iterations of the search. For example,
while searching for a steering controller, we may arrive at
a program that, under certain conditions, steers the car into
a wall, an illegal behavior that the neural policy does not
exhibit. Such histories would be irrelevant to the distance
between eN and e if the set H were constructed ahead of
time by simulating eN , and never updated. This would be
unfortunate as these are precisely the inputs on which the
programmatic policy needs guidance.

Our solution to this problem is input augmentation, or pe-
riodic updates to the set H. More precisely, after a certain
number of search steps for a ﬁxed set H, and after choosing
the best available synthesized program for this set, we sam-
ple a set of additional histories by simulating the current
programmatic policy, and add these samples to H.

3.1. Algorithm Details

We show pseudocode for NDPS in Algorithm 1. The inputs
to the algorithm are a POMDP M , a neural policy eN for

Algorithm 1 Neurally Directed Program Search

Input: POMDP M , neural policy eN , sketch S
H ← create histories(eN , M )
e ← initialize(eN , H, M, S)
R ← collect reward(e, M )
repeat

(e′, R′) ← (e, R)
H ← update histories(e, eN , M, H)
E ← neighborhood pool(e)
e ← arg mine′∈E Ph∈Hke′(h) − eN (h)k
R ← collect reward(e, M )

until R′ ≥ R
Output: e′

M that serves as an oracle, and a sketch S. The algorithm
ﬁrst samples a set of histories of eN using the procedure
create histories. Next it uses the routine initialize
to generate the program that is the starting point of the
policy search. Then the procedure collect reward cal-
culates the expected aggregate reward R(e) (described in
Section 2), by simulating the program in the POMDP.

From this point on, NDPS iteratively updates its estimate e
of the target program, as well as its estimate H of the set of
interesting inputs used for distance computation. To do the
former, NDPS uses the procedure neighborhood pool to
generate a space of programs that are structurally similar
to e, then ﬁnds the program in this space that minimizes
distance from eN . The latter task is done by the routine
update histories, which heuristically picks interesting
inputs in the trajectory of the learned program and then ob-
tains the corresponding actions from the oracle for those
inputs. This process goes on until the iterative search fails
to improve the estimated reward R of e.

The subroutines used in the above description can be imple-
mented in many ways. Now we elaborate on our implemen-
tation of the important subroutines of NDPS.

The optimization step. The search for a program e′ at
minimal distance from the neural oracle can be imple-
mented in many ways. The approach we use has two steps.
First, we enumerate a set of program templates — numer-
ically parameterized programs — that are structurally sim-

Programmatically Interpretable Reinforcement Learning

ilar to e and are permitted by the sketch S, giving prior-
ity to shorter templates. Next, we ﬁnd optimal parameters
for the enumerated templates. Our primary tool for the
second step is Bayesian optimization (Snoek et al., 2012),
though we also explored a symbolic optimization technique
based on Satisﬁability Modulo Theories (SMT) solving
(Appendix B).

The initialization step. The performance of NDPS turns
out to be quite sensitive to the choice of the program that
is the starting point of the search. Our initialization routine
initialize is broadly similar to the optimization step, in
that it attempts to ﬁnd programs that closely imitate the or-
acle through a combination of template enumeration and
parameter optimization. However, rather than settling on a
single program, initialize generates a pool of programs
that are close in behavior to the oracle. After this, it simu-
lates the programs in the POMDP and returns the program
that achieves the highest reward.

4. Environments for Experiments

In this section, we describe the environments (modeled by
POMDPs) on which we evaluated the NDPS algorithm.

TORCS. We use NDPS to generate controllers for cars in
The Open Racing Car Simulator (TORCS) (Wymann et al.,
2014). TORCS has been used extensively in AI research,
for example in (Salem et al., 2017), (Koutn´ık et al., 2013),
and (Loiacono et al., 2010) among others. (Lillicrap et al.,
2015a) has shown that a Deep Deterministic Policy Gradi-
ent (DDPG) network can be used in RL environments with
continuous action spaces. The DRL agents for TORCS in
this paper implement this approach.

In its full generality TORCS provides a rich environment
with input from up to 89 sensors, and optionally the 3D
graphic from a chosen camera angle in the race. The con-
trollers have to decide the values of 5 parameters during
game play, which correspond to the acceleration, brake,
clutch, gear and steering of the car. Apart from the immedi-
ate challenge of driving the car on the track, controllers also
have to make race-level strategy decisions, like making pit-
stops for fuel. A lower level of complexity is provided in
the Practice Mode setting of TORCS. In this mode all race-
level strategies are removed. Currently, so far as we know,
state-of-the-art DRL models are capable of racing only in
Practice Mode, and this is also the environment that we use.
Here we consider the input from 29 sensors, and decide val-
ues for the acceleration and steering actions.

The sketches used in our experiments are as in the ex-
ample in Section 2, and provide the basic structure of
a proportional-integral-derivative (PID) program, with ap-
propriate holes for parameter and observation values. To

obtain a practical implementation, we constrain the fold
calculation to the ﬁve latest observations of the history.
This constraint corresponds to the standard strategy of au-
tomatic (integral) error reset in discretized PID controllers
(Astrom & Hagglund, 1984).

Each track in TORCS can we viewed as a distinct POMDP.
In our implementation of NDPS for TORCS we choose one
track and synthesize a program for it. Whenever the al-
gorithm needs to interact with the POMDP, we use the pro-
gram or DRL agent to race on the track. For example, in the
procedure collect reward we use the synthesized pro-
gram to race one lap, and the reward is a function of the
speed, angle and position of the car at each time step.

For the create histories procedure we use the DRL
agent to complete one lap of the track (an episode), record-
ing the sensor values and environment state at each time
step. The update histories procedure uses a two step
process. First, the synthesized program is used to race one
lap and we store the sequence of observations (given by sen-
sor values) o1, o2, . . . provided by TORCS during this lap.
Then, we use the DRL agent to generate the corresponding
action ai for each observation oi. Each tuple (oi, ai) is then
added to the set of histories.

Classic Control Games.
In addition to TORCS, we eval-
uated our approach in three classic control games, Acrobot,
CartPole, and MountainCar. These games provide simpler
RL environments, with fewer input sensors than TORCS
and only a single discrete action at each time step, com-
pared to two continuous actions in TORCS. These results
appear in Appendix A.

5. Experimental Analysis

Now we present an empirical evaluation of the effective-
ness of our algorithm in solving the PIRL problem. We
synthesize programs for two TORCS tracks, CG-Speedway-
1 and Aalborg. These tracks provide varying levels of dif-
ﬁculty, with Aalborg being the more difﬁcult track of the
two.

5.1. Evaluating Performance

A controller’s performance is measured according to two
metrics, lap time and reward. To calculate the lap time, the
programs are allowed to complete a three lap race, and we
report the average time taken to complete a lap during this
race. The reward function is calculated using the car’s ve-
locity, angle with the track axis, and distance from the track
axis. The same function is used to train the DRL agent ini-
tially. In the experiments we compare the average reward
per time step, obtained by the various programs.

We compare among the following RL agents:

Programmatically Interpretable Reinforcement Learning

A1: DRL. An agent which uses DRL to ﬁnd a policy rep-
resented as a deep neural network. The speciﬁc DRL
algorithm we use is Deep Deterministic Policy Gra-
dients (Lillicrap et al., 2015b), which has previously
been used on TORCS.

A2: Naive. Program synthesized without access to a policy

oracle.

A3: NoAug. Program synthesized without input augmenta-

tion.

A4: NoSketch. Program synthesized in our policy lan-

guage without sketch guidance.

A5: NoIF. Programs permitted by a restriction of our
sketch that does not permit conditional branching.

A6: NDPS. The Program generated by the NDPS algo-

rithm.

In Table 1 we present the performance results of the above
list. The lap times in that table are given in minutes and
seconds. The TIMEOUT entries indicate that the synthesis
process did not return a program that could complete the
race, within the speciﬁed timeout of twelve hours.

These results justify the various choices that we made in
our NDPS algorithm architecture, as discussed in Section 3.
In many cases those choices were necessary to be able to
synthesize a program that could successfully complete a
race. As a consequence of these results, we only consider
the DRL agent and the NDPS program for subsequent com-
parisons.

The NoAug and NoSketch agents are unable to generate pro-
grams that complete a single lap on either track. In the case
of NoSketch this is because the syntax of the policy lan-
guage (Figure 1), deﬁnes a very large program space. If we
randomly sample from this space without any constraints
(like those provided by the sketch), then the probability of
getting a good program is extremely low and hence we are
unable to reliably generate a program that can complete a
lap. The NoAug agent performs poorly because without in-
put augmentation, the synthesizer has no guidance from the
oracle regarding the “correct” behavior once the program
deviates even slightly from the oracle’s trajectory.

The NDPS algorithm is biased towards generating simpler
programs to aid in interpretability. In the NDPS algorithm
experiments we allow the synthesizer to produce policies
with up to ﬁve nested if statements. However, if two poli-
cies have LAP TIMES within one second of each other, then
the algorithm chooses the one with fewer if statements as
the output. This is a reasonable choice because a differ-
ence of less than one second in LAP TIMES can be the re-
sult of different starting positions in the TORCS simulator,

and hence the performance of such policies is essentially
equivalent.

Table1. Performance results in TORCS. Lap time is given in Min-
utes:Seconds. Timeout indicates that the synthesizer did not re-
turn a program that completed the race within the speciﬁed time-
out.

MODEL

CG-SPEEDWAY-1

AALBORG

LAP TIME

REWARD

LAP TIME

REWARD

DRL
Naive
NoAug
NoSketch
NoIF
NDPS

54.27
2:07.09
TIMEOUT
TIMEOUT
1:01.60
1:01.56

118.39
58.72
−
−
115.25
115.32

1:49.66
TIMEOUT
TIMEOUT
TIMEOUT
2:45.13
2:38.87

71.23
−
−
−
52.81
54.91

5.2. Qualitative Analysis of the Programmatic Policy

We provide qualitative analysis of the inferred program-
matic policy through the lens of interpretability, and its be-
havior in acting in the environment.

Interpretability.
Interpretability is a qualitative metric,
and cannot be easily demonstrated via experiments. The
DRL policies are considered uninterpretable because their
policies are encoded in black box neural networks. In con-
trast, the PIRL policies are compact and human-readable
by construction, as exempliﬁed by the acceleration policy
in Figure 2. More examples of our synthesized policies are
given in Appendix C.

Behavior of Policy. Our experimental validation showed
that the programmatic policy was less aggressive in terms
of its use of actions and resulting in smoother steering ac-
tions. Numerically, we measure smoothness in Table 2 by
comparing the population standard deviation of the set of
steering actions taken by the program during the entire race.
In Figure 3 we present a scatter plot of the steering actions
taken by the DRL agent and the NDPS program during a
slice of the CG-Speedway-1 race. As we can see, the NDPS
program takes much more conservative actions.

Table2. Smoothness measure of agents in TORCS, given by the
standard deviation of the steering actions during a complete race.
Lower values indicate smoother steering.

MODEL

CG-SPEEDWAY-1 AALBORG

DRL
NDPS

0.5981
0.1312

0.9008
0.2483

Programmatically Interpretable Reinforcement Learning

n
o
i
t
c
A
g
n
i
r
e
e
t
S

1.00

0.75

0.50

0.25

0.00

− 0.25

− 0.50

− 0.75

− 1.00

DRL
NDPS

1500

2000

2500

3000

Distance Raced

8000

7000

6000

5000

4000

3000

2000

1000

0

d
e
c
a
R
e
c
n
a
t
s
i
D

NDPS TrackPos Block
NDPS RPM Block
NDPS Both Block
DRL  TrackPos Block
DRL  RPM Block
DRL Both Block

Figure3. Slice of steering actions taken by the DRL and NDPS
agents, during the CG-Speedway-1 race. This ﬁgure demonstrates
that the NDPS agent drives more smoothly.

0.1

0.2

0.3

0.4

0.5

0.6
Block Probability

0.7

0.8

0.9

5.3. Robustness to Missing/Noisy Features

To evaluate the robustness of the agents with respect to de-
fective sensors we introduce a Partial Observability variant
of TORCS. In this variant, a random sample of j sensors are
declared defective. During the race, one or more of these
defective sensors are blocked with some ﬁxed probability.
Hence, during game-play, the sensor either returns the cor-
rect reading or a null reading. For sufﬁciently high block
probabilities, both agents will fail to complete the race. In
Table 3 we show the distances raced for two values of the
block probability, and in Figure 4 we plot the distance raced
as we increase the block probability on the Aalborg track.
In both these experiments, the set of defective sensors was
taken to be {RPM, TrackPos} because we know that the
synthesized programs crucially depend on these sensors.

Table3. Partial observability results in TORCS blocking sensors
{RPM, TrackPos} . For each track and block probability we give
the distance, in meters, raced by the program before crashing.

MODEL

CG-SPEEDWAY-1
50%

90%

AALBORG
50% 90%

DRL
NDPS

21
1976

17
200

71
1477

20
287

5.4. Evaluating Generalization to New Instances

To compare the ability of the agents to perform on unseen
tracks, we executed the learned policies on tracks of com-
parable difﬁculty. For agents trained on the CG-Speedway-
1 track, we chose CG track 2 and E-Road as the transfer
tracks, and for Aalborg trained tracks we chose Alpine 2
and Ruudskogen. As can be seen in Tables 4 and 5, the
NDPS programmatically synthesized program far outper-
forms the DRL agent on unseen tracks. The DRL agent is
unable to complete the race on any of these transfer tracks.
This demonstrates the transferability of the policies NDPS

Figure4. Distance raced by the agents as the block probability in-
creases for a particular sensor(s) on Aalborg. The NDPS agent is
more robust to blocked sensors.

ﬁnds.

Table4. Transfer results with training on CG-Speedway-1. ‘Cr’
indicates that the agent crashed after racing the speciﬁed distance.

MODEL

CG TRACK 2

E-ROAD

LAP TIME

REWARD

LAP TIME

REWARD

DRL
NDPS

CR 1608M
1:40.57

−
110.18

CR 1902M
1:51.59

−
98.21

Table5. Transfer results with training on Aalborg. ‘Cr’ denotes
the agent crashed, after racing the speciﬁed distance.

MODEL

ALPINE 2

RUUDSKOGEN

LAP TIME

REWARD

LAP TIME

REWARD

DRL
NDPS

CR 1688M
3:16.68

−
67.49

CR 3232M
3:19.77

−
57.69

5.5. Veriﬁability of Policies

Now we use established symbolic veriﬁcation techniques to
automatically prove two properties of policies generated by
NDPS. So far as we know, the current state of the art neural
network veriﬁers cannot verify the DRL network we are
using in a reasonable amount of time, due to the size and
complexity of the network used to implement the DDPG
algorithm. For example, the Reluplex (Katz et al., 2017)
algorithm was tested on networks at most 300 nodes wide,
whereas our network has three layers with 600 nodes each,
and other smaller layers.

Smoothness Property For the program given in Fig-
k+5
i=k kpeek(hRPM, i +
ure 2 we proved, we have ∀k, P

 
 
Programmatically Interpretable Reinforcement Learning

1) − peek(hRPM, i)k < 0.006 =⇒ kpeek(hAccel, k +
1) − peek(hAccel, k)k < 0.49.
Intuitively, the above
logical implication means that if the sum of the con-
secutive differences of the last six RPM sensor values
is less than 0.006,
then the acceleration actions calcu-
lated at the last and penultimate step will not differ by
more than 0.49. Similarly, for a policy given in Ap-
k+5
i=k kpeek(hTrackPos, i + 1) −
pendix C, we prove ∀k, P
peek(hTrackPos, i)k < 0.006 =⇒ kpeek(hSteer, k+1)−
peek(hSteer, k)k < 0.11. This proof gives us a guarantee
of the type of smooth steering behavior that we empirically
examined earlier in this section.

can

that

prove

Universal Bounds We
the pro-
gram in Figure 2 satisﬁes the property ∀i
(0 ≤
peek(hRPM, i) ≤ 1 ∧ −1 ≤ peek(hTrackPos, i) ≤
1) =⇒ (kpeek(hSteer, i)k < 101.08 ∧ −54.53 <
peek(hAccel, i) < 53.03).
Intuitively, this means that
we have proved global bounds for the action values in
this environment, assuming reasonable bounds on some
of the input values.
In the TORCS environment these
bounds are not very useful, since the simulator clips these
actions to certain pre-speciﬁed ranges. However,
this
experiment demonstrates that our framework allows us to
prove universal bounds on the actions, and this could be a
critical property for other environments.

6. Related Work

Syntax-Guided Synthesis. The original formulation of
inductive program synthesis is to search for a program in
a hypothesis space (programming language) that is con-
sistent with a speciﬁcation (such as IO examples). How-
ever, this search is often intractable because of the large
(potentially inﬁnite) hypothesis space. One of the key
ideas to make this search tractable is to provide the syn-
thesizer a sketch of the desired program in addition to
the examples, for example in (Solar-Lezama, 2009) and
(Feser et al., 2015). The program sketch in addition to pro-
viding structure to the search space also allows users to
provide additional insights. This approach has been gen-
eralized in a framework called Syntax-Guided Synthesis
(SYGUS) (Alur et al., 2015). Our PIRL approach is inspired
by SYGUS in the sense that we also use a high-level gram-
mar to constrain the shape of the possible learnt policies in
a policy language grammar. However, unlike SYGUS and
previous sketch-based synthesis approaches that use logical
constraints as speciﬁcation, PIRL searches for policies with
quantitative objectives.

Imitation Learning.
Imitation learning (Schaal, 1999)
has been a successful paradigm for reducing the sample
complexity of reinforcement learning algorithms by al-
lowing the agent to leverage the additional supervision

provided in terms of expert demonstrations for the de-
sired behaviors. The DAGGER (Dataset Aggregation) al-
gorithm (Ross et al., 2011) is an iterative algorithm for imi-
tation learning that learns stationary deterministic policies,
where in each iteration i it uses the current learnt policy πi
to collect new trajectories and adds them to the dataset D
of all previously found trajectories. The policy for the next
iteration πi+1 is a policy that best mimics the expert pol-
icy π∗ on the whole dataset D. Our Neurally Directed Pro-
gram Search (NDPS) is inspired by the DAGGER algorithm,
where we use the trained DeepRL agent as the expert (or-
acle), and iteratively perform IO augmentation for unseen
input states explored by our synthesized policy with the cur-
rent best reward. However, one key difference is that NDPS
uses the expert trajectories to only guide the local program
search in our policy language grammar to ﬁnd a policy with
highest rewards, unlike the imitation learning setting where
the goal is to match the expert demonstrations perfectly.

Neural Program Synthesis and Induction. Many re-
cent efforts use neural networks for learning programs.
In neural program in-
These efforts have two ﬂavors.
duction, the goal is to learn a network that encodes the
program semantics using internal weights. These archi-
tectures typically augment neural networks with differ-
entiable computational substrates such as memory (Neu-
ral Turing Machines (Graves et al., 2014)), modules (Neu-
ral RAM (Kurach et al., 2015)) or data-structures such as
stacks (Joulin & Mikolov, 2015), and formulate the pro-
gram learning problem in an end-to-end differentiable man-
ner. In neural program synthesis, the architectures gener-
ate programs directly as outputs using multi-task transfer
learning (e.g. ROBUSTFILL (Devlin et al., 2017), DEEP-
CODER (Balog et al., 2016), BAYOU (Murali et al., 2018)),
where the network weights are used to guide the pro-
gram search in a DSL. There have also been some re-
cent approaches to use RL for learning to search programs
in DSLs (Bunel et al., 2018; Abolaﬁa et al., 2018). Our
approach falls in the category of program synthesis ap-
proaches where we synthesize policies in a policy language.
However, we learn richer policy programs with continuous
parameters using the NDPS algorithm.

Interpretable Machine Learning. Many recent ef-
forts in deep learning aim to make deep networks
more interpretable (Montavon et al., 2017; Lipton, 2016;
Garnelo et al., 2016; Zahavy et al., 2016; Shanahan, 2005;
Lake et al., 2016). There are three key approaches explored
for interpreting DNNs: i) generate input prototypes in the
input domain that are representatives of the learned concept
in the abstract domain of the top-level of a DNN, ii) explain-
ing DNN decisions by relevance propagation and comput-
ing corresponding representative concepts in the input do-
main, and iii) Using symbolic techniques to explain and

Programmatically Interpretable Reinforcement Learning

interpret a DNN. Our work differs from these approaches
in that we are replacing the DRL model with human read-
able source code, that is programmatically synthesized to
mimic the policy found by the neural network. Working
at this level of abstraction provides a method to apply ex-
isting synthesis techniques to the problem of making DRL
models interpretable.

Veriﬁcation
of Deep Neural Networks. Relu-
plex (Katz et al., 2017) is an SMT solver that supports
linear real arithmetic with ReLU constraints, and has been
used to verify several properties of DNN-based airborne
collision avoidance systems, such as not producing er-
roneous alerts and uniformity of alert regions. Unlike
Reluplex, our framework generates interpretable program
source code as output, where we can use traditional
symbolic program veriﬁcation techniques (King, 1976) to
prove program properties.

7. Conclusion

We have introduced a framework for interpretable rein-
forcement learning, called PIRL. Here, policies are repre-
sented in a high-level language. The goal is to ﬁnd a policy
that ﬁts a syntactic “sketch” and also has optimal long-term
reward. We have given an algorithm inspired by imitation
learning, called NDPS, to achieve this goal. Our results
show that the method is able to generate interpretable poli-
cies that clear reasonable performance goals, are amenable
to symbolic veriﬁcation, and, assuming a well-designed
sketch, are robust and easily transferred to unseen environ-
ments.

The experiments in this paper only considered environ-
ments with symbolic inputs. Handling perceptual inputs
may raise additional algorithmic challenges, and is a natu-
ral next step. Also, in this paper, we only considered de-
terministic (if memoryful) policies. Extending our frame-
work to stochastic policies is a goal for future work. Fi-
nally, while we explored policies in the context of rein-
forcement learning, one could deﬁne similar frameworks
for other learning settings.

Acknowledgements

This research was partially supported by NSF Award CCF-
1162076 and DARPA MUSE Award #FA8750-14-2-0270.

References

Abolaﬁa, D. A., Norouzi, M., and Le, Q. V. Neural
program synthesis with priority queue training. CoRR,
abs/1801.03526, 2018.

Alur, R., Bod´ık, R., Dallal, E., Fisman, D., Garg, P., Ju-

niwal, G., Kress-Gazit, H., Madhusudan, P., Martin, M.
M. K., Raghothaman, M., Saha, S., Seshia, S. A., Singh,
R., Solar-Lezama, A., Torlak, E., and Udupa, A. Syntax-
guided synthesis. In Dependable Software Systems Engi-
neering, pp. 1–25. 2015. .

Astrom, K. and Hagglund, T. Automatic tuning of sim-
ple regulators with speciﬁcations on phase and ampli-
tude margins. Automatica, 20(5):645 – 651, 1984. ISSN
0005-1098. .

˚Astr¨om, K. J. and H¨agglund, T. PID controllers: The-
ory, Design, and Tuning. Instrument society of America,
1995.

Balog, M., Gaunt, A. L., Brockschmidt, M., Nowozin, S.,
and Tarlow, D. Deepcoder: Learning to write programs.
CoRR, abs/1611.01989, 2016.

Barto, A. G., Sutton, R. S., and Anderson, C. W. Neuron-
like adaptive elements that can solve difﬁcult learning
control problems. IEEE Transactions on Systems, Man,
and Cybernetics, SMC-13(5):834–846, Sept 1983. ISSN
0018-9472. .

Bunel, R., Hausknecht, M., Devlin, J., Singh, R., and Kohli,
P. Leveraging grammar and reinforcement learning for
neural program synthesis. In ICLR, 2018.

Cadar, C. and Sen, K. Symbolic execution for software test-
ing: three decades later. Communications of the ACM, 56
(2):82–90, 2013.

Devlin, J., Uesato, J., Bhupatiraju, S., Singh, R., Mohamed,
A., and Kohli, P. Robustﬁll: Neural program learning
under noisy I/O. CoRR, abs/1703.07469, 2017.

Feser, J. K., Chaudhuri, S., and Dillig, I. Synthesizing
data structure transformations from input-output exam-
ples. In Proceedings of the 36th ACM SIGPLAN Confer-
ence on Programming Language Design and Implemen-
tation, Portland, OR, USA, June 15-17, 2015, pp. 229–
239, 2015. .

Garnelo, M., Arulkumaran, K., and Shanahan, M. To-
wards deep symbolic reinforcement learning. CoRR,
abs/1609.05518, 2016.

Geramifard, A., Dann, C., Klein, R. H., Dabney, W., and
How, J. P. Rlpy: A value-function-based reinforcement
learning framework for education and research. Journal
of Machine Learning Research, 16:1573–1578, 2015.

Graves, A., Wayne, G., and Danihelka, I. Neural turing

machines. CoRR, abs/1410.5401, 2014.

Joulin, A. and Mikolov, T. Inferring algorithmic patterns
In Advances in

with stack-augmented recurrent nets.

Programmatically Interpretable Reinforcement Learning

Neural Information Processing Systems 28: Annual Con-
ference on Neural Information Processing Systems 2015,
December 7-12, 2015, Montreal, Quebec, Canada, pp.
190–198, 2015.

Katz, G., Barrett, C. W., Dill, D. L., Julian, K., and Kochen-
derfer, M. J. Reluplex: An efﬁcient smt solver for veri-
fying deep neural networks. In Computer Aided Veriﬁca-
tion, pp. 97–117, 2017.

King, J. C. Symbolic execution and program testing. Com-

munications of the ACM, 19(7):385–394, 1976.

Koutn´ık, J., Cuccu, G., Schmidhuber, J., and Gomez, F. J.
Evolving large-scale neural networks for vision-based
TORCS. In Proceedings of the 8th International Confer-
ence on the Foundations of Digital Games, FDG 2013,
Chania, Crete, Greece, May 14-17, 2013., pp. 206–212,
2013.

Kurach, K., Andrychowicz, M., and Sutskever, I. Neural
random-access machines. CoRR, abs/1511.06392, 2015.

state-spaces. In Proceedings of the Eighth International
Conference on Machine Learning. Morgan Kaufmann,
January 1991.

Murali, V., Chaudhuri, S., and Jermaine, C. Neural sketch
In ICLR,

learning for conditional program generation.
2018.

Ross, S., Gordon, G. J., and Bagnell, D. A reduction of
imitation learning and structured prediction to no-regret
online learning. In Proceedings of the Fourteenth Inter-
national Conference on Artiﬁcial Intelligence and Statis-
tics, AISTATS 2011, Fort Lauderdale, USA, April 11-13,
2011, pp. 627–635, 2011.

Salem, M., Mora, A. M., Merelo, J. J., and Garc´ıa-S´anchez,
P. Driving in TORCS using modular fuzzy controllers.
In Applications of Evolutionary Computation - 20th Eu-
ropean Conference, EvoApplications 2017, Amsterdam,
The Netherlands, April 19-21, 2017, Proceedings, Part I,
pp. 361–376, 2017.

Lake, B. M., Ullman, T. D., Tenenbaum, J. B., and Gersh-
man, S. J. Building machines that learn and think like
people. CoRR, abs/1604.00289, 2016.

Schaal, S.
robots?
1999.

Is imitation learning the route to humanoid
Trends in cognitive sciences, 3(6):233–242,

Lillicrap, T. P., Hunt, J. J., Pritzel, A., Heess, N., Erez,
T., Tassa, Y., Silver, D., and Wierstra, D. Continu-
ous control with deep reinforcement learning. CoRR,
abs/1509.02971, 2015a.

Lillicrap, T. P., Hunt, J. J., Pritzel, A., Heess, N., Erez, T.,
Tassa, Y., Silver, D., and Wierstra, D. Continuous con-
trol with deep reinforcement learning. arXiv preprint
arXiv:1509.02971, 2015b.

Lipton, Z. C. The mythos of model interpretability. CoRR,

abs/1606.03490, 2016.

Loiacono, D., Prete, A., Lanzi, P. L., and Cardamone, L.
Learning to overtake in TORCS using simple reinforce-
In Proceedings of the IEEE Congress
ment learning.
on Evolutionary Computation, CEC 2010, Barcelona,
Spain, 18-23 July 2010, pp. 1–8, 2010. .

Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Ve-
ness, J., Bellemare, M. G., Graves, A., Riedmiller, M.,
Fidjeland, A. K., Ostrovski, G., et al. Human-level con-
trol through deep reinforcement learning. Nature, 518
(7540):529, 2015.

Montavon, G., Samek, W., and M¨uller, K. Methods for
interpreting and understanding deep neural networks.
CoRR, abs/1706.07979, 2017.

Moore, A. Variable resolution dynamic programming: Ef-
ﬁciently learning action maps in multivariate real-valued

Shanahan, M. Perception as abduction: Turning sensor data
into meaningful representation. Cognitive Science, 29
(1):103–134, 2005. ISSN 1551-6709. .

Silver, D., Huang, A., Maddison, C. J., Guez, A., Sifre, L.,
van den Driessche, G., Schrittwieser, J., Antonoglou, I.,
Panneershelvam, V., Lanctot, M., Dieleman, S., Grewe,
D., Nham, J., Kalchbrenner, N., Sutskever, I., Lillicrap,
T. P., Leach, M., Kavukcuoglu, K., Graepel, T., and Has-
sabis, D. Mastering the game of Go with deep neural
networks and tree search. Nature, 529(7587):484–489,
2016.

Silver, D., Hubert, T., Schrittwieser, J., Antonoglou, I., Lai,
M., Guez, A., Lanctot, M., Sifre, L., Kumaran, D., Grae-
pel, T., et al. Mastering chess and Shogi by self-play
with a general reinforcement learning algorithm. arXiv
preprint arXiv:1712.01815, 2017.

Snoek, J., Larochelle, H., and Adams, R. P. Practical
bayesian optimization of machine learning algorithms.
In Proceedings of the 25th International Conference
on Neural Information Processing Systems - Volume 2,
NIPS’12, pp. 2951–2959, USA, 2012. Curran Associates
Inc.

Solar-Lezama, A. The sketching approach to program syn-
In Programming Languages and Systems, 7th
thesis.
Asian Symposium, APLAS 2009, Seoul, Korea, Decem-
ber 14-16, 2009. Proceedings, pp. 4–13, 2009. .

Programmatically Interpretable Reinforcement Learning

Wang, Z., de Freitas, N., and Lanctot, M.

Du-
eling network architectures for deep reinforcement
CoRR, abs/1511.06581, 2015.
learning.
URL
http://arxiv.org/abs/1511.06581.

Wymann, B., Espi´e, E., Guionneau, C., Dimitrakakis, C.,
Coulom, R., and Sumner, A. TORCS, The Open Racing
Car Simulator. http://www.torcs.org, 2014.

Zahavy, T., Ben-Zrihem, N., and Mannor, S. Graying the
black box: Understanding dqns. CoRR, abs/1602.02658,
2016.

Appendix: Programmatically Interpretable Reinforcement Learning

A. Evaluation on Classic Control Games

In this section, we provide results of additional experimen-
tal evaluation on some classic control games. We use the
OpenAI Gym environment implementation of these games.
A brief description of these games is given below.

We used the DUEL-DDQN algorithm (Wang et al., 2015)
to obtain our neural policy oracle for these games, rather
than DDPG, as an implementation of Duel-DDQN already
appears on the OpenAI Gym leader-board.

Table6. Rewards achieved in Classic Control Games. Acrobot
does not have threshold at which it is considered solved.

ACROBOT

CARTPOLE MOUNTAINCAR

SOLVED
DRL
NDPS-SMT
NDPS-BOPT
MINIMUM

−
-63.17
-84.16
-127.21
-200

195
197.53
183.15
143.21
8

-110
-84.73
-108.06
-143.86
-200

Acrobot. This environment consists of a two link, two
joint robot. The joint between the links is actuated. At the
start of the episode, the links are hanging downwards. At
every timestep the agent chooses an action that correspond
to applying a force to move the actuated link to the right, to
the left, or to not applying a force. The episode is over once
the end of the lower link swings above a certain height. The
goal is to end the episode in the fewest possible timesteps.

We use the OpenAI Gym ‘Acrobot-v1’ environment.
This implementation is based on the system presented
in (Geramifard et al., 2015). Each observation is a set con-
sisting of readings from six sensors, corresponding to the
rotational joint angles and velocities of joints and links.
The action space is discrete with three elements, and at each
timestep the environment returns the observation and a re-
ward of −1. An episode is terminated after 200 time steps
irrespective of the state of the robot. This is an unsolved en-
vironment, which means it does not have a speciﬁed reward
threshold at which it’s considered solved.

from the center. At every timestep the agent chooses to ap-
ply a force to move the cart to the right or to the left, and the
goal is to prevent an episode from ending for the maximum
possible timesteps.

We use the OpenAI Gym ‘CartPole-v0’ environment, based
on the system presented in (Barto et al., 1983). The sensor
values correspond to the cart position, cart velocity, pole
angle and pole velocity. The action space is discrete with
two elements, and at each timestep the environment returns
the observation and a reward of +1. An episode is termi-
nated after 200 time steps irrespective of the state of the
cart. CartPole-v0 deﬁnes “solving” as getting an average
reward of at least 195.0 over 100 consecutive trials.

MountainCar. This environment consists of an under-
powered car on a one-dimensional track. At the beginning,
the car is placed between two ‘hills’. The episode ends
when the car reaches the top of the hill in front of it. Since
the car is underpowered, the agent needs to drive it back
and forth to build momentum. At every timestep the agent
chooses to apply a force to move the car to the right, to the
left, or to not apply a force. The goal is to end the episode
in the fewest possible timesteps.

We use the OpenAI Gym ‘MountainCar-v0’ environment.
This implementation is based on the system presented
in (Moore, 1991). The sensors provide the position and
velocity of the car. The action space is discrete with three
elements, and at each timestep the environment returns the
observation and a reward of −1. An episode is terminated
after 200 time steps irrespective of the state of the robot.
MountainCar-v0 is considered “solved” if the average re-
ward over 100 consecutive trials is not less than -110.0.

Results. Table 6 shows rewards obtained by optimal poli-
cies found using various methods in these environments.
The ﬁrst row gives numbers for the DRL method. The rows
NDPS-SMT and NDPS-BOPT for versions of the NDPS al-
gorithm that respectively use SMT-based optimization and
Bayesian optimization to ﬁnd template parameters (more
on this below).

CartPole. This environment consists of a pole attached
by an un-actuated joint to a cart that moves along a friction-
less track. At the beginning, the pole is balanced vertically
on the cart. The episode ends when the pole is more than
15◦ from vertical, or the cart moves more than 2.4 units

B. Additional Details on Algorithm

Now we elaborate on the optimization techniques we used
in the distance computation step arg mine′ Ph∈Hke′(h) −
eN (h)k, to ﬁnd a program similar to a given program e, in
Algorithm 1.

Programmatically Interpretable Reinforcement Learning

0.97 ∗ peek((0.0 − hTrackPos), −1)+ 0.05 ∗ fold(+, (0.0 − hTrackPos))+ 49.98 ∗ (peek(hTrackPos, −2) − peek(hTrackPos, −1))

Figure5. A programmatic policy for steering, automatically discovered by the NDPS algorithm with training on Aalborg.

if (0.0001 − peek(hTrackPos, −1) > 0) and (0.0001 + peek(hTrackPos, −1) > 0)

then 0.95 ∗ peek((0.64 − hRPM), −1) + 5.02 ∗ fold(+, (0.64 − hRPM)) + 43.89 ∗ (peek(hRPM, −2) − peek(hRPM, −1))
else 0.95 ∗ peek((0.60 − hRPM), −1) + 5.02 ∗ fold(+, (0.60 − hRPM)) + 43.89 ∗ (peek(hRPM, −2) − peek(hRPM, −1))

Figure6. A programmatic policy for acceleration, automatically discovered by the NDPS algorithm with training on CG-Speedway-1.

0.86 ∗ peek((0.0 − hTrackPos), −1)+ 0.09 ∗ fold(+, (0.0 − hTrackPos))+ 46.51 ∗ (peek(hTrackPos, −2) − peek(hTrackPos, −1))

Figure7. A programmatic policy for steering, automatically discovered by the NDPS algorithm with training on CG-Speedway-1.

As mentioned in the main paper, we start by enumerating
a list of program templates, or programs with numerical-
valued parameters θ. This is done by ﬁrst replacing the nu-
merical constants in e by parameters, eliding some subex-
pressions from the resulting parameterized program, and
then regenerating the subexpressions using the rules of S
(without instantiating the parameters), giving priority to
shorter expressions. The resulting program template eθ fol-
lows the sketch S and is also structurally close to e. Now
we search for values for parameters θ that optimally imitate
the neural oracle.

Bayesian optimization. We use Bayesian optimization
as our primary tool when searching for such optimal pa-
rameter values. This method applies to problems in which
actions (program outputs) can be represented as vectors of
real numbers. All problems considered in our experiments
fall in this category. The distance of individual pairs of
outputs of the synthesized program and the policy oracle
is then simply the Euclidean distance between them. The
sum of these distances is used to deﬁne the aggregate cost
across all inputs in H. We then use Bayesian optimization
to ﬁnd parameters that minimize this cost.

if (0.1357 + peek(h4, −1)) < 0

then 2
else 0

Figure8. A programmatic policy for Acrobot, automatically dis-
covered by the NDPS algorithm.

if (fold(+, h0) − peek(h3, −1)) > 0

then 0
else 1

Figure9. A programmatic policy for CartPole, automatically dis-
covered by the NDPS algorithm.

if (0.2498 − peek(h0, −1) > 0)

and (0.0035 − peek(h1, −1) < 0)

then 0
else 2

Figure10. A programmatic policy for MountainCar, automati-
cally discovered by the NDPS algorithm.

SMT-based Optimization. We also use a second param-
eter search technique based on SMT (Satisﬁability Modulo
Theories) solving. Here, we generate a constraint that stip-
ulates that for each h ∈ H, the output eθ(h) must match
eN (h) up to a constant error. Here, eN (h) is a constant
value obtained by executing eN . The output eθ(h) depends
on unknown parameters θ; however, constraints over eθ(h)
can be represented as constraints over θ using techniques

for symbolic execution of programs (Cadar & Sen, 2013).
Because the oracle is only an approximation to the optimal
policy in our setting, we do not insist that the generated
constraint is satisﬁed entirely. Instead, we set up a Max-
Sat problem which assigns a weight to the constraint for
each input h, and then solve this problem with a Max-Sat
solver.

Unfortunately, SMT-based optimization does not scale well

Programmatically Interpretable Reinforcement Learning

in environments with continuous actions. Consequently,
we exclusively use Bayesian optimization for all TORCS
based experiments. SMT-based optimization can be used
in the classic control games, however, and Table 6 shows
results generated using this technique (in row NDPS-SMT).

The results in Table 6 show that for the classic control
games, SMT-based optimization gives better results. This
is because the small number of legal actions in these games,
limited to at most three values {0, 1, 2}, are well suited
for the SMT setting. The SMT solver is able to efﬁciently
perform parameter optimization, with a small set of histo-
ries. Whereas, the limited variability in actions forces the
Bayesian optimization method to use a larger set of histo-
ries, and makes it harder for the method to avoid getting
trapped in local minimas.

C. Policy Examples

In this section we present more examples of the policies
found by the NDPS algorithm.

The program in Figure 5 shows the body of a policy for
steering, which together with the acceleration policy given
in the paper (Figure 2), was found by the NDPS algorithm
by training on the Aalborg track. Figures 6 & 7 likewise
show the policies for acceleration and steering respectively,
when trained on the CG-Speedway-1 track. Similarly, Fig-
ures 8, 9 & 10 show policies found for Acrobot, CartPole,
and MountainCar respectively. Here hi is the sequence of
observations from the i-th of k sensors, for example h0 is
the 0-th sensor. The sensor order is determined by the Ope-
nAI simulator.

D. TORCS Video

We provide a video at the following link, which depicts
clips of the DRL agent and the NDPS algorithm synthesized
program, on the training track and one of the transfer (un-
seen) tracks, in that order:

https://goo.gl/Z2X5x6

On the training track, we can see that the steering actions
taken by the DRL agent are very irregular, especially when
compared to the smooth steering actions of the NDPS agent
in the following clip. For the transfer track, we show the
agents driving on the E-Road track. We can see that the
DRL agent crashes before completing a full lap, while the
NDPS agent does not crash. We have provided only small
clips of the car during a race, to keep the video length and
size small, but the behavior is representative of the agent
for the entire race.

