Deep transfer learning in the assessment of the quality of protein models

David Menéndez Hurtado,∗ Karolis Uziela, and Arne Elofsson†
Department of Biochemistry and Biophysics and Science for Life Laboratory, Stockholm University

Motivation: Proteins fold into complex structures that are crucial for their biological functions.
Experimental determination of protein structures is costly and therefore limited to a small fraction
of all known proteins. Hence, diﬀerent computational structure prediction methods are necessary
for the modelling of the vast majority of all proteins. In most structure prediction pipelines, the last
step is to select the best available model and to estimate its accuracy. This model quality estimation
problem has been growing in importance during the last decade, and progress is believed to be
important for large scale modelling of proteins. The current generation of model quality estimation
programs performs well at separating incorrect and good models, but fails to consistently identify
the best possible model. State-of-the-art model quality assessment methods use a combination of
features that describe a model and the agreement of the model with features predicted from the
protein sequence.
Results: We ﬁrst introduce a deep neural network architecture to predict model quality using
signiﬁcantly fewer input features than state-of-the-art methods. Thereafter, we propose a method-
ology to train the deep network that leverages the comparative structure of the problem. We also
show the possibility of applying transfer learning on databases of known protein structures. We
demonstrate its viability by reaching state-of-the-art performance using only a reduced set of input
features and a coarse description of the models.
Availability: The code will be freely available for download at github.com/ElofssonLab/ProQ4.

I.

INTRODUCTION

Proteins perform the vast majority of all biological
functions. They are constructed as long polymers built
of twenty amino acids that fold into a three-dimensional
shape after synthesis. During the last half of the cen-
tury, the structures of more than 100 000 proteins have
been experimentally obtained using X-ray crystallogra-
phy, NMR, or electron microscopy. Although the experi-
mental techniques have improved signiﬁcantly, the aver-
age cost for a new protein structure is still close to $100k,
limiting the number of experimentally determined pro-
tein structures [1].

A single organism contains thousands of genes, each
coding for at least one protein. Due to the exponen-
tial decrease of sequencing costs the sequence of more
than 100 million proteins has been deposited in public
databases like UniRef [2]. Further, almost one order
of magnitude more sequences are available from meta-
genomic projects. This means that there are at least
three orders of magnitude separating the number of
known protein sequences and structures. This gap is in-
creasing, and only computational methods will be able
to close it.

to

generate

Luckily, methods

accurate
three-
If the structure
dimensional models of proteins exist.
it can be
of a homologous protein has been solved,
used as a template for modelling. This method can
be applied to about 50% of all protein families [3, 4].
For the rest, one has to rely on other methods. Here,

∗ david.menendez.hurtado@scilifelab.se
† arne@bioinfo.se

rapid progress in contact prediction has recently enabled
the modelling of the structure of many proteins. The
accuracy of these models varies and depends on several
factors and no single method always produces the best
in many modelling approaches a
model. Therefore,
combination of methods and/or parameter settings are
used to produce multiple models. This will later will be
analysed to identify the best one.

A. Deep learning

Deep learning is a family of machine learning algo-
rithms that has brought a revolution in ﬁelds such as
computer vision, speech recognition, and artiﬁcial intel-
ligence [5]. The improvements can be attributed to two
discoveries: (i) new algorithms enable to deﬁne and eﬃ-
ciently train much more complex models, that can take
advantage of large training sets; and (ii), deep learning
methods can make use of the structure of the data to
take a data-driven approach to feature engineering. In-
stead of hand crafting high-level features, deep learning
can use lower lever representations of the data that pre-
serve its structure, such as the ordering of amino acids in
a protein chain, or the proximity of pixels in an image. A
deep learning model is composed of multiple layers that
successively transform the inputs, learning to extract the
relevant information during training. In eﬀect, replacing
the manual feature engineering with an automatic feature
extraction. In a deep model, each layer learns to combine
some of its input creating a hierarchy of features auto-
matically extracted from the data. For example, when
trying to identify an object in an image, the ﬁrst layers
might learn to detect edges, the next layers would com-

8
1
0
2

r
p
A
7
1

]

M
B
.
o
i
b
-
q
[

1
v
1
8
2
6
0
.
4
0
8
1
:
v
i
X
r
a

 
 
 
 
 
 
bine them into textures, object parts, and eventually the
whole training label.

B. Transfer learning

Deep learning can be used to train high capacity mod-
els, but it requires large amounts of data, that is not
always available or cheap. But since most of the network
acts as a feature extractor, it is possible to train a net-
work on a larger and diﬀerent but related problem, and
reuse the learned feature extraction.

Yosinski et al. [6] studied how well these features are
generalisable across categories in image recognition and
has since become a standard procedure in deep learning.

C. Predicting protein structural features

The structure of a protein consists of secondary struc-
ture elements; α-helices and β-sheets that are packed in
such a way that hydrophobic amino acids are mostly hid-
den from the surface. We also know that homologous
sequences fold into similar structures, so we can search
sequence databases for proteins that are likely to be sim-
ilar to the one we are interested in, and compile them
into an aligned list called multiple sequence alignment.

Both the secondary structure and the surface acces-
sibility of a residue in a protein can be predicted with
a rather high accuracy by applying machine learning on
the statistics extracted from the columns of this multiple
sequence alignment. The accuracy of these methods has
reached close to 80% in two [7] or three [8] state classiﬁ-
cations.

D. CASP: Critical Assessment of protein Structure
Prediction

CASP is a biennial experiment aimed at assessing the
state of the structure prediction ﬁeld. The organizers re-
lease the sequence of proteins of hitherto unknown struc-
ture, and allow a few days for groups around the world
to submit predictions. In a second stage, these models
are published and evaluated by model quality assessment
methods. The latest editions count around 100 individ-
ual sequences (also called targets), and received around
200 models per target, coming from circa 30 independent
methods.

2

FIG. 1: Detail of the 3D structure of the protein 3TDU.
Highlighted in yellow are the residues that smoothly
transition between helix and coil. Predictions are
commonly wrong about the exact position of the
boundary.

extent that it is possible to simulate the folding of a pro-
tein. The purpose of the model quality assessment pro-
gram is to accurately estimate the distance of the model
from the native structure.

There are two general strategies to evaluate the qual-
ity of a single protein model: comparison with auxiliary
predictions, and evaluation of physico-chemical proper-
ties of the model. A limitation of the second approach is
be that even if a method could perfectly describe the free
energy of a protein model - this measure might not be at
all correlated with the diﬀerence of a model from the na-
tive structure. Take the trivial example of a model where
all atoms except one, are perfectly placed. This last atom
is then positioned on top of another atom. Such a model
would have a near inﬁnite free energy, but by any dis-
tance measure, be almost perfect.

On the other hand models solely relying on predictions
might provide important low-resolution methods and re-
duce the complexity of 3D prediction to simpler ones,
such as secondary structure. A good model is expected
to agree with the predictions. In addition, all disagree-
ments might not carry the same information. Often the
exact boundaries of secondary structure elements are no-
toriously diﬃcult to predict, and depend on the exact
thresholds used to deﬁne it, as seen in Figure 1. In con-
trast, it is rare that errors in predictions between diﬀerent
secondary structure classes occur.

E. Model quality assessment background

Estimating the free energies of protein models has
a long history within the protein structure prediction
ﬁeld. [9, 10] Here, the ultimate goal is to understand the
fundamental physics governing protein folding to such an

For more than a decade several groups have developed
protein model quality assessment methods using various
input features [11–16]. The improvements achieved dur-
ing the last few years can be attributed to small, but sig-
niﬁcant, improvements to the methods by (i) including

F. Related work

additional descriptions of a protein model [17], (ii) ap-
plying deep learning techniques [18] and combining many
features [16].

Here follows a brief description of the inputs and algo-
rithms used by other comparable methods. These mostly
focus on physico-chemical descriptors, such as statistical
potentials, and train simple machine learning algorithms.

• QMEAN [19]: Linear combination of the agree-
ment of secondary structure and surface area, and
three statistical potentials describing the torsion
angles, amino acid contacts, and exposure to the
water.

• DeepQA [20]: Deep Belief Network combining sev-
eral scoring potentials and energies, other quality
assessment methods, and seven diﬀerent agreement
metrics between observed and predicted secondary
structure and surface area.

• ProQ3 [17]: A Linear SVM trained on atom and
amino acid contacts, observed secondary structure,
multiple sequence alignment statistics, agreements
with secondary structure and surface area, as well
as terms of the Talaris energy function [21].

• ProQ3D [18]: Same input as ProQ3, but replacing
the linear SVM with a multi layer perceptron.

• VoroMQA [22]: Statistical potential based on the

frequencies of observed atom contacts.

• SVMQA [15]: SVM combining diﬀerent statistical
potentials and agreement with secondary structure
and surface area.

In contrast to all other methods, our method uses only
coarse structural features and a multiple sequence align-
ment, but no statistical potentials nor any other chemical
description.

II. METHODS

A. Datasets

In order to directly compare results with the most re-
cent method, ProQ3D [18] retrained on LDDT [23], we
have used the same datasets for training and testing: all
the submitted models to the CASP editions 9 and 10 for
training, and CASP 11 for evaluation, excluding all the
targets shorter than 50 residues. In total, we have 57 263
models from 212 diﬀerent targets in the training set, and
14 580 from 79 targets in the test set, excluding targets
cancelled by the organisers.

We also present the results on the same subset of the
Cameo dataset used by ProQ3D, 19 899 models from 676
diﬀerent targets.

For the pre-trained networks, we used 5687 structures
from the PISCES dataset [24], while an additional 300

3

were left out for validation. The multiple sequence align-
ments were produced using Jackhmmer [25] to search
Uniref50 [26], with an E-value threshold of 10−3 for 3
iterations.

B. Description of inputs

Prediction of structural features of a protein is im-
proved by using multiple sequence alignments [27]. From
the multiple sequence alignment we extract two statis-
tics: the self-information (Equation 1a) and the partial
entropy (Equation 1b) of the position:

Ii = − log

(cid:19)

,

(cid:18) pi
¯pi

Si = −pi log

(cid:19)

,

(cid:18) pi
¯pi

(1a)

(1b)

where pi is the frequency of the amino acid i at the po-
sition and ¯pi is the average frequency on the data set.
We also include the protein sequence itself using sparse
encoding.

The protein models are deﬁned in a coarse representa-
tion by the sine and cosine of the dihedral angles [28] ϕ
and ψ, the secondary structure, relative surface area, and
energies of hydrogen bonds in the backbone, as deﬁned
by DSSP [29]. In DSSP, 8 diﬀerent secondary structure
states are assigned to a protein. Due to lack of data, we
merged the following two pairs of states: G (310 helix)
and I (π− helix), and T (hydrogen bonded turn) and S
(bend).

C. Output: the target function

There are several diﬀerent metrics that can be used
to evaluate the similarity between a protein model and
the native structure. In this work we choose to use a lo-
cal scoring function: the Local Distance Diﬀerence Test
(LDDT) [30], a number between 0 and 1 that represents
the fraction of conserved contacts between all pairs of
atoms in the native structure for several distance thresh-
olds. An LDDT of 1 means a perfect agreement, and
a good model shall have scores higher than 0.5. Other
quality estimation methods could also be used providing
similar performance. To estimate the quality of a model
we deﬁne the global score to be the average of the local
scores, giving a score of 0 to any residue missing from the
model, and ignoring those absent from the native struc-
ture.

D. Figures of merit

The performance of the models will be evaluated on

several metrics.

• Local correlation: Pearson correlation between the
predicted and true values assigned to every residue.
This measures the reliability of the predicted scores
assigned to each residue.

• Local RMSE: Root Mean Squared Error between
the aforementioned predicted local scores and the
true values.

• Per model correlation: average Pearson correlation
between predicted and true values of every residue
for every model. This measures how well we can
diﬀerentiate the correct and incorrect parts of the
model.

• Global correlation: Pearson correlation between
predicted and true values for the overall model.
This is deﬁned as the average of the local scores,
ignoring any residue not present in the native struc-
ture, and setting the score of missing residues to 0.
This measures how well we can rank targets in a
global scale.

• Global RMSE: Root Mean Squared Error between

the global predicted and true scores.

• Per target correlation: average Pearson correlation
for the global scores per target. A measurement of
the ability of the program to rank models from the
same target.

• First rank loss: average diﬀerence between the best
and the top ranked model. It measures how well we
can select the best model for each target.

III.

IMPLEMENTATION

A. Network architecture

In order to exploit the spatial distribution of the local
features, and to allow the network to compare observa-
tions and predictions locally, we have implemented a 1D
fully convolutional network trained on the local scores.
We used the ELU activation function [31] as a non-
linearity, and also applied a small L2 penalty of 10−14
to every convolutional layer, except for the output lay-
ers, The training was guided by the Adam optimiser [32].

B. The ResNet module

The convolutional block from ResNet [33] inspired our
architecture due to its capacity to converge eﬃciently
while still keeping a deep architecture that provides a
large eﬀective ﬁeld of view. As shown on Figure 2, it
is composed of two blocks of successive convolution of
width 3, followed by an activation function, batch nor-
malisation [34], and dropout, whose output is summed
to the inputs. When the number of input and output

channels is diﬀerent, we modify the skip connection to
include only one convolution, activation, batch normali-
sation, and dropout.

4

FIG. 2: The 1D ResNet module, the main building
block of our convolutional nets

C. Simple Convolutional Neural Network

The simplest implementation of a deep convolutional
network consists of several branches that combines all the
inputs can be seen in Figure 3. In one branch, the three
input vectors derived from the sequence (the sequence it-
self, self-information, and partial entropy) are followed by
a convolution of size 1, to project them into a 16 dimen-
sional vector space per residue. They are then followed
by two ResNet modules, merged into a single branch by
concatenation, and followed by two more ResNet mod-
ules. The structural inputs are likewise projected into
a 64 dimensional space and passed through four ResNet
modules. Finally, both branches are concatenated, and
sent through four more ResNet modules. A single con-
volutional layer of width 7 and no L2 penalty is applied
used in the ﬁnal layer.

5

at the time, we will present the network with two models
of the same target and ask it to predict the scores, as well
as which model is better, for every residue, as shown in
Figure 5.

In order to ensure the symmetry of the problem is re-
spected, each model is passed through a pair of identical
copies of the pre-trained network described previously,
keeping the parameters of each copy tied. This is called a
Siamese conﬁguration, because the network is composed
of two conjoined twins. The comparison prediction is
done by a symmetrised perceptron with one hidden layer,
the SortNet [35], represented in grey boxes in the Figure.
SortNet is a small variation of the classical perceptron
to represent proper preference. So, if we predict that a
is better than b with a probability of 0.8, we will also
predict b to be better than a with a probability of 0.2.
The SortNet is composed by two parallel hidden layers
of 512 neurons per amino acid, and includes batch nor-
malisation and dropout [36].

As is customary in multi-output models, the total loss
is a weighted average of the loss for every output. Since
the comparison has eﬀectively 200 times more training
examples, we assign a higher weight on this output. In
our experiments, the best results were obtained with a
weight of 1 for the comparison and 0.1 for each of the
scores. See Figure 5.

F. Regression as a classiﬁcation

Deep learning usually performs better on classiﬁcation
than on regression tasks. Therefore, we will divide the
[0, 1] range into N equally sized bins and replace the
mean squared error loss function by a cross entropy. In
order to recover the predicted score, we then average the
scores with equally spaced weights.

p =

N
X

i=1

si(σlow + i · σstep) + σof f set,

(2)

where si is the predicted probability of being in the i−th
bin, σlow, σstep, and σof f set are three free parameters
that were obtained minimising the mean squared error
on the training set.

This is the ﬁnal architecture, and we will refer to it as

ProQ4.

FIG. 3: The convolutional architecture

D. Sequence pre-trained network

Our dataset contains roughly 200 times more models
than unique sequences, which is an obvious source of bias.
For example, some of these targets are hard, and not a
single model is of good quality. The network could there-
fore easily learn that this particular sequence is always
bad, which we want to avoid. After all, a new method,
or more data could result in a good model in the future.
To tackle this issue, we pre-train the branch corre-
sponding to the sequence inputs on 5687 of known pro-
tein structures from PISCES [24], showing our network a
much more diverse set of proteins. As shown in Figure 4a,
we inserted one hidden convolutional layer connected to
four more predicting the 3 and 6-state secondary struc-
ture, surface accessibility, and sine and cosine of the di-
hedral angles. We denominate alignment features to the
output of the network in the hidden layer before this one,
and it is used to replace the sequence branch in the pre-
vious network. The resulting model has exactly the same
architecture and parameters, but with some weights set
through training in a diﬀerent task.

The performance of each auxiliary predictor is com-
parable to state-of-the-art methods, but due to possible
overlaps between training and test sets of the diﬀerent
methods, a completely fair comparison would need more
careful studies that are beyond the scope of this paper.

E. Tricephalous network

The ultimate application of model quality assessment
is to rank models of the same protein.
In this section
we will describe an architecture designed to exploit this
structure of the problem by reducing it to pairwise com-
parisons.

In our dataset, for each target we have around 200
individual models, but 20 000 pairs, which we can use as
data augmentation. So, instead of feeding one structure

The networks were implemented with Keras [37], using
Tensorﬂow [38] as a backend. The data is stored in HDF5
ﬁles accessed through PyTables [39]. All the networks
were trained on a single Nvidia 1070Ti GPU, equipped
with 8GB of VRAM.

In order to make predictions, the only dependencies are
Python 3 with Numpy, Biopython, Keras, Tensorﬂow,

G. Dependencies

6

(a) Sequence pre-training, learning the alignment
features.

FIG. 4: The two stages of the Pre-trained network. The sequence pre-training is used to extract the alignment
features that are used subsequently throughout the paper.

(b) Sequence pre-trained network

IV. RESULTS AND DISCUSSION

In the Tables I and II we present the results on the
CASP 11 datasets for the three networks, compared with
the state-of-the-art method, ProQ3D [18]. No other pub-
licly available method was trained on LDDT, so we can-
not establish a fair comparison. We also present the re-
sults on Cameo [40] on Tables III and IV. The last row on
each table, Tricephalous network trained on classiﬁcation
is our ﬁnal model, ProQ4, also plotted in Figure 6.

Of all the reported ﬁgures, we believe the per target
correlation to be the most important metric, since one
is usually interested in comparing models corresponding
to the same protein. First rank loss is also of interest,
but since depends on a single data point per target, it is
noisier.

For a baseline, we trained a simple feed forward net-
work on our features with a window of 21 residues, with
two hidden layers of 512 units, ELU activation, Batch
Normalisation, and Dropout (pdrop = 0.1). This model
represents how much information is there in the features
themselves, disregarding the structure.

It can be seen that both the pre-training and the com-
parative strategy signiﬁcantly improve the predictions,
both the per target correlation and the ﬁrst rank loss are
better than previous methods.

The quality of the sequence-based network does not
appear to be hindering our performance, since the per
target correlations are only weakly correlated with the
quality of the predictions, see Figure 8. Furthermore,
the worst ranked targets have very low average scores,

FIG. 5: The Tricephalous architecture: the two stages
of the Comparative network combined at once.

and H5Py, DSSP, and a multiple sequence alignment.
All dependencies are open source and can be freely dis-
tributed. Running on GPUs requires a CUDA-enabled
NVIDIA GPU card, but can also work on CPUs.

7

TABLE I: Summary of results on the local scores on CASP11.

Method

R-local RMSE local R-per model

ProQ3D
(retrained on LDDT) 0.84

0.125

0.61

Base MLP
Pre-trained MLP

Simple CNN
Pre-trained CNN
Tricephalous

ProQ4

0.62
0.52

0.51
0.68
0.72

0.77

0.180
0.198

0.205
0.172
0.160

0.147

0.44
0.47

0.42
0.55
0.55

0.56

R-local is the correlation between all local predicted and true scores in the dataset; RMSE stands for Root Mean
Squared Error. R-per model is the average correlation between predicted and true scores for each model in the
dataset. Find a more detailed explanation in section II D

TABLE II: Summary of results on the global scores on CASP11.

Method

R-global Global RMSE R-per target First rank loss

ProQ3D
(retrained on LDDT)

Base MLP
Pre-trained MLP

Simple CNN
Pre-trained CNN
Tricephalous

0.90

0.77
0.67

0.67
0.85
0.87

0.080

0.118
0.135

0.157
0.121
0.106

ProQ4

0.91

0.085

0.82

0.82
0.82

0.68
0.85
0.88

0.90

0.040

0.046
0.046

0.091
0.036
0.029

0.022

R-global is the correlation between all global predicted and true scores in the dataset; R-per target is the average
correlation of global scores of models for each protein; and ﬁrst rank loss is the average diﬀerence in true scores
between the best model and the top ranked for each target.

8

FIG. 6: 2D histogram of local (upper) and global
(lower) scores for CASP 11 and Cameo.

FIG. 8: Comparison between per target correlations
and the quality of the sequence-based predictor. The
correlation is weak (0.33), suggesting that the quality of
the sequence-based features is not a signiﬁcant limiting
factor.

FIG. 7: Comparison of the performance of ProQ3D (in
blue) and ProQ4 (green) in per target correlations
(upper) and ﬁrst rank loss (lower). For Cameo, the
histograms have been truncated to the same range as
CASP for clarity.

FIG. 9: The per target correlations of ProQ3D and
ProQ4 as a function of the average quality of the model
on CASP11. The dependency is stronger for ProQ3D
(RP Q3D = 0.52 vs RP Q4 = 0.31).

correlations. The ﬁnal model has 5 classes.

which are indeed diﬃcult to rank, as shown in Figure 9.

B. The eﬀect of larger networks

A. Number of classes in the scores

When treating the regression as a classiﬁcation, we
tested all splits between 2 and 9 classes, using equally
spaced bins. The diﬀerences between 3 or more classes
are smaller than 2% in the local, global, and per target

We tested deeper networks increasing from 8 up to
50 ResNet blocks deep, and while it improved the lo-
cal correlation, the global metrics remained the same, or
slightly lower. For example, with a depth of 50 layers,
we increased a local correlation of from 0.77 to 0.81, on
CASP11, while the global remained at 0.91, but the per
target drops from 0.90 to 0.87. Even though the local cor-

0.000.250.500.751.000.00.20.40.60.81.0PredictedlocalCASP110.000.250.500.751.000.00.20.40.60.81.0Cameo0.000.250.500.751.00True0.00.20.40.60.81.0Predictedglobal0.000.250.500.751.00True0.00.20.40.60.81.00.40.60.81.0Correlation0102030PertargetcorrelationsCASP110.40.60.81.0Correlation0100200Cameo0.000.050.100.150.200.25Loss010203040FirstRankLoss0.000.050.100.150.200.25Loss0100200ProQ3ProQ40.40.50.60.70.80.9SecondaryStructure-3stateaccuracy0.650.700.750.800.850.900.951.00Pertargetcorrelation0.20.30.40.50.60.7Averagemodelquality0.40.50.60.70.80.91.0PertargetcorrelationProQ4ProQ39

TABLE III: Summary of results on the local scores on Cameo.

Method

R-local RMSE local R-per model

ProQ3D
(retrained on LDDT) 0.79

0.137

0.64

Base MLP
Pre-trained MLP

Simple CNN
Pre-trained CNN
Tricephalous

ProQ4

0.48
0.50

0.43
0.61
0.65

0.65

0.232
0.248

0.219
0.202
0.199

0.201

0.42
0.47

0.41
0.55
0.56

0.56

R-local is the correlation between all local predicted and true scores in the dataset; RMSE stands for Root Mean
Squared Error. R-per model is the average correlation between predicted and true scores for each model in the
dataset. Find a more detailed explanation in section II D

TABLE IV: Summary of results on the global scores on Cameo.

Method

R-global Global RMSE R-per target First rank loss

ProQ3D
(retrained on LDDT)

0.88

0.093

Base MLP
Pre-trained MLP

Simple CNN
Pre-trained CNN
Tricephalous

ProQ4

0.71
0.76

0.70
0.80
0.82

0.82

0.180
0.202

0.163
0.158
0.158

0.156

0.80

0.75
0.76

0.71
0.80
0.83

0.84

0.021

0.034
0.032

0.041
0.028
0.025

0.023

R-global is the correlation between all global predicted and true scores in the dataset; R-per target is the average
correlation of global scores of models for each protein; and ﬁrst rank loss is the average diﬀerence in true scores
between the best model and the top ranked for each target.

relations improve signiﬁcantly, the per model correlation
is slightly reduced from 0.56 to 0.55. Larger networks
seem to predict signiﬁcantly better local scores, but be-
ing hampered by biases.

C. Global vs local scores

We are training on local scores, so directly trying to op-
timise the local RMSE. It is surprising, then, that while
the performance on local scores is signiﬁcantly worse than
ProQ3D, ProQ4 shows an improvement on global met-
rics, specially on per target correlations. So, ProQ4 is
better at telling the global diﬀerences between models,
but fails to locate them accurately. This may be due to
the fact that during the training procedure we are pre-
senting the network with the full model, or due to the
lack of a description of the chemical properties of the
model.

As shown in the section IV B, an increase in local per-
formance does not necessarily translate into global im-
provements.

D. Diﬀerence between CASP and Cameo

The main diﬀerence in Cameo is that there are much
fewer models per target, and coming from fewer servers.
Many of the targets have easy templates available, so
most of the models tend to be similar to each other.

The average ﬁrst rank loss on the Cameo dataset is
dominated by a single target, 4UYQ_B, with a loss of
0.44 (see Figure 7). If that target were excluded, the aver-
age ﬁrst rank loss would drop to 0.021, same as ProQ3D.

E. Are we learning something new?

Figure 10 shows a correlation matrix between all the
global scores for all the architectures presented. We can
clearly identify two close clusters, one for the MLP ar-
chitectures, and another one for all the convolutional
networks using pre-trained features. Simple CNN is an
outlier, showing only a moderate correlation with its ar-
chitectural twin, the pretrained network. This indicates
that the Tricephalous network and ProQ4 are learning
the same thing, ProQ4 is just slightly better.

On the other hand, the agreement between ProQ3D
and each of our models is similar to the agreement be-
tween the model and the true values, suggesting that
both are learning something fundamentally diﬀerent, de-
spite having been trained on the same dataset.

F. Method biases

10

and produce models of diverse chemical characteristics.
This is a challenge when evaluating the model quality; a
model presenting unnatural chemical properties can be
due to low quality or just the existence of non-optimised
local geometries, for instance caused by sub-optimal side-
chain packing.

A common solution to the diversity problem is to uni-
formise the models by repacking the side-chains with a
single program such as SCWRL [41]. However, there are
limitations to this approach and it might be computa-
tionally expensive. Also, from a practical point of view,
it causes a method to be dependent on additional pro-
grams.

In our proposed method, we use only a coarse descrip-
tion of the protein that is not sensitive to the packing of
the side chains. This should make it quicker and easier
to apply it in a large scale.

Another source of bias befalls when both the method
generating the model and the assessment make use of the
same auxiliary predictor, such as PSIPRED [8]. In this
case, we ﬁnd a bias for models generated with a particular
method.
In order to tackle this issue, we replace the
comparison with explicit predictors with our own method
and train on the hidden representation instead of the ﬁnal
output.

V. CONCLUSIONS

A. Limitation of the method

Our proposed method uses a very coarse description
of the structural structures, focused on features that can
be predicted from the sequence. This restricted descrip-
tion limits the performance on the local level, but it is
compensated by an increased performance in the global
and, specially, per target ranking, due to the in built
comparative structure.

Finding the right representation for the chemical prop-
erties of proteins from a deep learning point of view re-
mains as an open question, and we hope this work will
incentivise this line of research.

B. The importance of structured data

One of the reasons behind the great success of deep
learning is the ability to take full advantage of the struc-
ture of the data. For machine learning in bioinformatics
this has not been utilized fully, except for contact pre-
diction in the works of Golkov et al. [42] and Wang et al.
[43]. Many machine learning methods in bioinformatics
still rely on sliding window approaches. Even when deep
learning has been applied this has often been limited to
increasing the complexity of a multi-layer perceptron ar-
chitecture.

There are multiple strategies to generate protein mod-
els. Diﬀerent methods fall into distinct kinds of errors,

Since the advent of the Non Free Lunch theorem [44],
we know that the success of a machine learning algorithm

11

FIG. 10: Correlation matrix between the predicted global scores on CASP 11 for each method. The order of the
rows is the same as in the tables, with the last corresponding to the true scores. A similar picture is obtained if we
compare local scores instead.

is tied to how much domain knowledge can be included
In traditional machine learning, this is
in its training.
done through careful feature engineering, trying to ﬁnd
the closest representation to our objective. In this work
we propose a training framework that replaces the tra-
ditional end-to-end ﬁtting with a multi-stage process de-
signed to inject domain knowledge in every step of the
way:

nature of the problem.

Both the pre-training and the comparative training
bring an improvement to the results across all the metrics
we have evaluated on both datasets.

The importance of structure is also seen on the eﬀect
of pre-training. While it improves CNN-based architec-
tures, Multi Layer Perceptron (MLP) models don’t ben-
eﬁt, or are even hindered by pre-training.

1. Spatial relationships and translation invariance are

FUNDING

coded as convolutions.

2. The sequence information is extracted in the pre-

training.

3. The tricephalous architecture encodes the ranking

This work was supported by grants from the Swedish
Research Council (VR-NT 2016-03798 to AE) and
Swedish e-Science Research Center (BW). The Swedish
re-
National
sources for Computing (SNIC) at NSC.

Infrastructure provided computational

[1] T. Terwilliger, D. Stuart, and S. Yokoyama, Annu Rev

[5] Y. LeCun, Y. Bengio,

and G. Hinton, Nature 521,

Biophys 38, 371 (2009).

436?444 (2015).

[2] The UniProt Consortium, Nucleic Acids Res 45, D158

(2017).

[3] M. Michel, D. Menéndez Hurtado, K. Uziela,
A. Elofsson, Bioinformatics 33, i23?i29 (2017).

and

[4] S. Ovchinnikov, H. Park, N. Varghese, P.-S. Huang, G. A.
Pavlopoulos, D. E. Kim, H. Kamisetty, N. C. Kyrpides,
and D. Baker, Science 355, 294?298 (2017).

[6] J. Yosinski, J. Clune, Y. Bengio, and H. Lipson, in Pro-
ceedings of the 27th International Conference on Neu-
ral Information Processing Systems - Volume 2 , NIPS’14
(MIT Press, Cambridge, MA, USA, 2014) pp. 3320–3328.
[7] B. Petersen, T. Petersen, P. Andersen, M. Nielsen, and
C. Lundegaard, BMC Structural Biology 9, 51 (2009).

ProQ3DMLPbasicMLPpretrainedCNNCNNpretrainedTricephalousProQ4TrueProQ3DMLPbasicMLPpretrainedCNNCNNpretrainedTricephalousProQ4True0.700.750.800.850.900.951.0012

[8] D. T. Jones, Journal of Molecular Biology 292, 195

(1999).

[29] W. Kabsch and C. Sander, Biopolymers 22, 2577 (1983).
[30] V. Mariani, M. Biasini, A. Barbato, and T. Schwede,

[9] B. Park and M. Levitt, Journal of molecular biology 258,

Bioinformatics 29, 2722 (2013).

367 (1996).

[10] T. Lazaridis and M. Karplus, Journal of molecular biol-

ogy 288, 477 (1999).

[31] D. Clevert, T. Unterthiner, and S. Hochreiter, Proceed-
ings of the 32nd International Conference on Machine
Learning 32 (2015).

[11] B. Wallner and A. Elofsson, Protein Science 12, 1073

[32] D. Kingma and J. Ba, International Conference for

(2003).

[12] B. Wallner, Protein Science 15, 900 (2006).
[13] A. Ray, E. Lindahl, and B. Wallner, BMC Bioinformatics

13, 224 (2012).

[14] S. Mirzaei, T. Sidi, C. Keasar,

and S. Crivelli,
IEEE/ACM Transactions on Computational Biology and
Bioinformatics , 1 (2016).

[15] B. Manavalan and J. Lee, Bioinformatics

(2017),

10.1093/bioinformatics/btx222.

[16] A. Maghrabi and L. J. McGuﬃn, Nucleic Acids Research

(2017), 10.1093/nar/gkx332.

Learning Representations (2015).

[33] K. He, X. Zhang, S. Ren, and J. Sun, 2016 IEEE Con-
ference on Computer Vision and Pattern Recognition
(CVPR) (2016), 10.1109/cvpr.2016.90.

[34] S. Ioﬀe and C. Szegedy, Proceedings of the 32nd Interna-
tional Conference on Machine Learning 37 (2015).
[35] L. Rigutini, T. Papini, M. Maggini, and F. Scarselli,
IEEE Transactions on Neural Networks 22, 1368 (2011).
[36] N. Srivastava, G. E. Hinton, A. Krizhevsky, I. Sutskever,
and R. Salakhutdinov, Journal of Machine Learning Re-
search 15, 1929 (2014).

[17] K. Uziela, N. Shu, B. Wallner, and A. Elofsson, Scientiﬁc

[37] F. Chollet

et al.,

“Keras,” https://github.com/

Reports 6, 33509 (2016).

fchollet/keras (2015).

[18] K. Uziela, D. Menéndez Hurtado, N. Shu, B. Wallner,

and A. Elofsson, Bioinformatics , btw819 (2017).

[19] P. Benkert, S. C. E. Tosatto, and D. Schomburg, Pro-
teins: Structure, Function, and Bioinformatics 71, 261
(2008).

[20] R. Cao, D. Bhattacharya, J. Hou, and J. Cheng, BMC
Bioinformatics 17 (2016), 10.1186/s12859-016-1405-y.
[21] A. Leaver-Fay, M. J. O’Meara, M. Tyka, R. Jacak,
Y. Song, E. H. Kellogg, J. Thompson, I. W. Davis,
R. A. Pache, S. Lyskov, J. J. Gray, T. Kortemme, J. S.
Richardson, J. J. Havranek, J. Snoeyink, D. Baker, and
B. Kuhlman, in Methods in Protein Design, Methods in
Enzymology, Vol. 523, edited by A. E. Keating (Academic
Press, 2013) pp. 109 – 143.

[22] K. Olechnovic and C. Venclovas, Proteins:

ture,
10.1002/prot.25278.

Function,

and Bioinformatics

Struc-
(2017),

[23] K. Uziela, D. Menéndez Hurtado, N. Shu, B. Wallner,
and A. Elofsson, Proteins: Structure, Function, and
Bioinformatics (2018), 10.1002/prot.25492.

[24] G. Wang and R. L. Dunbrack, Jr., Bioinformatics 19,

1589 (2003).

[25] L. S. Johnson, S. R. Eddy, and E. Portugaly, BMC Bioin-

formatics 11, 431 (2010).

[26] B. E. Suzek, Y. Wang, H. Huang, P. B. McGarvey, and

[38] M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen,
C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin,
S. Ghemawat, I. Goodfellow, A. Harp, G. Irving, M. Is-
ard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur, J. Lev-
enberg, D. Mané, R. Monga, S. Moore, D. Murray,
C. Olah, M. Schuster, J. Shlens, B. Steiner, I. Sutskever,
K. Talwar, P. Tucker, V. Vanhoucke, V. Vasudevan,
F. Viégas, O. Vinyals, P. Warden, M. Wattenberg,
M. Wicke, Y. Yu, and X. Zheng, “TensorFlow: Large-
scale machine learning on heterogeneous systems,”
(2015), software available from tensorﬂow.org.

[39] F. Alted,

I. Vilata, et al., “PyTables: Hierarchical

datasets in Python,” (2002–).

[40] J. Haas, A. Barbato, D. Behringer, G. Studer,
S. Roth, M. Bertoni, K. Mostaguir, R. Gumienny, and
T. Schwede, Proteins: Structure, Function, and Bioinfor-
matics 86, 387?398 (2017).

[41] Q. Wang, A. A. Canutescu, and R. L. Dunbrack, Nature

Protocols 3, 1832 (2008).

[42] V. Golkov, M. J. Skwark, A. Golkov, A. Dosovitskiy,
T. Brox, J. Meiler, and D. Cremers, in Advances in Neu-
ral Information Processing Systems 29 , edited by D. D.
Lee, M. Sugiyama, U. V. Luxburg, I. Guyon, and R. Gar-
nett (Curran Associates, Inc., 2016) pp. 4222–4230.
[43] S. Wang, S. Sun, Z. Li, R. Zhang, and J. Xu, PLoS

C. H. Wu, Bioinformatics 31, 926 (2014).

Comput Biol 13, e1005324 (2017).

[27] B. Rost, C. Sander, and R. Schneider, Journal of Molec-

[44] D. H. Wolpert, Neural Computation 8, 1341?1390 (1996).

ular Biology 235, 13 (1994).

[28] B. Xue, O. Dor, E. Faraggi,

and Y. Zhou, Proteins:
Structure, Function, and Bioinformatics 72, 427 (2008).

