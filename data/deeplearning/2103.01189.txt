1
2
0
2

r
a

M
1

]
T
C
.
h
t
a
m

[

1
v
9
8
1
1
0
.
3
0
1
2
:
v
i
X
r
a

Learnersâ€™ languages

David I. Spivak

Abstract

In â€œBackprop as functorâ€, the authors show that the fundamental elements of
deep learningâ€”gradient descent and backpropagationâ€”can be conceptualized as
a strong monoidal functor Para(Euc) â†’ Learn from the category of parameterized
Euclidean spaces to that of learners, a category developed explicitly to capture
parameter update and backpropagation.
It was soon realized that there is an
isomorphism Learn (cid:27) Para(SLens), where SLens is the symmetric monoidal
category of simple lenses as used in functional programming.

In this note, we observe that SLens is a full subcategory of Poly, the category
of polynomial functors in one variable, via the functor ğ´ â†¦â†’ ğ´yğ´. Using the fact
that (Poly, âŠ—) is monoidal closed, we show that a map ğ´ â†’ ğµ in Para(SLens) has a
natural interpretation in terms of dynamical systems (more precisely, generalized
Moore machines) whose interface is the internal-hom type [ğ´yğ´, ğµyğµ].

Finally, we review the fact that the category ğ‘-Coalg of dynamical systems
on any ğ‘ âˆˆ Poly forms a topos, and consider the logical propositions that can be
stated in its internal language. We give gradient descent as an example, and we
conclude by discussing some directions for future work.

1 Introduction

In the paper â€œBackprop as functorâ€ [FST19], the authors show that gradient descent
and backpropagationâ€”as used in deep learningâ€”can be conceptualized as a strong
monoidal functor ğ¿ : Para(Euc) â†’ Learn from the category of parameterized euclidean
spaces to that of learners, a category developed explicitly to capture parameter update
and backpropagation. Here, Para is a monad on the category of symmetric monoidal
categories. It sends (C, ğ¼, âŠ—) to a category with the same objects Ob Para(C) â‰” Ob C,
but with hom-sets that include a parameterizing object

Para(C)(ğ‘1, ğ‘2) â‰” {(ğ‘, ğ‘“ ) | ğ‘ âˆˆ C, ğ‘“ : ğ‘1 âŠ— ğ‘ â†’ ğ‘2}/âˆ¼

where the parameterizing object ğ‘ is considered up to an equivalence relation âˆ¼.1 The
composite of ğ‘1 âŠ— ğ‘1 â†’ ğ‘2 and ğ‘2 âŠ— ğ‘2 â†’ ğ‘3 in Para(C) has parameterizing object ğ‘1 âŠ— ğ‘2
1The equivalence relation âˆ¼ is generated by regarding (ğ‘, ğ‘“ ) âˆ¼ (ğ‘â€², ğ‘“ â€²) if there exists an epi-
morphism ğ‘” : ğ‘ Ö‰ ğ‘â€² with ğ‘“ = ğ‘” # ğ‘“ â€². As Bruno GavranoviÄ‡ points out in a recent presentation,
https://www.youtube.com/watch?v=ji8MHKlQZ9w, it is often preferable to dispense with the equiva-
lence relation and instead conceive of Para(C) as a bicategory. This is what we shall do as well.

1

 
 
 
 
 
 
and is given by the ordinary composite

ğ‘1 âŠ— (ğ‘1 âŠ— ğ‘2) â†’ ğ‘2 âŠ— ğ‘2 â†’ ğ‘3.

The domain of the backpropagation functor, Para(Euc), is thus the Para construction
applied to the Cartesian monoidal category of Euclidean spaces Rğ‘› and smooth maps.
But it was soon realized that Learn is in fact also given by a Para construction,
namely there is an isomorphism Learn (cid:27) Para(SLens), where SLens is the symmetric
monoidal category of simple lenses as used in functional programming. The objects
of SLens are sets Ob(SLens) = Ob(Set), but a morphism consists of a pair of functions

SLens(ğ´, ğµ) â‰” {( ğ‘“1, ğ‘“ â™¯) | ğ‘“1 : ğ´ â†’ ğµ,

ğ‘“ â™¯ : ğ´ Ã— ğµ â†’ ğ´}.

(1)

Thus a map ğ´ â†’ ğµ in Para(SLens) consists of a set ğ‘ƒ and functions ğ‘“1 : ğ´ Ã— ğ‘ƒ â†’
ğµ and ğ‘“ â™¯ : ğ´ Ã— ğµ Ã— ğ‘ƒ â†’ ğ´ Ã— ğ‘ƒ. The authors of [FST19] developed this structure
in order to conceptualize the compositional nature of deep learning as comprising
a parameterizing set ğ‘ƒ (often called â€œthe space of weights and biasesâ€) and three
functions:

ğ¼ : ğ´ Ã— ğ‘ƒ â†’ ğµ

ğ‘ˆ : ğ´ Ã— ğµ Ã— ğ‘ƒ â†’ ğ‘ƒ

ğ‘… : ğ´ Ã— ğµ Ã— ğ‘ƒ â†’ ğ´

implement

update

request

(2)

The implement function is a ğ‘ƒ-parameterized function ğ´ â†’ ğµ, and the update and
request functions take a pair (ğ‘, ğ‘) of â€œtraining dataâ€ and both updates the parameterâ€”
e.g. by gradient descentâ€”and returns an element of the input space ğ´, which is used
to train another such function in the network. This last stepâ€”the requestâ€”is not just
found in deep learning as practiced, but is in fact crucial for deï¬ning composition.2

But by this point, the notation (ğ‘ƒ, ğ¼, ğ‘ˆ , ğ‘…) of Learn has become heavy and the
structure seems to be getting lost. Even knowing Learn (cid:27) Para(SLens) seems ad-hoc
since the morphisms (1) of SLens areâ€”to this pointâ€”mathematically unmotivated.
This is where Poly comes in.

In this note, we observe that SLens is a full subcategory of Poly, the category
of polynomial functors in one variable, via the functor ğ´ â†¦â†’ ğ´yğ´. Using the fact
that (Poly, âŠ—) is monoidal closed, we will reconceptualize Para(SLens) in terms of
polynomial coalgebras, which can be understood as dynamical systems: machines
with states that can be observed as â€œoutputâ€ and updated based on â€œinputâ€.
In
particular, a morphism ğ´ â†’ ğµ in Learn will be recast as a coalgebra on the internal
hom polynomial [ğ´yğ´, ğµyğµ], and we will explain this in terms of dynamics.

This viewpoint allows us to substantially generalize the construction in Learn, a
construction which also appears prominently in the theory of open games [Gha+16].

2The reader can check that given only (ğ‘ƒ, ğ¼, ğ‘ˆ) : ğ´ â†’ ğµ and (ğ‘„, ğ½, ğ‘‰) : ğµ â†’ ğ¶, one can construct a
composed parameter set ğ‘ƒ Ã— ğ‘„, and one can construct a composed implement function ğ´ Ã— ğ‘ƒ Ã— ğ‘„ â†’ ğ¶,
but one cannot construct an associative update operation ğ´ Ã— ğ¶ Ã— ğ‘ƒ Ã— ğ‘„ â†’ ğ‘ƒ Ã— ğ‘„. In order to get it, one
needs the request function ğµ Ã— ğ¶ Ã— ğ‘„ â†’ ğµ. By endowing morphisms with the request function, as in
Learn (2), composition and a monoidal structure is easily deï¬ned.

2

Perhaps more interestingly, it allows us to use we the fact that the category ğ‘-Coalg
of dynamical systems on any interface ğ‘ âˆˆ Poly forms a topos. A topos is a setting in
which one can do dependent type theory and higher-order logic. In fact, the topos of
ğ‘-coalgebras is in some ways as simple as possible: it is not only a copresheaf topos
ğ‘-Coalg (cid:27) SetC for a certain category C, but in fact the site C is the free category
on a directed graph that weâ€™ll call Treeğ‘. This makes the logic of ğ‘-coalgebrasâ€”and
hence of dynamical systems, learners, and game-playersâ€”quite simple. However, the
particular graph Treeğ‘ associated to ğ‘ is highly-structured, and we should ï¬nd that
this structure is inherited by the internal language of ğ‘-Coalg.

The point is to consider logical propositions that can be stated in the internal
language of ğ‘-Coalg and to use these propositions in order to constrain the behavior
of learners and game-players (categoriï¬ed as discussed above), and of interaction
patterns between dynamical systems more generally. For example, â€œgradient descent
and backpropagationâ€ is a property we can express in the internal language.

Plan for the paper

In Section 2 we will discuss various relevant constructions in the category Poly of poly-
nomial functors in one variable. In particular, we will review its symmetric monoidal
closed structure (Poly, y, âŠ—, [âˆ’, âˆ’]), its composition monoidal structure (y, âŠ³), and the
notion of coalgebras. We explain how morphisms in Learn can be phrased in terms of
coalgebras on internal hom objects, and we reconstruct Para(SLens) in these terms.

In Section 3, we ï¬rst show that the category ğ‘-Coalg of ğ‘-coalgebras for the endo-
functor ğ‘ : Set â†’ Set is a presheaf topos. We then discuss the internal logic of ğ‘-Coalg,
and we conclude by giving several directions for future work.

Notation

We denote the category of sets by Set; we generally denote sets with upper-case letters
ğ´, ğµ, etc. Given a natural number ğ‘ âˆˆ N, we write N â‰” {1, . . . , ğ‘ }, so 0 = âˆ…, 1 = {1},
2 = {1, 2}, etc. Given sets ğ´, ğµ, we often write ğ´ğµ â‰” ğ´ Ã— ğµ to denote their Cartesian
product.

We will denote polynomials with lower-case letters, ğ‘, ğ‘, etc.

Acknowledgments

We thank David A. Dalrymple, Dai Girardo, Paul Kreiner, David Jaz Myers, and
Alex Zhu for useful conversations. We also acknowledge support from AFOSR grant
FA9550-20-10348.

3

2 Constructions in Poly

In this section we review the category Poly, for which [GK12] is an excellent reference;
we also discuss its symmetric monoidal closed structure. Then we discuss polynomial
coalgebras and reconceptualize the category Learn and GavranoviÄ‡â€™s bicategorical
variant, in that language.

2.1 Background on Poly as a monoidal closed category

For any set ğ´, let yğ´ : Set â†’ Set be the functor represented by ğ´; that is, yğ´ applied to
a set ğ‘† is Set(ğ´, ğ‘†) (cid:27) ğ‘†ğ´. In particular, y â‰” y1 is (isomorphic to) the identity functor
ğ‘† â†¦â†’ ğ‘† and 1 â‰” y0 is the constant functor ğ‘† â†¦â†’ 1. Note that yğ´(1) (cid:27) 1ğ´ (cid:27) 1 for any ğ´.
The coproduct of functors ğ¹ and ğº, denoted ğ¹ + ğº, is taken pointwise; this means

there is a natural isomorphism

(ğ¹ + ğº)(ğ‘†) (cid:27) ğ¹(ğ‘†) + ğº(ğ‘†)

where the coproduct ğ¹(ğ‘†) + ğº(ğ‘†) is taken in Set. Similarly, for any set ğ¼ and functors
ğ¹ğ‘–, one for each ğ‘– âˆˆ ğ¼, their coproduct is computed pointwise

(ğ‘†) (cid:27)

ğ¹ğ‘–

!

Ã•ğ‘–âˆˆğ¼

Ã•ğ‘–âˆˆğ¼

ğ¹ğ‘–(ğ‘†).

Deï¬nition 2.1. A polynomial functor ğ‘ is any coproduct

ğ‘ â‰”

yğ‘[ğ‘–]

Ã•ğ‘–âˆˆğ¼
of representable functors, where ğ¼ âˆˆ Set and each ğ‘[ğ‘–] âˆˆ Set are sets. We denote the
category of polynomial functors and natural transformations between them by Poly.

We note that if ğ‘ =

ğ‘–âˆˆğ¼ yğ‘[ğ‘–] then ğ‘(1) (cid:27) ğ¼; hence we can write any ğ‘ âˆˆ Poly in

canonical form

Ã

ğ‘ (cid:27)

yğ‘[ğ‘–].

Ã•ğ‘–âˆˆğ‘(1)

(3)

We refer to each ğ‘– âˆˆ ğ‘(1) as a position in ğ‘ and to each ğ‘‘ âˆˆ ğ‘[ğ‘–] as a direction at ğ‘–.

Example 2.2. We can consider any set ğ‘† as a constant polynomial

ğ‘ âˆˆğ‘† y0.

We can consider a polynomial ğ‘ âˆˆ Poly as a set (or discrete category) ğ‘(1) equipped
with a functor ğ‘[âˆ’] : ğ‘(1) â†’ Set. Then a map of polynomials ğœ‘ : ğ‘ â†’ ğ‘ can be
identiï¬ed with a diagram as follows

Ã

ğ‘(1)

ğ‘[âˆ’]

ğ‘(1)

ğ‘[âˆ’]

ğœ‘1

â‡
ğœ‘â™¯

Set

4

(4)

 
That is, ğœ‘ can be decomposed into a function ğœ‘1 : ğ‘(1) â†’ ğ‘(1) on positions, and for
every ğ‘– âˆˆ ğ‘(1) with ğ‘— â‰” ğœ‘1(ğ‘–), a component function ğœ‘â™¯
ğ‘– : ğ‘[ğ‘—] â†’ ğ‘[ğ‘–] on directions.
This follows from the Yoneda lemma and the universal property of coproducts. We
will sometimes use this (ğœ‘1, ğœ‘â™¯) : ğ‘ â†’ ğ‘ notation below.
Example 2.3. A morphism ğ´1yğ´2 â†’ ğµ1yğµ2 can be identiï¬ed with a function ğœ‘1 : ğ´1 â†’
ğµ1 and a function ğœ‘â™¯ : ğ´1 Ã— ğµ2 â†’ ğ´2. That is,

Poly(ğ´1yğ´2 , ğµ1yğµ2) (cid:27) ğµğ´1

1 ğ´ğ´1ğµ2

2

.

(5)

Proposition 2.4. The composite of polynomial functors ğ‘, ğ‘ âˆˆ Poly, which we denote ğ‘ âŠ³ ğ‘,
is again polynomial with formula

ğ‘ âŠ³ ğ‘ (cid:27)

ğ‘‘âˆˆğ‘[ğ‘–] ğ‘[ğ‘—ğ‘‘]

y

Ã•ğ‘–âˆˆğ‘(1) Ã•ğ‘— : ğ‘[ğ‘–]â†’ğ‘(1)
The composition operation âŠ³ is a (nonsymmetric) monoidal structure on Poly, with unit y.

Ã

Proof. See page 12.

(6)

(cid:3)

Example 2.5. If ğ‘ = y2 and ğ‘ = y + 1, then ğ‘ âŠ³ ğ‘ (cid:27) y2 + 2y + 1 whereas ğ‘ âŠ³ ğ‘ (cid:27) y2 + 1.
Example 2.6. Applying a polynomial ğ‘ to a set ğ‘† is given by composition: ğ‘(ğ‘†) (cid:27) ğ‘ âŠ³ ğ‘†.

Proposition 2.7 (The symmetric monoidal category (Poly, y, âŠ—)). The category Poly has
a symmetric monoidal structure with unit y and monoidal product âŠ— on objects given by the
following formula

ğ‘ âŠ— ğ‘ â‰”

yğ‘[ğ‘–]Ã—ğ‘[ğ‘—]

Ã•ğ‘–âˆˆğ‘(1) Ã•ğ‘—âˆˆğ‘(1)

Proof. See page 13.

(cid:3)

Proposition 2.8 (Internal hom [âˆ’, âˆ’]). The âŠ— monoidal structure on Poly is closed; that is,
for every ğ‘, ğ‘ âˆˆ Poly there is a polynomial

[ğ‘, ğ‘] â‰”

y

Ã

Ã•ğœ‘ : ğ‘â†’ğ‘

ğ‘–âˆˆğ‘(1) ğ‘[ğœ‘1(ğ‘–)]

for which we have a natural isomorphism

Poly(ğ‘Ÿ âŠ— ğ‘, ğ‘) (cid:27) Poly(ğ‘Ÿ, [ğ‘, ğ‘]).

Proof. See page 13.

(7)

(8)

(cid:3)

Example 2.9. Given sets ğ´ and ğµ, we use Eqs. (5) and (7) to compute that the internal
hom between ğ´yğ´ and ğµyğµ is

[ğ´yğ´, ğµyğµ] (cid:27) ğµğ´ğ´ğ´ğµyğ´ğµ.

The counit of the adjunction (8) is a natural map eval : ğ‘ âŠ— [ğ‘, ğ‘] â†’ ğ‘ called eval-
uation. In very much the same way, it induces two sorts of morphisms we will use
later:

[ğ‘1, ğ‘1] âŠ— [ğ‘2, ğ‘2] â†’ [ğ‘1 âŠ— ğ‘2, ğ‘1 âŠ— ğ‘2]

and

[ğ‘, ğ‘] âŠ— [ğ‘, ğ‘Ÿ] â†’ [ğ‘, ğ‘Ÿ].

(9)

5

2.2 Coalgebras, generalized Moore machines, and learners

Coalgebras for endofunctors ğ¹ : Set â†’ Set form a major topic of study [AM82; AdÃ¡05;
Jac17]. In this section we recall the deï¬nition and explain the relevance to dynamical
systems (generalized Moore machines) and learners.

Deï¬nition 2.10 (Coalgebra). Given a polynomial ğ‘, a ğ‘-coalgebra is a pair (ğ‘†, ğ›½) where
ğ‘† âˆˆ Set and ğ›½ : ğ‘† â†’ ğ‘ âŠ³ ğ‘†. A ğ‘-coalgebra morphism from (ğ‘†, ğ›½) to (ğ‘†â€², ğ›½â€²) consists of a
function ğ‘“ : ğ‘† â†’ ğ‘†â€² such that the following diagram commutes:

ğ‘†

ğ‘“

ğ‘†â€²

ğ›½

ğ›½â€²

ğ‘ âŠ³ ğ‘†

ğ‘âŠ³ ğ‘“

ğ‘ âŠ³ ğ‘†â€²

(10)

We denote the category of ğ‘-coalgebras and their morphisms by ğ‘-Coalg.

Proposition 2.11. A ğ‘-coalgebra (ğ‘†, ğ›½) can be identiï¬ed with a map of polynomials

ğ‘†yğ‘† â†’ ğ‘

Proof. One ï¬nds an isomorphism Poly(ğ‘†, ğ‘âŠ³ğ‘†) (cid:27) Poly(ğ‘†yğ‘† , ğ‘) by direct calculation. (cid:3)

Warning 2.12. Looking at Proposition 2.11, one might be tempted to think that a map
of ğ‘-coalgebras as in (10) can be identiï¬ed with a commuting triangle

ğ‘†yğ‘†

?

ğ‘†â€²yğ‘†â€²

ğ‘

but this is not the case; for one thing, the marked arrow does not arise from a function
ğ‘“ : ğ‘† â†’ ğ‘†â€².

Proposition 2.13. For any ğ‘, ğ‘ âˆˆ Poly there is a functor

ğ‘-Coalg Ã— ğ‘-Coalg â†’ (ğ‘ âŠ— ğ‘)-Coalg

making â€¢-Coalg a lax monoidal functor Poly â†’ Cat.

Proof. See page 13.

(cid:3)

The relevance of coalgebras to dynamics was of interest in the earliest of references
we know of, namely [AM82], where they are referred to as codynamics. We will
proceed with our own terminology.

Deï¬nition 2.14 (Moore machine). For sets ğ´, ğµ, an (ğ´, ğµ)-Moore machine consists of

â€¢ a set ğ‘†, elements of which are called states,
â€¢ a function ğ‘Ÿ : ğ‘† â†’ ğµ, called readout, and
â€¢ a function ğ‘¢ : ğ‘† Ã— ğ´ â†’ ğ‘†, called update.

It is further called initialized if it is equipped with an element ğ‘ 0 âˆˆ ğ‘†.

6

With an initialized (ğ´, ğµ)-Moore machine (ğ‘†, ğ‘Ÿ, ğ‘¢, ğ‘ 0), we can take any ğ´-stream

ğ‘ : N â†’ ğ´ and produce a ğµ-stream ğ‘ : N â†’ ğµ inductively using the formula

ğ‘ ğ‘›+1 â‰” ğ‘¢(ğ‘ ğ‘› , ğ‘ğ‘›)

and

ğ‘ğ‘› â‰” ğ‘Ÿ(ğ‘ ğ‘›).

Proposition 2.15. An (ğ´, ğµ)-Moore machine with states ğ‘† can be identiï¬ed with a map of
polynomials ğ‘†yğ‘† â†’ ğµyğ´, and hence with a ğµyğ´-coalgebra ğ‘† â†’ ğµyğ´ âŠ³ ğ‘† by Proposition 2.11.

Proof. The identiï¬cation uses ğœ‘1 â‰” ğ‘Ÿ and ğœ‘â™¯ â‰” ğ‘¢.

(cid:3)

We can thus refer to any ğ‘-coalgebra as a generalized Moore machine, where
ğ‘ âˆˆ Poly is generalizing the monomial ğµyğ´. Mathematically, given ğ›½ : ğ‘† â†’ ğ‘ âŠ³ ğ‘†, we
also get the two-fold composite

ğ›½
âˆ’â†’ ğ‘ âŠ³ ğ‘†

ğ‘âŠ³ğ›½
âˆ’âˆ’â†’ ğ‘ âŠ³ ğ‘ âŠ³ ğ‘†

ğ‘†

and indeed the ğ‘›-fold composite ğ‘† â†’ ğ‘âŠ³ğ‘› âŠ³ ğ‘† for any ğ‘› âˆˆ N. The idea is that for every
state ğ‘  âˆˆ ğ‘†, we get a position ğ‘Ÿ(ğ‘ ) âˆˆ ğ‘(1), and for every direction ğ‘‘ âˆˆ ğ‘[ğ‘Ÿ(ğ‘ )] there, we
get a new state ğ‘¢(ğ‘ , ğ‘‘). We thus think of ğ‘ as an interface for the dynamical system:
ğ‘(1) says what the world can see about the current stateâ€”i.e. its outward position
ğ‘– â‰” ğ‘Ÿ(ğ‘ )â€”and ğ‘[ğ‘–] says what sort of forces or inputs the state can be subjected to.

A map of polynomials ğœ‘ : ğ‘ â†’ ğ‘â€² is a change of interface. We can transform a ğ‘-
dynamical system into a ğ‘â€²-dynamical system that has the same set of states. Indeed,
simply compose any ğ‘† â†’ ğ‘ âŠ³ ğ‘† with ğœ‘ âŠ³ ğ‘† : ğ‘ âŠ³ ğ‘† â†’ ğ‘â€² âŠ³ ğ‘†.

More generally, a map ğœ‘ : ğ‘1 âŠ— Â· Â· Â· âŠ— ğ‘ğ‘˜ â†’ ğ‘â€² allows us to take ğ‘˜-many dynamical
systems ğ‘†1 â†’ ğ‘1 âŠ³ ğ‘†1 through ğ‘†ğ‘˜ â†’ ğ‘ğ‘˜ âŠ³ ğ‘†ğ‘˜ and use Proposition 2.13 to combine them
into a single dynamical system

ğ‘† â†’ (ğ‘1 âŠ— Â· Â· Â· âŠ— ğ‘ğ‘˜) âŠ³ ğ‘†

ğœ‘
âˆ’â†’ ğ‘â€² âŠ³ ğ‘†

with interface ğ‘â€² and states ğ‘† â‰” ğ‘†1 Ã— Â· Â· Â· Ã— ğ‘†ğ‘˜.
Example 2.16. Wiring diagrams are one way of combining dynamical systems as above.

Controlled_Plant

ğœ‘ =

ğ´

Controller

Plant

ğ¶

ğµ

(11)

In the wiring diagram (11) three boxes are shown: the controller, the plant, and the
system; we can consider each as having a monomial interface:

Plant = ğ¶yğ´ğµ

Controller = ğµyğ¶

Controlled_Plant = ğ¶yğ´.

(12)

The wiring diagram itself represents a morphism

ğœ‘ : ğ¶yğ´ğµ âŠ— ğµyğ¶ â†’ ğ¶yğ´

7

in Poly. Deï¬ning ğœ‘ requires a function ğœ‘1 : ğ¶ Ã— ğµ â†’ ğ¶ and a function ğœ‘â™¯ : ğ¶ Ã— ğµ Ã— ğ´ â†’
ğ´Ã—ğµÃ—ğ¶; the ï¬rst is projection and the second is an isomorphism. Together these simply
say how the wiring diagram shuttles information within the controlled plant. Indeed,
the wiring diagram lets us put together dynamics of the controller and the plant to
give dynamics for the controlled plant. That is, given Moore machines ğ‘†yğ‘† â†’ Plant
and ğ‘‡yğ‘‡ â†’ Controller, we get a Moore machine ğ‘†ğ‘‡yğ‘†ğ‘‡ â†’ Controlled_Plant.

More generally, we can think of transistors in a computer as dynamical systems,
and the logic gates, adder circuits, memory circuits, a connected keyboard or monitor,
etc. each as a wiring diagram comprising these simpler systems.

Example 2.17. In Example 2.16 the wiring pattern is ï¬xed, but as we show in [Spi20],
Poly also supports wiring diagrams for dynamical systems that can change their
interaction pattern based on their internal states.

We now come to learners. As mentioned in the introduction, the category Learn
from [FST19] is better understood as a bicategory. Its objects are sets, Ob(Learn) =
Ob(Set), a 1-morphism (learner) from ğ´ to ğµ consists of a set ğ‘ƒ and maps ğ¼ : ğ´ Ã— ğ‘ƒ â†’ ğµ
and (ğ‘…, ğ‘ˆ) : ğ´ Ã— ğµ Ã— ğ‘ƒ â†’ ğ´ Ã— ğ‘ƒ, and a 2-morphismâ€”a morphism between learnersâ€”is
a map ğ‘“ : ğ‘ƒ â†’ ğ‘ƒâ€² making the following squares commute:

ğ´ Ã— ğ‘ƒ

ğ´Ã— ğ‘“

ğ´ Ã— ğ‘ƒâ€²

ğ¼

ğ¼â€²

ğµ

ğµ

ğ´ Ã— ğµ Ã— ğ‘ƒ

ğ´Ã—ğµÃ— ğ‘“

ğ´ Ã— ğµ Ã— ğ‘ƒâ€²

(ğ‘…,ğ‘ˆ)

(ğ‘…â€²,ğ‘ˆ â€²)

ğ´ Ã— ğ‘ƒ

ğ´Ã— ğ‘“

ğ´ Ã— ğ‘ƒâ€²

We denote the category of learners from ğ´ to ğµ as Learn(ğ´, ğµ).

Proposition 2.18. For sets ğ´, ğµ, there is an equivalence of categories

Learn(ğ´, ğµ) (cid:27) [ğ´yğ´, ğµyğµ]-Coalg.

Proof. See page 14.

(13)

(cid:3)

We will now give a deï¬nition that generalizes the bicategory Learn, give examples,
and discuss intuition. In particular, we deï¬ne a category-enriched operad Org, which
includes Learn as a full subcategory.

Deï¬nition 2.19 (The operad Org). We deï¬ne Org to be the category-enriched operad
deï¬ned as follows. The objects of Org are polynomials: Ob(Org) â‰” Ob(Poly). For
objects ğ‘1, . . . , ğ‘ğ‘˜ , ğ‘â€², the category of maps between them is deï¬ned by

Org(ğ‘1, . . . , ğ‘ğ‘˜; ğ‘â€²) â‰” [ğ‘1 âŠ— Â· Â· Â· âŠ— ğ‘ğ‘˜ , ğ‘â€²]-Coalg.
For any object ğ‘, the identity on ğ‘ is given by the [ğ‘, ğ‘]-coalgebra 1 â†’ [ğ‘, ğ‘](1) (cid:27)
Poly(ğ‘, ğ‘) that sends 1 â†¦â†’ idğ‘.

Given objects ğ‘1,1, . . . , ğ‘1,ğ‘—1 , . . . , ğ‘ğ‘˜,1, . . . , ğ‘ğ‘˜,ğ‘—ğ‘˜ , the composition functor

[ğ‘1,1 âŠ— Â· Â· Â· âŠ— ğ‘1,ğ‘—1 , ğ‘1]-Coalg Ã— Â· Â· Â· Ã— [ğ‘ğ‘˜,1 âŠ— Â· Â· Â· âŠ— ğ‘ğ‘˜,ğ‘—ğ‘˜ , ğ‘ğ‘˜]-Coalg

Ã— [ğ‘1 âŠ— Â· Â· Â· âŠ— ğ‘ğ‘˜ , ğ‘â€²]-Coalg â†’ [ğ‘1,1 âŠ— Â· Â· Â· âŠ— ğ‘ğ‘˜,ğ‘—ğ‘˜ , ğ‘â€²]-Coalg

is given by repeated application of the maps in (9) and Proposition 2.13.

8

How do we think of a morphism (ğ‘†, ğ›½) : (ğ‘1, . . . , ğ‘ğ‘˜) â†’ ğ‘â€² in Org? It is a dynamical
system which has a set ğ‘† of states. For every state ğ‘  âˆˆ ğ‘†, we can read out an associated
element ğ›½1(ğ‘ ) : ğ‘1 âŠ— Â· Â· Â· âŠ— ğ‘ğ‘˜ â†’ ğ‘â€²; we can think of this as a wiring diagram as in Exam-
ple 2.16 or a generalization thereof. That is, the current state ğ‘  dictates an organization
pattern ğ›½1(ğ‘ ): how outputs of the internal systems are aggregated and output from
the outer interface, and how feedback from outside is distributed internally.

But so far, this is only the readout of ğ›½. Whatâ€™s an input? An input to this system
consists of a tuple of outputs ğ‘– â‰” (ğ‘–1, . . . , ğ‘–ğ‘˜) âˆˆ ğ‘1(1) Ã— Â· Â· Â· Ã— ğ‘ğ‘˜(1), one output for each
of the internal systems, together with an input ğ‘‘ âˆˆ ğ‘â€²[ğ›½1(ğ‘–)] to the outer system.

Imagine youâ€™re the oï¬ƒcer in charge of an organization: youâ€™re in charge of how your
employees and other resources are arranged, how they send information to each other
and the outside world, and how the feedback from the outside world is disbursed to
the employees and resources. You see what they do, you see how the world responds,
and you update your internal state and the organizationâ€™s arrangement however you
see ï¬t. In this image, you as the oï¬ƒcer are playing the role of (ğ‘†, ğ›½), i.e. a morphism
in Org. But even a simple logic gate or adder circuit in a computerâ€”something that
doesnâ€™t have a changing internal state or update how resources are connectedâ€”counts
as a morphism in Org. Again, the only diï¬€erence in that case is that the state set ğ‘† (cid:27) 1,
the way the internal resources are connectedâ€”is unchanged by inputs.

Example 2.20. For any operad, there is an algebra of 0-ary morphisms. In the case of
Org, this algebra Org â†’ Cat sends ğ‘ â†¦â†’ ğ‘-Coalg, the category of dynamical systems
on ğ‘, since the unit of âŠ— is y and [y, ğ‘] (cid:27) ğ‘.

Next weâ€™ll give a mathematical language for describing dynamical systems as in

Example 2.20 as well as the generalized learners (or oï¬ƒcers) described above.

3 Toposes of learners

We ended the previous section by deï¬ning the (category-enriched) operad Org and
explaining how it generalizes the bicategory Learn. In this section we mainly discuss
the internal language for each learner. That is, given ğ‘, ğ‘â€² âˆˆ Ob(Poly) = Ob(Org),
where perhaps ğ‘ = ğ‘1 âŠ— Â· Â· Â· âŠ— ğ‘ğ‘˜, we discuss the category Org(ğ‘; ğ‘â€²) of such learners.
Our ï¬rst job is to show that every such category is a topos; this will give us access
to the Mitchell-Benabou language and Kripke-Joyal semanticsâ€”the so-called internal
language of the topos and its interpretation. We then explain the sorts of thingsâ€”
propositionsâ€”that one can express in this language, e.g. the proposition â€œI will follow
the gradient descent algorithmâ€ is a particular case.

3.1 The topos of ğ‘-coalgebras

In this section, we show that for any polynomial ğ‘, there is a category Cğ‘, called the
cofree category on ğ‘, for which we can ï¬nd an equivalence

ğ‘-Coalg (cid:27) Cğ‘-Set

9

between ğ‘-coalgebras and functors Cğ‘ â†’ Set.
graph, making it quite easy to understand in certain respects.3

In fact, the category Cğ‘ is free on a

Following [nLa21], we deï¬ne a rooted tree to be a graph ğ‘‡ whose free category has
an initial object, called the root; the idea is that for any node ğ‘›, there is exactly one path
from the root to ğ‘›. We denote the nodes of ğ‘‡ by ğ‘‡0, the root by rootğ‘‡ âˆˆ ğ‘‡0, and for any
node ğ‘› âˆˆ ğ‘‡0 we denote the set of arrows emanating from ğ‘› by ğ‘‡[ğ‘›]. Note that at the
target ğ‘›â€² of any arrow ğ‘ âˆˆ ğ‘‡[ğ‘›], there sits another rooted tree with root ğ‘›â€²; we denote
this tree by codğ‘‡(ğ‘).

Deï¬nition 3.1 (The graph Treeğ‘ of ğ‘-trees). For a polynomial ğ‘ âˆˆ Poly, deï¬ne a ğ‘-tree
to be a tuple (ğ‘‡ , ğœ™1, ğœ™â™¯), where ğ‘‡ is a rooted tree, ğœ™1 : ğ‘‡0 â†’ ğ‘(1) is a function called the
position function, and ğœ™â™¯

ğ‘› is a bÄ³ection

ğœ™â™¯

ğ‘› : ğ‘[ğœ™1(ğ‘›)]

(cid:27)
âˆ’â†’ ğ‘‡[ğ‘›]

for each node ğ‘› âˆˆ ğ‘‡0, identifying the set of branches in the tree ğ‘‡ at node ğ‘› with the
set of directions in the polynomial ğ‘ at the position ğœ™1(ğ‘›).

We denote by Treeğ‘ the graph whose vertex set is the set of ğ‘-trees, and for which

an arrow ğ‘ : ğ‘‡ â†’ ğ‘‡â€² is a branch ğ‘ âˆˆ ğ‘‡[rootğ‘‡] with ğ‘‡â€² = codğ‘‡(ğ‘).

Example 3.2. If ğ‘ = yğ´ for a nonempty set ğ´ then there is only one ğ‘-tree: each node
has the unique label ğ‘(1) (cid:27) 1 and ğ´-many branches.

If ğ‘ = {go}y1 + {stop}y0 (cid:27) y+1 then counting the number of nodes gives a bÄ³ection

between set of ğ‘-trees and the set N âˆª {âˆ}

stop
â€¢ ,

go
â€¢ â†’

stop
â€¢ ,

go
â€¢ â†’

go
â€¢ â†’

stop
â€¢ ,

...

,

go
â€¢ â†’

go
â€¢ â†’

go
â€¢ â†’ Â· Â· Â·

Theorem 3.3. For any polynomial ğ‘ there is an equivalence of categories

ğ‘-Coalg (cid:27) Treeğ‘-Set

where Treeğ‘ is the free category on the graph Treeğ‘ of ğ‘-trees.

Proof. See page 14.

(cid:3)

3.2 The internal language of ğ‘-Coalg

For any category C, the category C-Set of functors C â†’ Set forms a topos. In particular,
this means that mathematicians have already developed a language and logic that
faithfully represents the structures of C-Set, and we can import it wholesale; see
[FS19, Chapter 7] or [MM92, Chapter VI]. Now that we know from Theorem 3.3 that
ğ‘-Coalg is a topos for any ğ‘ âˆˆ Poly, we are interested in corresponding language for
the topos Learn(ğ´, ğµ) = [ğ´yğ´, ğµyğµ]-Coalg of learners, for any sets ğ´, ğµ; hence the title

3The name â€œcofree categoryâ€ comes from the fact thatâ€”up to isomorphismâ€”comonoids in Poly are

categories; see [ahman2016directed]. So weâ€™re really taking the cofree comonoid on ğ‘.

10

â€¢ â€¢

â€¢ â€¢

â€¢ â€¢

â€¢ â€¢

â€¢ â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

Figure 1: Left: a dynamical system, i.e. coalgebra, for the polynomial ğ‘ â‰” {â€¢, â€¢}y2+â€¢ (cid:27)
2y2 + 1. Right: the ğ‘-tree corresponding to the node â€¢.

â€œlearnersâ€™ languages.â€ However since most of the relevant abstractions work more
generally for ğ‘-Coalg, weâ€™ll mainly work there.

Not assuming the reader knows topos theory, we will proceed as though we are
deï¬ning the few relevant concepts from scratch, when in actuality we are merely
â€œreading them oï¬€â€ from the established literature. For example Deï¬nition 3.4 simply
unpacks the topos-theoretic deï¬nition of a logical proposition as a subobject of the
terminal object in the topos ğ‘-Coalg.

Deï¬nition 3.4. A logical proposition (about ğ‘-coalgebras) is deï¬ned to be a set ğ‘ƒ âŠ† Treeğ‘
of ğ‘-trees satisfying the condition that if ğ‘‡ âˆˆ ğ‘ƒ is a tree in ğ‘ƒ, then for any direction
ğ‘‘ âˆˆ ğ‘‡[rootğ‘‡], the tree codğ‘‡(ğ‘‘) âˆˆ ğ‘ƒ is also a tree in ğ‘ƒ.

Proposition 3.5 gives us an easy way to construct logical propositions about ğ‘-
coalgebras, and hence learners. Namely, it says if we put a condition on the ğ‘-positions
that can show up as labels, and if we put a condition on the codomain map (how
directions in the tree lead to new positions), we get a logical proposition. Of course,
these arenâ€™t the only ones, but they form a nice special case.

Recall from Deï¬nition 3.1 that a ğ‘-tree is a rooted tree ğ‘‡ equipped with a position
ğ‘› : ğ‘‡[ğ‘›] (cid:27) ğ‘[ğœ™1(ğ‘›)])

function ğœ™1 : ğ‘‡0 â†’ ğ‘(1); we elide the bÄ³ections (earlier denoted ğœ™â™¯
in what follows.

Proposition 3.5. Given ğ‘ âˆˆ Poly, suppose given subsets

ğ‘„ âŠ† ğ‘(1)

and

ğ‘… âŠ†

ğ‘„.

Ã–ğ‘–âˆˆğ‘„ Ã–ğ‘‘âˆˆğ‘[ğ‘–]

Then the following set of trees is a logical proposition:

ğ‘ƒğ‘…
ğ‘„

â‰” {ğ‘‡ âˆˆ Treeğ‘ | âˆ€(ğ‘– : ğ‘‡0).ğœ™1(ğ‘–) âˆˆ ğ‘„ âˆ§ âˆ€(ğ‘‘ : ğ‘‡[ğ‘–]). codğ‘‡(ğ‘‘) âˆˆ (ğ‘…ğ‘–ğ‘‘)}.

Proof. The result is immediate from Deï¬nition 3.4.

(cid:3)

Example 3.6 (Gradient descent). The gradient descent, backpropagation algorithm
used by each â€œneuronâ€ in a deep learning architecture can be phrased as a logical
proposition about learners. The whole learning architecture is then put together as in
[FST19], or as weâ€™ve explained things above, using the operad Org from Deï¬nition 2.19.

11

So suppose a neuron is tasked with learning a function Rğ‘š â†’ Rğ‘›, and it has a
parameter space Rğ‘˜, i.e. we are given a smooth function ğ‘“ : Rğ‘˜ Ã— Rğ‘š â†’ Rğ‘›. We will
deï¬ne a corresponding logical proposition using Proposition 3.5. Deï¬ne ğ‘ âˆˆ Poly by

ğ‘ â‰” [Rğ‘šy

Rğ‘š

Rğ‘›

, Rğ‘›y

] (cid:27)

Rğ‘š Ã—Rğ‘›

y

.

Ã•ğ‘” : Rğ‘šyRğ‘š â†’Rğ‘›yRğ‘›

Deï¬ne ğ‘„ âŠ† {(ğ‘”1, ğ‘” â™¯) | ğ‘”1 : Rğ‘š â†’ Rğ‘› , ğ‘” â™¯ : Rğ‘š Ã— Rğ‘› â†’ Rğ‘š } by saying that ğ‘”1(ğ‘¥) must be
of the form ğ‘“ (ğ‘, ğ‘¥) for some ğ‘ âˆˆ Rğ‘˜ in the parameter set and that ğ‘” â™¯
ğ‘¥ is given by â€œpulling
back gradient vectorsâ€ using the map on cotangent spaces deï¬ned by composing with
the derivative of ğ‘”1 at ğ‘¥, in the usual way.

Now given (ğ‘”1, ğ‘” â™¯) âˆˆ ğ‘„, we continue with the setup of Proposition 3.5 by deï¬ning
ğ‘…(ğ‘”1, ğ‘” â™¯) : Rğ‘š Ã— Rğ‘› â†’ ğ‘„ to say how the learner updates its current parameter value ğ‘ âˆˆ
Rğ‘˜ given an input-output pair; this again is speciï¬ed by the deep learning algorithm.
Typically, it uses a loss function to calculate a cotangent vector at ğ‘“ (ğ‘, ğ‘¥) which is
passed back to a cotangent vector at ğ‘, and a dual vector of some â€œlearning rateâ€ ğœ– is
traversed.

The details are important for implementation, but not for understanding the idea.
The idea is that as long as we say what sorts of maps are allowed (smooth maps with
reverse derivatives) and how they update, we have deï¬ned a logical proposition.

The logical propositions that come from Proposition 3.5 are very special. More
generally, one could have a logical proposition like â€œwhenever I receive two red tokens
within three seconds, I will wait ï¬ve seconds and then send either three blue tokens
or two blues and six reds.â€ As long as this behavior has the â€œwheneverâ€ ï¬‚avorâ€”more
precisely as long as it satisï¬es the condition in Deï¬nition 3.4â€”it will be a logical
proposition in the topos.

3.3 Future work

There are many avenues for future work. One is to give more syntactic languageâ€”
beyond the logical symbols true, false, âˆ§, âˆ¨, â‡’, Â¬, âˆ€, âˆƒ that exist in any toposâ€”for
building logical propositions in the ğ‘-Coalg toposes speciï¬cally. Another is to under-
stand various modalities in these toposes.

The sort of morphisms between toposes that seem to arise most naturally in this
context are not the usual kindâ€”adjoint functors E â‡† Eâ€² for which the left adjoint
preserves all ï¬nite limits, called geometric morphismsâ€”but instead adjoint functors
E â‡† Eâ€² for which the left adjoint preserves all connected limits. Thus another avenue
for future research is to consider how logical and type-theoretic statements move
between toposes that are connected in this way.

A Proofs

Proof of Proposition 2.4. It is well-known that composition of functors is a monoidal
operation, so it suï¬ƒces to see that the polynomial (6) is the composite of functors ğ‘, ğ‘.

12

To show this, we use the fact that for any set ğ´ we have a bÄ³ection yğ´ (cid:27)
calculate the composite

ğ‘âˆˆğ´ y to

Ã

ğ‘ âŠ³ ğ‘ (cid:27)

y âŠ³

y

Ã•ğ‘–âˆˆğ‘(1) Ã–ğ‘‘âˆˆğ‘[ğ‘–]

Ã•ğ‘—âˆˆğ‘(1) Ã–ğ‘’âˆˆğ‘[ğ‘—]
y

Ã•ğ‘–âˆˆğ‘(1) Ã–ğ‘‘âˆˆğ‘[ğ‘–] Ã•ğ‘—âˆˆğ‘(1) Ã–ğ‘’âˆˆğ‘[ğ‘—]

(cid:27)

(cid:27)

y (cid:27)

Ã•ğ‘–âˆˆğ‘(1) Ã•ğ‘— : ğ‘[ğ‘–]â†’ğ‘(1) Ã–ğ‘‘âˆˆğ‘[ğ‘–] Ã–ğ‘’âˆˆğ‘[ğ‘—(ğ‘‘)]

Ã•ğ‘–âˆˆğ‘(1) Ã•ğ‘— : ğ‘[ğ‘–]â†’ğ‘(1)

ğ‘‘âˆˆğ‘[ğ‘–] ğ‘[ğ‘—ğ‘‘]

y

Ã

where the ï¬rst isomorphism is (3), the second is substitution, the third is the distribu-
(cid:3)
tive law, and the fourth is properties of exponents.

Proof of Proposition 2.7. With the formula given, it is clear that the âŠ—-operation is asso-
ciative (up to isomorphism), and that y, which has y(1) (cid:27) 1 and y[1] (cid:27) y, is a unit.
One can also check that the formula is functorial in ğ‘ and ğ‘, completing the proof. (cid:3)

Proof of Proposition 2.8. The natural isomorphism is given by rearranging terms:

Poly(ğ‘Ÿ âŠ— ğ‘, ğ‘) (cid:27)

ğ‘Ÿ[ğ‘˜] Ã— ğ‘[ğ‘–]

(cid:27)

(cid:27)

(cid:27)

Ã–ğ‘˜âˆˆğ‘Ÿ(1) Ã–ğ‘–âˆˆğ‘(1) Ã•ğ‘—âˆˆğ‘(1) Ã–ğ‘’âˆˆğ‘[ğ‘—]

Ã–ğ‘˜âˆˆğ‘Ÿ(1) Ã•ğœ‘1 : ğ‘(1)â†’ğ‘(1) Ã–ğ‘–âˆˆğ‘(1) Ã–ğ‘’âˆˆğ‘[ğœ‘1(ğ‘–)]

ğ‘Ÿ[ğ‘˜] Ã— ğ‘[ğ‘–]

ğ‘[ğ‘–]

Ã—

ğ‘Ÿ[ğ‘˜]

Ã–ğ‘˜âˆˆğ‘Ÿ(1) Ã•ğœ‘1 : ğ‘(1)â†’ğ‘(1)

Â©

Ã–ğ‘–âˆˆğ‘(1) Ã–ğ‘’âˆˆğ‘[ğœ‘1(ğ‘–)]
ğ‘Ÿ[ğ‘˜]

Ã–ğ‘˜âˆˆğ‘Ÿ(1) Ã•ğœ‘ : ğ‘â†’ğ‘ Ã–ğ‘–âˆˆğ‘(1) Ã–ğ‘’âˆˆğ‘[ğœ‘1(ğ‘–)]

Â«

Âª
Â®
Â¬

Â©

Â«

Ã–ğ‘–âˆˆğ‘(1) Ã–ğ‘’âˆˆğ‘[ğœ‘1(ğ‘–)]

Âª
Â®
Â¬

(cid:27) Poly

ğ‘Ÿ,

y

Ã

Ã•ğœ‘ : ğ‘â†’ğ‘

ğ‘–âˆˆğ‘(1) ğ‘[ğœ‘1(ğ‘–)]

!

(cid:27) Poly(ğ‘Ÿ, [ğ‘, ğ‘]).

In order, these isomorphisms are given by: unfolding the deï¬nition of morphisms in
Poly, distributivity, products commuting with products, deï¬nition of morphisms in
(cid:3)
Poly, rules of exponents, and Eq. (7)â€™s deï¬nition of [ğ‘, ğ‘], respectively.

Proof of Proposition 2.13. We need to give not only the functor ğœ† : ğ‘-Coalg Ã— ğ‘-Coalg â†’
(ğ‘ âŠ— ğ‘)-Coalg, for any ğ‘, ğ‘ âˆˆ Poly but also a functor {1} â†’ y-Coalg, which we can
identify with a y-coalgebra; we take the latter to be the unique function 1 â†’ y âŠ³ 1. For
the former, one could proceed abstractly using the fact that there is a duoidal structure
on Poly

(ğ‘ âŠ³ ğ‘ ) âŠ— (ğ‘ âŠ³ ğ‘¡) â†’ (ğ‘ âŠ— ğ‘) âŠ³ (ğ‘  âŠ— ğ‘¡).
Indeed, since for sets ğ‘†, ğ‘‡ we have ğ‘† âŠ— ğ‘‡ (cid:27) ğ‘† Ã— ğ‘‡, the result will follow from the
properties of duoidal structures (applied in the case where ğ‘  â‰” ğ‘† and ğ‘¡ â‰” ğ‘‡ are
constant polynomials). However, for the readerâ€™s convenience, we will give the map
ğœ† : ğ‘-Coalg Ã— ğ‘-Coalg â†’ (ğ‘ âŠ— ğ‘)-Coalg more explicitly.

13

 
 
 
Given ğ›½ : ğ‘† â†’ ğ‘ âŠ³ ğ‘† and ğ›¾ : ğ‘‡ â†’ ğ‘ âŠ³ ğ‘‡, we deï¬ne a function

ğ‘†ğ‘‡ â†’ (ğ‘ âŠ— ğ‘) âŠ³ (ğ‘†ğ‘‡) (cid:27)

(ğ‘†ğ‘‡)ğ‘[ğ‘–]Ã—ğ‘[ğ‘—]

(ğ‘ , ğ‘¡) â†¦â†’

ğ‘– â‰” ğ›½1(ğ‘ ), ğ‘— â‰” ğ›¾1(ğ‘¡), (ğ‘‘, ğ‘’) â†¦â†’ (ğ›½â™¯

ğ‘– (ğ‘‘), ğ›¾â™¯

ğ‘— (ğ‘’)

.

Ã•ğ‘–âˆˆğ‘(1) Ã•ğ‘—âˆˆğ‘(1)

This is natural in ğ‘†, ğ‘‡, which makes ğœ† a functor for any ğ‘, ğ‘. One can check that all the
axioms of a lax monoidal functor are veriï¬ed, in the sense that the required diagrams
(cid:3)
commute up to natural isomorphism.

(cid:0)

(cid:1)

Proof of Proposition 2.18. On one hand, an object in Learn(ğ´, ğµ) as described in (2)
consists of a set ğ‘ƒ and functions ğ´ Ã— ğ‘ƒ â†’ ğµ and ğ´ Ã— ğµ Ã— ğ‘ƒ â†’ ğ´ and ğ´ Ã— ğµ Ã— ğ‘ƒ â†’ ğ‘ƒ.
On the other hand, we have [ğ´yğ´, ğµyğµ] (cid:27) ğµğ´ğ´ğ´ğµyğ´ğµ by Example 2.9, so a coalgebra
ğ‘ƒ â†’ [ğ´yğ´, ğµyğµ] âŠ³ ğ‘ƒ consists of a function ğ‘ƒ â†’ ğµğ´, a function ğ‘ƒ â†’ ğ´ğ´ğµ, and a function
ğ‘ƒ â†’ ğ‘ƒğ´ğµ. The two descriptions can be identiï¬ed by currying. The [ğ´yğ´, ğµyğµ]-Coalg
morphisms

ğ‘ƒ

ğ‘ƒâ€²

ğµğ´ğ´ğ´ğµğ‘ƒğ´ğµ

ğµğ´ğ´ğ´ğµ(ğ‘ƒâ€²)ğ´ğµ

are easily seen to coincide with those shown in (13).

(cid:3)

Proof of Theorem 3.3. It is well-known that C-Set is equivalent to the category of discrete
opï¬brations over C via the category-of-elements construction. When C is free on a
graph ğº, the category of elements for any functor â„ : C â†’ Set is also free on a graph,
say ğ».
In this case the opï¬bration can be identiï¬ed with a graph homomorphism
ğœ‹ : ğ» â†’ ğº with the property (â€œopï¬bâ€) that for any vertex â„ âˆˆ ğ», the function on arrows
(cid:27)
ğ»[â„]
âˆ’â†’ ğº[ğœ‹(â„)] induced by ğœ‹ is a bÄ³ection. Under this correspondence, a morphism
â„ â†’ â„â€² of copresheaves is identiï¬ed with a graph homomorphism ğ‘“ : ğ» â†’ ğ»â€² for
which ğœ‹ = ğœ‹â€² â—¦ ğ‘“ .

Thus we have reduced to showing that there is an equivalence between ğ‘-Coalg
and the category of those graph homomorphisms ğœ‹ : ğ» â†’ Treeğ‘ that have the opï¬b
property. Suppose given a ğ‘-coalgebra ğ›½ : ğ‘† â†’ ğ‘ âŠ³ğ‘†; it includes a function ğ›½1 : ğ‘† â†’ ğ‘(1)
and for each ğ‘  âˆˆ ğ‘† a function ğ›½â™¯
ğ‘  : ğ‘[ğ›½1(ğ‘ )] â†’ ğ‘†. We deï¬ne the corresponding graph
ğºğ‘†,ğ›½ to have vertex set ğ‘†, and each ğ‘  âˆˆ ğ‘† to have ğ‘[ğ›½1(ğ‘ )]-many outgoing arrows;
the target of each outgoing arrow ğ‘‘ âˆˆ ğ‘[ğ›½1(ğ‘ )] is deï¬ned to be ğ›½â™¯
ğ‘ (ğ‘‘). The graph
homomorphism ğœ‹ : ğºğ‘†,ğ›½ â†’ Treeğ‘ is deï¬ned inductively: for any ğ‘  âˆˆ ğ‘†, the ğ‘-tree ğœ‹(ğ‘ )
has root labeled ğ›½1(ğ‘ ), and for each outgoing branch ğ‘‘ âˆˆ ğ‘[ğ›½1(ğ‘ )] the target vertex is
assigned the label ğ›½1(ğ‘ â€²), where ğ‘ â€² â‰” ğ›½â™¯
ğ‘ (ğ‘‘), and for each outgoing branch ğ‘‘â€² âˆˆ ğ‘[ğ›½1(ğ‘ â€²)]
the target vertex is assigned the label ğ›½1(ğ‘ â€²â€²) where ğ‘ â€²â€² â‰” ğ›½â™¯
ğ‘ â€²(ğ‘‘â€²), and so on. It is clear
that ğœ‹ satisï¬es the opï¬b property, since it assigns to each vertex ğ‘  in the graph ğºğ‘†,ğ›½ a
vertex in Treeğ‘ (the ğ‘-tree ğœ‹(ğ‘ )) with the same set ğ‘[ğ›½1(ğ‘ )] of outgoing arrows.

Conversely, given a graph homomorphism ğœ‹ : ğº â†’ Treeğ‘ with the opï¬b property,
let ğ‘†ğº be the set of vertices in ğº. The required coalgebra map ğ›½ : ğ‘†ğº â†’ ğ‘ âŠ³ ğ‘†ğº consists

14

of a function ğ›½1 : ğ‘†ğº â†’ ğ‘(1) and a function ğ›½â™¯
ğ‘  : ğ‘[ğ›½1(ğ‘ )] â†’ ğ‘†ğº for every ğ‘  âˆˆ ğ‘†ğº. We
take the function ğ›½1 to send vertex ğ‘  to the root label ğœ™(rootğœ‹(ğ‘ )) for tree ğœ‹(ğ‘ ). Since
we have a bÄ³ection ğ‘[ğ›½1(ğ‘ )] (cid:27) ğº[ğ‘ ], we can take ğ›½â™¯
ğ‘  to simply be the target function
ğº[ğ‘ ] â†’ ğ‘†ğº for the graph ğº.

It is a straightforward calculation to check that these two constructions are mutually
inverse, and to check that graph homomorphisms over Treeğ‘ correspond bÄ³ectively to
(cid:3)
morphisms of ğ‘-coalgebras.

References

[AdÃ¡05]

JirÄ± AdÃ¡mek. â€œIntroduction to coalgebraâ€. In: Theory and Applications of
Categories 14.8 (2005), pp. 157â€“199 (cit. on p. 6).

[AM82] Michael A Arbib and Ernest G Manes. â€œParametrized data types do not
need highly constrained parametersâ€. In: Information and Control 52.2 (1982),
pp. 139â€“158 (cit. on p. 6).

[FS19]

[FST19]

Brendan Fong and David I. Spivak. An Invitation to Applied Category Theory:
Seven Sketches in Compositionality. Cambridge University Press, 2019 (cit. on
p. 10).

Brendan Fong, David I. Spivak, and RÃ©my TuyÃ©ras. â€œBackprop as Functor:
A compositional perspective on supervised learningâ€. In: Proceedings of the
34th Annual ACM/IEEE Symposium on Logic in Computer Science. ACM. 2019.
eprint: arXiv:1711.10455 (cit. on pp. 1, 2, 8, 11).

[Gha+16] Neil Ghani, Jules Hedges, Viktor Winschel, and Philipp Zahn. â€œComposi-
tional game theoryâ€. In: Proceedings of Logic in Computer Science (LiCS) 2018
(2016) (cit. on p. 2).

[GK12]

[Jac17]

[MM92]

[nLa21]

[Spi20]

Nicola Gambino and Joachim Kock. â€œPolynomial functors and polynomial
monadsâ€. In: Mathematical Proceedings of the Cambridge Philosophical Society
154.1 (Sept. 2012), pp. 153â€“192 (cit. on p. 4).

Bart Jacobs. Introduction to Coalgebra. Vol. 59. Cambridge University Press,
2017 (cit. on p. 6).

Saunders MacLane and Ieke MoerdÄ³k. Sheaves in Geometry and Logic: A
First Introduction to Topos Theory. Springer, 1992 (cit. on p. 10).

nLab authors. tree. http://ncatlab.org/nlab/show/tree. Revision 26.
Feb. 2021 (cit. on p. 10).

David I. Spivak. Poly: An abundant categorical setting for mode-dependent
dynamics. 2020. eprint: arXiv:2005.01894 (cit. on p. 8).

15

