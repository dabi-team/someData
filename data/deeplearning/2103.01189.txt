1
2
0
2

r
a

M
1

]
T
C
.
h
t
a
m

[

1
v
9
8
1
1
0
.
3
0
1
2
:
v
i
X
r
a

Learners’ languages

David I. Spivak

Abstract

In “Backprop as functor”, the authors show that the fundamental elements of
deep learning—gradient descent and backpropagation—can be conceptualized as
a strong monoidal functor Para(Euc) → Learn from the category of parameterized
Euclidean spaces to that of learners, a category developed explicitly to capture
parameter update and backpropagation.
It was soon realized that there is an
isomorphism Learn (cid:27) Para(SLens), where SLens is the symmetric monoidal
category of simple lenses as used in functional programming.

In this note, we observe that SLens is a full subcategory of Poly, the category
of polynomial functors in one variable, via the functor 𝐴 ↦→ 𝐴y𝐴. Using the fact
that (Poly, ⊗) is monoidal closed, we show that a map 𝐴 → 𝐵 in Para(SLens) has a
natural interpretation in terms of dynamical systems (more precisely, generalized
Moore machines) whose interface is the internal-hom type [𝐴y𝐴, 𝐵y𝐵].

Finally, we review the fact that the category 𝑝-Coalg of dynamical systems
on any 𝑝 ∈ Poly forms a topos, and consider the logical propositions that can be
stated in its internal language. We give gradient descent as an example, and we
conclude by discussing some directions for future work.

1 Introduction

In the paper “Backprop as functor” [FST19], the authors show that gradient descent
and backpropagation—as used in deep learning—can be conceptualized as a strong
monoidal functor 𝐿 : Para(Euc) → Learn from the category of parameterized euclidean
spaces to that of learners, a category developed explicitly to capture parameter update
and backpropagation. Here, Para is a monad on the category of symmetric monoidal
categories. It sends (C, 𝐼, ⊗) to a category with the same objects Ob Para(C) ≔ Ob C,
but with hom-sets that include a parameterizing object

Para(C)(𝑐1, 𝑐2) ≔ {(𝑝, 𝑓 ) | 𝑝 ∈ C, 𝑓 : 𝑐1 ⊗ 𝑝 → 𝑐2}/∼

where the parameterizing object 𝑝 is considered up to an equivalence relation ∼.1 The
composite of 𝑐1 ⊗ 𝑝1 → 𝑐2 and 𝑐2 ⊗ 𝑝2 → 𝑐3 in Para(C) has parameterizing object 𝑝1 ⊗ 𝑝2
1The equivalence relation ∼ is generated by regarding (𝑝, 𝑓 ) ∼ (𝑝′, 𝑓 ′) if there exists an epi-
morphism 𝑔 : 𝑝 ։ 𝑝′ with 𝑓 = 𝑔 # 𝑓 ′. As Bruno Gavranović points out in a recent presentation,
https://www.youtube.com/watch?v=ji8MHKlQZ9w, it is often preferable to dispense with the equiva-
lence relation and instead conceive of Para(C) as a bicategory. This is what we shall do as well.

1

 
 
 
 
 
 
and is given by the ordinary composite

𝑐1 ⊗ (𝑝1 ⊗ 𝑝2) → 𝑐2 ⊗ 𝑝2 → 𝑐3.

The domain of the backpropagation functor, Para(Euc), is thus the Para construction
applied to the Cartesian monoidal category of Euclidean spaces R𝑛 and smooth maps.
But it was soon realized that Learn is in fact also given by a Para construction,
namely there is an isomorphism Learn (cid:27) Para(SLens), where SLens is the symmetric
monoidal category of simple lenses as used in functional programming. The objects
of SLens are sets Ob(SLens) = Ob(Set), but a morphism consists of a pair of functions

SLens(𝐴, 𝐵) ≔ {( 𝑓1, 𝑓 ♯) | 𝑓1 : 𝐴 → 𝐵,

𝑓 ♯ : 𝐴 × 𝐵 → 𝐴}.

(1)

Thus a map 𝐴 → 𝐵 in Para(SLens) consists of a set 𝑃 and functions 𝑓1 : 𝐴 × 𝑃 →
𝐵 and 𝑓 ♯ : 𝐴 × 𝐵 × 𝑃 → 𝐴 × 𝑃. The authors of [FST19] developed this structure
in order to conceptualize the compositional nature of deep learning as comprising
a parameterizing set 𝑃 (often called “the space of weights and biases”) and three
functions:

𝐼 : 𝐴 × 𝑃 → 𝐵

𝑈 : 𝐴 × 𝐵 × 𝑃 → 𝑃

𝑅 : 𝐴 × 𝐵 × 𝑃 → 𝐴

implement

update

request

(2)

The implement function is a 𝑃-parameterized function 𝐴 → 𝐵, and the update and
request functions take a pair (𝑎, 𝑏) of “training data” and both updates the parameter—
e.g. by gradient descent—and returns an element of the input space 𝐴, which is used
to train another such function in the network. This last step—the request—is not just
found in deep learning as practiced, but is in fact crucial for deﬁning composition.2

But by this point, the notation (𝑃, 𝐼, 𝑈 , 𝑅) of Learn has become heavy and the
structure seems to be getting lost. Even knowing Learn (cid:27) Para(SLens) seems ad-hoc
since the morphisms (1) of SLens are—to this point—mathematically unmotivated.
This is where Poly comes in.

In this note, we observe that SLens is a full subcategory of Poly, the category
of polynomial functors in one variable, via the functor 𝐴 ↦→ 𝐴y𝐴. Using the fact
that (Poly, ⊗) is monoidal closed, we will reconceptualize Para(SLens) in terms of
polynomial coalgebras, which can be understood as dynamical systems: machines
with states that can be observed as “output” and updated based on “input”.
In
particular, a morphism 𝐴 → 𝐵 in Learn will be recast as a coalgebra on the internal
hom polynomial [𝐴y𝐴, 𝐵y𝐵], and we will explain this in terms of dynamics.

This viewpoint allows us to substantially generalize the construction in Learn, a
construction which also appears prominently in the theory of open games [Gha+16].

2The reader can check that given only (𝑃, 𝐼, 𝑈) : 𝐴 → 𝐵 and (𝑄, 𝐽, 𝑉) : 𝐵 → 𝐶, one can construct a
composed parameter set 𝑃 × 𝑄, and one can construct a composed implement function 𝐴 × 𝑃 × 𝑄 → 𝐶,
but one cannot construct an associative update operation 𝐴 × 𝐶 × 𝑃 × 𝑄 → 𝑃 × 𝑄. In order to get it, one
needs the request function 𝐵 × 𝐶 × 𝑄 → 𝐵. By endowing morphisms with the request function, as in
Learn (2), composition and a monoidal structure is easily deﬁned.

2

Perhaps more interestingly, it allows us to use we the fact that the category 𝑝-Coalg
of dynamical systems on any interface 𝑝 ∈ Poly forms a topos. A topos is a setting in
which one can do dependent type theory and higher-order logic. In fact, the topos of
𝑝-coalgebras is in some ways as simple as possible: it is not only a copresheaf topos
𝑝-Coalg (cid:27) SetC for a certain category C, but in fact the site C is the free category
on a directed graph that we’ll call Tree𝑝. This makes the logic of 𝑝-coalgebras—and
hence of dynamical systems, learners, and game-players—quite simple. However, the
particular graph Tree𝑝 associated to 𝑝 is highly-structured, and we should ﬁnd that
this structure is inherited by the internal language of 𝑝-Coalg.

The point is to consider logical propositions that can be stated in the internal
language of 𝑝-Coalg and to use these propositions in order to constrain the behavior
of learners and game-players (categoriﬁed as discussed above), and of interaction
patterns between dynamical systems more generally. For example, “gradient descent
and backpropagation” is a property we can express in the internal language.

Plan for the paper

In Section 2 we will discuss various relevant constructions in the category Poly of poly-
nomial functors in one variable. In particular, we will review its symmetric monoidal
closed structure (Poly, y, ⊗, [−, −]), its composition monoidal structure (y, ⊳), and the
notion of coalgebras. We explain how morphisms in Learn can be phrased in terms of
coalgebras on internal hom objects, and we reconstruct Para(SLens) in these terms.

In Section 3, we ﬁrst show that the category 𝑝-Coalg of 𝑝-coalgebras for the endo-
functor 𝑝 : Set → Set is a presheaf topos. We then discuss the internal logic of 𝑝-Coalg,
and we conclude by giving several directions for future work.

Notation

We denote the category of sets by Set; we generally denote sets with upper-case letters
𝐴, 𝐵, etc. Given a natural number 𝑁 ∈ N, we write N ≔ {1, . . . , 𝑁 }, so 0 = ∅, 1 = {1},
2 = {1, 2}, etc. Given sets 𝐴, 𝐵, we often write 𝐴𝐵 ≔ 𝐴 × 𝐵 to denote their Cartesian
product.

We will denote polynomials with lower-case letters, 𝑝, 𝑞, etc.

Acknowledgments

We thank David A. Dalrymple, Dai Girardo, Paul Kreiner, David Jaz Myers, and
Alex Zhu for useful conversations. We also acknowledge support from AFOSR grant
FA9550-20-10348.

3

2 Constructions in Poly

In this section we review the category Poly, for which [GK12] is an excellent reference;
we also discuss its symmetric monoidal closed structure. Then we discuss polynomial
coalgebras and reconceptualize the category Learn and Gavranović’s bicategorical
variant, in that language.

2.1 Background on Poly as a monoidal closed category

For any set 𝐴, let y𝐴 : Set → Set be the functor represented by 𝐴; that is, y𝐴 applied to
a set 𝑆 is Set(𝐴, 𝑆) (cid:27) 𝑆𝐴. In particular, y ≔ y1 is (isomorphic to) the identity functor
𝑆 ↦→ 𝑆 and 1 ≔ y0 is the constant functor 𝑆 ↦→ 1. Note that y𝐴(1) (cid:27) 1𝐴 (cid:27) 1 for any 𝐴.
The coproduct of functors 𝐹 and 𝐺, denoted 𝐹 + 𝐺, is taken pointwise; this means

there is a natural isomorphism

(𝐹 + 𝐺)(𝑆) (cid:27) 𝐹(𝑆) + 𝐺(𝑆)

where the coproduct 𝐹(𝑆) + 𝐺(𝑆) is taken in Set. Similarly, for any set 𝐼 and functors
𝐹𝑖, one for each 𝑖 ∈ 𝐼, their coproduct is computed pointwise

(𝑆) (cid:27)

𝐹𝑖

!

Õ𝑖∈𝐼

Õ𝑖∈𝐼

𝐹𝑖(𝑆).

Deﬁnition 2.1. A polynomial functor 𝑝 is any coproduct

𝑝 ≔

y𝑝[𝑖]

Õ𝑖∈𝐼
of representable functors, where 𝐼 ∈ Set and each 𝑝[𝑖] ∈ Set are sets. We denote the
category of polynomial functors and natural transformations between them by Poly.

We note that if 𝑝 =

𝑖∈𝐼 y𝑝[𝑖] then 𝑝(1) (cid:27) 𝐼; hence we can write any 𝑝 ∈ Poly in

canonical form

Í

𝑝 (cid:27)

y𝑝[𝑖].

Õ𝑖∈𝑝(1)

(3)

We refer to each 𝑖 ∈ 𝑝(1) as a position in 𝑝 and to each 𝑑 ∈ 𝑝[𝑖] as a direction at 𝑖.

Example 2.2. We can consider any set 𝑆 as a constant polynomial

𝑠∈𝑆 y0.

We can consider a polynomial 𝑝 ∈ Poly as a set (or discrete category) 𝑝(1) equipped
with a functor 𝑝[−] : 𝑝(1) → Set. Then a map of polynomials 𝜑 : 𝑝 → 𝑞 can be
identiﬁed with a diagram as follows

Í

𝑞(1)

𝑞[−]

𝑝(1)

𝑝[−]

𝜑1

⇐
𝜑♯

Set

4

(4)

 
That is, 𝜑 can be decomposed into a function 𝜑1 : 𝑝(1) → 𝑞(1) on positions, and for
every 𝑖 ∈ 𝑝(1) with 𝑗 ≔ 𝜑1(𝑖), a component function 𝜑♯
𝑖 : 𝑞[𝑗] → 𝑝[𝑖] on directions.
This follows from the Yoneda lemma and the universal property of coproducts. We
will sometimes use this (𝜑1, 𝜑♯) : 𝑝 → 𝑞 notation below.
Example 2.3. A morphism 𝐴1y𝐴2 → 𝐵1y𝐵2 can be identiﬁed with a function 𝜑1 : 𝐴1 →
𝐵1 and a function 𝜑♯ : 𝐴1 × 𝐵2 → 𝐴2. That is,

Poly(𝐴1y𝐴2 , 𝐵1y𝐵2) (cid:27) 𝐵𝐴1

1 𝐴𝐴1𝐵2

2

.

(5)

Proposition 2.4. The composite of polynomial functors 𝑝, 𝑞 ∈ Poly, which we denote 𝑝 ⊳ 𝑞,
is again polynomial with formula

𝑝 ⊳ 𝑞 (cid:27)

𝑑∈𝑝[𝑖] 𝑞[𝑗𝑑]

y

Õ𝑖∈𝑝(1) Õ𝑗 : 𝑝[𝑖]→𝑞(1)
The composition operation ⊳ is a (nonsymmetric) monoidal structure on Poly, with unit y.

Í

Proof. See page 12.

(6)

(cid:3)

Example 2.5. If 𝑝 = y2 and 𝑞 = y + 1, then 𝑝 ⊳ 𝑞 (cid:27) y2 + 2y + 1 whereas 𝑞 ⊳ 𝑝 (cid:27) y2 + 1.
Example 2.6. Applying a polynomial 𝑝 to a set 𝑆 is given by composition: 𝑝(𝑆) (cid:27) 𝑝 ⊳ 𝑆.

Proposition 2.7 (The symmetric monoidal category (Poly, y, ⊗)). The category Poly has
a symmetric monoidal structure with unit y and monoidal product ⊗ on objects given by the
following formula

𝑝 ⊗ 𝑞 ≔

y𝑝[𝑖]×𝑞[𝑗]

Õ𝑖∈𝑝(1) Õ𝑗∈𝑞(1)

Proof. See page 13.

(cid:3)

Proposition 2.8 (Internal hom [−, −]). The ⊗ monoidal structure on Poly is closed; that is,
for every 𝑝, 𝑞 ∈ Poly there is a polynomial

[𝑝, 𝑞] ≔

y

Í

Õ𝜑 : 𝑝→𝑞

𝑖∈𝑝(1) 𝑞[𝜑1(𝑖)]

for which we have a natural isomorphism

Poly(𝑟 ⊗ 𝑝, 𝑞) (cid:27) Poly(𝑟, [𝑝, 𝑞]).

Proof. See page 13.

(7)

(8)

(cid:3)

Example 2.9. Given sets 𝐴 and 𝐵, we use Eqs. (5) and (7) to compute that the internal
hom between 𝐴y𝐴 and 𝐵y𝐵 is

[𝐴y𝐴, 𝐵y𝐵] (cid:27) 𝐵𝐴𝐴𝐴𝐵y𝐴𝐵.

The counit of the adjunction (8) is a natural map eval : 𝑝 ⊗ [𝑝, 𝑞] → 𝑞 called eval-
uation. In very much the same way, it induces two sorts of morphisms we will use
later:

[𝑝1, 𝑞1] ⊗ [𝑝2, 𝑞2] → [𝑝1 ⊗ 𝑝2, 𝑞1 ⊗ 𝑞2]

and

[𝑝, 𝑞] ⊗ [𝑞, 𝑟] → [𝑝, 𝑟].

(9)

5

2.2 Coalgebras, generalized Moore machines, and learners

Coalgebras for endofunctors 𝐹 : Set → Set form a major topic of study [AM82; Adá05;
Jac17]. In this section we recall the deﬁnition and explain the relevance to dynamical
systems (generalized Moore machines) and learners.

Deﬁnition 2.10 (Coalgebra). Given a polynomial 𝑝, a 𝑝-coalgebra is a pair (𝑆, 𝛽) where
𝑆 ∈ Set and 𝛽 : 𝑆 → 𝑝 ⊳ 𝑆. A 𝑝-coalgebra morphism from (𝑆, 𝛽) to (𝑆′, 𝛽′) consists of a
function 𝑓 : 𝑆 → 𝑆′ such that the following diagram commutes:

𝑆

𝑓

𝑆′

𝛽

𝛽′

𝑝 ⊳ 𝑆

𝑝⊳ 𝑓

𝑝 ⊳ 𝑆′

(10)

We denote the category of 𝑝-coalgebras and their morphisms by 𝑝-Coalg.

Proposition 2.11. A 𝑝-coalgebra (𝑆, 𝛽) can be identiﬁed with a map of polynomials

𝑆y𝑆 → 𝑝

Proof. One ﬁnds an isomorphism Poly(𝑆, 𝑝⊳𝑆) (cid:27) Poly(𝑆y𝑆 , 𝑝) by direct calculation. (cid:3)

Warning 2.12. Looking at Proposition 2.11, one might be tempted to think that a map
of 𝑝-coalgebras as in (10) can be identiﬁed with a commuting triangle

𝑆y𝑆

?

𝑆′y𝑆′

𝑝

but this is not the case; for one thing, the marked arrow does not arise from a function
𝑓 : 𝑆 → 𝑆′.

Proposition 2.13. For any 𝑝, 𝑞 ∈ Poly there is a functor

𝑝-Coalg × 𝑞-Coalg → (𝑝 ⊗ 𝑞)-Coalg

making •-Coalg a lax monoidal functor Poly → Cat.

Proof. See page 13.

(cid:3)

The relevance of coalgebras to dynamics was of interest in the earliest of references
we know of, namely [AM82], where they are referred to as codynamics. We will
proceed with our own terminology.

Deﬁnition 2.14 (Moore machine). For sets 𝐴, 𝐵, an (𝐴, 𝐵)-Moore machine consists of

• a set 𝑆, elements of which are called states,
• a function 𝑟 : 𝑆 → 𝐵, called readout, and
• a function 𝑢 : 𝑆 × 𝐴 → 𝑆, called update.

It is further called initialized if it is equipped with an element 𝑠0 ∈ 𝑆.

6

With an initialized (𝐴, 𝐵)-Moore machine (𝑆, 𝑟, 𝑢, 𝑠0), we can take any 𝐴-stream

𝑎 : N → 𝐴 and produce a 𝐵-stream 𝑏 : N → 𝐵 inductively using the formula

𝑠𝑛+1 ≔ 𝑢(𝑠𝑛 , 𝑎𝑛)

and

𝑏𝑛 ≔ 𝑟(𝑠𝑛).

Proposition 2.15. An (𝐴, 𝐵)-Moore machine with states 𝑆 can be identiﬁed with a map of
polynomials 𝑆y𝑆 → 𝐵y𝐴, and hence with a 𝐵y𝐴-coalgebra 𝑆 → 𝐵y𝐴 ⊳ 𝑆 by Proposition 2.11.

Proof. The identiﬁcation uses 𝜑1 ≔ 𝑟 and 𝜑♯ ≔ 𝑢.

(cid:3)

We can thus refer to any 𝑝-coalgebra as a generalized Moore machine, where
𝑝 ∈ Poly is generalizing the monomial 𝐵y𝐴. Mathematically, given 𝛽 : 𝑆 → 𝑝 ⊳ 𝑆, we
also get the two-fold composite

𝛽
−→ 𝑝 ⊳ 𝑆

𝑝⊳𝛽
−−→ 𝑝 ⊳ 𝑝 ⊳ 𝑆

𝑆

and indeed the 𝑛-fold composite 𝑆 → 𝑝⊳𝑛 ⊳ 𝑆 for any 𝑛 ∈ N. The idea is that for every
state 𝑠 ∈ 𝑆, we get a position 𝑟(𝑠) ∈ 𝑝(1), and for every direction 𝑑 ∈ 𝑝[𝑟(𝑠)] there, we
get a new state 𝑢(𝑠, 𝑑). We thus think of 𝑝 as an interface for the dynamical system:
𝑝(1) says what the world can see about the current state—i.e. its outward position
𝑖 ≔ 𝑟(𝑠)—and 𝑝[𝑖] says what sort of forces or inputs the state can be subjected to.

A map of polynomials 𝜑 : 𝑝 → 𝑝′ is a change of interface. We can transform a 𝑝-
dynamical system into a 𝑝′-dynamical system that has the same set of states. Indeed,
simply compose any 𝑆 → 𝑝 ⊳ 𝑆 with 𝜑 ⊳ 𝑆 : 𝑝 ⊳ 𝑆 → 𝑝′ ⊳ 𝑆.

More generally, a map 𝜑 : 𝑝1 ⊗ · · · ⊗ 𝑝𝑘 → 𝑝′ allows us to take 𝑘-many dynamical
systems 𝑆1 → 𝑝1 ⊳ 𝑆1 through 𝑆𝑘 → 𝑝𝑘 ⊳ 𝑆𝑘 and use Proposition 2.13 to combine them
into a single dynamical system

𝑆 → (𝑝1 ⊗ · · · ⊗ 𝑝𝑘) ⊳ 𝑆

𝜑
−→ 𝑝′ ⊳ 𝑆

with interface 𝑝′ and states 𝑆 ≔ 𝑆1 × · · · × 𝑆𝑘.
Example 2.16. Wiring diagrams are one way of combining dynamical systems as above.

Controlled_Plant

𝜑 =

𝐴

Controller

Plant

𝐶

𝐵

(11)

In the wiring diagram (11) three boxes are shown: the controller, the plant, and the
system; we can consider each as having a monomial interface:

Plant = 𝐶y𝐴𝐵

Controller = 𝐵y𝐶

Controlled_Plant = 𝐶y𝐴.

(12)

The wiring diagram itself represents a morphism

𝜑 : 𝐶y𝐴𝐵 ⊗ 𝐵y𝐶 → 𝐶y𝐴

7

in Poly. Deﬁning 𝜑 requires a function 𝜑1 : 𝐶 × 𝐵 → 𝐶 and a function 𝜑♯ : 𝐶 × 𝐵 × 𝐴 →
𝐴×𝐵×𝐶; the ﬁrst is projection and the second is an isomorphism. Together these simply
say how the wiring diagram shuttles information within the controlled plant. Indeed,
the wiring diagram lets us put together dynamics of the controller and the plant to
give dynamics for the controlled plant. That is, given Moore machines 𝑆y𝑆 → Plant
and 𝑇y𝑇 → Controller, we get a Moore machine 𝑆𝑇y𝑆𝑇 → Controlled_Plant.

More generally, we can think of transistors in a computer as dynamical systems,
and the logic gates, adder circuits, memory circuits, a connected keyboard or monitor,
etc. each as a wiring diagram comprising these simpler systems.

Example 2.17. In Example 2.16 the wiring pattern is ﬁxed, but as we show in [Spi20],
Poly also supports wiring diagrams for dynamical systems that can change their
interaction pattern based on their internal states.

We now come to learners. As mentioned in the introduction, the category Learn
from [FST19] is better understood as a bicategory. Its objects are sets, Ob(Learn) =
Ob(Set), a 1-morphism (learner) from 𝐴 to 𝐵 consists of a set 𝑃 and maps 𝐼 : 𝐴 × 𝑃 → 𝐵
and (𝑅, 𝑈) : 𝐴 × 𝐵 × 𝑃 → 𝐴 × 𝑃, and a 2-morphism—a morphism between learners—is
a map 𝑓 : 𝑃 → 𝑃′ making the following squares commute:

𝐴 × 𝑃

𝐴× 𝑓

𝐴 × 𝑃′

𝐼

𝐼′

𝐵

𝐵

𝐴 × 𝐵 × 𝑃

𝐴×𝐵× 𝑓

𝐴 × 𝐵 × 𝑃′

(𝑅,𝑈)

(𝑅′,𝑈 ′)

𝐴 × 𝑃

𝐴× 𝑓

𝐴 × 𝑃′

We denote the category of learners from 𝐴 to 𝐵 as Learn(𝐴, 𝐵).

Proposition 2.18. For sets 𝐴, 𝐵, there is an equivalence of categories

Learn(𝐴, 𝐵) (cid:27) [𝐴y𝐴, 𝐵y𝐵]-Coalg.

Proof. See page 14.

(13)

(cid:3)

We will now give a deﬁnition that generalizes the bicategory Learn, give examples,
and discuss intuition. In particular, we deﬁne a category-enriched operad Org, which
includes Learn as a full subcategory.

Deﬁnition 2.19 (The operad Org). We deﬁne Org to be the category-enriched operad
deﬁned as follows. The objects of Org are polynomials: Ob(Org) ≔ Ob(Poly). For
objects 𝑝1, . . . , 𝑝𝑘 , 𝑝′, the category of maps between them is deﬁned by

Org(𝑝1, . . . , 𝑝𝑘; 𝑝′) ≔ [𝑝1 ⊗ · · · ⊗ 𝑝𝑘 , 𝑝′]-Coalg.
For any object 𝑝, the identity on 𝑝 is given by the [𝑝, 𝑝]-coalgebra 1 → [𝑝, 𝑝](1) (cid:27)
Poly(𝑝, 𝑝) that sends 1 ↦→ id𝑝.

Given objects 𝑝1,1, . . . , 𝑝1,𝑗1 , . . . , 𝑝𝑘,1, . . . , 𝑝𝑘,𝑗𝑘 , the composition functor

[𝑝1,1 ⊗ · · · ⊗ 𝑝1,𝑗1 , 𝑝1]-Coalg × · · · × [𝑝𝑘,1 ⊗ · · · ⊗ 𝑝𝑘,𝑗𝑘 , 𝑝𝑘]-Coalg

× [𝑝1 ⊗ · · · ⊗ 𝑝𝑘 , 𝑝′]-Coalg → [𝑝1,1 ⊗ · · · ⊗ 𝑝𝑘,𝑗𝑘 , 𝑝′]-Coalg

is given by repeated application of the maps in (9) and Proposition 2.13.

8

How do we think of a morphism (𝑆, 𝛽) : (𝑝1, . . . , 𝑝𝑘) → 𝑝′ in Org? It is a dynamical
system which has a set 𝑆 of states. For every state 𝑠 ∈ 𝑆, we can read out an associated
element 𝛽1(𝑠) : 𝑝1 ⊗ · · · ⊗ 𝑝𝑘 → 𝑝′; we can think of this as a wiring diagram as in Exam-
ple 2.16 or a generalization thereof. That is, the current state 𝑠 dictates an organization
pattern 𝛽1(𝑠): how outputs of the internal systems are aggregated and output from
the outer interface, and how feedback from outside is distributed internally.

But so far, this is only the readout of 𝛽. What’s an input? An input to this system
consists of a tuple of outputs 𝑖 ≔ (𝑖1, . . . , 𝑖𝑘) ∈ 𝑝1(1) × · · · × 𝑝𝑘(1), one output for each
of the internal systems, together with an input 𝑑 ∈ 𝑝′[𝛽1(𝑖)] to the outer system.

Imagine you’re the oﬃcer in charge of an organization: you’re in charge of how your
employees and other resources are arranged, how they send information to each other
and the outside world, and how the feedback from the outside world is disbursed to
the employees and resources. You see what they do, you see how the world responds,
and you update your internal state and the organization’s arrangement however you
see ﬁt. In this image, you as the oﬃcer are playing the role of (𝑆, 𝛽), i.e. a morphism
in Org. But even a simple logic gate or adder circuit in a computer—something that
doesn’t have a changing internal state or update how resources are connected—counts
as a morphism in Org. Again, the only diﬀerence in that case is that the state set 𝑆 (cid:27) 1,
the way the internal resources are connected—is unchanged by inputs.

Example 2.20. For any operad, there is an algebra of 0-ary morphisms. In the case of
Org, this algebra Org → Cat sends 𝑝 ↦→ 𝑝-Coalg, the category of dynamical systems
on 𝑝, since the unit of ⊗ is y and [y, 𝑝] (cid:27) 𝑝.

Next we’ll give a mathematical language for describing dynamical systems as in

Example 2.20 as well as the generalized learners (or oﬃcers) described above.

3 Toposes of learners

We ended the previous section by deﬁning the (category-enriched) operad Org and
explaining how it generalizes the bicategory Learn. In this section we mainly discuss
the internal language for each learner. That is, given 𝑝, 𝑝′ ∈ Ob(Poly) = Ob(Org),
where perhaps 𝑝 = 𝑝1 ⊗ · · · ⊗ 𝑝𝑘, we discuss the category Org(𝑝; 𝑝′) of such learners.
Our ﬁrst job is to show that every such category is a topos; this will give us access
to the Mitchell-Benabou language and Kripke-Joyal semantics—the so-called internal
language of the topos and its interpretation. We then explain the sorts of things—
propositions—that one can express in this language, e.g. the proposition “I will follow
the gradient descent algorithm” is a particular case.

3.1 The topos of 𝑝-coalgebras

In this section, we show that for any polynomial 𝑝, there is a category C𝑝, called the
cofree category on 𝑝, for which we can ﬁnd an equivalence

𝑝-Coalg (cid:27) C𝑝-Set

9

between 𝑝-coalgebras and functors C𝑝 → Set.
graph, making it quite easy to understand in certain respects.3

In fact, the category C𝑝 is free on a

Following [nLa21], we deﬁne a rooted tree to be a graph 𝑇 whose free category has
an initial object, called the root; the idea is that for any node 𝑛, there is exactly one path
from the root to 𝑛. We denote the nodes of 𝑇 by 𝑇0, the root by root𝑇 ∈ 𝑇0, and for any
node 𝑛 ∈ 𝑇0 we denote the set of arrows emanating from 𝑛 by 𝑇[𝑛]. Note that at the
target 𝑛′ of any arrow 𝑎 ∈ 𝑇[𝑛], there sits another rooted tree with root 𝑛′; we denote
this tree by cod𝑇(𝑎).

Deﬁnition 3.1 (The graph Tree𝑝 of 𝑝-trees). For a polynomial 𝑝 ∈ Poly, deﬁne a 𝑝-tree
to be a tuple (𝑇 , 𝜙1, 𝜙♯), where 𝑇 is a rooted tree, 𝜙1 : 𝑇0 → 𝑝(1) is a function called the
position function, and 𝜙♯

𝑛 is a bĳection

𝜙♯

𝑛 : 𝑝[𝜙1(𝑛)]

(cid:27)
−→ 𝑇[𝑛]

for each node 𝑛 ∈ 𝑇0, identifying the set of branches in the tree 𝑇 at node 𝑛 with the
set of directions in the polynomial 𝑝 at the position 𝜙1(𝑛).

We denote by Tree𝑝 the graph whose vertex set is the set of 𝑝-trees, and for which

an arrow 𝑎 : 𝑇 → 𝑇′ is a branch 𝑎 ∈ 𝑇[root𝑇] with 𝑇′ = cod𝑇(𝑎).

Example 3.2. If 𝑝 = y𝐴 for a nonempty set 𝐴 then there is only one 𝑝-tree: each node
has the unique label 𝑝(1) (cid:27) 1 and 𝐴-many branches.

If 𝑝 = {go}y1 + {stop}y0 (cid:27) y+1 then counting the number of nodes gives a bĳection

between set of 𝑝-trees and the set N ∪ {∞}

stop
• ,

go
• →

stop
• ,

go
• →

go
• →

stop
• ,

...

,

go
• →

go
• →

go
• → · · ·

Theorem 3.3. For any polynomial 𝑝 there is an equivalence of categories

𝑝-Coalg (cid:27) Tree𝑝-Set

where Tree𝑝 is the free category on the graph Tree𝑝 of 𝑝-trees.

Proof. See page 14.

(cid:3)

3.2 The internal language of 𝑝-Coalg

For any category C, the category C-Set of functors C → Set forms a topos. In particular,
this means that mathematicians have already developed a language and logic that
faithfully represents the structures of C-Set, and we can import it wholesale; see
[FS19, Chapter 7] or [MM92, Chapter VI]. Now that we know from Theorem 3.3 that
𝑝-Coalg is a topos for any 𝑝 ∈ Poly, we are interested in corresponding language for
the topos Learn(𝐴, 𝐵) = [𝐴y𝐴, 𝐵y𝐵]-Coalg of learners, for any sets 𝐴, 𝐵; hence the title

3The name “cofree category” comes from the fact that—up to isomorphism—comonoids in Poly are

categories; see [ahman2016directed]. So we’re really taking the cofree comonoid on 𝑝.

10

• •

• •

• •

• •

• •

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

Figure 1: Left: a dynamical system, i.e. coalgebra, for the polynomial 𝑝 ≔ {•, •}y2+• (cid:27)
2y2 + 1. Right: the 𝑝-tree corresponding to the node •.

“learners’ languages.” However since most of the relevant abstractions work more
generally for 𝑝-Coalg, we’ll mainly work there.

Not assuming the reader knows topos theory, we will proceed as though we are
deﬁning the few relevant concepts from scratch, when in actuality we are merely
“reading them oﬀ” from the established literature. For example Deﬁnition 3.4 simply
unpacks the topos-theoretic deﬁnition of a logical proposition as a subobject of the
terminal object in the topos 𝑝-Coalg.

Deﬁnition 3.4. A logical proposition (about 𝑝-coalgebras) is deﬁned to be a set 𝑃 ⊆ Tree𝑝
of 𝑝-trees satisfying the condition that if 𝑇 ∈ 𝑃 is a tree in 𝑃, then for any direction
𝑑 ∈ 𝑇[root𝑇], the tree cod𝑇(𝑑) ∈ 𝑃 is also a tree in 𝑃.

Proposition 3.5 gives us an easy way to construct logical propositions about 𝑝-
coalgebras, and hence learners. Namely, it says if we put a condition on the 𝑝-positions
that can show up as labels, and if we put a condition on the codomain map (how
directions in the tree lead to new positions), we get a logical proposition. Of course,
these aren’t the only ones, but they form a nice special case.

Recall from Deﬁnition 3.1 that a 𝑝-tree is a rooted tree 𝑇 equipped with a position
𝑛 : 𝑇[𝑛] (cid:27) 𝑝[𝜙1(𝑛)])

function 𝜙1 : 𝑇0 → 𝑝(1); we elide the bĳections (earlier denoted 𝜙♯
in what follows.

Proposition 3.5. Given 𝑝 ∈ Poly, suppose given subsets

𝑄 ⊆ 𝑝(1)

and

𝑅 ⊆

𝑄.

Ö𝑖∈𝑄 Ö𝑑∈𝑝[𝑖]

Then the following set of trees is a logical proposition:

𝑃𝑅
𝑄

≔ {𝑇 ∈ Tree𝑝 | ∀(𝑖 : 𝑇0).𝜙1(𝑖) ∈ 𝑄 ∧ ∀(𝑑 : 𝑇[𝑖]). cod𝑇(𝑑) ∈ (𝑅𝑖𝑑)}.

Proof. The result is immediate from Deﬁnition 3.4.

(cid:3)

Example 3.6 (Gradient descent). The gradient descent, backpropagation algorithm
used by each “neuron” in a deep learning architecture can be phrased as a logical
proposition about learners. The whole learning architecture is then put together as in
[FST19], or as we’ve explained things above, using the operad Org from Deﬁnition 2.19.

11

So suppose a neuron is tasked with learning a function R𝑚 → R𝑛, and it has a
parameter space R𝑘, i.e. we are given a smooth function 𝑓 : R𝑘 × R𝑚 → R𝑛. We will
deﬁne a corresponding logical proposition using Proposition 3.5. Deﬁne 𝑝 ∈ Poly by

𝑝 ≔ [R𝑚y

R𝑚

R𝑛

, R𝑛y

] (cid:27)

R𝑚 ×R𝑛

y

.

Õ𝑔 : R𝑚yR𝑚 →R𝑛yR𝑛

Deﬁne 𝑄 ⊆ {(𝑔1, 𝑔 ♯) | 𝑔1 : R𝑚 → R𝑛 , 𝑔 ♯ : R𝑚 × R𝑛 → R𝑚 } by saying that 𝑔1(𝑥) must be
of the form 𝑓 (𝑎, 𝑥) for some 𝑎 ∈ R𝑘 in the parameter set and that 𝑔 ♯
𝑥 is given by “pulling
back gradient vectors” using the map on cotangent spaces deﬁned by composing with
the derivative of 𝑔1 at 𝑥, in the usual way.

Now given (𝑔1, 𝑔 ♯) ∈ 𝑄, we continue with the setup of Proposition 3.5 by deﬁning
𝑅(𝑔1, 𝑔 ♯) : R𝑚 × R𝑛 → 𝑄 to say how the learner updates its current parameter value 𝑎 ∈
R𝑘 given an input-output pair; this again is speciﬁed by the deep learning algorithm.
Typically, it uses a loss function to calculate a cotangent vector at 𝑓 (𝑎, 𝑥) which is
passed back to a cotangent vector at 𝑎, and a dual vector of some “learning rate” 𝜖 is
traversed.

The details are important for implementation, but not for understanding the idea.
The idea is that as long as we say what sorts of maps are allowed (smooth maps with
reverse derivatives) and how they update, we have deﬁned a logical proposition.

The logical propositions that come from Proposition 3.5 are very special. More
generally, one could have a logical proposition like “whenever I receive two red tokens
within three seconds, I will wait ﬁve seconds and then send either three blue tokens
or two blues and six reds.” As long as this behavior has the “whenever” ﬂavor—more
precisely as long as it satisﬁes the condition in Deﬁnition 3.4—it will be a logical
proposition in the topos.

3.3 Future work

There are many avenues for future work. One is to give more syntactic language—
beyond the logical symbols true, false, ∧, ∨, ⇒, ¬, ∀, ∃ that exist in any topos—for
building logical propositions in the 𝑝-Coalg toposes speciﬁcally. Another is to under-
stand various modalities in these toposes.

The sort of morphisms between toposes that seem to arise most naturally in this
context are not the usual kind—adjoint functors E ⇆ E′ for which the left adjoint
preserves all ﬁnite limits, called geometric morphisms—but instead adjoint functors
E ⇆ E′ for which the left adjoint preserves all connected limits. Thus another avenue
for future research is to consider how logical and type-theoretic statements move
between toposes that are connected in this way.

A Proofs

Proof of Proposition 2.4. It is well-known that composition of functors is a monoidal
operation, so it suﬃces to see that the polynomial (6) is the composite of functors 𝑝, 𝑞.

12

To show this, we use the fact that for any set 𝐴 we have a bĳection y𝐴 (cid:27)
calculate the composite

𝑎∈𝐴 y to

Î

𝑝 ⊳ 𝑞 (cid:27)

y ⊳

y

Õ𝑖∈𝑝(1) Ö𝑑∈𝑝[𝑖]

Õ𝑗∈𝑞(1) Ö𝑒∈𝑞[𝑗]
y

Õ𝑖∈𝑝(1) Ö𝑑∈𝑝[𝑖] Õ𝑗∈𝑞(1) Ö𝑒∈𝑞[𝑗]

(cid:27)

(cid:27)

y (cid:27)

Õ𝑖∈𝑝(1) Õ𝑗 : 𝑝[𝑖]→𝑞(1) Ö𝑑∈𝑝[𝑖] Ö𝑒∈𝑞[𝑗(𝑑)]

Õ𝑖∈𝑝(1) Õ𝑗 : 𝑝[𝑖]→𝑞(1)

𝑑∈𝑝[𝑖] 𝑞[𝑗𝑑]

y

Í

where the ﬁrst isomorphism is (3), the second is substitution, the third is the distribu-
(cid:3)
tive law, and the fourth is properties of exponents.

Proof of Proposition 2.7. With the formula given, it is clear that the ⊗-operation is asso-
ciative (up to isomorphism), and that y, which has y(1) (cid:27) 1 and y[1] (cid:27) y, is a unit.
One can also check that the formula is functorial in 𝑝 and 𝑞, completing the proof. (cid:3)

Proof of Proposition 2.8. The natural isomorphism is given by rearranging terms:

Poly(𝑟 ⊗ 𝑝, 𝑞) (cid:27)

𝑟[𝑘] × 𝑝[𝑖]

(cid:27)

(cid:27)

(cid:27)

Ö𝑘∈𝑟(1) Ö𝑖∈𝑝(1) Õ𝑗∈𝑞(1) Ö𝑒∈𝑞[𝑗]

Ö𝑘∈𝑟(1) Õ𝜑1 : 𝑝(1)→𝑞(1) Ö𝑖∈𝑝(1) Ö𝑒∈𝑞[𝜑1(𝑖)]

𝑟[𝑘] × 𝑝[𝑖]

𝑝[𝑖]

×

𝑟[𝑘]

Ö𝑘∈𝑟(1) Õ𝜑1 : 𝑝(1)→𝑞(1)

©

Ö𝑖∈𝑝(1) Ö𝑒∈𝑞[𝜑1(𝑖)]
𝑟[𝑘]

Ö𝑘∈𝑟(1) Õ𝜑 : 𝑝→𝑞 Ö𝑖∈𝑝(1) Ö𝑒∈𝑞[𝜑1(𝑖)]

«

ª
®
¬

©

«

Ö𝑖∈𝑝(1) Ö𝑒∈𝑞[𝜑1(𝑖)]

ª
®
¬

(cid:27) Poly

𝑟,

y

Í

Õ𝜑 : 𝑝→𝑞

𝑖∈𝑝(1) 𝑞[𝜑1(𝑖)]

!

(cid:27) Poly(𝑟, [𝑝, 𝑞]).

In order, these isomorphisms are given by: unfolding the deﬁnition of morphisms in
Poly, distributivity, products commuting with products, deﬁnition of morphisms in
(cid:3)
Poly, rules of exponents, and Eq. (7)’s deﬁnition of [𝑝, 𝑞], respectively.

Proof of Proposition 2.13. We need to give not only the functor 𝜆 : 𝑝-Coalg × 𝑞-Coalg →
(𝑝 ⊗ 𝑞)-Coalg, for any 𝑝, 𝑞 ∈ Poly but also a functor {1} → y-Coalg, which we can
identify with a y-coalgebra; we take the latter to be the unique function 1 → y ⊳ 1. For
the former, one could proceed abstractly using the fact that there is a duoidal structure
on Poly

(𝑝 ⊳ 𝑠) ⊗ (𝑞 ⊳ 𝑡) → (𝑝 ⊗ 𝑞) ⊳ (𝑠 ⊗ 𝑡).
Indeed, since for sets 𝑆, 𝑇 we have 𝑆 ⊗ 𝑇 (cid:27) 𝑆 × 𝑇, the result will follow from the
properties of duoidal structures (applied in the case where 𝑠 ≔ 𝑆 and 𝑡 ≔ 𝑇 are
constant polynomials). However, for the reader’s convenience, we will give the map
𝜆 : 𝑝-Coalg × 𝑞-Coalg → (𝑝 ⊗ 𝑞)-Coalg more explicitly.

13

 
 
 
Given 𝛽 : 𝑆 → 𝑝 ⊳ 𝑆 and 𝛾 : 𝑇 → 𝑞 ⊳ 𝑇, we deﬁne a function

𝑆𝑇 → (𝑝 ⊗ 𝑞) ⊳ (𝑆𝑇) (cid:27)

(𝑆𝑇)𝑝[𝑖]×𝑞[𝑗]

(𝑠, 𝑡) ↦→

𝑖 ≔ 𝛽1(𝑠), 𝑗 ≔ 𝛾1(𝑡), (𝑑, 𝑒) ↦→ (𝛽♯

𝑖 (𝑑), 𝛾♯

𝑗 (𝑒)

.

Õ𝑖∈𝑝(1) Õ𝑗∈𝑞(1)

This is natural in 𝑆, 𝑇, which makes 𝜆 a functor for any 𝑝, 𝑞. One can check that all the
axioms of a lax monoidal functor are veriﬁed, in the sense that the required diagrams
(cid:3)
commute up to natural isomorphism.

(cid:0)

(cid:1)

Proof of Proposition 2.18. On one hand, an object in Learn(𝐴, 𝐵) as described in (2)
consists of a set 𝑃 and functions 𝐴 × 𝑃 → 𝐵 and 𝐴 × 𝐵 × 𝑃 → 𝐴 and 𝐴 × 𝐵 × 𝑃 → 𝑃.
On the other hand, we have [𝐴y𝐴, 𝐵y𝐵] (cid:27) 𝐵𝐴𝐴𝐴𝐵y𝐴𝐵 by Example 2.9, so a coalgebra
𝑃 → [𝐴y𝐴, 𝐵y𝐵] ⊳ 𝑃 consists of a function 𝑃 → 𝐵𝐴, a function 𝑃 → 𝐴𝐴𝐵, and a function
𝑃 → 𝑃𝐴𝐵. The two descriptions can be identiﬁed by currying. The [𝐴y𝐴, 𝐵y𝐵]-Coalg
morphisms

𝑃

𝑃′

𝐵𝐴𝐴𝐴𝐵𝑃𝐴𝐵

𝐵𝐴𝐴𝐴𝐵(𝑃′)𝐴𝐵

are easily seen to coincide with those shown in (13).

(cid:3)

Proof of Theorem 3.3. It is well-known that C-Set is equivalent to the category of discrete
opﬁbrations over C via the category-of-elements construction. When C is free on a
graph 𝐺, the category of elements for any functor ℎ : C → Set is also free on a graph,
say 𝐻.
In this case the opﬁbration can be identiﬁed with a graph homomorphism
𝜋 : 𝐻 → 𝐺 with the property (“opﬁb”) that for any vertex ℎ ∈ 𝐻, the function on arrows
(cid:27)
𝐻[ℎ]
−→ 𝐺[𝜋(ℎ)] induced by 𝜋 is a bĳection. Under this correspondence, a morphism
ℎ → ℎ′ of copresheaves is identiﬁed with a graph homomorphism 𝑓 : 𝐻 → 𝐻′ for
which 𝜋 = 𝜋′ ◦ 𝑓 .

Thus we have reduced to showing that there is an equivalence between 𝑝-Coalg
and the category of those graph homomorphisms 𝜋 : 𝐻 → Tree𝑝 that have the opﬁb
property. Suppose given a 𝑝-coalgebra 𝛽 : 𝑆 → 𝑝 ⊳𝑆; it includes a function 𝛽1 : 𝑆 → 𝑝(1)
and for each 𝑠 ∈ 𝑆 a function 𝛽♯
𝑠 : 𝑝[𝛽1(𝑠)] → 𝑆. We deﬁne the corresponding graph
𝐺𝑆,𝛽 to have vertex set 𝑆, and each 𝑠 ∈ 𝑆 to have 𝑝[𝛽1(𝑠)]-many outgoing arrows;
the target of each outgoing arrow 𝑑 ∈ 𝑝[𝛽1(𝑠)] is deﬁned to be 𝛽♯
𝑠(𝑑). The graph
homomorphism 𝜋 : 𝐺𝑆,𝛽 → Tree𝑝 is deﬁned inductively: for any 𝑠 ∈ 𝑆, the 𝑝-tree 𝜋(𝑠)
has root labeled 𝛽1(𝑠), and for each outgoing branch 𝑑 ∈ 𝑝[𝛽1(𝑠)] the target vertex is
assigned the label 𝛽1(𝑠′), where 𝑠′ ≔ 𝛽♯
𝑠(𝑑), and for each outgoing branch 𝑑′ ∈ 𝑝[𝛽1(𝑠′)]
the target vertex is assigned the label 𝛽1(𝑠′′) where 𝑠′′ ≔ 𝛽♯
𝑠′(𝑑′), and so on. It is clear
that 𝜋 satisﬁes the opﬁb property, since it assigns to each vertex 𝑠 in the graph 𝐺𝑆,𝛽 a
vertex in Tree𝑝 (the 𝑝-tree 𝜋(𝑠)) with the same set 𝑝[𝛽1(𝑠)] of outgoing arrows.

Conversely, given a graph homomorphism 𝜋 : 𝐺 → Tree𝑝 with the opﬁb property,
let 𝑆𝐺 be the set of vertices in 𝐺. The required coalgebra map 𝛽 : 𝑆𝐺 → 𝑝 ⊳ 𝑆𝐺 consists

14

of a function 𝛽1 : 𝑆𝐺 → 𝑝(1) and a function 𝛽♯
𝑠 : 𝑝[𝛽1(𝑠)] → 𝑆𝐺 for every 𝑠 ∈ 𝑆𝐺. We
take the function 𝛽1 to send vertex 𝑠 to the root label 𝜙(root𝜋(𝑠)) for tree 𝜋(𝑠). Since
we have a bĳection 𝑝[𝛽1(𝑠)] (cid:27) 𝐺[𝑠], we can take 𝛽♯
𝑠 to simply be the target function
𝐺[𝑠] → 𝑆𝐺 for the graph 𝐺.

It is a straightforward calculation to check that these two constructions are mutually
inverse, and to check that graph homomorphisms over Tree𝑝 correspond bĳectively to
(cid:3)
morphisms of 𝑝-coalgebras.

References

[Adá05]

Jirı Adámek. “Introduction to coalgebra”. In: Theory and Applications of
Categories 14.8 (2005), pp. 157–199 (cit. on p. 6).

[AM82] Michael A Arbib and Ernest G Manes. “Parametrized data types do not
need highly constrained parameters”. In: Information and Control 52.2 (1982),
pp. 139–158 (cit. on p. 6).

[FS19]

[FST19]

Brendan Fong and David I. Spivak. An Invitation to Applied Category Theory:
Seven Sketches in Compositionality. Cambridge University Press, 2019 (cit. on
p. 10).

Brendan Fong, David I. Spivak, and Rémy Tuyéras. “Backprop as Functor:
A compositional perspective on supervised learning”. In: Proceedings of the
34th Annual ACM/IEEE Symposium on Logic in Computer Science. ACM. 2019.
eprint: arXiv:1711.10455 (cit. on pp. 1, 2, 8, 11).

[Gha+16] Neil Ghani, Jules Hedges, Viktor Winschel, and Philipp Zahn. “Composi-
tional game theory”. In: Proceedings of Logic in Computer Science (LiCS) 2018
(2016) (cit. on p. 2).

[GK12]

[Jac17]

[MM92]

[nLa21]

[Spi20]

Nicola Gambino and Joachim Kock. “Polynomial functors and polynomial
monads”. In: Mathematical Proceedings of the Cambridge Philosophical Society
154.1 (Sept. 2012), pp. 153–192 (cit. on p. 4).

Bart Jacobs. Introduction to Coalgebra. Vol. 59. Cambridge University Press,
2017 (cit. on p. 6).

Saunders MacLane and Ieke Moerdĳk. Sheaves in Geometry and Logic: A
First Introduction to Topos Theory. Springer, 1992 (cit. on p. 10).

nLab authors. tree. http://ncatlab.org/nlab/show/tree. Revision 26.
Feb. 2021 (cit. on p. 10).

David I. Spivak. Poly: An abundant categorical setting for mode-dependent
dynamics. 2020. eprint: arXiv:2005.01894 (cit. on p. 8).

15

