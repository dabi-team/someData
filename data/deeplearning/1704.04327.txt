Deep API Programmer: Learning to Program with APIs

Surya Bhupatiraju
MIT
surya@mit.edu

Rishabh Singh
Microsoft Research
risin@microsoft.com

Abdel-rahman Mohamed
Microsoft Research
asamir@microsoft.com

Pushmeet Kohli
Microsoft Research
pkohli@microsoft.com

7
1
0
2

r
p
A
4
1

]
I

A
.
s
c
[

1
v
7
2
3
4
0
.
4
0
7
1
:
v
i
X
r
a

Abstract

We present DAPIP, a Programming-By-Example
system that learns to program with APIs to perform
data transformation tasks. We design a domain-
speciﬁc language (DSL) that allows for arbitrary
concatenations of API outputs and constant strings.
The DSL consists of three family of APIs: regular
expression-based APIs, lookup APIs, and transfor-
mation APIs. We then present a novel neural syn-
thesis algorithm to search for programs in the DSL
that are consistent with a given set of examples.
The search algorithm uses recently introduced neu-
ral architectures to encode input-output examples
and to model the program search in the DSL. We
show that synthesis algorithm outperforms baseline
methods for synthesizing programs on both syn-
thetic and real-world benchmarks.

1 Introduction
The ability to discover a program consistent with a given user
intent (speciﬁcation) is considered as one of the central prob-
lems in artiﬁcial intelligence [Green, 1969]. While signiﬁcant
progress has been made in synthesizing programs in differ-
ent domains [Alur et al., 2013], current synthesis techniques
do not scale to larger and more complex programs. More-
over, the state-of-the-art synthesis techniques [Gulwani et al.,
2012] require a great deal of domain expertise with manually
designed heuristics and rules to develop an efﬁcient search
procedure.
In this paper, we present DAPIP, or Deep API
Programmer, a system that aims to overcome some of these
shortcomings by automatically learning a synthesis algorithm
in the domain of data transformation tasks.

The process of transforming data from raw data into us-
able formats (also known as data wrangling) is a key problem
faced by data scientists for any data analysis task. Some stud-
ies have reported that this data wrangling process can some-
times take up to 80% of the total data analysis time [Dasu and
Johnson, 2003; Kandel et al., 2011]. Recently, Programming-
By-Example (PBE) techniques such as FlashFill [Gulwani,
2011; Gulwani et al., 2012] and BlinkFill [Singh, 2016]
were developed to help users perform data transformation
tasks using examples instead of having to write complex pro-
grams. These techniques encode the space of programs using

a domain-speciﬁc language (DSL), and then develop algo-
rithms based on version-space algebra (VSA) [Polozov and
Gulwani, 2015; Lau et al., 2003] to efﬁciently search the
space of programs. There are two key shortcomings of these
approaches. First, the DSL is limited to only certain low-
level syntactic regular expression-based operators that allow
for an efﬁcient structuring of search space. This limits the
expressiveness of the PBE systems; for example, they do not
allow semantic data transformations using arbitrary transfor-
mation functions such as obtaining month names from a date
or abbreviating the state name in an input address. Second,
building an efﬁcient synthesizer using VSA requires a large
engineering effort with manually designed heuristic rules.

We tackle the ﬁrst shortcoming by designing DAPIP’s DSL
to have function APIs as the core element, which allows
for composition of APIs with constant strings. The DSL
consists of three kinds of APIs:
regular expression-based
APIs, lookup APIs, and transformation APIs. The regular
expression-based APIs perform a regular expression-based
transformation on the input strings, which are needed for syn-
tactic data transformations. The lookup APIs search for a
particular string in the input data based on a dictionary of
strings, and the transformation APIs perform some transfor-
mation on top of a lookup operation based on a predeﬁned
mapping between two sets of strings. The lookup and trans-
formation APIs allow for semantic data transformations.

The second shortcoming is handled by learning the syn-
thesis algorithm in DAPIP automatically from data using two
recently introduced neural modules [Parisotto et al., 2016].
The ﬁrst module called the cross-correlational encoder com-
putes a ﬁxed-dimension vector representation of the input-
output examples by using tensor representations obtained by
running two bi-directional LSTMs [Hochreiter and Schmid-
huber, 1997; Graves and Schmidhuber, 2005] on the input and
output strings and computing their cross correlation. The sec-
ond module, the recursive-reverse-recursive neural network,
or R3NN, encodes a partial derivation in the DSL and given
the example encoding vector, returns a distribution over the
space of possible expansions to the partial derivation. The
R3NN incrementally builds a program in the DSL that is con-
sistent with the input-output examples. The input-output en-
coder and the R3NN modules are trained end-to-end using
thousands of programs and corresponding input-output exam-
ples, which are automatically sampled from the DSL.

 
 
 
 
 
 
Input v
John S. Henry
Mike Stanley

1
2
3 Bernie John Smith
4 Martha S Johnson M. Johnson

Output
J. Henry
M. Stanley
B. Smith

Figure 1: An example FlashFill task of abbreviating names.
The user provides the ﬁrst two outputs, and the bold entries
are then automatically generated by the learned program.

Input v

Output

1
2
3
4

500 Mem Dr., Cambridge, 02139 Cambridge, MA
Redmond, WA
Seattle, WA
Kirkland, WA

22 NE Street, Redmond, USA
Seattle, 98002
21 Peace Ave., Kirkland, 98034

Figure 3: Using the trained R3NN model to sample programs
from the DSL given a set of input-output examples; even in
the inference use case, nodes are expanded in a particular,
discrete order.

Figure 2: Transforming addresses to City and State.

in Appendices C and D.

More examples of real-world FlashFill tasks can be found

We evaluate DAPIP on a set of synthetic and 238 real-
world FlashFill benchmarks. Our experiments indicate that
our deep learning based approach is able to effectively model
and predict the presence of different types of APIs. It is able
to solve 45% of the FlashFill benchmarks and signiﬁcantly
outperforms the enumerative search based baseline.

To summarize, the key contributions of this paper are:
• We design an expressive DSL with APIs that can encode
both syntactic and semantic data transformation tasks.
• We automatically learn a synthesis algorithm for synthe-
sizing programs in the DSL using neural architectures.
• We evaluate our system DAPIP on 238 real-world Flash-
Fill benchmarks and thousands of synthetic benchmarks.

2 Motivating Examples
We present a few real-world examples to motivate the DSL.
Example 1. An Excel user wanted to transform names to ﬁrst
initial followed by last name as shown in Figure 1. Since
some input examples had optional middle names, the user was
struggling to ﬁnd a macro to perform the desired task.

DAPIP learns the following program for

this task:
Concat(GetFirstChar(v), ConstStr(“.(cid:48)(cid:48)), GetLastWord(v)).
The learned program uses the GetFirstChar and GetLast-
Word APIs that belong to the class of regex APIs, which
extract substrings from the input string based on regular
expressions.
Example 2. An Excel user had a list of addresses and wanted
to extract the city and state values as shown in Figure 2.

This is an example of a very common task that can not be
performed by systems such as FlashFill. Since the data is in
many different formats, there is no consistent regular expres-
sion that can be used to extract the city names. Moreover,
to obtain the state name, the system needs to use a trans-
form API GetStateFromCity. DAPIP learns the following
program:Concat(GetCity(v), ConstStr(“,(cid:48)(cid:48) ),
GetStateFromCity(GetCity(v))).

3 Overview of Approach

We now present an overview of our end-to-end system that
learns to synthesize programs in a DSL that are consistent
with a set of examples. The training phase of our system is
shown in Figure 4 and the test phase is shown in Figure 3. We
ﬁrst design a DSL that allows for composition of nested API
calls with constant strings. We designed this DSL after study-
ing a large family of real-world string transformation tasks so
that it is expressive enough to encode these tasks. During
the training phase, we use a program sampler to uniformly
sample a large number of programs from this DSL. For each
program, we use a rule-based approach to construct 5 input
strings for the program such that the prerequisites of the pro-
gram are met. We obtain the output strings by executing the
program on the input strings.

During training, each sampled program together with the
corresponding input-output examples is used to train the
R3NN model, a neural architecture that learns distributions
over the expansions in the DSL conditioned on the examples.
The examples are encoded using a second neural architec-
ture called the cross-correlational encoder, which produces
a ﬁxed-dimensional vector. The R3NN system takes as in-
put the input-output conditioning vector, the DSL, and the
training program, and is trained to predict a conditional dis-
tribution over the set of DSL expansions. The next expansion
is sampled from this conditional distribution, leading to the
partial tree, and the procedure repeats; one can observe a po-
tential order of the nodes growing in the respective ﬁgures.

The trained R3NN model can then be used to synthesize
programs in the DSL given a set of examples. The trained
model takes the input-output conditioning vector as input,
and generates a distribution over the set of DSL expansions
that are likely to be the expansions required to construct the
desired program. The distribution is then sampled to derive
programs in the DSL, where the order of expansions is speci-
ﬁed by the distribution, as shown in the respective ﬁgure, and
the system returns the ﬁrst program that is consistent with the
input-output examples.

R3NNIn:-“John-Doe”-On:-“J.D.”IO,EncoderInputsOutputsIO-ExamplesDSLProgram:S">e;-e">Concat(...);-f1">T2(f3)SampleInferred-Programf">f2S">ee">Cf">f1f">?f">f3143256Figure 4: Training the R3NN network to learn distributions over DSL expansions conditioned on the input-output examples;
expansion are performed in a particular order as dictated by the conditional distribution.

4 Domain-Speciﬁc Language

The syntax of the domain-speciﬁc language for API-based
string transformations is shown in Figure 5. The top-level
construct of the language is the Concat function that returns
the concatenation of its argument substrings fi. A substring
expression f can either be a constant string s, the input string
v, or the result of an API function with f as its argument.
The Concat operator allows for composition of API calls with
constant strings. The DSL consists of 3 types of APIs: regex
APIs R, lookup APIs L, and transformation APIs T .

Regex API R: The regex APIs search for certain reg-
ular expression-based patterns in the input string and return
the matched string. Some examples of regex APIs are Get-
FirstNum, GetBetFirstAndSecondCommas, etc. Our DSL
consists of 104 such regex APIs.

Lookup API L: The lookup APIs look for presence of
certain strings in the input string and return the lookup string.
Each lookup API consists of a dictionary of a ﬁnite collec-
tion of strings, which are used for searching input substrings.
Some examples of lookup APIs are GetCity,GetState, Get-
StockSymbol etc. For example, the GetState API contains
a dictionary of 50 US state names, whereas the GetCity API
contains a dictionary of 18, 200 US cities. Our DSL consists
of 18 such lookup APIs.

Transformation API T : The transformation APIs con-
sists of a dictionary D : S1 → S2, which maps a ﬁnite col-
lection of strings S1 to another ﬁnite collection of strings S2.
These APIs search for a string s ∈ S1 in the input string
and return the corresponding output string D[s] ∈ S2. Some
examples of such APIs include GetStateFromCity, GetFirst-
NameInitial, etc. For example, the transformation API Get-
StateFromCity consists of a dictionary mapping a collection
of 18, 200 US cities to the corresponding US states. Our DSL
consists of 13 such functions.

The full list of all functions is provided in Appendix A.

5 Neural Architecture for Search

The neural search over the programs in the DSL conditioned
on the input-output examples is performed using the model
outlined in [Parisotto et al., 2016]. First, the input-output
examples are encoded into a ﬁxed length feature vector that

String e
Substring f

:= Concat(f1, . . . , fn)
:= R(f ) | T (f ) | L(v)
ConstStr(s) | v
|
| Lm
· · ·
| Rl
· · ·
| Tk
· · ·

Lookup API L := L1 |
Regex API R := R1 |
:= T1 |

Transform API T

Figure 5: The syntax of the DSL for API compositions.

aims to capturing shared patterns between the input and out-
put strings. This example representation is then passed to a
neural tree-based generative model over program trees, called
R3NN, to generate the desired hidden program. We provide
a high level overview of the both the architectures.

a

encoder

generates

cross-correlational

5.1 Neural Input-Output Encoder
The
ﬁxed-
dimensional vector representation of a set of input-output
Intuitively, the encoder needs to capture
(I/O) examples.
three key information: parts of the output strings that are
likely to be constant strings, parts of the output strings that
can be computed from input strings, and some characteristics
of the example strings that will help the program generator
module identify the set of useful APIs for the given task. To
simplify the DSL, we assume a ﬁxed universe of possible
constant strings so that we can focus on training the encoder
to produce the likely set of APIs.

The I/O encoder ﬁrst runs two bidirectional LSTM net-
works separately on the input and output strings in each ex-
ample pair, which produces two matrices of size 2 × H × T ,
where H is the LSTM hidden dimension and T is the maxi-
mum length of the I/O string. The encoder then slides the out-
put matrix over the input matrix for each time step and com-
putes the outer product between respective matrix columns.
There are in total 2 · (T − 1) alignments as we slide the matri-
ces and we obtain 2·(T −1) vectors in total after the dot prod-
uct. Finally, the encoder concatenates the values for overlap-
ping time steps to obtain a 2×T ×(T −1)-dimensional vector
encoding for each example pair.

f">f2S">eProgram-SamplerR3NNProgram:S">ee">Concat(...)f1">T1(f2)...In:-“John-Doe”-On:-“J.D.”IO,EncoderInputsOutputsIO-ExamplesGround-Truth-Programe">Cf">f1f">?f">f3DSLDSLDistribution-over-DSL-ExpansionsProgram:S">e;-e">Concat(...);-f1">T2(f3)Ground-TruthProgram1432565.2 Tree-Structured Generation Model
The tree generation model incrementally constructs a pro-
gram tree starting from the start symbol of the DSL grammar
and expanding the tree with one derivation at a time until ob-
taining a tree with that consists only non-terminal nodes. The
R3NN network assigns posterior probabilities to every valid
expansion of a partial tree to guide the search algorithm. In
other words, given a partial program tree, the R3NN network
decides which non-terminal node to expand in the tree and
with which expansion rule in the grammar.

The R3NN is deﬁned by the following parameters: i) an
M -dimensional representation φ(s) ∈ RM for every sym-
bol s in the grammar, ii) an M -dimensional representation
ω(r) ∈ RM for each grammar rule r, iii) a deep neural net-
work fr for each grammar rule r that takes as input a vector
x ∈ RQ·M (where Q is the number of RHS symbols of r) and
outputs a vector y ∈ RM , and iv) a deep neural network gr
(reverse of fr) which takes as input a vector x(cid:48) ∈ RQ·M and
outputs a vector y(cid:48) ∈ RQ·M .

Given a partial program tree, R3NN ﬁrst assigns the repre-
sentation φ(S(l)) to each leaf node l, where S(l) denotes the
grammar symbol of node l. It then performs a standard recur-
sive pass over the tree from bottom-to-top, by recursively ap-
plying fR(n) for every non-leaf node n on its RHS node rep-
resentations to compute the representation of n, where R(n)
denotes the rule associated with node n. This pass continues
until we reach the root node. The φ(root) represents informa-
tion about all tree nodes, but does not encode any notion of
the node positions in the tree. To solve this issue, R3NN per-
forms a reverse-recursive pass starting from the root node to
compute updated representations of all child nodes using the
reverse deep network gR(n). After performing the reverse-
recursive pass, each leaf node l is assigned a new distributed
representation φ(cid:48)(l), which intuitively captures the global in-
formation about every other node in the tree.

The scores for each expansion e ∈ E can now be obtained
from the global leaf representations φ(cid:48)(l). Let er be the ex-
pansion type (production rule r ∈ R that e applies) and let el
be the leaf node l that er is applied to for an expansion e. The
score of an expansion is calculated using ze = φ(cid:48)(el) · ω(er)
and the probability of the expansion is obtained by exponen-
tiated normalized sum over the scores: π(e) =

(cid:80)

eze
e(cid:48)∈E ez

e(cid:48) .

6 Evaluation
We now present results from two major sets of experiments
and analyze the model in more detail with the goal of as-
sessing its expressiveness. We demonstrate that our model is
capable of learning to synthesize simple programs when pro-
vided with a library of over 100 API functions. We also show
that the model is capable of strong generalization, where it
can not only generalize across different I/O examples for a
given program, but also across new, unseen programs.

6.1 Experimental Setup and Training Details
We use both synthetic benchmarks and real-world FlashFill
benchmarks for evaluation. The synthetic benchmarks are ob-
tained by sampling the programs in the DSL uniformly, and
then using a rule-based approach to generate corresponding

input-output examples. For example, if we sample a pro-
gram consisting of GetThirdNum and GetState APIs, the
rule-based approach would ensure that the input strings in
the example consist of at least three numbers and one state
strings. For each benchmark, we sample ﬁve input strings
and the corresponding output strings are obtained by execut-
ing the sampled program on the input strings. Several exam-
ples of training data are shown in Appendix B.

We ﬁrst train the R3NN on a DSL consisting of only one
family of APIs to evaluate its effectiveness on learning indi-
vidual API family. We call the models trained on only the
regex APIs (and constant strings) as the FF models and call
the corresponding DSL as the regex-only DSL. We then train
the R3NN with all APIs to evaluate the effectiveness of learn-
ing programs in the DSL consisting of different APIs and
their composition with constant strings; we call this DSL the
full DSL. The models trained on the full DSL are called the
FF++ models. Since the FlashFill benchmarks can be solved
using only the regex APIs and the set of constant strings, we
also evaluate the FF model on the FlashFill benchmarks.

We train the cross-correlation encoder and R3NN jointly
with the principle of maximum likelihood; the model pro-
duces posterior probabilities over possible expansions and we
backpropagate an error signal based on the ground truth pro-
grams. We use the Adam optimizer [Kingma and Ba, 2014],
with an initial learning rate of 0.001 and clipping gradients at
10 for both modules. We found that small learning rates are
crucial for R3NN to prevent unstable learning. Every epoch
consists of 1000 training batches of 10 instances, where each
instance contains a ground truth program and 5 input-output
pairs. The evaluation on synthetic data is performed on pro-
grams that are not seen during training. We report results
when evaluating with both 1-best inference and with stochas-
tic search (10, 50, or 100 samples), where we resample a pro-
gram conditioned on the same input-output examples multi-
ple times. This way, we allow the model to have small errors
in its ﬁnal posterior probabilities for selecting an expansion.

6.2 Learning API Types
Each of the three classes of API functions, while much more
interpretable, still pose nontrivial challenges for the model to
learn to compose. The lookup API functions contain large
dictionaries and the model must learn when to call such APIs
given the input-output examples. For example, while the dif-
ference between names and cities may seem trivial to human
practitioners, the model must learn to disambiguate each of
these entities. The transformation API functions pose an ad-
ditional challenge; with programs that require these types of
API calls, not only does the model need to learn some en-
coding of the hidden dictionary, but the output string may not
contain any obvious matching substring in the input string be-
cause of the nature of the API function. As a result, a simple
string matching algorithm between the inputs and outputs will
not work to solve this problem, and the input-output encoder
must learn useful representations of pairs of them, and be ex-
pressive enough to capture the implicit string transformation.
Lastly, the regex API functions do not encode dictionaries but
represent syntactic substring operations, and the model must
learn to recognize which API functions to call based on which

parts of the output are present in the input.

We ﬁrst present an ablative study of what class of APIs are
the easiest to learn in isolation, and which one is the most
challenging in the full DSL.

Regex APIs
In Table 1, we report the training and valida-
tion set accuracies of different models trained on the regex-
only DSL (FF model). The length column denotes the maxi-
mum length of programs that each model was trained on. The
length 7 model was trained with 9000 programs, length 8 with
16000, length 9 with 616510, and length 10 with 1263000
programs. For validation, we select 1000 randomly chosen
held-out programs from this set and generate new I/O exam-
ples to test the generalization power of the trained model.

Length Training Validation

7
8
9
10

80%
91%
22%
64%

67%
85%
20%
63%

Table 1: Best FF model performance by max program length.

Of particular note is the performance on programs of length
10. At this length, the DSL can generate programs with API
nesting, API composition, and concatenation with a constant
string; this represents all possible constructs in our DSL.

Lookup and Transform APIs
In this experiment, we ﬁx
the maximum size of the programs in the training and vali-
dation set to size 10 and only include the lookup and trans-
form APIs in the DSL. The results are shown in Table 2. We
ﬁnd that when the DSL is restricted to these APIs, the trained
models achieve a very high accuracy and are able to identify
composition of APIs with very high precision.

APIs

Training Validation

Lookup
Lookup+Transform

96%
98%

96%
98%

Table 2: Learnability of other APIs.

All APIs: Regex + Transform + Lookup We now present
the model evaluation that was trained on the full DSL. Recall
that because we’ve trained on the full DSL, these models are
referred to as the FF++ models.

The performance of the FF++ models is shown in Table
3. We observe that both training and validation accuracies
decreased as compared to the FF models, which is expected
since we now have an increased set of APIs that also include
more complex APIs encoding large dictionaries. However,
the length 10 model is still able to get 44% accuracy.

We analyze these results further to understand the learn-
ability of different APIs when trained together as shown in
Table 4. The regex APIs seem to be the easiest to learn for

Length Training Validation

7
8
9
10

54%
75%
46%
50%

46%
64%
37%
44%

Table 3: The performance of best FF++ model on synthetic
dataset by max length of programs.

the network, which may be accredited to the speciﬁc nature
of the IO encoder, as it was designed to detect patterns in sub-
strings between the input and output examples. Interestingly,
the lookup APIs are harder to learn than the transformation
APIs, which can be attributed to the fact that they encode
larger dictionaries as compared to the dictionaries of trans-
form APIs.

Samples LookupAPIs TransformAPIs RegexAPIs

10
50
100

32%
37%
38%

50%
52%
57%

72%
89%
92%

Table 4: Ablative analysis of FF++ model performance.

6.3 FlashFill using API Compositions
We now present the results of the best FF and FF++ mod-
els on the FlashFill benchmarks obtained from the authors
of FlashFill [Gulwani et al., 2012]. These benchmarks cor-
respond to real-world string transformation tasks in Excel,
where each benchmark comprises of 5 input-output string ex-
amples.

FF models
Baseline performance with uniform search We ﬁrst
present the results we obtain with a baseline uniform search
model on the FlashFill benchmarks in Table 5. The base-
line model performs a uniform search over the DSL expan-
sions and is biased towards small programs. We also present
stochastic sampling results for a fair comparison with the per-
formance of the FF models.

Samples

10

50

100

Performance

2% 10% 17%

Table 5: Uniform search on FF benchmarks

The uniform search does surprisingly well considering the
large space of all possible programs because the DSL we de-
signed with APIs allows many of the benchmarks to be solved
with a single call, e.g. GetFirstWord, and the uniform search
sampler is biased towards shorter programs.

FF Model performance on FlashFill Benchmarks We
now evaluate the trained models whose accuracies on syn-
thetic data are reported in Table 1. Note that unlike in Table

1, each of the model is evaluated on the same dataset and so
the results are comparable across rows. In this case, we not
only report the results with stochastic sampling, but also re-
port the 1-best programs under the 1 column in Table 6.

Length

1

10

50

100

7
8
9
10

20% 30% 37% 41%
18% 29% 34% 39%
15% 26% 36% 36%
20% 26% 38% 45%

Table 6: FF model performance on FF benchmarks

In this case, we observe that with 100 samples, the length-
10 model is able to solve 45% of the benchmarks.
It sur-
passes the performance of Neural FlashFill [Parisotto et al.,
2016], which achieves an accuracy of 23% with 100 samples
and 34% with 1000 samples. On further inspection of the
benchmarks, we ﬁnd that only 50% of the benchmarks can
be solved with programs of length ≤ 10 in our DSL. If we
normalize across this, we see that we can solve 90% of all
solvable benchmarks. This indicates that our model is capa-
ble of learning to synthesize realistic programs.

FF++ Model
Baseline Performance with uniform search We ﬁrst
present the baseline results of uniform search. Since the DSL
has expanded, the uniform search performs slightly worse and
can only achieve an accuracy of about 11% with 100 samples.

Samples

10

50

100

Performance

3% 8% 11%

Table 7: Uniform search on FF benchmarks with full DSL

FlashFill benchmark performance The results for evalu-
ating the FF++ model on the FlashFill benchmarks is shown
in Table 8. The length 10 models can still remarkably solve
37% of the benchmarks even with the extended DSL.

Length

10

50

100

7
8
9
10

28% 31% 33%
24% 32% 34%
19% 32% 34%
24% 34% 37%

Table 8: FF++ model performance on FF benchmarks

7 Related Work
We describe the related work from the domains of VSA-based
programming by example systems and neural program induc-
tion and synthesis systems.

Programming By Example for String Manipulations
There has been much recent work on designing version space
algebra-based PBE systems for performing data transforma-
tion and extraction. FlashFill [Gulwani, 2011; Gulwani et
al., 2012] is a PBE system that performs regular expression
based string transformations using examples. Given an input-
output example string, FlashFill ﬁrst searches over all possi-
ble ways to decompose the output string and represent the set
of those sub-programs concisely using a DAG data structure.
This VSA-based approach has then been extended to also
build PBE systems for number transformations [Singh and
Gulwani, 2012b], table joins [Singh and Gulwani, 2012a],
data extraction [Le and Gulwani, 2014], and data reshap-
ing [Barowy et al., 2015]. While these methods are inter-
pretable and tractable, they are unscalable to any additions of
new functionality. DAPIP, unlike the VSA-based PBE sys-
tems, is trained automatically using the R3NN network by
sampling several thousands of programs from arbitrary DSLs.

Neural Program Induction and Synthesis There has been
a plethora of recent work in both neural program induction
and neural program synthesis. The goal in neural program
induction is to teach neural networks the functional behavior
of a program by augmenting the neural networks with addi-
tional computational modules such as Neural GPU [Kaiser
and Sutskever, 2015], Neural Turing Machine [Graves et al.,
2014], and stacks-augmented RNNs [Joulin and Mikolov,
2015]. One limitation of these architectures is that although
they are able to learn the functional behavior, they do not
expose an interpretable program back to the user. In addi-
tion, they need to be trained per task separately, represent-
ing a lack of strong generality. More recent work, such as
Terpret [Gaunt et al., 2016] and Neural-RAM [Kurach et al.,
2015] seek to mitigate the interpretability issue but they need
to be trained for each individual benchmark problem, which
is prohibitively expensive.

A recent approach was proposed to use the R3NN-based
neural architectures to synthesize programs in a DSL similar
to that of FlashFill [Parisotto et al., 2016]. We employ the
same architecture but in a different DSL consisting of APIs at
the core level of expressions. The APIs allows the program
depth to be shallower than programs in a DSL with more
primitives, and we investigate if that can make the task of
automatically learning a search strategy easier for the R3NN.
We argue that imposing higher-order functions is much more
extensible and more akin to human-like programming.

8 Future Work
There are a number of ways that we can extend the results and
techniques presented in this paper to yield both improvements
in the current numbers as well as allow us to scale to larger
programs.

8.1 Function embeddings
We rely on the R3NN and the input-output encoder to implic-
itly encode the semantics of each function, and we’ve shown
through a number of experiments that the tree model is ca-
pable of doing so. This is impressive in its own right, but in

order to improve the performance further, we should extend
the model to support explicit, continuous representations of
each function. This can be achieved in a number of ways -
the simplest of which involves encoding each function as a
randomly initialized vector and allowing the model to attend
to API functions that may be relevant to the input-output ex-
amples. We can freeze the embeddings, or we can elect to
backpropagate errors through both the attention mechanism
and the embeddings, and jointly learn these representations.
This represents a principled approach to adding new functions
and method is easy to extend to additional API functions that
we may choose to add.

8.2 Divide and conquer
Function embeddings allow us to perform better on existing
problems by giving the model more information as to what
choices to make when generating the tree. However, this does
not resolve the issue of scalability. Even with function em-
beddings, as the inputs and outputs grow in size and complex-
ity, we have no scalable method of performing inference over
which programs to synthesize. However, instead of viewing
the problem as a whole, we can break up the problem into
smaller pieces and try to solve each subpiece and concatenate
the answers together. This divide-and-conquer approach al-
lows us to treat larger problems as conglomerations of a num-
ber of smaller problems. This procedure requires two general
mechanisms: one module will need to predict how to split the
output string into smaller, meaningful chunks, and the second
module will consume each input-output piece, synthesize the
correct program, and each piece will eventually be concate-
nated together. This is especially convenient in this problem
setting because the FlashFill language is one that is focused
on concatenations, so we lose no generality in being able to
solve the problem.

8.3 Extending the DSL
An interesting extension of the DSL is to add multi-argument
API function calls. This could yield more general API func-
tions, such as GetNthObj(n, o), and could replace functions
like GetFirstWord, GetSecondNumber. In addition, we can
also add multi-argument Concat functions; this idea goes
neatly with the divide-and-conquer approach and can be used
to help scale the model to synthesize larger programs.

8.4 Batching Trees
While the divide-and-conquer approach is an algorithmic im-
provement to speed up the process of training the model, we
can also take advantage of the model to incorporate faster
batching proocols. Using a tree-based generative models al-
lows us to batch operations together that occur at the same
depth in the tree because each operation is indepenedent of
all of its siblings. Moreover, we can also batch multiple trees
together for increased performance.

9 Conclusion
In this paper, we presented DAPIP, a system that tries to au-
tomatically learn a synthesis algorithm given a DSL. In par-
ticular, we designed a DSL consisting of APIs as ﬁrst class

constructs that allows the system to perform richer tasks using
small sized programs. We used the recently introduced R3NN
neural architecture to automatically learn a synthesis algo-
rithm for our DSL. The preliminary results suggest that the
system is able to efﬁciently learn programs up to size 10 with
about 45% accuracy on real-world benchmarks. We believe
this direction of using neural architectures to automatically
develop synthesis algorithms for PBE systems can lead to big
advancements in program synthesis techniques and make it
more generally applicable to many new domains.

References
[Alur et al., 2013] Rajeev Alur, Rastislav Bodik, Garvit Ju-
niwal, Milo MK Martin, Mukund Raghothaman, Sanjit A
Seshia, Rishabh Singh, Armando Solar-Lezama, Emina
Torlak, and Abhishek Udupa. Syntax-guided synthesis.
In Formal Methods in Computer-Aided Design (FMCAD),
2013, pages 1–8. IEEE, 2013.

[Barowy et al., 2015] Daniel W. Barowy, Sumit Gulwani,
Ted Hart, and Benjamin G. Zorn. Flashrelate: extract-
ing relational data from semi-structured spreadsheets us-
ing examples. In PLDI, pages 218–228, 2015.

[Dasu and Johnson, 2003] Tamraparni Dasu and Theodore
Johnson. Exploratory data mining and data cleaning, vol-
ume 479. John Wiley & Sons, 2003.

[Gaunt et al., 2016] Alexander

Marc
Brockschmidt, Rishabh Singh, Nate Kushman, Push-
meet Kohli, Jonathan Taylor, and Daniel Tarlow. Terpret:
A probabilistic programming language for program
induction. arXiv preprint arXiv:1608.04428, 2016.

Gaunt,

L

[Graves and Schmidhuber, 2005] Alex Graves and J¨urgen
Framewise phoneme classiﬁcation with
Schmidhuber.
bidirectional lstm and other neural network architectures.
Neural Networks, 18(5):602–610, 2005.

[Graves et al., 2014] Alex Graves, Greg Wayne, and Ivo
arXiv preprint

Danihelka. Neural turing machines.
arXiv:1410.5401, 2014.

[Green, 1969] Cordell Green. Application of theorem prov-
In Proceedings of the 1st In-
ing to problem solving.
ternational Joint Conference on Artiﬁcial Intelligence, IJ-
CAI’69, pages 219–239, 1969.

[Gulwani et al., 2012] Sumit Gulwani, William R. Harris,
and Rishabh Singh. Spreadsheet data manipulation using
examples. Commun. ACM, 55(8):97–105, 2012.

[Gulwani, 2011] Sumit Gulwani. Automating string process-
ing in spreadsheets using input-output examples. In POPL,
pages 317–330, 2011.

[Hochreiter and Schmidhuber, 1997] Sepp Hochreiter and
J¨urgen Schmidhuber. Long short-term memory. Neural
computation, 9(8):1735–1780, 1997.

[Joulin and Mikolov, 2015] Armand

and Tomas
Inferring algorithmic patterns with stack-
In Advances in Neural

Mikolov.
augmented recurrent nets.
Information Processing Systems, pages 190–198, 2015.

Joulin

[Kaiser and Sutskever, 2015] Łukasz Kaiser

Ilya
Sutskever. Neural gpus learn algorithms. arXiv preprint
arXiv:1511.08228, 2015.

and

[Kandel et al., 2011] Sean Kandel, Andreas

Paepcke,
Joseph M. Hellerstein, and Jeffrey Heer. Wrangler: inter-
active visual speciﬁcation of data transformation scripts.
In Proceedings of the International Conference on Human
Factors in Computing Systems, CHI 2011, Vancouver, BC,
Canada, May 7-12, 2011, pages 3363–3372, 2011.

[Kingma and Ba, 2014] Diederik Kingma and Jimmy Ba.
arXiv

Adam: A method for stochastic optimization.
preprint arXiv:1412.6980, 2014.

[Kurach et al., 2015] Karol Kurach, Marcin Andrychowicz,
and Ilya Sutskever. Neural random-access machines. arXiv
preprint arXiv:1511.06392, 2015.

[Lau et al., 2003] Tessa A. Lau, Steven A. Wolfman, Pe-
dro M. Domingos, and Daniel S. Weld. Programming
by demonstration using version space algebra. Machine
Learning, 53(1-2):111–156, 2003.

[Le and Gulwani, 2014] Vu Le and Sumit Gulwani. Flashex-
tract: a framework for data extraction by examples.
In
PLDI, page 55, 2014.

[Parisotto et al., 2016] Emilio Parisotto, Abdel-rahman Mo-
hamed, Rishabh Singh, Lihong Li, Dengyong Zhou, and
Pushmeet Kohli. Neuro-symbolic program synthesis.
arXiv preprint arXiv:1611.01855, 2016.

[Polozov and Gulwani, 2015] Oleksandr Polozov and Sumit
Gulwani. Flashmeta: a framework for inductive program
synthesis. In OOPSLA, pages 107–126, 2015.

[Singh and Gulwani, 2012a] Rishabh Singh and Sumit Gul-
wani. Learning semantic string transformations from ex-
amples. PVLDB, 5(8):740–751, 2012.

[Singh and Gulwani, 2012b] Rishabh Singh and Sumit Gul-
wani. Synthesizing number transformations from input-
output examples. In CAV, pages 634–651, 2012.

[Singh, 2016] Rishabh Singh. Blinkﬁll: Semi-supervised
programming by example for syntactic string transforma-
tions. PVLDB, 9(10):816–827, 2016.

d
r
o
W
s
p
a
C
t
s
a
L
o
T
h
t
f
i
F
t
e
G

d
r
o
W

e
s
a
c
r
e
p
o
r
P
t
s
r
i
F
t
e
G

d
r
o
W

e
s
a
c
r
e
p
o
r
P
d
n
o
c
e
S
t
e
G

d
r
o
W

e
s
a
c
r
e
p
o
r
P
h
t
r
u
o
F
t
e
G

d
r
o
W

e
s
a
c
r
e
p
o
r
P
d
r
i
h
T
t
e
G

d
r
o
W

e
s
a
c
r
e
p
o
r
P
h
t
f
i
F
t
e
G

s
d
r
o
W

e
s
a
c
r
e
p
o
r
P

l
l

A
t
e
G

d
r
o
W

e
s
a
c
r
e
p
o
r
P
t
s
a
L
t
e
G

d
r
o
W

e
s
a
c
r
e
p
o
r
P
t
s
a
L
o
T
d
n
o
c
e
S
t
e
G

d
r
o
W

e
s
a
c
r
e
p
o
r
P
t
s
a
L
o
T
h
t
r
u
o
F
t
e
G

d
r
o
W

e
s
a
c
r
e
p
o
r
P
t
s
a
L
o
T
d
r
i
h
T
t
e
G

d
r
o
W

e
s
a
c
r
e
p
o
r
P
t
s
a
L
o
T
h
t
f
i
F
t
e
G

s
r
e
b
m
u
N

l
l

A
t
e
G

s
r
e
t
t
e
L

l
l

A
t
e
G

r
a
h
C
e
e
r
h
T
t
s
r
i
F
t
e
G

r
a
h
C
o
w
T
t
s
r
i
F
t
e
G

r
a
h
C
r
u
o
F
t
s
r
i
F
t
e
G

r
a
h
C
e
v
i
F
t
s
r
i
F
t
e
G

t
i
g
D

i

t
s
r
i
F
t
e
G

i

t
i
g
D
e
e
r
h
T
t
s
r
i
F
t
e
G

i

t
i
g
D
o
w
T
t
s
r
i
F
t
e
G

i

t
i
g
D
r
u
o
F
t
s
r
i
F
t
e
G

i

t
i
g
D
e
v
i
F
t
s
r
i
F
t
e
G

d
r
o
W
s
p
a
C
t
s
r
i
F
t
e
G

d
r
o
W
s
p
a
C
d
n
o
c
e
S
t
e
G

d
r
o
W
s
p
a
C
h
t
r
u
o
F
t
e
G

d
r
o
W
s
p
a
C
d
r
i
h
T
t
e
G

d
r
o
W
s
p
a
C
h
t
f
i
F
t
e
G

d
r
o
W
s
p
a
C
t
s
a
L
t
e
G

h
s
a
D
d
n
o
c
e
S
o
T
h
s
a
D

t
s
r
i
F
t
e
G

a
m
m
o
C
t
s
r
i
F
o
T
t
r
a
t
S
t
e
G

d
n
E
o
T
h
s
a
D

t
s
a
L
t
e
G

d
n
E
o
T
e
c
a
p
S
t
s
r
i
F
t
e
G

e
c
a
p
S
t
s
a
L
o
T
t
r
a
t
S
t
e
G

d
n
E
o
T
e
c
a
p
S
t
s
a
L
t
e
G

h
s
a
D
o
T
t
r
a
t
S
t
e
G

a
m
m
o
C
d
r
i
h
T
d
n
A
d
n
o
c
e
S
n
e
e
w
t
e
B
d
r
o
W

t
e
G

a
m
m
o
C
d
n
o
c
e
S
d
n
A
t
s
r
i
F
n
e
e
w
t
e
B
d
r
o
W

t
e
G

s
a
m
m
o
C
h
t
i

W

s
e
c
a
p
S
e
c
a
p
e
R

l

s
e
h
s
a
D
h
t
i

W

s
e
c
a
p
S
e
c
a
p
e
R

l

d
n
E
o
T
a
m
m
o
C
t
s
a
L
t
e
G

s
e
r
o
c
s
r
e
d
n
U
h
t
i

W

s
e
c
a
p
S
e
c
a
p
e
R

l

d
n
E
d
n
A
e
c
a
p
S
a
m
m
o
C
n
e
e
w
t
e
B
d
r
o
W

t
e
G

l

d
n
E
o
T
n
o
o
C
t
s
a
L
n
e
e
w
t
e
B
g
n
i
r
t
S
t
e
G

l

n
o
o
C
d
n
o
c
e
S
o
T
t
r
a
t
S
t
e
G

l

n
o
o
C
t
s
r
i
F
o
T
t
r
a
t
S
t
e
G

n
a
r
a
P
o
T
t
r
a
t
S
t
e
G

t
A
d
n
A
t
r
a
t
S
n
e
e
w
t
e
B
d
r
o
W

t
e
G

d
n
E
d
n
A
t
A
n
e
e
w
t
e
B
d
r
o
W

t
e
G

e
s
a
c
r
e
w
o
L
o
T

e
s
a
c
r
e
p
p
U
o
T

e
s
a
c
r
e
p
o
r
P
o
T

g
n
i
r
t
s

t
u
p
n
i

e
h
t

e
k
a
t

s
n
o
i
t
c
n
u
f

l
l

A

.
s
n
o
i
t
c
n
u
f
x
e
g
e
r
4
0
1
d
n
a

,
s
n
o
i
t
c
n
u
f

m
r
o
f
s
n
a
r
t
3
1
,
s
n
o
i
t
c
n
u
f
p
u
k
o
o
l
8
1
e
r
a

e
r
e
h
t

;
l
e
d
o
m

r
u
o
y
b
d
e
s
u
s
n
o
i
t
c
n
u
f

f
o
t
s
i
l

l
l
u
F

:
6
e
r
u
g
i
F

s
c
i
t
n
a
m
e
s

n
o
i
t
c
n
u
f

o
n

e
d
i
v
o
r
p

e
w

t
a
h
t

l
l
a
c
e
R

.
s
l
l
a
c

n
o
i
t
c
n
u
f

r
e
h
t
o

h
t
i

w
d
e
t
s
e
n

r
o

d
e
t
a
n
e
t
a
c
n
o
c

e
b

n
e
h
t

n
a
c

h
c
i
h
w

,
g
n
i
r
t
s

t
u
p
t
u
o

e
l
g
n
i
s

a

e
c
u
d
o
r
p

d
n
a

t
u
p
n
i

e
h
t

o
t

d
e
d
d
a

e
b

n
a
c

s
n
o
i
t
c
n
u
f

f
o

r
e
b
m
u
n

y
n
a

,
e
r
o
f
e
r
e
h
T

.

n
o
i
t
c
n
u
f

h
c
a
e

f
o

s
n
o
i
t
a
t
n
e
s
e
r
p
e
r

t
n
e
t
a
l

s
n
r
a
e
l

y
l
t
i
c
i
l
p
m

i

l
e
d
o
m
e
h
t

;
l
e
d
o
m
e
h
t

o
t

s
n
o
i
t
c
n
u
f

e
v
o
b
a

e
h
t

f
o

y
n
a

s
a

f
o

.
s
n
o
i
t
a
c
ﬁ

i
d
o
m
d
e
e
n

t
o
n

l
l
i

w
s

m
h
t
i
r
o
g
l
a
g
n
i
n
r
a
e
l

g
n
i
y
l
r
e
d
n
u

e
h
t

d
n
a

y
r
a
r
b
i
l

s
i
h
t

d
r
o
W
s
p
a
C
t
s
a
L
o
T
d
n
o
c
e
S
t
e
G

e
t
o
u
Q
d
n
o
c
e
S
d
n
A
t
s
r
i
F
t
s
a
L
n
e
e
w
t
e
B
g
n
i
r
t
S
t
e
G

t
o
D
d
n
A
t
r
a
t
S
n
e
e
w
t
e
B
d
r
o
W

t
e
G

d
r
o
W
s
p
a
C
t
s
a
L
o
T
h
t
r
u
o
F
t
e
G

d
r
o
W
s
p
a
C
t
s
a
L
o
T
d
r
i
h
T
t
e
G

r
e
b
m
u
N
t
s
r
i
F
f
O
d
n
E
o
T
t
r
a
t
S
t
e
G

d
n
E
d
n
A
t
o
D
n
e
e
w
t
e
B
d
r
o
W

t
e
G

r
a
h
C
t
s
r
i
F
t
e
G

e
c
a
p
S
t
s
r
i
F
o
T
t
r
a
t
S
t
e
G

r
e
b
m
u
N
t
s
a
L
o
T
h
t
r
u
o
F
t
e
G

r
e
b
m
u
N
t
s
a
L
o
T
h
t
f
i
F
t
e
G

l

a
h
p
A
t
s
a
L
o
T
d
n
o
c
e
S
t
e
G

l

a
h
p
A
t
s
a
L
o
T
h
t
r
u
o
F
t
e
G

l

a
h
p
A
t
s
a
L
o
T
d
r
i
h
T
t
e
G

l

a
h
p
A
t
s
a
L
o
T
h
t
f
i
F
t
e
G

l

a
h
p
A
d
n
o
c
e
S
t
e
G

l

a
h
p
A
h
t
r
u
o
F
t
e
G

l

a
h
p
A
d
r
i
h
T
t
e
G

l

a
h
p
A
t
s
r
i
F
t
e
G

l

a
h
p
A
h
t
f
i
F
t
e
G

l

a
h
p
A
t
s
a
L
t
e
G

S
W
d
n
o
c
e
S
t
e
G

S
W
h
t
r
u
o
F
t
e
G

S
W
d
r
i
h
T
t
e
G

S
W

t
s
r
i
F
t
e
G

S
W
h
t
f
i
F
t
e
G

S
W

t
s
a
L
t
e
G

d
r
o
W

t
s
a
L
o
T
d
n
o
c
e
S
t
e
G

d
r
o
W

t
s
a
L
o
T
h
t
r
u
o
F
t
e
G

d
r
o
W

t
s
a
L
o
T
d
r
i
h
T
t
e
G

d
r
o
W

t
s
a
L
o
T
h
t
f
i
F
t
e
G

r
e
b
m
u
N
d
n
o
c
e
S
t
e
G

r
e
b
m
u
N
h
t
r
u
o
F
t
e
G

r
e
b
m
u
N
d
r
i
h
T
t
e
G

r
e
b
m
u
N
t
s
r
i
F
t
e
G

r
e
b
m
u
N
h
t
f
i
F
t
e
G

r
e
b
m
u
N
t
s
a
L
t
e
G

r
e
b
m
u
N
t
s
a
L
o
T
d
n
o
c
e
S
t
e
G

r
e
b
m
u
N
t
s
a
L
o
T
d
r
i
h
T
t
e
G

d
r
o
W
d
n
o
c
e
S
t
e
G

d
r
o
W
h
t
r
u
o
F
t
e
G

d
r
o
W
d
r
i
h
T
t
e
G

d
r
o
W
h
t
f
i
F
t
e
G

d
r
o
W

t
s
a
L
t
e
G

)
4
0
1
(

x
e
g
e
R

d
r
o
W

t
s
r
i
F
t
e
G

l

o
b
m
y
S
k
c
o
t
S
m
o
r
F
y
n
a
p
m
o
C
t
e
G

l

O
E
C
m
o
r
F
o
b
m
y
S
k
c
o
t
S
t
e
G

y
n
a
p
m
o
C
m
o
r
F
O
E
C
t
e
G

r
b
b
A
e
t
a
t
S
m
o
r
F
e
t
a
t
S
t
e
G

e
t
a
t
S
m
o
r
F
r
b
b
A
e
t
a
t
S
t
e
G

i

e
d
o
c
p
Z
m
o
r
F
y
t
i
C
t
e
G

y
t
i
C
m
o
r
F
e
t
a
t
S
t
e
G

)
3
1
(

m
r
o
f
s
n
a
r
T

l

a
i
t
i
n
I
t
s
r
i
F
t
e
G

l

a
i
t
i
n
I
t
s
a
L
t
e
G

e
t
a
D
m
o
r
F
y
a
d
k
e
e

W

t
e
G

e
t
a
D
m
o
r
F
h
t
n
o
M
t
e
G

e
t
a
D
m
o
r
F
r
a
e
Y
t
e
G

l

e
t
a
D
m
o
r
F
a
n
d
r
O
t
e
G

i

s
I
P
A

f
o

t
e
S
e
t
e
l

p
m
o
C
e
h
T

A

x
i
d
n
e
p
p
A

e
m
a
N
t
e
e
r
t
S
t
e
G

m
u
N
t
e
e
r
t
S
t
e
G

)
8
1
(

p
U
k
o
o
L

e
m
a
N
y
t
i
C
t
e
G

m
u
N
t
p
A
t
e
G

e
m
a
N
e
t
a
t
S
t
e
G

r
b
b
A
e
t
a
t
S
t
e
G

e
m
a
N
t
s
r
i
F
t
e
G

e
m
a
N
t
s
a
L
t
e
G

e
d
o
c
p
Z
t
e
G

i

y
n
a
p
m
o
C
t
e
G

O
E
C
t
e
G

x
ﬃ
u
S
t
e
G

e
l
t
i
T
t
e
G

l

o
b
m
y
S
k
c
o
t
S
t
e
G

y
a
d
k
e
e

W

t
e
G

h
t
n
o
M
t
e
G

r
a
e
Y
t
e
G

e
t
a
D
t
e
G

S
W

t
s
a
L
o
T
d
n
o
c
e
S
t
e
G

S
W

t
s
a
L
o
T
h
t
r
u
o
F
t
e
G

S
W

t
s
a
L
o
T
d
r
i
h
T
t
e
G

S
W

t
s
a
L
o
T
h
t
f
i
F
t
e
G

)
.
t
n
o
c
(

x
e
g
e
R

s
o
r
e
Z
g
n
d
a
e
L
m

i

i
r
T

s
e
c
a
p
S
m

i
r
T

y
t
i
t
n
e
d
I
t
e
G

B Samples of Training Data

DAPIP Prediction: (Concat (ConstStr CONST10) (GetStreetName (arg inp)))
Inputs:
} summer Impulse St. Pellerin
Hensley Bag St. HI Rinaldo Nolan @
hook Gertha % Plate St. hobbies MT
discussion Mcfarlin . Straw St.
hobbies Anger St. Twitty Downing ?

Outputs:
Mr.Impulse St.
Mr.Bag St.
Mr.Plate St.
Mr.Straw St.
Mr.Anger St.

Predictions:
Mr.Impulse St.
Mr.Bag St.
Mr.Plate St.
Mr.Straw St.
Mr.Anger St.

DAPIP Prediction: (Concat (ConstStr CONST36) (GetStateName (arg inp)))
Inputs:
MA , North Carolina Zehr Gilma
Utah Evelia % Nancy
Josh skin . Missouri Agudelo
yarn drawer ‘ Indiana
Sandidge ) key Indiana

Outputs:
North Carolina
Utah
Missouri
Indiana
Indiana

Predictions:
North Carolina
Utah
Missouri
Indiana
Indiana

DAPIP Prediction: (Concat (GetStateAbbrFromState (arg inp)) (ConstStr CONST25))
Inputs:
Elza Foot Locker Illinois @bo.com Mollett
$ can Sound St. mist Nevada
Harpin Utah . Reali RI Laurinda Borden
) Connecticut Belt Mortimer
Danita Tennessee throat

Outputs:
IL *
NV *
UT *
CT *
TN *

Predictions:
IL *
NV *
UT *
CT *
TN *

DAPIP Prediction: (GetSecondToLastWS (arg (GetCEO (arg inp))))
Inputs:
Eldora John Thain Marotta
Marya clover Sundar Pichai
327 drawer Gregory Wasson Kristian
! AOL Inc. Rinaldo quicksand James Gorman
Richard Johnson Barbie Gasaway

Outputs:
John
Sundar
Gregory
James
Richard

Predictions:
John
Sundar
Gregory
James
Richard

Figure 7: Selected samples of correct model predictions on the FlashFill++ synthetic test set. These samples also provide
samples of the nature of the programmatically generated training data for the FF and FF++ models. Note that because these
programs rely on the semantic Lookup and Transform APIs, there is no provided reference FlashFill program, as there would
be no program that could solve these synthetic benchmarks.

C Samples of Solved FlashFill Benchmarks

(SubStr (RegPos (RegexStr (ConstStr ”0-0”)) (k 1) (dir End))(RegPos (RegexStr

FlashFill Program:
REGEX4) (k 4) (dir End)))
DAPIP Prediction: (TrimLeadingZeros (arg (GetFirstDashToSecondDash (arg Inp))))
Outputs:
Inputs:
9:50
09:40-09:50
8:30
09:50-08:30
7:30
09:50-07:30
9:55
09:50-09:55
6:30
05:50-06:30

Predictions:
9:50
8:30
7:30
9:55
6:30

FlashFill Program: (Concat (SubStr (RegPos (RegexStr REGEX8) (k 1) (dir End)) (RegPos (RegexStr
REGEX1) (k 1) (dir End))) (ConstStr ”@”))
DAPIP Prediction: (Concat (ToLowercase (arg (GetFirstWord (arg Inp))) (ConstStr CONST13))
Inputs:
Sophia Underwood
Logan Smith
Lucas Janckle
Audrey Bennette
Amelia Ford

Predictions:
sophia@
logan@
lucas@
audrey@
amelia@

Outputs:
sophia@
logan@
lucas@
audrey@
amelia@

(Concat (GetStartToEndOfFirstNumber (arg (ToUppercase (arg Inp))) (ConstStr

FlashFill Program: (Concat (SubStr (RegPos (RegexStr REGEX8) (k 1) (dir End)) (RegPos (RegexStr
REGEX4) (k 1) (dir End))) (ConstStr ”]”))
DAPIP Prediction:
CONST12))
Inputs:
[CPT-00350
[CPT-11523]
[CPT-23412]
[CPT-23412
[CPT-2422]

Predictions:
[CPT-00350]
[CPT-11523]
[CPT-23412]
[CPT-23412]
[CPT-2422]

Outputs:
[CPT-00350]
[CPT-11523]
[CPT-23412]
[CPT-23412]
[CPT-2422]

FlashFill Program: (SubStr (RegPos (RegexStr REGEX8) (k 1) (dir End)) (RegPos (RegexStr REGEX4) (k
1) (dir End)))
DAPIP Prediction: (GetLastNumber (arg (TrimSpaces (arg GetFirstAlpha (arg Inp)))))
Outputs:
Inputs:
1
1:42:00 AM
4
4:18:00 AM
6
6:54:00 PM
11
11:06:00 AM
9
9:12:00 AM

Predictions:
1
4
6
11
9

Figure 8: Selected samples of correct model predictions on the Flashﬁll test set. We additionally provide the program that
FlashFill inferred given the input-output pairs, and contrast that with DAPIP’s prediction. Note that DAPIP programs have a
much higher level of expressivity and interpretability.

D Samples of Unsolved FlashFill Benchmarks

FlashFill Program: (Concat (Concat (Concat (Concat (Concat (Concat (Concat (Concat (Concat (Concat
(SubStr (RegPos (RegexStr REGEX8) (k 1) (dir End)) (RegPos (RegexStr REGEX1) (k 1) (dir End))) (Con-
stStr ”,”)) (SubStr (RegPos (RegexStr REGEX7) (k 1) (dir End)) (RegPos (RegexStr REGEX1) (k 2) (dir
End)))) (ConstStr ”,”)) (SubStr (RegPos (RegexStr REGEX7) (k 2) (dir End)) (RegPos (RegexStr REGEX1)
(k 3) (dir End)))) (ConstStr ”,”)) (SubStr (RegPos (RegexStr REGEX7) (k 3) (dir End)) (RegPos (RegexStr
REGEX1) (k 4) (dir End)))) (ConstStr ”.”)) (ConstStr ”and”)) (ConstStr ”.”)) (SubStr (RegPos (RegexStr
REGEX7) (k 4) (dir End)) (RegPos (RegexStr REGEX10) (k 1) (dir End))))
Inputs:
Tom Mickey Minnie Donald Daﬀy
Ben Bill Jerry Meyer Rahul
Shahrukh Aamir Salman Amitabh Ajay
Kobe Lebron Dwayne Chris Kevin
Earth Fire Wind Water Sun

Outputs:
Tom,Mickey,Minnie,Donald.and.Daﬀy
Ben,Bill,Jerry,Meyer.and.Rahul
Shahrukh,Aamir,Salman,Amitabh.and.Ajay
Kobe,Lebron,Dwayne,Chris.and.Kevin
Earth,Fire,Wind,Water.and.Sun

FlashFill Program: (Concat (Concat (Concat (SubStr (RegPos (RegexStr REGEX8) (k 1) (dir End)) (RegPos
(RegexStr REGEX4) (k 1) (dir End))) (SubStr (RegPos (RegexStr (ConstStr ”1-”)) (k 1) (dir End)) (RegPos
(RegexStr REGEX4) (k 2) (dir End)))) (SubStr (RegPos (RegexStr (ConstStr ”-”)) (k 2) (dir End)) (RegPos
(RegexStr REGEX4) (k 3) (dir End)))) (SubStr (RegPos (RegexStr (ConstStr ”-”)) (k 3) (dir End)) (RegPos
(RegexStr REGEX4) (k 4) (dir End))))
Inputs:
1-452-789-4567
1-503-897-4567
1-408-789-4561
1-406-789-1562
1-845-456-7891

Outputs:
14527894567
15038974567
14087894561
14067891562
18454567891

Figure 9: Selected samples from the FlashFill benchmarks that could not be solved by our model; benchmarks such as these
constitute the 55% of FlashFill benchmarks that our model cannot solve. At present, the maximum length of programs that
DAPIP can produce is only 10, and these particular benchmarks would require much longer programs. However, if the batching
of trees can be done more efﬁciently, the system can be trained on longer programs and it is conceivable that these benchmarks
can be solved.

