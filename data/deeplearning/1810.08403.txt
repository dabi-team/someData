8
1
0
2

t
c
O
9
1

]

C
D
.
s
c
[

1
v
3
0
4
8
0
.
0
1
8
1
:
v
i
X
r
a

Towards Efﬁcient Large-Scale Graph Neural Network Computing

Lingxiao Ma†∗, Zhi Yang†∗, Youshan Miao‡, Jilong Xue‡, Ming Wu‡, Lidong Zhou‡, Yafei Dai†

†Peking University, Beijing, China
‡Microsoft Research, Beijing, China

Abstract

Recent deep learning models have moved beyond low-
dimensional regular grids such as image, video, and
speech, to high-dimensional graph-structured data, such
as social networks, brain connections, and knowledge
graphs. This evolution has led to large graph-based ir-
regular and sparse models that go beyond what exist-
ing deep learning frameworks are designed for. Further,
these models are not easily amenable to efﬁcient, at scale,
acceleration on parallel hardwares (e.g. GPUs).

We introduce NGra,

the ﬁrst parallel process-
ing framework for graph-based deep neural networks
(GNNs). NGra presents a new SAGA-NN model for ex-
pressing deep neural networks as vertex programs with
each layer in well-deﬁned (Scatter, ApplyEdge, Gather,
ApplyVertex) graph operation stages. This model not
only allows GNNs to be expressed intuitively, but al-
so facilitates the mapping to an efﬁcient dataﬂow rep-
resentation. NGra addresses the scalability challenge
transparently through automatic graph partitioning and
chunk-based stream processing out of GPU core or over
multiple GPUs, which carefully considers data locali-
ty, data movement, and overlapping of parallel process-
ing and data movement. NGra further achieves efﬁcien-
cy through highly optimized Scatter/Gather operators on
GPUs despite its sparsity. Our evaluation shows that
NGra scales to large real graphs that none of the exist-
ing frameworks can handle directly, while achieving up
to about 4 times speedup even at small scales over the
multiple-baseline design on TensorFlow.

1

Introduction

Deep learning,
in the form of deep neural networks
(DNNs), has been gaining popularity due to its suc-

∗ These authors contributed equally to this work.
∗∗ This work is done when Lingxiao Ma is an intern and Zhi Yang

is a visiting researcher at Microsoft Research.

cess in areas such as speech, vision, and natural lan-
guage processing.
In these areas, the coordinates of
the underlying data representation often have a regu-
lar grid structure, which is friendly to hardware ac-
celeration (e.g., GPU) with massive SIMD-style data-
parallelism. There is an emerging trend in applying deep
learning models on data with an irregular graph struc-
ture [9, 22, 25, 13, 15, 4, 5, 29], driven by the importance
of the graph data such as social networks, knowledge
graphs, and graphs in bioinformatics and neuroscience
(e.g., protein-protein interactions or neuron connections
in brains), and moving the state-of-the-art prediction re-
sults in their targeted applications (e.g., classiﬁcation,
embedding, and query-answering). These graph-based
neural networks (GNNs) typically apply neural network
models over the features associated with vertices and
edges in a graph, and propagate and aggregate the results
to produce the next-level features.

None of the existing solutions supports GNNs well.
The existing graph process engines [28, 26, 11, 6, 41]
often provide a Gather-Apply-Scatter (GAS)-like vertex-
program model, but incapable of expressing and sup-
porting neural network architectures within the graph
constructs. Deep learning frameworks such as Tensor-
Flow [3], PyTorch [2], MxNet [8], and CNTK [42] are
designed to express neural networks as dataﬂow graphs,
but do not support a graph-propagation model direct-
ly. In addition, none of them offer the needed scalabil-
ity to handle large graphs, nor do they support efﬁcient
GPU-based implementation of graph propagation oper-
ators (which translate into sparse operations). The cur-
rent lack of support has seriously limited the ability to
explore the full potentials of GNNs at scale, as the com-
bination of DNNs and large graph structures poses sig-
niﬁcant challenges at the system level.
In this paper, we present NGra,

the ﬁrst system
to support large-scale GNNs, from an easy-to-express
programming model to a scalable and efﬁcient paral-
lel processing engine on GPUs. NGra naturally com-

 
 
 
 
 
 
bines dataﬂow with a vertex-program abstraction in
a new model called SAGA-NN (Scatter-ApplyEdge-
Gather-ApplyVertex with Neural Networks). Whereas
SAGA can be considered a variant of the GAS model,
the user deﬁned functions in the SAGA-NN model allow
users to express neural network computation over ver-
tex or edge data (which are treated as tensors) by using a
dataﬂow abstraction, rather than those designed for tradi-
tional graph processing (e.g., algorithms such as PageR-
ank, connected component, and shortest path)

Just as with DNNs, efﬁcient use of GPUs is critical
to the performance of GNNs and is more so due to the
additional challenge of handling large graph structures.
To achieve scalability beyond the physical limitation of
GPUs, NGra transparently partitions a graph (vertex and
edge data) into chunks, and translates a GNN algorithm
expressed in the SAGA-NN model into a dataﬂow graph
with operators at the chunk granularity, through which
it enables chunk-based parallel stream processing on a
single or multiple GPUs.

The efﬁciency of the NGra engine then hinges heav-
ily on how well NGra manages and schedules the par-
allel stream processing and the implementation of the
key graph propagation operators, Scatter and Gather, on
GPUs. NGra pays careful attention to data locality to
minimize swapping data in and out of GPU memory
and to maximize the reuse of data chunks while in GPU
memory, while overlapping the data movement and the
computation in a streaming way. For the multi-GPU
case, it uses a ring-based streaming mechanism to avoid
redundant data movement from host memory by ex-
changing data chunks among GPUs directly. The Scatter
and Gather stages in the SAGA-NN model conduct the
vertex data propagation along edges and behave as ma-
trix multiplications on sparse structures. It is notorious-
ly difﬁcult to perform sparse matrix operation on data-
parallel hardware like GPU. NGra therefore introduces
special operators supported by a graph propagation en-
gine into the dataﬂow graph and optimizes its execution
on GPUs. Note that, unlike the traditional graph process-
ing scenarios that other GPU-based graph engines focus
on, in GNN scenarios, the mutable vertex data itself may
not be accommodated in GPU device memory since the
data of each vertex can be a feature vector rather than a
simple scalar. Our scheme, therefore, prefers to exploit
parallelism in per-vertex data access to beneﬁt more on
memory access efﬁciency.

We implement NGra through extending TensorFlow
with vertex-program abstraction and custom operators
for graph propagation procedure. We demonstrate that
NGra can scale to support a variety of GNN algorithms
on large graphs containing millions of vertices with hun-
dreds of feature dimensions and hundred millions of
edges through leveraging the host memory of a single

Figure 1: Feed-forward computation of a 2-layer GNN.

server and the computation power of GPU(s), which can-
not be achieved by using existing deep learning frame-
works directly. Compared with TensorFlow on small
graphs that it can support with GPU, NGra obtains up
to about 4x speedup. We also extensively evaluate the
improvements caused by the multiple optimizations in
NGra to demonstrate their effectiveness.

The rest of the paper is organized as follows. Sec-
tion 2 introduces the SAGA-NN programming abstrac-
tion. Section 3 describes the components, mechanisms,
and optimizations in NGra system. Section 4 presents the
ring-based streaming scheme in NGra to scale for multi-
ple GPUs. Section 5 illustrates the usage of the SAGA-
NN model with applications. Section 6 discusses the im-
plementation and evaluation of NGra. We discuss related
work in Section 7 and conclude in Section 8.

2 NGra Programming Abstraction

Graph-based neural network (GNN) is a general neural
network architecture deﬁned according to a graph struc-
ture. Each vertex or edge in the graph can be associated
with a tensor data (normally a vector) as its feature or em-
bedding. GNN can be stacked in multiple layers, with an
iterative propagation procedure conducted layer-by-layer
over the same graph. In each layer, the vertex or edge
features are transformed and propagated along edges and
aggregated at the target vertices to produce the new fea-
tures for the next layer. The transformation can be an ar-
bitrary DNN computation. The graph may also contain
a label for each vertex, each edge, or the entire graph,
for computing a loss function at the top layer. A feed-
forward computation is then performed from the bottom
layer to the top layer, with the back-propagation conduct-
ed reversely. Figure 1 illustrates the feed-forward com-
putation of a 2-layer GNN.

We now use the Gated Graph ConvNet (G-GCN) algo-
rithm [29, 4] as a concrete example. Graph ConvNet gen-
eralizes the notion of the convolution operation, typically
applied on image datasets, to apply to an arbitrary graph

2

vertex(cid:96)+1 = G-GCN(vertex(cid:96))

H W (cid:96)

C W (cid:96)]

params p = [W (cid:96)
// Passing data over edges
edge(cid:96)=Scatter(vertex(cid:96));
// edge-parallel computation
acc = ApplyEdge(edge(cid:96), p)

η = sigmoid(p.W (cid:96)
return η (cid:12) edge(cid:96).src

H ⊗ edge(cid:96).src + p.W (cid:96)

C ⊗ edge(cid:96).dest)

set Gather.accumulator = sum
accum = Gather(acc)
// compute new vertex data
vertex(cid:96)+1 = ApplyVertex(vertex(cid:96), accum, p)

return ReLU (cid:0)p.W (cid:96) ⊗ accum(cid:1)

return vertex(cid:96)+1

Figure 2: Gated Graph ConvNet at layer (cid:96) in the SAGA-
NN model, where ⊗ refers to matrix multiplication.

(e.g., a knowledge graph). Gated Graph ConvNet further
incorporates the gates mechanism, so that the model can
learn which edges are more important for the learning
target. The feed-forward computation of G-GCN at each
layer is formalized recursively in Example 2.1.

Example 2.1. Let h(cid:96)
u denote the feature vector of a ver-
tex u at layer (cid:96), and W (cid:96), W (cid:96)
C are the weight pa-
rameters to learn. The gated graph ConvNet algorithm
recursively deﬁnes the feature of a vertex u as follows:

H , and W (cid:96)

h(cid:96)+1
u = ReLU

(cid:18)

W (cid:96)

(cid:18)

∑
v→u

(cid:19)(cid:19)

ηvu (cid:12) h(cid:96)
v

where (cid:12) is the element-wise multiplication and ηvu (for
each edge v → u) acts as edge gate computed by:

ηvu = sigmoid

(cid:16)
W (cid:96)

H h(cid:96)

u + W (cid:96)

Ch(cid:96)
v

(cid:17)

2.1 SAGA-NN Model

To express the recursive computation at each layer of
a GNN, which contains both graph propagation and
DNN computation, we propose a SAGA-NN (Scatter-
ApplyEdge-Gather-ApplyVertex with Neural Networks)
vertex-program abstraction.
SAGA-NN deﬁnes four
stages of a feed-forward computation in each layer of a
GNN: Scatter, ApplyEdge, Gather, and ApplyVertex.

SAGA-NN provides

two user-deﬁned functions
(UDFs) for ApplyEdge and ApplyVertex, respectively, to
declare the neural network computations on edges and
vertices. The ApplyEdge function deﬁnes the computa-
tion on each edge, which takes edge and p as inputs,
where edge is the abstraction of edge data and p con-
tains the learnable parameters of the GNN model. Each
edge is a tuple of tensors [src, dest, data] repre-
senting the data of the source and destination vertices
connected by the edge, as well as the edge associated da-
ta; e.g., edge weight. This function can be used to apply

3

Figure 3: SAGA-NN Stages for each layer of GNN.

a neural network model on edge and p, and output an
intermediate tensor value associated with the edge. The
ApplyVertex function deﬁnes the computation on a ver-
tex, which takes as input a vertex tensor data vertex,
the vertex aggregation accum and learnable parameters
p, and returns the new vertex data through applying a
neural network model. The SAGA-NN abstraction builds
on a dataﬂow framework, so users can symbolically de-
ﬁne the dataﬂow graphs in UDFs by connecting math-
ematical operations (e.g., add, tanh, sigmoid, matmul)
provided by the underlying framework.

The other two stages, Scatter and Gather, perform da-
ta propagation and prepare data collections for inputs of
ApplyEdge and ApplyVertex. They are triggered and con-
ducted by the system implicitly, and do not require users
to provide explicit UDFs. Figure 2 illustrates the descrip-
tion of G-GCN (at layer l) in the SAGA-NN model.

2.2 Execution Semantics

For each GNN layer, the four-stage execution ﬂow of
a feed-forward computation is illustrated in Figure 3.
It starts from the Scatter stage, where the tensor da-
ta vertex of each vertex is passed onto the adjacent
edges to construct edge data edge, containing both the
source and destination vertex data. The subsequent Ap-
plyEdge stage then invokes a parallel computation de-
ﬁned by the ApplyEdge function on the edge data to
produce an intermediate tensor value for each edge as its
outputs. The Gather stage then propagates those outputs
along the edges and aggregates them at the destination
vertices through commutative and associative accumu-
late operations. Finally, the ApplyVertex stage executes
the computation deﬁned in ApplyVertex function on all

accum.V2V1V0edgeedgeScatterApplyEdgeGatherApplyVertexvertex featureedge featureedge outputaccumulatedvertex outputvertices to produce updated vertex data for the next layer.
A GNN training process also involves a backward
computation phase in each stage of a layer (cid:96) for back-
propagation of gradients. The backward computations
are invoked in the reverse order of the feed-forward
it starts from the backward-VertexApply
computation:
stage, which takes the gradient ∇vertex(cid:96)+1 passed
from layer (cid:96) + 1 as input to update the corresponding
learnable parameters on vertices, and outputs the gradi-
ent ∇accum and the partial vertex gradient ∇vertex(cid:96)
p.
Then the backward-Gather stage takes ∇accum as input
and computes its output gradient ∇acc for each edge
based on the accumulate function used in Gather. The
subsequent backward-ApplyEdge stage then takes ∇acc
as input to update the learnable parameters relevant to
edge, and outputs the partial vertex gradients ∇vertex(cid:96)
p
for both the source and destination vertices. Finally, the
backward-Scatter stage accumulates all the partial gra-
dients for a vertex to generate the ﬁnal ∇vertex(cid:96) and
pass to layer (cid:96) − 1.

NGra can automatically generate the corresponding
back-propagation execution for each layer of GNN de-
ﬁned in the SAGA-NN model, because the UDFs for
ApplyEdge and ApplyVertex are expressed as dataﬂow
computations over regular tensors and can therefore
leverage auto-differentiation provided by the deep learn-
ing frameworks. We choose not to expose UDFs for
Scatter and Gather, because these UDFs, if provid-
ed, are highly coupled with the propagation procedure,
whose computations ﬂow through the irregular graph
structure and are hard to be expressed as dataﬂow that
NGra optimizes—users would have to implement the
corresponding derivative functions of the UDFs, a seri-
ous burden. Following the same principle, NGra also
It
avoids to expose user-deﬁned aggregation methods.
provides a set of default ones instead, including max,
sum, and concatenation, which can be chosen by setting
Gather.accumulator (as shown in Figure 2).

By carefully combining dataﬂow with the vertex-
program abstraction, SAGA-NN inherits beneﬁts from
both. The dataﬂow abstraction makes it easy to ex-
press neural network architectures in GNNs and lever-
age auto-differentiation. The vertex-program in SAGA-
NN allows users to express computations naturally by
thinking locally as a vertex and captures common pat-
terns in GNNs as well-deﬁned stages, thereby enabling
graph-related optimization (e.g., efﬁcient graph propa-
gation procedures) and helping produce streaming-based
dataﬂow graph with an optimized scheduling strategy.

3 NGra System

NGra provides a combination of the dataﬂow and vertex-
program abstractions as the user interface. Under-

neaththis abstraction, NGra mainly consists of 1) a front-
end that translates the algorithm implemented in SAGA-
NN model into a chunk-granularity dataﬂow graph to en-
able GNN computation on large graph in GPU; 2) an op-
timization layer that produces a scheduling strategy for
minimizing data movement between host and GPU de-
vice memory, and recognizes opportunities to fuse op-
erations and remove redundant computations; 3) a set
of efﬁcient propagation operation kernels that support
streaming-based processing to overlap data movement
and computation in GPU; 4) a dataﬂow execution run-
time. Because NGra largely leverages existing dataﬂow-
based deep learning frameworks for the dataﬂow execu-
tion runtime, we focus on the design of the ﬁrst three in
this section as they are the main contributions of NGra.

3.1 Chunk-Based Streaming Dataﬂow

When exploiting computation power of GPU, existing
deep learning frameworks assume that the input and out-
put tensor data of a single operator in the dataﬂow graph
can be fully held in GPU device memory. However,
when treating the vertex or edge data of an entire graph
as a single tensor or matrix, this assumption often fails
to hold for large graphs, which limits the scale of the
graph that the system can support efﬁciently. To address
this problem, NGra splits the vertex and edge data of
the graph into small chunks that can ﬁt into GPU device
memory and constructs a dataﬂow graph with operators
processing computations at the chunk granularity.

NGra splits vertex and edge data into chunks through
a 2D partitioning to tile the adjacency matrix represent-
ing the edges in the graph, with vertex data split into
the corresponding equally-sized disjoint vertex id inter-
vals. This way, edges in each edge chunk connect the
vertices in two vertex chunks as sources and destina-
tions, respectively. As illustrated in Figure 4, edge chunk
Ci j contains edges connecting source vertices in vertex
chunk Vi and destination vertices in vertex chunk Vj. In
each edge chunk, for feed-forward computation, edges
are laid out in a compressed sparse column (CSC) for-
mat with edges clustered by destination vertex id, where-
as for back-propagation computation, edges are arranged
in compressed sparse row (CSR) format. NGra also
makes a best effort to re-encode vertex ids to equalize
the numbers of edges in edge chunks for balanced chunk-
granularity computation.

By splitting data into chunks, NGra is able to gen-
erate a dataﬂow graph with operators operating on da-
ta chunks that ﬁt in GPU memory.
In the dataﬂow
graph, the outputs of the operators in the Scatter stage
are a grid of edge data chunks with edge data the tu-
ple [src,dest,data] (in Section 2.1). Each edge da-
ta chunk is then processed by the operators in the Ap-

4

Figure 4: Chunk-based dataﬂow graph for a destination interval V0 at a G-GCN layer. The swap-out of output tensors
of operations from the SAG phase when connecting to D2H is hidden in the SAG sub-graph for a clear visualization.

plyEdge stage to produce another grid of edge data
chunks with edge data acc (as in Figure 2). The op-
erators in the Gather stage then accumulate these edge
data chunks based on the destination vertices to generate
the corresponding vertex data chunks as the inputs for
the ApplyVertex stage that follows.

A naive scheduling strategy for this dataﬂow graph is
to execute the operators stage-by-stage. However, since
the size of the output data chunk grids of a stage can be
large and may not be accommodated in the GPU device
memory, they will be swapped out to host memory after
the completion of the current stage and before the be-
ginning of the next, thereby losing the opportunity for
the operators in the next stage to reuse the output da-
ta chunks that already reside in GPU device memory in
the current stage. For example, when the Gather stage
outputs a vertex chunk with the accumulated vertex data,
the scheduler may choose to schedule the operators in the
same Gather stage to produce a next vertex chunk, or, it
may immediately schedule the operators in the following
ApplyVertex stage to consume the current vertex chunk
since it is already in the GPU device memory.

NGra therefore adopts a scheduling strategy for every
GNN layer as illustrated in Figure 4. For each output
vertex chunk of the Gather stage (e.g., A0 in the ﬁgure)
that maintains the accumulated values for the destination
vertices in the chunk, it may be used as input and output
by multiple operators in the same Gather stage for the
different source vertex chunks (e.g., V0, V1, and V2). The
scheduler tries to hold it in GPU device memory to keep
reusing it for those Gather operators until it is consumed
by the operators in the following ApplyVertex stage. As
in Figure 4, NGra continuously executes operators in the

Scatter, ApplyEdge, and Gather (S-A-G) stages and re-
peats this pattern for V0, V1, and V2 to produce the ﬁnal
A0, followed by the corresponding operators in the Ap-
plyVertex stage that consumes A0. It then schedules the
operators to produce the next output vertex chunk of the
Gather stage.

NGra employs explicit device-to-host (D2H) and host-
to-device (H2D) operators to conduct the data swap be-
tween host and GPU device memory. During a training
process, the intermediate feature data (e.g., the result of
matrix multiplication in the ApplyEdge stage as in Fig-
ure 4) relevant to vertex or edge chunks may be used
in back-propagation. They may be swapped out to host
memory during feed-forward computation and swapped
back in during back-propagation.

Employing explicit data movement operators enables
streaming-based scheduling, to overlap data swap with
other computations in operators that are independent of
the data transferred. For example, at the beginning of
the execution of each GNN layer, the operators in the
Scatter stage can overlap with their corresponding H2D
operators; i.e., the scatter operation on the current vertex
chunk can overlap with the operator that loads the next
vertex chunk from host memory to GPU device memory.

3.2 Dataﬂow Graph Optimization

NGra further optimizes a generated dataﬂow graph to re-
move redundant computations or fuse operations by con-
sidering the semantics of the SAGA-NN model. Con-
sidering the matrix multiplication operations in the Ap-
plyEdge stage as in Figure 4, they perform computations
between the vertex data that are scattered to the edges

5

S-A-GS-A-GV0A0V1C00C10S-A-GA0V2C20A0D2HD2HmatmulReLUWH2DH2DV0 BackwardV0Vertex FeatureEdge ChunkV1V2C00C10C20V1C10ApplyVertexA0matmulsigApplyEdgeScattermulGather2D Graph PartitionH2DD2HD2HH2DV0SrcDestmatmulWHWCWWaddWA0Figure 5: Optimized layer-wise dataﬂow graph in G-GCN.

ter, ApplyEdge, Gather stages can be reduced to a single
propagation procedure using a special customized oper-
ator. NGra automatically detects this case and replaces
the subgraph of these three stages with the special oper-
ator. As shown in Figure 5, for G-GCN, after the matrix
multiplications are moved to ApplyVertex stage, the SAG
phase for each chunk contains only element-wise opera-
tions (e.g., + and sigmoid), so the whole SAG phase is
replaced with a fused-gather operation.

3.3 Propagation Kernels on GPUs

Scatter and Gather are the two key stages to handle the
propagation procedures over the often sparse edge struc-
ture of a graph. To support both stages efﬁciently on
GPUs, NGra provides customized scatter/gather opera-
tion kernels optimized for GPU execution. The design
carefully considers the data structure layout to allow the
kernels to better leverage GPU memory hierarchy (i.e.,
shared memory and register) and massive parallelism.
Even with a sparse graph structure, which often leads to
random access on vertex data, unlike traditional graph
processing scenarios, in most GNN algorithms, the data
of each vertex is a dense vector rather than a scalar, we
therefore prefer to exploit GPU parallelism in per-vertex
data access with a best effort.
Scatter Kernel. The scatter operator passes vertex fea-
ture data, from both source and destination, to edges. In
feed-forward computation, edges are arranged in a CSC
format. We therefore organize the incoming edges of a
single destination vertex as in a group and assign a thread
block to process them. For a vertex with a large in-
degree, we split the edge set into consecutive subgroups
for multiple thread blocks. In each thread block, the pro-
cess of scattering source vertex data consists of two phas-
es, as illustrated in Figure 6(a). First, the threads fetch
the source vertex ids from the edges in the edge group
stored in contiguous address space, and cache them in
the shared memory. Second, the threads copy the vertex
data to the edge data storage in parallel along the dimen-
sions of vertex feature vector. This way, in most cases,
an instruction in a thread-warp may have highly efﬁcient
coalesced memory access. The destination vertex data

Figure 6: Propagation kernels.

and the learnable parameter WC or WH that is shared by
all the edges. Because a vertex may have multiple adja-
cent edges that the vertex data can be scattered to, such
same multiplication for a vertex can be conducted multi-
ple times and redundant. NGra therefore moves the com-
putations that are only related to source or destination
vertices out of the ApplyEdge stage of the current layer
to the ApplyVertex stage of the previous layer. Figure 5
shows the optimized dataﬂow graph with the matrix mul-
tiplications moved into the ApplyVertex stage.

NGra supports operator fusion as another optimiza-
In some GNN algorithms, the ApplyEdge func-
tion.
tion does not perform complex neural network compu-
tation, but only element-wise operations, such as +, -,
×, ÷, tanh, sigmoid, ReLU, etc. In this case, the Scat-

6

A0matmulReLUApplyVertexmatmulSrcDestmatmulWHWCV0WSrcDestC10FusedGatherA0A0S-A-GS-A-GS-A-GA0A0C10C00C2013702DstSrcSrc Features012313Shared MemorySrcBlock 0Vertex FeaturesDst FeaturesRegistersDst: 0Global MemoryBlock 0Dst: 0Edge FeaturesGlobal MemoryAccumRegisters0123VertexAccum(a) Scatter(b) Gather13702DstSrcDstcan be accessed in a similar way. Because destination
data is shared by multiple edges, it can be cached in reg-
ister after being accessed once. In back-propagation, a
similar process is conducted on the CSR edge format.

Gather Kernel. The gather operator collects the fea-
ture vectors of edges to the destination vertices and re-
duces them into a single vector for each destination ver-
tex through a user-provided accumulate function. We
employ a similar principle of exploiting parallelism as
for the scatter operator. The process is illustrated in Fig-
ure 6(b). A block of threads ﬁrst cooperatively enumer-
ate the edge group, and accumulate the features of each
edge into a temporary vector in register, and then write
the result back to the corresponding destination vertex.

4 Parallel Processing with Multiple GPUs

NGra further exploits the parallelism of multiple GPUs
in a single server. Figure 7 shows the interconnection
architecture of a typical 8-GPU server, where GPUs are
connected to CPU/DRAM (host memory) via a multi-
level PCI-Express (PCIe) interface hierarchy.

4.1 Multi-GPU Architecture

In a multi-GPU system, the GPU interconnection has a
hierarchical structure, leading to multiple levels of local-
ity when transferring data across different GPUs or be-
tween host and GPU device memory. For example, as
shown in Figure 7, the communication between GPU 0
and GPU 1 achieves the highest performance as they are
attached to the same PCIe switch. GPU 0 needs to go
through two PCIe switches and one PCIe host bridge
when communicating with device like GPU 2 or 3, there-
fore introducing longer latency and lower throughput.
GPU 0 cannot conduct P2P access when communicating
with GPUs located in other NUMA nodes (e.g., GPU 4
or 7), and hence performs even worse.

In addition, the upper level link bandwidth is shared
by the GPU devices under the same root. For example,
GPU 0 and GPU 1 share the same communication band-
width between the PCIe host bridge and the PCIe switch
that they are rooted at. As a result, their communica-
tions with GPU devices under other PCIe switches may
interfere with each other when conducted concurrently,
leaving their local PCIe bandwidth under-utilized. This
makes the root level links more likely become the bot-
tleneck in parallel computation. We therefore carefully
design the streaming scheme by considering the locality
characteristics of the multi-GPU system to achieve high-
er parallelism and better performance.

Figure 7: Multi-GPU architecture

4.2 Ring-Based Parallel Streaming

Consider a layer of GNN computation, a vanilla solution
to exploit multi-GPU parallelism is to run a dataﬂow sub-
graph (as shown in Figure 4), which produces an output
vertex chunk of the ApplyVertex stage, in a single GPU,
and let multiple GPUs execute different sets of such sub-
graphs. The process of this subgraph essentially out-
puts one vertex chunk (e.g., V (cid:48)
0) and takes a set of vertex
chunks containing all vertices (e.g., V0, V1, and V2) as in-
put. When running these subgraphs in multiple GPUs at
the same time, the same set of vertex chunks are load-
ed from host memory into the device memory of these
GPUs. This makes data transfer bottlenecked at the root
level PCIe links that are shared by all the GPUs. There-
fore, we design a ring-based streaming scheme to allow
GPUs to reuse the data chunks that are already loaded
from host memory by exchanging them directly. We or-
ganize the data-sharing path among the multiple GPUs
as a ring, which is illustrated as the circle with red dot
line in Figure 7. Because both PCIe and QPI links sup-
port duplex [39, 16], the simultaneous data transfers on
the ring do not interfer with each other on bandwidth.
With this scheme, each vertex chunk is loaded from host
memory to enter the ring and passed to all the GPUs on
the ring in order.

Scheduling in Ring-Based Streaming.
In ring-based
streaming, a GPU needs to take the following two ac-
tions: 1) loading a data chunk from the host memory or
from the device memory of the previous GPU in the ring;
2) performing local computations. In order to enable the
overlap between the two actions, NGra introduces an ex-
plicit device-to-device (D2D) operator and employs a co-
ordinated scheduling as illustrated in Figure 8.

In step 1, only GPU 0 and GPU 2 load vertex data
chunks 1 and 3 from the host memory, respectively. Af-
ter loading, in step 2, GPU 0 and GPU 2 start computa-
tions based on chunks 1 and 3, while loading chunks 2
and 4, respectively. At the same time, GPU 1 and GPU 3
start fetching chunks 1 and 3 from GPU 0 and GPU 2. In
step 3 and step 4, they enter the whole-ring forward mode
where there is no data loaded from the host memory. In
step 5, unable to get input vertex data from the ring any

7

CPU / DRAMQPIPCIe SwitchGPU0GPU1PCIe SwitchGPU2GPU3PCIe Host BridgeCPU / DRAMPCIe SwitchGPU4GPU5PCIe SwitchGPU6GPU7PCIe Host Bridgex16x16x16x16x16x16x16x16Ringx16x16x16x16vertex(cid:96)+1 = CommNet(vertex(cid:96))

H , W (cid:96)
C]

params p = [W (cid:96)
// Passing data over edges
edge(cid:96) = Scatter(vertex(cid:96));
// no edge-parallel computation
acc = ApplyEdge(edge(cid:96))

return edge(cid:96).src

set Gather.accumulator = sum
accum = Gather(acc)
// compute new vertex data
vertex(cid:96)+1 = ApplyVertex(vertex(cid:96), accum, p)

return ReLU (cid:0)p.W (cid:96)

H ⊗ vertex(cid:96) + p.W (cid:96)

C ⊗ accum(cid:1)

return vertex(cid:96)+1

Figure 9: Communication Neural Net (CommNet)

vertex(cid:96)+1 = GCN(vertex(cid:96))

params p = W (cid:96)
// Passing data over edges
edge(cid:96) = Scatter(vertex(cid:96));
// edge.data refers to the static weight
acc = ApplyEdge(edge(cid:96))

return edge(cid:96).src × edge.data

set Gather.accumulator = sum
accum = Gather(acc)
// compute new vertex data
vertex(cid:96)+1 = ApplyVertex(vertex(cid:96), accum, p)

return ReLU (cid:0)p.W (cid:96) ⊗ accum(cid:1)

return vertex(cid:96)+1

Figure 10: Graph Convolutional Network (GCN)

on the GPUs that belong to this maximal fat-tree.

5 Applications

NGra can support many different types of graph-based
neural networks [4, 5, 9, 15, 13, 22, 25, 29, 38]. In this
section, we present the layer-wise programs of several
representative GNN models from the literature.
Communication neural net (CommNet)
[38] is a
model where cooperating agents learn to communicate
among themselves before taking actions. Each agent is
controlled by a deep feed-forward network, which addi-
tionally receives the summed transmissions of other con-
nected agents. This network can be used to solve multi-
ple learning communication tasks like trafﬁc control. In
CommNet, there is no computation on the edge, so the
ApplyEdge stage is simpy a passthrough (see Figure 9).
Each agent gets the summed transmissions via the Gath-
er stage, and generates its new hidden state in the Ap-
plyVertex stage.
Graph convolutional networks (GCN) [15, 22] gener-
alizes the notion of CNNs to an operation that operates
on an arbitrary graph. This algorithm has been applied
in many semi-supervised or unsupervised graph cluster-
ing problems, such as entity classiﬁcation in a knowl-

Figure 8: Ring-based streaming in a 4-GPU setting.

more, GPU 0 and GPU 2 read data chunk 5 and 7, respec-
tively, from the host memory. Additionally, GPU 1 and
GPU 3 drop data chunks 3 and 1 after processing them
locally because the chunks have already been consumed
by all the GPUs in the ring. All the GPUs in step 6 take
the same actions as step 5, except that the data chunk
numbers are shifted. And the process enters the whole-
ring forward mode again after that step. The whole pro-
cess continus in such a pipelining fashion until all vertex
data chunks have been loaded and processed.

This scheme leaves GPU 1 and GPU 3 idle in step 1
because it already makes full use of the system band-
width. More concurrent loadings can make things worse.
For example, if all the GPUs load different vertex data
chunks from the host memory simultaneously, through-
put will be limited by root links such as the upper link of
PCIe switch in Figure 7. In this case, GPU 0 and GPU 1
will get only half the bandwidth due to the shared upper
link. Suppose a single GPU needs time t0 to transfer a da-
ta chunk into GPU device memory, two concurrent trans-
fers will take 2 · t0 before starting computation. Actual-
ly, such longer transfer latency will happen each time the
ring loads new data chunks from the host memory, which
leads to extra stalls in the entire processing pipeline.

In addition, analyzing the multi-GPU architecture can
help decide which GPU(s) should perform data load-
ing in ring-based streaming. With host memory as root,
GPUs as leaves, and data links (with bandwidth) as
edges, we can build a bandwidth tree where we can get a
maximal fat-tree by gradually removing GPUs that could
share upper link bandwidth with other GPUs. On top
of Figure 8, we get a maximal bandwidth fat-tree (solid
red line) from the original bandwidth tree (dashed green
line). Data loading from the host memory happens only

8

GPU 0GPU 1GPU 2GPU 3maximalbandwidthfat-treeoriginal bandwidthtreeStep12345613emptyempty21431332211443433221145443722165548772LoadLoadDeleteDelete#Computing ChunkDelete DataLoad Data#Receiving ChunkTransfervertex(cid:96)+1 = Max-pooling GCN(vertex(cid:96))

pool , b(cid:96)]

params p = [W (cid:96), W (cid:96)
// Passing data over edges
edge(cid:96) = Scatter(vertex(cid:96));
// NN computation using source data
acc = ApplyEdge(edge(cid:96),p){
p.W (cid:96)

pool ⊗ edge(cid:96).src + p.b(cid:96)(cid:17)

return σ

(cid:16)

set Gather.accumulator = max
accum = Gather(acc)
// compute new vertex data
vertex(cid:96)+1 = ApplyVertex(vertex(cid:96), accum, p)

return ReLU (cid:0)p.W (cid:96) ⊗ accum(cid:1)

return vertex(cid:96)+1

Figure 11: Max-Pooling GCN (MP-GCN)

vertex(cid:96)+1 = GG-NN(vertex(cid:96))

//different for each edge type
params p, A
edge(cid:96) = Scatter(vertex(cid:96));
// edge.data refers to edge type
acc = ApplyEdge(edge(cid:96), A){

return A(edge(cid:96).data) ⊗ edge(cid:96).src

set Gather.accumulator = sum
accum = Gather(acc)
// compute new vertex data using GRU
vertex(cid:96)+1=ApplyVertex(vertex(cid:96), accum, p)

return GRU(vertex(cid:96), accum)

return vertex(cid:96)+1

Figure 12: Gated Graph Neural Network (GG-NN)

edge graph. In GCN, there is computation (without neu-
ral networks) on the edge for weighted neighbor acti-
vation. In the GCN program (see Figure 10), the Scatter
operation feeds vertex features into the ApplyEdge func-
tion, which multiplies it by the static edge weight deter-
mined by the vertex degree. The Gather stage returns
the weighted sum of activations of neighbors on which
the ApplyVertex stage applies a fully-connected layer.
Max-pooling GCN (MP-GCN) [13] applies the max-
pooling operator to each of the computed features, which
can effectively capture different aspects of the neigh-
borhood set. In MP-GCN, there is an NN-based com-
putation on the edge with the max aggregation instead
of mean.
In its program (see Figure 11), the Scatter
stage passes the source vertex feature vector into fully-
connected neural network deﬁned in ApplyEdge func-
tion. Then the Gather stage returns the element-wise
max of features of neighbors on which the ApplyVertex
stage applies a fully-connected layer.
Gated GCN (G-GCN) [4, 29] is our running example
which incorporates the gate mechanism into GCN, so
that the model can learn which edges are more impor-
tant for the learning target. Its computation pattern dif-
fers from that of Max-pooling GCN in that the NN-based

9

computation on edges requires the feature vectors of both
source and destination vertices. The Scatter stage must
propagate the feature data of both vertices on the edge
(see Figure 2).
Gated graph neural networks (GG-NN) [25] applies
recurrent neural networks (RNNs) for walks on a graph
structure and unroll the recurrence for a ﬁxed number of
steps. This model was used for NLP tasks and also in
quantum chemistry for fast organic molecule properties
estimation. GG-NN has NN-based edge computation,
but using different parameters for different edge labels
(the model assumes discrete edge types). Also, GG-NN
has dense computation on vertices where the ApplyVer-
tex function is Gated Recurrent Unit (GRU). In the GG-
NN program (see Figure 12), different edges can share
different parameters in the ApplyEdge function.

6 Evaluation

We implement NGra on top of TensorFlow (v1.7) with
about 2,900 lines of C++ code and 3,000 lines of Python
code. NGra extends TensorFlow with a front-end to
transform SAGA-NN programs into a chunk-granularity
dataﬂow graph, several (fused) scatter/gather operators
for efﬁcient graph propagation, and a ring-based stream-
ing scheduling scheme.

In this section, we present the detailed evaluation re-
sults and demonstrate the efﬁciency and scalability of
NGra, as well as comparing with a state-of-the-art sys-
tem, TensorFlow.
Experimental setup. We evaluate NGra on a multi-
GPU server, which is equipped with dual 2.6 GHz Intel
Xeon E5-2690v4 processors (28 cores in total), 512 GB
of memory, and 8 NVIDIA Tesla P100 GPU. The in-
stalled operating system is Ubuntu 16.04, using libraries
CUDA 8.0, and cuDNN 6.

Table 1 lists the datasets that we used for evaluation,
which are Pubmed citation network [36], protein-protein
interaction graphs [18], BlogCatalog social network [24],
Reddit online discussion forum [13], and Wikidata [30],
respectively. The column feature in Table 1 represents
the size of vertex feature vector, and the label column
means the number of label classes. We test the perfor-
mance of our system on the task of vertex classiﬁcation,
e.g., classifying academic papers into different subjects
in the Pubmed citation dataset, which contains sparse
bag-of-words feature vectors for each document and a
list of citation links between documents.

Our evaluation uses 5 popular GNN applications intro-
duced in Section 5. Note that only CommNet, GCN and
GG-NN can be directly supported using the Tensorﬂow
operators due to no or simple computation on the edge,
in which cases the propagation can be treated as a sparse

Dataset
pubmed
protein
BlogCatalog
reddit small
reddit middle
reddit full
enwiki

vertex#
19.7K
43.5K
10.3K
46.6K
233.0K

edge#
108.4K
205.6K
668.0K
1.4M
23.2M
2.2M 571.0M
3.2M 222.1M

feature
500
29
128
602
602
300
300

label
3
3
39
41
41
50
12

Table 1: Datasets (K: thousand, M: million).

dataset

pubmed
NG TF NG TF NG TF NG

protein

blog

reddit-small

TF

GCN
8.4 32.5
8.2 13.6 14.8 20.7
CommNet 14.2 18.6 27.4 33.5 10.6 35.8
GG-NN

44.2 113.3
62.4 132.4
37.6 41.9 77.7 83.7 23.6 49.4 127.3 195.3

Table 2: Iteration time (ms) comparison with Tensor-
Flow.

Figure 13: Propagation kernel time of TensorFlow(TF),
cuSPARSE, and NGra(NG) on graphs with different den-
sity.

multiplication. We set the number of layers (cid:96) = 2 in each
GNN. All performance numbers in our experiments are
calculated by averaging over 10 epochs.

6.1 Efﬁcient Graph Propagation

NGra’s efﬁcient Scatter and Gatter kernels play an im-
port role in handling sparsity of graph propagation.
Micro-benchmark on Synthetic Data.
To evalu-
ate performance of our propagation kernels, we com-
pare NGra with TensorFlow and cuSPARSE [1] on
a simple sparse-dense matrix multiplication workload,
which can be implemented with SAGA model through
just specifying ApplyEdge phase as a multiplication
with edge feature. For TensorFlow, we directly use its
sparse tensor dense matmul operator. The in-
puts of the computation are a [10, 000 × 10, 000] sparse
matrix with variant graph densities (i.e., the percent-
age of non-zero values) from 0.01% to 10%, and a
[10, 000 × 128] dense matrix. The performance results
are shown in Figure 13. Compare to TensorFlow, our
propagation kernels can speed up by 1.5× to 10×. Even
compared to cuSPARSE, NGra can improve the perfor-
mance by 1.6× to 6.3×. The huge performance gaps are
mainly due to our careful kernel optimization and special
GPU threading model design for GNN scenarios, where
the vertex data is often a feature vector.

10

Figure 14: Streaming scheduling strategies comparison
on different applications. (Data: reddit middle)

Real Applications on Small Data. To compare with
TensorFlow on real applications, we need to ﬁt the whole
graph data in device memory, as TensorFlow cannot sup-
port graph larger than single GPU memory. Thus, we
just use the ﬁrst 4 small datasets in Table 1 to run all the
3 applications that TensorFlow supports. Table 2 lists the
comparison results. Overall, NGra outperforms Tensor-
Flow by ranging from 7.7% to 2.9× among all the appli-
cations and datasets. In the 3 applications, the average
improvement of GCN (1.4×), is more than others, main-
ly because GCN’s graph propagation takes more com-
putation cycles than others. The improvements are al-
so relative to datasets. For example, the density of the
blog graph is greater, which leads to higher graph prop-
agation overhead, where NGra can speed up. The aver-
age improvement of all applications on the blog dataset
is 2.1×, while this numbers for the reset datasets are
35.7%, 23.4%, and 1.1× respectively.

6.2 Scaling-up on a Single GPU

NGra uses the chunk-based streaming mechanism to sup-
port graphs that do not ﬁt in GPU memory. We ﬁrst eval-
uate different scheduling strategies in this mechanism,
as introduced in Section 3, and then demonstrate NGra’s
performance on real applications through comparisons
with NGra’s baseline versions.
Streaming Scheduling Strategy. The scheduling strat-
egy of a chunk-based dataﬂow graph heavily affects the
overall performance, as it determines the number of data

 1 10 100 1000 10000 0.01 0.1 1 10Propagation Time (μs)Graph Density (%)TFcuSPARSENG 0 0.5 1 1.5 2GCNMP-GCNCommNetG-GCNGG-NNRuntime (s)Dest-order Sched.Stage-based Sched.NGra Sched.Figure 15: Scaling up performance of NGra on different applications.

Figure 16: Speed up of NGra with different applications on large graphs.

swapping introduced in Section 3.1. We demonstrate the
beneﬁt of our strategy through comparing with two al-
ternatives: stage-based and dest-order scheduling strate-
gies. In the stage-based strategy, the Scatter, ApplyEdge,
and Gatter (S-A-G) are composed as one stage, the Ap-
plyVertex as another stage, where these two stages are
executed one-by-one. This will introduce one data swap-
ping between two stages. In the dest-order strategy, it
prefers to schedule operators in the Scatter stage along
the direction that destination vertex chunk changes. In
this case, for each source vertex chunk, the accum data
needs to be swapped in and out once. Figure 14 shows
the comparison results for 5 applications on the red-
dit middle dataset. Compared to the stage-based strate-
gy, NGra’s scheduling outperforms by 24.9% to 35.1%
for different applications. For the dest-order strategy,
NGra improves the performance by 60.1% to 93.1%.
These results demonstrate the beneﬁts of avoiding data-
swapping and the importance of NGra’s scheduling.

Beneﬁt of Streaming on Real Applications. To eval-
uate the performance gain of streaming in NGra, we im-
plement a baseline version of NGra by disabling stream-
ing and the optimized graph propagation, denoted as NG-
base. In this case, NG-base can still handle large graph
by partitioning it into chunks and processing them se-
quentially. We also implement another version through
using only chunk-based streaming in NGra, denoted as
NG-stream, which can achieve overlapping of data trans-
mission and computation. We compare end-to-end per-
formance of NG-base, NG-stream, and NGra (NG) on 3
applications in Figure 15. We construct the datasets with
different scales by simply duplicating the reddit small
dataset by 1, 4, 9, and 16 copies. Compared to NG-base,
NG-stream improves the performance by 33.2%, 29.3%,
and 23.0%, respectively, for the 3 applications. By fur-
ther using optimized graph propagation, NGra is able to
speed up the performance of these applications by 2.5×,
2.4×, and 1.9× than NG-base, respectively.

11

 0 1 2 1 4 9 16Runtime (s)Chunk#(a) GCNNG-BaseNG-StreamNG 0 1 2 1 4 9 16Runtime (s)Chunk#(b) CommNetNG-BaseNG-StreamNG 0 1 2 1 4 9 16Runtime (s)Chunk#(c) GG-NNNG-BaseNG-StreamNG1248 1 2 4 8Speed upGPU#GCN enwikiring-basednon-ring1248 1 2 4 8Speed upGPU#GCN redfulring-basednon-ring 1 2 4 8GPU#GG-NN enwikiring-basednon-ring 1 2 4 8GPU#GG-NN redfulring-basednon-ring 1 2 4 8GPU#CommNet enwikiring-basednon-ring 1 2 4 8GPU#CommNet redfulring-basednon-ring 1 2 4 8GPU#G-GCN enwikiring-basednon-ring 1 2 4 8GPU#G-GCN redfulring-basednon-ring 1 2 4 8GPU#MP-GCN enwikiring-basednon-ring 1 2 4 8GPU#MP-GCN redfulring-basednon-ring6.3 Scaling-out on Multiple GPUs

work concentrate on computations conducted on CPU.

NGra enables scaling GNN computation to multiple
GPUs with ring-based parallel streaming. We compare
this mechanism with a baseline without the ring-based
strategy, denoted as non-ring. Figure 16 shows the com-
parison results for 5 applications on two large datasets,
enwiki and reddit full, respectively. Please note that ring-
base mechanism only works on multi-GPU, so 1 GPU
data point is the same. The results show clearly the
beneﬁts of ring-based streaming mechanism. For ex-
ample, when scaling the computation from 1 GPU to 2
GPUs, the average speed up of non-ring mechanism is
only 1.06×, while our ring-based one can reach 1.93×.
This is mainly because, without ring-based design, each
of the two GPUs needs to load input data through shared
PCIe links concurrently, which easily becomes the bot-
tleneck of the system. The ring-based mechanism allows
near-linear speed-up because the second GPU can direct-
ly load data from the ﬁrst one, avoiding pressure on the
shared upper PCIe links.

From Figure 16, we also observe near-linear scala-
bility for our Ring-based mechanism before across NU-
MA nodes. As the current TensorFlow implementation
can hardly support NUMA-aware tensor allocation well,
reading data cross NUMA nodes become suboptimal.
Our further experiments show that we can get 7.09×
speed-up on average if we manually enable NUMA-
aware tensor allocation. Generally, Ring-based mecha-
nism in NGra can improve performance by about 2× on
average when using multiple GPUs.

7 Related Work

Many real world data can be organized as graph-
structured, e.g., web graph, social network, and knowl-
edge graph, etc., where tremendous valuable information
can be extracted. A large number of graph processing
systems have been proposed and developed to analyze
those data through iterative propagation-based computa-
tion. Pregel [28] ﬁrst proposes the vertex-program mod-
el. It is extended by subsequent work like GraphLab [26]
and PowerGraph [11] which proposes GAS model to ex-
ploit more parallelism on edge-related operations. The
GAS model is also well adopted and further extend-
ed by a bunch of following work which conduct op-
timizations on different aspects including graph lay-
out, sequential data access, and secondary storage (e.g.,
GraphChi [23], Grace [33], XStream [35], Chaos [34],
and FlashGraph [45]), distributed shared memory and
RDMA (e.g., Grappa [31] and GraM [40]), NUMA-
awareness, scheduling, and load balancing (e.g., Ga-
lois [32], Mizan [19], and Polymer [44]), and graph par-
titioning (e.g., PowerLyra [6] and BiGraph [7]). All these

There are another series of graph system work that fo-
cus on exploiting computation power of GPU for graph
processing. Medusa [46] provides simple programming
abstractions for GPU-based graph processing and auto-
matically conducts parallel execution on multiple GPUs.
CuSha [20] mainly focuses on exploring new graph rep-
resentations to allow faster graph processing. They both
cannot process graphs exceeding the GPU memory ca-
pacity. Totem [10] statically partitions the graph in-
to GPU and host memory to balance their computa-
tion loads, which may not be achievable, especially for
large graphs, since the ratios of memory and computation
power between GPU and CPU are not aligned. GraphRe-
duce [37] can process out-of-memory graphs on a sin-
gle GPU. It optimizes memory coalescing through using
two different formats, the beneﬁt of which can be easily
cancelled by the redundant data transfers. GTS [21] can
also process out-of-memory graphs on multiple GPUs.
It does not have mechanisms to avoid redundant vertex
data load from host to device memory for multi-GPU
case. Garaph [27] exploits edge-centric parallelism and
dynamic scheduling to achieve the best performance on
the CPU/GPU hybrid platform. Lux [17] investigates
the placement of graph data over memory hierarchy of
CPUs in multiple nodes. Graphie [14] proposes methods
to address the challenges when the set of active vertices
can change throughout the execution. All these above
systems only focus on supporting traditional graph algo-
rithms like PageRank, connected component, and short-
est path, etc.

TuX2 [41] pioneers the effort on studying the gap be-
tween graph and traditional machine learning computa-
tion, while NGra moves further to connect graph process-
ing and deep learning which can be well supported by the
dataﬂow frameworks like TensorFlow [3], PyTorch [2],
MxNet [8], and CNTK [42], etc. A similar past ef-
fort is in work of GraphX [12] which is a graph system
built over a general dataﬂow engine, SPARK [43], while
its target is to connect graph processing with batch-like
map-reduce workloads in a single workﬂow pipeline.

8 Conclusion

GNNs represent an emerging computation model that
arises naturally from the need to apply neural network
models on large graphs. Supporting efﬁcient and scal-
able parallel computation for GNN training is demanding
due to its inherent complexity. NGra is the ﬁrst to target
GNNs, with a new programming abstraction, which is
then mapped and optimized as dataﬂows to execute efﬁ-
ciently on GPUs.

12

References

[16] INTEL CORP.

[1] cuSPARSE, Retrieved

2018.
//developer.nvidia.com/cusparse.

September,

https:

[2] PyTorch, Retrieved September, 2018. http://pytorch.

org.

[3] ABADI, M., BARHAM, P., CHEN, J., CHEN, Z., DAVIS, A.,
DEAN, J., DEVIN, M., GHEMAWAT, S., IRVING, G., ISARD,
M., KUDLUR, M., LEVENBERG, J., MONGA, R., MOORE,
S., MURRAY, D. G., STEINER, B., TUCKER, P., VASUDE-
VAN, V., WARDEN, P., WICKE, M., YU, Y., AND ZHENG,
X. TensorFlow: A System for Large-Scale Machine Learning.
In 12th USENIX Symposium on Operating Systems Design and
Implementation (OSDI 16) (GA, 2016), USENIX Association,
pp. 265–283.

[4] BRESSON, X., AND LAURENT, T. Residual gated graph con-
vnets. In International Conference on Learning Representations
(ICLR) (2018).

[5] BUI, T. D., RAVI, S., AND RAMAVAJJALA, V. Neural graph
learning: Training neural networks using graphs. In Proceedings
of 11th ACM International Conference on Web Search and Data
Mining (WSDM) (2018).

[6] CHEN, R., SHI, J., CHEN, Y., AND CHEN, H. PowerLyra: Dif-
ferentiated graph computation and partitioning on skewed graphs.
In Proceedings of the Tenth European Conference on Computer
Systems (2015), EuroSys’15, ACM.

[7] CHEN, R., SHI, J., ZANG, B., AND GUAN, H. Bipartite-
oriented distributed graph partitioning for big learning. In Pro-
ceedings of 5th Asia-Paciﬁc Workshop on Systems (2014), AP-
Sys’14, ACM.

[8] CHEN, T., LI, M., LI, Y., LIN, M., WANG, N., WANG, M.,
XIAO, T., XU, B., ZHANG, C., AND ZHANG, Z. Mxnet: A
ﬂexible and efﬁcient machine learning library for heterogeneous
In NIPS Workshop on Machine Learning
distributed systems.
Systems (LearningSys) (2016).

[9] DEFFERRARD, M., BRESSON, X., AND VANDERGHEYNST, P.
Convolutional neural networks on graphs with fast localized spec-
tral ﬁltering. In Advances in Neural Information Processing Sys-
tems (2016), pp. 3844–3852.

[10] GHARAIBEH, A., BELTR ˜AO COSTA, L., SANTOS-NETO, E.,
AND RIPEANU, M. A yoke of oxen and a thousand chickens
In Proceedings of the 21st
for heavy lifting graph processing.
International Conference on Parallel Architectures and Compila-
tion Techniques (New York, NY, USA, 2012), PACT ’12, ACM,
pp. 345–354.

[11] GONZALEZ, J. E., LOW, Y., GU, H., BICKSON, D., AND
GUESTRIN, C. Powergraph: Distributed graph-parallel compu-
tation on natural graphs. In OSDI (2012), vol. 12, p. 2.

[12] GONZALEZ, J. E., XIN, R. S., DAVE, A., CRANKSHAW, D.,
FRANKLIN, M. J., AND STOICA, I. GraphX: Graph processing
In 11th USENIX Sympo-
in a distributed dataﬂow framework.
sium on Operating Systems Design and Implementation (2014),
OSDI’14, USENIX.

[13] HAMILTON, W. L., YING, R., AND LESKOVEC, J.

Inductive

representation learning on large graphs. In NIPS (2017).

[14] HAN, W., MAWHIRTER, D., WU, B., AND BULAND, M. Gra-
phie: Large-scale asynchronous graph traversals on just a gpu. In
Proceedings of the International Conference on Parallel Archi-
tectures and Compilation Techniques (2017), PACT’17.

[15] HENAFF, M., BRUNA, J., AND LECUN, Y. Deep convolu-
tional networks on graph-structured data. arXiv preprint arX-
iv:1506.05163 (2015).

2009.

An introduction to the intel quickpath
https://www.intel.com/

interconnect,
content/www/us/en/io/quickpath-technology/
quick-path-interconnect-introduction-paper.
html.

[17] JIA, Z., KWON, Y., SHIPMAN, G., MCCORMICK, P., EREZ,
M., AND AIKEN, A. A distributed multi-gpu system for fast
graph processing. Proc. VLDB Endow. 11, 3 (Nov. 2017), 297–
310.

[18] KERSTING, K., KRIEGE, N. M., MORRIS, C., MUTZEL, P.,
AND NEUMANN, M. Benchmark data sets for graph kernels,
2016.

[19] KHAYYAT, Z., AWARA, K., ALONAZI, A., JAMJOOM, H.,
WILLIAMS, D., AND KALNIS, P. Mizan: A system for dynamic
load balancing in large-scale graph processing. In Proceedings of
the 8th ACM European Conference on Computer Systems (2013),
EuroSys’13, ACM.

[20] KHORASANI, F., VORA, K., GUPTA, R., AND BHUYAN, L. N.
Cusha: Vertex-centric graph processing on gpus. In Proceedings
of the 23rd International Symposium on High-performance Par-
allel and Distributed Computing (New York, NY, USA, 2014),
HPDC ’14, ACM, pp. 239–252.

[21] KIM, M.-S., AN, K., PARK, H., SEO, H., AND KIM, J. Gts:
A fast and scalable graph processing method based on streaming
topology to gpus. In Proceedings of the 2016 International Con-
ference on Management of Data (New York, NY, USA, 2016),
SIGMOD ’16, ACM, pp. 447–461.

[22] KIPF, T. N., AND WELLING, M. Semi-supervised classiﬁcation
with graph convolutional networks. International Conference on
Learning Representations (ICLR) (2016).

[23] KYROLA, A., BLELLOCH, G., AND GUESTRIN, C. GraphChi:
Large-scale graph computation on just a PC. In Presented as part
of the 10th USENIX Symposium on Operating Systems Design
and Implementation (2012), OSDI’12, USENIX.

[24] LEI, T., AND HUAN, L. Relational learning via latent social di-
mensions. In KDD ’09: Proceedings of the 15th ACM SIGKDD
international conference on Knowledge discovery and data min-
ing (New York, NY, USA, 2009), ACM, pp. 817–826.

[25] LI, Y., TARLOW, D., BROCKSCHMIDT, M., AND ZEMEL, R.
Gated graph sequence neural networks. International Conference
on Learning Representations (ICLR) (2016).

[26] LOW, Y., BICKSON, D., GONZALEZ, J., GUESTRIN, C., KY-
ROLA, A., AND HELLERSTEIN, J. M. Distributed GraphLab:
A framework for machine learning and data mining in the cloud.
Proc. VLDB Endow. 5, 8 (Apr. 2012).

[27] MA, L., YANG, Z., CHEN, H., XUE, J., AND DAI, Y. Garaph:
Efﬁcient gpu-accelerated graph processing on a single machine
In 2017 USENIX Annual Technical
with balanced replication.
Conference (USENIX ATC 17) (Santa Clara, CA, 2017), USENIX
Association, pp. 195–207.

[28] MALEWICZ, G., AUSTERN, M. H., BIK, A. J., DEHNERT,
J. C., HORN, I., LEISER, N., AND CZAJKOWSKI, G. Pregel:
A system for large-scale graph processing. In Proceedings of the
2010 ACM SIGMOD International Conference on Management
of Data (2010), SIGMOD’10, ACM.

[29] MARCHEGGIANI, D., AND TITOV, I. Encoding sentences with
graph convolutional networks for semantic role labeling. In Pro-
ceedings of the 2017 Conference on Empirical Methods in Natu-
ral Language Processing (2017), Association for Computational
Linguistics, pp. 1506–1515.

[30] META. Data dumps — meta, discussion about wikimedia

projects, 2018. [Online; accessed 3-May-2018].

13

[45] ZHENG, D., MHEMBERE, D., BURNS, R., VOGELSTEIN, J.,
PRIEBE, C. E., AND SZALAY, A. S. FlashGraph: Processing
In 13th
billion-node graphs on an array of commodity SSDs.
USENIX Conference on File and Storage Technologies (2015),
FAST’15, USENIX.

[46] ZHONG, J., AND HE, B. Medusa: A parallel graph processing
system on graphics processors. SIGMOD Rec. 43, 2 (Dec. 2014),
35–40.

[31] NELSON, J., HOLT, B., MYERS, B., BRIGGS, P., CEZE, L.,
KAHAN, S., AND OSKIN, M. Latency-tolerant software dis-
tributed shared memory. In 2015 USENIX Annual Technical Con-
ference (2015), USENIX ATC’15, USENIX.

[32] NGUYEN, D., LENHARTH, A., AND PINGALI, K. A lightweight
infrastructure for graph analytics. In Proceedings of the Twenty-
Fourth ACM Symposium on Operating Systems Principles (2013),
SOSP’13, ACM.

[33] PRABHAKARAN, V., WU, M., WENG, X., MCSHERRY, F.,
ZHOU, L., AND HARADASAN, M. Managing large graphs on
multi-cores with graph awareness. In 2012 USENIX Annual Tech-
nical Conference (2012), USENIX ATC’12, USENIX.

[34] ROY, A., BINDSCHAEDLER, L., MALICEVIC,

J., AND
ZWAENEPOEL, W. Chaos: Scale-out graph processing from sec-
ondary storage. In Proceedings of the 25th Symposium on Oper-
ating Systems Principles (2015), SOSP’15, ACM.

[35] ROY, A., MIHAILOVIC, I., AND ZWAENEPOEL, W. X-Stream:
Edge-centric graph processing using streaming partitions. In Pro-
ceedings of the Twenty-Fourth ACM Symposium on Operating
Systems Principles (2013), SOSP’13, ACM.

[36] SEN, P., NAMATA, G., BILGIC, M., GETOOR, L., GALLIGHER,
B., AND ELIASSI-RAD, T. Collective classiﬁcation in network
data. AI magazine 20, 1 (2008), 61–80.

[37] SENGUPTA, D., SONG, S. L., AGARWAL, K., AND SCHWAN,
K. Graphreduce: Processing large-scale graphs on accelerator-
In Proceedings of the International Confer-
based systems.
ence for High Performance Computing, Networking, Storage and
Analysis (New York, NY, USA, 2015), SC ’15, ACM, pp. 28:1–
28:12.

[38] SUKHBAATAR, S., SZLAM, A., AND FERGUS, R. Learning
multiagent communication with backpropagation. In Advances in
Neural Information Processing Systems (NIPS) (2016), pp. 2244–
2252,.

[39] WIKIPEDIA. PCI Express, 2018. https://en.wikipedia.

org/wiki/PCI_Express.

[40] WU, M., YANG, F., XUE, J., XIAO, W., MIAO, Y., WEI, L.,
LIN, H., DAI, Y., AND ZHOU, L. GraM: Scaling graph computa-
tion to the trillions. In Proceedings of the Sixth ACM Symposium
on Cloud Computing (2015), SoCC’15, ACM.

[41] XIAO, W., XUE, J., MIAO, Y., LI, Z., CHEN, C., WU, M.,
LI, W., AND ZHOU, L. TuX2: Distributed Graph Computa-
tion for Machine Learning. In 14th USENIX Symposium on Net-
worked Systems Design and Implementation (NSDI 17) (Boston,
MA, 2017), USENIX Association, pp. 669–682.

[42] YU, D., EVERSOLE, A., SELTZER, M., YAO, K., KUCHAIEV,
O., ZHANG, Y., SEIDE, F., HUANG, Z., GUENTER, B., WANG,
H., DROPPO, J., ZWEIG, G., ROSSBACH, C., GAO, J., STOL-
CKE, A., CURREY, J., SLANEY, M., CHEN, G., AGARWAL,
A., BASOGLU, C., PADMILAC, M., KAMENEV, A., IVANOV,
V., CYPHER, S., PARTHASARATHI, H., MITRA, B., PENG, B.,
AND HUANG, X. An introduction to computational networks and
the computational network toolkit. Tech. rep., October 2014.

[43] ZAHARIA, M., CHOWDHURY, M., DAS, T., DAVE, A., MA,
J., MCCAULEY, M., FRANKLIN, M. J., SHENKER, S., AND
STOICA, I. Resilient distributed datasets: A fault-tolerant ab-
straction for in-memory cluster computing. In Proceedings of the
9th USENIX Conference on Networked Systems Design and Im-
plementation (2012), NSDI’12, USENIX.

[44] ZHANG, K., CHEN, R., AND CHEN, H. NUMA-aware graph-
structured analytics. In Proceedings of the 20th ACM SIGPLAN
Symposium on Principles and Practice of Parallel Programming
(2015), PPoPP’15, ACM.

14

