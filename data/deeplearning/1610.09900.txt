7
1
0
2

r
a

M
2

]
I

A
.
s
c
[

2
v
0
0
9
9
0
.
0
1
6
1
:
v
i
X
r
a

Inference Compilation and Universal Probabilistic Programming

Tuan Anh Le

Atılım Güneş Baydin
Department of Engineering Science, University of Oxford
{tuananh, gunes, fwood}@robots.ox.ac.uk

Frank Wood

Abstract

We introduce a method for using deep neu-
ral networks to amortize the cost of inference
in models from the family induced by uni-
versal probabilistic programming languages,
establishing a framework that combines the
strengths of probabilistic programming and
deep learning methods. We call what we do
“compilation of inference” because our method
transforms a denotational speciﬁcation of an
inference problem in the form of a probabilis-
tic program written in a universal program-
ming language into a trained neural network
denoted in a neural network speciﬁcation lan-
guage. When at test time this neural network
is fed observational data and executed, it per-
forms approximate inference in the original
model speciﬁed by the probabilistic program.
Our training objective and learning procedure
are designed to allow the trained neural net-
work to be used as a proposal distribution in
a sequential importance sampling inference
engine. We illustrate our method on mixture
models and Captcha solving and show signiﬁ-
cant speedups in the eﬃciency of inference.

Figure 1: Our approach to compiled inference. Given
only a probabilistic program p(x, y), during compi-
lation we automatically construct a neural network
architecture comprising an LSTM core and various
embedding and proposal layers speciﬁed by the proba-
bilistic program and train this using an inﬁnite stream
of training data {x(m), y(m)} generated from the model.
When this expensive compilation stage is complete, we
are left with an artifact of weights φ and neural archi-
tecture specialized for the given probabilistic program.
During inference, the probabilistic program and the
compilation artifact is used in a sequential importance
sampling procedure, where the artifact parameterizes
the proposal distribution q(x|y; φ).

1 INTRODUCTION

Probabilistic programming uses computer programs to
represent probabilistic models (Gordon et al., 2014).
Probabilistic programming systems such as STAN (Car-
penter et al., 2015), BUGS (Lunn et al., 2000), and
Infer.NET (Minka et al., 2014) allow eﬃcient inference
in a restricted space of generative models, while sys-
tems such as Church (Goodman et al., 2008), Venture
(Mansinghka et al., 2014), and Anglican (Wood et al.,
2014)—which we call universal—allow inference in un-
restricted models. Universal probabilistic programming

Appearing in Proceedings of the 20th International Con-
ference on Artiﬁcial Intelligence and Statistics (AISTATS)
2017, Fort Lauderdale, Flordia, USA. JMLR: W&CP vol-
ume 54. Copyright 2017 by the authors.

systems are built upon Turing complete programming
languages which support constructs such as higher or-
der functions, stochastic recursion, and control ﬂow.

There has been a spate of recent work addressing
the production of artifacts via “compiling away” or
“amortizing” inference (Gershman and Goodman, 2014).
This body of work is roughly organized into two camps.
The one in which this work lives, arguably the camp
organized around “wake-sleep” (Hinton et al., 1995),
is about oﬄine unsupervised learning of observation-
parameterized importance-sampling distributions for
Monte Carlo inference algorithms. In this camp, the
approach of Paige and Wood (2016) is closest to ours
in spirit; they propose learning autoregressive neural
density estimation networks oﬄine that approximate
inverse factorizations of graphical models so that at

CompilationProbabilisticprogramp(cid:16)(cid:1);y)InferenceTrainingdata(cid:1)(cid:1)(cid:1)(cid:1));y(cid:1)(cid:1))gTestdatayPosteriorp(cid:16)(cid:1)jy)Training(cid:3)Expensive/slowCheap/fastSISNNarchitectureCompilationartifactq(cid:16)(cid:1)jy;(cid:3))DKL(cid:16)p(cid:16)(cid:1)jy)jjq(cid:16)(cid:1)jy;(cid:3))) 
 
 
 
 
 
Inference Compilation and Universal Probabilistic Programming

test time, the trained “inference network” starts with
the values of all observed quantities and progressively
proposes parameters for latent nodes in the original
structured model. However, inversion of the depen-
dency structure is impossible in the universal proba-
bilistic program model family, so our approach instead
focuses on learning proposals for “forward” inference
methods in which no model dependency inversion is
performed. In this sense, our work can be seen as being
inspired by that of Kulkarni et al. (2015) and Ritchie
et al. (2016b) where program-speciﬁc neural proposal
networks are trained to guide forward inference. Our
aim, though, is to be signiﬁcantly less model-speciﬁc.
At a high level what characterizes this camp is the fact
that the artifacts are trained to suggest sensible yet
varied parameters for a given, explicitly structured and
therefore potentially interpretable model.

The other related camp, emerging around the varia-
tional autoencoder (Kingma and Welling, 2014; Burda
et al., 2016), also amortizes inference in the manner we
describe, but additionally also simultaneously learns
the generative model, within the structural regulariza-
tion framework of a parameterized non-linear trans-
formation of the latent variables. Approaches in this
camp generally produce recognition networks that non-
linearly transform observational data at test time into
parameters of a variational posterior approximation,
albeit one with less conditional structure, excepting the
recent work of Johnson et al. (2016). A chief advantage
of this approach is that the learned model, as opposed
to the recognition network, is simultaneously regular-
ized both towards being simple to perform inference in
and towards explaining the data well.

In this work, we concern ourselves with performing
inference in generative models speciﬁed as probabilistic
programs while recognizing that alternative methods ex-
ist for amortizing inference while simultaneously learn-
ing model structure. Our contributions are twofold:
(1) We work out ways to handle the complexities intro-
duced when compiling inference for the class of genera-
tive models induced by universal probabilistic program-
ming languages and establish a technique to embed
neural networks in forward probabilistic programming
inference methods such as sequential importance sam-
pling (Doucet and Johansen, 2009). (2) We develop
an adaptive neural network architecture, comprising
a recurrent neural network core and embedding and
proposal layers speciﬁed by the probabilistic program,
that is reconﬁgured on-the-ﬂy for each execution trace
and trained with an inﬁnite stream of training data
sampled from the generative model. This establishes a
framework combining deep neural networks and gener-
ative modeling with universal probabilistic programs
(Figure 1).

We begin by providing background information and
reviewing related work in Section 2. In Section 3 we

introduce inference compilation for sequential impor-
tance sampling, the objective function, and the neural
network architecture. Section 4 demonstrates our ap-
proach on two examples, mixture models and Captcha
solving, followed by the discussion in Section 5.

2 BACKGROUND

2.1 Probabilistic Programming

Probabilistic programs denote probabilistic generative
models as programs that include sample and observe
statements (Gordon et al., 2014). Both sample and
observe are functions that specify random variables
in this generative model using probability distribu-
tion objects as an argument, while observe, in addi-
tion, speciﬁes the conditioning of this random variable
upon a particular observed value in a second argument.
These observed values induce a conditional probability
distribution over the execution traces whose approxi-
mations and expected values we want to characterize
by performing inference.

An execution trace of a probabilistic program is ob-
tained by successively executing the program determin-
istically, except when encountering sample statements
at which point a value is generated according to the
speciﬁed probability distribution and appended to the
execution trace. We assume the order in which the
observe statements are encountered is ﬁxed. Hence
we denote the observed values by y := (yn)N
n=1 for a
ﬁxed N in all possible traces.

Depending on the probabilistic program and the values
generated at sample statements, the order in which
the execution encounters sample statements as well
as the number of encountered sample statements may
be diﬀerent from one trace to another. Therefore,
given a scheme which assigns a unique address to each
sample statement according to its lexical position in
the probabilistic program, we represent an execution
trace of a probabilistic program as a sequence

(xt, at, it)T

t=1 ,

(1)

where xt, at, and it are respectively the sample value,
address, and instance (call number) of the tth entry
in a given trace, and T is a trace-dependent length.
Instance values it = Pt
1(at = aj) count the number
of sample values obtained from the speciﬁc sample
statement at address at, up to time step t. For each
trace, a sequence x := (xt)T
t=1 holds the T sampled
values from the sample statements.

j=1

The joint probability density of an execution trace is

p(x, y) :=

T
Y

t=1

fat (xt|x1:t−1)

N
Y

n=1

gn(yn|x1:τ (n)) ,

(2)

Tuan Anh Le, Atılım Güneş Baydin, Frank Wood

Figure 2: Results from counting and localizing objects detected in the PASCAL VOC 2007 dataset (Everingham
et al., 2010). We use the corresponding categories of object detectors (i.e., person, cat, bicycle) from the
MatConvNet (Vedaldi and Lenc, 2015) implementation of the Fast R-CNN (Girshick, 2015). The detector output
is processed by using a high detection threshold and summarized by representing the bounding box detector
output by a single central point. Inference using a single trained neural network was able to accurately identify
both the number of detected objects and their locations for all categories. MAP results from 100 particles.

where fat is the probability distribution speciﬁed by the
sample statement at address at and gn is the probabil-
ity distribution speciﬁed by the nth observe statement.
fat(·|x1:t−1) is called the prior conditional density given
the sample values x1:t−1 obtained before encountering
the tth sample statement. gn(·|x1:τ (n)) is called the
likelihood density given the sample values x1:τ (n) ob-
tained before encountering the nth observe statement,
where τ is a mapping from the index n of the observe
statement to the index of the last sample statement
encountered before this observe statement during the
execution of the program.

Inference in such models amounts to computing an
approximation of p(x|y) and its expected values Iζ =
R ζ(x)p(x|y) dx over chosen functions ζ.

While there are many inference algorithms for universal
probabilistic programming languages (Wingate et al.,
2011; Ritchie et al., 2016a; Wood et al., 2014; Paige
et al., 2014; Rainforth et al., 2016), we focus on al-
gorithms in the importance sampling family in the
context of which we will develop our scheme for amor-
tized inference. This is related, but diﬀerent to the
approaches that adapt proposal distributions for the
importance sampling family of algorithms (Gu et al.,
2015; Cheng and Druzdzel, 2000).

2.2 Sequential Importance Sampling

Sequential importance sampling (SIS) (Arulampalam
et al., 2002; Doucet and Johansen, 2009) is a method for
performing inference over execution traces of a proba-
bilistic program (Wood et al., 2014) whereby a weighted
set of samples {(wk, xk)}K
k=1 is used to approximate
the posterior and the expectations of functions as

ˆp(x|y) =

ˆIζ =

K
X

k=1

K
X

k=1

wkδ(xk − x)/

K
X

j=1

wj

wkζ(xk)/

K
X

j=1

wj,

(3)

(4)

where δ is the Dirac delta function.

SIS requires designing proposal distributions qa,i corre-
sponding to the addresses a of all sample statements
in the probabilistic program and their instance values i.
A proposal execution trace xk
1:T k is built by executing
the program as usual, except when a sample statement
at address at is encountered at time t, a proposal sam-
ple value xk
t is sampled from the proposal distribution
qat,it(·|xk
1:t−1) given the proposal sample values until
that point. We obtain K proposal execution traces
xk := xk
1:T k (possibly in parallel) to which we assign
weights

wk =

N
Y

n=1

gn(yn|xk

1:τk(n)) ·

T k
Y

t=1

fat(xk
qat,it(xk

t |xk
t |xk

1:t−1)
1:t−1)

(5)

for k = 1, . . . , K with T k denoting the length of the
kth proposal execution trace.

3 APPROACH

We achieve inference compilation in universal proba-
bilistic programming systems through proposal distri-
bution adaptation, approximating p(x|y) in the frame-
work of SIS. Assuming we have a set of adapted pro-
posals qat,it (xt|x1:t−1, y) such that their joint q(x|y)
is close to p(x|y), the resulting inference algorithm
remains unchanged from the one described in Sec-
tion 2.2, except the replacement of qat,it(xt|x1:t−1) by
qat,it(xt|x1:t−1, y).

Inference compilation amounts to minimizing a func-
tion, speciﬁcally the loss of a neural network architec-
ture, which makes the proposal distributions good in
the sense that we specify in Section 3.1. The process of
generating training data for this neural network archi-
tecture from the generative model is described in Sec-
tion 3.2. At the end of training, we obtain a compilation
artifact comprising the neural network components—
the recurrent neural network core and the embedding
and proposal layers corresponding to the original model

Inference Compilation and Universal Probabilistic Programming

denoted by the probabilistic program—and the set of
trained weights, as described in Section 3.3.

Eq. 1. Speciﬁcally, we generate our training data in
the form of minibatches (Cotter et al., 2011) sampled
from the generative model p(x, y):

3.1 Objective Function

the

use

Kullback–Leibler

We
divergence
DKL (p(x|y) || q(x|y; φ)) as our measure of close-
ness between p(x|y) and q(x|y; φ).
To achieve
closeness over many possible y’s, we take the expec-
tation of this quantity under the distribution of p(y)
and ignore the terms excluding φ in the last equality:

L(φ) := Ep(y) [DKL (p(x|y) || q(x|y; φ))]

(6)

Z

=

Z

p(y)

y

x

p(x|y) log

p(x|y)
q(x|y; φ)

dx dy

= Ep(x,y) [− log q(x|y; φ)] + const.

(7)

This objective function corresponds to the nega-
tive entropy criterion. Individual adapted proposals
qat,it(xt|ηt(x1:t−1, y, φ)) =: qat,it(xt|x1:t−1, y) depend
on ηt, the output of the neural network at time step t,
parameterized by φ.

Considering the factorization

q(x|y; φ) =

T
Y

t=1

qat,it(xt|ηt(x1:t−1, y, φ)) ,

(8)

the neural network architecture must be able to map to
a variable number of outputs, and incorporate sampled
values in a sequential manner, concurrent with the
running of the inference engine. We describe our neural
network architecture in detail in Section 3.3.

3.2 Training Data

Since Eq. 7 is an expectation over the joint distribution,
we can use the following noisy unbiased estimate of its
gradient to minimize the objective:

∂
∂φ

L(φ) ≈

1
M

M
X

m=1

(cid:16)

∂
∂φ

− log q(x(m)|y(m); φ)

(cid:17)

(9)

(x(m), y(m)) ∼ p(x, y), m = 1, . . . , M .

(10)

Here, (x(m), y(m)) is the mth training (probabilistic
program execution) trace generated by running an un-
constrained probabilistic program corresponding to the
original one. This unconstrained probabilistic program
is obtained by a program transformation which re-
places each observe statement in the original program
by sample and ignores its second argument.

Universal probabilistic programming languages support
stochastic branching and can generate execution traces
with a changing (and possibly unbounded) number of
random choices. We must, therefore, keep track of
information about the addresses and instances of the
samples x(m)
in the execution trace, as introduced in

t

(cid:26)(cid:16)

Dtrain =

x(m)
t

, a(m)
t

, i(m)
t

(cid:17)T (m)

t=1

(cid:16)

,

y(m)
n

(cid:17)N

(cid:27)M

n=1

,

m=1

(11)

where M is the minibatch size, and, for a given trace
m, the sample values, addresses, and instances are re-
spectively denoted x(m)
, a(m)
, and the values
t
sampled from the distributions in observe statements
are denoted y(m)
n .

, and i(m)

t

t

During compilation, training minibatches are gener-
ated on-the-ﬂy from the probabilistic generative model
and streamed to a stochastic gradient descent (SGD)
procedure, speciﬁcally Adam (Kingma and Ba, 2015),
for optimizing the neural network weights φ.

Minibatches of this inﬁnite stream of training data are
discarded after each SGD update; we therefore have no
notion of a ﬁnite training set and associated issues such
as overﬁtting to a set of training data and early stopping
using a validation set (Prechelt, 1998). We do sample
a validation set that remains ﬁxed during training to
compute validation losses for tracking the progress of
training in a less noisy way than that admitted by the
training loss.

3.3 Neural Network Architecture

Our compilation artifact is a collection of neural net-
work components and their trained weights, specialized
in performing inference in the model speciﬁed by a
given probabilistic program. The neural network ar-
chitecture comprises a non-domain-speciﬁc recurrent
neural network (RNN) core and domain-speciﬁc obser-
vation embedding and proposal layers speciﬁed by the
given program. We denote the set of the combined
parameters of all neural network components φ.

RNNs are a popular class of neural network architec-
ture which are well-suited for sequence-to-sequence
modeling (Sutskever et al., 2014) with a wide spec-
trum of state-of-the-art results in domains including
machine translation (Bahdanau et al., 2014), video
captioning (Venugopalan et al., 2014), and learning
execution traces (Reed and de Freitas, 2016). We use
RNNs in this work owing to their ability to encode
dependencies over time in the hidden state. In par-
ticular, we use the long short-term memory (LSTM)
architecture which helps mitigate the vanishing and
exploding gradient problems of RNNs (Hochreiter and
Schmidhuber, 1997).

The overall architecture (Figure 3) is formed by com-
bining the LSTM core with a domain-speciﬁc observe
embedding layer f obs, and several sample embedding

Tuan Anh Le, Atılım Güneş Baydin, Frank Wood

a,i

a,i and proposal layers f prop

layers f smp
that are distinct
for each address–instance pair (a, i). As described in
Section 3.2, each probabilistic program execution trace
can be of diﬀerent length and composed of a diﬀerent
sequence of addresses and instances. To handle this
complexity, we deﬁne an adaptive neural network ar-
chitecture that is reconﬁgured for each encountered
trace by attaching the corresponding embedding and
proposal layers to the LSTM core, creating new layers
on-the-ﬂy on the ﬁrst encounter with each (a, i) pair.

Evaluation starts by computing the observe embed-
ding f obs (y). This embedding is computed once per
trace and repeatedly supplied as an input to the LSTM
at each time step. Another alternative is to supply
this embedding only once in the ﬁrst time step, an ap-
proach preferred by Karpathy and Fei-Fei (2015) and
Vinyals et al. (2015) to prevent overﬁtting (also see
Section 4.2).

At each time step t, the input ρt of the LSTM is
constructed as a concatenation of

1. the observe embedding f obs(y),

2. the
f smp
at−1,it−1

embedding

the
(xt−1), using zero for t = 1, and

previous

of

sample

f obs:
Figure 3: The neural network architecture.
observe embedding; f smp
: sample embeddings;
at−1,it−1
xt−1: previous sample value; at, it, type(at): one-hot
encodings of current address, instance, proposal type;
ρt: LSTM input; ht: LSTM output; f prop
: proposal
at,it
layers; ηt: proposal parameters. Note that the LSTM
core can possibly be a stack of multiple LSTMs.

3. the one-hot encodings of the current address at, in-
stance it, and proposal type type(at) of the sample
statement

which is beyond the scope of this paper. The source
code for our framework and for reproducing the ex-
periments in this paper can be found on our project
page.1

for which the artifact will generate the parameter ηt of
the proposal distribution qat,it(·|ηt). The parameter ηt
is obtained via the proposal layer f prop
(ht), mapping
at,it
the LSTM output ht through the corresponding pro-
posal layer. The LSTM network has the capacity to
incorporate inputs in its hidden state. This allows the
parametric proposal qat,it(xt|ηt(x1:t−1, y, φ)) to take
into account all previous samples and all observations.

During training (compilation), we supply the ac-
tual sample values x(m)
,
at−1,it−1
in or-
and we are interested in the parameter ηt
∂
der
∂φ −
to calculate the per-sample gradient
log qa(m)

t−1 to the embedding f smp

|ηt(x1:t−1, y, φ)) to use in SGD.

(x(m)
t

,i(m)
t

t

During inference, the evaluation proceeds by requesting
proposal parameters ηt from the artifact for speciﬁc
address–instance pairs (at, it) as these are encountered.
The value xt−1 is sampled from the proposal distribu-
tion in the previous time step.

The neural network artifact is implemented in Torch
(Collobert et al., 2011), and it uses a ZeroMQ-based
protocol for interfacing with the Anglican probabilistic
programming system (Wood et al., 2014). This setup
allows distributed training (e.g., Dean et al. (2012))
and inference with GPU support across many machines,

4 EXPERIMENTS

We demonstrate our inference compilation framework
on two examples. In our ﬁrst example we demonstrate
an open-universe mixture model. In our second, we
demonstrate Captcha solving via probabilistic inference
(Mansinghka et al., 2013).2

4.1 Mixture Models

Mixture modeling, e.g. the Gaussian mixture model
(GMM) shown in Figure 5, is about density estimation,
clustering, and counting. The inference problems posed
by a GMM, given a set of vector observations, are to
identify how many, where, and how big the clusters
are, and optionally, which data points belong to each
cluster.

We investigate inference compilation for a two-
dimensional GMM in which the number of clusters
is unknown. Inference arises from observing the val-

1https://probprog.github.io/

inference-compilation/

2A video of inference on real test data for both examples

is available at: https://youtu.be/m-FYEXVyQjQ

LSTM...xt(cid:1)1atittype(cid:10)at)one-hotone-hotone-hotfobsfsmpa(cid:1)(cid:1)(cid:1)(cid:3)i(cid:1)(cid:1)(cid:1)fpropa(cid:1)(cid:3)i(cid:1)(cid:5)t(cid:5)t(cid:8)1(cid:5)t(cid:8)2htht(cid:8)1ht(cid:8)2tt(cid:8)1t(cid:8)2observes(cid:7)mpleInference Compilation and Universal Probabilistic Programming

Figure 4: Typical inference results for an isotropic Gaussian mixture model with number of clusters ﬁxed to
K = 3. Shown in all panels: kernel density estimation of the distribution over maximum a posteriori values of the
means {maxµk p(µk|y)}3
k=1 over 50 independent runs. This ﬁgure illustrates the uncertainty in the estimate of
where cluster means are for each given number of particles, or equivalently, ﬁxed amount of computation. The
top row shows that, given more computation, inference, as expected, slowly becomes less noisy in expectation. In
contrast, the bottom row shows that the proposal learned and used by inference compilation produces a low-noise,
highly accurate estimate given even a very small amount of computation. Eﬀectively, the encoder learns to
simultaneously localize all of the clusters highly accurately.

ues of yn (Figure 5, line 9) and inferring the posterior
number of clusters K and the set of cluster mean and
covariance parameters {µk, Σk}K
k=1. We assume that
the input data to this model has been translated to
the origin and normalized to lie within [−1, 1] in both
dimensions.

In order to make good proposals for such inference, the
neural network must be able to count, i.e., extract and
represent information about how many clusters there
are and, conditioned on that, to localize the clusters.
Towards that end, we select a convolutional neural
network as the observation embedding, whose input is
a two-dimensional histogram image of binned observed
data y.

In presenting observational data y assumed to arise
from a mixture model to the neural network, there are
some important considerations that must be accounted
for.
In particular, there are symmetries in mixture
models (Nishihara et al., 2013) that must be broken in
order for training and inference to work. First, there
are K! (factorial) ways to label the classes. Second,
there are N ! ways the individual data points could be
permuted. Even in experiments like ours with K < 6
and N ≈ 100, this presents a major challenge for neu-
ral network training. We break the ﬁrst symmetry by,
at training time, sorting the clusters by the Euclidian
distance of their means from the origin and relabeling
all points with a permutation that labels points from
the cluster nearest the original as coming from the ﬁrst
cluster, next closest the second, and so on. This is only
approximately symmetry breaking as many diﬀerent
clusters may be very nearly the same distance away
from the origin. Second, we avoid the N ! symmetry by
only predicting the number, means, and covariances

µk, Σk ∼ p(µk, Σk)

K ∼ p(K)
for k = 1, . . . , K do

1: procedure GaussianMixture
2:
3:
4:
5: Generate data:
6:
7:
8:
9:
10:

π ←uniform(1, K)
for n = 1, . . . , N do
zn ∼ p(zn|π)
yn ∼ p(yn|zn = k, µk, Σk)

return yn

. sample number of clusters

. sample cluster parameters

. sample class label
. sample data

Figure 5: Pseudo algorithm for generating Gaussian
mixtures of a variable number of clusters. At test time
we observe data yn and infer K, {µk, Σk}K

k=1.

of the clusters, not the individual cluster assignments.
The net eﬀect of the sorting is that the proposal mech-
anism will learn to propose the nearest cluster to the
origin as it receives training data always sorted in this
manner.

Figure 4, where we ﬁx the number of clusters to 3,
shows that we are able to learn a proposal that makes
inference dramatically more eﬃcient than sequential
Monte Carlo (SMC) (Doucet and Johansen, 2009). Fig-
ure 2 shows one kind of application such an eﬃcient
inference engine can do: simultaneous object counting
(Lempitsky and Zisserman, 2010) and localization for
computer vision, where we achieve counting by setting
the prior p(K) over number of clusters to be a uniform
distribution over {1, 2, . . . , 5}.

4.2 Captcha Solving

We also demonstrate our inference compilation frame-
work by writing generative probabilistic models for
Captchas (von Ahn et al., 2003) and comparing our re-

SMC1InferenceCompilation10100100010000Particles1: procedure Captcha
2:
ν ∼ p(ν)
3:
κ ∼ p(κ)
4: Generate letters:
5:
Λ ← {}
6:
for i = 1, . . . , ν do
7:
8:
9: Render:
10:
11:
12:
13:

γ ← render(Λ, κ)
π ∼ p(π)
γ ← noise(γ, π)
return γ

λ ∼ p(λ)
Λ ← append(Λ, λ)

Tuan Anh Le, Atılım Güneş Baydin, Frank Wood

. sample number of letters
. sample kerning value

. sample letter identity

. sample noise parameters

the list of addresses for which we learn proposal dis-
tributions improves robustness when testing with data
not sampled from the same model. This corresponds
to the well-known technique of adding synthetic varia-
tions to training data for transformation invariance, as
used by Simard et al. (2003), Varga and Bunke (2003),
Jaderberg et al. (2014), and many others.

a1 = “ν”
i1 = 1
x1 = 7

a5 = “λ”
i5 = 3
x5 = 18

a9 = “λ”
i9 = 7
x9 = 9

a2 = “κ”
i2 = 1
x2 = −1

a6 = “λ”
i6 = 4
x6 = 53

a3 = “λ”
i3 = 1
x3 = 6

a7 = “λ”
i7 = 5
x7 = 17

Noise:
displacement
ﬁeld

Noise:
stroke

a4 = “λ”
i4 = 2
x4 = 23

a8 = “λ”
i8 = 6
x8 = 43

Noise:
ellipse

Figure 6: Pseudo algorithm and a sample trace of
the Facebook Captcha generative process. Variations
include sampling font styles, coordinates for letter place-
ment, and language-model-like letter identity distribu-
tions p(λ|λ1:t−1) (e.g., for meaningful Captchas). Noise
parameters π may or may not be a part of inference.
At test time we observe image γ and infer ν, Λ.

sults with the literature. Captcha solving is well suited
for a generative probabilistic programming approach
because its latent parameterization is low-dimensional
and interpretable by design. Using conventional com-
puter vision techniques, the problem has been previ-
ously approached using segment-and-classify pipelines
(Starostenko et al., 2015; Bursztein et al., 2014; Gao
et al., 2014, 2013), and state-of-the-art results have
been obtained by using deep convolutional neural net-
works (CNNs) (Goodfellow et al., 2014; Stark et al.,
2015), at the cost of requiring very large (in the order of
millions) labeled training sets for supervised learning.

), Baidu 2013 (
), reCaptcha (

We start by writing generative models for each of
the types surveyed by Bursztein et al. (2014), namely
), eBay (
Baidu 2011 (
),
Yahoo (
), and Wikipedia
(
). Figure 6 provides an overall summary of
our modeling approach. The actual models include
domain-speciﬁc letter dictionaries, font styles, and var-
ious types of renderer noise for matching each Captcha
style. In particular, implementing the displacement
ﬁelds technique of Simard et al. (2003) proved instru-
mental in achieving our results. Note that the param-
eters of stochastic renderer noise are not inferred in
the example of Figure 6. Our experiments have shown
that we can successfully train artifacts that also extract
renderer noise parameters, but excluding these from

the

compilation artifacts we use a stack
two LSTMs of 512 hidden units each, an
six con-
layers organized as

For
of
observe-embedding CNN consisting of
volutions and two linear
[2×Convolution]-MaxPooling-[3×Convolution]-
MaxPooling-Convolution-MaxPooling-Linear-Linear,
where convolutions are 3×3 with successively 64, 64,
64, 128, 128, 128 ﬁlters, max-pooling layers are 2×2
with step size 2, and the resulting embedding vector
is of length 1024. All convolutions and linear layers
are followed by ReLU activation. Depending on the
particular style, each artifact has approximately 20M
trainable parameters. Artifacts are trained end-to-end
using Adam (Kingma and Ba, 2015) with initial
learning rate α = 0.0001, hyperparameters β1 = 0.9,
β2 = 0.999, and minibatches of size 128.

Table 1 reports inference results with test images sam-
pled from the model, where we achieve very high
recognition rates across the board. The reported re-
sults are obtained after approximately 16M training
traces. With the resulting artifacts, running infer-
ence on a test Captcha takes < 100 ms, whereas dura-
tions ranging from 500 ms (Starostenko et al., 2015) to
7.95 s (Bursztein et al., 2014) have been reported with
segment-and-classify approaches. We also compared
our approach with the one by Mansinghka et al. (2013).
Their method is slow since it must be run anew for
each Captcha, taking in the order of minutes to solve
one Captcha in our implementation of their method.
The probabilistic program must also be written in a
way amenable to Markov Chain Monte Carlo inference
such as having auxiliary indicator random variables
for rendering letters to overcome multimodality in the
posterior.

We subsequently investigated how the trained models
would perform on Captcha images collected from the
web. We identiﬁed Wikipedia and Facebook as two
major services still making use of textual Captchas,
and collected and labeled test sets of 500 images each.3
Initially obtaining low recognition rates (< 10%), with
several iterations of model modiﬁcations (involving tun-
ing of the prior distributions for font size and renderer
noise), we were able to achieve 81% and 42% recogni-
tion rates with real Wikipedia and Facebook datasets,
considerably higher than the threshold of 1% needed to

3Facebook Captchas are collected from a page for ac-
cessing groups. Wikipedia Captchas appear on the account
creation page.

Inference Compilation and Universal Probabilistic Programming

Table 1: Captcha recognition rates.

Baidu 2011 Baidu 2013

eBay

Our method
Bursztein et al. (2014)
Starostenko et al. (2015)
Gao et al. (2014)
Gao et al. (2013)
Goodfellow et al. (2014)
Stark et al. (2015)

99.8%
38.68%

34%

99.9%
55.22%

99.2%
51.39%

51%

Yahoo

98.4%
5.33%
91.5%
55%
36%

reCaptcha Wikipedia

Facebook

93.6%
28.29%

91.0%

96.4%
22.67%
54.6%
34%

99.8%
90%

deem a Captcha scheme broken (Bursztein et al., 2011).
The fact that we had to tune our priors highlights the
issues of model bias and “synthetic gap” (Zhang et al.,
2015) when training models with synthetic data and
testing with real data.4

tal challenges associated with its constituents:
fast
and scalable inference on probabilistic programs, inter-
pretability of the generative model, an inﬁnite stream
of labeled training data, and the ability to correctly
represent and handle uncertainty.

In our experiments we also investigated feeding the
observe embeddings to the LSTM at all time steps
versus only in the ﬁrst time step. We empirically veri-
ﬁed that both methods produce equivalent results, but
the latter takes signiﬁcantly (approx. 3 times) longer
to train. This is because we are training f obs end-to-
end from scratch, and the former setup results in more
frequent gradient updates for f obs per training trace.5

In summary, we only need to write a probabilistic
generative model that produces Captchas suﬃciently
similar to those that we would like to solve. Using our
inference compilation framework, we get the inference
neural network architecture, training data, and labels
for free. If you can create instances of a Captcha, you
can break it.

5 DISCUSSION

We have explored making use of deep neural networks
for amortizing the cost of inference in probabilistic
programming. In particular, we transform an inference
problem given in the form of a probabilistic program
into a trained neural network architecture that pa-
rameterizes proposal distributions during sequential
importance sampling. The amortized inference tech-
nique presented here provides a framework within which
to integrate the expressiveness of universal probabilis-
tic programming languages for generative modeling
and the processing speed of deep neural networks for
inference. This merger addresses several fundamen-

4Note that the synthetic/real boundary is not always
clear: for instance, we assume that the Captcha results in
Goodfellow et al. (2014) closely correspond to our results
with synthetic test data because the authors have access to
Google’s true generative process of reCaptcha images for
their synthetic training data. Stark et al. (2015) both train
and test their model with synthetic data.

5Both Karpathy and Fei-Fei (2015) and Vinyals et al.
(2015), who feed CNN output to an RNN only once, use
pretrained embedding layers.

Our experimental results show that, for the family
of models on which we focused, the proposed neural
network architecture can be successfully trained to ap-
proximate the parameters of the posterior distribution
in the sample space with nonlinear regression from
the observe space. There are two aspects of this ar-
chitecture that we are currently working on reﬁning.
Firstly, the structure of the neural network is not wholly
determined by the given probabilistic program: the in-
variant LSTM core maintains long-term dependencies
and acts as the glue between the embedding and pro-
posal layers that are automatically conﬁgured for the
address–instance pairs (at, it) in the program traces.
We would like to explore architectures where there is a
tight correspondence between the neural artifact and
the computational graph of the probabilistic program.
Secondly, domain-speciﬁc observe embeddings such as
the convolutional neural network that we designed for
the Captcha-solving task are hand picked from a range
of fully-connected, convolutional, and recurrent archi-
tectures and trained end-to-end together with the rest
of the architecture. Future work will explore automat-
ing the selection of potentially pretrained embeddings.

A limitation that comes with not learning the gen-
erative model itself—as is done by the models orga-
nized around the variational autoencoder (Kingma and
Welling, 2014; Burda et al., 2016)—is the possibility
of model misspeciﬁcation (Shalizi et al., 2009; Gel-
man and Shalizi, 2013). Section 3.2 explains that our
training setup is exempt from the common problem of
overﬁtting to the training set. But as demonstrated
by the fact that we needed alterations in our Captcha
model priors for handling real data, we do have a risk of
overﬁtting to the model. Therefore we need to ensure
that our generative model is ideally as close as possi-
ble to the true data generation process and remember
that misspeciﬁcation in terms of broadness is prefer-
able to a misspeciﬁcation where we have a narrow, but
uncalibrated, model.

Tuan Anh Le, Atılım Güneş Baydin, Frank Wood

Acknowledgements

We would like to thank Hakan Bilen for his help with
the MatConvNet setup and showing us how to use his
Fast R-CNN implementation and Tom Rainforth for his
helpful advice. Tuan Anh Le is supported by EPSRC
DTA and Google (project code DF6700) studentships.
Atılım Güneş Baydin and Frank Wood are supported
under DARPA PPAML through the U.S. AFRL under
Cooperative Agreement FA8750-14-2-0006, Sub Award
number 61160290-111668.

References
M. S. Arulampalam, S. Maskell, N. Gordon, and
T. Clapp. A tutorial on particle ﬁlters for online
nonlinear/non-Gaussian Bayesian tracking. IEEE
Transactions on Signal Processing, 50(2):174–188,
2002.

D. Bahdanau, K. Cho, and Y. Bengio. Neural ma-
chine translation by jointly learning to align and
translate. In International Conference on Learning
Representations (ICLR), 2014.

Y. Burda, R. Grosse, and R. Salakhutdinov. Impor-
tance weighted autoencoders. In International Con-
ference on Learning Representations (ICLR), 2016.

E. Bursztein, M. Martin, and J. Mitchell. Text-based
CAPTCHA strengths and weaknesses. In Proceedings
of the 18th ACM Conference on Computer and Com-
munications Security, pages 125–138. ACM, 2011.

E. Bursztein, J. Aigrain, A. Moscicki, and J. C. Mitchell.
The end is nigh: generic solving of text-based
CAPTCHAs. In 8th USENIX Workshop on Oﬀensive
Technologies (WOOT 14), 2014.

B. Carpenter, A. Gelman, M. Hoﬀman, D. Lee,
B. Goodrich, M. Betancourt, M. A. Brubaker, J. Guo,
P. Li, and A. Riddell. Stan: a probabilistic program-
ming language. Journal of Statistical Software, 2015.

J. Cheng and M. J. Druzdzel. Ais-bn: An adaptive
importance sampling algorithm for evidential reason-
ing in large bayesian networks. Journal of Artiﬁcial
Intelligence Research, 2000.

R. Collobert, K. Kavukcuoglu, and C. Farabet. Torch7:
A MATLAB-like environment for machine learning.
In BigLearn, NIPS Workshop, EPFL-CONF-192376,
2011.

A. Cotter, O. Shamir, N. Srebro, and K. Sridharan.
Better mini-batch algorithms via accelerated gradi-
ent methods. In Advances in Neural Information
Processing Systems, pages 1647–1655, 2011.

J. Dean, G. Corrado, R. Monga, K. Chen, M. Devin,
M. Mao, M. aurelio Ranzato, A. Senior, P. Tucker,
K. Yang, Q. V. Le, and A. Y. Ng. Large scale
distributed deep networks. In F. Pereira, C. J. C.
Burges, L. Bottou, and K. Q. Weinberger, editors,

Advances in Neural Information Processing Systems
25, pages 1223–1231. Curran Associates, Inc., 2012.

A. Doucet and A. M. Johansen. A tutorial on particle
ﬁltering and smoothing: Fifteen years later. Hand-
book of Nonlinear Filtering, 12(656–704):3, 2009.

M. Everingham, L. Van Gool, C. K. Williams, J. Winn,
and A. Zisserman. The Pascal visual object classes
(VOC) challenge. International Journal of Computer
Vision, 88(2):303–338, 2010.

H. Gao, W. Wang, J. Qi, X. Wang, X. Liu, and J. Yan.
The robustness of hollow CAPTCHAs. In Proceedings
of the 2013 ACM SIGSAC Conference on Computer
& Communications Security, pages 1075–1086. ACM,
2013.

H. Gao, W. Wang, Y. Fan, J. Qi, and X. Liu.
The robustness of “connecting characters together”
CAPTCHAs. Journal of Information Science and
Engineering, 30(2):347–369, 2014.

A. Gelman and C. R. Shalizi. Philosophy and the
practice of Bayesian statistics. British Journal of
Mathematical and Statistical Psychology, 66(1):8–38,
2013.

S. J. Gershman and N. D. Goodman. Amortized in-
ference in probabilistic reasoning. In Proceedings of
the 36th Annual Conference of the Cognitive Science
Society, 2014.

R. Girshick. Fast R-CNN. In Proceedings of the IEEE
International Conference on Computer Vision, pages
1440–1448, 2015.

I. J. Goodfellow, Y. Bulatov, J. Ibarz, S. Arnoud, and
V. Shet. Multi-digit number recognition from street
view imagery using deep convolutional neural net-
works. In International Conference on Learning Rep-
resentations (ICLR), 2014.

N. D. Goodman, V. K. Mansinghka, D. M. Roy,
K. Bonawitz, and J. B. Tenenbaum. Church: A
language for generative models. In Uncertainty in
Artiﬁcial Intelligence, 2008.

A. D. Gordon, T. A. Henzinger, A. V. Nori, and S. K.
Rajamani. Probabilistic programming. In Future of
Software Engineering, FOSE 2014, pages 167–181.
ACM, 2014.

S. Gu, Z. Ghahramani, and R. E. Turner. Neural
adaptive sequential Monte Carlo. In Advances in
Neural Information Processing Systems, pages 2611–
2619, 2015.

G. E. Hinton, P. Dayan, B. J. Frey, and R. M. Neal.
The wake-sleep algorithm for unsupervised neural
networks. Science, 268(5214):1158–1161, 1995.

S. Hochreiter and J. Schmidhuber. Long short-term
memory. Neural Computation, 9(8):1735–1780, 1997.

M. Jaderberg, K. Simonyan, A. Vedaldi, and A. Zisser-
man. Synthetic data and artiﬁcial neural networks

Inference Compilation and Universal Probabilistic Programming

for natural scene text recognition. In Workshop on
Deep Learning, NIPS, 2014.

M. J. Johnson, D. Duvenaud, A. B. Wiltschko, S. R.
Datta, and R. P. Adams. Structured VAEs: Compos-
ing probabilistic graphical models and variational au-
toencoders. arXiv preprint arXiv:1603.06277, 2016.

A. Karpathy and L. Fei-Fei. Deep visual-semantic
alignments for generating image descriptions.
In
Proceedings of the IEEE Conference on Computer
Vision and Pattern Recognition, pages 3128–3137,
2015.

D. Kingma and J. Ba. Adam: A method for stochas-
In International Conference on

tic optimization.
Learning Representations (ICLR), 2015.

D. P. Kingma and M. Welling. Auto-encoding varia-
tional Bayes. In International Conference on Learn-
ing Representations (ICLR), 2014.

T. D. Kulkarni, P. Kohli, J. B. Tenenbaum, and V. K.
Mansinghka. Picture: a probabilistic programming
language for scene perception. In Proceedings of the
IEEE Conference on Computer Vision and Pattern
Recognition, 2015.

V. Lempitsky and A. Zisserman. Learning to count
objects in images. In Advances in Neural Information
Processing Systems, pages 1324–1332, 2010.

D. J. Lunn, A. Thomas, N. Best, and D. Spiegelhal-
ter. WinBUGS–a Bayesian modelling framework:
concepts, structure, and extensibility. Statistics and
Computing, 10(4):325–337, 2000.

V. Mansinghka, T. D. Kulkarni, Y. N. Perov, and
J. Tenenbaum. Approximate Bayesian image in-
terpretation using generative probabilistic graphics
programs. In Advances in Neural Information Pro-
cessing Systems, pages 1520–1528, 2013.

V. Mansinghka, D. Selsam, and Y. Perov. Ven-
ture: a higher-order probabilistic programming plat-
form with programmable inference. arXiv preprint
arXiv:1404.0099, 2014.

T. Minka, J. Winn, J. Guiver, S. Webster, Y. Za-
ykov, B. Yangel, A. Spengler, and J. Bronskill. In-
fer.NET 2.6, 2014. Microsoft Research Cambridge.
http://research.microsoft.com/infernet.

R. Nishihara, T. Minka, and D. Tarlow. Detecting
parameter symmetries in probabilistic models. arXiv
preprint arXiv:1312.5386, 2013.

B. Paige and F. Wood. Inference networks for sequential
Monte Carlo in graphical models. In Proceedings
of the 33rd International Conference on Machine
Learning, volume 48 of JMLR, 2016.

B. Paige, F. Wood, A. Doucet, and Y. W. Teh. Asyn-
chronous anytime sequential Monte Carlo. In Ad-
vances in Neural Information Processing Systems,
pages 3410–3418, 2014.

L. Prechelt. Early stopping — but when? In Neural
Networks: Tricks of the Trade, pages 55–69. Springer,
1998.

T. Rainforth, C. A. Naesseth, F. Lindsten, B. Paige,
J.-W. van de Meent, A. Doucet, and F. Wood. In-
teracting particle Markov chain Monte Carlo.
In
Proceedings of the 33rd International Conference
on Machine Learning, volume 48 of JMLR: W&CP,
2016.

S. Reed and N. de Freitas. Neural programmer-
interpreters. In International Conference on Learning
Representations (ICLR), 2016.

D. Ritchie, A. Stuhlmüller, and N. D. Goodman. C3:
Lightweight incrementalized MCMC for probabilistic
programs using continuations and callsite caching.
In AISTATS 2016, 2016a.

D. Ritchie, A. Thomas, P. Hanrahan, and N. Good-
man. Neurally-guided procedural models: Amortized
inference for procedural graphics programs using neu-
ral networks. In Advances In Neural Information
Processing Systems, pages 622–630, 2016b.

C. R. Shalizi et al. Dynamics of Bayesian updating with
dependent data and misspeciﬁed models. Electronic
Journal of Statistics, 3:1039–1074, 2009.

P. Y. Simard, D. Steinkraus, and J. C. Platt. Best
practices for convolutional neural networks applied
to visual document analysis. In Proceedings of the
Seventh International Conference on Document Anal-
ysis and Recognition – Volume 2, ICDAR ’03, pages
958–962, Washington, DC, 2003. IEEE Computer
Society.

F. Stark, C. Hazırbaş, R. Triebel, and D. Cremers.
Captcha recognition with active deep learning. In
GCPR Workshop on New Challenges in Neural Com-
putation, Aachen, Germany, 2015.

O. Starostenko, C. Cruz-Perez, F. Uceda-Ponga,
Breaking text-based
and V. Alarcon-Aquino.
CAPTCHAs with variable word and character orien-
tation. Pattern Recognition, 48(4):1101–1112, 2015.

I. Sutskever, O. Vinyals, and Q. V. Le. Sequence to
sequence learning with neural networks. In Advances
in Neural Information Processing Systems, pages
3104–3112, 2014.

T. Varga and H. Bunke. Generation of synthetic train-
ing data for an hmm-based handwriting recognition
system. In Seventh International Conference on Doc-
ument Analysis and Recognition, 2003, pages 618–
622. IEEE, 2003.

A. Vedaldi and K. Lenc. Matconvnet – convolutional
neural networks for MATLAB. In Proceeding of the
ACM International Conference on Multimedia, 2015.

S. Venugopalan, H. Xu, J. Donahue, M. Rohrbach,
R. Mooney, and K. Saenko. Translating videos to

Tuan Anh Le, Atılım Güneş Baydin, Frank Wood

natural language using deep recurrent neural net-
works. arXiv preprint arXiv:1412.4729, 2014.

O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show
and tell: A neural image caption generator. In Pro-
ceedings of the IEEE Conference on Computer Vision
and Pattern Recognition, pages 3156–3164, 2015.

L. von Ahn, M. Blum, N. J. Hopper, and J. Langford.
CAPTCHA: Using hard AI problems for security. In
International Conference on the Theory and Appli-
cations of Cryptographic Techniques, pages 294–311.
Springer, 2003.

D. Wingate, A. Stuhlmüller, and N. Goodman.
Lightweight implementations of probabilistic pro-
gramming languages via transformational compila-
tion. In Proceedings of the 14th International Con-
ference on Artiﬁcial Intelligence and Statistics, pages
770–778, 2011.

F. Wood, J. W. van de Meent, and V. Mansinghka.
A new approach to probabilistic programming infer-
ence. In Proceedings of the Seventeenth International
Conference on Artiﬁcial Intelligence and Statistics,
pages 1024–1032, 2014.

X. Zhang, Y. Fu, S. Jiang, L. Sigal, and G. Agam.
Learning from synthetic data using a stacked mul-
tichannel autoencoder. In 2015 IEEE 14th Inter-
national Conference on Machine Learning and Ap-
plications (ICMLA), pages 461–464, Dec 2015. doi:
10.1109/ICMLA.2015.199.

