IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

1

Combining Graph Neural Networks with Expert
Knowledge for Smart Contract Vulnerability
Detection

Zhenguang Liu, Peng Qian, Xiaoyang Wang, Yuan Zhuang, Lin Qiu, and Xun Wang

1
2
0
2

l
u
J

4
2

]

R
C
.
s
c
[

1
v
8
9
5
1
1
.
7
0
1
2
:
v
i
X
r
a

Abstract—Smart contract vulnerability detection draws extensive attention in recent years due to the substantial losses caused by
hacker attacks. Existing efforts for contract security analysis heavily rely on rigid rules deﬁned by experts, which are labor-intensive and
non-scalable. More importantly, expert-deﬁned rules tend to be error-prone and suffer the inherent risk of being cheated by crafty
attackers. Recent researches focus on the symbolic execution and formal analysis of smart contracts for vulnerability detection, yet to
achieve a precise and scalable solution. Although several methods have been proposed to detect vulnerabilities in smart contracts,
there is still a lack of effort that considers combining expert-deﬁned security patterns with deep neural networks.

In this paper, we explore using graph neural networks and expert knowledge for smart contract vulnerability detection. Speciﬁcally,
we cast the rich control- and data- ﬂow semantics of the source code into a contract graph. To highlight the critical nodes in the graph,
we further design a node elimination phase to normalize the graph. Then, we propose a novel temporal message propagation network
to extract the graph feature from the normalized graph, and combine the graph feature with designed expert patterns to yield a ﬁnal
detection system. Extensive experiments are conducted on all the smart contracts that have source code in Ethereum and VNT Chain
platforms. Empirical results show signiﬁcant accuracy improvements over the state-of-the-art methods on three types of vulnerabilities,
where the detection accuracy of our method reaches 89.15%, 89.02%, and 83.21% for reentrancy, timestamp dependence, and inﬁnite
loop vulnerabilities, respectively.

Index Terms—Deep learning, blockchain, smart contract, vulnerability detection, expert knowledge

(cid:70)

1 INTRODUCTION

B Lockchain and its killer applications, e.g., Bitcoin and

smart contract, are taking the world by storm [1–6]. A
blockchain is essentially a distributed and shared transac-
tion ledger, maintained by all the miners in the blockchain
network following a consensus protocol [7]. The consen-
sus protocol and replicated ledgers enforce all the trans-
actions immutable once recorded on the chain, endowing
blockchain with decentralization and tamper-free nature.

Smart contract. Smart contracts are programs running on
top of the blockchain [4, 8]. A smart contract can implement
arbitrary rules for managing assets by encoding the rules
into source code. The deﬁned rules of a contract will be
strictly and automatically followed during execution, effec-
tuating the ‘code is law’ logic. Smart contracts make the
automatic execution of contract terms possible, facilitating
complex decentralized applications (DApps). Indeed, many
DApps are basically composed of several smart contracts as
the backend and a user interface as the frontend [9].

Millions of smart contracts have been deployed in var-
ious blockchain platforms, enabling a wide range of appli-

• Zhenguang Liu, Peng Qian are with School of Computer and Information
Engineering, Zhejiang Gongshang University and Zhejiang University,
China. Email: liuzhenguang2008@gmail.com, messi.qp711@gmail.com

• Yuan Zhuang is with National University of Singapore, Singapore.
• Xiaoyang Wang is with School of Computer and Information Engineering,

Zhejiang Gongshang University, China.
•
Lin Qiu is with Southern University of Science and Technology, China.
• Xun Wang is with School of Computer and Information Engineer-
ing, Zhejiang Gongshang University and Zhejiang Lab, China. Email:
xwang@zjgsu.edu.cn.

Corresponding authors: Peng Qian, Xun Wang

cations including wallets [10], crowdfunding, decentralized
gambling [11], and cross-industry ﬁnance [12]. The number
of smart contracts is still growing rapidly. For example,
within the last six months, over 15,000 new contracts were
deployed on Ethereum alone, which is the most famous
smart contract platform.

Security issues of smart contracts. Smart contracts from
various ﬁelds now hold more than 10 billion dollars worth
of virtual coins. Undoubtedly, holding so much wealth
makes smart contracts attractive enough to attackers. In June
2016, attackers exploited the reentrancy vulnerability of the
DAO contract [13] to steal 3.6 million Ether, which was
worth 60 million US Dollars. This case is not isolated and
several security vulnerabilities are discovered and exploited
every few months [13–15], undermining the trust for smart
contract-based applications.

There are several reasons that make smart contracts par-
ticularly prone to errors. First, the programming languages
(e.g., Solidity) and tools are still new and crude, leaving
plenty of rooms for bugs and misunderstandings in the tools
[8, 16]. Second, since smart contracts are immutable once
deployed, developers are required to anticipate all possible
status and environments the contract may encounter in
the future, which is undoubtedly difﬁcult. Distinct from
conventional distributed applications that can be updated
when bugs are detected, there is no way to patch the bugs
of a smart contract without forking the blockchain (almost
an impossible task), regardless of how much money the
contract holds or how popular it is [8]. Therefore, effective
vulnerability checkers for smart contracts before their de-

 
 
 
 
 
 
IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

2

ployment are essential.

Drawbacks of conventional methods. Conventional
methods for smart contract vulnerability detection, such as
[8, 16–18], employ classical static analysis or dynamic exe-
cution techniques to identify vulnerabilities. Unfortunately,
they fundamentally rely on several expert-deﬁned patterns.
The manually deﬁned patterns bear the inherent risk of
being error-prone and some complex patterns are non-trivial
to be covered. Crudely using several rigid patterns leads to
high false-positive and false-negative rates, and crafty attackers
may easily bypass the pattern checking using tricks. More-
over, as the number of smart contracts increases rapidly, it
is becoming impossible for a few experts to sift through all
the contracts to design precise patterns. A feasible solution
might be: ask each expert to label a number of contracts,
then collect all the labeled contracts from many experts to
train a model that can automatically give a prediction on
whether a contract has a speciﬁc type of vulnerability.

Recently, efforts have been made towards adopting deep
neural networks for smart contract vulnerability detection
[19–21], achieving improved accuracy. [19] utilizes LSTM
based networks to sequentially process source code, while
[20] models the source code into control ﬂow graphs. [21]
builds a sequential model to analyze the Ethereum op-
eration code. However, these approaches either treat the
source code or operation code as a text sequence instead
of semantic blocks, or fail to highlight critical variables in
the data ﬂow [20], leading to insufﬁcient semantic modeling
and unsatisfactory results.

To ﬁll the research gap, in this paper, we investigate
more than 300,000 smart contract functions and present
a fully automated and scalable approach that can detect
vulnerabilities at the function level. Speciﬁcally, we cast the
rich control- and data- ﬂow semantics of the source code into
graphs. The nodes in the graph represent critical variables
and function invocations, while directed edges capture their
temporal execution traces. Since not all nodes in the graph
are of equal importance and most graph neural networks
are inherently ﬂat during information propagation on the
graph, we design a node elimination phase to normalize the
graph and highlight the key nodes. The normalized graph
is then fed into a temporal message propagation network
to learn the graph feature. In the meantime, we extract the
security pattern feature from the source code using expert
knowledge. Finally, the graph feature and security pattern
feature are incorporated to produce the ﬁnal vulnerability
detection results.

We conducted experiments on all the 40k contracts that
have source code in Ethereum and on all the contracts in
VNT Chain, demonstrating signiﬁcant improvements over
state-of-the-art vulnerability detection methods: F1 score
from 78% to 86%, 79% to 88%, 74% to 82% for reentrancy,
timestamp dependence, and inﬁnite loop vulnerabilities, respec-
tively. Our implementations1 are released to facilitate future
research.

We would like to point out that this work is clearly
distinct from the previous one [20] in three ways: 1) this
work is to investigate whether combining graph neural
networks with conventional expert patterns could achieve

1. Github: https://github.com/Messi-Q/GPSCVulDetector

better vulnerability detection results, while the objective
of the previous work is to explore the possibility of using
neural networks for smart contract vulnerability detection.
2) In this work, we propose to extract vulnerability-speciﬁc
expert patterns and combine them with the graph feature.
We also explicitly model the key variables in the data ﬂow.
In contrast, in the previous work, we only utilize the graph
feature while ignoring expert patterns and key variables. 3)
This work consistently outperforms the previous one across
different vulnerabilities, and overall provides more insights
and ﬁndings in this ﬁeld. Note that in the previous paper,
we proposed two neural networks, DR-GCN and TMP, to
explore the applicability of different graph neural networks
on smart contract vulnerability detection. In this paper, we
focus on extending TMP, which delivers better performance
than DR-GCN. We will also extend DR-GCN and compare it
with the extension of TMP.

Contributions. To summarize, the key contributions are:
• To the best of our knowledge, we are the ﬁrst to inves-
tigate the idea of fusing conventional expert patterns
and graph-neural-network extracted features for smart
contract vulnerability detection.

• We propose to characterize the contract function source
code as contract graphs. We also explicitly normalize
the graph to highlight key variables and invocations.
A novel temporal message propagation network is pro-
posed to automatically capture semantic graph features.
• Our methods set the new state-of-the-art performance
on smart contract vulnerability detection, and overall
provide insights into the challenges and opportunities.
As a side contribution, we have released our implemen-
tations to facilitate future research.

2 RELATED WORK
2.1 Smart Contract Vulnerability Detection

Smart contract vulnerability detection is one of the fun-
damental problems in blockchain security. Early works on
smart contract vulnerability detection verify smart contracts
by employing formal methods [22–25]. For example, [22]
introduces a framework, translating Solidity code (the smart
contract programming language of Ethereum) and the EVM
(Ethereum Virtual Machine) bytecode into the input of an
existing veriﬁcation system. [25] proposes a formal model
for EVM and reasons the potential bugs in smart contracts
by using the Isabelle/HOL tool. Further, [23] and [24] deﬁne
formal semantics of the EVM using the F* framework and
the K framework, respectively. Although these frameworks
provide strong formal veriﬁcation guarantees, they are still
semi-automated.

Another stream of work relies on generic testing and
symbolic execution, such as Oyente [8], Maian [26], and
Securify [18]. Oyente is one of the pioneering works that
perform symbolic execution on contract functions and ﬂags
bugs based on simple patterns. Zeus [27] leverages abstract
interpretation and symbolic model checking, as well as the
constrained horn clauses to detect vulnerabilities in smart
contracts. [18] introduces compliance (negative) and viola-
tion (positive) patterns to ﬁlter false warnings.

Researchers also explore smart contract vulnerability
detection using dynamic execution. [17] presents Contract-
Fuzzer to identify vulnerabilities by fuzzing and runtime

IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

3

functions in binary code are represented by attributed con-
trol ﬂow graphs. [34] develops Devign, a general graph neu-
ral network-based model for vulnerability identiﬁcation in
C programming language. Different from these methods, we
focus on the speciﬁc smart contract vulnerability task, and
explicitly take into account the distinct roles and temporal
relationships of program elements.

Fig. 1 A simpliﬁed example of reentrancy vulnerability.

3 PROBLEM STATEMENT

behavior monitoring during execution. Similarly, [28] de-
velops a fuzzing-based analyzer to identify the reentrancy
vulnerability. Sereum [29] uses taint analysis to monitor
runtime data ﬂows during smart contract execution for vul-
nerability detection. However, dynamic execution methods
require a hand-crafted agent contract to interact with the
contract under test, preventing them from fully-automated
applications and endowing them non-scalability.

Recently, a few attempts have been made to study using
deep neural networks for smart contract vulnerability detec-
tion. [19] constructs the sequential contract snippet and feeds
them into the BLSTM-ATT model to detect reentrancy bugs.
[20] proposes to convert the source code of a contract into
the contract graph and constructs graph neural networks as
the detection model. [30] proposes ContractWard, extracting
bigram features from the operation code of smart contracts
and utilizing machine learning algorithms. However, al-
though a few methods have been proposed, the ﬁeld of con-
tract vulnerability detection using deep learning is still in its
infancy and the accuracy is still unsatisfactory. For common
smart contract vulnerabilities and attacks, motivated readers
may refer to [31] for a comprehensive survey.

2.2 Graph Neural Network

With the remarkable success of neural networks, graph
neural network has been investigated extensively in various
ﬁelds such as graph classiﬁcation [32, 33], program analysis
[34, 35], and graph embedding [36]. Existing approaches
roughly cast into two categories: (i) Spectral-based approaches
generalize well-established neural networks like CNNs to
work on graph-structured data. For instance, GCN [37]
implements a ﬁrst-order approximation of spectral graph
convolutions [38–40] and develops a layer-wise propaga-
tion network using the Laplacian matrix, which achieves
promising performance on graph node classiﬁcation tasks.
[41] proposes a graph CNN which can take data of arbitrary
graph structure as input. (ii) Spatial-based methods inherit
ideas from recurrent GNNs and adopt information prop-
agation to deﬁne graph convolutions. Early work such as
[42] directly sums up the nodes’ neighborhood information
for graph convolutions. Another line of work, such as GAT
[43] and GAAN [44], employs attention mechanisms to learn
the weights of different neighboring nodes. Motivated by
these spatial-based approaches, [45] outlines a message-
passing neural network framework to predict the chemical
properties of molecules.

Recently, [34, 35, 46, 47] attempt to apply GNNs to
program analysis issues. Speciﬁcally, [35] introduces a gated
graph recurrent network for variable prediction, while [46]
proposes Gemini for binary code similarity detection, where

In this section, we ﬁrst formulate the problem, then in-
troduce the three types of vulnerabilities studied in this
paper, and present the reasons for focusing on these three
vulnerabilities.

Problem formulation. Given the source code of a smart
contract, we are interested in developing a fully automated
approach that can detect vulnerabilities at the function level.
In other words, we are to estimate the label ˆy for each
smart contract function f , where ˆy = 1 represents f has
a speciﬁc vulnerability while ˆy = 0 denotes f is safe. In
this paper, we focus on three types of vulnerabilities, which
will be presented below. Before that, we ﬁrst introduce the
preliminary knowledge of the fallback mechanism in smart
contracts, which is important in understanding the problem.
Fallback mechanism. Within a smart contract, each func-
tion is uniquely identiﬁed by a signature, consisting of its
name and parameter types [31]. Upon a function invocation,
the signature of the invoked function is passed to the called
contract. If the signature matches a function of the called
contract, the execution jumps to the corresponding function.
Otherwise, it jumps to the fallback function. Money transfer
is considered as an empty signature, which will trigger
the fallback function as well. The fallback function is a
special function with no name and no argument, which
can be arbitrarily programmed [31]. After introducing this
background knowledge, we now are ready to elaborate on
the three types of vulnerabilities.

(1) Reentrancy is a well-known vulnerability that caused
the infamous DAO attack. When a smart contract function
f1 transfers money to a recipient contract C, the fallback
function f2 of C will be automatically executed. In its fall-
back function f2, C may invoke back to f1 for conducting an
invalid second-time transfer. Since the current execution of
f1 waits for the ﬁrst-time transfer to ﬁnish, C can make use
of the intermediate state of f1 to succeed in stealing money.
A simpliﬁed example is shown in Fig. 1, where the withdraw
function of contract Bank has a reentrancy vulnerability,
contract Attacker steals money by exploiting the vulnera-
bility. First, Attacker deposits 10 Ether (Ether is the virtual
money of Ethereum) in contract Bank (step 1). Then, Attacker
withdraws the 10 Ether by invoking the withdraw function
(step 2). When the contract Bank sends 10 Ether to Attacker
using call.value (Bank, line 9), the fallback function (Attacker,
lines 8–11) of Attacker will be automatically invoked (step 3).
In its fallback function, Attacker calls withdraw again (step
4). Since the userBalance of Attacker has not yet been set to 0
(Bank, line 10), Bank believes that Attacker still has 10 Ether in
the contract, thus transfers 10 Ether to Attacker again (Step
5). The withdraw loop lasts for 9 times (count + + < 10,
Attacker line 9). Finally, Attacker obtains much more Ether
(100 Ether) than expected (10 Ether).

123456789101112123456789101112c(cid:82)(cid:81)(cid:87)(cid:85)ac(cid:87)(cid:3)Ba(cid:81)(cid:78)(cid:94)(cid:3)(cid:3)(cid:80)a(cid:83)(cid:83)(cid:76)(cid:81)g(cid:3)(add(cid:85)e(cid:86)(cid:86)(cid:3)=>(cid:3)(cid:88)(cid:81)(cid:76)(cid:87))(cid:3)(cid:83)(cid:85)(cid:76)(cid:89)a(cid:87)e(cid:3)(cid:88)(cid:86)e(cid:85)Ba(cid:79)a(cid:81)ce;(cid:3)(cid:3)(cid:3)(cid:3)f(cid:88)(cid:81)c(cid:87)(cid:76)(cid:82)(cid:81)(cid:3)de(cid:83)(cid:82)(cid:86)(cid:76)(cid:87)()(cid:3)(cid:83)a(cid:92)ab(cid:79)e(cid:94)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:88)(cid:86)e(cid:85)Ba(cid:79)a(cid:81)ce[(cid:80)(cid:86)g.(cid:86)e(cid:81)de(cid:85)]+=(cid:80)(cid:86)g.(cid:89)a(cid:79)(cid:88)e;(cid:3)(cid:3)(cid:3)(cid:3)(cid:96)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)f(cid:88)(cid:81)c(cid:87)(cid:76)(cid:82)(cid:81)(cid:3)(cid:3)(cid:90)(cid:76)(cid:87)hd(cid:85)a(cid:90)()(cid:3)(cid:3)(cid:83)(cid:88)b(cid:79)(cid:76)c(cid:94)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:88)(cid:76)(cid:81)(cid:87)(cid:3)a(cid:80)(cid:82)(cid:88)(cid:81)(cid:87)(cid:3)=(cid:3)(cid:88)(cid:86)e(cid:85)Ba(cid:79)a(cid:81)ce[(cid:80)(cid:86)g.(cid:86)e(cid:81)de(cid:85)];(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:85)e(cid:84)(cid:88)(cid:76)(cid:85)e((cid:80)(cid:86)g.(cid:86)e(cid:81)de(cid:85).ca(cid:79)(cid:79).(cid:89)a(cid:79)(cid:88)e(a(cid:80)(cid:82)(cid:88)(cid:81)(cid:87))());(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:88)(cid:86)e(cid:85)Ba(cid:79)a(cid:81)ce[(cid:80)(cid:86)g.(cid:86)e(cid:81)de(cid:85)](cid:3)=(cid:3)0;(cid:3)(cid:3)(cid:3)(cid:3)(cid:96)(cid:96)(cid:3)(cid:3)(cid:3)(cid:3)c(cid:82)(cid:81)(cid:87)(cid:85)ac(cid:87)(cid:3)A(cid:87)(cid:87)ac(cid:78)e(cid:85)(cid:94)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)add(cid:85)e(cid:86)(cid:86)(cid:3)ba(cid:81)(cid:78)_add=01f3(cid:91)...32;(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)f(cid:88)(cid:81)c(cid:87)(cid:76)(cid:82)(cid:81)(cid:3)(cid:3)a(cid:87)(cid:87)ac(cid:78)()(cid:94)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)ba(cid:81)(cid:78)_add.de(cid:83)(cid:82)(cid:86)(cid:76)(cid:87).(cid:89)a(cid:79)(cid:88)e(10(cid:3)e(cid:87)he(cid:85))();(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)ba(cid:81)(cid:78)_add.(cid:90)(cid:76)(cid:87)hd(cid:85)a(cid:90)();(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:96)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)f(cid:88)(cid:81)c(cid:87)(cid:76)(cid:82)(cid:81)(cid:3)(cid:3)()(cid:3)(cid:3)(cid:83)a(cid:92)ab(cid:79)e(cid:94)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:76)f(c(cid:82)(cid:88)(cid:81)(cid:87)(cid:3)++(cid:3)<(cid:3)10)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)ba(cid:81)(cid:78)_add.(cid:90)(cid:76)(cid:87)hd(cid:85)a(cid:90)();(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:96)(cid:96)(cid:3)134(cid:24)2IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

4

Fig. 2 The overall architecture of our proposed method. (a) The expert pattern extraction phase; (b) the contract graph
construction and normalization phase; (c) the vulnerability detection phase.

(2) Timestamp dependence vulnerability exists when
a smart contract uses the block timestamp as a triggering
condition to execute some critical operations, e.g., using the
timestamp of a future block as the source to generate random
numbers so as to determine the winner of a game. The miner
(a node in the blockchain) who mines the block has the
freedom to set the timestamp of the block within a short
time interval (< 900 seconds) [17]. Therefore, miners may
manipulate the block timestamps to gain illegal beneﬁts.

(3) Inﬁnite loop is a common vulnerability in smart
contracts. The program of a function may contain a loop (e.g.
for loop, while loop, and self-invocation loop) with no exit
condition or the exit condition cannot be reached, namely
an inﬁnite loop.

Why focus on these vulnerabilities. We mainly focus
on the three aforementioned vulnerabilities since: (i) In
real attacks, blockchain networks have suffered more than
100 million USD losses due to the three vulnerabilities.
For instance, attacks on reentrancy have caused one of the
biggest losses (60 million USD in The Dao Event) in smart
contract history. (ii) We empirically found that the three
vulnerabilities may affect a signiﬁcant number of smart
contracts and are non-trivial to be detected. Speciﬁcally,
we surveyed 40,932 Ethereum smart contracts, observing
that around 5,013 out of 307,396 functions possess at least
one invocation to call.value. Although possessing a call.value
invocation does not necessarily mean that the contract has
a reentrancy vulnerability, the contract has the potential
to be affected by the reentrancy vulnerability and thus re-
quires further checking. Similarly, around 4,833 functions
have used block.timestamp and thus are potentially affected
by the timestamp dependence vulnerability. Many functions
have for or while loops, which may lead to the inﬁnite loop
vulnerability. In contrast, most other contract vulnerabilities
affect a relatively smaller number of functions, e.g., the locked
ether vulnerability affects less than 900 functions, and the
integer overﬂow vulnerability affects less than 1,000 functions.

4 OUR METHOD
Method overview. The overall architecture of our proposed
method is depicted in Fig. 2, which consists of three phases:
(1) a security pattern extraction phase, which obtains the
vulnerability-speciﬁc expert patterns from the source code;
(2) a contract graph construction and normalization phase,
which extracts the control ﬂow and data ﬂow semantics
from the source code and highlights the critical nodes; and
(3) a vulnerability detection phase, which casts the normal-
ized contract graph into graph feature using temporal graph
neural network, and combines the pattern feature and graph

feature to output the detection result. In what follows, we
elaborate on the details of the three components one by one.

4.1 Expert Pattern Extraction

In this section, we summarize existing patterns and design
new patterns for the three speciﬁc vulnerabilities respec-
tively, and implement an open-sourced tool to automatically
extract these patterns.

Reentrancy. Conventionally, the reentrancy vulnerability
is considered as an invocation to call.value that can call back
to itself through a chain of calls. That is, the invocation
of call.value is successfully re-entered to perform the unex-
pected operation of repeated money transfer. By investigat-
ing existing works such as [8, 17, 27], we design three sub-
patterns. The ﬁrst sub-pattern is callValueInvocation that
checks whether there exists an invocation to call.value in the
function. The second sub-pattern balanceDeduction checks
whether the user balance is deducted after money transfer
using call.value, which considers the fact that the money
stealing can be avoided if user balance is deducted each time
before money transfer. The third sub-pattern enoughBalance
concerns whether there is a check on the sufﬁciency of
the user balance before transferring to a user. Note that
enoughBalance is a new pattern designed in this paper.

Timestamp dependence. Generally, the timestamp de-
pendence vulnerability exists when a smart contract uses the
block timestamp as part of the conditions to perform critical
operations [17]. By investigating previous works including
[8, 17, 31], we design three sub-patterns that are closely
related to timestamp dependence. First, sub-pattern times-
tampInvocation models whether there exists an invocation
to opcode block.timestamp in the function. Then, the second
sub-pattern timestampAssign checks whether the value of
block.timestamp is assigned to other variables or passed to
a function as a parameter, namely whether block.timestamp
is actually used. Last, the third sub-pattern timestampCon-
tamination checks if block.timestamp may contaminate the
triggering condition of a critical operation, which can be
implemented by taint analysis. Sub-pattern timestampCon-
tamination is a new pattern designed in this paper.

Inﬁnite loop. Inﬁnite loop is conventionally considered
as a loop bug which unintentionally iterates forever, failing
to jump out of the loop and return an expected result.
Speciﬁcally, we deﬁne three expert patterns for inﬁnite loop
as follows. (1) The ﬁrst sub-pattern loopStatement checks
whether the function possesses a loop statement such as for
and while. (2) The second sub-pattern loopCondition mod-
els whether the exit condition can be reached. For example,

(b)	Contract	graph	construction	and	normalizationC3C2C1C1C3C2e1(a)	Security	pattern	extractione2e3contract	graphs(c)	Vulnerability	detectionsmart	contract	functionssecurity	patternspragma	solidity	0.4.24;contract	DAO{		function	withdraw(){				msg.sender.call.value();				balance[msg.sender]-=0;				......		}}GrPrIEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

5

Fig. 3 The contract graph construction and normalization phase. The ﬁrst ﬁgure shows the source code of a contract
function, while the second ﬁgure visualizes the contract graph extracted from the code. Nodes Ci denote core nodes,
nodes Ni represent normal nodes, and node F denotes fallback node. The third ﬁgure illustrates the temporal edges
in the extracted graph, where the types of edges are detailed in Table 1. The fourth ﬁgure demonstrates the graph after
normalization.

for a while loop, its exit condition i < 10 may not be reached
if i is never updated in the loop. (3) The third sub-pattern
selfInvocation models whether the function invokes itself
and the invocation is not in an if statement. This concerns
the fact that if the self-invocation statement is not in an if
statement, the self-invocation loop will never terminate.

Pattern Extraction Implementations. We implemented
an open-sourced tool to extract the designed expert pat-
terns from smart contract functions. Particularly, simple sub-
patterns such as callValueInvocation, timestampInvocation, and
loopStatement can be directly extracted by keyword match-
ing. Sub-patterns balanceDeduction, enoughBalance, loopCondi-
tion, timestampAssign, and selfInvocation are obtained by syn-
tax analysis. Complex sub-pattern timestampContamination is
extracted by taint analysis where we follow the traces of the
data ﬂow and ﬂag all the variables that may be affected
along the traces.

4.2 Contract Graph Construction and Normalization

Existing works [35, 48] have shown that programs can be
transformed into symbolic graph representations, which are
able to preserve semantic relationships (e.g., data depen-
dency and control dependency) between program elements.
Inspired by this, we formulate smart contract functions into
contract graphs, and assign distinct roles to different program
elements (namely nodes). We also construct edges to model
control and data ﬂow between program elements, taking
their temporal orders into consideration. Further, we design
a node elimination process to normalize the contract graph
and highlight important nodes. Next, we introduce contract
graph construction and normalization, respectively.

4.2.1 Contract Graph Construction

Nodes construction. Our ﬁrst insight is that different pro-
gram elements in a function are not of equal importance in
detecting vulnerabilities. Therefore, we extract three types
of nodes, i.e., core nodes, normal nodes, and fallback nodes.

Core nodes. Core nodes symbolize the key invocations
and variables that are critical for detecting a speciﬁc vul-
nerability. In particular, for reentrancy vulnerability, core
nodes model (i) an invocation to a money transfer function

or the built-in call.value function, (ii) the variable that cor-
responds to user balance, and (iii) variables that can directly
affect user balance. For timestamp dependence vulnerability,
(i) invocations to block.timestamp, (ii) variables assigned by
block.timestamp, and (iii) invocations to a random function
that takes block.timestamp as the cardinal seed are extracted
as core nodes. For inﬁnite loop vulnerability, (i) all the loop
statements such as for and while statements, (ii) the loop
condition variables, and (iii) self invocations are considered
as core nodes.

Normal nodes. While core nodes represent key invoca-
tions and variables, normal nodes are used to model invo-
cations and variables that play an auxiliary role in detecting
vulnerabilities. Speciﬁcally, invocations and variables that
are not extracted as core nodes are modeled as normal ones,
e.g., for timestamp dependence vulnerability, invocations
that do not call block.timestamp and variables indirectly
related to block.timestamp are considered as normal nodes.

Fallback node. Further, we construct a fallback node F to
stimulate the fallback function of a virtual attack contract,
which can interact with the function under test.

A simpliﬁed example. Taking contract Vulnerable presented
in the left of Fig. 3 as an example, suppose we are to evaluate
whether its withdraw function possesses a reentrancy vulner-
ability. As shown by the arrows in the left two ﬁgures of Fig.
3, function withdraw itself is ﬁrst modeled as a core node C1
since its inner code contains call.value. Then, following the
temporal order of the code, we treat the critical variable
Balance[msg.sender] as a core node C2, while variable
amount is modeled as normal node N1. The invocation
to call.value is extracted as a core node C3, and the fallback
function of a virtual attack contract is characterized by the
fallback node F .

Edges construction. Our second insight is that the nodes
are closely related to each other in a temporal manner rather
than being isolated. To capture rich semantic dependencies
between the nodes, we construct three categories of edges,
namely control ﬂow, data ﬂow, and fallback edges. Each edge
describes a path that might be traversed through by the
function under test, and the temporal number of the edge
characterizes its sequential order in the function. We investi-

VsVeOrderTypee1C1C21ITe2C1N12ITe3C2N13ACe4N1C34FWe5C3N15ACe6C3C36RGe7C3C27FWe8C2C28ACe9C2N19AGe10C3F10FBe11FC111FBContract Vulnerable12345678910Temporal EdgesContract Graph//…//withdrawfunctionfunctionwithdraw(uintamount)public{if(Balance[msg.sender]<amount){throw;}require(msg.sender.call.value(amount)());Balance[msg.sender]-=amount;}//…Normalized GraphFC1C2N1C3Core NodeFallback NodeCiNiNormal NodeFControlFlow EdgeDataFlow EdgeFallbackEdgee1e4e3e2e5e7e9e10e11e8C1C2C3e1e4e3e2e5e7e9e8e11e10e6e6IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

6

Type (Abbreviation)
AH
RG
IR
IT
IF
GB
GN
WH
FR
FW
AG
AC
FB

Semantic Fact
assert{X}
require{X}
if{...} revert
if{...} throw
if{X}
if{...} else {X}
if{...} then {X}
while{X} do{...}
for{X} do{...}
natural sequential relationships
assign{X}
access{X}
interactions with fallback function

Category

Control-ﬂow

Data-ﬂow

Fallback

TABLE 1 Semantic edges summarization. All edges are
classiﬁed into three categories, namely control-ﬂow, data-
ﬂow, and fallback edges.

gated various functions and summarized the semantic edges
in Table 1. All edges are classiﬁed into three categories.

Control ﬂow edges. Control ﬂow edges capture the control
semantics of the code. Speciﬁcally, a control ﬂow edge is
constructed for a conditional statement or security handle
statement, such as a if, for, assert, and require statement. The
edge directs from the previous node encountered, which
represents the critical function call or variable preceding to
the current statement, to the node representing the function
call or variable in the current statement. In particular, we
use forward edges to describe the natural control ﬂow of the
code sequence. A forward edge connects two nodes in the
adjacent statements. The main beneﬁt of such encoding is to
reserve the programming logic reﬂected by the sequence of
the source code. The control ﬂow edges are depicted with
red arrows in Fig. 3.

Data ﬂow edges. Data ﬂow edges track the usage of vari-
ables. A data ﬂow edge involves the access or modiﬁcation
of a variable. The data ﬂow edges are demonstrated with
orange arrows in Fig. 3. For example, the access and assign
statement Balance[msg.sender]-=amount (line 8, Vulnera-
ble, Fig. 3) is characterized by two data ﬂow edges, i.e.,
an access edge e7 starting from the Balance[msg.sender]
variable node C2 to itself, and an assign edge e8 starting
from C2 to the amount variable node N1.

Fallback edges. In order to explicitly model the speciﬁc
fallback mechanism, two fallback edges are constructed. The
ﬁrst fallback edge connects from the ﬁrst call.value invoca-
tion to the fallback node, while the second edge directs from
the fallback node to the function under test. The fallback
edges are shown by dashed purple edges in Fig. 3.

Node and edge features. Fig. 4 illustrates the extracted
features for edges and nodes, respectively. Speciﬁcally, the
feature of an edge is extracted as a tuple (Vstart, Vend,
Order, Type), where Vstart and Vend represent its start and
end nodes, Order denotes its temporal order, and Type
stands for edge type. For nodes, different kinds of nodes
possess different features. 1) The feature of a node that
models function invocation consists of (ID, AccFlag, Caller,
Type), where ID denotes its identiﬁer, Caller represents the
caller address of the invocation, and T ype stands for the
node type. Interestingly, the modiﬁer of a smart contract
function Ψ may trigger the pre-check of certain conditions,
e.g., modiﬁer owner will check whether the caller of Ψ is
the owner of the contract before executing Ψ. Therefore,
we use AccFlag to capture this semantics, where AccFlag
= ‘LimitedACC’ speciﬁes the function has limited access
while AccFlag =‘NoLimited’ denotes non-limited access. 2)
In contrast, the feature of a fallback node or a node that

Fig. 4 Illustration of the edge feature and node feature.

models variable consists of only ID and Type.

4.2.2 Contract Graph Normalization

Most graph neural networks are inherently ﬂat when prop-
agating information, ignoring that some nodes play more
central roles than others. Moreover, different contract func-
tions yield distinct graphs, hindering the training of graph
neural networks. Therefore, we propose a node elimination
process to normalize the contract graph.

i=1, normal nodes {Ni}|N |

Nodes elimination. As introduced in Section 4.2.1, the
nodes of a contract graph are partitioned into core nodes
{Ci}|C|
i=1, and the fallback node F .
We remove each normal node Ni, but pass the feature of
Ni to its nearest core nodes. For example, the normal node
N1 in the second ﬁgure of Fig. 3 is removed with its feature
aggregated to nearest core nodes C2 and C3. For a node Ni
that has multiple nearest core nodes, its feature is passed
to all of them. The edges connected to the removed normal
nodes are preserved but with their start or end node moving
to the corresponding core node. The fallback node is also
removed similar to the normal node.

Feature aggregation. After removing normal nodes, fea-
tures of core nodes are updated by aggregating features
from their neighboring normal nodes. More precisely, the
new feature of Ci is composed of three components: (i) self-
feature, namely the feature of core node Ci itself; (ii) in-
features, namely features of the normal nodes {Pj}|P |
j=1 that
are merged to Ci and having a path pointing from Pj to Ci;
and (iii) out-feature, namely features of the normal nodes
{Qk}|Q|
k=1 that are merged to Ci and having a path directs
from Qk to Ci. Note that features of different normal nodes
that model variables and invocations are added respectively
when aggregating to the same node.

4.3 Vulnerability Detection

In this subsection, we introduce the proposed vulnerabil-
ity detection network CGE (Combining Graph feature and
Expert patterns). First, we obtain the expert pattern feature
Pr by passing the extracted sub-patterns (introduced in
subsection 4.1) into a feed-forward neural network (FNN).
Then, we extract the graph feature Gr from the normalized
contract graph by our proposed temporal message propaga-
tion network, consisting of a message propagation phase and
a readout phase. Finally, we use a fusion network to combine
the graph feature Gr and the pattern feature Pr, outputting
the detection results. The process is demonstrated in Fig. 5
with details presented below.

Security pattern feature Pr extraction. For the sub-
patterns closely related to a speciﬁc vulnerability, we utilize
a one-hot vector to represent each sub-pattern, and append
a 0/1 digit to each vector, which indicates whether the func-
tion under test has the sub-pattern. The vectors for all sub-
patterns related to a speciﬁc vulnerability are concatenated

IDLimitedAccCallerTypeIDTypeIDTypeVstartVendOrderTypeEdge	FeatureFallback	Node	FeatureVariable	Node	FeatureInvocation	Node	FeatureIEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

7

Fig. 5 The process of vulnerability detection. First, a feed-forward neural network generates the pattern feature Pr
for the security patterns extracted from the source code. Then, the temporal message propagation network is used to
extract the graph feature Gr from the contract graph. Finally, the CGE network combines Gr and Pr into the merged
feature Xr, which is fed into the FC and sigmoid layers to output the vulnerability detection results.

into a ﬁnal vector x. Taking x as the input, and the ground
truth of whether the function has the speciﬁc vulnerability
as the target label, we utilize a feed-forward neural network
ϕ(x) to extract high-dimensional semantic feature Pr ∈ Rd.
Contract graph feature Gr Extraction. After extracting
security pattern feature Pr, we further obtain the seman-
tic feature of the contract graph by using our proposed
temporal-message-propagation network, which consists of
a message propagation phase and a readout phase. In the
message propagation phase, the network passes information
along the edges successively by following their temporal
orders. Then, it generates the graph feature Gr by using
a readout function, which aggregates the ﬁnal states of all
nodes in the contract graph.

Message propagation phase. Formally, we denote the nor-
malized contract graph as G = {V, E}, where V consists of
the core nodes, and E consists of all edges. Denote E = {e1,
e2, . . . , eN }, where ek represents the kth temporal edge.

Messages are passed along the edges, one edge per
time step. At ﬁrst, the hidden state h0
i for each node Vi is
initialized with its own node feature. Then, at time step
k, message ﬂows through the kth temporal edge ek and
updates the hidden state hek of the end node of ek.

More speciﬁcally, message mk is ﬁrst computed basing
on the hidden state hsk of the start node of ek, and the edge
type tk:

xk = hsk ⊕ tk
mk = Wkxk + bk

(1)

(2)

where ⊕ denotes concatenation, matrix Wk and bias vector
bk are network parameters. The original message xk con-
tains information from the start node of ek and edge ek itself,
which are then transformed into a vector embedding using
Wk and bk.

After receiving the message, the end node of ek updates
its hidden state hek by aggregating information from the
incoming message and its previous state. Formally, hek is
updated according to:

where network parameters U , Z, R are matrices, while b1
and b2 are bias vectors.

Readout phase. After successively traversing all the edges
in G, we extract the feature for G by reading out the ﬁnal
hidden states of all nodes. Let hT
i be the ﬁnal hidden state
of the ith node, we ﬁnd that the differences between the
ﬁnal hidden state hT
i are
informative in the vulnerability detection task. Therefore,
we consider to generate the graph feature Gr by

i and the original hidden state h0

si = hT
i ⊕ h0
i
gi = sof tmax(W (2)
oi = sof tmax(W (2)
|V |
(cid:88)

o

g

Gr = F C(

oi (cid:12) gi)

(tanh(b(1)
(tanh(b(1)

g + W (1)
o + W (1)

g si)) + b(2)
g )
o si)) + b(2)
o )

(5)

(6)

(7)

(8)

i=1

where ⊕ denotes concatenation, and (cid:12) denotes element-
wise product. Wj, b(1)
, with subscript j ∈ {g, o}
are network parameters.

, and b(2)

j

j

Vulnerability detection by combining Pr and Gr. After
obtaining the security pattern feature Pr and the contract
graph feature Gr, we combine them to compute the ﬁnal
label ˆy ∈ (0, 1), indicating whether the function under test
has the speciﬁc vulnerability. To this end, we ﬁrst ﬁlter Pr
and Gr using a convolution layer and a max pooling layer,
then we concatenate the ﬁltered features and pass them to a
network consisting of 3 fully connected layers and a sigmoid
layer. The process can be formulated as:

Xr = ψ(Pr) ⊕ ψ(Gr)
ˆy = sigmoid(F C(Xr))

(9)

(10)

The convolutional layer learns to assign different weights
to different elements of the semantic vector, while the max
pooling layer highlights the signiﬁcant elements and avoids
overﬁtting. The fully connected layer and the non-linear
sigmoid layer produce the ﬁnal estimated label ˆy.

5 EXPERIMENTS

ˆhek = tanh(U mk + Zhek + b1)
(cid:48)
ek = sof tmax(Rˆhek + b2)
h

(3)

(4)

In this section, we empirically evaluate our proposed meth-
ods on all the Ethereum smart contracts that have source
code veriﬁed by Etherscan [49], as well as on all the available

FC Layer andSigmoidReadout phaseConvolution and PoolingXr : mergedfeaturehigh-dimfeaturesMessage propagation phaseContract graphSecurity patternsVulnerability? (1 or 0)......FC.olgl(          )∑i =1| C |GrPrXrφ(x1, x2, x3)FNNC1C3e3e1e2C2FilterFilterIEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

8

smart contracts on another blockchain platform VNT Chain
[50]. We seek to answer the following research questions:
• RQ1: Can the proposed method effectively detect the
reentrancy, inﬁnite loop, and timestamp dependence vul-
nerabilities? How are its accuracy, precision, recall, and
F1 score performance against the state-of-the-art conven-
tional vulnerability detection approaches?

• RQ2: Is our proposed method useful for detecting new
types of vulnerabilities, e.g., sharing-variable reentrancy,
which is difﬁcult for existing methods?

• RQ3: Can the proposed method outperform other neural

network-based methods?

• RQ4: How do the proposed security pattern, graph normal-
ization, message propagation modules, and different network
layers in CGE affect the performance of the proposed
method?

Next, we ﬁrst present the experimental settings, followed by
answering the above research questions one by one.

5.1 Experimental Settings

Datasets. We conducted experiments on two real-world
smart contract datasets, namely ESC (Ethereum Smart Con-
tracts) and VSC (VNT chain Smart Contracts), which are
collected from Ethereum and VNT Chain platforms, re-
spectively. Experiments for reentrancy and timestamp de-
pendence vulnerabilities are conducted on ESC, while the
inﬁnite loop vulnerability is evaluated on VSC.

• The ESC dataset consists of 307,396 smart contract
functions from 40,932 smart contracts in Ethereum [51].
Among the functions, around 5,013 functions possess at
least one invocation to call.value, making them poten-
tially affected by the reentrancy vulnerability. Around
4,833 functions contain the block.timestamp statement,
making them susceptible to the timestamp dependence
vulnerability. Around 56,800 functions contain for or
while loop statements.

• The VSC dataset contains 13, 761 functions, which are
collected from all the available 4, 170 smart contracts
in the VNT Chain network [50]. VNT Chain is an
experimental public blockchain platform proposed by
companies and universities from Singapore, China, and
Australia. The VNT Chain runs smart contracts written
in Class C language.
Implementation details. All the experiments are con-
ducted on a computer equipped with an Intel Core i7
CPU at 3.7GHz, a GPU at 1080Ti, and 32GB of Memory.
Our vulnerability detection system consists of three main
components: the auto CodeExtractor tool for extracting the
security patterns and contract graphs from the source code;
the Normalization tool for normalizing contract graphs; the
CGE network that outputs results by combining pattern
feature and graph feature. The CodeExtractor and Normal-
ization tools are implemented with Python, while the CGE
network is implemented with TensorFlow. The implementa-
tions of our vulnerability detection system are available at
https://github.com/Messi-Q/GPSCVulDetector.

Parameter settings. The adam optimizer is employed
in the CGE network. We apply a grid search to ﬁnd out
the best settings of hyper-parameters: the learning rate l is
tuned amongst {0.0001, 0.0005, 0.001, 0.002, 0.005, 0.01}, the

dropout rate d is searched in {0.1, 0.2, 0.3, 0.4, 0.5}, and
batch size β in {8, 16, 32, 64, 128}. To prevent overﬁtting,
we tuned the L2 regularization λ in {10−6, 10−5, 10−4, 10−3,
10−2, 10−1}. Without special mention in texts, we report the
performance of all neural network models with following
default setting: 1) l = 0.002, 2) d = 0.2, 3) β = 32, and 4)
λ = 10−4. For each dataset, we randomly select 80% of them
as the training set and the other 20% as the testing set for
several times, and report the averaged result. The ground
truth labels for contract functions are provided by experts.

5.2 Comparison with State-of-the-art Existing Methods
(RQ1)

In this section, we benchmark our proposed method
against existing non-deep-learning vulnerability detection
approaches, which include:
• Oyente [8]: A well-known symbolic veriﬁcation tool for
smart contract vulnerability detection, which performs
symbolic execution on the CFG (control ﬂow graph) to
check vulnerable patterns.

• Mythril [52]: A security analysis method, which uses
concolic analysis, taint analysis, and control ﬂow checking
to detect smart contract vulnerabilities.

• Smartcheck [16]: An extensible static analysis tool for

discovering smart contract code vulnerabilities.

• Securify [18]: A formal-veriﬁcation based tool for detect-
ing Ethereum smart contract bugs, which checks compli-
ance and violation patterns to ﬁlter false positives.

• Slither [53]: A static analysis framework designed to ﬁnd
issues in Ethereum smart contracts by converting a smart
contract into an intermediate representation of SlithIR.
Comparison on reentrancy vulnerability detection.
First, we compare our CGE approach with the ﬁve existing
methods on the reentrancy vulnerability detection task. The
performance of different methods is presented in the left
of Table 2, where metrics of accuracy, recall, precision, and F1
score are engaged. We would like to highlight that all metrics
are computed over only the susceptible smart contract func-
tions having invocation(s) to call.value, i.e., the functions that
may be infected with the reentrancy vulnerability. Functions
with no call.value invocation are known to be immune to
reentrancy vulnerability and is trivial to be handled (using
purely keyword matching), thus we do not involve those
functions in the calculation to better investigate the prob-
lem. From the quantitative results of Table 2, we have the
following observations. First, we ﬁnd that conventional non-
deep-learning methods have not yet achieved a satisfactory
accuracy on the reentrancy vulnerability detection task, e.g.,
the state-of-the-art method (i.e., Slither) yields a 77.12%
accuracy. Second, our proposed method substantially out-
performs the existing methods on reentrancy vulnerability
detection. Speciﬁcally, CGE achieves a 89.15% accuracy,
gaining a 12.03% accuracy improvement over conventional
methods. The strong empirical evidences suggest the great
potential of combing graph neural networks with expert
patterns for reentrancy vulnerability detection.

By looking into the existing methods, we believe that
the reasons for the low precision and recall of conventional
methods are: (1) they heavily rely on simple and ﬁxed
patterns to detect vulnerabilities, e.g., Mythril checks whether
the call.value invocation is not followed by any internal function

IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

9

Methods

Smartcheck
Oyente
Mythril
Securify
Slither

Vanilla-RNN
LSTM
GRU
GCN

DR-GCN
TMP
CGE

Reentrancy (ESC dataset)

Timestamp dependence (ESC dataset)

Methods

Inﬁnite Loop (VSC dataset)

Acc(%)

Recall(%)

Precision(%)

F1(%) Acc(%)

Recall(%)

Precision(%)

F1(%)

Acc(%)

Recall(%)

Precision(%)

F1(%)

52.97
61.62
60.54
71.89
77.12

49.64
53.68
54.54
77.85

81.47
84.48
89.15

32.08
54.71
71.69
56.60
74.28

58.78
67.82
71.30
78.79

80.89
82.63
87.62

25.00
38.16
39.58
50.85
68.42

49.82
51.65
53.10
70.02

72.36
74.06
85.24

28.10
44.96
51.02
53.57
71.23

50.71
58.64
60.87
74.15

76.39
78.11
86.41

44.32
59.45
61.08
–
74.20

49.77
50.79
52.06
74.21

78.68
83.45
89.02

37.25
38.44
41.72
–
72.38

44.59
59.23
59.91
75.97

78.91
83.82
88.10

39.16
45.16
50.00
–
67.25

51.91
50.32
49.41
68.35

71.29
75.05
87.41

38.18
41.53
45.49
–
69.72

45.62
54.41
54.15
71.96

74.91
79.19
87.75

Jolt
PDA
SMT
Looper
–

Vanilla-RNN
LSTM
GRU
GCN

DR-GCN
TMP
CGE

42.88
46.44
54.04
59.56
–

49.57
51.28
51.70
64.01

68.34
74.61
83.21

23.11
21.73
39.23
47.21
–

47.86
57.26
50.42
63.04

67.82
74.32
82.29

38.23
42.96
55.69
62.72
–

42.10
44.07
45.00
59.96

64.89
73.89
81.97

28.81
28.26
45.98
53.87
–

44.79
49.80
47.55
61.46

66.32
74.10
82.13

TABLE 2 Performance comparison in terms of accuracy, recall, precision, and F1 score. A total of sixteen methods
are investigated in the comparison, including state-of-the-art vulnerability detection methods, neural network-based
alternatives, DR-GCN, TMP, and CGE. ‘–’ denotes not applicable.

call to detect reentrancy, and (2) the rich data dependencies
and control dependencies within smart contract code are not
characterized with ﬁne-grained details in these methods.

Comparison on timestamp dependence vulnerability
detection. We further compare the proposed CGE with the
ﬁve methods on the timestamp dependence vulnerability
detection task. The comparison results are demonstrated
in the middle of Table 2. The state-of-the-art conventional
method (i.e., Slither) has obtained a 74.20% accuracy on
timestamp dependence vulnerability detection, which is
quite low. This may stem from the fact that most of exist-
ing methods detect timestamp dependence vulnerability by
crudely checking whether there is block.timestamp statement
in the function. Moreover, in consistent with the results on
reentrancy vulnerability detection, CGE keeps delivering
the best performance in terms of all the four metrics. In
particular, CGE gains a 14.82% accuracy improvement over
state-of-the-art conventional methods.

Comparison on inﬁnite loop vulnerability detection.
We also evaluated our methods on the inﬁnite loop vul-
nerability. Speciﬁcally, we compare our methods against
available inﬁnite loop detection methods including:
• Jolt [54]: The tool detects inﬁnite loop bugs by monitoring

the program state of two consecutive loop iterations.

• SMT [55]: An algorithm that relies on satisﬁability mod-
ulo theories for automated detection of inﬁnite loop bugs.
• PDA [56]: A method that performs program path-based

checking for inﬁnite loop detection.

• Looper [57]: Loop detection based on symbolic execution.
Quantitative results are illustrated in the right of Ta-
ble 2. From the table, we see that CGE consistently and
signiﬁcantly outperforms other methods on the inﬁnite loop
vulnerability detection task. In particular, CGE achieves a
83.21% accuracy and a 82.13% F1 score. In contrast, state-
of-the-art detection tools Looper are 59.56% and 53.87%,
and TMP are 74.61% and 74.10%. The improvements may
come from the fact that we consider key variables and rich
dependencies between program elements in smart contracts.
We further visualize the quantitative results of Table 2
in Figs. 6(a), (b), and (c). Speciﬁcally, Fig. 6(a) and Fig. 6(b)
present comparison results of reentrancy vulnerability de-
tection and timestamp dependence vulnerability detection,
respectively. The 7 rows (in different colors) from front to
back denote methods Smartcheck, Oyente, Mythril, Securify,
Slither, TMP, and CGE, respectively. For each row in the
ﬁgures, accuracy, recall, precision, and F1 score are respectively

demonstrated from left to right. Fig. 6(c) shows comparison
results of inﬁnite loop vulnerability detection, where the 6
rows from front to back denote Jolt, PDA, SMT, Looper, TMP,
and CGE methods, respectively. We can clearly observe that
CGE outperforms existing methods by a large margin.

5.3 A Case Study Towards Better Understanding of the
Reasons Behind the Results (RQ2)

In this subsection, we present an interesting case of smart
contract vulnerabilities, which may bring new insights into
the abilities of the studied methods. Particularly, we inves-
tigate a new type of reentrancy vulnerability, i.e., sharing-
variable reentrancy. To our knowledge, most existing meth-
ods cannot precisely detect such vulnerabilities.

Besides classical reentrancy introduced in Fig. 1 and
section 3, a reentrancy attack is also possible when a transfer
function shares internal variables with another function,
which we deﬁne as sharing-variable reentrancy.

In Fig. 7, we illustrate a real-world sharing-variable
reentrancy example, where the Malicious contract plays an
attack role against the Vulnerable contract. More speciﬁcally,
contract Vulnerable contains two functions: getBonusWith-
draw and withdrawAll. Function withdrawAll allows a user to
withdraw all her rewards, while function getBonusWithdraw
allows a user to withdraw all her rewards together with a
0.1 Ether bonus for each new user.

Attack. As demonstrated in Fig. 7, contract Malicious
ﬁrst uses its attack function to call the getBonusWithdraw
function of contract Vulnerable (step 1). As getBonusWithdraw
invokes the withdrawAll function (Vulnerable, line 6) to send
the rewards and bonus to Malicious (step 2). This will
automatically trigger the fallback function of Malicious (step
3), where Malicious invokes getBonusWithdraw again to steal
money (step 4). Since the bonus ﬂag Bonus[msg.sender] has
yet been set to true, Vulnerable believes Malicious has not got
the new user bonus yet and thus gives 0.1 Ether bonus again
to Vulnerable (Vulnerable, line 5), then function withdrawAll is
re-entered to withdraw the 0.1 Ether illegal bonus (step 5).
Malicious actually invokes getBonusWithdraw 9 times (Mali-
cious, line 9) in its fallback function to steal 1 Ether.

Underlying issue. This example reveals that although
in the withdrawAll function, contract Vulnerable updates
the user balance (i.e., Reward) before money transfer, Ma-
licious can still be attacked. The novel attack utilizes the
shared variable (Reward) to steal money. Although with-
drawAll function itself is safe, the malicious contract may

IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

10

(a) Reentrancy comparison of tools

(b) Timestamp comparison of tools

(c) Inﬁnite loop comparison of tools

(d) Reentrancy comparison of net-
works

(e) Timestamp comparison of net-
works

(f) Inﬁnite loop comparison of net-
works

Fig. 6 Visuallization of the quantitative results in Table 2: (a) & (d) present comparison results of reentrancy
vulnerability detection, while (b) & (e) present comparison results of timestamp dependence detection, (c) & (f)
show comparison results of inﬁnite loop vulnerability detection. In (a) & (b), the 7 rows from front to back denote the
Smartcheck, Oyente, Mythril, Securify, Slither, TMP, and CGE methods, respectively. In (c), the 6 rows from front to
back denote the Jolt, PDA, SMT, Looper, TMP, and CGE methods, respectively. In (d) & (e) & (f), the 7 rows from front
to back denote the Vanilla-RNN, LSTM, GRU, GCN, DR-GCN, TMP, and CGE methods, respectively. For each row in
the ﬁgures, accuracy, recall, precision, and F1 score are respectively demonstrated from left to right.

call getBonusWithdraw to modify the shared variable Reward
to enable attacks.

Unfortunately, such kind of attacks cannot yet be de-
tected by existing methods. We empirically checked the
Vulnerable contract using the state-of-the-art tools includ-
ing Oyente [8], Securify [18], Smartcheck [16], Slither [53],
and Mythril [52], and manually inspected their generated
reports. Oyente, Smartcheck, Slither, and Mythril fail to
identify the reentrancy bug, whereas Security presents a
lot of warnings all at the wrong places and misses the
sharing-variable reentrancy vulnerability as well. In con-
trast, CGE successfully detects the vulnerability. These evi-
dences reveal that the underlying detection rules of existing
reentrancy vulnerability detection methods indeed can be
cheated by the sharing variable trick and some vulnerability
patterns are hard to be covered. The current rules check
only the user balance variable that is directly related to the
call.value invocation, while ignoring dependencies between
variables, e.g., other variables may affect the user balance
variable. In this regard, an essential highlight of our method
is the capability of capturing data dependencies between
critical variables.

5.4 Comparison with Neural Network-based Methods
(RQ3)

We further compare our methods with other neural network
alternatives to seek out which neural network architectures
could succeed in the smart contract vulnerability detection
task. The compared methods are summarized below.
• Vanilla-RNN [58]: A two-layer recurrent neural network,
which takes the code sequence as input and evolves its
hidden states recurrently to capture the sequential pattern
lying in the code.

Fig. 7 A real-world smart contract with the sharing-
variable reentrancy vulnerability.

• LSTM [59]: The most widely used recurrent neural net-
work for processing sequential data. LSTM is short for
long short term memory, which recurrently updates the
cell state upon successively reading the code sequence.
• GRU [60]: The gated recurrent unit, which uses gating

mechanisms to handle the code sequence.

• GCN [37]: Graph convolutional network that takes the
contract graph as input and implements layer-wise con-
volution on the graph using graph Laplacian.

• DR-GCN [20]: The degree-free graph convolutional net-
work, which increases the connectivity of nodes and
removes the diagonal node degree matrix.

• TMP [20]: The temporal message propagation network,
which learns the contract graph feature by ﬂowing in-
formation along the edges successively following their
temporal order. The ﬁnal graph feature is used for vul-
nerability prediction.

For a feasible comparison, Vanilla-RNN, LSTM, and
GRU are fed with the contract function code sequence, rep-
resented as vectors. GCN, DR-GCN, and TMP are presented

AccuracyRecallPrecisionF1SmartcheckOyenteMythrilSecurifySlitherTMPCGE%20406080100AccuracyRecallPrecisionF1SmartcheckOyenteMythrilSecurifySlitherTMPCGE%20406080100AccuracyRecallPrecisionF1JoltPDASMTLooper--TMPCGE%20406080100AccuracyRecallPrecisionF1Vanilla-RNNLSTMGRUGCNDR-GCNTMPCGE%20406080100AccuracyRecallPrecisionF1Vanilla-RNNLSTMGRUGCNDR-GCNTMPCGE%20406080100AccuracyRecallPrecisionF1Vanilla-RNNLSTMGRUGCNDR-GCNTMPCGE%2040608010012345678910111213contract	Vulnerable{				...				function		getBonusWithdraw(){								require(!Bonus[msg.sender]);									Reward[msg.sender]	+=	0.1	ether;								withdrawAll(msg.sender);								Bonus[msg.sender]	=	true;				}				function		withdrawAll()	{								unit	amount	=	Reward[msg.sender];								Reward[msg.sender]	=	0;								require(msg.sender.call.value(amount	)());				}}	contract	Malicious{				address	vul_add=01a5f...43;						...				function		attack()	{														vul_add.getBonusWithdraw();					}				function		()	payable{									count++;											if	(count	<	10)	{													vul_add.getBonusWithdraw();         }				}}	123451234567891011121314IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

11

with the normalized graph extracted from the source code
and are required to detect the corresponding vulnerabilities.
We illustrate the results of different models in terms
of accuracy, recall, precision, and F1 score in Table 2, while
Figs. 6(d), (e), and (f) further visualize the results. Interest-
ingly, experimental results show that Vanilla-RNN, LSTM,
and GRU perform relatively worse than the state-of-the-
art conventional (non-deep-learning) methods. In contrast,
graph neural networks GCN, DR-GCN, and TMP, which
are capable of handling graphs, achieve signiﬁcantly bet-
ter results than conventional methods. This suggests that
blindly treat the source code as a sequence is not suitable for
the vulnerability detection task, while modeling the source
code into graphs and adopting graph neural networks is
promising. We conjecture that processing code sequentially
loses valuable information from smart contract code since
they ignore the structural information of contract programs,
such as the data-ﬂow and invocation relationships. The
accuracies of GCN and DR-GCN are lower than TMP, this
may due to the fact that GCN and DR-GCN fail to capture
the temporal information induced by data ﬂow and control
ﬂow, which is explicitly considered in TMP using ordered
edges. Further, we attribute the improved performance of
CGE over TMP to that TMP does not consider known
security patterns and ignores key variables.

5.5 Ablation Study (RQ4)

By default, CGE adopts the graph normalization module to
highlight the core nodes in the contract graph, it is interesting
to study the effect of removing this module. Moreover,
CGE incorporates an expert pattern extraction module and
a message propagation module to aggregate information from
both security patterns and the contract graph. It is useful to
evaluate the contributions of the two modules by removing
them respectively from CGE. Finally, we are also interested
in exploring the effect of different network layers in CGE.
In what follows, we conduct experiments to study the four
aforementioned modules.

Effect of the graph normalization module. We removed
the graph normalization module (introduced in subsec-
tion 4.2.2) from CGE, and compared it with the default CGE.
The variant is denoted as CGE-WON, where WON is short
for without normalization. Quantitative results are summa-
rized in Table 3. We can observe that with the proposed
graph normalization phase, the performance of CGE is bet-
ter. For example, for reentrancy vulnerability detection task,
the CGE model obtains a 2.81% and 2.55% improvement in
terms of accuracy and F1 score, respectively.

Figs. 8(a) & (b) & (c) further plot the ROC curves of CGE
and CGE-WON. We adopt Receiver Operating Characteris-
tic (ROC) analysis to show the impact of the graph normal-
ization module. AUC (area under the curve) is used as the
measure for performance, the higher AUC the better per-
formance. Fig. 8(a) demonstrates that CGE performs better
on the reentrancy detection task, the AUC increases by 0.03
with the graph normalization module. On the timestamp
dependence detection task, CGE obtains a 0.03 improvement
in AUC (shown in Fig. 8(b)). On the inﬁnite loop detection
task, CGE gains a 0.04 improvement in AUC (shown in
Fig. 8(c)). In the ﬁgures, we also demonstrate the effect
of removing the graph normalization module of another

method, namely TMP. Similar ﬁndings are observed. The
experimental results suggest that program elements should
contribute distinctly to vulnerability detection rather than
having equal contributions.

Effect of the security pattern module. To evaluate the
effect of our proposed security pattern module, we analyze
the performance of CGE with and without the security pat-
tern module. Towards this, we modify CGE by removing the
expert pattern extraction module, utilizing only the graph
feature for vulnerability learning and detection. This variant
is denoted as CGE-WOE, where WOE is short for without
expert pattern. The empirical ﬁndings are demonstrated in
Table 3, while the visual curves are illustrated in Fig. 8(d).
In Fig. 8(d), the red curve demonstrates the accuracy of CGE
over different epochs on the reentrancy vulnerability de-
tection. Obviously, we can observe that the performance of
CGE is consistently superior to CGE-WOE across all epochs,
revealing that incorporating security patterns is necessary
and important to improve the performance. Quantitative
results on all the three vulnerabilities, which are presented
in Table 3, further reconﬁrm the ﬁnding.

We also conduct experiments to extend other neural net-
works with expert patterns, and empirically compared these
methods with CGE. The results are illustrated in Table 4,
where ‘-EP’ denotes combining with expert patterns. We can
observe that neural networks combined with expert patterns
indeed achieve better results compared to their pure neural
network counterparts. For example, DR-GCN-EP gains a
4.92% accuracy improvement over DR-GCN in average,
and LSTM-EP obtains a 6.91% accuracy improvement over
LSTM. These results indicate the effectiveness of combining
neural networks with expert patterns. On the other hand,
the proposed method CGE consistently outperforms other
approaches including DR-GCN-EP. DR-GCN-EP ranks sec-
ond in the tested methods.

Effect of the contract graph feature extraction module.
We further investigate the impact of the contract graph fea-
ture extraction module in CGE by comparing it with its vari-
ant. Towards this, we remove the proposed contract graph
construction and temporal message propagation module,
while utilizing only the security pattern feature. The new
variant is denoted as CGE-WOG, namely CGE without
contract graph feature. Fig. 8(e) visualizes the results, where
the red curve demonstrates the accuracy of CGE over dif-
ferent epochs, while the blue curve shows the accuracy of
CGE-WOG. Clearly, the performance of CGE is consistently
better compared to its variant across all epochs. Quantitative
results are further presented in Table 3, where all the three
vulnerabilities are involved. The results, together with the
experimental results on CGE-WOE, suggest that the contract
graph feature contributes signiﬁcant performance gain in
CGE and leads to a higher gain than the security pattern
feature.

Effect of different feature fusion networks. When com-
bining security pattern features and contract graph features,
CGE uses a neural network with a convolution layer and
a max pooling layer followed by 3 fully connected layers
and a sigmoid layer. To verify this network architecture,
we also study ﬁve other alternatives. First, we replace the
convolution and max pooling layer with a fully connected
layer, which we denote as CGE(FC). We also try replacing

IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

12

Reentrancy

Timestamp dependence

Inﬁnite loop

Metrics

Acc(%)
Recall(%)
Precision(%)
F1(%)

CGE-WOG CGE-WOE

CGE-WON CGE

CGE-WOG CGE-WOE

CGE-WON CGE

CGE-WOG CGE-WOE

CGE-WON CGE

82.09
80.18
72.15
75.95

84.42
82.65
78.94
80.75

86.34
84.38
83.35
83.86

89.15
87.62
85.24
86.41

81.30
80.68
78.42
79.53

83.52
82.89
80.16
81.50

86.61
84.06
83.90
83.98

89.02
88.10
87.41
87.75

72.23
70.08
71.44
70.75

74.68
74.21
73.86
74.03

79.51
77.14
76.26
76.70

83.21
82.29
81.97
82.13

TABLE 3 Accuracy comparison between CGE and its variants on the three vulnerability detection tasks.

Variants

Vanilla-RNN-EP
LSTM-EP
GRU-EP
GCN-EP
DR-GCN-EP

CGE(LSTM)
CGE(FC)
CGE(1-FC)
CGE(2-FC)
CGE(AP)
CGE

Reentrancy

Timestamp dependence

Inﬁnite Loop

Acc(%)

Recall(%)

Precision(%)

F1(%) Acc(%)

Recall(%)

Precision(%)

F1(%) Acc(%)

Recall(%)

Precision(%)

F1(%)

56.06
60.15
62.08
80.96
85.14

86.74
87.64
88.54
88.89
88.02
89.15

60.24
72.26
75.01
81.05
84.12

85.18
85.74
86.12
86.47
85.92
87.62

58.21
58.68
60.13
76.84
79.38

82.85
82.97
83.80
84.51
83.45
85.24

59.20
64.77
66.75
78.89
81.68

84.00
84.33
84.94
85.48
84.67
86.41

54.58
59.82
61.22
79.32
83.74

87.92
88.12
86.62
87.05
85.25
89.02

49.65
63.38
64.18
79.94
84.02

85.08
87.98
87.82
84.96
85.16
88.10

59.35
58.28
58.45
73.65
80.59

87.13
85.04
81.73
85.02
81.84
87.41

54.07
56.29
61.18
76.67
82.27

86.09
86.49
84.66
84.98
83.47
87.75

54.72
56.52
57.09
70.06
74.36

79.18
80.62
81.43
81.82
79.53
83.21

52.62
59.98
60.54
69.81
73.08

78.25
78.96
81.25
81.76
78.58
82.29

49.94
49.75
49.81
64.29
69.45

76.80
77.24
80.98
80.54
76.94
81.97

51.24
54.39
54.65
66.94
71.22

77.52
78.09
81.11
81.15
77.75
82.13

TABLE 4 Upper: Performance comparison between CGE and other neural networks combined with expert patterns.
‘-EP’ denotes combining with expert patterns. Lower: Comparison with other feature fusion network architectures.

(a) Reentrancy

(b) Timestamp dependence

(c) Inﬁnite loop

(d) Accuracy study on the security pattern module

(e) Accuracy study on the graph feature module

Fig. 8 Curves comparison: (a), (b), and (c) present the ROC analysis of graph normalization module for TMP, CGE, and
their variants on the three vulnerability detection tasks, where AUC stands for area under the curve. In (d), the two
curves study the effect of removing the security pattern extraction module, while (e) presents the study on removing
the contract-graph feature extraction module.

them with an LSTM layer, which we term as CGE(LSTM).
Then, we keep the convolution and max pooling layer, but
change the 3 fully connected layers to 1 or 2 fully connected
layers. The two variants are denoted as CGE(1-FC) and
CGE(2-FC), respectively. Finally, we explore replacing the
max pooling layer with an average pooling layer, namely
CGE(AP), while keeping other layers ﬁxed. The empirical
results are illustrated in Table 4. The results reveal that: 1)
RNN architectures such as LSTM are not suitable for the
feature fusion task, 2) the default setting of CGE yields
better results than the ﬁve alternatives, and 3) using average
pooling or changing the number of fully connected layers
leads to a slight performance drop.

6 DISCUSSIONS

Specialty of our method in dealing with smart contracts.
Distinct from conventional programs that consume only
CPU resources, users have to pay a fee for executing each
line of smart contract code. The fee is approximately pro-
portional to how much code needs to run and is referred to
as gas. Therefore, in the proposed method, we studied the
inﬁnite loop vulnerability since an inﬁnite loop will consume
a lot of gas but all the gas is consumed in vain. This is
because the inﬁnite loop is unable to change any state (any
execution that runs out of gas is aborted). Moreover, the
function libraries of the smart contracts and other program
languages are quite different. For example, call.value and

block.timestamp are unique and specially designed in smart
contracts. We implement an open-sourced tool to analyze
the speciﬁc syntax of smart contract statements. We also use
core nodes to symbolize invocations and variables closely
related to a speciﬁc vulnerability, and represent other vari-
ables and invocations as normal nodes. We would like to
point out that there is a unique fallback mechanism in
smart contracts, which is different from other programming
languages. In the contract graph, we build a fallback node
to stimulate the fallback function of a virtual attack contract,
which can interact with the function under test.

Discussions on the contract graph. Existing efforts
adopted the control ﬂow graph, code property graph, and ab-
stract syntax tree to represent program code. The differences
between them and our contract graph can be summarized
as: (i) Control ﬂow graph utilizes a node to model a basic
block, i.e. a straight-line piece of code without any jumps, and
uses edges to represent jumps [61]. They focus mainly
on execution path jumps and tend to consider each node
as of equal importance. (ii) Code property graph [62, 63]
models statements as nodes, and represents the control
ﬂow between statements as edges. (iii) Abstract syntax tree
[64, 65] adopts a tree representation of the abstract syntactic
structure of source code, which relies on a tree structure
and has difﬁculties in fully characterizing the rich seman-
tic information between nodes. (iv) In our contract graph,
nodes are used to model variables and invocations related

0.00.20.40.60.81.0False Positive Rate0.00.20.40.60.81.0True Positive RateTMP-WON (AUC = 0.81)TMP (AUC = 0.86)CGE-WON (AUC = 0.88)CGE (AUC = 0.91)0.00.20.40.60.81.0False Positive Rate0.00.20.40.60.81.0True Positive RateTMP-WON (AUC = 0.79)TMP (AUC = 0.82)CGE-WON (AUC = 0.89)CGE (AUC = 0.92)0.00.20.40.60.81.0False Positive Rate0.00.20.40.60.81.0True Positive RateTMP-WON (AUC = 0.70)TMP (AUC = 0.75)CGE-WON (AUC = 0.81)CGE (AUC = 0.85)050100150Epoch0.00.20.40.60.81.0AccuracyCGE-WOECGE050100150Epoch0.00.20.40.60.81.0AccuracyCGE-WOGCGEIEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

13

to a speciﬁc vulnerability and are classiﬁed into different
categories, i.e. core nodes, normal nodes, and fallback nodes. We
also explicitly model the order of the edges following their
temporal order in the code and consider the speciﬁc fallback
mechanism of the smart contracts.

7 CONCLUSION AND FUTURE WORK

In this paper, we have proposed a fully automated approach
for smart contract vulnerability detection at the function
level. In contrast to existing approaches, we combine both
expert patterns and contract graph semantics, consider rich
dependencies between program elements, and explicitly
model the fallback mechanism of smart contracts. We also
explore the possibility of using novel graph neural networks
to learn the graph feature from the contract graph, which
contains rich control- and data- ﬂow semantics. Extensive
experiments are conducted, showing that our method sig-
niﬁcantly outperforms the state-of-the-art vulnerability de-
tection tools and other neural network-based methods. We
believe our work is an important step towards revealing
the potential of combining deep learning with conventional
patterns on smart contract vulnerability detection tasks. For
future work, we will investigate the possibility of extending
this method to smart contracts that have only bytecode, and
explore this architecture on more other vulnerabilities.

ACKNOWLEDGMENTS

This paper was supported by the Natural Science Founda-
tion of Zhejiang Province, China (Grant No. LQ19F020001),
the National Natural Science Foundation of China (No.
61902348, 61802345), and the Research Program of Zhejiang
Lab (2019KD0AC02).

REFERENCES
[1] T. T. A. Dinh, J. Wang, G. Chen, R. Liu, B. C. Ooi, and K.-L. Tan,
“Blockbench: A framework for analyzing private blockchains,” in
ICMD, 2017, pp. 1085–1100.

[2] D. Yaga, P. Mell, N. Roby, and K. Scarfone, “Blockchain technology

overview,” arXiv preprint arXiv:1906.11078, 2019.

[3] C. Badertscher, U. Maurer, D. Tschudi, and V. Zikas, “Bitcoin as
a transaction ledger: A composable treatment,” in Annual Interna-
tional Cryptology Conference, 2017, pp. 324–356.

[4] M. Dhawan, “Analyzing safety of smart contracts,” in Proceedings

of the NDSS, 2017, pp. 16–17.

[5] M. Tsikhanovich, M. Magdon-Ismail, M. Ishaq, and V. Zikas,
“Pd-ml-lite: Private distributed machine learning from lighweight
cryptography,” arXiv preprint arXiv:1901.07986, 2019.

[6] T. T. A. Dinh, R. Liu, M. Zhang, G. Chen, B. C. Ooi, and J. Wang,
“Untangling blockchain: A data processing view of blockchain
systems,” IEEE Transactions on Knowledge and Data Engineering,
vol. 30, no. 7, pp. 1366–1385, 2018.

[7] L. S. Sankar, M. Sindhu, and M. Sethumadhavan, “Survey of
consensus protocols on blockchain applications,” in Proceedings of
the ICACCS, 2017, pp. 1–5.

[8] L. Luu, D.-H. Chu, H. Olickel, P. Saxena, and A. Hobor, “Making

smart contracts smarter,” in CCS, 2016, pp. 254–269.

[9] A. M. Antonopoulos and G. Wood, Mastering ethereum: building

smart contracts and dapps, 2018.

[10] A. Bahga and V. K. Madisetti, “Blockchain platform for industrial
internet of things,” Journal of Software Engineering and Applications,
vol. 9, no. 10, p. 533, 2016.

[11] V. Buterin et al., “A next-generation smart contract and decentral-

ized application platform,” white paper, vol. 3, p. 37, 2014.

[12] J. Kokina, R. Mancha, and D. Pachamanova, “Blockchain: Emer-
gent industry adoption and implications for accounting,” Journal
of Emerging Technologies in Accounting, vol. 14, no. 2, pp. 91–100,
2017.

[13] “The dao smart contract,” Website, 2016, http://etherscan.io/

address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413.

[14] “King of the ether,” Webiste, 2016, https://www.kingoftheether.

com/postmortem.html.

[15] “An in-depth look at the parity multisig bug,” Website, 2017, http:

//hackxingdistributed.com/2017/07/22/deep-dive-parity-bug.

[16] S. Tikhomirov, E. Voskresenskaya, I. Ivanitskiy, R. Takhaviev,
E. Marchenko, and Y. Alexandrov, “Smartcheck: Static analysis of
ethereum smart contracts,” in WETSEB, 2018, pp. 9–16.

[17] B. Jiang, Y. Liu, and W. Chan, “Contractfuzzer: Fuzzing smart
contracts for vulnerability detection,” in Proceedings of the ASE,
2018, pp. 259–269.

[18] P. Tsankov, A. Dan, D. Drachsler-Cohen, A. Gervais, F. Buenzli,
and M. Vechev, “Securify: Practical security analysis of smart
contracts,” in Proceedings of the CCS, 2018, pp. 67–82.

[19] P. Qian, Z. Liu, Q. He, R. Zimmermann, and X. Wang, “Towards
automated reentrancy detection for smart contracts based on
sequential models,” IEEE Access, vol. 8, pp. 19 685–19 695, 2020.

[20] Y. Zhuang, Z. Liu, P. Qian, Q. Liu, X. Wang, and Q. He, “Smart
contract vulnerability detection using graph neural network,” in
Proceedings of the IJCAI-20, 7 2020, pp. 3283–3290.

[21] W. J. Tann, X. J. Han, S. S. Gupta, and Y. Ong, “Towards safer smart
contracts: A sequence learning approach to detecting vulnerabili-
ties,” CoRR, 2018.

[22] K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Gollamudi,
G. Gonthier, N. Kobeissi, N. Kulatova, A. Rastogi, T. Sibut-Pinote,
N. Swamy et al., “Formal veriﬁcation of smart contracts: Short
paper,” in Proceedings of the 2016 ACM Workshop on Programming
Languages and Analysis for Security, 2016, pp. 91–96.

[23] I. Grishchenko, M. Maffei, and C. Schneidewind, “A semantic
framework for the security analysis of ethereum smart contracts,”
in International Conference on Principles of Security and Trust, 2018,
pp. 243–269.

[24] E. Hildenbrandt, M. Saxena, N. Rodrigues, X. Zhu, P. Daian,
D. Guth, B. Moore, D. Park, Y. Zhang, A. Stefanescu et al., “Kevm:
A complete formal semantics of the ethereum virtual machine,” in
CSF, 2018, pp. 204–217.

[25] Y. Hirai, “Deﬁning the ethereum virtual machine for interactive
theorem provers,” in International Conference on Financial Cryptog-
raphy and Data Security, 2017, pp. 520–535.

[26] I. Nikoli´c, A. Kolluri, I. Sergey, P. Saxena, and A. Hobor, “Finding
the greedy, prodigal, and suicidal contracts at scale,” in Annual
Computer Security Applications Conference, 2018, pp. 653–663.
[27] S. Kalra, S. Goel, M. Dhawan, and S. Sharma, “Zeus: Analyzing

safety of smart contracts,” in NDSS, 2018.

[28] C. Liu, H. Liu, Z. Cao, Z. Chen, B. Chen, and B. Roscoe, “Reguard:
ﬁnding reentrancy bugs in smart contracts,” in Proceedings of the
ICSE, 2018, pp. 65–68.

[29] M. Rodler, W. Li, G. O. Karame, and L. Davi, “Sereum: Protecting
existing smart contracts against re-entrancy attacks,” in Proceedings
of the NDSS, 2019.

[30] W. Wang, J. Song, G. Xu, Y. Li, H. Wang, and C. Su, “Contractward:
Automated vulnerability detection models for ethereum smart
contracts,” TNSE, 2020.

[31] N. Atzei, M. Bartoletti, and T. Cimoli, “A survey of attacks on
ethereum smart contracts (sok),” in International Conference on
Principles of Security and Trust, 2017, pp. 164–186.

[32] M. Zhang, Z. Cui, M. Neumann, and Y. Chen, “An end-to-end
deep learning architecture for graph classiﬁcation,” in AAAI, 2018.
[33] H. Wang, P. Zhang, X. Zhu, I. W.-H. Tsang, L. Chen, C. Zhang, and
X. Wu, “Incremental subgraph feature selection for graph clas-
siﬁcation,” IEEE Transactions on Knowledge and Data Engineering,
vol. 29, no. 1, pp. 128–142, 2016.

[34] Y. Zhou, S. Liu, J. Siow, X. Du, and Y. Liu, “Devign: Effective
vulnerability identiﬁcation by learning comprehensive program
semantics via graph neural networks,” in Advances in Neural
Information Processing Systems, 2019, pp. 10 197–10 207.

[35] M. Allamanis, M. Brockschmidt, and M. Khademi, “Learning to
represent programs with graphs,” in International Conference on
Learning Representations (ICLR), 2018.

[36] H. Cai, V. W. Zheng, and K. C.-C. Chang, “A comprehensive sur-
vey of graph embedding: Problems, techniques, and applications,”
IEEE Transactions on Knowledge and Data Engineering, vol. 30, no. 9,
pp. 1616–1637, 2018.

[37] T. N. Kipf and M. Welling, “Semi-supervised classiﬁcation with

graph convolutional networks,” in Proceedings of the ICLR, 2017.

[38] M. Defferrard, X. Bresson, and P. Vandergheynst, “Convolutional

IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING

14

neural networks on graphs with fast localized spectral ﬁltering,”
in Advances in neural information processing systems, 2016, pp. 3844–
3852.

[39] X. Zhou, F. Shen, L. Liu, W. Liu, L. Nie, Y. Yang, and H. T.
Shen, “Graph convolutional network hashing,” IEEE transactions
on cybernetics, 2018.

[40] Y. Wei, X. Wang, L. Nie, X. He, R. Hong, and T.-S. Chua, “Mmgcn:
Multi-modal graph convolution network for personalized recom-
mendation of micro-video,” in Proceedings of the 27th ACM MM,
2019, pp. 1437–1445.

[41] R. Li, S. Wang, F. Zhu, and J. Huang, “Adaptive graph convolu-

tional neural networks,” in AAAI, 2018.

[42] A. Micheli, “Neural network for graphs: A contextual constructive
approach,” IEEE Transactions on Neural Networks, vol. 20, no. 3, pp.
498–511, 2009.

[43] P. Veliˇckovi´c, G. Cucurull, A. Casanova, A. Romero, P. Lio,
and Y. Bengio, “Graph attention networks,” arXiv preprint
arXiv:1710.10903, 2017.

[44] J. Zhang, X. Shi, J. Xie, H. Ma, I. King, and D.-Y. Yeung, “Gaan:
Gated attention networks for learning on large and spatiotemporal
graphs,” arXiv preprint arXiv:1803.07294, 2018.

[45] J. Gilmer, S. S. Schoenholz, P. F. Riley, O. Vinyals, and G. E. Dahl,
“Neural message passing for quantum chemistry,” in Proceedings
of the ICML, 2017, pp. 1263–1272.

[46] X. Xu, C. Liu, Q. Feng, H. Yin, L. Song, and D. Song, “Neural
network-based graph embedding for cross-platform binary code
similarity detection,” in CCS, 2017, pp. 363–376.

[47] S. Shen, S. Shinde, S. Ramesh, A. Roychoudhury, and P. Saxena,
“Neuro-symbolic execution: Augmenting symbolic execution with
neural constraints.” in Proceedings of the NDSS, 2019.

[48] R. A. Rossi, R. Zhou, and N. Ahmed, “Deep inductive graph
representation learning,” IEEE Transactions on Knowledge and Data
Engineering, 2018.

[49] “Etherscan,” Website, 2015, https://etherscan.io/.
[50] “Vntchain,” Website, 2018, https://github.com/vntchain/go-vnt.
https://github.com/ethereum/
[51] “Ethereum,” Website,

2015,

go-ethereum.

[52] B. Mueller, “A framework for bug hunting on the ethereum
blockchain,” Webiste, 2017, https://github.com/ConsenSys/
mythril.

[53] J. Feist, G. Grieco, and A. Groce, “Slither: a static analysis frame-

work for smart contracts,” in WETSEB, 2019, pp. 8–15.

[54] M. Carbin, S. Misailovic, M. Kling, and M. C. Rinard, “Detecting
and escaping inﬁnite loops with jolt,” in European Conference on
Object-Oriented Programming, 2011, pp. 609–633.

[55] M. Kling, S. Misailovic, M. Carbin, and M. Rinard, “Bolt: on-
demand inﬁnite loop escape in unmodiﬁed binaries,” ACM SIG-
PLAN Notices, vol. 47, no. 10, pp. 431–450, 2012.

[56] A. Ibing and A. Mai, “A ﬁxed-point algorithm for automated static
detection of inﬁnite loops,” in IEEE 16th International Symposium
on High Assurance Systems Engineering, 2015, pp. 44–51.

[57] J. Burnim, N.

Jalbert, C. Stergiou, and K. Sen, “Looper:
Lightweight detection of inﬁnite loops at runtime,” in Proceedings
of ASE, 2009, pp. 161–169.

[58] C. Goller and A. Kuchler, “Learning task-dependent distributed
representations by backpropagation through structure,” in Pro-
ceedings of ICNN, vol. 1, 1996, pp. 347–352.

[59] H. Sak, A. Senior, and F. Beaufays, “Long short-term memory
recurrent neural network architectures for large scale acoustic
modeling,” in Fifteenth annual conference of the international speech
communication association, 2014.

[60] J. Chung, C. Gulcehre, K. Cho, and Y. Bengio, “Empirical evalua-
tion of gated recurrent neural networks on sequence modeling,”
arXiv preprint arXiv:1412.3555, 2014.

[61] A. V. Phan, M. Le Nguyen, and L. T. Bui, “Convolutional neural
networks over control ﬂow graphs for software defect prediction,”
in 2017 IEEE 29th International Conference on Tools with Artiﬁcial
Intelligence (ICTAI).
IEEE, 2017, pp. 45–52.

[62] F. Yamaguchi, N. Golde, D. Arp, and K. Rieck, “Modeling and
discovering vulnerabilities with code property graphs,” in 2014
IEEE Symposium on Security and Privacy.
IEEE, 2014, pp. 590–604.
[63] S. Suneja, Y. Zheng, Y. Zhuang, J. Laredo, and A. Morari, “Learning
to map source code to software vulnerability using code-as-a-
graph,” arXiv preprint arXiv:2006.08614, 2020.

[64] L. Mou, G. Li, L. Zhang, T. Wang, and Z. Jin, “Convolutional
neural networks over tree structures for programming language
processing,” in Proceedings of the AAAI Conference on Artiﬁcial

Intelligence, vol. 30, no. 1, 2016.

[65] J. Zhang, X. Wang, H. Zhang, H. Sun, K. Wang, and X. Liu, “A
novel neural source code representation based on abstract syntax
tree,” in 2019 IEEE/ACM 41st International Conference on Software
Engineering (ICSE).
IEEE, 2019, pp. 783–794.

Zhenguang Liu is currently a professor of Zhe-
jiang Gongshang University. He had been a re-
search fellow in National University of Singapore
and A*STAR. He respectively received his Ph.D.
and B.E. degrees from Zhejiang University and
Shandong University, China. His research inter-
ests include smart contract security and mul-
timedia data analysis. Dr. Liu has served as
technical program committee member for con-
ferences such as ACM MM, CVPR, AAAI, IJCAI,
and ICCV, session chair of ICGIP, local chair of

KSEM, and reviewer for IEEE TVCG, IEEE TPDS, ACM TOMM, etc.

Peng Qian received his BSc degree in software
engineering from Yangtze University, MSc de-
gree in computer science from Zhejiang Gong-
shang University, in 2018 and 2021. He is cur-
rently pursuing a Ph.D. at Zhejiang University.
His research interests include blockchain secu-
rity, graph neural network, and deep learning.

Xiaoyang Wang received the BSc and MSc de-
grees in computer science from Northeastern
University, China, in 2010 and 2012, respec-
tively, and the PhD degree from the University
of New South Wales, Australia, in 2016. He is
a professor in Zhejiang Gongshang University,
Hangzhou, China. His research interest includes
query processing on massive graph data.

Yuan Zhuang received her PhD from the Col-
lege of Computer Science and Technology
(CCST), Jilin University, China. Her research
interests include blockchain security, machine
learning, big data processing and distributed
computing

Lin Qiu is a PhD candidate at the Department
of Information Systems and Analytics, National
University of Singapore, Singapore. Before that,
she obtained her bachelor degree from Xiamen
University, China. Her research interests lie in
deep learning, healthcare, and blockchain.

Xun Wang is currently a professor at the School
of Computer Science and Information Engineer-
ing, Zhejiang Gongshang University, China. He
received his BSc in mechanics, Ph.D. degrees
in computer science, all from Zhejiang Univer-
sity, China, in 1990 and 2006, respectively. His
research interests include intelligent information
processing and computer vision. He has pub-
lished over 100 papers in high-quality journals
and conferences. He is a member of the IEEE
and ACM, and a distinguished member of CCF.

