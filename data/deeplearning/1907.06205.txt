9
1
0
2

l
u
J

4
1

]
E
S
.
s
c
[

1
v
5
0
2
6
0
.
7
0
9
1
:
v
i
X
r
a

AUTOMATIC REPAIR AND TYPE BINDING OF UNDECLARED
VARIABLES USING NEURAL NETWORKS

A PREPRINT

Venkatesh Theru Mohan
Department of Computer Science
Iowa State University
venkytm@iastate.edu

Ali Jannesari
Department of Computer Science
Iowa State University
jannesar@iastate.edu

July 16, 2019

ABSTRACT

Deep learning had been used in program analysis for the prediction of hidden software defects using
software defect datasets, security vulnerabilities using generative adversarial networks as well as
identifying syntax errors by learning a trained neural machine translation on program codes. How-
ever, all these approaches either require defect datasets or bug-free source codes that are executable
for training the deep learning model. Our neural network model is neither trained with any defect
datasets nor bug-free programming source codes, instead it is trained using structural semantic de-
tails of Abstract Syntax Tree (AST) where each node represents a construct appearing in the source
code. This model is implemented to ﬁx one of the most common semantic errors, such as undeclared
variable errors as well as infer their type information before program compilation. By this approach,
the model has achieved in correctly locating and identifying 81% of the programs on prutor dataset
of 1059 programs with only undeclared variable errors and also inferring their types correctly in
80% of the programs.

Keywords Automatic Bug Repair, Undeclared Variables, Neural Networks, Type Binding

1

Introduction

In the recent decades, there had been some signiﬁcant contributions in the automation of program analysis tasks. Neu-
ral networks had been frequently used either for detection or generation tasks in programming language processing
similar to natural language processing. It had been employed in detecting software defects, as well as prediction of
errors by using software metrics [17].

There have been some state-of-art performances achieved by generative adversarial networks and neural ma-
chine translation systems on language translation tasks in Natural Language Processing (NLP) that led to the
deployment of these systems on error correction tasks in the programming source codes. Neural machine Translation
(NMT) in [14] builds and trains a single neural network model using a labelled set of paired examples that results in
translation from the input directly. They are end-to-end in the sense that they have the ability to learn the source text
directly by mapping them to the corresponding target text and uses an encoder-decoder(usually made up of Recurrent
Neural Networks (RNN) units) approach for applying the transformations where encoder consists of sequences of
source text and output consists of sequences of target text. Generative Adversarial Networks (GAN) trains a neural
network model to predict security vulnerabilities in [13] without the necessity of being a paired set of source domain
containing buggy codes and target domain consisiting of bug-free codes, instead being a bijection mapping. Generally,
in this labelled set of paired examples or unpaired examples, the neural network model is trained on the set of positive
examples where the mapping takes place between target sequences, made up of positive examples that are bug-free
and compiling without any errors and source sequences consisting of negative examples that contains bugs within
the code making the compilation to fail. In sequence-to-sequence learning systems such as NMT, it is ﬂexible to
train and learn the model with a labelled set of paired examples, but consider the scenario where there are no paired

 
 
 
 
 
 
A PREPRINT - JULY 16, 2019

examples, further to put it in a simpler context, consider a real-case scenario where some common syntax or semantic
errors are being committed by freshers or novice programmers working in a software industry or student submissions
of programming assignments in coding competitions and there are no positive or bug-free reference examples, then
learning becomes difﬁcult for neural network approaches and neural machine translation models.

In our model, there are no positive examples to train and focus is only on the negative buggy examples specif-
ically, the common semantic error caused due to undeclared variables which is often committed and unperceived
by the novice programmers. The model is instead trained based on the structural and semantic elements, that
is the non-terminal and terminal nodes of the programming source codes captured from the abstract syntax tree
representation. The type of the undeclared variables is also inferred by performing type binding using the semantic
elements of AST representation that provides about the type information of the variables thereby saving the compiler’s
time in performing the type binding of those undeclared variables. The comprehensive information of the ASTs,
the motive of Long Short-Term Memory (LSTM), detailed view of the training approach and implementation, the
generation approach and different scenarios where undeclared variables will be caused and possible cases of type
inference of them will be discussed in the upcoming sections of the paper.

2 Related Work

AST are the static intermediate model of a programming source code as discussed in [1] where the compiler’s analytic
front-end parses it, constructs the AST model eventually passing it to the compiler’s synthetic back-end to produce an
assembly code for a speciﬁc machine and also used for program analysis/transformation. Often low-level concrete
syntax tree representations have a complex structure and it is difﬁcult to characterize the semantics especially in the
poorly understood domains, so in [2], describes a transformation process to get a good abstract syntax representation
from low-level concrete speciﬁcation where modern tools rely on its ability to analyze, simulate and synthesize
programs easily in language processing.

In the past recent decades, deep learning had achieved various scales in text domain such as natural language
especially in neural machine translation tasks and used it successfully even for programming language processing
tasks as well. Some of the recent works that had achieved empiricial success on neural machine translation include
dialogue response generation, summarization and text generation tasks as explained in detail in [3], also NMT
tasks are very much useful in translation from one language to another like in [4] where NMT encoder-decoder
model had been implemented using word embedding along with byte-pair encoding method to develop an efﬁcent
translation mechanism from English-Tamil. The performance of such text generation tasks such as NMT is enhanced
with attention mechanism in [5] to automatically search for a context of a source text that is relevant for predic-
tion of target words and an ensemble model of global and local attention mechanism of [6] improving the performance.

Natural language generation having a discrete output space had also been implemented by generative adversar-
ial networks (introduced by [7]) on generating sentences from context-free grammars and probabilistic grammars
as shown in [8]. The quality of the text generation had been improvised by conditioning information on generated
samples to produce realistic natural looking sentences compared to maximum likelihood training procedures. Text
generation has also shown some encouraging results in [9] in which the discriminator of the GAN leaks its own
high-level features to the generator at each of the generator steps thus making the scalar guiding signal available
continuously throughout the generative process.

In [10], prediction of next tokens in the source code is implemented using LSTM neural networks where the
model trains and learns associated subsequent nodes for code completion, given a partial AST containing left subset
of nodes or semantic features with respect to a subtree. The efﬁciency of AST in extracting tokens and comparing
the source codes based on them and the use of deep learning in classifying duplicate/clone codes can be helpful
in software code maintenance as seen in [11] where maintaining duplicate codes for reuse in order to improve
productivity of programming becomes a burden when there are inconsistencies caused due to bug ﬁxes and program
modiﬁcations in the original code at multiple locations.

The signiﬁcance of AST representation of source code can further be noted in [12] where LSTM neural net-
works are leveraged to capture the long contextual relationships between semantic features to identify related code
elements in order to predict the software vulnerabilities which causes a security threat or makes the program buggy.
GAN approach is used in [13] for repairing vulnerabilities in source codes without any paired examples or bijections
by mapping from non-buggy source domain to buggy target domain and training the discriminator using the loss that
is generated between real examples and NMT-generated outputs from generator of desired output.

2

A PREPRINT - JULY 16, 2019

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

#include < s t d i o . h>
int main ( )
{

int
i , max , j , n , m, y ;
s c a n f ( ”%d %d ” ,&n ,&m) ;
for ( i = 1 ; i <=n ; i ++) {

s = 0 ;
for ( j = 1 ; j <=m; j ++) {
s c a n f ( ”%d ” ,&y ) ;
s = s + j ;
}
if ( max<s )
max= s ;

}
return 0 ;

}

Figure 1: An example illustrating the undeclared variable ”s” that is frequently used in the program is caught by the
compiler

Syntax errors poses a threat as it fails the compilation and some recent techniques such as [14] where a RNN model
is learnt on syntactically correct, executing student programming course submissions to model all valid sequences of
token and use a preﬁx token sequence which is from the beginning of the program till the error location and is used
to predict the following sequence that are able to automate the repair of errors present in corresponding locations of
code. Sequence-to-sequence NMT with attention mechanism is learned iteratively in repairing syntax errors in [15]
using the tokenized vector representation of the program and is used to predict the erroneous program locations and
the ﬁxing statement without using any external compiler tools or any AST representation. A real-time feedback is
given to the students enrolled in beginner level programming assignments in [16] of the compile-time syntax errors
that are made by using RNN to predict the target lines from syntactically correct submissions given the source error
lines from wrong submissions and a abstract version of top ranked suggestion of error ﬁx is presented as feedback.

3 Approach

This section covers some examples of undeclared variables and also the importance of semantic analysis to determine
the type information of those undeclared variables. We introduce the Abstract Syntax Trees (AST) that is used as the
input, deployment of the LSTM RNN for training the deep learning model, semantic analysis determining the types of
undeclared variables, and the generation approach by performing the serialization/deserialization of the AST in order
to get back the clean and bug-free source code.

3.1 Motivating Examples

The most frequent semantic error that goes unnoticeable by novice programmers is the undeclared variables. The
cause of this error is due to the variables being undeclared or another common cause will be usually through spelling
mistakes which makes it the ﬁrst occurrence in the program. The main challenge lies in the fact in determining
whether the variable is an identiﬁer, arrays, pointers or pointers-to-pointers and also in concluding about the type of
the variable if it is an integer, ﬂoat, character, double, long int and so on. The C99 standard1, removes the implicit
integer rule that states a variable declared without an explicit data type is assumed to be integer which was previously
deﬁned in C89 standard2. Therefore, there is a need for determining the variables that are undeclared along with its
type, else the compiler will throw an error.

3.2 Abstract Syntax Trees

Generally, any programming language whether statically or dynamically typed follows an unambiguous context-free
grammar language where there exists not more than one leftmost derivations or rightmost derivations of non-terminals,
or more precisely there is always a unique parse tree for each string of the language generated by it. Parse trees are

1www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf
2https://www.pdf-archive.com/2014/10/02/ansi-iso-9899-1990-1/ansi-iso-9899-1990-1.pdf

3

A PREPRINT - JULY 16, 2019

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

#include < s t d i o . h>
int main ( )
{

int n ,m;
int
i , j ;
int a [ 2 0 ] ;
int sum = 0 ;
s c a n f ( ”%d%d ” ,&n ,&m) ;
for ( i = 0 ; i <n ; i ++) {

for ( j = 0 ; j <m; j ++) {

s c a n f ( ”%d ” ,& a [ j ] ) ;
sum=sum+a [ j ] ;

}
p r i n t f ( ”%d\n ” , sum ) ;
i ++;
J ++;

}
return 0 ;

}

Figure 2: An example of compiler error caused by an undeclared variable ”J” that is used once in the program

FuncDef

FuncDecl

Decl

TypeDecl

IdentiﬁerType

Compound

hanoi

hanoi

ﬂoat

Decl

TypeDecl

IdentiﬁerType

FuncCall

Assignment:=

towers

towers

ﬂoat

ID

ExprList

ID

BinaryOp:+

scanf

Constant

UnaryOp:&

towers

ID

Constant

”%f”

ID

towers

999.99

towers

Figure 3: An example illustration of Abstract Syntax Trees(AST) of C program with non-terminals at the root as well
as internal nodes and terminals at the leaf nodes of the tree.

formed from a concrete context-free grammar and are not suitable for performing syntax or semantic analysis due to
their complex representation. Nevertheless, the Abstract Syntax Tree are the derivation trees following an abstract
grammar is used as an input for syntax/semantic analysis at compile-time. It is a rooted tree representation of an
abstract syntactical structure of a programming language construct where the non-terminals represents non-leaf nodes
and the terminals forms the children nodes. Some of the non-terminals in C language are Decl, IdentifierType,
For, TypeDecl, ExprList, FuncDef, ArrayDecl etc. Terminal nodes includes any string literals, numerical
literals, variable names, operators, keywords etc. Figure 3 shows an example AST representation where a node
enclosed in a rectangle box and black-colored depicts the non-terminal nodes (eg.,FuncDef), node that are enclosed
in dashed box and red-colored depicts the terminal nodes or tokens of the source code.

3.3 Model

This subsection covers the basics of LSTM-RNN and the prediction model that is subsequently used for generation
approach.

Long Short Term Memory(LSTM) recurrent neural networks have special memory units in the form of self-
loops to produce paths so that information can be maintained for longer durations of time. LSTM is preferred over
vanilla RNN due to the fact that the former tends to avoid vanishing or exploding gradient problem that occurs when
trying to learn long term dependencies and store it in memory cells during backpropagation. This occurs when many
deep layers with speciﬁc activation functions like sigmoid are used for training, it smoothens a region of input space

4

A PREPRINT - JULY 16, 2019

into an output space between 0 and 1, then even a high change in input region effects almost negligible change in
output region, thereby making the gradients/error signals of a long-term interaction becomes vanishingly very small.
Further, the vanilla RNNs are affected by information morphology problem in which information contained at a
prior state is lost due to non-linearites between the input and output space. LSTM avoids this problem by ensuring
a constant unit activation function and uses gates to control the information ﬂow between the memory cell and the
outside layers without any inference. LSTM uses three gates namely forget gate, input gate and output gate layers.
The forget gate layer decides the information that is needed to be stored or erased from the LSTM cell state where the
decision is made by the sigmoid layer outputting a number between 0 to 1.

f i

(t) = σ(bi

f +

U i,j

fxj

(t) +

(cid:88)

j

(cid:88)

j

W i,j

fhj

(t-1))

(1)

where x(t) is the input vector at current timestep t and h(t) is the current hidden layer vector at timestep t, and bf, Uf,
Wf are bias units, input weights and recurrent weights of forget gate units fi
The input gate layer controls the ﬂow of new information that is being stored in the LSTM cell state si
with a self-loop weight fi

(t) conditioned

(t).

(t).

gi

(t) = σ(bi

g +

U i,j

gxj

(t) +

W i,j

ghj

(t-1))

(2)

(cid:88)

(cid:88)

j

j

where x(t) is input vector at current timestep t and h(t) is current hidden layer vector at timestep t, and bg, Ug, Wg are
bias units, input weights and recurrent weights of input gate units gi

(t).

si

(t) = f i

(t)si

(t-1) + gi

(t)σ(bi +

U i,jxj

(t) +

(cid:88)

j

(cid:88)

j

W i,jhj

(t-1))

(3)

where the parameters W,U and b represents the recurrent weights, input weights and bias units present in a LSTM cell.
The output gate layer in the memory cell decides the pieces of information that is going to be output by the LSTM
cell state. This is done by passing the cell state through a tanh layer and eventually multiplying by the sigmoid of the
output gate.

qi

(t) = σ(bi

o +

U i,j

oxj

(t) +

W i,j

ohj

(t-1))

(4)

(cid:88)

(cid:88)

j

j

where bo,Uo,Wo are the parametric units of the output gate qi
weights. The output hidden state hi

(t) is obtained from output gate qi

(t) as follows:

(t) that represents bias units, input weights and recurrent

hi

(t) = tanh(si

(t))qi

(t)

(5)

In our prediction model, we use non-terminals and terminals obtained from the AST as the input. The main ideology
behind our model is to specify a declaration for any identiﬁer that is used throughout a C program. Here, we assume
identiﬁer in our context that excludes keywords and only includes alphanumeric variables. This in turn solves the
complex problem of automatically ﬁxing the undeclared variables.

3.3.1 Declaration Classiﬁcation and Prediction

ID is the non-terminal node of the AST that represents an identiﬁer excluding keywords as mentioned above. Decl
is the non-terminal node of the AST representation that is entitled to represent the declaration of the identiﬁer where
its terminal node is the corresponding identiﬁer itself. Similarly, TypeDecl and IdentifierType are the semantic
elements that is used to represent the type speciﬁer information of the identiﬁer where identiﬁer and its type are its
corresponding terminals respectively.

For the classiﬁcation purpose, the pair of non-terminal node ID and any terminal alphanumeric identiﬁers usu-
ally variables is augmented along with pairs of Decl and the respective identiﬁer, TypeDecl and the identiﬁer,
IdentifierType and a generalized ”type” referring to the corresponding types of those identiﬁer variables so that
they can be used for backsubstitution which will be explained later in the generation approach. After classiﬁcation,
the LSTM model is used to predict the Decl, TypeDecl and IdentifierType information for any alphanumeric
identiﬁer variable occurring with its corresponding non-terminal node ID. The classiﬁcation model is sequential
where the embedding layer, LSTM layer and softmax layers are stacked on top of each other sequentially as shown in
Figure 4 are detailed below in this section.

5

A PREPRINT - JULY 16, 2019

Figure 4: Illustration of approach showing concatenation of non-terminal and terminal node embeddings extracted
from AST being used as the inputs to LSTM model for the sequence classiﬁcation and prediction.

3.3.2 Embedding Layer of Non-Terminal and Terminal Nodes

In our model, we do not use any pre-trained embeddings, instead it is trained simultaneously with the model. The
sequences of input tokens are a combination of non-terminal and terminal nodes where in our model, we consider
only 4 non-terminals ID, Decl, TypeDecl, IdentifierType and all the alphanumeric identiﬁer variables as the
terminals. These input tokens are formed by the concatenation of individual string encodings of non-terminal and
terminal node vocabularies (that is discussed in evaluation section), subsequently embedding is computed on the
integer encodings(converted from string) for performing the training of the model. The embeddings are computed as
follows:

Ei = A ∗ concat(N iT i)

(6)

where A is K × V N,T matrix where K is the embedding vector size and VN,T is the vocabulary size formed by the
concatenated encodings of non-terminal and terminal nodes.

3.3.3 LSTM Layer

The sequences of embedded tokens are passed on to the LSTM layer containing LSTM memory cells where each cell
state stores information of the previous state and are controlled by the forget gate, input gate and output gate layers as
mentioned above in equations (1),(2),(3),(4). Each LSTM cell state takes inputs from its previous LSTM cell hidden
state hi-1, state information si as well as the input tokens and outputs the hidden state hi of LSTM cell as in equation
(5) where the LSTM layers can be seen from Figure 4.

3.3.4 Dense Softmax Activation Layer

The last LSTM memory cell state’s output hidden state of the LSTM layer is passed to the softmax activation layer
to predict the sequences of non-terminals Decl, TypeDecl and IdentifierType given the non-terminal ID. The
predicted output sequences at timestep t (or ﬁxed input sequence length) are represented by ˆy(t) and is formulated as:

where bN,T is the bias unit of softmax layer with size of VN,T dimensional vector, MN,T is a weight matrix of size
K × V N,T and h(t) is the hidden state of the LSTM cells at each timestep t.

ˆy(t) = sof tmax(bN,T + M N,Th(t))

(7)

6

A PREPRINT - JULY 16, 2019

Figure 5: The vocabulary of all non-terminal nodes of AST for C programs

4 Evaluation and Results

4.1 Dataset

The dataset that used in this approach is prutor3 which is a database that has student coding submissions for university
programming assignments. It contains a set of 53478 C programs out of which there are 6978 erroneous programs
which contains multiple and single line syntax as well as semantic errors. Out of 6978 programs, 1059 programs
contains only undeclared variable errors which is the main focus of our evaluation.

4.2 Preprocessing and Training Details

We use pycparser4, that acts as a front-end of the C compiler to parse source code of C language in python. AST are
obtained as an output for the source code after the parsing stage and are stored in text ﬁles.

The source code is preprocessed in the form of tokens that represents the terminal nodes of its corresponding
AST. Since the set of tokens are uncontinuous, discrete and in its textual form, it must be encoded into sequences of
numerical vectors to be used for training the model. Additionally, there are 47 ﬁxed set of non-terminals in C language
that are encoded as in Figure 5. The terminals can be keywords, strings, data types, integers or ﬂoating point numbers.
The terminals of the above mentioned categories are encoded separately in a speciﬁc range of numbers. Now, the
data for training is prepared by concatenating the encodings of non-terminals and terminals together. The individual
encodings in the form of integers are converted to strings initially and after concatenation, they are converted back
to integers. For example, the non-terminal IdentifierType is encoded as 9 in the dictionary of non-terminals and
converted to ’9’, if the terminals are data types like int, ﬂoat, long etc. then they are encoded as 111111 referring to
a generalized ’type’ and converted to ’111111’. Therefore, the concatenation of the non-terminals and terminals are
mapped accordingly and stored in separate vocabulary. This vocabulary set is used in performing the training of the
model. One-hot encoding approach is used to perform categorical multi-class classiﬁcation to represent the elements
of vocabulary as vectors with each of them of vocabulary size containing 1 at the corresponding index and rest of
them are 0.

Training Details:
The training experiment is performed by using embedding dimension of size 512 and two LSTM layers are used each
with number of hidden units as 512 and a dropout of 0.5. The input sequence length is 1, batch size is 3, vocabulary
size is 583 and the total number of sequences is 2319. The dense layer is used for forming a fully connected layer in
which each of the input layer nodes is connected with every hidden and output layer nodes. The activation function
used in our model is softmax function because of its efﬁciency in dealing with multi-class classiﬁcation problems
compared to sigmoid and ReLU due to the fact that the outputs of the softmax is a categorical probability distribution
summing to 1 and lying between 0 to 1. The total number of units of Dense layer is equal to the vocabulary size. The
vocabulary formed from concatenation is split into training and testing data where test data size is 0.2 and the split
rule percentage used is 80/20. The loss function used is categorical cross-entropy function. The optimizer used is
RMSprop with a learning rate of 0.01 as it is better in handling non-local extremum points and has a constant initial
global learning rate compared to optimizers such as Stochastic gradient descent optimizer.

3https://www.cse.iitk.ac.in/users/karkare/prutor/prutor-deepﬁx-09-12-2017.zip
4https://pypi.org/project/pycparser/

7

A PREPRINT - JULY 16, 2019

[ ] ,

” n o d e t y p e ” : ” D e c l ” ,
” b i t s i z e ” : n u l l ,
” f u n c s p e c ” :
” i n i t ” : n u l l ,
” name ” : ” j ” ,
” q u a l s ” :
[ ] ,
” s t o r a g e ” :
” t y p e ” : {

[ ] ,

” n o d e t y p e ” : ” TypeDecl ” ,
” d e c l n a m e ” : ” j ” ,
” q u a l s ” :
” t y p e ” : {

[ ] ,

” n o d e t y p e ” : ”

I d e n t i f i e r T y p e ” ,

” names ” :

[

” i n t ”

]

}

{

}

}

Figure 6: Example demo of JSON object containing Decl, TypeDecl and IdentiﬁerType nodes.

4.3 Generation Approach

During generation, one-hot encoding is used to represent the new unseen sequences of the nonterminal ID and a
terminal variable as a categorical distribution and the output class is classiﬁed as the sequences of non-terminals
Decl, TypeDecl, IdentifierType along with the corresponding terminal variables.

4.3.1 AST Transformation

The program ﬁx approach is carried out through an AST transformation performed by augmenting the predicted
output sequences in each of the program’s AST syntactical structure for the terminal variables associated with its
corresponding non-terminal node ID. This augmentation is carried out on each of the source code by performing a
check on declaration of the variables in the vocabulary set of concatenated encodings of non-terminal and terminal
nodes as created previously using the predicted output sequence of the non-terminal Decl and the associated terminal
variable. If any of the predicted output sequences does not match with the declared variables present in a source code,
then the output sequence Decl containing the particular terminal variable is augmented to the original AST structure
of the code through serialization and deserialization that will be described below.

4.3.2 Serialization and Deserialization

Serialization is implemented using pycparser by transforming data structures such as nodes of python Node object by
traversing the AST (the nodes being obtained by parsing the source code from pycparser) recursively into a dictionary
object representation which is then subsequently serialized into a JSON object that is understood by Pycparser in
deserializing it back to a dictionary object and thereby consequently back to AST Node objects. An example JSON
object representation of a AST node object is shown in Figure 6 where the nodetype key refers to the different types
of non-terminal nodes such as Decl, ArrayDecl, TypeDecl, IdentifierType. The TypeDecl and ArrayDecl
are the child nodes of Decl and IdentifierType is the child node of the intermediate non-terminal TypeDecl node.
The key name refers to the terminal variables, type refers to the datatypes and coord refers to the Coord node of the
AST indicating the location of the object in the corresponding source code.

The serialization and deserialization is carried out when there is an AST transformation performed as men-
tioned above, so that the transformation is taking place consistently without disintegrating the program thereby
ensuring maximal quality of the source code.

8

A PREPRINT - JULY 16, 2019

4.3.3 Pre-Compile Time Type Binding and Analysis Results

After determining and performing the augmentation of the undeclared terminal variables, the type of those undeclared
variables is determined before compiling the program and is augmented to the original AST structure. The type
binding is performed by determining the type of a lvalue from its rvalue in an assignment statement or ﬁnding the
type of a undeclared variable from its neighboring variables in an expression of a program.

The type of the undeclared variables is determined and drawn from the following cases:

Case 1: When the rvalue is a constant, where the non-terminal is Constant and is of integer type, then the
lvalue whose non-terminal is ID, is assigned integer as seen from the Figure 7, in the assignment statement i=0 on
left side of ﬁgure, ”i” is undeclared and is assigned integer.

1
2
3
4
5
6
7
8
9

int main ( )
{
int k , n , x , a [ 1 0 0 ] ;
s c a n f ( ”%d ” , &k ) ;
s c a n f ( ”%d ” , &n ) ;
for ( i = 0 ; i <n ; i ++)

s c a n f ( ”%d ” , &a [ i ] ) ;

return 0 ;
}

1
2
3
4
5
6
7
8
9
10
11
12
13

int main ( )
{
int
i ;
int k ;
int n ;
int x ;
int a [ 1 0 0 ] ;
s c a n f ( ”%d ” , &k ) ;
s c a n f ( ”%d ” , &n ) ;
for

( i = 0 ;

i < n ;
s c a n f ( ”%d ” , &a [ i ] ) ;

i ++)

return 0 ;
}

Figure 7: Case 1 demonstrating location of error in the for loop statement involving undeclared identiﬁer ”i” and the
ﬁx of it

Case 2: In this case, if the rvalue is an identiﬁer that refers to an array element whose non-terminal is ID and
its non-terminal parent is ArrayRef, then the lvalue terminal variable with non-terminal ID is assigned to the
respective type of rvalue element. We can see in Figure 8 where ”b” is undeclared and is assigned to integer type
from array ”n[1000]” in the statement b=n[i].

1
2
3

4
5
6
7
8
9
10
11
12
13
14
15
16

int main ( )
{
int n [ 1 0 0 0 ] , a [ 5 0 0 ] , nm , i , j , l n ,

f l a g = 0 ;

s c a n f ( ”%d\n ” ,& l n ) ;
s c a n f ( ”%d\n ” ,&nm ) ;
for ( i = 0 ; i <500; i ++)
{

a [ i ] = 0 ;

}
for ( i = 0 ; i <nm ; i ++)
{

s c a n f ( ”%d ” ,&nm ) ;
c=n [ i ] ;

}
return 0 ;
}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

int main ( )
{
int c ;
int n [ 1 0 0 0 ] ;
int a [ 5 0 0 ] ;
int nm ;
int
int
int
int
s c a n f ( ”%d ” ” \n ” , &l n ) ;
s c a n f ( ”%d ” ” \n ” , &nm ) ;
for
{

i ;
j ;
l n ;
f l a g = 0 ;

i < 5 0 0 ;

( i = 0 ;

i ++)

a [ i ] = 0 ;

}
for
{

( i = 0 ;

i < nm ;

i ++)

s c a n f ( ”%d ”
c = n [ i ] ;

, &nm ) ;

}
return 0 ;
}

Figure 8: Case 2 indicating the error in assignment statement between variable and array identiﬁer

9

A PREPRINT - JULY 16, 2019

Case 3: If the non-terminal of rvalue and non-terminal of lvalue are the children nodes of the non-terminal
BinaryOp, then the type of rvalue is assigned as the type of lvalue. In the Figure 9 on the left side of the ﬁgure,
in the conditional expression statement count > max, BinaryOp is ”>”, the lvalue ”count” is undeclared with its
non-terminal being ID and the rvalue is max with its non-terminal being ID.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

int main ( )
{
int n , i , j , max ;
int a [ 2 0 ] ;
for ( i = 0 ; i <n ; i ++)
{

for ( j = i ; j <n ; j ++)
{

if ( a [ i ]<a [ j ] )
{
c o u n t = c o u n t + 1 ;
}

}

if ( c o u n t >max ) {max= c o u n t ; }

}
p r i n t f ( ”%d ” , max ) ;
return 0 ;
}

i ++)

j < n ;

j ++)

c o u n t = c o u n t + 1 ;

for
{

i < n ;

( j = i ;

( i = 0 ;

1 int main ( )
2 {
3 int c o u n t ;
4 int n ;
i ;
5 int
6 int
j ;
7 int max ;
8 int a [ 2 0 ] ;
9 for
10 {
11
12
13
14
15
16
17
18
19
20
21
22 }
23 p r i n t f ( ”%d ” , max ) ;
24 return 0 ;
25 }

( c o u n t > max )

max = c o u n t ;

}
if
{

if
{

}

}

( a [ i ] < a [ j ] )

Figure 9: Case 3 illustrating the repair of assignment statement of variable and array identiﬁer

Case 4: This case is similar to case 2 but deals with assignment of a variable to another variable instead of array
element. In this Figure 10, in the left side of the ﬁgure, the lvalue variable ”z” inside the For statement is undeclared,
and its non-terminal node is ID, it is assigned to the integer type of the variable ”i” whose non-terminal is ID.

1
2
3
4
5
6
7
8
9
10
11
12
13

i ,

j , k ;

int main ( ) {
int n ,
s c a n f ( ”%d ” , &n ) ;
for ( i = 1 ;
{
for ( j =1 , z= i ; j <= i ; j ++ , k−−)

i <=n ;

i ++)

if ( ( k%2) == 0 )
p r i n t f ( ” ∗ ” ) ;

{

}

}
return 0 ;
}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

int main ( )
{
int z ;
int n ;
i ;
int
j ;
int
int k ;
s c a n f ( ”%d ” , &n ) ;
for
{
for

( i = 1 ;

i <= n ;

i ++)

( j = 1 , z = i ; j <= i ; j ++ , k−−)

{

}

if

( ( k % 2 ) == 0 )
p r i n t f ( ” ∗ ” ) ;

}
return 0 ;
}

Figure 10: Case 4 illustrating the ﬁx of variable ”z” from the for loop statement

Case 5: This case deals with binary operation involved in an assignment expression statement. In Figure 11, the
terminal variable ”t” is undeclared and is assigned to the type of the terminal variable ”summation” which is of type
double. In the statement summation = summation + t*delx, there is non-terminal Assignment and its children

10

nodes being the non-terminal ID with terminal ”summation” variable and the node BinaryOp with its corresponding
children nodes ID:summation, BinaryOp:+, BinaryOp:* with its children ID:t, ID:delx.

A PREPRINT - JULY 16, 2019

1 double sum ( double a , double n ,

double d e l x )

j ;
( j = 0 ; j <n ; j ++)

2 {
3 double summation = 0 ;
4 int
5 for
6 {double x=a+ j ∗ d e l x ;
7 double r = f a b s ( f ( x )−g ( x ) ) ;
8 summation = summation + t ∗ d e l x ;
9 }
10 return summation ;
11 }

1 double sum ( double a , double n , double

d e l x )

j ++)

j < n ;

j ;
( j = 0 ;

2 {
3 double t ;
4 double summation = 0 ;
5 int
6 for
7 {
8 double x = a + ( j ∗ d e l x ) ;
9 double r = f a b s ( f ( x )−g ( x ) ) ;
10 summation = summation + ( t ∗ d e l x ) ;
11 }
12
13 return summation ;
14 }

Figure 11: Case 5 demonstrating the error in binary operation and undeclared ”t” getting ﬁxed

Case 6: This case is an exact opposite of case 2 where the lvalue in the Figure 12 is an array identiﬁer ”b”
undeclared, whose non-terminal node is ID and its parent node is ArrayRef and rvalue is a terminal variable
”count” whose non-terminal node ID is assigned as integer.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

i , j , n , k , c o u n t =0 , max ;

int main ( )
{
int
s c a n f ( ”%d ” ,&n ) ;
int a [ n ] ;
for ( i = 0 ; i <n ; i ++) {

s c a n f ( ”%d ” , a [ i ] ) ;

}
for

( i = 0 ; i <n ; i ++) {
for

( j = i ; j <n ; j ++) {
if

( a [ j ]>a [ i ] ) {
c o u n t ++;

}

}
b [ i ] = c o u n t ;
c o u n t = 0 ;

}
return 0 ;
}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

int main ( )
{
int b [ 1 0 0 0 ] ;
int
i ;
j ;
int
int n ;
int k ;
int c o u n t = 0 ;
int max ;
s c a n f ( ”%d ” , &n ) ;
int a [ n ] ;
for
{

( i = 0 ;

i < n ;

i ++)

s c a n f ( ”%d ” , a [ i ] ) ;

( i = 0 ;

i < n ;

i ++)

}
for
{

( j = i ;

j < n ;

j ++)

( a [ j ] > a [ i ] )

c o u n t ++;

for
{

if
{

}

}
b [ i ] = c o u n t ;
c o u n t = 0 ;

}
return 0 ;
}

Figure 12: Illustration of case 6 marked by red line indicating the error in assignment statement

Case 7: This case is slightly similar to case 5 but it does not involve any assignment operation. The type can be
assigned to a variable not only from lvalue but also from its neighbouring variables involved in a binary operation.
As we can see in left side of the Figure 13, the terminal variable ”diff” being undeclared is involved in a binary
operation BinaryOp:* and BinaryOp:+ with the terminal variables ”key” and ”a” respectively, so the variable ”diff”
is assigned to integer type.

11

1 int main ( )
2 {
3 const double E = 0 . 0 0 0 0 0 1 ;
4 double a , b , i n t e r , s u b a r e a = 0 ;
5 int n , key = 0 ;
6 s c a n f ( ”%l f%l f%d ” ,&a ,&b ,& n ) ;
7 i n t e r = ( b − a ) / n ;
8 while ( key<n&&d i f f ∗ key+1< E )
9 {
10
11
12 }
13 return 0 ;
14 }

s u b a r e a +=1;
key ++;

A PREPRINT - JULY 16, 2019

1 int main ( )
2 {
3 int d i f f ;
4 const double E = 0 . 0 0 0 0 0 1 ;
5 double a ;
6 double b ;
7 double i n t e r ;
8 double s u b a r e a = 0 ;
9 int n ;
10 int key = 0 ;
11 s c a n f ( ”%l f ” ”%l f ” ”%d ” , &a , &b , &n ) ;
12 i n t e r = ( b − a )
13 while ( ( key < n ) &&(( d i f f ∗ key ) + 1 )<E ) )
14 {
15
16
17 }
18 return 0 ;
19 }

s u b a r e a += 1 ;
key ++;

/ n ;

Figure 13: Demo of case 7 involving the error in while loop statement

Case 8: In this case, the type of a variable is bound from the type of a function call in a conditional expression. In
Figure 14, the terminal variable ”k” is undeclared in the ”for” expression k >= hanoi(j)-1 and it is being involved in
a binary operation BinaryOp:>= with the function call hanoi(j) where the corresponding non-terminal node of the
terminal ”hanoi” is ID and parent node being FuncCall, is integer.

1 int main ( ) {
2 int
t , i , n , j ;
3 int x ;
4 s c a n f ( ”%d ” ,& t ) ;
5 for ( i = 1 ; i <t ; i ++)
6 {
7 s c a n f ( ”%d ” ,&n ) ;
8 for ( j = 0 ; k>=h a n o i ( j ) −1; j ++)
9 {
10
11
12
13
14 }
15 }
16 return 0 ;
17 }

if ( h a n o i ( j ) −1==k )

p r i n t f ( ” y e s ” ) ;

p r i n t f ( ” no ” ) ;

else

i < t ;

1 int main ( )
2 {
3 int k ;
t ;
4 int
5 int
i ;
6 int n ;
7 int
j ;
8 int x ;
9 s c a n f ( ”%d ” , &t ) ;
10 for
( i = 1 ;
11 {
12
13
14
15
16
17
18
19
20 }
21 return 0 ;
22 }

s c a n f ( ”%d ” , &n ) ;
for
{
if

p r i n t f ( ” no ” ) ;

else

}

i ++)

( j = 0 ; k>=( h a n o i ( j ) − 1 ) ; j ++)

( ( h a n o i ( j ) − 1 ) == k )
p r i n t f ( ” y e s ” ) ;

Figure 14: Case 8 indicating the undeclared ”k” in for loop statement

Case 9: This case is similar to case 8, however instead of a conditional expression with a binary operation, the type
of the function call is a rvalue is bound to a lvalue variable in an assignment expression statement with a binary
operation. This can be seen from Figure 15, where variable ”y” is undeclared in the assignment expression y =
tower(j)-1 and is assigned to the type of the function call tower(j) whose non-terminal node is ID and parent node is
FuncCall.

12

A PREPRINT - JULY 16, 2019

Identiﬁed

Not
Identiﬁed

Correctly
Identiﬁed
(True
Positive)

Wrongly
Identiﬁed
(False
Positive)

Correctly
Identiﬁed
+ Correct
Type
Inferred
(Fixed)

887(83.7%)

172

857(80.9%)

202

844(79.7%)

Wrongly
Identiﬁed
+ Wrong
Type
Inferred
(Not
Fixed)
215

Total

1059

N/A

N/A

566(99.1%)

5

560(98%)

11

571

N/A

N/A

179(91.7%)

16

172(88.2%)

23

195

N/A

N/A

90(96.8%)

N/A

N/A

22(78.5%)

3

6

90(96.8%)

22(78.5%)

3

6

93

28

Table 1: Analysis results of both the undeclared variables and arrays

Undeclared
Variables
and Arrays
Undeclared
variables -
Main
function
Undeclared
variables -
Multiple
functions
Undeclared
Arrays -
Main
functions
Undeclared
Arrays -
Multiple
functions

1
2
3
4
5
6
7
8
9
10
11
12
13

int main ( )
{int

i , n , j , t ;

s c a n f ( ”%d\n ” ,&n ) ;
for ( i = 1 ; i <=n ; i ++)
{

s c a n f ( ”%d\n ” ,& t ) ;

for ( j = 1 ; j <=200; j ++)
{

y= t o w e r ( j ) −1;

}
}

return 0 ;
}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

int main ( )
{
int y ;
int
i ;
int n ;
j ;
int
t ;
int
s c a n f ( ”%d ” ” \n ” , &n ) ;
for
{

i <= n ;

( i = 1 ;

i ++)

s c a n f ( ”%d ” ” \n ” , &t ) ;
j <= 2 0 0 ;
for
{

( j = 1 ;

y = t o w e r ( j ) − 1 ;

j ++)

}

}
return 0 ;
}

Figure 15: Case 9 demonstrating the undeclared identiﬁer ”y” in assignment statement with a function call

Table 1 shows the results of analysis obtained after performing the compilation of the programs manually where the
ﬁrst row consists of all the programs (1059) that are containing both undeclared variables and arrays in which our
approach has located and identiﬁed the undeclared variables in 887(83.7%) programs out of total number of 1059
programs. However, our approach has correctly located and identiﬁed them in 857(80.9%) programs, but the repair
is performed on 844(79.7%) programs by correctly locating as well as inferring and binding their types. The value
of the ﬁrst column ”Identiﬁed” in the rest of the rows are not applicable (N/A) as the results correspond to programs
where undeclared variables are identiﬁed and located. Similarly, the second row shows the results for programs with
only undeclared variables and consisting of only single main functions (571) out of the identiﬁed programs (887). The

13

A PREPRINT - JULY 16, 2019

Cases
Case 1
Case 2

Case 3
Case 4

Case 5
Case 6

Case 7
Case 8

Case 9

Brief Description
Assignment expression statement with a constant on the right-hand side of the expression
Assignment expression statement with an array identiﬁer on the right-hand side and an identiﬁer
other than array identiﬁer on the left-hand side of the expression
Conditional expression statement with a binary operation between the identiﬁer variables
Assignment expression statement with an identiﬁer other than array identiﬁer on the right-hand side
of the expression
Assignment expression statement with a binary operation between the identiﬁer variables
Assignment expression statement with an identiﬁer other than arrays on the right-hand side and an
array identiﬁer on the left-hand side of the expression
Binary operation between identiﬁer variables in a loop expression statement
Conditional expression statement with a binary operation between an identiﬁer and a function call
expression
Assignment expression statement with a binary operation between an identiﬁer and a function call
expression

Table 2: Summary of Type Binding Case Description

third row displays the results of programs with undeclared variables and containing two or more functions including
main function (195) out of 887 programs. The fourth row demonstrates the results shown by programs only with
errors caused due to undeclared arrays and having one and only main function (93) out of the 887 programs. Finally,
the last row illustrates the number of programs which contains undeclared variables and having two or more functions
along with main function (22) out of those 887 programs. Table 2 shows the summary of various cases along the
rows and its brief description message along the columns through which the type binding is performed before the
compile-time.

i < n ;

i ++)

s c a n f ( ”%d ” , &a [ i ] ) ;

( i = 0 ;

1 int main ( )
2 {
3 int J ;
4 int n ;
i ;
5 int
j ;
6 int
7 int
f l a g = 0 ;
s c a n f ( ”%d ” , &n ) ;
8
9 int a [ 5 1 ] ;
10 for
11 {
12
13 }
14 for
15 {
16
17
18
19
20
21
22
23
24
25 }
26 return 0 ;
27 }

( j = 0 ;

( i = 0 ;

for
{

if
{

}

}

( a [ i ] == a [ j ] )

p r i n t f ( ”YES” ) ;
f l a g = 1 ;
break ;

i < n ;

i ++)

j < n ;

J ++)

l ;

( l = 1 ;

l <= n ;

1 int main ( )
2 {
3 int
4 double a ;
5 double b ;
6 double k ;
7 double p ;
8 int n ;
9
10 k = ( ( a − b ) ∗ 1 . 0 )
11 for
12 {
13
14
15
16
17
18
19
20
21
22
23 return 0 ;
24 }

p r i n t f ( ” %.4 f ” , p ) ;

if ( ( l ∗ k ) <(−1) )

if ( ( l ∗ k ) > 1 )

p+= k ;

}

s c a n f ( ”%f ” ”%f ” ”%d ” , &a , &b , &n ) ;

/ n ;

l ++)

if ( ( l ∗k>=−1) && ( l ∗k<= 1 ) )

p=p + ( ( ( l ∗ k ) ∗ ( l ∗ k ) ) ∗k ) ;

p=p + ( ( l ∗ k ) ∗ ( l ∗ k ) ) ∗ ( l ∗k ) ∗k ;

Figure 16: Picture on left illustrates repair that caused inﬁnite loop due to variable ”J” incremented in loop statement
and the right side depicts repair caused by binding type int instead of double

14

A PREPRINT - JULY 16, 2019

5 Discussion

There are few limitations in our approach. Fixing the undeclared variables that had been due to imperceptible spelling
mistakes or a variable that is used only once throughout the program may cause the program to run in an inﬁnite loop
or lead to some possible run-time errors. As seen in the left side of Figure 16, instead of incrementing the variable ”j”
inside the for loop, the programmer had used ”J” instead which had caused the program to run into an inﬁnite loop.
Another major limitation is in the type binding approach on the right side of Figure 16 shows an example where,
the type has been wrongly bound to the variable ”l” because ”l” is used in the for loop expression in which ”l” is
assigned to constant ”1” as well as it is used in an assignment expression inside the for loop body, in the statement
if((l*k) < -1), variable ”k” is of the type double and ”*” is a binary operation, so the variable ”j” should be assigned
of the type double instead it is inferred as an integer type due to the former case.

We had seen in our model that a vocabulary in the form of hash table is used for training purposes. The pur-
pose of training neural networks on the hash table is due to the fact that it can be used for recognizing input patterns
(keys) in the hash table and can be used to predict the sequences (values). Consider the case where an input pattern is
not present in the hash table and we need to predict the sequence, a hash table would have return null in this case but
neural networks will give the closest sequence prediction.

The beneﬁts of our approach lies in the fact that our model could be used in real-time as a tool for any C pro-
gramming environment online or ofﬂine editors in locating, reporting and repairing undeclared identiﬁers for any C
programs. Additionally, our model can be used when there are lack of positive bug-free syntactically correct and
executing source program reference examples for buggy source programs. Also, our type binding approach will be
applicable even for declared variables.

6 Conclusion and Future Work

In this paper, we had seen different cases of one of the most common semantic error: undeclared variables. We had
combined AST and LSTM approaches to extract a set of non-terminal and terminal nodes to carry out the classiﬁcation
and prediction tasks of the undeclared variables. We had also seen the generation of clean and buggy-free source
programs by performing AST transformation and serialization as well as deserialization of AST to JSON and vice-
versa. Furthermore, in this paper we had coined a new term known as Pre-Compile Time Type binding where we had
implemented the ﬁx of the types of undeclared variables by binding them their corresponding types before providing
it for the compiler to compile them. By our approach, we had correctly identiﬁed 81% of the programs that contains
only undeclared identiﬁer errors. Also, we had ﬁxed those undeclared identiﬁer errors by binding their corresponding
types in 80% of the programs.

In future, we would like to perform automatic repair on different types of syntactic,semantic errors and logical
errors. Further, we plan to perform type binding for the limitation cases in Figure 16 as well as also implement a
repair approach for the logical errors that arises after the repair of syntactic and semantic errors caused by variables
used only once in the program or due to spelling mistakes.

References

[1] G. Fischer and J. Lusiardi and J. Wolff von Gudenberg, Abstract Syntax Trees - and their Role in Model Driven
Software Development. International Conference on Software Engineering Advances (ICSEA 2007). Aug. 2007,
pp. 38-38. doi: 10.1109/ICSEA.2007.12.

[2] Wile, David S, Abstract syntax from concrete syntax. ICSE, vol. 97, pp. 472–480, 1997, Citeseer

[3] Kosovan, Soﬁia and Lehmann, Jens and Fischer, Asja, Dialogue response generation using neural networks with
attention and background knowledge. Proceedings of the Computer Science Conference for University of Bonn
Students (CSCUBS), vol. 2017, 2017

[4] Choudhary, Himanshu and Pathak, Aditya Kumar and Saha, Rajiv Ratan and Kumaraguru, Ponnurangam, Neural
Machine Translation for English-Tamil. Proceedings of the Third Conference on Machine Translation: Shared
Task Papers, pp. 770–775, 2018

[5] Bahdanau, Dzmitry and Cho, Kyunghyun and Bengio, Yoshua, Neural machine translation by jointly learning to

align and translate. arXiv preprint arXiv:1409.0473, 2014

[6] Luong, Minh-Thang and Pham, Hieu and Manning, Christopher D, Effective approaches to attention-based neural

machine translation. arXiv preprint arXiv:1508.04025, 2015

15

A PREPRINT - JULY 16, 2019

[7] Goodfellow, Ian and Pouget-Abadie, Jean and Mirza, Mehdi and Xu, Bing and Warde-Farley, David and Ozair,
Sherjil and Courville, Aaron and Bengio, Yoshua, Generative adversarial nets. Advances in neural information
processing systems, pp.2672–2680, 2014

[8] Rajeswar, Sai and Subramanian, Sandeep and Dutil, Francis and Pal, Christopher and Courville, Aaron, Adver-

sarial generation of natural language. arXiv preprint arXiv:1705.10929, 2017

[9] Guo, Jiaxian and Lu, Sidi and Cai, Han and Zhang, Weinan and Yu, Yong and Wang, Jun, Long text generation
via adversarial training with leaked information. Thirty-Second AAAI Conference on Artiﬁcial Intelligence, 2018
[10] Liu, Chang and Wang, Xin and Shin, Richard and Gonzalez, Joseph E and Song, Dawn, Neural code completion.

2016

[11] Li, Liuqing and Feng, He and Zhuang, Wenjie and Meng, Na and Ryder, Barbara, Cclearner: A deep learning-
based clone detection approach. 2017 IEEE International Conference on Software Maintenance and Evolution
(ICSME), pp. 249–260, 2017, IEEE

[12] Dam, Hoa Khanh and Tran, Truyen and Pham, Trang and Ng, Shien Wee and Grundy, John and Ghose, Aditya,

Automatic feature learning for vulnerability prediction. arXiv preprint arXiv:1708.02368, 2017

[13] Harer, Jacob and Ozdemir, Onur and Lazovich, Tomo and Reale, Christopher and Russell, Rebecca and Kim,
Louis and others, Learning to repair software vulnerabilities with generative adversarial networks. Advances in
Neural Information Processing Systems, pp. 7933–7943, 2018

[14] Ahmed, Umair Z and Kumar, Pawan and Karkare, Amey and Kar, Purushottam and Gulwani, Sumit, Compilation
error repair: for the student programs, from the student programs. 2018 IEEE/ACM 40th International Conference
on Software Engineering: Software Engineering Education and Training (ICSE-SEET), pp. 78–87, 2018, IEEE

[15] Gupta, Rahul and Pal, Soham and Kanade, Aditya and Shevade, Shirish, Deepﬁx: Fixing common c language

errors by deep learning. Thirty-First AAAI Conference on Artiﬁcial Intelligence, 2017

[16] Bhatia, Sahil and Singh, Rishabh, Automated correction for syntax errors in programming assignments using

recurrent neural networks. arXiv preprint arXiv:1603.06129, 2016

[17] Jayanthi, R and Florence, Lilly, Software defect prediction techniques using metrics based on neural network

classiﬁer. Cluster Computing, pp. 1–12, 2018, Springer

16

