0
2
0
2

n
u
J

9
2

]

G
L
.
s
c
[

2
v
5
0
7
4
0
.
8
0
9
1
:
v
i
X
r
a

Exploiting Parallelism Opportunities with Deep Learning
Frameworks

YU EMMA WANG, Harvard University
CAROLE-JEAN WU, Facebook
XIAODONG WANG, Facebook
KIM HAZELWOOD, Facebook
DAVID BROOKS, Harvard University

State-of-the-art machine learning frameworks support a wide variety of design features to enable a flexible
machine learning programming interface and to ease the programmability burden on machine learning developers.
Identifying and using a performance-optimal setting in feature-rich frameworks, however, involves a non-trivial
amount of performance profiling efforts and often relies on domain-specific knowledge. This paper takes a
deep dive into analyzing the performance impact of key design features in a machine learning framework and
quantifies the role of parallelism. The observations and insights distill into a simple set of guidelines that one
can use to achieve much higher training and inference speedup. Across a diverse set of real-world deep learning
models, the evaluation results show that the proposed performance tuning guidelines outperform the Intel and
TensorFlow recommended settings by 1.29× and 1.34×, respectively.

ACM Reference Format:
Yu Emma Wang, Carole-Jean Wu, Xiaodong Wang, Kim Hazelwood, and David Brooks. 2020. Exploiting
Parallelism Opportunities with Deep Learning Frameworks. 1, 1 (July 2020), 21 pages. https://doi.org/10.1145/
nnnnnnn.nnnnnnn

1 INTRODUCTION
The wide adoption of deep learning (DL) tasks has spawned a plethora of domain-specific frameworks
to help improve development efficiency and to enable a flexible path from research to production
deployment for machine learning (ML). Notable ML frameworks include Caffe/Caffe2 [23], Py-
Torch [24], TensorFlow [2], and MXNet [8]. These frameworks provide high-level APIs as the
building blocks of DL models. The ML frameworks can significantly reduce the prototyping cycle
because of the substantial (re)use of optimized libraries and greatly improve the productivity of
developers building end-to-end DL models. In addition to programmability benefits, the frameworks
also provide many DL-specific optimizations to improve performance and performance portability
across software stacks and new hardware systems. The net result is an explosion in the development
of ever more complex DL models and a concomitant increase in the performance cost of inference.
Performance is especially important for deep learning inference. When trained DL models are de-
ployed into at-scale production serving, performance optimization for inference can affect datacenter
resource efficiency since inference is sensitive to both throughput and latency [17, 29, 31]. Inference
performance also affects whether a model can be deployed to performance- and energy-constrained
mobile and edge systems [36]. An important research question this paper aims to address is —what
is the performance cost of high-level abstraction or programmability in modern feature-rich DL
frameworks?. A further question examined in the paper is whether and by how much can we re-
duce this “programmability tax” by tuning the complex set of design choices available in current
ML frameworks. Answering both questions requires a comprehensive understanding of framework
features.

Authors’ addresses: Yu Emma Wang, ywang03@g.harvard.edu, Harvard University, 33 Oxford St, Cambridge, MA; Carole-
Jean Wu, carolejeanwu@fb.com, Facebook; Xiaodong Wang, xdwang@fb.com, Facebook; Kim Hazelwood, Facebook; David
Brooks, dbrooks@eecs.harvard.edu, Harvard University.

1

 
 
 
 
 
 
Fig. 1. Time breakdown for Inception v3.

Previous work have examined the performance of the modern DL frameworks and focused on
cross-framework comparison [4, 22, 30]. These studies help machine learning model developers
and engineers to make informed decisions about framework choices. However, there lacks in-depth,
focused performance characterization studies that quantify performance impacts of key framework
design features, explaining the underlying performance root cause of each design feature within a
framework. These design features include a rich set of parallelism opportunities within and between
DL model layers and across input data, for example, across the batch dimension. Furthermore, this
paper also examines key choices available to users include back-end math kernels, threading libraries,
and scheduling policies (Sections 4 to 6).

Figure 1 uses Inception as an example to illustrate the performance impact of important framework
features across the programming abstraction1. Overall, the performance of Inception can be improved
by 3.6× with properly tuned, optimized framework configurations. Determining performance-optimal
framework knobs, however, requires expert knowledge. In this example, tuning the inter-operator
parallelism speeds up the performance of native operators by 1.54×, leading to a speedup of 1.47×
for the whole model. Exploiting intra-operator parallelism further speeds up inference performance
by another 25×, translating to 2.4× performance improvement for the entire model. Using the
performance tuning guideline described in this work can speed up the native operators by 6.5×,
leading to an overall model performance improvement of 3.6×. Compared to the recommended
TensorFlow setting [14], our tuning guideline speeds up the whole model by 1.15×. The evaluation
results across a wide collection of DL workloads demonstrate consistent performance speedup.
For some DL workloads, over 2× performance improvement is observed. Selecting the optimal
performance setting is not straightforward, even for CPU platforms that serve a large, diverse
collection of DL use cases in production datacenter fleets. The significant gap for performance
improvement motivates the in-depth studies presented in this paper.

This paper provides three major contributions:

• We provide a detailed analysis to reason about and quantify performance implications of funda-
mental framework design features on CPU platforms, including scheduling mechanisms, operator
designs, library back ends, and parallelism mechanisms. We find that the programmability tax
ranges from 63% to 1.3%.

• Built upon the insights from this performance analysis, we propose simple guidelines for tuning

framework parameters to maximize parallelism and reduce framework overheads.

1Performance breakdown for Inception v3 running on a dual-socket CPU platform is presented. Methodological detail is in
Section 3.

2

77%4%50%1%13%4%2%8%LibraryKernel,Framework Native Op,Overhead** Overhead is the increasing synchronization time caused by workload imbalance among threads.(1) MKL-DNN backend (Sec 6)(2) Inter-Op Parallelism (Sec 4) -- TF Recommended Setting(3) Inter- and Intra-Op Parallelism (Sec 5)-- Our Recommended Setting (Sec 8)Fig. 2. An overview of the framework design features studied in this work.

• We demonstrate the usability of our approach by integrating the proposed methodology into
TensorFlow. The code is made available on GitHub2. The proposed settings match the globally
optimal performance and outperform the suggested settings from Intel [3] and TensorFlow [14]
performance guides by 1.29× and 1.34×, respectively, across a set of real-world DL models,
including several from the MLPerf suite [27].

2 FRAMEWORK DESIGN OVERVIEW
Deep learning frameworks have lowered the programming effort for DL researchers and decreased
prototyping time for new models. Abstraction provided by these frameworks hides some design
choices, such as run-time scheduling and actual implementation of operators, which may not be
noticeable by users but are important for performance. In this section, we describe how deep learning
framework design choices (Section 2.1) exploit parallelism opportunities exposed in deep learning
workloads (Section 2.2), and overview our framework parameter tuning methodology (Section 2.3).
We also discuss related work. While this work focuses on inference, our analysis and takeaways can
be applied for training as well. Thus we demonstrate both inference and training.

Our performance analysis focuses on CPUs, which are the most widely-used platforms serving
ML workloads in datacenters [15, 17]. Performance improvement directly translates into capacity
efficiency improvement. As we will see, DL frameworks offer a large set of tradeoffs to exploit paral-
lelism that lead to significant optimization opportunities on CPUs. On the other hand, frameworks
for accelerators such as GPUs expose less performance knobs for users, because mapping compute
kernels to accelerators introduces less variability than mapping to general purpose processors. As
developers focusing on accelerating a handful of compute kernels for deep learning, the kernel
computation will be increasingly faster and the framework overhead will take larger fraction. At this
point, efficient designs of framework is especially important, and the lessons learnt from parallelizing
CPU frameworks can be transferred to frameworks for accelerators.

2.1 Design Features
Figure 2 presents the stack of DL frameworks and design features that we study. This work focuses
on frameworks with opaque operators, i.e., operators or kernels that are manually written and tuned
by engineers. It is a design adopted by popular DL frameworks such as TensorFlow, Keras, Pytorch
and Caffe2. Frameworks such as Tensor Comprehensions [34], TVM [9], and Julia [5] do not belong
to this category since they generate kernels. The configurations they explore are usually not exposed

2https://github.com/Emma926/mcbench

3

to model developers at the framework level such as the ones in Figure 2. Thus, the designs of those
frameworks differ in important ways that put them out of the scope of this paper.

The design feature study in this work distinguishes itself from previous work that focus on
framework-level comparison without revealing the root causes of the performance difference, in-
cluding [4, 22, 30]. This work emphasizes that the performance difference of frameworks originates
from their different design choices, such as the ones in Figure 2. This applies to different versions
of the same framework, such as TensorFlow 1 and 2. The insights from analyzing TensorFlow 1
are applicable to TensorFlow 2 because they share the same design features and the performance
difference is caused by their different choices.
Scheduler Here “scheduler” refers to the operator scheduler, not the process scheduler of the
OS. It takes a computational graph representing the DL workload and schedules its operators
based on dependencies and hardware resources. Two common approaches are synchronous and
asynchronous scheduling. Synchronous scheduling schedules one operator at a time. Asynchronous
scheduling schedules all operators in ready state, such that the operators can execute in parallel if
hardware resources are available. In the example of Figure 2, asynchronous scheduling is faster than
synchronous scheduling, assuming unlimited hardware units. However as we will show in Section 4,
given limited hardware resources, the optimal mechanism usually falls between the two extremes.
Operator Frameworks include both native operators and operators based on library kernels. The
way operators make use of kernels can have a surprisingly large impact on performance. For
example, Figure 2 shows two potential implementations of a MatMul operator based on library
kernel MATMUL, to implement the MatMul operator at the framework level. The right one passes
arguments as is to MATMUL. The left one splits matrix x into smaller blocks and passes each block
to a thread in a thread pool. We will show in Section 5.2 that the latter performs better because it
parallelizes data preparation before entering the MATMUL kernel.
Library Mathematical libraries provide efficient parallel implementations of common kernels. We
study three widely-used libraries: MKL, MKL-DNN and Eigen. A thread pool manages a number
of threads that execute tasks upon request. Besides the thread pools used by math libraries, DL
frameworks use additional thread pools to parallelize computations outside of the math kernels. We
study thread pool implementations in the C standard library, Eigen, and Folly.
Beyond One-Socket Parallelism mechanisms need to be applied based on workloads. Common
mechanisms include data and model parallelism.

2.2 Parallelism Opportunities
A DL workload can be expressed with a computational graph, where a node represents an operator,
and an edge indicates the dataflow dependencies between operators [2]. DL workloads expose
the parallelism within an operator (intra-operator), between operators (inter-operator), and among
requests. Efficient framework designs should exploit such opportunities.

2.2.1 Parallelism within an Operator. Operators manipulate tensors, i.e., n-dimensional arrays. The
parallelism within an operator (intra-operator parallelism) can be exploited with the following
techniques.
SIMD The use of single instruction multiple data (SIMD) architectures, e.g., Intel’s AVX instruc-
tions [26], is implemented in mathematics libraries. The MKL, MKL-DNN, and Eigen libraries can
use AVX2 and AVX512 instructions.
Multi-Threading Multi-threading is implemented at the operator and library levels. For example,
MKL uses OpenMP for multi-threading. At the operator level, a framework may have a separate
thread pool for further parallelism.

4

Data Parallelism Data parallelism splits one batch of data into multiple smaller batches. Thus it can
improve performance of large-batch workloads.

2.2.2 Parallelism between Operators. The parallelism across operators (inter-operator parallelism)
can be exploited by scheduling and model parallelism.
Scheduling Asynchronous scheduling is to place independent operators on different hardware units
such as CPU threads, GPU stream multi-processors, or processing elements in accelerators. This way
independent operators can execute in parallel.
Model Parallelism Model parallelism is realized by scheduling different operators (or the same
operator after splitting along the model size dimension) on different hardware sockets or nodes, such
as distributing large embedding tables across hardware nodes [13].
Model Pipelining Model pipelining is a special case of model parallelism [7]. One hardware node
receives data from a previous node and operates on it while the previous node is computing the next
training step. In contrast to data parallelism, model parallelism lowers the memory requirement for
large models. This work does not study model pipelining.

2.2.3 Parallelism among Requests. Parallelism among requests can be exploited by batching, to
transform request-level parallelism to intra-op parallelism. For example, multiple image classification
requests can be combined and executed in a single session, such that the number of requests is
mapped to the batch size dimension.

2.3 Framework Parameter Tuning
Based on our analysis of design features and parallelism opportunities, we reduce the number of
design features needing to be selected from five (scheduling mechanism, operator design, math
library, thread pool library, parallelism mechanism) to one, the number of asynchronous scheduling
thread pools. Other features, such as operator parallelism, follow from that choice. We propose simple
guidelines for tuning framework features based on a model’s inter-operator parallelism, as reflected in
its computational graph. To demonstrate their usability, we integrate the guidelines with TensorFlow,
and achieve 1.29× and 1.34× speedup over Intel [3] and TensorFlow [14] recommended settings,
respectively. We also achieve the same average performance as with globally optimal settings and
95% of globally optimal performance in the worse case. We have developed a TensorFlow plugin
that sets framework parameters automatically, and it is available on GitHub.3 Details are in Section 8.
Previous work proposed to tune TensorFlow parameters automatically [16], which treats the tuning
process as a black box and therefore does not explain how parameters affect performance. Our work
differs in three ways. First, our tuning method is supported by strong analysis. A deep understanding
of framework designs and the root causes of performance difference makes our tuning method
intuitive and lightweight. Second, performance with our worst-case settings differs by less than 5%
from the global optimum obtained by exhaustive search, while previous work [16] reports large
performance degradation. Finally, the robustness of our guidelines, is validated on a different set
of real-world DL workloads using a state-of-the-art two-socket system. Our evaluation highlights
the importance of framework parameter tuning for state-of-the-art translation and recommendation
models.

3 EXPERIMENTAL SETUP
Our scripts and workloads are available on GitHub, together with the TensorFlow plugin.
CPU Platforms We use three Intel Skylake CPU platforms, small, large, and large.2. large.2 contains
two sockets of large with a peak bi-directional bandwidth of 120 GB/s. large and large.2 represent

3https://github.com/Emma926/mcbench

5

widely-used datacenter servers. small has fewer cores; we use it to eliminate threading overhead
for certain studies. We use large and small for most of the analysis where the performance tuning
guidelines are summarized, and large.2 for the evaluation of the guidelines. small has 32 fused
multiply-add (FMA) units per core, while large has 64 per core. Although all of the platforms support
hyperthreading, each core has only one set of FMA units, which limits the benefits of hyperthreading
if both hyperthreads need FMA units. The specifications are summarized in Table 1. large and
large.2 are Amazon Web Services m5.metal instances. Unless otherwise specified, we use the large
platform.

SKU
i7-6700k
Platinum 8175M

small
large
* Estimated with GeekBench v4 [25].

Cores TFLOPS
0.423*
1.64*

4
24

Freq
4 GHz
2.5 GHz

LLC
8 MB
33 MB

Table 1. Hardware platforms under study. An additional platform is large.2 that contains two sockets of
large with a 120GB/s bi-directional UPI bandwidth at peak.

Frameworks Because TensorFlow supports all features, we use TensorFlow v1.13 with the MKL-
DNN back end, unless otherwise specified. Conducting the same experiments with PyTorch (Caffe2
module) shows similar trends, so in this paper we focus on TensorFlow. We set thread affinity to
prioritize binding one software thread with one physical core [3].
Workloads We use a set of production-size deep learning models, including three from MLPerf [27]
(ResNet-50 [18], Transformer [35], neural collaborative filtering (NCF) [19]), as well as DenseNet [20],
SqueezeNet [21], Inception [33], GoogLeNet [32], CaffeNet [23], ResNext [37], and Google’s Wide
& Deep Learning model [10]. To deeply understand the design features, we use micro-benchmarks
such as matrix multiplication. We use a subset of the aforementioned models to focus our evaluation
on the respective design features (Sections 4 and 5). We hold out all the non-vision models for
Section 8 to evaluate the proposed method.
Methodology Our profiling methodology enables thorough analysis. We produce time breakdowns
(stack bars) for individual CPU cores using Linux’s perf record and profiling one core at a time.
Using floating-point performance counters, we measure performance as floating-point operations per
second (FLOPS). We trace execution with performance counters by sampling instructions per cycle
(IPC) every few milliseconds and ordering the samples by time stamps. The perf stat command
with the topdown option produces the top-down breakdown. LLC misses, memory, and UPI traffic
come from the corresponding performance counters.
Terminology Here are some terms used often later on.
• MKL Threads: the threads for MKL and MKL-DNN. Abbreviated intra-op threads.
• Inter-Operator Pools: the independent thread pools in a framework, the size of each set by

intra-op threads. Abbreviated inter-op pools, or pools.

4 SCHEDULING MECHANISM
A deep learning model is expressed using a computational graph that represents the data flow
between operators. At run time, operator scheduling exposes optimization opportunities, such as
scheduling independent operators simultaneously. In this section we study the trade-offs of using
such inter-operator parallelism4. We show that not all models benefit from asynchronous scheduling,
and that the best setting depends on a model’s inter-operator parallelism, quantified by the width of
its computational graph.

4The experiments are conducted with the real-world workloads implemented in Caffe2, because the Inception architecture is
important for this study, and the Caffe2 model zoo makes it more convenient to use Inception.

6

(a) Synchronous

(b) Asynchronous

(c) Thread Pools

Fig. 3. Examples of (a) synchronous scheduling, (b) asynchronous scheduling, and (c) using one and four
thread pools, with the same total hardware resources.

Fig. 4. (Bar Chart) The speedup of using asynchronous scheduling over synchronous. (Table) The maximum
computational graph width and best numbers of thread pools. Workloads with more branches benefit from
more pools.

Figure 3 shows examples of synchronous and asynchronous scheduling of an Inception mod-
ule [33], and the use of one and four thread pools. Scheduling of an operator is to submit the job to a
thread pool. Sometimes asynchronous scheduling, i.e., running multiple operators simultaneously,
can improve performance. For the simple example shown, scheduling one operator at a time takes nine
steps to finish (Figure 3a); scheduling four operators at a time reduces the steps to five (Figure 3b).
One simple implementation is to create several thread pools of the same size to share the computing
hardware (Figure 3c), and to schedule independent operators asynchronously to the thread pools.
This design is adopted by popular DL frameworks. In TensorFlow, the number of asynchronous
thread pools is called the number of inter-operator threads. Caffe2 calls it the asynchronous thread
pool size. In this paper, we refer to it as the inter-op pools, as opposed to intra-op threads. We will
show that synchronous scheduling is beneficial in both single-socket and multi-socket systems. The
best performance is achieved by balancing intra- and inter-operator parallelism.

4.1 Datacenter Platform Performance
We show that the best number of thread pools is no more than the maximum number of parallel
operators for a model. We use the large platform in Table 1.

Figure 4’s bar chart shows the speedup of asynchronous scheduling on different production-size
inference and training workloads. The baseline is synchronous scheduling, using one thread pool
of size 24. Inference uses three thread pools, each with 8 threads; training uses two pools, each
with 12 threads. Workloads benefit from asynchronous scheduling differently. Inception v1 and v2,
GoogLeNet, ResNet, and FC-512 speed up more than others.

7

CaffeSqueezeGoogleIncepV1IncepV2ResNextFC-512*FC-4k**0.00.51.01.5PerformanceInference, 3 PoolsTraining, 2 PoolsMax Width12444222Best Pools11,22,32,32,31,21,21* Similar size with the FC layers in YouTube and Facebook recommendation models.** Similar size with the FC layers in Transformer.Batch Size = 16Sync SchedulingAsync SchedulingFig. 5. (a) Inception v2 architecture contains modules with four (b) and three (c) independent branches. Area
1 exhibits inter- and intra-op parallelism and area 2 only intra-op.

The performance difference is because of the intrinsic inter-op parallelism of the models, which is
quantified by the width, or the number of branches, of their computational graphs. It measures the
number of operators that can be scheduled in parallel. The table at the bottom of Figure 4 summarizes
the maximum graph width and the best numbers of pools for varying batch sizes. We distinguish
between inference and training workloads because the computational graphs of training workloads
contain gradient and sum weight operators, which doubles the number of parallel operators. An
intrinsic model limitation is that the best numbers of pools (for varying batch sizes) do not exceed
the maximum graph width. The best number of pools varies based on batch sizes. Large batches
increase the best number of pools for inference, but decrease it for training. That is because the
parallel operators for training, gradient and sum weight, become imbalanced with large batches.
Gradient becomes much compute-intensive than sum weight. Allocating computing resources evenly
for the two hurts performance.

4.2 Inception v2 Case Study
To highlight parallelism opportunities at the intra- and inter-op levels, we use Inception v2 as an
example. Its model architecture contains operator branches that can execute in parallel. In the baseline
implementations that either schedule each branch naively to one CPU core or schedule one operator to
all CPU cores, workload imbalance and synchronization overhead significantly reduce performance.
We show that synchronization overhead can be mitigated by choosing the number/size of thread
pools to better balance intra- and inter-operator parallelism. We use the small platform in Table 1, as
it enables an exhaustive study of possible cases.
Inception v2 Architecture To simplify the explanation of later results, we first summarize the
Inception v2 architecture [33] in Figure 5. Figure 5a shows the top level architecture, color coded as
areas 1 and 2. Area 1 exhibits both intra- and inter-op parallelism, while area 2 only has intra-op
parallelism. Area 1 contains two inception modules. Module 4 has four branches (Figure 5b) and
module 3 has three (Figure 5c). The convolution operators are converted to MatMul using im2col(),
so intensive computation is mostly MatMul.
Performance Scaling with Pools and Threads Figure 6 shows the relative performance of Inception
v2 with a batch size of 16, sweeping inter-op pools and MKL threads per pool. The total number of

8

Conv 7⨉7Module 4Conv 3⨉3Conv 3⨉3Module 3Module 4Module 3Module 4MatMulMath ⨉ 5Math ⨉ 5Math ⨉ 5Math ⨉ 5SoftMax⨉ 2⨉ 4⨉ 2(a)Inception v2ConcatMath ⨉ 4Conv 3⨉3Math ⨉ 4Conv 3⨉3Math ⨉ 4Conv 3⨉3Math ⨉ 4Conv 3⨉3Math ⨉ 4Conv 3⨉3Math ⨉ 4Conv 3⨉3Math ⨉ 4Conv 3⨉3PoolConcat“Math” operators are single-threaded, including SpatialBN, Mul, Add, Relu and MaxPool.Conv is converted to MatMul using im2col().            Compute-intensive operators, using MKL sgemm kernel with AVX instructions.ConcatMath ⨉ 4Conv 3⨉3Math ⨉ 4Conv 3⨉3Math ⨉ 4Conv 3⨉3Math ⨉ 4Conv 3⨉3Math ⨉ 4Conv 3⨉3PoolConcat(b) Module 4(c) Module 3212Fig. 6. Performance of Inception v2 with different numbers of inter-op pools and MKL threads per pool. Best
configuration balances intra- and inter-op parallelism.

Fig. 7. Execution time breakdown of four cases.

threads on the system is the product of the two. Hyperthreads are used when more than four threads
are created. Exceeding eight threads is labeled over-threading because there are more software
threads than hardware threads. (Scaling is similar with batch sizes from 1 to 128.)

Hyperthreading does not improve performance significantly, such as [4,1] vs [4,2], and [1,4] vs
[2,4] ([Threads, Pools]). The compute-intensive operators, Convs and MatMuls, are bottlenecked by
the fused multiply-accumulate (FMA) units, which are shared between hyperthreads on the same
core.

As expected, over-threading, i.e., using more software threads than hardware threads, hurts the
performance, because threading overhead increases with more software threads, and computing
resources are saturated. As a result, simply setting all framework knobs to the maximum does not
yield the best performance.

Performance is best with two pools and two threads per pool. Using four total threads in other
ways, such as four pools with one thread each, or one pool with four threads, cannot achieve such
performance. Our profiling methodology reveals and visualizes the underlying causes in Figures 7
and 8.
Run-Time Breakdown and Execution Traces We select four cases, a baseline that uses only one
thread, and three cases that each use four threads in total. One software thread is bound to one
CPU core. Figure 7 shows the aggregate time breakdown, and Figure 8 shows the corresponding
execution traces. In Figure 8, one iteration of Inception v2 inference is marked with red bars, and
operators in execution are labeled with the corresponding color in Figure 5, where area 1 exhibits

9

1234MKL Thread4321Inter-Op Pool11.471.561.591.371.971.881.691.561.841.411.461.711.761.651.61HyperthreadingOver-Threading1.01.21.41.61.801/41/32/31Relative Latency   MKL Threads1            1         4          2Inter-Op Pools1            4         1          2CPU Cores0 --> 3SyncCaffe2Caffe2:MathThreadpoolMKL(a) Execution traces of 4 inter-op pools, 1 MKL threads

(b) Execution traces of 1 inter-Op pools, 4 MKL threads

(c) Execution traces of 2 inter-op pools, 2 MKL threads

Fig. 8. Execution traces of three cases in Figure 7. Color-coded areas 1 and 2 correspond to the operators in
Figure 5.

intra- and inter-op parallelism, and area 2 has only intra-op parallelism. The fraction of time each
core spent executing (rather than synchronizing) is indicated to the right of each trace. It matches the
breakdowns in Figure 7.

The first case, using four pools of size one, incurs high synchronization overhead in Figure 7 and
Figure 8a, primarily because the operators in area 2, with only intra-op parallelism, are assigned only
one core (thread), and other cores are waiting to synchronize. The trace in area 1 is slightly better,
with every core executing one branch of each inception module.

The second case, using one pool with four threads, does not perform well either, because the Caffe2-
native operations (the parts labeled as Caffe2 and Caffe2:Math in Figure 7) are single-threaded, and
other cores are stalled by core 0, as shown by the long synchronization time in the rightmost three
bars of Figure 7 and the traces of cores 1–3 in Figure 8b.

The third case, using two pools, each with two threads, is a better balance. It reduces synchroniza-
tion time in both area 1 and area 2 compared to the first case. Area 1 is improved because the number
and size of convolutions in each inception branch is not even, as shown by Figure 5b, and allocating
one core for each branch (the first case) makes the core running the smallest branch wait for a long
time. Area 2 is improved because its operators are sequential and compute-intensive, and having
more cores improves performance.
Optimization Opportunity Operators in a complex model come in different sizes and have different
dependencies. Fixing each thread pool size usually incurs synchronization overhead because of work
imbalance. Thus there is an opportunity to implement a global thread pool, allowing the scheduler to
determine dynamically how many threads to schedule for each operator. For example, in the traces
of Figure 5, providing area 1 with two pools of two threads each and area 2 with one pool of four
threads can lead to higher performance.

10

0510152025303210CoreExe%31414633|1 Interation |12SynchronizationExecution0510152025301-309425051015202530Time (seconds)3210Core6537754012Fig. 9. Speedup from using 24 MKL threads instead of one. TensorFlow exhibits lower speedups than MKL.

5 OPERATOR DESIGN
Operators are building blocks of DL frameworks, providing basic semantics through high-level
language (like Python) APIs to ease the development process for framework users. As shown in
Figure 1, a workload built with a DL framework involves library kernels and framework native
computation. In this section, we show that efficient operator design can speed up framework native
computation, and yields up to 4.2× performance improvement for real-world models.
Implementations of Framework Native Operators We first describe framework native operators,
the operators that do not use library kernels. Native operators handle control flow as well as ten-
sor reshaping, broadcasting, and preprocessing. Some, like those for control flow or input image
preprocessing, are necessary. Others can fairly be described as a framework programmability tax.
The overhead stems from preparing inputs for library kernels, or computing how to parallelize a
given workload in the main thread. One example of the latter kind is Eigen::ParallelFor, used by
TensorFlow.
Implementations of Compute-Intensive Operators A framework operator must sometimes do
more than simply pass arguments to library kernels. Data preparation is often required, for example.
Taking matrix multiplication (MatMul) as an example, we list two implementations below. In the
context of deep learning, x is an input matrix of size [batch size × number of activations] and w is a
weight matrix of size [activations in current layer × activations in next layer]. We assume MatMul is
the interface of a framework operator, and MATMUL is the corresponding library kernel, e.g., in
MKL.

Sec 5.1) MatMul1(x, w):

data_prep(x, w)
return MATMUL(x, w)

Sec 5.2)

MatMul2(x, w):

// Reshape x, w into bx and bw
for bx, bw in x, w:

threadpool.run(MatMul1,
bx, bw)

return threadpool.join_results()

MatMul1 conducts data preparation and passes the matrices to the library kernel. MatMul2 uses
an additional thread pool that we call the intra-operator thread pool, to distinguish it from the MKL
thread pool. The operator splits the matrices into smaller ones, and passes those small matrices to the
intra-op thread pool. The intra-op thread pool then executes multiple copies of MatMul1 in parallel.
This way data_prep() of the whole matrix can be parallelized. Before and after the library call, the
data formatting and results gathering work is part of the programmability tax. We will study the two
implementations in the following subsections.

11

1282565121k2k4k8k16kMatrix Size0510131624SpeedupTensorFlowMKLFig. 10. Run-time breakdown for all CPU cores. Data preparation overhead causes the poor scalability in
Figure 9.

5.1 MKL Threads
By analyzing the overhead and scalability of the first operator implementation, MatMul1, we show
that both the TensorFlow (TF) operator and the MKL kernel suffer from data preparation overhead,
which prevents them from scaling linearly with the number of CPU cores. The results here can
also apply when convolution operators are converted to MatMuls using im2col(). We use the large
platform in Table 1.
Performance Scaling Both TF and MKL have scaling issues, and TF is slightly worse. Figure 9
shows the speedup of using 24 MKL threads over using one, for both TF operators and MKL kernels.
The matrices are squared and represented by one dimension. The total number of floating-point
operations is the cube of that number. Figure 9 shows that the speedup of TF is always lower than
that of MKL, especially for small matrices. TF speedup is comparable to MKL when matrices are
larger than 4k. The maximum speedup achievable is about 16×, which is lower than the number of
cores, 24.
Causes of the Poor Scalability Our profiling methodology reveals that data preparation overhead
causes suboptimal performance scaling. We pick two variants of MatMul, MatMul-512 and MatMul-
4k, that operate on medium- and large-size matrices, respectively. MatMul-512 represents the fully-
connected (FC) layers from YouTube [11] and Facebook recommendation [15, 28] models, while
MatMul-4k represents the FC layers in Transformer [35]. Figure 10 shows the run-time breakdown
of all CPU cores running the MatMuls, using 1 and 24 MKL threads. With multiple threads, the
thread tasked with lengthy TF data preparation is the main thread, labeled CPU Core 0. The latency
of each MatMul workload is normalized to that of using one MKL thread.

The TF parts of Figure 10 show that TF’s scaling issue is caused by framework overhead, due
mainly to TF data preparation for MKL kernels. Using one MKL thread, MatMul-512 spends over
10% of its time in TF data preparation; using 24 MKL threads, the overhead exceeds 72%. Overhead
is much lower for MatMul-4k: less than 3% in both cases. Without TF overhead, speedup can clearly
be much greater. The MKL parts of Figure 10 show that MKL data preparation causes the scaling
issue for MKL kernels. MKL kernel execution time is roughly 1/24 of the original run-time for
MatMul-512. Speedup drops with time spent in MKL data preparation.
The Role of Framework Design The Amdahl’s law bottleneck of DL frameworks is non-negligible.
The overhead a MatMul with size n × n × n scales linearly with n (O(n)), while the number of
floating-point operations scales cubically (O(n3)). Thus the speedup of large MatMuls (e.g., 4k) is
closer to ideal speedup. Realistically, however, the most commonly-used FC layers are not always
large enough. Actually smaller ones are common in commercial workloads including YouTube’s [11]
recommendation model (of size 256 to 1k) and Facebook’s [15, 28] (of size 64 to 512). Especially
when hardware platforms are upgraded to higher floating-point computation capability, we need even

12

124124MKL Threads01/120.30.50.751Relative LatencyMatMul-512MatMul-4kCPU Cores01-23OtherTF BarrierTF Data PrepMKL Data PrepMKL KernelFig. 11. Run-time breakdown of TensorFlow workloads with 1 (left bar) and 24 (right bar) intra-op threads.
Both cases use 24 MKL threads.

Fig. 12. Run-time breakdown of all CPU cores. Intra-op threads parallelize the overhead in cores 24-47.

larger matrices to amortize the overhead. Thus it is key to focus optimization efforts on mitigating
framework overhead.

5.2 Intra-Operator Threads
After decades of optimizing the GEMM kernel, the performance bottleneck has shifted to the
overhead of using such kernels, e.g., the data preparation overhead in Figure 10. A natural approach
to reducing the overhead in framework design is to parallelize the framework native computation,
with an intra-operator thread pool implemented at the framework level, as MatMul2 does. We show
that when library kernels are using FMA units, intra-op threads improve performance by utilizing
other computational units on the same physical core, thereby benefiting from Intel’s hyperthreading
technology. We use the large platform from Table 1.
Performance Improvement We first show how much performance improvement intra-op threads
can yield and where it comes from. Figure 11 summarizes speedup and time breakdown when using
1 (left bar) and 24 (right bar) intra-op threads. Both cases use 24 MKL threads. MatMul-512 and
MatMul-4k are the same operators as in previous sections. Using 24 intra-op threads reduces the
execution time of TF native operators, while that of other parts stays similar. The speedup ranges
from 1.05× (DenseNet) to 4.21× (SqueezeNet).

Workloads bottlenecked by TF native operators benefit more from intra-op threads. Such workloads,
including MatMul-512 and SqueezeNet, have small to medium MatMul or convolution operations,
because TF native operators are likely to consume larger fractions of computation time. For example,

13

MatM-512*MatM-4k**DenseNetResNetSqueeze00.20.40.60.81Relative Latency* Similar size with the FC layers in YouTube and Facebook recommendation models.** Similar size with the FC layers in Transformer.1.78x1.24x1.05x1.90x4.21xSyncPy OverheadTF BarrierTF Native OpOpenMPMKL124124Intra-op Threads00.20.40.60.81Relative LatencyMatMul=512MatMul=4kCPU Cores01-2324-47Sync + OtherTF BarrierTF Data PrepOpenMPMKL Data PrepMKL Kernel(a) Cycle Breakdown

(b) LLC MPKI

(c) BW (GB/s)

Fig. 13. (a) Cycle breakdown (bottom axis) and IPC (top axis) for three libraries multiplying matrices of
various sizes. MKL has the highest retiring ratio and IPC, because it is the least back-end bound. (b) MKL has
the lowest LLC miss rate. (c) The memory bandwidth consumption. MKL’s prefetching is the most effective:
almost all memory traffic is prefetching.

SqueezeNet has a small percentage of MKL computation since it is designed to have fewer parameters
than AlexNet by using many small (1x1) convolution kernels [21].
Programmability Tax Figure 11 also quantifies the framework programmability tax. We estimate the
tax using the non-MKL fractions, since they are not compute-intensive and can be largely optimized
if written with high-performance language/code as MKL kernels. After optimizing with intra-op
threads, the programmability tax ranges from 1.3% (DenseNet) to 63% (MatMul-512). SqueezeNet
(47%) is higher than ResNet-50 (26%). MatMul-4k (11%) is slightly smaller. This is the price we are
paying for using frameworks.
Full-System Profiling Our profiling methodology visualizes the execution of every core on the CPU
platform to expose the reasons for performance improvement. Figure 12 shows the time breakdown
for all 48 hyperthreads on the large platform. We focus on the two MatMuls, since they are the
simplest workloads. Because cores 24-47 are not active when using one intra-op thread, the third bar
is omitted for that case. Core 0 of each case is the same as in Figure 11.

Figure 12 shows that with 24 intra-op threads, TF data preparation is distributed to cores 24
through 47. (The bottom of the third bar for MatMul-512 with 24 intra-op threads shows a tiny
TF data preparation cost.) That shortens TF data preparation time in core 0, so that the TF barrier
time of cores 1 to 23 is shortened. With only one intra-op thread, cores 1 to 23 spend about 60%
(MatMul-512) and 40% (MatMul-4k) of time waiting in barrier, which is a big waste.
Hyperthreading Using intra-op threads takes advantage of Intel’s hyperthreading technology by
colocating an intra-op thread and an MKL thread on the same physical core. Since they need
different hardware resources, they can execute in parallel without contention. The critical path is
the MKL thread. The intra-op thread adds no execution time to the overall workload. For example,
in Figure 12, logical cores 0 and 24 are on the same physical core. Core 0 executes mostly MKL
floating-point operations with FMA units, which core 24 does not need. Even without hyperthreading,
the implementation of intra-op threads improves performance through parallelization. In that case,
the physical core’s critical path combines the intra-op thread with the MKL thread.

6 LIBRARY CHOICE
Thanks to the mathematics and thread pool libraries, deep learning framework developers do not
have to implement every basic functions from scratch. In this section we study libraries for machine

14

0204060801001282565121k2k4k8k16k32kMatrix SizeRetiringBad SpeculationFront-end BoundBack-end Bound01234IPC0.00.5EigenMKL-DNNMKL0581012Fig. 14. Thread pool overhead, measured as time to run 10k micro tasks. Folly outperforms std::thread and
Eigen even in an extreme case with 64 threads on a 4-core CPU.

learning and thread pools. We show that optimization can improve a GEMM kernel’s performance
by up to 25%, owing to more efficient data prefetching. We also find that robust thread pools such as
Eigen and Folly are better able to keep production-critical workloads running with little variation,
thus investing in sophisticated implementations is worthwhile for service providers.

6.1 Machine Learning Library
We compare MKL, MKL-DNN, and Eigen with GEMM (general matrix multiplication) microbench-
marks on the small platform (Table 1) to expose architectural bottlenecks.

We conduct top-down analysis [38] for single-threaded GEMM kernels with a variety of matrix
sizes. Figure 13a shows the cycle breakdown (stacked bars) and IPC (dots). The three bars shown
for each matrix size are for Eigen, MKL-DNN, and MKL, from top to bottom. For GEMM, MKL
performs the best, followed by MKL-DNN. With matrices larger than 4k, about 25% of cycles are
back-end bound for Eigen and MKL-DNN.

The back-end bottleneck is caused by last-level-cache (LLC) misses, shown as LLC misses per
thousand instructions (MPKI) in Figure 13b. Eigen and MKL-DNN have much higher LLC MPKI
than MKL. The LLC miss rate difference is caused by the aggressiveness and effectiveness of data
prefetching, shown by the memory traffic in Figure 13c, where the right ends of the bars show
memory traffic incurred by LLC misses. MKL’s memory traffic is close to that of MKL-DNN, and
its much lower LLC miss rate shows that MKL’s software prefetching is more effective.

We compare the GEMM kernels to demonstrate how and why kernel performance can vary. MKL-
DNN is likely outperform other libraries for other kernels, because it is a library targeting deep
learning with DL-specific optimizations. It reportedly outperforms other frameworks [6].

6.2 Thread Pool Library
We compare three thread pools, one simple implementation using std::thread, and the thread pools
in Eigen [12] and Folly [1]. Our microbenchmark creates a thread pool and starts 10k tasks that
increment the value of a globally shared variable. This microbenchmark examines the case where the
computation per thread is minimal and the synchronization between threads is the maximum. It is a
common way to stress-test thread pools such as in Pytorch5 as an isolation study. We benchmark in
two scenarios: (1) setting the number of threads to be the same as the number of physical cores, and
(2) using many more threads than the number of cores. We use the small platform from Table 1.

Figure 14 compares the overall latency of running 10k micro tasks. In both cases, Folly outperforms
Eigen and Eigen outperforms std::thread. When thread pool size is 64, greatly exceeding the number
of CPU cores, Folly and Eigen perform consistently well as with four threads, and oversubscribing
the system does not drastically increase the overhead. But the overhead of std::thread increases by
over 3×, with every CPU core spending about 60% of its time in synchronization.

5https://github.com/pytorch/pytorch/blob/master/binaries/at_launch_benchmark.cc

15

stdEigenFollystdEigenFollyThreads = 4                  Threads = 640.00.10.20.3SecondsFig. 15. A two-socket platform speeds up ResNet-50 by 1.43×. The bottleneck is the UPI bandwidth, increasing
TF data preparation time as part of the TF native operator time.

7 BEYOND ONE SOCKET
In previous sections we have explored the framework designs on one-socket CPUs. In this section,
we study how those design features can be applied to scale out the workloads beyond one socket.
Unsurprisingly, the bottleneck of a two-socket system is the UPI bandwidth between sockets. We
study scaling one operator to two sockets and scheduling multiple operators to different sockets, as
scaling-out versions of intra- and inter-op parallelism studies. The experiments are conducted on the
large and large.2 platforms from Table 1.

7.1 Data Parallelism
We study data parallelism by setting the numbers of intra-op and MKL threads to the total number of
physical cores and the number of inter-op threads to one.
ResNet Performance Figure 15 shows the execution time breakdown of ResNet-50 running on one-
and two-socket platforms. The latter speeds up ResNet by 1.43×, less than the two-fold hardware
increase. The bottleneck is that UPI traffic peaks at 91.4GB/s, compared to the theoretical maximum
of 120GB/s. UPI saturation increases the latency of TF native operators on a two-socket platform,
which now includes both data preparation and transfer time between sockets.
MatMul Performance To test the limit of the large.2 platform, we conduct microbenchmarking
using TensorFlow MatMul operators. Similarly, the UPI bandwidth is the bottleneck for large
MatMuls. Figure 16 shows two-socket speedup and corresponding UPI bandwidth consumption.
The speedup and UPI throughput increase with larger MatMul sizes, and peak for MatMul-8k. For
MatMul-16k, speedup decreases and bandwidth saturates, indicating empirically the maximum UPI
bandwidth is around 100GB/s for such workloads.

The speedup of a workload is determined by its intrinsic parallelism and UPI bandwidth saturation.
Figure 17 shows the time breakdown of MatMuls running on one- and two-socket platforms. For
medium MatMul sizes like 512, the poor scalability is caused by the limited parallelism of the
workload, which cannot hide data preparation overhead. For larger MatMuls, 4k and 8k, the data
preparation time of both TF and MKL increases on the two-socket platform because of UPI saturation.
MatMul-8k has the best balance of intrinsic parallelism and UPI throughput. It leads to the highest
speedup (1.8×, i.e., 44% less execution time than with just one socket), which is close to perfect
scaling.

7.2 Model Parallelism
We study model parallelism of a two-socket platform by using two inter-op pools, one per CPU
socket. Model parallelism improves performance significantly when the parallel operators are on

16

1-Socket2-Sockets00.250.50.751Relative LatencyCore0RestCores1.43XUPI Bdw: 91.4 GB/sOtherTF BarrierOpenMPTF Native OpMKL-DNN(a) Two-Socket Speedup

(b) UPI Traffic

Fig. 16. (a) Speedup of a two-socket platform over one socket. (b) Measured peak UPI bandwidth consumption
on the two-socket platform is close to 100GB/s.

Fig. 17. Run-time breakdown of all CPU cores.

critical paths and have similar sizes, as with multiple embedding operators in neural collaborative
filtering (NCF). Performance and model parallelism mechanisms will be discussed in the next section.
Model parallelism does not always improve performance. One example is the inter-op parallelism
from training workloads, as in Section 4. Assigning gradient and weight sum operators one socket
each causes workload imbalance between two sockets when batch size is large. Two-socket platforms
are not beneficial when the intra-op thread pool is not implemented at the framework level, since the
workload bottleneck is single-threaded operators.

8 FRAMEWORK DESIGN TUNING
At the outset, we identified five design features: scheduling mechanism, operator implementation,
math library, thread pool library, and the parallelism mechanism for platforms larger than one socket.
Our analysis has shown that the most effective setting for users to determine is the proper number
of inter-op pools based on the model architecture. Intra-op parallelism configurations follow from
that setting. Based on the analysis in previous sections, we therefore propose a set of simple yet
effective guidelines. The guidelines are architecture-irrelevant, because they are summarized based
on software design analysis; thus they can be applied to CPUs with different architectures including
Intel, AMD and OpenPOWER.
Definitions To present the guidelines, we first define a few terminologies. Section 4.1 and Figure 4
mentioned the maximum width of a model graph. The average width of a model graph quantifies
its inter-op parallelism, and we use it to determine the number of inter-op pools for a model. The
average width of a model is the floor of the ratio of the total number of (heavy) operators divided by
the maximum number of layers. A heavy operator is a compute-intensive or embedding operator
that usually takes significantly longer execution time than other operators. Examples are the Conv
operators in Figure 5, as opposed to lightweight math operators, which are not considered. The
average model width of Figure 5b is ⌊ 7

3 ⌋ = 2.

17

5121k2k4k8k16k0.00.51.01.52.0Speedup5121k2k4k8k16k0100UPI BW (GB/s)ReadWrite121212Sockets00.250.500.751Relative LatencyMatMul-512MatMul-4kMatMul-8kCPU Cores0RestsOtherTF BarrierTF Data PrepOpenMPMKL Data PrepMKL KernelFig. 18. Performance using the recommended TensorFlow settings [14] (baseline), Intel blog [3], our work,
and global optimum obtained by exhaustive search. Our work outperforms Intel and Tensorflow suggestions
and nearly closes the gap between the state of the art and the global optimum.

Dense
1

Squeeze ResNet

IncepV3 W/D NCF Trans

1

1

2

3

4

4

Table 2. Average model width, i.e., the number of pools selected for Figure 18 based on our guidelines. Intra-op
and MKL threads = total physical cores divided by those numbers.

Guidelines The number of inter-op pools (p) is chosen to be the average model width. After p is
chosen, we choose the numbers of MKL and intra-op threads such that the entire system is split into
p partitions without redundant threads (Section 4.2 and Figure 6). Therefore, the number of MKL
threads and the number of intra-op threads for each thread pool should be equal to the total number
of physical cores on the system divided by p. That way one MKL thread and one intra-op thread can
share the same physical core. MKL threads can use the FMA units and the intra-op threads can use
other units via hyperthreading (Section 5.2 and Figure 12).
Evaluation Setup We integrate our guidelines with TensorFlow v1.13. (TensorFlow refers to inter-op
pools as inter-op parallelism threads.) We will open source the TensorFlow plugin to the public, to let
users apply our guidelines automatically. The size of the design space encompassing the numbers of
MKL, intra- and inter-op threads is the cube of the number of logical cores. For the large.2 system,
that means 963 = 884, 736 design points. Our guidelines suggest picking only one of those 884, 736
possibilities.

We evaluate our guidelines by applying the rules to a fresh set of workloads and by performing
the evaluation on a different platform from that used to develop the guidelines. Our analysis uses
microbenchmarks and vision models that run with images; for evaluation, we add Inception v3 [33],
the wide-deep recommendation model [10], the neural collaborative filtering model (NCF) [19], and
Transformer [35], covering recommendation and translation workloads. The bulk of our analysis

18

DenseNetResNetSqueezeNetInceptionV3NCFTransformerDenseNetResNetSqueezeNetInceptionV3Wide-DeepNCFTransformerAvg1Performance2InferenceTraining* TensorFlow: Intra-op/MKL threads = physical cores; inter-op pools = sockets.** Intel: Intra-op/MKL threads = physical cores per socket; inter-op pools = sockets.TensorFlow*Intel**This WorkGlobal Optimumuses platforms small and large from Table 1; here we evaluate the guidelines on the large.2 platform,
the largest AWS bare metal instance.
Speedup Figure 18 summarizes the speedup of this work over TensorFlow [14] (baseline) and
Intel [3] recommended settings. It also compares our settings’ performance to the global optimum
obtained by exhaustively sweeping the design space. TensorFlow suggests setting the number of
MKL and intra-op threads to the physical core count, and inter-op pools to the socket count. Intel
suggests setting MKL and intra-op threads to the number of physical cores per socket, and inter-op
pools to the socket count. Our analysis shows that TensorFlow suggests more threads than needed,
and Intel’s setting is suitable for models with an average width of two.

Overall, our performance guidelines perform consistently better than the settings recommended by
Intel and TensorFlow. Our method bridges the performance gap between those state-of-the-art settings
and the global optimum for all evaluated workloads except Inception inference and SqueezeNet
training. In those two cases, our guidelines achieve 95% of the performance offered by the global
optimal setting. On average, this work achieves the same performance as the global optimum, and
1.34× and 1.29× better performance than TensorFlow’s and Intel’s suggestions, respectively.

We summarize the average model width in Table 2. It is the same as the number of inter-op pools
in use. The models shown have average width between one and four, which is diverse. The numbers
of MKL and intra-op threads for each model is the total number of physical cores (48) divided by the
model width. For example, the setting for the W/D (wide and deep) model is 3 inter-op pools, 16
MKL threads, and 16 intra-op threads, which is also the globally optimal setting.

The performance guides from Intel and TensorFlow are general, aiming to make it easy for
most users to get reasonable performance, and they perform reasonably well. For vision models,
TensorFlow’s settings perform as well as the global optima and our guidelines, while Intel’s does
not perform well for the vision models except for Inception, because Intel’s setting favors models
with inter-op parallelism that other vision models do not have. Intel’s settings perform better than
TensorFlow’s for recommendation and translation models. The latter have several parallel embedding
operators, thus their average width is no less than two. The default TensorFlow setting performs
much worse than both the Intel and TensorFlow recommendations. TensorFlow naively sets all
parameters—MKL threads, intra-op threads, and inter-op pools—to the number of logical cores. As
pointed out in our earlier analysis, this is sub-optimal. Thus TensorFlow users who run only one
model and one session at a time should at least set the number of inter-op pools to one instead of
using the default setting.

9 CONCLUSION
We presented a detailed evaluation and analysis of key design features and the role of parallelism in a
machine learning framework, focusing on scheduling, operator implementation, and library back
ends. To maximize parallelism, we proposed simple guidelines for tuning framework parameters,
distilled from detailed domain-specific design feature knowledge and analysis. We demonstrated the
usability and the additional performance improvement of this approach by integrating and evaluating
our methodology with TensorFlow. On average, our method outperformed the suggested settings
from Intel and TensorFlow performance guides by 1.29× and 1.34×, respectively, across a set of
real-world DL models.

REFERENCES
[1] 2019. Folly: Facebook Open-source Library. https://github.com/facebook/folly.
[2] Martín Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat,
Geoffrey Irving, Michael Isard, et al. 2016. TensorFlow: A System for Large-Scale Machine Learning. In OSDI, Vol. 16.
265–283.

19

[3] P Anju. 2018. Tips to Improve Performance for Popular Deep Learning Frameworks on CPUs. Intel Developer Zone

(2018).

[4] Soheil Bahrampour, Naveen Ramakrishnan, Lukas Schott, and Mohak Shah. 2016. Comparative Study of Caffe, Neon,

Theano, and Torch for Deep Learning. (2016).

[5] Jeff Bezanson, Alan Edelman, Stefan Karpinski, and Viral B Shah. 2017. Julia: A Fresh Approach to Numerical

Computing. SIAM review 59, 1 (2017), 65–98.

[6] Ashraf Bhuiyan, Mahmoud Abuzaina, Niranjan Hasabnis, Niroop Ammbashankar, Faijul Amin, Sheng Fu, and Bhavani

Subramanian. [n.d.]. Improving TensorFlow Inference Performance on Intel Xeon Processors. Intel AI Blog ([n. d.]).
[7] Google AI Blog. 2019. Introducing GPipe, an Open Source Library for Efficiently Training Large-scale Neural Network

Models. https:// ai.googleblog.com/ 2019/ 03/ introducing-gpipe-open-source-library.html (2019).

[8] Tianqi Chen, Mu Li, Yutian Li, Min Lin, Naiyan Wang, Minjie Wang, Tianjun Xiao, Bing Xu, Chiyuan Zhang, and
Zheng Zhang. 2015. MXNet: A Flexible and Efficient Machine Learning Library for Heterogeneous Distributed Systems.
arXiv preprint arXiv:1512.01274 (2015).

[9] Tianqi Chen, Thierry Moreau, Ziheng Jiang, Lianmin Zheng, Eddie Yan, Haichen Shen, Meghan Cowan, Leyuan Wang,
Yuwei Hu, Luis Ceze, et al. 2018. {TVM}: An Automated end-to-end optimizing compiler for deep learning. In 13th
{USENIX} Symposium on Operating Systems Design and Implementation ({OSDI} 18). 578–594.

[10] Heng-Tze Cheng. [n.d.]. Wide and Deep Learning: Better Together with TensorFlow. Google AI Blog ([n. d.]).

https://ai.googleblog.com/2016/06/wide-deep-learning-better-together-with.html.

[11] Paul Covington, Jay Adams, and Emre Sargin. 2016. Deep Neural Networks for YouTube Recommendations. In

Proceedings of the 10th ACM conference on recommender systems. ACM, 191–198.

[12] Eigen. 2019. Eigen Thread Pool. (2019). https://bitbucket.org/eigen/eigen/src/default/unsupported/Eigen/CXX11/src/

ThreadPool/.

[13] Assaf Eisenman, Maxim Naumov, Darryl Gardner, Misha Smelyanskiy, Sergey Pupyrev, Kim Hazelwood, Asaf Cidon,
and Sachin Katti. 2018. Bandana: Using Non-Volatile Memory for Storing Deep Learning Models. arXiv preprint
arXiv:1811.05922 (2018).

[14] Google. 2019. TensorFlow Performance Guide. https://docs.w3cub.com/tensorflow~guide/performance/performance_

guide/#general_best_practices. TensorFlow Documentation.

[15] Udit Gupta, Xiaodong Wang, Maxim Naumov, Carole-Jean Wu, Brandon Reagen, David Brooks, Bradford Cottel, Kim
Hazelwood, Bill Jia, Hsien-Hsin S Lee, Andrey Malevich, Dheevatsa Mudigere, Mikhail Smelyanskiy, Liang Xiong, and
Xuan Zhang. 2019. The Architectural Implications of Facebook’s DNN-based Personalized Recommendation. arXiv
preprint arXiv:1906.03109 (2019).

[16] Niranjan Hasabnis. 2018. Auto-Tuning TensorFlow Threading Model for CPU Backend.

arXiv preprint

arXiv:1812.01665 (2018).

[17] Kim Hazelwood, Sarah Bird, David Brooks, Soumith Chintala, Utku Diril, Dmytro Dzhulgakov, Mohamed Fawzy,
Bill Jia, Yangqing Jia, Aditya Kalro, et al. 2018. Applied Machine Learning at Facebook: A Datacenter Infrastructure
Perspective. In High Performance Computer Architecture (HPCA), 2018 IEEE International Symposium on. IEEE,
620–629.

[18] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. 2016. Deep Residual Learning for Image Recognition. In

Proceedings of the IEEE conference on Computer Vision and Pattern Recognition. 770–778.

[19] Xiangnan He, Lizi Liao, Hanwang Zhang, Liqiang Nie, Xia Hu, and Tat-Seng Chua. 2017. Neural Collaborative Filtering.
In Proceedings of the 26th international conference on world wide web. International World Wide Web Conferences
Steering Committee, 173–182.

[20] Gao Huang, Zhuang Liu, Laurens Van Der Maaten, and Kilian Q Weinberger. 2017. Densely Connected Convolutional

Networks. In Proceedings of the IEEE conference on Computer Vision and Pattern Recognition. 4700–4708.

[21] Forrest N Iandola, Song Han, Matthew W Moskewicz, Khalid Ashraf, William J Dally, and Kurt Keutzer. 2016.
arXiv preprint

SqueezeNet: AlexNet-Level Accuracy with 50x Fewer Parameters and <0.5 MB Model Size.
arXiv:1602.07360 (2016).

[22] Arpan Jain, Ammar Ahmad Awan, Quentin Anthony, Hari Subramoni, and Dhableswar K DK Panda. 2019. Performance
characterization of dnn training using tensorflow and pytorch on modern clusters. In 2019 IEEE International Conference
on Cluster Computing (CLUSTER). IEEE, 1–11.

[23] Yangqing Jia, Evan Shelhamer, Jeff Donahue, Sergey Karayev, Jonathan Long, Ross Girshick, Sergio Guadarrama, and
Trevor Darrell. 2014. Caffe: Convolutional architecture for fast feature embedding. In Proceedings of the 22nd ACM
international conference on Multimedia. ACM, 675–678.

[24] Nikhil Ketkar. 2017. Introduction to PyTorch. In Deep Learning with Python. Springer, 195–208.
[25] Primate Labs. 2019. GeekBench v4. https://www.geekbench.com/.
[26] Chris Lomont. 2011. Introduction to Intel Advanced Vector Extensions. Intel White Paper (2011), 1–21.

20

[27] P. Mattson, V. J. Reddi, C. Cheng, C. Coleman, G. Diamos, D. Kanter, P. Micikevicius, D. Patterson, G. Schmuelling,
H. Tang, G. Wei, and Carole-Jean Wu. 2020. MLPerf: An Industry Standard Benchmark Suite for Machine Learning
Performance. IEEE Micro 40, 2 (2020), 8–16.

[28] Maxim Naumov, Dheevatsa Mudigere, Hao-Jun Michael Shi, Jianyu Huang, Narayanan Sundaraman, Jongsoo Park,
Xiaodong Wang, Udit Gupta, Carole-Jean Wu, Alisson G Azzolini, Dmytro Dzhulgakov, Andrey Mallevich, Ilia
Cherniavskii, Yinghai Lu, Raghuraman Krishnamoorthi, Ansha Yu, Volodymyr Kondratenko, Stephanie Pereira, Xianjie
Chen, Wenlin Chen, Vijay Rao, Bill Jia, Liang Xiong, and Misha Smelyanskiy. 2019. Deep Learning Recommendation
Model for Personalization and Recommendation Systems. arXiv preprint arXiv:1906.00091 (2019).

[29] Vijay Janapa Reddi, Christine Cheng, David Kanter, Peter Mattson, Guenther Schmuelling, Carole-Jean Wu, Brian
Anderson, Maximilien Breughe, Mark Charlebois, William Chou, et al. 2019. MLPerf inference benchmark. arXiv
preprint arXiv:1911.02549 (2019).

[30] Shaohuai Shi, Qiang Wang, Pengfei Xu, and Xiaowen Chu. 2016. Benchmarking state-of-the-art deep learning software

tools. In 2016 7th International Conference on Cloud Computing and Big Data (CCBD). IEEE, 99–104.

[31] Akshitha Sriraman, Abhishek Dhanotia, and Thomas F Wenisch. 2019. SoftSKU: Optimizing Server Architectures for
Microservice Diversity at Scale. In Proceedings of the 46th International Symposium on Computer Architecture. ACM,
513–526.

[32] Christian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet, Scott Reed, Dragomir Anguelov, Dumitru Erhan, Vincent
Vanhoucke, and Andrew Rabinovich. 2015. Going Deeper with Convolutions. In Proceedings of the IEEE conference on
Computer Vision and Pattern Recognition. 1–9.

[33] Christian Szegedy, Vincent Vanhoucke, Sergey Ioffe, Jon Shlens, and Zbigniew Wojna. 2016. Rethinking the Inception
Architecture for Computer Vision. In Proceedings of the IEEE conference on Computer Vision and Pattern Recognition.
2818–2826.

[34] Nicolas Vasilache, Oleksandr Zinenko, Theodoros Theodoridis, Priya Goyal, Zachary DeVito, William S Moses, Sven
Verdoolaege, Andrew Adams, and Albert Cohen. 2018. Tensor Comprehensions: Framework-Agnostic High-Performance
Machine Learning Abstractions. arXiv preprint arXiv:1802.04730 (2018).

[35] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, and Illia
Polosukhin. 2017. Attention Is All You Need. In Advances in Neural Information Processing Systems. 5998–6008.
[36] Carole-Jean Wu, David Brooks, Kevin Chen, Douglas Chen, Sy Choudhury, Marat Dukhan, Kim Hazelwood, Eldad
Isaac, Yangqing Jia, Bill Jia, et al. 2019. Machine Learning at Facebook: Understanding Inference at the Edge. In 2019
IEEE International Symposium on High Performance Computer Architecture (HPCA). IEEE, 331–344.

[37] Saining Xie, Ross Girshick, Piotr Dollár, Zhuowen Tu, and Kaiming He. 2017. Aggregated Residual Transformations
for Deep Neural Networks. In Proceedings of the IEEE conference on Computer Vision and Pattern Recognition.
1492–1500.

[38] Ahmad Yasin. 2014. A Top-Down Method for Performance Analysis and Counters Architecture. In 2014 IEEE

International Symposium on Performance Analysis of Systems and Software (ISPASS). IEEE, 35–44.

21

