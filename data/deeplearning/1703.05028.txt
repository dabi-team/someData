Fonduer: Knowledge Base Construction
from Richly Formatted Data

Sen Wu Luke Hsiao Xiao Cheng Braden Hancock Theodoros Rekatsinas∗
Philip Levis Christopher R´e

Stanford University

∗University of Wisconsin-Madison

{senwu, lwhsiao, xiao, bradenjh, pal, chrismre}@cs.stanford.edu

∗rekatsinas@wisc.edu

8
1
0
2

r
a

M
2

]

B
D
.
s
c
[

2
v
8
2
0
5
0
.
3
0
7
1
:
v
i
X
r
a

ABSTRACT
We focus on knowledge base construction (KBC) from richly for-
matted data. In contrast to KBC from text or tabular data, KBC from
richly formatted data aims to extract relations conveyed jointly via
textual, structural, tabular, and visual expressions. We introduce
Fonduer, a machine-learning-based KBC system for richly format-
ted data. Fonduer presents a new data model that accounts for three
challenging characteristics of richly formatted data: (1) prevalent
document-level relations, (2) multimodality, and (3) data variety.
Fonduer uses a new deep-learning model to automatically capture
the representation (i.e., features) needed to learn how to extract rela-
tions from richly formatted data. Finally, Fonduer provides a new
programming model that enables users to convert domain expertise,
based on multiple modalities of information, to meaningful signals
of supervision for training a KBC system. Fonduer-based KBC
systems are in production for a range of use cases, including at a
major online retailer. We compare Fonduer against state-of-the-art
KBC approaches in four different domains. We show that Fonduer
achieves an average improvement of 41 F1 points on the quality
of the output knowledge base—and in some cases produces up to
1.87× the number of correct entries—compared to expert-curated
public knowledge bases. We also conduct a user study to assess the
usability of Fonduer’s new programming model. We show that after
using Fonduer for only 30 minutes, non-domain experts are able to
design KBC systems that achieve on average 23 F1 points higher
quality than traditional machine-learning-based KBC approaches.

1 INTRODUCTION
Knowledge base construction (KBC) is the process of populating a
database with information from data such as text, tables, images, or
video. Extensive efforts have been made to build large, high-quality
knowledge bases (KBs), such as Freebase [5], YAGO [38], IBM Wat-
son [6, 10], PharmGKB [17], and Google Knowledge Graph [37].
Traditionally, KBC solutions have focused on relation extraction
from unstructured text [23, 27, 36, 44]. These KBC systems already
support a broad range of downstream applications such as infor-
mation retrieval, question answering, medical diagnosis, and data
visualization. However, troves of information remain untapped in
richly formatted data, where relations and attributes are expressed
via combinations of textual, structural, tabular, and visual cues. In
these scenarios, the semantics of the data are signiﬁcantly affected
by the organization and layout of the document. Examples of richly
formatted data include webpages, business reports, product speciﬁ-
cations, and scientiﬁc literature. We use the following example to
demonstrate KBC from richly formatted data.

Figure 1: A KBC task to populate relation HasCollectorCur-
rent(Transistor Part, Current) from transistor datasheets. Part
and Current mentions are in blue and green, respectively.

Example 1.1 (HasCollectorCurrent). We highlight the ELEC-
TRONICS domain. We are given a collection of transistor datasheets
(like the one shown in Figure 1), and we want to build a KB of their
maximum collector currents.1 The output KB can power a tool that
veriﬁes that transistors do not exceed their maximum ratings in a
circuit. Figure 1 shows how relevant information is located in both
the document header and table cells and how their relationship is
expressed using semantics from multiple modalities.

The heterogeneity of signals in richly formatted data poses a major
challenge for existing KBC systems. The above example shows how
KBC systems that focus on text data—and adjacent textual contexts
such as sentences or paragraphs—can miss important information
due to this breadth of signals in richly formatted data. We review
the major challenges of KBC from richly formatted data.

Challenges. KBC on richly formatted data poses a number of
challenges beyond those present with unstructured data: (1) ac-
commodating prevalent document-level relations, (2) capturing the
multimodality of information in the input data, and (3) addressing
the tremendous data variety.

Prevalent Document-Level Relations We deﬁne the context of a
relation as the scope information that needs to be considered when
extracting the relation. Context can range from a single sentence to
a whole document. KBC systems typically limit the context to a few
sentences or a single table, assuming that relations are expressed
relatively locally. However, for richly formatted data, many relations
rely on information from throughout a document to be extracted.

1Transistors are semiconductor devices often used as switches or ampliﬁers. Their
electrical speciﬁcations are published by manufacturers in datasheets.

                                          SMBT3904...MMBT3904  NPN Silicon Switching Transistors • High DC current gain: 0.1 mA to 100 mA • Low collector-emitter saturation voltage  Maximum Ratings Parameter Symbol Value Unit Collector-emitter voltage VCEO 40 V Collector-base voltage VCBO 60 Emitter-base voltage VEBO 6 Collector current IC 200 mA Total power dissipation    TS ≤ 60°C    TS ≤ 115°C Ptot   S330S S250S mW  Junction temperature Tj 150 °C Storage temperature Tstg -65 ... 150  TransistorPartCurrentSMBT3904200mAMMBT3904200mAHasCollectorCurrentKnowledge BaseFrom tableFrom headerTransistor DatasheetFont: Arial; Size: 12; Style: BoldAligned 
 
 
 
 
 
Example 1.2 (Document-Level Relations). In Figure 1, transistor
parts are located in the document header (boxed in blue), and the
collector current value is in a table cell (boxed in green). Moreover,
the interpretation of some numerical values depends on their units
reported in another table column (e.g., 200 mA).

Limiting the context scope to a single sentence or table misses many
potential relations—up to 97% in the ELECTRONICS application.
On the other hand, considering all possible entity pairs throughout
the document as candidates renders the extraction problem computa-
tionally intractable due to the combinatorial explosion of candidates.

Multimodality Classical KBC systems model input data as unstruc-
tured text [23, 26, 36]. With richly formatted data, semantics are
part of multiple modalities—textual, structural, tabular, and visual.

Example 1.3 (Multimodality). In Figure 1, important information
(e.g., the transistor names in the header) is expressed in larger, bold
fonts (displayed in yellow). Furthermore, the meaning of a table
entry depends on other entries with which it is visually or tabularly
aligned (shown by the red arrow). For instance, the semantics of a
numeric value is speciﬁed by an aligned unit.

Semantics from different modalities can vary signiﬁcantly but can
convey complementary information.

Data Variety With richly formatted data, there are two primary
sources of data variety: (1) format variety (e.g., ﬁle or table format-
ting) and (2) stylistic variety (e.g., linguistic variation).

Example 1.4 (Data Variety). In Figure 1, numeric intervals are
expressed as “-65 . . . 150,” but other datasheets show intervals as
“-65 ∼ 150,” or “-65 to 150.” Similarly, tables can be formatted with a
variety of spanning cells, header hierarchies, and layout orientations.

Data variety requires KBC systems to adopt data models that are
generalizable and robust against heterogeneous input data.

Our Approach. We introduce Fonduer, a machine-learning-
based system for KBC from richly formatted data. Fonduer takes as
input richly formatted documents, which may be of diverse formats,
including PDF, HTML, and XML. Fonduer parses the documents
and analyzes the corresponding multimodal, document-level con-
texts to extract relations. The ﬁnal output is a knowledge base with
the relations classiﬁed to be correct. Fonduer’s machine-learning-
based approach must tackle a series of technical challenges.

Technical Challenges The challenges in designing Fonduer are:
(1) Reasoning about relation candidates that are manifested in hetero-
geneous formats (e.g., text and tables) and span an entire document
requires Fonduer’s machine-learning model to analyze heteroge-
neous, document-level context. While deep-learning models such
as recurrent neural networks [2] are effective with sentence- or
paragraph-level context [22], they fall short with document-level
context, such as context that span both textual and visual features
(e.g., information conveyed via fonts or alignment) [21]. Developing
such models is an open challenge and active area of research [21].
(2) The heterogeneity of contexts in richly formatted data magni-
ﬁes the need for large amounts of training data. Manual annotation
is prohibitively expensive, especially when domain expertise is re-
quired. At the same time, human-curated KBs, which can be used
to generate training data, may exhibit low coverage or not exist

altogether. Alternatively, weak supervision sources can be used to
programmatically create large training sets, but it is often unclear
how to consistently apply these sources to richly formatted data.
Whereas patterns in unstructured data can be identiﬁed based on text
alone, expressing patterns consistently across different modalities in
richly formatted data is challenging.
(3) Considering candidates across an entire document leads to a
combinatorial explosion of possible candidates, and thus random
variables, which need to be considered during learning and inference.
This leads to a fundamental tension between building a practical
KBC system and learning accurate models that exhibit high recall. In
addition, the combinatorial explosion of possible candidates results
in a large class imbalance, where the number of “True” candidates
is much smaller than the number of “False” candidates. Therefore,
techniques that prune candidates to balance running time and end-
to-end quality are required.

Technical Contributions Our main contributions are as follows:
(1) To account for the breadth of signals in richly formatted data,
we design a new data model that preserves structural and semantic
information across different data modalities. The role of Fonduer’s
data model is twofold: (a) to allow users to specify multimodal
domain knowledge that Fonduer leverages to automate the KBC
process over richly formatted data, and (b) to provide Fonduer’s
machine-learning model with the necessary representation to reason
about document-wide context (see Section 3).
(2) We empirically show that existing deep-learning models [46]
tailored for text information extraction (such as long short-term mem-
ory (LSTM) networks [18]) struggle to capture the multimodality of
richly formatted data. We introduce a multimodal LSTM network
that combines textual context with universal features that correspond
to structural and visual properties of the input documents. These
features are inherently captured by Fonduer’s data model and are
generated automatically (see Section 4.2). We also introduce a series
of data layout optimizations to ensure the scalability of Fonduer to
millions of document-wide candidates (see Appendix C).
(3) Fonduer introduces a programming model in which no devel-
opment cycles are spent on feature engineering. Users only need
to specify candidates, the potential entries in the target KB, and
provide lightweight supervision rules which capture a user’s do-
main knowledge and programmatically label subsets of candidates,
which are used for training Fonduer’s deep-learning model (see
Section 4.3). We conduct a user study to evaluate Fonduer’s pro-
gramming model. We ﬁnd that when working with richly formatted
data, users utilize the semantics from multiple modalities of the data,
including both structural and textual information in the document.
Our study demonstrates that given 30 minutes, Fonduer’s program-
ming model allows users to attain F1 scores that are 23 points higher
than supervision via manual labeling candidates (see Section 6).

Summary of Results. Fonduer-based systems are in production
in a range of academic and industrial uses cases, including a major
online retailer. Fonduer introduces several advancements over prior
KBC systems (see Appendix 7): (1) In contrast to prior systems that
focus on adjacent textual data, Fonduer can extract document-level
relations expressed in diverse formats, ranging from textual to tab-
ular formats; (2) Fonduer reasons about multimodal context, i.e.,
both textual and visual characteristics of the input documents, to

extract more accurate relations; (3) In contrast to prior KBC systems
that rely heavily on feature engineering to achieve high quality [34],
Fonduer obviates the need for feature engineering by extending a
bidirectional LSTM—the de facto deep-learning standard in natu-
ral language processing [24]—to obtain a representation needed to
automate relation extraction from richly formatted data. We eval-
uate Fonduer in four real-world applications of richly formatted
information extraction and show that Fonduer enables users to build
high-quality KBs, achieving an average improvement of 41 F1 points
over state-of-the-art KBC systems.

2 BACKGROUND

We review the concepts and terminology used in the next sections.

Machine-learning-based KBC systems use machine learning to max-
imize the probability of correctly classifying candidates, given their
features and ground truth examples.

2.2 Recurrent Neural Networks

The machine-learning model we use in Fonduer is based on a re-
current neural network (RNN). RNNs have obtained state-of-the-art
results in many natural-language processing (NLP) tasks, includ-
ing information extraction [15, 16, 43]. RNNs take sequential data
as input. For each element in the input sequence, the information
from previous inputs can affect the network output for the current
element. For sequential data {x1, . . . , xT }, the structure of an RNN
is mathematically described as:

2.1 Knowledge Base Construction

ht = f(xt, ht−1),

y = g({h1, . . . , hT })

The input to a KBC system is a collection of documents. The output
of the system is a relational database containing facts extracted from
the input and stored in an appropriate schema. To describe the
KBC process, we adopt the standard terminology from the KBC
community. There are four types of objects that play integral roles
in KBC systems: (1) entities, (2) relations, (3) mentions of entities,
and (4) relation mentions.

An entity e in a knowledge base corresponds to a distinct real-
world person, place, or object. Entities can be grouped into different
entity types T1, T2, . . . , Tn. Entities also participate in relationships.
A relationship between n entities is represented as an n-ary relation
R(e1, e2, . . . , en) and is described by a schema SR(T1, T2, . . . , Tn)
where ei ∈ Ti. A mention m is a span of text that refers to an
entity. A relation mention candidate (referred to as a candidate in
this paper) is an n-ary tuple c = (m1, m2, . . . , mn) that represents
a potential instance of a relation R(e1, e2, . . . , en). A candidate
classiﬁed as true is called a relation mention, denoted by rR.

Example 2.1 (KBC). Consider the HasCollectorCurrent task in
Figure 1. Fonduer takes a corpus of transistor datasheets as input
and constructs a KB containing the (Transistor Part, Current) binary
relation as output. Parts like SMBT3904 and Currents like 200mA
are entities. The spans of text that read “SMBT3904” and “200”
(boxed in blue and green, respectively) are mentions of those two
entities, and together they form a candidate. If the evidence in the
document suggests that these two mentions are related, then the
output KB will include the relation mention (SMBT3904, 200mA)
of the HasCollectorCurrent relation.

The KBC problem is deﬁned as follows:

Deﬁnition 2.2 (Knowledge Base Construction). Given a set of
documents D and a KB schema SR(T1, T2, . . . , Tn), where each Ti
corresponds to an entity type, extract a set of relation mentions rR
from D, which populate the schema’s relational tables.

Like other machine-learning-based KBC systems [7, 36], Fonduer
converts KBC to a statistical learning and inference problem: each
candidate is assigned a Boolean random variable that can take the
value “True” if the corresponding relation mention is correct, or
“False” otherwise. In machine-learning-based KBC systems, each
candidate is associated with certain features that provide evidence
for the value that the corresponding random variable should take.

where ht is the hidden state for element t, and y is the representation
generated by the sequence of hidden states {h1, . . . , hT }. Functions
f and g are nonlinear transformations. For RNNs, we have that
f = tanh(Whxt + Uhht−1 + bh) where Wh, Uh are parameter
matrices and bh is a vector. Function g is typically task-speciﬁc.

Long Short-term Memory LSTM [18] networks are a special
type of RNN that introduce new structures referred to as gates,
which control the ﬂow of information and can capture long-term
dependencies. There are three types of gates: input gates it control
which values are updated in a memory cell; forget gates ft control
which values remain in memory; and output gates ot control which
values in memory are used to compute the output of the cell. The
ﬁnal structure of an LSTM is given by:

it = σ(Wixt + Uiht−1 + bi)
ft = σ(Wfxt + Ufht−1 + bf)
ot = σ(Woxt + Uoht−1 + bo)
ct = ft ◦ ct−1 + it ◦ tanh(Wcxt + Ucht−1 + bc)
ht = ot ◦ tanh(ct)

where ct is the cell state vector, W, U, b are parameter matrices and
a vector, σ is the sigmoid function, and ◦ is the Hadamard product.
Bidirectional LSTMs consist of forward and backward LSTMs.
The forward LSTM fF reads the sequence from x1 to xT and cal-
culates a sequence of forward hidden states (hF
T ). The
backward LSTM fB reads the sequence from xT to x1 and calcu-
lates a sequence of backward hidden states (hB
T ). The ﬁnal
hidden state for the sequence is the concatenation of the forward and
backward hidden states, e.g., hi = [hF

1 , . . . , hB

1 , . . . , hF

i , hB
i ].

Attention Previous work explored using pooling strategies to train
an RNN, such as max pooling [41], which compresses the informa-
tion contained in potentially long input sequences to a ﬁxed-length
internal representation by considering all parts of the input sequence
impartially. This compression of information can make it difﬁcult
for RNNs to learn from long input sequences.

In recent years, the attention mechanism has been introduced
to overcome this limitation by using a soft word-selection process
that is conditioned on the global information of the sentence [2].
That is, rather than squashing all information from a source input
(regardless of its length), this mechanism allows an RNN to pay

Figure 2: An overview of Fonduer KBC over richly formatted data. Given a set of richly formatted documents and a series of
lightweight inputs from the user, Fonduer extracts facts and stores them in a relational database.

hierarchy of document components. In this graph, each node is a
context (represented as boxes in Figure 3). The root of the DAG
is a Document, which contains Section contexts. Each Section is
divided into: Texts, Tables, and Figures. Texts can contain multiple
Paragraphs; Tables and Figures can contain Captions; Tables can
also contain Rows and Columns, which are in turn made up of Cells.
Each context ultimately breaks down into Paragraphs that are parsed
into Sentences. In Figure 3, a downward edge indicates a parent-
contains-child relationship. This hierarchy serves as an abstraction
for both system and user interaction with the input corpus.

In addition, this data model allows us to capture candidates that
come from different contexts within a document. For each context,
we also store the textual contents, pointers to the parent contexts,
and a wide range of attributes from each modality found in the
original document. For example, standard NLP pre-processing tools
are used to generate linguistic attributes, such as lemmas, parts of
speech tags, named entity recognition tags, dependency paths, etc.,
for each Sentence. Structural and tabular attributes of a Sentence,
such as tags, and row/column information, and parent attributes, can
be captured by traversing its path in the data model. Visual attributes
for the document are recorded by storing bounding box and page
information for each word in a Sentence.

Example 3.1 (Data Model). The data model representing the PDF
in Figure 1 contains one Section with three children: a Text for the
document header, a Text for the description, and a Table for the table
itself (with 10 Rows and 4 Columns). Each Cell links to both a Row
and Column. Texts and Cells contain Paragraphs and Sentences.

Fonduer’s multimodal data model uniﬁes inputs of different for-
mats, which addresses the data variety of richly formatted data that
comes from variations in format. To construct the DAG for each doc-
ument, we extract all the words in their original order. For structural
and tabular information, we use tools such as Poppler2 to convert
an input ﬁle into HTML format; for visual information, such as
coordinates and bounding boxes, we use a PDF printer to convert an
input ﬁle into PDF format. If a conversion occurred, we associate
the multimodal information in the converted ﬁle with all extracted
words. We align the word sequences of the converted ﬁle with their
originals by checking if both their characters and number of repeated

2https://poppler.freedesktop.org

Figure 3: Fonduer’s data model.
more attention to the subsets of the input sequence where the most
relevant information is concentrated.

Fonduer uses a bidirectional LSTM with attention to represent
textual features of relation candidates from the documents. We
extend this LSTM with features that capture other data modalities.

3 THE Fonduer FRAMEWORK
An overview of Fonduer is shown in Figure 2. Fonduer takes as
input a collection of richly formatted documents and a collection
of user inputs. It follows a machine-learning-based approach to
extract relations from the input documents. The relations extracted
by Fonduer are stored in a target knowledge base.

We introduce Fonduer’s data model for representing different
properties of richly formatted data. We then review Fonduer’s data
processing pipeline and describe the new programming paradigm
introduced by Fonduer for KBC from richly formatted data.

The design of Fonduer was strongly guided by interactions with
collaborators (see the user study in Section 6). We ﬁnd that to
support KBC from richly formatted data, a uniﬁed data model must:

• Serve as an abstraction for system and user interaction.
• Capture candidates that span different areas (e.g. sections
of pages) and data modalities (e.g., textual and tabular data).
• Represent the formatting variety in richly formatted data

sources in a uniﬁed manner.

Fonduer introduces a data model that satisﬁes these requirements.

3.1 Fonduer’s Data Model
Fonduer’s data model is a directed acyclic graph (DAG) that con-
tains a hierarchy of contexts, whose structure reﬂects the intuitive

OutputFonduerError	AnalysisUser	InputTransistorPartCurrentSMBT3904200mAMMBT3904200mAHasCollectorCurrentStatic                                          SMBT3904...MMBT3904  NPN Silicon Switching Transistors • High DC current gain: 0.1 mA to 100 mA • Low collector-emitter saturation voltage  Maximum Ratings Parameter Symbol Value Unit Collector-emitter voltage VCEO 40 V Collector-base voltage VCBO 60 Emitter-base voltage VEBO 6 Collector current IC 200 mA Total power dissipation    TS ≤ 71°C    TS ≤ 115°C Ptot   S330S S250S mV  Junction temperature Tj 150 °C Storage temperature Tstg -65 ... 150                                            SMBT3904...MMBT3904  NPN Silicon Switching Transistors • High DC current gain: 0.1 mA to 100 mA • Low collector-emitter saturation voltage  Maximum Ratings Parameter Symbol Value Unit Collector-emitter voltage VCEO 40 V Collector-base voltage VCBO 60 Emitter-base voltage VEBO 6 Collector current IC 200 mA Total power dissipation    TS ≤ 71°C    TS ≤ 115°C Ptot   S330S S250S mV  Junction temperature Tj 150 °C Storage temperature Tstg -65 ... 150                                            SMBT3904...MMBT3904  NPN Silicon Switching Transistors • High DC current gain: 0.1 mA to 100 mA • Low collector-emitter saturation voltage  Maximum Ratings Parameter Symbol Value Unit Collector-emitter voltage VCEO 40 V Collector-base voltage VCBO 60 Emitter-base voltage VEBO 6 Collector current IC 200 mA Total power dissipation    TS ≤ 71°C    TS ≤ 115°C Ptot   S330S S250S mV  Junction temperature Tj 150 °C Storage temperature Tstg -65 ... 150  Data	InputSchemaKBC	InitializationPhase	1Phase	2Multimodal	Featurization&MultimodalLSTMMatchers	&	ThrottlersCandidate	GenerationSupervision&	ClassificationLabeling	FunctionsIterativePhase	3occurrences before the current word are the same. Fonduer can re-
cover from conversion errors by using the inherent redundancy in
signals from other modalities. In addition, this DAG structure also
simpliﬁes the variation in format that comes from table formatting.
Takeaways. Fonduer consolidates a diverse variety of document
formats, types of contexts, and modality semantics into one model in
order to address variety inherent in richly formatted data. Fonduer’s
data model serves as the formal representation of the intermediate
data utilized in all future stages of the extraction process.

3.2 User Inputs and Fonduer’s Pipeline

The Fonduer processing pipeline follows three phases. We brieﬂy
describe each phase in turn and focus on the user inputs required by
each phase. Fonduer’s internals are described in Section 4.

(1) KBC Initialization The ﬁrst phase in Fonduer’s pipeline is to
initialize the target KB where the extracted relations will be stored.
During this phase, Fonduer requires the user to specify a target
schema that corresponds to the relations to be extracted. The target
schema SR(T1, . . . , Tn) deﬁnes a relation R to be extracted from the
input documents. An example of such a schema is provided below.

Example 3.2 (Relation Schema). An example SQL schema for

the relation in Figure 1 is:

CREATE TABLE H a s C o l l e c t o r C u r r e n t (

T r a n s i s t o r P a r t v a r c h a r ,
C u r r e n t v a r c h a r ) ;

Fonduer uses the user-speciﬁed schema to initialize an empty
relational database where the output KB will be stored. Furthermore,
Fonduer iterates over its input corpus and transforms each docu-
ment into an instance of Fonduer’s data model to capture the variety
and multimodality of richly formatted documents.

(2) Candidate Generation In this phase, Fonduer extracts relation
candidates from the input documents. Here, users are required to
provide two types of input functions: (1) matchers and (2) throttlers.

Matchers To generate candidates for relation R, Fonduer requires
that users deﬁne matchers for all distinct mention types in schema
SR. Matchers are how users specify what a mention looks like. In
Fonduer, matchers are Python functions that accept a span of text as
input—which has a reference to its data model—and output whether
or not the match conditions are met. Matchers range from simple
regular expressions to complicated functions that take into account
signals across multiple modalities of the input data and can also
incorporate existing methods such as named-entity recognition.

Example 3.3 (Matchers). From the HasCollectorCurrent relation
in Figure 1, users deﬁne matchers for each type of the schema. A
dictionary of valid transistor parts can be used as the ﬁrst matcher.
For maximum current, users can exploit the pattern that these values
are commonly expressed as a numerical value between 100 and 995
for their second matcher.

# Use a dictionary to match transistor parts
def t r a n s i s t o r p a r t m a t c h e r ( span ) :

return 1 if span in p a r t d i c t i o n a r y else 0

# Use RegEx to extract numbers between [100 , 995]
def m a x c u r r e n t m a t c h e r ( span ) :

return 1 if re . match ( '[1−9][0−9][0−5]' , span ) else 0

Throttlers Users can optionally provide throttlers, which act as
hard ﬁltering rules to reduce the number of candidates that are
materialized. Throttlers are also Python functions, but rather than
accepting spans of text as input, they operate on candidates, and
output whether or not a candidate meets the speciﬁed condition.
Throttlers limit the number of candidates considered by Fonduer.

Example 3.4 (Throttler). Continuing the example shown in Fig-
ure 1, the user provides a throttler, which only keeps candidates
whose Current has the word “Value” as its column header.

def v a l u e i n c o l u m n h e a d e r ( cand ) :

if ' Value ' in h e a d e r n g r a m s ( cand . current ) :

return 1

else :

return 0

Given the input matchers and throttlers, Fonduer extracts rela-
tion candidates by traversing its data model representation of each
document. By applying matchers to each leaf of the data model,
Fonduer can generate sets of mentions for each component of the
schema. The cross-product of these mentions produces candidates:

Candidate(idcandidate, mention1, . . . , mentionn)

where mentions are spans of text and contain pointers to their context
in the data model of their respective document. The output of this
phase is a set of candidates, C.

(3) Training a Multimodal LSTM for KBC In this phase, Fonduer
trains a multimodal LSTM network to classify the candidates gener-
ated during Phase 2 as “True” or “False” mentions of target relations.
Fonduer’s multimodal LSTM combines both visual and textual fea-
tures. Recent work has also proposed the use of LSTMs for KBC
but has focused only on textual data [46]. In Section 5.3.3, we ex-
perimentally demonstrate that state-of-the-art LSTMs struggle to
capture the multimodal characteristics of richly formatted data, and
thus, obtain poor-quality KBs.

Fonduer uses a bidirectional LSTM (reviewed in Section 2.2)
to capture textual features and extends it with additional structural,
tabular, and visual features captured by Fonduer’s data model. The
LSTM used by Fonduer is described in Section 4.2. Training in
Fonduer is split into two sub-phases: (1) a multimodal featurization
phase and (2) a phase where supervision data is provided by the user.

Multimodal Featurization Here, Fonduer traverses its internal data
model instance for each input document and automatically generates
features that correspond to structural, tabular, and visual modalities
as described in Section 4.2. These constitute a bare-bones feature
library (referred to as feature lib, below), which augments the textual
features learned by the LSTM. All features are stored in a relation:

Features(idcandidate, LSTMtextual, feature libothers)

No user input is required during this step. Fonduer obviates the need
for feature engineering and shows that incorporating multimodal
information is key to achieving high-quality relation extraction.

Supervision To train its multimodal LSTM, Fonduer requires that
users provide some form of supervision. Collecting sufﬁcient train-
ing data for multi-context deep-learning models is a well-established
challenge. As stated by LeCun et al. [21], taking into account a

context of more than a handful of words for text-based deep-learning
models requires very large training corpora.

To soften the burden of traditional supervision, Fonduer uses a
supervision paradigm referred to as data programming [33]. Data
programming is a human-in-the-loop paradigm for training machine-
learning systems. In data programming, users only need to specify
lightweight functions, referred to as labeling functions (LFs), that
programmatically assign labels to the input candidates. A detailed
overview of data programming is provided in Appendix A. While
existing work on data programming [32] has focused on labeling
functions over textual data, Fonduer paves the way for specifying
labeling functions over richly formatted data.

Fonduer requires that users specify labeling functions that label
the candidates from Phase 2. Labeling functions in Fonduer are
Python functions that take a candidate as input and assign +1 to
label it as “True,” −1 to label it as “False,” or 0 to abstain.

Example 3.5 (Labeling Functions). Looking at the datasheet in
Figure 1, users can express patterns such as having the Part and
Current y-aligned on the visual rendering of the page. Similarly,
users can write a rule that labels a candidate whose Current is in the
same row as the word “current” as “True.”

# Rule−based LF based on visual information
def y a x i s a l i g n e d ( cand ) :

return 1 if cand . part . y == cand . current . y else 0

# Rule−based LF based on tabular content
def h a s c u r r e n t i n r o w ( cand ) :

if ' current ' in r o w n g r a m s ( cand . current ) :

return 1

else :

return 0

As shown in Example 3.5, Fonduer’s internal data model allows
users to specify labeling functions that capture supervision patterns
across any modality of the data (see Section 4.3). In our user study,
we ﬁnd that it is common for users to write labeling functions that
span multiple modalities and consider both textual and visual pat-
terns of the input data (see Section 6).

The user-speciﬁed labeling functions, together with the candidates
generated by Fonduer, are passed as input to Snorkel [32], a data-
programming engine, which converts the noisy labels generated by
the input labeling functions to denoised labeled data used to train
Fonduer’s multimodal LSTM model (see Appendix A).

Classiﬁcation Fonduer uses its trained LSTM to assign a marginal
probability to each candidate. The last layer of Fonduer’s LSTM
is a softmax classiﬁer (described in Section 4.2) that computes
the probability of a candidate being a “True” relation. In Fonduer,
users can specify a threshold over the output marginal probabilities to
determine which candidates will be classiﬁed as “True” (those whose
marginal probability of being true exceeds the speciﬁed threshold)
and which are “False” (those whose marginal probability fall beneath
the threshold). This threshold depends on the requirements of the
application. Applications that require critically high accuracy can
set a high threshold value to ensure only candidates with a high
probability of being “True” are classiﬁed as such.

As shown in Figure 2, supervision and classiﬁcation are typically
executed over several iterations as users develop a KBC application.

This feedback loop allows users to quickly receive feedback and im-
prove their labeling functions, and avoids the overhead of rerunning
candidate extraction and materializing features (see Section 6).

3.3 Fonduer’s Programming Model for KBC

Fonduer is the ﬁrst system to provide the necessary abstractions
and mechanisms to enable the use of weak supervision as a means
to train a KBC system for richly formatted data. Traditionally,
machine-learning-based KBC focuses on feature engineering to
obtain high-quality KBs. This requires that users rerun feature
extraction, learning, and inference after every modiﬁcation of the
features used during KBC. With Fonduer’s machine-learning ap-
proach, features are generated automatically. This puts emphasis on
(1) specifying the relation candidates and (2) providing multimodal
supervision rules via labeling functions. This approach allows users
to leverage multiple sources of supervision to address data vari-
ety introduced by variations in style better than traditional manual
labeling [36].

Fonduer’s programming paradigm obviates the need for feature
engineering and introduces two modes of operation for Fonduer
applications: (1) development and (2) production. During develop-
ment, labeling functions are iteratively improved, in terms of both
coverage and accuracy, through error analysis as shown by the blue
arrows in Figure 2. LFs are applied to a small sample of labeled
candidates and evaluated by the user on their accuracy and coverage
(the fraction of candidates receiving non-zero labels). To support
efﬁcient error analysis, Fonduer enables users to easily inspect the
resulting candidates and provides a set of labeling function metrics,
such as coverage, conﬂict, and overlap, which provide users with
a rough assessment of how to improve their LFs. In practice, ap-
proximately 20 iterations are adequate for our users to generate a
sufﬁciently tuned set of labeling functions (see Section 6). In pro-
duction, the ﬁnalized LFs are applied to the entire set of candidates,
and learning and inference are performed only once to generate the
ﬁnal KB.

On average, only a small number of labeling functions are needed
to achieve high-quality KBC (see Section 6). For example, in the
ELECTRONICS application, 16 labeling functions, on average, are
sufﬁcient to achieve an average F1 score of over 75. Furthermore, we
ﬁnd that tabular and visual signals are particularly valuable forms of
supervision for KBC from richly formatted data, and complementary
to traditional textual signals (see Section 6).

4 KBC IN Fonduer

Here, we focus on the implementation of each component of Fonduer.
In Appendix C we discuss a series of optimizations that enable
Fonduer’s scalability to millions of candidates.

4.1 Candidate Generation

Candidate generation from richly formatted data relies on access
to document-level contexts, which is provided by Fonduer’s data
model. Due to the signiﬁcantly increased context needed for KBC
from richly formatted data, na¨ıvely materializing all possible can-
didates is intractable as the number of candidates grows combina-
torially with the number of relation arguments. This combinatorial
explosion can lead to performance issues for KBC systems. For

example, in the ELECTRONICS domain, just 100 documents can gen-
erate over 1M candidates. In addition, we ﬁnd that the majority of
these candidates do not express true relations, creating a signiﬁcant
class imbalance that can hinder learning performance [19].

To address this combinatorial explosion, Fonduer allows users
to specify throttlers, in addition to matchers, to prune away excess
candidates. We ﬁnd that throttlers must:

• Maintain high accuracy by only ﬁltering negative candi-

dates.

• Seek high coverage of the candidates.

Throttlers can be viewed as a knob that allows users to trade off
precision and recall and promote scalability by reducing the number
of candidates to be classiﬁed during KBC.

removed. Figure 5 illustrates Fonduer’s LSTM. We now review
each component of Fonduer’s LSTM.

Bidirectional LSTM with Attention Traditionally, the primary
source of signal for relation extraction comes from unstructured
text. In order to understand textual signals, Fonduer uses an LSTM
network to extract textual features. For mentions, Fonduer builds
a Bi-LSTM to get the textual features of the mention from both
directions of sentences containing the candidate. For sentence si
containing the ith mention in the document, the textual features
hik of each word wik are encoded by both forward (deﬁned as
superscript F in equations) and backward (deﬁned as superscript B)
LSTM, which summarizes information about the whole sentence
with a focus on wik. This takes the structure:

i(k−1), Φ(si, k))
i(k+1), Φ(si, k))

hF
ik = LST M(hF
hB
ik = LST M(hB
ik, hB
hik = [hF
ik]
where Φ(si, k) is the word embedding [40], which is the representa-
tion of the semantics of the kth word in sentence si.

Then, the textual feature representation for a mention, ti, is calcu-
lated by the following attention mechanism to model the importance
of different words from the sentence si and to aggregate the feature
representation of those words to form a ﬁnal feature representation,

Figure 4: Tradeoff between (a) quality and (b) execution time
when pruning the number of candidates using throttlers.

uik = tanh(Wwhik + bw)

Figure 4 shows how using throttlers affects the quality-performance
tradeoff in the ELECTRONICS domain. We see that throttling signiﬁ-
cantly improves system performance. However, increased throttling
does not monotonically improve quality since it hurts recall. This
tradeoff captures the fundamental tension between optimizing for
system performance and optimizing for end-to-end quality. When no
candidates are pruned, the class imbalance resulting from many neg-
ative candidates to the relatively small number of positive candidates
harms quality. Therefore, as a rule of thumb, we recommend that
users apply throttlers to balance negative and positive candidates.
Fonduer provides users with mechanisms to evaluate this balance
over a small holdout set of labeled candidates.

Takeaways. Fonduer’s data model is necessary to perform can-
didate generation with richly formatted data. Pruning negative can-
didates via throttlers to balance negative and positive candidates
not only ensures the scalability of Fonduer but also improves the
precision of Fonduer’s output.

4.2 Multimodal LSTM Model

We now describe Fonduer’s deep-learning model in detail. Fonduer’s
model extends a bidirectional LSTM (Bi-LSTM), the de facto deep-
learning standard for NLP [24], with a simple set of dynamically
generated features that capture semantics from the structural, tabular,
and visual modalities of the data model. A detailed list of these
features is provided in Appendix B. In Section 5.3.2, we perform
an ablation study demonstrating that non-textual features are key to
obtaining high-quality KBs. We ﬁnd that the quality of the output
KB deteriorates up to 33 F1 points when non-textual features are

αik =

exp(uT
Σj exp(uT
ti = Σjαijuij

ikuw)
ijuw)

where Ww, uw, and b are parameter matrices and a vector. uik is
the hidden representation of hik, and αik is to model the importance
of each word in the sentence si. Special candidate markers (shown
in red in Figure 5) are added to the sentences to draw attention to the
candidates themselves. Finally, the textual features of a candidate
are the concatenation of its mentions’ textual features [t1, . . . , tn].

Extended Feature Library Features for structural, tabular, and
visual modalities are generated by leveraging the data model, which
preserves each modality’s semantics. For each candidate, such
as the candidate (SMBT3904, 200) shown in Figure 5, Fonduer
locates each mention in the data model and traverses the DAG to
compute features from the modality information stored in the nodes
of the graph. For example, Fonduer can traverse sibling nodes
to add tabular features such as featurizing a node based on the
other mentions in the same row or column. Similarly, Fonduer
can traverse the data model to extract structural features from tags
stored while parsing the document along with the hierarchy of the
document elements themselves. We review each modality:

Structural features. These provide signals intrinsic to a docu-
ment’s structure. These features are dynamically generated and
allow Fonduer to learn from structural attributes, such as parent and
sibling relationships and XML/HTML tag metadata found in the data
model (shown in yellow in Figure 5). The data model also allows
Fonduer to track structural distances of candidates, which helps
when a candidate’s mentions are visually distant, but structurally

Prec.Rec.F1Quality00.51.0% of Candidates Filtered050100LinearSpeed Up246810% of Candidates Filtered050100(a) Quality vs. Filter Ratio(b) Speed Up vs. Filter RatioFigure 5: An illustration of Fonduer’s multimodal LSTM for candidate (SMBT3904, 200) in Figure 1.

close together. Speciﬁcally, featurizing a candidate with the distance
to the lowest common ancestor in the data model is a positive signal
for linking table captions to table contents.

Tabular features. These are a special subset of structural features
since tables are very common structures inside documents and have
high information density. Table features are drawn from the grid-like
representation of rows and columns stored in the data model, shown
in green in Figure 5. In addition to the tabular location of mentions,
Fonduer also featurizes candidates with signals such as being in the
same row or column. For example, consider a table that has cells
with multiple lines of text; recording that two mentions share a row
captures a signal that a visual alignment feature could easily miss.
Visual features. These provide signals observed from a visual
rendering of a document. In cases where tabular or structural features
are noisy—including nearly all documents converted from PDF to
HTML by generic tools—visual features can provide a complemen-
tary view of the dependencies among text. Visual features encode
many highly predictive types of semantic information implicitly,
such as position on a page, which may imply when text is a title or
header. An example of this is shown in red in Figure 5.

Training All parameters of Fonduer’s LSTM are jointly trained,
including the parameters of the Bi-LSTM as well as the weights of
the last softmax layer that correspond to additional features.

Takeaways. To achieve high-quality KBC with richly format-
ted data, it is vital to have features from multiple data modalities.
These features are only obtainable through traversing and accessing
modality attributes stored in the data model.

4.3 Multimodal Supervision

Unlike KBC from unstructured text, KBC from richly formatted data
requires supervision from multiple modalities of the data. In richly
formatted data, useful patterns for KBC are more sparse and hidden
in non-textual signals, which motivates the need to exploit over-
lap and repetition in a variety of patterns over multiple modalities.
Fonduer’s data model allows users to directly express correctness
using textual, structural, tabular, or visual characteristics, in addition
to traditional supervision sources like existing KBs. In the ELEC-
TRONICS domain, over 70% of labeling functions written by our
users are based on non-textual signals. It is acceptable for these
labeling functions to be noisy and conﬂict with one another. Data

programming theory (see Appendix A.2) shows that, with a suf-
ﬁcient number of labeling functions, data programming can still
achieve quality comparable to using manually labeled data.

In Section 5.3.4, we ﬁnd that using metadata in the ELECTRONICS
domain, such as structural, tabular, and visual cues, results in a
66 F1 point increase over using textual supervision sources alone.
Using both sources gives a further increase of 2 F1 points over
metadata alone. We also show that supervision using information
from all modalities, rather than textual information alone, results in
an increase of 43 F1 points, on average, over a variety of domains.
Using multiple supervision sources is crucial to achieving high-
quality information extraction from richly formatted data.

Takeaways. Supervision using multiple modalities of richly for-
matted data is key to achieving high end-to-end quality. Like mul-
timodal featurization, multimodal supervision is also enabled by
Fonduer’s data model and addresses stylistic data variety.

5 EXPERIMENTS
We evaluate Fonduer over four applications: ELECTRONICS, AD-
VERTISEMENTS, PALEONTOLOGY, and GENOMICS—each contain-
ing several relation extraction tasks. We seek to answer: (1) how
does Fonduer compare against both state-of-the-art KBC techniques
and manually curated knowledge bases? and (2) how does each com-
ponent of Fonduer contribute to end-to-end extraction quality?

5.1 Experimental Settings

Datasets. The datasets used for evaluation vary in size and for-

mat. Table 1 shows a summary of these datasets.

Electronics The ELECTRONICS dataset is a collection of single
bipolar transistor speciﬁcation datasheets from over 20 manufactur-
ers, downloaded from Digi-Key.3 These documents consist primarily
of tables and express relations containing domain-speciﬁc symbols.
We focus on the relations between transistor part numbers and sev-
eral of their electrical characteristics. We use this dataset to evaluate
Fonduer with respect to datasets that consist primarily of tables
and numerical data.

Advertisements The ADVERTISEMENTS dataset contains web-
pages that may contain evidence of human trafﬁcking activity. These

3https://www.digikey.com

[[1SMBT39041]]…MMBT3904[[22002]]                                          SMBT3904...MMBT3904  NPN Silicon Switching Transistors • High DC current gain: 0.1 mA to 100 mA • Low collector-emitter saturation voltage  Maximum Ratings Parameter Symbol Value Unit Collector-emitter voltage VCEO 40 V Collector-base voltage VCBO 60 Emitter-base voltage VEBO 6 Collector current IC 200 mA Total power dissipation    TS ≤ 71°C    TS ≤ 115°C Ptot   S330S S250S mV  Junction temperature Tj 150 °C Storage temperature Tstg -65 ... 150  Textual featuresFont: Arial; Size: 12; Style: BoldFont: Arial; Size: 10 Header: ‘Value’; Row: 5;Column:3AlignedSame Font!"#!"$!"%!"&!"'!(#!($!(%sentence )"sentence )(Structural featuresVisualfeaturesTabular featuresMultimodal featuresBi-LSTM with AttentionExtended Feature Library[]⊕⊕Softmaxℎ"#,ℎ"$,ℎ"#-ℎ"$-ℎ"%-ℎ"&-ℎ"&,ℎ"%,ℎ"',ℎ"'-ℎ(#,ℎ(#-ℎ($,ℎ($-ℎ(%,ℎ(%-.".(Table 1: Summary of the datasets used in our experiments.

Dataset
ELEC.
ADS.
PALEO.
GEN.

Size
3GB
52GB
95GB
1.8GB

#Docs
7K
9.3M
0.3M
589

Format
#Rels
4
PDF
4 HTML
PDF
10
4 XML

webpages may provide prices of services, locations, contact infor-
mation, physical characteristics of the victims, etc. Here, we extract
all attributes associated with a trafﬁcking advertisement. The output
is deployed in production and is used by law enforcement agencies.
This is a heterogeneous dataset containing millions of webpages over
692 web domains in which users create customized ads, resulting
in 100,000s of unique layouts. We use this dataset to examine the
robustness of Fonduer in the presence of signiﬁcant data variety.

Paleontology The PALEONTOLOGY dataset is a collection of well-
curated paleontology journal articles on fossils and ancient organ-
isms. Here, we extract relations between paleontological discoveries
and their corresponding physical measurements. These papers often
contain tables spanning multiple pages. Thus, achieving high quality
in this application requires linking content in tables to the text that
references it, which can be separated by 20 pages or more in the
document. We use this dataset to test Fonduer’s ability to draw
candidates from document-level contexts.

Genomics The GENOMICS dataset is a collection of open-access
biomedical papers on gene-wide association studies (GWAS) from
the manually curated GWAS Catalog [42]. Here, we extract relations
between single-nucleotide polymorphisms and human phenotypes
found to be statistically signiﬁcant. This dataset is published in
XML format, thus, we do not have visual representations. We use
this dataset to evaluate how well the Fonduer framework extracts
relations from data that is published natively in a tree-based format.

Comparison Methods. We use two different methods to evalu-
ate the quality of Fonduer’s output: the upper bound of state-of-the-
art KBC systems (Oracle) and manually curated knowledge bases
(Existing Knowledge Bases).

Oracle Existing state-of-the-art information extraction (IE) methods
focus on either textual data or semi-structured and tabular data. We
compare Fonduer against both types of IE methods. Each IE method
can be split into (1) a candidate generation stage and (2) a ﬁltering
stage, the latter of which eliminates false positive candidates. For
comparison, we approximate the upper bound of quality of three
state-of-the-art information extraction techniques by experimentally
measuring the recall achieved in the candidate generation stage
of each technique and assuming that all candidates found using a
particular technique are correct. That is, we assume the ﬁltering
stage is perfect by assuming a precision of 1.0.

• Text: We consider IE methods over text [23, 36]. Here,
candidates are extracted from individual sentences, which
are pre-processed with standard NLP tools to add part-of-
speech tags, linguistic parsing information, etc.

• Table: For tables, we use an IE method for semi-structured
data [3]. Candidates are drawn from individual tables by
utilizing table content and structure.

Table 2: End-to-end quality in terms of precision, recall, and
F1 score for each application compared to the upper bound of
state-of-the-art systems.

Sys.

ELEC.

ADS.

PALEO.

GEN.

Metric
Prec.
Rec.
F1
Prec.
Rec.
F1
Prec.
Rec.
F1
Prec.
Rec.
F1

Text
1.00
0.03
0.06
1.00
0.44
0.61
0.00
0.00
0.00*
0.00
0.00
#
0.00

Table
1.00
0.20
0.40
1.00
0.37
0.54
1.00
0.04
0.08
0.00
0.00
#
0.00

Ensemble
1.00
0.21
0.42
1.00
0.76
0.86
1.00
0.04
0.08
0.00
0.00
#
0.00

Fonduer
0.73
0.81
0.77
0.87
0.89
0.88
0.72
0.38
0.51
0.89
0.81
0.85

* Text did not ﬁnd any candidates.
# No full tuples could be created using Text or Table alone

• Ensemble: We also implement an ensemble (proposed
in [9]) as the union of candidates generated by Text and
Table.

Existing Knowledge Base We use existing knowledge bases as
another comparison method. The ELECTRONICS application is
compared against the transistor speciﬁcations published by Digi-
Key, while GENOMICS is compared to both GWAS Central [4] and
GWAS Catalog [42], which are the most comprehensive collections
of GWAS data and widely-used public datasets. Knowledge bases
such as these are constructed using a combination of manual entry,
web aggregation, paid third-party services, and automation tools.

Fonduer Details. Fonduer is implemented in Python, with
database operations being handled by PostgreSQL. All experiments
are executed in Jupyter Notebooks on a machine with four CPUs
(each CPU is a 14-core 2.40 GHz Xeon E5–4657L), 1 TB RAM,
and 12×3TB hard drives, with the Ubuntu 14.04 operating system.

5.2 Experimental Results

5.2.1 Oracle Comparison We compare the end-to-end qual-
ity of Fonduer to the upper bound of state-of-the-art systems. In
Table 2, we see that Fonduer outperforms these upper bounds for
each dataset. In ELECTRONICS, Fonduer results in a signiﬁcant
improvement of 71 F1 points over a text-only approach. In contrast,
ADVERTISEMENTS has a higher upper bound with text than with
tables, which reﬂects how advertisements rely more on text than the
largely numerical tables found in ELECTRONICS. In the PALEON-
TOLOGY dataset, which depends on linking references from text to
tables, the uniﬁed approach of Fonduer results in an increase of 43
F1 points over the Ensemble baseline. In GENOMICS, all candidates
are cross-context, preventing both the text-only and the table-only
approaches from ﬁnding any valid candidates.

5.2.2 Existing Knowledge Base Comparison We now com-
pare Fonduer against existing knowledge bases for ELECTRONICS
and GENOMICS. No manually curated KBs are available for the other
two datasets. In Table 3, we ﬁnd that Fonduer achieves high cover-
age of the existing knowledge bases, while also correctly extracting
novel relation entries with over 85% accuracy in both applications.
In ELECTRONICS, Fonduer achieved 99% coverage and extracted
an additional 17 correct entries not found in Digi-Key’s catalog. In

Table 3: End-to-end quality vs. existing knowledge bases.

System

Knowledge Base

# Entries in KB
# Entries in Fonduer
Coverage
Accuracy
# New Correct Entries
Increase in Correct Entries

ELEC.

GEN.

Digi-Key

GWAS
GWAS
Catalog
Central
4,023
3,008
6,420
6,420
0.80
0.82
0.89
0.87
2,486
3,154
1.05× 1.87× 1.42×

376
447
0.99
0.87
17

Figure 6: Average F1 score over four relations when broadening
the extraction context scope in ELECTRONICS.

the GENOMICS application, we see that Fonduer provides over 80%
coverage of both existing KBs and ﬁnds 1.87× and 1.42× more
correct entries than GWAS Central and GWAS Catalog, respectively.

Takeaways. Fonduer achieves over 41 F1 points higher quality
on average when compared against the upper bound of state-of-the-
art approaches. Furthermore, Fonduer attains over 80% of the data
in existing public knowledge bases while providing up to 1.87× the
number of correct entries with high accuracy.

5.3 Ablation Studies

We conduct ablation studies to assess the effect of context scope,
multimodal features, featurization approaches, and multimodal su-
pervision on the quality of Fonduer. In each study, we change one
component of Fonduer and hold the others constant.

5.3.1 Context Scope Study To evaluate the importance of
addressing the non-local nature of candidates in richly formatted
data, we analyze how the different context scopes contribute to end-
to-end quality. We limit the extracted candidates to four levels of
context scope in ELECTRONICS and report the average F1 score for
each. Figure 6 shows that increasing context scope can signiﬁcantly
improve the F1 score. Considering document context gives an addi-
tional 71 F1 points (12.8×) over sentence contexts and 47 F1 points
(2.6×) over table contexts. The positive correlation between quality
and context scope matches our expectations, since larger context
scope is required to form candidates jointly from both table content
and surrounding text. We see a smaller increase of 11 F1 points
(1.2×) in quality between page and document contexts since many
of the ELECTRONICS relation mentions are presented on the ﬁrst
page of the document.

Takeaways. Semantics can be distributed in a document or im-
plied in its structure, thus requiring larger context scope than the
traditional sentence-level contexts used in previous KBC systems.

Figure 7: The impact of each modality in the feature library.

of disabling one feature type while leaving all other types enabled,
and report the average F1 scores of each conﬁguration in Figure 7.
We ﬁnd that removing a single feature set resulted in drops of 2 F1
points (no textual features in PALEONTOLOGY) to 33 F1 points (no
textual features in ADVERTISEMENTS). While it is clear in Figure 7
that each application depends on different feature types, we ﬁnd that
it is necessary to incorporate all feature types to achieve the highest
extraction quality.

The characteristics of each dataset affect how valuable each fea-
ture type is to relation classiﬁcation. The ADVERTISEMENTS dataset
consists of webpages that often use tables to format and organize
information—many relations can be found within the same cell or
phrase. This heavy reliance on textual features is reﬂected by the
drop of 33 F1 points when textual features are disabled. In ELEC-
TRONICS, both components of the (part, attribute) tuples we extract
are often isolated from other text. Hence, we see a small drop of 5
F1 points when textual features are disabled. We see a drop of 21 F1
points when structural features are disabled in the PALEONTOLOGY
application due to its reliance on structural features to link between
formation names (found in text sections or table captions) and the
table itself. Finally, we see similar decreases when disabling struc-
tural and tabular features in the GENOMICS application (24 and 29
F1 points, respectively). Because this dataset is published natively
in XML, structural and tabular features are almost perfectly parsed,
which results in similar impacts of these features.

Takeaways. It is necessary to utilize multimodal features to
provide a robust, domain-agnostic description for real-world data.

5.3.3 Featurization Study We compare Fonduer’s multimodal
featurization with: (1) a human-tuned multimodal feature library
that leverages Fonduer’s data model, requiring feature engineering;
(2) a Bi-LSTM with attention model; this RNN considers textual
features only; (3) a machine-learning-based system for information
extraction, referred to as SRV, which relies on HTML features [11];
and (4) a document-level RNN [22], which learns a representation
over all available modes of information captured by Fonduer’s data
model. We ﬁnd that:

5.3.2 Feature Ablation Study We evaluate Fonduer’s multi-
modal features. We analyze how different features beneﬁt informa-
tion extraction from richly formatted data by comparing the effects

• Fonduer’s automatic multimodal featurization approach
produces results that are comparable to manually-tuned fea-
ture representations requiring feature engineering. Fonduer’s

0.060.300.660.7712.8x2.6xQuality (F1)00.51.0SentenceTablePageDocument0.880.550.630.800.74Quality (F1)00.51.0Ads.0.770.720.700.630.69Quality (F1)00.51.0Elec.0.510.490.300.410.34Quality (F1)00.51.0Paleo.0.850.760.610.56Quality (F1)00.51.0Gen.AllNo TextualNo StructuralNo TabularNo VisualTable 4: Comparing approaches to featurization based on
Fonduer’s data model.

Sys.

ELEC.

ADS.

PALEO.

GEN.

Metric Human-tuned
0.71
Prec.
0.82
Rec.
0.76
F1
0.88
Prec.
0.88
Rec.
0.88
F1
0.92
Prec.
0.37
Rec.
0.53
F1
0.92
Prec.
0.82
Rec.
0.87
F1

Bi-LSTM w/ Attn.
0.42
0.50
0.45
0.51
0.43
0.47
0.52
0.15
0.23
0.66
0.41
0.47

Fonduer
0.73
0.81
0.77
0.87
0.89
0.88
0.76
0.38
0.51
0.89
0.81
0.85

Table 5: Comparing the features of SRV and Fonduer.

Feature Model
SRV
Fonduer

Precision
0.72
0.87

Recall
0.34
0.89

F1
0.39
0.88

Table 6: Comparing document-level RNN and Fonduer’s deep-
learning model on a single relation from ELECTRONICS.

Learning Model
Document-level RNN
Fonduer

Runtime during Training (secs/epoch) Quality (F1)
0.26
0.65

37,421
48

neural network is able to extract relations with a quality
comparable to the human-tuned approach in all datasets
differing by no more than 2 F1 points (see Table 4).

• Fonduer’s RNN outperforms a standard, out-of-the-box Bi-
LSTM signiﬁcantly. The F1-score obtained by Fonduer’s
multimodal RNN model is 1.7× to 2.2× higher than that
of a typical Bi-LSTM (see Table 4).

• Fonduer outperforms extraction systems that leverage HTML
features alone. Table 5 shows a comparison between Fonduer
and SRV [11] in the ADVERTISEMENTS domain—the only
one of our datasets with HTML documents as input. Fonduer’s
features capture more information than SRV’s HTML-based
features, which only capture structural and textual informa-
tion. This results in 2.3× higher quality.

• Using a document-level RNN to learn a single representa-
tion across all possible modalities results in neural networks
with structures that are too large and too unique to batch
effectively. This leads to slow runtime during training and
poor-quality KBs. In Table 6, we compare the performance
of a document-level RNN [22] and Fonduer’s approach of
appending non-textual information in the last layer of the
model. As shown Fonduer’s multimodal RNN obtains an
F1-score that is almost 3× higher while being three orders
of magnitude faster to train.

Takeaways. Direct feature engineering is unnecessary when uti-
lizing deep learning as a basis to obtain the feature representation
needed to extract relations from richly formatted data.

5.3.4 Supervision Ablation Study We study how quality is
affected when using only textual LFs, only metadata LFs, and the
combination of the two sets of LFs. Textual LFs only operate on

Figure 8: Study of different supervision resources on quality.
Metadata includes structural, tabular, and visual information.

textual modality characteristics while metadata LFs operate on struc-
tural, tabular, and visual modality characteristics. Figure 8 shows
that applying metadata-based LFs achieves higher quality than tra-
ditional textual-level LFs alone. The highest quality is achieved
when both types of LFs are used. In ELECTRONICS, we see an
increase of 66 F1 points (9.2×) when using metadata LFs and a 3 F1
point (1.04×) improvement over metadata LFs when both types are
used. Because this dataset relies more heavily on distant signals, LFs
that can label correctness based on column or row header content
signiﬁcantly improve extraction quality. The ADVERTISEMENTS
application beneﬁts equally from metadata and textual LFs. Yet, we
get an increase of 20 F1 points (1.2×) when both types of LFs are
applied. The PALEONTOLOGY and GENOMICS applications show
more moderate increases of 40 (4.6×) and 40 (1.8×) F1 points by
using both types over only textual LFs, respectively.

6 USER STUDY
Traditionally, ground truth data is created through manual annotation,
crowdsourcing, or other time-consuming methods and then used as
data for training a machine-learning model. In Fonduer, we use the
data-programming model for users to programmatically generate
training data, rather than needing to perform manual annotation—a
human-in-the-loop approach. In this section we qualitatively evalu-
ate the effectiveness of our approach compared to traditional human
labeling and observe the extent to which users leverage non-textual
semantics when labeling candidates.

We conducted a user study with 10 users, where each user was
asked to complete the relation extraction task of extracting maximum
collector-emitter voltages from the ELECTRONICS dataset. Using
the same experimental settings, we compare the effectiveness of two
approaches for obtaining training data: (1) manual annotations (Man-
ual) and (2) using labeling functions (LF). We selected users with a
basic knowledge of Python but no expertise in the ELECTRONICS
domain. Users completed a 20 minute walk-through to familiarize
themselves with the interface and procedures. To minimize the effect
of cognitive fatigue and familiarity with the task, half of the users
performed the task of manually annotating training data ﬁrst, then
the task of writing labeling functions, while the other half performed
the tasks in the reverse order. We allotted 30 minutes for each task
and evaluated the quality that was achieved using each approach at
several checkpoints. For manual annotations, we evaluated every
ﬁve minutes. We plotted the quality achieved by user’s labeling func-
tions each time the user performed an iteration of supervision and
classiﬁcation as part of Fonduer’s iterative approach. We ﬁltered
out two outliers and report results of eight users.

0.770.880.510.850.740.680.450.730.080.680.110.45AllOnly MetadataOnly TextualQuality (F1)00.51.0Elec.Ads.Paleo.Gen.candidates discovered using separate extraction tasks [9, 14], which
overlooks candidates composed of mentions that must be found
jointly from document-level context scopes.

Multimodality In unstructured data information extraction systems,
only textual features [26] are utilized. Recognizing the need to repre-
sent layout information as well when working with richly formatted
data, various additional feature libraries have been proposed. Some
have relied predominantly on structural features, usually in the con-
text of web tables [11, 30, 31, 39]. Others have built systems that
rely only on visual information [13, 45]. There have been instances
of visual information being used to supplement a tree-based repre-
sentation of a document [8, 20], but these systems were designed for
other tasks, such as document classiﬁcation and page segmentation.
By utilizing our deep-learning-based featurization approach, which
supports all of these representations, Fonduer obviates the need to
focus on feature engineering and frees the user to iterate over the
supervision and learning stages of the framework.

Supervision Sources Distant supervision is one effective way to
programmatically create training data for use in machine learning.
In this paradigm, facts from existing knowledge bases are paired
with unlabeled documents to create noisy or “weakly” labeled train-
ing examples [1, 25, 26, 28]. In addition to existing knowledge
bases, crowdsourcing [12] and heuristics from domain experts [29]
have also proven to be effective weak supervision sources. In our
work, we show that by incorporating all kinds of supervision in
one framework in a noise-aware way, we are able to achieve high
quality in knowledge base construction. Furthermore, through our
programming model, we empower users to add supervision based
on intuition from any modality of data.

8 CONCLUSION

In this paper, we study how to extract information from richly for-
matted data. We show that the key challenges of this problem are
(1) prevalent document-level relations, (2) multimodality, and (3)
data variety. To address these, we propose Fonduer, the ﬁrst KBC
system for richly formatted information extraction. We describe
Fonduer’s data model, which enables users to perform candidate
extraction, multimodal featurization, and multimodal supervision
through a simple programming model. We evaluate Fonduer on
four real-world domains and show an average improvement of 41
F1 points over the upper bound of state-of-the-art approaches. In
some domains, Fonduer extracts up to 1.87× the number of correct
relations compared to expert-curated public knowledge bases.

Acknowledgments We gratefully acknowledge the support of DARPA under No.
N66001-15-C-4043 (SIMPLEX), No. FA8750-17-2-0095 (D3M), No. FA8750-12-2-
0335, and No. FA8750-13-2-0039, DOE 108845, NIH U54EB020405, ONR under
No. N000141712266 and No. N000141310129, the Intel/NSF CPS Security grant
No. 1505728, the Secure Internet of Things Project, Qualcomm, Ericsson, Analog
Devices, the National Science Foundation Graduate Research Fellowship under Grant
No. DGE-114747, the Stanford Finch Family Fellowship. the Moore Foundation, the
Okawa Research Grant, American Family Insurance, Accenture, Toshiba, and members
of the Stanford DAWN project: Intel, Microsoft, Google, Teradata, and VMware. We
thank Holly Chiang, Bryan He, and Yuhao Zhang for helpful discussions. We also thank
Prabal Dutta, Mark Horowitz, and Bj¨orn Hartmann for their feedback on early versions
of this work. The U.S. Government is authorized to reproduce and distribute reprints for
Governmental purposes notwithstanding any copyright notation thereon. Any opinions,
ﬁndings, and conclusions or recommendations expressed in this material are those of
the authors and do not necessarily reﬂect the views, policies, or endorsements, either
expressed or implied, of DARPA, DOE, NIH, ONR, or the U.S. Government.

Figure 9: F1 quality over time with 95% conﬁdence intervals
(left). Modality distribution of user labeling functions (right).

In Figure 9 (left), we report the quality (F1 score) achieved by the
two different approaches. The average F1 achieved using manual
annotation was 0.26 while the average F1 score using labeling func-
tions was 0.49, an improvement of 1.9×. We found with statistical
signiﬁcance that all users were able to achieve higher F1 scores using
labeling functions than manually annotating candidates, regardless
of the order in which they performed the approaches. There are
two primary reasons for this trend. First, labeling functions provide
a larger set of training data than manual annotations by enabling
users to apply patterns they ﬁnd in the data programmatically to all
candidates—a natural desire they often vocalized while performing
manual annotation. On average, our users manually labeled 285 can-
didates in the allotted time, while the labeling functions they created
labeled 19,075 candidates. Users provided seven labeling functions
on average. Second, labeling functions tend to allow Fonduer to
learn more generic features, whereas manual annotations may not
adequately cover the characteristics of the dataset as a whole. For
example, labeling functions are easily applied to new data.

In addition, we found that for richly formatted data, users relied
less on textual information—a primary signal in traditional KBC
tasks—and more on information from other modalities, as shown
in Figure 9 (right). Users utilized the semantics from multiple
modalities of the richly formatted data, with 58.5% of their labeling
functions using tabular information. This reﬂects the characteristics
of the ELECTRONICS dataset, which contains information that is
primarily found in tables. In our study, the most common labeling
functions in each modality were:

• Tabular: labeling a candidate based on the words found in

the same row or column.

• Visual: labeling a candidate based on its placement in a

document (e.g., which page it was found on).

• Structural: labeling a candidate based on its tag names.
• Textual: labeling a candidate based on the textual charac-

teristics of the voltage mention (e.g. magnitude).

Takeaways. We found that when working with richly formatted
data, users relied heavily on non-textual signals to identify candi-
dates and weakly supervise the KBC system. Furthermore, leverag-
ing weak supervision allowed users to create knowledge bases more
effectively than traditional manual annotations alone.

7 RELATED WORK
We brieﬂy review prior work in a few categories.

Context Scope Existing KBC systems often restrict candidates to
speciﬁc context scopes such as single sentences [23, 44] or tables [7].
Others perform KBC from richly formatted data by ensembling

LFManualQuality (F1)0.20.40.6Time (min)0102030Ratio00.51.0Txt.Str.Tab.Vis.References

[1] G. Angeli, S. Gupta, M. Jose, C. D. Manning, C. R´e, J. Tibshirani, J. Y. Wu,
S. Wu, and C. Zhang. Stanford’s 2014 slot ﬁlling systems. TAC KBP, 695, 2014.
[2] D. Bahdanau, K. Cho, and Y. Bengio. Neural machine translation by jointly

learning to align and translate. arXiv preprint arXiv:1409.0473, 2014.

[3] D. W. Barowy, S. Gulwani, T. Hart, and B. Zorn. Flashrelate: extracting relational
In ACM SIGPLAN

data from semi-structured spreadsheets using examples.
Notices, volume 50, pages 218–228. ACM, 2015.

[4] T. Beck, R. K. Hastings, S. Gollapudi, R. C. Free, and A. J. Brookes. Gwas central:
a comprehensive resource for the comparison and interrogation of genome-wide
association studies. EJHG, 22(7):949–952, 2014.

[5] K. Bollacker, C. Evans, P. Paritosh, T. Sturge, and J. Taylor. Freebase: a collabo-
ratively created graph database for structuring human knowledge. In SIGMOD,
pages 1247–1250. ACM, 2008.

[6] E. Brown, E. Epstein, J. W. Murdock, and T.-H. Fin. Tools and methods for

building watson. IBM Research. Abgerufen am, 14:2013, 2013.

[7] A. Carlson, J. Betteridge, B. Kisiel, B. Settles, E. R. Hruschka Jr, and T. M.
Mitchell. Toward an architecture for never-ending language learning. In AAAI,
volume 5, page 3, 2010.

[8] M. Cosulschi, N. Constantinescu, and M. Gabroveanu. Classifcation and com-
parison of information structures from a web page. Annals of the University of
Craiova-Mathematics and Computer Science Series, 31, 2004.

[9] X. Dong, E. Gabrilovich, G. Heitz, W. Horn, N. Lao, K. Murphy, T. Strohmann,
S. Sun, and W. Zhang. Knowledge vault: A web-scale approach to probabilistic
knowledge fusion. In SIGKDD, pages 601–610. ACM, 2014.

[10] D. Ferrucci, E. Brown, J. Chu-Carroll, J. Fan, D. Gondek, A. A. Kalyanpur,
A. Lally, J. W. Murdock, E. Nyberg, J. Prager, et al. Building watson: An
overview of the deepqa project. AI magazine, 31(3):59–79, 2010.

[11] D. Freitag. Information extraction from html: Application of a general machine

learning approach. In AAAI/IAAI, pages 517–523, 1998.

[12] H. Gao, G. Barbier, and R. Goolsby. Harnessing the crowdsourcing power of

social media for disaster relief. IEEE Intelligent Systems, 26(3):10–14, 2011.

[13] W. Gatterbauer, P. Bohunsky, M. Herzog, B. Kr¨upl, and B. Pollak. Towards
domain-independent information extraction from web tables. In WWW, pages
71–80, 2007.

[14] V. Govindaraju, C. Zhang, and C. R´e. Understanding tables in context using

standard nlp toolkits. In ACL, pages 658–664, 2013.

[15] A. Graves, M. Liwicki, S. Fern´andez, R. Bertolami, H. Bunke, and J. Schmidhuber.
A novel connectionist system for unconstrained handwriting recognition. IEEE
transactions on pattern analysis and machine intelligence, 31(5):855–868, 2009.
[16] A. Graves, A.-r. Mohamed, and G. Hinton. Speech recognition with deep recurrent
neural networks. In Acoustics, speech and signal processing (icassp), 2013 ieee
international conference on, pages 6645–6649. IEEE, 2013.

[17] M. Hewett, D. E. Oliver, D. L. Rubin, K. L. Easton, J. M. Stuart, R. B. Altman,
and T. E. Klein. Pharmgkb: the pharmacogenetics knowledge base. Nucleic acids
research, 30(1):163–165, 2002.

[18] S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural computation,

9(8):1735–1780, 1997.

[19] N. Japkowicz and S. Stephen. The class imbalance problem: A systematic study.

Intelligent data analysis, 6(5):429–449, 2002.

[20] M. Kovacevic, M. Diligenti, M. Gori, and V. Milutinovic. Recognition of common
areas in a web page using visual information: a possible application in a page
classiﬁcation. In ICDM, pages 250–257, 2002.

[21] Y. LeCun, Y. Bengio, and G. Hinton. Deep learning. Nature, 521(7553):436–444,

2015.

[22] J. Li, T. Luong, and D. Jurafsky. A hierarchical neural autoencoder for paragraphs

and documents. In ACL, pages 1106–1115, 2015.

[23] A. Madaan, A. Mittal, G. R. Mausam, G. Ramakrishnan, and S. Sarawagi. Nu-
merical relation extraction with minimal supervision. In AAAI, pages 2764–2771,
2016.

[24] C. Manning. Representations for language: From word embeddings to sentence
meanings. https://simons.berkeley.edu/talks/christopher-manning-2017-3-27,
2017.

[25] B. Min, R. Grishman, L. Wan, C. Wang, and D. Gondek. Distant supervision for
relation extraction with an incomplete knowledge base. In HLT-NAACL, pages
777–782, 2013.

[26] M. Mintz, S. Bills, R. Snow, and D. Jurafsky. Distant supervision for relation

extraction without labeled data. In ACL, pages 1003–1011, 2009.

[27] N. Nakashole, M. Theobald, and G. Weikum. Scalable knowledge harvesting
with high precision and high recall. In WSDM, pages 227–236. ACM, 2011.
[28] T.-V. T. Nguyen and A. Moschitti. End-to-end relation extraction using distant
supervision from external semantic repositories. In HLT, pages 277–282, 2011.
[29] P. Pasupat and P. Liang. Zero-shot entity extraction from web pages. In ACL (1),

pages 391–401, 2014.

[30] G. Penn, J. Hu, H. Luo, and R. T. McDonald. Flexible web document analysis for
delivery to narrow-bandwidth devices. In ICDAR, volume 1, pages 1074–1078,
2001.

[31] D. Pinto, M. Branstein, R. Coleman, W. B. Croft, M. King, W. Li, and X. Wei.
Quasm: a system for question answering using semi-structured data. In JCDL,
pages 46–55, 2002.

[32] A. Ratner, S. H. Bach, H. Ehrenberg, J. Fries, S. Wu, and C. R´e. Snorkel: Rapid
training data creation with weak supervision. VLDB, 11(3):269–282, 2017.
[33] A. Ratner, C. M. De Sa, S. Wu, D. Selsam, and C. R´e. Data programming:

Creating large training sets, quickly. In NIPS, pages 3567–3575, 2016.

[34] C. R´e, A. A. Sadeghian, Z. Shan, J. Shin, F. Wang, S. Wu, and C. Zhang. Feature
engineering for knowledge base construction. IEEE Data Engineering Bulletin,
2014.

[35] B. Settles. Active learning literature survey. 2010. Computer Sciences Technical

Report, 1648.

[36] J. Shin, S. Wu, F. Wang, C. De Sa, C. Zhang, and C. R´e. Incremental knowledge

base construction using deepdive. VLDB, 8(11):1310–1321, 2015.

[37] A. Singhal. Introducing the knowledge graph: things, not strings. Ofﬁcial google

blog, 2012.

[38] F. M. Suchanek, G. Kasneci, and G. Weikum. Yago: A large ontology from
wikipedia and wordnet. Web Semantics: Science, Services and Agents on the
World Wide Web, 6(3):203–217, 2008.

[39] A. Tengli, Y. Yang, and N. L. Ma. Learning table extraction from examples. In

COLING, page 987, 2004.

[40] J. Turian, L. Ratinov, and Y. Bengio. Word representations: a simple and general

method for semi-supervised learning. In ACL, pages 384–394, 2010.

[41] P. Verga, D. Belanger, E. Strubell, B. Roth, and A. McCallum. Multilingual
relation extraction using compositional universal schema. In HLT-NAACL, pages
886–896, 2016.

[42] D. Welter, J. MacArthur, J. Morales, T. Burdett, P. Hall, H. Junkins, A. Klemm,
P. Flicek, T. Manolio, L. Hindorff, et al. The nhgri gwas catalog, a curated
resource of snp-trait associations. Nucleic acids research, 42:D1001–D1006,
2014.

[43] Y. Wu, M. Schuster, Z. Chen, Q. V. Le, M. Norouzi, W. Macherey, M. Krikun,
Y. Cao, Q. Gao, K. Macherey, et al. Google’s neural machine translation sys-
tem: Bridging the gap between human and machine translation. arXiv preprint
arXiv:1609.08144, 2016.

[44] M. Yahya, S. E. Whang, R. Gupta, and A. Halevy. ReNoun : Fact Extraction for

Nominal Attributes. EMNLP, pages 325–335, 2014.

[45] Y. Yang and H. Zhang. Html page analysis based on visual cues. In ICDAR, pages

859–864, 2001.

[46] Y. Zhang, A. Chaganty, A. Paranjape, D. Chen, J. Bolton, P. Qi, and C. D. Manning.
Stanford at tac kbp 2016: Sealing pipeline leaks and understanding chinese. TAC,
2016.

A DATA PROGRAMMING

Machine-learning-based KBC systems rely heavily on ground truth
data (called training data) to achieve high quality. Traditionally,
manual annotations or incomplete KBs are used to construct train-
ing data for machine-learning-based KBC systems. However, these
resources are either costly to obtain or may have limited coverage
over the candidates considered during the KBC process. To address
this challenge, Fonduer builds upon the newly introduced paradigm
of data programming [33], which enables both domain experts and
non-domain experts alike to programmatically generate large train-
ing datasets by leveraging multiple weak supervision sources and
domain knowledge.

In data programming, which provides a framework for weak
supervision, users provide weak supervision in the form of user-
deﬁned functions, called labeling functions. Each labeling function
provides potentially noisy labels for a subset of the input data and
are combined to create large, potentially overlapping sets of labels
which can be used to train a machine-learning model. Many different
weak-supervision approaches can be expressed as labeling functions.
This includes strategies that use existing knowledge bases, individual
annotators’ labels (as in crowdsourcing), or user-deﬁned functions
that rely on domain-speciﬁc patterns and dictionaries to assign labels
to the input data.

The aforementioned sources of supervision can have varying
degrees of accuracy, and may conﬂict with each other. Data pro-
gramming relies on a generative probabilistic model to estimate the
accuracy of each labeling function by reasoning about the conﬂicts
and overlap across labeling functions. The estimated labeling func-
tion accuracies are in turn used to assign a probabilistic label to each
candidate. These labels are used in conjunction with a noise-aware
discriminative model to train a machine-learning model for KBC.

A.1 Components of Data Programming

The main components in data programming are as follows:

Candidates A set of candidates C to be probabilistically classiﬁed.

Labeling Functions Labeling functions are used to programmat-
ically provide labels for training data. A labeling function is a
user-deﬁned procedure that takes a candidate as input and outputs
a label. Labels can be as simple as true or false for binary tasks, or
one of many classes for more complex multiclass tasks. Since each
labeling function is applied to all candidates and labeling functions
are rarely perfectly accurate, there may be disagreements between
them. The labeling functions provided by the user for binary classi-
ﬁcation can be more formally deﬁned as follows. For each labeling
function λi and r ∈ C, we have λi : r (cid:55)→ {−1, 0, 1} where +1 or −1
denotes a candidate as “True” or “False” and 0 abstains. The output
of applying a set of l labeling functions to k candidates is the label
matrix Λ ∈ {−1, 0, 1}k×l.

Output Data-programming frameworks output a conﬁdence value
p for the classiﬁcation for each candidate as a vector Y ∈ {p}k.

To perform data programming in Fonduer, we rely on a data-
programming engine, Snorkel [32]. Snorkel accepts candidates
and labels as input and produces marginal probabilities for each
candidate as output. These input and output components are stored
as relational tables. Their schemas are detailed in Section 3.

A.2 Theoretical Guarantees

While data programming uses labeling functions to generate noisy
training data, it theoretically achieves a learning rate similar to meth-
ods that use manually labeled data [33]. In the typical supervised-
learning setup, users are required to manually label ˜O((cid:15)−2) ex-
amples for the target model to achieve an expected loss of (cid:15). To
achieve this rate, data programming only requires the user to specify
a constant number of labeling functions that does not depend on
(cid:15). Let β be the minimum coverage across labeling functions (i.e.,
the probability that a labeling function provides a label for an input
point) and γ be the minimum reliability of labeling functions, where
γ = 2 · a − 1 with a denoting the accuracy of a labeling function.
Then under the assumptions that (1) labeling functions are condition-
ally independent given the true labels of input data, (2) the number
of user-provided labeling functions is at least ˜O(γ−3β−1), and (3)
there are k = ˜O((cid:15)−2) candidates, data programming achieves an
expected loss (cid:15). Despite the strict assumptions with respect to la-
beling functions, we ﬁnd that using data programming to develop
KBC systems for richly formatted data leads to high-quality KBs
(across diverse real-world applications) even when some of the data-
programming assumptions are not met (see Section 5.2).

B EXTENDED FEATURE LIBRARY

Fonduer augments a bidirectional LSTM with features from an
extended feature library in order to better model the multiple modal-
ities of richly formatted data. In addition, these extended features
can provide signals drawn from large contexts since they can be
calculated using Fonduer’s data model of the document rather than
being limited to a single sentence or table. In Section 5, we ﬁnd that
including multimodal features is critical to achieving high-quality
relation extraction. The provided extended feature library serves
as a baseline example of these types of features that can be easily
enhanced in the future. However, even with these baseline features,
our users have been able to build high-quality knowledge bases for
their applications.

The extended feature library consists of a baseline set of fea-
tures from the structural, tabular, and visual modalities. Table 7
lists the details of the extended feature library. Features are rep-
resented as strings, and each feature space is then mapped into a
one-dimensional bit vector for each candidate, where each bit repre-
sents whether the candidate has the corresponding feature.

C Fonduer AT SCALE

We use two optimizations to enable Fonduer’s scalability to mil-
lions of candidates (see Section 3.1): (1) data caching and (2) data
representations that optimize data access during the KBC process.
Such optimizations are standard in database systems. Nonetheless,
their impact on KBC has not been studied in detail.

Each candidate to be classiﬁed by Fonduer’s LSTM as “True” or
“False” is associated with a set of mentions (see Section 3.2). For
each candidate, Fonduer’s multimodal featurization generates fea-
tures that describe each individual mention in isolation and features
that jointly describe the set of all mentions in the candidate. Since
each mention can be associated with many different candidates, we
cache the featurization of each mention. Caching during featuriza-
tion results in a 100× speed-up on average in the ELECTRONICS
domain yet only accounts for 10% of this stage’s memory usage.

Recall from Section 3.3 that Fonduer’s programming model in-
troduces two modes of operation: (1) development, where users
iteratively improve the quality of labeling functions without execut-
ing the entire pipeline; and (2) production, where the full pipeline is
executed once to produce the knowledge base. We use different data
representations to implement the abstract data structures of Features
and Labels (a structure that stores the output of labeling functions
after applying them over the generated candidates). Implementing
Features as a list-of-lists structure minimizes runtime in both modes
of operation since it accounts for sparsity. We also ﬁnd that Labels
implemented as a coordinate list during the development mode are
optimal for fast updates. A list-of-lists implementation is used for
Labels in production mode.

C.1 Data Caching

With richly formatted data, which frequently requires document-
level context, thousands of candidates need to be featurized for each
document. Candidate features from the extended feature library are
computed at both the mention level and relation level by traversing
the data model accessing modality attributes. Because each mention
is part of many candidates, na¨ıve featurization of candidates can

Table 7: Features from Fonduer’s feature library. Example values are drawn from the example candidate in Figure 1. Capitalized
preﬁxes represent the feature templates and the remainder of the string represents a feature’s value.

Description

Position of a node among its siblings

Row number of the mention
Column number of the mention

Row header n-grams in the table of the mention
Column header n-grams in the table of the mention

Feature Type Arity
Structural
Structural
Structural
Structural
Structural
Structural
Structural
Structural
Structural
Structural
Structural
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Tabular
Visual
Visual
Visual
Visual
Visual
Visual
Visual
Visual

Unary HTML tag of the mention
Unary HTML attributes of the mention
Unary HTML tag of the mention’s parent
Unary HTML tag of the mention’s previous sibling
Unary HTML tag of the mention’s next sibling
Unary
Unary HTML class sequence of the mention’s ancestors
Unary HTML tag sequence of the mention’s ancestors
Unary HTML ID’s of the mention’s ancestors
Binary HTML tags shared between mentions on the path to the root of the document
Binary Minimum distance between two mentions to their lowest common ancestor
Unary N-grams in the same cell as the mentiona
Unary
Unary
Unary Number of rows the mention spans
Unary Number of columns the mention spans
Unary
Unary
Unary N-grams from all Cells that are in the same row as the given mentiona
Unary N-grams from all Cells that are in the same column as the given mentiona
Binary Whether two mentions are in the same table
Binary Row number difference if two mentions are in the same table
Binary Column number difference if two mentions are in the same table
Binary Manhattan distance between two mentions in the same table
Binary Whether two mentions are in the same cell
Binary Word distance between mentions in the same cell
Binary Character distance between mentions in the same cell
Binary Whether two mentions in a cell are in the same sentence
Binary Whether two mention are in the different tables
Binary Row number difference if two mentions are in different tables
Binary Column number difference if two mentions are in different tables
Binary Manhattan distance between two mentions in different tables
Unary N-grams of all lemmas visually aligned with the mentiona
Unary
Binary Whether two mentions are on the same page
Binary Whether two mentions are horizontally aligned
Binary Whether two mentions are vertically aligned
Binary Whether two mentions’ left bounding-box borders are vertically aligned
Binary Whether two mentions’ right bounding-box borders are vertically aligned
Binary Whether the centers of two mentions’ bounding boxes are vertically aligned

Page number of the mention

Example Value
TAG <h1>

HTML ATTR font-family:Arial

PARENT TAG <p>

PREV SIB TAG <td>

NEXT SIB TAG <h1>

NODE POS 1

ANCESTOR CLASS <s1>

ANCESTOR TAG <body> <p>
ANCESTOR ID l1b
COMMON ANCESTOR <body>

LOWEST ANCESTOR DEPTH 1
CELL cevb
ROW NUM 5

COL NUM 3

ROW SPAN 1

COL SPAN 1

ROW HEAD collector

COL HEAD value
ROW 200 [ma]c
COL 200 [6]c
SAME TABLEb
SAME TABLE ROW DIFF 1b
SAME TABLE COL DIFF 3b
SAME TABLE MANHATTAN DIST 10b
SAME CELLb
WORD DIFF 1b
CHAR DIFF 1b
SAME PHRASEb
DIFF TABLEb
DIFF TABLE ROW DIFF 4b
DIFF TABLE COL DIFF 2b
DIFF TABLE MANHATTAN DIST 7b
ALIGNED current

PAGE 1

SAME PAGE
HORZ ALIGNEDb
VERT ALIGNED
VERT ALIGNED LEFTb
VERT ALIGNED RIGHTb
VERT ALIGNED CENTERb

a All N-grams are 1-grams by default.
b This feature was not present in the example candidate. The values shown are example values from other documents.
c In this example, the mention is 200, which forms part of the feature preﬁx. The value is shown in square brackets.

result in the redundant computation of thousands of mention features.
This pattern highlights the value of data caching when performing
multimodal featurization on richly formatted data.

Traditional KBC systems that operate on single sentences of
unstructured text pragmatically assume that only a small number of
candidates will need to be featurized for each sentence and do not
cache mention features as a result.

Example C.1 (Inefﬁcient Featurization). In Figure 1, the transistor
part mention MMBT3904 could be matched with up to 15 different
numerical values in the datasheet. Without caching, the features of
the MMBT3904 would be unnecessarily recalculated 14 times, once
for each candidate. In real documents 100s of feature calculations
would be wasted.

In Example C.1, eliminating unnecessary feature computations can
improve performance by an order of magnitude.

To optimize the feature-generation process, Fonduer implements
a document-level caching scheme for mention features. The ﬁrst
computation of a mention feature requires traversing the data model.
Then, the result is cached for fast access if the feature is needed
again. All features are cached until all candidates in a document are
fully featurized, after which the cache is ﬂushed. Because Fonduer
operates on documents atomically, caching a single document at
a time improves performance without adding signiﬁcant memory
overhead. In the ELECTRONICS application, we ﬁnd that caching
achieves over 100× speed-up on average and in some cases even
over 1000×, while only accounting for approximately 10% of the
memory footprint of the featurization stage.

Takeaways. When performing feature generation from richly for-
matted data, caching the intermediate results can yield over 1000×
improvements in featurization runtime without adding signiﬁcant
memory overhead.

C.2 Data Representations

The Fonduer programming model involves two modes of operation:
(1) development and (2) production. In development, users itera-
tively improve the quality of their labeling functions through error
analysis and without executing the full pipeline as in previous tech-
niques such as incremental KBC [36]. Once the labeling functions
are ﬁnalized, the Fonduer pipeline is only run once in production.
In both modes of operation, Fonduer produces two abstract data
structures (Features and Labels as described in Section 3). These
data structures have three access patterns: (1) materialization, where
the data structure is created; (2) updates, which include inserts,
deletions, and value changes; and (3) queries, where users can
inspect the features and labels to make informed updates to labeling
functions.

Both Features and Labels can be viewed as matrices, where each
row represents annotations for a candidate (see Section 3.2). Fea-
tures are dynamically named during multimodal featurization but
are static for the lifetime of a candidate. Labels are statically named
in classiﬁcation but updated during development. Typically Fea-
tures are sparse: in the ELECTRONICS application, each candidate
has about 100 features while the number of unique features can be
more than 10M. Labels are also sparse, where the number of unique
labels is the number of labeling functions.

The data representation that is implemented to store these abstract
data structures can signiﬁcantly affect overall system runtime. In the
ELECTRONICS application, multimodal featurization accounts for
50% of end-to-end runtime, while classiﬁcation accounts for 15%.
We discuss two common sparse matrix representations that can be
materialized in a SQL database.

• List of lists (LIL): Each row stores a list of (column key,
value) pairs. Zero-valued pairs are omitted. An entire row
can be retrieved in a single query. However, updating values
requires iterating over sublists.

• Coordinate list (COO): Rows store (row key, column -
key, value) triples. Zero-valued triples are omitted. With
COO, multiple queries must be performed to fetch a row’s
attributes. However, updating values takes constant time.

The choice of data representation for Features and Labels reﬂects
their different access patterns, as well as the mode of operation.
During development, Features are materialized once, but frequently
queried during the iterative KBC process. Labels are updated each
time a user modiﬁes labeling functions. In production, Features’
access pattern remains the same. However, Labels are not updated
once users have ﬁnalized their set of labeling functions.

From the access patterns in the Fonduer pipeline, and the char-
acteristics of each sparse matrix representation, we ﬁnd that imple-
menting Features as an LIL minimizes runtime in production and
development. Labels, however, should be implemented as COO to
support fast insertions during iterative KBC and reduce runtimes for
each iteration. In production, Labels can also be implemented as LIL
to avoid the computation overhead of COO. In the ELECTRONICS
application, we ﬁnd that LIL provides 1.4× speed-up over COO in
production and that COO provides over 5.8× speed-up over LIL
when adding a new labeling function.

Takeaways. We ﬁnd that Labels should be implemented as a
coordinate list during development, which supports fast updates for
supervision, while Features should use a list of lists, which provides
faster query times. In production, both Features and Labels should
use a list-of-list representation.

D FUTURE WORK
Being able to extract information from richly formatted data enables
a wide range of applications, and represents a new and interesting
research direction. While we have demonstrated that Fonduer can
already obtain high-quality knowledge bases in several applications,
we recognize that many interesting challenges remain. We brieﬂy
discuss some of these challenges.

Data Model One challenge in extracting information from richly
formatted data comes directly at the data level—we cannot perfectly
preserve all document information. Future work in parsing, OCR,
and computer vision have the potential to improve the quality of
Fonduer’s data model for complex table structures and ﬁgures. For
example, improving the granularity of Fonduer’s data model to be
able to identify axis titles, legends, and footnotes could provide
additional signals to learn from and additional speciﬁcity for users
to leverage while using the Fonduer programming model.

Deep-Learning Model Fonduer’s multimodal recurrent neural
network provides a prototypical automated featurization approach
that achieves high quality across several domains. However, fu-
ture developments for incorporating domain-speciﬁc features could
strengthen these models. In addition, it may be possible to expand
our deep-learning model to perform additional tasks (e.g., identify-
ing candidates) to simplify the Fonduer pipeline.

Programming Model Fonduer currently exposes a Python inter-
face to allow users to provide weak supervision. However, further
research in user interfaces for weak supervision could bolster user
efﬁciency in Fonduer. For example, allowing users to use natural
language or graphical interfaces in supervision may result in im-
proved efﬁciency and reduced development time through a more
powerful programming model. Similarly, feedback techniques like
active learning [35] could empower users to more quickly recognize
classes of candidates that need further disambiguation with LFs.

