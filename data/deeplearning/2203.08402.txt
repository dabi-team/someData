2
2
0
2

r
a

M
6
1

]
L
P
.
s
c
[

1
v
2
0
4
8
0
.
3
0
2
2
:
v
i
X
r
a

Gradual Tensor Shape Checking

MOMOKO HATTORI, The University of Tokyo, Japan
NAOKI KOBAYASHI, The University of Tokyo, Japan
RYOSUKE SATO, The University of Tokyo, Japan

Tensor shape mismatch is a common source of bugs in deep learning programs. Most of the studies conducted
to solve this problem use the whole-program analysis approach, which lacks compositionality. A type-based
approach is desirable in this respect, but since the problem of shape inference is undecidable in general, fully
automated shape inference is bound to be either unsound or too conservative.

We propose a type-based approach to detect tensor shape mismatches that works practically under such
limitations. One of the main features of our approach is the best-eï¬€ort shape inference. Because of the un-
decidability of shape inference, our procedure performs it only in a best-eï¬€ort manner. The inference result
may be too imprecise to statically guarantee the absence of the shape inconsistencies, and in such cases, dy-
namic checks are inserted into the program. Another main feature is gradual typing. Users can improve the
precision of the inference by adding appropriate type annotations to the program.

We formalize our approach and prove that it satisï¬es the criteria of gradual typing proposed by Siek et al.
in 2015. We implement a prototype shape checking tool based on our approach and evaluate its eï¬€ectiveness
by applying it to some deep neural network programs.

CCS Concepts: â€¢ Software and its engineering â†’ Formal software veriï¬cation.

Additional Key Words and Phrases: reï¬nement types, gradual typing

1 INTRODUCTION

1.1 Tensor Shape Checking and Its Diï¬€iculty
Tensor shape mismatch is one of the common sources of dynamic errors in programs that use
tensors (i.e., multi-dimensional arrays). For example, consider the reshape function of tensors. The
reshape operation takes a tensor ğ‘¥ and an integer list ğ‘† and returns a new tensor of the shape ğ‘†
obtained by realigning the elements in ğ‘¥. The input tensor ğ‘¥ and the return value of the reshape
operation must have the same number of elements. Therefore, one can successfully reshape a
tensor of shape [2; 3; 4]1 into a shape [3; 2; 4], while trying to reshape it into [3; 4] results in a
runtime error.

One of the domains that frequently uses tensors is deep learning. Since deep learning programs
often take a considerable amount of time to train networks, it is often the case that a program
takes hours and days to compute the weights of deep neural networks only to be terminated by
one tensor shape mismatch error, throwing away the trained weights. What is even worse is that
some tensor shape mismatches are harder to notice. For example, mixing up the height and the
width of square images does not result in runtime errors but only degrades the performance of the
neural network.

Some methods have been proposed to detect such errors before the execution, and they can be
classiï¬ed into two categories. One is the whole-program analysis approach [15, 26] which keeps
track of the tensor shape by partially evaluating the program in the style of abstract interpretation.
The other is the type-based approach [1, 22] which expresses the shapes of the tensors as a part of
the type information. Still, none of them is fully satisfactory: either they are too conservative and
reject valid programs or fail to detect shape mismatch errors.

1In this paper, we denote lists in the OCaml-style as in [1; 2; 3] to disambiguate it from the citations.

Authorsâ€™ addresses: Momoko Hattori, hattori@kb.is.s.u-tokyo.ac.jp, The University of Tokyo, Tokyo, Japan; Naoki
Kobayashi, , The University of Tokyo, Tokyo, Japan; Ryosuke Sato, , The University of Tokyo, Tokyo, Japan.

 
 
 
 
 
 
2

Hattori et al.

1 let model s =

2

3

let f = ... in let g = ... in
fun x -> let x1 = f x in g x1

4
5 let _ = model 1 (Tensor.rand [20])

Fig. 1. An OCaml program written with OCaml-Torch.

This paper pursuits a type-based approach as it is expected to provide modular detection of
tensor shape inconsistencies. One of the main diï¬ƒculties in this approach is that shapes are ï¬rst-
class objects. For example, the library function Tensor.zeros of OCaml-Torch [2] (which provides
OCaml bindings for libtorch [19]) takes a list ğ‘† of integers, and returns a new tensor whose shape
is ğ‘†. Thus, we have to work with dependent types: Tensor.zeros would be given the type

ğ‘† : int list â†’ {ğ‘Ÿ : int | ğ‘Ÿ .shape = ğ‘† }.

It is diï¬ƒcult to infer such dependent (reï¬nement) types fully automatically. Yet, we wish to avoid
programmersâ€™ burden of writing too many type annotations.

Another diï¬ƒculty is that shape constraints can be so complex that even type checking, let alone
inference, can be too costly or impossible. For instance, the reshape operation that we explained
earlier needs the proof that the shape of the input tensor ğ‘¥ is compatible with the given shape
ğ‘† = [ğ‘ 1; . . . ; ğ‘ ğ‘›] (i.e., if the shape of ğ‘¥ is to be [ğ‘  â€²
ğ‘–=1ğ‘ ğ‘– holds)2. Thus, type
checking requires complex reasoning about integer arithmetic and lists.

ğ‘š], then Î ğ‘š

1; . . . ; ğ‘  â€²

ğ‘–=1ğ‘  â€²
ğ‘–

= Î ğ‘›

1.2 Overview of Our Approach

Based on the observations above, we propose an approach that works practically under such dif-
ï¬culties. Our approach can be characterized by three main features: best-eï¬€ort type inference,
hybrid type checking, and gradual typing [24]. We explain those features using our prototype tool
GraTen.

1.2.1 Best-Eï¬€ort Type Inference. One of the main features of our approach is that it provides best-
eï¬€ort type and shape inference. Although it is performed in a best-eï¬€ort manner, it enables the
type checker to work on programs with no type annotations and still detect some simple shape
mismatches.

As an example, we use the program presented in Figure 1 and illustrate how GraTen analyzes
it. The function model takes an integer parameter s, deï¬nes functions f and g, and returns a layer
(function that takes tensor and returns a tensor) which composes f and g. The deï¬nitions of f and
g are omitted here, but let us assume that their respective types are as below, where s in the type
of f is the argument of model.

f : ğ‘¥:{ğœˆ : tensor | len(ğœˆ .shape) = 1} â†’ tensor

g : tensor( [10]) â†’ tensor( [1])

nth(0, ğ‘¥ .shape)
s

(cid:18) (cid:20)

(cid:21) (cid:19)

These types indicate that ğ‘“ takes a 1-dimensional tensor (i.e., a vector) and returns a vector whose
length is one-sth of the length of the argument, and ğ‘” expects a vector of length 10 and returns a
vector of length 1. We formally introduce the syntax of the types later in Section 2.

For this program, GraTen infers the following type for the function model with its best-eï¬€ort
= 10 for the shape of ğ‘¥ is necessary for this program not to

inference. The constraint nth(0,ğœˆ.shape)

ğ‘ 

2Actually, even worse, some ğ‘ ğ‘– can be âˆ’1, in which case, the size of the ğ‘–-th dimension is unspeciï¬ed.

Gradual Tensor Shape Checking

1 let model s =

2

3

let f = ... in let g = ... in
fun x -> let x1 = if s = 1 then x else f x in g x1

3

Fig. 2. The program from Figure 1 with small modification.

1 let model s =

2

3

4

let f = ... in let g = ... in
fun x -> let x1 = if s = 1 then x else f x in

g (assert (x1.shape = [10]); x1)

Fig. 3. A program returned from GraTen after running it against the program in Figure 2.

1 let model s =

2

3

4

let f = ... in let g = ... in
fun x ->

let x1 = (if s = 1 then x else f x : tensor([nth 0 x.shape / s])) in g x1

Fig. 4. The program from Figure 2 after adding type annotations.

raise shape mismatch errors at the application of g.

ğ‘ :int â†’ ğ‘¥:

ğœˆ:tensor | len(ğœˆ .shape) = 1 âˆ§
(cid:26)

nth(0, ğœˆ .shape)
s

= 10

â†’ tensor( [1])

(cid:27)

The inferred type of model is used to prevent any calls to model that can crash anywhere in the
body of model. Indeed, GraTen rejects the calls in line 5 of Figure 1 where the arguments do
not satisfy the constraint nth(0,ğœˆ.shape)
= 10. As such, our approach can statically detect shape
mismatches if the type information of the program (obtained from the type annotations or the
best-eï¬€ort type inference) is precise enough.

s

1.2.2 Hybrid Type Checking. The second feature of our approach is that the type checking is hy-
brid: we combine static and dynamic checking. The type checker inserts assertions to the program
points where the type safety is not statically guaranteed, Ã  la Knowles and Flanaganâ€™s hybrid type
checking [14].

For example, consider the program in Figure 2, which is obtained by adding a conditional branch
to the one in Figure 1. The type of the then and else branch of the if expression is inferred to be
tensor(x.shape) and tensor( [ nth(0,x.shape)
]), respectively. In this case, the type of x1 is simply
inferred to be tensor without any information about its shape, and the inferred type for model is
as follows. The best-eï¬€ort inference of GraTen fails to capture the constraint nth(0,ğœˆ.shape)
= 10
for ğ‘¥ due to the imprecise type information of x1.

ğ‘ 

ğ‘ 

ğ‘ :int â†’ ğ‘¥:{ğœˆ : tensor | len(ğœˆ .shape) = 1} â†’ tensor( [1])

Along with the inferred types, GraTen outputs the program in Figure 3, which is the same as the
original program except for an assertion inserted at the argument of g. Since the statically inferred
type of x1 does not guarantee that the application of g to x1 does not fail, GraTen inserts an
assertion into the program to check the requirement dynamically.

4

Hattori et al.

1.2.3 Gradual Typing. The third feature of our approach is that it incorporates gradual typing [24]
so that the users can improve the precision of the best-eï¬€ort type inference by adding type anno-
tations.

For example, Figure 4 shows the program from Figure 2 with a type annotation to x1. With
this annotation, GraTen infers the same type for model as it did to the model in Figure 1, and
no assertions are inserted to the program produced by GraTen. As such, adding correct type
annotations improves the type checking and decreases the number of assertions inserted.

Thanks to the best-eï¬€ort inference, users should not have to add type annotations to everywhere
in the program but can focus on the program points where the static inference did not perform
well, which is usually indicated by the insertion of assertions.

We have proved that our type system satisï¬es the gradual guarantee [24], which ensures that
adding type annotation preserves the type-ability and the behavior of the program (with some
assertions inserted) regardless of its precision, as long as the annotation does not disagree with
the program.

Among the three features, the notion of hybrid type checking was ï¬rst proposed by Knowles
and Flanagan [14], and our gradual typing is closely related to gradual reï¬nement types by [16],
but we believe that the particular combination of three features is new. In particular, unlike the
original gradual reï¬nement types [16], we insert assertions instead of carrying around evidence
terms [11] in the reduction to guarantee type safety.

The contribution and the structure of this paper is as follows.

â€¢ The formalization of a type system consisting of the three features above. We deï¬ne our type
system as the type-based transformation relation from source programs to programs with
runtime assertion checks. We prove the soundness of our type system as well (Section 2).
The shape-polymorphic extension of the type system is also brieï¬‚y discussed (Section 3).

â€¢ A proof that our system satisï¬es the gradual guarantee [24] (Section 4).
â€¢ Implementation of a prototype system GraTen based on the formalization (Section 5).
â€¢ Experimental evaluation of GraTen using the examples of deep learning programs bundled
in the OCaml-Torch library. We conï¬rm that GraTen can statically type-check the programs
eï¬€ectively with a reasonable amount of type annotations (Section 6).

2 A GRADUALLY-TYPED LANGUAGE WITH TENSORS

In this section, we formalize our type system and the translation to insert assertions. We ï¬rst
introduce the source and the target language of the translation in Subsections 2.1 and 2.2. We then
formalize the type system and the translation and prove their soundness in Subsection 2.3. The
gradual guarantee properties will be discussed later in Section 4.

2.1 Source Language
The syntax of the source language and types is presented in Figure 5. Throughout this paper, ğ‘›, ğ‘, ğ‘¥
respectively denote integers, constants (including integers and primitive functions) and variables.
The language we consider is a basic ML-style functional language with integer lists, which is
used to express tensor shapes. Lists are restricted to those that only contain integer elements for
simplicity. The empty list [ ] and cons function are both included in the constant ğ‘.

Type annotations can be added to the function arguments ğœ†ğ‘¥:ğœ .ğ‘€, recursive functions fix(ğ‘“ :(ğ‘¥:ğœ1 â†’

ğœ2), ğ‘¥, ğ‘€) and to arbitrary expressions by (ğ‘€ : ğœ). In the actual implementation of GraTen, users
may omit the type annotations in lambda expressions and recursive functions as they are inferred
in the best-eï¬€ort type inference.

Gradual Tensor Shape Checking

5

ğ‘€ (term) ::= ğ‘ | ğ‘¥ | ğœ†ğ‘¥:ğœ .ğ‘€ | ğ‘€ ğ‘¥ | (ğ‘€ : ğœ) | let ğ‘¥ = ğ‘€1 in ğ‘€2
fix(ğ‘“ :(ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥, ğ‘€) | if ğ‘¥ then ğ‘€1 else ğ‘€2

|

ğœ (type) ::= {ğ‘¥ : ğµ | ğœ‘} | ğ‘¥:ğœ1 â†’ ğœ2

ğµ (base type) ::= bool | int | int list | tensor
ğœ‘ (predicate) ::= true | false | ğ‘ 1 = ğ‘ 2 | ğ‘†1 = ğ‘†2 | ğ‘¥ | Â¬ğœ‘ | ğœ‘1 âˆ§ ğœ‘2 | ğœ‘1 âˆ¨ ğœ‘2

|

broadcastable(ğ‘†1, ğ‘†2) | reshapeable(ğ‘†1, ğ‘†2) | Â· Â· Â·

ğ‘† (shape) ::= [ğ‘ 1; . . . ; ğ‘ ğ‘›] | ğ‘¥ | ğ‘¥ .shape | append(ğ‘†1, ğ‘†2) | Â· Â· Â·

ğ‘  (size) ::= ğ‘› | ğ‘¥ | len(ğ‘†) | nth(ğ‘ , ğ‘†) | âˆ’ğ‘  | ğ‘ 1 + ğ‘ 2 | ğ‘ 1 Ã— ğ‘ 2 |

ğ‘ 1
ğ‘ 2

| Â· Â· Â·

ğ‘¡ ::= ğœ‘ | ğ‘† | ğ‘ 

Î“ (type env.) ::= âˆ… | Î“, ğ‘¥ : ğœ
Î” (base type env.) ::= âˆ… | Î”, ğ‘¥ : ğµ

Fig. 5. Syntax of the source language, the types and the type enviornments.

Î” âŠ¢wf ğœ
Î”, ğ‘¥ : ğµ âŠ¢wf ğœ‘ : bool
Î” âŠ¢wf {ğ‘¥ : ğµ | ğœ‘}

Î”, BT(ğ‘¥ : ğœ1) âŠ¢wf ğœ2
Î” âŠ¢wf ğ‘¥:ğœ1 â†’ ğœ2

BT(Î“)

BT(âˆ…) = âˆ…

BT(Î“, ğ‘¥ : {ğ‘¥ : ğµ | ğœ‘}) = BT(Î“), ğ‘¥ : ğµ
BT(Î“, ğ‘¥ : (ğ‘¦:ğœ1 â†’ ğœ2)) = BT(Î“)

Î” âŠ¢BT ğ‘¡ : ğµ

Î” âŠ¢BT ğ‘¥ : Î”(ğ‘¥)

Î”(ğ‘¥) = tensor
Î” âŠ¢BT ğ‘¥ .shape : int list

Î” âŠ¢BT ğ‘  : int

Î” âŠ¢BT ğ‘† : int list

Î” âŠ¢BT nth(ğ‘ , ğ‘†) : int

Fig. 6. Selected rules of well-formedness condition of types (full definition in the appendix Figure 18).

The argument of a function application and the branching condition of an if-expression are
restricted to variables for the sake of simplicity of typing rules. Note that this restriction does not
lose generality, as a general function application ğ‘€1 ğ‘€2 can be normalized to let ğ‘“ = ğ‘€1 in let ğ‘¥ =
ğ‘€2 in ğ‘“ ğ‘¥.

Types are deï¬ned following the standard deï¬nition of reï¬nement types. Intuitively, the type
{ğ‘¥ : ğµ | ğœ‘} describes a value ğ‘¥ of type ğµ such that ğœ‘ holds. For example, {ğ‘¥ : tensor | dim(ğ‘¥) = 2}
is the type of 2-dimenstional tensors. We may omit the reï¬nement predicates when they are true.
For example, we may write {ğ‘¥ : int | true} as int.

The reï¬nement predicates, shapes and sizes are expressions of type bool, int list and int re-
spectively. As shown in the deï¬nition, they may use some built-in functions such as broadcastable
and append in order to express common tensor operations.

Figure 6 deï¬nes the well-formedness of types. A base type environment Î” is a mapping from
variables to base types, as deï¬ned in Figure 5. The function BT(Â·) converts a type environment to
a base type environment. The typing relation for predicates, shapes and sizes Î” âŠ¢BT ğ‘¡ : ğµ is a part
of the well-formedness of types Î” âŠ¢wf ğœ.

6

Hattori et al.

ğ‘£ (value) ::= ğ‘ | ğ‘¥ | [ğ‘£1, . . . , ğ‘£ğ‘›] | ğœ†ğ‘¥ğœ .ğ‘ | fix(ğ‘“ ğœ, ğ‘¥, ğ‘ )

ğ‘ (cast term) ::= ğ‘£ | if ğ‘£ then ğ‘1 else ğ‘2 | ğ‘ ğ‘£ | let ğ‘¥ğœ = ğ‘1 in ğ‘2 | assert(ğœ‘); ğ‘

Fig. 7. Syntax of the target language.

[ğ‘£/ğ‘¥]ğ‘

[ğ‘£/ğ‘¥] (assert(ğœ‘); ğ‘ ) = assert( [ğ‘£/ğ‘¥]ğœ‘); [ğ‘£/ğ‘¥]ğ‘
[ğ‘£/ğ‘¥] (ğœ†ğ‘¦ğœ .ğ‘ ) = ğœ†ğ‘¦ [ğ‘£/ğ‘¥ ]ğœ .[ğ‘£/ğ‘¥]ğ‘
[ğ‘£/ğ‘¥] (fix(ğ‘“ ğœ, ğ‘¦, ğ‘ )) = fix(ğ‘“ [ğ‘£/ğ‘¥ ]ğœ, ğ‘¦, [ğ‘£/ğ‘¥]ğ‘ )

[ğ‘£/ğ‘¥] (let ğ‘¦ğœ = ğ‘1 in ğ‘2) = (let ğ‘¦ [ğ‘£/ğ‘¥ ]ğœ = [ğ‘£/ğ‘¥]ğ‘1 in [ğ‘£/ğ‘¥]ğ‘2)
(Variables are assumed to be alpha-renamed so that variables at
diï¬€erent scopes do not collide)

ğ‘1 âˆ’â†’ ğ‘2

assert(true); ğ‘ âˆ’â†’ ğ‘
assert(false); ğ‘ âˆ’â†’ error

(ğœ†ğ‘¥ğœ .ğ‘1) ğ‘£ âˆ’â†’ [ğ‘£/ğ‘¥]ğ‘1
ğ‘ ğ‘£ âˆ’â†’ ev(ğ‘, ğ‘£)
let ğ‘¥ğœ = ğ‘£ in ğ‘ âˆ’â†’ [ğ‘£/ğ‘¥]ğ‘

Fig. 8. Selected rules of substitution and reduction of the target language (full definition in the appendix
Figure 19 and Figure 20).

2.2 Target Language

As explained already (in Section 1), since our type checker inference/checking procedure is incom-
plete, run-time checks are inserted into places where type-safety cannot be statically guaranteed.
Figure 7 shows the syntax of programs obtained by the insertion of assertions. The syntax of the
target language is similar to that of the source language with some diï¬€erences. One of them is the
addition of assertion assert(ğœ‘); ğ‘ , which is used to implement the dynamic check. Like Flanaganâ€™s
hybrid type system [14] (and unlike the blame calculus [27]), we guarantee the safety of target
programs by assertions of the form assert(ğœ‘); ğ‘ , which checks that ğœ‘ holds and then proceeds to
evaluate ğ‘ ; if ğœ‘ does not hold, the program is aborted and a run-time type error is reported. This
method is expected to be easier to implement since most of the modern programming languages
are equipped with assertions, and more eï¬ƒcient than the blame calculus in that it avoids the accu-
mulation of dynamic casts at runtime. This implementation of the dynamic cast is possible since
our system is only â€œgradualizedâ€ at the predicate level of the reï¬nement type and the underlying
simple type is static.

Another diï¬€erence is that the binders in let expressions are annotated with their type. This is

required when deï¬ning the precision relation over the cast terms in Section 4.

The substitution and the reduction rules of the cast terms are presented in Figure 8. The eval-
uation of primitive function ev(ğ‘, ğ‘£) is deï¬ned to be the return value of the primitive function ğ‘
applied to an argument ğ‘£ if ğ‘£ meets the constraint of the argument of ğ‘, and otherwise undeï¬ned.
We denote ğ‘ â‡‘ if there exists an inï¬nite reduction sequence from ğ‘ .

The substitution for cast terms is deï¬ned in the standard manner, except that the implicitly-
annotated type information and the predicate in the assertion need to be updated as well. As
can be seen in the deï¬nition of the cast term reduction, these implicitly-annotated types are only
required for the sake of formalization and ignored at runtime.

We also introduce the type derivation rules for the cast terms Î“; ğœ‘ âŠ¢ ğ‘ : ğœ in Figure 9. This
relation is used in the discussion of the soundness of the type system later in Subsubsection 2.3.2.
The 4-ary relation Î“; ğœ‘ âŠ¢ ğ‘ : ğœ denotes that a cast term ğ‘ has type ğœ under a type environment

Gradual Tensor Shape Checking

7

Î“; ğœ‘ âŠ¢ ğ‘ : ğœ

Î“; ğœ‘ âŠ¢ ğ‘ : ty(ğ‘) (CT-Const)

Î“(ğ‘¥) = ğ‘¦:ğœ1 â†’ ğœ2
Î“; ğœ‘ âŠ¢ ğ‘¥ : Î“(ğ‘¥)

Î“(ğ‘¥) = {ğ‘¦ : ğµ | ğœ‘ â€²}
Î“; ğœ‘ âŠ¢ ğ‘¥ : {ğ‘¦ : ğµ | ğ‘¦ = ğ‘¥ }

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘ : ğœ2
Î“; ğœ‘ âŠ¢ ğœ†ğ‘¥ğœ1 .ğ‘ : ğ‘¥:ğœ1 â†’ ğœ2

(CT-Lam)

(CT-Var-Fun)
Î“; ğœ‘ âŠ¢ ğ‘ : ğ‘¥:ğœ1 â†’ ğœ2

(CT-Var-Base)

Î“; ğœ‘ âŠ¢ ğ‘£ : ğœ1

(CT-App)

Î“; ğœ‘ âŠ¢ ğ‘ ğ‘£ : [ğ‘£/ğ‘¥]ğœ2

Î“, ğ‘“ : (ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘ : ğœ2
Î“; ğœ‘ âŠ¢ fix(ğ‘“ ğ‘¥:ğœ1â†’ğœ2, ğ‘¥, ğ‘ ) : ğ‘¥:ğœ1 â†’ ğœ2

(CT-Fix)

Î“; ğœ‘ âˆ§ ğœ‘ â€² âŠ¢ ğ‘ : ğœ
Î“; ğœ‘ âŠ¢ assert(ğœ‘ â€²); ğ‘ : ğœ

(CT-Assert)

Î“; ğœ‘ âŠ¢ ğ‘£ : {ğ‘¥ : bool | ğœ‘ â€²}

Î“; ğœ‘ âˆ§ ğ‘£ âŠ¢ ğ‘1 : ğœ

Î“; ğœ‘ âˆ§ Â¬ğ‘£ âŠ¢ ğ‘2 : ğœ

Î“; ğœ‘ âŠ¢ if ğ‘£ then ğ‘1 else ğ‘2 : ğœ

(CT-If)

Î“; ğœ‘ âŠ¢ ğ‘1 : ğœ2

Î“, ğ‘¥ : ğœ2; ğœ‘ âŠ¢ ğ‘2 : ğœ

Î“; ğœ‘ âŠ¢ ğ‘ : ğœ â€²

Î“; ğœ‘ âŠ¢ ğœ â€² <: ğœ

Î“; ğœ‘ âŠ¢ let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 : ğœ

Î“; ğœ‘ âŠ¢ ğ‘ : ğœ

(CT-Sub)

(CT-Let)

Fig. 9. Typing rules for the cast terms.

Î¦(Î“)

Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2

Î¦(âˆ…) = true

Î¦(Î“, ğ‘¥ : {ğ‘¦ : ğµ | ğœ‘}) = Î¦(Î“) âˆ§ [ğ‘¥/ğ‘¦]ğœ‘
Î¦(Î“, ğ‘¥ : (ğ‘¦:ğœ1 â†’ ğœ2)) = Î¦(Î“)

(cid:15) âˆ€BT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 â‡’ ğœ‘2
Î“; ğœ‘ âŠ¢ {ğ‘¥ : ğµ | ğœ‘1} <: {ğ‘¥ : ğµ | ğœ‘2}

(Sub-Base)

Î“; ğœ‘ âŠ¢ ğœ3 <: ğœ1

Î“, ğ‘¥ : ğœ3; ğœ‘ âŠ¢ ğœ2 <: ğœ4

Î“; ğœ‘ âŠ¢ ğ‘¥:ğœ1 â†’ ğœ2 <: ğ‘¥:ğœ3 â†’ ğœ4

(Sub-Fun)

Fig. 10. Subtyping rules.

Î“ and a logical context ğœ‘. The logical context ğœ‘, sharing its syntax with the reï¬nement predicate,
holds the information of logically valid predicates at respective program points. New predicates
are added at the then branch and the else branch of (CT-If), and the post-assertion cast term in
(CT-Assert). The subsumption is allowed in (CT-Sub) by the subtyping relation Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2
(Figure 10), which is deï¬ned in a standard manner.

2.3 Typing Rules

2.3.1 Assertion Insertion to Source Program. Next, we discuss the typing rules for the source lan-
guage and the assertion insertion to it. Figure 11 deï¬nes the type judgement and cast insertion
relation. The 5-ary relation Î“; ğœ‘ âŠ¢ ğ‘€ { ğ‘ : ğœ intuitively reads: under a type environment Î“ and a
logical context ğœ‘, a term ğ‘€ translates to a cast term ğ‘ and has type ğœ. If we ignore the part â€œ{ ğ‘ â€
and replace the gradual subtyping relation . with the standard subtyping relation on reï¬nement
types (Figure 10), then our type system is a standard reï¬nement type system. Thus, the main nov-
elty in the rules in Figure 11 lies in the use of the consistent subtyping relation Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ ,
which is explained below.

8

Î“; ğœ‘ âŠ¢ ğ‘€ { ğ‘ : ğœ

Î“; ğœ‘ âŠ¢ ğ‘ { ğ‘ : ty(ğ‘)

(CI-Const)

Î“(ğ‘¥) = {ğ‘¦ : ğµ | ğœ‘ â€²}
Î“; ğœ‘ âŠ¢ ğ‘¥ { ğ‘¥ : {ğ‘¦ : ğµ | ğ‘¦ = ğ‘¥ }

(CI-Var-Base)

Hattori et al.

Î“(ğ‘¥) = ğ‘¦:ğœ1 â†’ ğœ2
Î“; ğœ‘ âŠ¢ ğ‘¥ { ğ‘¥ : Î“(ğ‘¥)
Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘€ { ğ‘ : ğœ2
Î“; ğœ‘ âŠ¢ ğœ†ğ‘¥:ğœ1.ğ‘€ { ğœ†ğ‘¥ğœ1 .ğ‘ : ğ‘¥:ğœ1 â†’ ğœ2

(CI-Var-Fun)

(CI-Lam)

Î“; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğ‘¦:ğœ1 â†’ ğœ2

Î“(ğ‘¥) = ğœ3

Î“; ğœ‘ âŠ¢ ğœ3 . ğœ1 { ğ‘2

Î“; ğœ‘ âŠ¢ ğ‘€1 ğ‘¥ { (let ğ‘¥ğœ1 = ğ‘2 ğ‘¥ in ğ‘1 ğ‘¥) : [ğ‘¥/ğ‘¦]ğœ2

Î“â€² = Î“, ğ‘“ : (ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥ : ğœ1

Î“â€²; ğœ‘ âŠ¢ ğ‘€ { ğ‘1 : ğœ3

Î“â€²; ğœ‘ âŠ¢ ğœ3 . ğœ2 { ğ‘2

Î“; ğœ‘ âŠ¢ fix(ğ‘“ :(ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥, ğ‘€) { fix(ğ‘“ ğ‘¥:ğœ1â†’ğœ2, ğ‘¥, let ğ‘¦ğœ3 = ğ‘1 in ğ‘2 ğ‘¦) : ğ‘¥:ğœ1 â†’ ğœ2

Î“; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğœ1

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘€2 { ğ‘2 : ğœ2

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğœ2 . ğœ { ğ‘3

BT(Î“) âŠ¢wf ğœ

Î“; ğœ‘ âŠ¢ (let ğ‘¥ = ğ‘€1 in ğ‘€2) { (let ğ‘¥ğœ1 = ğ‘1 in let ğ‘¦ğœ2 = ğ‘2 in ğ‘3 ğ‘¦) : ğœ

(CI-App)

(CI-Fix)

(CI-Let)

Î“; ğœ‘ âŠ¢ ğ‘¥ : {ğ‘¥ : bool | ğœ‘ â€²}

Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğ‘€1 { ğ‘1 : ğœ1

Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğœ1 . ğœ { ğ‘3

Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğ‘€2 { ğ‘2 : ğœ2

Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğœ2 . ğœ { ğ‘4

(CI-If)

(CI-Annot)

Î“; ğœ‘ âŠ¢ if ğ‘¥ then ğ‘€1 else ğ‘€2
{ if ğ‘¥ then (let ğ‘¦ğœ1 = ğ‘1 in ğ‘3 ğ‘¦) else (let ğ‘¦ğœ2 = ğ‘2 in ğ‘4 ğ‘¦) : ğœ

Î“; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğœ1
Î“; ğœ‘ âŠ¢ ğœ1 . ğœ { ğ‘2
Î“; ğœ‘ âŠ¢ (ğ‘€1 : ğœ) { (let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 ğ‘¥) : ğœ

Fig. 11. Type derivation rules for the source language.

{ğ‘¥ : ğµ | ğœ‘1} âŠ“ {ğ‘¥ : ğµ | ğœ‘2} = {ğ‘¥ : ğµ | ğœ‘1 âˆ§ ğœ‘2}
(ğ‘¥:ğœ1 â†’ ğœ2) âŠ“ (ğ‘¥:ğœ3 â†’ ğœ4) = ğ‘¥:(ğœ1 âŠ“ ğœ3) â†’ (ğœ2 âŠ“ ğœ4)

ğœ1 âŠ“ ğœ2

Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘

(cid:15) âˆƒBT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 âˆ§ ğœ‘2

(cid:15) âˆ€BT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 â‡’ (ğœ‘ â€² â‡” ğœ‘2)

Î“; ğœ‘ âŠ¢ {ğ‘¥ : ğµ | ğœ‘1} . {ğ‘¥ : ğµ | ğœ‘2} { ğœ†ğ‘¥ {ğ‘¥:ğµ |ğœ‘1 }.assert(ğœ‘ â€²); ğ‘¥

(Cast-Base)

Î“; ğœ‘ âŠ¢ ğœ3 . ğœ1 { ğ‘1

Î“, ğ‘¥ : ğœ1 âŠ“ ğœ3; ğœ‘ âŠ¢ ğœ2 . ğœ4 { ğ‘2

Î“; ğœ‘ âŠ¢ ğ‘¥:ğœ1 â†’ ğœ2 . ğ‘¥:ğœ3 â†’ ğœ4 { ğœ†ğ‘“ ğ‘¥:ğœ1â†’ğœ2 .ğœ†ğ‘¥ğœ3 .(let ğ‘¦ğœ1âŠ“ğœ3 = ğ‘1 ğ‘¥ in let ğ‘§ğœ2 = ğ‘“ ğ‘¦ in ğ‘2 ğ‘§)

(Cast-Fun)

Fig. 12. Definition of the consistent subtyping relation Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ .

Gradual Tensor Shape Checking

9

The consistent subtyping relation Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ (Figure 12) is used in the cast insertion
relation to guarantee that there exists a value that has both of the types ğœ1 and ğœ2 under Î“ and ğœ‘,
and to produce an assertion term ğ‘ that checks at runtime if a value that is statically known to be
of type ğœ1 can be used as a value of type ğœ2.

The rule for the base case (Cast-Base) checks if there exists a value, and an assignment of the
values to the variables in the type environment, that satisï¬es both ğœ1 and ğœ2. This intuitively holds
if ğœ1 is castable to ğœ2 for some runtime values.

The rule (Cast-Base) also produces a lambda function that implements the cast with an as-
sertion. The content of the assertion ğœ‘ â€² must be at least the â€œdiï¬€erenceâ€ of ğœ‘1 and ğœ‘2. For ex-
ample, consider the case when ğœ1 is a tensor type whose dimension is known to be 1, namely
{ğ‘¥ : tensor | len(ğ‘¥ .shape) = 1}, and ğœ2 is a tensor type whose shape is known to be [3], namely
{ğ‘¥ : tensor | ğ‘¥ .shape = [3]}. The assertion generated from casting ğœ1 to ğœ2 is as follows. Note
how the assertion does not need to check if ğ‘¥ has at least one dimension because it is guaranteed
by ğœ1. 3

âˆ…; true âŠ¢ {ğ‘¥ : tensor | len(ğ‘¥ .shape) = 1} . {ğ‘¥ : tensor | ğ‘¥ .shape = [3]}
{ ğœ†ğ‘¥ {ğ‘¥:tensor |len(ğ‘¥ .shape)=1}.assert(nth(0, ğ‘¥ .shape) = 3); ğ‘¥
The rule for the function types (Cast-Fun) recursively checks the castability of the argument
types and the return types and combines the assertion terms for them. Notice how the subsumption
for the return types ğœ2 and ğœ4 has the meet of two argument types ğœ1 âŠ“ ğœ3 in the type environment.
The meet of two types (Figure 12) is deï¬ned as a conjunction of the reï¬nement predicates4.

The consistent subtyping relation can be seen as a gradualization of the subtyping relation
Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2 (Figure 10). In fact, when a type ğœ1 is a subtype of another type ğœ2, it is possible
that the assertion term generated by casting ğœ1 to ğœ2 only contains assertions that always succeed,
which can be erased by some optimization. The following proposition states this fact. Note that
this corresponds to the blame-subtyping theorem, one of the criteria for gradual typing presented
in [24].

Proposition 1. Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2 implies Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ for some ğ‘ where all the assertions in

ğ‘ are of the form assert(true); ğ‘ â€².

2.3.2 Type Safety. We conclude this section with a note on the soundness of our type system.
The soundness is based on the fact that if the source program is well-typed, the program after the
assertion insertion is also well-typed.

The most critical part of the proof is to prove the assertion term can be assigned a function type

from the pre-assertion type to the post-assertion type.

Lemma 1. Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ implies Î“; ğœ‘ âŠ¢ ğ‘ : ğ‘¥:ğœ1 â†’ ğœ2 for some variable ğ‘¥ that does not

occur in ğœ2.

This is an immediate result of Lemma 6 in the appendix. With Lemma 1, we can prove that the

assertion-inserted program can be assigned the same type as that of the original program.

Lemma 2 (Assertion Insertion Preserves Types). Î“; ğœ‘ âŠ¢ ğ‘€ { ğ‘ : ğœ implies Î“; ğœ‘ âŠ¢ ğ‘ : ğœ.

We can also prove the standard progress and preservation properties under a reasonable assump-
tion that the types of the primitive functions are properly deï¬ned as follows (see the appendix for
the proofs).

3We assume that the function nth(ğ‘›, ğ‘†) returns the ğ‘›-th element of the list ğ‘†, and the index is 0-indexed.
4Although the meet of two function types is deï¬ned, it does not make any diï¬€erence in the deï¬nition of consistent sub-
typing relation since function types in the type environment is not used.

10

Hattori et al.

Assumption 1. âŠ¢ ğ‘ ğ‘£ : ğœ implies ev (ğ‘, ğ‘£) is deï¬ned and âŠ¢ ev (ğ‘, ğ‘£) : ğœ

Combining Lemma 2 with the progress and preservation properties, we obtain the type safety

as follows.

Theorem 1 (Type Safety). With Assumption 1, âˆ…; true âŠ¢ ğ‘€ { ğ‘ : ğœ implies ğ‘ âˆ’â†’âˆ— ğ‘£ for some

ğ‘£, ğ‘ â‡‘, or ğ‘ âˆ’â†’âˆ— error.

The type safety property states that a well-typed program does not cause untrapped dynamic
errors. The only case where a cast-inserted program causes untrapped errors is when the result
of an application of a primitive function is undeï¬ned (i.e., ev (ğ‘, ğ‘£) is undeï¬ned). The type safety
property ensures that such untrapped errors do not happen for well-typed terms as long as the
ty(ğ‘) is deï¬ned appropriately.

Remark 1. In our system, we used reï¬nement types to express tensor shapes. An alternative design
would be to express the type of a tensor with shape ğ‘† as tensor(ğ‘†) (instead of {ğ‘¥ : tensor | ğ‘¥ .shape =
ğ‘† }) and incorporate shape polymorphism and dynamic shapes/sizes. In such a system, the type of ReLU
function would be âˆ€ğ‘†.tensor(ğ‘†) â†’ tensor(ğ‘†) and the type of a 1-dimensional tensor with statically
unknown length would be tensor( [â˜…]), where â˜… denotes the unknown size. Although this approach
may look simpler, it introduces an unnecessary complication.

Consider a function of type âˆ€ğ‘, ğ‘.tensor( [ğ‘ Ã— ğ‘]) â†’ tensor( [ğ‘ + ğ‘]), and applying it to a 1-
dimensional tensor with statically unknown length tensor( [â˜…]). The polymorphic shape parameters
ğ‘ and ğ‘ would both need to be instantiated with â˜…, since no other option would be more appropriate.
Then, we would need to consider a dynamic cast from tensor( [â˜…]) to tensor( [â˜…Ã—â˜…]), which would
require an existential quantiï¬er in the assertion.

Since we observed through the experiments that the types of most of the realistic tensor functions can
be expressed using our reï¬nement types, we did not choose this alternative design. Some exceptional
cases we have noticed are discussed in the next section.

3 EXTENSION WITH POLYMORPHISM
Using the reï¬nement types, we can express the types of most of the shape polymorphic ten-
sor functions. For example, ReLU is a function that takes a tensor and returns a tensor of the
same shape as the input. In a type system with shape polymorphism, the type of such function
is expressed as âˆ€ğ‘†:int list. tensor(ğ‘†) â†’ tensor(ğ‘†), whereas in our system, it is expressed as
ğ‘¥:tensor â†’ tensor(ğ‘¥ .shape).

There is, however, shape polymorphism that cannot be expressed in this style. Consider the

type:

âˆ€ğ‘†1, ğ‘†2. (tensor(ğ‘†1) â†’ tensor(ğ‘†2)) â†’ tensor(ğ‘†1) â†’ tensor(ğ‘†2)

The application function ğœ†ğ‘“ .ğœ†ğ‘¥ .ğ‘“ ğ‘¥, for example, has this type. In our system presented so far, there
is no way to present the equivalent of this type.

We therefore discuss an extension of our type system with explicit polymorphism on sizes and
shapes. We introduce type schemes and redeï¬ne type environments to map from variables to type
schemes.

ğ‘‡ (type scheme) ::= âˆ€ğ‘¥1:ğµ1, . . . , ğ‘¥ğ‘›:ğµğ‘›.ğœ

Î“ (type environment) ::= âˆ… | Î“ [ğ‘¥ â†¦â†’ ğ‘‡ ]

We deï¬ne the new typing relation as a transformation relation Î“; Î”; ğœ‘ âŠ¢ ğ‘€ : ğœ =â‡’ ğ‘€ â€² which
associates a polymorphically-typed program ğ‘€ with a monomorphically-typed program ğ‘€ â€²:

Gradual Tensor Shape Checking

Î“(ğ‘“ ) = âˆ€ğ‘¥1:ğµ1, . . . , ğ‘¥ğ‘›:ğµğ‘›.ğœ

BT(Î“), Î” âŠ¢BT ğ‘¡ğ‘– : ğµğ‘– for each ğ‘–

Î“; Î”; ğœ‘ âŠ¢ ğ‘“ : [ğ‘¡1/ğ‘¥1, . . . , ğ‘¡ğ‘›/ğ‘¥ğ‘›]ğœ =â‡’ ğ‘“ ğ‘¡1 Â· Â· Â· ğ‘¡ğ‘›

Î“; (Î”, ğ‘¥1 : ğµ1, . . . , ğ‘¥ğ‘› : ğµğ‘›); ğœ‘ âŠ¢ ğ‘€1 : ğœ1 =â‡’ ğ‘€ â€²
1

ğ‘¥1, . . . , ğ‘¥ğ‘› do not occur in ğ‘

(Î“, ğ‘“ : âˆ€ğ‘¥1:ğµ1, . . . , ğ‘¥ğ‘›:ğµğ‘›.ğœ1); Î”; ğœ‘ âŠ¢ ğ‘€2 : ğœ2 =â‡’ ğ‘€ â€²
2

Î“; Î”; ğœ‘ âŠ¢ (let ğ‘“ = ğ‘€1 in ğ‘€2) : ğœ â€² =â‡’ (let ğ‘“ = ğœ†ğ‘¥1:ğµ1. Â· Â· Â· ğœ†ğ‘¥ğ‘›:ğµğ‘›.ğ‘€ â€²

1 in ğ‘€ â€²
2)

11

(PT-Var)

(PT-Let)

Here, Î” is a type environment for polymorphic shape variables.

Thus, a type scheme âˆ€ğ‘¥1:ğµ1, . . . , ğ‘¥ğ‘›:ğµğ‘›.ğœ is mapped to a monomorphic (reï¬nement) type ğ‘¥1:ğµ1 â†’
Â· Â· Â· â†’ ğ‘¥ğ‘›:ğµğ‘› â†’ ğœ. The term obtained by type inference is thus just a monomorphically-typed term,
to which the theory of gradual tensor types developed in the previous subsections apply.

There is, however, a subtle conï¬‚ict in the best-eï¬€ort inference of type schemes and the coercion
mechanism of gradual typing. In the rule (PT-Let), we need to infer appropriate ğ‘¡1, . . . , ğ‘¡ğ‘› and
choosing wrong ğ‘¡1, . . . , ğ‘¡ğ‘› may cause cast failures, even if the original program is safe. For example,
consider the following program:
let app f x = f x in
let g = ... (* complex function on tensors *) in

... app g ...

Then, the function app can be assigned the following type scheme.

âˆ€ğ‘†1, ğ‘†2 : int list. (tensor(ğ‘†1) â†’ tensor(ğ‘†2)) â†’ tensor(ğ‘†1) â†’ tensor(ğ‘†2)

Type inference then tries to convert the caller app g ğ‘¥ to a term of the form app ğ‘¡1 ğ‘¡2 g ğ‘¥. However,
if g is a complex function for which the precise inference of shapes is diï¬ƒcult, then we will fail to
infer appropriate parameters ğ‘¡1, ğ‘¡2. In that case, we need to fall back to the safe side, and assign to
app a less precise monomorphic type:

(tensor â†’ tensor) â†’ tensor â†’ tensor.

The caller app g is then just transformed to app g ğ‘¥.

The solution above (of falling back to monomorphic typing when type inference for callers fail)

still has the following problems.

(1) In the example above, other callers of app will also be monomorphically typed, which leads

to imprecise type inference. For example, suppose h is statically known to have type tensor( [2; 3]) â†’
tensor( [1]). Based on the type scheme, we could infer the type of app h to be tensor( [2; 3]) â†’
tensor( [1]), but due to the presence of the caller app g, the imprecise type tensor â†’
tensor is inferred also for app h.

(2) It is against the principle of modular type inference that whether a polymorphic type is

assigned to app depends on callers.

A remedy to the problems above is to prepare both polymorphic and monomorphic versions for
each polymorphic function. In the example above, thus app is transformed to two functions:
let app_poly s1 s2 f x = ...
let app_mono f x = ...

where:

app_poly : âˆ€ğ‘†1, ğ‘†2. (tensor(ğ‘†1) â†’ tensor(ğ‘†2)) â†’ tensor(ğ‘†1) â†’ tensor(ğ‘†2)
app_mono : (tensor â†’ tensor) â†’ tensor â†’ tensor

Then we can transform app g and app h to app_mono g and app_poly [2; 3] [1] h.

12

ğ‘¥ âŠ¢ ğœ1 âŠ‘ ğœ2

e

(cid:15) âˆ€

ğ‘¦, ğ‘¥ .ğœ‘1 â‡’ ğœ‘2

ğ‘¦ âŠ¢ {ğ‘¥ : ğµ | ğœ‘1} âŠ‘ {ğ‘¥ : ğµ | ğœ‘2}

(Prec-Base)

Hattori et al.

ğ‘¦, ğ‘¥ âŠ¢ ğœ2 âŠ‘ ğœ4
ğ‘¦ âŠ¢ ğœ1 âŠ‘ ğœ3
ğ‘¦ âŠ¢ ğ‘¥:ğœ1 â†’ ğœ2 âŠ‘ ğ‘¥:ğœ3 â†’ ğœ4
e

e

(Prec-Fun)

Î“1 âŠ‘ Î“2
e

e

âˆ… âŠ‘ âˆ…

Î“1 âŠ‘ Î“2

e

dom(Î“1) âŠ¢ ğœ1 âŠ‘ ğœ2

Î“1, ğ‘¥ : ğœ1 âŠ‘ Î“2, ğ‘¥ : ğœ2

Fig. 13. Precision relation of types and type environments.

Remark 2. The polymorphic extension we have discussed here may still not be suitable for the

inference of some programs. For example, let ğ‘“ be a function of the following type:

ğ‘“ : {ğ‘¥ : tensor | prod ğ‘¥ .shape = 128} â†’ tensor

and consider applying ğ‘“ to the above-mentioned app. Since it is impossible to infer the shape of the
argument or the return value of ğ‘“ , the type of app falls back to that of app_mono. The type of app ğ‘“
is thus inferred to be tensor â†’ tensor, although we know that app ğ‘“ can be assigned the same type
as ğ‘“ .

Function Layer.forward of OCaml-Torch is one of the most frequently used primitive function, and
it has similar types as app. We noticed that not being able to infer the same type as ğ‘“ for app ğ‘“ in the
above case critically degrades the precision of inference. Therefore, in the prototype implementation,
we specially assign the following reï¬nement-polymorphic type to Layer.forward:

âˆ€ğ‘1:bool, ğ‘2:bool.
(ğ‘¥:{ğ‘¥:tensor | ğ‘1} â†’ {ğ‘¦:tensor | ğ‘2}) â†’ ğ‘¥:{ğ‘¥:tensor | ğ‘1} â†’ {ğ‘¦:tensor | ğ‘2}

where the parameters ğ‘1 and ğ‘2 are instantiated with temporary reï¬nement variables. We leave the
formal justiï¬cation of such reï¬nement-polymorphic types as future work.

4 GRADUAL GUARANTEE
In a standard gradual type system, programs are compared by their precision, or the amount of
information they contain in the type annotations. This notion is used to deï¬ne the gradual guar-
antee [24], which is the core property of gradual typing. The gradual guarantee comes in two
parts. The ï¬rst one is called static gradual guarantee, which states that decreasing the precision of
type annotation from a well-typed program still preserves the typeability of the program at a less
precise type. The second one is called dynamic gradual guarantee, which claims that a less precise
program behaves the same as the more precise one with fewer assertion errors.

In Subsection 4.1, we ï¬rst deï¬ne the precision for the language introduced in Section 2. We then

show in Subsection 4.2 that our type system satisï¬es the gradual guarantee.

4.1 Precision
ğ‘¥ âŠ¢ ğœ1 âŠ‘ ğœ2 on types by using the logical implication
Figure 13 deï¬nes the precision relation
ğ‘¥ keeps the variables that may ap-
between the reï¬nement predicates. The sequence of variables
pear in the reï¬nement predicates. For example, the following is an example of the type precision
relation for the base type.

e

e

âŠ¢ {ğ‘¥ : tensor | ğ‘¥ .shape = [3]} âŠ‘ {ğ‘¥ : tensor | len(ğ‘¥ .shape) = 1}

Gradual Tensor Shape Checking

13

ğ‘¥ âŠ¢ ğ‘€1 âŠ‘ ğ‘€2

e

ğ‘¦ âŠ¢ ğœ1 âŠ‘ ğœ2

ğ‘¦, ğ‘¥ âŠ¢ ğ‘€1 âŠ‘ ğ‘€2

ğ‘¦ âŠ¢ ğœ†ğ‘¥:ğœ1.ğ‘€1 âŠ‘ ğœ†ğ‘¥:ğœ2.ğ‘€2
e

e

(PM-Lam)

ğ‘¦ âŠ¢ ğ‘€1 âŠ‘ ğ‘€2

ğ‘¦ âŠ¢ ğœ1 âŠ‘ ğœ2

ğ‘¦ âŠ¢ (ğ‘€1 : ğœ1) âŠ‘ (ğ‘€2 : ğœ2)

(PM-Annot)

e

ğ‘¦ âŠ¢ ğ‘¥:ğœ1 â†’ ğœ2 âŠ‘ ğ‘¥:ğœ3 â†’ ğœ4

ğ‘¦ âŠ¢ fix(ğ‘“ : (ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥, ğ‘€) âŠ‘ fix(ğ‘“ : (ğ‘¥:ğœ3 â†’ ğœ4), ğ‘¥, ğ‘€ â€²)

e

e
ğ‘¦, ğ‘“ , ğ‘¥ âŠ¢ ğ‘€ âŠ‘ ğ‘€ â€²
e

(PM-Fix)

e

e

Fig. 14. Selected rules for the precision relation on terms (full definition in the appendix Figure 21).

e

Î“; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘2

dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ2

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘2

Î“ âŠ¢ ğ‘1 âŠ‘ ğ‘3

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘2 âŠ‘ ğ‘4

Î“; ğœ‘ âŠ¢ ğœ†ğ‘¥ğœ1 .ğ‘1 âŠ‘ ğœ†ğ‘¥ğœ2 .ğ‘2

(PC-Lam)

Î“; ğœ‘ âŠ¢ let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 âŠ‘ let ğ‘¥ğœ3 = ğ‘3 in ğ‘4
(PC-Let)

âˆ€BT(Î“).Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 â‡’ ğœ‘2

Î“; ğœ‘ âˆ§ ğœ‘1 âŠ¢ ğ‘1 âŠ‘ ğ‘2

Î“; ğœ‘ âŠ¢ assert(ğœ‘1); ğ‘1 âŠ‘ assert(ğœ‘2); ğ‘2

(PC-Assert)

Fig. 15. Selected rules for the precision relation on cast terms ((full definition in the appendix Figure 22).

Note that in the rule (Prec-Fun), the precision of the argument type and the return type are
compared independently; the type information on ğ‘¥ is not used in the comparison of the return
types. This is in contrast with the rule (Sub-Fun) in Figure 10 for subtyping.

Figure 13 also extends the relation to Î“ âŠ‘ Î“â€² on type environments.
The precision relation is also extended to the relation

ğ‘¥ âŠ¢ ğ‘€ âŠ‘ ğ‘€ â€² on terms, by the rules in

Figure 14. Here,

ğ‘¥ is the sequence of variables in scope.

Finally, we deï¬ne the precision relation of the cast terms in Figure 15. Unlike the term precision
relation (Figure 14), the precision relation Î“; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘2 on cast terms requires the type environ-
ment Î“ and the logical context ğœ‘ in the judgement, and the reï¬nement extraction from the type
environment Î¦(Î“) is used in the rule (PC-Assert).

e

e

We also assume the following property on the evaluation of the primitive functions.

Assumption 2. If ev (ğ‘, ğ‘£2) and ev (ğ‘, ğ‘£1) are both deï¬ned, then ğ‘£1 âŠ‘ ğ‘£2 implies ev (ğ‘, ğ‘£1) âŠ‘ ev (ğ‘, ğ‘£2)

Intuitively, the precision of cast terms are designed in such a way that, when âˆ…; true âŠ¢ ğ‘1 âŠ‘ ğ‘2
holds, the assertions in ğ‘1 is more strict than that of ğ‘2, and therefore the dynamic checks in ğ‘1
is more likely to fail than in ğ‘2. The following two propositions state this intuition (the proofs are
in the appendix).

ğ‘1 âˆ’â†’ ğ‘ â€²

Proposition 2. Suppose âˆ…; true âŠ¢ ğ‘1 : ğœ and âˆ…; true âŠ¢ ğ‘2 : ğœ â€². Then, âˆ…; true âŠ¢ ğ‘1 âŠ‘ ğ‘2 and
1 âŠ‘ ğ‘ â€²
Proposition 3. Suppose âˆ…; true âŠ¢ ğ‘1 : ğœ and âˆ…; true âŠ¢ ğ‘2 : ğœ â€². Then, âˆ…; true âŠ¢ ğ‘1 âŠ‘ ğ‘2 and

2 and âˆ…; true âŠ¢ ğ‘ â€²

1 imply ğ‘2 âˆ’â†’ ğ‘ â€²

2 for some ğ‘ â€²
2.

ğ‘2 âˆ’â†’ ğ‘ â€²

2 imply either of the following.

â€¢ ğ‘1 âˆ’â†’ ğ‘ â€²
â€¢ ğ‘1 âˆ’â†’ error

1 and ğ‘ â€²

1 âŠ‘ ğ‘ â€²

2 for some ğ‘ â€²
1

14

Hattori et al.

4.2 Gradual Guarantee
In this subsection, we prove that our system satisï¬es the gradual guarantee [24]. First, we prove
that the consistent subtyping relation Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ is upper-closed with respect to the
precision relation

ğ‘¥ âŠ¢ ğœ1 âŠ‘ ğœ3 on types.

Lemma 3. Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘1, dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ3, dom(Î“) âŠ¢ ğœ2 âŠ‘ ğœ4 and Î“ âŠ‘ Î“â€² implies

Î“â€²; ğœ‘ âŠ¢ ğœ3 . ğœ4 { ğ‘2 for some ğ‘2.

e

We can further prove that the cast term ğ‘2 in the statement of Lemma 3 is less precise than the

original cast term ğ‘1 as follows.

Lemma 4. Suppose Î“ âŠ‘ Î“â€², dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ â€²
{ ğ‘ â€² implies Î“; ğœ‘ âŠ¢ ğ‘ âŠ‘ ğ‘ â€².

and Î“â€²; ğœ‘ âŠ¢ ğœ â€²
1

. ğœ â€²
2

1 and dom(Î“) âŠ¢ ğœ2 âŠ‘ ğœ â€²

2. Then, Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘

Using the above properties, we can prove the following lemma which constitutes the core part

of the proof of the gradual guarantee.

Lemma 5. Î“ âŠ‘ Î“â€², dom(Î“) âŠ¢ ğ‘€ âŠ‘ ğ‘€ â€² and Î“; ğœ‘ âŠ¢ ğ‘€ { ğ‘ : ğœ imply Î“â€²; ğœ‘ âŠ¢ ğ‘€ â€² { ğ‘ â€² : ğœ â€²,

Î“; ğœ‘ âŠ¢ ğ‘ âŠ‘ ğ‘ â€² and dom(Î“) âŠ¢ ğœ âŠ‘ ğœ â€² for some ğ‘ â€² and ğœ â€².

Finally, we can show the static and dynamic gradual guarantee as follows.
Theorem 2 (Static gradual guarantee). âˆ… âŠ¢ ğ‘€1 âŠ‘ ğ‘€2 and âŠ¢ ğ‘€1 : ğœ1 imply âŠ¢ ğ‘€2 : ğœ2 and

âˆ… âŠ¢ ğœ1 âŠ‘ ğœ2 for some ğœ2.

Proof. Immediate result from Lemma 5.
Theorem 3 (Dynamic gradual guarantee). Suppose âˆ… âŠ¢ ğ‘€1 âŠ‘ ğ‘€2 and âŠ¢ ğ‘€1 { ğ‘1 : ğœ1. Then,

(cid:3)

there exist ğ‘2 and ğœ2 that satisfy all of the following.

â€¢ âŠ¢ ğ‘€2 { ğ‘2 : ğœ2.
â€¢ ğ‘1 âˆ’â†’âˆ— ğ‘£1 implies ğ‘2 âˆ’â†’âˆ— ğ‘£2 and ğ‘£1 âŠ‘ ğ‘£2 for some ğ‘£2.
â€¢ ğ‘1 â‡‘ implies ğ‘2 â‡‘.
â€¢ ğ‘2 âˆ’â†’âˆ— ğ‘£2 implies ğ‘1 âˆ’â†’âˆ— ğ‘£1 and ğ‘£1 âŠ‘ ğ‘£2 for some ğ‘£1, or ğ‘1 âˆ’â†’âˆ— error.
â€¢ ğ‘2 â‡‘ implies ğ‘1 â‡‘ or ğ‘1 âˆ’â†’âˆ— error.
Proof. From Lemma 5, âŠ¢ ğ‘€2 { ğ‘2 : ğœ2 holds for some ğ‘2 and ğœ2 where âŠ¢ ğ‘1 âŠ‘ ğ‘2 and âŠ¢ ğœ1 âŠ‘ ğœ2.
Also, from Lemma 2, we obtain âŠ¢ ğ‘1 : ğœ1 and âŠ¢ ğ‘2 : ğœ2.
Using Proposition 2, ğ‘1 âˆ’â†’âˆ— ğ‘£1 for some ğ‘£1 implies ğ‘2 âˆ’â†’âˆ— ğ‘£2 for some ğ‘£2 such that ğ‘£1 âŠ‘ ğ‘£2.

Also, ğ‘1 âˆ’â†’âˆ implies ğ‘2 âˆ’â†’âˆ.

Using Proposition 3, ğ‘2 âˆ’â†’âˆ— ğ‘£2 for some ğ‘£2 implies ğ‘1 âˆ’â†’âˆ— ğ‘£1 for some ğ‘£1 such that ğ‘£1 âŠ‘ ğ‘£2, or
(cid:3)

ğ‘1 âˆ’â†’âˆ— error. Also, ğ‘2 âˆ’â†’âˆ implies ğ‘1 âˆ’â†’âˆ or ğ‘1 âˆ’â†’âˆ— error.

5 IMPLEMENTATION
Based on the type system introduced so far, we have implemented GraTen, a prototype type
checker targeted at OCaml programs that deï¬ne and run deep learning models with OCaml-Torch.
GraTen takes an OCaml program and performs best-eï¬€ort type inference and type checking. If
the type checking is successful, it returns the types of top-level variables deï¬ned in the program,
and the source program with necessary assertions inserted. Otherwise, the type checking fails
with an error message.

The types of the library functions, including those of OCaml-Torch, is deï¬ned in stub ï¬les. For

example, the type of tr (matrix transpose function) is deï¬ned as follows.
val tr : x:{ v:tensor | len v.shape = 2 } -> tensor([nth 1 x.shape; nth 0 x.shape])
GraTen uses the polymorphic extension of the formalized type system which we have discussed

in Section 3.

Gradual Tensor Shape Checking

15

1 let f (x : { v:int | v > 0 }) = x in

f (random_int ())

2
1 let f (x : { v:int | v > 0 }) = x in

f (random_int () : [] |- int => { v:int | v > 0 })

2
1 let f (x : { v:int | v > 0 }) = x in

2

f ((fun v -> assert (v > 0); v) (random_int ()))

Fig. 16. Evolution of a program in each stage of the type checking. On the top is the original program, in the
middle is the program after the type inference and insertion of the subsumption marker, and at the bottom
is the program after the cast insertion.

5.1 Structure of GraTen
5.1.1 Overview. The type checking of GraTen consists of three phases: simple type inference, best-
eï¬€ort type inference and consistent subtyping veriï¬cation.

The ï¬rst phase performs simple type inference for the input program, annotating the AST with

the inferred simple types of each node.

The second phase infers the reï¬nement types in a best-eï¬€ort manner, using the simple type
information from the previous stage. This stage also inserts subsumption marker to places in the
program which may require the assertion. A subsumption marker is a 4-tuple (Î“, ğœ‘, ğœ1, ğœ2) which
indicates that Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ needs to hold for some ğ‘ .

The third phase uses these subsumption markers to check the validity of the consistent subtyp-
ing. For a subsumption marker (Î“, ğœ‘, ğœ1, ğœ2), it is checked with a SMT solver if Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘
actually holds for some ğ‘ . The assertion term ğ‘ is inserted for the term the subsumption marker
is inserted.

An example of the evolution of a program in each stage of the type checking is shown in Fig-
ure 16. The source program (on the top) deï¬nes a function f which takes a positive integer and
applies it to a randomly generated integer. After the type inference, a subsumption marker is in-
serted at the application of f to a random integer. The subsumption marker indicates that under
an empty logical context [], the expression random_int () has type int and it is used as the type
{ğœˆ : int | ğœˆ > 0}. The ï¬nal stage uses this marker to check if âˆ…; true âŠ¢ int . {ğœˆ : int | ğœˆ > 0} {
ğ‘ holds for any ğ‘ , and inserts the assertion ğ‘ . Since the term random_int () is not statically
guaranteed to evaluate to a positive integer, we need to check if it is positive before being applied
to the function f.

A detailed description of the second and the third phase is given in the following subsubsections.

5.1.2 Best-Eï¬€ort Type Inference. In the second phase of the analysis, the type inference engine
uses the information of simple types to generate templates of reï¬nement types for wherever the
reï¬nements need to be come up with. Speciï¬cally, the argument types of unannotated lambda
expressions, the types of unannotated recursive functions, and the types of if expressions and
let expressions are tentatively expressed with the template types.

Then, the inference engine collects all the subtyping constraints from the program. Only during
the inference phase, we assume that the subsumption in the type derivation uses the standard
subtyping relation Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2 instead of the consistent subtyping relation Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘
to get more desirable inference results with fewer assertions.

The subtyping constraints are further decomposed to veriï¬cation conditions, which are logic
terms of the form ğœ‘1 â‡’ ğœ‘2 â‡’ ğœ‘3, following the deï¬nition of the subtyping relation (Figure 10).
The ï¬rst, second, and third predicate in a veriï¬cation condition respectively corresponds to the

16

Hattori et al.

predicate from the context Î¦(Î“) âˆ§ ğœ‘, the reï¬nement of the type on the left ğœ‘1, and that of the type
on the right ğœ‘2. For instance, a subtyping constraint

âˆ…; true âŠ¢ ğ‘¥:{ğ‘¥ : int | ğœ‘1} â†’ {ğ‘¦ : int | ğœ‘2} <: ğ‘¥:{ğ‘¥ : int | ğœ‘3} â†’ {ğ‘¦ : int | ğœ‘4}

is transformed into two veriï¬cation conditions true â‡’ ğœ‘3 â‡’ ğœ‘1 and ğœ‘3 â‡’ ğœ‘2 â‡’ ğœ‘4.

The veriï¬cation conditions may contain the tentative variables for the undetermined reï¬nement
predicates. The inference engine tries to ï¬nd a solution for these variables in such a way that ğœ‘2 and
ğœ‘3 in a veriï¬cation condition ğœ‘1 â‡’ ğœ‘2 â‡’ ğœ‘3 are as â€œcloseâ€ as possible. For example, the solution
for a veriï¬cation condition true â‡’ ğ‘¥ = 1 â‡’ â€˜ğ‘ where â€˜ğ‘ is a tentative variable is â€˜ğ‘ = (ğ‘¥ = 1),
rather than â€˜ğ‘ = true. Each tentative variable holds a collection of variables it can depend on to
enhance the precision of the inference.

Of course, it is diï¬ƒcult to ï¬nd a solution in some situations, for example, when there are multiple
tentative predicate variables on the rightmost-hand side of a veriï¬cation condition. In such cases,
the inference engine does not try to do anything with the veriï¬cation condition. As such, the solver
process the constraints until they are all cleared or it reached saturation with all of the constraints
left cannot be processed further. All the undecided tentative variables are then given the solution
of true, the most general reï¬nement predicate.

5.1.3 Consistent Subtyping Verification and Assertion Insertion. After the type inference is ï¬nished,
GraTen checks the validity of the subsumption markers and inserts assertions if necessary.

For a subsumption marker (Î“, ğœ‘, ğœ1, ğœ2), GraTen ï¬rst attempts to prove Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2 with Z3 [5].
If it is veriï¬ed within a predetermined time limit, the subsumption marker is resolved as valid and
no assertion is inserted to that position. This is because Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2 implies Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘
for some ğ‘ , and as we learned in Section 2 (Proposition 1), no assertions need to be inserted if ğœ1
is a subtype of ğœ2.

If Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2 is not veriï¬ed, it still does not mean that the program cannot be type-checked.
In that case, GraTen tries to disprove âˆƒğ‘ . Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ with Z3. If it is disproved within the
time limit, it implies that the consistent subtyping constraints cannot be satisï¬ed for any possible
inputs, and hence program does not type-check. Otherwise, the subsumption marker is optimisti-
cally resolved as valid and an appropriate assertion is inserted.

The inserted assertion is constructed following the deï¬nition of the consistent subtyping rela-
tion (Figure 12). In the assertion generation for the base case (Cast-Base), the predicate ğœ‘2 from
the type on the right-hand side is chosen as the predicate ğœ‘ â€² to be checked in the assertion.

6 EXPERIMENT
This section reports on experiments to evaluate the eï¬€ectiveness of the best-eï¬€ort inference, using
the example programs bundled in the OCaml-Torch library [2]. We have also checked how type
annotations changed the inference results.

6.1 Methods
6.1.1 Test Cases. We applied GraTen to programs under examples/ directory of the repository of
OCaml-Torch5. Table 1 shows the list of programs we have tested GraTen with. Since GraTen is
yet to support some features of OCaml and OCaml-Torch, some of the programs were modiï¬ed in
such a way that does not change the structure of the neural network for GraTen to successfully
analyze them. A list of the notable modiï¬cations added to the target programs is shown below.
Smaller syntactic modiï¬cations are not listed here and can be found in the supplementary materi-
als.

5https://github.com/LaurentMazare/ocaml-torch/tree/main/examples

Gradual Tensor Shape Checking

17

(M1) Replacing or removing type-polymorphic functions. Type-polymorphic functions that are
used to create loops such as List.foldl are replaced with recursive functions. Only in
cifar/densenet.ml, List.foldi is unrolled assuming that the length of block_config is 4,
since otherwise it was impossible to add precise type annotations that can make the program
statically type-check. Other type-polymorphic functions such as no_grad are replaced with
the type-instantiated versions.

(M2) Removing use of lists with non-integer elements, especially tensor lists and layer6 lists. Since
GraTen does not support reï¬nement inference for tensor lists and layer lists yet, using lists
of tensors or layers can interfere with the precise inference. As a result, two list-taking primi-
tive functions are removed. First, Tensor.cat is replaced with a variant Tensor.cat_ which
takes two tensors instead of a list of tensors. Consequently, an application of Tensor.cat
to a list of two tensors like Tensor.cat dim [xs; ys] is changed to Tensor.cat_ dim xs
ys. Second, the use of Layer.sequential is replaced with a recursive function or a chain
of layer applications.

(M3) Replacing mutable ï¬‚oat objects with 0-dimensional tensors.
(M4) Deconstructing record objects. Some programs use record types to put together parameters,
tensors or layers. Some of the record ï¬elds hold integer parameters on which the tensor
shape of other objects depends. Since ï¬eld access of record objects is not supported in re-
ï¬nement predicates, such parameters are separated from the record types and added to the
function arguments.

(M5) Currying some functions that take pairs of integers. For example, function max_pool2d takes
a pair of integers for the height and width of the padding, kernel size and the stride pa-
rameters. Since tuples are not available yet in the reï¬nement predicates, we replace it with
max_pool2d_ which has the following type signature.

(M6) Changing optional arguments to required arguments. OCaml has a feature called optional
arguments which allows the programmer to omit arguments. When it is omitted, the default
argument will be used if it is deï¬ned; otherwise, the argument becomes the option type
(nullable type). Because the support of polymorphic types such as option is premature in
GraTen, optional arguments without default arguments are changed to required arguments.
Among the above modiï¬cations, we believe that enabling to undo the changes from (M2), (M4),
(M5) and (M6) will be a matter of engineering that can be achieved by improving the implementa-
tion. Meanwhile, (M1) and (M3) would reuire extention of the type system.

The programs that can be found under examples/ and not listed in Table 1 are excluded from

the test cases for the following reasons:

â€¢ neural_transfer uses a library function Vgg.vgg16_layers whose type cannot be de-

scribed in GraTen.

â€¢ Programs dqn.ml, dqn_atari.ml,dqn_pong.ml under reinforcement-learninguse queues

which are not supported in GraTen yet.

â€¢ env_gym_pyml.ml and venv_env_gym_pyml.ml under reinforcement-learning treats Python

objects whose veriï¬cation is not the scope of this paper.

â€¢ reinforcement-learning/policy_gradient.ml uses mutable lists which cannot be re-

placed with another datatype already supported in GraTen.

â€¢ yolo/darknet.ml and translation/lang.ml use hash tables which are not supported in

GraTen yet.

â€¢ translation/dataset.ml and translation/lang.ml are irrelevant as tensor objects do

not appear in them.

6Functions that takes a tensor and returns a tensor.

18

Hattori et al.

Location under examples/
char_rnn/char_rnn.ml
cifar/cifar_train.ml
cifar/densenet.ml
cifar/fast_resnet.ml
cifar/preact_resnet.ml
cifar/resnet.ml
gan/began.ml
gan/gan_stability.ml
gan/mnist_cgan.ml
gan/mnist_dcgan.ml
gan/mnist_gan.ml
gan/progressive_growing_gan.ml
gan/relativistic_dcgan.ml
jit/load_and_run.ml
min-gpt/mingpt.ml
mnist/conv.ml
mnist/linear.ml
mnist/nn.ml
pretrained/ï¬netuning.ml
pretrained/predict.ml
reinforcement-learning/a2c.ml
reinforcement-learning/ppo.ml
reinforcement-learning/rollout.ml
translation/seq2seq.ml
vae/vae.ml
yolo/yolo.ml

Modiï¬cations
(M1), (M3), (M4)
(M3)
(M1), (M2), (M5)
(M2), (M5)
(M2), (M5)
(M1), (M5)
(M1), (M3), (M5)
(M1), (M5)
(M2)
None
None
(M2)
None
None
(M4)
(M5)
None
None
(M1), (M3)
None
(M4)
(M4)
(M3), (M4), (M6)
(M1), (M3)
(M3)
None

Table 1. List of programs used in the experiment. The left column shows the location of the original program
in the OCaml-Torch repository, and the right column lists the added modifications.

To successfully analyze the test cases, GraTen provides basic support for OCaml module sys-
tems: users can deï¬ne and use modules within a single ï¬le, and use modules implemented in
other ï¬les as well. For instance, cifar/cifar_train.ml uses the other programs under cifar/.
In such a case, GraTen loads in advance the type signature of the other dependent modules
from the corresponding .mli ï¬les7. Therefore, we assume in this experiment that the reï¬nement
type signatures of the dependent modules are given even before type-annotating the target pro-
gram itself. For example, upon experimenting with cifar/cifar_train.ml, it is assumed that the
cifar/model.mli deï¬nes the precise types for each ï¬eld of the type Model.t as in Figure 178, and
the .mli ï¬les for the other modules under cifar/ is deï¬ned similarly.

6.1.2 Evaluation. We evaluated GraTen and its best-eï¬€ort inference by focusing on the following
three aspects.

7In OCaml, ï¬les with extension .mli deï¬ne the interface of a module. For example, foo.mli provides the signature of a
module named Foo implemented in foo.ml.
8In GraTen, â€™Ëœâ€™ (tilde) before filename indicates that the name filename is used as the argument label.

Gradual Tensor Shape Checking

type t =

19

{ model_name : string
; model : x:{ v:tensor | len v.shape = 4 && nth 1 v.shape = 3 &&

-> ~is_training:bool -> tensor([nth 0 x.shape; 10])

(nth 2 v.shape // 32) * (nth 3 v.shape // 32) = 1 }

; epochs : int
; lr_schedule : ~batch_idx:int -> ~batches_per_epoch:int -> ~epoch_idx:int -> float
; batch_size : int
}

Fig. 17. Definition of Model.t in cifar/mode.mli

First, we counted the number of assertions inserted into the original program when GraTen
is used for the target program. Since the assertions indicate the program points that could fail
at runtime, the user of GraTen would want to pay attention to the location and the number of
inserted assertions and try to decrease them.

Second, we counted the minimum number of type annotations required to statically type-check
the entire program to show the realistic programmersâ€™ burden of trying to statically type-check
the program with type annotations. The annotations were added in such a way that the functions
do not lose the original shape polymorphism. The type annotations are counted by the number of
reï¬nement types with reï¬nement predicates in the provided annotations. For example, the follow-
ing type annotation of a function type counts as 3 since the reï¬nement of the input tensor and the
two output tensors are written. The type annotation bool for the second argument is not counted
because its reï¬nement is omitted as true.
tensor([h; w]) -> ~is_training:bool -> tensor([h; w]) * tensor([h; w])

Some programs have type annotations in the deï¬nition of record types in a similar manner as in
Figure 17. Such annotations are taken into account as well.

Lastly, we measured the time taken by GraTen to analyze the unannotated and annotated pro-
grams. The experiment is conducted on a Linux machine with 8-core Intel i7-7700K (4.20GHz) and
GHC version 8.8.4 is used.

6.2 Experimental Results

Table 2 presents the result of the experiment. We analyze this result by the following three aspects:
assertions, type annotations and analysis time.

Inserted Assertions. Out of 26 programs tested, 11 programs did not require type annotations
6.2.1
to statically type-check the whole program. Among the other 15 programs, 7 programs statically
type-checked after adding appropriate type annotations. The assertions remained even after an-
notated for the other 8 programs such as gan/began.ml and gan/gan_stability.ml. These remaining
assertions are caused by the type signatures of some library functions being imprecise about the
return type. For instance, Torch.Serialize.load is a function that loads a tensor from a ï¬le and
its type signature is deï¬ned as follows.

val load : ~filename:string -> tensor

The return type of load is simply deï¬ned as tensor since it is impossible to assume any properties
about its shape. As a result, an assertion was inserted to check if the loaded tensor satisï¬es the
requirement to run the program without uncaught errors. Even adding type annotations to the
loaded tensor does not remove the assertion.

20

Hattori et al.

Location under examples/
char_rnn/char_rnn.ml
cifar/cifar_train.ml
cifar/densenet.ml
cifar/fast_resnet.ml
cifar/preact_resnet.ml
cifar/resnet.ml
gan/began.ml
gan/gan_stability.ml
gan/mnist_cgan.ml
gan/mnist_dcgan.ml
gan/mnist_gan.ml
gan/progressive_growing_gan.ml
gan/relativistic_dcgan.ml
jit/load_and_run.ml
min-gpt/mingpt.ml
mnist/conv.ml
mnist/linear.ml
mnist/nn.ml
pretrained/ï¬netuning.ml
pretrained/predict.ml
reinforcement-learning/a2c.ml
reinforcement-learning/ppo.ml
reinforcement-learning/rollout.ml
translation/seq2seq.ml
vae/vae.ml
yolo/yolo.ml

LOC time (s)

98
72
116
64
85
78
220
224
117
136
83
118
171
16
207
53
50
39
69
68
105
129
91
258
78
144

1.86
0.27
10.75
0.96
3.16
2.51
24.66
15.33
0.97
4.21
0.56
1.13
5.97
0.23
16.21
0.41
0.30
0.23
0.32
0.41
1.14
1.48
8.53
8.20
1.66
0.86

#assert
4
0
6
0
8
8
1
40
1
4
0
0
1
1
8
0
0
0
0
2
0
0
9
11
4
4

#annot
4
-
2
-
5
4
1
4
-
2
-
-
1
1
7
-
-
-
-
2
-
-
7
35
10
2

time (s)
0.81
-
23.97
-
1.18
1.49
24.67
16.12
-
2.10
-
-
5.83
0.23
15.94
-
-
-
-
0.32
-
-
3.83
5.77
0.59
0.85

#assert
0
-
0
-
0
0
1
2
-
0
-
-
1
1
0
-
-
-
-
2
-
-
1
3
0
3

Table 2. Result of running GraTen to the test cases. The second column shows the size of the program
after being modified following the description in Table 1. The third and fourth columns are the results for
unannotated programs. The third column shows the time taken by GraTen to type-check the program, and
the fourth column shows the number of assertions inserted after that. From the fifth to the seventh columns
are for the programs after adding some annotations. The fifth column shows the number of annotations
added to the program.

It must be noted that some other functions are given imprecise types due to the immature sup-
port of polymorphic data types. For example, the type of Tensor.stack is deï¬ned as follows
because GraTen does not eï¬€ectively support non-integer lists yet. Reï¬ning the return types of
such functions is left as a future work.
val stack : ~dim:int -> list (tensor) -> tensor

6.2.2 Patterns of Added Type Annotations. As we added type annotations to the test cases, we
observed that the program points that require type annotations have similarities. In fact, all of the
type annotations falls into one of the following patterns.
(P1) Branches i.e., if expressions and match expressions with multiple branches (e.g., Figure 4 in

Section 1).

(P2) Recursive functions. For example, loop in translation/seq2seq.ml is annotated as follows.

Gradual Tensor Shape Checking

21

(P5) Total

Location under examples/
char_rnn/char_rnn.ml
cifar/densenet.ml
cifar/preact_resnet.ml
cifar/resnet.ml
gan/began.ml
gan/gan_stability.ml
gan/mnist_dcgan.ml
gan/relativistic_dcgan.ml
jit/load_and_run.ml
pretrained/predict.ml
reinforcement-learning/rollout.ml
translation/seq2seq.ml
min-gpt/mingpt.ml
vae/vae.ml
yolo/yolo.ml

4
2
5
4
1
4
2
1
1
2
7
35
7
10
2
Table 3. Breakdown of the number of annotations required in the test cases.

(P1)
0
0
3
2
0
2
2
0
0
1
0
3
0
0
0

(P3)
2
0
0
0
0
0
0
0
0
0
3
2
4
0
0

(P2)
2
2
2
2
0
0
0
0
0
0
0
15
3
0
0

(P4)
0
0
0
0
0
0
0
0
0
0
0
13
0
10
0

0
0
0
0
1
2
0
1
1
1
4
2
0
0
2

let rec loop

: ~state:tensor([1; hidden_size]) -> ~prevs:list ({ v:tensor | prod v.shape = 1 })
-> ~max_length:int -> list ({ v:tensor | prod v.shape = 1 })

= fun ~state ~prevs ~max_length -> ...

(P3) Higher-order shape-polymorphic arguments. For example, sample in char_rnn.ml is anno-

tated as follows.
let sample ~labels ~lstm ~dataset ~device

~linear:(linear : x:{ v:tensor | last v.shape = hidden_size }

-> tensor(init x.shape @ [labels])) = ...

(P4) Deï¬nition of record types (e.g., Figure 17).
(P5) Imprecise type signatures of primitive functions, or user-deï¬ned functions of dependent
modules. For example, translation/seq2seq.ml has the following type annotation since the
return type of Tensor.stack is imprecise.
let enc_outputs : tensor([1; len input_; hidden_size]) =

Tensor.stack enc_outputs ~dim:1

As stated in Subsubsection 6.2.1, these annotations do not result in removing the assertion
insertion.

The ï¬rst three patterns indicate that the best-eï¬€ort type inference does not eï¬€ectively infer pre-
cise reï¬nements for branches, recursive functions and higher-order shape-polymorphic arguments.
The fourth pattern (P4) would be inevitable when using record types. As we discussed in the pre-
vious section, it remains as future work to exempt users from having to add type annotations for
(P5). With such improvements, we believe that it will be quite predictable to point out the program
points that require type annotation for better inference.

Table 3 shows the breakdown of the annotation counts categorized by the patterns from (P1)
to (P5). While most of the annotated programs statically type-checked with no more than 10 an-
notations, translation/seq2seq.ml required comparatively many annotations as several recursive

22

Hattori et al.

functions and record types are used in it. Still, the use of record types seems to have been eï¬€ec-
tive in reducing the number of annotations in translation/seq2seq.ml as the record type deï¬nition
worked as type aliases and avoided repetitive annotations for the decoder, which is passed around
to functions predict and train_loss as a higher-order shape-polymorphic argument.

6.2.3 Analysis Time. The analysis time varies widely by test cases with a slight tendency that
larger programs take a longer time than smaller ones. While GraTen type-checked most of the
15 annotated programs in a shorter time than the unannotated ones, the analysis time increased
after annotations for cifar/densenet.ml and gan/gan_stability.ml. This may be because adding pre-
cise type annotations increases the complexity of the inferred types for a function that is used in
multiple places, leading to more precise yet costly analysis.

Some instances such as gan/began.ml took a considerably long time to analyze. It is left as future

work to proï¬le and speed up the analysis.

6.3 Discussions
In this subsection, we discuss the strengths, weaknesses and our perspective of the future devel-
opment of our system.

6.3.1 Performance of Best-Eï¬€ort Inference. As we reported in Subsubsection 6.2.2, the best-eï¬€ort
type inference of GraTen does not perform well for branches, recursions and higher-order shape-
polymorphic arguments â€“ at a glance, this may seem unsatisfying. However, the objective of this
research is not to develop a perfect inference algorithm but to provide a method that can be used
for unannotated programs, and to encourage users to work interactively with the type checker to
gradually add type annotations. With this respect, we believe that GraTen has achieved desirable
results since it will be easy for the user to ï¬nd out where to add type annotations. This is because
1) the inserted assertions can tell which parts of the program are not statically type-checked, and
2) as we discussed in Subsubsection 6.2.2, the location where type annotations would be required
is predictable from the program structure.

6.3.2 Lists of Tensors and Layers. As of now, the reï¬nement inference for lists in GraTen is only
available for integer lists. Meanwhile, it is common in deep learning programs to deï¬ne a list of
tensors or a list of functions. For example, library functions Tensor.cat and Tensor.stack both
take a list of tensors and return a new tensor by concatenating them. Another library function
Layer.sequential takes a list of layers (functions that take and return a tensor) and makes an-
other layer by composing them.

An idea to add support for these library functions is to add new reï¬nement predicates for ten-
sors lists or layer lists. For example, we can add a predicate composable(ğ‘¥, ğ‘†1, ğ‘†2) which means
that a list of layers ğ‘¥ is composable and the composed function takes a tensor of shape ğ‘†1 and re-
turns a tensor of shape ğ‘†2. The type of Layer.sequential can then be expressed with the shape
polymorphic extension (Section 3)) as follows.
val sequential : forall S1 S2.

{ v:list(tensor -> tensor) | composable(x,S1,S2) } -> tensor(S1) -> tensor(S2)
To practically infer composable reï¬nements for layer lists, it will also be necessary to change the
type-instantiated versions of list-manipulating functions as well. For instance, the cons function
has the following type for integer lists:
val cons_int : x:int -> y:list(int) -> { v:list(int) | v = x :: y }

Meanwhile, it would need to have the following type for layer lists.
val cons_layers

Gradual Tensor Shape Checking

23

: forall S1 S2 S3. (tensor(S1) -> tensor(S2))
-> { v:list(tensor -> tensor) | composable(v, S2, S3) }
-> { v:list(tensor -> tensor) | composable(v, S1, S3) }

6.3.3 Type-Level Polymorphism. Since GraTen does not support type-level polymorphism, some
type-polymorphic functions were replaced with type-instantiated versions in the experiments.

One idea to implement type-level polymorphism would be to allow adding multiple type signa-
tures in the fashion of mypy [17]. For example, the cons function would be assigned diï¬€erent type
signatures depending on the type of the list elements as follows.
val cons : 'a -> list('a) -> list('a)
@overload
val cons: x:int -> y:list(int) -> { v:list(int) | v = x :: y }
@overload
val cons : forall S1 S2 S3. x:(tensor(S1) -> tensor(S2)) -> ...

6.3.4 Reporting Incorrect Type Annotations. Since our type system sees the standard reï¬nement
types as gradual, some users might ï¬nd the behavior of GraTen unexpected in some cases. For
example, the following program deï¬nes a function f which takes a matrix and returns a matrix.
Suppose that the programmer intended the function f to return a matrix of the same shape as the
input, but mistakenly used a transpose function tr. As a result, the type annotation is incorrect in
general.
let f x = (tr x : tensor(x.shape))

Although the type annotations in this program seem precise enough, the wrong type annotation
does not make this program fail to type-check in our type system. This is because there is a pos-
sibility that these type annotations hold when the input matrix is square. GraTen accepts this
program and outputs the following program with an assertion.
let f x = (fun y -> assert(y.shape = x.shape); y) (tr x)
To make sure that a given program behaves as expected, users not only need to make GraTen
accept the program but also need to check the output program to see if no unexpected assertions
are inserted.

7 RELATED WORK
7.1 Tensor Shape Checking in Deep Learning Programs

The tensor shape checking method has been studied for decades, mainly focusing on the ï¬eld of
numeric analysis [4, 7]. The tensor shape checking with a focus on the deep learning programs,
however, is a relatively new topic, and a variety of methods have been proposed both in academia
and in industry.

Some tools statically check tensor shapes with advanced type systems. Hasktorch [1] is a Haskell
binding of libtorch [19] which provides a mode that statically checks tensor shapes. Since they use
the type-level programming feature of Haskell to implement the tensor shapes, tensor shapes are
not ï¬rst-class objects. As a result, programs such as the one in Figure 1 cannot be expressed since it
is impossible to deï¬ne the function f whose type depends on the ï¬rst-class object s. Relay [21, 22]
is an IR for deep learning compilers with a rich type system for tensor shape with type inference.
Both Relay and Hasktorch support dynamic shape as a wild card in the static shape checking.

Apart from the type-based veriï¬cation methods, some tensor shape error detection tools also
take a static approach. Pythia [6, 15] statically detects shape fault for TensorFlow [3] programs by
keeping track of the tensor shapes throughout the program using value-ï¬‚ow analysis. The tracking

24

Hattori et al.

of shape is in a best-eï¬€ort manner, allowing the shape inference results to be â€œunknownâ€ in some
cases. The analysis crucially relies on the programming practice in TensorFlow to annotate tensor
shapes as much as possible.

Other static checking tools took an approach that uses symbolic execution to collect constraints
from the program and veriï¬es it with a solver; Tensors Fitting Perfectly [20] and PyTea [13] are
on this approach. Both methods remove loops from the program in an ad-hoc manner based on a
reasonable assumption for the program.

Lastly, some took dynamic approaches to provide lightweight shape fault detection. Shape-
Flow [26] is an abstract interpreter of TensorFlow programs; it shares the same APIs as TensorFlow
but only calculates the shape of tensors. Users can run the analysis by replacing the import of Ten-
sorFlow with ShapeFlow in the target program, which executes more eï¬ƒciently than the original
TensorFlow program. Elichika [12] uses a similar method to ShapeFlow with a feature to display
the interpreted shapes with a symbolic expression. These dynamic approaches enable quick anal-
ysis and require no type annotations, but provide no guarantee for untested inputs.

7.2 Static and Dynamic Checking for Refinement Types
Earlier work on dependent type system focuses on decidable type checking and inference with
restricted reï¬nement logic [10, 23, 28, 29]. Meanwhile, dynamic checking with contracts [9, 18]
oï¬€ers expressive veriï¬cation that cannot be covered with a static type system, but at a cost of
runtime overhead. Naturally, the combination of static and dynamic checking has been actively
explored by the successors of both parties.

Hybrid type checking [14] is a similar method to ours which extends the purely-dynamic method
of using contracts by verifying speciï¬cations statically as much as possible. This method diï¬€ers
from ours in that it inserts a dynamic check only when the subtyping constraint is not proven to
be valid or invalid. As a result, this method statically rejects the incorrectly annotated program
that we discussed in Subsubsection 6.3.4, while our method accepts it with a dynamic check in the
hope that a more precise type annotation will remove the need for a dynamic check. Our method
can be understood as a variant of hybrid type checking with a focus on being gradual in adding
type annotations.

The application of gradual typing to dependent type systems has also been studied [8, 16].
Especially, Gradual Reï¬nement Types [16] is very similar to our type system in that it gradual-
izes only the predicate part of a reï¬nement type system and the underlying simple type is static.
One of the diï¬€erences is that their system distinguishes statically-unknown reï¬nement predicates
with statically-known ones, while our system assumes that any reï¬nement predicates can have a
statically-unknown portion. For example, consider the following program:

let ğ‘“ ğ‘¥ (ğ‘¦ : {ğœˆ : int | true}) = ğ‘¥/ğ‘¦

This program is rejected in their system because the type annotation of ğ‘¦ indicates that the pro-
grammer is conï¬dent that ğ‘¦ can be any integers including 0; otherwise, the type annotation should
have been {ğœˆ : int | â˜… }. Meanwhile, our system interprets the type annotation as not precise
enough and accepts the program by inserting a dynamic check to ğ‘¦.

The type inference for gradual reï¬nement types has been studied by Vazou et al. [25]. Their

work limits the reï¬nement to liquid predicates [23] to maintain the decidability.

8 CONCLUSION AND FUTURE WORK

We presented a new type-based approach to verifying tensor shapes by combining best-eï¬€ort type
inference with gradual typing. Since the inference and checking of tensor shapes are undecidable

Gradual Tensor Shape Checking

25

in general, the type checker inserts assertions to places where the type safety is not statically
guaranteed, and users can assist the best-eï¬€ort inference by annotating the program.

We formalized the type system and proved that it satisï¬es the criteria of gradual typing, espe-
cially the gradual guarantee. The key idea is to interpret the standard reï¬nement types as gradual;
the precision relation of types is deï¬ned by the logical implication of the reï¬nement predicates.
Instead of the standard subtyping relation Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2, our type system uses the consistent
subtyping relation Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ that states there exists a value that has both of types ğœ1 and
ğœ2. The consistent subtyping relation generates an assertion to dynamically check the type safety.
The typing relation is deï¬ned as a relation to insert these assertions into the source program.

Finally, we implemented a prototype type checker GraTen and applied it with some of the
example programs publicly available in OCaml-Torch repository. We observed that, thanks to the
best-eï¬€ort type inference, users would not be required too many type annotations to statically
type-check the whole program, and it would not be diï¬ƒcult to ï¬nd where to add type annotations
to improve the inference.

We conclude with some ideas for future work.

â€¢ Extension with type polymorphism. As we observed in the experiments, type polymorphic
functions are frequently used in realistic programs. Extending our type system with ML-
style type polymorphism would make the type checker more practical.

â€¢ Application for imperative languages with dynamic type system, especially Python. In this
paper, we have selected OCaml as a target language of the prototype in order to ensure
that the input program is statically-typed. Since Python and Python-based libraries such as
TensorFlow and PyTorch are more popular in the machine learning community than OCaml
and OCaml-Torch, it would be more beneï¬cial for the community to apply our approach for
Python.

Acknowledgment

This work was partially supported by JSPS KAKENHI Grant Numbers JP20H05703.

REFERENCES
[1] 2020. Hasktorch. http://hasktorch.org/. [Online; accessed 15-July-2021].
[2] 2020. OCaml-Torch. https://github.com/LaurentMazare/ocaml-torch. [Online; accessed 05-July-2021].
[3] MartÃ­n Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S Corrado, Andy Davis,
Jeï¬€rey Dean, Matthieu Devin, et al. 2016. Tensorï¬‚ow: Large-scale machine learning on heterogeneous distributed
systems. arXiv preprint arXiv:1603.04467 (2016).

[4] Akinori Abe and Eijiro Sumii. 2015. A simple and practical linear algebra library interface with static size checking.

arXiv preprint arXiv:1512.01898 (2015).

[5] Leonardo De Moura and Nikolaj BjÃ¸rner. 2008. Z3: An eï¬ƒcient SMT solver. In International conference on Tools and

Algorithms for the Construction and Analysis of Systems. Springer, 337â€“340.

[6] Julian Dolby, Avraham Shinnar, Allison Allain, and Jenna Reinen. 2018. Ariadne: analysis for machine learning pro-
grams. In Proceedings of the 2Nd ACM SIGPLAN International Workshop on Machine Learning and Programming Lan-
guages. 1â€“10.

[7] Frederik Eaton. 2006. Statically typed linear algebra in Haskell. In Proceedings of the 2006 ACM SIGPLAN workshop on

Haskell. 120â€“121.

[8] Joseph Eremondi, Ã‰ric Tanter, and Ronald Garcia. 2019. Approximate normalization for gradual dependent types.

Proceedings of the ACM on Programming Languages 3, ICFP (2019), 1â€“30.

[9] Robert Bruce Findler and Matthias Felleisen. 2002. Contracts for higher-order functions. In Proceedings of the seventh

ACM SIGPLAN international conference on Functional programming. 48â€“59.

[10] Tim Freeman and Frank Pfenning. 1991. Reï¬nement types for ML. In Proceedings of the ACM SIGPLAN 1991 conference

on Programming language design and implementation. 268â€“277.

[11] Ronald Garcia, Alison M Clark, and Ã‰ric Tanter. 2016. Abstracting gradual typing. In Proceedings of the 43rd Annual

ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. 429â€“442.

26

Hattori et al.

[12] Momoko Hattori, Shimpei Sawada, Shinichiro Hamaji, Masahiro Sakai, and Shunsuke Shimizu. 2020. Semi-static
type, shape, and symbolic shape inference for dynamic computation graphs. In Proceedings of the 4th ACM SIGPLAN
International Workshop on Machine Learning and Programming Languages. 11â€“19.

[13] Ho Young Jhoo, Sehoon Kim, Woosung Song, Kyuyeon Park, DongKwon Lee, and Kwangkeun Yi. 2021. A Static
Analyzer for Detecting Tensor Shape Errors in Deep Neural Network Training Code. arXiv preprint arXiv:2112.09037
(2021).

[14] Kenneth Knowles and Cormac Flanagan. 2010. Hybrid type checking. ACM Trans. Program. Lang. Syst. 32, 2 (2010),

6:1â€“6:34. https://doi.org/10.1145/1667048.1667051

[15] Siï¬s Lagouvardos, Julian Dolby, Neville Grech, Anastasios Antoniadis, and Yannis Smaragdakis. 2020. Static analysis
of shape in TensorFlow programs. In 34th European Conference on Object-Oriented Programming (ECOOP 2020). Schloss
Dagstuhl-Leibniz-Zentrum fÃ¼r Informatik.

[16] Nico Lehmann and Ã‰ric Tanter. 2017. Gradual reï¬nement types. In Proceedings of the 44th ACM SIGPLAN Symposium

on Principles of Programming Languages. 775â€“788.

[17] Jukka Lehtosalo et al. 2017. Mypy: optional static typing for python. http://mypy-lang.org/.

[Online; accessed

02-March-2022].

[18] Bertrand Meyer. 1992. Eiï¬€el: the language. Prentice-Hall, Inc.
[19] Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Alban

Desmaison, Luca Antiga, and Adam Lerer. 2017. Automatic diï¬€erentiation in pytorch. (2017).

[20] Adam Paszke and Brennan Saeta. 2021. Tensors Fitting Perfectly. arXiv preprint arXiv:2102.13254 (2021).
[21] Jared Roesch, Steven Lyubomirsky, Marisa Kirisame, Logan Weber, Josh Pollock, Luis Vega, Ziheng Jiang, Tianqi
Chen, Thierry Moreau, and Zachary Tatlock. 2019. Relay: A high-level compiler for deep learning. arXiv preprint
arXiv:1904.08368 (2019).

[22] Jared Roesch, Steven Lyubomirsky, Logan Weber, Josh Pollock, Marisa Kirisame, Tianqi Chen, and Zachary Tatlock.
2018. Relay: A new ir for machine learning frameworks. In Proceedings of the 2nd ACM SIGPLAN International Work-
shop on Machine Learning and Programming Languages. 58â€“68.

[23] Patrick M Rondon, Ming Kawaguci, and Ranjit Jhala. 2008. Liquid types. In Proceedings of the 29th ACM SIGPLAN

Conference on Programming Language Design and Implementation. 159â€“169.

[24] Jeremy G Siek, Michael M Vitousek, Matteo Cimini, and John Tang Boyland. 2015. Reï¬ned criteria for gradual typ-
ing. In 1st Summit on Advances in Programming Languages (SNAPL 2015). Schloss Dagstuhl-Leibniz-Zentrum fuer
Informatik.

[25] Niki Vazou, Ã‰ric Tanter, and David Van Horn. 2018. Gradual liquid type inference. Proceedings of the ACM on Pro-

gramming Languages 2, OOPSLA (2018), 1â€“25.

[26] Sahil Verma and Zhendong Su. 2020.

ShapeFlow: Dynamic Shape Interpreter for TensorFlow.

arXiv preprint

arXiv:2011.13452 (2020).

[27] Philip Wadler and Robert Bruce Findler. 2009. Well-typed programs canâ€™t be blamed. In European Symposium on

Programming. Springer, 1â€“16.

[28] Hongwei Xi and Frank Pfenning. 1998. Eliminating array bound checking through dependent types. In Proceedings

of the ACM SIGPLAN 1998 conference on Programming language design and implementation. 249â€“257.

[29] Hongwei Xi and Frank Pfenning. 1999. Dependent types in practical programming. In Proceedings of the 26th ACM

SIGPLAN-SIGACT symposium on Principles of programming languages. 214â€“227.

A COMPLETE DEFINITIONS AND PROOFS
A.1 Well-Formedness of Types

A.2 Semantics of Cast Terms
Figure 19 deï¬nes the full deï¬nition of the reduction of the cast terms ğ‘1 âˆ’â†’ ğ‘2.

A.3 Properties about Type System

Proposition 4. (Proposition 1 in paper) Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2 implies Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ for some ğ‘

where all the assertions in ğ‘ are of the form assert(true); ğ‘ â€².

Proof. By induction on Î“; ğœ‘ âŠ¢ ğœ1 <: ğœ2.

â€¢ Case (Sub-Base).

Gradual Tensor Shape Checking

27

Î“ âŠ¢BT ğ‘¡ : ğµ

Î” âŠ¢BT ğ‘¥ : Î”(ğ‘¥)

Î” âŠ¢BT true : bool

Î” âŠ¢BT false : bool

Î” âŠ¢BT ğ‘ ğ‘– : int

(ğ‘– = 1, 2)

Î” âŠ¢BT ğ‘†ğ‘– : int list

(ğ‘– = 1, 2)

Î” âŠ¢BT ğ‘ 1 = ğ‘ 2 : bool

Î” âŠ¢BT ğ‘†1 = ğ‘†2 : bool

Î” âŠ¢BT ğ‘› : int
Î” âŠ¢BT ğœ‘ : bool
Î” âŠ¢BT Â¬ğœ‘ : bool

Î” âŠ¢BT ğœ‘ğ‘– : bool

(ğ‘– = 1, 2)

Î” âŠ¢BT ğœ‘ğ‘– : bool

(ğ‘– = 1, 2)

Î” âŠ¢BT Â¬ğœ‘1 âˆ§ ğœ‘2 : bool
(ğ‘– = 1, 2)

Î” âŠ¢BT ğ‘†ğ‘– : int list

Î” âŠ¢BT broadcastable(ğ‘†1, ğ‘†2) : bool

Î” âŠ¢BT Â¬ğœ‘1 âˆ¨ ğœ‘2 : bool
Î” âŠ¢BT ğ‘†ğ‘– : int list
Î” âŠ¢BT reshapeable(ğ‘†1, ğ‘†2) : bool

(ğ‘– = 1, 2)

Î” âŠ¢BT ğ‘ ğ‘– : int(ğ‘– = 1, . . . , ğ‘›)
Î” âŠ¢BT [ğ‘ 1; . . . ; ğ‘ ğ‘›] : int list
Î” âŠ¢BT ğ‘† : int list
Î” âŠ¢BT len(ğ‘†) : int

Î” âŠ¢BT ğ‘†ğ‘– : int list
(ğ‘– = 1, 2)
Î” âŠ¢BT append(ğ‘†1, ğ‘†2) : int list

Î” âŠ¢BT ğ‘  : int

Î” âŠ¢BT ğ‘† : int list

Î” âŠ¢BT nth(ğ‘ , ğ‘†) : int

Î” âŠ¢BT ğ‘ ğ‘– : int

(ğ‘– = 1, 2)

Î” âŠ¢BT ğ‘ ğ‘– : int

(ğ‘– = 1, 2)

Î” âŠ¢BT ğ‘ 1 + ğ‘ 2 : int

Î” âŠ¢BT ğ‘ 1 Ã— ğ‘ 2 : int

Î”(ğ‘¥) = tensor
Î” âŠ¢BT ğ‘¥ .shape : int list
Î” âŠ¢BT ğ‘  : int
Î” âŠ¢BT âˆ’ğ‘  : int
(ğ‘– = 1, 2)

Î” âŠ¢BT ğ‘ ğ‘– : int
ğ‘ 1
Î” âŠ¢BT
ğ‘ 2

: int

Fig. 18. Complete rules for the typing rules of predicates, shapes and sizes.

(cid:15) âˆ€BT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 â‡’ ğœ‘2
Î“; ğœ‘ âŠ¢ {ğ‘¥ : ğµ | ğœ‘1} <: {ğ‘¥ : ğµ | ğœ‘2}

Since (cid:15) âˆƒBT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 âˆ§ ğœ‘2 holds, the following is obtained as expected.

Î“; ğœ‘ âŠ¢ {ğ‘¥ : ğµ | ğœ‘1} . {ğ‘¥ : ğµ | ğœ‘2} { ğœ†ğ‘¥ {ğ‘¥:ğµ |ğœ‘1 }.assert(true); ğ‘¥

â€¢ Case (Sub-Fun).

Î“; ğœ‘ âŠ¢ ğœ5 <: ğœ3

Î“, ğ‘¥ : ğœ5; ğœ‘ âŠ¢ ğœ4 <: ğœ6

Î“; ğœ‘ âŠ¢ ğ‘¥:ğœ3 â†’ ğœ4 <: ğ‘¥:ğœ5 â†’ ğœ6

From the induction hypothesis, there exists ğ‘1 and ğ‘2 such that Î“; ğœ‘ âŠ¢ ğœ5 . ğœ3 { ğ‘1
and Î“, ğ‘¥ : ğœ5; ğœ‘ âŠ¢ ğœ4 . ğœ6 { ğ‘2 hold, and all the assertions in ğ‘1 and ğ‘2 are of the form
assert(true); ğ‘ â€². Since Î“, ğ‘¥ : ğœ3 âŠ“ ğœ5 âŠ‘ Î“, ğ‘¥ : ğœ5 holds, Î“, ğ‘¥ : ğœ3 âŠ“ ğœ5; ğœ‘ âŠ¢ ğœ4 . ğœ6 { ğ‘2
follows. Therefore, Î“; ğœ‘ âŠ¢ ğ‘¥:ğœ3 â†’ ğœ4 . ğ‘¥:ğœ5 â†’ ğœ6 { ğ‘ holds for an ğ‘ such that ğ‘ â‰¡
ğœ†ğ‘“ ğ‘¥:ğœ3â†’ğœ4 .ğœ†ğ‘¥ğœ5 .let ğ‘¥ğœ3âŠ“ğœ5 = ğ‘1 ğ‘¥ in let ğ‘¦ğœ4 = ğ‘“ ğ‘¥ in ğ‘2 ğ‘¦.

(cid:3)

28

[ğ‘£/ğ‘¥]ğ‘

[ğ‘£/ğ‘¥]ğ‘ = ğ‘

Hattori et al.

[ğ‘£/ğ‘¥]ğ‘¦ =

ğ‘£
ğ‘¦
(
[ğ‘£/ğ‘¥] (ğ‘ ğ‘£ â€²) = ( [ğ‘£/ğ‘¥]ğ‘ ) ( [ğ‘£/ğ‘¥]ğ‘£ â€²)

(ğ‘¥ = ğ‘¦)
(ğ‘¥ â‰  ğ‘¦)

[ğ‘£/ğ‘¥] (ğœ†ğ‘¦ğœ .ğ‘ ) = ğœ†ğ‘¦ [ğ‘£/ğ‘¥ ]ğœ .[ğ‘£/ğ‘¥]ğ‘
[ğ‘£/ğ‘¥] (fix(ğ‘“ ğœ, ğ‘¦, ğ‘ )) = fix(ğ‘“ [ğ‘£/ğ‘¥ ]ğœ, ğ‘¦, [ğ‘£/ğ‘¥]ğ‘ )
[ğ‘£/ğ‘¥] (assert(ğœ‘); ğ‘ ) = assert( [ğ‘£/ğ‘¥]ğœ‘); [ğ‘£/ğ‘¥]ğ‘

[ğ‘£/ğ‘¥] (if ğ‘£1 then ğ‘1 else ğ‘2) = if [ğ‘£/ğ‘¥]ğ‘£1 then [ğ‘£/ğ‘¥]ğ‘1 else [ğ‘£/ğ‘¥]ğ‘2
[ğ‘£/ğ‘¥] (let ğ‘¦ğœ = ğ‘1 in ğ‘2) = (let ğ‘¦ [ğ‘£/ğ‘¥ ]ğœ = [ğ‘£/ğ‘¥]ğ‘1 in [ğ‘£/ğ‘¥]ğ‘2)
(We assume variables are appropriately alpha-renamed so that variables at diï¬€erent scopes do
not collide)

ğ‘1 âˆ’â†’ ğ‘2

assert(true); ğ‘ âˆ’â†’ ğ‘
assert(false); ğ‘ âˆ’â†’ error

(ğœ†ğ‘¥ğœ .ğ‘1) ğ‘£ âˆ’â†’ [ğ‘£/ğ‘¥]ğ‘1

(fix(ğ‘“ ğœ, ğ‘¥, ğ‘1)) ğ‘£ âˆ’â†’ [ğ‘£/ğ‘¥, fix(ğ‘“ ğœ, ğ‘¥, ğ‘1)/ğ‘“ ]ğ‘1

ğ‘ ğ‘£ âˆ’â†’ ev(ğ‘, ğ‘£)
let ğ‘¥ğœ = ğ‘£ in ğ‘ âˆ’â†’ [ğ‘£/ğ‘¥]ğ‘

if true then ğ‘1 else ğ‘2 âˆ’â†’ ğ‘1
if false then ğ‘1 else ğ‘2 âˆ’â†’ ğ‘2

ğ¶ [ğ‘1] âˆ’â†’

ğ¶ [ğ‘2]
error

(

(ğ‘1 âˆ’â†’ ğ‘2)
(ğ‘1 âˆ’â†’ error)

ğ¶ (context) ::= (cid:3) | ğ¶ ğ‘ | ğ‘£ ğ¶ | let ğ‘¥ = ğ¶ in ğ‘

Fig. 19. Substitution and reduction of the target language (full version of Figure 8 in paper).

A.4 Type Safety

Lemma 6. Let Base(Î“) and self(ğœ, ğ‘¥) be deï¬ned as follows.

Base(âˆ…) = âˆ…

Base(Î“, ğ‘¥ : {ğ‘¦ : ğµ | ğœ‘}) = Base(Î“), ğ‘¥ : {ğ‘¦ : ğµ | ğœ‘}
Base(Î“, ğ‘¥ : ğ‘¦:ğœ1 â†’ ğœ2) = Base(Î“)

self({ğ‘¥ : ğµ | ğœ‘}, ğ‘¦) = {ğ‘¥ : ğµ | ğœ‘ âˆ§ ğ‘¥ = ğ‘¦}
self(ğ‘¥:ğœ1 â†’ ğœ2, ğ‘¦) = ğ‘¥:ğœ1 â†’ ğœ2

Gradual Tensor Shape Checking

29

Then, Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ implies Base(Î“); ğœ‘ âŠ¢ ğ‘ : ğ‘¥:ğœ1 â†’ self(ğœ2, ğ‘¥) for a variable ğ‘¥ does not occur
in ğœ2.

Proof. By induction on the derivation of Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ .
â€¢ Case (Cast-Base). The derivation must be of the following form (note ğœ1 â‰¡ {ğ‘¥ : ğµ | ğœ‘1} and

ğœ2 â‰¡ {ğ‘¥ : ğµ | ğœ‘2}).

(cid:15) âˆƒBT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 âˆ§ ğœ‘2
(cid:15) âˆ€BT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 â‡’ (ğœ‘ â€² â‡” ğœ‘2)
Î“; ğœ‘ âŠ¢ {ğ‘¥ : ğµ | ğœ‘1} . {ğ‘¥ : ğµ | ğœ‘2} { ğœ†ğ‘¥ {ğ‘¥:ğµ |ğœ‘1 }.assert(ğœ‘ â€²); ğ‘¥

Noting BT(Î“) = BT(Base(Î“)) and Î¦(Î“) = Î¦(Base(Î“)), the following holds.
(cid:15) âˆ€BT(Base(Î“)), ğ‘¥:ğµ.Î¦(Base(Î“)) âˆ§ ğœ‘ âˆ§ ğœ‘1 âˆ§ ğœ‘ â€² âˆ§ ğ‘¦ = ğ‘¥ â‡’ [ğ‘¦/ğ‘¥]ğœ‘2

Therefore, the following proof tree concludes the proof.

Base(Î“), ğ‘¥ : ğœ1; ğœ‘ âˆ§ ğœ‘ â€² âŠ¢ ğ‘¥ : {ğ‘¦ : ğµ | ğ‘¦ = ğ‘¥ }
Base(Î“), ğ‘¥ : ğœ1; ğœ‘ âˆ§ ğœ‘ â€² âŠ¢ {ğ‘¦ : ğµ | ğ‘¦ = ğ‘¥ } <: {ğ‘¦ : ğµ | [ğ‘¦/ğ‘¥]ğœ‘2 âˆ§ ğ‘¦ = ğ‘¥ }
Base(Î“), ğ‘¥ : ğœ1; ğœ‘ âŠ¢ assert(ğœ‘ â€²); ğ‘¥ : {ğ‘¦ : ğµ | [ğ‘¦/ğ‘¥]ğœ‘2 âˆ§ ğ‘¦ = ğ‘¥ }
Base(Î“); ğœ‘ âŠ¢ (ğœ†ğ‘¥ {ğ‘¥:ğµ |ğœ‘1 }.assert(ğœ‘ â€²); ğ‘¥) : ğ‘¥:ğœ1 â†’ {ğ‘¦ : ğµ | [ğ‘¦/ğ‘¥]ğœ‘2 âˆ§ ğ‘¦ = ğ‘¥ }

â€¢ Case (Cast-Fun). The derivation must be of the following form (note ğœ1 â‰¡ ğ‘¥:ğœ3 â†’ ğœ4 and

ğœ2 â‰¡ ğ‘¥:ğœ5 â†’ ğœ6).

Î“; ğœ‘ âŠ¢ ğœ5 . ğœ3 { ğ‘1

Î“, ğ‘¥ : ğœ3 âŠ“ ğœ5; ğœ‘ âŠ¢ ğœ4 . ğœ6 { ğ‘2

Î“; ğœ‘ âŠ¢ ğ‘¥:ğœ3 â†’ ğœ4 . ğ‘¥:ğœ5 â†’ ğœ6
{ ğœ†ğ‘“ ğ‘¥:ğœ3â†’ğœ4 .ğœ†ğ‘¥ğœ5 .(let ğ‘¦ğœ3âŠ“ğœ5 = ğ‘1 ğ‘¥ in let ğ‘§ğœ4 = ğ‘“ ğ‘¦ in ğ‘2 ğ‘§)

The following holds from the induction hypothesis for some variables ğ‘ and ğ‘ that does not
occur in ğœ3 and ğœ6 respectively.

Base(Î“); ğœ‘ âŠ¢ ğ‘1 : ğ‘:ğœ5 â†’ self(ğœ3, ğ‘)
Base(Î“, ğ‘¥ : ğœ3 âŠ“ ğœ5); ğœ‘ âŠ¢ ğ‘2 : ğ‘:ğœ4 â†’ self(ğœ6, ğ‘)
The following proof tree concludes the proof (Î“â€² := Base(Î“), ğ‘“ : (ğ‘¥:ğœ3 â†’ ğœ4), ğ‘¥ : ğœ5).

(1)

(2)

Î 1
Î“â€²; ğœ‘ âŠ¢ ğ‘1 ğ‘¥ : self(ğœ3, ğ‘¥)

Î 2
Î“â€², ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ (let ğ‘§ğœ4 = ğ‘“ ğ‘¦ in ğ‘2 ğ‘§) : ğœ6

Î“â€²; ğœ‘ âŠ¢ (let ğ‘¦ğœ3âŠ“ğœ5 = ğ‘1 ğ‘¥ in let ğ‘§ğœ4 = ğ‘“ ğ‘¦ in ğ‘2 ğ‘§) : ğ‘¥:ğœ5 â†’ ğœ6
Base(Î“); ğœ‘ âŠ¢ ğœ†ğ‘“ ğ‘¥:ğœ3â†’ğœ4 .ğœ†ğ‘¥ğœ5 .(let ğ‘¦ğœ3âŠ“ğœ5 = ğ‘1 ğ‘¥ in let ğ‘§ğœ4 = ğ‘“ ğ‘¦ in
ğ‘2 ğ‘§) : ğ‘“ :(ğ‘¥:ğœ3 â†’ ğœ4) â†’ (ğ‘¥:ğœ5 â†’ ğœ6)

Î 1:

Î 2:

Î“â€²; ğœ‘ âŠ¢ ğ‘1 : ğ‘:ğœ5 â†’ self(ğœ3, ğ‘)

Î“â€²; ğœ‘ âŠ¢ ğ‘¥ : ğœ5

Î“â€²; ğœ‘ âŠ¢ ğ‘1 ğ‘¥ : self(ğœ3, ğ‘¥)

Î 3
Î“â€², ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ ğ‘“ ğ‘¦ : ğœ4

Î“â€², ğ‘¦:self(ğœ3, ğ‘¥), ğ‘§:ğœ4; ğœ‘ âŠ¢ ğ‘2 : ğ‘:ğœ4 â†’ self(ğœ6, ğ‘)
Î“â€², ğ‘¦:self(ğœ3, ğ‘¥), ğ‘§:ğœ4; ğœ‘ âŠ¢ ğ‘§ : ğœ4
Î“â€², ğ‘¦:self(ğœ3, ğ‘¥), ğ‘§:ğœ4; ğœ‘ âŠ¢ ğ‘2 ğ‘§ : self(ğœ6, ğ‘§)
Î“â€², ğ‘¦:self(ğœ3, ğ‘¥), ğ‘§:ğœ4; ğœ‘ âŠ¢ ğ‘2 ğ‘§ : ğœ6

Î“â€², ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ (let ğ‘§ğœ4 = ğ‘“ ğ‘¦ in ğ‘2 ğ‘§) : ğœ6

30

Î 3:

Hattori et al.

Î“â€², ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ ğ‘“ : ğ‘¥:ğœ3 â†’ ğœ4
Î“â€², ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ ğ‘¦ : ğœ3
Î“â€², ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ ğ‘“ ğ‘¦ : [ğ‘¦/ğ‘¥]ğœ4

Î“â€², ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ [ğ‘¦/ğ‘¥]ğœ4 <: ğœ4

Î“â€², ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ ğ‘“ ğ‘¦ : ğœ4

In Î 3, one of the leaves Î“â€², ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ [ğ‘¦/ğ‘¥]ğœ4 <: ğœ4 is proven as follows:
â€“ If ğœ3 is a function type, so is ğœ5, and ğ‘¥ is a variable of function type. Therefore, ğ‘¥ does not

occur in ğœ4, and [ğ‘¦/ğ‘¥]ğœ4 = ğœ4 holds.

â€“ If ğœ3 is a base type, Î¦(Î“â€², ğ‘¦:self(ğœ3, ğ‘¥)) implies ğ‘¦ = ğ‘¥. Therefore,

Î“â€²; ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ [ğ‘¦/ğ‘¥]ğœ4 <: ğœ4 holds.

Also, in Î 2, one of the leaves

Î“â€², ğ‘¦:self(ğœ3, ğ‘¥), ğ‘§:ğœ4; ğœ‘ âŠ¢ ğ‘2 : ğ‘:ğœ4 â†’ self(ğœ6, ğ‘)

(3)

is proven as follows.
â€“ If ğœ3 is a function type, so is ğœ3 âŠ“ ğœ5, and (2) is equivalent to Base(Î“); ğœ‘ âŠ¢ ğ‘2 : ğ‘:ğœ4 â†’

self(ğœ6, ğ‘). Therefore, (3) holds trivially.

â€“ If ğœ3 is a base type, so is ğœ5. Let ğœ3 â‰¡ {ğ‘¥ : ğµ | ğœ‘3} and ğœ5 â‰¡ {ğ‘¥ : ğµ | ğœ‘5}. Then,

Î¦(Î“â€², ğ‘¦:self(ğœ3, ğ‘¥)) is logically equivalent to Î¦(Base(Î“, ğ‘¥:ğœ3 âŠ“ ğœ5)) as follows:

Î¦(Î“â€², ğ‘¦:self(ğœ3, ğ‘¥)) = Î¦(Base(Î“)) âˆ§ ğœ‘5 âˆ§ [ğ‘¦/ğ‘¥]ğœ‘3 âˆ§ ğ‘¦ = ğ‘¥

Î¦(Base(Î“, ğ‘¥:ğœ3 âŠ“ ğœ5)) = Î¦(Base(Î“)) âˆ§ ğœ‘3 âˆ§ ğœ‘5

Therefore, Î“â€², ğ‘¦:self(ğœ3, ğ‘¥); ğœ‘ âŠ¢ ğ‘2 : ğ‘:ğœ4 â†’ self(ğœ6, ğ‘) holds, and so does (3).

(cid:3)

Lemma 7. (Lemma 2 in paper) Î“; ğœ‘ âŠ¢ ğ‘€ { ğ‘ : ğœ implies Î“; ğœ‘ âŠ¢ ğ‘ : ğœ.

Proof. By induction on the derivation of Î“; ğœ‘ âŠ¢ ğ‘€ { ğ‘ : ğœ.
â€¢ Case (CI-App).

Î“; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğ‘¦:ğœ1 â†’ ğœ2

Î“(ğ‘¥) = ğœ3

Î“; ğœ‘ âŠ¢ ğœ3 . ğœ1 { ğ‘2

Î“; ğœ‘ âŠ¢ ğ‘€1 ğ‘¥ { (let ğ‘¥ğœ1 = ğ‘2 ğ‘¥ in ğ‘1 ğ‘¥) : [ğ‘¥/ğ‘¦]ğœ2

From the induction hypothesis and Lemma 1, we obtain the following.

Î“; ğœ‘ âŠ¢ ğ‘1 : ğ‘¦:ğœ1 â†’ ğœ2

Î“; ğœ‘ âŠ¢ ğ‘2 : ğœ3 â†’ ğœ1

Therefore, Î“; ğœ‘ âŠ¢ ğ‘2 ğ‘¥ : ğœ1 holds, and Î“; ğœ‘ âŠ¢ (let ğ‘¥ğœ1 = ğ‘2 ğ‘¥ in ğ‘1 ğ‘¥) : [ğ‘¥/ğ‘¦]ğœ2 is obtained as
expected.
â€¢ Case (CI-Fix).

Î“â€² = Î“, ğ‘“ : (ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥ : ğœ1

Î“â€²; ğœ‘ âŠ¢ ğ‘€ { ğ‘1 : ğœ3

Î“â€²; ğœ‘ âŠ¢ ğœ3 . ğœ2 { ğ‘2

Î“; ğœ‘ âŠ¢ fix(ğ‘“ :(ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥, ğ‘€) { fix(ğ‘“ ğ‘¥:ğœ1â†’ğœ2, ğ‘¥, let ğ‘¦ğœ3 = ğ‘1 in ğ‘2 ğ‘¦) : ğ‘¥:ğœ1 â†’ ğœ2

From the induction hypothesis and Lemma 1, we obtain Î“â€²; ğœ‘ âŠ¢ ğ‘1 : ğœ3 and Î“â€²; ğœ‘ âŠ¢ ğ‘2 :
ğ‘¦:ğœ3 â†’ ğœ2 for some variable ğ‘¦ that does not occur in ğœ2. Therefore, Î“â€²; ğœ‘ âŠ¢ (let ğ‘¦ğœ3 =
ğ‘1 in ğ‘2 ğ‘¦) : ğœ2 holds, and thus Î“; ğœ‘ âŠ¢ fix(ğ‘“ ğ‘¥:ğœ1â†’ğœ2, ğ‘¥, let ğ‘¦ğœ3 = ğ‘1 in ğ‘2 ğ‘¦) : ğ‘¥:ğœ1 â†’ ğœ2
holds as expected.

Gradual Tensor Shape Checking

â€¢ Case (CI-Let).

31

Î“; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğœ1

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘€2 { ğ‘2 : ğœ2

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğœ2 . ğœ { ğ‘3

BT(Î“) âŠ¢wf ğœ

Î“; ğœ‘ âŠ¢ (let ğ‘¥ = ğ‘€1 in ğ‘€2) { (let ğ‘¥ğœ1 = ğ‘1 in let ğ‘¦ğœ2 = ğ‘2 in ğ‘3 ğ‘¦) : ğœ

From the induction hypothesis and Lemma 1, we obtain the following, where ğ‘§ does not
appear in ğœ.

Î“; ğœ‘ âŠ¢ ğ‘1 : ğœ1

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘2 : ğœ2

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘3 : ğ‘§:ğœ2 â†’ ğœ

Therefore, we obtain Î“; ğœ‘ âŠ¢ (let ğ‘¥ğœ1 = ğ‘1 in let ğ‘¦ğœ2 = ğ‘2 in ğ‘3 ğ‘¦) : [ğ‘¦/ğ‘§]ğœ and [ğ‘¦/ğ‘§]ğœ = ğœ
concludes the proof.

â€¢ Case (CI-If).

Î“; ğœ‘ âŠ¢ ğ‘¥ : {ğ‘¥ : bool | ğœ‘ â€²}

Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğ‘€1 { ğ‘1 : ğœ1
Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğ‘€2 { ğ‘2 : ğœ2

Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğœ1 . ğœ { ğ‘3
Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğœ2 . ğœ { ğ‘4

Î“; ğœ‘ âŠ¢ if ğ‘¥ then ğ‘€1 else ğ‘€2
{ if ğ‘¥ then (let ğ‘¦ğœ1 = ğ‘1 in ğ‘3 ğ‘¦) else (let ğ‘¦ğœ2 = ğ‘2 in ğ‘4 ğ‘¦) : ğœ

From the induction hypothesis and Lemma 1, we obtain the following, where ğ‘§ does not
appear in ğœ.

Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğ‘1 : ğœ1
Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğ‘2 : ğœ2

Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğ‘3 : ğ‘§:ğœ1 â†’ ğœ
Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğ‘4 : ğ‘§:ğœ2 â†’ ğœ

Therefore, Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ let ğ‘¦ğœ1 = ğ‘1 in ğ‘3 ğ‘¦ : ğœ and Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ let ğ‘¦ğœ2 = ğ‘2 in ğ‘4 ğ‘¦ : ğœ
holds, and Î“; ğœ‘ âŠ¢ if ğ‘¥ then (let ğ‘¦ğœ1 = ğ‘1 in ğ‘3 ğ‘¦) else (let ğ‘¦ğœ2 = ğ‘2 in ğ‘4 ğ‘¦) : ğœ follows
as expected.

â€¢ Case (CI-Annot).

Î“; ğœ‘ âŠ¢ ğœ1 . ğœ { ğ‘2
Î“; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğœ1
Î“; ğœ‘ âŠ¢ (ğ‘€1 : ğœ) { (let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 ğ‘¥) : ğœ

From the induction hypothesis, Î“; ğœ‘ âŠ¢ ğ‘1 : ğœ1 holds. Also, from Lemma 1, we obtain Î“; ğœ‘ âŠ¢
ğ‘2 : ğ‘¦:ğœ1 â†’ ğœ, where ğ‘¦ does not occur in ğœ. Therefore, Î“; ğœ‘ âŠ¢ (let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 ğ‘¥) : [ğ‘¥/ğ‘¦]ğœ
holds, and [ğ‘¥/ğ‘¦]ğœ = ğœ concludes the proof.

â€¢ Other cases are trivial.

(cid:3)

Definition 1. Substitution of type [ğ‘£/ğ‘¥]ğœ and type environment [ğ‘£/ğ‘¥]Î“ is deï¬ned in Figure 20.

Lemma 8. Î“; ğœ‘ âŠ¢ ğœ <: ğœ â€² and âŠ¢ ğ‘£ : Î“(ğ‘¥) imply [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğœ <: [ğ‘£/ğ‘¥]ğœ â€².

Proof. By induction on Î“; ğœ‘ âŠ¢ ğœ <: ğœ â€².
â€¢ Case (Sub-Base).

(cid:15) âˆ€BT(Î“), ğ‘¦:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 â‡’ ğœ‘2
Î“; ğœ‘ âŠ¢ {ğ‘¦ : ğµ | ğœ‘1} <: {ğ‘¦ : ğµ | ğœ‘2}

Hattori et al.

32

[ğ‘£/ğ‘¥]ğœ

[ğ‘£/ğ‘¥]Î“

[ğ‘£/ğ‘¥]{ğ‘¦ : ğµ | ğœ‘} = {ğ‘¦ : ğµ | [ğ‘£/ğ‘¥]ğœ‘}
[ğ‘£/ğ‘¥] (ğ‘¦:ğœ1 â†’ ğœ2) = ğ‘¦:( [ğ‘£/ğ‘¥]ğœ1) â†’ ( [ğ‘£/ğ‘¥]ğœ2)

[ğ‘£/ğ‘¥]âˆ… = âˆ…
[ğ‘£/ğ‘¥] (Î“, ğ‘¥ : ğœ) = [ğ‘£/ğ‘¥]Î“
[ğ‘£/ğ‘¥] (Î“, ğ‘¦ : ğœ) = ( [ğ‘£/ğ‘¥]Î“),ğ‘¦ : [ğ‘£/ğ‘¥]ğœ

(ğ‘¥ â‰  ğ‘¦)

Fig. 20. Substitution of type and type environment.

We can assume ğ‘¥ â‰  ğ‘¦ w.l.o.g by alpha renaming. If Î“(ğ‘¥) is a function type, ğ‘¥ âˆ‰ dom(BT(Î“))
and ğ‘¥ does not appear in Î¦(Î“), ğœ‘, ğœ‘1 or ğœ‘2. Therefore, BT( [ğ‘£/ğ‘¥]Î“) = BT(Î“) and Î¦( [ğ‘£/ğ‘¥]Î“) =
Î¦(Î“), we obtain âˆ€BT( [ğ‘£/ğ‘¥]Î“), ğ‘¦:ğµ.Î¦( [ğ‘£/ğ‘¥]Î“) âˆ§ [ğ‘£/ğ‘¥]ğœ‘ âˆ§ [ğ‘£/ğ‘¥]ğœ‘1 â‡’ [ğ‘£/ğ‘¥]ğœ‘2. Therefore,
[ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]{ğ‘¦ : ğµ | ğœ‘1} <: [ğ‘£/ğ‘¥]{ğ‘¦ : ğµ | ğœ‘2} holds.
If Î“(ğ‘¥) is a base type, ğ‘¥ âˆˆ dom(BT(Î“)) and dom(BT( [ğ‘£/ğ‘¥]Î“)) = dom(BT(Î“)) \ {ğ‘¥ }. Since ğ‘£
is a closed term, we obtain âˆ€BT( [ğ‘£/ğ‘¥]Î“),ğ‘¦:ğµ.[ğ‘£/ğ‘¥] (Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1) â‡’ [ğ‘£/ğ‘¥]ğœ‘2. Therefore,
[ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ {ğ‘¦ : ğµ | [ğ‘£/ğ‘¥]ğœ‘1} <: {ğ‘¦ : ğµ | [ğ‘£/ğ‘¥]ğœ‘2} holds.

â€¢ Case (Sub-Fun).

Î“; ğœ‘ âŠ¢ ğœ3 <: ğœ1

Î“, ğ‘¦ : ğœ3; ğœ‘ âŠ¢ ğœ2 <: ğœ4

Î“; ğœ‘ âŠ¢ ğ‘¦:ğœ1 â†’ ğœ2 <: ğ‘¦:ğœ3 â†’ ğœ4

We can assume ğ‘¥ â‰  ğ‘¦ w.l.o.g by alpha renaming. From the induction hypothesis, we obtain:

[ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğœ‘3 <: [ğ‘£/ğ‘¥]ğœ‘1
( [ğ‘£/ğ‘¥]Î“), ğ‘¥ : [ğ‘£/ğ‘¥]ğœ3; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğœ2 <: [ğ‘£/ğ‘¥]ğœ4
Therefore, [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥] (ğ‘¦:ğœ1 â†’ ğœ2) <: [ğ‘£/ğ‘¥] (ğ‘¦:ğœ3 â†’ ğœ4) holds as expected.

(cid:3)

Lemma 9. Î“; ğœ‘ âŠ¢ ğ‘ : ğœ and âŠ¢ ğ‘£ : Î“(ğ‘¥) imply [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘ : [ğ‘£/ğ‘¥]ğœ.

Proof. By induction on Î“; ğœ‘ âŠ¢ ğ‘ : ğœ.
â€¢ Case (CT-Const), (CT-Var-Fun) and (CT-Var-Base) is trivial.
â€¢ Case (CT-Lam).

Î“, ğ‘¦ : ğœ1; ğœ‘ âŠ¢ ğ‘1 : ğœ2
Î“; ğœ‘ âŠ¢ ğœ†ğ‘¦ğœ1 .ğ‘1 : ğ‘¦:ğœ1 â†’ ğœ2

We can assume ğ‘¥ â‰  ğ‘¦ by alpha renaming. From the induction hypothesis,

( [ğ‘£/ğ‘¥]Î“),ğ‘¦ : [ğ‘£/ğ‘¥]ğœ1; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘1 : [ğ‘£/ğ‘¥]ğœ2

holds. Therefore, [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ ğœ†ğ‘¦ [ğ‘£/ğ‘¥ ]ğœ1 .[ğ‘£/ğ‘¥]ğ‘1 : ğ‘¦:( [ğ‘£/ğ‘¥]ğœ1) â†’ [ğ‘£/ğ‘¥]ğœ2 holds as ex-
pected.

â€¢ Case (CT-Fix) is similar to the case (CT-Lam).

Gradual Tensor Shape Checking

â€¢ Case (CT-App).

33

Î“; ğœ‘ âŠ¢ ğ‘1 : ğ‘¦:ğœ1 â†’ ğœ2

Î“; ğœ‘ âŠ¢ ğ‘£1 : ğœ1

Î“; ğœ‘ âŠ¢ ğ‘1 ğ‘£1 : [ğ‘£1/ğ‘¦]ğœ2

We assume ğ‘¥ â‰  ğ‘¦ by alpha renaming. From the induction hypothesis, we obtain the follow-
ing.

[ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘1 : ğ‘¦:[ğ‘£/ğ‘¥]ğœ1 â†’ [ğ‘£/ğ‘¥]ğœ2
[ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘£1 : [ğ‘£/ğ‘¥]ğœ1

Therefore, [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ ( [ğ‘£/ğ‘¥]ğ‘1) ( [ğ‘£/ğ‘¥]ğ‘£1) : [[ğ‘£/ğ‘¥]ğ‘£1/ğ‘¦] [ğ‘£/ğ‘¥]ğœ2 holds as expected.

â€¢ Case (CT-Sub).

Î“; ğœ‘ âŠ¢ ğ‘ : ğœ â€²

Î“; ğœ‘ âŠ¢ ğœ â€² <: ğœ

Î“; ğœ‘ âŠ¢ ğ‘ : ğœ

From the induction hypothesis and Lemma 8, we obtain the following.

[ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘ : [ğ‘£/ğ‘¥]ğœ â€²
[ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğœ â€² <: [ğ‘£/ğ‘¥]ğœ

Therefore, [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘ : [ğ‘£/ğ‘¥]ğœ follows as expected.

â€¢ Other cases are trivial from the induction hypothesis.

From now on, we abbreviate âˆ…; true âŠ¢ ğ‘ : ğœ as âŠ¢ ğ‘ : ğœ.

Lemma 10 (Progress). Suppose âŠ¢ ğ‘ : ğœ holds, and ev (ğ‘, ğ‘£) is deï¬ned whenever âŠ¢ ğ‘ ğ‘£ : ğœ holds for

(cid:3)

some ğœ. Then, one of the following holds.

â€¢ ğ‘ is a value.
â€¢ ğ‘ âˆ’â†’ ğ‘ â€² for some ğ‘ â€²
â€¢ ğ‘ âˆ’â†’ error

Proof. By induction on the derivation of âŠ¢ ğ‘ : ğœ.

â€¢ In cases (CT-Const), (CT-Var-Fun), (CT-Var-Base), (CT-Lam) and (CT-Fix), ğ‘ is a value.
â€¢ Case (CT-App).

âŠ¢ ğ‘1 : ğ‘¥:ğœ1 â†’ ğœ2

âŠ¢ ğ‘£ : ğœ1

âŠ¢ ğ‘1 ğ‘£ : [ğ‘£/ğ‘¥]ğœ2

We split cases from the induction hypothesis.
â€“ If ğ‘1 is a value, then ğ‘1 is either a constant, a lambda term, or a recursive function. If ğ‘1 is
a constant ğ‘, then ğ‘ ğ‘£ âˆ’â†’ ev(ğ‘, ğ‘£) holds since ev (ğ‘, ğ‘£) is deï¬ned whenever ğ‘ ğ‘£ is well-typed.
If ğ‘1 is a lambda term or a recursive function, there exists ğ‘ â€² such that ğ‘1 ğ‘£ âˆ’â†’ ğ‘ â€² holds.

â€“ If ğ‘1 âˆ’â†’ ğ‘ â€²
â€“ If ğ‘1 âˆ’â†’ error, then ğ‘1 ğ‘£ âˆ’â†’ error.

1 holds for some ğ‘ â€²

1, then ğ‘1 ğ‘£ âˆ’â†’ ğ‘ â€²

1 ğ‘£.

34

â€¢ Case (CT-Assert).

Hattori et al.

âˆ…; ğœ‘ âŠ¢ ğ‘1 : ğœ
âŠ¢ assert(ğœ‘); ğ‘1 : ğœ

Since ğœ‘ is a closed predicate, ğœ‘ is either true or false. If ğœ‘ â‰¡ true, then assert(ğœ‘); ğ‘1 âˆ’â†’
ğ‘1. Otherwise, ğœ‘ â‰¡ false holds, thus assert(ğœ‘); ğ‘1 âˆ’â†’ error.

â€¢ Case (CT-If).

âŠ¢ ğ‘£ : {ğ‘¥ : bool | ğœ‘}

âˆ…; ğ‘£ âŠ¢ ğ‘1 : ğœ

âˆ…; Â¬ğ‘£ âŠ¢ ğ‘2 : ğœ

âŠ¢ if ğ‘£ then ğ‘1 else ğ‘2 : ğœ

Since ğ‘£ is a closed boolean value, ğ‘£ is either true or false. If ğ‘£ â‰¡ true, then if true then ğ‘1 else ğ‘2 âˆ’â†’
ğ‘1. If ğ‘£ â‰¡ false, then if false then ğ‘1 else ğ‘2 âˆ’â†’ ğ‘2.

â€¢ Case (CT-Let).

âŠ¢ ğ‘1 : ğœ2

ğ‘¥ : ğœ2; true âŠ¢ ğ‘2 : ğœ

âŠ¢ let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 : ğœ

We split cases from the induction hypothesis.
â€“ If ğ‘1 is a value, let ğ‘£1 such that ğ‘1 â‰¡ ğ‘£1. Then, let ğ‘¥ğœ1 = ğ‘£1 in ğ‘2 âˆ’â†’ [ğ‘£1/ğ‘¥]ğ‘2 holds.
â€“ If ğ‘1 âˆ’â†’ ğ‘ â€²
1 in ğ‘2 holds.
â€“ If ğ‘1 âˆ’â†’ error holds, then let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 âˆ’â†’ error.

1, then let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 âˆ’â†’ let ğ‘¥ğœ1ğ‘ â€²

1 holds for some ğ‘ â€²

â€¢ Case (CT-Sub) is immediate from the induction hypothesis.

(cid:3)

Lemma 11 (Preservation). Suppose âŠ¢ ğ‘ ğ‘£ : ğœ implies âŠ¢ ev (ğ‘, ğ‘£) : ğœ for every ğ‘, ğ‘£ and ğœ. Then,

âŠ¢ ğ‘ : ğœ and ğ‘ âˆ’â†’ ğ‘ â€² imply âŠ¢ ğ‘ â€² : ğœ.

Proof. By induction on ğ‘ âˆ’â†’ ğ‘ â€².
â€¢ Case assert(true); ğ‘1 âˆ’â†’ ğ‘1. From the inversion of âŠ¢ assert(true); ğ‘1 : ğœ, it follows that

âŠ¢ ğ‘1 : ğœ.

â€¢ Case (ğœ†ğ‘¥ğœ1 .ğ‘1) ğ‘£ âˆ’â†’ [ğ‘£/ğ‘¥]ğ‘1. The derivation of âŠ¢ (ğœ†ğ‘¥ğœ1 .ğ‘1) ğ‘£ : ğœ must be of the following

form.

âŠ¢ ğ‘£ : ğœ1

ğ‘¥ : ğœ1; true âŠ¢ ğ‘1 : ğœ2
âŠ¢ (ğœ†ğ‘¥ğœ1 .ğ‘1) : ğ‘¥:ğœ1 â†’ ğœ2

âŠ¢ (ğœ†ğ‘¥ğœ1 .ğ‘1) ğ‘£ : [ğ‘£/ğ‘¥]ğœ2
Using Lemma 9, ğ‘¥ : ğœ1; true âŠ¢ [ğ‘£/ğ‘¥]ğ‘1 : [ğ‘£/ğ‘¥]ğœ2 holds. Since ğ‘¥ does not appear freely in
[ğ‘£/ğ‘¥]ğ‘1, this entails âŠ¢ [ğ‘£/ğ‘¥]ğ‘1 : [ğ‘£/ğ‘¥]ğœ2 as expected.

â€¢ Case let ğ‘¥ğœ1 = ğ‘£ in ğ‘1 âˆ’â†’ [ğ‘£/ğ‘¥]ğ‘1 is similar to the previous case.
â€¢ Case (fix(ğ‘“ ğœ1, ğ‘¥, ğ‘1)) ğ‘£ âˆ’â†’ [ğ‘£/ğ‘¥, fix(ğ‘“ ğœ1, ğ‘¥, ğ‘1)/ğ‘£]ğ‘1. The derivation of âŠ¢ (fix(ğ‘“ ğœ1, ğ‘¥, ğ‘1)) ğ‘£ :

ğœ is as follows (note ğœ1 â‰¡ ğ‘¥:ğœ2 â†’ ğœ3).

âŠ¢ ğ‘£ : ğœ2

ğ‘“ : (ğ‘¥:ğœ2 â†’ ğœ3), ğ‘¥ : ğœ2; true âŠ¢ ğ‘1 : ğœ3
âŠ¢ fix(ğ‘“ ğ‘¥:ğœ2â†’ğœ3, ğ‘¥, ğ‘1) : ğ‘¥:ğœ2 â†’ ğœ3

âŠ¢ (fix(ğ‘“ ğ‘¥:ğœ2â†’ğœ3, ğ‘¥, ğ‘1)) ğ‘£ : [ğ‘£/ğ‘¥]ğœ3
Using Lemma 9, ğ‘“ : (ğ‘¥:ğœ2 â†’ ğœ3), ğ‘¥ : ğœ2; true âŠ¢ [ğ‘£/ğ‘¥, fix(ğ‘“ ğœ1, ğ‘¥, ğ‘1)/ğ‘£]ğ‘1 : ğœ3 holds. There-
fore,
âŠ¢ [ğ‘£/ğ‘¥, fix(ğ‘“ ğœ1, ğ‘¥, ğ‘1)/ğ‘£]ğ‘1 : ğœ3 holds as expected.

Gradual Tensor Shape Checking

â€¢ Case ğ‘ ğ‘£ âˆ’â†’ ev (ğ‘, ğ‘£) follows from the assumption.
â€¢ Case if true then ğ‘1 else ğ‘2 âˆ’â†’ ğ‘1 is trivial.
â€¢ Case if false then ğ‘1 else ğ‘2 âˆ’â†’ ğ‘2 is trivial.
â€¢ Other cases are trivial.

35

(cid:3)

Theorem 4 (Type Safety). Suppose âŠ¢ ğ‘ ğ‘£ : ğœ implies âŠ¢ ev (ğ‘, ğ‘£) : ğœ for every ğ‘, ğ‘£ and ğœ. Then,

âˆ…; true âŠ¢ ğ‘€ { ğ‘ : ğœ implies either ğ‘ âˆ’â†’âˆ— ğ‘£, ğ‘ â‡‘ or ğ‘ âˆ’â†’âˆ— error.

Proof. From Lemma 7, âŠ¢ ğ‘ : ğœ holds. Therefore, the result is obtained from Lemma 10 and
(cid:3)

Lemma 11.

A.5 Properties about Precision

ğ‘¥ âŠ¢ ğœ1 âŠ‘ ğœ2 and

Lemma 12.
Lemma 13. (Lemma 3 in paper) Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2, dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ3, dom(Î“) âŠ¢ ğœ2 âŠ‘ ğœ4 and Î“ âŠ‘ Î“â€²

ğ‘¥ âŠ¢ ğœ1 âŠ“ ğœ3 âŠ‘ ğœ2 âŠ“ ğœ4.

ğ‘¥ âŠ¢ ğœ3 âŠ‘ ğœ4 imply

imply Î“â€²; ğœ‘ âŠ¢ ğœ3 . ğœ4.

e

e

e

Proof. By induction on Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2.
â€¢ Case (Cast-Base). The derivation must be of the following form.

(cid:15) âˆƒBT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 âˆ§ ğœ‘2
(cid:15) âˆ€BT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 â‡’ (ğœ‘ â€² â‡” ğœ‘2)
Î“; ğœ‘ âŠ¢ {ğ‘¥ : ğµ | ğœ‘1} . {ğ‘¥ : ğµ | ğœ‘2} { ğœ†ğ‘¥ {ğ‘¥:ğµ |ğœ‘1 }.assert(ğœ‘ â€²); ğ‘¥

Let ğœ‘3 such that ğœ3 â‰¡ {ğ‘¥ : ğµ | ğœ‘3}, ğœ‘4 such that ğœ4 â‰¡ {ğ‘¥ : ğµ | ğœ‘4}, and Î“â€² such that Î“ âŠ‘ Î“â€².
From dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ3, dom(Î“) âŠ¢ ğœ2 âŠ‘ ğœ4 and Î“ âŠ‘ Î“â€², we obtain the following, noting that
only a variable of base type appears in the predicates.
âˆ€BT(Î“), ğ‘¥:ğµ.ğœ‘1 â‡’ ğœ‘3
âˆ€BT(Î“), ğ‘¥:ğµ.ğœ‘2 â‡’ ğœ‘4
âˆ€BT(Î“).Î¦(Î“) â‡’ Î¦(Î“â€²)

Therefore, âˆƒBT(Î“â€²), ğ‘¥:ğµ.Î¦(Î“â€²) âˆ§ ğœ‘ âˆ§ ğœ‘3 âˆ§ ğœ‘4 holds, noting BT(Î“) = BT(Î“â€²). Let ğœ‘ â€²â€² such that
âˆ€BT(Î“â€²), ğ‘¥:ğµ.Î¦(Î“â€²) âˆ§ ğœ‘ âˆ§ ğœ‘3 â‡’ (ğœ‘ â€²â€² â‡” ğœ‘4). Thus, Î“â€²; ğœ‘ âŠ¢ {ğ‘¥ : ğµ | ğœ‘3} . {ğ‘¥ : ğµ | ğœ‘4} {
ğœ†ğ‘¥ {ğ‘¥:ğµ |ğœ‘3 }.assert(ğœ‘ â€²â€²); ğ‘¥ holds as expected.

â€¢ Case (Cast-Fun). The derivation must be of the following form.

Î“; ğœ‘ âŠ¢ ğœ â€²
2

. ğœ â€²
1

{ ğœ†ğ‘“ ğ‘¥:ğœâ€²

1â†’ğœâ€²â€²

1 .ğœ†ğ‘¥ğœâ€²

{ ğ‘1
Î“; ğœ‘ âŠ¢ ğ‘¥:ğœ â€²
2 .(let ğ‘¥ğœâ€²

Î“, ğ‘¥ : ğœ â€²

1 âŠ“ ğœ â€²
2; ğœ‘ âŠ¢ ğœ â€²â€²
1
. ğ‘¥:ğœ â€²
2 â†’ ğœ â€²â€²
2
2 = ğ‘1 ğ‘¥ in let ğ‘¦ğœâ€²â€²

1 â†’ ğœ â€²â€²
1
1âŠ“ğœâ€²

. ğœ â€²â€²
2

{ ğ‘2

1 = ğ‘“ ğ‘¥ in ğ‘2 ğ‘¦)

3, ğœ â€²â€²

3 , ğœ â€²

Let ğœ â€²
and dom(Î“) âŠ¢ ğœ2 âŠ‘ ğœ4, the following holds.

4 such that ğœ3 â‰¡ ğ‘¥:ğœ â€²

4 and ğœ â€²â€²

3 â†’ ğœ â€²â€²

3 and ğœ4 â‰¡ ğ‘¥:ğœ â€²

4 â†’ ğœ â€²â€²

4 . From dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ3

dom(Î“) âŠ¢ ğœ â€²
dom(Î“) âŠ¢ ğœ â€²

1 âŠ‘ ğœ â€²
3
2 âŠ‘ ğœ â€²
4
2 âŠ‘ ğœ â€²

dom(Î“), ğ‘¥ âŠ¢ ğœ â€²â€²
dom(Î“), ğ‘¥ âŠ¢ ğœ â€²â€²

1 âŠ‘ ğœ â€²â€²
3
2 âŠ‘ ğœ â€²â€²
4

Using Lemma 12, dom(Î“) âŠ¢ ğœ â€²
ğœ â€²
1 âŠ“ ğœ â€²
Î“â€², ğ‘¥ : ğœ â€²

2 âŠ‘ Î“â€², ğ‘¥ : ğœ â€²
3 âŠ“ ğœ â€²

4 holds. Let Î“â€² such that Î“ âŠ‘ Î“â€². Then, Î“, ğ‘¥ :
{ ğ‘3 and
{ ğ‘4 hold for some ğ‘3 and ğ‘4. Therefore, we obtain Î“; ğœ‘ âŠ¢

4 holds. From the induction hypothesis, Î“â€²; ğœ‘ âŠ¢ ğœ â€²
. ğœ â€²â€²
4

3 âŠ“ ğœ â€²
4; ğœ‘ âŠ¢ ğœ â€²â€²
3

1 âŠ“ ğœ â€²

3 âŠ“ ğœ â€²

. ğœ â€²
3

4

36

Hattori et al.

ğ‘¥:ğœ â€²
3 â†’ ğœ â€²â€²
expected.

3 . ğ‘¥:ğœ â€²

4 â†’ ğœ â€²â€²
4

{ ğœ†ğ‘“ ğ‘¥:ğœâ€²

3â†’ğœâ€²â€²

3 .ğœ†ğ‘¥ğœâ€²

4 .(let ğ‘¥ğœâ€²

3âŠ“ğœâ€²

4 = ğ‘3 ğ‘¥ in let ğ‘¦ğœâ€²â€²

3 = ğ‘“ ğ‘¥ in ğ‘4 ğ‘¦) as

Lemma 14. (Lemma 4 in paper) Suppose Î“ âŠ‘ Î“â€², dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ â€²
{ ğ‘ â€² implies Î“; ğœ‘ âŠ¢ ğ‘ âŠ‘ ğ‘ â€².
. ğœ â€²
2

Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ and Î“â€²; ğœ‘ âŠ¢ ğœ â€²
1
Proof. By induction on the derivation of Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ .
â€¢ Case (Cast-Base).

1 and dom(Î“) âŠ¢ ğœ2 âŠ‘ ğœ â€²

2. Then,

(cid:3)

(cid:15) âˆƒBT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 âˆ§ ğœ‘2
(cid:15) âˆ€BT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 â‡’ (ğœ‘ â€² â‡” ğœ‘2)
Î“; ğœ‘ âŠ¢ {ğ‘¥ : ğµ | ğœ‘1} . {ğ‘¥ : ğµ | ğœ‘2} { ğœ†ğ‘¥ {ğ‘¥:ğµ |ğœ‘1 }.assert(ğœ‘ â€²); ğ‘¥

From the inversion of dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ â€²
1} and ğœ â€²
ğœ‘ â€²

2 â‰¡ {ğ‘¥ : ğµ | ğœ‘ â€²

1 and ğœ‘ â€²

2} for some ğœ‘ â€²
âˆ€dom(Î“), ğ‘¥ .ğœ‘1 â‡’ ğœ‘ â€²
1

âˆ€dom(Î“), ğ‘¥ .ğœ‘2 â‡’ ğœ‘ â€²
2

1 and dom(Î“) âŠ¢ ğœ2 âŠ‘ ğœ â€²

2, it must be that ğœ â€²

1 â‰¡ {ğ‘¥ : ğµ |

2 where the following holds.

Since the variables of function types cannot be used in the predicates, we can restrict the
quantiï¬ed variables to dom(BT(Î“)) as follows.

âˆ€dom(BT(Î“)), ğ‘¥ .ğœ‘1 â‡’ ğœ‘ â€²
1
âˆ€dom(BT(Î“)), ğ‘¥ .ğœ‘2 â‡’ ğœ‘ â€²
2

(4)

(5)

The derivation of Î“; ğœ‘ âŠ¢ ğœ â€²
1

. ğœ â€²
2

{ ğ‘ â€² must be of the following form.

(cid:15) âˆƒBT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘ â€²

(cid:15) âˆ€BT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘ â€²
1} . {ğ‘¥ : ğµ | ğœ‘ â€²

2} { ğœ†ğ‘¥ {ğ‘¥:ğµ |ğœ‘â€²

Î“; ğœ‘ âŠ¢ {ğ‘¥ : ğµ | ğœ‘ â€²

1 âˆ§ ğœ‘ â€²
2
1 â‡’ (ğœ‘ â€²â€² â‡” ğœ‘ â€²
2)
1 }.assert(ğœ‘ â€²â€²); ğ‘¥

Therefore, we obtain âˆ€BT(Î“), ğ‘¥:ğµ.Î¦(Î“)âˆ§ğœ‘âˆ§ğœ‘1âˆ§ğœ‘ â€² â‡’ ğœ‘ â€²â€² as follows: Assume Î¦(Î“)âˆ§ğœ‘âˆ§ğœ‘1âˆ§ğœ‘ â€².
1 follows from (4), and ğœ‘2 follows from the premise of Î“; ğœ‘ âŠ¢ ğœ1 . ğœ2 { ğ‘ . Therefore,
Then, ğœ‘ â€²
2 is obtained by (5). With the premise of Î“; ğœ‘ âŠ¢ ğœ â€²
ğœ‘ â€²
Thus, we obtain Î“; ğœ‘ âŠ¢ ğ‘ âŠ‘ ğ‘ â€² as follows.

{ ğ‘ â€², we obtain ğœ‘ â€²â€² as expected.

. ğœ â€²
2

1

âˆ€BT(Î“), ğ‘¥:ğµ.Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 âˆ§ ğœ‘ â€² â‡’ ğœ‘ â€²â€²
Î“, ğ‘¥ : {ğ‘¥ : ğµ | ğœ‘1}; ğœ‘ âŠ¢ assert(ğœ‘ â€²); ğ‘¥ âŠ‘ assert(ğœ‘ â€²â€²); ğ‘¥

Î“; ğœ‘ âŠ¢ ğœ†ğ‘¥ {ğ‘¥:ğµ |ğœ‘1 }.assert(ğœ‘ â€²); ğ‘¥ âŠ‘ ğœ†ğ‘¥ {ğ‘¥:ğµ |ğœ‘â€²

1 }.assert(ğœ‘ â€²â€²); ğ‘¥

â€¢ Case (Cast-Fun).

Î“; ğœ‘ âŠ¢ ğœ5 . ğœ3 { ğ‘1

Î“, ğ‘¥ : ğœ3 âŠ“ ğœ5; ğœ‘ âŠ¢ ğœ4 . ğœ6 { ğ‘2

Î“; ğœ‘ âŠ¢ ğ‘¥:ğœ3 â†’ ğœ4 . ğ‘¥:ğœ5 â†’ ğœ6
{ ğœ†ğ‘“ ğ‘¥:ğœ3â†’ğœ4 .ğœ†ğ‘¥ğœ5 .(let ğ‘¥ğœ3âŠ“ğœ5 = ğ‘1 ğ‘¥ in let ğ‘¦ğœ4 = ğ‘“ ğ‘¥ in ğ‘2 ğ‘¦)

Gradual Tensor Shape Checking

37

ğ‘¥ âŠ¢ ğ‘€1 âŠ‘ ğ‘€2

ğ‘¥ âŠ¢ ğ‘ âŠ‘ ğ‘ (PM-Const)

ğ‘¦ âŠ¢ ğ‘¥ âŠ‘ ğ‘¥ (PM-Var)

e

e

ğ‘¦ âŠ¢ ğ‘€1 âŠ‘ ğ‘€2

ğ‘¦ âŠ¢ ğœ1 âŠ‘ ğœ2
e

e
(PM-Annot)

ğ‘¦ âŠ¢ (ğ‘€1 : ğœ1) âŠ‘ (ğ‘€2 : ğœ2)

ğ‘¦ âŠ¢ ğœ1 âŠ‘ ğœ2

ğ‘¦, ğ‘¥ âŠ¢ ğ‘€1 âŠ‘ ğ‘€2

ğ‘¦ âŠ¢ ğœ†ğ‘¥:ğœ1.ğ‘€1 âŠ‘ ğœ†ğ‘¥:ğœ2.ğ‘€2
e
ğ‘¦ âŠ¢ ğ‘€1 âŠ‘ ğ‘€2
ğ‘¦ âŠ¢ ğ‘€1 ğ‘¥ âŠ‘ ğ‘€2 ğ‘¥

e

e

e

e
ğ‘¦, ğ‘¥ âŠ¢ ğ‘€2 âŠ‘ ğ‘€ â€²
ğ‘¦ âŠ¢ ğ‘€1 âŠ‘ ğ‘€ â€²
2
1
e
1 in ğ‘€ â€²
ğ‘¦ âŠ¢ (let ğ‘¥ = ğ‘€1 in ğ‘€2) âŠ‘ (let ğ‘¥ = ğ‘€ â€²
2)
ğ‘¦, ğ‘“ , ğ‘¥ âŠ¢ ğ‘€ âŠ‘ ğ‘€ â€²

e
ğ‘¦ âŠ¢ ğ‘¥:ğœ1 â†’ ğœ2 âŠ‘ ğ‘¥:ğœ3 â†’ ğœ4
e

e

e

ğ‘¦ âŠ¢ fix(ğ‘“ : (ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥, ğ‘€) âŠ‘ fix(ğ‘“ : (ğ‘¥:ğœ3 â†’ ğœ4), ğ‘¥, ğ‘€ â€²)

e

e

ğ‘¦ âŠ¢ ğ‘€1 âŠ‘ ğ‘€ â€²
1

e
ğ‘¦ âŠ¢ ğ‘€2 âŠ‘ ğ‘€ â€²
2

ğ‘¦ âŠ¢ (if ğ‘¥ then ğ‘€1 else ğ‘€2) âŠ‘ (if ğ‘¥ then ğ‘€ â€²

1 else ğ‘€ â€²
2)

e

e

e

Fig. 21. Precision relation over terms (full version of Figure 14 in paper).

(PM-Lam)

(PM-App)

(PM-Let)

(PM-Fix)

(PM-If)

From the inversion of dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ â€²
and ğœ â€²

6 for some ğœ â€²

2 â‰¡ ğ‘¥:ğœ â€²

5 â†’ ğœ â€²

3, ğœ â€²

1 and dom(Î“) âŠ¢ ğœ2 âŠ‘ ğœ â€²

2, it must be that ğœ â€²

1 â‰¡ ğ‘¥:ğœ â€²

3 â†’ ğœ â€²
4

6 where the following holds.

5 and ğœ â€²
4, ğœ â€²
dom(Î“) âŠ¢ ğœ3 âŠ‘ ğœ â€²
3
dom(Î“) âŠ¢ ğœ5 âŠ‘ ğœ â€²
5
dom(Î“), ğ‘¥ âŠ¢ ğœ4 âŠ‘ ğœ â€²
4
dom(Î“), ğ‘¥ âŠ¢ ğœ6 âŠ‘ ğœ â€²
6
{ ğ‘ â€² must be of the following form.

(6)

(7)

(8)

(9)

The derivation of Î“â€²; ğœ‘ âŠ¢ ğœ â€²
1

. ğœ â€²
2

Î“â€²; ğœ‘ âŠ¢ ğœ â€²
5

. ğœ â€²
3

{ ğœ†ğ‘“ ğ‘¥:ğœâ€²

3â†’ğœâ€²

4 .ğœ†ğ‘¥ğœâ€²

Î“â€², ğ‘¥ : ğœ â€²

{ ğ‘ â€²
1
Î“â€²; ğœ‘ âŠ¢ ğ‘¥:ğœ â€²
3 â†’ ğœ â€²
4
3âŠ“ğœâ€²
5 .(let ğ‘¥ğœâ€²
5 = ğ‘ â€²

3 âŠ“ ğœ â€²
5; ğœ‘ âŠ¢ ğœ â€²
4
5 â†’ ğœ â€²
. ğ‘¥:ğœ â€²
6
1 ğ‘¥ in let ğ‘¦ğœâ€²

. ğœ â€²
6

{ ğ‘ â€²
2

With (6) and (7), we obtain Î“; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘ â€²
ğœ3 âŠ“ ğœ5 âŠ‘ Î“â€², ğ‘¥ : ğœ â€²
with (8) and (9). Thus, Î“; ğœ‘ âŠ¢ ğ‘ âŠ‘ ğ‘ â€² follows as expected.

5, we obtain Î“, ğ‘¥ : ğœ3 âŠ“ ğœ5; ğœ‘ âŠ¢ ğ‘2 âŠ‘ ğ‘ â€²

3 âŠ“ ğœ â€²

4 = ğ‘“ ğ‘¥ in ğ‘ â€²

2 ğ‘¦)
1 from the induction hypothesis. Noting Î“, ğ‘¥ :
2 from the induction hypothesis

(cid:3)

A.6 Gradual Guarantee

Figure 21 and Figure 22 presents the full deï¬nition of the precision of terms
precision of cast terms Î“; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘2 respectively.

ğ‘¥ âŠ¢ ğ‘€1 âŠ‘ ğ‘€2 and the

Remark 3. The notation Ëœğ‘¥ \ {ğ‘¦} denotes a sequence of variables that is created by removing ğ‘¦ from

e

Ëœğ‘¥.

Lemma 15. dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ2, ğ‘£1 âŠ‘ ğ‘£2 and âŠ¢ ğ‘£1 : Î“(ğ‘¥) imply (dom(Î“) \ {ğ‘¥ }) âŠ¢ [ğ‘£1/ğ‘¥]ğœ1 âŠ‘

[ğ‘£2/ğ‘¥]ğœ2.

Proof. By induction on Î“ âŠ¢ ğœ1 âŠ‘ ğœ2.

38

Î“; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘2

Hattori et al.

dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ2

Î“; ğœ‘ âŠ¢ ğ‘ âŠ‘ ğ‘

(PC-Const)
Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘2

Î“; ğœ‘ âŠ¢ ğ‘¥ âŠ‘ ğ‘¥

Î“; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘2

(PC-Var)
âˆ…; true âŠ¢ ğ‘£1 âŠ‘ ğ‘£2

Î“; ğœ‘ âŠ¢ ğœ†ğ‘¥ğœ1 .ğ‘1 âŠ‘ ğœ†ğ‘¥ğœ2 .ğ‘2

Î“; ğœ‘ âŠ¢ ğ‘1 ğ‘£1 âŠ‘ ğ‘2 ğ‘£2

(PC-Lam)

dom(Î“) âŠ¢ ğ‘¥:ğœ1 â†’ ğœ2 âŠ‘ ğ‘¥:ğœ â€²

1 â†’ ğœ â€²
2
Î“; ğœ‘ âŠ¢ fix(ğ‘“ ğ‘¥:ğœ1â†’ğœ2, ğ‘¥, ğ‘1) âŠ‘ fix(ğ‘“ ğ‘¥:ğœâ€²

Î“, ğ‘“ : ğ‘¥:ğœ1 â†’ ğœ2, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘2
2, ğ‘¥, ğ‘2)

1â†’ğœâ€²

Î“ âŠ¢ ğ‘1 âŠ‘ ğ‘3

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘2 âŠ‘ ğ‘4

Î“; ğœ‘ âŠ¢ let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 âŠ‘ let ğ‘¥ğœ3 = ğ‘3 in ğ‘4

âˆ…; true âŠ¢ ğ‘£1 âŠ‘ ğ‘£2

Î“; ğœ‘ âˆ§ ğ‘£1 âŠ¢ ğ‘1 âŠ‘ ğ‘3

Î“; ğœ‘ âˆ§ Â¬ğ‘£1 âŠ¢ ğ‘2 âŠ‘ ğ‘4

Î“; ğœ‘ âŠ¢ if ğ‘£1 then ğ‘1 else ğ‘2 âŠ‘ if ğ‘£2 then ğ‘3 else ğ‘4

âˆ€BT(Î“).Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 â‡’ ğœ‘2

Î“; ğœ‘ âˆ§ ğœ‘1 âŠ¢ ğ‘1 âŠ‘ ğ‘2

Î“; ğœ‘ âŠ¢ assert(ğœ‘1); ğ‘1 âŠ‘ assert(ğœ‘2); ğ‘2

Fig. 22. Precision relation of the cast terms (full version of Figure 15 in paper).

(PC-App)

(PC-Fix)

(PC-Let)

(PC-If)

(PC-Assert)

â€¢ Case (Prec-Base).

âˆ€dom(Î“),ğ‘¦.ğœ‘1 â‡’ ğœ‘2
dom(Î“) âŠ¢ {ğ‘¦ : ğµ | ğœ‘1} âŠ‘ {ğ‘¦ : ğµ | ğœ‘2}

We can assume ğ‘¦ â‰  ğ‘¥ w.l.o.g by alpha renaming.
If Î“(ğ‘¥) is a function type, ğ‘¥ does not appear in ğœ‘1 or ğœ‘2. Therefore, the result follows trivially.
If Î“(ğ‘¥) is a base type, ğ‘£1 is a constant, and thus ğ‘£1 = ğ‘£2 follows from ğ‘£1 âŠ‘ ğ‘£2. Therefore,
âˆ€dom(Î“) \ {ğ‘¥ }, ğ‘¦.[ğ‘£1/ğ‘¥]ğœ‘1 â‡’ [ğ‘£2/ğ‘¥]ğœ‘2 follows.

â€¢ Case (Prec-Fun).

dom(Î“) âŠ¢ ğœ3 âŠ‘ ğœ5

dom(Î“), ğ‘¦ âŠ¢ ğœ4 âŠ‘ ğœ6

dom(Î“) âŠ¢ ğ‘¦:ğœ3 â†’ ğœ4 âŠ‘ ğ‘¦:ğœ5 â†’ ğœ6

We can assume ğ‘¦ â‰  ğ‘¥ w.l.o.g by alpha renaming. From the induction hypothesis, the follow-
ing holds.

dom(Î“) \ {ğ‘¥ } âŠ¢ [ğ‘£1/ğ‘¥]ğœ3 âŠ‘ [ğ‘£2/ğ‘¥]ğœ5
(dom(Î“) \ {ğ‘¥ }), ğ‘¦ âŠ¢ [ğ‘£1/ğ‘¥]ğœ3 âŠ‘ [ğ‘£2/ğ‘¥]ğœ5

Therefore, we obtain dom(Î“) \ {ğ‘¥ } âŠ¢ [ğ‘£1/ğ‘¥] (ğ‘¦:ğœ3 â†’ ğœ4) âŠ‘ [ğ‘£2/ğ‘¥] (ğ‘¦:ğœ5 â†’ ğœ6) as expected.

(cid:3)

Lemma 16. Î“; ğœ‘ âŠ¢ ğ‘ âŠ‘ ğ‘ â€², ğ‘£ âŠ‘ ğ‘£ â€² and âŠ¢ ğ‘£ : Î“(ğ‘¥) imply [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘ âŠ‘ [ğ‘£ â€²/ğ‘¥]ğ‘ â€².

Proof. By induction on Î“; ğœ‘ âŠ¢ ğ‘ âŠ‘ ğ‘ â€².
â€¢ Case (PC-Const) is trivial.

Gradual Tensor Shape Checking

39

â€¢ Case (PC-Var). If ğ‘ = ğ‘ â€² = ğ‘¥, then [ğ‘£/ğ‘¥]ğ‘ = ğ‘£ and [ğ‘£ â€²/ğ‘¥]ğ‘ â€² = ğ‘£ â€². Therefore, [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢
[ğ‘£/ğ‘¥]ğ‘ âŠ‘ [ğ‘£ â€²/ğ‘¥]ğ‘ â€² holds from ğ‘£ âŠ‘ ğ‘£ â€². Otherwise, [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘ âŠ‘ [ğ‘£ â€²/ğ‘¥]ğ‘ â€² triv-
ially holds from (PC-Var).

â€¢ Case (PC-Lam).

dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ2

Î“, ğ‘¦ : ğœ1; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘2

Î“; ğœ‘ âŠ¢ ğœ†ğ‘¦ğœ1 .ğ‘1 âŠ‘ ğœ†ğ‘¦ğœ2 .ğ‘2

We can assume ğ‘¥ â‰  ğ‘¦ w.l.o.g by alpha renaming. From the induction hypothesis, ( [ğ‘£/ğ‘¥]Î“), ğ‘¦ :
[ğ‘£/ğ‘¥]ğœ1; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘1 âŠ‘ [ğ‘£ â€²/ğ‘¥]ğ‘2 holds. Also, dom(Î“) \ {ğ‘¥ } âŠ¢ [ğ‘£/ğ‘¥]ğœ1 âŠ‘ [ğ‘£ â€²/ğ‘¥]ğœ2
holds from Lemma 15. Noting dom( [ğ‘£/ğ‘¥]Î“) = dom(Î“) \ {ğ‘¥ }, we obtain [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢
ğœ†ğ‘¦ [ğ‘£/ğ‘¥ ]ğœ1 .[ğ‘£/ğ‘¥]ğ‘1 âŠ‘ ğœ†ğ‘¦ [ğ‘£â€²/ğ‘¥ ]ğœ2 .[ğ‘£ â€²/ğ‘¥]ğ‘2 as expected.

â€¢ Case (PC-Let).

Î“ âŠ¢ ğ‘1 âŠ‘ ğ‘3

Î“, ğ‘¦ : ğœ1; ğœ‘ âŠ¢ ğ‘2 âŠ‘ ğ‘4

Î“; ğœ‘ âŠ¢ let ğ‘¦ğœ1 = ğ‘1 in ğ‘2 âŠ‘ let ğ‘¦ğœ3 = ğ‘3 in ğ‘4

We can assume ğ‘¥ â‰  ğ‘¦ w.l.o.g by alpha renaming. From the induction hypothesis, followings
hold.

[ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘1 âŠ‘ [ğ‘£/ğ‘¥]ğ‘3
( [ğ‘£/ğ‘¥]Î“),ğ‘¦ : [ğ‘£/ğ‘¥]ğœ1; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ [ğ‘£/ğ‘¥]ğ‘2 âŠ‘ [ğ‘£/ğ‘¥]ğ‘4

Therefore,

[ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âŠ¢ (let ğ‘¦ [ğ‘£/ğ‘¥ ]ğœ1 = [ğ‘£/ğ‘¥]ğ‘1 in [ğ‘£/ğ‘¥]ğ‘2) âŠ‘ (let ğ‘¦ [ğ‘£/ğ‘¥ ]ğœ3 = [ğ‘£/ğ‘¥]ğ‘3 in [ğ‘£/ğ‘¥]ğ‘4)

holds as expected.

â€¢ Case (PC-Fix) and (PC-Let) is similar to (PC-Lam).
â€¢ Case (PC-App) and (PC-If) is immediate from the induction hypothesis.
â€¢ Case (PC-Assert).

âˆ€BT(Î“).Î¦(Î“) âˆ§ ğœ‘ âˆ§ ğœ‘1 â‡’ ğœ‘2

Î“; ğœ‘ âˆ§ ğœ‘1 âŠ¢ ğ‘1 âŠ‘ ğ‘2

Î“; ğœ‘ âŠ¢ assert(ğœ‘1); ğ‘1 âŠ‘ assert(ğœ‘2); ğ‘2

From the induction hypothesis, [ğ‘£/ğ‘¥]Î“; [ğ‘£/ğ‘¥]ğœ‘ âˆ§ [ğ‘£/ğ‘¥]ğœ‘1 âŠ¢ [ğ‘£/ğ‘¥]ğ‘1 âŠ‘ [ğ‘£ â€²/ğ‘¥]ğ‘2 holds.
If Î“(ğ‘¥) is a function type, then BT( [ğ‘£/ğ‘¥]Î“) = BT(Î“) and Î¦( [ğ‘£/ğ‘¥]Î“) = Î¦(Î“) holds. Also, ğ‘¥ does
not appear in ğœ‘, ğœ‘1 or ğœ‘2. Therefore, âˆ€BT( [ğ‘£/ğ‘¥]Î“).Î¦( [ğ‘£/ğ‘¥]Î“) âˆ§ [ğ‘£/ğ‘¥]ğœ‘ âˆ§ [ğ‘£/ğ‘¥]ğœ‘1 â‡’ [ğ‘£/ğ‘¥]ğœ‘2
holds.
If Î“(ğ‘¥) is a base type, ğ‘£ = ğ‘£ â€² holds from ğ‘£ âŠ‘ ğ‘£ â€² since ğ‘£ must be a constant. Also, BT( [ğ‘£/ğ‘¥]Î“) =
BT(Î“) \{ğ‘¥ } and Î¦( [ğ‘£/ğ‘¥]Î“) = [ğ‘£/ğ‘¥]Î¦(Î“) holds. Therefore, âˆ€BT( [ğ‘£/ğ‘¥]Î“).Î¦( [ğ‘£/ğ‘¥]Î“) âˆ§ [ğ‘£/ğ‘¥]ğœ‘ âˆ§
[ğ‘£/ğ‘¥]ğœ‘1 â†’ [ğ‘£/ğ‘¥]ğœ‘2 holds.
Therefore, in either cases,

âˆ€BT( [ğ‘£/ğ‘¥]Î“).Î¦( [ğ‘£/ğ‘¥]Î“) âˆ§ [ğ‘£/ğ‘¥]ğœ‘ âˆ§ [ğ‘£/ğ‘¥]ğœ‘1 â‡’ [ğ‘£ â€²/ğ‘¥]ğœ‘2

follows as expected.

(cid:3)

From now on, we abbreviate âˆ…; true âŠ¢ ğ‘1 âŠ‘ ğ‘2 as ğ‘1 âŠ‘ ğ‘2.

As we stated in the paper, we assume the following property for the primitive functions.

40

Hattori et al.

and ğ‘1 âˆ’â†’ ğ‘ â€²

Assumption 3. If ev (ğ‘, ğ‘£2) and ev(ğ‘, ğ‘£1) are both deï¬ned, then ğ‘£1 âŠ‘ ğ‘£2 implies ev (ğ‘, ğ‘£1) âŠ‘ ev (ğ‘, ğ‘£2).
Lemma 17. (Proposition 2 in paper) Suppose âŠ¢ ğ‘1 : ğœ and âŠ¢ ğ‘2 : ğœ â€² for some ğœ and ğœ â€². Then, ğ‘1 âŠ‘ ğ‘2

1 âŠ‘ ğ‘ â€²
2.

1 imply ğ‘2 âˆ’â†’ ğ‘ â€²

2 and ğ‘ â€²
Proof. By induction on ğ‘1 âˆ’â†’ ğ‘ â€²
1.
â€¢ Case assert(true); ğ‘3 âˆ’â†’ ğ‘3. From the inversion of ğ‘1 âŠ‘ ğ‘2, it must be that ğ‘2 â‰¡
assert(true); ğ‘4 for some ğ‘4 where ğ‘3 âŠ‘ ğ‘4. Therefore, assert(true); ğ‘4 âˆ’â†’ ğ‘4 holds.
â€¢ Case (ğœ†ğ‘¥ğœ1 .ğ‘3)ğ‘£1 âˆ’â†’ [ğ‘£1/ğ‘¥]ğ‘3. From the inversion of ğ‘1 âŠ‘ ğ‘2, it must be that ğ‘2 â‰¡
(ğœ†ğ‘¥ğœ2 .ğ‘4) ğ‘£2 for some ğœ2, ğ‘4 and ğ‘£2 where ğœ1 âŠ‘ ğœ2, ğ‘£1 âŠ‘ ğ‘£2 and ğ‘¥ : ğœ1; true âŠ¢ ğ‘3 âŠ‘ ğ‘4.
Also, from the inversion of âŠ¢ (ğœ†ğ‘¥ğœ1 .ğ‘3) ğ‘£1 : ğœ, we obtain âŠ¢ ğ‘£1 : ğœ1. Therefore, by using
Lemma 16, [ğ‘£1/ğ‘¥]ğ‘3 âŠ‘ [ğ‘£2/ğ‘¥]ğ‘4 holds as expected.

â€¢ Case (fix(ğ‘“ ğœ1, ğ‘¥, ğ‘1))ğ‘£1 âˆ’â†’ [ğ‘£1/ğ‘¥, fix(ğ‘“ ğœ1, ğ‘¥, ğ‘1)/ğ‘“ ]ğ‘1. From the inversion of ğ‘1 âŠ‘ ğ‘2, it
must be that ğ‘2 â‰¡ (fix(ğ‘“ ğœ2, ğ‘¥, ğ‘2))ğ‘£2 where fix(ğ‘“ ğœ1, ğ‘¥, ğ‘1) âŠ‘ fix(ğ‘“ ğœ2, ğ‘¥, ğ‘2) and ğ‘£1 âŠ‘ ğ‘£2.
By using Lemma 16, we obtain the following as expected.

[ğ‘£1/ğ‘¥, fix(ğ‘“ ğœ1, ğ‘¥, ğ‘1)/ğ‘“ ]ğ‘1 âŠ‘ [ğ‘£2/ğ‘¥, fix(ğ‘“ ğœ2, ğ‘¥, ğ‘2)/ğ‘“ ]ğ‘2

â€¢ Case ğ‘ ğ‘£1 âˆ’â†’ ev (ğ‘, ğ‘£1). From the inversion of ğ‘1 âŠ‘ ğ‘2, it must be that ğ‘2 â‰¡ ğ‘ ğ‘£2 for some ğ‘£2
where ğ‘£1 âŠ‘ ğ‘£2 holds. Since âŠ¢ ğ‘ ğ‘£2 : ğœ â€² holds, ev(ğ‘, ğ‘£2) is also deï¬ned. Using the property of
ev (Â·, Â·), we obtain ev (ğ‘, ğ‘£1) âŠ‘ ev (ğ‘, ğ‘£2) as expected.

â€¢ Case (let ğ‘¥ğœ1 = ğ‘£1 in ğ‘3) âˆ’â†’ [ğ‘£1/ğ‘¥]ğ‘3. From the inversion of ğ‘1 âŠ‘ ğ‘2, it must be that
ğ‘2 â‰¡ let ğ‘¥ğœ2 = ğ‘£2 in ğ‘4 for some ğœ2, ğ‘£2 and ğ‘4 where ğ‘£1 âŠ‘ ğ‘£2 and ğ‘¥ : ğœ1; true âŠ¢ ğ‘3 âŠ‘ ğ‘4
holds.
Also, we obtain âŠ¢ ğ‘£1 : ğœ3 and ğ‘¥ : ğœ3; true âŠ¢ ğ‘3 âŠ‘ ğ‘4 for some ğœ3 from the inversion of
âŠ¢ (let ğ‘¥ğœ1 = ğ‘£ in ğ‘3) : ğœ. Using Lemma 16, [ğ‘£1/ğ‘¥]ğ‘3 âŠ‘ [ğ‘£2/ğ‘¥]ğ‘4 holds as expected.

â€¢ Case if true then ğ‘3 else ğ‘4 âˆ’â†’ ğ‘3. From the inversion of ğ‘1 âŠ‘ ğ‘2, it must be that
ğ‘2 â‰¡ if true then ğ‘5 else ğ‘6 for some ğ‘5 and ğ‘6 where ğ‘3 âŠ‘ ğ‘5 and ğ‘4 âŠ‘ ğ‘6 holds.

â€¢ Case if false then ğ‘3 else ğ‘4 âˆ’â†’ ğ‘3 is similar to the previous case.
â€¢ Case let ğ‘¥ğœ1 = ğ‘3 in ğ‘4 âˆ’â†’ let ğ‘¥ğœ1 = ğ‘ â€²

3. From the inversion of
ğ‘1 âŠ‘ ğ‘2, it must be that ğ‘2 â‰¡ (let ğ‘¥ğœ2 = ğ‘5 in ğ‘6) where ğ‘3 âŠ‘ ğ‘5 and ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘4 âŠ‘ ğ‘6.
From the induction hypothesis, ğ‘5 âˆ’â†’ ğ‘ â€²
5. Therefore,
let ğ‘¥ğœ2 = ğ‘5 in ğ‘6 âˆ’â†’ let ğ‘¥ğœ2 = ğ‘ â€²
5 in ğ‘6
holds as expected.

5 and ğ‘ â€²
5 in ğ‘6 and let ğ‘¥ğœ1 = ğ‘ â€²

3 in ğ‘4 where ğ‘3 âˆ’â†’ ğ‘ â€²

3 in ğ‘4 âŠ‘ let ğ‘¥ğœ2 = ğ‘ â€²

5 holds for some ğ‘ â€²

3 âŠ‘ ğ‘ â€²

â€¢ Other cases are trivial from the induction hypothesis.

(cid:3)

Lemma 18. (Proposition 3 in paper) Suppose âŠ¢ ğ‘1 : ğœ and âŠ¢ ğ‘2 : ğœ â€² for some ğœ and ğœ â€². Then, ğ‘1 âŠ‘ ğ‘2

and ğ‘2 âˆ’â†’ ğ‘ â€²

2 imply one of the following.
1 âŠ‘ ğ‘ â€²
1 and ğ‘ â€²
2

â€¢ ğ‘1 âˆ’â†’ ğ‘ â€²
â€¢ ğ‘1 âˆ’â†’ error.
Proof. By induction on ğ‘2 âˆ’â†’ ğ‘ â€²
2.
â€¢ Case assert(true); ğ‘4 âˆ’â†’ ğ‘4. From the inversion of ğ‘1 âŠ‘ ğ‘2, it must be that ğ‘1 â‰¡
(assert(ğœ‘); ğ‘3) for some ğœ‘ and ğ‘3 where ğœ‘ â‡’ true and ğ‘3 âŠ‘ ğ‘4. Since ğœ‘ is a closed pred-
icate, ğœ‘ â‰¡ true or ğœ‘ â‰¡ false holds. If ğœ‘ â‰¡ true, then assert(ğœ‘); ğ‘3 âˆ’â†’ ğ‘3 and ğ‘3 âŠ‘ ğ‘4
holds as expected. Otherwise, assert(ğœ‘); ğ‘3 âˆ’â†’ error as expected.

â€¢ Case (ğœ†ğ‘¥ğœ2 .ğ‘4) ğ‘£2 âˆ’â†’ [ğ‘£2/ğ‘¥]ğ‘4. From the inversion of ğ‘1 âŠ‘ ğ‘2, it must be that ğ‘1 â‰¡
(ğœ†ğ‘¥ğœ1 .ğ‘3 ğ‘£1) âˆ’â†’ [ğ‘£1/ğ‘¥]ğ‘3 for some ğœ1, ğ‘£1 and ğ‘3 where ğœ1 âŠ‘ ğœ2, ğ‘£1 âŠ‘ ğ‘£2 and ğ‘¥ : ğœ1; true âŠ¢
ğ‘3 âŠ‘ ğ‘4. By inverting âŠ¢ ğ‘1 : ğœ, we obtain âŠ¢ ğ‘£1 : ğœ1. Therefore, using Lemma 16, [ğ‘£1/ğ‘¥]ğ‘3 âŠ‘
[ğ‘£2/ğ‘¥]ğ‘4 holds as expected.

Gradual Tensor Shape Checking

41

â€¢ Case (fix(ğ‘“ ğœ2, ğ‘¥, ğ‘4)) ğ‘£2 âˆ’â†’ [ğ‘£2/ğ‘¥, fix(ğ‘“ ğœ2, ğ‘¥, ğ‘4)/ğ‘“ ]ğ‘4 is immediate using Lemma 16.
â€¢ Case ğ‘ ğ‘£2 âˆ’â†’ ev (ğ‘, ğ‘£2). From the inversion of ğ‘1 âŠ‘ ğ‘2, it must be that ğ‘1 â‰¡ ğ‘ ğ‘£1 for some
ğ‘£1 where ğ‘£1 âŠ‘ ğ‘£2 holds. Since âŠ¢ ğ‘ ğ‘£1 : ğœ holds, ev(ğ‘, ğ‘£1) is also deï¬ned. Using the property of
ev (Â·, Â·), we obtain ev (ğ‘, ğ‘£1) âŠ‘ ev (ğ‘, ğ‘£2) as expected.

â€¢ Case let ğ‘¥ğœ2 = ğ‘£2 in ğ‘4 âˆ’â†’ [ğ‘£2/ğ‘¥]ğ‘4. From the inversion of ğ‘1 âŠ‘ ğ‘2, it must be that ğ‘1 â‰¡
let ğ‘¥ğœ1 = ğ‘£1 in ğ‘3 for some ğœ1, ğ‘£1 and ğ‘3 where ğœ1 âŠ‘ ğœ2, ğ‘£1 âŠ‘ ğ‘£2 and ğ‘¥ : ğœ1; true âŠ¢ ğ‘3 âŠ‘ ğ‘4.
Also, âŠ¢ ğ‘£1 : ğœ3 and ğ‘¥ : ğœ3; true âŠ¢ ğ‘3 âŠ‘ ğ‘4 holds for some ğœ3 from the inversion of âŠ¢ ğ‘1 : ğœ.
Therefore, from Lemma 16, we obtain [ğ‘£1/ğ‘¥]ğ‘3 âŠ‘ [ğ‘£2/ğ‘¥]ğ‘4 as expected.

â€¢ Other cases are trivial.

(cid:3)

Lemma 19. Î“ âŠ‘ Î“â€², dom(Î“) âŠ¢ ğ‘€ âŠ‘ ğ‘€ â€² and Î“; ğœ‘ âŠ¢ ğ‘€ { ğ‘ : ğœ imply Î“â€²; ğœ‘ âŠ¢ ğ‘€ â€² { ğ‘ â€² : ğœ â€²,

Î“; ğœ‘ âŠ¢ ğ‘ âŠ‘ ğ‘ â€² and dom(Î“) âŠ¢ ğœ âŠ‘ ğœ â€² for some ğ‘ â€² and ğœ â€².

Proof. By induction on the derivation of Î“; ğœ‘ âŠ¢ ğ‘€ âŠ‘ ğ‘€ â€².
â€¢ Case (PM-Lam).

dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ â€²
1

dom(Î“), ğ‘¥ âŠ¢ ğ‘€1 âŠ‘ ğ‘€ â€²
1

dom(Î“) âŠ¢ ğœ†ğ‘¥:ğœ1.ğ‘€1 âŠ‘ ğœ†ğ‘¥:ğœ â€²

1.ğ‘€ â€²
1

The derivation of Î“; ğœ‘ âŠ¢ ğœ†ğ‘¥:ğœ1.ğ‘€1 { ğ‘ : ğœ must be of the following form.

Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğœ2
Î“; ğœ‘ âŠ¢ ğœ†ğ‘¥:ğœ1.ğ‘€1 { ğœ†ğ‘¥:ğœ1.ğ‘1 : ğ‘¥:ğœ1 â†’ ğœ2

Let Î“â€² such that Î“ âŠ‘ Î“â€². Since Î“, ğ‘¥ : ğœ1 âŠ‘ Î“â€², ğ‘¥ : ğœ â€²
hypothesis to obtain Î“â€², ğ‘¥ : ğœ â€²
1 : ğœ â€²
ğœ â€²
1.ğ‘€ â€²
2 for some ğ‘ â€²
1
We conclude by noting dom(Î“) âŠ¢ ğ‘¥:ğœ1 â†’ ğœ2 âŠ‘ ğ‘¥:ğœ â€²

{ ğ‘ â€²
1; ğœ‘ âŠ¢ ğ‘€ â€²
1
2. Therefore, Î“â€²; ğœ‘ âŠ¢ ğœ†ğ‘¥:ğœ â€²

1 and ğœ â€²

{ ğœ†ğ‘¥:ğœ â€²
1 â†’ ğœ â€²
2.

2, Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘ â€²
1.ğ‘ â€²

1 holds, we can apply the induction
1 and dom(Î“), ğ‘¥ âŠ¢ ğœ2 âŠ‘
2 holds as expected.

1 : ğ‘¥:ğœ â€²

1 â†’ ğœ â€²

â€¢ Case (PM-App).

dom(Î“) âŠ¢ ğ‘€1 âŠ‘ ğ‘€ â€²
1
dom(Î“) âŠ¢ ğ‘€1 ğ‘¥ âŠ‘ ğ‘€ â€²
1 ğ‘¥

The derivation of Î“; ğœ‘ âŠ¢ ğ‘€1 ğ‘¥ { ğ‘ : ğœ must be of the following form.

Î“; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğ‘¦:ğœ1 â†’ ğœ2

Î“(ğ‘¥) = ğœ3

Î“; ğœ‘ âŠ¢ ğœ3 . ğœ1 { ğ‘2

Î“; ğœ‘ âŠ¢ ğ‘€1 ğ‘¥ { (let ğ‘¦ğœ1 = ğ‘2 ğ‘¥ in ğ‘1 ğ‘¦) : [ğ‘¥/ğ‘¦]ğœ2

Let Î“â€² such that Î“ âŠ‘ Î“â€². From the induction hypothesis, Î“â€²; ğœ‘ âŠ¢ ğ‘€ â€²
1 â†’ ğœ â€²
1 : ğ‘¦:ğœ â€²
2,
1
Î“; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘ â€²
1 and dom(Î“) âŠ¢ ğ‘¦:ğœ1 â†’ ğœ2 âŠ‘ ğœ â€² holds for some ğ‘ â€²
1 and ğœ â€². By inverting
dom(Î“) âŠ¢ ğ‘¦:ğœ1 â†’ ğœ2 âŠ‘ ğœ â€², it must be that ğœ â€² â‰¡ ğ‘¦:ğœ â€²
2 where dom(Î“) âŠ¢
1 and ğœ â€²
2. Also, Î“â€²(ğ‘¥) = ğœ â€²
ğœ1 âŠ‘ ğœ â€²
3 âŠ‘ ğœ3 holds for some ğœ â€²
3
from Î“ âŠ‘ Î“â€².
From Lemma 3 and Lemma 4, we obtain Î“â€²; ğœ‘ âŠ¢ ğœ â€²
ğ‘2 âŠ‘ ğ‘ â€²

1 â†’ ğœ â€²
2 for some ğœ â€²
3 and dom(Î“) âŠ¢ ğœ â€²

1 and dom(Î“), ğ‘¦ âŠ¢ ğœ2 âŠ‘ ğœ â€²

2 where Î“; ğœ‘ âŠ¢

2 for some ğ‘ â€²

3 . ğœ â€²
1

2 holds. Therefore,

{ ğ‘ â€²

{ ğ‘ â€²

Î“â€²; ğœ‘ âŠ¢ ğ‘€ â€²

1 ğ‘¥ { (let ğ‘¦ğœâ€²

1 = ğ‘ â€²

2 ğ‘¥ in ğ‘ â€²

1 ğ‘¦) : [ğ‘¥/ğ‘¦]ğœ â€²
2

42

Hattori et al.

follows. We conclude by noting dom(Î“) âŠ¢ [ğ‘¥/ğ‘¦]ğœ2 âŠ‘ [ğ‘¥/ğ‘¦]ğœ â€²
ğœ1 and ğœ3 are the same, and the following.

2 since the underlying types for

Î“; ğœ‘ âŠ¢ (let ğ‘¦ğœ1 = ğ‘2 ğ‘¥ in ğ‘1 ğ‘¦) âŠ‘ (let ğ‘¦ğœâ€²

1 = ğ‘ â€²

2 ğ‘¥ in ğ‘ â€²

1 ğ‘¦)

â€¢ Case (PM-Let).

dom(Î“) âŠ¢ ğ‘€1 âŠ‘ ğ‘€ â€²
1

dom(Î“) âŠ¢ (let ğ‘¥ğœ1 = ğ‘€1 in ğ‘€2) âŠ‘ (let ğ‘¥ğœâ€²

dom(Î“), ğ‘¥ âŠ¢ ğ‘€2 âŠ‘ ğ‘€ â€²
2
1 in ğ‘€ â€²
2)

1 = ğ‘€ â€²

The derivation of Î“; ğœ‘ âŠ¢ let ğ‘¥ğœ1 = ğ‘€1 in ğ‘€2 { ğ‘ : ğœ must be f the following form.

Î“; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğœ1

Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ2 . ğœ { ğ‘3

Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘€2 { ğ‘2 : ğœ2
BT(Î“) âŠ¢wf ğœ

Î“; ğœ‘ âŠ¢ (let ğ‘¥ğœ1 = ğ‘€1 in ğ‘€2) { (let ğ‘¥ğœ1 = ğ‘1 in let ğ‘¦ğœ2 = ğ‘2 in ğ‘3 ğ‘¦) : ğœ

1, ğ‘ â€²

{ ğ‘ â€²

2 : ğœ â€²

2 for some ğ‘ â€²

Let Î“â€² such that Î“ âŠ‘ Î“â€². From the induction hypothesis, Î“â€² âŠ¢ ğ‘€ â€²
1
2, ğœ â€²
ğ‘€ â€²
2
1 and dom(Î“), ğ‘¥ âŠ¢ ğœ2 âŠ‘ ğœ â€²
dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ â€²
2 . ğœ { ğ‘ â€²
Î“â€², ğ‘¥ : ğœâˆ’1â€²; ğœ‘ âŠ¢ ğœ â€²
3 for some ğ‘ â€²
Î“, ğ‘¥ : ğœ1 âŠ‘ Î“â€², ğ‘¥ : ğœ â€²
1. Therefore,
Î“; ğœ‘ âŠ¢ (let ğ‘¥ğœâ€²
1 = ğ‘€ â€²

2 where Î“; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘ â€²

{ ğ‘ â€²
1 and Î“â€², ğ‘¥ : ğœ â€²
1; ğœ‘ âŠ¢
1, Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘2 âŠ‘ ğ‘ â€²
2,
2. From Lemma 13 and Lemma 4, we obtain
3 where Î“, ğ‘¥ : ğœ1; ğœ‘ âŠ¢ ğ‘3 âŠ‘ ğ‘ â€²
3 holds, since

1 and ğœ â€²

2 = ğ‘ â€²

1 = ğ‘ â€²

1 : ğœ â€²

2) { (let ğ‘¥ğœâ€²

1 in let ğ‘¦ğœâ€²

1 in ğ‘€ â€²

2 in ğ‘ â€²

3 ğ‘¦) : ğœ

holds as expected. We conclude by noting
Î“; ğœ‘ âŠ¢ (let ğ‘¥ğœ1 = ğ‘1 in let ğ‘¦ğœ2 = ğ‘2 in ğ‘3 ğ‘¦) âŠ‘ (let ğ‘¥ğœâ€²

1 = ğ‘ â€²

1 in let ğ‘¦ğœâ€²

2 = ğ‘ â€²

2 in ğ‘ â€²

3 ğ‘¦)

â€¢ Case (PM-Fix).

dom(Î“), ğ‘“ , ğ‘¥ âŠ¢ ğ‘€1 âŠ‘ ğ‘€ â€²
1
dom(Î“) âŠ¢ fix(ğ‘“ : (ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥, ğ‘€1) âŠ‘ fix(ğ‘“ : (ğ‘¥:ğœ â€²

dom(Î“) âŠ¢ ğ‘¥:ğœ1 â†’ ğœ2 âŠ‘ ğ‘¥:ğœ â€²
1 â†’ ğœ â€²

1 â†’ ğœ â€²
2
2), ğ‘¥, ğ‘€ â€²
1)

The derivation of Î“; ğœ‘ âŠ¢ fix(ğ‘“ : (ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥, ğ‘€1) { ğ‘ : ğœ must be of the following form.
(Note ğœ â‰¡ ğ‘¥:ğœ1 â†’ ğœ2)

Î“1 = Î“, ğ‘“ : (ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥ : ğœ1

Î“1; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğœ3

Î“1; ğœ‘ âŠ¢ ğœ3 . ğœ2 { ğ‘2

Î“; ğœ‘ âŠ¢ fix(ğ‘“ : (ğ‘¥:ğœ1 â†’ ğœ2), ğ‘¥, ğ‘€1) { fix(ğ‘“ ğ‘¥:ğœ1â†’ğœ2, ğ‘¥, let ğ‘¦ğœ3 = ğ‘1 in ğ‘2 ğ‘¦) : ğ‘¥:ğœ1 â†’ ğœ2

= Î“, ğ‘“ : (ğ‘¥:ğœ â€²
{ ğ‘ â€²
1 : ğœ â€²

Let Î“â€² such that Î“ âŠ‘ Î“â€², and Î“â€²
1
induction hypothesis, Î“â€²
1 ; ğœ‘ âŠ¢ ğ‘€ â€²
1
and dom(Î“), ğ‘“ , ğ‘¥ âŠ¢ ğœ3 âŠ‘ ğœ â€²
(PM-Fix). Using Lemma 13 and Lemma 4, Î“â€²
Î“; ğœ‘ âŠ¢ ğ‘2 âŠ‘ ğ‘ â€²
2 holds. Therefore,
2), ğ‘¥, ğ‘€ â€²
1 â†’ ğœ â€²

1) { fix(ğ‘“ ğ‘¥:ğœâ€²

3. Also, dom(Î“), ğ‘“ , ğ‘¥ âŠ¢ ğœ2 âŠ‘ ğœ â€²

1 ; ğœ‘ âŠ¢ ğœ â€²
3

. ğœ â€²
2

1 â†’ ğœ â€²

2), ğ‘¥ : ğœ â€²

3 holds for some ğ‘ â€²

Î“â€²; ğœ‘ âŠ¢ fix(ğ‘“ : (ğ‘¥:ğœ â€²
holds as expected. We conclude by noting dom(Î“) âŠ¢ ğ‘¥:ğœ1 â†’ ğœ2 âŠ‘ ğ‘¥:ğœ â€²
2, ğ‘¥, let ğ‘¦ğœâ€²
Î“; ğœ‘ âŠ¢ fix(ğ‘“ ğ‘¥:ğœ1â†’ğœ2, ğ‘¥, let ğ‘¦ğœ3 = ğ‘1 in ğ‘2 ğ‘¦) âŠ‘ fix(ğ‘“ ğ‘¥:ğœâ€²

3 = ğ‘ â€²

2, ğ‘¥, let ğ‘¦ğœâ€²

1â†’ğœâ€²

1â†’ğœâ€²

2 ğ‘¦) : ğ‘¥:ğœ â€²
2 and
1 in ğ‘ â€²

1 â†’ ğœ â€²
3 = ğ‘ â€²

1 in ğ‘ â€²

2 ğ‘¦)

1 â†’ ğœ â€²
2

1. Then, Î“1 âŠ‘ Î“â€²

1 holds. From the
3 where Î“1; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘ â€²
1 and ğœ â€²
1
2 holds from the assumption of
{ ğ‘ â€²
2 holds for some ğ‘ â€²
2 where

Gradual Tensor Shape Checking

â€¢ Case (PM-If).

43

dom(Î“) âŠ¢ ğ‘€1 âŠ‘ ğ‘€ â€²
1

dom(Î“) âŠ¢ ğ‘€2 âŠ‘ ğ‘€ â€²
2
dom(Î“) âŠ¢ (if ğ‘¥ then ğ‘€1 else ğ‘€2) âŠ‘ (if ğ‘¥ then ğ‘€ â€²
1 else ğ‘€ â€²
2)

The derivation of Î“; ğœ‘ âŠ¢ if ğ‘¥ then ğ‘€1 else ğ‘€2 : ğœ must be of the following form.

Î“; ğœ‘ âŠ¢ ğ‘¥ : {ğ‘£ : bool | ğœ‘ â€²}

Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğ‘€1 { ğ‘1 : ğœ1
Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğ‘€2 { ğ‘2 : ğœ2

Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğœ1 . ğœ { ğ‘3
Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğœ2 . ğœ { ğ‘4

Î“; ğœ‘ âŠ¢ if ğ‘¥ then ğ‘€1 else ğ‘€2
{ if ğ‘¥ then (let ğ‘¦ğœ1 = ğ‘1 in ğ‘3 ğ‘¦) else (let ğ‘¦ğœ2 = ğ‘2 in ğ‘4 ğ‘¦) : ğœ

Let Î“â€² such that Î“ âŠ‘ Î“â€². We obtain the following from the induction hypothesis.
1 : ğœ â€²
1
2 : ğœ â€²
2

Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğ‘1 âŠ‘ ğ‘ â€²
1
Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğ‘2 âŠ‘ ğ‘ â€²
2

{ ğ‘ â€²
Î“â€²; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğ‘€ â€²
1
{ ğ‘ â€²
Î“â€²; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğ‘€ â€²
2
dom(Î“â€²) âŠ¢ ğœ1 âŠ‘ ğœ â€²
1

Using Lemma 13, Î“â€²; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğœ â€²
1
and ğ‘ â€²
obtain

4. From Lemma 4, Î“; ğœ‘ âˆ§ ğ‘¥ âŠ¢ ğ‘3 âŠ‘ ğ‘ â€²

. ğœ { ğ‘ â€²

dom(Î“â€²) âŠ¢ ğœ2 âŠ‘ ğœ â€²
2
. ğœ { ğ‘ â€²
3 and Î“â€²; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğœ â€²

3 and Î“; ğœ‘ âˆ§ Â¬ğ‘¥ âŠ¢ ğ‘4 âŠ‘ ğ‘ â€²

2

4 holds for some ğ‘ â€²
3
4 holds. Therefore, we

{ if ğ‘¥ then (let ğ‘¦ğœâ€²
as expected. We conclude by noting

1 = ğ‘ â€²

Î“â€²; ğœ‘ âŠ¢ if ğ‘¥ then ğ‘€ â€²
1 in ğ‘ â€²

1 else ğ‘€ â€²
2
3 ğ‘¦) else (let ğ‘¦ğœâ€²

2 = ğ‘ â€²

2 in ğ‘ â€²

4 ğ‘¦) : ğœ

Î“; ğœ‘ âŠ¢ if ğ‘¥ then (let ğ‘¦ğœ1 = ğ‘1 in ğ‘3 ğ‘¦) else (let ğ‘¦ğœ2 = ğ‘2 in ğ‘4 ğ‘¦)

âŠ‘ if ğ‘¥ then (let ğ‘¦ğœâ€²

1 = ğ‘ â€²

1 in ğ‘ â€²

3 ğ‘¦) else (let ğ‘¦ğœâ€²

2 = ğ‘ â€²

2 in ğ‘ â€²

4 ğ‘¦)

â€¢ Case (PM-Annot).

dom(Î“) âŠ¢ ğ‘€1 âŠ‘ ğ‘€ â€²
1
dom(Î“) âŠ¢ (ğ‘€1 : ğœ) âŠ‘ (ğ‘€ â€²

dom(Î“) âŠ¢ ğœ âŠ‘ ğœ â€²
1 : ğœ â€²)

The derivation of Î“; ğœ‘ âŠ¢ (ğ‘€1 : ğœ) { ğ‘ : ğœ must be of the following form.

Î“; ğœ‘ âŠ¢ ğœ1 . ğœ { ğ‘2
Î“; ğœ‘ âŠ¢ ğ‘€1 { ğ‘1 : ğœ1
Î“; ğœ‘ âŠ¢ (ğ‘€1 : ğœ) { (let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 ğ‘¥) : ğœ

1 where dom(Î“) âŠ¢ ğœ1 âŠ‘ ğœ â€²

Let Î“â€² such that Î“ âŠ‘ Î“â€². From the induction hypothesis, Î“â€²; ğœ‘ âŠ¢ ğ‘€ â€²
1
ğ‘ â€²
1 and ğœ â€²
we have Î“â€²; ğœ‘ âŠ¢ ğœ â€²
2 for some ğ‘ â€²
obtain Î“â€²; ğœ‘ âŠ¢ (ğ‘€ â€²
1 = ğ‘ â€²
Î“; ğœ‘ âŠ¢ (let ğ‘¥ğœ1 = ğ‘1 in ğ‘2 ğ‘¥) âŠ‘ (let ğ‘¥ğœâ€²

{ ğ‘ â€²
1 for some
1. Using Lemma 13 and Lemma 4,
2 holds. Therefore, we
2 ğ‘¥) : ğœ â€² as expected. We conclude by noting

1 . ğœ â€² { ğ‘ â€²
1 : ğœ â€²) { (let ğ‘¥ğœâ€²

2 where Î“; ğœ‘ âŠ¢ ğ‘2 âŠ‘ ğ‘ â€²

1 and Î“; ğœ‘ âŠ¢ ğ‘1 âŠ‘ ğ‘ â€²

1 in ğ‘ â€²
1 = ğ‘ â€²

1 : ğœ â€²

1 in ğ‘ â€²

2 ğ‘¥).

(cid:3)

