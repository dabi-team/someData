0
2
0
2

t
c
O
2
2

]

G
L
.
s
c
[

2
v
5
9
0
8
0
.
7
0
0
2
:
v
i
X
r
a

Synthesize, Execute and Debug: Learning to Repair
for Neural Program Synthesis

Kavi Gupta
UC Berkeley
kavi@berkeley.edu

Peter Ebert Christensen ∗
Technical University of Denmark
pebch@dtu.dk

Xinyun Chen*
UC Berkeley
xinyun.chen@berkeley.edu

Dawn Song
UC Berkeley
dawnsong@cs.berkeley.edu

Abstract

The use of deep learning techniques has achieved signiﬁcant progress for program
synthesis from input-output examples. However, when the program semantics
become more complex, it still remains a challenge to synthesize programs that are
consistent with the speciﬁcation. In this work, we propose SED, a neural program
generation framework that incorporates synthesis, execution, and debugging stages.
Instead of purely relying on the neural program synthesizer to generate the ﬁnal
program, SED ﬁrst produces initial programs using the neural program synthesizer
component, then utilizes a neural program debugger to iteratively repair the gener-
ated programs. The integration of the debugger component enables SED to modify
the programs based on the execution results and speciﬁcation, which resembles
the coding process of human programmers. On Karel, a challenging input-output
program synthesis benchmark, SED reduces the error rate of the neural program
synthesizer itself by a considerable margin, and outperforms the standard beam
search for decoding.

1

Introduction

Program synthesis is a fundamental problem that has attracted a lot of attention from both the artiﬁcial
intelligence and programming languages community, with the goal of generating a program that
satisﬁes the given speciﬁcation [17, 10]. One of the most popular forms of speciﬁcations is to provide
a few examples of program inputs and the desired outputs, which has been studied in various domains,
including string manipulation [10, 5] and graphics applications [8, 7].

There has been an emerging line of work studying deep learning techniques for program synthesis
from input-output examples [5, 29, 2, 3]. Some recent work demonstrate that a large performance
gain can be achieved by properly leveraging the execution results to guide the program synthesis
process [23, 27, 31, 3, 7]. In particular, in [3, 31, 7], they propose to make predictions based on
the intermediate results obtained by executing the partially generated programs. This scheme is
well-suited for sequential programming tasks [31, 7]; however, for programs that are loop-containing,
the execution results of partial programs are not always informative. For example, in [3], to execute
a partial while loop, its body is only executed once [3], making it effectively equivalent to an if
statement. Furthermore, existing work on program synthesis generate the entire program from scratch
without further editing, even if the predicted program is already inconsistent with the input-output
speciﬁcation and thus incorrect. On the contrary, after observing wrong program outputs, human

∗Equal contribution. Work was done when Peter was visiting UC Berkeley.

34th Conference on Neural Information Processing Systems (NeurIPS 2020), Vancouver, Canada.

 
 
 
 
 
 
programmers would go through the written code and attempt to ﬁx the program fragments that cause
the issue.

Inspired by the trial-and-error human coding procedure, we propose SED, which augments existing
neural program synthesizers with a neural debugger component to repair the generated programs.
Given the input-output speciﬁcation, SED ﬁrst synthesizes candidate programs with a neural program
generation model. Next, SED executes the predicted programs and see if any of them satisﬁes the
input-output examples. If none of them does, SED proceeds into the debugging stage, where it selects
the most promising program from the candidates, then generates editing operations with a neural
network component acting as the debugger. The neural program debugger iteratively modiﬁes the
program until it passes the speciﬁcation or reaches the maximal number of editing iterations. Besides
the syntactic information of candidate programs as token sequences, our debugger also leverages the
semantic information provided by their execution traces, which facilitates it to ﬁx the semantic errors.

We evaluate SED on Karel benchmark [2, 4], where the programs satisfying input-output examples
could include control ﬂow constructs such as conditionals and loops. With different choices of the
neural program synthesis model, SED consistently improves the performance of the synthesizer itself
by a considerable margin. Meanwhile, when the synthesizer performs the greedy decoding and only
provides a single program for editing, SED outperforms the standard beam search applied to the
synthesizer, which further demonstrates the effectiveness of our SED framework.

2 Problem Setup

In this section, we present the setup of the input-output program synthesis problem, which is the
main focus of this work. We will also introduce the program repair problem handled by our neural
debugger component.

Program synthesis from input-output examples. In a standard input-output program synthesis
k=1 (or {IOK}
problem [5, 2], the synthesizer is provided with a set of input-output pairs {(ik, ok)}K
in short), which serves as the speciﬁcation of the desired program semantics. Let the ground truth
program be P (cid:63), the goal of the program synthesizer is to generate a program P in a domain-speciﬁc
language (DSL) L, so that for any valid input i(cid:48), P (i(cid:48)) = P (cid:63)(i(cid:48)) = o(cid:48). In practice, besides {IOK},
usually another set of “held out” input-output examples {IOKtest }test is generated to verify the
equivalence between the generated and ground truth programs, which could be imprecise due to the
typically small test set.

Program repair with input-output speciﬁcation. In our program repair setting, besides the same
input-output speciﬁcation given for the synthesis problem above, a buggy program P (cid:48) is also provided,
which is inconsistent with the speciﬁcation. The goal is to perform editing operations, so that the
modiﬁed program becomes correct.

Intuitively, program repair is no more difﬁcult than the program synthesis problem, as the editing
process can completely remove the provided program P (cid:48) and synthesize a new program. However, it
is usually beneﬁcial to utilize P (cid:48), especially when it is close to a correct program [25].

Karel domain. The Karel programming language goes back to the 1980’s as an introductory language
for Stanford CS students [21], and some recent work have proposed deep learning approaches with
this domain as a test bed [2, 23, 3, 25, 24]. A program in this language describes the movements of a
robot inside a 2D grid world, and we present a sample program in Figure 1. In the grids, the arrows
represent the robot, the grey cells are obstacles that can not be manipulated, and the dots are markers.
Besides an action set for the robot, Karel language also includes control ﬂow constructs, i.e., if,
repeat and while. The full grammar speciﬁcation is discussed in Appendix B.

3 SED: Synthesize, Execute and Debug

In this section, we demonstrate SED, which learns to debug for neural program synthesis. In the
synthesis phase, SED uses a neural program synthesizer to produce candidate programs. When the
programs do not satisfy the speciﬁcation according to the execution results, a debugging phase is
required before providing the ﬁnal program for evaluation. Figure 1 provides an example of how SED
works. In the following, we ﬁrst present the neural network architecture, then describe the training
and inference procedures.

2

Figure 1: A sample debugging process of SED. Given the input-output examples, the synthesizer
provides a wrong program that misses the repeat-loop in the ground truth. Our debugger then
performs a series of edits, which results in a correct program. Note that the INSERT operation does
not advance the pointer in the input program, so several edits are applied to the move token.

3.1 Synthesizer

Our SED framework is largely agnostic to the choice of the synthesizer, as long as it achieves
non-trivial prediction performance, thus it is beneﬁcial to leverage its predicted programs for the
debugger component. In particular, SED is compatible with existing neural program synthesis models
that largely employ the encoder-decoder architectures [2, 3, 5]. A common model architecture for
input-output program synthesis includes an encoder to embed the input-output pairs, which could
be an LSTM for string manipulation tasks [5], or a convolutional neural network for our Karel
task [2, 3, 23]. Then, an LSTM decoder generates the program based on the input embedding.

3.2 Debugger

Figure 2: The neural debugger model in SED. The encoder consists of three parts: (1) IOEmbed
for I/O embedding; (2) TraceEmbed that convolves the traces with their corresponding I/O pairs;
and (3) ProgramEncoder that jointly embeds each program token with its corresponding exe-
cution steps in the trace. EditDecoder is used for generating edits. We outline our proposed
TraceEmbed component in red dots, which is the key architectural difference compared to [25].
Note: We use the light blue and green squares to indicate that the same values are passed into the
edit decoder at every step.

We present the debugger architecture in Figure 2. We follow previous work for Karel domain to use
a convolutional neural network for I/O embedding, a bi-directional LSTM to encode the program

3

for debugging, and an LSTM to sequentially generate the edit operation for each input program
token [25]. The debugger supports 4 types of edit operations: KEEP copies the current program
token to the output; DELETE removes the current program token; INSERT[t] adds a program token
t; and REPLACE[t] replaces the current program token with t. Therefore, the total number of edit
operations is 2|V | + 2, where |V | is the Karel vocabulary size. For KEEP, REPLACE and DELETE,
the LSTM moves on to process the next program token after the current edit operation, while for
INSERT, the next edit operation still based on the current program token, as shown in Figure 1.

The input program serves as a cue to the desired syntactic structure; however, it may not be sufﬁcient
to reveal the semantic errors. Motivated by the breakpoint support in Integrated Development
Environments (IDEs) for debugging, we propose an execution trace embedding technique and
incorporate it into the original debugger architecture, as highlighted in Figure 2. Speciﬁcally, we ﬁrst
execute the input program on each input grid iu, and obtain the execution trace eu,0, ..., eu,t, ..., eu,T ,
where u ∈ {1, 2, ..., K}. For each state eu,t, we use a convolutional neural network for embedding:

te(u,t) = TraceEmbed([eu,t; iu; ou])

(1)

Where [a; b] means the concatenation of vectors a and b.

To better represent the correspondence between each program token and the execution states it affects,
we construct a bipartite graph E ⊆ G × I, where G is the set {(u, t)}, and I is the set of program
token indices. We set ((u, t), i) ∈ E iff the program token pi was either executed to produce eu,t; or
pi initiates a loop or conditional, e.g., repeat, and the body of that loop or conditional produces
eu,t when executed. For each program token pi, we compute a vector representation of its related
execution states, which is the mean of the corresponding embedding vectors:

qi =

1
|{(u, t) : ((u, t), i) ∈ E}|

(cid:88)

te(u,t)

(u,t):((u,t),i)∈E

(2)

Finally, the program token representation fed into the edit decoder is ep(cid:48)
original program token embedding computed by the bi-directional program encoder.

i = [epi; qi], where epi is the

3.3 Training

We design a two-stage training process for the debugger, as discussed below.

Stage 1: Pre-training with synthetic program mutation. We observe that if we directly train
the debugger with the predicted programs of the synthesizer, the training hardly makes progress.
One main reason is because a well-trained synthesizer only makes wrong predictions for around
15% − 35% training samples, which results in a small training set for the debugger model. Although
the synthesizer could produce a program close to one that satisﬁes the input-output speciﬁcation, it is
mostly distinct from the annotated ground truth program, as indicated in our evaluation. Therefore, we
build a synthetic program repair dataset in the same way as [25] to pre-train the debugger. Speciﬁcally,
for each sample in the original Karel dataset, we randomly apply several mutations to generate an
alternative program P (cid:48) from the ground truth program P . Note that the mutations operate on the AST,
thus the edit distance between program token sequences of P and P (cid:48) may be larger than the number
of mutations, as shown in Figure 4. We defer more details on mutations to Appendix D. We generate
an edit sequence to modify from P (cid:48) to P , then train the debugger with the standard cross-entropy
loss using this edit sequence as supervision.

Stage 2: Fine-tuning with the neural program synthesizer. After pre-training, we ﬁne-tune the
model with the incorrect programs produced by the neural program synthesizer. Speciﬁcally, we run
the decoding process using the synthesizer model on the Karel training set, then use those wrong
predictions to train the debugger.

3.4

Inference Procedure

During inference, we achieve the best results using a best ﬁrst search, as described in Algorithm 1. In
the algorithm, we denote the synthesizer model as M (e), which produces a list of candidate programs
for input-output examples e. The debugger model D(p, e) produces a list of candidate programs

4

Algorithm 1 Best ﬁrst search

F ← M (e)
S ← {}
for i ∈ {1 . . . k} do

1: function BEST-FIRST-SEARCHk((e))
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:

c ← arg maxp∈F \S T (p, e)
S ← S ∪ {c}
if T (c, e) = 1 then

end for
return arg maxp∈F T (p, e)

end if
F ← F ∪ D(c, e)

return c

(cid:46) Frontier of the search space: programs yet to be expanded
(cid:46) Already expanded programs

(cid:46) Success

(cid:46) Probable failure, unless the program was found on the ﬁnal

step

13: end function

given the input program p. The function T (p, e) executes the program p on the examples e, and
returns a value in [0, 1] representing the proportion of input-output examples that are satisﬁed.

Within our SED framework, we view program synthesis from speciﬁcation as a search on an inﬁnite
tree with every node except the root node being annotated with a program c, and having children
D(c, e). Our goal is to search for a program p satisfying T (p, e) = 1. While T (p, e) = 1 does not
ensure that the generated program is semantically correct, as e does not include held-out test cases, it
is a necessary condition, and we ﬁnd it sufﬁcient as the termination condition of our search process.

We design two search algorithms for SED. Our ﬁrst algorithm is a greedy search, which iteratively
selects the program from the beam output of the previous edit iteration that passes the greatest number
of input-output examples (and has not yet been further edited by the debugger), and returns the edited
program when it passes all input-output examples, or when it reaches the maximal number of edit
operations allowed, denoted as k. See Algorithm 2 in Appendix C for more details.

A more effective scheme employs a best-ﬁrst search. Compared to the greedy search, this search
algorithm keeps track of all the programs encountered, as shown in line 10 of Algorithm 1, so that it
can fall back to the debugger output from earlier edit iterations rather than get stuck, when none of
the programs from the current edit iteration is promising.

4 Evaluation

In this section, we demonstrate the effectiveness of SED for Karel program synthesis and repair. We
ﬁrst discuss the evaluation setup, then present the results.

4.1 Evaluation Setup

The Karel benchmark [4, 2] is one of the largest publicly available input-output program synthesis
dataset that includes 1,116,854 samples for training, 2,500 examples in the validation set, and 2,500
test examples. Each sample is provided with a ground truth program, 5 input-output pairs as the
speciﬁcation, and an additional one as the held-output test example. We follow prior work [2, 23, 3]
to evaluate the following metrics: (1) Generalization. The predicted program P is said to generalize
if it passes the all the 6 input-output pairs during testing. This is the primary metric we consider. (2)
Exact match. The predicted program is an exact match if it is the same as the ground truth.

Program repair. In addition to the Karel program synthesis task introduced above, we also evaluate
our debugger component on the mutation benchmark in [25]. Speciﬁcally, to construct the test set, for
each sample in the original Karel test set, we ﬁrst obtain 5 programs {P (cid:48)
i=1 by randomly applying 1
to 5 mutations starting from the ground truth program P , then we generate 5 test samples for program
repair, where the i-th sample includes P (cid:48)
i as the program to repair, and the same input-output pairs
and ground truth program P as the original Karel test set.

i }5

5

4.2 Synthesizer Details

We consider two choices of synthesizers. The ﬁrst synthesizer is LGRL [2], which employs a
standard encoder-decoder architecture as discussed in Section 3.1. During inference, we apply a
beam search with beam size B = 32. We also evaluate a variant that performs the greedy decoding,
i.e., B = 1, denoted as LGRL-GD. The second synthesizer is the execution-guided neural program
synthesis model proposed in [3], denoted as EGNPS. The model architecture of EGNPS similar to
LGRL, but it leverages the intermediate results obtained by executing partial programs to guide the
subsequent synthesis process. During inference, we apply a search with beam size B = 64. We
present the performance of these synthesizers in the ﬁrst row ( “Synthesizer Only”) of Table 1.

4.3 Debugger Details

We compare our debugger architecture incorporated with the trace embedding component to the base-
line in [25], and we refer to ours and the baseline as TraceEmbed and No TraceEmbed respectively.
For the program synthesis task, all models are pre-trained on the training set of the synthetic mutation
benchmark with 1-3 mutations. For the ﬁne-tuning results, LGRL and LGRL-GD are ﬁne-tuned
with their synthesized programs, as discussed in Section 3.3. For EGNPS, we evaluate the debugger
ﬁne-tuned with LGRL, because EGNPS decoding executes all partial programs generated in the beam
at each step, which imposes a high computational cost when evaluating the model on the training set.

4.4 Results

Mutation benchmark for program repair. Figure 3 shows the results on the mutation benchmark.
For each debugger architecture, we train one model with programs generated using 1-3 mutations, and
another one with 1-5 mutations. Our most important observation is that the debugger demonstrates a
good out-of-distribution generalization performance. Speciﬁcally, when evaluating on 4-5 mutations,
although the performance of models trained only on 1-3 mutations are worse than models trained
on 1-5 mutations, they are already able to repair around 70% programs with 5 mutations, which is
desirable when adapting the model for program synthesis. On the other hand, each model achieves
better test performance when trained on a similar distribution. For example, models trained on 1-3
mutations achieve better performance when evaluating on 1-3 mutations than those trained on 1-5
mutations.

Meanwhile, for each number of mutations, the lowest repair error is achieved by the model with our
TraceEmbed component, demonstrating that leveraging execution traces is helpful. However, such
models tend to overﬁt more to the training data distribution, potentially due to the larger model sizes.

Figure 3: Results on the mutation benchmark, where x-axis indicates the number of mutations to
generate the programs for repair in the test set. In the legend, “3” refer to models trained on 1-3
mutations, “5” refer to models trained on 1-5 mutations.

6

Table 1: Results on the test set for Karel program synthesis, where we present the generalization error
with exact match error in parentheses for each synthesizer / debugger combination.
LGRL-GD

Synthesizer+Debugger

EGNPS

LGRL

Synthesizer Only

39.00% (65.72%)

22.00% (63.40%)

12.64% (56.76%)

No TraceEmbed+No Finetune
No TraceEmbed+Finetune
TraceEmbed+No Finetune
TraceEmbed+Finetune

18.56% (62.84%)
16.12% (60.88%)
18.68% (63.84%)
16.12% (61.16%)

14.88% (62.72%)
14.32% (62.48%)
14.60% (62.88%)
14.28% (62.68%)

10.68% (56.64%)
10.20% (56.56%)
10.68% (56.56%)
10.48% (56.52%)

The Karel program synthesis benchmark. Table 1 presents our main results for program synthe-
sis, where the debugger runs 100 edit steps. Firstly, SED consistently boosts the performance of
the neural program synthesizer it employs. In particular, with LGRL-GD as the synthesizer, SED
signiﬁcantly outperforms LGRL without the debugger, which shows that the iterative debugging
performed by SED is more effective than the standard beam search. Meanwhile, with EGNPS as the
synthesizer, even if the synthesizer already leverages the execution information to guide the synthesis,
SED still provides additional performance gain, which conﬁrms the beneﬁts of incorporating the
debugging stage for program synthesis. Note that for EGNPS, we base our predictions on a single
program synthesizer, rather than the ensemble of 15 models that achieves the best results in [3]. Even
if we apply the ensemble as the program synthesizer for SED, which already provides a strong result
of 8.32% generalization error, SED is still able to improve upon this ensemble model to achieve
7.78% generalization error.

Figure 4: Left: The distribution of edit distances for the mutation benchmark by number of mutations.
Middle and right: The joint distributions of the edit distances between the initial program predicted
by the LGRL synthesizer (init), the gold program, and the program predicted by SED that passes
all IO cases (pred). Dashed lines correspond to x = y.

To understand how SED repairs the synthesizer predictions, Figure 4 demonstrates the distribution of
edit distances between the initial and ground truth programs in the pre-training dataset (leftmost),
as well as distributions of edit distances among the ground truth, the predicted programs by the
synthesizer, and the repaired programs by SED that are semantically correct (middle and right).
The debugger is not ﬁne-tuned, employs the trace embedding component, and performs 100 edit
steps. Firstly, from the middle graph, we observe that SED tends to repair the synthesizer prediction
towards a correct program that requires fewer edit steps than the ground truth, and we provide an
example in Figure 1. The rightmost graph further shows that the repaired programs are generally
closer to the initial predictions than to the ground truth, which could be the reason why SED achieves
a much smaller improvement of the exact match than the generalization metric. Comparing these
distributions to the leftmost graph, we note that without ﬁne-tuning, SED is already able to repair not
only program semantic errors that might not correspond to the synthetic mutations for training, but
also programs with larger edit distances to the ground truth than the edit distances resulting from
synthetic mutations, which again demonstrates the generalizability of SED.

Next, we discuss the effects of our trace embedding component and ﬁne-tuning, and we further
present the results with different number of edit steps in Figure 5. We observe that ﬁne-tuning
improves the results across the board, and has a particularly pronounced effect for LGRL-based
models, where the data source for ﬁne-tuning comes from the same synthesizer. Meanwhile, the

7

Figure 5: Comparison of different architectures and training process for program synthesis. TE refers
to TraceEmbed, and F refers to ﬁne-tuning on the data generated by the same synthesizer. Note the
logarithmic scale of the x axis.

Figure 6: Comparison of best ﬁrst and greedy search strategies. All models use TraceEmbed+Finetune
as deﬁned in Table 1.

Table 2: Generalization errors of the LGRL program synthesizer with SED and the standard beam
search respectively, when expanding the same number of programs per sample.

Debugger beam size Edit steps

32
64
32
64

25
25
100
100

# of expanded programs
141
229
393
687

SED
16.64%
15.72%
15.40%
14.60%

Beam Search
18.52%
17.64%
17.00%
15.92%

debugger accompanied with the trace embedding mostly achieves better performance, especially
when ﬁne-tuning is not performed. Note that the performance gain is not due to the larger model
size. To conﬁrm this, we train another model without TraceEmbed, but we increase the hidden
sizes of IOEmbed and ProgramEncoder components, so that the number of model parameters
matches the model with TraceEmbed. Using the LGRL synthesizer, this alternative debugger
architecture achieves generalization errors of 15.88% without ﬁne-tuning and 16.64% with ﬁne-
tuning respectively, which are even worse than their smaller counterparts without TraceEmbed. On
the other hand, due to the small training set for ﬁne-tuning, since the trace embedding component
introduces additional model parameters, the debugger component could suffer more from over-ﬁtting.

Figure 6 compares the best ﬁrst and greedy search strategies. We see that best ﬁrst search always
outperforms greedy search, often being able to achieve a similar performance in half the number of
edit steps. This effect is more pronounced for LGRL and EGNPS synthesizers, as they provide more
than one program to start with, which best ﬁrst search can more effectively exploit.

In Table 1, we demonstrate that with the same program synthesizer, SED provides a more signiﬁcant
performance gain than the standard beam search. In Table 2, we further compare the generalization
errors of SED and the standard beam search, with the same number of expanded programs per sample.
Speciﬁcally, using the LGRL program synthesizer, we evaluate SED with debugger beam sizes of 32
and 64 and edit steps of 25 and 100 respectively, and track the number of expanded programs per
sample. Afterwards, we apply the standard beam search to the same LGRL program synthesizer,
and we set the beam sizes to match the average number of expanded programs by SED. Again, our

8

results show that SED consistently outperforms the standard beam search, when the same number of
programs are expanded.

5 Related Work

Program synthesis from input-output examples. Program synthesis from input-output speciﬁca-
tion is a long-standing challenge with many applications [16, 10, 19], and recent years have witnessed
signiﬁcant progress achieved by deep learning approaches [1, 20, 5, 2]. Different domain-speciﬁc
languages (DSLs) have been investigated, such as AlgoLISP [12, 31] for array manipulation, Flash-
Fill [20, 5, 29] for string transformation, and Karel [2, 23, 3] studied in this work. While most existing
work only uses the execution results to post-select among a set of candidate programs predicted
by a synthesizer, some recent work leverage more ﬁne-grained semantic information such as the
intermediate execution states to improve the synthesizer performance [27, 31, 3, 7]. In our evaluation,
we demonstrate that SED further provides performance gain by leveraging execution results to repair
the synthesized programs.

Besides neural network approaches, several generate-and-test techniques have been presented for
program synthesis, mostly based on the symbolic search [22, 26]. Speciﬁcally, STOKE uses MCMC
sampling to explore the space of program edits for superoptimization [22], while we demonstrate that
with our neural network design, SED achieves good performance even with a simple heuristic search.
CEGIS-based approaches utilize a symbolic solver for generating counterexamples to guide the
program synthesis process [26, 13], which typically require a more complete and formal speciﬁcation
than a few input-output examples as provided in the Karel domain. We consider developing more
advanced search techniques to improve the model performance as future work.

Program repair. There has been a line of work on program repair, including search-based tech-
niques [15, 14, 18] and neural network approaches [11, 30, 25, 28, 6]. While most of these work
focus on syntactic error correction, S3 designs search heuristics to improve the efﬁciency and gen-
eralizability of enumerative search over potential bug ﬁxes, guided by input-output examples as
the speciﬁcation [14]. In [30], they train a neural network to predict the semantic error types for
programming submissions, where they use execution traces to learn the program embedding. In [25],
they study program repair on Karel where the wrong programs are generated with synthetic mutation,
and we use its model as a baseline for our debugger component. Meanwhile, iterative repair is used as
part of the decompilation pipeline in [9]. In this work, our SED framework incorporates the program
repair scheme for input-output program synthesis, where the relationship between the program and
the speciﬁcation is typically complex.

Though both our work and [25] evaluate on Karel, there are several key differences. Most importantly,
in [25], they didn’t study how to incorporate a debugger component to improve the program synthesis
results. Instead, they focus on repairing programs that are generated by randomly mutating the ground
truth programs, thus they assume that the wrong programs are already syntactically similar to the
ground truth. On the other hand, we demonstrate that the debugger component is not only helpful for
the program repair task itself, but also improves the program synthesis performance. Furthermore,
even if the program synthesizer generates programs syntactically far from the ground truth, the
debugger may still be able to predict alternative programs that satisfy the speciﬁcation.

6 Conclusion

Program synthesis and program repair have typically been considered as largely different domains.
In this work, we present the SED framework, which incorporates a debugging process for program
synthesis, guided with execution results. The iterative repair process of SED outperforms the beam
search when the synthesizer employs the greedy decoding, and it signiﬁcantly boosts the performance
of the synthesizer alone, even if the synthesizer already employs a search process or incorporates the
execution information. Additionally, we found that even though there is a program aliasing problem
for supervised training, our two-stage training scheme alleviates this problem, and achieves strong
generalization performance. Our SED framework could potentially be extended to a broad range of
speciﬁcation-guided program synthesis applications, and we consider it as future work.

9

Broader Impacts

Program synthesis has many potential real-world applications. One signiﬁcant challenge of program
synthesis is that the generated program needs to be precisely correct. SED mitigates this challenge by
not requiring the solution to be generated in one shot, and instead allowing partial solutions to be
corrected via an iterative improvement process, achieving an overall improvement in performance
as a result. We thus believe SED-like frameworks could be applicable for a broad range of program
synthesis tasks.

Acknowledgments and Disclosure of Funding

This material is in part based upon work supported by the National Science Foundation under Grant
No. TWC-1409915, Berkeley DeepDrive, and DARPA D3M under Grant No. FA8750-17-2-0091.
Any opinions, ﬁndings, and conclusions or recommendations expressed in this material are those of
the author(s) and do not necessarily reﬂect the views of the National Science Foundation. Xinyun
Chen is supported by the Facebook Fellowship.

References

[1] M. Balog, A. L. Gaunt, M. Brockschmidt, S. Nowozin, and D. Tarlow. Deepcoder: Learning to

write programs. In International Conference on Learning Representations, 2017.

[2] R. Bunel, M. Hausknecht, J. Devlin, R. Singh, and P. Kohli. Leveraging grammar and rein-
forcement learning for neural program synthesis. In International Conference on Learning
Representations, 2018.

[3] X. Chen, C. Liu, and D. Song. Execution-guided neural program synthesis. In International

Conference on Learning Representations, 2019.

[4] J. Devlin, R. R. Bunel, R. Singh, M. Hausknecht, and P. Kohli. Neural program meta-induction.

In Advances in Neural Information Processing Systems, pages 2080–2088, 2017.

[5] J. Devlin, J. Uesato, S. Bhupatiraju, R. Singh, A. rahman Mohamed, and P. Kohli. Robustﬁll:

Neural program learning under noisy i/o. In ICML, 2017.

[6] E. Dinella, H. Dai, Z. Li, M. Naik, L. Song, and K. Wang. Hoppity: Learning graph trans-
In International Conference on Learning

formations to detect and ﬁx bugs in programs.
Representations, 2020.

[7] K. Ellis, M. I. Nye, Y. Pu, F. Sosa, J. B. Tenenbaum, and A. Solar-Lezama. Write, execute,

assess: Program synthesis with a repl. In NeurIPS, 2019.

[8] K. Ellis, D. Ritchie, A. Solar-Lezama, and J. Tenenbaum. Learning to infer graphics programs
from hand-drawn images. In Advances in neural information processing systems, pages 6059–
6068, 2018.

[9] C. Fu, H. Chen, H. Liu, X. Chen, Y. Tian, F. Koushanfar, and J. Zhao. Coda: An end-to-end

neural program decompiler. In NeurIPS, 2019.

[10] S. Gulwani, W. R. Harris, and R. Singh. Spreadsheet data manipulation using examples.

Communications of the ACM, 55(8):97–105, 2012.

[11] R. Gupta, S. Pal, A. Kanade, and S. K. Shevade. Deepﬁx: Fixing common c language errors by

deep learning. In AAAI, 2017.

[12] A. S. Illia Polosukhin. Neural program search: Solving data processing tasks from description

and examples, 2018.

[13] L. Laich, P. Bielik, and M. Vechev. Guiding program synthesis by learning to generate examples.

In International Conference on Learning Representations, 2020.

[14] X.-B. D. Le, D.-H. Chu, D. Lo, C. Le Goues, and W. Visser. S3: syntax-and semantic-guided
repair synthesis via programming by examples. In Proceedings of the 2017 11th Joint Meeting
on Foundations of Software Engineering, pages 593–604, 2017.

[15] C. Le Goues, M. Dewey-Vogt, S. Forrest, and W. Weimer. A systematic study of automated
program repair: Fixing 55 out of 105 bugs for $8 each. In 2012 34th International Conference
on Software Engineering (ICSE), pages 3–13. IEEE, 2012.

10

[16] H. Lieberman. Your wish is my command: Programming by example. 2001.
[17] Z. Manna and R. J. Waldinger. Toward automatic program synthesis. Communications of the

ACM, 14(3):151–165, 1971.

[18] B. Mehne, H. Yoshida, M. R. Prasad, K. Sen, D. Gopinath, and S. Khurshid. Accelerating
search-based program repair. In 2018 IEEE 11th International Conference on Software Testing,
Veriﬁcation and Validation (ICST), pages 227–238. IEEE, 2018.

[19] S. H. Muggleton, D. Lin, N. Pahlavi, and A. Tamaddoni-Nezhad. Meta-interpretive learning:

application to grammatical inference. Mach. Learn., 94(1):25–49, 2014.

[20] E. Parisotto, A.-r. Mohamed, R. Singh, L. Li, D. Zhou, and P. Kohli. Neuro-symbolic program

synthesis. In International Conference on Learning Representations, 2017.

[21] R. E. Pattis. Karel the Robot: A Gentle Introduction to the Art of Programming. John Wiley &

Sons, Inc., USA, 1st edition, 1981.

[22] E. Schkufza, R. Sharma, and A. Aiken. Stochastic superoptimization. ACM SIGARCH Computer

Architecture News, 41(1):305–316, 2013.

[23] E. C. Shin, I. Polosukhin, and D. Song. Improving neural program synthesis with inferred
execution traces. In Advances in Neural Information Processing Systems, pages 8917–8926,
2018.

[24] R. Shin, N. Kant, K. Gupta, C. Bender, B. Trabucco, R. Singh, and D. X. Song. Synthetic
datasets for neural program synthesis. In International Conference on Learning Representations,
2019.

[25] R. Shin, I. Polosukhin, and D. X. Song. Towards speciﬁcation-directed program repair. In ICLR

Workshop, 2018.

[26] A. Solar-Lezama and R. Bodik. Program synthesis by sketching. Citeseer, 2008.
[27] S.-H. Sun, H. Noh, S. Somasundaram, and J. Lim. Neural program synthesis from diverse
demonstration videos. In Proceedings of the 35th International Conference on Machine Learn-
ing, 2018.

[28] M. Vasic, A. Kanade, P. Maniatis, D. Bieber, and R. Singh. Neural program repair by jointly
learning to localize and repair. In International Conference on Learning Representations, 2019.
[29] A. J. Vijayakumar, A. Mohta, O. Polozov, D. Batra, P. Jain, and S. Gulwani. Neural-guided

deductive search for real-time program synthesis from examples. In ICLR, 2018.

[30] K. Wang, R. Singh, and Z. Su. Dynamic neural program embedding for program repair. In

International Conference on Learning Representations, 2018.

[31] A. Zohar and L. Wolf. Automatic program synthesis of long programs with a learned garbage

collector. In NeurIPS, 2018.

11

A Hyperparameters

A.1 LGRL Training

The LGRL model was trained with a learning rate of 1, that decayed by 50% every 105 steps on 50
epochs of the Karel training dataset, using minibatch SGD with batch size 128 and gradient clipping
with magnitude 1. It was run in greedy decoding mode to form the LGRL-GD synthesizer, and run
using beam search with 32 beams to form the LGRL synthesizer.

A.2 EGNPS Model

The EGNPS model was trained for 10 epochs on the Karel dataset, with a learning rate of 5 × 10−4,
and the batch size is 16. See [3] for more details. During the inference time, it was run in the search
mode with a beam size of 64.

A.3 Debugger Training

The debugger was trained with a learning rate of 1, that decayed by 50% every 105 steps on 50 epochs
of the Karel training dataset using random mutations, sampled with probability proportional to the
number of mutations. Minibatch SGD was used with a batch size of 64, and gradient clipping with
magnitude 1. The models were ﬁnetuned on examples from the training dataset that were incorrect,
also for 50 epochs, with a learning rate of 10−4.

A.4 TraceEmbed Architecture

The TraceEmbed unit is a residual convolutional network. The input, output, and trace grids are
stacked along the channel axis, thus preserving locality in space while allowing features and which
grid to be fully connected. The network is composed of an initial convolution that takes the 15 × 3
channels of the input grids to 64 channels, then three ResNet blocks, each of which consists two
layers of of batch normalization, ReLU, and convolution followed by a residual connection. All
convolutions are 3 × 3 with a padding of 1. The last layer is a fully connected layer that ﬂattens the
entire grid into an embedding of size 256 (the same size as a program token embedding).

B More Descriptions of the Karel Domain

Figure 7 presents the grammar speciﬁcation of the Karel DSL. Speciﬁcally, the DSL describing
its movements inside a grid consisting of cells which are of size 2x2 to 18x18 and containing
between 0 to 10 objects. These movements are described with move, turnLeft, turnRight
and interactions with the markers are pickMarker and putMarker. The language contains
constructs with conditionals such while and for loops with front, left, right, IsClear,
markerspresent, and negations. Each cell of the grid is represented as a 16-dimensional vector
corresponding to the features described in Table 3.

Prog p ::= def run() : s
Stmt s ::= while(b) : s | repeat(r) : s | s1 ; s2 | a

|

if(b) : s | ifelse(b) : s1 else : s2
Cond b ::= frontIsClear() | leftIsClear() | rightIsClear
markersPresent() | noMarkersPresent() | not b

|

Action a ::= move() | turnRight() | turnLeft()

|

pickMarker() | putMarker()

Cste r ::= 0 | 1 | ... | 19

Figure 7: Grammar for the Karel task.

C Full Greedy Algorithm

The full greedy algorithm is in Algorithm 2.

12

Robot facing North
Robot facing East
Robot facing South
Robot facing West
Obstacle
Grid boundary
1 marker
2 markers
3 markers
4 markers
5 markers
6 markers
7 markers
8 markers
9 markers
10 markers
Table 3: Representation of each cell in the Karel state.

Algorithm 2 Greedy search algorithm

return c

end if
for i ∈ {1 . . . k} do

c ← arg maxp∈M (e) T (p, e)
S ← {}
if T (c, e) = 1 then

1: function GREEDY-SEARCHk((e))
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
end for
13:
return c
14:
15: end function

c ← arg maxp∈D(c,e)\S T (p, e)
S ← S ∪ {c}
if T (c, e) = 1 then

return c

end if

(cid:46) Already expanded programs

(cid:46) Success

(cid:46) Success

(cid:46) Failure

D Mutations

There are six types of mutations that we consider, identical to the ones used in [25]. Three mutations,
insert(n, a), delete(n), replace(n, a), each take a node n and either delete it, replace it
with some action a, or insert the action a next to this node. The mutation wrap(¯n, t, c) wraps
the series of nodes ¯n in a control construct speciﬁed by the control type t ∈ Tc, where Tc =
{if, ifelse, while, repeat} and control value c, which is a conditional for if/while and
a number for repeat. The unwrap(n) mutation takes in a node whose root is a construct in Tc and
replaces it with its body. The mutation replaceControl(n, c) takes a node n whose root is a
construct in Tc and replaces the control value or number of repetitions with c, an appropriately typed
control value. Each mutation maintains the syntactic validity of the program.

13

