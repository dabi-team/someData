Towards Understanding Chinese Checkers with Heuristics, Monte Carlo Tree Search,
and Deep Reinforcement Learning

Ziyu Liua,1, Meng Zhoua,1, Weiqing Caoa,1,∗, Qiang Qua, Henry Wing Fung Yeunga, Vera Yuk Ying Chunga

aSchool of Computer Science, The University of Sydney, Camperdown NSW 2006, Australia

9
1
0
2

r
a

M
8

]

G
L
.
s
c
[

2
v
7
4
7
1
0
.
3
0
9
1
:
v
i
X
r
a

Abstract

The game of Chinese Checkers is a challenging traditional board game of perfect information for computer programs to
tackle that diﬀers from other traditional games in two main aspects: ﬁrst, unlike Chess, all checkers remain indeﬁnitely
in the game and hence the branching factor of the search tree does not decrease as the game progresses; second,
unlike Go, there are also no upper bounds on the depth of the search tree since repetitions and backward movements
are allowed.
In this work, we present an approach that eﬀectively combines the use of heuristics, Monte Carlo tree
search, and deep reinforcement learning for building a Chinese Checkers agent without the use of any human game-play
data. In addition, unlike other common approaches, our approach uses a two-stage training pipeline to facilitate agent
convergence. Experiment results show that our agent is competent under diﬀerent scenarios and reaches the level of
experienced human players.

Keywords: Chinese Checkers, Heuristics, Monte Carlo Tree Search, Reinforcement Learning, Deep Learning

1. Introduction

There have been many successes (Silver et al., 2017a,b,
2016; Khalifa et al., 2016) in developing machine learning
algorithms that excel at traditional zero-sum board games
of perfect information, such as Chess (Silver et al., 2017a;
Thrun, 1995) and Go (Silver et al., 2017b), as well as other
games (Lagoudakis & Parr, 2003; Waugh & Bagnell, 2015;
Conitzer & Sandholm, 2003; Pendharkar, 2012; Guo et al.,
2014; Stanley et al., 2006; Finnsson & Bj¨ornsson, 2008;
Chen et al., 2017). Little research attention, however,
has been drawn to solve the game of Chinese Checkers
with machine learning techniques. While there are known
strategies for approaching Chinese Checkers, such strate-
gies often only focus on the initial starting policy and lo-
cally optimal game-play patterns, or that they may heavily
rely on cooperation between the players, which is often not
possible. In addition, with the goal to move all of a players
checkers to the opponents side, there are two particular as-
pects of the game that are diﬀerent from other traditional
games which may lead to an enormously large game-tree
and state-space complexity (Allis, 1994) and game diver-
gence. First, checkers in the game remain indeﬁnitely on
the board and cannot be captured; and second, the pos-
sibility of repetition and backward movements of checkers

∗Corresponding author
Email addresses: zliu6676@uni.sydney.edu.au (Ziyu Liu),

mzho7212@uni.sydney.edu.au (Meng Zhou),
wcao4942@uni.sydney.edu.au (Weiqing Cao),
qiqu7152@uni.sydney.edu.au (Qiang Qu),
hyeu8081@uni.sydney.edu.au (Henry Wing Fung Yeung),
vera.chung@sydney.edu.au (Vera Yuk Ying Chung)

1Equal contribution

mean that the game can be arbitrarily long without vio-
lating game rules.

In this work, we present an approach that eﬀectively
combines the use of heuristics, Monte Carlo Tree Search
(MCTS), and reinforcement learning for building a Chi-
nese Checkers agent without the use of any human game-
play data. Our approach is inspired by AlphaGo Zero on
the game of Go (Silver et al., 2017b), where the agent is
represented as a single, deep residual (He et al., 2016) con-
volutional neural network (LeCun et al., 1998) which takes
as input the current game state and outputs both the cur-
rent game-play policy and the current game state value
from the perspective of the current player. The training
pipeline for the agent, however, diﬀers in that the agent
is ﬁrst guided and initialized using a greedy heuristic, and
experiment results show that such guidance can quickly
allow the agent to learn very basic strategies like consec-
utive hops and can signiﬁcantly reduce the depth of the
search trees in the games. The next stage of the training
pipeline aims to improve the network through reinforce-
ment learning, where each iteration the network gener-
ates many self-play games with Monte Carlo Tree Search
and is trained using the ﬁnal game outcomes and post-
search action policies. For comparison, we also trained a
network entirely through MCTS-guided self-play reinforce-
ment learning (i.e. tabula rasa learning) as well as a net-
work trained with the Deep Q-Learning approach as seen
in the work of Mnih et al. (2013) used for training agents
to play Atari Games. Experiment results show that the
current approach outperforms both of these approaches to
a signiﬁcant extent.

Preprint submitted to Elsevier

March 11, 2019

 
 
 
 
 
 
The rest of the paper is organised as follows. Section 2
discusses related work done in the ﬁeld. Section 3 explains
in detail the methods and techniques used for building the
agent. Section 4 presents and extensively discusses the
results of the experiments conducted on several important
aspects of the training framework and discusses how they
may aﬀect the agents performance. Section 5 concludes
the paper.

2. Background

Heuristics in games. Heuristics are one of the most widely
and commonly used techniques in artiﬁcial intelligence to
guide decision-making in games when no exact solutions
are available (Oh et al., 2017), or the search spaces are
too large for any form of exhaustive search (Bulitko et al.,
2011). With a carefully designed heuristic function for
game state transitions, the branching factor of the search
tree can be signiﬁcantly reduced (as evidently bad moves
can be avoided) while potentially increasing the perfor-
mance of the agent. Diﬀerent forms of heuristic search
have been successfully applied and shown to improve the
performance of an agent in various games such as the
work of Cui & Shi (2011), Churchill et al. (2012), Bu-
litko et al. (2011), Kovarsky & Buro (2005a), Kovarsky &
Buro (2005b), and Gelly & Silver (2008). This includes
various board games such as Chess and Go (Kovarsky &
Buro, 2005b; Gelly & Silver, 2008) where heuristic search
can be used for ﬁnding locally optimal plays and various
video games such as path-ﬁnding through complex terrain
and performing complex real-time strategy (Cui & Shi,
2011; Churchill et al., 2012; Bulitko et al., 2011; Kovarsky
& Buro, 2005a). In the case of Chinese checkers, heuristics
has also been applied, for example, in search for the quick-
est game progress by prioritising moving the most forward
checkers, or in search for the shortest possible game (Bell,
2008). However, while these heuristic rules can inspire
some game-play strategies like building bridges (depicted
in Figure 4), they depend heavily on the state of the game
and sometimes the cooperation of the opponent, which
means achieving expert-level play solely with heuristics is
often not possible in real and competitive games.

Monte Carlo Tree Search. Originally introduced in the
work of Coulom (2007), Monte Carlo tree search (MCTS)
is an eﬀective method for searching the next optimal action
when given the current game state (Silver et al., 2017b,
2016; Gelly & Silver, 2008; Ciancarini & Favini, 2010; Szita
et al., 2009; Pepels et al., 2014; Khalifa et al., 2016). It
does so by running multiple simulations, where each sim-
ulation gradually expands the search-tree rooted at the
current game state by following the locally optimal ac-
tion at each subsequent state while taking into account
some degree of exploration through to a leaf node in the
search-tree and back-up the value of the leaf state for the
next simulation (Coulom, 2007); an action is then decided
based on all simulations. With its eﬀective look-ahead

2

search, MCTS has been shown to improve the performance
of agents in games such as Ms Pac-Man (Pepels et al.,
2014), and board games such as Go (both in restricted
(Gelly & Silver, 2008) and unrestricted games (Silver et al.,
2017b, 2016)), the Settlers of Catan (Szita et al., 2009) and
Kriegspiel (Ciancarini & Favini, 2010). Modiﬁcations to
MCTS is also possible; for example, Khalifa et al. (2016)
demonstrated in their work that by taking into account
human and game-speciﬁc factors, MCTS can be modiﬁed
to further improve the agents performance. In our work,
a slightly modiﬁed version (as compared to common vari-
ants in as seen in Gelly & Silver (2008); Coulom (2007);
Browne et al. (2012); Ciancarini & Favini (2010)) of MCTS
is used, where we replaced the Upper Conﬁdence Bound
(UCB) algorithm with a variant as used in AlphaGo Zero
(Silver et al., 2017b). More details are presented in Meth-
ods.

Reinforcement Learning in games. In recent years, rein-
forcement learning has been shown to be the key in the suc-
cesses of many intelligent agents excelling at board games
that were thought to be extremely hard or even impossi-
ble for computers to master, including Go, Chess, Othello
(Silver et al., 2017a,b, 2016; Ghory, 2004), and others. It
is a powerful framework that allows computer programs
to learn through interactions with the environment rather
than following a ﬁxed set of rules or learning from a ﬁxed
set of data, and it allows the agent to be more ﬂexible
with the complex, dynamic real-world interactions, hence
suitable for games in particular. In the context of board
games, the reinforcement learning framework can also be
combined with various other techniques such as Monte
Carlo tree search to further its eﬀectiveness. For exam-
ple, AlphaZero (Silver et al., 2018) was able to achieve
expert-level performance in Chess, Go, and Shogi with-
out the use of any human knowledge when trained solely
on self-play reinforcement learning guided by Monte Carlo
tree search. In our work, reinforcement learning is used to
continually improve the performance of our agent through
MCTS-guided self-plays.

Deep Q-Learning. As a well-known reinforcement learn-
ing approach, Q-learning follows the same structure as the
Markov Decision Process to maximize the accumulated im-
mediate reward obtained by performing a speciﬁc action
for a given state. For a long time since its development,
neural networks has been abandoned for this approach due
to its lack of convergence guarantee. However, ﬁrstly pro-
posed by Mnih et al. (2013), Deep Q-Learning with the use
of deep neural networks has been successfully applied to
Atari games to outperforms human in particular games, as
well as various other games and applications (Van Hasselt
et al., 2016; Greenwald et al., 2003; Tesauro, 2004; Lample
& Chaplot, 2017; Li et al., 2016). By using some training
techniques such as experience replay, epsilon-greedy and
Huber loss, the convergence rate of the network is signif-
icantly increased. In our case, a Deep Q-Learning agent

Figure 1: Restricted game board for two players. White cells rep-
resent empty slots and coloured cells represent slots occupied by
diﬀerent players.

Figure 2: Matrix representation of a game state.

is trained following the algorithm and training techniques
proposed by Mnih et al. (2013) as a comparison to our
main approach. The details will be discussed in Methods.

3. Methods

3.1. Game Formulation

In a standard game of Chinese Checkers (Fonseca, 2016),
there can be 2, 3, 4, or 6 players playing on a star-shaped
board, each with 10 checkers.
In this work, we reduced
the game for streamlined training and analysis: we ﬁrst
restricted the number of players to 2 and the number of
checkers for each player to 6, and then resized to game
board to a 49-slot, diamond-shaped board by removing
the extra checker slots for the extra players. All game
rules are unaﬀected. Figure 1 illustrates the revised game
board as adapted from a standard 6-player board. To rep-
resent the board in a program, we use a 7×7 matrix, called
the game matrix , in which the value 0 represent an empty
slot, value 1 represent checkers of the ﬁrst player (Player
1) and value 2 for the second player (Player 2). Player 1
always starts from the bottom-left corner (i.e. bottom of
the board) while Player 2 always starts from the top-right
corner (i.e. top of the board) of the game matrix. Figure
2 illustrates a mapping between the board representation
used in this paper and its game matrix representation.
Win state in the game can be easily checked by looking
only at the top-right and bottom-left corners of the game
matrix.

Each checker is tracked throughout a game by main-
taining its ID and its position as the game progresses. The
position of a checker is its position in the game matrix, and
its ID is an integer between 1 to 6 as illustrated in Fig-
ure 3. Four lookup tables, from position to ID and from
ID to position for each player, are cached for performance
and are updated as each move is made. The reason for
maintaining an ID for each checker is that when the agent
makes a prediction given a game state, a unique identiﬁer
for each checker is required such that the agents predicted
action policy is not ambiguous.

3

Figure 3: ID matrices of a single game state as input to neural net-
work. The IDs written on the checkers (1 to 6) correspond to values
in the matrices. The top and bottom matrices are produced from
the perspective of Player 1 (blue) and Player 2 (red) respectively.

Due to the nature of the game that a player can take
arbitrarily many hops for moving a checker to a single des-
tination, valid moves for a player at any given game state
are represented as a collection of distinct starting-ending
position pairs. The valid moves for each player is deter-
mined by ﬁrst checking the adjacent slots for each checker
which are reachable by rolling. Then, for each checker of
the current player, the valid destinations are determined
through recursive mirror hops through depth-ﬁrst search.
By using the unique IDs of the checkers, we can therefore
represent an agents action policy, which is a vector output
from the network representing the prior probabilities for
each possible move, at any given state using an ID-and-
destination mapping instead of a from-and-to mapping,
thereby greatly reducing the output dimension. For this
reason, the game matrix is primarily used for storage and
visualisation purposes, while inputs to the agent will take
the form of the ID matrices as illustrated in Figure 3. Fur-
ther details on the input and output of the agent will be
discussed in the Network Architecture and Conﬁgurations
subsection.

In addition to maintaining checker positions we also
cache a ﬁxed number of past game states as history. Past
game states are particularly useful for two reasons. First,
some common game-play strategies (such as “Bridge” as
shown in Figure 4) are not directly observable for the cur-

progresses. Second, unlike Go, repetitions and backward
movements are allowed, which means there are also no up-
per bounds on the depth of the search tree. Even in our
restricted game instance where the average length of ratio-
nal games is 45 moves, there are still on average 30 possible
moves at each state (both statistics calculated from a large
number of plays), yielding a total of more than 1066 unique
move sequences.

In order to eﬀectively reduce both the breadth and
depth of any form of search, we propose a simple heuris-
tic: at any given state, the value of the next possible valid
actions (determined as described in subsection Game For-
mulation) are ranked in decreasing order by their forward
distance, which is denoted by Ψ(A) for an action A. De-
note Player 1 and Player 2 to be P 1 and P 2 respectively,
and the action A = (As, Ae), where As = (Asa, Asb) and
Ae = (Aea, Aeb) refer to the 2-tuple of starting position
As and ending position Ae of the checker move in terms of
their row, column coordinates in the game matrix respec-
tively. Then, for any valid As and Ae where 1 ≤ Asa ≤ 7,
1 ≤ Asb ≤ 7, 1 ≤ Aea ≤ 7, and 1 ≤ Aeb ≤ 7 since the
game matrix has 7 rows and columns, Ψ(A) is given by:

Ψ(A) =

(cid:26) (Asa − Asb) − (Aea − Aeb),
(Aea − Aeb) − (Asa − Asb),

for P 1 (1)

for P 2 (2)

(cid:80)

Intuitively, if we consider the actual game board in-
stead of the game matrix, then Ψ(A) can be understood
as how far the action A has moved the checker in the pos-
itive direction, which is upwards for Player 1 and down-
wards for Player 2 on the board. With Ψ, we can then
formulate two greedy agents, being stochastically greedy
and deterministically greedy respectively: the former uses
Ψ(Ai)
j Ψ(Aj ) as the prior probability for selecting
the value
the action Ai among all possible actions Aj, while the de-
terministically greedy agent always picks the action with
the largest Ψ value. However, when multiple actions have
the same value, the latter agent samples an action uni-
formly from the set of best actions that involves the last
checker, which is the one fallen behind others. For both
types of agents, if all possible moves are backward moves
(i.e. negative forward distance, which is extremely unlikely
but possible), the action with the least absolute heuristic
value is chosen.

Through plays against humans, it was found that the
performance of both greedy agents is robust to vastly dif-
ferent game states, because it always recursively searches
for the longest possible move (which are often indiscernible
by humans) without concerning any local strategies played
by the opponent or even itself. However, for this very rea-
son, greedy agents can hardly defeat any experienced hu-
man player in a game due to its lack of strategies, since
human players can proactively plan and use strategies to
ensure no checkers fall behind by sacriﬁcing locally optimal
plays or even make backward moves for assisting fallen-

Figure 4: A local game-play strategy used in Chinese Checkers, com-
monly referred as a bridge.
In the ﬁgure on the right, the yellow
highlighted checker ﬁrst makes two consecutive hops, then another
bridge is formed for green-highlighted checker in the next round.

Figure 5: Examples of sub-optimal plays (black arrow) by heuristic
guided agent vs optimal plays (red arrows).

rent state while such strategies are being formed. It may
therefore be useful for the agent to look at a longer history
before making a move. Secondly, game history can be used
for checking meaningless repetitions or cyclic moves during
training by examining the number of distinct destinations
of past moves. Speciﬁcally, if in the past 16 moves of the
game there are less than 6 unique move destinations, then
it can be reasonably inferred that at least one player is
performing move cycles of length smaller than or equal to
3. However, note that it remains a diﬃcult task to detect
cyclic moves of arbitrary length.
In our work, 16 near-
est past games states are kept for detecting short cyclic
moves, and 3 nearest past game states were used together
as input to model.

3.2. Heuristic

There are two aspects of Chinese Checkers that make
it challenging for an agent to perform a deep search down
the game tree. First, unlike Chess, no capturing of check-
ers is possible in Chinese Checkers, which means that the
number of checkers in the game (and hence the branching
factor of the search tree) does not decrease as the game

4

behind checkers. Figure 5 illustrates the critical weakness
of heuristic-guided agents: with the game state on the left,
Player 2 (red) will win in at most 5 moves; a heuristic-
guided agent (blue) in this case would pick a move similar
to the move noted with the black arrow and hence lose
the game; however, an optimal play involves moving the
checker backward and use the other checker as a bridge
(depicted by red arrows) and therefore win the game in 4
moves.

On the other hand, through a large number of matches
between the two types of greedy agents, it was found that
the deterministic agent performs slightly better: after
playing 20,000 matches between the agents, where each
agent took turn to start, the deterministic agent wins 9,908
matches while the stochastic agent wins 9,766 matches,
with 326 games being draw due to move repetitions or
In addition,
moves that blocked the game progression.
to reduce the likelihood of repeating or similar move se-
quences due to the nature of greedy agents, the ﬁrst three
moves for each agent are uniformly randomly selected.
Therefore, the deterministic heuristic was used through-
out our experimentation (described in later sections).

3.3. Network Architecture and Conﬁgurations

The agent is represented as a single neural network
which takes as input the current game state and outputs
both the game-play policy (i.e. what actions should be
taken with what likelihood) and the game state value (i.e.
how good is the situation) for the current state from the
perspective of the current player. The ﬁnal neural net-
work architecture is depicted in Figure 6. This residual
convolutional network design was inspired by Silver et al.
(2017b) and He et al. (2016) for their great performance.
Blue blocks in the ﬁgure represent single convolutional lay-
ers (LeCun et al., 1998) with ReLU activation (Krizhevsky
et al., 2012) and a stride of 1. There are in total 9 convo-
lutional blocks (represented as Green blocks in the ﬁgure),
where each block contains a stack of 3 convolutional lay-
ers with 1 × 1, 3 × 3, 1 × 1 kernels, 32, 32, 64 ﬁlters,
and ReLU activations respectively. The skip connections
(curved paths and add gates in Figure 6) between the
convolutional blocks are adapted from ResNet (He et al.,
2016). Batch normalisation (Ioﬀe & Szegedy, 2015) layers
are also added after each convolutional layer before the
ReLU activation; no batch norm layers are added between
fully connected layers. Also, bias was used on fully con-
nected layers but not convolutional layers due to the bias
introduced by batch norm layers. All weights in the net-
work are initialised using the Xavier initialisation method
(Glorot & Bengio, 2010).

Convolutional layers with 1 × 1 sized kernels (He et al.,
2016) were extensively used to reduce the number of pa-
rameters in the network, and they eﬀectively perform di-
mensionality reduction on the feature maps while encour-
aging them to learn more robust features. In fact, com-
pared to the original architecture described by Silver et al.

Figure 6: Network Architecture. All conv and FC layers use ReLU
activation unless otherwise speciﬁed. All conv layers have a stride of
1.

(2017b) from which our design is inspired, the current ar-
chitecture has approximately 247,386 parameters, which is
only around 22% as much parameters. While the architec-
ture design shown by Silver et al. (2017b) has been proven
eﬀective, such networks are extremely hard to train given
the amount of game-play data that can be generated with-
out the use of massive amount of computing resources. As
a result, excessive parameters will lead to signiﬁcant over-

5

ﬁtting in our experimental setting.

Network Input. The input to the network is a 7 × 7 × 7
tensor. The ﬁrst six slices of the last dimension are six
7 × 7 ID matrices (as illustrated in Figure 3) for the past
three game states, where each game state is represented
using two ID matrices, one from the perspective of the
current player and the other from the perspective of the
opponent, stacked in this exact order. The game states are
then concatenated in sorted order where the most recent
state is on the top. The last 7 × 7 slice is a binary feature
map full of value 0 if the current player is Player 1 and
value 1 otherwise. When the game history contains less
than 3 game states, the trailing slices of the tensor (except
from the last one) will be ﬁlled with 0.

Network Output. There are two output-heads of the net-
work, the policy head and the value head, following the
practices used by Silver et al. (2017b). The value head
takes the feature maps output from the residual blocks as
input and outputs 1 real number in range [−1, 1], which
represents the evaluated game outcome from the perspec-
tive of the current player; a value closer to 1 means by
playing from the current state, the current player is more
likely to win than lose and vice versa. The ﬁrst 49 ele-
ments in the output vector represent the prior probability
for checker with ID 1 to move each possible position (49
of them in total) on the board; similarly, the second 49
elements represent the prior for the checker with ID 2 and
so on. The conversion between vector indices to checker
ID and position on board follows the unpacking order of
checker ID, checker row, and checker column. For exam-
ple, the 181th element in the vector refers to the probability
of moving the checker with ID 4 to the 5th row and 6th
column in the game matrix, where the ID of the checkers
start from 1.

3.4. Monte Carlo Tree Search

In our work, MCTS is primarily used in two scenar-
ios: to calibrate the action policy of the agent at training
time, and to enhance the performance of the agent at test
time. We have adapted the general MCTS framework from
Coulom (2007) and Browne et al. (2012) with a several
modiﬁcations inspired by Silver et al. (2017b):

1. Rather than performing a Monte Carlo rollout at
leaf positions of the tree (such as seen in the work
of Pepels et al. (2014) and Khalifa et al. (2016)) we
instead use the neural network as a game state evalu-
ator. This signiﬁcantly speeds up the MCTS process
by reducing the depth of the tree search as no playout
till the end state is needed. For Chinese Checkers in
particular, this is required as the depth of the game
tree is unbounded.

2. A variant of the Upper Conﬁdence Bound (UCB)
on Trees (or UCT) algorithm (Rosin, 2011) is used
where the prior probability of an action is also taken

into account in the exploration term of the search,
which is slightly modiﬁed such that the search is
more sensitive to the number of searches on a par-
ticular action and would therefore encourage more
exploration on actions that are searched less often.

Notation and Structure. Concretely, the Monte Carlo tree
search used in this work involves four stages, which we re-
ferred to as Selection, Expansion, Backup, and Decision.
To represent a game as a tree, we ﬁrst store the raw game
states using game matrices at tree nodes along with the
current player and the prior probabilities of game state
transitions, which can be predicted by the network in the
Expansion stage. We then store the possible state transi-
tions from the current state as edges directed away from
the tree node. Each edge stores the starting and end-
ing position of the move in the game matrix, the player
who will make this move, and four important tree search
statistics (Silver et al., 2017b): N , W , Q, and P , where N
is the number of times this edge has been visited during
the search, W is the accumulated value (from the Backup
stage) during the search, Q is the mean value (therefore
Q = W
N ), and P is the prior probability of selecting this
move. We denote the N , W , Q, P values of some edge k
to be Nk, Wk, Qk, Pk respectively. The overall procedure
of MCTS is to ﬁrst perform a given number of simulations,
which are iterations of Selection, Expansion, and Backup
stages; then, a ﬁnal decision is made based on the edges
that is directly incident to the root node, which represents
the current game state.

Selection. The ﬁrst step in a simulation is to iteratively
select the locally optimal moves from the current game
state (root of the search tree) until reaching a leaf node of
the tree. However, note that as the search progresses down
the tree, the simulated player is switched at every tree
level. At any given state, the next action is determined by
picking the outgoing edge with the maximum Q + U value,
where

Uj = cPj

(cid:112)(cid:80)

k Nk
Nj + 1

(3)

for the edge j, and c is a global constant controlling the
level of exploration; through empirical analysis, the value
of c = 3.5 is used in our work. The value U serves to in-
troduce an upper conﬁdence bound (Rosin, 2011) that the
given action will be optimal. Intuitively, if an edge is rarely
visited, then its U value will be bigger than that of the
other edges, hence increasing the overall Q + U value and
therefore encourages exploration. However, as the visit
counts N increases, the search will still asymptotically pre-
fer the edges with higher Q values as the signiﬁcance of U
decreases.

While a commonly used expression for U on an edge j

is

6

(cid:115)

Uj = c

2 ln (cid:80)
Nj

k Nk

(4)

(also known as the UCT algorithm (Browne et al., 2012)),
it is unsuitable in the case of Chinese Checkers since it
does not take into account the prior probability for se-
lecting the edge j. While this does not aﬀect games with
shallow or depth-bounded game-trees, in Chinese Checkers
this may lead the agent to explore obviously unpromising
moves (such as consecutive hops back) instead of better
moves when the number of simulations is restricted. With
the move prior P , the search is more focused on more
promising moves from the agents game-play experience.
However, by introducing P in U , the level of exploration
of the search is constrained and game trajectories may de-
pend undesirably heavily on past experiences. To mitigate
this issue, the square root term in Uj is slightly modiﬁed
such that the value of Uj is now more sensitive to Nj.

Expansion. After iterative selection and arriving at a leaf
node, the game state is evaluated by the neural network,
which outputs a 294-dimensional vector P representing the
prior for selecting the next moves from the leaf state, and
a value V representing the evaluated game outcome from
the perspective of the current player. The output vector
is sparse, as the number of valid moves, denoted by n,
is limited. Then, n corresponding valid next states are
created as nodes and are assigned to the current leaf node
as children, while the P statistic of the new edges directed
from the leaf node to the children will be assigned the
corresponding move prior from vector P. After expansion,
the values of N , W , Q for the new edges are initialised to
0. This stage diﬀers from a traditional MCTS procedure in
that no playouts (aka “rollouts”, “unrolling”) is required,
making the tree search more eﬃcient.

Backup. Once the tree is expanded at the leaf node, the
value V is back propagated along the path (i.e. the set of
edges) from the root while updating the edge statistics of
each edge along this path. For each edge e in the path:

1. If the player of e (represented as an action) is the
same as the player at the leaf node, the value We is
added by V; Otherwise, We is subtracted by V. One
exception, however, is that if the leaf state is a win
state, then the direction of adding/subtracting V is
inverted because the player at the leaf node has lost
the game.

2. The value Ne is incremented by 1.
3. The value Qe is updated to be We
Ne

.

Figure 7 summarises the above three stages involved in a
simulation.

Decision. After the search is ﬁnished with many iterations
of Selection, Expansion, and Backup, the agent randomly
samples a move from the root state using the exponentia-
tion of the visit counts as prior probabilities; if we denote
the post-search prior to be P*, then for an edge e, its

probability of being selected is:

P*e =

1
t
e

N

(cid:80)

k N

1
t
k

(5)

where t (adapted from Silver et al. (2017b)) is a temper-
ature parameter controlling the level of exploration. Intu-
itively, a value t > 1 will lead to a smoother probability
distribution over the edges, while a t close to 0 will lead
to a deterministic choice, since maxe(pe) will be close to
1. In our work, t is set to 0 during evaluation and testing
for achieving deterministic plays and is set to a value big-
ger than or equal to 1 for the initial moves of the self-play
games for encouraging diversity in the generated training
data. After performing the tree search for a particular
state, the entire search tree is discarded and a new search
tree will be built for each new game state. More details
are presented in Experiments and Results.

3.5. Data Generation and Training Pipeline

In summary, the agent is trained using a two-stage
training pipeline:
it is ﬁrst trained with histories of self-
plays guided by the deterministic heuristic, and is then fur-
ther optimised through reinforcement
learning using
MCTS-guided self-plays. It is worth mentioning that for
both stages of the pipeline, no human game plays are used,
and the training data are generated entirely through agent
self-plays.

Labels and data augmentation. Each training example
comprises the 7 × 7 × 7 tensor representing the current
game state as input, and the expected game state value
and post-search policy vector as the ground truth. The
game state value label, denoted as V*, will always be ei-
ther -1 or 1 representing a loss or a win from the perspec-
tive of Player 1. There is no draw in the game, as such
games are only possible due to meaningless repetitions or
irrational moves. The policy ground truth, denoted by P*
will be a 294-dimensional vector representing move prior.
During our experiments, the size of the training set is aug-
mented to be twice as large by ﬂipping each slice of the
input tensor along the last dimension around the bottom-
left-top-right diagonal (i.e. mirroring the board).

Optimisation Objective. The loss function for the network
is an unweighted sum of the losses at the two output
heads of the neural network. With each training exam-
ple, the loss for the value head is calculated using mean
squared error loss between predicted game state value V
and ground truth V*, while the loss for the policy head is
calculated using cross entropy loss between predicted move
prior P and policy ground truth P*. L2-regularisation is
also added to the loss term. In summary, loss L is given
by:

L = PT log(P*) + (cid:107)V − V*(cid:107)2 + λ(cid:107)θ(cid:107)2
where θ refers to the parameters of the network and λ is
a constant controlling the strength of L2 regularisation.

(6)

7

Figure 7: Summary of the simulation process of the Monte Carlo Tree Search used in this work.

Training on heuristic-guided self-plays. By directing the
greedy agent to play against itself without any form of
look-ahead search and game state evaluation, we are able
to quickly generate a substantial amount of training data
within a short amount of time. On average, it takes ap-
proximately 2 minutes to generate 5,000 self-play games
when fully utilising two Intel i5 2.7 GHz CPU cores.

In this setting, each game state is a training example
where the state value ground truth is the ﬁnal outcome
of the game (with the value negated when switching play-
ers); the policy ground truth is calculated by assigning
the reciprocal of number of moves with most forward dis-
tance to the corresponding optimal move indices in a 294-
dimensional, zero-ﬁlled vector. Heuristic-guided training
is done in a supervised manner where self-play data are
ﬁrst generated and the agent is then trained on them over
a ﬁxed number of epochs. To increase the diversity of
the data and reduce memory consumption, our implemen-
tation in fact generates the training set on-the-ﬂy with
approximately 15,000 new games per iteration and uses a
smaller number of epochs per iteration (5 per iteration).
However, there are two important factors that makes the
raw heuristic-guided self-play data less useful. First, even
if each move in the games is sampled rather than picked
deterministically, one can still observe frequently occurring
game-play patterns due to the agents locally optimal strat-
egy. This may lead to undesirably high correlations be-
tween training examples. To mitigate this, we introduced
three measures to add stochasticity to the data generation
process:

• Randomising the starting positions of all checkers
(which gives rise to more than 9×1010 possible start-
ing states).

• Forcing the agent to take random initial moves which
causes subsequent moves to be substantially diﬀer-
ent.

• Only retaining a very small portion of the generated
training examples by random sampling. The per-
centage of data kept is around 3-5% depending on
need.

The ratio between randomising starting checker positions,
randomising starting moves, and normal plays is set to
be 5:3:2, but other variations are also possible. Secondly,
the heuristic-guided agent only focuses on locally optimal
moves, which means the agent can easily make forward-
only moves and avoid some globally optimal plays that re-
quire horizontal or backward moves as depicted in Figure
5. To mitigate this, the ﬁrst stage of the training pipeline
is stopped before the model is trained till convergence to
increase the malleability of the network for further training
through reinforcement learning, in which stage the train-
ing data is harder to generate. Another minor drawback
of heuristic-guided self-plays is that there is a very small
probability that a games does not ﬁnish due to blocking
checkers. Since draw games are undesired in the training
set and in general, an early stopping mechanism is intro-
duced where the maximum length of each self-play game
is limited of 0.1s, and draw games are discarded.

Training on MCTS-guided self-plays. Once the network
is properly initialised through supervised learning, it is
further trained through self-play reinforcement learning,
where MCTS is used at each state to generate an improved
move prior P* as the policy label. Our reinforcement pro-
cess is described as follows. Starting from the initial ver-
sion, we maintain the current model M , the best model
M ∗, an opponent Mp, where M ∗ and Mp are initialised to
be M . Starting from the ﬁrst episode and for each episode,
we match M against Mp to generate a ﬁxed number of self-
play games, and then randomly sample 50% of the gener-
ated data to break correlation and use them to train M .
After a number of epochs of training, the newer version
of M , is evaluated against M ∗ and a human player on a

8

Figure 8: Summary of our training framework.

certain number of games. If M defeats M ∗ by more than
55%, then M ∗ and Mp can optionally be updated with M ,
depending on whether M is overﬁtting to a policy, which
is measured by its performance increase against a versatile
and dynamic human player, or whether Mp is chosen to be
the greedy player, in which case Mp will not be updated.
Note that variations to the above reinforcement process is
possible. For example, it is possible to have M ∗ and Mp to
be the same model, to have a diﬀerent win rate threshold,
to have M ∗ instead of M match against Mp to generate
training data, or to discard the use of Mp and M ∗ alto-
gether so that the training is always iterating on the only
model M . While initial experiments show that these vari-
ations bring little diﬀerence in terms of a trained models
win rate against human players, whether diﬀerences in the
reinforcement process can profoundly impact the training
and performance of the model remains an open question
worth further exploration.

In contrast to the generation of heuristic-guided self-
plays, the rate at which MCTS-guided plays are generated
are remarkably slow. On average, it takes around 120 min-
utes to generate 180 self-play games with 175 simulations
per Monte Carlo tree search on 12 CPUs @ 3.7GHz after
the generation procedure has been parallelised, yielding
an average of 1.5 minutes per game. Another pitfall was
that MCTS-guided plays also suﬀered the lack of game-
play diversity. To mitigate this, the level of exploration by
the agent during training is increased using the following
strategies:

• First 6 moves of the game are randomly chosen

• Subsequent 10 moves use a large temperature t, typ-

ically 1 or 2, for post-search decision

• The remainder of the game is played deterministi-
cally with t = 0.01, so that the best possible moves
are always chosen by the agents.

dimension as the number of valid actions is drawn from
the Dirichlet distribution where α = 0.03, and the vector is
added to the move prior at the root node with weight 0.25,
following the practices from Silver et al. (2017b). This en-
courages all immediate next moves to be tried. Figure 8
summarises the overall training framework.

3.6. Alternative Approaches

In addition to the approach described above, we also
experimented two alternative approaches for comparison:
Deep Q-Learning and tabularasa reinforcement learning.

Q-Learning. Like all traditional reinforcement learning
approach, Q-learning consists of ﬁve major components:
a set of all possible states, a set of all possible actions, a
transition probability distribution describing the probabil-
ity over what state it would transit to by taking a speciﬁc
action in a given state, a discount factor controlling the
balance between gaining short-term reward and long-term
reward and a reward function which takes a state and an
action and outputs the corresponding reward of taking this
action in this state. By making a move in a given state,
the agent will get a positive or negative immediate reward
and the ultimate goal of Q-Learning is to maximize the
accumulated reward.
In other words, we are trying to
maximize the value of:

R(S0, a0) + δR(S1, a1) + δ2R(S2, a2) + ...

(7)

where R is the reward function mapping a particular state
Si and the action ai to a real-valued reward, and δ is a
discount factor with range 0 ≤ δ ≤ 1. To manage this
accumulated reward with more ease, the above formula
could be transformed into a recursion by deﬁning Q(S, a)
as the accumulated reward in state S when we perform
action a. Thus, the action we choose in a certain state
would be the action resulting into the maximum Q value:

The number of moves to play randomly and explo-
ratively are determined empirically such that the post-
move game state are likely to occur in a normal human-
to-human match while signiﬁcantly contributing to the
In addition, before per-
diversity of future game states.
forming the very ﬁrst simulation of MCTS (i.e. when the
search tree is empty), a small noise vector with the same

Q(S, a) = R(S, a) + δ

(cid:88)

Psa(S(cid:48)) max

a

Q(S(cid:48), a(cid:48))

(8)

where S(cid:48), a(cid:48) is the next state and action, Psa gives the state
transition probability with a given state, and (cid:80)
S Psa(S) =
1 and Psa(S) ≥ 1. To calculate the actual value for all
Q(S, a), a method called Value Iteration is developed. By

9

initializing all Q(S, a) with arbitrary value, we consistently
updates all Q(S, a) with the diﬀerence of current Q(S, a)
and the new Q(S, a) we estimated through actually per-
forming action a in state S and observing the immediate
reward. The details for this algorithm is provided in Al-
gorithm 1.

Algorithm 1 Value Iteration

1: Initialize Q(s, a) arbitrarily
2: repeat
3:
4:
5:

for each episode do

6:

Choose a from s using policy derived from Q
Take action a, observe r, s(cid:48)
Q(s, a) ← Q(s, a) + α[r + γ maxa(cid:48) Q(s(cid:48), a(cid:48)) −
Q(s, a)]
s ← s(cid:48)
end for

7:
8:
9: until s is terminal

Although mathematically there is a guarantee that
Value Iteration would converge to the actual Q-value, in
so many cases the number of all possible state and action
pair is incredibly large, which could not be ﬁtted into the
memory. To solve this problem, we adapted the approach
from Mnih et al. (2015), which uses a convolutional net-
work that takes the state as the input and predict the
Q(s, a) values.

The major diﬀerence between our game and Atari
games is that Atari games has a deterministic environ-
ment, which means given a certain state and its history
we can actually predict what state the environment will
transit into. However, in our case the state transition does
not only depend on the current state and the action the
agent picks but also the action the opponent picks. In this
scenario, simply randomizing the opponents move is not
particularly preferable, since random move normally leads
to tie and does not provides very useful guidance for the
agent. In order to help the agent to learn the optimal pol-
icy eﬃciently, we need to set up an opponent with good
performance. Thus the greedy policy agent is used as its
opponent.

With this pre-deﬁned opponent, we can set up the tran-
sition probability and the rewarding mechanism. For sim-
plicity, the transition probability given a state and the
chosen action is one divided by the number of valid moves
so that it promotes generality. To encourage the agent to
move forward and learn to move backward for long-term
beneﬁt, we designed the rewarding system to give a pos-
itive reward equivalent to the number of rows it jumps
across in the forward direction in this move and give a
negative reward equivalent to the number of rows it jumps
across in the backward direction, multiplied by 0.01. And
when all the checker pieces arrived the other side of the
board resulting into victory, we give the agent a very large
reward which in our case set to be 10. With such reward-
ing mechanism, it is shown that the agent has learned the

10

technique of moving a small step backward so that it could
gain larger rewards in the next few moves.

As for the network architecture, the major structure
is the same as the structure we mentioned in the previ-
ous subsection. To ﬁt into Q-Learning usage, the input
and output layer are modiﬁed. Since one training exam-
ple only includes the Q-value for one state-action pair and
the network outputs the Q-values for all actions associ-
ated with the input state, we need to add a mask in the
ﬁnal output layer to make sure the loss will only include
the action we choose. This is accomplished by setting up
an additional input layer with the same dimension as the
output layer as the mask. During the updating process,
only the index representing the action we choose is set to
be 1 and all the other elements in the mask input vector
are ﬁlled with 0. In this way, regression can be performed
for a single output neuron. To make a prediction, we use
a vector all ﬁlled with 1 as the mask input vector.

To generate the training data, we need the agents to ac-
tually play the game and get the reward from the environ-
ment. Thus, a pair of the state and action with their cor-
responding Q-value would be one training example. There
are generally two ways to choose action for the agent dur-
ing the process of generating training data. The ﬁrst way
is randomly choosing one action from the valid action set,
which turns out to be a good option when the training
process just started as it emphasizes on exploration. The
second way is picking the action with the highest Q-value
from the networks output, which will be eﬀective during
the later stage of training as it concentrates on exploita-
tion. To combine the advantages of these two approaches,
we used a method called epsilon-greedy policy, where we
keep a probability (cid:15) for choosing an action randomly in-
stead of deterministically based on the network’s output.
Initially, epsilon is set to be 1 and as the training process
going we gradually decrease the epsilon until the epsilon
reaches 0.1 so that in the later stage of the training pro-
cess we will have a much higher probability to choose the
action based on the network’s output and at the begin-
ning we are more likely to choose the action randomly. A
graphical illustration of the epsilon schedule is illustrated
in Figure 9.

In order to perform regression, we need to deﬁne a loss
function, and the commonly used Mean Square Error is
problematic in this case because larger errors are empha-
sized over smaller errors due to the square operation; large
errors will lead to radical change of the network which in
turn change the target value dramatically.
In compari-
son, Mean Absolute Error addresses this problem, but the
penalty for larger errors is insuﬃcient. To keep a balance
between these two loss functions, we used a special loss
function called Huber Loss, which uses Mean Square Er-
ror for low error and Mean Absolute Error for large error.

Figure 9: Q-Learning Epsilon-Greedy schedule over training. x-axis
represents the number of episodes divided by 10,000. y-axis repre-
sents the value of (cid:15).

Figure 10: Agent overﬁtting to a speciﬁc policy, indicated by sudden
increase in win rate against another model. Note that log-scale is
used for y-axis due to the diﬀerences in data magnitudes and spikes
in the models loss.

The equation of Huber Loss function is provided below:

Huber(a) =






1
2

a2,

|a| −

1
2

,

for |a| ≤ 1

(9)

otherwise

(10)

Tabula rasa Reinforcement Learning. We experimented
with the training approach similar to that described in Sil-
ver et al. (2018), where an agent, denoted by M0, is trained
based solely on MCTS-guided reinforcement learning. In-
stead of using a guidance, M0 is trained directly from the
second stage of the current training pipeline, starting from
scratch and total random plays and uses MCTS to guide
its plays against itself to generate training data, where
the policy labels and value labels are the post-tree-search
move prior and the actual game outcome respectively. All
other training conﬁgurations are adapted from Table 1,
with minor necessary modiﬁcations such as learning rate
and regularisation strength.

The single most important problem with tabula rasa
learning in Chinese Checkers is that when agents are
trained starting from random play, the self-play game may
never ﬁnish. To address this problem, we introduced two
mechanisms: a soft limit on the total number of moves, and
a diﬀerent reward policy that encourages forward move-
ment without requiring the game to reach a win state.
The soft move limit involves setting a constant T to be
the initial allowed number of moves of the game; if no
progress, which is deﬁned by the net increase in the num-
ber of checkers moved into the opponents base, has been
made by either player within T moves, then the game is
terminated. When progress has been made, the allowed
number of moves would be incremented by T , and the pro-
cess repeats as the game continues. The outcome of the
game is determined by the following reward policy: once
the game terminates, both players total forward distance

11

in the game is ﬁrst computed to be the sum of the num-
ber of rows that a players checkers have advanced in the
board, and then the absolute diﬀerence Dp between the
distances is computed. The player with a larger forward
distance is considered the winner if Dp is greater than a
pre-set threshold Dt, in which case this player is given a
reward of 1 while the other player receives a reward of -1.
When Dp < Dt, the game is considered draw, which is not
a possible outcome in the two-stage training framework.
Overall, this reward policy introduces the distinction be-
tween good or bad moves, instead of having a reward of 0
everywhere. In our implementation, Dt was set to 3, and
the soft limit T was set to 100.

4. Experiments, Results, and Analysis

In this section, we ﬁrst present and discuss the train-
ing and the performance of the agent, and we present the
details and results of the experiments conducted on sev-
eral important aspects of the training framework includ-
ing game initialisation techniques and other ﬁne-grained
hyper-parameters, and we discuss how each of these as-
pects may aﬀect the agents performance.
In addition,
we compare the current training framework with other
approaches including Q-Learning and tabula rasa rein-
forcement learning. For most experiments, we use the
greedy agent as a baseline for comparison unless otherwise
stated, since the heuristic is always robust and determin-
istic (though not necessarily optimal) under various game
states and its local optimality means it has a constant per-
formance.

4.1. Training

Main approach. The ﬁnal training conﬁguration are sum-
marised in Table 1. Training is done on 12 CPUs and

Final Training Conﬁgurations

Input dimension
Output dimension policy vector
Output dimension policy vector
Dirichlet noise weight
Dirichlet parameter α
Game move limit
Reward policy
Batch Size
L2 regularisation λ in heuristic stage
L2 regularisation λ in MCTS stage
Learning rate
Optimizer
Number of epochs in heuristic stage
Number of epochs in MCTS stage
Number of self-play games in heuristic stage
Number of self-play games in MCTS stage
Number of evaluation games
Number of Monte Carlo simulations
Temperature parameter τ for exploratory play
Temperature parameter τ for deterministic play
Number of moves in exploratory play
Tree search exploration constant c
Initial random moves
Hardware CPU
Hardware GPU
Memory limit

IR7×7×7
IR294
IR
0.25
0.03 (as vector)
100
1 for win, -1 for loss
32
1e-4
5e-3
1e-4
SGD + Nesterov
100 in total
5 per episode
15000 in total
180 per episode
24
175
2
1e-2
5 per player
3.5
3 per player
12 Intel i7
1 Nvidia GTX 1080
32 GB

Table 1: Final training conﬁgurations for the main approach.

1 NVIDIA GeForce 1080 GPU: for the ﬁrst stage of the
training pipeline, the agent is supervised by heuristics for
100 epochs; in each epoch, 15,000 heuristic-guided self-
plays are generated, yielding approximately 40,000 to
50,000 training examples given average game length of 40
moves, the two-fold data augmentation, and 4% data re-
tention rate. The agent is then trained on these exam-
ples for 2 iterations before continuing to the next epoch.
For the second stage of the training pipeline, 180 self-play
games are generated in each episode from self-play games
using the current best model M ∗ with 175 Monte Carlo
simulations for each action. By combining training data
from the previous episode and randomly sampling 50% of
them, around 18,000 training examples are retained for
each episode. During the second stage of training, how-
ever, the model can easily overﬁt to the generated exam-
ples due to the relatively small number of training exam-
ples compared to the ﬁrst stage. Figure 10 depicts the loss
curve of an overﬁtting model and its performance when
matched against the initial version of itself. It can be ob-
served that as the loss decreases, the agent in fact learns
a counter-policy speciﬁcally for its opponent, which is the
initial model out of the ﬁrst stage of the training pipeline.
The overﬁtting is indicated by the sudden increase in the
number of wins at version 46, but very few wins by the
earlier versions. In order to prevent overﬁtting, the agent

is trained on the examples generated in each episode for
only 5 epochs before continuing to the next episode. Fig-
ure 11, on the other hand, illustrates the models learning
progression with regularisation proportionate to the num-
ber of generated examples; it can be observed that the
number of games won against the ﬁrst version is gradually
increasing. Agent evaluation, as described in the previ-
ous section, is done after each episode where the model is
matched against the best agent M ∗ (where no Mp is kept)
so far on 24 games and we update M ∗ with the current
agent if the newer agent is able to defeat M ∗ by at least
14 games.

Q-Learning. During training data collection, the game is
set to the initial state and the training agent is set to play
against the greedy policy agent until the end of the game
using the epsilon greedy policy mentioned in the previous
section. For every move the training agent made, a tuple
of (St, at, Rt, St+1) is collected, where t is the time step.

In order to train the model more eﬃciently, we also set
a move limit, which means the total amount move made
by the agent reaches this limit, this round of game will
terminate. The reason behind this move limit is that ran-
domly choosing move will not typically lead to the normal
termination state which is either all checker pieces of the
agent moves to its opponents base or other way around
and we only want to keep those moves that may leads to

12

Figure 11: Loss curve and model performance of the current model
architecture with suitable regularisation.

Figure 12: Q-Learning Mean Absolute Error for every 10,000 training
episodes.

improvement to the model. During our training process,
we set the move limit to be 40 which is slight higher than
the average number of moves greedy algorithm agent takes
to ﬁnish the game against itself.

To prevent the model from divergence, we adapt the
method called experience replay into our training process:
in each iteration, instead of updating the network based
on the move that were just made, we keep a ﬁnite training
data pool (in our case the limit is set to 1,000,000 training
examples) and in each iteration we randomly pick a mini-
batch of training data (in our case the size of mini-batch
is 32) from the training data pool to update the network.
Before training begins, we pre-ﬁll the training data pool
with 5000 training examples, so that it is highly unlikely
to include successive states in the mini-batch.

In summary, for each epochs of the training process, we
initialise a game with the initial state and let the training
agent play against the greedy policy agent to the end us-
ing epsilon greedy policy. Every time the agent makes an
action, the (St, at, Rt, St+1) tuple is added into the train-
ing data pool. Once the size training data pool reaches a
threshold, a mini-batch is drawn randomly from the pool
to update the network. Throughout the entire training
process, 10,000,000 epochs are run and around 400,000,000
training tuples are generated. The mean absolute error
during training is illustrate in Figure 12.

Tabula rasa Reiniforcement Learning. The training pro-
cedure for this approach is similar to that of the main ap-
proach, except that the ﬁrst stage of the training pipeline
is removed. Most training conﬁgurations are identical to
that described in Table 1, except that the reward policy
is diﬀerent as described in the previous section. Starting
from a random model M0, in each episode we generate
180 self-play games where each step uses 175 Monte Carlo
simulations, yielding approximately 7,000 training exam-
ples per episode and they are iterated for 5 epochs before
continuing to the next episode, identical to the stage 2

Figure 13: Typical huddle-formation (blue) to prevent the opponent
(red)s checkers from hopping.

training pipeline of the main approach. An additional op-
ponent model Mp is kept for generating training data, and
is replaced with the newest version of M0 when the win
rate exceeds the pre-deﬁned threshold.

4.2. Performance

Main approach. The performance of the agent is sum-
marised in Table 2. The computing resource used for test-
ing is one Intel i7 CPU @ 3.7GHz.
In each game, the
thinking limit for each step is set to 180 Monte Carlo tree
searches, leaving a thinking time of approximately 3 sec-
In total, the trained agent was tested by playing
onds.
300 games against the agent directly following the greedy
heuristic and 100 games against a proﬁcient Chinese check-
ers human player. The trained agent was able to achieve
roughly 90% win rate against the greedy player and 63%
against a human player. Abandoned games are infrequent
and are mostly due to the agent refusing to move its last
checkers out of its base to avoid its imminent loss, which
it
can be foreseen from its lookahead search. Overall,
is reasonable to conclude that the agent is very robust
against the greedy agent and strong against experienced

13

Opponent
Greedy Agent
Human

Agent Wins Agent Losses Game Abandoned Total Agent Elo Rating Change
271 (90.3%)
63 (63%)

28 (9.3%)
32(32%)

+392
+111

300
100

1
5

Table 2: Performance of the main approach agent.

Figure 14: Q-Learning accumulated reward from testing after every
10,000 episodes of training. x-axis represents the test game number,
and the y-axis represents the accumulated reward.

Figure 15: Loss history over epochs for training an agent from scratch
through tabula rasa reinforcement learning.

human players, and we argue that this is partially due to
the eﬀective look-ahead Monte Carlo tree search, where
the agent can deliberately interfere with the long, consec-
utive hops that the greedy agent is best at. For example,
the agent would aim to block or break opponents checker
“bridges” as they are forming, either by intruding with its
own checkers or removing its checkers that are part of the
bridges. When played against humans, the agent exhibits
greedy-like traits such as seeking to take the longest hops,
but it also learns to form strategies such as the bridge and
to occasionally sacriﬁce locally optimal moves for a bet-
ter long-term strategy. For example, in a local game state
depicted by Figure 13, the agent (blue) would prefer to
maintain its huddle-formation (where the 4 checkers stick
together) to block the red checkers from hopping over, in-
stead of taking the locally optimal move of advancing its
checkers and breaking the cluster.

However, the agent also has a few weaknesses. When
exploration is disabled during testing (with temperature t
set to 0.01 for Monte Carlo tree search and no initial ran-
dom moves), we can hardly observe diversity in its starting
strategies. In addition, it rarely takes several locally sub-
optimal moves in a row for a better global strategy. We
conjecture that the agent is partially bias towards greedy-
moves due to its heuristic-guided initialisation; however,
it is believed that this condition can be mitigated and its
performance can be further improved through further self-
play reinforcement learning.

Q-Learning. After training to convergence, we evaluate
the performance of Q-Learning agent by playing against

14

the greedy policy agent. The accumulated reward after
each game played at the end of every 10,000 episode (to-
talling 1,000 games) is illustrated in Figure 14, where the
y-axis represents the reward value. By observing the game,
we ﬁnd that the Q-Learning agent successfully learns some
basic strategies such as sacriﬁcing checker progress by mov-
ing back checker pieces for better long-term plays. During
the beginning of the game, it even outperformed greedy
policy agent dramatically. However, as the game goes on,
the performance of the agent drops signiﬁcantly as it starts
to focus on one checker only and later randomly acting. By
analyzing the training data, we ﬁnd that this is due to the
fact that by following the epsilon-greedy policy, the agent
tends to ignore some checker pieces to maximize the tem-
porary reward. As greedy policy agent quickly blocks the
path of the checker pieces left behind, the game almost
always ends with a tie, which leads to insuﬃcient training
data for the later part of the game. We argue that the
problem is mainly due to the nature of the game and the
complexity of it such that Q-learning may not be suitable.

Tabula rasa reinforcement learning. A model M0 with ran-
domly initialized weights is trained for approximately 2
days using the training techniques and conﬁgurations as
described in the previous sections, including time for gen-
erating training examples and training the model. The
training loss history over epochs is illustrated in Figure
15: while it appears that the loss is slowly decreasing
over time, it is evident that the learning was fairly in-
eﬃcient. In addition, the loss value was volatile and show
little signs of further decrease. Not surprisingly, when the

trained model is matched against the best agent trained
using the two-stage pipeline approach, it wins 0 out of
100 games. We argue that the failure is primarily due to
two reasons. First, while the reward policy encourages the
agent to move forward by rewarding the agent positively
for more forward distance than its opponent, the reward
policy does not however give the agent a consistent win
state. In other words, so long as the current player has
more forward distance, the win state can be drastically
diﬀerent while the value head of the network receives the
same reward. Therefore, the gradients from both the value
and policy head of the network can be ambiguous and not
eﬀective for training as the agent does not always receive
consistent feedback. Secondly, the amount of training data
used may be insuﬃcient to train such a large model. Since
the agent is trained starting from totally stochastic plays,
the duration for a self-play game can be unbounded and
hence the game is almost always terminated by a pre-set
move limit, which, however, must be large enough so that a
clear winner can be identiﬁed at the games terminal state.
With these drawbacks, the eﬃciency of the data genera-
tion process is far from the that achieved by the two-stage
training framework.

4.3. Experiments on Game Initialisation Techniques

Another important aspect of the training framework is
how diﬀerent game initialisation techniques may aﬀect self-
play data generation, and thereby inﬂuencing the agents
ability to adapt to diverse scenarios. As discussed in the
previous section, two important game initialisation tech-
niques that were deployed to introduce stochasticity to the
data generation process include randomising the starting
positions of all checkers and forcing the agent to take a
ﬁxed number of random moves at the beginning of each
game.

Randomising starting positions. This technique was ini-
tially proposed and implemented to address the lack of
diversity of game-play patterns when generating heuristic-
guided self-plays, as the number of unique move sequences
are very limited if the agent always follows the same heuris-
tic. However, through controlled experiments it was found
that the eﬀectiveness of this technique on the agents per-
formance is relatively small.

For experiment, we trained two greedy agents, denoted
by MR and MN , on heuristic-guided self-play data, where
MR is trained entirely on games with random starting
state while MN is trained entirely on games with nor-
mal starting conditions. No other initialisation techniques
were used. Starting from random models, both agents
are trained for 100 epochs, and in each epoch 15,000 new
games are generated and 5% of training examples are re-
tained for breaking correlation. All other training conﬁg-
urations follow those described in Table 1.

By matching the two trained agents, we observed that
the MN is able to easily defeat MR with an win rate of over
80%. We also observed that MR would often pick actions

that are clearly locally sub-optimal, which is rather sur-
prising as it was trained on a heuristic that always prefers
locally optimal moves. We argue that this outcome is due
to two factors:

1. Most randomised starting states (and hence the sub-
sequent states) are not representative of the distri-
bution of the game states drawn from real matches.
2. Since there is a large number of possible states, the
performance of the agent depends heavily on what
samples were generated during training.

However, by training the agent on vastly diﬀerent ex-
amples in each epoch, this technique has a positive impact
of acting as a strong regulariser to the network, because
when trained on such data the agent must extract more
robust features from the board for making predictions in-
stead of memorising or relying on a ﬁxed pattern in the
plays. This beneﬁt is manifested by the fact that MR is
able to cope, though not necessarily optimally, with the
highly likely unseen moves from its normatively trained
opponent MN during matches and win a certain propor-
tion of them.

For the above reasons, this technique is still deployed
when generating 50% of heuristic-guided self-play data.
However, it is not used during MCTS-guided self-play rein-
forcement learning because the agent should be reinforced
on real game-play data only.

Initial random moves. Unlike randomising starting posi-
tions, forcing initial random moves of the agents can still
result in game trajectories that are highly representative
of the real game states distribution, but such initialisation
can lead to much more diverse game-plays.

For experiment, we trained two agents MS and MN ,
where MN is trained on a set of heuristic-guided self-plays
where 50% of the games started with the standard initial
state while the other 50% started with a random state. In
contrast, MS is also trained on a set of heuristic-guided
self-plays, but 50% of games started with a random state,
20% of the games started with the normal initial state, and
30% of games started with 3 random moves by each player.
The reason for having 50% of the training data to be drawn
from games with a random starting state is to reduce the
tendency for overﬁtting to initial starting strategies for
both agents. All other training conﬁgurations remain the
same as that described earlier.

By matching the greedy agent with each of MS and
MN where MS and MN are both guided by MCTS during
the matches, we observed that MS actually outperformed
MN as indicated by a 10% increase in the win rate against
the greedy agent, where MS won 77/100 games against the
greedy agent while MN only won 67/100 against the same
agent. We argue that this is because by introducing ini-
tial random moves, the agent is exposed to more starting
strategies that the greedy agent would not have explored
due to the apparent sub-optimality of these strategirs.
However, by further increasing the percentage of games

15

with random initial moves (while decreasing the percent-
age of games with normative starting states), we observe
very little improvements in the agents performance. For
these reasons, we retain 30% of the self-plays to begin with
random initial moves. The optimal number of initial ran-
dom moves, however, remain an open area for further ex-
ploration, although throughout the experiments 3 random
moves per player is observed to be a good default setting.

4.4. Additional critical hyper-parameters

Number of Monte Carlo simulations. Through controlled
experiments of matching the agent against the greedy player,
we observed that an increasing number of Monte Carlo
simulations performed by the model would lead to a per-
formance at least as good as the model allowed less sim-
ulations, as indicated by the win rate against the greedy
player. However, we also observed that as the number of
simulations becomes large (> 500), the marginal gain in
performance decreases sharply while the compute resource
required increases constantly. Another factor of consider-
ation during our experiments was that performing a large
number of simulations incurs heavy memory footprint; for
example, since the Expansion stage of MCTS is performed
in each simulation and on average there are 30 possible
valid next actions, a single worker process running only 200
simulations will require storing more than 6,000 copies of
game states in memory, which means around 72,000 copies
of game states need to be cached with 12 independent
workers. Through empirical analysis, 175 Monte Carlo
simulations for each action was a good default for balanc-
ing the performance of and the resource required by the
model.

Tree search exploration constant c. The constant c in the
MCTS selection stage controls the level of exploration of
the agent during the search. Controlled experiments against
the greedy agent indicates that this constant has a rela-
tively small impact on the performance of our agent. How-
ever, a large c > 3.5 tends to lead to an increase in per-
formance (approx. 2% increase in win rate) compared to
the default choice of c = 1, especially in the case when
the number of simulations is large. The value c = 3.5 is
found by grid search to be a good default choice. While
the eﬀect of this constant is not always consistent, we do
observe minor but consistent deterioration in the agents
performance when a small number of Monte Carlo tree
search < 100 is combined with a large c > 3.5. We argue
that this is because as the agent is encouraged to explore
other moves, it may not be able to search deeper into the
game tree for planning non-local strategies.

5. Conclusion and Future Work

In this work, we have presented an approach for build-
ing a Chinese Checker agent that reaches the level of ex-
perienced human players with an eﬀective combination of

heuristics, Monte Carlo Tree Search (MCTS), and deep
reinforcement learning. Through experimentation, we ob-
served that the trained agent has learn common strategies
played in Chinese Checkers and is robust to the dynamic
states in the game. However, it remains an open topic
worth further research that whether a Chinese Checker
agent can be built tabula rasa to overcome some of the
drawbacks of our agent as identiﬁed in this work, and
whether expert-level multi-agents are possible in Chinese
Checkers.

References

Allis, V. (1994). Searching for Solutions in Games and Artiﬁcial

Intelligence. Ph.D. thesis Maastricht University.

Bell, G. I. (2008). The shortest game of chinese checkers and related

problems. CoRR, abs/0803.1245 .

Browne, C. B., Powley, E., Whitehouse, D., Lucas, S. M., Cowling,
P. I., Rohlfshagen, P., Tavener, S., Perez, D., Samothrakis, S.,
& Colton, S. (2012). A survey of monte carlo tree search meth-
ods. IEEE Transactions on Computational Intelligence and AI
in Games, 4 , 1–43. doi:10.1109/TCIAIG.2012.2186810.

Bulitko, V., Bjrnsson, Y., Sturtevant, N. R., & Lawrence, R. (2011).
Real-time heuristic for path ﬁnding in video games. In Artiﬁcial
Intelligence for Computer Games (pp. 1–30). Springer.

Chen, R. S., Lucier, B., Singer, Y., & Syrgkanis, V. (2017). Robust
In Advances in Neural

optimization for non-convex objectives.
Information Processing Systems (NIPS) (pp. 4705–4714).

Churchill, D., Saﬃdine, A., & Buro, M. (2012). Fast heuristic search

for rts game combat scenarios. In AIIDE .

Ciancarini, P., & Favini, G. P. (2010). Monte carlo tree search in
kriegspiel. Artiﬁcial Intelligence, 174 , 670–684. doi:https://doi.
org/10.1016/j.artint.2010.04.017.

Conitzer, V., & Sandholm, T. (2003). Bl-wolf: A framework for loss-
bounded learnability in zero-sum games.
In Proceedings of the
20th International Conference on Machine Learning (ICML-03)
(pp. 91–98).

Coulom, R. (2007). Eﬃcient selectivity and backup operators in
monte-carlo tree search. In Lecture Notes in Computer Science.
Springer volume 4630.

Cui, X., & Shi, H. (2011). A*-based path ﬁnding in modern computer
games. International Journal of Computer Science and Network
Security, 11 , 125–130.

Finnsson, H., & Bj¨ornsson, Y. (2008). Simulation-based approach to

general game playing. In AAAI (pp. 259–264). volume 8.

Fonseca, N. (2016). Optimizing a Game of Chinese Checkers. Tech-

nical Report Bridgewater State University.

Gelly, S., & Silver, D. (2008). Achieving master level play in 9 x
In AAAI (pp. 1537–1540). volume 8. URL:

9 computer go.
http://www.aaai.org/Papers/AAAI/2008/AAAI08-257.pdf.

Ghory, I. (2004). Reinforcement learning in board games. Depart-
ment of Computer Science, University of Bristol, Tech. Rep, (p.
105).

Glorot, X., & Bengio, Y. (2010). Understanding the diﬃculty of
training deep feedforward neural networks. In Proceedings of the
Thirteenth International Conference on Artiﬁcial Intelligence and
Statistics (pp. 249–256). PMLR volume 9 of Proceedings of Ma-
chine Learning Research.

Greenwald, A., Hall, K., & Serrano, R. (2003). Correlated q-learning.

In ICML (pp. 242–249). volume 3.

Guo, X., Singh, S., Lee, H., Lewis, R. L., & Wang, X. (2014). Deep
learning for real-time atari game play using oﬄine monte-carlo tree
search planning. In Advances in Neural Information Processing
Systems (NIPS) (pp. 3338–3346).

He, K., Zhang, X., Ren, S., & Sun, J. (2016). Deep residual learn-
ing for image recognition. 2016 IEEE Conference on Computer
Vision and Pattern Recognition (CVPR), (pp. 770–778).

16

Szita, I., Chaslot, G., & Spronck, P. (2009). Monte-carlo tree search
in settlers of catan. In Advances in Computer Games (pp. 21–32).
volume 6048.

Tesauro, G. (2004). Extending q-learning to general adaptive multi-
In Advances in Neural Information Processing

agent systems.
Systems (NIPS) (pp. 871–878).

Thrun, S. (1995). Learning to play the game of chess. In Advances in
Neural Information Processing Systems (NIPS) (pp. 1069–1076).
Van Hasselt, H., Guez, A., & Silver, D. (2016). Deep reinforcement
learning with double q-learning. In Thirtieth AAAI Conference
on Artiﬁcial Intelligence.

Waugh, K., & Bagnell, J. A. (2015). A uniﬁed view of large-scale

zero-sum equilibrium computation. In AAAI .

Ioﬀe, S., & Szegedy, C. (2015). Batch normalization: Accelerating
deep network training by reducing internal covariate shift.
In
ICML.

Khalifa, A., Isaksen, A., Togelius, J., & Nealen, A. (2016). Modifying
mcts for human-like general video game playing. In IJCAI (pp.
2514–2520).

Kovarsky, A., & Buro, M. (2005a). Heuristic search applied to ab-
In Lecture Notes in Computer Science.

stract combat games.
Springer volume 3501.

Kovarsky, A., & Buro, M. (2005b). Heuristic Search Applied to Ab-
stract Combat Games. In B. K´egl, & G. Lapalme (Eds.), Advances
in Artiﬁcial Intelligence (pp. 66–78). Springer Berlin Heidelberg.
Krizhevsky, A., Sutskever, I., & Hinton, G. E. (2012). Imagenet clas-
siﬁcation with deep convolutional neural networks. In Advances in
Neural Information Processing Systems (NIPS) (pp. 1097–1105).
Lagoudakis, M. G., & Parr, R. (2003). Learning in zero-sum team
markov games using factored value functions.
In Advances in
Neural Information Processing Systems (NIPS) (pp. 1659–1666).
Lample, G., & Chaplot, D. S. (2017). Playing fps games with deep

reinforcement learning. In AAAI .

LeCun, Y., Bottou, L., Bengio, Y., Haﬀner, P. et al. (1998).
Gradient-based learning applied to document recognition. Pro-
ceedings of the IEEE , 86 , 2278–2324.

Li, L., Lv, Y., & Wang, F. (2016). Traﬃc signal timing via deep re-
inforcement learning. IEEE/CAA Journal of Automatica Sinica,
3 , 247–254. doi:10.1109/JAS.2016.7508798.

Mnih, V., Kavukcuoglu, K., Silver, D., Graves, A., Antonoglou, I.,
Wierstra, D., & Riedmiller, M. A. (2013). Playing atari with deep
reinforcement learning. CoRR, abs/1312.5602 .

Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J.,
Bellemare, M. G., Graves, A., Riedmiller, M., Fidjeland, A. K.,
Ostrovski, G. et al. (2015). Human-level control through deep
reinforcement learning. Nature, 518 , 529.

Oh, I.-S., Cho, H., & Kim, K.-J. (2017). Playing real-time strategy
games by imitating human players micromanagement skills based
on spatial analysis. Expert Systems with Applications, 71 , 192–
205.

Pendharkar, P. C. (2012). Game theoretical applications for multi-
agent systems. Expert Systems with Applications, 39 , 273–279.
Pepels, T., Winands, M. H. M., & Lanctot, M. (2014). Real-time
monte carlo tree search in ms pac-man. IEEE Transactions on
Computational Intelligence and AI in Games, 6 , 245–257. doi:10.
1109/TCIAIG.2013.2291577.

Rosin, C. D. (2011). Multi-armed bandits with episode context.
Annals of Mathematics and Artiﬁcial Intelligence, 61 , 203–230.
doi:https://doi.org/10.1007/s10472-011-9258-6.

Silver, D., Hubert, T., Schrittwieser, J., Antonoglou, I., Lai, M.,
Guez, A., Lanctot, M., Sifre, L., Kumaran, D., Graepel, T., Lilli-
crap, T., Simonyan, K., & Hassabis, D. (2017a). Mastering chess
and shogi by self-play with a general reinforcement learning algo-
rithm. arXiv:1712.01815.

Silver, D., Hubert, T., Schrittwieser, J., Antonoglou, I., Lai, M.,
Guez, A., Lanctot, M., Sifre, L., Kumaran, D., Graepel, T., Lil-
licrap, T., Simonyan, K., & Hassabis, D. (2018). A general re-
inforcement learning algorithm that masters chess, shogi, and go
through self-play. Science, 362 , 1140–1144. doi:10.1126/science.
aar6404.

Silver, D., Schrittwieser, J., Simonyan, K., Antonoglou, I., Huang,
A., Guez, A., Hubert, T., Baker, L., Lai, M., Bolton, A., Chen,
Y., Lillicrap, T., Hui, F., Sifre, L., van den Driessche, G., Graepel,
T., & Hassabis, D. (2016). Mastering the game of go with deep
neural networks and tree search. Nature, 550 .

Silver, D., Schrittwieser, J., Simonyan, K., Antonoglou, I., Huang,
A., Guez, A., Hubert, T., Baker, L., Lai, M., Bolton, A., Chen, Y.,
Lillicrap, T., Hui, F., Sifre, L., van den Driessche, G., Graepel,
T., & Hassabis, D. (2017b). Mastering the game of go without
human knowledge. Nature, 550 , 354. URL: https://doi.org/10.
1038/nature24270.

Stanley, K. O., Bryant, B. D., Karpov, I., & Miikkulainen, R. (2006).
Real-time evolution of neural networks in the nero video game. In
AAAI (pp. 1671–1674). volume 6.

17

