AiDroid: When Heterogeneous Information Network Marries Deep Neural
Network for Real-time Android Malware Detection
Yanfang Ye∗1, Shifu Hou1, Lingwei Chen1, Jingwei Lei2, Wenqiang Wan2,
Jiabin Wang2, Qi Xiong2, Fudong Shao2
1Department of Computer Science and Electrical Engineering
West Virginia University, Morgantown, WV, USA
yanfang.ye@mail.wvu.edu, {shhou, lgchen}@mix.wvu.edu
2Tencent Security Lab, Tencent, Guangdong, China
{lingfonglei, johnnywan, luciferwang, keonxiong, joeyshao}@tencent.com

9
1
0
2

y
a
M
0
2

]

R
C
.
s
c
[

2
v
7
2
0
1
0
.
1
1
8
1
:
v
i
X
r
a

Abstract

The explosive growth and increasing sophistication of An-
droid malware call for new defensive techniques that are ca-
pable of protecting mobile users against novel threats. In this
paper, we ﬁrst extract the runtime Application Programming
Interface (API) call sequences from Android apps, and then
analyze higher-level semantic relations within the ecosystem
to comprehensively characterize the apps. To model different
types of entities (i.e., app, API, IMEI, signature, afﬁliation)
and the rich semantic relations among them, we then con-
struct a structural heterogeneous information network (HIN)
and present meta-path based approach to depict the related-
ness over apps. To efﬁciently classify nodes (e.g., apps) in the
constructed HIN, we propose the HinLearning method to ﬁrst
obtain in-sample node embeddings and then learn represen-
tations of out-of-sample nodes without rerunning/adjusting
HIN embeddings at the ﬁrst attempt. Afterwards, we design
a deep neural network (DNN) classiﬁer taking the learned
HIN representations as inputs for Android malware detection.
A comprehensive experimental study on the large-scale real
sample collections from Tencent Security Lab is performed
to compare various baselines. Promising experimental results
demonstrate that our developed system AiDroid which inte-
grates our proposed method outperforms others in real-time
Android malware detection. AiDroid has already been incor-
porated into Tencent Mobile Security product that serves mil-
lions of users worldwide.

1. Introduction
Due to the mobility and ever expanding capabilities, smart
phones have become increasingly ubiquitous in people’s ev-
eryday life performing tasks such as social networking, on-
line banking, and entertainment. Android, as an open source
and customizable operating system (OS) for smart phones,
is currently dominating the smart phone market by 77.32%
(Statcounter 2018). However, due to its large market share
and open source ecosystem of development, Android attracts
not only the developers for producing legitimate Android ap-
plications (apps), but also attackers to disseminate malware
(malicious software) that deliberately fulﬁlls the harmful in-
tent to the smart phone users (e.g., stealing user credentials,
pushing unwanted apps or advertisements). Because of lack-
ing trustworthiness review methods, developers can easily
upload their Android apps including repackaged apps and
malware to the ofﬁcial marketplace (i.e., Google Play). The

The revised version will be published in IJCAI 2019 entitled “Out-
of-sample Node Representation Learning for Heterogeneous Graph
in Real-time Android Malware Detection”.

presence of other third-party Android markets (e.g., Opera
Mobile Store, Wandoujia) makes this problem worse. Driven
by the considerable economic proﬁts, there has been explo-
sive growth of Android malware which posed serious threats
to the smart phone users - i.e., it’s reported that there have
been 4, 687, 008 newly generated Android malware that in-
fected more than 61 million smart phones in the ﬁrst half
of 2018 (TencentSecurity 2018). To evade the detection of
mobile security products (e.g., Norton, Lookout and Ten-
cent Mobile Security), Android malware has turned to be
increasingly sophisticated. For example, as shown in Fig-
ure 1, the “TigerEyeing” trojan is a new kind of Command
and Control (C&C) malware that pretends to be legitimate
apps (e.g., mobile games, system tools) and only executes
to perform the proﬁtable tasks on-demand. The explosive
growth and increasing sophistication of Android malware
call for new defensive techniques that are capable of pro-
tecting smart phone users against novel threats.

Figure 1: Increasingly sophisticated Android malware.

To combat the evolving Android malware attacks, by
collaboration with smart phone vendors, in this paper, we
ﬁrst extract the Application Programming Interface (API)
call sequences from runtime executions of Android apps
in users’ smart phones to capture their behaviors. To com-
prehensively characterize Android apps, we further analyze
higher-level semantic relationships within the ecosystem,
such as whether two apps have similar behaviors, whether
they co-exist in the same smart phone that can be identi-
ﬁed by its unique International Mobile Equipment Identity
(IMEI) number, whether they are signed by the same devel-
oper or produced by the same company (i.e., afﬁliation), etc.
To model such complex relationships, we present a struc-
tured heterogeneous information network (HIN) (Sun and
Han 2012) and use meta-path based approach (Sun et al.
2011) to build up relatednesses over apps. To efﬁciently clas-
sify nodes (e.g., apps) in the constructed HIN, HIN embed-

 
 
 
 
 
 
Figure 2: Overview of the developed system AiDroid for real-time Android malware detection.

ding methods (Fu, Lee, and Lei 2017; Dong, Chawla, and
Swami 2017; Fan et al. 2018) have been proposed. How-
ever, most of these existing methods are primarily designed
for static networks, where all nodes are known before learn-
ing. As our application requires real-time prediction of new
coming nodes (i.e., unknown apps) to detect Android mal-
ware, it is infeasible to rerun HIN embeddings whenever
new nodes arrive, especially considering the fact that rerun-
ning HIN embeddings also results in the need of retraining
the downstream classiﬁer. How to efﬁciently learn the repre-
sentations of out-of-sample nodes in HIN, i.e. nodes that ar-
rive after the HIN embedding process, remains largely unan-
swered. To solve this problem, we propose the HinLearning
method to ﬁrst obtain in-sample node embeddings and then
learn the representations of out-of-sample nodes in HIN,
which is capable to preserve the heterogeneous property of
HIN and also allows fast and scalable learning. Afterwards,
we design a deep neural network (DNN) classiﬁer leverag-
ing the advantages of convolutional neural networks (CNNs)
and Inception for Android malware detection. We develop
a system AiDroid for real-time Android malware detection,
which has the following major traits:
• Besides runtime behaviors extracted from Android apps,
we further analyze the complex relationships within the
ecosystem (i.e., app-API, app-IMEI, app-signature, app-
afﬁliation, IMEI-signature, IMEI-afﬁliation relations) to
characterize Android apps. We then present HIN to rep-
resent the Android apps and exploit meta-path based ap-
proach to depict the relatednesses over apps. This pro-
vides a comprehensive solution that is capable to be more
resilient against Android malware’s evasion tactics.

• We are the ﬁrst

to propose the method (denoted as
HinLearning) to efﬁciently learn the representations for
out-of-sample nodes in HIN using in-sample node em-
beddings while without rerunning/adjusting them, which
makes the downstream classiﬁer feasible for classifying
new arriving nodes (e.g., apps) without retraining. Though
it’s proposed for real-time Android malware detection, the
HinLearning method is a general framework which is able
to learn desirable node representations in HIN (i.e., in-
cluding in-sample and out-of-sample nodes) and thus can
be further applied to various speed-sensitive dynamic net-
work mining tasks (e.g., node classiﬁcation, clustering).
• We provide a comprehensive experimental study based on
the large-scale real sample collections from Tencent Se-

curity Lab, which demonstrates the effectiveness and ef-
ﬁciency of our developed system AiDroid. It has already
been incorporated into Tencent Mobile Security product
that server millions of users worldwide.

2. System Overview
The overview of our developed system AiDroid for real-time
Android malware detection is shown in Figure 2, mainly
consisting of the following components:
• Feature Extractor. Through the installed Tencent Mobile
Security product, smart phone users can upload the ex-
tracted API call sequences of Android apps as well as the
meta-data to AiDroid. It will then analyze various rela-
tionships among different types of entities (i.e., app, API,
IMEI, signature, afﬁliation) to depict the Android apps.
(See Section 3.1. for details.)

• HIN Constructor. In this module, based on the features
extracted from the previous component, a structural HIN
is ﬁrst presented to model the relationships among dif-
ferent types of entities; and then different meta-paths are
built from the HIN to capture the relatedness over apps
from different views (i.e., with different semantic mean-
ings). (See Section 3.2. for details.)

• HIN Representation Learner. In HinLearning, based on
the meta-path schemes built from the previous module, a
heterogeneous in-sample node embedding method HINE
is ﬁrst proposed to learn the low-dimensional representa-
tions for in-sample nodes in HIN; then, Hin2Img method
is devised to learn representations of out-of-sample nodes
using learned in-sample node embeddings, which is also
capable to enrich representations of in-sample nodes. (See
Section 3.3. for details.)

• DNN Classiﬁer. After representation learning using Hin-
Learning, the learned representations of in-sample nodes
with type of app will be fed to the designed DNN (see
Section 3.4. for details) to train the classiﬁcation model,
based on which new arriving nodes (i.e., out-of-sample
nodes with type of app) can be predicted as either benign
or malicious.

3. Proposed Method
In this section, we introduce the detailed approaches of how
we represent the Android apps, and how to solve Android
malware detection (i.e., classiﬁcation) problem based on the
representations.

3.1. Feature Extraction
Dynamic Behavior Extraction. API calls are used by An-
droid apps in order to access Android OS functionality and
system resources. Therefore, we extract the sequences of
API calls in the application framework from runtime exe-
cutions of Android apps to capture their behaviors. For ex-
ample, a sequence of API calls (StartActivity, checkCon-
nect, getPhoneInfo, receiveMsg, sendMsg, ﬁnishActivity) ex-
tracted from the previous mentioned “TigerEyeing” trojan
represents its typical behaviors of connecting to the C&C
server in order to fetch the conﬁguration information; while
another sequence of its extracted API calls (startActivity,
checkConnect, sendSMS, ﬁnishActivity) denotes its intention
of sending SMS messages without user’s concern. Note that,
to simplify the further computation, each API call in the ex-
tracted sequences will be mapped to an integer ID.
Relation-based Feature Extraction. Besides the API call
sequences extracted from an Android app that can be used
to represent its behaviors, to detect the increasingly sophis-
ticated Android malware, we further consider the following
kinds of relationships.
• R1: To describe the relation between an app and an API
call it invokes during runtime execution, we build the app-
invoke-API matrix I where each element ii,j ∈ {0, 1}
denotes if app i invokes API call j.

• R2: To describe the relation that an app exists (i.e., is in-
stalled) in a smart phone (i.e., IMEI), we generate the app-
exist-IMEI matrix E where each element ei,j ∈ {0, 1}
means if app i exists in phone j.

• R3: Every app run on the Android platform must be
signed by the developer. To depict such relationship, we
build the app-certify-signature matrix C whose element
ci,j ∈ {0, 1} denotes if app i is certiﬁed by signature j.
• R4: Package name (a.k.a. Google Play ID) is the unique
identiﬁer for an Android app. Companies conventionally
use their reversed domain name to begin their package
names (e.g., “com.tencent.mobileqq”). We extract the do-
main name from the package name to denote the relation
between an app (e.g., “mobileqq”) and its afﬁliation (e.g.,
“tencent.com”); and then we generate the app-associate-
afﬁliation matrix A where each element ai,j ∈ {0, 1}
indicates whether app i is associated with afﬁliation j.
• R5: To represent the relation that a smart phone has a
set of apps signed by a particular developer, we create
the IMEI-have-signature matrix H where each element
hi,j ∈ {0, 1} denotes if smart phone i has signature j.
• R6: To denote the relation that a smart phone installs a
set of apps associated with a speciﬁc afﬁliation, we gen-
erate the IMEI-possess-afﬁliation matrix P where each
element pi,j ∈ {0, 1} denotes whether smart phone i pos-
sesses afﬁliation j.

3.2. HIN Construction
In order to depict apps, APIs, IMEIs, signatures and afﬁl-
iations as well as the rich relationships among them (i.e.,
R1-R6), it is important to model them in a proper way so
that different kinds of relations can be better and easier han-
dled. We introduce how to use HIN, which is capable to be

composed of different types of entities and relations, to rep-
resent the apps by using the features extracted above. We
ﬁrst present the concepts related to HIN as follows.
Deﬁnition 1 A heterogeneous information network (HIN)
(Sun and Han 2012) is deﬁned as a graph G = (V, E) with
an entity type mapping φ: V → A and a relation type map-
ping ψ: E → R, where V denotes the entity set and E is
the relation set, A denotes the entity type set and R is the
relation type set, and the number of entity types |A| > 1 or
the number of relation types |R| > 1. The network schema
(Sun and Han 2012) for a HIN G, denoted as TG = (A, R),
is a graph with nodes as entity types from A and edges as
relation types from R.

HIN not only provides the network structure of the data
associations, but also provides a high-level abstraction of
the categorical association. For our case, we have ﬁve entity
types (i.e., app, API, IMEI, package, signature) and six types
of relations among them (i.e., R1-R6). Based on the deﬁni-
tions above, the network schema for HIN in our application
is shown in Figure 3, which enables the apps to be repre-
sented in a comprehensive way that utilizes their semantic
and structural information.

Figure 3: Network schema for HIN in our application.

To formulate the relatedness among entities in HIN, the
concept of meta-path has been proposed (Sun et al. 2011):
a meta-path P is a path deﬁned on the graph of network
R1−−→
schema TG = (A, R), and is denoted in the form of A1
R2−−→ ... RL−−→ AL+1, which deﬁnes a composite relation
A2
R = R1 · R2 · . . . · RL between types A1 and AL+1, where
· denotes relation composition operator, and L is length of
P. In our application, based on the HIN schema shown in
Figure 3, incorporated the domain knowledge from anti-
malware experts, we design six meaningful meta-paths to
characterize the relatedness over apps at different views (i.e.,
PID1-PID6 shown in Figure 4).

Figure 4: Meta-paths built for Android malware detection
(the symbols are the abbreviations shown in Figure 3).

For example, PID1 depicts that two apps are related if
they both invoke the same API (e.g., two malicious mo-
bile video players both invoke the API of “requestAudioFo-
cus”); while PID5 describes that two apps are connected if
their associated afﬁliations are possessed by (i.e., co-occur
in) the same phone. To measure the relatedness over HIN
entities (e.g., apps), traditional representation learning for
HIN (Sun et al. 2011) mainly focuses on factorizing the

matrix (e.g., adjacency matrix) of a HIN to generate latent-
dimension features for the nodes in this HIN. However, the
computational cost of decomposing a large-scale matrix is
usually very expensive, and also suffers from its statistical
performance drawback (Grover and Leskovec 2016). Since
Android malware detection is a speed sensitive application
and requires cost-effective solutions, scalable representa-
tion learning method for HIN, especially for out-of-sample
nodes, is in need.

3.3. HinLearning: Representation Learning of
In-Sample and Out-of-Sample Nodes in HIN
To address the above challenge, we ﬁrst formalize the prob-
lem of HIN representation learning as follow.
Deﬁnition 2 HIN Representation Learning (Fu, Lee, and
Lei 2017; Dong, Chawla, and Swami 2017). Given a HIN
G = (V, E), the representation learning task is to learn a
function f : V → Rd that maps each node v ∈ V to a vector
in a d-dimensional space Rd, d (cid:28) |V| that are capable to
preserve the structural and semantic relations among them.
To solve the problem of HIN representation learning, due
to the heterogeneous property of HIN (i.e., network consist-
ing of multi-typed entities and relations), it is difﬁcult to
directly apply the conventional homogeneous network em-
bedding techniques (e.g., DeepWalk (Perozzi, Al-Rfou, and
Skiena 2014), LINE (Tang et al. 2015), node2vec (Grover
and Leskovec 2016)) to learn the latent representations
for HIN. To address this issue, HIN embedding methods
(Fu, Lee, and Lei 2017; Dong, Chawla, and Swami 2017;
Fan et al. 2018) have been proposed, which are capable to
preserve the semantic and structural correlations between
different types of nodes . However, most of these existing
methods are primarily designed for static networks, where
all nodes are known before learning. In our application (i.e.,
real-time Android malware detection), it is infeasible to re-
run HIN embeddings whenever new nodes arrive, especially
considering the fact that rerunning HIN embeddings also
results in the need of retraining the downstream classiﬁer.
How to efﬁciently learn the representations of out-of-sample
nodes in HIN, i.e. nodes that arrive after the HIN embedding
process, remains largely unanswered. To solve this problem,
we ﬁrst propose heterogeneous in-sample node embedding
(HINE) model to learn in-sample node embeddings that is
able to preserve the heterogeneous property of HIN; then,
we devise Hin2Img to learn out-of-sample node representa-
tions and also enrich in-sample node representations using
previous learned in-sample node embeddings without rerun-
ning/adjusting HIN embeddings.
HINE: Heterogeneous In-sample Node Embedding. We
ﬁrst propose a random walk strategy guided by different
meta-paths to map the word-context concept in a text cor-
pus into a HIN; then we exploit skip-gram to learn effective
in-sample node representations for a HIN.

Given a source node vj in a homogeneous network, the
traditional random walk is a stochastic process with ran-
dom variables v1
is a node cho-
sen at random from the neighbors of node vk. The transition
probability p(vi+1
j) at step i is the normalized probability

j such that vk+1

j , ..., vk

j , v2

|vi

j

j

distributed over the neighbors of vi
j by ignoring their node
types. However, this mechanism is unable to capture the se-
mantic and structural correlations among different types of
nodes in a HIN. Here, we show how we use different built
meta-paths to guide the random walker in a HIN to gen-
erate the paths of multiple types of nodes. Given a HIN
G = (V, E) with schema TG = (A, R), and a set of differ-
ent meta-paths S = {Pj}n
j=1, each of which is in the form
of A1 → ...At → At+1... → Al, we put a random walker
to traverse the HIN. The random walker will ﬁrst randomly
choose a meta-path Pk from S and the transition probabili-
ties at step i are deﬁned as:

p(vi+1|vi

λ
|S|

At , S) =
1
|NAt+1

(vi
)|
if (vi+1, vi
1
|NAt+1

(vi

At

)|

At




0

At ) ∈ E, φ(vi

At ) = Aapp, φ(vi+1) = At+1

if (vi+1, vi
At ) ∈ E, φ(vi
φ(vi+1) = At+1, (At, At+1) ∈ Pk
otherwise,

At ) (cid:54)= Aapp,

(1)

where φ is the node type mapping function, NAt+1 (vi
)
At
denotes the At+1 type of neighborhood of node vi
, Aapp is
At
entity type of app, and λ is the number of meta-paths starting
with Aapp → At+1 in the given meta-path set S. The walk
paths generated by the above strategy are able to preserve
both the semantic and structural relations between different
types of nodes in the HIN.

After mapping the word-context concept in a text corpus
into a HIN via the above proposed meta-path guided random
walk strategy (i.e., a sentence in the corpus corresponds to a
sampled path and a word corresponds to a node), skip-gram
(Mikolov et al. 2013a; Perozzi, Al-Rfou, and Skiena 2014) is
then applied on the paths to minimize the loss of observing
a node’s neighbourhood (within a window w) conditioned
on its current representation. The objective function of skip-
gram is:

arg min

X

(cid:88)

−w≤k≤w,j(cid:54)=k

− log p(vj+k|X(vj)),

(2)

where X(vj) is the current representation vector of vj,

and p(vj+k|X(vj)) is deﬁned using the softmax function:

p(vj+k|X(vj)) =

exp(X(vj+k) · X(vj))
q=1 exp(X(vq) · X(vj))

(cid:80)|V|

.

(3)

Due to its efﬁciency, we ﬁrst apply hierarchical softmax
technique (Mikolov et al. 2013b) to solve Eq. 3, and employ
the stochastic gradient descent to train the skip-gram.
Hin2Img: Out-of-sample node representation learning.
Can we use in-sample node embeddings learned by the
above proposed HINE to efﬁciently learn representations of
out-of-sample nodes in HIN and also enrich in-sample node
representations? To answer this question, we ﬁrst present the
concept of k-order neighbors in HIN as following.

Deﬁnition 3 k-order Neighbors in HIN. Given a HIN G =
(V, E), let 1-order neighbors of a node vi ∈ V be S(1)(vi) so
that S(1)(vi) = {vj|(vi, vj) ∈ E}; then, k-order neighbors
S(k)(vi) of a node vi (k > 1) can be denoted as S(k)(vi) =
{S(1)(vz) \ S(k−2)(vi), vz ∈ S(k−1)(vi)}.

By the above deﬁnition, each node (i.e., either in-sample
or out-of-sample) in HIN is represented by the following
representation matrix:

X(vi) = [X(vi), X(S(1)(vi)), ..., X(S(k)(vi))],

(4)
where X ∈ Rt×d, each of which denotes d-dimensional
node embedding. In our application, as illustrated in Figure
5, for each k, we exploit breadth-ﬁrst search (BFS) method
to ﬁnd the tk neighbors in the order of type app, signature,
package, IMEI and API, and t = 1 + (cid:80)k
1 tk. Empirically
we found k = 2 and t = d perform the best in our appli-
cation, and apply them to our problem throughout the paper.
Note that we zero-pad the representation matrix in the corre-
sponding rows when the node embeddings cannot be found
(i.e., out-of-sample nodes) or t < d.

app) in HIN as input fed to the multilayer architecture to
learn the higher level concept. In this multilayer architec-
ture, the designed DNN ﬁrst stacks pairs of convolutional
layers and normalization layers with different ﬁlter sizes
and strides followed by maxpoolings to capture universal
features, such as curves and edges (Huang, Zhao, and Liu
2018). It then comes with an Inception module (Szegedy
et al. 2015) to generate more task-speciﬁc features, such as
discriminative properties for malicious and benign apps. In
the Inception module, the general features will be passed
through the mixture of convolutional layers in parallel to
take advantage of multi-level feature extraction, in which
1 × 1 convolutions and 3 × 3 maxpooling are conﬁgured
for dimensionality reduction prior to 1 × 1, 3 × 3, and 5 × 5
convolutions that are used for feature learning, followed by a
concatenation layer to concatenate the resulting feature rep-
resentations. After the global maxpooling, based on a pair
of fully connected layer and a softmax layer, the designed
DNN will train the model for classifying any new arriving
node (i.e., out-of-sample node with type of app represented
as a t × d matrix X) as either benign or malicious.

Figure 5: HinLearning: node representation learning in HIN.

Based on the in-sample node embeddings which can be
learned ofﬂine using the proposed HINE, when a new node
(e.g., a testing app) arrives, it only take O(t × d) time to ob-
tain its representation using the proposed Hin2Img; further-
more, the representation learning for the new arriving node
doesn’t require rerunning HIN embeddings, which makes
the downstream classiﬁer workable for classifying the new
arriving node without retraining.

3.4. Deep Neural Network
CNNs (LeCun, Bengio, and Hinton 2015) have achieved
great success in learning salient features for classiﬁcation
tasks; while the crafty architecture of Inception (Szegedy et
al. 2015) has shown high performance and low computa-
tional cost under strict constraints on memory and compu-
tational budget. Therefore, taking the generated representa-
tions of Android apps from previous section as inputs, we
devise our deep learning framework leveraging the advan-
tages of CNNs and Inception for real-time detection of An-
droid malware, which is illustrated in Figure 6. In our de-
signed DNN, for training, we take the generated t × d rep-
resentation matrix X of each in-sample node (with type of

Figure 6: Our designed DNN for malware detection.

Algorithm 1 illustrates the implementation of our devel-
oped system AiDroid which integrates the above proposed
method in detail.

Algorithm 1: AiDroid: HIN marries DNN.
Input: HIN G = (V, E) with schema TG = (A, R),

traning data set DI (in-sample apps), and testing
data set DO (out-of-sample apps).

Output: y: The labels for the testing data set.
Learn in-sample node embeddings X(vi) ∈ Rd
(i = 1, ..., |V|) using HINE;
for i = 1 → |DI | do

Apply Hin2Img: for each k, ﬁnd k-order neighbors
X(S(k)(vi)) and then generate the t × d matrix
X(vi) = [X(vi), X(S(1)(vi)), ..., X(S(k)(vi))];

end
Train DNN using Xs ∈ Rt×d;
for j = 1 → |DO| do

Use Hin2Img to generate X(vj);
Obtain the label yvj using trained DNN;

end
return y;

4. Experimental Results and Analysis
In this section, we fully evaluate the performance of our de-
veloped system AiDroid for Android malware detection.

4.1. Data Collection

We obtain the large-scale real sample collection from Ten-
cent Security Lab, which contains 190,696 training app (i.e.,
83,784 benign and 106,912 malicious). After feature extrac-
tion and based on the designed network schema, the con-
structed HIN has 286,421 nodes (i.e., 190,696 nodes with
type of app, 331 nodes with type of API, 70,187 nodes with
type of IMEI, 8,499 nodes with type of signature, and 16,708
with type of afﬁliation) and 4,170,047 edges including rela-
tions of R1-R6. The new coming 17,746 unknown apps are
used as testing data (to obtain the ground truth, they are fur-
ther analyzed by the anti-malware experts, 13,313 of which
are labeled as benign and 4,433 are malicious).

4.2. Baseline Methods

We validate the performance of our proposed method in
AiDroid for Android malware detection by comparisons
with different groups of baseline methods.

First, based on the constructed HIN described above, we
evaluate our proposed HIN representation learn method Hin-
Learning by comparisons with following baselines.
In-sample node embedding. We compare our proposed
HINE with other network embedding methods including:
• DeepWalk and LINE: For DeepWalk (Perozzi, Al-Rfou,
and Skiena 2014) and LINE (Tang et al. 2015), we ignore
the heterogeneous property of HIN and directly feed the
HIN for embedding.

• metapath2vec: We use each meta-path scheme separately
to guide random walks in metapath2vec (Dong, Chawla,
and Swami 2017).

For HINE, we divide the designed meta-paths into three
sets (i.e., S1 = {PID1}, S2 = {PID3, PID4}, S3 = {PID2,
PID5, PID6}) and use the proposed strategy to guide ran-
dom walks. The parameter settings used for HINE are in line
with DeepWalk, LINE and metapath2vec, which are empir-
ically set as: vector dimension d = 64 (LINE: 64 for each
order (1st- and 2nd-order)), walks per node r = 20, walk
length l = 50 and window size w = 5.
Out-of-sample node representation learning. We compare
our proposed Hin2Img for out-of-sample node representa-
tion learning with following baselines:
• LocalAvg: The out-of-sample nodes are represented by
averaging embeddings of neighboring in-sample nodes.
• LabelProp: Label propagation proposed for multivariate
regression problem can be used to learn the representa-
tions of out-of-sample nodes. As it has been demonstrated
(Ma, Cui, and Zhu 2018) that the vanilla version of la-
bel propagation (Zhu and Ghahramani 2002) outperforms
others, we hence use it as a baseline.

• Rerunning: For comparisons, we also run a baseline by
rerunning all node embeddings when new nodes arrive.
Second, we evaluate different types of features for An-
droid malware detection. Our proposed method is general
for HINs. Thus, a natural baseline is to see whether the
knowledge we add in should be represented as HIN instead
of other features. Here we compare two types of features:
behavioral sequences and HIN-based features.

• Behavioral Sequences (f-1): We devise three baselines
based on the extracted API call sequences of Android
apps: (1) we build support vector machine (SVM) clas-
siﬁer based on binary (i.e., if an API call is invoked by an
app) feature vectors (i.e., Bin+SVM); (2) we exploit Long
Short-term Memory (LSTM) (Sutskever, Vinyals, and Le
2014) for sequence modeling, based on which SVM clas-
siﬁer is then built (i.e., LSTM+SVM); and (3) we also
train our proposed DNN based on the extracted API call
sequences for evaluation (i.e., Seq+DNN).

• HIN-based Features (f-2): Based on the constructed
HIN, the proposed HinLearning is applied for represen-
tation learning (i.e., both in-sample and out-of-sample
nodes), based on which the designed DNN is used to train
the classiﬁcation model for prediction (i.e., AiDroid).

4.3. Comparisons and Analysis
Based on the HIN constructed from the training data, using
the developed DNN as downstream classiﬁer and the new
coming nodes (i.e., apps) for testing, from Table 1, we can
observe that different combinations of in-sample node em-
bedding and out-of-sample representation learning show dif-
ferent performances in Android malware detection: (1) For
in-sample node embedding methods, our proposed HINE
outperforms all baselines in terms of ACC and F1. That is to
say, HINE learns signiﬁcantly better node (i.e., app) repre-
sentation in HIN than current state-of-the-art methods. The
success of HINE lies in the proper consideration and ac-
commodation of the heterogeneous property of HIN (i.e.,
the multiple types of nodes and relations), and the advan-
tage of random walk guided by different meta-paths for sam-
pling the node paths. (2) For out-of-sample representation
learning, our proposed Hin2Img consistently and signiﬁ-
cantly outperforms all baselines (i.e., the detection perfor-
mance achieve superb 0.9908 ACC and 0.9817 F1), which
even surpasses the rerunning HIN embeddings. Obviously,
t × d representation matrices learned by Hin2Img utilizing
1- and 2-order neighbors are more expressive than other em-
beddings in depicting the apps for the problem of real-time
Android malware detection.

Table 1: Comparisons of different methods.

Metric

ACC

F1

In-sample

Out-of-sample Learning

Embedding LocalAvg LabelProp Hin2Img

Rerunning

DeepWalk
LINE

0.9057
0.9111
metapath2vec 0.9289
0.9389

HINE

DeepWalk
LINE

0.8267
0.8364
metapath2vec 0.8669
0.8849

HINE

0.9214
0.9307
0.9448
0.9533

0.8547
0.8705
0.8954
0.9094

0.9506
0.9690
0.9799
0.9908

0.9055
0.9398
0.9606
0.9817

0.9516
0.9602
0.9722
0.9843

0.9076
0.9234
0.9459
0.9691

We also show the comparisons in Table 2 for different
features in Android malware detection. From the results,
we can see that: (1) Based on the extracted API call se-
quences (i.e., f-1), LSTM provides signiﬁcant improvement
in sequence modeling while our proposed DNN outperforms

others in detection Android malware. (2) Compared with
content-based features only, HIN-based features (i.e., f-2)
indeed perform better. The reason behind this is that HIN-
based features are more expressive to characterize a com-
plex and comprehensive relatednesses over apps through the
designed meta-paths which consist of not only relationships
between apps and their invoked API calls, but also higher-
level semantics within the ecosystem.

Table 2: Comparisons of different types of features.

Feature Method

TP

TN

Bin+SVM 3,926
LSTM+SVM 4,115
Seq+DNN 4,168
AiDroid
4,395

11,828
12,339
12,504
13,188

f-1

f-2

FP

1,485
974
809
125

Feature Method

Recall Precision ACC

FN

507
318
265
38

F1

Bin+SVM 0.8856 0.7255 0.8877 0.7976
LSTM+SVM 0.9282 0.8086 0.9271 0.8642
Seq+DNN 0.9402 0.8374 0.9394 0.8858
AiDroid
0.9914 0.9723 0.9908 0.9817

f-1

f-2

4.4. Parameter Sensitivity, Scalability and Stability
In this set of experiments, we systematically evaluate the pa-
rameter sensitivity, scalability and stability of our developed
system AiDroid. We ﬁrst examine how latent dimensions (d)
and neighborhood size (w) affect the performance in An-
droid malware detection. As shown in Figure 7.(a) and (b),
we can see that AiDroid is not strictly sensitive to these pa-
rameters and is able to reach high performance under a cost-
effective parameter choice. We then run the experiments us-
ing new arriving apps from Aug. 1-10, 2018 to assess the
average detection time and accuracy. Figure 7.(c) and (d)
demonstrate AiDroid is scalable and stable over a long time
span in detecting newly generated Android malware (i.e., av-
erage prediction time: 4.3 ms/app and 0.9891 ACC on aver-
age). Figure 7.(e) shows the ROC curve of AiDroid based on
the data described in Section 4.1 which achieves an impres-
sive 0.9914 true positive rate (TPR) at 0.0094 false positive
rate (FPR). We can conclude that AiDroid is indeed feasible
in practical use for real-time Android malware detection.

Figure 7: Parameter sensitivity, scalability and stability.

5. Related Work

In recent years, there have been ample research studies
on developing intelligent Android malware detection sys-
tems using machine learning and data mining techniques
(Wu et al. 2012; Wu and Hung 2014; Hou et al. 2016;
Chen, Hou, and Ye 2017; Ye et al. 2017; Saracino et al.
2018). For example, DroidDolphin (Wu and Hung 2014)
built classiﬁers based on dynamic analysis, while Droid-
Mat (Wu et al. 2012) and DroidMiner (Yang et al. 2014)
constructed their models based on static analysis. However,
most of the existing systems merely utilize content-based
features for the detection. To further address the challenges
of Android malware detection, in our preliminary work, Hin-
Droid (Hou et al. 2017) was proposed which considered
higher-level semantic relations among apps and APIs and
introduced HIN for the ﬁrst time in Android malware de-
tection; but HinDroid was primarily designed for static HIN
without considering new arriving nodes.

To solve the problem of network representation learning,
after DeepWalk (Perozzi, Al-Rfou, and Skiena 2014), LINE
(Tang et al. 2015) and node2vec (Grover and Leskovec
2016) that were proposed for homogeneous network em-
bedding, HIN2vec (Fu, Lee, and Lei 2017), metapath2vec
(Dong, Chawla, and Swami 2017), metagraph2vec (Fan et
al. 2018), and PME (Chen et al. 2018) have been proposed
for HIN representation learning. However, few of them can
deal with out-of-sample nodes, i.e., nodes that arrive after
the HIN embedding process. Though algorithms (Chang et
al. 2015; Zhao et al. 2018) have been proposed to infer em-
beddings for out-of-sample nodes in HIN, they necessitate
adjusting in-sample node embeddings and also the down-
stream classiﬁer retraining. Efﬁcient representation learning
for out-of-sample nodes in HIN without rerunning/adjusting
HIN embeddings is in need for our application in real-time
Android malware detection.

6. Conclusion

To combat the evolving Android malware attacks, in this
paper, we ﬁrst extract the API call sequences from run-
time executions of Android apps and further analyze higher-
level semantic relationships within the ecosystem. To de-
pict such complex relations, we introduce HIN for model-
ing and use meta-path based approach to build up related-
nesses over apps. To efﬁciently classify nodes (i.e., apps) in
HIN, we propose the HinLearning method to ﬁrst gain in-
sample node embeddings and then learn representations of
out-of-sample nodes without rerunning/adjusting HIN em-
beddings for the ﬁrst time. Afterwards, we design a DNN
classiﬁer leveraging the advantages of CNNs and Inception
for Android malware detection. A comprehensive experi-
mental study on the large-scale real data collections from
Tencent Security Lab is performed to compare various base-
lines. Promising experimental results demonstrate that our
developed system AiDroid outperforms others in real-time
Android malware detection, which has been incorporated
into Tencent Mobile Security product that serves millions
of users worldwide.

Acknowledgement

The authors would also like to thank the anti-malware ex-
perts of Tencent Security Lab (Yinming Mei, Yuanhai Luo,
Hong Yi, and Kui Wang) for helpful discussion and imple-
mentation. Y. Ye, S. Hou, and L. Chen’s work is partially
supported by the U.S. National Science Foundation under
grants CNS-1618629, CNS-1814825 and OAC-1839909,
WV HEPC.dsr.18.5, and WVU Research and Scholarship
Advancement Grant (R-844).

References

[Chang et al. 2015] Chang, S.; Han, W.; Tang, J.; Qi, G.-J.;
Aggarwal, C. C.; and Huang, T. S. 2015. Heterogeneous
network embedding via deep architectures. In KDD, 119–
128. ACM.
[Chen et al. 2018] Chen, H.; Yin, H.; Wang, W.; Wang, H.;
Nguyen, Q. V. H.; and Li, X. 2018. Pme: Projected metric
embedding on heterogeneous networks for link prediction.
In KDD.
[Chen, Hou, and Ye 2017] Chen, L.; Hou, S.; and Ye, Y.
2017. Securedroid: Enhancing security of machine learning-
based detection against adversarial android malware attacks.
In ACSAC, 362–372. ACM.
[Dong, Chawla, and Swami 2017] Dong, Y.; Chawla, N. V.;
and Swami, A. 2017. metapath2vec: Scalable representation
learning for heterogeneous networks. In KDD.
[Fan et al. 2018] Fan, Y.; Hou, S.; Zhang, Y.; Ye, Y.; and Ab-
dulhayoglu, M. 2018. Gotcha-sly malware!: Scorpion a
metagraph2vec based malware detection system. In KDD.
[Fu, Lee, and Lei 2017] Fu, T.-Y.; Lee, W.-C.; and Lei, Z.
2017. Hin2vec: Explore meta-paths in heterogeneous infor-
mation networks for representation learning. In CIKM.
[Grover and Leskovec 2016] Grover, A., and Leskovec, J.
2016. node2vec: Scalable feature learning for networks. In
KDD. ACM.
[Hou et al. 2016] Hou, S.; Saas, A.; Ye, Y.; and Chen, L.
2016. Droiddelver: An android malware detection system
using deep belief network based on api call blocks.
In
WAIM, 54–66.
[Hou et al. 2017] Hou, S.; Ye, Y.; Song, Y.; and Abdulhayo-
glu, M. 2017. Hindroid: An intelligent android malware
detection system based on structured heterogeneous infor-
mation network. In KDD, 1507–1515. ACM.
[Huang, Zhao, and Liu 2018] Huang, S.-J.; Zhao, J.-W.; and
Liu, Z.-Y. 2018. Cost-effective training of deep cnns with
active model adaptation. In KDD.
[LeCun, Bengio, and Hinton 2015] LeCun, Y.; Bengio, Y.;
and Hinton, G. 2015. Deep learning. Nature.
[Ma, Cui, and Zhu 2018] Ma, J.; Cui, P.; and Zhu, W. 2018.
Depthlgp: Learning embeddings of out-of-sample nodes in
dynamic networks. In AAAI.
[Mikolov et al. 2013a] Mikolov, T.; Chen, K.; Corrado, G.;
and Dean, J. 2013a. Efﬁcient estimation of word represen-
tations in vector space. In arXiv preprint arXiv:1301.3781.

2018.
share worldwide.

Mobile
In
/mobile/world-

[Mikolov et al. 2013b] Mikolov, T.; Sutskever, I.; Chen, K.;
Corrado, G. S.; and Dean, J. 2013b. Distributed represen-
tations of words and phrases and their compositionality. In
NIPS.
[Perozzi, Al-Rfou, and Skiena 2014] Perozzi, B.; Al-Rfou,
R.; and Skiena, S. 2014. Deepwalk: Online learning of so-
cial representations. In KDD.
[Saracino et al. 2018] Saracino, A.; Sgandurra, D.; Dini, G.;
and Martinelli, F. 2018. Madam: Effective and efﬁcient
behavior-based android malware detection and prevention.
TDSC.
[Statcounter 2018] Statcounter.
operating
system market
http://gs.statcounter.com/os-market-share
wide.
[Sun and Han 2012] Sun, Y., and Han, J. 2012. Mining het-
erogeneous information networks: principles and method-
ologies. Synthesis Lectures on Data Mining and Knowledge
Discovery.
[Sun et al. 2011] Sun, Y.; Han, J.; Yan, X.; Yu, P. S.; and Wu,
T. 2011. Pathsim: Meta path-based top-k similarity search
in heterogeneous information networks. PVLDB.
[Sutskever, Vinyals, and Le 2014] Sutskever, I.; Vinyals, O.;
and Le, Q. V. 2014. Sequence to sequence learning with
neural networks. In NIPS.
[Szegedy et al. 2015] Szegedy, C.; Liu, W.; Jia, Y.; Sermanet,
P.; Reed, S.; Anguelov, D.; Erhan, D.; Vanhoucke, V.; and
Rabinovich, A. 2015. Going deeper with convolutions. In
CVPR.
[Tang et al. 2015] Tang, J.; Qu, M.; Wang, M.; Zhang, M.;
Yan, J.; and Mei, Q. 2015. Line: Large-scale information
network embedding. In WWW.
[TencentSecurity 2018] TencentSecurity.
phone security report for the ﬁrst half of 2018.
https://m.qq.com/security lab/news detail 471.html.
[Wu and Hung 2014] Wu, W.-C., and Hung, S.-H.
2014.
Droiddolphin: A dynamic android malware detection frame-
work using big data and machine learning. In RACS.
[Wu et al. 2012] Wu, D. J.; Mao, C. H.; Wei, T. E.; Lee,
H. M.; and Wu, K. P. 2012. Droidmat: Android malware
In Asia
detection through manifest and api calls tracing.
JCIS, 62–69.
[Yang et al. 2014] Yang, C.; Xu, Z.; Gu, G.; Yegneswaran,
V.; and Porras, P. 2014. Droidminer: Automated mining
and characterization of ﬁne-grained malicious behaviors in
android applications. In ESORICS.
[Ye et al. 2017] Ye, Y.; Li, T.; Adjeroh, D.; and Iyengar, S. S.
2017. A survey on malware detection using data mining
techniques. ACM Computing Surveys (CSUR) 50(3).
[Zhao et al. 2018] Zhao, D.; Li, J.; Tan, Y.; Yang, K.; Ge, B.;
and Dou, Y. 2018. Optimization adjustment of human re-
sources based on dynamic heterogeneous network. Physica
A.
[Zhu and Ghahramani 2002] Zhu, X., and Ghahramani, Z.
2002. Learning from labeled and unlabeled data with label
propagation. CMU Technical report.

2018. Mobile
In

