Synthesizing Programs for Images using Reinforced Adversarial Learning

Yaroslav Ganin 1 Tejas Kulkarni 2 Igor Babuschkin 2 S. M. Ali Eslami 2 Oriol Vinyals 2

Abstract

Advances in deep generative networks have led
to impressive results in recent years. Neverthe-
less, such models can often waste their capacity
on the minutiae of datasets, presumably due to
weak inductive biases in their decoders. This is
where graphics engines may come in handy since
they abstract away low-level details and represent
images as high-level programs. Current methods
that combine deep learning and renderers are lim-
ited by hand-crafted likelihood or distance func-
tions, a need for large amounts of supervision, or
difﬁculties in scaling their inference algorithms
to richer datasets. To mitigate these issues, we
present SPIRAL, an adversarially trained agent
that generates a program which is executed by a
graphics engine to interpret and sample images.
The goal of this agent is to fool a discriminator
network that distinguishes between real and ren-
dered data, trained with a distributed reinforce-
ment learning setup without any supervision. A
surprising ﬁnding is that using the discrimina-
tor’s output as a reward signal is the key to allow
the agent to make meaningful progress at match-
ing the desired output rendering. To the best of
our knowledge, this is the ﬁrst demonstration of
an end-to-end, unsupervised and adversarial in-
verse graphics agent on challenging real world
(MNIST, OMNIGLOT, CELEBA) and synthetic
3D datasets. A video of the agent can be found at
https://youtu.be/iSyvwAwa7vk.

8
1
0
2

r
p
A
3

]

V
C
.
s
c
[

1
v
8
1
1
1
0
.
4
0
8
1
:
v
i
X
r
a

1. Introduction

Recovering structured representations from raw sensations
is an ability that humans readily possess and frequently use.
Given a picture of a hand-written character, decomposing
it into strokes can make it easier to classify or re-imagine

Work done while YG was an intern at DeepMind. 1Montreal
Institute for Learning Algorithms, Montr´eal, Canada 2DeepMind,
London, United Kingdom. Correspondence to: Yaroslav Ganin
<yaroslav.ganin@gmail.com>.

Figure 1. SPIRAL takes as input either random noise or images
and iteratively produces plausible samples or reconstructions via
graphics program synthesis. The ﬁrst row depicts an unconditional
run given random noise. The second, third and fourth rows depict
conditional execution given an image with a handwritten character,
the Mona Lisa, and objects arranged in a 3D scene.

that character, and similarly, knowing the underlying layout
of a room can aid with planning, navigation and interaction
in that room. Furthermore, this structure can be exploited
for generalization, rapid learning, and even communication
with other agents. It is commonly believed that humans
exploit simulations to learn this skill (Lake et al., 2017).
By experimenting with a pen and a piece of paper we learn
how our hand movements lead to written characters, and
via imagination we learn how architectural layouts manifest
themselves in reality.

In the visual domain, inversion of a renderer for the purposes
of scene understanding is typically referred to as inverse
graphics (Mansinghka et al., 2013; Kulkarni et al., 2015a).
Training vision systems using the inverse graphics approach
has remained a challenge. Renderers typically expect as in-
put programs that have sequential semantics, are composed
of discrete symbols (e.g., keystrokes in a CAD program),
and are long (tens or hundreds of symbols). Additionally,
matching rendered images to real data poses an optimization
problem as black-box graphics simulators are not differen-
tiable in general.

To address these problems, we present a new approach for
interpreting and generating images using Deep Reinforced
Adversarial Learning. In this approach, an adversarially
trained agent generates visual programs which are in turn

 
 
 
 
 
 
Synthesizing Programs for Images using Reinforced Adversarial Learning

Cond

π

π

π

π

place
small
red
box
at (8, 13)

place
small
green
cylinder
at (2, 2)

place
large
purple
capsule
at (8, 8)

change to
large
blue
sphere
at (13, 8)

R

R

R

R

Actors

π

π

R

R

(a)

Policy Learner

D

LG

Render

Final

Queue

Trajectories

Unrolled

π

Entropy
Loss

D

D

LD

Discriminator Learner

Generated
Data

Replay

Real
Data

Dataset

(b)

Figure 2. The SPIRAL architecture. (a) An execution trace of the SPIRAL agent. The policy outputs program fragments which are
rendered into an image at each step via a graphics engine
. The agent can make use of these intermediate renders to adjust its policy. The
agent only receives a reward in the ﬁnal step of execution. (b) Distributed training of SPIRAL. A collection of actors (in our experiments,
up to 64), asynchronously and continuously produce execution traces. This data, along with a training dataset of ground-truth renderings,
are passed to a Wasserstein discriminator on a separate GPU for adversarial training. The discriminator assesses the similarity of the ﬁnal
renderings of the traces to the ground-truth. A separate off-policy GPU learner receives batches of execution traces and trains the agent’s
parameters via policy-gradients to maximize the reward assigned to them by the discriminator, i.e., to match the distribution of the ground
truth dataset.

R

executed by a graphics engine to generate images, either
conditioned on data or unconditionally. The agent is re-
warded by fooling a discriminator network, and is trained
with distributed reinforcement learning without any extra
supervision. The discriminator network itself is trained to
distinguish between rendered and real images.

Our contributions are as follows:

• An adversarially trained reinforcement learning agent
that interprets and generates images in the space of
visual programs. Crucially, the architecture of our
agent is agnostic both to the semantics of the visual
program and to the domain.

• Scaling inverse graphics to real world and procedural
datasets without the need for labels. In particular, our
model discovers pen strokes that give rise to MNIST
and OMNIGLOT characters, brush strokes that give rise
to celebrity faces, and scene descriptions that, once ren-
dered, reconstruct an image of a 3D scene (Figure 1).

• Evidence that utilizing a discriminator’s output as the
reward signal for reinforcement learning is signiﬁcantly
better at optimizing the pixel error between renderings
and data, compared to directly optimizing pixel error.

• A showcase of state-of-the-art deep reinforcement
learning techniques, which can provide a scaling path
for inverse graphics, and could lead to broader implica-
tions for program synthesis in future work.

2. Related Work

The idea of inverting simulators to interpret images has
been explored extensively in recent years (Nair et al., 2008;
Paysan et al., 2009; Mansinghka et al., 2013; Loper & Black,
2014; Kulkarni et al., 2015a; Jampani et al., 2015). Struc-
tured object-attribute based ‘de-rendering’ models have
been proposed for interpretation of images (Wu et al., 2017b)
and videos (Wu et al., 2017a). Concurrent work has ex-
plored the use of Constructive Solid Geometry primitives
for explaining binary images (Sharma et al., 2017). Loper
& Black (2014) proposed the idea of differentiable inverse
graphics, which is efﬁcient for optimizing continuous vari-
ables but cannot handle discrete variables. Earlier work has
also explored using reinforcement learning for automatic
generation of single brush strokes (Xie et al., 2013). How-
ever, scaling these approaches to larger real-world datasets,
particularly at test-time, has remained a challenge.

Inferring motor programs for the reconstruction of MNIST
digits was ﬁrst studied in (Nair & Hinton, 2006). The gen-
erative model is parametrized by two pairs of opposing
springs whose stiffness is controlled by a motor program.
The training procedure involved starting with a prototype
program and its corresponding observation. Random noise
was then added to this prototype in order to produce new
training examples until the generated distribution stretched
to cover the manifold of the training digits. In contrast, our
model automatically learns the training curriculum via the
discriminator and the same agent is suitable for a range of
scene understanding problems, including those in 3D.

Synthesizing Programs for Images using Reinforced Adversarial Learning

Visual program induction has recently been studied in
the context of hand-written characters on the OMNIGLOT
dataset (Lake et al., 2015). This model achieves impres-
sive performance but requires parses from a hand-crafted
algorithm to initialize training and was not demonstrated
to generalize beyond hand-written characters. Ellis et al.
(2017) proposed a visual program induction model to infer
LATEXprograms for diagram understanding. More recently,
the sketch-rnn model (Ha & Eck, 2017) used sequence-
to-sequence learning (Sutskever et al., 2014) to produce
impressive sketches both unconditionally and conditioned
on data. However, similar to the aforementioned works and
unlike SPIRAL, the model requires supervision in the form
of sketches and corresponding sequences of strokes.

In the neural network community, there have been analogous
attempts at inferring and learning feed-forward or recurrent
procedures for image generation (LeCun et al., 2015; Hinton
& Salakhutdinov, 2006; Goodfellow et al., 2014; Ackley
et al., 1987; Kingma & Welling, 2013; Oord et al., 2016;
Kulkarni et al., 2015b; Eslami et al., 2016; Reed et al., 2017;
Gregor et al., 2015). These models demonstrate impressive
image generation capabilities but generally lack the ability
to infer structured representations of images.

Our approach employs adversarial training techniques, ﬁrst
used for generative modeling (Goodfellow et al., 2014) and
domain adaptation (Ganin & Lempitsky, 2015). Generative
Adversarial Networks (GANs) (Goodfellow et al., 2014)
were orignally used for image generation but have now
been successfully applied to model audio, text and motor
behaviors (Ho & Ermon, 2016; Merel et al., 2017). Per-
haps the most interesting extension in our context is their
use in domain transfer, where images from one domain
(e.g., segmentations) were mapped to another (e.g., pixels).
Models such as pix2pix (Isola et al., 2017), CycleGAN
(Zhu et al., 2017) and AIGN (Tung et al., 2017) fall in this
category.

The SPIRAL agent builds upon this literature, has minimal
hand-crafting in its design, requires no supervision in the
form of pairs of programs and corresponding images and,
as we demonstrate in the following sections, is applicable
across a wide range of domains.

3. The SPIRAL Agent

3.1. Overview

Our goal is to construct a generative model G capable
of sampling from some target data distribution pd. To
that end, we propose using an external black-box render-
ing simulator R that accepts a sequence of commands
a = (a1, a2, . . . , aN ) and transforms them into the domain
of interest, e.g., a bitmap. For example, R could be a CAD
program rendering descriptions of primitives into 3D scenes.

Thus, our task is equivalent to recovering a distribution
pa such that pd ≈ R(pa). We model pa with a recurrent
neural network π which we call the policy network (or,
somewhat sloppily, the agent). The generation process G,
which consists of a policy π and a renderer R, is illustrated
in Figure 2a.

In order to optimize π, we employ the adversarial framework
(Goodfellow et al., 2014). In this framework, the generator
(denoted as G) aims to maximally confuse a discrimina-
tor network D which is trained to distinguish between the
samples drawn from pd and the samples generated by the
model. As a result, the distribution deﬁned by G (denoted
as pg) gradually becomes closer to pd. Crucially, and unlike
previous work, our training procedure does not require any
strong supervision in the form of aligned examples from pd
and pa.

We give the concrete training objectives for G and D below.

3.2. Objectives

In our experiments, we found that the original minimax
objective from Goodfellow et al. (2014) was hard to opti-
mize in the context of our model, so we opted for using a
variant that employs Wasserstein distance as a measure of
divergence between distributions (Gulrajani et al., 2017), as
it appears to handle vastly dissimilar pg and pd more grace-
fully. In this case, the discriminator is considered “confused”
if it assigns the same scores (in expectation) to the inputs
coming both from pd and pg. We note that our approach can
be used in conjunction with other forms of GAN objectives
as well.

Discriminator. Following (Gulrajani et al., 2017), we de-
ﬁne the objective for D as:

LD = −Ex∼pd [D(x)] + Ex∼pg [D(x)] + R,

(1)

where R is a regularization term softly constraining D to
stay in the set of Lipschitz continuous functions (for some
ﬁxed Lipschitz constant). It is worth noting that the solution
to (1) is deﬁned up to an additive constant. Due to the nature
of how we use discriminator outputs during training of π, we
found it beneﬁcial to resolve this ambiguity by encouraging
D(x) to be close to 0 on average for x ∼ 1

2 pg + 1

2 pd.

Generator. We formally deﬁne π as a network that at every
time step t predicts a distribution over all possible com-
mands πt = π(at|st; θ), where st is the recurrent state of
the network, and θ is a set of learnable parameters. Given
a sequence of samples (at | at ∼ πt, 1 ≤ t ≤ N ), a sample
from pg is then computed as R(a1, a2, . . . , aN ). Since the
generator is an arbitrary non-differentiable function, we
cannot optimize

LG = −Ex∼pg [D(x)]

(2)

Synthesizing Programs for Images using Reinforced Adversarial Learning

with naive gradient descent. Therefore we pose this prob-
lem as maximization of the expected return which can be
solved using standard techniques from reinforcement learn-
ing. Speciﬁcally, we employ a variant of the REINFORCE
(Williams, 1992) algorithm, advantage actor-critic (A2C):

• Actors are responsible for generating the training trajec-
tories through interaction between the policy network
and the rendering simulator. Each trajectory contains a
sequence ((πt, at) | 1 ≤ t ≤ N ) as well as all interme-
diate renderings produced by R.

LG = −

(cid:88)

t

log π(at | st; θ) [Rt − V π(st)] ,

(3)

where V π is an approximation to the value function which
is considered to be independent of θ, and Rt = (cid:80)N
t rt is a
1-sample Monte-Carlo estimate of the return. Optimizing
(3) recovers the solution to (2) if the rewards are set to:

(cid:40)

rt =

0 ,
D(R(a1, a2, . . . , aN )) ,

t < N ,
t = N .

(4)

One interesting aspect of this new formulation is that we
can also bias the search by introducing intermediate rewards
which may depend not only on the output of R but also on
commands used to generate that output. We present several
examples of such rewards in Section 4.

3.3. Conditional Generation

So far, we have described the case of unconditional gen-
eration, but in many situations it is useful to condition the
model on auxiliary input (Mirza & Osindero, 2014). For
instance, one might be interested in ﬁnding a speciﬁc pro-
gram that generates a given image xtarget. That could be
achieved by supplying xtarget both to the policy and to the
discriminator networks. In other words,

pg = R (pa(a|xtarget)) ,

(5)

• A policy learner receives trajectories from the actors,
combines them into a batch and updates π by perform-
ing an SGD step on LG (2). Following common prac-
tice (Mnih et al., 2016), we augment LG with an en-
tropy penalty encouraging exploration.

• In contrast to the base IMPALA setup, we deﬁne an ad-
ditional discriminator learner. This worker consumes
random examples from pd, as well as generated data
(ﬁnal renders) coming from the actor workers, and
optimizes LD (1).

In the original paper introducing WGAN with gradient
penalty (Gulrajani et al., 2017), the authors note that in
order to obtain better performance, the discriminator has
to be updated more frequently than the generator. In our
setting, generation of each model sample is expensive since
it involves multiple invocations of an external simulator. We
therefore do not omit any trajectories in the policy learner.
Instead, we decouple the D updates from the π updates
by introducing a replay buffer that serves as a communica-
tion layer between the actors and the discriminator learner.
That allows the latter to optimize D at a higher rate than
the training of the policy network due to the difference in
network sizes (π is a multi-step RNN, while D is a plain
CNN). We note that even though sampling from a replay
buffer inevitably leads to smoothing of pg, we found this
setup to work well in practice.

while pd becomes a Dirac δ-function centered at xtarget. The
ﬁrst two terms in (1) thus reduce to

4. Experiments

4.1. Datasets

−D(xtarget | xtarget) + Ex∼pg [D(x|xtarget)] .

(6)

It can be shown that for this particular setting of pg and
pd, the (cid:96)2-distance is an optimal discriminator. However,
in general it is not a unique solution to (1) and may be a
poor candidate to be used as the generator’s reward signal
(see Section A in the appendix for details). In Section 4, we
empirically evaluate both (cid:96)2 and a dynamically learned D
and conclude that those two options are not equivalent in
practice (for example, see Figure 8a).

3.4. Distributed Learning

We validate our approach on three real-world and one syn-
thetic image dataset. The ﬁrst, MNIST (LeCun et al., 1998),
is regarded as a standard sanity check for newly proposed
generative models. It contains 70,000 examples of hand-
written digits, of which 10,000 constitute a test set. Each
example is a 28 × 28 grayscale image. Although the dataset
is often considered “solved” by neural decoder-based ap-
proaches (including GANs and VAEs), these approaches do
not focus on recovering interpretable structure from the data.
We, therefore, choose not to discard MNIST from the em-
pirical evaluation since it is likely that additional constraints
increase the difﬁculty of the modeling task.

Our training pipeline is outlined in Figure 2b. It is an ex-
tension of the recently proposed IMPALA architecture (Es-
peholt et al., 2018). For training, we deﬁne three kinds of
workers:

The second dataset, OMNIGLOT (Lake et al., 2015), com-
prises 1623 handwritten characters from 50 alphabets. Com-
pared to MNIST, this dataset introduces three additional
challenges: higher data variability, higher complexity of

Synthesizing Programs for Images using Reinforced Adversarial Learning

Control point, a1

t = pc

Current location, lt

Color,

End point, a2
Pressure,
Brush size,

t = lt+1
a3
t
a4
t
a{5,6,7}
t

the agent’s action space in the
Figure 3. Illustration of
libmypaint environment. We show three different strokes (red,
green, blue) that can result from a single instruction from the agent
to the renderer. Starting from a position on the canvas, the agent
selects the coordinates of the next end point, the coordinates of the
intermediate control point, as well as the brush size, pressure and
color. See Section 4.2 for details.

symbols (e.g., disjoint subcurves) and fewer (only 20) data
points per symbol class.

Since both MNIST and OMNIGLOT represent a restricted
line drawing domain, we diversify our set of experiments
by testing the proposed method on CELEBA (Liu et al.,
2015). The dataset contains over 200,000 color headshots
of celebrities with large variation in poses, backgrounds and
lighting conditions.

Lastly, we are interested in evaluating our approach on the
task of unsupervised 3D scene understanding which is a
crucial precursor for manipulating and reasoning about ob-
jects in the real world. To that end, we created a procedural
dataset called MUJOCO SCENES consisting of renders of
simple 3D primitives (up to 5 objects) scattered around a
square platform (see Figure 10). The training set is com-
prised of 50,000 RGB images generated by means of the
MuJoCo environment discussed in the next section.

In each case, we rescale the images to 64 × 64, which
allows us to reuse the same network architectures in all the
experiments, demonstrating the generality of our method.

4.2. Environments

We introduce two new rendering environments.
For
MNIST, OMNIGLOT and CELEBA generation we use an
open-source painting library libmypaint (libmypaint
contributors, 2018). The agent controls a brush and pro-
duces a sequence of (possibly disjoint) strokes on a canvas
C. The state of the environment is comprised of the contents
of C as well as the current brush location lt. Each action
at is a tuple of 8 discrete decisions (a1
t ) (see
Figure 3). The ﬁrst two components are the control point pc
and the end point lt+1 of the stroke, which is speciﬁed as a
quadratic B´ezier curve:

t , . . . , a8

t , a2

p(τ ) = (1 − τ )2 lt + 2(1 − τ ) τ pc + τ 2 lt+1 ,

(7)

where τ ∈ [0, 1]. In our experiments, we deﬁne the valid
range of locations as a 32 × 32 grid imposed on C. We
set l0 to the upper left corner of the canvas. The next 5
components represent the appearance of the stroke:
the
pressure that the agent applies to the brush (10 levels), the
brush size, and the stroke color characterized by mixture
of red, green and blue (20 bins for each color component).
The last element of at is a binary ﬂag specifying the type of
action: the agent can choose either to produce a stroke or
to jump right to lt+1. For grayscale datasets (MNIST and
OMNIGLOT), we omit the color components.

In the MUJOCO SCENES experiment, we render images
using a MuJoCo-based environment (Todorov et al., 2012).
At each time step, the agent has to decide on the object
type (4 options), its location on a 16 × 16 grid, its size
(3 options) and the color (3 color components with 4 bins
each). The resulting tuple is sent to the environment, which
adds an object to the scene according to the speciﬁcation.
Additionally, the agent can decide to skip a move or change
the most recently emitted object. All three types of actions
are illustrated in Figure 2a.

4.3. MNIST

For the MNIST dataset, we conduct two sets of experiments.
In the ﬁrst set, we train an unconditional agent to model the
data distribution. Along with the reward provided by the
discriminator we also use auxiliary penalties expressing our
inductive biases for the particular type of data. To encourage
the agent to draw a digit in a single continuous motion of the
brush, we provide a small negative reward for starting each
continuous sequence of strokes. We also found it beneﬁcial
to penalize our model for not producing any visible strokes
at all. The resulting agent manages to generate samples
clearly recognizable as hand-written digits. Examples of
such generations are shown in Figure 4a.

In the second set of experiments, we train an agent to gener-
ate the strokes for a given target digit, and we compare two
kinds of rewards discussed in Section 3.3: ﬁxed (cid:96)2-distance
and the discriminator score. The results are summarized
in Figure 8a (blue curves). We note that the discriminator-
based approach signiﬁcantly speeds up training of the model
and achieves lower ﬁnal (cid:96)2 error. When no auxiliary rewards
were employed, (cid:96)2-based runs failed to learn reasonable
reconstructions. Figure 4b presents several conditional gen-
erations produced by our method.

Following (Sharma et al., 2017), we also train a “blind” ver-
sion of the agent, i.e., we do not feed intermediate canvas
states as an input to π. That means that the model cannot
rely on reactive behaviour since it does not “see” the im-
mediate consequences of its decisions. The training curve
for this experiment is shown in Figure 8a (dotted blue line).
Although the agent does not reach the level of performance

Synthesizing Programs for Images using Reinforced Adversarial Learning

0

Training frames

25 · 106

Final result

0

Training frames

25 · 106

Final result

(a) MNIST unconditional generation

(a) Omniglot unconditional generation

(b) MNIST reconstruction

(b) Omniglot reconstruction

Figure 4. MNIST. (a) A SPIRAL agent is trained to draw MNIST
digits via a sequence of strokes in the libmypaint environment.
As training progresses, the quality of the generations increases.
The ﬁnal samples capture the multi-modality of the dataset, varying
brush sizes and digit styles. (b) A conditional SPIRAL agent is
trained to reconstruct using the same action space. Reconstructions
(left) match ground-truth (right) accurately.

Figure 5. Omniglot.
(a) A SPIRAL agent is trained to draw
MNIST digits via a sequence of strokes in the libmypaint
environment. As training progresses, the quality of the genera-
tions increase. The ﬁnal samples capture the multi-modality of the
dataset, varying brush sizes and character styles. (b) A conditional
SPIRAL agent is trained to reconstruct using the same action space.
Reconstructions (left) match ground-truth (right) accurately.

of the full model, it can still produce sensible reconstruc-
tions which suggests that our approach could be used in the
more general setting of program synthesis, where access to
intermediate states of the execution pipeline is not assumed.

4.4. OMNIGLOT

In the previous section, we showed that our approach works
reasonably well for handwritten digits. In this series of
experiments, we test our agent in a similar but more chal-
lenging setting of handwritten characters. The difﬁculty of
the dataset manifests itself in lower quality of unconditional
generations (Figure 5a). Note that this task appears to be
hard for other neural network based approaches as well:
models that do produce good samples, such as (Rezende
et al., 2016), do not do so in a manner that mimics actual
strokes.

The conditional agent, on the other hand, managed to reach
convincing quality of reconstructions (Figure 5b). Unfortu-
nately, we could not make the (cid:96)2-based model work well in
this setting (Figure 8a; dashed red line). This suggests not
only that discriminator rewards speed up learning, but also
that they allow successful training of agents in cases where

na¨ıve rewards like (cid:96)2 do not result in sufﬁcient exploration.

Since OMNIGLOT contains a highly diverse set of symbols,
over the course of training our model could learn a general
notion of image reproduction rather than simply memorizing
dataset-speciﬁc strokes.
In order to test this, we feed a
trained agent with previously unseen line drawings. The
resulting reconstructions are shown in Figure 6. The agent
handles out-of-domain images well, although it is slightly
better at reconstructing the OMNIGLOT test set.

4.5. CELEBA

Since the libmypaint environment is also capable of
producing complex color paintings, we explore this direc-
tion by training a conditional agent on the CELEBA dataset.
As in previous experiments, we use 20-step episodes, and
as before, the agent does not receive any intermediate re-
wards. In addition to the reconstruction reward (either (cid:96)2 or
discriminator-based), we put a penalty on the earth mover’s
distance between the color histograms of the model’s output
and xtarget. We found this relatively task-agnostic penalty
to slightly improve the performance of the method, but we
would like to stress that it is by no means necessary.

Synthesizing Programs for Images using Reinforced Adversarial Learning

INPUT
64 × 64

RECONSTRUCTION
64 × 64

RECONSTRUCTION
256 × 256

TRACE
256 × 256

Figure 6. Image parsing using the SPIRAL agent trained on Om-
niglot. All images from test sets. Given a rastered input (a), the
agent produces a reconstruction (b) that closely matches the input.
(c) Having access to the underlying strokes, we can render the
character at a higher resolution, or in a different stroke style. (d)
The agent effectively parses the input image into strokes. Each
stroke is depicted in a separate color (we show average across 100
samples).

Given that we made no effort whatsoever to adapt the ac-
tion space for this domain, it is not surprising that it takes
signiﬁcantly more time to discover the policy that produces
images resembling the target (Figure 7). As in the OM-
NIGLOT experiment, the (cid:96)2-based agent demonstrates some
improvement over the random policy but gets stuck and, as
a result, fails to learn sensible reconstructions (Figure 8b).

Although blurry, the model’s reconstruction closely matches
the high-level structure of each image. For instance the
background color, the position of the face and the color of
the person’s hair. In some cases, shadows around eyes and
the nose are visible. However, we observe that our model
tends to generate strokes in the ﬁrst half of the episode that
are fully occluded by strokes in the second half. We hy-
pothesize that this phenomenon is a consequence of credit
assignment being quite challenging in this task. One pos-
sible remedy is to provide the agent with a mid-episode
reward for reproducing a blurred version of the target image.
We leave this prospect for future work.

4.6. MUJOCO SCENES

For the MUJOCO SCENES dataset, we use our agent to con-
struct simple CAD programs that best explain input images.
Here we are only considering the case of conditional gener-
ation. Like before, the reward function for the generator can
be either the (cid:96)2 score or the discriminator output. We did not
provide any auxiliary reward signals. The model is unrolled
for 20 time steps, so it has the capacity to infer and represent
up to 20 objects and their attributes. As we mentioned in
Section 4.2, the training data consists of scenes with at most
5 objects. The agent does not have this knowledge a priori
and needs to learn to place the right number of primitives.

Figure 7. CELEBA reconstructions. The SPIRAL agent recon-
structs human faces in 20 strokes. Although blurry, the recon-
structions closely match the high-level structure of each image,
for instance the background color, the position of the face and the
color of the person’s hair. In some cases, shadows around eyes and
the nose are visible.

As shown in Figure 8b, the agent trained to directly min-
imize (cid:96)2 is unable to solve the task and has signiﬁcantly
higher pixel-wise error. In comparison, the discriminator-
based variant solves the task and produces near-perfect re-
constructions on a holdout set (Figure 10).

We note that our agent has to deal with a high-cardinality
action space intractable for a brute-force search. Indeed,
the total number of possible execution traces is M N , where
M = 4 · 162 · 3 · 43 · 3 is the total number of attribute settings
for a single object (see Section 4.2 for details) and N = 20
is the length of an episode.1 In order to demonstrate the com-
putational hardness of the task, we ran a general-purpose
Metropolis-Hastings inference algorithm on a set of 100
images. The algorithm samples an execution trace deﬁning
attributes for a maximum of 20 primitives. These attributes
are treated as latent variables. During each time step of infer-
ence, a block of attributes (including the presence/absence
ﬂag) corresponding to a single object is ﬂipped uniformly
within appropriate ranges. The resulting trace is rendered
by the environement into an output sample which is then
accepted or rejected using the Metropolis-Hastings update
rule, with a Gaussian likelihood centered around the test
image and a ﬁxed diagonal covariance of 0.25. As shown in
Figure 9, the MCMC search baseline was unable to solve
the task even after a large number of evaluations.

5. Discussion

Scaling visual program synthesis to real world and combina-
torial datasets has been a challenge. We have shown that it is

1The actual number of scene conﬁgurations is smaller but still

intractable.

Synthesizing Programs for Images using Reinforced Adversarial Learning

(a) MNIST and OMNIGLOT

(b) CELEBA and MUJOCO SCENES

Figure 8. (cid:96)2-distance between reconstructions and ground truth images over the course of training. Across all datasets, we observe
that training using a discriminator leads to signiﬁcantly lower (cid:96)2-distances, than when directly minimizing (cid:96)2. We also show in (a) that the
SPIRAL agent is capable of reconstructing even when it does not have access to the renderer in intermediate steps, however this does lead
to a small degradation in performance.

Figure 9. Blocked Metropolis-Hastings (MCMC) vs SPIRAL.
The MUJOCO SCENES dataset has a large combinatorial search
space. We ran a general-purpose MCMC algorithm with object
based blocked proposals and SPIRAL on 100 holdout images
during inference time. SPIRAL reliably processes every image
in a single pass. We ran the MCMC algorithm for thousands of
evaluations but it was unable to solve the task.

possible to train an adversarial generative agent employing
black-box rendering simulators. Our results indicate that
using the Wasserstein discriminator’s output as a reward
function with asynchronous reinforcement learning can pro-
vide a scaling path for visual program synthesis. The current
exploration strategy used in the agent is entropy-based, but
future work should address this limitation by employing so-
phisticated search algorithms for policy improvement. For
instance, Monte Carlo Tree Search can be used, analogous
to AlphaGo Zero (Silver et al., 2017). General-purpose
inference algorithms could also be used for this purpose.

Future work should explore different parameterizations of
action spaces. For instance, the use of two arbitrary control
points is perhaps not the best way to represent strokes, as it
is hard to deal with straight lines. Actions could also directly

Figure 10. 3D scene reconstructions. The SPIRAL agent is
trained to reconstruct 3D scenes by emitting sequences of com-
mands for the MuJoCo environment. In each pair, the left image
corresponds to the model’s output while the right one is the target.
Our method is capable of acurately inferring the number of objects,
their locations, sizes and colors.

parametrize 3D surfaces, planes and learned texture models
to invert richer visual scenes. On the reward side, using
a joint image-action discriminator similar to BiGAN/ALI
(Donahue et al., 2016; Dumoulin et al., 2016) (in this case,
the policy can viewed as an encoder, while the renderer be-
comes a decoder) could result in a more meaningful learning
signal, since D will be forced to focus on the semantics of
the image.

We hope that this paper provides an avenue to further explore
inverse simulation and program synthesis on applications
ranging from vision, graphics, speech, music and scientiﬁc
simulators.

00.511.5·1080.120.10.080.060.040.020Trainingframes‘2-distanceMNIST,‘2MNIST,DMNIST,D(blind)OMNIGLOT,‘2OMNIGLOT,D00.511.5·1080.40.30.20.10Trainingframes‘2-distanceCELEBA,‘2CELEBA,DMUJOCOSCENES,‘2MUJOCOSCENES,D02,0004,0006,0008,00000.050.1Iterations‘2-distanceSPIRALBlockedMCMCSynthesizing Programs for Images using Reinforced Adversarial Learning

Acknowledgements

We would like to thank Mike Chrzanowski, Michael Fig-
urnov, David Warde-Farley, Pushmeet Kohli, Sasha Vezh-
nevets and Suman Ravuri for helping with the manuscript
preparation as well as Sergey Bartunov, Ian Goodfellow,
Jacob Menick, Lasse Espeholt, Ivo Danihelka, Junyoung
Chung, C¸ a˘glar G¨ulc¸ehre, Dzmitry Bahdanau and Koray
Kavukcuoglu for insightful discussions and support.

References

Ackley, David H, Hinton, Geoffrey E, and Sejnowski, Ter-
rence J. A learning algorithm for boltzmann machines.
In Readings in Computer Vision. Elsevier, 1987.

Donahue,

Jeff, Kr¨ahenb¨uhl, Philipp,

and Darrell,
Trevor. Adversarial feature learning. arXiv preprint
arXiv:1605.09782, 2016.

Dumoulin, Vincent, Belghazi, Ishmael, Poole, Ben, Lamb,
Alex, Arjovsky, Martin, Mastropietro, Olivier, and
Courville, Aaron. Adversarially learned inference. arXiv
preprint arXiv:1606.00704, 2016.

Ellis, Kevin, Ritchie, Daniel, Solar-Lezama, Armando,
and Tenenbaum, Joshua B. Learning to infer graph-
ics programs from hand-drawn images. arXiv preprint
arXiv:1707.09627, 2017.

Eslami, SM Ali, Heess, Nicolas, Weber, Theophane, Tassa,
Yuval, Szepesvari, David, Kavukcuoglu, Koray, and Hin-
ton, Geoffrey E. Attend, infer, repeat: Fast scene under-
standing with generative models. In NIPS, 2016.

Espeholt, Lasse, Soyer, Hubert, Munos, Remi, Simonyan,
Karen, Mnih, Volodymir, Ward, Tom, Doron, Yotam,
Firoiu, Vlad, Harley, Tim, Dunning, Iain, Legg, Shane,
and Kavukcuoglu, Koray. IMPALA: Scalable distributed
deep-rl with importance weighted actor-learner architec-
tures. arXiv preprint arXiv:1802.01561, 2018.

Ganin, Yaroslav and Lempitsky, Victor. Unsupervised do-
main adaptation by backpropagation. In ICML, 2015.

Goodfellow, Ian, Pouget-Abadie, Jean, Mirza, Mehdi, Xu,
Bing, Warde-Farley, David, Ozair, Sherjil, Courville,
Aaron, and Bengio, Yoshua. Generative adversarial nets.
In NIPS, 2014.

Gregor, Karol, Danihelka, Ivo, Graves, Alex, Rezende,
Danilo, and Wierstra, Daan. Draw: A recurrent neural
network for image generation. In ICML, 2015.

Gulrajani, Ishaan, Ahmed, Faruk, Arjovsky, Martin, Du-
Improved

moulin, Vincent, and Courville, Aaron C.
training of wasserstein gans. In NIPS, 2017.

Ha, David and Eck, Douglas. A neural representation of
sketch drawings. arXiv preprint arXiv:1704.03477, 2017.

He, Kaiming, Zhang, Xiangyu, Ren, Shaoqing, and Sun,
Jian. Deep residual learning for image recognition. In
CVPR, 2016.

Hinton, Geoffrey E and Salakhutdinov, Ruslan R. Reducing
the dimensionality of data with neural networks. Science,
2006.

Ho, Jonathan and Ermon, Stefano. Generative adversarial

imitation learning. In NIPS, 2016.

Hochreiter, Sepp and Schmidhuber, J¨urgen. Long short-term

memory. Neural computation, 1997.

Isola, Phillip, Zhu, Jun-Yan, Zhou, Tinghui, and Efros,
Alexei A. Image-to-image translation with conditional
adversarial networks. In CVPR, 2017.

Jaderberg, Max, Dalibard, Valentin, Osindero, Simon, Czar-
necki, Wojciech M., Donahue, Jeff, Razavi, Ali, Vinyals,
Oriol, Green, Tim, Dunning, Iain, Simonyan, Karen, Fer-
nando, Chrisantha, and Kavukcuoglu, Koray. Popula-
tion based training of neural networks. arXiv preprint
arXiv:1711.09846, 2017.

Jampani, Varun, Nowozin, Sebastian, Loper, Matthew, and
Gehler, Peter V. The informed sampler: A discriminative
approach to bayesian inference in generative computer
vision models. CVIU, 2015.

Kingma, Diederik P and Ba, Jimmy. Adam: A method for
stochastic optimization. arXiv preprint arXiv:1412.6980,
2014.

Kingma, Diederik P and Welling, Max. Auto-encoding
variational bayes. arXiv preprint arXiv:1312.6114, 2013.

Kulkarni, Tejas D, Kohli, Pushmeet, Tenenbaum, Joshua B,
and Mansinghka, Vikash. Picture: A probabilistic pro-
In CVPR,
gramming language for scene perception.
2015a.

Kulkarni, Tejas D, Whitney, William F, Kohli, Pushmeet,
and Tenenbaum, Josh. Deep convolutional inverse graph-
ics network. In NIPS, 2015b.

Lake, Brenden M, Salakhutdinov, Ruslan, and Tenenbaum,
Joshua B. Human-level concept learning through proba-
bilistic program induction. Science, 2015.

Lake, Brenden M, Ullman, Tomer D, Tenenbaum, Joshua B,
and Gershman, Samuel J. Building machines that learn
and think like people. Behavioral and Brain Sciences, 40,
2017.

Synthesizing Programs for Images using Reinforced Adversarial Learning

LeCun, Yann, Bottou, L´eon, Bengio, Yoshua, and Haffner,
Patrick. Gradient-based learning applied to document
recognition. Proceedings of the IEEE, 86(11), 1998.

Rezende, Danilo, Danihelka, Ivo, Gregor, Karol, Wierstra,
Daan, et al. One-shot generalization in deep generative
models. In ICML, 2016.

LeCun, Yann, Bengio, Yoshua, and Hinton, Geoffrey. Deep

learning. Nature, 2015.

libmypaint contributors. libmypaint. https://github.

com/mypaint/libmypaint, 2018.

Liu, Ziwei, Luo, Ping, Wang, Xiaogang, and Tang, Xiaoou.
Deep learning face attributes in the wild. In ICCV, 2015.

Loper, Matthew M and Black, Michael J. Opendr: An
approximate differentiable renderer. In ECCV, 2014.

Mansinghka, Vikash K, Kulkarni, Tejas D, Perov, Yura N,
and Tenenbaum, Josh. Approximate bayesian image in-
terpretation using generative probabilistic graphics pro-
grams. In NIPS, 2013.

Sharma, Gopal, Goyal, Rishabh, Liu, Difan, Kalogerakis,
Evangelos, and Maji, Subhransu. CSGNet: Neural shape
parser for constructive solid geometry. arXiv preprint
arXiv:1712.08290, 2017.

Silver, David, Schrittwieser, Julian, Simonyan, Karen,
Antonoglou, Ioannis, Huang, Aja, Guez, Arthur, Hubert,
Thomas, Baker, Lucas, Lai, Matthew, Bolton, Adrian,
et al. Mastering the game of go without human knowl-
edge. Nature, 2017.

Sutskever, Ilya, Vinyals, Oriol, and Le, Quoc V. Sequence to
sequence learning with neural networks. In NIPS, 2014.

Todorov, Emanuel, Erez, Tom, and Tassa, Yuval. Mujoco: A
physics engine for model-based control. In IROS, 2012.

Merel, Josh, Tassa, Yuval, Srinivasan, Sriram, Lemmon, Jay,
Wang, Ziyu, Wayne, Greg, and Heess, Nicolas. Learn-
ing human behaviors from motion capture by adversarial
imitation. arXiv preprint arXiv:1707.02201, 2017.

Tung, Hsiao-Yu Fish, Harley, Adam W, Seto, William, and
Fragkiadaki, Katerina. Adversarial inverse graphics net-
works: Learning 2d-to-3d lifting and image-to-image
translation from unpaired supervision. In ICCV, 2017.

Mirza, Mehdi and Osindero, Simon. Conditional generative
adversarial nets. arXiv preprint arXiv:1411.1784, 2014.

Villani, C´edric. Optimal transport: old and new. Springer

Science & Business Media, 2008.

Williams, Ronald J. Simple statistical gradient-following
algorithms for connectionist reinforcement learning. In
Reinforcement Learning. Springer, 1992.

Wu, Jiajun, Lu, Erika, Kohli, Pushmeet, Freeman, Bill, and
Tenenbaum, Josh. Learning to see physics via visual
de-animation. In NIPS, 2017a.

Wu, Jiajun, Tenenbaum, Joshua B, and Kohli, Pushmeet.

Neural scene de-rendering. In CVPR, 2017b.

Xie, Ning, Hachiya, Hirotaka, and Sugiyama, Masashi.
Artist agent: A reinforcement learning approach to auto-
matic stroke generation in oriental ink painting. IEICE
Transactions on Information and Systems, 2013.

Zhu, Jun-Yan, Park, Taesung, Isola, Phillip, and Efros,
Alexei A. Unpaired image-to-image translation using
cycle-consistent adversarial networks. In CVPR, 2017.

Mnih, Volodymyr, Badia, Adria Puigdomenech, Mirza,
Mehdi, Graves, Alex, Lillicrap, Timothy, Harley, Tim,
Silver, David, and Kavukcuoglu, Koray. Asynchronous
methods for deep reinforcement learning. In ICML, 2016.

Nair, Vinod and Hinton, Geoffrey E. Inferring motor pro-
grams from images of handwritten digits. In NIPS, 2006.

Nair, Vinod, Susskind, Josh, and Hinton, Geoffrey E.
Analysis-by-synthesis by learning to invert generative
black boxes. In ICANN, 2008.

Oord, Aaron van den, Kalchbrenner, Nal, and Kavukcuoglu,
Koray. Pixel recurrent neural networks. In ICML, 2016.

Paysan, Pascal, Knothe, Reinhard, Amberg, Brian, Romd-
hani, Sami, and Vetter, Thomas. A 3d face model for
pose and illumination invariant face recognition. In AVSS,
2009.

Radford, Alec, Metz, Luke, and Chintala, Soumith. Un-
supervised representation learning with deep convolu-
tional generative adversarial networks. arXiv preprint
arXiv:1511.06434, 2015.

Reed, Scott, Oord, A¨aron, Kalchbrenner, Nal, Colmenarejo,
Sergio G´omez, Wang, Ziyu, Chen, Yutian, Belov, Dan,
and Freitas, Nando. Parallel multiscale autoregressive
density estimation. In ICML, 2017.

Synthesizing Programs for Images using Reinforced Adversarial Learning

A. Optimal D for Conditional Generation

It turns out that in the case of conditional generation (i.e.,
pd is a Dirac δ-function), we can derive an explicit form of
the optimal (non-parametric) discriminator D. Indeed, (1)
corresponds to the dual representation of the Wasserstein-1
metric (Villani, 2008). The primal form of that metric is
deﬁned as

W1(pg, pd) =

inf
γ∈Γ(pg,pd)

(cid:90)

(cid:107)x − y(cid:107)2 dγ(x, y) ,

(8)

where Γ(pg, pd) is a set of all couplings between pg and pd.
Taking into account that the data distribution is a point mass,
we can simplify (8):

W1(pg, pd) = Ex∼pg (cid:107)x − xtarget(cid:107)2 .

(9)

The expression above gives the optimal value for LD in (1).
Therefore D(x) = (cid:107)x − xtarget(cid:107)2 is a solution of (1):

LD((cid:107)x − xtarget(cid:107)2) = − (cid:107)xtarget − xtarget(cid:107)2

+ Ex∼pg (cid:107)x − xtarget(cid:107)2
+ 0 ,

(10)

where the last term (R) is zero since the Euclidean distance
belongs to the set of 1-Lipschitz functions.

This result suggests that for inverse graphics, in (4), one may
use a ﬁxed image distance (like the Euclidean distance (cid:96)2)
instead of a parametric function optimized via the WGAN
objective. Note, however, that (cid:96)2 is not a unique solution to
(1). Consider, for example, the case where the model distri-
bution is also a Dirac delta centered at xg. The Wasserstein
distance is equal to d = (cid:107)xg − xtarget(cid:107)2. In order to achieve
that value in (1), we could take any D such that ∀ α ∈ [0, 1]

D (α xg + (1 − α) xtarget) = α · d ,

(11)

and Lip(D) ≤ 1. One example of such function would be
a hyperplane H containing the segment (11). Let us now
consider a set of points

V = (cid:8)x | (cid:107)x − xg(cid:107)2 < ε, (cid:107)x − xtarget(cid:107)2 = d(cid:9)

(12)

in an ε-vicinity of xg. By deﬁnition, (cid:107)x − xtarget(cid:107)2 is con-
stant for any x ∈ V . That means that (cid:96)2 expresses no
preference over points that are equidistant from xtarget even
though some of them may be semantically closer to xtarget.
This property may signiﬁcantly slow down learning if we
are relying on (cid:96)2 (or similar distance) as our training signal.
Functions like H, on the other hand, have non-zero slope
in V and therefore can potentially shift the search towards
more promising subspaces.

One other reason why discriminator training is different
from using a ﬁxed image distance is that in practice, we do

not optimize the exact dual formulation of the Wasserstein
distance and, on top of that, use stochastic gradient descent
methods which we do not run until convergence. A toy
example illustrating that difference is presented in Figure 11.

B. Network Architectures

The policy network (shown in Figure 12) takes the observa-
tion (i.e., the current state of the canvas Ct) and conditions
it on a tuple corresponding to the last performed action at.
The resulting features are then downsampled to a lower-
dimensional spatial resolution by means of strided convo-
lutions and passed through a stack of ResNet blocks (He
et al., 2016) followed by a fully-connected layer. This yields
an embedding which we feed into an LSTM (Hochreiter &
Schmidhuber, 1997). The LSTM produces a hidden vec-
tor z0 serving as a seed for the action sampling procedure
described below.

In order to obtain at+1, we employ an autoregressive de-
coder depicted in Figure 13. Each component ai
t+1 is sam-
pled from a categorical distribution whose parameters are
computed as a function of zi. We use two kinds of functions
depending on whether ai
t+1 corresponds to a scalar (e.g.,
brush size) or to a spatial location (e.g., a control point of
a B´ezier curve). In the scalar case, zi is transformed by a
fully-connected layer, otherwise we process it using several
ResNet blocks followed by a series of transpose convolu-
tions and a ﬁnal convolution. After ai
t+1 is sampled, we
obtain an updated hidden vector zi+1 by embedding ai
t+1
into a 16-dimensional code and combining it with zi. The
procedure is repeated until the entire action tuple has been
generated.

For the discriminator network, we use a conventional archi-
tecture similar to DCGAN (Radford et al., 2015).

C. Training Details

Following standard practice in the GAN literature, we op-
timize the discriminator objective using Adam (Kingma &
Ba, 2014) with a learning rate of 10−4 and β1 set to 0.5.
For generator training, we employ population-based explo-
ration of hyperparameters (PBT) (Jaderberg et al., 2017)
to ﬁnd values for the entropy loss coefﬁcient and learning
rate of the policy learner. A population contains 12 training
instances with each instance running 64 CPU actor jobs
and 2 GPU jobs (1 for the policy learner and 1 for the dis-
criminator learner). We assume that discriminator scores
are compatible across different instances and use them as a
measure of ﬁtness in the exploitation phase of PBT.

The batch size is set to 64 on both the policy learner and dis-
criminator learner. The generated data is sampled uniformly
from a replay buffer with a capacity of 20 batches.

Synthesizing Programs for Images using Reinforced Adversarial Learning

· · ·

Input images (the set of x)

xtarget

(a) Data.

(b) (cid:96)2-distance to xtarget.

(c) D(x, xtarget).

Figure 11. A toy experiment illustrating the difference between (cid:96)2 and discriminator training in practice. (a) We collect a dataset of
images with a single solid circle in all possible locations (top) and pick one of them as a target image (bottom). (b) The (cid:96)2-distance (in the
pixel space) from the input images to the target as a function of the circle location; the surface is ﬂat around the borders since the circles
do not overlap. (c) We train a discriminative model D that takes a pair of images and tells whether they match or not; just like (cid:96)2, the
resulting function has a pit centered at the target location, but unlike (b), the surface now has better behaved gradients.

Ct
[64,64,3]

Conv 5x5
[64,64,32]

at
[1]

MLP
[16]

Add
[64,64,32]

Concat+FC
[32]

3 ×

Conv 4x4
(stride=2)
[·/2,·/2,32]

8 ×

ResBlock 3x3
[8,8,32]

Flatten+FC
[256]

Last state

LSTM
[256]

Next state

Decoder
(see Figure 13)

at+1
[1]

Figure 12. The architecture of the policy network for a single
step. FC refers to a fully-connected layer, MLP is a multilayer
perceptron, Conv is a convolutional layer and ResBlock is a
residual block. We give the dimensions of the output tensors in the
square brackets. ReLU activations between the layers have been
omitted for brevity.

zi
[256]

scalar

FC
[N]

location

Reshape
[4,4,16]

ResBlock 3x3
[8,8,32]

×8

Deconv 4x4
(stride=2)
[·*2,·*2,32]

×2

Conv 3x3
[32,32,1]

Reshape
[32*32]

ai
t+1
[1]

Sample
[1]

MLP
[16]

Concat+FC
[256]

zi+1
[256]

Figure 13. The architecture of the autoregressive decoder for
sampling an element ai
t+1 of the action tuple. The initial hid-
den vector z0 is provided by an upstream LSTM. Depending on
the type of the subaction to be sampled, we use either the scalar
or the location branch of the diagram.

