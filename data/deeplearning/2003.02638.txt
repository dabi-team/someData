Metric-Based Imitation Learning Between Two Dissimilar
Anthropomorphic Robotic Arms

Marcus Ebner von Eschenbach1,2, Binyamin Manela1, Jan Peters2, Armin Biess1

0
2
0
2

b
e
F
5
2

]

O
R
.
s
c
[

1
v
8
3
6
2
0
.
3
0
0
2
:
v
i
X
r
a

Abstract— The development of autonomous robotic systems
that can learn from human demonstrations to imitate a desired
behavior - rather than being manually programmed - has
huge technological potential. One major challenge in imitation
learning is the correspondence problem: how to establish cor-
responding states and actions between the expert and learner,
when the embodiments of the agents are different (morphology,
dynamics, degrees of freedom, etc.). Many existing approaches
in imitation learning circumvent the correspondence problem,
for example, kinesthetic teaching or teleoperation, which are
performed on the robot. In this work we explicitly address
the correspondence problem by introducing a distance measure
between dissimilar embodiments. This measure is then used as a
loss function for static pose imitation and as a feedback signal
within a model-free deep reinforcement learning framework
for dynamic movement imitation between two anthropomorphic
robotic arms in simulation. We ﬁnd that the measure is well
suited for describing the similarity between embodiments and
for learning imitation policies by distance minimization.

I. INTRODUCTION

Approaches to imitation learning in robotics have deliv-
ered huge success ranging from helicopter acrobatics [1],
high-speed arm skills [2], haptic control [3], [4], gestures [5],
manipulation [6], [7], [8] to legged locomotion [9], [8]. The
machine learning algorithms that make imitation learning
possible are well studied and have recently been sum-
marized [10]. Surprisingly, despite all of these impressive
successes in the acquisition of new robot motor skills, fun-
damental research questions in imitation learning of central
importance have remained open for decades. Among such
core questions is the correspondence problem: how can one
agent (the learner or imitator) produce a similar behavior -
in some aspect - to behavior it perceives in another agent
(the expert or demonstrator), given that
the two agents
obey different kinematics and dynamics (body morphology,
degrees of freedom (DOFs), constraints, joints and actuators,
torque limits), i.e., occupy different state spaces [11]?

Existing algorithmic approaches towards imitation learn-
ing can be divided into two groups: behavioral cloning (BC)
and inverse reinforcement learning (IRL) or inverse optimal
control (IOC), both can be further subdivided into model-
based and model-free approaches depending on whether the
system dynamics is available or not [10]. BC and IRL make

*This work was supported in part by the Helmsley Charitable Trust
through the Agricultural, Biological and Cognitive Robotics Initiative and
the Israel Science Foundation (grant no. 1627/17).

1Department
of
Gurion University
abiess@bgu.ac.il

Industrial Engineering
of

the Negev, Be’er

and Management Ben-
Israel

84105,

Sheva

2 Intelligent Autonomous Systems Group Technical University Darm-
stadt, 64289 Darmstadt, Germany Germany mail@jan-peters.net

(a)

(b)

Fig. 1: Static pose imitation between dissimilar antrophomor-
phic robotic arms using a 7-DOF-Panda expert. (a) 4-DOF-
Panda learner; (b) 3-DOF-Panda learner. Dissimilar robots
are generated by locking DOFs (expert is shown on the left,
the learner on the right, locked joints in red).

different assumptions about the correspondence of learner
and expert. In BC, a mapping from states to actions is
generated from the demonstrations using supervised learning
methods. This mapping can then be used by the learner to
reproduce similar behavior, provided that the embodiments
of expert and learner are alike, otherwise the method will
fail due to lack of correspondence.

Successful

implementations of model-based BC algo-
rithms have been obtained for a hitting-a-ball
task with
an underactuated robot [12], playing video games [13] and
controlling a UAV through a real forest [14]. Model-free
BC algorithms have been implemented for autonomous RC
helicopter ﬂight using experts demonstrations [1] and for
learning tasks, such as tennis swings [15], ball-paddling [2]
and human-robot collaborative motions in tool-handover
tasks [16], autonomous knot-tying using a surgical robot [17]
and character animation [18].

In an IRL framework, the learner infers a reward function
for a given task from expert demonstrations of the task.

 
 
 
 
 
 
The underlying assumption is that the reward function is a
parsimonious and portable representation of the task, which
can be transferred and generalized to agents with different
embodiments. Thus, IRL implicitly resolves the correspon-
dence problem but has the disadvantage of being computa-
tionally expensive and requires reinforcement learning in an
inner loop. IRL has been implemented mostly in a model-
based approach for tasks, such as learning to drive a car in
a simulator [19] and path planning [20], [21], [22]. A few
model-free IRL algorithms have been proposed and used to
learn policies of robot motion [4], [23], [24].

The correspondence problem results in the following ques-
tion: what action sequence in the learner is required to
produce behavior that is similar to the expert, given that
learner and expert have different embodiments and given
that a measure of similarity d is deﬁned. If we denote
the state-action pairs of the expert and learner as (st, at)
and (ˆst, ˆat), respectively, with t = 1, 2, . . . T ,
then we
can formulate the correspondence problem in its simplest
form as follows: for a given set of demonstrations D =
{s1, a1, . . . , aT −1, sT }N
i=1 ﬁnd actions ˆat, t = 1, 2, . . . T , so
that ˆst is similar to st for all t = 1, 2, . . . T , where similarity
(negative loss) is deﬁned as (cid:80)T
t=1 d(st, ˆst) → min.
Note that the states depend on the actions via the system
dynamics, thus, it is st+1 = f (st, at) and ˆst+1 = ˆf (ˆst, ˆat),
where f and ˆf describe the system dynamics of expert
and learner, respectively. Several levels of complexity can
be added to this formulation. (1) Generally, the dynamics
for real systems are stochastic, thus, st+1 = f (st, at) + (cid:15)t
and ˆst+1 = ˆf (ˆst, ˆat) + ˆ(cid:15)t, where (cid:15)t and ˆ(cid:15)t is noise. In
this case the distance can be measured between probability
distributions of state vectors, (cid:80)T
t=1 d(p(st), ˆp(ˆst)) → min,
where p(st) and ˆp(ˆst) denote the probability distribution for
expert and learner, respectively (2) The system dynamics of
expert and/or learner are often not known, leading to model-
free vs. model-based approaches. (3) The demonstrations are
often given in the form D = {s1, . . . , sT }, i.e., the actions of
the expert are not available. (4) The states of the expert may
be only partially observable, for instance, if the environment
is observed by cameras. The states must then be inferred
from observations ot only.

In this work we study imitation tasks between two dis-
similar anthropomorphic robot arms, which are generated by
locking degrees of freedom (DOFs) in the learner. Through-
out this work we assume that the dynamics of the learner
are not available to the learning agent, thus, we are in a
model-free setting. We ﬁrst introduce our deﬁnition of an
embodiment state and provide a distance measure to assess
the similarity between embodiments. This distance measure
is then used to imitate static poses using neural networks
(Fig.1) and as a feedback signal for movement imitation
using reinforcement learning.

II. RELATED WORK

Metric approaches to the correspondence problem in imi-
tation have been developed in a series of studies [25], [26],
[27], [28], [29], [30]. In these studies, the correspondence

problem was formulated in state-action space with separate
metrics for states and actions. Simple global metrics based
on the Hamming norm, Euclidean distance and inﬁnity norm
(Lp-norms) were used to measure the similarity between
expert and learner. Another approach to the correspondence
problem is to explicitly learn the forward dynamics of
the learner. The actions of the learner are then adapted
to the given demonstrations by using the learned forward
dynamics. Within this framework, Englert et al. [12] have
used the Kullback-Leibler divergence as similarity measure
to compare trajectory distributions from an expert and a robot
learner. Similarly, Grimes et al. [31], [32] have used Gaussian
Mixture Models to learn a forward model and infer optimal
actions of the learner. The model has been used to transfer
human motions to a humanoid robot.

III. METHODS

A. Deﬁnition of an embodiment

In this study an embodiment consists of a chain of links,
which are represented by frames that are attached to each
link. Frames are commonly used in robotics to describe
the orientation and translation (pose) of rigid bodies with
respect to a laboratory frame. Frames are elements of the
special Euclidean group SE(3), which is a non-Euclidean
manifold and group (Lie-group). Frames can be represented
as homogeneous matrices deﬁned as

T =

(cid:21)

(cid:20) R p
0T
1

,

(1)

where R ∈ SO(3) is a rotation matrix (RRT = RT R =
I, det R = 1) and p ∈ R3 is a column vector, describing
the orientation and translation of a frame, respectively, with
respect to a reference frame. For simplicity we write T =
[R, p]. The inverse is then deﬁned as T −1 = [RT , −RT p].
The conﬁguration space of an embodiment consisting of n
links with attached frames can be described by an element
of the direct product space SE(3)n = SE(3) × SE(3) ×
· · · × SE(3) (n copies). The velocity of a frame is described
by a twist, which encodes the rotational and translational
velocity of the rigid body. A twist is an element of the Lie-
algebra se(3), which deﬁnes a vector space. The velocity of
the embodiment consisting of n frames is described by an
element of the direct product space se(3)n = se(3)×se(3)×
· · · × se(3) (n copies). A twist can be represented by 4 × 4
matrices of the form

or

V b = T −1 ˙T =

(cid:21)

(cid:20)[ωb] vb
0

0T

V s = ˙T T −1 =

(cid:21)

(cid:20)[ωs] vs
0

0T

,

(2)

(3)

where (2) deﬁnes the body twist and (3) the spatial twist. The
notation [·] denotes a skew symmetric 3×3 matrix composed

of the components of the angular velocity ω = [ω1, ω2, ω3]T ,
that is

[ω] = −[ω]T =





0
ω3
−ω2

−ω3
0
ω1



 .

ω2
−ω1
0

(4)

Speciﬁcally, [ωb] = RT ˙R ∈ R3×3 and vb = RT ˙p ∈ R3
deﬁne the angular velocity and translational velocity of the
origin with respect
to the base frame, respectively, both
expressed in coordinates of the body frame. A similar but
interpretation can be given to the
less intuitive physical
spatial twist. For simplicity we write V = [ω, v]. The joint
of the ﬁrst
link is always attached to the origin of the
base frame, which serves as a reference frame in which all
comparisons will be performed. Each joint rotates around
one axis. The forward kinematic map is a map from joint
angles q = [q1, q2, . . . , qn]T to frames q → T (q), where n
denotes the number of DOFs. For simplicity we ﬁrst consider
a planar manipulator with n DOFs. We assume that all links
have cylindrical shape and constant mass density. We attach
a frame to each link i with its origin at a distance of ri from
joint i − 1, i = 1, . . . , n, and with the x-axis that is pointing
along the link direction. The transformation from link frame
i to the base frame 0 can then be described by a product of
matrix exponentials

T0i(q1, q2, . . . , qi) = eq1S1 eq2S2 . . . eqiSiMi ,

(5)

where

Mi =







1 0 0
0 1 0
0 0 1
0 0 0







ri
0
0
1

, Si =

(cid:20)[ni] −ni × qi

(cid:21)

0

0

,

(6)

for i = 1, . . . , n. The homogeneous matrix Mi describes a
constant shift of the frame i by ri along the x-axis. The screw
Si ∈ se(3) is a 4 × 4 matrix and describes the rotation axis
of the revolute joint i. Here ni denotes a unit vector in the
direction of the joint axis i, qi is a vector from the base to
any point on the joint axis i (both expressed in coordinates
with respect to the base frame) and × denotes the vector
cross product. Common choices for ri are ri = li/2, which
corresponds to attaching frames to the center of mass (COM)
of each link (our choice) and ri = li, which corresponds to
attaching frames to the end of each link. Joint angles and
joint velocities ˙q = [ ˙q1, ˙q2, . . . , ˙qn]T determine the twists,
thus (q, ˙q) → V(q, ˙q). The (body) twists follow from (2)
and (5) as (i = 1, . . . , n)

V0i = T −1

0i (q1, q2, . . . , qi) ·

˙T0i(q1, q2, . . . , qi) ,

which can be determined recursively leading to

V0i = Ad[MieSiqi ]−1(V0i−1) + Si ˙qi ,

(7)

(8)

where the adjoint map AdT (V) for frame T = [R, p] and
twist V = [ω, v] is deﬁned as AdT (V) = [Rω, p × Rω +
Rv] ∈ se(3) and V00 := 0 [33]. Note that from the (body)
twists V0i = [ω0i, v0i] the angular velocity and translational

(a)

(b)

(c)

Fig. 2: Pose imitation task between planar manipulators. (a)
Demonstrator pose; (b, c) Learner poses. Learner (b) gen-
erates perfect imitation if similarity is deﬁned by candidate
points, e.g., end-effector position. However, for a similarity
measure based on frames,
the two embodiments do not
resemble each other. Learner (c) – consisting only of two
links – provides better imitation than learner (b) if similarity
is measured between frames attached to each link.

velocity of frame T0i = [R0i, p0i] with respect to the base
frame can be easily obtained by

ωs
0i = R0iω0i ,
˙p0i = R0iv0i .

(9)

(10)

For further details using frames and twists we refer to
[34]. After these derivations we can deﬁne the state of an
embodiment s as the state of all frames

s = (s1, . . . , si, . . . , sn)

= (T01, V01, . . . , T0i, V0i, . . . , T0n, V0n) ,

(11)

where we surpressed the arguments and si = (T0i, V0i) ∈
S i denotes the state of frame i. Note that via the foward
kinematic map, which is assumed to be known in this work,
an embodiment state is fully determined by its joint angles
q and joint velocities ˙q, i.e., s = s(q, ˙q). A special case of
(11) is obtained when ignoring rotational information. In this
case, an embodiment can be described by the position and
(translational) velocity of a set of candidate points, deﬁned
by the origin of each frame (by setting R = I in (1), (2)).
The embodiment state is then described by

s = (x1, v1, . . . , xi, vi, . . . , xn, vn) ,

(12)

where si = (xi, vi) denotes the state vector of candi-
date point i. The deﬁnition of an embodiment in terms of
frames/twists and candidate points is generic and can be
applied to any robot. A disadvantage of using frames is that
they are not elements of a vector space, but deﬁne a non-
Euclidean manifold.

B. Similarity between embodiments

Similarity of embodiments can be assessed by deﬁning
a distance measure d between frames/twists or candidate
points, that is

d(si, ˆsj) : S i × ˆS j (cid:55)→ R+
0 ,
where si ∈ S i and ˆsj ∈ ˆS j result from different state spaces.
We ﬁrst consider the distance

d(Ti, ˆTj) = αtrdtr(Ti, ˆTj) + αrotdrot(Ti, ˆTj) (13)

0.40.20.00.20.4x0.00.20.40.60.8y0.40.20.00.20.4x0.40.20.00.20.4xbetween two frames, Ti = [Ri, pi] and ˆTj = [ ˆRj, ˆpj]. The
distance consists of a translational and rotational part, which
are weighted with factors αtr and αrot. The weights can
be either constants or functions of other variables. For the
translational part we set the Euclidean distance between the
two frame origins

dtr(Ti, ˆTj) = (cid:107)pi − ˆpj(cid:107) .

(14)

There are various ways to deﬁne the rotational distance
between frames. We choose to take the angle between the
unit vectors pointing along the x-axes of the frames, i.e., into
the directions of the links. Thus, we deﬁne

β = arccos(ei

x · ˆej
x)

(15)

leading to values in the interval [0, π]. This deﬁnition results
in numerical problems when performing gradient descent
because the derivative of the arccos-function is

d
dx

arccos x = −

√

1
1 − x2

.

(16)

To avoid singularities, a modiﬁed rotational distance can be
deﬁned by shifting the negated cos β into the interval [0, π]
as

drot(Ti, ˆTj) =

π
2

(1 − cos β) =

π
2

(1 − ei

x · ˆej

x) .

(17)

the direction of the x-axis of frame T0i =
Note that
[R0i, p0i] with respect to the laboratory frame can be easily
extracted as the ﬁrst column of the rotation matrix R0i.
The distance measure introduced in (13), (14) and (17)
includes only the static pose of the embodiment and frames
might be considered similar, even though they move into
different directions. To include also motion information into
the distance measure, the twists of the frames need to be
taken into consideration. For dynamic motion imitation we
therefore augment the distance measure between two states
si = (Ti, Vi) ∈ S i and ˆsj = ( ˆTj, ˆVj) ∈ ˆS j by including
the translational and angular velocity (9) and (10), that is

d(si, ˆsj) = αtrdtr + αrotdrot + αvdv + αωdω ,

(18)

with

dv = (cid:107) ˙pi − ˙ˆpj(cid:107)

and

dω = (cid:107)ωs

i − ˆωs

j (cid:107) .

(19)

Note that the distance measure between two states si and ˆsj,
can be extended over all state spaces by deﬁning the sum of
all mutual distances

d(s, ˆs) =

n
(cid:88)

ˆn
(cid:88)

i=1

j=1

d(si, ˆsj) .

(20)

In the next section a weighted version of (20) will be
introduced by incorporating link correspondences.

C. Link Correspondences

To measure similarity between links of two embodiments,
we ﬁrst deﬁne how correspondence between links of different
embodiments can be established. Embodiments may differ
in the number and length of links, and thus, a one-to-one
assignment between links is often not possible. To estab-
lish correspondence between links of different embodiments
with possibly different overall size, we ﬁrst rescale each
embodiment by the sum of its link lengths L, resulting in
a chain length of 1. To establish correspondence, we assign
a weight for every possible link-pair combination. Thus, for
two embodiments 1 and 2 with n and ˆn links, respectively,
link correspondence can be represented by a correspondence
matrix W ∈ Rn×ˆn. Irrelevant combinations result in zero
or close to zero entries and higher values indicate higher
relevance. Each row of the correspondence matrix contains
the correspondence weights of one link of embodiment 1
to all other links of embodiment 2, where the highest value
indicates which link is the most relevant from all links of
embodiment 2. The elements of the correspondence matrix
can either be calculated as a function of embodiment states
or pre-calculated for a pair of embodiments, independent of
their current state.

State-Dependent Assignment. For state-dependent calcu-
lations of the correspondence matrix W (s, ˆs), weights are
calculated using the distance measure between frames. The
the higher the weight for this pair
closer the distance,
of frames. To obtain the correspondence matrix W (s, ˆs),
the mutual distance matrix D(cid:48)(s, ˆs) = (D(cid:48)(si, ˆsj)) , i =
1 . . . n, j = 1 . . . ˆn, between all links of the two embodi-
ments is computed using the distance measure in (13). A
correspondence matrix can be generated by replacing the
smallest element of each row of D(cid:48)(s, ˆs) with 1 and all
other elements with 0, resulting in a binary matrix W12(s, ˆs)
that assigns exactly one link of embodiment 1 to each link
of embodiment 2 with a weight 1. The same operation
can be applied for each column of D(cid:48)(s, ˆs), resulting in
W21. Adding W12 to W21 results in a correspondence
matrix W . A correspondence matrix that only uses the
minimum for each row and each column is very selective
and ignores the fact that more than one link of the other
embodiment may be lying in a similar distance and should
be taken into consideration. This effect can be mitigated by
applying a softmax function to the rows and columns of
the correspondence matrix, after multiplying with a constant
factor ξ < 0 to ﬁnd soft minima instead of maxima and to
adjust the distinctness of the minimum.

D. Calculating Distance Between Embodiments

We deﬁne distance between embodiments as element-wise
multiplication of the distance function with the correspon-
dence matrix i.e., D(s, ˆs) = W (s, ˆs)◦D(cid:48)(s, ˆs), where ◦ de-
notes the Hadamard product. Only distances between corre-
sponding link pairs remain because non-corresponding pairs
are weighted with zero or near-zero values. To obtain one
single scalar number, the mean of all entries of the resulting
matrix is taken. Matrix norms, such as the Frobenius norm,

can also be used. For the evaluation of the correspondence
matrix and the distance matrix, suitable weights, αtr and
αrot, need to be chosen. Different settings are possible here.
The pseudo-code for calculating the distance measure are
shown in Algorithm 1.

i=1 × { ˆTj}ˆn

Function distance measure(s(q), ˆs( ˆq), αtr, αrot)
i=1, { ˆTj}ˆn

j=1 from q, ˆq using

Calculate {Ti}n
forward kinematics.
D ← d(T , ˆT , αtr, αrot) f oreach (T , ˆT ) in
{Ti}n
Either calculate correspondence matrix W (s, ˆs) or
use static correspondence matrix W .
DW ← D ◦ W
(cid:80)n
DW =
return DW

j=1 DW,ij
mn

(cid:80)m

j=1

i=1

Algorithm 1: Calculating the Distance Measure

IV. RESULTS

We studied static and dynamic imitation tasks in simula-
tion between two dissimilar embodiments using the previ-
ously derived distance measure. First, we present results of
static pose imitation tasks between planar manipulators with
different links using gradient descent. Second, we examined
whether a neural network can learn the optimal static pose
between two planar manipulators and, furthermore, between
two Franka Emika Panda robots for a given expert pose. In
addition, we investigated how well the learner generalized
to poses it has not seen during training. Third, we present
results for a dynamic imitation tasks between two Franka
Emika Panda robotic arms. For this purpose, a simulation
environment was built in the physics simulator Gazebo. In all
simulations, we assumed that the learner has no knowledge
of the robot dynamics.

A. Static Pose Imitation Task

In a static pose imitation task, the optimal pose of the
learner, ˆq∗ is obtained for a given pose of the expert, q, by
minimization of the distance measure

ˆq∗ = arg min

d(s(q), ˆs( ˆq)) .

(21)

ˆq

Minimizing the distance function is a nonlinear optimization
problem for which generally no analytical solution exists, in
particular, for embodiments with a large number of links. Us-
ing mathematical libraries such as TensorFlow, the gradient
of the distance function can be computed and local minima
can be found numerically via gradient descent. Instead of
trying to solve the optimization problem repeatedly for each
input, we can learn a mapping from joint angles of the
expert to joint angles of the learner fθ : q −→ ˆq, where
q ∈ [−π, π]n and ˆq ∈ [−π, π]ˆn. The function fθ can be
approximated by a neural network with weight parameters
θ. The distance measure was implemented as a computation
graph in TensorFlow [35].

(a) αtr = 0.5, αrot = 1.0

(b) αtr = 3.0, αrot = 1.0

(c) αtr = 1.0, αrot = 1.0

(d)

(e)

(f)

Fig. 3: (a-c) Effects of using different distance weighting
factors on pose imitation between two planar manipulators
(expert: blue, learner: orange).
(d-f) Distance function between planar manipulators with
two links. (d) State-dependent weight matrix with αtr =
1.5, αrot = 1.0; (e) State-dependent weight matrix with
distance-dependent weighting factors; (f) State-independent
weight matrix, considering only rotational distance between
corresponding links (αtr = 0). The distance is plotted over
all possible joint angles of one embodiment, while the other
manipulator remains ﬁxed at q = [1.5, −1.5].

Comparing Link Correspondences. Before training the
neural network, we analyzed the behavior of the distance
function for a simple toy model. Fig. 3a-c shows an imitation
task between planar manipulators with two links. The dis-
tance was measured using a state-dependent correspondence
matrix W , using varying weight factors αtr, αrot. Each pose
of the learner was found via gradient descent. The choice of
weight factors clearly has a strong inﬂuence on the quality
of the result. Balancing between translational and rotational
weights is challenging. One possibility to overcome this
difﬁculty may be to simply use the translational distance
as the translational weight and to redeﬁne the rotational
weight by subtracting the translational distance from its
maximum value and rescaling from [0, π] to [0, 2]. This way,
translational and rotational distance are in the same value
range, i.e.,

αtr = dtr, αrot =

2
π

(2 − dtr).

(22)

3210123q1,13210123q1,20246810121416Distance3210123q1,13210123q1,20.00.51.01.52.02.53.03.54.0Distance3210123q1,13210123q1,20.01.63.24.86.48.09.611.212.8DistanceThe maximum distance results from the fact
that both
embodiments are normalized to be in a sphere of radius 1
or diameter 2, which is the maximum Euclidean distance
between two points in this sphere. Equation (22) ensures
that the sum of αtr and αrot is always 2, excluding the
transformation factor 2/π. The problem with the above
approaches is that there exist local minima in the distance
function, as can be observed in Fig. 3d and 3e for two-
link manipulators. Fig. 3f on the other hand, shows that
when considering the only the orientational between frames
(setting αtr = 0) using a static, precalculated correspondence
matrix, only one minimum remains . This approach is less
ﬂexible but more robust and resulted in parallel alignment
of corresponding links. Therefore, all following experiments
were conducted using this distance measure.

Pose Imitation Mapping Using a Neural Network. We
next
implemented a neural network to map joint angles
of the expert to corresponding joint angles of the learner,
leading to a more efﬁcient method for static pose imitation
than conducting a gradient descent search for each state. To
generate this nonlinear map, network parameters

θ∗ = arg min

θ

N
(cid:88)

i=1

d(s(qi), ˆs(fθ(qi))) ,

(23)

need to be determined, which minimize the distance between
the states of the expert and the states of the learner for a given
training set {q1, q2, . . . , qN }, where the map fθ(qi) is repre-
sented by a neural network and θ are the network parameters.
The training dataset {q1, q2, . . . , qN } can be generated ran-
domly because it contains only expert angles that do not need
to be labeled. The network structure consists of three hidden
layers of size 32 with LReLU activation functions. The
output layer uses the tanh as activation function, resulting in
output values in [−1, 1]. These values can then be mapped to
angular values in [−π, π]. Having generated a training dataset
and another dataset for validation, the network was trained
using a minibatch-based stochastic gradient descent method.
After dividing the training set into minibatches, the update
step is performed for each of the minibatches. Afterwards,
the whole training set is shufﬂed and the procedure repeated.
We trained a neural network to ﬁnd a mapping from joint
angles of a 7-DOF expert manipulator to angles of a 4-DOF
learner manipulator and another network for the same pair
of manipulators but with switched expert/learner roles. Each
time we used a training set of 1024 expert demonstrations,
dividing it into 32 minibatches in each episode. Fig. 4 shows
the learned poses of the trained network for given expert
angles that were not included in the training set.

Pose Imitation Between Three-Dimensional Embodiments.
We next applied the method from the previous section to two
Franka Emika Panda robotic arms in simulation. Dissimilar
embodiments were generated by locking individual DOFs of
the learner to qi = 0. For example, to simulate a four-link-
Panda robot with four DOFs, joint 3, 6, and 7 were locked.
To simulate a three-link-Panda robot, additionally link 2 was
locked (see Fig. 1). We ﬁrst studied static pose imitation

(a)

(c)

(b)

(d)

Fig. 4: Imitation between two planar manipulators using a
neural network. (a-b) Expert: 7-DOF, learner: 4-DOF; (c-d)
Expert: 4-DOF, learner: 7-DOF.

between identical embodiments with all full 7 DOFs enabled
(Video 1 1). Fig. 1a shows an example of how the trained
network solves the task between dissimilar embodiments
(expert: 7 DOFs, learner: 4 DOFs). The locked joints 6 and 7
(indicated in red) lie at the very end of the embodiment and
therefore do not contribute much to the overall conﬁguration
of the embodiment, in contrast to the locked joint 3 at the
center of the embodiment. In Fig. 1b, the learner only has
3 DOFs. The learner tries to establish similarity by rotating
joint 4 as the second joint is locked. The results can be seen
in Video 2 2.

The experiments have shown that training a neural network
with a distance-based loss function worked reasonably well
for static pose imitation. Local minima in the distance
function and over-ﬁtting on the training set posed some
problems. While the former is more difﬁcult to solve, the
latter can be solved by increasing the size of the training set
and stopping the training process at a suitable time. Another
possibility to improve the network’s performance may lie
in the structure and training of the network. We used the
same structure for all pose imitation tasks without employing
techniques that decrease the probability of over-ﬁtting, such
as dropout or regularization [36].

B. Dynamic Motion Imitation

In this section, we a apply a reinforcement

learning
algorithm for motion imitation by using the online distance
measure between embodiments as a feedback signal. Re-
inforcement learning has shown great success in learning
motor tasks, for example, [37], [38]. We study the transfer
of motions from one Panda robot with maximally seven
DOFs to another one in simulation. As before, different
embodiments are generated by locking DOFs in the learner.

1https://youtu.be/UPZclkFoFXQ
2https://youtu.be/BmFH6Nr9F1Y

Simulation Environment. The manufacturer

We assume that the dynamics of the robots are unavailable
the learner is controlled by joint
(model-free) and that
torques τ . Consequently, the agent needs to control the joint
positions but also, implicitly, learn the the robot dynamics.
(Franka
Emika) of the Panda robot provided a good integration of
the robot into the ROS ecosystem, which we augmented
by the Gazebo physics simulator. Unfortunately, no exact
inertia values for the Panda were provided, which were
needed to simulate the dynamics. The CoR-Lab group from
the Universitt Bielefeld published some estimates of inertia
values on their GitHub repository3. We used these estimates
and manually adjusted them by using the guide given in the
Gazebo manual. The simulated robot is controlled via joint
torque commands. To create trajectories of the expert, simple
PID-controllers were conﬁgured for each joint. Due to the
lack of sophisticated controllers and to facilitate the task for
the RL agent, gravity was turned off in the simulation.

RL Environment and Agent. The next task consisted in
the implementation of the reinforcement
learning agent
and the interface for interaction with the simulation. The
state space consisted of the expert and learner states, thus,
the environment’s state s is deﬁned by the tuple st =
{s(qt, ˙qt), ˆs( ˆqt, ˙ˆqt)}. The actions are given by the torque
commands of the learner, ˆat = ˆτt, subject to the torque limits
for each corresponding joint. The control of the expert is not
observable by the RL agent. For training and testing, multiple
random trajectories of similar duration were recorded. The
step size was set to ∆t = 0.1s and a step consisted of the
following transitions: The agent executed an action in the en-
vironment by sending a torque command to the learner. The
torques were then applied for the duration of the simulation
time ∆t. The simulation then paused and returned the next
observed state st+1 together with the reward rt+1, which was
calculated from the state as the negative distance measure
between the embodiment states. To train the agent, we used
Proximal Policy Optimization (PPO) [39], which is a state-
of-the art actor-critic DRL algorithm. One big advantage of
PPO is its robustness towards hyperparameter tuning. We
employed the GPU-optimized version (PPO2) of the Stable-
Baselines repository, based on OpenAI’s implementations.

Simulation 1: Imitation of a Single Trajectory. We ﬁrst
tested, whether motion imitation using reinforcement learn-
ing is feasible by transferring a single trajectory between
two Panda robots with all 7 DOFs activated, i.e., expert and
learner had identical embodiments. Both expert and learner
started in their zero pose, in which all joint angles and
joint velocities are set to zero. The trajectory of the expert
was recorded off-line by moving each joint to an arbitrarily
chosen goal position. The environment was reset whenever
the trajectory ended. Each trajectory had a total duration
of 5 s, which leads to 50 steps per episode. The discount
factor was set to γ = 0.4 implying that the agent acted
myopically. This value was chosen because high values led

Fig. 5: Generalization capabilities of two different agents.
Shown is the distance measure for two 7-DOF-Panda learners
while imitating the same, previously unseen trajectory. One
learner (”Specialized“) was trained on a single trajectory,
whereas the other (”Generalized“) was trained on 124 dif-
ferent trajectories.

to very slow training progress. The weights for the frame-
distance function were set to αtr = 0.0, αrot = 1.0, αv =
0.001, αω = 0.01 in all simulation experiments. Training
time was about 7.5 hours on a desktop computer using
GPU-accelerated computations. The simulation showed that
the learned trajectory resembles the expert’s trajectory very
closely and that imitation of motions is possible using a
reinforcement learning framework with a distance related
reward function. The results can be seen in Video 3 4.

Simulation 2: Generalization Between Trajectories. It was
examined next, whether the agent can imitate trajectories
it had not seen before. For this purpose, we trained the
agent with different numbers of training data (one vs. 124
trajectories). Trajectories were recorded as before, but each
time with different ﬁnal poses. The trajectory of the agent
trained on a single trajectory barely resembles the trajectory
of the expert. The imitation of the agent trained on the larger
data set is not perfect, but resembles the trajectories from the
expert more closely (see Video 4 5). This improvement shows
in a signiﬁcantly smaller distance between expert and learner
along the trajectory (see Fig. 5).

Simulation 3: Imitation Between Dissimilar Embodiments.
In the next experiment, we studied motion transfer between
dissimilar Panda robots. Towards this goal, we trained the
agent again on the same 124 trajectories but this time the
learner had only 4 or 3 DOFs, respectively. As the learning
robot was restricted in its DOFs, some trajectories could
could not be imitated well, resulting in higher values of the
distance measure. We found that the restricted learner moved
its links in similar directions as the expert but the restrictions
prevented a more similar imitation. Examples can be seen in
Video 5 6.

V. CONCLUSIONS

Our main contributions with this work are threefold: First,
we have introduced a deﬁnition of embodiment states in

3https://github.com/corlab/cogimon-gazebo-
models/blob/master/franka/robots/panda arm.xacro

4https://youtu.be/dLN314VJTHg
5https://youtu.be/2Q7jiY9DRUg
6https://youtu.be/Fytw8sz0pG0

05101520253035Steps0.000.050.100.150.200.250.300.35DistanceSpecializedGeneralizedterms of frames/twists and candidate points. Second, we have
povided a distance measure between dissimilar embodiments
using correspondences between frames of expert and learner.
Third, we have applied this distance measure to static pose
and movement imitation tasks between manipulators. All
tasks have been performed in simulation. In all experiments
we could show that the agent was able to learn the imitation
task, even though no dynamic model has been provided to
the learner. The framework that we have developed is generic
and ﬂexible and not limited to our choice of parameters,
distance measures and type of robots. Depending on the
correspondence matrix calculation, the topology of the em-
bodiments is not crucial. Possibly even free topologies like
swarms of ﬂying objects could be compared and brought into
similarity.

REFERENCES

[1] P. Abbeel, A. Coates, and A. Y. Ng, “Autonomous helicopter aero-
batics through apprenticeship learning,” The International Journal of
Robotics Research, vol. 29, no. 13, pp. 1608–1639, 2010.

[2] J. Kober and J. Peters, “Imitation and reinforcement learning,” IEEE
Robotics & Automation Magazine, vol. 17, no. 2, pp. 55–62, 2010.
[3] P. Kormushev, S. Calinon, and D. G. Caldwell, “Imitation learning of
positional and force skills demonstrated via kinesthetic teaching and
haptic input,” Advanced Robotics, vol. 25, no. 5, pp. 581–603, 2011.
[4] A. Boularias, J. Kober, and J. Peters, “Relative entropy inverse re-
inforcement learning,” in Proceedings of the Fourteenth International
Conference on Artiﬁcial Intelligence and Statistics, 2011, pp. 182–189.
[5] S. Calinon, F. D’halluin, E. L. Sauser, D. G. Caldwell, and A. G.
Billard, “Learning and reproduction of gestures by imitation,” IEEE
Robotics & Automation Magazine, vol. 17, no. 2, pp. 44–54, 2010.
[6] T. Asfour, P. Azad, F. Gyarfas, and R. Dillmann, “Imitation learning
of dual-arm manipulation tasks in humanoid robots,” International
Journal of Humanoid Robotics, vol. 5, no. 02, pp. 183–202, 2008.
[7] M. Lopes, F. S. Melo, and L. Montesano, “Affordance-based imitation
learning in robots,” in 2007 IEEE/RSJ International Conference on
Intelligent Robots and Systems.

IEEE, 2007, pp. 1015–1021.

[8] N. Ratliff, J. A. Bagnell, and S. S. Srinivasa, “Imitation learning for
locomotion and manipulation,” in 2007 7th IEEE-RAS International
Conference on Humanoid Robots.

IEEE, 2007, pp. 392–397.

[9] R. Chalodhorn, D. B. Grimes, K. Grochow, and R. P. Rao, “Learning to
walk by imitation in low-dimensional subspaces,” Advanced Robotics,
vol. 24, no. 1-2, pp. 207–232, 2010.

[10] T. Osa, J. Pajarinen, G. Neumann, J. A. Bagnell, P. Abbeel, J. Peters,
et al., “An algorithmic perspective on imitation learning,” Foundations
and Trends R(cid:13) in Robotics, vol. 7, no. 1-2, pp. 1–179, 2018.

[11] A. Billard, S. Calinon, and R. Dillmann, “Learning from humans,”

Springer Handbook of Robotics, pp. 1995–2014, 01 2016.

[12] P. Englert, A. Paraschos, M. P. Deisenroth, and J. Peters, “Probabilistic
model-based imitation learning,” Adaptive Behavior, vol. 21, no. 5, pp.
388–403, 2013.

[13] S. Ross, G. Gordon, and D. Bagnell, “A reduction of imitation learning
and structured prediction to no-regret online learning,” in Proceedings
of the fourteenth international conference on artiﬁcial intelligence and
statistics, 2011, pp. 627–635.

[14] S. Ross, N. Melik-Barkhudarov, K. S. Shankar, A. Wendel, D. Dey,
J. A. Bagnell, and M. Hebert, “Learning monocular reactive uav
control in cluttered natural environments,” 2013 IEEE International
Conference on Robotics and Automation, 2013.

[15] A. J. Ijspeert, J. Nakanishi, and S. Schaal, “Movement imitation with
nonlinear dynamical systems in humanoid robots,” in Proceedings
2002 IEEE International Conference on Robotics and Automation
(Cat. No. 02CH37292), vol. 2.

IEEE, 2002, pp. 1398–1403.

[16] G. Maeda, M. Ewerton, G. Neumann, R. Lioutikov, and J. Peters,
“Phase estimation for fast action recognition and trajectory generation
in human–robot collaboration,” The International Journal of Robotics
Research, vol. 36, no. 13-14, pp. 1579–1594, 2017.

[17] T. Osa, K. Harada, N. Sugita, and M. Mitsuishi, “Trajectory planning
under different
task automation by
initial conditions for surgical
learning from demonstration,” in 2014 IEEE International Conference
on Robotics and Automation (ICRA).

IEEE, 2014, pp. 6507–6513.

[18] X. B. Peng, P. Abbeel, S. Levine, and M. van de Panne, “Deepmimic:
Example-guided deep reinforcement learning of physics-based char-
acter skills,” ACM Transactions on Graphics (TOG), vol. 37, no. 4,
pp. 1–14, 2018.

[19] P. Abbeel and A. Y. Ng, “Apprenticeship learning via inverse rein-
forcement learning,” in Proceedings of the twenty-ﬁrst international
conference on Machine learning, 2004.

[20] N. D. Ratliff, J. A. Bagnell, and M. A. Zinkevich, “Maximum margin
planning,” in Proceedings of the 23rd international conference on
Machine learning, 2006, pp. 729–736.

[21] D. Silver, J. Bagnell, and A. Stentz, “Learning from demonstration for
autonomous navigation in complex unstructured terrain,” I. J. Robotic
Res., vol. 29, pp. 1565–1592, 10 2010.

[22] B. Ziebart, A. Maas, J. Bagnell, and A. Dey, “Maximum entropy
inverse reinforcement learning.” AAAI Press, 2008, pp. 1433–1438.
[23] C. Finn, S. Levine, and P. Abbeel, “Guided cost learning: Deep inverse
optimal control via policy optimization,” Proceedings of the 33Rd
International Conference on Machine Learning, 03 2016.

[24] J. Ho, J. Gupta, and S. Ermon, “Model-free imitation learning with
policy optimization,” in International Conference on Machine Learn-
ing, 2016, pp. 2760–2769.

[25] C. L. Nehaniv and K. Dautenhahn, “Like me?- Measures of correspon-
dence and imitation,” Cybernetics and Systems, vol. 32, pp. 11–51,
2001.

[26] A. Alissandrakis, C. Nehaniv, and K. Dautenhahn, “Imitating with
alice: Learning to imitate corresponding actions across dissimilar
embodiments,” IEEE Transactions on Systems, Man, & Cybernetics,
Part A: Systems and Humans, vol. 32, pp. 482–496, 07 2002.
[27] A. Alissandrakis, C. L. Nehaniv, and K. Dautenhahn, “Do as I do:
Correspondences across different robotic embodiments,” in Procs. 5th
German Workshop on Artiﬁcial Life. Lubeck, 2002.

[28] A. Alissandrakis, C. L. Nehaniv, K. Dautenhahn, and J. Saunders,
“Achieving corresponding effects on multiple robotic platforms: Im-
itating in context using different effect metrics,” in In: Proceedings
of the Third International Symposium on Imitation in Animals and
Artifacts. AISB, 2005.

[29] A. Alissandrakis, C. L. Nehaniv, and K. Dautenhahn, “Correspondence
mapping induced state and action metrics for robotic imitation,” IEEE
Transactions on Systems, Man, and Cybernetics, Part B (Cybernetics),
vol. 37, pp. 299–307, 2007.

[30] C. L. Nehaniv and K. E. Dautenhahn, Imitation and social learning in
robots, humans and animals: behavioural, social and communicative
dimensions. Cambridge University Press, 2007.

[31] D. B. Grimes, R. Chalodhorn, and R. P. Rao, “Dynamic imitation in
a humanoid robot through nonparametric probabilistic inference.” in
Robotics: science and systems. Citeseer, 2006, pp. 199–206.
[32] D. B. Grimes and R. P. Rao, “Learning actions through imitation and
exploration: Towards humanoid robots that learn from humans,” in
Creating Brain-Like Intelligence. Springer, 2009, pp. 103–138.
[33] F. Park, J. Bobrow, and S. Ploen, “A lie group formulation of robot
dynamics,” The International Journal of Robotics Research, vol. 14,
no. 6, pp. 609–618, 1995.

[34] K. M. Lynch and F. C. Park, Modern Robotics. Cambridge University

Press, 2017.

[35] M. Abadi, P. Barham, J. Chen, Z. Chen, A. Davis, J. Dean, M. Devin,
S. Ghemawat, G. Irving, M. Isard, M. Kudlur, J. Levenberg, R. Monga,
S. Moore, D. G. Murray, B. Steiner, P. Tucker, V. Vasudevan,
P. Warden, M. Wicke, Y. Yu, and X. Zheng, “Tensorﬂow: a system
for large-scale machine learning,” in 12th USENIX Symposium on
Operating Systems Design and Implementation (OSDI 16). USENIX
Association, 2016, pp. 265–283.

[36] C. C. Aggarwal, Neural networks and deep learning. Springer, 2018,

vol. 10.

[37] N. Heess, D. TB, S. Sriram, J. Lemmon, J. Merel, G. Wayne, Y. Tassa,
T. Erez, Z. Wang, S. Eslami, et al., “Emergence of locomotion
behaviours in rich environments,” arXiv preprint arXiv:1707.02286,
2017.

[38] O. M. Andrychowicz, B. Baker, M. Chociej, R. Jozefowicz, B. Mc-
Grew, J. Pachocki, A. Petron, M. Plappert, G. Powell, A. Ray, et al.,
“Learning dexterous in-hand manipulation,” The International Journal
of Robotics Research, vol. 39, no. 1, pp. 3–20, 2020.

[39] J. Schulman, F. Wolski, P. Dhariwal, A. Radford, and O. Klimov,
preprint

optimization

algorithms,”

arXiv

“Proximal
arXiv:1707.06347, 2017.

policy

