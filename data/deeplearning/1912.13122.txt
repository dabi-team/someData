0
2
0
2

l
u
J

4
2

]
I

A
.
s
c
[

3
v
2
2
1
3
1
.
2
1
9
1
:
v
i
X
r
a

Declarative Mechanism Design
A testbed for Regulated Deep Learning

Andr´es Garc´ıa-Camino
agarcia-camino@acm.org

Independent Researcher,
Campus UAB s/n, 08913 Barcelona, Spain

Abstract. Regulation of Multi-Agent Systems (MAS) and Declarative
Electronic Institutions (DEIs) was a multidisciplinary research topic of
the past decade involving (Physical and Software) Agents and Law since
the beginning, but recently evolved towards News-claimed Robot Lawyer
since 2016. One of these ﬁrst proposals of restricting the behaviour of
Software Agents was Electronic Institutions.
However, with the recent reformulation of Artiﬁcial Neural Networks
(ANNs) as Deep Learning (DL) [1], Security, Privacy, Ethical and Legal
issues regarding the use of DL has raised concerns in the Artiﬁcial In-
telligence (AI) Community. Now that the Regulation of MAS is almost
correctly addressed, we propose the Regulation of Artiﬁcial Neural Net-
works as Agent-based Training of a special type of regulated Artiﬁcial
Neural Network that we call Institutional Neural Network (INN).
The main purpose of this paper is to bring attention to Artiﬁcial Teaching
(AT) and to give a tentative answer showing a proof-of-concept imple-
mentation of Regulated Deep Learning (RDL). This paper introduces
the former concept and provides I, a language previously used to model
declaratively and extend Electronic Institutions, as a means to regulate
the execution of Artiﬁcial Neural Networks and their interactions with
Artiﬁcial Teachers (ATs).

1 Motivation

Regulation of Multi-Agent Systems (MAS) and Declarative Electronic Institu-
tions (DEIs) [2][3][4] was a multidisciplinary research topic of the past decade
involving (Physical and Software) Agents and Law since the beginning, but re-
cently evolved towards News-claimed Robot Lawyer since 2016. One of these
ﬁrst proposals of restricting the behaviour of Software Agents was Electronic
Institutions [5] [6] [7].

However, with the recent reformulation of Artiﬁcial Neural Networks (ANNs)
as Deep Learning (DL) [1], Security, Privacy, Ethical and Legal issues regarding
the use of DL has raised concerns in the Artiﬁcial Intelligence (AI) Community
[8].

Now that the Regulation of MAS is almost correctly addressed, we propose
the Regulation of Artiﬁcial Neural Networks as Agent-based Training of a special

 
 
 
 
 
 
type of regulated Artiﬁcial Neural Network that we call Institutional Neural
Network (INN).

The main purpose of this paper is to bring attention to Artiﬁcial Teaching
(AT) and to give a tentative answer showing a proof-of-concept implementation
of Regulated Deep Learning (RDL).

This paper introduces the former concept and provides I [3], a language
previously used to model and extend Electronic Institutions[7], as a means to
regulate the execution of Artiﬁcial Neural Networks and their interactions with
Artiﬁcial Teachers (ATs).

The structure of this position article is as follows, in section 2 the need of
Agent-based Training for DL (ABT4DL) is introduced. In Section 3 the fore-
mentioned language is introduced and, Section 3.1 presents some preliminary
deﬁnitions for this work. The normative language that includes the tentative
answer is presented in section 4. Section 5 presents the Semantics of the language
and section 6 its Operational Semantics. Some examples of Artiﬁcial Neural
Network modeling are presented in section 7. And ﬁnally, sections 9 and 10
presents some conclusions and possible future work to continue this research,
respectively.

2 Agent-based Training for Deep Learning

Current ANNs, and subsequently Deep Learning, proposals are Data-driven:
they model an a priori unknown function by processing large amounts of data
[1] without automatically controlling the source of this data, neither how one
could certify the proper use of the data.

We introduce Agent-based Training for Deep Learning (ABT4DL) as a new
paradigm for Automated training of Artiﬁcial Neural Networks. However, we
envisage that such training should be regulated and mediated, thus, as we pro-
pose agents as artiﬁcial data providers with an intuitive role of Artiﬁcial Teacher
(AT), using a Regulated MAS as follows in order to regulate and mediate the
behaviour of these Artiﬁcial Teachers interacting with Artiﬁcial Neural Networks
residing in the state-of-aﬀairs of a Declarative Electronic Institution [4].

3

Introducing a Regulation Language

The proposed language in this work is based in Event-Condition-Action (ECA)
rules, that perform the speciﬁed institutional actions when the given agent events
occur and when the prespeciﬁed conditions hold. The performance of actions add
or remove atomic formulae thus triggering another type of rule: the if-rules, that
are standard production rules as usually found in Expert Sytems [9]. Above
these two types of rules a new types of rules are placed: ignore-rules, that ignore
a set of simultaneous events, force-rules, that generate a set of events on the
occurrence of a given set of events satisfying certain conditions, and prevent-
rules, that ignore the execution of ECA or if-then rules if certain formulae hold

in the current state and another given set of formulae hold in the calculation of
the next state.

3.1 Preliminary Deﬁnitions

Some basic concepts are now introduced. The building blocks of the language
are terms:

Def. 1. A term, denoted as τ , is

– Any variable x, y, z (with or without subscripts) or
– Any construct f n(τ1, . . . , τn), where f n is an n-ary function symbol and

τ1, . . . , τn are terms.

Terms f 0 stand for constants and will be denoted as a, b, c (with or without sub-
scripts). Numbers and arithmetic functions to build terms are used ; arithmetic
functions may appear inﬁx, following their usual conventions. Prolog’s conven-
tion [10] is used using strings starting with a capital letter to represent variables
and strings starting with a small letter to represent constants. Some examples
of terms are Price (a variable) and send (a, B, P rice × 1.2) (a function). The
deﬁnition of atomic formulae is as follows:
Def. 2. An atomic formula, denoted as α, is any construct pn(τ1, . . . , τn), where
pn is an n-ary predicate symbol and τ1, . . . , τn are terms.
When the context makes it clear what n is, it is dropped. p0 stands for propo-
sitions. Arithmetic relations (e.g., =, 6=, and so on) are employed as predicate
symbols, and these will appear in their usual inﬁx notation. Atomic formulae
built with arithmetic relations to represent constraints on variables are used
– these atomic formulae have a special status, as it is explained below. The
deﬁnition of constraints in this work, a subset of atomic formulae is:
Def. 3. A constraint γ is a binary atomic formula τ ⊳ τ, where ⊳ ∈ {=, 6=, >
, ≥, <, ≤}.

Γ = {γ1, . . . , γn} is used as a set of constraints. A state of aﬀairs is a set
of atomic formulae, representing (as shown below) the normative positions of
agents, observable agent attributes and the state of the environment1.

Def. 4. A state of aﬀairs ∆ = {α0 : Γ0, . . . , αn : Γn} is a a ﬁnite and possibly
empty set of implicitly, universally quantiﬁed atomic formulae αi restricted by a
possibly empty set of constraints Γi, 0 ≤ i ≤ n. When the set of constraints is
empty, it is written just αi.

4 I: A Language for Institutional Neural Networks

This section introduces a rule language for the regulation and management of
concurrent events generated by a population of agents.

1 It is referred to the state of the environment as the subset of atomic formulae rep-

resenting observable aspects of the environment in a given point in time.

∆0 ⇛

∆0

Ξ 0
1 , · · · , Ξ 0
n
l
ag 1 · · · ag n

l

∗  ∆1 ⇛

∆1

Ξ 1
1 , · · · , Ξ 1
m
l
ag 1 · · · ag m

l

∗  · · ·

Fig. 1. Semantics as a Sequence of ∆’s

Figure 1 depicts the computational model used: n initial state of aﬀairs ∆0
(possibly empty) is oﬀered (represented by “⇛”) to a set of agents (ag1, · · · , agn).
These agents can add their speech acts (Ξ 0
n) to the state of aﬀairs (via
“l”). Ξ t
i is the (possibly empty) set of speech acts added by agent i at state
of aﬀairs ∆t. After an established amount of time, an exhaustive application of
∗
 ”) to the modiﬁed state, yielding a new state
rules is performed(denoted by “
of aﬀairs ∆1. This new state will, in its turn, be oﬀered to the agents for them
to add their utterances, and the same process will go on.

1 , · · · , Ξ 0

One goal of the I language is to specify the eﬀects of concurrent events and
this is achieved with Event-Condition-Action (ECA) rules. Intuitively, an ECA-
rule means that whenever the events occur and the conditions hold then the
actions are applied. These actions consist of the addition and removal of atomic
formulae from the state of aﬀairs. ECA-rules are checked in parallel and they
are executed only once without chaining.

If-rules are similar to rules in standard production systems, if the conditions
hold then the actions are applied. They are implemented with a forward chaining
mechanism: they are executed sequentially until no new formula is added or
removed.

Ignore-rules are used for ignoring events when the conditions hold in order to
avoid unwanted behaviour. Similarly, prevent-rules are used for preventing some
conditions to hold in the given situations. In order to prevent unwanted states,
events causing such unwanted states are ignored. Force-rules generate events and
execute actions as consequence of other events and conditions.

Sanctions over unwanted events can be carried out with ECA-rules. For in-
stance, they can decrease the credit of one agent by 10 if she generates a certain
event.

Figure 7 shows the grammar for I, i.e. the syntax of the ﬁve type of rules

proposed: ECA-rules, if-rules, ignore-rules, prevent-rules and force-rules.

ECA-Rule ::= on set of events if conditions do actions

if -Rule ::= if conditions do actions

ignore-Rule ::= ignore set of events if conditions
prevent-Rule ::= prevent conditions if conditions

f orce-Rule ::= force set of events on set of events

set of events ::= events | ∅

if conditions do actions

events ::= atomic f ormula, events | atomic f ormula
conditions ::= conditions & conditions | not(conditions)
| sat(set of constraints) | constr f ormula
| seteq(set of constraints, set of constraints)
| constraint ∈ set of constraints
| time(number) | true

constr f ormula ::= atomic f ormulae

| atomic f ormulae : set of constraints

actions ::= action,actions | action
action ::= add(constr f ormula) | del(constr f ormula)

Fig. 2. Grammar for I

ECA rules specify the eﬀect of a set of events, i.e. a set of atomic formulae,
if the conditions hold. This eﬀect is speciﬁed by means of a sequence of actions
namely addition and removal of constrained formulae. A constrained formulae
is an atomic formula that may be followed by a set of arithmetical constraints
using the syntax presented in Def. 3. Furthermore, by conditions is meant one
or more possibly negated conditions. Then, a condition may be a constrained
formula, the sat predicate that checks that a set of constraints is satisﬁable, the
seteq predicate that checks if two sets are equal, the time predicate that checks
current time or the true constant that always hold.

If-rules specify the logical consequence if the conditions hold by means of a
sequence of actions. Ignore-rules specify the set of events that should be ignored
if the conditions hold. Similarly, prevent-rules specify the conditions that should
not hold if some conditions hold. Finally, force-rules specify a set of new events
that are generated on the occurrence of a set of events and the satisfaction of
a sequence of conditions. Furthermore, it also speciﬁes a sequence of actions to
perform if the rule is triggered.

An extra kind of rule, called expectation-rules, and shown in Fig. 3, that
generate and remove expectations of events might be added. If the expectation
fails to be fulﬁlled then some sanctioning or corrective actions are performed.

However, each expectation rule are equivalent to the following rules:

In Fig. 4, Rule 1 and 2 respectively adds and removes an expectation when-
ever the events have occurred and the conditions hold. Rule 3 cancels the un-
fulﬁlled expectation and sanctions an agent for the unfulﬁlled expectation by
executing the given actions whenever some conditions hold.

expectation-Rule ::= expected event on set of events if conditions
′′

′

violated-if conditions

fulﬁlled-if conditions
sanction-do actions

Fig. 3. Expectation Rule

on set of events if conditions do add(exp(event))
do del(exp(event))
do del(exp(event)),actions

if exp(event) ∧ conditions

if exp(event) ∧ conditions

′′

′

(1)

(2)

(3)

Fig. 4. Expectation rule semantics expressed with 3 rules

5 Semantics

Instead of basing the I language on the standard deontic notions, two types of
prohibitions and two types of obligations are included. In the language, ECA-
rules determine what is possible to perform, i.e. they establish the eﬀects (includ-
ing sanctions) in the institution after performing certain (possibly concurrent)
events. ECA-rules can be seen as conditional count-as rules: the given events
count as the execution of the actions in the ECA-rule if the conditions hold and
the event is not explicitly prohibited. As for the notion of permission, all the
events are permitted if not explicitly prohibited. The notion of an event being
prohibited may be expressed depending on whether that event has to be ignored
or not. If not otherwise expressed, events are not ignored. Likewise, the notion
of a state being prohibited may be speciﬁed depending on whether that state
has to be prevented or not. By default, states are not prevented. Obligations
are diﬀerentiated in two types: expectations, which an agent may not fulﬁll, and
forced (or obligatory) events, which the system takes as institutional events even
they are not actually performed by the agents.

Each set of ECA-rules generates a labelled transition system hS, E, Ri where
S is a set of states, each state in S is a set of atomic formulae, E is a set of events,
and R is a S × 2E × S relationship indicating that whenever a set of events occur
in the former state, then there is a transition to the subsequent state.

Ignore-rules avoid executing any transition that contains in its labelling the
events that appear in any ignore-rule. For instance, having a rule ignore α1
if true would avoid executing the transitions labelled as {α1}, {α1, α2} and
{α1, α2, α3}. However, having a rule ignore α1, α2 if true would avoid executing
{α1, α2} and {α1, α2, α3} but not {α1}.

Prevent-rules ignore all the actions in an ECA-rule if it brings the given

formulae about. For example, suppose that we have

prevent q1 if true

along with ECA-rules 4, 5 and 6 below. After the occurrence of events α1 and
α2 and since q1 is an eﬀect of event α2, all the actions in ECA-rule 5 would be
ignored obtaining a new state where p and r hold but neither q1 nor q2.

on α1 if true do add(p)
on α2 if true do add(q1),add(q2)
on α1, α2 if true do add(r)

(4)
(5)

(6)

Force-rules generate events during the execution of the transition system.
However, the eﬀects of such events are still speciﬁed by ECA-rules and subject
to prevent and ignore-rules.

6 Operational Semantics

As shown in ﬁgure 1, the semantics of rules are presented as a relationship
between states of aﬀairs: rules map an existing state of aﬀairs to a new state of
aﬀairs. This section deﬁnes this relationship. The deﬁnitions below rely on the
concept of substitution, that is, the set of values for variables in a computation
[10, 11]:

Def. 5. A substitution σ = {x0/τ0, . . . , xn/τn} is a ﬁnite and possibly empty set
of pairs xi/τi, 0 ≤ i ≤ n.

Def. 6. The application of a substitution to an atomic formulae α possibly re-
stricted by a set of constraints {γ0, . . . , γm} is as follows:

1. c · σ = c for a constant c;
2. x · σ = τ · σ if x/τ ∈ σ; otherwise x · σ = x;
3. pn(τ0, . . . , τn) · σ = pn(τ0 · σ, . . . , τn · σ);
4. pn(τ0, . . . , τn) : {γ0, . . . , γm} · σ = pn(τ0 · σ, . . . , τn · σ) : {γ0 · σ, . . . , γm · σ}.

Def. 7. The application of a substitution to a sequence is the sequence of the
application of the substitution to each element: hα1, . . . , αni·σ = hα1·σ, . . . , αn·σi

The semantics of the conditions are now deﬁned, that is, when a condition

holds:

Def. 8. Relation sl(∆, C, σ) holds between state ∆, a condition C in an if clause
and a substitution σ depending on the format of the condition:
1. sl(∆, C & C′, σ) holds iﬀ sl(∆, C, σ′) and sl(∆, C′ · σ′, σ′′) hold and σ =

σ′ ∪ σ′′.

2. sl(∆, not(C), σ) holds iﬀ sl(∆, C, σ) does not hold.
3. sl(∆, seteq(L, L2), σ) holds iﬀ L ⊆ L2, L2 ⊆ L and |L| = |L2|.
4. sl(∆, sat(constraints), σ) holds iﬀ
satisﬁable(constraints · σ) hold.

5. sl(∆, γ ∈ Γ, σ) holds iﬀ (γ · σ) ∈ (Γ · σ).
6. sl(∆, time(T ), σ) holds iﬀ current time is T .
7. sl(∆, true, σ) always holds.
8. sl(∆, constr f ormula, σ) holds iﬀ

constr f ormula · σ ∈ ∆.

Case 1 depicts the semantics of atomic formulae and how their individual
substitutions are combined to provide the semantics for a conjunction. Case
2 introduces negation by failure. Case 3 compares if two lists have the same
elements possibly in diﬀerent order. Case 4 checks if a set of constraints is satis-
ﬁable. Case 5 checks if a constraint belongs to a set of constraints. Case 6 checks
if T is current time. Case 7 gives semantics to the keyword true. Case 8 holds
when an possibly constrained, atomic formulae constr f ormula is part of the
state of aﬀairs.

The semantics of the actions of a rule are now deﬁned:

Def. 9. Relation sr(∆, A, ∆′) mapping a state ∆, the action section of a rule
and a new state ∆′ is deﬁned as:
1. sr(∆, (A,As), ∆′) holds iﬀ both sr(∆, A, ∆1) and sr(∆1, As, ∆′) hold.
2. sr(∆, add(constr f ormula), ∆′) holds iﬀ

(a) constr f ormula 6∈ ∆ and ∆′ = ∆ ∪ {constr f ormula} or;
(b) ∆′ = ∆.

3. sr(∆, del(constr f ormula), ∆′) holds iﬀ

(a) constr f ormula ∈ ∆ and ∆′ = ∆ \ {constr f ormula} or;
(b) ∆′ = ∆.

Case 1 decomposes a conjunction and builds the new state by merging the partial
states of each update. Case 2 and 3 cater respectively for the insertion and
removal of atomic formulae α.

Relation checkprv checks if there is no prevent-rule that has been violated,
i.e., it is not the case that all the conditions of any prevent-rule hold in the state
of aﬀairs ∆′. It checks whether ∆′ contain all the conditions of each prevent-rule
or not, if ∆ also contain the given conditions.
Def. 10. Relation checkprv(∆, ∆′, P rvRules) mapping ∆, the state before ap-
plying updates, ∆′, the state after applying updates, and a sequence P rvRules of
prevent-rules, holds iﬀ an empty set is the largest set of conditions C such that:
p = prevent C if C′, p ∈ P rvRules,
and sl(∆, C′), sl(∆′, C) hold

Def. 11. f ire(∆, P rvRules, if C do A, ∆′), relation mapping a state ∆, a
sequence P rvRules of prevent-rules, an if-rule and a new state ∆′ holds iﬀ
f ired(C, A) starts to hold, sr(∆, A, ∆′) and
checkprv(∆, ∆′, P rvRules) hold.

Relation can f ire checks whether the conditions of a given if-rule hold and

the rule after applying substitution σ has not been already ﬁred.

Def. 12. Relation can f ire(∆, if C do A, σ) mapping a state ∆ an if-rule and
a substitution σ holds iﬀ sl(∆, C, σ) holds and f ired(C · σ, A · σ) does not hold.

Relation resolve determines the rule that will be ﬁred by selecting the ﬁrst

rule in the list.

Def. 13. resolve(RuleList, SelectedRuleList), relation mapping a list of if-
rules and a selected if-rule list holds iﬀ

1. RuleList = hi and SelectedRuleList = hi; or
2. RuleList = hr1, · · · , rni and SelectedRuleList = hr1i.

Relation select rule determines the rule that will be ﬁred by selecting all the

rules that can ﬁre and resolving the conﬂict with relation resolve.

Def. 14. Relation select rule(∆, If RulesList,
SelectedRuleList) mapping a state of aﬀairs ∆, a list of if-rules and a selected
if-rule list holds iﬀ Rs is the largest set of rules R ∈ Rs, Rs ⊆ If RulesList such
that can f ire(∆, R, σ); resolve(Rs, SR) hold and SelectedRuleList = SR · σ.

Relation sif determines the new state of aﬀairs after applying a set of if-rules

to a initial state of aﬀairs taking into account a set of prevent-rules.

Def. 15. sif (∆, If Rules, P rvRules, ∆′), relation mapping a state of aﬀairs ∆,
a list of if-rules, a list of prevent-rules and a new state of aﬀairs holds iﬀ

1. select rule(∆, If Rules, R) hold, R 6= hi,

f ire(∆, P rvRules, R, ∆′′) and
sif (∆′′, If Rules, P rvRules, ∆′) hold; or
2. select rule(∆, If Rules, R) hold, R = hi; or
3. sif (∆, If Rules, P rvRules, ∆′) hold.

Relation ignored determines that a set of events which occurred have to be

ignored taking into account a list of ignore-rules.

Def. 16. Relation ignored(∆, Ξ, E, IgnRules) mapping a state of aﬀairs ∆, a
list Ξ of events that occurred, a list of events in a ECA-rule and a list of ignore-
rules holds iﬀ i = ignore E′ if C, i ∈ IgnRules, E′ ⊆ Ξ, E ∩ E′
6= ∅ and
sl(∆, C) holds.

Relation s′

r uses sr ﬁrst and then sif in order to activate the forward chaining.

r(∆, If Rules, P rvRules,

Def. 17. Relation s′
ActionList, ∆′) mapping a state of aﬀairs ∆, a list of if-rules, a list of prevent-
rules, a list of actions and a new state of aﬀairs holds iﬀ any of the conditions
below hold:

1. ActionList = hi and ∆′ = ∆; or
2. ActionList = ha1, · · · , ani, sr(∆, a1, ∆′′),

checkprv(∆, ∆′′, P rvRules),
sif (∆′′, If Rules, P rvRules, ∆′′′) and
s′
r(∆′′′, If Rules, P rvRules, ha2, · · · , ani, ∆′)
hold; or
r(∆, If Rules, P rvRules, ha2, · · · , ani, ∆′).

3. s′

Relation seca calculates the new state of aﬀairs ∆′ from an initial state ∆ and
a set Ξ of events that occurred applying a list of ECA-rules, if-rules, ignore-rules
and prevent-rules.

Def. 18. Relation seca(∆, Ξ, ECARules,
If Rules, IgnRules, P rvRules, ∆′) mapping a state of aﬀairs ∆, a list Ξ of
events that occurred, a list of ECA-rules, a list of if-rules, a list of ignore-rules,
a list of prevent-rules, and a new state of aﬀairs holds iﬀ:

– As is the largest set of actions A′ = A · σ in an ECA-rule r = on E if C

do A such that:
• r ∈ ECARules, E · σ′ ⊆ Ξ, sl(∆, C, σ′′) hold,
• ignored(∆, Ξ, E, IgnRules) does not hold and
• σ = σ′ ∪ σ′′; and
r(∆, If Rules, P rvRules, As, ∆′) hold.

– s′

Relation sf orce calculates the new state of aﬀairs ∆′ and the new set Ξ ′
of occurred events from an initial state ∆ and a set Ξ of events that occurred
applying a list of if-rules, ignore-rules, prevent-rules and force-rules.

Def. 19. Relation sf orce(∆, Ξ, If Rules,
IgnRules, P rvRules, F rcRules, Ξ ′, ∆′) mapping a state of aﬀairs ∆, a list Ξ
of events that occurred, a list of if-rules, a list of ignore-rules, a list of prevent-
rules, a list of force-rules, a new list of events that occured and a new state of
aﬀairs holds iﬀ:

– EAs is the largest set of tuples hF E · σ, A · σi of forced events and actions

in a force rule f r = force F E on E if C do A such that

• f r ∈ F rcRules, E · σ′ ⊆ Ξ, sl(∆, C, σ′′) holds,
• ignored(∆, Ξ, E, IgnRules) does not hold and
• σ = σ′ ∪ σ′′;

– Es is the largest set of forced events Ev such that hEv, Ai ∈ EAs;
– Ξ ′ = Ξ ∪ Es;
– As is the largest set of actions A such that hEv, Ai ∈ EAs; and
– s′

r(∆, If Rules, P rvRules, As, ∆′) holds.

Relation s∗ calculates the new state of aﬀairs ∆′ from an initial state ∆ and a
set Ξ of events that occurred applying a list of ECA-rules, if-rules, ignore-rules,
prevent-rules and force-rules.

Def. 20. Relation

s∗

′
)
(∆, Ξ, ECARls, If Rls, IgnRls, P rvRls, F rcRls, ∆

mapping a state of aﬀairs ∆, a list Ξ of events that occurred, a list of ECA-rules,
a list of if-rules, a list of ignore-rules, a list of prevent-rules, a list of force-rules
and a new state of aﬀairs holds iﬀ:

– Cs is the largest set of conditions C such that f ired(C, A) stop holding;
– f ired(f alse, f alse) starts to hold,
– sif (∆, If Rls, P rvRls, ∆′′),
– sf orce(∆′′, Ξ, If Rls, IgnRls, P rvRls, F rcRls, Ξ ′,

∆′′′) and

– seca(∆′′′, Ξ ′, ECARls, If Rls, IgnRls, P rvRls, ∆′)

hold.

7 Modelling Neural Networks with rules

In this section we introduce how to use I rule-language for modelling Artiﬁcial
Neural Networks. We start with the more simpler unit of processing in Artiﬁcial
Neural Networks, i.e. Perceptrons.

We will rely on two special type of events, inputs speciﬁed as i(xi, lj), with
the intuitive meaning that an agent provided xi as the input for layer lj; and
outputs speciﬁed as o(xi, lj) with the intuitive meaning that xi is an output for
lj.

7.1 Modelling Multi-layer Perceptrons as rules

We begin this section presenting an example on how to use the I language in
order to specify a Perceptron:

on i(X1, 1), · · · i(Xn, 1)
if
do add(o(Y, 1))

prolog(calculate(X1, · · · , Xn, Y ))

(7)

Fig. 5. Example of one layer

In Fig. 5, Rule 7 translates a set of n inputs, provided by Agents, to one
output by means of a calculation implemented in prolog by a calculate predicate.
For specifying multiple layers of Perceptrons, we envisage several rules (Per-

ceptrons) forward chaining in several activations:

For space restrictions, we model a basic two-layer Multi-layer Perceptron
(MLP) where i Perceptrons are deﬁned by rules from 8–10 in Fig. 6. The last

on i(X1, 1), · · · i(Xn, 1)
if
do add(o(Y1, 1))

prolog(calculate(X1, · · · , Xn, Y1))

· · ·

on i(Xj , 1), · · · i(Xk, 1)
if
do add(o(Yi, 1))

prolog(calculate(Xj , · · · , Xk, Yi))

o(X1, 1) & · · · & o(Xi, 1)
prolog(calculate(X1, · · · , Xi, Yi+1))

if
&
do add(o(Yi+1, 2))

Fig. 6. Example of second layer

(8)

(9)

(10)

(11)

rule gathers the outputs from the previous layer and calculates the ﬁnal output
(of layer 2).

This basic example illustrates expressiveness of I modelling Artiﬁcial Neural
Networks. For further uses and examples on regulation with I, we refer the
reader to [4]

8 I ∗: Online rule-management extension

Continuing the work from [4], an extension that easily could pop up when anal-
ysis the language and the problems one might want to solve is the online rule-
managemnt, i.e. the possibility of adding and removing rules on runtime. Thus,
agents by means of events, and if they are accepted as valid actions, could trigger
the institutional rule actions declared previously.

As for the implementation of the extension, rules are deﬁned as dynamic
Prolog clauses, as with the fired/1 clause declared as dynamic after the initial
comments of the code in the Appendix.

We now redeﬁne the actions of adding and deleting open units, i.e. con-

strained formulae or rules:

Def. 21. Relation sr(∆, A, ∆′) mapping a state ∆, the action section of a rule
and a new state ∆′ is deﬁned as:

1. sr(∆, (A,As), ∆′) holds iﬀ both sr(∆, A, ∆1) and sr(∆1, As, ∆′) hold.
2. sr(∆, add(constr f ormula), ∆′) holds iﬀ

(a) constr f ormula 6∈ ∆ and ∆′ = ∆ ∪ {constr f ormula} or;
(b) ∆′ = ∆.

3. sr(∆, add(rule), ∆′) holds iﬀ

(a) rule does not hold and assert(rule)
(b) ∆′ = ∆.

4. sr(∆, del(constr f ormula), ∆′) holds iﬀ

(a) constr f ormula ∈ ∆ and ∆′ = ∆ \ {constr f ormula} or;
(b) ∆′ = ∆.

5. sr(∆, del(rule), ∆′) holds iﬀ

(a) rule holds and retract(rule)
(b) ∆′ = ∆.

Case 1 decomposes a conjunction and builds the new state by merging the partial
states of each update. Case 2 and 4 cater respectively for the insertion and
removal of atomic formulae α. Finally, Case 3 and 5 formalises respectively the
insertion and removal of rule rule, following Sictus Prolog capability to add and
remove Horn clauses in runtime.

Rules ::= rule ′

′atomic f ormula, [ECA-Rule | if -Rule |

(

)
ECA-Rule ::= on set of events if conditions do actions

′
ignore-Rule | prevent-Rule | f orce-Rule]

′+

if -Rule ::= if conditions do actions

ignore-Rule ::= ignore set of events if conditions

prevent-Rule ::= prevent conditions if conditions

f orce-Rule ::= force set of events on set of events

if conditions do actions

set of events ::= events | ∅

events ::= atomic f ormula, events | atomic f ormula
conditions ::= conditions & conditions | not(conditions)
| sat(set of constraints) | constr f ormula
| seteq(set of constraints, set of constraints)
| constraint ∈ set of constraints
| time(number) | true

constr f ormula ::= atomic f ormulae

| atomic f ormulae : set of constraints

actions ::= action,actions | action
open unit ::= constr f ormula | rule

action ::= add(open unit) | del(open unit)

Fig. 7. Grammar for I

∗

:Adding and Removing Rules

9 Conclusions

This paper poses the open question of how to regulate the computations of
Artiﬁcial Neural Networks and Deep Learning and tries to open a research path
towards Artiﬁcial Teaching by means of Agent-based Training for Deep Learning
(ABT4DL). This proposal of Collaborative Learning use of Regulated Multi-
agent Systems (MAS) for this purpose. I presented my advances along these
lines, i.e. a normative language for Regulated MAS that is used to gather a set
of concurrent inputs provided by the proposed Training Agents.

The I language is useful to predict a future state of aﬀairs with an initial
state and a sequence of sets of events, that occur and modify the intermediate
states of aﬀairs, until the ﬁnal one is reached. The limitations of the language are
determined by the rule engine. These limitations include the inability to plan,
i.e. determine the sequence of sets of events that must occur in order to reach
a given state of aﬀairs from a given initial state, or post-dicting, i.e. determine
the previously unknown facts in a partial initial state given a ﬁnal state and
the sequence of sets of events that may have occurred previously. However, the
goal of the language is to regulate a MAS and keep track of its evolution by
prediction. Post-diction and planning would be interesting for a language that
an agent could use for deciding which action to perform but this is not the aim
of this paper.

In this article, how agent behaviour can be regulated with the language
proposed is shown, and it is shown that I has a simple and ﬁxed semantics
that avoids normative conﬂicts. However diﬀerent options of execution are given
by adding extra ignore-rules specifying what normative positions prevail over
others, in order to avoid any normative conﬂict when using deontic notions [4].
The main contribution of I summarised from [4] is the management of sets of
events that occur simultaneously and its implementation of norms not following
the standard deontic notions, i.e., permissions, prohibitions, and obligations.
One example of application would be when a software agent wins a given good
in an auction [12]. Two options are envisaged for the payment in that scenario:
1) expect the agent to generate the event of the payment and sanction the agent
if the event is not generated before a given deadline; or 2) if the Electronic
Institution has control on the agent’s balance, automatically generate an event
of payment as if the agent would have generated it. In fact, an obligation (to
perform an event) that may be violated is represented as the expectation of the
attempts to perform it. However, the enforcement of an obligation (to perform
a set of events) that may not be violated is carried out by the middleware by
taking these events as having been performed even they have not, denoting them
as forced events.

10 Future Work

10.1 Improving Computational Regulations

As mentioned previously, the language has been tested in the Electronic Institu-
tions (EIs) Middleware presented in [7] that runs over JADE [13]. Nonetheless,
the author expects to add the language to a newly developed Middleware, as
it is capable of give Operational Semantics, i.e run, a Declarative version of EI
protocols as it was shown in [4]. The main advantage of a Declarative version is
that it might be provided to Software Agents as the rules-of-the-game in order
to coordinate, e.g, using Game Theory.

10.2 Improving Game Theory

From the complete implementation of Declarative Electronic Institutions found
in [4] we have just used one Activity, a Metamorphic Game, i.e. a game whose
rules may vary with time, action (or inaction) of agents, or other normative
notions. To the best of my knowledge there are several types of Games not
formalised yet in order to fully coordinate agents in a Declarative (Complete)
Electronic Institution. Thus, there might be a need to formalise Hierarchical Con-
current Metamorphic Game Theory. However, following the Divide-and-Conquer
methodology a ﬁrst attempt of roadmap would be in the inverse order:

M etamorphic ⇒ Concurrent ⇒ Hierarchical

M etamorphic ⇒ Concurrent M etamorphic

Concurrent M etamorphic ⇒

Hierarchical Concurrent M etamorphic

Then, it would reasonable to study their interrelationships, thus creating
Declarative Meta-Games, as the computable with the Declarative Electronic
Institutions tested.

10.3 Full-Hybrid Artiﬁcial Intelligence

However, using I as an Programmable Event-based Middle-ware opens new
paths of research as it uses Hybrid AI (ı.e. mixes Autonomous Agents and Multi-
agents Systems, Machine Learning, and Symbolic Programming). Furthermore,
one of the main applications of Hybrid AI is in its own a whole new AI subﬁeld,
namely, Artiﬁcial Teaching.

10.4 Artiﬁcial Teaching

The whole concept of Artiﬁcial Teaching is recent, and not properly deﬁned
yet. There are some mentions in the literature that I will not cite in order to
engage the reader to improve the previous lines and the proposed concepts luckily
exposing her results on subsequent articles. For a sample, the reader may check
ongoing research in [14] and [15].

In my humble opinion, in the research path towards General AI there are
several Problem-speciﬁc milestones to reach in every sub-ﬁeld of AI; and mim-
icking Human Intelligence and Evolution, it may seem a natural step forward to
add the teaching capability to artiﬁcial learners to decrease complexity.

Please imagine a researcher (agent) being in a continuous ”Deep... and deep...
and deep... and very deep... Learning” process since the beginning of its exis-
tence. To the best of my knowledge, there are very few (human) researchers
(honestly, almost none) that self-learned everything on his own, with no inter-
action with others who may have taught him something, even involuntarily, and
this happens almost every day as a Spanish proverb well says.

10.5 Collaborative Knowledge Evolution

With this, I want to emphasize the role of (Human and Artiﬁcial; Physical and
Software) Teachers in Collaborative Learning and (Collaborative) Research, and
thus in Collaborative Knowledge Evolution. Luckily, in a future we would be a
step closer to General AI, by means of Collaborative Optimisation, achieving
thus a full integration and consensus of researchers (and their contributions,
either Physical or Software), even they are not collaborating on purpose. And
all these thanks to Regulated Middle-wares and Artiﬁcial Mediators.

References

1. Y. Lecun, Y. Bengio and G. Hinton, Deep learning, 2015. ISSN 14764687.

doi:10.1038/nature14539.

2. A. Garc´ıa-Camino, Implementing Norms in Electronic Institutions, in: Proceed-
ings of 4th International Joint Conference on Autonomous Agents and Multiagent
Systems (AAMAS’05), Utrecht, The Nederlands, 2005, pp. 667–673.

3. A. Garc´ıa-Camino, Ignoring, Forcing and Expecting Concurrent Events in Elec-
tronic Institutions, in: COIN III: Coordination, Organization, Institutions and
Norms in Agent Systems. Revised Selected Papers from the 2007 Workshop Se-
ries, Lecture Notes in Computer Science, Vol. 4870, Springer, 2007, pp. 15–26.
4. A. Garc´ıa-Camino, Normative regulation of open multi-agent systems, Monograf´ıas

del IIIA Vol. 35, Consejo Superior de Investigaciones Cient´ıﬁcas, 2010.

5. P. Noriega, Agent-Mediated Auctions: The Fishmarket Metaphor, PhD thesis, Uni-
versitat Autonoma de Barcelona, 1997, Number 8 in IIIA Monograph Series..
6. J.A. Rodr´ıguez-Aguilar, On the Design and Construction of Agent-mediated Elec-
tronic Institutions, PhD thesis, Universitat Autonoma de Barcelona, 2001, Number
14 in IIIA Monograph Series.

7. M. Esteva, Electronic Institutions: from speciﬁcation to development, PhD thesis,
Universitat Politecnica de Catalunya, 2003, Number 19 in IIIA Monograph Series.
8. V. Dignum, Ethics in artiﬁcial intelligence: introduction to the special issue, 2018.

ISSN 15728439. doi:10.1007/s10676-018-9450-z.

9. V. Vianu, Rule-Based Languages, Annals of Mathematics and Artiﬁcial Intelligence

19(1–2) (1997), 215–259.

10. K.R. Apt, From Logic Programming to Prolog, Prentice-Hall, U.K., 1997.
11. M. Fitting, First-Order Logic and Automated Theorem Proving, Springer-Verlag,

New York, U.S.A., 1990.

12. G. Cun´ı, M. Esteva, P. Garcia, E. Puertas, C. Sierra and T. Solchaga, MASFIT:
Multi-Agent System for Fish Trading, in: Procs. of the 16th European Conference
on Artiﬁcial Intelligence (ECAI 2004), Valencia, Spain, 2004, pp. 710–714.

13. F. Bellifemine, A. Poggi and G. Rimassa, JADE - A FIPA-compliant agent frame-
work, Technical Report, Telecom Italia., 1999, Part of this report has been also
published in Proceedings of PAAM’99, London, April 1999, pp.97-108..

14. D.-K. Kim, M. Liu, S. Omidshaﬁei, S. Lopez-Cot, M. Riemer, G. Habibi,
G. Tesauro, S. Mourad, M. Campbell and J.P. How, Learning Hierarchical Teaching
Policies for Cooperative Agents, in: Proceedings of the Conference in Autonomous
Agents and Multi-agent Systems (AAMAS’20), International Foundation for Au-
tonomous Agents and Multiagent Systems (IFAAMAS)., 2020, pp. 620–628.

15. F.L.D. Silva, G. Warnell, A.H.R. Costa and P. Stone, Agents Teaching Agents: A
Survey on Inter-agent Transfer Learning, in: Proceedings of the Conference in Au-
tonomous Agents and Multi-agent Systems (AAMAS’20), International Foundation
for Autonomous Agents and Multiagent Systems (IFAAMAS)., 2020, pp. 2165–
2167.

16. SICS, SICStus Prolog, Swedish Institute of Computer Science, 2019.

A Source Code

Next, I include the source code for the release version of I extracted from [4]
and written in Sicstus Prolog [16] :

% --------------------------------------------------------
% File: I-interpreter.pl
% Date: 10 March 2007
% Author: Andres Garcia-Camino -- agarcia-camino@acm.org
% Description:
% This program implements an interpreter for electronic
% institutions and norms represented as rules.
%
% History:
% version 5: Add s_if in s_star -> forward chaining is
%
% version 4: Fixes removal of formulae with variables
% version 3: Adds seteq command
% version 2: Fixes intersects(E,E’) vs intersects(E’,E)
%
% Instructions:
% 1. Edit the rule/2 facts to accommodate your rules
% ---------------------------------------------------------

activated even there is

no event

:- op(170,fx,[on,prevent,ignore,force,if]).
:- op(160,xfy,[if,do,on]).
:- use_module(library(lists)).
:- dynamic fired/1.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Reset
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 1. Retract all fired(_) assertions.
% 2. Assert the fired(_,_) fact so that "can_fire" does not
% fail if no such predicate exists.

reset :-

findall(C,retract(fired(C,_)),_),
assert(fired(false,false)).

% ---------------------------------------------------------

run(Delta,Events,NewDelta):-

findall(R,(rule(Id,R),R=(on _ if _ do _)),ECARules),
findall(R,(rule(Id,R),R=(ignore _ if _)),IgnRules),
findall(R,(rule(Id,R),R=(prevent _ if _)),PrvRules),
findall(R,(rule(Id,R),R=(force _ on _ if _ do _)),

FrcRules),

findall(R,(rule(Id,R),R=(if _ do _)),IfRules),
s_star(Delta,Events,ECARules,IfRules,IgnRules,PrvRules,

FrcRules,NewDelta).

% ---------------------------------------------------------

% ---------------------------------------------------------

s_star(Delta,Events,ECARules,IfRules,IgnRules,PrvRules,

FrcRules,NewDelta):-

reset,
s_if(Delta,IfRules,PrvRules,Delta2),
s_f(Delta2,Events,IfRules,IgnRules,PrvRules,FrcRules,

NewEvents,Delta3),

s_on(Delta3,NewEvents,ECARules,IfRules,IgnRules,PrvRules,

NewDelta).

% ---------------------------------------------------------

s_f(Delta,Events,IfRules,IgnRules,PrvRules,FrcRules,

NewEvents, NewDelta):-

findall([FE,A],(member(force FE on E if C do A,FrcRules),

subset2(E,Events),

s_l(Delta,C),\+ ignored(Delta,Events,E,IgnRules)),EAs),
findall(Ev,member([Ev,Ac],EAs),Es), append(Es,Events,

NewEvents),

findall(Ac,member([Ev,Ac],EAs),As),s_prime_r(Delta,

IfRules,PrvRules,As,NewDelta).

% ---------------------------------------------------------

s_on(Delta,Events,ECARules,IfRules,IgnRules,PrvRules,

NewDelta):-

findall(A,(member(on E if C do A,ECARules),

subset2(E,Events),
s_l(Delta,C),\+ ignored(Delta,Events,E,IgnRules)),As),

s_prime_r(Delta,IfRules,PrvRules,As,NewDelta).

% ---------------------------------------------------------

ignored(Delta,Events,E,IgnRules):-member(ignore E2 if C,

IgnRules),
subset2(E2,Events),
intersects(E,E2),s_l(Delta,C).

% ---------------------------------------------------------

% ---------------------------------------------------------
s_prime_r(S,_,_,[],S).

s_prime_r(S,IfRules,PrvRules,[A|As],NewS):-

s_r(S,A,TmpS),
check_prv(TmpS,PrvRules),
s_if(TmpS,IfRules,PrvRules,TmpS2),

s_prime_r(TmpS2,IfRules,PrvRules,As,NewS).

s_prime_r(S,IfRules,PrvRules,[_|As],NewS):-

s_prime_r(S,IfRules,PrvRules,As,NewS).

% ---------------------------------------------------------
check_prv(Delta,PrvRules):-

findall(C,(member(prevent C if C2,PrvRules),

s_l(Delta,C),
s_l(Delta,C2)),[]).

% ---------------------------------------------------------
% s_l(S/+,Conditions/+):-
% - Checks if Conditions matches S
% - When checking it also assigns values to variables in
%
% - Conditions is a list of the terms
% ---------------------------------------------------------
s_l(_,[]). % end of list?

Conditions

s_l(S,([Atf|Atfs])):- % otherwise

!,
s_l(S,Atf), % check each element of the list...
s_l(S,Atfs).

s_l(S,\+ Atf):- % handle negation

!,
\+ s_l(S,Atf).

s_l(_,seteq(L,L2)):- !, subset2(L,L2), subset2(L2,L),

length(L,N), length(L2,N).

s_l(_,true):-!. % handle true keyword

s_l(_,prolog(Goal)):- % handle arbitrary Prolog goal

!,
call(Goal).

s_l(S,Atf):- % atfs must be in S

!,
member(Atf,S).

% ---------------------------------------------------------

% ---------------------------------------------------------
s_r(S,[],S). % end of updates?

s_r(S,[Update|RHS],NewS):- % otherwise

!,
s_r(S,Update,STemp), % handle each update at a time
s_r(STemp,RHS,NewS).

s_r(S,add(Atf),[Atf|S]):- % add atf?

!,
\+ member(Atf,S).
s_r(S,add(_),S).
s_r(S,del(Atf),NewS):- % delete atf
!,
member(Atf,S),
delete(S,Atf,NewS).

s_r(S,del(_),S).

s_r(S,prolog(Goal),S):-

!,
call(Goal).

% ---------------------------------------------------------

intersects(L,L).
intersects(L,L2):- member(A,L),member(A,L2).
intersects(A,L):-member(A,L).

% ---------------------------------------------------------

subset2([],[]).
subset2([],[_|_]).
subset2([H|T],L):- member(H,L), subset2(T,L).
subset2(A,L):- member(A,L).

% ---------------------------------------------------------

s_if(Delta,IfRules,PrvRules,NewDelta):-
select_rule(Delta,IfRules,R),R\=[],
fire(Delta,PrvRules,R,TmpDelta),

s_if(TmpDelta,IfRules,PrvRules,NewDelta).

s_if(Delta,IfRules,_,Delta):-

select_rule(Delta,IfRules,[]).

s_if(Delta,IfRules,PrvRules,NewDelta):-

s_if(Delta,IfRules,PrvRules,NewDelta).
% ---------------------------------------------------------

% ---------------------------------------------------------

select_rule(Delta,IfRules,R):-

findall(Rule,(member(Rule,IfRules),can_fire(Delta

Rule)),
resolve(Rs,R).

Rs),

% ---------------------------------------------------------

resolve([],[]).
resolve([H|_],H).

% ---------------------------------------------------------

can_fire(Delta,if C do _):-s_l(Delta,C),\+ fired(C,A).

% ---------------------------------------------------------
fire(Delta,PrvRules,if C do A,NewDelta):-

assert(fired(C,A)),s_r(Delta,A,NewDelta),
check_prv(NewDelta,PrvRules).

