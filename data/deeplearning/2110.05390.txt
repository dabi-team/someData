1
2
0
2

t
c
O
1
1

]
L
P
.
s
c
[

1
v
0
9
3
5
0
.
0
1
1
2
:
v
i
X
r
a

Synthesizing Machine Learning Programs with PAC
Guarantees via Statistical Sketching

OSBERT BASTANI, University of Pennsylvania, USA

We study the problem of synthesizing programs that include machine learning components such as deep
neural networks (DNNs). We focus on statistical properties, which are properties expected to hold with high
probability—e.g., that an image classification model correctly identifies people in images with high probability.
We propose novel algorithms for sketching and synthesizing such programs by leveraging ideas from statistical
learning theory to provide statistical soundness guarantees. We evaluate our approach on synthesizing list
processing programs that include DNN components used to process image inputs, as well as case studies on
image classification and on precision medicine. Our results demonstrate that our approach can be used to
synthesize programs with probabilistic guarantees.

1 INTRODUCTION
Machine learning has recently become a powerful tool for solving challenging problems in artificial
intelligence. As a consequence, there has been a great deal of interest in incorporating machine
learning components such as deep neural networks (DNNs) into real-world systems, ranging from
healthcare decision-making [22, 27, 38], to robotics perception and control [44, 56], to improving
performance of software systems [16, 17, 39, 40, 43].

In these domains, there is often a need to ensure correctness properties of the overall system.
To reason about such properties, we need to reason about properties of the incorporated machine
learning components. However, it is in general impossible to absolutely guarantee correctness of a
machine learning component—e.g., we can never guarantee that a DNN correctly detects every
single image containing a pedestrian. Instead, we consider statistical properties, which are properties
that hold with high probability with respect to the distribution of inputs—e.g., we may want to
ensure that the DNN detects 95% of pedestrians encountered by an autonomous car.

We propose a framework for synthesizing programs that incorporate machine learning com-
ponents while satisfying statistical correctness properties. Our framework consists of two com-
ponents.1 First, it includes a novel statistical sketching algorithm, which builds on the concept of
sketching [66] to provide statistical guarantees. At a high level, it takes as input a sketch annotated
with specifications encoding statistical properties that are expected to hold, as well as holes cor-
responding to real-valued thresholds for making decisions (e.g., the confidence level at which to
label an image as containing a pedestrian or to diagnose a patient with a disease). Since statistical
properties depend on the data distribution, it additionally takes as input a labeled dataset of training
examples (separate from those used to train the DNNs). Then, our algorithm selects values to fill
the holes in the sketch so all the given specifications are satisfied.

1For completeness, our framework also includes a third component for statistical verification of machine learning pro-
grams [62, 73], which is described in Appendix A.

Author’s address: Osbert Bastani, obastani@seas.upenn.edu, University of Pennsylvania, USA.

Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and
the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored.
Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires
prior specific permission and/or a fee. Request permissions from permissions@acm.org.
© 2021 Association for Computing Machinery.
XXXX-XXXX/2021/10-ART $15.00
https://doi.org/10.1145/nnnnnnn.nnnnnnn

, Vol. 1, No. 1, Article . Publication date: October 2021.

 
 
 
 
 
 
2

Bastani

Second, our framework uses this sketching algorithm in conjunction with a syntax-guided syn-
thesizer [2] to synthesize programs in a specific domain that provably satisfy statistical guarantees.
Our strategy is to first synthesize a sketch whose specifications encode the overall statistical cor-
rectness property, and then apply our sketching algorithm to fill the holes in the sketch so these
specifications are satisfied with high probability.

The key challenge is providing statistical guarantees for programs using DNNs. To do so, we
leverage generalization bounds from statistical learning theory [34, 69, 71]. These bounds can be
thought of as a variant of concentration inequalities to apply to parameters that are estimated based
on a dataset. Traditionally, it is hard to apply generalization bounds to obtain useful guarantees on
the performance of machine learning components. One reason is that modern machine learning
models such as DNNs do not satisfy assumptions in learning theory. However, a deeper issue is
that learning theory can only prove bounds with respect to the best model in a given family, not
the “true” model. More precisely, given a model family F and a training dataset (cid:174)𝑧, learning theory
provides bounds on the performance of the model ˆ𝑓 learned using (cid:174)𝑧 in the following form:

𝐿( ˆ𝑓 ) ≤ 𝐿(𝑓 ∗) + G(F , 𝑛),
where 𝐿 a loss function (e.g., the accuracy of a model 𝑓 ) and G is a measure of the complexity
of F in the context of the amount of available training data 𝑛 = |(cid:174)𝑧| (e.g., VC dimension [34] or
Rademacher complexity [7]). In particular, learning theory provides no tools for bounding the error
𝐿(𝑓 ∗) of the optimal model given infinite training examples. In other words, learning theory cannot
guarantee that ˆ𝑓 is good at detecting pedestrians; at best, that given enough data, it is as good at
detecting pedestrians as the best possible DNN 𝑓 ∗ ∈ F .

However, we can provide guarantees for loss functions 𝐿 where we know that there exists some
solution 𝑓 ∗ with zero loss 𝐿(𝑓 ∗) = 0. In an analogy with program verification, we cannot in general
devise verification algorithms that are both sound and complete. Instead, the goal is to devise
algorithms that are as precise as possible subject to a soundness constraint. Similarly, our goal is to
learn models that perform as well as possible while satisfying a statistical property—i.e., we want a
model that empirically minimizes the number of false alarms while still satisfying the correctness
guarantee. For instance, this approach satisfies the above condition since 𝐿(𝑓 ∗) = 0 if 𝑓 ∗ predicts
there is a pedestrian in every image. Thus, we might learn a model that is guaranteed to detect 95%
of pedestrians but reports many false alarms (but in practice, we often achieve good performance).
In this context, we show how to use learning theory to sketch programs with statistical guarantees.
The machine learning components (e.g., DNNs) in the given sketch have already been trained
before our sketching algorithm is applied. In particular, the only task that must be performed by
our sketching algorithm is to choose threshold values to fill the holes in the sketch in a way that
satisfies the given specifications while maximizing performance—e.g., choose the confidence level
of the DNN above which an image contains a pedestrian so we detect 95% of pedestrians. Then,
generalization bounds can give us formal guarantees because (i) we are only synthesize a handful
of parameters, so the generalization error G(F , 𝑛) is small, and (ii) we can always choose the
thresholds to make conservative decisions, so the error 𝐿(𝑓 ∗) of the best possible model is small (we
choose the loss 𝐿 to measure whether the given specifications are satisfied, not the performance).
Next, we propose an algorithm for synthesizing machine learning programs that leverages our
statistical sketching algorithm as a subroutine. We consider a specification saying that with high
probability, the synthesized program should either return the correct answer or return “unknown”.
This specification is consistent with the above discussion since we can naïvely ensure correctness
by always returning “unknown”. Then, our goal is to synthesize a program that satisfies the desired
statistical specification but returns “unknown” as rarely as possible. To achieve this goal, our
synthesis algorithm first uses a standard enumerative synthesis algorithm to identify a program

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

3

that is correct when given access to ground truth labels. When ground truth labels are unavailable,
this program must instead use labels predicted by machine learning components; to satisfy the
specification, these components include holes corresponding to predicted confidences below which
the component returns “unknown”. Then, our algorithm uses statistical sketching to fill these holds
with thresholds in a way that satisfies the statistical property encoded by the given specification.
Our sketching algorithm requires the holes in the sketch to be annotated with local correctness
properties; then, it fill sthe holes in a way that satisfies these annotations. Thus, the main challenge
for our synthesizer is how to label holes in the sketch with these annotations so that if the
annotations hold true, the given specification is satisfied. We instantiate such a strategy in the
context of list processing programs where the components can include learned DNNs such as object
classifiers or detectors. In particular, our algorithm analyzes the sketch to allocate allowable errors
to each hole in a way that the overall error of the program is bounded by the desired amount.

We have implemented our approach in a tool called StatCoder, and evaluate it in two ways.
First, we evaluate its ability to synthesize list processing programs satisfying statistical properties
where the program inputs are images, and DNN components are used to classify or detect objects in
these images. Our results show that our algorithm for error allocation outperforms a naïve baseline,
and that our novel statistical learning theory bound outperforms using a more traditional bound.
Second, we perform two case studies of our sketching algorithm: one on ImageNet classification
and another on a medical prediction task, which demonstrate additional interesting applications of
our sketching algorithm. In summary, our contributions are:

• A sketching language for writing programs that incorporate machine learning components

in a way that ensures correctness guarantees (Section 3).

• Algorithms for sketching (Section 4) and synthesizing (Section 5) such programs.
• An empirical evaluation (Section 7) validating our approach in the context of our list process-

ing domain (for synthesis) as well as two case studies (for sketching).

2 OVERVIEW
We describe how our statistical sketching algorithm can construct a subroutine for detecting
whether an image contains a person, guaranteeing that if the image contains a person, then it
returns “true” with high probability. Then, we describe how our synthesizer uses the sketching
algorithm to synthesize a program that counts the number of people in a sequence of images.

Statistical sketching. We assume given a DNN component 𝑓 : X → [0, 1] that, given an image
𝑥 ∈ X, predicts whether 𝑥 contains a person. In particular, 𝑓 (𝑥) is a score indicating its confidence
that 𝑥 contains a person; higher score means more likely to contain a person. We do not assume
the the scores are reliable—e.g., they may be overconfident. We assume that the ground truth label
𝑦∗ ∈ Y = {0, 1} indicates whether 𝑥 contains a person. For example, 𝑓 (𝑥) may be the probability
that an image contains a person according to a pretrained DNN such as ResNet [29]; then, the goal
is to tailor this DNN to the current task in a way that provides correctness guarantees.

In particular, our goal is to choose a threshold 𝑐 ∈ [0, 1] such that the program returns that
the given image 𝑥 contains a person if 𝑓 (𝑥) has confidence at least 1 − 𝑐—i.e., 𝑓 (𝑥) ≥ 1 − 𝑐, or
equivalently, 1 − 𝑓 (𝑥) ≤ 𝑐. Furthermore, we want 𝑐 to be correct in the following sense:

(𝑦∗ = 1) ⇒ (1 − 𝑓 (𝑥) ≤ 𝑐)

That is, if the image contains a person (i.e., 𝑦∗ = 1), then the classifier should say so (i.e., 1− 𝑓 (𝑥) ≤ 𝑐).
Note that we do not require the converse—i.e., the program may incorrectly conclude that an image
contains a person even if it does not. That is, we want soundness (i.e., no false negatives) but not
necessarily completeness (i.e., no false positives). However, we cannot guarantee that soundness

, Vol. 1, No. 1, Article . Publication date: October 2021.

4

Bastani

holds for every image 𝑥; instead, we want to guarantee it holds with high probability. There are
two ways to formulate probabilistic correctness. First, we can say 𝑐 is 𝜖-approximately correct if

P𝑝 (𝑥,𝑦∗)

(cid:0)𝑦∗ = 1 ⇒ 1 − 𝑓 (𝑥) ≤ 𝑐(cid:1) ≥ 1 − 𝜖,

(1)

where 𝑝 (𝑥, 𝑦∗) is the data distribution and 𝜖 ∈ R>0 is a user-provided confidence level—i.e., 𝑓 is
correct for 1 − 𝜖 fraction of images sampled from 𝑝 (𝑥, 𝑦∗) that contain a person. Alternatively, we
can say 𝑐 is 𝜖-approximately correct if

P𝑝 (𝑥,𝑦∗)

(cid:0)1 − 𝑓 (𝑥) ≤ 𝑐 | 𝑦∗ = 1(cid:1) ≥ 1 − 𝜖.

(2)

We refer to (1) as an implication guarantee and (2) as a conditional guarantee. The difference is how
“irrelevant examples” (i.e., 𝑦∗ = 0) are counted: (1) counts them as being correctly handled, whereas
(2) omits them from consideration. In our example, (1) says we can count all images without people
as being correctly handled. If most images do not contain people, then we can make a large number
of mistakes on images that contain people and still achieve ≥ 1 − 𝜖 correctness overall. In contrast,
(2) ignores images without people, so we must obtain ≥ 1 − 𝜖 correctness rate on images with
people alone. However, using (2), if there are very few images with people, then estimates of the
error rate can be very noisy, making our algorithm very conservative. We allow the user choose
which guarantee to use; intuitively, (1) can be used if the goal is to bound the overall error rate,
whereas (2) should be used if it is to bound the error rate among relevant examples. Our syntax for
expressing the specification in our example is

The syntax | indicates the conditional guarantee (2); we use ⇒ to indicate (1).

1 − 𝑓 (𝑥) ≤ 𝑐 {𝑦∗ = 1} |

0.05.

We need to slightly weaken our guarantees in an additional way. The reason is that our algorithm
relies on training examples (cid:174)𝑧 = {(𝑥1, 𝑦∗
𝑖 ) ∼ 𝑝 are i.i.d.
samples from 𝑝 (𝑥, 𝑦∗). Thus, as with probably approximately correct (PAC) bounds from statistical
learning theory [28, 69], we need to additional allow a possibility that our algorithm fails altogether
due to the randomness in our training examples (cid:174)𝑧. In particular, consider an algorithm 𝐴 that
chooses 𝑐 = 𝐴((cid:174)𝑧); then, we say 𝐴 is (𝜖, 𝛿)-PAC if

𝑛)} to choose 𝑐, where (𝑥𝑖, 𝑦∗

1), ..., (𝑥𝑛, 𝑦∗

P𝑝 ( (cid:174)𝑧)

(cid:0)𝐴((cid:174)𝑧) is 𝜖-approximately correct(cid:1) ≥ 1 − 𝛿

where 𝑝 ((cid:174)𝑧) is the distribution over the training examples (cid:174)𝑧, and 𝛿 ∈ R>0 is another user-provided
confidence level. Then, given the sketch, a value 𝛿 ∈ R>0, and a dataset (cid:174)𝑧, our algorithm synthesizes
a value of 𝑐 to fill ??1 in a way that ensures that the specification holds (i.e., 𝑐 is 𝜖-approximately
correct) with probability at least 1 − 𝛿.

Synthesis algorithm. Next, suppose we want to synthesize a program that counts the number of
people in a list of images ℓ = (𝑥1, ..., 𝑥𝑛). Intuitively, we can do so by writing a simple list processing
program around our DNN for detecting people. In particular, letting

(predictperson 𝑥) = 1(1 − 𝑓 (𝑥) ≤ ??)
be our DNN component, where the detection threshold has been left as a hole, then the sketch
˜𝑃ex = (fold + (map predictperson ℓ) 0)
counts the number of people in ℓ. Given a few input-output examples along with the ground truth
labels for each image, we can use a standard enumerative synthesizer to compute the sketch ˜𝑃ex,
assuming predictperson returns the ground truth label. In particular, this sketch has a single hole in
the DNN component predictperson that remains to be filled.

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

5

Note that ˜𝑃ex evaluates correctly if predictperson returns the ground truth label, but in general,
it may make mistakes. Thus, the correctness property for the synthesized program 𝑃ex needs to
account for the possibility that predictperson may return incorrectly. Mirroring the correctness
property for a single prediction, suppose we want a program 𝑃ex that conservatively overestimates
the number of people in ℓ.2 In particular, given confidence levels 𝜖, 𝛿 ∈ R>0, we say a completion
𝑃ex of ˜𝑃ex is 𝜖-approximately correct if

where 𝛼 = (ℓ, 𝑦∗) is an example, and
Then, we say our synthesis algorithm is (𝜖, 𝛿)-probably approximately correct (PAC) if

ℓ ≥ 𝑦∗) ≥ 1 − 𝜖,
(cid:75)

𝑃ex
(cid:74)
ℓ denotes the output of running program 𝑃 on input ℓ.
(cid:75)

P𝑝 (𝛼) (
𝑃
(cid:74)

P𝑝 ( (cid:174)𝛼) (𝐴( ˜𝑃ex, (cid:174)𝛼) is 𝜖-approximately correct) ≥ 1 − 𝛿,
where 𝑃ex = 𝐴( ˜𝑃ex, (cid:174)𝛼) is the program synthesized using our algorithm and training examples (cid:174)𝛼.
Using our statistical sketching algorithm, we can provide (𝜖 ′, 𝛿 ′)-PAC guarantees on predictperson
for any 𝜖 ′, 𝛿 ′ ∈ R>0; thus, the question is how to choose (i) the appropriate specification, (ii) the
parameters of this specification, and (iii) the confidence levels 𝜖 ′, 𝛿 ′. These choices depend on the
specification that we want to ensure for the synthesized program 𝑃ex. In our example, we can use
the specification above—i.e., that predictperson returns 1 with high probability if there is a person:
(predictperson 𝑥) = 1(1 − 𝑓 (𝑥) ≤??) {𝑦∗ = 1} |
𝜖′.
In general, the specification on predictperson may have additional parameters (in particular, for
real-valued predictions, an error tolerance 𝑒).

Next, we need to choose 𝜖 ′, 𝛿 ′. While there is only one hole, predictperson is executed multiple times
(assuming length(ℓ) > 1). We need to choose 𝜖 ′ and 𝛿 ′ so that with high probability, predictperson
is correct for all applications. For simplicity, we assume given an upper bound 𝑁 ∈ N on the
maximum possible length of ℓ (we discuss how we might remove this assumption in Section 6).
Given 𝑁 , we take 𝜖 ′ = 𝜖/𝑁 and 𝛿 ′ = 𝛿/𝑁 ; then, we use our sketching algorithm to synthesize 𝑐 to
fill the hole in predictperson. By a union bound, for a given list ℓ, all applications of predictperson are
correct with probability at least 1 − 𝜖, and this property holds with probability at least 1 − 𝛿. Under
this event, 𝑃ex returns correctly—i.e., 𝑃ex satisfies the desired (𝜖, 𝛿)-PAC guarantee.

3 SKETCH LANGUAGE
In this section, we describe the syntax and semantics of our sketch language, as well as the desired
correctness properties we expect that synthesized programs should satisfy.

Syntax. Our sketch language is shown in Figure 1. Intuitively, in the expression 𝜙 (𝑃, 𝑐) {𝑄 }𝜔
𝜖 ,
𝑄 is a specification that we want to ensure holds, 𝑃 is a score (intuitively, it should indicate the
likelihood that 𝑄 holds, but we make no assumptions about it), 𝑐 is a threshold below which we
consider 𝑄 to be satisfied, 𝜖 is the allowed failure probability, and 𝜔 indicates whether we want
a conditional guarantee (i.e., 𝜔 = |, the guarantee (2)) or implication guarantee (i.e., 𝜔 = ⇒, the
guarantee (1)). We assume that 𝑃 evaluates to a value in R, 𝑐 ∈ R, and 𝑄 evaluates to a value in
{0, 1}. Note that 𝑄 is itself a program; unlike programs 𝑃, it can use ground truth inputs 𝑦. Finally,
either 𝑐 and 𝜖 in this expression can be left as a hole ?? (but not both simultaneously).

We say 𝑃 is complete if it contains no holes and partial otherwise. We use P to denote the space
of programs, ¯P ⊆ P to denote the space of complete programs, and ¯𝑃 ∈ ¯P to denote a complete
program. For 𝑃 ∈ P, we use Φ(𝑃) to denote the expressions 𝜙 (𝑃 ′, 𝑐) {𝑄 }𝜔
𝜖 in 𝑃 (including cases
2In Section 5, our synthesis algorithm is presented for the case where it returns the correct answer or “unknown” with high
probability, but as we discuss in Section 6, it can easily be modified to return an overestimate of the correct answer.

, Vol. 1, No. 1, Article . Publication date: October 2021.

6

Bastani

𝑃 ::= 𝑐 | 𝑥 | 𝑓 (𝑃, ..., 𝑃 )
| 𝜙 (𝑃, 𝑐) {𝑄 }𝜔
𝑄 ::= 𝑐 | 𝑥 | 𝑦 | 𝑓 (𝑄, ..., 𝑄)

𝜖 | 𝜙 (𝑃, ??) {𝑄 }𝜔

𝜖 | 𝜙 (𝑃, 𝑐) {𝑄 }𝜔
??

𝑐
(cid:74)
𝑥
(cid:74)
𝑦

(cid:74)

∗
𝛼 = 𝑐
(cid:75)
∗
𝛼 = 𝛼 (𝑥)
(cid:75)
∗
𝛼 = 𝛼 (𝑦)
(cid:75)

𝛽 = 𝑐
𝛽 = 𝛽 (𝑥)

𝑐
(cid:74)
𝑥
(cid:74)

(cid:75)

(cid:75)

𝑓 (𝑃, ..., 𝑃 )
(cid:74)
𝑓 (𝑄, ..., 𝑄)
𝜙 (𝑃, 𝑐) {𝑄 }𝜔
𝜖
(cid:74)

(cid:74)

∗
∗
𝛼 , ...,
𝛼 = 𝑓 (
𝑃
(cid:74)
(cid:75)
(cid:75)
∗
∗
𝛼 , ...,
𝑄
𝛼 = 𝑓 (
(cid:75)
(cid:74)
(cid:75)
∗
𝑄
𝛼 =
(cid:74)
(cid:75)

∗
𝛼
(cid:75)

𝑃
(cid:74)

∗
𝛼 )
(cid:75)
∗
𝑄
𝛼 )
(cid:75)
(cid:74)

(cid:74)

𝑓 (𝑃, ..., 𝑃 )
𝜙 (𝑃, 𝑣) {𝑄 }𝜔
𝜖
(cid:74)

(cid:75)

(cid:75)

𝛽 = 𝑓 (
𝛽 = 1(

𝑃
(cid:74)

𝑃
(cid:74)

𝛽 , ...,
𝑃
(cid:74)
𝛽 > 𝑐)

(cid:75)

(cid:75)

𝛽 )

(cid:75)

Fig. 1. Syntax (left), train semantics (right, top), and test semantics (right, bottom). The production rules in
the syntax are implicitly universally quantified over constant values 𝑐 ∈ C, input variables 𝑥 ∈ X, ground truth
input variables 𝑦 ∈ Y, components 𝑓 ∈ F where 𝑓 : C𝑘 → C, 𝜖 ∈ R>0, and 𝜔 ∈ {|, ⇒}. The distinguished
component 𝜙 ∈ F is a function 𝜙 : R2 → R defined by 𝜙 (𝑧, 𝑡) = 1(𝑧 ≤ 𝑡).

where 𝑐 or 𝜖 is a hole), Φ𝑐
to denote the expressions 𝜙 (𝑃 ′, 𝑐) {𝑄 }𝜔

??(𝑃) ⊆ Φ(𝑃) to denote the expressions 𝜙 (𝑃 ′, ??) {𝑄 }𝜔
?? in 𝑃, and Φ?? (𝑃) = Φ𝑐
?? (𝑃).

?? (𝑃) ∪ Φ𝜖

𝜖 in 𝑃, Φ𝜖

?? (𝑃) ⊆ Φ(𝑃)

Semantics. We define two semantics for programs 𝑃, shown in Figure 1:
• Train semantics: Given a training valuation 𝛼 ∈ A, where 𝛼 : X ∪ Y → C maps both
𝛼 evaluate 𝑄 instead of
∗
(cid:75)

inputs and ground truth inputs 𝑦 to values, the train semantics
𝜙 (𝑃, 𝑐). Since they ignore 𝜙, they can be applied to both partial and complete programs.
• Test semantics: Given a test valuation 𝛽 ∈ B, where 𝛽 : X → C maps inputs to values, the

(cid:74)

·

test semantics

·

𝛽 evaluate 𝜙 (𝑃, 𝑐) instead of 𝑄. They only apply to complete programs.

(cid:74)

(cid:75)

Correctness properties. We define what it means for a complete program to be correct—i.e., satisfies

its specifications. We begin with correctness of a single specification.

Definition 3.1. Given a distribution 𝑝 (𝛼) over test valuations 𝛼 ∈ A, 𝜙 ( ¯𝑃, 𝑐) {𝑄 } |

𝜖 is approxi-

mately sound if it satisfies the conditional guarantee3
P𝑝 (𝛼)

𝜙 ( ¯𝑃, 𝑐) {𝑄 }𝜔
(cid:1) ≥ 1 − 𝜖,
𝜖
(cid:74)
is approximately sound if it satisfies the implication guarantee

𝜙 ( ¯𝑃, 𝑐) {𝑄 }𝜔
𝜖
(cid:74)

and {𝑄 }⇒
𝜖

∗
𝛼
(cid:75)

𝛼
(cid:75)

(cid:12)
(cid:12)

(cid:0)

𝜙 ( ¯𝑃, 𝑐) {𝑄 }𝜔
𝜖
(cid:74)
This property can be thought of as probabilistic soundness; it says that we should have 𝜙 ( ¯𝑃, 𝑐) ⇒

𝜙 ( ¯𝑃, 𝑐) {𝑄 }𝜔
𝜖
(cid:74)

𝛼 (cid:1) ≥ 1 − 𝜖.
(cid:75)

∗
𝛼 ⇒
(cid:75)

P𝑝 (𝛼)

(cid:0)

𝑄 with high probability, which means that 𝜙 ( ¯𝑃, 𝑐) is a sound overapproximation of 𝑄.

Definition 3.2. A complete program ¯𝑃 is approximately correct (denoted ¯𝑃 ∈ ¯P∗) if every

expression 𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔

𝜖 in ¯𝑃 is approximately sound.

4 STATISTICAL SKETCHING
Next, we describe our algorithm for synthesizing values 𝑐 and 𝜖 to fill holes in a given sketch. Our
algorithm, shown in Figure 1, takes as input a sketch 𝑃, training valuations (cid:174)𝛼 = (𝛼1, ..., 𝛼𝑛), where
𝛼1, ..., 𝛼𝑛 ∼ 𝑝 are i.i.d. samples, and a confidence level 𝛿 ∈ R>0, and outputs a complete program
𝐴( ¯𝑃, (cid:174)𝛼) ∈ ¯P∗ that is approximately correct with probability at least 1 − 𝛿 with respect to 𝑝 ( (cid:174)𝛼).

Our algorithm synthesizes 𝑐 and 𝜖 in a bottom-up fashion, so that all subtrees of the current
expression are complete. Our sketching algorithm uses probabilistic bounds in conjunction with the
given samples (cid:174)𝛼 to provide guarantees. Intuitively, since we are estimating parameters from data,
our problem is a statistical learning problem [69], so we can leverage techniques from statistical
learning theory to provide guarantees on the synthesized sketch.

3Note that since 𝛼 includes valuations of 𝑥 ∈ X, we can use it in conjunction both train semantics and test semantics.

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

7

For synthesizing 𝑐—i.e., an expression 𝐸 = 𝜙 (𝑃, 𝑐) {𝑄 }𝜔
,
𝐸
(cid:74)
(cid:75)
𝛼 = 1
then 𝑐 is 𝜖-approximately correct if 𝑧𝛼 ≤ 𝑐 conditioned on 𝑧∗
(if 𝜔 = ⇒) with probability at least 1 − 𝜖 with respect to 𝑝 (𝛼). In either case, synthesizing 𝑐 is
equivalent to a binary classification problem with labels 𝑧∗
𝛼 , with a one-dimensional hypothesis
space 𝑐 ∈ R and a one-dimensional feature space 𝑧𝛼 ∈ R. Furthermore, this problem is simple—𝑐 is
a linear classifier. Thus, we could use standard learning theory results to provide guarantees.

𝛼 ∈ R and 𝑧∗
𝛼 =
(cid:75)
𝛼 = 1 (if 𝜔 = |) or whenever 𝑧∗

𝜖 . Letting 𝑧𝛼 =

𝑃
(cid:74)

However, we can obtain sharper guarantees using a learning theory bound specialized to our
setting. We build on a bound based on [28] (Section 4.1) tailored to the realizable setting, where
there exists a classifier that makes zero mistakes. Our setting is realizable, since 𝑐 = ∞ always
makes zero mistakes. The main difference is that their bound always chooses a classifier that makes
zero mistakes, which can be overly conservative. We prove a novel generalization bound that allows
for some number 𝑘 of mistakes that is a function of 𝜖, 𝛿, and 𝑛.

Synthesizing a value 𝜖 is a bit different, since we are not classifying examples that depend on a
single 𝛼, but examples that depend on (cid:174)𝛼. Thus, we can formulate it as a learning problem where
the examples are (cid:174)𝛼; however, this approach is complicated due to the need to figure out how to
divide our given samples (cid:174)𝛼 into multiple sub-examples (cid:174)𝛼1, ... (cid:174)𝛼𝑛. Instead, we use an approach based
on Hoeffding’s inequality [30] (Section 4.2) to infer 𝜖. In particular, Hoeffding’s inequality gives us
a lower bound on the correctness rate P𝑝 (𝛼) (𝑧𝛼 | 𝑧∗
𝛼 ⇒ 𝑧𝛼 ) ≥ 1 − 𝜖
(if 𝜔 = ⇒), and we can simply use this 𝜖.

𝛼 ) ≥ 1 − 𝜖 (if 𝜔 = |) or P𝑝 (𝛼) (𝑧∗

Finally, our sketching algorithm uses the above two approaches to synthesize 𝑐 and 𝜖 (Section 4.3).

4.1 A Learning Theory Bound

Problem formulation. We consider a unary classification problem with one-dimensional feature
and hypothesis spaces. In particular, given a probability distribution 𝑝 (𝑧) over 𝑧 ∈ R (the feature),
the goal is to select the smallest possible threshold 𝑡 ∈ R (the hypothesis) such that

P𝑝 (𝑧) (𝑧 ≤ 𝑡) ≥ 1 − 𝜖
for a given 𝜖 ∈ R>0. That is, we want the smallest possible 𝑡 such that 𝑧 ∈ (−∞, 𝑡] with probability
at least 1 − 𝜖 according to 𝑝 (𝑧). We denote the subset of 𝑡 that satisfies (3) by

(3)

T𝜖 = (cid:8)𝑡 ∈ R | P𝑝 (𝑧) (𝑧 ≤ 𝑡) ≥ 1 − 𝜖(cid:9) .
To compute such a 𝑡, we are given a training set of examples (cid:174)𝑧 = (𝑧1, ..., 𝑧𝑛) ∈ R𝑛, where 𝑧1, ..., 𝑧𝑛 ∼ 𝑝
are 𝑛 i.i.d. samples from 𝑝. An estimator ˆ𝑡 is a mapping ˆ𝑡 : R𝑛 → R. Then, the constraint (3) is
ˆ𝑡 ((cid:174)𝑧) ∈ T𝜖 ; we say such a ˆ𝑡 is 𝜖-approximately correct—i.e., it is correct for “most” samples 𝑧 ∼ 𝑝.

In general, we are unable to guarantee that ˆ𝑡 is approximately correct due to the randomness in
the training examples (cid:174)𝑧. Thus, we additionally allow for a small probability 𝛿 ∈ R>0 that ˆ𝑡 is not
approximately correct.

Definition 4.1. Given 𝜖, 𝛿 ∈ R>0, ˆ𝑡 is (𝜖, 𝛿)-PAC if P𝑝 ( (cid:174)𝑧) (ˆ𝑡 ((cid:174)𝑧) ∈ T𝜖 ) ≥ 1 − 𝛿.
That is, ˆ𝑡 ((cid:174)𝑧) is approximately correct with probability at least 1 − 𝛿 according to 𝑝 ((cid:174)𝑧). Our goal

is to construct an (𝜖, 𝛿)-PAC estimator ˆ𝑡 ((cid:174)𝑧) that tries to minimize ˆ𝑡 ((cid:174)𝑧).

Estimator. Given 𝜖, 𝛿 ∈ R>0, consider the estimator

ˆ𝑡 ((cid:174)𝑧) = inf
𝑡 ∈R

(cid:8)𝑡 ∈ R (cid:12)

(cid:12) 𝐿(𝑡; (cid:174)𝑧) ≤ 𝑘(cid:9) + 𝛾 ((cid:174)𝑧) where 𝑘 = max

(cid:40)
ℎ ∈ N

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

ℎ
∑︁

𝑖=0

(cid:19)

(cid:18)𝑛
𝑖

𝜖𝑖 (1 − 𝜖)𝑛−𝑖 ≤ 𝛿

(cid:41)

(4)

where the empirical loss is 𝐿(𝑡; (cid:174)𝑧) = (cid:205)𝑧 ∈(cid:174)𝑧 1(𝑧 > 𝑡), and where 𝛾 ((cid:174)𝑧) > 0 is an arbitrary positive
function. Intuitively, the empirical loss counts the number of mistakes that 𝑡 makes on the training

, Vol. 1, No. 1, Article . Publication date: October 2021.

8

Bastani

Algorithm 1 Use learning theory to sketch ¯𝑃 that is approximately correct.

procedure Sketch(𝑃, (cid:174)𝛼, 𝛿)

𝑚 ← |Φ?? (𝑃)|
for 𝐸 ∈ BottomUp(Φ??(𝑃)) do
if 𝐸 = 𝜙 ( ¯𝑃 ′, ??) {𝑄 }𝜔
𝜖 then

Compute (cid:174)𝑧 (cid:174)𝛼 according to (6)
Compute ˆ𝑡 ((cid:174)𝑧 (cid:174)𝛼 ) according to (4) with (𝜖, 𝛿/𝑚)
Fill the hole ?? with ˆ𝑡 ((cid:174)𝑧𝛼 )

else if 𝐸 = 𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔

?? then
Compute (cid:174)𝑧 (cid:174)𝛼 according to (6)
Compute ˆ𝜈 ((cid:174)𝑧 (cid:174)𝛼 ) according to (5) with 𝛿/𝑚
Fill the hole ?? with 1 − ˆ𝜈 ((cid:174)𝑧 (cid:174)𝛼 )

end if

end for
return true
end procedure

data—i.e., 𝑧 ∈ (cid:174)𝑧 such that 𝑧 ∉ (−∞, 𝑡]. To compute the solution 𝑘 in (4), we start with ℎ = 0 and
increment it until it no longer satisfies the condition. To ensure numerical stability, this computation
is performed using logarithms. Note that 𝑘 does not exist if the set inside the maximum in (4) is
empty; in this case, we choose ˆ𝜓 ((cid:174)𝑧) = 0, which trivially satisfies the PAC property. To compute
ˆ𝑡 ((cid:174)𝑧), we sort the training examples 𝑧1, ..., 𝑧𝑛 by magnitude, so 𝑧1 ≥ 𝑧2 ≥ ... ≥ 𝑧𝑛. Finally, 𝑧𝑘+1 solves
the minimization problem in (4), so ˆ𝑡 ((cid:174)𝑧) = 𝑧𝑘+1 + 𝛾 ((cid:174)𝑧). If 𝑘 does not exist, then we choose ˆ𝑡 ((cid:174)𝑧) = ∞,
which trivially satisfies the PAC property. We have the following; see Appendix B.2 for a proof:

Theorem 4.2. The estimator ˆ𝑡 ((cid:174)𝑧) in (4) is (𝜖, 𝛿)-PAC.

4.2 A Concentration Bound

Problem formulation. Consider a Bernoulli distribution 𝑝 = Bernoulli(𝜇) with unknown mean
𝜇 ∈ [0, 1]. Our goal is to compute a lower bound 𝜈 ∈ [0, 1] of 𝜇—i.e., 𝜇 ≥ 𝜈. For example, if 𝜇 is
the error rate of a classifier, then 𝜈 is a lower bound on this rate. To compute 𝜈, we are given a
training set (cid:174)𝑧 = (𝑧1, ..., 𝑧𝑛) ∈ {0, 1}𝑛, where 𝑧1, ..., 𝑧𝑛 ∼ 𝑝 are 𝑛 i.i.d. samples from 𝑝. An estimator is
a mapping ˆ𝜈 : R𝑛 → R. We say ˆ𝜈 is correct if it satisfies 𝜇 ≥ ˆ𝜈 ((cid:174)𝑧). We are unable to guarantee that
ˆ𝜈 ((cid:174)𝑧) is correct due to the randomness in the training examples (cid:174)𝑧. Thus, we additionally allow for a
small probability 𝛿 ∈ R>0 that ˆ𝜓 ((cid:174)𝑧) is not correct—i.e., it is probably correct (PC).

Definition 4.3. Given 𝛿 ∈ R>0, ˆ𝜈 is 𝛿-PC if P𝑝 ( (cid:174)𝑧)
In other words, ˆ𝜈 ((cid:174)𝑧) is correct with probability at least 1 − 𝛿 according to the randomness in

(cid:0)𝜇 ≥ ˆ𝜈 ((cid:174)𝑧)(cid:1) ≥ 1 − 𝛿.

𝑝 ((cid:174)𝑧). Our goal is to construct an 𝛿-PC estimator ˆ𝜈 ((cid:174)𝑧).

Estimator. Given 𝛿 ∈ R>0, consider the estimator

ˆ𝜈 ((cid:174)𝑧) = ˆ𝜇 ((cid:174)𝑧) −

√︂ log(1/𝛿)
2𝑛

,

(5)

where ˆ𝜇 ((cid:174)𝑧) = 𝑛−1 (cid:205)𝑧 ∈(cid:174)𝑧 𝑧 is an estimate of 𝜇 based on the samples (cid:174)𝑧; we take ˆ𝜈 ((cid:174)𝑧) = 0 if (5) is
negative. Intuitively, the second term in ˆ𝜈 ((cid:174)𝑧) is a correction to ˆ𝜇 ((cid:174)𝑧) to ensure it is (𝜖, 𝛿)-PC, based
on Hoeffding’s inequality [30]. We have the following; see Appendix B.3 for a proof:

Theorem 4.4. The estimator ˆ𝜈 is 𝛿-PC.

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

9

4.3 Sketching Algorithm

Problem formulation. A sketching algorithm 𝐴 : P × A𝑛 → ¯P takes as input a partial program
𝑃 ∈ P, together with a set of test valuations (cid:174)𝛼 = (𝛼1, ..., 𝛼𝑛) ∈ A𝑛, where 𝛼1, ..., 𝛼𝑛 ∼ 𝑝 are i.i.d.
samples from an underlying distribution 𝑝 (𝛼). Then, ¯𝑃 = 𝐴(𝑃, (cid:174)𝛼) should be a complete program
that is approximately correct by filling each hole in expressions 𝜙 (𝑃 ′, ??) {𝑄 }𝜔
??(𝑃) with a
value 𝑐 ∈ R and each hole in expressions 𝜙 (𝑃 ′, 𝑐) {𝑄 }𝜔
??(𝑃) with a value 𝜖 ∈ R>0. We assume
that every expression in Φ(𝑃) has a hole—i.e., Φ(𝑃) = Φ?? (𝑃); otherwise, we cannot guarantee that
the existing thresholds in these expressions are approximately sound.

?? ∈ 𝜙𝜖

𝜖 ∈ Φ𝑐

Definition 4.5. A partial program 𝑃 ∈ P is a full sketch, denoted 𝑃 ∈ P0, if Φ??(𝑃) = Φ(𝑃).
Then, we say 𝐴 is correct if 𝐴(𝑃, (cid:174)𝛼) ∈ ¯P∗. We cannot guarantee this property; instead, given

𝛿 ∈ R>0, we want it to hold with probability at least 1 − 𝛿 according to 𝑝 ( (cid:174)𝛼).

Definition 4.6. A sketching algorithm 𝐴 : P0 × A𝑛 → ¯P is 𝛿-probably approximately correct
(cid:0)𝐴(𝑃, (cid:174)𝛼) ∈ ¯P∗(cid:1) ≥ 1 − 𝛿.

(PAC) if for all 𝑃 ∈ P0, we have P𝑝 ( (cid:174)𝛼)

Note that this definition does not include 𝜖 since these values are provide in the given sketch.

Algorithm. Our sketching algorithm is shown in Algorithm 1. At a high level, it fills each hole so
that the resulting expressions 𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔
𝜖 are all approximately sound. The order in which these
expressions are processed is important; a expression cannot be processed until all its descendants
have been processed. This order ensures that ¯𝑃 ′ is complete, so it can be evaluated. In Algorithm 1,
the function BottomUp ensures that the expressions in Φ?? (𝑃) is processed in such an order. The
algorithm allocates a 𝛿/𝑚 probability of failure for each expression, where 𝑚 = |Φ?? (𝑃)|.

Synthesizing 𝑐. We describe how our algorithm synthesizes a threshold 𝑐 for an expression

𝐸 = 𝜙 ( ¯𝑃 ′, ??) {𝑄 }𝜔

𝜖 . Given a single test valuation 𝛼 ∼ 𝑝, consider the values

𝑧𝛼 =

¯𝑃 ′
(cid:74)

𝛼
(cid:75)

and

𝑧∗
𝛼 =

𝜙 ( ¯𝑃 ′, ??) {𝑄 }𝜔
𝜖
(cid:74)

∗
𝛼
(cid:75)

Given 𝑐 ∈ R, it follows by definition of

·

𝛼 that
(cid:75)
(cid:74)
𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔
𝜖
(cid:74)

𝛼 = 1(𝑧𝛼 ≤ 𝑐).
(cid:75)

Thus, 𝐸 is approximately sound for some 𝑐 ∈ R if and only if

P𝑝 (𝛼) (𝑧𝛼 ≤ 𝑐 | 𝑧∗

𝛼 ) ≥ 1 − 𝜖

if 𝜔 = |

or

P𝑝 (𝛼) (𝑧∗

𝛼 ⇒ 𝑧𝛼 ≤ 𝑐) ≥ 1 − 𝜖

if 𝜔 = ⇒ .

Given (cid:174)𝛼 = (𝛼1, ..., 𝛼𝑛), where 𝛼1, ..., 𝛼𝑛 ∼ 𝑝 i.i.d.,

(cid:40)

(cid:174)𝑧 (cid:174)𝛼 =

{𝑧𝛼 | 𝛼 ∈ (cid:174)𝛼 ∧ 𝑧∗
{𝑧∗

𝛼 }
𝛼 ⇒ 𝑧𝛼 | 𝛼 ∈ (cid:174)𝛼 }

if 𝜔 = |
if 𝜔 = ⇒

(6)

is a vector of i.i.d. samples. The estimator ˆ𝑡 ((cid:174)𝑧 (cid:174)𝛼 ) in (4) with parameters (𝜖, 𝛿/𝑚) ensures approximate
soundness with high probability—i.e.,

P𝑝 (𝛼)

(cid:0)𝑧𝛼 ≤ ˆ𝑡 ((cid:174)𝑧 (cid:174)𝛼 ) | 𝑧∗

𝛼

(cid:1) ≥ 1 − 𝜖

if 𝜔 = |

or P𝑝 (𝛼)

(cid:0)𝑧∗

𝛼 ⇒ 𝑧𝛼 ≤ ˆ𝑡 ((cid:174)𝑧 (cid:174)𝛼 )(cid:1) ≥ 1 − 𝜖

if 𝜔 = ⇒ .

holds with probability at least 1 − 𝛿/𝑚 according to 𝑝 ( (cid:174)𝛼).

, Vol. 1, No. 1, Article . Publication date: October 2021.

10

Bastani

Synthesizing 𝜖. We describe how our algorithm synthesizes a confidence level 𝜖 for an expression

𝐸 = 𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔

??. Given a single test valuation 𝛼 ∼ 𝑝, consider the values
𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔
∗
𝛼 .
??
(cid:75)
(cid:74)
𝛼 and
(cid:75)

𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔
??
(cid:74)
Note that we compute these values even though the 𝜖 is a hole, since
𝛼 do not depend on
∗
(cid:75)
𝜖. Also, note that unlike the case of synthesizing 𝑐, where 𝑧𝛼 ∈ R is a score, in this case, 𝑧𝛼 ∈ {0, 1}
is a binary value. Given 𝜖 ∈ R>0, 𝐸 is 𝜖-approximately sound for 𝜖 if and only if

𝑧∗
𝛼 =

𝑧𝛼 =

and

𝛼
(cid:75)

(cid:74)

(cid:74)

·

·

P𝑝 (𝛼) (𝑧𝛼 | 𝑧∗

𝛼 ) ≥ 1 − 𝜖

if 𝜔 = |

or

P𝑝 (𝛼) (𝑧∗

𝛼 ⇒ 𝑧𝛼 ) ≥ 1 − 𝜖

if 𝜔 = ⇒ .

Given (cid:174)𝛼 = (𝛼1, ..., 𝛼𝑛), where 𝛼1, ..., 𝛼𝑛 ∼ 𝑝 are i.i.d. samples, (cid:174)𝑧 (cid:174)𝛼 defined in (6) is a vector of i.i.d.
samples from Bernoulli(𝜇). Then, the estimator ˆ𝜈 ((cid:174)𝑧 (cid:174)𝛼 ) in (5) with parameter 𝛿/𝑚 is a lower bound
on 𝜇 with high probability—i.e.,

P𝑝 (𝛼) (𝑧𝛼 | 𝑧∗

𝛼 ) ≥ ˆ𝜈 ((cid:174)𝑧 (cid:174)𝛼 )

if 𝜔 = |

or

P𝑝 (𝛼) (𝑧∗

𝛼 ⇒ 𝑧𝛼 ) ≥ ˆ𝜈 ((cid:174)𝑧 (cid:174)𝛼 )

if 𝜔 = ⇒ .

holds with probability at least 1 − 𝛿/𝑚 according to 𝑝 ( (cid:174)𝛼). Thus, it suffices to choose 1 − 𝜖 = ˆ𝜈 ((cid:174)𝑧 (cid:174)𝛼 ).

The following guarantee follows from Theorems 4.2 & 4.4 by a union bound over Φ( ¯𝑃):

Theorem 4.7. Algorithm 1 is 𝛿-PAC.

5 SYNTHESIS ALGORITHM
We now describe a syntax-guided synthesizer that uses our sketching algorithm to identify programs
with machine learning components while satisfying a desired error guarantee. In general, to design
such a synthesizer, we need to design a space of specifications along with a domain-specific language
(DSL) of programs. For clarity, we focus on a specific set of design choices; as we discuss in Section 6,
our approach straightforwardly generalizes in several ways. We consider the following choices:
• Specifications: We consider specifications ˜𝜓 = (𝜓, 𝜖, 𝑒), consisting of both a traditional
part 𝜓 indicating the logical property that the train semantics of the program should satisfy
(provided either as a logical formula or input-output examples), and a statistical part (𝜖, 𝑒)
indicating that the program should have error at most 𝑒 with probability at least 1 − 𝜖 with
respect to 𝑝 (𝛼), or else return ∅.

• DSL: We consider a DSL (shown in Figure 2) of list processing programs where the inputs are
images of integers. Our DSL includes components designed to predict the integer represented
by a given image. These components return the predicted value if its confidence is above a
certain threshold, and return ∅ otherwise. Values ∅ are propagated as ∅ by all components
in our DSL—i.e., if any input to a function is ∅, then its output is also ∅.

For clarity, we refer to specifications ˜𝜓 as task specifications and specifications on DSL components
as component specifications. As a running example, consider the program in Figure 3. This program
predicts the value 𝑥 of the image input1 (as an integer) and values ℓ of the images in the list input2
(as real values), and then sums the values in ℓ that are greater than equal to 𝑥. It contains three
components that have component specifications: the two machine learning components predictint
and predictfloat, along with the inequality cond-≤. The first two component specifications ensure
that the corresponding machine learning model returns correctly (or ∅) with high probability. For
the last one, note that in the expression 𝑦1 ≤ 𝑦2, the inputs 𝑦1 and 𝑦2 may have a small amount of
prediction error, so if they are to close together (i.e., |𝑦1 − 𝑦2| ≤ 𝑐 for some 𝑐 ∈ R≤0), then 𝑦1 ≤ 𝑦2
might be incorrect. Thus, to ensure ≤ returns correctly, cond-≤ returns ∅ if |𝑦1 − 𝑦2| ≤ 𝑐.

Finally, note that we use 𝜔 = ⇒, indicating that our goal is to synthesize ¯𝑃 such that the the
𝛼 | > 𝑒(cid:1) ≥ 1 − 𝜖. We could use
∗
(cid:75)

overall success rate is bounded—i.e., P𝑝 (𝛼)
𝜔 = | here if we instead wanted to bound the probability of failure conditioned on

𝛼 = ∅ ∨ |
(cid:75)

𝛼 −
(cid:75)

¯𝑃
(cid:74)

¯𝑃
(cid:74)

¯𝑃
(cid:74)

(cid:0)

¯𝑃
(cid:74)

𝛼 ≠ ∅.
(cid:75)

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

11

𝑃𝜏 ::= input1

𝜏 | · · · | input𝑘𝜏
𝜏

| (𝑃𝜏′→𝜏 𝑃𝜏′ )
| (fold 𝑃𝜏′→𝜏 →𝜏 𝑃list(𝜏′) 𝑃𝜏 )

𝑃list(𝜏 ) ::= (map 𝑃𝜏′→𝜏 𝑃list(𝜏′) )

| (filter 𝑃𝜏 →bool 𝑃list(𝜏 ) )
| (slice 𝑃list(𝜏 ) 𝑃int 𝑃int)

𝑃int ::= (length 𝑃list(𝜏 ) )

𝑃𝜎→𝜎→𝜎 ::= + | −
𝑃int→int→bool ::= ≤ | = | ≥

𝑃float→float→bool ::= cond-≤ | cond-≥
𝑃image→𝜎 ::= predict𝜎
𝑃image→image ::= cond-flip

then ˆ𝑓 (𝑥) else ∅)

(predictint 𝑥) = (if ˆ𝑝 (𝑥, ˆ𝑓 (𝑥)) ≥ ??𝑐 { ˆ𝑓 (𝑥) = 𝑦∗ }⇒
??𝜖
(predictfloat 𝑥) = (if ˆ𝑝 (𝑥, ˆ𝑓 (𝑥)) ≥ ??𝑐 { | ˆ𝑓 (𝑥) − 𝑦∗ | ≤ ??𝑒 }⇒
??𝜖
(cond-flip 𝑥) = (if ˆ𝑝flip (𝑥, ˆ𝑓flip (𝑥)) ≥ ??𝑐 { ˆ𝑓flip (𝑥) = 𝑦∗
flip }⇒
??𝜖
(cond-flip0 𝑥) = (if ˆ𝑓flip (𝑥) then flip(𝑥) else 𝑥)
1 ≤ 𝑦∗
(cond-≤ 𝑦1 𝑦2) = (if |𝑦1 − 𝑦2 | ≥ ??𝑐 {𝑦∗
1 ≥ 𝑦∗
(cond-≥ 𝑦1 𝑦2) = (if |𝑦1 − 𝑦2 | ≥ ??𝑐 {𝑦∗

2 }⇒
??𝜖
2 }⇒
??𝜖

then 𝑦1 ≥ 𝑦2 else ∅)

then 𝑦1 ≥ 𝑦2 else ∅)

then ˆ𝑓 (𝑥) else ∅)

then (cond-flip0 𝑥) else ∅)

Fig. 2. This figure shows our domain-specific language (DSL) of list processing programs over images of
inputs. The top half shows the production rules; these rules are implicitly universally quantified over the type
variables 𝜏 and 𝜎, where 𝜏 ::= bool | int | float | image | list(𝜏) | 𝜏 → 𝜏 and 𝜎 ::= int | float | image. The
bottom half shows the semantics of functions in our language that have statistical specifications.

Algorithm 2 Use learning theory to synthesize ¯𝑃 that is approximately correct.

procedure Synthesize( (cid:174)𝛼,𝜓, 𝜖, 𝑒, 𝑁 , 𝛿)
˜𝑃 ← SynthesizePartialSketch(𝜓 )
(cid:174)𝛼synth, (cid:174)𝛼sketch ← Split( (cid:174)𝛼)
𝑃 ← arg max𝑃 ′ ∈FillAll( ˜𝑃,𝜖,𝑒)
return Sketch(𝑃, (cid:174)𝛼sketch, 𝛿)

Score(Sketch(𝑃 ′, (cid:174)𝛼synth, 𝛿))

end procedure

Given labeled training examples (cid:174)𝛼, a task specification ˜𝜓 , a maximum list length 𝑁 , and a
confidence level 𝛿, our algorithm shown in Algorithm 2 synthesizes a complete program ¯𝑃 that
satisfies ˜𝜓 with probability at least 1 − 𝛿. At a high level, this algorithm proceeds in three steps:
• Step 1: First, our algorithm uses the logical specification 𝜓 to identify a sketch ˜𝑃 whose
train semantics is consistent with 𝜓 . Note that the train semantics for sketches in our DSL in
Figure 2 are well-defined even when the holes left unfilled. We refer to ˜𝑃 as a partial sketch,
since it has additional holes that cannot be filled by our sketching algorithm.

• Step 2: While our algorithm uses our sketching algorithm described in Algorithm 1 to fill
holes ??𝑐 in ˜𝑃, it must first fill the holes ??𝜖 and ??𝑒 (described below), which cannot be
handled by this algorithm. To this end, it analyzes the program to identify constraints on
the values of 𝜖 and 𝑒 that can be assigned to each hole ??𝜖 and ??𝑒 , respectively and satisfy
the desired task specification (𝜖, 𝑒). Given candidate values (cid:174)𝑒 and (cid:174)𝜖, it constructs the sketch
𝑃 = Fill( ˜𝑃, (cid:174)𝜖, (cid:174)𝑒), and evaluates the success rate Score(𝑃) (i.e., how often
𝛼 ≠ ∅). It chooses
(cid:75)
the sketch 𝑃 that maximizes this objective over a finite set of choices of (cid:174)𝜖 and (cid:174)𝑒.

𝑃
(cid:74)

• Step 3: Finally, it uses a held-out set of labeled examples (cid:174)𝛼sketch in conjunction with our
sketching algorithm in Algorithm 1 to synthesize We use a held-out set since Theorem 4.7
only holds if the examples (cid:174)𝛼sketch are not used to construct the sketch 𝑃.

, Vol. 1, No. 1, Article . Publication date: October 2021.

12

Bastani

Task Specification

˜𝜓ex = (cid:0)𝜓 = { [1, 2, 3] ↦→ 3, [2, 4, 2] ↦→ 4}, 𝜖 = 0.05, 𝑒 = 6, 𝑁 = 3, 𝛿 = 0.05(cid:1)

Partial Sketch

Components
with Holes

˜𝑃ex = (fold + (filter (cond-≤
(cid:32)(cid:32)
(cid:32)(cid:32)
(cid:123)(cid:122)
(cid:125)
(cid:124)
𝑓1

(cid:32)(cid:32)(cid:32)(cid:32)

(predictint
(cid:32)(cid:32)(cid:32)(cid:32)
(cid:123)(cid:122)
(cid:125)
(cid:124)
𝑓2

input1)) (map predictfloat
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:125)

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

(cid:124)

(cid:123)(cid:122)
𝑓3

input2) 0))

𝑓1 = (𝜆𝑦1 (𝜆𝑦2 (if |𝑦1 − 𝑦2 | ≥ ??𝑐 {𝑦∗
1 ≤ 𝑦∗
𝑓2 = (𝜆𝑥 (if ˆ𝑝 (𝑥, ˆ𝑓 (𝑥)) ≥ ??𝑐 { ˆ𝑓 (𝑥) = 𝑦∗ }⇒
??𝜖
𝑓3 = (𝜆𝑥 (if ˆ𝑝 (𝑥, ˆ𝑓 (𝑥)) ≥ ??𝑐 { | ˆ𝑓 (𝑥) − 𝑦∗ | ≤ ??𝑒 }⇒
??𝜖

then 𝑦1 ≤ 𝑦2 else ∅)))

2 }⇒
??𝜖
then ˆ𝑓 (𝑥) else ∅))

then ˆ𝑓 (𝑥) else ∅))

Fig. 3. Example of a task in our list processing domain. Given ˜𝜓ex, the goal is to synthesize a program ¯𝑃 whose
𝛼 | ≤ 𝑒(cid:1) ≥ 1 − 𝜖.
∗
train semantics satisfies 𝜓 , and whose test semantics satisfy P𝑝 (𝛼)
(cid:75)

𝛼 = ∅ ∨ |
(cid:75)

𝛼 −
(cid:75)

¯𝑃
(cid:74)

¯𝑃
(cid:74)

¯𝑃
(cid:74)

(cid:0)

In Figure 3, we show the partial sketch ˜𝑃ex along with two analyses which are used to help compute
the search space over (cid:174)𝜖 and (cid:174)𝑒. Below, we describe our DSL and synthesis algorithm in more detail.

5.1 Domain-Specific Language
Our DSL is summarized in Figure 2. To be precise, this figure shows sketches in our language; filling
holes in these sketches produces a program in our language. At a high level, the language consists
of standard list processing operators such as map, filter, and fold, along with a set of functions that
can be applied to individual integers, real numbers, or images.

Machine learning components. Our DSL has three machine learning components: predictint,
predictfloat, and cond-flip. The first two predict the value in a given image. They are identical except
for their component specification; whereas the integer predictions must be exactly correct, the
real-valued predictions are allowed to have bounded error. We describe these specifications below.
This difference gives the user flexibility in terms of what kind of guarantees they want to provide.
The third machine learning component checks if the input image is flipped along the vertical
axis. We include it to demonstrate how our approach can combine multiple machine learning
components. It only returns an image if it is confident about its prediction; otherwise, it returns ∅.

Component specifications. Intuitively, there are two kinds of component specifications in our
language: (i) require that the output is exactly correct, and (ii) require that the error of the output
is bounded. There are four components in (i): predictint, cond-flip, cond-≤, and cond-≥. The first
two are straightforward—they consist of a machine learning component, and return the predicted
value if the prediction confidence is a threshold to be synthesized, and return ∅ otherwise.

The latter two are result from challenges handling inequalities on real-valued predictions. In
particular, real-valued predictions (i.e., by predictfloat) can be wrong by a bounded amount, yet the
return value of ≤ and ≥ is a Boolean value that must be exactly correct. Thus, these components
include a component specification indicating that their output must be correct with high probability.
Note that the scoring function used in the condition is |𝑦1 − 𝑦2|; intuitively, if the inputs 𝑦1 and 𝑦2
are far apart (i.e., |𝑦1 − 𝑦2| is large), then the predicted result is less likely to be an error.

The predictfloat component is the only one in (ii). The only difference from predictint is that it only
requires that the prediction is correct to within some bounded amount of error—i.e., | ˆ𝑓 (𝑥) −𝑦∗| ≤ 𝑒,
for some 𝑒 ∈ R≥0. Note that 𝑒 is left as a hole to be filled.

Holes. Our language has three kinds of holes. The first two are holes ??𝑐 and ??𝜖 ; these are in our
sketch DSL in Figure 2. Note that in that DSL, each component specification could only have either
𝑐 or 𝜖 as a hole, but here we allow both to be left as holes; our algorithm searches over choices

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

13

of 𝜖 to fill holes ??𝜖 , and uses our sketching algorithm in Algorithm 1 to fill holes ??𝑐 . The third
kind of hole is the hole ??𝑒 in the component specification | ˆ𝑓 (𝑥) − 𝑦∗| ≤ ??𝑒 for predictfloat, which
indicates the magnitude of error allowed by the prediction of that component. As with ??𝜖 holes,
the ??𝑒 holes are filled by our algorithm before our sketching algorithm is applied. Intuitively, ??𝜖
(resp., ??𝑒 ) holes must be filled in a way that satisfies the overall 𝜖 failure probability guarantee
(resp., 𝑒 error guarantee) in the user-provided task specification ˜𝜓 .

5.2 Synthesis Algorithm
Our algorithm (Algorithm 2) takes as input labeled training examples (cid:174)𝛼, a task specification
˜𝜓 = (𝜓, 𝜖, 𝑒), and 𝛿 ∈ R>0, and returns a program ¯𝑃 that satisfies ˜𝜓 with probability ≥ 1 − 𝛿.

Step 1: Syntax-guided synthesis. Our algorithm first synthesizes a partial sketch ˜𝑃 in our DSL
whose train semantics satisfies 𝜓 —i.e., UNSAT𝛼,𝑦 (cid:0)𝑦 =
∗
𝛼
is well-defined even though there are holes in ˜𝑃. We can compute ˜𝑃 using any standard synthesizer.
(cid:75)
Step 2: Sketching 𝜖 and 𝑒. Next, our algorithm fills the holes ??𝜖 in ˜𝑃 with values (cid:174)𝜖 and holes ??𝑒
with values (cid:174)𝑒 to obtain a sketch 𝑃 = Fill( ˜𝑃, (cid:174)𝜖, (cid:174)𝑒). Since 𝑃 only has holes ??𝜖 , we can use Algorithm 1
to fill these holes in a way that guarantees correctness for the given values (cid:174)𝜖 and (cid:174)𝑒—i.e.,

𝛼 ∧ ¬𝜓 (𝛼, 𝑦)(cid:1). Importantly, note that
∗
(cid:75)

˜𝑃
(cid:74)

˜𝑃
(cid:74)

¯𝑃
(cid:74)

𝛼 | ≤ 𝑒(cid:1) ≥ 1 − 𝜖,
∗
(7)
𝑃
(cid:75)
(cid:74)
where ¯𝑃 is a completion of 𝑃 where the holes ??𝑐 in 𝑃 have been filled with values (cid:174)𝑐. We need to
use ¯𝑃 since the test semantics are not well-defined for sketches 𝑃. In particular, we need to choose
values (cid:174)𝜖 and (cid:174)𝑒 that ensure that (7) holds for all possible completions ¯𝑃 of 𝑃.

𝛼 −
(cid:75)

P𝑝 (𝛼)

(cid:0)|

Furthermore, we not only want to choose (cid:174)𝜖 and (cid:174)𝑒 to ensure correctness, but also to maximize
a quantitative property of ¯𝑃. In particular, we want to choose it in a way that maximizes the
probability that 𝑃 does not return ∅—i.e., maximize the score
𝛼 ≠ ∅(cid:1)
(cid:75)

Note that the score depends critically on the choice of thresholds (cid:174)𝑐 used to fill holes ??𝑐 in 𝑃. Thus,
given a set of candidate choices (cid:174)𝜖 and (cid:174)𝑒, our algorithm constructs the corresponding sketch 𝑃 ′ =
Fill( ˜𝑃, (cid:174)𝜖, (cid:174)𝑒), uses our sketching algorithm to fill the holes ??𝑐 in 𝑃 ′ to obtain ¯𝑃 ′ = Sketch(𝑃 ′, (cid:174)𝛼, 𝛿),
and finally scores ¯𝑃 ′. Then, our algorithm chooses 𝑃 ′ with the highest score. In Algorithm 2, we let
FillAll( ˜𝑃, 𝜖, 𝑒) denote the set of all sketches 𝑃 ′ constructed from candidates (cid:174)𝜖 and (cid:174)𝑒.

Score(𝑃) = P𝑝 (𝛼)

¯𝑃
(cid:74)

(cid:0)

One important detail is that Algorithm 1 requires that 𝑃 is a straight-line program—i.e., it cannot
handle loops. For now, we assume that we are given a bound 𝑁 ∈ N on the maximum length of
any input list. Then, we can unroll list operations such as map, filter, and fold into straight-line
code. Algorithm 2 uses this strategy to apply Algorithm 1 to sketches 𝑃. We describe how we can
remove the assumption that we have an upper bound 𝑁 in Section 6.

Step 3: Sketching 𝑐. Finally, we use Algorithm 1 to choose values (cid:174)𝑐 to fill holes ??𝑐 in the highest
scoring sketch 𝑃 from the previous step, and return the result ¯𝑃 = Sketch(𝑃, (cid:174)𝛼sketch, 𝛿). Importantly,
in the previous step, 𝑃 is chosen based on a subset (cid:174)𝛼synth of the training examples (cid:174)𝛼, whereas in
this step, ¯𝑃 is constructed based on a disjoint subset (cid:174)𝛼sketch. We choose these two subsets to be of
equal size since Algorithm 1 is sensitive to the number of examples in (cid:174)𝛼. This strategy ensures that
𝑃 does not depend on the random variable (cid:174)𝛼sketch, thereby ensuring that Theorem 4.7 holds.

5.3 Search Space Over (cid:174)𝜖 and (cid:174)𝑒
Here, we describe how we choose candidates (cid:174)𝜖 and (cid:174)𝑒 in Step 2 so that the candidate sketches
𝑃 ′ = Fill( ˜𝑃, (cid:174)𝜖, (cid:174)𝑒) satisfy (7). At a high level, for (cid:174)𝜖, for each component 𝑓 of ˜𝑃 with an ??𝜖 hole,

, Vol. 1, No. 1, Article . Publication date: October 2021.

14

(cid:74)

(𝐹 𝐿)

(cid:74)
(fold 𝐹 𝐿 𝐵)

(map 𝐹 𝐿)

(cid:74)
(filter 𝐹 𝐿)

(cid:74)
(slice 𝐿 𝐼1 𝐼2)

(cid:74)

(cid:74)

(length 𝐿)

𝑓 ′

(cid:74)
input𝑖
𝜏
(cid:74)

(cid:75)

#
𝑓

𝐿
(cid:74)
(cid:75)
#
𝑓 +
(cid:75)
#
𝑓 +
(cid:75)
#
𝑓 +
𝐼1
(cid:74)

#
#
𝐹
𝑓 +
𝑓 =
(cid:75)
(cid:74)
(cid:75)
#
𝑓 = 𝑁 ·
𝐹
(cid:75)
(cid:74)
#
𝑓 = 𝑁 ·
𝐹
(cid:75)
(cid:74)
#
𝑓 = 𝑁 ·
𝐹
(cid:75)
(cid:74)
(cid:75)
#
#
𝐿
𝑓 +
𝑓 =
(cid:75)
(cid:74)
(cid:75)
#
#
𝐿
𝑓 =
𝑓
(cid:75)
(cid:75)
(cid:74)
#
𝑓 = 1(𝑓 ′ = 𝑓 )
(cid:75)
#
𝑓 = 0

(cid:75)

#
𝑓

𝐵
(cid:74)

(cid:75)

#
𝑓 +
(cid:75)
#
𝑓

𝐿
(cid:74)
𝐿
(cid:74)
𝐿
(cid:74)
(cid:75)
#
𝑓 +

(cid:75)
#
𝑓

𝐼2
(cid:74)

#
𝑓

(cid:75)

Bastani

err)𝑛 (
(cid:75)

𝐿
(cid:74)

err,
(cid:75)

𝐵
(cid:74)

(cid:75)

err)

err)
(cid:75)
𝐹
(
(cid:74)
err)
(cid:75)

(𝐹 𝐿)
(cid:74)
(fold 𝐹 𝐿 𝐵)

(cid:74)

(map 𝐹 𝐿)
(cid:74)
(filter 𝐹 𝐿)
(cid:74)
(slice 𝐿 𝐼1 𝐼2)
(length 𝐿)

(cid:74)

(cid:74)

(cid:75)

𝑛∈{0,1,...,𝑁 }
err (
𝐿
𝐹
(cid:74)
(cid:75)
err

err (
err =
𝐿
𝐹
(cid:75)
(cid:74)
(cid:74)
err = max
(cid:75)
err =
(cid:74)
(cid:75)
err =
𝐿
(cid:74)
(cid:75)
err =
𝐿
(cid:75)
(cid:74)
err = 0
(cid:75)

(cid:75)
err

(cid:75)

𝜆𝜂.𝑒𝑓
𝜆𝜂.𝜆𝜂′.𝜂 + 𝜂′
𝜆𝜂.𝜂

if 𝑓 = predictfloat
if 𝑓 ∈ {+, −}
otherwise

𝑓

(cid:74)

input𝑖
𝜏
(cid:74)

err =
(cid:75)




err = 0
(cid:75)

err for
Fig. 4. Rules Algorithm 2 uses to compute the search space over (cid:174)𝜖 (left) and (cid:174)𝑒 (right). In the rule of
fold, 𝑓 𝑛 (ℓ, 𝑏) = 𝑓 (ℓ, 𝑓 𝑛−1 (ℓ, 𝑏)) (and 𝑓 0 (ℓ, 𝑏) = 𝑏) is the function 𝑓 iterated 𝑛 times in its second argument.
(cid:75)
The definitions of 𝜂, 𝜂 ′, and 𝜂 + 𝜂 ′ in the rule for

(cid:74)

𝑓

·

err are given in Section 5.3.
(cid:75)

(cid:74)

˜𝑃
(cid:74)

(cid:75)

#
𝑓

, which is the number of times 𝑓 occurs in the unrolled version of ˜𝑃; then, we
we compute
consider (cid:174)𝜖 = (𝜖𝑓1, ..., 𝜖𝑓𝑑 ) such that (cid:205)𝑓 𝜖𝑓 ≤ 𝜖. For (cid:174)𝑒, for each component 𝑓 of ˜𝑃 with an ??𝑒 hole,
err : (cid:174)𝑒 ↦→ 𝑒 ′, which is a linear function mapping (cid:174)𝑒 to an upper bound 𝑒 ′ on the error
we compute
(cid:75)
of the output; then, we consider (cid:174)𝑒 such that

err((cid:174)𝑒) ≤ 𝑒. We provide details below.

˜𝑃
(cid:74)
˜𝑃
(cid:74)

(cid:75)

Search space over (cid:174)𝜖. First, we describe our search space over parameter values (cid:174)𝜖 used to fill holes
??𝜖 so that the overall failure rate is at most 𝜖. Note that here, (cid:174)𝜖 = (𝜖𝑓1, ..., 𝜖𝑓𝑘 ), where F ˜𝑃 = {𝑓1, ..., 𝑓𝑘 }
are subexpressions of ˜𝑃 of the form predictint, predictfloat, cond-flip, cond-≤, or cond-≥, since each
of these subexpressions contains exactly one hole of the form ??𝜖 .

Intuitively, we can ensure correctness via a union bound—i.e., if the sum of the 𝜖𝑓 is bounded by 𝜖,
then the overall failure probability is also bounded by 𝜖. The key caveat is that to apply Algorithm 1,
we need to unroll the sketch 𝑃 = Fill( ˜𝑃, (cid:174)𝜖, (cid:174)𝑒). Thus, we need to count a value 𝜖𝑓 multiple times if
the corresponding subexpression 𝑓 occurs multiple times in the unrolled version of 𝑃.

(cid:75)

𝑃
(cid:74)

In particular, the rules

#
𝑓 ′ shown in Figure 4 are designed to count the number of occurrences
of the subexpression 𝑓 ′ in the unrolled version of 𝑃. Note that in these rules, 𝑓 ′ refers to a specific
subexpression, and 1(𝑓 = 𝑓 ′) refers to whether 𝑓 is that specific subexpression; multiple uses of
the same construct (e.g., a program with two uses of predictint) are counted separately. These rules
are straightforward; for instance, when unrolling the fold operator, the expressions for the list 𝐿
and the initial value 𝐵 are included exactly once, whereas the function expression 𝐹 occurs 𝑁 times.
Then, to ensure that the failure probability is at most 𝜖, it suffices for (cid:174)𝜖 to satisfy

∑︁

𝑓 ∈ F ˜𝑃

˜𝑃
(cid:74)

(cid:75)

#
𝑓 · 𝜖𝑓 ≤ 𝜖.

(8)

Now, let ΔF ˜𝑃 = { (cid:174)𝑥 ∈ R| F ˜𝑃 | | ∀𝑓 . 0 ≤ 𝑥 𝑓 ≤ 1 ∧ (cid:205)𝑓 ∈ F ˜𝑃
given any (cid:174)𝑥 ∈ ΔF ˜𝑃
finite set of points from ΔF ˜𝑝

˜𝑃
, letting 𝜖𝑓 = 𝑥 𝑓 · 𝜖/
(cid:74)

#
𝑓

(cid:75)

, and construct the corresponding set of values (cid:174)𝜖.

𝑥 𝑓 = 1} be the regular simplex in R | F ˜𝑃 |. Now,
, then (8) is satisfied. In our algorithm, we search over a

In Figure 6, the rule for filter applies 𝑓1 =cond-≤ and 𝑓2 = predictint each 𝑁 = 3 times (where
= 3. Similarly, map applies
= 3. As an example of a point in our search space,

𝑁 is the given bound on the list length), so we have
𝑓3 = predictfloat a total of 𝑁 = 3 times, so
taking (cid:174)𝑥 = (1/3, 1/3, 1/3) yields (cid:174)𝜖 = (1/9, 1/9, 1/9).

˜𝑃ex
(cid:74)

˜𝑃ex
(cid:74)

˜𝑃ex
(cid:74)

#
𝑓2

#
𝑓1

#
𝑓1

=

(cid:75)

(cid:75)

(cid:75)

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

15

Search space over (cid:174)𝑒. Next, we describe our search space over parameter values (cid:174)𝑒 used to fill holes
??𝑒 so the overall error is at most 𝑒. Similar to before, (cid:174)𝑒 = (𝑒𝑓1, ..., 𝑒𝑓ℎ ), but this time G ˜𝑃 = {𝑓1, ..., 𝑓ℎ }
are subexpressions of ˜𝑃 of the form predictfloat, which each contain exactly one hole of the form
??𝑒 . In this case, we define an analysis that bounds the overall error of the output of ¯𝑃 = Fill(𝑃, (cid:174)𝜖, (cid:174)𝑒)
for any (cid:174)𝜖 as a function of (cid:174)𝑒. More precisely,
Fill(𝑃, (cid:174)𝜖, (cid:174)𝑒)
(cid:74)

𝑃
(cid:74)
for all (cid:174)𝜖 and (cid:174)𝑒, and for all 𝛼 such that all component specifications in Fill(𝑃, (cid:174)𝜖, (cid:174)𝑒 hold for (cid:174)𝛼. In other
words, (9) bounds the error of the output for examples 𝛼 such that predictions fall within the desired
error bounds (failures happen with probability at most 𝜖 according to our choices of (cid:174)𝜖).

err satisfies the following property:
err ((cid:174)𝑒)

𝑃
(cid:74)
(cid:75)
𝛼 −
(cid:75)

(cid:13)
(cid:13)∞ ≤

𝑃
(cid:74)

∗
𝛼
(cid:75)

(9)

(cid:13)
(cid:13)

(cid:75)

Note that (9) uses the 𝐿∞ norm. For scalar outputs, we have ∥𝑥 − 𝑥 ′∥∞ = |𝑥 − 𝑥 ′|. For list outputs,
for the 𝐿∞ norm to be well-defined, we need to ensure that 𝑥 =
𝛼 are of
∗
(cid:75)
the same length (at least, when all component specifications are satisfied). In particular, the only
potential case where 𝑥 and 𝑥 ′ have unequal lengths is if ¯𝑃 contains a filter operator. We focus on
filtering real-valued lists; filtering integer-valued lists is similar (and there are no operations to
filter list-valued lists or image-valued lists). In the real-valued case, the filter function must be either
cond-≤ and cond-≥. Assuming the component specifications on cond-≤ and cond-≥ are satisfied,
then their (Boolean) outputs are guaranteed to be equal, so the outputs of the filter operator have
equal length under train and test semantics. Thus, ∥𝑥 − 𝑥 ′∥∞ is well-defined.

𝛼 and 𝑥 ′ =
(cid:75)

Fill(𝑃, (cid:174)𝜖, (cid:174)𝑒)

¯𝑃
(cid:74)

(cid:74)

Given

𝑃
(cid:74)

err, our goal is to compute (cid:174)𝑒 satisfying
(cid:75)

err((cid:174)𝑒) ≤ 𝑒.

𝑃
(cid:74)

(cid:75)

(cid:75)

(cid:75)

˜𝑃
(cid:74)

𝑎𝑓 · 𝑒𝑓 . In Figure 3, we have
𝑃
(cid:74)

As with (cid:174)𝜖, we can construct a candidate (cid:174)𝑒 for any point in 𝑥 ∈ ΔG ˜𝑃
by taking 𝑒𝑓 = 𝑥 𝑓 · 𝑒/𝑎𝑓 , where
˜𝑃
err = 3 · 𝑒𝑓3, so there is a single candidate 𝑒𝑓3 = 𝑒/3.
err = (cid:205)𝑓 ∈ G ˜𝑃
(cid:74)
(cid:75)
err, which are shown in Figure 4 (right). They compute an symbolic
Next, we describe the rules
expression of the form 𝜂 = (cid:205)𝑓 ∈ G ˜𝑃
𝑎𝑓 · 𝑒𝑓 ∈ E ˜𝑃 , where 𝑎𝑓 ∈ R≥0 and 𝑒𝑓 is a symbol. Given (cid:174)𝑒, an
expression 𝜂 can be evaluated by substituting (cid:174)𝑒 for the symbols 𝑒𝑓 in 𝜂. Now, the rule for function
err is the
application assumes given a function abstraction
identity function except for predictfloat, +, and −. The case predictfloat follows since we have assumed
that the component specification holes, and the component specification for 𝑓 = predictfloat says
¯𝑓
𝑎𝑓 ·𝑒𝑓 and
exactly that |
𝛼 −
(cid:74)
(cid:75)
𝜂 ′ = (cid:205)𝑓 ∈ G ˜𝑃
𝑓 · 𝑒𝑓 , we define 𝜂 + 𝜂 ′ = (cid:205)𝑓 ∈ G ˜𝑃
𝑓 ) · 𝑒𝑓 . The rule for map follows since we are
(𝑎𝑓 + 𝑎′
𝑎′
using the 𝐿∞ norm, so the bound is applied elementwise. The remaining rules are straightforward.
In Figure 3, the rule for predictfloat returns 𝑒𝑓3, so the rule for map returns 3 · 𝑒𝑓3 (since the given
err = 3 · 𝑒𝑓3 .

𝛼 | ≤ 𝑒𝑓 for any completion ¯𝑓 of 𝑓 . For + and −, letting 𝜂 = (cid:205)𝑓 ∈ G ˜𝑃
∗
(cid:75)

bound on the list length is 𝑁 = 3). The remaining rules propagate this value, so

err : E ˜𝑃 → E ˜𝑃 . In particular,
(cid:75)

𝐹

𝐹

(cid:75)

(cid:74)

(cid:74)

(cid:74)

𝑓

err is a linear function follows by structural induction. Additional compo-

(cid:75)

Finally, the fact that

·

˜𝑃ex
(cid:74)

nents (e.g., multiplication) can result in nonlinear expressions, but a similar approach applies.

(cid:74)

(cid:75)

Overall search space. Our overall search space consists of pairs (cid:174)𝜖 and (cid:174)𝑒 such that (cid:174)𝜖 satisfies (8)
and (cid:174)𝑒 satisfies (10); given such a pair, FillAll( ˜𝑃, 𝜖, 𝑒) includes the program 𝑃 = Fill( ˜𝑃, (cid:174)𝜖, (cid:174)𝑒). Together,
(8) and (10) ensure the desired property (7). In particular, for any completion ¯𝑃 of 𝑃, (10) ensures
that |
𝛼 | ≤ 𝑒 as long as 𝛼 satisfies all the component specifications, and (8) ensures that 𝛼
∗
(cid:75)
satisfies the component specifications with probability at least 1 − 𝜖 over 𝑝 (𝛼).

𝛼 −
(cid:75)

¯𝑃
(cid:74)

𝑃
(cid:74)

6 DISCUSSION

Generality. In Section 5, we described a synthesizer tailored to the language in Figure 2. Our
approach generalizes straightforwardly in several ways. First, we note that the predictint and
predictfloat machine learning components are not specific to images of integers, and represent

, Vol. 1, No. 1, Article . Publication date: October 2021.

(10)

16

Bastani

general classification and regression problems, respectively. Furthermore, we can also include
err.
additional list processing components as long as we provide the abstract semantics
Thus, our algorithm can be viewed as a general algorithm for synthesizing list processing programs
with DNNs for classification and regression, where the specification is that with high probability,
the program should return the either the correct answer (within some given error tolerance) or ∅.
We can also modify the specification in certain ways; for instance, we can ignore certain kinds
of errors by modifying the annotations on predictint and predictfloat. For instance, to allow for
one-sided errors in regression problems (e.g., it is fine to say “person” when there isn’t one but
not vice versa), we can simply drop the absolute values from the task specification 𝜓 and from the
annotations on predictfloat. For this case, the algorithm for allocating errors 𝑒 works as is, but in
general, it may need to be modified to ensure the annotations imply the specification.

# and

(cid:75)

(cid:74)

(cid:74)

(cid:75)

·

·

Bound on examples. In Section 5, we assumed given a bound 𝑁 on the maximum length of any list
observed during program execution. Intuitively, we can circumvent this assumption by computing
a high probability bound 𝑁 ; the error probability can be included in the user-provided allowable
𝛼 denote the maximum list length observed while executing ˜𝑃 on
error rate 𝜖. In particular, let
(cid:75)
input 𝛼. Then, suppose we can obtain 𝑁 such that

˜𝑃
(cid:74)

len

P𝑝 (𝛼)

(cid:0)

˜𝑃
(cid:74)

len
𝛼 ≤ 𝑁 ) ≥ 1 −
(cid:75)

𝜖
2

.

Now, if we synthesize a completion ¯𝑃 of ˜𝑃 with overall error rate ≤ 𝜖/2, then by a union bound,
the total error rate is ≤ 𝜖. Finally, to obtain such an 𝑁 , we can use the specification
len
𝛼 ≤?? {true}⇒
𝜖/2.
(cid:75)
len
𝛼 ≤ 𝑐 with
Letting 𝑐 be the synthesized value used to fill the hole, the specification says that
(cid:75)
probability at least 𝜖/2 according to 𝑝 (𝛼), which is exactly the desired condition on 𝑁 ; thus, we
can take 𝑁 = 𝑐. Note that since the specification is true, we can use either | or ⇒.

˜𝑃
(cid:74)

˜𝑃
(cid:74)

7 EVALUATION
We describe our evaluation on synthesizing list processing programs, as well as on two case studies:
(i) a state-of-the-art image classifier, and (ii) a random forest trained to predict Warfarin drug
dosage. In addition, we describe an extension of (i) to object detection in Appendix C.

7.1 Synthesizing List Processing Programs with Image Classification

Experimental setup. We evaluate our synthesis algorithm on our list processing domain in
Section 5. Inputs are lists of MNIST digits [42]. We use a convolutional DNN (two convolutional
layers followed by two fully connected layers, with ReLU activations) [41] to predict the integer in
an image, trained on the MNIST training set; it achieves 99.2% accuracy. We also train a single layer
DNN, which is 4.04× faster but only 98.5% accurate. Finally, for inputs with the flip component,
with consider input images flipped along their horizontal axis. We train a DNN to predict whether
a given image is flipped; it achieves 99.6% accuracy.

For the synthesizer, we use a standard enumerative synthesizer that returns the smallest program
in terms of depth (but chooses arbitrarily among equal depth programs). We give it 5 labeled input-
output examples as a specification 𝜓 , along with the type of the function to be synthesized [23, 50].
For the search space over each (cid:174)𝜖 and (cid:174)𝑒, we consider values (cid:174)𝑥0 ∈ {1, 3, 5}𝑑 , where 𝑑 = |F ˜𝑃 | or
𝑑 = |G ˜𝑃 |, and then take (cid:174)𝑥 = (cid:174)𝑥0/∥ (cid:174)𝑥0∥1 to normalize it to Δ𝑑 . We also compare to (i) a baseline
“No Search”, which only considers a single (cid:174)𝑥0 = (1, ..., 1), and (ii) a baseline “𝑘 = 0”, which uses
a variant of our generalization bound that uses either 𝑘 = 0 (or 𝑘 = ∅, if there are insufficient
samples); this strategy captures the guarantees provided by traditional generalization bounds from

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

17

DSL Variant

Task

StatCoder

∅ Rate

No Search

Failure Rate

StatCoder

No Search

int

sum 𝑥 ∈ ℓ
max 𝑥 ∈ ℓ
sum 𝑥 ∈ ℓ that are ≤ 𝑘
max first 𝑘 elements 𝑥 ∈ ℓ
count 𝑥 ∈ ℓ that are ≤ 𝑘

average

–

float

sum 𝑥 ∈ ℓ
max 𝑥 ∈ ℓ
sum 𝑥 ∈ ℓ that are ≤ 𝑘
max first 𝑘 elements 𝑥 ∈ ℓ
count 𝑥 ∈ ℓ that are ≤ 𝑘

average

–

flip

sum 𝑥 ∈ ℓ
max 𝑥 ∈ ℓ
sum 𝑥 ∈ ℓ that are ≤ 𝑘
max first 𝑘 elements 𝑥 ∈ ℓ
count 𝑥 ∈ ℓ that are ≤ 𝑘

average

–

fast

average

overall

sum 𝑥 ∈ ℓ
max 𝑥 ∈ ℓ
sum 𝑥 ∈ ℓ that are ≤ 𝑘
max first 𝑘 elements 𝑥 ∈ ℓ
count 𝑥 ∈ ℓ that are ≤ 𝑘

–

–

0.000
0.000
0.001
0.000
0.001

0.000

0.000
0.000
0.000
0.000
0.000

0.000

0.015
0.015
0.025
0.063
0.025

0.029

0.033
0.033
0.039
0.035
0.039

0.036

0.016

𝑘 = 0

0.177
0.177
0.206
0.195
0.206

0.000
0.000
0.022
0.008
0.022

0.010

0.192

0.000
0.000
1.000
0.005
1.000

0.000
0.000
1.000
0.177
1.000

0.401

0.435

0.016
0.016
0.085
0.046
0.085

0.230
0.230
0.265
0.258
0.265

0.050

0.250

0.033
0.033
0.127
0.061
0.127

0.706
0.706
0.755
1.000
0.755

0.076

0.784

0.134

0.415

𝑘 = 0

0.001
0.001
0.001
0.000
0.000

0.018
0.008
0.010
0.007
0.000

0.009

0.001

0.001
0.000
0.000
0.000
0.000

0.001
0.000
0.000
0.000
0.000

0.000

0.000

0.012
0.006
0.004
0.004
0.000

0.001
0.001
0.001
0.000
0.000

0.005

0.001

0.026
0.008
0.005
0.007
0.000

0.000
0.000
0.000
0.000
0.000

0.009

0.000

0.006

0.000

0.018
0.008
0.016
0.007
0.000

0.010

0.001
0.000
0.010
0.000
0.000

0.002

0.012
0.006
0.012
0.005
0.000

0.007

0.026
0.008
0.023
0.010
0.000

0.013

0.008

Table 1. We show results on synthesizing list processing programs, for both our approach (StatCoder) and
the baseline that does not search over (cid:174)𝜖 and (cid:174)𝑒 (“No Search”). For each DSL variant and each task, we show
the “∅ Rate” P𝑝 (𝛼) (

¯𝑃
(cid:74)

𝛼 ≠ ∅ ∧ |
(cid:75)

¯𝑃
(cid:74)

𝛼 −
(cid:75)

¯𝑃
(cid:74)

∗
𝛼 = ∅|) > 𝑒.
(cid:75)

𝛼 = ∅), and the “Failure Rate” P𝑝 (𝛼) (
(cid:75)

¯𝑃
(cid:74)

statistical learning theory [28, 34, 71]. We use our algorithm with parameters 𝜖 = 𝛿 = 0.05, 𝑒 = 6,
and 𝑁 = 3. We use 2500 MNIST test set images for each 𝛼synth and 𝛼sketch, and the remaining 5000
for evaluation. Next, we consider four variants of our DSL:

• Int: Restrict to components with integer type and omit the cond-flip component
• Float: Same as “int”, but include components with real types
• Flip: Same as “int”, but include the flip component
• Fast: Same as “int”, but use the fast neural network.

For each variant, we consider five list processing tasks, which are designed to exercise different
kinds of components. These programs all take as input a list ℓ of images 𝑥 ∈ ℓ; in addition, several
of them take as input a second image 𝑘 that encodes some information relevant to task. Then, they
output an integer or real value (as specified by 𝜓 ). The tasks are shared across the different DSL
variants, but specific programs change based on the available components.

Results. We show results in Table 1. For the program ¯𝑃 synthesized using each our approach

StatCoder and our baseline that does not search over (cid:174)𝜖 and (cid:174)𝑒, we show the following metrics:

• ∅ Rate: The rate at which ¯𝑃 returns ∅—i.e., P𝑝 (𝛼) (
• Failure Rate: The rate at which ¯𝑃 makes mistakes—i.e.,
(cid:0)

¯𝑃
(cid:74)

𝛼 = ∅).
(cid:75)

P𝑝 (𝛼)

¯𝑃
(cid:74)

𝛼 ≠ ∅ ∧ |
(cid:75)

¯𝑃
(cid:74)

𝛼 −
(cid:75)

¯𝑃
(cid:74)

𝛼 = ∅|(cid:1) > 𝑒.
∗
(cid:75)

, Vol. 1, No. 1, Article . Publication date: October 2021.

18

Bastani

(a)

(b)

(c)

Fig. 5. For list processing programs, we show ∅ rate (black) and failure rate (red) as a function of (a) 𝜖, (b) 𝛿,
and (c) 𝑒, on average for (a,b) “Int” programs and (c) “Float” programs. Defaults are 𝜖 = 𝛿 = 0.05 and 𝑒 = 6.0.

Task

StatCoder

∅ Rate

No Search

Failure Rate

StatCoder

No Search

count the number of people in 𝑥
check if 𝑥 contains a person
count people near the center of 𝑥
find people near a car
minimum distance from a person to the center of 𝑥

average

0.054
0.054
0.290
0.901
0.149

0.290

𝑘 = 0

0.901
0.901
0.901
1.000
0.901

0.054
0.054
0.290
0.901
0.149

𝑘 = 0

0.003
0.003
0.003
0.000
0.000

0.124
0.124
0.032
0.003
0.023

0.124
0.124
0.032
0.003
0.023

0.061

0.290

0.921

0.061

0.002

Table 2. We show results on synthesizing list processing programs over object detection, for our approach
StatCoder. For each DSL variant and each task, we show the “∅ Rate” P𝑝 (𝛼) (
𝛼 = ∅), and the “Failure
(cid:75)
Rate” P𝑝 (𝛼) (

∗
𝛼 = ∅|) > 𝑒. Parameters are 𝜖 = 𝛿 = 0.2 and 𝑒 = 20.0.
(cid:75)

𝛼 ≠ ∅ ∧ |
(cid:75)

𝛼 −
(cid:75)

¯𝑃
(cid:74)

¯𝑃
(cid:74)

¯𝑃
(cid:74)

¯𝑃
(cid:74)

As can be seen, both StatCoder and the baseline always achieve the desired failure rate bound of
𝜖 = 0.05. Furthermore, by searching over candidates (cid:174)𝜖 and (cid:174)𝑒, StatCoder substantially outperforms
the baseline, achieving an 8× reduction in ∅ rate on average. For simpler programs (i.e., sum and
max), the two perform similarly since there is only a single hole, so the search space only contains
one candidate. However, for larger programs, the search improves performance by up to an order of
magnitude. There is a single case where the baseline performs better (the fourth program in the “flip”
DSL), due to random chance since the dataset 𝛼sketch used to synthesize the final program ¯𝑃 from ˜𝑃
differs from the dataset 𝛼synth used to choose (cid:174)𝜖 and (cid:174)𝑒. StatCoder outperforms the “𝑘 = 0” baseline
by an even larger margin, due to the fact that the generalization bound is overly conservative;
these results demonstrate the importance of using a generalization bound specialized to our setting
rather than a more traditional generalization bound that minimizes the empirical risk.

Next, in Figure 5, we show how these results vary as a function of the specification parameters 𝜖,
𝛿, and 𝑒. As can be seen, 𝜖 has the largest effect on ∅ and failure rates, followed by 𝑒; as expected, 𝛿
has almost no effect since the dependence of our bound on 𝛿 is logarithmic.

Finally, we note that the failure rates for the “fast” DSL are very low. Thus, we could use our
technique to chain together the fast program with the slow one, along the same lines as discussed
in our case study in Section 7.3; we estimate that doing so results in a 3× speedup on average.

7.2 Synthesizing List Processing Programs with Object Detection

Experimental setup. Next, we consider synthesizing programs that operate over the predictions
made by a state-of-the-art DNN for object detection. We assume given a DNN component ˆ𝑓 that
given an image 𝑥, is designed to detect people and cars in 𝑥. We use a pretrained state-of-the-art
object detector called Faster R-CNN [56] available in PyTorch [53], tailored to the COCO dataset [45],

, Vol. 1, No. 1, Article . Publication date: October 2021.

0.0000.0010.0020.00300.0050.010.0150.050.10.150.2failure rate∅rate𝜀0.0000.0010.0020.0030.0000.0050.0100.0150.050.10.150.2failure rate∅rate𝛿0.0000.0010.0020.0030.0000.0050.0100.0153.06.09.012.0failure rate∅rateeSynthesizing Machine Learning Programs

19

which is a dataset of real-world images containing people, cars, and other objects. There are multiple
variants of Faster R-CNN; we use the most accurate one, X101-FPN with 3× learning rate schedule.
We represent this DNN as a component ˆ𝑓 : X → Y = D∗ × R, where ˆ𝑓 (𝑥) = ( ˆ𝑦 (𝑥), ˆ𝑝 (𝑥))
consists of a list of detections 𝑑 ∈ ˆ𝑦 (𝑥) along with a correctness score ˆ𝑝 (𝑥) that the prediction is
correct. Each detection 𝑑 ∈ D = R2 × Z is itself a tuple 𝑑 = (𝑏, 𝑧) including the position 𝑏 and
predicted category of the object. The ground truth label 𝑦∗ for an image 𝑥 is a list of detections
𝑑 ∈ 𝑦∗. In general, we cannot expect to get a perfect match between the predicted bounding boxes
and the ground truth ones. Typically, two detections 𝑑, 𝑑 ∗ match, denoted ∥𝑑 − 𝑑 ∗∥ ≤ 𝑒, where 𝑒 is a
specified error tolerance, if the distance between their centers satisfies ∥𝑏 − 𝑏∗∥∞ ≤ 𝑒. Furthermore,
we write ∥ ˆ𝑦 (𝑥) − 𝑦∗∥ ≤ 𝑒 if | ˆ𝑦 (𝑥)| = |𝑦∗| and there exists a one-to-one correspondence between
𝑑 ∈ ˆ𝑓 (𝑥) and 𝑑 ∗ ∈ 𝑦∗ such that ∥𝑑 − 𝑑 ∗ ∥ ≤ 𝑒. Then, we define predict : X → (Y ∪ ∅) by

(predict 𝑥) = (if ˆ𝑝 (𝑥) ≥??𝑐 {∥ ˆ𝑦 (𝑥) − 𝑦∗ ∥ ≤??𝑒 }⇒
??𝜖

then ˆ𝑦 (𝑥) else ∅).

In other words, the specification says that a correct prediction is if the error tolerance is below a
level ??𝑒 to be specified. Thus, given 𝑒 and 𝜖 to fill ??𝑒 and ??𝜖 , respectively, our sketching algorithm
synthesizes a threshold 𝑐 to fill ??𝑐 in a way that guarantees that this specification holds. Then,
predict returns ˆ𝑦 (𝑥) if the DNN is sufficiently confident in its prediction, and ∅ otherwise.

We can use this component in conjunction with our synthesis algorithm in the same way that it

uses predictfloat. In particular, we define the abstract semantics
err = 𝜆𝜂.𝑒predict.

(predict 𝑥)

(cid:74)

(cid:75)

These semantics enable it to select the error tolerance 𝑒 to fill ??𝑒 . The remainder of the synthesis
algorithm proceeds as in Section 7.1. We use parameters 𝜖 = 𝛿 = 0.2, 𝑒 = 20.0, and 𝑁 = 3, and
use 𝑛 = 1000 COCO validation set images for each 𝛼synth and 𝛼sketch and the remaining 1503 for
evaluation. We use larger 𝜖 and 𝛿 since the accuracy of the object detector is significantly lower
than that of the image classifier, so the ∅ rates are very high for smaller choices.

(cid:75)

𝐿′
(cid:74)

We evaluate our approach on synthesizing five programs, which include additional list processing
and
, (ii) (compose 𝑓 𝑓 ′), which returns the composition 𝜆𝑥 .𝑓 (𝑓 ′(𝑥)), (iii) (is𝑧′ 𝐷), which
= (𝑏, 𝑧) is a detection and 𝑧 ′ ∈ Z is an object category, and (iv)
= (𝑏, 𝑧) and
𝐷
#, they each evaluate each of
(cid:74)

components: (i) (product 𝐿 𝐿′), which returns the list of all pairs (𝑥, 𝑥 ′) such that 𝑥 ∈
𝑥 ′ ∈
returns 1(𝑧 = 𝑧 ′), where
(distance 𝐷 𝐷 ′), which returns the distance ∥𝑏 − 𝑏 ′∥∞ between two detections
𝐷 ′
(cid:74)
their arguments once, and for

= (𝑏 ′, 𝑧 ′). Their abstract semantics are straightforward: for

err, the only one that propagates errors is distance, for which
(cid:75)

𝐷
(cid:74)

𝐿
(cid:74)

(cid:75)

(cid:75)

(cid:75)

(cid:74)

(cid:75)

(cid:75)

·

·
(cid:74)
(distance 𝐷 𝐷 ′)

(cid:74)

err =
(cid:75)

𝐷
(cid:74)

err +
(cid:75)

𝐷 ′
(cid:74)

(cid:75)

err.

Results. We provide results in Table 2. The trends are similar to Section 7.1; the main difference
is that search does not help in this case, likely because there is only a single machine learning
component so optimizing the allocation does not significantly affect performance. Finally, we can
chain these programs with a faster object detector to reduce running time; see Appendix C.

7.3 Case Study 1: ImageNet Image Classification

Correctness. Consider program shown in Figure 6, which classifies images as “person” (returns
true) or “not person” (returns false). The function is_person takes as input an image 𝑥, and
optionally the ground truth label 𝑦∗ (which is only used during sketching). The specification in
is_person says that the program should return true with high probability if the image is of a
person (i.e., 𝑦∗ = 1). The predicate 1(1 − 𝑓 (𝑥) ≤ 𝑐) is shown in blue, where the value of 𝑐 has been
left as a hole ??1, the specification 𝑦∗ = 1 is shown in green in the curly braces, and the value
𝜖 = 0.05 is shown in green in the square braces. We perform a case study in the context of this

, Vol. 1, No. 1, Article . Publication date: October 2021.

20

Bastani

def is_person(x, y_true=None):

if 1.0 - f(x) <= ??1 {y_true} [|, 0.05]:

return True

else:

return False

def is_person_fast(x):

def monitor_correctness(x):

if np.random.uniform() <= 0.99:

return

passert 1.0 - f_fast(x) <= ??2 {is_person(x)} [|, 0.05]

if 1.0 - f_fast(x) <= ??2 {is_person(x)} [|, 0.05]:

def monitor_speed(x):

return is_person(x)

else:

return False

passert 1.0 - f_fast(x) > ??2 {true} [|, ??3]

Fig. 6. A program used to predict whether an image 𝑥 contains a person. Specifications are shown in green;
curly brackets is the specification and square brackets is the value of 𝜖. The corresponding inequality with a
hole in blue. Holes with the same number are filled with the same value.

program (though for labels other than “person”). We consider the ImageNet dataset [18], a large
image classification benchmark with over one million images in 1000 categories, including various
different animals and inanimate objects. We consider the ResNet-152 DNN architecture [29], a
state-of-the-art image classification model trained on ImageNet that achieves about 88% accuracy
overall. For both architectures, we use the implementation in PyTorch [53].

To use our system, we split the ImageNet validation set consisting of 50,000 held-out images into
(at most) 25,000 for synthesis (i.e., the synthesis set) and 25,000 for validation. Because ImageNet has
so many labels, each object category has very few examples in the validation dataset (50 on average).
Thus, we group the labels into larger, coarse-grained categories, focusing on ones that correspond
to many fine-grained ImageNet labels. We consider “dog” (130 labels, 6,500 images) “bird” (59
labels, 2,950 images), “insect” (27 labels, 1,350 images), “car” (21 labels, 1050 images), “snake” (17
labels, 850 images), and “cat” (13 labels, 650 images). The default one we use is “car”; this category
contains vehicles such as passenger cars, bikes, busses, trolleys, etc. For the scoring function, given
a coarse-grained category 𝑌 ⊆ Y, we use the sum of the fine-grained label probabilities—i.e.,
𝑓 (𝑥) = (cid:205)𝑦 ∈𝑌 𝑝 (𝑥, 𝑦), where 𝑝 (𝑥, 𝑦) is the predicted probability of label 𝑦 according to ResNet-152.
Then, we use our sketching algorithm to synthesize 𝑐 to fill ??1. We show results in the first
and fourth rows of Figure 7. Note that the red curves ideally equal the blue curves, but are slightly
conservative to account for synthesis being based on finitely many samples. The value of 𝜖 has the
biggest effect on performance, since it directly governs recall; as 𝜖 grows, recall drops (as desired)
and precision substantially improves. In contrast, the performance does not vary significantly with
𝛿. These trends match sample complexity guarantees from learning theory relevant to our setting
of 𝑛 = 𝑂 (log(1/𝛿)/𝜖) [34, 71]. Next, as 𝑛 grows larger, recall can more closely match the desired
maximum, allowing precision to improve dramatically (the non-monotone effect is most likely due
to random chance). Finally, the dependence on the target label is also governed by the number of
synthesis images in each category.

Improving speed. Next, we describe how our framework can be used to compose 𝑓 with a second
DNN 𝑓fast, which is much faster than 𝑓 but has lower accuracy. Intuitively, we want to use 𝑓fast
when we can guarantee its prediction is correct with high probability, and use 𝑓 otherwise. This
approach has been used to reduce running time [13, 67]; our framework can be used to do so while
providing rigorous accuracy guarantees.

The code for this approach is shown in is_person_fast in Figure 6. As before, the idea is to
compute a threshold 𝑐 ′ such that the prediction 𝑓fast (𝑥) ≥ 1 − 𝑐 ′ is correct with high probability.
There are two differences. First, if we conclude that there might be a person in the image according
to 𝑓fast, then we return the prediction according to 𝑓 (instead of true). While 𝑓fast is guaranteed
to detect 95% images with people with high probability, it may have more false positives than 𝑓 ;
calling 𝑓 after 𝑓fast reduces these false positives. Second, the correctness guarantee is with respect

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

21

(c)

(f)

(i)

(a)

(d)

(g)

(b)

(e)

(h)

(j)

Fig. 7. For ResNet alone, we show the recall (red), desired lower bound on the recall (blue), and precision
(black) as a function of (a) 𝜖, (b) 𝛿, (c) 𝑦 ∈ Y, and (j) the number of synthesis examples 𝑛; the defaults are
𝜖 = 𝛿 = 0.05, 𝑛 = 25, 000, and 𝑦 = “car”, except in (c) we use 𝜖 = 0.1 to facilitate the comparison with (f). We
show the same values for ResNet+AlexNet as a function of (d) 𝜖, (e) 𝛿, and (f) 𝑦 ∈ Y. For ResNet+AlexNet
(black) compared to AlexNet alone (green), we show the running time as a function of (g) 𝜖, (h) 𝛿, and (i)
𝑦 ∈ Y; we omit ResNet alone since its running time (82.6 minutes) is significantly above the scale.

to the prediction ˆ𝑦 = 1(𝑓 (𝑥) ≥ 1 − 𝑐) rather than 𝑦∗. We could use 𝑦∗, but there is no need—if ˆ𝑦 is
incorrect, then it is not helpful for 𝑓fast to predict correctly since it falls back on ˆ𝑦.

For 𝑓fast, we use AlexNet, which achieves about 57% accuracy overall; in particular, we use
𝑓fast (𝑥) = (cid:205)𝑦 ∈𝑌 𝑝fast (𝑥, 𝑦), where 𝑝fast (𝑥, 𝑦) is the predicted probability of label 𝑦 according to
AlexNet. Then, we conclude that 𝑥 (may) have label 𝑦 if 𝑓fast (𝑥) ≥ 1 − 𝑐 ′, where 𝑐 ′ is synthesized
by our algorithm. We obtain results on an Nvidia GeForce RTX 2080 Ti GPU. We show results
on the second and third rows of Figure 7. All results shown are for the combined predictions (i.e.,
using both AlexNet and ResNet), and are estimated on the validation set. For running time, we omit

, Vol. 1, No. 1, Article . Publication date: October 2021.

0.600.700.800.901.000.050.10.150.2Precision/Recall𝜀0.600.700.800.901.000.050.10.150.2Precision/Recall𝛿0.500.600.700.800.901.00DogBirdInsectCarSnakeCatPrecision/Recall0.600.700.800.901.000.050.10.150.2Precision/Recall𝜀0.600.700.800.901.000.050.10.150.2Precision/Recall𝛿0.500.600.700.800.901.00DogBirdInsectCarSnakeCatPrecision/Recall0510150.050.10.150.2Time (Minutes)𝜀0510150.050.10.150.2Time (Minutes)𝛿05101520DogBirdInsectCarSnakeCatTime (Minutes)0.200.400.600.801.00500010000150002000025000Precision/Recalln22

Bastani

results for ResNet since its running time is 82.6 minutes, which is more than 4× the running time
of our combined model. For the “dog” category, our approach reduces running time 6× from 82.6
minutes to 13.8 minutes without any sacrifice in precision or recall.

Thus, our approach significantly reduces running time while achieving the desired error rate.
Furthermore, comparing to Figure 7 (d), the precision does not significantly decrease across most
labels. It does suffer for the labels “car” and “snake”. Intuitively, for these labels, there are relatively
few examples in the synthesis set, so the synthesis algorithm needs to choose more conservative
thresholds. Since the fast program has two thresholds whereas the original program only has one,
it is more conservative in the latter case. This difference is reflected in the fact that Figure 7 (e) has
higher recall than (d), especially for “car” and “snake”.

Importantly, these results rely on the fact that we are tailoring our predictions to a single
category—i.e., our system enables the user to tailor the predictions of pretrained DNN models such
as ResNet and AlexNet to their desired task. For instance, it can focus on predicting cars rather
than achieving good performance on all 1000 ImageNet categories.

Runtime monitoring. As described in Appendix A.3, our framework can monitor the synthesized
program at runtime, which is useful since PAC guarantees are specific to the data distribution
𝑝 (𝑥, 𝑦∗). Thus, if the program is executed on data from a different distribution, called distribution
shift [12, 55], then our guarantees may not hold. Monitoring requires us to obtain ground truth
labels 𝑦∗ for inputs 𝑥 encountered at run time; then, we use these ground truth labels to estimate
the failure rate of the model and ensure it is below the desired value 𝜖.

We show how we can monitor the correctness of is_person_fast. In this case, we can easily ob-
tain ground truth labels since the specification for ??2 can be obtained by evaluating 𝑓 (𝑥). We want
to avoid running 𝑓 on every input since this would defeat the purpose of using a fast DNN; instead,
we might run it once every 𝑁 iterations for some large 𝑁 . The function monitor_correctness
implements this check, generating a ground truth label once every 𝑁 = 100 iterations on average.
Note that we formulate the check as a probabilistic assertion [60]—i.e.,

which has the semantics

passert 1 − 𝑓fast (𝑥) ≤ 𝑐 ′ {1 − 𝑓 (𝑥) ≤ 𝑐} |

0.05,

P𝑝 (𝑥,𝑦∗)

(cid:0)1 − 𝑓fast (𝑥) ≤ 𝑐 ′ | 1 − 𝑓 (𝑥) ≤ 𝑐(cid:1),

which is the specification in is_person_fast. When our framework synthesizes a value 𝑐 ′ to fill
??2 in is_person_fast, it uses the same value to fill ??2 in monitor_correctness. Then, at run
time, it accumulates pairs (𝑥, ˆ𝑦), where ˆ𝑦 = 1(𝑓 (𝑥) ≤ 𝑐), in calls to monitor_correctness and
uses them to check whether the probabilistic assertion in that function is true.

To evaluate whether monitoring can detect shifts, we select two subsets of the “car” category:
(i) bikes, including motor bikes, and (ii) passenger cars, excluding busses, trucks, etc., with 6 fine-
grained labels each. Then, we consider a shift from the car category to the bike category—i.e., if we
imagine that bikes were instead labeled as cars, would the recall of our program continue to be above
the desired threshold. First, we check whether it proves correctness when the data distribution
does not shift—i.e., using the test images labeled “passenger car”. We run our verification algorithm
on this property using the test set images labeled As expected, our verification algorithm correctly
concludes that both the recall and the running time are within the expected bounds. Then, we check
whether it proves correctness when the data distribution shifts—i.e., using the test images labeled
“bike”. In this case, our verification algorithm concludes that recall is incorrect, but running time is
correct. Indeed, the average running time is now lower—intuitively, 𝑓fast is incorrectly rejecting
many “car” images, which reduces recall (undesired) as well as running time (desired).

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

23

def predict_warfarin_dose(x, y_true=None):

def monitor_correctness(x):

y = argmax([(ys, f(x, y)) for y in [‘low’, ‘med’, ‘high’]])
if y == ‘low’ and f(x, ‘low’) >= ??1 {y_true != ‘high’} [|, 0.05]:

return ‘low’

y = argmax([(ys, f(x, y)) for y in [‘low’, ‘med’, ‘high’]])
y_true = obtain_result(x)
if y == ‘low’:

if y == ‘high’ and f(x, ‘high’) >= ??2 {y_true != ‘low’} [|, 0.05]:

passert f(x, ‘low’) >= ??1 {y_true != ‘high’} [|, 0.05]

return ‘high’

return ‘med’

if y == ‘high’:

passert f(x, ‘high’) >= ??2 {y_true != ‘low’} [|, 0.05]

Fig. 8. A program that predicts the Warfarin dose for a patient with covariates 𝑥. Specifications are shown in
green; curly brackets is the specification and square brackets is the value of 𝜖. The corresponding inequality
with a hole in blue. Holes with the same number are filled with the same value.

(a)

(d)

(b)

(e)

(c)

(f)

Fig. 9. We show the error rate (top) and accuracy (bottom) for our program (black), the random forest (red),
always predicting “medium” (green) as a function of (a,d) 𝜖, (b,e) 𝛿, and (c,f) the number of synthesis examples
𝑛; for the top plots, we also show the desired upper bound on the error rate (blue).

As a side note, our framework can also be used to monitor quantitative properties. For instance,
we can keep monitor how frequently the branch 𝑓fast (𝑥) > 𝑐 is taken—i.e., avoiding the need to
evaluate 𝑓 (𝑥). In Figure 6, monitor_running_time includes a probabilistic assertion

passert 1 − 𝑓fast (𝑥) > 𝑐 ′ {true} |
𝜖
to perform this check. This assertion says that 1 − 𝑓fast (𝑥) > 𝑐 ′ with probability at least 1 − 𝜖—i.e.,
the faster branch in is_person_fast should be taken at least 1 − 𝜖 fraction of the time according
to 𝑝 (𝑥, 𝑦∗). We might not know what is a reasonable value of 𝜖—i.e., the rate at which 𝑓fast predicts
there is a person in the image. Thus, we leave it as a hole ??3. Given training examples (cid:174)𝑧, our
framework can be used to synthesize a value of 𝜖 to fill this hole.

7.4 Case Study 2: Precision Medicine

Warfarin dosing task. Next, we consider a task from precision medicine. In particular, we consider
a random forest trained to predict dosing level for the Warfarin drug based on individual covariates
such as genetic biomarkers [36]. Personalized dosing can improve patient outcomes, but significant
errors can lead to adverse events if not quickly corrected. The ideal dosage is a real-valued label.
The goal is to train a model to predict this dosage as a decision support tool for physicians. For
simplicity, we build on an approach that converts the problem into a classification problem by

, Vol. 1, No. 1, Article . Publication date: October 2021.

0.000.010.020.030.040.0500.020.040.060.080.1Error Rate𝜀0.000.010.020.030.040.0500.020.040.060.080.1Error Rate𝛿0.000.010.020.030.040.05500100015002000Error Raten0.500.550.600.6500.020.040.060.080.1Accuracy𝜀0.500.550.600.6500.020.040.060.080.1Accuracy𝛿0.500.550.600.65500100015002000Accuracyn24

Bastani

discretizing this value into labels Y = {high, medium, low} dose [8]. Then, the goal is to maximize
accuracy while ensuring that very few patients for whom a high dose is predicted but should have
been assigned a low dose, and vice versa.

Experimental setup. We split the dataset (5,528 examples) into training (1,658 examples), synthesis
(2,764 examples), and test (1,106 examples) sets. Then, we use scikit-learn [54] to train a random
forest 𝑓 : X × Y → R with 100 trees on the training set, where 𝑓 (𝑥, 𝑦) ∈ R is the probability
assigned to label 𝑦 ∈ Y, and use 𝑓 in conjunction with the program shown in Figure 9. This program
includes two thresholds 𝑐low and 𝑐high, and only assigns a low dose to a patient with covariates 𝑥 if
𝑓 (𝑥) ≥ 1 − 𝑐low, and similarly for a high dose—i.e., it only assigns the riskier outcomes when 𝑓 is
sufficiently confident in its prediction. Importantly, the specification on 𝑐low refers not to the error
rate on predictions for patients for whom 𝑦 = low, but for whom 𝑦 = high—i.e., we want to choose
𝑐low to ensure precision specifically on patients for whom 𝑦 = high, and conversely for 𝑐high. We
use our synthesis algorithm to synthesize values of 𝑐low and 𝑐high that satisfy these specifications.

Correctness. Figure 9 shows the results of our approach (black) compared to directly predicting
the highest probability label according to the random forest 𝑓 (red), always predicting “medium”
(green), and the desired error rate (blue), as a function of the maximum error rate 𝜖, the maximum
failure probability 𝛿, and the number of synthesis examples 𝑛. The top plots show the error rate,
which is the maximum of the rate at which patients with 𝑦 = low are assigned a high dose, and
the rate at which patients 𝑦 = high are assigned a low dose; this value should be below the blue
line. The bottom plot shows the overall accuracy of the program—i.e., how often its predicted dose
equals the ground truth dose. All values are estimated on the held-out test set. As before, 𝜖 has the
largest impact on performance since it directly controls the error rate; however, once it hits 𝜖 = 0.06,
performance levels off since its accuracy now equals that of 𝑓 , and the program never assigns
a dose not predicted by 𝑓 . Performance is flat as a function of 𝛿. Finally, performance increases
quickly as 𝑛 goes from 500 to 1000, but plateaus thereafter, again once accuracy equals that of 𝑓 .

Runtime monitoring. In the case of Warfarin dosing, the doctor administers an initial dose to the
patient (possibly the predicted dose, depending on the doctor’s judgement), and gradually adjusts
it based on the patient response. Thus, we eventually observe the ground truth dose that should
have been recommended, which we can use to monitor our program. This process is achieved
by the monitor_correctness subroutine; here, obtain_result returns the true dose eventually
observed for a patient with covariates 𝑥. We evaluate whether our runtime monitoring can detect
shifts in the data distribution that lead to a reduction in performance. We consider a shift in terms
of the ethnicity of the patients, which has recently been identified as an important challenge in
algorithmic healthcare [48]. In particular, we consider a model trained using non-Hispanic White
patients (2,969 examples), which we refer to as the “majority patients”, and test it on Black, Hispanic,
and Asian patients (2,559 examples), which we refer to as the “minority patients”.

First, we check if it proves correctness when the data distribution does not shift—i.e., we train
the random forest, and synthesize and verify the program on majority patients. As expected, it
successfully verifies correctness. Next, we check if it proves correctness when there is a shift—i.e.,
we train the random forest and synthesize the program on majority patients, but verify the program
on minority patients. As expected, it rejects the program as incorrect.

Finally, recall that whether verification is successful depends on how many test examples are
provided; thus, we also evaluate how many test examples are needed in this setting. To make
sure we have enough examples, we use all examples in this case. Then, we find that for 2,000 test
examples, our verification algorithm successfully proves correctness, but for 500, 1,000, or 1,500
test examples, it fails. Intuitively, the number of test examples needed to verify correctness needs

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

25

to be more than the number use to synthesize the parameters, or else the synthesized thresholds
will be more precise (i.e., closer to their “optimal” value) and the verification algorithm will not
have enough data to validate them. In this case, we use 1,000 synthesis examples, so about 2× as
many test examples are needed to verify correctness.

8 RELATED WORK

Synthesizing machine learning programs. There has been work on synthesizing programs that
include DNN components [21, 25, 65, 70, 74] and on synthesizing probabilistic programs [47, 59];
however, they do not provide guarantees on the synthesized program. There has been work on
synthesizing control policies that satisfy provable guarantees [4, 10, 72, 75]; however, they focus
on the setting where the learner can interact with the environment, and are not applicable to our
supervised learning setting. Finally, there has been work on synthesizing programs with probabilistic
constraints [20], but requires that the search space of programs has finite VC dimension.

Verified machine learning. There has been recent interest in verifying machine learning programs—
e.g., verifying robustness [3, 9, 26, 31, 33], fairness [1, 11], and safety [32, 33]. More broadly, there
has been work verifying systems such as approximate computing [14, 15, 46, 57] and probabilistic
programming [60, 61]. The most closely related work is [19, 24, 35, 49], which verify semantic
properties of machine learning models by sampling synthetic inputs from a user-specified space. In
contrast, our focus is on synthesizing machine learning programs.

Statistical verification. There has been work leveraging statistical bounds to verify stochastic
systems [62, 63, 73], probabilistic programs [60, 61], and machine learning programs [11]. Our veri-
fication algorithm in Appendix A relies on bounds similar to the ones used in these approaches [73].
To the best of our knowledge, we are the first to focus on synthesis; in contrast to verification, our
approach relies on bounds from learning theory to provide correctness guarantees.

Conformal prediction. There has been work on conformal prediction [6, 58, 64, 68], including
applications of these ideas to deep learning [5, 37, 51, 52], which aim to use statistical techniques
to provide guarantees on the predictions of machine learning models. In particular, they provide
confidence sets of outputs that contain the true label with high probability. Our techniques are
inspired by these approaches, extending them to a general framework of synthesizing machine
learning programs that satisfy provable guarantees.

9 CONCLUSION
We have proposed algorithms for synthesizing machine learning programs that come with PAC
guarantees. Our technique leverages novel statistical learning bounds to achieve these guarantees.
We have empirically demonstrated how our approach can be used to synthesize list processing
programs that manipulate images using DNN components while satisfying PAC guarantees, as well
as on two case studies in image classification and precision medicine. A key direction for future
work is how to extend these ideas to settings where the underlying data distribution may shift, and
to settings beyond supervised learning such as reinforcement learning.

REFERENCES
[1] Aws Albarghouthi, Loris D’Antoni, Samuel Drews, and Aditya V Nori. 2017. FairSquare: probabilistic verification of

program fairness. Proceedings of the ACM on Programming Languages 1, OOPSLA (2017), 1–30.

[2] Rajeev Alur, Rastislav Bodik, Garvit Juniwal, Milo MK Martin, Mukund Raghothaman, Sanjit A Seshia, Rishabh Singh,

Armando Solar-Lezama, Emina Torlak, and Abhishek Udupa. 2013. Syntax-guided synthesis. IEEE.

, Vol. 1, No. 1, Article . Publication date: October 2021.

26

Bastani

[3] Greg Anderson, Shankara Pailoor, Isil Dillig, and Swarat Chaudhuri. 2019. Optimization and abstraction: A synergistic
approach for analyzing neural network robustness. In Proceedings of the 40th ACM SIGPLAN Conference on Programming
Language Design and Implementation. 731–744.

[4] Greg Anderson, Abhinav Verma, Isil Dillig, and Swarat Chaudhuri. 2020. Neurosymbolic Reinforcement Learning with

Formally Verified Exploration. In Advances in neural information processing systems.

[5] Anastasios Angelopoulos, Stephen Bates, Jitendra Malik, and Michael I Jordan. 2020. Uncertainty Sets for Image

Classifiers using Conformal Prediction. arXiv preprint arXiv:2009.14193 (2020).

[6] Vineeth Balasubramanian, Shen-Shyang Ho, and Vladimir Vovk. 2014. Conformal prediction for reliable machine

learning: theory, adaptations and applications. Newnes.

[7] Peter L Bartlett and Shahar Mendelson. 2002. Rademacher and Gaussian complexities: Risk bounds and structural

results. Journal of Machine Learning Research 3, Nov (2002), 463–482.

[8] Hamsa Bastani and Mohsen Bayati. 2015. Online decision-making with high-dimensional covariates. Operations

Research (2015).

[9] Osbert Bastani, Yani Ioannou, Leonidas Lampropoulos, Dimitrios Vytiniotis, Aditya Nori, and Antonio Criminisi. 2016.
Measuring neural net robustness with constraints. In Advances in neural information processing systems. 2613–2621.
[10] Osbert Bastani, Yewen Pu, and Armando Solar-Lezama. 2018. Verifiable reinforcement learning via policy extraction.

In Advances in neural information processing systems. 2494–2504.

[11] Osbert Bastani, Xin Zhang, and Armando Solar-Lezama. 2019. Probabilistic verification of fairness properties via

concentration. Proceedings of the ACM on Programming Languages 3, OOPSLA (2019), 1–27.

[12] Shai Ben-David, John Blitzer, Koby Crammer, and Fernando Pereira. 2007. Analysis of representations for domain

adaptation. In Advances in neural information processing systems. 137–144.

[13] Tolga Bolukbasi, Joseph Wang, Ofer Dekel, and Venkatesh Saligrama. 2017. Adaptive neural networks for efficient
inference. In Proceedings of the 34th International Conference on Machine Learning-Volume 70. JMLR. org, 527–536.
[14] Michael Carbin, Deokhwan Kim, Sasa Misailovic, and Martin C Rinard. 2012. Proving acceptability properties of

relaxed nondeterministic approximate programs. ACM SIGPLAN Notices 47, 6 (2012), 169–180.

[15] Michael Carbin, Sasa Misailovic, and Martin C Rinard. 2013. Verifying quantitative reliability for programs that execute

on unreliable hardware. ACM SIGPLAN Notices 48, 10 (2013), 33–52.

[16] Jia Chen, Jiayi Wei, Yu Feng, Osbert Bastani, and Isil Dillig. 2019. Relational verification using reinforcement learning.

Proceedings of the ACM on Programming Languages 3, OOPSLA (2019), 1–30.

[17] Yanju Chen, Chenglong Wang, Osbert Bastani, Isil Dillig, and Yu Feng. 2020. Program Synthesis Using Deduction-
Guided Reinforcement Learning. In International Conference on Computer Aided Verification. Springer, 587–610.
[18] Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. 2009. Imagenet: A large-scale hierarchical image

database. In 2009 IEEE conference on computer vision and pattern recognition. Ieee, 248–255.

[19] Tommaso Dreossi, Daniel J Fremont, Shromona Ghosh, Edward Kim, Hadi Ravanbakhsh, Marcell Vazquez-Chanlatte,
and Sanjit A Seshia. 2019. Verifai: A toolkit for the formal design and analysis of artificial intelligence-based systems.
In International Conference on Computer Aided Verification. Springer, 432–442.

[20] Samuel Drews, Aws Albarghouthi, and Loris D’Antoni. 2019. Efficient Synthesis with Probabilistic Constraints. In

International Conference on Computer Aided Verification. Springer, 278–296.

[21] Kevin Ellis, Daniel Ritchie, Armando Solar-Lezama, and Josh Tenenbaum. 2018. Learning to infer graphics programs

from hand-drawn images. In Advances in neural information processing systems. 6059–6068.

[22] Andre Esteva, Brett Kuprel, Roberto A Novoa, Justin Ko, Susan M Swetter, Helen M Blau, and Sebastian Thrun. 2017.
Dermatologist-level classification of skin cancer with deep neural networks. nature 542, 7639 (2017), 115–118.
[23] John K Feser, Swarat Chaudhuri, and Isil Dillig. 2015. Synthesizing data structure transformations from input-output

examples. ACM SIGPLAN Notices 50, 6 (2015), 229–239.

[24] Daniel J Fremont, Tommaso Dreossi, Shromona Ghosh, Xiangyu Yue, Alberto L Sangiovanni-Vincentelli, and Sanjit A
Seshia. 2019. Scenic: a language for scenario specification and scene generation. In Proceedings of the 40th ACM
SIGPLAN Conference on Programming Language Design and Implementation. 63–78.

[25] Alexander L Gaunt, Marc Brockschmidt, Nate Kushman, and Daniel Tarlow. 2017. Differentiable programs with neural

libraries. In International Conference on Machine Learning. 1213–1222.

[26] Timon Gehr, Matthew Mirman, Dana Drachsler-Cohen, Petar Tsankov, Swarat Chaudhuri, and Martin Vechev. 2018.
Ai2: Safety and robustness certification of neural networks with abstract interpretation. In 2018 IEEE Symposium on
Security and Privacy (SP). IEEE, 3–18.

[27] Varun Gulshan, Lily Peng, Marc Coram, Martin C Stumpe, Derek Wu, Arunachalam Narayanaswamy, Subhashini
Venugopalan, Kasumi Widner, Tom Madams, Jorge Cuadros, et al. 2016. Development and validation of a deep learning
algorithm for detection of diabetic retinopathy in retinal fundus photographs. Jama 316, 22 (2016), 2402–2410.
[28] David Haussler, Michael Kearns, Nick Littlestone, and Manfred K Warmuth. 1991. Equivalence of models for polynomial

learnability. Information and Computation 95, 2 (1991), 129–161.

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

27

[29] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. 2016. Deep residual learning for image recognition. In

Proceedings of the IEEE conference on computer vision and pattern recognition. 770–778.

[30] Wassily Hoeffding. 1994. Probability inequalities for sums of bounded random variables. In The Collected Works of

Wassily Hoeffding. Springer, 409–426.

[31] Xiaowei Huang, Marta Kwiatkowska, Sen Wang, and Min Wu. 2017. Safety verification of deep neural networks. In

International Conference on Computer Aided Verification. Springer, 3–29.

[32] Radoslav Ivanov, James Weimer, Rajeev Alur, George J Pappas, and Insup Lee. 2019. Verisig: verifying safety properties
of hybrid systems with neural network controllers. In Proceedings of the 22nd ACM International Conference on Hybrid
Systems: Computation and Control. 169–178.

[33] Guy Katz, Clark Barrett, David L Dill, Kyle Julian, and Mykel J Kochenderfer. 2017. Reluplex: An efficient SMT solver
for verifying deep neural networks. In International Conference on Computer Aided Verification. Springer, 97–117.
[34] Michael J Kearns, Umesh Virkumar Vazirani, and Umesh Vazirani. 1994. An introduction to computational learning

theory. MIT press.

[35] Edward Kim, Divya Gopinath, Corina Pasareanu, and Sanjit A Seshia. 2020. A Programmatic and Semantic Approach
to Explaining and Debugging Neural Network Based Object Detectors. In Proceedings of the IEEE/CVF Conference on
Computer Vision and Pattern Recognition. 11128–11137.

[36] Stephen E Kimmel, Benjamin French, Scott E Kasner, Julie A Johnson, Jeffrey L Anderson, Brian F Gage, Yves D
Rosenberg, Charles S Eby, Rosemary A Madigan, Robert B McBane, et al. 2013. A pharmacogenetic versus a clinical
algorithm for warfarin dosing. New England Journal of Medicine 369, 24 (2013), 2283–2293.

[37] Danijel Kivaranovic, Kory D Johnson, and Hannes Leeb. 2020. Adaptive, Distribution-Free Prediction Intervals for

Deep Networks. In International Conference on Artificial Intelligence and Statistics. 4346–4356.

[38] Matthieu Komorowski, Leo A Celi, Omar Badawi, Anthony C Gordon, and A Aldo Faisal. 2018. The artificial intelligence
clinician learns optimal treatment strategies for sepsis in intensive care. Nature medicine 24, 11 (2018), 1716–1720.
[39] Tim Kraska, Mohammad Alizadeh, Alex Beutel, H Chi, Ani Kristo, Guillaume Leclerc, Samuel Madden, Hongzi Mao,

and Vikram Nathan. 2019. Sagedb: A learned database system. In CIDR.

[40] Tim Kraska, Alex Beutel, Ed H Chi, Jeffrey Dean, and Neoklis Polyzotis. 2018. The case for learned index structures. In

Proceedings of the 2018 International Conference on Management of Data. 489–504.

[41] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. 2012. Imagenet classification with deep convolutional neural

networks. Advances in neural information processing systems 25 (2012), 1097–1105.

[42] Yann LeCun, Léon Bottou, Yoshua Bengio, and Patrick Haffner. 1998. Gradient-based learning applied to document

recognition. Proc. IEEE 86, 11 (1998), 2278–2324.

[43] Woosuk Lee, Kihong Heo, Rajeev Alur, and Mayur Naik. 2018. Accelerating search-based program synthesis using

learned probabilistic models. ACM SIGPLAN Notices 53, 4 (2018), 436–449.

[44] Sergey Levine, Chelsea Finn, Trevor Darrell, and Pieter Abbeel. 2016. End-to-end training of deep visuomotor policies.

The Journal of Machine Learning Research 17, 1 (2016), 1334–1373.

[45] Tsung-Yi Lin, Michael Maire, Serge Belongie, James Hays, Pietro Perona, Deva Ramanan, Piotr Dollár, and C Lawrence
Zitnick. 2014. Microsoft coco: Common objects in context. In European conference on computer vision. Springer,
740–755.

[46] Sasa Misailovic, Michael Carbin, Sara Achour, Zichao Qi, and Martin C Rinard. 2014. Chisel: Reliability-and accuracy-

aware optimization of approximate computational kernels. ACM Sigplan Notices 49, 10 (2014), 309–328.

[47] Aditya V Nori, Sherjil Ozair, Sriram K Rajamani, and Deepak Vijaykeerthy. 2015. Efficient synthesis of probabilistic

programs. ACM SIGPLAN Notices 50, 6 (2015), 208–217.

[48] Ziad Obermeyer, Brian Powers, Christine Vogeli, and Sendhil Mullainathan. 2019. Dissecting racial bias in an algorithm

used to manage the health of populations. Science 366, 6464 (2019), 447–453.

[49] Matthew O’Kelly, Aman Sinha, Hongseok Namkoong, Russ Tedrake, and John C Duchi. 2018. Scalable end-to-end
autonomous vehicle testing via rare-event simulation. In Advances in Neural Information Processing Systems. 9827–9838.
[50] Peter-Michael Osera and Steve Zdancewic. 2015. Type-and-example-directed program synthesis. ACM SIGPLAN

Notices 50, 6 (2015), 619–630.

[51] Sangdon Park, Osbert Bastani, Nikolai Matni, and Insup Lee. 2020. PAC Confidence Sets for Deep Neural Networks via

Calibrated Prediction. In International Conference on Learning Representations.

[52] Sangdon Park, Shuo Li, Osbert Bastani, and Insup Lee. 2020. PAC Confidence Predictions for Deep Neural Network

Classifiers. arXiv preprint arXiv:2011.00716 (2020).

[53] Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Alban

Desmaison, Luca Antiga, and Adam Lerer. 2017. Automatic differentiation in pytorch. (2017).

[54] Fabian Pedregosa, Gaël Varoquaux, Alexandre Gramfort, Vincent Michel, Bertrand Thirion, Olivier Grisel, Mathieu
Blondel, Peter Prettenhofer, Ron Weiss, Vincent Dubourg, et al. 2011. Scikit-learn: Machine learning in Python. the
Journal of machine Learning research 12 (2011), 2825–2830.

, Vol. 1, No. 1, Article . Publication date: October 2021.

28

Bastani

[55] Joaquin Quionero-Candela, Masashi Sugiyama, Anton Schwaighofer, and Neil D Lawrence. 2009. Dataset shift in

machine learning. The MIT Press.

[56] Shaoqing Ren, Kaiming He, Ross Girshick, and Jian Sun. 2016. Faster r-cnn: Towards real-time object detection with
region proposal networks. IEEE transactions on pattern analysis and machine intelligence 39, 6 (2016), 1137–1149.
[57] Martin Rinard. 2006. Probabilistic accuracy bounds for fault-tolerant computations that discard tasks. In Proceedings of

the 20th annual international conference on Supercomputing. 324–334.

[58] Yaniv Romano, Evan Patterson, and Emmanuel Candes. 2019. Conformalized quantile regression. In Advances in

Neural Information Processing Systems. 3543–3553.

[59] Feras A Saad, Marco F Cusumano-Towner, Ulrich Schaechtle, Martin C Rinard, and Vikash K Mansinghka. 2019.
Bayesian synthesis of probabilistic programs for automatic data modeling. Proceedings of the ACM on Programming
Languages 3, POPL (2019), 1–32.

[60] Adrian Sampson, Pavel Panchekha, Todd Mytkowicz, Kathryn S McKinley, Dan Grossman, and Luis Ceze. 2014.
Expressing and verifying probabilistic assertions. In Proceedings of the 35th ACM SIGPLAN Conference on Programming
Language Design and Implementation. 112–122.

[61] Sriram Sankaranarayanan, Aleksandar Chakarov, and Sumit Gulwani. 2013. Static analysis for probabilistic programs:
inferring whole program properties from finitely many paths. In Proceedings of the 34th ACM SIGPLAN conference on
Programming language design and implementation. 447–458.

[62] Koushik Sen, Mahesh Viswanathan, and Gul Agha. 2004. Statistical model checking of black-box probabilistic systems.

In International Conference on Computer Aided Verification. Springer, 202–215.

[63] Koushik Sen, Mahesh Viswanathan, and Gul Agha. 2005. On statistical model checking of stochastic systems. In

International Conference on Computer Aided Verification. Springer, 266–280.

[64] Glenn Shafer and Vladimir Vovk. 2008. A tutorial on conformal prediction. Journal of Machine Learning Research 9,

Mar (2008), 371–421.

[65] Ameesh Shah, Eric Zhan, Jennifer J Sun, Abhinav Verma, Yisong Yue, and Swarat Chaudhuri. 2020. Learning Differen-

tiable Programs with Admissible Neural Heuristics. In Advances in neural information processing systems.

[66] Armando Solar-Lezama. 2008. Program synthesis by sketching. University of California, Berkeley.
[67] Surat Teerapittayanon, Bradley McDanel, and Hsiang-Tsung Kung. 2016. Branchynet: Fast inference via early exiting
from deep neural networks. In 2016 23rd International Conference on Pattern Recognition (ICPR). IEEE, 2464–2469.
[68] Ryan J Tibshirani, Rina Foygel Barber, Emmanuel Candes, and Aaditya Ramdas. 2019. Conformal prediction under

covariate shift. In Advances in Neural Information Processing Systems. 2530–2540.

[69] Leslie G Valiant. 1984. A theory of the learnable. Commun. ACM 27, 11 (1984), 1134–1142.
[70] Lazar Valkov, Dipak Chaudhari, Akash Srivastava, Charles Sutton, and Swarat Chaudhuri. 2018. Houdini: Lifelong

learning as program synthesis. In Advances in Neural Information Processing Systems.

[71] Vladimir Vapnik. 2013. The nature of statistical learning theory. Springer science & business media.
[72] Abhinav Verma, Vijayaraghavan Murali, Rishabh Singh, Pushmeet Kohli, and Swarat Chaudhuri. 2018. Programmati-

cally Interpretable Reinforcement Learning. In International Conference on Machine Learning. 5045–5054.

[73] Håkan LS Younes and Reid G Simmons. 2002. Probabilistic verification of discrete event systems using acceptance

sampling. In International Conference on Computer Aided Verification. Springer, 223–235.

[74] Halley Young, Osbert Bastani, and Mayur Naik. 2019. Learning Neurosymbolic Generative Models via Program

Synthesis. In International Conference on Machine Learning.

[75] He Zhu, Zikang Xiong, Stephen Magill, and Suresh Jagannathan. 2019. An inductive synthesis framework for verifiable
reinforcement learning. In Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and
Implementation. 686–701.

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

29

A STATISTICAL VERIFICATION
We describe our algorithm for verifying a complete program. Our algorithm (Algorithm 3) takes
as input a complete program ¯𝑃, training valuations (cid:174)𝛼 = (𝛼1, ..., 𝛼𝑛), where 𝛼1, ..., 𝛼𝑛 ∼ 𝑝 are i.i.d.
samples, and a confidence level 𝛿 ∈ R>0, and outputs a value 𝐴( ¯𝑃, (cid:174)𝛼) ∈ {0, 1} indicating whether ¯𝑃
is approximately complete, which is correct with probability at least 1 − 𝛿 with respect to 𝑝 ( (cid:174)𝛼).

Our algorithm is based on statistical verification [62, 63, 73]. These algorithms leverage concen-
tration inequalities from probability theory to provide high-probability correctness guarantees.
Concentration inequalities are theorems that provide rigorous bounds on the rate of convergence
of statistical estimators. For instance, consider a Bernoulli distribution 𝑝 = Bernoulli(𝜇) with
unknown mean 𝜇. Given samples 𝑧1, ..., 𝑧𝑛 ∼ 𝑝, Hoeffding’s inequality [30] says that the empirical
mean ˆ𝜇 ((cid:174)𝑧) = 𝑛−1 (cid:205)𝑛

𝑖=1 𝑧𝑖 converges to 𝜇:

P𝑝 ( (cid:174)𝑧)

(cid:0)| ˆ𝜇 ((cid:174)𝑧) − 𝜇| ≤ 𝜖(cid:1) ≥ 1 − 𝛿 where 𝛿 = 2𝑒−2𝑛𝜖 2,

(11)

i.e., ˆ𝜇 ((cid:174)𝑧) is a good approximation of 𝜇 with high probability.

𝐸
(cid:74)

𝛼 . Then, 𝜖-approximate soundness of 𝐸 is equivalent to 𝜇 = P𝑝 (𝛼) (𝑧𝛼 | 𝑧∗
∗
(cid:75)

In our setting, given training valuation 𝛼 and a specification 𝐸 = 𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔
𝛼 and 𝑧∗
(cid:75)

𝜖 in ¯𝑃, we let 𝑧𝛼 =
𝛼 ) ≥ 1 −𝜖
𝐸
𝛼 =
(cid:74)
if 𝜔 = |, or 𝜇 = P𝑝 (𝛼) (𝑧∗
𝛼 ⇒ 𝑧𝛼 ) ≥ 1 − 𝜖 if 𝜔 = ⇒. That is, 𝜖-approximate soundness is equivalent
to 𝜇 ≥ 1 − 𝜖, where 𝜇 is the mean of a Bernoulli random variable 𝑧𝛼 that is a function of a random
variable 𝛼 with distribution 𝑝 (𝛼 | 𝑧∗
𝛼 ⇒ 𝑧𝛼
that is a function of 𝛼 with distribution 𝑝 (𝛼) (if 𝜔 = ⇒). However, 𝑧𝛼 is potentially a complicated
function of 𝛼 and 𝑝 (𝛼) is unknown, so 𝜇 is hard to compute directly. Instead, given i.i.d. samples
and use them estimate 𝜇:
𝛼1, ..., 𝛼𝑛 ∼ 𝑝 (𝛼), we can construct the samples 𝑧𝛼1, ..., 𝑧𝛼𝑛 and 𝑧∗
𝛼1

𝛼 ) (if 𝜔 = |) or the mean of a Bernoulli random variable 𝑧∗

, ..., 𝑧∗
𝛼𝑛

ˆ𝜇 ( (cid:174)𝛼) =

(cid:40) (cid:205)𝑛

𝑖=1 𝑧𝛼𝑖 ∧𝑧∗
𝛼𝑖
(cid:205)𝑛
𝑖=1 𝑧∗
𝛼𝑖
𝛼𝑖 ⇒ 𝑧𝛼𝑖
𝑖=1 𝑧∗

(cid:205)𝑛

if 𝜔 = |
if 𝜔 = ⇒ .

Then, we can use (11) to bound the error of ˆ𝜇 ( (cid:174)𝛼)—e.g., if ˆ𝜇 ( (cid:174)𝛼) ≥ 1 − 𝜖
2 with
probability at least 1 − 𝛿, then 𝜇 ≥ 1 − 𝜖 with probability at least 1 − 𝛿. However, this approach is
inefficient since Hoeffding’s inequality is not tight for our setting. Instead, our verification algorithm
(Appendix A.2) leverages a concentration inequality tailored to our setting (Appendix A.1). Finally,
we disucss how our approach can be used in the context of runtime monitoring (Appendix A.3).

2 and | ˆ𝜇 ( (cid:174)𝛼) − 𝜇| ≤ 𝜖

A.1 A Concentration Bound

Problem formulation. Consider a Bernoulli distribution 𝑝 = Bernoulli(𝜇) with unknown mean
𝜇 ∈ [0, 1]. Given 𝜖 ∈ R>0, our goal is to determine whether 𝜇 ≥ 1 − 𝜖. For instance, a sample 𝑧 ∼ 𝑝
may indicate a desired outcome (e.g., a correctly classified input), in which case 𝜇 is the correctness
rate and 𝜖 is a desired bound on the error rate; then, our goal is to check whether the 𝜇 meets the
desired error bound. More precisely, we want to compute 𝜓 ∈ {0, 1} such that

𝜓 ⇒ (𝜇 ≥ 1 − 𝜖).

(12)

That is, 𝜓 is a sound overapproximation of the property 𝜇 ≥ 1 − 𝜖 (i.e., 𝜓 = 1 implies 𝜇 ≥ 1 − 𝜖).

To compute such a 𝜓 , we are given a training set of examples (cid:174)𝑧 = (𝑧1, ..., 𝑧𝑛) ∈ {0, 1}𝑛, where
𝑧1, ..., 𝑧𝑛 ∼ 𝑝 are 𝑛 i.i.d. samples from 𝑝. An estimator is a mapping ˆ𝜓 : R𝑛 → R. We say such an
estimator is approximately correct if it satisfies the condition (12)—i.e., ˆ𝜓 ((cid:174)𝑧) ⇒ (𝜇 ≥ 1 − 𝜖).

In general, we cannot guarantee ˆ𝜓 ((cid:174)𝑧) is approximately correct due to the randomness in the
training examples (cid:174)𝑧.4 Thus, we allow a probability 𝛿 ∈ R>0 that ˆ𝜓 ((cid:174)𝑧) is not approximately correct.

4Note that ˆ𝜓 is a deterministic function; the randomness of ˆ𝜓 ( (cid:174)𝑧) is entirely due to the randomness in the training data (cid:174)𝑧.

, Vol. 1, No. 1, Article . Publication date: October 2021.

30

Bastani

Algorithm 3 Use statistical verification to check if 𝑃 is approximately correct.

procedure Verify( ¯𝑃, (cid:174)𝛼, 𝛿)

𝑚 ← |Φ(𝑃)|
for 𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔

𝜖 ∈ Φ( ¯𝑃) do

Compute (cid:174)𝑧 (cid:174)𝛼 according to (14)
Compute ˆ𝜓 ((cid:174)𝑧 (cid:174)𝛼 ) according to (13) with (𝜖, 𝛿/𝑚)
if ¬ ˆ𝜓 ((cid:174)𝑧 (cid:174)𝛼 ) then
return false

end if

end for
return true
end procedure

Definition A.1. Given 𝜖, 𝛿 ∈ R>0, ˆ𝜓 is (𝜖, 𝛿)-PAC if P𝑝 ( (cid:174)𝑧)
In other words, ˆ𝜓 ((cid:174)𝑧) is approximately correct with probability at least 1 − 𝛿 according to the

(cid:0) ˆ𝜓 ((cid:174)𝑧) ⇒ (𝜇 ≥ 1 − 𝜖)(cid:1) ≥ 1 − 𝛿.

randomness in 𝑝 ((cid:174)𝑧). Our goal is to construct an (𝜖, 𝛿)-PAC estimator ˆ𝜓 ((cid:174)𝑧).

ˆ𝜓 ((cid:174)𝑧) = 1(𝐿((cid:174)𝑧) ≤ 𝑘) where 𝑘 = max

Estimator. Given 𝜖, 𝛿 ∈ R>0, consider the estimator
(cid:40)
ℎ ∈ N

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
and where 𝐿((cid:174)𝑧) = (cid:205)𝑛
𝑧 ∈(cid:174)𝑧 (1 − 𝑧). Intuitively, 𝐿((cid:174)𝑧) counts the number of errors, so we conclude the
desired property holds as long as 𝐿((cid:174)𝑧) is below a threshold 𝑘. This threshold is chosen so ˆ𝜓 is
(𝜖, 𝛿)-PAC—in particular, 𝛿 upper bounds the CDF of the binomial distribution evaluated at 𝑘.

𝜖𝑖 (1 − 𝜖)𝑛−𝑖 ≤ 𝛿

(cid:18)𝑛
𝑖

ℎ
∑︁

(13)

𝑖=0

(cid:41)

(cid:19)

To compute the solution 𝑘 in (13), we start with ℎ = 0 and increment it until it no longer satisfies
the condition. To ensure numerical stability, this computation is performed using logarithms. Note
that 𝑘 does not exist if the set inside the maximum in (13) is empty; in this case, we choose ˆ𝜓 ((cid:174)𝑧) = 0,
which trivially satisfies the PAC property. We have the following; see Appendix B.1 for a proof:

Theorem A.2. The estimator

ˆ𝜓 is (𝜖, 𝛿)-PAC.

A.2 Verification Algorithm

Problem formulation. A verification algorithm 𝐴 : ¯P × A𝑛 → {0, 1} takes as input a complete
program ¯𝑃 ∈ ¯P, and a set of test valuations (cid:174)𝛼 = (𝛼1, ..., 𝛼𝑛) ∈ A𝑛, where 𝛼1, ..., 𝛼𝑛 ∼ 𝑝 are i.i.d.
samples from a distribution 𝑝 (𝛼). For example, 𝑝 (𝛼) may be the distribution of input images to an
image classifier encountered while running in production, that have been manually labeled using
crowdsourcing. Then, 𝐴( ¯𝑃, (cid:174)𝛼) ∈ {0, 1} should indicate whether ¯𝑃 is approximately sound—i.e.,
𝜖 ∈ Φ( ¯𝑃) is approximately sound. We say that 𝐴 is sound
whether every expression 𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔
if 𝐴( ¯𝑃, (cid:174)𝛼) ⇒ ¯𝑃 ∈ ¯P∗. As before, we cannot guarantee that 𝐴 is sound; instead, given 𝛿 ∈ R>0, we
want this property to hold with probability at least 1 − 𝛿 according to 𝑝 ( (cid:174)𝛼).

Definition A.3. A verification algorithm 𝐴 : ¯P × A𝑛 → {0, 1} is 𝛿-probably approximately

sound if for all ¯𝑃 ∈ ¯P, P𝑝 ( (cid:174)𝛼)

(cid:0)𝐴( ¯𝑃, (cid:174)𝛼) ⇒ ¯𝑃 ∈ ¯P∗(cid:1) ≥ 1 − 𝛿.

Algorithm. Our verification algorithm is shown in Algorithm 3. It check approximate correctness
of ¯𝑃 by checking approximate soundness of each 𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔
𝜖 ∈ Φ( ¯𝑃). It does so by allocating a
𝛿/𝑚 probability of failure for each expression, where 𝑚 = |Φ( ¯𝑃)| is the number of such expressions.

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

31

Next, we describe how our algorithm checks approximate soundness for a single expression

𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔

𝜖 . Given a single test valuation 𝛼 ∼ 𝑝, consider the indicators

𝑧𝛼 =

𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔
𝜖
(cid:74)
That is, 𝑧𝛼 indicates whether 𝜙 ( ¯𝑃 ′, 𝑐) holds, and 𝑧∗
is approximately sound if and only if

and

𝛼
(cid:75)

𝑧∗
𝛼 =

𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }𝜔
𝜖
(cid:74)

∗
𝛼 .
(cid:75)

𝛼 indicates whether 𝑄 holds. Then, 𝜙 ( ¯𝑃 ′, 𝑐) {𝑄 }

P𝑝 (𝛼) (𝑧𝛼 | 𝑧∗

𝛼 ) ≥ 1 − 𝜖

if 𝜔 = |

or

P𝑝 (𝛼) (𝑧∗

𝛼 ⇒ 𝑧𝛼 ) ≥ 1 − 𝜖

if 𝜔 = ⇒ .

Next, note that 𝑧𝛼 ∈ {0, 1} is a Bernoulli random variable with mean 𝜇 = P𝑝 (𝛼) (𝑧𝛼 | 𝑧∗
𝜇 = P𝑝 (𝛼) (𝑧∗

𝛼 ) (if 𝜔 = |) or
𝛼 ⇒ 𝑧𝛼 ) (if 𝜔 = ⇒). Thus, given (cid:174)𝛼 = (𝛼1, ..., 𝛼𝑛), where 𝛼1, ..., 𝛼𝑛 ∼ 𝑝 are i.i.d. samples,

(cid:40)

(cid:174)𝑧 (cid:174)𝛼 =

{𝑧𝛼 | 𝛼 ∈ (cid:174)𝛼 ∧ 𝑧∗
{𝑧∗

𝛼 }
𝛼 ⇒ 𝑧𝛼 | 𝛼 ∈ (cid:174)𝛼 }

if 𝜔 =|
if 𝜔 =⇒

(14)

is a vector of i.i.d. samples from Bernoulli(𝜇). Then, the estimator ˆ𝜓 ((cid:174)𝑧 (cid:174)𝛼 ) in (13) with parameters
(𝜖, 𝛿/𝑚) indicates whether 𝜇 ≥ 1 − 𝜖 with high probability—i.e., if ˆ𝜓 ((cid:174)𝑧 (cid:174)𝛼 ) = 1, then 𝜇 ≥ 1 − 𝜖
holds with probability at least 1 − 𝛿/𝑚 according to 𝑝 ( (cid:174)𝛼). The following guarantee follows from
Theorem A.2 by a union bound over expressions in Φ( ¯𝑃):

Theorem A.4. Algorithm 3 is 𝛿-probably approximately sound.

A.3 Runtime Monitoring
One challenge is that the specifications considered by our framework depend on the distribution of
the data. As a consequence, if this distribution changes, then our correctness guarantees may no
longer hold. This potential failure mode, called distribution shift [12, 55], is a major challenge for
machine learning components. A key feature of our framework is that it can be used not only to
sketch or verify the program before it is deployed, but also to continuously re-sketch the program
based on feedback obtained in production to account for potential distribution shift. The primary
requirement for using this approach is the need for feedback—i.e., continuing to collect labeled
examples in production. In some settings, this kind of feedback is naturally available; otherwise, a
solution is to manually label a small fraction of examples—e.g., using crowdsourcing [18].

Given ground truth labels for the input examples encountered in production, our verification
algorithm can be straightforwardly adapted to the runtime setting. In particular, our system collects
examples during execution; once it collects at least 𝑁 examples, it re-runs verification or sketching.
It can do so after every subsequent example, or every 𝐾 examples. Finally, we may want to discard
an examples after 𝑇 steps, both for computational efficiency and to account for the fact that the data
distribution may be shifting over time so older examples are less representative. Here, 𝐾, 𝑁 ,𝑇 ∈ N
are hyperparameters. Finally, we note that our statistical sketching algorithm can similarly be
adapted to the runtime setting.

B PROOFS

B.1 Proof of Theorem A.2
It suffices to show that if 𝜇 < 1 − 𝜖, then P𝑝 ( (cid:174)𝑧) ( ˆ𝜓 ((cid:174)𝑧)) < 𝛿. First, note that since 𝑧1, ..., 𝑧𝑛 are i.i.d.
Bernoulli random variables with mean 𝜇, then 1 − 𝑧1, ..., 1 − 𝑧𝑛 are i.i.d. Bernoulli random variables
with mean 𝜈 = 1 − 𝜇. Their sum 𝐿((cid:174)𝑧) is a binomial random variable—i.e., 𝐿((cid:174)𝑧) ∼ Binomial(𝑛, 𝜈).

, Vol. 1, No. 1, Article . Publication date: October 2021.

32

Bastani

Also, note that the condition 𝜇 < 1 − 𝜖 is equivalent to 𝜈 > 𝜖. Thus, we have

P𝑝 ( (cid:174)𝑧) ( ˆ𝜓 ((cid:174)𝑧)) =

<

𝑘
∑︁

𝑖=0
𝑘
∑︁

𝑖=0
≤ 𝛿,

(cid:19)

(cid:18)𝑛
𝑖

𝜈𝑖 (1 − 𝜈)𝑛−𝑖

(cid:19)

(cid:18)𝑛
𝑖

𝜖𝑖 (1 − 𝜖)𝑛−𝑖

where the first inequality follows by standard properties of the CDF of the Binomial distribution.
The claim follows. □

B.2 Proof of Theorem 4.2
First, define

𝑡 0
𝜖 = inf
𝑡 ∈R

T𝜖 .

Intuitively, 𝑡 0
particular, it is clear that 𝑡 ∈ T𝜖 for all 𝑡 > 𝑡 0
may not hold. Thus, it suffices to show

𝜖 ∈ R is the threshold that determines whether 𝑡 is 𝜖-approximately correct. In
𝜖 ∈ T𝜖 may or

𝜖 and 𝑡 ∉ T𝜖 for all 𝑡 < 𝑡 0

𝜖 ; in general, 𝑡 0

P𝑝 ( (cid:174)𝑧) (ˆ𝑡 ((cid:174)𝑧) ≤ 𝑡 0

𝜖 ) < 𝛿.

To this end, note that the constraint 𝐿(𝑡; (cid:174)𝑧) ≤ 𝑘 in (4) implies

1(𝑧 > ˆ𝑡 ((cid:174)𝑧) − 𝛾 ((cid:174)𝑧)) ≤ 𝑘.

∑︁

𝑧 ∈(cid:174)𝑧

Thus, on event ˆ𝑡 ((cid:174)𝑧) ≤ 𝑡 0

𝜖 , we have ˆ𝑡 ((cid:174)𝑧) − 𝛾 ((cid:174)𝑧) ≤ 𝑡 0

𝜖 − 𝛾 ((cid:174)𝑧), so

𝑘 ≤

∑︁

𝑧 ∈(cid:174)𝑧

1(𝑧 > ˆ𝑡 ((cid:174)𝑧) − 𝛾 ((cid:174)𝑧)) ≤

1(𝑧 > 𝑡 0

𝜖 − 𝛾 ((cid:174)𝑧)).

∑︁

𝑧 ∈(cid:174)𝑧

As a consequence, we have

P𝑝 ( (cid:174)𝑧) (ˆ𝑡 ((cid:174)𝑧) ≤ 𝑡 0

𝜖 ) ≤ P𝑝 ( (cid:174)𝑧)

1(𝑧 > 𝑡 0

𝜖 − 𝛾 ((cid:174)𝑧)) ≥ 𝑘

(cid:33)

.

(cid:32)

∑︁

𝑧 ∈(cid:174)𝑧

Next, since 𝑡 0

𝜖 − 𝛾 ((cid:174)𝑧) < 𝑡 0

𝜖 , we have 𝑡 0

𝜖 − 𝛾 ((cid:174)𝑧) ∉ T𝜖 —i.e.,

𝜖 < P𝑝 (𝑧) (𝑧 > 𝑡 0

𝜖 − 𝛾 ((cid:174)𝑧)) = E𝑝 (𝑧) (1(𝑧 > 𝑡 0

𝜖 − 𝛾 ((cid:174)𝑧))).

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

33

In other words, the random variables 1(𝑧 > 𝑡 0
with mean 𝜈 > 𝜖. Thus, we have

𝜖 −𝛾 ((cid:174)𝑧)) for 𝑧 ∈ (cid:174)𝑧 are i.i.d. Bernoulli random variables

P𝑝 ( (cid:174)𝑧)

(cid:32)

∑︁

𝑧 ∈(cid:174)𝑧

1(𝑧 > 𝑡 0

𝜖 − 𝛾 ((cid:174)𝑧)) ≥ 𝑘

(cid:33)

𝑘
∑︁

𝑖=0
𝑘
∑︁

𝑖=0
𝑘
∑︁

𝑖=0
𝑘
∑︁

=

=

<

=

P𝑝 ( (cid:174)𝑧)

(cid:32)

∑︁

𝑧 ∈(cid:174)𝑧

1(𝑧 > 𝑡 0

𝜖 + 𝛾 ((cid:174)𝑧)) = 𝑖

(cid:33)

Binomial(𝑖; 𝑛, 𝜈)

Binomial(𝑖; 𝑛, 𝜖)

(cid:19)

𝜖𝑖 (1 − 𝜖)𝑛−𝑖

(cid:18)𝑛
𝑖

𝑖=0
≤ 𝛿,
where the first inequality follows by standard properties of the CDF of the Binomial distribution.
The claim follows. □

B.3 Proof of Theorem 4.4
First, we have the following classical inequality [30]:

Theorem B.1. (Hoeffding’s inequality) We have

(cid:16)

P𝑝 ( (cid:174)𝑧)

𝜇 − ˆ𝜇 ((cid:174)𝑧) ≥ 𝑡

(cid:17)

≤ 𝑒−2𝑛𝑡 2 .

Now, letting 𝑡 =

√︃ log(1/𝛿)
2𝑛

, we have

≤ P𝑝 ( (cid:174)𝑧)
where the second-to-last inequality follows from Theorem B.1. The claim follows. □

𝜇 − ˆ𝜇 ((cid:174)𝑧) ≥ 𝑡

𝜇 ≥ ˆ𝜈 ((cid:174)𝑧)

P𝑝 ( (cid:174)𝑧)

≤ 𝛿,

(cid:16)

(cid:17)

(cid:16)

(cid:17)

≤ 𝑒−2𝑛𝑡 2

C ADDITIONAL CASE STUDY: OBJECT DETECTION

Object detection. We assume given a DNN component 𝑓 that given an image 𝑥, is designed to
detect people in 𝑥. Our formulation of object detection in this section is slightly different than the
previous setup. In particular, 𝑑 ∈ 𝑓 (𝑥) is a list of detections, which is a pair 𝑑 = (𝑏, 𝑝) including a
bounding box 𝑏 ∈ R4 that encodes the center, width, and height of a rectangular region of 𝑥, and a
value 𝑝 ∈ [0, 1] that is the predicted probability that 𝑏 exists. In addition, the ground truth label
𝑦∗ for an image 𝑥 is a list of bounding boxes 𝑏 ∈ 𝑦∗. In general, we cannot expect to get a perfect
match between the predicted bounding boxes and the ground truth ones. Typically, two bounding
boxes 𝑏,′ match if have significant overlap—in particular, their intersection-over-union satisfies
IOU(𝑏, 𝑏 ′) ≥ 𝜌 for some threshold 𝜌 ∈ [0, 1]; we use a standard choice of 𝜌 = 0.5. We denote that
𝑏 and 𝑏 ′ match in this sense by 𝑏 (cid:27) 𝑏 ′. Finally, 𝑏 approximately matches a bounding box in 𝑦∗ it
𝑏 (cid:27) 𝑏 ′ for some 𝑏 ′ ∈ 𝑦∗, which we denote by 𝑏 ˜∈ 𝑦∗.

Experimental setup. We use a pretrained state-of-the-art object detector called Faster R-CNN [56]
available in PyTorch [53], tailored to the COCO dataset [45]. There are multiple variants of Faster
R-CNN; we use the most accurate one, termed X101-FPN with 3× learning rate schedule. For each
predicted bounding box, this model additionally outputs a predicted object category (e.g., “person”),
as well as the size of the bounding box (“small”, “medium”, and “large”). For most of our evaluation,

, Vol. 1, No. 1, Article . Publication date: October 2021.

34

Bastani

def detect_ppl(x):

y_hat = f(x)
return [d.box for d in y_hat if check_det(x, d)]

def check_det(x, d, d_true=None)

return d.score > ??1 {IOU(d.box, d_true) >= 0.5} [|, 0.05]

def detect_ppl_fast(x, y_true=None):

y_hat = f_fast(x)
no_ppl_score = 1.0 - max([d.score for d in y_hat])
if no_ppl_score > ??2 {len(detect_ppl(x)) != 0} [|, 0.05]:

return []

else:

return detect_ppl(x)

def monitor_correctness(x):

if np.random.uniform() <= 0.99:

return

y_hat = f_fast(x)
no_ppl_score = 1.0 - max([d.score for d in y_hat])
passert no_ppl_score > ??1 { len(detect_ppl(x)) != 0} [??3]

def monitor_speed(x):
y_hat = f_fast(x)
no_ppl_score = 1.0 - max([d.score for d in y_hat])
passert no_ppl_score > ??1 {true} [??3]

Fig. 10. A program used to detect people in a given image 𝑥. Specifications are shown in green; curly brackets
is the specification and square brackets is the value of 𝜖. The corresponding inequality with a hole in blue.
Holes with the same number are filled with the same value.

we use “person” and “large”. We specify alternative choices when we used them; in particular, we
additionally consider 6 of the 91 object categories: “person” (10777 bounding boxes), “car” (1918
bounding boxes), “truck” (414 bounding boxes), “motorcycle” (367 bounding boxes), “bike” (314
bounding boxes), and “bus” (283 bounding boxes). We split the COCO validation set into 2000
synthesis images and 3000 test images.

Correctness. Our goal is to detect a majority of people. In particular, we consider synthesizing a

threshold 𝑐 and selecting all bounding boxes with probability above 𝑐—i.e.,

𝑓 (𝑥, 𝑐) = {𝑏 | (𝑏, 𝑝) ∈ 𝑓 (𝑥) ∧ 𝑝 ≥ 𝑐}.
This task is more challenging to specify than our examples so far since 𝑓 (𝑥) is a structured output.
In particular, we are not reasoning about whether 𝑓 (𝑥) is correct with high probability with respect
to 𝑝 (𝑥, 𝑦∗), but whether bounding boxes (𝑏, 𝑝) ∈ 𝑓 (𝑥) are correct. Thus, we need a distribution
𝑝 (𝑏 | 𝑥) over bounding boxes 𝑏 in an image 𝑥. Given such a distribution, our goal is to choose 𝑐 so
P𝑝 (𝑥,𝑦∗),𝑝 (𝑏 |𝑥) (𝑏 ˜∈ 𝑓 (𝑥, 𝑐) | 𝑏 ˜∈ 𝑦∗) ≥ 1 − 𝜖,
(15)
where 𝑝 (𝑥, 𝑦∗) is the data distribution. Intuitively, this property says that 𝑓 (𝑥, 𝑐) contains at least
a 1 − 𝜖 fraction of ground truth bounding boxes. A reasonable choice for 𝑝 (𝑏 | 𝑥) is the uniform
distribution over 𝑓 (𝑥, 0)—i.e., the set of all bounding boxes predicted by 𝑓 . One issue is when a
ground truth bounding box 𝑏 ∈ 𝑦∗ is completely missing from 𝑓 (𝑥, 0); in this case, 𝑏 would not
occur in 𝑝 (𝑏 | 𝑥), so (15) would not count it as an error even though it is missing from 𝑓 (𝑥, 𝑐) for
any 𝑐. To handle this case, we simply add (𝑏, 0) to 𝑓 (𝑥) during synthesis for such bounding boxes
𝑏—i.e., 𝑓 predicts 𝑏 occurs with probability zero.

The program for achieving this goal is shown in the subroutine detect_ppl in Figure 10. We
use our algorithm in conjunction with the synthesis examples to synthesize the parameter ??1 for
this program, using the default values 𝜖 = 𝛿 = 0.05 and the object category “person”. In Figure 11,
we show the recall (red), desired lower bound on recall (blue), and precision (black) as a function of
(a) 𝜖, (b) 𝛿, and (c) the object category 𝑦. The trends are largely similar to before—e.g., performance

, Vol. 1, No. 1, Article . Publication date: October 2021.

Synthesizing Machine Learning Programs

35

(a)

(d)

(g)

(b)

(e)

(h)

(c)

(f)

(i)

Fig. 11. For the slow model alone (top) and slow+fast model (middle), we show recall (red), the desired lower
bound on recall (blue), and precision (black) as a function of (a,d) 𝜖, (b,e) 𝛿, and (c,f) the object category 𝑦. For
slow+fast (black), slow alone (red), and fast alone (green), we show running time as a function of (g) 𝜖, (h) 𝛿,
and (i) the object category 𝑦.

varies significantly with 𝜖 and the object category, but not very much with 𝛿. For (c), we use 𝜖 = 0.1
to facilitate comparison to our fast program described below.

Improving speed. We use a similar approach to improve speed as before—i.e., given a fast object
detector 𝑓fast, we want to use it to check the image, and only send it to the slow object detector 𝑓 if
necessary. A challenge compared to image classification is that the object detection model does not
operate at the level of bounding boxes, which is the level at which we defined correctness, but at
the level of images. Thus, we cannot decide whether we want to run the slow model independently
for each detection 𝑑 ∈ 𝑓fast (𝑥); instead, we have to make such a decision for an image 𝑥 as a whole.
Intuitively, we check whether the fast model returns any detections in the given image 𝑥. To this
end, we compute the maximum score 𝑝 across all detections (𝑏, 𝑝) ∈ 𝑓fast (𝑥)—i.e.,

˜𝑓fast (𝑥) = max

(𝑏,𝑝) ∈𝑓fast (𝑥)

𝑝.

Then, we want to guarantee that 𝑦∗ = ∅ if this score is below some threshold that ensures that
𝑦∗ = ∅; this property is equivalent to its contrapositive

(𝑦∗ ≠ ∅) ⇒ (1 − ˜𝑓fast (𝑥) ≤ 𝑐),

(16)

, Vol. 1, No. 1, Article . Publication date: October 2021.

0.800.850.900.951.000.050.10.150.2Precision/Recall𝜀0.800.850.900.951.000.050.10.150.2Precision/Recall𝛿0.000.200.400.600.801.00PersonCarTruckMotorBikeBusPrecision/Recall0.600.700.800.901.000.050.10.150.2Precision/Recall𝜀0.800.850.900.951.000.050.10.150.2Precision/Recall𝛿0.000.200.400.600.801.00PersonCarTruckMotorBikeBusPrecision/Recall048120.050.10.150.2Time (Minutes)𝜀048120.050.10.150.2Time (Minutes)𝛿04812PersonCarTruckMotorBikeBusTime (Minutes)36

Bastani

where the right-hand side of the implication is equivalent to 𝑓fast (𝑥) ≥ 1 − 𝑐—i.e., the score is above
the threshold 1 − 𝑐. As before, we cannot ensure this property holds with probability one, so instead
we use the high-probability variant

P𝑝 (𝑥,𝑦∗) (1 − ˜𝑓fast (𝑥) ≤ 𝑐 | 𝑦∗ ≠ ∅) ≥ 1 − 𝜖.
This approach is shown in the detect_ppl_fast subroutine in Figure 10. We note that this approach
does not provide guarantees as strong as the ones for image classification—in particular, there is
a chance that the false negative images 𝑥 of 𝑓fast (i.e., 𝑥 does not satisfy (16)) will contain larger
numbers of ground truth bounding boxes compared to true positive images. Then, the recall at
the level of bounding boxes may be less than 1 − 2𝜖. However, we find that it works well in
practice; intuitively, 𝑓fast is more likely to have false negative images that contain fewer ground
truth bounding boxes.

For 𝑓fast, we use a variant of Faster R-CNN termed R50-FPN with 3× learning rate schedule, which
is the fastest variant available. Then, we synthesize the parameters of ??1 and ??2 in Figure 10
using the synthesis examples. As before, all results are run on an Nvidia GeForce RTX 2080 Ti
GPU. In Figure 11, we show the recall (red), desired lower bound on recall (blue), and precision
(black) of our approach as a function of (d) 𝜖, (e) 𝛿, and (f) the object category 𝑦. Similarly, we
show the running time (on the entire test set) of the combined program slow+fast (black), fast
alone (green), and slow alone (red). As can be seen, our approach reduces running time by more
than 2× except in the case of “person” (28% reduction) and “truck” (45% reduction). The person
speedup is relatively small because so many of the images in the COCO dataset contain people.
Compared to the image classification setting, we obtain a smaller speedup since the gap between
the fast and slow models is not as large, and also because we can only avoid using the slow model
for images that contain zero detections. Furthermore, comparing Figure 11 (c) and (f) (i.e., slow
alone vs. slow+fast, respectively), for categories “car” and “truck”, we suffer no loss in precision,
though we suffer a small loss in precision for the others.

Finally, we note that in Figure 11 (e), for 𝛿 = 0.15 and 𝛿 = 0.2, the estimated recall falls slightly
below the desired lower bound on recall. This result is most likely due to random chance, either
because of randomness in the synthesis set or because these values are estimates based on a random
test set. In particular, 0.15 is a fairly high failure probability (note that the results across 𝛿 are
correlated, since we are using the same synthesis and test sets across all 𝛿).

Runtime monitoring. We use runtime monitors to check that our program meets the desired
bounds both in terms of error rate (the subroutine monitor_correctness in Figure 10) and running
time (the subroutine monitor_speed in Figure 10). These approaches are the same as for image
classification—the correctness monitor checks that the error rate (i.e., 𝑓fast (𝑥) concludes there are
no detections but 𝑓 (𝑥) ≠ ∅) is below the desired rate 𝜖, and the running time monitor checks that
𝑓 is not called too often (i.e., 𝑓fast (𝑥) concludes there are no detections sufficiently frequently).

To evaluate these monitors, we consider a shift from the default “large” bounding boxes we use
to “small” and “medium”. Intuitively, the smaller bounding boxes correspond to objects farther in
the background, which are harder to detect but also tend to be less important (e.g., an autonomous
car may not care as much about detecting far-away pedestrians). The trends are as before. First, we
find that the monitors correctly prove correctness when there is no shift. Second, we find that the
running time does not increase due to the shift, so the running time monitor continues to prove
correctness. Finally, our correctness monitor rejects correctness for the shift to “small” bounding
boxes; interestingly, it proves correctness for “medium” bounding boxes, which suggests that our
synthesized program generalizes to this case.

, Vol. 1, No. 1, Article . Publication date: October 2021.

