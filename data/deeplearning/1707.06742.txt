7
1
0
2

g
u
A
1
1

]

G
L
.
s
c
[

3
v
2
4
7
6
0
.
7
0
7
1
:
v
i
X
r
a

Machine Teaching
A New Paradigm for Building Machine Learning Systems

Patrice Y. Simard
Saleema Amershi
David M. Chickering
Alicia Edelman Pelton
Soroush Ghorashi
Christopher Meek
Gonzalo Ramos
Jina Suh
Johan Verwey
Mo Wang
John Wernsing
Microsoft Research, One Microsoft Way, Redmond, WA 98052, USA

patrice@microsoft.com
samershi@microsoft.com
dmax@microsoft.com
aliciaep@microsoft.com
sorgh@microsoft.com
meek@microsoft.com
goramos@microsoft.com
jinsuh@microsoft.com
joverwey@microsoft.com
mowan@microsoft.com
johnwer@microsoft.com

Abstract

The current processes for building machine
learning systems require practitioners with
deep knowledge of machine learning. This
signiﬁcantly limits the number of machine
learning systems that can be created and has
led to a mismatch between the demand for
machine learning systems and the ability for
organizations to build them. We believe that
in order to meet this growing demand for ma-
chine learning systems we must signiﬁcantly
increase the number of individuals that can
teach machines. We postulate that we can
achieve this goal by making the process of
teaching machines easy, fast and above all,
universally accessible.

While machine learning focuses on creating
new algorithms and improving the accuracy
of “learners”, the machine teaching discipline
focuses on the eﬃcacy of the “teachers”. Ma-
chine teaching as a discipline is a paradigm
shift that follows and extends principles of
software engineering and programming lan-
guages. We put a strong emphasis on the
teacher and the teacher’s interaction with
data, as well as crucial components such as
techniques and design principles of interac-
tion and visualization.

In this paper, we present our position re-
garding the discipline of machine teaching
and articulate fundamental machine teaching

principles. We also describe how, by decou-
pling knowledge about machine learning al-
gorithms from the process of teaching, we can
accelerate innovation and empower millions
of new uses for machine learning models.

1. Introduction

The demand for machine learning (ML) models far
exceeds the supply of “machine teachers” that can
build those models. Categories of common-sense un-
derstanding tasks that we would like to automate with
computers include interpreting commands, customer
support, or agents that perform tasks on our behalf.
The combination of categories, domains, and tasks
leads to millions of opportunities for building special-
ized, high-accuracy machine learning models. For ex-
ample, we might be interested in building a model to
understand voice commands for controlling a televi-
sion or building an agent for making restaurant reser-
vations. The key to opening up the large space of solu-
tions to is to increase the number of machine teachers
by making the process of teaching machines easy, fast
and universally accessible.

A large fraction of the machine learning community is
focused on creating new algorithms to improve the ac-
curacy of the “learners” (machine learning algorithms)
on given labeled data sets. The machine teaching
(MT) discipline is focused on the eﬃcacy of the teach-
ers given the learners. The metrics of machine teaching
measure performance relative to human costs, such as

 
 
 
 
 
 
Machine Teaching

productivity, interpretability, robustness, and scaling
with the complexity of the problem or the number of
contributors.

Many problems that aﬀect model building productiv-
ity are not addressed by traditional machine learning.
One such problem is concept evolution, a process in
which the teacher’s underlying notion of the target
class is deﬁned and reﬁned over time (Kulesza et al.,
2014). Label noise or inconsistencies can be detrimen-
tal to traditional machine learning because it assumes
that the target concept is ﬁxed and is deﬁned by the
labels. In practice, concept deﬁnitions, schemas, and
labels can change as new sets of rare positives are dis-
covered or when teachers simply change their minds.

Consider a binary classiﬁcation task for gardening web
pages where the machine learner and feature set is
ﬁxed. The teacher may initially label botanical gar-
den web pages as positive examples for the gardening
concept, but then later decide that these are negative
examples. Relabeling the examples when the target
concept evolves is a huge burden on the teacher. From
a teacher’s perspective, concepts should be decompos-
able into sub-concepts and the manipulation of the
relationship between sub-concepts should be easy, in-
terpretable, and reversible. At the onset, the teacher
could decompose gardening into sub-concepts (that in-
clude botanical gardens) and label the web page ac-
cording to this concept schema.

In this scenario, labeling for sub-concepts has no ben-
eﬁts to the machine learning algorithm, but it beneﬁts
the teacher by enabling concept manipulation. Manip-
ulation of sub-concepts can be done in constant time
(i.e., not dependent on the number of labels), and the
teacher’s semantic decisions can be documented for
communication and collaboration. Addressing concept
evolution is but one example of where the emphasis on
the teacher’s perspective can make a large diﬀerence
in model building productivity.

Machine teaching is a paradigm shift away from ma-
chine learning, akin to how other ﬁelds in program-
ming language have shifted from optimizing perfor-
mance to optimizing productivity with the notions of
functional programming, programming interfaces, ver-
sion control, etc. The discipline of machine teaching
follows and extends principles of software engineering
and languages that are fundamental to software pro-
ductivity. Machine teaching places a strong empha-
sis on the teacher and the teacher’s interaction with
data, and techniques and design principles of interac-
tion and visualization are crucial components. Ma-
chine teaching is also directly connected to machine
learning fundamentals as it deﬁnes abstractions and

interfaces between the underlying algorithm and the
teaching language. Therefore, machine teaching lives
at the interaction of the human-computer interaction,
machine learning, visualization, systems and engineer-
ing ﬁelds. The goal of this paper is to explore machine
learning model building from the teacher’s perspec-
tive.

2. The need for a new discipline

In 2016, at one of Microsoft’s internal conferences
(TechFest) during a panel titled “How Do We Build
and Maintain Machine Learning Systems?”, the host
started the discussion by asking the audience “What is
your worst nightmare?” in the context of building ma-
chine learning models for production. A woman raised
her hand and gave the ﬁrst answer:

“[...] Manage versions. Manage data ver-
sions. Being able to reproduce the models.
What if, you know, the data disappears, the
person disappears, the model disappears...
And we cannot reproduce this. I have seen
this hundreds of times in Bing. I have seen
it every day. Like... Oh yeah, we had a good
I need to
model. Ok, I need to tweak it.
understand it. And then... Now we cannot
reproduce it. That is my biggest nightmare!”

To put context to this testimony, we review what
building a machine learning model may look like in
a product group:

1. A problem owner collects data, writes labeling
guidelines, and optionally contributes some labels.

2. The problem owner outsources the task of labeling
a large portion of the data (e.g., 50,000 examples).

3. The problem owner examines the labels and may
discover that the guidelines are incorrect or that
the sampled examples are inappropriate or in-
adequate for the problem. When that happens,
GOTO step 1.

4. An ML expert is consulted to select the algorithm
(e.g., deep neural network), the architecture (e.g.,
number of layers, units per layer, etc.), the objec-
tive function, the regularizers, the cross-validation
sets, etc.

5. Engineers adjust existing features or create new
features to improve performance. Models are
trained and deployed on a fraction of traﬃc for
testing.

6. If the system does not perform well on test traﬃc,

2.1. Deﬁnitions of machine learning and

GOTO step 1

machine teaching

Machine Teaching

7. The model is deployed on full traﬃc. Performance
of the model is monitored, and if that performance
goes below a critical level, the model is modiﬁed
by returning to step 1.

An iteration through steps 1 to 6 typically takes weeks.
The system can be stable at step 7 for months. When
it eventually breaks, it can be for a variety of reasons:
the data distribution has changed, the competition
has improved and the requirements have increased,
new features are available and some old features are
no longer available, the deﬁnition of the problem has
changed, or a security update or other change has bro-
ken the code. At various steps, the problem owner,
the machine learning expert, or the key engineer may
have moved on to another group or another company.
The features or the labels were not versioned or doc-
umented. No one understands how the data was col-
lected because it was done in an ad hoc and organic
fashion. Because multiple players with diﬀerent ex-
pertise are involved, it takes a signiﬁcant amount of
eﬀort and coordination to understand why the model
does not perform as well as expected after being re-
trained. In the worst case, the model is operating but
no one can tell if it is performing as expected, and
no one wants the responsibility of turning it oﬀ. Ma-
chine learning “litter” starts accumulating everywhere.
These problems are not new to machine learning in
practice (Sculley et al., 2014).

The example above illustrates the fact that building a
machine learning model involves more than just col-
lecting data and applying learning algorithms, and
that the management process of building machine
learning solutions can be fraught with ineﬃciencies.
There are other forms of ineﬃciencies that are deeply
embedded in the current machine learning paradigm.
For instance, machine learning projects typically con-
sist of a single monolithic model trained on a large
labeled data set. If the model’s summary performance
metrics (e.g., accuracy, F1 score) were the only re-
quirements and the performance remained unchanged,
adding examples would not be a problem even if the
new model errs on the examples that were previously
predicted correctly. However, for many problems for
which predictability and quality control are important,
any negative progress on the model quality leads to
laborious testing of the entire model and incurs high
maintenance cost. A single monolithic model lacks the
modularity required for most people to isolate and ad-
dress the root cause of a regression problem.

It is diﬃcult to argue that the challenges discussed
above are given a high priority in the world’s best
machine learning conferences. These problems and
ineﬃciencies do not stem from the machine learning
algorithm, which is the central topic of the machine
learning ﬁeld; they come from the processes that use
machine learning, from the interaction between people
and machine learning algorithms, and from people’s
own limitations.

To give more weight to this assertion, we will deﬁne
the machine learning research ﬁeld narrowly as:

Deﬁnition 2.1 (Machine learning research)
Machine Learning research aims at making the
learner better by improving ML algorithms.

This ﬁeld covers, for instance, any new variations or
breakthroughs in deep learning, unsupervised learning,
recurrent networks, convex optimization, and so on.

Conversely, we see version control, concept decomposi-
tion, semantic data exploration, expressiveness of the
teaching language, interpretability of the model, and
productivity as having more in common with program-
ming and human-computer interaction than with ma-
chine learning. These “machine teaching” concepts,
however, are extraordinarily important to any practi-
tioners of machine learning. Hence, we deﬁne a disci-
pline aimed at improving these concept as:

Deﬁnition 2.2 (Machine teaching research)
Machine teaching research aims at making the teacher
more productive at building machine learning models.

We have chosen these deﬁnitions to minimize the inter-
section between the two ﬁelds and thus provide clarity
and scoping. The two disciplines are complementary
and can evolve independently. Of course, like any gen-
eralization, there are limitations. Curriculum learn-
ing (Bengio et al., 2009), for instance, could be seen
as belonging squarely in the intersection because it in-
volves both a learning algorithm and teacher behavior.
Nevertheless, we have found these deﬁnitions useful to
decide what to work on and what not to work on.

2.2. Decoupling machine teaching from

machine learning

Machine teaching solutions require one or more ma-
chine learning algorithms to produce models through-
out the teaching process (and for the ﬁnal output).
This requirement can make things complex for teach-
ers. Diﬀerent deployment environments may support

Machine Teaching

diﬀerent runtime functions, depending on what re-
sources are available (e.g., DSPs, GPUs, FPGAs, tight
memory or CPU constraints) or what has been imple-
mented and green-lighted for deployment. Machine
learning algorithms can be understood as “compilers”
that convert the teaching information to an instance
of the set of functions available at runtime. For ex-
ample, each such instance might be characterized by
the weights in a neural network, the “means” in K-
means, the support vectors in SVMs, or the decisions
in decision trees. For each set of runtime functions,
diﬀerent machine learning compilers may be available
(e.g., LBFGS, stochastic gradient descent), each with
its own set of parameters (e.g., history size, regulariz-
ers, k-folds, learning rates schedule, batch size, etc.)

Machine teaching aims at shielding the teacher from
both the variability of the runtime and the complex-
ity of the optimization. This has a performance cost:
optimizing for a target runtime with expert control of
the optimization parameters will always outperform
generic parameter-less optimization. It is akin to in-
lining assembly code. But like high-level programming
languages, our goal with machine teaching is to reduce
the human cost in terms of both maintenance time
and required expertise. The teaching language should
be “write once, compile anywhere”, following the ISO
C++ philosophy.

Using well-deﬁned interfaces describing the inputs
(feature values) and outputs (label value predictions)
of machine learning algorithms, the teaching solution
can leverage any machine learning algorithms that
support these interfaces. We impose three additional
system requirements:

1. The featuring language available to the teacher
should be expressive enough to enable examples
to be distinguished in meaningful ways (a hash of
a text document has distinguishing power, but it
is not considered meaningful). This enables the
teacher to remove feature blindness without nec-
essarily increasing concept complexity.

2. The complexity (VC dimension) of the set of func-
tions that the system can return increases with
the dimension of the feature space. This enables
the teacher to decrease the approximation error
by adding features.

3. The available ML algorithms must satisfy the
classical deﬁnition of learning consistency (Vap-
nik, 2013). This enables the teacher to decrease
the estimation error by adding labeled examples.

The aim of these requirements is to enable teachers to

create and debug any concept function to an arbitrary
level of accuracy without being required to understand
the runtime function space, learning algorithms, or op-
timization.

3. Analogy to programming

In this section, we argue that teaching machines is a
form of programming. We ﬁrst describe what machine
teaching and programming have in common. Next, we
highlight several tools developed to support software
development that we argue are likely to provide valu-
able guidance and inspiration to the machine teaching
discipline. We conclude this section with a discussion
of the history of the discipline of programming and
how it might be predictive of the trajectory of the dis-
cipline of machine teaching.

3.1. Commonalities and diﬀerences between

programming and teaching

Assume that a software engineer needs to create a
stateless target function (e.g., as in functional pro-
gramming) that returns value Y given input X. While
not strictly sequential, we can describe the program-
ming process as a set of steps as follows:

1. The target function needs to be speciﬁed

2. The target function can be decomposed into sub-

functions

3. Functions (including sub-functions) need to be

tested and debugged

4. Functions can be documented

5. Functions can be shared

6. Functions can be deployed

7. Functions need to be maintained (scheduled and

unscheduled debug cycles)

Further assume that a teacher wants to build a target
classiﬁcation function that returns class Y given in-
put X. The process for machine teaching presented in
the previous section is similar to the set of program-
ming steps above. While there are strong similarities,
there are also signiﬁcant diﬀerences, especially in the
debugging step (Table 1).

In order to strengthen the analogy between teaching
and programming, we need a machine teaching lan-
guage that lets us express these steps in the context
of a machine learning model building task. For pro-
gramming, the examples of languages include C++,

Machine Teaching

Table 1. Comparison of debugging steps in programming and machine teaching

Debugging in programming
(3) Repeat:

Debugging in machine teaching
(3) Repeat:

(a) Inspect
(b) Edit code
(c) Compile
(d) Test

(a) Inspect
(b) Edit/add knowledge (e.g., labels, features, ...)
(c) Train
(d) Test

Python, JavaScript, etc. which can be compiled into
machine language for execution. For teaching, the lan-
guage is a means of expressing teacher knowledge into
a form that a machine learning algorithm can leverage
for training. Teacher knowledge does not need to be
limited to providing labels but can be a combination
of schema constraints (e.g., mutually exclusive labels
for classiﬁcation, state transition constraints in entity
extraction1), labeled examples, and features. Just as
new programing languages are being developed to ad-
dress current limitations, we expect that new teaching
languages will be developed that allow the teacher to
communicate diﬀerent types of knowledge and to com-
municate knowledge more eﬀectively.

3.2. Programming paving the way forward

As we have illustrated in the previous sections, cur-
rent machine learning processes require multiple peo-
ple of diﬀerent expertise and strong knowledge depen-
dency among them, there are no standards or tooling
for versioning of data and models, and there is a strong
co-dependency between problem formulation, training
and the underlying machine learning algorithms. For-
tunately, the emerging discipline of machine teaching
can leverage lessons learned from the programming,
software engineering and related disciplines. These
disciplines have developed over the last half century
and addressed many analogous problems that machine
teaching aims to solve. This is not surprising given
their strong commonalities. In this section, we high-
light several lessons and relate them to machine teach-
ing.

3.2.1. Solving complex problems

The programming discipline has developed and im-
proved a set of tools, techniques and principles that
allow software engineers to solve complex problems in
ways that allow for eﬃcient, maintainable and under-
standable solutions. These principles include problem
decomposition, encapsulation, abstraction, and design

1In an address recognizer, we might want to require that

the zip code appears after the state.

patterns. Rather than discussing each of these, we con-
trast the diﬀering expectations between software engi-
neers solving a complex problem and machine teachers
solving a complex problem. One of the most power-
ful concepts that allowed software engineers to write
systems that solve complex problems is that of decom-
position. The next anecdote illustrates its importance
and power.

We asked dozens of software engineers the following:

1. Can you write a program that correctly imple-

ments the game Tetris?

2. Can you do it in a month?

The answer to the ﬁrst question is universally “yes”.
The answer to the second question varies from “I think
so” to “why would it take more than 2 days?”. The
ﬁrst question is arguably related to the Church-Turing
thesis which states that all computable functions are
computable by a Turing machine. If a human can com-
pute the function, there exists a program that can per-
form the same computation on a Turing machine. In
other words, given that there is an algorithm to imple-
ment the Tetris game, most respectable software en-
gineers believe they can also implement the game on
whatever machine they have access to and in whatever
programming language they are familiar with. The
answer to the second question is more puzzling. The
state space in a Tetris game (informally the number of
conﬁgurations of the pieces on the screen) is very large,
in fact, far larger than can be examined by the software
engineer. Indeed, one might expect that the complex-
ity of the program should grow exponentially with the
size of the representation of a state in the state space.
Yet, the software engineers seem conﬁdent that they
can implement the game in under a month. The most
likely explanation is that they consider the complexity
of the implementation and the debugging to be poly-
nomial in both the representation of the state space
and the input.

Let us examine how machine learning experts react
to similar questions asked about teaching a complex

Machine Teaching

problem:

1. Can you teach a machine to recognize kitchen

utensils in an image as well as you do?

2. Can you do it in a month?

When these questions were asked to another handful of
machine learning experts, the answers were quite var-
ied. While one person answered “yes” to both ques-
tions without hesitation, most machine learning ex-
perts were less conﬁdent about both questions with
answers including “probably”, “I think so”, “I am not
sure”, and “probably not”. Implementing the Tetris
game and recognizing simple non-deformable objects
seem like fairly basic functions in either ﬁelds, thus it
is surprising that the answers to both sets of questions
are so diﬀerent.

The goal of both programming and teaching is to cre-
ate a function. In that respect, the two activities have
far more in common than they have diﬀerences.
In
both cases we are writing functions, so there is no rea-
son to think that the Church-Turing thesis is not true
for teaching. Despite the similarities, the expectations
of success for creating, debugging, and maintaining
such function diﬀer widely between software engineers
and teachers. While the programming languages and
teaching languages are diﬀerent, the answers to the
questions were the same for all software engineers re-
gardless of the programming languages. Yet, most ma-
chine learning experts did not give upper bounds on
how long it would take to solve a teaching problem,
even when they thought the problem was solvable.

Software engineers have the conﬁdence of being able
to complete the task in a reasonable time because
they have learned to decompose problems into smaller
problems. Each smaller problem can be further de-
composed until coding and debugging can be done in
constant or polynomial time. For instance, to code
Tetris, one can create a state module, a state transfor-
mation module, an input module, a scoring module, a
shape display module, an animation module, and so
on. Each of these modules can be further decomposed
into smaller modules. The smaller modules can then
be composed and debugged in polynomial time. Given
that each module can be built eﬃciently, software en-
gineers have conﬁdence that they can code Tetris in
less than a month’s time.

It is interesting to observe that that the ability to de-
compose a problem is a learned skill and is not easy to
learn. A smart student could understand and learn all
the functions of a programming language (variables,
in a
arrays, conditional statements, for loops, etc.)

week or two. If the same student was asked to code
Tetris after two weeks, they would not know where to
start. After 6 to 12 months of learning how to pro-
gram, most software engineers would be able to ac-
commodate the task of programming the Tetris game
in under a month.

Akin to how decomposition brings conﬁdence to soft-
ware engineers2 and an upper bound to solving com-
plex problems, machine teachers can learn to decom-
pose complex machine learning problems with the
right tools and experiences, and the machine teach-
ing discipline can bring the expectations of success for
teaching a machine to a level comparable to that of
programming.

3.2.2. Scaling to multiple contributors

The complexity of the problems that software engi-
neers can solve has increased signiﬁcantly over the past
half century, but there are limits to the scale of prob-
lems that one software engineer can solve. To address
this, many tools and techniques have been developed
to enable multiple engineers to contribute to the solu-
tion of a problem. In this section, we focus on three
concepts - programming languages, interfaces (APIs),
and version control.

One of the key developments that enables scaling with
the number of contributors is the creation of standard-
ized programming languages. The use of a standard-
ized programming language along with design pat-
terns and documentation enables other collaborators
to read, understand and maintain the software. The
analog to programming languages for machine teach-
ing is the expressions of a teacher’s domain knowledge
which include labels, features and schemas. Currently,
there is no standardization of the programming lan-
guages for machine teaching.

Another key development that enables scaling with the
number of contributors is the use of componentization
and interfaces, which are closely related to the idea of
problem decomposition discussed above. Componen-
tization allows for a separation of concerns that re-
duces development complexity, and clear interfaces al-
low for independent development and innovation. For
instance, a software engineer does not need to consider
the details of the hardware upon which the solution
will run. For machine teaching, the development of
clear interfaces for services required for teaching, such
as training, sampling and featuring, would enable inde-
pendent teaching. In addition, having clear interfaces

2For similar reasons, the ability to decompose also bring
conﬁdence to professional instructors and animal trainers.

Machine Teaching

for models, features, labels, and schemas enables com-
posing these constituent parts to solve more complex
problems, and thus, allowing for their use in problem
decomposition.

The ﬁnal development that enables scaling with the
number of contributors is the development of version
control systems. Modern version control systems sup-
port merging contributions by multiple software engi-
neers, speculative development, isolation of bug ﬁxes
and independent feature development, and rolling back
to previous versions among many other beneﬁts. The
primary role of a version control system is to track and
manage changes to the source code rather than keeping
track of the compiled binaries. Similarly, in machine
teaching, a version control system could support man-
aging the changes of the labels, features, schemas, and
learners used for building the model and enable re-
producibility and branching for experimentation while
providing documentation and transparency necessary
for collaboration.

3.2.3. Supporting the development of

problem solutions

In the past few decades, there has been an explosion
of tools and processes aimed at increasing program-
ming productivity. These include the development of
high-level programming languages, innovations in inte-
grated development environments, and the creation of
development processes. Some of these tools and pro-
cesses have a direct analog in machine teaching, and
some are yet to be developed and adapted. Table 2
presents a mapping of many of these tools and con-
cepts to machine teaching.

3.3. The trajectory of the machine teaching

discipline

We conclude this section with a brief review of the
history of programming and how that might inform
the trajectory of the machine teaching discipline. The
history of programming is inexorably linked to the de-
velopment of computers. Programming started with
scientiﬁc and engineering tasks (1950s) with few pro-
grams and programming languages like FORTRAN
that focused on compute performance. In the 1960s,
the range of problems expanded to include manage-
ment information systems and the range of program-
ming languages expanded to target speciﬁc application
domains (e.g., COBOL). The explosion of the number
of software engineers led to the realization that scal-
ing with contributors was diﬃcult (Brooks Jr, 1995).
In the 1980s, the scope of problems to which pro-
gramming was applied exploded with the advent of

the personal computer as did the number of software
engineers solving the problems (e.g., with Basic). Fi-
nally, in the 1990s, another explosive round of growth
began with the advent of web programming and pro-
gramming languages like JavaScript and Java. As of
writing this paper, the number of software engineers
in the world is approaching 20 million!

Machine teaching is undergoing a similar explosion.
Currently, much of the machine teaching eﬀort is un-
dertaken by experts in machine learning and statistics.
Like the story of programming, the range of problems
to which machine learning has been applied has been
expanding. With the deep-learning breakthroughs in
perceptual tasks in the 2010s (e.g., speech, vision, self-
driving cars), there has been an incredible eﬀort to
broaden the range of problems addressed by teaching
machines to solve the problems. Similar to the expand-
ing population of software engineers, the advent of ser-
vices like LUIS.ai3 and Wit.ai4 have enabled domain
experts to build their own machine learning models
with no machine learning knowledge. The discipline of
machine teaching is young and in its formative stages.
One can only expect that this growth will continue
at an even quicker pace.
In fact, machine teaching
might be the path to bringing machine learning to the
masses.

4. The role of teachers

The role of the teacher is to transfer knowledge to the
learning machine so that it can generate a useful model
that can approximate a concept. Let’s deﬁne what we
mean by this.

Deﬁnition 4.1 (Concept) A concept is a mapping
from any example to a label value.

For example, the concept of a recipe web page can
be represented by a function that returns zero or
one, based on whether a web page contains a cooking
recipe.
In another example, an address concept can
be represented by a function that, given a document,
returns a list of token ranges, each labeled “address”,
“street”, “zip”, “state”, etc. Label values for a binary
concept could be “Is” and “Is Not”. We may also
allow a “Undecided” label which allows a teacher to
postpone labeling decisions or ignore ambiguous ex-
amples. Postponing a decision is important because
the concept may be evolving in the teacher’s head.
An example of this is in (Kulesza et al., 2014).

Deﬁnition 4.2 (Feature) A feature is a concept that

3https://www.luis.ai/
4https://wit.ai/

Machine Teaching

Table 2. Mapping between programming and machine teaching
Programming
Compiler

Machine teaching
ML Algorithms (Neural Networks, SVMs)

Operating System/Services/IDEs

Training, Sampling, Featuring Services,
etc.

Frameworks

ImageNet, word2vec, etc.

Programming Languages (Fortran,
Python, C#)

Labels, Features, Schemas, etc.

Programming Expertise

Teaching Expertise

Version Control

Version Control

Development Processes (speciﬁcations,
unit testing, deployment, monitoring,
etc.)

Teaching Processes (data collection,
testing, publishing, etc.)

assigns each example a scalar value.

We usually use feature to denote a concept when em-
phasizing its use in a machine learning model. For
example, the concept corresponding to the presence or
absence of the word “recipe” in text examples might
be a useful feature when teaching the recipe concept.

Deﬁnition 4.3 (Teacher) A teacher is the person
who transfers concept knowledge to a learning ma-
chine.

To clarify this deﬁnition of a teacher, the methods of
knowledge transfer need to be deﬁned. At this point,
they include a) example selection (biased), b) label-
ing, c) schema deﬁnition (relationship between labels),
d) featuring, and e) concept decomposition (where
features are recursively deﬁned as sub-models). The
teachers are expected to make mistakes in all the forms
of knowledge transfer. These teaching “bugs” are com-
mon occurrences.

Figure 1 illustrates how concepts, labels, features, and
teachers are related. We assume that every concept is
a computable function of a representation of examples.
The representation is assumed to include all available
information about each example. The horizontal axis
represents the (inﬁnite) space of examples. The verti-
cal axis represents the (inﬁnite) space of programs or
concepts. In computer science theory, programs and
examples can be represented as (long) integers. Us-
ing that convention, each integer number on the ver-
tical axis could be interpreted as a program, and each

integer number on the horizontal axis could be inter-
preted as an example. We ignore the programs that
do not compile and the examples that are nonsensical.
We now use Figure 1 to refer to the diﬀerent ways a
teacher can pass information to a learning system.

Deﬁnition 4.4 (Selection) Selection is the process
by which teachers gain access to an example that ex-
empliﬁes useful aspects of a concept.

Teachers can select speciﬁc examples by ﬁltering the
set of unlabeled examples. By choosing these ﬁl-
ters deliberately, they can systematically explore the
space and discover information relevant to concepts.
For example, a teacher may discover insect recipes
while building a recipe classiﬁer by issuing a query on
“source of proteins”. We note that uniform sampling
and uncertainty sampling, which have no explicit input
from a teacher, are likely of little use for discovering
rare clusters of positive examples. Combinations of se-
mantic ﬁlters involving trained models are even more
powerful (e.g., “nutrition proteins” and low score with
current classiﬁer). This ability to ﬁnd examples con-
taining useful aspects of a concept enables the teacher
to ﬁnd useful features and provide the labels to train
them. Furthermore, the selection choices themselves
can be valuable documentation of the teaching pro-
cess.

Deﬁnition 4.5 (Label) A label is a (example, con-
cept value) pair created by a teacher in relation to a
concept.

Machine Teaching

Figure 1. Representation of examples and concepts. Each column represents an example and contains all concept values
for that example. A teacher looks in that direction to “divine” a label. The teacher has access to feature concepts not
available to the training set (it is part of the teaching power). However, the teacher does not know his/her own program.
Each row represents a concept and contains the value of that concept for all examples. A teacher looks in that direction
to “divine” the usefulness of a feature concept. A teacher can guess the values over the space of examples (it is part of
the teaching power). Features selected by the teacher looking horizontally are immune to over-training.

Teachers can provide labels by “looking at a column”
in Figure 1. It is important to realize that the teachers
do not know which programs are running in their heads
when they evaluate the target concept values. If they
knew the programs, they would transfer their knowl-
edge in programmatic form to the machine and would
not need machine learning. Teachers instead look at
the available data of an example and “divine” its label.
They do this by unconsciously evaluating sub-features
and combining them to make labeling decisions. The
feature spaces and the combination functions available
to the teachers are beyond what is available through
the training sets. This power is what makes the teach-
ers valuable for the purpose of creating labels.

Deﬁnition 4.6 (Schema) A schema is a relation-
ship graph between concepts.

When multiple concepts are involved, a teacher can
express relationship between them. For instance, the
teacher could express that the concepts “Tennis” and
“Soccer” are mutually exclusive, or that concept “Ten-
nis” implies the concept “Sport”. These concept con-
straints are relationships between lines on the dia-
gram (true across all examples). Separating knowl-
edge captured by the schema from the knowledge cap-
tured by the labels allows information to be conveyed

and edited at a high level. The implied labels can
be changed simply by changing the concept relation-
ship. For instance, “Golf” could be moved from being
a sub-concept of “Sport” to being mutually exclusive
or vice versa. Teachers can understand and change
the semantics of a concept by reviewing its schema.
Semantic decisions can be reversed without editing in-
dividual labels.

Deﬁnition 4.7 (Generic feature) A generic fea-
ture is a set of related feature functions.

are

features

created by engineers

Generic
in
parametrizable form, and teachers instantiate individ-
ual features by providing useful and semantic parame-
ters. For instance, a generic feature could be: “Log(1
+ number of instances of words in list X in a docu-
ment)” and an instantiation would be setting X to a
list of car brands (useful for an automotive classiﬁer).

Given a set of generic features, teachers have the abil-
ity to evaluate diﬀerent (instantiated) features by look-
ing along the corresponding horizontal lines in Fig-
ure 1. Given two features, the teachers can “divine”
that one is better than the other on a large unlabeled
set. For instance, a teacher may choose a feature that
measures the presence of the word “recipe” over a fea-
ture that measures the presence of the word “the”,

Machine Teaching

even though the latter feature might yield better re-
sults on the training set. This ability to estimate the
value of a feature over estimated distributions of the
test set is essential to feature engineering, and is prob-
ably the most useful capability of a teacher. Features
selected by the teacher in this manner are immune to
over-training because they are created independently
of the training set. Note the contrast to “automatic
feature selection”, which only looks at the training set
and concept-independent statistics and is susceptible
to over-training.

Deﬁnition 4.8 (Decomposition) Decomposition is
the act of using simpler concepts to express more com-
plex ones.

Whereas teachers do not have direct access to the pro-
gram implementing their concept, they sometimes can
infer how these programs work. Socrates used to teach
by asking the right questions. The “right question” is
akin to providing a useful sub-concept, whose value
makes evaluating the overall concept easier. In other
words, Socrates was teaching by decomposition rather
than by examples. This ability is not equally available
to teachers. It is learned. It is essential to scaling with
complexity and with the number of teachers. It is the
same ability that helps software engineers decompose
functions into sub-functions. Software engineers also
acquire this ability with experience. As in program-
ming, teaching decompositions are not unique (in soft-
ware engineering, switching from one decomposition to
another is called refactoring).

The knowledge provided by the teacher through con-
cept decomposition is high level and modular. Each
concept implementation might provide its own exam-
ple selection, labels, schema, and features. These can
be viewed as documentation of interfaces and con-
tracts. Each concept implementation may be a black
box, but the concept hierarchy is transparent and in-
terpretable. Concept decomposition is the highest
form of knowledge provided by the teacher.

Now that we have deﬁned some of the key roles of the
(machine) teacher, we turn to the question of how do
we meet the demand for them.

Meeting the demand for teachers

We postulate that the right solution to satisfy the in-
creasing demand for machine learning models is to in-
crease the number of people that can teach machines
these models. But how do we do that and who are
they?

The current ML-focused work ﬂows put the machine

learning or data scientist on the driver’s seat. While
training more scientists is a way to increase the number
of teachers, we believe that that is not the right path
to follow. For starters, machine learning and data sci-
entists are a scarce and expensive resource. Secondly,
machine learning scientists can serve a better purpose
inventing and optimizing learning algorithms. In the
same way, data scientists are indispensable applying
their expertise to make sense of data and transform it
into a usable form.

The machine teaching process that we envision does
not require the skills of a ML expert or data scientist.
Machine teachers use their domain knowledge to pick
the right examples and counterexamples for a concept
and explain why they diﬀer. They do this through
an interactive information exchange with a learning
system. It is within the ranks of the domain experts
where we will ﬁnd the large population of machine
teachers that will increase, by orders of magnitude,
the number of ML models used to solve problems. We
can transform domain experts by making a machine
teaching language universally accessible.

A key characteristic of domain experts is that they
understand the semantics of a problem. To this point,
we argue that if a problem’s data does not need to be
interpreted by a person to be useful, machine teaching
is not needed. For example, problems for which the
labeled data is abundant or practically limitless; e.g.
Computer Vision, Speech Understanding, Genomics
Analysis, Click-Prediction, Financial Forecasting. For
these, powerful learning algorithms or hardware may
be the better strategy to arrive at an eﬀective solution.
In other problems like the above, feature selection us-
ing cross validation can be used to arrive at a good
solution without the need of a machine teacher.

There is nonetheless, an ever-growing set of prob-
lems for which machine teaching is the right approach;
problems where unlabeled data is plentiful and domain
knowledge to articulate a concept is essential. Exam-
ples of these include controlling Internet-of-Things ap-
pliances through spoken dialogs and the environment’s
context, or routing customer feedback for a brand new
product of a start-up to the right department, build-
ing a one-time assistant to help a paralegal sift through
hundreds of thousands of briefs, etc.

We aim at reaching the same number of machine teach-
ers as there are software engineers, a set counted in
the tens of millions. Table 3 illustrates the diﬀerences
in numbers between machine learning scientists, data
scientists, and domain experts. By enabling domain
experts to teach, we will enable them to apply their
knowledge to solve directly millions of meaningful, per-

Machine Teaching

sonal, shared, “one-oﬀ” and recurrent problems at a
scale that we have never seen.

5. Teaching process

A teaching or programming language can be applied in
many diﬀerent ways, some more eﬀective than others.
We propose the following principles for the language
and process of machine teaching:

Universal teaching language We do not rely on
the power of speciﬁc machine learning algorithms. The
teaching interface is the same for all algorithms.
If
a machine learning algorithm is swapped for another
one, more teaching may be necessary, but the teach-
ing language and the model building experience is not
changed. Machine learning algorithms should be inter-
changeable. Conversely, the teaching language should
be simple and easy to learn given the domain (e.g.,
text, signal,
Ideally, we aim at designing
an ANSI or ISO standard per domain. Teachers that
speak the same language should be interchangeable.

images).

Feature completeness (or realizability) We as-
sume that all the target concepts that a teacher may
want to implement are “realizable” through a recur-
sive composition of models and existing features. This
implies a property on the feature set, which we call
“feature completeness”. Feature completeness is the
responsibility of the teaching tool, not the teachers.
Teachers achieve realizability through the following ac-
tions:

1. Add missing features: If a teacher can distin-
guish two documents belonging to two diﬀerent
classes in a meaningful way, there must be a (cor-
responding) feature expressible in the system that
can make an equivalent semantically meaningful
distinction. By adding such a feature, the teacher
can correct feature blindness errors.
If no such
feature exists, the language is not feature com-
plete for distinguishing the desired classes.

2. Create features through decomposition: If
the concept function cannot be learned from the
existing set of features due to limitations of the
model class, the teacher can circumvent this prob-
lem by creating features that are themselves mod-
els; we call this process “model decomposition”.
To illustrate the point, suppose there are two bi-
nary features A and B, and the teacher would like
to produce a model for A ⊕ B (where ⊕ stands for
XOR) using logistic regression. Because of the
capacity limitations of logistic regression, it is im-
possible to represent A ⊕ B without additional

features. If the teacher adds a third AND feature
A∧B, however, logistic regression can work. Note
that A∧B is itself learnable via logistic regression
in the A and B feature space.

3. Explicitly ignore ambiguous patterns: Am-
biguous patterns can be marked as “don’t care”
to avoid wasting features, labels, and the teacher’s
time on diﬃcult examples. Areas of “don’t care”
are used as a coping mechanism to keep the real-
izability assumption despite the Bayes error rate.
This action does not constrain the feature set.

Feature completeness of a teaching language does not
imply that the language can be used to eﬃciently teach
concepts. If a feature complete language is not very
expressive, realizability can require a large number of
If a feature complete language
model compositions.
is too expressive (e.g. a features can be speciﬁed as
programs), the teachers have to become engineers.

Rich and diverse sampling set We call the set of
unlabeled documents accessible to the teacher when
building models the “sampling distribution”. We
call the set of documents for which models are built
the “deployment distribution”. The rich-and-diverse-
sampling-set principle is that the sampling distribution
captures the richness and diversity of examples in the
deployment distribution. The sampling distribution
and the deployment distributions are preferably simi-
lar, but they do not have to be perfectly matched. The
most important requirement of the sampling distribu-
tion is that all important types of documents be repre-
sented (rich and diverse). If important documents are
missing from the sampling distribution, performance
could be impacted in unpredictable ways. As a rule of
thumb, unlabeled data should be collected indiscrim-
inately because the cost of storing data is negligible
compared to the cost of teaching; we view selectively
collecting only the data that is meant to be labeled
as both risky and limiting5. A rich and diverse data
set allows the teacher to explore it to express knowl-
edge through selection. It also allows the teacher to
ﬁnd examples that can be used to train sub-concepts
that are more speciﬁc than the original concept. For
instance, a teacher could decide to build classiﬁers for
bonsai gardening (sub-concept) and botanical garden-
ing (excluded concept) to be used as features to a gar-
dening classiﬁer. The sampling set needs to be rich
enough to contain suﬃcient examples to successfully
learn the sub-concepts. The sampling distribution can

5For example, the collected set may not contain im-
portant examples that would otherwise be found via the
machine teaching process.

Machine Teaching

Potential teacher
Machine learning experts

Table 3. Where to ﬁnd machine teachers
Quantities
Tens of thousands

Data Scientist / Analyst

Hundreds of thousands

Domain expert

Tens of millions

Characteristics
Has profound understanding
of machine learning. Can
modify a machine learning
algorithm or architecture to
improve performance.
Can analyze big data, detect
trend and correlations using
machine learning. Can train
machine learning models on
existing values to extract
value for a business.
Understands the semantics of
a problem. Can provide
examples and counter
examples, and explain the
diﬀerence between them.

be updated or re-collected. Examples that have been
labeled by teachers, however, are kept forever because
labels always retain some semantic value.

Distribution robustness The assumption that the
training distribution matches the sampling or deploy-
ment distribution is unrealistic in practice. The role
of the teacher is to create a model that is correct for
any example, regardless of the deployment distribu-
tion. Given our assumption of feature completeness
and a rich and diverse sampling set, the result of a suc-
cessful teaching process should be robust to not know-
ing the deployment distributions.
Imagine program-
ming a “Sort” function. We expect “Sort” to work
regardless of the distribution of the data it is sorting.
Thanks to realizability, we have the same correctness
expectation for teaching. Because the training data is
discovered and labeled for the training set in an ad hoc
way using ﬁltering, distribution robustness is a critical
assumption and we therefore favor machine learning
algorithms that are robust to covariate shifts. Warn-
ing: having a mismatch between train and sampling
(or deployment) distributions complicates evaluation.

Modular development Decomposition is a central
principle of both programming and machine teach-
ing. The machine teaching process should support
the modular development of concept implementation.
This includes the decomposition of concepts into sub-
concepts, and the use of models as features for other
models. We can achieve this by standardizing model
and feature interfaces. Similar to a programming in-
tegrated development environment (IDE), within our
teaching IDE, concept implementation is done through

“projects” that are grouped into “solutions”. Projects
in a solution are trained together because their retrain-
ing can aﬀect each other. Dependencies across diﬀer-
ent solutions are treated as versioned packages, which
means that retraining a project in one solution does
not aﬀect a project in a diﬀerent solution (the teacher
must update the package reference to incorporate such
changes). The modular development principle encour-
ages the sharing of explicit concept implementations.

labels,
Version control All teacher actions (e.g.,
features,
label constraints, schema and dependency
graph, and even programming code if necessary) are
equivalent to a concept “program”. They are saved
in the same “commit”. Like programming code, the
teacher’s actions relevant to a concept are saved in a
version control system. Diﬀerent type of actions are
kept in diﬀerent ﬁles to facilitate merge operations be-
tween contributions from diﬀerent teachers.

The combination of these principles suggests a teach-
ing process that is diﬀerent from the standard teach-
ing process. The universal teaching language implies
that the machine learning expert can be left out of the
teaching loop. The featuring completeness principle
implies that the engineers can be left out of the teach-
ing loop as well. The teaching tool should provide the
teacher with all that is needed to build models eﬀec-
tively. The engineers can update the data pipeline and
the programming language, but neither are concept-
dependent so the engineer is out of the teaching loop.
These two principles imply that a single person with
domain and teaching knowledge can own the whole

Machine Teaching

repeat

while training set is realizable do
if quality criteria is met then

exit

end
// Actively and semantically explore sampling set using concept based ﬁlters.
Find a test error (i.e., an incorrectly predicted (example, label) pair);
Add example to training set.;

end
// Fix training set error
if training error is caused by labeling error(s) then

Correct labeling error(s);

else

// Fix feature blindness. This may entail one or more of the following actions:
Add or edit basic features;
Create a new concept/project for a new feature (decomposition);
Change label constraints or schema (high level knowledge);

end

until forever ;

Algorithm 1: A machine teaching process

process. The availability of a rich and diverse sam-
pling set means that the traditional data collection for
labeling step is not part of the concept teaching pro-
cess. The distribution robustness principle allows the
teacher to explore and label freely throughout the pro-
cess without worrying about balancing classes or ex-
ample types. Concept modularity and version control
guarantee that a function created in a project is repro-
ducible provided that (1) all of its features are deter-
ministic and (2) training is deterministic. The concept
modularity principle enables interpretability and scal-
ing with complexity. The interpretability comes from
being able to explain what each sub-concept does by
looking at the labels, features, or schema. Even if each
sub-concept is a black box inside, their interfaces are
transparent. The merge functionality in version con-
trol enables easy collaboration between multiple teach-
ers.

Based on the above, we propose a skeleton for a teach-
ing process in Algorithm 1. Note that this process is
not unique.

Evaluating the quality criteria in a distribution-robust
setting is diﬃcult and beyond the scope of this pa-
per. A simple criteria could be to pause when the
teacher’s cost or time invested reaches a given limit.
Finding test error eﬀectively is also diﬃcult and be-
yond the scope of this paper. The idea is to query
over the large sample set by leveraging query-speciﬁc
teacher-created concepts and sub-concepts. The art is
to maximize the semantic expressiveness of querying
and the diversity of results. Uncertainty sampling is

a trivial and uninteresting case (ambiguous examples
are not useful for coming up with new decomposition
concepts).

There are a few striking diﬀerences between the teach-
ing process above and the standard model building
process. The most important aspect is that it can be
done by a single actor operating on the true distribu-
tion. Knowledge transfer from teacher to learner has
multiple modalities (selection,
labels, features, con-
straints, schema). The process is a never-ending loop
reminiscent of Tom Mitchell’s NELL (Carlson et al.,
2010). Capacity is increased on demand, so there is no
need for traditional regularization because the teacher
controls the capacity of the learning system by adding
features only when necessary.

6. Conclusion

Over the past two decades, the machine learning ﬁeld
has devoted most of its energy to developing and im-
proving learning algorithms. For problems in which
data is plentiful and statistical guarantees are suﬃ-
cient, this approach has paid oﬀ handsomely. The
ﬁeld is now evolving toward addressing a larger set
of simpler and more ephemeral problems. While the
demand to solve these problems eﬀectively grows, the
access to teachers that can build corresponding solu-
tions is limited by their scarcity and cost. To truly
meet this demand, we need to advance the discipline
of machine teaching. This shift is identical to the shift
in the programming ﬁeld in the 1980s and 1990s. This

Machine Teaching

parallel yields a wealth of beneﬁts. This paper takes
inspiration from three lessons from the history of pro-
gramming. The ﬁrst one is problem decomposition and
modularity. They have allowed programming to scale
with complexity. We argue that a similar approach
has the same beneﬁts for machine teaching. The sec-
ond lesson is the standardization of programming lan-
guages: write once, run everywhere. This paper is not
proposing a standard machine teaching language, but
we enumerated the most important machine-learning-
agnostic knowledge channels available to the teacher.
The ﬁnal lesson is the process discipline, which in-
cludes separation of concerns and the building of stan-
dard tools and libraries. This addresses the same limi-
tations to productivity and scaling with the number of
contributors that plagued programming (as described
in the ”Mythical Man Month” (Brooks Jr, 1995)). We
have proposed a set of principles that lead to a better
teaching process discipline. Some of the tools of pro-
gramming, such as version control, can be used as is.
Some of these principles have been successfully applied
in services such as LUIS.ai and by product groups in-
side Microsoft such as Bing Local. We are in the early
stages of building a teaching interactive development
environment.

On a more philosophical note, large monolithic sys-
tems, as epitomized by deep learning, are a popular
trend in artiﬁcial intelligence. We see this as a form of
machine learning behaviorism. It is the idea that com-
plex concepts can be learned from a large set of (in-
put, output) pairs. With the aid of regularizers and/or
deep representations computed using unsupervised or
semi-supervised learning, the monolithic learning ap-
proach has yielded impressive results. This has been
the case in several ﬁelds where labeled data is abun-
dant (speech, vision, machine translation). The mono-
lithic approach, however, has limitations when labeled
data is hard to come by. Deep representations built
from unlabeled data optimize where the data is. Rare
misspellings that are domain speciﬁc are likely to be ig-
nored or misinterpreted if they appear more frequently
in a diﬀerent domain context. Corner cases with little
or no labels for autonomous-driving may be ignored
at great perils. Large (amorphic) models are hard to
interpret. These limitations can be overcome by in-
jecting semantic knowledge via active teaching (e.g.,
labels, features, structure). For this reason, we believe
that both large monolithic systems and systems more
actively supervised by teaching have important roles
to play in machine learning. As a bonus, they can
easily be combined to complement each other.

7. Acknowledgements

We thank Jason Williams for his support and contri-
butions to Machine Teaching. Jason is the creator
of the LUIS (Language Understanding Internet Ser-
vices) project, a service for building language under-
standing models, based on the principles mentioned
in this paper. We thank Riham Mansour and the
Microsoft Cairo team for co-building, maintaining,
and improving the www.LUIS.ai service. Finally, we
thank Matthew Hurst and his team for building high-
performing web page entity extractors leveraging our
machine teaching tools. These entity extractors are
deployed in Bing Local.

References

Yoshua Bengio, J´erˆome Louradour, Ronan Collobert,
and Jason Weston. 2009. Curriculum Learning. In
Proceedings of the 26th Annual International Con-
ference on Machine Learning (ICML ’09). ACM,
New York, NY, USA, 41–48. https://doi.org/
10.1145/1553374.1553380

Frederick P Brooks Jr. 1995. The Mythical Man-
Month: Essays on Software Engineering, Anniver-
sary Edition, 2/E. Pearson Education India.

Andrew Carlson, Justin Betteridge, Bryan Kisiel,
Burr Settles, Estevam R. Hruschka, Jr., and
Tom M. Mitchell. 2010.
Toward an Architec-
ture for Never-ending Language Learning. In Pro-
ceedings of the Twenty-Fourth AAAI Conference
on Artiﬁcial Intelligence (AAAI’10). AAAI Press,
1306–1313.
http://dl.acm.org/citation.cfm?
id=2898607.2898816

Todd Kulesza, Saleema Amershi, Rich Caruana,
Danyel Fisher, and Denis Charles. 2014. Structured
labeling for facilitating concept evolution in machine
learning. In Proceedings of the SIGCHI Conference
on Human Factors in Computing Systems. ACM,
3075–3084.

D. Sculley, Gary Holt, Daniel Golovin, Eugene Davy-
dov, Todd Phillips, Dietmar Ebner, Vinay Chaud-
hary, and Michael Young. 2014. Machine Learning:
The High Interest Credit Card of Technical Debt. In
SE4ML: Software Engineering for Machine Learn-
ing (NIPS 2014 Workshop).

Vladimir Vapnik. 2013. The Nature of Statistical
Learning Theory. Springer science & business me-
dia.

