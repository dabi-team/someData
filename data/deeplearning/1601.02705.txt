Robobarista: Learning to Manipulate Novel Objects
via Deep Multimodal Embedding

Jaeyong Sung, Seok Hyun Jin, Ian Lenz, and Ashutosh Saxena

6
1
0
2

n
a
J

2
1

]

O
R
.
s
c
[

1
v
5
0
7
2
0
.
1
0
6
1
:
v
i
X
r
a

Abstract‚Äî There is a large variety of objects and appliances
in human environments, such as stoves, coffee dispensers, juice
extractors, and so on. It is challenging for a roboticist to
program a robot for each of these object types and for each of
their instantiations. In this work, we present a novel approach to
manipulation planning based on the idea that many household
objects share similarly-operated object parts. We formulate the
manipulation planning as a structured prediction problem and
learn to transfer manipulation strategy across different objects
by embedding point-cloud, natural language, and manipulation
trajectory data into a shared embedding space using a deep
neural network. In order to learn semantically meaningful
spaces throughout our network, we introduce a method for
pre-training its lower layers for multimodal feature embedding
and a method for Ô¨Åne-tuning this embedding space using
a loss-based margin. In order to collect a large number of
manipulation demonstrations for different objects, we develop
a new crowd-sourcing platform called Robobarista. We test our
model on our dataset consisting of 116 objects and appliances
with 249 parts along with 250 language instructions, for which
there are 1225 crowd-sourced manipulation demonstrations. We
further show that our robot with our model can even prepare
a cup of a latte with appliances it has never seen before.1

I. INTRODUCTION

Consider the espresso machine in Figure 1 ‚Äî even without
having seen this machine before, a person can prepare a cup
of latte by visually observing the machine and reading an
instruction manual. This is possible because humans have
vast prior experience with manipulating differently-shaped
objects that share common parts such as ‚Äòhandles‚Äô and
‚Äòknobs.‚Äô In this work, our goal is to give robots the same
capabilites ‚Äì speciÔ¨Åcally, to enable robots to generalize their
manipulation ability to novel objects and tasks (e.g. toaster,
sink, water fountain, toilet, soda dispenser, etc.). We build an
algorithm that uses a large knowledge base of manipulation
demonstrations to infer an appropriate manipulation trajec-
tory for a given pair of point-cloud and natural language
instructions.

If the robot‚Äôs sole task is to manipulate one speciÔ¨Åc
espresso machine or just a few types of ‚Äòhandles‚Äô, a roboticist
could manually program the exact sequence to be executed.
However, human environments contain a huge variety of
objects, which makes this approach un-scalable and infea-
sible. ClassiÔ¨Åcation of objects or object parts (e.g. ‚Äòhandle‚Äô)
alone does not provide enough information for robots to
actually manipulate them, since semantically-similar objects

Email:

are with Department

of Computer Science, Cornell
Authors
{jysung,sj372,ianlenz,asaxena}
University.
@cs.cornell.edu Jaeyong Sung is also a visiting student researcher
at Stanford University. Ashutosh Saxena is also with Brain of Things, Inc.
1Parts of this work were presented at ISRR 2015 (Sung et al. [61])

First encounter of an espresso machine by our PR2 robot.
Fig. 1.
Without ever having seen the machine before, given language instructions
and a point-cloud from Kinect sensor, our robot is capable of Ô¨Ånding
appropriate manipulation trajectories from prior experience using our deep
multimodal embedding model.

or parts might be operated completely differently ‚Äì con-
sider, for example, manipulating the ‚Äòhandle‚Äô of a urinal,
as opposed to a door ‚Äòhandle‚Äô. Thus, rather than relying on
scene understanding techniques [8, 39, 19], we directly use
3D point-clouds for manipulation planning using machine
learning algorithms.

The key idea of our work is that objects designed for use
by humans share many similarly-operated object parts such
as ‚Äòhandles‚Äô, ‚Äòlevers‚Äô, ‚Äòtriggers‚Äô, and ‚Äòbuttons‚Äô; thus, manip-
ulation motions can be transferred even between completely
different objects if we represent these motions with respect
to these parts. For example, even if the robot has never seen
an espresso machine before, it should be able to manipulate
it if it has previously seen similarly-operated parts of other
objects such as a urinal, soda dispenser, or restroom sink,
as illustrated in Figure 2. Object parts that are operated in
similar fashion may not necessarily carry the same part name
(e.g. ‚Äòhandle‚Äô) but should have some similarity in their shapes
that allows motions to be transferred between completely
different objects.

Going beyond manipulation based on simple semantic
classes is a signiÔ¨Åcant challenge which we address in this
work. Instead, we must also make use of visual information

 
 
 
 
 
 
(point-clouds), and a natural language instruction telling the
robot what to do since many possible affordances can exist
for the same part. Designing useful features for either of
these modalities alone is already difÔ¨Åcult, and designing
features which combine the two for manipulation purposes
is extremely challenging.

Obtaining a good common representation between differ-
ent modalities is challenging for two main reasons. First,
each modality might intrinsically have very different statisti-
cal properties ‚Äì for example, most trajectory representations
are inherently dense, while a bag-of-words representation
of language is by nature sparse. This makes it challenging
to apply algorithms designed for unimodal data, as one
modality might overpower the others. Second, even with
is extremely challenging to design
expert knowledge,
joint features between such disparate modalities. Humans
are able to map similar concepts from different sensory
system to the same concept using common representation
between different modalities [15]. For example, we are able
to correlate the appearance with feel of a banana, or a
language instruction with a real-world action. This ability
to fuse information from different input modalities and map
them to actions is extremely useful to a household robot.

it

In this work, we use deep neural networks to learn a shared
embedding between the combination of object parts in the
environment (point-cloud) and natural language instructions,
and manipulation trajectories (Fig. 3). This means that all
three modalities are projected to the same feature space. We
introduce an algorithm that learns to pull semantically similar
environment/language pairs and their corresponding trajec-
tories to the same regions, and push environment/language
pairs away from irrelevant trajectories based on how irrele-
vant these trajectories are. Our algorithm allows for efÔ¨Åcient
inference because, given a new instruction and point-cloud,
we only need to Ô¨Ånd the nearest trajectory to the projection
of this pair in the learned embedding space, which can be
done using fast nearest-neighbor algorithms [45].

In the past, deep learning methods have shown impressive
results for learning features in a wide variety of domains
[33, 54, 21] and even learning cross-domain embeddings for,
for example, language and image features [57]. In contrast
to these existing methods, here we present a new pre-
training algorithm for initializing networks to be used for
joint embedding of different modalities.

Such deep learning algorithms require a large dataset
for training. However, collecting a large enough dataset
of expert demonstrations on a large number of objects is
very expensive as it requires joint physical presence of
the robot, an expert, and the object to be manipulated. In
this work, we show that we can crowd-source the collec-
tion of manipulation demonstrations to the public over the
web through our Robobarista platform. Since crowd-sourced
demonstrations might be noisy and sub-optimal, we present
a new learning algorithm which handles this noise. With
our noise handling algorithm, our model trained with crowd-
sourced demonstrations outperforms the model trained with
expert demonstrations, even with the signiÔ¨Åcant amount of

noise in crowd-sourced manipulation demonstrations.

Furthermore, in contrast to previous approaches based on
learning from demonstration (LfD) that learn a mapping from
a state to an action [4], our work complements LfD as we
focus on the entire manipulation motion, as opposed to a
sequential state-action mapping.

Our Robobarista web-based crowdsourcing platform
(http://robobarista.cs.cornell.edu) allowed us to
collect a large dataset of 116 objects with 250 natural lan-
guage instructions for which there are 1225 crowd-sourced
manipulation trajectories from 71 non-expert users, which
we use to validate our methods. We also present experiments
on our robot using our approach. In summary,
the key
contributions of this work are:

‚Ä¢ We present a novel approach to manipulation planning
via part-based transfer between different objects that
allows manipulation of novel objects.

‚Ä¢ We introduce a new deep learning model that handles
three modalities with noisy labels from crowd-sourcing.
‚Ä¢ We introduce a new algorithm, which learns an embed-
ding space while enforcing a varying and loss-based
margin, along with a new unsupervised pre-training
method which outperforms standard pre-training algo-
rithms [20].

‚Ä¢ We develop an online platform which allows the in-
corporation of crowd-sourcing to manipulation planning
and introduces a large-scale manipulation dataset.

‚Ä¢ We evaluate our algorithms on this dataset, show-
ing signiÔ¨Åcant improvement over other state-of-the-art
methods.

II. RELATED WORK
Improving robotic perception and teaching manipulation
strategies to robots has been a major research area in recent
years. In this section, we describe related work in various
aspects of learning to manipulate novel objects.
Scene Understanding. In recent years, there has been sig-
niÔ¨Åcant research focus on semantic scene understanding [39,
32, 33, 75], human activity detection [59, 25], and features
for RGB-D images and point-clouds [55, 35]. Similar to our
idea of using part-based transfers, the deformable part model
[19] was effective in object detection. However, classiÔ¨Åcation
of objects, object parts, or human activities alone does not
provide enough information for a robot
to reliably plan
manipulation. Even a simple category such as ‚Äòkitchen sinks‚Äô
has a huge amount of variation in how different instances
are manipulated ‚Äì for example, handles and knobs must
be manipulated differently, and different orientations and
positions of these parts require very different strategies such
as pulling the handle upwards, pushing upwards, pushing
sideways, and so on. On the other hand, direct perception
approaches [18, 34] skip the intermediate object labels and
directly perceive affordances based on the shape of the
object. These works focus on detecting the part known to
afford certain actions, such as ‚Äòpour,‚Äô given the object, while
we focus on predicting the correct motion given the object
part.

Manipulation Strategy. Most works in robotic manipulation
focus on task-speciÔ¨Åc manipulation of known objects‚Äîfor
example, baking cookies with known tools [9] and folding
the laundry [42] ‚Äì or focus on learning speciÔ¨Åc motions such
as grasping [30] and opening doors [14]. Others [60, 43]
focus on sequencing manipulation tasks assuming perfect
manipulation primitives such as grasp and pour are available.
Instead, here, we use learning to generalize to manipulating
novel objects never seen before by the robot, without relying
on preprogrammed motion primitives.

For the more general task of manipulating new instances
of objects, previous approaches rely on Ô¨Ånding articulation
[58, 50] or using interaction [29], but they are limited by
tracking performance of a vision algorithm. Many objects
that humans operate daily have small parts such as ‚Äòknobs‚Äô,
which leads to signiÔ¨Åcant occlusion as manipulation is
demonstrated. Another approach using part-based transfer
between objects has been shown to be successful for grasping
[11, 13]. We extend this approach and introduce a deep
learning model that enables part-based transfer of trajectories
by automatically learning relevant features. Our focus is
on the generalization of manipulation trajectory via part-
based transfer using point-clouds without knowing objects a
priori and without assuming any of the sub-steps (‚Äòapproach‚Äô,
‚Äògrasping‚Äô, and ‚Äòmanipulation‚Äô).

A few recent works use deep learning approaches for
robotic manipulation. Levine et al. [38] use a Gaussian
mixture model to learn system dynamics, then use these to
learn a manipulation policy using a deep network. Lenz et al.
[37] use a deep network to learn system dynamics for real-
time model-predictive control. Both these works focus on
learning low-level controllers, whereas here we learn high-
level manipulation trajectories.

Learning from Demonstration. Several successful ap-
proaches for teaching robots tasks, such as helicopter maneu-
vers [1] or table tennis [46], have been based on Learning
from Demonstration (LfD) [4]. Although LfD allows end
users to demonstrate a manipulation task by simply taking
control of the robot‚Äôs arms, it focuses on learning individual
actions and separately relies on high level task composition
[40, 12] or is often limited to previously seen objects
[49, 48]. We believe that learning a single model for an action
like ‚Äòturning on‚Äô is impossible because human environments
have so many variations.

Unlike learning a model from demonstration, instance-
based learning [2, 17] replicates one of the demonstrations.
Similarly, we directly transfer one of the demonstrations, but
focus on generalizing manipulation planning to completely
new objects, enabling robots to manipulate objects they have
never seen before.

Metric Embedding. Several works in machine learning
make use of the power of shared embedding spaces. LMNN
[72] learns a max-margin Mahalanobis distance for a uni-
modal input feature space. Weston et al. [73] learn linear
mappings from image and language features to a common
embedding space for automatic image annotation. Moore

et al. [44] learn to map songs and natural language tags
to a shared embedding space. However, these approaches
learn only a shallow, linear mapping from input features,
whereas here we learn a deep non-linear mapping which is
less sensitive to input representations.

Deep Learning. In recent years, deep learning algorithms
have enjoyed huge successes, particularly in the domains of
of vision and natural language processing (e.g. [33, 54]).
In robotics, deep learning has previously been successfully
used for detecting grasps for novel objects in multi-channel
RGB-D images [36] and for classifying terrain from long-
range vision [21].

Ngiam et al. [47] use deep learning to learn features
incorporating both video and audio modalities. Sohn et al.
[56] propose a new generative learning algorithm for multi-
modal data which improves robustness to missing modalities
at inference time. In these works, a single network takes
all modalities as inputs, whereas here we perform joint
embedding of multiple modalities using multiple networks.
Several previous works use deep networks for joint em-
bedding between different feature spaces. Mikolov et al.
[41] map different languages to a joint feature space for
translation. Srivastava and Salakhutdinov [57] map images
and natural language ‚Äútags‚Äù to the same space for automatic
annotation and retrieval. While these works use conventional
pre-training algorithms, here we present a new pre-training
approach for learning embedding spaces and show that
it outperforms these existing methods (Sec. VIII-C.) Our
algorithm trains each layer to map similar cases to similar
areas of its feature space, as opposed to other methods
which either perform variational learning [22] or train for
reconstruction [20].

Hu et al. [24] also use a deep network for metric learning
for the task of face veriÔ¨Åcation. Similar to LMNN [72],
Hu et al. [24] enforces a constant margin between distances
among inter-class objects and among intra-class objects. In
Sec. VIII-C, we show that our approach, which uses a
loss-dependent variable margin, produces better results for
our problem. Our work builds on deep neural network to
embed three different modalities of point-cloud, language,
and trajectory into shared embedding space while handling
lots of label-noise originating from crowd-sourcing.

Crowd-sourcing. Many approaches to teaching robots ma-
nipulation and other skills have relied on demonstrations
by skilled experts [4, 1]. Among previous efforts to scale
teaching to the crowd [10, 62, 27], Forbes et al. [17] employs
a similar approach towards crowd-sourcing but collects mul-
tiple instances of similar table-top manipulation with same
object. Others also build web-based platform for crowd-
sourcing manipulation [65, 66]. However, these approaches
either depend on the presence of an expert (due to required
special software), or require a real robot at a remote location.
Our Robobarista platform borrows some components of work
from Alexander et al. [3], but works on any standard web
browser with OpenGL support and incorporates real point-
clouds of various scenes.

Fig. 2. Mapping object part and natural language instruction input to manipulation trajectory output. Objects such as the espresso machine
consist of distinct object parts, each of which requires a distinct manipulation trajectory for manipulation. For each part of the machine, we can re-use a
manipulation trajectory that was used for some other object with similar parts. So, for an object part in a point-cloud (each object part colored on left),
we can Ô¨Ånd a trajectory used to manipulate some other object (labeled on the right) that can be transferred (labeled in the center). With this approach, a
robot can operate a new and previously unobserved object such as the ‚Äòespresso machine‚Äô, by successfully transferring trajectories from other completely
different but previously observed objects. Note that the input point-cloud is very noisy and incomplete (black represents missing points).

III. OUR APPROACH

Our goal is to build an algorithm that allows a robot to
infer a manipulation trajectory when it is introduced to a new
object or appliance and its natural language instruction man-
ual. The intuition for our approach is that many differently-
shaped objects share similarly-operated object parts; thus, the
manipulation trajectory of an object can be transferred to a
completely different object if they share similarly-operated
parts.

For example, the motion required to operate the handle
of the espresso machine in Figure 2 is almost identical to
the motion required to Ô¨Çush a urinal with a handle. By
identifying and transferring trajectories from prior experience
with parts of other objects, robots can manipulate even
objects they have never seen before.

We Ô¨Årst formulate this problem as a structured prediction
problem as shown in Figure 2. Given a point-cloud for
each part of an espresso machine and a natural language
instruction such as ‚ÄòPush down on the handle to add hot
water‚Äô, our algorithm outputs a trajectory which executes
the task, using a pool of prior motion experience.

This is a challenging problem because the object is entirely
new to the robot, and because it must jointly consider the
point-cloud, natural language instruction, and each poten-
tial trajectory. Moreover, manually designing useful features
from these three modalities is extremely challenging.

We introduce a deep multimodal embedding approach that
learns a shared, semantically meaningful embedding space
between these modalities, while dealing with a noise in
crowd-sourced demonstration data. Then, we introduce our
Robobarista crowd-sourcing platform, which allows us to
easily scale the collection of manipulation demonstrations
to non-experts on the web.

A. Problem Formulation

Our goal is to learn a function f that maps a given pair of
point-cloud p ‚àà P of an object part and a natural language

instruction l ‚àà L to a trajectory œÑ ‚àà T that can manipulate
the object part as described by free-form natural language l:

f : P √ó L ‚Üí T

(1)

For instance, given the handle of the espresso machine in
Figure 2 and an natural language instruction ‚ÄòPush down on
the handle to add hot water‚Äô, the algorithm should output
a manipulation trajectory that will correctly accomplish the
task on the object part according to the instruction.
Point-cloud Representation. Each instance of a point-cloud
p ‚àà P is represented as a set of n points in three-dimensional
Euclidean space where each point (x, y, z) is represented
with its RGB color (r, g, b):

p = {p(i)}n

n
i=1 = {(x, y, z, r, g, b)(i)}
i=1

The size of this set varies for each instance. These points
are often obtained by stitching together a sequence of sensor
data from an RGBD sensor [26].
Trajectory Representation. Each trajectory œÑ ‚àà T is
represented as a sequence of m waypoints, where each
waypoint consists of gripper status g, translation (tx, ty, tz),
and rotation (rx, ry, rz, rw) with respect to the origin:

œÑ = {œÑ (i)}m

i=1 = {(g, tx, ty, tz, rx, ry, rz, rw)(i)}

m
i=1

where g ‚àà {‚Äúopen‚Äù, ‚Äúclosed‚Äù, ‚Äúholding‚Äù}. g depends on the
type of the end-effector, which we have assumed to be a two-
Ô¨Ångered parallel-plate gripper like that of PR2 or Baxter. The
rotation is represented as quaternions (rx, ry, rz, rw) instead
of the more compact Euler angles to prevent problems such
as gimbal lock.
Smooth Trajectory. To acquire a smooth trajectory from
a waypoint-based trajectory œÑ , we interpolate intermedi-
ate waypoints. Translation is linearly interpolated and the
quaternion is interpolated using spherical linear interpolation
(Slerp) [53].

B. Data Pre-processing

Each of the point-cloud, language, and trajectory (p, l, œÑ )
can have any length. Thus, we Ô¨Åt raw data from each
modality into a Ô¨Åxed-length vector.

We represent point-cloud p of any arbitrary length as
an occupancy grid where each cell indicates whether any
point lives in the space it represents. Because point-cloud p
consists of only the part of an object which is limited in size,
we can represent p using two occupancy grid-like structures
of size 10 √ó 10 √ó 10 voxels with different scales: one with
each voxel spanning a cube of 1 √ó 1 √ó 1(cm) and the other
with each cell representing 2.5 √ó 2.5 √ó 2.5(cm).

Each language instruction is represented as a Ô¨Åxed-size
bag-of-words representation with stop words removed. Fi-
nally, for each trajectory œÑ ‚àà T , we Ô¨Årst compute its
smooth interpolated trajectory œÑs ‚àà Ts (Sec. III-A), and
then normalize all trajectories Ts to the same length while
preserving the sequence of gripper states such as ‚Äòopening‚Äô,
‚Äòclosing‚Äô, and ‚Äòholding‚Äô.

C. Direct manipulation trajectory transfer

Even if we have a trajectory to transfer, a conceptually
transferable trajectory is not necessarily directly compatible
if it is represented with respect to an inconsistent reference
point.

To make a trajectory compatible with a new situation
without modifying the trajectory, we need a representation
method for trajectories, based on point-cloud information,
that allows a direct transfer of a trajectory without any
modiÔ¨Åcation.
Challenges. Making a trajectory compatible when trans-
ferred to a different object or to a different instance of the
same object without modiÔ¨Åcation can be challenging depend-
ing on the representation of trajectories and the variations in
the location of the object, given in point-clouds.

Many approaches which control high degree of freedom
arms such as those of PR2 or Baxter use conÔ¨Åguration-
space trajectories, which store a time-parameterized series
of joint angles [64]. While such approaches allow for direct
control of joint angles during control, they require costly
recomputation for even a small change in an object‚Äôs position
or orientation.

One approach that allows execution without modiÔ¨Åcation
is representing trajectories with respect
to the object by
aligning via point-cloud registration (e.g. [17]). However, a
large object such as a stove might have many parts (e.g.
knobs and handles) whose positions might vary between
different stoves. Thus, object-aligned manipulation of these
parts would not be robust to different stoves, and in general
would impede transfer between different instances of the
same object.

Lastly, it is even more challenging if two objects require
similar trajectories, but have slightly different shapes. And
this is made more difÔ¨Åcult by limitations of the point-cloud
data. As shown in left of Fig. 2, the point-cloud data, even
when stitched from multiple angles, are very noisy compared
to the RGB images.

Fig. 3. Deep Multimodal Embedding: Our deep neural network learns
to embed both point-cloud/natural language instruction combinations and
manipulation trajectories in the same space. This allows for fast selection
of a new trajectory by projecting a new environment/instruction pair and
choosing its nearest-neighbor trajectory in this space.

Our Solution. Transferred trajectories become compatible
across different objects when trajectories are represented 1)
in the task space rather than the conÔ¨Åguration space, and 2)
relative to the object part in question (aligned based on its
principal axis), rather than the object as a whole.

Trajectories can be represented in the task space by record-
ing only the position and orientation of the end-effector. By
doing so, we can focus on the actual interaction between
the robot and the environment rather than the movement of
the arm. It is very rare that the arm conÔ¨Åguration affects the
completion of the task as long as there is no collision. With
the trajectory represented as a sequence of gripper position
and orientation, the robot can Ô¨Ånd its arm conÔ¨Åguration
that is collision free with the environment using inverse
kinematics.

However, representing the trajectory in task space is not
enough to make transfers compatible. The trajectory must
also be represented in a common coordinate frame regardless
of the object‚Äôs orientation and shape.

Thus, we align the negative z-axis along gravity and
align the x-axis along the principal axis of the object part
using PCA [23]. With this representation, even when the
object part‚Äôs position and orientation changes, the trajectory
does not need to change. The underlying assumption is that
similarly operated object parts share similar shapes leading
to a similar direction in their principal axes.

IV. DEEP MULTIMODAL EMBEDDING

In this work, we use deep learning to Ô¨Ånd the most
appropriate trajectory for a given point-cloud and natural
language instruction. This is much more challenging than
the uni-modal binary or multi-class classiÔ¨Åcation/regression
problems (e.g. image recognition [33]) to which deep learn-
ing has mostly been applied [6]. We could simply convert
our problem into a binary classiÔ¨Åcation problem, i.e. ‚Äúdoes

point-cloud(ùíë)language(ùíç)trajectory(ùùâ)ùíâùüèùíôùíâùüêùíâùüëpushpullhandleleverfillstovestopcupcontroltowardsthis trajectory match this point-cloud/language pair?‚Äù Then,
we can use a multimodal feed-forward deep network [47] to
solve this problem [61].

However, this approach has several drawbacks. First, it
requires evaluating the network over every combination of
potential candidate manipulation trajectory and the given
point-cloud/language pair, which is computationally expen-
sive. Second,
this method does nothing to handle noisy
labels, a signiÔ¨Åcant problem when dealing with crowd-
sourced data as we do here. Finally, while this method is
capable of producing reasonable results for our problem, we
show in Section VIII-C that a more principled approach to
our problem is able to improve over it.

Instead, in this work, we present a new deep architecture
and algorithm which is a better Ô¨Åt for this problem, directly
addressing the challenges inherent in multimodal data and
the noisy labels obtained from crowdsourcing. We learn
a joint embedding of point-cloud, language, and trajectory
data into the same low dimensional space. We learn non-
linear embeddings using a deep learning approach which
maps raw data from these three different modalities to a joint
embedding space.

We then use this space to Ô¨Ånd known trajectories which
are good matches for new combinations of object parts and
instructions. Compared to previous work that exhaustively
runs a full network over all these combinations [61], our
approach allows us to pre-embed all candidate trajectories
into this common feature space. Thus, the most appropriate
trajectory can be identiÔ¨Åed by embedding only a new point-
cloud/language pair and then Ô¨Ånding its nearest neighbor.

In our joint feature space, proximity between two mapped
points should reÔ¨Çect how relevant two data-points are to
each other, even if they are from completely different
modalities. We train our network to bring demonstrations
that would manipulate a given object according to some
language instruction closer to the mapped point for that
object/instruction pair, and to push away demonstrations that
would not correctly manipulate the object. Trajectories which
have no semantic relevance to the object are pushed much
further away than trajectories that have some relevance, even
if the latter would not manipulate the object according to the
instruction.

joint embedding of all

Prior to learning a full

three
modalities, we pre-train embeddings of subsets of the modal-
ities to learn semantically meaningful embeddings for these
modalities, leading to improved performance as shown in
Section VIII-C.

To solve this problem of learning to manipulate novel
objects and appliance as deÔ¨Åned in equation (1), we learn
two different mapping functions that map to a common
space‚Äîone from a point-cloud/language pair and the other
from a trajectory. More formally, we want to learn Œ¶P,L(p, l)
and Œ¶T (œÑ ) which map to a joint feature space RM :

Œ¶P,L(p, l) : (P, L) ‚Üí RM
Œ¶T (œÑ ) : T ‚Üí RM

Here, we represent
network, as shown in Figure 3.

these mappings with a deep neural

The Ô¨Årst, Œ¶P,L, which maps point-clouds and trajectories,
is deÔ¨Åned as a combination of two mappings. The Ô¨Årst of
these maps to a joint point-cloud/language space RN2,pl ‚Äî
Œ¶P (p) : P ‚Üí RN2,pl and Œ¶L(l) : L ‚Üí RN2,pl . Once
each is mapped to RN2,pl, this space is then mapped to the
joint space shared with trajectory information: Œ¶P,L(p, l) :
((P, L) ‚Üí RN2,pl ) ‚Üí RM .

A. Model

We use two separate multi-layer deep neural networks, one
for Œ¶P,L(p, l) and one for Œ¶T (œÑ ). Take Np as the size of
point-cloud input p, Nl as similar for natural language input
l, N1,p and N1,l as the number of hidden units in the Ô¨Årst hid-
den layers projected from point-cloud and natural language
features, respectively, and N2,pl as the number of hidden
units in the combined point-cloud/language layer. With W ‚Äôs
as network weights, which are the learned parameters of our
system, and a(¬∑) as a rectiÔ¨Åed linear unit (ReLU) activation
function [78], our model for projecting from point-cloud and
language features to the shared embedding h3 is as follows:

h1,p
i = a

h1,l
i = a

h2,pl
i = a

h3
i = a

(cid:16)(cid:80)Np

(cid:16)(cid:80)Nl

(cid:17)

i,j pj
(cid:17)

j=0 W 1,p
j=0 W 1,l
i,j lj
j=0 W 2,p
i,j h1,p
i,j h2,pl
j=0 W 3,pl

j

(cid:16)(cid:80)N1,p

(cid:16)(cid:80)N2,pl

j + (cid:80)N1,l
(cid:17)

j=0 W 2,l

i,j h1,l

j

(cid:17)

The model for projecting from trajectory input œÑ is similar,
except it takes input only from a single modality.

B. Inference.

Once all mappings are learned, we solve the original
problem from equation (1) by choosing, from a library
of prior trajectories, the trajectory that gives the highest
similarity (closest in distance) to the given point-cloud p and
language l in our joint embedding space RM . As in previous
work [73], similarity is deÔ¨Åned as sim(a, b) = a ¬∑ b, and
the trajectory that maximizes the magnitude of similarity is
selected:

argmax
œÑ ‚ààT

sim(Œ¶P,L(p, l), Œ¶T (œÑ ))

The previous approach to this problem [61] required pro-
jecting the combination of the current point-cloud and natural
language instruction with every trajectory in the training set
through the network during inference. Here, we pre-compute
the representations of all training trajectories in h3, and need
only project the new point-cloud/language pair to h3 and Ô¨Ånd
its nearest-neighbor trajectory in this embedding space. As
shown in Section VIII-C, this signiÔ¨Åcantly improves both the
runtime and accuracy of our approach and makes it much
more scalable to larger training datasets like those collected
with crowdsourcing platforms.

V. LEARNING JOINT
POINT-CLOUD/LANGUAGE/TRAJECTORY MODEL

The main challenge of our work is to learn a model
which maps three disparate modalities ‚Äì point-clouds, nat-
ural language, and trajectories ‚Äì to a single semantically
meaningful space. We introduce a method that
learns a
common point-cloud/language/trajectory space such that all
trajectories relevant to a given task (point-cloud/language
combination) should have higher similarity to the projection
of that task than task-irrelevant trajectories. Among these
than
irrelevant
others, and thus should be pushed further away.

trajectories, some might be less relevant

For example, given a door knob that needs to be grasped
normal to the door surface and an instruction to rotate it
clockwise, a trajectory that correctly approaches the door
knob but rotates counter-clockwise should have higher simi-
larity to the task than one which approaches the knob from a
completely incorrect angle and does not execute any rotation.
For every training point-cloud/language pair (pi, li), we
have two sets of demonstrations: a set of trajectories Ti,S
that are relevant (similar) to this task and a set of trajectories
Ti,D that are irrelevant (dissimilar) as described in Sec. V-C.
For each pair of (pi, li), we want all projections of œÑj ‚àà Ti,S
to have higher similarity to the projection of (pi, li) than
œÑk ‚àà Ti,D. A simple approach would be to train the network
to distinguish these two sets by enforcing a Ô¨Ånite distance
(safety margin) between the similarities of these two sets
[72], which can be written in the form of a constraint:

sim(Œ¶P,L(pi, li), Œ¶T (œÑj)) ‚â• 1 + sim(Œ¶P,L(pi, li), Œ¶T (œÑk))

Rather than simply being able to distinguish two sets, we
want to learn semantically meaningful embedding spaces
from different modalities. Recalling our earlier example
where one incorrect trajectory for manipulating a door knob
was much closer to correct than another, it is clear that our
learning algorithm should drive some of incorrect trajectories
to be more dissimilar than others. The difference between the
similarities of œÑj and œÑk to the projected point-cloud/language
pair (pi, li) should be at least the loss ‚àÜ(œÑj, œÑk). This can
be written as a form of a constraint:

‚àÄœÑj ‚àà Ti,S, ‚àÄœÑk ‚àà Ti,D
sim(Œ¶P,L(pi, li), Œ¶T (œÑj))

‚â• ‚àÜ(œÑj, œÑk) + sim(Œ¶P,L(pi, li), Œ¶T (œÑk))

Intuitively,
this forces trajectories with higher DTW-MT
distance from the ground truth to embed further than those
with lower distance. Enforcing all combinations of these con-
straints could grow exponentially large. Instead, similar to the
cutting plane method for structural support vector machines
[68], we Ô¨Ånd the most violating trajectory œÑ (cid:48) ‚àà Ti,D for each
training pair of (pi, li, œÑi ‚àà Ti,S) at each iteration. The most
violating trajectory has the highest similarity augmented with
the loss scaled by a constant Œ±:

œÑ (cid:48)
i = arg max
œÑ ‚ààTi,D

(sim(Œ¶P,L(pi, li), Œ¶T (œÑ )) + Œ±‚àÜ(œÑi, œÑ ))

Pre-training lower layers: Visualization of our pre-training
Fig. 4.
approaches for h2,pl and h2,œÑ . For h2,pl, our algorithm pushes matching
point-clouds and instructions to be more similar. For h2,œÑ , our algorithm
pushes trajectories with higher DTW-MT similarity to be more similar.

The cost of our deep embedding space h3 is computed as

the hinge loss of the most violating trajectory.

Lh3(pi, li, œÑi) = |‚àÜ(œÑ (cid:48)

i , œÑi)+sim(Œ¶P,L(pi, li), Œ¶T (œÑ (cid:48)

i ))

‚àísim(Œ¶P,L(pi, li), Œ¶T (œÑi))|+

The average cost of each minibatch is back-propagated
through all the layers of the deep neural network using the
AdaDelta [77] algorithm.

A. Pre-training Joint Point-cloud/Language Model

One major advantage of modern deep learning methods
is the use of unsupervised pre-training to initialize neural
network parameters to a good starting point before the Ô¨Ånal
supervised Ô¨Åne-tuning stage. Pre-training helps these high-
dimensional networks to avoid overÔ¨Åtting to the training data.
Our lower layers h2,pl and h2,œÑ represent features ex-
tracted exclusively from the combination of point-clouds
and language, and from trajectories, respectively. Our pre-
training method initializes h2,pl and h2,œÑ as semantically
meaningful embedding spaces similar to h3, as shown later
in Section VIII-C.

First, we pre-train the layers leading up to these layers
using spare de-noising autoencoders [71, 78]. Then, our
process for pre-training h2,pl is similar to our approach to
Ô¨Åne-tuning a semantically meaningful embedding space for
h3 presented above, except now we Ô¨Ånd the most violating
language l(cid:48) while still relying on a loss over the associated
optimal trajectory:

l(cid:48) = argmax
l‚ààL

(sim(Œ¶P (pi), Œ¶L(l)) + Œ±‚àÜ(œÑ, œÑ ‚àó

i ))

Lh2,pl (pi, li, œÑi) = |‚àÜ(œÑi, œÑ (cid:48))+sim(Œ¶P (pi), Œ¶L(l(cid:48)))

‚àísim(Œ¶P (pi), Œ¶L(li))|+

Notice that although we are training this embedding space
to project from point-cloud/language data, we guide learning
using trajectory information.

After the projections Œ¶P and Œ¶L are tuned, the output of
these two projections are added to form the output of layer
h2,pl in the Ô¨Ånal feed-forward network.

point-cloud(ùíë)language(ùíç)trajectory(ùùâ)ùíâùüèùíôùíâùüê,ùíëùíçpoint-cloud/language embeddingtrajectory(ùùâ‚Ä≤)trajectory embeddingùíâùüèùíôùíâùüê,ùùâB. Pre-training Trajectory Model

VI. LOSS FUNCTION FOR MANIPULATION TRAJECTORY

For our task of inferring manipulation trajectories for novel
objects, it is especially important that similar trajectories
œÑ map to similar regions in the feature space deÔ¨Åned by
h2,œÑ , so that trajectory embedding h2,œÑ itself is semantically
meaningful and they can in turn be mapped to similar regions
in h3. Standard pretraining methods, such as sparse de-
noising autoencoder [71, 78] would only pre-train h2,œÑ to
reconstruct individual trajectories. Instead, we employ pre-
training similar to Sec. V-A, except now we pre-train for
only a single modality ‚Äì trajectory data.

As shown on right hand side of Fig. 4, the layer that
embeds to h2,œÑ is duplicated. These duplicated embedding
layers are treated as if they were two different modalities,
but all their weights are shared and updated simultaneously.
For every trajectory œÑ ‚àà Ti,S, we can again Ô¨Ånd the most
violating œÑ (cid:48) ‚àà Ti,D and the minimize a similar cost function
as we do for h2,pl.

C. Label Noise

When our data contains a signiÔ¨Åcant number of noisy
trajectories œÑ , e.g. due to crowd-sourcing (Sec. VII), not all
trajectories should be trusted as equally appropriate, as will
be shown in Sec. VIII.
For every pair of

(pi, li), we have Ti =
{œÑi,1, œÑi,2, ..., œÑi,ni}, a set of trajectories submitted by the
crowd for (pi, li). First, the best candidate label œÑ ‚àó
i ‚àà Ti
for (pi, li) is selected as the one with the smallest average
trajectory distance to the others:

inputs

œÑ ‚àó
i = argmin
œÑ ‚ààTi

1
ni

ni(cid:88)

j=1

‚àÜ(œÑ, œÑi,j)

We assume that at least half of the crowd tried to give a
reasonable demonstration. Thus a demonstration with the
smallest average distance to all other demonstrations must
be a good demonstration. We use the DTW-MT distance
function (described later in Sec. VI) for our loss function
‚àÜ(œÑ, ¬ØœÑ ), but
it could be replaced by any function that
computes the loss of predicting ¬ØœÑ when œÑ is the correct
demonstration.

Using the optimal demonstration and a loss function
‚àÜ(œÑ, ¬ØœÑ ) for comparing demonstrations, we Ô¨Ånd a set of
trajectories Ti,S that are relevant (similar) to this task and a
set of trajectories Ti,D that are irrelevant (dissimilar.) We can
use thresholds (tS, tD) determined by the expert to generate
two sets from the pool of trajectories:

Ti,S = {œÑ ‚àà T |‚àÜ(œÑ ‚àó

i , œÑ ) < tS}

Ti,D = {œÑ ‚àà T |‚àÜ(œÑ ‚àó

i , œÑ ) > tD}

This method allows our model to be robust against noisy
labels and also serves as a method of data augmentation by
also considering demonstrations given for other tasks in both
sets of Ti,S and Ti,D.

For both learning and evaluation, we need a function
which accurately represents distance between two trajecto-
ries. Prior metrics for trajectories consider only their transla-
tions (e.g. [31]) and not their rotations and gripper status. We
propose a new measure, which uses dynamic time warping,
for evaluating manipulation trajectories. This measure non-
linearly warps two trajectories of arbitrary lengths to produce
a matching, then computes cumulative distance as the sum of
cost of all matched waypoints. The strength of this measure
is that weak ordering is maintained among matched way-
points and that every waypoint contributes to the cumulative
distance.

B }mB

For two trajectories of arbitrary lengths, œÑA = {œÑ (i)

A }mA
and œÑB = {œÑ (i)
i=1 , we deÔ¨Åne a matrix D ‚àà RmA√ómB ,
where D(i, j) is the cumulative distance of an optimally-
warped matching between trajectories up to index i and j,
respectively, of each trajectory. The Ô¨Årst column and the Ô¨Årst
row of D is initialized as:

i=1

D(i, 1) =

D(1, j) =

i
(cid:88)

k=1
j
(cid:88)

k=1

c(œÑ (k)

A , œÑ (1)

B ) ‚àÄi ‚àà [1, mA]

c(œÑ (1)

A , œÑ (k)

B ) ‚àÄj ‚àà [1, mB]

where c is a local cost function between two waypoints
(discussed later). The rest of D is completed using dynamic
programming:

D(i, j) =c(œÑ (i)

A , œÑ (j)
B )

+ min{D(i ‚àí 1, j ‚àí 1), D(i ‚àí 1, j), D(i, j ‚àí 1)}

A is matched to œÑ (1)

Given the constraint that œÑ (1)

B , the for-
mulation ensures that every waypoint contributes to the Ô¨Ånal
cumulative distance D(mA, mB). Also, given a matched
B ), no waypoint preceding œÑ (i)
pair (œÑ (i)
A is matched to
a waypoint succeeding œÑ (j)

B , encoding weak ordering.

A , œÑ (j)

B is deÔ¨Åned:

A ; Œ≥)w(œÑ (j)
B ; Œ±T , Œ±R,Œ≤, Œ≥) = w(œÑ (i)
(cid:19)(cid:18)
dR(œÑ (i)
A , œÑ (j)
B )
Œ±R

The pairwise cost function c between matched waypoints
A and œÑ (j)
œÑ (i)
A , œÑ (j)
c(œÑ (i)
(cid:18) dT (œÑ (i)
A , œÑ (j)
B )
Œ±T
A , œÑ (j)
dT (œÑ (i)
A , œÑ (j)
dR(œÑ (i)
A , œÑ (j)
dG(œÑ (i)
w(œÑ (i); Œ≥) = exp(‚àíŒ≥ ¬∑ ||œÑ (i)||2)

B ) = ||(tx, ty, tz)(i)
A ‚àí (tx, ty, tz)(j)
B ) = angle difference between œÑ (i)
A = g(j)
B ) = 1(g(i)
B )

B ||2
A and œÑ (j)

1 + Œ≤dG(œÑ (i)

A , œÑ (j)
B )

B ; Œ≥)

where

+

(cid:19)

B

The parameters Œ±, Œ≤ are for scaling translation and rotation
errors, and gripper status errors, respectively. Œ≥ weighs the
importance of a waypoint based on its distance to the object
part. 2 Finally, as trajectories vary in length, we normalize
D(mA, mB) by the number of waypoint pairs that contribute

2In this work, we assign Œ±T , Œ±R, Œ≤, Œ≥ values of 0.0075 meters, 3.75‚ó¶,

1 and 4 respectively.

Fig. 5.
number of crowd demonstrations for teaching the robot.

Screen-shot of Robobarista, the crowd-sourcing platform running on Chrome browser. We have built Robobarista platform for collecting a large

to the cumulative sum, |D(mA, mB)|path‚àó (i.e. the length of
the optimal warping path), giving the Ô¨Ånal form:

distance(œÑA, œÑB) =

D(mA, mB)
|D(mA, mB)|path‚àó

This distance function is used for noise-handling in our
model and as the Ô¨Ånal evaluation metric.

VII. ROBOBARISTA: CROWD-SOURCING PLATFORM

In order to collect a large number of manipulation demon-
strations from the crowd, we built a crowd-sourcing web
platform that we call Robobarista (see Fig. 5). It provides a
virtual environment where non-expert users can teach robots
via a web browser, without expert guidance or physical
presence with a robot and a target object.

The system simulates a situation where the user encounters
a previously unseen target object and a natural language
instruction manual for its manipulation. Within the web
browser, users are shown a point-cloud in the 3-D viewer on
the left and a manual on the right. A manual may involve
several instructions, such as ‚ÄúPush down and pull the handle
to open the door‚Äù. The user‚Äôs goal is to demonstrate how to
manipulate the object in the scene for each instruction.

The user starts by selecting one of the instructions on the
right to demonstrate (Fig. 5). Once selected, the target object
part is highlighted and the trajectory edit bar appears below
the 3-D viewer. Using the edit bar, which works like a video
editor, the user can playback and edit the demonstration. The
trajectory representation, as a set of waypoints (Sec. III-A),
is directly shown on the edit bar. The bar shows not only
the set of waypoints (red/green) but also the interpolated
waypoints (gray). The user can click the ‚Äòplay‚Äô button or
hover the cursor over the edit bar to examine the current
demonstration. The blurred trail of the current trajectory
(ghosted) demonstration is also shown in the 3-D viewer
to show its full expected path.

Generating a full trajectory from scratch can be difÔ¨Åcult
for non-experts. Thus, similar to Forbes et al. [17], we
provide a trajectory that the system has already seen for
another object as the initial starting trajectory to edit.3

In order to simulate a realistic experience of manipulation,
instead of simply showing a static point-cloud, we have
overlaid CAD models for parts such as ‚Äòhandle‚Äô so that
functional parts actually move as the user tries to manipulate
the object.

A demonstration can be edited by: 1) modifying the po-
sition/orientation of a waypoint, 2) adding/removing a way-
point, and 3) opening/closing the gripper. Once a waypoint
is selected, the PR2 gripper is shown with six directional
arrows and three rings, used to modify the gripper‚Äôs position
and orientation, respectively. To add extra waypoints, the user
can hover the cursor over an interpolated (gray) waypoint
on the edit bar and click the plus(+) button. To remove an
existing waypoint, the user can hover over it on the edit bar
and click minus(-) to remove. As modiÔ¨Åcation occurs, the
edit bar and ghosted demonstration are updated with a new
interpolation. Finally, for editing the status (open/close) of
the gripper, the user can simply click on the gripper.

For broader accessibility, all functionality of Robobarista,
including 3-D viewer, is built using Javascript and WebGL.
We have made the platform available online (http://
robobarista.cs.cornell.edu)

VIII. EXPERIMENTS

A. Robobarista Dataset

In order to test our model, we have collected a dataset of
116 point-clouds of objects with 249 object parts (examples
shown in Figure 6). Objects range from kitchen appliances
such as stoves and rice cookers to bathroom hardware such
as sinks and toilets. Figure 14 shows a sample of 70 such

3We have made sure that it does not initialize with trajectories from other

folds to keep 5-fold cross-validation in experiment section valid.

Examples from our dataset, each of which consists of a natural language instruction (top), an object part in point-cloud representation
Fig. 6.
(highlighted), and a manipulation trajectory (below) collected via Robobarista. Objects range from kitchen appliances such as stove and rice cooker to
urinals and sinks in restrooms. As our trajectories are collected from non-experts, they vary in quality from being likely to complete the manipulation task
successfully (left of dashed line) to being unlikely to do so successfully (right of dashed line).

objects. There are also a total of 250 natural language instruc-
tions (in 155 manuals).4 Using the crowd-sourcing platform
Robobarista, we collected 1225 trajectories for these objects
from 71 non-expert users on the Amazon Mechanical Turk.
After a user is shown a 20-second instructional video, the
user Ô¨Årst completes a 2-minute tutorial task. At each session,
the user was asked to complete 10 assignments where each
consists of an object and a manual to be followed.

For each object, we took raw RGB-D images with the
Microsoft Kinect sensor and stitched them using Kinect
Fusion [26] to form a denser point-cloud in order to incor-
porate different viewpoints of objects. Objects range from
kitchen appliances such as ‚Äòstove‚Äô, ‚Äòtoaster‚Äô, and ‚Äòrice cooker‚Äô
to ‚Äòurinal‚Äô, ‚Äòsoap dispenser‚Äô, and ‚Äòsink‚Äô in restrooms. The
dataset
is made available at http://robobarista.cs.
cornell.edu

B. Baselines

We compared our model against many baselines:

1) Random Transfers (chance): Trajectories are selected at
random from the set of trajectories in the training set.
2) Object Part ClassiÔ¨Åer: To test our hypothesis that classi-
fying object parts as an intermediate step does not guarantee
successful transfers, we trained an object part classiÔ¨Åer using
multiclass SVM [67] on point-cloud features œÜ(p) including
local shape features [32], histogram of curvatures [52], and
distribution of points. Using this classiÔ¨Åer, we Ô¨Årst classify
the target object part p into an object part category (e.g.
‚Äòhandle‚Äô, ‚Äòknob‚Äô), then use the same feature space to Ô¨Ånd its
nearest neighbor p(cid:48) of the same class from the training set.
Then the trajectory œÑ (cid:48) of p(cid:48) is transferred to p.
3) Structured support vector machine (SSVM): We used
SSVM to learn a discriminant scoring function F : P √ó
L √ó T ‚Üí R. At test time, for target point-cloud/language

4Although not necessary for training our model, we also collected

trajectories from the expert for evaluation purposes.

pair (p, l), we output the trajectory œÑ from the training set
that maximizes F. To train SSVM, we use a joint feature
mapping œÜ(p, l, œÑ ) = [œÜ(œÑ ); œÜ(p, œÑ ); œÜ(l, œÑ )]. œÜ(œÑ ) applies
Isomap [63] to interpolated œÑ for non-linear dimensionality
reduction. œÜ(p, œÑ ) captures the overall shape when trajectory
œÑ is overlaid over point-cloud p by jointly representing them
in a voxel-based cube similar to Sec. III-B, with each voxel
holding count of occupancy by p or œÑ . Isomap is applied
to this representation to get the Ô¨Ånal œÜ(p, œÑ ). Finally, œÜ(l, œÑ )
is the tensor product of the language features and trajectory
features: œÜ(l, œÑ ) = œÜ(l) ‚äó œÜ(œÑ ). We used our loss function
(Sec. VI) to train SSVM and used the cutting plane method
to solve the SSVM optimization problem [28].

4) Latent Structured SVM (LSSVM) + kinematic structure:
The way in which an object is manipulated largely depends
on its internal structure ‚Äì whether it has a ‚Äòrevolute‚Äô, ‚Äòpris-
matic‚Äô, or ‚ÄòÔ¨Åxed‚Äô joint. Instead of explicitly trying to learn
this structure, we encoded this internal structure as latent
variable z ‚àà Z, composed of joint type, center of joint,
and axis of joint [58]. We used Latent SSVM [76] to train
with z, learning the discriminant function F : P √ó L √ó
T √ó Z ‚Üí R. The model was trained with feature map-
ping œÜ(p, l, œÑ, z) = [œÜ(œÑ ); œÜ(p, œÑ ); œÜ(l, œÑ ); œÜ(l, z); œÜ(p, œÑ, z)],
which includes additional features that involve z. œÜ(l, z)
captures the relation between l, a bag-of-words represen-
tation of language, and bag-of-joint-types encoded by z
(vector of length 3 indicating existence of each joint type)
by computing the tensor product œÜ(l) ‚äó œÜ(z), then reshaping
the product into a vector. œÜ(p, œÑ, z) captures how well the
portion of œÑ that actually interacts with p abides by the
internal structure h. œÜ(p, œÑ, z) is a concatenation of three
types of features, one for each joint type. For ‚Äòrevolute‚Äô
type joints, it includes deviation of trajectory from plane of
rotation deÔ¨Åned by z, the maximum angular rotation while
maintaining pre-deÔ¨Åned proximity to the plane of rotation,
and the average cosine similarity between rotation axis of œÑ

TABLE I
RESULTS ON OUR DATASET WITH 5-fold cross-validation. ROWS LIST MODELS WE TESTED INCLUDING OUR MODEL AND BASELINES. COLUMNS
SHOW DIFFERENT METRICS USED TO EVALUATE THE MODELS.

Models
Chance
Object Part ClassiÔ¨Åer

per manual
DTW-MT
28.0 (¬±0.8)
-

Latent SSVM + Kinematic [58]
Task similarity + Random
Task Similarity + Weights [17]
Deep Network with Noise-handling without Embedding
Deep Multimodal Network without Embedding
Deep Multimodal Network with Noise-handling without Embedding [61]
LMNN-like Cost Function [72]
Our Model without Any Pretraining
Our Model with SDA
Our Model without Noise Handling
Our Model with Experts
Our Model - Deep Multimodal Embedding

Structured SVM 21.0 (¬±1.6)
17.4 (¬±0.9)
14.4 (¬±1.5)
13.3 (¬±1.2)
13.7 (¬±1.6)
14.0 (¬±2.3)
13.0 (¬±1.3)
15.4 (¬±1.8)
13.2 (¬±1.4)
11.5 (¬±0.6)
12.6 (¬±1.3)
12.3 (¬±0.5)
11.0 (¬±0.8)

per instruction

DTW-MT
27.8 (¬±0.6)
22.9 (¬±2.2)
21.4 (¬±1.6)
17.5 (¬±1.6)
13.5 (¬±1.4)
12.5 (¬±1.2)
13.3 (¬±1.6)
13.7 (¬±2.1)
12.2 (¬±1.1)
14.7 (¬±1.6)
12.4 (¬±1.0)
11.1 (¬±0.6)
12.1 (¬±1.1)
11.8 (¬±0.9)
10.5 (¬±0.7)

Accuracy (%)
11.2 (¬±1.0)
23.3 (¬±5.1)
26.9 (¬±2.6)
40.8 (¬±2.5)
49.4 (¬±3.9)
53.7 (¬±5.8)
51.9 (¬±7.9)
49.7 (¬±10.0)
60.0 (¬±5.1)
55.5 (¬±5.3)
54.2 (¬±6.0)
62.6 (¬±5.8)
53.8 (¬±8.0)
56.5 (¬±4.5)
65.1 (¬±4.9)

and axis deÔ¨Åned by z. For ‚Äòprismatic‚Äô joints, it includes the
average cosine similarity between the extension axis and the
displacement vector between waypoints. Finally, for ‚ÄòÔ¨Åxed‚Äô
joints, it includes whether the uninteracting part of œÑ has
collision with the background p since it is important to
approach the object from correct angle.
5) Task-Similarity Transfers + random: We compute the pair-
wise similarities between the test case (ptest, ltest) and each
training example (ptrain, ltrain), then transfer a trajectory
œÑ associated with the training example of highest similarity.
Pairwise similarity is deÔ¨Åned as a convex combination of the
cosine similarity in bag-of-words representations of language
and the average mutual point-wise distance of two point-
clouds after a Ô¨Åxed number of iterations of the ICP [7]
algorithm. If there are multiple trajectories associated with
(ptrain, ltrain) of highest similarity, the trajectory for transfer
is selected randomly.
6) Task-similarity Transfers + weighting: The previous
method is problematic when non-expert demonstrations for a
single task (ptrain, ltrain) vary in quality. Forbes et al. [17]
introduces a score function for weighting demonstrations
based on weighted distance to the ‚Äúseed‚Äù (expert) demon-
stration. Adapting to our scenario of not having any expert
demonstrations, we select œÑ that has the lowest average
distance from all other demonstrations for the same task,
with each distance measured with our loss function (Sec. VI.)
This is similar to our noise handling approach in Sec. V-C.
7) Deep Network without Embedding: We train a deep neural
network to learn a similar scoring function F : P √óL√óT ‚Üí
R to that learned for SSVM above. This model discrimina-
tively projects the combination of point-cloud, language, and
trajectory features to a score which represents how well the
trajectory matches that point-cloud/language combination.
Note that this is much less efÔ¨Åcient than our joint embedding
approach, as it must consider all combinations of a new
point-cloud/language pair and every training trajectory to
perform inference, as opposed to our model which need only
project this new pair to our joint embedding space. This deep

Fig. 7. Deep Multimodal Network without Embedding baseline model
takes the input x of three different modalities (point-cloud, language, and
trajectory) and outputs y, whether it is a good match or bad match. It Ô¨Årst
learns features separately (h1) for each modality and then learns the relation
(h2) between input and output of the original structured problem. Finally,
last hidden layer h3 learns relations of all these modalities.

learning model concatenates all the input of three modalities
and learns three hidden layers before the Ô¨Ånal layer.
8) Deep Multimodal Network without Embedding: The same
approach as ‚ÄòDeep Network without Embedding‚Äô with layers
per each modality before concatenating as shown in Figure 7.
More details about the model can be found in [61].
9) LMNN [72]-like cost function: For all top layer Ô¨Åne-tuning
and lower layer pre-training, we deÔ¨Åne the cost function
without loss augmentation. Similar to LMNN [72], we give
a Ô¨Ånite margin between similarities. For example, as cost
function for h3:

Lh3 (pi, li, œÑi) = |1+sim(Œ¶P,L(pi, li), Œ¶T (œÑ (cid:48)))

‚àísim(Œ¶P,L(pi, li), Œ¶T (œÑi))|+

10) Our Model without Pretraining: Our full model Ô¨Ånetuned
without any pre-training of lower layers ‚Äì all parameters are
randomly initialized.
11) Our Model with SDA: Our full model without pre-
training h2,pl and h2,œÑ as deÔ¨Åned in Section V-A and

point cloud(ùíë)language(ùíç)trajectory(ùùâ)‚Ñé1ùë•‚Ñé2‚Ñé3ùë¶Fig. 8. Examples of successful and unsuccessful transfers of manipulation trajectory from left to right using our model. In Ô¨Årst two examples, though
the robot has never seen the ‚Äòcoffee dispenser‚Äô and ‚Äòslow cooker‚Äô before, the robot has correctly identiÔ¨Åed that the trajectories of ‚Äòcereal dispenser‚Äô and
‚ÄòDC power supply‚Äô, respectively, can be used to manipulate them.

Section V-B. Instead, we pre-train each layer as stacked de-
noising autoencoders [71, 78].
12) Our Model without Noise Handling: Our model is trained
without noise handling as presented in Section V-C. All of
the trajectories collected from the crowd are trusted as a
ground-truth labels.
13) Our Model with Experts: Our model is trained only
using trajectory demonstrations from an expert which were
collected for evaluation purposes.
14) Our Full Model - Deep Multimodal Embedding: Our full
model as described in this paper with network size of h1,p,
h1,l, h1,œÑ , h2,pl, h2,œÑ , and h3 respectively having a layer with
150, 175, 100, 100, 75, and 50 nodes.

C. Results and Discussions

We evaluated all models on our dataset using 5-fold cross-
validation and the results are in Table I. All models which
required hyper-parameter tuning used 10% of the training
data as the validation set.

Rows list

the models we tested including our model
and baselines. Each column shows one of three evaluation
metrics. The Ô¨Årst two use dynamic time warping for manip-
ulation trajectory (DTW-MT) from Sec. VI. The Ô¨Årst column
shows averaged DTW-MT for each instruction manual con-
sisting of one or more language instructions. The second
column shows averaged DTW-MT for every test pair (p, l).
As DTW-MT values are not intuitive, we also include
a measure of ‚Äúaccuracy,‚Äù which shows the percentage of
transferred trajectories with DTW-MT value less than 10.
Through expert surveys, we found that when DTW-MT of
manipulation trajectory is less than 10, the robot came up
with a reasonable trajectory and will very likely be able
to accomplish the given task. Additionally, Fig. 11 shows
accuracies obtained by varying the threshold on the DTW-
MT measure.
Can manipulation trajectories be transferred from com-
pletely different objects? Our full model gave 65.1% accu-
racy (Table I), outperforming every other baseline approach
tested.

Fig. 8 shows two examples of successful transfers and
one unsuccessful transfer by our model. In the Ô¨Årst example,

the trajectory for pulling down on a cereal dispenser is
transferred to a coffee dispenser. Because our approach
to trajectory representation is based on the principal axis
(Sec. III-C), even though the cereal and coffee dispenser
handles are located and oriented differently, the transfer is
a success. The second example shows a successful transfer
from a DC power supply to a slow cooker, which have
‚Äúknobs‚Äù of similar shape. The transfer was successful despite
the difference in instructions (‚ÄúTurn the switch..‚Äù and ‚ÄúRotate
the knob..‚Äù) and object type. This highlights the advantages
of our end-to-end approach over relying on semantic classes
for parts and actions.

The last example in Fig. 8 shows a potentially unsuccessful
transfer. Despite the similarity in two instructions and sim-
ilarity in required counterclockwise motions, the transferred
motion might not be successful. While the knob on radiator
must be grasped in the middle, the rice cooker has a handle
that extends sideways, requiring it to be grasped off-center.
For clarity of visualization in Ô¨Ågures, we have overlaid CAD
models over some noisy point-clouds. Many of the object
parts were too small and/or too glossy for the Kinect sensor.
We believe that a better 3-D sensor would allow for more
accurate transfers. On the other hand, it is interesting to
note that the transfer in opposite direction from the radiator
knob to the rice cooker handle may have yielded a correct
manipulation.
Can we crowd-source the teaching of manipulation tra-
jectories? When we trained our full model with expert
demonstrations, which were collected for evaluation pur-
poses, it performed at 56.5% compared to 65.1% by our
model trained with crowd-sourced data. Even though non-
expert demonstrations can carry signiÔ¨Åcant noise, as shown
in last two examples of Fig. 6, our noise-handling approach
allowed our model
less
accurate crowd-sourced dataset. Note that all of our crowd
users are true non-expert users from Amazon Mechanical
Turk.
Is segmentation required for the system? Even with the
state-of-the-art techniques [16, 33], detection of ‚Äòmanipula-
ble‚Äô object parts such as ‚Äòhandles‚Äô and ‚Äòlevers‚Äô in a point-

to take advantage of the larger,

‚ÄúPull the Colossal Crunch handle to dispense.‚Äù‚ÄúPull down on the right handle to dispense the coffee.‚Äù‚ÄúTurn the switch clockwise to switch on the power supply‚Äù‚ÄúRotate the knob clockwise to turn slow cooker on.‚ÄùSuccessful TransfersUnsuccessful Transfer‚ÄúTurn the handle counterclockwise to unlock the cooker.‚Äù‚ÄúTurn the knob counterclockwise to decrease the temperature‚ÄùExamples of transferred trajectories being executed on PR2. On the left, PR2 is able to rotate the ‚Äòknob‚Äô to turn the lamp on. In the third
Fig. 10.
snapshot, using two transferred trajectories, PR2 is able to hold the cup below the ‚Äònozzle‚Äô and press the ‚Äòlever‚Äô of ‚Äòcoffee dispenser‚Äô. In the last example,
PR2 is frothing milk by pulling down on the lever, and is able to prepare a cup of latte with many transferred trajectories.

over 70% recognition accuracy in classifying Ô¨Åve major
classes of object parts (‚Äòbutton‚Äô, ‚Äòknob‚Äô, ‚Äòhandle‚Äô, ‚Äònozzle‚Äô,
‚Äòlever‚Äô.) However, the Object Part ClassiÔ¨Åer baseline, based
on this classiÔ¨Åcation, performed at only 23.3% accuracy for
actual trajectory transfer, outperforming chance by merely
12.1%, and signiÔ¨Åcantly underperforming our model‚Äôs result
of 65.1%. This shows that object part labels alone are not
sufÔ¨Åcient to enable manipulation motion transfer, while our
model, which makes use of richer information, does a much
better job.
Can features be hand-coded? What does learned deep
embedding space represent? Even though we carefully
designed state-of-the-art task-speciÔ¨Åc features for the SSVM
and LSSVM models, these models only gave at most 40.8%
accuracy. The task similarity method gave a better result
of 53.7%, but it requires access to all of the raw training
data (point-clouds, language, and trajectories) at test time,
which leads to heavy computation at test time and requires a
large amount of storage as the size of training data increases.
Our approach, by contrast, requires only the trajectory data,
and a low-dimensional representation of the point-cloud and
language data, which is much less expensive to store than
the raw data.

This shows that it is extremely difÔ¨Åcult to Ô¨Ånd a good set
of features which properly combines these three modalities.
Our multimodal embedding model does not require hand-
designing such features, instead learning a joint embedding
space as shown by our visualization of the top layer h3
in Figure 12. This visualization is created by projecting all
training data (point-cloud/language pairs and trajectories) of
one of the cross-validation folds to h3, then embedding them
to 2-dimensional space using t-SNE [69]. Although previous
work [61] was able to visualize several nodes in the top
layer, most were difÔ¨Åcult to interpret. With our model, we can
embed all our data and visualize all the layers (see Figs. 12
and 13).

One interesting result

is that our system was able to
naturally learn that ‚Äúnozzle‚Äù and ‚Äúspout‚Äù are effectively
synonyms for purposes of manipulation. It clustered these
together in the lower-right of Fig. 12 based solely on the fact
that both are associated with similar point-cloud shapes and
manipulation trajectories. At the same time, it also identiÔ¨Åed
one exception, a small cluster of ‚Äúnozzles‚Äù in the center of
Fig. 12 which require different manipulation motions.

Comparisons of transfers between our model and the base-
Fig. 9.
line (deep multimodal network without embedding [61]). In these three
examples, our model successfully Ô¨Ånds correct manipulation trajectory from
these objects while the other one does not. Given the lever of the toaster,
our algorithm Ô¨Ånds similarly slanted part from the rice cooker while the
other model Ô¨Ånds completely irrelevant trajectory. For the opening action
of wafÔ¨Çe maker, trajectory for paper cutter is correctly identiÔ¨Åed while the
other model transfers from a handle that has incompatible motion.

cloud is by itself a challenging problem [35]. Thus, we
rely on human experts to pre-label parts of the object to be
manipulated. The point-cloud of the scene is over-segmented
into thousands of supervoxels, from which the expert chooses
the part of the object to be manipulated. Even with expert
input, such segmented point-clouds are still extremely noisy
because of sensor failures, e.g. on glossy surfaces.
Is intermediate object part labeling necessary? A multi-
class SVM trained on object part labels was able to obtain

‚ÄúPress the button to open the lid.‚Äù‚ÄúPush down on the right lever to start toasting.‚Äù‚ÄúTurn handle counterclockwise to turn on cold water.‚Äù‚ÄúLift up the handle before placing the paper.‚Äù‚ÄúPull the handle up to open the waffle maker.‚Äù‚ÄúPull down the center handle to fill the cup with ice.‚ÄùInputDeep Multimodal Networkwithout Embedding [60]Deep Multimodal Embedding(Our Model)‚ÄúPush the Diet Pepsi button to fill the cup.‚Äù‚ÄúIn an emergency, hit the push-button in the back.‚Äù‚ÄúRotate the handle on the right clockwise.‚Äùmakes sense because one point-cloud might afford many
possible actions, while language instructions are much more
speciÔ¨Åc.
Does embedding improve efÔ¨Åciency? The previous model
[61] had 749, 638 parameters to be learned, while our model
has only 418, 975 (and still gives better performance.)

The previous model had to compute joint point-
cloud/language/trajectory features for all combinations of
the current point-cloud/language pair with each candidate
trajectory (i.e. all trajectories in the training set) to infer
an optimal trajectory. This is inefÔ¨Åcient and does not scale
well with the number of training datapoints. However, our
model pre-computes the projection of all trajectories into h3.
Inference in our model then requires only projecting the new
point-cloud/language combination to h3 once and Ô¨Ånding the
trajectory with maximal similarity in this embedding.

In practice, this results in a signiÔ¨Åcant improvement in
efÔ¨Åciency, decreasing the average time to infer a trajectory
from 2.3206ms to 0.0135ms, a speed-up of about 171x. Time
was measured on the same hardware, with a GPU (GeForce
GTX Titan X), using the Theano library [5]. We measured
inference times 10000 times for Ô¨Årst test fold, which has
a pool of 962 trajectories. Time to preprocess the data and
time to load into GPU memory was not included in this
measurement. We note that the only part of our algorithm‚Äôs
runtime which scales up with the amount of training data
is the nearest-neighbor computation, for which there exist
many efÔ¨Åcient algorithms [45]. Thus, our algorithm could
be scaled to much larger datasets, allowing it to handle a
wider variety of tasks, environments, and objects.

D. Robotic Validation

To validate the concept of part-based manipulation trajec-
tory transfer in a real-world setting, we tested our algorithm
on our PR2 robot. To ensure real transfers, we tested with
four objects the algorithm had never seen before ‚Äì a coffee
dispenser, coffee grinder, lamp, and espresso machine.

The PR2 robot has two 7DoF arms, an omni-directional
base, and many sensors including a Microsoft Kinect, stereo
cameras, and a tilting laser scanner. For these experiments, a
point-cloud is acquired from the head mounted Kinect sensor
and each motion is executed on the speciÔ¨Åed arm using a
Cartesian end-effector stiffness controller [9] in ROS [51].

For each object, the robot is presented with a segmented
point-cloud along with a natural language text manual, with
each step in the manual associated with a segmented part
in the point-cloud. Once our algorithm outputs a trajectory
(transferred from a completely different object), we Ô¨Ånd the
manipulation frame for the part‚Äôs point-cloud by using its
principal axis (Sec. III-B). Then, the transferred trajectory
can be executed relative to the part using this coordinate
frame, without any modiÔ¨Åcation to the trajectory.

The chosen manipulation trajectory, deÔ¨Åned as a set of
waypoints, is converted to a smooth and densely interpolated
trajectory (Sec. III-A.) The robot Ô¨Årst computes and execute
a collision-free motion to the starting point of the manipu-
lation trajectory. Then, starting from this Ô¨Årst waypoint, the

Thresholding Accuracy: Accuracy-threshold graph showing
Fig. 11.
results of varying thresholds on DTW-MT scores. Our algorithm consistently
outperforms the previous approach [61] and an LMNN-like cost function
[72].

In addition to the aforementioned cluster in the bottom-
right of Fig. 12, we see several other logical clusters.
Importantly, we can see that our embedding maps vertical
and horizontal rotation operations to very different regions
of the space ‚Äì roughly 12 o‚Äôclock and 8 o‚Äôclock in Fig. 12, re-
spectively. Even though these have nearly identical language
instructions, our algorithm learns to map them differently
based on their point-clouds, mapping nearby the appropriate
manipulation trajectories.
Should cost
function be loss-augmented? When we
changed the cost function for pre-training h2 and Ô¨Åne-
tuning h3 to use a constant margin of 1 between relevant
Ti,S and irrelevant Ti,D demonstrations [72], performance
drops to 55.5%. This loss-augmentation is also visible in
our embedding space. Notice the purple cluster around the 6
o‚Äôclock region of Fig. 12, and the lower part of the cluster in
the 5 o‚Äôclock region. The purple cluster represents tasks and
demonstrations related to pushing a bar (often found on soda
fountains), and the lower part of the red cluster represents the
task of holding a cup below the nozzle. Although the motion
required for one task would not be replaceable by the other,
the motions and shapes are very similar, especially compared
to most other motions e.g. turning a horizontal knob.
Is pre-embedding important? As seen in Table I, without
any pre-training our model gives an accuracy of only 54.2%.
Pre-training the lower layers with the conventional stacked
de-noising auto-encoder (SDA) algorithm [71, 78] increases
performance to 62.6%, still signiÔ¨Åcantly underperforming
our pre-training algorithm, which gives 65.1%. This shows
that our metric embedding pre-training approach provides a
better initialization for an embedding space than SDA.

Fig. 13 shows the joint point-cloud/language embedding
h2,pl after the network is initialized using our pre-training
algorithm and then Ô¨Åne-tuned using our cost function for
h3. While this space is not as clearly clustered as h3 shown
in Fig. 12, we note that point-clouds tend to appear in the
more general center of the space, while natural language
instructions appear around the more-speciÔ¨Åc edges. This

203040506070809010051015202530Accuracy (%)ThresholdSung et al. [61]LMNN-like cost func.Our Model without Noise HandlingOur ModelLearned Deep Point-cloud/Language/Trajectory Embedding Space:

Joint embedding space h3 after the network is fully Ô¨Åne-tuned,
Fig. 12.
visualized in 2d using t-SNE [69] . Inverted triangles represent projected point-cloud/language pairs, circles represent projected trajectories. The occupancy
grid representation of object part point-clouds is shown in green in blue grids. Among the two occupancy grids (Sec. III-B), we selected the one that
is more visually parsable for each object. The legend at the bottom right shows classiÔ¨Åcations of object parts by an expert, collected for the purpose of
building a baseline. As shown by result of this baseline (object part classiÔ¨Åer in Table I), these labels do not necessarily correlate well with the actual
manipulation motion. Thus, full separation according to the labels deÔ¨Åned in the legend is not optimal and will not occur in this Ô¨Ågure or Fig. 13. These
Ô¨Ågures are best viewed in color.

interpolated trajectory is executed. For these experiments, we
placed the robot in reach of the object, but one could also
Ô¨Ånd a location using a motion planner that would make all
waypoints of the manipulation trajectory reachable.

Some of the examples of successful execution on a PR2
robot are shown in Fig. 10 and in video at the project website:
http://robobarista.cs.cornell.edu/. For example,
a manipulation trajectory from the task of ‚Äúturning on a light
switch‚Äù is transferred to the task of ‚ÄúÔ¨Çipping on a switch to
start extracting espresso‚Äù, and a trajectory for turning on DC
power supply (by rotating clockwise) is transferred to turning
on the Ô¨Çoor lamp. These demonstrations shows that part-
based transfer of manipulation trajectories is feasible without
any modiÔ¨Åcation to the source trajectories by carefully
choosing their representation and coordinate frames (Sec. III-
C).

IX. CONCLUSION AND FUTURE WORK

In this work, we introduce a novel approach to predicting
manipulation trajectories via part based transfer, which al-
lows robots to successfully manipulate even objects they have
never seen before. We formulate this as a structured-output
problem and approach the problem of inferring manipulation

trajectories for novel objects by jointly embedding point-
cloud, natural language, and trajectory data into a common
space using a deep neural network. We introduce a method
for learning a common representation of multimodal data
using a new loss-augmented cost function, which learns
a semantically meaningful embedding from data. We also
introduce a method for pre-training the network‚Äôs lower
layers, learning embeddings for subsets of modalities, and
show that it outperforms standard pre-training algorithms.
Learning such an embedding space allows efÔ¨Åcient inference
by comparing the embedding of a new point-cloud/language
pair against pre-embedded demonstrations. We introduce our
crowd-sourcing platform, Robobarista, which allows non-
expert users to easily give manipulation demonstrations over
the web. This enables us to collect a large-scale dataset of
249 object parts with 1225 crowd-sourced demonstrations, on
which our algorithm outperforms all other methods tried. We
also verify on our robot that even manipulation trajectories
transferred from completely different objects can be used to
successfully manipulate novel objects the robot has never
seen before.

While our model is able to give correct manipulation tra-
jectories for most of the objects we tested it on, outperform-

Flip the circuit's switch down to turn it off.Pull down on the handle to dispense the tea.Turn handle counterclockwise to mix in hot water.Rotate the speaker knob clockwise until it clicks.Push down on the lever to start the toasting cycle.Push down on the right lever to dispense cold water.Rotate the Heart to Heart knob clockwise to dispense.To unlock the door, rotate the lock clockwise.Push the button to fill the cup.Press the button to turn the range hood on.Hold the bowl below the Colossal Crunch nozzle.Hold the cup below the nozzle on the left.Hold the milk pitcher under the froth wand and submerge the nozzle of the wand into the milk.Push on the bar to fill the cup with ice.Pull down on the right dispenser's lever to fill the cup.Push down on the handle to add hot water.Fig. 13. Learned Point-cloud/Language Space: Visualization of the point-cloud/language layer h2,lp in 2d using t-SNE [69] after the network is fully
Ô¨Åne-tuned. Inverted triangles represent projected point-clouds and circles represent projected instructions. A subset of the embedded points are randomly
selected for visualization. Since 3D point-clouds of object parts are hard to visualize, we also include a snapshot of a point-cloud showing the whole
object. Notice correlations in the motion required to manipulate the object or follow the instruction among nearby point-clouds and natural language.

ing all other approaches tried, open-loop execution of a pose
trajectory may not be enough to correctly manipulate some
objects. For such objects, correctly executing a transferred
manipulation trajectory may require incorporating visual
and/or force feedback [74, 70] in order for the execution
to adapt exactly to the object. For example, some dials or
buttons have to be rotated or pushed until they click, and
each might require a different amount of displacement to
accomplish this task. For such tasks, the robot would have to
use this feedback to adapt its trajectory in an online fashion.

Our current model also only takes into account the object
part and desired action in question. For some objects, a
correct trajectory according to these might still collide with
other parts of the environment. Once again, solving this
problem would require adapting the manipulation trajectory
after it‚Äôs selected, and is an interesting direction for future
work.

ACKNOWLEDGMENT

We thank Joshua Reichler for building the initial prototype
of the crowd-sourcing platform. We thank Ross Knepper and
Emin G¬®un Sirer for useful discussions. We thank NVIDIA
Corporation for the donation of the Tesla K40 GPU used
for this research. This work was supported by NRI award
1426452, ONR award N00014-14-1-0156, and by Microsoft
Faculty Fellowship and NSF Career Award to one of us
(Saxena).

REFERENCES

[1] P. Abbeel, A. Coates, and A. Ng.

Autonomous
helicopter aerobatics through apprenticeship learning.
International Journal of Robotics Research, 2010.
[2] D. W. Aha, D. Kibler, and M. K. Albert. Instance-based

learning algorithms. Machine learning, 1991.

[3] B. Alexander, K. Hsiao, C. Jenkins, B. Suay, and
R. Toris. Robot web tools [ros topics]. Robotics &
Automation Magazine, IEEE, 19(4):20‚Äì23, 2012.
[4] B. Argall, S. Chernova, M. Veloso, and B. Browning.
A survey of robot learning from demonstration. RAS,
2009.

[5] F. Bastien, P. Lamblin, R. Pascanu, et al. Theano: new
features and speed improvements. Deep Learning and
Unsupervised Feature Learning NIPS 2012 Workshop,
2012.

[6] Y. Bengio, A. Courville, and P. Vincent. Representation
Pattern
learning: A review and new perspectives.
Analysis and Machine Intelligence, IEEE Transactions
on, 35(8):1798‚Äì1828, 2013.

[7] P. J. Besl and N. D. McKay. Method for registration of
3-d shapes. In Robotics-DL tentative, pages 586‚Äì606.
International Society for Optics and Photonics, 1992.

[8] M. Blaschko and C. Lampert. Learning to localize
In ECCV.

objects with structured output regression.
2008.

[9] M. Bollini, J. Barry, and D. Rus. Bakebot: Baking cook-
ies with the pr2. In IEEE/RSJ International Conference
on Intelligent Robots and Systems PR2 Workshop, 2011.
[10] C. Crick, S. Osentoski, G. Jay, and O. C. Jenkins.

Pull down on the lever to dispense paper towel.Push down on the right lever to start toasting.Lift up the skim milk release bar handle.Pull the Corn Flakes handle to dispense.Pull the other knob clockwise to mix cold water.Turn the handle left (clockwise) until the cup has been filled.Rotate the left knob clockwise to the desired setting.Press the emergency stop button to directly remove power to actuators of robot.Rotate the leftmost knob clockwise to the desired setting.Hold the cup below the apple juice nozzle.Place the cup below the nozzle.Hold the cup below the spout.Push the handle to fill the bottle.Examples of objects and object parts. Each image shows the point cloud representation of an object. We overlaid some of its parts by CAD
Fig. 14.
models for online Robobarista crowd-sourcing platform. Note that the actual underlying point-cloud of object parts contains much more noise and is not
clearly segmented, and none of the models have access to overlaid model for inferring manipulation trajectory.

Human and robot perception in large-scale learning
from demonstration. In HRI. ACM, 2011.

[11] H. Dang and P. K. Allen. Semantic grasping: Planning
robotic grasps functionally suitable for an object ma-
nipulation task. In IEEE/RSJ International Conference
on Intelligent Robots and Systems, 2012.

[12] C. Daniel, G. Neumann, and J. Peters.

Learning
concurrent motor skills in versatile solution spaces.
In IEEE/RSJ International Conference on Intelligent
Robots and Systems. IEEE, 2012.

[13] R. Detry, C. H. Ek, M. Madry, and D. Kragic. Learning
a dictionary of prototypical grasp-predicting parts from
grasping experience. In IEEE International Conference
on Robotics and Automation, 2013.

[14] F. Endres, J. Trinkle, and W. Burgard. Learning the dy-
namics of doors for robotic manipulation. In IEEE/RSJ
International Conference on Intelligent Robots and
Systems, 2013.

[15] G. Erdogan, I. Yildirim, and R. A. Jacobs. Transfer of
object shape knowledge across visual and haptic modal-
ities. In Proceedings of the 36th Annual Conference of
the Cognitive Science Society, 2014.

[16] P. F. Felzenszwalb, R. B. Girshick, D. McAllester, and
D. Ramanan. Object detection with discriminatively
trained part-based models. PAMI, 32(9):1627‚Äì1645,
2010.

[17] M. Forbes, M. J.-Y. Chung, M. Cakmak, and R. P.
Robot programming by demonstration with
Rao.
crowdsourced action Ô¨Åxes. In Second AAAI Conference
on Human Computation and Crowdsourcing, 2014.
[18] J. J. Gibson. The ecological approach to visual percep-

tion. Psychology Press, 1986.

[19] R. Girshick, P. Felzenszwalb, and D. McAllester. Ob-

ject detection with grammar models. In NIPS, 2011.

[20] I. Goodfellow, Q. Le, A. Saxe, H. Lee, and A. Y.
Ng. Measuring invariances in deep networks. In NIPS,
2009.

[21] R. Hadsell, A. Erkan, P. Sermanet, M. ScofÔ¨Åer,
U. Muller, and Y. LeCun. Deep belief net learning
in a long-range vision system for autonomous off-
road driving. In IEEE/RSJ International Conference on
Intelligent Robots and Systems, pages 628‚Äì633. IEEE,
2008.

[22] G. Hinton and R. Salakhutdinov. Reducing the dimen-
sionality of data with neural networks. Science, 313
(5786):504‚Äì507, 2006.

[23] K. Hsiao, S. Chitta, M. Ciocarlie, and E. Jones.
Contact-reactive grasping of objects with partial shape
information. In IEEE/RSJ International Conference on
Intelligent Robots and Systems, 2010.

[24] J. Hu, J. Lu, and Y.-P. Tan. Discriminative deep
metric learning for face veriÔ¨Åcation in the wild.
In
The IEEE Conference on Computer Vision and Pattern
Recognition, 2014.

ley, USA, July 2014.

[26] S. Izadi, D. Kim, O. Hilliges, D. Molyneaux, R. New-
combe, P. Kohli, et al. Kinectfusion: real-time 3d
reconstruction and interaction using a moving depth
camera. In ACM Symposium on UIST, 2011.

[27] A. Jain, B. Wojcik, T. Joachims, and A. Saxena. Learn-
ing preferences for manipulation tasks from online
coactive feedback. In International Journal of Robotics
Research, 2015.

[28] T. Joachims, T. Finley, and C.-N. J. Yu. Cutting-plane

training of structural svms. Machine Learning, 2009.

[29] D. Katz, M. Kazemi, J. Andrew Bagnell, and A. Stentz.
Interactive segmentation, tracking, and kinematic mod-
In IEEE
eling of unknown 3d articulated objects.
International Conference on Robotics and Automation,
pages 5003‚Äì5010. IEEE, 2013.

[30] B. Kehoe, A. Matsukawa, S. Candido, J. Kuffner, and
K. Goldberg. Cloud-based robot grasping with the
google object recognition engine. In IEEE International
Conference on Robotics and Automation, 2013.
[31] H. Koppula and A. Saxena. Anticipating human ac-
tivities using object affordances for reactive robotic
response. In Robotics: Science and Systems, 2013.
[32] H. Koppula, A. Anand, T. Joachims, and A. Saxena.
Semantic labeling of 3d point clouds for indoor scenes.
NIPS, 2011.

[33] A. Krizhevsky, I. Sutskever, and G. E. Hinton. Imagenet
classiÔ¨Åcation with deep convolutional neural networks.
In NIPS, 2012.

[34] O. Kroemer, E. Ugur, E. Oztop, and J. Peters. A kernel-
In IEEE
based approach to direct action perception.
International Conference on Robotics and Automation,
2012.

[35] K. Lai, L. Bo, and D. Fox. Unsupervised feature
learning for 3d scene labeling. In IEEE International
Conference on Robotics and Automation, 2014.
[36] I. Lenz, H. Lee, and A. Saxena. Deep learning for de-
tecting robotic grasps. Robotics: Science and Systems,
2013.

[37] I. Lenz, R. Knepper, and A. Saxena. Deepmpc: Learn-
ing deep latent features for model predictive control. In
Robotics: Science and Systems, 2015.
[38] S. Levine, N. Wagener, and P. Abbeel.

Learning
contact-rich manipulation skills with guided policy
search. IEEE International Conference on Robotics and
Automation, 2015.

[39] L.-J. Li, R. Socher, and L. Fei-Fei. Towards total scene
understanding: ClassiÔ¨Åcation, annotation and segmen-
tation in an automatic framework. In The IEEE Con-
ference on Computer Vision and Pattern Recognition,
2009.

[40] O. Mangin, P.-Y. Oudeyer, et al. Unsupervised learning
of simultaneous motor primitives through imitation. In
IEEE ICDL-EPIROB, 2011.

[25] N. Hu, Z. Lou, G. Englebienne, and B. Krse. Learning
to recognize human activities from soft labeled data. In
Proceedings of Robotics: Science and Systems, Berke-

[41] T. Mikolov, Q. V. Le, and I. Sutskever. Exploiting
similarities among languages for machine translation.
CoRR, 2013.

[42] S. Miller, J. Van Den Berg, M. Fritz, T. Darrell,
K. Goldberg, and P. Abbeel. A geometric approach
International Journal of
to robotic laundry folding.
Robotics Research, 2012.

[43] D. Misra, J. Sung, K. Lee, and A. Saxena. Tell me
dave: Context-sensitive grounding of natural language
to mobile manipulation instructions. In Robotics: Sci-
ence and Systems, 2014.

[44] J. Moore, S. Chen, T. Joachims, and D. Turnbull. Learn-
ing to embed songs and tags for playlist prediction.
In Conference of the International Society for Music
Information Retrieval (ISMIR), pages 349‚Äì354, 2012.
[45] M. Muja and D. G. Lowe. Scalable nearest neighbor
algorithms for high dimensional data. PAMI, 2014.
[46] K. M¬®ulling, J. Kober, O. Kroemer, and J. Peters.
Learning to select and generalize striking movements
in robot table tennis. International Journal of Robotics
Research, 32(3):263‚Äì279, 2013.

[47] J. Ngiam, A. Khosla, M. Kim, J. Nam, H. Lee, and
A. Y. Ng. Multimodal deep learning. In International
Conference on Machine Learning, 2011.

[48] P. Pastor, H. Hoffmann, T. Asfour, and S. Schaal.
Learning and generalization of motor skills by learning
from demonstration. In IEEE International Conference
on Robotics and Automation, 2009.

[49] M. Phillips, V. Hwang, S. Chitta, and M. Likhachev.
Learning to plan for constrained manipulation from
In Robotics: Science and Systems,
demonstrations.
2013.

[50] S. Pillai, M. Walter, and S. Teller. Learning articulated
motions from visual demonstration. In Robotics: Sci-
ence and Systems, 2014.

[51] M. Quigley, K. Conley, B. Gerkey, J. Faust, T. Foote,
J. Leibs, R. Wheeler, and A. Y. Ng. Ros: an open-
source robot operating system. In ICRA workshop on
open source software, volume 3, page 5, 2009.

[52] R. Rusu and S. Cousins.

3D is here: Point Cloud
In IEEE International Conference on

Library (PCL).
Robotics and Automation, 2011.

[53] K. Shoemake. Animating rotation with quaternion

curves. SIGGRAPH, 19(3):245‚Äì254, 1985.

[54] R. Socher, J. Pennington, E. Huang, A. Ng, and
C. Manning. Semi-supervised recursive autoencoders
for predicting sentiment distributions. In EMNLP, 2011.
[55] R. Socher, B. Huval, B. Bhat, C. Manning, and A. Ng.
Convolutional-recursive deep learning for 3d object
classiÔ¨Åcation. In NIPS, 2012.

[56] K. Sohn, W. Shang, and H. Lee. Improved multimodal
deep learning with variation of information. In NIPS,
2014.

[57] N. Srivastava and R. R. Salakhutdinov. Multimodal
learning with deep boltzmann machines. In NIPS, 2012.
[58] J. Sturm, C. Stachniss, and W. Burgard. A probabilistic
framework for learning kinematic models of articulated
objects. Journal of ArtiÔ¨Åcial Intelligence Research, 41
(2):477‚Äì526, 2011.

[59] J. Sung, C. Ponce, B. Selman, and A. Saxena. Un-

structured human activity detection from rgbd images.
In IEEE International Conference on Robotics and
Automation, 2012.

[60] J. Sung, B. Selman, and A. Saxena.

Synthesizing
manipulation sequences for under-speciÔ¨Åed tasks using
unrolled markov random Ô¨Åelds. In IEEE/RSJ Interna-
tional Conference on Intelligent Robots and Systems,
2014.

[61] J. Sung, S. H. Jin, and A. Saxena. Robobarista: Object
part-based transfer of manipulation trajectories from
In International
crowd-sourcing in 3d pointclouds.
Symposium on Robotics Research (ISRR), 2015.
[62] S. Tellex, R. Knepper, A. Li, T. Howard, D. Rus, and
N. Roy. Asking for help using inverse semantics.
Robotics: Science and Systems, 2014.

[63] J. Tenenbaum, V. De Silva, and J. Langford. A global
geometric framework for nonlinear dimensionality re-
duction. Science, 290(5500):2319‚Äì2323, 2000.

[64] S. Thrun, W. Burgard, D. Fox, et al. Probabilistic

robotics. MIT press Cambridge, 2005.

[65] R. Toris and S. Chernova. Robotsfor. me and robots for
you. In Proceedings of the Interactive Machine Learn-
ing Workshop, Intelligent User Interfaces Conference,
pages 10‚Äì12, 2013.

[66] R. Toris, D. Kent, and S. Chernova. The robot manage-
ment system: A framework for conducting human-robot
interaction studies through crowdsourcing. Journal of
Human-Robot Interaction, 3(2):25‚Äì49, 2014.

[67] I. Tsochantaridis, T. Hofmann, T. Joachims, and Y. Al-
tun. Support vector machine learning for interdependent
and structured output spaces. In ICML. ACM, 2004.

[68] I. Tsochantaridis, T. Joachims, T. Hofmann, Y. Altun,
and Y. Singer. Large margin methods for structured and
interdependent output variables. JMLR, 6(9), 2005.
[69] L. Van der Maaten and G. Hinton. Visualizing data
using t-sne. Journal of Machine Learning Research, 9
(2579-2605):85, 2008.

[70] F. Vina, Y. Bekiroglu, C. Smith, Y. Karayiannidis, and
D. Kragic. Predicting slippage and learning manipu-
lation affordances through gaussian process regression.
In Humanoids, 2013.

[71] P. Vincent, H. Larochelle, Y. Bengio, and P.-A. Man-
zagol. Extracting and composing robust features with
denoising autoencoders. In International Conference on
Machine Learning, 2008.

[72] K. Q. Weinberger, J. Blitzer, and L. K. Saul. Distance
metric learning for large margin nearest neighbor clas-
siÔ¨Åcation. In NIPS, 2005.

[73] J. Weston, S. Bengio, and N. Usunier. Wsabie: Scaling
In IJCAI,

up to large vocabulary image annotation.
2011.

[74] S. Wieland, D. Gonzalez-Aguirre, N. Vahrenkamp,
T. Asfour, and R. Dillmann. Combining force and vi-
sual feedback for physical interaction tasks in humanoid
robots. In Humanoid Robots, 2009.

[75] C. Wu, I. Lenz, and A. Saxena. Hierarchical semantic
labeling for task-relevant rgb-d perception. In Robotics:

Science and Systems, 2014.

[76] C.-N. Yu and T. Joachims. Learning structural svms
In International Conference on

with latent variables.
Machine Learning, 2009.

[77] M. D. Zeiler. Adadelta: An adaptive learning rate
method. arXiv preprint arXiv:1212.5701, 2012.
[78] M. D. Zeiler, M. Ranzato, R. Monga, et al. On rectiÔ¨Åed

linear units for speech processing. In ICASSP, 2013.

