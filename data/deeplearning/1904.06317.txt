Few-Shot Bayesian Imitation Learning with Logical Program Policies

Tom Silver, Kelsey R. Allen, Alex K. Lew, Leslie Kaelbling, Josh Tenenbaum
Massachusetts Institute of Technology
{tslvr, krallen, alexlew, lpk, jbt}@mit.edu

9
1
0
2

v
o
N
6
1

]
I

A
.
s
c
[

2
v
7
1
3
6
0
.
4
0
9
1
:
v
i
X
r
a

Abstract

Humans can learn many novel tasks from a very small num-
ber (1–5) of demonstrations, in stark contrast to the data re-
quirements of nearly tabula rasa deep learning methods. We
propose an expressive class of policies, a strong but general
prior, and a learning algorithm that, together, can learn inter-
esting policies from very few examples. We represent policies
as logical combinations of programs drawn from a domain-
speciﬁc language (DSL), deﬁne a prior over policies with a
probabilistic grammar, and derive an approximate Bayesian
inference algorithm to learn policies from demonstrations. In
experiments, we study six strategy games played on a 2D grid
with one shared DSL. After a few demonstrations of each
game, the inferred policies generalize to new game instances
that differ substantially from the demonstrations. Our policy
learning is 20–1,000x more data efﬁcient than convolutional
and fully convolutional policy learning and many orders of
magnitude more computationally efﬁcient than vanilla pro-
gram induction. We argue that the proposed method is an apt
choice for tasks that have scarce training data and feature sig-
niﬁcant, structured variation between task instances.

Introduction
People are remarkably good at learning and generalizing
strategies for everyday tasks, like ironing a shirt or brewing
a cup of coffee, from one or a few demonstrations. Websites
like WikiHow.com and LifeHacker.com are ﬁlled with thou-
sands of “how-to” guides for tasks that are hard to solve by
pure reasoning or trial and error alone, but easy to learn and
generalize from just one illustrated demo (Figure 1). We are
interested in designing artiﬁcial agents with the same few-
shot imitation learning capabilities.

A common approach to imitation learning is behavior
cloning (BC), in which demonstrations are used as super-
vision to directly train a policy. BC is often thought to be
too prone to overﬁtting to generalize from very little data.
Indeed, we ﬁnd that neural network policies trained with
BC are suspectible to severe overﬁtting in our experiments.
However, we argue that this failure is due not to BC in gen-
eral, but rather, to an underconstrained policy class and a
weak prior.

Copyright c(cid:13) 2020, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

Figure 1: People can learn strategies for an enormous vari-
ety of tasks from one or a few demonstrations, e.g., “gate
off an area,” “build stairs,” or “catch a bird” (left). We pro-
pose a policy class and learning algorithm for similarly data-
efﬁcient imitation learning. Given 1–5 demos of tasks like
“Fence In,” “Reach for the Star,” and “Chase” (middle), we
learn policies that generalize substantially (right).

More structured policies with strong Occam’s razor pri-
ors can be found in two lines of work: logical and rela-
tional (policy) learning (Dˇzeroski, De Raedt, and Blockeel
1998; Natarajan et al. 2011), and program (policy) synthesis
(Wingate et al. 2013; Sun et al. 2018). Policies expressed in
predicate logic are easy to learn, but difﬁcult to scale, since
each possible predicate must be hand-engineered by the re-
searcher. Programmatic policies can be automatically gener-
ated by searching a small domain-speciﬁc language (DSL),
but learning even moderately sophisticated policies can re-
quire an untenably large search in program space.

We propose Logical Program Policies (LPP): an expres-
sive, structured, and efﬁciently learnable policy class that

 
 
 
 
 
 
combines the strengths of logical and programmatic poli-
cies. Our ﬁrst main idea is to consider policies that have
logical “top level” structure and programmatic feature de-
tectors (predicates) at the “bottom level.” The feature detec-
tors are expressions in a domain-speciﬁc language (DSL).
By logically combining feature detectors, we can derive an
inﬁnitely large, rich policy class from a small DSL. This “in-
ﬁnite use of ﬁnite means” is in contrast to prior work in re-
lational RL where each feature is individually engineered,
making it labor-intensive to apply in complex settings.

Our second main idea is to exploit the logical structure
of LPP to obtain an efﬁcient imitation learning algorithm,
overcoming the intractability of general program synthesis.
To ﬁnd policies in LPP, we incrementally enumerate fea-
ture detectors, apply them to the demonstrations, invoke an
off-the-shelf Boolean learning method, and score each can-
didate policy with a likelihood and prior. What would be
an intractable search over full policies is effectively reduced
to a manageable search over feature detectors. We thus
have an efﬁcient approximate Bayesian inference method for
p(π|D), the posterior distribution of policies π given demon-
strations D.

While LPP and the proposed learning method are agnos-
tic to the particular choice of the DSL and application do-
main, we focus here on six strategy games which are played
on 2D grids of arbitrary size (see Figure 3). In these games,
a state consists of an assignment of discrete values to each
grid cell and an action is a single grid cell (a “click” on the
grid). The games are diverse in their transition rules and in
the tactics required to win, but the common state and action
spaces allow us to build our policies for all six games from
one shared, small DSL. In experiments, we ﬁnd that poli-
cies learned from ﬁve or fewer demonstrations can general-
ize perfectly in all six games. In contrast, policies learned as
convolutional neural networks fail to generalize, even when
domain-speciﬁc locality structure is built into the architec-
ture (as in fully convolutional networks (Long, Shelhamer,
and Darrell 2015)). Overall, our experiments suggest that
LPP offers an efﬁcient, ﬂexible framework for learning rich,
generalizable policies from very little data.

Problem Statement

In imitation learning, we are given a dataset D of expert
trajectories (s0, a0, ..., sT −1, aT −1, sT ) where st ∈ S are
states and at ∈ A are actions. We suppose that the trajecto-
ries are sampled from a Markov process M = (S, A, T, G),
with transition distribution T (s(cid:48)
| s, a) and goal states
G ⊂ S, and that actions are sampled from an expert policy
π∗ : S × A → [0, 1], where π∗(a | s) is a state-conditional
distribution over actions. For imitation learning, we must
specify (1) a hypothesis class of policies Π and (2) an al-
gorithm for learning a policy π ∈ Π from D that matches
the expert π∗. We assume that the expert π∗ is optimal with
respect to M, so we report the fraction of trials in which a
learned policy π reaches goal states in G from held-out ini-
tial states in M to evaluate performance.

The LPP Policy Class
We seek a policy class Π with a concise parameterization
that can be reasonably speciﬁed by a human programmer,
and for which there is a tractable learning algorithm for re-
covering π∗ ∈ Π from demonstrations.

We consider policies that are parameterized by state-
action classiﬁers h : S ×A → {0, 1}. When h(s, a) = 0, ac-
tion a will never be taken in state s; when h(s, a) = 1, a may
be taken. This parameterization allows us to handle arbitrar-
ily large action spaces (variable grid sizes). Given h(s, a),
we can derive a corresponding policy π(a | s) that samples
a uniformly at random among those a such that h(s, a) = 1.
In other words, π(a | s) ∝ h(s, a). This stochastic policy
formulation reﬂects the fact that the demonstrator may ran-
domly select among several optimal actions. For complete-
ness, we deﬁne π(a | s) ∝ 1 if ∀a, h(s, a) = 0. Specifying a
policy class Π thus reduces to specifying a class of functions
H from which to learn an h.

One option for H is to consider logical rules that com-
pute Boolean expressions combining binary features derived
from (s, a). Although this enables fast inference using well-
understood Boolean learning algorithms, it requires the AI
programmer to hand-engineer informative binary features,
which will necessarily vary from task to task. Another op-
tion is to consider programmatic rules: rules that are ex-
pressions in some general-purpose DSL for predicates on
state-action pairs. In this case, the AI programmer need only
specify a small core of primitives for the DSL, from which
task-speciﬁc policies can be derived during inference. The
challenge here is that ﬁnding a good policy in the inﬁnitely
large class of programs in the DSL is difﬁcult; simple meth-
ods like enumeration are much too slow to be useful.

We combine the complementary strengths of logical and
program-based policies to deﬁne the Logical Program Poli-
cies (LPP) class. Policies in LPP have a logical “top level”
and a programmatic ”bottom level.” The bottom level is
comprised of feature detector programs f : S ×A → {0, 1}.
These programs are expressions in a DSL and can include,
for example, loops and conditional statements. A feature de-
tector program takes a state s and an action a as input and re-
turns a binary output, which provides one bit of information
about whether a should be taken in s. The top level is com-
prised of a logical formula h over the outputs of the bottom
level. Without loss of generality, we can express the formula
in disjunctive normal form:

h(s, a) (cid:44) (f1,1(s, a) ∧ ... ∧ f1,n1(s, a)) ∨ ...
∨(fm,1(s, a) ∧ ... ∧ fm,nm (s, a))

(1)

where the f ’s are possibly negated. LPP thus includes all
policies that correspond to logical formulae over ﬁnite sub-
sets of feature detector programs expressed in the DSL.

Imitation Learning as Bayesian Inference
We now address the imitation learning problem of ﬁnding a
policy π that ﬁts the expert demonstrations D. Rather than
ﬁnding a single LPP policy, we will infer a full posterior
distribution over policies p(π | D). From a Bayesian per-
spective, maintaining the full posterior is principled; from a

practical perspective, the full posterior leads to modest per-
formance gains over a single MAP policy. Once we have
inferred p(π | D), we will ultimately take MAP actions ac-
cording to arg maxa∈A

Ep(π|D)[π(a | s)].

Probabilistic Model p(π, D)
We begin by specifying a probabilistic model over policies
and demonstrations p(π, D), which factors into a prior dis-
tribution p(π) over policies in LPP, and a likelihood p(D |
π) giving the probability that an expert generates demonstra-
tions D by following the policy π.

,

(cid:17)

i=1...M

(cid:16)(cid:86)

j=1...Ni

fi,j(s, a)bij (1 − fi,j(s, a))1−bij

We choose the prior distribution p(π) to encode a
preference for those policies which use fewer, simpler
that a policy π ∈
feature detector programs. Recall
LPP is parameterized by a logical formula h(s, a) =
(cid:87)
in
which each of the fi,j is a binary feature detector expressed
in a simple DSL and the bij are binary parameters that de-
termine whether a given feature detector is negated. We set
the prior probability of such a policy to depend only on
the number and sizes of the programmatic components fi,j:
namely, p(π) ∝ (cid:81)M
j=1 p(fi,j), the probability of gen-
i=1
erating each of the fi,j independently from a probabilistic
context-free grammar p(f ) (Manning and Sch¨utze 1999).1
The grammar we use in this work is shown in the appendix.
The likelihood of a dataset D given a policy π is p(D |
π) ∝ (cid:81)N
j=1 π(aij | sij). In the appendix, we also con-
i=1
sider the case where demonstrations are corrupted by noise.

(cid:81)Ni

(cid:81)Ti

Approximating the Posterior p(π | D)

Algorithm 1: LPP imitation learning
input: Demos D, ensemble size K, max iters L
Create anti-demos D = {(s, a(cid:48)) : (s, a) ∈ D, a(cid:48) (cid:54)= a};
Set labels y[(s, a)] = 1 if (s, a) ∈ D else 0;
Initialize approximate posterior q;
for i in 1, ..., L do

fi = generate next feature();
X = {(f1(s, a), ..., fi(s, a))T : (s, a) ∈ D ∪ D}
µi, wi = logical inference(X, y, p(f ), K);
update posterior(q, µi, wi);

end
return q;

We now have a prior p(π) and likelihood p(D | π),
and we wish to compute an approximate posterior q(π) ≈
p(π | D). We take q to be a weighted mixture of K poli-
cies µ1, . . . , µK (in our experiments, K = 25) and initialize
it so that each µi is equally weighted and equal to the uni-
form policy, µi(a | s) ∝ 1. Our core insight is a way to

1Note that without some maximum limit on (cid:80)M

i=1 Ni, this is
an improper prior, and for this technical reason, we introduce a
uniform prior on (cid:80)M
i=1 Ni, between 1 and a very high maximum
value α; the resulting factor of 1
α does not depend on π at all, and
can be folded into the proportionality constant.

exploit the structure of LPP to efﬁciently search the space
of policies and update the mixture q to better match the pos-
terior. In the appendix, we show that this scheme is formally
a variational inference algorithm that iteratively minimizes
the KL divergence from q to the true posterior.

Our algorithm is given a set of demonstrations D. The
state-action pairs (s, a) in D comprise positive examples —
inputs for which h(s, a) = 1. We start by computing a set
of “anti-demonstrations” D = {(s, a(cid:48)) | (s, a) ∈ D, a(cid:48)
(cid:54)=
a}, which serve as approximate negative examples. (D is
approximate because it may contain false negatives, but they
will generally constitute only a small fraction of the set.)

We now have a binary classiﬁcation problem with posi-
tive examples D and negative examples D. The main loop
of our algorithm considers progressively larger feature rep-
resentations of these examples. At iteration i, we use only
the simplest feature detectors f1, ..., fi, where “simplest”
here means “of highest probability under the probabilistic
grammar p(f ).” We can enumerate features in this order by
performing a best-ﬁrst search through the grammar.

Given a ﬁnite set of feature detectors f1, . . . , fi, we can
convert any state-action pair (s, a) into a length-i binary fea-
ture vector x ∈ {0, 1}i = (f1(s, a), . . . , fi(s, a))T . We
do this conversion on D and D to obtain a design matrix
Xi ∈ {0, 1}|D∪D|×i. The remaining problem of learning a
binary classiﬁer as a logical combination of binary features
is very well understood (Mitchell 1978; Valiant 1985; Quin-
lan 1986; Dietterich and Michalski 1986). In this work, we
use an off-the-shelf stochastic greedy decision-tree learner
(Pedregosa et al. 2011).
learned
a
a

can
h(s, a)
formula
fj,l(s, a)bjl (1 − fj,l(s, a))1−bjl

tree, we

eas-
=

decision

logical

Given

ily
(cid:87)

(cid:16)(cid:86)

read

(cid:17)
,

off

j=1...M

l=1...Nj

in which each of the fj,l is one of the i feature detectors
under consideration at iteration i. This induces a candi-
date policy µ∗(a|s) ∝ h(s, a). We can evaluate its prior
probability p(µ∗) and its likelihood p(D | µ∗), then decide
whether to include µ∗ in our mixture q, based on whether
its unnormalized posterior probability is greater than that
of the lowest-scoring existing mixture component. The
mixture is always weighted according to our model over π
and D, so that q(µj) = p(µj |D)
i=1 p(µi|D) . In practice, we run the
decision-tree learner several times (5 in experiments) with
different random seeds to generate several distinct candidate
policies at each iteration of the algorithm. We can stop the
process after a ﬁxed number of iterations, or when the prior
probabilities of the enumerated programs fi fall below a
threshold: any policy that uses a feature detector fi with
prior probability p(fi) < p(µj, D) for all µj in q’s support
has no chance of meriting inclusion in our mixture.

(cid:80)K

Once we have an approximation q to the posterior, we can

use it to derive a ﬁnal policy for use at test time:

π∗(s) = arg max

a∈A

Eq[π(a | s)] = arg max

a∈A

q(µ)µ(a|s).

(cid:88)

µ∈q

We could alternatively use the full distribution over actions
to guide exploration, e.g., in combination with reinforce-

Method

Type

Description

cell is value
shifted
scanning

V → C
Check whether the attended cell has a given value
O × C → C
Shift attention by an offset, then check a condition
O × C × C → C Repeatedly shift attention by the given offset, and

at action cell
at cell with value V × C → P

C → P

check which of two conditions is satisﬁed ﬁrst
Attend to the action cell and check a condition
Attend to a cell with the value and check condition

Table 1: Methods of the domain-speciﬁc language (DSL) used in this work. A program (P) in the DSL implements a predicate
on state-action pairs (i.e., P = S × A → {0, 1}), by attending to a certain cell, then running a condition (C). Conditions check
that some property holds of the current state relative to an implicit attention pointer. V ranges over possible grid cell values and
an “off-screen” token, and O over “offsets,” which are pairs (x, y) of integers specifying horizontal and vertical displacements.

Figure 2: Example of a policy in LPP for the “Nim” game. (A) h(s, a) is a logical combination of programs from a DSL. For
example, f12 returns True if the cell to the right of the action a has value (cid:3). The induced policy is π(a | s) ∝ h(s, a). (B)
Given state s, (C) there is one action selected by h. This policy encodes the “leveling” tactic, which wins the game.

ment learning (Hester et al. 2018). In this work, we focus
on exploitation and therefore require only the maximum a
posteriori actions, for use with a deterministic ﬁnal policy.

Experiments and Results
We now present experiments to evaluate the data efﬁciency,
computational complexity, and generalization of LPP ver-
sus several baselines. We also analyze the learned policies,
examine qualitative performance (see Figure 4 and the ap-
pendix), and conduct ablation studies to measure the con-
tributions of the components of LPP. All experiments were
performed on a single laptop running macOS Mojave with a
2.9 GHz Intel Core i9 processor and 32 GB of memory.

Tasks
We consider six diverse strategy games (Figure 3) that share
a common state space (S = (cid:83)
h,w∈N V hw; variable-sized
grids with discrete-valued cells) and action space A =
N × N; single “clicks” on any cell). For a grid of dimension
h × w, we only consider clicks on the grid, i.e., {1, ..., h} ×
{1, ..., w}. Grid sizes vary within tasks. These tasks fea-
ture high variability between different task instances; learn-
ing a robust policy requires substantial generalization. The
tasks are also very challenging due to the unbounded ac-
tion space, the absence of shaping or auxiliary rewards, and
the arbitrarily long horizons that may be required to solve
a task instance. Each task has a maximum episode length
of 60 and counts as a failure if the episode terminates with-

out a success. There are 11 training and 9 test instances per
task. Instances of Nim, Checkmate Tactic, and Reach for the
Star are procedurally generated; instances of Stop the Fall,
Chase, and Fence In are manually generated, as the varia-
tion between instances is not trivially parameterizable. We
provide descriptions of the tasks in the appendix.

Domain-Speciﬁc Language
Recall that each feature detector program takes a state and
action as input and returns a Boolean value. In our tasks,
states are full grid layouts and actions are single grid cells
(“clicks”). The speciﬁc DSL of feature detectors that we use
in this work (Table 1) is inspired by early work in visual
routines (Ullman 1987; Hay et al. 2018). Each program im-
plements a procedure for attending to some grid cell and
checking that a local condition holds nearby. Given input
(s, a), a program begins by initializing an implicit atten-
tion pointer either to the grid cell in s associated with ac-
tion a (at action cell), or to an arbitrary grid cell con-
taining a certain value (at cell with value). Next, the
program will check a condition at or near the attended cell.
The simplest condition is cell is value, which checks
whether the attended cell has a certain value. More com-
plex conditions, which look not just at but near the attended
cell, can be built up using the shifted and scanning
methods. The shifted method builds a condition that ﬁrst
shifts the attention pointer by some offset, then applies an-
other condition. The scanning method starts at the cur-
rently attended cell and “scans” along some direction, re-

Figure 3: The strategy games studied in this work. See the appendix for descriptions and additional illustrations.

Figure 4: One-shot imitation learning in “Fence In.” From a single demonstration (top), we learn an enclosing strategy that
generalizes to many new task instances (bottom).

peatedly shifting the attention pointer by a speciﬁed off-
set and checking whether either of two speciﬁed conditions
hold. If, while scanning, the ﬁrst condition becomes satis-
ﬁed before the second, the scanning condition returns 1.
Otherwise, it returns 0. Thus the overall DSL contains ﬁve
methods, which are summarized in Table 1. See Figure 2 for
a complete example of a policy in LPP using this DSL.

Baselines
Local Linear Network (LLN): A single 3×3 convolutional
ﬁlter is trained to classify whether each cell in s should
be “clicked,” based only on the 8 surrounding cells. FCN:
A deep fully convolutional network (Long, Shelhamer, and
Darrell 2015) is trained with the same inputs and outputs as
“Local Linear.” The network has 8 convolutional layers with
kernel size 3, stride 1, padding 1, 4 channels (8 in the in-
put layer), and ReLU nonlinearities. This architecture was
chosen to reﬂect the receptive ﬁeld sizes we expect are nec-
essary for the tasks. CNN: A standard convolutional neural
network is trained with full grid inputs and discrete action
outputs. Grids are padded so that all have the same maximal
height and width. The architecture is: 64-channel convolu-
tion; max pooling; 64-channel fully-connected layer; |A|-
channel fully-connected layer. All kernels have size 3 and
all strides and paddings are 1. Vanilla Program Induction
(VPI): Full policies are enumerated from a DSL grammar
that includes logical disjunctions, conjunctions, and nega-
tions over the feature detector DSL. The number of disjunc-
tions and conjunctions each follow a geometric distribution

(p = 0.5). (Several other values of p were also tried without
improvement.) Policies are then enumerated and mixed as in
LPP learning; this baseline is thus identical to LPP learning
but with the greedy Boolean learning removed.

Effect of Number of Demonstrations
We ﬁrst evaluate the test-time performance of LPP and base-
lines as the number of training demonstrations varies from 1
to 10. For each number of demonstrations, we run leave-one-
out cross validation: 10 trials, each featuring a distinct set
of demonstrations drawn from the overall pool of 11 train-
ing demonstrations. LPP learning is run for 10,000 itera-
tions for each task. The mean and maximum trial perfor-
mance offer complementary insight: the mean reﬂects the
expected performance if demonstrations were selected at
random; the maximum reﬂects the expected performance if
the most useful demonstrations were selected, perhaps by an
expert teacher. Results are shown in Figure 5. On the whole,
LPP markedly outperforms all baselines, especially on the
more difﬁcult tasks. The baselines are limited for different
reasons. The highly parameterized CNN baseline is able to
perfectly ﬁt the training data and win all training games (not
shown), but given the limited training data and high variation
from training to task, it severely overﬁts and fails to gener-
alize. The FCN baseline is also able to ﬁt the training data
almost perfectly. Its additional structure permits better gen-
eralization in Nim, Checkmate Tactic, Reach for the Star,
and Fence In than the CNN, but overall its performance is
still far behind LPP. In contrast, the LLN baseline is unable

Figure 5: Performance on held-out test task instances as a function of the number of training demonstrations for LPP (ours) and
four baselines. Maximums and means are over 10 training sets.

Figure 6: Performance on held-out test task instances as
a function of the number of programs enumerated for the
Vanilla Program Induction (VPI) baseline and LPP (ours).

to ﬁt the training data; with the exception of Nim, its training
performance is close to zero. Similarly, the training perfor-
mance of the VPI baseline is near or at zero for all tasks
beyond Nim. In Nim, there is evidently a low complexity
program that works roughly half the time, but an optimal
policy is more difﬁcult to ﬁnd.

Effect of Number of Programs Searched

We now examine test-time performance of LPP and VPI as
a function of the number of programs searched. For this ex-
periment, we give both methods all 11 training demonstra-
tions for each task. Results are shown in Figure 6. LPP re-
quires fewer than 100 programs to learn a winning policy for
Nim, fewer than 1,000 for Checkmate Tactic and Chase, and
fewer than 10,000 for Stop the Fall, Reach for the Star, and
Fence In. In contrast, VPI is unable to achieve nonzero per-

Figure 7: Performance on held-out test task instances for
LPP and four ablation models.

formance for any task other than Nim, for which it achieves
roughly 45% performance after 100 programs enumerated.
The lackluster performance of VPI is unsurprising given the
combinatorial explosion of programs. For example, the op-
timal policy for Nim shown in Figure 2 involves six con-
stituent programs, each with a parse tree depth of three or
four. There are 108 unique constituent programs with parse
tree depth three and therefore more than 13,506,156,000 full
policies with six or fewer constituent programs. VPI would
have to search roughly so many programs before arriving at a
winning policy for Nim, which is by far the simplest task. In
contrast, a winning LPP policy is learnable after fewer than
100 enumerations. In practical terms, LPP learning for Nim
takes on the order of 1 second on a laptop without highly
optimized code; after running VPI for six hours in the same
setup, a winning policy is still not found.

Ablation Studies

We now perform ablation studies to explore which aspects
of the LPP class and learning algorithm contribute to the

strong performance. We consider four ablated models. The
“Features + NN” model learns a neural network state-action
binary classiﬁer on the ﬁrst 10,000 feature detectors enu-
merated from the DSL. This model addresses the possibil-
ity that the features alone are powerful enough to solve the
task when combined with a simple classiﬁer. The NN is a
multilayer perceptron with two layers of dimension 100 and
ReLU activations. The “Features + NN + L1 Regularization”
model is identical to the previous baseline except that an L1
regularization term is added to the loss to encourage sparsity.
This model addresses the possibility that the features alone
sufﬁce when we incorporate an Occam’s razor bias similar to
the one that exists in LPP learning. The “No Prior” model is
identical to LPP learning, except that the grammatical prior
is replaced with a uniform prior. Similarly, the “Sparsity
Prior” model uses a prior that penalizes the number of top-
level programs involved in the policy, without regard for the
relative priors of the individual programs. Results are pre-
sented in Figure 7. They conﬁrm that the each component
— the feature detectors, the sparsity regularization, and the
grammatical prior — adds value to the overall framework.

Related Work
Sample efﬁciency and generalization are two of the main
concerns in imitation learning (Schaal 1997; Abbeel and Ng
2004). To cope with limited data, demonstrations can be
used in combination with additional RL (Hester et al. 2018;
Nair et al. 2018). Alternatively, a mapping from demonstra-
tions to policies can be learned from a background set of
tasks (Duan et al. 2017; Finn et al. 2017). A third option is
to introduce a prior over a structured policy class (Andre and
Russell 2002; Doshi-Velez et al. 2010; Wingate et al. 2011),
e.g., hierarchical policies (Niekum 2013). Our work ﬁts into
the third tradition; our contribution is a new policy class with
a structured prior that enables efﬁcient learning.

LPP policies are logical at the “top level” and program-
matic at the “bottom level.” Logical representations for RL
problems have been considered in many previous works,
particularly in relational RL (Dˇzeroski, De Raedt, and Bloc-
keel 1998; Natarajan et al. 2011). Also notable is work by
Shah et al. (2018), who learn linear temporal logic speciﬁ-
cations from demonstration using a ﬁnite grammatical prior.
While some LPP programs may be seen as ﬁxed-arity log-
ical relations in the classical sense, others are importantly
more general and powerful, involving loops and a potentially
arbitrary number of atoms. For example, one program suf-
ﬁces to check whether a Queen’s diagonal path is clear in
Chess; no relation over a ﬁxed number of squares can cap-
ture the same feature. Furthermore, relational RL assumes
that relations are ﬁxed, ﬁnite, and given, typically hand-
designed by the programmer. In LPP, the programmer in-
stead supplies a DSL describing inﬁnitely many features.

LPP learning is a particular type of program synthesis,
which more broadly refers to a search over programs, in-
cluding but not limited to the case where we have a gram-
mar over programs, the programs are mappings, and input-
output examples are available. When a grammar is given, the
problem is sometimes called syntax-guided synthesis (Alur
et al. 2013). Most relevant is work by Alur, Radhakrishna,

and Udupa (2017), who propose a “divide and conquer” ap-
proach that uses greedy decision tree learning in combina-
tion with enumeration from a grammar of “conditions”, sim-
ilar to our “No Prior” baseline.

Recent work has also examined neural program synthe-
sis (NPS) wherein a large dataset of (input, output, pro-
gram) examples is used to train a guidance function for pro-
gram enumeration (Parisotto et al. 2016; Devlin et al. 2017;
Bunel et al. 2018; Huang et al. 2019). In practice, NPS meth-
ods are still limited to programs involving ∼10 primitives.
The neural guidance can delay, but not completely avoid,
the combinatorial explosion of search in program space.
LPP learning is not a generic program induction method,
but rather, an algorithm that exploits the logical structure of
LPP programs to dramatically speed up search, sometimes
ﬁnding programs with ∼250 primitives (Appendix Table 2).

The interpretation of policy learning as an instance of
program synthesis is explored in prior work (Wingate et
al. 2011; Sun et al. 2018; Verma et al. 2018). In particu-
lar, L´azaro-Gredilla et al. (2019) learn object manipulation
concepts from before/after image pairs that can be trans-
ferred between 2D simulation and a real robot. In this work,
we focus on the problem of efﬁcient inference and compare
against vanilla program induction in experiments.

Discussion and Conclusion

In an effort to efﬁciently learn policies from very few
demonstrations that generalize substantially, we have intro-
duced the LPP policy class and an approximate Bayesian in-
ference algorithm for imitation learning. We have seen that
the LPP policy class includes winning policies for a diverse
set of strategy games, and moreover, that those policies can
be efﬁciently learned from ﬁve or fewer demonstrations. In
ongoing work we are studying how to scale our approach
to a wider range of tasks, starting with more sophisticated
DSLs that include counting or simple data structures. How-
ever, even our current DSL is surprisingly general. For in-
stance, in preliminary experiments (see appendix), we ﬁnd
that our current algorithm can learn a generalizing policy
for Atari Breakout from just one demonstration.

Beyond policy learning, this work contributes to the long
and ongoing discussion about the role of prior knowledge in
AI. In the common historical narrative, early attempts to in-
corporate prior knowledge via feature engineering failed to
scale, leading to the modern shift towards domain-agnostic
deep learning methods (Sutton 2019). Now there is renewed
interest in incorporating inductive bias into contemporary
methods, especially for problems where data is scarce. We
argue that encoding prior knowledge via a probabilistic
grammar over feature detectors and learning to combine
these feature detectors with Boolean logic is a promising
path forward. More generally, we submit that “meta-feature
engineering” of the sort exempliﬁed here strikes an appro-
priate balance between the strong inductive bias of classical
AI and the ﬂexibility and scalability of modern methods.

Acknowledgements

We gratefully acknowledge support
from NSF grants
1523767 and 1723381; from ONR grant N00014-13-1-
0333; from AFOSR grant FA9550-17-1-0165; from ONR
grant N00014-18-1-2847; from Honda Research; and from
the Center for Brains, Minds and Machines (CBMM),
funded by NSF STC award CCF-1231216. KA acknowl-
edges support from NSERC. Any opinions, ﬁndings, and
conclusions or recommendations expressed in this material
are those of the authors and do not necessarily reﬂect the
views of our sponsors.

References
[Abbeel and Ng 2004] Abbeel, P., and Ng, A. Y. 2004. Ap-
prenticeship learning via inverse reinforcement learning. In-
ternational Conference on Machine Learning.
[Alur et al. 2013] Alur, R.; Bodik, R.; Juniwal, G.; Martin,
M. M.; Raghothaman, M.; Seshia, S. A.; Singh, R.; Solar-
Lezama, A.; Torlak, E.; and Udupa, A. 2013. Syntax-guided
synthesis. In Formal Methods in Computer-Aided Design.
[Alur, Radhakrishna, and Udupa 2017] Alur, R.; Radhakr-
ishna, A.; and Udupa, A. 2017. Scaling enumerative pro-
In International
gram synthesis via divide and conquer.
Conference on Tools and Algorithms for the Construction
and Analysis of Systems, 319–336. Springer.
[Andre and Russell 2002] Andre, D., and Russell, S. J. 2002.
State abstraction for programmable reinforcement learning
agents. AAAI Conference on Artiﬁcial Intelligence.
[Bunel et al. 2018] Bunel, R.; Hausknecht, M.; Devlin, J.;
Singh, R.; and Kohli, P. 2018. Leveraging grammar and
reinforcement learning for neural program synthesis. Inter-
national Conference on Learning Representations.
[Devlin et al. 2017] Devlin, J.; Uesato, J.; Bhupatiraju, S.;
Singh, R.; Mohamed, A.-r.; and Kohli, P. 2017. Robust-
ﬁll: Neural program learning under noisy i/o. International
Conference on Machine Learning.
and
[Dietterich and Michalski 1986] Dietterich, T. G.,
Michalski, R. S. 1986. Learning to predict sequences.
Machine learning: An artiﬁcial intelligence approach.
[Doshi-Velez et al. 2010] Doshi-Velez, F.; Wingate, D.; Roy,
N.; and Tenenbaum, J. B. 2010. Nonparametric Bayesian
policy priors for reinforcement learning. Advances in Neural
Information Processing Systems.
[Duan et al. 2017] Duan, Y.; Andrychowicz, M.; Stadie, B.;
Ho, J.; Schneider, J.; Sutskever, I.; Abbeel, P.; and Zaremba,
W. 2017. One-shot imitation learning. Advances in Neural
Information Processing Systems.
[Dˇzeroski, De Raedt, and Blockeel 1998] Dˇzeroski,
S.;
De Raedt, L.; and Blockeel, H. 1998. Relational reinforce-
In International Conference on Inductive
ment learning.
Logic Programming, 11–22. Springer.
[Finn et al. 2017] Finn, C.; Yu, T.; Zhang, T.; Abbeel, P.; and
Levine, S. 2017. One-shot visual imitation learning via
meta-learning. Conference on Robot Learning.
[Hay et al. 2018] Hay, N.; Stark, M.; Schlegel, A.; Wen-
delken, C.; Park, D.; Purdy, E.; Silver, T.; Phoenix, D. S.;

and George, D. 2018. Behavior is everything–towards rep-
resenting concepts with sensorimotor contingencies. AAAI
Conference on Artiﬁcial Intelligence.
[Hester et al. 2018] Hester, T.; Vecerik, M.; Pietquin, O.;
Lanctot, M.; Schaul, T.; Piot, B.; Horgan, D.; Quan, J.;
Sendonaris, A.; Osband, I.; et al. 2018. Deep Q-learning
from demonstrations. AAAI Conference on Artiﬁcial Intelli-
gence.
[Huang et al. 2019] Huang, D.-A.; Nair, S.; Xu, D.; Zhu, Y.;
Garg, A.; Fei-Fei, L.; Savarese, S.; and Niebles, J. C. 2019.
Neural task graphs: Generalizing to unseen tasks from a sin-
In Computer Vision and Pattern
gle video demonstration.
Recognition.
[Johnson et al. 2016] Johnson, M.; Hofmann, K.; Hutton, T.;
and Bignell, D. 2016. The malmo platform for artiﬁcial
intelligence experimentation. In IJCAI, 4246–4247.
[L´azaro-Gredilla et al. 2019] L´azaro-Gredilla, M.; Lin, D.;
Guntupalli, J. S.; and George, D. 2019. Beyond imita-
tion: Zero-shot task transfer on robots by learning concepts
as cognitive programs. Science Robotics 4(26).
[Long, Shelhamer, and Darrell 2015] Long, J.; Shelhamer,
E.; and Darrell, T. 2015. Fully convolutional networks for
semantic segmentation. IEEE Conference on Computer Vi-
sion and Pattern Recognition.
[Manning and Sch¨utze 1999] Manning, C. D., and Sch¨utze,
H. 1999. Foundations of statistical natural language pro-
cessing. MIT press.
[Mitchell 1978] Mitchell, T. M. 1978. Version spaces: an ap-
proach to concept learning. Technical report, Stanford Uni-
versity.
[Nair et al. 2018] Nair, A.; McGrew, B.; Andrychowicz, M.;
Zaremba, W.; and Abbeel, P. 2018. Overcoming explo-
In-
ration in reinforcement learning with demonstrations.
ternational Conference on Robotics and Automation.
[Natarajan et al. 2011] Natarajan, S.; Joshi, S.; Tadepalli, P.;
Kersting, K.; and Shavlik, J. 2011. Imitation learning in rela-
tional domains: A functional-gradient boosting approach. In
Twenty-Second International Joint Conference on Artiﬁcial
Intelligence.
[Niekum 2013] Niekum, S. D. 2013. Semantically grounded
learning from unstructured demonstrations. Ph.D. Disserta-
tion, University of Massachusetts, Amherst.
[Parisotto et al. 2016] Parisotto, E.; Mohamed, A.-r.; Singh,
R.; Li, L.; Zhou, D.; and Kohli, P. 2016. Neuro-symbolic
program synthesis. arXiv preprint arXiv:1611.01855.
[Pedregosa et al. 2011] Pedregosa, F.; Varoquaux, G.; Gram-
fort, A.; Michel, V.; Thirion, B.; Grisel, O.; Blondel, M.;
Prettenhofer, P.; Weiss, R.; Dubourg, V.; Vanderplas, J.; Pas-
sos, A.; Cournapeau, D.; Brucher, M.; Perrot, M.; and Duch-
esnay, E. 2011. Scikit-learn: Machine learning in Python.
Journal of Machine Learning Research 12:2825–2830.
[Quinlan 1986] Quinlan, J. R. 1986. Induction of decision
trees. Machine learning 1(1):81–106.
[Schaal 1997] Schaal, S. 1997. Learning from demonstra-
tion. Advances in Neural Information Processing Systems.

[Shah et al. 2018] Shah, A.; Kamath, P.; Shah, J. A.; and Li,
S. 2018. Bayesian inference of temporal task speciﬁcations
In Advances in Neural Information
from demonstrations.
Processing Systems, 3804–3813.
[Sun et al. 2018] Sun, S.-H.; Noh, H.; Somasundaram, S.;
and Lim, J. 2018. Neural program synthesis from diverse
demonstration videos. In International Conference on Ma-
chine Learning.
[Sutton 2019] Sutton, R. 2019. The bitter lesson.
[Ullman 1987] Ullman, S. 1987. Visual routines. Readings
in Computer Vision 298–328.
[Valiant 1985] Valiant, L. G. 1985. Learning disjunction of
International Joint Conference on Artiﬁcial
conjunctions.
Intelligence.
[Verma et al. 2018] Verma, A.; Murali, V.; Singh, R.; Kohli,
P.; and Chaudhuri, S. 2018. Programmatically interpretable
International Conference on Ma-
reinforcement learning.
chine Learning.
[Wingate et al. 2011] Wingate, D.; Goodman, N. D.; Roy,
D. M.; Kaelbling, L. P.; and Tenenbaum, J. B.
2011.
International
Bayesian policy search with policy priors.
Joint Conference on Artiﬁcial Intelligence.
[Wingate et al. 2013] Wingate, D.; Diuk, C.; O’Donnell, T.;
Tenenbaum, J.; and Gershman, S. 2013. Compositional pol-
icy priors. Technical report, Massachusetts Institute of Tech-
nology.

Probabilistic Grammar for DSL
Variational Interpretation of LPP Learning
The algorithm for LPP learning presented in the main text
can be understood as performing variational inference, it-
eratively minimizing the KL divergence from q to the true
posterior. We make two observations to this effect. First, ﬁx-
ing the K component policies in the support of the mixture
q, the component weights that minimize the KL divergence
DKL(q(π) || p(π | D)) are q(µj) =
i=1 p(µi|D) , that
is, each policy should be weighted according to its relative
posterior probability. Second, if some policy µ∗ not in the
support of q has higher posterior probability than some ex-
isting mixture component µi, a lower KL is always achiev-
able by replacing µi with µ∗ and reweighting the mixture
accordingly. Our algorithm maintains a list µ1, . . . , µK of
the K best policies seen so far, and iteratively searches an
increasingly large space for new policies µ∗ of high pos-
terior probability. Whenever a µ∗ is found that has higher
(unnormalized) posterior probability than the lowest-scoring
policy µi in our “best-K” list, replace µi with µ∗. At each
iteration, our variational approximation is simply q(µj) =

p(µj |D)

(cid:80)K

p(µj |D)

(cid:80)K

i=1 p(µi|D) for j ∈ {1, . . . , K}.

Environment Details

Nim
Task Description There are two columns (piles) of match-
sticks and empty cells. Clicking on a matchstick cell changes

Production rule

Probability

Programs
P → at cell with value(V, C)
P → at action cell(C)
Conditions
C → shifted(O, B)
C → B
Base conditions
B → cell is value(V)
B → scanning(O, C, C)
Offsets
O → (N, 0)
O → (0, N)
O → (N, N)
Numbers
N → N
N → −N
Natural numbers (for i = 1, 2, . . . )
N → i
Values (for each value v in this game)
V → v

0.5
0.5

0.5
0.5

0.5
0.5

0.25
0.25
0.5

0.5
0.5

(0.99)(0.01)i−1

1/|V|

Table 2: The prior p(f ) over programs, speciﬁed as a proba-
bilistic context-free grammar (PCFG).

all cells above and including the clicked cell to empty; click-
ing on a empty cell has no effect. After each matchstick cell
click, a second player takes a turn, selecting another match-
stick cell. The second player is modeled as part of the envi-
ronment transition and plays optimally. When there are mul-
tiple optimal moves, one is selected randomly. The objective
is to remove the last matchstick cell.

Task Instance Distribution Instances are generated pro-
cedurally. The height of the grid is selected randomly be-
tween 2 and 20. Th e initial number of matchsticks in each
column is selected randomly between 1 and the height with
the constraint that the two columns cannot be equal. All
other grid cells are empty.

Expert Policy Description The winning tactic is to
“level” the columns by selecting the matchstick cell next to
a empty cell and diagonally up from another matchstick cell.
Winning the game requires perfect play.

Checkmate Tactic
Task Description This task is inspired by a common
checkmating pattern in Chess. Note that only three pieces
are involved in this game (two kings and a white queen) and
that the board size may be H × W for any H, W , rather

than the standard 8 × 8. Initial states in this game feature
the black king somewhere on the boundary of the board, the
white king two cells adjacent in the direction away from the
boundary, and the white queen attacking the cell in between
the two kings. Clicking on a white piece (queen or king) se-
lects that piece for movement on the next action. Note that a
selected piece is a distinct value from a non-selected piece.
Subsequently clicking on an empty cell moves the selected
piece to that cell if that move is legal. All other actions have
no effect. If the action results in a checkmate, the game is
over and won; otherwise, the black king makes a random
legal move.

Task Instance Distribution Instances are generated pro-
cedurally. The height and width are randomly selected be-
tween 5 and 20. A column for the two kings is randomly
selected among those not adjacent to the left or right sides.
A position for the queen is randomly selected among all
those spaces for which the queen is threatening checkmate
between the kings. The board is randomly rotated among the
four possible orientations.

Expert Policy Description The winning tactic selects the
white queen and moves it to the cell between the kings.

Chase

Task Description This task features a stick ﬁgure agent,
a rabbit adversary, walls, and four arrow keys. At each time
step, the adversary randomly chooses a move (up, down, left,
or right) that increases its distance from the agent. Clicking
an arrow key moves the agent in the corresponding direction.
Clicking a gray wall has no effect other than advancing time.
Clicking an empty cell creates a new (blue) wall. The agent
and adversary cannot move through gray or blue walls. The
objective is to “catch” the adversary, that is, move the agent
into the same cell. It is not possible to catch the adversary
without creating a new wall; the adversary will always be
able to move away before capture.

Task Instance Distribution There is not a trivial param-
eterization to procedurally generate these task instances, so
they are manually generated.

Expert Policy Description The winning tactic advances
time until the adversary reaches a corner, then builds a new
wall next to the adversary so that it is trapped on three sides,
then moves the agent to the adversary.

Stop the Fall

Task Description This task involves a parachuter, gray
static blocks, red “ﬁre”, and a green button that turns on
gravity and causes the parachuter and blocks to fall. Click-
ing an empty cell creates a blue static block. The game is
won when gravity is turned on and the parachuter falls to
rest without touching (being immediately adjacent to) ﬁre.

Task Instance Distribution There is not a trivial param-
eterization to procedurally generate these task instances, so
they are manually generated.

Expert Policy Description The winning tactic requires
building a stack of blue blocks below the parachuter that is
high enough to prevent contact with ﬁre, and then clicking
the green button.

Reach for the Star
Task Description In this task, a robot must move to a cell
with a yellow star. Left and right arrow keys cause the robot
to move. Clicking on an empty cell creates a dynamic brown
block. Gravity is always on, so brown objects fall until they
are supported by another brown block. If the robot is adja-
cent to a brown block and the cell above the brown block is
empty, the robot will move on top of the brown block when
the corresponding arrow key is clicked. (In other words, the
robot can only climb one block, not two or more.)

Task Instance Distribution Instances are generated pro-
cedurally. A height for the star is randomly selected between
2 and 11 above the initial robot position. A column for the
star is also randomly selected so that it is between 0 and 5
spaces from the right border. Between 0 and 5 padding rows
are added above the star. The robot position is selected be-
tween 0 and 5 spaces away from where the start of the min-
imal stairs would be. Between 0 and 5 padding columns are
added to the left of the agent. The grid is ﬂipped along the
vertical axis with probability 0.5.

Expert Policy Description The winning tactic requires
building stairs between the star and robot and then moving
the robot up them.

Fence In
Task Description This task uses the Malmo interface to
Minecraft (Johnson et al. 2016). As in the other tasks, ob-
servations are 2D grids with discrete values and actions are
“clicks” on the grid. This task features fences, one sheep,
and open space in the grid. Clicking on a grid cell has the
effect of building a fence at that location if it is currently
open. The objective of the task is to build fences in such a
way that the sheep is completely enclosed by fences. (En-
closure is calculated by ﬁnding the connected component
that contains the sheep and checking whether it reaches the
boundary of the grid.)

Task Instance Distribution There is not a trivial param-
eterization to procedurally generate these task instances, so
they are manually generated.

Expert Policy Description The expert policy builds
fences from left to right one cell below the sheep, starting
at the nearest fence on the left and ﬁnishing at the nearest
fence on the right.

Additional Results

Data Efﬁciency of Baselines
We saw in our main experiments that generalizable convolu-
tional and fully convolutional policies cannot be learned in
our regime of very low data and very high variation between
task instances. In an effort to better understand the gap in
data efﬁciency between the deep policies (CNN and FCN)

Figure 8: Performance on held-out test task instances as a function of the number of training demonstrations for CNN and FCN
baselines.

and LPP, we again measure the test performance of the base-
lines as a function of the number of demonstrations, but with
many more demonstrations than we previously considered.
In the main paper, we report results for up to 10 demonstra-
tions; here we report results for up to 5,000. We focus on
Nim and Checkmate Tactic for this experiment. Recall that
at most 5 demonstrations were necessary to learn a winning
(test performance 1.0) policy in LPP. In Figure 8, we see that
FCNs require 100 demonstrations in Nim and 500 demon-
strations in Checkmate Tactic to achieve test performance
1.0. We also ﬁnd that CNNs require 1,000 demonstrations in
Nim and 5,000 demonstrations in Checkmate Tactic. Thus
LPP achieves 20 – 1,000x data efﬁciency gains over these
baselines.

Learned Policy Analysis

Here we analyze the learned LPP policies in an effort to
understand their representational complexity and qualita-
tive behavior. We enumerate 10,000 programs and train
with 11 task instances for each task. Table 3 reports three
statistics for the MAP policies learned for each task: the
number of top-level programs (at action cell and
at cell with value calls), the total number of method
calls (shifted, scanning, and cell is value as
well); and the maximum parse tree depth among all pro-
grams in the policy. The latter term is the primary driver
of learning complexity in practice. The number of top-level
programs ranges from 11 to 97; the number of method calls
ranges from 32 to 244; and the maximum parse tree depth is
3 or 4 in all tasks. These numbers suggest that LPP learning
is capable of discovering policies of considerable complex-
ity, far more than what would be feasible with full policy
enumeration. We also note that the learned policies are very
sparse, given that the maximum number of available top-
level programs is 10,000. Visualizing the policies offers fur-
ther conﬁrmation of their strong performance (Figures 5–9).

An example of a clause in the learned MAP policy for
Stop the Fall is shown in Figure 9. This clause is used to
select the ﬁrst action: the cell below the parachuter and im-
mediately above the ﬂoor is clicked. Other clauses govern
the policy following this ﬁrst action, either continuing to
build blocks above the ﬁrst one, or clicking the green but-
ton to turn on gravity. From the example clause, we see
that the learned policy may include some redundant pro-
grams, which unnecessarily decrease the prior without in-
creasing the likelihood. Such redundancy is likely due to
the approximate nature of our Boolean learning algorithm
(greedy decision-tree learning). Posthoc pruning of the poli-
cies or alternative Boolean learning methods could address
this issue. The example clause also reveals that the learned
policy may take unnecessary (albeit harmless) actions in the
case where there are no “ﬁre” objects to avoid. In examining
the behavior of the learned policies for Stop the Fall and the
other games, we do not ﬁnd any unnecessary actions taken,
but this does not preclude the possibility in general. Despite
these two qualiﬁcations, the clause and others like it are a
positive testament to the interpretability and intuitiveness of
the learned policies.

Noisy Demonstrations
Our main experiments used demonstrations that were sam-
pled following the expert policy exactly. In realistic set-
tings, it is often the case that demonstrations are corrupted
by noise, e.g., due to human error. We can accommodate
noise in learning by modifying the likelihood p(D | π) to
include a noise model. A simple noise model that we con-
sider here assumes that the expert policy is followed with
probability (1 − (cid:15)), and with probability (cid:15), a random ac-
tion is taken. (This is akin to the expert following an (cid:15)-
greedy policy.) The likelihood then becomes p(D | π) ∝
(cid:81)N

(cid:81)Ti

j=1(1 − (cid:15))π(aij | sij) + (cid:15)

i=1
In this set of experiments, we investigate how the noise

|A| .

Figure 9: One of the clauses of the learned MAP policy for “Stop the Fall”. The clause suggests clicking a cell if scanning up
we ﬁnd a parachuter before a drawn or static block; if the cell is empty; if the cell above is not drawn; if the cell is not a green
button; and if a static block is immediately below. Note that this clause is slightly redundant and may trigger an unnecessary
action for a task instance where there are no “ﬁre” cells.

Task

Nim
Checkmate Tactic
Chase
Stop the Fall
Reach for the Star
Fence In

Number of Programs Method Calls Max Depth
32
11
60
23
244
97
50
17
151
34
40
9

4
3
3
4
4
3

Table 3: Analysis of the MAP policies learned in LPP with 10,000 programs enumerated and all 11 training demonstrations.
The number of top-level programs, the number of constituent method calls, and the maximum parse depth of a program in the
policy is reported for each of the ﬁve tasks.

model affects learning and generalization if demonstrations
are (1) perfect, (2) corrupted by independent random noise,
and (3) corrupted by correlated random noise. There will be
mismatch between the noise model and noise source except
for the case where the independent random noise probability
of the demonstrations is equal to (cid:15) in the noise model.

Demonstrations We use the Nim task for all experiments.
The perfect demonstrations (1) are identical to the main ex-
periments. Independent random noise (2) is introduced by
taking a random action with probability 0.2. Correlated ran-
dom noise (3) is introduced by clicking on a random token
cell with probability 0.2. Recall that if a single incorrect to-
ken is clicked in Nim, the game is inevitably lost.

as

the

above

and
described

Results We modify

Methods
like-
∈
(cid:15)
lihood
{0.0, 1e−4, 1e−3, 1e−2, 1e−1, 1.0}. All
hyperparame-
ters are otherwise unchanged from the main experiments.
For each value of (cid:15), for each of the three sets of demon-
strations, we perform LPP learning with demonstrations
ranging from 2 to 16.

consider

and

Results are shown in Figure 10. Across all demonstration
types, we ﬁrst note that too high of an (cid:15) results in a severe
drop in performance. By inspecting the learned policies, we
see that a high (cid:15) results in overly simpliﬁed policies that are
favored by the prior; all actions not consistent with this sim-
ple policy are treated as noise. An (cid:15) of 0.0 also results in a
severe drop in performance for the demos with noise, but for

a different reason: when no noise is assumed by the model,
no policy consistent with the noisy demos is found within
the allotted enumeration budget. Interestingly, a very small
but nonzero (cid:15) seems to be consistently effective, even though
the actual probability of a random action in the noisy demos
is 0.2. This result suggests that the primary beneﬁt of modi-
fying the likelihood is to avoid discarding policy candidates
that nearly, but not perfectly, match the demos.

Atari Breakout
As our principal focus in this work is few-shot generaliza-
tion, the experiments described thus far have been carried
out in a suite of grid game tasks that were designed to ex-
hibit substantial structured variation. Popular reinforcement
learning benchmarks such as Atari 2600 games involve rela-
tively little variation between task instances and were there-
fore not selected for our main experiments. Nonetheless, the
question of whether LPP policy learning and the particular
DSL used for our grid games can be extended to Atari games
and other familiar benchmarks is interesting, as it sheds light
on the generality of the approach. In this section, we begin
to answer this question with some preliminary experiments
and results on Atari Breakout.

Task In Breakout (Figure 11), an agent must move a pad-
dle left or right so that it hits a ball into bricks above. When
a brick is hit, it disappears, and a reward of 1 is given. If the
ball falls below the paddle, the episode is over. The ball’s
initial position and velocity vary between task instances.

Figure 10: Effect of noisy demonstrations on learning performance and generalization in Nim. See text for details.

information, resulting in size 210 × 160 × 3 × 2 tensors3. We
convert these tensors into the familiar 2D grid representation
by ﬂattening the latter two dimensions so that each 3×2 ten-
sor is converted to a single ﬂoat value. In the data, there are
15 unique ﬂattened values across all pixels in all observa-
tions. The ﬁnal observation space is thus isomorphic to a 2D
grid with 15 discrete values, that is, {0, 1, ..., 14}210×160.

Expert Policy We implement a simple reactive policy
from which we can draw expert demonstrations. Given
an observation, we ﬁrst determine the velocity of the ball
based on the two consecutive frames. We further determine
whether the paddle is to the left or right of the ball. If the ball
is moving towards the left and the paddle is not on the left,
then we take the “left” action, and the same for the opposite
direction. We take the noop action otherwise. This policy
is not necessarily optimal, but it successfully keeps the ball
in play and continues to reap rewards for several thousand
frames.

Methods and Results We use the same DSL described in
the main paper for this experiment, with one change: the
at action cell method of the DSL is designed under
the assumption that actions are clicks on a grid cell, but
the action space in Atari Breakout is simply four discrete
values (“left”, “right”, “ﬁre”, “noop”); thus we remove this
method from the DSL and replace it with four simple iden-
tity checks (action is left, action is right,
action is fire, action is noop). The probabilis-
tic grammatical prior is modiﬁed accordingly, giving uni-
form probability to these four action methods and to the
at cell with value method in the ﬁrst substitution.

We sample a single demonstration for 500 frames using
the expert policy described above. This demonstration shows
3 bricks breaking for a total reward of 3. We then run LPP
learning with 120,000 programs enumerated. (Fewer pro-
grams were found to be insufﬁcient.) To ease the compu-
tational burden, we enumerate programs involving only 4 of

3Stacking four frames is standard for Atari but redundant for

Breakout

Figure 11: Atari Breakout.

We use the Breakout environment made available through
OpenAI Gym (“BreakoutNoFrameskip-v4”) with three stan-
dard wrappers2: “EpisodicLifeEnv”, which ensures that the
episode ends when the ball falls below the paddle; “FireRe-
setEnv”, which executes the “ﬁre” action at the beginning
of the game to make the ball appear; and “NoopResetEnv”,
which randomizes the initial position of the ball between
task instances. Raw observations are 210×160 RGB images.
We stack two consecutive observations to capture velocity

2These wrappers are implemented in the “stable base-
lines” package (https://github.com/hill-a/stable-baselines). Equiv-
alent preprocessing was done in the original DQN paper and down-
stream work.

the 15 total discrete values, namely those involving the color
of the paddle and ball. This is a problem-speciﬁc hack that
injects additional prior knowledge. However, we do expect
that results would be similar if all discrete values were in-
cluded and more programs (on the order of 5 million) were
enumerated.

To evaluate the learned policy, we test on 10 held-out task
instances for 500 frames. (Recall that variation between task
instances is parameterized by the initial position and veloc-
ity of the ball.) In all 10 cases, the learned policy accrues a
reward of 3. This matches the expert policy and suggests
perfect generalization from only a single relatively short
demonstration, at least for the limited task horizon of 500.
To further assess generalization, we continue past the hori-
zon of 500 and record the total reward accumulated before
the ball falls below the paddle. Across the 10 held-out task
instances, we ﬁnd an average reward of 8.80 with a standard
deviation of 7.47. These results indicate that the learned pol-
icy can generalize immediately to observations with more
bricks missing in different locations than seen during the
single demonstration.

These preliminary results suggest that the policy learning
method and the speciﬁc DSL proposed in this work may ex-
tend to other tasks with minor modiﬁcation, including games
that are not typically thought of as grid-based. We look for-
ward to continuing to evaluating the scalability and applica-
bility of the DSL and general LPP policy learning in future
work.

Training and Test Environments
In the following ﬁgures, we illustrate each task with repre-
sentative training demonstrations and LPP test performance.
(See the main text for Fence In.)

Figure 12: A LPP policy learned from two demonstrations of “Nim” (blue) generalizes perfectly to all test task instances (e.g.
green).

Figure 13: A LPP policy learned from ﬁve demonstrations of “Checkmate Tactic” (blue) generalizes perfectly to all test task
instances (e.g. green).

Figure 14: A LPP policy learned from four demonstrations of “Chase” (top) generalizes perfectly to all test task instances (e.g.
bottom).

Figure 15: A LPP policy learned from three demonstrations of “Stop the Fall” (top) generalizes perfectly to all test task instances
(e.g. bottom).

Figure 16: A LPP policy learned from ﬁve demonstrations of “Reach for the Star” (top) generalizes perfectly to all test task
instances (e.g. bottom).

