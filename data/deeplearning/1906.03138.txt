This is a pre-print of an article accepted for publication in Nature Communications

1

Accurate deep neural network inference using computational
phase-change memory

Vinay Joshi,1, 2 Manuel Le Gallo,1, a) Simon Haefeli,1, 3 Irem Boybat,1, 4 S.R. Nandakumar,1 Christophe
Piveteau,1, 3 Martino Dazzi,1, 3 Bipin Rajendran,2 Abu Sebastian,1, b) and Evangelos Eleftheriou1
1)IBM Research - Zurich, S¨aumerstrasse 4, 8803 R¨uschlikon, Switzerland
2)King’s College London, Strand, London WC2R 2LS, United Kingdom
3)ETH Zurich, R¨amistrasse 101, 8092 Zurich, Switzerland
4)Ecole Polytechnique Federale de Lausanne (EPFL), 1015 Lausanne, Switzerland

(Dated: 14 April 2020)

In-memory computing is a promising non-von Neumann approach for making energy-efﬁcient deep learning inference
hardware. Crossbar arrays of resistive memory devices can be used to encode the network weights and perform efﬁcient
analog matrix-vector multiplications without intermediate movements of data. However, due to device variability and
noise, the network needs to be trained in a speciﬁc way so that transferring the digitally trained weights to the analog
resistive memory devices will not result in signiﬁcant loss of accuracy. Here, we introduce a methodology to train
ResNet-type convolutional neural networks that results in no appreciable accuracy loss when transferring weights to in-
memory computing hardware based on phase-change memory (PCM). We also propose a compensation technique that
exploits the batch normalization parameters to improve the accuracy retention over time. We achieve a classiﬁcation
accuracy of 93.7% on the CIFAR-10 dataset and a top-1 accuracy on the ImageNet benchmark of 71.6% after mapping
the trained weights to PCM. Our hardware results on CIFAR-10 with ResNet-32 demonstrate an accuracy above 93.5%
retained over a one day period, where each of the 361,722 synaptic weights of the network is programmed on just two
PCM devices organized in a differential conﬁguration.

I.

INTRODUCTION

Deep neural networks (DNNs) have revolutionized the ﬁeld of artiﬁcial intelligence and have achieved unprecedented success
in cognitive tasks such as image and speech recognition. Platforms for deploying the trained model of such networks and
performing inference in an energy-efﬁcient manner are highly attractive for edge computing applications. In particular, internet-
of-things battery-powered devices and autonomous cars could especially beneﬁt from fast, low-power, and reliably accurate
DNN inference engines. Signiﬁcant progress in this direction has been made with the introduction of specialized hardware for
inference operating at reduced digital precision (4 to 8-bit), such as Google’s tensor processing unit (TPU)1 and low-power
graphical processing units (GPUs) such as NVIDIA T42. While these platforms are very ﬂexible, they are based on architectures
where there is a physical separation between memory and processing units. The models are typically stored in off-chip memory,
leading to constant shuttling of data between memory and processing units, which limits the maximum achievable energy
efﬁciency.

In order to reduce the data transfers to a minimum in inference accelerators, a promising avenue is to employ in-memory com-
puting using non-volatile memory devices3. Both charge-based storage devices, such as Flash memory4, and resistance-based
(memristive) storage devices, such as metal-oxide resistive random-access memory (ReRAM)5,6 and phase-change memory
(PCM)7–9 are being investigated for this.
In this approach, the network weights are encoded as the analog charge state or
conductance state of these devices organized in crossbar arrays, and the matrix-vector multiplications during inference can be
performed in-situ in a single time step by exploiting Kirchhoff’s circuit laws. The fact that these devices are non-volatile (the
weights will be retained when the power supply is turned off) and have multi-level storage capability (a single device can encode
an analog range of values as opposed to 1 bit) is very attractive for inference applications. However, due to the analog nature of
the weights programmed in these devices, only limited precision can be achieved in the matrix-vector multiplications and this
could limit the achievable inference accuracy of the accelerator.

One potential solution to this problem is to train the network fully on hardware9,10, such that all hardware non-idealities
would be de facto included as constraints during training. Another similar approach is to perform partial optimizations of the
hardware weights after transferring a trained model to the chip11,12. The drawback of these approaches is that every neural
network would have to be trained on each individual chip before deployment. Off-line variation-aware training schemes have
also been proposed, where hardware non-idealities such as device-to-device variations13,14, defective devices14, or IR drop13
are ﬁrst characterized and then fed into the training algorithm running in software. However, these approaches would require

0
2
0
2

r
p
A
1
1

]
T
E
.
s
c
[

2
v
8
3
1
3
0
.
6
0
9
1
:
v
i
X
r
a

a)Electronic mail: anu@zurich.ibm.com
b)Electronic mail: ase@zurich.ibm.com

 
 
 
 
 
 
This is a pre-print of an article accepted for publication in Nature Communications

2

characterizing and training the neural network from scratch for every chip. A more practical approach would be to have a
single custom generic training algorithm that is run entirely in software which would make the network immune to most of the
hardware non-idealities, but at the same time would require only very little knowledge about the speciﬁc hardware it will be
deployed on. In this way, the model would have to be trained only once and could be deployed on a multitude of different chips.
To this end, several works have proposed to inject noise in the training algorithm to the layer inputs15, synaptic weights16, and
pre-activations17,18. However, previous demonstrations have generally been limited to rather simple and shallow networks, and
experimental validations of the effectiveness of the various approaches have been missing. We are aware of one recent work that
analyzed more complex problems such as ImageNet classiﬁcation18, however the hardware model used was rather abstract and
no experimental validation was presented.

In this work, we explore injecting noise to the synaptic weights during the training of DNNs in software as a generic method
to improve the network resilience against analog in-memory computing hardware non-idealities. We focus on the ResNet
convolutional neural network (CNN) architecture, and introduce a number of techniques that allow us to achieve a classiﬁcation
accuracy of 93.7% on the CIFAR-10 dataset and a top-1 accuracy of 71.6% on the ImageNet benchmark after mapping the
trained weights to PCM synapses. In contrast to previous approaches, the noise injected during training is crudely estimated from
a one-time all-around hardware characterization, and captures the combined effect of read and write noise without introducing
additional noise-related training hyperparameters. We validate the training approach through hardware/software experiments,
where each of the 361,722 weights of ResNet-32 is programmed on two PCM devices of a prototype chip, and the rest of the
network functionality is simulated in software. We achieve an experimental accuracy of 93.75% after programming, which
stays above 92.6% over a period of 1 day. To improve the accuracy retention further, we develop a method to periodically
calibrate the batch normalization parameters to correct the activation distributions during inference. We demonstrate a signiﬁcant
improvement in the accuracy retention with this method (up to 93.5% on hardware for CIFAR-10) compared with a simple global
scaling of the layers’ outputs, at the cost of additional digital computations during calibration. Finally, we discuss our training
approach with respect to other methods and quantify the tradeoffs in terms of accuracy and ease of training.

II. RESULTS

A. Problem statement

For our experiments, we consider two residual networks on two different datasets: ResNet-32 on the CIFAR-10 dataset,
and ResNet-34 on the ImageNet dataset19. As shown in Fig. 1a, ResNet-32 consists of 3 different ResNet blocks with ten
3 × 3 kernels each, and is used to classify 32 × 32-pixel RGB images that belong to one out of 10 classes (see Methods). The
network contains 361,722 synaptic weights. The ResNet-34 network used for the 1000-class ImageNet dataset is shown in
Supplementary Fig. 1. The main differences compared to ResNet-32 are the number and size of the ResNet blocks, and a larger
number of input/output channels (see Methods).

The weights of all convolution layers along with the fully connected layer of ResNet-32 can be mapped on memristive crossbar
arrays as explained in Fig. 1b. Each synaptic weight can be mapped on a differential pair of memristive devices that are located
on two different columns. For a given layer l, the synaptic weight W l
i j of the (i, j)th synaptic element is represented by the
effective synaptic conductance Gl

i j given by

i j = Gl,+
Gl

i j − Gl,−
i j ,

(1)

and Gl,−
i j

where Gl,+
are the conductance values of the two devices forming the differential pair. Those device conductance
i j
values are deﬁned as the effective conductance perceived in the operation of a non-ideal memristive crossbar array, and therefore
include all the circuit non-idealities from the crossbar and peripheral circuitry.

The mapping between the synaptic weight W l

i j obtained after software training and the corresponding synaptic conductance is

given by

Gl

i j = W l

i j ×

Gmax
W l

max

+ δ Gl

i j = Gl

T,i j + δ Gl
i j,

(2)

where Gmax is the maximum reliably programmable device conductance and W l
max is the maximum absolute synaptic weight
i j × Gmax
value of layer l. δ Gl
i j represents the synaptic conductance error from the ideal target conductance value Gl
.
W l
δ Gl
i j is a time-varying random variable that describes the effects of non-ideal device programming (inaccuracies associated with
write) and conductance ﬂuctuations over time (inaccuracies associated with read). Possible factors leading to such conductance
errors include inaccuracies in programming the synaptic conductance to Gl
T,i j, 1/ f noise from memristive devices and circuits,
temporal conductance drift, device-to-device variations, defective (stuck) devices, and circuit non-idealities (e.g. IR drop).

T,i j = W l

max

This is a pre-print of an article accepted for publication in Nature Communications

3

FIG. 1. a, ResNet-32 network architecture for CIFAR-10 image classiﬁcation. The architecture of ResNet-32 used in this study is a slightly
modiﬁed version of the original implementation19 with fewer input and output channels in ResNet blocks 2 and 3. b, Training and inference
of an example layer of ResNet-32 according to the methodology proposed in this paper. Software training is performed by injecting a random
noise term to the weights used during the forward propagation, δW l
tr, which is representative of the combined read and write noise of the
memristive devices used during inference (see Section II B). When transferring the weights of a convolution layer to memristive crossbars for
inference, they are ﬂattened into a 2-D matrix by collapsing each ﬁlter into a single vector programmed on a crossbar column, and stacking all
ﬁlters on separate columns20. The weights are then programmed as the differential conductance of two memristive devices. Input activations
al are applied as voltages on the crossbar rows. The output current from the column containing the G− devices is subtracted from the one
from the column containing the G+ devices. The differential current output I from the crossbar then routes to a digital circuitry that performs
batch normalization and the corresponding rectiﬁed linear unit (ReLU) activation function, in order to obtain the input activations for the next
layer al+1. The ﬁnal softmax activation function can be performed off-chip if required. An optional correction of the batch normalization
parameters can be periodically performed to improve the accuracy retention over time (see Section II D and II E). The input image is padded
with zero values at the border to ensure that the convolution operation preserves the height and width of the image. Therefore, considering an
input image of size n × n, the convolution operation can be performed in n2 matrix-vector multiplication cycles.

i j. For existing memristive technologies, the magnitude of δ Gl

Clearly, a direct mapping of the synaptic weights of a DNN trained with 32-bit ﬂoating point (FP32) precision to the same
DNN with memristive synapses is expected to degrade the network accuracy due to the added error in the weights arising from
δ Gl
7, which in
general is not tolerable by DNNs trained with FP32 without any constrains. Imposing such errors as constraints during training
can be beneﬁcial in improving the network accuracy. In fact, quantization of the weights or activations21, and injecting noise
on the weights22, activations23 or gradients24 have been widely used as DNN regularizers during training to reduce overﬁtting
on the training dataset25,26. These techniques can improve the accuracy of DNN inference when it is performed with the same
model precision as during training. However, achieving baseline accuracy while performing DNN inference on a model which
is inevitably different from the one obtained after training, as it is the case for any analog in-memory computing hardware, is a
more difﬁcult problem and requires additional investigations.

i j may range from 1 − 10% of the magnitude of Gl

T,i j

Although a large body of efﬁcient techniques to train DNNs with reduced digital precision has been reported27,28, it is unlikely
that such procedures can generally be applied as-is to analog in-memory computing hardware due to the random nature of δ Gl
i j.
Since quantization errors coming from rounding to reduced ﬁxed-point precision are not random, DNNs trained in this way
are not a priori expected to be suitable for deployment on analog in-memory computing hardware. Techniques that inject

ResNet block 110 layersResNet block 210 layersResNet block 310 layers3x316163x316163x33163x316163x316163x328281x116281x1285632x32x3CIFAR-10 image Output channels 28Kernel size x Input channels 3x3x16 = 144W l21Input activations for (l+1)th layerMap W to Gal1I1I2I28+-+-+-Crossbar of memristive devicesGl,+213x328283x328283x328563x356563x356563x3565656x10Global averagepoolingFully connectedSoftmaxKernel sizeInput channelsOutput channelsDigital circuitry for batch  normalization and ReLUal2al144Gl,-21al+11al+12al+128abBatch normalizationparameters correctionPost trainingForward propagationBackward propagation Input activationsFlattenWeight updateMemristive device nonidealities → δWtrlW l = W l + δWtrl^W l3x31628Software training with noise injectionInference using in-memory computing hardwareConvolution layer lKernel size 3x3Input channels 16Output channels 28: This paper's contributionsThis is a pre-print of an article accepted for publication in Nature Communications

4

random Gaussian noise during training are a much more natural ﬁt to make the network robust to errors from analog in-memory
computing hardware. As early as in 1994, it was shown that injecting noise on the synaptic weights during training enhances
the tolerance to weight perturbations of multi-layer perceptrons, and the application of this technique to analog neural hardware
was discussed29. Recent works have also proposed to apply noise to the layer inputs or pre-activations in order to improve the
network tolerance to hardware noise15,18. In this work, we follow the original approach of Murray et al.29 of injecting Gaussian
noise to the synaptic weights during training. Next, we discuss different techniques that we employed together with synaptic
weight noise in order to improve the accuracy of inference on ResNet and achieve close to software-equivalent accuracy after
transferring the weights to PCM hardware.

B. Training procedure

When performing inference with analog in-memory computing hardware, the DNN experiences errors primarily due to (i)
inaccurate programming of the network weights onto the devices (write noise) and (ii) temporal ﬂuctuations of the hardware
weights (read noise). We can cast the effect of these errors into a single error term δ Gl
i j that distorts each synaptic weight
when performing forward propagation during inference. Hence, we propose to add random noise that corresponds to the error
induced by δ Gl
i j to the synaptic weights at each forward pass during training (see Fig. 1b). The backward pass and weight
updates are performed with weights that did not experience this noise. We found that adding noise to the weights only in the
forward propagation is sufﬁcient to achieve close to baseline accuracy for a noise magnitude comparable to that of our hardware,
and adding noise during the backward propagation did not improve the results further. For simplicity, we assume that δ Gl
i j
is Gaussian distributed, which is usually the case for analog memristive hardware. Weights are linearly mapped to the entire
conductance range Gmax of the hardware, hence the standard deviation σ l
of the Gaussian noise on weights to be applied
during training, for a layer l, can be computed as

δWtr

σ l
W l

δWtr

max

≡ ηtr =

σδ G
Gmax

,

(3)

where σδ G is a representative standard deviation of the combined read and write noise measured from hardware. During training,
max changes, therefore σ l
the weight distribution of every layer and hence W l
is recomputed after every weight update so that
ηtr stays constant throughout training. We found this to be especially important in achieving good training convergence with
this method.

δWtr

Weight initialization can have a signiﬁcant effect on DNN training30. Two different weight initializations can lead to com-
pletely different minima when optimizing the network objective function. The network optimum when training with additive
noise could be closer to the FP32 training optimum than to a completely random initialization. So it can be beneﬁcial to initialize
weights from a pretrained baseline network and then retrain this network by injecting noise. A similar observation was reported
for training ResNet with reduced digital precision28. For achieving high classiﬁcation accuracy in our experiments, we found
this strategy more helpful than random initialization.

The noise injected during training according to Eq. (3) is closely related to the maximum weight of a layer, and can thus
grow uncontrollably with outlier weight values. Controlling the weight distribution in a desirable range can improve the network
training convergence and makes the mapping of weights to hardware with limited conductance range easier. We therefore clip
the synaptic weights at layer l after every weight update in the range [−α × σW l , α × σW l ], where σW l is the standard deviation
of weights in layer l and α is a tunable hyperparameter. In our studies, α = 2.0 and α = 2.5 worked the best for ResNet-32 and
ResNet-34, respectively.

DNN convergence accuracy, in general, is sensitive to the learning rate used during training. Since we initialize the network
parameters from a baseline network, using the same learning rate scheduling as that of the baseline network does not guarantee
accurate convergence. To choose appropriate learning rate scheduling for ResNet-32, we ﬁrst forward propagate the training set
on the pretrained baseline network with injected synaptic weight noise and note the resulting accuracy. We note the learning rate
evolution starting from this accuracy in the baseline network training curve until convergence, and use the same learning rate
evolution while retraining the network by injecting noise.

We performed simulations to characterize the inference performance after training incorporating the injection of Gaussian
noise in conjunction with the techniques presented above. We computed the classiﬁcation accuracy for different amounts of
injected noise ηtr during training. We also show how the accuracy is affected when the inference weights are perturbed by a

certain amount of relative noise ηin f ≡
l before performing inference on the test dataset.

max

σ l
δWin f
W l

, where σ l

δWin f

is the standard deviation of the noise injected to the weights of layer

The test accuracy of ResNet-32 on CIFAR-10 obtained for different amounts of noise injected during training, without induc-
ing any perturbation during inference (ηin f = 0), is plotted in Fig. 2a. It can be seen that the training algorithm is able to achieve
a test accuracy close to the software baseline of 93.87% with up to approximately ηtr = 8%. The tolerance of the networks

This is a pre-print of an article accepted for publication in Nature Communications

5

FIG. 2. a, Test accuracy on CIFAR-10 obtained for different amounts of relative injected weight noise during training ηtr without inducing
any perturbation during inference (ηin f = 0). When ηtr > 8%, the training convergence starts to become affected by the high noise and it is
not possible anymore to reach the software baseline within the same number of epochs. The error bars represent the standard deviation over
10 training runs. b, Test accuracy on CIFAR-10 obtained for the networks trained with different amounts of relative weight noise ηtr as a
function of the weight noise injected during inference ηin f . In most cases, ηtr can be increased above ηin f up to a certain point and still lead
to comparable or slightly higher (within ≈ 0.1%) test accuracy than for ηtr = ηin f . However, when ηtr becomes much higher than ηin f , the
test accuracy decreases due to the inability of the network to achieve baseline accuracy when ηtr > 8%. Each data point represents the average
over 10 training runs and 100 inference runs. c, Test accuracy on CIFAR-10 as a function of ηtr = ηin f . The error bars represent the standard
deviation over 100 inference runs averaged over 10 training runs. d, Top-1 accuracy on ImageNet as a function of ηtr = ηin f . The error bars
represent the standard deviation over 10 inference runs on a single training run.

trained with different amounts of ηtr to weight perturbations during inference, ηin f , is shown in Fig. 2b. For a given value of
ηin f , in general, the highest test accuracy can be obtained for the network that has been trained with a comparable amount of
synaptic weight noise, i.e. for ηtr ≈ ηin f . The test accuracy for ηtr = ηin f is shown in Fig. 2c. It can be seen that for up to
ηin f = 5%, an accuracy within 0.5% of the software baseline is achievable. The impact of the weight initialization, clipping,
and learning rate scheduling on the accuracy is shown in Supplementary Fig. 2. Not incorporating any of those three techniques
results in at least 1% drop in test accuracy for ηtr = ηin f = 3.8%.

The top-1 accuracy of ResNet-34 on ImageNet for ηtr = ηin f is shown in Fig. 2d. Consistent with previous observations18,28,
we found that the network recovers high accuracy extremely quickly when retraining with additive noise due to quick updates
of the batch normalization parameters (see Supplementary Note 1), and obtained satisfactory convergence after only 8 epochs.
The accuracy on ImageNet is much more sensitive to the noise injected during training than for CIFAR-10, and when noise
in injected on all layers, there is more than 0.5% accuracy drop from the baseline even down to ∼ 1.2% relative noise. In the
literature, many network compression techniques allow higher precision for the ﬁrst and last layers, which are more sensitive
to noise28,31. We applied the same simpliﬁcation to our problem, which means that we removed the noise during training on
the ﬁrst convolutional layer and the last dense layer, and performed inference with the ﬁrst and last layer without noise. The
obtained accuracy after training, by injecting the same training and inference noise as previously, can be increased by more than

02468101289909192939402468101293.493.693.894.094.202468101290.591.091.592.092.593.093.594.01.01.52.02.53.03.54.070.070.571.071.572.072.573.073.5bCIFAR-10 test accuracy (%)Relative inference noise (cid:1)inf (%) (cid:1)tr = 2.6% (cid:1)tr = 3.77% (cid:1)tr = 5.65% (cid:1)tr = 7.53% (cid:1)tr = 11.3%baseline (cid:1)inf = 0baselineCIFAR-10 test accuracy (%)Relative training noise (cid:1)tr (%)acbaselineCIFAR-10 test accuracy (%)Relative noise (cid:1)tr = (cid:1)inf (%)dbaselineImageNet top-1 accuracy (%)Relative noise (cid:1)tr = (cid:1)inf (%) Noise on all layers No noise on first and last layersThis is a pre-print of an article accepted for publication in Nature Communications

6

FIG. 3. a, Cumulative distributions of 11 representative iteratively programmed conductance levels on 10,000 PCM devices per level. The
vertical dashed lines denote the target conductance for each level. b, Conductance standard deviation of the 11 levels as a function of target
conductance. The inset shows a representative conductance distribution of one level. c, Test accuracy on CIFAR-10 after software training and
after weight transfer to PCM synapses for different training schemes. d, Top-1 accuracy on ImageNet after software training and after weight
transfer to PCM synapses for different training schemes. In c and d, the error bars represent the standard deviation over 10 inference runs.

1% with this technique (see Fig. 2d).

C. Weight transfer to PCM-based synapses

In order to experimentally validate the effectiveness of the above training methodology, we performed experiments on a
prototype multi-level PCM chip comprising 1 million PCM devices fabricated in 90 nm CMOS baseline technology32. PCM
is a memristive technology which records data in a nanometric volume of phase-change material sandwiched between two
electrodes33. The phase-change material is in the low-resistive crystalline phase in an as-fabricated device. By applying a
current pulse of sufﬁcient amplitude (typically referred to as the RESET pulse) an amorphous region around the narrow bottom
electrode is created via a melt-quench process. The device will be in a low conductance state if the high-resistive amorphous
region blocks the current path between the two electrodes. The size of the amorphous region can be modulated in an almost
completely analog manner by the application of suitable electrical pulses. Hence, a continuum of conductance values can be
programmed in a single PCM device over a range of more than two orders of magnitude.

An optimized iterative programming algorithm was developed to program the conductance values in the PCM devices with
high accuracy (see Methods). The experimental cumulative distributions of conductance values for 11 representative pro-
grammed levels, measured approximately 25 seconds after programming, are shown in Fig. 3a. The standard deviation of
these distributions is extracted and ﬁtted with a polynomial function of the target conductance (dashed lines in Fig. 3a) as shown
in Fig. 3b. For all levels, we achieve a standard deviation less than 1.2 µS, which is more than 2 times lower than that reported
in previous works on nanoscale PCM arrays for a similar conductance range34,35.

05101520253002040608010005101520250.00.20.40.60.81.01.232-bit4-bitTernaryAdditive noise90919293949532-bit4-bitAdditive noise626466687072747693.8593.8992.3594.1791.6692.8292.0293.7173.2072.9571.9465.4164.8671.62Cumulative frequency (%)Conductance (mS)ab Experiment Polynomial fitStandard deviation (mS)Target conductance (mS)810121416Conductance (mS)cCIFAR-10 test accuracy (%)Training schemes After training After transfer to PCM synapsesdImageNet top-1 accuracy (%)Training schemes After training After transfer to PCM synapsesThis is a pre-print of an article accepted for publication in Nature Communications

7

To study the effect of weight transfer to PCM synapses, Eq. (2) is computed using the conductance standard deviation mea-
sured from hardware. δ Gl
i j is modeled as a Gaussian distributed random variable with 0 mean and standard deviation given by
the ﬁtted curve of Fig. 3b for the corresponding target conductance, |Gl
T,i j|, computed with Gmax = 25 µS. The resulting test
accuracy obtained after software training and after weight transfer to PCM synapses for ResNet-32 on CIFAR-10 is shown in
Fig. 3c for different training procedures. It can be seen that standard FP32 training without constraints performs the worst after
transfer to PCM synapses. Training with 4-bit precision weights (using the method described in Ref. 28), which is roughly the
effective precision of our PCM devices34, improves the performance after transfer with respect to FP32, but nevertheless the
accuracy decreases by more than 1% after transferring the 4-bit weights to PCM. Training ternary digital weights36 leads to a
lower performance drop (< 0.5%) when transferring weights to PCM, although we were not able to reach the FP32 baseline
with ternary weights on this network. Therefore the accuracy after transfer is worse than for the 4-bit weights. When performing
training by injecting Gaussian noise as described in Section II B with ηtr = 3.8%, corresponding to σδ G = 0.94 µS (median of
the 11 values reported in Fig. 3b), the best overall performance after transfer to PCM is obtained. The resulting accuracy of
93.7% is less than 0.2% below the FP32 baseline. A rather broad range of values of ηtr lead to a similar resulting accuracy (see
Supplementary Fig. 3), demonstrating that ηtr does not have to be very precisely determined for obtaining satisfactory results
on PCM. The accuracy obtained without perturbing the weights after training by injecting noise is slightly higher than the FP32
baseline, which could be attributed to improved generalization resulting from the additive noise training.

The top-1 accuracy for ResNet-34 on ImageNet after transfer to PCM synapses for different training procedures is shown in
Fig. 3d. Training with additive noise increases the accuracy by approximately 6% on PCM compared with FP32 and 4-bit28
training. The accuracy of 71.6% achieved with additive noise training on PCM is signiﬁcantly higher than that reported in Fig.
2d with ηin f = 3.8%, which could be attributed to a high percentage of network weights mapped to low conductance values with
lower standard deviation than the median of 0.94 µS.

D. Hardware/software inference experiment on CIFAR-10

Although we could achieve good test accuracy after weight transfer to PCM synapses as shown in the previous section, an
important challenge for any analog in-memory computing hardware is to be able to retain this accuracy over time. This is
especially true for PCM due to the high 1/ f noise experienced in these devices as well as temporal conductance drift. The
conductance values in PCM drift over time t according to the relation G(t) = G(t0)(t/t0)−ν , where G(t0) is the conductance
measured at time t0 after programming and ν is the drift exponent, which depends on the device, phase-change material, and
phase conﬁguration of the PCM (ν is higher for the amorphous than the crystalline phase)37. In our PCM devices, ν ≈ 0.06
on average. Therefore, it is essential to measure experimentally how the test accuracy evolves over time during inference with
PCM.

Here, we present experiments where all 361,722 synaptic weights of ResNet-32 trained with ηtr = 3.8% are programmed
individually on two PCM devices of the chip. Depending on the sign of Gl
is iteratively programmed to
|Gl
T,i j|, and the other device is RESET close to 0 µS with a single pulse of 450 µA amplitude and 50 ns width. The iterative
programming algorithm converged on 99.1% of the devices programmed to nonzero conductance, and no screening for defective
devices on the chip was performed prior to the experiments. The scatter plot of the PCM weights measured approximately 25
seconds after programming versus the target weights W l
i j is shown in Fig. 4a. After programming, the PCM analog conductance
values were periodically read from hardware over a period of 1 day, scaled to the network weights, and reported to the software
that performed inference on the test dataset (see Methods).

T,i j, either Gl,+

i j or Gl,−

i j

In addition to the experiment, we developed an advanced behavioral model of the hardware in order to precisely capture
the conductance evolution over time during inference (see Supplementary Note 2). The model is built based on an extensive
experimental characterization of the array-level statistics of hardware noise and drift. Conductance drift is modeled using a
Gaussian distributed drift exponent across devices, whose mean and standard deviation both depend on the target conductance
state |Gl
T,i j|. Conductance noise with the experimentally observed 1/ f 1.21 frequency dependence is also incorporated with a
magnitude that depends on the target conductance state and time. The model is able to accurately reproduce both the array-level
statistics (see Fig. 4b) and individual device behavior (see Fig. 4c) observed over the duration of the experiment. Accurate
modeling of all the complex dependencies of noise and drift as a function of time and conductance state was found to be very
critical in being able to reproduce the experimental evolution of the accuracy on ResNet.

The resulting accuracy on CIFAR-10 over time is shown in Fig. 4d. The test accuracy measured 25 seconds after programming
is 93.75%, which is very similar to the result obtained in Fig. 3c. However, if nothing is done to compensate for conductance
drift, the accuracy quickly decreases down to 10% (random guessing) within approximately 1000 seconds. This is because
the magnitude of the PCM weights gradually reduces over time due to drift and this prevents the activations from properly
propagating throughout the network. A simple global scaling calibration procedure can be used to compensate for the effect
of drift on the matrix-vector multiplications performed with PCM crossbars. As proposed in Ref. 34, the summed current of a
subset of the columns in the array can be periodically read over time at a constant voltage. The resulting total current is then

This is a pre-print of an article accepted for publication in Nature Communications

8

FIG. 4. a, Scatter plot of weights programmed in the PCM chip versus target weights obtained after training. The inset shows the distribution
of the relative error between programmed and target synaptic conductance, (Gl
T,i j)/Gmax, and its standard deviation σ . b, Distributions
of programmed devices whose target conductance fall within 0.25 µS from 5 representative GT values. The distributions are shown at four
different times spanning the experiment duration of one day. The ﬁlled bars are the measured hardware data, the black lines are the PCM
model. c, Individual device conductance evolution over time of four arbitrarily picked devices from the chip programmed to four distinct GT
values, along with one PCM model realization for the same GT values. d, Measured test accuracy over time from the weights of the PCM
chip, along with the corresponding PCM model match. A global drift compensation (GDC) procedure is performed for every layer before
performing inference on the test set. The ﬁlled areas from the PCM model correspond to one standard deviation over 25 inference runs.

i j − Gl

divided by the summed current of the same columns but read at time t0. This results in a single scaling factor that can be applied
to the output of the entire crossbar in order to compensate for a global conductance shift (see Methods and Supplementary Fig.
4). Since this factor can be combined with the batch normalization parameters, it does not incur any additional overhead when
performing inference. This simple global drift compensation (GDC) procedure was implemented for every layer before carrying
out inference on the test set, and the results are shown in Fig. 4d. It can be seen that GDC allows the retention of a test accuracy
above 92.6% for 1 day on the PCM chip, and effectively prevents the effect of global weight decay over time as illustrated in
Supplementary Fig. 4. A good agreement of the accuracy evolution between model and experiment is obtained, hence validating
its use for extrapolating results over a longer period of time and for assessing the accuracy of larger networks that cannot ﬁt on
our current hardware.

E. Adapting batch normalization statistics to improve the accuracy retention

Although GDC can compensate for a global conductance shift across the array, it cannot mitigate the effect of 1/ f noise and
drift variability across devices. From the model, we observe that 1/ f noise is responsible for the random accuracy ﬂuctuations,

101102103104105051015202510110210310410592.292.492.692.893.093.293.493.693.894.0-0.6-0.4-0.20.00.20.40.6-0.6-0.4-0.20.00.20.40.6aProgrammed weight in PCM chipTarget weight100101102103104105Counts-20-1001020010k20k30kCountsConductance error (%)s = 4 %GT = 3.6 mSGT = 8.7 mSGT = 14 mScGT ~ 2 mSGT ~ 7 mSGT ~ 12 mSGT ~ 22 mSDevice conductance (mS)Time (s) Experiment ModelGT ~ 17 mSGT = 24 mS0510152025100102104 Experiment Model100,748 sConductance (mS)10010210410,172 s1001021042,385 s100102104b27 sbaselinedCIFAR-10 test accuracy (%)Time (s) Experiment ModelThis is a pre-print of an article accepted for publication in Nature Communications

9

FIG. 5. a, The AdaBS calibration procedure consists in updating the running mean µ and variance σ 2 parameters of the batch normalization
performed in the digital unit of the in-memory computing hardware. The calibration is performed periodically when the device is idle, and
after calibration the values of µ and σ 2 of every layer are updated for subsequent inference. Note that during the calibration phase, batch
B instead of µ and σ 2 (see Methods and Supplementary Note 3).
normalization is performed using the mini-batch mean µB and variance σ 2
b, Test accuracy of ResNet-32 on CIFAR-10 with GDC and AdaBS using the PCM model, along with experimental test accuracy obtained
by applying AdaBS on ResNet-32 with the measured weights from the PCM chip. The ﬁlled areas from the PCM model correspond to one
standard deviation over 25 inference runs. c Top-1 accuracy of ResNet-34 on ImageNet with GDC and AdaBS computed using the PCM
model. Implementations using PCM synapses for all layers as well as ﬁrst and last layers in digital FP32, and PCM synapses for all other
layers, are shown. In the latter, no noise is applied on the ﬁrst and last layers during training. The ﬁlled areas correspond to one standard
deviation over 10 inference runs.

whereas drift variability and its dependence on the target conductance state cause the monotonous accuracy decrease over time
(see Supplementary Fig. 5). In order to improve the accuracy retention further, we propose to leverage the batch normalization
parameters to correct the activation distributions during inference such that their mean and variance match those that were
optimally learned during training. During inference, batch normalization is performed by normalizing the preactivations by
their corresponding running mean µ and variance σ 2 computed during training. Then, scale and shift factors (γ and β ) that
were learned through backpropagation are applied to the normalized preactivations. Since γ and β are learnable parameters,
it is not desirable to change them since it would require retraining the model on the PCM devices. However, updating µ and
σ 2 is more intuitive, since the mean and variance of the preactivations are affected by noise and drift. Leveraging this idea,
we introduce a new compensation technique called adaptive batch normalization statistics update (AdaBS), which improves the
accuracy retention beyond GDC at the cost of additional computations during the calibration phase.

As described in Fig. 5a, the calibration phase consists in sending multiple mini-batches from a set of calibration images
that come from the same distribution than the images seen during inference. In this study, we use the images from the training
dataset as calibration images. The running mean and variance of preactivations are computed across the entire calibration dataset.
The new values of µ and σ 2 computed during calibration are then used for subsequent inference. The main advantage of this
technique is that it does not incur additional digital computations nor weight programming during inference, since we are only
updating the batch normalization parameters µ and σ 2 when the calibration is performed. However, injecting the entire training

AdaBS calibration: compute μ and σ2At the end of calibration phaseupdate μ and σ2n input mini-batches of activations from n distinct randomly sampled mini-batches from the training setX1XnLayer inputCrossbararrayof l th layerBatch norm.μ, σ2, γ, βReLUCrossbararrayof l th layerInference phaseCalibration phaseBatch norm.μB, σB2, γ, βReLUaTo next layerTo next layer10110210310410510610790.591.091.592.092.593.093.594.01011021031041051061076062646668707274baselinebCIFAR-10 test accuracy (%)Time (s)Model (GDC)Model (AdaBS)Experiment (AdaBS)baselinecImageNet top-1 accuracy (%)Time (s)Model (GDC); All-PCMModel (AdaBS); All-PCMModel (GDC); First and last layers in FP32Model (AdaBS); First and last layers in FP32This is a pre-print of an article accepted for publication in Nature Communications

10

dataset to compute µ and σ 2 in the calibration phase would bring signiﬁcant overhead. When reducing the amount of injected
images, the number of updates of the running statistics becomes smaller, and if the momentum used for computing µ and σ 2 is
not properly tuned to account for this, the network accuracy heavily decreases. To tackle this issue, we developed a procedure to
obtain the optimal momentum as a function of the number of mini-batches used for calibration (see Methods and Supplementary
Note 3). With this method, we were able to reduce the number of calibration images down to 5.2% of the CIFAR-10 training
dataset (2,600 images) without affecting the accuracy. With that number of images, the overhead in terms of digital computations
of the AdaBS calibration is about 52% of performing batch normalization during inference on the whole CIFAR-10 test set (see
Supplementary Note 3). It may appear cumbersome to send so many images to the device to perform the calibration, however
since it is only performed periodically over time when the device is idle and not every time an image is inferred by the network,
the high calibration cost can be amortized. The calibration overhead can be further reduced by using more efﬁcient variants of
batch normalization such as the L1-norm version (see Supplementary Note 3). Moreover, although we used AdaBS (and GDC)
to compensate solely for the drift of the PCM devices, the same procedure can be applied to mitigate conductance changes due
to ambient temperature variations, a critical issue for any analog in-memory computing hardware. The resulting accuracy when
performing AdaBS on ResNet-32 with hardware weights before carrying out inference on the test set is shown in Fig. 5b. AdaBS
allows to retain a test accuracy above 93.5% over one day, an improvement of 0.9% compared with GDC. This improvement
becomes 1.8% for one year when extrapolating the results using the PCM model.

We also applied AdaBS on the ImageNet classiﬁcation task with ResNet-34, trained with ηtr = 3.8%, using the PCM model
to simulate the weight evolution for one year. By applying the same AdaBS method as for CIFAR-10 using only 0.1% of the
ImageNet training dataset for calibration (1300 images), the accuracy after one year is increased by 7% compared with GDC
when all layers are implemented with PCM synapses (see Fig. 5c). When the ﬁrst and last layers are implemented in digital
FP32, the initial accuracy increases to 71.9% and the retention is signiﬁcantly improved. This technique, combined with AdaBS,
allows the retention of an accuracy above 71% for one year. Drawbacks in efﬁciency when performing inference on hardware
in this way have to be mentioned, but they stay limited given the small number of parameters and input size of the ﬁrst and last
layers 1.

III. DISCUSSION

Combined together, the strategies developed in this study allow us to achieve the highest accuracies reported so far with analog
resistive memory on the CIFAR-10 and ImageNet benchmarks with residual networks close to their original implementation19.
Although there is still room for improvement especially on ImageNet, those accuracies are already comparable or higher than
those reported on ternary weight networks36, for example 71.6% top-1 accuracy of ResNet-34 on ImageNet with ﬁrst layer in
FP3238. Importantly, the accuracies we report are achieved with just a single nanoscale PCM device encoding the absolute
value of a weight. A common approach that could improve the accuracy further is to use multiple devices to encode different
bits of a weight3,35, at the expense of area and energy penalty, and additional support required by the peripheral circuitry.
Aligned with previous observations18,28, we notice that retraining ResNet with additive noise results mainly in adapting the
batch normalization parameters, whereas the weights stay close to the full-precision weights trained without noise. Hence,
retraining by injecting noise from a pretrained baseline network rather than from scratch is very effective since the network
recovers high accuracy very quickly, especially for ImageNet. Although our experiments are not done on a fully-integrated chip
that supports all functions of deep learning inference, the most critical effects of array-level variability, noise, and drift, are
fully accounted for because each weight of the network is programmed on individual PCM devices of our array. Aspects of a
fully-integrated chip that are not entirely captured in our experiments such as IR drop and additional circuit nonidealities such as
offsets and noise have been studied in previous works and could be mitigated by additional retraining methods13,15. Additional
errors due to quantization coming from the crossbar data converters are analyzed further below.

There exist many different methods of training a neural network with noise that aim to improve the resilience of the model to
analog mixed-signal hardware. These include injecting additive noise on the inputs of every layer15, on the preactivations17,18, or
just adding noise on the input data39. Moreover, injecting multiplicative Gaussian noise to the weights29 (σ l
i j|) is also
defensible regarding the observed noise on the hardware. We analyzed the four aforementioned methods, attempting to reach the
same accuracy demonstrated previously after weight transfer to PCM devices, to identify their possible beneﬁts and drawbacks
(see Supplementary Note 4). We found that it is possible to adjust the training procedure of all four methods to achieve a
similar accuracy on CIFAR-10 after transferring the weights to PCM synapses. Somewhat surprisingly, even adding noise on
the input data during training, which is just a simple form of data augmentation, leads to a model which is more resilient
to weight perturbations during inference. This shows that it is not necessary to train a model with very complicated noise
models that imitate the observed hardware noise precisely. As long as the data propagated through the network is corrupted

δWtr,i j ∝ |W l

1 The ﬁrst layer’s input is a large 224 × 224 image, but it has only 3 channels. For the last layer, the input is ﬂattened to a single 512-dimensional vector

(assuming a batch size of 1). The ﬁrst and last layers contain less than 3% of the network weights.

This is a pre-print of an article accepted for publication in Nature Communications

11

by a Gaussian noise of the right magnitude, the model is expected to be robust to mapping on PCM devices. However, all
four methods require one or multiple noise scaling factor hyperparameters to tune in order to reach satisfactory accuracy after
transfer to PCM. In contrast, our proposed methodology estimates the additive noise to inject on the weights, ηtr, from a simple
hardware characterization, avoiding any hyperparameter search for noise scaling factors. The value of ηtr does not have to be
very precise either, because there is a range of values that lead to similar accuracy after transfer to PCM (see Supplementary Fig.
3). Moreover, we found that injecting noise on weights achieves better accuracy retention over time (see Supplementary Note
4), which suggests that weight noise mimics the behavior of the PCM hardware better.

A critical issue for in-memory computing hardware is the need for digital-to-analog (analog-to-digital) conversion every time
data goes in (out) of the crossbar arrays. These data conversions lead to quantization of the activations and preactivations, re-
spectively, which introduce additional errors in the forward propagation. Based on a recent ADC survey18, 8-bit data conversion
is a good tradeoff between precision and energy consumption. Hence, we analyzed the effect of quantizing the input and output
of every layer of ResNet-32 and ResNet-34 to 8-bit on the inference accuracy. We set the input/output quantization ranges to
the 99.995-th percentile of the activation/preactivation distributions that are obtained when forward propagating 10k randomly
sampled images from the training dataset through the baseline network. As shown in Supplementary Fig. 6, even though the 8-bit
quantization is not included in our training algorithm, the quantization has a minimal effect on the mean accuracy of ResNet-32
on CIFAR-10 (< 0.05% drop) and ResNet-34 on ImageNet (< 0.15% drop) after weight transfer to PCM synapses. The accu-
racy evolution over time, retaining the same quantization ranges, does not degrade signiﬁcantly further and stays well within
one standard deviation of that obtained without quantization. The small accuracy deviations could be potentially overcome by
including the quantization in the retraining process, which will likely be necessary if less than 8-bit resolution is desired for
higher energy efﬁciency.

Although a computational memory accelerates the matrix-vector multiplication operations in a DNN, communicating activa-
tions between computational memory cores executing different layers can become a bottleneck. This bottleneck depends upon
two factors, (i) the way different layers are connected to each other and (ii) the latency of the hardware implementation to trans-
fer activations from one core to another. Designing optimal interconnectivity between the cores for state-of-the-art deep CNNs
is an open research problem. Indeed, having the network weights stationary during execution in a computational memory puts
limits on what portion of the computation can be forwarded to different cores and what cannot. This ultimately results in long-
established hardware communication fabrics being ill-ﬁt for the task. One topology for communication fabrics that is well-suited
for computational memory is proposed by Dazzi et al.40. It is based on a 5 parallel prism (5PP) graph topology and facilitates
inter-layer pipelined execution of CNNs3. The proposed 5PP topology allows the mapping of all the primary connectivities
of state-of-the-art neural networks, including ResNet, DenseNet and Inception-style networks40. As discussed in Ref. 40, the
ResNet-32 implementation with 5PP can result in potentially 2× improvement in pipeline stage latency with similar bandwidth
requirements compared with a standard 2D-mesh. Assuming 8-bit activations, communication links with data rate of 5Gbps41,
and crossbar computational cycle time of 100 ns, a single image inference latency of 52 µs and frame rate of 38, 600 frames per
second (FPS) for ResNet-32 on CIFAR-10 is estimated. As an approximate comparison, YodaNN42, a digital DNN inference
accelerator for binary weight networks with ultra-low power budget, achieves 434.8 FPS in high throughput mode for a 9-layer
CNN (BinaryConnect43) on CIFAR-10. Although not a direct comparison, the proposed topology and pipelined execution of
ResNet-32 could result in 88× speedup, with a deeper network than the digital solution.

In summary, we introduced strategies for training ResNet-type CNNs for deployment on analog in-memory computing hard-
ware, as well as improving the accuracy retention on such hardware. We proposed to inject noise to the synaptic weights which
is proportional to the combined read and write conductance noise of the hardware during the forward pass of training. This
approach combined with judicious weight initialization, clipping, and learning rate scheduling, allowed us to achieve an accu-
racy of 93.7% on the CIFAR-10 dataset and a top-1 accuracy on the ImageNet benchmark of 71.6% after mapping the trained
weights to analog PCM synapses. Our methods introduce only a single additional hyperparameter during training, the weight
clip scale α, since the magnitude of the injected noise can be easily deduced from a one-time hardware characterization. Af-
ter programming the trained weights of ResNet-32 on 723,444 PCM devices of a prototype chip, the accuracy computed from
the measured hardware weights stayed above 92.6% over a period of 1 day, which is to the best of our knowledge the highest
accuracy experimentally reported to-date on the CIFAR-10 dataset by any analog resistive memory hardware. A global scaling
procedure was used to compensate for the conductance drift of the PCM devices, which was found to be critical in improving the
accuracy retention. However, global scaling could not mitigate the effect of 1/ f noise and drift variability across devices, which
led to accuracy ﬂuctuations and monotonous accuracy decrease over time, respectively. Periodically calibrating the batch nor-
malization parameters before inference allowed to alleviate those issues at the cost of additional digital computations, increasing
the 1-day accuracy to 93.5% on hardware. These results demonstrate the feasibility of realizing accurate inference on complex
DNNs through analog in-memory computing using existing PCM devices.

This is a pre-print of an article accepted for publication in Nature Communications

12

METHODS

A. Experiments on PCM hardware platform

The experimental platform is built around a prototype PCM chip that comprises 3 million PCM devices. The PCM array is
organized as a matrix of word lines (WL) and bit lines (BL). In addition to the PCM devices, the prototype chip integrates the
circuitry for device addressing and for write and read operations. The PCM chip is interfaced to a hardware platform comprising
two ﬁeld programmable gate array (FPGA) boards and an analog-front-end (AFE) board. The AFE board provides the power
supplies as well as the voltage and current reference sources for the PCM chip. The FPGA boards are used to implement overall
system control and data management as well as the interface with the data processing unit. The experimental platform is operated
from a host computer, and a Matlab environment is used to coordinate the experiments. The PCM devices were integrated into
the chip in 90-nm CMOS technology using the key-hole process described in Ref. 44. The phase-change material is doped
Ge2Sb2Te5. The bottom electrode has a radius of ∼ 20 nm and a length of ∼ 65 nm. The phase-change material is ∼ 100 nm
thick and extends to the top electrode, whose radius is ∼ 100 nm. All experiments performed in this work were done on an array
containing 1 million devices accessed via transistors, which is organized as a matrix of 512 WL and 2048 BL.

A PCM device is selected by serially addressing a WL and a BL. To read a PCM device, the selected BL is biased to a constant
voltage (300 mV) by a voltage regulator via a voltage generated off chip. The sensed current is integrated by a capacitor, and the
resulting voltage is then digitized by the on-chip 8-bit cyclic analog-to-digital converter (ADC). The total duration of applying
the read pulse and converting the data with the ADC is 1 µs. The readout characteristic is calibrated via on-chip reference
polysilicon resistors. To program a PCM device, a voltage generated off chip is converted on chip into a programming current.
This current is then mirrored into the selected BL for the desired duration of the programming pulse. Iterative programming
involving a sequence of program-and-verify steps is used to program the PCM devices to the desired conductance values45. The
devices are initialized to a high-conductance state via a staircase-pulse sequence. The sequence starts with a RESET pulse of
amplitude 450 µA and width 50 ns, followed by 6 pulses of amplitude decreasing regularly from 160 µA to 60 µA and with a
constant width of 1000 ns. After initialization, each device is set to a desired conductance value through a program-and-verify
scheme. The conductance of all devices in the array is read 5 times consecutively at a voltage of 0.3 V, and the mean conductance
of these reads is used for veriﬁcation. If the read conductance of a speciﬁc device does not fall within 0.25 µS from its target
conductance, it receives a programming pulse where the pulse amplitude is incremented or decremented proportionally to the
difference between the read and target conductance. The pulse amplitude ranges between 80 µA and 400 µA. This program-
and-verify scheme is repeated for a maximum of 55 iterations.

i j and Gl,−

In the hardware/software inference experiments, the analog conductance values of the PCM devices encoding the network
weights, Gl,+
, are serially read individually with the 8-bit on-chip ADC at predeﬁned timestamps spaced over a pe-
riod of one day. The read conductance values at every timestamp are reported to a TensorFlow-based software. This software
performs the forward propagation of the CIFAR-10 test set on the weights read from hardware and computes the resulting clas-
siﬁcation accuracy. The drift compensation techniques, GDC and AdaBS, are performed entirely in software at every timestamp
based on the conductance values read from hardware.

i j

B. PCM-based deep learning inference simulator

We developed a simulation framework to test the efﬁcacy of DNN inference using PCM devices. We chose Google’s
TensorFlow46 deep learning framework for the simulator development. The large library of algorithms in TensorFlow enables
us to use native implementation of required activation functions and batch normalization. Moreover, any regular TensorFlow
code of a DNN can be easily ported to our simulator. As shown in Supplementary Fig. 7, custom made TensorFlow opera-
tions are implemented that generate PCM conductance values from the behavioral model of hardware PCM devices that was
developed (see Supplementary Note 2). All the nonidealities including conductance range, programming noise, read noise, and
conductance drift are implemented in TensorFlow following the equations shown in Supplementary Note 2. The simulator can
also take the PCM conductance data measured from hardware as input, in order to perform inference on the hardware data.
Data converters that simulate digital quantization of data at the input and output of crossbars are also implemented with tunable
quantization ranges and precision. In this study, the data converters were turned off for all simulations except those presented in
Supplementary Fig. 6. The drift correction techniques are implemented post quantization of the crossbar output.

C. Training implementation of ResNet-32 on CIFAR-10

ResNet-32 has 31 convolution layers with 3 × 3 kernels, 2 convolution layers with 1 × 1 kernels, and a ﬁnal fully-connected
layer. The network contains 361,722 synaptic weights. It consists of 3 different ResNet blocks with 10 3 × 3 kernels each. After

This is a pre-print of an article accepted for publication in Nature Communications

13

the ﬁrst convolution layer, there is a unity residual feed forward connection after every two convolution layers, except the 1 × 1
residual convolution connection to make output channels compatible between two layers. Each convolution layer is followed
by batch normalization47. ReLU activation is used after every batch normalization except in case of residual connections,
where the ReLU activation is computed after summation. The output of the last convolution layer is then downsampled using
global average pooling48, which is followed by a single fully-connected layer. For the last fully-connected layer, no batch
normalization is performed. The architecture of ResNet-32 used in this study is a slightly modiﬁed version of the original
implementation19 with fewer input and output channels in ResNet blocks 2 and 3. This network is trained on the well-known
CIFAR-10 classiﬁcation dataset49. It has 32 × 32 pixels RGB images that belong to one of the 10 classes.

The network is trained on the 50,000 images of the training set, and evaluation is performed on the 10,000 images of the test
set. The training is performed using stochastic gradient descent with a momentum of 0.9. The network objective is categorical
cross entropy function over 10 classes of the input image. Learning rate scheduling is performed to reduce learning rate by 90%
at every 50th training epoch. The initial learning rate for the baseline network is 0.1 and training converges in 200 epochs with
a mini-batch size of 128. Weights of all convolution and fully connected layers of the baseline network are initialized using He
Normal30 initialization. The baseline network is retrained by injecting Gaussian noise for up to 150 epochs with weight clip
scale α = 2. We preprocess the training images by randomly cropping a 32 × 32 patch after padding 2 pixels along the height
and width of the image. We also apply a random horizontal ﬂip on the images from the train set. Additionally, we apply cutout50
on the training set images. For both training and test set, we apply channel wise normalization for 0 mean and unit standard
deviation.

D. Training implementation of ResNet-34 on ImageNet

The architecture of the ResNet-34 network for ImageNet classiﬁcation is derived from Ref. 19. It has 32 convolution layers
with 3 × 3 kernels, 3 convolution layers with 1 × 1 kernels, a ﬁrst convolution layer with 7 × 7 kernels and a ﬁnal fully-connected
layer. The network has 21,797,672 synaptic weights. The ﬁrst convolution layer downsamples the input by using a stride of 2
pixels, followed by a maxpooling layer with kernel size of 3 × 3 and stride of 2 to downsample the feature maps to the resolution
of 56 × 56 pixels. Each residual connection with 1 × 1 convolution and ﬁrst layer of ResNet blocks 2, 3, 4 downsample the input
by using a stride of 2 pixels. A global average pooling layer before the ﬁnal fully-connected layer downsamples the 7 × 7 input
to 1 × 1 resolution. The ﬁnal fully-connected layer computes the output prediction corresponding to 1,000 classes.

We trained ResNet-34 on the ImageNet51 dataset. The ImageNet dataset has 1.3M images in the training set and 50k images
in the test set. Images in the ImageNet dataset are preprocessed by following the same preprocessing steps as that of the Pytorch
baseline model. Training images are randomly cropped to a 224 × 224 patch and then random horizontal ﬂip is applied on
the images. Channel wise normalization is performed on the images in both training and test set for 0 mean and unit standard
deviation. Only for the test set, images are ﬁrst resized to 256 × 256 using bilinear interpolation method and then a center crop
is performed to obtain the 224 × 224 image patch.

The network objective function is softmax cross entropy on network output and corresponding 1,000 labels. The network
objective is minimized using the stochastic gradient descent algorithm with a momentum of 0.9. We obtained our baseline
network architecture and its parameters from the Pytorch model zoo52. We use this network to perform additive noise training
by injecting Gaussian noise for a total of 10 training epochs. In contrast to ResNet-32 on CIFAR-10, no learning rate scheduling
was performed since the network was trained only for 10 epochs with additive noise. We use mini-batch size of 400 and learning
rate of 0.001 for the additive noise training simulations. We also use L2 weight decay of 0.0001 and weight clip scale of α = 2.5
for the additive noise training.

E. Global drift compensation (GDC) method

The GDC calibration phase consists of computing the summed current of L columns in each array encoding a network layer
(see Supplementary Fig. 4). Those L columns contain devices initially programmed to known conductance values Gmn(t0). By
reading those column currents, Im, periodically with applied voltage Vcal on all rows, we can compensate for a global conductance
shift in the array during inference. When input data is processed by the crossbar during inference, the crossbar output can be
scaled by 1/ ˆα, where

ˆα =

m=1 Im

∑L
n=1 ∑L

m=1 Gmn(t0)

Vcal ∑N

.

This procedure is especially simple because L can be chosen to be small, enough to get sufﬁcient statistics. Moreover, ˆα is
computed from the device data itself, without resorting to any assumption on how the conductance changes nor requiring extra
timing information. The term Vcal ∑N
m=1 Gmn(t0) needs to be computed only once, stored in the digital memory of the chip,

n=1 ∑L

This is a pre-print of an article accepted for publication in Nature Communications

14

and is reused for all calibrations. Reading the subset of L columns of the crossbar can be done while the PCM array is idle, i.e.,
when there are no incoming images to be processed by the device. Performing the L current summations can be implemented
either with on-chip digital circuitry or in the control unit of the chip. At the end of the calibration phase, 1/ ˆα is computed
and stored locally in digital unit of the crossbar. The output scaling by 1/ ˆα during inference can be combined with batch
normalization because it is a linear operation. In our experiments, the calibration procedure was performed using all columns of
each layer (e.g. L is equal to two times number of output channels) every time before inference is performed on the whole test
set.

F. Adaptive batch normalization statistics update (AdaBS) technique

Batch normalization is performed differently in the training and inference phases of a DNN. During the training of a DNN,
B) over the

batch normalization normalizes the input to zero mean and unit variance by computing the mean (µB) and variance (σ 2
mini-batch of m images

xi

µB =

σ 2
B =

1
m

1
m

m
∑
i=1
m
∑
i=1

(xi − µB)2.

(4)

(5)

The normalized input is then scaled and shifted by γ and β . During the training phase, γ and β are learned through backpropaga-
tion. In parallel, a global running mean (µ) and variance (σ 2) are computed by exponentially averaging µB and σ 2
B respectively,
over all the training batches

µ = p · µ + (1 − p) · µB
σ 2 = p · σ 2 + (1 − p) · σ 2
B,

(6)

(7)

where p is the momentum. After training, the estimates of the global mean and variance µ and σ 2 are then used during the
inference phase. When performing forward propagation during inference, the batch normalization coefﬁcients µ, σ 2, γ, and β
are used for normalization, scale, and shift.

The calibration phase of AdaBS consists in recomputing and updating µ and σ 2 for every layer where batch normalization is
present. We recompute µ and σ 2 by feeding a randomly sampled set of mini-batches from the training dataset. In recomputing µ
and σ 2, hyper-parameters such as mini-batch size (m) and momentum (p) need to be carefully tuned to achieve the best network
accuracy.

For AdaBS calibration, we observed that using an optimal value of the momentum is necessary to achieve good inference
accuracy evolution over time. For this, we have developed an algorithm to estimate the optimal value of momentum by an
empirical analysis, which is explained in Supplementary Note 3. Based on this analysis, the formula we used to compute the
optimal momentum as a function of the number of injected mini-batches n is

p = 0.015(1/n).

(8)

Using Eq. (8) to compute the momentum, we found that with a ﬁxed mini-batch size of m = 200 images, it is sufﬁcient to inject
n = 13 mini-batches for the AdaBS calibration of the ResNet-32 network, that is approximately 5% of the CIFAR-10 training set
(2,600 images). The sensitivity of the accuracy to the number of images used for AdaBS calibration is shown in Supplementary
Note 3. For ResNet-34 on ImageNet, we used mini-batch size of m = 50 and n = 26 mini-batches, that is 0.1% of the ImageNet
training set (1,300 images). In the experiments presented in Fig. 5, AdaBS calibration was performed for every layer before
performing inference on the test set, except the last layer because it does not have batch normalization.

ACKNOWLEDGMENTS

We thank O. Hilliges for discussions, and our colleagues at IBM TJ Watson Research Center, in particular M. BrightSky,
for help with fabricating the PCM prototype chip used in this work. This work was partially funded by the European Re-
search Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement number
682675).

This is a pre-print of an article accepted for publication in Nature Communications

15

AUTHOR CONTRIBUTIONS

V.J., M.L., S.H., C.P. and A.S. conceived the training methodology. V.J., M.L., S.H., I.B. and A.S. conceived the drift
correction techniques. V.J. and S.H. performed the software training and inference simulations under the guidance of M.L.. I.B.
performed the PCM hardware experiments with the support of V.J.. S.R.N. and V.J. developed the PCM model. V.J. and C.P.
developed the PCM deep learning inference TensorFlow-based software. M.D. provided critical in-memory computing hardware
insights and performed the ResNet-32 performance estimation. M.L. wrote the manuscript with input from all authors. M.L.,
A.S., B.R. and E.E. supervised the project.

This is a pre-print of an article accepted for publication in Nature Communications

16

REFERENCES

1N. P. Jouppi, C. Young, N. Patil, D. Patterson, G. Agrawal, R. Bajwa, S. Bates, S. Bhatia, N. Boden, A. Borchers, et al., “In-datacenter performance analysis
of a tensor processing unit,” in 2017 ACM/IEEE 44th Annual International Symposium on Computer Architecture (ISCA) (IEEE, 2017) pp. 1–12.
2Z. Jia, M. Maggioni, J. Smith, and D. P. Scarpazza, “Dissecting the NVidia turing T4 GPU via microbenchmarking,” arXiv preprint arXiv:1903.07486 (2019).
3A. Shaﬁee, A. Nag, N. Muralimanohar, R. Balasubramonian, J. P. Strachan, M. Hu, R. S. Williams, and V. Srikumar, “ISAAC: A convolutional neural network
accelerator with in-situ analog arithmetic in crossbars,” in 2016 ACM/IEEE 43rd Annual International Symposium on Computer Architecture (ISCA) (2016)
pp. 14–26.
4F. Merrikh-Bayat, X. Guo, M. Klachko, M. Prezioso, K. K. Likharev, and D. B. Strukov, “High-performance mixed-signal neurocomputing with nanoscale
ﬂoating-gate memory cell arrays,” IEEE Transactions on Neural Networks and Learning Systems 29, 4782–4790 (2018).
5W.-H. Chen, C. Dou, K.-X. Li, W.-Y. Lin, P.-Y. Li, J.-H. Huang, J.-H. Wang, W.-C. Wei, C.-X. Xue, Y.-C. Chiu, et al., “CMOS-integrated memristive
non-volatile computing-in-memory for AI edge processors,” Nature Electronics 2, 420–428 (2019).
6M. Hu, C. E. Graves, C. Li, Y. Li, N. Ge, E. Montgomery, N. Davila, H. Jiang, R. S. Williams, J. J. Yang, et al., “Memristor-based analog computation and
neural network classiﬁcation with a dot product engine,” Advanced Materials 30, 1705914 (2018).
7M. Le Gallo, A. Sebastian, R. Mathis, M. Manica, H. Giefers, T. Tuma, C. Bekas, A. Curioni, and E. Eleftheriou, “Mixed-precision in-memory computing,”
Nature Electronics 1, 246 (2018).
8I. Boybat, M. Le Gallo, S. Nandakumar, T. Moraitis, T. Parnell, T. Tuma, B. Rajendran, Y. Leblebici, A. Sebastian, and E. Eleftheriou, “Neuromorphic
computing with multi-memristive synapses,” Nature communications 9, 2514 (2018).
9S. Ambrogio, P. Narayanan, H. Tsai, R. M. Shelby, I. Boybat, C. Nolfo, S. Sidler, M. Giordano, M. Bodini, N. C. Farinha, et al., “Equivalent-accuracy
accelerated neural-network training using analogue memory,” Nature 558, 60 (2018).

10S. Nandakumar, M. Le Gallo, I. Boybat, B. Rajendran, A. Sebastian, and E. Eleftheriou, “Mixed-precision architecture based on computational memory for

training deep neural networks,” in International Symposium on Circuits and Systems (ISCAS) (IEEE, 2018) pp. 1–5.

11A. Mohanty, X. Du, P.-Y. Chen, J.-s. Seo, S. Yu, and Y. Cao, “Random sparse adaptation for accurate inference with inaccurate multi-level rram arrays,” in

2017 IEEE International Electron Devices Meeting (IEDM) (IEEE, 2017) pp. 6–3.

12S. K. Gonugondla, M. Kang, and N. R. Shanbhag, “A variation-tolerant in-memory machine learning classiﬁer via on-chip training,” IEEE Journal of

Solid-State Circuits 53, 3163–3173 (2018).

13B. Liu, H. Li, Y. Chen, X. Li, Q. Wu, and T. Huang, “Vortex: variation-aware training for memristor x-bar,” in Proceedings of the 52nd Annual Design

Automation Conference (ACM, 2015) p. 15.

14L. Chen, J. Li, Y. Chen, Q. Deng, J. Shen, X. Liang, and L. Jiang, “Accelerator-friendly neural-network training: Learning variations and defects in rram

crossbar,” in Proceedings of the Conference on Design, Automation & Test in Europe (European Design and Automation Association, 2017) pp. 19–24.

15S. Moon, K. Shin, and D. Jeon, “Enhancing reliability of analog neural network processors,” IEEE Transactions on Very Large Scale Integration (VLSI)

Systems 27, 1455–1459 (2019).

16D. Miyashita, S. Kousai, T. Suzuki, and J. Deguchi, “A neuromorphic chip optimized for deep learning and CMOS technology with time-domain analog and

digital mixed-signal processing,” IEEE Journal of Solid-State Circuits 52, 2679–2689 (2017).

17M. Klachko, M. R. Mahmoodi, and D. B. Strukov, “Improving noise tolerance of mixed-signal neural networks,” arXiv preprint arXiv:1904.01705 (2019).
18A. S. Rekhi, B. Zimmer, N. Nedovic, N. Liu, R. Venkatesan, M. Wang, B. Khailany, W. J. Dally, and C. T. Gray, “Analog/mixed-signal hardware error

modeling for deep learning inference,” in Proceedings of the 56th Annual Design Automation Conference (ACM, 2019) pp. 81:1–81:6.

19K. He, X. Zhang, S. Ren, and J. Sun, “Deep residual learning for image recognition,” in Proceedings of the IEEE conference on computer vision and pattern

recognition (2016) pp. 770–778.

20T. Gokmen, M. Onen, and W. Haensch, “Training Deep Convolutional Neural Networks with Resistive Cross-Point Devices,” Frontiers in Neuroscience 11,

1–22 (2017), 1705.08014.

21P. Merolla, R. Appuswamy, J. Arthur, S. K. Esser, and D. Modha, “Deep neural networks are robust to weight binarization and other non-linear distortions,”

arXiv preprint arXiv:1606.01981 (2016).

22C. Blundell, J. Cornebise, K. Kavukcuoglu, and D. Wierstra, “Weight uncertainty in neural networks,” arXiv preprint arXiv:1505.05424 (2015).
23C. Gulcehre, M. Moczulski, M. Denil, and Y. Bengio, “Noisy activation functions,” in International conference on machine learning (2016) pp. 3059–3068.
24A. Neelakantan, L. Vilnis, Q. V. Le, I. Sutskever, L. Kaiser, K. Kurach, and J. Martens, “Adding gradient noise improves learning for very deep networks,”

arXiv preprint arXiv:1511.06807 (2015).

25G. An, “The effects of adding noise during backpropagation training on a generalization performance,” Neural computation 8, 643–674 (1996).
26K. Jim, B. G. Horne, and C. L. Giles, “Effects of noise on convergence and generalization in recurrent networks,” in Proceedings of the 7th International

Conference on Neural Information Processing Systems, NIPS’94 (MIT Press, Cambridge, MA, USA, 1994) pp. 649–656.

27S. Gupta, A. Agrawal, K. Gopalakrishnan, and P. Narayanan, “Deep learning with limited numerical precision,” in Proceedings of the 32nd International

Conference on Machine Learning (ICML-15) (2015) pp. 1737–1746.

28J. L. McKinstry, S. K. Esser, R. Appuswamy, D. Bablani, J. V. Arthur, I. B. Yildiz, and D. S. Modha, “Discovering low-precision networks close to full-

precision networks for efﬁcient embedded inference,” CoRR abs/1809.04191 (2018), arXiv:1809.04191.

29A. F. Murray and P. J. Edwards, “Enhanced MLP performance and fault tolerance resulting from synaptic weight noise during training,” IEEE Transactions

on neural networks 5, 792–802 (1994).

30K. He, X. Zhang, S. Ren, and J. Sun, “Delving deep into rectiﬁers: Surpassing human-level performance on imagenet classiﬁcation,” CoRR abs/1502.01852

(2015), arXiv:1502.01852.

31M. Rastegari, V. Ordonez, J. Redmon, and A. Farhadi, “Xnor-net: Imagenet classiﬁcation using binary convolutional neural networks,” in European Confer-

ence on Computer Vision (Springer, 2016) pp. 525–542.

32G. Close, U. Frey, M. Breitwisch, H. Lung, C. Lam, C. Hagleitner, and E. Eleftheriou, “Device, circuit and system-level analysis of noise in multi-bit

phase-change memory,” in 2010 IEEE International Electron Devices Meeting (IEDM) (IEEE, 2010) pp. 29–5.

33G. W. Burr, M. J. Brightsky, A. Sebastian, H.-Y. Cheng, J.-Y. Wu, S. Kim, N. E. Sosa, N. Papandreou, H.-L. Lung, H. Pozidis, et al., “Recent progress in

phase-change memory technology,” IEEE Journal on Emerging and Selected Topics in Circuits and Systems 6, 146–162 (2016).

34M. Le Gallo, A. Sebastian, G. Cherubini, H. Giefers, and E. Eleftheriou, “Compressed sensing with approximate message passing using in-memory comput-

ing,” IEEE Transactions on Electron Devices 65, 4304–4312 (2018).

35H. Tsai, S. Ambrogio, C. Mackin, P. Narayanan, R. M. Shelby, K. Rocki, A. Chen, and G. W. Burr, “Inference of long-short term memory networks at

software-equivalent accuracy using 2.5m analog phase change memory devices,” in 2019 Symposium on VLSI Technology (2019) pp. T82–T83.

36F. Li, B. Zhang, and B. Liu, “Ternary weight networks,” arXiv preprint arXiv:1605.04711 (2016).

This is a pre-print of an article accepted for publication in Nature Communications

17

37M. Le Gallo, D. Krebs, F. Zipoli, M. Salinga, and A. Sebastian, “Collective structural relaxation in phase-change memory devices,” Advanced Electronic

Materials 4, 1700627 (2018).

38G. Venkatesh, E. Nurvitadhi, and D. Marr, “Accelerating deep convolutional networks using low-precision and sparsity,” in IEEE International Conference

on Acoustics, Speech and Signal Processing (ICASSP) (2017) pp. 2861–2865.

39C. M. Bishop, “Training with noise is equivalent to Tikhonov regularization,” Neural computation 7, 108–116 (1995).
40M. Dazzi, A. Sebastian, P. A. Francese, T. Parnell, L. Benini, and E. Eleftheriou, “5 parallel prism: A topology for pipelined implementations of convolutional

neural networks using computational memory,” arXiv preprint arXiv:1906.03474 (2019).

41E. Sacco, P. A. Francese, M. Brndli, C. Menolﬁ, T. Morf, A. Cevrero, I. Ozkaya, M. Kossel, L. Kull, D. Luu, H. Yueksel, G. Gielen, and T. Toiﬂ, “A 5Gb/s

7.1fJ/b/mm 8x multi-drop on-chip 10mm data link in 14nm FinFET CMOS SOI at 0.5V,” in 2017 Symposium on VLSI Circuits (2017) pp. C54–C55.

42R. Andri, L. Cavigelli, D. Rossi, and L. Benini, “YodaNN: An architecture for ultralow power binary-weight CNN acceleration,” IEEE Transactions on

Computer-Aided Design of Integrated Circuits and Systems 37, 48–60 (2017).

43M. Courbariaux, Y. Bengio, and J.-P. David, “Binaryconnect: Training deep neural networks with binary weights during propagations,” in Advances in Neural

Information Processing Systems (2015) pp. 3123–3131.

44M. Breitwisch, T. Nirschl, C. Chen, Y. Zhu, M. Lee, M. Lamorey, G. Burr, E. Joseph, A. Schrott, J. Philipp, et al., “Novel lithography-independent pore phase

change memory,” in Proc. IEEE Symposium on VLSI Technology (2007) pp. 100–101.

45N. Papandreou, H. Pozidis, A. Pantazi, A. Sebastian, M. Breitwisch, C. Lam, and E. Eleftheriou, “Programming algorithms for multilevel phase-change

memory,” in Proc. International Symposium on Circuits and Systems (ISCAS) (2011) pp. 329–332.

46M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow, A. Harp,
G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur, J. Levenberg, D. Man´e, R. Monga, S. Moore, D. Murray, C. Olah, M. Schuster, J. Shlens,
B. Steiner, I. Sutskever, K. Talwar, P. Tucker, V. Vanhoucke, V. Vasudevan, F. Vi´egas, O. Vinyals, P. Warden, M. Wattenberg, M. Wicke, Y. Yu, and X. Zheng,
“TensorFlow: Large-scale machine learning on heterogeneous systems,” (2015), software available from tensorﬂow.org.

47S. Ioffe and C. Szegedy, “Batch normalization: Accelerating deep network training by reducing internal covariate shift,” CoRR abs/1502.03167 (2015),

arXiv:1502.03167.

48B. Zhou, A. Khosla, `A. Lapedriza, A. Oliva, and A. Torralba, “Learning deep features for discriminative localization,” CoRR abs/1512.04150 (2015),

arXiv:1512.04150.

49A. Krizhevsky, V. Nair, and G. Hinton, “Cifar-10 (canadian institute for advanced research),” .
50T. Devries and G. W. Taylor, “Improved regularization of convolutional neural networks with cutout,” CoRR abs/1708.04552 (2017), arXiv:1708.04552.
51O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, and L. Fei-Fei, “Imagenet large

scale visual recognition challenge,” Int. J. Comput. Vision 115, 211–252 (2015).

52“Torchvision.models,” https://pytorch.org/docs/stable/torchvision/models.html, accessed: 2019-10-24.

