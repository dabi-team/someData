Data Programming using Continuous and Quality-Guided Labeling Functions

Oishik Chatterjee
Department of CSE
IIT Bombay, India

Ganesh Ramakrishnan
Department of CSE
IIT Bombay, India

oishik@cse.iitb.ac.in

ganesh@cse.iitb.ac.in

Sunita Sarawagi
Department of CSE
IIT Bombay, India
sunita@iitb.ac.in

9
1
0
2

v
o
N
2
2

]

G
L
.
s
c
[

1
v
0
6
8
9
0
.
1
1
9
1
:
v
i
X
r
a

Abstract

Scarcity of labeled data is a bottleneck for supervised learn-
ing models. A paradigm that has evolved for dealing with this
problem is data programming. An existing data programming
paradigm allows human supervision to be provided as a set of
discrete labeling functions (LF) that output possibly noisy la-
bels to input instances and a generative model for consolidat-
ing the weak labels. We enhance and generalize this paradigm
by supporting functions that output a continuous score (in-
stead of a hard label) that noisily correlates with labels. We
show across ﬁve applications that continuous LFs are more
natural to program and lead to improved recall. We also show
that accuracy of existing generative models is unstable with
respect to initialization, training epochs, and learning rates.
We give control to the data programmer to guide the training
process by providing intuitive quality guides with each LF.
We propose an elegant method of incorporating these guides
into the generative model. Our overall method, called CAGE,
makes the data programming paradigm more reliable than
other tricks based on initialization, sign-penalties, or soft-
accuracy constraints.

1

Introduction

Modern machine learning systems require large amounts of
labelled data. For many applications, such labelled data is
created by getting humans to explicitly label each training
example. A problem of perpetual interest in machine learn-
ing is reducing the tedium of such human supervision via
techniques like active learning, crowd-labeling, distant su-
pervision, and semi-supervised learning. A limitation of all
these methods is that supervision is restricted to the level of
individual examples.

A recently proposed (Ratner et al. 2016) paradigm is that
of Data Programming. In this paradigm, humans provide
several labeling functions written in any high-level program-
ming language. Each labeling function (LF) takes as input,
an example and either attaches a label to it or backs off. We
illustrate such LFs on one of the ﬁve tasks that we experi-
mented with, viz., that of labeling mention of a pair of peo-
ple names in a sentence as deﬁning the spouse relation or
not. The users construct heuristic patterns as LFs for identi-
fying spouse relation in a sentence containing an entity pair

Copyright c(cid:13) 2020, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

(E1, E2). A LF can assign +1 to indicate that the spouse re-
lation is true for the candidate pair (E1,E2), -1 to mean that
no spouse relation, and 0 to mean that the LF in unable to
assert anything for this example. Speciﬁcally for the spouse
relation extraction task, Table 1 lists six LFs.

In isolation, each LF may neither be always correct nor
complete. LFs may also produce conﬂicting labels. For the
purpose of illustration, consider a text snippet ‘Michelle
Obama is the mother of Malia and Sasha and the wife of
Barack Obama’. For the candidate pair (‘Michelle Obama’,
’Barack Obama’), LF1 and LF4 in Table 1 assign a label 1
whereas LF2 assigns the label -1.

Ratner et al. (2016) presented a generative model for con-
sensus on the noisy and conﬂicting labels assigned by the
discrete LFs to determine probability of the correct labels.
Labels thus obtained could be used for training any super-
vised model/classiﬁer and evaluated on a test set. In this pa-
per, we present two signiﬁcant extensions of the above data
programming paradigm.

First, the user provided set of LFs might not be complete
in their discrete forms. LF1 through LF3 in Table 1 that look
for words in various hand-crafted dictionaries, may have
incomplete dictionaries. A more comprehensive alternative
could be to design continuous valued LFs that return scores
derived from soft match between words in the sentence and
the dictionary. As an example, for LF1 through LF3, the
soft match could be obtained based on cosine similarity of
pre-trained word embedding vectors (Mikolov et al. 2013)
of a word in the dictionary with a word in the sentence. This
could enable an LF to provide a continuous class-speciﬁc
score to the model, instead of a hard class label (when
triggered). In Table 2, we list a continuous LF corre-
sponding to each LF from Table 1. Such continuous LFs
can expand the scope of matching to semantically similar
words beyond the pre-speciﬁed words in the dictionary. For
example: in the sentence 1) <Allison>, 27, and
<Ricky>, 34, wed on Saturday surrounded
by friends., the word ’wed’ is semantically similar to
’married’ and would be detected by our continuous LF but
missed by the discrete ones in Table 1.

More generally across applications, human experts are
very often able to identify real-valued scores that correlate
strongly with the label but ﬁnd it difﬁcult to discretize that
score into a hard label. More examples of such scores in-

 
 
 
 
 
 
SpouseDict = {’spouse’, ’married’, wife’, ’husband’, ’ex-wife’, ’ex-husband’}
FamilyDict = {’father’, ’mother’, ’sister’, ’brother’, ’son’, ’daughter’,’grandfather’, ’grandmother’, ’uncle’, ’aunt’,’cousin’ }(cid:78){+”,+’-in-law’}
OtherDict = {’boyfriend’, ’girlfriend’ ’boss’, ’employee’, ’secretary’, ’co-worker’}
SeedSet = {(’Barack Obama’, ’Michelle Obama ’), (’Jon Bon Jovi’,’Dorothea Hurley’),(’Ron Howard’,’Cheryl Howard’),.....}
Id
LF1
LF2
LF3
LF4
LF5

Description
If some word in SpouseDict is present between E1 and E2 or within 2 words of either, return 1 else return 0
If some word in FamilyDict is present between E1 and E2, return -1 else return 0.
If some word in OtherDict is present between E1 and E2, return -1 else return 0.
If both E1 and E2 occur in SeedSet, return 1 else return 0.
If the number of word tokens lying between E1 and E2 are less than 4, return 1 else return 0.

Table 1: Discrete LFs based on dictionary lookups or thresholded distance for the spouse relationship extraction task

Id
LF1
LF2
LF3
LF4
LF5

Class Description
+1
-1
-1
-1
+1

max [cosine(word-vector(u), word-vector(v))-0.8]+: u ∈ SpouseDict and v ∈ {words between E1, E2}.
max [cosine(word-vector(u), word-vector(v))-0.8]+: u ∈ FamilyDict and v ∈ {words between E1, E2}.
max [cosine(word-vector(u), word-vector(v))-0.8]+: u ∈ OtherDict and v ∈ {words between E1, E2}.
max [0.2 - Norm-Edit-Dist(E1, E2, u, v)]+: (u, v), (v, u) ∈ SeedSet.
[1 - (number of word tokens between E1 and E2)/5.0]+

Table 2: Continuous LFs corresponding to some of the discrete LFs in Table 1 for the spouse relationship extraction task

clude TF-IDF match with prototypical documents in a text-
classiﬁcation task, distance among entity pairs for a relation
extraction task, and conﬁdence scores from hand-crafted
classiﬁers.

We extend existing generative models (Ratner et al. 2016;
Bach et al. 2017) to support continuous LFs. In addition to
modeling the consensus distribution over all LFs (continu-
ous and discrete), we model the distribution of scores for
each continuous LF. In Section 4 in the supplementary ma-
terial, we illustrate through an example, why the model for
continuous LFs is not a straightforward extension of the dis-
crete counterpart.

Our second extension is designed to remove the instability
of existing generative training based on unsupervised like-
lihood. Across several datasets we observed that the accu-
racy obtained by the existing models was highly sensitive to
initialization, training epochs, and learning rates. In the ab-
sence of labeled validation set, we cannot depend on preva-
lent tricks like early stopping to stabilize training. We give
control to the data programmer to guide the training process
by providing intuitive accuracy guides with each LF. In the
case that the labeler develops each LF after inspecting some
examples, the labeler would naturally have a rough estimate
of the fraction q of examples that would be correctly labeled
by the LF, amongst all examples that trigger the LF. Even
otherwise, it might not be too difﬁcult for the labeler to in-
tuitively specify some value of q. We show that such a q
serves as a user-controlled quality guide that can effectively
guide the training process. For the case of continuous LFs,
we use q as a rough estimate of the mean score of the con-
tinuous LF whenever it triggers correctly. A quality guide
of q = 0.9 for LF1 would imply that when LF1 triggers
correctly the average embedding score is 0.9. This is easier
than choosing a hard threshold on the embedding score to
convert it to a discrete LF. We provide an elegant method of
guiding our generative training with these user-provided ac-
curacy estimates, and show how it surpasses simpler meth-

ods like sign penalty and data constraints. Empirically, we
show our method stabilizes unsupervised likelihood training
even with very crude estimates of q. We study stability issues
of the existing model with respect to training epochs and
demonstrate that the proposed model is naturally more sta-
ble. We refer to our overall approach as CAGE, which stands
for Continuous And quality Guided lab Eling functions.
In summary, CAGE makes the following contributions:
1) It enhances the expression power of data programming by
supporting continuous labeling functions (generalizations of
discrete LFs) as the unit of supervision from humans.
2) It proposes a carefully parameterized graphical model that
outperforms existing models even for discrete LFs, and per-
mits easy incorporation of user priors for continuous LFs.
3) It extends the generative model through quality guides,
thereby increasing its stability and making it less sensitive
to initialization. Its training is based on a principled method
of regularizing the marginals of the joint model with user-
provided accuracy guides.
We present extensive experiments on ﬁve datasets, com-
paring various models for performance and stability, and
present the signiﬁcantly positive impact of CAGE . We show
that our method of incorporating user guides leads to more
reliable training than obvious ideas like sign penalty and
constraint based training.

2 Our Approach: CAGE

Let X denote the space of input
instances and Y =
{1, . . . , K} denote the space of labels and P (X , Y) denote
their joint distribution. Our goal is to learn a model to asso-
ciate a label y with an example x ∈ X . Unlike standard su-
pervised learning, we are not provided true labels of sampled
instances during training. Let the sample of m unlabeled in-
stances be x1, . . . , xm. Instead of the true y’s we are pro-
vided a set of n labeling functions (LFs) λ1, λ2, . . . λn such
that each LF λj can be either discrete or continuous. Each
LF λj is attached with a class kj and on an instance xi out-

puts a discrete label τij = kj when triggered and τij = 0
when not triggered. If λj is continuous, it also outputs a
score sij ∈ (0, 1). This is a form of weak supervision that
implies that when a LF is triggered on an instance xi, it is
proposing that the true label y should be kj, and if contin-
uous it is attaching a conﬁdence proportional to sij with its
labeling.

But to reliably and accurately infer the true label y from
such weak supervision without any labeled data, we need to
exploit the assumption that τij is positively correlated with
y. We allow the programmer of the LF to make this assump-
tion explicit by attaching a guess on the fraction qt
j of trig-
gering of the LF where the true y agrees with τij. We show
in the experiments that crude guesses sufﬁce. Intuitively, this
says that the user expects qt
j fraction of examples for which
the LF value has been triggered to be correct. Additionally,
for continuous LF the programmer can specify the quality
index qc
j denoting the average score of sj when there is such
agreement.

Our goal is to learn to infer the correct label by creating
consensus among outputs of the LFs. Thus, the model of
CAGE imposes a joint distribution between the true label y
and the values τij, sij returned by each LF λj on any data
sample xi drawn from the hidden distribution P (X , Y).

Pθ,π(y, τi, si) =

1
Zθ

n
(cid:89)

j=1

ψθ(τij, y) (ψπ(τij, sij, y))cont(λj )

(1)
where cont(λj) is 1 when λj is a continuous LF and 0 oth-
erwise. And θ, π denote the parameters used in deﬁning the
potentials psiθ, ψπ coupling discrete and continuous vari-
ables respectively. In this factorization of the joint distribu-
tion we make the natural assumption that each LF indepen-
dently provides its supervision on the true label. The main
challenge now is designing the potentials coupling various
random variables so that: (a) The parameters (θ, π) can be
trained reliably using unlabeled data alone. This partially
implies that the number of parameters should be limited. (b)
The model should be expressive enough to ﬁt the joint distri-
bution on the τj and sj variables across a variety of datasets
without relying on labeled validation dataset for model se-
lection and hyper-parameter tuning. (c) Finally, the poten-
tials should reﬂect the bias of the programmer on the qual-
ity in providing the true y. We will show how without such
control, it is easy to construct counter-examples where the
standard likelihood-based training may fail miserably.

With these goals in mind, and after signiﬁcant exploration
we propose the following form of potentials. For the discrete
binary τij variables, we chose these simple potentials:

ψθ(τij, y) =

(cid:26)exp(θjy)

1

if τij (cid:54)= 0,
otherwise.

(2)

Thus, for each LF we have K parameters corresponding to
each of the class labels. An even simpler alternative would
be to share the θjy across different ys as used in (Bach et
al. 2017) but that approach imposes undesirable restrictions
on the distributions it can express. We elaborate on that in
Section 2.3.

For the case of continuous LFs the task of designing
the potential ψπ(sij, τij, y) that is trainable with unlabeled
data and captures user bias well turned out to be signiﬁ-
cantly harder. Speciﬁcally, we wanted a form that is suited
for scores that can be interpreted as conﬁdence probabili-
ties (that lie between 0 and 1), and capture the bias that
sij is high when τij and y agree, and low otherwise. For
conﬁdence variables, a natural parametric form of density
is the beta density. The beta density is popularly expressed
in terms of two independent parameters α > 0 and β > 0
as P (s|α, β) ∝ sα−1(1 − s)β−1. Instead of independently
learning these parameters, we chose an alternative represen-
tation that allows expression of user prior on the expected
s. We write the beta in terms of two alternative parameters:
the mean parameter qc
j and the scale parameter π1. These are
related to α and β as α = qc

j π1 and β = (1 − qc

j )π1.

We deﬁne our continuous potential as:

ψπ(τij, sij, y) =




Beta(sij; αa, βa)
Beta(sij; αd, βd)

1

if kj = y & τij (cid:54)= 0,
if kj (cid:54)= y & τij (cid:54)= 0,
otherwise

j πjy and βa = (1 − qc

(3)
where αa = qc
j )πjy are parameters
of the agreement distribution and αd = (1 − qc
j )πjy and
βd = qc
j πjy are parameters of the disagreement distribu-
tion, where πjy is constrained to be strictly positive. To im-
pose πjy > 0 while also maintaining differentiability, we
reparametrize πjy as exp(ρjy). Thus, we require K param-
eters for each continuous LF, which is the same as for a dis-
crete LF. The Beta distribution would normally require 2K
parameters but we used the user provided qualify guide in
that special manner shown above to share the mean between
the agreeing and disagreeing Beta.

We experimented with a large variety of other potential
forms before converging on the above. We will elaborate on
alternatives in the experimental section.

With these potentials, the normalizer Zθ of our joint dis-

tribution (Eqn 1) can be calculated as

(cid:88)

(cid:89)

(cid:88)

Zθ =

ψθ(τj, y)

τj ∈{kj ,0}

y
(cid:88)

=

j
(cid:89)

(1 + exp(θjy))

(cid:90) 1

sj =0

ψπ(τj, sj, y)

(4)

y∈Y

j

The normalizer reveals two further facets of our joint dis-
tribution. First our continuous potentials are deﬁned such
that when summed over sj-s we get a value of 1, hence
the normalizer is independent of the continuous parameters
π. That is, the continuous potentials ψπ(τij, sij, y) are lo-
cally normalized Bayesian probabilities P (sij|τij, y). Sec-
ond, the discrete potentials are not locally normalized; the
ψθ(τj, y) cannot be interpreted as Pr(τj|y) because by nor-
malizing them globally we were able to learn the interac-
tion among the LFs better. We will show empirically that ei-
ther the full Bayesian model with potentials P (y), P (τij|y),
and P (sij|τij, y) or the fully undirected model where the
ψπ(τij, sij, y) potential is un-normalized are both harder to
train.

2.1 Training CAGE
Our training objective can be expressed as:

max
θ,π

LL(θ, π|D) + R(θ, π|{qt

j})

(5)

The ﬁrst part maximizes the likelihood on the observed τi
and si values of the training sample D = x1, . . . , xm after
marginalizing out the true y. It can be expressed as:

m
(cid:88)

i=1

n
(cid:89)

log

(cid:88)

y∈Y

Pθ,π(τi, si, y)

(6)

ψj(τij, y) (ψj(sij, τij, y))cont(λj ) − m log Zθ

LL(θ, π|D) =

=

m
(cid:88)

i=1

(cid:88)

log

y∈Y

j=1

By CAGE−G, we will hereafter refer to the model in Eqn 1
that has parameters learnt by maximizing only this (ﬁrst)
likelihood part of the objective in Eqn 6 and not the sec-
ond part R(θ, π|{qt
j}) is a regularizer that
guides the parameters with the programmer’s expectation of
the quality of each LF. We start by motivating the need for
the regularizer by showing simple cases that can cause the
likelihood-only training to yield poor accuracy.

j}). R(θ, π|{qt

Example 1: Sensitivity to Initialization Consider a bi-
nary classiﬁcation task where the n LFs are perfect oracles
that trigger only on instances whose true label matches kj.
Assume all λj are discrete. The likelihood of such data can
be expressed as:

m
(cid:88)

LL(θ) =

log(exp(

(cid:88)

θj1) + exp(

(cid:88)

θj2))

i=1
(cid:89)

j:kj =y

j:kj =y

− m log(

(1 + exp(θj1)) +

(cid:89)

(1 + exp(θj2)))

(7)

j

j

The value of the above likelihood is totally symmetric in θj1
and θj2 but the accuracy is not. We will get 100% accuracy
only when the parameter for the agreeing case: θjkj is larger
than θjy for y (cid:54)= kj, and 0% accuracy if θjkj is smaller.
A trick is to initialize the θ parameters carefully so that the
agreeing parameters θjkj do have larger values. However,
even such careful initialization can be forgotten in less trivial
cases as we show in the next example.

Example 2: Failure in spite of good initialization Con-
sider a set S1 of r LFs that assign a label of 1 and remain-
ing set S2 of n − r LFs that assign label 2. Let each true
class-2 instance trigger one or more LF from S1 and one
or more LF from S2. Let each true class-1 instance trigger
only LFs from S1. When we initialize LFs in set S1 such
that θj1 − θj2 > 0 and LFs in set S2 have θj2 − θj1 > 0,
we can get good accuracy. However, as training progresses
the likelihood will be globally maximized when both sets of
LFs favor the same class on all instances. If we further as-
sume that the true class distribution is skewed, the LL(θ) ob-
jective quickly converges to this useless maxima. This sce-
nario is not artiﬁcial. Many of the real datasets (e.g. the LFs





of Spouse relation extraction data in Table 1) exhibit such
trends.

A straight-forward ﬁx of the above problem is to impose
a penalty on the sign of θjkj − θjy. However, since the θs
of LFs interact via the global normalizer Zθ this condition
is neither necessary nor sufﬁcient to ensure that in the joint
model Pθ(y, τ ) the values of y and kj agree more than dis-
agree. For globally conditioned models the parameters can-
not be easily interpreted, and we need to constrain at the
level of the joint distribution.

One method to work with the whole distribution is to con-
strain the conditional Pθ(y|τi) over the instances where the
LF triggers and constrain that the accumulated probability
of the agreeing y is at least qt

j as follows:



R(θ|{qt

j}, D) =

(cid:88)

j

softplus



(cid:88)

i:τij =kj

(qt

j − Pθ(τi, kj))

(8)
We call this the data-driven constrained training method and
refer to it as CAGEdataG. However, a limitation of this con-
straint is that in a mini-batch training environment it is difﬁ-
cult to get enough examples per batch for reliable estimation
of the empirical accuracy, particularly for LFs that trigger in-
frequently. Next we present our method of incorporating the
user guidance into the trained model to avoid such instabil-
ity.

2.2 Data-independent quality guides in CAGE
Our ﬁnal approach that worked reliably was to regularize
the parameters so that the learned joint distribution of y and
τj matches the user-provided quality guides qt
j over all y, τj
values from the joint distribution Pθ,π. By default, this is the
regularizer that we employ in CAGE.

The qt

Pθ(y = kj|τj = kj) =

j guide is the user’s belief on the fraction of cases
where y and τj agree when τj (cid:54)= 0 (LF λj triggers). Using
the joint distribution we can calculate this agreement proba-
bility as Pθ(y = kj|τj = kj). This probability can be com-
puted in closed form by marginalizing over all remaining
variables in the model in Equation 1 as follows:
Pθ(y = kj, τj = kj)
Pθ(τj = kj)
Mj(kj) (cid:81)
y∈Y Mj(y) (cid:81)

r(cid:54)=j(1 + Mr(y))
where Mj(y) = exp(θjy). We then seek to minimize the
KL distance between the user provided qt
j and the model
calculated precision Pθ(y = kj|τj = kj) which turns out to
be:

r(cid:54)=j(1 + Mr(kj))

(cid:80)

=

R(θ|{qt

j}) =

qt
j log Pθ(y = kj|τj = kj)

(cid:88)

j

(9)

+(1 − qt

j) log(1 − Pθ(y = kj|τj = kj))

Speciﬁcally, when the CAGE model is restricted only to
discrete LFs while also incorporating the quality guide in
Eqn 9 into the objective in Eqn 6, we refer to the ap-
proach as CAGE−C. Further, when the quality guide in
Eqn 9 is dropped from CAGE−C, we refer to the approach
as CAGE−C−G.

2.3 Relationship of CAGE with existing models
We would like to point out that the following two simpliﬁca-
tions in CAGE lead to existing well known models (Ratner
et al. 2016; Ratner et al. 2017), viz., (i) Coupling the θyj pa-
rameters, (ii) Ignoring quality guides, and (iii) Not including
continuous potentials. The design used in (Bach et al. 2017)
is to assign a single parameter θj for each LF and share it
across y as:

ψsnorkel
j

(τij, y) =




exp(θj)
exp(−θj)

1

if τij (cid:54)= 0, y = kj,
if τij (cid:54)= 0, y (cid:54)= kj,
otherwise.

(10)

After ignoring quality guides and continuous LF, we note
that a choice of θj,+1 = −θj,−1 makes CAGE exactly same
as the model in Snorkel. However, we found the Snorkel’s
method of parameter sharing incorporates an unnecessary
bias that Pθ(τij = 0|y = kj) = 1 − Pθ(τij = 0|y (cid:54)= kj).
Also, Snorkel’s pure likelihood-based training is subject to
all the sensitivity to parameter initialization and training
epochs that we highlighted in Section 2.1. We show in the
experiments how each of the three new extensions in CAGE
is crucial to getting reliable training with the data program-
ming paradigm.

3 Empirical Evaluation
In this section we (1) evaluate the utility of continuous LFs
vis-a-vis discrete LFs, (2) demonstrate the role of the quality
guides for the stability of the unsupervised likelihood train-
ing of CAGE as well as Snorkel, and (3) perform a detailed
ablation study to justify various design elements of our gen-
erative model and its guided training procedure.

3.1 Datasets and Experiment Setup
We perform these comparisons on ﬁve different datasets.
Spouse: (spo ) This is a relation extraction dataset that pro-
poses to label candidate pairs of entities in a sentence as ex-
pressing a ‘spouse’ relation or not. Our train-dev-test splits
and set of discrete LFs shown in Table 1 are the same as
in (Ratner et al. 2016) where it was ﬁrst used. For each
discrete LF that checks for matches in a dictionary D of
keywords we create a continuous LF that returns sj as the
maximum of cosine similarity of their word embeddings as
shown in Table 2. We used pre-trained vectors provided by
Glove (Pennington, Socher, and Manning 2014).
SMS spam (sms ) is a binary spam/no-spam classiﬁcation
dataset with 5574 documents split into 3700 unlabeled-train
and 1872 labeled-test instances. Nine LFs are created based
on (i) presence of three categories of words which are highly
likely to indicate spam (ii) presence of 2 categories of trigger
words in certain contexts, (iii) reference to keywords indica-
tive of ﬁrst/second or third person, (iv) text characteristics
such as number of capitalized characters, presence of spe-
cial characters, etc. and ﬁnally a LF that is (v) associated
with the negative class, always triggers and serves as the
class prior. The LFs are explained in the supplementary in
Section 6. The continuous LFs are created in the same way
as in Spouse based on word-embedding similarity, number
of capitalized characters, etc.

CDR: (cdr 2018) This is also a relation extraction dataset
where the task is to detect whether or not a sentence ex-
presses a ‘chemical cures disease’ relation. The train-dev-
test splits and LFs are the same as in (Ratner et al. 2016).
We did not develop any continuous LF for CDR.

Dedup: This datasetPublicly available at https://www.cse.
iitb.ac.in/∼sunita/alias/ comprises of 32 thousand pairs of
noisy citation records with ﬁelds like Title, Author, Year
etc. The task is to detect if the record pairs are dupli-
cates. We have 18 continuous LFs corresponding to vari-
ous text similarity functions (such as Jaccard, TF-IDF sim-
ilarity, 1-EditDistance, etc.) computed over one or more of
these ﬁelds. Each of these LFs is positively correlated with
the duplicate label; we create another 18 with the score
as 1-similarity for the negative class. The dataset is highly
skewed with only 0.5% of the instances as duplicate. All
LFs here are continuous.

Iris: Iris is a UCI dataset with 3 classes. We split it into 105
unlabeled train and 45 labeled test examples. We create LFs
from the 4 features of the data as follows: For each feature
f and class y, we calculate f ’s mean value f y amongst the
examples of y from labeled data and create a LF that returns
the value 1 − norm(f − f y) - where norm(f − f y) is the
normalized distance from this mean. This gives us a total of
4 × 3 = 12 continuous LFs. Each such LF has a correspond-
ing discrete LF that is triggered if the feature is closest to the
mean of its corresponding class.

Ionosphere: This is another 2-class UCI dataset, that is split
to 245 unlabeled train and 106 labeled test instances. 64 con-
tinuous LFs are created in a manner similar to Iris.

Training Setup For each dataset and discrete LF we arbi-
trarily assigned a default discrete quality guide qt
j = 0.9 and
for continuous LFs qc
j = 0.85. We used learning rate of 0.01
and 100 training epochs. Parameters were initialized favor-
ably — so for the agreeing parameter initial θjkj =1 and for
disagreeing parameter initial θky = −1, y (cid:54)= kj. For Snorkel
this is equivalent to θj = 1. Only for CAGE that is trained
with guides we initialize all parameters to 1. We show in
Section 5 that CAGE is insensitive to initialization whereas
others are not.

Evaluation Metric We report F1 as our accuracy measure
on all binary datasets and for the multi-class dataset Iris we
measure micro F1 across the classes. From our generative
model, as well as Snorkel, the predicted label on a test in-
stance xi is the y for which the joint generative probability
is highest, that is: argmaxyP (y, τi, si). Another measure of
interest is the accuracy that would be obtained by training a
standard discriminative classiﬁer Pw(y|x) with labeled data
as the probabilistically labeled P (y|xi) ∝ P (y, τi, si) ex-
amples xi from the generative model. In the ﬁrst part of the
experiment we measure the accuracy of labeled data pro-
duced by the generative model. In Section 9 in the Supple-
mentary, we present accuracy from a trained discriminative
model from such dataset. We implemented our model in Py-
torch.1

Spouse CDR SMS

Majority
Snorkel
CAGE−C−G
CAGE−C
CAGE

0.17
0.41
0.48
0.50
0.58

0.53
0.66
0.69
0.69
0.69

Ion
0.23 0.79 0.84
0.34 0.70 0.87
0.34 0.81 0.87
0.45 0.82 0.87
0.54 0.97 0.87

Iris Dedup
-
-
-
-
0.79

Table 3: Overall Results (F1) with predictions from various
generative models contrasted with the Majority baseline.

3.2 Overall Results
In Table 3, we compare the performance of CAGE in terms
of F1, against the following alternatives: (i) Majority: This
is a simple baseline, wherein, the label on which a major-
ity of the LFs show agreement is the inferred consensus la-
bel. (ii) Snorkel: See Section 2.3. (iii) CAGE−C−G: Our
model without continuous LFs and quality guides (See Sec-
tion 2.2). (iv) CAGE−C: Our model with quality guides but
without continuous LFs (See Section 2.2).

From this table we make three important observations: (1)
Comparing Snorkel with CAGE−C−G that differs only in de-
coupling Snorkel’s shared θj parameters, we observe that
the shared parameters of Snorkel were indeed introducing
undesirable bias. (2) Comparing CAGE−C−G and CAGE−C
we see the gains due to our quality guides. (3) Finally, com-
paring CAGE−C and CAGE we see the gains because of the
greater expressibility of continuous LFs. These LFs required
negligible additional human programming effort beyond the
discrete LFs. Compared to Snorkel our model provides sig-
niﬁcant overall gains in F1. For datasets like Dedup which
consist only of continuous scores, CAGE is the only option.
We next present a more detailed ablation study to tease

out the importance of different design elements of CAGE.

3.3 Role of the Quality Guides
We motivate the role of the quality guides in Figure 1
where we show test F1 for increasing training epochs on
three datasets. In these plots we considered only discrete
LFs. We compare Snorkel and our model with (CAGE−C)
and without (CAGE−C−G) these guides. Without the qual-
ity guides, all datasets exhibit unpredictable swings in test
F1. These swings cannot be attributed to over-ﬁtting since
in Spouse and SMS F1 improves later in training with our
quality guides. Since we do not have labeled validation data
to choose the correct number of epochs, the quality guides
are invaluable in getting reliable accuracy in unsupervised
learning.

Next, we show that the stability provided by the quality
guides (qt
j) is robust to large deviations from the true accu-
racy of a LF. Our default qt
j value was 0.9 for all LFs irre-
spective of their true accuracy. We repeated our experiments
with a precision of 0.8 and got the same accuracy across
training epochs (Figure 4 in Supplementary). We next ask if
knowing the true accuracy of a LF would help even more
and how robust our training is to distortion in the user’s
guess from the true accuracy. We calculated true accuracy

1Code available at https://github.com/oishik75/CAGE.

of each LF on the devset and distorted this by a Gaussian
noise with variance σ. In Figure 2 we present accuracy after
100 epochs on two datasets with increasing distortion (σ).
On CDR CAGE’s accuracy is very robust to distorted qt
j but
guides are important as we see from Figure 1(c). On Spouse
accuracy is highest with perfect values of qt
j (Sigma=0) but
it stays close to this accuracy up to a distortion of 0.4.
Sensitivity to Initialization: We carefully initialized param-
eters of all models except CAGE . With random initialization
all models without guides (Snorkel and CAGE−G) provide
very poor accuracy. Exact numbers are in the supplementary
material (c.f. Figure 3).

CAGE−C−G+−P
CAGE−C−G
CAGE-C,dataG
CAGE−C

Spouse CDR Sms
0.34
0.69
0.48
0.34
0.69
0.48
0.34
0.69
0.48
0.45
0.69
0.50

Ion
0.81
0.81
0.81
0.82

Table 4: Comparing different methods of incorporating
user’s quality guide on discrete LFs.

Method of Enforcing Quality Guides
In Table 4, we
compare F1 for the following choices: (i) CAGE−C−G+−P:
Our model with the objective in Eqn (6) augmented with the
sign penalty max(0, θjy(cid:54)=kj − θjkj ) instead of the regular-
izer in Eqn (9). (ii) CAGE−C−G: Our model without guides
(iii) CAGE-C,dataG: The data-driven method of incorporating
quality guides (See Section 2.1), and (iv) CAGE−C: our data
independent regularizer of the model’s marginals with qt
j
(Eqn 9). From Table 4 we observe that CAGE−C is the only
one that provides reliable gains. Thus, it is not just enough to
get quality guides from users, we need to also design sound
methods of combining them in likelihood training.

3.4 Structure of the Potentials
In deﬁning the joint distribution Pθ,π(y, τi, si) (Eq 1) we
used undirected globally normalized potentials for the dis-
crete LFs(Eqn 2). We compare with an alternative where
our joint is a pure directed Bayesian network with po-
tentials P r(τj|y) = exp(θjy/(1 + exp(θjy) on each
discrete LF and a class prior Pr(y). We observe that
the undirected model
is better able to capture interac-
tion among the LFs with the global normalization Zθ.

Directed
CAGE

Spouse CDR Sms
0.59
0.49
0.15
0.54
0.69
0.58

Ion
0.86
0.97

Iris
0.89
0.87

We repeated other ablation experiments where the contin-
uous potentials are undirected and take various forms. The
results appear in the Supplementary in Sect 7 and show that
local normalization is crucially important for modeling sj of
continuous LFs.

Related Work
Several consensus-based prediction combination algo-
rithms (Gao et al. 2009; Kulkarni et al. 2018) exist that

(a) Spouse

(b) SMS

(c) CDR

Figure 1: F1 with increasing number of training epochs compared across snorkel, CAGE−C−Gand CAGE−C, for three datasets.
For each dataset, in the absence of guides, we observe unpredictable variation in test F1 as training progresses.

(b) evaluate them in the absence of absolute gold standard;
(c) estimate reliability of labelers. (Donmez and Carbonell
2008) propose a proactive learning method that jointly se-
lects the optimal labeler and instance with a decision theo-
retic approach. Some recent literature has also studied the
augmenting neural networks with rules in ﬁrst order logic
to either guide the individual layers (Li and Srikumar 2019)
or train model weights within constraints of the rule based
system using a student and teacher model (Hu et al. 2016)

Snorkel (Ratner et al. 2016; Bach et al. 2017; Ratner et
al. 2017; Hancock et al. 2018; Varma et al. 2019) relies
on domain experts manually developing heuristic and noisy
LFs. Similar methods that rely on imperfect sources of la-
bels are (Bunescu and Mooney 2007; Hearst 1992) relying
on heuristics,
(Mintz et al. 2009) on distant supervision
and (Jawanpuria, Nath, and Ramakrishnan 2015) on learn-
ing conjunctions discrete of (discrete) rules. The aforemen-
tioned literature focuses exclusively on labeling suggestions
that are discrete. We present a generalized generative model
to aggregate heuristic labels from continuous (and discrete)
LFs while also incorporating user accuracy priors.

Conclusion We presented a data programming paradigm
that lets the user specify labeling functions which when trig-
gered on instances can also produce continuous scores. The
unsupervised task of consolidating weak labels is inherently
unstable and sensitive to parameter initialization and train-
ing epochs. Instead of depending on un-interpretable hyper-
parameters which can only be tuned with labeled validation
data which we assume is unavailable, we let the user guide
the training with interpretable quality guesses. We carefully
designed the potentials and the training process to give the
user more interpretable control.

Acknowledgements This research was partly sponsored
by a Google India AI/ML Research Award and partly spon-
sored by IBM Research, India (speciﬁcally the IBM AI
Horizon Networks - IIT Bombay initiative).

Figure 2: F1 with increasing distortion in the guess of the LF
quality guide, qt
j.

combine multiple model predictions to counteract the ef-
fects of data quality and model bias. There also exist label
embedding approaches from the extreme classiﬁcation lit-
erature (Yeh et al. 2017) that exploit inter-label correlation.
While these approaches assume that the imperfect labeler’s
knowledge is ﬁxed, (Fang et al. 2012) present a self-taught
active learning paradigm, where a crowd of imperfect label-
ers learn complementary knowledge from each other. How-
ever, they use instance-wise reliability of labelers to query
only the most reliable labeler without any notion of consen-
sus. A recent work by (Chang, Amershi, and Kamar 2017)
presents a collaborative crowd sourcing approach. However,
they are motivated by the problem of eliminating the burden
of deﬁning labeling guidelines a priori and their approach
harnesses the labeling disagreements to identify ambiguous
concepts and create semantically rich structures for post-hoc
label decisions.

There is work in the crowd-labeling literature that makes
use of many imperfect labelers (Kulkarni et al. 2018; Raykar
et al. 2010; Yan et al. 2011; Dekel and Shamir 2009) and
accounts for both labeler and model uncertainty to propose
probabilistic solutions to (a) adapt conventional supervised
learning algorithms to learn from multiple subjective labels;

020406080100Epochs0.420.440.460.480.50F1_scoreF1_snorkelF1_CAGECGF1_CAGEC020406080100Epochs0.340.360.380.400.420.44F1_scoreF1_snorkelF1_CAGECGF1_CAGEC020406080100Epochs0.5500.5750.6000.6250.6500.6750.700F1_scoreF1_snorkelF1_CAGECGF1_CAGEC0.00.20.40.60.8Sigma0.500.550.600.650.70F1_scoreF1_spouseF1_cdrReferences

[Bach et al. 2017] Bach, S. H.; He, B. D.; Ratner, A.; and
R´e, C. 2017. Learning the structure of generative models
In Proceedings of the 34th Interna-
without labeled data.
tional Conference on Machine Learning, ICML 2017, Syd-
ney, NSW, Australia, 6-11 August 2017, 273–282.
[Bunescu and Mooney 2007] Bunescu, R. C., and Mooney,
R. J. 2007. Learning to extract relations from the web us-
ing minimal supervision. In ACL 2007, Proceedings of the
45th Annual Meeting of the Association for Computational
Linguistics, June 23-30, 2007, Prague, Czech Republic.
[cdr 2018] 2018. Chemical - Disease Relation Extraction
Task. https://github.com/HazyResearch/snorkel/tree/master/
tutorials/cdr. [Online; accessed 31-March-2018].
[Chang, Amershi, and Kamar 2017] Chang, J. C.; Amershi,
S.; and Kamar, E. 2017. Revolt: Collaborative crowdsourc-
ing for labeling machine learning datasets. In Proceedings
of the Conference on Human Factors in Computing Systems
(CHI), Denver, CO, USA, 2334–2346.
[Dekel and Shamir 2009] Dekel, O., and Shamir, O. 2009.
In Proceedings of the
Good learners for evil teachers.
26th Annual International Conference on Machine Learn-
ing (ICML), Montreal, Qubec, Canada, 233–240.
[Donmez and Carbonell 2008] Donmez, P., and Carbonell,
J. G. 2008. Proactive learning: cost-sensitive active learning
with multiple imperfect oracles. In Proceedings of the 17th
ACM Conference on Information and Knowledge Manage-
ment (CIKM), Napa Valley, California, USA, 619–628.
[Fang et al. 2012] Fang, M.; Zhu, X.; Li, B.; Ding, W.; and
Wu, X. 2012. Self-taught active learning from crowds.
In 12th IEEE International Conference on Data Mining
(ICDM), Brussels, Belgium, 858–863.
[Gao et al. 2009] Gao, J.; Liang, F.; Fan, W.; Sun, Y.; and
Han, J. 2009. Graph-based consensus maximization among
multiple supervised and unsupervised models. In 23rd An-
nual Conference on Neural Information Processing Systems
(NIPS), Vancouver, Canada, 585–593.
[Hancock et al. 2018] Hancock, B.; Varma, P.; Wang, S.;
Bringmann, M.; Liang, P.; and R´e, C. 2018. Training clas-
siﬁers with natural language explanations. In Proceedings
of the 56th Annual Meeting of the Association for Computa-
tional Linguistics (ACL), Melbourne, Australia, 1884–1895.
[Hearst 1992] Hearst, M. A. 1992. Automatic acquisition
In 14th Interna-
of hyponyms from large text corpora.
tional Conference on Computational Linguistics, COLING,
Nantes, France, 539–545.
[Hu et al. 2016] Hu, Z.; Ma, X.; Liu, Z.; Hovy, E. H.; and
Xing, E. P. 2016. Harnessing deep neural networks with
logic rules. In Proceedings of the 54th Annual Meeting of the
Association for Computational Linguistics (ACL), Berlin,
Germany.
[Jawanpuria, Nath, and Ramakrishnan 2015] Jawanpuria, P.;
Nath, J. S.; and Ramakrishnan, G. 2015. Generalized hier-
archical kernel learning. Journal of Machine Learning Re-
search 16:617–652.

[Kulkarni et al. 2018] Kulkarni, A.; Uppalapati, N. R.;
Singh, P.; and Ramakrishnan, G.
2018. An interactive
multi-label consensus labeling model for multiple labeler
In Proceedings of the Thirty-Second AAAI
judgments.
Conference on Artiﬁcial Intelligence, (AAAI), New Orleans,
Louisiana, USA, 1479–1486.
[Li and Srikumar 2019] Li, T., and Srikumar, V. 2019. Aug-
menting neural networks with ﬁrst-order logic. In Proceed-
ings of the 57th Conference of the Association for Computa-
tional Linguistics (ACL), Florence, Italy, 292–302.
[Mikolov et al. 2013] Mikolov, T.; Chen, K.; Corrado, G.;
and Dean, J. 2013. Efﬁcient estimation of word represen-
tations in vector space. In Workshop Track Proceedings of
1st International Conference on Learning Representations,
(ICLR), Scottsdale, Arizona, USA.
[Mintz et al. 2009] Mintz, M.; Bills, S.; Snow, R.; and Juraf-
sky, D. 2009. Distant supervision for relation extraction
In Proceedings of the 47th Annual
without labeled data.
Meeting of the Association for Computational Linguistics
(ACL) and the 4th International Joint Conference on Natu-
ral Language Processing (IJCNLP), Singapore, 1003–1011.
[Pennington, Socher, and Manning 2014] Pennington,
J.;
2014. Glove: Global
Socher, R.; and Manning, C. D.
In Proceedings of the
vectors for word representation.
Conference on Empirical Methods in Natural Language
Processing (EMNLP), Doha, Qatar, 1532–1543.
[Ratner et al. 2016] Ratner, A. J.; Sa, C. D.; Wu, S.; Sel-
sam, D.; and R´e, C. 2016. Data programming: Creating
large training sets, quickly. In Proceedings of Annual Con-
ference on Neural Information Processing Systems (NIPS),
Barcelona, Spain, 3567–3575.
[Ratner et al. 2017] Ratner, A.; Bach, S. H.; Ehrenberg,
H. R.; Fries, J. A.; Wu, S.; and R´e, C. 2017. Snorkel:
Rapid training data creation with weak supervision. PVLDB
11(3):269–282.
[Raykar et al. 2010] Raykar, V. C.; Yu, S.; Zhao, L. H.;
Valadez, G. H.; Florin, C.; Bogoni, L.; and Moy, L. 2010.
Learning from crowds. The Journal of Machine Learning
Research 11:1297–1322.
[sms ] Sms spam collection data set.
unicamp.br/∼tiago/smsspamcollection/.
[spo ] Spouse Relation Extraction Task. https://github.com/
HazyResearch/snorkel/tree/master/tutorials/intro.
[Varma et al. 2019] Varma, P.; Sala, F.; He, A.; Ratner, A.;
and R´e, C.
2019. Learning dependency structures for
In Proceedings of the 36th In-
weak supervision models.
ternational Conference on Machine Learning (ICML), Long
Beach, California, USA, 6418–6427.
[Yan et al. 2011] Yan, Y.; Rosales, R.; Fung, G.; and Dy,
J. G. 2011. Active learning from crowds. In Proceedings
of the 28th International Conference on Machine Learning
(ICML), Bellevue, Washington, USA, 1161–1168.
[Yeh et al. 2017] Yeh, C.; Wu, W.; Ko, W.; and Wang, Y. F.
2017. Learning deep latent space for multi-label classiﬁca-
In Proceedings of the Thirty-First AAAI Conference
tion.

http://www.dt.fee.

on Artiﬁcial Intelligence, San Francisco, California, USA,
2838–2844.

Data Programming using Continuous and Quality-Guided Labeling

Functions (Supplementary Material)

4 Challenges in modeling continuous LFs: Illustration through an Example

Sentence id

Discrete

Continuous

S1 (+1)
S2 (-1)

LF1 (+1)
1
0

LF2 (-1)
0
1

LF1 (+1)
1, 1.0
1, 0.75

LF2 (-1)
1, 0.84
1, 1.0

Table 5: Triggering of the continuous and discrete versions of functions LF1 and LF2 for the two example sentences S1 and S2.

In this section, we highlight some challenges that we attempt to address while modeling continuous LFs. We illustrate
the challenges through two example sentences. Beside each sentence id, we state the value of the true label (±1). While the
candidate pair in S1 is an instance of the spouse relationship, the pair in S2 is not:
(cid:104)S1, +1(cid:105): It’s no secret that Brandi Glanville’s relationship with ex-husband <Eddie Cibrian> and his wife, <LeAnn Rimes>,
has been a strained one – but Glanville tells ETonline it’s getting better.
(cid:104)S2, −1(cid:105): Afterwards, <Christian Brady>, Dean of the Schreyer Honors College and father of <Mack Brady>, whom the
game is named after, addressed the lacrosse team.

In Table 5, we present the outputs of both discrete and continuous LFs on the examples S1 and S2. For S1, in the discrete
case, correct consensus can easily be performed to output the true label +1 as LF1 (designed for class +1) gets triggered whereas
LF2 (designed for class -1) is not triggered. correct consensus is challenging since both LF1 and LF2 produce non-trivial scores.
Let us say that we threhold the score of each continuous LF to be able to mimic the discrete case; e.g., score above the threshold
will mean that the LF is triggered and otherwise, not. However, the threshold would depend on the particular LF (possibly
0.75 for LF1 and 0.84 for LF2), and is tricky to estimate in an unsupervised setup such as ours. To address this challenge, we
signiﬁcantly extend and modify the existing generative model (Ratner et al. 2016; Bach et al. 2017) to support continuous LFs.
In addition to modeling the triggering distribution of each LF (continuous or discrete), we also model the distribution of scores
for each continuous LF.

5 Robustness to Parameter Initialization
We trained our models with random Gaussian (0,0.1) initialization and compared with our agreeing initialization. In Figure 3
we show how CAGE−Cis able to recover from any initialization whereas methods without guides fare even worse with random
initialization.

6 Labeling Functions employed in the SMS-Spam dataset
The SMS Spam dataset2 is a collection of raw SMS text. The task is to classify each SMS as spam or not. We employed 9
discrete and 6 continuous labeling functions. We brieﬂy discuss each labeling function that we employed in this task, beginning
with the discrete labeling functions:

1. Three labeling functions based on the presence of trigger words which are highly likely to indicate spam. Each labeling
function below, associated with the ‘spam’ class is triggered if any of the words in the SMS matches at least one of the words
associated with that LF

(a) LF1: matches one of the trigger words in the set trigWord1 = {’free’,’credit’,’cheap’,’apply’,’buy’,’attention’,’shop’,’sex’,’soon’,

’now’,’spam’}.
def LF1(c):

return (1,1) if len(trigWord1.intersection(c[’text’].split())) > 0
else (0,0)

(b) LF2: matches one of the trigger words in the set trigWord2 = {’gift’,’click’,’new’,’online’,’discount’,’earn’,’miss’,’hesitate’,

’exclusive’,’urgent’}.
def LF2(c):

return (1,1) if len(trigWord2.intersection(c[’text’].split())) > 0
else (0,0)

2http://www.dt.fee.unicamp.br/∼tiago/smsspamcollection/

(a) Agreeing initialization

(b) Random Initialization.

Figure 3: F1 with increasing number of training epochs compared across snorkel, CAGE−C−Gand CAGE−C, for two datasets:
Spouse (top-row) and CDR(bottom-row)

(c) LF3: matches one of the trigger words in the set trigWord3 = {’cash’,’refund’,’insurance’,’money’,’guaranteed’,’save’,’win’,’teen’,

’weight’,’hair’}.
def LF3(c):

return (1,1) if len(trigWord3.intersection(c[’text’].split())) > 0
else (0,0)

2. Two labeling functions associated with the ‘spam’ class based on the presence of words/phrases in other parts of speech

along with some context, which are highly likely to indicate spam:

(a) LF4: matches inquiries in the contex of a person’s being free or not free along with some overlap with the set of words

notFreeWords = {’toll’,’Toll’,’freely’,’call’,’meet’,’talk’,’feedback’},
def LF4(c):

return (-1,1) if ’free’ in c[’text’].split() and

len(notFreeWords.intersection(c[’text’].split()))>0

else (0,0)

(b) LF5: matches inquiries in the contex of a person’s being free or not free along with substring match with the set of

words/phrases notFreeSubstring = {’not free’,’you are’,’when’,’wen’},
def LF4(c):

return (-1,1) if ’free’ in c[’text’].split() and

re.search(ltp(notFreeSubstring),c[’text’], flags= re.I)

else (0,0)

3. Two labeling functions associated with the ‘spam’ class based on the presence of ﬁrst, second or third person keyword

matches:

(a) LF6:

matches

ﬁrst
{’I’,’i’,’u’,’you’,’ur’,’your’,’our’,’we’,’us’,’you´re,’},
def LF6(c):

second

and

person

keywords

in

ﬁrstAndSecondPersonWords

=

return (-1,1) if ’free’ in c[’text’].split() and
len(person1.intersection(c[’text’].split()))>0

else (0,0)

020406080100Epochs0.420.440.460.480.50F1_scoreF1_snorkelF1_CAGECGF1_CAGEC020406080100Epochs0.10.20.30.40.5F1_scoreF1_snorkelF1_CAGECGF1_CAGEC020406080100Epochs0.5500.5750.6000.6250.6500.6750.700F1_scoreF1_snorkelF1_CAGECGF1_CAGEC020406080100Epochs0.00.10.20.30.40.50.6F1_scoreF1_snorkelF1_CAGECGF1_CAGEC(b) LF7: matches third person keywords in thirdPersonWords = {’He’,’he’,’She’,’she’,’they’,’They’,’Them’,’them’,’their’,’Their’},

def LF7(c):

return (-1,1) if ’free’ in c[’text’].split() and

len(thirdPersonWords.intersection(c[’text’].split()))>0

else (0,0)

4. Function based on text characteristics such as number of capitalized characters. The function below is triggered if the number

of capital characters exceeds a threshold (6 in this case).

def LF8(c):

return (1,1)

if (sum(1 for ch in c[’text’] if ch.isupper()) > 6)

else (0,0)

5. Class Prior labeling function: The function below is always triggered for the negative class and serves as a class prior.

def LF9(c):

return (-1,1)

All of our continuous labeling functions are continuous versions of the discrete labeling functions described above. For those
discrete labeling functions that match dictionary entries, the continuous counterpart computes the maximum word vector based
similarity of the text (or textual context) across all entires in the dictionary. They are listed below:
(i) Three labeling functions based on the presence of trigger words which are highly likely to indicate spam:

(a) CLF1: Continuous version of LF1:

def CLF1(c):

sc = 0
word_vectors = get_word_vectors(c[’text’].split())
for w in trigWord1:

sc=max(sc,get_similarity(word_vectors,w))

return (1,sc)

(b) CLF2: Continuous version of LF2:

def CLF2(c):

sc = 0
word_vectors = get_word_vectors(c[’text’].split())
for w in trigWord2:

sc=max(sc,get_similarity(word_vectors,w))

return (1,sc)

(c) CLF3: Continuous version of LF3:

def CLF3(c):

sc = 0
word_vectors = get_word_vectors(c[’text’].split())
for w in trigWord3:

sc=max(sc,get_similarity(word_vectors,w))

return (1,sc)

(ii) Two labeling functions associated with the ‘spam’ class based on the presence of words/phrases in other parts of speech

along with some context, which are highly likely to indicate spam:

(a) CLF4: Continuous version of LF4:

def CLF4(c):

sc = 0
word_vectors = get_word_vectors(c[’text’].split())
for w in notFreeWords:

sc=max(sc,get_similarity(word_vectors,w))

return (1,sc)

(b) CLF5: Continuous version of LF5:

def CLF5(c):

sc = 0
word_vectors = get_word_vectors(c[’text’].split())
for w in notFreeSubstring:

sc=max(sc,get_similarity(word_vectors,w))

return (1,sc)

(iii) Two labeling functions associated with the ‘spam’ class based on the presence of ﬁrst, second or third person keyword

matches:

(a) CLF6: Continuous version of LF6:

def CLF6(c):

sc = 0
word_vectors = get_word_vectors(c[’text’].split())
for w in firstAndSecondPersonWords:

sc=max(sc,get_similarity(word_vectors,w))

return (-1,sc)

(b) CLF7: Continuous version of LF7

def CLF7(c):

sc = 0
word_vectors = get_word_vectors(c[’text’].split())
for w in thirdPersonWords:

sc=max(sc,get_similarity(word_vectors,w))

return (-1,sc)

(iv) Continuous version of LF8; the value it returns increases with the number of capital characters:

def CLF8(c):

l = sum(1 for ch in c[’text’] if ch.isupper())
return (1, 1-np.exp(float(-l/2)))

(v) Class Prior labeling function: This remains the same as before.

def CLF8(c):

return (-1,1)

7 Form of continuous potential
We explored many different generic forms of potentials for continuous LFs and we compare them with the speciﬁc beta-
distribution form. These potentials ψ(sj, τj, y) return a score increasing in sj when there is agreement, and decreasing in sj
when there is disagreement (for positive θj):
1. Treat s as a weight: θjyτjsj.
2. Thresholded: θjyτj max(sj − πj, 0)
3. Thresholded Sigmoid: θjyτjsigmoid(sj − πj)
4. Logit (Global conditioning on Beta): θjyτj log s
1−s
5. Half clipped Gaussian instead of Beta with the Gaussian mean at ’1’ when τj and y agree, and at 0 when they disagree. The

only learned parameter is then the variance of the Gaussian which we represent as πjy.

P (sij|y, lij, kj)

=






HG(1 − sij; scale = θjy0)
HG(sij; scale = θjy1)
1

if kj = y & lij (cid:54)= 0,
if kj (cid:54)= y & lij (cid:54)= 0,
otherwise.

(11)

In Table 6 we compare accuracy with these alternative forms of potentials. We appreciate the difﬁculty of choosing the right
continuous potentials by observing that for most of these other choices the accuracy is really poor.

8 Example: Failure in spite of good initialization of the Snorkel Model
Consider another dataset consisting of n LFs that are just slightly better than random, that is their agreement with the true y
when they trigger is just (0.5+(cid:15))*100%. A simple majority voting on the noisy LF labels will give nearly 100% accuracy when
n is large. On the other hand, with the Snorkel model even with favorable initializations (θj = 1, ∀j), the ﬁnal values of the
parameters on covergence is often poor. In most training runs, the accuracy dropped to 0 after a few training iterations. Our
decoupled model is able to perform well in this case without accuracy guides.

ψ(sj, τj, y)
θjyτjsj
θjyτj max(sj − πj, 0)
θjyτjsigmoid(sj − πj)
θjyτj log s
1−s
CAGE

Spouse CDR Sms Dedup
0
0
0
0.46
0.58

0.26
0
0
0
0.79

0
0
0
0
0.54

0.49
0.49
0.49
0
0.61

Ionosphere
0.96
0.83
0.80
0
0.97

Iris
0.87
0.87
0.87
0.44
0.87

Table 6: Comparison of Continuous Potentials

j : (1) where qc
Figure 4: F1 with increasing training epochs for three settings of qc
j = 0.8 for
all LFs, and (3) where qc
j = true accuracy of LF λj + a Gaussian noise of variance 0.2. We observe that across two different
datasets, the accuracy remains the same and stable for all three quality guides. Without the guides, we already saw in Figure 1
of the main paper how the F1 swings with training epochs.

j = 0.9 for all LFs, (2) where qc

9 Results by training Discriminative Classiﬁer
Data Programming is hinged upon creation of probabilistic training labels for any discriminative model with a standard loss
function. In Table 7, we report precision, recall and F1 scores on the test data by training a logistic regression classiﬁer on
labeled data created by Snorkel as well as our generative model CAGE . A takeaway of the following results is that, through
the use of continuous LFs and quality guides, the discriminative model generalizes much better beyond the heuristics encoded
in the LFs.

Spouse

Snorkel
CAGE

P
0.30
0.65

R
0.66
0.47

F1
0.41
0.55

P
0.41
0.58

CDR
R
0.98
0.86

F1
0.58
0.69

P
0.20
0.52

Sms
R
0.96
0.66

F1
0.34
0.58

Table 7: Discriminative Classiﬁer trained on data labeled using the generative models and evaluated on held-out test data.

020406080100Epochs0.500.550.600.650.70F1_scoreSensitivity of Quality Guides with different q_jF1_spouse_q_j = dev + N(0,0.2)F1_spouse_q_j = dev + N(0,0.5)F1_spouse_q_j = devF1_cdr_q_j = dev + N(0,0.2)F1_cdr_q_j = dev + N(0,0.5)F1_cdr_q_j = dev