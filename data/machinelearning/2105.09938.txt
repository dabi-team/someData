1
2
0
2

v
o
N
8

]
E
S
.
s
c
[

3
v
8
3
9
9
0
.
5
0
1
2
:
v
i
X
r
a

Measuring Coding Challenge Competence With
APPS

Dan Hendrycks∗
UC Berkeley

Steven Basart*
UChicago

Saurav Kadavath
UC Berkeley

Mantas Mazeika
UIUC

Akul Arora
UC Berkeley

Ethan Guo
UC Berkeley

Collin Burns
UC Berkeley

Samir Puranik
UC Berkeley

Horace He
Cornell

Dawn Song
UC Berkeley

Jacob Steinhardt
UC Berkeley

Abstract

While programming is one of the most broadly applicable skills in modern society,
it is unclear how well state-of-the-art machine learning models can write code. De-
spite its importance, there has been surprisingly little work on evaluating code gen-
eration, and it can be difﬁcult to assess code generation performance in an accurate
and rigorous manner. To meet this challenge, we introduce APPS, a benchmark for
code generation. Unlike prior work in more restricted settings, our benchmark mea-
sures the ability of models to take an arbitrary natural language speciﬁcation and
generate satisfactory Python code. Similar to how companies assess candidate soft-
ware developers, we evaluate models by checking their generated code on test cases.
Our benchmark includes 10,000 problems, which range from having simple one-
line solutions to being substantial algorithmic challenges. We ﬁne-tune large lan-
guage models on both GitHub and our training set, and we ﬁnd that the prevalence
of syntax errors is decreasing exponentially as models improve. Recent models such
as GPT-Neo can pass approximately 20% of the test cases of introductory problems,
so we ﬁnd that machine learning models are now beginning to learn how to code.
As the social signiﬁcance of automatic code generation increases over the coming
years, our benchmark can provide an objective measure for tracking advancements.

“Everybody should learn to program a computer, because it teaches you how to think.” – Steve Jobs

1

Introduction

Computer programming can be found in nearly all parts of society. Spanning entertainment, health-
care, education, and more, programming is an extraordinarily general tool with applications that are
vast in scope. As computers are becoming more ubiquitous in modern life, rising demand for high-
quality code draws an ever-greater number of aspiring programmers to the profession. After years of
study to become proﬁcient coders, human experts are are able to convert abstract speciﬁcations of
diverse cognitive tasks into concrete programs.

In the past few years, large-scale language models have shown promise in generalizing to various
cognitive tasks, including linguistic inference (Wang et al., 2019a), commonsense reasoning (Zellers
et al., 2019; Huang et al., 2019; Bisk et al., 2019), logical deduction (Liu et al., 2020b), mathematics
(Polu and Sutskever, 2020; Hendrycks et al., 2021c), and general understanding of multiple domains

∗Equal Contribution.

35th Conference on Neural Information Processing Systems (NeurIPS 2021) Track on Datasets and Benchmarks.

 
 
 
 
 
 
Figure 1: An example problem from APPS (left) along with possible generated code (middle) and
two example test cases we use to evaluate the generated code (right). Our evaluation framework has
test cases and 10,000 code generation problems of varying difﬁculty levels.

of human knowledge (Hendrycks et al., 2021b). However, whether large-scale language models can
reliably write code remains an open question.

Motivated by the potential of language models and the need for thorough code generation evaluation,
we introduce APPS, a benchmark for code generation from natural language speciﬁcations. Unlike
prior work on code generation with Transformer language models (Vaswani et al., 2017), which
mostly focuses on code translation (Lachaux et al., 2020) and pseudocode-to-code (Kulal et al., 2019),
we evaluate models on their ability to take speciﬁcations given in natural language and write code
that meets these speciﬁcations. This setting mirrors how human coders are evaluated and is a more
realistic and informative setting in which to benchmark models.

APPS provides a precise and comprehensive view of code generation. APPS evaluates models not
only on their ability to code syntactically correct programs, but also on their ability to understand task
descriptions and devise algorithms to solve these tasks. It contains 10,000 programming problems at
various levels of difﬁculty, covering simple introductory problems, interview-level problems, and
coding competition challenges. If a model were to perform well on APPS, this would indicate an
ability to ﬂexibly use data structures and programming techniques, as well as an ability to correctly
interpret diverse task speciﬁcations, follow instructions, and understand human intent (Hendrycks
et al., 2021a).

For most text generation tasks, high-quality evaluation requires human feedback, which can be
time-consuming or carry pecuniary costs. As a result, automatic metrics such as BLEU (Papineni
et al., 2002) are often used to compare methods, but these metrics do not necessarily track program
correctness. Since the objective for code generation is to produce correct programs, we assess
programs not with BLEU but with test cases and error catching. Evaluating code generation on APPS
is facilitated by a large bank of over 130,000 test cases. The test cases are speciﬁcally chosen to
probe correct functionality across the input space. By using test cases, we provide a gold-standard
metric for code generation quality.

In our experiments, we ﬁnd that models are now starting to exhibit nonzero accuracy and solve some
coding problems. Additionally, as models improve, we observe that syntax errors are exponentially
decreasing. We also ﬁnd further evidence that BLEU is a problematic metric for code generation,
sometimes being anticorrelated with gold-standard accuracy. We ﬁnd that accuracy decreases with
difﬁculty level and improves through ﬁne-tuning and model size increases. The strongest model that
we evaluate on introductory problems passes almost 20% of test cases given ﬁve attempts. These
results position code generation as a challenging but now tractable testbed for large-scale language
models.

Writing code to meet speciﬁcations in natural language is an economically valuable task with
widespread social implications should it be solved, as it could eventually facilitate malicious code
generation and one day result in job automation. As large-scale language models have the potential

2

ProblemGenerated CodeTest CasesH-IndexGiven a list of citations counts,where each citation is anonnegative integer, write afunction h_index that outputsthe h-index. The h-index is thelargest number h such that hpapers have each least h citations.Example:Input: [3,0,6,1,4]Output: 3Input:[1,4,1,4,2,1,3,5,6]Generated Code Output:4                      ✓Input:[1000,500,500,250,100,100,100,100,100,75,50,30,20,15,15,10,5,2,1]Generated Code Output:15                     ✓(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:1)(cid:2)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:8)(cid:14)(cid:15)(cid:16)(cid:17)(cid:4)(cid:4)(cid:4)(cid:4)(cid:8)(cid:4)(cid:18)(cid:4)(cid:19)(cid:2)(cid:8)(cid:10)(cid:11)(cid:12)(cid:13)(cid:8)(cid:14)(cid:15)(cid:16)(cid:4)(cid:4)(cid:7)(cid:3)(cid:4)(cid:8)(cid:4)(cid:20)(cid:4)(cid:21)(cid:17)(cid:4)(cid:4)(cid:4)(cid:4)(cid:11)(cid:12)(cid:13)(cid:8)(cid:14)(cid:15)(cid:22)(cid:15)(cid:12)(cid:23)(cid:14)(cid:10)(cid:16)(cid:4)(cid:4)(cid:4)(cid:4)(cid:11)(cid:12)(cid:13)(cid:8)(cid:14)(cid:15)(cid:22)(cid:23)(cid:2)(cid:24)(cid:2)(cid:23)(cid:15)(cid:2)(cid:10)(cid:16)(cid:4)(cid:4)(cid:4)(cid:4)(cid:5)(cid:4)(cid:18)(cid:4)(cid:21)(cid:4)(cid:4)(cid:4)(cid:4)(cid:25)(cid:5)(cid:7)(cid:19)(cid:2)(cid:4)(cid:10)(cid:5)(cid:4)(cid:26)(cid:4)(cid:8)(cid:4)(cid:27)(cid:8)(cid:1)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:11)(cid:12)(cid:13)(cid:8)(cid:14)(cid:15)(cid:28)(cid:5)(cid:29)(cid:30)(cid:31)(cid:20)(cid:18)(cid:5)(cid:16)(cid:17)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:5)(cid:4)(cid:32)(cid:18)(cid:4)(cid:31)(cid:4)(cid:4)(cid:4)(cid:4)(cid:23)(cid:2)(cid:14)(cid:13)(cid:23)(cid:8)(cid:4)(cid:5)(cid:4)(cid:4)(cid:4)(cid:4)(cid:2)(cid:19)(cid:15)(cid:2)(cid:17)(cid:4)(cid:4)(cid:4)(cid:4)(cid:23)(cid:2)(cid:14)(cid:13)(cid:23)(cid:8)(cid:4)(cid:21)(cid:1)(cid:2)Programming Language
Test Cases
Number of Programs
Lines per Program (Avg.)
Number of Exercises
Text Input

PY150
Python
(cid:53)
N/A
1
3,000
Python

CONCODE
Java
(cid:53)
104,000
26.3
104,000
Docstrings

SPoC
C++

APPS
Python

18,356
14.7
677
Pseudocode

232,421
18.0
10,000
Problem Descriptions

Table 1: A comparison of the APPS dataset to existing datasets for converting between text and code.
APPS has over an order of magnitude more ground-truth solutions than these datasets, test cases, and
natural language problem descriptions.

to make signiﬁcant progress on code generation, it is essential that we begin to track advancements
on this task. Our new benchmark facilitates measuring performance in an accurate and rigorous
manner. Using APPS, we ﬁnd that programming is very difﬁcult for modern language models, though
performance is improving. Thus, the APPS benchmark can provide foresight about the performance
of future large-scale language models at the critical task of program synthesis from natural language.
The dataset is available at https://github.com/hendrycks/apps.

2 Related Work

Program Synthesis. Program synthesis is the task of generating a computer program that satisﬁes
given speciﬁcations. Deductive program synthesis uses formal logic speciﬁcations to deﬁne a
search problem. Complex optimization techniques are used to generate programs satisfying these
speciﬁcations (Alur et al., 2018). Because speciﬁcations must be converted into a formal language,
these approaches can be rigid. Inductive synthesis from example input-output behavior can provide
an alternative to formal speciﬁcation (Cai et al., 2017; Gulwani et al., 2017), but it is often hard to
full specify behavior with examples, as any machine learning practitioner is well-aware.

An alternative to formal or inductive speciﬁcation is to specify program behavior in natural language,
which prior work has considered in constrained settings. Raza et al. (2015) and Desai et al. (2016)
generate short programs using ad-hoc programming languages to solve speciﬁcations such as “Any
2 letters followed by any combination of 6 whole numbers.” Yu et al. (2018) introduce the Spider
dataset for converting natural language queries into short SQL database commands. In contrast, we
consider long natural language speciﬁcations and general-purpose programming languages.

Code Understanding Datasets. Language modeling is a compelling tool for code generation,
and several works have achieved success generating code with language models in limited settings.
Lachaux et al. (2020) use unsupervised machine translation techniques to translate functions across
programming languages, attaining identical behavior after translation in many cases. Kulal et al.
(2019) introduce SPoC, a method for converting pseudocode to code utilizing seq2seq machine
translation with an additional search step. To train SPoC, they collect line-by-line descriptions of C++
programs using Amazon Mechanical Turk. Recently, Lu et al. (2021) introduce the CodeXGLUE
benchmark which aggregates various previous benchmarks and use CodeBLEU (Ren et al., 2020)
and CONCODE. Iyer et al. (2018) investigate generating Java code from docstrings and evaluate
performance with BLEU. The docstrings are often incomplete speciﬁcations of what should be coded
and only 14.7 words long on average, e.g. “Convert mixed case to underscores.” By comparison,
problem speciﬁcations in our new APPS benchmark are self-contained and have a much larger
average length of 293.2 words. Unlike Iyer et al. (2018), APPS contains test cases for every exercise,
enabling a high-quality evaluation of code correctness. Further comparisons are in the Appendix.

Evaluating Large-Scale Language Models. Modern large-scale language models have demon-
strated impressive capabilities across a variety of text-based tasks. On the SuperGLUE benchmark
(Wang et al., 2019b), some models now exceed human performance. On many commonsense reason-
ing benchmarks, performance is rising quickly (Zellers et al., 2019; Huang et al., 2019; Bisk et al.,
2019). Even when language models are evaluated across diverse technical areas such as law and
medicine, performance is surprisingly high and poised to improve as models are scaled up further
(Hendrycks et al., 2021b). With rapid improvements across numerous datasets, ﬁnding resilient

3

benchmarks on which models signiﬁcantly underperform humans is challenging. APPS represents an
attempt to ﬁll this gap and cleanly separate model performance from that of expert humans.

3 The APPS Dataset

The APPS dataset consists of problems collected from different open-access coding websites such as
Codeforces, Kattis, and more. The APPS benchmark attempts to mirror how humans programmers are
evaluated by posing coding problems in unrestricted natural language and using test cases to evaluate
solution correctness. The problems range in difﬁculty from introductory to collegiate competition
level and measure coding and problem-solving ability.

The Automated Programming Progress Standard, abbreviated APPS, consists of 10,000 coding
problems in total, with 131,777 test cases for checking solutions and 232,421 ground-truth solutions
written by humans. Problems can be complicated, as the average length of a problem is 293.2 words.
The data are split evenly into training and test sets, with 5,000 problems each. In the test set, every
problem has multiple test cases, and the average number of test cases is 21.2. Each test case is
speciﬁcally designed for the corresponding problem, enabling us to rigorously evaluate program
functionality.

Dataset Construction. To create the APPS dataset, we manually curate problems from open-access
sites where programmers share problems with each other, including Codewars, AtCoder, Kattis, and
Codeforces. Problems are posed as natural language speciﬁcations of what should be coded, and they
come in various formats. To improve quality and consistency, we wrote custom HTML parsers for
each source of problems, which allows us to properly format LaTeX expressions, lists, and sections in
the question text. Where necessary, we convert equation images to LaTeX using the MathPix API, and
we remove problems that rely on image ﬁgures. We also perform deduplication using tf-idf features
with SVD dimensionality reduction and cosine similarity. Several graduate and undergraduate student
authors polished and reﬁned this dataset over the course of six months, ensuring a high-quality set of
problems.

Executing and evaluating arbitrary Python code is challenging. On the websites we source data from,
human solutions are allowed to run arbitrary code, including import statements for common modules
and libraries. To handle this, each website implements a custom judging system for solutions. We
design a testing framework with this in mind, which merges the judging functionality of several
websites. We also standardize the format of test cases. The end result is that solutions are allowed to
execute arbitrary Python code, and the results are compared against test cases for a given problem.

Dataset Difﬁculty. Each of our problem sources uses a separate scale for measuring difﬁculty. We
place problems from these different sources into three categories. For example, problems from Kattis
with difﬁculty less than 3 are categorized as “introductory,” problems with difﬁculty between 3 and 5
as “interview,” and problems with difﬁculty greater than 5 as “competition.”

1. Introductory Level. These are problems that most programmers with 1-2 years of expe-
rience can answer without requiring complicated algorithms. Examples of such problems
include counting the number of vowels in a string, or returning the running sum of a list of
integers. There are 3,639 problems classiﬁed as introductory level and 1,000 in the test set.

2. Interview Level. These are problems that are more algorithmic and difﬁcult in nature and
would be at the level of questions asked in programming technical interviews. Examples
of such problems might include those involving data structures such as trees or graphs,
or problems that requiring nontrivial algorithms. There are 5,000 problems classiﬁed as
interview level and 3,000 in the test set.

3. Competition Level. These are problems are the most challenging and are at the level of the
most advanced high school and collegiate programming competitions, including USACO,
IOI, and ACM. There are 1,361 competition level problems and 1,000 in the test set.

Problem Formats. To accommodate a broad range of problem sources, problems in APPS come
in two formats.

• Call-Based Format problems generally provide initial starter code, usually in the form of a

function header, and ask for the solution to be provided as the function’s return value.

4

Problem
You are given a string s = s1s2 . . . sn of length n, which only contains digits 1, 2,..., 9. A substring
s[l . . . r] of s is a string slsl+1sl+2 . . . sr. A substring s[l . . . r] of s is called even if the number
represented by it is even. Find the number of even substrings of s. Note, that even if some substrings
are equal as strings, but have different l and r, they are counted as different substrings. The ﬁrst line
contains an integer n (1 ≤ n ≤ 65000) — the length of the string s. The second line contains a string
s of length n. The string s consists only of digits 1, 2,..., 9. Print the number of even substrings of s.
Model Output
n = int(input())
s = input()
ans = 0
for i in range(n):

for j in range(i, n):

if int(s[i:j+1]) % 2 == 0:

print(ans)

ans += 1

Figure 2: Model-generated code from GPT-2 1.5B. 18/18 test cases pass for the problem. Note that
models were given in problems exactly as they they are formatted here, which even meant parsing
LATEX. For brevity, we exclude formatting instructions from this depicted problem.

• Standard Input Format problems generally lack starter code. Instead, the model is only
provided with the problem and must output its answers to the STDOUT stream, such as by
using print statements.

For the call-based format problems, we prompt models using the following inputs:

"\nQUESTION:\n" + q_str + "\n" + starter_code_str + "\n" + "\nUse
Call-Based Format\n\nANSWER:\n"

For the above prompt, the variable q_str represents the raw text of the problem statement. The
variable starter_code_str represents the starter code given in the problem deﬁnition, or the
empty string if no starter code was provided. For the standard input format problems, we prompt
the model with the input string as before, but we replace “Call-Based Format” with “Standard Input
Format.” Note that if starter code is given, it is only part of the input. This means that to use the
starter code, a model must learn to copy the starter code at the beginning of its outputted answer in
order to get the question correct. We ﬁnd that ﬁne-tuned models are able to do this without difﬁculty.

In the APPS test split, the average number of test cases is 21.2, but some
Test Case Quality.
problems only have two test cases. These problems mainly come from Kattis and were chosen for
the test split due to limited numbers of competition problems. A potential concern is that these
problems could result in false positives if models happen to guess both test cases correctly. This is
very unlikely in problems with large output spaces, but some problems have small output spaces,
such as {“YES”, “NO”}. Although the model must narrow down these two options from the space of
all possible strings, we ﬁnd that this is not difﬁcult for current models to accomplish, and this may
cause false positives in our evaluation.

To quantify the impact of these problems, we took all 2- and 3-test-case problems that GPT-Neo 2.7B
passed and manually checked for false positives. Out of 12 problems that the model got correct with
2 test cases, 8 were false positives. Out of 6 problems with 3 test cases, only 1 was a false positive.
Since the test cases are from coding challenge websites with many users, we can assume that false
negatives are absent. Thus, the false positive rate with 2 test cases is 8/(890 − 4) = 0.009 < 1% and
1/(765 − 5) = 0.001 < 1% with 3 test cases. The upshot is that the potential for noise is signiﬁcantly
less than that of most naturally annotated datasets.

5

Problem
You are given two integers n and m. Calculate the number of pairs of arrays (a, b) such that: the
length of both arrays is equal to m; each element of each array is an integer between 1 and n
(inclusive); ai ≤ bi for any index i from 1 to m; array a is sorted in non-descending order; array b is
sorted in non-ascending order. As the result can be very large, you should print it modulo 109 + 7.
Input: The only line contains two integers n and m (1 ≤ n ≤ 1000, 1 ≤ m ≤ 10). Output: Print one
integer – the number of arrays a and b satisfying the conditions described above modulo 109 + 7.

Model Output
n, m = map(int, input().split())
mod = 10**9+7

fact = [1, 1]
factinv = [1, 1]
inv = [0, 1]

for i in range(2, n+1):

fact.append((fact[-1] * i) % mod)
inv.append((-inv[mod % i] * (mod//i)) % mod)
factinv.append((factinv[-1] * inv[-1]) % mod)

def cmb(n, r, mod):

if (r < 0) or (n < r):

return 0
r = min(r, n - r)
return fact[n] * factinv[r] * factinv[n-r] % mod

print((cmb(n, m, mod) * cmb(m-1, n-1, mod)) % mod)

Figure 3: An example from GPT-2 1.5B. Although the code generated passes 0 test cases, it looks
plausible at ﬁrst glance.

4 Experiments

4.1 Experimental Setup

Models. We use GPT-2 (Radford et al., 2019), GPT-3 (Brown et al., 2020), and GPT-Neo (Black
et al., 2021) models. The GPT architecture is especially appropriate for text generation because it is
autoregressive. However, GPT-2 was not pretrained on code, so we pretrain it on GitHub as described
in the next paragraph. Anecdotal evidence indicates that GPT-3 can generate code. To determine the
extent of its code generation ability, we use the ‘davinci’ (Instruct series) model, the largest publicly
available model speculated to have 175 billion parameters. Finally, GPT-Neo has an architecture
similar to GPT-3, and it was pretrained on the Pile (Gao et al., 2020) which includes GitHub. Unlike
GPT-3, GPT-Neo’s weights are publicly available, hence we are able to ﬁne-tune it with APPS.

GPT-2 Pretraining. Since GPT-2 was trained on natural language and not code, we collected
GitHub code to further pretrain GPT-2. GitHub repositories with fewer than one star were ﬁltered
out. While Neo’s GitHub pretraining data did not undergo an APPS data decontamination process,
our GPT-2 models are trained on decontaminated data. Speciﬁcally, all repositories matching certain
keywords that would suggest overlap with common programming exercises were removed. We
provide the list of keywords in the Supplementary Materials. We also discard any GitHub code that
contains functions with the same signatures as functions in the starter code in many of our APPS
problems. This leaves us with 30 GB of Python code. To improve the efﬁciency of pretraining, we
process all Python code in the pretraining dataset by converting from spaces to tabs, which saves the
character conversion when running model tokenizers.

Fine-tuning. During ﬁne-tuning with APPS, the objective is to predict the entire code solution,
given both the English text problem statement and the problem format (call-based format or standard
input format). For problems with starter code, we exclude the starter code from the training loss.

6

Model

Introductory Interview Competitive Average Introductory Interview Competition Average

Test Case Average

Strict Accuracy

GPT-2 0.1B
GPT-2 1.5B
GPT-Neo 2.7B
GPT-3 175B

5.64
7.40
14.68
0.57

6.93
9.11
9.85
0.65

4.37
5.05
6.54
0.21

6.16
7.96
10.15
0.55

1.00
1.30
3.90
0.20

0.33
0.70
0.57
0.03

0.00
0.00
0.00
0.00

0.40
0.68
1.12
0.06

Table 2: Average percentage of test cases passed and strict accuracy for each model and difﬁculty
level. All values are percentages. Note ‘0.1B’ indicates the number of model parameters in billions.
GPT-3 is a few-shot model and not ﬁne-tuned, unlike the other models. GPT-Neo does best and
attains approximately 4% strict accuracy on Introductory problems, and for these problems it passes
approximately 15% of the test cases.

Across pretraining and ﬁne-tuning, we use the AdamW optimizer (Loshchilov and Hutter, 2019),
a batch size of 256, and a weight decay of 0.05. We ﬁne-tune for 10 epochs. We use DeepSpeed
and its implementation of the ZeRO optimizer to reduce memory consumption while training large
models (Rasley et al., 2020; Rajbhandari et al., 2020). Unless otherwise speciﬁed, we use the default
HuggingFace generation parameters, except that we use beam search with a beam size of 5. Models
are ﬁne-tuned on 8 A100 GPUs.

4.2 Metrics

To obtain a comprehensive evaluation of code generation ability, we use the large bank of test cases
and ground-truth solutions provided with APPS. Test cases allow for automatic evaluation, even
though the the space of possible programs can be combinatorially large. Therefore, unlike many
other text generation tasks, manual analysis is not necessary. We aggregate the generated code’s
performance on test cases with two metrics, “test case average” and “strict accuracy.”

Test Case Average. We compute the average fraction of test cases passed. Concretely, let the
number of problems in the test set be P . For a given problem p, let the code generated to solve
problem p be denoted (cid:104)codep(cid:105), and set of test cases for problem p be {(xp,c, yp,c)}Cp
c=1. Then the
test case average is

1
P

P
(cid:88)

p=1

1
Cp

Cp
(cid:88)

c=1

1{eval((cid:104)codep(cid:105), xp,c) = yp,c}.

Oftentimes, solutions can successfully pass a subset of the test cases but not cover every corner
case. This allows for less stringent model evaluation, as strict accuracy may currently obscure model
improvements.

Strict Accuracy. Eventually, generated solutions should pass all test cases including corner cases.
To compute the strict accuracy which requires programs pass every test case, we run the code generated
by the model on every test case of every problem. Strict accuracy is then computed by taking the
number of solutions passing every test case divided by the total number of exercises. Using the
1{eval((cid:104)codep(cid:105), xp,c) =
notation from before, we can write the strict accuracy as 1
P
yp,c}. Future research may only use strict accuracy when models become sufﬁciently capable.

(cid:81)Cp
c=1

(cid:80)P

p=1

4.3 Model Performance Analysis

Qualitative Output Analysis. Models can sometimes generate correct or superﬁcially plausible
code. Figure 2 shows code generated by GPT-2 1.5B that passes all test cases. When models do
not pass the test cases, sometimes their generated code still appears plausible at ﬁrst glance. For
example, in Figure 3, we see that the 1.5B parameter model generates code that is related to the
problem statement and makes a plausible attempt to solve it.

Test Case Evaluation. We show the main results in Table 2. We observe that models are able to
generate code that passed some test cases, implying many generated programs are free of syntax errors
and can successfully process inputs test cases to produce correct answers. Note that for Introductory
questions, GPT-Neo passes approximately 15% of the test cases. We visualize Test Case Average

7

Figure 4: The average percentage of test cases
passed increases with larger ﬁne-tuned models.

Figure 5: Syntax errors decrease exponentially
with ﬁne-tuning and increased model sizes. GPT-
Neo 2.7B has very few syntax errors.

results in Figure 4. This demonstrates models are showing marked improvements on code generation
and now starting to have traction on code generation.

Performance can be further improved by sampling mul-
tiple solutions and selecting the best. Here, we per-
form beam search with beam width 5 and evaluate its
5 beams, so that each model has ﬁve attempts to get
a problem correct rather than one. With this setup,
GPT-Neo’s strict accuracy on Introductory problem
then exceeds 5%, as shown in Table 3. Our results in
the Supplementary Materials show that the top-5 test
case average GPT-2 0.1B is 10.75 while the top-1 test
case average of GPT-2 1.5B is 7.96. This highlights
that simply sampling multiple candidate solutions is a
powerful way to markedly improve performance.

Top-1

Top-5

Test Case Average
Strict Accuracy

14.7% 19.9%
5.5%
3.9%

Table 3: GPT-Neo 2.7B performance on in-
troductory problems using one generated
program (Top-1) and the best of ﬁve gener-
ated programs (Top-5). Full results are in
the Supplementary Materials.

Our results also provide us with information about the
importance of model choice. Evidently existing few-shot GPT-3 models are not necessarily better at
code generation than ﬁne-tuned models that are smaller by two orders of magnitude. Additionally,
performance improvement from GPT-2 1.5B to GPT-Neo 2.7B is larger than that from GPT-2 0.1B
to GPT-2 1.5B. Potential causes of GPT-Neo’s better performance are that GPT-Neo is trained on
more code from GitHub, it has more parameters, or its architecture hyperparameters were chosen
better. Memorization explaining all performance is an implausible explanation as performance tracks
problem difﬁculty; were models just memorizing, we would expect uniform performance across
difﬁculties. Since models still have large room for improvement, solving the APPS benchmark
without unreasonable amounts of computational resources may require architectural or algorithmic
improvements.

Syntax Errors. We now assess the frequency of syntax errors, errors that prevent the program from
being interpreted including inconsistent spacing, unbalanced brackets, missing colons, and so on.
Syntax errors are identiﬁed in our testing framework based on the heuristic of whether pyext is able
to load the generated code as a Python module. For our purposes, this almost exclusively occurs for
syntax errors. We visualize the prevalence of syntax errors in Figure 5. While approximately 59% of
GPT-3’s generated solutions for introductory problems have syntax errors, GPT-Neo syntax error
frequency is approximately 3%. Note that recent work such as Yasunaga and Liang (2020) create a
separate model to repair source code to ﬁx compilation issues, but our results suggest that such efforts
may be unnecessary in the future as syntax error frequency is sharply decreasing automatically.

8

IntroductoryInterviewCompetitionProblem Difficulty0246810121416Test Case Average (%)Model Test Case AveragesGPT-3 (few-shot)GPT-2 (0.1B)GPT-Neo (2.7B)IntroductoryInterviewCompetitionProblem Difficulty102101Solutions With Syntax Errors (%)Syntax Error Prevalence IsDecreasing ExponentiallyBLEU. We ﬁnd that assessing model performance with BLEU is a poor substitute for evaluating
with test cases. To evaluate BLEU, we take the generated solution and compute its BLEU with each
human-written solution for a given problem; we then record the highest BLEU score. Observe in
Figure 6 that BLEU increases as problem sources become more difﬁcult, even though models actually
perform worse on harder problems. Moreover, worse models can have similar or higher BLEU scores.
For example, GPT-2 0.1B has 26.8, 29.7, and 30.2 as BLEU scores for introductory, interview, and
competition problems, respectively. Meanwhile GPT-Neo 2.7B has 27.1, 29.1, and 29.3 as its BLEU
scores, respectively. Hence BLEU wrongly suggests GPT-Neo is a worse model.

Evaluating GPT-3. We evaluate GPT-3 175B
on APPS in a few-shot setting. A separate
prompt is used for standard input and call-based
questions, and each prompt includes instruction
text along with two example questions and solu-
tions from the corresponding question type. We
ﬁnd that GPT-3 only solves 3 problems out of
5,000: two introductory problems and one inter-
view problem. The two introductory problems
are simple interpretation tasks, such as imple-
menting a speciﬁed algebraic expression. The
interview problem requires higher-level thinking
that suggests nontrivial reasoning. However, it
is possible that GPT-3 memorized the solution
during pretraining, or that it took a lucky guess
based on heuristics in the question. One poten-
tial factor in GPT-3’s poor performance is that
it handles syntax poorly. Namely, we observed
cases where improper formatting of otherwise
functioning code causes a syntax error. For spe-
ciﬁc examples and more details, see the Supplementary Materials.

Figure 6: BLEU scores for GPT-Neo 2.7B increase
with difﬁculty level and are anticorrelated with a
gold-standard accuracy metric.

Evaluations on Larger Models. Since the public release of APPS, several others have trained
even larger models on APPS than we evaluate here. OpenAI Codex is a 12B parameter Transformer
language model pre-trained on large quantities of public code and comments. Chen et al. (2021)
evaluate Codex on APPS under various conﬁgurations and achieve top-1 and top-5 accuracy on
introductory problems of 4.14% and 9.65% respectively, close to double the top-5 accuracy of
GPT-Neo 2.7B. Furthermore, by scaling up to a top-1000 evaluation they obtain 25% accuracy.
This demonstrates that larger models trained speciﬁcally for code generation can improve APPS
performance even further, but are still far from solving the task.

5 Conclusion

We introduced APPS, a benchmark of 10,000 Python programming problems. Unlike prior work
that focused on pseudocode to code generation or translation between programming languages, our
benchmark measures how well language models can generate python code given natural language
speciﬁcations. By performing extensive quality assurance and including hundreds of thousands of
test cases and ground-truth solutions across different difﬁculty levels, we created a comprehensive
and rigorous testbed for evaluating models. We assessed state-of-the-art generative models on our
benchmark and found that overall performance was low. However, the prevalence of syntax errors
decreased exponentially as models improved, and recent models such as GPT-Neo solved over 5% of
our introductory problems. As models become more competent at code generation, it is important to
have a proxy for tracking this capability which could one day result in automation or malicious code
generation. The APPS benchmark can provide an important measure for tracking upstream program
synthesis advancements.

9

IntroductoryInterviewCompetitionProblem Difficulty26272829303132BLEUBLEUTest Case Average (%)0246810121416Test Case Average (%)BLEU Does Not Track Performance WellReferences

Miltiadis Allamanis and Charles Sutton. Mining source code repositories at massive scale using
language modeling. In 2013 10th Working Conference on Mining Software Repositories (MSR),
pages 207–216. IEEE, 2013.

Rajeev Alur, Dana Fisman, Saswat Padhi, Rishabh Singh, and Abhishek Udupa. Sygus-comp 2018:

Results and analysis. SYNT, 2018.

Yonatan Bisk, Rowan Zellers, Ronan Le Bras, Jianfeng Gao, and Yejin Choi. Piqa: Reasoning about

physical commonsense in natural language, 2019.

Sid Black, Leo Gao, Phil Wang, Connor Leahy, and Stella Biderman. GPT-Neo: Large Scale Autore-
gressive Language Modeling with Mesh-Tensorﬂow, March 2021. URL https://doi.org/
10.5281/zenodo.5297715. If you use this software, please cite it using these metadata.
T. Brown, B. Mann, Nick Ryder, Melanie Subbiah, J. Kaplan, Prafulla Dhariwal, Arvind Neelakantan,
Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, G. Krüger,
T. Henighan, R. Child, Aditya Ramesh, D. Ziegler, Jeffrey Wu, Clemens Winter, Christopher
Hesse, Mark Chen, E. Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, J. Clark, Christopher
Berner, Sam McCandlish, A. Radford, Ilya Sutskever, and Dario Amodei. Language models are
few-shot learners. ArXiv, abs/2005.14165, 2020.

Jonathon Cai, Richard Shin, and D. Song. Making neural programming architectures generalize via

recursion. 2017.

Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde, Jared Kaplan, Harri Edwards,
Yura Burda, Nicholas Joseph, Greg Brockman, et al. Evaluating large language models trained on
code. arXiv preprint arXiv:2107.03374, 2021.

Aditya Desai, Sumit Gulwani, Vineet Hingorani, Nidhi Jain, Amey Karkare, Mark Marron, and
Subhajit Roy. Program synthesis using natural language. In Proceedings of the 38th International
Conference on Software Engineering, pages 345–356, 2016.

Leo Gao, Stella Biderman, Sid Black, Laurence Golding, Travis Hoppe, Charles Foster, Jason Phang,
Horace He, Anish Thite, Noa Nabeshima, et al. The pile: An 800gb dataset of diverse text for
language modeling. arXiv preprint arXiv:2101.00027, 2020.

Timnit Gebru, Jamie Morgenstern, Briana Vecchione, Jennifer Wortman Vaughan, Hanna Wallach,
Hal Daumeé III, and Kate Crawford. Datasheets for datasets. arXiv preprint arXiv:1803.09010,
2018.

Sumit Gulwani, Oleksandr Polozov, and R. Singh. Program synthesis. Found. Trends Program. Lang.,

4:1–119, 2017.

Dan Hendrycks, Collin Burns, Steven Basart, Andrew Critch, Jerry Li, Dawn Song, and Jacob
Steinhardt. Aligning AI with shared human values. Proceedings of the International Conference
on Learning Representations (ICLR), 2021a.

Dan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob
Steinhardt. Measuring massive multitask language understanding. Proceedings of the International
Conference on Learning Representations (ICLR), 2021b.

Dan Hendrycks, Collin Burns, Saurav Kadavath, Akul Arora, Steven Basart, Eric Tang, Dawn Song,
and Jacob Steinhardt. Measuring mathematical problem solving with the math dataset. arXiv
preprint arXiv:2103.03874, 2021c.

Lifu Huang, Ronan Le Bras, Chandra Bhagavatula, and Yejin Choi. Cosmos qa: Machine reading

comprehension with contextual commonsense reasoning, 2019.

Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, and Luke Zettlemoyer. Mapping language to code in
programmatic context. In Proceedings of the 2018 Conference on Empirical Methods in Natural
Language Processing, Brussels, Belgium, October-November 2018. Association for Computational
Linguistics.

Sumith Kulal, Panupong Pasupat, Kartik Chandra, Mina Lee, Oded Padon, Alex Aiken, and Percy S
Liang. Spoc: Search-based pseudocode to code. In Advances in Neural Information Processing
Systems, volume 32, 2019.

Marie-Anne Lachaux, Baptiste Roziere, Lowik Chanussot, and Guillaume Lample. Unsupervised

translation of programming languages. arXiv preprint arXiv:2006.03511, 2020.

10

W. Ling, P. Blunsom, Edward Grefenstette, K. Hermann, Tomás Kociský, Fumin Wang, and A. Senior.

Latent predictor networks for code generation. ArXiv, abs/1603.06744, 2016.

Hui Liu, Mingzhu Shen, Jiaqi Zhu, Nan Niu, Ge Li, and Lu Zhang. Deep learning based program
generation from requirements text: Are we there yet? IEEE Transactions on Software Engineering,
2020a.

J. Liu, Leyang Cui, Hanmeng Liu, Dandan Huang, Yile Wang, and Yue Zhang. LogiQA: A challenge

dataset for machine reading comprehension with logical reasoning. In IJCAI, 2020b.

I. Loshchilov and F. Hutter. Decoupled weight decay regularization. In ICLR, 2019.
Shuai Lu, Daya Guo, Shuo Ren, Junjie Huang, Alexey Svyatkovskiy, A. Blanco, C. Clément, Dawn
Drain, Daxin Jiang, Duyu Tang, Ge Li, L. Zhou, Linjun Shou, Long Zhou, Michele Tufano,
Ming Gong, Ming Zhou, N. Duan, N. Sundaresan, Shao Kun Deng, Shengyu Fu, and Shujie Liu.
Codexglue: A machine learning benchmark dataset for code understanding and generation. 2021.

Yusuke Oda, Hiroyuki Fudaba, Graham Neubig, Hideaki Hata, Sakriani Sakti, Tomoki Toda, and
Satoshi Nakamura. Learning to generate pseudo-code from source code using statistical machine
translation. In International Conference on Automated Software Engineering (ASE), 2015.

Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. Bleu: a method for automatic
evaluation of machine translation. In Proceedings of the 40th annual meeting of the Association
for Computational Linguistics, pages 311–318, 2002.

Stanislas Polu and Ilya Sutskever. Generative language modeling for automated theorem proving.

ArXiv, abs/2009.03393, 2020.

Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language

models are unsupervised multitask learners. OpenAI blog, 1(8):9, 2019.

Samyam Rajbhandari, Jeff Rasley, Olatunji Ruwase, and Yuxiong He. Zero: Memory optimizations

toward training trillion parameter models, 2020.

Jeff Rasley, Samyam Rajbhandari, Olatunji Ruwase, and Yuxiong He. Deepspeed: System optimiza-
tions enable training deep learning models with over 100 billion parameters. Proceedings of the
26th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2020.
Veselin Raychev, Pavol Bielik, and Martin T. Vechev. Probabilistic model for code with decision
trees. Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented
Programming, Systems, Languages, and Applications, 2016.

Mohammad Raza, Sumit Gulwani, and Natasa Milic-Frayling. Compositional program synthesis

from natural language and examples. In IJCAI, 2015.

Shuo Ren, Daya Guo, Shuai Lu, L. Zhou, Shujie Liu, Duyu Tang, M. Zhou, A. Blanco, and S. Ma.
Codebleu: a method for automatic evaluation of code synthesis. ArXiv, abs/2009.10297, 2020.
L. Tang and R. Mooney. Using multiple clause constructors in inductive logic programming for

semantic parsing. In ECML, 2001.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez,

L. Kaiser, and Illia Polosukhin. Attention is all you need. ArXiv, abs/1706.03762, 2017.

Alex Wang, Yada Pruksachatkun, Nikita Nangia, Amanpreet Singh, Julian Michael, Felix Hill, Omer
Levy, and Samuel Bowman. Superglue: A stickier benchmark for general-purpose language
understanding systems. In NeurIPS, 2019a.

Alex Wang, Yada Pruksachatkun, Nikita Nangia, Amanpreet Singh, Julian Michael, Felix Hill, Omer
Levy, and Samuel R. Bowman. Superglue: A stickier benchmark for general-purpose language
understanding systems. In NeurIPS, 2019b.

Bailin Wang, Richard Shin, Xiaodong Liu, Oleksandr Polozov, and Matthew Richardson. Rat-
arXiv preprint

sql: Relation-aware schema encoding and linking for text-to-sql parsers.
arXiv:1911.04942, 2019c.

Michihiro Yasunaga and Percy Liang. Graph-based, self-supervised program repair from diagnostic

feedback. ArXiv, abs/2005.10636, 2020.

Tao Yu, Rui Zhang, Kai Yang, Michihiro Yasunaga, Dongxu Wang, Zifan Li, James Ma, Irene Li,
Qingning Yao, Shanelle Roman, et al. Spider: A large-scale human-labeled dataset for complex
and cross-domain semantic parsing and text-to-sql task. arXiv preprint arXiv:1809.08887, 2018.

11

Maksym Zavershynskyi, A. Skidanov, and Illia Polosukhin. Naps: Natural program synthesis dataset.

2nd Workshop on Neural Abstract Machines and Program Induction, 2018.

J. Zelle and R. Mooney. Learning to parse database queries using inductive logic programming. In

AAAI/IAAI, Vol. 2, 1996.

Rowan Zellers, Ari Holtzman, Yonatan Bisk, Ali Farhadi, and Yejin Choi. Hellaswag: Can a machine

really ﬁnish your sentence?, 2019.

12

Programming Language
Test Cases
Number of Programs
Lines per Program (Avg.)
Number of Exercises
Text Input

Hearthstone
Python
(cid:53)
665
7.7
665
Card Text

Django
Python
(cid:53)
18,805
1
18,805
Comment

NAPS
UAST

APPS
Python

17,477
21.7
2,231
Pseudocode

232,421
18.0
10,000
Problem Descriptions

Table 4: Further comparisons of APPS with previous datasets.

Model

Introductory Interview Competitive Average Introductory Interview Competition Average

Top-5 Test Case Average

Top-5 Strict Accuracy

GPT-2 0.1B
GPT-2 1.5B
GPT-Neo 2.7B

13.81
16.86
19.89

10.97
13.84
13.19

7.03
9.01
9.90

10.75
13.48
13.87

2.70
3.60
5.50

0.73
1.03
0.80

0.00
0.00
0.00

1.02
1.34
1.58

Table 5: Top-5 performance of GPT-2 models and GPT-Neo. Taking the best of ﬁve candidate
solutions markedly improves performance.

A Auxiliary Dataset Information

Legal Compliance.
In APPS, we scrape question text, ground-truth solutions, and test cases from
various coding challenge websites. These websites are AtCoder, CodeChef, Codeforces, Codewars,
HackerRank, Kattis, and LeetCode. In all cases, we only scrape public-facing data. For instance, we
avoid scraping data from paywalled portions of sites. In the case of Kattis, all problems we scrape
are under the CC BY-SA 3.0 license (https://creativecommons.org/licenses/by-sa/3.0/). For other
websites, some content may be copyrighted. In these cases, we abide by Fair Use §107: “the fair
use of a copyrighted work, including such use by ... scholarship, or research, is not an infringement
of copyright”, where fair use is determined by “the purpose and character of the use, including
whether such use is of a commercial nature or is for nonproﬁt educational purposes”, “the amount
and substantiality of the portion used in relation to the copyrighted work as a whole”, and “the effect
of the use upon the potential market for or value of the copyrighted work.” The APPS dataset is
noncommercial and is likely to have no effect on the value of the original problems. Moreover, for all
problem sources, we only scrape a fraction of the available problems and ground-truth solutions.

Regarding international copyright laws, the websites that we scrape from are based in the United
States, Japan, India, and Russia, all of which are contracting parties to the WIPO Copyright Treaty.
In the United States, the WIPO Copyright Treaty is implemented by the Digital Millenium Copyright
Act (DMCA). Since APPS was made in the United States, the DMCA is the relevant legislation that
we must comply with. Notably, DMCA §1201 states, “No person shall circumvent a technological
measure that effectively controls access to a work protected under this title.” We do not circumvent
access controls when creating APPS and hence abide by §1201. Fair Use extends to content protected
by the DMCA, for which we refer readers to the previous paragraph.

Although GDPR only applies in the European Union, some of the ground-truth solutions in APPS
may have been written by EU citizens. GDPR is chieﬂy concerned with the protection of personal
data gathered by entities engaging in economic activity. The only personally linked information in
APPS is the problem solutions written by individuals and published under aliases to public websites.
In some cases, these solutions contain identifying information in comments, which we remove to
preserve privacy. We comply with GDPR, because our processed solutions remove identiﬁers, and
we are compliant because we collect the data for academic research purposes.

Author Statement and License. We bear all responsibility in case of violation of rights. The
APPS data is licensed under CC BY-SA 3.0 in accordance with the Kattis problem licenses and the
ShareAlike terms. Our code is open sourced under the MIT license.

13

B Datasheets

We follow the recommendations of Gebru et al. (2018) and provide a datasheet for the ETHICS
dataset in this section.

B.1 Motivation

For what purpose was the dataset created? Was there a speciﬁc task in mind? Was there
a speciﬁc gap that needed to be ﬁlled? Please provide a description. The APPS dataset was
created to track the progress of code generation models on the task of generating arbitrary Python code
from complex natural language speciﬁcations, a challenging setting that had no rigorous benchmark
before our work.

Who created the dataset (e.g., which team, research group) and on behalf of which entity (e.g.,
company, institution, organization)? Refer to the main document.

Who funded the creation of the dataset? If there is an associated grant, please provide the
name of the grantor and the grant name and number. There is no associated grant.

Any other comments? No.

B.2 Composition

What do the instances that comprise the dataset represent (e.g., documents, photos, people,
countries)? Are there multiple types of instances (e.g., movies, users, and ratings; people and
interactions between them; nodes and edges)? Please provide a description. The instances
are coding challenge problems posed in natural language, each of which consists of question text,
ground-truth solutions, and test cases. Please refer to the main document for more detail.

How many instances are there in total (of each type, if appropriate)? APPS contains 10,000
problems, 232,421 ground-truth solutions, and 131,777 test cases.

Does the dataset contain all possible instances or is it a sample (not necessarily random) of
instances from a larger set? If the dataset is a sample, then what is the larger set? Is the
sample representative of the larger set (e.g., geographic coverage)? If so, please describe how
this representativeness was validated/veriﬁed. If it is not representative of the larger set, please
describe why not (e.g., to cover a more diverse range of instances, because instances were
withheld or unavailable). APPS contains a subset of all possible test cases for its problems. These
test cases are written by problem designers to cover important functionality.

What data does each instance consist of? “Raw” data (e.g., unprocessed text or images) or fea-
tures? In either case, please provide a description. Each instance consists of text and numerical
data.

Is there a label or target associated with each instance? If so, please provide a description.
Each instance is associated with test cases, which provide a ground-truth signal for functional
correctness.

Is any information missing from individual instances? If so, please provide a description,
explaining why this information is missing (e.g., because it was unavailable). This does not
include intentionally removed information, but might include, e.g., redacted text. No.

Are relationships between individual instances made explicit (e.g., users’ movie ratings, social
network links)? If so, please describe how these relationships are made explicit. We remove
duplicate or near-duplicate problems from APPS.

14

Are there recommended data splits (e.g., training, development/validation, testing)? If so,
please provide a description of these splits, explaining the rationale behind them. We pro-
vide a training and test split. The splits were optimized for increasing the number of test cases in the
test split while maintaining a ﬁxed number of problems from each difﬁculty.

Are there any errors, sources of noise, or redundancies in the dataset? If so, please provide a
description. See Section 3 in the main paper for a discussion of test case quality.

Is the dataset self-contained, or does it link to or otherwise rely on external resources (e.g.,
websites, tweets, other datasets)? The dataset is self-contained.

Does the dataset contain data that might be considered conﬁdential (e.g., data that is protected
by legal privilege or by doctor-patient conﬁdentiality, data that includes the content of individ-
uals’ non-public communications)? If so, please provide a description. No.

Does the dataset contain data that, if viewed directly, might be offensive, insulting, threatening,
or might otherwise cause anxiety? If so, please describe why. Unknown.

Does the dataset relate to people? If not, you may skip the remaining questions in this section.
Yes.

Does the dataset identify any subpopulations (e.g., by age, gender)? If so, please describe how
these subpopulations are identiﬁed and provide a description of their respective distributions
within the dataset. No.

Is it possible to identify individuals (i.e., one or more natural persons), either directly or in-
directly (i.e., in combination with other data) from the dataset? If so, please describe how
No.

Does the dataset contain data that might be considered sensitive in any way (e.g., data that re-
veals racial or ethnic origins, sexual orientations, religious beliefs, political opinions or union
memberships, or locations; ﬁnancial or health data; biometric or genetic data; forms of govern-
ment identiﬁcation, such as social security numbers; criminal history)? If so, please provide a
description. No.

Any other comments? No.

B.3 Collection Process

How was the data associated with each instance acquired? Was the data directly observable
(e.g., raw text, movie ratings), reported by subjects (e.g., survey responses), or indirectly in-
ferred/derived from other data (e.g., part-of-speech tags, model-based guesses for age or lan-
guage)? If data was reported by subjects or indirectly inferred/derived from other data, was
the data validated/veriﬁed? If so, please describe how. All data was collected by scraping
problems from coding challenge websites, such as Codewars, AtCoder and Kattis.

What mechanisms or procedures were used to collect the data (e.g., hardware apparatus or
sensor, manual human curation, software program, software API)? How were these mecha-
nisms or procedures validated? We used off-the-shelf and custom-built scrapers. We manually
checked whether scraped data matched text on the websites.

If the dataset is a sample from a larger set, what was the sampling strategy (e.g., deterministic,
probabilistic with speciﬁc sampling probabilities)? Some problems we scraped were left out of
APPS for various reasons, e.g. they required images to solve, they lacked ground-truth solutions and
test cases, or they were duplicate problems.

Who was involved in the data collection process (e.g., students, crowdworkers, contractors)
and how were they compensated (e.g., how much were crowdworkers paid)? All data was
collected by undergraduate and graduate student authors on the paper.

15

Over what timeframe was the data collected? Does this timeframe match the creation time-
frame of the data associated with the instances (e.g., recent crawl of old news articles)? If
not, please describe the timeframe in which the data associated with the instances was created.
Data was collected from late 2020 to early 2021 and reﬁned for six months.

Were any ethical review processes conducted (e.g., by an institutional review board)? If so,
please provide a description of these review processes, including the outcomes, as well as a link
or other access point to any supporting documentation No.

Does the dataset relate to people? If not, you may skip the remainder of the questions in this
section. Yes.

Did you collect the data from the individuals in question directly, or obtain it via third parties
or other sources (e.g., websites)? We scraped data via websites where individuals had publicly
posted problem solutions.

Were the individuals in question notiﬁed about the data collection? If so, please describe
(or show with screenshots or other information) how notice was provided, and provide a link
or other access point to, or otherwise reproduce, the exact language of the notiﬁcation itself.
Users who posted on the Internet were not notiﬁed of our collection, because their examples were
posted publicly.

Did the individuals in question consent to the collection and use of their data? If so, please
describe (or show with screenshots or other information) how consent was requested and pro-
vided, and provide a link or other access point to, or otherwise reproduce, the exact language
to which the individuals consented. N/A

If consent was obtained, were the consenting individuals provided with a mechanism to revoke
their consent in the future or for certain uses? If so, please provide a description, as well as a
link or other access point to the mechanism (if appropriate). N/A

Has an analysis of the potential impact of the dataset and its use on data subjects (e.g., a data
protection impact analysis) been conducted? If so, please provide a description of this analysis,
including the outcomes, as well as a link or other access point to any supporting documentation.
No.

Any other comments? No.

B.4 Preprocessing/Cleaning/Labeling

Was any preprocessing/cleaning/labeling of the data done (e.g., discretization or bucketing,
tokenization, part-of-speech tagging, SIFT feature extraction, removal of instances, processing
of missing values)? If so, please provide a description. If not, you may skip the remainder of
the questions in this section. Yes, as described in Section 3 of the main paper.

Was the “raw” data saved in addition to the preprocessed/cleaned/labeled data (e.g., to support
unanticipated future uses)? If so, please provide a link or other access point to the “raw” data.
No.

Is the software used to preprocess/clean/label the instances available? If so, please provide a
link or other access point. Not at this time.

Any other comments? No.

B.5 Uses

Has the dataset been used for any tasks already? If so, please provide a description. Yes, see
the main paper.

16

Is there a repository that links to any or all papers or systems that use the dataset? If so, please
provide a link or other access point. No.

What (other) tasks could the dataset be used for? N/A

Is there anything about the composition of the dataset or the way it was collected and prepro-
cessed/cleaned/labeled that might impact future uses? For example, is there anything that a
future user might need to know to avoid uses that could result in unfair treatment of individ-
uals or groups (e.g., stereotyping, quality of service issues) or other undesirable harms (e.g.,
ﬁnancial harms, legal risks) If so, please provide a description. Is there anything a future user
could do to mitigate these undesirable harms? We describe how our data collection is legally
compliant in Appendix A.

Are there tasks for which the dataset should not be used? If so, please provide a description.
N/A

Any other comments? No.

B.6 Distribution

Will the dataset be distributed to third parties outside of the entity (e.g., company, institution,
organization) on behalf of which the dataset was created? If so, please provide a description.
Yes, the dataset will be publicly distributed.

the dataset will be distributed (e.g.,

How will
Does the dataset have a digital object
https://github.com/hendrycks/apps.

identiﬁer (DOI)? The dataset

tarball on website, API, GitHub)?
is available at

When will the dataset be distributed? The dataset is currently available.

Will the dataset be distributed under a copyright or other intellectual property (IP) license,
and/or under applicable terms of use (ToU)? If so, please describe this license and/or ToU, and
provide a link or other access point to, or otherwise reproduce, any relevant licensing terms
or ToU, as well as any fees associated with these restrictions. The code for our experimental
framework is distributed under an MIT license. Where applicable,

Have any third parties imposed IP-based or other restrictions on the data associated with the
instances? If so, please describe these restrictions, and provide a link or other access point to,
or otherwise reproduce, any relevant licensing terms, as well as any fees associated with these
restrictions.
In cases where websites that we scrape data from have copyright policies, we abide
by Fair Use according to §107, and we comply with GDPR even though all our problem sources with
ground-truth solutions are based in the US. See Appendix A for details.

Do any export controls or other regulatory restrictions apply to the dataset or to individual
instances? If so, please describe these restrictions, and provide a link or other access point to,
or otherwise reproduce, any supporting documentation. No.

Any other comments? No.

B.7 Maintenance

Who is supporting/hosting/maintaining the dataset? Refer to the main document.

How can the owner/curator/manager of the dataset be contacted (e.g., email address)? Refer
to the main document.

Is there an erratum? If so, please provide a link or other access point. Not at this time.

17

Will the dataset be updated (e.g., to correct labeling errors, add new instances, delete in-
stances)? If so, please describe how often, by whom, and how updates will be communicated
to users (e.g., mailing list, GitHub)? We plan to update the dataset with an additional JSON of
test cases present in the question text for each problem. This will be available through GitHub.

If the dataset relates to people, are there applicable limits on the retention of the data associ-
ated with the instances (e.g., were individuals in question told that their data would be retained
for a ﬁxed period of time and then deleted)? If so, please describe these limits and explain how
they will be enforced No.

Will older versions of the dataset continue to be supported/hosted/maintained? If so, please
describe how. If not, please describe how its obsolescence will be communicated to users. N/A

If others want to extend/augment/build on/contribute to the dataset, is there a mechanism for
them to do so? If so, please provide a description. Will these contributions be validated/ver-
iﬁed? If so, please describe how. If not, why not? Is there a process for communicating/dis-
tributing these contributions to other users? If so, please provide a description. Our dataset
could be extended with additional problems that follow the formatting of existing problems.

Any other comments? No.

C Additional Dataset Information

Expanded Dataset Comparisons. We compared to several datasets in the (Kulal et al., 2019;
Yu et al., 2018; Raychev et al., 2016; Iyer et al., 2018; Lu et al., 2021) main paper. We continue
the comparisons below. Ling et al. (2016) introduce datasets based on Hearthstone and Magic the
Gathering card games for code generation. Oda et al. (2015) provide a language-to-code dataset
using simple code comments. Zavershynskyi et al. (2018) introduce the NAPS dataset for converting
pseudocode to code, obtained by crowdsourcing low-level descriptions of programming exercises,
and apply machine translation techniques to the problem. Recent anecdotal posts on social media have
demonstrated that modern Transformers can in some instances generate JSX code adhering to user
requests, but our work provides precision to the discussion through quantitative evaluation. Allamanis
and Sutton (2013) introduce the GitHub Java Corpus used for performing language modeling on
Java code. Liu et al. (2020a) do a smaller-scale analysis of code generation but with their limited
language-speciﬁc training data models “fail to pass even a single predeﬁned test case” on their 300
test problems, while with our large training set and test set, trained models can pass tens of thousands
of test cases. Zelle and Mooney (1996) and Tang and Mooney (2001) precedes Yu et al. (2018) by
also facilitating the synthesis of database queries, though more recent program synthesis works such
as Wang et al. (2019c) use Spider from Yu et al. (2018).

Table 4 compares APPS to Hearthstone (Ling et al., 2016), Django (Oda et al., 2015), and Zaver-
shynskyi et al. (2018). ‘Number of Programs’ refers to the number of human-written programs or
functions in the dataset, and ‘Number of Exercises’ refers to the number of tasks that the network
must solve. These numbers can differ in datasets such as APPS with multiple human-written solutions
per exercise.

Excluded Keywords.
In creating the GitHub pretraining dataset, we exclude the following key-
words to prevent overlap with coding challenge questions similar to those in APPS: ‘atcoder’,
‘coderbyte’, ‘leetcode’, ‘codeforces’, ‘codewars’, ‘hackerrank’, ‘topcoder’, ‘codechef’, ‘checkio’,
‘HackerEarth’, ‘Programmr’, ‘Exercism’, ‘Codier’, ‘PyBites’, ‘Tynker’, ‘CodinGame’, ‘CodeCom-
bat’, ‘usaco’, ‘IOI’, ‘UVA’, ‘ICFP’, ‘EPIJudge’, ‘SPOJ’, ‘UVaOJ’, ‘judge’, ‘interview’, ‘solution’,
‘coding’, ‘code’, ‘problem’, ‘exercise’, ‘challenge’, ‘algo’, ‘practice’, ‘competitive’, ‘program’.

D Additional Results

Top-5 Performance. Rather than allowing models to generate just one potential solution, we let
models generate ﬁve and we choose the best performing solution. Full top-5 performance results are
in Table 5.

18

Problem
Mahmoud and Ehab play a game called the even-odd game. Ehab chooses his favorite integer n and
then they take turns, starting from Mahmoud. In each player’s turn, he has to choose an integer a and
subtract it from n such that: 1 ≤ a ≤ n. If it’s Mahmoud’s turn, a has to be even, but if it’s Ehab’s
turn, a has to be odd.
If the current player can’t choose any number satisfying the conditions, he loses. Can you determine
the winner if they both play optimally?

—–Input—–
The only line contains an integer n (1 ≤ n ≤ 109), the number at the beginning of the game.

—–Output—–
Output “Mahmoud” (without quotes) if Mahmoud wins and “Ehab” (without quotes) otherwise.

Model Output
n = int(input())
if n % 2 == 0:

print('Mahmoud')

else:

print('Ehab')

Figure 7: The sole interview problem solved by GPT-3. Legitimately solving this problem requires
nontrivial reasoning about the proposed game’s branching possibilities.

a, b = int(input()), int(input())
if a == b:

print(''.join(map(str, [a, b])))

else:

print(''.join(map(str, [a, b])))

Figure 8: Oftentimes, GPT-3 generates outputs with incorrect syntax, such as the above code. Even
though the code is reasonable, bad formatting of the if-else block causes a syntax error.

GPT-3. We evaluate GPT-3 175B on APPS in a few-shot setting. A separate prompt is used for
standard input and call-based questions, and each prompt includes instruction text along with two
example questions and solutions from the corresponding question type. The solutions we select
for each prompt are the shortest solutions passing all test cases for the corresponding problems.
In preliminary experiments, we found that the original GPT-3 175B did not perform well, and the
instruct series was necessary for reasonable generations. Inference on the 5,000 problems in the
APPS test set is possible for approximately $500.

We ﬁnd that GPT-3 only solves 3 problems out of 5,000: two introductory problems and one interview
problem. The two introductory problems are simple interpretation tasks, such as implementing a
speciﬁed algebraic expression. The interview problem requires higher-level thinking and is show
in Figure 7. Legitimately solving this problem would suggest nontrivial reasoning. However, it is
possible that GPT-3 memorized the solution during pretraining, or that it took a lucky guess based on
heuristics in the question.

We also ﬁnd that GPT-3 tends to handle syntax poorly. In Figure 8, we see a generation with improper
formatting of an if-else block, which causes a syntax error. By contrast, GPT-2 0.1B has fewer syntax
errors with three orders of magnitude fewer parameters, and GPT-Neo 2.7B has almost no syntax
errors. These two models are ﬁne-tuned on GitHub and the APPS training set.

More Generated Code Examples. Additional examples of generated code can be found in Fig-
ure 9, Figure 10, and Figure 11.

19

Problem
Given is a directed graph G with N vertices and M edges. The vertices are numbered 1 to N, and
the i-th edge is directed from Vertex A_i to Vertex B_i. It is guaranteed that the graph contains no
self-loops or multiple edges. Determine whether there exists an induced subgraph (see Notes) of G
such that the in-degree and out-degree of every vertex are both 1. If the answer is yes, show one such
subgraph. Here the null graph is not considered as a subgraph.

Model Output
import sys

sys.setrecursionlimit(10 ** 7)
input = sys.stdin.readline
f_inf = float('inf')
mod = 10 ** 9 + 7

def resolve():

n, m = map(int, input().split())
edge = [[] for _ in range(n)]
for _ in range(m):

a, b = map(int, input().split())
edge[a - 1].append(b - 1)
edge[b - 1].append(a - 1)

def dfs(u):

stack = [u]
seen = [False] * n
while stack:

u = stack.pop()
if seen[u]:

continue

seen[u] = True
for v in edge[u]:

if seen[v]:

continue

seen[v] = True
stack.append(v)

res = None
for i in range(n):

if not seen[i]:

seen[i] = True
res = dfs(i)

if not res:

print(-1)

else:

print(res)

if __name__ == '__main__':

resolve()

Figure 9: An example generated by GPT-2 1.5B. The model can sometimes compose function calls.

20

Problem
Given is a tree G with N vertices. The vertices are numbered 1 through N, and the i-th edge connects
Vertex a_i and Vertex b_i. Consider painting the edges in G with some number of colors. We want to
paint them so that, for each vertex, the colors of the edges incident to that vertex are all different.
Among the colorings satisfying the condition above, construct one that uses the minimum number of
colors.

Model Output
import sys
from collections import deque, defaultdict, Counter
from itertools import accumulate, product, permutations, combinations
from operator import itemgetter
from bisect import bisect_left, bisect_right
from heapq import heappop, heappush
from math import ceil, floor, sqrt, gcd, inf
from copy import deepcopy
import numpy as np
import scipy as sp

INF = inf
MOD = 1000000007

n = int(input())
ab = [list(map(int, input().split())) for i in range(n - 1)]

graph = [[] for i in range(n + 1)]
for a, b in ab:

graph[a].append(b)
graph[b].append(a)

visited = [False] * (n + 1)
color = [0] * (n + 1)
color[0] = 1
stack = [1]
while stack:

x = stack.pop()
for y in graph[x]:
if visited[y]:

continue
visited[y] = True
color[y] = color[x] + 1
stack.append(y)

ans = min(color)
print(*ans, sep="\n")

Figure 10: An additional generated example. Here, the model output has many import statements.

21

Problem
There is a special square room with mirrors on each of the four walls. Except for the southwest corner,
there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has
walls of length p, and a laser ray from the southwest corner ﬁrst meets the east wall at a distance
q from the 0th receptor. Return the number of the receptor that the ray meets ﬁrst. (It is guaranteed
that the ray will meet a receptor eventually.)

Example 1:
Input: p = 2, q = 1
Output: 2
Explanation: The ray meets receptor 2 the ﬁrst time it gets reﬂected back to the left wall.

Starter Code

class Solution:

def mirrorReflection(self, p: int, q: int) -> int:

Model Output
class Solution:

def mirrorReflection(self, p: int, q: int) -> int:

self.p = p
self.q = q
self.mirrors = [(0, 1), (0, -1), (1, 0), (-1, 0)]
return self.mirrors[self.p - 1][self.q - 1]

Figure 11: An example using the call-based format with some starter code.

22

