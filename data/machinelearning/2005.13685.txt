0
2
0
2

y
a
M
7
2

]

C
D
.
s
c
[

1
v
5
8
6
3
1
.
5
0
0
2
:
v
i
X
r
a

ProTuner: Tuning Programs with Monte Carlo Tree Search

Ameer Haj-Ali
UC Berkeley

Hasan Genc
UC Berkeley

Qijing Huang
UC Berkeley

William Moses
MIT

John Wawrzynek
UC Berkeley

Krste Asanovi´c
UC Berkeley

Ion Stoica
UC Berkeley

Abstract
We explore applying the Monte Carlo Tree Search (MCTS)
algorithm in a notoriously difﬁcult task: tuning programs for
high-performance deep learning and image processing. We
build our framework on top of Halide and show that MCTS
can outperform the state-of-the-art beam-search algorithm.
Unlike beam search, which is guided by greedy intermediate
performance comparisons between partial and less meaning-
ful schedules, MCTS compares complete schedules and looks
ahead before making any intermediate scheduling decision.
We further explore modiﬁcations to the standard MCTS algo-
rithm as well as combining real execution time measurements
with the cost model. Our results show that MCTS can outper-
form beam search on a suite of 16 real benchmarks.

1 Introduction

Most deep learning and image processing programs rely heav-
ily on loops, which represent the vast majority of a program’s
total execution time. Due to the high number of loops in each
loop nest, it is possible to schedule the loops in many different,
yet functionally equivalent ways. Choosing a bad program
schedule can result in a dramatically worse execution time.
Similar schedules can include different optimizations such
as inlining, tiling, vectorization, and multithreading, which
can signiﬁcantly impact the performance of the program. The
number of possible optimizations grows exponentially with
the number of loops in the loop nest. With the end of Moore’s
law and the booming of new application-speciﬁc integrated
circuits (ASICs), the scheduling challenge becomes harder as
the scheduler also needs to generate different schedules for
different target architectures.

Due to its complexity, scheduling is often done using heuris-
tics and tremendous amounts of hand engineering. Big ven-
dors often hire engineers that are dedicated to manually writ-
ing schedules for different applications. This incurs huge costs
both in terms of time and human capital. Heuristics mostly
fall short in achieving optimal performance [16, 19, 20]. Ide-
ally, the scheduler should consider all the possible schedules

and the target hardware to ﬁnd the optimal schedule. Unfor-
tunately, the space of possible schedules for different hard-
ware targets is prohibitively large to explore. To cope with
that, a recent work [1] proposed using beam search with a
learned cost model to ﬁnd good schedules. While this ap-
proach achieves promising improvements over the baseline
default auto-scheduler in Halide [41], it often fails to ﬁnd the
optimal schedule. The main issue lies in the greediness of
beam search and the inability of the cost model to accurately
predict the performance of partially scheduled (not meaning-
ful) programs, which is needed at every intermediate step of
the beam search. This results in a multiplied error at every
decision made in the beam search tree and an inability to
explore schedules that are less rewarding in the short term but
potentially more rewarding in the long term.

To overcome these challenges we propose ProTuner, which
uses Monte Carlo Tree Search (MCTS) [11]. In ProTuner,
we formulate the scheduling problem as a Markov decision
process (MDP) where each intermediate schedule is repre-
sented as a state and the actions are the different intermediate
optimizations that could be applied next. The reward is propor-
tional to the execution time improvement. The solution would
be the actions that lead to the optimal schedule and hence
solving the MDP can guarantee the optimal schedule. One
promising algorithm to solve MDPs is MCTS. MCTS builds
a search tree using selection, expansion, simulation, and back-
propagation that explore the search space. After some number
of iterations, the tree decides which next step (of intermediate
scheduling optimization) to perform next. When this happens,
a new root is determined and the MCTS starts again. With the
upper conﬁdence bound (UCB) [6] the MCTS is guaranteed
to converge to the optimal solution after enough iterations.

MCTS makes decisions by looking ahead, evaluating com-
plete schedules, avoiding greediness, and considering the ex-
pected long term reward of scheduling decisions, which also
makes it more resilient to noise in the cost model. We, there-
fore, conjecture that MCTS is a better ﬁt for ﬁnding the opti-
mal schedule compared to beam search. To explore that, we
implemented ProTuner on top of Halide [41], evaluated it, and

1

 
 
 
 
 
 
found that ProTuner with MCTS outperforms beam search
or achieves comparable performance on all of the evaluated
benchmarks, achieving up to 3.25× better performance.

Our main contributions are:

• We propose to formulate the scheduling problem as an

MDP and solve it using MCTS with the UCB.

• We build ProTuner on top of Halide and explore dif-
ferent MCTS techniques to improve and ﬁne tune its
performance.

• Rigorous evaluations that show ProTuner achieves up to
3.5× better performance than beam search on a suite of
16 real benchmarks.

• We show how ProTuner can combine real execution time
evaluation with the learned cost model and show this can
further boost the performance.

2 Background

2.1 Halide Scheduling

Halide [41] is a domain-speciﬁc language for image process-
ing and deep learning tasks. Halide’s language abstraction
decouples the algorithmic descriptions of the target image
processing workloads from a speciﬁc mapping of the work-
load on hardware, which we refer to as a “schedule”. This
abstraction provides the user with a clearly deﬁned schedul-
ing space and makes it easier to explore different schedules
automatically. Many decisions need to be made in a Halide
schedule, including the execution order of different functions,
vectorization factors, tiling factors, inlining, memory alloca-
tion strategies, etc. The overall scheduling space is intractable
and expert scheduling can be hard to develop. Therefore, au-
tomatic generation of high-performance Halide schedulings
has been implemented and studied in several prior works
[36] [35] [45] [1].

2.2 Beam Search

Beam search [43] is a heuristic algorithm that explores a deci-
sion tree and searches for the optimal decisions by expanding
a limited number of children with the highest intermediate
rewards. It is widely used for the sequential decision-making
process, such as speech recognition [43] and software schedul-
ing [1]. It builds its search tree with a breadth-ﬁrst search. At
each step of the algorithm, it exhaustively evaluates all the
direct children, sorts the children based on the intermediate
rewards, and keeps the top-k children as the parent nodes
for the next iteration. k is the beam size that determines the
total number of top children to keep at every iteration. It is
essentially a greedy algorithm and thus can get stuck in local
optima.

2.3 Markov Decision Processes

A Markov decision process (MDP) is a discrete stochastic
control process that models sequential decision making in
fully observable environments. It assumes the Markov prop-
erty that the impact of one decision taken in a state only
depends on that state and not the prior decision history. An
MDP model consists of:

• S: A set of possible states, with s0 representing the initial

state.

• A: A set of possible actions.

• R(s, a): A reward function.

• T (s(cid:48)|s, a): A transition function that models the prob-
ability of getting to state s(cid:48) given an action a in state
s.

Solving an MDP means ﬁnding a policy π(s) that chooses an
action to apply based on the current state and optimizes for
the overall expected reward. The decision making process is
modeled as a sequence of state and action pairs (s, a). The
next state s(cid:48) can either be decided deterministically by the pair
(s, a) or stochastically by a probability distribution p(s(cid:48)|s, a).

2.4 Monte Carlo Tree Search

Monte Carlo Tree Search (MCTS) is a method that can solve
MDPs. It combines tree search with random sampling for
ﬁnding the optimal decisions in the MDP. In MCTS, a tree
is built incrementally based on selection, expansion, simula-
tion, and backpropagation. A tree policy is used to select a
node to expand at each iteration of the algorithm. This policy
should balance the exploration and exploitation of the search
algorithm. The node is expanded and a simulation is then
run from the selected node to collect the rewards of the ter-
minal state. The decisions made during the simulation are
determined by a default policy, which can be uniform random
sampling in its simplest form and this is what we use. Lastly
MCTS backpropagates the reward and updates the statistics
of the ancestor nodes. In this paper, the tree policy used is the
UCB [6]:

UCB = ¯X j + 2Cp

(cid:115)

2ln(n)
n j

(1)

where n is the number of times the current parent node has
been visited, n j is the number of times child j has been visited,
¯X j is the average reward of the
and Cp > 0 is a constant.
simulations. The left term ( ¯X j) tracks exploitation while the
right term tracks exploration. Increasing Cp will add more
exploration, and decreasing it will reduce exploration.

According to [25], MCTS offers signiﬁcant advantages
over alpha-beta pruning that minimizes the search space in
the scenario where there is no good evaluation function. The
evaluation of moves in MCTS has been proven to converge to
Minimax.

2

Figure 1: Speedup of greedy and beam search with a cost model trained to predict the cost of the future complete schedules
normalized to greedy and beam search respectively with the original cost model (trained on complete schedules only).

Figure 2: Speedup of greedy and beam search with a cost model trained directly on random schedules of all the benchmark
algorithms themselves, normalized to greedy and beam search respectively with the original cost model (trained on complete
schedules only).

3 Challenges in Beam Search

A beam search-based approach [1] has been recently proposed
as a scheduler in Halide, which achieves state-of-the-art re-
sults. In this approach, a cost model is trained as a proxy
for predicting the true execution time of intermediate sched-
ules used by the beam search to determine which schedules
to take. Unfortunately, the cost model is trained on fully
scheduled programs and cannot predict the execution time of
incomplete/partially-scheduled programs. We also observed
that the cost model often falls short in properly predicting
execution times of fully scheduled programs and thus often
minimal cost does not necessarily mean optimal execution

time. This makes the beam search very sensitive to inaccu-
racies in the cost model. Since beam search queries the cost
model at every scheduling decision, this error aggregates.

We experimented with two techniques to overcome the
challenge of predicting the execution time of incomplete pro-
grams. In the ﬁrst we trained a cost model as was done in [1],
except that we trained it on the fully scheduled benchmarks
that we later run the search on. Figure 2 shows the results on
beam search and greedy search (beam size of one) with the
new cost model. We observe that the performance improves
for some benchmarks while for others it deteriorates and over-
all the performance is similar. This was also observed by the
authors in [1] when they retrained their cost model on the spe-

3

Execution Times Speedup0.01.02.03.0bilateral_gridlocal_laplacianl_meanslens_blurcamera_pipestencil_chainharrishistmax_filterunsharpinterpolateconv_layeriir_blurbgumat_mulresnet50geomeangreedybeamTraining a Value FunctionExecution Times Speedup0.01.02.03.0bilateral_gridlocal_laplacianl_meanslens_blurcamera_pipestencil_chainharrishistmax_filterunsharpinterpolateconv_layeriir_blurbgumat_mulresnet50geomeangreedybeamTraining on the Benchmarksciﬁc benchmark programs that they were also autotuning. The
reason is that even if the model is trained on the benchmarks
that we later run the inference on, it is hard for the cost model
to accurately predict the execution time of incomplete sched-
ules during the search. In the second experiment shown in
Figure 1 we trained the model to predict the future cost of the
current schedule. This also did not work well because there
are multiple options for scheduling the rest of the program
and thus the same partial schedule of a program can lead to
different costs.

To overcome these challenges we formulate the schedul-
ing problem as an MDP. In such a framework, a graph node
represents an intermediate schedule/program, with edges be-
tween nodes representing potential scheduling actions. Thus,
applying a particular schedule to a program could be seen as
a simple graph traversal. Algorithms that solve such MDP’s
seek to ﬁnd a node/set of actions that maximize the reward of
the end state. In our use case, the reward would be the inverse
of the execution time (thereby ensuring that maximizing the
reward gives the fastest program).

MCTS is a promising algorithm for solving MDPs. We
chose to use MCTS for four reasons: it is theoretically guar-
anteed to ﬁnd the best node with sufﬁcient time; its UCB for-
mula balances the exploration of new states and exploitation
of existing good states combined with using the expectation
of future rewards which makes it more resilient to noise; its
ability to look ahead before making a decision avoiding greed-
iness; and the ability to make decisions based on costs of fully
scheduled programs, which means the cost model can predict
their execution time more accurately. Furthermore, MCTS
allows us to combine real execution time measurements and
the cost model’s predictions to further improve performance.

4 The Proposed ProTuner Scheduler

Our MDP is deﬁned by actions that correspond to intermediate
scheduling decisions and states that represent intermediate
schedules. The cost is the execution time of the schedule. To
enumerate the possible schedules and evaluate their costs we
use the same techniques used in [1]. Given an n-dimensional
tensor the scheduling is split to n stages and starting from the
last stage and back to the input, a new scheduling decision
is made at each stage, which proposes a new tiling and a
compute and storage granularity at which to insert the new
stage. The new tilings can be unrolled or spread across parallel
threads or single instruction multiple data (SIMD) lanes. The
costs of the complete schedules (at the end of simulation) are
evaluated using a cost model trained on random programs
that are fully scheduled.

Figure 3 shows the block diagram of ProTuner. The MCTS
starts from the last stage and explores the possible schedules
back to the inputs. At every simulation from one node in
the MCTS the simulation ends by computing the cost from
the cost model and the cost is backpropagated to the parent

Figure 3: The block diagram of ProTuner. The program is fed
to the MCTS that interacts with the learned cost model to ﬁnd
the optimal schedule. To make each intermediate scheduling
decision the MCTS explores the beneﬁts of the possible next
actions based on the average cost but eventually picks the
root that leads to the best cost. Each node stores the average
costs, the best cost so far, and the complete schedule that has
this best cost. The simulation can either be greedy or random.
The backpropagation returns costs or 0/1 based on whether it
outperforms the global best. When running an ensemble of
MCTSes, the next root is picked to be the best from all the
best roots.

nodes with the terminating fully scheduled state. These nodes
update the future best cost so far, the terminating state and the
value function that stores the average cost so far. During the
search the MCTS uses the average cost to determine the next
child to explore. We explored the option to use the best cost
in the search but that resulted in non-smooth value functions
where the children that got lucky earlier and found better
costs received signiﬁcantly more simulations than less lucky
children. This often results in a greedy behavior we are trying
to avoid.

When the computation budget is reached either after pass-
ing the number of allowed iterations or due to time out a
winning action (schedule) for the current stage is determined
and the new root is the state this action leads too. The winner
is determined based on the best cost so far as in [9]. We found

4

ProgramMCTSCostScheduleOptimalScheduleLearned Cost Model(a) Proportion of decisions made by standard and greedy MCT-
Ses on the bilateral_grid test.

(b) Proportion of decisions made by standard and greedy MCT-
Ses on the nl_means test.

(c) Proportion of decisions made by standard and greedy MCT-
Ses on the iir_blur test.

(d) Proportion of decisions made by standard and greedy MCT-
Ses on the max_filter test.

Figure 4: The portion of decisions made by greedy MCTSes for a different number of standard and greedy MCTSes on a suite of
four real applications. X_Y corresponds to X standard MCTSes and Y greedy MCTSes. The overall number of trees is 16.

this to outperforms taking the child with the best average cost
by 25%. This is mainly because it can guarantee that later
steps need to ﬁnd schedules that are better than the best so far
(rather than average best), which can be helpful when fewer
iterations are available. This also allows us to combine real
execution time measurements with cost model predictions at
a negligible overhead.

To further improve our results we run multiple MCTSes in
parallel across multiple cores that synchronize when picking
a new root at every intermediate scheduling decision, which
is the best child from all the best children of all the MCTSes.
In addition to the performance beneﬁts achieved from this
parallelism, an ensemble of MCTSes is proven to outperform
a single MCTS with the number of iterations equal to the
combined number of iterations available in the ensemble [12].

Since MCTS evaluates the program’s cost when it is fully
scheduled, the cost is more reliable than that of beam search,
which evaluates costs of intermediate schedules that are not
meaningful and the cost cannot properly evaluate since it
was and could only be trained on fully scheduled programs.
Unlike beam search, MCTS looks ahead and does not have the

greedy nature of beam search. Furthermore, MCTS does not
need to evaluate the costs of all the children during simulation
or compute their state features (which we found to consume
more than 92.3% of the overhead in beam search). Instead it
randomly and continuously picks a possible child and only
evaluates one state when it is fully scheduled.

4.1

Improving Scheduling Time by Adding
Greedy MCTSes

We explored multiple techniques to improve the scheduling
time of our MCTS. We found that adding some greediness to
our algorithm makes it ﬁnd good schedules in a shorter time.
First, we explored adding greediness by picking the best next
action with probability 1
2 instead of randomly picking an ac-
tion during the simulation phase in the MCTS. This however
did not give us any beneﬁts over simulating random actions.
Instead, we tried to mimic the MCTS scheme in single-player
games with 0/1 rewards. So when running from the ﬁrst root,
it ﬁnds the best cost, and then the children that later become
roots get 1 point if they beat their parent’s cost, otherwise

5

Percentage of Decisions0%25%50%75%100%16_015_112_48_84_121_150_16standardgreedybilateral_gridPercentage of Decisions0%25%50%75%100%16_015_112_48_84_121_150_16standardgreedynl_meansPercentage of Decisions0%25%50%75%100%16_015_112_48_84_121_150_16standardgreedyiir_blurPercentage of Decisions0%25%50%75%100%16_015_112_48_84_121_150_16standardgreedymax_filterall_mcts=[]
all_mcts.append(init_greedy_mcts())
all_mcts.extend(init_standard_mcts(num_mcts=15))
current_root = state0 //empty schedule
best_fully_scheduled_states={}
next_best_roots={}
while(!fully_scheduled){
parallel_for(i=0...15){

best_fully_scheduled_states[i],
next_best_roots[i] =

all_mcts[i].run(root=current_roots[i])

}
best_index = get_best_state_index_from_costs(

best_fully_scheduled_states)
/* Uncomment the next lines to evaluate
the real execution time instead of
estimated cost:
best_index =

get_best_state_index_real_measure(
best_fully_scheduled_states) */

parallel_for(i=0...15){
current_roots[i] =

next_best_roots[best_index]

}
optimal_schedule =

best_fully_scheduled_states[best_index]

fully_scheduled =

next_best_roots[best_index].is_leaf

}

Figure 6: Pseudocode of the MCTS scheduling algorithm that
combines 15 standard MCTSes and one greedy MCTS. The
best next root can be determined based on the best cost of the
best fully scheduled states or based on the best execution time
measurement of the best fully scheduled states as shown in
the commented line.

4.2 Combining the Cost Model and Real Exe-

cution Time Measurement

Despite their inaccuracies, cost models are often used because
the real measurement takes a prolonged time. To compensate
for inaccuracies in the cost model while incurring minimal
additional overhead, we added real execution time measure-
ments at every iteration where a new root is declared. Our
ﬁnal algorithm is shown in Figure 6. The algorithm initializes
one greedy MCTS and 15 standard ones. While the program
is not fully scheduled it runs the MCTSes in parallel from the
current root. The returned best roots are evaluated based on
the best real execution time measurement (the commented
line).

To implement real execution time measurement in our C++
code the head thread forks multiple children. Each compiles

Figure 5: The execution time speed up to the best execution
time on a suite of four real applications (higher is better). X_Y
corresponds to X standard MCTSes and Y greedy MCTSes.
The overall number of trees is 16. The 15_1 setting did best
overall.

0. This normalizes the reward, simpliﬁes the hyperparame-
ter tuning of the cost, and forces the new roots to beat the
costs of their ancestors. However, this resulted in 9% worse
performance.

What we found to work very well was combining stan-
dard MCTSes with an MCTS that simulates greedily. In
the later, after the node to be expanded based on the UCB
formula is determined, it is expanded with a random child
but the simulation is done purely greedily using the cost
model. To determine how many trees should simulate ran-
domly or greedily we experimented with different numbers
of random or greedy MCTSs on four real applications as
shown in Figures 4 and 5. We found that some applications
like bilateral_grid and nl_means beneﬁted from adding
greedy MCTSes while iir_blur and max_filter did not.
We also observed that it is sufﬁcient to use a single MCTS that
simulates greedily as it made a good balance between greedi-
ness and uniform exploration. Figure 4 shows the number of
decisions made by greedy MCTSes as a function of different
numbers of random and greedy MCTSes. We observe that
adding more greedy MCTSes did not change the number of
decisions made by greedy MCTSes for nl_means, which ben-
eﬁts from greediness. For bilateral_grid there was a small
increase in the number of decisions by greedy MCTSes as we
increased the number of greedy MCTSes but this did not im-
pact the performance as we found that greedy MCTSes often
found similar best states. For iir_blur and max_filter that
beneﬁt mostly from standard MCTSes, adding more greedy
MCTSes made a small increase in the number of decisions
made by greedy MCTSes but on the other hand the perfor-
mance got worse.

6

Name

mcts_30s

mcts_10s

mcts_1s

mcts_Cp10_30s

mcts_sqrt2_30s

mcts_cost+real_30s

mcts_cost+real_1s

Seconds for Iteration

30

10

1

30

30

30

1

)

)

)

(1 +

(1 +

(1 +

1
∑i ExecTimei
n j
1
∑i ExecTimei
n j
1
∑i ExecTimei
n j

Expansion Formula
(cid:113) ln(n)
n j
(cid:113) ln(n)
n j
(cid:113) ln(n)
n j
(cid:113) ln(n)
n j
√
(cid:113) 2ln(n)
2
n j
(cid:113) ln(n)
n j
(cid:113) ln(n)
n j

1
∑i ExecTimei
n j

1
ExecTimei
n j

(1 + 10

1
∑i ExecTimei
n j

(1 +

(1 +

+

)

)

1
∑i ExecTimei
n j

∑i

)

Measurement

cost model

cost model

cost model

cost model

cost model

cost model
+ real
cost model
+ real

Table 1: The MCTS conﬁgurations explored. We explored different timeouts (time too determine a new root) in seconds per
MCTS iteration, expansion formulas where we modify the UCB, and execution time measurement schemes. mcts_sqrt2_30s is
the algorithm that gives the most weight to exploration and is the closest to the original UCB formula. mcts_Cp10_30s gives
the second highest weight to exploration. mcts_cost+real_30s combines mcts_30s from the ﬁrst row and real execution
time measurement. mcts_10s and mcts_1s reduce the seconds for iteration to ten seconds and one second, respectively.
mcts_cost+real_1s combines mcts_1s from the ﬁrst row and real execution time measurement. mcts_sqrt2_30s, uses the
original UCB formula, and encourages much more exploration than the other MCTS algorithms. We used Cp = 1√
as suggested
2
in [28], which showed that it works well with rewards in range [0, 1] as it satisﬁes the Hoeffding inequality. Multiplying the
exploitation term with the exploration term encourages early exploitation.

a benchmark application serially for each of the candidate
schedules returned by the greedy and standard MCTSes. Af-
terward, each of the compiled benchmark applications is run
serially (to make sure they do not interfere with each other’s
run). The schedule with the best real execution time, rather
than the one with the lowest cost, is used as the new root of
the MCTSes for the next iteration.

To compile the benchmark applications, we used Halide’s
rudimentary “RunGen” wrapper, described in the ofﬁcial doc-
umentation [27]. RunGen wraps a solitary scheduled Halide
function (which is what we compiled) into a simple bench-
mark application that returns the execution time of the sched-
uled program.

The RunGen wrapper fails to compile an error-free pro-
gram for various applications, such as camera_pipe and bgu.
For these applications, we instead compiled the scheduled
functions with the custom wrappers found under the apps
directory in the ofﬁcial Halide repository.

We could not use real execution time measurements for
ResNet50 as it requires many simultaneously scheduled func-
tions that a single forked child cannot run on its own. There-
fore, for ResNet50, we report the results from the MCTS run
that schedules it using the cost model only.

5 Evaluation

To evaluate ProTuner we built it on top of Halide in C++. We
run ProTuner on AWS m5.8xlarge instances. These instances
run Intel Xeon Platinum 8259CL processors with 16 physical
cores with, 128 GB RAM and 100 GB SSD storage. AWS
often provides different CPUs for different instances even if
they are from the same type (e.g., m5.8xlarge can have Intel
Xeon Platinum 8259CL processors or Intel Xeon Platinum
8175M processors). To minimize variance between runs we
run all our results on the same instance, during the same
time of the day, when it is night time in the time zone and
after turning off hyperthreading. Details for reproducing our
results are available in the appendix. The code will also be
open-sourced for further research and development.

We set the timeout limit for picking a new root in the MCTS
to 30 seconds. We also explore reducing that to one second
and include real execution time measurements. We use 16
MCTS (one greedy, 15 standard) that run in parallel and syn-
chronize every timeout for picking a new root. For an apples-
to-apples comparison, we also run 16 beam searches in paral-
lel. We use the open-sourced code of Halide’s beam search
algorithm with the artifacts published by the original authors
with the same conﬁguration of provided in [1] with a beam
size of 32 and ﬁve passes (iterations of beam search). We also
compared our results to a greedy auto-scheduler (beam size
of 1), the default scheduler on Halide’s master branch, and

7

Figure 7: The minimum cost found by every algorithm normalized to the best cost found by all the algorithms on a suite of 16
real benchmarks.

random search. Random search does not use the cost model.
It runs for ten minutes and outputs the program with the best
real execution time it found. The other algorithms run with
three different seeds and the best performing schedule found
by each algorithm is reported.

We auto-scheduled a suit of 16 real applications. These
applications range from matrix multiplications to various
blurs, convolutions and interpolations, to full implementation
of ResNet50 [21]. These applications were taken from the
baseline beam search work we compare against and are avail-
able on the Halide repository. We experimented with multiple
MCTS conﬁgurations as shown in Table 1. We mainly ex-
perimented with different timeouts for determining a new
root while running the MCTS algorithm, the expansion for-
mula that determines, which child in the tree gets expanded
and integrating real execution time measurements during the
search.

5.1 Cost

Figure 7 shows the minimum costs found by our MCTS al-
gorithms compared to random, greedy, and beam search. The
costs are normalized to the best cost found by all the algo-
rithms. The cost of ResNet50 is omitted because the applica-
tion includes multiple stages, each stage is auto-scheduled sep-
arately (with costs in different ranges) and later the stages are
merged back to form the ﬁnal application. We observe that our
MCTS outperforms beam, greedy, random search cost-wise in
geometric mean, in all the MCTS conﬁgurations. This means

8

that with a cost model that has 100% accuracy, our MCTS
achieves better performance than that of beam, greedy, and
random search. mcts_Cp10_30s costs outperform the costs
of beam search in all the benchmarks. mct_30s outperforms
beam search in all the benchmarks except iir_blur, in which
it achieves costs 4.5% worse than beam search. mct_10s out-
performs beam search in all the benchmarks except nl_means,
and iir_blur in which it achieves costs 8.9% and 1.1%
worse than beam search, respectively. mcts_sqrt2_30s out-
performs beam search in all the benchmarks except nl_means
and iir_blur, which achieve costs 5.2% and 2.4% worse
than beam search, respectively. mcts_cost+real_30s and
mcts_cost+real_1s achieve the worst geometric mean cost
among the MCTS algorithms. This means that they found
schedules with better execution times but at higher costs.

5.2 Execution Time

Figure 8 shows the minimum execution time each algorithm
found normalized to the best execution time found by all the
algorithms. Note that the scale in costs and execution times
is different. Similar to the costs, in geometric mean, all the
MCTS algorithms outperform beam search (1.06×-1.36×),
even mcts_1s, which gives one second for each MCTS itera-
tion. ur biggest execution time improvement is observed in
interpolate where we achieve 1.8×-3.25× better perfor-
mance in the different MCTS algorithms.

As

and
mcts_cost+real_1s achieve the best performance in

mcts_cost+real_30s

expected,

Figure 8: The minimum execution time found by every algorithm normalized to the best execution time found by all the
algorithms on a suite of 16 real benchmarks.

geometric mean. This is despite not achieving the best
geometric mean in costs. This shows that real execution time
measurement is effective. Interestingly, mcts_cost+real_1s
achieves better performance than mcts_cost+real_30s.
The ﬁrst is less likely to overﬁt to the cost model than the
second. A clear example can be seen in conv_layer, which
is the smallest benchmark. While both mcts_cost+real_1s
and mcts_cost+real_30s outperform the other MCTS
algorithms, the ﬁrst achieves better performance as it stops
evaluating the cost model earlier and hence it is less likely to
overﬁt to the cost model, especially on smaller benchmarks.
We observe that mcts_10s achieves similar performance
to mcts_30s and mcts_sqrt2_30s, and better performance
than mcts_Cp10_30s in geometric mean. This means that
10 seconds per MCTS iteration is sufﬁcient for our bench-
marks. Adding more time might be useful for large bench-
marks but can be harmful to smaller benchmarks where the
MCTS might overﬁt to the cost model. An ideal conﬁguration
should consider the size of the application when setting the
MCTS parameters.

plications, such as conv_layer and mat_mul, this time is
dominated by the compilation and benchmarking time. For
larger applications, this time is dominated by the search time.
Our performance analysis shows that most of the search time
(88%) is spent during the generation of new children (sched-
ules) in the simulation phase and only 7.5% of the time is
spent in the cost evaluation. However, our standard MCTS
simulation needs a single randomly generated child. The rest
of the children are generated but not used. Therefore we see a
potential for 8× speedup in the search time of MCTS, which
we seek to implement in future work.

For mcts_cost+real_1s and mcts_cost+real_30s the
average auto-scheduling time is 23 and 35 minutes, respec-
tively. Most benchmarks require roughly 3× more time to
auto-schedule with real execution time measurement when
the MCTS iteration is set to 30 seconds. This time mostly
consumed in the forked children processes that compile and
evaluate the candidates of potential next roots serially. While
it might seem to be inefﬁcient to do this serially, we chose
do it that way to avoid interference between threads during
execution time measurement.

5.3 Search Time

Our MCTS algorithms with the cost model schedule programs
in seconds to minutes. Among all the benchmarks, the average
auto-scheduling time of mcts_1s, mcts_10s, and mcts_30s
are 31, 155, 422 seconds respectively. This includes the time
to compile the search code, the search time, and the time
to compile and benchmark the applications. In smaller ap-

5.4 Autotuning with Limited Time Budget

Figure 9 shows the autotuning performance comparison be-
tween beam search and MCTS. We limit the autotuning time
to 15 minutes for each application. This time includes the
compilation and execution time of the benchmarks as well
as the search time. The execution time of the generated pro-

9

Figure 9: Execution time speedup normalized to the best execution time using beam search, mcts_1s, and mcts_0.5s with
autotuning on a suite of 16 real benchmarks. Each algorithm is rerun with a different seed until a timeout of 15 minutes is reached
and the bests performance found by each algorithm is reported.

gram is normalized to the best execution time found by beam
search and MCTS. For time efﬁciency we use mcts_1s. We
further explored using half a second per MCTS iteration
(mcts_0.5s), which allows for more real execution time mea-
surements during autotuning. Each algorithm is rerun with
a different seed until the timeout of 15 minutes is reached
and the best performance found by each algorithm is reported.
mcts_0.5s achieves the best overall performance and outper-
forms beam search by up to 3.43× and by 1.35× in geometric
mean, in the same time budget. mcts_1s also outperforms
beam search by up to 3× and by 1.29× in geometric mean in
the same time budget. This is mainly due to more accurate
scheduling decisions derived by meaningful costs of fully
scheduled programs rather than incomplete programs.

6 Related Work

Multiple previous attempts to automatically schedule Halide
programs have been proposed. In the original paper [41],
heuristics and genetic search over random schedule rewrites
were used. The scheduling relied on measuring real execution
time, which resulted in a search time that can get prolonged
to days for moderate benchmarks. OpenTuner [4] autotunes
a program using an AUC-Bandit-meta-technique-directed
ensemble selection of algorithms. It is effective in scheduling
simple pipelines [36].

The auto-scheduler that comes with the master Halide repo,
which we compare against in Section 5 is based on [35]. It
uses a cost model with a greedy search algorithm that allows
it to run quickly, with not autotuning or benchmarking at all.
However, it only considers a ﬁxed set of optimization heuris-
tics for things like parallelism, vectorization and unrolling,

and a single level of tiling and fusion. [26] improved this cost
model, but did not expand the restricted search space. [44, 45]
improves the search space and uses a manual cost model.
However, the search space is still smaller than ours.

Many compilers that use loop polyhedral analysis to per-
form automatic scheduling of afﬁne loop nests [7,8,10,18,36,
50]. Many possible Halide schedules are excluded in these
compilers. However, it might be possible to use the polyhedral
representation in building more accurate cost models, which
we plan to do in future work.

AutoTVM [14] uses tree-based algorithms to auto-schedule
programs on TVM [13], which is an optimization stack for
deep learning. This approach however still requires the user
to manually write the search space for each loop. Further-
more, each operation is optimized in isolation without ex-
ploring large programs. [3] uses deep reinforcement learning
to schedule deep learning pipelines and improves the perfor-
mance compared to AutoTVM.

Machine learning in compiler optimization has been pro-
posed in many prior works [5, 51]. This includes phase or-
dering [2, 17, 23, 24, 29, 46], tiling factors [42], mappings of
kernels to CPUs or GPUs [15] with supervised learning, auto-
vectorization [19,30,32,34,37–40,47–49] and the throughput
of basic blocks [33].

Multi-Level Intermediate Representation (MLIR) [31] has
been recently proposed to help with scaling the performance
with the end of Moore’s law. One objective of MLIR is to
represent kernels in a form suitable for optimization, and allow
easy integration of search algorithms such as reinforcement
learning, MCTS, and beam search.

10

7 Future Work

We see multiple future directions for this work. We could com-
bine a value function cost model that can predict the advantage
of taking an action instead of running the MCTS simulation.
Another direction can include applying deep reinforcement
learning methods to solve the scheduling MDP as done in
similar domains in compiler optimization in [3, 19, 20, 22].
We believe that if deep reinforcement learning (with a neu-
ral network) can generalize in that case then the runtime of
the algorithm can be signiﬁcantly improved as the algorithm
will only need to run inference rather than retrain/research
from scratch as the case in MCTS or beam search. With lim-
ited resources, more accurate cost models are necessary for
scheduling, especially with the recent trends in customized
hardware and the explosion of new applications. Such cost
models need to consider the target hardware parameters and
program features.

Another point for improvement in our implementation is
in generating the next states during the random simulation.
During the MCTS simulation phase, our implementation now
generates all the possible children (next possible intermediate
schedules) and then randomly picks one child. In this setting,
our algorithm’s cost evaluation overhead is 7.5% while 88%
of the time is spent on enumerating children that our standard
MCTSes do not use. In other words, we see the potential for
8× runtime improvement for our MCTS algorithm. Different
conﬁgurations of the MCTS impact the performance differ-
ently. Some applications seem to beneﬁt more from greedy
behavior while others work better with a random one. The
Cp could be further tuned and our performance could be im-
proved if we had a different Cp for different programs. This is
because different programs have different costs/runtimes and
thus using the same Cp for all programs encourages less ex-
ploration in shorter programs. Furthermore, as we go deeper
into the MCTS, the Cp could be reduced to encourage less ex-
ploration as the standard deviation in the costs of the children
decreases. We also observed that our MCTS can overﬁt to the
cost model if we run it for too long.

We plan to extend the search space to include more op-
timizations currently pruned such as vector sizes different
than the native vector size, or not enforcing the multi-core
parallelism to be at the outermost loop level. We also plan to
explore more hardware targets and experiment with more au-
totuning methods that can further improve the performance.

8 Conclusion

We proposed and developed ProTuner: a framework that uses
an MCTS-based algorithm to automatically tune programs
for high-performance deep learning and image processing
applications. Our results demonstrated up to 3.25× better
performance compared to the state-of-the-art beam-search al-
gorithm. Looking forward, we foresee a potential opportunity

to continue scaling performance—despite the end of Moore’s
Law—through automatic program tuning and optimization,
with machine learning algorithms such as MCTS.

References

[1] Andrew Adams, Karima Ma, Luke Anderson, Riyadh
Baghdadi, Tzu-Mao Li, Michael Gharbi, Benoit Steiner,
Steven Johnson, Kayvon Fatahalian, Fredo Durand, et al.
Learning to optimize halide with tree search and ran-
dom programs. ACM Transactions on Graphics (TOG),
38(4):1–12, 2019.

[2] Felix Agakov, Edwin Bonilla, John Cavazos, Bjorn
Franke, Grigori Fursin, Michael FP O’Boyle, John
Thomson, Marc Toussaint, and Christopher KI Williams.
Using machine learning to focus iterative optimization.
In Proceedings of the International Symposium on Code
Generation and Optimization, pages 295–305. IEEE
Computer Society, 2006.

[3] Byung Hoon Ahn, Prannoy Pilligundla, and Hadi Es-
maeilzadeh. Reinforcement learning and adaptive sam-
pling for optimized dnn compilation. arXiv preprint
arXiv:1905.12799, 2019.

[4] Jason Ansel, Shoaib Kamil, Kalyan Veeramachaneni,
Jonathan Ragan-Kelley, Jeffrey Bosboom, Una-May
O’Reilly, and Saman Amarasinghe. Opentuner: An ex-
tensible framework for program autotuning. In Proceed-
ings of the 23rd international conference on Parallel
architectures and compilation, pages 303–316. ACM,
2014.

[5] Amir H Ashouri, William Killian, John Cavazos, Gian-
luca Palermo, and Cristina Silvano. A survey on com-
piler autotuning using machine learning. ACM Comput-
ing Surveys (CSUR), 51(5):1–42, 2018.

[6] Peter Auer, Nicolo Cesa-Bianchi, and Paul Fischer.
Finite-time analysis of the multiarmed bandit problem.
Machine learning, 47(2-3):235–256, 2002.

[7] Riyadh Baghdadi, Ulysse Beaugnon, Albert Cohen, To-
bias Grosser, Michael Kruse, Chandan Reddy, Sven Ver-
doolaege, Adam Betts, Alastair F Donaldson, Jeroen
Ketema, et al. Pencil: A platform-neutral compute inter-
mediate language for accelerator programming. In 2015
International Conference on Parallel Architecture and
Compilation (PACT), pages 138–149. IEEE, 2015.

[8] Riyadh Baghdadi, Jessica Ray, Malek Ben Romdhane,
Emanuele Del Sozzo, Abdurrahman Akkas, Yunming
Zhang, Patricia Suriana, Shoaib Kamil, and Saman Ama-
rasinghe. Tiramisu: A polyhedral compiler for express-
ing fast and portable code. In 2019 IEEE/ACM Interna-

11

tional Symposium on Code Generation and Optimiza-
tion (CGO), pages 193–205. IEEE, 2019.

[9] Yngvi Bjornsson and Hilmar Finnsson. Cadiaplayer: A
simulation-based general game player. IEEE Transac-
tions on Computational Intelligence and AI in Games,
1(1):4–15, 2009.

[10] Uday Bondhugula, Albert Hartono, Jagannathan Ra-
manujam, and Ponnuswamy Sadayappan. A practical
automatic polyhedral parallelizer and locality optimizer.
In Proceedings of the 29th ACM SIGPLAN Conference
on Programming Language Design and Implementation,
pages 101–113, 2008.

[11] Cameron B Browne, Edward Powley, Daniel White-
house, Simon M Lucas, Peter I Cowling, Philipp
Rohlfshagen, Stephen Tavener, Diego Perez, Spyridon
Samothrakis, and Simon Colton. A survey of monte
carlo tree search methods. IEEE Transactions on Com-
putational Intelligence and AI in games, 4(1):1–43,
2012.

[12] Guillaume MJ-B Chaslot, Mark HM Winands, and
H Jaap van Den Herik. Parallel monte-carlo tree search.
In International Conference on Computers and Games,
pages 60–71. Springer, 2008.

[13] Tianqi Chen, Thierry Moreau, Ziheng Jiang, Haichen
Shen, Eddie Yan, Leyuan Wang, Yuwei Hu, Luis Ceze,
Carlos Guestrin, and Arvind Krishnamurthy. Tvm: end-
arXiv
to-end optimization stack for deep learning.
preprint arXiv:1802.04799, 2018.

[14] Tianqi Chen, Lianmin Zheng, Eddie Yan, Ziheng Jiang,
Thierry Moreau, Luis Ceze, Carlos Guestrin, and Arvind
Krishnamurthy. Learning to optimize tensor programs.
In Advances in Neural Information Processing Systems,
pages 3389–3400, 2018.

[15] Chris Cummins, Pavlos Petoumenos, Zheng Wang, and
Hugh Leather. End-to-end deep learning of optimiza-
tion heuristics. In 2017 26th International Conference
on Parallel Architectures and Compilation Techniques
(PACT), pages 219–232. IEEE, 2017.

[16] Chris Cummins, Pavlos Petoumenos, Zheng Wang, and
Hugh Leather. Synthesizing benchmarks for predictive
modeling. In 2017 IEEE/ACM International Symposium
on Code Generation and Optimization (CGO), pages
86–99. IEEE, 2017.

[17] Grigori Fursin, Cupertino Miranda, Olivier Temam,
Mircea Namolaru, Elad Yom-Tov, Ayal Zaks, Bilha
Mendelson, Edwin Bonilla, John Thomson, Hugh
Leather, et al. Milepost gcc: machine learning based
research compiler. 2008.

[18] Tobias Grosser, Armin Groesslinger, and Christian
Lengauer. Polly—performing polyhedral optimizations
on a low-level intermediate representation. Parallel
Processing Letters, 22(04):1250010, 2012.

[19] Ameer Haj-Ali, Nesreen K Ahmed, Ted Willke,
Yakun Sophia Shao, Krste Asanovic, and Ion Stoica.
Neurovectorizer: end-to-end vectorization with deep
In Proceedings of the 18th
reinforcement learning.
ACM/IEEE International Symposium on Code Genera-
tion and Optimization, pages 242–255, 2020.

[20] Ameer Haj-Ali, Qijing Huang, William Moses, John
Xiang, John Wawrzynek, Krste Asanovic, and Ion Sto-
ica. Autophase: Juggling hls phase orderings in random
forests with deep reinforcement learning. In Third Con-
ference on Machine Learning and Systems (ML-Sys),
2020.

[21] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian
Sun. Deep residual learning for image recognition. In
Proceedings of the IEEE conference on computer vision
and pattern recognition, pages 770–778, 2016.

[22] Qijing Huang, Ameer Haj-Ali, William Moses, John Xi-
ang, Ion Stoica, Krste Asanovic, and John Wawrzynek.
Autophase: Compiler phase-ordering for hls with deep
reinforcement learning. In 2019 IEEE 27th Annual In-
ternational Symposium on Field-Programmable Custom
Computing Machines (FCCM), pages 308–308. IEEE,
2019.

[23] Qijing Huang, Ruolong Lian, Andrew Canis, Jongsok
Choi, Ryan Xi, Stephen Brown, and Jason Anderson.
The effect of compiler optimizations on high-level syn-
thesis for fpgas. In Field-Programmable Custom Com-
puting Machines (FCCM), 2013 IEEE 21st Annual In-
ternational Symposium on, pages 89–96. IEEE, 2013.

[24] Qijing Huang, Ruolong Lian, Andrew Canis, Jongsok
Choi, Ryan Xi, Nazanin Calagar, Stephen Brown, and
Jason Anderson. The effect of compiler optimiza-
tions on high-level synthesis-generated hardware. ACM
Transactions on Reconﬁgurable Technology and Systems
(TRETS), 8(3):14, 2015.

[25] Tomas Jakl. Arimaa challenge-comparission study of

mcts versus alpha-beta methods. 2011.

[26] Abhinav Jangda and Uday Bondhugula. An effective
fusion and tile size model for optimizing image process-
ing pipelines. ACM SIGPLAN Notices, 53(1):261–275,
2018.

[27] Steven Johnson.

Running and benchmarking
Halide GitHub Repository:
halide generators.
https://github.com/halide/Halide/blob/master/README
_rungen.md, Aug 2019.

12

[28] Levente Kocsis, Csaba Szepesvari, and Jan Willemson.
Improved monte-carlo search. Univ. Tartu, Estonia, Tech.
Rep, 1, 2006.

[29] Sameer Kulkarni and John Cavazos. Mitigating the
compiler optimization phase-ordering problem using
machine learning. In Proceedings of the ACM Inter-
national Conference on Object Oriented Programming
Systems Languages and Applications, OOPSLA ’12,
2012.

[30] Samuel Larsen and Saman Amarasinghe. Exploiting
superword level parallelism with multimedia instruction
sets, volume 35. ACM, 2000.

[31] Chris Lattner, Jacques Pienaar, Mehdi Amini, Uday
Bondhugula, River Riddle, Albert Cohen, Tatiana Sh-
peisman, Andy Davis, Nicolas Vasilache, and Oleksandr
Zinenko. Mlir: A compiler infrastructure for the end of
moore’s law. arXiv preprint arXiv:2002.11054, 2020.

[32] Daniel S McFarlin, Volodymyr Arbatov, Franz
Franchetti, and Markus Puschel. Automatic simd
vectorization of fast fourier transforms for the larrabee
In Proceedings of the
and avx instruction sets.
international conference on Supercomputing, pages
265–274. ACM, 2011.

[33] Charith Mendis, Alex Renda, Saman Amarasinghe, and
Michael Carbin. Ithemal: Accurate, portable and fast
basic block throughput estimation using deep neural
networks. arXiv preprint arXiv:1808.07412, 2018.

[34] Charith Mendis, Cambridge Yang, Yewen Pu, Saman
Amarasinghe, and Michael Carbin. Compiler auto-
vectorization with imitation learning. In Advances in
Neural Information Processing Systems, pages 14598–
14609, 2019.

[35] Ravi Teja Mullapudi, Andrew Adams, Dillon Sharlet,
Jonathan Ragan-Kelley, and Kayvon Fatahalian. Auto-
matically scheduling halide image processing pipelines.
ACM Transactions on Graphics (TOG), 35(4):1–11,
2016.

[36] Ravi Teja Mullapudi, Vinay Vasista, and Uday Bond-
hugula. Polymage: Automatic optimization for image
processing pipelines. ACM SIGARCH Computer Archi-
tecture News, 43(1):429–443, 2015.

[37] Dorit Nuzman, Sergei Dyshel, Erven Rohou, Ira Rosen,
Kevin Williams, David Yuste, Albert Cohen, and Ayal
Zaks. Vapor simd: Auto-vectorize once, run everywhere.
In Proceedings of the 9th Annual IEEE/ACM Interna-
tional Symposium on Code Generation and Optimiza-
tion, pages 151–160. IEEE Computer Society, 2011.

[38] Vasileios Porpodas. Supergraph-slp auto-vectorization.
In 2017 26th International Conference on Parallel Ar-
chitectures and Compilation Techniques (PACT), pages
330–342. IEEE, 2017.

[39] Vasileios Porpodas and Timothy M Jones. Throttling
automatic vectorization: When less is more. In 2015
International Conference on Parallel Architecture and
Compilation (PACT), pages 432–444. IEEE, 2015.

[40] Vasileios Porpodas, Alberto Magni, and Timothy M
Jones. Pslp: Padded slp automatic vectorization.
In
Proceedings of the 13th Annual IEEE/ACM Interna-
tional Symposium on Code Generation and Optimiza-
tion, pages 190–201. IEEE Computer Society, 2015.

[41] Jonathan Ragan-Kelley, Connelly Barnes, Andrew
Adams, Sylvain Paris, Fredo Durand, and Saman Ama-
rasinghe. Halide: a language and compiler for optimiz-
ing parallelism, locality, and recomputation in image
processing pipelines. Acm Sigplan Notices, 48(6):519–
530, 2013.

[42] Mohammed Rahman, Louis-Noël Pouchet, and P Sa-
dayappan. Neural network assisted tile size selection.
In International Workshop on Automatic Performance
Tuning (IWAPT’2010). Berkeley, CA: Springer Verlag,
2010.

[43] D Raj Reddy et al. Speech understanding systems: A
summary of results of the ﬁve-year research effort. De-
partment of Computer Science. Carnegie-Mellon Uni-
versity, Pittsburgh, PA, 17, 1977.

[44] Savvas Sioutas, Sander Stuijk, Henk Corporaal, Twan
Basten, and Lou Somers. Loop transformations leverag-
ing hardware prefetching. In Proceedings of the 2018
International Symposium on Code Generation and Opti-
mization, pages 254–264, 2018.

[45] Savvas Sioutas, Sander Stuijk, Luc Waeijen, Twan Bas-
ten, Henk Corporaal, and Lou Somers. Schedule syn-
thesis for halide pipelines through reuse analysis. ACM
Transactions on Architecture and Code Optimization
(TACO), 16(2):1–22, 2019.

[46] Mark Stephenson, Saman Amarasinghe, Martin Martin,
and Una-May O’Reilly. Meta optimization: Improving
compiler heuristics with machine learning. In Proceed-
ings of the ACM SIGPLAN 2003 Conference on Pro-
gramming Language Design and Implementation, PLDI
’03, 2003.

[47] Kevin Stock, Louis-Noël Pouchet, and P Sadayappan.
Using machine learning to improve automatic vector-
ization. ACM Transactions on Architecture and Code
Optimization (TACO), 8(4):50, 2012.

13

[48] Xinmin Tian, Hideki Saito, Ernesto Su, Abhinav Gaba,
Matt Masten, Eric Garcia, and Ayal Zaks. Llvm frame-
work and ir extensions for parallelization, simd vector-
ization and ofﬂoading. In 2016 Third Workshop on the
LLVM Compiler Infrastructure in HPC (LLVM-HPC),
pages 21–31. IEEE, 2016.

[49] Konrad Trifunovic, Dorit Nuzman, Albert Cohen, Ayal
Zaks, and Ira Rosen. Polyhedral-model guided loop-nest
auto-vectorization. In 2009 18th International Confer-
ence on Parallel Architectures and Compilation Tech-
niques, pages 327–337. IEEE, 2009.

[50] Nicolas Vasilache, Oleksandr Zinenko, Theodoros
Theodoridis, Priya Goyal, Zachary DeVito, William S
Moses, Sven Verdoolaege, Andrew Adams, and Albert
Cohen. Tensor comprehensions: Framework-agnostic
high-performance machine learning abstractions. arXiv
preprint arXiv:1802.04730, 2018.

[51] Zheng Wang and Michael O’Boyle. Machine learning
in compiler optimization. Proceedings of the IEEE,
106(11):1879–1901, 2018.

14

source ~/.bashrc
conda create --name halide python=3
conda activate halide
pip install torch torch-vision numpy
conda install -c anaconda libpng
sudo apt-get install libjpeg-dev
export LD_LIBRARY_PATH=~/llvm-project/Halide/bin
cd ~/llvm-project/Halide/apps/autoscheduler/\
paper_results_scripts
./generate_all_apps_results

Appendix

8.1 Running

Once the Github repository is cloned and the machine is setup
run:

./generate_all_apps_results.sh

inside Halide/apps/autoscheduler/paper_results_scripts direc-
tory.

8.2 Setting AWS Instance

we use Ubuntu Server 18.04 LTS (HVM), SSD Volume Type
- ami-003634241a8fcdec0 (64-bit x86) m5.8xlarge instances
with 100GB Storage.

8.2.1 Turning Off Hyperthreading

#!/bin/bash
for i in {16..31}; do

echo "Disabling logical HT core $i."
echo 0 > /sys/devices/system/cpu/cpu${i}/online;

done

8.2.2 Set Up

sudo apt-get install libcurl4-openssl-dev libssl-dev
uuid-dev zlib1g-dev libpulse-dev -y
#Might need :
#sudo apt-get clean
#sudo apt-get update
sudo snap install cmake --classic
git clone https://github.com/llvm/llvm-project.git
cd llvm-project
git checkout release/9.x # to build LLVM 9.x
mkdir build
mkdir install
cd build
cmake -DLLVM_ENABLE_PROJECTS="clang;lld;clang-tools-extra"
-DLLVM_ENABLE_RTTI=ON -DLLVM_ENABLE_TERMINFO=OFF
-DLLVM_TARGETS_TO_BUILD="X86;ARM;NVPTX;AArch64;Mips;PowerPC;Hexagon"
-DLLVM_ENABLE_ASSERTIONS=ON -DCMAKE_BUILD_TYPE=Release
-DLLVM_BUILD_32_BITS=OFF -DCMAKE_INSTALL_PREFIX=../install
../llvm
make install -j16
export LLVM_CONFIG=~/llvm-project/install/bin/llvm-config
cd ..
git clone https://github.com/Anonymous/Halide
cd Halide
make -j30
install anaconda
curl -O https://repo.anaconda.com/archive/Anaconda3-2019.03-Linux-x86_64.sh
sha256sum Anaconda3-2019.03-Linux-x86_64.sh
bash Anaconda3-2019.03-Linux-x86_64.sh

15

