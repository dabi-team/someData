PySchedCL: Leveraging Concurrency in
Heterogeneous Data-Parallel Systems

Anirban Ghose, Siddharth Singh, Vivek Kulaharia, Lokesh Dokara, Srijeeta Maity and Soumyajit Dey

1

0
2
0
2

p
e
S
6
1

]

C
D
.
s
c
[

1
v
2
8
4
7
0
.
9
0
0
2
:
v
i
X
r
a

Abstract—In the past decade, high performance compute capabilities
exhibited by heterogeneous GPGPU platforms have led to the popularity
of data parallel programming languages such as CUDA and OpenCL.
Such languages, however, involve a steep learning curve as well as
developing an extensive understanding of the underlying architecture
of the compute devices in heterogeneous platforms. This has led to the
emergence of several High Performance Computing frameworks which
provide high-level abstractions for easing the development of data-
parallel applications on heterogeneous platforms. However, the schedul-
ing decisions undertaken by such frameworks only exploit coarse-
grained concurrency in data parallel applications. In this paper, we pro-
pose PySchedCL, a framework which explores ﬁne-grained concurrency
aware scheduling decisions that harness the power of heterogeneous
CPU/GPU architectures efﬁciently. We showcase the efﬁcacy of such
scheduling mechanisms over existing coarse-grained dynamic schedul-
ing schemes by conducting extensive experimental evaluations for a
Machine Learning based inferencing application.

1 INTRODUCTION
The rise of data parallel programming languages like
OpenCL [1] and CUDA [2] have paved the way for high
throughput application development on big data clusters
as well as embedded platforms comprising multiple CPU
and GPU cores. Such frameworks support asynchronous
event driven programming models that enable both data
parallel and task parallel paradigms of computation for
implementing high performance parallel applications. The
OpenCL runtime system additionally has provision for pro-
gram portability across different types of devices i.e. the
same computational kernel source code can be compiled
into device speciﬁc binaries for execution on different de-
vices.

Given heterogeneous platforms comprising multiple de-
vices of varying computational power, determining efﬁcient
architecture-to-application mapping decisions require ex-
tensive domain knowledge of platform level characteristics
as well as precedence constraints enforced by the appli-
cation which is typically represented as a directed acyclic

• A. Ghose, S. Maity and S. Dey are with the Dept. of Computer
IIT Kharagpur Email: {anirban.ghose, srijeeta,

Science and Engg.,
soumya}@cse.iitkgp.ac.in
S. Singh is with the Dept. of Computer Science, University of Maryland,
College Park Email: ssingh37@umd.edu

•

• V. Kulaharia is with Cohesity Solutions India Pvt Ltd., working as a

•

Member of Technical Staff Email: Vivek.Kulaharia@cohesity.com
L. Dokara is with iB Hubs working as a DevOps Specialist Email:
lokesh@ibhubs.co

(cid:70)

graph (DAG) of tasks. As an illustrative example, let us
consider a simple fork-join DAG in Fig. 1.

Fig. 1: DAG Mapping Decisions

We consider a heterogeneous platform comprising a sin-
gle CPU and a single GPU along with a DMA copy engine
responsible for transferring data across the PCI-Express bus
from the CPU to the GPU and back. The fork-join graph
comprises four tasks, each representing some computational
kernel which takes as input two input buffers and produces
one output buffer. In Fig. 1, the rectangular nodes represent
input and output buffers and the circular nodes represent
kernels. We use this convention throughout the paper. The
edges between a buffer and task represents the precedence
constraints between tasks as well. Given a heterogeneous
compute platform comprising a single CPU and a single
GPU there can exist a total of 16 task-device mappings for
this DAG where task(s) are either mapped to a GPU device
or a CPU device. In Fig. 1, we explore one of the 16 possible
mappings where k0 and k3 are mapped to a CPU device, k1
and k2 are mapped to a GPU device.

Scheduling decisions for general application DAGs are
coarse-grained in the sense that each task is mapped to
a single device at a time and the associated kernel execu-
tion, buffer reads and writes are ﬁnished completely before
proceeding to execute successors of the kernels. In Fig. 1,
for kernel k2 to start execution, k1 must ﬁnish and the
copy engine should copy the resultant buffer b5 to the host.
After that the required input buffer b4 has to be copied
to the GPU device. The scheduling decisions are achieved
by designing complex host programs that orchestrate the

k0k1k2k3CPUb0b1b3b4b2b5b6GPUCPUGPUb7b0b1b2b3b4b5b7b6b0b1b3b2b4b5b6k0k1k2k2k0k1k3b7k3Coarse GrainedFine GrainedCPUCopyEngineGPUCPUCopyEngineGPUtime 
 
 
 
 
 
process of mapping individual kernels to target devices of
the heterogeneous platform while maintaining precedence
constraints. Alternatively, there exist several frameworks
proposed in the recent past that alleviate the burden of
implementing such complex orchestrators for undertaking
coarse-grained scheduling decisions. The frameworks can
be classiﬁed into two broad categories. The ﬁrst category of
frameworks [3], [4] provide a top-level API as well as addi-
tional programming constructs using which a designer can
explicitly specify the mapping and scheduling of OpenCL
kernels without writing a complex host program. The sec-
ond category of frameworks (StarPU, MultiCL) [5], [6] pro-
vide scheduling engines optimized for heterogeneous clus-
ters with support for custom scheduling heuristics. These
frameworks require as input the DAG speciﬁcation and a
scheduling heuristic for mapping OpenCL kernels optimally
on a heterogeneous platform. Both styles rely on deriving
coarse-grained scheduling decisions for application DAGs.
In contrast, we believe scheduling decisions should be
more ﬁne-grained in nature allowing execution of multiple
tasks in the same device and interleaving copy operations
with execute operations. This is exempliﬁed in the right
hand side scheduling option of Fig. 1. In the ﬁgure we show
the execution timings of kernels in CPU and GPU along with
the data transfers scheduled in the available copy engine
in the GPU platform. We can observe for kernel k1, the
two input buffers b2 and b3 can be transferred by the copy
engine in parallel. Also while kernel k1 is executed, b4 can be
transferred asynchronously to the GPU device. The kernel
k2 executes in parallel with k1 while sharing the same GPU
resource. As a result, we observe that the individual times
of k1 and k2 increase. However, the overall time to ﬁnish
DAG execution decreases.

Implementing such ﬁne-grained scheduling requires de-
signing an even more complex host program capable of
i) asynchronously interleaving data transfers as and when
required and ii) clustering multiple tasks to the same device
as and when feasible. These scheduling decisions can be
achieved by setting up multiple worker queues per device
and asynchronously enqueueing commands for executing
multiple kernels on the same device. For the CUDA runtime
system, these worker queues are referred as CUDA streams.
For the OpenCL runtime these are referred as command
queues. Naturally, the end user has to consider the compu-
tational capability of the device and the individual com-
putational requirements of each concurrent kernel before
dispatch.

We propose PySchedCL, a platform agnostic program-
ming framework which is possibly the ﬁrst computer-aided
design solution that is capable of automating the process of
deriving both coarse-grained and ﬁne-grained scheduling
decisions for efﬁcient collaborative execution of application
DAGs on heterogeneous multicores comprising CPU and
GPU devices. The proposed framework supports reduction
of considerable implementation overhead and automatically
outputs scheduling decisions that exploit concurrency, re-
quiring minimal intervention from the programmer. The
framework is built using the widely used PyOpenCL API
[7] and facilitates rapid development and deployment of
OpenCL applications. We choose OpenCL, since it offers
device portability, thus supporting a myriad of compute

2

devices such as CPU, GPUs, FPGAs, DSPs etc. Our frame-
work enables the user to concentrate only on developing
OpenCL kernels and perform minimum manual interven-
tion that would help in ﬁnally determining near optimal
runtime scheduling decisions for data parallel applications
on a target heterogeneous CPU-GPU platform. We note the
optimizations proposed are generic and the ideas can be
leveraged for any data parallel heterogeneous setting. The
salient features of the proposed framework are enumerated
as follows.

1) The framework eases development of data parallel ap-
plications through speciﬁcation ﬁles, thus completely
bypassing the requirement of manually implementing
orchestrator host programs. As a representative exam-
ple, one can implement the host code of a Transformer
Neural Network based inference pipeline [8] which
takes ≈ 130 lines of vanilla OpenCL code using a
speciﬁcation ﬁle of 25 lines in our framework.

2) The framework comprises a customizable scheduling
backend optimized for automatically extracting ﬁne-
grained concurrency in applications executing on het-
erogeneous compute platforms. The backend also en-
ables programmable scheduling with its rich API sup-
port, thereby allowing users to design, experiment and
validate both coarse-grained and ﬁne-grained schedul-
ing policies on top of the default strategies in the
framework .

3) While the usability of the framework is evident in terms
of programming effort, we also observe the efﬁcacy of
its automated ﬁne-grained scheduling schemes through
extensive experimentation for AI workloads such as
transformer networks. We have observed considerable
speedups in the range of 1.4 − 3.4× for such applica-
tions compared to existing coarse-grained scheduling
approaches supported in frameworks such as StarPU
[5], SOCL [4] etc.
The remainder of the paper is organized as follows. In
Section 2, we present necessary background on OpenCL
runtime and the inadequacy of existing OpenCL based
high-level scheduling frameworks, thus motivating the re-
quirement of our proposed framework. This is followed by
problem formulation in Section 3 and the software architec-
ture of the framework in Section 4. We perform extensive
experimentation and provide a comparative evaluation in
Section 5. We present a comprehensive list of related work
in Section 6 and ﬁnally conclude the paper in Section 7.

2 BACKGROUND AND MOTIVATION

Any OpenCL application typically comprises two distinct
program entities - i) the host which is a single threaded
sequential program executing on one CPU core that or-
chestrates the entire process of managing data and issuing
directives for parallel execution, and ii) kernel(s) which
execute on devices with support for vector processing
(CPU,GPU,FPGA,DSP etc). For every computational ker-
nel, the single-threaded host program leverages command
queues supported by the OpenCL API to issue commands
for performing the following operations - i) copying the data
from host to input buffers resident on device memory (Host
to Device or H2D transfer), ii) launching multiple instances

of the same kernel to process the data copied to the device
and iii) copying back the data stored in output buffers in the
device back to the host memory after the kernel has ﬁnished
processing (Device to Host or D2H transfer).

As an illustrative example, we consider a simple
OpenCL application DAG depicted in the top left of Fig. 2
where kernel k0 performs a vector addition operation (vadd)
and kernel k1 performs a simple element-wise trigonometric
sine operation (vsin) on the output of k0. The kernel k0
takes as input two input buffers (b0 and b1), performs
element-wise addition and produces an output buffer (b2).
The kernel k1 takes one buffer (b3) and performs an in-
place element-wise sine operation. The corresponding ker-
nel codes of k0 and k1 are depicted in the functions vadd
and vsin respectively in the top right subﬁgure of Fig. 2.

Considering a heterogeneous platform comprising two
GPU devices GP U0 and GP U1, it may be observed in the
bottom right subﬁgure of Fig. 2 that two command queues
are setup, one for each GPU device. Kernel k0 executes
on GP U0 and kernel k1 executes on GP U1. Each com-
mand queue consists of a sequence of commands for H2D
transfers, kernel execution and D2H transfers pertaining to
each kernel. The associated host program depicted in the
bottom left of Fig. 2 illustrates how the command queues
are populated.

For GP U0, the host ﬁrst issues two write commands
(clEnqueueWrite())
for copying data from the host
to the buffers b0 and b1. This is followed by a barrier
directive (clEnqueueBarrier()). The barrier command
in general ensures that all commands enqueued previ-
ously ﬁnish before proceeding to execute commands en-
queued after the barrier. In this case, it is ensured that
the write commands are ﬁnished before processing the
next command in the queue. The host next enqueues a
kernel execution command or ndrange command using the
function clEnqueueNDRangeKernel() which spawns a
collection of threads referred as work items where each
work item executes the function bodies depicted in the
top right of Fig. 2. The execution command is followed
by a barrier directive and ﬁnally one read command
(clEnqueueReadBuffer()). In a similar fashion, for the
command queue of device GP U1, the host issues a write
command (for buffer b3), an execute command for vsin
kernel and read command (for buffer b3). We note that
barriers in general
incur synchronization overhead. For
the remainder of the paper we assume that barriers are
not enqueued and that command queues follow inorder
execution i.e. commands are executed in the order which
they are enqueued and each command cannot start until the
previous command has ﬁnished completely.

The OpenCL runtime system uses event objects for en-
forcing dependencies across multiple commands resident in
same or different queues. In Fig. 2, the ith write for the H2D
transfers (highlighted by red edges in the OpenCL DAG)
are associated with event wi. In a similar fashion, the ith
ndrange command for kernels and ith read command for
D2H transfers (highlighted by red edges in the OpenCL
DAG) are associated with events ei and ri respectively.
These are labelled in the OpenCL DAG. The associated
event for a command is speciﬁed in the last argument
of a function call with the clEnqueue preﬁx in the host

3

Fig. 2: OpenCL Execution

program. The second last argument of each such function
represents events on which the event associated with com-
mand c is dependent for execution. For our representative
example, from the OpenCL DAG it may be observed that
the event w3 is dependent on r1, i.e. the write command
corresponding to w3 should take place only when the read
command corresponding to r1 is complete. This is speciﬁed
in the clEnqueueWriteBuffer command for buffer w3.

Finally, for the event r2 associated with the last read
command (‘read for b3’), a callback function cb is setup using
the clSetEventCallback() API call. A callback function
cb in general is registered with any event ev. The object to
the event along with data to be accessed by the callback
function once it starts execution is speciﬁed in user args.
The callback function is spawned on a separate thread in
parallel with the host program once the event ev (denoting
computation/data transfer) has achieved some status (any
one of enqueued / submitted / complete) as speciﬁed in the
argument status and is implemented typically to notify the
host. In Fig. 2, cb notiﬁes the host, once r2 has achieved
complete status i.e. ‘read for b3’ has ﬁnished. We note the
clEnqueue OpenCL functions enqueue operations to each
command queue for the devices, i.e. after enqueuing the
commands, the host is free to execute something else while
those commands are executed on the target device.

2.1 Motivation

We consider a transformer application [8] which is a pop-
ular Deep Learning Neural Network pipeline for Natural
Language Processing (NLP) tasks. The application exhibits
ample scopes for exploiting concurrency with the possibility
of executing multiple instances of standard General Matrix
Multiply (GEMM) kernels in parallel. A sample DAG com-
prising 8 kernels for one layer of the transformer network is
presented in Fig. 3.

As per our earlier convention, the rectangular nodes rep-
resent input and output buffers and the circular nodes repre-
sent kernels. Each kernel is labeled with the corresponding
level number starting from 1. Initially there is a copy oper-
ation which copies the same buffer to each of the kernels
at level 1. Each of the kernels in levels 1,4,5,6 represent

clEnqueueWriteBuffer(--,--,--,NULL,w1);clEnqueueReadBuffer(--,--,--,NULL,r1);clEnqueueNDRangeKernel(--,--,NULL,e1)clSetEventCallback(r2,status, &cb,user_args);clEnqueueWriteBuffer(--,--,--,NULL,w2); clEnqueueBarrier(); clEnqueueBarrier();clFlush(); ndrange for k0write for b1read for b2write for b0BarrierBarrierclEnqueueWriteBuffer(--,--,--,r1,w3);k0bob1b2b1bob1HOSTb3b3HOSTk1w1w2- - - - //Enqueue commands  - - - - - - -__kernel void vadd( __global float* input1, __global float* input2, __global float* output, int n){   int i = get_global_id(0);   if(i<n)  output[i] = input1[i]+input2[i];}__kernel void vsin( __global float* i0){   int i = get_global_id(0);   io[i] = sin(io[i]);}r1r2w3e1e2 ndrange for k1write for b3read for b3BarrierBarrierGPU 1GPU 0clFlush();OpenCL DAGOpenCL kernelsHost ProgramCommand Queue Setupcallback function cb4

like StarPU [5], SOCL [4] and MultiCL [6] all impose this
same level of programming complexity. We next examine
how coarse-grained and ﬁne-grained scheduling decisions
are made for mapping this DAG onto a single GPU device
with the help of Figs. 4 and 5 respectively.

We execute the DAG on a heterogeneous platform com-
prising an NVIDIA GTX-970 GPU device and a Quadcore
Intel i5-4690K CPU device. Coarse-grained scheduling is
achieved by setting up a single command queue on the
GPU device as depicted in the right hand side of Fig. 4.
As a consequence, all read, write and ndrange commands for
each of the 8 kernels as labelled by the events used in Fig. 3
execute serially on the GPU device. In the left hand side of
Fig.4, we plot a Gantt chart representing the time taken by
the commands. It is evident from the Gantt chart that such
serialized execution of commands on the GPU device result
in an execution time of 105ms.

General Matrix Multiply (GEMM) kernels where each kernel
takes as input two buffers and produces one output buffer.
The kernels in level 2 and level 3 represent transpose and
softmax operations respectively, each processing one input
buffer to produce one output buffer. The edges between
rectangular nodes, i.e. buffers, represent data dependencies
for the DAG. For enforcing precedence constraints between
any pair of kernels (ki, kj), a programmer shall set event
dependencies between read commands for output buffers
of ki and write commands for input buffers of kj, as was
observed in Fig. 2. For our transformer DAG depicted in
Fig. 3, we assume that the entire DAG is mapped to a single
GPU device. This implies that the output buffers of kernels
at level i to be processed as input buffers of kernels at level
i + 1, i = [1, 5] are already resident in GPU memory. Thus
explicit reads and writes for dependent buffers between
kernels in levels 1-5 are not required. In this scenario, the
programmer needs to set up event dependencies between
ndrange commands of kernels in levels i and i+1 as depicted
in the event dependency graph. One can observe from Fig.
3, that the actual H2D and D2H transfers (red edges) occur
only for kernels at level 1 and level 6 while the remaining
black edges reﬂect the input-output buffer dependencies
between kernels in the DAG.

Fig. 4: Coarse-grained Scheduling

Fig. 3: Event Dependencies for DAG

In the left hand side of Fig 3. we label each kernel k of
the DAG with event ek associated with the corresponding
ndrange command for that kernel. Apart from this, we have
a write command w0 responsible for copying one common
buffer to be used for each GEMM kernel in level 1. We also
have write commands w1, w2, w3 for each of the remaining
buffers required by GEMM kernels in level 1 and a write
command w4 for a buffer required by GEMM kernel in
level 6. Finally we have a read command r for the output
buffer of the GEMM kernel in level 6. The dependencies
between these events are depicted in the corresponding
event dependency graph in the right hand side of Fig. 3. The
end designer is burdened with the task of manually writing
a host program that will capture the event dependencies
illustrated in this dependency graph for ensuring that prece-
dence relations of the DAG are met during execution. This
is achieved by using the complex programming constructs
for OpenCL events and callback functions as discussed
earlier. Existing heterogeneous programming frameworks

Fig. 5: Fine-grained Scheduling

In contrast, if we set up multiple command queues,
there is a possibility of leveraging ﬁne-grained scheduling
decisions that can i) interleave data transfers with ndrange
operations and can ii) execute multiple ndrange operations
concurrently. In the right hand side of Fig. 5, we setup
3 command queues for achieving this. As a result of en-
queuing the operations using multiple command queues,

12411356GEMMTRANSPOSEGEMMSOFTMAXGEMMGEMMe2e3e4e5e6e7e8w0w1w2w3rw0w1w2w3e1e2e3e4e5e6e7e8w4rHOSTe1HOSTHOSTw4w1w2w3w0e5e7w4e4e6rede1e2e3e8r5060708090100110Time(milli seconds)w0w1e1w2e2w3e3e4e5e6e7w4w0w1e1w2e8rcommand queue eventsCommand Queue1_gemm (w1,e1)1_gemm (w2,e2)1_gemm (w3,e3)initial copy (w0)3_gemm (e5)5_gemm (e7)6_gemm (w4,e8,r)2_transpose (e4)4_softmax (e6)Interleaving of write and ndrange w0w1e1e4e8w2e2e5w4rw3e3e6e7e4e1e2e3e8rw1w2w3e5e7e6w4w05060708090100110Time(milli seconds)command queue eventsCommand Queueswe observe from the corresponding Gantt chart in the left
hand side of Fig. 5, several write and ndrange commands
are interleaved thus resulting in an 8% decrease in overall
execution time with the DAG ﬁnishing in 95ms. On closer
inspection, one can observe from the Gantt chart that while
the ndrange command associated with e1 is executing, the
buffer associated with w2 can be copied simultaneously.
This is because w2 and e1 belong to separate command
queues in the right hand side of Fig. 5. In a similar vein,
w3 can also be copied while e1 and e2 are executing.
Additionally, it can be seen that all kernels in level 1 i.e.
ndrange commands associated with events e1, e2 and e3 are
executing concurrently on the same device. We can observe
something similar happening for the events e5, e6 and w4 in
the Gantt chart as well. However, there are commands that
despite belonging to different command queues are not able
to execute simultaneously due to the precedence relation-
ships enforced by the event dependency graph illustrated in
of Fig. 3. These dependencies being part of the actual com-
mand queue setup, are represented by inter-queue edges
between events in the command queue structure in the right
hand side of Fig. 5. For example, since e4 is dependent upon
e2, it can start execution only after e2 has ﬁnished. But e4
can still overlap with e3. Another interesting observation
would be that the individual execution times for each kernel
increases slightly as a result of interleaving. This is due
to the fact, that different work groups of different kernels
that have been concurrently dispatched are scheduled in
a round robin fashion to the compute units of the device,
thus causing resource contention [9]. However, the total
time for ﬁnishing kernels concurrently is lesser than the
case when they are dispatched in sequence. We note that
both the cases represented in Figs. 4 and 5 depict one of the
possible command queue conﬁgurations and multiple such
possibilities exist both for coarse-grained and ﬁne-grained
scheduling respectively.

The Gantt charts for the execution of DAG highlighted
in Fig. 3 thus reveal that ﬁne-grained scheduling has poten-
tial performance beneﬁts over coarse-grained scheduling in
the context of data parallel programming models used for
GPGPU systems.

3 PROBLEM FORMULATION
Let us consider a heterogeneous platform P depicted in
Fig. 6 which comprises a CPU device and a GPU device
connected via a PCI-Express bus. Each device has support
for executing multiple kernels simultaneously. The OpenCL
standard supports device ﬁssion for CPU devices i.e. a sin-
gle CPU device can be partitioned into multiple subdevices,
thereby enabling concurrent execution for the same. We
consider as GPU an NVIDIA device with Hyper-Q support
[2]. Hyper-Q offers a solution that allows the CPU host
to dispatch multiple kernels simultaneously on the GPU
device with the help of hardware managed work queues.

Let us represent an OpenCL application as a directed
acyclic graph (DAG) G = (cid:104)(K, B), (EI , EO, E)(cid:105) where K
(cid:83) BO represents
denotes the set of OpenCL kernels, B = BI
the set of buffers for all k ∈ K. The set BI denotes the
set of input buffers and the set BO denotes the set of
output buffers. The set EI ⊆ BI × K denotes the set of

5

edge dependencies between each input buffer and kernel,
EO ⊆ K×BO denotes the set of edge dependencies between
each kernel and output buffer. The set E ⊆ BO ×BI denotes
the set of input output buffer dependencies across kernels
in the DAG. For the remainder of the paper, we shall use
this notation for representing DAGs. Command queues are
typically setup per device, depending on which kernels are
mapped to which devices.

Fig. 6: Platform and DAG Model

Given an OpenCL DAG G, we denote a task component
T as a subset of kernels K (cid:48) ⊆ K where each kernel k is
mapped to a device of the same type say dev. In our case,
dev = {cpu, gpu}. In Fig. 6, T = {k0, k1, k2, k3, k4}. For a
given task component we deﬁne the following terminology.

Deﬁnition 1. Given a task component T pertaining to some
OpenCL DAG G, we deﬁne F RON T (T ) as the set of kernels
where each kernel k has input buffer dependencies (bi, k) ∈ EI
such that for bi, if there exists an immediate predecessor bj where
(bj, bi) ∈ E and (k(cid:48), bj) ∈ EO, then the kernel k(cid:48) belongs to a
different task component T (cid:48)

d(cid:48) .

In Fig. 6, we observe that F RON T (T ) = {k0}, since
both input buffers b2 and b3 have predecessors pertaining
to kernels belonging in a different task component.

Deﬁnition 2. Given a task component T pertaining to some
OpenCL DAG G, we deﬁne EN D(T ) as the set of kernels
where each kernel k has output buffer dependencies (k, bi) ∈ EO
such that for bi if there exists an immediate successor bj where
(bi, bj) ∈ E and (bj, k(cid:48)) ∈ EI then kernel k(cid:48) belongs to a
different task component T (cid:48).

In Fig. 6, we can observe that EN D(T ) = {k3, k4}.

Deﬁnition 3. Given a task component T pertaining to some
OpenCL DAG G, we deﬁne IN (T ) as the set of kernels where
each kernel k ∈ T, k /∈ F RON T (T ), k /∈ EN D(T ).

In Fig. 6, we can observe that IN (T ) = {k1, k2}. We
classify buffer edge dependencies (bi, bj) ∈ E into two
categories -i) intra edge, ii) inter edge. Given a task compo-
nent T pertaining to a DAG G, an edge (bi, bj) for kernels
ki, kj such that (ki, bi) ∈ EO, (bj, kj) ∈ EI represents an
intra edge if ki and kj belong to the same component and
inter edge if they belong to different task components. In

k1k2b5b6b7b8b9b10b13b11b12b14k0b2b3b4FRONT(T)IN(T)END(T)b0b1b15b16k3k4PCI-ECPUGPUHyper Q Device Fission w1w2e1e2e3e4e5r1r2w3w4w1e1e2w2w3e3w4e5r2e4r1Software Defined Command Queues(Q) Fig. 6, we can observe that (b4, b6), (b4, b7), (b9, b11) and
(b10, b12) are intra edges, while (b0, b2), (b1, b3), (b13, b15)
and (b14, b16) are inter edges.

We classify kernel-buffer dependencies in EI and EO
into two categories - i) isolated copy and ii) dependent copy.
Given any kernel ki, an edge (bi, ki) ∈ EI represents an
isolated copy (write) iff for every bk ∈ B, (bk, bi) /∈ E. The
same edge can represent a dependent copy if there exists
some buffer bi ∈ B such that (bi, bk) ∈ E. In a similar
fashion, an edge (ki, bj) represents an isolated copy (read) iff
for every bk ∈ B, (bj, bk) /∈ E respectively and a dependent
copy (read) if there existed some bk such that (bj, bk) ∈ E.
In Fig. 6, the edges (b5, k1) and (b8, k2) represent isolated
writes while every other kernel-buffer dependency repre-
sents dependent copies.

Deﬁnition 4. Given a task component T of an application DAG
G mapped to a device d with r command queues, we deﬁne
the command queue data structure Q = (cid:104)Q, Eq(cid:105) as follows.
Q = {q1, q2, · · · , qr} is the set of command queues, each
command queue qi is a list such that every location qi[j] ∈
{write, ndrange, read} contains any of these three commands
pertaining to some kernel belonging to T . Each element of Eq is
a precedence constraint of the form (cid:104)qs[i], qt[j](cid:105), 1 ≤ s (cid:54)= t ≤ r
which enforces that the i-th command enqueued in qs must ﬁnish
execution before the j-th command enqueued in qt can start.

A precedence constraint (cid:104)qs[i], qt[j](cid:105) ∈ EQ exists if any
of the following is true - i) qs[i] is an isolated/dependent
write (bl, km) and qt[j] is an ndrange operation for kernel
km, ii) qs[i] is an ndrange operation for kernel km and qt[j]
is a dependent/isolated read (km, bl), iii) both qs[i] and qt[j]
are ndrange operations for kernels km and kn respectively
such that there exists edges (km, bl) ∈ EO, (bp, kn) ∈ EI
and (bl, bp) ∈ E where (bl, bp) is an intra edge. In Fig. 6,
(b3, k0) corresponds to a dependent write for kernel k0 thus
requiring a dependency between associated operations w2
and e1 in Q. The edge (e1, e3) represents the dependency
between kernels k0 and k2 arising due to the dependencies
(k0, b4),(b4, b7),(b7, k2) where (b4, b7) is an intra edge. The
operations of a kernel kl ∈ T that are to be enqueued to
some queue qs ∈ Q of Q are determined by the framework
using an enqueue procedure enq(kl, qs) and is described as
follows.
i) If kl ∈ F RON T (T ), enq(kl, qs) enqueues all dependent
write commands for buffers bm corresponding to dependent
writes (bm, kl) ∈ EI followed by ndrange command for kl
to qs.
ii) If kl ∈ EN D(T ), enq(kl, qs) enqueues ndrange com-
mand for kl followed by all dependent reads (kl, bm) ∈ EO
for bm to qs.
iii) If kl ∈ IN (T ), enq(kl, qs) only enqueues ndrange for kl
to qs.
Note, a kernel may belong to any combination of the three
sets discussed above. One can observe that since all kernels
in T are mapped to the same device, the enq procedure
using the rule set above ensures that redundant dependent
reads from F RON T (T ), redundant dependent writes and
reads from IN (T ) and redundant dependent writes from
EN D(T ) are avoided from being enqueued. Apart from
these enqueue operations, for every kernel kl, irrespective
of which set it belongs to, enq(kl, qs) enqueues to qs - (i)

6

all isolated writes (bm, kl) ∈ EI for input buffers bm before
enqueuing the ndrange command for kl and (ii) all isolated
reads (kl, bn) ∈ EO for output buffers bn after enqueuing
the ndrange command for ki.
Note that the above rules for enq when applied to individual
kernels in a task component T need not generate a unique
command queue structure Q for a device. This, coupled
with different possible task component partitions based on
device mapping decisions of the overall DAG lead to multi-
ple possible dispatch orderings, i.e. scheduling decisions for
the kernels.

Deﬁnition 5. Consider a DAG G = (cid:104)(K, B), (EI , EO, E)(cid:105),
with a set of task components T = {T1, T2, · · · , TM } such that
(cid:83)
i Ti = K, a heterogeneous CPU-GPU multicore target platform
P = {d1, d2, · · · dp} containing p devices, and the number
of command queues for each device {r1, r2, · · · rp} as given.
Consider, the set of all command queues R = {q1, q2, · · · , qN }
where N = (cid:80)
i ri. For such an application-architecture pair,
a (valid) schedule σ is a collection of enqueue procedures
{enq(ki, qj)|ki ∈ K, qj ∈ R} such that each kernel ki ∈ K
is dispatched in a topologically sorted fashion with respect to the
ordering of ki’s enforced by the edges in G.

Our framework facilitates automated creation of such
correct-by-construction valid schedules, both coarse-grained
and ﬁne-grained.

4 SOFTWARE ARCHITECTURE

An overview of the software architecture for PySchedCL is
shown in Fig. 7. The framework comprises two distinct
modules, the functionalities of which are elaborated below.

Fig. 7: PySchedCL Toolﬂow

A. Design Frontend: The input to the scheduling frame-
work is an OpenCL application represented in the form
of an OpenCL DAG G as discussed earlier. The proposed
framework supports a speciﬁcation ﬁle using which pro-
grammers can easily design an OpenCL application for
execution on a heterogeneous platform. The speciﬁcation
ﬁle contains necessary buffer-kernel dependency informa-
tion for an OpenCL DAG, along with necessary attribute
information such as input/output buffers, variables passed
as arguments for each constituent kernel. The ﬁle uses
Javascript Object Notation (JSON) format. Let us consider
an example DAG comprising three kernels as depicted in
Fig. 8. Each kernel in dag.json ﬁle as shown in top-
left box of Fig. 8, is designated with i) a unique identiﬁer
ﬁeld called id, ii) a name ﬁle depicting the name of kernel
function, iii) a device ﬁeld dev indicating the device type
to which the kernel should be mapped (‘cpu’ or ‘gpu’). The
task component partitioning T = {T1, T2, · · · , TM } for the
DAG is speciﬁed as a list tc = {{· · · }, · · · , {· · · }} with
each sub-list i being an enumeration of the kernel id-s in
Ti. All kernels mapped to a task component must be given
the same device type. In Fig. 8, the list tc = {{0, 2}, {1}}

HPC ALGORITHMGPUCPUSPEC. FILEOPENCL COMMAND QUEUEMANAGEMENTKERNEL DAG MANAGEMENTselect()dispatch()DESIGNFRONTENDSCHEDULING BACKENDTARGET DEVICES--------------------GUIDANCEPARAMETERSCMD QUEUESspeciﬁes that the kernels with ids 0 and 2 are mapped as a
task component with both constituent kernels having ‘gpu’
device preference while kernel with id 1 is the other task
component having ‘cpu’ device preference. The number of
command queues to be setup for the platform is speciﬁed
in the list cq where each element ri : n denotes that device
di ∈ P has ri = n command queues. Assuming a target
platform for 4 devices, we can observe from Fig. 8 that
cq = {r1 : 4, r2 : 2, r3 : 2, r4 : 4}. The framework uses
this information to automatically set up Q data-structure for
each task component. The dependency information of the
DAG is speciﬁed as a set of edges of the form ki, br → kj, bs,
where ki,kj represent kernel ids that are dependent, br is
an output buffer of ki and bs is an input buffer of kj i.e.
(ki, br) ∈ EO, (bs, kj) ∈ EI and br, bs ∈ E. The ids for
the buffers br and bs are represented by their corresponding
argument positions in the function call for the kernels. For
example, consider the entry 0, 2 → 2, 0, in the dag.json
ﬁle of Fig. 8. This implies that the output buffer speciﬁed in
argument 2 of kernel 0 will be used as input buffer speciﬁed
in argument 0 of kernel 2. Note in the bottom-left box of Fig.
8 the tag "outputBuffers" for the matmul kernel (which
is kernel ‘0’). The argument position pos for this buffer is
indicated as 2 in the speciﬁcation.

Fig. 8: JSON Speciﬁcation File for DAG

i)

Kernel

the name of

the ﬁlepath of

the
information includes
function (matmul),
the required
ii)
source ﬁle (gemm.cl),
iii) the kernel dimensionality in
workDimension and iv) the total number of work items
(globalWorkSize) to be launched for this kernel. The
variable globalWorkSize is a three element list where
each element refers to the number of work items along a par-
ticular dimension. Buffer information for each kernel consti-
tutes information for three buffer lists - i) inputBuffers
reserved for input buffers, ii) outputBuffers reserved
for output buffers and iii) ioBuffers reserved for buffers
which are treated as both input and output by the kernel.
Each buffer is characterized by the tuple (cid:104)type, size, pos(cid:105)
where type denotes the data type for each element in the
buffer, size denotes the total number of elements in the
buffer, and pos denotes the index position of the buffer
argument in the actual function call of the kernel. Variable
argument information for every kernel is denoted by the
tuple (cid:104)type, pos, value(cid:105) with type, pos meaning same as
earlier and value denoting the argument variable.

7

The required attribute information comprising information
speciﬁc to the kernel implementation, buffers and variable
arguments for the matmul kernel is depicted in Fig. 8.
The matmul kernel takes as input two matrices A, B of
dimensions M × K, K × N respectively and produces an
output matrix C of dimension M × N . For this, a total of
M ∗ N work items is launched. In Fig. 8, the three variable
arguments are M, N, K for matmul and globalWorkSize
= [M,N,1]. In Fig. 8, the value of size for the output
buffer is set as the symbolic expression M ∗ N . Guidance
parameters speciﬁed as symbolic expressions aide in de-
picting the relationship between number of work items
launched and the dataspace to be processed. The values of
the symbolic variables M, N, K can be conﬁgured by the
user as command line parameters before dispatching the
kernel. In general, guidance parameters can be speciﬁed
both as compile time constants or using expressions con-
taining symbolic variables as exempliﬁed.
We have implemented an LLVM [10] based compiler pass
with the help of the library reported in [11] that 1) parses
the abstract syntax tree of each OpenCL kernel and auto-
matically generates necessary attribute information for each
kernel, 2) infers the dimensionality, types and positions
of variables and buffers used for each kernel, 3) classiﬁes
buffers as input/output buffers by understanding whether
it is treated as l-values or r-values in the body of the function.
This pass thus automatically generates most ﬁelds of the
JSON ﬁle by analysing the individual kernels. After this, the
user is only required to specify guidance parameters which
include -i) the size of the buffers ii) the number of work
items iii) the values of the variable arguments.
B. Scheduling Backend: As depicted in Fig. 7, the schedul-
ing backend processes the speciﬁcation ﬁle of an application
DAG and takes care of setting up OpenCL command queues
for mapping kernels across devices of a heterogeneous
CPU/GPU platform. We explain the working principle of
the backend with the help of the procedure schedule high-
lighted in Algorithm 1.
Input: G - an OpenCL DAG, P - target devices
1: procedure SCHEDULE(G,P)
2:
3:
4:
5:
6:
7: function SETUP CQ(T ,Q)
8:
9:
10:
11:
12:
13: function CB()
14:
15:
16:
17:

ev, T, d, F , A ← get user args()
update status(ev, T ), T (cid:48) = get ready succ(T )
lock(); update task queue(T (cid:48), F ); unlock()
if T is ﬁnished then lock();return device(d, A); unlock()

k ← unprocessed, q ← selrr(Q), enq(k, q)
set dependencies(k, EQ), update(unprocessed)
if k ∈ EN D(T ) then set callbacks(k,Q, cb)

Q= (cid:104)Q, EQ(cid:105) ← init() unprocessed ← F RON T (T )
while all kernels of T not processed do

F ← ready task components(G) , A ← P
while all kernels of G not ﬁnished do

T, d ← select(F , A), Q ← setup cq(T, d), dispatch(T ,Q)

while A contains a device and F is not empty do

sleep till cb update()

Algorithm 1: Scheduling in PySchedCL
Initialization: The procedure executes on the host device,
and ﬁrst parses the input speciﬁcation (for the applica-
tion graph G along with the set of devices in the target
platform P) and populates the centralized task queue F
with task components that are ready for dispatch using
ready task components() (line 2). Here, a task component
T is added to F if for every kernel ki ∈ F RON T (T ), there
exists no predecessor. The task queue F is implemented

__kernel void matmul(__global float *i1,__global float *i2, __global float *o)__kernel void vecadd(__global float *i1,__global float *i2, __global float *o)__kernel void matvecmul(__global float *i1,__global float *i2, __global float *o)012010122201        "src": "gemm.cl",,          "workDimension": 2,"globalWorkSize": "[M,N,1]","inputBuffers": [  {"type": "float", "pos": 0, "size": "M*K" },  {"type": "float", "pos": 1, "size": "K*N"  } ],"outputBuffers": [   {  "type": "float", "pos": 2, "size": "M*N" } ],"varArguments": [  {"type": "int", "pos": 3, "value":  "M" },  {"type": "int", "pos": 4, "value":  "K"  },  {"type": "int", "pos": 5, "value":  "N"  } ] GUIDANCE {“id”: 0,“name”: “matmul” ,"dev":'gpu', ...................}{“id”: 1, “name”: “vecadd”,  "dev":'cpu',.................   }{“id”: 2,“name”: “matvecmul”,   "dev":  'gpu', ............}“ “{r1: 4, r2:2, r3:2, r4:4}”, “tc”: “{{0,2},{1}}”---0 2 -> 2 01 2 -> 2 1dag.jsonas a priority queue, where the user can specify custom
ranking measures for enforcing an ordering among task
components to be selected from F . The set A represents the
set of available devices and is initialized to all the devices
contained in P (line 2).
Primary Scheduling Loop: The procedure schedule runs the
routines inside the while loop (line 3-6) and continues until
all kernels of the DAG have not ﬁnished execution. In any
scheduling iteration where the frontier F and the set A are
non-empty (line 4), the select routine inspects task compo-
nents in F and returns T and d (line 5) if an available device
d ∈ A is found that matches the device preferences of all the
constituent kernels of some task component T ∈ F . We note
that the select routine is a blocking call i.e. if a task compo-
nent T or a matching device d is not immediately available,
the routine blocks further execution of the schedule routine
until a suitable match is found. In the meantime, kernels
already dispatched continue executing on their respective
devices. Once T and a matching device d ∈ A is obtained
using select(line 5), the framework spawns a separate child
thread responsible for running setup cq() and dispatch()
functions for mapping T to d (line 5). This ensures that on
the host device i) the master thread running schedule con-
tinues to search for existing task components that are free to
execute on matching devices that are available using select
(lines 3-5) and ii) the subsequent operations for setting up
command queue data structures (once a match is found) and
dispatching each task component (line 5) are performed in
parallel using separate child threads. In the event, if one
of F or A is empty, the schedule procedure remains idle
using sleep till cb update() (line 6). The data structures
F and A are updated by callback functions with new task
components and devices, once they are available again. This
happens following the procedure outlined in cb (lines 13-17).
We note such callback functions when initiated operate in a
parallel thread w.r.t. schedule, executing on the host device.
Once one of these data structures are updated by respective
callbacks, the schedule routine resumes the scheduling loop
(lines 3-5) if any kernel of G remained unﬁnished.
Command Queue Setup: In each child thread, the setup cq
procedure is used to set up the command queue structure Q
(line 5) for a given T and d. The data structure Q = (cid:104)Q, EQ(cid:105)
is ﬁrst initialized using the init routine (line 9) such that
EQ = {} and Q = {q0, q1, · · · , qD} where D represents
the number of command queues to be setup as speciﬁed
by ri ∈ cq for that device d in the JSON ﬁle. We shall
explain how setup cq ﬁnishes setting up Q with the help
of an illustrative example depicted in Fig. 9 where we map
the task component T = {k0, k1, k2, k3, k4} to a GPU device
using a total of 3 command queues i.e. Q = {q0, q1, q2}.
set
the
the procedure next
After
unprocessed with kernels belonging to F RON T (T ) (line
8) and keeps on updating Q until all kernels of T have been
processed (lines 9-12). A kernel k is said to be processed
once all read, write and ndrange operations pertaining to it
have been enqueued to a queue, otherwise it is unprocessed.
Initially, unprocessed = {k0} for the task component T in
Fig. 8. Next, in each iteration of the while loop (lines 10-12) a
kernel k is ﬁrst selected from unprocessed (line 10). A queue
q is selected in a round robin fashion from Q of Q using
selrr(Q) (line 10). Following the rules outlined in Section

initializes

init(),

8

Fig. 9: Command Queue Setup
3, the enq(k, q) function enqueues relevant read, write and
ndrange commands of kernel k to q (line 10). In Fig. 9, we
observe that k0 and q0 are ﬁrst selected and enq(k0, q0)
pushes write commands w1 and w2 to q0 followed by the
ndrange command e1. The write commands correspond to
the two inter edges (b0, b2) and (b1, b3). The setup cq func-
tion next sets up dependencies between relevant operations
i.e. synthesizes EQ of Q using set dependencies() (line 11).
For kernel k0, we have no dependencies to set. Once this is
done, the list unprocessed is updated with the successors of
k that have not been processed using update (line 11).

The sequence of enq calls and step by step construc-
tion of the set EQ by setup cq are highlighted in Fig. 9.
For kernel k1 belonging to IN (T ), enq(k1, q1) pushes the
isolated write operation w3 and the ndrange operation e2
to q1. The set dependencies() function populates EQ with
the dependency (cid:104)e1, e2(cid:105). One may observe that despite
there being a dependency between k0 and k1, the round-
robin selection of queues ensures that write commands
w1 and w2 enqueued to q0 can be interleaved with the
write command w3 enqueued to q1. In a similar fashion,
as depicted in Fig. 9, the enq function pushes operations
for kernels k2, k3 and k4 to q2, q0 and q1 respectively while
the set dependencies() function sets up EQ. One can also
observe that since ndrange operations e2 and e3 belong
to different command queues with no dependencies, they
can also execute in parallel. We note that while setting up
Q, the framework uses low-level OpenCL API calls with
the clEnqueue preﬁx for i) enqueuing commands in each
q ∈ Q ii) associating event objects with each such command
and iii) enforcing dependencies in EQ using these event
objects as discussed in Section 2.
In addition to constructing Q,
Callback Assignment:
setup cq uses the set callbacks function (line 12) to in-
vestigate already enqueued operations pertaining to each
kernel k ∈ EN D(T ) in Q and register multiple instances of
the callback procedure cb (lines 13-17). This is done by reg-
istering an instance of cb using clSetEventCallback()
(refer Section 2) for every event ev associated with certain
commands for all kernels k ∈ EN D(T ) in Q, depending on
the device d where T gets mapped to.
1) If d is a GPU device, callback is registered for events
associated with every dependent read command pertaining
to an inter edge bi, bj ∈ E such that k, bi ∈ EO. In Fig.
9, callbacks are registered for events associated with the

k1k2k3b5b6b7b8b9b10b13b11b12k4b14k0b2b3b4FRONT(T)IN(T)END(T)w1e1w2e4r1w4e3w3e2e5r2callback()q0q1q2b15b16b0b1w1w2e1e2e3e4e5r1r2w3w4HOSTHOSTQ = {q0,q1,q2}Td= {k0,k1,k2,k3,k4,k5}callback()EQ= {}enq(k0,q0)EQ= {<e1,e2>}enq(k1,q1)EQ= {<e1,e2>,<e1,e3>}enq(k2,q2)EQ= {<e1,e2>,<e1,e3>,<e2,e4>}enq(k3,q0)EQ= {<e1,e2>,<e1,e3>,<e2,e4><e3,e5>}enq(k4,q1)setup_cq(T,  Q)read commands r1 and r2 pertaining to kernels k3 and k4
belonging to EN D(T ).
2) If d is a CPU device sharing the same memory space
as that of the host, callback is registered for the event
pertaining to the ndrange operation of k if k, bi ∈ EO
and there exists an inter edge bi, bj ∈ E. If T had been
mapped to a CPU device in Fig. 9, the callbacks would have
been registered with events associated with the ndrange
commands e4 and e5.

While registering each callback instance, the routine
set callbacks() also ensures to specify the associated
event ev, task component T , device d and global task
queue F and device set A in user arg argument of
clSetEventCallback() so that they are accessible once
the callback instance starts execution.
Thread safe Callback Procedure: Each instance of the call-
back function registered using set callbacks() is spawned
at runtime when the associated event completes and follows
the functionality outlined in procedure cb (lines 13-17). The
associated data ev, T , d, F and A as discussed above are ﬁrst
obtained using get user args() (line 14). Next, the routine
update status (line 15) is used to update based on ev which
kernel ki has completely ﬁnished execution in EN D(T ).
We say that a kernel ki has ﬁnished execution if i) ki was
mapped to a CPU and ev pertained to an ndrange command
or ii) ki was mapped to a GPU and every event other
than ev pertaining to dependent read commands have also
completed. This indicates that the output buffers produced
by ki are available in the host memory space. Depending
on which kernel ki has ﬁnished, task components T (cid:48) /∈ F
containing kernels kj ∈ F RON T (T (cid:48)) which are successors
of ki, are next investigated if they are ready for dispatch
in the function get ready succ() (line 15). If it is observed
that all predecessors of every kernel in F RON T (T (cid:48)), have
ﬁnished execution, then T (cid:48) is ready for dispatch. All such
ready task components are populated in the set T (cid:48) and are
added to F using update task queue() (line 16). Finally,
if all kernels of EN D(T ) have ﬁnished execution i.e. all
kernels in T have completed, the device d is returned
back to A using the return device function (line 17). One
may further note that the routines return device() and
update task queue() are rendered thread safe using the
lock() and unlock() functions. As discussed earlier, callback
functions are initiated in separate threads and thus execute
in parallel with the host thread running schedule while
potentially modifying F and A. Furthermore, as described
above multiple callbacks can be registered for the same task
component and can potentially execute simultaneously. It is
therefore imperative that atomic updates are applied to the
shared data structures F and A by the callback functions to
ensure correctness.
Final Dispatch: Once the callback functions are set, the
dispatch function (line 8) is called which executes the
clFlush() function once for each command queue in Q
to ensure that the commands are submitted to the device.
Once this call is made, the associated command queues are
locked i.e. they cannot be used by other task components
that are ready for dispatch.

The algorithm schedule highlights a generic scheduling
framework which allows for specifying the task component
partitioning T and overriding the implementation of the

9

select routine for choosing T ∈ T and d ∈ A with different
scheduling policies. We note that the design principles of
PySchedCL extend beyond OpenCL and holds in general for
any heterogeneous CPU/GPU platform that supports SIMD
style programming and a runtime system that supports
some abstraction of worker queues for enqueuing opera-
tions on compute devices. One can thus incorporate the
methodologies highlighted in this paper by implementing
schedule in CUDA (using streams) or modern frameworks
such as DPC++ (using SYCL queues [12]). The focal point
of our work lies in investigating ﬁne-grained scheduling
techniques as opposed to traditional coarse-grained policies
and presenting a generic design workﬂow for achieving the
same.

5 EXPERIMENTAL RESULTS

The Transformer Neural Network [8] has proven to be a
viable alternative to Recurrent Neural Networks [13], in
Natural Language Processing (NLP) tasks such as Named
Entity Recognition and Neural Machine Translation.

1 , w(cid:124)

2 , w(cid:124)

h , W V

3 ....w(cid:124)

h , W K

The transformer architecture is based on the standard
encoder-decoder architecture used in sequential learning
tasks, and is depicted in Fig. 10. The input to the trans-
former is a sentence matrix X = [w(cid:124)
n] where
wi ∈ Rd represents an embedding vector for each word
in the sentence. The matrix X undergoes transformations
through each layer in the encoder and decoder before
yielding the target vector Y . An attention mechanism is used
to assign scores indicating the importance of each word
in the sentence. This is achieved by a series of matrix
transformations through a mechanism called multi-headed
attention. Each layer in the transformer comprises multiple
heads operating in parallel where each head h represents
a series of linear algebra operations on the sentence ma-
trix X for generating a contextual embedding matrix Zh
comprising contextual embedding vectors for each of the
n words in the sentence. Each head h is characterized by
four parameter weight matrices W Q
h and Wh. The
computation involved in each head h is represented by the
DAG on the right hand side of Fig. 10 (the same DAG
used in the motivation example in Section 2). It can be
observed that the sentence vector X typically undergoes 3
parallel GEMM transformations with the weight matrices
W Q
h to generate Query Q, Key K and Value V
matrices respectively. Using Q and K, as depicted in Fig.
10, the matrices A = QK (cid:124)
followed by B = Sof tmax(A)
are computed where Sof tmax represents a normalized
exponential function [14]. The contextual embedding matrix
C = [h(cid:124)
n] is computed as C = BV . Finally, the
output Zh is obtained by the GEMM operation CWh. The
outputs of each of these heads are concatenated to produce
the ﬁnal contextual embeddings for the sentence. The output
of each layer is passed as input to the following layer similar
to any neural network pipeline.
In contrast to RNNs, the transformer architecture offers
ample scope for parallelization. A single transformer layer
typically comprises, 8 or 16 heads and thus a maximum of
16 ∗ 3 = 48 matrix computations can execute in parallel
given sufﬁcient hardware resources. Since the operations in
each of the layers are similar in nature, we validate our

h , W K

h , W V

3....h(cid:124)

2, h(cid:124)

1, h(cid:124)

10

We execute the clustering scheme for each of the trans-
former DAGs by varying the number of command queues
qcpu ∈ [0, 5] and qgpu ∈ [0, 5] for our target platform
and by varying the number of task components mapped
to the CPU, hcpu ∈ [0, H]. The remaining H − hcpu task
components are mapped to the GPU device. Given this,
let us denote an architecture mapping conﬁguration for
the clustering scheme as mc = (cid:104)qgpu, qcpu, hcpu(cid:105). We have
observed from our experimental results that increasing be-
yond 5 command queues for the CPU and GPU device
does not improve execution time. This may be attributed
to the overhead of managing multiple command queues
by the OpenCL runtime system. The clustering scheme can
also emulate static coarse-grained scheduling decisions if
the entire DAG is mapped to the GPU device using a
single command queue i.e. mc = (1, 0, 0). We consider
clustering with this architecture-mapping conﬁguration to be
the default coarse-grained scheduling scheme against which
we shall compare how ﬁne-grained decisions fare for the
same task component partitioning T .

For each DAG distinguished by the number of heads
H, the best mapping conﬁguration for clustering is the one
which gives the best speedup with respect to time taken by
the DAG to execute in its default conﬁguration. We proﬁle
a total of (H + 1) ∗ qcpu ∗ qgpu such mapping conﬁgurations
for each transformer DAG with H heads and highlight
our observations in Fig. 11. The x-axis denotes the total
number of heads for the transformer. The y-axis represents
the speedups obtained for the best conﬁguration for each
DAG over the default conﬁguration. Each point is labeled by
the qgpu, qcpu tuple corresponding to the best conﬁguration.
We further note that for DAGs with number of heads upto
10 (region to the left of the dotted line), hcpu is 0. For DAGs
having number of heads greater than 10 (region to the right
of the dotted line), we have hcpu = 1.

Thus, for DAGs with H ∈
[1, 10], we observe that the
conﬁguration only
best
differs from the default
conﬁguration with respect
to the qgpu parameter. All
the task components of
the DAGs are scheduled
to the GPU with the only
difference being the num-
ber of command queues assigned to each component.
The key observation in this region is that the transformer
shows a clear speedup of about 15% − 17%,
if ﬁne-
grained scheduling is enabled leveraging multiple com-
mand queues. This highlights the effectiveness of automated
ﬁne-grained scheduling which our framework offers.

Fig. 11: Speedups for Expt. 1

For H ∈ [11, 16], we observe that scheduling one of the
task components of the DAG to the CPU device yields the
maximum speedups. We also observe a jump in the relative
speedup values as compared to the DAGs with H <= 10.
This is because apart from taking ﬁne-grained scheduling
decisions for the GPU device, we are also undertaking
certain ﬁne-grained scheduling decisions for the CPU device
as well. This results in better extraction of application level-
parallelism since mapping a task component to the CPU
results in lesser contention for the GPU device. However we

Fig. 10: Transformer Architecture

experimental ﬁndings by designing a single layer of the
transformer network as a DAG using a PySchedCL based
speciﬁcation. As component kernels, we use kernels that are
readily available from the Polybench [15], NVIDIA OpenCL
[2] benchmark suites.

We conduct a series of experiments classiﬁed into three
broad categories and for each experiment we deﬁne β as the
size of the transformer such that the matrices deﬁned earlier
Q,K,V ,X are all of dimensions β×β. We denote the number
of heads for the transformer as H. All experiments are
executed on the single CPU single GPU platform described
in Section 2.
Experiment 1: Static Scheduling Scheme for Transformer:
We implement a static scheduling scheme called clustering
which is optimized for taking ﬁne-grained decisions and
proﬁle the execution time for a total of 16 transformer
DAGs. The 16 DAGs for the experiment set are generated
by varying the number of heads H ∈ [1, 16] and ﬁxing β for
each DAG as 256.

For our clustering scheme, we set the task component
mappings for each of the 16 DAGs beforehand by con-
ﬁguring i) the kernel preferences using the dev ﬁeld for
each kernel and ii) the task component partitioning T using
the list tc in the speciﬁcation ﬁle. Given the structure of
the DAG, it makes sense to cluster all kernels belonging
to one transformer head into a task component and map
it to a particular device. Since, the transformer heads are
independent, such task component mappings would result
in there being no inter edge buffers. As a result there will be
no read callbacks. Thus for any transformer with H heads,
possible mapping conﬁgurations would be to 1) map all
heads to a GPU device, 2) map 1 head to the CPU and H − 1
heads to the GPU device, ... and ﬁnally H + 1) mapping
all H heads to the GPU device. Since each head is identical,
clustering all kernels of a head into a task component would
result in a total of H + 1 mapping conﬁgurations for a DAG
with H heads.

In the clustering scheme, each task component T for the
DAG is annotated with the maximum bottom level rank
[16] of the kernels in F RON T (T ). The bottom level rank
for any kernel in a DAG represents the maximum time
left to ﬁnish all kernels in the path starting from k to the
last kernel in the DAG. The priority queue F is ordered
with respect to this bottom level rank measure. Since the
order of kernel dispatching and device mapping decisions
are decided beforehand, the clustering scheme is inherently
static.

H1H2H3H16H1H2H3H16H1H2H3H16X12411356XQ = XWhQK = XWhKV = XWhVKTA=QKTB=Softmax(A)C=BVZh = CWhEncoderZDECODER0       2        4        6        8      10       12     14      161.051.101.151.251.301.351.203,33,25,45,45,43,22,02,03,04,05,03,03,05,03,03,0No. of headsSpeedupobserve with H > 10, it is meaningful to migrate only one
head to the CPU device for further speedups. This makes
sense since i) the GPU has an order of magnitude number of
processing elements greater than the CPU under considera-
tion, ii) the kernels selected are optimized for GPUs rather
than CPUs and iii) the CPU device is heavily engaged in
setting up command queues and issuing directives to the
devices in the heterogeneous platform. Mapping more than
1 head for execution on the CPU actually takes more time
to execute than that of mapping the remaining heads to the
GPU device.

The current experiment highlighted how the clustering
scheme has been envisaged for the transformer DAG by
considering speciﬁc DAG head mappings along with a
choice of command queues and devices. Our next two
categories of experiments consider comparing our static
scheme with traditional implementations of coarse-grained
heterogeneous scheduling policies like Eager and HEFT
available in the StarPU framework [5] which are inherently
dynamic in nature i.e. kernel-device mappings are decided
only at runtime.
Experiment 2: Clustering vs Eager Execution: We have
implemented a simplistic eager execution based scheduling
algorithm in our framework inspired from StarPU. In this
strategy, we specify every kernel in the DAG as a separate
task component and each device to use only one command
queue. The select routine is modiﬁed to i) choose task
components based on the bottom level ranks discussed
earlier and ii) select any device d that is available at run-
time irrespective of the individual device preferences of the
kernel. The eager scheduling scheme supports only coarse-
grained scheduling since it implements single command
queue per device. Furthermore, since each task component
is a kernel here, an explicit callback is required for every
kernel to notify the host that it has ﬁnished execution.

For a comparative evaluation of this dynamic scheme
with clustering, we generate a set of input DAGs by keeping
the number of heads H ﬁxed to 16 and by varying the size
parameter β from 64 to 512 in powers of 2. We proﬁle each
such input DAG, using both eager scheduling and clustering
schemes for all possible mapping conﬁgurations. We com-
pute the speedups of execution times taken by clustering
based scheduling for the best mapping conﬁguration over
that of eager and highlight them in Figure 12 (a). The x-axis
represents the size of the transformer head (β) for each DAG
and the y-axis represents the speedup values. Each point in
the plot is again labelled by the tuple qgpu, qcpu used by the
best mapping conﬁguration for the clustering scheme. The
third element of the best conﬁguration hcpu was found to be
1 for each β. It can be observed that clustering outperforms
eager by a considerable margin. The comparison in Fig. 12
brings out the advantage of static ﬁne-grained scheduling
as supported by our framework.
Experiment 3: Clustering vs HEFT: Our ﬁnal experiment
considers the standard Heterogeneous Earliest Finishing
Time First algorithm [16] heft. Similar to eager, the schedul-
ing heuristic heft assumes each task component to represent
one kernel and sets up one command queue for each device.
The select routine is modiﬁed to i) choose the kernel k with
the maximum bottom level rank and for ii) choose the device
d on which k can execute with the earliest ﬁnishing time

11

Fig. 12: Speedup Results for Experiments 2 and 3

(EFT). Assuming execution times for kernels are available
via prior proﬁling, EFT of k executing on a device d is
computed as the sum of its execution time and the execution
time of a kernel k(cid:48) currently executing on d. Considering the
same set of input DAGs used in Experiment 2, we plot the
speedups of the best conﬁgurations of the clustering scheme
over the heft scheme in Fig. 12 (b). As expected, heft performs
better than eager due to the added knowledge of earliest ﬁn-
ishing times for each task. However, heft being implemented
as a dynamic coarse-grained scheduling scheme is short
sighted and fails to exploit concurrency aware scheduling
decisions undertaken by clustering.

Comparative Evaluation: One can also observe from the
speedup values from Experiments 1, 2 and 3 that both heft
and eager perform poorly when compared to both coarse-
grained and ﬁne-grained versions of static clustering. We
explain the reasons behind this by performing a deeper
analysis of the scheduling decisions taken for a DAG with
H = 16 and β = 512 using the Gantt charts for eager heft and
cluster scheduling depicted in Fig. 13. The primary reason
for the poor performance of eager maybe attributed to the
greedy selection of devices based on runtime availability
rather than kernel preference. As a consequence, one can
observe from Fig. 13 (a), that multiple GEMM kernels have
been scheduled on the CPU, thereby taking a signiﬁcantly
larger amount of time. Even though GPU bound GEMM
kernels take less time, the execution of the callbacks are
delayed since the CPU is being heavily used for the GEMM
computation. This is evident from the gaps between the
kernels scheduled on the GPU device. Since the callback
function is initiated using a separate thread for notifying the
host, it might happen that either i) the master thread run-
ning the schedule routine is swapped out of main memory
at that point of time or ii) there are not enough resources
to spawn the thread for running the callback function. As
a result, the read callbacks wait before updating F and
A to allow progress. In contrast, we observe there are
little to no gaps between kernels scheduled on the CPU
device. This indicates that once the ndrange callback for a
kernel executing on the CPU device ﬁnishes, it immediately
updates A. Consequently, the scheduling algorithm contin-
ues to dispatch kernels to the available CPU, thus causing
starvation of the GPU resource.

In contrast to eager scheduling, it may be observed from
Fig. 13, that heft exclusively uses the GPU for the GEMM
kernels and is thus approximately 2.4× faster than eager.
But, heft fundamentally being a dynamic coarse-grained
scheduling policy like eager still relies on read callbacks for
dispatch decisions for every kernel. The successive gaps in-
troduced between each kernel execution in the DAG results

(a) clustering vs eager(b) clustering vs heft   25                  26             27                     28                    29                   210         25                   26             27                     28                    29              210Size of transformer (β)        Size of transformer (β)3.43.23.02.82.62.42.22.22.01.81.61.4Speedup1,33,25,54,11,33,25,54,1in a considerable slowdown.

Fig. 13: Gantt charts for different scheduling algorithms

For our clustering scheme we may observe from Fig. 13
(c), that kernels start executing much later when compared
to kernels being scheduled in the other schemes. This may
be attributed to the fact, that our framework sets up the com-
mand queues ﬁrst with operations pertaining to all kernels
in a task component before actually dispatching the kernels
to their respective devices. Another interesting observation
in Fig. 13 (c) is as follows. Since, the task component par-
titioning T ensures that there exists no inter edge buffers
in EN D(T ) for each task component T in the clustering
scheme, there is no explicit requirement of callbacks which
was the primary bottleneck in the other dynamic schemes.
As a result, there exists no gaps between the execution
of any two successive kernels in the DAG in Fig.13. This
holds true for the default coarse-grained conﬁguration of
clustering as well, since the task component partitioning set
T is same as that of the ﬁne-grained conﬁguration. The
deﬁnition of T coupled with intelligent use of command
queues by the framework for clustering helps in avoiding
these runtime delays and results in a considerable speedup
when compared to dynamic scheduling decisions employed
by eager and heft. The framework has been open-sourced in
Github 1 with scripts for running all the experiments.

6 RELATED WORK
Given the rich API support of CUDA and OpenCL, several
frameworks have emerged over the last few years with the
objective of providing user friendly solutions for develop-
ment of data parallel applications. Frameworks based on
CUDA include OpenACC [17] and HiCUDA [18] which
supports a directive based programming model where rel-
evant annotations in sequential C programs generate data
parallel CUDA code for execution on the GPU. Frameworks
such as GMAC [19] ease programming by not requiring
explicit memory operations while designing CUDA appli-
cations. Several OpenCL based frameworks have also been

1. https://github.com/anighose25/pyschedcl-concurrent

12

envisioned in the past decade for general purpose hetero-
geneous programming. The most notable framework in this
regard is SkelCL [20] which offers support for designing
algorithmic skeletons (higher order functions such as map,
reduce, scan etc) which can be leveraged for implementing
data parallel kernels. Note, the primary approach of this
work is complementary in the sense that they focus on rapid
kernel development, while our work focuses on scheduling
optimizations on target heterogeneous architectures. The
most recent work reported in [3] proposes a novel set of
APIs for specifying dependencies of a DAG thus easing
application development, but does not have explicit algo-
rithm support for scheduling. The VirtCL framework [21]
provides an abstraction layer between the programmer and
the OpenCL runtime system acting as a hypervisor for
scheduling multiple OpenCL applications. The abstraction
framework leverages a proﬁle driven history based schedul-
ing scheme for dispatching OpenCL kernels on multiple de-
vices. However, a major limitation for VirtCL is that it can-
not operate with devices belonging to different platforms.
Our framework in contrast is suited to work with different
OpenCL platforms and supports both static and dynamic
scheduling approaches for mapping OpenCL kernels. There
also exists frameworks such as SnUCL [22], VOCL [23],
MultiCL [6] etc. that extend upon the OpenCL runtime API
which allows OpenCL applications to leverage devices be-
longing to heterogeneous clusters. While SnUCL and VOCL
have no explicit algorithm support for scheduling, MultiCL
relies on coarse-grained scheduling decisions with a focus
on data partitioning across multiple devices. Also, since
these APIs are extensions of OpenCL, one cannot bypass
the requirement of complex host program development for
implementing data parallel applications.

StarPU [5], [24] is a uniﬁed scheduling framework al-
lowing users to design and experiment scheduling policies
for both CUDA and OpenCL applications. The work re-
ported in [4] presents an uniﬁed OpenCL implementation
called SOCL which directly extends StarPU for exclusively
supporting execution of OpenCL workloads across multiple
devices. Both SOCL and StarPU rely on prior proﬁling
information for each task on each device for constructing
a performance model to be used for scheduling decisions
and have algorithm support for coarse-grained scheduling
decisions. In contrast, to the best of our knowledge, our
framework is possibly the ﬁrst to present an automated
mechanism for enforcing ﬁne-grained scheduling decisions
which are relatively more adept in exploiting concurrency
in OpenCL applications.

7 CONCLUSION

We propose a platform agnostic scheduling framework that
not only enables users to design HPC applications with
ease, but also performs optimized scheduling decisions that
exploit both application-level and platform-level concur-
rency. For an application with ample scope for concur-
rency, we have observed that rather than relying on tra-
ditional coarse-grained scheduling decisions, implementing
ﬁne-grained scheduling policies using PySchedCL where the
user speciﬁes an intuitive task component partitioning T
after examining the structure of a DAG application results

(a) eager(b) heftcommand queuestime (seconds)(a) eager(b) heft(c) clustering13

[22] J. Kim, S. Seo, J. Lee, J. Nah, G. Jo, and J. Lee, “Snucl: an opencl
framework for heterogeneous cpu/gpu clusters,” in ICS, pp. 341–
352, 2012.

[23] S. Xiao, P. Balaji, Q. Zhu, R. Thakur, S. Coghlan, H. Lin, G. Wen,
J. Hong, and W. Feng, “Vocl: An optimized environment for
transparent virtualization of graphics processing units,” in InPar,
pp. 1–12, 2012.

[24] A. Hugo, A. Guermouche, P. Wacrenier, and R. Namyst, “Compos-
ing multiple starpu applications over heterogeneous machines: A
supervised approach,” in IJHPCA, pp. 1050–1059, 2013.

[25] A. Maghazeh, S. Chattopadhyay, P. Eles, and Z. Peng, “Cache-
aware kernel tiling: An approach for system-level performance
optimization of gpu-based applications,” in DATE, pp. 570–575,
2019.

[26] N. Mishra, C. Imes, J. D. Lafferty, and H. Hoffmann, “Caloree:
Learning control for predictable latency and low energy,” SIG-
PLAN Notices, vol. 53, no. 2, pp. 184–198, 2018.

in signiﬁcantly better execution times. Future work entails
investigating sophisticated low-level scheduling approaches
such as sub-kernel partitioning [9], [25] at the work-item
level for effective interleaving of concurrent kernels. Such
approaches coupled with Machine Learning assisted con-
trol theoretic scheduling solutions [26] shall be used to
develop an auto-tuning framework on top of PySchedCL
which would automatically determine given an application-
architecture pair, the optimal allocation of command queues
across devices in the platform.

REFERENCES

[1]

J. E. Stone, D. Gohara, and G. Shi, “OpenCL: A Parallel Program-
ming Standard for Heterogeneous Computing Systems,” MCSE,
vol. 12, no. 3, p. 66, 2010.

[2] Nvidia, “Nvidia gpu computing sdk,”
[3] P. J¨a¨askel¨ainen, V. Korhonen, M. Koskela, J. Takala, K. Egiazarian,
A. Danielyan, C. Cruz, P. James, and S. McIntosh-Smith, “Exploit-
ing task parallelism with opencl: A case study,” J. Signal Process.
Syst., 10 2018.
S. Henry, A. Denis, D. Barthou, M.-C. Counilh, and R. Namyst,
“Toward opencl automatic multi-device support,” in Euro-Par,
pp. 776–787, 2014.

[4]

[5] C. Augonnet, S. Thibault, R. Namyst, and P.-A. Wacrenier, “Starpu:
A uniﬁed platform for task scheduling on heterogeneous multi-
core architectures,” in Euro-Par, pp. 863–874, 2009.

[6] A. M. Aji, A. J. Pe ˜na, P. Balaji, and W. chun Feng, “Multicl:
Enabling automatic scheduling for task-parallel workloads in
opencl.,” Parallel Comput, vol. 58, pp. 37–55, 2016.

[7] A. Kl ¨ockner, N. Pinto, Y. Lee, B. Catanzaro, P. Ivanov, and A. Fasih,
“Pycuda and pyopencl: A scripting-based approach to gpu run-
time code generation,” Parallel Comput, vol. 38, no. 3, pp. 157–174,
2012.

[8] A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N.
Gomez, Ł. Kaiser, and I. Polosukhin, “Attention is all you need,”
in NeurIPS, pp. 5998–6008, 2017.
S. . Shekofteh, H. Noori, M. Naghibzadeh, H. Fr ¨oning, and H. S.
Yazdi, “ccuda: Effective co-scheduling of concurrent kernels on
gpus,” IEEE TPDS, vol. 31, no. 4, pp. 766–778, 2020.

[9]

[10] C. Lattner and V. Adve, “”llvm: A compilation framework for
lifelong program analysis & transformation”,” in CGO, pp. 75–86,
IEEE, 2004.

[11] A. Magni, C. Dubach, and M. O’Boyle, “Automatic optimization of
thread-coarsening for graphics processors,” in PACT, pp. 455–466,
2014.

[12] B. Ashbaugh, A. Bader, J. Brodman, J. Hammond, M. Kinsner,
J. Pennycook, R. Schulz, and J. Sewall, “Data parallel c++: Enhanc-
ing sycl through extensions for productivity and performance,” in
IWOCL, 2020.

[13] S. Hochreiter and J. Schmidhuber, “Long short-term memory,”

Neural Comput, vol. 9, no. 8, pp. 1735–1780, 1997.

[14] C. M. Bishop, Pattern recognition and machine learning. springer,

2006.

[15] L.-N. Pouchet, “Polybench benchmark suite,” 2012.
[16] H. Topcuoglu, S. Hariri, and M.-Y. Wu, “Performance-effective and
low-complexity task scheduling for heterogeneous computing,”
TPDS, vol. 13, pp. 260–274, Mar 2002.

[17] T. Hoshino, N. Maruyama, S. Matsuoka, and R. Takaki, “Cuda vs
openacc: Performance case studies with kernel benchmarks and a
memory-bound cfd application,” in CCGrid, pp. 136–143, 2013.
[18] T. D. Han and T. S. Abdelrahman, “hicuda: High-level gpgpu

programming,” TPDS, vol. 22, no. 1, pp. 78–90, 2011.

[19] I. Gelado, J. E. Stone, J. Cabezas, S. Patel, N. Navarro, and W.-
m. W. Hwu, “An asymmetric distributed shared memory model
for heterogeneous parallel systems,” in ASPLOS, pp. 347–358,
2010.

[20] M. Steuwer, P. Kegel, and S. Gorlatch, “Skelcl - a portable skeleton
library for high-level gpu programming,” in IPDPS Phd Forum,
pp. 1176–1182, 2011.

[21] Y.-P. You, H.-J. Wu, Y.-N. Tsai, and Y.-T. Chao, “VirtCL: a frame-
work for OpenCL device abstraction and management,” in PPoPP,
pp. 161–172, 2015.

