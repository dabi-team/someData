0
2
0
2

g
u
A
1
3

]
E
S
.
s
c
[

1
v
9
8
4
3
1
.
8
0
0
2
:
v
i
X
r
a

BiLO-CPDP: Bi-Level Programming for Automated
Model Discovery in Cross-Project Defect Prediction∗

Ke Li1, Zilin Xiang2, Tao Chen3 and Kay Chen Tan4

1Department of Computer Science, University of Exeter, EX4 4QF, Exeter, UK
2College of Computer Science and Engineering, University of Electronic Science and Technology of
China, 611731, Chengdu, China
3Department of Computer Science, Loughborough University, Loughborough, LE11 3TU, UK
4Department of Computer Science, City University of Hong Kong, Tat Chee Avenue, Hong Kong
∗Email: k.li@exeter.ac.uk, zilin.xiang@gmail.com, t.t.chen@lboro.ac.uk

Abstract: Cross-Project Defect Prediction (CPDP), which borrows data from similar projects
by combining a transfer learner with a classiﬁer, have emerged as a promising way to predict software
defects when the available data about the target project is insuﬃcient. However, developing such
a model is challenge because it is diﬃcult to determine the right combination of transfer learner
and classiﬁer along with their optimal hyper-parameter settings. In this paper, we propose a tool,
dubbed BiLO-CPDP, which is the ﬁrst of its kind to formulate the automated CPDP model discovery
from the perspective of bi-level programming. In particular, the bi-level programming proceeds the
optimization with two nested levels in a hierarchical manner. Speciﬁcally, the upper-level optimization
routine is designed to search for the right combination of transfer learner and classiﬁer while the
nested lower-level optimization routine aims to optimize the corresponding hyper-parameter settings.
To evaluate BiLO-CPDP, we conduct experiments on 20 projects to compare it with a total of 21
existing CPDP techniques, along with its single-level optimization variant and Auto-Sklearn, a state-
of-the-art automated machine learning tool. Empirical results show that BiLO-CPDP champions better
prediction performance than all other 21 existing CPDP techniques on 70% of the projects, while
being overwhelmingly superior to Auto-Sklearn and its single-level optimization variant on all cases.
Furthermore, the unique bi-level formalization in BiLO-CPDP also permits to allocate more budget to
the upper-level, which signiﬁcantly boosts the performance.

Keywords: Cross-project defect prediction, transfer learning, classiﬁcation techniques, auto-

mated parameter optimization, conﬁgurable software and tool

1

Introduction

Software defects are errors in code and its logic that cause a software product to malfunction or to
produce incorrect/unexpected results. Given that software systems become increasingly ubiquitous in
our modern society, software defects are highly likely to result in disastrous consequences to businesses
and daily lives. For example, the latest Annual Software Fail Watch report from Tricentis1 shows
that, globally, software defects/failures aﬀected over 3.7 billion people and caused $1.7 trillion in lost
revenue.

One of the key reasons behind the prevalent defects in modern software systems is their increasingly
soaring size and complexity. Due to the limited resource for software quality assurance and the intrinsic
dependency among a large number of software modules, it is expensive, if not impossible, to rely on
human eﬀorts (e.g., code review) to thoroughly inspect software defects. Instead, it is more pragmatic
to predict the defect-prone software modules to which software engineers are suggested to focus their

∗This manuscript is accepted for publication in ASE 2020. The copyright of this paper has been permanently

transferred to ACM.

1https://www.tricentis.com/resources/software-fail-watch-5th-edition/

1

 
 
 
 
 
 
limited software quality assurance resource. To this end, machine learning algorithms have been widely
used to automate the process of defect prediction.

As discussed in [1], one of the keys to the success of defect prediction models is the amount
of data available for model training.
In practice, however, it is unfortunately not uncommon that
such data is scarce or even unavailable. This can be attributed to the small size of the company
and/or the targeted software project is the ﬁrst of its kind. Cross project defect prediction (CPDP),
which aims to predict defects in the a software project by leveraging experience (e.g., training data or
hyper-parameters of trained defect prediction models) from other existing ones, has therefore become
extremely appealing [2]. Unfortunately, partially due to the diﬀerence of the data distribution between
the source and the target projects, the performance of vanilla CPDP is not as promising as it was
supposed to be [3]. Transfer learning, which is able to transfer knowledge across diﬀerent domains, has
shown to be able to overcome the aforementioned challenges (e.g., data scarcity and data distribution
discrepancy) and has gradually become the main driving force for CPDP [4]. Generally speaking, the
basic idea is to equip a machine learning classiﬁer with a transfer learner that enables its ability to
learn from other projects in model building.

There is No Free Lunch in defect prediction given that machine learning enabled defect prediction
models often come with conﬁgurable and adaptable parameters (87% prevalent classiﬁers are with at
least one parameter [5,6]). The prediction accuracy on various software projects largely depends on the
parameter settings of those defect prediction models [7,8]. Furthermore, it becomes more complicated
in CPDP because: 1) the conﬁgurable parameters is augmented by the transfer learner (85% widely
used CPDP techniques require at least one parameter to setup in the transfer learner) thus lead to
an enlarged search space; 2) there exist complex yet unknown interactions among the parameters of
the classiﬁer and those of the transfer learner (that is to say parameter optimization over either the
classiﬁer or the transfer learner alone may not lead to the overall optimal performance); and 3) the
optimal selection of the combination of classiﬁer and transfer learner is as important as parameter
optimization but is unfortunately ignored in the current literature (most, if not all, CPDP models are
designed with an ad-hoc combination of transfer learner and classiﬁer, the performance of which is
reported to be far from optimal [9]). Although there exist some prior works considering the hyper-
parameter optimization for CPDP models [10,11], they only consider the hyper-parameters associated
with the classiﬁer. As investigated in a latest empirical study [9], this practice is far from truly
optimizing the performance of the underlying CPDP model while the settings of hyper-parameters of
the transfer learner are more decisive.

Bearing the above considerations in mind, we propose a new tool, dubbed BiLO-CPDP, to automate
the model discovery for CPDP tasks. It provides an uniﬁed perspective for the combinatorial selection
of classiﬁer and transfer learner, as well as their hyper-parameter optimization within the mathematical
framework of bi-level programming, where two levels of nested optimization problems are formulated:
the upper-level optimization problem is solved subject to the optimality of a lower-level optimization
problem. Speciﬁcally, the upper-level optimization problem aims to identify the optimal combination
of transfer learner and classiﬁer from a given portfolio; while the lower-level optimization problem is
dedicated to searching for the optimal parameter setting associated with the corresponding transfer
learner and classiﬁer. Note that a combination of transfer learner and classiﬁer is not considered to be
feasible for comparison unless the corresponding parameters have been optimized. In BiLO-CPDP, the
upper-level optimization is formulated as a combinatorial optimization problem which is solved by the
Tabu search [12] while the lower-level optimization is modeled as an expensive optimization problem
with a limited budget to be solved by Tree-structured Parzen Estimator (TPE) [13], a state-of-the-art
Bayesian optimization algorithm.

To evaluate the the eﬀectiveness of BiLO-CPDP for automated model discovery in CPDP, we
conduct experiments to compare it with 21 existing CPDP techniques, its single-level variant and
Auto-Sklearn [14] — a state-of-the-art automated machine learning (AutoML) tool— over 20 dis-
tinct projects. The results fully demonstrate the overwhelming superiority of BiLO-CPDP over the
others with statistical signiﬁcance and a large eﬀect size on all projects.
In summary, the key contributions of this paper are as follows:

• To the best of our knowledge, BiLO-CPDP is the ﬁrst of its kind for automating CPDP from

2

the perspective of bi-level programming. Given that BiLO-CPDP is not only able to automat-
ically search the optimal combination of transfer learner and classiﬁer, but also can set their
appropriate hyper-parameter settings, it paves a new avenue for automated model discovery in
CPDP.

• Through extensive experiments with 21 existing CPDP techniques, we show that BiLO-CPDP is
the best on 14 out of 20 projects, and second to only one existing technique for another ﬁve.
This fully demonstrates the eﬀectiveness and importance brought by automatically choosing the
appropriate transfer learner and classiﬁer associated with their optimal hyper-parameter settings
for CPDP.

• In terms of optimization problem formulation, on all projects, we show that the bi-level pro-
gramming formulated in BiLO- CPDP is statistically better than hybridizing both combinatorial
selection and parameter optimization as a single-level global optimization problem, which is
perhaps a more conservative solution as used in, e.g., Auto-Sklearn [14].

• Interestingly, from our experimental results, we disclose that choosing the best combination
of classiﬁer and transfer learner (upper level) is more important than fully optimizing their
parameters (lower level). Henceforth, given the limited resource for software quality assurance,
it is beneﬁcial to allocate more search budget to the upper-level optimization.

In the rest of this paper, Section 2 gives the background about bi-level programming. Section 3
delineates the algorithmic implementation of BiLO-CPDP step by step. The experimental setup is
introduced in Section 4 and the results are analyzed in Section 5. Thereafter, Section 6 and 7 reviews
the related works and discusses the threats to validity, respectively. Finally, Section 8 concludes this
paper and threads some lights on future directions.

2 Bi-level Programming

Bi-level programming is a mathematical program within which one optimization problem is nested
within another in a hierarchical manner [15]. It is ubiquitous in many real-world optimization and
public/private sector decision-making problems where the realized outcome of any solution or decision
leader) to optimize their objectives is aﬀected by the
taken by the upper-level authority (a.k.a.
response of lower-level entities (a.k.a. follower), who seek to optimize their own outcomes. This is in
principle similar to the Stackelberg games [16] in which a leader ﬁrst makes its move and a follower
maximizes the corresponding gain by taking the leader’s move into account. It is interesting to note
that the two levels of optimization problems are asymmetric in bi-level programming. That is to
say, the upper-level leader has the entire picture of optimization problems at both levels whereas the
lower-level follower usually takes the decisions from the leader and then optimizes its own strategies.

The bi-level programming formulated in BiLO-CPDP can be mathematically deﬁned as:

maximize
xu∈Λd×Rn,xl∈Rn
subject to

F (xu, xl∗)

xl∗ ∈ argmax{fxu(xl)}

,

(1)

where xu ∈ Λd × Rn and xl ∈ Rn denote the upper- and lower-level variables2 while F : Λd × Rn → R
and fxu : Rn → R are the upper-level and lower-level objective functions, respectively (details can be
found in Section 3). A bi-level programming that involves nested optimization/decision-making tasks
at both levels. For any given combination xu, there exists a (xu, xl∗) pair where xl∗ is an optimal (or
near-optimal) response to xu represents a feasible solution to the upper-level optimization problem
given that it also satisﬁes the constraints therein.

2Λd × Rn means that the problem is a discrete combinatorial problem.

3

Figure 1: The overall architecture of BiLO-CPDP.

3 Bi-level Programming for Automated CPDP Model Discovery

The CPDP model building process consists of two intertwined parts: 1) transfer learning that augments
data from diﬀerent domains by selecting relevant instances or assigning appropriate weights to diﬀerent
instances; and 2) defect prediction model building based on adapted data. As reported in a latest
research [9], the performance of a CPDP model largely depend on the combination of transfer learner
and classiﬁer along with their hyper-parameter settings. In light of this, the BiLO-CPDP proposed in
this work was speciﬁcally designed to address such a problem. Through automatically discovering the
best combination of transfer learner and classiﬁer as well as their optimal hyper-parameter settings,
BiLO-CPDP serves as an automatic tool that provides a de nova CPDP model discovery. In this section,
we will delineate the architecture of BiLO-CPDP and the algorithmic details of its optimization routines
at both levels.

3.1 Overview of BiLO-CPDP

The overall architecture of BiLO-CPDP is illustrated in Fig. 1 which consists of three key phases, i.e.,
data pre-processing, optimization and performance validation.

1. Data Pre-processing: Given a raw dataset with N > 1 projects, software engineers are asked
to specify which one is the target domain that serves as the target domain data while the
remaining N − 1 projects are then used as the source domain data. In particular, all source
domain data are used in the model training while a part of the target domain data is used as
the hold-out set for the testing purpose. As the default in BiLO-CPDP, we use 10% of the target
domain data for testing while the remaining 90% is for training. This is because some transfer
learners considered in this work do need data from the target domain in training, e.g., MCWs [17].
For other transfer learners that can be trained independently to the target domain, we use all
data for testing.

4

bar.cbar.hfoo.cfoo.hsource domain training databar.cbar.hfoo.cfoo.htarget domaintraining data············target domaintesting datarawdatasetcalculate testingperformancetransfer learningalgorithmsdefect predictionmodelUpper-level optimiztion00.51transfer learnerclassifierAUCTabu searchData pre-processingLow-level optimiztioncalculate trainingperformanceOptimizationPerformancevalidationTPETable 1: Overview of 13 selected transfer learners ([N], [R] and [C] denote integer, real and categorical
value, respectively).

Algorithm Parameter

NNfilter
[20]

k [N]
metric [C]

kernel [C]

TCA+ [4]

dime [N]

lamb [R]
gama [R]
k [N]
sigma [R]
lambda [R]
strategy [C]
k [N]

MCWs [17]

TD [28]

Range
[1, 100]
Euc, Man, Che,
Min, Mah
primal, rbf,
linear, sam
[5, max(N s,
N t)]
[10E − 7, 100]
[10E − 6, 100]
[2, N s]
[0.01, 10]
[10E − 7, 100]
NN, EM
[1, N s]

Algorithm Parameter

CDE SMOTE
[21]

k [N]
metric [C]

GIS [23]

prob [R]
chrm size [R]
pop size [N]
num parts [N]
num gens [N]
mcount [N]

Range
[1, 100]
Euc, Man, Che,
Min, Mah
[0.02, 0.1]
[0.02, 0.1]
[2, 30]
[2, 6]
[5, 20]
[3, 10]

Algorithm Parameter

FSS bagging
[22]

topN [N]
threshold [R]
ratio [R]

CLIFE MORPH
[24]

n [N]
alpha [R]
beta [R]
per [R]

Range
[1, 15]
[0.3, 0.7]
[0.1, 0.5]

[1, 100]
[0.05, 0.2]]
[0.2, 0.4]
[0.6, 0.9]

HISNN [25] minham [N]

[1, N s]

FeSCH [26]

nt [N]
strategy [C]

[1, N s]
SFD, LDF, FCR

UM [27]

p [R]
qua T [C]

[0.01, 0.1]
cli , cohen

VCB [29]

m [N]
lambda [R]

[2, 30]
[0.5, 1.5]

PCAmining
[30]

dime [N]

[5, max(N s,
N t)

For full speciﬁcation of all the parameters, please visit our repository: https://github.com/COLA-Laboratory/
ase2020

2. Optimization: BiLO-CPDP models CPDP as a bi-level programming that not only identiﬁes
the most competitive combination of transfer leaner and classiﬁer for the underlying CPDP
task (tackled by the upper-level routine), but also equips the chosen CPDP model with the
appropriate hyper-parameter settings (carried out by the lower-level routine). Since the resources
for software quality assurance are often limited, the entire optimization process would inevitably
be constrained under a computational budget of running time. In this regard, the unique bi-level
programming formulated in BiLO-CPDP can in fact provide a ﬁne-grained and ﬂexible allocation
of the budget between upper- and lower-level, whose eﬀects will be investigated as part of the
experimental evaluation in Section 5.4. The CPDP model, which has the best combination with
its optimal hyper-parameter settings in terms of the training accuracy, is returned in the end.
Note that due to the lack of data samples, using training accuracy in the parameter optimization
of transfer learner is not uncommon and has shown promising results for CPDP [9].

3. Performance Validation: After the optimization phase, as an optional module in BiLO-CPDP,
the generalization of the built CPDP model can be validated and tested by using the hold-out set
from the target domain data, which is unknown during training stage. In practice, this will be
the new project that one wishes to predict defects for. In BiLO-CPDP, the area under the receiver
operating characteristic (ROC) curve, i.e., AUC [18], is applied as the performance metric to
measure the eﬀectiveness of a model. Formally, AUC is deﬁned as:

AU C =

(cid:80)

t−∈D−

(cid:80)

t+∈D+ 1 [P red (t−) < P red (t+)]

|D−| · |D+|

,

(2)

where P red(t) is the probability that sample t is predicted to be a positive sample, and 1 [f (t−) < f (t+)]
is an indicator function which returns 1 if f (t−) < f (t+) otherwise it returns 0. D− is the set
of negative samples, and D+ is the set of positive samples. Apart from the fact that AUC has
been widely for software defect prediction [9], it has two distinctive characteristics: 1) diﬀerent
from other prevalent metrics like precision and recall, AUC does not depend on a particular
threshold [18], which is diﬃcult to tweak in order to carry out an unbiased assessment; and 2)
it is not sensitive to imbalanced data which is not uncommon in software defect prediction [19].
The larger the AUC value is, the better prediction accuracy the model achieves. In particular,
the AUC value ranges between 0 and 1 where 0 indicates the worst performance, 0.5 corresponds
a randomly guessed performance and 1 represents the best performance. Note that AUC is also
the metric used in optimization phase to evaluate and compare training accuracy.

5

Table 2: Overview of 16 selected classiﬁers ([N], [R] and [C] denote integer, real and categorical value,
respectively).

Algorithm Parameter

Algorithm Parameter

Extra
Trees
Classifier
(EXs)

Random
Forest (RF)

Passive
Aggressive
Classifier
(PAC)

Ridge

KNearest N-
eighbor(KNN)

adaBoost

max e [N]
criterion [C]
min s l [N]
splitter [C]
min a p [N]
m stim [N]
criterion [C]
splitter [C]
min s l [N]
min a p [N]
C [R]
ﬁt int [C]
tol [R]
loss [C]
alpha [R]
ﬁt int [C]
tol [R]
n neigh [N]
p [N]
n est [N]
rate [R]

Range
[10, 100]
gini, entropy
[1, 20]
random, best
[2, N s/10]
[10, 100]
gini, entropy
auto, sqrt, log2
[1, 20]
[2, N s/10]
[0.001, 100]
true, false
[10E − 6, 0.1]
hinge, s hinge
[10E − 5, 1000]
ture, false
[10E − 6, 0.1]
[1, 50]
[1, 5]
[10, 1000]
[0.01, 10]

Algorithm Parameter

max e [N]
criterion [C]
min s l [N]
splitter [C]
min a p [N]
C [R]
kernel [C]
degree [N]
coef0 [R]
gamma [R]
penalty [C]
alpha [R]
ﬁt int [C]
tol [R]
n est [N]
max s [R]
max f [R]
radius [R]
weight [C]

Extra
Tree
Classifier
(EXtree)

Support
Vector
Machine
(SVM)

Perceptron

Bagging

Radius
Neighbors
Classifier
(RNC)

Range
[10, 100]
gini, entropy
[1, 20]
random, best
[2, N s/10]
[0.001, 10]
rbf, lin, poly, sig
[1, 5]
[0, 10]
[0.01, 100]
L1, L2
[10E − 6, 0.1]
true, false
[10E − 6, 0.1]
[10, 200]
[0.7, 1.0]
[0.7, 1.0]
[0, 10000]
uni, dist

Decision
Tree (DT)

Multilayer
Perceptron
(MLP)

Naive
Bayes (NB)

Logistic
Regression
(LR)
Nearest
Centroid
Classifier
(NCC)

max e [N]
criterion [C]
min s l [N]
splitter [C]
min a p [N]
active [C]

hid l s [N]
solver [C]
iter [N]
NBType [C]

alpha [R]
norm [C]
penalty [C]
ﬁt int [C]
tol [R]

Range
[10, 100]
gini, entropy
[1, 20]
auto, sqrt, log2
[2, N s/10]
iden, log,
tanh, relu
[50, 200]
lbfgs, sgd, adam
[100, 250]
gauss,
multi, comp
[0, 10]
ture, false
L1, L2
ture, false
[10E − 6, 0.1]

metric [C] Euc, Man, Che,

shrink t [R]

Min, Mah
[0, 10]

For full speciﬁcation of all the parameters, please visit our repository: https://github.com/COLA-Laboratory/
ase2020

3.2 Upper-Level Optimization

Tables 1 and 2 respectively list the transfer learners and the classiﬁers considered in our work, which
form the portfolios. Note that all transfer learners considered in BiLO-CPDP have been used in either
the defect prediction or CPDP literature while the classiﬁers come from scikit-learn3, the state-of-
the-art machine learning Python library. In addition, the corresponding hyper-parameters associated
with those transfer learners and classiﬁers along with their value ranges are also provided in the
corresponding tables. Any combination of a transfer learner and a classiﬁer comes up with a CPDP
model. The ultimate goal of the upper-level optimization is to search for the best combination out
of all possible alternatives (208 in this work) for the underlying CPDP task. In particular, for each
candidate combination of transfer learner and classiﬁer, their corresponding hyper-parameter settings
are optimized via a lower-level optimization routine which will be explained in Section 3.3.

At the upper-level in BiLO-CPDP, the search of the best combination of transfer learner and classiﬁer

is solved as a combinatorial optimization problem as speciﬁed below.

• Search space: For the upper level, the search space consists of all the valid combinations of
transfer learners and classiﬁer picked up from the given portfolios, i.e., those listed in Tables 1
and 2. In practice, such portfolios can be amended and speciﬁed by the software engineers based
on their preferences/requirements.

• Objective function: Recall from the equation (1), the objective function for the upper level
F (xu, xl∗) takes a combination from the portfolio (xu) and the optimized hyper-parameter of
such combination (xl∗) as inputs. It then outputs the corresponding training AUC obtained by
training the CPDP model for comparison. Note that xl∗ is initially unknown for a given xu at the
upper-level before running a lower-level optimization routine. Therefore, the objective function
at upper-level optimization is constrained and determined by the lower-level optimization.

• Optimization algorithm: For the upper-level optimization in BiLO-CPDP, we use Tabu search [12]
to serve as the optimizer, which is also the entry point of the optimization phase. In particular,
we use Tabu search in this work because:

3https://scikit-learn.org/stable/

6

Algorithm 1: runTabuSearch: Upper-level optimization that tunes the combination of trans-
fer learner and classiﬁer.

Input: Portfolio of transfer learners T and classiﬁers C
Output: Optimal CPDP model xu

opt and its optimal parameter settings xl∗
opt

1 Randomly initialize a valid combination of transfer learner and classiﬁer xu ← (t, c); /* t ∈ T

and c ∈ C are a candidate transfer learner and classifier */

2 (cid:96)t ← ∅;
3 while The overall time budget is not exhausted do
4

[(xu, xl∗), F (xu, xl∗)] ← searchCandidate(xu, (cid:96)t);
if xu /∈ (cid:96)t then
(cid:96)t ← (cid:96)t

(cid:83){xu};

5

6

/* (cid:96)t is the tabu list */

7 return (xu

opt, xl∗

opt) ← argmaxxu∈(cid:96)t{F (xu, xl∗)};

Algorithm 2: searchCandidate(xu, (cid:96)t): Search the next combination candidate from the
neighborhood of xu

Input: Candidate CPDP model xu and newest tabu list (cid:96)t
Output: The best CPDP model within xu’s neighbor and its optimal parameter settings xopt,

the performance of this CPDP model fopt, i.e., the value of F (xu, xl∗)

1 δ ← Get the neighbors of xu;
2 Θxu ← Get the conﬁguration space of the transfer learner and the classiﬁer speciﬁed by xu;
3 [xl(cid:48), fxu(xl(cid:48))] ← runTPE(xu, Θxu);
4 xopt ← (xu, xl(cid:48)), fopt ← fxu(xl(cid:48));
5 foreach xc ∈ δ ∧ xc /∈ (cid:96)t do
6

Θxc ← Get the conﬁguration space of the transfer learner and the classiﬁer speciﬁed by xc;
[xl(cid:48), fxc(xl(cid:48))] ← runTPE(xc, Θxc);
if fxc(xl(cid:48)) > fopt then

xopt ← (xc, xl(cid:48)), fopt ← fxc(xl(cid:48));

7

8

9

10 return xopt, fopt;

– Our problem is expensive and thus it is unrealistic for an exact search to reach the optimal
solution. Metaheuristic such as Tabu search, which does not guarantee optimum but can
often produce near-optimal result, is more practical and acceptable.

– Unlike other metaheuristics, Tabu search employs local search to speed up its conver-

gence [12].

– Tabu search permits a better chance to escape from local optima than other local search

methods [12].

As shown in in Algorithm 1 and Algorithm 2, Tabu search carries out a neighborhood search
where the neighborhood of the current solution is restricted by the search history of previously
visited solutions and is stored in the form of a tabu list (lines 5 and 6 in Algorithm 1 and lines
5 to 9 in Algorithm 2). If all neighbors are tabu, it is acceptable to take a move that worsen the
value of the objective function (lines 3 and 4 in Algorithm 2). This is what enables Tabu search
to escape from local optima, which is highly likely to cause issues with a traditional gradient
decent method. According to a provided selection criteria, Tabu search only keep a record of
some previously visited states.

3.3 Lower-Level Optimization

As introduced in Section 3.1, the main purpose of the lower-level optimization is to optimize the hyper-
parameters associated with the chosen combination of transfer learner and classiﬁer. Speciﬁcally, this

7

Algorithm 3: runTPE(xu, Θxu): Lower-level optimization for identifying the optimal hyper-
parameters.

Input: Combination of transfer learner and classiﬁer xu, conﬁguration space Θc
Output: Optimized hyper-parameters xl∗ and its objective function fxu(xl∗)

1 D ← Use space-ﬁlling to sample a set of hyper-parameters from Θc and evaluate their objective

functions;

2 while The lower-level time budget is not exhausted do
3

Use Tree Parzen to build a surrogate model based on D;
xlc ← Best conﬁguration based on the AUC predicted by the acquisition function over the
surrogate model;
fxu(xlc) ← Evaluate the objective function of xlc by physically training the CPDP model;
D = D (cid:83){(xlc, fxu(xlc))};

4

5

6
7 return (xl∗, fxu(xl∗)) ← argmax(xlc ,fxu (xlc ))∈D{fxu(xlc)};

level in BiLO-CPDP is modeled and tackled as below.

• Search space: At this level, the search space is the conﬁguration space of the corresponding
parameters for the transfer learner and classiﬁer picked up from the upper-level routine. Indeed,
as can be seen from Tables 1 and 2, such a conﬁguration space might be diﬀerent depending on
the chosen combination of transfer learner and classiﬁer.

• Objective function: Recall from the equation (1), when a combination of transfer learner and
classiﬁer is picked up from the upper-level routine, the objective function for the lower-level f (xl)
takes the conﬁguration of the corresponding hyper-parameters as the inputs (xl) and outputs
the training AUC for the CPDP model. The AUC collected from the result of the low-level
routine is ﬁnally used as the objective value at the upper-level routine to steer the optimization.

• Optimization algorithm: It is not uncommon that the training and evaluation of a CPDP
model is computationally demanding and time consuming. To this end, in BiLO-CPDP, we apply
the Tree-structured Parzen Estimator (TPE) [13] — a state-of-the-art Bayesian optimization
algorithm for hyper-parameter optimization of machine learning algorithms — as the optimizer
for the lower-level optimization, due primarily to the following reasons:

– TPE copes with a wide range of variables well, including integer, real, and categorical ones,

which ﬁts precisely with our need [13].

– Recent work on CPDP [9] and from the machine learning community [31] have reported

the outstanding performance of TPE for expensive conﬁguration problems.

As the pseudo-code shown in Algorithm 3, the TPE algorithm ﬁrst uses a space-ﬁlling technique
to sample a set of hyper-parameters’ values from the given conﬁguration space Θc of transfer
learner and classiﬁer, which would then be trained for collecting the training AUC performance
(line 1). All these constitute the initial dataset D. During the main while-loop, a relatively cheap
surrogate model of the expensive physical model training and the AUC evaluation is built based
on all sampled data in D (line 3). Thereafter, a promising hyper-parameter conﬁguration trial
xlc is identiﬁed by optimizing the acquisition function (i.e., expected improvement) following
a classic Bayesian optimization rigour. The AUC of xlc is thereafter evaluated and used to
augment D (lines 4 to 6). At the end, the best hyper-parameter setting xl∗ in D along with its
AUC performance fxu(xl∗) are returned to the upper-level optimization routine (line 7).

8

4 Experimental Setup

This section introduces our experiment setups4.

4.1 Dataset

In our experiments, the dataset of software projects is collected according to the following three
inclusion criteria:

1. To promote the reproducibility and practicality of our experiments, we only consider projects

hosted in public repositories and are related to non-academic software.

2. To mitigate potential conclusion bias, projects are required to cover diﬀerent corpora and do-

mains.

3. To ensure the credibility of experiments, we focus on projects that have already been used in

the CPDP literature.

Note that a project is temporarily selected if it meets all above three criteria. To further reﬁne our
dataset composition, we apply the following two exclusion criteria to rule out inappropriate projects.

1. It is not uncommon that the projects are evolved with more than one version during their
lifetime. Since diﬀerent versions of the same project are highly likely to share many similarities,
they may simplify the transfer learning. In this case, only the latest version of the project is
kept.

2. To promote the robustness of experiments, projects with repeated or missing data are ruled out

from our consideration.

Based on the above inclusion criteria, we select ﬁve publicly available datasets, i.e., JURECZKO,
NASA, SOFTLAB, AEEEM, ReLink. Note that all these datasets have been reviewed and discussed in
many recent survey in the CPDP literature [2,18,32,33]. Thereafter, SOFTLAB is further ruled out from
our consideration according to the above exclusion criteria. In addition, NASA is also not considered
in our experiments since its data quality is relatively poor as reported in [34]. At the end, the
dataset considered in our experiments consist of 20 open source projects with 10,952 instances. Its
characteristics are summarized as follows:

• AEEEM [35]: This dataset contains 5 open source projects with 5,371 instances. In particular,
each instance has 61 metrics with two diﬀerent types, including static and process metrics like
the entropy of code changes and source code chorn.

• ReLink [36]: This dataset consists of 3 open source projects with 649 instances. In particular,
each instance comes with 26 static metrics. Note that the defect labels are further manually
veriﬁed after being generated from source code management system commit comments.

• JURECZKO [37]: This dataset originally consists of 92 released software collected from a mix of
open sourced, proprietary and academic projects. With respect to the ﬁrst inclusion criterion,
those proprietary and academic projects are not considered. Moreover, since the projects in
JURECZKO have been updated more than once, according to the ﬁrst exclusion criterion, only
the latest version of a project is considered in our experiments. Ultimately, we choose 12 open
source projects with 4,932 instances from JURECZKO.

4All source code and data of this work can be publicly accessed via our repository: https://github.com/

COLA-Laboratory/ase2020

9

Table 3: Scott-Knott test on BiLO-CPDP and existing CPDP techniques over 30 runs. (the larger rank,
the better; gray=the best)

e
h
c
a
p
CPDP Technique A
6
2
5
3
3
3
1
4
4
3
2
4
4
4
4
3
4
2
2
3
4
6

NNfilter-NB
UM-NB
UM-LR
CLIFE-NB
CLIFE-KNN
FeSCH-RF
GIS-NB
FeSCH-LR
CLIFE-SVM
TD-RF
TD-LR
TD-MLP
TD-DT
FeSCH-DT
VCB-SVM
CDE SMOTE-RF
CDE SMOTE-KNN
FSS bagging-RF
FSS bagging-NB
FSS bagging-LR
HISNN-NB
BiLO-CPDP

T
D
J
4
6
6
4
7
4
1
4
4
6
4
4
6
3
7
4
4
5
2
5
1
7

C
L
8
5
7
3
4
2
3
1
4
3
3
3
3
3
3
5
3
3
4
3
1
6

L
M
5
4
4
1
2
3
1
2
3
2
2
1
2
2
2
2
1
1
3
3
1
5

E
D
P
3
3
3
3
3
3
1
3
2
3
3
3
3
3
3
3
3
3
2
3
1
4

e
f
a
S
8
1
6
6
1
5
1
5
1
5
5
1
4
5
2
1
5
1
3
6
6
7

Q
E
5
7
3
4
3
3
3
3
3
3
1
3
6
3
2
4
3
8
3
3
1
8

t
a
c
m
o
T
14
9
12
9
12
10
9
2
7
6
9
7
8
8
2
1
1
4
11
5
3
13

g
n
i
x
Z
4
4
4
1
4
1
4
1
4
3
1
4
1
2
1
4
4
4
4
1
4
5

l
e
m
a
c
7
7
5
4
3
2
5
3
3
3
3
3
3
3
2
1
1
2
3
2
3
6

y
v
i

9
11
10
6
6
8
5
7
8
2
6
8
7
5
2
1
1
2
3
8
4
12

t
n
a
6
10
9
8
7
6
10
7
2
5
4
7
6
7
2
1
1
3
6
4
4
11

t
i
d
E

j

3
5
7
8
7
8
8
5
6
8
8
7
6
2
5
1
1
6
8
9
4
10

e
s
p
a
n
y
s

2
6
4
4
4
4
4
5
3
3
3
3
3
3
1
1
3
3
3
4
3
6

i
o
p
6
8
4
6
4
5
4
4
7
4
4
5
3
2
2
1
1
3
2
4
2
8

e
n
e
c
u

l

8
7
5
4
4
4
4
4
4
4
4
2
1
1
4
2
6
4
2
3
2
7

y
t
i
c
o
l
e
v
3
8
3
5
4
5
6
7
3
5
6
5
5
2
1
1
2
6
2
4
3
9

j
4
g
o
l

8
9
10
7
6
4
7
5
6
3
6
4
5
8
3
3
4
1
1
2
3
11

n
a
l
a
x
8
10
5
4
6
4
2
7
8
6
9
9
2
5
1
1
12
2
3
2
2
11

s
e
c
r
e
x
7
8
7
4
4
6
5
6
3
3
3
3
3
3
2
1
1
2
3
5
2
9

The raw AUC values can be found in our repository: https://github.com/COLA-Laboratory/ase2020

4.2 Experimental Procedure

Our experimental procedure follows the three-phases workﬂow of BiLO-CPDP introduced in Section 3.1.
Here we explain the corresponding settings for each phase.

• In the data pre-processing phase for all peer CPDP techniques, all projects in this work will be
used as target domain data in a round-robin manner, forming 20 diﬀerent CPDP tasks. This
aims to mitigate the potential bias in conclusion.

• In the optimization phase, each CPDP task is allocated with an overall time budget of one hour
(i.e., 3, 600 seconds, as suggested by Feurer et al. [14]) while setting each lower-level exploitation
as 20 seconds in BiLO-CPDP. When applicable, the same budget is given to other state-of-the-
art peer CPDP techniques that permit hyper-parameter optimization in the comparison, e.g.,
Auto-sklearn [14]. We apply the TPE algorithm implementation integrated in Hyperopt5, a
popular Python library for hyper-parameter tuning in machine learning [38], for the lower-level
routine of BiLO-CPDP.

• In the performance validation phase, AUC is used as the performance metric. Due to the
stochastic nature of BiLO-CPDP and some peer CPDP techniques considered, each technique is
independently repeated 30 times for a given CPDP task and the mean AUC values are recorded
for comparison.

4.3 Ranking, Statistical Test and Eﬀect Size

In our experiments, we use the following three statistical measures to interpret the statistical signiﬁ-
cance of our comparative results.

5http://hyperopt.github.io/hyperopt/

10

• Scott-Knott test: Instead of merely comparing the raw AUC values, we apply the Scott-
Knott test to rank the performance of diﬀerent peer techniques over 30 runs on each project, as
recommended by Mittas and Angelis [39]. In a nutshell, the Scott-Knott test uses a statistical test
and eﬀect size to divide the performance of peer techniques into several clusters. In particular,
the performance of peer techniques within the same cluster are statistically insigniﬁcant, i.e.,
their overall AUC values are statistically equivalent. Note that the clustering process terminates
until no split can be made. Finally, each cluster can be assigned a rank according to the mean
AUC values achieved by the peer techniques within the cluster. In particular, since a greater
AUC is preferred, the larger the rank is, the better performance of the technique achieves.

• Wilcoxon signed-rank test: We apply the Wilcoxon signed-rank test [40] with a signiﬁcant
level p = 0.05 [41] to investigate the statistical signiﬁcance of the comparisons.
It is a non-
parametric statistical test that makes little assumption about the underlying distribution of the
data and has been recommended in software engineering research [41].

• A12 eﬀect size: To ensure the resulted diﬀerences are not generated from a trivial eﬀect, we
apply A12 [42] as the eﬀect size measure to evaluate the probability that one technique is better
than another. According to Vargha and Delaney [42], when comparing BiLO-CDPD with another
peer technique in our experiments, A12 = 0.5 means they are equivalent. A12 > 0.5 denotes that
BiLO-CDPD is better for more than 50% of the times. In particular, 0.56 ≤ A12 < 0.64 indicates
a small eﬀect size while 0.64 ≤ A12 < 0.71 and A12 ≥ 0.71 mean a medium and a large eﬀect
size, respectively.

Note that both Wilcoxon signed-rank test and A12 are also used in the Scott-Knott test for generating
the clusters.

4.4 Research Questions

We seek to answer the following four research questions (RQs) through our experimental evaluation:

• RQ1: Is BiLO-CPDP able to automatically conﬁgure a CPDP model having better performance

than the existing CPDP techniques under their reported settings?

• RQ2: How is the performance of BiLO-CPDP comparing with Auto- Sklearn, a state-of-the-art

AutoML tool?

• RQ3: Is the bi-level programming in BiLO-CPDP beneﬁcial?

• RQ4: Given a limited computational budget, which level in BiLO-CPDP is more important and

deserves more budget?

5 Results and Discussions

In this section, we present and discuss the results of our empirical experiments and address the RQs
posed in Section 4.4.

5.1 Comparison with Existing CPDP Work

5.1.1 Method

In order to answer RQ1, we use the transfer learners and classiﬁers collected in Tables 1 and 2 to
constitute 21 peer CPDP techniques in comparison with BiLO-CPDP. Note that although there are
only 13 transfer learners listed in Table 1, some of them are combined with more than one classiﬁer to
constitute diﬀerent CPDP models used in the literature (e.g., TD is combined with classiﬁers RF, LR,
MLP and DT that constitute four diﬀerent CPDP models in [28]). For the parameter settings, we use
the tuned values as reported in the corresponding work.

11

Figure 2: Total ranks achieved by BiLO-CPDP (the right most one) and the 21 peer techniques (the
larger rank, the better; the dashed line and dotted line denote the best and average result over the 21
peer techniques, respectively).

Figure 3: A12 result between BiLO-CPDP and Auto-Sklearn over 30 runs (A12 > 0.5 means BiLO-CPDP
is better).

5.1.2 Results and Analysis

From the experimental results on the Scott-Knott test shown in Table 3, it is clear to see that
In
BiLO-CPDP is the best on 14 out of 20 (70%) projects, second only to one other on ﬁve cases.
contrast, most of the other peer CPDP techniques, albeit hand crafted by domain experts, are not as
competitive as BiLO-CPDP. In particular, NNfilter-NB is the most outstanding peer technique that
is the best on only 7 out 20 (35%) projects while the other peer techniques rarely take the best rank
across all 20 projects. Noteworthily, the performance of NNfilter-NB ties with BiLO-CPDP in two of
its best results. In terms of the total ranks achieved over all projects, as shown in Fig. 2, we can
observe the clear superiority of BiLO-CPDP which is at least 50% better than the other 21 peer tech-
niques. Furthermore, we notice that the superior performance of BiLO-CPDP is consistent across all 20
projects in view of its top three ranked positions achieved in all projects. In contrast, the performance
of existing CPDP techniques exhibit clear variations depending on the underlying target projects.

Response to RQ1: BiLO-CPDP is generally better than the other 21 existing CPDP techniques over
all 20 projects. Unlike others that were hand-crafted by domain experts to certain extents, BiLO-CPDP
builds an eﬀective CPDP model in a completely automated manner, leading to highly competitive
performance over diﬀerent projects.

12

NNfilter-NBUM-NBUM-LRCLIFE-NBCLIFE-KNNFeSCH-RFGIS-NBFeSCH-LRCLIFE-SVMTD-RFTD-LRTD-MLPTD-DTFeSCH-DTVCB-SVMCDE_SMOTE-RFCDE_SMOTE-KNNFSS_bagging-RFFSS_bagging-NBFSS_bagging-LRHISNN-NBBiLO-CPDP050100150200RankpoisynapseZxingantlog4jSafeivyPDEcamelluceneJDTjEditEQvelocityTomcatApacheMLxercesLCxalan0.60.70.80.91.0Effect Size (A12)Table 4: Mean AUC (standard deviation) for BiLO-CPDP and Auto-Sklearn over 30 runs (gray=better;
bold=p¡.05).

BiLO-CPDP

Auto-sklearn

Project
poi

p-value
8.1703E-1 (4.38E-3) 6.5262E-1 (6.98E-3) 1.71E-6
synapse 7.1999E-1 (7.72E-3) 6.0183E-1 (3.68E-3) 1.65E-6
6.3949E-1 (5.37E-3) 6.2615E-1 (1.45E-6) 1.91E-6
Zxing
8.0006E-1 (8.26E-3) 7.4530E-1 (7.63E-3) 1.71E-6
ant
8.4196E-1 (1.52E-2) 6.0965E-1 (1.19E-2) 1.57E-6
log4j
7.9923E-1 (2.09E-2) 6.7513E-1 (6.15E-3) 1.64E-6
Safe
8.0657E-1 (3.51E-3) 7.2407E-1 (9.64E-4) 1.19E-6
ivy
6.8539E-1 (2.57E-3) 5.9781E-1 (2.22E-16) 1.62E-6
PDE
6.2228E-1 (4.01E-3) 5.9006E-1 (1.11E-16) 1.62E-6
camel
lucene 7.1065E-1 (8.13E-3) 6.4408E-1 (4.87E-6) 1.37E-6
7.3705E-1 (1.09E-2) 6.7517E-1 (1.11E-16) 1.66E-6
8.5207E-1 (3.77E-2) 7.1589E-1 (5.70E-3) 1.68E-6
7.1714E-1 (1.34E-2) 6.0201E-1 (3.33E-16) 1.73E-6
velocity 7.0220E-1 (8.40E-3) 6.0896E-1 (4.50E-2) 1.61E-6
Tomcat 7.7295E-1 (1.40E-3) 7.3892E-1 (1.32E-2) 1.45E-7
7.4787E-1 (3.33E-16) 6.58E-1
Apache
6.4966E-1 (1.58E-3) 6.1708E-1 (2.22E-16) 1.73E-6
ML
xerces 7.1552E-1 (1.03E-2) 5.9892E-1 (6.03E-3) 1.71E-6
7.0859E-1 (1.89E-2) 6.2476E-1 (1.11E-16) 1.73E-6
7.6250E-1 (7.67E-3) 6.7732E-1 (2.31E-2) 1.71E-6

JDT
jEdit
EQ

7.4808E-1 (8.27E-3)

LC
xalan

5.2 Comparison with Auto-Sklearn

5.2.1 Method

In principle, BiLO-CPDP is an AutoML tool that automatically searches for the right combination of
transfer learner and classiﬁer and their optimized hyper-parameter settings for a given CPDP task.
To validate its competitiveness from the perspective of AutoML, we compare the performance of
BiLO-CPDP with Auto-Sklearn6 [14], a state-of-the-art and readily available AutoML tool that can
also optimize the combination and its parameters.

5.2.2 Results and Analysis

From the comparison results of AUC values shown in Table 4, we clearly see the overwhelmingly supe-
rior performance of BiLO-CPDP versus Auto-Sklearn where the AUC values obtained by BiLO-CPDP
are all better than those of Auto-Sklearn. In particular, all those better results, except on Apache, are
statistically signiﬁcant, according to the p values shown in the last column of Table 4. Furthermore,
as shown in Fig. 3, all A12 values suggest a large eﬀect size. In particular, we see an overwhelming
A12 = 1, except only on Zxing and Apache. These indicate that the improvements on the AUC results
brought by BiLO-CPDP over that of the Auto-Sklearn are signiﬁcantly large in general.

The results are caused by the fact that Auto-Sklearn does not have a bi-level structure, hence it en-
codes all transfer learner and classiﬁer combinations along with their corresponding hyper-para- meter
settings into an integrated solution at a single-level, which is solved by the SMAC algorithm [43]. Dur-
ing its optimization process, a combination of transfer learner and classiﬁer is selected ﬁrst. Thereafter,
the variables corresponding to the hyper-parameters of the chosen transfer learner and the classiﬁer
become active while the remaining variables are set to be dummy. By this means, the total number
of variables considered in Auto-Sklean goes up to 93, resulting a unnecessarily much larger search
space comparing with BiLO-CPDP. Given the limited budget, Auto-Sklearn therefore ends up with
a less eﬀective exploration of both useful combinations of transfer learners and classiﬁers and their
hyper-parameter settings.

6https://automl.github.io/auto-sklearn/master/

13

Table 5: Mean AUC (standard deviation) for BiLO-CPDP and SLO-CPDP over 30 runs (gray=better;
bold=p¡.05).

SLO-CPDP

BiLO-CPDP

Project
poi

p-value
8.1703E-1 (4.38E-3) 5.7493E-1 (2.71E-1) 1.92E-6
synapse 7.1999E-1 (7.72E-3) 5.0601E-1 (2.33E-1) 1.73E-6
6.3949E-1 (5.37E-3) 5.4209E-1 (1.46E-1) 1.92E-6
Zxing
8.0006E-1 (8.26E-3) 6.3099E-1 (1.76E-1) 1.73E-6
ant
8.4196E-1 (1.52E-2) 6.2807E-1 (2.49E-1) 2.60E-6
log4j
7.9923E-1 (2.09E-2) 7.4254E-1 (3.96E-2) 5.74E-5
Safe
8.0657E-1 (3.51E-3) 6.3528E-1 (1.77E-1) 1.73E-6
ivy
6.8539E-1 (2.57E-3) 5.0874E-1 (2.52E-1) 1.73E-6
PDE
6.2228E-1 (4.01E-3) 4.7330E-1 (2.15E-1) 5.22E-6
camel
lucene 7.1065E-1 (8.13E-3) 5.8568E-1 (2.05E-1) 1.15E-4
7.3705E-1 (1.09E-2) 6.2603E-1 (1.81E-1) 1.36E-5
8.5207E-1 (3.77E-2) 5.5203E-1 (2.50E-1) 1.73E-6
7.1714E-1 (1.34E-2) 5.4016E-1 (2.21E-1) 2.88E-6
velocity 7.0220E-1 (8.40E-3) 5.3123E-1 (2.11E-1) 1.73E-6
Tomcat 7.7295E-1 (1.40E-3) 5.6400E-1 (2.40E-1) 1.92E-6
Apache 7.4808E-1 (8.27E-3) 5.2924E-1 (1.23E-1) 1.01E-6
6.4966E-1 (1.58E-3) 5.8287E-1 (1.53E-1) 7.16E-4
xerces 7.1552E-1 (1.03E-2) 6.3384E-1 (1.29E-1) 6.87E-5
7.0859E-1 (1.89E-2) 5.3199E-1 (2.38E-1) 1.02E-5
7.6250E-1 (7.67E-3) 5.9866E-1 (2.21E-1) 5.79E-5

JDT
jEdit
EQ

LC
xalan

ML

Response to RQ2: Comparing with the state-of-the-art AutoML tool Auto-Sklearn, BiLO-CPDP
achieves signiﬁcantly better results given a limited computational budget.

5.3 Comparison with Single-Level Variant

5.3.1 Method

It is conservative to curious about the usefulness brought by this bi-level programming formulation and
why not simply formulating a single-level problem that consists of both combination and parameters.
The comparison with Auto-Sklearn, which is at a single-level, partially validates this concern, but
the results can be biased by the fact that it uses a diﬀerent optimization algorithm. To fully evaluate
the eﬀectiveness of bi-level programming, we develop a single-level variant of BiLO-CPDP, dubbed
SLO-CPDP, which diﬀers from BiLO-CPDP only on the solution representation.

Speciﬁcally, SLO-CPDP is similar to Auto-Sklearn in the sense that they both work on single-level
optimization — the transfer learner and classiﬁer, together with their hyper-parameters, are encoded
as a single solution representation. However, the diﬀerence is that SLO-CPDP exploits the TPE algorithm
as the Bayesian optimizer, which is identical to BiLO-CPDP. Auto-Sklearn, in contrast, uses the classic
SMAC algorithm that leverages Random Forest to build the surrogate model.

5.3.2 Results and Analysis

From the AUC values shown in Table 5, we observe a rather superior performance achieved by
BiLO-CPDP over SLO-CPDP. Speciﬁcally, BiLO-CPDP again obtains a better AUC value on all 20 projects.
In particular, all better results are with statistical signiﬁcance (p¡.05), as shown in the last column
of Table 5. Furthermore, from Fig. 4, we ﬁnd that the diﬀerences between the AUC values achieved by
BiLO-CPDP and SLO-CPDP are with a large eﬀect size. Given such a result, we can infer that the inef-
fectiveness of SLO-CPDP can be attributed to the enlarged search space caused by the unwise coupling
of transfer learner and classiﬁer combination along with their parameters at a single-level.

14

Figure 4: A12 result between BiLO-CPDP and SLO-CPDP over 30 runs (A12 > 0.5 means BiLO-CPDP is
better).

Figure 5: A12 result between BiLO-CPDP(h) and BiLO-CPDP(l) over 30 runs (A12 > 0.5 means
BiLO-CPDP(h) is better).

Response to RQ3: The bi-level programming in BiLO-CPDP considerably contributes to its eﬀec-
In contrast to the single-level where the combination and parameters are formulated in
tiveness.
a “ﬂat” way, bi-level programming signiﬁcantly reduces the search space and steer the search in a
hierarchical manner, leading to better performance under a limited budget.

5.4

Impact of Budget for the Two Levels

5.4.1 Method

In practice, it is not uncommon that the resource for defect prediction, particular the time budget, is
limited. In our experiments, the total budget allocated to BiLO-CPDP is one hour in total, following the
best practice in the AutoML community [14]. However, the unique bi-level programming formulated
in BiLO-CPDP allows us a ﬂexible control over the budget allocated to the two levels, hence it is
interested to know how their budget allocations may impact the performance. To this end, within the
one hour total budget, we set two budget allocation strategies: one with high budget to the upper-
level, dubbed BiLO-CPDP(h), that allows 20 seconds for each low-level optimization, leaving more
resources for exploring the combinations at the upper-level. Note that 20 seconds are very short for
some model training thus is counter-intuitive. This is also the default setting in BiLO-CPDP we used
for other experiments. Another one preserves high budget to the low-level, dubbed BiLO-CPDP(l), in
which the lower-level optimization is allocated with 100 training and AUC evaluations. This allows
a low-level routine to consume at least 80 seconds (the smallest amount of time required to complete
100 evaluations among all combinations) for more suﬃcient exploration of the hyper-parameters.

15

poisynapseZxingantlog4jSafeivyPDEcamelluceneJDTjEditEQvelocityTomcatApacheMLxercesLCxalan0.60.70.80.91.0Effect Size (A12)poisynapseZxingantlog4jSafeivyPDEcamelluceneJDTjEditEQvelocityTomcatApacheMLxercesLCxalan0.60.70.80.91.0Effect Size (A12)Table 6: Mean AUC (standard deviation) for BiLO-CPDP(h) and BiLO-CPDP(l) over 30 runs
(gray=better; bold=p¡.05).

BiLO-CPDP(l)

BiLO-CPDP(h)

Project
poi

p-value
8.1703E-1 (4.38E-3) 5.9447E-1 (2.74E-1) 3.85E-6
synapse 7.1999E-1 (7.72E-3) 6.1897E-1 (1.26E-1) 1.73E-6
6.3949E-1 (5.37E-3) 6.1108E-1 (2.10E-2) 8.46E-6
Zxing
8.0006E-1 (8.26E-3) 4.6150E-1 (3.31E-1) 1.91E-6
ant
8.4196E-1 (1.52E-2) 5.1593E-1 (2.91E-1) 2.46E-6
log4j
7.9923E-1 (2.09E-2) 7.1771E-1 (1.38E-1) 2.87E-6
Safe
8.0657E-1 (3.51E-3) 5.9659E-1 (3.04E-1) 5.23E-6
ivy
6.8539E-1 (2.57E-3) 4.3027E-1 (3.05E-1) 1.71E-6
PDE
6.2228E-1 (4.01E-3) 3.9054E-1 (2.79E-1) 7.90E-6
camel
lucene 7.1065E-1 (8.13E-3) 5.3341E-1 (2.69E-1) 1.12E-5
7.3705E-1 (1.09E-2) 3.7420E-1 (3.51E-1) 3.85E-6
8.5207E-1 (3.77E-2) 5.0339E-1 (3.30E-1) 1.72E-6
7.1714E-1 (1.34E-2) 4.2035E-1 (3.22E-1) 8.37E-6
velocity 7.0220E-1 (8.40E-3) 5.0660E-1 (2.55E-1) 1.92E-6
Tomcat 7.7295E-1 (1.40E-3) 5.6762E-1 (2.87E-1) 2.50E-6
Apache 7.4808E-1 (8.27E-3) 7.1257E-1 (2.62E-2) 7.22E-6
6.4966E-1 (1.58E-3) 3.7510E-1 (3.07E-1) 5.70E-6
xerces 7.1552E-1 (1.03E-2) 4.8507E-1 (2.72E-1) 3.87E-6
7.0859E-1 (1.89E-2) 4.9327E-1 (3.00E-1) 1.23E-4
7.6250E-1 (7.67E-3) 4.9144E-1 (3.05E-1) 1.91E-6

JDT
jEdit
EQ

LC
xalan

ML

5.4.2 Results and Analysis

As shown in Table 6, we can see that BiLO-CPDP(h) is overwhelmingly superior to BiLO- CPDP(l)
where it obtains better AUC values on all 20 projects. In addition, from the comparison results of
A12 shown in Fig. 5, we can see that the diﬀerences between AUC values achieved by the two budget
allocation strategies are categorized to have a large eﬀect size.

The performance diﬀerences are due to the fact that the CPDP model training can be rather
time-consuming and unfavorable, especially given a limited budget. Therefore, for BiLO-CPDP(l),
once a combination of transfer learner and classiﬁer is selected at the upper-level routine, its initiative
to favor better exploration of the hyper-parameters at the lower-level routine can easily consume a
signiﬁcant amount of the budget (the median computational time is around 300 seconds according
to our oﬄine statistics). This has caused the combinatorial space of transfer learners and classiﬁers
to become severely under-explored. In contrast, by strictly restricting the budget at the lower-level
optimization routine, BiLO-CPDP(h) suﬀers from a limited exploration of the hyper-parameter space,
but permitting a suﬃcient chance to explore many combinations of transfer learners and classiﬁers.
From the results, it evidences that exploring the combination space is more important than using the
hyper-parameter space under a limited budget.

Response to RQ4: Given a limited budget, it is recommended to allocate more expenditure to the
upper-level optimization routine in BiLO-CPDP. By this means, more combinations of transfer learner
and classiﬁer can be investigated even without fully optimized hyper-parameters, which is more ben-
eﬁcial to performance.

6 Related Work

In the past decades, machine learning classiﬁers have become the core techniques for defect prediction,
in which the success can be greatly aﬀected by the setting of the classiﬁers’ hyper-parameters [44]. This
is a challenging issue, as Jiang et al. [45] pointed out that simply using the default values are dreadful,
causing severely bad performance of the prediction. The automated parameter optimization for defect
predictors is therefore crucial. Indeed, a large scale empirical study by Tantithamthavorn et al. [5, 6]
found that well-tuned hyper-parameters can signiﬁcantly boost the performance of the classiﬁers in

16

defect prediction. Fu [46] even suggest that such optimization should become a standard practice in
every single Software Engineering task. In light of this, Agrawal et al. [47] have applied Diﬀerential
Evolution to tune SMOTE, a pre-processor for handling data imbalance, for predicting software defects.
Their work focus on within-project defect prediction though. Similarly, DODGE [48] is a recent tool that
optimizes the parameters of data pre-processor and classiﬁer. Although they aim for within-project
case, the combination of pre-processor and classiﬁer can be resemble to our CPDP task. However,
their optimization assumes conservative hybridization of all the parameters and the combinations as
a single-level optimization problem.

The importance of automated parameter optimization remains stand in the context of CPDP,
where the problem become even more complex as the parameters of transfer learners also come into
play. Qu et al. [49] have shown that the parameter settings of classiﬁers for CPDP are even more
important. A few automated optimizers exist for CPDP, for example, Ozturk et al. [11] and Qu et
al. [10] examine various diﬀerent optimization algorithms to tune CPDP models. Nevertheless, they
focus only on the parameter tuning whilst ignore the combination of transfer learner and classiﬁer
during optimization. Indeed, Li et al. [9] further demonstrate that the parameter interactions between
transfer learner and classiﬁer, as well as their combination, also play an integral role to the prediction
performance. Auto-Sklearn [14], which is a widely-used generic tool to tune arbitrary machine
learning algorithms, is also highly potential for CPDP tuning. However, again, its design has restricted
that the combination of transfer learner and classiﬁer along with their parameters need to be tuned as
a single optimization problem, which worsen its performance compared with BiLO-CPDP, as we have
shown in Section 5.

Although the potentials of bi-level programming have been explored for other Software Engineering
problems, e.g., code smell detection [50] and test case generation [51], to the best of our knowledge,
its adoption has never been reported in the context of CPDP. Our work is therefore unique to all
aforementioned techniques in the sense that:

• BiLO-CPDP is the ﬁrst of its kind to formulate bi-level programming for the parameter optimiza-

tion of CPDP.

• BiLO-CPDP automatically optimizes not only the parameters, but also discover the possible com-

bination of transfer learner and classiﬁer from a given portfolio.

• We show that exploring the combination of transfer learner and classiﬁer is more important than
the their parameters tuning, the former should thus deserve more computational budget. In this
regard, the bi-level programming formulated in BiLO-CPDP provides better ﬂexibility to achieve
such a requirement of ﬁne-grained budget allocation [52–90].

7 Threats to Validity

Similar to many empirical studies in software engineering, our work is subject to threats to validity.
Construct threats can be raised from the experiment uncertainty caused by the learning and opti-
mization. To mitigate this, we have repeated 30 runs for each techniques and compare the techniques
using Scott-Knott test [39], supported by Wilcoxon signed-rank test [40] and A12 eﬀect size metric [42].
Therefore, whenever we report “A is better than B”, we imply that A is indeed statistically better
with large eﬀect size. The single metric AUC may also subject to such a threat. However, AUC was
chosen mainly due to its parameter-free nature and high reliability as reported in the machine learning
community [91].

Internal threats can be related to the parameter setting, which in our case the key parameter is the
time budget for optimization. Indeed, a diﬀerent budget may aﬀect the result, and therefore we have
set a total budget following the state-of-the-practice suggested in the AutoML community [14], which
is reasonable given the required runs. We have also investigated the relative importance of budget
allocation between the upper- and lower-level in BiLO-CPDP.

External threats are concerned with whether the ﬁndings are generailzable to other projects. To
mitigate such, as discussed in Section 4, our 20 projects cover a wide spectrum of the real-world cases

17

with diverse characteristics, each of which was used as the target domain data to be predicted using
the other 19 ones as sources.

8 conclusion

The choice of combination of transfer learner and classiﬁer along with their hyper-parameter settings
have a signiﬁcant impact to the performance of CPDP model. In this paper, we propose BiLO-CPDP, a
tool that is able to automatically develop a high-performance CPDP model for the given CPDP task.
Speciﬁcally, BiLO-CPDP, for the ﬁrst time, formulates the automated CPDP model discovery problem
from a bi-level programming perspective. In particular, the upper-level optimization routine searches
for the right combination of transfer learner and classiﬁer while the lower-level optimization routine
optimizes the corresponding hyper-parameters associated with the chosen combination. Furthermore,
the hierarchical optimization paradigm allows a more ﬂexible control of the computational budget at
both levels. From our empirical study, we have shown that BiLO-CPDP

• automatically develops a better CPDP model comparing to 21 state-of-the-art CPDP techniques

with hand-crafted combination and reported parameter settings.

• overwhelmingly outperforms Auto-Sklearn, a state-of-the-art AutoML tool, and the single-level

optimization variant of BiLO-CPDP.

• allows software engineers to set more search budget for the upper-level, which signiﬁcantly boosts

the performance.

BiLO-CPDP showcases the importance of automatically optimizing the combination of transfer
learners and classiﬁers, together with their parameters. This paves a new way to enable more intelligent
parameter optimization and adaptation for CPDP model building.
In future, we seek to consider
multiple objectives within the bi-level programming and to investigate more precise eﬀects of allocating
budget between the two levels. We also plan to further distinguish between the parameters for transfer
learner and classiﬁer at the low-level, as it has been shown that the parameter tuning of the former is
more important than the latter [9].

Acknowledgement

K. Li was supported by UKRI Future Leaders Fellowship (Grant No. MR/S017062/1).

References

[1] T. Zimmermann, N. Nagappan, H. C. Gall, E. Giger, and B. Murphy, “Cross-project defect
prediction: a large scale experiment on data vs. domain vs. process,” in ESEC/FSE’09: Proc. of
the 7th joint meeting of the European Software Engineering Conference and the ACM SIGSOFT
International Symposium on Foundations of Software Engineering. ACM, 2009, pp. 91–100.

[2] S. Hosseini, B. Turhan, and D. Gunarathna, “A systematic literature review and meta-analysis
on cross project defect prediction,” IEEE Trans. Software Eng., vol. 45, no. 2, pp. 111–147, 2019.

[3] F. Rahman, D. Posnett, and P. T. Devanbu, “Recalling the ”imprecision” of cross-project defect
prediction,” in FSE’12: Proc. of the 20th ACM SIGSOFT Symposium on the Foundations of
Software Engineering. ACM, 2012, p. 61.

[4] J. Nam, S. J. Pan, and S. Kim, “Transfer defect learning,” in ICSE’13: Proc. of the 35th Inter-

national Conference on Software Engineering, 2013, pp. 382–391.

[5] C. Tantithamthavorn, S. McIntosh, A. E. Hassan, and K. Matsumoto, “Automated parameter
optimization of classiﬁcation techniques for defect prediction models,” in ICSE’16: Proc. of the
38th International Conference on Software Engineering, 2016, pp. 321–332.

18

[6] ——, “The impact of automated parameter optimization on defect prediction models,” IEEE

Transactions on Software Engineering, vol. 45, no. 7, pp. 683–711, 2019.

[7] T. Mende and R. Koschke, “Revisiting the evaluation of defect prediction models,” in
PROMISE’09: Proc. of the 5th International Workshop on Predictive Models in Software En-
gineering, 2009, p. 7.

[8] T. Mende, “Replication of defect prediction studies: problems, pitfalls and recommendations,”
in PROMISE’10: Proc. of the 6th International Conference on Predictive Models in Software
Engineering, 2010, p. 5.

[9] K. Li, Z. Xiang, T. Chen, S. Wang, and K. C. Tan, “Understanding the automated parameter
optimization on transfer learning for cpdp: An empirical study,” in ICSE’20: Proc. of the 42th
International Conference on Software Engineering, 2020, accepted for publication.

[10] Y. Qu, X. Chen, Y. Zhao, and X. Ju, “Impact of hyper parameter optimization for cross-project
software defect prediction,” International Journal of Performability Engineering, vol. 14, no. 6,
pp. 1291–1299, 2018.

[11] M. M. ¨Ozt¨urk, “The impact of parameter optimization of ensemble learning on defect prediction,”

The Computer Science Journal of Moldova, vol. 27, no. 1, pp. 85–128, 2019.

[12] F. Glover and M. Laguna, Tabu Search. Springer US, 1998, vol. 1–3, pp. 2093–2229.

[13] J. Bergstra, R. Bardenet, Y. Bengio, and B. K´egl, “Algorithms for hyper-parameter optimization,”
in NIPS’11: Proc. of the 25th Annual Conference on Neural Information Processing Systems,
2011, pp. 2546–2554.

[14] M. Feurer, A. Klein, K. Eggensperger, J. T. Springenberg, M. Blum, and F. Hutter, “Eﬃcient
and robust automated machine learning,” in NIPS’15: Proc. of the 2015 Annual Conference on
Neural Information Processing Systems, 2015, pp. 2962–2970.

[15] A. Sinha, P. Malo, and K. Deb, “A review on bilevel optimization: From classical to evolutionary
approaches and applications,” IEEE Trans. Evolutionary Computation, vol. 22, no. 2, pp. 276–
295, 2018.

[16] H. Von Stackelberg, Market structure and equilibrium. Springer Science & Business Media, 2010.

[17] S. Qiu, L. Lu, and S. Jiang, “Multiple-components weights model for cross-project software defect

prediction,” IET Software, vol. 12, no. 4, pp. 345–355, 2018.

[18] Y. Zhou, Y. Yang, H. Lu, L. Chen, Y. Li, Y. Zhao, J. Qian, and B. Xu, “How far we have
progressed in the journey? an examination of cross-project defect prediction,” ACM Trans.
Softw. Eng. Methodol., vol. 27, no. 1, pp. 1:1–1:51, 2018.

[19] Z. Li, X. Jing, and X. Zhu, “Progress on approaches to software defect prediction,” IET Software,

vol. 12, no. 3, pp. 161–175, 2018.

[20] B. Turhan, T. Menzies, A. B. Bener, and J. S. D. Stefano, “On the relative value of
cross-company and within-company data for defect prediction,” Empirical Software Engineering,
vol. 14, no. 5, pp. 540–578, 2009. [Online]. Available: https://doi.org/10.1007/s10664-008-9103-7

[21] N. Limsettho, K. E. Bennin, J. W. Keung, H. Hata, and K. Matsumoto, “Cross project de-
fect prediction using class distribution estimation and oversampling,” Information and Software
Technology, vol. 100, pp. 87–102, 2018.

[22] Z. He, F. Peters, T. Menzies, and Y. Yang, “Learning from open-source projects: An empirical
study on defect prediction,” in 2013 ACM/IEEE International Symposium on Empirical Software
Engineering and Measurement.

IEEE, 2013, pp. 45–54.

19

[23] S. Hosseini, B. Turhan, and M. M¨antyl¨a, “A benchmark study on the eﬀectiveness of search-based
data selection and feature selection for cross project defect prediction,” Information and Software
Technology, vol. 95, pp. 296–312, 2018.

[24] F. Peters, T. Menzies, L. Gong, and H. Zhang, “Balancing privacy and utility in cross-company
defect prediction,” IEEE Transactions on Software Engineering, vol. 39, no. 8, pp. 1054–1068,
2013.

[25] D. Ryu, J.-I. Jang, and J. Baik, “A hybrid instance selection using nearest-neighbor for cross-
project defect prediction,” Journal of Computer Science and Technology, vol. 30, no. 5, pp.
969–980, 2015.

[26] C. Ni, W.-S. Liu, X. Chen, Q. Gu, D.-X. Chen, and Q.-G. Huang, “A cluster based feature
selection method for cross-project software defect prediction,” Journal of Computer Science and
Technology, vol. 32, no. 6, pp. 1090–1107, 2017.

[27] F. Zhang, A. Mockus, I. Keivanloo, and Y. Zou, “Towards building a universal defect prediction
model,” in Proceedings of the 11th Working Conference on Mining Software Repositories, 2014,
pp. 182–191.

[28] S. Herbold, “Training data selection for cross-project defect prediction,” in ESEM’13: Proc. of
the 9th International Conference on Predictive Models in Software Engineering, 2013, pp. 1–10.

[29] D. Ryu, O. Choi, and J. Baik, “Value-cognitive boosting with a support vector machine for
cross-project defect prediction,” Empirical Software Engineering, vol. 21, no. 1, pp. 43–71, 2016.

[30] N. Nagappan, T. Ball, and A. Zeller, “Mining metrics to predict component failures,” in Proceed-

ings of the 28th international conference on Software engineering, 2006, pp. 452–461.

[31] M. Feurer and F. Hutter, “Hyperparameter optimization,” in Automated Machine Learning -

Methods, Systems, Challenges, 2019, pp. 3–33.

[32] S. Herbold, “A systematic mapping study on cross-project defect prediction,” CoRR, vol.

abs/1705.06429, 2017.

[33] S. Herbold, A. Trautsch, and J. Grabowski, “A comparative study to benchmark cross-project
defect prediction approaches,” IEEE Trans. Software Eng., vol. 44, no. 9, pp. 811–833, 2018.

[34] M. J. Shepperd, Q. Song, Z. Sun, and C. Mair, “Data quality: Some comments on the NASA
software defect datasets,” IEEE Trans. Software Eng., vol. 39, no. 9, pp. 1208–1215, 2013.

[35] M. D’Ambros, M. Lanza, and R. Robbes, “An extensive comparison of bug prediction ap-
proaches,” in Proceedings of the 7th International Working Conference on Mining Software Repos-
itories, MSR 2010 (Co-located with ICSE), Cape Town, South Africa, May 2-3, 2010, Proceedings,
2010, pp. 31–41.

[36] R. Wu, H. Zhang, S. Kim, and S. Cheung, “Relink: recovering links between bugs and changes,”
in ESEC/FSE’11: Proc. of 19th ACM SIGSOFT Symposium on the Foundations ofSoftware
Engineering and 13th European Software Engineering Conference, 2011, pp. 15–25.

[37] M. Jureczko and L. Madeyski, “Towards identifying software project clusters with regard to defect
prediction,” in PROMISE’10: Proc. of the 6th International Conference on Predictive Models in
Software Engineering, 2010, p. 9.

[38] J. Bergstra, D. Yamins, and D. D. Cox, “Making a science of model search: Hyperparameter
optimization in hundreds of dimensions for vision architectures,” in ICML’13: Proc. of the 30th
International Conference on Machine Learning, vol. 28, 2013, pp. 115–123.

[39] N. Mittas and L. Angelis, “Ranking and clustering software cost estimation models through a
multiple comparisons algorithm,” IEEE Trans. Software Eng., vol. 39, no. 4, pp. 537–551, 2013.

20

[40] F. Wilcoxon, “Individual comparisons by ranking methods,” 1945.

[41] A. Arcuri and L. C. Briand, “A practical guide for using statistical tests to assess randomized
algorithms in software engineering,” in ICSE’11: Proc. of the 33rd International Conference on
Software Engineering. ACM, 2011, pp. 1–10.

[42] A. Vargha and H. D. Delaney, “A critique and improvement of the cl common language eﬀect

size statistics of mcgraw and wong,” 2000.

[43] F. Hutter, H. H. Hoos, and K. Leyton-Brown, “Sequential model-based optimization for general
algorithm conﬁguration,” in LION5: Proc. of the 5th International Conference Learning and
Intelligent Optimization, ser. Lecture Notes in Computer Science, vol. 6683. Springer, 2011, pp.
507–523.

[44] A. G. Koru and H. Liu, “An investigation of the eﬀect of module size on defect prediction using
static measures,” ACM SIGSOFT Software Engineering Notes, vol. 30, no. 4, pp. 1–5, 2005.

[45] Y. Jiang, B. Cukic, and T. Menzies, “Can data transformation help in the detection of fault-prone

modules?” in DEFECTS. ACM, 2008, pp. 16–20.

[46] W. Fu, T. Menzies, and X. Shen, “Tuning for software analytics: Is it really necessary?” Infor-

mation and Software Technology, vol. 76, pp. 135–146, 2016.

[47] A. Agrawal and T. Menzies, “Is ”better data” better than ”better data miners”?: on the beneﬁts
of tuning SMOTE for defect prediction,” in ICSE’18: Proc. of the 40th International Conference
on Software Engineering. ACM, 2018, pp. 1050–1061.

[48] A. Agrawal, W. Fu, D. Chen, X. Shen, and T. Menzies, “How to “dodge” complex software

analytics,” IEEE Transactions on Software Engineering, pp. 1–1, 2019.

[49] Y. Qu, X. Chen, Y. Zhao, and X. Ju, “Impact of hyper parameter optimization for cross-project
software defect prediction.” International Journal of Performability Engineering, vol. 14, no. 6,
2018.

[50] D. Sahin, M. Kessentini, S. Bechikh, and K. Deb, “Code-smell detection as a bilevel problem,”
ACM Transactions on Software Engineering and Methodology (TOSEM), vol. 24, no. 1, pp. 1–44,
2014.

[51] D. Sahin, M. Kessentini, M. Wimmer, and K. Deb, “Model transformation testing: a bi-level
search-based software engineering approach,” Journal of Software: Evolution and Process, vol. 27,
no. 11, pp. 821–837, 2015.

[52] T. Chen, K. Li, R. Bahsoon, and X. Yao, “FEMOSAA: feature-guided and knee-driven multi-
objective optimization for self-adaptive software,” ACM Trans. Softw. Eng. Methodol., vol. 27,
no. 2, pp. 5:1–5:50, 2018.

[53] J. Zou, C. Ji, S. Yang, Y. Zhang, J. Zheng, and K. Li, “A knee-point-based evolutionary algo-
rithm using weighted subpopulation for many-objective optimization,” Swarm and Evolutionary
Computation, vol. 47, pp. 33–43, 2019.

[54] K. Li, J. Zheng, C. Zhou, and H. Lv, “An improved diﬀerential evolution for multi-objective
optimization,” in CSIE’09: Proc. of 2009 WRI World Congress on Computer Science and Infor-
mation Engineering, 2009, pp. 825–830.

[55] J. Billingsley, K. Li, W. Miao, G. Min, and N. Georgalas, “A formal model for multi-objective
optimisation of network function virtualisation placement,” in EMO’19: Proc. of the 10th Inter-
national Conference Evolutionary Multi-Criterion Optimization, 2019, pp. 529–540.

21

[56] K. Li, J. Zheng, M. Li, C. Zhou, and H. Lv, “A novel algorithm for non-dominated hypervolume-
based multiobjective optimization,” in SMC’09: Proc. of 2009 the IEEE International Conference
on Systems, Man and Cybernetics, 2009, pp. 5220–5226.

[57] K. Li, “Progressive preference learning: Proof-of-principle results in MOEA/D,” in EMO’19:
Proc. of the 10th International Conference Evolutionary Multi-Criterion Optimization, 2019, pp.
631–643.

[58] K. Li, R. Chen, D. A. Savic, and X. Yao, “Interactive decomposition multiobjective optimization
via progressively learned value functions,” IEEE Trans. Fuzzy Systems, vol. 27, no. 5, pp. 849–860,
2019.

[59] M. Wu, K. Li, S. Kwong, Q. Zhang, and J. Zhang, “Learning to decompose: A paradigm
for decomposition-based multiobjective optimization,” IEEE Trans. Evolutionary Computation,
vol. 23, no. 3, pp. 376–390, 2019.

[60] K. Li and S. Kwong, “A general framework for evolutionary multiobjective optimization via

manifold learning,” Neurocomputing, vol. 146, pp. 65–74, 2014.

[61] K. Li, ´A. Fialho, and S. Kwong, “Multi-objective diﬀerential evolution with adaptive control of
parameters and operators,” in LION5: Proc. of the 5th International Conference on Learning
and Intelligent Optimization, 2011, pp. 473–487.

[62] K. Li, S. Kwong, R. Wang, K. Tang, and K. Man, “Learning paradigm based on jumping genes:
A general framework for enhancing exploration in evolutionary multiobjective optimization,” Inf.
Sci., vol. 226, pp. 1–22, 2013.

[63] J. Cao, S. Kwong, R. Wang, and K. Li, “A weighted voting method using minimum square error
based on extreme learning machine,” in ICMLC’12: Proc. of the 2012 International Conference
on Machine Learning and Cybernetics, 2012, pp. 411–414.

[64] ——, “AN indicator-based selection multi-objective evolutionary algorithm with preference for
multi-class ensemble,” in ICMLC’14: Proc. of the 2014 International Conference on Machine
Learning and Cybernetics, 2014, pp. 147–152.

[65] K. Li, S. Kwong, Q. Zhang, and K. Deb, “Interrelationship-based selection for decomposition
multiobjective optimization,” IEEE Trans. Cybernetics, vol. 45, no. 10, pp. 2076–2088, 2015.

[66] K. Li, K. Deb, Q. Zhang, and Q. Zhang, “Eﬃcient nondomination level update method for
steady-state evolutionary multiobjective optimization,” IEEE Trans. Cybernetics, vol. 47, no. 9,
pp. 2838–2849, 2017.

[67] K. Li, S. Kwong, and K. Deb, “A dual-population paradigm for evolutionary multiobjective

optimization,” Inf. Sci., vol. 309, pp. 50–72, 2015.

[68] R. Chen, K. Li, and X. Yao, “Dynamic multiobjectives optimization with a changing number of

objectives,” IEEE Trans. Evolutionary Computation, vol. 22, no. 1, pp. 157–171, 2018.

[69] K. Li, Q. Zhang, S. Kwong, M. Li, and R. Wang, “Stable matching-based selection in evolutionary
multiobjective optimization,” IEEE Trans. Evolutionary Computation, vol. 18, no. 6, pp. 909–923,
2014.

[70] K. Li, ´A. Fialho, S. Kwong, and Q. Zhang, “Adaptive operator selection with bandits for a mul-
tiobjective evolutionary algorithm based on decomposition,” IEEE Trans. Evolutionary Compu-
tation, vol. 18, no. 1, pp. 114–130, 2014.

[71] K. Li, S. Kwong, R. Wang, J. Cao, and I. J. Rudas, “Multi-objective diﬀerential evolution with
self-navigation,” in SMC’12: Proc. of the 2012 IEEE International Conference on Systems, Man,
and Cybernetics, 2012, pp. 508–513.

22

[72] K. Li, R. Wang, S. Kwong, and J. Cao, “Evolving extreme learning machine paradigm with adap-
tive operator selection and parameter control,” International Journal of Uncertainty, Fuzziness
and Knowledge-Based Systems, vol. 21, pp. 143–154, 2013.

[73] J. Cao, S. Kwong, R. Wang, X. Li, K. Li, and X. Kong, “Class-speciﬁc soft voting based multiple

extreme learning machines ensemble,” Neurocomputing, vol. 149, pp. 275–284, 2015.

[74] K. Li, R. Chen, G. Fu, and X. Yao, “Two-archive evolutionary algorithm for constrained mul-
tiobjective optimization,” IEEE Trans. Evolutionary Computation, vol. 23, no. 2, pp. 303–315,
2019.

[75] M. Wu, K. Li, S. Kwong, and Q. Zhang, “Evolutionary many-objective optimization based on

adversarial decomposition,” IEEE Trans. Cybernetics, vol. 50, no. 2, pp. 753–764, 2020.

[76] M. Wu, S. Kwong, Y. Jia, K. Li, and Q. Zhang, “Adaptive weights generation for decomposition-
based multi-objective optimization using gaussian process regression,” in Proceedings of the Ge-
netic and Evolutionary Computation Conference, GECCO 2017, Berlin, Germany, July 15-19,
2017, 2017, pp. 641–648.

[77] M. Wu, K. Li, S. Kwong, Y. Zhou, and Q. Zhang, “Matching-based selection with incomplete lists
for decomposition multiobjective optimization,” IEEE Trans. Evolutionary Computation, vol. 21,
no. 4, pp. 554–568, 2017.

[78] K. Li, K. Deb, and X. Yao, “R-metric: Evaluating the performance of preference-based evolution-
ary multiobjective optimization using reference points,” IEEE Trans. Evolutionary Computation,
vol. 22, no. 6, pp. 821–835, 2018.

[79] M. Wu, S. Kwong, Q. Zhang, K. Li, R. Wang, and B. Liu, “Two-level stable matching-based
selection in MOEA/D,” in SMC’15: Proc. of the 2015 IEEE International Conference on Systems,
Man, and Cybernetics, 2015, pp. 1720–1725.

[80] K. Li, K. Deb, Q. Zhang, and S. Kwong, “An evolutionary many-objective optimization algorithm
based on dominance and decomposition,” IEEE Trans. Evolutionary Computation, vol. 19, no. 5,
pp. 694–716, 2015.

[81] K. Li, S. Kwong, J. Cao, M. Li, J. Zheng, and R. Shen, “Achieving balance between proximity
and diversity in multi-objective evolutionary algorithm,” Inf. Sci., vol. 182, no. 1, pp. 220–242,
2012.

[82] K. Li, K. Deb, O. T. Altin¨oz, and X. Yao, “Empirical investigations of reference point based
methods when facing a massively large number of objectives: First results,” in EMO’17: Proc. of
the 9th International Conference Evolutionary Multi-Criterion Optimization, 2017, pp. 390–405.

[83] K. Li, K. Deb, and Q. Zhang, “Evolutionary multiobjective optimization with hybrid selection
principles,” in CEC’15: Proc. of the 2015 IEEE Congress on Evolutionary Computation, 2015,
pp. 900–907.

[84] K. Li, Z. Xiang, and K. C. Tan, “Which surrogate works for empirical performance modelling?
A case study with diﬀerential evolution,” in CEC’19: Proc. of the 2019 IEEE Congress on
Evolutionary Computation, 2019, pp. 1988–1995.

[85] H. Gao, H. Nie, and K. Li, “Visualisation of pareto front approximation: A short survey and em-
pirical comparisons,” in CEC’19: Proc. of the 2019 IEEE Congress on Evolutionary Computation,
2019, pp. 1750–1757.

[86] M. Liu, K. Li, and T. Chen, “Security testing of web applications: a search-based approach for de-
tecting SQL injection vulnerabilities,” in GECCO’19: Proc. of the 2019 Genetic and Evolutionary
Computation Conference Companion, 2019, pp. 417–418.

23

[87] K. Li and Q. Zhang, “Decomposition multi-objective optimisation: current developments and
future opportunities,” in GECCO’19: Proc. of the 2019 Genetic and Evolutionary Computation
Conference Companion, 2019, pp. 1002–1031.

[88] S. Kumar, R. Bahsoon, T. Chen, K. Li, and R. Buyya, “Multi-tenant cloud service composition
using evolutionary optimization,” in ICPADS’18: Proc. of the 24th IEEE International Confer-
ence on Parallel and Distributed Systems, 2018, pp. 972–979.

[89] M. Liu, K. Li, and T. Chen, “DeepSQLi: Deep semantic learning for testing SQL injection,”
in ISSTA ’20: Proc. of 29th ACM SIGSOFT International Symposium on Software Testing and
Analysis, 2020, pp. 286–297.

[90] J. Cao, H. Wang, S. Kwong, and K. Li, “Combining interpretable fuzzy rule-based classiﬁers via
multi-objective hierarchical evolutionary algorithm,” in ICMLC’11: Proc. of the IEEE Interna-
tional Conference on Systems, Man and Cybernetics, 2011, pp. 1771–1776.

[91] C. X. Ling, J. Huang, and H. Zhang, “AUC: a statistically consistent and more discriminat-
ing measure than accuracy,” in IJCAI’03: Proc. of the 8th International Joint Conference on
Artiﬁcial Intelligence, 2003, pp. 519–526.

24

