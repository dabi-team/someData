9
1
0
2

r
p
A
8
1

]
E
N
.
s
c
[

1
v
7
7
5
8
0
.
4
0
9
1
:
v
i
X
r
a

Semantic variation operators for multidimensional genetic
programming

William La Cava∗
University of Pennsylvania
Philadelphia, PA
lacava@upenn.edu

Jason H. Moore
University of Pennsylvania
Philadelphia, PA
jhmoore@upenn.edu

ABSTRACT
Multidimensional genetic programming represents candidate so-
lutions as sets of programs, and thereby provides an interesting
framework for exploiting building block identification. Towards
this goal, we investigate the use of machine learning as a way to
bias which components of programs are promoted, and propose
two semantic operators to choose where useful building blocks are
placed during crossover. A forward stagewise crossover operator
we propose leads to significant improvements on a set of regression
problems, and produces state-of-the-art results in a large bench-
mark study. We discuss this architecture and others in terms of
their propensity for allowing heuristic search to utilize information
during the evolutionary process. Finally, we look at the collinearity
and complexity of the data representations that result from these ar-
chitectures, with a view towards disentangling factors of variation
in application.

KEYWORDS
representation learning, feature construction, variation, regression

ACM Reference Format:
William La Cava and Jason H. Moore. 2019. Semantic variation operators for
multidimensional genetic programming. In Genetic and Evolutionary Com-
putation Conference (GECCO ’19), July 13–17, 2019, Prague, Czech Republic.
ACM, New York, NY, USA, 9 pages. https://doi.org/10.1145/3321707.3321776

1 INTRODUCTION
A central theme in genetic programming (GP) is how to identify,
propagate, and properly compose the components of programs that
contribute to good solutions. In the context of classification and re-
gression, these building blocks fill the role of “feature engineering".
That is to say, building blocks of GP solutions are meant to explain
the underlying factors of variation that produce the observed re-
sponse. The task of optimizing a set of explanatory features for a
problem is known as representation learning, especially in the larger
machine learning (ML) community [3]. Representation learning is

∗Corresponding Author

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
GECCO ’19, July 13–17, 2019, Prague, Czech Republic
© 2019 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-6111-8/19/07. . . $15.00
https://doi.org/10.1145/3321707.3321776

a fundamental challenge in ML due to its computational complex-
ity and the role the representation plays in model accuracy and
interpretation. Interestingly, a variant of GP known as multidimen-
sional GP (MGP) makes this relationship between building block
discovery and representation learning explicit by optimizing a set
of programs, each of which is an independent feature in the ML
model. Our goal in this paper is to introduce semantic variation
methods to MGP, with the goal of improving the representations it
produces.

What makes a representation good? At the minimum, a good
representation produces a model with better generalization than
a model trained only on the raw data attributes. In addition, a
good representation teases apart the factors of variation in the data
into independent components. Finally, an ideal representation is
succinct so as to promote intelligibility. In other words, a represen-
tation should only have as many features as there are independent
factors in the process. Our discussion centers around these three
motivations.

In the following section, we attempt to summarize the large body
of work concerning feature construction / representation learning
in GP, especially those methods that use ML to promote building
blocks. This provides context for the MGP family of methods. We
then describe our main contribution: the proposed methods of
crossover in Section 3. We conduct an experiment at first on 8
regression problems, considering full hyperparameter tuning, and
analyze the representations that are produced with and without the
new crossover methods. Finally, we benchmark the new methods
against many ML and GP methods on more than 100 open source
regression problems. We find that the new methods of crossover
lead to state-of-the-art results for regression. Our discussion points
to further directions for improving representation quality within
this framework.

2 BACKGROUND
Feature construction / representation learning has been a consistent
theme in the GP community and has been studied with various
architectures. Without major changes, GP can be applied to the task
of identifying single features for regression and classification (or
multiple features in the multiclass case [30]), and this approach has
been explored in several works, summarized in [27]. These filter
approaches generally use an information-theoretic measure to de-
termine how good a program is likely to be as a feature. Optimizing
single features requires basically no changes to GP’s methodology,
but lacks the power to optimize features for the multivariate context
in which they are typically used.

Another approach that has been studied is to treat each indi-
vidual in the population as a feature, and to optimize an ensemble

 
 
 
 
 
 
GECCO ’19, July 13–17, 2019, Prague, Czech Republic

William La Cava and Jason H. Moore

model of the entire population [2, 6, 20, 21, 40]. Only a single re-
gression model is trained per generation, which demands minimal
overhead. However, it is not well known how to properly select
and vary features evolved by such a process. Since each individual
is a feature, its fitness is heavily dependent on the current popula-
tion. Furthermore, a desirable set of features should be essentially
orthogonal in order to create a well-conditioned representation,
and convergent evolutionary processes aim in the opposite direc-
tion. To overcome issues of collinearity and a convergent search
process, the following ideas have been proposed. In evolutionary
feature synthesis (EFS) [2], features are selected proportionally to
their coefficient in a regularized linear model; in order to prevent
multicollinearity, correlation thresholds are implemented during
variation to keep children different from their parents. In the feature
engineering wrapper (FEW) [20, 21], multicollinearity is selected
against by using a survival version of ϵ-lexicase selection to choose
features. In Kaizen GP [6, 40], individuals are only added to the
model if they pass a significance test, in a hill climbing fashion.
Another option is to not use an evolutionary updating scheme at
all, but rather to create a large set of random features and fit an
ML model to this, as in FFX [25]. More recently, Vanneschi et. al.
explored one step linear combinations of random programs [39],
experimentally showing that they often lead to overfitting.

Rather than building a model from the entire population, one
could apply an ML method to the entire program trace as a means of
identifying building blocks [17]. Multiple regression GP (MRGP) [1]
defines a program’s behavior as the Lasso [37] estimate generated
over the entire program’s trace. One downside of this approach
is the likely presence of highly correlated features in the program
trace, leading to an ill-conditioned regression matrix. In a similar
vein to MRGP, Behavioral GP [18] extracts information from the
entire program trace, this time using a decision tree algorithm to
identify important building blocks, which are stored in an archive
for re-use. In both algorithms, the key insight is to use ML with
program traces to undo the complex masking effect that program
execution has on the behavior of building blocks that are down-
stream from other operations in the program (for further discussion
on the topic of program traces see [16]).

MGP is a framework that is, in some sense, in between the en-
semble techniques and the program trace techniques described
above. Programs are represented as sets of separate subprograms,
usually trees. Unlike population-wide models, the fitness of each in-
dividual is directly related to its model predictions, and individuals
in the population benefit from typical evolutionary optimization
processes. Unlike program trace-based methods, by using multi-
output programs, MGP exposes independent components of the total
program behavior to the ML process that produces the model. As
a result, building blocks are easier to isolate and share among the
population in direct ways.

Examples of MGP include Krawiec’s method [15], M2GP [13],
M3GP [28], e-M3GP [36], M4GP [22], and FEAT [23]. In all of these
methods, individuals in the population produce a set of correspond-
ing outputs that are then fed into a deterministic ML method to
produce the program’s regression or classification estimates. In the
case of M2GP, M3GP, and M4GP, classification proceeds using a
nearest centroid classifier [38], whereas linear regression methods

are used for regression with M3GP [29] and FEAT. Although a num-
ber of methods have been proposed in the MGP paradigm, they
have not made much use of the semantics of independent building
blocks in each program that this architecture creates. An exception
is [23], in which the authors use the coefficient magnitude to weight
probabilities of mutation. The main contribution of this study is
the development of semantic crossover schemes to leverage the
architecture of MGP to a larger degree than these previous studies.

3 METHODS
In this paper we focus on the task of regression, with the goal of
building a predictive model ˆy(x) using N paired examples T =
{(xi , yi )}N
i=1. The regression model ˆy(x) associates the inputs x ∈
Rd with a real-valued output y ∈ R. The goal of feature engineering
/ representation learning is to find a new representation of x via
a m-dimensional feature mapping ϕ(x) : Rd → Rm , such that the
model ˆy(ϕ(x)) outperforms the model ˆy(x) by some pre-defined
metric (see above).

In MGP, each individual in the population is a candidate repre-
sentation, ϕ(x), consisting of a set of programs [ϕ1, . . . , ϕm ]. As
an example, the individual

[(+ (x1) (x2)), (cos (x3) ), (exp (cube (x1)))]
would encode a representation with three features: (x1+x2), cos(x3),
and exp(x 3
). Throughout the paper, we refer to these subprograms
1
ϕ as features, and use the word attribute to refer to the independent
variables in x.

MGP methods share this representation in common, and differ in
terms of 1) the ML method used to generate the model prediction,
i.e. ˆy(ϕ), 2) the crossover and mutation operators used, and 3) the
selection process used. The crossover operators proposed in this
section will work with any MGP method, but are designed with a
linear ML pairing in mind.

3.1 Feature Engineering Automation Tool
We study a recent MGP method named the Feature Engineering
Automation Tool (FEAT) [23], in which candidate features are pa-
rameterized by weights, θ , and used to fit a linear model

ˆy =

m
(cid:213)

i=1

βiϕi (x, θ )

(1)

The coefficients [β1,

. . . , βm ] are determined using ridge re-
gression [12]. Note that each ϕ is normalized to zero mean, unit
variance before ridge regression is applied. The parameters θ are
attached to the edges of differentiable operators and updated each
generation via gradient descent. The fitness of each individual in
FEAT is its mean squared error (MSE) on the training set.

Feedback. In order to promote building blocks, FEAT uses feed-
back from the ML process to bias the variation step. In a nutshell, the
probability of a feature in ϕ being mutated or replaced by crossover
is inversely related the magnitude of its coefficient β in Eqn. 1.
Let ˜βi (n) = |βi |/(cid:205)m
|βi |. The normalized coefficient magnitudes
i
˜β ∈ [0, 1] are used to define softmax-normalized probabilities. The
probability of mutation for feature i in program n is denoted PMi (n),
and defined as follows:

Semantic variation operators for multidimensional genetic programming

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

si (n) = exp(1 − ˜βi )/

m
(cid:213)

exp(1 − ˜βi )

i
PMi (n) = γsi (n) + (1 − γ )

1
m

(2)

Here, γ is a parameter that controls the amount of feedback
from the weights that is used to bias the selection of feature i for
mutation. In our experiments, we tune γ , and also test whether the
softmax normalization of si (n) is useful.

Selection. In the initial work introducing FEAT [23], the authors
compared several optimization schemes, including NSGA-II, sim-
ulated annealing, random search, ϵ-lexicase selection [24], and a
hybrid of ϵ-lexicase selection with NSGA-II’s survival scheme. The
final combination achieved the best results in the analysis, and is
used in our work here. The original work attempted to address the
issue of disentanglement by measuring the multicollinearity of rep-
resentations and setting this metric as an additional objective during
survival. However, none of the objectives tried resulted in less cor-
related final representations, and actually made them slightly worse.
One of the goals of this paper is to explore a second hypothesis,
that disentangled representations can be encouraged through the
use of semantic variation operators, rather than through additional
objectives.

Variation. Semantic variation operators have not yet been pro-
posed for MGP frameworks. The most recent MGP techniques
(M3GP, M4GP and FEAT) adopt special variation operators that
vary programs at the feature level. Feature crossover (called “root
crossover" in [28]) swaps features between two parent represen-
tations. Feature mutation may delete a feature or add a random
feature. M3GP, M4GP and FEAT also use standard subtree crossover
and point mutation operators, and each of these operators occur
with equal probability. In FEAT, however, the probabilities of each
feature being chosen for mutation or crossover is determined by
Eqn. 2.

In the following section, we describe two new semantic crossover
operators for MGP that attempt to maintain orthogonality in the
representations while moving towards models with lower residuals.

3.2 Semantic Crossover
The following two crossover methods are called semantic because
they use information about the program’s outputs to determine
the recombination that occurs to produce a child from two par-
ents. Both operators are based on the following observations. We
have two parent representations, ϕp1 and ϕp2, with corresponding
model outputs ˆyp1 and ˆyp2 that are linear combinations of their
respective representations, as in Eqn. 1. We want to produce the
best combination of ϕp1 and ϕp2 for the child representation ϕc .
Basically we can treat this as a feature selection problem, where
= ϕp1 ∪ ϕp2 and we want to pick the best.
we have features ϕA
On one hand we could simply concatenate the feature sets, and
generate a new model ˆy(ϕA), which is the linear model fit to all
features of both parents. This approach would lead to exponential
growth in offspring, which would run against our goal of lowering
complexity.

In lieu of that approach, we propose here what are essentially
regularized versions of semantic crossover that constrain the num-
ber of features in the offspring to be of equal cardinality to ϕp1, i.e.
|ϕc | = |ϕp1|. The first operator, best residual fit crossover (ResXO),
chooses a feature from ϕp1 to be replaced, and then chooses the
feature in ϕp2 that best approximates the residual of the model after
removing this feature. The second operator, stagewise crossover
(StageXO), uses forward stagewise regression [14] as a feature se-
lection method to iteratively construct the offspring.

3.3 Best residual fit crossover (ResXO)
Given parents p1 and p2, ResXO swaps a feature in p1 with the
feature in p2 that most closely approximates the residual error of
p1 with the selected feature removed. The child representation is
denoted as ϕc . The steps are as follows:

(1) pick ϕd from ϕp1 using probabilities given by Eqn. 2.
(2) calculate the residual of p1 without ϕd :

r = y − ˆyp1 − βd ϕd
(3) choose ϕ∗ from ϕp2, which is the feature most correlated

with r .

= ϕp1 with ϕd replaced by ϕ∗.

(4) ϕc
ResXO is a semantic backpropagation operator [7, 11, 33], since
it seeks to replace a component of the parent program with a sub-
program most closely matching the desired semantics, given by r .
Within the MGP framework, this backpropagation is very simple,
and does not require complex inversion operations to be introduced.
We expect that ResXO will also lead to lower correlations between
features in ϕc than in ϕp1. To understand why, consider that

r = y −

(cid:213)

βiϕi

ϕi ∈ϕ p1\ϕd

Therefore r should have low correlation with the rest of the p1’s
representation. Assuming the replacement feature from ϕp2 closely
matches r , it should also be uncorrelated with {ϕp1 \ϕd }. Note that
ResXO may produce an individual with higher squared error than
its parents, since ϕd may be more correlated with r than ϕ∗.

3.4 Forward stagewise crossover (StageXO)
Rather than restricting crossover to the replacement of a single
feature, the crossover operator can be used to compile the set of
features that iteratively reduce the target error using a forward
stagewise crossover method we call StageXO. The procedure is as
follows:

(1) set the initial residual equal to the target: r = y. Center

means around zero for all ϕ.

(2) set ϕA to be all subprograms in ϕp1 and ϕp2.
(3) while |ϕc | < |ϕp1|:

(a) pick ϕ∗ from ϕA which is most correlated with r .
(b) compute the least squares coefficient b for ϕ∗ fit to r .
(c) update r = r − bϕ∗
(d) add ϕ∗ to ϕc .
(e) remove ϕ∗ from ϕA.

Unlike feature selection methods like forward/backward step-
wise selection, forward stagewise selection only calculates the

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

William La Cava and Jason H. Moore

weight of a single feature at a time, and is thus more lightweight.
The downside of this approach in the context of regression is that
it generally takes more iterations to reach the least squares coeffi-
cients of the complete model [10]. In our case this is unimportant,
since we are only interested in quickly choosing the most impor-
tant features, which are then used to fit a multiple linear regression
model. We expect the child representation returned by StageXO to
contain uncorrelated features since the residual is updated each it-
eration to remove the portion of the response explained by previous
features.

Forward stagewise regression, and therefore the StageXO opera-
tor, is closely related to boosting [9]. In both cases the residual is
iteratively reduced by adding model components (weak learners in
the case of boosting, and features/building blocks in our case). The
relationship between forward stagewise regression, boosting, and
regularized linear models is expounded upon in [10]. The stagewise
additive modeling paradigm is also used by a recent GP technique
called Wave [26], in which GP runs are iteratively trained on resid-
uals of previous runs. The insight here is that the unique represen-
tation of programs in MGP allows the same general methodology
to be exploited for combining partial solutions during crossover,
rather than as a post-run ensemble method.

4 EXPERIMENT
Our experiment consists of two stages. First, we conduct an ex-
tensive study of FEAT with and without the semantic crossover
operators introduced in Section 3. In this study we vary the hy-
perparameters related to variation and analyze the results in detail
for 8 regression problems. In the second study, we apply FEAT,
FEATResXO, and FEATStageXO to more than 100 problems from
the PMLB regression benchmark [32]. These variants are compared
to state-of-the-art symbolic regression and ML methods.

4.1 Hyperparameter study
Despite several MGP methods having been proposed, there has
not been a systematic study of the effect of variation operators on
the performance of this family of methods. To fill this gap, and
to properly analyze the new methods introduced in this paper,
we performed a grid search of variation hyperparameters on 8
regression problems. The hyperparameters that were varied are
shown in Table 1.

Feedback softmax normalization refers to the softmax transfor-
mation in Eqn. 2; we tested for whether this normalization, which
assumes a multinomial distribution of probabilities, was useful. The
eight comparison problems are listed in Table 2.

4.2 Benchmark comparison
In the second study, we compared FEAT with each crossover variant
to 15 other methods: 5 GP methods [1, 4, 19, 35] and 10 ML methods
from scikit-learn [34]. The 5 GP methods we compared to are:

• Geometric Semantic GP (GSGP) [4]
• MRGP [1]
• Age-fitness Pareto Optimization (AFP) [35]
• ϵ-lexicase selection (EPLEX) [19]
• ϵ-lexicase selection with 1 million evaluations (EPLEX-1M) [19]

Table 1: Hyperparameter values for FEAT in the experi-
ments. The bottom values are fixed.

Hyperparameter
probability of crossover (comple-
ment: mutation)
feedback (γ , Eqn. 2)
type of feature crossover
probability of feature crossover
(complement: subtree crossover)
feedback softmax normalization
population size
generations
max depth
maximum dimensionality
iterations of gradient descent

Values
[0,0.25,0.5, 0.75,1.0]

[0, 0.25, 0.5, 0.75, 1.0]
[Standard, ResXO, StageXO]
[0.5, 0.75, 1.0]

[On, Off]
500
100 (200 for PMLB)
6
min(50, 2 ∗ |x|)
10

Table 2: Regression problems used for method comparisons.

Problem

Airfoil
Concrete
ENC
ENH
Housing
Tower
UBall5D
Yacht

Dimension

Samples

5
8
8
8
14
25
5
6

1503
1030
768
768
506
3135
6024
309

These methods were benchmarked on 94 open-source datasets
collected in the Penn ML Benchmark [31]. We used results from
Orzechowski et. al.’s benchmark analysis [32] as a comparison, and
followed the same validation procedure. Each comparison method
underwent hyperparameter tuning using 5-fold cross validation on
a 75% split of the training set, and was then tested on a 25% test
fold. The hyperparameters are detailed in Table 1 of the original
work [32]. This process was repeated for 10 trials. GP methods
were given 100,000 evaluations, apart from EPLEX-1M which used
1 million. For FEAT, we did not re-tune the hyperparameters, in-
stead using the values determined from the hyperparameter tuning
experiment.

We also extended the PMLB comparison to larger datasets be-
cause we were interested in 1) how FEAT handled larger datasets
(the original study was restricted to smaller datasets, c.f. Fig. 1 of
[32]) and also how the size of the final models compared to other
top-ranking algorithms such as XGBoost [5] and multilayer percep-
tron (MLP). The extended analysis included 111 datasets, whose
properties are shown in Fig. 1. These datasets are used to evaluate
the complexity of the final models.

4.3 Metrics
As mentioned earlier, we consider there to be three over-arching
goals when learning a representation. The first is that ϕ(x) leads to a
model with a low generalization error. To measure this, we compare

Semantic variation operators for multidimensional genetic programming

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

Figure 1: Properties of
PMLB [31].

the benchmarks used from

the mean squared error (MSE) and coefficient of determination (R2)
of each model output on the test set. We also wish to minimize the
complexity of the representation. To measure the complexity of
solutions in FEAT, we count the total number of nodes in the final
representation. For comparison to XGBoost, we count the number of
nodes in the trees, and for comparison to MLP, we count the number
of nodes in the network. Finally, we want a representation that is
“disentangled", meaning that each feature of ϕ is as orthogonal to
the others as possible. One such measure is the pairwise Pearson
correlations of features in ϕ, written as

Corr (ϕ) =

1
N (N − 1)

(cid:213)

ϕi,ϕj ∈ϕ,i(cid:44)j

(cid:19)2

(cid:18) cov(ϕi , ϕj )
σ (ϕi )σ (ϕj )

(3)

We use this equation to compare the final representations across

selection methods.

5 RESULTS
The hyperparameter tuning results are presented first. In addition
to test score reporting, we plot various views of the data with re-
spect to different hyperparameters, and also look at representation
correlations in the resultant models and statistical comparisons. In
the subsequent section, the PMLB comparison results are shown,
including score comparisons, runtime comparisons, statistical tests
and comparisons of the final model sizes for FEAT, XGBoost, and
MLP learners.

5.1 Hyperparameter tuning
Prediction comparisons for each crossover method are shown in
Fig. 2 for the 8 tuning problems. The plot shows the mean test fold

Figure 2: Mean 5-fold CV R2 performance for different
crossover operators on the 8 tuning problems.

R2 value for the tuned estimator, summarized across trials. In gen-
eral one can see that StageXO produces the most accurate results,
followed by ResXO. Across the 8 problems, StageXO significantly
outperforms standard crossover (p <0.035); the pairwise statistical
comparisons are given in Table 3.

We also looked at the correlation of the representations produced
by the different crossover methods, shown in Fig. 3. We confirmed
our hypotheses that ResXO and StageXO would produce less corre-
lated representations than the traditional crossover operator.

The best values for each tuned parameter is shown in Table 4.
We found that softmax normalization did not improve the feedback
probabilities. Across problems, the best crossover/mutation fraction
was found to be 0.75 (Fig. 4), with a feature crossover rate of 0.75
for Feat and 0.5 for ResXO and StageXO. The best feedback value
was problem dependent, as shown in Fig. 5. Since the feedback
essentially controls the amount of exploration versus exploitation,
it stands to reason that the ideal setting of this parameter would be
problem dependent. Feedback levels of 0.25 were best for FEAT and
FEATStageXO, and no feedback was best for FEATResXO. For the
ResXO operator, this corresponds to choosing the feature to swap
out of the parent at random.

102103104Number of instances101102Number of features0.710.720.730.74Score (R2)airfoil0.8450.8500.8550.8600.865concrete0.9700.9710.9720.9730.9740.975Score (R2)enc0.99740.99750.99760.9977enh0.8150.8200.8250.830Score (R2)housing0.9460.9480.9500.952towerFeatFeatResXOFeatStageXOAlgorithm0.900.920.94Score (R2)uball5dFeatFeatResXOFeatStageXOAlgorithm0.99650.99700.9975yachtGECCO ’19, July 13–17, 2019, Prague, Czech Republic

William La Cava and Jason H. Moore

Figure 3: Average pairwise representation correlation
(Eqn. 3) for different crossover operators on the 8 tuning
problems.

Figure 4: Test rankings for different crossover probabilities
on the 8 tuning problems.

Figure 5: Mean 5-fold CV R2 performance for different levels
of feedback on the 8 tuning problems.

Table 3: Bonferroni-adjusted p-values using a Wilcoxon
signed rank test of R2 scores for the methods across all tun-
ing problems. Bold: p <0.05.

Feat

FeatResXO

FeatResXO 4.6e-01
FeatStageXO 3.5e-02

1.2e-01

Table 4: Best hyperparameter values for FEAT across the 8
tuning problems.

Hyperparameter
probability of crossover
feedback
probability of feature crossover
feedback softmax normalization

FEAT
0.75
0.25
0.75
Off

FEAT-ResXO
0.75
0.0
0.5
Off

FEAT-StageXO
0.75
0.25
0.5
Off

5.2 Benchmark comparison
The comparisons of FEAT to 15 other methods is shown in Fig. 6.
Across problems, FEATStageXO achieves a nearly identical ranking
to EPLEX-1M, which is ϵ-lexicase selection run for 1 million eval-
uations. In this case, FEATStageXO achieves these similar results

using 100,000 evaluations. However, the additional complexity of
fitting ML models to each individual makes the evaluation of each
individual in FEAT more costly. The wall clock times shown in Fig. 7
reflect this, as the FEAT wall clock times sit somewhere between
the methods that ran for 100,000 evaluations (GSGP, AFP, MRGP,
EPLEX) and EPLEX-1M.

A Friedman test of the MSE rankings across problems indicates
significant differences. Table 5 shows post-hoc pairwise Wilcoxon
signed rank tests of the results. FEAT, FEATResXO, and FEAT-
StageXO all significantly outperform the other GP-based methods
run for 100,00 evaluations. There is no significant difference found
between the FEAT variants, EPLEX-1M, XGBoost, GradBoost, or
MLP. The FEAT variants significantly outperform all other ML
methods across the benchmark problems.

We extend the comparison of FEAT to XGBoost, MLP and Elas-
ticNet on 111 of the datasets in PMLB in order to evaluate the
complexity of the final representations. The size comparisons are
shown in Fig. 8. In general FEAT produces representations about
1.5 orders of magnitude smaller than XGBoost and MLP. We found
that StageXO led to slightly larger models than Feat or FeatResXO.

FeatFeatResXOFeatStageXO0.60.81.0Mean Representation Correlation0.00.250.50.751.0Crossover/Mutation Rate050100Test Score Rankall problemsStandardResXOStageXO0.00.250.50.751.00.60.7Mean CV R2airfoil0.00.250.50.751.00.820.840.86concrete0.00.250.50.751.00.9650.970Mean CV R2enc0.00.250.50.751.00.9940.996enh0.00.250.50.751.00.70.8Mean CV R2housing0.00.250.50.751.00.930.940.95tower0.00.250.50.751.0feedback0.80.9Mean CV R2uball5d0.00.250.50.751.0feedback0.9850.9900.995yachtStandardResXOStageXOSemantic variation operators for multidimensional genetic programming

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

Figure 6: Median test MSE rankings on the PMLB datasets. The box shows the quartiles of the rankings with whiskers showing
the rest of the distribution excluding outliers. Algorithms are ordered left to right by best (lowest) to worst (highest) median
ranking.

Figure 7: Runtime comparisons on the PMLB datasets. Runtime is the wall clock time for a single training instance. Algorithms
are ordered to match Fig. 6.

Adaboost

AFP

EPLEX

EPLEX-
1M

FEAT

FEAT-
ResXO

FEAT-
StageXO

GradBoost GSGP

KernelRidge Lasso

LinReg

LinSVR

MLP

MRGP

RF

SGD

AFP
EPLEX
EPLEX-1M
FEAT
FEATResXO
FEATStageXO
GradBoost
GSGP
KernelRidge
Lasso
LinReg
LinSVR
MLP
MRGP
RF
SGD
XGBoost

1.2e-02
1.0e+00
8.2e-09
2.6e-08
1.8e-04
9.1e-08
1.5e-08
8.4e-11
1.0e+00
8.3e-04
1.1e-04
1.1e-03
2.6e-02
1.0e+00
7.9e-05
2.0e-06
2.1e-08

7.3e-08
9.4e-12
5.8e-10
2.2e-06
8.2e-10
2.3e-08
2.6e-07
1.5e-03
1.0e+00
7.0e-03
8.6e-02
2.6e-06
1.0e+00
1.2e-04
6.4e-05
6.9e-11

3.4e-09
1.9e-06
5.8e-04
4.1e-06
5.6e-03
4.1e-12
1.0e+00
1.9e-06
2.3e-07
2.3e-06
1.0e+00
1.0e+00
1.0e+00
1.9e-09
5.3e-05

1.0e+00
5.0e-02
1.0e+00
3.7e-02
1.5e-14
8.1e-04
4.4e-12
3.7e-12
4.6e-12
1.0e+00
1.1e-04
7.4e-06
9.6e-13
1.0e+00

1.7e-02
1.0e+00
1.0e+00
8.1e-14
2.1e-02
4.5e-10
4.5e-11
1.3e-09
1.0e+00
7.0e-04
1.0e-04
2.7e-12
1.0e+00

5.8e-03
1.0e+00
5.1e-13
1.0e+00
3.5e-07
4.5e-09
5.7e-07
1.0e+00
2.8e-01
2.0e-01
1.5e-09
1.0e+00

1.0e+00
2.3e-14
1.1e-02
4.8e-10
6.1e-11
9.0e-10
1.0e+00
3.6e-04
7.6e-05
1.3e-11
1.0e+00

2.6e-14
9.9e-01
1.8e-08
1.7e-08
2.6e-08
1.0e+00
2.1e-01
2.3e-06
4.1e-11
8.9e-03

1.4e-14
2.1e-02
1.0e+00
3.9e-01
9.6e-15
2.1e-05
2.1e-13
1.0e+00
6.0e-15

8.6e-08
3.0e-09
7.9e-09
7.4e-01
1.0e+00
1.0e+00
2.6e-09
6.9e-03

1.0e+00
1.0e+00
6.8e-07
2.3e-01
4.7e-06
5.5e-02
1.3e-10

1.0e+00
2.0e-08
2.5e-02
4.4e-06
1.0e+00
6.4e-10

1.3e-07
1.5e-01
1.3e-06
1.0e+00
2.2e-10

1.0e+00
1.0e+00
1.8e-09
1.0e+00

1.0e+00
4.5e-03
2.8e-03

2.8e-09
3.6e-08

5.8e-12

Table 5: Bonferroni-adjusted p-values using a Wilcoxon signed rank test of MSE scores for the methods across all benchmarks.
Bold: p <0.05.

6 DISCUSSION & CONCLUSION
This paper proposes semantic crossover operators for multidimen-
sional genetic programming. We contend that MGP provides an
interesting framework for developing semantic variation methods,
due to the unique way that program semantics are easily teased
apart in the multi-output architecture. The most successful of these
is forward stagewise crossover (StageXO), which mimics forward
stagewise selection to incrementally build an offspring from the

representations of its parents. A lightweight version of seman-
tic backpropagation crossover, ResXO, is also proposed. StageXO
achieves better performance on 8 regression problems than naive
crossover operators, taking into account hyperparameter tuning.
We find that the resultant representations are also less “entangled",
i.e. less correlated when using these crossover methods.

We consider this to be a first foray into semantic methods for
MGP, and consider the potential for more powerful techniques to
be high. One can imagine many more semantic operators that take

FeatStageXOEPLEX-1MXGBoostFeatFeatResXOGradBoostMLPMRGPRFKernelRidgeAdaboostEPLEXAFPLassoGSGPSGDLinRegLinSVR2.55.07.510.012.515.017.5Median Test MSE RanksFeatStageXOEPLEX-1MXGBoostFeatFeatResXOGradBoostMLPMRGPRFKernelRidgeAdaboostEPLEXAFPLassoGSGPSGDLinRegLinSVR10−210−1100101102103Runtime (s)GECCO ’19, July 13–17, 2019, Prague, Czech Republic

William La Cava and Jason H. Moore

[4] Mauro Castelli, Sara Silva, and Leonardo Vanneschi. 2015. A C++ framework for
geometric semantic genetic programming. Genetic Programming and Evolvable
Machines 16, 1 (March 2015), 73–81. https://doi.org/10.1007/s10710-014-9218-0
[5] Tianqi Chen and Carlos Guestrin. 2016. XGBoost: A Scalable Tree Boosting
System. In Proceedings of the 22Nd ACM SIGKDD International Conference on
Knowledge Discovery and Data Mining (KDD ’16). ACM, New York, NY, USA,
785–794. https://doi.org/10.1145/2939672.2939785

[6] Vinícius Veloso De Melo. 2014. Kaizen programming. ACM Press, 895–902.

https://doi.org/10.1145/2576768.2598264

[7] Robyn Ffrancon and Marc Schoenauer. 2015. Memetic Semantic Genetic Pro-
gramming. ACM Press, 1023–1030. https://doi.org/10.1145/2739480.2754697
[8] Steven B. Fine, Erik Hemberg, Krzysztof Krawiec, and Una-May O’Reilly. 2018.
Exploiting Subprograms in Genetic Programming. In Genetic Programming Theory
and Practice XV (Genetic and Evolutionary Computation), Wolfgang Banzhaf,
Randal S. Olson, William Tozier, and Rick Riolo (Eds.). Springer International
Publishing, 1–16.

[9] Yoav Freund and Robert E. Schapire. 1995. A desicion-theoretic generalization of
on-line learning and an application to boosting. In Computational learning theory.
Springer, 23–37. http://link.springer.com/chapter/10.1007/3-540-59119-2_166

[10] Jerome Friedman, Trevor Hastie, and Robert Tibshirani. 2001. The elements of
statistical learning. Vol. 1. Springer series in statistics Springer, Berlin. http:
//statweb.stanford.edu/~tibs/book/preface.ps

[11] Mario Graff, Eric Sadit Tellez, Elio Villaseñor, and Sabino Miranda. 2015. Semantic
Genetic Programming Operators Based on Projections in the Phenotype Space.
(2015), 13.

[12] Arthur E. Hoerl and Robert W. Kennard. 1970. Ridge regression: Biased estimation

for nonorthogonal problems. Technometrics 12, 1 (1970), 55–67.

[13] Vijay Ingalalli, Sara Silva, Mauro Castelli, and Leonardo Vanneschi. 2014. A
Multi-dimensional Genetic Programming Approach for Multi-class Classification
Problems. In Genetic Programming. Springer, 48–60. http://link.springer.com/
chapter/10.1007/978-3-662-44303-3_5

[14] Gareth James, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2013. An
Introduction to Statistical Learning. Springer Texts in Statistics, Vol. 103. Springer
New York, New York, NY. https://doi.org/10.1007/978-1-4614-7138-7

[15] Krzysztof Krawiec. 2002. Genetic programming-based construction of features
for machine learning and knowledge discovery tasks. Genetic Programming and
Evolvable Machines 3, 4 (2002), 329–343. http://link.springer.com/article/10.1023/
A:1020984725014

[16] Krzysztof Krawiec. 2012. On relationships between semantic diversity, com-
plexity and modularity of programming tasks. In Proceedings of the fourteenth
international conference on Genetic and evolutionary computation conference. ACM,
783–790. http://dl.acm.org/citation.cfm?id=2330272

[17] Krzysztof Krawiec. 2016. Behavioral program synthesis with genetic programming.

Vol. 618. Springer.

[18] Krzysztof Krawiec and Una-May O’Reilly. 2014. Behavioral programming: a
broader and more detailed take on semantic GP. In Proceedings of the 2014 con-
ference on Genetic and evolutionary computation. ACM Press, 935–942. https:
//doi.org/10.1145/2576768.2598288

[19] William La Cava, Thomas Helmuth, Lee Spector, and Jason H. Moore. 2018. A
probabilistic and multi-objective analysis of lexicase selection and ε -lexicase
selection. Evolutionary Computation (May 2018), 1–28. https://doi.org/10.1162/
evco_a_00224

[20] William La Cava and Jason Moore. 2017. A General Feature Engineering Wrapper
for Machine Learning Using \epsilon -Lexicase Survival. In Genetic Programming.
Springer, Cham, 80–95. https://doi.org/10.1007/978-3-319-55696-3_6

[21] William La Cava and Jason H Moore. 2017. Ensemble representation learning: an
analysis of fitness and survival for wrapper-based genetic programming methods.
In GECCO ’17: Proceedings of the 2017 Genetic and Evolutionary Computation
Conference. ACM, Berlin, Germany, 961–968. https://doi.org/10.1145/3071178.
3071215

[22] William La Cava, Sara Silva, Kourosh Danai, Lee Spector, Leonardo Vanneschi,
and Jason H. Moore. 2018. Multidimensional genetic programming for multiclass
classification. Swarm and Evolutionary Computation (April 2018). https://doi.
org/10.1016/j.swevo.2018.03.015

[23] William La Cava, Tilak Raj Singh, James Taggart, Srinivas Suri, and Jason H.
Moore. 2019. Learning concise representations for regression by evolving net-
works of trees. In International Conference on Learning Representations (ICLR).
https://arxiv.org/abs/1807.00981 In Press.

[24] William La Cava, Lee Spector, and Kourosh Danai. 2016. Epsilon-Lexicase Se-
lection for Regression. In Proceedings of the Genetic and Evolutionary Com-
putation Conference 2016 (GECCO ’16). ACM, New York, NY, USA, 741–748.
https://doi.org/10.1145/2908812.2908898

[25] Trent McConaghy. 2011. FFX: Fast, scalable, deterministic symbolic regression
technology. In Genetic Programming Theory and Practice IX. Springer, 235–260.
http://link.springer.com/chapter/10.1007/978-1-4614-1770-5_13

[26] David Medernach, Jeannie Fitzgerald, R. Muhammad Atif Azad, and Conor Ryan.
2016. A New Wave: A Dynamic Approach to Genetic Programming. In Proceedings
of the Genetic and Evolutionary Computation Conference 2016 (GECCO ’16). ACM,

Figure 8: Number of nodes in solutions on the PMLB
datasets.

advantage of this architecture. Three extensions come to mind. The
first is to consider the features of many programs during crossover,
rather than just two parents, as is done with population wide se-
mantic crossover [39], behavioral GP, or in recent work by Fine
et. al. [8]. The second extension would be to explicitly design vari-
ation operators that improve the condition of the representation,
for example by pruning highly correlated features. A third exten-
sion is to implement smarter termination conditions for stagewise
crossover that take into account the fitness of the parents or an
error tolerance.

The current methods appear to be competitive with state-of-the-
art regression techniques. In particular, FEAT is able to achieve
top ranking results with less computational complexity than the
previous top GP method on the PMLB benchmark. It is also able
to produce much smaller representations than XGBoost and MLP.
These promising results should motivate further research within
the MGP framework.

7 SUPPLEMENTARY MATERIAL
Code to reproduce the experiments can be found at http://github.
com/lacava/gecco_2019.

8 ACKNOWLEDGMENTS
This work was supported by NIH grants AI116794 and LM012601,
as well as the PA CURE grant from the Pennsylvania Department
of Health. Special thanks to Tilak Raj Singh and members of the
Computational Genetics Lab.

REFERENCES
[1] Ignacio Arnaldo, Krzysztof Krawiec, and Una-May O’Reilly. 2014. Multiple
regression genetic programming. In Proceedings of the 2014 conference on Genetic
and evolutionary computation. ACM Press, 879–886. https://doi.org/10.1145/
2576768.2598291

[2] Ignacio Arnaldo, Una-May O’Reilly, and Kalyan Veeramachaneni. 2015. Building
Predictive Models via Feature Synthesis. ACM Press, 983–990. https://doi.org/10.
1145/2739480.2754693

[3] Yoshua Bengio, Aaron Courville, and Pascal Vincent. 2013. Representation
learning: A review and new perspectives. IEEE transactions on pattern analysis
and machine intelligence 35, 8 (2013), 1798–1828. http://ieeexplore.ieee.org/xpls/
abs_all.jsp?arnumber=6472238

FeatStageXOFeatFeatResXOXGBMLPElasticNet100101102103104Size (# nodes)Semantic variation operators for multidimensional genetic programming

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

New York, NY, USA, 757–764. https://doi.org/10.1145/2908812.2908857

[27] Mohammed Muharram and George D. Smith. 2005. Evolutionary constructive
induction. IEEE Transactions on Knowledge and Data Engineering 17, 11 (2005),
1518–1528. http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1512037
[28] Luis Muñoz, Sara Silva, and Leonardo Trujillo. 2015. M3GP–Multiclass Classifi-
cation with GP. In Genetic Programming. Springer, 78–91. http://link.springer.
com/chapter/10.1007/978-3-319-16501-1_7

[29] Luis Muñoz, Leonardo Trujillo, Sara Silva, Mauro Castelli, and Leonardo Van-
neschi. 2018. Evolving multidimensional transformations for symbolic regres-
sion with M3GP. Memetic Computing (Sept. 2018). https://doi.org/10.1007/
s12293-018-0274-5

[30] Kourosh Neshatian, Mengjie Zhang, and Peter Andreae. 2012. A filter approach
to multiple feature construction for symbolic learning classifiers using genetic
programming. IEEE Transactions on Evolutionary Computation 16, 5 (2012), 645–
661.

[31] Randal S. Olson, William La Cava, Patryk Orzechowski, Ryan J. Urbanowicz, and
Jason H. Moore. 2017. PMLB: A Large Benchmark Suite for Machine Learning
Evaluation and Comparison. BioData Mining (2017). https://arxiv.org/abs/1703.
00512 arXiv preprint arXiv:1703.00512.

[32] Patryk Orzechowski, William La Cava, and Jason H. Moore. 2018. Where are
we now? A large benchmark study of recent symbolic regression methods.
arXiv:1804.09331 [cs] (April 2018). https://doi.org/10.1145/3205455.3205539 arXiv:
1804.09331.

[33] Tomasz P. Pawlak, Bartosz Wieloch, and Krzysztof Krawiec. 2015. Semantic
backpropagation for designing search operators in genetic programming. IEEE
Transactions on Evolutionary Computation 19, 3 (2015), 326–340.

[34] Fabian Pedregosa, Gaël Varoquaux, Alexandre Gramfort, Vincent Michel,
Bertrand Thirion, Olivier Grisel, Mathieu Blondel, Peter Prettenhofer, Ron

Weiss, Vincent Dubourg, and others. 2011. Scikit-learn: Machine learning
in Python. Journal of Machine Learning Research 12, Oct (2011), 2825–2830.
http://www.jmlr.org/papers/v12/pedregosa11a.html

[35] Michael Schmidt and Hod Lipson. 2011. Age-fitness pareto optimization. In
Genetic Programming Theory and Practice VIII. Springer, 129–146. http://link.
springer.com/chapter/10.1007/978-1-4419-7747-2_8

[36] Sara Silva, Luis Munoz, Leonardo Trujillo, Vijay Ingalalli, Mauro Castelli, and
Leonardo Vanneschi. 2015. Multiclass Classification Through Multidimensional
Clustering. In Genetic Programming Theory and Practice XIII. Vol. 13. Springer,
Ann Arbor, MI.

[37] Robert Tibshirani. 1996. Regression shrinkage and selection via the lasso. Journal
of the Royal Statistical Society. Series B (Methodological) (1996), 267–288. http:
//www.jstor.org/stable/2346178

[38] Robert Tibshirani, Trevor Hastie, Balasubramanian Narasimhan, and Gilbert
Chu. 2002. Diagnosis of multiple cancer types by shrunken centroids of gene
expression. Proceedings of the National Academy of Sciences 99, 10 (May 2002),
6567–6572. https://doi.org/10.1073/pnas.082099299

[39] Leonardo Vanneschi, Mauro Castelli, Luca Manzoni, Krzysztof Krawiec, Alberto
Moraglio, Sara Silva, and Ivo Gonçalves. 2017. PSXO: population-wide semantic
crossover. In Proceedings of the Genetic and Evolutionary Computation Conference
Companion. ACM, 257–258.

[40] Vinícius Veloso de Melo and Wolfgang Banzhaf. 2017. Automatic Feature Engi-
neering for Regression Models with Machine Learning: an Evolutionary Compu-
tation and Statistics Hybrid. Information Sciences (2017). https://doi.org/10.1016/
j.ins.2017.11.041

