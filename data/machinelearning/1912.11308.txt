9
1
0
2

c
e
D
4
2

]

G
L
.
s
c
[

1
v
8
0
3
1
1
.
2
1
9
1
:
v
i
X
r
a

ADD-Lib: Decision Diagrams in Practice

Frederik Gossen, Alnis Murtovi, Philip Zweihoﬀ, and Bernhard Steﬀen

TU Dortmund University, Germany
{firstname.lastname}@tu-dortmund.de

Abstract. In the paper, we present the ADD-Lib, our eﬃcient and easy
to use framework for Algebraic Decision Diagrams (ADDs). The focus
of the ADD-Lib is not so much on its eﬃcient implementation of in-
dividual operations, which are taken by other established ADD frame-
works, but its ease and ﬂexibility, which arise at two levels: the level of
individual ADD-tools, which come with a dedicated user-friendly web-
based graphical user interface, and at the meta level, where such tools
are speciﬁed. Both levels are described in the paper: the meta level by
explaining how we can construct an ADD-tool tailored for Random For-
est reﬁnement and evaluation, and the accordingly generated Web-based
domain-speciﬁc tool, which we also provide as an artifact for cooperative
experimentation. In particular, the artifact allows readers to combine a
given Random Forest with their own ADDs regarded as expert knowledge
and to experience the corresponding eﬀect.

Keywords: Algebraic Decision Diagrams, Binary Decision Diagrams,
Random Forest, Modeling.

1

Introduction

Taking decisions on the basis of some scenario proﬁle is omnipresent: the evalu-
ation of program conditions falls into this category, as well as typical (AI-based)
classiﬁcation approaches, like e.g., letter recognition, but also (recommender
system-based) oﬀer selection business decisions. Algebraic Decision Diagrams
provide a powerful framework for decision taking that can easily be adapted to
a wide range of application scenarios just by ’playing’ with the underlying al-
gebraic structure to support e.g., deterministic, probabilistic and fuzzy decision
paradigms. Random Forests provide an interesting application scenario, which
is not only very popular in practice, but which can particularly beneﬁt from the
ADD technology. In fact, in [15] we were able to improve the Random Forest
evaluation by multiple order of magnitude.

State-of-the Art ADD frameworks like CUDD are a good basis to eﬃciently
implement corresponding decision support systems, but require low level pro-
gramming and dedicated extensions, e.g. to change the underlying algebraic
structure.

In the paper, we present the ADD-Lib, our eﬃcient and easy to use algebraic
framework for dealing with decision diagrams. Characteristic for ADD-Lib are

 
 
 
 
 
 
not so much the eﬃcient implementation of individual operations, which are
taken from other established ADD frameworks, but its ease and ﬂexibility, which
arise at two levels:

– At the level of individual ADD-tools, which come with a dedicated user-
friendly Web-based graphical user interface supporting cooperative work.
These tools are designed to address the application expert and to not require
any programming expertise.

– At the meta level, where such tools are speciﬁed. This comprises the def-
inition of a corresponding domain-speciﬁc language in term of its abstract
and concrete (graphical) syntax, the required algebraic structure, as well as
intended GUI features.

Both levels are described in the paper: the meta level by explaining how we can
construct an ADD-tool tailored for Random Forest reﬁnement and evaluation,
and the accordingly generated Web-based domain-speciﬁc tool, which we also
provide as an artifact for cooperative experimentation. In particular, the artifact
allows readers to reﬁne given Random Forests with their own ADDs expressing
their dedicated domain knowledge and to experience the corresponding eﬀect.

In Section 2, we recap various forms of decision diagrams and point the
reader to relevant literature. After introducing the ADD-Lib, our framework for
Algebraic Decision Diagrams in Section 3, we present a case study in which we
augment a machine-learned decision model with expert knowledge in Section 4
conclude in Section 5.

2 Decision Diagrams

The most widely known example of decision diagrams are (Reduced Ordered)
Binary Decision Diagrams (BDDs) [7]. For more than 30 years now, this data
structure is state of the art for the representation of Boolean functions. Many
other forms of decision diagrams [8,25] have emerged since: reduced, ordered,
binary, n-ary, those over Boolean values and others with more than just two
terminals. In this section, we will give a brief overview of some variants and
point to relevant literature.

Binary Decision Diagrams, although the most popular form, were not the
ﬁrst kind of decision diagram. In fact, the ﬁrst form was called a Binary-decision
Program [20], a representation that relies on the idea of many subsequent binary
decisions until the result of the program is reached. Although it was not called
one, this representation already constitutes a directed acyclic graph.

The basic idea evolved to a graph-based data structure for Boolean func-
tions [3]. With the elimination of duplicate and redundant nodes, the represen-
tation could be simpliﬁed, similar to the simpliﬁcation of a Boolean formula.

The breakthrough, however, was the introduction of an order on the Boolean
variables of the input domain. For a given variable order, (Reduced Ordered)
Binary Decision Diagrams (BDDs) [7] are

– a canonical representation for Boolean functions (Bn → B),

x1

x3

x2

x1

x3

x2

x3

0

1

0

1

2

(a) BDD for the
Boolean function
(x1 ∧ x2) ∨ x3.

(b) ADD for
(x1 ∗ x2) + x3.

the function

Fig. 1. Exemplary BDD and ADD representing analogous functions.

– minimal in size, and
– every input variable is encountered at most once per path from the root to

a terminal node.

For brevity, we will assume all decision diagrams to be reduced and ordered in
what follows.

Because BDDs represent Boolean functions, all logical operations, e.g. con-
junction, disjunction, and negation, are naturally deﬁned on them and eﬃcient
algorithms exist. In this way, BDDs form an algebraic structure analogous to the
standard Boolean logic. Binary Decision Diagrams are used for symbolic model
checking [9], equivalence checking [18], VLSI-synthesis [5] and various other ar-
eas. An exemplary BDD for the Boolean function x1 ∧ x2 ∨ x3 is displayed in
Figure 1a.

Algebraic Decision Diagrams (ADDs) [28] are a generalization of BDDs
that is of particular interest to our contributions. Rather than representing BDDs
with a Boolean co-domain (Bn → B), they are able to represent functions with
an arbitrary co-domain (Bn → A). At the same time, ADDs inherit their key
properties, canonicity, minimality, and variable appearances, from BDDs.

ADDs have their origin in Multi Terminal BDDs [11], however, their associ-
ation with an algebraic structure is the essential conceptual extension [28]. With
that, we can deﬁne any algebraic structure, e.g. (A, ◦), directly on the co-domain
A. Every operation on this carrier set can be lifted to the level of their respective
decision diagrams.

Similarly to the realization of standard Boolean operations on BDDs, eﬃcient
algorithms are known for ADDs, too. Rather than conjunction, disjunction, and
negation, we can, e.g., deﬁne a join operation ◦. The operation can then be

Fig. 2. Exemplary ADD with the RGB color space as its algebraic structure.

applied to (i) elements of the co-domain as well as to (ii) the corresponding
ADDs. For brevity, we denote the operations on the co-domains and those on
the ADDs with the same symbols.

Use cases for ADDs include stochastic planning [17], stochastic model check-

ing [19], and logic synthesis, veriﬁcation, and testing of digital circuits [28].

An exemplary ADD with the associated algebraic structure (Z, +, ∗) is shown
in Figure 1b. The depicted function x1 ∗ x2 + x3 is similar to that of previously
seen BDD in the sense that multiplication replaces conjunction and addition
replaces disjunction (cf. Figure 1a).

ADDs are by no means limited to integers, or even numbers. A more complex
example is shown in Figure 2 where the algebraic structure is deﬁned over colors
in the RGB space [0 . . . 255]3. This example originates from an email classiﬁcation
service that assigns colors to emails based on some importance criterion [14]. It
is shown here solely to illustrate the ﬂexibility of ADDs.

3 ADD-Lib

There exist many implementations of the standard algorithms for Binary De-
cision Diagrams (BDDs), Algebraic Decision Diagrams (ADDs), and even for
Zero-suppressed Decision Diagrams (ZDDs) [4,21,29]. However, these realiza-
tions lack ﬂexibility at their core: The underlying algebraic structures, e.g. the
standard Boolean logic, are hard coded – even for Algebraic Decision Diagrams.
In CUDD [29], e.g., ADDs are limited to real numbers1 and the standard
arithmetic operations. The framework is, in fact, so rigid that a change of the
algebraic structure imposes a non-trivial adaptation of the library’s core – a
change that would eﬀect major parts of the code base.

With the ADD-Lib [1], we provide a framework that overcomes these limita-
tions: This decision diagram framework is highly ﬂexible and puts emphasis on
the interchangeability of the underlying algebraic structure. At the same time,
the implementation delegates computationally expensive operations to the well-
established and robust C implementation of CUDD in a service-oriented fashion.
In this way, the ADD-Lib inherits its broad range of functions and provides an
easy-to-use yet ﬂexible interface for the most common use cases.

1 Real numbers are represented by double values.

importantEmailsubjectContainsUrgentsubjectContainsDeadlinesubjectContainsNewslettersubjectContainsNewslettersubjectContainsOverduefromGovfromGovfromGovfromGovsubjectContainsNewsletterfromShopAfromShopAfromShopAfromShopAfromShopBinAddressBook63, 63, 63fromShopBinAddressBook0, 0, 044, 0, 0108, 63, 63127, 127, 127fromShopBinAddressBookfromShopB127, 63, 63inAddressBook127, 0, 0172, 0, 0191, 63, 63236, 63, 63191, 127, 127fromGovfromGovfromShopAfromShopAfromShopAfromShopAfromShopBinAddressBook63, 127, 63fromShopBinAddressBook0, 64, 044, 64, 0108, 127, 63127, 191, 127fromShopBinAddressBookfromShopB127, 127, 63inAddressBook127, 64, 0172, 64, 0191, 127, 63236, 127, 63191, 191, 127fromShopAfromShopAfromShopAfromShopAfromShopBinAddressBook63, 191, 63fromShopBinAddressBook0, 127, 044, 127, 0108, 191, 63127, 255, 127fromShopBinAddressBookfromShopB127, 191, 63inAddressBook127, 127, 0172, 127, 0191, 191, 63236, 191, 63191, 255, 127The deﬁnition of a new algebraic structure demands no more than a speci-
ﬁcation of its carrier set and the associated operations. This way, the algebraic
structure can be deﬁned directly on the co-domain of the ADDs. That very deﬁ-
nition is then plugged into the ADD algorithms for the operations on the actual
data structure. The user deﬁnes the simple underlying algebraic structure and
gets the corresponding algebraic structure of ADDs with no additional eﬀort.

To facilitate the implementation of custom algebraic structures, the ADD-
Lib comes with templates for the most common use cases. The categorization
into

– groups and group-like structures,
– rings and ring-like structures, and
– various lattices and logics

allows to determine the required operations at compile time. For example, a
Boolean lattice will require conjunction, disjunction, and negation as well as a
distinguished 0 and 1 element.

Consider an application that makes Boolean decisions based on some predi-
cates, e.g. an email ﬁlter [14,30]. A standard BDD with its Boolean operations
would be a suitable data structure to represent such a decision function. However,
when some notion of certainty is required the standard Boolean logic (B, ∧, ∨, ¬)
is no longer an appropriate model. Instead, a three-valued logic or one of the
many fuzzy logics is then more suitable to model the problem. A concrete in-
stance of such a logic is the probabilistic fuzzy logic:

Af := ([0, 1], ∧f , ∨f , ¬f ) with a ∧f b := a ∗ b

a ∨f b := 1 − (1 − a) ∗ (1 − b)

¬f := 1 − a

This custom deﬁnition of a logic is naturally deﬁned on its carrier set, the
interval [0, 1]. The ADD-Lib lifts this deﬁnition to ADDs and, with that, pro-
vides a data structure to model decision functions of the form Bn → [0, 1]. All
operations that were deﬁned on the carrier set, i.e. conjunction, disjunction, and
negation, are then also applicable to these decision diagrams.

Besides being an extremely ﬂexible framework for ADDs, the ADD-Lib comes
with powerful tools that facilitate experimentation with various forms of decision
diagrams. It includes tools to visualize the in-memory data structure and to
export it in common formats, including image formats and dot code.

The many code generators that come with the ADD-Lib allow for its use
in optimizing compilers or code generators [13,14,15,30]. ADDs are used as the
intermediate representation in these applications, taking full advantage of their
optimization potential. From that optimized, and in some cases optimal, rep-
resentation an implementation in many common general-purpose programming
languages can be generated fully automatically. Among the supported languages
are Java, JavaScript, C, C++. The generated code implements the represented
function in the form of a goto-program – a hardly readable but very eﬃcient im-
plementation. This code can then be compiled together with its user application
and allows for rapid evaluation of the ADD’s decision function.

3.1 ADDs for Program Optimization

An easily interchangeable algebraic structure allows for the use of ADDs in many
new domains. We have used them primarily as an intermediate representation
(IR) for program optimization. This concerns:

– Domain-speciﬁc languages that focus on a particular domain, e.g. Ran-
dom Forests [15] or decision rules [13]. Constraining a language to one do-
main allows not only for a mindset-oriented design of the language [30] but
also for a domain-speciﬁc optimization of the programs. For languages that
model decision services based on some predicates, ADDs with a domain-
speciﬁc algebraic structure serve a suitable intermediate representation with
desirable properties: They (i) optimize decision functions, already as part of
the standard algorithms, and they are (ii) compositional, a property that is
desirable also in the input language.

– General-purpose languages. With the right algebraic structure, we were

able to optimize and to compile programs of the exemplary while-language [12].
In fact, this radically new approach allowed us to signiﬁcantly optimize an
iterative Fibonacci implementation – a program that generally appears to
lack optimization potential.

In this paper, we continue with this line of work and we use ADDs as an
intermediate representation for a domain-speciﬁc graphical language that allows
us to combine the power of machine learning with expert knowledge.

4 Augmenting Random Forests with Expert Knowledge

Random Forests are one of the most widely known classiﬁers in machine learn-
ing. With Algebraic Decision Diagrams (ADDs) over three diﬀerent algebraic
structures, we were able to transform the original model into a single aggregated
ADD in a semantics-preserving fashion. With this approach, it is possible to
reduce the model’s running time and also its size quite drastically [15].

Being semantics-preserving, this approach fully inherits the forest’s behavior:
where the forest makes the right decision, we make the right decision and vice
versa. Machine learning methods in general, and Random Forests in particular,
derive their model from a (representative) training dataset and infer some gen-
eralized decision model from it. For new instances, this model is able to make a
decision and, in this sense, generalizes its training dataset.

Heuristic approaches like these are often very successful for problems that are
insuﬃciently understood by humans. While good solutions can be found, these
approaches typically yield little to no insight about the underlying phenomenon.
At the same time no guarantees are given and a machine learned model remains
purely heuristic.

Expert knowledge, on the other hand, can only help if a problem is suﬃciently
understood. Where this is possible, however, it can provide hard guarantees
about the resulting behavior.

The question arises how to combine the advantages of both worlds. A method
is needed to compose information form the two sources. As we have demonstrated
in previous work, ADDs are a suitable data structure for Random Forests [15]
and also for domain-speciﬁc decision services [13,30]. It is only natural to build
upon this and to allow for their composition in yet another domain-speciﬁc
language.

At ﬁrst, this creation of many graphical domain-speciﬁc languages – some-
times for a single use case – may appear overly expensive. However, with state of
the art language development tools [2,27] and meta-modeling frameworks [26,31]
this development has become much cheaper than anticipated.

4.1 Metamodel-based Generation of Collaborative Domain-speciﬁc

Languages

Domain-speciﬁc languages aim at closing the gap between domain knowledge and
technical requirements. Graphical domain-speciﬁc languages (DSLs), in combi-
nation with sophisticated mindset-supporting Development Environments
(mIDE) [30], have proven to be particularly suitable because of their intuitive
usability in many ﬁelds.

In practice, three major bottlenecks aggravate the introduction of mIDEs:

– the enormous development eﬀort for the required domain-speciﬁc languages

and their enclosing mIDE,

– the continuous delivery of enhanced versions of the DSL as a result of lan-

guage evolution, and

– the circuitous manual installation of the graphical modeling tools on each
device and the synchronization between multiple users during collaboration.

However, with the right tools, a meta model-based generation of modeling
tools can meet these challenges. The Cinco SCCE Meta Tooling Suite [26] is
one example that has been designed to overcome the bottleneck of expensive
tool development by providing a holistic, simplicity-driven [24] approach for the
creation of such domain-speciﬁc graphical mIDEs. The main concept of Cinco is
the generation of an entire mIDE from a high-level speciﬁcation of the deﬁned
model structures, functionalities, and the user interface. The semantics of the
speciﬁed modeling language is deﬁned by means of code generators and model
transformations [22].

Besides the natively supported generation of Eclipse-based mIDEs, Cinco
supports the web as an alternative target platform. This is realized in Pyro [31,23],
a tool that uses the very same speciﬁcation to generate an mIDE for the web
that is, in principle, analogous to the Eclipse variant.

A web-based mIDE provides distributed access to a centralized instance of a
model that can be used and edited by multiple users. The generated tool is easily
accessible through a web browser and requires no installation or maintenance by
its users. At the same time the distribution of new, enhanced versions of a DSL
becomes trivial: a server update is immediately available to all users.

Conceptually, Pyro is geared to modern online editors for collaborative work,
like Google Docs, Microsoft Oﬃce 365, or solutions like ShareLaTeX/Overleaf.
In this way, Cinco and Pyro, together, address the three barriers that prevent
the wide use of DSLs: Development becomes cheap, language evolution and
distribution become trivial, and the mIDE could hardly be more accessible to
its users.

4.2 A Graphical Language for Algebraic Decision Diagrams

Our graphical language for Algebraic Decision Diagrams relies on an algebraic
structure, tailored to the aggregation of Random Forests [15]. At the same time,
we aim to conform to the mindset of an expert and to allow for manual adapta-
tions of the resulting decision model. The goal is the creation of a sophisticated
tool for the machine learning domain with relatively little eﬀort.

Random Forests [6,16] are a widely-known classiﬁer in machine learning.
They are easy to understand, implement, and at the same time very successful
in many domains. The ensemble consists of a multitude of decision trees, which
are constructed from a training dataset. Each decision tree evaluates diﬀerent
predicates based on given features and results in leaf nodes representing the
voted category. The task of classiﬁcation is realized by summing up the votes
for each tree in the forest and deciding for the most frequent one. In contrast to
decision trees, Random Forests do not overﬁt on their training dataset [6].

However, being a purely heuristic method, no guarantees about the decision
model’s behavior can be given. To address this issue, we will improve the classiﬁ-
cation prediction through the composition with other manually created decision
models, i.e. ADDs. This composition of Random Forests with expert knowledge
will allow to enforce at least some guarantees and, in this sense, regain control
over the prediction behavior.

Our domain-speciﬁc language builds upon the experience in [14,30]. The mod-

eling languages are threefold:

– one model for the declaration of features and categories (also called classes),
– multiple ADD models that, based on predicates over the features, determine

one of the categories as the most likely outcome, and

– one composition model that deﬁnes the aggregation of the individual ADDs.

The underlying algebraic structure of the regarded ADDs is deﬁned as

A := (Rn, +, ∗, norm)
where the co-domain Rn is an n-dimensional vector space and addition + and
multiplication ∗ are deﬁned component-wise. In addition, we deﬁne a normal-
ization on the vectors v = v1, v2, . . . , vn as

norm(v) :=

1
(cid:80)n
i=1 vi

v.

In the context of Random Forests, the aim is to model the frequencies, or
weights, of the possible outcomes, i.e. the categories. Every component of a
vector v ∈ Rn represents the weight of one of the categories.

Declaration of Features and Categories First, to declare the available fea-
tures and categories, a dedicated Declaration language is realized. This language
comprises corresponding node types for Feature and Category. The deﬁnitions
will be referenced in the following languages and serve the purpose of seamless
reuse (see Figure 4 for an example).

Algebraic Decision Diagrams Next, we present our DecisionDiagram lan-
guage (see Figure 5 and 6 for examples.). The abstract syntax is analogous to
the structure of ADDs and consists of node types for Predicate, Result and a
root node type called Function. Moreover, the edge types TrueBranch and False-
Branch are used to connect the nodes.

– The Predicate node type corresponds to the inner nodes of ADDs. Rather
than limiting ourselves to Boolean variables, we allow for suitable predicates
that compare an input feature against a constant real value. A predicate
node type refers to a Feature node type of the Declaration language. The
value against which the value of the feature is compared, is speciﬁed by an
additional attribute of the Predicate node.

– The Result node type represents the ADD’s terminal node. As our co-domain
is deﬁned as Rn and each entry of the n-dimensional vector corresponds to
a category’s associated weight, the Result node type contains a list of nodes
of type Value which references a Category from the Declaration language.
The weight for a Category can be set as an attribute of Value.

– The TrueBranch and FalseBranch edge types are used to connect Predicate
nodes to others of the same kind and also to the Result nodes. By the use
of connection constraints, a Predicate node has exactly one TrueBranch, one
FalseBranch successor, and at least one incoming edge. Result node type,
on the other hand, allow no outgoing edges, similar to the terminals of an
ADD.

– The Function node type points to the root of an ADD and assigns a name
to it which enables the possibility of referencing ADDs and composing them
as deﬁned in the following Calculation language.

Composition of Algebraic Decision Diagrams The composition of multiple
algebraic decision diagrams is realized by the Calculation language combining
references to decision diagrams and mathematical operations (see Figure 7 for
an example). The Calculation language contains a DecisionDiagram node type
which holds a reference to a Function node of the DecisionDiagram MGL. In
addition, diﬀerent calculation node types are deﬁned to realize mathematical op-
erations like Addition, Subtraction, Division and Multiplication. To diﬀerentiate
between associative and none associative operators, two corresponding abstract
node types are speciﬁed supporting dedicated edge connection constraints. As-
sociative operator sub node types have two incoming SingleParameter edges,
whereas none associative sub node types have one LeftParameter and one Right-
Parameter incoming edge. This restriction will be enforced by generated valida-
tors in the running tool.

1 import " declaration . mgl " as dec
2 graphModel DecisionDiagram {
3

c o n t a i na b l e E l e m e nt s ( Function [ 1 ,*] , Predicate , Result [ 1 ,*])
node Function {

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24
25 }

attr EString as name
outgoingEdges ( TrueBranch [ 1 ,1 ])

}
node Predicate {

prime dec :: Feature as feature
attr EFloat as value
outgoingEdges ( FalseBranch [ 1 ,1 ] , TrueBranch [ 1 ,1 ])
incomingEdges ( Branch [ 1 ,*])

}
container Result {

incomingEdges ( Branch [ 1 ,*])
c o n t a in a b l e E l e m e nt s ( Value [ 0 ,*])

}
node Value {

prime dec :: Category as category
attr EFloat as value

}
abstract edge Branch {}
edge TrueBranch extends Branch {}
edge FalseBranch extends Branch {}

Fig. 3. Abstract syntax of the DSL for decision diagrams (DecisionDiagram.mgl).

It is possible to generate code from the graphical models, e.g. to utilize com-
posed ADDs for the evaluation of input data or to visualize the composed ADDs.
This transformation is realized by ﬁrst creating ADDs with the ADD-Lib from
the graphical models. As the ADD-Lib already provides numerous code genera-
tors for diﬀerent target languages, these can simply be invoked.

Realization in Cinco and Pyro The abstract syntax of our three graphical
languages is deﬁned with the Meta Graph Language (MGL) of Cinco. The MGL
for the DecisionDiagram language is displayed in Listing 3 which highlights how
the previous node and edge types as well as their attributes are deﬁned. As
the Predicate node type references a node of type Feature and the Value node
type references a node of type Category, the Declaration MGL has to be im-
ported (see Line 1, 9 and 19). Already in the MGL static semantics such as edge
constraints can be speciﬁed where Cinco automatically generates corresponding
validations in the modeling environment. Result is of type container as it can
contain multiple nodes of type Value.

From the short description of the graph syntax, we are able to generate a
mindset-supporting Development Environment (mIDE) [30] fully automatically.
This generative approach is the crucial enabler for the development of domain-
speciﬁc languages. Only with their development being as easy and cheap as this,
domain-speciﬁc languages as focused as the ones discussed in this paper can
eventually pay oﬀ.

Fig. 4. Iris ﬂower declared features and categories.

4.3 Introducing Expert Knowledge with our Web mIDE

In this section, we use the newly created domain-speciﬁc language (Sec. 4.2)
for ADDs to incorporate expert knowledge into a machine-learned model. The
example of a Random Forest, that was trained on the popular Iris dataset [10],
serves a subject throughout the remainder of this paper.

The demonstration of our graphical language is structured as follows:

– We ﬁrst see how three learned decision trees from the Iris data set can be

represented as ADDs within our graphical modeling tool.

– We will then create an ADD by hand which contains knowledge of a domain

expert.

– Finally, we aggregate the three learned decision trees into one semantic pre-
serving ADD and then aggregate this ADD with the ADD-Lib, which was
created by hand into one ﬁnal ADD. This ﬁnal ADD represents a Random
Forest representing knowledge from both the learned decision tree and the
domain expert.

Random Forest Transformation to ADD Models A Random Forest is
trained on a dataset, the Iris dataset [10] in this case. The dataset lists dimen-
sions of Iris ﬂowers’ sepals and petals for three diﬀerent species. As a result
all predicates in the forest reason about these features in the sense that they
compare them against a constant threshold.

The number of individual trees in a Random Forest is, in principle, not
limited. For illustration purposes, we choose a small size of only three trees.
Note, however, that neither the Random Forest nor our aggregation is limited to
such a small number. In fact, we were able to aggregate extremely large forests
with up to 10,000 trees [15].

With trees being structurally similar to decision diagrams of our language,
their transformation is straightforward. In fact, decision trees constitute a subset
of our modeling language.

Fig. 5. Learned and imported decision diagram

The Iris ﬂower example declaration model and three learned trees can be
created using the Create Iris context menu action available on a Declaration
model instance in the running IDE. The declaration model (see Fig. 4) contains
instances of the prior deﬁned Feature and Category node types.

The created feature and category nodes are used to deﬁne predicates and
result nodes of the ADDs as instance of the Decision Diagram DSL. As a result
of this, the imported ADDs (see Fig. 5), which have been learned and extracted
from the Random Forest refer to the deﬁned features and categories. These
three learned decision trees represent a Random Forest learned from the Iris
ﬂower data set. They are similar in size and the leaf nodes contain exactly one
class weight which is set to 1 while all other class weights are set to 0. The class
weight set to 1 represents the predicted class of the original decision tree.

Aggregation with Composition Models As a next step, the DecisionDia-
gram DSL can be used to create an additional decision diagram, based on the
same feature declaration. In contrast to the decision trees displayed in Figure 5,
the decision diagram in Figure 6 was not learned but created manually by a
domain expert, i.e. a non-programmer with extensive knowledge of the domain,
in this case the Iris ﬂowers.

Assume, that this domain expert cares particularly about the Iris species
Setosa. He or she may model, e.g. the decision diagram that has one path which
leads to a leaf and ensures that the Setosa ﬂower is chosen as the predicted
class. For this reason the class weight of Setosa is set to 8 while the remaining
class weights are set to 0. This single decision diagram in this case inﬂuences
the predicted class in the same way 8 decision trees would. In all other cases the
reached leaf contains class weights which are set to 0 which can be interpreted
as cases which we do not want to aﬀect.

The learned decision trees in Figure 5 and the manually created decision
diagram in Figure 6 are now composed into one ADD in order to include the

Fig. 6. Manually created ADD enforces expert knowledge about Iris Setosa.

expert knowledge represented by the manually created ADD into the Random
Forest. This composition in Figure 7 can be divided into three parts. First,
the three learned decision trees are aggregated into one ADD which in essence
represents the Random Forest consisting of these three single decision trees. The
aggregation is realized by the + operation, i.e. component-wise addition of two
class vectors, which is then lifted to the ADD.

Next, the class weights of the aggregated ADD are normalized by applying the
monadic norm operation (Sec. 4.2) which transforms the absolute class weights
to relative values in the interval [0, 1].

Finally, the normalization of the aggregated ADD is aggregated together with
the manually created ADD resulting in the ﬁnal ADD. As the class weights of
the aggregated ADD, resulting from the three learned ADDs, are normalized
values between 0 and 1, the decision of the manually created ADD is weighted
much stronger. The class weight of the Setosa category is set to 8 in one of
the leafs of the manually created ADD which ensures that if the features’ input
values are such that the path to the leaf is traversed, the predicted category in
the ﬁnal aggregated ADD will also be the Setosa category.

As mentioned, the ADD-Lib provides various code generation for diﬀerent
target languages. An automatically generated visualization for the ﬁnal aggre-
gated ADD is displayed in Figure 8.

The underlying code generators all rely on ADDs as their intermediate rep-
resentation. Decision functions are automatically optimized by the properties
of ADDs and allow for straightforward code generation. Only the transforma-
tion from models of the input language to the ADDs must be addressed. For
the graphical languages in this example the transformation is straightforward
along the acyclic structure of the models. All complexity is delegated to the
ADD-Lib’s core where well-studied and eﬃcient ADD algorithms perform the
transformation in a service-oriented fashion.

Fig. 7. Composition of the three learned ADDs and the manually created ADD.

Fig. 8. The ﬁnal aggregated ADD.

Besides generating code for visualization purposes, the code generators can
also be used to generate an implementation of the represented function in various
general-purpose programming languages. In our example, we use this to generate
a JavaScript implementation fully automatically. The generated code can then be
embedded in a web application that, in this case, provides a graphical interface
for the evaluation of test data.

Given the four features sepal length, sepal width, petal length and petal
width as input, the generated tool uses the ADD to predict the ﬂower category.

5 Conclusion

We have presented the ADD-Lib, our eﬃcient and easy to use algebraic frame-
work for dealing with decision diagrams. Characteristic for ADD-Lib is its ease
and ﬂexibility, which arise at two levels: the level of individual ADD-tools, which
come with a dedicated user-friendly Web-based graphical user interface, and at
the meta level, where such tools are speciﬁed. We have illustrated the meta level
by explaining how we can construct an ADD-tool tailored for Random Forest
reﬁnement and evaluation. The according automatically generated Web-based
domain-speciﬁc tool for Random Forest reﬁnement and evaluation is provided
as an artifact for readers to reply the development of Section 4, and to combine

given Random Forests with their own ADDs regarded as expert knowledge and
to experience the corresponding eﬀect.

The kernel ADD-Lib, as well as the Cinco and the Pyro frameworks are open
source but not yet presented as a dedicated homogeneous artifact. Thus readers
could, in principle, also replay our meta-level development. This may, however,
be quite hard for newcomers. We are therefore planning to develop a dedicated
domain-speciﬁc meta tool for this purpose.

References

1. The java library for algebraic decision diagrams. https://add-lib.scce.info/,

accessed: 2019-09-04

2. Xtext - language engineering made easy! https://www.eclipse.org/Xtext/, ac-

cessed: 2019-10-25

3. Akers, S.B.: Binary decision diagrams. IEEE Trans. Comput. 27(6), 509–516 (Jun
1978). https://doi.org/10.1109/TC.1978.1675141, https://doi.org/10.1109/TC.
1978.1675141

4. Brace, K.S., Rudell, R.L., Bryant, R.E.: Eﬃcient implementation of a bdd package.

In: 27th ACM/IEEE Design Automation Conference (1990)

5. Brayton, R.K., Hachtel, G.D., McMullen, C., Sangiovanni-Vincentelli, A.: Logic
minimization algorithms for VLSI synthesis, vol. 2. Springer Science & Business
Media (1984)

6. Breiman, L.: Random forests. Machine Learning 45(1) (2001)
7. Bryant: Graph-based
IEEE Transactions
https://doi.org/10.1109/TC.1986.1676819

boolean
on Computers C-35(8),

algorithms

for

function manipulation.
1986).
(Aug
677–691

8. Bryant, R.E.: Chain reduction for binary and zero-suppressed decision diagrams.
In: Beyer, D., Huisman, M. (eds.) Tools and Algorithms for the Construction and
Analysis of Systems. pp. 81–98. Springer International Publishing, Cham (2018)
9. Burch, J., Clarke, E., McMillan, K., Dill, D., Hwang, L.: Symbolic model check-
ing: 1020 states and beyond. Information and Computation 98(2), 142 – 170
(1992). https://doi.org/https://doi.org/10.1016/0890-5401(92)90017-A, http://
www.sciencedirect.com/science/article/pii/089054019290017A

10. Fisher, R.A.: The use of multiple measurements in taxonomic problems. Annals of

Eugenics 7(7), 179–188 (1936)

11. Fujita, M., McGeer, P., Yang, J.Y.: Multi-terminal binary decision diagrams:
An eﬃcient data structure for matrix representation. Formal Methods in Sys-
tem Design 10(2), 149–169 (Apr 1997). https://doi.org/10.1023/A:1008647823331,
https://doi.org/10.1023/A:1008647823331

12. Gossen, F., Jasper, M., Murtovi, A., Steﬀen, B.: Aggressive aggregation: a new

paradigm for program optimization, under Submission

13. Gossen, F., Margaria, T.: Generating real-time decision systems with the new

miaamics. Electronic Communications of the EASST 74 (2018)

14. Gossen, F., Margaria, T., Murtovi, A., Naujokat, S., Steﬀen, B.: Dsls for decision
services: A tutorial introduction to language-driven engineering. In: Leveraging Ap-
plications of Formal Methods, Veriﬁcation and Validation. Modeling - 8th Interna-
tional Symposium, ISoLA 2018, Limassol, Cyprus, November 5-9, 2018, Proceed-
ings, Part I. pp. 546–564 (2018). https://doi.org/10.1007/978-3-030-03418-4 33,
https://doi.org/10.1007/978-3-030-03418-4_33

15. Gossen, F., Steﬀen, B.: Large random forests: Optimisation for rapid evaluation,

under Submission

16. Ho, T.K.: Random decision forests. In: Proceedings of the Third International
Conference on Document Analysis and Recognition (Volume 1) - Volume 1. ICDAR
’95, IEEE Computer Society, Washington, DC, USA (1995)

17. Hoey, J., St-Aubin, R., Hu, A., Boutilier, C.: Spudd: Stochastic planning using
decision diagrams. In: Proceedings of the Fifteenth Conference on Uncertainty in
Artiﬁcial Intelligence. pp. 279–288. UAI’99, Morgan Kaufmann Publishers Inc.,
San Francisco, CA, USA (1999), http://dl.acm.org/citation.cfm?id=2073796.
2073828

18. Kuehlmann, A., Paruthi, V., Krohm, F., Ganai, M.K.: Robust boolean reasoning
for equivalence checking and functional property veriﬁcation. IEEE Transactions
on Computer-Aided Design of Integrated Circuits and Systems 21(12), 1377–1394
(Dec 2002). https://doi.org/10.1109/TCAD.2002.804386

19. Kwiatkowska, M., Norman, G., Parker, D.: Prism: Probabilistic symbolic model
checker. In: Field, T., Harrison, P.G., Bradley, J., Harder, U. (eds.) Computer
Performance Evaluation: Modelling Techniques and Tools. pp. 200–204. Springer
Berlin Heidelberg, Berlin, Heidelberg (2002)

20. Lee, C.Y.: Representation of

switching circuits by binary-decision pro-
grams. The Bell System Technical Journal 38(4), 985–999 (July 1959).
https://doi.org/10.1002/j.1538-7305.1959.tb01585.x

21. Lv, G., Su, K., Xu, Y.: Cacbdd: A bdd package with dynamic cache manage-
ment. In: Sharygina, N., Veith, H. (eds.) Computer Aided Veriﬁcation. pp. 229–234.
Springer Berlin Heidelberg, Berlin, Heidelberg (2013)
22. Lybecait, M., Kopetzki, D., Steﬀen, B.: Design for

through model
transformation.
In: Leveraging Applications of Formal Methods, Veriﬁca-
tion and Validation. Modeling - 8th International Symposium, ISoLA 2018,
Limassol, Cyprus, November 5-9, 2018, Proceedings, Part
I. pp. 381–
398 (2018). https://doi.org/10.1007/978-3-030-03418-4 23, https://doi.org/10.
1007/978-3-030-03418-4_23

’x’

23. Lybecait, M., Kopetzki, D., Zweihoﬀ, P., Fuhge, A., Naujokat, S., Steﬀen, B.:
A tutorial introduction to graphical modeling and metamodeling with cinco. In:
International Symposium on Leveraging Applications of Formal Methods. pp. 519–
538. Springer (2018)

24. Margaria, T., Steﬀen, B.: Simplicity as a Driver for Agile Innovation. Computer

43(6), 90–92 (2010). https://doi.org/10.1109/MC.2010.177

25. Minato, S.: Zero-suppressed bdds for set manipulation in combinatorial problems.

In: 30th ACM/IEEE Design Automation Conference. pp. 272–277 (1993)

26. Naujokat, S., Lybecait, M., Kopetzki, D., Steﬀen, B.: CINCO: a simplicity-driven
approach to full generation of domain-speciﬁc graphical modeling tools. STTT
20(3), 327–354 (2018). https://doi.org/10.1007/s10009-017-0453-6, https://doi.
org/10.1007/s10009-017-0453-6

27. Parr, T.: The deﬁnitive ANTLR 4 reference. Pragmatic Bookshelf (2013)
28. R. Iris Bahar, Erica A. Frohm, C.M.G.G.D.H.E.M.A.P.F.S.: Algebraic decision dia-
grams and their applications. In: Proceedings of the 1993 IEEE/ACM International
Conference on Computer-aided Design. IEEE Computer Society Press (1993)
29. Somenzi, F.: Eﬃcient manipulation of decision diagrams. International Journal on

Software Tools for Technology Transfer 3(2) (2001)

30. Steﬀen, B., Gossen, F., Naujokat, S., Margaria, T.: Language-driven en-
gineering: From general-purpose to purpose-speciﬁc languages. In: Comput-

ing and Software Science - State of the Art and Perspectives, pp. 311–
344 (2019). https://doi.org/10.1007/978-3-319-91908-9 17, https://doi.org/10.
1007/978-3-319-91908-9_17

31. Zweihoﬀ, P., Naujokat, S., Steﬀen, B.: Pyro: Generating domain-speciﬁc col-
laborative online modeling environments. In: Fundamental Approaches to Soft-
ware Engineering - 22nd International Conference, FASE 2019, Held as Part of
the European Joint Conferences on Theory and Practice of Software, ETAPS
2019, Prague, Czech Republic, April 6-11, 2019, Proceedings. pp. 101–115
(2019). https://doi.org/10.1007/978-3-030-16722-6 6, https://doi.org/10.1007/
978-3-030-16722-6_6

