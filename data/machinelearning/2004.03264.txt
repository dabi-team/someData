Inspector Gadget: A Data Programming-based Labeling System
for Industrial Images

Geon Heo, Yuji Roh, Seonghyeon Hwang, Dayun Lee, Steven Euijong Whang
Korea Advanced Institute of Science and Technology
Daejeon, Republic of Korea
{geon.heo,yuji.roh,sh.hwang,dayun.lee,swhang}@kaist.ac.kr

0
2
0
2

g
u
A
1
2

]

G
L
.
s
c
[

3
v
4
6
2
3
0
.
4
0
0
2
:
v
i
X
r
a

ABSTRACT
As machine learning for images becomes democratized in the Soft-
ware 2.0 era, one of the serious bottlenecks is securing enough
labeled data for training. This problem is especially critical in a
manufacturing setting where smart factories rely on machine learn-
ing for product quality control by analyzing industrial images. Such
images are typically large and may only need to be partially ana-
lyzed where only a small portion is problematic (e.g., identifying
defects on a surface). Since manual labeling these images is expen-
sive, weak supervision is an attractive alternative where the idea is
to generate weak labels that are not perfect, but can be produced
at scale. Data programming is a recent paradigm in this category
where it uses human knowledge in the form of labeling functions
and combines them into a generative model. Data programming has
been successful in applications based on text or structured data and
can also be applied to images usually if one can find a way to con-
vert them into structured data. In this work, we expand the horizon
of data programming by directly applying it to images without this
conversion, which is a common scenario for industrial applications.
We propose Inspector Gadget, an image labeling system that com-
bines crowdsourcing, data augmentation, and data programming to
produce weak labels at scale for image classification. We perform
experiments on real industrial image datasets and show that Inspec-
tor Gadget obtains better performance than other weak-labeling
techniques: Snuba, GOGGLES, and self-learning baselines using
convolutional neural networks (CNNs) without pre-training.

1 INTRODUCTION
In the era of Software 2.0, machine learning techniques for images
are becoming democratized where the applications range from man-
ufacturing to medical. For example, smart factories regularly use
computer vision techniques to classify defective and non-defective
product images [26]. In medical applications, MRI scans are ana-
lyzed to identify diseases like cancer [22]. However, many compa-
nies are still reluctant to adapt machine learning due to the lack of
labeled data where manual labeling is simply too expensive [37].
We focus on the problem of scalable labeling for classification
where large images are partially analyzed, and there are few or no
labels to start with. Although many companies face this problem,
it has not been studied enough. Based on a collaboration with a
large manufacturing company, we provide the following running
example. Suppose there is a smart factory application where product
images are analyzed for quality control (Figure 1). These images
taken from industrial cameras usually have high-resolution. The
goal is to look at each image and tell if there are certain defects (e.g.,
identify scratches, bubbles, and stampings). For convenience, we
hereafter use the term defect to mean a part of an image of interest.

Figure 1: Labeling industrial images with Inspector Gadget
in a smart factory application.

A conventional solution is to collect enough labels manually
and train say a convolutional neural network on the training data.
However, fully relying on crowdsourcing for image labeling can
be too expensive. In our application, we have heard of domain
experts demanding six-figure salaries, which makes it infeasible to
simply ask them to label images. In addition, relying on general
crowdsourcing platforms like Amazon Mechanical Turk may not
guarantee high-enough labeling quality.

Among the possible methods for data labeling (see an extensive
survey [31]), weak supervision is an important branch of research
where the idea is to semi-automatically generate labels that are not
perfect like manual ones. Thus, these generated labels are called
weak labels, but they have reasonable quality where the quantity
compensates for the quality. Data programming [29] is a represen-
tative weak supervision technique of employing humans to develop
labeling functions (LFs) that individually perform labeling (e.g.,
identify a person riding a bike), perhaps not accurately. However,
the combination of inaccurate LFs into a generative model results
in probabilistic labels with reasonable quality. These weak labels
can then be used to train an end discriminative model.

So far, data programming has been shown to be effective in
finding various relationships in text and structured data [28]. Data
programming has also been successfully applied to images where
they are usually converted to structured data beforehand [40, 42].
However, this conversion limits the applicability of data program-
ming. As an alternative approach, GOGGLES [9] demonstrates that,
on images, automatic approaches using pre-trained models may be
more effective. Here the idea is to extract semantic prototypes of
images using the pre-trained model and then cluster and label the
images using the prototypes. However, GOGGLES also has limita-
tions (see Section 6.2), and it is not clear if it is the only solution
for generating training data for image classification.

We thus propose Inspector Gadget, which opens up a new class
of problems for data programming by enabling direct image label-
ing at scale without the need to convert to structured data using a

Inspector GadgetEnd ModelSmart FactoryDefectOKWeakLabelsUnlabeled 
 
 
 
 
 
combination of crowdsourcing, data augmentation, and data pro-
gramming techniques. Inspector Gadget provides a crowdsourcing
workflow where workers identify patterns that indicate defects.
Here we make the tasks easy enough for non-experts to contribute.
These patterns are augmented using general adversarial networks
(GANs) [13] and policies [7]. Each pattern effectively becomes a
labeling function by being matched with other images. The simi-
larities are then used as features to train a multi-layer perceptron
(MLP), which generates weak labels.

In our experiments, Inspector Gadget performs better overall
than state-of-the-art methods: Snuba, GOGGLES, and self-learning
baselines that use CNNs (VGG-19 [35] and MobileNetV2 [32]) with-
out pre-training. We release our code as a community resource [1].

In the rest of the paper, we present the following:
• The architecture of Inspector Gadget (Section 2).
• The component details of Inspector Gadget:

• Crowdsourcing workflow for helping workers identify pat-

terns (Section 3).

• Pattern augmenter for expanding the patterns using GANs

and policies (Section 4).

• Feature generator and labeler for generating similarity fea-

tures and producing weak labels (Section 5).

• Experimental results where Inspector Gadget outperforms other
image labeling techniques – Snuba, GOGGLES, and self-learning
baselines using CNNs – where there are few or no labels to start
with (Section 6).

2 OVERVIEW
The main technical contribution of Inspector Gadget is its effective
combination of crowdsourcing, data augmentation, and data pro-
gramming for scalable image labeling for classification. Figure 2
shows the overall process of Inspector Gadget. First, a crowdsourc-
ing workflow helps workers identify patterns of interest from im-
ages that may indicate defects. While the patterns are informative,
they may not be enough and are thus augmented using generative
adversarial networks (GANs) [13] and policies [8]. Each pattern
effectively becomes a labeling function where it is compared with
other images to produce similarities that indicate whether the im-
ages contain defects. A separate development set is used to train a
small model that uses the similarity outputs as features. This model
is then used to generate weak labels of images indicating the defect
types in the test set. Figure 3 shows the architecture of the Inspector
Gadget system. After training the Labeler, Inspector Gadget only
utilizes the components highlighted in gray for generating weak
labels. In the following sections, we describe each component in
more detail.

3 CROWDSOURCING WORKFLOW
Since collecting enough labels on the entire images are too expen-
sive, we would like to utilize human knowledge as much as possible
and reduce the additional amount of labeled data. We propose a
crowdsourcing workflow shown in Figure 4. First, the workers mark
defects using bounding boxes through a UI. Since the workers are

Geon Heo, Yuji Roh, Seonghyeon Hwang, Dayun Lee, Steven Euijong Whang

Figure 2: An overview of how Inspector Gadget constructs a
model (labeler) that generates weak labels.

Figure 3: The architecture of Inspector Gadget.

not necessarily experts, the UI educates them how to identify de-
fects beforehand. The bounding boxes in turn become the patterns
we use to find other defects. Figure 5 shows sample images of a
real-world smart factory dataset (called Product; see Section 6.1 for
a description) where defects are highlighted with red boxes. Notice
that the defects are not easy to find as they are small and mixed
with other parts of the product.

As with any crowdsourcing application, we may run into quality
control issues where the bounding boxes of the workers vary even
for the same defect. Inspector Gadget addresses this problem by
first combining overlapping bounding boxes together. While there
are several ways to combine boxes, we find that averaging their
coordinates works reasonably well. The two other strategies we
considered were to take the “union” of coordinates (i.e., find the
coordinates that cover the overlapping boxes), or take the “inter-
section” of coordinates (i.e., find the coordinates for the common
parts of the boxes). However, the union strategy tends to generate
patterns that are too large, while the intersection strategy has the
opposite problem of generating tiny patterns. Hence, we only use
the average strategy in our experiments. For the remaining outlier
boxes, Inspector Gadget goes through a peer review phase where
workers discuss which ones really contain defects. In Section 6.3,
we perform ablation tests to show how each of these steps helps
improve the quality of patterns.

Another challenge is determining how many images must be
annotated to generate enough patterns. In general, we may not
have statistics on the portion of images that have defects. Hence,
our solution is to randomly select images and annotate them un-
til the number of defective images exceeds a given threshold. In
our experiments, identifying tens of defective images is sufficient

ImagesIdentify PatternsAugmentDev. Set ImagesMatching patterns1.00.50.50.500LabelerFeaturesAuto tuneCrowdsourcing WorkflowPattern AugmenterFeature GeneratorImages & Dev. LabelsPatternsLabelerInspector GadgetUnlabeledImagesWeak LabelsInspector Gadget: A Data Programming-based Labeling System for Industrial Images

Figure 4: The crowdsourcing workflow of Inspector Gadget. Crowd workers can interact with a UI and provide bounding boxes
that identify defects. The boxes are used as patterns, which are combined or go through a peer review phase.

4.1 GAN-based Augmentation
The first method is to use generative adversarial networks (GAN)
to generate variations of patterns that are similar to the existing
ones. Intuitively, these augmented patterns can fill in the gaps of
the existing patterns. The original GAN [13] trains a generator to
produce realistic fake data where the goal is to deceive a discrimi-
nator that tries to distinguish the real and fake data. More recently,
many variations have been proposed (see a recent survey [43]).

We use a Relativistic GAN (RGAN) [19], which can efficiently
generate more realistic patterns than the original GAN. The formu-
lation of RGAN is:

max
D
max
G

E(xr ,G(z))∼(P,Q)[log(σ (D(xr ) − D(G(z))))]
E(xr ,G(z))∼(P,Q)[log(σ (D(G(z)) − D(xr )))]

where G is the generator, xr is real data, D(x) is the probability that
x is real, z is a random noise vector that is used by G to generate
various fake data, and σ is the sigmoid function. While training,
the discriminator of RGAN not only distinguishes data, but also
tries to maximize the difference between two probabilities: the
probability that a real image is actually real, and the probability
that a fake image is actually fake. This setup enforces fake images
to be more realistic, in addition to simply being distinguishable
from real images as in the original GAN. We also use Spectral
Normalization [24], which is a commonly-used technique applied
to a neural network structure where the discriminator restricts the
gradient to adjust the training speed for better training stability.

Another issue is that neural networks assume a fixed size and
shape of its inputs. While this assumption is reasonable for a ho-
mogeneous set of images, the patterns may have different shapes.
We thus fit patterns to a fixed-sized square shape by resizing them
before augmentation. Then we re-adjust new patterns into one of
the original sizes in order to properly find other defects. Figure 6
shows the entire process applied to an image. In Section 6.4, we
show that the re-sizing of patterns is effective in practice.

4.2 Policy-based Augmentation
Policies [7] have been proposed as another way to augment images
and complement the GAN approach. The idea is to use manual
policies to decide how exactly an image is varied. Figure 7 shows
the results of applying four example policies on a surface defect
from the KSDD dataset (see description in Section 6.1). Policy-based
augmentation is effective for patterns where applying operations
based on human knowledge may result in quite different, but valid
patterns. For example, if a defect is line-shaped, then it makes sense

Figure 5: Sample images in the Product dataset (see Sec-
tion 6.1) containing scratch, bubble, and stamping defects
where we highlight each defect with a bounding box.

(see the N D
values in Table 1). All the annotated images form a
V
development set, which we use in later steps for training the labeler.
The crowdsourcing workflow can possibly be automated using
pre-trained region proposal networks (RPNs) [30]. However, this
approach requires other training data with similar defects and
bounding boxes, which seldom exist for our applications.

4 PATTERN AUGMENTER
Pattern augmentation is a way to compensate for the possible lack
of patterns even after using crowdsourcing. The patterns can be
lacking if not enough human work is done to identify all possible
patterns and especially if there are not enough images containing
defects (i.e., there is a class imbalance) so one has to go through
many images just to encounter a negative label. We would thus like
to automatically generate more patterns without resorting to more
expensive crowdsourcing.

We consider two types of augmentation – GAN-based [13] and
policy-based [7]. The two methods complement each other and
have been used together in medical applications for identifying le-
sions [11]. GAN-based augmentation is good at generating random
variations of existing defects that do not deviate significantly. On
the other hand, policy-based augmentation is better for generating
specific variations of defects that can be quite different, exploiting
domain knowledge. In Section 6.4, we show that neither augmen-
tation subsumes the other, and the two can be used together to
produce the best results.

The augmentation can be done efficiently because we are aug-
menting small patterns instead of the entire images. For high-
resolution images, it is sometimes infeasible to train a GAN at
all. In addition, if most of the image is not of interest for analysis, it
is difficult to generate fake parts of interest while leaving the rest of
the image as is. By only focusing on augmenting small patterns, it
becomes practical to apply sophisticated augmentation techniques.

UIDefect MarkingsOverlappingOutliersCombinePeer ReviewFinal Patterns Candidate PatternsCrowdsourcing WorkflowImagesPatterns & Dev. LabelsGeon Heo, Yuji Roh, Seonghyeon Hwang, Dayun Lee, Steven Euijong Whang

patterns. Notice that the output of an FGF is different than a con-
ventional labeling function in data programming where the latter
returns a weak label per image. A vector that consists of all output
values of the FGFs on each image is used as the input of the labeler.
Depending on the type of defect, the pattern matching may differ.
A naïve approach is to do an exact pixel-by-pixel comparison, but
this is unrealistic when the defects have variations. Instead, a better
way is to compare the distributions of pixel values. This comparison
is more robust to slight variations of a pattern. On the other hand,
there may be false positives where an obviously different defect
matches just because its pixels have similar distributions. In our
experiments, we found that comparing distributions on the x and y
axes using normalized cross correlation [2] is effective in reducing
such false positives. Given an image I with pixel dimensions W × H
and pattern Pi with dimensions w × h, the ith FGF fi is defined as:

Figure 6: GAN-based augmentation on a pattern containing
a scratch defect from the Product dataset.

fi (I ) = max
x,y

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:205)

x ′,y′ Pi (x ′, y ′) · I (x + x ′, y + y ′)

(cid:113)(cid:205)

x ′,y′ Pi (x ′, y ′)2 · (cid:205)

x ′,y′I (x + x ′, y + y ′)2

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

Figure 7: Policy-based augmentation on a pattern with a
crack defect from the KSDD dataset (see Section 6.1). For each
augmentation, we show the operation and magnitude.

to stretch or rotate it. There are two parameters to configure: the
operation to use and the magnitude of applying that operation.
Recently, policy-based techniques have become more automated,
e.g., AutoAugment [7] uses reinforcement learning to decide to
what extent can policies be applied together.

We use an simpler approach than AutoAugment. Among certain
combinations of policies, we choose the ones that work best on the
development set. We first split the development set into train and
test sets. For each policy, we specify a range for the magnitudes
and choose 10 random values within that range. We then iterate all
combinations of three policies. For each combination, we augment
the patterns in the train set using the 10 magnitudes and train
a model (see details in Section 5) on the train set images until
convergence. Then we evaluate the model on the separate test
set. Finally, we use the policy combination that results in the best
accuracy and apply it to the entire set of patterns.

5 WEAK LABEL GENERATION
Once Inspector Gadget gathers patterns and augments them, the
next step is to generate features of images (also called primitives
according to Snuba [41]) and train a model that can produce weak
labels. Note that the way we generate features of images is more
direct than existing data programming systems that first convert
images to structured data with interpretable features using object
detection (e.g., identify a vehicle) before applying labeling functions.

5.1 Feature Generator
Inspector Gadget provides feature generation functions (FGFs) that
match all generated patterns with the new input image to identify
similar defects on any location and return the similarities with the

where 0 ≤ x < W − w, 0 ≤ y < H − h, 0 ≤ x ′ < w, and 0 ≤ y ′ <
h. When matching a pattern against an image, a straightforward
approach is to make a comparison with every possible region of the
same size in the image. However, scanning the entire image may be
too time consuming. Instead, we use a pyramid method [3] where
we first search for candidate parts of an image by reducing the
resolutions of the image and pattern and performing a comparison
quickly. Then just for the candidates, we perform a comparison
using the full resolution.

5.2 Labeler
After the features are generated, Inspector Gadget trains a model
on the output similarities of the FGFs, where the goal is to produce
weak labels. The model can have any architecture and be small
because there are not as many features as say the number of pixels
in an image. We use a multilayer perceptron (MLP) because it is
simple, but also has good performance compared to other models.
An interesting observation is that, depending on the model archi-
tecture (e.g., the number of layers in an MLP), the model accuracy
can vary significantly as we demonstrate in Section 6.5. Inspector
Gadget thus performs model tuning where it chooses the architec-
ture that has the best accuracy results on the development set. This
feature is powerful compared to existing CNN approaches where
the architecture is complicated, and it is too expensive to consider
other variations.

The labeling process after training the labeler consists of two
steps. First, the patterns are matched to unlabeled images for gen-
erating the features. Second, the trained labeler is applied on the
features to make a prediction for each unlabeled image. We note
that latency is not the most critical issue because we are generating
weak labels, which are used to construct the training data for the
end discriminative model. Training data construction is usually
done in batch mode instead of say real time.

Image resizeReal PatternFake PatternImage resizeGANTrainGen.ResizeResizeOriginalBrightness, 1.632Invert, 0.246ResizeX, 0.872Rotate, 7.000Inspector Gadget: A Data Programming-based Labeling System for Industrial Images

Table 1: For each of the five datasets, we show the image size, the dataset size(N ) and number of defective images(N D ), the
development set size(NV ) and number of defective images within it(N D

V ), the types of defects detected, and the task type.

Dataset
KSDD [38]

Image size

500 x 1257

N (N D )
399 (52)

Product (scratch)

Product (bubble)

162 x 2702

1673 (727)

77 x 1389

1048 (102)

Product (stamping)

161 x 5278

1094 (148)

NV (N D
V )
78 (10)

170 (76)

104 (10)

109 (15)

Defect Type

Task Type

Crack

Scratch

Bubble

Stamping

Binary

Binary

Binary

Binary

NEU [18]

200 x 200

300 per defect

100 per defect

Rolled-in scale, Patches, Crazing,
Pitted surface, Inclusion, Scratch

Multi-class

6 EXPERIMENTS
We evaluate Inspector Gadget on real datasets and answer the
following questions.
• How accurate are the weak labels of Inspector Gadget compared
to other labeling methods and are they useful when training
the end discriminative model?

• How useful is each component of Inspector Gadget?
• What are the errors made by Inspector Gadget?

We implement Inspector Gadget in Python and use the OpenCV
library and three machine learning libraries: Pytorch, TensorFlow,
and Scikit-learn. We use an Intel Xeon CPU to train our MLP models
and an NVidia Titan RTX GPU to train larger CNN models. Other
details can be found in our released code [1].

6.1 Settings

Datasets. We use real datasets for classification tasks. For each
dataset, we construct a development set as described in Section 3.
Table 1 summarizes the datasets with other experimental details,
and Figures 5 and 8 shows samples of them. We note that the results
in Section 6.2 are obtained by varying the size of the development
set, and the rest of the experiments utilize the same size as described
in Table 1. For each dataset, we have a gold standard of labels. Hence,
we are able to compute the accuracy of the labeling on separate
test data.

annotated by the Kolektor Group. There is only one type of
defect – cracks – but each one varies significantly in shape.
• The Product dataset (Figure 5) is proprietary and obtained
through a collaboration with a manufacturing company. Each
product has a circular shape where different strips are spread
into rectangular shapes. There are three types of defects: scratches,
bubbles, and stampings, which occur in different strips. The
scratches vary in length and direction. The bubbles are more
uniform, but have small sizes. The stampings are small and
appear in fixed positions. We divide the dataset into three, as if
there is a separate dataset for each defect type.

• The Northeastern University Surface Defect Database (NEU [18])
contains images that are divided into 6 defect types of surface
defects of hot-rolled steel strips: rolled-in scale, patches, craz-
ing, pitted surface, inclusion, and scratches. Compared to the
other datasets, these defects take larger portions of the images.
Since there are no images without defects, we solve the different
task of multi-class classification where the goal is to determine
which defect is present.

GAN-based Augmentation. We provide more details for Section 4.1.
For all datasets, the input random noise vector has a size of 100,
the learning rates of the generator and discriminator are both 1e−4,
and the number of epochs is about 1K. We fit patterns to a square
shape where the width and height are set to 100 or the averaged
value of all widths and heights of patterns, whichever is smaller.

Labeler Tuning. We use an L-BFGS optimizer [20], which pro-
vides stable training on small data, with a 1e−5 learning rate. We
use k-fold cross validation where each fold has at least 20 examples
per class and early stopping in order to compare the accuracies of
candidate models before they overfit.

(a) KSDD data

(b) NEU data

Figure 8: Sample images in KSDD [38] and NEU [18] datasets
where we highlight the defects with bounding boxes.

• The Kolektor Surface-Defect Dataset (KSDD [38]) is constructed
from images of electrical commutators that were provided and

Accuracy Measure. We use the F1 score, which is the harmonic
mean between precision and recall. Suppose that the set of true
defects is D while the set of predictions is P. Then the precision
Pr = |D∩P |
. While there are
|P |
other possible measures like ROC-AUC, F1 is known to be more
suitable for data where the labels are imbalanced [14] as in most of
our settings.

, and F1 = 2×P r ×Re
P r +Re

, recall Re = |D∩P |
|D |

Systems Compared. We compare Inspector Gadget with other
image labeling systems and self-learning baselines that train CNN
models on available labeled data.

crazinginclusionpatchespitted surfacescratchesrolled-in scaleTable 2: Comparison of VGG-19 F1 scores when pre-trained
on various datasets.

Pre-trained on

Target
Dataset

Product (sc)
Product (bu)
Product (st)
KSDD

Product Product Product
(scratch) (bubble) (stamping) KSDD ImageNet
0.958
0.531
x
0.112

0.942
x
0.810
0.093

0.964
0.453
0.781
x

x
0.535
0.798
0.683

0.972
0.913
0.900
0.897

Snuba [41] automates the process of labeling function (LF) con-
struction by starting from a set of primitives that are analogous to
our FGFs and iteratively selecting subsets of them to train heuristic
models, which becomes the LFs. Each iteration involves compar-
ing models trained on all possible subsets of the primitives up
to a certain size. Finally, the LFs are combined into a generative
model. We faithfully implement Snuba and use our crowdsourced
and augmented patterns for generating primitives, in order to be
favorable to Snuba. However, adding more patterns quickly slows
down Snuba as its runtime is exponential to the number of patterns.
We also compare with GOGGLES [9], which takes the labeling
approach of not using crowdsourcing. However, it relies on the fact
that there is a pre-trained model and extracts semantic prototypes
of images where each prototype represents the part of an image
where the pre-trained model is activated the most. Each image is
assumed to have one object, and GOGGLES clusters similar im-
ages for unsupervised learning. In our experiments, we use the
opensourced code of GOGGLES.

Finally, we compare Inspector Gadget with self-learning [39]
baselines that train CNN models on the development set using
cross validation and use them to label the rest of the images. Note
that when we compare Inspector Gadget with a CNN model, we
are mainly comparing their feature generation abilities. Inspector
Gadget’s features are the pattern similarities while for VGG’s fea-
tures are produced at the end of the convolutional layers. In both
cases, the features go through a final fully-connected layer (i.e.,
MLP). To make a fair comparison, we experiment with both heavy
and light-weight CNN models. For the heavy model, we use VGG-
19 [35], which is widely used in the literature. For the light-weight
model, we use MobileNetV2 [32], which is designed to train effi-
ciently in a mobile setting, but nearly has the performance of heavy
CNNs. We also make a comparison with VGG-19 whose weights
are pre-trained on ImageNet [10] and fine-tuned on each dataset.
An alternative approach is to pre-train VGG-19 on other datasets
in Table 1 instead of ImageNet. To see which approach is better, we
compare the transfer learning results in Table 2. We observe that
combining VGG-19 with ImageNet outperforms the other scenarios
on all target datasets and thus use ImageNet to be favorable to
transfer learning. In addition, we use preprocessing techniques
on images that are favorable for the baselines. For example, the
images from the Product dataset are long rectangles, so we split
each image in half and stack them on top of each other to make
them more square-like, which is advantageous for CNNs.

Geon Heo, Yuji Roh, Seonghyeon Hwang, Dayun Lee, Steven Euijong Whang

6.2 Weak Label Accuracy
We compare the weak label accuracy of Inspector Gadget with the
other methods by increasing the development set size and observing
the F1 scores in Figure 9. To clearly show how Inspector Gadget
compares with other methods, we use a solid line to draw its plot
while using dotted lines for the rest. Among the models that are
not pre-trained (i.e., ignore “TL (VGG19 + Pre-training)” for now),
we observe that Inspector Gadget performs best overall because it
is either the best or second-best method in all figures. This result is
important because industrial images have various defect types that
must all be identified correctly. For KSDD (Figure 9d), Inspector
Gadget performs the best because the pattern augmentation helps
Inspector Gadget find more variations of cracks (see Section 6.4). For
Product (Figures 9a–9c), Inspector Gadget consistently performs
the first or second best despite the different characteristics of the
defects. For NEU (Figure 9e), Inspector Gadget ranks first for the
multi-class classification.

We explain the performances of other methods. Snuba consis-
tently has a lower F1 than Inspector Gadget possibly because the
number of patterns is too large to handle. Instead of considering
all combinations of patterns and training heuristic models, Inspec-
tor Gadget’s approach of training the labeler works better for our
experiments. GOGGLES does not use gold labels for training and
thus has a constant accuracy. In Figure 9a, GOGGLES has a high
F1 because the defect sizes are large, and the pre-trained VGG-16
is effective in identifying them as objects. For the other figures,
however, GOGGLES does not perform as well because the defect
sizes are small and difficult to identify as objects. VGG-19 without
pre-training (“SL (VGG19)”) only performs the best in Figure 9c
where CNN models are very good at detecting stamping defects
because they appear in a fixed location on the images. For other
figures, VGG-19 performs poorly because there is not enough la-
beled data. MobileNetV2 does not perform well in any of the figures.
Finally, the transfer learning method (“TL (VGG19 + Pre-training)”)
shows a performance comparable to Inspector Gadget. In particular,
transfer learning performs better in Figures 9a, 9c, and 9e, while
Inspector Gadget performs better in Figures 9b and 9d (for small dev.
set sizes). While we do not claim that Inspector Gadget outperforms
transfer learning models, it is thus an attractive option for certain
types of defects (e.g., bubbles) and small dev. set sizes.

6.3 Crowdsourcing Workflow
We evaluate how effectively we can use the crowd to label and
identify patterns using the Product datasets. Table 3 compares the
full crowdsourcing workflow in Inspector Gadget with two variants:
(1) a workflow that does not average the patterns at all and (2) a
workflow that does average the patterns, but still does not perform
peer reviews. We evaluate each scenario without using pattern
augmentation. As a result, the full workflow clearly performs the
best for the Product (scratch) and Product (stamping) datasets. For
the Product (bubble) dataset, the workflow that does not combine
patterns has a better average F1, but the accuracies vary among
different workers. Instead, it is better to use the stable full workflow
without the variance.

Inspector Gadget: A Data Programming-based Labeling System for Industrial Images

(a) Product (scratch)

(b) Product (bubble)

(c) Product (stamping)

(d) KSDD [38]

(e) NEU [18]

Figure 9: Weak label accuracy comparison between Inspector Gadget, Snuba [41], GOGGLES [9], the self-learning baselines
(SL) using VGG-19 [35] and MobileNetV2 [32], and transfer learning baseline (TL) on different sizes of development set. Among
the models that are not pre-trained, Inspector Gadget performs either the best or second-best in all figures.

Table 3: Crowdsourcing workflow ablation results

Dataset

No avg.
(±std/2)
0.940 (±0.005)
Product (scratch)
0.616 (±0.045)
Product (bubble)
Product (stamping) 0.299 (±0.142)

F1 scores

No

Full

peer review workflow

0.952
0.525
0.543

0.960
0.605
0.595

Table 4: Pattern augmentation impact on Inspector Gadget.
For each dataset, we highlight the highest F1 score.

each augmentation helps improve F1, using both of them usually
gives the best results. While adding more patterns thus helps to a
certain extent, it does has diminishing returns afterwards.

Pattern augmentation is an important way to solve class imbal-
ance where there are very few defects compared to non-defects.
Among the five datasets, KSDD, Product (bubble), and Product
(stamping) have relatively few numbers of defects, and they benefit
the most from pattern augmentation where the performance lift
compared to no augmentation ranges from 0.10–0.27.

Dataset

KSDD [38]
Product (scratch)
Product (bubble)
Product (stamping)
NEU [18]

Policy GAN Using
Both

No
Aug. Based Based
0.509
0.578
0.415
0.962
0.965
0.958
0.702
0.617
0.715
0.765
0.700
0.700
0.930
0.936
0.954

0.688
0.979
0.701
0.859
0.954

6.4 Pattern Augmentation
We evaluate how augmented patterns help improve the weak label
F1 score of Inspector Gadget. Table 4 shows the impact of the
GAN-based and policy-based augmentation on the five datasets.
Figure 10 shows how adding patterns impacts the F1 score for the
Product (bubble) dataset. While adding more patterns helps to a
certain extent, it has diminishing returns afterwards. The results
for the other datasets are similar, although sometimes noisier. The
best number of augmented patterns differs per dataset, but falls
in the range of 100–500. When using both methods, we simply
combine the patterns from each augmentation. As a result, while

Figure 10: Policy-based and GAN-based augmentation re-
sults on the Product (stamping) dataset.

6.5 Model Tuning
We evaluate the impact of model tuning on accuracy described in
Section 5.2 as shown in Figure 11. We use an MLP with 1 to 3 hidden
layers and varied the number of nodes per hidden layer to be one
of {2n |n = 1 . . . m and 2m−1 ≤ I ≤ 2m } where I is the number of
input nodes. For each dataset, we first obtain the maximum and

406080100120140160SizeofDev.Set0.51.0F1score30405060708090100SizeofDev.Set0.00.51.0F1score406080100SizeofDev.Set0.00.51.0F1score20304050607080SizeofDev.Set0.00.51.0F1score200400600800SizeofDev.Set0.00.51.0F1score020406080100NumberofAugmentedPatterns0.40.50.6F1scorePolicy-basedGAN-basedGeon Heo, Yuji Roh, Seonghyeon Hwang, Dayun Lee, Steven Euijong Whang

Table 6: Error analysis of Inspector Gadget.

Cause

Matching Noisy
data

failure

Dataset
KSDD [38]

10 (52.6 %) 5 (26.3 %)
Product (scratch) 11 (36.7 %) 11 (36.7 %)
19 (45.2 %) 15 (35.7 %)
Product (bubble)
Product (stamping) 15 (45.5 %) 13 (39.4 %)
35 (63.6 %) 4 (7.3 %)

NEU [18]

Difficult
to humans
4 (21.1 %)
8 (26.6 %)
8 (19.1 %)
5 (15.1 %)
16 (29.1 %)

have difficulty identifying the defects because they are not obvious
(e.g., a near-invisible scratch).

7 RELATED WORK

Crowdsourcing for machine learning and databases. Using hu-
mans in advanced analytics is increasingly becoming mainstream [44]
where the tasks include query processing [23], entity matching [12],
active learning [25], data labeling [15], and feature engineering [6].
Inspector Gadget provides a new use case where the crowd identi-
fies patterns.

Data Programming. Data programming [29] is a recent para-
digm where workers program labeling functions (LFs), which are
used to generate weak labels at scale. Snorkel [4, 28] is a seminal
system that demonstrates the practicality of data programming,
and Snuba [41] extends it by automatically constructing LFs using
primitives. In comparison, Inspector Gadget does not assume any
accuracy guarantees on the feature generation function and directly
labels images without converting them to structured data.

Several systems have studied the problem of automating label-
ing function construction. CrowdGame [21] proposes a method for
constructing LFs for entity resolution on structured data. Adversar-
ial data programming [27] proposes a GAN-based framework for
labeling with LF results and claims to be better than Snorkel-based
approaches. In comparison, Inspector Gadget solves the different
problem of partially analyzing large images.

Automatic Image labeling. There is a variety of general automatic
image labeling techniques. Data augmentation [34] is a general
method to generate new labeled images. Generative adversarial
networks (GANs) [13] have been proposed to generate fake, but
realistic images based on existing images. Policies [7] were proposed
to apply custom transformations on images as long as they remain
realistic. Most of the existing work operate on the entire images. In
comparison, Inspector Gadget is efficient because it only needs to
augment patterns, which are much smaller than the images. Label
propagation techniques [5] organize images into a graph based on
their similarities and then propagates existing labels of images to
their most similar ones. In comparison, Inspector Gadget is designed
for images where only a small part of them are of interest while the
main part may be nearly identical to other images, so we cannot
utilize the similar method. There are also application-specific defect
detection methods [17, 18, 36], some of which are designed for
the datasets we used. In comparison, Inspector Gadget provides
a general framework for image labeling. Recently, GOGGLES [9]
is an image labeling system that relies on a pre-trained model to

Figure 11: The variations in F1 scores when tuning the MLP
model hyper-parameters.

Table 5: F1 scores of end models trained on the development
set (Dev. Set) only or the development set combined with
the weak labels produced by Inspector Gadget (WL (IG)). Tip.
Pnt shows how larger the development set must be for the
Dev. Set approach to obtain the same F1 score as WL (IG).

Dataset
KSDD [38]
Product (sc)
Product (bu)
Product (st)
NEU [18]

End Model Dev. Set WL (IG) Tip. Pnt
×3.248
×4.374
×6.041
×7.565
×1.874

VGG19
VGG19
VGG19
VGG19
ResNet50

0.700
0.978
0.720
0.876
0.970

0.499
0.925
0.359
0.782
0.953

minimum possible F1 scores by evaluating all the tuned models we
considered directly on the test data. Then, we compare these results
with the (test data) F1 score of the actual model that Inspector
Gadget selected using the development set. We observe that the
model tuning in Inspector Gadget can indeed improve the model
accuracy, close to the maximum possible value.

6.6 End Model Accuracy
We now address the issue of whether the weak labels are actually
helpful for training the end discriminative model. We compare the
F1 score of this end model with the same model that is trained on
the development set. For the discriminative model, we use VGG-
19 [35] for the binary classification tasks on KSDD and Product, and
ResNet50 [16] for the multi-class task on NEU. We can use other
discriminative models that have higher absolute F1, but the point
is to show the relative F1 improvements when using weak labels.
Table 5 shows that the F1 scores improve by 0.02–0.36. In addition,
the results of “Tip. Pnt” show that one needs to increase the sizes of
the development sets by 1.874–7.565x for the discriminative models
to obtain the same F1 scores as Inspector Gadget.

6.7 Error Analysis
We perform an error analysis on which cases Inspector Gadget
fails to make correct predicts for the five datasets based on manual
investigation. We use the ground truth information for the analysis.
Table 6 shows that most common error is when certain defects do
not match with the patterns, which can be improved by using better
pattern augmentation and matching techniques. The next common
case is when the data is noisy, which can be improved by cleaning
the data. The last case is the most challenging where even humans

KSDDScratchBubbleStampingNEU0.00.20.40.60.81.0F1scoreMaxMinOurtuningInspector Gadget: A Data Programming-based Labeling System for Industrial Images

extract semantic prototypes of images. In comparison, Inspector
Gadget does not rely on pre-trained models and is more suitable for
partially analyzing large images using human knowledge. Lastly, an
interesting line of work is novel class detection [33] where the goal
is to identify unknown defects. While Inspector Gadget assumes a
fixed set of defects, it can be extended with these techniques.

8 CONCLUSION
We proposed Inspector Gadget, a scalable image labeling system for
classification problems that effectively combines crowdsourcing,
data augmentation, and data programming techniques. Inspector
Gadget targets applications in manufacturing where large indus-
trial images are partially analyzed, and there are few or no labels
to start with. Unlike existing data programming approaches that
convert images to structured data beforehand using object detec-
tion models, Inspector Gadget directly labels images by providing
a crowdsourcing workflow to leverage human knowledge for iden-
tifying patterns of interest. The patterns are then augmented and
matched with other images to generate similarity features for MLP
model training. Our experiments show that Inspector Gadget out-
performs other image labeling methods (Snuba, GOGGLES) and
self-learning baselines using CNNs without pre-training. We thus
believe that Inspector Gadget opens up a new class of problems to
apply data programming.

9 ACKNOWLEDGMENTS
This work was supported by a Google AI Focused Research Award,
by SK Telecom, and by the Engineering Research Center Program
through the National Research Foundation of Korea (NRF) funded
by the Korean Government MSIT (NRF-2018R1A5A1059921).

REFERENCES
[1] [n.d.].

Inspector Gadget Github repository.

InspectorGadget. Accessed July 15th, 2020.

https://github.com/geonheo/

[2] [n.d.]. OpenCV. https://docs.opencv.org/2.4/modules/imgproc/doc/object_

detection.html. Accessed July 15th, 2020.

[3] E. H. Adelson, C. H. Anderson, J. R. Bergen, P. J. Burt, and J. M. Ogden. 1984.
1984, Pyramid methods in image processing. RCA Engineer 29, 6 (1984), 33–41.
[4] Stephen H. Bach, Daniel Rodriguez, Yintao Liu, Chong Luo, Haidong Shao, Cas-
sandra Xia, Souvik Sen, Alexander Ratner, Braden Hancock, Houman Alborzi,
Rahul Kuchhal, Christopher Ré, and Rob Malkin. 2019. Snorkel DryBell: A Case
Study in Deploying Weak Supervision at Industrial Scale. In SIGMOD. 362–375.
[5] Thang D. Bui, Sujith Ravi, and Vivek Ramavajjala. 2018. Neural Graph Learning:

Training Neural Networks Using Graphs. In WSDM. 64–71.

[6] Justin Cheng and Michael S. Bernstein. 2015. Flock: Hybrid Crowd-Machine

Learning Classifiers. In CSCW. 600–611.

[7] Ekin Dogus Cubuk, Barret Zoph, Dandelion Mané, Vijay Vasudevan, and Quoc V.
Le. 2018. AutoAugment: Learning Augmentation Policies from Data. CoRR
abs/1805.09501 (2018). arXiv:1805.09501

[8] Ekin D. Cubuk, Barret Zoph, Dandelion Mane, Vijay Vasudevan, and Quoc V.
Le. 2019. AutoAugment: Learning Augmentation Strategies From Data. In CVPR.
113–123.

[9] Nilaksh Das, Sanya Chaba, Sakshi Gandhi, Duen Horng Chau, and Xu Chu.
2020. GOGGLES: Automatic Training Data Generation with Affinity Coding. In
SIGMOD.

[10] Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Fei-Fei Li. 2009. Ima-

geNet: A large-scale hierarchical image database. In CVPR. 248–255.

[11] Maayan Frid-Adar, Idit Diamant, Eyal Klang, Michal Amitai, Jacob Goldberger,
and Hayit Greenspan. 2018. GAN-based synthetic medical image augmentation
for increased CNN performance in liver lesion classification. Neurocomputing
321 (2018), 321–331.

[12] Chaitanya Gokhale, Sanjib Das, AnHai Doan, Jeffrey F Naughton, Narasimhan
Rampalli, Jude Shavlik, and Xiaojin Zhu. 2014. Corleone: hands-off crowdsourcing
for entity matching. In SIGMOD. 601–612.

[13] Ian J. Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-
Farley, Sherjil Ozair, Aaron C. Courville, and Yoshua Bengio. 2014. Generative
Adversarial Nets. In NIPS. 2672–2680.

[14] Qiong Gu and Zhihua Zhu, Liand Cai. 2009. Evaluation Measures of the Classifi-
cation Performance of Imbalanced Data Sets. In CIIS, Zhihua Cai, Zhenhua Li,
Zhuo Kang, and Yong Liu (Eds.). Berlin, Heidelberg, 461–471.

[15] Daniel Haas, Jiannan Wang, Eugene Wu, and Michael J Franklin. 2015. Clamshell:
Speeding up crowds for low-latency data labeling. arXiv preprint arXiv:1509.05969
(2015).

[16] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. 2016. Deep Residual
Learning for Image Recognition. In 2016 IEEE Conference on Computer Vision
and Pattern Recognition, CVPR 2016, Las Vegas, NV, USA, June 27-30, 2016. IEEE
Computer Society, 770–778.

[17] Y. He, K. Song, H. Dong, and Y. Yan. 2019. Semi-supervised defect classification of
steel surface based on multi-training and generative adversarial network. Optics
and Lasers in Engineering 122 (2019), 294–302.

[18] Yu He, Ke-Chen Song, Qinggang Meng, and Yunhui Yan. 2020. An End-to-
end Steel Surface Defect Detection Approach via Fusing Multiple Hierarchical
Features. IEEE Transactions on Instrumentation and Measurement 69 (04 2020),
1493–1504.

[19] Alexia Jolicoeur-Martineau. 2019. The relativistic discriminator: a key element

missing from standard GAN. In ICLR.

[20] Dong C. Liu and Jorge Nocedal. 1989. On the limited memory BFGS method for

large scale optimization. Math. Program. 45, 1-3 (1989), 503–528.

[21] Tongyu Liu, Jingru Yang, Ju Fan, Zhewei Wei, Guoliang Li, and Xiaoyong Du.
2019. CrowdGame: A Game-Based Crowdsourcing System for Cost-Effective
Data Labeling. In SIGMOD. 1957–1960.

[22] Yun Liu, Timo Kohlberger, Mohammad Norouzi, George Dahl, Jenny Smith, Arash
Mohtashamian, Niels Olson, Lily Peng, Jason Hipp, and Martin Stumpe. 2018.
Artificial Intelligence Based Breast Cancer Nodal Metastasis Detection: Insights
into the Black Box for Pathologists. Archives of Pathology & Laboratory Medicine
(2018).

[23] Adam Marcus, Eugene Wu, David R Karger, Samuel Madden, and Robert C Miller.

2011. Crowdsourced databases: Query processing with people. Cidr.

[24] Takeru Miyato, Toshiki Kataoka, Masanori Koyama, and Yuichi Yoshida.
2018. Spectral Normalization for Generative Adversarial Networks. CoRR
abs/1802.05957 (2018). arXiv:1802.05957 http://arxiv.org/abs/1802.05957
[25] Barzan Mozafari, Purnamrita Sarkar, Michael J Franklin, Michael I Jordan, and
Samuel Madden. 2012. Active learning for crowd-sourced databases. arXiv
preprint arXiv:1209.3686 (2012).

[26] Ercan Oztemel and Samet Gursev. 2018. Literature review of Industry 4.0 and

related technologies. Journal of Intelligent Manufacturing (2018).

[27] Arghya Pal and Vineeth N. Balasubramanian. 2018. Adversarial Data Program-
ming: Using GANs to Relax the Bottleneck of Curated Labeled Data. In CVPR.
1556–1565.

[28] Alexander J. Ratner, Stephen H. Bach, Henry R. Ehrenberg, and Chris Ré. 2017.
Snorkel: Fast Training Set Generation for Information Extraction. In SIGMOD
(Chicago, Illinois, USA). 1683–1686.

[29] Alexander J. Ratner, Christopher De Sa, Sen Wu, Daniel Selsam, and Christopher
Ré. 2016. Data Programming: Creating Large Training Sets, Quickly. In NIPS.
3567–3575.

[30] Shaoqing Ren, Kaiming He, Ross Girshick, and Jian Sun. 2015. Faster r-cnn:
Towards real-time object detection with region proposal networks. In Advances
in neural information processing systems. 91–99.

[31] Yuji Roh, Geon Heo, and Steven Euijong Whang. 2019. A Survey on Data Collec-
tion for Machine Learning: a Big Data - AI Integration Perspective. IEEE TKDE
(2019).

[32] Mark Sandler, Andrew G. Howard, Menglong Zhu, Andrey Zhmoginov, and Liang-
Chieh Chen. 2018. MobileNetV2: Inverted Residuals and Linear Bottlenecks. In
CVPR. 4510–4520.

[33] Walter J Scheirer, Anderson de Rezende Rocha, Archana Sapkota, and Terrance E
Boult. 2012. Toward open set recognition. IEEE transactions on pattern analysis
and machine intelligence 35, 7 (2012), 1757–1772.

[34] Connor Shorten and Taghi M. Khoshgoftaar. 2019. A survey on Image Data

Augmentation for Deep Learning. J. Big Data 6 (2019), 60.

[35] Karen Simonyan and Andrew Zisserman. 2015. Very Deep Convolutional Net-

works for Large-Scale Image Recognition. In ICLR.

[36] Ke-Chen Song and Yunhui Yan. 2013. A noise robust method based on completed
local binary patterns for hot-rolled steel strip surface defects. Applied Surface
Science 285 (2013), 858–864.

[37] Michael Stonebraker and El Kindi Rezig. 2019. Machine Learning and Big Data:

What is Important? IEEE Data Eng. Bull. (2019).

[38] Domen Tabernik, Samo Šela, Jure Skvarč, and Danijel Skočaj. 2019. Segmentation-
Based Deep-Learning Approach for Surface-Defect Detection. Journal of Intelli-
gent Manufacturing (15 May 2019).

[39] Isaac Triguero, Salvador García, and Francisco Herrera. 2015. Self-labeled tech-
niques for semi-supervised learning: taxonomy, software and empirical study.

Knowl. Inf. Syst. 42, 2 (2015), 245–284.

[40] Paroma Varma, Bryan D. He, Payal Bajaj, Nishith Khandwala, Imon Banerjee,
Daniel L. Rubin, and Christopher Ré. 2017. Inferring Generative Model Structure
with Static Analysis. In NeurIPS. 240–250.

[41] Paroma Varma and Christopher Ré. 2018. Snuba: Automating Weak Supervision

to Label Training Data. PVLDB 12, 3 (2018), 223–236.

[42] Paroma Varma, Frederic Sala, Ann He, Alexander Ratner, and Christopher Ré.
2019. Learning Dependency Structures for Weak Supervision Models. In ICML,

Geon Heo, Yuji Roh, Seonghyeon Hwang, Dayun Lee, Steven Euijong Whang

Kamalika Chaudhuri and Ruslan Salakhutdinov (Eds.), Vol. 97. 6418–6427.
[43] Zhengwei Wang, Qi She, and Tomas E. Ward. 2019. Generative Adversarial Net-
works: A Survey and Taxonomy. CoRR abs/1906.01529 (2019). arXiv:1906.01529
[44] Doris Xin, Litian Ma, Jialin Liu, Stephen Macke, Shuchen Song, and Aditya G.
Parameswaran. 2018. Accelerating Human-in-the-loop Machine Learning: Chal-
lenges and Opportunities. In DEEM@SIGMOD. 9:1–9:4.

