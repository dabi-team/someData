A Generative Model for Punctuation in Dependency Trees

Xiang Lisa Li∗ and Dingquan Wang∗ and Jason Eisner
Department of Computer Science, Johns Hopkins University
xli150@jhu.edu, {wdd,jason}@cs.jhu.edu

9
1
0
2

n
u
J

6
2

]
L
C
.
s
c
[

1
v
8
9
2
1
1
.
6
0
9
1
:
v
i
X
r
a

Abstract

Treebanks traditionally treat punctuation
marks as ordinary words, but linguists have
suggested that a tree’s “true” punctuation
marks are not observed (Nunberg, 1990).
These latent “underlying” marks serve to
delimit or separate constituents in the syn-
tax tree. When the tree’s yield is rendered as
a written sentence, a string rewriting mech-
anism transduces the underlying marks into
“surface” marks, which are part of the ob-
served (surface) string but should not be re-
garded as part of the tree. We formalize
this idea in a generative model of punc-
tuation that admits efﬁcient dynamic pro-
gramming. We train it without observing
the underlying marks, by locally maximiz-
ing the incomplete data likelihood (simi-
larly to the EM algorithm). When we use
the trained model to reconstruct the tree’s
underlying punctuation, the results appear
plausible across 5 languages, and in par-
ticular are consistent with Nunberg’s anal-
ysis of English. We show that our gener-
ative model can be used to beat baselines
on punctuation restoration. Also, our recon-
struction of a sentence’s underlying punctu-
ation lets us appropriately render the surface
punctuation (via our trained underlying-to-
surface mechanism) when we syntactically
transform the sentence.

1

Introduction

Punctuation enriches the expressiveness of writ-
ten language. When converting from spoken to
written language, punctuation indicates pauses or
pitches; expresses propositional attitude; and is
conventionally associated with certain syntactic
constructions such as apposition, parenthesis, quo-
tation, and conjunction.

In this paper, we present a latent-variable
model of punctuation usage, inspired by the rule-
based approach to English punctuation of Nun-
berg (1990). Training our model on English data

∗Equal contribution.

357

learns rules that are consistent with Nunberg’s
hand-crafted rules. Our system is automatic, so we
use it to obtain rules for Arabic, Chinese, Spanish,
and Hindi as well.

Moreover, our rules are stochastic, which al-
lows us to reason probabilistically about ambigu-
ous or missing punctuation. Across the 5 lan-
guages, our model predicts surface punctuation
better than baselines, as measured both by per-
plexity (§4) and by accuracy on a punctuation
restoration task (§6.1). We also use our model
to correct the punctuation of non-native writers
of English (§6.2), and to maintain natural punc-
tuation style when syntactically transforming En-
glish sentences (§6.3).
In principle, our model
could also be used within a generative parser, al-
lowing the parser to evaluate whether a candidate
tree truly explains the punctuation observed in the
input sentence (§8).

Punctuation is interesting In The Linguistics of
Punctuation, Nunberg (1990) argues that punctu-
ation (in English) is more than a visual counter-
part of spoken-language prosody, but forms a lin-
guistic system that involves “interactions of point
indicators (i.e. commas, semicolons, colons, pe-
riods and dashes).” He proposes that much as in
phonology (Chomsky and Halle, 1968), a gram-
mar generates underlying punctuation which then
transforms into the observed surface punctuation.
Consider generating a sentence from a syntactic

grammar as follows:

Hail the king [, Arthur Pendragon ,]

[, who wields [ “ Excalibur ” ] ,] .

Although the full tree is not depicted here, some of
the constituents are indicated with brackets. In this
underlying generated tree, each appositive NP is
surrounded by commas. On the surface, however,
the two adjacent commas after Pendragon will
now be collapsed into one, and the ﬁnal comma
will be absorbed into the adjacent period. Fur-
thermore, in American English, the typographic

 
 
 
 
 
 
convention is to move the ﬁnal punctuation inside
the quotation marks. Thus a reader sees only this
modiﬁed surface form of the sentence:

Hail the king, Arthur Pendragon,
who wields “Excalibur.”

Note that these modiﬁcations are string transfor-
mations that do not see or change the tree. The
resulting surface punctuation marks may be clues
to the parse tree, but (contrary to NLP convention)
they should not be included as nodes in the parse
tree. Only the underlying marks play that role.

Punctuation is meaningful Pang et al. (2002)
use question and exclamation marks as clues to
sentiment. Similarly, quotation marks may be
used to mark titles, quotations, reported speech,
or dubious terminology (University of Chicago,
2010). Because of examples like this, methods for
determining the similarity or meaning of syntax
trees, such as a tree kernel (Agarwal et al., 2011)
or a recursive neural network (Tai et al., 2015),
should ideally be able to consider where the un-
derlying punctuation marks attach.

Punctuation is helpful Surface punctuation re-
mains correlated with syntactic phrase structure.
NLP systems for generating or editing text must be
able to deploy surface punctuation as human writ-
ers do. Parsers and grammar induction systems
beneﬁt from the presence of surface punctuation
marks (Jones, 1994; Spitkovsky et al., 2011). It is
plausible that they could do better with a linguisti-
cally informed model that explains exactly why the
surface punctuation appears where it does. Pat-
terns of punctuation usage can also help identify
the writer’s native language (Markov et al., 2018).

Punctuation is neglected Work on syntax and
parsing tends to treat punctuation as an af-
terthought rather than a phenomenon governed by
its own linguistic principles. Treebank annota-
tion guidelines for punctuation tend to adopt sim-
ple heuristics like “attach to the highest possi-
ble node that preserves projectivity” (Bies et al.,
1995; Nivre et al., 2018).1 Many dependency
parsing works exclude punctuation from evalua-
tion (Nivre et al., 2007b; Koo and Collins, 2010;
Chen and Manning, 2014; Lei et al., 2014; Kiper-
wasser and Goldberg, 2016), although some others
retain punctuation (Nivre et al., 2007a; Goldberg
and Elhadad, 2010; Dozat and Manning, 2017).

Unpunctuated Tree: T

ATTACH

tree:

T (cid:48)
Underlying sequence: u
sentence: ¯u

NOISYCHANNEL

Dale

means river valley

nsubj

root

dobj

root.

”

“

nsubj
u0
u1
“ Dale ”

“

dobj

”
u3

u4
means “ river valley ” .

u2

Surface

sentence: ¯x
sequence: x

“ Dale ”
x0
x1

means “ river valley . ”
x4

x3

x2

Figure 1: The generative story of a sentence. Given
an unpunctuated tree T at top, at each node w ∈
T , the ATTACH process stochastically attaches a left
puncteme l and a right puncteme r, which may be
empty. The resulting tree T (cid:48) has underlying punctua-
tion u. Each slot’s punctuation ui ∈ u is rewritten to
xi ∈ x by NOISYCHANNEL.

In tasks such as word embedding induction
(Mikolov et al., 2013; Pennington et al., 2014) and
machine translation (Zens et al., 2002), punctua-
tion marks are usually either removed or treated as
ordinary words ( ˇReh˚uˇrek and Sojka, 2010).

Yet to us, building a parse tree on a surface
sentence seems as inappropriate as morphologi-
cally segmenting a surface word. In both cases,
one should instead analyze the latent underlying
form, jointly with recovering that form. For exam-
ple, the proper segmentation of English hoping
is not hop-ing but hope-ing (with underlying
e), and the proper segmentation of stopping
is neither stopp-ing nor stop-ping but
stop-ing (with only one underlying p). Cot-
terell et al. (2015, 2016) get this right for morphol-
ogy. We attempt to do the same for punctuation.

2 Formal Model

We propose a probabilistic generative model of
sentences (Figure 1):

p(¯x) = (cid:80)

(1)
T,T (cid:48)psyn(T ) · pθ(T (cid:48) | T ) · pφ(¯x | ¯u(T (cid:48)))

First, an unpunctuated dependency tree T is
stochastically generated by some recursive pro-
cess psyn (e.g., Eisner, 1996, Model C).2 Second,
each constituent (i.e., dependency subtree) sprouts
optional underlying punctuation at its left and right
edges, according to a probability distribution pθ
that depends on the constituent’s syntactic role
(e.g., dobj for “direct object”). This punctuated
tree T (cid:48) yields the underlying string ¯u = ¯u(T (cid:48)),
which is edited by a ﬁnite-state noisy channel pφ
to arrive at the surface sentence ¯x.

1http://universaldependencies.org/u/

2Our model could be easily adapted to work on con-

dep/punct.html

stituency trees instead.

358

This third step may alter the sequence of punc-
tuation tokens at each slot between words—for ex-
ample, in §1, collapsing the double comma , ,
between Pendragon and who. u and x denote
just the punctuation at the slots of ¯u and ¯x respec-
tively, with ui and xi denoting the punctuation to-
ken sequences at the ith slot. Thus, the transfor-
mation at the ith slot is ui (cid:55)→ xi.

Since this model is generative, we could train
it without any supervision to explain the observed
surface string ¯x: maximize the likelihood p(¯x) in
(1), marginalizing out the possible T, T (cid:48) values.

In the present paper, however, we exploit known
T values (as observed in the “depunctuated” ver-
sion of a treebank). Because T is observed, we can
jointly train θ, φ to maximize just
(cid:88)

pθ(T (cid:48) | T ) · pφ(x | u(T (cid:48)))

p(x | T ) =

(2)

T (cid:48)

That is, the psyn model that generated T becomes
irrelevant, but we still try to predict what surface
punctuation will be added to T . We still marginal-
ize over the underlying punctuation marks u.
These are never observed, but they must explain
the surface punctuation marks x (§2.2), and they
must be explained in turn by the syntax tree T
(§2.1). The trained generative model then lets us
restore or correct punctuation in new trees T (§6).

2.1 Generating Underlying Punctuation

The ATTACH model characterizes the probability
of an underlying punctuated tree T (cid:48) given its cor-
responding unpunctuated tree T , which is given by
(cid:89)

pθ(lw, rw | w)

(3)

pθ(T (cid:48) | T ) =

w∈T

where lw, rw ∈ V are the left and right punctemes
that T (cid:48) attaches to the tree node w. Each puncteme
(Krahn, 2014) in the ﬁnite set V is a string of 0 or
more underlying punctuation tokens.3 The proba-
bility pθ(l, r | w) is given by a log-linear model

pθ(l, r|w) ∝

(cid:40)

exp θ(cid:62)f (l, r, w) if (l, r) ∈ Wd(w)
0

otherwise

(4)

3Multi-token punctemes are occasionally useful. For ex-
ample, the puncteme ... might consist of either 1 or 3 to-
kens, depending on how the tokenizer works; similarly, the
puncteme ?! might consist of 1 or 2 tokens. Also, if a sin-
gle constituent of T gets surrounded by both parentheses and
quotation marks, this gives rise to punctemes (“ and ”).
(A better treatment would add the parentheses as a separate
puncteme pair at a unary node above the quotation marks, but
that would have required T (cid:48) to introduce this extra node.)

359

3. Period Absorption

1. Point Absorption
„(cid:55)→ , ,.(cid:55)→ . -,(cid:55)→ - .?(cid:55)→ ?
-;(cid:55)→ ; ;.(cid:55)→ .
2. Quote Transposition 4. Bracket Absorptions
,)(cid:55)→ ) -)(cid:55)→ ) (,(cid:55)→ (
”,(cid:55)→ ,”
,”(cid:55)→ ” “,(cid:55)→ “

abbv.(cid:55)→ abbv

”.(cid:55)→ .”

.!(cid:55)→ !

Table 1: Some of Nunberg’s punctuation interaction
rules in English, in priority order. The absorption rules
ensure that when there are two adjacent tokens, the
“weaker” one is deleted (where the strength ordering
is {?, !, (, ), “, ”} > . > {;, :} > - > ,), except
that bracketing tokens such as () and “” do not absorb
tokens outside the material they bracket.

where V is the ﬁnite set of possible punctemes and
Wd ⊆ V 2 gives the possible puncteme pairs for a
node w that has dependency relation d = d(w) to
its parent. V and Wd are estimated heuristically
from the tokenized surface data (§4). f (l, r, w) is
a sparse binary feature vector, and θ is the cor-
responding parameter vector of feature weights.
The feature templates in Appendix A4 consider the
symmetry between l and r, and their compatibility
with (a) the POS tag of w’s head word, (b) the de-
pendency paths connecting w to its children and
the root of T , (c) the POS tags of the words ﬂank-
ing the slots containing l and r, (d) surface punc-
tuation already added to w’s subconstituents.

2.2 From Underlying to Surface
From the tree T (cid:48), we can read off the sequence
of underlying punctuation tokens ui at each slot i
between words. Namely, ui concatenates the right
punctemes of all constituents ending at i with the
left punctemes of all constituents starting at i (as
illustrated by the examples in §1 and Figure 1).
The NOISYCHANNEL model then transduces ui to
a surface token sequence xi, for each i = 0, . . . , n
independently (where n is the sentence length).

Nunberg’s formalism Much like Chomsky and
Halle’s (1968) phonological grammar of English,
Nunberg’s (1990) descriptive English punctuation
grammar (Table 1) can be viewed computationally
as a priority string rewriting system, or Markov
algorithm (Markov, 1960; Caracciolo di Forino,
1968). The system begins with a token string u.
At each step it selects the highest-priority local
rewrite rule that can apply, and applies it as far
left as possible. When no more rules can apply,

4 The appendices are included only in this arXiv version,

not in the TACL journal.

abcde
abcde
a bde
a dbe
a d e

(cid:46) ab (cid:55)→ ab
(cid:46) bc (cid:55)→ b
(cid:46) bd (cid:55)→ db
(cid:46) be (cid:55)→ e

Figure 2: Editing abcde (cid:55)→ ade with a sliding win-
dow. (When an absorption rule maps 2 tokens to 1, our
diagram leaves blank space that is not part of the out-
put string.) At each step, the left-to-right process has
already committed to the green tokens as output; has
not yet looked at the blue input tokens; and is currently
considering how to (further) rewrite the black tokens.
The right column shows the chosen edit.

the ﬁnal state of the string is returned as x.

Simplifying the formalism Markov algorithms
are Turing complete. Fortunately, Johnson (1972)
noted that in practice, phonological u (cid:55)→ x maps
described in this formalism can usually be imple-
mented with ﬁnite-state transducers (FSTs).

For computational simplicity, we will formu-
late our punctuation model as a probabilistic FST
(PFST)—a locally normalized left-to-right rewrite
model (Cotterell et al., 2014). The probabilities
for each language must be learned, using gradient
descent. Normally we expect most probabilities to
be near 0 or 1, making the PFST nearly determin-
istic (i.e., close to a subsequential FST). However,
permitting low-probability choices remains useful
to account for typographical errors, dialectal dif-
ferences, and free variation in the training corpus.
Our PFST generates a surface string, but the
invertibility of FSTs will allow us to work back-
wards when analyzing a surface string (§3).

A sliding-window model
Instead of having rule
priorities, we apply Nunberg-style rules within a
2-token window that slides over u in a single left-
to-right pass (Figure 2). Conditioned on the cur-
rent window contents ab, a single edit is selected
stochastically: either ab (cid:55)→ ab (no change), ab (cid:55)→ b
(left absorption), ab (cid:55)→ a (right absorption), or
ab (cid:55)→ ba (transposition). Then the window slides
rightward to cover the next input token, together
with the token that is (now) to its left. a and b are
always real tokens, never boundary symbols. φ
speciﬁes the conditional edit probabilities.5

5Rather than learn a separate edit probability distribution
for each bigram ab, one could share parameters across bi-
grams. For example, Table 1’s caption says that “stronger”
tokens tend to absorb “weaker” ones. A model that incor-
porated this insight would not have to learn O(|Σ|2) separate
absorption probabilities (two per bigram ab), but only O(|Σ|)
strengths (one per unigram a, which may be regarded as a

These speciﬁc edit rules (like Nunberg’s) can-
not insert new symbols, nor can they delete all of
the underlying symbols. Thus, surface xi is a good
clue to ui: all of its tokens must appear underly-
ingly, and if xi = (cid:15) (the empty string) then ui = (cid:15).
The model can be directly implemented as
a PFST (Appendix D4) using Cotterell et al.’s
(2014) more general PFST construction.

Our single-pass formalism is less expressive
than Nunberg’s. It greedily makes decisions based
on at most one token of right context (“label
bias”). It cannot rewrite ’”.(cid:55)→.’” or ”,.(cid:55)→.”
because the . is encountered too late to percolate
leftward; luckily, though, we can handle such En-
glish examples by sliding the window right-to-left
instead of left-to-right. We treat the sliding direc-
tion as a language-speciﬁc parameter.6

2.3 Training Objective

Building on equation (2), we train θ, φ to lo-
cally maximize the regularized conditional log-
likelihood
(cid:16) (cid:88)

[c(T (cid:48))]2(cid:17)

− ς · ||θ||2

log p(x | T ) − ξ · E
T (cid:48)

x,T

(5)

where the sum is over a training treebank.7

The expectation E[· · · ] is over T (cid:48) ∼ p(·
|
T, x). This generalized expectation term pro-
vides posterior regularization (Mann and McCal-
lum, 2010; Ganchev et al., 2010), by encourag-
ing parameters that reconstruct trees T (cid:48) that use
symmetric punctuation marks in a “typical” way.
The function c(T (cid:48)) counts the nodes in T (cid:48) whose
punctemes contain “unmatched” symmetric punc-
tuation tokens: for example, ) is “matched” only
when it appears in a right puncteme with ( at the
comparable position in the same constituent’s left
puncteme. The precise deﬁnition is given in Ap-
pendix B.4

In our development experiments on English, the
posterior regularization term was necessary to dis-
cover an aesthetically appealing theory of under-
lying punctuation. When we dropped this term

1-dimensional embedding of the punctuation token a). We
ﬁgured that the punctuation vocabulary Σ was small enough
(Table 2) that we could manage without the additional com-
plexity of embeddings or other featurization, although this
does presumably hurt our generalization to rare bigrams.

6We could have handled all languages uniformly by mak-
ing ≥ 2 passes of the sliding window (via a composition of
≥ 2 PFSTs), with at least one pass in each direction.

7In retrospect, there was no good reason to square the
ET (cid:48) [c(T (cid:48))] term. However, when we started redoing the ex-
periments, we found the results essentially unchanged.

360

(ξ = 0) and simply maximized the ordinary regu-
larized likelihood, we found that the optimization
problem was underconstrained: different training
runs would arrive at different, rather arbitrary un-
derlying punctemes. For example, one training run
learned an ATTACH model that used underlying
“. to terminate sentences, along with a NOISY-
CHANNEL model that absorbed the left quotation
mark into the period. By encouraging the under-
lying punctuation to be symmetric, we broke the
ties. We also tried making this a hard constraint
(ξ = ∞), but then the model was unable to explain
some of the training sentences at all, giving them
probability of 0. For example, I went to the
“ special place ” cannot be explained, be-
cause special place is not a constituent.8

3

Inference

In principle, working with the model (1) is
straightforward, thanks to the closure properties
of formal languages. Provided that psyn can be en-
coded as a weighted CFG, it can be composed with
the weighted tree transducer pθ and the weighted
FST pφ to yield a new weighted CFG (similarly to
Bar-Hillel et al., 1961; Nederhof and Satta, 2003).
Under this new grammar, one can recover the opti-
mal T, T (cid:48) for ¯x by dynamic programming, or sum
over T, T (cid:48) by the inside algorithm to get the likeli-
hood p(¯x). A similar approach was used by Levy
(2008) with a different FST noisy channel.

In this paper we assume that T is observed, al-
lowing us to work with equation (2). This cuts the
computation time from O(n3) to O(n).9 Whereas
the inside algorithm for (1) must consider O(n2)
possible constituents of ¯x and O(n) ways of build-
ing each, our algorithm for (2) only needs to iterate
over the O(n) true constituents of T and the 1 true
way of building each. However, it must still con-
sider the |Wd| puncteme pairs for each constituent.

3.1 Algorithms

Given an input sentence ¯x of length n, our job is
to sum over possible trees T (cid:48) that are consistent

8Recall that the NOISYCHANNEL model family (§2.2) re-
quires the surface “ before special to appear underlyingly,
and also requires the surface (cid:15) after special to be empty
underlyingly. These hard constraints clash with the ξ = ∞
hard constraint that the punctuation around special must
be balanced. The surface ” after place causes a similar
problem: no edge can generate the matching underlying “.

9We do O(n) multiplications of N × N matrices where

N = O(# of punc types · max # of punc tokens per slot).

Algorithm 1 The algorithm for scoring a given
(T, x) pair. The code in blue is used during train-
ing to get the posterior regularization term in (5).
Input: T , x
(cid:46) Training pair (omits T (cid:48), u)
Output: p(x | T ), E[c(T (cid:48))]
1: procedure TOTALSCORE(T , x)
2:

for i = 1 to n do

3:

4:

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

15:

16:

17:

18:

compute WFSA (Mi, λi, ρi)

E ← 0
procedure IN(w)

(cid:46) exp. count of unmatched punctemes
(cid:46) w ∈ T

i, k ← slots at left, right of w constit
j ← slot at right of w headword
Mleft ← ((cid:81)
w(cid:48)∈leftkids(w) IN(w(cid:48)))ρj−1
j ((cid:81)
Mright ← λ(cid:62)
w(cid:48)∈rightkids(w) IN(w(cid:48)))
M(cid:48) ← Mleft · 1 · Mright (cid:46) RNj ×1, R1×Nj
(cid:46) RNi×Nk
M ← 0
for (l, r) ∈ Wd(w) do
p ← pθ(l, r | w)
M ← M + p · Mi(l)M(cid:48)Mk(r)
E ← E + p · 1l,r have unmatched punc
(cid:46) RNi×Nk

return M

Mroot ← IN(root(T ))
return λ(cid:62)
0 Mrootρn, E

(cid:46) R, R

with T and ¯x, or to ﬁnd the best such T (cid:48). This
is roughly a lattice parsing problem—made easier
by knowing T . However, the possible ¯u values
are characterized not by a lattice but by a cyclic
WFSA (as |ui| is unbounded whenever |xi| > 0).
For each slot 0 ≤ i ≤ n, transduce the sur-
face punctuation string xi by the inverted PFST
for pφ to obtain a weighted ﬁnite-state automa-
ton (WFSA) that describes all possible underly-
ing strings ui.10 This WFSA accepts each pos-
sible ui with weight pφ(xi
If it has Ni
states, we can represent it (Berstel and Reutenauer,
1988) with a family of sparse weight matrices
Mi(υ) ∈ RNi×Ni, whose element at row s and
column t is the weight of the s → t arc labeled
with υ, or 0 if there is no such arc. Additional
vectors λi, ρi ∈ RNi specify the initial and ﬁnal
weights. (λi is one-hot if the PFST has a single
initial state, of weight 1.)

| ui).

For any puncteme l (or r) in V, we deﬁne
Mi(l) = Mi(l1)Mi(l2) · · · Mi(l|l|), a product
over the 0 or more tokens in l. This gives the total
weight of all s →∗ t WFSA paths labeled with l.

10Constructively, compose the u-to-x PFST (from the end
of §2.2) with a straight-line FSA accepting only xi, and
project the resulting WFST to its input tape (Pereira and Ri-
ley, 1996), as explained at the end of Appendix D.

361

The subprocedure in Algorithm 1 essentially
extends this to obtain a new matrix IN(w) ∈
RNi×Nk , where the subtree rooted at w stretches
from slot i to slot k.
Its element IN(w)st gives
the total weight of all extended paths in the ¯u
WFSA from state s at slot i to state t at slot k. An
extended path is deﬁned by a choice of underly-
ing punctemes at w and all its descendants. These
punctemes determine an s-to-ﬁnal path at i, then
initial-to-ﬁnal paths at i + 1 through k − 1, then an
initial-to-t path at k. The weight of the extended
path is the product of all the WFSA weights on
these paths (which correspond to transition prob-
abilities in pφ PFST) times the probability of the
choice of punctemes (from pθ).

This

inside algorithm computes quantities
needed for training (§2.3). Useful variants arise
via well-known methods for weighted derivation
forests (Berstel and Reutenauer, 1988; Goodman,
1999; Li and Eisner, 2009; Eisner, 2016).

Speciﬁcally, to modify Algorithm 1 to maximize
over T (cid:48) values (§§6.2–6.3) instead of summing
over them, we switch to the derivation semiring
(Goodman, 1999), as follows. Whereas IN(w)st
used to store the total weight of all extended paths
from state s at slot i to state t at slot j, now it will
store the weight of the best such extended path. It
will also store that extended path’s choice of un-
derlying punctemes, in the form of a puncteme-
annotated version of the subtree of T that is rooted
at w. This is a potential subtree of T (cid:48).

Thus, each element of IN(w) has the form
(r, D) where r ∈ R and D is a tree. We deﬁne
addition and multiplication over such pairs:

(r, D) + (r(cid:48), D(cid:48)) =

(cid:40)

if r > r(cid:48)
(r, D)
(r(cid:48), D(cid:48)) otherwise

(r, D) · (r(cid:48), D(cid:48)) = (rr(cid:48), DD(cid:48))

(6)

(7)

where DD(cid:48) denotes an ordered combination of
two trees. Matrix products UV and scalar-matrix
products p · V are deﬁned in terms of element ad-
dition and multiplication as usual:

(UV)st = (cid:80)
(p · V)st = p · Vst

rUsr · Vrt

(8)

(9)

What is DD(cid:48)? For presentational purposes, it is
convenient to represent a punctuated dependency
tree as a bracketed string. For example, the under-
lying tree T (cid:48) in Figure 1 would be [ [“ Dale ”]
means [“ [ river ] valley ”] ] where

the words correspond to nodes of T . In this case,
we can represent every D as a partial bracketed
string and deﬁne DD(cid:48) by string concatenation.
This presentation ensures
that multiplication
(7) is a complete and associative (though not
commutative) operation, as in any semiring. As
base cases, each real-valued element of Mi(l)
or Mk(r) is now paired with the string [l or r]
respectively,11 and the real number 1 at line 10 is
paired with the string w. The real-valued elements
of the λi and ρi vectors and the 0 matrix at line 11
are paired with the empty string (cid:15), as is the real
number p at line 13.

In practice, the D strings that appear within the
matrix M of Algorithm 1 will always represent
complete punctuated trees. Thus, they can actu-
ally be represented in memory as such, and differ-
ent trees may share subtrees for efﬁciency (using
pointers). The product in line 10 constructs a ma-
trix of trees with root w and differing sequences
of left/right children, while the product in line 14
annotates those trees with punctemes l, r.

To sample a possible T (cid:48) from the derivation for-
est in proportion to its probability (§6.1), we use
the same algorithm but replace equation (6) with

(r, D) + (r(cid:48), D(cid:48)) =

(cid:40)

if u < r
(r + r(cid:48), D)
r+r(cid:48)
(r + r(cid:48), D(cid:48)) otherwise

with u ∼ Uniform(0, 1) being a random number.

3.2 Optimization

Having computed the objective (5), we ﬁnd the
gradient via automatic differentiation, and opti-
mize θ, φ via Adam (Kingma and Ba, 2014)—a
variant of stochastic gradient decent—with learn-
ing rate 0.07, batchsize 5, sentence per epoch
400, and L2 regularization. (These hyperparam-
eters, along with the regularization coefﬁcients ς
and ξ from equation (5), were tuned on dev data
(§4) for each language respectively.) We train
the punctuation model for 30 epochs. The initial
NOISYCHANNEL parameters (φ) are drawn from
N (0, 1), and the initial ATTACH parameters (θ)
are drawn from N (0, 1) (with one minor excep-
tion described in Appendix A).

11We still construct the real matrix Mi(l) by ordinary ma-
trix multiplication before pairing its elements with strings.
This involves summation of real numbers: each element of
the resulting real matrix is a marginal probability, which sums
over possible PFST paths (edit sequences) that could map the
underlying puncteme l to a certain substring of the surface
slot xi. Similarly for Mk(r).

362

4

Intrinsic Evaluation of the Model

Data. Throughout §§4–6, we will examine the
punctuation model on a subset of the Univer-
sal Dependencies (UD) version 1.4 (Nivre et al.,
2016)—a collection of dependency treebanks
across 47 languages with uniﬁed POS-tag and de-
pendency label sets. Each treebank has designated
training, development, and test portions. We ex-
periment on Arabic, English, Chinese, Hindi, and
Spanish (Table 2)—languages with diverse punc-
tuation vocabularies and punctuation interaction
rules, not to mention script directionality. For each
treebank, we use the tokenization provided by UD,
and take the punctuation tokens (which may be
multi-character, such as ...) to be the tokens with
the PUNCT tag. We replace each straight dou-
ble quotation mark " with either “ or ” as appro-
priate, and similarly for single quotation marks.12
We split each non-punctuation token that ends in
. (such as etc.) into a shorter non-punctuation
token (etc) followed by a special punctuation to-
ken called the “abbreviation dot” (which is distinct
from a period). We prepend a special punctuation
mark ˆ to every sentence ¯x, which can serve to
absorb an initial comma, for example.13 We then
replace each token with the special symbol UNK if
its type appeared fewer than 5 times in the training
portion. This gives the surface sentences.

To estimate the vocabulary V of underlying
punctemes, we simply collect all surface token se-
quences xi that appear at any slot in the training
portion of the processed treebank. This is a gener-
ous estimate. Similarly, we estimate Wd (§2.1) as
all pairs (l, r) ∈ V 2 that ﬂank any d constituent.

Recall that our model generates surface punctu-
ation given an unpunctuated dependency tree. We
train it on each of the 5 languages independently.
We evaluate on conditional perplexity, which will
be low if the trained model successfully assigns a
high probability to the actual surface punctuation
in a held-out corpus of the same language.

Baselines. We compare our model against three
baselines to show that its complexity is necessary.
Our ﬁrst baseline is an ablation study that does not
use latent underlying punctuation, but generates
the surface punctuation directly from the tree. (To

Language Treebank #Token %Punct #Omit #Type
282K
Arabic
123K
Chinese
255K
97.7K
352K
es_ancora 560K

ar
zh
en
en_esl
hi

7.9
13.8
11.7
9.8
6.7
11.7

255
3
40
2
21
25

18
23
35
16
15
16

Hindi
Spanish

English

Table 2: Statistics of our datasets. “Treebank” is the
UD treebank identiﬁer, “#Token” is the number of to-
kens, “%Punct” is the percentage of punctuation to-
kens, “#Omit” is the small number of sentences con-
taining non-leaf punctuation tokens (see footnote 19),
and “#Type” is the number of punctuation types after
preprocessing. (Recall from §4 that preprocessing dis-
tinguishes between left and right quotation mark types,
and between abbreviation dot and period dot types.)

implement this, we ﬁx the parameters of the noisy
channel so that the surface punctuation equals the
underlying with probability 1.) If our full model
performs signiﬁcantly better, it will demonstrate
the importance of a distinct underlying layer.

Our other two baselines ignore the tree struc-
ture, so if our full model performs signiﬁcantly
better, it will demonstrate that conditioning on ex-
plicit syntactic structure is useful. These baselines
are based on previously published approaches that
reduce the problem to tagging: Xu et al. (2016)
use a BiLSTM-CRF tagger with bigram topology;
Tilk and Alumäe (2016) use a BiGRU tagger with
attention. In both approaches, the model is trained
to tag each slot i with the correct string xi ∈ V ∗
(possibly (cid:15) or ˆ). These are discriminative proba-
bilistic models (in contrast to our generative one).
Each gives a probability distribution over the tag-
gings (conditioned on the unpunctuated sentence),
so we can evaluate their perplexity.14

Results. As shown in Table 3, our full model
beats the baselines in perplexity in all 5 languages.
Also,
in 4 of 5 languages, allowing a trained
NOISYCHANNEL (rather than the identity map)
signiﬁcantly improves the perplexity.

5 Analysis of the Learned Grammar

5.1 Rules Learned from the Noisy Channel

We study our learned probability distribution over
noisy channel rules (ab (cid:55)→ b, ab (cid:55)→ a, ab (cid:55)→ ab,

12For en and en_esl, “ and ” are distinguished by
language-speciﬁc part-of-speech tags. For the other 4 lan-
guages, we identify two " dependents of the same head word,
replacing the left one with “ and the right one with ”.

13For symmetry, we should also have added a ﬁnal mark.

14These methods learn word embeddings that optimize
log-likelihood on the punctuation restoration
conditional
training data. They might do better if these embeddings were
shared with other tasks, as multi-task learning might lead
them to discover syntactic categories of words.

363

CRF ATTACH +NC DIR

Attn.
1.4676 1.3016 1.2230 1.1526 L
Arabic
Chinese 1.6850 1.4436 1.1921 1.1464 L
English 1.5737 1.5247 1.5636 1.4276 R
1.1201 1.1032 1.0630 1.0598 L
Hindi
Spanish 1.4397 1.3198 1.2364 1.2103 R

Table 3: Results of the conditional perplexity experi-
ment (§4), reported as perplexity per punctuation slot,
where an unpunctuated sentence of n words has n + 1
slots. Column “Attn.” is the BiGRU tagger with atten-
tion, and “CRF” stands for the BiLSTM-CRF tagger.
“ATTACH” is the ablated version of our model where
surface punctuation is directly attached to the nodes.
Our full model “+NC” adds NOISYCHANNEL to trans-
duce the attached punctuation into surface punctuation.
DIR is the learned direction (§2.2) of our full model’s
noisy channel PFST: Left-to-right or Right-to-left. Our
models are given oracle parse trees T . The best per-
plexity is boldfaced, along with all results that are not
signiﬁcantly worse (paired permutation test, p < 0.05).

ab(cid:55)→ba) for English. The probability distributions
corresponding to six of Nunberg’s English rules
are shown in Figure 3. By comparing the orange
and blue bars, observe that the model trained on
the en_cesl treebank learned different quotation
rules from the one trained on the en treebank. This
is because en_cesl follows British style, whereas
en has American-style quote transposition.15

We now focus on the model learned from the
en treebank. Nunberg’s rules are deterministic,
and our noisy channel indeed learned low-entropy
rules, in the sense that for an input ab with un-
derlying count ≥ 25,16 at least one of the possi-
ble outputs (a, b, ab or ba) always has probability
> 0.75. The one exception is ”. (cid:55)→ .” for which
the argmax output has probability ≈ 0.5, because
writers do not apply this quote transposition rule
consistently. As shown by the blue bars in Fig-
ure 3, the high-probability transduction rules are
consistent with Nunberg’s hand-crafted determin-
istic grammar in Table 1.

Our system has high precision when we look at
the conﬁdent rules. Of the 24 learned edits with
conditional probability > 0.75, Nunberg lists 20.
Our system also has good recall. Nunberg’s

15American style places commas and periods inside the
quotation marks, even if they are not logically in the quote.
British style (more sensibly) places unquoted periods and
commas in their logical place, sometimes outside the quo-
tation marks if they are not part of the quote.

16For rarer underlying pairs ab, the estimated distributions

sometimes have higher entropy due to undertraining.

Figure 3: Rewrite probabilities learned for English,
averaged over the last 4 epochs on en treebank (blue
bars) or en_esl treebank (orange bars). The header
above each ﬁgure is the underlying punctuation string
(input to NOISYCHANNEL). The two counts in the ﬁg-
ure headers are the number of occurrences of the under-
lying punctuation strings in the 1-best reconstruction of
underlying punctuation sequences (by Algorithm 1) re-
spectively in the en and en_esl treebank. Each bar
represents one surface punctuation string (output of
NOISYCHANNEL), its height giving the probability.

hand-crafted schemata consider 16 punctuation
types and generate a total of 192 edit rules, in-
cluding the specimens in Table 1. That is, of the
162 = 256 possible underlying punctuation bi-
grams ab, 3
4 are supposed to undergo absorption
or transposition. Our method achieves fairly high
recall, in the sense that when Nunberg proposes
ab(cid:55)→γ, our learned p(γ | ab) usually ranks highly
among all probabilities of the form p(γ(cid:48) | ab). 75
of Nunberg’s rules got rank 1, 48 got rank 2, and
the remaining 69 got rank > 2. The mean recipro-
cal rank was 0.621. Recall is quite high when we
restrict to those Nunberg rules ab (cid:55)→ γ for which
our model is conﬁdent how to rewrite ab, in the
sense that some p(γ(cid:48)
(This tends
to eliminate rare ab: see footnote 5.) Of these 55
Nunberg rules, 38 rules got rank 1, 15 got rank 2,
and only 2 got rank worse than 2. The mean recip-
rocal rank was 0.836.

| ab) > 0.5.

¿What about Spanish? Spanish uses inverted
question marks ¿ and exclamation marks ¡, which
form symmetric pairs with the regular question
If we try to ex-
marks and exclamation marks.
trapolate to Spanish from Nunberg’s English for-
malization, the English mark most analogous to ¿
is (. Our learned noisy channel for Spanish (not
graphed here) includes the high-probability rules
,¿ (cid:55)→ ,¿ and :¿ (cid:55)→ :¿ and ¿, (cid:55)→ ¿ which match
Nunberg’s treatment of ( in English.

364

, , , 0.00.20.40.60.8, ,  count=331||196, . , . . , 0.000.250.500.751.00, .  count=723||900'' .'' . . ''0.00.20.40.60.8'' .  count=43||22. ''. '' '' .0.00.20.40.60.8. ''  count=20||14! . ! . . ! 0.00.20.40.6! .  count=17||17- , - , , - 0.00.20.40.60.8- ,  count=25||85.2 Attachment Model

What does our model learn about how dependency
relations are marked by underlying punctuation?

,advmod,

root.

,“ccomp”

,nmod,

ˆ,Earlier, Kerry said ,“ ... ,in fact, answer the question”.
ˆ Earlier, Kerry said ,“ ... ,in fact, answer the question.”

The above example17 illustrates the use of speciﬁc
puncteme pairs to set off the advmod, ccomp,
and nmod relations. Notice that said takes
a complement (ccomp) that
is symmetrically
quoted but also left delimited by a comma, which
is indeed how direct speech is punctuated in
English. This example also illustrates quotation
transposition. The top ﬁve relations that are most
likely to generate symmetric punctemes and their
top (l, r) pairs are shown in Table 4.

conj

,conj,

,conj,

cc

Section 1
Section 1

,2 , ,... 7 , and 8 ...
,... 7 , and 8 ...
,2

The above example18 shows how our model han-
dles commas in conjunctions of 2 or more phrases.
UD format dictates that each conjunct after the
ﬁrst is attached by the conj relation. As shown
above, each such conjunct is surrounded by under-
lying commas (via the N.,.,.conj feature from
Appendix A), except for the one that bears the
conjunction and (via an even stronger weight on
−−−→conj.cc feature). Our learned feature
the C.(cid:15).(cid:15).
weights indeed yield p((cid:96) = (cid:15), r = (cid:15)) > 0.5 for the
ﬁnal conjunct in this example. Some writers omit
the “Oxford comma” before the conjunction: this
style can be achieved simply by changing “sur-
rounded” to “preceded” (that is, changing the N
feature to N.,.(cid:15).conj).

6 Performance on Extrinsic Tasks

We evaluate the trained punctuation model by us-
ing it in the following three tasks.

6.1 Punctuation Restoration

In this task, we are given a depunctuated sentence
¯d19 and must restore its (surface) punctuation. Our
model supposes that the observed punctuated sen-
tence ¯x would have arisen via the generative pro-

17[en] Earlier, Kerry said, “Just because you
get an honorable discharge does not, in fact,
answer that question.”

18[en]

Sections 1, 2, 5, 6, 7, and 8 will

survive any termination of this License.

19 To depunctuate a treebank sentence, we remove all to-
kens with POS-tag PUNCT or dependency relation punct.
These are almost always leaves; else we omit the sentence.

parataxis appos
2.29

2.38
, , 26.8
(cid:15) (cid:15)
20.1
( ) 13.0
- (cid:15)
9.7
: (cid:15)
8.1

ccomp
0.53

advcl
0.77

list
1.33
, , 18.8 (cid:15) (cid:15) 60.0 (cid:15) (cid:15) 73.8
90.8
: (cid:15) 18.1 , , 22.3 , , 21.2 “ ” 2.4
- (cid:15) 15.9 , (cid:15) 5.3 (cid:15) , 3.1
, , 2.4
(cid:15) (cid:15) 14.4 < > 3.0 ( ) 0.74 :“ ” 0.9
( ) 13.1 ( ) 3.0 (cid:15) - 0.21 “ ,” 0.8

(cid:15) (cid:15)

Table 4: The top 5 relations that are most likely to
generate symmetric punctemes, the entropy of their
puncteme pair (row 2), and their top 5 puncteme pairs
(rows 3–7) with their probabilities shown as percent-
ages. The symmetric punctemes are in boldface.

cess (1). Thus, we try to ﬁnd T , T (cid:48), and ¯x that are
consistent with ¯d (a partial observation of ¯x).

The ﬁrst step is to reconstruct T from ¯d. This
initial parsing step is intended to choose the T that
maximizes psyn(T | ¯d).20 This step depends only
on psyn and not on our punctuation model (pθ, pφ).
In practice, we choose T via a dependency parser
that has been trained on an unpunctuated treebank
with examples of the form (¯d, T ).21

Equation (2) now deﬁnes a distribution over
(T (cid:48), x) given this T . To obtain a single prediction
for x, we adopt the minimum Bayes risk (MBR)
approach of choosing surface punctuation ˆx that
minimizes the expected loss with respect to the
unknown truth x∗. Our loss function is the total
edit distance over all slots (where edits operate on
punctuation tokens). Finding ˆx exactly would be
intractable, so we use a sampling-based approx-
imation and draw m = 1000 samples from the
posterior distribution over (T (cid:48), x). We then deﬁne

ˆx = argmin
x∈S(T )

(cid:88)

x∗∈S(T )

ˆp(x∗|T ) · loss(x, x∗) (10)

where S(T ) is the set of unique x values in the
sample and ˆp is the empirical distribution given by
the sample. This can be evaluated in O(m2) time.
We evaluate on Arabic, English, Chinese,
Hindi, and Spanish. For each language, we train
both the parser and the punctuation model on
the training split of that UD treebank (§4), and
evaluate on held-out data. We compare to the
BiLSTM-CRF baseline in §4 (Xu et al., 2016).22

20Ideally, rather than maximize, one would integrate over
possible trees T , in practice by sampling many values Tk
from psyn(· | ¯u) and replacing S(T ) in (10) with (cid:83)
k S(Tk).
the Yara parser (Rasooli and Tetreault,
2015), a fast non-probabilistic transition-based parser that
uses rich non-local features (Zhang and Nivre, 2011).

21Speciﬁcally,

22We copied their architecture exactly but re-tuned the hy-
perparameters on our data. We also tried tripling the amount
of training data by adding unannotated sentences (provided

365

ticularly low for Chinese and Arabic). The graph
in Figure 4 explores this relationship, by evaluat-
ing (on dev data) with noisier trees obtained from
parsers that were variously trained on only the ﬁrst
10%, 20%, . . . of the training data. On all 5 lan-
guages, provided that the trees are at least 75%
correct, our punctuation model beats both the triv-
ial baseline and the BiLSTM-CRF (which do not
use trees). It also beats the ATTACH ablation base-
line at all levels of tree accuracy (these curves are
omitted from the graph to avoid clutter). In all lan-
guages, better parses give better performance, and
gold trees yield the best results.

6.2 Punctuation Correction

Our next goal is to correct punctuation errors in
a learner corpus. Each sentence is drawn from
the Cambridge Learner Corpus treebanks, which
provide original (en_esl) and corrected (en_cesl)
sentences. All kinds of errors are corrected, such
as syntax errors, but we use only the 30% of sen-
tences whose depunctuated trees T are isomorphic
between en_esl and en_cesl. These en_cesl
trees may correct word and/or punctuation errors
in en_esl, as we wish to do automatically.

We assume that an English learner can make
mistakes in both the attachment and the noisy
channel steps. A common attachment mistake is
the failure to surround a non-restrictive relative
clause with commas.
In the noisy channel step,
mistakes in quote transposition are common.

T (cid:48)
c

(cid:80)

psyn(T | ¯xe) · pθ(T (cid:48)

Correction model. Based on the assumption
about the two error sources, we develop a dis-
Let ¯xe de-
criminative model for this task.
note the full input sentence, and let xe and xc
denote the input (possibly errorful) and output
(corrected) punctuation sequences. We model
p(xc | ¯xe) = (cid:80)
c |
T
T, xe) · pφ(xc | T (cid:48)
c). Here T is the depunctu-
ated parse tree, T (cid:48)
c is the corrected underlying tree,
T (cid:48)
e is the error underlying tree, and we assume
p(T (cid:48)
pθ(T (cid:48)
e).
In practice we use a 1-best pipeline rather than
summing. Our ﬁrst step is to reconstruct T from
the error sentence ¯xe. We choose T that max-
imizes psyn(T | ¯xe) from a dependency parser
trained on en_esl treebank examples (¯xe, T ). The
second step is to reconstruct T (cid:48)
e based on our punc-
tuation model trained on en_esl. We choose T (cid:48)
e
that maximizes p(T (cid:48)
e | T, xe). We then reconstruct
T (cid:48)
c by

c | T, xe) = (cid:80)
T (cid:48)
e

e | T, xe) · pθ(T (cid:48)

c | T (cid:48)

p

8 ATTACH a--

--a

Arabic 0.064 0.064 0.063
Chinese 0.110 0.109 0.104
English 0.100 0.108 0.092
0.025 0.023 0.019
Hindi
Spanish 0.093 0.092 0.085

0.059 0.053
0.102 0.048
0.090 0.079
0.018 0.013
0.078 0.068

Figure 4: Edit distance per slot (which we call average
edit distance, or AED) for each of the 5 corpora. Lower
is better. The table gives the ﬁnal AED on the test data.
Its ﬁrst 3 columns show the baseline methods just as in
Table 3: the trivial deterministic method, the BiLSTM-
CRF, and the ATTACH ablation baseline that attaches
the surface punctuation directly to the tree. Column 4
is our method that incorporates a noisy channel, and
column 5 (in gray) is our method using oracle (gold)
trees. We boldface the best non-oracle result as well as
all that are not signiﬁcantly worse (paired permutation
test, p < 0.05). The curves show how our method’s
AED (on dev data) varies with the labeled attachment
score (LAS) of the trees, where --a at x = 100 uses
the oracle (gold) trees, a-- at x < 100 uses trees from
our parser trained on 100% of the training data, and the
-- points at x (cid:28) 100 use increasingly worse parsers.
The p and 8 at the right of the graph show the AED of
(cid:35)
the trivial deterministic baseline and the BiLSTM-CRF
baseline, which do not use trees.

We also compare to a “trivial” deterministic base-
line, which merely places a period at the end of the
sentence (or a "|" in the case of Hindi) and adds no
other punctuation. Because most slots do not in
fact have punctuation, the trivial baseline already
does very well; to improve on it, we must ﬁx its
errors without introducing new ones.

Our ﬁnal comparison on test data is shown in
the table in Figure 4. On all 5 languages, our
method beats (usually signiﬁcantly) its 3 com-
petitors:
the
BiLSTM-CRF, and the ablated version of our
model (ATTACH) that omits the noisy channel.

the trivial deterministic baseline,

Of course, the success of our method depends
on the quality of the parse trees T (which is par-

along with the original annotated sentences by Ginter et al.
(2017)), taking advantage of the fact that the BiLSTM-CRF
does not require its training sentences to be annotated with
trees. However, this actually hurt performance slightly, per-
haps because the additional sentences were out-of-domain.
We also tried the BiGRU-with-attention architecture of Tilk
and Alumäe (2016), but it was also weaker than the BiLSTM-
CRF (just as in Table 3). We omit all these results from Fig-
ure 4 to reduce clutter.

366

5060708090100Labeled Attachment Score (LAS)0.020.040.060.080.100.12Average Edit Distance (AED)p

8

parsed gold 8-corr
a--
AED 0.052 0.051 0.047 0.034 0.033 0.005
F0.5 0.779 0.787 0.827 0.876 0.881 0.984

Table 5: AED and F0.5 results on the test split of
English-ESL data. Lower AED is better; higher F0.5
is better. The ﬁrst three columns (markers corre-
spond to Figure 4) are the punctuation restoration base-
lines, which ignore the input punctuation. The fourth
and ﬁfth columns are our correction models, which
use parsed and gold trees. The ﬁnal column is the
BiLSTM-CRF model tailored for the punctuation cor-
rection task.

p(T (cid:48)

c | T (cid:48)

e) = (cid:81)

we∈T (cid:48)
e

p(l, r | we)

(11)

where we is the node in T (cid:48)
e, and p(l, r | we) is a
similar log-linear model to equation (4) with addi-
tional features (Appendix C4) which look at we.

Finally, we reconstruct xc based on the noisy
channel pφ(xc | T (cid:48)
c) in §2.2. During training, φ is
regularized to be close to the noisy channel param-
eters in the punctuation model trained on en_cesl.
We use the same MBR decoder as in §6.1 to
choose the best action. We evaluate using AED
as in §6.1. As a second metric, we use the script
from the CoNLL 2014 Shared Task on Grammati-
cal Error Correction (Ng et al., 2014): it computes
the F0.5-measure of the set of edits found by the
system, relative to the true set of edits.

As shown in Table 5, our method achieves bet-
ter performance than the punctuation restoration
baselines (which ignore input punctuation). On
the other hand, it is soundly beaten by a new
BiLSTM-CRF that we trained speciﬁcally for the
task of punctuation correction. This is the same
as the BiLSTM-CRF in the previous section, ex-
cept that the BiLSTM now reads a punctuated
input sentence (with possibly erroneous punctua-
tion). To be precise, at step 0 ≤ i ≤ n, the BiL-
STM reads a concatenation of the embedding of
word i (or BOS if i = 0) with an embedding of
the punctuation token sequence xi. The BiLSTM-
CRF wins because it is a discriminative model tai-
lored for this task: the BiLSTM can extract arbi-
trary contextual features of slot i that are corre-
lated with whether xi is correct in context.

its that are suggested by a writing assistance tool
(Heidorn, 2000), or subtree deletions in compres-
sive summarization (Knight and Marcu, 2002).

For our experiment, we evaluate an interesting
case of syntactic transformation. Wang and Eis-
ner (2016) consider a systematic rephrasing pro-
cedure by rearranging the order of dependent sub-
trees within a UD treebank, in order to synthesize
new languages with different word order that can
then be used to help train multi-lingual systems
(i.e., data augmentation with synthetic data).

As Wang and Eisner acknowledge (2016, foot-
note 9), their permutations treat surface punctua-
tion tokens like ordinary words, which can result
in synthetic sentences whose punctuation is quite
unlike that of real languages.

In our experiment, we use Wang and Eisner’s
(2016) “self-permutation” setting, where the de-
pendents of each noun and verb are stochastically
reordered, but according to a dependent ordering
model that has been trained on the same language.
rephrasing a English sentence
For example,

advcl

punct

root

mark

det
SCONJ
If true , the caper failed .

nsubj

PUNCT

VERB

NOUN

ADJ

DET

PUNCT

punct

under an English ordering model may yield

det

nsubj
DET
the caper failed .

punct

VERB

NOUN

root

punct

advcl
PUNCT SCONJ

mark

ADJ
If true ,

PUNCT

which is still grammatical except that , and . are
wrongly swapped (after all, they have the same
POS tag and relation type). Worse, permutation
may yield bizarre punctuation such as , , at the
start of a sentence.

Our punctuation model gives a straightforward
remedy—instead of permuting the tree directly,
we ﬁrst discover its most likely underlying tree
,advcl,

root.

mark

det
ˆ, If true, the caper failed .

nsubj

by the maximizing variant of Algorithm 1 (§3.1).
Then, we permute the underlying tree and sample
the surface punctuation from the distribution
modeled by the trained PFST, yielding

det

nsubj

root.

,advcl,

mark

ˆthe caper failed ,If true ,.
ˆthe caper failed ,If true .

We

6.3 Sentential Rephrasing

We suspect that syntactic transformations on a
sentence should often preserve the underlying
punctuation attached to its tree. The surface punc-
tuation can then be regenerated from the trans-
formed tree. Such transformations include ed-

leave the handling of capitalization to future work.
We test the naturalness of the permuted sen-
tences by asking how well a word trigram lan-
guage model trained on them could predict the
original sentences.23 As shown in Table 6, our per-

23So the two approaches to permutation yield different

367

Punctuation

All

Base Half Full Base Half Full
Arabic 156.0 231.3 186.1 540.8 590.3 553.4
Chinese 165.2 110.0 61.4 205.0 174.4 78.7
English 98.4 74.5 51.0 140.9 131.4 75.4
118.4 118.8 91.8
Hindi
Spanish 266.2 259.2 194.5 346.3 343.4 239.3

10.8 11.0 9.7

“All” evaluates on all

Table 6: Perplexity (evaluated on the train split to
avoid evaluating generalization) of a trigram language
model trained (with add-0.001 smoothing) on differ-
ent versions of rephrased training sentences. “Punc-
tuation” only evaluates perplexity on the trigrams that
the tri-
have punctuation.
grams. “Base” permutes all surface dependents includ-
ing punctuation (Wang and Eisner, 2016). “Full” is
our full approach: recover underlying punctuation, per-
mute remaining dependents, regenerate surface punc-
tuation. “Half” is like “Full” but it permutes the non-
punctuation tokens identically to “Base.” The permu-
tation model is trained on surface trees or recovered
underlying trees T (cid:48), respectively. In each 3-way com-
parison, we boldface the best result (always signiﬁcant
under a paired permutation test over per-sentence log-
probabilities, p < 0.05).

mutation approach reduces the perplexity over the
baseline on 4 of the 5 languages, often dramati-
cally.

7 Related Work

Punctuation can aid syntactic analysis, since it
signals phrase boundaries and sentence structure.
Briscoe (1994) and White and Rajkumar (2008)
parse punctuated sentences using hand-crafted
constraint-based grammars that implement Nun-
berg’s approach in a declarative way. These gram-
mars treat surface punctuation symbols as ordi-
nary words, but annotate the nonterminal cate-
gories so as to effectively keep track of the under-
lying punctuation. This is tantamount to crafting
a grammar for underlyingly punctuated sentences
and composing it with a ﬁnite-state noisy channel.
The parser of Ma et al. (2014) takes a differ-
ent approach and treats punctuation marks as fea-
tures of their neighboring words. Zhang et al.
(2013) use a generative model for punctuated sen-
tences, leting them restore punctuation marks dur-
ing transition-based parsing of unpunctuated sen-
tences. Li et al. (2005) use punctuation marks to
segment a sentence: this "divide and rule" strat-
egy reduces ambiguity in parsing of long Chinese
sentences. Punctuation can similarly be used to

training data, but are compared fairly on the same test data.

constrain syntactic structure during grammar in-
duction (Spitkovsky et al., 2011).

Punctuation restoration (§6.1) is useful for tran-
scribing text from unpunctuated speech. The task
is usually treated by tagging each slot with zero
or more punctuation tokens, using a traditional
sequence labeling method: conditional random
ﬁelds (Lui and Wang, 2013; Lu and Ng, 2010), re-
current neural networks (Tilk and Alumäe, 2016),
or transition-based systems (Ballesteros and Wan-
ner, 2016).

8 Conclusion and Future Work

We have provided a new computational approach
to modeling punctuation. In our model, syntactic
constituents stochastically generate latent under-
lying left and right punctemes. Surface punctu-
ation marks are not directly attached to the syn-
tax tree, but are generated from sequences of adja-
cent punctemes by a (stochastic) ﬁnite-state string
rewriting process . Our model is inspired by Nun-
berg’s (1990) formal grammar for English punctu-
ation, but is probabilistic and trainable. We give
exact algorithms for training and inference.

We trained Nunberg-like models for 5 lan-
guages and L2 English. We compared the English
model to Nunberg’s, and showed how the trained
models can be used across languages for punctua-
tion restoration, correction, and adjustment.

In the future, we would like to study the
usefulness of the recovered underlying trees on
tasks such as syntactically sensitive sentiment
analysis (Tai et al., 2015), machine translation
(Cowan et al., 2006), relation extraction (Cu-
lotta and Sorensen, 2004), and coreference reso-
lution (Kong et al., 2010). We would also like
to investigate how underlying punctuation could
aid parsing. For discriminative parsing, features
for scoring the tree could refer to the underly-
ing punctuation, not just the surface punctuation.
For generative parsing (§3), we could follow the
scheme in equation (1). For example, the psyn
factor in equation (1) might be a standard re-
current neural network grammar (RNNG) (Dyer
et al., 2016); when a subtree of T is completed by
the REDUCE operation of psyn, the punctuation-
augmented RNNG (1) would stochastically attach
subtree-external left and right punctemes with pθ
and transduce the subtree-internal slots with pφ.

In the future, we are also interested in enriching
the T (cid:48) representation and making it more differ-

368

ent from T , to underlyingly account for other phe-
nomena in T such as capitalization, spacing, mor-
phology, and non-projectivity (via reordering).

Acknowledgments

This material is based upon work supported by
the National Science Foundation under Grant Nos.
1423276 and 1718846, including a REU supple-
ment to the ﬁrst author. We are grateful to the state
of Maryland for the Maryland Advanced Research
Computing Center, a crucial resource. We thank
Xiaochen Li for early discussion, Argo lab mem-
bers for further discussion, and the three reviewers
for quality comments.

References

Apoorv Agarwal, Boyi Xie, Ilia Vovsha, Owen
Rambow, and Rebecca Passonneau. 2011. Sen-
timent analysis of Twitter data. In Proceedings
of the Workshop on Language in Social Media
(LSM 2011), pages 30–38.

Miguel Ballesteros and Leo Wanner. 2016. A neu-
ral network architecture for multilingual punc-
tuation generation. In Proceedings of the 2016
Conference on Empirical Methods in Natural
Language Processing, pages 1048–1053.

On formal properties of

Yehoshua Bar-Hillel, M. Perles, and E. Shamir.
simple
1961.
für
phrase structure grammars.
Phonetik, Sprachwissenschaft und Kommunika-
tionsforschung, 14:143–172. Reprinted in Y.
Bar-Hillel (1964), Language and Information:
Selected Essays on their Theory and Applica-
tion, Addison-Wesley 1964, pages 116–150.

Zeitschrift

Jean Berstel and Christophe Reutenauer. 1988.
Rational Series and their Languages. Springer-
Verlag.

Ann Bies, Mark Ferguson, Karen Katz, Robert
MacIntyre, Victoria Tredinnick, Grace Kim,
Mary Ann Marcinkiewicz, and Britta Schas-
berger. 1995. Bracketing guidelines for Tree-
bank II style: Penn Treebank project. Technical
Report MS-CIS-95-06, University of Pennsyl-
vania.

Ted Briscoe. 1994. Parsing (with) punctuation,
etc. Technical report, Xerox European Re-
search Laboratory.

369

Danqi Chen and Christopher Manning. 2014. A
fast and accurate dependency parser using neu-
ral networks. In Proceedings of the 2014 Con-
ference on Empirical Methods in Natural Lan-
guage Processing (EMNLP), pages 740–750.

Noam Chomsky and Morris Halle. 1968. The
Sound Pattern of English. Harper and Row,
New York.

Ryan Cotterell, Nanyun Peng, and Jason Eisner.
2014. Stochastic contextual edit distance and
probabilistic FSTs. In Proceedings of the 52nd
Annual Meeting of the Association for Compu-
tational Linguistics (Volume 2: Short Papers),
pages 625–630.

Ryan Cotterell, Nanyun Peng, and Jason Eisner.
2015. Modeling word forms using latent under-
lying morphs and phonology. Transactions of
the Association for Computational Linguistics
(TACL), 3:433–447.

Ryan Cotterell, Tim Vieira, and Hinrich Schütze.
2016. A joint model of orthography and mor-
In Proceedings of
phological segmentation.
the 2016 Conference of the North American
Chapter of the Association for Computational
Linguistics: Human Language Technologies
(NAACL-HLT), pages 664–669.

Brooke Cowan, Ivona Kuˇcerová, and Michael
Collins. 2006. A discriminative model for tree-
to-tree translation. In Proceedings of the 2006
Conference on Empirical Methods in Natural
Language Processing (EMNLP), pages 232–
241.

Aron Culotta and Jeffrey Sorensen. 2004. De-
pendency tree kernels for relation extraction.
In Proceedings of the 42nd Annual Meeting of
the Association for Computational Linguistics
(ACL).

Timothy Dozat and Christopher Manning. 2017.
Efﬁcient third-order dependency parsers.
In
Proceedings of the 5th International Confer-
ence on Learning Representations (ICLR).

Chris Dyer, Adhiguna Kuncoro, Miguel Balles-
teros, and Noah A. Smith. 2016. Recurrent
In Proceedings of
neural network grammars.
the 2016 Conference of the North American
Chapter of the Association for Computational

Linguistics: Human Language Technologies
(NAACL-HLT), pages 199–209.

Jason Eisner. 1996. Three new probabilistic mod-
els for dependency parsing: An exploration. In
Proceedings of the 16th International Confer-
ence on Computational Linguistics (COLING),
pages 340–345.

Jason Eisner. 2016.

Inside-outside and forward-
backward algorithms are just backprop. In Pro-
ceedings of the EMNLP Workshop on Struc-
tured Prediction for NLP.

A. Caracciolo di Forino. 1968. String process-
ing languages and generalized Markov algo-
rithms. In D. G. Bobrow, editor, Symbol Manip-
ulation Languages and Techniques, pages 191–
206. North-Holland Publishing Company, Am-
sterdam.

Kuzman Ganchev, Jennifer Gillenwater, and Ben
Taskar. 2010. Posterior regularization for struc-
tured latent variable models. Journal of Ma-
chine Learning Research, 11:2001–2049.

Filip Ginter, Jan Hajiˇc, Juhani Luotolahti, Milan
Straka, and Daniel Zeman. 2017. CoNLL 2017
shared task - automatically annotated raw texts
and word embeddings. LINDAT/CLARIN dig-
ital library at the Institute of Formal and Ap-
plied Linguistics (ÚFAL), Faculty of Mathe-
matics and Physics, Charles University.

Yoav Goldberg and Michael Elhadad. 2010. An
efﬁcient algorithm for easy-ﬁrst non-directional
In Human Language
dependency parsing.
Technologies: The 2010 Annual Conference of
the North American Chapter of the Association
for Computational Linguistics (NAACL-HLT),
pages 742–750.

Joshua Goodman. 1999. Semiring parsing. Com-

putational Linguistics, 25(4):573–605.

George Heidorn. 2000.

Intelligent writing assis-
In Robert Dale, Herman Moisl, and
tance.
Harold Somers, editors, Handbook of Natural
Language Processing, pages 181–207. Marcel
Dekker, New York.

C. Douglas Johnson. 1972. Formal Aspects of

Phonological Description. Mouton.

Bernard E. M. Jones. 1994. Exploring the role of
punctuation in parsing natural text. In COLING
1994 Volume 1: The 15th International Confer-
ence on Computational Linguistics.

Diederik Kingma and Jimmy Ba. 2014. Adam: A
method for stochastic optimization. In Proceed-
ings of the International Conference on Learn-
ing Representations (ICLR).

Eliyahu Kiperwasser and Yoav Goldberg. 2016.
Simple and accurate dependency parsing us-
ing bidirectional LSTM feature representations.
Transactions of the Association for Computa-
tional Linguistics (TACL), 4:313–327.

Kevin Knight and Daniel Marcu. 2002. Summa-
rization beyond sentence extraction: A proba-
bilistic approach to sentence compression. Ar-
tiﬁcial Intelligence, 139(1):91–107.

Fang Kong, Guodong Zhou, Longhua Qian, and
Qiaoming Zhu. 2010.
Dependency-driven
anaphoricity determination for coreference res-
In Proceedings of the 23rd Interna-
olution.
tional Conference on Computational Linguis-
tics (COLING), pages 599–607.

Terry Koo and Michael Collins. 2010. Efﬁcient
third-order dependency parsers. In Proceedings
of the 48th Annual Meeting of the Association
for Computational Linguistics (ACL), pages 1–
11.

Albert E. Krahn. 2014. A New Paradigm for
Punctuation. Ph.D. thesis, The University of
Wisconsin-Milwaukee.

Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay,
and Tommi Jaakkola. 2014. Low-rank tensors
for scoring dependency structures. In Proceed-
ings of the 52nd Annual Meeting of the As-
sociation for Computational Linguistics (ACL),
pages 1381–1391.

Roger Levy. 2008. A noisy-channel model of
human sentence comprehension under uncer-
In Proceedings of the 2008 Con-
tain input.
ference on Empirical Methods in Natural Lan-
guage Processing (EMNLP), pages 234–243.

Xing Li, Chengqing Zong, and Rile Hu. 2005. A
hierarchical parsing approach with punctuation
processing for long Chinese sentences. In Pro-
ceedings of the International Joint Conference
on Natural Language Processing (IJCNLP).

370

Zhifei Li and Jason Eisner. 2009.

First- and
second-order expectation semirings with appli-
cations to minimum-risk training on translation
In Proceedings of the Conference on
forests.
Empirical Methods in Natural Language Pro-
cessing (EMNLP), pages 40–51.

Wei Lu and Hwee Tou Ng. 2010. Better punctu-
ation prediction with dynamic conditional ran-
In Proceedings of the 2010 Con-
dom ﬁelds.
ference on Empirical Methods in Natural Lan-
guage Processing (EMNLP), pages 177–186.

Marco Lui and Li Wang. 2013.

Recovering
casing and punctuation using conditional ran-
dom ﬁelds. In Proceedings of the Australasian
Language Technology Association Workshop
(ALTA), pages 137–141.

Ji Ma, Yue Zhang, and Jingbo Zhu. 2014. Punc-
tuation processing for projective dependency
In Proceedings of the 52nd Annual
parsing.
Meeting of the Association for Computational
Linguistics (Volume 2: Short Papers), pages
791–796.

Gideon S. Mann and Andrew McCallum. 2010.
Generalized expectation criteria for
semi-
supervised learning with weakly labeled
data. Journal of Machine Learning Research,
11:955–984.

Andrey Andreevich Markov. 1960. The theory
of algorithms. American Mathematical Society
Translations, series 2(15):1–14.

Ilia Markov, Vivi Nastase, and Carlo Strappar-
ava. 2018. Punctuation as native language in-
In Proceedings of the 27th Inter-
terference.
national Conference on Computational Linguis-
tics (COLING), pages 3456–3466.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jef-
frey Dean. 2013. Efﬁcient estimation of word
representations in vector space. Computing Re-
search Repository (CoRR), arXiv:1301.3781.

Mark-Jan Nederhof and Giorgio Satta. 2003.
Probabilistic parsing as intersection. In 8th In-
ternational Workshop on Parsing Technologies
(IWPT), pages 137–148.

Hwee Tou Ng, Siew Mei Wu, Ted Briscoe, Chris-
tian Hadiwinoto, Raymond Hendy Susanto, and
Christopher Bryant. 2014. The CoNLL-2014

shared task on grammatical error correction.
In Proceedings of the Eighteenth Conference
on Computational Natural Language Learning:
Shared Task, pages 1–14.

Joakim Nivre, Željko Agi´c, Lars Ahrenberg,
Maria Jesus Aranzabe, Masayuki Asahara,
Aitziber Atutxa, Miguel Ballesteros,
John
Bauer, Kepa Bengoetxea, Yevgeni Berzak,
Riyaz Ahmad Bhat, Eckhard Bick, Carl
Börstell, Cristina Bosco, Gosse Bouma, Sam
Bowman, Gül¸sen Cebiro˘glu Eryi˘git, Giuseppe
G. A. Celano, Fabricio Chalub, Ça˘grı Çöl-
tekin, Miriam Connor, Elizabeth Davidson,
Marie-Catherine de Marneffe, Arantza Diaz de
Ilarraza, Kaja Dobrovoljc, Timothy Dozat,
Kira Droganova, Puneet Dwivedi, Marhaba
Eli, Tomaž Erjavec, Richárd Farkas, Jennifer
Foster, Claudia Freitas, Katarína Gajdošová,
Daniel Galbraith, Marcos Garcia, Moa Gär-
denfors, Sebastian Garza, Filip Ginter, Iakes
Goenaga, Koldo Gojenola, Memduh Gökır-
mak, Yoav Goldberg, Xavier Gómez Guino-
vart, Berta Gonzáles Saavedra, Matias Gri-
oni, Normunds Gr¯uz¯ıtis, Bruno Guillaume,
Jan Hajiˇc, Linh Hà M˜y, Dag Haug, Barbora
Hladká, Radu Ion, Elena Irimia, Anders Jo-
hannsen, Fredrik Jørgensen, Hüner Ka¸sıkara,
Hiroshi Kanayama,
Jenna Kanerva, Boris
Katz, Jessica Kenney, Natalia Kotsyba, Si-
mon Krek, Veronika Laippala, Lucia Lam,
Phuong Lê H`ông, Alessandro Lenci, Nikola
Ljubeši´c, Olga Lyashevskaya, Teresa Lynn,
Aibek Makazhanov, Christopher Manning,
C˘at˘alina M˘ar˘anduc, David Mareˇcek, Héctor
Martínez Alonso, André Martins, Jan Mašek,
Yuji Matsumoto, Ryan McDonald, Anna Mis-
silä, Verginica Mititelu, Yusuke Miyao, Simon-
etta Montemagni, Keiko Sophie Mori, Shun-
suke Mori, Bohdan Moskalevskyi, Kadri Muis-
chnek, Nina Mustaﬁna, Kaili Müürisep, Luong
Nguy˜ên Thi., Huy`ên Nguy˜ên Thi. Minh, Vitaly
Nikolaev, Hanna Nurmi, Petya Osenova, Robert
Östling, Lilja Øvrelid, Valeria Paiva, Elena Pas-
cual, Marco Passarotti, Cenel-Augusto Perez,
Slav Petrov, Jussi Piitulainen, Barbara Plank,
Martin Popel, Lauma Pretkalnin, a, Prokopis
Prokopidis, Tiina Puolakainen, Sampo Pyysalo,
Alexandre Rademaker, Loganathan Ramasamy,
Livy Real, Laura Rituma, Rudolf Rosa, Shadi
Saleh, Baiba Saul¯ıte, Sebastian Schuster, Wolf-
gang Seeker, Mojgan Seraji, Lena Shakurova,

371

Mo Shen, Natalia Silveira, Maria Simi, Radu
Simionescu, Katalin Simkó, Mária Šimková,
Kiril Simov, Aaron Smith, Carolyn Spadine,
Alane Suhr, Umut Sulubacak, Zsolt Szántó,
Takaaki Tanaka, Reut Tsarfaty, Francis Ty-
ers, Sumire Uematsu, Larraitz Uria, Gertjan
van Noord, Viktor Varga, Veronika Vincze,
Lars Wallin, Jing Xian Wang, Jonathan North
Washington, Mats Wirén, Zdenˇek Žabokrt-
ský, Amir Zeldes, Daniel Zeman, and Hanzhi
Universal Dependencies 1.4.
Zhu. 2016.
LINDAT/CLARIN digital
the In-
stitute of Formal and Applied Linguistics
(ÚFAL), Faculty of Mathematics and Physics,
Charles University. Data available at http:
//universaldependencies.org.

library at

Joakim Nivre, Johan Hall, Sandra Kübler, Ryan
McDonald, Jens Nilsson, Sebastian Riedel, and
Deniz Yuret. 2007a. The CoNLL 2007 shared
In Proceedings
task on dependency parsing.
of the CoNLL Shared Task Session of EMNLP-
CoNLL 2007, pages 915–932.

Joakim Nivre, Johan Hall, Jens Nilsson, Atanas
Chanev, Gül¸sen Eryigit, Sandra Kübler, Sve-
toslav Marinov, and Erwin Marsi. 2007b. Malt-
parser: A language-independent system for
data-driven dependency parsing. Natural Lan-
guage Engineering, 13(2):95–135.

Joakim Nivre et al. 2018. Universal depen-
dencies annotation guidelines. Available at
universaldependencies.org.

Geoffrey Nunberg. 1990. The Linguistics of Punc-
tuation. Number 18 in CSLI Lecture Notes.
Center for the Study of Language and Informa-
tion.

Bo Pang,

Thumbs up?

Lillian Lee,

and Shivakumar
Vaithyanathan. 2002.
Senti-
ment classiﬁcation using machine learning
the 2002
techniques.
Conference on Empirical Methods in Natural
Language Processing (EMNLP 2002).

In Proceedings of

Jeffrey Pennington, Richard Socher, and Christo-
pher Manning. 2014. GloVe: Global vectors
In Proceedings of
for word representation.
the 2014 Conference on Empirical Methods in
Natural Language Processing (EMNLP), pages
1532–1543.

372

Fernando C. N. Pereira and Michael D. Riley.
1996. Speech recognition by composition of
weighted ﬁnite automata. Computing Research
Repository (CoRR), arXiv:cmp-lg/9603001.

Mohammad Sadegh Rasooli and Joel R. Tetreault.
2015. Yara parser: A fast and accurate depen-
dency parser. Computing Research Repository,
arXiv:1503.06733 (version 2).

Radim ˇReh˚uˇrek and Petr Sojka. 2010. Software
framework for topic modelling with large cor-
pora. In Proceedings of the LREC 2010 Work-
shop on New Challenges for NLP Frameworks,
pages 45–50.

Valentin I. Spitkovsky, Hiyan Alshawi, and Daniel
Jurafsky. 2011. Punctuation: Making a point in
unsupervised dependency parsing. In Proceed-
ings of the Fifteenth Conference on Computa-
tional Natural Language Learning, CoNLL ’11,
pages 19–28.

Kai Sheng Tai, Richard Socher, and Christo-
Improved semantic
pher D. Manning. 2015.
representations from tree-structured long short-
term memory networks. In Proceedings of the
53rd Annual Meeting of the Association for
Computational Linguistics and the 7th Interna-
tional Joint Conference on Natural Language
Processing (ACL-COLING), pages 1556–1566.

Ottokar Tilk and Tanel Alumäe. 2016. Bidirec-
tional recurrent neural network with attention
mechanism for punctuation restoration. In In-
terspeech, pages 3047–3051.

Ke M. Tran, Yonatan Bisk, Ashish Vaswani,
Daniel Marcu, and Kevin Knight. 2016. Unsu-
pervised neural hidden Markov models. In Pro-
ceedings of the Workshop on Structured Predic-
tion for NLP, pages 63–71.

University of Chicago. 2010. The Chicago Man-

ual of Style. University of Chicago Press.

Dingquan Wang and Jason Eisner. 2016. The
Galactic Dependencies treebanks: Getting more
data by synthesizing new languages. Transac-
tions of the Association for Computational Lin-
guistics (TACL), 4:491–505.

Michael White and Rajakrishnan Rajkumar. 2008.
A more precise analysis of punctuation for
broad-coverage surface realization with CCG.

In Proceedings of the COLING 2008 Workshop
on Grammar Engineering Across Frameworks,
pages 17–24.

K. Xu, L. Xie, and K. Yao. 2016.

Investigat-
ing LSTM for punctuation prediction. In 2016
10th International Symposium on Chinese Spo-
ken Language Processing (ISCSLP), pages 1–5.

Richard Zens, Franz Josef Och, and Hermann Ney.
2002. Phrase-based statistical machine transla-
tion. In Annual Conference on Artiﬁcial Intelli-
gence, pages 18–32.

Dongdong Zhang, Shuangzhi Wu, Nan Yang, and
Punctuation prediction with
Mu Li. 2013.
In Proceedings of
transition-based parsing.
the 51st Annual Meeting of the Association for
Computational Linguistics (ACL), pages 752–
760.

Yue Zhang and Joakim Nivre. 2011. Transition-
based dependency parsing with rich non-local
In Proceedings of the 49th Annual
features.
Meeting of the Association for Computational
Linguistics: Human Language Technologies
(NAACL-HLT), pages 188–193.

373

Supplementary
Reference Material:
Details for Replicability

A Feature Templates for ATTACH

Below, we provide feature templates for the fea-
tures used by the ATTACH model in §2.1. To il-
lustrate, Table 7 lists all the non-backoff features
that ﬁre on a particular node in Figure 1 of the
main paper. Speciﬁcally, Table 7 lists the nonzero
features in the feature vector f (l, r, w) where w is
the tree node that dominates the subject Dale and
(l, r) = (“, ”) says to surround that subject with
quotation marks.

In general, the feature vector f (l, r, w) assigns
nonzero values (1 values unless otherwise stated)
to the features that are named by the following tu-
ples. (We use dots here to separate the elements of
a tuple.)

• N.l.r.g. ¯d, N.l.r.g.d, N.l.r.g, N.l.r. ¯d, and
N.l.r.d, where g is the POS-tag of the word at
w, d is the dependency relation that labels the
−→
edge of T that points to w, and ¯d =
d
according to the direction of that edge. The
ﬁrst feature name is most speciﬁc, while the
remaining 4 features are backoff features.

←−
d or

For example, such features can be used to say
that an appositive (d = appos) headed by a
noun (g = NOUN) likes to be surrounded by
commas (l = r = ,).

To make training faster and perhaps avoid lo-
cal optima, we initialize the weight of feature
N.l.r.d to its log-count in training data.

• W.h.l.r.g. ¯d, W.h.l.r.g.d, W.h.l.r.g, W.h.l.r. ¯d,
and W.h.l.r.d, where h measures the length
of the constituent headed by w: h = 1 for
a short constituent (1–2 words), h = 2 for a
medium constituent (3–5 words), and h = 3
for a long constituent (≥ 6 words).

a

positive weight

For
example,
on
W.3.,.,.advcl says
long subordi-
nate clauses (h = 3, d = advcl) are likely
to be surrounded by commas.

that

• A.l.r.g. ¯d.d(cid:48),
A.l.r.g.d(cid:48),
A.l.r. ¯d.d(cid:48),
for each de-
pendency relation d(cid:48) that occurs along the

and A.l.r.d.d(cid:48),

A.l.r.g.d.d(cid:48),

path from the root of T to the parent of
(Here l, r, and g are properties of w as
w.
before, whereas d(cid:48) refers to an ancestor of
w.) The value of this feature is the number of
times that d(cid:48) appears along the path. Notice
that if d = root, the path is empty, so none
of the A features ﬁre.

For example, such features might cause a
subordinate clause to be punctuated differ-
ently depending on whether it is attached to
the main verb or a more deeply nested verb.

C.l.r.g.d.d(cid:48),

and C.l.r.d.d(cid:48),

• C.l.r.g. ¯d.d(cid:48),
C.l.r.g.d(cid:48),
C.l.r. ¯d.d(cid:48),
for each de-
pendency relation d(cid:48) that appears on an edge
from w to a child of w. The value of this
feature is the number of such edges. Notice
that if w is a leaf, it has no children, so none
of the C features ﬁre.

For example, such features could be used to
say that a relative clause that contains a sub-
ject (d(cid:48) = subj), such as an object-relative
clause, likes to be surrounded by commas.

• L.l.g−1.g+1 and R.r.g−1.g+1, where g−1 and
g+1 are the POS-tags surrounding the slot
where l or r (respectively) is generated. We
use g−1 = BOS or g+1 = EOS if the slot
is at the beginning or the end of the sentence
(respectively).

• S.g. ¯d, S.g.d, S.g, S. ¯d and S.d, provided that
l and r are symmetric punctemes. Sym-
metry is determined by simultaneously scan-
ning l from left to right and r from right to
left, and checking whether the punctuation
marks at each position form one of the fol-
lowing pairs:24 {} [] () “” <> ¿? ¡!
《》〈〉【】『』「」„ -- . If l and r are both
empty strings, they are not considered sym-
metric.

• c.l.r.g. ¯d, c.l.r.g.d, c.l.r.g, c.l.r. ¯d and c.l.r.d,
for each punctuation token c that appears at
least once as surface punctuation within the
constituent dominated by w. (That is, if w’s
constituent stretches from slot i to slot k, its
internal slots are j = i + 1, . . . , k − 1, and c
must appear in xj for some such j.)

24A more complete list could be compiled from Unicode’s
opening/closing punctuation pairs, but this list is sufﬁcient for
the experiments in this paper.

Name

Value

Feature Type
N.l.r.g. ¯d
W.h.l.r.g. ¯d
S.g. ¯d

←−−−−
nsubj
←−−−−
nsubj

N.“.”.NOUN.
W.1.“.”.NOUN.
S.NOUN.
A.l.r.g. ¯d.d(cid:48) A.“.”.NOUN.
L.l.g−1.g+1
R.r.g−1.g+1

1
1
←−−−−
nsubj
1
←−−−−
nsubj.root 1
1
1

L.“.BOS.NOUN
R.”.NOUN.VERB

Table 7: A subset of the features that ﬁre on the node
with nsubj in Figure 1.

by the S feature in Appendix A, except that it
omits the pairs where the two tokens are equal
(namely -- and „).

First, we modify l and r to ﬁlter out tokens
that do not appear in the list above. We then
check whether the modiﬁed l and r are symmet-
ric punctemes in the sense of the S feature (Ap-
pendix A). If not, we count the node as having un-
matched punctuation.

C Correction Feature Templates

For the correction model (§6.2), recall that we
ﬁrst ﬁnd the 1-best underlyingly punctuated tree
T (cid:48)
e that explains a tree T along with its possibly
erroneous or non-standard surface punctuation xe.
We then use ATTACH to generate corrected
punctuation to attach to T . At this step, it may
be beneﬁcial to condition on knowledge of the re-
constructed underlying punctuation that we recon-
structed in T (cid:48)
e. Thus, we add the following 2 fea-
ture templates, which are extended versions of the
N and W features in Appendix A. In these templates
for evaluating f (l, r, w) in a proposed T (cid:48), l(cid:48) and r(cid:48)
denote the left and right underlying punctemes at-
tached to the corresponding node we in T (cid:48)
e.

• N.l.r.g. ¯d.l(cid:48).r(cid:48),
N.l.r.l(cid:48).r(cid:48)

N.l.r. ¯d.l(cid:48).r(cid:48),

N.l.r.g.l(cid:48).r(cid:48),

• W.h.l.r.g. ¯d.l(cid:48).r(cid:48),W.h.l.r. ¯d.l(cid:48).r(cid:48), W.h.l.r.g.l(cid:48).r(cid:48),

W.h.l.r.l(cid:48).r(cid:48)

These features make it possible to implement
punctuation marks of different precedence.
For example, a conjunct is ordinarily delim-
ited by commas (§5.2), but a conjunct that al-
ready contains internal commas (c = ,) may
be delimited by semicolons instead, as shown
below.25 Similarly, an appositive that already
contains internal commas may be delimited
by dashes instead of commas.

There are two ways to read newspapers:
in print, which is costly;

or in digital, which is free.

Some of these features are not edge-local. They
look at entire paths or constituents, or the surface
punctuation of a constituent. However, they do ad-
mit tractable exact algorithms, similarly to a neu-
ral HMM (Tran et al., 2016). How?

During training, line 13 of Algorithm 1 is able
to compute each feature vector f (l, r, w) given the
observed input tree T and surface punctuation x.
§6.2 and §6.3 both need to ﬁnd the 1-best un-
derlying tree T (cid:48) that corresponds to the given T
and x of a treebank sentence, so that it can cor-
rect or permute that sentence. As discussed at the
end of §3.1, this makes use of the same feature
vectors f (l, r, w), and merely replaces the inside
algorithm with a Viterbi decoding algorithm.

The situation is slightly more difﬁcult at test
time, when T is still observed, but the surface
punctuation is not observed and must be sampled
(§6.1). However, we can still do exact joint sam-
pling of T (cid:48) and x by traversing T bottom-up. That
is, after we have processed the child nodes of w,
we can process w by sampling xj at the internal
slots between its children (using NOISYCHAN-
NEL) and then sampling ((cid:96), r) at its external slots
(using ATTACH, which may depend on the xj val-
ues via the c features).

B Posterior Regularization

Equation (5) includes the expectation of c(T (cid:48)),
which counts the nodes in T (cid:48) whose l and r
punctemes contain any unmatched punctuation to-
kens.

We deﬁne a criterion to decide whether l
and r are unmatched, based on this list of
matched symmetric tokens: {} [] () “” <> ¿?
¡!《》〈〉【】『』「」 . This is the same list used

25Unfortunately, this feature does not explain why all other
conjuncts in the same conjunction (including the ﬁnal con-
junct) also switch to semicolons.

a : a

$ : (cid:15)

a : (cid:15)

b : (cid:15)

(cid:15)

:

a

b:(cid:15)

a : (cid:15)

a

b

:

a

b

:

(cid:15)

(cid:15)

:

a

b

:

a

b

b : b

$:a

b

:

$

a : a

$

∧

b : b

∧(cid:13) a:(cid:15)
∧(cid:13) a:(cid:15)

−−→ a(cid:13) b:(cid:15)
−−→ a(cid:13) b:(cid:15)

−−→ a(cid:13) $:a
−−→ b(cid:13) $:b

−−→ $(cid:13)(cid:13) (cid:46) ab(cid:55)→a
−−→ $(cid:13)(cid:13) (cid:46) ab(cid:55)→b

b : (cid:15)
−−→ a(cid:13) b:b
−−→ a(cid:13) b:a

∧(cid:13) a:(cid:15)
∧(cid:13) a:(cid:15)

−−→ a(cid:13) $:a
−−→ b(cid:13) $:b

−−→ $(cid:13)(cid:13) (cid:46) ab(cid:55)→ba
−−→ $(cid:13)(cid:13) (cid:46) ab(cid:55)→ab

Figure 5: An example of our PFST on vocabulary
Σ = {a, b}. The input (underlying punctuation to-
kens) is colored in blue and the output (surface punctu-
ation tokens) is colored in green. All arc probabilities
are suppressed for readability. ∧ is the start state, $
is the ﬁnal state, (cid:15) denotes the empty string, and $ de-
notes a special end-of-input token. The four rewriting
rules at the bottom of the ﬁgure are illustrated as differ-
ent paths in the PFST.

D PFST implementation

Construct the PFST Recall from §2.2 and Fig-
ure 2 that our noisy channel is supposed to slide
a 2-token window over the string of punctuation
tokens, stochastically editing them as it goes.

In our PFST implementation, each arc has the
form a b:c−→ d , which transitions from state a to
state d while reading an underlying punctuation
token b and generating a surface punctuation token
c. Here the state label a represents the ﬁrst token
in the current sliding window, and the underlying
token b provides the second token in that window.
All surface tokens preceding a have already been
output by the PFST. a has not yet been output by
the PFST, because it will not necessarily be part
of the surface string—it might still be deleted or
transposed.

Choosing to traverse this arc corresponds to
choosing a particular edit to the current window
contents ab. After this edit, the new state d will
reﬂect the ﬁrst token in the new position of the
sliding window.26

Recall from §2.2 that there are 4 possible edits
to ab. These correspond to different choices of c
and d in a b:c−→ d :

• To allow ab (cid:55)→ ab (no change), we include an

arc with c = a and d = b. This outputs the
delayed token a, and then slides the window
rightward so that b is now the ﬁrst token.

• To allow ab (cid:55)→ b (left absorption), we include
an arc with c = (cid:15) and d = b. This is identical
to the previous case, except that it chooses to
skip outputting a, so a has been deleted.

• To allow ab (cid:55)→ a (right absorption), we in-
clude an arc with c = (cid:15) and d = a. This is
identical to the previous case, except that it is
now b that it skips outputting. The ﬁrst token
in the sliding window therefore remains a.

• To allow ab (cid:55)→ ba (transposition), we include
an arc with c = b and d = a. This is identi-
cal to the previous case, except that it outputs
b before the delayed token a. We still have
not output a, so the ﬁrst token in the sliding
window remains a.

The probabilities of these 4 arcs are speciﬁed by
the noisy channel parameters φ. They must sum
to 1 because our noisy channel model will choose
exactly one of the 4 edits for the current sliding
window ab. This fact helps to ensure that our au-
tomaton is indeed a PFST, whose deﬁnition re-
quires that the possible transitions from a given
state a on a given input token b must have total
probability of 1 (Cotterell et al., 2014).

We must also deal with boundary conditions,
using boundary tokens ∧ and $ at the start and end
(respectively) of the underlying string.

• The PFST starts in the special state ∧ , mean-
ing that the sliding window is before the left
edge of the string. The arcs from ∧ have the
form ∧ a:(cid:15)−→ a (with probability 1), which
effectively edits the boundary window ∧a by
left absorption of the ∧. In effect, taking the
arc simply slides the window rightward to the
ﬁrst “real” position of the sliding window,
discovering that its ﬁrst character will be the
ﬁrst underlying token a.

• We append the terminal token $ to the un-
derlying string.27 Thus,
the sliding win-
dow’s ﬁnal position has the form a$. The
arcs that consume this token have the form

26Speciﬁcally, the new window contents will be de, where
e is the underlying token e that follows b. That token e will
be read by the next arc—the arc taken from the new state d.

27In contrast, we did not prepend the initial token ∧ to the
underlying string, but rather initialized in a state ∧ that pre-
tended that ∧ had previously been read.

a $:a−−→ $ (with probability 1), which effec-
tively edits the boundary window a$ by right
absorption of the $, but with the modiﬁcation
that it actually emits the delayed character a
(which cannot undergo any further changes)
and halts.

Let Σ be the vocabulary of punctuation types;
our PFST F has |Σ|+2 states. There is a start state
∧ , a ﬁnal state $ , and the remaining |Σ| states
each represents a punctuation type. An edge s a:b−−→t
denotes a transition from state s to t upon reading
an underlying punctuation token a and generating
a surface punctuation token b. The weight of this
edge is the probability of such a transtion, which
is

The set of edges in our PFST could be enumer-

ated as follows:

• a b:b−→ a , a b:(cid:15)−→ b , a b:(cid:15)−→ a , a b:a−−→ b , for

all distinct a, b ∈ Σ

• ∧ a:(cid:15)−→ a , a $:a−−→ $ , a a:(cid:15)−→ a , a a:a−−→ a

for all a ∈ Σ

,

• ∧ $:(cid:15)−→ $ (same as the ﬁrst case above but

where a = $ instead of a ∈ Σ)

Figure 5 illustrates the topology of our PFST with
a toy vocabulary Σ = {a, b}. The PFST is locally
normalized, because the weights of edges from a
given state on the same input sum up to 1. (See
Cotterell et al. (2014) for a full discussion of lo-
cally normalized PFSTs.)

From PFST to WFSA In §3.1, we construct a
weighted ﬁnite-state acceptor (WFSA) for each
slot, which describes all possible underlying
strings ui that can be rewritten as the surface string
xi that was observed in that slot. We will explain
how to obtain this WFSA. The method is a de-
tailed explanation of line 3 in Algorithm 1, already
sketched in footnote 10.

b : (cid:15)

a : (cid:15)

b : (cid:15)

a : (cid:15)

0

∧, 0

(cid:15)

:

a

b:(cid:15)

1

a, 1

b

:

(cid:15)

:

(cid:15) a

2

b, 1

b : b

a :b

b : b

3

a, 2

(cid:15)

:

a

4

b, 2

b : (cid:15)

a : (cid:15)

$:a

5

$, 2

−→ 1 a

Figure 6: The WFST obtained by composing the yel-
low PFST F in Figure 5 with the green straight-line
FSA 0 b
−→ 2 that accepts xi = ba. The states
are indexed from 0 (the initial state) to 5 (the ﬁnal
state). The bottom of each state shows the identiﬁers
of the yellow and green states that it combines. Each
arc is copied, along with its labels and weight, from a
corresponding arc in Figure 5. Only states that are ac-
cessible from the initial state are shown; arc weights
are suppressed for readability.

z is some green state identiﬁer in the straight-line
FSA for xi. Thus, we depict it in Figure 6 as a
yellow/green state. In other words, the state space
of F ◦ xi consists of the Cartesian product of the
PFST states and the straight-line FSA states. The
edge y,z s−→ y(cid:48),z(cid:48) exists if and only if y s:t−→ y(cid:48) exists
in F and z t−→ z(cid:48) exists in x, with the edge weight
inherited from the former. Note that the result of
composition is a WFST rather than a PFST, since
the arc weights are no longer guaranteed to be lo-
cally normalized.

Finally, to obtain the desired WFSA that de-
scribes the possible underlying strings ui
that
could have yielded xi, we project the WFST onto
its domain (input). This is a simple matter of drop-
ping the output (which follows the colon) from
each arc in the WFST of Figure 6. The weights
are retained.

First, we construct the composition F ◦ xi,
where F is the PFST as shown in yellow in Fig-
ure 5. This composition extracts just the paths of
F that would output the given surface string xi.
To perform this composition, we must represent
the string xi as an unweighted straight-line FSA
with one arc per token of xi. We show this FSA in
−−−→ 2 · · · xi[|x|]
green: 0 xi[1]
The composition F ◦xi is illustrated in Figure 6.
Each state in the composition has the form y,z,
where y is some yellow state identiﬁer in F and

−−−→ 1 xi[2]

−−−→ |x| .

