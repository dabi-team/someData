0
2
0
2

l
u
J

2
1

]
L
M

.
t
a
t
s
[

1
v
2
7
0
6
0
.
7
0
0
2
:
v
i
X
r
a

A spectral algorithm for robust regression with subgaussian rates

Jules Depersin

email: jules.depersin@ensae.fr
CREST, ENSAE, IPParis. 5, avenue Henry Le Chatelier, 91120 Palaiseau, France.

Abstract

We study a new linear up to quadratic time algorithm for linear regression in the absence of strong assumptions
on the underlying distributions of samples, and in the presence of outliers. The goal is to design a procedure which
comes with actual working code that attains the optimal sub-gaussian error bound even though the data have
only ﬁnite moments (up to L4) and in the presence of possibly adversarial outliers. A polynomial-time solution
to this problem has been recently discovered [11] but has high runtime due to its use of Sum-of-Square hierarchy
programming. At the core of our algorithm is an adaptation of the spectral method introduced in [35] for the
mean estimation problem to the linear regression problem. As a by-product we established a connection between
the linear regression problem and the furthest hyperplane problem. From a stochastic point of view, in addition
to the study of the classical quadratic and multiplier processes we introduce a third empirical process that comes
naturally in the study of the statistical properties of the algorithm. We provide an analysis of this latter process
using results from [13].

AMS subject classiﬁcation: 62F35
Keywords: Robustness, heavy-tailed data, regression.

1

Introduction

Much work concerning the prototypical problem of regression focuses on the study of rates of error of a given statisti-
cal procedure while making strong assumptions on the underlying distributions of samples, assuming for instance that
they are i.i.d. and subgaussian or bounded (see for instance, [28, 41, 31]). It is however of fundamental importance
to understand what happens when the data violates such strong assumptions, for instance, when the underlying
distribution of samples is heavy-tailed and/or when the dataset is corrupted by outliers. In such cases – which are
everyday cases for real-world datasets – classical estimators such as OLS or MLE exhibit, at best, far-from-optimal
statistical behaviours and at worst completely non-sens outputs. In this work, we study the statistical properties
(non-asymptotic estimations and predictions results) of algorithms coming with actual working code constructed on
this type of real-word datasets. We want to put forward that it is an algorithm and not only a purely theoretical
estimator and that this algorithm can be coded eﬃciently (we provide a simulation study in the following) since its
most time consuming fundamental building block is to ﬁnd a top singular vector of a reasonable size matrix. However,
our theoretical results show that even though the dataset is far from the ideal i.i.d. subgaussian framework and even
though we study an actually codable algorithm, the resulting estimator achieves the very same minimax bounds with
(exponentially) high probability as the MLE/OLS does in the ideal i.i.d. Gaussian framework (i.e. Gaussian design
and independent Gaussian noise), (see [31] for deviation optimal result in the ideal framework). On top of that, we
prove a theoretical running time for that algorithm which can be linear O(N d) (where N is the sample size and d is
the number of features) and at most quadratic O(N 2d).

Robustness has been a classical topic in statistics since the work of Hampel [19, 20], Huber([24, 23]) and Tukey [46].
For a statistical problem such as mean estimation, regression or covariance estimation, we are given a loss function
and an associated risk function (cid:96) (for instance, for the problem of estimation of the mean vector µ∗ := E(X) ∈ Rd,
the loss function is (cid:96)µ(X) = (cid:107)µ − X(cid:107)2
2 , ∀µ ∈ Rd and the associated risk if (cid:96)(µ) = E(cid:96)µ(X)). For robust estimators
the emphasis is not put on the expected risk E((cid:96)(ˆµ)) – where the expectation is taken w.r.t. the data – but rather
on the dependence of the risk bound rδ on the conﬁdence level 1 − δ ∈ [0, 1]: we want to ﬁnd the smallest rδ so
that P((cid:96)(ˆµ) > rδ) ≤ δ and the way rδ depends on δ is paramount in this approach (this is a key property of the
estimator ˆµ that cannot be revealed when its expected risk is studied). An estimator is robust if the rate rδ does not
grow ”too quickly” when δ goes to 0: we look for an optimal dependence called ”subgaussian rate”, because it is the

1

 
 
 
 
 
 
dependency that we would get if all the data were sub-gaussian. It has been known that for the problem of estimating
the mean in one dimension (d = 1) under the only assumptions that the random variables have bounded variance σ,
there are estimators which achieve rates whose dependence on δ is way better than the empirical mean [6]. Indeed,
N δ (N being the number of sample), the
while the empirical mean cannot achieve in general a better rate than σ/
median of means estimator for instance achieves the same rate as the empirical mean does in the Gaussian setting
σ(cid:112)log(1/δ)/N (see [6, 15]). Achieving similar guarantees for large dimensions d is much more diﬃcult, even without
asking for computationally-tractable algorithms. However, a number of estimators did succeed, in the last decade,
to match the rates achievable in the Gaussian case by usual approaches (sometimes called ”subgaussian rates”) with
much weaker assumptions, even in high dimensions, for problems such as regression or mean estimation (see [39, 40]
or [38] for a survey). Here we consider the standard linear regression setting where data are couples (Xi, Yi)i ∈ Rd ×R
and we look for the best linear combination of the coordinates of an input vector X to predict the output Y , that is
we look for β∗ deﬁned as follows.

√

β∗ = argmin

(cid:96)(β) = argmin

β∈Rd

β∈Rd

E(Y1 − (cid:104)β, X1(cid:105))2.

The theoretical question of ﬁnding robust to heavy-tailed estimators reaching optimal rates for the regression
problem has attracted much attention during the last ten years. It ﬁrst started with the study the standard proce-
dures in this heavy-tailed framework, such as Empirical Risk Minimization or its regularized versions [34, 47, 30, 44].
Several results showed the negative but unavoidable impact of heavy-tailed data on these classical procedures [32].
In the mean time, new estimators have been introduced. For instance, the pioneer work of [3] has considered weak
moment conditions, such as a L2 − L4 norm equivalence, under which the subgaussian rate could be reached. It was
then followed by a rich literature such as [37, 18, 33, 44, 47]. The remaining issue is that naive methods to compute
these new theoretically-optimal estimators take exponential time in the number of dimension d, partly because some
of them are based on non-convex optimization.

Some recent works (for instance [16, 17, 8, 42, 22]) focused on providing procedures that were not only robust (to
outlier or heavy tailed data), but also computationally eﬃcient. Unfortunately, in [16, 17, 8] the procedures fail with
constant probability, failing to give a good dependence on δ, and procedures from [42, 22] do not achieve optimal
rates: for instance, for the problem of mean estimation with bounded covariance Σ, they achieve a bound of order

(up to constants) when the rates achievable in the Gaussian case by the empirical mean is of order

optimal rates rδ under weak assumptions on underlying data, and in the presence of outliers among the data?

. This suggests an important question: are there eﬃciently computable procedures achieving

(cid:113) Tr(Σ)×log(1/δ)
∝
N
(cid:113) Tr(Σ)+(cid:107)Σ(cid:107)op log(1/δ)

N

This question was recently answered aﬃrmatively for the mean estimation problem.

Indeed, recent advances
have shown that, for the problem of mean estimation, one could ﬁnd computationally eﬃcient procedures (that is to
say polynomial in both the dimension d and the number of data N ) that are statistically nearly optimal, meaning

that they reach -up to universal constants- the optimal radius rδ =
for every conﬁdence level
δ ∈ [0, 1] (see [21, 9, 14]). More recently, [35] introduce a spectral method reaching the optimal sub-gaussian rates
without using Semi-Deﬁnite Programming, making somehow robust mean estimation easier to understand, easier to
interpret and easier to code while still keeping optimal statistical results.

N

(cid:113) Tr(Σ)+(cid:107)Σ(cid:107)op log(1/δ)

The question of whether reaching similar bounds (matching the one of the OLS in the Gaussian setting without
the Gaussian and i.i.d. assumptions – thus allowing for corrupted and heavy-tailed datasets) in polynomial time
was possible for other statistical problems such as regression or covariance matrix estimation had been open for
a long time.
Indeed, up to recently, the best known polynomial algorithms were the one from [45] or from [22].
The guarantee is the same for those two algorithms: when the covariance of X is the identity and when the noise
ξ = Y − (cid:104)β∗, X(cid:105) has bounded variance (cid:96)( ˆf ) − (cid:96)(f ∗) ≤ O( log(1/δ)d
) with probability 1 − δ, and they need a number of
sample of order N (cid:38) log(1/δ)d. The article [11] has been the ﬁrst to construct a polynomial-time method achieving
the rate of the OLS in the Gaussian setting (cid:96)( ˆf ) − (cid:96)(f ∗) ≤ O( log(1/δ)∨d
). To the date, it is the only procedure
running in polynomial algorithm achieving the optimal subgaussian rate. However, [11] uses the Sum of Square
(SoS) programming hierarchy to design their algorithm. Even if SoS hierarchy runs in polynomial time, its reliance
on solving large semi-deﬁnite programs makes it impractical and is still a theoretical result leaving still open the
question on the existence of a practical eﬃcient algorithm achieving optimal subgaussian rates.

N

N

In this article, we tackle this issue, showing that techniques from [35] combined with lemmas from [13] can be
used to give the ﬁrst practical, nearly quadratic (and in fact in most cases nearly-linear) algorithm that reaches the
subgaussian rate. We also conduct numerical experiments on simulated data with our proposed procedure to show

2

that it is indeed practical and fast. Moreover, as predicted by our theoretical ﬁndings, our simulation analysis shows
that it is robust both to heavy-tailed data and to outliers. To the best of our knowledge, this is the ﬁrst time that nu-
merical experiments are conducted for a regression algorithm with sub-gaussian rates and polynomial time guarantees.

From a theoretical point of view, our main result (that we will prove later) can be stated as follows (see Setting 1

for the precise set of assumptions and next sections for the construction of the algorithm).

Theorem 1. There are universal constants A, B, C so that the following hold. Let δ ≥ e−AN and K ≥ B((cid:98)log(1/δ)(cid:99)∨
d ∨ |O|) where |O| is the number of outliers. Given N ≥ K points, there is an algorithm running in time

that outputs an estimate ˆβ ∈ Rd such that with probability at least 1 − δ

O (cid:0)(nd + k2d) × log(||β∗||Σ) × polylog(k, d)(cid:1)

(cid:96)( ˆβ) − (cid:96)(β∗) ≤ C

supu∈BΣ

1 (cid:104)u, X1(cid:105)2)K
E(ξ2
N

.

So for K = B((cid:98)log(1/δ)(cid:99) ∨ d ∨ |O|), we get, up to universal constants the (deviation minimax optimal) subgaus-
sian rate achieved by OLS in the Gaussian framework (see [31]). This rate was achieved previously under similar
assumptions by Median-of-means estimators in [37, 36, 33, 18] but none of them come with computational time
guarantees.

To construct estimator ˆβ from Theorem 1 and to prove its theoretical properties as stated in Theorem 1, we

outline now the role of the following key tools:

• Median of Means [43, 25, 1]: this approach is nowadays widely used in robust estimation (see [39, 38,
33, 12, 42], and see [15] for a good introduction to this technique). Let us quickly explain this trick in one
dimension. Consider the problem of estimating the mean µ of a one-dimensional random variable X from
corrupted samples, supposing only E((X − µ)2) ≤ σ2. In that case, the empirical mean fails to provide any
guarantees in the presence of outliers, and only gives weak bounds (of order σ(cid:112)1/(δn) for the conﬁdence level
1 − δ, [7]) even when there are no outliers.

The median of mean method, that can be traced back to [43] for a conﬁdence level 1 − δ consists in splitting
the data X1, ..., XN into K ∼ log(1/δ) equal-size buckets. For all 1 ≤ k ≤ K, ¯Xk denotes the average of the
samples in bucket k. Then we let µδ be the median of ¯X1, · · · , ¯XK. We can show with a straightforward analysis
([15, 43]) that |µδ −µ| ≤ σ(cid:112)log(1/δ)/N with probability ≥ 1−δ and that this bound still holds in the presence
of up to K/8 outliers in the data. The main challenge is to extend this idea to higher dimensional settings
and to other statistical problems, where we need to design appropriate notions of median. For instance,
[37, 36, 33, 18, 13] introduce median-of-mean estimators suited for regression but which are intractable in
practice.

• The Furthest hyperplane problem was ﬁrst adapted to compute median-of-mean estimators very recently
by [35]. Authors from [35] adapt to the problem of robust mean estimation a procedure initially proposed
by [27] to ﬁnd the approximate furthest hyperplane, that is to say the hyperplane that separate 0 from most
of the data and that is the furthest possible from 0. The method from [27] is based on the multiplicative
weight update method (see [2] for a survey), a technique which allows to compute eﬃciently approximations of
quantities such as inf wi∈∆ supu

i wi (cid:104)u, xi(cid:105)2 where ∆ is a convex set of positive weights.

(cid:80)

The combination of these two techniques is at the heart of both the construction and the statistical and computational
time studies of the algorithm satisfying Theorem 1.

In section 2 we present the assumptions we make on the data and provide all the stochastic lemmas that will
In section 3 we will present our descent algorithm and give its precise statistical

be needed for the algorithm.
performance. In section 4 we present some empirical results on simulated data.

2 Assumptions and preliminary stochastic results

2.1 Assumptions
As explained in the previous section, the observed dataset ( ˜Xi, ˜Yi)N
i=1 ∈ Rd × R is a corrupted version of the i.i.d.
dataset {(Xi, Yi)i, i ∈ {1, . . . , N }} in a possibly adversarial way. The assumptions made on good data (Xi, Yi)i are
gathered in the following setting: (see also [36] or [3]).

3

Setting 1. We assume that the following ”heavy-tailed setting” holds:

1. X1 has ﬁnite second moments; we write its L2-moments matrix Σ = E(X1X T

1 ) and we assume that Σ is
known. Let also BΣ = {x ∈ Rd| (cid:104)x, Σx(cid:105) ≤ 1} be the ellipsoid associated with this L2 structure and, for u ∈ Rd
(cid:107)u(cid:107)2

Σ = (cid:104)u|Σu(cid:105).

2. Let ξ1 = Y1 − (cid:104)β∗, X1(cid:105) and assume that σ2 := supu∈BΣ

E(ξ2

1 (cid:104)u, X1(cid:105)2) is such that σ2 < ∞.

3. There exists an universal constant γ such that, for all u ∈ Rd, γE((cid:104)u, X(cid:105)2) ≥

(cid:113)

E((cid:104)u, X(cid:105)4).

We assume adversarial contamination on the data: (X1, Y1), · · · , (XN , YN ) denote N i.i.d. random vectors in Rd ×R.
The vectors (X1, Y1), · · · , (XN , YN ) are not observed, instead, there exists a (possibly random) set O such that, for
any i ∈ Oc, ( ˜Xi, ˜Yi) = (Xi, Yi). The set of indices of outliers O can be arbitrarily correlated with the data (Xi, Yi) –
for instance, only the 9N/10 data with the largest (cid:107)Xi(cid:107)2 are observed – and the outliers ( ˜Xi, ˜Yi)i∈O can be anything
(they can be arbitrarily correlated between themselves and with the non-corrupted data (Xi, Yi), i = 1, . . . , N ). The
only constraint on O is on its size: we suppose that we know an upper bound of |O| (even though, this constraint
may be dropped out if we use an adaptive scheme on K such as Lepski’s method in the end). The observed dataset
is therefore {( ˜Xi, ˜Yi) : i = 1, · · · , N }, and we want to recover β∗ out of it.

Let us now comment on Setting 1. The ﬁrst three assumptions deal with the heavy-tailed setup. It involves at
most the existence of a fourth moment on the noise ζ and the functions class {u ∈ Rd → (cid:10)u, X(cid:11)}. The strongest
assumption among them is the third one which is a L2/L4 norm equivalence assumption. This type of assumption
has been used from the beginning for the statistical study of ERM and other classical methods in the heavy-tailed
scenario for instance in [44, 47, 30] or in [3]. It is also related to the small ball assumption from [29]. It has been
systematically used for the study of Median-of-means estimators (see [36]). The remaining of Setting 1 deals with
the adversarial contamination model. This covers many classical setup such as Huber’s (cid:15)-contamination model or
the O ∪ I framework from [18, 33]. It is somehow the strongest contamination model since an adversary is allowed
to modify without any restriction up to |O| data before the dataset is revealed to the statistician (for more details,
see [5] or [17]).

2.2 Bounds on three stochastic processes

In this section, we introduce three stochastic processes that play a central role in our analysis. We provide a high
probability control for the supremum of the three of them into three lemmas. All the stochastic tools that we will
need later will be related to one of the three processes. So that all the stochastic part of this work is gather into
this section and in the end we will identify a single event onto which the study of the algorithm will be using purely
deterministic arguments.

We now state the three lemmas. The two ﬁrst one deal with the classical quadratic and multiplier processes
which already appeared in the study of ERM in [31]. They naturally show up when the quadratic loss is used. The
last one is new and is related to the descent algorithm we are studying below.

We split the data in K blocks that we note Bk, k ∈ {1, . . . , K}, in agreement with the Median-of-Mean framework.
We note m = N/K the number of data in each blocks, and we note Xk = (Xi)i∈Bk and ˜Xk = ( ˜Xi)i∈Bk . Yk and
˜Yk are deﬁned the same way. We start by stating [13, Lemma 2], that we will use several times in what follows. We
refer the reader to [13, Deﬁnition 1] or [48] for a deﬁnition of the VC-dimension of a set of functions

Lemma 1. Let F be a set of Boolean functions satisfying the following assumptions.

• For all f ∈ F, P (f (X1, Y1) = 0) ≥ 31/32.

• K ≥ C(VC(F) ∨ |O|) where C is a universal constant.

Then, with probability ≥ 1−exp(−K/512), for all f ∈ F, there is at least 19K/20 blocks Bk on which f ( ˜Xk, ˜Yk) =

0.

This lemma is used as a baseline to prove the three following lemmas that will deﬁne the three stochastic events
A, B and E that are needed for our algorithm to give a good estimate. We state in this section that all three fail
with exponentially low probability. We introduce the rate

r = 8σ

(cid:114)

K
N

.

4

(1)

Lemma 2 (Multiplier process). There is a universal constant C1 so that the following hold. If K ≥ C1(d ∨ |O|),
the following event E has probability ≥ 1 − exp(−K/512) : for all u ∈ BΣ, there exist more than 19/20K blocks Bk
so that :

1
m

|

(cid:88)

i∈Bk

( ˜Yi − (cid:104)β∗, ˜Xi(cid:105)) (cid:104)u, ˜Xi(cid:105) | ≤ r.

This can also be also written as: for all u ∈ Rd there exist more than 19/20K blocks Bk so that :

1
m

|

(cid:88)

i∈Bk

( ˜Yi − (cid:104)β∗, ˜Xi(cid:105)) (cid:104)u, ˜Xi(cid:105) | ≤ r||u||Σ.

Lemma 3 (Quadratic process). There is C1 a universal constant so that the following hold. If K ≥ C1(d ∨ |O|)
the following event B has probability probability ≥ 1 − exp(−K/512): for all u, v ∈ Rd, there exists more than 19/20K
blocks Bk so that :

|

1
m

(cid:88)

i∈Bk

(cid:104)u, ˜Xi(cid:105) (cid:104)v, ˜Xi(cid:105) − (cid:104)u, Σv(cid:105) | ≤ 6γ

(cid:114) 1
m

(cid:107)u(cid:107)Σ (cid:107)v(cid:107)Σ

In particular, when m ≥ 360 000γ2, on the event B, for all u ∈ Rd

99/100 (cid:104)u, Σu(cid:105) ≤

1
m

(cid:88)

2
(cid:104)u, ˜Xi(cid:105)

i∈Bk

≤ 101/100 (cid:104)u, Σu(cid:105) .

Lemma 4. There is C1 a universal constant so that the following hold. If K ≥ C1(d ∨ |O|) and m ≥ 128γ, then the
following event A has probability exp(−K/512). For all βc ∈ Rd, there exist more than 19/20K blocks Bk so that :

(cid:13)
˜Zk(βc)
(cid:13)
(cid:13)

(cid:13)
(cid:13)
(cid:13)2

≤ 8

(cid:114) E(||(ξ1Σ−1/2X1||2
2)
m

√

+

d (cid:107)βc − β∗(cid:107)Σ ≤

√

d(r + (cid:107)βc − β∗(cid:107)Σ)

where

with r deﬁned as in 1.

˜Zk(βc) =

1
m

(cid:88)

i∈Bk

( ˜Yi − βc ˜Xi)Σ−1/2 ˜Xi

We assume for the rest of this work, that K ≥ C1(d ∨ |O|), that m ≥ 360 000γ2. We moreover assume

that events A, B and E hold.

3 Analysis of the algorithm

The general algorithm, as in [35], is a basic descent procedure :

input : ˜X1, ˜Y1 . . . , ˜XN , ˜YN , K ≥ C1(d ∨ |O|), and Tdes.
output: A robust estimator of β∗

1 Initialize β0 = 0
2 for t = 1, ..., Tdes do
3

4

dt = stepSize( ˜X, ˜Y , K, βt, Tdes)
gt = descentDirection( ˜X, ˜Y , K, βt, dt, Tdes)
βt+1 = βt − dtgt

5
6 end
7 Return ROUND(Z, θ, (ut)t).

Algorithm 1: Main descent algorithm

A good descent direction v should check (cid:104)v, Σβt − β∗(cid:105) ≥ c0||βt − β∗||Σ and ||v||Σ = 1 for some constant c0 < 1,

and a good step size should check dt ∈ [c1 (cid:107)βt − β∗(cid:107)Σ , c0 (cid:107)βt − β∗(cid:107)Σ] with 0 < c1 < c0 so that

5

Σ ≤ (1 − 2c0c1 + c2
with α < 1. In order to ﬁnd a good descent direction, we will be using the central quantity

Σ ≤ α||βt − β∗||2
Σ

1)||βt − β∗||2

||βt+1 − β∗||2

Zk(βc) =

1
m

(cid:88)

i∈Bk

(Yi − βcXi)Σ−1/2Xi

i∈Bk

already mentioned in the previous section (see Lemma 4). We decompose Zk as Zk(βc) = 1
m
(cid:80)

ξiΣ−1/2Xi +
(cid:104)β∗ − βc, Xj(cid:105) Σ−1/2Xi. The ﬁrst term has mean zero by deﬁnition of β∗, but the expectation of the second
one is Σ1/2(β∗ − βc). So if we ﬁnd a direction so that most Zk(βc) are ”aligned” with this direction, we might have
a shot at ﬁnding a descent direction. The introduction of this quantity Z is the main novelty of this work. We will
see in the rest of this section that ﬁnding such a direction indeed leads to a nice descent, and we will show how to
ﬁnd it eﬃciently.

i∈Bk

(cid:80)

More precisely, we will show that the algorithms stepSize and descentDirection are good step size and descent
direction. The main tool is a modiﬁcation of the algorithm APPROXBREGMAN from [35] (which is in turn an adaptation
from [26]), that we called BregmanRegression

We summarize the properties of this descent in a main theorem :

Theorem 2. On the event E, A, B, each iteration of Algorithm 1 checks the following with probability ≥ 1 −
exp(K)/Tdes

• Whenever ||βc − β∗||Σ ≥ 100r,

(cid:107)βc+1 − β∗(cid:107)Σ ≤ (1 − 2/100.000) (cid:107)βc − β∗(cid:107)Σ

• Whenever ||βc − β∗||Σ ≤ 100r,

(cid:107)βc+1 − β∗(cid:107)Σ ≤ 102r

Moreover, each iteration runs in time O((N d + K 2d) × polylog(d, K))

√

To prove this, we need a few intermediate lemma and algorithms. All the results hold on the event A ∩ B ∩ E
We ﬁrst state some essential remarks about pruning. Because we are on A, we know that 9/10K blocks check
(cid:13)
(cid:13)
d(r + (cid:107)βc − β∗(cid:107)Σ). For simplicity, we will just note ˜Zk(βc) = ˜Zi We note K (cid:48) = (cid:98)9/10K(cid:99), and we
˜Zk(βc)
(cid:13)
(cid:13)
≤
(cid:13)2
(cid:13)
K(cid:48) the K (cid:48) smallest ˜Zi, as returned by algorithm 2. For the rest of this part we will mainly work with
note Z (cid:48)
1, ..., Z (cid:48)
the pruned data, so that, on A, R := maxk≤K(cid:48) ||Z (cid:48)

d(r + (cid:107)βc − β∗(cid:107)Σ).

k|| <

√

input : ˜Z1, ..., ˜ZK
output: Pruned ˜Zσ(1), ..., ˜Zσ(K(cid:48))

1 Compute the norms || ˜Zi|| and sort them ˜Zσ(1) < ˜Zσ(2) < ... < ˜Zσ(K)
2 Remove the top 1/20
3 Return ˜Zσ(1), ..., ˜Zσ(K(cid:48)) := (Z (cid:48)

k)k∈{1,...,K(cid:48)}.

Algorithm 2: Pruning algorithm

Now the ﬁrst lemma of this part states that if Q8/10 is the 8/10 quantile of a serie, maxu∈Bd

Q8/10((cid:104)Z (cid:48)

i, u(cid:105)) is a

good estimate of the distance ||βc − β∗||Σ (Bd

2 denote the unit ball for the canonical euclidean distance on Rd)

2

Lemma 5. There is u ∈ Bd

2 so that, for at least 8/10 of the k ∈ {1, ..., K (cid:48)}

(cid:104)Z (cid:48)

k, u(cid:105) ≥ θ1

with θ1 := 99/100||βc − β∗||Σ − r
Moreover, for any u ∈ Bd

2, at least 8/10 of the pruned blocks check, (cid:104)Z (cid:48)

i, u(cid:105) ≤ r + 101/100||βc − β∗||Σ

6

Now we give the main lemma from [35], that states that it is possible to approximate maxu∈B2 Q8/10((cid:104)Z (cid:48)

k, u(cid:105))

with exponentially high probability in polynomial time.

Lemma 6 (Lemma 5.2 of [35]). There a universal constant C such that the following holds. Suppose there is u ∈ B2
so that, for at least 8/10 of the k

(cid:104)Z (cid:48)

k, u(cid:105) ≥ θ > 0

and that, for all k, Z (cid:48)
with T and θ outputs a vector ˜u ∈ Bd
probability exp(−T /C) ) . Moreover, each of the T iteration of 3 costs K × d + polylog(d) operations

k < R. Then, when T ≥ 2 log(K (cid:48))R2/θ2, with probability ≥ 1 − exp(−T /C), algorithm 3 applied
k(cid:105) ≥ θ/10 (and returns ”fail” with

2 so that, for at least 2/10 blocks , (cid:104)˜u, Z (cid:48)

Remark : Algorithm 3 always return either a vector u ∈ Bd

2 so that, for at least 2/10 of the i, (cid:104)u, Z (cid:48)

k(cid:105) ≥ θ/10 or

”fail”. If there is no u so that for at least 2/10 blocks (cid:104)u, Z (cid:48)

k(cid:105) ≥ θ/10, then it will always return ”fail”

input : Z (cid:48)
output: A good descent direction or ”Fail”.

K, θ and T .

1, . . . , Z (cid:48)

1 R = max(||Z (cid:48)
2 Initialize weights ω1 = (1, ..., 1)/K
3 for t = 1, ..., T do

i||)

4

5

6

7

Let At be the K × d matrix whose ith row is (cid:112)ωt(i)Z (cid:48)
of At × Σ−1/2, computed with a PowerMethod.
i, ut(cid:105)2.
Set σi = (cid:104)Z (cid:48)
ωt+1(i) = ωt(i) × (1 − σi/2)
Normalize a = (cid:80)
i ωt+1(i), ωt+1 = ωt+1/a
Compute the Bregmann projection ωt+1 = Bregmann(ωt+1)

8
9 end
10 Return ROUND(Z (cid:48), θ, (ut)t).

i and ut be the approximate top right singular vector

Algorithm 3: BregmanRegression

Remark. Lemma 6 has a failure probability even if we are on the events A, B and E: it is because Algorithm 3 calls
two random algorithms, PowerMethod, which fails with constant probability, and ROUND, which fails with exponentially
low probability ∝ exp(−cT ) with c a constant ([27, 35]). Algorithm 3 can tolerate at most 0.1T among T mistakes in
the computation of the top eigenvectors of the matrices At, and the event where more than 0.1T of the power methods
fail happesn with probability exponentially low in T . The failure probability of algorithm 3 and the algorithm itself
are explained in depth in [35].

The computation of the Bregman projection is described in [4], and appears of course in [35].

This last lemma states that ﬁnding a direction ”aligned” with most of the Z (cid:48)

k grants a good descent direction.

Lemma 7. If for at least 2/10 blocks , (cid:104)u, Z (cid:48)
β∗||Σ/100 (and of course ||v||Σ = 1 ).

k(cid:105) ≥ θ/10, then v = Σ−1/2u checks (cid:104)v, Σβc − β∗(cid:105) ≥ θ/10 − r − ||βc −

Proof of Theorem 2. We now have all the right tools to perform our analysis.

• Whenever ||βc − β∗||Σ ≥ 100r, then by Lemma 5, there exists u so that for at least 8/10K (cid:48) of the (pruned)
i, u(cid:105) ≥ 98/100||βc − β∗||Σ. So algorithm 3 with θ ∈ [49/100 (cid:107)βc − β∗(cid:107)Σ , 98/100 (cid:107)βc − β∗(cid:107)Σ], and with

blocks (cid:104)Z (cid:48)
T ≥ 6 log(K (cid:48))K ≥ 6 log(K (cid:48))d ≥ 2 log(K (cid:48))R2/θ2 does not output ”Fail” (Lemma 6).

We also recall that if there is no u so that for at least 4/10 blocks , (cid:104)u, Zi(cid:105) ≥ θ/10, then it will always return
”Fail”. Thus whenever θ ≥ 10(101/100 (cid:107)βc − β∗(cid:107) + r), by Lemma 5 , the algorithm returns ”Fail”.
So our binary search stepSize returns a θ ∈ [49/100||βc − β∗||Σ , 10(102/100 (cid:107)βc − β∗(cid:107)Σ)] × 2/100 × (1/10) ×
(100/102), in less than log(R/||βc − β∗||Σ) (cid:46) log(d) iterations. The vector u returned by descentDirection is
so that v = Σ−1/2u checks (cid:104)v, Σβc − β∗(cid:105) ≥ 2||βc − β∗||Σ/100, with high probability (Lemma 7).
So we have, if c1 = 49/100 × 1/10 × 2/100 × 100/102 and c0 = 2/100

(cid:107)βc+1 − β∗(cid:107)Σ ≤ (1 − 2c0c1 + c2

1) (cid:107)βc − β∗(cid:107)Σ ≤ (1 − 2/100.000) (cid:107)βc − β∗(cid:107)Σ

7

• Whenever ||βc − β∗||Σ ≤ 100r, whenever θ ≥ 10(101/100 (cid:107)βc − β∗(cid:107) + r), by Lemma 5 , the algorithm returns
”Fail”, so our binary search stepSize returns a θ ≤ 10(102/100 (cid:107)βc − β∗(cid:107)Σ) × 2/100 × (1/10) × (100/102) =
2/100 (cid:107)βc − β∗(cid:107)Σ). We have

(cid:107)βc+1 − β∗(cid:107)Σ ≤ 102/100 (cid:107)βc − β∗(cid:107)Σ ≤ 102r

Once again, we recall that there is no eﬀort made here to optimize the constants.

4 Experiments

In this section, we present the results of some synthetic numerical experiments. Our ﬁrst aim is to show that our
algorithm comes with actual code and that it can be computed eﬃciently. This is a important feature of our approach
that we want to put forward because, even though there are polynomial time algorithms (even linear time ones for the
problem of mean estimation) they usually do not come with eﬃcient code. Our second aim is to show the robustness
(to heavy-tailed and outliers) properties of our algorithms as predicted by our theoretical ﬁndings in Theorem 2.

4.1 Experiments with heavy-tailed data and outliers

Data generating process. We ﬁx the contamination level (cid:15) = |O|/N . Then, we generate (1 − (cid:15))N ”clean”
input vectors Xi following a multivariate Student’s standard t-distribution with parameter 3 and we generate the
corresponding ”clean” responses following the linear model Y = (cid:104)β∗, X(cid:105) + σξ where β∗ = [1, . . . , 1] ∈ Rd and where
ξ also follows Student’s t-distribution and is independent from the feature vector X, and σ is the inverse signal to
noise ration (SNR). We simulate an outliers attack by adding on the (cid:15)N remaining data an arbitrary large number
(109) to some cordinates of the input vectors, or multiplying them by 109. We also set some responses to 0 and some
other to 109. The total number of samples is set to be N = 50d. We note that the sample size we choose increases
with the dimension. We conduct 50 independent simulations.

Metric. We measure the parameter error in L2 norm, which is also the estimation norm (cid:107).(cid:107)Σ as we take Σ = Id.
Baselines. As our baselines, we use the Ordinary Least Square, the Huber-loss M-estimator, RANdom SAmple
Consensus (RANSAC) and the MOM-estimator from [22], that we name metric MOM. The ﬁrst three are imple-
mented in the python library sci-kit learn, and we coded the last one.

Results. We summarize our main ﬁndings here.

• Error vs dimension d: We ﬁx (cid:15) = 0.005, and we choose, for both our algorithm and the one from [22] to take
K = d. We do not include the OLS in our graphic because its very poor performance (due to the presence of
contamination) would prevent us to compare the four others. We notice that for all the algorithms but the
one presented in this paper, the prediction error grows quickly with the dimension. On the opposite, for our
algorithm, the performance does not depend on the dimension. This does not come as a surprise, as the error
is ∝ σK/N , which we chose to be d/N , which is a ﬁxed quantity in this setup. (Figure 1(a)). In Figure 1(b)
we see a comparison between the maximum error over the 50 simulations and the mean error. We note that
the maximum decreases with d which seems to match the theory: since our bounds are true with probability
1 − exp(−K/c) (which is here equal to 1 − exp(−d/c)), the are more frequently true as d grows.

• Error vs the inverse SNR σ: We ﬁx (cid:15) = 0.005, d = 200 , we still choose K = d and we study how the algorithms
perform for a range of SNR σ. We do not include OLS and we do not include RANSAC, because its error
explodes for large σ . We notice that our algorithm’s error depends linearly on σ, which is not a surprise.

4.2 Which choice of K ?

From a theoretical point of view, we answered the question of how one should choose the parameter K in the previous
section: K should me at least K ≥ C1(d ∨ |O| ∨ log(1/δ)) for our algorithm to work with probability ≥ 1 − δ, but it
should not be too high because we do not want our bound ∝ K/N to explode.

Setup. In Figure 2, we ﬁx the contamination level (cid:15) = |O|/N to be 0 (there is no outlier). Then, we generate
the covariates of dimension d = 100 from a multivariate Student’s t-distribution with parameter 3 and we generate
the corresponding clean responses using y = (cid:104)β∗, x(cid:105) + ξ where β∗ = [1, · · · , 1] and where ξ follows Student’s t-
distribution and is independent from the covariates. The number of samples is set to 10000. We conduct 50
independent simulations.

8

(a) Mean parameter error vs d

(b) Mean and max parameter error vs d

(c) Mean parameter error vs σ

(d) Mean parameter error vs σ

Figure 1: Parameter error variations

Results. The interesting thing is that we can recover a kind of trade-oﬀ from numerical experiment. It seems
indeed that when K (cid:28) d, our algorithm can not seize the complexity of the regression task, and that when K (cid:29)
d, there are not enough data per block and thus the block are ”not informative enough”. Those two opposite
phenomenons lead to a sort of bias-variance trade-oﬀ.

5 Conclusion

We can outline the main beneﬁts and limitations of our algorithm. On the practical side, the main beneﬁt is its
low computational complexity and that it comes with eﬃcient actual code. On the theoretical side, the algorithm
is robust to adversarial outliers and robust to heavy-tailed data and it achieves the subgaussian rate. It avoids the
pitfall of SOS or SDPs since it uses spectral methods. This makes our algorithm both easy to understand easy to
code, and that is the reason why this work comes with a simulation study unlike many other works in this literature.
The main limitation for now is that we need to know the variance matrix Σ of the co-variates (whereas sub
optimal algorithms such as [22] do not require knowledge of Σ). An other limitation of this work lies in the choice of
K: we need prior knowledge on the number of outliers for our procedure to work. It might be possible to improve
this with a Lepski-type procedure [36].

A ﬁnal comment is that, while we choose the descent procedure from [35] for its simplicity and practical per-
formances, the procedures from [14] or from [10] applied with our ˜Zk’s would probably work just as well and give
similar rates but may be harder to code eﬃciently in practice.

An interesting perspective would be to extend this work to other estimation problems such as covariance esti-
i (cid:104)u, Aiu(cid:105)2 for
i (cid:104)u, vi(cid:105)2 with the power method, this other

mation, as presented in [11]. To do so, one would have to ﬁnd an eﬃcient way to compute supu∈B2
any symmetric matrices Ai. While it is simple to compute supu∈B2

(cid:80)

(cid:80)

9

(a) Mean parameter error vs K (d=100)

(b) Maximum parameter error vs K (d=100)

Figure 2: Choice of K

problem seems harder. We may also wonder if it is possible to adapt this kind of spectral procedure in order to
recover sparse signals or, more generally, if it is possible to introduce any regularisation.

6 Proofs

6.1 Stochatic proofs

We state a theorem and its direct corollary that will be useful to bound the diﬀerent VC-dimensions at stake.

Theorem 3 (Warren, [49]). Let P = {P1, ..., Pm} denote a set of polynomials of degree at most ν in n real variables
with m > n, then the number of sign assignments consistent for P is at most (4eνm/n)n.

We denote by Rn

ν [X] the set of polynomials of dergree at most ν in n real variables.

Corollary 1. Assume that the set of functions F can be written F = {P ∈ Rn
VC(F) ≤ 2n log2(4eν).

ν [X] → 1P (x)≥0, x ∈ Rn}, then

Let us also recall that, if g : Y → X is a function and F ◦ g = {f ◦ g | f ∈ F}, then VC(F ◦ g) ≤ VC(F).

Proof of Lemma 2. Let F = {(x, y) ∈ R(d+1)×m → 1(cid:104)u,(cid:80)
indicators of half-spaces, but F is the composition of g : (x, y) ∈ R(d+1)×m → (u → (cid:104)u, (cid:80)
m2r2) ∈ Rd
that VC(F) ≤ cd.
For all u ∈ BΣ,

i(yi−(cid:104)β∗,xi(cid:105))xi(cid:105)2≥m2r2 , u ∈ BΣ}. This is not a set of
i(yi − (cid:104)β∗, xi(cid:105))xi(cid:105)2 −
2[X] → 1P (u)≥0, u ∈ Rd}. By Corollary 1 , there exists an absolute constant c such

2[X] and of {P ∈ Rd

(cid:32)

P

1
m

|

(cid:88)

i∈B1

(Yi − (cid:104)β∗, Xi(cid:105)) (cid:104)u, Xi(cid:105) | ≥ r

≤

(cid:33)

E(ξ2

1 (cid:104)u, X1(cid:105)2)
mr2

≤

1
32

.

By Lemma 1 applied with F, it follows that the following event E has probability ≥ 1 − exp(−K/512): for all

u ∈ BΣ, there exist more than 3/4K blocks k where

( ˜Yi − (cid:104)a, ˜Xi(cid:105)) (cid:104)u, ˜Xi(cid:105) | ≤ mr.

(cid:88)

|

i∈Bk

Proof of Lemma 3. We note that, by bilinearity, it is enough to prove this result when ||u||Σ = ||v||Σ = 1.

Let G = {(xi) ∈ Rd×m → 1| (cid:80)(cid:104)xi,u(cid:105)(cid:104)xi,v(cid:105)−uΣv|2≥c||u||2

Σ||v||2
Σ

g : (x, y) ∈ R(d+1)×m → (u, v → | (cid:80) (cid:104)xi, u(cid:105) (cid:104)xi, v(cid:105) − uΣv|2 − c||u||2
1P (u)≥0, u ∈ Rd}, so there exists an absolute constant c such that VC(G) ≤ cd (Corollary 1).

Σ) ∈ R2d

Σ||v||2

, u, v ∈ Rd}. Once again, G is a composition of
4 [X] →

4 [X] and of {P ∈ R2d

10

Let r1 = 6γ

(cid:113) 1

m (cid:107)u(cid:107)Σ (cid:107)v(cid:107)Σ .
(cid:32)
|

P

(cid:88)

1
m

i∈B1

(cid:104)u, Xi(cid:105) (cid:104)v, Xi(cid:105) − (cid:104)u, Σv(cid:105) | ≥ r1

≤

(cid:33)

E((cid:104)u, X1(cid:105)2 (cid:104)v, X1(cid:105)2)
mr2
1

≤

1
32

because E((cid:104)u, X1(cid:105)2 (cid:104)v, X1(cid:105)2) ≤ E((cid:104)u, X1(cid:105)4)1/2E((cid:104)v, X1(cid:105)4)1/2 ≤ γ2 (cid:107)u(cid:107)2

Σ (cid:107)v(cid:107)2

Σ (this is from the L2 − L4 norm

equivalence). We conclude with Lemma 1.

Proof of Lemma 4. We deﬁne Zk(βc) = (cid:80)

We can write (cid:107)Zk(βc)(cid:107)2 ≤

bound those two quantities :

(cid:13)
(cid:13)
(cid:13)

1
m

(cid:80)

j∈Bk

(Yj − βXj)Σ−1/2Xj.

j∈Bk
(Yj − β∗Xj)Σ−1/2Xj

(cid:13)
(cid:13)
(cid:13)2
(cid:113) E(||(ξ1Σ−1/2X1||2
2)

m

First E((Yj − β∗Xj)Σ−1/2Xj) = 0, so, if a = 8

+

(cid:13)
(cid:13)
(cid:13)

1
m

(cid:80)

j∈Bk

((β∗ − βc)Xj)Σ−1/2Xj

(cid:13)
(cid:13)
(cid:13)2

, we will

P(||

1
m

(cid:88)

j∈B1

(Yj − βcXj)Σ−1/2Xj||2 ≥ a) ≤

E(||(ξ1Σ−1/2X1||2
2)
ma2

≤

1
64

Then, if we note Vk = (cid:104)(β∗ − βc)Xj(cid:105) Σ−1/2Xj we notice that E(Vk) = Σ1/2(β∗ − βc), and that E(||Vk||2) ≤
)1/2 E((cid:104)βc − β∗, X(cid:105)2)1/2. As X checks the L4 − L2 norm equivalence, Σ−1/2X checks the same

(cid:13)Σ−1/2X(cid:13)
2
2) = γd, and E((cid:104)βc − β∗, X(cid:105)2)1/2 = (cid:107)βc − β∗(cid:107)Σ, so
(cid:13)

2
E((cid:104)Σ−1/2X, Σ−1/2X(cid:105)
equivalence, so E((cid:13)

E(||

1
m

(cid:88)

i∈B1

Vi||2

2)1/2 ≤ γE((cid:13)
(cid:13)Σ−1/2X(cid:13)
4
(cid:13)
1
m

2) = ||E(V1)||2

2 +

E(||Vi − E(Vi)||2

2) ≤ ||E(V1)||2

2 +

1
m

E(||Vi||2

2) ≤ (cid:107)βc − β∗(cid:107)2

Σ +

1
m

γd (cid:107)βc − β∗(cid:107)2
Σ

So, as m ≥ 128γ, if b =

√

d (cid:107)βc − β∗(cid:107)Σ

P(||

1
m

(cid:88)

i∈B1

Vi|| ≥ b) ≤

1
64

So the probability that one of the two bounds fails is ≤ 1/32. We then just use lemma 1, with the functions
Σ), β ∈ Rd}. Again, we use Corollary 1 to state that

i(yi−(cid:104)β,xi(cid:105))xi||2≥d(r2+(cid:107)βc−β∗(cid:107)2

F = {(x, y) ∈ R(d+1)×m → 1|| (cid:80)
there exists an absolute constant c such that VC(G) ≤ cd.

6.2 Algorithmic proofs

Proof of Lemma 5. In fact, we just know that, if we take u = Σ1/2(βc−β∗)

(cid:104) ˜Zi, u(cid:105) =

(cid:88)

i∈Bk

( ˜Yi − (cid:104)β∗, ˜Xi(cid:105)) (cid:104)v, ˜Xi(cid:105) +

i∈Bk

(||βc−β∗||Σ) , and v = (βc−β∗)
(cid:88)

((cid:104)β∗ − βc, ˜Xi(cid:105)) (cid:104)v, ˜Xi(cid:105)

(||βc−β∗||Σ) ∈ BΣ

(2)

So for at least 9/10 blocks, (cid:104) ˜Zi, u(cid:105) ≥ 99/100||βc − β∗||Σ − r := θ1. This is true for at least 9/10 of the blocks

( ˜Zi), it is true for at least 17/19 > 8/10 of the ”pruned blocks” (Z (cid:48)

i).

The same way, for any u ∈ B2, we take v = Σ−1/2u ∈ BΣ

(cid:104) ˜Zi, u(cid:105) =

(cid:88)

( ˜Yi − (cid:104)β∗, Xi(cid:105)) (cid:104)v, Xi(cid:105) +

(cid:88)

((cid:104)β∗ − βc, Xi(cid:105)) (cid:104)v, Xi(cid:105)

i∈Bk

i∈Bk
≤r + (cid:104)β∗ − βc, Σv(cid:105) + 1/100||βc − β∗||Σ
≤r + 101/100||βc − β∗||Σ

for at least 9/10 of the blocks. Again, as this is true for at least 9/10 of the blocks, it is true for at least 17/19 > 8/10
of the ”pruned blocks”

11

Proof of Lemma 7.

(cid:104) ˜Zi, u(cid:105) =

(cid:88)

( ˜Yi − (cid:104)β∗, Xi(cid:105)) (cid:104)v, Xi(cid:105) +

(cid:88)

((cid:104)β∗ − βc, Xi(cid:105)) (cid:104)v, Xi(cid:105)

i∈Bk

i∈Bk
≤r + (cid:104)β∗ − βc, Σv(cid:105) + 1/100||βc − β∗||Σ

for at least 9/10 of the blocks ˜Zi. Again, as this is true for at least 9/10 of the blocks, it is true for at least
17/19 > 8/10 of the ”pruned blocks” Z (cid:48)
i.

Their is at least one block that checks both (cid:104)u, Z (cid:48)

i(cid:105) ≥ θ/10 and (cid:104)u, Z (cid:48)

i(cid:105) ≤ r + (cid:104)β∗ − βc, Σv(cid:105) + 1/100||βc − β∗||Σ (as

2/10 + 17/19 > 1), so

(cid:104)β∗ − βc, Σv(cid:105) ≥ θ/10 − r − ||βc − β∗||Σ/100

Acknowlegements: I would like to thank Guillaume Lecu´e and Matthieu Lerasle for their precious comments.

I thank Yannick Guyonvarch and Fabien Perez for their help.

References

[1] Noga Alon, Yossi Matias, and Mario Szegedy. The space complexity of approximating the frequency moments. J. Comput. System
Sci., 58(1, part 2):137–147, 1999. Twenty-eighth Annual ACM Symposium on the Theory of Computing (Philadelphia, PA, 1996).

[2] Sanjeev Arora, Elad Hazan, and Satyen Kale. The multiplicative weights update method: a meta-algorithm and applications. Theory

of Computing, 8(6):121–164, 2012.

[3] Jean-Yves Audibert and Olivier Catoni. Robust linear least squares regression. Ann. Statist., 39(5):2766–2794, 10 2011.

[4] Boaz Barak, Moritz Hardt, and Satyen Kale. The Uniform Hardcore Lemma via Approximate Bregman Projections, pages 1193–1200.

[5] Battista Biggio, Blaine Nelson, and Pavel Laskov. Support vector machines under adversarial label noise. In Chun-Nan Hsu and
Wee Sun Lee, editors, Proceedings of the Asian Conference on Machine Learning, volume 20 of Proceedings of Machine Learning
Research, pages 97–112, South Garden Hotels and Resorts, Taoyuan, Taiwain, 14–15 Nov 2011. PMLR.

[6] Olivier Catoni. Challenging the empirical mean and empirical variance: A deviation study. Annales de l’I.H.P. Probabilit´es et

statistiques, 48(4):1148–1185, 2012.

[7] Olivier Catoni. Challenging the empirical mean and empirical variance: a deviation study. Ann. Inst. Henri Poincar´e Probab. Stat.,

48(4):1148–1185, 2012.

[8] Yu Cheng, Ilias Diakonikolas, and Rong Ge. High-dimensional robust mean estimation in nearly-linear time. In Proceedings of the

Thirtieth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 2755–2771. SIAM, Philadelphia, PA, 2019.

[9] Yeshwanth Cherapanamjeri, Nicolas Flammarion, and Peter L. Bartlett. Fast mean estimation with sub-gaussian rates, 2019.

[10] Yeshwanth Cherapanamjeri, Samuel B. Hopkins, Tarun Kathuria, Prasad Raghavendra, and Nilesh Tripuraneni. Algorithms for

heavy-tailed statistics: Regression, covariance estimation, and beyond, 2019.

[11] Yeshwanth Cherapanamjeri, Samuel B. Hopkins, Tarun Kathuria, Prasad Raghavendra, and Nilesh Tripuraneni. Algorithms for
heavy-tailed statistics: Regression, covariance estimation, and beyond. In Proceedings of the 52nd Annual ACM SIGACT Symposium
on Theory of Computing, STOC 2020, page 601–609, New York, NY, USA, 2020. Association for Computing Machinery.

[12] Geoﬀrey Chinot, Lecu´e Guillaume, and Lerasle Matthieu. Statistical learning with lipschitz and convex loss functions. arXiv preprint

arXiv:1810.01090, 2018.

[13] Jules Depersin. Robust subgaussian estimation with vc-dimension, 2020.

[14] Jules Depersin and Guillaume Lecu´e. Robust subgaussian estimation of a mean vector in nearly linear time, 2019.

[15] Luc Devroye, Matthieu Lerasle, Gabor Lugosi, and Roberto I. Oliveira. Sub-Gaussian mean estimators. Ann. Statist., 44(6):2695–

2725, 2016.

[16] Ilias Diakonikolas, Gautam Kamath, Daniel M. Kane, Jerry Li, Ankur Moitra, and Alistair Stewart. Robust estimators in high
dimensions without the computational intractability. In 57th Annual IEEE Symposium on Foundations of Computer Science—
FOCS 2016, pages 655–664. IEEE Computer Soc., Los Alamitos, CA, 2016.

[17] Ilias Diakonikolas, Weihao Kong, and Alistair Stewart. Eﬃcient algorithms and lower bounds for robust linear regression.

In
Proceedings of the Thirtieth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 2745–2754. SIAM, Philadelphia, PA,
2019.

[18] Lecu´e Guillaume and Lerasle Matthieu. Learning from mom’s principles: Le cam’s approach, 2017.

[19] Frank R. Hampel. A general qualitative deﬁnition of robustness. Ann. Math. Statist., 42:1887–1896, 1971.

[20] Frank R. Hampel. Robust estimation: a condensed partial survey. Z. Wahrscheinlichkeitstheorie und Verw. Gebiete, 27:87–104,

1973.

[21] Samuel B Hopkins. Sub-gaussian mean estimation in polynomial time. arXiv preprint arXiv:1809.07425, 2018.

[22] Daniel Hsu and Sivan Sabato. Loss minimization and parameter estimation with heavy tails. Journal of Machine Learning Research,

17(18):1–40, 2016.

[23] Peter J. Huber. Robust estimation of a location parameter. Ann. Math. Statist., 35:73–101, 1964.

12

[24] Peter J. Huber and Elvezio M. Ronchetti. Robust statistics. Wiley Series in Probability and Statistics. John Wiley & Sons, Inc.,

Hoboken, NJ, second edition, 2009.

[25] Mark R. Jerrum, Leslie G. Valiant, and Vijay V. Vazirani. Random generation of combinatorial structures from a uniform distribution.

Theoret. Comput. Sci., 43(2-3):169–188, 1986.

[26] Zohar Karnin, Edo Liberty, Shachar Lovett, Roy Schwartz, and Omri Weinstein. On the furthest hyperplane problem and maximal

margin clustering, 2011.

[27] Zohar Karnin, Edo Liberty, Shachar Lovett, Roy Schwartz, and Omri Weinstein. Unsupervised svms: On the complexity of the
furthest hyperplane problem. In Shie Mannor, Nathan Srebro, and Robert C. Williamson, editors, Proceedings of the 25th Annual
Conference on Learning Theory, volume 23 of Proceedings of Machine Learning Research, pages 2.1–2.17, Edinburgh, Scotland,
25–27 Jun 2012. PMLR.

[28] V. Koltchinskii. Oracle Inequalities in Empirical Risk Minimization and Sparse Recovery Problems. Springer, Berlin, 2011.
[29] Vladimir Koltchinskii and Shahar Mendelson. Bounding the smallest singular value of a random matrix without concentration. Int.

Math. Res. Notices, to appear. arXiv:1312.3580.

[30] G. Lecu´e and S. Mendelson. Sparse recovery under weak moment assumptions. J. Eur. Math. Soc., to appear. ArXiv:1401.2188.
[31] Guillaume Lecu´e and Shahar Mendelson. Learning subgaussian classes: Upper and minimax bounds. arXiv preprint arXiv:1305.4825,

2013.

[32] Guillaume Lecu´e and Shahar Mendelson. Performance of empirical risk minimization in linear aggregation. Bernoulli, 22(3):1520–

1534, 2016.

[33] Guillaume Lecu´e and Matthieu Lerasle. Robust machine learning by median-of-means : theory and practice, 2017.
[34] Guillaume Lecu´e and Shahar Mendelson. Regularization and the small-ball method i: sparse recovery, 2016.
[35] Zhixian Lei, Kyle Luh, Prayaag Venkat, and Fred Zhang. A fast spectral algorithm for mean estimation with sub-gaussian rates,

2019.

[36] Matthieu Lerasle. Lecture notes: Selected topics on robust statistical learning theory, 2019.
[37] Gabor Lugosi and Shahar Mendelson. Risk minimization by median-of-means tournaments, 2016.
[38] Gabor Lugosi and Shahar Mendelson. Mean estimation and regression under heavy-tailed distributions–a survey, 2019.
[39] G´abor Lugosi, Shahar Mendelson, et al. Sub-gaussian estimators of the mean of a random vector. The Annals of Statistics,

47(2):783–794, 2019.

[40] Z. Szabo M. Lerasle, T. Matthieu and G. Lecu´e. Monk – outliers-robust mean embedding estimation by median-of-means. Technical

report, CNRS, University of Paris 11, Ecole Polytechnique and CREST, 2017.

[41] Pascal Massart. Concentration inequalities and model selection, volume 1896 of Lecture Notes in Mathematics. Springer, Berlin,
2007. Lectures from the 33rd Summer School on Probability Theory held in Saint-Flour, July 6–23, 2003, With a foreword by Jean
Picard.

[42] Stanislav Minsker. Geometric median and robust estimation in banach spaces. Bernoulli, 21(4):2308–2335, 2015.
[43] A. S. Nemirovsky and D. B. and Yudin. Problem complexity and method eﬃciency in optimization. A Wiley-Interscience Publication.
John Wiley & Sons, Inc., New York, 1983. Translated from the Russian and with a preface by E. R. Dawson, Wiley-Interscience
Series in Discrete Mathematics.

[44] Roberto Imbuzeiro Oliveira. The lower tail of random quadratic forms with applications to ordinary least squares. Probab. Theory

Related Fields, 166(3-4):1175–1194, 2016.

[45] Adarsh Prasad, Arun Sai Suggala, Sivaraman Balakrishnan, and Pradeep Ravikumar. Robust estimation via robust gradient

estimation, 2018.

[46] John W. Tukey. The future of data analysis. Ann. Math. Statist., 33:1–67, 1962.
[47] Sara van de Geer and Alan Muro. On higher order isotropy conditions and lower bounds for sparse quadratic forms. Electron. J.

Stat., 8(2):3031–3061, 2014.

[48] Aad van der Vaart and Jon A. Wellner. A note on bounds for VC dimensions, volume Volume 5 of Collections, pages 103–107.

Institute of Mathematical Statistics, Beachwood, Ohio, USA, 2009.

[49] Hugh E. Warren. Lower bounds for approximation by nonlinear manifolds. Transactions of the American Mathematical Society,

133(1):167–178, 1968.

7 Appendix

input : ˜Z1, . . . , ˜ZK, θ and u1, ..., uT .
output: u.

1 while (cid:104)Zi, u(cid:105) ≤ θ/10 for more than 0.6K blocks do
2

gj ∼ N (0, 1) for j ∈ {1, ..., T }
u = (cid:80)
Report ”Fail” and exit if more than T trials have been performed

j gjui/|| (cid:80)

j gjui||

3

4
5 end
6 Return u.

Algorithm 4: Round

13

input : ˜X1, ˜Y1 . . . , ˜XN , ˜YN , βc, K ≥ |O|, Tdes
output: A good distance estimation, dt

(cid:80)

j∈Bi

( ˜Yj − βc ˜Xj)Σ−1/2 ˜Xj

1 Let, for i ≤ K, ˜Zi = 1
m
2 Z (cid:48) = prune( ˜Z)
3 R = max( ˜Z (cid:48)
i)
4 dhigh = R, dlow = 0
5 for j ∈ {1, 2, ..., (cid:98)log(K)(cid:99)} do
dm = (dhigh + dlow)/2
6
if BregmanRegression(Z (cid:48), d, log(Tdes) + log(K)K) returns ”Fail” then

7

8

9

10

11

dhigh ← dm

end
else

dlow ← dm

end

12
13 end
14 Return dlow × 2/100 × (1/10) × (100/102).

Algorithm 5: stepSize

input : ˜X1, ˜Y1 . . . , ˜XN , ˜YN , βc, K ≥ |O|, Tdes, θ.
output: u.

(cid:80)

1 Let, for i ≤ K, ˜Zi = 1
m
2 prune( ˜Z)
3 u = BregmanRegression( ˜Z, θ × 100/2 × (10) × (102/100), log(Tdes) + log(K)K)
4 Return Σ−1/2u.

( ˜Yj − βc ˜Xj)Σ−1/2 ˜Xj

j∈Bi

Algorithm 6: descentDirection

14

