2
2
0
2

r
a

M
1
3

]
L
P
.
s
c
[

2
v
7
7
5
7
0
.
2
0
2
2
:
v
i
X
r
a

Weighted Programmingâˆ—
A Programming Paradigm for Specifying Mathematical Models

KEVIN BATZ, RWTH Aachen University, Germany
ADRIAN GALLUS, RWTH Aachen University, Germany
BENJAMIN LUCIEN KAMINSKI, Saarland University, Saarland Informatics Campus, Germany and Uni-
versity College London, United Kingdom
JOOST-PIETER KATOEN, RWTH Aachen University, Germany
TOBIAS WINKLER, RWTH Aachen University, Germany

We study weighted programming, a programming paradigm for specifying mathematical models. More specif-
ically, the weighted programs we investigate are like usual imperative programs with two additional features:
(1) nondeterministic branching and (2) weighting execution traces. Weights can be numbers but also other ob-
jects like words from an alphabet, polynomials, formal power series, or cardinal numbers. We argue that
weighted programming as a paradigm can be used to specify mathematical models beyond probability distri-
butions (as is done in probabilistic programming).

We develop weakest-precondition- and weakest-liberal-precondition-style calculi Ã  la Dijkstra for reason-
ing about mathematical models speciï¬ed by weighted programs. We present several case studies. For instance,
we use weighted programming to model the ski rental problem â€” an optimization problem. We model not only
the optimization problem itself, but also the best deterministic online algorithm for solving this problem as
weighted programs. By means of weakest-precondition-style reasoning, we can determine the competitive
ratio of the online algorithm on source code level.

CCS Concepts: â€¢ Theory of computation â†’ Models of computation; Programming logic; Denota-
tional semantics; Invariants; Pre- and post-conditions; Program semantics.

Additional Key Words and Phrases: weighted programming, denotational semantics, weakest preconditions

1 INTRODUCTION AND OVERVIEW

Weighted programs are usual programs with two distinct features: (1) nondeterministic branching
and (2) the ability to weight the current execution trace. A prime and very well-studied example
of weighted programs are probabilistic programs which can branch their execution depending on
the outcome of a random coin ï¬‚ip. For instance, the program { ğ¶1 }
{ ğ¶2 } weights the trace
that executes ğ¶1 with probability 1/3 and the trace executing ğ¶2 with 1 âˆ’ 1/3 = 2/3. The weighted
outcomes of the two branches are then â€” simply put â€” summed together.

1
3

(cid:2)

(cid:3)

Besides applications as randomized algorithms for speed-up in solving computationally intractable

problems, probabilistic programming has over the past decade gained rapidly increasing attention
in machine learning. There, probabilistic programs serve as intuitive algorithmic descriptions of
complicated probability distributions. As Gordon et al. [2014] put it:

â€œThe goal of probabilistic programming is to enable probabilistic modeling [. . . ] to be
accessible to the working programmer, who has suï¬ƒcient domain expertise, but perhaps
not enough expertise in probability theory [. . . ].â€

âˆ—Accepted for publication (https://doi.org/10.1145/3527310).

Authorsâ€™ addresses: Kevin Batz, kevin.batz@cs.rwth-aachen.de, RWTH Aachen University, Aachen, Germany; Adrian
Gallus, adrian.gallus@rwth-aachen.de, RWTH Aachen University, Aachen, Germany; Benjamin Lucien Kaminski, b.
kaminski@ucl.ac.uk, Saarland University, Saarland Informatics Campus, SaarbrÃ¼cken, Germany and University College
London, London, United Kingdom; Joost-Pieter Katoen, katoen@cs.rwth-aachen.de, RWTH Aachen University, Aachen,
Germany; Tobias Winkler, tobias.winkler@cs.rwth-aachen.de, RWTH Aachen University, Aachen, Germany.

 
 
 
 
 
 
2

Batz, Gallus, Kaminski, Katoen, and Winkler

In this paper, we consider more general weights than probabilities â€” in fact: more general than
numbers. We should stress that we are not the ï¬rst to consider weighted programs (see e.g. [Aguirre
and Katsumata 2020; Brunel et al. 2014; Gaboardi et al. 2021] and see Section 7 for detailed com-
parisons).

Our goal was, however, not to merely go from probabilistic to weighted programming, just for
the sake of generalization. Instead, we advocate weighted programming as a programming paradigm
for specifying mathematical models. In particular, our prime goal is to take a step towards making
mathematical modeling more accessible to people with a programming background. In a nutshell:

Render mathematical modeling accessible to the working programmer,
who has suï¬ƒcient domain expertise, but perhaps not enough expertise
in the respective mathematical theory.

Towards that goal, let us have a look at how such modeling could work in practice.

Weighted Programming as a Paradigm for Specifying Mathematical Models
As a motivating example, we consider the classical Ski Rental Problem [Komm 2016], a classi-
cal optimization problem, studied also in the context of online algorithms and competitive anal-
ysis [Borodin and El-Yaniv 1998]. A precise textual description of the problem is as follows:

The Scenario: A person does not own a pair of skis but is going on a skiing trip
for ğ‘› days. At the beginning of each day, the person can chose between two options:
Either rent a pair of skis, costing 1e for that day; or buy a pair of skis, costing ğ‘¦e
(and then go skiing for all subsequent days free of charge).
The Question: What is the optimal (i.e. minimal) amount of money that the person
has to spend for a pair of skis for the entire length of the trip?

Using weighted programming, we can model the scenario of this op-
timization problem in a quite natural, simple, and intuitive way by
the weighted program opt on the right. Intuitively, this weighted
program tests each day whether the vacation is already over (Line
1). If not, it does the following (Lines 2â€“5): First, it decrements the
vacation length by 1 day (Line 2). It then models the two options
that the person has for each day by a nondeterministic branching
(Line 4). In the left branch, it realizes the ï¬rst option: Paying 1e
(Line 3). In the right branch, it realizes the second option: Paying
ğ‘¦e and then setting the remaining vacation length to 0 (Line 5),
because with respect to having to pay for a pair of skis (not with
respect to the joy of skiing) the vacation has eï¬€ectively ended.

The Scenario:

1:

2:

3:

4:

5:

while ( ğ‘› > 0 ) {
ğ‘› â‰” ğ‘› âˆ’ 1
{

#

âŠ™ 1

} âŠ• {

âŠ™ ğ‘¦

ğ‘› â‰” 0

}

#

}

If we now want to answer the question of the optimization prob-
lem, we ï¬rst chose a suitable semiring. In this setting of opti-
mizing (i.e. minimizing) incurred cost, the tropical semiring T =
(N+âˆ, min, +, âˆ, 0) comes to mind. The carrier set of this semir-
ing are the extended natural numbers. The addition (âŠ•) in this semiring is taking the minimum
of two numbers. In the program, this is reï¬‚ected by the fact that in Line 4 we would like to make
whatever choice is cheaper for us. The multiplication (âŠ™) is the standard addition of numbers. In
the program, this is reï¬‚ected, for example, in Line 3, where we add a 1 to the current execution
trace.

The Question:

opt
K
J

( 1 ) = ?

wp

For actually answering the question of the optimization problem, we determine a weakest pre-
condition of sorts, but interpreted here in a more general â€œquantitativeâ€ setting, with respect to
postâ€œconditionâ€ 1 â€” the multiplicative identity of the semiring; in this case, 1 is the natural number 0.

Weighted Programming

3

Intuitively, this will for each path multiply together the weights along the path (recall: semiring
multiplication is natural number addition). Then, we sum over the weights of all paths (recall:
semiring summation is natural number minimization), thus yielding the accumulated costs along
the least expensive path. As a result, our weakest-precondition-style calculus will yield

i.e. the minimum of the numbers ğ‘› and ğ‘¦. This is precisely the solution to our optimization problem:
If the trip length ğ‘› is larger than the cost of buying skis, we should buy skis which will cost us ğ‘¦e.
If ğ‘› is smaller than ğ‘¦, we should instead rent each day (at cost 1e/day) which will cost us ğ‘›e.

wp

opt
K

J

( 1 ) = ğ‘› âŠ• ğ‘¦ ,

( 1 ) / wp

onl
K
J

onl that solves the ski rental problem and determine wp
opt
ratio wp
K

Toward competitive analysis, we can now model the cost of a deterministic online algorithm
( 1 ). Then, we can compute the
onl
( 1 ) to determine the competitive ratio of the online algorithm onl.
K
We stress that program opt from above is not strictly speaking executable. For that, one would
need some sort of scheduler who determinizes the nondeterministic choices. It is also not imme-
diately clear what weighting the individual execution traces on a physical computer would mean.
Instead, the above weighted program encodes a mathematical model, namely an optimization prob-
lem, by means of an algorithmic representation â€” much in the spirit of a probabilistic program that
is also not necessarily meant to be executed but instead models a probability distribution.

J

J

Lastly, we would like to note that determining weakest preconditions is related to inference in
probabilistic programming [Gordon et al. 2014], where one is concerned with, e.g., determining
the probability that the probabilistic program establishes some postcondition.

Contributions
Our main technical contribution is the â€” to the best of our knowledge â€” ï¬rst weakest precondition-
style reasoning framework for weighted programs, which conservatively extends both Dijkstraâ€™s
classical weakest preconditions and weakest liberal weakest preconditions. Our weakest pre cal-
culi capture the semantics of unbounded and potentially nonterminating loops eï¬€ortlessly, while
other works explicitly avoid partiality (see Section 7). Our weakest liberal preweightings even
give a nuanced semantics to nonterminating runs in order to reason about such traces as well. We
demonstrate the applicability of our framework by several examples.

To achieve a high degree of generality and applicability, our framework is parameterized by
a monoid of weights for weighting computations of programs and so-called weightings that take
over the role of â€œquantitative assertionsâ€. We prove well-deï¬nedness and healthiness conditions
of our calculi, provide formal connections to an operational semantics, and develop easy-to-apply
invariant-based reasoning techniques.

Outline
Section 2 provides preliminaries on monoids and semirings. Section 3 introduces the syntax and
operational semantics of weighted programs. We introduce our weakest (liberal) preweighting
calculi for reasoning about weighted programs in Section 4. Invariant-style reasoning for loops is
presented in Section 5. In Section 6, we demonstrate the eï¬ƒcacy of our framework by means of
several examples. In Section 7, we give an overview of and a comparison to other works that study
weighted computations. We conclude in Section 8.

2 MONOIDS AND SEMIRINGS

The weights occurring in our programs are elements from a monoid. Intuitively, this is because we
would like to â€œmultiplyâ€ the weights on a programâ€™s computation trace together in order to obtain
the total weight of that trace. In particular, this multiplication should be associative and allow for

4

Batz, Gallus, Kaminski, Katoen, and Winkler

neutral, i.e. eï¬€ectless weighting. In Section 4.2 further below, we introduce monoid modules that
are another important ingredient for our theory.

Deï¬nition 2.1 (Monoids). A monoid W = (ğ‘Š , âŠ™, 1) consists of a carrier set ğ‘Š , an operation

âŠ™ : ğ‘Š Ã— ğ‘Š â†’ ğ‘Š , and an identity 1 âˆˆ ğ‘Š , such that for all ğ‘, ğ‘, ğ‘ âˆˆ ğ‘Š ,

(1) the operation âŠ™ is associative, i.e.
(2) 1 is an identity with respect to âŠ™, i.e.

ğ‘ âŠ™ (ğ‘ âŠ™ ğ‘) = (ğ‘ âŠ™ ğ‘) âŠ™ ğ‘,
ğ‘ âŠ™ 1 = 1 âŠ™ ğ‘ = ğ‘.

and

The monoid W is called commutative if moreoever ğ‘ âŠ™ ğ‘ = ğ‘ âŠ™ ğ‘ holds.

â–³

Â· , ğœ–) over alphabet Î“ â‰  âˆ… and the
Important examples of monoids are the words monoid (Î“âˆ—,
probability monoid ( [0, 1], Â· , 1) (the latter is commutative). Another algebraic structure that plays
a key role in this paper are semirings. Even though they are not strictly required for our theory, they
render the application of our framework easier and more intuitive. This is because every semiring
is a monoid module over itself, which we explain in more detail in Section 4.2. Our deï¬nition of
semirings is stated below; for an in-depth introduction, we refer to [Droste et al. 2009, Ch. 1, 2].
As usual, multiplication âŠ™ binds stronger than addition âŠ• and we omit parentheses accordingly.

Deï¬nition 2.2 (Semirings). A semiring S = (ğ‘†, âŠ•, âŠ™, 0, 1) consists of a carrier set ğ‘†, an addi-

tion âŠ• : ğ‘† Ã— ğ‘† â†’ ğ‘†, a multiplication âŠ™ : ğ‘† Ã— ğ‘† â†’ ğ‘†, a zero 0 âˆˆ ğ‘†, and a one 1 âˆˆ ğ‘†, such that

(1) (ğ‘†, âŠ•, 0) forms a commutative monoid;
(2) (ğ‘†, âŠ™, 1) forms a (possibly non-commutative) monoid;
(3) multiplication distributes over addition, i.e. for all ğ‘, ğ‘, ğ‘ âˆˆ ğ‘†,

ğ‘ âŠ™ (ğ‘ âŠ• ğ‘) = ğ‘ âŠ™ ğ‘ âŠ• ğ‘ âŠ™ ğ‘

and

(ğ‘ âŠ• ğ‘) âŠ™ ğ‘ = ğ‘ âŠ™ ğ‘ âŠ• ğ‘ âŠ™ ğ‘ ;

and

(4) multiplication by zero annihilates ğ‘†, i.e.

0 âŠ™ ğ‘ = ğ‘ âŠ™ 0 = 0 .

â–³

Our â€œcheat sheetâ€ in Table 1 lists various example semirings along with possible applications in a
weighted programming context. Further well-known semirings not considered speciï¬cally in this
paper include (i) the Åukasiewicz semiring [Gerla 2003; Nola and Gerla 2005] motivated by multival-
ued logics and related to tropical geometry [Gavalec et al. 2015], (ii) the resolution semiring [Bagnol
2014] from proof theory, (iii) the categorial and lexicographic semirings [Sproat et al. 2014] used
in natural language processing, (iv) the thermodynamic semirings [Marcolli and Thorngren 2011,
2014] employed in information theory, and (v) the conï¬dence-probability semiring [Wirsching et al.
2010]. We leave the study of applications of weighted programs over these semirings for future
work. Finally, we mention that more complicated semirings can be created from existing ones
through algebraic constructions like matrices, tensors, polynomials, or formal power series.

3 WEIGHTED PROGRAMS
For a monoid W = (ğ‘Š , âŠ™, 1) of weights, we study the W-weighted guarded command lan-
guage W-wGCL featuring â€” in addition to standard control-ï¬‚ow instructions â€” branching and
weighting. If the monoid W is evident from the context, we omit the symbol and write just wGCL.

1Also known as max-min-semiring. The name Bottleneck semiring is taken from [Pouly 2010]. Quantitative veriï¬cation
using this semiring is further studied in [Zhang and Kaminski 2022a,b].

Weighted Programming

5

Table 1. Weighted programming cheat sheet.

Optimization via the Tropical semiring (N+âˆ, min, +, +âˆ, 0)
Weighting âŠ™ ğ’‚:
Accumulate cost ğ‘
Postweighting ğ’‡ :

Branching âŠ•:
Choose branch that will accumulate minimal cost
wp Jğ‘ª K ( 0 ):
Minimal accumulated cost amongst all termi-
nating executions of ğ¶

Cost that is accumulated after program ter-
mination; typically choose ğ‘“ = 0

wlp Jğ‘ª K ( ğ’‡ ):
Minimum of wp Jğ¶K ( ğ‘“ ) and the min-
imal accumulated cost amongst all non-
terminating executions of ğ¶

âˆ’âˆ, max, +, âˆ’âˆ, 0)

Optimization via the Arctic semiring (N+âˆ
Weighting âŠ™ ğ’‚:
Accumulate cost ğ‘
Postweighting ğ’‡ :
Cost that is accumulated after program ter-
mination; typically choose ğ‘“ = 0
Optimization via the Bottleneck semiring1 (R+âˆ
Weighting âŠ™ ğ’‚:
Restrict capacity of current branch to ğ‘

Branching âŠ•:
Choose branch that will accumulate maximal cost
wp Jğ‘ª K ( 0 ):
Maximal accumulated cost amongst all termi-
nating executions of ğ¶

âˆ’âˆ, max, min, âˆ’âˆ, +âˆ)

Branching âŠ•:
Choose branch with accumulate maximal capacity
wp Jğ‘ª K ( ğ’‡ ):
Maximum bottleneck amongst all terminat-
ing executions of ğ¶

Postweighting ğ’‡ :
Upper bound after program termination;
typically choose ğ‘“ = +âˆ

Model Checking via the Formal languages semiring

2Î“âˆ—

, âˆª,

Â· , âˆ…, { ğœ€ }

Weighting âŠ™ ğ’‚:
Append symbol ğ‘ to current trace

Branching âŠ•:
Account for/aggregate behavior of both branches
wp Jğ‘ª K ( {ğœº } ):

(cid:0)

(cid:1)

Language of all terminating traces of ğ¶

Postweighting ğ’‡ :
Language that is appended to each termi-
nated trace; typically choose ğ‘“ = {ğœ– }
Combinatorics via the (extended) Natural Numbers semiring (N+âˆ, +,
Branching âŠ•:
Weighting âŠ™ ğ’‚:
Make ğ‘ copies of current path/trace
Sum up number of paths/traces of both branches
wp Jğ‘ª K ( 1 ):
Number of all terminating paths/traces of ğ¶

Postweighting ğ’‡ :
Number of copies that is made of each ter-
minated path/trace; typically choose ğ‘“ = 1

wlp Jğ‘ª K ( ğ’‡ ):
Same as wp Jğ¶K ( ğ‘“ ) if all executions of ğ¶
terminate, else +âˆ

wlp Jğ‘ª K ( ğ’‡ ):
Maximum bottleneck amongst all executions
of ğ¶

wlp Jğ‘ª K ( {ğœº } ):
Language of all terminating and nontermi-
nating traces of ğ¶

Â· , 0, 1)

wlp Jğ‘ª K ( ğ’‡ ):
Same as wp Jğ¶K ( ğ‘“ ) if all executions of ğ¶
terminate, else +âˆ

Hidden Markov Models via the Viterbi semiring ( [0, 1], max,
Weighting âŠ™ ğ’‚:
Let what follows happen with probability ğ‘

Branching âŠ•:
Choose branch of maximal probability

Â· , 0, 1)

Postweighting ğ’‡ :
Probability additionally multiplied to each
terminated trace; typically choose ğ‘“ = [ğœ‘ ],
i.e. the indicator function of some event ğœ‘

wp Jğ‘ª K ( [ğ‹] ):

Maximal probability of a terminating execu-
tion establishing ğœ‘

wlp Jğ‘ª K ( [ğ‹] ):
Maximal probability of a non-terminating ex-
ecution, or a terminating execution establish-
ing ğœ‘

Veriï¬cation/Debugging via the Boolean semiring ({0, 1}, âˆ¨, âˆ§, 0, 1)
Weighting âŠ™ ğ’‚:
Assert predicate ğ‘

Branching âŠ•:
Angelic choice: choose â€œmost trueâ€ branch
wp Jğ‘ª K ( ğ’‡ ):

Postweighting ğ’‡ :

Postcondition (a predicate) that should be
established after program termination

Weakest precondition of ğ‘“ , the weakest pred-
icate ğ‘” so that starting in ğ‘”, program ğ¶ can
terminate in state ğœ |= ğ‘“

wlp Jğ‘ª K ( ğ’‡ ):
Weakest liberal precondition of ğ‘“ , the weak-
est predicate ğ‘” so that starting in ğ‘”, program
ğ¶ can either diverge or terminate in state
ğœ |= ğ‘“

Feature Selection via the Why semiring (propositional positive DNF, âˆ¨, âˆ§, 0, 1) over a ï¬nite set
of variables ğ‘‹1, . . . , ğ‘‹ğ‘› (cf. [Dannert et al. 2019])
Weighting âŠ™ ğ’‚:
Use resource ğ‘
Postweighting ğ’‡ :

Branching âŠ•:
Alternatives: use resources via ğ¶1 or via ğ¶2
wp Jğ‘ª K ( [ğ‹] ):

Combinations of resources used after termi-
nation; typically choose ğ‘“ = [ğœ‘ ]

Possible alternatives (disjunction) of
source sets (conjunction) to reach event ğœ‘

re-

wlp Jğ‘ª K ( [ğ‹] ):
Possible alternatives (disjunction) of
re-
source sets (conjunction) to either not termi-
nate or reach event ğœ‘

6

Batz, Gallus, Kaminski, Katoen, and Winkler

3.1 Syntax
wGCL programs ğ¶ adhere to the grammar

ğ¶

âˆ’â†’ { ğ¶1 } âŠ• { ğ¶2 }
ğ‘¥ â‰” ğ¸
|
ğ¶2
ğ¶1
skip â‰¡ âŠ™ 1

#

|

|

| âŠ™ ğ‘
|

if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }
while ( ğœ‘ ) { ğ¶1 }
{ ğ¶1 } ğ‘ âŠ•ğ‘ { ğ¶2 } â‰¡ { âŠ™ ğ‘

|

|

(branching | weighting)

(assignment | conditional choice)

(sequential composition | loop)

ğ¶1 } âŠ• { âŠ™ ğ‘

ğ¶2 }

(syntactic sugar)

where ğ‘¥ is a program variable from a countable set Vars, ğ¸ is an arithmetic expression over Vars, ğœ‘
is a Boolean expression (also called guard), and ğ‘ is a weight from the monoidâ€™s carrier ğ‘Š .

#

#

Our programs feature branching â€œ{ ğ¶1 } âŠ• { ğ¶2 }â€ and weighting â€œâŠ™ ğ‘â€ of the current computation
path where ğ‘ âˆˆ ğ‘Š represents some weight. For example, we can express a probabilistic choice â€œex-
ecute ğ¶1 with probability 1/3 and ğ¶2 otherwiseâ€ as { ğ¶1 } 1/3âŠ•2/3 { ğ¶2 } over the monoid ( [0, 1], Â·, 1).
We allow for syntactic sugar in weightings, e.g. âŠ™ ğ‘ğ‘¥ for some ğ‘ âˆˆ ğ‘Š , ğ‘¥ âˆˆ Vars.2 The symbol âŠ™
used in the weight-statement is reminiscent of the corresponding monoid operation in W. The
symbol âŠ• we use for the branching-statement will become evident in Section 4.

3.2 Program States
A program state ğœ maps each variable in Vars to its value in N. To ensure that the set of program
states is countable,3 we restrict to states in which at most ï¬nitely many variables have a non-zero
value. Intuitively, those that appear in a given program are possibly assigned a non-zero value.
Formally, the set Î£ of program states is given by

Î£ â‰” { ğœ : Vars â†’ N | { ğ‘¥ âˆˆ Vars | ğœ (ğ‘¥) â‰  0 } is ï¬nite } .

We overload notation and denote by ğœ (ğœ‰) the evaluation of the (arithmetic, Boolean, or weight)
expression ğœ‰ in ğœ, i.e. the value obtained from evaluating ğœ‰ after replacing every variable ğ‘¥ in ğœ‰
by ğœ (ğ‘¥). We denote by ğœ [ğ‘¥ â†¦â†’ ğ‘£] the update of variable ğ‘¥ by value ğ‘£ in state ğœ. Formally:

ğœ [ğ‘¥ â†¦â†’ ğ‘£] â‰” ğœ† ğ‘¦.

ğ‘£
ğœ (ğ‘¦)

(

if ğ‘¦ = ğ‘¥,
otherwise.

3.3 Operational Semantics

To formalize our notion of weighted computation paths, we deï¬ne small-step operational semantics
[Plotkin 2004] in terms of a weighted computation graph, or rather a weighted computation forest.4
Apart from our special weight operation âŠ™ ğ‘, the operational semantics is standard but we include
the details for the sake of completeness. Intuitively, the computation forest of W-wGCL contains
one tree ğ‘‡ğ¶,ğœ per program ğ¶ and initial state ğœ representing the computation of ğ¶ on initial state
ğœ.

Deï¬nition 3.1 (Computation Forest of W-wGCL). For the monoid W = (ğ‘Š , âŠ™, 1), the computa-

tion forest of W-wGCL is the (countably inï¬nite) directed weighted graph G = (ğ‘„, Î”), where
â€¢ ğ‘„ = (wGCL âˆª { â†“ }) Ã— Î£ Ã— N Ã— { ğ¿, ğ‘… }âˆ— is the set of vertices (called conï¬gurations);
â€¢ Î” âŠ† ğ‘„ Ã— ğ‘Š Ã— ğ‘„ is the set of directed weighted edges (called transitions) which is deï¬ned as
â–³

the smallest set satisfying the SOS-rules in Fig. 1.

2The corresponding program ğ‘– â‰” ğ‘¥ # while ( ğ‘– > 0 ) { âŠ™ ğ‘ # ğ‘– â‰” ğ‘– âˆ’ 1 } requires introducing a fresh loop-variable ğ‘– âˆˆ Vars.
3We restrict Î£ a priori to avoid technical issues; even wGCL programs over uncountable Î£ reach just countably many
states.
4A path-based semantics in terms of trees is convenient for technical reasons; it allows to distinguish programs like skip
from { skip } âŠ• { skip }. The latter has two terminating computation paths with weight 1 and the former has only one.

Weighted Programming

ğœâ€² = ğœ [ğ‘¥ â†¦â†’ Jğ¸K(ğœ) ]
hğ‘¥ â‰” ğ¸, ğœ, ğ‘›, ğ›½ i âŠ¢1 hâ†“, ğœâ€², ğ‘›+1, ğ›½ i

(assign)

hâŠ™ ğ‘, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hâ†“, ğœ, ğ‘›+1, ğ›½ i

(weight)

hğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hâ†“, ğœâ€², ğ‘›+1, ğ›½ i
hğ¶1 # ğ¶2, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶2, ğœâ€², ğ‘›+1, ğ›½ i

(seq. 1)

ğœ |= ğœ‘
hif ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }, ğœ, ğ‘›, ğ›½ i âŠ¢1 hğ¶1, ğœ, ğ‘›+1, ğ›½ i

(if)

hğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€²

1, ğœâ€², ğ‘›+1, ğ›½ i

hğ¶1 # ğ¶2, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€²

and ğ¶â€²
1
1 # ğ¶2, ğœâ€², ğ‘›+1, ğ›½ i
ğœ |= Â¬ğœ‘
hif ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }, ğœ, ğ‘›, ğ›½ i âŠ¢1 hğ¶2, ğœ, ğ‘›+1, ğ›½ i

(seq. 2)

â‰  â†“

7

(else)

h{ ğ¶1 } âŠ• { ğ¶2 }, ğœ, ğ‘›, ğ›½ i âŠ¢1 hğ¶1, ğœ, ğ‘›+1, ğ›½ğ¿i

(l. branch)

h{ ğ¶1 } âŠ• { ğ¶2 }, ğœ, ğ‘›, ğ›½ i âŠ¢1 hğ¶2, ğœ, ğ‘›+1, ğ›½ğ‘…i

(r. branch)

ğœ |= ğœ‘
hwhile ( ğœ‘ ) { ğ¶ }, ğœ, ğ‘›, ğ›½ i âŠ¢1 hğ¶ # while ( ğœ‘ ) { ğ¶ }, ğœ, ğ‘›+1, ğ›½ i

(while)

ğœ |= Â¬ğœ‘
hwhile ( ğœ‘ ) { ğ¶ }, ğœ, ğ‘›, ğ›½ i âŠ¢1 hâ†“, ğœ, ğ‘›+1, ğ›½ i

(break)

Fig. 1. Structural operational semantics of wGCL-programs.

We use the notation ğœ…1 âŠ¢ğ‘ ğœ…2 instead of (ğœ…1, ğ‘, ğœ…2) âˆˆ Î”. Intuitively, for a conï¬guration hğ¶, ğœ, ğ‘›, ğ›½i,
the component ğ¶ represents the program that still needs to be executed (thus playing the role
of a â€œprogram counterâ€) and ğ¶ = â†“ indicates termination; ğœ is the current program state (variable
valuation); ğ‘› is the number of computation steps that have been executed so far and ğ›½ is the history
of left and right branches that have been taken. Remembering the number of computation steps
and the history of left and right branches ensures that G is indeed a forest. Moreover, it is easy
to check that G has no multi-edges, i.e. there is at most one weighted edge between any two
conï¬gurations.

Note that G is ï¬nitely branching and that the only rules that alter the branching history ğ›½ are
(l. branch) and (r. branch). In particular, (if) and (else) do not change ğ›½ because they are not truly
branching: Indeed, all conï¬gurations of the form hif ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }, ğœ, ğ‘›+1, ğ›½i have a
unique successor conï¬guration which depends on whether or not ğœ satisï¬es ğœ‘.

An initial conï¬guration is of the form ğœ… = hğ¶, ğœ, 0, ğœ–i for arbitrary ğ¶ and ğœ. For initial conï¬gu-
rations we also write hğ¶, ğœi instead of hğ¶, ğœ, 0, ğœ–i. By deï¬nition of Î”, initial conï¬gurations have
no incoming transitions; they are thus the roots of the trees in the computation forest. Similarly,
a conï¬guration hâ†“, ğœ, ğ‘›, ğ›½i is called ï¬nal. Final conï¬gurations are the leaves of the forest.

We can now deï¬ne computation paths. For ğœ… âˆˆ ğ‘„, let succ(ğœ…) â‰” { ğœ… â€² âˆˆ ğ‘„ | âˆƒğ‘ âˆˆ ğ‘Š : ğœ… âŠ¢ğ‘ ğœ… â€² }
be the set of all possible successor conï¬gurations. A computation path of length ğ‘› âˆˆ N is a ï¬nite
path ğœ‹ = ğœ…0ğœ…1 . . . ğœ…ğ‘› in G, i.e. ğœ…ğ‘–+1 âˆˆ succ(ğœ…ğ‘– ) for all ğ‘– = 0, . . . , ğ‘› âˆ’ 1, such that ğœ…0 is initial. The
set of all such paths is denoted Pathsğ‘›
ğœ…0 . Since G has no multi-edges, for two conï¬gurations ğœ… and
ğœ… â€² âˆˆ succ(ğœ…) we denote the unique weight ğ‘ âˆˆ ğ‘Š such that ğœ… âŠ¢ğ‘ ğœ… â€² by wgt(ğœ… ğœ… â€²). The weight of a
computation path ğœ…0ğœ…1 . . . ğœ…ğ‘› is then deï¬ned as

wgt(ğœ…0ğœ…1 . . . ğœ…ğ‘›) â‰”

ğ‘›âˆ’1

Ãˆğ‘–=0

wgt(ğœ…ğ‘– ğœ…ğ‘–+1) = wgt(ğœ…0 ğœ…1) âŠ™ wgt(ğœ…1 ğœ…2) âŠ™ Â· Â· Â· âŠ™ wgt(ğœ…ğ‘›âˆ’1 ğœ…ğ‘›) .

Recall that our monoids are not commutative in general, and thus the order of the above product
matters. The last state of computation path ğœ‹ = ğœ…0ğœ…1 . . . ğœ…ğ‘› is the program state at conï¬guration
ğœ…ğ‘› and is denoted last(ğœ‹) âˆˆ Î£. The computation path ğœ‹ is called terminal if ğœ…ğ‘› is ï¬nal. Given an
initial conï¬guration ğœ…0, we deï¬ne the set of terminating computation paths starting in ğœ…0 as

TPathsğœ…0

=

Ã˜ğ‘› âˆˆN

(cid:8)

ğœ‹ âˆˆ Pathsğ‘›
ğœ…0

ğœ‹ is terminal

.

(cid:12)
(cid:12)

(cid:9)

Note that TPathsğœ…0 is a countable set for each ğœ…0. An inï¬nite computation path is an inï¬nite se-
quence ğœ…0ğœ…1 . . . such that ğœ…0 . . . ğœ…ğ‘– is a computation path for all ğ‘– â‰¥ 0.

8

Î£

Î£

wp Jğ¶K ( ğœ“ )

(cid:3)

Â¬wp Jğ¶K ( ğœ“ )

ğœ“

Â¬ğœ“

set

The

(a)
in
perspective:
wp Jğ¶K ( ğœ“ ), ğ¶ can terminate in ğœ“ . Start-
ing in Â¬wp Jğ¶K ( ğœ“ ), ğ¶ either diverges or
terminates in Â¬ğœ“ , but it cannot terminate in ğœ“ .

Starting

Batz, Gallus, Kaminski, Katoen, and Winkler

( ğœ“ )

wp

ğ¶
J

K

ğˆ

(cid:3)

(cid:3)

ğ¶

â€¢
ğœ“ (ğœ1)

Ã” h

â€¢
ğœ“ (ğœ2)

â€¢
ğœ“ (ğœ3)

. . .

i

(b) The map perspective: Given initial state ğœ,
wp Jğ¶K ( ğœ“ ) determines all final states ğœğ‘– reach-
able from executing ğ¶ on ğœ, evaluates ğœ“
in each ğœğ‘– , and returns the disjunction over
these truth values.

Fig. 2. Two perspectives on the angelic weakest precondition of program ğ¶ with respect to postcondition ğœ“ .

4 WEIGHTING TRANSFORMER SEMANTICS

Throughout this section, we develop a weakest-precondition-style calculus Ã  la Dijkstra [1975]
for reasoning about weighted programs on source code level. We start with a recap on Dijkstraâ€™s
weakest preconditions. We then gradually lift weakest preconditions to weakest preweightings.

4.1 Weakest Preconditions
Dijkstraâ€™s weakest precondition calculus is based on predicate transformers

: B â†’ B ,

where B = {0, 1}Î£

is the set of predicates over Î£,

which associate to each nondeterministic program ğ¶ a mapping from predicates to predicates.
Somewhat less common, we consider here an angelic setting, where the nondeterminism is re-
solved to our advantage. Speciï¬cally, the angelic weakest precondition transformer wp
maps
( ğœ“ ) over initial states, such that exe-
a postcondition ğœ“ over ï¬nal states to a precondition wp
( ğœ“ ) guarantees that ğ¶ can5 terminate
K
cuting the program ğ¶ on an initial state satisfying wp
ğ¶
ğœ denotes the set of all
in a ï¬nal state satisfying ğœ“ , see also Figure 2a. More symbolically, if
J
K
ï¬nal states reachable from executing ğ¶ on ğœ, then
ğœ |= ğœ“ .
ğœ |= wp

ğ¶
J
ğ¶
J

implies

âˆƒ ğœ âˆˆ

ğ¶
J

( ğœ“ )

K

K

ğ¶
J

K

ğ¶
J

ğœ :
K

While the above is a set perspective on wp, a diï¬€erent, but equivalent, perspective on wp is the map
perspective, see Figure 2b. From this perspective, the postcondition is a function ğœ“ : Î£ â†’ {0, 1}
( ğœ“ ) is then a function that takes
mapping program states to truth values. The predicate wp
as input an initial state ğœ, determines for each reachable ï¬nal state ğœ âˆˆ
ğœ the (truth) value ğœ“ (ğœ),
K
and ï¬nally returns the disjunction over all these truth values. More symbolically,

ğ¶
J

ğ¶
J

K

wp

ğ¶
J

K

wp

ğ¶
J

K

( ğœ“ ) (ğœ)

=

ğœ“ (ğœ) .

Ãœğœ âˆˆJğ¶Kğœ

5Recall that ğ¶ is a nondeterministic program.

Weighted Programming

9

It is this map perspective which we will now gradually lift to a weighted setting. For that, we
ï¬rst need to leave the realm of Boolean values in which the predicates live. Instead of acting on
Boolean-valued predicates, our calculus will instead act on more general objects called weightings.

4.2 Weightings and Modules
For probabilistic programs, Kozen [1985] and later Morgan et al. [1996] have generalized predicates
to real-valued functions ğ‘“ : Î£ â†’ Râˆ
â‰¥0 (called expectations [McIver and Morgan 2005]) associating a
quantity to every program state. With weightings, we generalize further by associating a more gen-
eral â€œquantityâ€ to every program state. Our wp-style calculus acts on these weightings instead of
Boolean-valued predicates. Weightings form â€” just like ï¬rst-order logic for weakest preconditions
â€” the assertion â€œlanguageâ€ of weakest preweighting reasoning.

Let us ï¬x a monoid W of weights. As with predicates and expectations, we need notions of
addition and multiplication operations for our weightings. The monoid W constituting our pro-
gramsâ€™ weights, however, only provides a multiplication âŠ™. We hence require that our weightings
form a W-module M which does provide an addition. This is inspired by the probabilistic setting
where the program weights â€” the probabilities â€” are taken from the interval [0, 1]6. Expectations,
however, map program states to arbitrary extended reals in Râˆ
â‰¥0 to reason about, e.g. expected
values of program variables. Another advantage of distinguishing between W and M in general
is explained in Example 4.4 further below.

We now deï¬ne modules formally. (Monoid)-modules are similar to vector spaces over ï¬elds in

that they also have a well-behaved scalar multiplication.

Deï¬nition 4.1 (Monoid-Modules). Let W = (ğ‘Š , âŠ™, 1) be a monoid. A (left) W-module M =
(ğ‘€, âŠ•, 0, âŠ—) is a commutative monoid (ğ‘€, âŠ•, 0) equipped with a (left) action called scalar multipli-
cation âŠ— : ğ‘Š Ã— ğ‘€ â†’ ğ‘€, such that for all monoid elements ğ‘£, ğ‘¤ âˆˆ ğ‘Š and module elements ğ‘, ğ‘ âˆˆ ğ‘€,

(1) the scalar multiplication âŠ— is associative, i.e.
(2) the scalar multiplication âŠ— is distributive, i.e.
(3) 1 is neutral w.r.t. âŠ— and 0 annihilates, i.e.
We are now in a position to deï¬ne weightings:

(ğ‘£ âŠ™ ğ‘¤) âŠ— ğ‘ = ğ‘£ âŠ— (ğ‘¤ âŠ— ğ‘) ,
ğ‘£ âŠ— (ğ‘ âŠ• ğ‘) = (ğ‘£ âŠ— ğ‘) âŠ• (ğ‘£ âŠ— ğ‘) ,

1 âŠ— ğ‘ = ğ‘

and ğ‘£ âŠ— 0 = 0.

â–³

Deï¬nition 4.2 (Weightings). Given a W-module M, a function ğ‘“ : Î£ â†’ ğ‘€ associating a weight
from M to each program state is called weighting. We denote the set of all weightings by W.
Elements of W are denoted by ğ‘“ , ğ‘”, â„, . . . and variations thereof.
â–³
The structure (W, âŠ•, 0, âŠ—), where âŠ•, 0, and âŠ— are lifted pointwise, also forms a W-module. We
refer to W as the module of weightings over M. We emphasize that all the results developed in
this paper apply to the important â€” and simpler â€” special case where the monoid and the mod-
ule together form a semiring: The multiplication âŠ™ of a semiring S = (ğ‘†, âŠ•, âŠ™, 0, 1) is then the
left-action âŠ— of the multiplicative monoid of (ğ‘†, âŠ™, 1) to the additive monoid (ğ‘†, âŠ•, 0). For this
reason, we write âŠ™ instead of âŠ— (as both are associative and it should be clear from the rightmost
multiplicantâ€™s type) and adopt the following convention:

Convention. In all examples in this paper, unless stated otherwise, both the monoid W and the

W-module M are given in terms of a semiring S that will be clear from the context.

Towards our goal of deï¬ning a weakest-precondition-style calculus for weighted programs, we
restrict to naturally ordered7 ğœ”-bicontinuous modules:

6Note that probabilities form a monoid under multiplication.
7More generally, partially ordered modules (where the partial order is compatible with the algebraic structure, e. g. addition
and left-action are monotone) also work. However, the natural order is the least (w.r.t. âŠ†) such partial order. We employ
the natural order for simplicity.

10

Batz, Gallus, Kaminski, Katoen, and Winkler

Deï¬nition 4.3 (Natural Order). Given a module M, the binary relation (cid:22) âŠ† ğ‘€ Ã— ğ‘€ given by

ğ‘ (cid:22) ğ‘

iï¬€

âˆƒ ğ‘ âˆˆ ğ‘€ :

ğ‘ âŠ• ğ‘ = ğ‘

is called the natural order on M. If (cid:22) is a partial order, we call M naturally ordered.

â–³

The unique least element of a naturally ordered module is 0. We say that M is ğœ”-bicontinuous if (1)
both the natural order (cid:22) and the reversed natural order (cid:23) are (pointed8) ğœ”-cpos [Abramsky 1994,
Sec. 2.2.4], and (2) the operations âŠ• and âŠ™ are ğœ”-continuous [Abramsky 1994, Sec. 2.2.4] functions
(w.r.t. both (cid:22) and (cid:23)). In particular, for M to be ğœ”-bicontinuous, we require the natural order (cid:22)
to possess a greatest element âŠ¤. The deï¬nition of naturally ordered ğœ”-bicontinuous semirings is
completely analogous. All these properties translate to the aforementioned module of weightings:
W is naturally ordered9 if the underlying module M is naturally ordered and joins/meets can be
deï¬ned pointwise. For example, the Boolean semiring B and the tropical semiring T described in
Section 2 are ğœ”-continuous. Please confer Appendix A for details on the above terms.

Example 4.4 (Modules). Let Î“ be a non-empty alphabet. The structure Lâˆ

, âˆª, âˆ…, Â·) forms
a module over the word monoid Î“âˆ—. Here, Î“âˆ â‰” Î“âˆ— âˆª Î“ğœ” is the set of all ï¬nite and ğœ”-words
over Î“, and the subsets of Î“âˆ are subsequently called ğœ”-potent languages over Î“. Our interest in
Lâˆ
Î“ stems from the fact that we want to study inï¬nite program runs as in Section 4.4. We stress
that this cannot be achieved by simply deï¬ning a semiring on 2Î“âˆ
. In fact, even though such a
semiring can be deï¬ned, its multiplication would not be ğœ”-cocontinuous (a counterexample is given
in Appendix B.3). On the other hand, Lâˆ
Î“ does form an ğœ”-bicontinuous module (cf. Appendix B.4).
â–³

Î“ â‰” (2Î“âˆ

4.3 Weakest Preweightings
We now deï¬ne a calculus for formal reasoning about weighted programs Ã  la Dijkstra. In reference
to Dijkstraâ€™s weakest precondition calculus and McIver & Morganâ€™s weakest preexpectation calculus,
we name our veriï¬cation system weakest preweighting calculus.

First, we notice that predicates just form a speciï¬c semiring, namely (B, âˆ¨, âˆ§, 0, 1) and thus
they are in particular modules over their underlying â€œBoolean monoidâ€ ({ 0, 1 } , âˆ§, 1). We refer to
this as the module of predicates. With that in mind, we can now generalize the map perspective of
weakest preconditions to weakest preweightings, see Figure 3a. Instead of a postcondition, we now
have a postweighting ğ‘“ : Î£ â†’ ğ‘€ mapping program states to elements from our W-module M.
( ğ‘“ ) is then a function that takes as input an initial state ğœ,
The weakest preweighting wp
determines the weight ğ‘¤ of each path starting in ğœ and terminating in some ï¬nal state ğœ, scalar-
multiplies the pathâ€™s weight ğ‘¤ to the corresponding postweight ğ‘“ (ğœ) from the module M, and
ï¬nally returns the module sum over all these so-determined weights, see Figure 3a.

ğ¶
J

K

Figure 3b depicts how the general weighted setting is instantiated to a probabilistic setting: the
postweightings become real-valued functions (expectations), the path weights become the pathsâ€™
probabilities, and the summation remains a summation, thus obtaining an expected value.

One of the main advantages of Dijkstraâ€™s calculus is that the weakest preconditions can be de-
ï¬ned by induction on the program structure, thus allowing for compositional reasoning. Indeed, the
same applies to our weighted setting. In the following, we ï¬x an ambient monoid W of programs
weights and an ğœ”-bicontinuous W-module M that constitutes the habitat of our weightings W.
We now go over each construct of wGCL and see how a weakest preweighting semantics can be
developed and understood analogously to Dijkstraâ€™s weakest preconditions.

8We additionally require existence of a least element âŠ¥.
9The natural order on W is the point-wise lifted natural order on M.

Weighted Programming

11

ğˆ

âŠ•

ğ‘

ğ¶

ğ‘

ğ‘

ğ‘

ğ‘
âŠ•

ğ‘

â€¢
ğ‘“ (ğœ2)

ğ‘

ğ‘

â€¢
ğ‘“ (ğœ3)

ğ‘

â€¢
ğ‘“ (ğœ1)

( ğ‘“ )

wp

ğ¶
J

K

Ã‰ h

( ğ‘“ )

wp

ğ¶
J

K

ğˆ

1
3

1
2

ğ¶

. . .

i

Exp h

â€¢
ğ‘“ (ğœ1)

â€¢
ğ‘“ (ğœ2)

â€¢
ğ‘“ (ğœ3)

. . .

i

(a) Weakest preweightings: Given initial
state ğœ, wp Jğ¶K ( ğ‘“ ) (ğœ) determines the weight
ğ‘¤ = ğ‘1ğ‘2Â· Â· Â· of each path starting in ğœ and ter-
minating in some final state ğœğ‘– , scalar-multiplies
ğ‘¤ to the corresponding postweight ğ‘“ (ğœ), and
returns the module sum over all so-determined
weights.

(b) Weakest preexpectations: Given initial
state ğœ, wp Jğ¶K ( ğ‘“ ) (ğœ) determines the ex-
pected value (with respect to the probability dis-
tribution generated by executing ğ¶ on ğœ) of ğ‘“
evaluated in the final states reached after execut-
ing ğ¶ on ğœ.

Fig. 3. The meaning of weakest preweightings generally and weakest preexpectations specifically.

Assignment. The weakest precondition of an assignment is given by

wp

ğ‘¥ â‰” ğ¸
J

K

( ğœ“ ) = ğœ“ [ğ‘¥/ğ¸] ,

where ğœ“ [ğ‘¥/ğ¸] is the replacement of every occurrence of variable ğ‘¥ in the postcondition ğœ“ by the
expression ğ¸. For weakest preweightings, we proceed analogously. That is, we â€œreplaceâ€ every
â€œoccurrenceâ€ of ğ‘¥ in ğ‘“ by ğ¸. Since ğ‘“ is actually not a syntactic object, we more formally deï¬ne

wp

ğ‘¥ â‰” ğ¸
J

K

( ğ‘“ ) = ğ‘“ [ğ‘¥/ğ¸] â‰” ğœ† ğœ. ğ‘“

ğœ [ğ‘¥ â†¦â†’ ğœ (ğ¸)]

.

So the weighting ğ‘“ of the ï¬nal state reached after executing the assignment ğ‘¥ â‰” ğ¸ is precisely ğ‘“
evaluated at the state ğœ [ğ‘¥ â†¦â†’ ğœ (ğ¸)] â€” the state obtained from ğœ by updating variable ğ‘¥ to ğœ (ğ¸).

(cid:16)

(cid:17)

Weighting. Consider the classical statement assert ğœ‘. Operationally, when executing assert ğœ‘
on some initial state ğœ, we check whether ğœ satisï¬es the predicate ğœ‘. If ğœ |= ğœ‘, the execution
trace â€œpasses throughâ€ the assertion and potentially proceeds with whatever program comes after
the assertion. If, however, ğœ 6|= ğœ‘, then the execution trace at hand is so-to-speak â€œannihilatedâ€.
Intuitively, these two cases can be thought of as multiplying (or weighting) the execution trace
either by a multiplicative identity one or by an annihilating zero, respectively.

Denotationally, the weakest precondition of assert ğœ‘ is given by

wp

assert ğœ‘
J

( ğœ“ ) = ğœ‘ âˆ§ ğœ“ .

K
Indeed, whenever an initial state ğœ satisï¬es the precondition ğœ‘ âˆ§ ğœ“ , then (a) executing assert ğœ‘
will pass through asserting ğœ‘ and moreover â€” since the assertion itself does not alter the current
program state â€” (b) it terminates in state ğœ which also satisï¬es the postcondition ğœ“ . Dually, if ğœ
does not satisfy ğœ‘ âˆ§ ğœ“ , then either (a) executing assert ğœ‘ does not pass through asserting ğœ‘ or
(b) it does pass through the assertion but ğœ does not satisfy the postcondition ğœ“ .

When viewing the above through our monoid and module glasses, âˆ§ is just the scalar-multipli-
( ğœ“ ) weights (multiplies) ğœ“
cation in the module of predicates. So in other words, wp
with ğœ‘. Therefore, we generalize from conjunction with a predicate to (scalar-)multiplication with a

assert ğœ‘

K

J

12

Batz, Gallus, Kaminski, Katoen, and Winkler

monoid element ğ‘ from W and introduce the statement âŠ™ ğ‘ into the programming language. Op-
erationally, our execution traces are weighted and the âŠ™ ğ‘ statement scalar-multiplies the current
execution traceâ€™s weight by an ğ‘. Denotationally, the weakest preweighting of âŠ™ ğ‘ is given by

wp

âŠ™ ğ‘

( ğ‘“ ) = ğ‘ âŠ™ ğ‘“ .

J

K

Remark 4.5 (On Non-commutativity and Notation). Recall that multiplication of weights is gen-
erally not commutative â€” think, for example, about the word monoid Î“âˆ—. In the light of potential
non-commutativity, the ï¬‚ipping of the sides, i.e. âŠ™ ğ‘ in the program syntax versus ğ‘ âŠ™
in the
denotational weighting transformer semantics, is on purpose: Programs are usually read (and ex-
ecuted) in a forward manner. Assuming that the weights along an execution trace are collected
from left to right, from initial to ï¬nal state, weighting by ğ‘ is a right-multiplication, appending at
the end of the current execution trace the weight ğ‘.

Weakest preweightings, on the other hand, are backward-moving: The ğ‘“ is a postweighting
that potentially abstracts or summarizes the eï¬€ects of subsequent computations. Whenever we
encounter on our way from the back to the front of a program a weighting by ğ‘, we thus have to
prepend ğ‘ to the current postweighting ğ‘“ , yielding a left-multiplication ğ‘ âŠ™ ğ‘“ in the denotations. â–³
Branching. We now consider the classical angelic nondeterministic choice { ğ¶1 } (cid:3) { ğ¶2 }. Op-
erationally, when â€œexecutingâ€ this choice on some initial state ğœ, either the program ğ¶1 or the
program ğ¶2 will be executed, chosen nondeterministically. Hence, the execution will reach either
a ï¬nal state in which executing ğ¶1 on ğœ terminates or a ï¬nal state in which executing ğ¶2 on ğœ
terminates (or no ï¬nal state if both computations diverge).

Denotationally, the angelic weakest precondition of { ğ¶1 } (cid:3) { ğ¶2 } is given by
( ğœ“ ) .

( ğœ“ ) = wp

( ğœ“ ) âˆ¨ wp

{ ğ¶1 } (cid:3) { ğ¶2 }

wp

ğ¶1
J

K

ğ¶2
J
ğ¶1
J

K

K
( ğœ“ ) âˆ¨ wp

Indeed, whenever an initial state ğœ satisï¬es the precondition wp
executing ğ¶1 or executing ğ¶2 will terminate in some ï¬nal state satisfying the postcondition ğœ“ .

ğ¶2
J

K

( ğœ“ ) then

{ ğ¶1 } (cid:3) { ğ¶2 }

Again viewed through our module glasses, âˆ¨ is just the addition of the module of predicates.
( ğœ“ ). We
So in other words, wp
thus generalize from disjunction of two predicates to addition of two module elements and introduce
the statement { ğ¶1 } âŠ• { ğ¶2 } into the programming language. Operationally, we have the same
interpretation as in the classical case: Either the program ğ¶1 can be executed or the program ğ¶2.
Denotationally, the weakest preweighting of { ğ¶1 } âŠ• { ğ¶2 } is given by

( ğœ“ ) unions (adds) wp

( ğœ“ ) and wp

ğ¶1
J

ğ¶2
J

K

J

K

K

wp

{ ğ¶1 } âŠ• { ğ¶2 }

( ğ‘“ ) = wp

( ğ‘“ ) âŠ• wp

( ğ‘“ ) .

ğ¶1
J

K

ğ¶2
J

K

( ğ‘“ ) tells us what element we obtain if ğ¶ğ‘– is executed, and the module addition âŠ• tells us

wp
how to account for the fact that either ğ¶1 or ğ¶2 could have been executed.

ğ¶ğ‘–
J

K

J

J

K

K

Conditional Choice. We now consider the classical conditional choice if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }.
Operationally, when executing if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 } on some initial state ğœ, we check whether
ğœ satisï¬es the predicate ğœ‘. If ğœ |= ğœ‘, the program ğ¶1 is executed; otherwise the program ğ¶2.

Denotationally, the weakest precondition of if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 } (and in fact also the weak-

est precondition of { assert ğœ‘

ğ¶1 } (cid:3) { assert Â¬ğœ‘

ğ¶2 }) is given by

wp

if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }
J

K

#

( ğœ“ ) = ğœ‘ âˆ§ wp

#

ğ¶1
J

K

( ğœ“ ) âˆ¨ Â¬ğœ‘ âˆ§ wp

( ğœ“ ) .

ğ¶2
J

K

Indeed, whenever an initial state ğœ satisï¬es the above precondition then either ğœ |= ğœ‘ and then
( ğœ“ ) â€” executing ğ¶1 will terminate in a ï¬nal state satisfy-
â€” since then ğœ must also satisfy wp
ing ğœ‘, or ğœ 6|= ğœ‘ and â€” since then ğœ must also satisfy wp
( ğœ“ ) â€” executing ğ¶2 will terminate
in a ï¬nal state satisfying ğœ‘.

ğ¶2
J

ğ¶1
J

K

K

Weighted Programming

13

In terms of monoids and modules, ğœ‘ âˆ§

could be viewed as a scalar-multiplication by either 1
(leaving the right operand unaltered) or by 0 (annihilating the right operand). However, general
monoids do not posses an annihilating 0. In order to reenact the desired behavior, we introduce
the Iverson bracket [ğœ‘] of a predicate ğœ‘, which for a weighting ğ‘“ âˆˆ W deï¬nes the weighting

( [ğœ™] ğ‘“ ) (ğœ)

=

ğ‘“ (ğœ)
0

if ğœ |= ğœ‘ ,
otherwise .

(
With this notation at hand, we deï¬ne the weakest preweighting of if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 } by
( ğ‘“ ) = [ğœ‘] wp

if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }

( ğ‘“ ) âŠ• [Â¬ğœ‘] wp

( ğ‘“ ) .

wp

J

K

By convention, [ğœ™] binds stronger than âŠ•. Depending on the truth value of ğœ‘, the above weakest
( ğ‘“ ).
preweighting thus selects either the preweighting wp

( ğ‘“ ) or the preweighting wp

ğ¶2
J

K

ğ¶1
J

K

ğ¶1
J

K

Sequential Composition. Our composite statement ğ¶1
ğ¶2 is standard. Operationally, ğ¶1 is ex-
ecuted ï¬rst and then â€” provided that ğ¶1 terminates â€” ğ¶2 is executed. A distinguishing feature of
the classical weakest precondition transformer is that it moves backwards through the program,
and the same applies to our weighting transformer, i.e.

#

wp

ğ¶1
J

#

K

ğ¶2

( ğ‘“ ) = wp

( wp

( ğ‘“ ) ) .

ğ¶1
J

K

ğ¶2
J

K

Indeed, to compute the weakest preweighting of the composition ğ¶1
ï¬rst compute an intermediate weighting wp

( ğ‘“ ), which we then feed into wp

#

ğ¶2 w.r.t. to some ğ‘“ âˆˆ W, we

ğ¶2
J

K

ğ¶1
J

.
K

Looping. Operationally, a loop while ( ğœ‘ ) { ğ¶ } is equivalent to the inï¬nite nested conditional

if ( ğœ‘ ) { ğ¶

if ( ğœ‘ ) { ğ¶

if ( ğœ‘ ) { ğ¶

. . . } else { skip } } else { skip } } else { skip } ,

#

#

#

which is the same as saying that while ( ğœ‘ ) { ğ¶ } â‰¡ if ( ğœ‘ ) { ğ¶
while ( ğœ‘ ) { ğ¶ } } else { skip }.
With the rules for conditional choice and composition as explained above, it is thus reasonable to
require that the preweighting wp

( ğ‘“ ) should be a ï¬xed point of the function

#

ğ¶2
J

K

while ( ğœ‘ ) { ğ¶ }
J

ğ‘‹ â†¦â†’ [ğœ‘] wp

K
( ğ‘‹ ) âŠ• [Â¬ğœ‘] ğ‘“

ğ¶
J

K
which is indeed just the wp-characteristic function deï¬ned above. For both the classical weakest
precondition transformer as well as for our weighted wp, we choose the semantics to be the least
ï¬xed point, which exists uniquely if the ambient module M is ğœ”-continuous (see Theorem 4.7
below). In the classical Boolean setting, this corresponds to choosing the strongest (least) possi-
ble predicate that satisï¬es the ï¬xed point equation. This ensures that the weakest precondition
contains only those initial states where the loop can actually terminate in a state satifying the
postcondition â€” but no such states for which the loop cannot terminate at all. Taking the least
ï¬xed point in the weighted setting generalizes this intuition as we will show in Theorem 4.15
below.

Properties of wp. Based on the above discussion, we now deï¬ne wp formally, state healthiness
and soundness properties, and provide several examples.

Deï¬nition 4.6 (Weakest Preweighting Transformer). The transformer wp : wGCL â†’ (W â†’ W)
is deï¬ned by induction on the structure of wGCL according to the rules in Table 2. The function

Î¦ğ‘“ : W â†’ W, ğ‘‹ â†¦â†’ [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp

( ğ‘‹ )

ğ¶ â€²
J

K

whose least ï¬xed point deï¬nes the weakest preweighting of while ( ğœ‘ ) { ğ¶ } is called the wp-
characteristic function of while ( ğœ‘ ) { ğ¶ } with respect to postweighting ğ‘“ .
â–³

14

Batz, Gallus, Kaminski, Katoen, and Winkler

Table 2. Rules defining the weakest preweighting wp Jğ¶K ( ğ‘“ ) of program ğ¶ w.r.t. postweighting ğ‘“ .

#

ğ¶
ğ‘¥ â‰” ğ¸
ğ¶1
ğ¶2
if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }
{ ğ¶1 } âŠ• { ğ¶2 }
âŠ™ ğ‘
while ( ğœ‘ ) { ğ¶ â€² }

( ğ‘“ )

wp
ğ¶
J
K
ğ‘“ [ğ‘¥/ğ¸]
wp
ğ¶1
J
[ğœ‘] wp
wp
ğ¶1
J
ğ‘ âŠ™ ğ‘“
lfp ğ‘‹ . [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp

( wp
K
ğ¶1
J
( ğ‘“ ) âŠ• wp
K

( ğ‘“ ) )
( ğ‘“ ) âŠ• [Â¬ğœ‘] wp
( ğ‘“ )

ğ¶2
J

ğ¶2
J

K

K

( ğ‘“ )

ğ¶2
J

K

K

( ğ‘‹ )

ğ¶ â€²
J

K

Theorem 4.7 (Well-Definedness of wp). Let the monoid module M over W be ğœ”-continuous.
For all W-wGCL programs ğ¶, the weighting transformer wp
is a well-deï¬ned ğœ”-continuous end-
ofunction on the module of weightings over M. In particular, if Î¦ğ‘“ is the wp-characteristic function
of while ( ğœ‘ ) { ğ¶ } with respect to postweighting ğ‘“ , then

ğ¶
J

K

wp

while ( ğœ‘ ) { ğ¶ }

( ğ‘“ )

=

J

K

Î¦ğ‘–
ğ‘“ (0) .

Ã„ğ‘– âˆˆN

Our wp satisï¬es the following so-called healthiness criteria (see e.g. [Hino et al. 2016; Hoare 1978;
Keimel 2015; McIver and Morgan 2005]) or homomorphism properties [Back and von Wright 1998]:

Theorem 4.8 (Healthiness). Let the monoid module M over W be ğœ”-continuous. For all W-

wGCL programs ğ¶, the wp transformer is
(1) monotone, i.e. for all ğ‘“ , ğ‘” âˆˆ W,
(2) strict, i.e.
(3) additive, i.e. for all ğ‘“ , ğ‘” âˆˆ W,
(4) Moreover, if W is commutative, then wp is homogeneous, i.e. for all ğ‘ âˆˆ ğ‘Š and ğ‘“ âˆˆ W,
K

ğ¶
J
( ğ‘“ âŠ• ğ‘” ) = wp

ğ¶
J
ğ¶
J

implies wp

( 0 ) = 0,

( ğ‘“ ) (cid:22) wp

K
( ğ‘” ).

( ğ‘“ ) âŠ• wp

K
ğ¶
J

ğ‘“ (cid:22) ğ‘”

ğ¶
J

ğ¶
J

( ğ‘” ),

wp

wp

K

K

K

and together with (3), wp then becomes linear.

wp

ğ¶
J

K

( ğ‘ âŠ™ ğ‘“ ) = ğ‘ âŠ™ wp

( ğ‘“ ) ,

ğ¶
J

K

Homogeneity does not hold in general: Consider the formal languages semiring L { ğ‘,ğ‘ } and the
program ğ¶ = âŠ™ { ğ‘ } with the constant postweighting ğ‘“ = 1 = { ğœ– }. Then

( { ğ‘ } Â· ğ‘“ ) = { ğ‘ } Â· { ğ‘ } = { ğ‘ğ‘ } â‰  { ğ‘ğ‘ } = { ğ‘ } Â· { ğ‘ } = { ğ‘ } Â· wp

( ğ‘“ ) .

The next theorem states that wp indeed generalizes the map perspective on classical weakest pre-
conditions as anticipated at the beginning of Section 4.3. The operational semantics as well as
TPaths hğ¶, ğœ i, wgt, and last are deï¬ned in Section 3.3.

Theorem 4.9 (Soundness of wp). Let the monoid module M over W be ğœ”-continuous. For all

ğ¶ âˆˆ wGCL, ğœ âˆˆ Î£ and ğ‘“ âˆˆ W,

( ğ‘“ ) (ğœ)

=

wp

ğ¶
J

K

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ i

wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹)) .

(1)

wp-Annotations. In the spirit of Hoare-style reasoning, we will annotate programs as is shown
abstractly in Fig. 4a and concretely in Fig. 4b. Read the annotations from bottom to top as follows:
ğ‘“ This ï¬rst annotation states that we start our reasoning from postweighting ğ‘“ âˆˆ W.
(1)

((

wp

ğ¶
J

K

ğ¶
J

K

Weighted Programming

ğ‘”â€²
ğ‘”

âŠ²âŠ³

((
wp

((
ğ¶

(meaning ğ‘” = wp

(meaning ğ‘” âŠ²âŠ³ ğ‘”â€²)
( ğ‘“ ))
ğ¶
J

K

ğ‘“

(postweighting is ğ‘“ )
(a) Style for wp annotations. âŠ²âŠ³ âˆˆ {(cid:22), =, (cid:23)}.

((

=

= ğ‘”â€²

2
[ğ‘¥ > 0] (1 + 1) âŠ• [ğ‘¥ = 0] (2 min 3)

((
wp
((
if ( ğ‘¥ > 0 ) { âŠ™ 1
= ğ‘“

0

âŠ™ 1 } else { { âŠ™ 2 } âŠ• { âŠ™ 3 } }

#

15

= ğ‘”

((

(b) Annotations for Example 4.10.

Fig. 4. Annotations for weakest preweightings. It is more intuitive to read these from the bottom to top.

(2) wp

((

(3) âŠ²âŠ³

((

(

ğ‘” The superscript wp before the annotation indicates that this annotation is obtained from
). The program passed into wp is the line immediately below this anno-
applying wp
tation â€” in this case ğ¶ â€” and the continuation passed into wp is the annotation immediately
below the program â€” in this case ğ‘“ . Hence, this annotation states ğ‘” = wp
ğ‘”â€² This last annotation states that ğ‘” âŠ²âŠ³ ğ‘”â€², for âŠ²âŠ³ âˆˆ {(cid:22), =, (cid:23)}. We thus allow rewriting, or
(like the classical rule of consequence in Hoare logic) to perform a monotonic relaxation.

ğ¶
J

( ğ‘“ ).

J

K

K

Let us illustrate wp by means of two examples. Recall our convention that the monoid W and the
module M stem from a semiring S unless stated otherwise.

Example 4.10. Let S = T = (N+âˆ, min, +, âˆ, 0) be the tropical semiring and consider a wGCL-

program ğ¶. Theorem 4.9 implies that for all states ğœ âˆˆ Î£,

( 0 ) (ğœ)

=

â€œminimum weight of all terminating computation paths that start in ğœâ€

where the weight of a path is the usual sum of all weights along that path. Notice that the above
â€œ0â€ is the map to the natural number 0 and not the semiring 0 = âˆ. For instance, we can verify that

wp

if ( ğ‘¥ > 0 ) { âŠ™ 1

âŠ™ 1 } else { { âŠ™ 2 } âŠ• { âŠ™ 3 } }

( 0 )

=

2 .

J

#

For that, consider the program annotations in Fig. 4b, which express that 2 = [ğ‘¥ > 0] (1 + 1) âŠ•
( 0 ) where ğ¶ = if (ğ‘¥ > 0) {. . .}. This reï¬‚ects that if ğ‘¥ > 0 initially,
[ğ‘¥ = 0] (2 min 3) = wp
ğ¶
then the only possible terminating path has weight 1 + 1 = 2. Otherwise, i.e. if ğ‘¥ = 0, then the
J
â–³
minimum weight of the two possible paths is also 2.

K

K

Example 4.11. Let S = LÎ“ = (2Î“âˆ—

, âˆª, Â·, âˆ…, { ğœ– }) be the semiring of formal languages over Î“.
Similarly to Example 4.4, we now choose the monoid W = Î“âˆ— of words and view LÎ“ as a Î“âˆ—-
module, i.e. the weighting-statements are of the form âŠ™ ğ‘¤ for some single word ğ‘¤ âˆˆ Î“âˆ—. The
weightings W, however, associate an entire language to each state. For all initial states ğœ âˆˆ Î£, we
have

wp

ğ¶
J

K

( { ğœ– } ) (ğœ)

=

â€œlanguage of all terminating computation paths starting in ğœâ€ ,

where each terminating path contributes the single word obtained from concatenating all symbols
occurring in the weight-statements along this path (this may also yield the empty word ğœ– = 1). â–³

wp

ğ¶
J

K

4.4 Weakest Liberal Preweightings

The weakest preweighting calculus developed in the previous section assigns a weight to each
initial state ğœ based on the terminating computation paths starting in ğœ and the postweighting ğ‘“ .
In particular, wp ignores (more precisely: assigns weight 0 to) nonterminating behavior, i.e. the
( ğ‘“ ) is independend of the inï¬nite computation paths of ğ¶. For instance, in
preweighting wp
the formal languages semiring L { ğ‘,ğ‘ } with monoid W = { ğ‘, ğ‘ }âˆ—, we have for all ğ‘“ âˆˆ W that
âˆ…

while ( true ) { âŠ™ ğ‘ }

= wp

( ğ‘“ ) ,

ğ¶
J

( ğ‘“ )

wp

=

K

while ( true ) { âŠ™ ğ‘ }
J

K

J

K

16

Batz, Gallus, Kaminski, Katoen, and Winkler

even though the computation trees of the two programs are clearly distinguishable.

In this section, we deï¬ne weakest liberal preweightings (wlp) as a means to reason about such
inï¬nite, i.e. nonterminating, program behaviors, thus generalizing Dijkstraâ€™s classical weakest lib-
eral preconditions. Unlike Dijkstraâ€™s weakest liberal preconditions who just assign true (instead
of false) to any nonterminating behavior, our weakest liberal preweightings can inspect nontermi-
nating behavior more nuancedly. As a teaser: our weakest liberal preweightings can distinguish
between while ( true ) { âŠ™ ğ‘ } and while ( true ) { âŠ™ ğ‘ } as we will demonstrate below.

Reconsidering the map perspective on weakest preconditions explained in Section 4.3, the weak-
est liberal precondition of program ğ¶ with respect to postcondition ğœ“ maps an initial state ğœ to
true iï¬€ (i) ğ¶ started on ğœ can terminate in a state ğœ satisfying ğœ“ , or (ii) it is possible that ğ¶ does not
terminate at all, or both. In more symbolic terms,

wlp

ğ¶
J

K

( ğœ“ ) (ğœ)

=

ğœ“ (ğœ) âˆ¨

Ãœğœ âˆˆJğ¶Kğœ

ğ¶
J

â‡‘
ğœ ,
K

where

wlp

ğ¶
J

â‡‘
ğœ holds iï¬€ the nondeterministic program ğ¶ may not terminate on ğœ.10 We have
K
( ğœ“ ) (ğœ) = wp
ğ¶
J

( false ) (ğœ) =

( ğœ“ ) (ğœ) âˆ¨

ğ¶
J

ğ¶
J

ğ¶
J

ğ¶
J

â‡‘
ğœ
K

and

wlp

K

K

â‡‘
ğœ ,
K

( false ) captures precisely the nonterminating behavior of ğ¶, and hence

(2)

( false ) characterizes precisely the diï¬€erence between wp

K

( ğ‘“ ) and wlp

( ğ‘“ ).

In the realm of monoids and modules, the predicate false is the zero 0 of the Boolean semiring.

K

K

K

ğ¶
J

ğ¶
J

ğ¶
J

K
implying that wlp
wlp

ğ¶
J

We now deï¬ne a weakest liberal preweighting calculus generalizing (2) by satisfying

âˆ€ ğ‘“ âˆˆ W :

wlp

( ğ‘“ )

= wp

( ğ‘“ ) âŠ• wlp

( 0 ) .

ğ¶
J

ğ¶
J

Intuitively, wlp
ample programs from the beginning of this subsection considered over the Î“âˆ—-module Lâˆ
ğœ”-potent formal languages, we get for example

K
( 0 ) captures the weights of the nonterminating paths in ğ¶: For the two ex-
{ ğ‘,ğ‘ } of

ğ¶
J

K

K

K

ğ¶
J

wlp

while ( true ) { âŠ™ ğ‘ }

( 0 ) = { ğ‘ğœ” }

and wlp

J

K

Deï¬nition 4.12 (Weakest Liberal Preweighting Transformer). The transformer wlp : wGCL â†’
(W â†’ W) is inductively deï¬ned according to Table 2 with lfp replaced by gfp and with every oc-
( ğ‘“ ) is deï¬ned as the greatest
currence of wp replaced by wlp. In particular, wlp
ï¬xed point of the characteristic function

while ( ğœ‘ ) { ğ¶ â€² }

J

while ( true ) { âŠ™ ğ‘ }
J

K

( 0 ) = { ğ‘ğœ” } .

Î¨ğ‘“ : W â†’ W, ğ‘‹

â†¦â†’ [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wlp

We obtain a well-deï¬nedness result analogous to Theorem 4.7:

( ğ‘‹ ) .

K

â–³

K
ğ¶ â€²
J

Theorem 4.13 (Well-Definedness of wlp). Let M be an ğœ”-cocontinuous W-module. For all
W-wGCL programs ğ¶, the transformer wlp
is a well-deï¬ned ğœ”-cocontinuous endofunction on the
module of weightings over M. In particular, if Î¨ğ‘“ is the wlp-characteristic function of while ( ğœ‘ ) { ğ¶ }
with respect to postweighting ğ‘“ , then

ğ¶
J

K

wlp

while ( ğœ‘ ) { ğ¶ }
J

K

( ğ‘“ )

= l
ğ‘– âˆˆN

Î¨ğ‘–
ğ‘“ (âŠ¤) .

As stated above, we furthermore get the following fundamental property:

Theorem 4.14 (Decomposition of wlp). Let M be an ğœ”-bicontinuous W-module. Then for all

programs ğ¶ and postweightings ğ‘“ ,

10Recall that we consider angelic nondeterminism.

( ğ‘“ )

= wp

wlp

ğ¶
J

K

( ğ‘“ ) âŠ• wlp

ğ¶
J

K

( 0 ) .

ğ¶
J

K

ğ¶
J

K

Weighted Programming

Moreover, we get a statement relating (inï¬nite) computation paths and wlp

17

( 0 ):

Theorem 4.15 (Soundness of wlp). Let the monoid module M over W be ğœ”-bicontinuous11.

Then for all programs ğ¶ and initial states ğœ,

( 0 ) (ğœ)

wlp

ğ¶
J

K

= l
ğ‘› âˆˆN

ÃŠğœ‹ âˆˆPathsğ‘›

hğ¶, ğœ i

wgt(ğœ‹) âŠ™ âŠ¤ .

(3)

Note that Theorem 4.15 is phrased in terms of the ï¬nite computation paths Pathsğ‘›
hğ¶, ğœ i. This is
because it is somewhat diï¬ƒcult to deï¬ne a general inï¬nite product in W that is compliant with
the way our wlp assigns weights to inï¬nite computation paths. Nevertheless, the right-hand side
of (3) depends only on the inï¬nite paths which can be seen intuitively as follows: For arbitrary
ğ‘› âˆˆ N consider the ï¬nite (not necessarily terminating) computation paths up to length ğ‘›. Let ğ‘£ (ğ‘›)
denote the sum their weights, where the weight of each path is additionally multiplied by âŠ¤, the
top element of M. Then (ğ‘£ (ğ‘›))ğ‘› âˆˆN is a decreasing chain in the module M. In the limit (i.e. inï¬mum),
all terminating computation paths will be ruled out as each of them has some ï¬nite length. The
limit/inï¬mum of the ğ‘£ (ğ‘›) exists by our theory and is independent of the programâ€™s terminating
paths. In fact, for programs that do not exhibit inï¬nite paths, we can show that the limit is 0 using
KÅ‘nigâ€™s classic inï¬nity lemma. We discuss the implications of this in Section 5.2.

Note that Theorem 4.15 indeed implies that wlp is backward compatible to classical weakest
liberal preconditions: In the Boolean semiring, the right-hand side of (3) equals true iï¬€ there exists
â‡‘
an inï¬nite computation path starting in ğœ, and thus wlp
ğœ holds as expected.
K
Example 4.16. Reconsider the tropical semiring T = (N+âˆ, min, +, âˆ, 0) with âŠ¤ = 0. The in-
ï¬mum d in the natural order is the supremum in the standard order on N+âˆ, and multiplication
with the top element âŠ¤ = 0 is eï¬€ectless as ğ‘ âŠ™ âŠ¤ = ğ‘ + 0 = ğ‘. It follows from Theorem 4.15 that

( 0 ) (ğœ) â‰¡

ğ¶
J

ğ¶
J

K

( 0 ) (ğœ)

=

â€œminimum weight of all inï¬nite computation paths starting in ğœâ€ ,

or âˆ â€” the tropical 0 â€” if no inï¬nite path exists. Hence wlp
( 0 ) (ğœ) â€” where the natural
number 0 is the tropical 1 â€” is the minimum path weight among all ï¬nite and inï¬nite computation
paths starting in ğœ. For example, for the program ğ¶ given by

ğ¶
J

K

while ( ğ‘¥ = 2 ) {

{ ğ‘¥ â‰” 3

âŠ™ 5 } âŠ• { skip }

}

#
and initial state ğœ with ğœ (ğ‘¥) = 2, we have wp
( 0 ) (ğœ) = 5 but wlp
there exists an inï¬nite path (only performing skip) with weight 0 < 5.

ğ¶
J

K

ğ¶
J

K

( 0 ) (ğœ) = 0 because
â–³

Example 4.17. Let M = Lâˆ

Î“ be the module of ğœ”-potent formal languages over the monoid of
words W = Î“âˆ— (cf. Example 4.11). Thus, weightings ğ‘“ âˆˆ W associate states with languages that
contain both ï¬nite and ğœ”-words. Let ğ¶ be a Î“âˆ—-wGCL program. It follows from Theorem 4.15 that

( 0 ) (ğœ)

wlp

ğ¶
J

K

= â€œlanguage of all (ï¬nite and ğœ”-)words that have some
inï¬nite computation path starting in ğœ as preï¬xâ€

,

where we have identiï¬ed computation paths with the words they are labelled with. In particular, if
( 0 ) (ğœ) is precisely the language
all inï¬nite paths of ğ¶ are weighted with an ğœ”-word, then wlp
consisting of all these words. For example, let Î“ = {ğ‘, ğ‘} and consider the following program ğ¶:
{ ğ‘¥ â‰” 0

while ( ğ‘¥ = 1 ) {

âŠ™ ğ‘ } âŠ• { âŠ™ ğ‘ }

ğ¶
J

}

K

11In the statement, we assert ğœ”-bicontinuity: our proof makes heavy use of Theorem 4.14 and thus we need wp to be well-
deï¬ned. However, it might be possible to prove a link between operational semantics and wlp assuming only ğœ”-cocontinuity.
But a proof seems much more convoluted than our current one.

#

wlp

ğ¶
J

K

18

Batz, Gallus, Kaminski, Katoen, and Winkler

If initially ğœ (ğ‘¥) = 1, then wp
{ğ‘ğœ” } and hence

ğ¶
J

K

( 1 ) (ğœ) = { ğ‘, ğ‘ğ‘, ğ‘ğ‘ğ‘, . . . }, where 1 = { ğœ– }, but wlp

( 0 ) (ğœ) =

ğ¶
J

K

( 1 ) (ğœ) = wp

( { ğœ– } ) (ğœ) âˆª wlp

( 0 ) (ğœ) = { ğ‘ğœ”, ğ‘, ğ‘ğ‘, ğ‘ğ‘ğ‘, . . . } .

â–³

wlp

ğ¶
J

K

ğ¶
J

K

ğ¶
J

K

ğ¶
J

Remark 4.18 (Probabilistic Weakest Liberal Preexpectations). McIver and Morgan [2005] and Kozen
( 0 ) (ğœ) yields the probability that ğ¶ di-
[1985] deï¬ne a probabilistic wlp-semantics where wlp
verges on input ğœ. Technically, probabilistic programs are wGCL-programs over the real semiring
(Râˆ
â‰¥0, +, Â·, 0, 1) where branching and weighting is restricted to statements of the form { . . . } ğ‘ âŠ•ğ‘
{ . . . }, where ğ‘ + ğ‘ = 1. However, by Theorem 4.15, our wlp over Râˆ
â‰¥0 yields for all loops and all
( 0 ) (ğœ) âˆˆ {0 = 0, âŠ¤ = âˆ} and is thus trivial. We cannot simply ï¬x this by choos-
states wlp
ing probabilities in [0, 1] as our module M since [0, 1] is not closed under addition. Nonetheless,
we can recover the wlp of Kozen [1985]; McIver and Morgan [2005] by considering the greatest
ï¬xed point below or equal to 1 instead of the true gfp in Râˆ
â‰¥0, i.e. we would consider a modiï¬ed
transformer wlp(cid:22)1. It is easy to show that this is well-deï¬ned and still satisï¬es Theorem 4.14 and
â–³
Theorem 4.15 (with the multiplication âŠ™âŠ¤ on the right hand side of (3) omitted).

loop
J

K

K

5 VERIFICATION OF LOOPS

For loop-free programs, weakest (liberal) preweightings can be obtained essentially by means of
syntactic reasoning. For loops, however, this is not the case since we need to reason about ï¬xed
points. This section introduces easy-to-apply proof rules for bounding weakest (liberal) preweight-
ings of loops, generalizing rules from the probabilistic setting [McIver and Morgan 2005].

5.1 Invariant-Based Verification of Loops
Let us ï¬x throughout the rest of the section an ambient monoid W of program weights and an
ambient ğœ”-bicontinuous W-module M. Since the wp- and wlp-characteristic functions of loops
are ğœ”-(co)continuous (see Theorem 4.7 and 4.13), we obtain proof rules for loops by Park induction
Theorem A.4:

Theorem 5.1 (Induction Rules for Loops). Let Î¦ğ‘“ and Î¨ğ‘“ be the wp- and wlp-characteristic

functionals of the loop while ( ğœ‘ ) { ğ¶ } with respect to postweighting ğ‘“ . Then for all ğ¼ âˆˆ W,

Î¦ğ‘“ (ğ¼ ) (cid:22) ğ¼
ğ¼ (cid:22) Î¨ğ‘“ (ğ¼ )

implies

wp

while ( ğœ‘ ) { ğ¶ }

( ğ‘“ ) (cid:22) ğ¼ ,

and

J
ğ¼ (cid:22) wlp

K

implies

while ( ğœ‘ ) { ğ¶ }
J
The weightings ğ¼ are called wp-superinvariants and wlp-subinvariants, respectively (or just invari-
ants if clear from context). In many cases â€” in particular for loop-free loop bodies â€” the above
proof rules are easy to apply as they only require to apply the respective characteristic functional
once. Example 5.5 demonstrates invariant-based reasoning and our annotation-style for loops.

( ğ‘“ ) .

K

What about the converse directions, i.e. lower bounds for wp and upper bounds for wlp? For
that, the analogous formulations of the above proof rules do not hold in general [Kaminski 2019].
In the next subsection we show that in the case of terminating programs, these formulations do
hold.

5.2 Terminating Programs and Unique Fixed Points
The notion of universal certain termination is central to the results of this section:

Deï¬nition 5.2 (Universal Certain Termination). A wGCL-program ğ¶ terminates certainly on ini-
tial state ğœ âˆˆ Î£ if there does not exist an inï¬nite computation path starting in hğ¶, ğœi. Moreover, ğ¶
is universally certainly terminating (UCT) if it terminates certainly on all ğœ âˆˆ Î£.
â–³

Weighted Programming

19

âŠ²âŠ³

((
Î¦

ğ¼

ğ‘”

((
while ( ğœ‘ ) {

ğ¼ â€²â€²
ğ¼ â€²

âŠ²âŠ³

((
wp
((
ğ¶

ğ¼

88

}

ğ‘“

(meaning ğ‘” âŠ²âŠ³ ğ¼ )
(ğ‘” = [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] ğ¼ â€²â€²)

=

((
Î¦

[ğ‘¥=0âˆ¨ğ‘¦=0]0 âŠ• [ğ‘¥=0âˆ¨ğ‘¦=0] (2ğ‘¥+ğ‘¦) = ğ¼

[ğ‘¥=0âˆ¨ğ‘¦=0]0 âŠ• [ğ‘¥ >0âˆ§ğ‘¦>0]ğ¼ â€²â€² = ğ‘”

(meaning ğ‘” = wp

(meaning ğ¼ â€² âŠ²âŠ³ ğ¼ â€²â€²)
( ğ‘“ ))
ğ¶
J

K

((
while ( ğ‘¥ > 0 âˆ§ ğ‘¦ > 0 ) {

=

[ (ğ‘¥ >1)âˆ¨(ğ‘¥ >0âˆ§ğ‘¦>1) ] (2ğ‘¥+ğ‘¦) âŠ• 1âŠ™ [ğ‘¥ â‰¤1âˆ¨ğ‘¦ â‰¤1]0 = ğ¼ â€²â€²

(expression ommited) = ğ¼ â€²

((
wp
((
{ ğ‘¥ â‰” ğ‘¥âˆ’1

ğ‘¦ â‰” ğ‘¦+1 } âŠ• { ğ‘¦ â‰” ğ‘¦âˆ’1 }

âŠ™ 1

(we employ invariant ğ¼ )

[ğ‘¥=0âˆ¨ğ‘¦=0]0 âŠ• [ğ‘¥=0âˆ¨ğ‘¦=0] (2ğ‘¥+ğ‘¦) = ğ¼

#

#

(postweighting is ğ‘“ )

}

88

0 = ğ‘“

((

(a) Annotation style for loops using invariants.

((

(b) wp loop annotations for Example 5.5.

Fig. 5. Inside the loop, we push an invariant ğ¼ (provided externally, denoted by 88 ğ¼ ) through the loop body,
thus obtaining ğ¼ â€²â€² which is (possibly an over- or underapproximation of) ğ¼ â€² = wp JCâ€²K ( ğ¼ ). Above the loop
head, we then annotate ğ‘” = [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] ğ¼ â€²â€². In the first line, we establish ğ‘” âŠ²âŠ³ ğ¼ , for âŠ²âŠ³ âˆˆ {(cid:22), =, (cid:23)}.

ğ¶
J

K

ğ¶
J

K

Certain termination of a program ğ¶ âˆˆ wGCL is also known as demonic termination of the pro-
gram obtained from ğ¶ by ignoring all weight-statements and interpreting branching as demonic
non-determinism. Note that all loop-free programs are trivially UCT. A well-established method
for proving certain termination is by use of ranking functions [Dijkstra 1975]. An important con-
sequence of UCT is that wp and wlp coincide. This is intuitively clear because if ğ¶ is UCT then
wlp
. Formally:

has no additional nonterminating behavior to account for compared to wp

Theorem 5.3 (Uniqe Fixed Points by Universal Certain Termination). Let while ( ğœ‘ ) { ğ¶ }
have a UCT loop body ğ¶ and let Î¦ğ‘“ and Î¨ğ‘“ be its wp- and wlp-characteristic functionals with respect
to an arbitrary postweighting ğ‘“ . Then Î¦ğ‘“ = Î¨ğ‘“ .

Furthermore, let ğ¼, ğ½ âˆˆ W be ï¬xed points of Î¦ğ‘“ . Then
while ( ğœ‘ ) { ğ¶ } terminates certainly on ğœ

implies

ğ¼ (ğœ) = ğ½ (ğœ) .

Moreover, if while ( ğœ‘ ) { ğ¶ } is UCT, then Î¦ğ‘“ has a unique ï¬xed point and
while ( ğœ‘ ) { ğ¶ }
J

while ( ğœ‘ ) { ğ¶ }
J

( ğ‘“ ) = wlp

wp

K

K

( ğ‘“ ) .

ğ¼ (cid:22) Î¦ğ‘“ (ğ¼ )
Î¨ğ‘“ (ğ¼ ) (cid:22) ğ¼

Hence, the converse directions of the rules in Theorem 5.1 do hold for UCT loops with UCT loop-
body. In particular, we can reason about exact weakest (liberal) preweightings of such loops.
Corollary 5.4. If both while ( ğœ‘ ) { ğ¶ } and ğ¶ are UCT, then for all ğ‘“ âˆˆ W and all ğ¼ âˆˆ W,
ğ¼ (cid:22) wp

while ( ğœ‘ ) { ğ¶ }

( ğ‘“ ) , and

implies

J

K

wlp

implies

( ğ‘“ ) (cid:22) ğ¼ .

while ( ğœ‘ ) { ğ¶ }
J
Let us now look at reasoning about loops in action. For this, we extend our annotation scheme to
loops as shown in Fig. 5a. Again, read the annotations from bottom to top as follows and consider
âŠ²âŠ³ as (cid:22) for simplicity:
(1)
(2)
(3) wp

ğ‘“ We start our reasoning from postweighting ğ‘“ âˆˆ W.
((
ğ¼ We choose (creatively) an invariant ğ¼ which we are going to push through the loop body.
ğ¼ â€² This annotation is obtained (uncreatively) from applying wp
88
), just as in Fig. 4.
((
The program passed into wp is the loop body ğ¶ and the continuation is the invariant ğ¼ . Hence,
this annotation states ğ¼ â€² = wp
( ğ¼ ) and by that we have pushed ğ¼ through the loop body.

K

J

K

(

ğ¶
J

K

20

Batz, Gallus, Kaminski, Katoen, and Winkler

(4) (cid:22)
(5) Î¦
((
((

(6) (cid:22)

((

ğ¼ â€²â€² This annotation states that ğ¼ â€² (cid:22) ğ¼ â€²â€², i.e. ğ¼ â€²â€² overapproximates ğ¼ â€², just as in Fig. 4.
ğ‘” This annotation ğ‘” is obtained from ğ¼ â€²â€² â€” the result of pushing the invariant ğ¼ through the
loop body (and possibly overapproximating the result) â€” by constructing ğ‘” = [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] ğ¼ â€²â€².
This annotation states that ğ‘” (cid:23) Î¦ğ‘“ (ğ¼ ).
ğ¼ This annotation states that ğ‘” (cid:22) ğ¼ , just as in Fig. 4. Since Î¦ğ‘“ (ğ¼ ) (cid:22) ğ‘” (cid:22) ğ¼ , this ï¬nal
( ğ‘“ ) (cid:22) ğ¼ and we could continue reasoning
annotation states by Theorem 5.1 that wp
loop
with ğ¼ .

K

J

Example 5.5. Consider the arctic semiring A = (N+âˆ âˆª { âˆ’âˆ }, max, +, âˆ’âˆ, 0) and the pro-

gram

ğ¶

=

while ( ğ‘¥ > 0 âˆ§ ğ‘¦ > 0 ) {

{ ğ‘¥ â‰” ğ‘¥ âˆ’ 1

ğ‘¦ â‰” ğ‘¦ + 1 } âŠ• { ğ‘¦ â‰” ğ‘¦ âˆ’ 1 }

âŠ™ 1

} .

#

#

ğ¶ is UCT, witnessed by the ranking function ğ‘Ÿ = 3ğ‘¥ + 2ğ‘¦: Both branches of the loop body strictly
decrease the value of ğ‘Ÿ . We verify that ğ¼ = [Â¬ğœ‘] 0 âŠ• [ğœ‘] (2(ğ‘¥ âˆ’ 1) + ğ‘¦), where ğœ‘ = (ğ‘¥ > 0 âˆ§ ğ‘¦ > 0),
is a ï¬xed point of Î¦0 in Fig. 5b. Hence, by Corollary 5.4, we get wp
( 0 ) = ğ¼ . By Theorem 4.9,
( 0 ) is the maximum weight among all terminating computations paths. In ğ¶, the weight
wp
of a path is the number of times it passes through the loop body. We thus conclude that the number
of ğ¶â€™s loop iterations is bounded by 2(ğ‘¥ âˆ’ 1) + ğ‘¦ if initially ğ‘¥ > 0 âˆ§ ğ‘¦ > 0 holds. This bound is
sharp.

ğ¶
J

ğ¶
J

K

K

6 CASE STUDIES
6.1 Competitive Analysis of Online Algorithms by Weighted Programming

Field:
Problem:

Competitive Analysis
Ski Rental Problem

Model:
Semiring: Tropical Semiring

Optimization Problem

Techniques: wp

We now demonstrate how to model optimization problems by means of weighted programming and
how to reason about competitive ratios of online algorithms [Borodin and El-Yaniv 1998; Fiat and
Woeginger 1998] on source code level by means of our wp calculus with the aid of invariants. In
particular, we model both the optimal solution to the Ski Rental Problem itself as well as the opti-
mal deterministic online algorithm for the problem as weighted programs. We argue that weighted
programming provides a natural formalism for reasoning about the competitive ratio of online
algorithms since weighted programs enable the succinct integration of cost models.

6.1.1 Online Algorithms and Competitive Analysis. Online algorithms perform their computation
without knowing the entire input a priori. Rather, parts of the input are revealed to the online
algorithm during the course of the computation. We consider here the well-known Ski Rental
Problem [Komm 2016]: Suppose we go an a ski trip for an a priori unknown number of ğ‘› â‰¥ 1 days
and we do not own a pair of skis. At the beginning of each day, we must choose between either
renting skis for exactly one day (cost: 1 Euro) or to buy a pair of skis (cost: ğ‘¦ euros).

The optimization goal is to minimize the total cost for the whole trip. If we knew the duration ğ‘› of
the trip a priori, the optimal solution would be rather obvious: If ğ‘› â‰¥ ğ‘¦, we buy the skis. Otherwise,
we are cheaper oï¬€ renting every day. This situation would correspond to an oï¬„ine setting, with
both ğ‘› and ğ‘¦ at hand, allowing for an optimal solution. Conversely, if the trip duration ğ‘› is unkown
and only the cost ğ‘¦ of the skis is known, we are in an online setting of the Ski Rental Problem.

Lacking knowledge about the entire input a priori often comes at the cost of non-optimality: An
online algorithm typically performs worse than the optimal oï¬„ine algorithm. Competitive analy-
sis [Borodin and El-Yaniv 1998] is a technique for measuring the degree of optimality of an online

Weighted Programming

21

while ( ğ‘› > 0 ) {
ğ‘› â‰” ğ‘› âˆ’ 1
{ (* rent *)
âŠ™ 1

#

} âŠ• { (* buy *)

âŠ™ ğ‘¦
#ğ‘› â‰” 0 (* terminate *)

} }

ğ‘ â‰” ğ‘ + 1

#

#

ğ‘ â‰” 0
while ( ğ‘› > 0 ) {
ğ‘› â‰” ğ‘› âˆ’ 1
if ( ğ‘ < ğ‘¦ ) {
âŠ™ 1
} else {
âŠ™ ğ‘¦

#

} }

#

ğ‘› â‰” 0

(a) The program ğ¶opt.

(b) The program ğ¶onl.

Fig. 6. The optimal solution to the Ski Rental Problem is modeled by ğ¶opt. The program ğ¶onl implements the
optimal deterministic online algorithm.

algorithm. The central notion is the competitive ratio of an online algorithm. Given a problem in-
stance ğœŒ, denote by ONL(ğœŒ) and OPT(ğœŒ) the cost of an online algorithm ONL and the cost of its
optimal oï¬„ine counterpart OPT on ğœŒ, respectively. The competitive ratio of ONL is deï¬ned as

ONL(ğœŒ)
OPT(ğœŒ)

,

sup
ğœŒ

i.e. the smallest constant upper-bounding the ratio between the cost of ONL and OPT for all prob-
lem instances ğœŒ. We determine such competitive ratios by wp-reasoning on weighted programs.

6.1.2 Modeling Infinite-State Online Algorithms as Weighted Programs. Together with wp-reasoning,
weighted programs over the tropical semiring T provide an appealing formalism for the compet-
itive analysis of inï¬nite-state online algorithms since (1) (nondeterministic) programs naturally
describe algorithmic problems- and solutions, and (2) reasoning on source code level enables rea-
soning about inï¬nite-state models. Modeling online algorithms as weighted programs is inspired
by [Aminof et al. 2009, 2010], who employ ï¬nite-state weighted automata for the automated com-
petitive analysis of ï¬nite-state online algorithms. We drop the restriction to ï¬nite-state algorithms
which comes, however, at the cost of full automation of their veriï¬cation.

Consider the nondeterministic weighted program ğ¶opt on the left-hand side of Figure 6 (let us
ignore the annotations for the moment). An initial program state ğœ âˆˆ Î£ ï¬xes an instance of the Ski
Rental Problem given by the duration ğœ (ğ‘›) of the trip and the cost ğœ (ğ‘¦) of the skis. Every execution
of ğ¶opt on ğœ corresponds to one possible solution: Each iteration of the loop corresponds to one day
of the ski trip. As long as the trip did not end (ğ‘› > 0), we can either rent the skis (ï¬rst branch) or
buy the skis (second branch). If we buy the skis, there is no further choice to be taken, so the loop
terminates. The cost of each choice is modeled by weighing the respective branches appropriately.
Now recall that in the tropical semiring T we have âŠ• = min, âŠ™ = +, 0 = âˆ, and 1 = 0. Thus,
the weight of a terminating computation path ğœ‹ is the sum of the weights along ğœ‹, i.e. the cost of
the solution given by ğœ‹. This enables determining the optimal cost for every initial program state
ğœ, i.e. every instance of the Ski Rental Problem, by wp-reasoning (cf. Example 4.11) since
wp qğ¶opty ( 1 ) (ğœ) = â€œminimum weight of all terminating computation paths starting in ğœâ€ .
Program ğ¶onl on the right-hand side in Figure 6 implements the optimal solution for the online
version of the Ski Rental Problem. The decisions made by ğ¶onl must therefore not depend on ğ‘›.

22

Batz, Gallus, Kaminski, Katoen, and Winkler

ğ¶onl
J

K

Let us compare the programs ğ¶opt and ğ¶onl. Program ğ¶onl is obtained from ğ¶opt by introducing a
counter ğ‘ keeping track of the elapsed time and by replacing the nondeterministic choice in ğ¶opt
by a deterministic one. As long as the current duration of the trip is smaller than the cost of the
skis, we rent the skis. As soon as this duration is at least the cost of the skis, we buy the skis. Since
ğ¶onl is deterministic, the cost of ğ¶onl on ğœ is given by wp

( 1 ) (ğœ).

6.1.3 Determining Competitive Ratios by wp-Reasoning. Due to the above reasoning,

.

sup
ğœ âˆˆÎ£

ğ¶onl
J

( 1 ) (ğœ)
wp
K
wp qğ¶opty ( 1 ) (ğœ)
is the competitive ratio of ğ¶onl. Hence, we obtain the competitive ratio of ğ¶onl by determining
wp qğ¶opty ( 1 ) and wp

ğ¶onl
J
Theorem 6.1. We have
wp qğ¶opty ( 1 ) = ğ‘› âŠ• ğ‘¦ , and wp
Proof. Since both ğ¶opt and ğ¶onl are UCT (witnessed by the ranking function ğ‘›), it suï¬ƒces to
show that the above weightings are ï¬xed points of the respective characteristic functional by
(cid:3)
Corollary 5.4. We proceed by annotating the programs. See Appendix E.1 for details.

( 1 ). This can be done in an invariant-based manner:

( 1 ) = [ğ‘› = 0] 0 âŠ• [0 < ğ‘¦]

(2ğ‘¦ âˆ’ 1) âŠ• [ğ‘› â‰¤ ğ‘¦ âˆ’ 1] ğ‘›

ğ¶onl
J

K

K

(cid:0)

(cid:1)

.

ğ¶onl
J

The fact that wp qğ¶opty ( 1 ) = ğ‘› âŠ• ğ‘¦ = ğœ†ğœ. ğœ (ğ‘›) min ğœ (ğ‘¦) corresponds to our informal description
from the beginning of this section: Depending on whether the duration of the trip ğ‘› exceeds the
cost ğ‘¦ of the skis, it is optimal to either immediately buy the skis or to keep renting them every
( 1 ) of ğ¶onl is more involved. If ğ‘› = 0, the cost of ğ¶onl is 0. Otherwise, i.e.
day. The cost wp
if the trip lasts for at least one day, there are two cases. If ğ‘› is strictly smaller than ğ‘¦, then the cost
of ğ¶onl is the minimum of 2ğ‘¦ âˆ’ 1 and ğ‘›. Otherwise, i.e. if ğ‘› is at least ğ‘¦, the cost of ğ¶onl is 2ğ‘¦ âˆ’ 1.

We can now determine the competitive ratio of ğ¶onl. Let, for simplicity, both ğ‘› > 0 and ğ‘¦ > 0
so that ğ‘› âŠ• ğ‘¦ > 0. This assumption is reasonable since the problem becomes trivial if the trip ends
= ğœ†ğœ. ğ‘“ (ğœ)
immediately or the skis are gratis. Given two weightings ğ‘“ , ğ‘” with ğ‘” > 0, we deï¬ne ğ‘“
ğ‘” (ğœ) .
ğ‘”
We conclude that the competitive ratio of ğ¶onl is 2 since 2 is the smallest constant upper bounding

K

( 1 )
wp
ğ¶onl
J
wp qğ¶opty ( 1 )

K

=

(2ğ‘¦ âˆ’ 1) âŠ• [ğ‘› â‰¤ ğ‘¦ âˆ’ 1] ğ‘›
ğ‘› âŠ• ğ‘¦

= [ğ‘› â‰¥ ğ‘¦]

2 âˆ’

(cid:0)

1
ğ‘¦

(cid:1)

âŠ• [ğ‘› < ğ‘¦] 1 .

6.2 Mutual Exclusion

Field:
Problem: Mutual Exclusion

Formal Veriï¬cation

Model:
Module: ğœ”-potent Formal Languages

Computation Traces

Techniques: wlp

In this case study, we instantiate weighted programming with the module of ğœ”-potent formal
languages to reason about inï¬nite behaviors of a semaphore-based mutual exclusion algorithm.
This is done in an invariant-based manner enabled by wlp-reasoning.

6.2.1 A Mutual Exclusion Protocol. Consider the program ğ¶mut shown in Fig. 7a and disregard
the weightings for the moment. Program ğ¶mut models ğ‘ processes participating in a semaphore-
based mutual exclusion protocol. On each iteration of the non-terminating while loop, a scheduler
selects one of the ğ‘ processes. The status â„“ [ğ‘–] of the selected process ğ‘– is either idle (ğ‘›), waiting
(ğ‘¤), or critical (ğ‘). If the process ğ‘– idles, it enters the waiting state. If the process ğ‘– is waiting,
it checks whether the binary semaphore (modeled by the shared variable ğ‘¦) allows to enter the
critical section (ğ‘¦ > 0) and, if so, enters the critical section. Otherwise, i.e. if ğ‘¦ = 0, the process

Weighted Programming

23

must continue waiting. Finally, if the process ğ‘– is in the critical section, it releases the critical section
and updates the semaphore appropriately.

It can be shown by standard means that the protocol modeled by ğ¶mut indeed ensures mutual
exclusion. That is, whenever we start in a state where at most one process is in the critical section
and ğ‘¦ = 0, it will never be the case that more than one process is in the critical section. However,
the protocol exhibits unfair behavior. Suppose the semaphore forbids some waiting process ğ‘˜ to
enter the critical section, i.e. ğ‘¦ = 0 and â„“ [ğ‘˜] = ğ‘¤. It is then possible that the scheduler behaves in
an adversarial manner such that process ğ‘˜ is going to starve, i.e. wait forever.

6.2.2 Reasoning about Infinite Behavior by wlp-Reasoning. We prove that the protocol exhibits un-
fair behavior by weighted programming and wlp-reasoning. To that end, we instantiate our frame-
work with the Î“âˆ—-module12 Lâˆ

Î“ of ğœ”-potent formal languages over Î“ (cf. Example 4.17), where

Î“ =

{ğ‘… ğ‘— ,ğ‘Šğ‘—, ğ¶ ğ‘— } .

Ã˜ğ‘— âˆˆN\{0}

Recall that our module addition âŠ• is union âˆª, the monoid and scalar-multiplications are concate-
nations and the zero element is 0 = âˆ…. Intuitively, (ï¬nite or inï¬nite) behaviors of ğ¶mut correspond
to (ï¬nite or inï¬nite) words over Î“. For instance, the ğœ”-word ğ¶1ğ‘Š ğœ”
2 indicates that process 1 enters
the critical section and that subsequently process 2 waits forever. This is realized by weighing the
branches of the loop body in ğ¶mut appropriately: If the process ğ‘– enters the critical section, waits, or
releases the critical section, we weight the corresponding branch by ğ¶ğ‘–, ğ‘Šğ‘–, or ğ‘…ğ‘–, respectively. This
is similar to labeling the states of a transition system by atomic propositions to express properties
of the system in, e.g. LTL [Baier and Katoen 2008]. Notice, however, that the transition system
underlying ğ¶mut is inï¬nite so that standard ï¬nite-state model checking techniques do not apply.
Now recall from Example 4.17 that the language of ğœ”-words produced by the loop in ğ¶mut on initial
( 0 ) (ğœ). Since the natural ordering (cid:22) on Lâˆ
Î“ is âŠ†, verifying that ğ¶mut indeed
state ğœ is wlp
exhibits the described unfair behavior boils down to proving that
ğ‘˜ (cid:22) wlp

K
[1 â‰¤ ğ‘˜ â‰¤ ğ‘ âˆ§ â„“ [ğ‘˜] = ğ‘¤ âˆ§ ğ‘¦ = 0] ğ‘Š ğœ”

ğ¶mut
J

( 0 ) ,

i.e. we are obliged to prove a lower bound on the weakest liberal preweighting of ğ¶mut w.r.t. (ir-
relevant) postweighting 0, which is done in an invariant-based manner Appendix E.2. The above
property indeed states that ğ¶mut exhibits unfair behavior: Whenever some process ğ‘˜ is waiting
and the semaphore forbids entering the critical section (ğ‘¦ = 0), the behavior ğ‘Š ğœ”
ğ‘˜ is possible, i.e.
process ğ‘˜ might wait forever.

ğ¶mut
J

K

6.3 Proving a Combinatorial Identity by Program Analysis

Field:
Problem: Counting bit patterns

Combinatorics

Model:
Semiring: Natural numbers

Combinatorial class

Techniques: wp

We instantiate our framework with the semiring (N+âˆ, +, Â·, 0, 1) to count the number of com-
putation paths in our programs. If a program ğ¶ does not contain weight-statements, it follows
from Theorem 4.9 that the number of terminating computation paths starting in ğœ is given by
( 1 ) (ğœ). More generally, given a predicate ğœ‘ over the program variables, the number of
wp
( [ğœ‘] 1 ) (ğœ). Thus,
paths terminating in a state satisfying ğœ‘ on initial state ğœ is given by wp
counting computation paths reduces to weakest preweighting-reasoning as illustrated in the fol-
lowing example.

ğ¶
J

ğ¶
J

K

K

12This is the only example in this section where we do not pursue the default method of specifying both the monoid W
and the module M at once by means of a single semiring S.

24

while ( true ) {

ğ‘

{ ğ‘– â‰” ğ‘— }

#

ÃŠğ‘—=1
if ( â„“ [ğ‘–] = ğ‘› ) {
â„“ [ğ‘–] â‰” ğ‘¤

} else if ( â„“ [ğ‘–] = ğ‘¤ ) {
if ( ğ‘¦ > 0 ) { âŠ™ ğ¶ğ‘–
else {âŠ™ ğ‘Šğ‘– }
} else if ( â„“ [ğ‘–] = ğ‘ ) {

#

ğ‘¦ â‰” ğ‘¦ âˆ’ 1

â„“ [ğ‘–] â‰” ğ‘ }

#

âŠ™ ğ‘…ğ‘–

ğ‘¦ â‰” ğ‘¦ + 1

â„“ [ğ‘–] â‰” ğ‘›

#

#

}

}

(a) The program ğ¶mut.

Batz, Gallus, Kaminski, Katoen, and Winkler

ğ‘ â‰” 0

ğ‘š â‰” 0
#
#
while ( ğ‘› > 0 ) {
ğ‘› â‰” ğ‘› âˆ’ 1

// ğ‘Ÿğ‘’ğ‘  â‰” []

#

{

ğ‘ â‰” 0 // append ( ğ‘Ÿğ‘’ğ‘ , 0 )

#

} âŠ• {

#

ğ‘ â‰” ğ‘ + 1
ğ‘š â‰” max(ğ‘š, ğ‘)

#

// append ( ğ‘Ÿğ‘’ğ‘ , 1 )

#

}

}

(b) The program ğ¶count.

Fig. 7. The program ğ¶mut is a mutual exclusion protocol adapted from [Baier and Katoen 2008]. The program
ğ¶count generates ğ‘›-bit strings and stores the maximum number of consecutive 1â€™s in ğ‘š.

Suppose we were to count the number of bit strings of length ğ‘› that avoid the pattern â€œ11â€.
Program ğ¶count in Fig. 7b non-deterministically â€œconstructsâ€ bit strings of length equal to the (input)
variable ğ‘› and simultaneously keeps track of the maximum amount of consecutive 1â€™s that have
occurred in variable ğ‘š. Since we are interested in counting strings not containing â€œ11â€, we have
( [ğ‘š â‰¤ 1] 1 ). To handle the loop in ğ¶count, we employ the loop invariant
to determine wp

ğ¶count
J
ğ¼ â‰” [ğ‘š â‰¤ 1] ( [ğ‘ = 0] Fib(ğ‘› + 2) âŠ• [ğ‘ > 0] Fib(ğ‘› + 1))

K

and verify that ğ¼ is indeed a ï¬xed point of the wp-characteristic functional of the loop Appendix E.3.
Here, Fib(ğ‘›) is the ğ‘›-th Fibonacci number deï¬ned recursively via Fib(0) â‰” 0, Fib(1) â‰” 1, and for
all ğ‘› â‰¥ 2, Fib(ğ‘›) â‰” Fib(ğ‘› âˆ’ 1) + Fib(ğ‘› âˆ’ 2). Since ğ¶count is obviously certainly terminating and ğ¼ is
a ï¬xed point of the wp-characteristic function of the loop w.r.t. postweighting [ğ‘š â‰¤ 1] 1, we have

wp

ğ¶count
J

K

( [ğ‘š â‰¤ 1] 1 )

=

ğ¼ [ğ‘/0] [ğ‘š/0]

=

Fib(ğ‘› + 2) ,

by Theorem 5.3, i.e. the number of â€œ11â€-avoiding bit strings of length ğ‘› is equal to Fib(ğ‘› + 2).

7 RELATED WORK

We organize related works in three categories: (1) Other generalized predicate transformers, (2) semir-
ing programming paradigms, (3) other approaches to modelling optimization problems.

7.1 Generalized Predicate Transformers and Hoare Logics

A well-known concrete instance of generalized, quantitative predicates are potential functions
Î¦ : Î£ â†’ Râ‰¥0. Such functions are used in amortized complexity analysis [Tarjan 1985] can be re-
garded an instance of the weightings introduced in this paper. Carbonneaux [2018]; Carbonneaux
et al. [2015] present a resource bound veriï¬cation system for a subset of C programs based on po-
tential functions. A non-trivial subset of their veriï¬cation rules can be recovered by instantiating
our framework with the tropical semiring, and interpreting their resource consumption statement

Weighted Programming

25

tick(n) as our weight primitive âŠ™ ğ‘›. More speciï¬cally, Carbonneaux et al. [2015] deï¬ne a quan-
titative Hoare triple { Î¦ } ğ‘ƒ { Î¦â€² }, where Î¦, Î¦â€² are potential functions, and ğ‘ƒ is a (deterministic)
program. Such a triple is valid iï¬€ for all initial states ğœ âˆˆ Î£ such that ğ‘ƒ terminates in a ï¬nal state ğœ â€²
it holds that Î¦(ğœ) â‰¥ ğ‘› + Î¦â€²(ğœ â€²), where ğ‘› is the resource consumption of ğ‘ƒ started on ğœ. It follows
( Î¦â€² ) is the least poten-
that { wp
tial ğ‘‹ that validates the triple { ğ‘‹ } ğ‘ƒ { Î¦â€² }. While the programming language from [Carbonneaux
et al. 2015] has advanced features such as procedures and recursion, it lacks a non-deterministic
choice as present in wGCL. A promising direction for future work is to investigate whether the
automatic inference algorithm of Carbonneaux et al. [2015] can be extended to non-deterministic
programs.

( Î¦â€² ) } ğ‘ƒ { Î¦â€² } is always a valid triple; furthermore, wp

ğ‘ƒ
J

ğ‘ƒ
J

K

K

Very recent works have studied predicate transformers and Hoare-style logics from an abstract
categorical perspective. A generic approach to deï¬ne predicate transformers, like our wp and wlp,
is given by Aguirre and Katsumata [2020], but only for loop-free programs. On the loop-free frag-
ment of wGCL, our weakest preweighting transformer wp is an instance of their framework. They
capture the computational side eï¬€ects, like our weightings, in a monad. More precisely, our trans-
former is obtained from the composed monad MSet (Writer w -) of a multiset monad MSet
- that distributes over a writer monad Writer w -. This speciï¬c instance, however, is not dis-
cussed explicitly by Aguirre and Katsumata [2020]. The writer monad corresponds to our weight-
ing monoid W, whereas the multiset monad captures the branching construct { ğ¶1 } âŠ• { ğ¶2 } that
we treat via W-modules. In contrast to their work, our wp is deï¬ned for loops. Moreover, we
introduce two transformers, wp for ï¬nite computations and wlp that additionally accounts for in-
ï¬nite computations. Finally, the correspondence to an operational semantics is not established in
[Aguirre and Katsumata 2020]. An interesting direction for future work is to explicitly construct
a strongest postcondition transformer for weighted programming, which Aguirre and Katsumata
[2020] deï¬ne non-constructively as an adjoint to wp. Problems with deï¬ning strongest postexpec-
tations for probabilistic programs, see [Jones 1990], demonstrate that giving a concrete strongest
post semantics is far less easy, even if it can be deï¬ned abstractly as an adjoint.

In a similar spirit, Gaboardi et al. [2021] introduce the notion of graded categories to unify
graded monadic and graded comonadic eï¬€ects. The gradings are over partially ordered monoids
(pomonoids) and can, for example, model probabilities or resources like our weightings. In the set-
ting of imperative languages, they consider it â€œnatural to have just the multiplicative structure of
the semiring as a pomonoidâ€ [Gaboardi et al. 2021, Sec. 6] because their programs only have one
input and output. The additive structure of semiring gradings has been used to join multiple inputs
for resource consumption in the ğœ†-calculus with comonadic contexts [Brunel et al. 2014; Ghica and
Smith 2014; Petricek et al. 2014]. In contrast, we use addition to join multiple outputs in monadic
computations, e. g. branching in our examples (Fig. 6 and Fig. 7). Hence, it might be interesting fu-
ture work to extend their categorical semantics with branching. They go on to construct a Graded
( [ğœ“ ] 1 ) given
Hoare Logic (GHL) with judgments âŠ¢ğ‘¤ {ğœ™ } ğ¶ {ğœ“ } corresponding to [ğœ™] ğ‘¤ (cid:22) wp
(Boolean) pre- and postconditions ğœ™,ğœ“ , program ğ¶, and a weight ğ‘¤ from a semiring. Although un-
bounded loops have been studied in concrete instances, they restrict to bounded loops in the general
setting: â€œThis allows us to focus on the grading structures for total functions, leaving the study
of the interaction between grading and partiality to future work.â€ [Gaboardi et al. 2021, Sec. 2].
Our work does not impose such restrictions. Both of our veriï¬cation calculi wp and wlp deal with
possibly unbounded loops.

ğ¶
J

K

Swierstra and Baanen [2019] handle eï¬€ects by monads, focussing on functional rather than
imperative programming. They show how to synthesize programs from speciï¬cations using general
results on predicate transformers. Combining these synthesis techniques with the above monad

26

Batz, Gallus, Kaminski, Katoen, and Winkler

instance of [Aguirre and Katsumata 2020] for the synthesis of weighted programs is an interesting
direction for future work.

7.2 Computing with Semirings
There exist a number of computation and programming paradigms in the literature that â€” similarly
to our approach â€” are parameterized by a semiring. Oâ€™Conner [2012] and Dolan [2013] show
that computational problems such as shortest paths, deriving the regular expression of a ï¬nite
automaton, dataï¬‚ow analysis, and others can be reduced to linear algebra over a suitable semiring.
They also provide concise Haskell implementations solving the resulting matrix problems in a
uniï¬ed way. The heart of these techniques is to compute the so-called star or closure ğ‘¥ âˆ— = 1 +
ğ‘¥ + ğ‘¥ 2 + . . . where ğ‘¥ is a matrix over the semiring. The same ğ‘¥ âˆ— is also the least solution of the
equation ğ‘¥ âˆ— = 1+ğ‘¥ Â·ğ‘¥ âˆ—. This ï¬xed point equation is closely related to the lfp occurring in our wp. In
fact, it can be interpreted as an automata-theoretic explicit-state analog to our wp. Our framework,
however, extends this to inï¬nite state spaces and allows reasoning in a symbolic fashion. The above
techniques, on the other hand, would require an inï¬nite transition matrix ğ‘¥, and are therefore
limited to ï¬nite-state problems, e. g. shortest paths in ï¬nite graphs.

Functional and declarative approaches for programming with semirings have also been explored.
Laird et al. [2013] and Brunel et al. [2014] consider functional languages parameterized by a semir-
ing and provide a categorical semantics. Their languages feature weighting computation steps
similar to our language. Additionally, Brunel et al. [2014] provide static analysis techniques to
obtain upper bounds on the weight of a computation. Indeed, with an appropriate semiring, the
semantics deï¬ned in these works also allows reasoning about e. g. best/worst-case resource con-
sumption, reachability probabilities, or expected values. In contrast to [Brunel et al. 2014; Laird
et al. 2013], our programming language is imperative and our semantics generalizes weakest pre-
conditions. Moreoever, while Laird et al. [2013] exemplify how their framework can be used to
detect inï¬nite reduction sequences, it does not provide a general way to assign a weight to diverg-
ing computation paths as our wlp does. Brunel et al. [2014] do not deal with inï¬nite computations.
Belle and De Raedt [2020] pursue a declarative approach by computing the weighted model count
of logical formulae in some theory where the literals are weighted in a semiring. Applications in-
clude matrix factorization, computing polyhedral volumes, or probabilistic inference. Furthermore,
Balkir et al. [2020]; Cohen et al. [2008] study weighted logic programs with a focus on parsers. This
declarative paradigm is, however, rather diï¬€erent from our weighted programs which allow spec-
ifying models in an algorithmic, imperative manner.

Kleene Algebras with Tests (KAT) [Kozen 1999, 2000] can model imperative programs in an
abstract fashion by identifying them with the objects from a Kleene algebra with an embedded
Boolean subalgebra. An important application of KAT is equational reasoning; and hence to e. g.
derive the rules of Hoare logic by applying algebraic manipulations. Note that a Kleene algebra is
itself an idempotent semiring whose purpose, however, is not to model weights of any kind but
the programs themselves. Nonetheless, to reason about weighted computations similar to us, KAT
was recently generalized to Graded KAT [Gomes et al. 2019] by replacing the Boolean subalgebra
with a more general object that can be viewed as a semiring with additional operations and axioms.
The elements of this semiring constitute the graded (or weighted) outcomes of the tests. However,
(Graded) KAT are no concrete programming languages; their main purpose is to prove general
results about imperative languages with loops and conditionals in an abstract fashion. Indeed,
investigating which of our wp (wlp) and invariant-based proof rules can be derived in Graded
KAT is an appealing direction for future work.

Weighted Programming

27

7.3 Optimization
There exists a large amount of work on modelling and solving optimization problems. A prominent
example is constrained optimization (e. g. linear programming [Horen 1985; Schrijver 1999]) for
which standardized- and domain-speciï¬c languages exist [Lofberg 2004; Nethercote et al. 2007].
Modelling and solving optimization problems with weighted programming diï¬€ers mainly in two
aspects from these techniques. (1) The way how optimization problems are modelled and (2) what
is modelled and for what purpose. Regarding aspect (1), techniques like integer linear program-
ming or languages like MiniZinc model optimization problems in a constraint-based manner. With
weighted programs, we describe these problems instead in an algorithmic fashion. As an intuition,
constrained optimization vs. weighted programming could be considered analogous to logic pro-
gramming vs. imperative programming.

Regarding aspect (2), constraint-based techniques often model one particular problem instance
for which an optimal solution is computed. Weighted programs, on the other hand, provide a means
to model and reason about every (out of possibly inï¬nitely many) problem instance at once. This
comes, however, at the cost of computability. The case study on the ski rental problem exempliï¬es
this: We verify the competitive ratio of the optimal online algorithm for every trip duration of the
ski rental problem. Automating this veriï¬cation process is an appealing direction for future work.
More closely related is the work by Bistarelli et al. [1997], who generalize Constraint Logic
Programming (CLP) by parameterizing CLP with a semiring ğ‘†. Elements and operations of ğ‘† take
over the role Boolean constants and connectives. This allows to, e. g. solve optimization problems
by ï¬nding atom instantiations of minimal cost.

8 CONCLUSION
We have studied weighted programming as a programming paradigm for specifying mathematical
models. We developed a weakest (liberal) precondition-style veriï¬cation framework for reasoning
about both ï¬nite and inï¬nite computations of weighted programs and demonstrated the eï¬ƒcacy of
our framework on several case studies. Future work includes automated reasoning about weighted
programs using, e.g., generalizations of ğ‘˜-induction [Batz et al. 2021; Sheeran et al. 2000] and
weighted program synthesis [Alur et al. 2015; Manna and Waldinger 1980]. Further directions are
weighted separation logics [Batz et al. 2019a; Ishtiaq and Oâ€™Hearn 2001; Reynolds 2002] as well
as to investigate â€œsamplingâ€ algorithms for weighted programs. For instance, what would be an
analogon to MCMC sampling in a weighted setting?

ACKNOWLEDGMENTS
This work was supported by the ERC AdG Frappant (787914) (https://cordis.europa.eu/project/id/787914)
and RTG 2236 UnRAVeL (https://gepris.dfg.de/gepris/projekt/282652900) funded by the German
Research Foundation. Part of this work was carried out at Schloss Dagstuhl â€“ Leibniz Center for
Informatics. We thank Lena Verscht and Linpeng Zhang for the fruitful discussions at Schloss
Dagstuhl.

REFERENCES
Samson Abramsky. 1994. Handbook of Logic in Computer Science. Vol. 3. Clarendon Press, Chapter Domain Theory.

http://www.cs.bham.ac.uk/~axj/papers.html

Alejandro Aguirre and Shin-ya Katsumata. 2020. Weakest Preconditions in Fibrations. In MFPS (Electronic Notes in Theo-

retical Computer Science, Vol. 352). Elsevier, 5â€“27. https://doi.org/10.1016/j.entcs.2020.09.002

Rajeev Alur, Rastislav BodÃ­k, Eric Dallal, Dana Fisman, Pranav Garg, Garvit Juniwal, Hadas Kress-Gazit, P. Madhusudan,
Milo M. K. Martin, Mukund Raghothaman, Shambwaditya Saha, Sanjit A. Seshia, Rishabh Singh, Armando Solar-Lezama,
In Dependable Software Systems Engineering.
Emina Torlak, and Abhishek Udupa. 2015. Syntax-Guided Synthesis.

28

Batz, Gallus, Kaminski, Katoen, and Winkler

NATO Science for Peace and Security Series, D: Information and Communication Security, Vol. 40. IOS Press, 1â€“25.
https://doi.org/10.3233/978-1-61499-495-4-1

Benjamin Aminof, Orna Kupferman, and Robby Lampert. 2009. Reasoning About Online Algorithms with Weighted Au-

tomata. In SODA. SIAM, 835â€“844. https://doi.org/10.1137/1.9781611973068.91

Benjamin Aminof, Orna Kupferman, and Robby Lampert. 2010. Reasoning about Online algorithms with Weighted Au-

tomata. ACM Trans. Algorithms 6, 2 (2010), 28:1â€“28:36. https://doi.org/10.1145/1721837.1721844

Ralph-Johan Back and Joakim von Wright. 1998.

Reï¬nement Calculus - A Systematic Introduction.

Springer.

https://doi.org/10.1007/978-1-4612-1674-2

Marc Bagnol. 2014. On the Resolution Semiring. (Sur le Semi-anneau de RÃ©solution). Ph. D. Dissertation. Aix-Marseille

University, Aix-en-Provence, France.

Christel Baier and Joost-Pieter Katoen. 2008. Principles of Model Checking. MIT Press.
Esma Balkir, Daniel Gildea, and Shay B. Cohen. 2020. Tensors over Semirings for Latent-Variable Weighted Logic Programs.

In IWPT 2020. Association for Computational Linguistics, 73â€“90. https://doi.org/10.18653/v1/2020.iwpt-1.8

Kevin Batz, Mingshuai Chen, Benjamin Lucien Kaminski, Joost-Pieter Katoen, Christoph Matheja, and Philipp SchrÃ¶er.
2021. Latticed k-Induction with an Application to Probabilistic Programs. In CAV (2) (Lecture Notes in Computer Science,
Vol. 12760). Springer, 524â€“549. https://doi.org/10.1007/978-3-030-81688-9_25

Kevin Batz, Benjamin Lucien Kaminski, Joost-Pieter Katoen, Christoph Matheja, and Thomas Noll. 2019a. Quantitative
separation logic: a logic for reasoning about probabilistic pointer programs. Proc. ACM Program. Lang. 3, POPL (2019),
34:1â€“34:29. https://doi.org/10.1145/3290347

Kevin Batz, Benjamin Lucien Kaminski, Joost-Pieter Katoen, Christoph Matheja, and Thomas Noll. 2019b. Quantitative
Separation Logic: A Logic for Reasoning about Probabilistic Pointer Programs. Proc. ACM Program. Lang. 3, POPL
(2019), 34:1â€“34:29. https://doi.org/10.1145/3290347

Vaishak Belle and Luc De Raedt. 2020. Semiring Programming: A Semantic Framework for Generalized Sum Product

problems. Int. J. Approx. Reason. 126 (2020), 181â€“201. https://doi.org/10.1016/j.ijar.2020.08.001

Stefano Bistarelli, Ugo Montanari, and Francesca Rossi. 1997. Semiring-based Constraint Logic Programming. In IJCAI (1).

Morgan Kaufmann, 352â€“357.

Allan Borodin and Ran El-Yaniv. 1998. Online Computation and Competitive Analysis. Cambridge University Press.
AloÃ¯s Brunel, Marco Gaboardi, Damiano Mazza, and Steve Zdancewic. 2014. A Core Quantitative Coeï¬€ect Calculus. In
ESOP (Lecture Notes in Computer Science, Vol. 8410). Springer, 351â€“370. https://doi.org/10.1007/978-3-642-54833-8_19

Quentin Carbonneaux. 2018. Modular and certiï¬ed resource-bound analyses. Ph. D. Dissertation. Yale University.
Quentin Carbonneaux, Jan Hoï¬€mann, and Zhong Shao. 2015. Compositional certiï¬ed resource bounds. In Proceedings of
the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation, Portland, OR, USA, June 15-17,
2015, David Grove and Stephen M. Blackburn (Eds.). ACM, 467â€“478. https://doi.org/10.1145/2737924.2737955

Shay B. Cohen, Robert J. Simmons, and Noah A. Smith. 2008.

Dynamic Programming Algorithms as Prod-
ucts of Weighted Logic Programs. In ICLP (Lecture Notes in Computer Science, Vol. 5366). Springer, 114â€“129.
https://doi.org/10.1007/978-3-540-89982-2_18

Katrin M. Dannert, Erich GrÃ¤del, Matthias Naaf, and Val Tannen. 2019. Generalized Absorptive Polynomials and Prove-

nance Semantics for Fixed-Point Logic. CoRR abs/1910.07910 (2019). https://doi.org/10.48550/arXiv.1910.07910

Edsger Wybe Dijkstra. 1975. Guarded Commands, Nondeterminacy and Formal Derivation of Programs. CACM 18, 8

(1975), 453â€“457. https://doi.org/10.1145/360933.360975

Stephen Dolan. 2013. Fun with Semirings: A Functional Pearl on the Abuse of Linear Algebra. In ICFP. ACM, 101â€“110.

https://doi.org/10.1145/2500365.2500613

Manfred Droste, Werner Kuich, and Heiko Vogler. 2009. Handbook of Weighted Automata (1st ed.). Springer Publishing

Company, Incorporated. https://doi.org/10.1007/978-3-642-01492-5

ZoltÃ¡n Ã‰sik. 2008.

Iteration Semirings. In Developments in Language Theory, Masami Ito and Masafumi Toyama (Eds.).

Springer Berlin Heidelberg, Berlin, Heidelberg, 1â€“20. https://doi.org/10.1007/978-3-540-85780-8_1

Amos Fiat and Gerhard J. Woeginger (Eds.). 1998. Online Algorithms, The State of the Art. Lecture Notes in Computer
Science, Vol. 1442. Springer. https://doi.org/10.1007/BFb0029561 the book grow out of a Dagstuhl Seminar, June 1996.
Marco Gaboardi, Shin-ya Katsumata, Dominic Orchard, and Tetsuya Sato. 2021. Graded Hoare Logic and its Categorical
Semantics. In Programming Languages and Systems - 30th European Symposium on Programming, ESOP 2021, Held as Part
of the European Joint Conferences on Theory and Practice of Software, ETAPS 2021, Luxembourg City, Luxembourg, March
27 - April 1, 2021, Proceedings (Lecture Notes in Computer Science, Vol. 12648), Nobuko Yoshida (Ed.). Springer, 234â€“263.
https://doi.org/10.1007/978-3-030-72019-3_9

Martin Gavalec, Zuzana Nemcova, and Sergei Sergeev. 2015. Tropical linear algebra with the Åukasiewicz T-norm. Fuzzy

Sets Syst. 276 (2015), 131â€“148. https://doi.org/10.1016/j.fss.2014.11.008

Brunella Gerla. 2003. Many-valued logic and semirings. Neural Network World 13 (01 2003).

Weighted Programming

29

Dan R. Ghica and Alex I. Smith. 2014. Bounded Linear Types in a Resource Semiring. In Programming Languages and
Systems - 23rd European Symposium on Programming, ESOP 2014, Held as Part of the European Joint Conferences on
Theory and Practice of Software, ETAPS 2014, Grenoble, France, April 5-13, 2014, Proceedings (Lecture Notes in Computer
Science, Vol. 8410), Zhong Shao (Ed.). Springer, 331â€“350. https://doi.org/10.1007/978-3-642-54833-8_18

J. Golan.

2003.

Semirings

and Aï¬ƒne

Equations

over

Them:

Theory

and Applications.

https://doi.org/10.1007/978-94-017-0383-3

Martin Goldstern. 2002. Completion of Semirings. (2002). https://doi.org/10.48550/arXiv.math/0208134
Leandro Gomes, Alexandre Madeira, and LuÃ­s Soares Barbosa. 2019. Generalising KAT to Verify Weighted Computations.

Sci. Ann. Comput. Sci. 29, 2 (2019), 141â€“184. https://doi.org/10.7561/sacs.2019.2.141

Andrew D. Gordon, Thomas A. Henzinger, Aditya V. Nori, and Sriram K. Rajamani. 2014. Probabilistic Programming. In

FOSE. ACM, 167â€“181. https://doi.org/10.1145/2593882.2593900

Wataru Hino, Hiroki Kobayashi, Ichiro Hasuo, and Bart Jacobs. 2016. Healthiness from Duality. In LICS. ACM, 682â€“691.

https://doi.org/10.1145/2933575.2935319

C. A. R. Hoare. 1978.

Some Properties of Predicate Transformers.

J. ACM 25, 3 (1978), 461â€“480.

https://doi.org/10.1007/978-1-4612-3228-5_6

Jeï¬€ Horen. 1985. Linear Programming. Networks 15, 2 (1985), 273â€“274. https://doi.org/10.1002/net.3230150211
Samin S. Ishtiaq and Peter W. Oâ€™Hearn. 2001. BI as an Assertion Language for Mutable Data Structures. In POPL. ACM,

14â€“26. https://doi.org/10.1145/360204.375719

Claire Jones. 1990. Probabilistic Non-Determinism. Ph. D. Dissertation. University of Edinburgh, UK.
Benjamin Lucien Kaminski. 2019. Advanced Weakest Precondition Calculi for Probabilistic Programs. Ph. D. Dissertation.

RWTH Aachen University, Germany. https://doi.org/10.18154/RWTH-2019-01829

Georg Karner. 1992.

On Limits

in Complete Semirings.

Semigroup forum 45, 2 (1992), 148â€“165.

https://doi.org/10.1007/bf03025757

Georg Karner. 2004.

Continuous Monoids and Semirings.

Theor. Comput. Sci. 318, 3 (2004), 355â€“372.

https://doi.org/10.1016/j.tcs.2004.01.020

Klaus Keimel. 2015. Healthiness Conditions for Predicate Transformers. In MFPS (Electronic Notes in Theoretical Computer

Science, Vol. 319). Elsevier, 255â€“270. https://doi.org/10.1016/j.entcs.2015.12.016

Dennis Komm. 2016.

An Introduction to Online Computation - Determinism, Randomization, Advice.

Springer.

https://doi.org/10.1007/978-3-319-42749-2

Dexter Kozen.

1985.

A Probabilistic

PDL.

J. Comput.

Syst.

Sci.

30,

2

(1985),

162â€“178.

https://doi.org/10.1016/0022-0000(85)90012-1

Dexter Kozen. 1999. On Hoare Logic and Kleene Algebra with Tests. In LICS. IEEE Computer Society, 167â€“172.

https://doi.org/10.1109/lics.1999.782610

Dexter Kozen. 2000. On Hoare Logic and Kleene Algebra with Tests. ACM Trans. Comput. Log. 1, 1 (2000), 60â€“76.

https://doi.org/10.1145/343369.343378

Werner Kuich. 1991. Automata and Languages Generalized to ğœ”-Continuous Semirings. Theor. Comput. Sci. 79, 1 (1991),

137â€“150. https://doi.org/10.1016/0304-3975(91)90147-t

Jim Laird, Giulio Manzonetto, Guy McCusker, and Michele Pagani. 2013. Weighted Relational Models of Typed Lambda-

Calculi. In LICS. IEEE Computer Society, 301â€“310. https://doi.org/10.1109/lics.2013.36

Johan Lofberg. 2004. YALMIP: A Toolbox for Modeling and Optimization in MATLAB. 2004 IEEE International Conference
on Robotics and Automation (IEEE Cat. No.04CH37508) (2004), 284â€“289. https://doi.org/10.1109/cacsd.2004.1393890
Zohar Manna and Richard J. Waldinger. 1980. A Deductive Approach to Program Synthesis. ACM Trans. Program. Lang.

Syst. 2, 1 (1980), 90â€“121. https://doi.org/10.1145/357084.357090

Matilde Marcolli and Ryan Thorngren. 2011.

Thermodynamic Semirings.

CoRR abs/1108.2874 (2011).

https://doi.org/10.48550/arXiv.1108.2874

Matilde Marcolli and Ryan Thorngren. 2014. Thermodynamic semirings. Journal of Noncommutative Geometry 8, 2 (2014),

337â€“392. https://doi.org/10.4171/jncg/159

Annabelle McIver and Carroll Morgan. 2005. Abstraction, Reï¬nement and Proof for Probabilistic Systems.

Springer.

https://doi.org/10.1007/b138392

Carroll Morgan, Annabelle McIver, and Karen Seidel. 1996. Probabilistic Predicate Transformers. ACM Trans. Program.

Lang. Syst. 18, 3 (1996), 325â€“353. https://doi.org/10.1145/229542.229547

Nicholas Nethercote, Peter J. Stuckey, Ralph Becket, Sebastian Brand, Gregory J. Duck, and Guido Tack. 2007. MiniZinc:
Towards a Standard CP Modelling Language. In CP (Lecture Notes in Computer Science, Vol. 4741). Springer, 529â€“543.
https://doi.org/10.1007/978-3-540-74970-7_38

Antonio Nola and Brunella Gerla. 2005. Algebras of Lukasiewiczâ€™s logic and their semiring reducts. Contemp. Math 377

(01 2005). https://doi.org/10.1090/conm/377/06988

30

Batz, Gallus, Kaminski, Katoen, and Winkler

Russel Oâ€™Conner. 2012.

A Very General Method of Computing Shortest Paths.

Personal blog entry.

http://r6.ca/blog/20110808T035622Z.html

Tomas Petricek, Dominic A. Orchard, and Alan Mycroft. 2014.

Coeï¬€ects: a calculus of context-dependent
computation.
the 19th ACM SIGPLAN international conference on Functional programming,
Gothenburg, Sweden, September 1-3, 2014, Johan Jeuring and Manuel M. T. Chakravarty (Eds.). ACM, 123â€“135.
https://doi.org/10.1145/2628136.2628160

In Proceedings of

Gordon D. Plotkin. 2004. A Structural Approach to Operational Semantics. The Journal of Logic and Algebraic Programming

60-61 (2004), 17â€“139. https://doi.org/10.1016/j.jlap.2004.05.001

Marc Pouly. 2010. Semirings for Breakfast. https://marcpouly.ch/pdf/internal_100712.pdf Visited on 2022-03-21..
John C. Reynolds. 2002. Separation Logic: A Logic for Shared Mutable Data Structures. In LICS. IEEE Computer Society,

55â€“74. https://doi.org/10.1109/lics.2002.1029817

Grzegorz Rozenberg and Arto Salomaa. 1997. Handbook of Formal Languages, Vol. 1: Word, Language, Grammar. Springer-

Verlag. https://doi.org/10.1007/978-3-642-59136-5

Alexander Schrijver. 1999. Theory of Linear and Integer Programming. Wiley.
Mary Sheeran, Satnam Singh, and Gunnar StÃ¥lmarck. 2000.

tion and a SAT-Solver.
https://doi.org/doi.org/10.1007/3-540-40922-x_8

In FMCAD (Lecture Notes

Checking Safety Properties Using Induc-
in Computer Science, Vol. 1954). Springer, 108â€“125.

Richard Sproat, Mahsa Yarmohammadi,

Izhak Shafran, and Brian Roark. 2014.

Semirings to Problems in Speech and Language Processing.
https://doi.org/10.1162/coli_a_00198

Applications of Lexicographic
Comput. Linguistics 40, 4 (2014), 733â€“761.

Wouter Swierstra and Tim Baanen. 2019. A Predicate Transformer Semantics for Eï¬€ects (functional pearl). Proc. ACM

Program. Lang. 3, ICFP (2019), 103:1â€“103:26. https://doi.org/10.1145/3341707

Robert Endre Tarjan. 1985. Amortized computational complexity. SIAM Journal on Algebraic Discrete Methods 6, 2 (1985),

306â€“318. https://doi.org/10.1137/0606031

GÃ¼nther J. Wirsching, Markus Huber, and Christian KÃ¶lbl. 2010. The conï¬dence-probability semiring. Technical Report

2010-04. FakultÃ¤t fÃ¼r Angewandte Informatik.

Linpeng Zhang and Benjamin Lucien Kaminski. 2022a. Quantitative Strongest Post. CoRR abs/2202.06765 (2022).

https://doi.org/10.48550/arXiv.2202.06765

Linpeng Zhang and Benjamin Lucien Kaminski. 2022b. Quantitative Strongest Post. PACMPL (2022).

Issue OOPSLA.

https://doi.org/10.1145/3527331 To appear.

Weighted Programming

31

A BACKGROUND ON SEMIRINGS, SEMIMODULES, AND FIXED POINT THEORY
A.1 Fixed Points

We apply ï¬xed point iteration and ï¬xed point induction to our wp and wlp calculi. Hence, we
recall the required material from Domain Theory here. For a thorough introduction, we refer to
[Abramsky 1994, Ch. Domain Theory].

A reï¬‚exive, transitive, and antisymmetric binary relation (cid:22) on a set ğ´ is a partial order and we
call (ğ´, (cid:22)) a partially ordered set (poset). Let ğµ âŠ† ğ´. We say that ğ‘ âˆˆ ğµ is a least element in ğµ if
ğ‘ (cid:22) ğ‘ â€² for all ğ‘ â€² âˆˆ ğµ. Note that there exists at most one least element. The least element of ğµ = ğ´ is
written âŠ¥ whenever it exists. Further, if the set { ğ‘ âˆˆ ğ´ | âˆ€ğ‘ âˆˆ ğµ : ğ‘ (cid:22) ğ‘ } has a least element, then
ğµ. An inï¬nite sequence
we call it the least upper bound or supremum of ğµ and denote it with
(ğ‘ğ‘– )ğ‘– âˆˆN of elements from ğ´ is called an ascending ğœ”-chain if

ğ‘0 (cid:22) ğ‘1 (cid:22) ğ‘2 (cid:22) . . .

,

Ãƒ

i.e. for all ğ‘– âˆˆ N we have ğ‘ğ‘– (cid:22) ğ‘ğ‘–+1.

It is easy to verify that the structure (ğ´, (cid:23)) that results from reverting the order (cid:22) is also a poset.
Greatest elements, greatest lower bounds or inï¬ma, and descending ğœ”-chains in (ğ´, (cid:22)) are deï¬ned
as least elements, suprema and ascending ğœ”-chains in (ğ´, (cid:23)), respectively. The greatest element
in ğ´ is denoted âŠ¤ if it exists and we adapt the notation d ğµ for inï¬ma.

Deï¬nition A.1 (ğœ”-cpo). The poset (ğ´, (cid:22)) is a (pointed) ğœ”-complete partial order (ğœ”-cpo) if there
exists13 a least element âŠ¥ and every ascending ğœ”-chain (ğ‘ğ‘– )ğ‘– âˆˆN has a supremum
ğ‘– âˆˆN ğ‘ğ‘– . Dually,
we call (ğ´, (cid:22)) a (pointed) ğœ”-cocomplete partial order (ğœ”-cocpo) if (ğ´, (cid:23)) is an ğœ”-cpo, i.e. if there
exists a greatest element âŠ¤ and every descending ğœ”-chain (ğ‘ğ‘– )ğ‘– âˆˆN has an inï¬mum dğ‘– âˆˆN ğ‘ğ‘– . If (ğ´, (cid:22))
â–³
is both an ğœ”-cpo and an ğœ”-cocpo, then we call it an ğœ”-bicpo.

Ãƒ

Consider a poset (ğ´, (cid:22)) with a function ğ‘“ : ğ´ â†’ ğ´. ğ‘“ is called monotone if

âˆ€ğ‘1, ğ‘2 âˆˆ ğ´ :

ğ‘1 (cid:22) ğ‘2

implies

ğ‘“ (ğ‘1) (cid:22) ğ‘“ (ğ‘2) .

Note that ğœ”-chains are preserved under monotone functions: If (ğ‘ğ‘– )ğ‘– âˆˆN is ascending (descending,
respectively), then the same holds for (ğ‘“ (ğ‘ğ‘– ))ğ‘– âˆˆN.

Deï¬nition A.2 (ğœ”-continuous functions). Let (ğ´, (cid:22)) be a poset and ğ‘“ : ğ´ â†’ ğ´ a function. ğ‘“ is

called ğœ”-continuous if it preserves suprema, i.e. for all ascending ğœ”-chains (ğ‘ğ‘– )ğ‘– âˆˆN in ğ´ we have

ğ‘“

ğ‘ğ‘–

!

Ã„ğ‘– âˆˆN

=

ğ‘“ (ğ‘ğ‘– ) .

Ã„ğ‘– âˆˆN

Dually, ğ‘“ is called ğœ”-cocontinuous if it preserves inï¬ma of descending chains. If ğ‘“ is both ğœ”-
â–³
continuous and -cocontinuous, then ğ‘“ is called ğœ”-bicontinuous.

It is easy to see that ğœ”-(co)continuity implies monotonicity, but the converse is false in general.

Lemma A.3. If ğ‘“ : (ğ´, (cid:22)) â†’ (ğ´, (cid:22)) and ğ‘” : (ğ´, (cid:22)) â†’ (ğ´, (cid:22)) are ğœ”-(co)continuous functions, then

their composition ğ‘” â—¦ ğ‘“ : (ğ´, (cid:22)) â†’ (ğ´, (cid:22)) is also ğœ”-(co)continuous.

The ğ‘›-fold composition of a function ğ‘“ : ğ´ â†’ ğ´ is recursively deï¬ned as ğ‘“ 0 = id and ğ‘“ ğ‘› = ğ‘“ â—¦ ğ‘“ ğ‘›âˆ’1
for all ğ‘› > 0.

Let (ğ´, (cid:22)) be a poset. A ï¬xed point of ğ‘“ : ğ´ â†’ ğ´ is an element ğ‘ âˆˆ ğ´ such that ğ‘“ (ğ‘) = ğ‘. A least
(greatest) ï¬xed point of ğ‘“ is a least (greatest, respectively) element in the set of ï¬xed points of ğ‘“ .

13Some authors deï¬ne ğœ”-cpo without requiring the existence of least elements, and speak of ğœ”-cpo with bottom or pointed
ğœ”-cpo.

 
32

Batz, Gallus, Kaminski, Katoen, and Winkler

Theorem A.4 (Kleene Iteration & Park Induction). Let (ğ´, (cid:22)) be a poset and ğ‘“ : ğ´ â†’ ğ´.
(1) If (ğ´, (cid:22)) is an ğœ”-cpo and ğ‘“ is ğœ”-continuous, then ğ‘“ has a least ï¬xed point lfp ğ‘“ satisfying

lfp ğ‘“ =

ğ‘“ ğ‘› (âŠ¥)

and

âˆ€ğ‘ âˆˆ ğ´ :

ğ‘“ (ğ‘) (cid:22) ğ‘

implies

lfp ğ‘“ (cid:22) ğ‘ .

(2) If (ğ´, (cid:22)) is an ğœ”-cocpo and ğ‘“ is ğœ”-cocontinuous, then ğ‘“ has a greatest ï¬xed point gfp ğ‘“ satisfying

Ã„ğ‘› âˆˆN

gfp ğ‘“ = l
ğ‘› âˆˆN

ğ‘“ ğ‘› (âŠ¤)

A.2 Semirings

and

âˆ€ğ‘ âˆˆ ğ´ :

ğ‘ (cid:22) ğ‘“ (ğ‘)

implies ğ‘ (cid:22) gfp ğ‘“ .

In the literature the term semiring is given diï¬€erent meanings; to prevent any confusion we restate
the deï¬nition we use. As usual, multiplication âŠ™ associates stronger than addition âŠ• and we drop
parentheses accordingly. For an in-depth introduction, we refer to [Droste et al. 2009, Chapter 1,
2].

Deï¬nition A.5 (Monoids). A monoid W = (ğ‘Š , âŠ™, 1) consists of a carrier set ğ‘Š , an operation

âŠ™ : ğ‘Š Ã— ğ‘Š â†’ ğ‘Š , and an identity 1 âˆˆ ğ‘Š , such that for all ğ‘, ğ‘, ğ‘ âˆˆ ğ‘Š ,

(1) the operation âŠ™ is associative, i.e. ,

(2) 1 is an identity with respect to âŠ™, i.e. ,

ğ‘ âŠ™ (ğ‘ âŠ™ ğ‘) = (ğ‘ âŠ™ ğ‘) âŠ™ ğ‘ ,

and

ğ‘ âŠ™ 1 = 1 âŠ™ ğ‘ = ğ‘ .

The monoid W is commutative, if

(3) the operation âŠ™ is commutative:

ğ‘ âŠ™ ğ‘ = ğ‘ âŠ™ ğ‘ .

â–³

Deï¬nition A.6 (Semirings). A semiring S = (ğ‘†, âŠ•, âŠ™, 0, 1) consists of a carrier set ğ‘†, an addi-

tion âŠ• : ğ‘† Ã— ğ‘† â†’ ğ‘†, a multiplication âŠ™ : ğ‘† Ã— ğ‘† â†’ ğ‘†, a zero 0 âˆˆ ğ‘†, and a one 1 âˆˆ ğ‘†, such that

(1) (ğ‘†, âŠ•, 0) forms a commutative monoid,
(2) (ğ‘†, âŠ™, 1) forms a (possibly not-commutative) monoid,

and

and for all ğ‘, ğ‘, ğ‘ âˆˆ ğ‘†,

(3) multiplication distributes over addition, i.e. ,
ğ‘ âŠ™ (ğ‘ âŠ• ğ‘) = ğ‘ âŠ™ ğ‘ âŠ• ğ‘ âŠ™ ğ‘

and

(4) and multiplication by zero annihilates ğ‘†, i.e. ,

(ğ‘ âŠ• ğ‘) âŠ™ ğ‘ = ğ‘ âŠ™ ğ‘ âŠ• ğ‘ âŠ™ ğ‘,

Given a semiring S, we can construct a semiring of functions via point-wise lifting of the oper-

0 âŠ™ ğ‘ = ğ‘ âŠ™ 0 = 0.

â–³

ations.

Lemma A.7 (Semirings of Semiring-valued Functions). Let S = (ğ‘†, âŠ•S, âŠ™S, 0S, 1 S) be a
semiring and ğ‘‹ be a non-empty set. Then Sğ‘‹ â‰” (ğ‘†ğ‘‹ , âŠ•, âŠ™, 0, 1), where ğ‘†ğ‘‹ is the set of functions of
type ğ‘‹ â†’ ğ‘† and for all ğ‘“ , ğ‘” âˆˆ ğ‘†ğ‘‹ ,

ğ‘“ âŠ• ğ‘” â‰” ğœ† ğ‘¥ .
ğ‘“ âŠ™ ğ‘” â‰” ğœ† ğ‘¥ .
0 â‰” ğœ† ğ‘¥ .
1 â‰” ğœ† ğ‘¥ .

ğ‘“ (ğ‘¥) âŠ•S ğ‘”(ğ‘¥),
ğ‘“ (ğ‘¥) âŠ™S ğ‘”(ğ‘¥),
0S,
1 S ,

also forms a semiring which we call the lifting of S with respect to ğ‘‹ .

â–³

Weighted Programming

33

There is a canonical embedding ğ‘† â†’ ğ‘†ğ‘‹ , ğ‘ â†¦â†’ (ğœ† ğ‘¥ . ğ‘) mapping semiring elements in ğ‘† to constant
functions in ğ‘†ğ‘‹ . For better readability, we overload notation and identify elements ğ‘ with their
corresponding constant functions ğœ† ğ‘¥ . ğ‘, e.g. writing ğ‘ âŠ™ ğ‘“ instead of (ğœ† ğ‘¥ . ğ‘) âŠ™ ğ‘“ where ğ‘“ âˆˆ ğ‘†ğ‘‹ .

For our purpose of developing a weakest-precondition-style calculus for weighted programs,
we need to impose additional structure on our semirings; most essentially: an order, in particular
one which is compatible with the algebraic structure of the semiring. Let us, for the remainder of
this section, ï¬x an ambient semiring S = (ğ‘†, âŠ•, âŠ™, 0, 1).

Deï¬nition A.8 (Natural Order). The relation (cid:22) is deï¬ned for all ğ‘, ğ‘ âˆˆ ğ‘† by

ğ‘ (cid:22) ğ‘

iï¬€

âˆƒ ğ‘ âˆˆ ğ‘† :

ğ‘ âŠ• ğ‘ = ğ‘.

If (cid:22) is a partial order, then we call S naturally ordered and (cid:22) the natural order on ğ‘†.

â–³

Note that a presence of additive inverses (other than the self-inverse 0) prohibits the existence of
a natural order as antisymmetry is violated. Indeed, the relation (cid:22) degenerates to ğ‘† Ã— ğ‘† for rings.

Lemma A.9 (Least Elements and Monotonicity of Algebraic Operations [Rozenberg and

Salomaa 1997, Ch. 9, Thm. 2.1]). Let S be naturally ordered. Then,

(1) 0 is the unique least element, and
(2) âŠ• and âŠ™ are monotone, i.e. for all ğ‘, ğ‘, ğ‘ âˆˆ ğ‘†,

ğ‘ (cid:22) ğ‘

implies

ğ‘ âŠ• ğ‘ (cid:22) ğ‘ âŠ• ğ‘

and ğ‘ âŠ™ ğ‘ (cid:22) ğ‘ âŠ™ ğ‘

and ğ‘ âŠ™ ğ‘ (cid:22) ğ‘ âŠ™ ğ‘ .

If the natural order (cid:22) moreover has a greatest element, then this is unique and denoted âŠ¤S, where
we drop the subscript S whenever it is clear from the context.

The partial order can be lifted pointwise to functions in the spirit of Lemma A.7, i.e. a partial

order (cid:22) âŠ† ğ‘†ğ‘‹ Ã— ğ‘†ğ‘‹ on Sğ‘‹ is given by

ğ‘“ (cid:22) ğ‘”

iï¬€

âˆ€ğ‘¥ âˆˆ ğ‘‹ :

ğ‘“ (ğ‘¥) (cid:22) ğ‘”(ğ‘¥) .

Moreover, if (cid:22) is the natural order on S, then (cid:22) as deï¬ned above is the natural order on Sğ‘‹ . In
case of ğœ”-(co)cpos, joins âŠ” (meets âŠ“) are hence given by pointwise joins (meets).

Second, in order to apply ï¬xed point theory to semirings, we require some continuity con-

straints.

Deï¬nition A.10 (ğœ”-continuous semirings [Ã‰sik 2008, Def. 14]). A semiring S = (ğ‘†, âŠ•, âŠ™, 0, 1) is
ğœ”-continuous, if (ğ‘†, (cid:22)) is an ğœ”-cpo and addition and multiplication by constants are ğœ”-continuous
functions, i.e. for all ğ‘ âˆˆ ğ‘† and all ascending chains (ğ‘ğ‘–)ğ‘– âˆˆN in ğ‘†, we require

as well as

ğ‘ âŠ•

ğ‘ğ‘–

=

(ğ‘ âŠ• ğ‘ğ‘–)

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

ğ‘ âŠ™

ğ‘ğ‘–

=

(ğ‘ âŠ™ ğ‘ğ‘–)

and

ğ‘ğ‘– âŠ™ ğ‘

=

(ğ‘ğ‘– âŠ™ ğ‘) .

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

Dually, S is ğœ”-cocontinuous if (ğ‘†, (cid:22)) is an ğœ”-cocpo and addition/multiplication with constants are
â–³
ğœ”-cocontinuous functions. S is ğœ”-bicontinuous if it is both ğœ”-continuous and -cocontinuous.

Moreoever, it is clear that if S is ğœ”-(co)continuous, then the semiring Sğ‘‹ of functions from a set
ğ‘‹ to S (cf. Lemma A.7) is ğœ”-(co)continuous as well.

The ğœ”-continuity also allows to deï¬ne countably inï¬nite sums. Semirings that admit an inï¬nite
sum operation are called complete. We only consider the case of ğœ”-ï¬nitary semirings [Karner 1992,

34

Batz, Gallus, Kaminski, Katoen, and Winkler

Sec. 5], with respect to the natural order (cid:22), where such inï¬nite sums are deï¬ned as follows [Ã‰sik
2008, Thm. 19]: Given a family (ğ‘ğ‘– )ğ‘– âˆˆğ¼ in ğ‘† over a countable index set ğ¼ ,

ğ‘ğ‘– â‰”

ğ‘ğ‘– .

ÃŠğ‘– âˆˆğ¼

Ã„ğ¹ âŠ†ğ¼,
ğ¹ ï¬nite ÃŠğ‘– âˆˆğ¹

(4)

This deï¬nition enjoys two important properties: (i) If ğ¼ is ï¬nite, the value coincides with the
usual sum; (ii) the summation order is irrelevant by deï¬nition. In fact, if ğ¼ is inï¬nite it can be
shown [Rozenberg and Salomaa 1997, Ch. 9, Thm. 2.3], (Appendix B.2) that the right-hand side of
(4) is equal to the supremum of the partial sums associated with any arbitrary summation order,
i.e. for all N-indexed families (ğ‘ğ‘–)ğ‘– âˆˆN such that there exists a bijection ğœ : N â†’ ğ¼ with ğ‘ğ‘– = ğ‘ğœ (ğ‘–) for
all ğ‘– âˆˆ N we have

ğ‘ğ‘–

=

ğ‘ğ‘– .

(5)

ÃŠğ‘– âˆˆğ¼

Ã„ğ‘› âˆˆN

ÃŠğ‘– â‰¤ğ‘›

The latter formulation is used as deï¬nition of ğœ”-continuous semirings in [Kuich 1991]. It shows
ğ‘› âˆˆN is clearly an ğœ”-
that being an ğœ”-cpo already suï¬ƒces to deï¬ne inï¬nite sums since
chain.14 Moreover, it follows by ğœ”-continuity that the extended distributive laws are satisï¬ed: For
all ğ‘ âˆˆ ğ‘†,

ğ‘– â‰¤ğ‘› ğ‘ğ‘–

(cid:0)Ã‰

(cid:1)

ğ‘ âŠ™

=

ğ‘ğ‘–

!

ÃŠğ‘– âˆˆğ¼

ÃŠğ‘– âˆˆğ¼

ğ‘ âŠ™ ğ‘ğ‘–

and

âŠ™ ğ‘ =

ğ‘ğ‘–

!

ÃŠğ‘– âˆˆğ¼

ÃŠğ‘– âˆˆğ¼

ğ‘ğ‘– âŠ™ ğ‘ .

For an in-depth discussion of complete, ï¬nitary, and continuous semirings we refer to [Ã‰sik 2008;

Golan 2003; Goldstern 2002; Karner 1992, 2004; Kuich 1991; Rozenberg and Salomaa 1997].

A.3 Modules over Monoids

Like vector spaces over a ï¬eld, modules over rings, or semimodules over semirings we deï¬ne mod-
ules over monoids. Semimodules over semirings in the setting of weighted automata are studied
in [Droste et al. 2009]. The modules represent what our programs act on â€“ they are a required
generalization to study formal languages as Example B.2 shows. We present everything in parallel
to Appendix A.2.

Deï¬nition A.11 (Module over a Monoid). Let W = (ğ‘Š , âŠ™, 1) be a monoid. A (left) W-module
M = (ğ‘€, âŠ•, 0, âŠ—) is a commutative monoid (ğ‘€, âŠ•, 0) equipped with a (left) action called scalar
multiplication âŠ— : ğ‘Š Ã— ğ‘€ â†’ ğ‘€, such that

(1) the scalar multiplication âŠ— is associative, i.e. for all ğ‘, ğ‘ âˆˆ ğ‘Š and ğ‘£ âˆˆ ğ‘€,

(ğ‘ âŠ™ ğ‘) âŠ— ğ‘£ = ğ‘ âŠ— (ğ‘ âŠ— ğ‘£) ,

(2) the scalar multiplication âŠ— is distributive, i.e. for all ğ‘ âˆˆ ğ‘Š and ğ‘£, ğ‘¤ âˆˆ ğ‘€,

ğ‘ âŠ— (ğ‘£ âŠ• ğ‘¤) = (ğ‘ âŠ— ğ‘£) âŠ• (ğ‘ âŠ— ğ‘¤) ,
(3) the monoidâ€™s one 1 is neutral and the moduleâ€™s zero 0 annihilates, i.e. for all ğ‘ âˆˆ ğ‘Š and ğ‘£ âˆˆ ğ‘€,

1 âŠ— ğ‘£ = ğ‘£

and

ğ‘ âŠ— 0 = 0 .

â–³

To simplify language we speak of modules (and forget about the â€œover a monoidâ€ part); this should
not be confused with a module over a ring. We emphasize that all the results developed in this paper
apply to the important special case where the monoid and the module together form a semiring:
The multiplication âŠ™ of a semiring S = (ğ‘†, âŠ•, âŠ™, 0, 1) is then the left-action âŠ— : ğ‘† Ã— ğ‘† â†’ ğ‘† of the

14The converse also is true, e.g. ğœ”-ï¬nitary semirings with respect to the natural order (cid:22) are an ğœ”-cpo with respect to (cid:22)
[Kuich 1991, Thm. 2.3]. Their notion of ğœ”-continuous semiring is hence also equivalent to Deï¬nition A.10.

 
 
Weighted Programming

35

multiplicative monoid of (ğ‘†, âŠ™, 1) to the additive monoid (ğ‘†, âŠ•, 0). We also do not diï¬€erentiate
multiplication âŠ™ and left-action âŠ— and write âŠ™ instead of âŠ— from now on â€“ both are associative
and the operation should be clear from the rightmost multiplicantâ€™s type.

Analogous to Lemma A.7, we also can construct a module of functions via point-wise lifting of

the operations.

Lemma A.12 (Module of Module-valued Functions). Let M = (ğ‘€, âŠ•M, 0M, âŠ™M) be an W-
module and ğ‘‹ be a non-empty set. Then Mğ‘‹ â‰” (ğ‘€ğ‘‹ , âŠ•, 0, âŠ™), where ğ‘€ğ‘‹ is the set of functions of
type ğ‘‹ â†’ ğ‘€ and for all ğ‘ âˆˆ ğ‘Š , ğ‘¢, ğ‘£ âˆˆ ğ‘€ğ‘‹ ,

ğ‘¢ âŠ• ğ‘£ â‰” ğœ† ğ‘¥ . ğ‘¢ (ğ‘¥) âŠ•M ğ‘£ (ğ‘¥) ,
ğ‘ âŠ™ ğ‘£ â‰” ğœ† ğ‘¥ .
0 â‰” ğœ† ğ‘¥ .

ğ‘ âŠ™M ğ‘£ (ğ‘¥) ,
0M ,

also forms a W-module which we call the lifting of M with respect to ğ‘‹ .

â–³

Analogous to Deï¬nition A.8, we speak of naturally ordered modules M.

Deï¬nition A.13 (Natural Order). The relation (cid:22) is deï¬ned for all ğ‘, ğ‘ âˆˆ ğ‘€ by

ğ‘ (cid:22) ğ‘

iï¬€

âˆƒ ğ‘ âˆˆ ğ‘€ :

ğ‘ âŠ• ğ‘ = ğ‘.

If (cid:22) is a partial order, then we call M naturally ordered and (cid:22) the natural order on M.

â–³

Similar to Lemma A.9, we have for modules:

Lemma A.14 (Least Elements and Monotonicity of Algebraic Operations). Let M be nat-

urally ordered. Then,

(1) 0 is the unique least element, and
(2) âŠ• and âŠ™ are monotone, i.e. for all ğ‘ âˆˆ ğ‘† and ğ‘¢, ğ‘£, ğ‘¤ âˆˆ ğ‘€,

ğ‘£ (cid:22) ğ‘¤

implies

ğ‘¢ âŠ• ğ‘£ (cid:22) ğ‘¢ âŠ• ğ‘¤ and ğ‘ âŠ™ ğ‘£ (cid:22) ğ‘ âŠ™ ğ‘¤ .

Proof. The ï¬rst two statements directly follow from the natural order. For the last one, distribu-
(cid:3)

tivity is additionally required.

If the natural order (cid:22) moreover has a greatest element, then this is unique and denoted âŠ¤M, where
we drop the subscript M whenever it is clear from the context.

As for semirings, we also want to apply ï¬xed point theory to modules. Inspired by Deï¬ni-

tion A.10, we deï¬ne the following notion of ğœ”-continuous modules.

Deï¬nition A.15 (ğœ”-continuous module). A W-module M is ğœ”-continuous, if (ğ‘€, (cid:22)) is an ğœ”-cpo
and addition and scalar multiplication with constants are ğœ”-continuous functions, i.e. for all ğ‘ âˆˆ ğ‘Š ,
ğ‘¢ âˆˆ ğ‘€ and all ascending chains (ğ‘£ğ‘– )ğ‘– âˆˆN in ğ‘€, we require

ğ‘¢ âŠ•

ğ‘£ğ‘–

=

( ğ‘ âŠ• ğ‘£ğ‘– )

and

ğ‘ âŠ™

ğ‘£ğ‘–

=

( ğ‘ âŠ™ ğ‘£ğ‘– ) .

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

Dually, M is ğœ”-cocontinuous if (ğ‘€, (cid:22)) is an ğœ”-cocpo and addition/scalar multiplication with con-
stants are ğœ”-cocontinuous functions. M is ğœ”-bicontinuous if it is both ğœ”-continuous and -cocontinuous.
â–³

Moreover, if M is ğœ”-(co)continuous, then the module Mğ‘‹ of functions from a set ğ‘‹ to M (cf.
Lemma A.12) is ğœ”-(co)continuous as well.

36

Batz, Gallus, Kaminski, Katoen, and Winkler

As for semirings, ğœ”-continuity allows to deï¬ne countably inï¬nite sums. We call a module ğœ”-
ï¬nitary if the inï¬nite sum is deï¬ned as follows: Given a family (ğ‘£ğ‘–)ğ‘– âˆˆğ¼ in ğ‘€ over a countable index
set ğ¼ ,

ğ‘£ğ‘– â‰”

ğ‘£ğ‘– â‰”

ÃŠğ‘– âˆˆğ¼

ğ¹ ï¬nite ÃŠğ‘– âˆˆğ¹
Ã„ğ¹ âŠ†ğ¼,

ğ‘¤ğ‘– ,

Ã„ğ‘› âˆˆN

ÃŠğ‘– â‰¤ğ‘›

(6)

where (ğ‘ğ‘–)ğ‘– âˆˆN is any N-indexed family such that there exists a bijection ğœ : N â†’ ğ¼ with ğ‘ğ‘– = ğ‘ğœ (ğ‘–)
for all ğ‘– âˆˆ N. Again, from ğœ”-continuity it follows that an extended distributive law is satisï¬ed: For
all ğ‘ âˆˆ ğ‘Š ,

ğ‘ âŠ™

=

ğ‘£ğ‘–

!

ÃŠğ‘– âˆˆğ¼

ÃŠğ‘– âˆˆğ¼

ğ‘ âŠ™ ğ‘£ğ‘–

 
Weighted Programming

37

B PROOFS OF PRELIMINARIES A
B.1 Proof of Theorem A.4

We only show Item 1 which implies Item 2 by reversing the order. The ï¬rst part of Item 1 is
simply an instance of the classic Kleene Fixed Point Theorem. The second partâ€”the Park Induction
principleâ€”can be seen as follows. First we show by induction that ğ‘“ ğ‘› (âŠ¥) (cid:22) ğ‘ for all ğ‘› âˆˆ N: For
ğ‘› = 0 we have ğ‘“ 0(âŠ¥) = âŠ¥ (cid:22) ğ‘. For ğ‘› â‰¥ 0, we have by the I.H. and monotonicity of ğ‘“ that

ğ‘“ ğ‘›+1(âŠ¥)

=

ğ‘“ (ğ‘“ ğ‘› (âŠ¥))

(cid:22)

ğ‘“ (ğ‘)

(cid:22)

ğ‘ .

By Kleene Fixpoint Theorem and the deï¬nition of suprema it follows that

lfp ğ‘“

=

ğ‘“ ğ‘› (âŠ¥)

(cid:22)

ğ‘ .

(cid:3)

Ã„ğ‘› âˆˆN

B.2 Proof that Eq. 4 and Eq. 5 (notions of ğ-finitary) coincide

Lemma B.1. Let S = (ğ‘†, âŠ•, âŠ™, 0, 1) be an ğœ”-continuous semiring, (ğ‘ğ‘– )ğ‘– âˆˆğ¼ a family in ğ‘† over a
countably inï¬nite index set ğ¼ , and (ğ‘ ğ‘— ) ğ‘— âˆˆN a family in ğ‘† such that there exists a bijection ğœ : N â†’ ğ¼
with ğ‘ ğ‘— = ğ‘ğœ ( ğ‘—) for all ğ‘— âˆˆ N. Then,

ğ‘ğ‘–

=

ğ‘ğ‘–

=

ğ‘ ğ‘— .

ÃŠğ‘– âˆˆğ¼

ğ¹ ï¬nite ÃŠğ‘– âˆˆğ¹
Ã„ğ¹ âŠ†ğ¼,

Ã„ğ‘› âˆˆN

ÃŠğ‘— â‰¤ğ‘›

In particular,

ğ‘– âˆˆğ¼ ğ‘ğ‘– is well-deï¬ned and Eq. (4) is compatible to Eq. (5).

Proof. First, as (

Ã‰

ğ‘— â‰¤ğ‘› ğ‘ ğ‘— )ğ‘› âˆˆN is an ğœ”-chain under the natural order (cid:22). Thus the supremum is

well deï¬ned in the ğœ”-continuous semiring.
Ã‰

Next, let ğ¹ âŠ† ğ¼ be a ï¬nite subset. We denote the image of ğ¹ under ğœ as ğœ (ğ¹ ) â‰” { ğœ (ğ‘–) | ğ‘– âˆˆ ğ¹ }.
Next, deï¬ne the maximal index ğ‘›ğ¹ â‰” max ğœ (ğ¹ ) âˆˆ N corresponding to ğ¹ (with respect to ğœ). Then,
we get the partition

{ ğ‘— âˆˆ N | 0 â‰¤ ğ‘— â‰¤ ğ‘›ğ¹ }

=

ğœ (ğ¹ ) âŠ { ğ‘— âˆˆ N | ğ‘— â‰¤ ğ‘›ğ¹ , ğ‘— âˆ‰ ğœ (ğ¹ ) } .

By deï¬nition of the natural order (cid:22) it follows

ğ‘ğ‘– =

ğ‘ğœ (ğ‘–) =

ğ‘ ğ‘—

(cid:22)

ğ‘ ğ‘— âŠ•

ğ‘ ğ‘— =

ğ‘ ğ‘—

(cid:22)

ğ‘ ğ‘— ,

ÃŠğ‘– âˆˆğ¹

ÃŠğ‘– âˆˆğ¹

ÃŠğ‘— âˆˆğœ (ğ¹ )

ÃŠğ‘— âˆˆğœ (ğ¹ )

ÃŠğ‘— â‰¤ğ‘›ğ¹
ğ‘—âˆ‰ğœ (ğ¹ )

ÃŠğ‘— â‰¤ğ‘›ğ¹

Ã„ğ‘› âˆˆN

ÃŠğ‘— â‰¤ğ‘›

and hence (if the left supremum exists)

ğ‘ğ‘–

(cid:22)

ğ‘ ğ‘— .

ğ¹ ï¬nite ÃŠğ‘– âˆˆğ¹
Ã„ğ¹ âŠ†ğ¼,

Ã„ğ‘› âˆˆN

ÃŠğ‘— â‰¤ğ‘›

On the other hand, we denote for ğ‘› âˆˆ N the preimage of Â¯ğ‘› â‰” { ğ‘— âˆˆ N | 0 â‰¤ ğ‘— â‰¤ ğ‘› } under ğœ as

ğ¹ğ‘› â‰” { ğ‘– âˆˆ ğ¹ | ğœ (ğ‘–) â‰¤ ğ‘› }. As this always is a ï¬nite subset of ğ¼ ,

ğ‘ ğ‘— =

ğ‘ğœ âˆ’1 ( ğ‘—) =

ğ‘ğ‘–

(cid:22)

ğ‘ğ‘– .

Ã„ğ‘› âˆˆN

ÃŠğ‘— â‰¤ğ‘›

Ã„ğ‘› âˆˆN

ÃŠğ‘— â‰¤ğ‘›

Ã„ğ‘› âˆˆN

ÃŠğ‘– âˆˆğ¹ğ‘›

ğ¹ ï¬nite ÃŠğ‘– âˆˆğ¹
Ã„ğ¹ âŠ†ğ¼,

Combining both inequalities, we obtain exactly the equality claimed above.

(cid:3)

38

Batz, Gallus, Kaminski, Katoen, and Winkler

B.3 Problems with the Semiring of infinite words
In order to extend LÎ“ with ğœ”-words (i.e. words of countably inï¬nite length) to obtain a semiring
of mixed languages, i.e. subsets of Î“âˆ = Î“âˆ— âˆª Î“ğœ” , one might be tempted to deï¬ne the concatenation
of languages ğ¿1, ğ¿2 âŠ† Î“âˆ— âˆª Î“ğœ” as follows: Partition ğ¿1 = ğ¾1 âˆª ğ‘€1 where ğ¾1 âŠ† Î“âˆ— are the ï¬nite and
ğ‘€1 âŠ† Î“ğœ” are the ğœ”-words of ğ¿1. We set

ğ¿1 Â· ğ¿2 â‰”

ğ¾1 Â· ğ¿2 âˆª ğ‘€1
âˆ…

(

if ğ¿2 â‰  âˆ… ,
if ğ¿2 = âˆ… .

Intuitively, concatenating ğœ”-words from the left is absorptive. This way, (2Î“âˆ—âˆªÎ“ğœ”
, âˆª, Â·, âˆ…, { ğœ– })
indeed is a ğœ”-continuous semiring. However, the multiplication Â· is not ğœ”-cocontinuos as the fol-
lowing example shows.

Example B.2 (Counterexample). Consider the singular alphabet Î“ = { ğ‘ }. Deï¬ne the descending

ğœ”-chain (ğ¿ğ‘›)ğ‘› âˆˆN where ğ¿ğ‘› â‰”

ğ‘ğ‘–

ğ‘– â‰¥ ğ‘›

. Then,

(cid:8)
Â· { ğ‘ğœ” }

(cid:12)
(cid:12)
=

ğ¿ğ‘›

l
ğ‘› âˆˆN

!

(cid:9)

Ã™ğ‘› âˆˆN

ğ¿ğ‘›

!

On the other hand,

Â· { ğ‘ğœ” }

=

âˆ… Â· { ğ‘ğœ” }

=

âˆ… .

l
ğ‘› âˆˆN

(ğ¿ğ‘› Â· { ğ‘ğœ” })

=

(ğ¿ğ‘› Â· { ğ‘ğœ” })

=

{ ğ‘ğœ” }

=

{ ğ‘ğœ” } .

Ã™ğ‘› âˆˆN

Ã™ğ‘› âˆˆN

Hence, Â· is not ğœ”-cocontinuos.

Even as a semimodule multiplication with a semiring element would not be ğœ”-cocontinuos. An
approach to resolve this problem is the notion of star semiring - omega semimodule pairs or quemir-
ings [Droste et al. 2009, Ch. 3]. Using semirings has the beneï¬t that it allows to study matricial
theories [Droste et al. 2009, Ch. 1 & 2].

Alternatively, we have the following approach. Consider the alphabet Î“. We obtain the word
Î“ â‰” () over

monoid Î“âˆ— = (Î“âˆ—, Â·, ğœ–) where Â· is the usual concatenation. Next, we deï¬ne a module Lâˆ
this monoid.

Î“ is a ğœ”-bicontinuous module

B.4 Proof that Lâˆ
Let Î“ be a non-empty alphabet. The word monoid is Î“âˆ— = (Î“âˆ—, Â·, ğœ–), where Â· is the usual con-
catenation and ğœ– is the empty word. As a shorthand denote Î“âˆ â‰” Î“âˆ— âˆª Î“ğœ” . For a word ğ‘£ âˆˆ Î“âˆ—
(from the monoid) and a formal language ğ¿ âŠ† Î“âˆ (from the module) we deï¬ne their concatenation
ğ‘£ Â· ğ¿ â‰” { ğ‘£ğ‘¤ | ğ‘¤ âˆˆ ğ¿ } as usual. Clearly, the module of mixed languages Lâˆ
, âˆª, âˆ…, Â·) is a
module over this monoid.

Î“ â‰” (2Î“âˆ

Claim. This module is ğœ”-bicontinuous.

Proof. The natural order (cid:22) simply is set inclusion âŠ† of languages. The inï¬mum âŠ“ of a descend-
ing ğœ”-chain simply is the intersection âˆ©, and the supremum âŠ” of an ascending ğœ”-chain simply
is the union âˆª, i.e. subsets of Î“âˆ by deï¬nition. Let (ğ´ğ‘– )ğ‘– âˆˆN be an ascending ğœ”-chain (ğ´ğ‘– âŠ† ğ´ğ‘–+1),
(ğ·ğ‘– )ğ‘– âˆˆN be an descending ğœ”-chain (ğ·ğ‘– âŠ‡ ğ·ğ‘–+1), ğ¿ âŠ† Î“âˆ, and ğ‘£ âˆˆ Î“âˆ— then

â€¢ Clearly, addition âˆª is ğœ”-continuous:

ğ¿ âˆª

ğ´ğ‘–

=

(ğ¿ âˆª ğ´ğ‘– ) .

Ã˜ğ‘– âˆˆN

Ã˜ğ‘– âˆˆN

 
 
Weighted Programming

39

â€¢ Also, addition âˆª is ğœ”-cocontinuous:

ğ¿ âˆª

ğ·ğ‘–

=

(ğ¿ âˆª ğ·ğ‘– ) .

â€¢ More interestingly, scalar multiplication Â· also is ğœ”-continuous:

Ã™ğ‘– âˆˆN

Ã™ğ‘– âˆˆN

Ã˜ğ‘– âˆˆN

ğ‘£ Â·

ğ´ğ‘–

=

ğ‘£ Â· ğ´ğ‘– .

ğ‘– âˆˆN ğ´ğ‘– , then there is an ğ‘¢ âˆˆ
Let ğ‘¤ âˆˆ ğ‘£ Â·
with ğ‘¢ âˆˆ ğ´ğ‘– and hence ğ‘¤ = ğ‘£ğ‘¢ âˆˆ ğ‘£ Â· ğ´ğ‘–.
On the other hand, let ğ‘¤ âˆˆ
ğ‘¢ âˆˆ ğ´ğ‘— . But this implies ğ‘¢ âˆˆ

Ã

Ã˜ğ‘– âˆˆN

ğ‘– âˆˆN ğ´ğ‘– such that ğ‘¤ = ğ‘£ğ‘¢. But then there is an ğ‘– âˆˆ N

Ã

ğ‘– âˆˆN ğ‘£ Â· ğ´ğ‘– , then there is an ğ‘— âˆˆ N such that ğ‘¤ = ğ‘£ğ‘¢ for some
ğ‘– âˆˆN ğ´ğ‘– and hence ğ‘¤ = ğ‘£ğ‘¢ âˆˆ ğ‘£ Â·

ğ‘– âˆˆN ğ´ğ‘–.

â€¢ Finally, scalar multiplication Â· is ğœ”-cocontinuous:15

Ã
Ã
ğ‘£ Â·

ğ·ğ‘–

=

ğ‘£ Â· ğ·ğ‘– .

Ã

Ã™ğ‘– âˆˆN

ğ‘– âˆˆN ğ·ğ‘– , then there is an ğ‘¢ âˆˆ

Let ğ‘¤ âˆˆ ğ‘£ Â·
hence ğ‘¤ = ğ‘£ğ‘¢ âˆˆ ğ‘£ Â· ğ·ğ‘– for all ğ‘– âˆˆ N.
Ã‘
On the other hand, let ğ‘¤ âˆˆ
But as ğ‘¤ is ï¬xed, this implies ğ‘¢ğ‘– = ğ‘¢ ğ‘— for all ğ‘–, ğ‘— âˆˆ N. Hence, there is an ğ‘¢ = ğ‘¢1 âˆˆ
with ğ‘¤ = ğ‘£ğ‘¢, i.e. ğ‘£ Â·

ğ‘– âˆˆN ğ‘£ Â· ğ·ğ‘– . Then, there is an ğ‘¢ğ‘– âˆˆ ğ¿ğ‘– with ğ‘¤ = ğ‘£ğ‘¢ğ‘– for all ğ‘– âˆˆ N.
ğ‘– âˆˆN ğ·ğ‘–

Ã‘

Ã‘

Ã™ğ‘– âˆˆN
ğ‘– âˆˆN ğ·ğ‘– such that ğ‘¤ = ğ‘£ğ‘¢. But then ğ‘¢ âˆˆ ğ·ğ‘– and

ğ‘– âˆˆN ğ·ğ‘– .

Ã‘

(cid:3)

Ã‘

15This is in general false if one were to allow languages (as opposed to single words) on the left hand side, i.e. ğ¿1 Â· ğ¿2 for
ğ¿1 âŠ‚ Î“âˆ— and ğ¿2 âŠ‚ Î“âˆ

40

Batz, Gallus, Kaminski, Katoen, and Winkler

C PROOFS OF SECTION 4
First of all, note that [ğœ‘] distributes of âŠ•: Let ğ‘“ , ğ‘” âˆˆ W and ğœ âˆˆ Î£.

â€¢ Case ğœ |= ğœ‘.

( [ğœ‘] (ğ‘“ âŠ• ğ‘”)) (ğœ) = ğ‘“ (ğœ) âŠ• ğ‘”(ğœ) = ( [ğœ‘] ğ‘“ ) (ğœ) âŠ• ( [ğœ‘] ğ‘“ ) (ğœ) = ( [ğœ‘] ğ‘“ âŠ• [ğœ‘] ğ‘”)) (ğœ)

â€¢ Case ğœ 6|= ğœ‘.

( [ğœ‘] (ğ‘“ âŠ• ğ‘”)) (ğœ) = 0 = 0(ğœ) âŠ• 0(ğœ) = ( [ğœ‘] ğ‘“ ) (ğœ) âŠ• ( [ğœ‘] ğ‘“ ) (ğœ) = ( [ğœ‘] ğ‘“ âŠ• [ğœ‘] ğ‘”) (ğœ)

C.1 Proof of Theorem 4.7
We will use the following:

Lemma C.1. Let (ğ‘ğ‘– )ğ‘– âˆˆN and (ğ‘ğ‘–)ğ‘– âˆˆN be ascending ğœ”-chains in an ğœ”-continuous module M. Then

(ğ‘ğ‘– âŠ• ğ‘ğ‘–) =

ğ‘ğ‘– âŠ•

ğ‘ğ‘– .

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

â–³

Proof. Follows because addition with constants is ğœ”-continuous (see Deï¬nition A.15) and ap-
(cid:3)

plying e.g. [Abramsky 1994, Ch. Domain Theory, Lem. 3.2.6].

Theorem C.2 (Theorem 4.7). Let the monoid module M over W be ğœ”-continuous. For all W-
: W â†’ W
wGCL programs ğ¶ and ğœ”-continuous W-modules M the weighting transformer wp
is a well-deï¬ned ğœ”-continuous function. If ğ¶ is of the form while ( ğœ‘ ) { ğ¶ â€² }, the least ï¬xed point is

ğ¶
J

K

( ğ‘“ )

=

wp

ğ¶
J

K

Î¦ğ‘–
ğ‘“ (0) .

Ã„ğ‘– âˆˆN

â–³

Proof. We employ induction on the structure of ğ¶. Let (ğ‘“ğ‘– )ğ‘– âˆˆN be an ascending ğœ”-chain in W.

Because M and W are ğœ”-continuous mondules, all the following joins exist.

The following forms the induction base.

Weighted Programming

41

â€¢ The program ğ¶ is of the form ğ‘¥ â‰” ğ¸.

wp

ğ¶
J

ğ‘“ğ‘–

!

K  

Ã„ğ‘– âˆˆN

=

ğ‘“ğ‘–

[ğ‘¥/ğ¸]

(cid:16) Ã„ğ‘– âˆˆN

(cid:17)

= ğœ† ğœ.

ğ‘“ğ‘–

ğœ [ğ‘¥ â†¦â†’ ğœ (ğ¸)]

(cid:1)

(cid:1)(cid:17)

(cid:1)(cid:17)

(cid:16) Ã„ğ‘– âˆˆN

(cid:17) (cid:0)

= ğœ† ğœ.

ğ‘“ğ‘–

ğœ [ğ‘¥ â†¦â†’ ğœ (ğ¸)]

Ã„ğ‘– âˆˆN

(cid:16)

(cid:0)

=

=

=

ğœ† ğœ. ğ‘“ğ‘–

ğœ [ğ‘¥ â†¦â†’ ğœ (ğ¸)]

Ã„ğ‘– âˆˆN

(cid:16)

(cid:0)

(ğ‘“ğ‘– [ğ‘¥/ğ¸])

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

wp

ğ¶
J

K

( ğ‘“ğ‘– )

(Def. of wp)

(Def. of [ğ‘¥/ğ¸])

(Def. of

(Def. of

)

)

Ãƒ

Ãƒ

(Def. of [ğ‘¥/ğ¸])

(Def. of wp)

â€¢ The program ğ¶ is of the form âŠ™ ğ‘. This is an immediate consequence of Lemma A.3 and the

ğœ”-continuity of âŠ™.

wp

ğ¶
J

ğ‘“ğ‘–

!

K  

Ã„ğ‘– âˆˆN

= ğ‘ âŠ™

=

=

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

ğ‘“ğ‘–

(cid:16) Ã„ğ‘– âˆˆN

(cid:17)

(ğ‘ âŠ™ ğ‘“ğ‘– )

wp

ğ¶
J

K

( ğ‘“ğ‘– )

(Def. of wp)

(âŠ™ is ğœ”-continuous in the second argument)

(Def. of wp)

The following forms the induction step. Hence, for each deconstruction of ğ¶, we assume both
to be ğœ”-continuous as our inductionâ€™s hypothesis. Notice that the subpro-

and wp

wp
grams ğ¶1, ğ¶2, ğ¶ â€² are always shorter than ğ¶.
K

ğ¶2
J

ğ¶1
J

K

42

Batz, Gallus, Kaminski, Katoen, and Winkler

â€¢ The program ğ¶ is of the form ğ¶1

ğ¶2. This is an immediate consequence of Lemma A.3.

#

wp

ğ¶
J

ğ‘“ğ‘–

!

K  

Ã„ğ‘– âˆˆN

= wp

wp

ğ¶1
J

K  

ğ¶2
J

ğ‘“ğ‘–

! !

K  

Ã„ğ‘– âˆˆN

= wp

ğ¶1
J

K  

Ã„ğ‘– âˆˆN

wp

ğ¶2
J

K

( ğ‘“ğ‘– )

!

=

=

Ã„ğ‘– âˆˆN

Ã„ğ‘– âˆˆN

wp

ğ¶1
J

K

( wp

ğ¶2
J

K

( ğ‘“ğ‘– ) )

wp

ğ¶
J

K

( ğ‘“ğ‘– )

(Def. of wp)

(Induction Hypothesis)

(Induction Hypothesis)

(Def. of wp)

â€¢ The program ğ¶ is of the form if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }. This is an immediate consequence

of Lemma A.3 and the moduleâ€™s ğœ”-continuity.

wp

ğ¶
J

ğ‘“ğ‘–

!

K  

Ã„ğ‘– âˆˆN

(Def. of wp)

= [ğœ‘] wp

ğ¶1
J

K  

Ã„ğ‘– âˆˆN

ğ‘“ğ‘–

!

âŠ• [Â¬ğœ‘] wp

ğ¶2
J

K  

Ã„ğ‘– âˆˆN

ğ‘“ğ‘–

!

(Induction Hypothesis)

= [ğœ‘]

wp

ğ¶1
J

K

(cid:16) Ã„ğ‘– âˆˆN

( ğ‘“ğ‘– )

âŠ• [Â¬ğœ‘]

(cid:17)

wp

ğ¶2
J

K

(cid:16) Ã„ğ‘– âˆˆN

( ğ‘“ğ‘– )

(cid:17)

(0, âŠ¤ are ğœ”-continuous)

=

=

=

[ğœ‘] wp

ğ¶1
J

K

(cid:16) Ã„ğ‘– âˆˆN

( ğ‘“ğ‘– )

âŠ•

(cid:17)

(cid:16) Ã„ğ‘– âˆˆN

[Â¬ğœ‘] wp

( ğ‘“ğ‘– )

ğ¶2
J
(âŠ• is ğœ”-continuous, Lemma C.1)

K

(cid:17)

( ğ‘“ğ‘– ) âŠ• [Â¬ğœ‘] wp

( ğ‘“ğ‘– )

ğ¶2
J

K

(cid:1)

(Def. of wp)

[ğœ‘] wp

ğ¶1
J

K

Ã„ğ‘– âˆˆN

(cid:0)

wp

ğ¶
J

K

( ğ‘“ğ‘– )

Ã„ğ‘– âˆˆN

Weighted Programming

43

â€¢ The program ğ¶ is of the form { ğ¶1 } âŠ• { ğ¶2 }. This is an immediate consequence of Lemma A.3

and the ğœ”-continuity of âŠ•.

wp

ğ¶
J

ğ‘“ğ‘–

!

K  

Ã„ğ‘– âˆˆN

= wp

ğ¶1
J

K  

Ã„ğ‘– âˆˆN

ğ‘“ğ‘–

!

âŠ• wp

ğ¶2
J

K  

Ã„ğ‘– âˆˆN

ğ‘“ğ‘–

!

(Def. of wp)

(Induction Hypothesis)

=

=

=

wp

ğ¶1
J

K

(cid:16) Ã„ğ‘– âˆˆN

( ğ‘“ğ‘– )

âŠ•

(cid:17)

(cid:16) Ã„ğ‘– âˆˆN

wp

ğ¶2
J

( ğ‘“ğ‘– )

K
(âŠ• is ğœ”-continuous, Lemma C.1)

(cid:17)

wp

ğ¶1
J

K

Ã„ğ‘– âˆˆN

(cid:0)

( ğ‘“ğ‘– ) âŠ• wp

( ğ‘“ğ‘– )

ğ¶2
J

K

(cid:1)

wp

ğ¶
J

K

( ğ‘“ğ‘– )

Ã„ğ‘– âˆˆN

(Def. of wp)

â€¢ The program ğ¶ is of the form while ( ğœ‘ ) { ğ¶ â€² }. First we show the loop-characteristic func-

tion

Î¦ğ‘“ : W â†’ W,

ğ‘” â†¦â†’ [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp

( ğ‘” )

ğ¶ â€²
J

K

to be ğœ”-continuous in both ğ‘“ and its argument ğ‘”.

Î¦

ğ‘–âˆˆN ğ‘“ğ‘–

Ãƒ

= ğœ† ğ‘”. [Â¬ğœ‘]

ğ‘“ğ‘–

âŠ• [ğœ‘] wp

(cid:16) Ã„ğ‘– âˆˆN

(cid:17)

= ğœ† ğ‘”.

[Â¬ğœ‘] ğ‘“ğ‘–

âŠ• [ğœ‘] wp

(cid:16) Ã„ğ‘– âˆˆN

(cid:17)

( ğ‘” )

ğ¶ â€²
J

K

( ğ‘” )

ğ¶ â€²
J

K

( ğ‘” )

ğ¶ â€²
J

K

( ğ‘” )

ğ¶ â€²
J

K

(cid:17)

(cid:17)

= ğœ† ğ‘”.

[Â¬ğœ‘] ğ‘“ğ‘– âŠ• [ğœ‘] wp

Ã„ğ‘– âˆˆN

(cid:16)

=

=

ğœ† ğ‘”. [Â¬ğœ‘] ğ‘“ğ‘– âŠ• [ğœ‘] wp

Ã„ğ‘– âˆˆN

(cid:16)

Î¦ğ‘“ğ‘–

Ã„ğ‘– âˆˆN

(Def. of Î¦ğ‘“ )

(0, âŠ¤ are ğœ”-continuous)

(âŠ• is ğœ”-continuous)

(Def. of âŠ” on SW)

(Def. of Î¦ğ‘“ )

44

Batz, Gallus, Kaminski, Katoen, and Winkler

Let (ğ‘”ğ‘– )ğ‘– âˆˆN be an (ascending) ğœ”-chain in W.

Î¦ğ‘“

ğ‘”ğ‘–

(cid:16) Ã„ğ‘– âˆˆN

(cid:17)

= [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp

ğ¶ â€²
J

ğ‘”ğ‘–

!

K  

Ã„ğ‘– âˆˆN

= [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘]

wp

ğ¶ â€²
J

K

( ğ‘”ğ‘– )

(cid:16) Ã„ğ‘– âˆˆN

= [Â¬ğœ‘] ğ‘“ âŠ•

[ğœ‘] wp

Ã„ğ‘– âˆˆN

(cid:0)

=

=

[Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp

Ã„ğ‘– âˆˆN

(cid:0)

Î¦ğ‘“ (ğ‘”ğ‘– )

( ğ‘”ğ‘– )

ğ¶ â€²
J

K

( ğ‘”ğ‘– )

ğ¶ â€²
J

K

(cid:17)

(cid:1)

(cid:1)

(Def. of Î¦ğ‘“ )

(Induction Hypothesis)

(0, âŠ¤ are ğœ”-continuous)

(âŠ• is ğœ”-continuous)

(Def. of Î¦ğ‘“ )

Ã„ğ‘– âˆˆN

while ( ğœ‘ ) { ğ¶ â€² }
( ğ‘“ ) is well deï¬ned and equals the
By Theorem A.4 the ï¬xed point wp
claimed expression. It is ğœ”-continuous in ğ‘“ by ğœ”-continuity of ğ‘“ â†¦â†’ Î¦ğ‘“ and the ï¬xed-point
J
operator lfp, e.g. [Abramsky 1994, Ch. Domain Theory, Thm. 2.1.19].

K

C.2 Proof of Theorem 4.9 (Soundness of wp w.r.t. operational semantics)

The following proof is based on [Batz et al. 2019b, Appendix B].

Theorem C.3 (Theorem 4.9). Let the monoid module M over W be ğœ”-continuous. For any wGCL

program ğ¶, initial state ğœ âˆˆ Î£, and post-weighting ğ‘“ âˆˆ W,

(cid:3)

( ğ‘“ ) (ğœ)

=

wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹)) .

wp

ğ¶
J

K

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i
Proof. We use a few auxiliary deï¬nitions and lemmas that can be found below. By Lemma C.7
Ëœwp also is a wGCL-functional due to Lemma C.8, we get
Ëœwp (cid:22) Ëœop by Lemma C.11. Both imply Ëœwp = Ëœop. Now, wp = op due to
(cid:3)

Ëœop is the least wGCL-functional. As
Ëœop (cid:22) Ëœwp. On the other hand,
Deï¬nition C.4. This is the above claim by Deï¬nition C.6.

Deï¬nition C.4. A map Î¦ : wGCL â†’ (W â†’ W) is called weighting transformer. The correspond-

ing extended weighting transformer ËœÎ¦ : (wGCL âˆª { â†“ }) â†’ (W â†’ W) is deï¬ned via

( ğ‘“ ) â‰”

ËœÎ¦

ğ¶
J

ğ‘“
Î¦

if ğ¶ = â†“
otherwise

ğ¶
J
for all ğ¶ âˆˆ wGCL âˆª { â†“ } and ğ‘“ âˆˆ W. Deï¬ne the partial order (cid:22) for weighting transformers Î¦, Î¨
via

(

K

K

( ğ‘“ )

ËœÎ¦ (cid:22) ËœÎ¨

iï¬€

( ğ‘“ ) (cid:22) Î¨

Î¦

ğ¶
J

K

ğ¶
J

K

( ğ‘“ ) for all ğ¶ âˆˆ wGCL, ğ‘“ âˆˆ W .

â–³

Weighted Programming

45

Deï¬nition C.5. An extended weighting transformer ËœÎ¦ is called wGCL-functional if for all wGCL

programs ğ¶, postweightings ğ‘“ âˆˆ W, states ğœ âˆˆ Î£, ğ‘› âˆˆ N, and ğ›½ âˆˆ { ğ¿, ğ‘… }âˆ—,

ËœÎ¦

ğ¶
J

K

( ğ‘“ ) (ğœ)

=

ğ‘ âŠ™ ËœÎ¦

( ğ‘“ ) (ğœ â€²) .

â–³

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i
Deï¬nition C.6. The map op : wGCL â†’ (W â†’ W) is deï¬ned for any wGCL program ğ¶, state

ğ¶ â€²
J

K

ğœ âˆˆ Î£, and post-weighting ğ‘“ âˆˆ W via

( ğ‘“ ) (ğœ) â‰”

wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹)) .

â–³

op

ğ¶
J

K

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, 0, ğœ–i
Lemma C.7. The map Ëœop is the least wGCL-functional.

Proof. First, we show that

Ëœop is a wGCL-functional. Given a conï¬guration ğœ…0 = hğ¶, ğœ, ğ‘›, ğ›½i,

where ğ¶ is a wGCL program and ğœ âˆˆ Î£ a state, we have

=

=

=

=

=

=

( ğ‘“ ) (ğœ)

Ëœop

ğ¶
J

K

wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹))

ÃŠğœ‹ âˆˆTPathsğœ…0

(wgt(ğœ…0 ğœ…1) âŠ™ wgt(ğœ…1 . . . ğœ…ğ‘˜ )) âŠ™ ğ‘“ (last(ğœ…1 . . . ğœ…ğ‘˜ ))

ÃŠğœ…0ğœ…1...ğœ…ğ‘˜ âˆˆTPathsğœ…0

ğœ…0 âŠ¢ğ‘ ğœ…1 ÃŠğœ‹ âˆˆTPathsğœ…1
ÃŠ

ğ‘ âŠ™ wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹))

ğ‘ âŠ™

wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹))

ğœ…0 âŠ¢ğ‘ ğœ…1
ÃŠ

ÃŠğœ‹ âˆˆTPathsğœ…1

(Def. of op)

(Def. of wgtğœ‹)

(split path)

(Distributivity)

(Induction on Fig. 1)

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ÃŠğœ‹ âˆˆTPathshğ¶â€², ğœâ€², 0, ğœ–i

ğ‘ âŠ™

wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹))

(Def. of op)

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœop

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²) .

Now let ËœÎ¦ be another wGCL-functional. We want to show that Ëœop (cid:22) ËœÎ¦. Thus, we perform induc-
tion over the maximum length â„“ âˆˆ N of terminating paths from a conï¬guration ğœ…0 = hğ¶, ğœ, ğ‘›, ğ›½i.
To that end, denote

TPathsâ‰¤â„“
ğœ…0

â‰”

ğœ…0 . . . ğœ…ğ‘˜ âˆˆ TPathsğœ…0

ğ‘˜ â‰¤ â„“

and

(cid:8)

Ëœopâ‰¤â„“

ğ¶
J

K

( ğ‘“ ) (ğœ) â‰”

ÃŠğœ‹ âˆˆTPathsâ‰¤â„“
ğœ…0

(cid:12)
(cid:12)

(cid:9)

wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹)) .

46

Batz, Gallus, Kaminski, Katoen, and Winkler

We prove Ëœopâ‰¤â„“
is ğœ”-ï¬nitary and hence

ğ¶
J

K

( ğ‘“ ) (cid:22) ËœÎ¦

( ğ‘“ ) for all â„“ âˆˆ N, then the claim follows because the module M

ğ¶
J

K

Ëœop

ğ¶
J

K

( ğ‘“ ) =

Ëœopâ‰¤â„“

Ã„â„“ âˆˆN

( ğ‘“ ) (cid:22) ËœÎ¦

ğ¶
J

K

( ğ‘“ ) .

ğ¶
J

K

Moreover, we may assume ğ¶ â‰  â†“ as otherwise Ëœop

( ğ‘“ ).
â†“
The following forms the induction base. Let â„“ = 0. Then, TPathsâ‰¤0
= âˆ… and
K
J
ğœ…0

( ğ‘“ ) = ğ‘“ = Ëœğ¶

ğ¶
J

K

The following forms the induction step. Let â„“ âˆˆ N such that Ëœopâ‰¤â„“

Ëœopâ‰¤0

( ğ‘“ ) = 0 (cid:22) ËœÎ¦

( ğ‘“ ) .

ğ¶
J

K

ğ¶
J

K

Ëœopâ‰¤â„“+1

ğ¶
J

K

( ğ‘“ ) (ğœ)

( ğ‘“ ) (cid:22) ËœÎ¦

ğ¶
J

K

( ğ‘“ ).

ğ¶
J

K

(wGCL-functional)

=

(cid:22)

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœopâ‰¤â„“

( ğ‘“ ) (ğœ â€²)

ğ¶ â€²
J

K

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ ËœÎ¦

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

= ËœÎ¦

ğ¶
J

K

( ğ‘“ ) (ğœ) .

(Induction Hypothesis)

(wGCL-functional)

(cid:3)

Lemma C.8. The map Ëœwp is a wGCL-functional.

Proof. We employ structural induction on the rules from Fig. 1 grouped by the structure of ğ¶.
The following forms the induction base.
â€¢ The program ğ¶ is of the form ğ‘¥ â‰” ğ¸.

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

= ğ‘“ [ğ‘¥/ğ¸] (ğœ)

= ğ‘“ (ğœ [ğ‘¥ â†¦â†’ ğœ (ğ¸)])

( ğ‘“ ) (ğœ [ğ‘¥ â†¦â†’ ğœ (ğ¸)])

= Ëœwp

â†“
K
J

=

ğ‘ âŠ™ Ëœwp

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

â€¢ The program ğ¶ is of the form âŠ™ ğ‘.

(Def. of wp)

(Def. of ğ‘“ [ğ‘¥/ğ¸])

(Def. of

Ëœwp)

(Fig. 1 (assign))

Weighted Programming

47

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

= (ğ‘ âŠ™ ğ‘“ ) (ğœ)

= ğ‘ âŠ™ Ëœwp

( ğ‘“ ) (ğœ)

â†“
K
J

=

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœwp

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

(Def. of wp)

(Def. of

Ëœwp)

(Fig. 1 (weight))

The following forms the induction step.

â€¢ The program ğ¶ is of the form ğ¶1

ğ¶2.

#
There are the following two exclusive cases by the rules from Fig. 1:
(1) Case hğ¶1, ğœ, ğ‘›, ğ›½i âŠ¢ğ‘ hâ†“, ğœ â€², ğ‘› + 1, ğ›½ â€²i.

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

= Ëœwp

ğ¶1
J

K

(

Ëœwp

ğ¶2
J

K

( ğ‘“ ) ) (ğœ)

(Def. of wp)

(Induction Hypothesis)

=

=

=

ÃŠhğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hâ†“, ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœwp

â†“
K
J

(

Ëœwp

ğ¶2
J

K

( ğ‘“ ) ) (ğœ â€²)

ÃŠhğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hâ†“, ğœâ€², ğ‘›+1, ğ›½â€² i

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœwp

ğ‘ âŠ™ Ëœwp

ğ¶2
J

K

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

( ğ‘“ ) (ğœ â€²)

(Def. of

Ëœwp)

(Fig. 1 (seq. 1))

(2) Case hğ¶1, ğœ, ğ‘›, ğ›½i âŠ¢ğ‘ hğ¶ â€²

1, ğœ â€², ğ‘› + 1, ğ›½ â€²i.

48

Batz, Gallus, Kaminski, Katoen, and Winkler

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

= Ëœwp

ğ¶1
J

K

(

Ëœwp

ğ¶2
J

K

( ğ‘“ ) ) (ğœ)

(Def. of wp)

(Induction Hypothesis)

hğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€²
ÃŠ

1, ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœwp

ğ¶ â€²
1
J

K

(

Ëœwp

ğ¶2
J

K

( ğ‘“ ) ) (ğœ â€²)

hğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€²
ÃŠ

1, ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœwp

ğ¶ â€²
1
J

#

ğ¶2

( ğ‘“ ) (ğœ â€²)

K

(Def. of wp)

(Fig. 1 (seq. 1))

=

=

=

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i
â€¢ The program ğ¶ is of the form if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }.

ğ‘ âŠ™ Ëœwp

( ğ‘“ ) (ğœ â€²)

ğ¶ â€²
J

K

There are the following two exclusive cases:

(1) Case ğœ |= ğœ‘.

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

= ( [ğœ‘]

Ëœwp

ğ¶1
J

K

( ğ‘“ ) âŠ• [Â¬ğœ‘]

Ëœwp

( ğ‘“ )) (ğœ)

ğ¶2
J

K

= Ëœwp

ğ¶1
J

K

( ğ‘“ ) (ğœ)

=

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœwp

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

(2) Case ğœ 6|= ğœ‘.

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

= ( [ğœ‘]

Ëœwp

ğ¶1
J

K

( ğ‘“ ) âŠ• [Â¬ğœ‘]

Ëœwp

( ğ‘“ )) (ğœ)

ğ¶2
J

K

= Ëœwp

ğ¶2
J

K

( ğ‘“ ) (ğœ)

=

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i
â€¢ The program ğ¶ is of the form { ğ¶1 } âŠ• { ğ¶2 }.

ğ‘ âŠ™ Ëœwp

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

(Def. of wp)

(Case ğœ |= ğœ‘)

(Fig. 1 (if))

(Def. of wp)

(Case ğœ 6|= ğœ‘)

(Fig. 1 (else))

Weighted Programming

49

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

(Def. of wp)

= Ëœwp

ğ¶1
J

K

( ğ‘“ ) (ğœ) âŠ• Ëœwp

( ğ‘“ ) (ğœ)

ğ¶2
J

K

(Fig. 1 (l. branch), (r. branch))

=

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœwp

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

â€¢ The program ğ¶ is of the form while ( ğœ‘ ) { ğ¶1 }.
There are the following two exclusive cases:

(1) Case ğœ |= ğœ‘.

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

= ( [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp

ğ¶1
J

K

( wp

ğ¶
J

K

( ğ‘“ ) )) (ğœ)

= wp

ğ¶1
J

K

( wp

ğ¶
J

K

( ğ‘“ ) ) (ğœ)

= wp

ğ¶1
J

ğ¶

( ğ‘“ ) (ğœ)

#

K

=

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœwp

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

(2) Case ğœ 6|= ğœ‘.

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

= ( [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp

ğ¶1
J

K

( wp

ğ¶
J

K

( ğ‘“ ) )) (ğœ)

= ğ‘“ (ğœ)

= Ëœwp

â†“
K
J

( ğ‘“ ) (ğœ)

=

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœwp

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

Lemma C.9. Let ğ¶1, ğ¶2 be wGCL programs and ğ‘“ âˆˆ W, then

(Def. of wp)

(Case ğœ |= ğœ‘)

(Def. of wp)

(Fig. 1 (while))

(Def. of wp)

(Case ğœ 6|= ğœ‘)

(Def. of

Ëœwp)

(Fig. 1 (break))

(cid:3)

â–³

Proof. Consider any state ğœ âˆˆ Î£. We employ structural induction on the rules from Fig. 1.

ğ¶2

( ğ‘“ ) = op

op

ğ¶1
J

#

K

ğ¶1
J

K

( op

( ğ‘“ ) ) .

ğ¶2
J

K

50

Batz, Gallus, Kaminski, Katoen, and Winkler

The following forms the induction base. The case hğ¶1, ğœ, ğ‘›, ğ›½i âŠ¢ğ‘ hâ†“, ğœ â€², ğ‘› + 1, ğ›½ â€²i.

Ëœop

ğ¶1
J

#

ğ¶2

( ğ‘“ ) (ğœ)

K

=

=

hğ¶1 # ğ¶2, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i
ÃŠ

ğ‘ âŠ™ Ëœop

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

ÃŠhğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hâ†“, ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœop

ğ¶2
J

K

( ğ‘“ ) (ğœ â€²)

= Ëœop

ğ¶1
J

K

( Ëœop

ğ¶2
J

K

( ğ‘“ ) ) (ğœ)

(wGCL-functional)

(Fig. 1 (seq. 1))

(wGCL-functional)

The following forms the induction step. The case hğ¶1, ğœ, ğ‘›, ğ›½i âŠ¢ğ‘ hğ¶ â€²

1, ğœ â€², ğ‘› + 1, ğ›½ â€²i.

Ëœop

ğ¶1
J

#

ğ¶2

( ğ‘“ ) (ğœ)

K

hğ¶1 # ğ¶2, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i
ÃŠ

ğ‘ âŠ™ Ëœop

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

hğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€²
ÃŠ

1, ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœop

ğ¶ â€²
1
J

#

ğ¶2

( ğ‘“ ) (ğœ â€²)

K

(wGCL-functional)

(Fig. 1 (seq. 1))

(Induction Hypothesis)

hğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€²
ÃŠ

1, ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ Ëœop

ğ¶ â€²
1
J

K

( Ëœop

ğ¶2
J

K

( ğ‘“ ) ) (ğœ â€²)

=

=

=

(wGCL-functional)

(cid:3)

= Ëœop

ğ¶1
J

K

( Ëœop

ğ¶2
J

K

( ğ‘“ ) ) (ğœ)

Lemma C.10. Let ğ¶ â€² be a wGCL program and ğ‘“ âˆˆ W, then

op

while ( ğœ‘ ) { ğ¶ â€² }

ğ¶ â€²
J
Proof. Let ğœ âˆˆ Î£ be a state. We distinguish two cases:

( ğ‘“ ) = [ğœ‘] ğ‘“ âŠ• [Â¬ğœ‘] op

K

J

( op

while ( ğœ‘ ) { ğ¶ â€² }

( ğ‘“ ) ) .

â–³

K

J

K

â€¢ ğœ |= ğœ‘.

Weighted Programming

51

op

while ( ğœ‘ ) { ğ¶ â€² }

( ğ‘“ ) (ğœ)

J

K

=

ÃŠhğ¶, ğœ, 0, ğœ– i âŠ¢ğ‘ hğ¶â€², ğœâ€², 1, ğ›½â€² i

ğ‘ âŠ™ Ëœop

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

= op

= op

ğ¶ â€²
J

#

ğ¶ â€²
J

K

while ( ğœ‘ ) { ğ¶ â€² }

( ğ‘“ ) (ğœ)

K

( op

while ( ğœ‘ ) { ğ¶ â€² }

( ğ‘“ ) ) (ğœ)

J

K

(wGCL-functional)

(Fig. 1 (while))

(Lemma C.9)

(Case ğœ |= ğœ‘)

= ( [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] op

ğ¶ â€²
J

K

( op

while ( ğœ‘ ) { ğ¶ â€² }

( ğ‘“ ) )) (ğœ) .

J

K

â€¢ ğœ 6|= ğœ‘.

op

while ( ğœ‘ ) { ğ¶ â€² }

( ğ‘“ ) (ğœ)

J

K

=

ÃŠhğ¶, ğœ, 0, ğœ– i âŠ¢ğ‘ hğ¶â€², ğœâ€², 1, ğ›½â€² i

ğ‘ âŠ™ Ëœop

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

( ğ‘“ ) (ğœ)

= Ëœop

â†“
K
J

= ğ‘“ (ğœ)

(wGCL-functional)

(Fig. 1 (break))

(Deï¬nition C.4)

(Case ğœ 6|= ğœ‘)

= ( [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] op

ğ¶ â€²
J

K

( op

while ( ğœ‘ ) { ğ¶ â€² }

( ğ‘“ ) )) (ğœ) .

J

K

(cid:3)

â–³

Lemma C.11. We have Ëœwp (cid:22) Ëœop.

Proof. We perform induction on the structure of wGCL programs.
The following forms the induction base.

â€¢ The program ğ¶ is of the form ğ‘¥ â‰” ğ¸.

We have

TPaths hğ¶, ğœ, 0, ğœ– i =

hğ¶, ğœ, 0, ğœ–i âŠ¢1 hâ†“, ğœ [ğ‘¥ â†¦â†’ ğœ (ğ¸)], 1, ğœ–i

.

(cid:8)

(cid:9)

52

Hence,

Batz, Gallus, Kaminski, Katoen, and Winkler

Ëœop

= Ëœop

ğ¶
J

K

â†“
K
J

( ğ‘“ ) (ğœ)

( ğ‘“ ) (ğœ [ğ‘¥ â†¦â†’ ğœ (ğ¸)])

= ğ‘“ (ğœ [ğ‘¥ â†¦â†’ ğœ (ğ¸)])

= ğ‘“ [ğ‘¥/ğ¸] (ğœ)

= Ëœwp

ğ¶
J

K

( ğ‘“ ) (ğœ) .

â€¢ The program ğ¶ is of the form âŠ™ ğ‘.

We have

Hence,

TPaths hğ¶, ğœ, 0, ğœ– i = { hğ¶, ğœ, 0, ğœ–i âŠ¢ğ‘ hâ†“, ğœ, 1, ğœ–i } .

( ğ‘“ ) (ğœ)

Ëœop

ğ¶
J

K

= ğ‘ âŠ™ Ëœop

( ğ‘“ ) (ğœ)

â†“
K
J

= ğ‘ âŠ™ ğ‘“ (ğœ)

= Ëœwp

ğ¶
J

K

( ğ‘“ ) (ğœ) .

(wGCL-functional)

(Def. of Ëœop)

(Def. of ğ‘“ [ğ‘¥/ğ¸])

(Def. of wp)

(wGCL-functional)

(Def. of Ëœop)

(Def. of wp)

The following forms the induction step.

â€¢ The program ğ¶ is of the form ğ¶1

ğ¶2.

#

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

= Ëœwp

(cid:22) Ëœwp

ğ¶1
J

K

ğ¶1
J

K

(

Ëœwp

ğ¶2
J

K

( Ëœop

ğ¶2
J

K

(Def. of wp)

( ğ‘“ ) ) (ğœ)

(Monotonicity; Induction Hypothesis on ğ¶2)

( ğ‘“ ) ) (ğœ)

(Induction Hypothesis on ğ¶1)

( ğ‘“ ) ) (ğœ)

(cid:22) Ëœop

= Ëœop

ğ¶1
J

K

ğ¶
J

K

( Ëœop

ğ¶2
J

K

( ğ‘“ ) (ğœ) .

(Lemma C.9)

â€¢ The program ğ¶ is of the form { ğ¶1 } âŠ• { ğ¶2 } or if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }.

Weighted Programming

53

( ğ‘“ ) (ğœ)

Ëœwp

ğ¶
J

K

ÃŠhğ¶, ğœ, 0, ğœ– i âŠ¢ğ‘ hğ¶â€², ğœâ€², 1, ğ›½â€² i

(wGCL-functional)

ğ‘ âŠ™ Ëœwp

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

(Induction Hypothesis on ğ¶ â€² âˆˆ { ğ¶1, ğ¶2 })

ÃŠhğ¶, ğœ, 0, ğœ– i âŠ¢ğ‘ hğ¶â€², ğœâ€², 1, ğ›½â€² i

ğ‘ âŠ™ Ëœop

ğ¶ â€²
J

K

( ğ‘“ ) (ğœ â€²)

(wGCL-functional)

=

(cid:22)

= Ëœop

ğ¶
J

K

( ğ‘“ ) (ğœ)

â€¢ The program ğ¶ is of the form while ( ğœ‘ ) { ğ¶ â€² }.

Let Î¦ğ‘“ be the corresponding characteristic function

Î¦ğ‘“ (ğ‘‹ ) â‰” [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp

i. e. wp

ğ¶
J

K

( ğ‘“ ) = lfp Î¦ğ‘“ . The map Ëœop

ğ¶
J
K
( ğ‘“ ))

Î¦ğ‘“ ( Ëœop

ğ¶
J

K

( ğ‘‹ ) ,

ğ¶ â€²
J

K
( ğ‘“ ) is a preï¬xed point of Î¦ğ‘“ :

= [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp

(cid:22) [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] Ëœop

ğ¶ â€²
J

K

ğ¶ â€²
J

K

( Ëœop

( Ëœop

ğ¶
J

K

ğ¶
J

K

= Ëœop

ğ¶
J

K

( ğ‘“ ) .

(Def. of Î¦ğ‘“ )

( ğ‘“ ) )

(Induction Hypothesis on ğ¶ â€²)

( ğ‘“ ) )

(Lemma C.10)

With Theorem A.4 it follows Ëœwp

ğ¶
J

K

( ğ‘“ ) (cid:22) Ëœop

( ğ‘“ ).

ğ¶
J

K

(cid:3)

C.3 Proof of Theorem 4.8

Theorem C.12 (Theorem 4.8). Let the monoid module M over W be ğœ”-continuous. For all W-

wGCL programs ğ¶, the wp transformer is

â€¢ monotone, i.e. for all ğ‘“ , ğ‘” âˆˆ W with ğ‘“ (cid:22) ğ‘”, wp
â€¢ strict, i.e. wp
ğ¶
â€¢ additive, i.e. for all ğ‘“ , ğ‘” âˆˆ W, wp
J
â€¢ and moreover, if the monoid W is commutative, then wp is linear, i.e. for all ğ‘ âˆˆ ğ‘Š ,

ğ¶
J
( ğ‘“ âŠ• ğ‘” ) = wp

K
( ğ‘“ ) âŠ• wp

( 0 ) = 0 ;

( ğ‘“ ) (cid:22) wp

( ğ‘” ) ;

ğ¶
J

ğ¶
J

ğ¶
J

ğ¶
J

K

K

K

K

K

( ğ‘” ) ;

wp

ğ¶
J

K

( ğ‘ âŠ™ ğ‘“ ) = ğ‘ âŠ™ wp

( ğ‘“ ) .

ğ¶
J

K

â–³

Proof.

â€¢ Monotonicity. Follows directly from ğœ”-continuity of wp

ğ¶
J

, Theorem 4.7.
K

54

Batz, Gallus, Kaminski, Katoen, and Winkler

â€¢ Strictness. Follows from Theorem 4.9 and annihilation of 0: Let ğœ âˆˆ Î£.

wp

ğ¶
J

K

( 0 ) (ğœ)

wgt(ğœ‹) âŠ™ 0(last(ğœ‹))

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i

0

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i
0

=

=

=

â€¢ Additivity. Follows from Theorem 4.9: Let ğœ âˆˆ Î£ and ğ‘“ , ğ‘” âˆˆ W.

=

=

=

=

wp

ğ¶
J

K

( ğ‘“ âŠ• ğ‘” ) (ğœ)

wgt(ğœ‹) âŠ™ (ğ‘“ âŠ• ğ‘”) (last(ğœ‹))

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i

wgt(ğœ‹) âŠ™ (ğ‘“ (last(ğœ‹) âŠ• ğ‘”(last(ğœ‹))

wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹) âŠ• wgt(ğœ‹) âŠ™ ğ‘”(last(ğœ‹))

wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹)

âŠ•

wgt(ğœ‹) âŠ™ ğ‘”(last(ğœ‹))

= wp

( ğ‘“ ) (ğœ) âŠ• wp

( ğ‘” ) (ğœ)

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i

ğ¶
J

ğ¶
J

K
â€¢ Linearity. Let the monoid W be commutative; we apply Theorem 4.9: As additivity always

K

holds, we only have to show homogenity. Let ğœ âˆˆ Î£, ğ‘ âˆˆ ğ‘Š and ğ‘“ âˆˆ W.

=

=

=

=

=

=

=

wp

ğ¶
J

K

( ğ‘ âŠ™ ğ‘“ ) (ğœ)

wgt(ğœ‹) âŠ™ (ğ‘ âŠ™ ğ‘“ ) (last(ğœ‹))

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i
ğ‘ âŠ™

wgt(ğœ‹) âŠ™ (ğ‘ âŠ™ ğ‘“ (last(ğœ‹))

(wgt(ğœ‹) âŠ™ ğ‘) âŠ™ ğ‘“ (last(ğœ‹)

(ğ‘ âŠ™ wgt(ğœ‹)) âŠ™ ğ‘“ (last(ğœ‹)

ğ‘ âŠ™ (ğ‘ âŠ™ wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹))

wgt(ğœ‹) âŠ™ ğ‘“ (last(ğœ‹)

ğ‘ âŠ™ wp

ÃŠğœ‹ âˆˆTPathshğ¶, ğœ, ğ‘›, ğ‘£i
ğ¶
J

K

( ğ‘“ ) (ğœ)

(cid:3)

Weighted Programming

55

C.4 Proof of Theorem 4.13

Theorem C.13 (Theorem 4.13). Let M be an ğœ”-cocontinuous W-module. For all W-wGCL pro-
is a well-deï¬ned ğœ”-cocontinuous endofunction on the

grams ğ¶, the weighting transformer wlp
module of weightings over M. In particular, if ğ¶ = while ( ğœ‘ ) { ğ¶ â€² }, we have for all ğ‘“ âˆˆ W that

ğ¶
J

K

wlp

ğ¶
J

K

( ğ‘“ )

= l
ğ‘– âˆˆN

Î¨ğ‘–
ğ‘“ (âŠ¤) .

Proof. Fully analogous to Theorem 4.7.

â–³

(cid:3)

C.5 Proof of Theorem 4.14
Let M be an ğœ”-bicontinuous W-module. First we need an auxiliary lemma.

Lemma C.14. Let (ğ‘ğ‘– )ğ‘– âˆˆN be an ascending ğœ”-chain and (ğ‘ğ‘–)ğ‘– âˆˆN be a descending ğœ”-chain in an ğœ”-
bicontinuous module. Furthermore, suppose that (ğ‘ğ‘– )ğ‘– âˆˆN is a descending ğœ”-chain such that for all ğ‘– âˆˆ N
it holds that ğ‘ğ‘– = ğ‘ğ‘– âŠ• ğ‘ğ‘–. Then we have

Proof. Let ğ‘ğœ” â‰”

=

ğ‘ğ‘– âŠ• l
ğ‘– âˆˆN

ğ‘ğ‘– .

Ã„ğ‘– âˆˆN

ğ‘ğ‘–

l
ğ‘– âˆˆN
ğ‘– âˆˆN ğ‘ğ‘– . We have
= l
ğ‘– âˆˆN

(cid:22) l
ğ‘– âˆˆN
where the last equality holds by ğœ”-cocontinuity of âŠ•.

(ğ‘ğ‘– âŠ• ğ‘ğ‘–)

l
ğ‘– âˆˆN

Ãƒ

ğ‘ğ‘–

(ğ‘ğœ” âŠ• ğ‘ğ‘–)

=

ğ‘ğœ” âŠ• l
ğ‘– âˆˆN

ğ‘ğ‘– ,

To prove the inequality in the other direction we will make use of the following auxiliary claim:

Claim. Suppose that (ğ‘¥ğ‘– )ğ‘– âˆˆN is an ascending ğœ”-chain and (ğ‘¦ğ‘– )ğ‘– âˆˆN is a descending ğœ”-chain such
ğ‘– âˆˆN ğ‘¥ğ‘– (cid:22) dğ‘– âˆˆN ğ‘¦ğ‘– .

that for all ğ‘– âˆˆ N we have ğ‘¥ğ‘– (cid:22) ğ‘¦ğ‘– . Then

Proof of Claim. We ï¬rst show the following:

Ãƒ

ğ‘¥ğ‘– (cid:22) ğ‘¦ ğ‘— .
To this end let ğ‘–, ğ‘— be arbitrary. There are two cases to consider:

âˆ€ğ‘– âˆˆ N âˆ€ğ‘— âˆˆ N :

(1) ğ‘– â‰¤ ğ‘— . By assumption, ğ‘¥ ğ‘— (cid:22) ğ‘¦ ğ‘— . Further, since the ğ‘¥â€™s form an ascending chain, we have

ğ‘¥ğ‘– (cid:22) ğ‘¥ ğ‘— .

(2) ğ‘– > ğ‘— . By assumption, ğ‘¥ğ‘– (cid:22) ğ‘¦ğ‘– . Further, since the ğ‘¦â€™s form a descending chain, we have

ğ‘¦ğ‘– (cid:22) ğ‘¦ ğ‘— .

In both cases, ğ‘¥ğ‘– (cid:22) ğ‘¦ ğ‘— holds. Now ï¬x ğ‘› âˆˆ N. We just have shown that ğ‘¥ğ‘– (cid:22) ğ‘¦ğ‘› for all ğ‘– âˆˆ N. Thus
ğ‘– âˆˆN ğ‘¥ğ‘– (cid:22) ğ‘¦ğ‘›. Since ğ‘› was arbitrary, we ï¬nally obtain
by deï¬nition of
(cid:3)

we immediately have

ğ‘– âˆˆN ğ‘¥ğ‘– (cid:22) dğ‘– âˆˆN ğ‘¦ğ‘– by deï¬nition of d.
To conclude the proof of Lemma C.14, let ğ‘ğœ” â‰”

Ãƒ

Ãƒ

Ãƒ

dğ‘– âˆˆN ğ‘ğ‘– and note that for all ğ‘– âˆˆ N,

and that (ğ‘ğ‘– âŠ• ğ‘ğœ” )ğ‘– âˆˆN is an ascending ğœ”-chain. Invoking the auxiliary claim above, we obtain

ğ‘ğ‘– âŠ• ğ‘ğœ”

(cid:22)

ğ‘ğ‘– âŠ• ğ‘ğ‘–

(cid:22) ğ‘ğ‘–

Noticing that

ğ‘– âˆˆN (ğ‘ğ‘– âŠ• ğ‘ğœ” ) = (

(ğ‘ğ‘– âŠ• ğ‘ğœ”)

(cid:22) l
ğ‘– âˆˆN

ğ‘ğ‘– .

Ã„ğ‘– âˆˆN
ğ‘– âˆˆN ğ‘ğ‘– ) âŠ• ğ‘ğœ” by ğœ”-continuity of âŠ• concludes the proof.

(cid:3)

Theorem C.15 (Theorem 4.14). Let M be an ğœ”-bicontinuous W-module. Let ğ¶ be a W-wGCL

Ãƒ

Ãƒ
program and M an ğœ”-bicontinuous W-module. Then for all ğ‘“ âˆˆ W,
( ğ‘“ )
ğ¶
J

( ğ‘“ ) âŠ• wlp

= wp

ğ¶
J

ğ¶
J

wlp

K

K

( 0 ) .

K

56

Batz, Gallus, Kaminski, Katoen, and Winkler

Proof. We employ induction on the structure of ğ¶. Let ğ‘“ âˆˆ W be an arbitrary postweighting.

â€¢ The cases where ğ¶ is of the form ğ‘¥ â‰” ğ¸ or âŠ™ ğ‘. Then wlp

( 0 ) = 0.

wp

ğ¶
J

â€¢ ğ¶ is of the form ğ¶1

K

ğ¶2.

= wp

ğ¶
J

K

ğ¶
J

K

and thus wlp

( 0 ) =

ğ¶
J

K

#
In this case, we have

wlp

= wlp

= wlp

ğ¶1
J

#

ğ¶1
J

K

ğ¶1
J

K

ğ¶2

( ğ‘“ )

K

( wlp

ğ¶2
J

K

( ğ‘“ ) )

( wp

ğ¶2
J

K

( ğ‘“ ) âŠ• wlp

ğ¶2
J

K

ğ¶2
J

K

( 0 ) )

( 0 ) ) âŠ• wlp

( 0 )

ğ¶1
J

K

( ğ‘“ ) âŠ• wlp

( ğ‘“ ) ) âŠ• wp

( ğ‘“ ) ) âŠ• wlp

ğ¶1
J

K

ğ¶1
J

K

( wlp

( wlp

ğ¶2
J

K

ğ¶2
J

K

( 0 ) ) âŠ• wlp

( 0 ) )

( wp

( wp

( wp

ğ¶2
J

K

ğ¶2
J

K

ğ¶2
J

K

= wp

= wp

= wp

= wp

ğ¶1
J

K

ğ¶1
J

K

ğ¶1
J

K

ğ¶1
J

#

ğ¶2

( ğ‘“ ) âŠ• wlp

K

( 0 ) .

ğ¶2

ğ¶1
J

#

K

â€¢ ğ¶ is of the form if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }.

wlp

if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }

( ğ‘“ )

J

[ğœ‘] wlp

[ğœ‘] (wp

ğ¶1
J

K

ğ¶1
J

K

K

( ğ‘“ ) âŠ• [Â¬ğœ‘] wlp

( ğ‘“ )

ğ¶2
J

K

( ğ‘“ ) âŠ• wlp

ğ¶1
J

K

( 0 )) âŠ• [Â¬ğœ‘] (wp

ğ¶2
J

K

[ğœ‘] wp

ğ¶1
J
[Â¬ğœ‘] wp

K
ğ¶2
J

K

( ğ‘“ ) âŠ• [ğœ‘] wlp

ğ¶1
J
( ğ‘“ ) âŠ• [Â¬ğœ‘] wlp

( 0 )

K
ğ¶2
J

( 0 )

K

[ğœ‘] wp

[ğœ‘] wlp

ğ¶1
K
J
ğ¶1
J

K

( ğ‘“ ) âŠ• [Â¬ğœ‘] wp
ğ¶2
K
J
( 0 ) âŠ• [Â¬ğœ‘] wlp
ğ¶2
J

( ğ‘“ )
( 0 )

K

=

=

=

âŠ•

=

âŠ•

(Def. of wlp)

(I.H. for ğ¶2)

(I.H. for ğ¶1)

(Additivity of wp)
( 0 )
(I.H. for ğ¶1)

ğ¶1
J

K

(Def. of wp and wlp)

(Def. of wlp)

( ğ‘“ ) âŠ• wlp

(I.H. on ğ¶1 and ğ¶2)
( 0 ))

ğ¶2
J
(Distributivity)

K

(Commutativity of âŠ•)

(Def. of wp and wlp)

= wp

if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }

( ğ‘“ ) âŠ• wlp

J

K

if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }
J

K

( 0 ) .

Weighted Programming

57

â€¢ ğ¶ is of the form { ğ¶1 } âŠ• { ğ¶2 }.

wlp

{ ğ¶1 } âŠ• { ğ¶2 }

( ğ‘“ )

= wlp

= wp

= wp

J

ğ¶1
J

K

ğ¶1
J

K

ğ¶1
J

K

K

( ğ‘“ ) âŠ• wlp

( ğ‘“ )

ğ¶2
J

K

( ğ‘“ ) âŠ• wlp

( ğ‘“ ) âŠ• wp

ğ¶1
J

K

ğ¶2
J

K

( 0 ) âŠ• wp

( ğ‘“ ) âŠ• wlp

( ğ‘“ ) âŠ• wlp

( 0 ) âŠ• wlp

ğ¶2
J

K

ğ¶1
J

K

= wp

{ ğ¶1 } âŠ• { ğ¶2 }

( ğ‘“ ) âŠ• wlp

{ ğ¶1 } âŠ• { ğ¶2 }

( 0 )

J

K

J

K

(Def. of wlp)

(I.H. on ğ¶1 and ğ¶2)

( 0 )

ğ¶2
J
(Commutativity of âŠ•)

K

( 0 )

ğ¶2
J
(Def. of wp and wlp)

K

â€¢ ğ¶ is of the form while ( ğœ‘ ) { ğ¶ â€² }.

Let Î¨ğ‘“ and Î¦ğ‘“ be the wlp- and wp-characteristic functions of the loop, respectively. We claim
that for all ğ‘› âˆˆ N it holds that

Î¨ğ‘›
ğ‘“ (âŠ¤)

= Î¦ğ‘›

ğ‘“ (0) âŠ• Î¨ğ‘›

0 (âŠ¤) .

(7)

This claim is proved by induction on ğ‘› (the I.H. of this induction is referred to as â€œinner I.H.â€):
â€“ ğ‘› = 0. In this case, the claim holds trivially.

58

Batz, Gallus, Kaminski, Katoen, and Winkler

=

=

=

=

=

=

=

â€“ ğ‘› > 0.

Î¨ğ‘›
ğ‘“ (âŠ¤)

= Î¨ğ‘“ (Î¨ğ‘›âˆ’1

ğ‘“

(âŠ¤))

= Î¨ğ‘“

Î¦ğ‘›âˆ’1
ğ‘“

(0) âŠ• Î¨ğ‘›âˆ’1

0 (âŠ¤)

(cid:16)

[Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wlp

(cid:17)

ğ¶ â€²
J

K (cid:16)

[Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘]

wp

(cid:16)

[Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘]

wp

(cid:16)

ğ¶ â€²
J

ğ¶ â€²
J

K (cid:16)

K (cid:16)

(n > 0)

(inner I.H.)

(Def. of Î¨ğ‘“ )

(I.H.)

(cid:17) (Linearity of wp)

Î¦ğ‘›âˆ’1
ğ‘“

(0) âŠ• Î¨ğ‘›âˆ’1

0 (âŠ¤)

Î¦ğ‘›âˆ’1
ğ‘“

(0) âŠ• Î¨ğ‘›âˆ’1

0 (âŠ¤)

(cid:17)

(cid:17)

âŠ• wlp

( 0 )

ğ¶ â€²
J

K

Î¦ğ‘›âˆ’1
ğ‘“

(0)

âŠ• wp

ğ¶ â€²
J

K (cid:16)

Î¨ğ‘›âˆ’1
0 (âŠ¤)

âŠ• wlp

(cid:17)

ğ¶ â€²
( 0 )
J
(Distributivity)

K

(cid:17)

(cid:17)

(0)

[Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp

âŠ• [ğœ‘]

wp

(cid:16)

ğ¶ â€²
J

K (cid:16)

Î¦ğ‘›âˆ’1
ğ‘“

ğ¶ â€²
J
K (cid:16)
Î¨ğ‘›âˆ’1
0 (âŠ¤)

(cid:17)
âŠ• wlp

(cid:17)

( 0 )

ğ¶ â€²
J

K

(cid:17)

Î¦ğ‘›
ğ‘“ (0) âŠ• [ğœ‘]

wp

(cid:16)

ğ¶ â€²
J

K (cid:16)

Î¨ğ‘›âˆ’1
0 (âŠ¤)

âŠ• wlp

(cid:17)

( 0 )

ğ¶ â€²
J

K

(cid:17)

Î¦ğ‘›
ğ‘“ (0) âŠ• [ğœ‘]

wlp

ğ‘“ (0) âŠ• Î¨ğ‘›
Î¦ğ‘›

(cid:16)
0 (âŠ¤) .

Î¨ğ‘›âˆ’1
0 (âŠ¤)

ğ¶ â€²
J

K (cid:16)

(cid:17) (cid:17)

We are now in a position to conclude the proof:

wlp

while ( ğœ‘ ) { ğ¶ â€² }
J

K

( ğ‘“ )

= l
ğ‘› âˆˆN

Î¨ğ‘›
ğ‘“ (âŠ¤)

Î¦ğ‘›
ğ‘“ (0) âŠ• Î¨ğ‘›

0 (âŠ¤)

= l
ğ‘› âˆˆN

(cid:16)

(cid:17)

=

Ã„ğ‘› âˆˆN

Î¦ğ‘›
ğ‘“ (0) âŠ• l
ğ‘› âˆˆN

Î¨ğ‘›
0 (âŠ¤)

(Def. of Î¦ğ‘“ )

(I.H.)

(Def. of Î¨0)

(Theorem 4.13)

(By (7))

(Lemma C.14)

(Theorem 4.7 & Theorem 4.13)

= wp

while ( ğœ‘ ) { ğ¶ â€² }
J

K

( ğ‘“ ) âŠ• wlp

while ( ğœ‘ ) { ğ¶ â€² }

( 0 )

J

K

Weighted Programming

59

(cid:3)

C.6 Proof of Theorem 4.15 (Soundness of wlp w.r.t. operational semantics)

Theorem C.16 (Theorem 4.15). Let the monoid module M over W be ğœ”-bicontinuous. For any

wGCL program ğ¶ and initial state ğœ âˆˆ Î£,

( 0 ) (ğœ)

wlp

ğ¶
J

K

= l
ğ‘› âˆˆN

ÃŠğœ‹ âˆˆPathsğ‘›

hğ¶, ğœ i

wgt(ğœ‹) âŠ™ âŠ¤ .

Proof. We use a few auxiliary deï¬nitions and lemmas that can be found below. First, the right
hand side is well-deï¬ned by Lemma C.17. Now, the claim is exactly Lemma C.21 by Deï¬nition C.18.
(cid:3)

Lemma C.17. For any wGCL program ğ¶ and state ğœ âˆˆ Î£ the sequence (ğ‘ ğ‘›)ğ‘› âˆˆN, where

ğ‘ ğ‘› â‰”

wgt(ğœ‹) âŠ™ âŠ¤ ,

ÃŠğœ‹ âˆˆPathsğ‘›

hğ¶, ğœ i

is a descending ğœ”-chain.

Proof. Let ğ‘› âˆˆ N. Given ğœ‹ âˆˆ Pathsğ‘›

hğ¶, ğœ i,

wgt(last(ğœ‹) ğœ…) âŠ™ âŠ¤ (cid:22) âŠ¤ .

ÃŠğœ… âˆˆsucc(last(ğœ‹))

As the moduleâ€™s scalar multiplication âŠ™ is ğœ”-continuous and thus monotone in the second argu-
ment, it follows

ğ‘ ğ‘›+1

=

=

(cid:22)

=

wgt(ğœ‹) âŠ™ âŠ¤

ÃŠğœ‹ âˆˆPathsğ‘›+1

hğ¶, ğœ i

wgt(ğœ‹) âŠ™

wgt(last(ğœ‹) ğœ…) âŠ™ âŠ¤

ÃŠğœ‹ âˆˆPathsğ‘›

hğ¶, ğœ i

ÃŠğœ… âˆˆsucc(last(ğœ‹))

wgt(ğœ‹) âŠ™ âŠ¤

ÃŠğœ‹ âˆˆPathsğ‘›
ğ‘ ğ‘› .

hğ¶, ğœ i

(cid:3)

Deï¬nition C.18. The map olp : wGCL â†’ W is deï¬ned for any wGCL program ğ¶ and state ğœ âˆˆ Î£

via

olp

ğ¶
J

K

(ğœ) â‰” l
ğ‘› âˆˆN

ÃŠğœ‹ âˆˆPathsğ‘›

hğ¶, ğœ i

wgt(ğœ‹) âŠ™ âŠ¤ .

It is well-deï¬ned by Lemma C.17.

â–³

Lemma C.19. The map olp behaves like a wGCL-functional (see Deï¬nition C.5):16

=

olp

ğ¶
J

K

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ olp

.

ğ¶ â€²
J

K

16But it is not an (extended) weighting transformer.

(Deï¬nition)

(Lemma C.17)

(split ğœ…0ğœ…1 . . . ğœ…ğ‘›)

(Distributivity)

(M is ğœ”-cocontinuous)

(Deï¬nition)

(cid:3)

â–³

=

ğ¶1
J

K

60

Proof.

olp

(ğœ)

ğ¶
J

K

Batz, Gallus, Kaminski, Katoen, and Winkler

= l
ğ‘› âˆˆN

= l
ğ‘› âˆˆN
ğ‘› â‰¥2

wgt(ğœ‹) âŠ™ âŠ¤

ÃŠğœ‹ âˆˆPathsğ‘›

hğ¶, ğœ i

(wgt(ğœ…0 ğœ…1) âŠ™ wgt(ğœ…1 . . . ğœ…ğ‘›)) âŠ™ âŠ¤

ÃŠğœ…0ğœ…1...ğœ…ğ‘› âˆˆPathsğ‘›

hğ¶, ğœ i

= l
ğ‘› âˆˆN
ğ‘› â‰¥2 ÃŠhğ¶, ğœ i âŠ¢ğ‘ ğœ…1 ÃŠğœ…1...ğœ…ğ‘› âˆˆPathsğ‘›âˆ’1
ğœ…1

ğ‘ âŠ™ wgt(ğœ‹) âŠ™ âŠ¤

= l
ğ‘› âˆˆN

ğ‘ âŠ™

wgt(ğœ‹) âŠ™ âŠ¤

ÃŠhğ¶, ğœ i âŠ¢ğ‘ ğœ…1

ÃŠğœ…1...ğœ…ğ‘› âˆˆPathsğ‘›

ğœ…1

=

=

ğ‘ âŠ™ l
ğ‘› âˆˆN

ÃŠhğ¶, ğœ i âŠ¢ğ‘ ğœ…1

ÃŠğœ…1...ğœ…ğ‘› âˆˆPathsğ‘›

ğœ…1

wgt(ğœ‹) âŠ™ âŠ¤

ÃŠhğ¶, ğœ i âŠ¢ğ‘ hğ¶â€², ğœâ€², 1, ğ›½ i

ğ‘ âŠ™ olp

ğ¶ â€²
J

K

Lemma C.20. For any wGCL programs ğ¶1, ğ¶2,

olp

ğ¶1
K
J
Proof. Consider any state ğœ âˆˆ Î£. We employ structural induction on the rules from Fig. 1.
The following forms the induction base. The case hğ¶1, ğœ, ğ‘›, ğ›½i âŠ¢ğ‘ hâ†“, ğœ â€², ğ‘› + 1, ğ›½ â€²i. First, olp

ğ¶2
J

ğ¶1
J

ğ¶1
J

) âŠ• olp

( olp

ğ¶2

op

K

K

K

#

.

=

0 as Pathsğ‘›

hğ¶1, ğœ i

= âˆ… by Fig. 1 for any ğ‘› â‰¥ 2. Hence,

olp

ğ¶1
J

#

ğ¶2

(ğœ)

K

=

=

hğ¶1 # ğ¶2, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i
ÃŠ

ğ‘ âŠ™ olp

(ğœ â€²)

ğ¶ â€²
J

K

ÃŠhğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hâ†“, ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ olp

(ğœ â€²)

ğ¶2
J

K

= op

= op

ğ¶1
J

K

ğ¶1
J

K

( olp

( olp

ğ¶2
J

K

ğ¶2
J

K

) (ğœ)

) (ğœ) âŠ• olp

(ğœ)

ğ¶1
J

K

(Lemma C.19)

(Fig. 1 (seq. 1))

(wGCL-functional)

= 0)

(olp

ğ¶1
J

K

Weighted Programming

61

The following forms the induction step. The case hğ¶1, ğœ, ğ‘›, ğ›½i âŠ¢ğ‘ hğ¶ â€²

1, ğœ â€², ğ‘› + 1, ğ›½ â€²i.

olp

ğ¶1
J

#

ğ¶2

(ğœ)

K

hğ¶1 # ğ¶2, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i
ÃŠ

ğ‘ âŠ™ olp

(ğœ â€²)

ğ¶ â€²
J

K

hğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€²
ÃŠ

1, ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ olp

ğ¶ â€²
1
J

#

ğ¶2

(ğœ â€²)

K

hğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€²
ÃŠ

1, ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™

op

(cid:0)

ğ¶ â€²
1
J

K

( olp

ğ¶2
J

K

) âŠ• olp

(Lemma C.19)

(Fig. 1 (seq. 1))

(Induction Hypothesis)
ğ¶ â€²
1
J

(ğœ â€²)

K

(cid:1)

(Distributivity)

hğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€²
ÃŠ

1, ğœâ€², ğ‘›+1, ğ›½â€² i

hğ¶1, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€²
ÃŠ

1, ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ op

ğ‘ âŠ™ olp

ğ¶ â€²
1
J

K
ğ¶ â€²
1
J

K

( olp

ğ¶2
J

K

) (ğœ â€²)

(ğœ â€²)

(wGCL-functional; Lemma C.19)

=

=

=

=

âŠ•

= op

ğ¶1
J

K

( olp

ğ¶2
J

K

ğ‘“ ) (ğœ) âŠ• olp

(ğœ)

ğ¶1
J

K

Lemma C.21. For any wGCL program ğ¶ and state ğœ âˆˆ Î£, it is wlp

Proof. We employ induction on the structure of ğ¶.
The following forms the induction base.
â€¢ The program ğ¶ is of the form ğ‘¥ â‰” ğ¸. Then, Pathsğ‘›

hğ¶, ğœ i

ğ¶
J

K

( 0 ) = olp

ğ¶
J

.
K

(cid:3)

â–³

= âˆ… by Fig. 1 for any ğ‘› â‰¥ 2, hence

â€¢ The program ğ¶ is of the form âŠ™ ğ‘. Then, Pathsğ‘›

hğ¶, ğœ i

( 0 ) = 0 = olp

wlp

ğ¶
J

K

.

ğ¶
J
= âˆ… by Fig. 1 for any ğ‘› â‰¥ 2, hence

K

wlp

ğ¶
J

K

( 0 ) = ğ‘ âŠ™ 0 = 0 = olp

.

ğ¶
J

K

The following forms the induction step.
â€¢ The program ğ¶ is of the form ğ¶1
ğ¶2.

#
( 0 )

( wlp

( wlp

ğ¶2
J

K

ğ¶2
J

K

wlp

= wlp

ğ¶
J

K

ğ¶1
J

K

= wp

= op

ğ¶1
J

K

ğ¶1
J

K

= olp

ğ¶2

ğ¶1
J

#

K

( 0 ) )

( 0 ) ) âŠ• wlp

ğ¶1
J

K

(Def. of wlp)

(Theorem 4.14)

( 0 )

(Theorem 4.9; Induction Hypothesis)

( olp

ğ¶2
J

K

) âŠ• olp

ğ¶1
J

K

(Lemma C.20)

62

Batz, Gallus, Kaminski, Katoen, and Winkler

â€¢ The program ğ¶ is of the form if ( ğœ‘ ) { ğ¶1 } else { ğ¶2 }. Let ğœ âˆˆ Î£ be a state. There are the

following two exclusive cases:

(1) Case ğœ |= ğœ‘.

(2) Case ğœ 6|= ğœ‘.

( 0 ) (ğœ)

wlp

ğ¶
J

K

= ( [ğœ‘] wlp

ğ¶1
J

K

( 0 ) âŠ• [Â¬ğœ‘] wlp

( 0 )) (ğœ)

ğ¶2
J

K

= wlp

ğ¶1
J

K

( 0 ) (ğœ)

(Def. of wlp)

(Case ğœ |= ğœ‘)

(Fig. 1 (if))

=

=

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ wlp

( 0 ) (ğœ â€²)

ğ¶ â€²
J

K

(Induction Hypothesis on ğ¶1)

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ olp

(ğœ â€²)

ğ¶ â€²
J

K

(Lemma C.19)

= olp

(ğœ)

ğ¶
J

K

( 0 ) (ğœ)

wlp

ğ¶
J

K

= ( [ğœ‘] wlp

ğ¶1
J

K

( 0 ) âŠ• [Â¬ğœ‘] wlp

( 0 )) (ğœ)

ğ¶2
J

K

= wlp

ğ¶2
J

K

( 0 ) (ğœ)

(Def. of wlp)

(Case ğœ 6|= Â¬ğœ‘)

(Fig. 1 (else))

=

=

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ wlp

( 0 ) (ğœ â€²)

ğ¶ â€²
J

K

(Induction Hypothesis on ğ¶2)

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ olp

(ğœ â€²)

ğ¶ â€²
J

K

(Lemma C.19)

= olp

(ğœ)

ğ¶
J

K

Weighted Programming

63

â€¢ The program ğ¶ is of the form { ğ¶1 } âŠ• { ğ¶2 }.

( 0 ) (ğœ)

wlp

ğ¶
J

K

= wlp

ğ¶1
J

K

( 0 ) (ğœ) âŠ• wlp

( 0 ) (ğœ)

ğ¶2
J

K

(Def. of wlp)

(Induction Hypothesis)

= olp

ğ¶1
J

K

(ğœ) âŠ• olp

(ğœ)

ğ¶2
J

K

=

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ olp

ğ¶ â€²
J

K

(Fig. 1 (l. branch), (r. branch))
(ğœ â€²)

(Lemma C.19)

= olp

(ğœ)

ğ¶
J

K

â€¢ The program ğ¶ is of the form while ( ğœ‘ ) { ğ¶1 }. We show that olp

loop characteristic function Î¨0 for postweight 0, where

ğ¶
J

K

is a ï¬xed point of the

Î¨0 (ğ‘‹ )

=

=

=

[Â¬ğœ‘] 0 âŠ• [ğœ‘] wlp
( ğ‘‹ )
[ğœ‘] wlp
ğ¶1
J

K

( ğ‘‹ )

ğ¶1
J

K

[ğœ‘] (wp

ğ¶1
J

K

( ğ‘‹ ) âŠ• wlp

( 0 )) .

ğ¶1
J

K

(Theorem 4.14)

(8)

Let ğœ âˆˆ Î£ be a state. There are the following two exclusive cases:
(1) Case ğœ |= ğœ‘.

Î¨0 (olp

ğ¶
J

) (ğœ)
K

=

[ğœ‘] (wp

(cid:0)
= (wp

ğ¶1
J

K

ğ¶1
J

K

( olp

= (op

= olp

ğ¶1
J

K

ğ¶1
J

#

=

) âŠ• wlp

ğ¶
J

K

( olp

ğ¶
J

K

) âŠ• olp

ğ¶

(ğœ)

K

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

= olp

(ğœ)

ğ¶
J

K

( olp

ğ¶
J

K

) âŠ• wlp

ğ¶1
J

K

((8) above)

( 0 ))

(ğœ)

(cid:1)

(Case ğœ |= ğœ‘)

( 0 )) (ğœ)

K

ğ¶1
J
(Theorem 4.9, Induction Hypothesis on ğ¶1)
ğ¶1
J

) (ğœ)
K

(Lemma C.20)

ğ‘ âŠ™ olp

(ğœ â€²)

ğ¶ â€²
J

K

(Fig. 1 (while))

(Lemma C.19)

64

Batz, Gallus, Kaminski, Katoen, and Winkler

(2) Case ğœ 6|= ğœ‘. Then, Pathsğ‘›
Î¨0 (olp

hğ¶, ğœ i
ğ¶
J

) (ğœ)
K

= âˆ… by Fig. 1 for any ğ‘› â‰¥ 2, hence olp

=

[ğœ‘] (wp

(cid:0)
= 0

ğ¶1
J

K

( olp

ğ¶
J

K

) âŠ• wlp

ğ¶1
J

K

( 0 ))

(ğœ)

(cid:1)

(ğœ) = 0.

ğ¶
J

K

((8) above)

(Case ğœ 6|= ğœ‘)

Overall, we have Î¨0 (olp
(cid:22) wlp
olp
ğ¶
J
K
most olp
ğ¶
J

ğ¶
J

K

) = olp

ğ¶
( 0 ). Next, we show that the greatest ï¬xed point of wlp
J
. To that end, we use induction on the path length â„“ âˆˆ N. Denote

( 0 ) is deï¬ned as greatest ï¬xed point,
( 0 ) is at

. As wlp
K

ğ¶
J

ğ¶
J

ğ¶
J

K

K

K

K

olp=â„“

â‰”

ğ¶
J

K

ÃŠğœ‹ âˆˆPathsâ„“

hğ¶, ğœ i

wgt(ğœ‹) âŠ™ âŠ¤ .

The following forms the induction base. Let â„“ = 0. Then, Pathsâ„“

hğ¶, ğœ i

= âˆ… and

( 0 ) (cid:22) âŠ¤ = olp=0

.

ğ¶
J

The following forms the induction step. Fully analogous to Lemma C.8,
functional. Let â„“ âˆˆ N such that wlp
ğ¶
K
J
( 0 ) (ğœ)

K
, and let ğœ âˆˆ Î£.
K

( 0 ) (cid:22) olp=â„“

ğ¶
J

wlp

K

wlp

ğ¶
J

ğ¶
J

K

(wGCL-functional)

Ëœwlp is a wGCL-

=

(cid:22)

ÃŠhğ¶, ğœ, ğ‘›, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ wlp

( 0 ) (ğœ â€²)

ğ¶ â€²
J

K

ÃŠhğ¶, ğœ, â„“, ğ›½ i âŠ¢ğ‘ hğ¶â€², ğœâ€², ğ‘›+1, ğ›½â€² i

ğ‘ âŠ™ olp=â„“

ğ¶ â€²
J

K

(Induction Hypothesis)

(Lemma C.19)

= olp=â„“+1

(ğœ) .
ğ¶
J
K
( 0 ) (cid:22) olp

By Deï¬nition of âŠ“, wlp

ğ¶
J

K

. Both inequalities imply wlp

ğ¶
J

K

( 0 ) = olp

ğ¶
J

K

ğ¶
J

.
K
(cid:3)

Weighted Programming

65

D PROOFS OF SECTION 5
D.1 Proof of Theorem 5.3

We will use the following lemma which is a useful alternative characterization of certain termina-
tion:

Lemma D.1. ğ¶ is certainly terminating for initial state ğœ âˆˆ Î£ iï¬€ there exists ğ‘ âˆˆ N such that

= âˆ… for all ğ‘› â‰¥ ğ‘, i.e. the length of all computation paths starting in hğ¶, ğœi is bounded.

Pathsğ‘›

hğ¶, ğœ i

Proof. The direction from right to left is trivial. For the other direction we show that the sub-
tree Gâ€² induced by succâˆ—(hğ¶, ğœi) â‰”
ğ‘– â‰¥0 succğ‘– (hğ¶, ğœi) is ï¬nite which implies that all paths have
bounded length. Assume towards contradiction that Gâ€² is inï¬nite. By deï¬nition, Gâ€² is ï¬nitely
branching. Thus, by KÅ‘nigâ€™s classic inï¬nity lemma, there exists an inï¬nite path ğœ…1ğœ…2 . . . in Gâ€². But
then there also exists an inï¬nite path starting in hğ¶, ğœi since ğœ…1 is reachable from there. This is a
(cid:3)
contradiction to the assumption that ğ¶ is certainly terminating for ğœ.

Ã

Proof of Theorem 5.3. First, since ğ¶ â€² is universally certainly terminating we have by Lemma D.1
= âˆ… for all ğ‘› â‰¥ ğ‘ and ğœ â€² âˆˆ Î£ and thus by Theorem 4.15

that there exists ğ‘ âˆˆ N such that Pathsğ‘›
hğ¶, ğœâ€² i
and Theorem 4.14, it holds for all ğ‘” âˆˆ W that

( ğ‘” ) = wp
This implies that the wp- and wlp-characteristic functions of the loop ğ¶ = while ( ğœ‘ ) { ğ¶ â€² } are
equal, i.e.

( ğ‘” ) .

wlp

K

K

ğ¶ â€²
J

ğ¶ â€²
J

Î¦ğ‘“

= ğœ† ğ‘‹ . [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wp
= ğœ† ğ‘‹ . [Â¬ğœ‘] ğ‘“ âŠ• [ğœ‘] wlp
= Î¨ğ‘“ .

ğ¶ â€²
J
K
ğ¶ â€²
J

K

( ğ‘‹ )

( ğ‘‹ )

Similarly, since ğ¶ is certainly terminating on ğœ, we also have

and thus

wlp

ğ¶ â€²
J

K
(gfp Î¦ğ‘“ ) (ğœ)

( ğ‘“ ) (ğœ) = wp

( ğ‘“ ) (ğœ)

ğ¶ â€²
J

K
(lfp Î¦ğ‘“ ) (ğœ) .

=

Since ğ¼1 and ğ¼2 are ï¬xed points of Î¦ğ‘“ ,

lfp Î¦ğ‘“ (cid:22) ğ¼1, ğ¼2 (cid:22) gfp Î¦ğ‘“

and thus ğ¼1(ğœ) = ğ¼2(ğœ).

(cid:3)

66

Batz, Gallus, Kaminski, Katoen, and Winkler

E ANNOTATED PROGRAMS
E.1 Ski Rental

wp

[ğ‘›=0]0 âŠ• [0<ğ‘¦ ]

(2ğ‘¦âˆ’1) âŠ• [ğ‘› â‰¤ğ‘¦âˆ’1]ğ‘›

=

((
Î¦

ğ‘› âŠ• ğ‘¦ = ğ¼
[ğ‘› = 0] 1 âŠ• [ğ‘› > 0] âŠ™ (ğ‘› âŠ• ğ‘¦)

((
while ( ğ‘› > 0 ) {

=

ğ‘› âŠ• ğ‘¦
1 âŠ™ (ğ‘› âˆ’ 1) âŠ• ğ‘¦

((
wp
((
ğ‘› â‰” ğ‘› âˆ’ 1
=

#

1 âŠ™ ğ‘› âŠ• ğ‘¦
1 âŠ™ ğ‘› âŠ• 1 âŠ™ ğ‘¦ âŠ• ğ‘¦
1 âŠ™ (ğ‘› âŠ• ğ‘¦) âŠ• ğ‘¦
(* rent *)

((
=
((
wp

((
{

wp

1 âŠ™ (ğ‘› âŠ• ğ‘¦)

((
âŠ™ 1

ğ‘› âŠ• ğ‘¦

((

} âŠ• {
=

((
wp

(* buy *)

ğ‘¦
ğ‘¦ âŠ™ 1

((
âŠ™ ğ‘¦
=
1

#

((
=
0
((
wp
0 âŠ• ğ‘¦
((
ğ‘› â‰” 0

ğ‘› âŠ• ğ‘¦

((

ğ‘› âŠ• ğ‘¦ = ğ¼

}

88

}

1

((

(* terminate *)

((
ğ‘ â‰” 0
=

#

(cid:0)

(cid:1)

[ğ‘›=0] âŠ• [ğ‘ â‰¥ğ‘¦ ]ğ‘¦ âŠ• [ğ‘<ğ‘¦ ]

((

Î¦

((

(2ğ‘¦âˆ’ğ‘âˆ’1) âŠ• [ğ‘› â‰¤ğ‘¦âˆ’ğ‘âˆ’1]ğ‘›

= ğ¼

[ğ‘›=0]0âŠ• [ğ‘›>0]

(cid:0)

[ğ‘+1â‰¥ğ‘¦ ]ğ‘¦ âŠ• [ğ‘+1<ğ‘¦ ]
(cid:1)

(2ğ‘¦âˆ’ğ‘âˆ’1) âŠ• [ğ‘› â‰¤ğ‘¦âˆ’ğ‘âˆ’1]ğ‘›

(cid:0)
while ( ğ‘› > 0 ) {

(cid:0)

[ğ‘+1â‰¥ğ‘¦ ]ğ‘¦ âŠ• [ğ‘+1<ğ‘¦ ]

(2ğ‘¦âˆ’ğ‘âˆ’1) âŠ• [ğ‘› â‰¤ğ‘¦âˆ’ğ‘âˆ’1]ğ‘›

(cid:1)(cid:1)

(cid:1)

=

((

=

((

=

[ğ‘+1â‰¥ğ‘¦ ]ğ‘¦ âŠ•

1âŠ™ [ğ‘›=1]0

(cid:0)
âŠ• [ğ‘+1<ğ‘¦ ]
(cid:0)

[ğ‘+1â‰¥ğ‘¦ ]ğ‘¦ âŠ• [ğ‘+1<ğ‘¦ ]

(cid:0)
[ğ‘›=1]0 âŠ• [ğ‘+1â‰¥ğ‘¦ ]ğ‘¦

((

1âŠ™

(2ğ‘¦âˆ’ğ‘âˆ’1) âŠ• [ğ‘› â‰¤ğ‘¦âˆ’ğ‘âˆ’1]ğ‘›

(cid:1)(cid:1)

âŠ• [ğ‘+1<ğ‘¦ ]
(cid:0)

(2ğ‘¦âˆ’ğ‘âˆ’2) âŠ• [ğ‘› â‰¤ğ‘¦âˆ’ğ‘âˆ’1] (ğ‘›âˆ’1)

[ğ‘+1<ğ‘¦ ] (1âŠ™ğ¼ [ğ‘/ğ‘+1] [ğ‘›/ğ‘›âˆ’1]) âŠ• [ğ‘+1â‰¥ğ‘¦ ]ğ‘¦

wp

((
ğ‘› â‰” ğ‘› âˆ’ 1

(cid:0)

(cid:1)(cid:1)

wp

[ğ‘+1<ğ‘¦ ] (1âŠ™ğ¼ [ğ‘/ğ‘+1]) âŠ• [ğ‘+1â‰¥ğ‘¦ ]ğ‘¦

#

((
ğ‘ â‰” ğ‘ + 1

wp

[ğ‘<ğ‘¦ ] (1âŠ™ğ¼ ) âŠ• [ğ‘ â‰¥ğ‘¦ ]ğ‘¦

#

((
if ( ğ‘ < ğ‘¦ ) {

wp

1âŠ™ğ¼

((

âŠ™ 1

ğ¼
((
} else {
=

ğ‘¦

((
wp

((

=

((
wp
((

ğ‘¦ âŠ™0

âŠ™ ğ‘¦

#

0

ğ¼ [ğ‘›/0]

ğ‘› â‰” 0

ğ¼

((
}

[ğ‘›=0]0 âŠ• [ğ‘ â‰¥ğ‘¦ ]ğ‘¦

88

âŠ• [ğ‘<ğ‘¦ ]

(2ğ‘¦âˆ’ğ‘âˆ’1) âŠ• [ğ‘› â‰¤ğ‘¦âˆ’ğ‘âˆ’1]ğ‘›

= ğ¼

(cid:0)

(cid:1)

}

1

((

Weighted Programming

E.2 Mutual Exclusion

(cid:23)

((
(cid:23)

[1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜

ğ‘Šğ‘˜ âŠ™ [1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜

67

ğ‘
ğ‘— =1 [â„“ [ ğ‘— ]=ğ‘¤ ] (ğ‘Šğ‘— âŠ™ [1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜ )

((
Î¦
(( Ã‰
while ( true ) {
wlp

ğ‘
ğ‘— =1 [â„“ [ ğ‘— ]=ğ‘¤ ] (ğ‘Šğ‘— âŠ™ [1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜ )

(( Ã‰
ğ‘

{ ğ‘– â‰” ğ‘— }

ÃŠğ‘—=1

wlp

#

[â„“ [ğ‘– ]=ğ‘¤ ](ğ‘Šğ‘– âŠ™ [1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜ )

((
if ( â„“ [ğ‘–] = ğ‘› ) {

wlp

âˆ…
((
â„“ [ğ‘–] â‰” ğ‘¤
(cid:23)

âˆ…

((
((

[1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜

} else if ( â„“ [ğ‘–] = ğ‘¤ ) {

(cid:23)

ğ‘Šğ‘– âŠ™ [1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜

[ğ‘¦=0] (ğ‘Šğ‘– âŠ™ [1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜ )

((
wlp
((
if ( ğ‘¦ > 0 ) {

wlp

âˆ…
((
ğ‘¦ â‰” ğ‘¦ âˆ’ 1
â„“ [ğ‘–] â‰” ğ‘
âŠ™ ğ¶ğ‘–
(cid:23)

#

âˆ…

#

((

[1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜

((
} else {
wlp

ğ‘Šğ‘– âŠ™ [1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜

((
âŠ™ ğ‘Šğ‘–

[1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜

((

}

[1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜

} else if ( â„“ [ğ‘–] = ğ‘ ) {

((

wlp

âˆ…
((
ğ‘¦ â‰” ğ‘¦ + 1
â„“ [ğ‘–] â‰” ğ‘›
âŠ™ ğ‘…ğ‘–
(cid:23)

#

âˆ…

#

[1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜

((

((

[1â‰¤ğ‘˜ â‰¤ğ‘ âˆ§â„“ [ğ‘˜ ]=ğ‘¤âˆ§ğ‘¦=0]ğ‘Š ğœ”
ğ‘˜

}

88

}
wlp

((

0

68

Batz, Gallus, Kaminski, Katoen, and Winkler

E.3 Path Counting

=

((
Î¦

ğ¼

(because ğ¼ [ğ‘›/0] = [ğ‘š â‰¤1])

[ğ‘›=0] [ğ‘š â‰¤1] âŠ• [ğ‘›>0]ğ¼

((
while ( ğ‘› > 0 ) {

=

((
=

[ğ‘š â‰¤1] ( [ğ‘=0] Fib(ğ‘›+2) âŠ• [ğ‘>0] Fib(ğ‘›+1)) = ğ¼

[ğ‘š â‰¤1] ( [ğ‘=0] (Fib(ğ‘›+1) âŠ•Fib(ğ‘›)) âŠ• [ğ‘>0] Fib(ğ‘›+1))

[ğ‘š â‰¤1] (Fib(ğ‘›+1) âŠ• [ğ‘=0] Fib(ğ‘›))

[ğ‘š â‰¤1] Fib(ğ‘›+1) âŠ• [ğ‘š â‰¤1âˆ§ğ‘=0] Fib(ğ‘›)

((
=
((
wp
((
ğ‘› â‰” ğ‘› âˆ’ 1

wp

((
{

=

[ğ‘š â‰¤1] Fib(ğ‘›+2) âŠ• [ğ‘š â‰¤1âˆ§ğ‘=0] Fib(ğ‘›+1)

[ğ‘š â‰¤1] Fib(ğ‘›+2)

[ğ‘š â‰¤1] ( [0=0] Fib(ğ‘›+2) âŠ• [0>0] Fib(ğ‘›+1))

((
wp
((
ğ‘ â‰” 0

[ğ‘š â‰¤1] ( [ğ‘=0] Fib(ğ‘›+2) âŠ• [ğ‘>0] Fib(ğ‘›+1))

((
} âŠ• {
=

[ğ‘š â‰¤1âˆ§ğ‘=0] Fib(ğ‘›+1)

[ğ‘š â‰¤1âˆ§ğ‘+1â‰¤1] ( [ğ‘+1=0] Fib(ğ‘›+2) âŠ• [ğ‘+1>0] Fib(ğ‘›+1))

((
wp
((
ğ‘ â‰” ğ‘ + 1
=

#

[ğ‘š â‰¤1âˆ§ğ‘ â‰¤1] ( [ğ‘=0] Fib(ğ‘›+2) âŠ• [ğ‘>0] Fib(ğ‘›+1))

[max(ğ‘š,ğ‘) â‰¤1] ( [ğ‘=0] Fib(ğ‘›+2) âŠ• [ğ‘>0] Fib(ğ‘›+1))

((
((
ğ‘š â‰” max(ğ‘š, ğ‘)

[ğ‘š â‰¤1] ( [ğ‘=0] Fib(ğ‘›+2) âŠ• [ğ‘>0] Fib(ğ‘›+1))

((

}

[ğ‘š â‰¤1] ( [ğ‘=0] Fib(ğ‘›+2) âŠ• [ğ‘>0] Fib(ğ‘›+1)) = ğ¼

88

}

[ğ‘š â‰¤1]

((

(b) ğ¶count with annotations for verifying the loop invariant.

#
ğ‘ â‰” 0

// ğ‘Ÿğ‘’ğ‘  â‰” []
ğ‘š â‰” 0
#
#
while ( ğ‘› > 0 ) {
ğ‘› â‰” ğ‘› âˆ’ 1
{

// append ( ğ‘Ÿğ‘’ğ‘ , 0 )
ğ‘ â‰” 0

} âŠ• {

// append ( ğ‘Ÿğ‘’ğ‘ , 1 )
ğ‘ â‰” ğ‘ + 1
ğ‘š â‰” max(ğ‘š, ğ‘)

#

#

#

}

}

program

non-
The
(a)
deterministically
bitstrings
of length ğ‘›. The maximum number of
consecutive 1â€™s is stored in variable ğ‘š.

â€œcreatesâ€

ğ¶count

Weighted Programming

E.4 Knapsack

69

=

((
wp

1 âŠ• [ğ‘¥ â‰¥8]1 âŠ• [ğ‘¥ â‰¥13]1

[0â‰¤1âˆ§0â‰¥8âˆ’ğ‘¥ ]1 âŠ• [0=0]1 âŠ• [0â‰¤4âˆ§0â‰¥8]1

âŠ• [0â‰¤3âˆ§0â‰¥13âˆ’ğ‘¥ ]1 âŠ• [0â‰¤2âˆ§0â‰¥5]1 âŠ• [0â‰¤6âˆ§0â‰¥13]1

((
ğ‘¡ â‰” 0
=

#

ğ‘Ÿ â‰” 0

#

[ğ‘¡ â‰¤1âˆ§ğ‘Ÿ â‰¥8âˆ’ğ‘¥ ]1 âŠ• [ğ‘¡=0]1 âŠ• [ğ‘¡ â‰¤4âˆ§ğ‘Ÿ â‰¥8]1

((

wp

âŠ• [ğ‘¡ â‰¤3âˆ§ğ‘Ÿ â‰¥13âˆ’ğ‘¥ ]1 âŠ• [ğ‘¡ â‰¤2âˆ§ğ‘Ÿ â‰¥5]1 âŠ• [ğ‘¡ â‰¤6âˆ§ğ‘Ÿ â‰¥13]1

[ğ‘¡+2â‰¤3âˆ§ğ‘Ÿ +5â‰¥13âˆ’ğ‘¥ ]1 âŠ• [ğ‘¡+2â‰¤2âˆ§ğ‘Ÿ +5â‰¥5]1 âŠ• [ğ‘¡+2â‰¤6âˆ§ğ‘Ÿ +5â‰¥13]1

[ğ‘¡+3â‰¤2âˆ§ğ‘Ÿ +ğ‘¥ â‰¥5]1 âŠ• [ğ‘¡+3â‰¤6âˆ§ğ‘Ÿ +ğ‘¥ â‰¥13]1 âŠ• [ğ‘¡ â‰¤2âˆ§ğ‘Ÿ â‰¥5]1 âŠ• [ğ‘¡ â‰¤6âˆ§ğ‘Ÿ â‰¥13]1

âŠ• [ğ‘¡ â‰¤3âˆ§ğ‘Ÿ â‰¥13âˆ’ğ‘¥ ]1 âŠ• [ğ‘¡ â‰¤2âˆ§ğ‘Ÿ â‰¥5]1 âŠ• [ğ‘¡ â‰¤6âˆ§ğ‘Ÿ â‰¥13]1
ğ‘Ÿ â‰” ğ‘Ÿ + 5 } âŠ• { skip }

[ğ‘¡ â‰¤3âˆ§ğ‘Ÿ â‰¥13âˆ’ğ‘¥ ]1 âŠ• [ğ‘¡ â‰¤2âˆ§ğ‘Ÿ â‰¥5]1 âŠ• [ğ‘¡ â‰¤6âˆ§ğ‘Ÿ â‰¥13]1

((
{ ğ‘¡ â‰” ğ‘¡ + 2
=

((
wp
((
{ ğ‘¡ â‰” ğ‘¡ + 3
=

((
wp
((
{ ğ‘¡ â‰” ğ‘¡ + 4

#

#

ğ‘Ÿ â‰” ğ‘Ÿ + ğ‘¥ } âŠ• { skip }

[ğ‘¡ â‰¤2âˆ§ğ‘Ÿ â‰¥5]1 âŠ• [ğ‘¡ â‰¤6âˆ§ğ‘Ÿ â‰¥13]1

[ğ‘¡+4â‰¤6âˆ§ğ‘Ÿ +8â‰¥13]1 âŠ• [ğ‘¡ â‰¤6âˆ§ğ‘Ÿ â‰¥13]1

ğ‘Ÿ â‰” ğ‘Ÿ + 8 } âŠ• { skip }

#

#

#
[ğ‘¡ â‰¤6âˆ§ğ‘Ÿ â‰¥13]1

((

Fig. 9. Program modelling the Knapsack problem (see Appendix F.1). The three branchings correspond to
choosing the respective task or not. Variables ğ‘¡ and ğ‘Ÿ stand for time and reward, respectively.

70

Batz, Gallus, Kaminski, Katoen, and Winkler

F FURTHER APPLICATIONS OF WEIGHTED PROGRAMMING
F.1 Reasoning about ğ‘›-th best solutions

Field:
Problem: Knapsack Problem

Discrete Optimization

Model:
Semiring: Natural numbers

Optimization problem

Techniques: wp

We apply path counting by weighted programming to quantify the ambiguity of the non-determinism
in a program. Assume we are given a nondeterministic weighted program ğ¶ modeling a discrete op-
timization problem. Each branching { ... } âŠ• { ... } in ğ¶ corresponds to a possible choice to be made
by an optimizer. Further, we assume that all program variables are either initialized explicitly by
the program or read-only. We will refer to such read-only variables as program parameters. Given
an initial parameters state ğœ, the optimization goal is to reach a ï¬nal state ğœ â€² satisfying a given
predicate ğœ‘ that maximizes ğœ â€²(ğ‘Ÿ ) for some ï¬xed special program variable ğ‘Ÿ â€” a â€œrewardâ€, or payoï¬€.
Examples for the predicate ğœ‘ include, e.g. thresholds on time- or energy consumption. A solution
to the optimization problem modeled by ğ¶ corresponds to a determinization ğ¶ â€² obtained from ğ¶ by
replacing every nondeterministic choice by a deterministic one. The reward ğœ â€²(ğ‘Ÿ ) achieved by ğ¶ â€²
on initial state ğœ is called the score of ğ¶ â€² w.r.t. ğœ. We can view the scores as a function ğœŒ : Î£ â†’ N
that only depends on the parameter variables. The solution ğ¶ â€² is called valid if for all parameters
ğœ, it reaches a ï¬nal state satisfying ğœ‘. Note that valid solution are not necessarily optimal.

Given some problem parameters ğœ, we are now interested in determining the rank of a given
solution ğ¶ â€² relative to the optimal solution implicitly encoded in ğ¶, e.g. â€œis ğ¶ â€² among the 3 best
solutions?â€. Assume that ğ¶ â€² is valid. Then ğ¶ â€² is among the best ğ‘› solutions under parameters ğœ iï¬€

( [ğœ‘ âˆ§ ğ‘Ÿ â‰¥ ğœŒ] 1 ) (ğœ) â‰¤ ğ‘› .

wp

ğ¶
J

K

We illustrate determining ranks of solutions by wp-reasoning by means of the Knapsack prob-
lem: Suppose we operate a cloud computer earning money by completing computational tasks.
There are currently 3 tasks in the queue, which take 2, 3, and 4 hours to complete, respectively,
and generate a reward of 5, ğ‘¥, and 8 euros, where ğ‘¥ is a program variable (considered an input pa-
rameter). Our goal is to maximize the total reward earned within 6 hours, i.e. ğœ‘ = (ğ‘¡ â‰¤ 6). Hence,
we have to decide on a subset of the three tasks to stay within this time limit since completing all
three would take 7 hours. This optimization problem is modeled by the program ğ¶ in Fig. 10. We
initialize the variables ğ‘¡ (for time) and ğ‘Ÿ (for reward) by 0 and may subsequently choose a subset
of the available tasks. These choices are modeled by the three nondeterministic branchings.

Choosing the ï¬rst and the third task always yields a valid solution (ğ‘¡ â‰¤ 6) generating an accu-
mulated reward of 13 euros. This solution is modeled by the determinization ğ¶ â€² of ğ¶ in Fig. 10. We
now compute

( [ğ‘¡ â‰¤ 6 âˆ§ ğ‘Ÿ â‰¥ 13] 1 ) = 1 âŠ• [ğ‘¥ â‰¥ 8] 1 âŠ• [ğ‘¥ â‰¥ 13] 1 ,

where we can readily read oï¬€ that ğ¶ â€² is (i) the unique optimal solution if ğ‘¥ < 8, (ii) among the two
best solutions if 8 â‰¤ ğ‘¥ < 13, and (iii) among the three best solutions else.

K

wp

ğ¶
J

Weighted Programming

71

wp

1 âŠ• [ğ‘¥ â‰¥ 8] 1 âŠ• [ğ‘¥ â‰¥ 13] 1

ğ‘Ÿ â‰” 0

((
ğ‘¡ â‰” 0
#
{ ğ‘¡ â‰” ğ‘¡ + 2
{ ğ‘¡ â‰” ğ‘¡ + 3
{ ğ‘¡ â‰” ğ‘¡ + 4

#
ğ‘Ÿ â‰” ğ‘Ÿ + 5 } âŠ• { skip }
ğ‘Ÿ â‰” ğ‘Ÿ + ğ‘¥ } âŠ• { skip }
ğ‘Ÿ â‰” ğ‘Ÿ + 8 } âŠ• { skip }

#
#

#
#

#
[ğ‘¡ â‰¤ 6 âˆ§ ğ‘Ÿ â‰¥ 13] 1

((

ğ‘Ÿ â‰” 0

#

ğ‘¡ â‰” 0
ğ‘¡ â‰” ğ‘¡ + 2
skip
#
ğ‘¡ â‰” ğ‘¡ + 4

#
ğ‘Ÿ â‰” ğ‘Ÿ + 5

#

ğ‘Ÿ â‰” ğ‘Ÿ + 8

#

#

Fig. 10. Program ğ¶ modeling the Knapsack problem (left) and a valid solution ğ¶ â€² (right). The three branchings
model the possible choices (either choosing the respective task or not). The variables ğ‘¡ and ğ‘Ÿ stand for time
and reward, respectively. Variable ğ‘¥ is an input parameter.

