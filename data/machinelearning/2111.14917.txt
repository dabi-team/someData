57

1
2
0
2

v
o
N
9
2

]
L
P
.
s
c
[

1
v
7
1
9
4
1
.
1
1
1
2
:
v
i
X
r
a

A Separation Logic for Negative Dependence

JIALU BAO, Cornell University, USA
MARCO GABOARDI, Boston University, USA
JUSTIN HSU, Cornell University, USA
JOSEPH TASSAROTTI, Boston College, USA

Formal reasoning about hashing-based probabilistic data structures often requires reasoning about random
variables where when one variable gets larger (such as the number of elements hashed into one bucket), the
others tend to be smaller (like the number of elements hashed into the other buckets). This is an example
of negative dependence, a generalization of probabilistic independence that has recently found interesting
applications in algorithm design and machine learning. Despite the usefulness of negative dependence for
the analyses of probabilistic data structures, existing veriÔ¨Åcation methods cannot establish this property for
randomized programs.

To Ô¨Åll this gap, we design LINA, a probabilistic separation logic for reasoning about negative dependence.
Following recent works on probabilistic separation logic using separating conjunction to reason about the
probabilistic independence of random variables, we use separating conjunction to reason about negative
dependence. Our assertion logic features two separating conjunctions, one for independence and one for
negative dependence. We generalize the logic of bunched implications (BI) to support multiple separating
conjunctions, and provide a sound and complete proof system. Notably, the semantics for separating con-
junction relies on a non-deterministic, rather than partial, operation for combining resources. By drawing on
closure properties for negative dependence, our program logic supports a Frame-like rule for negative depen-
dence and monotone operations. We demonstrate how LINA can verify probabilistic properties of hash-based
data structures and balls-into-bins processes.

Additional Key Words and Phrases: Probabilistic programs, separation logic, negative dependence

1 INTRODUCTION
Hashing plays a fundamental role in many probabilistic data structures, from basic hash tables to
more sophisticated schemes such as Bloom Ô¨Ålters. In these applications, a hash function ‚Ñé maps
a universe of possible values, typically large, to a set of buckets, typically small. Hash-based data
structures satisfy a variety of probabilistic guarantees. For instance, we may be interested in the
false positive rate: the probability that a data structure mistakenly identiÔ¨Åes an element as being
stored in a collection, when it was not inserted. We may also be interested in load measures, such
as the probability that a bucket in the data structure overÔ¨Çows. A typical way to analyze these
quantities is to treat random hash functions as balls-into-bins processes. For example, hashing ùëÅ
unique elements into ùêµ bins can be modeled as throwing ùëÅ balls into ùêµ bins, where each bin is
drawn uniformly at random.

While this modeling is convenient, one complication is that the counts of the elements in the
diÔ¨Äerent buckets are not probabilistically independent: one bin containing many elements makes
it more likely that other bins contain few elements. The lack of independence makes it diÔ¨Écult

Authors‚Äô addresses: Jialu Bao, Cornell University, USA; Marco Gaboardi, Boston University, USA; Justin Hsu, Cornell Uni-
versity, USA; Joseph Tassarotti, Boston College, USA.

Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for proÔ¨Åt or commercial advantage and that copies bear this notice and
the full citation on the Ô¨Årst page. Copyrights for third-party components of this work must be honored. For all other uses,
contact the owner/author(s).
¬© 2022 Copyright held by the owner/author(s).
2475-1421/2022/1-ART57
https://doi.org/10.1145/3498719

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

 
 
 
 
 
 
57:2

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

to reason about multiple bins, for instance bounding the number of empty bins. Moreover, many
common tools for analyzing probabilistic processes, like concentration bounds, usually require in-
dependence. This subtlety has also been a source of problems in pen-and-paper analyses of proba-
bilistic data structures. For instance, the standard analysis of the Bloom Ô¨Ålter bounds the number
of occupied bins in order to bound the false positive rate. The original version of this analysis
presented by Bloom [1970], and also repeated in many papers, assumes that the bin counts are
independent. However, Bose et al. [2008] pointed out that this assumption is incorrect, and in fact
the claimed upper-bound on the false-positive rate is actually a lower bound. Proving a correct
bound on the false-positive rate required a substantially more complicated argument; recently,
Gopinathan and Sergey [2020] mechanized a correct, but complex proof in Coq.

We aim to develop a simpler method to formally reason about hash-based data structures and

balls-into-bins processes, drawing on a key concept in probability theory: negative dependence.

Towards a simpler analysis: negative dependence. To study balls-into-bins processes and other

phenomena, researchers in probability theory have developed a theory of negative dependence [Pemantle
2000]. Intuitively, variables are negatively dependent if when one is larger, then the others tend to
be smaller. The counts of the bins in the balls-into-bins process is a motivating example of negative
dependence.

While there are multiple incomparable deÔ¨Ånitions of negative dependence, Joag-Dev and Proschan

[1983] proposed a notion called negative association (NA) that has many good probabilistic proper-
ties. For instance, the bins‚Äô counts in the balls-into-bins process satisÔ¨Åes NA, and NA‚Äôs closure prop-
erties enable simple, calculation-free proofs of NA. More intriguingly, as Dubhashi and Ranjan
[1998] identiÔ¨Åed, sums of NA variables satisfy some concentration bounds that usually assume
probabilistic independence, including the widely-used ChernoÔ¨Ä bounds.

Our goal: formal reasoning about negative dependence. From a veriÔ¨Åcation perspective, the clo-
sure properties suggest a compositional method for proving NA in probabilistic programs. In this
work, we develop a separation logic for negative dependence, building on a separation logic for
probabilistic programs called PSL [Barthe et al. 2020]. Like all separation logics, PSL is a program
logic where assertions are drawn from the logic of bunched implications (BI) [O‚ÄôHearn and Pym
1999], a substructural logic. In PSL, the separating conjunction ‚àó states that two sets of variables
are probabilistically independent, a common and useful property when analyzing probabilistic
programs.

We aim to extend the assertions of PSL so that they can describe both independence and negative

dependence. There are three main diÔ¨Éculties:

‚Ä¢ To support reasoning about negative dependence, the assertion logic needs to be extended
with a second separating conjunction that is weaker than the separating conjunction of PSL.
It is easy to extend the syntax of formulas, but the extended logic should also enjoy good
metatheoretical properties like BI does, including a sound and complete proof system.

‚Ä¢ The standard resource semantics of BI [Pym 2002], based on partial commutative monoids
(PCMs), is not expressive enough to model negative association because two variables with
given marginal distributions can be negatively associated in more than one way.

‚Ä¢ DeÔ¨Åning the semantics of separating conjunction to capture NA is surprisingly challenging.
Straightforward deÔ¨Ånitions fail to satisfy expected properties, like associativity of separating
conjunction.

Beyond the assertions, it is also unclear how to integrate negative association with the proof rules
of PSL. In particular, to view negative association as a kind of separation, our program logic should
have an analogue of the Frame rule for NA.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:3

Contributions and outline. In this paper, we oÔ¨Äer the following contributions.

‚Ä¢ A novel logic ùëÄ-BI that extends BI with multiple separating conjunctions, related by a pre-
order. Following Docherty [2019], models of ùëÄ-BI allow two states to be combined into a
single state in more than one way (Section 3). We develop a proof system for ùëÄ-BI, and use
Docherty‚Äôs duality-theoretic approach to prove soundness and completeness.

‚Ä¢ A probabilistic model of ùëÄ-BI that can capture both the independence and negative associ-

ation (Section 4). There are two interesting aspects of our model:
‚Äì We crucially use the ‚Äúnon-deterministic‚Äù combination of resources allowed by Docherty‚Äôs
semantics of BI. While this semantics was originally used to simplify the metatheory of
BI, our model shows that the added Ô¨Çexibility can enable new applications of the logic.

‚Äì Our model relies on a novel notion called PNA that is more expressive than Joag-Dev and Proschan

[1983]‚Äôs NA. The generalization is needed to satisfy the conditions for an ùëÄ-BI model.
Moreover, the closure properties and useful consequences of NA continue to hold for our
generalization.

‚Ä¢ A program logic, LINA (Logic of Independence and Negative Association), extending PSL
with ùëÄ-BI-assertions and a new negative-association Frame rule (Section 5). Being a conser-
vative extension of PSL, the proof rules of PSL remain valid in LINA. We demonstrate our
program logic by proving negative association and related properties on several case studies
(Section 6). For example, using NA, it is possible to give a signiÔ¨Åcantly simpler veriÔ¨Åcation of
the false positive rate of the Bloom Ô¨Ålter. Another example‚Äîan analysis of a repeated balls-
into-bins process motivated by distributed computing‚Äîinvolves a loop with a probabilistic
guard, and requires reasoning about conditional distributions.

We discuss related work in Section 7, and conclude in Section 8.

2 OVERVIEW AND KEY IDEA

In this section, we introduce negative association as a tool for analyzing hashing-based algorithms.
We use Bloom Ô¨Ålters, a hash-based data structure, as a motivating example. After sketching a
standard proof applying negative association to Bloom Ô¨Ålters, we will show how the same analysis
can be formalized in LINA.

2.1 Background on negative association
Negative association is a property of a set of random variables, which intuitively says that when
some variables are larger, we expect the others to be smaller. It is formalized as follows:

DeÔ¨Ånition 2.1 (Negative Association (NA)). Let ùëã1, . . . ùëãùëõ be random variables. The set {ùëãùëñ }ùëñ is
negatively associated (NA) if for every pair of subsets ùêº, ùêΩ ‚äÜ {1, . . . , ùëõ} such that ùêº ‚à© ùêΩ = ‚àÖ, and
every pair of both monotone or both antitone functions1 ùëì : R|ùêº | ‚Üí R and ùëî : R|ùêΩ | ‚Üí R, where
ùëì , ùëî is either lower bounded or upper bounded, we have:

E[ùëì (ùëãùëñ, ùëñ ‚àà ùêº ) ¬∑ ùëî(ùëã ùëó, ùëó ‚àà ùêΩ )] ‚â§ E[ùëì (ùëãùëñ, ùëñ ‚àà ùêº )] ¬∑ E[ùëî(ùëã ùëó, ùëó ‚àà ùêΩ )]

We can view NA as generalizing independence: a set of independent random variables is NA
because equality holds. NA also strengthens negative covariance, a simpler notion of negative de-
ùëñ ‚àà[ùëõ ] E[ùëãùëñ].
pendence that requires E[

ùëñ ‚àà[ùëõ ] ùëãùëñ ] ‚â§

The survey paper by Dubhashi and Ranjan [1998] explains several properties of NA random
variables useful for algorithm analysis. First, some standard theorems about sums of independent

√é

√é

1In the following, we will consistently use monotone to mean monotonically non-decreasing and antitone to mean mono-
tonically non-increasing.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:4

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

random variables apply more generally to sums of NA random variables. In particular, the widely-
used ChernoÔ¨Ä bound, which intuitively says that the sum of independent random variables is close
to the expected value of the sum with high probability, holds also for NA variables. In addition,
NA is preserved by some common operations on random variables. Thus, we can easily prove that
a set of random variables satisÔ¨Åes NA if they are generated by applying NA-preserving operations
to a few basic, building-block random variables:

Theorem 2.2. The random variables {ùëãùëñ }ùëñ in the following cases are negatively associated:
(1) Let {ùëã1, . . . , ùëãùëõ} be Bernoulli random variables such that
(2) Let ùëãùëñ be the ùëñ-th entry in the vector ùëã , where ùëã is a uniformly random permutation of a Ô¨Ånite,

ùëãùëñ = 1.

nonempty set ùê¥.

(3) Let {ùëã1, . . . , ùëãùëõ} be independent random variables.

√ç

In particular, the Ô¨Årst case of this theorem implies that if we draw a length-ùëõ one-hot vector, i.e.,
a vector that has one entry being one and all remaining entries being zero, uniformly at random,
then the entries of the vector satisfy negative association.

The following theorem states two key closure properties of NA random variables.

Theorem 2.3. The set ùëÜ of random variables in the following cases are negatively associated:
(1) Let ùëá be negatively associated, and let ùëÜ be a non-empty subset of ùëá .
(2) Let ùëá and ùëà be two sets of negatively associated random variables such that every ùëã ‚àà ùëá and

ùëå ‚àà ùëà is independent of each other. Let ùëÜ = ùëá ‚à™ ùëà .

(3) Let {ùëã1, . . . ùëãùëõ} be negatively-associated, and ùêº1, . . . , ùêºùëö be a partition of the set {1, . . . , ùëõ}. For
each 1 ‚â§ ùëó ‚â§ ùëö, let ùëìùëó : R|ùêº ùëó | ‚Üí R be monotone. Let ùëÜ = {ùëì1 (ùëãùëò, ùëò ‚àà ùêº1), . . . , ùëìùëö (ùëãùëò, ùëò ‚àà ùêºùëö)}.

The Ô¨Årst case shows that negative association is preserved if we discard random variables, while
the second case allows us to join two independent sets of negatively associated random variables to
form a larger negatively associated set. Finally, the third case guarantees that negative association
is preserved under applying monotone maps on disjoint subsets of variables.

2.2 Example: Bloom filters

We demonstrate how NA and its closure properties can be used to analyze Bloom Ô¨Ålters. A Bloom
Ô¨Ålter is a space-eÔ¨Écient probabilistic data structure for storing a set of items from a universe ùëà .
An ùëÅ -bit Bloom Ô¨Ålter consists of a length-ùëÅ array ùëèùëôùëúùëúùëö holding zero-one entries. We assume
there is a family A of hash functions mapping ùëà to {0, . . . , ùëÅ ‚àí 1} such that for any ùë• ‚àà ùëà and
any bucket ùëò, Pùëì ‚ààA (ùëì (ùë•) = ùëò) = 1/ùëÅ . Let ùëô1, . . . , ùëôùêª be a collection of hash functions drawn from
A. We assume the hash functions are independent, meaning the collection of variables {ùëôùëñ (ùë•) |
ùë• ‚àà ùëà , ùëñ ‚àà {1, . . . , ùêª }} are mutually independent. To add an item ùë• ‚àà ùëà to the Ô¨Ålter, we compute
ùëô1(ùë•), . . . , ùëôùêª (ùë•) to get ùêª positions in the bit array and then set the bits at each of these positions
to 1. To check if an item ùë¶ is in the Ô¨Ålter, we check whether the bits at positions ùëô1 (ùë¶), . . . , ùëôùêª (ùë¶) in
ùëèùëôùëúùëúùëö are all 1. If they are, the item is said to be in the Ô¨Ålter, but if any is 0, then the item is not
in the Ô¨Ålter. This membership test may suÔ¨Äer from false positives, i.e., it may show that an item
ùë¶ is in the Ô¨Ålter even when ùë¶ was never added to the Ô¨Ålter. This can happen because with hash
collisions, other items added to the Bloom Ô¨Ålter could set all the bits at locations ùëô1 (ùë¶), . . . , ùëôùêª (ùë¶)
to 1. A basic quantity of interest is the false positive rate: the probability that a Bloom Ô¨Ålter reports
a false positive.

Our goal is to bound an ùëÅ -bit Bloom Ô¨Ålter‚Äôs false positive rate after ùëÄ distinct items are added,
assuming that it uses ùêª independent hash functions. Here, we brieÔ¨Çy sketch a standard proof
where negative association plays a key role. Let ùë• be some data item not in the set, and let FP be

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:5

the event the Bloom Ô¨Ålter returns a false positive on ùë•. We split the analysis of the probability of
FP into two steps.

For the Ô¨Årst step, we condition on ùúå, the fraction of bits in ùëèùëôùëúùëúùëö that are set to 1 after all
items have been added. With ùúå Ô¨Åxed to some value, for each hash function ùëôùõº the probability that
ùëèùëôùëúùëúùëö[ùëôùõº (ùë•)] = 1 is ùúå. For ùë• to be a false positive, we must have ùëèùëôùëúùëúùëö[ùëôùõº (ùë•)] = 1 for all ùõº. Since
ùëô1, . . . , ùëôùêª are independent hash functions, this occurs with probability ùúåùêª .

The next step is to show that with high probability, ùúå lies within a narrow range around its
expected value. Before showing how to prove this, let us Ô¨Årst see why such a bound is useful. Let ùúá
be the expected value of ùúå. Suppose we have that for some small ùúñ and ùõø that Pr[ùúå ‚â§ ùúá +ùúñ] ‚â• 1 ‚àíùõø.
Then, by the law of total probability we have:

Pr[FP] ‚â§ Pr[FP | ùúå ‚â§ ùúá + ùúñ] + Pr[ùúå > ùúá + ùúñ]

‚â§ (ùúá + ùúñ)ùêª + ùõø

where the second line follows from the calculation of the probability of FP when conditioned on
ùúå.

Now, we turn to the question of how to obtain a bound of the form Pr[ùúå ‚â§ ùúá + ùúñ] < 1 ‚àí ùõø. As
mentioned in Section 1, a common (incorrect) analysis of ùúå assumes that the entries of ùëèùëôùëúùëúùëö are
independent, and then applies a ChernoÔ¨Ä bound. However, the entries in ùëèùëôùëúùëúùëö, {ùëèùëôùëúùëúùëö[ùõΩ]}ùõΩ, are
not independent‚Äîwhat we can actually prove is that are negatively associated, which fortunately
still allows us to apply the ChernoÔ¨Ä bound, as stated later in Theorem 6.1.

‚Ñé ‚Üê 0
while ‚Ñé < ùêª do

ùëèùëôùëúùëúùëö ‚Üê ùëßùëíùëüùëú (ùëÅ );
ùëö ‚Üê 0;
while ùëö < ùëÄ do

To see that the {ùëèùëôùëúùëúùëö[ùõΩ]}ùõΩ are NA, consider the program in
Figure 1, which models the process of adding ùëÄ distinct items to
the Bloom Ô¨Ålter. Because the ùëÄ items are distinct, we model the
hash functions as independently, randomly sampling hash values
for each item as they are added, a standard model used in the anal-
ysis of hashing data structures [Mitzenmacher and Upfal 2005].
That is, we encode the hashing step as sampling a one-hot vec-
tor with the command ùëú‚Ñé and storing it in the variable ùëèùëñùëõ, where
the hot bit of the vector ùëèùëñùëõ represents the selected position. To set
the corresponding position in the Ô¨Ålter to 1, we update ùëèùëôùëúùëúùëö to
be ùëèùëôùëúùëúùëö || ùëèùëñùëõ, the bitwise-or of the current array and the sampled
one-hot array. To show that {ùëèùëôùëúùëúùëö[ùõΩ]}ùõΩ are NA, we can reason
using the closure properties. Initially, ùëèùëôùëúùëúùëö is set to ùëßùëíùëüùëú (ùëÅ ). Any
set of constant random variables is independent, and hence negatively associated by Theorem 2.3.
Next, when an item is added, the ùëèùëñùëõ array is NA by Theorem 2.2. Because ùëèùëñùëõ is sampled indepen-
dently of ùëèùëôùëúùëúùëö, the set {ùëèùëôùëúùëúùëö[ùõΩ]}ùõΩ ‚à™ {ùëèùëñùëõ[ùõΩ]}ùõΩ is NA. The bitwise-or operation || is monotone,
so again by Theorem 2.3, the array ùë¢ùëùùëë is negatively associated, thereby showing that ùëèùëôùëúùëúùëö is
NA at the end of each loop iteration.

ùëèùëñùëõ $‚Üê ùëú‚Ñé( [ùëÅ ]);
ùë¢ùëùùëë ‚Üê ùëèùëôùëúùëúùëö || ùëèùëñùëõ;
ùëèùëôùëúùëúùëö ‚Üê ùë¢ùëùùëë;
‚Ñé ‚Üê ‚Ñé + 1;

Fig. 1. Example: Bloom filter

ùëö ‚Üê ùëö + 1

2.3 Representing negative association with separating conjunction

Now that we have seen some properties of negative association and how they can be used to
analyze the Bloom Ô¨Ålter, we give a high-level explanation of how these ideas are formalized in
LINA, a novel program logic that is a core contribution of our work. As mentioned in Section 1,
an earlier separation logic PSL has a separating conjunction ‚àó which is interpreted as probabilistic
independence. That is, a program state satisÔ¨Åes ùëÉ ‚àó ùëÑ if its randomized program variables can
be split so that one subset satisÔ¨Åes ùëÉ, another satisÔ¨Åes ùëÑ, and the distributions of these two sets
are independent. LINA augments PSL with a weaker separating conjunction ‚äõ modeling negative

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:6

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

association. The precise deÔ¨Ånition of negative association needs to be modiÔ¨Åed to form a proper
model of bunched implications, but for now, one can informally think of ùëÉ ‚äõ ùëÑ as meaning the
random variables can be split into two sets negatively associated with each other that satisfy ùëÉ
and ùëÑ respectively.

The proof rules of LINA can be used to prove NA by applying closure properties to building-
block NA-distributions, much like in our proof sketch above for the Bloom Ô¨Ålter. For example, we
can derive a rule that captures NA of entries in a one-hot distribution:

‚ä¢{‚ä§} ùë• $‚Üê ùëú‚Ñé(ùëõ) { ùëõ‚äõ

ùõΩ=0

hùë• [ùõΩ]i} ,

where the assertion hùë¶i means that the program variable ùë¶ is distributed according to some un-

speciÔ¨Åed probability distribution, and ‚äõ is an iterated version of the ‚äõ separating conjunction.

Thus, the post-condition here says that all of the entries of the ùë• vector are negatively associated.
Meanwhile, since NA is closed under monotone maps, we obtain a form of separation logic‚Äôs

frame rule for ‚äõ:

‚ä¢ {ùúô } ùëê {ùë¶ ‚àº ùëì (ùëã )}

ùëì monotone

(side conditions omitted)

‚ä¢ {ùúô ‚äõ ùúÇ} ùëê {hùë¶i ‚äõ ùúÇ}

,

where ùëã is a set of variables contained in any program states satisfying ùúô, ùëì is a monotone func-
tion mapping ùëã to a variable ùë¶, and ùúÇ is an assertion on some other random variables that are
negatively associated with those satisfying ùúô. (We describe a complete version of this rule with
all side conditions later, in Section 5.4.) Using this rule, we can show monotone vector operations
like || in the Bloom Ô¨Ålter example preserve negative associativity. For example, we can derive:

‚ä¢{ ùëõ‚äõ

ùõΩ=0

hùë• [ùõΩ]i ‚äõ

ùëõ‚äõ

ùõæ=0

hùë¶ [ùõæ]i} ùëß ‚Üê ùë• || ùë¶ { ùëõ‚äõ

ùõΩ=0

hùëß [ùõΩ]i} ,

which says that if the union of entries in ùë• and entries in ùë¶ satisfy NA, then entries in ùëß = ùë• || ùë¶
also satisfy NA.

We now sketch how to formalize the proof that {ùëèùëôùëúùëúùëö[ùõΩ]}ùõΩ in the Bloom Ô¨Ålter are NA; we defer
the rest of the proof of this example to Section 6. The basic idea is to establish ‚äõùëÅ

ùõΩ=0 hùëèùëôùëúùëúùëö[ùõΩ]i
as a loop invariant. When an item is added in the loop, we combine the frame rule with the
one-hot sampling vector rule to get that the ùëèùëñùëõ vector is negatively associated, thus showing:

ùõæ=0 hùëèùëñùëõ[ùõæ]i. Applying the rule for || above, we obtain that ùë¢ùëùùëë is neg-

ùõΩ=0 hùëèùëôùëúùëúùëö[ùõΩ]i ‚äõ ‚äõùëÅ
‚äõùëÅ
atively associated, ‚äõùëÅ

ùõΩ=0hùë¢ùëùùëë [ùõΩ]i. At that point ùë¢ùëùùëë is assigned to ùëèùëôùëúùëúùëö, restoring the loop

invariant.

3 THE LOGIC ùëÄ-BI

Having seen the role of negative association in analyzing randomized algorithms and how its prop-
erties correspond to rules in LINA, we now show how negative association can be interpreted
by separating conjunction. As a Ô¨Årst step, we extend the logic of bunched implications (BI), the
assertion logic underlying separation logic, to support multiple forms of separating conjunction
simultaneously, related by a pre-order. Our motivation to design this logic is to reason about in-
dependence and negative association in one logic and capture that independence implies negative
association, but the logic is more general and accommodates other potentially interesting models.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:7

3.1 The syntax and proof rules
Let AP be a set of atomic propositions, and (ùëÄ, ‚â§) be a Ô¨Ånite pre-order. The formula in the logic
of ùëÄ-bunched implications (ùëÄ-BI) has the following grammar:

ùëÉ, ùëÑ ::= ùëù ‚àà AP | ‚ä§ | ùêºùëö ‚ààùëÄ | ‚ä• | ùëÉ ‚àß ùëÑ | ùëÉ ‚à® ùëÑ | ùëÉ ‚Üí ùëÑ | ùëÉ ‚àóùëö ‚ààùëÄ ùëÑ | ùëÉ ‚àí‚àóùëö ‚ààùëÄ ùëÑ.
ùëÄ-BI associates each element of ùëÄ with a separating conjunction ‚àóùëö, a corresponding multiplica-
tive identity ùêºùëö and a separating implication ‚àí‚àóùëö. The proof system for M-BI is based on the proof
system for BI, with indexed copy of rules for each separation, and in addition has ‚àó-Weakening
rules. We present the full Hilbert-style proof system in Appendix B; most of the rules are the same
as in the proof system for BI. Here, we only comment on the new rules.

The ‚àó-Weakening rule says that if ùëö1 ‚â§ ùëö2, then the assertion ùëÉ ‚àóùëö1 ùëÑ implies ùëÉ ‚àóùëö2 ùëÑ.

ùëö1 ‚â§ ùëö2
ùëÉ ‚àóùëö1 ùëÑ ‚ä¢ ùëÉ ‚àóùëö2 ùëÑ

‚àó-Weakening

We can derive analogous weakening rules for separating implications and multiplicative identities,
in the reverse direction.

Lemma 3.1. The following rules are derivable in ùëÄ-BI:

ùëö1 ‚â§ ùëö2
ùëÉ ‚àí‚àóùëö2 ùëÑ ‚ä¢ ùëÉ ‚àí‚àóùëö1 ùëÑ

‚àí‚àó-Weakening

ùëö1 ‚â§ ùëö2
ùêºùëö2 ‚ä¢ ùêºùëö1

UnitWeakening

3.2 Semantics
As is standard with bunched logics [Pym et al. 2004], we give a Kripke style semantics to ùëÄ-BI. We
will deÔ¨Åne a structure called ùëÄ-BI frame, and then deÔ¨Åne ùëÄ-BI models and the satisfaction rules
on ùëÄ-BI models.

An ùëÄ-BI frame is a collection of BI frames satisfying some frame conditions. While BI frames
are often presented as partial, pre-ordered commutative monoids over states, we need the more
general presentation due to Docherty [2019], where the binary operation returns a set of states,
instead of at most one state. Such binary operations can be deterministic (returning a set of at
most one element) or non-deterministic. The admission of non-deterministic models was originally
motivated by the metatheory; somewhat surprisingly, it is also a crucial ingredient in deÔ¨Åning the
negative association model we will see in Section 4.

DeÔ¨Ånition 3.2 (BI Frame). A (Down-Closed) BI frame is a structure X = (ùëã, ‚äë, ‚äï, ùê∏) such that ‚äë
is a pre-order on the set of states ùëã , ‚äï : ùëã 2 ‚Üí P (ùëã ) is a binary operation, and ùê∏ ‚äÜ ùëã , satisfying
following frame conditions (with outermost universal quantiÔ¨Åcation omitted for readability):

(Down-Closed)
(Commutativity)
(Associativity)
(Unit Existence)
(Unit Coherence)
(Unit Closure)

ùëß ‚àà ùë• ‚äï ùë¶ ‚àß ùë• ‚Ä≤ ‚äë ùë• ‚àß ùë¶‚Ä≤ ‚äë ùë¶ ‚Üí ‚àÉùëß‚Ä≤(ùëß‚Ä≤ ‚äë ùëß ‚àß ùëß‚Ä≤ ‚àà ùë• ‚Ä≤ ‚äï ùë¶‚Ä≤);
ùëß ‚àà ùë• ‚äï ùë¶ ‚Üí ùëß ‚àà ùë¶ ‚äï ùë•;
ùë§ ‚àà ùë° ‚äï ùëß ‚àß ùë° ‚àà ùë• ‚äï ùë¶ ‚Üí ‚àÉùë† (ùë† ‚àà ùë¶ ‚äï ùëß ‚àß ùë§ ‚àà ùë• ‚äï ùë†);
‚àÉùëí ‚àà ùê∏ (ùë• ‚àà ùëí ‚äï ùë•);
ùëí ‚àà ùê∏ ‚àß ùë• ‚àà ùë¶ ‚äï ùëí ‚Üí ùë¶ ‚äë ùë•;
ùëí ‚àà ùê∏ ‚àß ùëí ‚äë ùëí ‚Ä≤ ‚Üí ùëí ‚Ä≤ ‚àà ùê∏.

Since all frames we consider in this paper will be Down-Closed, we often abbreviate Down-
Closed BI frame as just BI frame. The (Commutativity), (Associativity) and (Unit Existence) condi-
tions capture the properties of commutative monoids, and the (Down-Closed) condition ensures
that the binary operation is coherent with the pre-order. Properties (Associativity) and (Commuta-
tivity) are generalizations of the usual algebraic properties to accommodate the non-determinism.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:8

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

The three Unit frame conditions ensure that the set ùê∏ behaves like a set of units, and satisÔ¨Åes
various closure properties under the binary operation and the pre-order.

We can now deÔ¨Åne ùëÄ-BI frame to be a collection of BI frames sharing the same set of states and

pre-order, with ordered binary operations:

DeÔ¨Ånition 3.3 (ùëÄ-BI Frame). An ùëÄ-BI frame is a structure X = (ùëã, ‚äë, ‚äïùëö ‚ààùëÄ , ùê∏ùëö) such that for

each ùëö, (ùëã, ‚äë, ‚äïùëö, ùê∏ùëö) is a BI frame, and there is a preorder ‚â§ on ùëÄ satisfying:

(Operation Inclusion) ùëö1 ‚â§ ùëö2 ‚Üí ùë• ‚äïùëö1 ùë¶ ‚äÜ ùë• ‚äïùëö2 ùë¶.

The (Operation Inclusion) condition together with the frame conditions of BI also imply an

inclusion on unit sets:

Lemma 3.4. Let X be an ùëÄ-BI frame. If ùëö1 ‚â§ ùëö2 then ùê∏ùëö2 ‚äÜ ùê∏ùëö1.

Proof. Let ùëí2 ‚àà ùê∏ùëö2. By (Unit Existence), there exists ùëí1 ‚àà ùê∏ùëö1 such that ùëí2 ‚àà ùëí1 ‚äïùëö1 ùëí2. By
(Operation Inclusion), ùëí2 ‚àà ùëí1 ‚äïùëö2 ùëí2, so (Unit Coherence) implies that ùëí1 ‚äë ùëí2, and then (Unit
(cid:3)
Closure) implies ùëí2 ‚àà ùê∏ùëö1 . So ùê∏ùëö2 ‚äÜ ùê∏ùëö1.

To obtain a BI model over a given BI frame, we must provide a valuation, which deÔ¨Ånes which
atomic propositions hold at each states in the frame. For the soundness of the proof system, it is
important that the valuation is persistent: any formula true at a state remains true at any larger
state. Formally, we deÔ¨Åne ùëÄ-BI models as follows.

DeÔ¨Ånition 3.5 (Valuation and model). A persistent valuation is a map V : AP ‚Üí P (ùëã ) such
that, for all ùëÉ ‚àà AP, if ùë• ‚àà V (ùëÉ) and ùë• ‚äë ùë¶ then ùë¶ ‚àà V (ùëÉ). An ùëÄ-BI model (X, V) is an ùëÄ-BI
frame X = (ùëã, ‚äë, ‚äïùëö, ùê∏ùëö) associated with a persistent valuation V on it.

Next, we deÔ¨Åne which ùëÄ-BI formula are true at a state in a ùëÄ-BI model.

DeÔ¨Ånition 3.6. On model (X, V), we deÔ¨Åne the satisfaction relation |=V between states in X

and ùëÄ-BI formula: for ùë• ‚àà X

ùë• |=V ùëù
ùë• |=V ‚ä§
ùë• |=V ùêºùëö
ùë• |=V ‚ä•
ùë• |=V ùëÉ ‚àß ùëÑ
ùë• |=V ùëÉ ‚à® ùëÑ
ùë• |=V ùëÉ ‚Üí ùëÑ
ùë• |=V ùëÉ ‚àóùëö ùëÑ
ùë• |=V ùëÉ ‚àí‚àóùëö ùëÑ iÔ¨Ä for all ùë¶ and ùëß such that ùëß ‚àà ùë• ‚äïùëö ùë¶, if ùë¶ |=V ùëÉ then ùëß |=V ùëÑ

iÔ¨Ä ùë• ‚àà V (ùëù)
iÔ¨Ä True
iÔ¨Ä ùë• ‚àà ùê∏ùëö
iÔ¨Ä False
iÔ¨Ä ùë• |=V ùëÉ and ùë• |=V ùëÑ
iÔ¨Ä ùë• |=V ùëÉ or ùë• |=V ùëÑ
iÔ¨Ä for all ùë¶ such that ùë• ‚äë ùë¶, if ùë¶ |=V ùëÉ then ùë¶ |=V ùëÑ
iÔ¨Ä there exist ùë• ‚Ä≤, ùë¶, and ùëß with ùë• ‚Ä≤ ‚äë ùë• and ùë• ‚Ä≤ ‚àà ùë¶ ‚äïùëö ùëß such that ùë¶ |=V ùëÉ and ùëß |=V ùëÑ

We say that a formula ùëÉ is valid in the model (X, V), written as X |=V ùëÉ, iÔ¨Ä ùë• |=V ùëÉ for all
ùë• ‚àà X. We also say that ùëÉ is valid if and only if ùëÉ is valid in all models and write that as |= ùëÉ.
Finally, we write ùëÉ |= ùëÑ if and only if for any model (X, V), X |=V ùëÉ implies X |=V ùëÑ.

We prove the following theorem in Appendix E.

Theorem 3.7. Let ùëÉ and ùëÑ be any two ùëÄ-BI formulas. Then ùëÉ |= ùëÑ iÔ¨Ä ùëÉ ‚ä¢ ùëÑ.

The reverse direction of (soundness) is straightforward by induction on the proof derivation,
but the forward direction (completeness) is less obvious; we use the duality-theoretic framework
proposed by Docherty [2019] to establish this theorem.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:9

3.3 Potential models
Our design of ùëÄ-BI is mainly motivated by our intended model of negative association and prob-
abilistic independence, which we will see in the next section, but the logic ùëÄ-BI is quite Ô¨Çexible
and we can see other natural models. Here we outline three models, inspired by the heap model
of separation logic [Reynolds 2001].

Hierarchical heaps. In the heap model of separation logic, heaps are partial maps ‚Ñé : N ‚áÄ Val
from integer addresses to values, and heap combination ‚ó¶‚Ñéùëíùëéùëù is a partial binary operation that
takes the union if the two heaps have disjoint domains, and is not deÔ¨Åned otherwise. In many
systems, memory addresses are partitioned into larger units, for instance pages. We can deÔ¨Åne
another partial binary operation ‚ó¶ùëùùëéùëîùëí that takes the union if the two heaps have disjoint domains
and are deÔ¨Åned on disjoint pages. Then, ‚Ñé1 ‚ó¶ùëùùëéùëîùëí ‚Ñé2 ‚äÜ ‚Ñé1 ‚ó¶‚Ñéùëíùëéùëù ‚Ñé2, so we can build a model of
ùëÄ-BI on the two-point pre-order. The two separating conjunctions ‚àó‚Ñéùëíùëéùëù and ‚àóùëùùëéùëîùëí then describe
heap and page separation respectively, which could be useful for reasoning about which memory
accesses may require a page-table lookup.

Strong separation logic. Heaps in separation logic can store values, but also addresses of other
locations. In the standard heap model, two separate heaps must have disjoint domains but may
store common addresses, i.e., they may hold dangling pointers to the same locations. Searching for
a separation logic with better decidability properties, Pagel and Zuleger [2021] proposed a notion
of strong separation logic, where two strongly-separated heaps can only hold common addresses
that are already stored in stack variables. The resulting form of separation can be modeled by
a separating conjunction ‚àóùë†ùë° , and the standard (weak) form of separation can be modeled by a
separating conjunction ‚àóùë§ùëò . Since strong separation implies weak separation, we can again build
a model of ùëÄ-BI supporting both conjunctions on the two-point pre-order.

‚àó(‚Ñé,ùëù)

Tagged memory. In some security-focused architec-
tures, pointers contain an address as well as a tag, in-
dicating capabilities that may be performed with that
piece of memory. To reason about these machines, we
can consider a resource frame where states are pairs
of (‚Ñé, ùëù), where ‚Ñé is a heap and ùëù is a permission (say
shared access, or exclusive access). We can then consider
four kinds of separation taking all combinations of heaps
aliasing/non-aliasing, and permissions compatible/incompatible. The result is a ùëÄ-BI frame, with
the lattice of separating conjunctions depicted in Figure 2. Assertions in models on this frame can
reason about all four kinds of separation, where ‚àó‚àí degenerates to the standard conjunction ‚àß.

Fig. 2. The pre-order for ‚àóùëö

‚àó‚àí

‚àó‚Ñé

‚àóùëù

4 A MODEL OF NEGATIVE ASSOCIATION AND INDEPENDENCE

In this section, we will present a ùëÄ-BI model for reasoning about both probabilistic independence
and negative association. Barthe et al. [2020] proposed a BI model that captures probabilistic in-
dependence, developed a program logic (PSL) to reason about independence in probabilistic pro-
grams. We will construct a BI model for negative association and combine it with the PSL model to
obtain a 2-BI model for both probabilistic independence and negative association, where 2 = {1, 2}
is the two-point set with pre-order 1 ‚â§ 2.

One may wonder if it is a simple exercise to replace the independence semantics of the separat-
ing conjunction in PSL by a semantics that capture negative association, but there are technical
challenges. As we will show in Section 4.2, two intuitive BI model deÔ¨Ånitions fail to satisfy all
frame conditions. To overcome the diÔ¨Éculties, in Section 4.3 we deÔ¨Åne a new notion of negative

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:10

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

association that can express negative dependence of various strengths, and then deÔ¨Åne a model
based on our new notion.

4.1 Preliminaries and the PSL model

We need to introduce some notation to deÔ¨Åne the models.

First, we represent program states as memories. Let the set of all program variables be Var, and
the set of all possible values be Val. For any Ô¨Ånite set of variables ùëÜ ‚äÜ Var, a memory on ùëÜ is a map
ùëÜ ‚Üí Val, and Mem[ùëÜ] denotes the set of memories on ùëÜ. For disjoint sets of variables ùëÜ,ùëá ‚äÜ Var,
and ùëö1 ‚àà Mem[ùëÜ], ùëö2 ‚àà Mem[ùëá ], we deÔ¨Åne ùëö1 ‚ä≤‚ä≥ ùëö2 to be the union of ùëö1, ùëö2.

Now we will introduce probabilistic memories. For a real-valued function ùëì , we say that ùë• is in
the support of ùëì if ùëì (ùë•) ‚â† 0. A countable distribution on a set ùëã is a countable support function
ùë• ‚ààùëã ùúá(ùë•) = 1. Let D (ùëã ) denote the set of countable distributions on
ùúá : ùëã ‚Üí [0, 1] such that
ùëã . A probabilistic memory on variables ùëÜ is a distribution over Mem[ùëÜ], so the set of probabilistic
memories on ùëÜ is D (Mem[ùëÜ]).

√ç

Next, we will need some constructions on distributions. A family of special distributions in
D (Mem[ùëÜ]) is Dirac distributions: for any ùë• ‚àà Mem[ùëÜ], the Dirac distribution ùõø (ùë•) puts all the
weight on ùë•, that is, for any ùë¶ ‚àà Mem[ùëÜ], ùõø (ùë•) (ùë¶) = 1 if ùë• = ùë¶, and ùõø (ùë•) (ùë¶) = 0 otherwise. For any
sets of variables ùëÜ ‚äÜ ùëÜ ‚Ä≤, we deÔ¨Åne the projection map ùúãùëÜ‚Ä≤,ùëÜ to map a distribution ùúá on Mem[ùëÜ ‚Ä≤] to
a distribution on Mem[ùëÜ]: for any ùë• ‚àà Mem[ùëÜ],

ùúãùëÜ‚Ä≤,ùëÜ ùúá(ùë•) :=

ùúá(ùë• ‚Ä≤),

ùë• ‚Ä≤ ‚ààMem[ùëÜ‚Ä≤ ] and pùëÜ (ùë• ‚Ä≤)=ùë•
√ï

where pùëÜ (ùë• ‚Ä≤) is ùë• ‚Ä≤ restricted on ùëÜ. Often ùëÜ ‚Ä≤ is clear, so we just write ùúãùëÜ for ùúãùëÜ‚Ä≤,ùëÜ . Then, we can
formally deÔ¨Åne independence of variables in a distribution:

DeÔ¨Ånition 4.1 (Independence). For any ùúá ‚àà D (Mem[ùëÜ]), and disjoint ùëá1,ùëá2 ‚äÜ ùëÜ, we say ùëá1,ùëá2 are

independent in ùúá if for any ùë• ‚àà Mem[ùëá1 ‚à™ ùëá2],

ùúãùëá1‚à™ùëá2 ùúá(ùë•) = ùúãùëá1 ùúá(pùëá1 (ùë•)) ¬∑ ùúãùëá2 ùúá(pùëá2 (ùë•)).

We then deÔ¨Åne the independent product ‚äó as: for any ùúá1 ‚àà D (Mem[ùëÜ]), ùúá2 ‚àà D (Mem[ùëá ]),

ùúá1 ‚äó ùúá2 =

(

‚àÖ
{ùúá | for any ùë• ‚àà Mem[ùëÜ ‚à™ ùëá ], ùúá(ùë•) = ùúá1 (pùëÜ (ùë•)) ¬∑ ùúá2 (pùëá (ùë•))}

if ùëÜ,ùëá not disjoint
if ùëÜ,ùëá disjoint

For any distribution ùúá ‚àà D (Mem[ùëÜ]), we call ùëÜ the domain of ùúá, denoted dom(ùúá). By construction,
if ùúá ‚àà ùúá1 ‚äó ùúá2, then dom(ùúá1) and dom(ùúá2) are independent in ùúá, and ùúá is the unique element in
ùúá1 ‚äó ùúá2. Simple calculations also show that if ùúá ‚àà ùúá1 ‚äó ùúá2, then ùúãùëÜ ùúá = ùúá1, ùúãùëá ùúá = ùúá2.

We can then present the Independence frame from Barthe et al. [2020] as the following BI frame.

For simplicity, we restrict its states to probabilistic memories for now.2

DeÔ¨Ånition 4.2. Let ùëã = ‚à™ùëÜ ‚äÜVarD (Mem[ùëÜ]). Say ùúá ‚äë ùúá‚Ä≤ iÔ¨Ä dom(ùúá) ‚äÜ dom(ùúá‚Ä≤) and ùúãdom(ùúá) ùúá‚Ä≤ = ùúá.

Let ùê∏indep = ùëã . We call Xindep = (ùëã, ‚äë, ‚äó, ùê∏indep) the Independence structure.

This Independence structure Xindep is a BI frame.

2Technically we take a slightly diÔ¨Äerent notion of BI frames that is more suitable for our purposes. Barthe et al. [2020]
presents BI frames with partial, pre-ordered commutative monoids, which require a unique unit for all states. But we can
encode their frame as our BI frame by taking its partial operation as an operation that returns sets of size at most one and
deÔ¨Åning the unit set ùê∏ to include their unique unit and be closed under ‚äë.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:11

4.2 Initial attempts at a NA model
Our goal is to design a BI model XPNA that can capture negative association and can be combined
with Xindep. To be compatible with Xindep, we let XPNA have the same set of states and the same
pre-order as Xindep. The important remaining piece of the puzzle is the binary operation ‚äï, which
must satisfy the frame conditions.

One Ô¨Årst attempt is to let ùúá1 ‚äï ùúá2 return the set of distributions that agree with ùúá1, ùúá2, and satisfy

strong NA‚Äîwe say ùúá satisÔ¨Åes strong NA if dom(ùúá) satisÔ¨Åes NA.

DeÔ¨Ånition 4.3. (Attempt 1: Strong NA model) Let ùëã = ‚à™ùëÜ ‚äÜVarD (Mem[ùëÜ]). For ùúá, ùúá‚Ä≤ ‚àà ùëã , say

ùúá ‚äë ùúá‚Ä≤ iÔ¨Ä dom(ùúá) ‚äÜ dom(ùúá‚Ä≤) and ùúãdom(ùúá) ùúá‚Ä≤ = ùúá. Let ùê∏ùë† = ùëã . DeÔ¨Åne ‚äïùë† : ùëã √ó ùëã ‚Üí P (ùëã ):

ùúá1 ‚äïùë† ùúá2 = {ùúá ‚àà D (Mem[ùëÜ ‚à™ ùëá ]) | ùúá satisÔ¨Åes strong NA, ùúãùëÜ ùúá = ùúá1, ùúãùëá ùúá = ùúá2, ùëÜ ‚à© ùëá = ‚àÖ}.

We call Xùë† = (ùëã, ‚äë, ‚äïùë†, ùê∏ùë†) the strong NA structure.

Unfortunately, the strong NA structure fails to have the (Unit Existence) property: if ùúá does not
satisfy strong NA, then there exists no ùúá‚Ä≤ that marginalizes to ùúá and satisÔ¨Åes strong NA, and thus
no ùëí such that ùúá ‚àà ùëí ‚äïùë† ùúá. The failure of this property implies that whether or not two states can
be combined depends on properties of the single states in isolation (e.g., whether a distribution
satisÔ¨Åes strong NA), and not just on how the two states relate to each other; this is hard to justify
if we are to read ‚äï as describing which pairs of states can be safely combined.

Looking for a diÔ¨Äerent way of capturing NA, we can take inspiration from the Xindep. There,
ùúá1 ‚äó ùúá2 returns a distribution that agrees with ùúá1, ùúá2 and on which dom(ùúá1) are independent from
dom(ùúá2). Thus, we can try letting ùúá1 ‚äï ùúá2 return distributions that agree with ùúá1, ùúá2 where any
variable ùë• in dom(ùúá1) must be negatively associated with any variable ùë¶ in dom(ùúá2), but variables
within dom(ùúá1) and variables within dom(ùúá2) need not be negatively associated. We call this
notion weak NA.

DeÔ¨Ånition 4.4 (Weak NA). Let ùëÜ ‚äÜ Var be a set of variables, and let ùê¥, ùêµ be two disjoint subsets
of ùëÜ. A distribution ùúá ‚àà D (Mem[ùëÜ]) satisÔ¨Åes (ùê¥, ùêµ)-NA if for every pair of both monotone or both
antitone functions ùëì : Mem[ùê¥] ‚Üí R, ùëî : Mem[ùêµ] ‚Üí R, where we take the point-wise orders on
Mem[ùê¥] and Mem[ùêµ], such that ùëì , ùëî is either lower bounded or upper bounded, we have

Eùëö‚àºùúá [ùëì (pùê¥ùëö) ¬∑ ùëî(pùêµùëö)] ‚â§ Eùëö‚àºùúá [ùëì (pùê¥ùëö)] ¬∑ Eùëö‚àºùúá [ùëî(pùêµùëö)].

By deÔ¨Ånition, being (ùê¥, ùêµ)-NA for all disjoint ùê¥, ùêµ ‚äÜ ùëÜ is equivalent to strong NA on ùëÜ. Now, we

can try deÔ¨Åning another model based on weak NA.

DeÔ¨Ånition 4.5. (Attempt 2: Weak NA model) Let ùëã = ‚à™ùëÜ ‚äÜVarD (Mem[ùëÜ]). For ùúá, ùúá‚Ä≤ ‚àà ùëã , ùúá ‚äë ùúá‚Ä≤

iÔ¨Ä dom(ùúá) ‚äÜ dom(ùúá‚Ä≤) and ùúãdom (ùúá) ùúá‚Ä≤ = ùúá. Let ùê∏ùë§ = ùëã . DeÔ¨Åne ‚äïùë§ : ùëã √ó ùëã ‚Üí P (ùëã ):

ùúá1 ‚äïùë§ ùúá2 = {ùúá ‚àà D (Mem[ùëÜ ‚à™ ùëá ]) | ùúá satisÔ¨Åes (ùëÜ,ùëá )-NA, ùúãùëÜ ùúá = ùúá1, ùúãùëá ùúá = ùúá2, ùëÜ ‚à© ùëá = ‚àÖ}.

We call Xùë§ = (ùëã, ‚äë, ‚äïùë§, ùê∏ùë§) the weak NA structure.

This weak NA structure satisÔ¨Åes most BI frame conditions, except that (Associativity) is unclear.
In short, the deÔ¨Ånition of ‚äïùë§ and (Associativity) requires that: if ùë§ satisÔ¨Åes (ùëÖ ‚à™ ùëÜ,ùëá )-NA and
(ùëÖ, ùëÜ)-NA, then ùë§ also satisÔ¨Åes (ùëÜ,ùëá )-NA and (ùëÖ, ùëÜ ‚à™ùëá )-NA. Now ùë§ satisÔ¨Åes (ùëÜ,ùëá )-NA by projec-
tion closure, but it is unclear whether ùë§ must satisfy (ùëÖ, ùëÜ ‚à™ ùëá )-NA; we leave this question as an
interesting open problem. Failing to satisfy (Associativity) would lead to a logic where separating
conjunction is not associative, and signiÔ¨Åcantly more diÔ¨Écult to use. Since it is unknown whether
Xùë§ is a BI frame, we will deÔ¨Åne another structure to capture negative association.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:12

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

4.3 Our NA model
Facing the problems with the strong NA structure and the weak NA structures, we will deÔ¨Åne a
BI model for negative association based on a new notion of negative association called partition
negative association (PNA). This notion interpolates weak NA and strong NA, in the following sense:
{ùê¥, ùêµ}-PNA is equivalent to (ùê¥, ùêµ)-NA for disjoint ùê¥, ùêµ ‚äÜ ùëÜ, and {{ùë†} | ùë† ‚àà ùëÜ }-PNA is equivalent
to strong NA for distributions in D (Mem[ùëÜ]).

DeÔ¨Ånition 4.6 (Partition Negative Association). We say a partition S‚Ä≤ coarsens a partition S if

‚à™S = ‚à™S‚Ä≤ and for any ùë† ‚Ä≤ ‚àà S‚Ä≤, ùë† ‚Ä≤ = ‚à™R for some R ‚äÜ S.

A distribution ùúá is S-PNA if and only if for any T that coarsens S, for any family of non-negative
monotone functions (or family of non-negative antitone functions), {ùëìùê¥ : Mem[ùê¥] ‚Üí R+}ùê¥ ‚ààT ,3
where we take the point-wise order on Mem[ùê¥] for each ùê¥ ‚àà T , we have

Eùëö‚àºùúá

"
We can use PNA to prove NA:

ùëìùê¥ (pùê¥ùëö)

‚â§

#

√ñùê¥ ‚ààT

√ñùê¥ ‚ààT

Eùëö‚àºùúá [ùëìùê¥ (pùê¥ùëö)].

Theorem 4.7. Given a set of variables ùëÜ, ùëÜ satisÔ¨Åes NA in ùúá iÔ¨Ä ùúá satisÔ¨Åes S-PNA for any S parti-

tioning ùëÜ iÔ¨Ä ùúá satisÔ¨Åes {{ùë†} | ùë† ‚àà ùëÜ }-PNA.4

We require PNA to be closed under coarsening, which helps us to prove the next structure we

deÔ¨Åne is a BI frame.

DeÔ¨Ånition 4.8. Let XPNA = (ùëã, ‚äë, ‚äï, ùê∏PNA), where ùëã = ùê∏PNA = ‚à™ùëÜ ‚äÜVarD (Mem[ùëÜ]). For ùúá, ùúá‚Ä≤ ‚àà ùëã ,

say ùúá ‚äë ùúá‚Ä≤ iÔ¨Ä dom(ùúá) ‚äÜ dom(ùúá‚Ä≤) and ùúãdom (ùúá) ùúá‚Ä≤ = ùúá. DeÔ¨Åne the operation ‚äï : ùëã √ó ùëã ‚Üí P (ùëã ):

ùúá1 ‚äï ùúá2 = {ùúá ‚àà D (Mem[ùëÜ ‚à™ ùëá ]) | ùúãùëÜ ùúá = ùúá1, ùúãùëá ùúá = ùúá2,

ùúá is (S ‚à™ T )-PNA for any partition S, T such that
ùúá1 is S-PNA, and ùúá2 is T -PNA, and (‚à™S) ‚à© (‚à™T ) = ‚àÖ.}

This deÔ¨Ånition of ‚äï interpolates ‚äïùë§ and ‚äïùë† , in the following sense.
Theorem 4.9. For any two states ùúá1, ùúá2 ‚àà ùëã , ùúá1 ‚äïùë† ùúá2 ‚äÜ ùúá1 ‚äï ùúá2 ‚äÜ ùúá1 ‚äïùë§ ùúá2.
The Ô¨Årst inclusion is because ùúá satisfying strong NA implies ùúá is R-PNA for any partition
R on dom(ùúá). The second inclusion is because ùúá1 ‚àà D (Mem[ùëÜ]) satisÔ¨Åes {ùëÜ }-PNA and ùúá2 ‚àà
D (Mem[ùëá ]) satisÔ¨Åes {ùëá }-PNA trivially, which implies any ùúá ‚àà ùúá1 ‚äï ùúá2 would satisfy (ùëÜ,ùëá )-NA.

Note that ‚äï is non-deterministic, and not just partial.

Theorem 4.10. There are distributions ùúá1, ùúá2 such that |ùúá1 ‚äï ùúá2 | ‚â• 2.
Proof. Let ùúá1 ‚àà D (Mem[{ùë• }]) and ùúá2 ‚àà D (Mem[{ùë¶}]) be uniform distribution over memories
over 0/1 variables ùë•, ùë¶. Then the independent product ùúá ‚äó ‚àà ùúá1 ‚äó ùúá2 is in ùúá1 ‚äï ùúá2, because the
projections to ùë• and to ùë¶ are ùúá1 and ùúá2 respectively, and ùúá ‚äó satisÔ¨Åes PNA since independence
implies PNA (we will see this shortly in Theorem 4.12). But the one-hot uniform distribution ùúáùëú‚Ñé
over variables ùë• and ùë¶, i.e., ùúáùëú‚Ñé ( [ùë• ‚Ü¶‚Üí 1, ùë¶ ‚Ü¶‚Üí 0]) = ùúáùëú‚Ñé ( [ùë• ‚Ü¶‚Üí 0, ùë¶ ‚Ü¶‚Üí 1]) = 1/2, is also in ùúá1 ‚äï ùúá2,
since again the projections match ùúá1 and ùúá2 and the one-hot distribution satisÔ¨Åes NA, and hence
(cid:3)
PNA. Since ùúáùëú‚Ñé ‚â† ùúá ‚äï , we are done.
3We restrict the family of functions to be non-negative: prior work like Joag-Dev and Proschan [1983] has assumed non-
negativity when working with notions of NA on partitions; furthermore, without that requirement, for partitions with odd
number of components, PNA would be equivalent to independence, a strange property.
4Technically, we slightly modify Dubhashi and Ranjan [1998]‚Äôs NA when deÔ¨Åning it in DeÔ¨Ånition 2.1 by in addition assum-
ing that ùëì , ùëî are bounded from one side. We add that condition to have a cleaner version of this theorem and Theorem 5.3.
All our other results and properties we state about NA in Section 1 hold with or without this condition.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:13

Thus, we can build a BI frame on probabilistic memories, crucially using a non-deterministic

combination operation on states [Docherty 2019].

Theorem 4.11. The structure XPNA = (ùëã, ‚äë, ‚äï, ùê∏PNA) is a Down-Closed BI frame.

See the full proof in Appendix C.1. For the frame conditions where the previous attempts failed,
(Unit Existence) holds by letting the unit ùëí to always be the trivial distribution on the empty set, and
(Associativity) can be proved using the facts that PNA is closed under coarsening and coarsening
commute with projections. We call XPNA the PNA model.

Now that we know the PNA frame is a BI frame and captures NA, we want to combine it with the
PSL frame to construct a ùëÄ-BI frame. To combine them, we need to show that for any ùúá1, ùúá2 ‚àà ùëã ,

The inclusion is implied by the following theorem:

ùúá1 ‚äó ùúá2 ‚äÜ ùúá1 ‚äï ùúá2.

Theorem 4.12 (Independence implies PNA). Let ùëÜ,ùëá ‚äÜ Var be two disjoint sets of variables.
Suppose ùúá1 ‚àà D (Mem[ùëÜ]), ùúá2 ‚àà D (Mem[ùëá ]). If ùúá1 satisÔ¨Åes S-PNA and ùúá2 satisÔ¨Åes T -PNA, then
any ùúá ‚àà ùúáùëÜ ‚äó ùúáùëá satisÔ¨Åes S ‚à™ T -PNA.

This theorem generalizes the independence closure for NA from Theorem 2.3. Its proof, however,
is more involved because PNA is more expressive and is closed under coarsening. (See the proof
in Appendix C.2.)

Thus, we can combine Xindep and XPNA into a 2-BI model.

Theorem 4.13. Let 2 = {1, 2} with pre-order 1 ‚â§ 2. Let ‚äï1 = ‚äó, ùê∏1 = ùê∏indep, ‚äï2 = ‚äï, ùê∏2 = ùê∏PNA.

The structure XD (Mem) = (ùëã, ‚äë, ‚äï1, ùê∏1, ‚äï2, ùê∏2) is a 2-BI model.

Thus XD (Mem) is a 2-BI frame on probabilistic memories.

4.4 Combining with deterministic memory

While we can model the program states of probabilistic programs as probabilistic memories, some
variables might only get deterministic assignments. It is useful to know whether a variable is deter-
ministic; for instance, a deterministic variable is automatically independent of other variables. To
keep track of deterministic variables, we want a 2-BI frame whose states distinguish deterministic
memories and probabilistic memories. We will construct it using a general approach for composing
ùëÄ-BI models. In particular, we will compose XD (Mem) with a 2-BI frame on deterministic memo-
ries.

We can deÔ¨Åne the product of two ùëÄ-BI frames if they share the same pre-order for indexing, ùëÄ.

DeÔ¨Ånition 4.14. Let ùëÄ be a pre-order. Given two ùëÄ-BI frames, X1 = (ùëã1, ‚äë1, ‚äï(1,ùëö ‚ààùëÄ) , ùê∏ (1,ùëö ‚ààùëÄ) )
and X2 = (ùëã2, ‚äë2, ‚äï(2,ùëö ‚ààùëÄ) , ùê∏ (2,ùëö ‚ààùëÄ) ). The product frame, X = X1 √ó X2 = (ùëã, ‚äë, ‚äïùëö ‚ààùëÄ , ùê∏ùëö ‚ààùëÄ ) is
deÔ¨Åned as

‚Ä¢ ùëã = ùëã1 √ó ùëã2;
‚Ä¢ (ùë•1, ùë•2) ‚äë (ùë• ‚Ä≤
‚Ä¢ For ùëö ‚àà ùëÄ, (ùë•1, ùë•2) ‚äïùëö (ùë• ‚Ä≤
‚Ä¢ ùê∏ùëö = ùê∏1,ùëö √ó ùê∏2,ùëö.

1, ùë• ‚Ä≤

2) if and only if ùë•1 ‚äë1 ùë• ‚Ä≤
1, ùë• ‚Ä≤

1 and ùë•2 ‚äë2 ùë• ‚Ä≤
2;

2) = {(ùë¶1, ùë¶2) | ùë¶1 ‚àà ùë•1 ‚äï1,ùëö ùë• ‚Ä≤

1 ‚àß ùë¶2 ‚àà ùë•2 ‚äï2,ùëö ùë• ‚Ä≤

2};

Theorem 4.15. If X1 and X2 are two M‚àíùêµùêº frames, then X = X1 √ó X2 is also an ùëÄ-BI frame.

The proof is straightforward.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:14

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

We now deÔ¨Åne a 2-BI frame modeling the independence and NA separation on the determin-
istic memories. Because deterministic variables are automatically independent of other variables,
it is meaningless to check whether a set of deterministic variables can be separated into two dis-
joint subsets independent of each other. Thus, we do not require the separation of domain when
modeling the independence and NA of deterministic variables:

DeÔ¨Ånition 4.16. Let ùëã ‚Ä≤ = ‚à™ùëÜ ‚ààVarMem[ùëÜ], and ‚äë be =, and the unit set ùê∏d = ùëã ‚Ä≤. DeÔ¨Åne ‚äïùëë by:

ùëö1 ‚äïùëë ùëö2 =

{ùëö1}
‚àÖ

(

if ùëö1 = ùëö2
if ùëö1 ‚â† ùëö2

Theorem 4.17. The structure XMem = (ùëã ‚Ä≤, ‚äëùëë, ‚äï1, ùê∏1, ‚äï2, ùê∏2), where ‚äï1 = ‚äï2 = ‚äïùëë and ùê∏1 = ùê∏2 =

ùê∏d, is a 2-BI frame.

Both XMem and XD (Mem) are 2-BI frames, so we can take their product.
Corollary 4.18. Xcomb = XMem √ó XD (Mem) is a 2-BI frame.

As desired, the states of Xcomb describe both deterministic memories and probabilistic memo-
ries. Furthermore, restricting to the BI model in Xcomb with operators indexed by 1 recovers the
probabilistic BI model in Barthe et al. [2020].

5 PROGRAM LOGIC

Given the model for NA developed in the previous section, we now have a suitable logic of as-
sertions. In this section, we complete the picture by designing a program logic, named LINA, for
reasoning about negative association and independence on probabilistic programs. We defer proofs
and details to Appendix D.

5.1 Probabilistic programs
We consider probabilistic programs in a basic probabilistic imperative language pWhile. Let DV, RV
be disjoint countable subsets of Var that respectively contain all deterministic variables and all
probabilistic variables. We consider program states to be a pair of a deterministic memory ùúé, and
a distribution ùúá over the probabilistic memory, i.e., (ùúé, ùúá) ‚àà Mem[DV] √ó D (Mem[RV]).

Because we will want to decompose a program state as a product of two disjoint memories,
each satisfying a sub-formula, we also want to interpret program expressions on memories whose
probabilistic part is only on part of RV. These memories have type Mem[DV] √ó D (Mem[ùëá ])
for some ùëá ‚äÜ RV, and we call them conÔ¨Ågurations, denoted Config.

We assume all expressions in pWhile are well-typed:

E ‚àã ùëí ::= DV | RV | [E, . . . , E] | E + E | E ‚àß E | . . .

Given an expression ùëí, we can interpret it as Mem[DV] √ó Mem[ùëá ] ‚Üí Val for any ùëá ‚äÜ RV that
includes all the free variables in ùëí. We can also lift it to an interpretation from conÔ¨Ågurations to
distributions of values, i.e., JùëíK : Mem[DV] √ó D (Mem[ùëá ]) ‚Üí D (Val) (see DeÔ¨Ånition D.1).

We then deÔ¨Åne commands in pWhile and again assume that they are well-typed:

C ‚àã ùëê ::= skip | DV ‚Üê Exp | RV ‚Üê Exp | RV $‚Üê Uùëá | C ; C

| if E then C else C | while E do C.

The randomization is introduced by the sampling command: RV $‚Üê Uùëá , where Uùëá stands for the
uniform distribution on a multi-set ùëá . We assume that the while loops terminate in Ô¨Ånite steps on
all inputs. We also assume that an expression assigned to a deterministic variable only mentions

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:15

deterministic variables, and a command branching on a randomized expression does not assign to
deterministic variables in its body/branches. This assumption ensures that deterministic variables
will not receive randomized values during the execution. It is not diÔ¨Écult to enforce this condition
by a syntactic restriction, which we omit for a cleaner presentation.

Following the standard semantics for probabilistic programs due to Kozen [1981], we interpret

pWhile programs as transformers from program states to program states, i.e.,

JùëêK : Mem[DV] √ó D (Mem[RV]) ‚Üí Mem[DV] √ó D (Mem[RV]).

The semantics of pWhile is standard (see DeÔ¨Ånition D.3).

In our examples, permutation distributions, uniform distributions over permutation(ùê¥):

DeÔ¨Ånition 5.1. Given a Ô¨Ånite multi-set of ùê¥, a permutation of ùê¥ is a bijective function ùõº : ùê¥ ‚Üí ùê¥.
We let permutation(ùê¥) be the multi-set of ùê¥‚Äôs permutations. When ùê¥ has duplicates, we distinguish
them using additional labels; so there are always |ùê¥|! elements in permutation(ùê¥).

Let one-hot([n]) denote the set of length-ùëõ one hot vectors. We then deÔ¨Åne the shorthands:
RV $‚Üê ùëùùëíùëüùëö(ùê¥) , RV $‚Üê Upermutation(ùê¥)
RV $‚Üê ùëú‚Ñé(ùëõ) , RV $‚Üê Uone-hot ( [ùëõ ])
if ùëè then ùëê , if ùëè then ùëê else skip.

5.2 Assertion Logic: atomic propositions and axioms
Like other program logics, LINA has two layers: the program logic layer describing the relation
between pre-conditions, programs and post-conditions, and the assertion logic layer describing
program states. In Section 4, we have constructed a probabilistic model of 2-BI, Xcomb, whose
states encompass all of Config, so our starting point for the assertion logic is this model. In this
section, we introduce atomic propositions AP for describing states in Xcomb and some axioms
that will hold on Xcomb.

We extend the core atomic formula from Barthe et al. [2020]. To talk about probabilities on
program states distributions, we Ô¨Årst deÔ¨Åne an event to be a function that maps a deterministic
program conÔ¨Åguration to 0 or 1, and let EV be a set of expressions that can be interpreted as event
on deterministic conÔ¨Ågurations i.e., for any ùëíùë£ ‚àà EV, Jùëíùë£K : Mem[DV] √ó Mem[ùëá ] ‚Üí {0, 1} for
some ùëá ‚äÜ RV. Since boolean expressions in the programming language can also be interpreted
as this type, we will let EV include all boolean expression. Let

AP ‚àã ùëù ::= Uùëá hEi | Bernùëù hEi | DetmhEi | E ‚àº E | E ‚â§ E | EV = ùëè | Pr[EV] ‚ä≤‚ä≥ ùõø
(1)
where ‚ä≤‚ä≥ ‚àà {=, ‚â§, ‚â•}, ùëè ‚àà {0, 1}, and ùõø ‚àà R is a constant. In particular, for boolean expression ùëí
and for ùëè ‚àà {0, 1}, since we can also view ùëí as an event, ùëí ‚àº ùëè and ùëí = ùëè are both valid atomic
propositions. We distinguish their notations ( ‚àº v.s. = ) because, in general, the left hand side of
EV = ùëè may not be an expression and the left hand side of E ‚àº E may not be an event.

We deÔ¨Åne the satisfaction of atomic proposition on program conÔ¨Ågurations as follows. Let FV(ùëí)

be the set of free variables in expression ùëí.

DeÔ¨Ånition 5.2 (Atomic Propositions). For (ùúé, ùúá) ‚àà Xcomb, deÔ¨Åne
‚Ä¢ (ùúé, ùúá) |= Uùëá hùëíi iÔ¨Ä FV(ùëí) ‚äÜ dom(ùúé) ‚à™ dom(ùúá) and JùëíK(ùúé, ùúá) is a distribution that assigns

probability 1

|ùëá | to each element of ùëá ;

‚Ä¢ (ùúé, ùúá) |= Bernùëù hùëíi iÔ¨Ä FV(ùëí) ‚äÜ dom(ùúé) ‚à™ dom(ùúá) and JùëíK(ùúé, ùúá) is a distribution that assign

probability ùëù to 1 and probability 1 ‚àí ùëù to 0, i.e., the Bernoulli distribution;

‚Ä¢ (ùúé, ùúá) |= Detmhùëíi iÔ¨Ä FV(ùëí) ‚äÜ dom(ùúé) ‚à™ dom(ùúá) and JùëíK(ùúé, ùúá) is a Dirac distribution;

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:16

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

‚Ä¢ (ùúé, ùúá) |= ùëí ‚àº ùëí ‚Ä≤ iÔ¨Ä FV(ùëí) ‚à™ FV(ùëí ‚Ä≤) ‚äÜ dom(ùúé) ‚à™ dom(ùúá) and JùëíK(ùúé, ùëö) = Jùëí ‚Ä≤K(ùúé, ùëö) for any ùëö

in the support of ùúá;

‚Ä¢ (ùúé, ùúá) |= ùëí ‚â§ ùëí ‚Ä≤ iÔ¨Ä FV(ùëí) ‚à™ FV(ùëí ‚Ä≤) ‚äÜ dom(ùúé) ‚à™ dom(ùúá) and JùëíK(ùúé, ùëö) ‚â§ Jùëí ‚Ä≤K(ùúé, ùëö) for any

ùëö in the support of ùúá;

‚Ä¢ (ùúé, ùúá) |= ùëíùë£ = ùëè if for any ùëö in the support of ùúá, Jùëíùë£K(ùúé, ùëö) = ùëè.
‚Ä¢ (ùúé, ùúá) |= Pr[ùëíùë£] ‚ä≤‚ä≥ ùõø iÔ¨Ä the probability of event Jùëíùë£K in (ùúé, ùúá), deÔ¨Åned to be Pr(ùúé,ùúá) [ùëíùë£] =

ùëö ‚ààMem [dom(ùúá) ] ùúá(ùëö) ¬∑ Jùëíùë£K(ùúé, ùëö), satisÔ¨Åes Pr(ùúé,ùúá) [ùëí] ‚ä≤‚ä≥ ùõø.

√ç

We use the abbreviations:
‚Ä¢ hùëíi , ùëí ‚àº ùëí. That is, (ùúé, ùúá) |= hùëíi holds if all of the variables in ùëí are deÔ¨Åned in ùúé and ùúá.
‚Ä¢ OHùëÅ hùëíi , Uone-hot([N])hùëíi.
‚Ä¢ For multi-set ùê¥, Permùê¥ hùëíi , Upermutation(A)hùëíi.

For any operation ‚äô ‚àà {‚àß, ‚à®, ‚äõ, ‚àó}, we pick the corresponding big-operation

‚àà

to be their iterated version (see DeÔ¨Ånition D.4).

o
With the atomic propositions and abbreviations, we can formally state that Xcomb captures NA.

√á

√î

, ‚äõ,‚àó

,
n√ì

Theorem 5.3. Let ùëÜ be any subset of RV. A set of randomized program variables ùëå = {ùë¶ùëñ
| 0 ‚â§
ùëñ < ùêæ } satisÔ¨Åes NA in distribution ùúá ‚àà D (Mem[ùëÜ]) if and only if for any deterministic memory
ùúé ‚àà Mem[DV], we have (ùúé, ùúá) |= ‚äõùêæ
In the Xcomb model, all axioms from Barthe et al. [2020, Lemma 3, 4] still hold, and we have new

ùëñ=0hùë¶ùëñ i.

axioms for the negative association conjunction and the permutation distribution.

Lemma 5.4. Let ùë•ùõæ be variables. The following axioms are valid in Xcomb.

|= OHùëÅ h[ùë•0, . . . , ùë•ùëÅ ‚àí1]i ‚Üí

ùëÅ‚äõ

ùõæ=0

hùë•ùõæ i

|= Permùê¥ h[ùë•0, . . . , ùë•ùëÅ ‚àí1]i ‚Üí

ùëÅ‚äõ

ùõæ=0

hùë•ùõæ i

(OH-PNA)

(Perm-PNA)

The two axioms follow from Theorem 2.2, which shows that random variables in one-hot dis-
tributions and permutation distributions are NA, and Theorem 5.3, which shows that ‚äõ captures
the NA of random variables. We can also encode the monotone map closure in Theorem 2.3 as an
axiom in the logic.

Lemma 5.5 (Monotone map). Let ùë•, ùë•ùõæ,ùõº and ùë¶ùõæ be variables. The following is valid in Xcomb.

ùëÅ‚äõ

ùõæ=0

|=

ùêæùõæ +1

ùëÅ

hùë•ùõæ,ùõº i

‚àß

ùë¶ùõæ = ùëìùõæ

ùë•ùõæ,0, . . . , ùë•ùõæ,ùêæùõæ
(cid:16)

(cid:17)

‚Üí

ùëÅ‚äõ

ùõæ=0

hùë¶ùõæ i

√õùõæ=0

√õùõº =0

¬©

¬´

¬™
¬Æ
¬¨

when ùëì1, . . . , ùëìùëÅ all monotone or all antitone

(Mono-Map)

When we establish NA from permutation distributions, it is preserved under not only mono-
tone/antitone maps but also any element-wise homogeneous maps. The reason is that Ô¨Åxing a
multi-set and a permutation, permuting Ô¨Årst and then applying the same map on each element
is the equivalent to applying the map on each element and then permuting. So applying homoge-
neous maps on a permutation distribution gives another permutation distribution. We can capture
this property in an axiom.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

 
A Separation Logic for Negative Dependence

57:17

Lemma 5.6 (Permutation Map). Let ùë•ùõæ be variables, and ùëì (ùê¥) be {ùëì (ùëé) | ùëé ‚àà ùê¥}. The following

axiom is valid in Xcomb.

|= Permùê¥ h[ùë•1, . . . , ùë•ùëÅ ]i ‚àß ùë¶ ‚àº [ùëì (ùë•1), . . . , ùëì (ùë•ùëÅ )] ‚Üí Permùëì (ùê¥) hùë¶i

(Perm-Map)

5.3 Restricting the assertion language

When designing a separation logic for reasoning about negative association and independence,
we sometimes want to separate out a smaller conÔ¨Åguration (ùúé ‚Ä≤, ùúá‚Ä≤) inside a given program state
(ùúé, ùúá) |= ùúô, such that (ùúé ‚Ä≤, ùúá‚Ä≤) satisÔ¨Åes some sub-formula of ùúô. In the program logic we will present
in Section 5.4, the soundness of RCase, Const, Frame and NegFrame rules all rely on the ability
to do that. To ensure there exists such a smaller conÔ¨Åguration, we require the assertion logic to
satisfy a key condition called restriction, which says that to check whether a conÔ¨Åguration satisÔ¨Åes
ùúô, it suÔ¨Éces to check whether the conÔ¨Åguration‚Äôs projection on FV(ùúô) satisÔ¨Åes ùúô. We identify a
subset of ùëÄ-BI formulas that satisfy the restriction property when interpreted on states in Xcomb:

DeÔ¨Ånition 5.7. We deÔ¨Åne ùëÄ-BIrestricted as

ùëÄ-BIrestricted ‚àã ùëÉ, ùëÑ ::= ùëù ‚àà AP | ‚ä§ | ‚ä• | ùëÉ ‚àß ùëÑ | ùëÉ ‚à® ùëÑ | ùëÉ ‚Üí ùëÑ | ùëÉ ‚àó ùëÑ | ùëÉ ‚àí‚àó ùëÑ | ùëÉ ‚äõ ùëÑ

where AP is deÔ¨Åned as in Equation (1).

ùëÄ-BIrestricted omits multiplicative identities ùêºùëö because on Xcomb they are all equivalent to ‚ä§. The

only limitation is that ùëÄ-BIrestricted excludes the use of ‚àí‚äõ.

Theorem 5.8 (Restriction). Let (ùúé, ùúá) be any conÔ¨Åguration, and let ùúô be an ùëÄ-BIrestricted formula

interpreted on Xcomb, Then, for any ùëö ‚àà Mem[DV \ FV(ùúô)],

(ùúé, ùúá) |= ùúô ‚áê‚áí (pFV(ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúãFV(ùúô ) ùúá) |= ùúô .

Indeed, we can exhibit a counterexample showing that ‚àí‚äõ does not satisfy restriction.

Theorem 5.9. There exists (ùúé, ùúá) ‚àà Config and formula ùúô such that (ùúé, ùúá) |= ùúô but (ùúé, ùúãFV(ùúô )) 6|= ùúô.

In the following, we will consider ùëÄ-BIrestricted formula on the Xcomb model as the assertion

logic.

5.4 The program logic
We now introduce the program logic layer of LINA. Judgements in LINA have the form {ùëÉ} ùëê {ùëÑ},
where ùëê ‚àà C is a probabilistic program, and ùëÉ, ùëÑ ‚àà ùëÄ-BIrestricted are restricted assertions.

DeÔ¨Ånition 5.10 (Validity). A LINA judgment is valid, written |= {ùëÉ} ùëê {ùëÑ}, if for all (ùúé, ùúá) ‚àà

Mem[DV] √ó D (Mem[RV]) such that (ùúé, ùúá) |= ùëÉ, we have JùëêK(ùúé, ùúá) |= ùëÑ.

Next, we present the proof system of LINA. Since our assertions are a conservative extension
of assertions from PSL, most of the rules carry over unchanged; we list existing rules in Figure 3.
Here, we comment on the new and generalized rules, which we list in Figure 4.

NA frame rule. Our most important addition is the frame rule for the negative association con-
junction ‚äõ. Informally, the NegFrame rule says that if a set of variables ùëã is negatively associated
with another set of variables ùëå that satisfy ùúÇ in a program state, and the program ùëê performs a
monotone operation ùëì on ùëã and stores the result in a variable ùë¶, then in the resulting program
state, ùë¶ and the untouched variables ùëå will also be negatively associated, and ùëå will still satisfy ùúÇ.
Like the Frame rule for independence ‚àó, the NegFrame rule uses syntactic restrictions to control
which variables the program may read and write. The three sets of variables RV(ùëê), WV(ùëê), MV(ùëê)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:18

DAssn

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

‚ä¢ {ùúì [ùëíùëë /ùë•ùëë ]} ùë•ùëë ‚Üê ùëíùëë {ùúì }

Skip

‚ä¢ {ùúô } skip {ùúô }

Seqn

‚ä¢ {ùúô } ùëê {ùúì }

‚ä¢ {ùúì } ùëê ‚Ä≤ {ùúÇ}

‚ä¢ {ùúô } ùëê ; ùëê ‚Ä≤ {ùúÇ}

Cond

‚ä¢ {ùúô ‚àß ùëè ‚àº tt} ùëê {ùúì }

‚ä¢ {ùúô ‚àß ùëè ‚àº Ô¨Ä } ùëê ‚Ä≤ {ùúì }

|= ùúô ‚Üí Detmhùëèi

‚ä¢ {ùúô } if ùëè then ùëê else ùëê ‚Ä≤ {ùúì }

Loop

‚ä¢ {ùúô ‚àß ùëè ‚àº tt} ùëê {ùúô }

|= ùúô ‚Üí Detmhùëèi

‚ä¢ {ùúô } while ùëè do ùëê {ùúô ‚àß ùëè ‚àº Ô¨Ä }

RAssn

ùë•ùëü ‚àâ FV(ùëíùëü )
‚ä¢ {‚ä§} ùë•ùëü ‚Üê ùëíùëü {ùë•ùëü ‚àº ùëíùëü }

RSamp

‚ä¢ {‚ä§} ùë•ùëü

$‚Üê UùëÜ {UùëÜ hùë•ùëü i}

RSamp*

‚ä¢ {ùúô } ùë•ùëü

ùë•ùëü ‚àâ FV(ùúô)
$‚Üê UùëÜ {ùúô ‚àó UùëÜ hùë•ùëü i}

Weak

‚ä¢ {ùúô } ùëê {ùúì }

|= ùúô ‚Ä≤ ‚Üí ùúô ‚àß ùúì ‚Üí ùúì ‚Ä≤

‚ä¢ {ùúô ‚Ä≤} ùëê {ùúì ‚Ä≤}

True

‚ä¢ {‚ä§} ùëê {‚ä§}

Conj

‚ä¢ {ùúô1} ùëê {ùúì1}

‚ä¢ {ùúô2} ùëê {ùúì2}

‚ä¢ {ùúô1 ‚àß ùúô2} ùëê {ùúì1 ‚àß ùúì2}

Case

‚ä¢ {ùúô1} ùëê {ùúì1}

‚ä¢ {ùúô2} ùëê {ùúì2}

‚ä¢ {ùúô1 ‚à® ùúô2} ùëê {ùúì1 ‚à® ùúì2}

Const

‚ä¢ {ùúô } ùëê {ùúì }

FV(ùúÇ) ‚à© MV(ùëê) = ‚àÖ

‚ä¢ {ùúô ‚àß ùúÇ} ùëê {ùúì ‚àß ùúÇ}

Frame

‚ä¢ {ùúô } ùëê {ùúì }

FV(ùúÇ) ‚à© MV(ùëê) = ‚àÖ

FV(ùúì ) ‚äÜ ùëá ‚à™ RV(ùëê) ‚à™ WV(ùëê)

|= ùúô ‚Üí hùëá ‚à™ RV(ùëê)i

‚ä¢ {ùúô ‚àó ùúÇ} ùëê {ùúì ‚àó ùúÇ}

Fig. 3. LINA rules: from PSL.

ùúÇ ‚àà CC

|=Mem ùúÇ ‚Üí

ùúÇùõº

ùúì ‚àà CM

‚àÄùõº ‚àà ùëÜ. ‚ä¢ {ùúô ‚àó ùúÇùõº } ùëê {ùúì }

RCase

|= ùúô ‚Üí hRV(ùëê)i

NegFrame

√úùõº ‚ààùëÜ

‚ä¢ {ùúô ‚àó ùúÇ} ùëê {ùúì }

FV(ùúÇ) ‚à© MV(ùëê) = ‚àÖ

‚ä¢ {ùúô } ùëê {ùë¶ ‚àº ùëì (ùëã )}

ùëã ‚äÜ RV(ùëê) \ MV(ùëê)
ùëì is a monotone function

ùë¶ ‚àâ FV(ùúÇ)

‚ä¢ {ùúô ‚äõ ùúÇ} ùëê {hùë¶i ‚äõ ùúÇ}

ProbBound

‚ä¢ {ùëíùë£1 = 1} ùëê {Pr[ùëíùë£2] ‚â§ ùõø }
‚ä¢ {Pr[ùëíùë£1] ‚â• 1 ‚àí ùúñ} ùëê {Pr[ùëíùë£2] ‚â§ ùõø + ùúñ}

Fig. 4. LINA rules: new and extended.

represent the variables that ùëê may read from, must write to, and may modify, respectively; these
sets can be deÔ¨Åned by induction on the syntax of the program. Roughly, the side conditions guaran-
tee the program ùëê does not read from or modify ùëå , the set of variables satisfying ùúÇ; they in addition

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:19

guarantee that ùëã , the domain of the monotone map will not be modiÔ¨Åed by ùëê, and ùë¶, the codomain
of the monotone map does not belong to ùëå .

Generalized random case analysis. As a more minor extension, we also generalize the random-
ized case analysis rule from PSL in RCase. At a high level, this rule allows reasoning by case
analysis on a property ùúÇ of the program memory (e.g., whether a variable is true or false). Since
the input is a distribution, which may have some probability of ùúÇ holding, and some probability of
ùúÇ not holding, soundness of the rule is a delicate matter requiring several technical side conditions.
The original rule in PSL only allowed case analysis on a Boolean expression; we generalize this
rule to allow a case analysis on any Ô¨Ånite number of cases (e.g., performing case analysis on the
value of a bounded variable).

To explain this rule, we Ô¨Årst introduce the side conditions in order. We say that a formula ùúÇ is
closed under conditioning (CC) if for any (ùúé, ùúá) |= ùúÇ, for any ùëö in the support of ùúá, (ùúé, ùõø (ùëö)) |= ùúÇ.
In the second condition, |=Mem ùúô denotes that for any ùúé ‚àà Mem[DV], ùëö ‚àà Mem[ùëá ] where
ùëá ‚äÜ RV, (ùúé, ùõø (ùëö)) |= ùúô, which says ùúô is valid on all eÔ¨Äectively deterministic conÔ¨Ågurations.
Finally, we say that a formula ùúô is closed under mixtures (CM) if (ùúé, ùúá1) |= ùúô, (ùúé, ùúá2) |= ùúô and ùúá is a
convex combination of ùúá1, ùúá2 together imply (ùúé, ùúá‚Ä≤) |= ùúô.

Then, the rule RCase says if an assertion ùúÇ is independent from the rest of the assertions in the
pre-condition, ùúÇ is closed under conditioning, and the post-condition ùúì is closed under mixtures,
then we can perform case analysis on ùúÇ to derive {ùúô ‚àó ùúÇ} ùëê {ùúì }. Intuitively, every memory ùëö in the
support of the input memory distribution satisÔ¨Åes ùúÇùëé for some case ùëé ‚àà ùëÜ. The main premise shows
that the output distribution of program ùëê from any such input ùëö satisÔ¨Åes ùúì . Then, since any distri-
bution ùúá on inputs is a convex combination of such memories ùëö, and ùúì holds on each conditional
output distribution, we have ùúì holds on the entire output distribution by convex closure.

Bounding bad events. In addition, we present the rule ProbBound to facilitate bounding tail
probabilities. It says that if the pre-condition ùëíùë£1 = 1 guarantees that event ùëíùë£2 happens for at
most ùõø probability after command ùëê, then in general, event ùëíùë£2 happens for at most probability
ùõø + ùúñ after ùëê, where ùúñ upper bounds the probability that ùëíùë£1 is not true in the pre-condition. The
validity of this rule uses the law of total probability, which says for any two events ùëíùë£1 and ùëíùë£2,

Pr(ùëíùë£1) = Pr(ùëíùë£1 | ùëíùë£2) ¬∑ Pr(ùëíùë£2) + Pr(ùëíùë£1 | ¬¨ùëíùë£2) ¬∑ Pr(¬¨ùëíùë£2)

‚â§ Pr(ùëíùë£1 | ùëíùë£2) + Pr(¬¨ùëíùë£2).

As expected, the LINA proof system is sound.

Theorem 5.11. (Soundness of LINA) If ‚ä¢ {ùúô } ùëê {ùúì } is derivable, then it is valid: |= {ùúô } ùëê {ùúì }.

6 EXAMPLES
Now that we have introduced LINA, we present a series of formalized case studies. Our examples
are extracted from various algorithms using hashing and balls-into-bins processes.

6.1 Preliminaries: probabilities, expectations, concentration bounds
Our examples will use a handful of standard facts about probability distributions, encoded as ax-
ioms in the assertion logic. We will generally mention these axioms before they are used, but here
we introduce one fact that we will use through all of our examples: the ChernoÔ¨Ä bound.

In each of our examples we will establish negative dependence of a sequence of random variables
{ùëãùëñ }ùëñ and apply a concentration bound: a theorem showing that the sum ùëã1 +¬∑ ¬∑ ¬∑+ùëãùëõ is usually close
to its expected value. This kind of analysis is useful for establishing high-probability guarantees

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:20

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

Bloom :

ùëèùëôùëúùëúùëö ‚Üê ùëßùëíùëüùëú (ùëÅ );
ùëö ‚Üê 0;
while ùëö < ùëÄ do

‚Ñé ‚Üê 0
while ‚Ñé < ùêª do

ùëèùëñùëõ $‚Üê ùëú‚Ñé( [ùëÅ ]);
ùë¢ùëùùëë ‚Üê ùëèùëôùëúùëúùëö || ùëèùëñùëõ;
ùëèùëôùëúùëúùëö ‚Üê ùë¢ùëùùëë;

‚Ñé ‚Üê ‚Ñé + 1;
ùëö ‚Üê ùëö + 1;

BloomArray :

ùëèùëôùëúùëúùëö ‚Üê ùëßùëíùëüùëú (ùëÅ );
ùëö ‚Üê 0;
while ùëö < ùëÄ do

‚Ñé ‚Üê 0
while ‚Ñé < ùêª do

ùëèùëñùëõ $‚Üê ùëú‚Ñé( [ùëÅ ]);
ùëõ ‚Üê 0;
while ùëõ < ùëÅ do

ùë¢ùëùùëë ‚Üê ùëèùëôùëúùëúùëö[ùëõ] || ùëèùëñùëõ[ùëõ];
ùëèùëôùëúùëúùëö[ùëõ] ‚Üê ùë¢ùëùùëë;
ùëõ ‚Üê ùëõ + 1

‚Ñé ‚Üê ‚Ñé + 1;

ùëö ‚Üê ùëö + 1

(a) Higher-level version

(b) Array version

Fig. 5. Bloom filter examples

of randomized algorithms, e.g., showing that the error of a random estimate is at most 0.01 with
probability at least 99%.

Theorem 6.1 (Chernoff bound for NA variables [Dubhashi and Ranjan 1998]). Let ùëã1, . . . , ùëãùëõ

be a sequence of NA random variables, each bounded in [0, 1], and let ùëå =
ure probability ùõΩ ‚àà (0, 1], we have:

ùëõ
ùëñ=1 ùëãùëñ. Then for any fail-

Pr[|ùëå ‚àí E[ùëå ] | ‚â• ùëá (ùõΩ, ùëõ)] ‚â§ ùõΩ where ùëá (ùõΩ, ùëõ) =

√ç
(ùëõ/2) ln(2/ùõΩ).

To hide complex numerical bounds, we use the notation ùëá (ùõΩ, ùëõ) for the above function through-

p

out. In our assertion logic, the ChernoÔ¨Ä bound can be encoded as the following axiom schema:

Theorem 6.2 (Chernoff bound, axiom). Let {ùë•ùõº } be a family of variables indexed by ùõº, where
each variable is bounded in [0, 1] and is a monotone function of its program variables. Then for any
ùõΩ ‚àà (0, 1], the following axiom schema is sound in our model:

‚â• ùëá (ùõΩ, ùëõ)

‚â§ ùõΩ

#

(NA-ChernoÔ¨Ä)

ùëÅ‚äõ

ùõº =0

|=

hùë•ùõº i ‚Üí Pr

ùë•ùõº ‚àí E

"

ùëÅ

ùë•ùõº

√ïùõº =0

ùëÅ

" (cid:12)
√ïùõº =0
(cid:12)
(cid:12)
(cid:12)
(cid:12)

#(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

We will also use a new expression in our assertions: E[ùëì ], where ùëì is a non-negative and
bounded numeric expression, denotes the expected value of ùëì in the current program conÔ¨Ågu-
ration. We also observe the following conventions throughout the examples: logical variables are
denoted by Greek (ùõº, ùõΩ, ùõæ, . . . ) and capital Roman letters (ùëÄ, ùëÅ , ùêæ, . . . ). Program variables start with
lower-case Roman letters (ùë•,ùë¶, ùëß, . . . ).

6.2 Bloom filter, high-level

Next, we revisit the Bloom Ô¨Ålter example introduced in Section 2. We show how to translate the
informal argument in Section 2 into formal proofs in our program logic. First, we will analyze
the process of adding items into a Bloom Ô¨Ålter ùëèùëôùëúùëúùëö and prove that the entries in ùëèùëôùëúùëúùëö are
negatively associated at the end of the process. Second, we will analyze a program that checks the
membership of a new item in a given Bloom Ô¨Ålter and show how to bound its false positive rate.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:21

Last, we combine them together into one proof that bounds the false positive rate of a Bloom Ô¨Ålter
with ùëÄ elements.

Proving NA of ùëèùëôùëúùëúùëö. We reproduce the code for Bloom in Figure 5a. This program is a higher-
level version of the program in Figure 5b, which performs array operations bit-by-bit. We align the
two versions so that the equivalent operations are side-by-side. We will demonstrate our program
logic on the higher-level version Ô¨Årst and analyze the array version later in Section 6.3.

Recall that the code models inserting ùëÄ distinct elements into a Bloom Ô¨Ålter backed by an array
ùëèùëôùëúùëúùëö of length ùëÅ , where each element is hashed by ùêª functions, each producing an element of
[ùëÅ ] uniformly at random. We refer to the outer loop as outer, and the inner loop as inner. For both

the outer and the inner loop, we apply the rule Loop with the loop invariant: ‚äõùëÅ

ùõΩ=0hùëèùëôùëúùëúùëö[ùõΩ]i.
We consider the inner loop Ô¨Årst. We show that the invariant is preserved by the body of inner.
After the ùëú‚Ñé sampling command, RSamp* gives:

ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i

‚àó OH[ùëÅ ] hùëèùëñùëõi

By negative association of the one-hot distribution (OH-PNA), we get

¬´

ùëÅ‚äõ

ùõΩ=0

¬©

which implies

¬©

¬™
¬Æ
¬¨

hùëèùëôùëúùëúùëö[ùõΩ]i

‚àó

¬™
¬Æ
¬¨

¬©

¬´

hùëèùëôùëúùëúùëö[ùõΩ]i

‚äõ

ùëÅ‚äõ

ùõæ=0

ùëÅ‚äõ

ùõæ=0

ùëèùëñùëõ[ùõæ]

¬™
¬Æ
¬¨
ùëèùëñùëõ[ùõæ]

¬´

ùëÅ‚äõ

ùõΩ=0

¬©
using Weak. Rearranging terms, this is equivalent to
¬´

¬™
¬Æ
¬¨

¬©

¬´

¬™
¬Æ
¬¨

ùëÅ‚äõ

hùëèùëôùëúùëúùëö[ùõΩ]i ‚äõ hùëèùëñùëõ[ùõΩ]i.

After the assignment to ùë¢ùëùùëë, we have:

ùõΩ=0

ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i ‚äõ hùëèùëñùëõ[ùõΩ]i

‚àß ùë¢ùëùùëë ‚àº ùëèùëôùëúùëúùëö || ùëèùëñùëõ.

Because || is monotone, applying the monotone mapping axiom (Mono-Map) gives us:

¬©

¬™
¬Æ
¬¨

¬´

ùëÅ‚äõ

ùõΩ=0

hùë¢ùëùùëë [ùõΩ]i.

Using the assignment rule (RAssn) on the assignment to bloom shows that the loop invariant is
preserved by the inner loop. Thus, Loop gives:

{

ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i} inner {

ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i}

Next, we turn to the outer loop. The argument showing that the invariant is preserved by the outer
loop follows by a straightforward argument, since the outer loop only modiÔ¨Åes ùëèùëôùëúùëúùëö through the

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

 
 
 
 
 
 
57:22

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

inner loop, so Loop gives:

Then, we have:

{

ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i} outer {

ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i}

{‚ä§} Bloom { ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i}

because initializing ùëèùëôùëúùëúùëö to the all-zeros vector, a deterministic value, establishes the loop invari-
ant. This judgment shows that the ùëèùëôùëúùëúùëö vector satisÔ¨Åes NA at the end of the program.

Bounding the false positive rate. Now, we turn to veri-
fying a bound on the false positive rate of the Bloom Ô¨Ål-
ter. Recall that a false positive occurs if when querying
with an element that was not inserted, the Ô¨Ålter returns
true. We can encode the membership check of a new ele-
ment as a program CheckMem (ùêª, ùëèùëôùëúùëúùëö), listed in Fig-
ure 6, which hashes the new element into ùêª uniformly
random positions and checks if these positions are all set
to one in the Ô¨Ålter. If so, the Bloom Ô¨Ålter will report that
the new element is in set, when it was never inserted‚Äîa
false positive.

To verify the false positive rate, we place the program

CheckMem(ùêª, ùëèùëôùëúùëúùëö) :

‚Ñé ‚Üê 0;
ùëéùëôùëô‚Ñéùëñùë° ‚Üê 1
while ‚Ñé < ùêª do
ùëèùëñùëõ $‚Üê U[ùëÅ ] ;
‚Ñéùëñùë° ‚Üê ùëèùëôùëúùëúùëö[ùëèùëñùëõ];
ùëéùëôùëô‚Ñéùëñùë° ‚Üê ‚Ñéùëñùë° && ùëéùëôùëô‚Ñéùëñùë°;
‚Ñé ‚Üê ‚Ñé + 1;

Fig. 6. Check the membership of a new
item

CheckMem(ùêª, ùëèùëôùëúùëúùëö) immediately after Bloom, and then verify a bound on the probability that
ùëéùëôùëô‚Ñéùëñùë° is 1 at the end of the combined program. We Ô¨Årst apply the ChernoÔ¨Ä bound to the NA
variables (NA-ChernoÔ¨Ä) to prove that, with high probability, the number of occupied bins in Bloom
is near its mean with high probability:

‚ä§

Bloom

Pr

(

)

(

ùëÅ

ùëèùëôùëúùëúùëö[ùõΩ] ‚àí E

ùëèùëôùëúùëúùëö[ùõΩ]

‚â• ùëá (ùõø, ùëÅ )

‚â§ ùõø

.

)

ùëÅ

√ïùõΩ=0

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞

Ô£Æ
√ïùõΩ=0
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

This concentration bound implies that a tail bound, which says with high probability

ùëÅ
ùõΩ=0 ùëèùëôùëúùëúùëö[ùõΩ] is upper bounded by its expected value plus ùëá (ùõø, ùëÅ ),

√ç

‚ä§

Bloom

ùëÅ

ùëÅ

Pr

ùëèùëôùëúùëúùëö[ùõΩ] < E

ùëèùëôùëúùëúùëö[ùõΩ]

+ ùëá (ùõø, ùëÅ )

‚â• 1 ‚àí ùõø

(

)

(

Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
Then we analyze CheckMem and show in Appendix F that
Ô£Ø
Ô£∞

Ô£Æ
√ïùõΩ=0
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞

√ïùõΩ=0

ùëÅ

ùëèùëôùëúùëúùëö[ùõΩ] < ùêæ

CheckMem

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª
Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§ (ùêæ/ùëÅ )ùêª

.

)

(2)

o
Then, by the ProbBound rule and basic axioms about probabilities, we have

o

n

n

√ïùõΩ=0

ùëÅ

{Pr[

ùëèùëôùëúùëúùëö[ùõΩ] < ùêæ] ‚â• 1 ‚àí ùõø} CheckMem {Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§ (ùêæ/ùëÅ )ùêª + ùõø}.

(3)

√ïùõΩ=0

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

.

A Separation Logic for Negative Dependence

57:23

We then use Seqn to combine the proved judgements for Bloom (2) and CheckMem (3) to derive
that, for any ùõø,

{‚ä§} Bloom; CheckMem{Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

E

ùëÅ
ùõΩ=0 ùëèùëôùëúùëúùëö[ùõΩ]

+ ùëá (ùõø, ùëÅ )

(cid:2) √ç

ùëÅ

(cid:3)

ùêª

+ ùõø}.

!

Since ùëéùëôùëô‚Ñéùëñùë° is 1 exactly when there is a false positive, this judgment proves an upper bound on
the false positive rate of the Bloom Ô¨Ålter.5

6.3 Bloom filter, low-level
The previous Bloom Ô¨Ålter uses a vector operation ùëèùëôùëúùëúùëö || ùëèùëñùëõ to transform an array of negatively
associated values. We next consider a lower-level version of the previous example, BloomArray,
in Figure 5b, where the vector operation is replaced by a loop that applies the Boolean-or.

Let outer and mid be the outer-most and second outer-most loops, and let inner be the inner-
most loop. Again, our goal is to show that the vector ùëèùëôùëúùëúùëö is negatively associated at the end of
the program. We Ô¨Årst prove the following judgment for inner:

{

ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i ‚àó

ùëÅ‚äõ

ùõæ=0

hùëèùëñùëõ[ùõæ]i} inner {

ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i ‚äõ

ùëÅ‚äõ

ùõæ=ùëõ

hùëèùëñùëõ[ùõæ]i}

We will apply the rule Loop on inner with the following loop invariant:

ùúô =

ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i ‚äõ

ùëÅ‚äõ

ùõæ=ùëò

hùëèùëñùëõ[ùõæ]i

To show that the loop invariant is preserved by the body, we can Ô¨Årst show:

{hùëèùëôùëúùëúùëö[ùëõ],ùëèùëñùëõ[ùëõ]i} ùë¢ùëùùëë ‚Üê ùëèùëôùëúùëúùëö[ùëõ] || ùëèùëñùëõ[ùëõ] {ùë¢ùëùùëë ‚àº ùëèùëôùëúùëúùëö[ùëõ] || ùëèùëñùëõ[ùëõ]}

using RAssn. Noting that the boolean-or operator is a monotone operation, we may apply the
frame rule NegFrame to obtain:

{hùëèùëôùëúùëúùëö[ùëõ],ùëèùëñùëõ[ùëõ]i ‚äõ ùúÇ} ùë¢ùëùùëë ‚Üê ùëèùëôùëúùëúùëö[ùëõ] || ùëèùëñùëõ[ùëõ] {hùë¢ùëùùëëi ‚äõ ùúÇ}

hùëèùëñùëõ[ùõæ]i

.

ùëÅ‚äõ

ùõæ=ùëõ+1
¬©

¬™
¬Æ
¬¨

¬™
¬Æ
¬¨

with the framing condition

ùúÇ =

ùëõ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i

‚äõ

!

ùëÅ‚äõ

ùõΩ=ùëõ+1

hùëèùëôùëúùëúùëö[ùõΩ]i

‚äõ

Thus, by re-associating the separating conjunction and applying RAssn for the remaining two
assignments in the inner-most loop, we have:

¬´

¬©

¬´

{ùúô } ùë¢ùëùùëë ‚Üê ùëèùëôùëúùëúùëö[ùëõ] || ùëèùëñùëõ[ùëõ]; ùëèùëôùëúùëúùëö[ùëõ] ‚Üê ùë¢ùëùùëë; ùëõ ‚Üê ùëõ + 1 {ùúô }

and thus by Loop, we have:

{ ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i ‚äõ

ùëÅ‚äõ

ùõæ=ùëõ

hùëèùëñùëõ[ùõæ]i} inner { ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i ‚äõ

ùëÅ‚äõ

ùõæ=ùëõ

hùëèùëñùëõ[ùõæ]i}.

5The precise expected value is ùëÅ ¬∑ (1 ‚àí (1 ‚àí 1/ùëÅ )ùëÄ ¬∑ùêª ), a fact which can also be shown in our logic. Roughly speaking,
this fact follows because each element of ùëèùëôùëúùëúùëö is the logical-or of ùëÄ ¬∑ ùêª probabilistically independent bits, each 1 with
probability 1/ùëÅ and 0 otherwise. This argument does not rely on negative association.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

 
 
 
 
57:24

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

Now for loop mid, we establish the same loop invariant as we took before:

ùúì =

ùëÅ‚äõ

ùõΩ=0

hùëèùëôùëúùëúùëö[ùõΩ]i

If ùúì holds at the beginning of mid, then invariant for the inner-most loop ùúô holds after assigning
0 to ùëõ and sampling ùëèùëñùëõ, since ùëèùëñùëõ is independent of ùúì (RSamp*) and ùëèùëñùëõ is distributed as ùëú‚Ñé(ùëõ),
which implies entries in ùëèùëñùëõ are negatively associated (OH-PNA). Furthermore, ùúô implies ùúì at the
exit of inner, by dropping the conjunct describing ùëèùëñùëõ. Thus, ùúì is a valid invariant for mid, and the
rest of the proof proceeds unchanged.

6.4 Permutation hashing

Our second example considers a scheme for hashing
using a random permutation. Consider the program
in Figure 7, from an algorithm for fast set intersec-
tion [Ding and K√∂nig 2011]. Letting ùêµ be the number of
bins, and the data universe be [ùêµ ¬∑ ùêæ] = {1, . . . , ùêµ ¬∑ ùêæ }
where ùêµ ¬∑ ùêæ ‚â• ùëÅ , we Ô¨Årst draw a uniformly random per-
mutation ùëî of the data universe. Then, we hash the num-
bers ùëõ ‚àà [ùëÅ ] into ùëèùëñùëõ[ùëõ] by applying the hash function
ùëî and then taking the result modulo ùêµ. Then, we record
whether the item landed in a speciÔ¨Åc bucket ùëç by com-
puting the indicator ‚Ñéùëñùë°ùëç [ùëõ] = [ùëèùëñùëõ[ùëõ] = ùëç ], which is 1
if ùëèùëñùëõ[ùëõ] = ùëç and 0 otherwise, and accumulate the result
into the count ùëêùë°.

PermHash :

ùëî $‚Üê ùëùùëíùëüùëö( [ùêµ ¬∑ ùêæ]);
ùëõ ‚Üê 0;
ùëêùë° ‚Üê 0;
while ùëõ < ùëÅ do

ùëèùëñùëõ[ùëõ] ‚Üê ùëöùëúùëë (ùëî[ùëõ], ùêµ);
‚Ñéùëñùë°ùëç [ùëõ] ‚Üê [ùëèùëñùëõ[ùëõ] = ùëç ];
ùëêùë° ‚Üê ùëêùë° + ‚Ñéùëñùë°ùëç [ùëõ];
ùëõ ‚Üê ùëõ + 1

Fig. 7. Permutation hashing

Our goal is to show that ùëêùë° is usually not far from its expected value, which is ùëÅ /ùêµ. If the
quantities {[ùëèùëñùëõ[ùëõ] = ùëç ]}ùëõ were independent, we would be able to apply a standard concentration
bound to the sum ùëêùë°. However, {ùëèùëñùëõ[ùëõ] = ùëç }ùëõ are not independent: for instance, since exactly ùêæ
elements from [ùêµ ¬∑ ùêæ] map to ùëç , if ùëèùëñùëõ[ùëõ] = ùëç for ùëõ ‚àà {0, 1, . . . , ùêæ ‚àí 1}, then ùëèùëñùëõ[ùêæ] = ùëç must be
false.

Nevertheless, we can show that {[ùëèùëñùëõ[ùëõ] = ùëç ]}ùëõ are negatively associated random variables.
Intuitively, {ùëî[ùëõ]}ùëõ are NA random variables because the result of a uniformly random permu-
tation is NA. Then, {ùëèùëñùëõ[ùëõ]}ùëõ is computed by mapping the function ùëöùëúùëë (‚àí, ùêµ) over the array ùëî;
since this produces another uniform permutation distribution, the vector {ùëèùëñùëõ[ùëõ]}ùëõ is also NA. By
similar reasoning {[ùëèùëñùëõ[ùëõ] = ùëç ]}ùëõ is also NA, as it is obtained by mapping the function [‚àí = ùëç ]
over {ùëèùëñùëõ[ùëõ]}ùëõ. Since this example is similar to the Ô¨Årst Bloom Ô¨Ålter example, except applying
the negative association of the permutation distribution (Perm-PNA) and the permutation map
axiom (Perm-Map), we defer the details to the appendix.

6.5 Fully-dynamic dictionary

For our next example, we consider a hashing scheme for a fully-dynamic dictionary, a space-
eÔ¨Écient data structure that supports insertions, deletions, and membership queries. The top level
of the data structure by Bercea and Even [2019] uses a two-level hashing scheme: elements are
Ô¨Årst hashed into a crate, and then hashed into a pocket dictionary within each crate. As part of the
space analysis of their scheme, Bercea and Even [2019] proves a high-probability bound on the
number of pocket dictionaries that overÔ¨Çow after a given number of elements are inserted.

We extract the program FDDict in Figure 8a from the scheme in Bercea and Even [2019]. The
program models the insertion of ùëÅ elements. Each element is Ô¨Årst hashed into one of ùê∂ possible

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:25

FDDict :

ùëèùëñùëõùê∂ùë° ‚Üê ùëßùëíùëüùëú (ùê∂, ùëÉ);
ùëõ ‚Üê 0;
while ùëõ < ùëÅ do
ùëêùëüùëéùë°ùëí [ùëõ]
ùëùùëúùëêùëòùëíùë° [ùëõ]
$‚Üê ùëú‚Ñé( [ùëÉ]);
ùëèùëñùëõ[ùëõ] ‚Üê ùëêùëüùëéùë°ùëí [ùëõ]‚ä§ ¬∑ ùëùùëúùëêùëòùëíùë° [ùëõ];
ùëù ‚Üê 0;
while ùëù < ùëÉ do

$‚Üê ùëú‚Ñé( [ùê∂]);

ùëê ‚Üê 0;
while ùëê < ùê∂ do

ùë¢ùëùùëë ‚Üê ùëèùëñùëõùê∂ùë° [ùëê] [ùëù] + ùëèùëñùëõ[ùëõ] [ùëê] [ùëù];
ùëèùëñùëõùê∂ùë° [ùëê] [ùëù] ‚Üê ùë¢ùëùùëë;
ùëê ‚Üê ùëê + 1;

ùëù ‚Üê ùëù + 1;

ùëõ ‚Üê ùëõ + 1;

ùëù ‚Üê 0;
while ùëù < ùëÉ do

ùëê ‚Üê 0;
while ùëê < ùê∂ do

ùëúùë£ùëíùëü [ùëê] [ùëù] ‚Üê [ùëèùëñùëõùê∂ùë° [ùëê] [ùëù] > ùëáùëèùëñùëõ];
ùë¢ùëùùëë ‚Üê ùëúùë£ùëíùëüùê∂ùë° [ùëê] + ùëúùë£ùëíùëü [ùëê] [ùëù];
ùëúùë£ùëíùëüùê∂ùë° [ùëê] ‚Üê ùë¢ùëùùëë;
ùëê ‚Üê ùëê + 1;

ùëù ‚Üê ùëù + 1

RepeatBIB :
ùëü ‚Üê 0;
while ùëü < ùëÖ do

ùëõ ‚Üê 0
ùëüùëíùëö ‚Üê 0;
while ùëõ < ùëÅ do

ùëêùë° [ùëõ] ‚Üê ùëêùë° [ùëõ] ‚àí [ùëêùë° [ùëõ] > 0];
ùëüùëíùëö ‚Üê ùëüùëíùëö + [ùëêùë° [ùëõ] > 0];
ùëõ ‚Üê ùëõ + 1;

ùëó ‚Üê 0;
while ùëó < ùëüùëíùëö do

ùëèùëñùëõ[ ùëó ] $‚Üê ùëú‚Ñé( [ùëÅ ]);
ùëò ‚Üê 0;
while ùëò < ùëÅ do

ùë¢ùëùùëë ‚Üê ùëêùë° [ùëò] + ùëèùëñùëõ[ ùëó ] [ùëò];
ùëêùë° [ùëò] ‚Üê ùë¢ùëùùëë;
ùëò ‚Üê ùëò + 1;

ùëó ‚Üê ùëó + 1;

ùëõ ‚Üê 0;
ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ] ‚Üê 0;
ùëíùëöùëùùë°ùë¶ ‚Üê ùëñùë†ùëçùëíùëüùëú (ùëêùë°);
while ùëõ < ùëÅ do

ùë¢ùëùùëë ‚Üê ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ] + ùëíùëöùëùùë°ùë¶ [ùëõ];
ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ] ‚Üê ùë¢ùëùùëë;
ùëõ ‚Üê ùëõ + 1;

ùëü ‚Üê ùëü + 1;

(a) Fully-dynamic dictionary [Bercea and Even
2019]

(b) Repeated balls-into-bins [Becchetti et al. 2019]

Fig. 8. Larger examples

crates uniformly at random, and then hashed into one of ùëÉ possible pocket dictionaries uniformly
at random. The variable ùëèùëñùëõ[ùëõ] is a ùê∂ by ùëÉ matrix, with all entries zero except for the entry at
(ùëêùëüùëéùë°ùëí [ùëõ], ùëùùëúùëêùëòùëíùë° [ùëõ]), which is set to 1. Next, the program totals up the number of elements hash-
ing to each (crate, pocket) pair, storing the result in the ùê∂ by ùëÉ matrix ùëèùëñùëõùê∂ùë°. Finally, the program
checks which (crate, pocket) pairs have count larger than some concrete threshold ùëáùëèùëñùëõ (ùëúùë£ùëíùëü ), and
totals up the number of full pocket dictionaries in each crate (ùëúùë£ùëíùëüùê∂ùë°).

Our logic can prove a judgment of the following form:

‚ä§

FDDict

(cid:26)

(cid:27)

ùê∂

(cid:26)

√õùõæ=0

Pr[ùëúùë£ùëíùëüùê∂ùë° [ùõæ] > ùëÉ ¬∑ ùúåùëèùëñùëõ + ùëá (ùúåùëúùë£ùëíùëü , ùëÉ)] ‚â§ ùúåùëúùë£ùëíùëü

,

(cid:27)

where the logical variables ùúåùëèùëñùëõ and ùúåùëúùë£ùëíùëü represents the parametric overÔ¨Çow properties. This for-
malizes a result similar to Bercea and Even [2019, Claim 21], which states that except with proba-
bility ùõΩ, all crates have at most ùëáùëúùë£ùëíùëü overfull pocket dictionaries. The core of the proof shows that
for every crate index ùõæ, the counts ùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ] are negatively associated, using the NegFrame
rule as in the array version of the Bloom Ô¨Ålter example. Then, we show that vector ùëúùë£ùëíùëü [ùõæ] [ùõΩ],
which indicates whether each pocket dictionary ùõΩ in crate ùõæ is overfull or not, is also negatively

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:26

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

associated. This holds because ùëúùë£ùëíùëü [ùõæ] [ùõΩ] is obtained from ùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ] by applying a monotone
function. Furthermore, the count of overÔ¨Çows ùëúùë£ùëíùëüùê∂ùë° [ùõæ] is obtained by another monotone func-
tion on ùëúùë£ùëíùëü [ùõæ] [ùõΩ] and thus its entries are also negatively associated.

6.6 Repeated balls-into-bins process
Our Ô¨Ånal example considers a probabilistic protocol proposed by Becchetti et al. [2019], imple-
mented as RepeatBIB in Figure 8b. Intuitively, the program implements a repeated balls-into-bins
process. Initially, ùëÅ balls are distributed among ùëÅ bins (ùëêùë° [ùëõ]). For ùëÖ rounds, in each round a ball
is Ô¨Årst removed from every non-empty bin. Then, the ùëüùëíùëö removed balls are randomly reassigned
to bins. This process is useful for distributed protocols and scheduling algorithms, where the balls
represent tasks and the bins represent computation nodes. Becchetti et al. [2019] proposed and
analyzed this algorithm (e.g., bounding the maximum load, proving how long it takes for all balls
to visit all bins). We can verify the following lower-bound on the number of empty bins, analogous
to Becchetti et al. [2019, Lemma 1 and Lemma 2]:

Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

ùëÅ

ùëÅ ‚â• 2‚àß

ùëêùë° [ùõº] ‚àº ùëÅ

√ïùõº =0

(

RepeatBIB

Pr

(

)

ùëÖ

√úùõΩ=0

(ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùõΩ] < ùëÅ /15 ‚àí ùëá (ùúåùëíùëöùëùùë° ùë¶, ùëÅ ))

‚â§ ùëÖ¬∑ùúåùëíùëöùëùùë° ùë¶

)

Two aspects of this program make it more diÔ¨Écult to verify. First, there is a loop with a ran-
domized guard: the number of removed balls ùëüùëíùëö is randomized quantity. Reasoning about such
loops is challenging, because our Loop rule is not directly applicable and only far weaker rules are
available for loops with general randomized guards. Becchetti et al. [2019] sidestep this problem
by conditioning on the number of balls in each bin, which also Ô¨Åxes ùëüùëíùëö to be some value, prov-
ing the target property for every Ô¨Åxed setting, and then combining the proofs together. LINA can
formalize this style of reasoning using the randomized case analysis rule (RCase) to condition on
ùëüùëíùëö‚Äôs value, and then apply the Loop rule; however, the post-condition of RCase must be closed
under mixtures (CM), while independence and negative association are known not to satisfy this
side-condition. Thus, it is not possible to prove negative association by Ô¨Årst conditioning and then
combining. To work around this second problem, we use a technique from Becchetti et al. [2019]
and prove, on each conditional distribution, a high-probability bound using the ChernoÔ¨Ä bound.
The beneÔ¨Åt of this approach is that high-probability bounds are CM, so we can apply RCase to com-
bine the results. In our view, the fact that LINA can handle this kind of subtle argument involving
conditioning is a strength of our approach.

7 RELATED WORK

Bunched implications. The logic of bunched implications (BI) [O‚ÄôHearn and Pym 1999; Pym 2002]
is a well-studied substructural logic. BI has a resource semantics [Pym et al. 2004], where states
are resources and the separating conjunction combines compatible resources together. We follow
Docherty‚Äôs uniform presentation and investigation of BI [Docherty 2019]; in particular, our neg-
ative association model relies on Docherty‚Äôs non-deterministic frame conditions, and we use his
duality-theoretic framework to establish ùëÄ-BI‚Äôs metatheory.

Separation logics. The Ô¨Årst separation logic was developed to verify pointer-manipulating pro-
grams [Ishtiaq and O‚ÄôHearn 2001; O‚ÄôHearn et al. 2001; Reynolds 2001]. There is long line of work
on separation logic for concurrency, starting from [Brookes 2007; O‚ÄôHearn 2007] and continuing
to the present day (e.g., [Jung et al. 2018; Sergey et al. 2015]).

More recently, separation logics have been developed for probabilistic programs. LINA is an
extension of PSL [Barthe et al. 2020], a separation logic for probabilistic independence. Bao et al.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:27

[2021] propose DIBI, an extension of BI with a non-commutative conjunction, and developed a
program logic with DIBI assertions that is capable of proving conditional independence. Batz et al.
[2019] propose QSL, a separation logic where assertions have a quantitative interpretation, and
used their logic to verify probabilistic and heap-manipulating programs. Tassarotti and Harper
[2019] develop a separation logic for relational reasoning about probabilistic programs, using the
coupling approach of pRHL [Barthe et al. 2012].

Verifying approximate data structures and applying concentration bounds. Bloom Ô¨Ålters are a data
structure supporting approximate membership queries (AMQs). Ceramist [Gopinathan and Sergey
2020] is a recent framework for verifying hash-based AMQ structures in the Coq theorem prover.
Besides handling Bloom Ô¨Ålters, Ceramist supports subtle proofs of correctness for many other
AMQs. Compared with our approach, Ceramist proofs are more precise but also more intricate,
applying theorems about Stirling numbers to achieve a precise bound on the false positive prob-
ability. In contrast, our approach reasons about negative dependence to achieve a substantially
simpler proof, albeit with less precise bounds.

Prior works in veriÔ¨Åcation have also applied the ChernoÔ¨Ä bound to bound sums of indepen-
dent random quantities (e.g., [Chakarov and Sankaranarayanan 2013; Wang et al. 2021]). While
independence is easier to establish, the negative association property that we need is more subtle.

Negative dependence. There are multiple deÔ¨Ånitions of negative dependence in the literature,

each with their own strengths and weaknesses. We work with negative association (NA) [Dubhashi and Ranjan
1998; Joag-Dev and Proschan 1983], because it holds in many situations where negative depen-
dence should hold and it is closed under various notions of composition. Recently, the notion of
Strong Rayleigh (SR) [Borcea et al. 2009] distribution has been proposed as an ideal deÔ¨Ånition of
negative dependence. The SR condition satisÔ¨Åes more closure properties than NA does; in partic-
ular, it is preserved under various forms of conditioning. However, SR distributions have mostly
been studied for Boolean variables only, and we do not know if an analogue of the monotone maps
property of NA holds for SR.

Beyond theoretical investigations, negative dependence plays a useful role in many practical
applications. In machine learning, negative dependence can help ensure diversity in predictions
by a model [Kulesza and Taskar 2012], and fast algorithms are known to learn and sample from
negatively-dependent distributions [Anari et al. 2016]. In algorithm design, negative dependence is
a useful tool to randomly round solutions of linear programs to integral solutions [Srinivasan 2001].
Negative dependence can ensure that certain constraints are satisÔ¨Åed exactly after rounding, while
still allowing concentration bounds to be applied to analyze the quality of the rounded solution.

8 CONCLUSION AND FUTURE DIRECTION
We introduced LINA, a probabilistic program logic that can reason about independence and nega-
tive association. Assertions in LINA are based on a novel probabilistic model of ùëÄ-BI, an extension
of the logic of Bunched Implications with multiple separating conjunctions. We demonstrated how
to use LINA to reason about probabilistic hashing schemes, and a repeated balls-into-bins process.
There are several natural directions for future work.

Other models of ùëÄ-BI, and non-deterministic frames. The assertion logic ùëÄ-BI was primarily
motivated by our NA model, but it is general enough that we believe there are likely other natural
models. Exploring these directions could allow modeling Ô¨Åner notions of separation, and could
further justify ùëÄ-BI as an interesting logic in its own right. It would also be interesting to see if
there are other models that use a non-deterministic operator to combine resources, as proposed
by Docherty [2019].

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:28

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

Verifying negative association for sampling algorithms. We used NA to analyze probabilistic hash-
ing schemes. Another classical application of NA is in sampling schemes, which generate a sam-
ple from a target distribution while satisfying certain constraints [Br√§nd√©n and Jonasson 2012;
Dubhashi et al. 2007]. NA samplers are useful in algorithm design [Srinivasan 2001] and statistics,
and it would be interesting to understand how to verify these programs. Many samplers employ
rejection sampling, which is not easily analyzed in LINA but which could be expressed with an
explicit conditioning operator, as in probabilistic programming languages [Gordon et al. 2014].

ACKNOWLEDGMENTS

We thank the anonymous reviewers for their helpful feedback and suggestions. This work bene-
Ô¨Åted from discussions with Simon Docherty. This work was supported in part by the NSF under
Grant No. 2035314, 1943130, 2040249, 2040222 and 2152831.

REFERENCES
Nima Anari, Shayan Oveis Gharan, and Alireza Rezaei. 2016.

Monte Carlo Markov chain algorithms for
sampling Strongly Rayleigh distributions and determinantal point processes.
In Conference on Computational
Learning Theory (COLT), Vol. 49. Proceedings of Machine Learning Research, New York, New York, 103‚Äì115.
http://proceedings.mlr.press/v49/anari16.html

Jialu Bao, Simon Docherty, Justin Hsu, and Alexandra Silva. 2021. A Bunched logic for conditional independence. In IEEE
Symposium on Logic in Computer Science (LICS). IEEE, Rome, Italy, 1‚Äì14. https://doi.org/10.1109/LICS52264.2021.9470712
Probabilistic relational Hoare logics for
computer-aided security Proofs. In Mathematics of Program Construction (MPC). Springer, Madrid, Spain, 1‚Äì6.
https://doi.org/10.1007/978-3-642-31113-0_1

Gilles Barthe, Benjamin Gr√©goire, and Santiago Zanella B√©guelin. 2012.

Gilles Barthe, Justin Hsu, and Kevin Liao. 2020. A probabilistic separation logic. Proceedings of the ACM on Programming

Languages 4, POPL (2020), 55:1‚Äì55:30. https://doi.org/10.1145/3371123

Kevin Batz, Benjamin Lucien Kaminski, Joost-Pieter Katoen, Christoph Matheja, and Thomas Noll. 2019. Quantitative
separation logic: a logic for reasoning about probabilistic pointer programs. Proceedings of the ACM on Programming
Languages 3, POPL (2019), 34:1‚Äì34:29. https://doi.org/10.1145/3290347

Luca Becchetti, Andrea Clementi, Emanuele Natale, Francesco Pasquale, and Gustavo Posta. 2019. Self-stabilizing repeated

balls-into-bins. Distributed Computing 32, 1 (2019), 59‚Äì68. https://doi.org/10.1007/s00446-017-0320-4

Ioana O. Bercea and Guy Even. 2019. Fully-dynamic space-eÔ¨Écient dictionaries and Ô¨Ålters with constant number of memory

accesses. CoRR abs/1911.05060 (2019). http://arxiv.org/abs/1911.05060

Burton H. Bloom. 1970. Space/time trade-oÔ¨Äs in hash coding with allowable errors. Commun. ACM 13, 7 (1970), 422‚Äì426.

https://doi.org/10.1145/362686.362692

Julius Borcea, Petter Br√§nd√©n,
ometry of polynomials.
https://www.ams.org/journals/jams/2009-22-02/S0894-0347-08-00618-8/

and Thomas M. Liggett.
Journal

2009.

the American Mathematical

of

Negative dependence

Society

22,

2

and the ge-
521‚Äì567.

(2009),

Prosenjit Bose, Hua Guo, Evangelos Kranakis, Anil Maheshwari, Pat Morin, Jason Morrison, Michiel Smid, and Yi-
Inform. Process. Lett. 108, 4 (2008), 210‚Äì213.

On the false-positive rate of Bloom Ô¨Ålters.

hui Tang. 2008.
https://doi.org/10.1016/j.ipl.2008.05.018

Petter Br√§nd√©n and Johan Jonasson. 2012. Negative dependence in sampling. Scandinavian Journal of Statistics 39, 4 (2012),

830‚Äì838. https://doi.org/10.1111/j.1467-9469.2011.00766.x

Stephen Brookes. 2007. A semantics for concurrent separation logic. Theoretical Computer Science 375, 1‚Äì3 (2007), 227‚Äì270.

https://doi.org/10.1016/j.tcs.2006.12.034

Aleksandar Chakarov and Sriram Sankaranarayanan. 2013.

Probabilistic program analysis with martingales.
In International Conference on Computer Aided VeriÔ¨Åcation (CAV). Springer, Saint Petersburg, Russia, 511‚Äì526.
https://doi.org/10.1007/978-3-642-39799-8_34

Bolin Ding and Arnd Christian K√∂nig. 2011. Fast set intersection in memory. Proceedings of the VLDB Endowment 4, 4

(2011), 255‚Äì266. https://doi.org/10.14778/1938545.1938550

Simon Docherty. 2019. Bunched logics: a uniform approach. Ph.D. Dissertation. UCL (University College London).
Devdatt P. Dubhashi, Johan Jonasson, and Desh Ranjan. 2007. Positive inÔ¨Çuence and negative dependence. Combinatorics,

Probability and Computing 16, 1 (2007), 29‚Äì41. https://doi.org/10.1017/S0963548306007772

Devdatt P. Dubhashi and Desh Ranjan. 1998. Balls and bins: A study in negative dependence. Random Structures and
Algorithms 13, 2 (1998), 99‚Äì124. https://doi.org/10.1002/(SICI)1098-2418(199809)13:2\<99::AID-RSA1\>3.0.CO;2-M

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:29

Kiran Gopinathan and Ilya Sergey. 2020. Certifying certainty and uncertainty in approximate membership query structures.
In International Conference on Computer Aided VeriÔ¨Åcation (CAV) (Lecture Notes in Computer Science, Vol. 12225). Springer,
Los Angeles, California, 279‚Äì303. https://doi.org/10.1007/978-3-030-53291-8_16

Andrew D. Gordon, Thomas A. Henzinger, Aditya V. Nori, and Sriram K. Rajamani. 2014. Probabilistic programming. In
Future of Software Engineering Proceedings (FOSE). Hyderabad, India, 167‚Äî-181. https://doi.org/10.1145/2593882.2593900
In
ACM SIGPLAN‚ÄìSIGACT Symposium on Principles of Programming Languages (POPL). London, England, 14‚Äì26.
https://doi.org/10.1145/360204.375719

BI as an assertion language for mutable data structures.

Samin Ishtiaq and Peter W. O‚ÄôHearn. 2001.

Kumar Joag-Dev and Frank Proschan. 1983. Negative association of random variables with applications. The Annals of

Statistics 11, 1 (1983), 286‚Äì295. https://doi.org/10.1214/aos/1176346079

Ralf Jung, Robbert Krebbers, Jacques-Henri Jourdan, Ales Bizjak, Lars Birkedal, and Derek Dreyer. 2018.

Iris from the
ground up: A modular foundation for higher-order concurrent separation logic. Journal of Functional Programming 28
(2018), e20. https://doi.org/10.1017/S0956796818000151

Dexter Kozen. 1981.

Semantics of probabilistic programs.

J. Comput. System Sci. 22, 3 (1981), 328‚Äì350.

https://doi.org/10.1016/0022-0000(81)90036-2

Alex Kulesza and Ben Taskar. 2012. Determinantal point processes for machine learning. Foundations and Trends in Machine

Learning 5, 2-3 (2012), 123‚Äì286. https://doi.org/10.1561/2200000044

Michael Mitzenmacher and Eli Upfal. 2005. Probability and computing - randomized algorithms and probabilistic analysis.

Cambridge University Press.

Peter W. O‚ÄôHearn. 2007. Resources, concurrency, and local reasoning. Theoretical Computer Science 375, 1‚Äì3 (2007), 271‚Äì307.

https://doi.org/10.1016/j.tcs.2006.12.035

Peter W. O‚ÄôHearn and David J. Pym. 1999. The logic of bunched implications. Bulletin of Symbolic Logic (1999), 215‚Äì244.

https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.4742&rep=rep1&type=pdf

Peter W. O‚ÄôHearn, John C. Reynolds, and Hongseok Yang. 2001. Local reasoning about programs that alter data structures.
In International Conference on Computer Science Logic (CSL) (Lecture Notes in Computer Science, Vol. 2142). Springer, Paris,
France, 1‚Äì19. https://doi.org/10.1007/3-540-44802-0_1

Jens Pagel and Florian Zuleger. 2021. Strong-Separation Logic. In European Symposium on Programming (ESOP), Lux-
embourg City, Luxembourg (Lecture Notes in Computer Science, Vol. 12648), Nobuko Yoshida (Ed.). Springer, 664‚Äì692.
https://doi.org/10.1007/978-3-030-72019-3_24

Robin Pemantle. 2000.

Towards a theory of negative dependence.

J. Math. Phys. 41, 3 (2000), 1371‚Äì1390.

David J. Pym.

https://doi.org/10.1063/1.533200
The
plied Logic Series, Vol. 26.
http://www.cantab.net/users/david.pym/BI-monograph-errata.pdf .

Kluwer Academic Publishers.

semantics and

2002.

proof

theory of

the

logic
of Bunched implications. Ap-
Errata and Remarks maintained at:

David J. Pym, Peter W. O‚ÄôHearn, and Hongseok Yang. 2004. Possible worlds and resources: The semantics of BI. Theoretical

Computer Science 315, 1 (2004), 257‚Äì305. https://www.sciencedirect.com/science/article/pii/S0304397503006248

John C. Reynolds. 2001. Intuitionistic reasoning about shared mutable data structure. Millennial Perspectives in Computer
Science 2, 1 (2001), 303‚Äì321. https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.11.5999&rep=rep1&type=pdf
Ilya Sergey, Aleksandar Nanevski, and Anindya Banerjee. 2015. Mechanized veriÔ¨Åcation of Ô¨Åne-grained concurrent pro-
grams. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI). ACM Press, Portland,
Oregon, 77‚Äì87. https://doi.org/10.1145/2737924.2737964

Aravind Srinivasan. 2001. Distributions on level-sets with applications to approximation algorithms. In IEEE Symposium on
Foundations of Computer Science (FOCS). IEEE, Las Vegas, Nevada, 588‚Äì597. https://doi.org/10.1109/SFCS.2001.959935
Joseph Tassarotti and Robert Harper. 2019. A separation logic for concurrent randomized programs. Proceedings of the

ACM on Programming Languages 3, POPL (2019), 64:1‚Äì64:30. https://doi.org/10.1145/3290377

Jinyi Wang, Yican Sun, Hongfei Fu, Krishnendu Chatterjee, and Amir Kafshdar Goharshady. 2021. Quantitative analysis
of assertion violations in probabilistic programs. In ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI). ACM Press, Virtual, 1171‚Äì1186. https://doi.org/10.1145/3453483.3454102

A PRELIMINARIES

Lemma A.1. Say S = {ùëÜùëñ | 1 ‚â§ ùëñ ‚â§ ùëÅ } where ùëÜùëñ are disjoint, ùëÜ = ‚à™S and ùúá ‚àà Mem[ùëÜ],

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:30

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

Then, ùëÜùëñ are independent in ùúá if and only if for any family of all monotone or all antitone functions

ùëìùëñ : Mem[ùëÜùëñ] ‚Üí R+,

Eùë•‚àºùúá

"

√ñùëÜùëñ ‚ààS

ùëìùëñ (pùëÜùëñ ùë•)

=

#

√ñùëÜùëñ ‚ààS

Eùë• ‚ààùúá [ùëìùëñ (pùëÜùëñ ùë•)].

(4)

Proof. The forward direction is straightforward. The backward direction needs more careful
analysis. In general, zero correlation does not imply independence, but here, we have the equality
for all family of monotone or antitone functions, so that suÔ¨Éces for independence.

We prove by induction on T = {ùëÜùëñ | 1 ‚â§ ùëñ ‚â§ ùêæ } that for any family of ùë£ùëñ ‚àà Mem[ùëÜùëñ ],

pùëÜùëñ ùë• = ùë£ùëñ

‚àß

!

Eùë• ‚ààùúá

√õùëÜùëñ ‚ààT

Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞

pùëÜùëñ ùë• < ùë£ùëñ

=

Eùë• ‚ààùúá

pùëÜùëñ ùë• = ùë£ùëñ

¬∑

Eùë• ‚ààùúá

pùëÜùëñ ùë• < ùë£ùëñ

.

√õùëÜùëñ ‚ààS\T
¬©

¬´

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

¬™
¬Æ
¬¨

√ñùëÜùëñ ‚ààT

(cid:2)

√ñùëÜùëñ ‚ààS\T

(cid:3)

(cid:2)

(cid:3)

(5)

Case |T | = 1: Say T = {ùëÜ ùëó }. Since indicator functions ùëÜùëñ < ùë£ùëñ and ùëÜùëñ ‚â§ ùë£ùëñ are both monotoni-

cally decreasing,

Eùë• ‚ààùúá

pùëÜ ùëó ùë• = ùë£ ùëó ‚àß (

pùëÜùëñ ùë• < ùë£ùëñ )

Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
= Eùë• ‚ààùúá
Ô£∞

= Eùë• ‚ààùúá

√õùëÜùëñ ‚ààS\T

pùëÜ ùëó ùë• ‚â§ ùë£ ùëó ‚àß (

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

pùëÜùëñ ùë• < ùë£ùëñ )

‚àí Eùë• ‚ààùúá

pùëÜ ùëó ùë• < ùë£ ùëó ‚àß (

pùëÜùëñ ùë• < ùë£ùëñ)

Ô£Æ
Ô£Ø
Ô£Ø
pùëÜ ùëó ùë• ‚â§ ùë£ ùëó
Ô£Ø
Ô£Ø
Ô£∞
(cid:2)

(cid:3)

¬∑

√õùëÜùëñ ‚ààS\T

Eùë• ‚ààùúá

√ñùëÜùëñ ‚ààS\T

(cid:2)

Ô£π
Ô£∫
Ô£∫
pùëÜùëñ ùë• < ùë£ùëñ
Ô£∫
Ô£∫
Ô£ª

Ô£Æ
Ô£Ø
Ô£Ø
‚àí Eùë• ‚ààùúá
Ô£Ø
Ô£Ø
Ô£∞

(cid:3)

(cid:2)

√õùëÜùëñ ‚ààS\T
¬∑

pùëÜ ùëó ùë• < ùë£ ùëó

Eùë• ‚ààùúá

Ô£π
Ô£∫
Ô£∫
pùëÜùëñ ùë• < ùë£ùëñ
Ô£∫
Ô£∫
Ô£ª

√ñùëÜùëñ ‚ààS\T

(cid:3)

(cid:2)

(By Equation (4))

(cid:3)

= (Eùë• ‚ààùúá

pùëÜ ùëó ùë• ‚â§ ùë£ ùëó

‚àí Eùë• ‚ààùúá

pùëÜ ùëó ùë• < ùë£ ùëó

) ¬∑

Eùë• ‚ààùúá

pùëÜùëñ ùë• < ùë£ùëñ

= Eùë• ‚ààùúá

(cid:2)
pùëÜ ùëó ùë• = ùë£ ùëó

(cid:3)
¬∑

(cid:2)
Eùë• ‚ààùúá

√ñùëÜùëñ ‚ààS\T

(cid:3)
pùëÜùëñ ùë• < ùë£ùëñ

(cid:2)

√ñùëÜùëñ ‚ààS\T

(cid:3)

(cid:2)

(cid:3)

(cid:2)

(cid:3)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

 
 
A Separation Logic for Negative Dependence

57:31

Case |T | > 1 Let ùëÜ ùëó be an element in T .

Eùë• ‚ààùúá

(

pùëÜùëñ ùë• = ùë£ùëñ ) ‚àß (

pùëÜùëñ ùë• < ùë£ùëñ)

√õùëÜùëñ ‚ààT

Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
= Eùë• ‚ààùúá
Ô£∞

pùëÜ ùëó ùë• ‚â§ ùë£ ùëó ‚àß (
Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
pùëÜ ùëó ùë• < ùë£ ùëó ‚àß (
Ô£∞
Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞
(cid:2)
pùëÜ ùëó ùë• < ùë£ ùëó

pùëÜ ùëó ùë• ‚â§ ùë£ ùëó

(cid:3)

¬∑

¬∑

‚àí Eùë• ‚ààùúá

= Eùë• ‚ààùúá

‚àí Eùë• ‚ààùúá

√õùëÜùëñ ‚ààS\T

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

pùëÜùëñ ùë• = ùë£ùëñ ) ‚àß (

pùëÜùëñ ùë• < ùë£ùëñ )

√õùëÜùëñ ‚ààT\{ùëÜ ùëó }

√õùëÜùëñ ‚ààS\T

pùëÜùëñ ùë• = ùë£ùëñ ) ‚àß (

√õùëÜùëñ ‚ààT\{ùëÜ ùëó }

√õùëÜùëñ ‚ààS\T
¬∑

pùëÜùëñ ùë• = ùë£ùëñ

Eùë• ‚ààùúá

√ñùëÜùëñ ‚ààT\{ùëÜ ùëó }

(cid:2)
pùëÜùëñ ùë• = ùë£ùëñ

(cid:3)

Eùë• ‚ààùúá

pùëÜùëñ ùë• = ùë£ùëñ

Eùë• ‚ààùúá

(cid:2)

(cid:2)

(cid:3)

(cid:3)

¬∑

¬∑

√ñùëÜùëñ ‚ààS\T

√ñùëÜùëñ ‚ààS\T

√ñùëÜùëñ ‚ààS\T

pùëÜùëñ ùë• < ùë£ùëñ )

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª
Ô£π
Ô£∫
Ô£∫
pùëÜùëñ ùë• < ùë£ùëñ
Ô£∫
Ô£∫
Ô£ª
(cid:2)
pùëÜùëñ ùë• < ùë£ùëñ

pùëÜùëñ ùë• < ùë£ùëñ

(cid:2)

(cid:2)

(cid:3)

(cid:3)

(cid:3)

Eùë• ‚ààùúá

Eùë• ‚ààùúá

Eùë• ‚ààùúá

(cid:2)

= Eùë• ‚ààùúá

pùëÜ ùëó ùë• = ùë£ ùëó

(cid:3)

¬∑

√ñùëÜùëñ ‚ààT\{ùëÜ ùëó }

When T = S, Equation (5) implies

(cid:2)

√ñùëÜùëñ ‚ààT\{ùëÜ ùëó }

(cid:3)

Eùë• ‚ààùúá

pùëÜùëñ ùë• = ùë£ùëñ

=

Eùë• ‚ààùúá

pùëÜùëñ ùë• = ùë£ùëñ

√ñùëÜùëñ ‚ààS
for any ùë£ùëñ‚Äôs. Thus, components in S are independent.

"
√õùëÜùëñ ‚ààS

#

(cid:2)

(cid:3)

(cid:3)

A.1 Coarsening

We prove some properties of coarsening. In the following we will use an alternative deÔ¨Ånition of
coarsening, which will be shown to be equivalent to what we deÔ¨Åne in the main text.

DeÔ¨Ånition A.2 (Alternative deÔ¨Ånition of coarsening). We Ô¨Årst index any partition S as S1, . . . , S|S | .
Say |S‚Ä≤| = ùëö, |S| = ùëõ. We say S‚Ä≤ coarsens a partition S there exists a function a ùëì : [ùëö] ‚Üí P ( [ùëõ])
such that 1) ‚à™ùëñ ‚àà[ùëö] ùëì (ùëñ) = [ùëõ]; 2) for any ùëñ, ùëó ‚àà [ùëö], either ùëñ = ùëó or ùëì (ùëñ), ùëì ( ùëó ) are disjoint; 3)
S‚Ä≤ = {‚à™{Sùëó

| ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [ùëö]}.

Lemma A.3. Let S, S‚Ä≤ be two partitions. Then S‚Ä≤ coarsens S according to DeÔ¨Ånition A.2 if and

only if S‚Ä≤ coarsens S according to DeÔ¨Ånition 4.6 .
Proof. We index S as S1, . . . , Sùëõ and S‚Ä≤ as S‚Ä≤
Backward direction: By that deÔ¨Ånition, we know a) for any S‚Ä≤

1, . . . , S‚Ä≤

|ùëö | .

b) ‚à™S = ‚à™S‚Ä≤.

ùëñ ‚àà S‚Ä≤, S‚Ä≤
ùëñ

= ‚à™R for some R ‚äÜ S;

We deÔ¨Åne the function ùëî : [ùëö] ‚Üí P ( [ùëõ]) as ùëî(ùëñ) = { ùëó | Sùëó ‚äÜ S‚Ä≤

ùëñ }. This ùëî would satisÔ¨Åes all the

conditions required:

(1) By substitution, ‚à™ùëñ ‚àà[ùëö]ùëî(ùëñ) = ‚à™ùëñ ‚àà[ùëö] { ùëó

| Sùëó ‚äÜ ùë† ‚Ä≤}. By b), for any
| Sùëó ‚äÜ S‚Ä≤
ùëó ‚àà [ùëõ], Sùëó ‚äÜ ‚à™S‚Ä≤. Then by a) and that S is a partition, if ùë† ‚Ä≤ covers any of Sùëó , it must
covers all of Sùëó , then Sùëó ‚äÜ ‚à™S‚Ä≤ implies there exists ùë† ‚Ä≤ ‚àà S‚Ä≤ such that Sùëó ‚äÜ ùë† ‚Ä≤. Thus,
ùëó ‚àà { ùëó | Sùëó ‚äÜ ùë† ‚Ä≤} ‚äÜ ‚à™ùë†‚Ä≤ ‚ààS‚Ä≤ { ùëó | Sùëó ‚äÜ ùë† ‚Ä≤}. For any ùëó ‚àâ [ùëõ], Sùëó is undeÔ¨Åned, so it is impossible
that Sùëó ‚äÜ ùë† ‚Ä≤ for some ùë† ‚Ä≤ ‚äÜ S‚Ä≤. Therefore, ‚à™ùë†‚Ä≤ ‚ààS‚Ä≤ { ùëó | Sùëó ‚äÜ ùë† ‚Ä≤} = [ùëõ].
ùëñ . If ùëñ ‚â† ùëó , then S‚Ä≤
ùëó , and ùëò ‚àâ ùëî( ùëó ). So for any ùëñ ‚â† ùëó , ùëî(ùëñ), ùëî( ùëó ) are disjoint.

ùëó are disjoint since S‚Ä≤ is a partition. Thus,

(2) For any ùëò ‚àà ùëî(ùëñ), Sùëò ‚äÜ S‚Ä≤

ùëñ } = ‚à™ùë†‚Ä≤ ‚ààS‚Ä≤ { ùëó

ùëñ and S‚Ä≤

Sùëò * S‚Ä≤

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:32

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

(3) By substitution,

{‚à™{Sùëó

| ùëó ‚àà ùëî(ùëñ)} | ùëñ ‚àà [ùëö]} = {‚à™{Sùëó

| Sùëó ‚äÜ S‚Ä≤

ùëñ } | ùëñ ‚àà [ùëö]} = {‚à™{Sùëó

| Sùëó ‚äÜ ùë† ‚Ä≤} | ùë† ‚Ä≤ ‚àà S‚Ä≤}.

Again, by a) and that S is a partition, if ùë† ‚Ä≤ ‚àà S covers any part of of Sùëó , it must covers all of
Sùëó , so ‚à™{Sùëó

| Sùëó ‚äÜ ùë† ‚Ä≤} = ùë† ‚Ä≤. Thus, {‚à™{Sùëó

| Sùëó ‚äÜ ùë† ‚Ä≤} | ùë† ‚Ä≤ ‚àà S‚Ä≤} = S‚Ä≤.

Forward direction: By 3), we know that S‚Ä≤ = {‚à™{Sùëó

ùëñ ‚àà S‚Ä≤,
ùëó ‚àà ùëì (ùëñ)}, which is a subset of S‚Ä≤ by construction. So we proved a). Also,
| ùëó ‚àà ùëì (ùëñ) | ùëñ ‚àà [ùëö]}, and by 1), that is equivalent to

| ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [ùëö]}. So for any S‚Ä≤

we have ùë† ‚Ä≤ = ‚à™{Sùëó
‚à™S‚Ä≤ = ‚à™{‚à™{Sùëó
‚à™{Sùëó

| ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [ùëö]} = ‚à™{Sùëó
| ùëó ‚àà [ùëõ]}, which is equivalent to ‚à™S.

|

(cid:3)

We can prove that coarsening commute with projections.

Lemma A.4. Given a partition S = {Sùëñ }ùëñ and a set ùëã , let Sùëã = {Sùëñ ‚à© ùëã | Sùëñ ‚àà S}. For any T
coarsening Sùëã , there exists a coarsening S‚Ä≤ of S such that T = {Sùëñ ‚à© ùëã | Sùëñ ‚àà S‚Ä≤}; conversely, for
any S‚Ä≤ coarsening S, and S‚Ä≤
ùëã

= {Sùëñ ‚à© ùëã | Sùëñ ‚àà S‚Ä≤}, we have S‚Ä≤

ùëã coarsens Sùëã .

Proof. Forward direction: By DeÔ¨Ånition A.2, there exists a coarsening function ùëì such that

T = {‚à™{(Sùëã ) ùëó

| ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [|T |]}
= {‚à™{Sùëó ‚à© ùëã | ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [|T |]}
= {(‚à™{Sùëó
= {ùëÜ ‚Ä≤ ‚à© ùëã | ùëÜ ‚Ä≤ ‚àà S‚Ä≤}

| ùëó ‚àà ùëì (ùëñ)}) ‚à© ùëã | ùëñ ‚àà [|T |]}

(where S‚Ä≤ = {‚à™{Sùëó

| ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [|T |]})

S‚Ä≤ has the same size as T , so S‚Ä≤ = {‚à™{Sùëó

| ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [|S‚Ä≤|]}, and thus S‚Ä≤ coarsens S.

Backward direction: S‚Ä≤ coarsens S, so there exists a coarsening function ùëì such that

Thus,

S‚Ä≤ = {‚à™{ùëÜ ùëó

| ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [|S‚Ä≤|]}.

S‚Ä≤
ùëã = {(‚à™{ùëÜ ùëó

| ùëó ‚àà ùëì (ùëñ)}) ‚à© ùëã | ùëñ ‚àà [|S‚Ä≤|]}

= {‚à™{ùëÜ ùëó ‚à© ùëã | ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [|S‚Ä≤|]}
= {‚à™{ùëÜùëã ùëó

| ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [|S‚Ä≤|]}.

Therefore, S‚Ä≤

ùëã coarsens Sùëã .

(cid:3)

B THE LOGIC ùëÄ-BI
Figure 9 gives a Hilbert-style proof system for ùëÄ-BI. If one erases the subscripts on ‚àó and ‚àí‚àó, then
the rules without the last three form a Hilbert proof system for BI.

Using the M-BI rules, we can derive the rule Cut:

ùëÑ ‚ä¢ ùëÖ
ùëÉ ‚àß ùëÑ ‚ä¢ ùëÖ
ùëÉ ‚ä¢ ùëÑ ‚Üí ùëÖ

ùëÉ ‚ä¢ ùëÖ

‚àß2
‚Üí
Cut

ùëÉ ‚ä¢ ùëÑ

Lemma 3.1. The following rules are derivable in ùëÄ-BI:

ùëö1 ‚â§ ùëö2
ùëÉ ‚àí‚àóùëö2 ùëÑ ‚ä¢ ùëÉ ‚àí‚àóùëö1 ùëÑ

‚àí‚àó-Weakening

ùëö1 ‚â§ ùëö2
ùêºùëö2 ‚ä¢ ùêºùëö1

UnitWeakening

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:33

ùëÉ ‚ä¢ ùëÉ

‚ä§

ùëÉ ‚ä¢ ‚ä§

‚ä•

‚ä• ‚ä¢ ùëÉ

ùëÉ ‚ä¢ ùëÖ

ùëÑ ‚ä¢ ùëÖ

ùëÉ ‚à® ùëÑ ‚ä¢ ùëÖ

‚à®-E

ùëÉ ‚ä¢ ùëÑùëñ
ùëÉ ‚ä¢ ùëÑ1 ‚à® ùëÑ2

‚à®-I

ùëÉ ‚ä¢ ùëÑ

ùëÉ ‚ä¢ ùëÖ

ùëÉ ‚ä¢ ùëÑ ‚àß ùëÖ

‚àß-I1

ùëÑ ‚ä¢ ùëÖ

ùëÉ ‚àß ùëÑ ‚ä¢ ùëÖ

‚àß-I2

ùëÉ ‚ä¢ ùëÑ1 ‚àß ùëÑ2
ùëÉ ‚ä¢ ùëÑùëñ

‚àß-E

ùëÉ ‚àß ùëÑ ‚ä¢ ùëÖ

ùëÉ ‚ä¢ ùëÑ ‚Üí ùëÖ

‚Üí-I

ùëÉ ‚ä¢ ùëÑ ‚Üí ùëÖ

ùëÉ ‚ä¢ ùëÑ

ùëÉ ‚ä¢ ùëÖ

‚Üí-E

ùëÉ ‚àóùëö ùëÑ ‚ä¢ ùëÖ
ùëÉ ‚ä¢ ùëÑ ‚àí‚àóùëö ùëÖ

‚àí‚àó

ùëÉ ‚ä¢ ùëÑ ‚àí‚àóùëö ùëÖ

ùëÜ ‚ä¢ ùëÑ

ùëÉ ‚àóùëö ùëÜ ‚ä¢ ùëÖ

‚àí‚àó-E

ùëÉ ‚ä£‚ä¢ ùëÉ ‚àóùëö ùêºùëö

‚àó-Unit

ùëÉ ‚ä¢ ùëÖ
ùëÑ ‚ä¢ ùëÜ
ùëÉ ‚àóùëö ùëÑ ‚ä¢ ùëÖ ‚àóùëö ùëÜ

‚àó-Conj

ùëÉ ‚àóùëö ùëÑ ‚ä¢ ùëÑ ‚àóùëö ùëÉ

‚àó-Comm

(ùëÉ ‚àóùëö ùëÑ) ‚àóùëö ùëÖ ‚ä£‚ä¢ ùëÉ ‚àóùëö (ùëÑ ‚àóùëö ùëÖ)

‚àó-Assoc

ùëö1 ‚â§ ùëö2
ùëÉ ‚àóùëö1 ùëÑ ‚ä¢ ùëÉ ‚àóùëö2 ùëÑ

‚àó-Inclusion

Fig. 9. Hilbert system for ùëÄ-BI

Proof. Let ùëö1 ‚â§ ùëö2. For the Ô¨Årst rule, it suÔ¨Éces to show that (ùëÉ ‚àí‚àóùëö2 ùëÑ) ‚àóùëö1 ùëÉ ‚ä¢ ùëÑ. By ‚àó-
Weakening, we have that (ùëÉ ‚àí‚àóùëö2 ùëÑ) ‚àóùëö1 ùëÉ ‚ä¢ (ùëÉ ‚àí‚àóùëö2 ùëÑ) ‚àóùëö2 ùëÉ so the result follows from Cut
and ‚àí‚àó ‚àíE.

For the second rule, ‚àó1-Unit implies ùêºùëö2 ‚ä¢ ùêºùëö2 ‚àóùëö1 ùêºùëö1 ; ‚àó-Weakening implies ùêºùëö2 ‚àóùëö1 ùêºùëö1 ‚ä¢
(cid:3)

ùêºùëö2 ‚àóùëö2 ùêºùëö1 ; and ‚àó2-Unit implies ùêºùëö2 ‚àóùëö2 ùêºùëö1 ‚ä¢ ùêºùëö1 . Then by Cut, we have ùêºùëö2 ‚ä¢ ùêºùëö1

C THE MODEL OF NEGATIVE DEPENDENCE AND INDEPENDENCE

C.1 A BI model for negative association

Theorem 4.9. For any two states ùúá1, ùúá2 ‚àà ùëã , ùúá1 ‚äïùë† ùúá2 ‚äÜ ùúá1 ‚äï ùúá2 ‚äÜ ùúá1 ‚äïùë§ ùúá2.

Proof. Let ùëÜ denote dom(ùúá1) and ùëá denote dom(ùúá2).
For any ùúá ‚àà ùúá1 ‚äïùë† ùúá2, we have ùúãùëÜ ùúá = ùúá1, ùúãùëá ùúá = ùúá2, and ùúá satisÔ¨Åes NA. ùúá being NA implies
ùúá is R-PNA for any partition R on dom(ùúá) So for any partition S on ùëÜ, partition T on ùëá , ùúá is
S ‚à™ T -PNA. Therefore, ùúá ‚àà ùúá1 ‚äï ùúá2.

For any ùúá ‚àà ùúá1 ‚äï ùúá2, ùúãùëÜ ùúá = ùúá1, ùúãùëá ùúá = ùúá2, and ùúá is {ùëÜ,ùëá }-PNA since ùúá1 is {ùëÜ }-PNA, ùúá2 is {ùëá }-PNA.
(cid:3)

Thus, ùúá ‚àà ùúá1 ‚äïùë§ ùúá2.

Theorem 4.11. The structure XPNA = (ùëã, ‚äë, ‚äï, ùê∏PNA) is a Down-Closed BI frame.

Proof. We sketch the conditions, using the notation from the deÔ¨Ånition:
Down-Closed. Let ùëëùëúùëö(ùë•) = ùëÜ, ùëëùëúùëö(ùë• ‚Ä≤) = ùëÜ ‚Ä≤, ùëëùëúùëö(ùë¶) = ùëá , ùëëùëúùëö(ùë¶‚Ä≤) = ùëá ‚Ä≤. We claim that we
can take ùëß‚Ä≤ = ùúãùëÜ‚Ä≤‚à™ùëá ‚Ä≤ùëß. We evidently have ùëß ‚äí ùëß‚Ä≤, and ùúãùëÜ‚Ä≤ùëß‚Ä≤ = ùúãùëÜ‚Ä≤ùúãùëÜùëß = ùë• ‚Ä≤ and ùúãùëá ‚Ä≤ùëß‚Ä≤ =
ùúãùëá ‚Ä≤ùúãùëá ùëß = ùë¶‚Ä≤.
What remains to show is that ùëß‚Ä≤ is S ‚à™ T -PNA for any S, T such that ùë• ‚Ä≤ is S-PNA, ùë¶‚Ä≤ is
T -PNA, and (‚à™S) ‚à© (‚à™T ) = ‚àÖ.
If ùë• ‚Ä≤ is S-PNA, then ùë• is S-PNA; if ùë¶‚Ä≤ is T -PNA, then ùë¶ is T -PNA; then ùëß ‚àà ùë• ‚äï ùë¶ must be
S ‚à™ T -PNA. Since ùëß‚Ä≤ := ùúãùëÜ‚Ä≤‚à™ùëá ‚Ä≤ùëß, and (‚à™S) ‚à™ (‚à™T ) ‚äÜ ùëÜ ‚Ä≤ ‚à™ ùëá ‚Ä≤, we have ùëß‚Ä≤ is S ‚à™ T -PNA too.
And evidently, ùëëùëúùëö(ùëß‚Ä≤) = ùëÜ ‚Ä≤ ‚à™ ùëá ‚Ä≤ = ùëëùëúùëö(ùë• ‚Ä≤) ‚à™ ùëëùëúùëö(ùë¶‚Ä≤). So ùëß‚Ä≤ ‚àà ùë• ‚Ä≤ ‚äï ùë¶‚Ä≤.

Commutativity. Immediate.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:34

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

Associativity. Let ùëëùëúùëö(ùë•) = ùëÖ, ùëëùëúùëö(ùë¶) = ùëÜ, ùëëùëúùëö(ùëß) = ùëá . We can assume that these sets are
all disjoint, otherwise there is nothing to prove. We claim that we can take ùë† = ùúãùëÜ‚à™ùëá ùë§. For
any ùë§ in ùë° ‚äï ùëß, ùë° ‚àà ùë• ‚äï ùë¶, we want to show that ùë§ ‚àà ùë• ‚äï ùë† and ùë† ‚àà ùë¶ ‚äï ùëß.
‚Ä¢ For any partition R, S such that (‚à™R) ‚à© (‚à™S) = ‚àÖ and ùë• is R-PNA, ùë† is S-PNA. For set
ùëã ‚àà Var, write {ùëå ‚à© ùëã | ùëå ‚àà S} as Sùëã . Then, by Lemma A.4, ùë† is S-PNA implies ùë¶ must
be SùëÜ -PNA. Similarly, ùë† is S-PNA implies ùëß must be Sùëá -PNA.
Then, ùë° ‚àà ùë• ‚äï ùë¶ must be R ‚à™ (SùëÜ )-PNA, and ùë§ ‚àà ùë° ‚äï ùëß must be R ‚à™ SùëÜ ‚à™ Sùëá -PNA. Note
that S coarsens SùëÜ ‚à™ Sùëá so ùë§ is R ‚à™ SùëÜ ‚à™ Sùëá -PNA implies that ùë§ is R ‚à™ S-PNA.
Also, ùúãùëÖùë§ = ùúãùëÖùúãùëÖ‚à™ùëÜùë§ = ùúãùëÖùë° = ùë•, and ùëëùëúùëö(ùë§) = ùëÖ ‚à™ ùëÜ ‚à™ ùëá = ùëëùëúùëö(ùë•) ‚à™ ùëëùëúùëö(ùë†).
Hence, ùë§ ‚àà ùë• ‚äï ùë†.

‚Ä¢ Note that ùë• is trivially {ùëÖ}-PNA. Then, for any partition S, T such that ùëÖ ‚à© (‚à™S) ‚à© (‚à™T ) =
‚àÖ and ùë¶ is S-PNA and ùëß is T -PNA, Ô¨Årst ùë° must be ({ùëÖ} ‚à™ S)-PNA, and then ùë§ must be
({ùëÖ} ‚à™ S ‚à™ T )-PNA. By projection, ùë† = ùúãùëÜ‚à™ùëá must be S ‚à™ T ùëß-PNA.
Also, ùúãùëÜùë† = ùúãùëÜ ùúãùëÜ‚à™ùëá ùë§ = ùúãùëÜùë§ = ùúãùëÜ ùúãùëÖ‚à™ùëÜùë§ = ùúãùëÜùë° = ùë¶, and similarly, ùúãùëá ùë† = ùëß. Also, ùëëùëúùëö(ùë†) =
ùëÜ ‚à™ ùëá = ùëëùëúùëö(ùë¶) ‚à™ ùëëùëúùëö(ùëß).
Hence, ùë† ‚àà ùë¶ ‚äï ùëß.

Unit Existence. Take ùëí to be ùúá where ùúá is the (unique) distribution in D (Mem[‚àÖ]).
Unit Closure. Immediate as we take ùê∏ = ùëÄ.
Unit Coherence. Immediate: ùë• ‚àà ùë¶ ‚äï ùëí entails ùë¶ = ùúãùëëùëúùëö (ùë¶) ùë•, which implies ùë¶ ‚äë ùë•.

(cid:3)

Theorem C.1. Given a set of variables ùëÜ, ùëÜ satisÔ¨Åes NA in ùúá iÔ¨Ä ùúá satisÔ¨Åes S-PNA for any S parti-

tioning ùëÜ iÔ¨Ä ùúá satisÔ¨Åes {{ùë†} | ùë† ‚àà ùëÜ }-PNA.

Proof. The second equivalence is straightforward:

‚Ä¢ {{ùë†} | ùë† ‚àà S} is a partition of ùëÜ, so we have the backward direction.
‚Ä¢ Any S partitioning ùëÜ coarsens {{ùë†} | ùë† ‚àà ¬ß}, so we have the Ô¨Årst direction.

For the forward direction of the Ô¨Årst equivalence, it suÔ¨Éces to prove that for any partition S of

ùëÜ, any family of all monotone or all antitone functions ùëìùëñ : Mem[ùëÜùëñ ] ‚Üí R+

Eùë•‚àºùúá

ùëìùëñ (pùëÜùëñùëö)

‚â§

#

"
√ñùëÜùëñ ‚ààS

√ñùëÜùëñ ‚ààS

(cid:2)

(cid:3)

Eùë•‚àºùúá

ùëìùëñ (pùëÜùëñùëö)

.

(6)

We prove that by induction on the size of S.
Base case |S| = 1: S-PNA is trivial.
Base case |S| = 2: S-PNA is straightforward from NA.
Inductive case: Assuming ùúá satisÔ¨Åes S-PNA for any partition with size less than ùêæ, we want

to show that ùúá satisÔ¨Åes S-PNA for any partition with size equals to ùêæ.
Say S = {ùëÜ1, . . . , ùëÜùêæ }. For any family of all monotone or all antitone functions ùëìùëñ : Mem[ùëÜùëñ] ‚Üí
ùêæ‚àí1
R+, either both ùëö ‚Ü¶‚Üí
ùëñ=1 ùëìùëñ (pùëÜùëñùëö) and
ùëìùêæ are antitone. Thus, by the inductive hypothesis

ùêæ‚àí1
ùëñ=1 ùëìùëñ (pùëÜùëñùëö) and ùëìùêæ are monotone, or both ùëö ‚Ü¶‚Üí

√é

ùêæ

Eùë•‚àºùúá

ùëìùëñ (pùëÜùëñùëö)

#

"

√ñùëñ=1

‚â§ Eùë•‚àºùúá

ùëìùëñ (pùëÜùëñùëö)

#

¬∑ Eùë•‚àºùúá

ùëìùêæ (pùëÜùêæ ùëö)

√é

ùëìùêæ (pùëÜùêæ ùëö)

(cid:2)

(cid:2)

(cid:3)

(cid:3)

ùêæ‚àí1

"

√ñùëñ=1
Eùë•‚àºùúá

‚â§

=

ùêæ‚àí1

√ñùëñ=1
ùêæ

√ñùëñ=1

ùëìùëñ (pùëÜùëñùëö)

¬∑ Eùë•‚àºùúá

(cid:3)

(cid:2)
ùëìùëñ (pùëÜùëñùëö)

.

Eùë•‚àºùúá

(cid:2)

(cid:3)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:35

The backward direction of the Ô¨Årst equivalence is more involved. For any two disjoint ùê¥, ùêµ ‚äÜ ùëÜ,
we know ùúá satisÔ¨Åes {ùê¥, ùêµ}-PNA, so for every pair of both monotone or both antitone functions
ùëì : Mem[ùê¥] ‚Üí R+, ùëî : Mem[ùêµ] ‚Üí R+,

Eùëö‚àºùúá [ùëì (pùê¥ùëö) ¬∑ ùëî(pùêµùëö)] ‚â§ Eùëö‚àºùúá [ùëì (pùê¥ùëö)] ¬∑ Eùëö‚àºùúá [ùëî(pùêµùëö)].

But the problem is to show this inequality when ùëì , ùëî are not both non-negative. We prove that in
three steps:

(1) If ùëì , ùëî are lower-bounded by ‚àíùêø, i.e., ùëì (ùë•) ‚â• ‚àíùêø and ùëî(ùë•) ‚â• ‚àíùêø for any ùë•. Then ùë• ‚Üí ùëì (ùë•) +ùêø

and ùë• ‚Üí ùëî(ùë•) + ùêø are both non-negative functions. Thus,

Eùëö‚àºùúá [(ùëì (pùê¥ùëö) + ùêø) ¬∑ (ùëî(pùêµùëö) + ùêø)] ‚â§ Eùëö‚àºùúá [ùëì (pùê¥ùëö) + ùêø] ¬∑ Eùëö‚àºùúá [ùëî(pùêµùëö) + ùêø].

(7)

Meanwhile,

E[(ùëì (pùê¥ùëö) + ùêø) ¬∑ (ùëî(pùêµùëö) + ùêø)] = E[ùëì (pùê¥ùëö) ¬∑ ùëî(pùêµùëö)] + ùêø ¬∑ E[ùëì (pùê¥ùëö)] + ùêø ¬∑ E[ùëî(pùêµùëö)] + ùêø2
E[ùëì (pùê¥ùëö) + ùêø] ¬∑ E[ùëî(pùêµùëö) + ùêø] = (E[ùëì (pùê¥ùëö)] + ùêø) ¬∑ (E[ùëî(pùêµùëö)] + ùêø)

= E[ùëì (pùê¥ùëö)] ¬∑ E[ùëî(pùêµùëö)] + ùêø ¬∑ E[ùëì (pùê¥ùëö)] + ùêø ¬∑ E[ùëî(pùêµùëö)] + ùêø2.

So Equation (7) implies that

Eùëö‚àºùúá [ùëì (pùê¥ùëö) ¬∑ ùëî(pùêµùëö)] ‚â§ Eùëö‚àºùúá [ùëì (pùê¥ùëö)] ¬∑ Eùëö‚àºùúá [ùëî(pùêµùëö)].

(2) If the codomain of ùëì or ùëî does not range across both negative and positive numbers, then
we can also prove the desired inequality by applying the monotone convergence theorem
on the result for lower-bounded functions.
‚Ä¢ Say ùëì is non-negative and ùëî is non-positive. For any natural number ùëõ, ùëö ‚àà Mem[ùê¥ ‚à™ ùêµ],
we deÔ¨Åne ùëîùëõ (pùêµùëö) = max(ùëî(pùêµùëö), ‚àíùëõ), ‚Ñéùëõ (ùëö) = ùëì (pùê¥ùëö) ¬∑ùëîùëõ(pùêµùëö). Then for any ùëõ, ùëîùëõ and
‚Ñéùëõ are lower-bounded non-positive functions; and for any ùëö, {ùëîùëõ (ùëö)}ùëõ ‚ààN is a monotoni-
cally decreasing sequence converging to ùëî(ùëö), {‚Ñéùëõ (ùëö)}ùëõ ‚ààN is a monotonically decreasing
sequence converging to ùëì (pùê¥ùëö) ¬∑ ùëî(pùêµùëö). By the monotone convergence theorem,

Eùëö‚àºùúá ùëì (pùê¥ùëö) ¬∑ ùëî(pùêµùëö) = lim
ùëõ‚Üí‚àû
Eùëö‚àºùúáùëî(pùêµùëö) = lim
ùëõ‚Üí‚àû

Eùëö‚àºùúá‚Ñéùëõ (ùëö)

Eùëö‚àºùúáùëîùëõ (ùúãùêµùëö).

By what we proved above, for any ùëõ, we have

Eùëö‚àºùúá [‚Ñéùëõ (ùëö)] ‚â§ Eùëö‚àºùúá [ùëì (pùê¥ùëö)] ¬∑ Eùëö‚àºùúá [ùëîùëõ (pùêµùëö)]

Taking that to the limit ùëõ ‚Üí ‚àû,

lim
ùëõ‚Üí‚àû

Eùëö‚àºùúá [‚Ñéùëõ (ùëö)] ‚â§ lim
ùëõ‚Üí‚àû
= lim
ùëõ‚Üí‚àû

Eùëö‚àºùúá [ùëì (pùê¥ùëö)] ¬∑ Eùëö‚àºùúá [ùëî(pùêµùëö)]

Eùëö‚àºùúá [ùëì (pùê¥ùëö)] ¬∑ lim
(cid:0)
ùëõ‚Üí‚àû

Eùëö‚àºùúá [ùëî(pùêµùëö)]

(cid:1)

Therefore, for any distribution ùúá ‚àà D (Mem[ùê¥ ‚à™ ùêµ]),

Eùëö‚àºùúá [ùëì (pùê¥ùëö) ¬∑ ùëî(pùêµùëö)] ‚â§ Eùëö‚àºùúá [ùëì (pùê¥ùëö)] ¬∑ Eùëö‚àºùúá [ùëî(pùêµùëö)].

‚Ä¢ The case where ùëì is non-positive and ùëî is non-negative is symmetric.
‚Ä¢ The case where ùëì and ùëî are both non-positive is also similar. We will deÔ¨Åne ùëìùëõ (pùê¥ùëö) =
max(ùëì (pùê¥ùëö), ‚àíùëõ), ùëîùëõ (pùêµùëö) = max(ùëî(pùêµùëö), ‚àíùëõ), ‚Ñéùëõ (ùëö) = ùëìùëõ (pùê¥ùëö) ¬∑ ùëîùëõ (pùêµùëö). Then we

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:36

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

have

Eùëö‚àºùúá ùëì (pùê¥ùëö) ¬∑ ùëî(pùêµùëö) = lim
ùëõ‚Üí‚àû
Eùëö‚àºùúáùëî(pùêµùëö) = lim
ùëõ‚Üí‚àû
Eùëö‚àºùúá ùëì (pùêµùëö) = lim
ùëõ‚Üí‚àû

Eùëö‚àºùúá‚Ñéùëõ (ùëö)

Eùëö‚àºùúáùëîùëõ (ùúãùêµùëö)

Eùëö‚àºùúá ùëìùëõ (ùúãùê¥ùëö).

And the rest follows.

(3) Now we consider the general case where we only know both ùëì and ùëî are either lower-

bounded or upper bounded.
‚Ä¢ If both ùëì and ùëî are lower-bounded, reduce to the Ô¨Årst case.
‚Ä¢ If ùëì is lower-bounded by ùêø, ùëî is upper-bounded by ùëà , then we can consider function ùëì ‚Ä≤ =
ùëì + ùêø and ùëî‚Ä≤ = ùëî ‚àí ùëà . Then ùëì ‚Ä≤ is non-negative and ùëî‚Ä≤ is non-positive, so by step 2, we have

Eùëö‚àºùúá [ùëì ‚Ä≤(pùê¥ùëö) ¬∑ ùëî‚Ä≤(pùêµùëö)] ‚â§ Eùëö‚àºùúá [ùëì ‚Ä≤(pùê¥ùëö)] ¬∑ Eùëö‚àºùúá [ùëî‚Ä≤(pùêµùëö)].

By calculations analogous to what we did in step 1, that implies

Eùëö‚àºùúá [ùëì (pùê¥ùëö) ¬∑ ùëî(pùêµùëö)] ‚â§ Eùëö‚àºùúá [ùëì (pùê¥ùëö)] ¬∑ Eùëö‚àºùúá [ùëî(pùêµùëö)].

‚Ä¢ If ùëì is upper-bounded and ùëî is lower-bounded: analogous to above.
‚Ä¢ If both ùëì and ùëî are upper-bounded: also, analogous to above.

Thus, ùúá satisÔ¨Åes {ùê¥, ùêµ}-PNA implies ùúá satisÔ¨Åes (ùê¥, ùêµ)-NA. And therefore, ùúá satisÔ¨Åes {ùê¥, ùêµ}-PNA

for any ùê¥, ùêµ ‚äÜ ùëÜ implies ùëÜ satisÔ¨Åes strong NA in ùúá.

(cid:3)

C.2 A 2-BI model for independence and negative association

The proof that independence implies PNA will use the following lemma.

Lemma C.2. In a distribution ùúá, if ùúá satisÔ¨Åes {ùëÜ1, ùëÜ2}-PNA, ùúá satisÔ¨Åes {ùëá1,ùëá2}-PNA, and ùëÜ1 ‚à™ ùëÜ2 is

independent from ùëá1 ‚à™ ùëá2 in ùúá then ùúá is {ùëÜ1 ‚à™ ùëá1, ùëÜ2 ‚à™ ùëá2}-PNA.

Proof. By the deÔ¨Ånition of PNA and independence, ùëÜ1, ùëÜ2 are disjoint, ùëá1,ùëá2 are disjoint, and
ùëÜ1 ‚à™ ùëá1, ùëÜ2 ‚à™ ùëá2 are disjoint. For any monotonically decreasing/increasing functions ùëì : Mem[ùëÜ1 ‚à™
ùëá1] ‚Üí R+, ùëî : Mem[ùëÜ2 ‚à™ ùëá2] ‚Üí R+,

Eùëö‚àºùúá [ùëì (pùëÜ1‚à™ùëá1ùëö) ¬∑ ùëî(pùëÜ2‚à™ùëá2ùëö)]
= Eùë†‚àºùúãùëÜ1‚à™ùëÜ2 ùúáEùë°‚àºùúãùëá1 ‚à™ùëá2 ùúá [ùëì (pùëÜ1ùë†, pùëá1ùë°) ¬∑ ùëî(pùëÜ2ùë†, pùëá2ùë°)]
Eùë°1‚àºùúãùëá1 ùúá [ùëì (pùëÜ1ùë†, ùë°1)] ¬∑ Eùë°2‚àºùúãùëá2 ùúá [ùëî(pùëÜ2ùë†, ùë°2)]
‚â§ Eùë†‚àºùúãùëÜ1‚à™ùëÜ2 ùúá
(cid:17)
‚â§ Eùë†1‚àºùúãùëÜ1 ùúá Eùë°1‚àºùúãùëá1 ùúá [ùëì (ùë†1, ùë°1)] ¬∑ Eùë†2‚àºùúãùëÜ2 ùúá Eùë°2‚àºùúãùëá2 ùúá [ùëî(ùë†2, ùë°2)]
‚â§ Eùëö‚àºùúá [ùëì (pùëÜ1‚à™ùëá1ùëö)] ¬∑ Eùëö‚àºùúá [ùëî(pùëÜ2‚à™ùëá2ùëö)]

(cid:16)

(By independence of ùëÜ1 ‚à™ ùëÜ2 and ùëá1 ‚à™ ùëá2)

(‚ô¶)

(‚ô•)
(‚ô£)

where ‚ô¶ is because ùúãùëá1‚à™ùëá2 ùúá is ùëá1,ùëá2-PNA and ùëì (pùëÜ1ùë†, ùë°1), ùëî(pùëÜ2ùë†, ùë°2) are both monotonically de-
creasing/increasing in ùëá1,ùëá2; ‚ô• is because ùúãùëÜ1‚à™ùëÜ2 ùúá is ùëÜ1, ùëÜ2-PNA and that Eùë°1‚àºùúãùëá1 ùúá [ùëì (pùëÜ1ùë†, ùë°1)], and
Eùë°2‚àºùúãùëá2 ùúá [ùëî(pùëÜ2ùë†, ùë°2)] are both monotonically decreasing/increasing in ùëÜ1, ùëÜ2; ‚ô£ is by independence
(cid:3)
of ùëÜ1 and ùëá1 and the independence of ùëÜ2 and ùëá2 in ùúá.

Theorem 4.12 (Independence implies PNA). Let ùëÜ,ùëá ‚äÜ Var be two disjoint sets of variables.
Suppose ùúá1 ‚àà D (Mem[ùëÜ]), ùúá2 ‚àà D (Mem[ùëá ]). If ùúá1 satisÔ¨Åes S-PNA and ùúá2 satisÔ¨Åes T -PNA, then
any ùúá ‚àà ùúáùëÜ ‚äó ùúáùëá satisÔ¨Åes S ‚à™ T -PNA.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:37

Proof. Fix S and T . Say S = {ùëÜ1, . . . , ùëÜùëù } and T = {ùëá1, . . . ,ùëáùëû }. For any R coarsening S ‚à™ T ,

indexing S ‚à™ T as {ùëà1, . . . , ùëàùëù+ùëû}, indexing R as {ùëÖ1, . . . , ùëÖùëõ}, we have:

Then, given a family of monotonically increasing/decreasing functions ùëîùëñ : ùëÖùëñ ‚Üí R+

R = {‚à™{ùëà ùëó

| ùëó ‚àà ùëì (ùëñ)} | ùëñ ‚àà [ùëõ]}.

| ùëó ‚àà ùëì (ùëñ)} can be divided into the part in ùëÜ and the part in ùëá . We refer to them

Eùëö‚àºùúá

"

√ñùëÖùëñ ‚ààR

ùëîùëñ (pùëÖùëñ ùëö)

#

= Eùëö‚àºùúá

ùëîùëñ (p‚à™{ùëà ùëó | ùëó ‚ààùëì (ùëñ) }ùëö)

.

Ô£Æ
√ñùëñ ‚àà[ùëõ ]
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

ùëñ may be empty). Thus, for each ùëñ,
ùëö).
1 , . . . ,ùëá ‚Ä≤

ùëîùëñ (p‚à™{ùëà ùëó | ùëó ‚ààùëì (ùëñ) }ùëö) = ùëîùëñ (pùëÜ‚Ä≤
ùëñ ‚à™ùëá ‚Ä≤
ùëñ
ùëõ} coarsens S, and T ‚Ä≤ = {ùëá ‚Ä≤

For each ùëñ, ‚à™{ùëà ùëó
ùëñ and ùëá ‚Ä≤
as ùëÜ ‚Ä≤

ùëñ . (Some of ùëÜ ‚Ä≤

ùëñ and ùëá ‚Ä≤

By Lemma A.4, S‚Ä≤ = {ùëÜ ‚Ä≤

1, . . . , ùëÜ ‚Ä≤

and T ‚Ä≤-PNA.

We prove by induction on ùëò ‚àà [ùëõ] that

Eùëö‚àºùúá

ùëîùëñ (pùëÜ‚Ä≤

ùëñ ‚à™ùëá ‚Ä≤
ùëñ

Ô£Æ
√ñùëñ ‚àà[ùëò ]
Ô£Ø
Ô£Ø
Base case When ùëò = 1, trivial.
Ô£Ø
Ô£Ø
Inductive case For ùëò < ùëõ, assume
Ô£∞

Eùëö‚àºùúá

ùëîùëñ (pùëÜ‚Ä≤

ùëñ ‚à™ùëá ‚Ä≤
ùëñ

ùëö)

.

√ñùëñ ‚àà[ùëò ]

(cid:2)

(cid:3)

ùëö)

‚â§

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

Eùëö‚àºùúá [

ùëîùëñ (pùëÜ‚Ä≤

ùëñ ‚à™ùëá ‚Ä≤
ùëñ

ùëö)] ‚â§

Eùëö‚àºùúá [ùëîùëñ (pùëÜ‚Ä≤

ùëñ ‚à™ùëá ‚Ä≤
ùëñ

ùëö)].

ùëõ} coarsens T . So ùúá is S‚Ä≤-PNA

√ñùëñ ‚àà[ùëò ]
√ñùëñ ‚àà[ùëò ]
ùëò+1}-PNA, and ùúá is T ‚Ä≤-PNA implies that
Note that ùúá is S‚Ä≤-PNA implies that ùúá is {‚à™ùëñ ‚àà[ùëò ] (ùëÜ ‚Ä≤
{‚à™ùëñ ‚àà[ùëò ] (ùëá ‚Ä≤
ùëñ ) ‚à™ {‚à™ùëñ ‚àà[ùëò ] (ùëá ‚Ä≤
ùëò+1}-
NA. Also, since all ùëîùëñ is monotonically increasing (decreasing) and non-negative, ùëö ‚Ü¶‚Üí
ùëñ ‚à™‚à™ùëñ ‚àà[ùëò ]ùëá ‚Ä≤
ùëñ

ùëñ ‚àà[ùëò ] ùëîùëñ (ùëö) is also a monotonically increasing (decreasing) function from ‚à™ùëñ ‚àà[ùëò ]ùëÜ ‚Ä≤

ùëò+1}-NA. Thus, by Lemma C.2, ùúá is also {{‚à™ùëñ ‚àà[ùëò ] (ùëÜ ‚Ä≤

ùëò+1 ‚à™ùëá ‚Ä≤

ùëñ ),ùëá ‚Ä≤

ùëñ ), ùëÜ ‚Ä≤

ùëñ ), ùëÜ ‚Ä≤

to R+. Therefore,
√é

Eùëö‚àºùúá [

ùëîùëñ (pùëÜ‚Ä≤

ùëñ ‚à™ùëá ‚Ä≤
ùëñ

√ñùëñ ‚àà[ùëò+1]

ùëö)] ‚â§ Eùëö‚àºùúá [

ùëîùëñ (pùëÜ‚Ä≤

ùëñ ‚à™ùëá ‚Ä≤
ùëñ

ùëö)] ¬∑ Eùëö‚àºùúá [ùëîùëò+1(pùëÜ‚Ä≤

ùëò+1‚à™ùëá ‚Ä≤

ùëò+1

ùëö)]

√ñùëñ ‚àà[ùëò ]
Eùëö‚àºùúá [ùëîùëñ (pùëÜ‚Ä≤

ùëñ ‚à™ùëá ‚Ä≤
ùëñ

ùëö)],

‚â§

√ñùëñ ‚àà[ùëò+1]

where the second inequality follows from the inductive hypothesis.

Thus, the desired inequality holds for any R coarsening S ‚à™ T and any family of monotonically
(cid:3)

increasing (decreasing) functions on R. Thus, ùúá is S ‚à™ T -PNA.

Theorem 4.15. If X1 and X2 are two M‚àíùêµùêº frames, then X = X1 √ó X2 is also an ùëÄ-BI frame.

Proof. Let Xùëñ,ùëö = (ùëãùëñ, ‚äëùëñ, ‚äïùëñ,ùëö, ùê∏ùëñ,ùëö). For any ùëñ ‚àà {1, 2}, ùëö ‚àà ùëÄ, Xùëñ,ùëö is a BI frame.
First, for any ùëö ‚àà ùëÄ, we prove that (ùëã, ‚äë, ‚äïùëö, ùê∏ùëö) is a BI frame.
Down-Closed. Let (ùëß1, ùëß2) ‚àà (ùë•1, ùë•2) ‚äïùëö (ùë¶1, ùë¶2) with (ùë•1, ùë•2) ‚äí (ùë• ‚Ä≤

1, ùë¶‚Ä≤
2).
Then, from the Down-Closed property of X1,ùëö and X2,ùëö respectively, we have that there
exists ùëß‚Ä≤
ùëñ ‚äï ùë¶‚Ä≤
2) and
1, ùëß‚Ä≤
(ùëß‚Ä≤

ùëñ for ùëñ ‚àà {1, 2}. Hence (ùëß1, ùëß2) ‚äí (ùëß‚Ä≤

2 such that ùëßùëñ ‚äíùëñ ùëß‚Ä≤
2) ‚äïùëö (ùë¶‚Ä≤

2) and (ùë¶1, ùë¶2) ‚äí (ùë¶‚Ä≤

1 and ùëß‚Ä≤
1, ùë¶‚Ä≤
1, ùë• ‚Ä≤
2).
Commutativity. Immediate.

2) ‚àà (ùë• ‚Ä≤

ùëñ and ùëß‚Ä≤

ùëñ ‚àà ùë• ‚Ä≤

1, ùë• ‚Ä≤

1, ùëß‚Ä≤

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:38

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

Associativity. Let (ùë§1, ùë§2) ‚àà (ùë°1, ùë°2) ‚äïùëö (ùëß1, ùëß2) and (ùë°1, ùë°2) ‚àà (ùë•1, ùë•2) ‚äïùëö (ùë¶1, ùë¶2). Then for
ùëñ ‚àà {1, 2} there exists ùë†ùëñ ‚àà ùë¶ùëñ ‚äïùëñ,ùëö ùëßùëñ such that ùë§ùëñ ‚àà ùë•ùëñ ‚äïùëñ,ùëöùë†ùëñ . Thus, (ùë†1, ùë†2) ‚àà (ùë¶1, ùë¶2) ‚äïùëö (ùëß1, ùëß2)
and (ùë§1, ùë§2) ‚àà (ùë•1, ùë•2) ‚äïùëö (ùë†1, ùë†2).

Unit Existence. Immediate.
Unit Closure. If (ùëí1, ùëí2) ‚àà ùê∏ùëö and (ùëí ‚Ä≤
Unit Coherence. Let (ùëí1, ùëí2) ‚àà ùê∏ùëö and (ùë•1, ùë•2) ‚àà (ùë¶1, ùë¶2) ‚äïùëö (ùëí1, ùëí2). Then ùë•ùëñ ‚äíùëñ ùë¶ùëñ , which
(cid:3)

2) ‚äí (ùëí1, ùëí2), then ùëí ‚Ä≤

ùëñ ‚àà ùê∏ùëñ,ùëö, so (ùëí ‚Ä≤

2) ‚àà ùê∏ùëö.

implies that (ùë•1, ùë•2) ‚äí (ùë¶1, ùë¶2).

1, ùëí ‚Ä≤

1, ùëí ‚Ä≤

Second, we show if ùëö ‚â§ ùëö‚Ä≤ ‚àà ùëÄ, then (ùúá1, ùúá‚Ä≤
X1 and X2 are ùëÄ-BI frames, so ùëö ‚â§ ùëö‚Ä≤ implies that ùúá1 ‚äï1,ùëö ùúá2 ‚äÜ1 ùúá1 ‚äï1,ùëö‚Ä≤ ùúá2 and ùúá‚Ä≤
2) ‚äÜ (ùúá1, ùúá‚Ä≤
1 ‚äï2,ùëö‚Ä≤ ùúá‚Ä≤
ùúá‚Ä≤

2. Therefore, (ùúá1, ùúá‚Ä≤

1) ‚äïùëö‚Ä≤ (ùúá2, ùúá‚Ä≤
2).

1) ‚äïùëö‚Ä≤ (ùúá2, ùúá‚Ä≤

1) ‚äïùëö (ùúá2, ùúá‚Ä≤

1) ‚äïùëö (ùúá2, ùúá‚Ä≤

2) ‚äÜ (ùúá1, ùúá‚Ä≤

2):

1 ‚äï2,ùëö‚Ä≤ ùúá‚Ä≤

2 ‚äÜ2

D PROGRAM LOGIC
D.1 The semantics of pWhile

DeÔ¨Ånition D.1 (Semantics of expressions). We assume all expressions are well-typed. We inter-
pret them as Mem[DV] √ó Mem[ùëá ] ‚Üí Val, which can be naturally lifted to Mem[DV] √ó
D (Mem[ùëá ]) ‚Üí D (Val). For ùúé ‚àà Mem[DV], ùëö ‚àà Mem[ùëá ],

Jùë•ùëë K(ùúé, ùëö) = ùúé (ùë•ùëë )
Jùë•ùëü K(ùúé, ùëö) = ùëö(ùë•ùëü )

J[ùëí1, . . . , ùëíùëõ]K(ùúé, ùëö) = [Jùëí1K(ùúé, ùëö), . . . , JùëíùëõK(ùúé, ùëö)]
Jùëí + ùëì K(ùúé, ùëö) = JùëíK(ùúé, ùëö) + Jùëì K(ùúé, ùëö)
Jùëí ‚àß ùëì K(ùúé, ùëö) = JùëíK(ùúé, ùëö) ‚àß Jùëì K(ùúé, ùëö)

when JùëíK(ùúé, ùëö) and Jùëìùëü K(ùúé, ùëö) are numbers
when JùëíK(ùúé, ùëö) and Jùëìùëü K(ùúé, ùëö) are booleans

DeÔ¨Ånition D.2 (Convex combination of distributions). Let the binary operator ‚ó¶ùúå takes a convex

combination of two distributions, i.e., for any ùúá1, ùúá2 ‚àà D (Mem[ùëÜ]), for any ùë• ‚àà Mem[ùëÜ],

ùúá1 ‚ó¶ùúå ùúá2 (ùë•) , ùúå ¬∑ ùúá1 (ùë•) + (1 ‚àí ùúå) ¬∑ ùúá2 (ùë•).
DeÔ¨Ånition D.3 (Semantics of pWhile). Let UnifùëÜ denotes the uniform distribution on Ô¨Ånite set ùëÜ,

i.e., ùúá : ùë† ‚Ü¶‚Üí 1

|ùëÜ | for any ùë† ‚àà ùëÜ.

We also assume that for any ùúé ‚àà Mem[DV], any ùúá1 ‚àà D (Mem[ùëá1]), ùúá2 ‚àà D (Mem[ùëá2]) where
ùëá1,ùëá2 ‚äÜ RV, the Ô¨Årst component of JùëêK(ùúé, ùúá1) and JùëêK(ùúé, ùúá2) are the same. For any (ùúé, ùúá) ‚àà Config,
let

JskipK(ùúé, ùúá) , (ùúé, ùúá)

Jùë•ùëë ‚Üê ùëíùëë K(ùúé, ùúá) , (ùúé [ùë•ùëë ‚Ü¶‚Üí Jùëíùëë K(ùúé, ùúá)], ùúá)
Jùë•ùëü ‚Üê ùëíùëü K(ùúé, ùúá) , (ùúé, bind(ùúá, ùëö ‚Ü¶‚Üí unit(ùëö[ùë•ùëü ‚Ü¶‚Üí Jùëíùëü K(ùúé, ùëö)])))
Jùë•ùëü

$‚Üê UùëÜ K(ùúé, ùúá) , (ùúé, bind(ùúá, ùëö ‚Ü¶‚Üí bind(UnifùëÜ, ùë£ ‚Ü¶‚Üí unit(ùëö[ùë•ùëü ‚Ü¶‚Üí ùë£]))))
Jùëê ; ùëê ‚Ä≤K(ùúé, ùúá) , Jùëê ‚Ä≤K(JùëêK(ùúé, ùúá))

Jif ùëè then ùëê else ùëê ‚Ä≤(ùúé, ùúá)K ,

Ô£±Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥
Jwhile ùëè do ùëêK(ùúé, ùúá) , lim
ùëõ‚Üí‚àû
Ô£≥

JùëêK(ùúé, ùúá)
Jùëê ‚Ä≤K(ùúé, ùúá)
(ùúé, ùúá1 ‚ó¶ùúå ùúá2)

if JùëèK(ùúé, ùúá) = ùõø (tt)
if JùëèK(ùúé, ùúá) = ùõø (Ô¨Ä )
otherwise, where (ùúé, ùúá1) = JùëêK(ùúé, ùúá | JùëèKùúé = tt),
ùúå = ùúá(JùëèKùúé = tt), and (ùúé, ùúá2) = Jùëê ‚Ä≤K(ùúé, ùúá | JùëèKùúé = Ô¨Ä ).

J(if ùëÖ ùëè then ùëê)ùëõ; if ùëÖ ùëè then abortK(ùúé, ùúá)

In the last case of the conditional, we write JùëèKùúé for the partial evaluation of ùëè on the determin-
istic memory and think of it as another expression. So ùúá | JùëèKùúé = tt and ùúá | JùëèKùúé = Ô¨Ä are both

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:39

conditional distribution. We assume that there is no update to the deterministic memory when
branching on randomized expressions, so the deterministic memory of both JùëêK(ùúé, ùúá | JùëèKùúé = tt)
and JùëêK(ùúé, ùúá | JùëèKùúé = Ô¨Ä ) remains to be ùúé.

In the semantics for the while loop, we can see abort as a command that programmers does
not have access to: for any ùúé, ùúá, JabortK(ùúé, ùúá) returns the zero sub-distribution. The limit, taken
with the point-wise order, exists because the sub-distribution‚Äôs mass monotonically increases as ùëõ
increases and is upper bounded by 1. In practice, because we assumed that all loops terminates in
Ô¨Ånite steps, the limit is always a full distribution, so all commands in pWhile can still be interpreted
as transformers from conÔ¨Ågurations to conÔ¨Ågurations.

D.2 The atomic propositions and axioms

, ‚äõ,‚àó

DeÔ¨Ånition D.4. For any operation ‚äô ‚àà {‚àß, ‚à®, ‚äõ, ‚àó}, we use the corresponding big-operation
,
n√ì

‚Ä¢ For any constant or logical variable ùëÅ ‚â• 1, let
√î

o

.

‚àà

√á

ùëÅ
ùëñ=0 ùëÉùëñ = ùëÉ0 abbreviate ((ùëÉ0‚äôùëÉ1)‚äô¬∑ ¬∑ ¬∑ )‚äôùëÉùëÅ ‚àí1.
ùëÅ
ùëñ=0 ùëÉùëñ ,
√á

‚äô ùëÉùëÅ ‚àí1 for ùëÅ > 1.

ùëÅ ‚àí1
ùëñ=0 ùëÉùëñ

Formally, let

ùëÅ
ùëñ=0 ùëÉùëñ = ùëÉ0 if ùëÅ = 1, and let

‚Ä¢ For a Ô¨Ånite multi- set of formula {ùëÉùëñ }ùëñ ‚ààùëÜ , let

ùë† ‚ààùëÜ ùëÉùë† abbreviate ((ùëÉùë†0 ‚äô ùëÉùë†1 ) ‚äô ¬∑ ¬∑ ¬∑ ) ‚äô ùëÉùë†ùëò ,
√á
where ùë†0, . . . , ùë†ùëò is an arbitrary ordering of ùëÜ. The satisfaction is not ambiguous since ‚äô is
associative and commutative.

(cid:16)√á

√á

√á

(cid:17)

ùë£
ùëñ=0 ùëÉùëñ to

√î

√á

√á

√á

ùëñ=0hùë¶ùëñ i.

be equivalent to

ùëÅ ‚ààVal (ùë£ ‚àº ùëÅ ‚àß

ùëÅ
ùëñ=0 ùëÉùëñ . Formally,

‚Ä¢ For any program variable ùë£ ‚àà DV ‚à™ RV, for any state (ùúé, ùúá) |= ùë£ ‚àº ùëÅ , we want
ùë£
ùëñ=0 ùëÉùëñ abbreviates

ùëÅ
ùëñ=0 ùëÉùëñ ).
√á
Theorem 5.3. Let ùëÜ be any subset of RV. A set of randomized program variables ùëå = {ùë¶ùëñ
| 0 ‚â§
ùëñ < ùêæ } satisÔ¨Åes NA in distribution ùúá ‚àà D (Mem[ùëÜ]) if and only if for any deterministic memory
ùúé ‚àà Mem[DV], we have (ùúé, ùúá) |= ‚äõùêæ
Proof. Forward direction: we Ô¨Åx ùúé ‚àà Mem[DV]. Let ùëåùëó = {ùë¶ùëñ
induction on ùëó that (ùúé, ùúãùëåùëó ùúá) |= ‚äõ ùëó+1
ùëñ=0 hùë¶ùëñ i.
If ùëó = 0: then ùë¶1 ‚àà dom(ùúá), and (ùúé, ùúã {ùë¶1 }ùúá) |= hùë¶1i.
If ùëó ‚â• 1: Assuming (ùúé, ùúãùëåùëó ‚àí1 ùúá) |= ‚äõ ùëó1
on {ùë¶ ùëó }, ùúá must be T1 ‚à™ T2-PNA. Thus, ùúãùëåùëó ùúá ‚àà ùúãùëåùëó ‚àí1 ùúá ‚äï ùúã {ùë¶ ùëó }ùúá. Since (ùúé, ùúãùëåùëó ‚àí1 ùúá) |= ‚äõ ùëó
(ùúé, ùúã {ùë¶ ùëó }ùúá) |= hùë¶ ùëó i, that implies (ùúé, ùúãùëåùëó ùúá) |= ‚äõ ùëó+1
Thus, (ùúé, ùúãùëåùëó ùúá) |= ‚äõ ùëó+1
(ùúé, ùúá) |= ‚äõùêæ
ùëñ=0hùë¶ùëñ i.

ùëñ=0hùë¶ùëñ i. Since ùëå satisÔ¨Åes NA in ùúá, by Theorem 4.7, ùúá is
T -PNA for any partition T of ùëå . In particular, for any partition T1 on ùëåùëó‚àí1 and any partition T2

ùëñ=0 hùë¶ùëñ i.
ùëñ=0 hùë¶ùëñ i. Take ùëó = ùêæ, we have (ùúé, ùúãùëå ùúá) |= ‚äõùêæ

| 0 ‚â§ ùëñ ‚â§ ùëó } we prove by

ùëñ=0hùë¶ùëñ i. By persistence,

ùëñ=0hùë¶ùëñ i and

Backward direction: for any ùê¥, ùêµ being disjoint subsets of ùëå , by commutativity and associativity

‚äõ ‚äõ ùë¶ùëñ ‚àà(ùëá \(ùê¥‚à™ùêµ)) hùë¶ùëñ i.
of ‚äõ, we can reorder formula and get (ùúé, ùúá) |=
By satisfaction rules and the deÔ¨Ånition of ‚äï, there exists ùúá‚Ä≤ ‚äë ùúá such that (ùúé, ùúá‚Ä≤) |= ‚äõ ùë¶ùëñ ‚ààùê¥ hùë¶ùëñ i ‚äõ
‚äõ ùë¶ùëñ ‚ààùêµ hùë¶ùëñ i. By satisfaction rules again, there exists ùúá1, ùúá2, ùúá‚Ä≤‚Ä≤ such that ùúá‚Ä≤ ‚äí ùúá‚Ä≤‚Ä≤ ‚àà ùúá1 ‚äï ùúá2, and
(ùúé, ùúá1) |= ‚äõ ùë¶ùëñ ‚ààùê¥ hùë¶ùëñ i, and (ùúé, ùúá2) |= ‚äõùë¶ùëñ ‚ààùêµ hùë¶ùëñ i. Note that ùúá1 is trivially {ùê¥}-PNA, and ùúá2 is

‚äõ ùë¶ùëñ ‚ààùê¥ hùë¶ùëñ i ‚äõ ‚äõ ùë¶ùëñ ‚ààùêµ hùë¶ùëñ i

(cid:16)

(cid:17)

trivially {ùêµ}-PNA. Thus, ùúá‚Ä≤‚Ä≤ satisÔ¨Åes {ùê¥, ùêµ}-PNA.

Therefore, ùúá satisÔ¨Åes (ùê¥, ùêµ)-NA for any ùê¥, ùêµ being disjoint subsets of ùëå , i.e., ùúá satisÔ¨Åes NA on
(cid:3)

ùëå .

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:40

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

Lemma 5.4. Let ùë•ùõæ be variables. The following axioms are valid in Xcomb.

|= OHùëÅ h[ùë•0, . . . , ùë•ùëÅ ‚àí1]i ‚Üí

ùëÅ‚äõ

ùõæ=0

hùë•ùõæ i

|= Permùê¥ h[ùë•0, . . . , ùë•ùëÅ ‚àí1]i ‚Üí

ùëÅ‚äõ

ùõæ=0

hùë•ùõæ i

(OH-PNA)

(Perm-PNA)

Proof. For any state (ùúé, ùúá) satisfying OHùëÅ h[ùë•1, . . . , ùë•ùëÅ ‚àí1]i, by Theorem 2.2, {ùë•1, . . . , ùë•ùëÅ } sat-
isÔ¨Åes NA in ùúá, and by Theorem 5.3, (ùúé, ùúá) |= ‚äõùëÅ
ùõæ=1hùë•ùõæ i. Similarly, by Theorem 2.2, {ùë•1, . . . , ùë•ùëÅ }
satisÔ¨Åes NA in ùúá, and by Theorem 5.3, (ùúé, ùúá) |= ‚äõùëÅ

ùõæ=1hùë•ùõæ i.

(cid:3)

Lemma D.5. Given a distribution ùúá with domain ùëÜ. Let S = {ùëÜ1, . . . , ùëÜùëÅ } be a partition of ùëÜ, {ùëìùëñ :
Mem[ùëÜùëñ ] ‚Üí Mem[ùëáùëñ ]}Sùëñ ‚ààS be a family of non-decreasing functions (or a family of non-increasing
functions), and T = {ùëá1, . . . ,ùëáùëÅ } be a partition of another set ùëá . Let

ùúá‚Ä≤ = bind

ùúá, ùëö ‚Ü¶‚Üí

unit(ùëìùëñ (pùëÜùëñùëö))

.

If ùúá satisÔ¨Åes S-PNA, then ùúá‚Ä≤ satisÔ¨Åes T -PNA.

(cid:16)

√äùëÜùëñ ‚ààS

(cid:17)

Proof. It suÔ¨Éces to show that for any R = {ùëÖ1, . . . , ùëÖùëö } that coarsens T , for any family of

non-negative non-increasing (or non-decreasing) functions {ùëîùëñ : Mem[ùëÖùëñ ] ‚Üí R+}ùëÖùëñ ‚ààR ,

Eùëö‚Ä≤‚àºùúá‚Ä≤

"

#

ùëîùëñ (pùëÖùëñ ùëö‚Ä≤)

‚â§

Eùëö‚Ä≤‚àºùúá‚Ä≤

ùëîùëñ (pùëÖùëñùëö‚Ä≤)

.

√ñùëñ

√ñùëñ
Our Ô¨Årst step is to show that if we can obtain a distribution on R by Ô¨Årst applying monotone
map and then coarsening, then we can also obtaining that by Ô¨Årst coarsening and then applying
monotone map: For any R that coarsens T = {ùëá1, . . . ,ùëáùëõ}, there exists some coarsening function
ùëî such that

(cid:2)

(cid:3)

R = {‚à™{ùëáùëó

| ùëó ‚àà ùëî(ùëñ)} | ùëñ ‚àà [ùëõ]}.

Let ùëÖùëñ = ‚à™{ùëáùëó
| ùëó ‚àà ùëî(ùëñ)}. Since ùëî is a coarsening function, for each ùëñ ‚àà [ùëõ], there exists exactly
one ùëòùëñ (i.e., the index for the component in the coarsened function) such that ùëî(ùëòùëñ ) ‚àã ùëñ. Then,
ùëáùëñ ‚äÜ ‚à™{ùëáùëó
Let ùëÖ‚Ä≤
ùëñ

ùëñ ] ‚Üí
Mem[ùëÖùëñ ] by having ‚Ñéùëñ (ùëö) =‚ä≤‚ä≥ ùëó ‚ààùëî (ùëñ) ùëìùëó (pùëÜ ùëó ùëö). Since each ùëìùëñ is monotone, then each ‚Ñéùëñ also mono-
tone in the point-wise order. Then,

| ùëñ ‚àà [ùëõ]}. Then R ‚Ä≤ coarsens S. DeÔ¨Åne ‚Ñéùëñ : Mem[ùëÖ‚Ä≤

| ùëó ‚àà ùëî(ùëòùëñ )} = ùëÖùëòùëñ .
= ‚à™{ùëÜ ùëó

| ùëó ‚àà ùëî(ùëñ)}, and R ‚Ä≤ = {ùëÖ‚Ä≤
ùëñ

ùúá‚Ä≤ = bind

ùúá, ùëö ‚Ü¶‚Üí

unit(ùëìùëñ (pùëÜùëñùëö))

= bind

ùúá, ùëö ‚Ü¶‚Üí

√äùëñ ‚àà[ùëõ ]
so ùúá‚Ä≤ is equivalent to applying ‚Ñéùëñ on each component of R ‚Ä≤.

(cid:17)

(cid:16)

(cid:16)

unit(‚Ñéùëñ (pùëÖ‚Ä≤

ùëñ

ùëö))

,

(cid:17)

√äùëÖ‚Ä≤
ùëñ ‚ààR‚Ä≤

Also, since ùúá is S-PNA and R ‚Ä≤ coarsens S, for any family of non-negative non-increasing (or

non-decreasing) functions {ùëîùëñ : Mem[ùëÖ‚Ä≤

ùëñ ] ‚Üí R+}ùëÖ‚Ä≤

ùëñ ‚ààR‚Ä≤,

Our second step is to show that this inequality is preserved under monotone maps.

Eùëö‚àºùúá

"

ùëîùëñ (pùëÖ‚Ä≤

ùëñ

ùëö)

‚â§

#

√ñùëñ

√ñùëñ

Eùëö‚àºùúáùëîùëñ (pùëÖ‚Ä≤

ùëñ

ùëö).

(8)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:41

‚Ä¢ If every ‚Ñéùëñ is non-increasing and {ùëîùëñ

: Mem[ùëÖùëñ ] ‚Üí R+}ùëÖùëñ ‚ààR are non-decreasing, is non-

increasing,

Eùëö‚Ä≤‚àºùúá‚Ä≤ [

ùëîùëñ (pùëÖùëñùëö‚Ä≤)]

√ñùëÖùëñ ‚ààR

√ïùëö‚Ä≤ ‚ààMem[ùëá ]

ùúá‚Ä≤(ùëö‚Ä≤) ¬∑

ùëîùëñ (pùëÖùëñùëö‚Ä≤)

√ñùëÖùëñ ‚ààR
ùúá(ùëö) ¬∑ (

√ïùëö‚Ä≤ ‚ààMem[ùëá ] √ïùëö ‚ààMem [ùëÜ ]

ùúá(ùëö) ¬∑

√ñùëÖ‚Ä≤
ùëñ ‚ààR‚Ä≤
ùëîùëñ (‚Ñéùëñ (pùëÖ‚Ä≤

ùëö))

ùëñ

=

=

=

√ïùëö ‚ààMem[ùëÜ ]

= Eùëö‚àºùúá [

√ñùëÖ‚Ä≤
ùëñ ‚ààR‚Ä≤

√ñùëÖ‚Ä≤
ùëñ ‚ààR‚Ä≤
ùëîùëñ (‚Ñéùëñ (pùëÖ‚Ä≤

ùëñ

ùëö))].

unit(‚Ñéùëñ (pùëÖ‚Ä≤

ùëñ

ùëö)) (pùëÖùëñùëö‚Ä≤)) ¬∑

ùëîùëñ (pùëÖùëñùëö‚Ä≤)

√ñùëÖùëñ ‚ààR

Note that ùëîùëñ ‚ó¶ ùëì is non-negative non-decreasing, then since ùúá satisÔ¨Åes Equation (8), we have

Eùëö‚àºùúá [

√ñùëÖ‚Ä≤
ùëñ ‚ààR‚Ä≤

ùëîùëñ (‚Ñéùëñ (pùëÖ‚Ä≤

ùëñ

ùëö))] ‚â§

√ñùëÖ‚Ä≤
ùëñ ‚ààR‚Ä≤

Eùëö‚àºùúá [ùëîùëñ (‚Ñéùëñ (pùëÖ‚Ä≤

ùëñ

ùëö))]

=

=

√ñùëÖ‚Ä≤
ùëñ ‚ààR‚Ä≤

ùúá(ùëö) ¬∑ ùëîùëñ (‚Ñéùëñ (pùëÖ‚Ä≤

ùëñ

ùëö))

√ïùëö ‚ààMem[ùëÜ ]
Eùëö‚Ä≤‚àºùúá‚Ä≤ùëîùëñ (pùëÖùëñùëö‚Ä≤).

Combined, we have Eùëö‚Ä≤‚àºùúá‚Ä≤ [

√ñùëÖùëñ ‚ààR
ùëñ ùëîùëñ (pùëÖùëñùëö‚Ä≤)] ‚â§

ùëñ Eùëö‚Ä≤‚àºùúá‚Ä≤ùëîùëñ (pùëÖùëñùëö‚Ä≤).

‚Ä¢ When ùëìùëñ is non-increasing and {ùëîùëñ } are non-negative non-decreasing, or when ùëìùëñ is non-
√é
decreasing and {ùëîùëñ } are non-negative non-decreasing/non-increasing, the proof is analo-
gous.

√é

(cid:3)

Lemma 5.5 (Monotone map). Let ùë•, ùë•ùõæ,ùõº and ùë¶ùõæ be variables. The following is valid in Xcomb.

ùëÅ‚äõ

ùõæ=0

|=

ùêæùõæ +1

ùëÅ

hùë•ùõæ,ùõº i

‚àß

ùë¶ùõæ = ùëìùõæ

ùë•ùõæ,0, . . . , ùë•ùõæ,ùêæùõæ
(cid:16)

ùëÅ‚äõ

ùõæ=0

‚Üí

hùë¶ùõæ i

(cid:17)

√õùõº =0

¬©

¬´

√õùõæ=0

¬™
¬Æ
¬¨
ùêæùõæ +1
ùõº =0 {ùë•ùõæ,ùõº } | 1 ‚â§ ùõæ < ùëÄ} as ùëãùëÄ .

when ùëì1, . . . , ùëìùëÅ all monotone or all antitone

(Mono-Map)

Proof. Abbreviate {

√ê

ùëÄ ‚â§ ùëÅ ,

ùêæùõæ +1
ùõº =0 hùë•ùõæ,ùõº i), we show by induction on ùëÄ that: for 1 ‚â§

For any state (ùúé, ùúá) satisfying ‚äõùëÅ
ùõæ=0(
‚Ä¢ (ùúé, ùúá) |= ‚äõùëÄ
ùêæùõæ
ùõæ=0 (
ùõº =0hùë•ùõæ,ùõº i);
‚Ä¢ And ùúá satisÔ¨Åes ùëãùëÄ -PNA implies ùúá satisÔ¨Åes ùëãùëÅ -PNA.
Assuming that it is true for ùëÄ, we show that for ùëÄ‚àí1. By assumption, (ùúé, ùúá) |= ‚äõùëÄ
ùõæ=0(
so there exists ùúá‚Ä≤, ùúá1, ùúá2 such that ùúá ‚äí ùúá‚Ä≤ ‚àà ùúá1 ‚äï ùúá2, (ùúé, ùúá1) |= ‚äõùëÄ‚àí1
ùêæùõæ +1
ùõº =0 hùë•ùõæ,ùõº i) and (ùúé, ùúá2) |=
ùõæ=0 (
√ì
ùêæùëÄ +1
ùõº =0 hùë•ùëÄ,ùõº i. Thus, ùúá‚Ä≤ is ùëãùëÄ -PNA if ùúá1 is ùëãùëÄ‚àí1-PNA and ùúá2 is ‚à™ùêæùëÄ +1
ùõº =0 {ùë•ùëÄ,ùõº }-PNA. Thus,

√ì

√ì

ùêæùõæ +1
ùõº =0 hùë•ùõæ,ùõº i),

√ì

√ì

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

 
57:42

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

‚Ä¢ By the deÔ¨Ånition of ‚äï, we have ùúá ‚äí ùúá1, and by persistence (ùúé, ùúá) |= ‚äõùëÄ‚àí1
ùõæ=0 (
‚Ä¢ Since (ùúé, ùúá1) |= ‚äõùëÄ‚àí1
ùêæùõæ +1
ùõº =0 hùë•ùõæ,ùõº i), we have ‚à™ùëãùëÄ‚àí1 is inside dom(ùúé) ‚à™ dom(ùúá1). Thus,
ùõæ=0 (
√ì
if ùúá satisÔ¨Åes ùëãùëÄ‚àí1-PNA, then ùúá1 ‚äë ùúá satisÔ¨Åes ùëãùëÄ‚àí1-PNA. Trivially, ùúá2 is ‚à™ùêæùëÄ
ùõº =0{ùë•ùëÄ,ùõº }-PNA.
Thus, ùúá‚Ä≤ is ùëãùëÄ -PNA, and ùúá is ùëãùëÄ -PNA. By inductive assumption, ùúá is ùëãùëÅ -PNA.

ùêæùõæ +1
ùõº =0 hùë•ùõæ,ùõº i);

√ì

Then, letting ùëÄ = 1 would give us: ùúá satisÔ¨Åes ùëã1-PNA implies ùúá satisÔ¨Åes ùëãùëÅ -PNA. ùëã1 is a partition
of one component, so ùúá satisfying ùëã1-PNA is trivial. Therefore, ùúá satisÔ¨Åes ùëãùëÅ -PNA.

Since

ùëÅ
ùõæ=0 ùë¶ùõæ = ùëìùõæ (ùë•ùõæ,1, . . . , ùë•ùõæ,ùêæùõæ ) and ùëìùõæ are all antitone or monotone, by Lemma D.5, ùúá satisÔ¨Åes

{{ùë¶ùõæ } | 1 ‚â§ ùõæ < ùëÅ }-PNA. Then we can show (ùúé, ùúá) |= ‚äõùëÅ

ùõæ=1hùë¶ùõæ i through another simple induc-
tion or by applying the existing theorems. If we do that by applying the theorems, Theorem 4.7
implies that if ùúá satisÔ¨Åes {{ùë¶ùõæ } | 1 ‚â§ ùõæ ‚â§ ùëÅ }-PNA, then {{ùë¶ùõæ } | 1 ‚â§ ùõæ ‚â§ ùëÅ } satisÔ¨Åes NA in ùúá.
Then, by Theorem 5.3, (ùúé, ùúá) |= ‚äõùëÅ
(cid:3)

√ì

ùõæ=1hùë¶ùõæ i.

D.3 The restriction property
We prove the restriction on deterministic memories and on randomized memories by separate
induction, and then combine them.

Lemma D.6 (Restriction on deterministic memories). Let (ùúé, ùúá) be any conÔ¨Åguration in Config,

and let ùúô be a ùëÄ-BIrestricted formula interpreted on Xcomb, Then, for any ùëö ‚àà Mem[DV \ FV(ùúô)],
(ùúé, ùúá) |= ùúô ‚áê‚áí (pFV(ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá) |= ùúô .

Proof. Note that the two directions are symmetric, so we only prove the forward direction.
We prove it by induction on the syntax of formula. Most cases are straightforward, so we only

show three cases.

ùúô = ùëÉ ‚Üí ùëÑ: Assuming (ùúé, ùúá) |= ùëÉ ‚Üí ùëÑ, that says for any (ùúé ‚Ä≤, ùúá‚Ä≤) ‚äí (ùúé, ùúá), if (ùúé ‚Ä≤, ùúá‚Ä≤) |= ùëÉ, then

(ùúé ‚Ä≤, ùúá‚Ä≤) |= ùëÑ.
ùúá) ‚äí (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá), it must
For any (
ùúé,
ùúé = pFV(ùúô )ùúé ‚ä≤‚ä≥ ùëö and the inductive hypothesis, (ùúé,
(ùúé,
Thus, (pFV(ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá) |= ùëÉ ‚Üí ùëÑ.
b

ùúá) |= ùëÉ implies (ùúé,
b

b

ùúá) |= ùëÑ; and by inductive hypothesis again, (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö,
b

b

b

b

b

ùúé = pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö and

ùúá ‚äí ùúá. If (
ùúá) |= ùëÉ; since (ùúé, ùúá) |= ùëÉ ‚Üí ùëÑ and

ùúé,

ùúá) |= ùëÉ, then by
ùúá ‚äí ùúá,
ùëöùë¢) |= ùëÑ,
b

b

|= ùëÉ ‚äõ ùëÑ, then there exists (

ùúô = ùëÉ ‚äõ ùëÑ: Assuming (ùúé, ùúá)
ùúé,

ùúá), (ùúé1, ùúá1), (ùúé2, ùúé2) such that
ùúá) ‚àà (ùúé1, ùúá1) ‚äï (ùúé2, ùúá2), (ùúé1, ùúá1) |= ùëÉ, and (ùúé2, ùúá2) |= ùëÑ. By the deÔ¨Ånition of

b
(ùúé, ùúá) ‚äí (
the pre-order and ‚äï, it must ùúé =
By inductive hypothesis, (pFV (ùúô )ùúé1 ‚ä≤‚ä≥ ùëö, ùúá1) = (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá1) |= ùëÉ, and (pFV (ùúô )ùúé2 ‚ä≤‚ä≥
ùëö, ùúá2) = (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá2) |= ùëÑ. Also,
(pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá) ‚äí (pFV(ùúô )ùúé ‚ä≤‚ä≥ ùëö,

ùúá) ‚àà (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá1) ‚äï (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá2).

ùúé = ùúé1 = ùúé2, ùúá ‚äí

ùúá ‚àà ùúá1 ‚äï ùúá2.
b

c

ùúé,

b

b

b

b

b

So (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá) |= ùëÉ ‚äõ ùëÑ.

ùúô = ùëÉ ‚àó ùëÑ Analogous as the case for ùëÉ ‚äõ ùëÑ.
ùúô = ùëÉ ‚àí‚àó ùëÑ: Assuming (ùúé, ùúá)

b

|= ùëÉ ‚àí‚àó ùëÑ, that says for any (ùúé ‚Ä≤‚Ä≤, ùúá‚Ä≤‚Ä≤) ‚àà (ùúé, ùúá) ‚äó (ùúé ‚Ä≤, ùúá‚Ä≤), if

(ùúé ‚Ä≤, ùúá‚Ä≤) |= ùëÉ, then (ùúé ‚Ä≤‚Ä≤, ùúá‚Ä≤‚Ä≤) |= ùëÑ.
For any (ùúé ‚Ä≤‚Ä≤, ùúá‚Ä≤‚Ä≤) ‚àà (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá) ‚äó (ùúé ‚Ä≤, ùúá‚Ä≤), it must ùúé ‚Ä≤‚Ä≤ = ùúé ‚Ä≤ = pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá‚Ä≤‚Ä≤ ‚àà ùúá ‚äó ùúá‚Ä≤.
Thus, (ùúé ‚Ä≤, ùúá‚Ä≤) |= ùëÉ is equivalent to (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá‚Ä≤) |= ùëÉ, and by inductive hypothesis, that
is equivalent to (ùúé, ùúá‚Ä≤) |= ùëÉ. It also follows that (ùúé, ùúá‚Ä≤‚Ä≤) ‚àà (ùúé, ùúá) ‚äó(ùúé, ùúá‚Ä≤). Since (ùúé, ùúá) |= ùëÉ ‚àí‚àó ùëÑ
and (ùúé, ùúá‚Ä≤) |= ùëÉ, we have (ùúé, ùúá‚Ä≤‚Ä≤) |= ùëÑ. By inductive hypothesis, (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá‚Ä≤‚Ä≤) |= ùëÑ, and
equivalently (ùúé ‚Ä≤‚Ä≤, ùúá‚Ä≤‚Ä≤) |= ùëÑ.
Thus, (pFV(ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúá) |= ùëÉ ‚àí‚àó ùëÑ.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:43

(cid:3)

Lemma D.7 (Restriction on randomized memories). Let (ùúé, ùúá) be any conÔ¨Åguration in Config,

and let ùúô be a ùëÄ-BIrestricted formula interpreted on Xcomb, Then,

(ùúé, ùúá) |= ùúô ‚áê‚áí (ùúé, ùúãFV(ùúô ) ùúá) |= ùúô .

Proof. The reverse direction follows by the Kripke monotonicity, and the forward direction
follows by induction on ùúô. The proof for most of the inductive cases is very similar to the proof
that the probabilistic model in Barthe et al. [2020] satisÔ¨Åes restriction. The new inductive case is:
‚Ä¢ ùúô ‚â° ùëÉ ‚äõ ùëÑ. Then, ùúá |= ùúô iÔ¨Ä there exists ùúá‚Ä≤, ùúá1, ùúá2 s.t. ùúá ‚äí ùúá‚Ä≤ ‚àà ùúá1 ‚äï ùúá2, ùúá1 |= ùëÉ and ùúá2 |= ùëÑ.
By induction, ùúãùêπùëâ (ùëÉ ) ùúá1 |= ùëÉ and ùúãùêπùëâ (ùëÑ) ùúá2 |= ùëÑ. Note that ùúãùêπùëâ (ùëÉ ) ùúá1 ‚äë ùúá1 and ùúãùêπùëâ (ùëÑ) ùúá2 ‚äë ùúá2.
By Down-closure, there exists ùúá‚Ä≤‚Ä≤ ‚äë ùúá‚Ä≤ such that ùúá‚Ä≤‚Ä≤ ‚àà ùúãùêπùëâ (ùëÉ ) ùúá1 ‚äï ùúãùêπùëâ (ùëÑ) ùúá2. This ùúá‚Ä≤‚Ä≤ satisÔ¨Åes
ùëÉ ‚äõ ùëÑ. By deÔ¨Ånition of ‚äï in the PNA model,

ùëëùëúùëö(ùúá‚Ä≤‚Ä≤) = ùëëùëúùëö(ùúãùêπùëâ (ùëÉ ) ùúá1) ‚à™ ùëëùëúùëö(ùúãùêπùëâ (ùëÑ) ùúá2) = ùêπùëâ (ùëÉ) ‚à™ ùêπùëâ (ùëÑ) = ùêπùëâ (ùëÉ ‚äõ ùëÑ).

Also, by the deÔ¨Ånition of the pre-order, ùúá‚Ä≤‚Ä≤ ‚äë ùúá‚Ä≤ ‚äë ùúá implies that ùúá‚Ä≤‚Ä≤ = ùúãùëëùëúùëö (ùúá‚Ä≤‚Ä≤) ùúá = ùúãùêπùëâ (ùúô ) ùúá.
Thus, ùúãùêπùëâ (ùúô ) ùúá = ùúá‚Ä≤‚Ä≤ |= ùúô.

(cid:3)

Theorem 5.8 (Restriction). Let (ùúé, ùúá) be any conÔ¨Åguration, and let ùúô be an ùëÄ-BIrestricted formula

interpreted on Xcomb, Then, for any ùëö ‚àà Mem[DV \ FV(ùúô)],

(ùúé, ùúá) |= ùúô ‚áê‚áí (pFV(ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúãFV(ùúô ) ùúá) |= ùúô .

Proof. Based on Lemma D.6 and Lemma D.7,

(ùúé, ùúá) |= ùúô ‚áê‚áí (ùúé, ùúãùúô ùúá) |= ùúô ‚áê‚áí (pFV (ùúô )ùúé ‚ä≤‚ä≥ ùëö, ùúãFV (ùúô ) ùúá) |= ùúô .

(cid:3)

For the counterexample of the restriction property, we prove a lemma.

Lemma D.8. Let ùúé ‚àà Mem[DV] be ‚Äúempty‚Äù ‚Äì let every deterministic variable be undeÔ¨Åned, ùúá be
the uniform distribution over one hot vectors on ùê¥, ùêµ, and ùúô = (U{0,1} hùê∂i) ‚àí‚äõ (hùêµi ‚àó hùê∂i). Then,
(ùúé, ùúá) |= ùúô.

Proof. Fix any ùúáùê∂ such that (ùúé, ùúáùê∂ ) |= U{0,1} hùê∂i, which implies that ùúãùê∂ ùúáùê∂ (0) = 0.5 and ùúãùê∂ ùúáùê∂ (1) =

0.5. Fix ùúáùëí ‚àà ùúá ‚äï ùúáùê∂ .

Since ùêµ ‚àà dom(ùúá), ùúá is trivially {{ùêµ}}-PNA. Similarly, ùúáùê∂ is trivially {{ùê∂}}-PNA. Thus, ùúáùëí ‚àà
:

ùúá ‚äï ùúáùê∂ must be {{ùêµ}, {ùê∂}}-PNA. Then for any two both monotone or antitone functions ùëì
Mem[ùêµ] ‚Üí R+, ùëî : Mem[ùê∂] ‚Üí R+,

Eùëö‚àºùúáùëí [ùëì (pùêµùëö) ¬∑ ùëî(pùê∂ùëö)] ‚â§ Eùëö‚àºùúáùëí [ùëì (pùêµùëö)] ¬∑ Eùëö‚àºùúáùëí [ùëî(pùê∂ùëö)].

Similarly, ùúáùëí ‚àà ùúá ‚äï ùúáùê∂ must be {{ùê¥}, {ùê∂}}-PNA, and for any two both monotone or antitone
functions ùëì : Mem[ùê¥] ‚Üí R+, ùëî : Mem[ùê∂] ‚Üí R+,

Eùëö‚àºùúáùëí [ùëì (pùê¥ùëö) ¬∑ ùëî(pùê∂ùëö)] ‚â§ Eùëö‚àºùúáùëí [ùëì (pùê¥ùëö)] ¬∑ Eùëö‚àºùúáùëí [ùëî(pùê∂ùëö)].

(9)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:44

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

Suppose variables ùêµ and ùê∂ are not independent in ùúáùëí , then by Lemma A.1, there must exists
some both monotone or both antitone functions ùëì : Mem[ùêµ] ‚Üí R+, ùëî : Mem[ùê∂] ‚Üí R+ such that

Eùëö‚àºùúáùëí [ùëì (pùêµùëö) ¬∑ ùëî(pùê∂ùëö)] < Eùëö‚àºùúáùëí [ùëì (pùêµùëö)] ¬∑ Eùëö‚àºùúáùëí [ùëî(pùê∂ùëö)]
‚áê‚áí 0.5 ¬∑ ùëì (0) ¬∑ (ùëî(1) ¬∑ ùëÉ (ùê∂ = 1 | ùêµ = 0) + ùëî(0) ¬∑ ùëÉ (ùê∂ = 0 | ùêµ = 0))
+ 0.5 ¬∑ ùëì (1) ¬∑ (ùëî(1) ¬∑ ùëÉ (ùê∂ = 1 | ùêµ = 1) + ùëî(0) ¬∑ ùëÉ (ùê∂ = 0, ùêµ = 1))

<(0.5 ¬∑ ùëì (0) + 0.5 ¬∑ ùëì (1)) ¬∑ (0.5 ¬∑ ùëî(1) + 0.5 ¬∑ ùëî(0)),

where ùëÉ (. . . ) denotes the respective probability that in ùúáùëí . Since ùúáùëí ‚àà ùúá ‚äï ùúáùê∂ , we have ùúáùëí ‚äí ùúá, and
ùúá being a uniform distribution over one-hot vectors on ùê¥, ùêµ indicates that for any ùëö in the support
of ùúáùëí , ùê¥ = 1 iÔ¨Ä ùêµ = 0, and ùê¥ = 0 iÔ¨Ä ùêµ = 1. Therefore, ùëÉ (ùê∂ = ùë£ | ùêµ = 0) = ùëÉ (ùê∂ = ùë£ | ùê¥ = 1) and
ùëÉ (ùê∂ = ùë£ | ùêµ = 1) = ùëÉ (ùê∂ = ùë£ | ùê¥ = 0). Also, by Bayes theorem, we have

ùëÉ (ùê∂ = ùë£ | ùê¥ = 0) ¬∑ ùëÉ (ùê¥ = 0) + ùëÉ (ùê∂ = ùë£ | ùê¥ = 1) ¬∑ ùëÉ (ùê¥ = 1) = ùëÉ (ùê∂ = ùë£)

=‚áí ùëÉ (ùê∂ = ùë£ | ùê¥ = 0) ¬∑ 0.5 + ùëÉ (ùê∂ = ùë£ | ùê¥ = 1) ¬∑ 0.5 = 0.5
‚áê‚áí ùëÉ (ùê∂ = ùë£ | ùê¥ = 0) = 1 ‚àí ùëÉ (ùê∂ = ùë£ | ùê¥ = 1).

Let ùëã = ùëÉ (ùê∂ = 1 | ùê¥ = 1), ùëå = ùëÉ (ùê∂ = 0 | ùê¥ = 1), then we have

0.5 ¬∑ ùëì (0) ¬∑ (ùëî(1) ¬∑ ùëã + ùëî(0) ¬∑ ùëå ) + 0.5 ¬∑ ùëì (1) ¬∑ (ùëî(1) ¬∑ (1 ‚àí ùëã ) + ùëî(0) ¬∑ (1 ‚àí ùëå ))

<(0.5 ¬∑ ùëì (0) + 0.5 ¬∑ ùëì (1)) ¬∑ (0.5 ¬∑ ùëî(1) + 0.5 ¬∑ ùëî(0))

‚áê‚áí ùëì (0) ¬∑ ùëî(1) ¬∑ (ùëã ‚àí 0.5) + ùëì (0) ¬∑ ùëî(0) ¬∑ (ùëå ‚àí 0.5) + ùëì (1) ¬∑ ùëî(1) ¬∑ (0.5 ‚àí ùëã ) + ùëì (1) ¬∑ ùëî(0) ¬∑ (0.5 ‚àí ùëå ) < 0
‚áê‚áí (ùëì (0) ‚àí ùëì (1)) ¬∑ ùëî(1) ¬∑ (ùëã ‚àí 0.5) + (ùëì (0) ‚àí ùëì (1)) ¬∑ ùëî(0) ¬∑ (ùëå ‚àí 0.5) < 0
‚áê‚áí 0.5 ¬∑ ùëì (1) ¬∑ (ùëî(1) ¬∑ ùëã + ùëî(0) ¬∑ ùëå ) + 0.5 ¬∑ ùëì (0) ¬∑ (ùëî(1) ¬∑ (1 ‚àí ùëã ) + ùëî(0) ¬∑ (1 ‚àí ùëå ))

<(0.5 ¬∑ ùëì (0) + 0.5 ¬∑ ùëì (1)) ¬∑ (0.5 ¬∑ ùëî(1) + 0.5 ¬∑ ùëî(0)).

Viewing ùëì as a function from Mem[ùê¥] to R+, this is equivalent to

Eùëö‚àºùúáùëí [ùëì (pùê¥ùëö) ¬∑ ùëî(pùê∂ùëö)] < Eùëö‚àºùúáùëí [ùëì (pùê¥ùëö)] ¬∑ Eùëö‚àºùúáùëí [ùëî(pùê∂ùëö)].

The last inequality contradicts Equation (9).

Therefore, ùêµ and ùê∂ must be independent in ùúáùëí . Hence, ùúáùëí |= hùêµi ‚àó hùê∂i, and ùúá |= ùúô.

(cid:3)

Theorem 5.9. There exists (ùúé, ùúá) ‚àà Config and formula ùúô such that (ùúé, ùúá) |= ùúô but (ùúé, ùúãFV(ùúô )) 6|= ùúô.

Proof. Let ùê¥, ùêµ, ùê∂ be three variables in RV. Let ùúô = (U{0,1} hùê∂i) ‚àí‚äõ (hùêµi ‚àó hùê∂i). Let ùúé be
a deterministic memory where every deterministic variable is undeÔ¨Åned, and ùúá be the uniform
distribution over one hot vectors on ùê¥, ùêµ. Then, we claim (ùúé, ùúá) |= ùúô but (ùúé, ùúã {ùêµ,ùê∂ }ùúá) 6|= ùúô. For
(ùúé, ùúá) |= ùúô, it suÔ¨Éces to show that for any ùúáùê∂ where ùê∂‚Äôs value is the uniform distribution on {0, 1},
for any ùúá‚Ä≤ ‚äí ùúá, and ùúáùëí ‚àà ùúá‚Ä≤ ‚äï ùúáùê∂ , ùêµ and ùê∂ are independent in ùúáùëí according to Lemma D.8. The
intuition is that ùúáùëí must satisÔ¨Åes {ùêµ, ùê∂}-PNA and {ùê¥, ùê∂}-PNA, and since ùê¥‚Äôs value is always the
opposite of ùêµ‚Äôs value, (ùêµ, ùê∂) has to satisfy pairwise independence in ùúáùëí . To show (ùúé, ùúã {ùêµ,ùê∂ }ùúá) 6|= ùúô,
we Ô¨Årst note that ùúã {ùêµ,ùê∂ }ùúá = ùúã {ùêµ }ùúá is a uniform distribution of 0 and 1 on ùêµ. Let ùúá‚Ä≤
ùê∂ ‚àà D (Mem[{ùê∂}])
be the uniform distribution on {0, 1}, ùúá‚Ä≤ ‚àà D (Mem[{ùêµ, ùê∂}]) be the uniform distribution over one-
6|= hùêµi ‚àó hùê∂i. Also, ùúá‚Ä≤ is in
hot vectors on ùêµ, ùê∂. Clearly, ùêµ, ùê∂ are not independent in ùúá‚Ä≤, so ùúá‚Ä≤
(cid:3)
ùúã {ùêµ,ùê∂ }ùúá ‚äï ùúá‚Ä≤

ùê∂ . So ùúãùêµ,ùê∂ ùúá 6|= U{0,1} hùê∂i ‚àí‚äõ (hùê¥i ‚àó hùê∂i).

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:45

D.4 The proof system of the program logic

The proof for the soundness of the frame rule relies on the following corollary of Lemma D.5.

Lemma D.9 (Monotone map closure PNA (specific case)). Let ùëÜ,ùëá ‚äÜ Var be two disjoint sets of
variables, and T is sub-partition of ùëá . Suppose that ùëì : Mem[ùëÜ] ‚Üí Mem[ùëÜ ‚Ä≤] is a monotonically non-
decreasing non-negative function, and ùëÜ ‚Ä≤ disjoint from ùëá . If ùúá with domain ùëÜ ‚à™ùëá satisÔ¨Åes {ùëÜ }‚à™T -PNA,
then bind(ùúá, ùëö ‚Ü¶‚Üí unit(ùëì (ùúãùëÜùëö)) ‚äï unit(ùúãùëáùëö)) ‚àà D (Mem[ùëÜ ‚Ä≤ ‚à™ ùëá ]) satisÔ¨Åes {ùëÜ ‚Ä≤} ‚à™ T -PNA.

Proof. We can reduce to Lemma D.5: Let ùëÜ1 = ùëÜ, ùëá1 = ùëÜ ‚Ä≤, and {ùëÜ2, . . . , ùëÜùëõ} = {ùëá2, . . . ,ùëáùëõ} = T .
Let ùëì1 = ùëì and the rest of ùëìùëñ to be the identity map. Note that we have assumed to only work
with non-negative values, so identity maps are also monotonically non-decreasing non-negative
(cid:3)
function.

Theorem 5.11. (Soundness of LINA) If ‚ä¢ {ùúô } ùëê {ùúì } is derivable, then it is valid: |= {ùúô } ùëê {ùúì }.

Proof. We only prove the cases not already in Barthe et al. [2020].
Rule: Cond. For any conÔ¨Åguration (ùúé, ùúá)

|= ùúô, by side-condition that |= ùúô ‚Üí Detmhùëèi,
(ùúé, ùúá) |= Detmhùëèi. Thus, JùëèK(ùúé, ùúá) must be a Dirac distribution. Since the commands are
well-typed, JùëèK(ùúé, ùúá) is a distribution over booleans. So JùëèK(ùúé, ùúá) is either a Dirac distribu-
tion of truthful value tt or a Dirac distribution of false value Ô¨Ä .
If JùëèK(ùúé, ùúá) is a Dirac distribution of truthful value tt, then for any ùëö in the support of ùúá,
JùëèK(ùúé, ùëö) = tt, and thus, (ùúé, ùúá) |= ùúô ‚àß ùëè ‚àº tt. By the side-condition ‚ä¢ {ùúô ‚àß ùëè ‚àº tt} ùëê {ùúì } and
inductive hypothesis that this judgement is sound, JùëêK(ùúé, ùúá) |= ùúì . When JùëèK(ùúé, ùúá) = ùõø (tt),
the semantics say that Jif ùëè then ùëê else ùëê ‚Ä≤K(ùúé, ùúá) = JùëêK(ùúé, ùúá) |= ùúì .
Symmetrically, when JùëèK(ùúé, ùúá) = ùõø (Ô¨Ä ), Jif ùëè then ùëê else ùëê ‚Ä≤K(ùúé, ùúá) = Jùëê ‚Ä≤K(ùúé, ùúá) |= ùúì .

Rule: Loop. For any (ùúé, ùúá) |= ùúô, the side condition implies (ùúé, ùúá) |= Detmhùëèi. We show by
induction that for any ùëõ, J(if ùëÖ ùëè then ùëê)ùëõK(ùúé, ùúá) |= ùúô ‚àßDetmhùëèi, and J(if ùëÖ ùëè then ùëê)ùëõK(ùúé, ùúá) |=
ùúô ‚àß ùëè ‚àº Ô¨Ä implies J(if ùëÖ ùëè then ùëê)ùëõ+1K(ùúé, ùúá) |= ùúô ‚àß ùëè ‚àº Ô¨Ä .
Say (ùúé ‚Ä≤, ùúá‚Ä≤) = J(if ùëÖ ùëè then ùëê)ùëõK(ùúé, ùúá). Assuming (ùúé ‚Ä≤, ùúá‚Ä≤) |= ùúô ‚àß Detmhùëèi, there are two
possibilities:
‚Ä¢ (ùúé ‚Ä≤, ùúá‚Ä≤) |= ùúô ‚àß ùëè ‚àº Ô¨Ä , then

J(if ùëÖ ùëè then ùëê)ùëõ+1K(ùúé, ùúá) = Jif ùëÖ ùëè then ùëêK(ùúé ‚Ä≤, ùúá‚Ä≤) = (ùúé ‚Ä≤, ùúá‚Ä≤) |= ùúô ‚àß ùëè ‚àº Ô¨Ä .

‚Ä¢ (ùúé ‚Ä≤, ùúá‚Ä≤) |= ùúô ‚àß ùëè ‚àº tt, then

J(if ùëÖ ùëè then ùëê)ùëõ+1K(ùúé, ùúá) = Jif ùëÖ ùëè then ùëêK(ùúé ‚Ä≤, ùúá‚Ä≤) = JùëêK(ùúé ‚Ä≤, ùúá‚Ä≤) |= ùúô,

where the last satisfaction is guaranteed by ‚ä¢ {ùúô ‚àß ùëè ‚àº tt} ùëê {ùúô }. Since |= ùúô ‚Üí Detmhùëèi,
so Jif ùëÖ ùëè then ùëêK(ùúé ‚Ä≤, ùúá‚Ä≤) |= ùúô ‚àß Detmhùëèi.

Since we assumed that the loop ends in Ô¨Ånite step, there exists a Ô¨Ånite number ùëÅ such that
J(if ùëÖ ùëè then ùëê)ùëÅ K(ùúé, ùúá) |= ùúô ‚àßùëè ‚àº Ô¨Ä and also J(if ùëÖ ùëè then ùëê)ùëÅ ‚àí1K(ùúé, ùúá) |= ùúô ‚àßùëè ‚àº tt if ùëÅ > 1.
Then Jwhile ùëè do ùëêK(ùúé, ùúá) = J(if ùëÖ ùëè then ùëê)ùëÅ K(ùúé, ùúá) |= ùúô ‚àß ùëè ‚àº Ô¨Ä .

Rule: RCase. For any (ùúé, ùúá) |= ùúô ‚àó ùúÇ, there exists ùúá‚Ä≤, ùúá1, ùúá2 such that ùúá ‚äí ùúá‚Ä≤ ‚àà ùúá1 ‚äï ùúá2 and

(ùúé, ùúá1) |= ùúô, (ùúé, ùúá2) |= ùúÇ.
Say ùúá2 is in D (Mem[ùëá ]), then for any ùëö in the support of ùúá2, the conditional distribution
ùúá2 | ùëá = ùëö is a Dirac distribution of ùëö, i.e., ùõø (ùëö). Since ùúÇ ‚àà CC (closed under conditioning), so
ùõº ‚ààùëÜ ùúÇùõº . Then, there exists ùõº such that (ùúé, ùõø (ùëö)) |= ùúÇùõº .
(ùúé, ùõø (ùëö)) |= ùúÇ, and thus (ùúé, ùõø (ùëö)) |=
Since dom(ùúá1) and dom(ùúá2) are independent in ùúá‚Ä≤, the conditional distribution ùúá‚Ä≤ | ùëá = ùëö
is in ùúá1 ‚äï ùõø (ùëö). So ùúá‚Ä≤
| ùëá = ùëö |= ùúô ‚àó ùúÇùõº . By the side-condition ‚ä¢ ùúô ‚àó ùúÇùõº and inductive
hypothesis that it is sound, we have JùëêK(ùúé, ùúá‚Ä≤ | ùëá = ùëö) |= ùúì .

√î

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:46

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

For any command ùëê, any condition ùëè, let (ùúéùëè, ùúáùëè) = JùëêK(ùúé, ùúá‚Ä≤ | ùëè) and (ùúéùëè, ùúá¬¨ùëè ) = JùëêK(ùúé, ùúá‚Ä≤ |
¬¨ùëè). We can show by induction on the semantics of commands that JùëêK(ùúé, ùúá‚Ä≤) is a convex
| ùëè) ‚ó¶ùúá‚Ä≤ (ùëè=tt) (ùúá‚Ä≤
combination of (ùúé, ùúá‚Ä≤
| ¬¨ùëè)).
Thus, JùëêK(ùúé, ùúá‚Ä≤) is a convex combination of all JùëêK(ùúé, ùúá‚Ä≤
| ùëá = ùëö), where ùëö in the sup-
port of ùúá‚Ä≤. Since each of JùëêK(ùúé, ùúá‚Ä≤
| ùëá = ùëö) satisÔ¨Åes ùúì and ùúì is closed under mixture, we
have JùëêK(ùúé, ùúá‚Ä≤) |= ùúì . We can also show by induction on the semantics of commands that
JùëêK(ùúé, ùúá) ‚äí JùëêK(ùúé, ùúá‚Ä≤) if ùúá ‚äí ùúá‚Ä≤. So by persistence JùëêK(ùúé, ùúá) |= ùúì .

| ¬¨ùëè): JùëêK(ùúé, ùúá‚Ä≤) = (ùúé, (ùúá‚Ä≤

| ùëè) and (ùúé, ùúá‚Ä≤

Rule: ProbBound. For any program state (ùúé, ùúá) |= Pr[ùëíùë£1] ‚â• 1‚àíùúñ, let event ùëíùë£ùúé

1 : Mem[dom(ùúá)] ‚Üí

{0, 1} be the result of partially interpreting ùëíùë£1 on ùúé, i.e., ùëíùë£ùúé
1
the function ùúÜùë• .1 ‚àí ùëíùë£ùúé
1 . We also write Prùúá [ùëíùë£ùúé
1 (ùë•) as ¬¨ùëíùë£ùúé
1 ] for
ùëíùë£ùúé
We can express ùúá as the convex combination of two conditional distributions, i.e.,

= curry(Jùëíùë£1K) (ùúé), and denote
ùëö ‚ààD (Mem [dom(ùúá) ]) ùúá(ùëö) ¬∑

1 (ùëö).

√ç

ùúá = Pr
ùúá

[ùëíùë£ùúé

1 ] ¬∑ (ùúá | ùëíùë£ùúé

1 ) + Pr
ùúá

[¬¨ùëíùë£ùúé

1 ] ¬∑ (ùúá | ¬¨ùëíùë£ùúé

1 ).

1

) = JùëêK(ùúé, (ùúá | ùëíùë£ùúé

Let (ùúé ‚Ä≤, ùúáùëíùë£ùúé
variables in the deterministic memories, there exists probabilistic memories ùúá¬¨ùëíùë£ùúé
1
(ùúé ‚Ä≤, ùúá¬¨ùëíùë£ùúé
) = JùëêK(ùúé, (ùúá | ¬¨ùëíùë£ùúé
prove that JùëêK(ùúé, ùúá) = (ùúé ‚Ä≤, ùúáùëíùë£ùúé
By construction, Jùëíùë£1K(ùúé, (ùúá | ùëíùë£ùúé
inductive hypothesis, we have |= {ùëíùë£1} ùëê {Pr[ùëíùë£2] ‚â• 1 ‚àí ùõø }, which implies

1 )). Since assignments to deterministic memories can only use
such that
1 )). Then, by induction on the denotational semantics, we can

‚ó¶Prùúá [ùëíùë£ùúé
1 ] ùúá¬¨ùëíùë£ùúé
1 )) = 1, so (ùúé, (ùúá | ùëíùë£ùúé

1 )) |= ùëíùë£1. Also, by the assumption and

).

1

1

1

JùëêK(ùúé, (ùúá | ùëíùë£ùúé

1 )) = (ùúé ‚Ä≤, ùúáùëíùë£ùúé

1

) |= Pr[ùëíùë£2] ‚â• 1 ‚àí ùõø.

By deÔ¨Ånition, that means Pr(ùúé‚Ä≤,ùúáùëíùë£ùúé

1

) [ùëíùë£2] ‚â• 1 ‚àí ùõø. Then, by the law of total probability,

(ùúé‚Ä≤,ùúáùëíùë£ùúé
1

Pr
‚ó¶Prùúá [ùëíùë£ùúé
1

] ùúá¬¨ùëíùë£)

[ùëíùë£ùúé

1 ] ‚â§

Pr
(ùúé‚Ä≤,ùúáùëíùë£ùúé
1
‚â§ ùõø + Pr
ùúé,ùúá

‚â§ ùõø + ùúñ

[ùëíùë£2] + Pr
ùúá

)

[¬¨ùëíùë£ùúé
1 ]

[¬¨ùëíùë£1]

(because Prùúá [¬¨ùëíùë£ùúé

1 ] = Prùúé,ùúá [¬¨ùëíùë£1])
(because (ùúé, ùúá) |= Pr[ùëíùë£1] ‚â• 1 ‚àí ùúñ,)

Therefore, JùëêK(ùúé, ùúá) |= Pr[ùëíùë£2] ‚â§ ùõø + ùúñ.

Rule: NegFrame. For any (ùúé, ùúá) |= ùëíùë£1 ‚àó ùúÇ, there exists ùëò1, ùëò2, ùúá‚Ä≤ such that ùúá ‚äí ùúá‚Ä≤ ‚àà ùëò1 ‚äï ùëò2,

and (ùúé, ùëò1) |= ùúô and (ùúé, ùëò2) |= ùúÇ.
Let ùëÜ1 , dom(ùëò1), and note that (ùúé, ùëò1) |= ùúô and |= ùúô ‚Üí hRV(ùëê)i implies (ùúé, ùëò1) |= hRV(ùëê)i,
and thus RV(ùëê) ‚à© RV ‚äÜ ùëÜ1. Let ùëÜ2 , dom(ùëò2) ‚à© FV(ùúÇ). Then, MV(ùëê) is disjoint from ùëÜ2
because ùëÜ2 ‚äÜ FV(ùúÇ) and FV(ùúÇ) ‚à© MV(ùëê) = ‚àÖ; also, by restriction, (ùúé, ùúãùëÜ2ùëò2) |= ùúÇ.
Since ùëò1 ‚äï ùëò2 is non-empty, ùëëùëúùëö(ùëò1), ùëëùëúùëö(ùëò2) are disjoint; since ùëÜ1 = ùëëùëúùëö(ùëò1), ùëÜ2 ‚äÜ ùëëùëúùëö(ùëò2),
ùëÜ1, ùëÜ2 are disjoint.
Let (ùúéùëí, ùúáùëí ) = JùëêK(ùúé, ùúá). Denote RV(ùëê) ‚à© DV as ùëÖ1, MV(ùê∂) ‚à© DV as ùëÄ1, RV(ùëê) ‚à© RV as
ùëÖ2, MV(ùê∂) ‚à© RV as ùëÄ2. By the soundness of RV, WV, and MV, there exists ùê∫ : Mem[ùëÖ1] ‚Üí
Mem[ùëÄ1], ùêπ : Mem[RV(ùëê)] ‚Üí D (Mem[ùëÄ2]) such that:
ùúéùëí = ùê∫ (pùëÖ1ùúé) ‚ä≤‚ä≥ pD V\ùëÄ1ùúé
ùúáùëí = bind(ùúá, ùëö ‚Ü¶‚Üí ùêπ (pùëÖ1ùúé ‚ä≤‚ä≥ pùëÖ2ùëö) ‚äó unit(pdom(ùúá)\ùëÄ2ùëö)).

Since ùëÖ2 ‚äÜ ùëÜ1, and ùëÜ2 is disjoint of ùëÜ1 and MV(ùëê), we have

ùúãùëÄ2‚à™ùëÜ1‚à™ùëÜ2 ùúáùëí = bind(ùúãùëÜ1‚à™ùëÜ2 ùúá, (ùëö1, ùëö2) ‚Ü¶‚Üí ùêπ (pùëÖ1ùúé ‚ä≤‚ä≥ pùëÖ2ùëö1) ‚äó unit(pùëÜ1\ùëÄ2ùëö1) ‚äó unit(ùëö2)).

(10)
One implication is that (ùúéùëí, ùúãùëÜ2 ùúáùëí ) |= ùúÇ: Equation (10) implies that ùúãùëÜ2 ùúáùëí = ùúãùëÜ2 ùúá. We (ùúé, ùúãùëÜ2 ùúá) |=
ùúÇ, so (ùúé, ùúãùëÜ2 ùúáùëí ) |= ùúÇ. By restriction, for any ùëö ‚àà Mem[DV \ FV(ùúÇ)], (pFV (ùúÇ)ùúé ‚ä≤‚ä≥ ùëö, ùúãùëÜ2 ùúáùëí ) |=

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:47

ùúÇ. Since ùúéùëí = ùê∫ (pùëÖ1ùúé) ‚ä≤‚ä≥ pD V\ùëÄ1ùúé, and FV(ùúÇ) ‚à© MV(ùëê) = ‚àÖ implies that FV(ùúÇ) ‚à© DV ‚äÜ
DV \ ùëÄ1, and (ùúéùëí, ùúãùëÜ2 ùúáùëí ) |= ùúÇ.
If ùë¶ ‚àà DV, then Jùë¶K(ùúéùëí, ùëöùêπ ‚ä≤‚ä≥ pùëã ‚à©R Vùëö) = ùúéùëí (ùë¶). Thus, (ùúéùëí, ùë°) |= hùë¶i where ùë° is the trivial
distribution in D (Mem[‚àÖ]). Also, (ùúéùëí, ùúáùëí ) ‚àà (ùúéùëí, ùë°) ‚ó¶ (ùúéùëí, ùúáùëí ), where (ùúéùëí, ùúáùëí ) ‚äí (ùúéùëí, ùúãùëÜ2 ùúáùëí ) |=
ùúÇ. So (ùúéùëí, ùúáùëí ) |= ùúÇ.
If ùë¶ ‚àâ MV(ùëê), then {ùë¶} ‚à™ ùëÜ2 ‚äÜ dom(ùúá) \ MV(ùëê), and thus ùúã {ùë¶ }‚à™ùëÜ2 ùúáùëí = ùúã {ùë¶ }‚à™ùëÜ2 ùúá.
‚Ä¢ Since ‚ä¢ {ùúô } ùëê {ùë¶ ‚àº ùëì (ùëã )}, by inductive assumption we have JùëêK(ùúé, ùëò1) |= ùë¶ ‚àº ùëì (ùëã ). Up-
dates to deterministic variables only depend on deterministic program state, so JùëêK(ùúé, ùëò1) =
(ùúéùëí, ùúáùëò ) for some ùúáùëò . And ùë¶ ‚àâ MV(ùëê) implies that ùúã {ùë¶ }ùúáùëò = ùúã {ùë¶ }ùúá = ùúã {ùë¶ }ùëò1. The restriction
property and JùëêK(ùúé, ùëò1) |= ùë¶ ‚àº ùëì (ùëã ) implies (ùúéùëí, ùúã {ùë¶ }ùëò1) = (ùúéùëí, ùúã {ùë¶ }ùúáùëò ) |= hùë¶i.

‚Ä¢ (ùúéùëí, ùúãùëÜ2 ùúá) |= ùúÇ.
‚Ä¢ ùúá ‚äí ùúá‚Ä≤ ‚àà ùëò1 ‚äï ùëò2, so ùúã {ùë¶ }‚à™ùëÜ2 ùúá ‚àà ùúã {ùë¶ }ùëò1 ‚äï ùúãùëÜ2ùëò2 too.
Therefore, (ùúéùëí, ùúã {ùë¶ }‚à™ùëÜ2 ùúá) |= hùë¶i ‚äõ ùúÇ. Since (ùúéùëí, ùúáùëí ) ‚äí (ùúéùëí, ùúã {ùë¶ }‚à™ùëÜ2 ùúáùëí ) = (ùúéùëí, ùúã {ùë¶ }‚à™ùëÜ2 ùúá), by
persistence, (ùúéùëí, ùúáùëí ) |= hùë¶i ‚äõ ùúÇ.
If ùë¶ ‚àà RV and ùë¶ ‚àà MV(ùëê), our overall strategy is to Ô¨Årst connect ùêπ with ùëì and show
the operation on variable ùë¶ is a monotone map, and then apply monotone map closure to
establish the NA between ùë¶ and ùúÇ.
Since (ùúé, ùúãùëÜ1 ùúá) = (ùúé, ùëò1) |= ùúô, by persistence (ùúé, ùúá) |= ùúô. By side-condition that ‚ä¢ {ùúô }ùëê{ùë¶ ‚àº
ùëì (ùëã )} and by induction that the proof rules are sound, it must JùëêK(ùúé, ùúá) = (ùúéùëí, ùúáùëí ) |= ùë¶ ‚àº
ùëì (ùëã ). By restriction, (ùúéùëí, ùúãùëã ‚à™{ùë¶ }ùúáùëí ) |= ùë¶ ‚àº ùëì (ùëã ).
Since ùëã ‚à© RV ‚äÜ (RV(ùëê) ‚à© RV) \ MV(ùëê) ‚äÜ ùëÜ1 \ MV(ùëê) and ùë¶ ‚àà MV(ùëê),

ùúãùëã ‚à™{ùë¶ }ùúáùëí = ùúãùëã ‚à™{ùë¶ }ùúãùëÜ1‚à™MV(ùëê) JùëêKùúá

= ùúãùëã ‚à™{ùë¶ }bind(ùúãùëÜ1 ùúá, ùëö ‚Ü¶‚Üí ùêπ (pùëÖ1ùúé ‚ä≤‚ä≥ pùëÖ2ùëö) ‚äó unit(pùëÜ1\ùëÄ2ùëö))
= bind(ùúãùëÜ1 ùúá, ùëö ‚Ü¶‚Üí ùúã {ùë¶ }ùêπ (pùëÖ1ùúé ‚ä≤‚ä≥ pùëÖ2ùëö) ‚äó unit(pùëã ‚à©R Vùëö))
Since (ùúéùëí, ùúãùëã ‚à™{ùë¶ }ùúáùëí ) |= ùë¶ ‚àº ùëì (ùëã ), for every ùëöùëí in the support of ùúãùëã ‚à™{ùë¶ }ùúáùëí , we have Jùë¶K(ùúéùëí, ùëöùëí) =
Jùëì (ùëã )K(ùúéùëí, ùëöùëí). By Equation (11), a memory ùëöùëí is in the support of ùúãùëã ‚à™{ùë¶ }ùúáùëí if and only if
there exists some ùëö, ùëöùêπ such that ùëö is in the support of ùúá, and ùëöùêπ is in the support of
ùúã {ùë¶ }ùêπ (pùëÖ1ùúé ‚ä≤‚ä≥ pùëÖ2ùëö), and ùëöùëí = ùëöùêπ ‚ä≤‚ä≥ pùëã ‚à©R Vùëö. Thus, the condition we have is: for every ùëö
is in the support of ùúá and ùëöùêπ is in the support of ùúã {ùë¶ }ùêπ (pùëÖ1ùúé ‚ä≤‚ä≥ pùëÖ2ùëö),
Jùë¶K(ùúéùëí, ùëöùêπ ‚ä≤‚ä≥ pùëã ‚à©R Vùëö) = Jùëì (ùëã )K(ùúéùëí, ùëöùêπ ‚ä≤‚ä≥ pùëã ‚à©R Vùëö).

(11)

Since ùëì does not depend on states and ùëã do not depend on ùëöùêπ , we also have that Jùëì (ùëã )K(ùúéùëí, ùëöùêπ ‚ä≤‚ä≥
pùëã ‚à©R Vùëö) = Jùëì (ùëã )K(ùúé, ùëö).
If ùë¶ ‚àà RV, then Jùë¶K(ùúéùëí, ùëöùêπ ‚ä≤‚ä≥ pùëã ‚à©R Vùëö) = ùëöùêπ (ùë¶), so it must ùëöùêπ (ùë¶) = Jùëì (ùëã )K(ùúé, ùëö). so
although ùêπ is a randomized function according to its type, for any ùëö in the support of ùúá,
ùúã {ùë¶ }ùêπ (pùëÖ1ùúé ‚ä≤‚ä≥ pùëÖ2ùëö) is a Dirac distribution:

ùúã {ùë¶ }ùêπ (pùëÖ1ùúé ‚ä≤‚ä≥ pùëÖ2ùëö) = ùõø (Jùëì (ùëã )K(ùúé, ùëö)).

Fixing ùúé, then there exists ùëì ‚Ä≤ such that Jùëì (ùëã )K(ùúé, ùëö) = ùëì ‚Ä≤(pùëã ‚à©R Vùëö) and ùëì ‚Ä≤ is monotone as
ùëì is monotone. Since ùëã ‚à© RV ‚äÜ ùëÜ1, we can also make ùëì ‚Ä≤ to have type Mem[ùëÜ1] ‚Üí Val.
Thus,

ùúã {ùë¶ }‚à™ùëÜ2 ùúáùëí = bind(ùúãùëÜ1‚à™ùëÜ2 ùúá, (ùëö1, ùëö2) ‚Ü¶‚Üí ùúãùë¶ùêπ (pùëÖ1ùúé ‚ä≤‚ä≥ pùëÖ2ùëö1) ‚äó unit(ùëö2))
= bind(ùúãùëÜ1‚à™ùëÜ2 ùúá, (ùëö1, ùëö2) ‚Ü¶‚Üí unit(Jùëì (ùëã )K(ùúé, ùëö1)) ‚äó unit(ùëö2))
= bind(ùúãùëÜ1‚à™ùëÜ2 ùúá, (ùëö1, ùëö2) ‚Ü¶‚Üí unit(ùëì ‚Ä≤(ùëö1)) ‚äó unit(ùëö2)).

Let ùúáùëê = ùúã {ùë¶ }‚à™ùëÜ2 (ùúáùëí ). We will then show that (ùúéùëí, ùúáùëê ) |= hùë¶i ‚àó ùúÇ.
Let ùëî1 = ùúãùë¶ (ùúáùëí ), ùëî2 = ùúãùëÜ2 ùúá, it suÔ¨Éces to show that ùúáùëê ‚àà ùëî1 ‚äï ùëî2. and ùëî1 |= hùë¶i, ùëî2 |= ùúÇ:

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:48

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

‚Ä¢ (ùúéùëí, ùúáùëí ) |= ùë¶ ‚àº ùëì (ùëã ), so (ùúéùëí, ùúáùëí ) |= hùë¶i. By restriction, (ùúéùëí, ùëî1) |= hùë¶i.
‚Ä¢ ùëî2 = ùúãùëÜ2 ùúá = ùúãùêπùëâ (ùúÇ)ùúãùëëùëúùëö (ùëò2) ùúá = ùúãùêπùëâ (ùúÇ)ùëò2, so (ùúé, ùëî2) |= ùúÇ. By Lemma D.6, for any ùëö ‚àà
Mem[DV \ FV(ùúÇ)], (pFV (ùúÇ)ùúé ‚ä≤‚ä≥ ùëö, ùëî2) |= ùúÇ. Since ùúéùëí = ùê∫ (pùëÖ1ùúé) ‚ä≤‚ä≥ pD V\ùëÄ1ùúé, and FV(ùúÇ) ‚à©
MV(ùëê) = ‚àÖ implies that FV(ùúÇ) ‚äÜ DV \ ùëÄ1, (ùúéùëí, ùëî2) |= ùúÇ.
‚Ä¢ First, ùúã {ùë¶ }ùúáùëê = ùúã {ùë¶ }ùúáùëí = ùëî1, and ùúãùëÜ2 ùúáùëê = ùúãùëÜ2 ùúáùëí = ùúãùëÜ2 ùúá = ùëî2.

Second, ùúãùëëùëúùëö (ùëò1)‚à™ùëëùëúùëö (ùëò2) ùúá ‚àà ùëò1 ‚äï ùëò2 implies that ùúãùëëùëúùëö (ùëò1)‚à™ùëëùëúùëö (ùëò2) ùúá is S‚Ä≤ ‚à™ T ‚Ä≤-PNA for any
S‚Ä≤, T ‚Ä≤ such that ùëò1 is S‚Ä≤-PNA, ùëò2 is T ‚Ä≤-PNA. Because ùúãùëÜ1 ùúá is always {ùëÜ1}-PNA, ùúãùëÜ1‚à™ùëÜ2 ùúá is
{ùëÜ1} ‚à™ T -PNA for any T such that ùëî2 is T -PNA. Recall that

ùúáùëê = bind(ùúãùëÜ1‚à™ùëÜ2 ùúá, (ùëö1, ùëö2) ‚Ü¶‚Üí unit(ùëì ‚Ä≤(ùëö1)) ‚äó unit(ùëö2)).

Thus, by the monotonicity map closure Lemma D.9, ùúáùëê is {ùë¶} ‚à™ T -PNA for any T such
that ùëî2 is T -PNA. Thus, ùúáùëê ‚àà ùëî1 ‚äï ùëî2, and therefore (ùúéùëí, ùúáùëê ) ‚àà (ùúéùëí, ùëî1) ‚äï (ùúéùëí, ùëî2).

Therefore, (ùúéùëí, ùúáùëê ) |= hùë¶i ‚àó ùúÇ.
By persistence, (ùúéùëí, ùúáùëí ) |= hùë¶i ‚àó ùúÇ.

(cid:3)

E COMPLETENESS OF ùëÄ-BI

E.1 ùëÄ-BI Algebras

DeÔ¨Ånition E.1 (BI Algebra). An BI algebra is an algebra A = (ùê¥, ‚àß, ‚à®, ‚Üí, ‚ä§, ‚ä•, ‚àó, ‚àí‚àó, ‚ä§‚àó) such that
‚Ä¢ (ùê¥, ‚àß, ‚à®, ‚Üí, ‚ä§, ‚ä•) is a Heyting algebra
‚Ä¢ (ùê¥, ‚àó, ‚ä§‚àó) is a commutative monoid
‚Ä¢ ùëé ‚àó ùëè ‚â§ ùëê if and only if ùëé ‚â§ ùëè ‚àí‚àó ùëê

where ‚â§ is the ordering associated with the Heyting algebra.

, ‚ä§‚àó

DeÔ¨Ånition E.2 (ùëÄ-BI Algebra). An ùëÄ-BI algebra is an algebra A = (ùê¥, ‚àß, ‚à®, ‚Üí, ‚ä§, ‚ä•, ‚àóùëö ‚ààùëÄ , ‚àí‚àóùëö ‚ààùëÄ
ùëö ‚ààùëÄ ) such that
‚Ä¢ For each ùëö ‚àà ùëÄ, the structure (ùê¥, ‚àß, ‚à®, ‚Üí, ‚ä§, ‚ä•, ‚àóùëö, ‚àí‚àóùëö, ‚ä§‚àó
‚Ä¢ If ùëö1 ‚â§ ùëö2 then ùëé ‚àóùëö1 ùëè ‚â§ ùëé ‚àóùëö2 ùëè

ùëö) is a BI-algebra

We can interpret ùëÄ-BI in an ùëÄ-BI algebra ùê¥. Let V : AP ‚Üí ùê¥ be a map assigning atomic
propositions to elements of ùê¥. We extend V to an interpretation J‚àíKV mapping propositions to
elements of ùê¥, deÔ¨Åned by:

JùëùK = V (ùëù)
J‚ä§K = ‚ä§
JùêºùëöK = ‚ä§‚àó
ùëö
J‚ä•K = ‚ä•

JùëÉ ‚àß ùëÑKV = JùëÉKV ‚àß JùëÑKV
JùëÉ ‚à® ùëÑKV = JùëÉKV ‚à® JùëÑKV
JùëÉ ‚Üí ùëÑKV = JùëÉKV ‚Üí JùëÑKV
JùëÉ ‚àóùëö ùëÑKV = JùëÉKV ‚àóùëö JùëÑKV
JùëÉ ‚àí‚àóùëö ùëÑKV = JùëÉKV ‚àí‚àóùëö JùëÑKV

Theorem E.3 (Algebraic Soundness). If ùëÉ ‚ä¢ ùëÑ is provable, then for all V, JùëÉKV ‚â§ JùëÑKV.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:49

Proof. By induction on the derivation of ùëÉ ‚ä¢ ùëÑ. The cases for everything except the Inclusion
rules show follow from the exact same argument as for standard BI and BI-algebra, as in Simon
Docherty‚Äôs thesis.

For the remaining case of ‚àó-inclusion, let ùëö1 ‚â§ ùëö2. Then we have

JùëÉ ‚àóùëö1 ùëÑKV = JùëÉKV ‚àóùëö1 JùëÑKV ‚â§ JùëÉKV ‚àóùëö2 JùëÑKV ‚â§ JùëÉ ‚àóùëö2 ùëÑKV

(cid:3)

DeÔ¨Ånition E.4 (Lindenbaum-Tarski Algebra). The Lindenbaum-Tarski algebra corresponding to
ùëÄ-BI is the set of all equivalence classes of interprovable propositions. That is, deÔ¨Åne the equiva-
lence relation ùëÉ ‚àº ùëÑ as ùëÉ ‚ä¢ ùëÑ and ùëÑ ‚ä¢ ùëÉ. We will show that the set of equivalence classes of this
relation forms an ùëÄ-BI algebra. Let [ùëÉ]‚àº be the equivalence class of ùëÉ under ‚àº. Take ùêºùëö, ‚ä§, and ‚ä•
to be [ùêºùëö]‚àº, [‚ä§]‚àº, and [‚ä•]‚àº, respectively. Then we deÔ¨Åne:

[ùëÉ]‚àº ‚àß [ùëÑ]‚àº = [ùëÉ ‚àß ùëÑ]‚àº
[ùëÉ]‚àº ‚à® [ùëÑ]‚àº = [ùëÉ ‚à® ùëÑ]‚àº
...
[ùëÉ]‚àº ‚àóùëö [ùëÑ]‚àº = [ùëÉ ‚àóùëö ùëÑ]‚àº
[ùëÉ]‚àº ‚àí‚àóùëö [ùëÑ]‚àº = [ùëÉ ‚àí‚àóùëö ùëÑ]‚àº

The fact that these operations are well-deÔ¨Åned and form a ùëÄ-BI algebra follows almost entirely
from the corresponding result for normal BI outlined in Docherty‚Äôs thesis. The only remaining
case is to check that if ùëö1 ‚â§ ùëö2 then [ùëÉ]‚àº ‚àóùëö1 [ùëÑ]‚àº ‚â§ [ùëÉ]‚àº ‚àóùëö2 [ùëÑ]‚àº. We have

[ùëÉ]‚àº ‚àóùëö1 [ùëÑ]‚àº = [ùëÉ ‚àóùëö1 ùëÑ]‚àº
‚â§ [ùëÉ ‚àóùëö2 ùëÑ]‚àº
= [ùëÉ]‚àº ‚àóùëö2 [ùëÑ]‚àº

Lemma E.5. ùëÉ ‚ä¢ ùëÑ if and only if [ùëÉ]‚àº ‚â§ [ùëÑ]‚àº.

(Since ùëÉ ‚àóùëö1 ùëÑ ‚â§ ùëÉ ‚àóùëö2 ùëÑ)

Proof. In the proof that the Lindenbaum-Tarski algebra indeed formed an ùëÄ-BI algebra, we
already showed that ùëÉ ‚ä¢ ùëÑ implies [ùëÉ]‚àº ‚â§ [ùëÑ]‚àº. Consider the opposite direction. Then we have
that [ùëÉ]‚àº ‚àß [ùëÑ]‚àº = [ùëÉ]‚àº, hence [ùëÉ ‚àß ùëÑ]‚àº = [ùëÉ]‚àº. This implies that ùëÉ ‚àß ùëÑ ‚ä£‚ä¢ ùëÉ. Since ùëÉ ‚àß ùëÑ ‚ä¢ ùëÑ,
(cid:3)
by transitivity we have ùëÉ ‚ä¢ ùëÑ.

Theorem E.6 (Algebraic Completeness). If JùëÉKV ‚â§ JùëÑKV for all V, then ùëÉ ‚ä¢ ùëÑ.

Proof. Consider the valuation V which maps ùëù ‚àà AP to [ùëù]‚àº. Then JùëÉKV = [ùëÉ]‚àº and JùëÑKV =
(cid:3)

[ùëÑ]‚àº. Hence we have [ùëÉ]‚àº ‚â§ [ùëÑ]‚àº which implies ùëÉ ‚ä¢ ùëÑ.

E.2 ùëÄ-BI Frames
ùëÄ-BI formulas are interpreted on Down-Closed ùëÄ-BI frames. We deÔ¨Åne a complex algebra on
ùëÄ-BI frames.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:50

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

DeÔ¨Ånition E.7 (Complex Algebra). If X is an ùëÄ-BI frame, then the complex algebra of X, written

Com(X) is the structure (P‚äë (ùëã ), ‚à©, ‚à™, ‚ÜíX, ùëã, ‚àÖ, ‚àóùëö ‚ààùëÄ , ‚àí‚àóùëö ‚ààùëÄ , ùê∏ùëö ‚ààùëÄ ) where

P‚äë(ùëã ) = {ùê¥ ‚äÜ ùëã | ùëé ‚àà ùê¥ ‚àß ùëé ‚äë ùëè ‚Üí ùëè ‚àà ùê¥}

ùê¥ ‚ÜíX ùêµ = {ùëé | ‚àÄùëè. ùëé ‚äë ùëè ‚àß ùëè ‚àà ùê¥ ‚Üí ùëè ‚àà ùêµ}
ùê¥ ‚àóùëö ùêµ = {ùë• | ‚àÉùë§, ùë¶, ùëß. ùë§ ‚äë ùë• ‚àß ùë§ ‚àà ùë¶ ‚äïùëö ùëß ‚àß ùë¶ ‚àà ùê¥ ‚àß ùëß ‚àà ùêµ}
ùê¥ ‚àí‚àóùëö ùêµ = {ùë• | ‚àÄùë§, ùë¶, ùëß. (ùë• ‚äë ùë§ ‚àß ùëß ‚àà ùë§ ‚äïùëö ùë¶ ‚àß ùë¶ ‚àà ùê¥) ‚Üí ùëß ‚àà ùêµ}

Lemma E.8. If X is an ùëÄ-BI frame, then Com(X) is an ùëÄ-BI algebra.

Proof. Each (ùëã, ‚äë, ‚äïùëö, ùê∏ùëö) is a BI frame. Docherty [2019] shows that the complex of a BI frame
is a BI algebra. Thus the only thing to check is that the ordering on ‚àó respects the ordering on ùëÄ.
Let ùëö1 ‚â§ ùëö2. We must show that ùê¥ ‚àóùëö1 ùêµ ‚äÜ ùê¥ ‚àóùëö2 ùêµ. Let ùë• ‚àà ùê¥ ‚àóùëö1 ùêµ. Then there exists ùë§, ùë¶, ùëß
such that ùë§ ‚äë ùë• and ùë§ ‚àà ùë¶ ‚äïùëö1 ùëß, with ùë¶ ‚àà ùê¥ and ùëß ‚àà ùêµ. by the Operation Inclusion property, we
(cid:3)
have that ùë§ ‚àà ùë¶ ‚äïùëö2 ùëß, hence ùë• ‚àà ùê¥ ‚àóùëö2 ùêµ.

DeÔ¨Ånition E.9 (Prime Filter). If (ùêø, ‚àß, ‚à®) is a bounded distributive lattice, a prime Ô¨Ålter on ùêπ is a

non-empty proper subset of ùê¥ such that:
‚Ä¢ If ùë• ‚àà ùêπ and ùë• ‚â§ ùë¶ then ùë¶ ‚àà ùêπ .
‚Ä¢ If ùë• ‚àà ùêπ and ùë¶ ‚àà ùêπ then ùë• ‚àß ùë¶ ‚àà ùêπ .
‚Ä¢ If ùë• ‚à® ùë¶ ‚àà ùêπ then ùë• ‚àà ùêπ or ùë¶ ‚àà ùêπ .

We write Prf(ùêø) for the set of prime Ô¨Ålters on ùêø.

DeÔ¨Ånition E.10 (Prime Filter Frame). If A is an ùëÄ-BI algebra, then the prime Ô¨Ålter ùëÄ-frame of

A is deÔ¨Åned as Prf(A) = (Prf(ùê¥), ‚äÜ, ‚äïùëö ‚ààùëÄ , ùê∏ùëö ‚ààùëÄ ) where

ùêπ1 ‚äïùëö ùêπ2 = {ùêπ ‚àà Prf(ùê¥) | ‚àÄùëé1 ‚àà ùêπ1. ‚àÄùëé2 ‚àà ùêπ2. ùëé1 ‚àóùëö ùëé2 ‚àà ùêπ }
ùëö ‚àà ùêπ }

ùê∏ùëö = {ùêπ ‚àà Prf(ùê¥) | ‚ä§‚àó

Lemma E.11. If A is an ùëÄ-BI algebra, then Prf(A) is an ùëÄ-BI frame.

Proof. Docherty [2019] shows that for each ùëö ‚àà ùëÄ, (Prf(ùê¥), ‚äÜ, ‚äïùëö, ùê∏ùëö) is a BI frame. Therefore,
we only need to check the Operation Inclusion property. Let ùëö1 ‚â§ ùëö2 and let ùêπ, ùê∫, ùêª ‚àà Prf(ùê¥)
with ùêπ ‚àà ùê∫ ‚äïùëö1 ùêª . Let ùëé ‚àà ùê∫ and ùëè ‚àà ùêª . Then ùëé ‚àóùëö1 ùëè ‚àà ùêπ . Since ùëé ‚àóùëö1 ùëè ‚â§ ùëé ‚àóùëö2 ùëè, and Ô¨Ålters are
upward-closed, ùëé ‚àóùëö2 ùëè ‚àà ùêπ , hence ùêπ ‚àà ùê∫ ‚äïùëö2 ùêª .

(cid:3)

Theorem E.12 (Representation Theorem). Every ùëÄ-BI algebra is isomorphic to a subalgebra
of a complex algebra. In particular, if A is an ùëÄ-BI algebra, then the map ùúÉ : A ‚Üí Com(Prf(A))
deÔ¨Åned as

ùúÉ (ùë•) = {ùêπ ‚àà Prf(A) | ùë• ‚àà ùêπ }

is an embedding.

Proof. Docherty [2019] proves that for each ùëö ‚àà ùëÄ, this map ùúÉ is an embedding of (ùê¥, ‚àß, ‚à®, ‚Üí
, ‚ä§, ‚ä•, ‚àóùëö, ‚àí‚àóùëö, ‚ä§‚àó
ùëö) as a BI algebra into the complex algebra, viewed as a BI algebra for the oper-
ations indexed by ùëö. Hence, ùúÉ is injective and a homomorphism with respect to all of the ùëÄ-BI
(cid:3)
algebra operations.

Theorem E.13 (Eqivalence of Algebras and Frames). Let A = (ùê¥, . . . ) be an ùëÄ-BI algebra
and let Va : AP ‚Üí ùê¥ be an interpretation of atomic propositions. Let X = (ùëã, . . . ) be an ùëÄ-BI
: Prop ‚Üí P (ùëã ) be a persistent valuation on X. Let ùúÉ be the embedding from
frame and let Vf

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:51

the previous result. DeÔ¨Åne the persistent valuation V ‚Ä≤
V ‚Ä≤
f

: AP ‚Üí Com(X) by:

a : AP ‚Üí P (Prf(ùê¥)) and the interpretation

V ‚Ä≤
V ‚Ä≤

a (ùëù) = ùúÉ (Va(ùëù))
f (ùëù) = Vf (ùëù).

Then we have

(1) ùë• |=Vf ùëÉ if and only if ùë• ‚àà JùëÉKV ‚Ä≤
(2) ùêπ |=V‚Ä≤

a ùëÉ if and only if JùëÉKVa ‚àà ùêπ .

f

Proof. For the Ô¨Årst part, we proceed by induction on ùëÉ.
‚Ä¢ Case ùëÉ = ùëù: We have:

ùë• |=Vf ùëù ‚Üî ùë• ‚àà Vf (ùëù)
‚Üî ùë• ‚àà Vf‚Äô (ùëù)
‚Üî ùë• ‚àà JùëùKf‚Äô

‚Ä¢ Case ùëÉ = ‚ä§: Then ùë• |=Vf ‚ä§ holds for all ùë•, and ‚ä§ in Com(X) is deÔ¨Åned to be ùëã , so ùë• ‚àà J‚ä§KV‚Ä≤

f

holds for all ùë•.

‚Ä¢ Case ùëÉ = ùêºùëö: Similar to ùëÉ = ‚ä§.
‚Ä¢ Case ùëÉ = ‚ä•: Similar to ùëÉ = ‚ä§.
‚Ä¢ Case ùëÉ = ùëÑ1 ‚àß ùëÑ2:

ùë• |=Vf ùëÑ1 ‚àß ùëÑ2 ‚Üî ùë• |=Vf ùëÑ1 and ùë• |=Vf ùëÑ2

‚Üî ùë• ‚àà JùëÑ1KVf‚Ä≤ and ùë• ‚àà JùëÑ2KVf‚Ä≤
‚Üî ùë• ‚àà JùëÑ1KVf‚Ä≤ ‚à© JùëÑ2KVf‚Ä≤
‚Üî ùë• ‚àà JùëÑ1 ‚àß ùëÑ2KVf‚Ä≤

(By satisÔ¨Åcation rule)
(Vf‚Ä≤ and Vf‚Ä≤ the same)

(By the ‚àß operation in Complex algebra and the recursive deÔ¨Ånition of V)

‚Ä¢ Case ùëÉ = ùëÑ1 ‚à® ùëÑ2:

ùë• |=Vf ùëÑ1 ‚à® ùëÑ2 ‚Üî ùë• |=Vf ùëÑ1 or ùë• |=Vf ùëÑ2

‚Üî ùë• ‚àà JùëÑ1KVf‚Ä≤ or ùë• ‚àà JùëÑ2KVf‚Ä≤
‚Üî ùë• ‚àà JùëÑ1KVf‚Ä≤ ‚à™ JùëÑ2KVf‚Ä≤
‚Üî ùë• ‚àà JùëÑ1 ‚à® ùëÑ2KVf‚Ä≤
‚Ä¢ Case ùëÉ = ùëÑ1 ‚Üí ùëÑ2: Let ùë• |=Vf ùëÑ1 ‚Üí ùëÑ2. Then, for all ùë¶ such that ùë• ‚äë ùë¶, if ùë¶ |=Vf ùëÑ1,
then ùë¶ |=Vf ùëÑ2. Applying the induction hypothesis, we have that for all ùë¶ such that ùë• ‚äë ùë¶, if
ùë¶ ‚àà JùëÑ1KVf‚Ä≤ , then ùë¶ ‚àà JùëÑ2KVf‚Ä≤ . Hence, ùë• ‚àà JùëÑ1 ‚Üí ùëÑ2KVf‚Ä≤ . The reverse direction is similar.
‚Ä¢ Case ùëÉ = ùëÑ1 ‚àóùëö ùëÑ2: Let ùë• |=Vf ùëÑ1 ‚àóùëö ùëÑ2. Then there exists ùë• ‚Ä≤, ùë¶, and ùëß such that ùë• ‚Ä≤ ‚äë ùë•
and ùë• ‚Ä≤ ‚àà ùë¶ ‚äïùëö ùëß, where ùë¶ |=Vf ùëÑ1 and ùëß |=Vf ùëÑ2. By the induction hypothesis, we have that
ùë¶ ‚àà JùëÑ1KVf‚Ä≤ and ùëß ‚àà JùëÑ2KVf‚Ä≤ . Hence, ùë• ‚àà JùëÑ1 ‚àóùëö ùëÑ2KVf‚Ä≤ .

‚Ä¢ Case ùëÉ = ùëÑ1 ‚àí‚àóùëö ùëÑ2: Let ùë• |=Vf ùëÑ1 ‚àí‚àóùëö ùëÑ2. Then for all ùë• ‚Ä≤, ùë¶, and ùëß such that ùë• ‚äë ùë• ‚Ä≤ and

ùëß ‚àà ùë• ‚Ä≤ ‚äïùëö ùë¶, if ùë¶ |=Vf ùëÑ1, then ùëß |=Vf ùëÑ2.
To show that ùë• ‚àà JùëÑ1 ‚àí‚àóùëö ùëÑ2KVf‚Ä≤ , let ùë§, ùë¶, and ùëß be such that ùë• ‚äë ùë§, ùëß ‚àà ùë§ ‚äïùëö ùë¶, and
ùë¶ ‚àà JùëÑ1KVf‚Ä≤ . We must show that ùëß ‚àà JùëÑ2KVf‚Ä≤ . Applying the induction hypothesis, we have
that ùë¶ ‚àà|=Vf ùëÑ1. Thus, by the preceding paragraph, we have that ùëß |=Vf ùëÑ2. Applying the
induction hypothesis again, we get that ùëß ‚àà JùëÑ2KVf‚Ä≤ .

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:52

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

For the second part, assuming ùêπ ‚àà Prf(A), then for any ùëÉ, we have

ùêπ |=V‚Ä≤

a ùëÉ ‚Üî ùêπ ‚àà Va‚Ä≤ (ùëÉ)

‚Üî ùêπ ‚àà Prf(A) and Va (ùëÉ) ‚àà ùêπ
‚Üî Va (ùëÉ) ‚àà ùêπ
‚Üî JùëÉKVa ‚àà ùêπ .

Theorem E.14 (Completeness). If ùëÉ |=V ùëÑ for all V, then ùëÉ ‚ä¢ ùëÑ

(cid:3)

Proof. Suppose ùëÉ 0 ùëÑ. Then by algebraic completeness, there exists some ùëÄ-BI algebra A and
an interpretation Va such that JùëÉKVa (cid:2) JùëÑKVa . By the prime Ô¨Ålter theorem, there exists [Docherty
2019] a prime Ô¨Ålter ùêπ such that JùëÉKVa ‚àà ùêπ and JùëÑKVa
a be as in the previous theorem,
(cid:3)
then we have ùêπ |=V‚Ä≤
a ùëÉ and ùêπ 6|=V‚Ä≤

a ùëÑ which contradicts the assumption that ùëÉ |=V‚Ä≤

‚àâ ùêπ . Let V ‚Ä≤

a ùëÑ.

F EXAMPLES: OMITTED DETAILS

F.1 Bound false positive rate in Bloom filter
One detail we omitted is that, since the Ô¨Årst line of the program Bloom, ùëèùëôùëúùëúùëö has been kept as a
bit-array throughout, i.e., all its entries are either 0 or 1. So it is easy to prove that

ùëÅ

{‚ä§} Bloom {

(ùëèùëôùëúùëúùëö[ùõΩ] = 0 ‚à® ùëèùëôùëúùëúùëö[ùõΩ] = 1)}.

Then, by the conjunction rule Conj, we have

√õùõΩ=0

{‚ä§} Bloom {Pr

where ùêæ = E

ùëÅ
ùõΩ=0 ùëèùëôùëúùëúùëö[ùõΩ]

.

Ô£Æ
√ïùõΩ=0
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞

Ô¨Årst ùëÅ entries are one,

h√ç

ùëÅ

ùëèùëôùëúùëúùëö[ùõΩ] < ùêæ + ùëá (ùõø, ùëÅ )

‚â• 1 ‚àí ùõø},

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

In the following, we will abbreviate formulas that assert ùëè is a bit-array where exactly ùêΩ of its

i

ùëÅ

ùëÅ

ùëè [ùõΩ] = ùêΩ

‚àß

(ùëè [ùõΩ] = 0 ‚à® ùëè [ùõΩ] = 1),

√ïùõΩ=0
as bv(ùëè, ùêΩ , ùëÅ ). Similarly, we will use bv(ùëè, < ùêΩ , ùëÅ ) to abbreviate

√õùõΩ=0

¬©

¬´

ùëÅ

ùëè [ùõΩ] < ùêΩ

‚àß

(ùëè [ùõΩ] = 0 ‚à® ùëè [ùõΩ] = 1).

ùëÅ

√õùõΩ=0

√ïùõΩ=0
¬©
Now we restate our goal as
¬´

¬™
¬Æ
¬¨

¬™
¬Æ
¬¨

{bv(ùëèùëôùëúùëúùëö, < ùêæ, ùëÅ )} CheckMem {Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§ (ùêæ/ùëÅ )ùêª }.

CheckMem Ô¨Årst initializes ‚Ñé and ùëéùëôùëô‚Ñéùëñùë° deterministically to 1. Then, using RAssn and Frame,

we can show that

‚ä¢ {‚ä§} ‚Ñé ‚Üê 0; ùëéùëôùëô‚Ñéùëñùë° ‚Üê 1 {(‚Ñé ‚àº 0) ‚àó (ùëéùëôùëô‚Ñéùëñùë° ‚àº 1)}.
Using the (ProbOne) axiom and the fact that 1 ‚â§ (ùêæ/ùëÅ )0 for any ùêæ and ùëÅ , we can show |= (‚Ñé ‚àº 0) ‚àó
(ùëéùëôùëô‚Ñéùëñùë° ‚àº 1) ‚Üí Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§ (ùêæ/ùëÅ )‚Ñé. Thus,

‚ä¢ {‚ä§} ‚Ñé ‚Üê 0; ùëéùëôùëô‚Ñéùëñùë° ‚Üê 1 {Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§ (ùêæ/ùëÅ )‚Ñé}.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

 
 
A Separation Logic for Negative Dependence

57:53

Because the assignments ‚Ñé ‚Üê 0; ùëéùëôùëô‚Ñéùëñùë° ‚Üê 1 do not modify the Bloom Ô¨Ålter array ùëèùëôùëúùëúùëö, we can
then apply the frame rule Frame to derive

‚ä¢ {bv(ùëèùëôùëúùëúùëö, < ùêæ, ùëÅ )} ‚Ñé ‚Üê 0; ùëéùëôùëô‚Ñéùëñùë° ‚Üê 1 {bv(ùëèùëôùëúùëúùëö, < ùêæ, ùëÅ ) ‚àó Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§ (ùêæ/ùëÅ )‚Ñé}.

(12)

We will abbreviate bv(ùëèùëôùëúùëúùëö, < ùêæ, ùëÅ ) ‚àó Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§ (ùêæ/ùëÅ )‚Ñé as ùúÇ. Because
upper bounded by ùëÅ ,

|=Mem ùúÇ ‚Üí

ùúÇ ùêΩ ,

ùëÅ
ùõΩ=0 ùëè [ùõΩ] is an integer

√ç

where ùúÇ ùêΩ abbreviates ùêΩ < ùêæ ‚àß

bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ ) ‚àó Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§ (ùêæ/ùëÅ )‚Ñé
We will then prove that for each ùêΩ , the formula ùúÇ ùêΩ is a loop invariant of CheckMem‚Äôs loop body.

.

The loop body Ô¨Årst uniformly sample an element from [ùëÅ ], so by RSamp‚àó,

(cid:0)

(cid:1)

√ú0‚â§ùêΩ <ùêæ

Together with the axiom |= ùëÉ ‚àó ùëÑ ‚Üí ùëÉ, Equation (13) implies

ùúÇ ùêΩ ‚àó U[ùëÅ ] hùëèùëñùëõi.

(13)

ùêΩ < ùêæ ‚àß

bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ ) ‚àó

Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§ (

(cid:18)

(cid:18)

ùêæ
ùëÅ

)‚Ñé

(cid:19)

‚àó U[ùëÅ ] hùëèùëñùëõi

.

(cid:19)

Then, ‚Ñéùëñùë° gets assigned to ùëèùëôùëúùëúùëö[ùëèùëñùëõ], so by RAssn, we have
{bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ ) ‚àó U[ùëÅ ] hùëèùëñùëõi} ‚Ñéùëñùë° ‚Üê ùëèùëôùëúùëúùëö[ùõΩ] {
Since the array ùëèùëôùëúùëúùëö only contains zero-one entries, when the sum of its entries is ùêΩ , an entry
(cid:0)
ùëèùëôùëúùëúùëö[ùëèùëñùëõ] drawn uniformly at random has probability ùêΩ
ùëÅ to be 1. If the entry is in addition chosen
independently from values in ùëèùëôùëúùëúùëö, then the bit ùëèùëôùëúùëúùëö[ùëèùëñùëõ] is distributed independent from the
distribution of ùëèùëôùëúùëúùëö. The (UniformSamp) axiom encodes this fact:

bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ ) ‚àó U[ùëÅ ] hùëèùëñùëõi

(cid:1)

‚àß ‚Ñéùëñùë° ‚àº ùëèùëôùëúùëúùëö[ùëèùëñùëõ]}.

|=

bv(ùëè, ùêΩ , ùëÅ ) ‚àó U[ùëÅ ] hùë•i

‚àß ‚Ñéùëñùë° ‚àº ùëè [ùë•]

‚Üí Bern ùêΩ
ùëÅ

h‚Ñéùëñùë°i ‚àó bv(ùëè, ùêΩ , ùëÅ ).

Thus, we have

(cid:0) (cid:0)

(cid:1)

(cid:1)

{bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ ) ‚àó U[ùëÅ ] hùëèùëñùëõi} ‚Ñéùëñùë° ‚Üê ùëèùëôùëúùëúùëö[ùõΩ] {Bern ùêΩ

ùëÅ

h‚Ñéùëñùë°i ‚àó bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ )}.

Because ‚Ñéùëñùë° ‚Üê ùëèùëôùëúùëúùëö[ùëèùëñùëõ] does not modify ùëéùëôùëô‚Ñéùëñùë°, we can apply the frame rule for ‚àó Frame and
get

bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ ) ‚àó U[ùëÅ ] hùëèùëñùëõi ‚àó Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

(

‚Ñéùëñùë° ‚Üê ùëèùëôùëúùëúùëö[ùõΩ]

ùêæ
ùëÅ

(cid:18)

‚Ñé

)

(cid:19)

Bern ùêΩ
ùëÅ

(

h‚Ñéùëñùë°i ‚àó bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ ) ‚àó Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

ùêæ
ùëÅ

(cid:18)

‚Ñé

.

)

(cid:19)

Next, with the assignment ùëéùëôùëô‚Ñéùëñùë° ‚Üê ‚Ñéùëñùë° && ùëéùëôùëô‚Ñéùëñùë°, by applying the axioms (IndepProb), (EqualProb)
and the RAssn rule, we get:

Bern ùêΩ
ùëÅ

(

h‚Ñéùëñùë°i ‚àó bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ ) ‚àó Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

ùëéùëôùëô‚Ñéùëñùë° ‚Üê ‚Ñéùëñùë° && ùëéùëôùëô‚Ñéùëñùë°

Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

(  

ùêΩ
ùëÅ

¬∑

ùêæ
ùëÅ

(cid:18)

‚Ñé

!

(cid:19)

‚àó bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ )

)

ùêæ
ùëÅ

(cid:18)

‚Ñé

)

(cid:19)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:54

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

We can then apply the rule of constancy Const and get

ùêΩ < ùêæ ‚àß

bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ ) ‚àó U[ùëÅ ] hùëèùëñùëõi ‚àó Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

ùêæ
ùëÅ

(cid:18)

‚Ñé

!)

(cid:19)

‚Ñéùëñùë° ‚Üê ùëèùëôùëúùëúùëö[ùõΩ]; ùëéùëôùëô‚Ñéùëñùë° ‚Üê ‚Ñéùëñùë° && ùëéùëôùëô‚Ñéùëñùë°

ùêΩ < ùêæ ‚àß

Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

ùêΩ
ùëÅ

¬∑

ùêæ
ùëÅ

(cid:18)

‚Ñé

!

(cid:19)

‚àó bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ )

!)

(

(

When we have ùêΩ < ùêæ, then (ùêæ/ùëÅ )‚Ñé ¬∑

ùêΩ
ùëÅ ‚â§ (ùêæ/ùëÅ )‚Ñé+1, so the post condition implies

ùêΩ < ùêæ ‚àß

Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

‚Ñé+1

!

ùêæ
ùëÅ

(cid:18)

(cid:19)

‚àó bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ )

!

The last step in the loop body is the assignment ‚Ñé ‚Üê ‚Ñé + 1. By the deterministic assignment rule
DAssn, we can establish the post condition ùúÇ ùêΩ afterwards:

ùêΩ < ùêæ ‚àß

bv(ùëèùëôùëúùëúùëö, ùêΩ , ùëÅ ) ‚àó Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

ùêæ
ùëÅ

(cid:18)

‚Ñé

.

!

(cid:19)

Thus, we have {ùúÇ ùêΩ } loop body {ùúÇ ùêΩ }

By Loop rule, we can establish {ùúÇ ùêΩ } ùëôùëúùëúùëù {ùúÇ ùêΩ ‚àß ‚Ñé ‚â• ùêª }. Since ùúÇ ùêΩ ‚àß ‚Ñé ‚â• ùêª implies Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

(ùêæ/ùëÅ )ùêª , we then have

{ùúÇ ùêΩ } ùëôùëúùëúùëù {Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

ùêª

}.

ùêæ
ùëÅ

(cid:18)

(cid:19)

Because Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§ (ùêæ/ùëÅ )ùêª is closed under mixtures, and ùúÇ is closed under conditioning, we
can then apply RCase to prove that

{ùúÇ} ùëôùëúùëúùëù {Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

ùêª

}.

ùêæ
ùëÅ

(cid:18)

(cid:19)

(14)

Using the Seqn rule to combine the proved judgments for CheckMem‚Äôs initialization (12) and
loop (14), we derive

ùëÅ

{

√ïùõΩ=0

ùëèùëôùëúùëúùëö[ùõΩ] < ùêæ} CheckMem {Pr[ùëéùëôùëô‚Ñéùëñùë°] ‚â§

ùêª

}.

ùêæ
ùëÅ

(cid:18)

(cid:19)

F.2 Permutation Hashing
We sketch how to replicate the informal reasoning in LINA. For the main loop, we apply the rule
Loop with the following loop invariant:

ùëõ

ùëõ

‚Ñéùëñùë°ùëç [ùõº] ‚àº [ùëöùëúùëë (ùëî[ùõº], ùêµ) = ùëç ] ‚àß Perm[ùêµ ¬∑ùêæ ] hùëîi ‚àß ùëêùë° =

‚Ñéùëñùë°ùëç [ùõº] ‚àß (¬¨(ùëõ < ùëÅ ) ‚Üí ùëõ ‚àº ùëÅ )

√õùõº =0
The loop invariant is preserved by the body of the loop, using the assignment rule (RAssn) and
the rule of constancy (Const). Thus we can show the following judgment:

√ïùõº =0

{ùëêùë° ‚àº 0 ‚àß ùëõ ‚àº 0} ùëôùëúùëúùëù {

ùëÅ

√õùõº =0

‚Ñéùëñùë°ùëç [ùõº] ‚àº [ùëöùëúùëë (ùëî[ùõº], ùêµ) = ùëç ] ‚àß Perm[ùêµ ¬∑ùêæ ] hùëîi ‚àß ùëêùë° ‚àº

‚Ñéùëñùë°ùëç [ùõº]}

ùëÅ

√ïùõº =0

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

 
  
  
 
A Separation Logic for Negative Dependence

57:55

Applying (Perm-Map), the post-condition implies:

‚Ñéùëñùë°ùëç [ùõº] ‚àº [ùëöùëúùëë (ùëî[ùõº], ùêµ) = ùëç ] ‚àß

ùëÅ‚àó

ùõº =0

ùëÅ

√õùõº =0

h‚Ñéùëñùë°ùëç [ùõº]i ‚àß Perm[ùêµ ¬∑ùêæ ] hùëîi ‚àß ùëêùë° ‚àº

‚Ñéùëñùë°ùëç [ùõº]

ùëÅ

√ïùõº =0

Applying basic axioms about expected value and the permutation distribution ((PermMarg) (ProbUnif)
(BijectUnif)), we have:

ùëÅ‚àó

ùõº =0

h‚Ñéùëñùë°ùëç [ùõº]i ‚àß ùëêùë° ‚àº

‚Ñéùëñùë°ùëç [ùõº] ‚àß E[ùëêùë°] ‚àº ùëÅ /ùêµ

ùëÅ

√ïùõº =0

And we can apply the negative-association ChernoÔ¨Ä bound (NA-ChernoÔ¨Ä) to conclude:

{‚ä§} PermHash {Pr[|ùëêùë° ‚àí ùëÅ /ùêµ| > ùëá (ùõΩ, ùëÅ )] < ùõΩ}

This conclusion corresponds to Proposition A.2 in Ding and K√∂nig [2011] algorithm for fast set
intersection.6

F.3 Fully-Dynamic Dictionary

We outline the main steps in the formal proof; the most interesting step is the last one, where we
use negative association, but all steps can be handled in our framework.

We will refer to the two outer-most loops as (1) and (2), the next two outer-most loops as (1.1)

and (2.1), and the inner-most loop as (1.1.1).

Computing E[ùëèùëñùëõùê∂ùë° [ùëê] [ùëù]]. For loop (1), we apply Loop with the following loop invariant:

ùê∂

ùëÉ

√õùõæ=0

√õùõΩ=0

E[ùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]] ‚àº ùëõ/(ùëÉ ¬∑ ùê∂) ‚àß (¬¨(ùëõ < ùëÅ ) ‚Üí ùëõ ‚àº ùëÅ ).

To show that this invariant is preserved by the loop, by two applications of RSamp* the following
holds after the sampling commands:

OH[ùëÉ ] hùëùùëúùëêùëòùëíùë° [ùëõ]i ‚àó OH[ùê∂ ] hùëêùëüùëéùë°ùëí [ùëõ]i ‚àß ùëèùëñùëõ[ùëõ] ‚àº ùëêùëüùëéùë°ùëí [ùëõ]‚ä§ ¬∑ ùëùùëúùëêùëòùëíùë° [ùëõ].

Using an axiom about independence and products of one-hot vectors (IndProdOH), this implies:

Using an axiom about the one-hot encoding (OHMarg):

OH[ùê∂ ]√ó[ùëÉ ] hùëèùëñùëõ[ùëõ]i.

E[ùëèùëñùëõ[ùõº] [ùõæ] [ùõΩ]] ‚àº 1/(ùëÉ ¬∑ ùê∂)

for every ùõº, ùõæ, and ùõΩ. Standard loop invariants for loop (1.1) and (1.1.1) show that:

ùëõ

ùëèùëñùëõùê∂ùë° [ùëê] [ùëù] ‚àº

ùëèùëñùëõ[ùõº] [ùëê] [ùëù],

√ïùõº =0
and linearity of expectation establishes the invariant condition for loop (1). The invariant holds
at the start of loop (1) since ùëèùëñùëõùê∂ùë° is zero-initialized, and it also holds at the end of loop (1). Since
ùëèùëñùëõùê∂ùë° is not modiÔ¨Åed further, the expectation bound also holds at the end of the program (Const).

6Ding and K√∂nig [2011] apply a variant of the ChernoÔ¨Ä bound to obtain a multiplicative, rather than an additive, error
guarantee. We present the additive version since the bound is a bit simpler, but there is no diÔ¨Éculty to handling the
multiplicative version in our framework.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:56

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

ùëõ‚àó

ùõº =0
(cid:18)

Bounding Pr[ùëèùëñùëõùê∂ùë° [ùëê] [ùëù] > ùëáùëèùëñùëõ]. For loop (1), we apply Loop with the following loop invariant:
ùëÅ

ùê∂

ùëÉ

hùëèùëñùëõ[ùõº]i

‚àß

ùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ] ‚àº

ùëèùëñùëõ[ùõº] [ùõæ] [ùõΩ] ‚àß (¬¨(ùëõ < ùëÅ ) ‚Üí ùëõ ‚àº ùëÅ ).

(cid:19)

√õùõæ=0

√ïùõº =0
The Ô¨Årst conjunction is an invariant, by applying the sampling rule Samp* and the independence
frame rule Frame from PSL. The rest of the invariant is preserved, following standard invariants
for loops (1.1) and (1.1.1). By projection (IndMap), at the end of loop (1) we can conclude:

√õùõΩ=0

ùê∂

ùëÉ

ùëÅ‚àó

ùõº =0

hùëèùëñùëõ[ùõº] [ùõæ] [ùõΩ]i

√õùõæ=0
Thus a (standard) ChernoÔ¨Ä bound gives:

√õùõΩ=0  

‚àß ùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ] ‚àº

ùëèùëñùëõ[ùõº] [ùõæ] [ùõΩ].

ùëÅ

√ïùõº =0

!

ùê∂

ùëÉ

Pr[ùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ] > E[ùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]] + ùëá (ùúåùëèùëñùëõ, ùëÅ )] ‚â§ ùúåùëèùëñùëõ.

√õùõæ=0

√õùõΩ=0

where E[ùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]] is ùëÅ /(ùëÉ ¬∑ùê∂) by the previous step. Again, property holds until the end of the
program since ùëèùëñùëõùê∂ùë° is not modiÔ¨Åed further (Const).

Bounding E[ùëúùë£ùëíùëüùê∂ùë° [ùëê]]. Using standard loop invariants, at the end of loop (2) we have:

ùê∂

ùëÉ

ùê∂

ùëÉ

ùëúùë£ùëíùëüùê∂ùë° [ùõæ] ‚àº

ùëèùëñùëõ[ùõø] [ùõΩ] ‚àß

ùëúùë£ùëíùëü [ùõæ] [ùõΩ] ‚àº [ùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ] > ùëáùëèùëñùëõ].

√õùõæ=0

√ïùõΩ=0

√ïùõø=0

√õùõΩ=0

Using linearity of expectation and the fact that ùëúùë£ùëíùëü [ùõæ] [ùõΩ] is either zero or one, we have:

E[ùëúùë£ùëíùëüùê∂ùë° [ùõæ]] ‚àº

E[ùëúùë£ùëíùëü [ùõæ] [ùõΩ]] ‚àº

Pr[ùëúùë£ùëíùëü [ùõæ] [ùõΩ] = 1] ‚àº

ùëÉ

ùëÉ

√ïùõΩ=0

√ïùõΩ=0

since we have bound the probability in the previous step.

Pr[ùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ] > ùëáùëèùëñùëõ] ‚â§ ùëÉ¬∑ùúåùëèùëñùëõ

ùëÉ

√ïùõΩ=0

Bounding Pr[ùëúùë£ùëíùëüùê∂ùë° [ùëê] > ùëáùëúùë£ùëíùëü ]. We want the following loop invariant for (1):

ùëÉ‚äõ

ùõΩ=0

ùê∂

ùëÉ

√õùõæ=0

√õùõΩ=0

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i ‚àß (¬¨(ùëõ < ùëÅ ) ‚Üí ùëõ ‚àº ùëÅ ).

We want the following loop invariant for (1.1):

ùëÉ‚äõ

ùõΩ=0

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i ‚äõ

ùëÉ‚äõ

ùõΩ=ùëê

hùëèùëñùëõ[ùëõ] [ùõæ] [ùõΩ]i ‚àß (¬¨(ùëù < ùëÉ) ‚Üí ùëù ‚àº ùëÉ).

ùê∂

√õùõæ=0

And the following loop invariant for (1.1.1):

ùëÉ‚äõ

ùõΩ=0

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i ‚äõ

ùëÉ‚äõ

ùõΩ=ùëù+[ùëê>ùõæ ]

hùëèùëñùëõ[ùëõ] [ùõæ] [ùõΩ]i.

ùê∂

√õùõæ=0

We show the invariant post-conditions for a Ô¨Åxed ùõæ; the big conjunction then follows by apply-
ing Conj. Working from inside-to-outside, we start with loop (1.1.1). To establish the invariant
condition, the critical case is ùëê = ùõæ. We can pull out:
ùëù‚äõ
ùëÉ‚äõ

hùëèùëñùëõ[ùëõ] [ùõæ] [ùõΩ]i ‚äõ hùëèùëñùëõùê∂ùë° [ùõæ] [ùëù]i ‚äõ hùëèùëñùëõ[ùëõ] [ùõæ] [ùëù]i

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i ‚äõ

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i ‚äõ

ùëÉ‚äõ

ùõΩ=0

ùõΩ=ùëù+1

ùõΩ=ùëù+1

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

|

Œ¶

{z

}

                                     
                                     
A Separation Logic for Negative Dependence

57:57

Now, we can use the assignment rule to show:

{Œ¶} ùë¢ùëùùëë ‚Üê ùëèùëñùëõùê∂ùë° [ùëê] [ùëù] + ùëèùëñùëõ[ùëõ] [ùëê] [ùëù] {ùë¢ùëùùëë ‚àº ùëèùëñùëõùê∂ùë° [ùëê] [ùëù] + ùëèùëñùëõ[ùëõ] [ùëê] [ùëù]}

Since addition is a monotone function, the NA frame rule (NegFrame) gives:

ùëù‚äõ

ùõΩ=0

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i ‚äõ

ùëÉ‚äõ

ùõΩ=ùëù+1

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i ‚äõ

ùëÉ‚äõ

ùõΩ=ùëù+1

hùëèùëñùëõ[ùëõ] [ùõæ] [ùõΩ]i ‚äõ hùë¢ùëùùëëi

after the assignment to ùë¢ùëùùëë. After the assignment to ùëèùëñùëõ[ùëê] [ùëù], we can fold:

ùëÉ‚äõ

ùõΩ=0

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i ‚äõ

ùëÉ‚äõ

ùõΩ=ùëù+1

hùëèùëñùëõ[ùëõ] [ùõæ] [ùõΩ]i

to establish the invariant for loop (1.1.1).

To establish the invariant for loop (1.1), when the inner-most loop (1.1.1) terminates we have

ùëê > ùõæ, and so we have:

ùëÉ‚äõ

ùõΩ=0

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i ‚äõ

ùëÉ‚äõ

ùõΩ=ùëù+1

hùëèùëñùëõ[ùëõ] [ùõæ] [ùõΩ]i.

To establish the invariant for loop (1), note that the invariant for loop (1.1) holds on loop entry
since ùëß is zero-initialized (DetInd). And the loop invariant for loop (1) is established when loop
(1.1) exits, when ùëù = ùëÉ.

Next, we tackle loop (2). We take the invariant:

ùëù‚äõ

ùõΩ=0

ùê∂

√õùõæ=0

hùëúùë£ùëíùëü [ùõæ] [ùõΩ]i ‚äõ

ùëÉ‚äõ

ùõΩ=ùëù

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i.

For the inner loop (2.1), we take the invariant:

ùëù+[ùëê>ùõæ ]‚äõ

ùõΩ=0

hùëúùë£ùëíùëü [ùõæ] [ùõΩ]i ‚äõ

ùëÉ‚äõ

ùõΩ=ùëù+[ùëê>ùõæ ]

hùëèùëñùëõùê∂ùë° [ùõæ] [ùõΩ]i.

ùê∂

√õùõæ=0

Again, we show the invariant post-conditions for a Ô¨Åxed ùõæ. For the critical iteration ùëê = ùõæ, we again
isolate ùëèùëñùëõùê∂ùë° [ùõæ] [ùëù], observe that addition is monotone and the function [ùëèùëñùëõùê∂ùë° [ùëê] [ùëù] > ùëáùëèùëñùëõ] is
monotone in ùëèùëñùëõùê∂ùë° [ùõæ] [ùëù], and apply the NA frame rule (NegFrame).

Finally at the end of the program, we can show:

along with the regular invariant

ùëÉ‚äõ

ùõΩ=0

hùëúùë£ùëíùëü [ùõæ] [ùõΩ]i

ùëÉ

ùëúùë£ùëíùëüùê∂ùë° [ùõæ] ‚àº

ùëúùë£ùëíùëü [ùõæ] [ùõΩ].

√ïùõΩ=0

We can then apply the negative-dependence ChernoÔ¨Ä bound (NA-ChernoÔ¨Ä):
Pr[ùëúùë£ùëíùëüùê∂ùë° [ùõæ] > E[ùëúùë£ùëíùëüùê∂ùë° [ùõæ]] + ùëá (ùúåùëúùë£ùëíùëü , ùëÉ)] ‚â§ ùúåùëúùë£ùëíùëü .
Using the expectation bound from the previous step and putting everything together, we conclude:

ùê∂

{‚ä§} FDDict {

Pr[ùëúùë£ùëíùëüùê∂ùë° [ùõæ] > ùëÉ ¬∑ ùúåùëèùëñùëõ + ùëá (ùúåùëúùë£ùëíùëü , ùëÉ)] ‚â§ ùúåùëúùë£ùëíùëü },

√õùõæ=0

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

57:58

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

thus showing a high-probability upper-bound on the number of overfull pocket dictionaries within
each crate.

F.4 Repeated Balls-into-Bins

We will refer to the loops in Figure 8b using the same scheme we used before: the outer-most loop
is loop (1), the three next-outer-most loops are loops (1.1), (1.2), and (1.3), and the inner-most loop
is loop (1.2.1). Starting from the outside, we take the following invariant for loop (1):

ùëü

ùëÅ

Pr

(ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùõΩ] > ùëáùëíùëöùëùùë° ùë¶ )

‚â§ ùëü ¬∑ ùúåùëíùëöùëùùë° ùë¶ ‚àß

ùëêùë° [ùõº] ‚àº ùëÅ

√ïùõº =0
Showing the invariant condition requires some work. First, note that:

Ô£Æ
√úùõΩ=0
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞
|=Mem

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

ùëÅ

ùëêùë° [ùõº] ‚àº ùëÅ ‚Üí

ùëÅ

ùëêùë° [ùõº] ‚àº |ùúé ‚àí1(ùõº)|

√ïùõº =0

√úùúé:[ùëÅ ]‚Üí[ùëÅ ]

√õùõº =0

where ùúé : [ùëÅ ] ‚Üí [ùëÅ ] ranges over all assignments of ùëÅ balls to ùëÅ bins, and where we write |=Mem
to denote that the formula is valid in all memories, rather than distributions over memories. We
write ùúè (ùõº) = |ùúé ‚àí1(ùõº)| for the number of balls in bin ùõº. We will show:

ùëÅ

{

ùëêùë° [ùõº] ‚àº ùúè (ùõº)} ùëèùëúùëëùë¶ {Pr

ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ] < ùëáùëíùëöùëùùë° ùë¶

‚â§ ùúåùëíùëöùëùùë° ùë¶}

√õùõº =0

where ùëèùëúùëëùë¶ is the body of loop (1). For loop (1.1), it is straightforward to show the invariant using
the loop rule Loop:

(cid:2)

(cid:3)

ùëÅ

ùëõ

ùëõ

(ùëêùë° [ùõº] ‚àº ùúè (ùõº))‚àß

(ùëêùë° [ùõº] ‚àº ùúè (ùõº) ‚àí [ùúè (ùõº) > 0])‚àßùëüùëíùëö ‚àº

[ùúé (ùõº) > 0]‚àß(¬¨(ùëõ < ùëÅ ) ‚Üí ùëõ ‚àº ùëÅ )

ùõº =ùëõ
√õ
At the exit of loop (1.1), we have:

√õùõº =0

√ïùõº =0

ùëÅ‚äõ

ùõº =0

hùëêùë° [ùõº]i

since counts are all equal to expressions of logical variables, so conditioning on the logical variables,
they are all deterministic; we take this formula to be the invariant for loop (1.2). Note that the loop
guard is not deterministic, since the value of ùëüùëíùëö is randomized. However, under our conditioning,
ùëüùëíùëö is deterministic under our conditioning since it is fully determined by the initial counts (i.e.,
it is the number of buckets that are initially non-empty). Hence, we may apply the loop rule Loop,
treating the loop guard as deterministic. This is the power of reasoning under conditioning.

Now to establish the invariant for loop (1.2), we reason much as in the previous examples. The

sampling rule Samp* gives:

By negative association for one-hot encoding (OH-PNA):

ùëÅ‚äõ

ùõº =0

hùëêùë° [ùõº]i ‚àó hùëèùëñùëõ[ ùëó ]i

This implies:

ùëÅ‚äõ

ùõº =0

hùëêùë° [ùõº]i ‚àó

ùëÅ‚äõ

ùõº =0

hùëèùëñùëõ[ ùëó ] [ùõº]i

ùëÅ‚äõ

ùõº =0

hùëêùë° [ùõº]i ‚äõ

ùëÅ‚äõ

ùõº =0

hùëèùëñùëõ[ ùëó ] [ùõº]i

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

A Separation Logic for Negative Dependence

57:59

For the inner-most loop (1.2.1), we apply the same technique as for loop (1.2). Since loop (1.2) has a
randomized guard, ùëò is a random variable and loop (1.2.1) also has a randomized guard. However,
under the conditioning, we may assume that ùëò is deterministic and apply Loop on loop (1.2.1) with
the following invariant:

ùëò‚äõ

ùõº =0

hùëêùë° [ùõº]i ‚äõ

hùëêùë° [ùëò]i ‚äõ

ùëÅ‚äõ

ùõº =ùëò

hùëèùëñùëõ[ ùëó ] [ùõº]i

‚äõ

ùëÅ‚äõ

ùõº =ùëò+1

hùëêùë° [ùõº]i ‚àß (¬¨(ùëò < ùëÅ ) ‚Üí ùëò ‚àº ùëÅ )

¬™
¬Æ
Like in earlier examples, we can establish this invariant using the negative dependence frame rule
since ùëêùë° [ùëõ] + ùëèùëñùëõ[ ùëó ] [ùëõ] is monotone. Thus at exit of loop (1.2.1), we have:
¬¨

¬´

¬©

ùëÅ‚äõ

ùõº =0

hùëêùë° [ùõº]i

Next, three applications of the assignment rule RAssn give:

ùëÅ‚äõ

ùõº =0

hùëêùë° [ùõº]i ‚àß ùëõ ‚àº 0 ‚àß ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ] ‚àº 0 ‚àß ùëíùëöùëùùë°ùë¶ ‚àº ùëñùë†ùëçùëíùëüùëú (ùëêùë°)

The function ùëñùë†ùëçùëíùëüùëú (ùë£) takes a vector of numbers ùë£, and returns a vector where each index ùëñ 1 if
ùë£ [ùëñ] is zero, else it holds 0. This is an antitone function: it is non-increasing in its argument. Thus,
the monotone mapping axiom (Mono-Map) gives:

Then, a standard loop invariant for loop (1.3) gives:

ùëÅ‚äõ

ùõº =0

hùëíùëöùëùùë°ùë¶ [ùõº]i

ùëÅ‚äõ

ùõº =0

hùëíùëöùëùùë°ùë¶ [ùõº]i ‚àß ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ] ‚àº

ùëíùëöùëùùë°ùë¶ [ùõº]

ùëÅ

√ïùõº =0

Now, we are in position to apply the negative association ChernoÔ¨Ä bound (NA-ChernoÔ¨Ä), giving
the judgment:

ùëêùë° [ùõº] ‚àº ùúè (ùõº)} ùëèùëúùëëùë¶ {Pr[ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ] < E[ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ]] ‚àí ùëá (ùúåùëíùëöùëùùë° ùë¶, ùëÅ )] ‚â§ ùúåùëíùëöùëùùë° ùë¶}

ùëÅ

{

√õùõº =0

where ùëèùëúùëëùë¶ is the body of loop (1). However, we are not yet done. We want to combine these
judgments‚Äîone for each map ùúé : [ùëÅ ] ‚Üí [ùëÅ ]‚Äîusing the randomized case analysis rule RCase We
can take the trivial pre-condition ùúô = ‚ä§, and the case condition:

ùëÅ

ùúÇ =

ùëêùë° [ùõº] ‚àº ùúè (ùõº)

√õùõº =0

Since ùúÇ asserts that the equality holds with probability 1, it is closed under conditioning. However,
our post-condition has a problem: it mentions the expected value E[ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ]], which may not
be preserved under mixtures, so the entire assertion is not CM. However, translating an argument
by Becchetti et al. [2019, Lemma 2] into our logic gives:

ùëêùë° [ùõº] ‚àº ùúè (ùõº)} ùëèùëúùëëùë¶ {E[ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ]] ‚â• ùëÅ /15}

ùëÅ

{

√õùõº =0

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

 
57:60

Jialu Bao, Marco Gaboardi, Justin Hsu, and Joseph Tassarotti

assuming that ùëÅ ‚â• 2. The argument makes use of basic properties of expected values and the
exponential function; we omit the details. Thus, we have:

ùëÅ

{

ùëêùë° [ùõº] ‚àº ùúè (ùõº)} ùëèùëúùëëùë¶ {Pr[ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ] < ùëÅ /15 ‚àí ùëá (ùúåùëíùëöùëùùë° ùë¶, ùëÅ )] ‚â§ ùúåùëíùëöùëùùë° ùë¶}

√õùõº =0

and the post-condition is now a CM assertion. Applying RCase, we have:

ùëÅ

{

ùëêùë° [ùõº] ‚àº ùëÅ } ùëèùëúùëëùë¶ {Pr[ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ] < ùëÅ /15 ‚àí ùëá (ùúåùëíùëöùëùùë° ùë¶, ùëÅ )] ‚â§ ùúåùëíùëöùëùùë° ùë¶}

√ïùõº =0

Recalling that we wanted the following invariant for loop (1):

ùëü

ùëÅ

Pr

(ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùõΩ] < ùëáùëíùëöùëùùë° ùë¶ )

‚â§ ùëü ¬∑ ùúåùëíùëöùëùùë° ùë¶ ‚àß

ùëêùë° [ùõº] ‚àº ùëÅ

Ô£π
Ô£∫
Ô£∫
we can use the rule of constancy Const and the assignment rule RAssn to preserve the Ô¨Årst con-
Ô£∫
Ô£∫
junct to show:
Ô£ª

Ô£Æ
√úùõΩ=0
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞

√ïùõº =0

ùëü ‚àí1

Pr

(ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùõΩ] < ùëáùëíùëöùëùùë° ùë¶)

‚â§ (ùëü ‚àí 1) ¬∑ ùúåùëíùëöùëùùë° ùë¶

√úùõΩ=0

Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

at the end of the body of loop (1). Combined with the probability bound for ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùëü ], an ap-
plication of the union bound (UnionBd) establishes the invariant for loop (1). Putting everything
together, we have:

{ùëÅ ‚â• 2 ‚àß

ùëÅ

√ïùõº =0

ùëêùë° [ùõº] ‚àº ùëÅ} RepeatBIB {Pr

analogous to Becchetti et al. [2019, Lemma 1 and 2].

Ô£Æ
√úùõΩ=0
Ô£Ø
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞

F.5 Axioms for Examples

ùëÖ

(ùëíùëöùëùùë°ùë¶ùê∂ùë° [ùõΩ] < ùëÅ /15 ‚àí ùëá (ùúåùëíùëöùëùùë° ùë¶, ùëÅ ))

‚â§ ùëÖ ¬∑ ùúåùëíùëöùëùùë° ùë¶}

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

For completeness, we present the probability-related axioms that we need for the examples. For
simplicity we present the axioms in binary form, though most extend directly to big operations.

‚Ä¢ Linearity of expectation. Let ùëí, ùëì be bounded expressions.

|= E[ùõº ¬∑ ùëí + ùõΩ ¬∑ ùëì ] ‚àº ùõº ¬∑ E[ùëí] + ùõΩ ¬∑ E[ùëì ]

(LinExp)

‚Ä¢ Union bound. Let ùëíùë£1, ùëíùë£2 ‚àà EV,

‚Ä¢ Permutation marginal. Let ùë• be an array variable, and let ùëÜ be a Ô¨Ånite set.

|= Pr[ùëíùë£1 ‚à® ùëíùë£2] ‚â§ Pr[ùëíùë£1] + ùëÉùëü [ùëíùë£2]

(UnionBd)

|= PermùëÜ hùë•i ‚Üí UùëÜ hùë• [ùõº]i
‚Ä¢ Expectation Indicator. Let ùëí be a 0/1 valued expression,

|= E[ùëí] ‚àº Pr[ùëí = 1]

‚Ä¢ Bernoulli variables probabilities. Let ùëí be an expression,

|= Bernùëù hùëíi ‚Üí Pr[ùëí = 1] = ùëù

‚Ä¢ Probability of uniform. Let ùëÜ be a Ô¨Ånite set.

|= Pr[UùëÜ hùë•i = ùõº] ‚àº 1/|ùëÜ |

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

(PermMarg)

(ExpectInd)

(BernProb)

(ProbUnif)

A Separation Logic for Negative Dependence

57:61

‚Ä¢ Bijection uniform. Let ùëÜ be a Ô¨Ånite set, and let ùëì : ùëÜ ‚Üí ùëÜ be a bijection.

|= UùëÜ hùë•i ‚Üí UùëÜ hùëì (ùë•)i

‚Ä¢ One-hot marginal. Let ùë• be an array variable.

|= OHùëÜ hùë•i ‚Üí UùëÜ hùë• [ùõº]i

‚Ä¢ Independent product one-hot.

(BijectUnif)

(OHMarg)

|= OH[ùëÄ ] hùë•i ‚àó OH[ùëÅ ] hùë¶i ‚Üí OH[ùëÄ ]√ó[ùëÅ ] hùë• ‚ä§ ¬∑ ùë¶i

(IndProdOH)

‚Ä¢ Independent map. Let ùë• be an array variable of length ùëÅ .

ùõº =0
‚Ä¢ Deterministic independent. Let ùë• be a variable.

ùõº =0

ùëÅ‚àó

|=

hùë• [ùõº]i ‚Üí

hùëì (ùë• [ùõº])i

ùëÅ‚àó

|= Detmhùë•i ‚Üí hùë•i ‚àó hùëíi

‚Ä¢ Events happen only if they have probability one. Let ùëíùë£ ‚àà EV,

|= ùëíùë£ = 1 ‚Üí Pr(ùëíùë£) = 1

(IndMap)

(DetInd)

(ProbOne)

‚Ä¢ Uniform sampling from a population. We represent a population as a bit-vector, where each
entry is an individual and 1 indicates they have some feature and 0 indicates not. Then,
if we uniformly sample from the population, the probability of getting a one is equal to
population-level ratio of ones, regardless how they are distributed in the population. Let
ùëÅ ‚â• ùêΩ be constants or logical variables, ùëè be an array variable of length ùëÅ , and ùë•, ‚Ñéùëñùë° be
variables:

|=

bv(ùëè, ùêΩ , ùëÅ ) ‚àó U[ùëÅ ] hùë•i

‚àß ‚Ñéùëñùë° ‚àº ùëè [ùë•]

‚Üí Bern‚Ñéùëñùë° h

ùêΩ
ùëÅ

i ‚àó

ùëÅ

ùëè [ùõΩ] = ùêΩ

.

(UniformSamp)

(cid:0)(cid:0)

(cid:1)
‚Ä¢ Independent product probabilities. Let ùëíùë£1, ùëíùë£2 ‚àà EV , ùêΩ , ùêæ be two real numbers,

(cid:1)

|= Pr[ùëíùë£1] ‚â§ ùêΩ ‚àó Pr[ùëíùë£2] ‚â§ ùêæ ‚Üí Pr[ùëíùë£1 ‚àß ùëíùë£2] ‚â§ ùêΩ ¬∑ ùêæ.

¬´

(IndepProb)

√ïùõΩ=0
¬©

¬™
¬Æ
¬¨

‚Ä¢ Equal probabilities. Let ùëè1, ùëè2 be two boolean expressions. Recall that ùëè1, ùëè2 ‚àà EV too.
|= ùëè1 ‚àº ùëè2 ‚Üí Pr[ùëè1] = Pr[ùëè2]

(EqualProb)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 57. Publication date: January 2022.

 
