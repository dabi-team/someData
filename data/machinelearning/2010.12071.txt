0
2
0
2

t
c
O
2
2

]
L
P
.
s
c
[

1
v
1
7
0
2
1
.
0
1
0
2
:
v
i
X
r
a

Translating Recursive Probabilistic Programs
to Factor Graph Grammars

DAVID CHIANG, University of Notre Dame, USA
CHUNG-CHIEH SHAN, Indiana University, USA

It is natural for probabilistic programs to use conditionals to express alternative substructures in models, and
loops (recursion) to express repeated substructures in models. Thus, probabilistic programs with conditionals
and recursion motivate ongoing interest in efficient and general inference. A factor graph grammar (FGG)
generates a set of factor graphs that do not all need to be enumerated in order to perform inference. We
provide a semantics-preserving translation from first-order probabilistic programs with conditionals and
recursion to FGGs.

1 INTRODUCTION
Probabilistic models often contain repeated substructures, such as the time steps of a hidden
Markov model, as well as alternative substructures, such as different grammar productions that
generate the same string. Loops (recursion) and conditionals naturally and compactly represent
such substructures in probabilistic programming. However, efficient and general inference on these
representations remains a longstanding challenge.

Factor graph grammars (FGGs) [Chiang and Riley 2020] are hyperedge replacement grammars
(HRGs) [Bauderon and Courcelle 1987; Drewes et al. 1997; Habel and Kreowski 1987] for generating
sets of factor graphs. They have recently been proposed as a unified formalism that can describe
both repeated and alternative substructures. Moreover, it turns out that inference can be performed
on an FGG (by variable elimination) without enumerating all the factor graphs generated.

This paper explores the relationship of this formalism to probabilistic programming languages
(PPLs). When random variables are limited to finite domains, what kinds of models can and canâ€™t be
expressed using FGGs? We answer this question by defining a simple PPL and giving a translation
from this language to FGGs. This translation extends that of van de Meent et al. [2018], which
translates a PPL without higher-order functions or recursion to a factor graph. Our source language
does allow recursion, and our translation uses the added power of FGGs to handle recursion and
conditionals cleanly.

2 DEFINITIONS
To establish notation, we briefly define hypergraphs, factor graphs, HRGs, and finally FGGs.

Fix a finite set ğ¿ of edge labels, and a function arity : ğ¿ â†’ Zâ‰¥0.
Definition 1. A (hyper)graph is a tuple (ğ‘‰ , ğ¸, lab, att, ext), where

â€¢ ğ‘‰ names a finite set of nodes.
â€¢ ğ¸ names a finite set of (hyper)edges.
â€¢ lab : ğ¸ â†’ ğ¿ assigns to each edge a label.
â€¢ att : ğ¸ â†’ ğ‘‰ âˆ— assigns to each edge ğ‘’ a sequence of arity (lab (ğ‘’)) attachment nodes.
â€¢ ext âˆˆ ğ‘‰ âˆ— is a sequence of zero or more external nodes.

Definition 2. A factor graph [Kschischang et al. 2001] is a hypergraph (ğ‘‰ , ğ¸, lab, att, ext) together
with a set ğ· and a function ğ¹ :

â€¢ ğ· is the set of possible values that each node can take. For simplicity, we use a single ğ· for

all nodes, unlike in the previous definition [Chiang and Riley 2020].

â€¢ ğ¹ maps each edge label â„“ to a function ğ¹ (â„“) : ğ· arity (â„“) â†’ Râ‰¥0. For brevity, we write ğ¹ (ğ‘’) for

ğ¹ (lab (ğ‘’)). An edge ğ‘’ together with its function ğ¹ (ğ‘’) is called a factor.

1

 
 
 
 
 
 
Example 3. Below is a factor graph for trees of a certain shape generated by a PCFG with start
symbol ğ‘†. Variables N range over nonterminal symbols and W over terminal symbols.

David Chiang and Chung-chieh Shan

ğ‘ (N2 â†’ W4)

N2

W4

N1 = ğ‘†

N1

ğ‘ (N1 â†’ N2N3)

N3

ğ‘ (N3 â†’ W5)

W5

We draw a node as a circle with its name inside, and an edge as a square with lines (called
tentacles) to its attachment nodes. To reduce clutter, we donâ€™t show the ordering of tentacles. We
draw a factor ğ‘’ as a small square with ğ¹ (ğ‘’) next to it, as an expression in terms of its attachment
nodesâ€™ names. A Boolean expression has value 1 if true and 0 if false.

Definition 4. An assignment of a factor graph ğ» = (ğ‘‰ , ğ¸, lab, att, ext) is a mapping ğœ‰ : ğ‘‰ â†’ ğ· from
nodes to values. We write Îğ» for the set of all assignments of ğ» . The weight of an assignment ğœ‰ is

ğ‘¤ğ» (ğœ‰) =

(cid:214)

ğ‘’ âˆˆğ¸

ğ¹ (ğ‘’) (cid:0)ğœ‰ (att (ğ‘’)1), . . . , ğœ‰ (att (ğ‘’) |att (ğ‘’) |)(cid:1).

We also define the marginal distribution over assignments to external nodes, ğœ‰ : ext â†’ ğ·:

ğ‘¤ext (ğœ‰) =

âˆ‘ï¸

ğ‘¤ğ» (ğœ‰ â€²).

ğœ‰ â€² âˆˆÎğ»
ğœ‰ â€² |ext =ğœ‰

(1)

(2)

Definition 5. A hyperedge replacement graph grammar (HRG) is a tuple (ğ‘ ,ğ‘‡ , ğ‘ƒ, ğ‘†), where

â€¢ ğ‘ âŠ† ğ¿ is a finite set of nonterminal symbols.
â€¢ ğ‘‡ âŠ† ğ¿ is a finite set of terminal symbols, disjoint from ğ‘ .
â€¢ ğ‘ƒ is a finite set of productions (or rules) of the form (ğ‘‹ â†’ ğ‘…), where ğ‘‹ âˆˆ ğ‘ , and ğ‘… is a

hypergraph with edge labels from ğ‘ âˆª ğ‘‡ and exactly arity (ğ‘‹ ) external nodes.

â€¢ ğ‘† âˆˆ ğ‘ is a distinguished start nonterminal symbol.

Most definitions require arity (ğ‘†) = 0, including the previous definition of FGGs [Chiang and
Riley 2020], but here we relax this requirement, to allow the graphs generated by an HRG to have
external nodes.

Definition 6. If ğº is an HRG and ğ‘‹ is a nonterminal symbol, define the set of ğ‘‹ -derivation trees
of ğº, Dğº (ğ‘‹ ), to be the smallest set containing all pairs (ğ‘…, ğ‘ ) such that (ğ‘‹ â†’ ğ‘…) âˆˆ ğº and ğ‘  is
a mapping from each nonterminal edge ğ‘’ in ğ‘… to a lab (ğ‘’)-derivation tree of ğº. Define the set of
derivation trees of ğº to be Dğº = Dğº (ğ‘†).

An ğ‘‹ -derivation tree ğ‘‡ = (ğ‘…, ğ‘ ) yields a graph with the same arity (ğ‘‹ ) external nodes as ğ‘…. We
define this graph by induction on ğ‘‡ as follows. For each ğ‘’ âˆˆ ğ‘…, let ğ»ğ‘’ be the graph yielded by ğ‘  (ğ‘’).
Replace ğ‘’ with ğ»ğ‘’ , identifying each attachment node att (ğ‘’)ğ‘– of ğ‘’ with the ğ‘–th external node of ğ»ğ‘’ ;
the resulting node is external iff att (ğ‘’)ğ‘– was.

Definition 7. An HRG for factor graphs, or a factor graph grammar (FGG) for short, is an HRG
together with a set ğ· and and a function ğ¹ , as in the definition of factor graphs (Definition 2),
except that ğ¹ is defined on terminal edge labels only.

Example 8. Below is an FGG for derivations of a PCFG in Chomsky normal form. The start symbol
of the FGG is Sâ€².

2

Translating Recursive Probabilistic Programs to Factor Graph Grammars

N1 = ğ‘†

Sâ€² âˆ’â†’

N1

X

N1

X âˆ’â†’ N1

ğ‘ (N1 â†’ N2N3)

N1

X âˆ’â†’ N1

W2

ğ‘ (N1 â†’ W2)

N2

X

This FGG generates an infinite number of factor graphs, including the one in Example 3, whose

derivation tree looks like:

N3

X

N1

X

N1

N2

X

N3

X

N1

N1

W2

W2

We draw external nodes in black. We draw an edge with nonterminal label ğ‘‹ as a square with
ğ‘‹ inside. Although the left-hand side is just a nonterminal symbol, we draw it like an edge, with
replicas of the external nodes as attachment nodes.

The graphs generated by an FGG can be viewed, together with ğ· and ğ¹ , as factor graphs, each
of which defines a distribution over assignments. We also want each nonterminal of the FGG to be
thought of as a distribution over derivation trees and assignments; for present purposes, we only
consider the marginal distribution over assignments to external nodes:
Definition 9. An assignment of a nonterminal edge label ğ‘‹ is a sequence ğœ‰ âˆˆ ğ· arity (ğ‘‹ ) of values.
The weight of an assignment ğœ‰ is

ğ‘¤ğ‘‹ (ğœ‰) =

âˆ‘ï¸

ğ‘¤extğ‘‡ (ğœ‰),

ğ‘‡ âˆˆD (ğ‘‹ )

(3)

where extğ‘‡ is the list of external nodes of the graph yielded by ğ‘‡ .

To query some variables, we can make them external in the generated graphs (because ğ‘† can
have nonzero arity), and ğ‘¤ğ‘† is their joint distribution. Chiang and Riley [2020] discuss how to
compute ğ‘¤ğ‘† ; in particular, if all variables have finite domain, then ğ‘¤ğ‘† can be computed in time
linear in the size of the FGG and exponential in the maximum treewidth of its right-hand sides.

3 A SIMPLE PROBABILISTIC PROGRAMMING LANGUAGE
The source language of our translation has the following syntax. Because the language is first-order,
variable names ğ‘¥ are distinct from function names ğ‘“ .

Programs

Expressions

ğ‘ ::= ğ‘’
ğ‘’ ::= ğ‘¥ |
|

| fun ğ‘“ (ğ‘¥1, . . . , ğ‘¥ğ‘›) = ğ‘’; ğ‘

let ğ‘¥1 = ğ‘’2 in ğ‘’3
if ğ‘’1 then ğ‘’2 else ğ‘’3

ğ‘“ (ğ‘’1, . . . , ğ‘’ğ‘›)

|
| case ğ‘’1 of inl(ğ‘¥2) â‡’ ğ‘’2 | inr (ğ‘¥3) â‡’ ğ‘’3

| sample ğ‘’1

| observe ğ‘’1 â† ğ‘’2

We assume a number of built-in functions and constants: =, â‰ , true, false, pairing, fst, snd, inl, inr,
unit. Boolean operations and and or can be treated as built-in functions, or if short-circuiting is
desired, defined as syntactic sugar:

ğ‘’1 and ğ‘’2 â‰¡ if ğ‘’1 then ğ‘’2 else false

ğ‘’1 or ğ‘’2 â‰¡ if ğ‘’1 then true else ğ‘’2

The only probabilistic constructs are sample and observe. Generatively speaking, sample ğ‘’1
evaluates ğ‘’1 to a distribution and then nondeterministically samples from the distribution, whereas
observe ğ‘’1 â† ğ‘’2 evaluates ğ‘’2 to a distribution and then multiplies the weight of the current branch

3

David Chiang and Chung-chieh Shan

of computation by the density of the distribution at the value of ğ‘’1. Other constructs can be defined
as syntactic sugar in terms of observe, by setting ğ‘’2 to a common distribution such as Bernoulli
or exponential. In particular, a fail expression unconditionally terminates the current branch of
computation, multiplying its weight by zero.

We assume that ğ· is countable, and define the denotations of the language in a relatively standard
way. Without recursion, we would directly define the denotation of each expression ğ‘’ to be an s-
finite kernel from environments to values [Staton 2017], where an environment is a tuple that maps
each free variable of ğ‘’ to its value. With recursion, we have to first define this denotation relative
to an interpretation of each function ğ‘“ as itself an s-finite kernel from environments to values,
where an environment is a tuple that maps each argument of ğ‘“ to its value. Thus, the denotation of
a programâ€™s function definitions maps an interpretation of each function to an interpretation of
each function. Finally, we take the least fixed point of this monotonic map [Kozen 1981].

4 COMPILING PROBABILISTIC PROGRAMS TO FGGS
Every subexpression ğ‘’ or function ğ‘“ of a program can be translated into an HRG production (or
two) whose left-hand-side nonterminal is ğ‘’ or ğ‘“ , respectively. If the subexpression ğ‘’ occurs in an
environment with ğ‘˜ bound variables, or if the function ğ‘“ takes ğ‘˜ arguments, then we translate it
to a nonterminal with arity ğ‘˜ + 1. The external nodes are ğ‘¥1, . . . , ğ‘¥ğ‘˜ for the variables and ğ‘£ for the
result. Such a nonterminal is pictured below.

ğ‘¥ğ‘–

ğ‘’

ğ‘£

ğ‘– = 1, . . . , ğ‘˜

We use plate notation to depict multiple nodes. Unless otherwise indicated, each plate has an
instance for each ğ‘– = 1, . . . , ğ‘˜. We stress, however, that plates are only meta-notation; as will be
clear in the example below, actual FGG rules do not use plates.

Our translation preserves semantics in the sense that the denotation of a subexpression ğ‘’ or
function ğ‘“ , regarded as a weight function on (ğ‘˜ + 1)-tuples, is equal to the weight function ğ‘¤ğ‘’
or ğ‘¤ ğ‘“ of its translation (Definition 9).

4.1 Random variables
The sample and observe expressions are translated by turning the density of the distribution into
a factor:

ğ‘¥ğ‘–

sample ğ‘’1

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

ğ‘¥ğ‘–

observe ğ‘’1 â† ğ‘’2

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

ğ‘’1

ğ‘’1

ğ‘’2

ğ‘£1

ğ‘£2

ğ‘£1 (ğ‘£)

ğ‘£2 (ğ‘£)

ğ‘£

ğ‘£

4.2 Conditionals and disjoint unions
A conditional expression translates to two productions, one for the case where the condition is true
and one for the case where the condition is false:

ğ‘¥ğ‘–

if ğ‘’1 then ğ‘’2 else ğ‘’3

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

4

ğ‘£1 = true

ğ‘’1

ğ‘’2

ğ‘£1

ğ‘£

Translating Recursive Probabilistic Programs to Factor Graph Grammars

ğ‘¥ğ‘–

if ğ‘’1 then ğ‘’2 else ğ‘’3

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

ğ‘£1 = false

ğ‘’1

ğ‘’3

ğ‘£1

ğ‘£

This is the only place a left-hand side has more than one right-hand side (along with the related
translation of case). So the FGG has one derivation tree for each possible code path.

This translation avoids a problem that van de Meent et al. [2018, Section 3.1] encounter when
translating conditional expressions to factor graphs. In a factor graph, both arms of the conditional
must be translated, and every assignment to the factor graph must assign values to variables in both
arms, even though only one can be active at a time. Their translation requires some complicated
machinery to work around this problem. But our translation to an FGG does not have this problem,
because it generates a different graph for each arm.

The translation of case is similar to if:

ğ‘¥ğ‘–

ğ‘¥ğ‘–

case ğ‘’1 of inl(ğ‘¦2) â‡’ ğ‘’2
| inr (ğ‘¦3) â‡’ ğ‘’3

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

case ğ‘’1 of inl(ğ‘¦2) â‡’ ğ‘’2
| inr (ğ‘¦3) â‡’ ğ‘’3

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

ğ‘’1

ğ‘£1

ğ‘£1 = inl (ğ‘¦2)

ğ‘’1

ğ‘£1

ğ‘’2

ğ‘’3

ğ‘£

ğ‘£

ğ‘¦2

ğ‘¦3

ğ‘£1 = inr (ğ‘¦3)

4.3 Functions and local variables
A function definition fun ğ‘“ (ğ‘¥1, . . . , ğ‘¥ğ‘›) = ğ‘’ becomes the production:

ğ‘¥ğ‘–

ğ‘“

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

ğ‘’

ğ‘£

Inside the function body, variables evaluate to their value in the environment:

ğ‘¥ğ‘–

ğ‘¥ ğ‘—

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

ğ‘¥ ğ‘—

ğ‘– â‰  ğ‘—

ğ‘£

ğ‘£ = ğ‘¥ ğ‘—

And function calls become:

ğ‘¥ğ‘–

ğ‘“ (ğ‘’1, . . . , ğ‘’ğ‘›)

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

ğ‘’ ğ‘—

ğ‘£ ğ‘—

ğ‘“

ğ‘£

ğ‘— = 1, . . . , ğ‘›

Unlike in the translation of van de Meent et al. [2018], the function can be recursive: the definition
of ğ‘“ can include calls to ğ‘“ . Infinite recursion is disallowed because the definition of FGG doesnâ€™t
allow infinite-sized derivation trees. But a program can have an infinite number of branches of
computation, in which the depth of recursion is unbounded. The resulting FGG has an infinite
number of derivation trees, and the inference algorithm does sum over, or at least approximate the
sum over, all of them.

5

David Chiang and Chung-chieh Shan

The translation of let is:

ğ‘¥ğ‘–

let ğ‘¥ = ğ‘’1 in ğ‘’2

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

ğ‘’2

ğ‘£

ğ‘’1

ğ‘¥

4.4 Built-in functions and constants
Built-in functions and constants

ğ‘ ::= = | â‰  |

true |

false |

(, )

|

fst

|

snd |

inl

|

inr

| unit

can be translated into FGG rules that give rise to terminal edges:

ğ‘¥ğ‘–

ğ‘ (ğ‘’1, . . . , ğ‘’ğ‘›)

ğ‘£ âˆ’â†’ ğ‘¥ğ‘–

ğ‘’ ğ‘—

ğ‘£ ğ‘—

ğ‘— = 1, . . . , ğ‘›

ğ‘£

ğ‘£ = ğ‘ (ğ‘£1, . . . , ğ‘£ğ‘›)

4.5 Programs
Finally, if ğ‘’ is the top-level expression at the end of a program (ğ‘), create the rule

ğ‘†
where ğ‘† is the start symbol of the FGG.

ğ‘£ âˆ’â†’ ğ‘’

ğ‘£

5 EXAMPLE: PCFG
The code in Figure 1a nondeterministically samples a string from a PCFG in Chomsky normal form.
If ğ‘‹ is a left-hand side, let ğ‘ [ğ‘‹ ] be a distribution over right-hand sides, which can be inl(ğ‘) for a
single terminal symbol ğ‘ or inr (ğ‘Œ, ğ‘ ) for two nonterminals ğ‘Œ and ğ‘ .

This translates to the FGG in Figure 2; note the similarity to Example 8. We have made a few

optimizations for greater readability:

â€¢ We â€œinlineâ€ all rules except those for if, case, and functions.
â€¢ Consecutive terminal edges arising from built-in functions and constants are composed into

â€¢ In the translation of variables, the factor ğ‘£ = ğ‘¥ ğ‘— can usually be contracted, merging the nodes

a single terminal edge.

for ğ‘¥ ğ‘— and ğ‘£.

â€¢ Rules that must have zero weight are omitted.
Next, we modify this program to take a string ğ‘¤ as input and constrain the derivations to those
that yield ğ‘¤, shown in Figure 1b. This translates to the FGG in Figure 3. Computing ğ‘¤ğ‘† on this
grammar [Chiang and Riley 2020] is equivalent to CKY. In the last rule, the nodes ğ‘¤, ğ‘¤ â€², and ğ‘£25
range over suffixes of the input string, so summing over assignments to the right-hand side takes
ğ‘‚ (ğ‘›3) time, just as in CKY. Unlike a typical implementation of CKY, however, the programs in
Figure 1 can be easily modified to efficiently handle, say, the intersection of a PCFG with a regular
language [Hale 2004; Lang 1988], or a PCFG whose nonterminals are structured as tuples [Collins
1997; Klein and Manning 2003].

6 CONCLUSION
The above translation has been implemented, but only outputs LATEX code to produce the diagrams
shown in this paper. We plan to properly implement the translation to output an FGG, but first we
need to implement FGGs and inference algorithms for them.

The translation only produces FGGs in which each rule has exactly one output external node. As
far as FGGs are concerned, a rule can have more than one output external node; the nonterminal

6

Translating Recursive Probabilistic Programs to Factor Graph Grammars

fun d(x) =

case sample p[x] of

inl a =>
unit
| inr yz =>

let u = d(fst(yz)) in
d(snd(yz));

d(S)

fun d(w, x) =

case sample p[x] of

inl a =>

if w != nil and car(w) = a then

cdr(w)

else

fail
| inr yz =>

let w' = d(w, fst(yz)) in
d(w', snd(yz));

if d(w, S) = nil then unit else fail

(a)

(b)

Fig. 1. Code for (a) all derivations of a PCFG in Chomsky normal form; (b) all derivations yielding a given
string ğ‘¤.

ğ‘†

ğ‘‘

ğ‘¥

ğ‘£1 âˆ’â†’

ğ‘£2

ğ‘‘

ğ‘£1

ğ‘£2 = ğ‘†

ğ‘£7 âˆ’â†’ ğ‘¥

ğ‘£5

ğ‘£4

ğ‘

ğ‘£7

ğ‘£5 = ğ‘ [ğ‘¥ ]

ğ‘£5 (ğ‘£4)

ğ‘£4 = inl (ğ‘)

ğ‘£7 = unit

ğ‘¥

ğ‘‘

ğ‘£12 âˆ’â†’ ğ‘¥

ğ‘£5

ğ‘£4

ğ‘¦ğ‘§

ğ‘£5 = ğ‘ [ğ‘¥ ]

ğ‘£5 (ğ‘£4)

ğ‘£4 = inr (ğ‘¦ğ‘§)

ğ‘£13

ğ‘£13 = snd (ğ‘¦ğ‘§)

ğ‘£10 = fst (ğ‘¦ğ‘§)

ğ‘£10

ğ‘‘

ğ‘‘

ğ‘¢

ğ‘£12

Fig. 2. Translation of the program in Figure 1a.

ğ‘†

ğ‘£6 âˆ’â†’

ğ‘£4 = ğ‘¤

ğ‘£5 = ğ‘†

ğ‘£6 = unit

ğ‘¤

ğ‘‘

ğ‘£17 âˆ’â†’

ğ‘¥

ğ‘£10 = ğ‘ [ğ‘¥ ]

ğ‘£4

ğ‘£5

ğ‘£6

ğ‘£10

ğ‘£17

ğ‘£17 = cdr (ğ‘¤)

ğ‘‘

ğ‘£3

ğ‘£2

ğ‘£2 = ğ‘£3 = nil

ğ‘£2 = true

ğ‘£9

ğ‘£10 (ğ‘£9)

ğ‘£9 = inl (ğ‘)

ğ‘£13

ğ‘
ğ‘£13 = ğ‘¤ â‰  nil âˆ§
car (ğ‘¤) = ğ‘

ğ‘£13 = true

ğ‘‘

ğ‘£25 âˆ’â†’

ğ‘¤

ğ‘¥

ğ‘£23 = fst (ğ‘¦ğ‘§)

ğ‘£23

ğ‘‘

ğ‘¤ â€²

ğ‘£10

ğ‘£9

ğ‘¦ğ‘§

ğ‘‘

ğ‘£25

ğ‘£10 = ğ‘ [ğ‘¥ ]

ğ‘£10 (ğ‘£9)

ğ‘£9 = inr (ğ‘¦ğ‘§)

ğ‘£27

ğ‘£27 = snd (ğ‘¦ğ‘§)

ğ‘¤

ğ‘¥

ğ‘¤

ğ‘¥

Fig. 3. Translation of the program in Figure 1b.

7

David Chiang and Chung-chieh Shan

edge that â€œcallsâ€ it could even have an input node that depends on one of its output nodes. What
kinds of functions would translate into such rules?

ACKNOWLEDGMENTS
This material is based upon work supported by the National Science Foundation under Grant
Nos. 2019291 and 2019266. Any opinions, findings, and conclusions or recommendations expressed
in this material are those of the authors and do not necessarily reflect the views of the National
Science Foundation.

REFERENCES
Michel Bauderon and Bruno Courcelle. 1987. Graph expressions and graph rewriting. Mathematical Systems Theory 20

(1987), 83â€“127.

David Chiang and Darcey Riley. 2020. Factor Graph Grammars. In Proc. Conference on Neural Information Processing Systems.
Michael Collins. 1997. Three Generative, Lexicalised Models for Statistical Parsing. In Proc. Annual Meeting of the Association
for Computational Linguistics and European Chapter of the Association for Computational Linguistics (ACL-EACL). 16â€“23.
Frank Drewes, Hans-JÃ¶rg Kreowski, and Annegret Habel. 1997. Hyperedge Replacement Graph Grammars. In Handbook of

Graph Grammars and Computing by Graph Transformation, Grzegorz Rozenberg (Ed.). World Scientific, 95â€“162.

Annegret Habel and Hans-JÃ¶rg Kreowski. 1987. May we introduce to you: Hyperedge replacement. In Proc. Third International
Workshop on Graph Grammars and Their Application to Computer Science (Lecture Notes in Computer Science, Vol. 291).
Springer, 15â€“26.

John Hale. 2004. The Information-Processing Difficulty of Incremental Parsing. In Proceedings of the Workshop on Incremental

Parsing: Bringing Engineering and Cognition Together. 58â€“65.

Dan Klein and Christopher D. Manning. 2003. Accurate Unlexicalized Parsing. In Proc. Annual Meeting of the Association for

Computation Linguistics. 423â€“430.

Dexter Kozen. 1981. Semantics of Probabilistic Programs. J. Comput. System Sci. 22, 3 (1981), 328â€“350.
Frank R. Kschischang, Brendan J. Frey, and Hans-Andrea Loeliger. 2001. Factor Graphs and the Sum-Product Algorithm.

IEEE Trans. Information Theory 47, 2 (2001), 498â€“519.

Bernard Lang. 1988. Parsing Incomplete Sentences. In Proc. International Conference on Computational Linguistics (COLING).

365â€“371.

Sam Staton. 2017. Commutative Semantics for Probabilistic Programming. In Programming Languages and Systems:
Proceedings of ESOP 2017, 26th European Symposium on Programming (Lecture Notes in Computer Science, 10201), Yang
Hongseok (Ed.). Springer, 855â€“879.

Jan-Willem van de Meent, Brooks Paige, Hongseok Yang, and Frank Wood. 2018. An Introduction to Probabilistic Program-

ming. arXiv:1809.10756.

8

