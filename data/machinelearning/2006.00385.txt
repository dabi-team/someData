0
2
0
2

y
a
M
0
3

]
E
S
.
s
c
[

1
v
5
8
3
0
0
.
6
0
0
2
:
v
i
X
r
a

An Empirical Study of Software Exceptions in the Field using
Search Logs

Foyzul Hassan
foyzul.hassan@my.utsa.edu
University of Texas
San Antonio, TX, USA

Chetan Bansal
chetanb@microsoft.com
Microsoft Research
Redmond, WA, USA

Nachiappan Nagappan
nachin@microsoft.com
Microsoft Research
Redmond, WA, USA

Thomas Zimmermann
tzimmer@microsoft.com
Microsoft Research
Redmond, WA, USA

Ahmed Hassan Awadallah
hassanam@microsoft.com
Microsoft Research
Redmond, WA, USA

ABSTRACT
Software engineers spend a substantial amount of time using Web
search to accomplish software engineering tasks. Such search tasks
include ﬁnding code snippets, API documentation, seeking help
with debugging, etc. While debugging a bug or crash, one of the
common practices of software engineers is to search for informa-
tion about the associated error or exception traces on the internet.

In this paper, we analyze query logs from a leading commercial
general-purpose search engine (GPSE) such as Google, Yahoo! or
Bing to carry out a large scale study of software exceptions. To
the best of our knowledge, this is the ﬁrst large scale study to ana-
lyze how Web search is used to ﬁnd information about exceptions.
We analyzed about 1 million exception related search queries from
a random sample of 5 billion web search queries. To extract ex-
ceptions from unstructured query text, we built a novel and high-
performance machine learning model with a F1-score of 0.82. Us-
ing the machine learning model, we extracted exceptions from raw
queries and performed popularity, effort, success, query character-
istic and web domain analysis. We also performed programming
language-speciﬁc analysis to give a better view of the exception
search behavior. These techniques can help improve existing meth-
ods, documentation and tools for exception analysis and prediction.
Further, similar techniques can be applied for APIs, frameworks,
etc.

CCS CONCEPTS
• Software and its engineering; • Information systems → Web
search engines; Query log analysis;

KEYWORDS
software engineering, debugging, web search, machine learning

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
Conference’17, July 2017, Washington, DC, USA
© 2019 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00
https://doi.org/10.1145/nnnnnnn.nnnnnnn

1 INTRODUCTION
With the growing complexity of software systems, use of web search
has become ubiquitous in software engineering. More and more
software engineers are relying on search engines for various tasks,
including ﬁnding code snippets, API documentation, debugging,
and understanding new concepts [49, 60, 66]. Prior research on code
search [10, 18, 64] has shown that software engineers depend heav-
ily on search engines for ﬁnding information. A study of Google
search [60] also identiﬁed that developers use Web search heavily
for code and code-related tasks. Researchers have proposed several
approaches [24, 43] to improve code search. Despite all these ef-
forts, recent study [56] on code-related search behavior identiﬁed
that code search often requires more effort than more general search
intents to ﬁnd a solution. Prior study [56] also identiﬁes that devel-
opers tend to search with error and exception message to ﬁnd solu-
tions, but general-purpose search engines (GPSEs) such as Google,
Yahoo! and Bing are better at locating general code issues compared
to speciﬁc errors or exceptions. Thus, error or exception search
imposes unique challenges for developers to ﬁnd solutions using
GPSEs.

Xin et al. [71] collected Web search logs from 60 developers
and interviewed 12 developers to categorize software engineering
related search tasks. According to the study, learning new topics is
the ﬁrst most popular task while debugging errors and exceptions
is the second most popular task developers accomplish using Web
search. Software engineers heavily rely on Web search to not only
ﬁnd documentation for exceptions but also crowd-sourced informa-
tion from websites like Stack Overﬂow, GitHub, etc. This under-
lines the importance of characterizing exception search behavior to
be able to improve and build new tools for improving exception
debugging using the internet. However, such analysis is non-trivial
and yet to be carried out, which motivates our large-scale study of
exception search analysis.

In this empirical study, we address two key challenges: 1) Ex-
traction of exceptions from unstructured text, and 2) Leveraging
search metadata for characterization of various aspects of exception-
related searches (e.g., popularity, effort, success). We collected search
logs from Bing.com. a leading GPSE . In GPSE, search queries
can be for a wide variety of intents and domains. To overcome the
challenge of extracting exceptions from query logs, we propose a
novel machine learning model for extraction of exception names
(e.g., NoClassDefFoundErrors) and identiﬁers (e.g., 500) from raw

 
 
 
 
 
 
Conference’17, July 2017, Washington, DC, USA

Foyzul Hassan, Chetan Bansal, Nachiappan Nagappan, Thomas Zimmermann, and Ahmed Hassan Awadallah

query text. To train and evaluate the machine learning model, we
extracted and labeled 348,559 (~0.3 million) search queries with a
semi automatic approach (See Section 4.3.1). Next, we deﬁned the
metrics for characterizing exception search behavior. Prior work on
software engineering search analysis [56, 60, 71] worked on lim-
ited amount of data and data collected in a controlled environment
using browser plug-ins or via crowd-sourcing. Such data may not
be a good representative of the actual behavior. To overcome this
issue, we collected 50 days of user search queries from a leading
GPSE and extracted exception names and identiﬁers with the ma-
chine learning model. We also performed Programming Language
(PL) speciﬁc categorization for better analysis. For behavior analy-
sis, we adopted standard metrics deﬁned and used in the Informa-
tion Retrieval (IR) [1, 8, 29, 62] community and performed behav-
ior analysis based on these metrics. Through this empirical analysis,
we address the following research questions:

• RQ1: What are the most popular exceptions?

Seeking help through general-purpose search engines (GPSEs)
is a complex process, and to understand developer needs, we
need to have a study on how developers interact with GPSEs.
Prior study [71] identiﬁes that exceptions are one of the top-
most searched items, but the study lacks the detail of excep-
tion search items and behavior. Through this research ques-
tion, we identiﬁed mostly searched exceptions that can be
more actionable for improving documentation and generate
ﬁx suggestions.

• RQ2: In terms of search effort, what exceptions require the

most effort?
Developers interaction with GPSEs are time intensive and re-
cent study on developer search behavior [56] identiﬁes that
code-related search tends to use more time than non-code
related search. In this RQ, we explored search effort for ex-
ceptions in terms of time to ﬁnd an exception solution.

• RQ3: Which exceptions are most difﬁcult to debug in terms

of search using Web search?
While searching for a query, people browse different web-
sites for a satisfactory solution. Through this RQ, we tried
to understand the successfulness of various exceptions from
different PLs.

• RQ4: What are the query characteristics of exceptions from

various PLs?
Through this RQ, we tried to answer the search query prop-
erty: number of terms in the query. Since for exceptions de-
velopers tend to search with exceptions generated by the com-
piler or framework, it can also help us to identify which ex-
ceptions are more verbose in nature.

• RQ5: Which websites are the most helpful in debugging ex-

ceptions?
In this RQ, we discussed the most frequently used Q&A sites
that are helpful in ﬁnding exception solutions. Though devel-
opers community considers Stack Overﬂow, GitHub, etc. as
the most used Q&A sites, this research question can identify
other prominent sites for exception solution and the ﬁndings

can also be helpful for the research community for solution
mining and improving the documentation.

Through answering the above research questions, we character-
ize the exception search behavior and provide insights for software
engineers as well as for researchers. For example, our analysis ﬁnds
that Python exception search is more effort-intensive than Java and
C# exception search, but have higher search success. Moreover, our
analysis on exception search shows that Q&A sites are more fre-
quently used than ofﬁcial sites for exception solution. Several re-
search studies have been performed to understand how software en-
gineers search for code [18, 60] and use Web search for various
tasks [56, 71]. Yet, this is the ﬁrst empirical study to analyze usage
of web search for debugging exceptions. In summary, we make the
following contributions:

• We propose a novel machine learning model that can extract
exception names and IDs from unstructured search query
text. Based on the evaluation described in Section 4.3.3, the
model has a high accuracy with a F1 score of 0.82.

• We analyzed ~5 billion web search queries using metrics
from the Information Retrieval (IR) community to understand
and characterize software exceptions.

• We conducted the ﬁrst study to analyze and characterize ex-
ceptions by leveraging commercial Web search data. The re-
sults provide useful insights for software engineers as well as
researchers to provide better tool support and documentation
for exceptions.

• We proposed a novel methodology for analyzing and charac-
terizing exceptions which can also be applied to other soft-
ware artifacts like APIs, programming frameworks, etc.
The rest of the paper is organized as follows: We start by pre-
senting related work and search log terminologies in Section 2 and
Section 3, respectively. After that, we discuss the overview of our
analysis which includes collecting search query data, extracting ex-
ceptions for raw query text, training and evaluation of the machine
learning model in Section 4. Section 5 presents the empirical ﬁnd-
ings of our study and Section 6 discussed about possible implica-
tions of our proposed extraction model and study. Finally, we dis-
cuss threats to validity and conclusion in Section 7 and Section 8,
respectively.
2 RELATED WORK
Web search is heavily used today for various purposes by software
engineers such as code search, debugging, downloading, etc. [13].
Prior research works on code search [10, 63, 65] identiﬁed that de-
velopers widely use GPSEs during development. In a survey, Stolee
et al. [65] reported that 85% of developers perform source code
search in GPSEs at least weekly. Similar behavior was also reported
by Sim et al. [63] that 50% of developers perform search for code
frequently. Moreover, prior study [63] identiﬁes that code-speciﬁc
search engines such as Koder and Krugle [6] perform better search-
ing for subsystems of code, while GPSEs perform better for code
blocks.

To analyze search behavior, search logs of GPSEs are widely
adopted by the different research communities [12, 30, 57]. Re-
search work [53] on the healthcare domain utilizes search log for de-
tecting devastating diseases, while recent work [15] uses search log
to measure employment demand. In software engineering research,

An Empirical Study of Software Exceptions in the Field using Search Logs

Conference’17, July 2017, Washington, DC, USA

search logs are also used to analyze search behavior. Bajracharya
et al. [11] analyzed the logs of a code search engine from a 12
months period. They do topic and lexical analysis to understand the
usage of code search engines. Further, they compared code search
engines with Web search engines and identiﬁed aspects unique to
code search. Research work to measure developer focus [18] used
search log of 150 developers over four months period of time. Re-
cent work by Rahman et al. [56] also utilizes search log to character-
ize code search behavior over non-code search. To analyze the be-
havior, they collected search logs from 150 developers that contain
nearly 150,000 queries. For the analysis, they collected logs from a
controlled environment. In contrast, we collected data from general
users to analyze exception search behavior and did the analysis on
a very large set of data (5 billion).

In a study on Google developers, Sadowski et al. [60] utilized a
combination of survey and log-analysis methodologies to analyze
code search behavior. The study identiﬁed that programmers fre-
quently search code with an average of ﬁve sessions with a total of
12 queries each day. In a recent large-scale study, Xin et al. [71]
collected Web search logs from 60 developers and interviewed 12
developers to categorize software engineering related search tasks.
They found that exception debugging is the second most frequent
task performed by software engineers using web search. In this
work, we analyze logs from a Web-scale search engine to do a large
scale study of software exceptions. Further, we use an ML based
approach to automatically extract exceptions from the raw search
query text. To the best of our knowledge, this is the ﬁrst empiri-
cal study to analyze and characterize millions of search queries to
extract exceptions and characterize them based on various metrics
like popularity, effort and success. Further, similar techniques can
be applied for APIs, frameworks, etc.

3 WEB SEARCH LOGS
For the analysis of exception search behavior, we collected web
search logs from a leading commercial general purpose search en-
gine (GPSE). The logs contain a rich set of metadata along with as-
sociated click information. The logs are anonymized and do not con-
tain any personally identiﬁable information (PII) like IP addresses,
etc.

3.1 Web Search Terminology
Since we use web search logs for our analysis of exception search
behavior, we have adopted some key terms from the web search
domain. In this section, we describe the deﬁnitions that will be used
frequently in the rest of the paper.

• Search Query: A search query is the raw query text entered

into the search engine by a user.

• Search Session: For a given client, a search session is de-
ﬁned as a series of search queries that extends until either the
browser is closed or there is a 30 minute inactivity [32, 55].
• Result Urls: Ordered list of Urls displayed by the search en-

gine in response to a search query.

• Clicked Urls: List of Urls clicked by the user from the result
Urls, ranked based on the order in which they were clicked.

• Dwell Time: Amount of time spent by a user on the clicked
result page. Dwell time is considered as one of the key met-
rics for web search effort [1, 32, 36] and has a high correla-
tion with task difﬁculty and user satisfaction [21, 40].

• SAT (Satisfaction) Click: Click Urls with Dwell Time more
than 30 sec are considered to be SAT clicks. Prior research
on search behavior [21, 26, 44] adopted SAT Click as signal
for relevance of the clicked Url.

• Search Success: Prior work on search analysis [29, 39] found
that if the last clicked Url answered the user query, they do
not explore the search results further. Hence, we consider a
search query to be successful, if the last result click for that
query is a SAT Click.

4 METHODOLOGY
In this section, we discussed the two steps of our study: 1) Excep-
tion query extraction and categorization, and 2) Exception search
analysis. Figure 1 shows an overview of the study. Our exception
search query extraction process and categorization is described in
Section 4.3. Based on extracted exceptions, we investigate the search
behavior to answer RQ1~RQ5 in Section 5. We use two datasets
from different time periods. The ﬁrst dataset (May 15-May 30, 2019)
is used to train the models to label, extract, and tag the exceptions.
The second dataset (June 1-July 20, 2019) is used for the empirical
analysis of web search behavior related to exceptions.

4.1 Data Filtering
Web search is ubiquitous in nature and is used in different domains
as well by a diverse set of people. Also, the web search patterns
varies based on demographics, locales, client, etc. Since in this work
we are focusing on exception search behavior, we applied the fol-
lowing ﬁlters to remove variation and noise:

Locale & Region: We only used search logs from users with Eng-
lish locale and the US region. We determined locale-based search re-
quest HTTP header [47]. Lastly, We also ﬁltered out search queries
that contains non-English characters based on character encoding.
Keywords & Clicks: Since we want to analyze exception related
search queries, in order to select error and exception related queries
we applied keyword-based ﬁltering. Prior research works [31, 61]
on error and exception handling also applied keyword-based search
approach to ﬁlter related issues or bugs. For exceptions, based on
manual analysis, we used the keywords: error, errno, and exception.
The keyword “error” is used in Python, Javascript, C/C++, Ruby,
R, TypeScript as part of exception, while “exception” keyword is
used as part of Java, C#, Php and Perl exceptions. Keyword “errno”
is used mainly for ID based exceptions. These keywords are very
generic in nature and covers wide range of exceptions from large set
PLs. So, we extracted all the queries which contains at least one of
these keywords in either the query text or the clicked Url. Further, to
remove noise from the dataset, we ﬁltered out all the search queries
which did not result in at least one click. Prior research works [7, 9,
42] on search behavior also removed such data to avoid cases where
users abandon the search query or remain inactive. This behavior
can mislead search behavior analysis.

Conference’17, July 2017, Washington, DC, USA

Foyzul Hassan, Chetan Bansal, Nachiappan Nagappan, Thomas Zimmermann, and Ahmed Hassan Awadallah

Figure 1: Overview of the Study

4.2 Study Subject
We collected search queries from a leading commercial Web search
engine such as Google, Yahoo!, Bing, etc.1 to train and evaluate
our machine learning model for extraction of exceptions from raw
search query texts. Apart from this dataset, we collected a separate
set of search logs from the same Web search engine for exception
search behavior analysis.

For model training, we extracted a random sample of search
queries from a 15 days period in May 2019. We applied the ﬁlters
described in Section 4.1 to get exception related queries. With the
ﬁlters applied, we extracted 1158286 (~1.1 million) search queries
along with the associated click information.

For the exception search behavior analysis, we applied the ﬁl-
ters mentioned in Section 4.1 to a random sample of 5 billion search
queries from 50 days (June 1, 2019 to July 20, 2019) period. Finally,
after ﬁltering, we extracted 980155 (0.98 million) search queries
from 589050 (0.58 million) distinct search sessions. We mined the
session information to perform session-speciﬁc analysis.
4.3 Exception Query Extraction and

Categorization

Search engines process search queries from a wide range of do-
mains and intents. Since our research is focused on characterizing
exception search behavior, we need to have a mechanism for ex-
tracting search queries related to exceptions. In order to be able to
extract exceptions from a wide variety of PLs and frameworks, the
extraction process should be generic. But due to the large volume
and diversity of search queries, hand-crafted regular expressions
have low accuracy. Therefore, we developed a high-performance
machine learning based approach that can extract exception Ids and
names from search queries.

4.3.1 Query Annotation. For training any machine learning model,
one of the main challenge is to have labeled data. Due to wide range
exception types from different PLs and frameworks and large vol-
ume of search query, annotating exceptions in search query can be
effort intensive. To minimize the effort of training query labeling
or annotation, we followed a two step process: 1) Regular expres-
sion based labeling, 2) Remove noises from the regular expression
based labels. As part of the regular expression based labeling, we
hand-crafted regular expressions shown in Table 1. We differentiate

1Anonymized for double blind

Table 1: Regular expressions for extracting exceptions from
Search Queries

No Regular expression
1

Sample search query
error 2006 (hy000) at line 462

|er-

(error
rno|err|refused|errorcode|error
code|hresult|exit|response|check
code|scope|state).*(\d+)
(\d+).*(error|errno|err|refused|
errorcode|error
code|hresult|exit|response|check
code|scope|state)
(?:^|[,
z.]+(error|exception|iteration)

])[A-Za-z]{1}[A-Za-

0[xX][0-9a-fA-F]+
[A-Z][0-9]+;
[3|4|5][0-9][0-9]

2

3

4
5
6

ssrs 2016 error: an attempt has
been...

java.lang.TypeNotPresentException:
Type javax.xml.bind.JAXBContext
not present
0x800A03EC saveas
LNK1189 65535
404 GET /nbextensions/widget-
s/notebook/js/extension.js

between ID based exceptions (e.g 404, CS1061) and name based
exceptions (TypeError, java.io.IOException). Regular expressions
no. 3 mentioned in Table 1 captures name based exceptions, while
other regular expressions capture ID based exceptions.

Even though we hand-crafted generic regular expressions to ex-
tract exceptions from search queries, as expected, it also results in
signiﬁcant amount of false positives. For example, “Ofﬁce 2016 er-
ror” is classiﬁed as an exception related query and “2016” is as
the exception ID. Similarly, “cyberterror facts” query also results
in a hit with “cyberterror” being tagged as the exception name. To
remove these noisy exception queries, we performed manual inspec-
tion of exceptions types. For an example, when we applied regular
expression based annotation, we found more than thousands “cy-
berterror” related query as exception query and those are grouped
as “cyberterror” exception. With manual analysis we evaluated each
exception group and identiﬁed that “cyberterror” is not a excep-
tion. So, we removed exception annotation of all the queries those
are previously identiﬁed as exception query by regular expression
based approach. In this process, we tried to minimize labeling effort
of large number of queries by looking at exception categories, not
by each individual search queries.

To create the annotated training dataset for the model, we per-
formed labeling using the regular expressions on the 1.1 million
search queries from the training period mentioned at Section 4.2.
After applying regular expressions based labeling, we collected 348558
(~0.3 million) queries with exception and non-exception query in

An Empirical Study of Software Exceptions in the Field using Search Logs

Conference’17, July 2017, Washington, DC, USA

the ratio 1:1. Two of the co-authors manually validated exception
types or groups for training data. We refer to this data as semi-
automatically annotated data.

4.3.2 ML Model for Extracting Exceptions. To parse search
queries we need to have a machine learning model to extract the
exception entity. In natural language processing, an entity is con-
sidered as basic information element and often considered the main
subject of the text. Named Entity Recognition(NER) is a Natural
Language Processing(NLP) technique to identify entities from text
and classify them into the deﬁned categories. NER is widely used in
different languages processing applications, such as newspaper con-
tent classiﬁcation [46], Q&A systems, and machine translation [25],
extract software project artifact information from document [27].
NER solutions can be divided into two broad categories: i) rule-
based and ii) statistical pattern-based. Rule-based methods are mainly
for common entities like persons, locations, organizations, etc. us-
ing specialized dictionaries as the reference for identiﬁcation. For
entities that are not included in the dictionary, may require experts
to rewrite the handcrafted rules. On the other hand, the statistical
pattern-based approach needs a larger annotated corpus for learn-
ing but doesn’t need experts. Different supervised machine learning
algorithms including HMMs [17], SVM [33], CRF [35] have been
used for learning of statistical pattern-based NER systems. With our
semi-automated tagging approach as described in Section 4.3.1, we
annotated the exception entity corpus for NER training.

The conditional random ﬁelds (CRF) algorithm proposed by Laf-
ferty [35] is widely used for reliable sequence labeling [38, 69,
70] for NER task. In our study, we used the ﬁrst-order Markov
linear chain CRF [59] with L-BFGS [37] training algorithm us-
ing the scaling method [54]. To regularize the classiﬁer, we used
Elastic-net(L1+L2) [22] penalty in order to reduce model complex-
ity. Based on the Hammersley-Clifford theorem, CRF computes the
conditional probability of a state sequence as follows:

pθ (y|x) =

1
Zθ (x)

T

K

exp

k=1
Õ
where x = (x1, . . . , xT ) denotes the input sequence and y = (y1, . . . , yT )

t =1
Õ

)

(

θk fk (yt −1, yt , xt )

(1)

is the output sequence, hereafter referred to as the sequence of la-
bels. { fk }1≤k ≤K is an arbitrary set of feature functions and {θk }1≤k ≤K
are the associated real-valued parameter values. For our study, we
used CRFSuite [51], which is a commonly used Python library for
CRF. As part of feature extraction, tokens and parts of speech (POS)
tags are the basic features to extract. The basic features have less
contextual information and less text patterns. So, in addition to ba-
sic features, we extract three other features, including contextual
features [20], gazetteer features [14], and orthographic features [41].
For hyper-parameters, we used 0.1 as Elastic-net L1 penalty and
0.01 as Elastic-net L2 penalty based on prior work on domain-speciﬁc
parser [4]. Due to large data size, we used maximum iteration count
200 for training.

4.3.3 Model Evaluation. In this section, we describe the evalu-
ation of the performance of CRF model described in Section 4.3.2.
We evaluateed the model using a manually annotated dataset. For
this dataset, we randomly sampled 500 queries with exception and

Table 2: CRF model performance evaluation.
Support
169
61

Class
Exception ID
Exception Name
Avg.

Precision
0.89
0.78
0.83

F1-Score
0.78
0.86
0.82

Recall
0.69
0.97
0.83

non-exception queries in the ratio 1:1 collected from the analysis pe-
riod (June 1, 2019 to June 5, 2019). Two researchers separately an-
notated those queries and resolved the disagreement by discussion.
We performed Cohen’s kappa coefﬁcient [68] to ﬁnd inter-annotator
agreement. Coefﬁcient value 1 indicates a complete agreement and
value of 0 indicates complete disagreement. In our annotation, we
found the coefﬁcient value as 0.88, which indicates high conﬁdence
of agreement.

Since we categorized exceptions into two broad categories: i)
ID-based Exception and ii) Name-based exception, we evaluated
the performance of both types of category. Table 2 shows the per-
formance of the machine learning model on manually labeled data.
According to the Table, average Precision, Recall, and F1-Score are
0.83, 0.83 and 0.82 respectively. Since our evaluation performed
with a dataset collected from real-world user search data and large
scale in nature, the performance of our model is reasonable and can
be used for exception data collection for empirical analysis of ex-
ception search behavior.

4.3.4 Exception Tagging for Analysis. Using the machine learn-
ing model described in Section 4.3.2, we tag the analysis dataset. If
the model can extract any exception from the query then we con-
sider that as an exception query. In many cases, search queries can
have multiple exceptions IDs or names due to search exception trace
from IDEs. In those cases, we only consider the root or ﬁrst level of
exception. With the machine learning model, we extracted 118315
ID-based exception query and 32887 Name-based exception query
from 980155 search queries.

4.3.5 Programming Language Categorization. Every program-
ming language (PL) can have its own format for exception names
and Ids. To perform PL speciﬁc exception analysis, we categorized
search queries into various PLs based on the exception, query text
and the clicked Urls. For this, we picked three popular program-
ming languages 1) Java, 2) C#, and 3) Python. To categorize search
queries into these programming languages, we performed a keyword-
based search with keywords (java, c#, and python). We search the
keywords in raw query and also in the clicked Urls. If match is
found then we assign the corresponding PL to the query. For in-
stance, for “Search query: python ImportError: cannot import name”
we found the PL name was mentioned in the query. So, we assigned
this exception query to Python PL category. If PL name was not
found in the search query or the clicked Urls; we look-up the excep-
tion tagged in the search query in exception lists for Java [3], C# [2]
and Python [5]. If we ﬁnd a match with any of these lists, then we as-
sign the corresponding PL name to that query. For example, in query
“Search query: System.io.ﬁlenotfoundexception addinutil.exe ” , no
PL name occurs in the search query or the clicked Urls. So we cross-
reference exception name with the C# exception list and found a
match. So, we assigned C# as PL type for that query. If we do
not ﬁnd keyword-based match or exception list based matches, we
don’t assign any PL name for the query. With this approach, we
categorized 17035 exception search queries as Java related, 13452

Conference’17, July 2017, Washington, DC, USA

Foyzul Hassan, Chetan Bansal, Nachiappan Nagappan, Thomas Zimmermann, and Ahmed Hassan Awadallah

exception search queries as C# related, and 27723 queries as Python
related.

4.4 Exception Analysis
Based on the exceptions and PL tagging of search queries, we per-
formed empirical analysis on exception search behavior. We ana-
lyzed the following ﬁve aspects: 1) Popularity Analysis, 2) Effort
Analysis, 3) Success Analysis, 4) Exception Query Characteristics
and 5) Website analysis for debugging of exceptions. The results of
the study are presented in Section 5.

5 EMPIRICAL STUDY
In this section, we present our analysis of exception search queries.
Some exceptions can be rare or their search results could not have
yielded a meaningful result. To avoid such unusual cases, we only
considered exceptions that appeared in at least twenty distinct search
sessions.

5.1 RQ1: What are the most frequently searched

exceptions?

5.1.1 Metric. To ﬁnd frequently searched exceptions, we used
unique session count as a metric as the same exception can be
searched for with different text.

5.1.2 Analysis. Exceptions can be presented in two text formats:
ID-based exception and Name-based exception. We measure the fre-
quency of both ID-based exceptions and Name-based exceptions.
Based on unique session count, Figure 2 shows the most frequently
searched ID-based exceptions. Among the top ten ID-based excep-
tion list, six of the exceptions (500, 404, 400, 403, 401, and 502)
are Http protocol exceptions and rest are Windows OS related ex-
ceptions. Figure 3 shows most frequently searched Name-based ex-
ceptions. In Name-based exceptions, typeerror is the most searched
exception. A reason might be due to the fact that both Python and
JavaScript throw typeerror exception. Other popular Name-based
exceptions are also related to Python and Java.

We also performed programming language (PL) speciﬁc popu-
larity analysis. Figure 4 shows the top searched exceptions of Java,
C#, and Python. For Java, noclassdeffounderror is the most popular
exception. Another exception we would like to call attention to is ex-
ception 65542 which is thrown from the Java utility library for use
with OpenGL. For C#, invalidoperationexception is the most fre-
quently searched exception. Even though cs1061 and cs0029 both
are C# compile time exceptions, they are also frequently searched.
Also, the C# exception ad0001 that is thrown from code analyzer
also shows up in the top searched for exceptions. For Python, type-
error is the mostly searched exception, which is raised when an
operation or function is applied to an object of inappropriate type.
Others frequent exceptions are also from Python built-in exceptions.
Python’s typeerror exception is searched 4.64 times more frequently
than Java’s most frequent exception and 8.47 times more frequently
than C#’s top searched exception. This also indicates that Python
exceptions are more frequently searched than Java and C#. Prior
studies [19, 48] on programming language popularity found that
Python is more popular than Java and C#, which aligns with our
exception search popularity ﬁndings.

4576

2650

2357

3098

2567

2303 1860

1553

1808

1194

t
n
u
o
C
n
o
i
s
s
e
S
e
u
q
n
U

i

5000
4500
4000
3500
3000
2500
2000
1500
1000
500
0

Figure 2: Popular ID exceptions

2290

2500
2000
1500
1000
500
0

t
n
u
o
C
n
o
i
s
s
e
S
e
u
q
n
U

i

1102 1038

846 826 721

565 484 368 327

Figure 3: Popular name exceptions

Finding 1: Most popular ID-based exceptions are related
to HTTP Connection and OS related errors. Python excep-
tions are more frequently searched than Java and C# ex-
ceptions.

5.2 RQ2: What is the exception search behavior

based on effort?

5.2.1 Metric. For effort analysis, we use Total Dwell Time (de-
scribed at Section 3.1) in seconds as the evaluation metric. We limit
Dwell Time in a Url to 600 seconds to avoid the case where the user
clicked the Url, but remained inactive over 600 seconds.

5.2.2 Analysis. Our exception search effort analysis is divided
both by exception format (ID/Name) as well as programming lan-
guage. According to Figure 5, overall exception search takes an av-
erage effort of 157.39 sec. While for ID-based exceptions it takes
155.22 secs, Name-based exceptions take 164.57 secs of effort, which
is 6.02% higher than ID-based exception search. Name-based ex-
ceptions are more effort-intensive than ID-based exception (con-
ﬁrmed by t-test with p-value(ID,Name) = 8.86e − 13, which is lower
than threshold 0.05). This could be due to the fact that IDs are usu-
ally unique are more easily “searchable” due to easy matching. For
programming language speciﬁc effort analysis, Java and C# take a
mean effort time of 160.59 sec and 161.57 sec respectively. While
Python exception searches take 169.18 sec, which is 5.34% higher
than Java and 4.71% than C#. Based on our analysis Python excep-
tions are most effort-intensive exceptions(conﬁrmed by t-test with
p-value(Java,Python) = 0.002 and p-value(C#,Python) = 0.03, which
are lower than threshold 0.05). Java and C# exceptions take similar

 
 
 
 
An Empirical Study of Software Exceptions in the Field using Search Logs

Conference’17, July 2017, Washington, DC, USA

t
n
u
o
C
n
o
i
s
s
e
S
e
u
q
n
U

i

600

500

400

300

200

100

0

484

368

324 317

286

2(cid:0)(cid:1) 173 163 148 141

265

225

192 179 172

146 143 136 133

109

t
n
u
o
C
n
o
i
s
s
e
S
e
u
q
n
U

i

300

250

200

150

100

50

0

2500

2246

t
n
u
o
C
n
o
i
s
s
e
S
e
u
q
n
U

i

2000

1500

1000

500

0

11021038

845

720

545

327 255 219 208

(a) Java

(b) C#

(c) Python

Figure 4: PL speciﬁc most popular exceptions

effort for search which we conﬁrmed by t-test with p-value(Java,C#)
= 0.79. Prior work [21] on effort with Dwell Time ﬁnds that it has
high correlation with task difﬁculty and user satisfaction.

C#’s top effort-intensive exceptions indicates that there could be
dissatisfaction with the search results or difﬁculty in these excep-
tions.

Finding 2: ID-based exceptions take less effort to ﬁnd a
solution. In terms of PL speciﬁc analysis, C# exceptions
and Java takes similar effort, while Python takes higher
effort than Java and C#.

Figure 5: Effort comparison

Figure 6 shows most effort-intensive exceptions of Java, C#, and
Python. Even though 400 is not a Java built-in exception, Java code
may generate 400 exceptions for Http protocol usage from code.
Other interesting Java exceptions are 1603 and 1618, which are Java
run-time and deployment exceptions. In terms of C#, cs0017 is the
most search effort-intensive exception and the surprising factor for
this exception is that it is a compile-time exception due to more
than one application entry point. Deﬁning one entry point for an
application is a basic concept of any programming language. But
our analysis identiﬁes that this the most intensive exception search
for C# and sheds light that better documentation for this could help
alleviate problems for developers. For Python, unboundlocalerror
is the most effort-intensive exception search which is raised when a
reference is made to a local variable in a function or method, but no
value has been bound to that variable.

For the top effort-intensive Java exceptions, search effort is at
least 37.83% higher than the average search effort for Java excep-
tions. For C#, top effort-intensive exceptions, this value is 58.17%
higher than average C# exception search effort. Top Python search
effort-intensive exceptions are 15.49% higher than average Python
exception search effort. The high variance in effort for Java and

5.3 RQ3: What is the exception search behavior

based on success?

5.3.1 Metric. Search success can be deﬁned as user found infor-
mation for a query that the user entered. To evaluate exception
search success behavior, we will use the Search Success metric
which we deﬁned in Section 3.1. The value for this metric is either
0 for fail and 1 for success.

5.3.2 Analysis. For exception search success analysis, we ana-
lyzed the overall dataset of exceptions, format-based exceptions and
PL speciﬁc exceptions. Figure 7 shows the mean success rate of all
the groups of exceptions. The overall success rate for exceptions is
0.57, while ID-based exception shows the mean success rate of 0.56
and Name-based exception shows the mean success rate of 0.58. So,
ID-based exceptions are less successful than Name-based exception
in terms of ﬁnding a solution from search engines(conﬁrmed by
t-test with p-value(ID, Name) = 2.45E − 13, which is lower than
threshold 0.05). In terms of PL speciﬁc analysis, Python excep-
tions are the most successful in terms of ﬁnding a solution from
the search engines with mean success rate 0.61. Among the three
programming languages, C# shows least success rate which 0.54.
Mean success rate of these three programming languages are also
statistically signiﬁcant with t-test p-Value(Java,C#) = 2.05e − 31, p-
Value(Java,Python) = 0.01, and p-Value(C#,Python) = 1.35e − 98.

 
 
 
 
 
 
Conference’17, July 2017, Washington, DC, USA

Foyzul Hassan, Chetan Bansal, Nachiappan Nagappan, Thomas Zimmermann, and Ahmed Hassan Awadallah

)
c
e
s
(
e
m
T

i

l
l

e
w
D
n
a
e
M

350

300

250

200

150

100

50

0

0
0
4

3
0
6
1

8
1
6
1

n
o
i
t
p
e
c
x
e
q
s

l

1
0
4

n
o
i
t
p
e
c
x
e
t
a
m
r
o
f
r
e
b
m
u
n

r
o
r
r
e
d
n
u
o
f
f
e
d
s
s
a
l
c
o
n

…
o
i
s
r
e
v
s
s
a
l
c
d
e
t
r
o
p
p
u
s
n
u

n
o
i
t
p
e
c
x
e
e
m

i
t
n
u
r

r
o
r
r
e
k
n

i
l

d
e
i
f
s
i
t
a
s
n
u

)
c
e
s
(
e
m
T

i

l
l

e
w
D
n
a
e
M

450
400
350
300
250
200
150
100
50
0

7
1
0
0
s
c

n
o
i
t
p
e
c
x
e
b
d
e
o

l

n
o
i
t
p
e
c
x
e
y
t
i
r
u
c
e
s

0
0
5

1
0
0
5
s
c

…
c
x
e
t
n
e
m
y
o
p
e
d
d

l

i
l

a
v
n

i

n
o
i
t
p
e
c
x
e
d
e
t
r
o
p
p
u
s
t
o
n

…
p
e
c
x
e
t
a
m
r
o
f
e
g
a
m
d
a
b

i

n
o
i
t
p
e
c
x
e
d
n
u
o
f
t
o
n

l
l

d

n
o
i
t
p
e
c
x
e
c
i
h
p
a
r
g
o
t
p
y
r
c

)
c
e
s
(
e
m
T

i

l
l

e
w
D
n
a
e
M

350

300

250

200

150

100

50

0

(a) Java

(b) C#

Figure 6: PL speciﬁc exceptions requiring most effort

l

r
o
r
r
e
a
c
o
d
n
u
o
b
n
u

l

r
o
r
r
e
x
e
d
n

i

r
o
r
r
e
f
o
e

r
o
r
r
e
e
u
a
v

l

r
o
r
r
e
l
s
s

r
o
r
r
e
e
m

i
t
n
u
r

r
o
r
r
e
n
o
i
t
a
t
n
e
d
n

i

r
o
r
r
e
n
o
i
t
c
e
n
n
o
c

r
o
r
r
e
e
d
o
c
e
d
e
d
o
c
i
n
u

(c) Python

0.57

0(cid:2)(cid:3)(cid:4)

(cid:5)(cid:6)(cid:7)(cid:8)

(cid:9)(cid:10)(cid:11)(cid:12)

(cid:13)(cid:14)(cid:15)(cid:16)

(cid:17)(cid:18)(cid:19)(cid:20)

’()

s
s

$%&

 S

!"#

(cid:30)(cid:31) 

(cid:27)(cid:28)(cid:29)

n
a
e
M

(cid:24)(cid:25)(cid:26)

(cid:21)(cid:22)(cid:23)

0

Figure 7: Exception search success comparison

Apart from group-speciﬁc success analysis, we also performed
analysis to ﬁnd the least successful exceptions of Java, C#, and
Python. According to Figure 8, verifyerror is the least successful
exception among Java exceptions. java.lang.VerifyError can occur
when the compile-time and run-time environments are different. An-
other less successful exception of Java is saxparseexception, which
might be caused during XML parsing and the solution also depends
on XML content. For C#, top four least successful exceptions are
due to code analysis (ad0001) and compile-time exceptions (cs1061,
cs0266, and cs1003). This might be an indication that the C# devel-
opment environment ﬁnds a lot more exceptions during code analy-
sis and compile-time than before the run-time executions, which is
good from a deployment perspective. For Python, connectionerror
is the least successful exception and it is also an exception that de-
pends on the connection environment rather than on the code alone.

Finding 3: ID based exceptions are less successful than
Name-based exceptions. Also, among the three Program-
ming Languages C# has the lowest search success.

5.4 RQ4: Characterizing exception search queries
5.4.1 Metric. We used the number of words or terms in the ex-
ception search query as the query characteristics. To count number
words we tokenize the raw query into words with space used as the
delimiter.

5.4.2 Analysis. Figure 9 shows the word count characteristics of
overall all exceptions, IDException, NameException, and the three
PL speciﬁc exceptions. As shown in the graph, ID-based Exceptions
are least wordy due to the uniqueness of the exception code. ID-
based exception mean word count is 6.93, while Name-based excep-
tion word count 9.13 (conﬁrmed by t-test with p-value (ID,Name) =
0.0, which is lower than threshold 0.05). C# exceptions mean word
count is 12.72, Java mean word count is 8.53, and Python mean
word count is 9.25. Among the three programming languages, C#
exceptions are the most verbose and Java is the least verbose, which
is also conﬁrmed by t-test with p-Value (Java,C#) = 2.37e − 141,
p−V alue(Java,Python) = 3.93e −07, p-Value(C#,Python) = 1.95e −
213. Users search exceptions with exception text message generated
by the compiler or during run-time. This indicates that C# compiler
or run-time generates more wordy exception message than Java and
Python.

Figure 10 shows the most verbose exceptions of Java, C#, and
Python. Even though gameerror is not Java’s built-in exception, it’s
the wordiest exception of Java. For C#, cs1061 is the most verbose
exception that is thrown when trying to call a method or access a
class member that does not exist. For the case of Python, environ-
menterror which is the base class of IOError, OSError exception is
the wordiest exception.

Finding 4: C# generates more verbose exceptions than
Java and Python.

5.5 RQ5: What are the popular web domains for

ﬁnding solutions to exceptions?

5.5.1 Metric. For this analysis, we used the metric click count to
a certain web domain for analysis and ranking of its helpfulness in
ﬁnding solutions to exceptions.

5.5.2 Analysis. Figure 11 shows the most popular exception so-
lution web domains. According to our analysis, stackoverﬂow.com
is the topmost web domain to provide a solution or help with excep-
tions. The next popular web domain is from Microsoft community
help site answers.microsoft.com site which covers troubleshooting

 
 
 
 
 
 
*
+
,
-
.
/
1
3
4
5
An Empirical Study of Software Exceptions in the Field using Search Logs

Conference’17, July 2017, Washington, DC, USA

9:;

LMN

]^_

s
s
e
c
c

n
a
e
M

0.5

0.4

0.3

0.2

0.1

0

s
s
e
c
c

n
a
e
M

678

0.5
0.4
0.3
0.2
0.1
0

r
o
r
r
e
y
f
i
r
e
v

…

i
t
p
e
c
x
e
t
a
m
r
o
f
r
e
b
m
u
n

…

i
t
p
e
c
x
e
t
n
e
m
u
g
r
a
a
g
e

l

l
l
i

n
o
i
t
p
e
c
x

ng
a

l

n
o
i
t
p
e
c
x
e
t
s
a
c
s

n>
a

l

1
0
4

r
o
r
r

nD
a

l

n
o
i
t
p
e
c
x
e
y
t
i
r
u
c
e
s

n
o
i
t
p
e
c
x
e
e
s
r
a
p
x
a
s

n
o
i
t
p
e
c
x
e
t
u
o
e
m

i
t
t

so

1
0
0
0
d
a

1

sO
c

sR
c

3
0
0
1
s
c

…
e
e
g
n
a
r
f
o
t
u
o
t
n
e
m
u
g
r
a

…
c
x
e
d
n
u
o
f
t
o
n
y
r
o
t
c
e
r
i
d

…

i
t
p
e
c
x
e
d
o
h
t
e
m
g
n
i
s
s
i

m

4
0
4

2W
0
1
s
c

…
p
e
c
x
e
n
o
i
t
a
c
o
v
n
i
t
e
g
r
a
t

s
s
e
c
c

n
a
e
M

Z[\

0.5

0.4

0.3

0.2

0.1

0

r
o
r
r
e

r
o
r
r
e
n
o
i
t
r
e
s
s
a

r
o
r
r
e
e
c
n
e
r
e
f
e
r

r
o
r
r
e
e
m
a
n

r
o
r
r
e
e
t
u
b
i
r
t
t
a

r
o
r
r
e
x
e
d
n

i

r
o
r
r
e
e
p
y
t

r
o
r
r
e
n
o
i
s
s
i

m
r
e
p

r
o
r
r
e
n
o
i
t
c
e
n
n
o
c

r
o
r
r
e
d
e
t
n
e
m
e
p
m

l

i
t
o
n

(a) Java

(b) C#

(c) Python

Figure 8: PL speciﬁc exceptions with least success

Finding 5: Even though Java, C#, and Python have their
own documentation websites and social forums, stackover-
ﬂow.com is the most popular website for debugging excep-
tions in these languages.

6 IMPLICATIONS
In this section, we discuss the implications of our exception extrac-
tion and categorization model and exception search behavior anal-
ysis. Followings are the list of actionable items inferred from the
study:

• In recent works [16, 34, 72], researchers have been work-
ing on code recommendation systems to assist developers
in writing code faster. These works mainly focus on APIs.
Through RQ1, we identiﬁed the most frequently searched
items from different PLs. Also, we identiﬁed that ID-based
exceptions such as 400, 500, etc. are searched frequently.
These frequently searched items can be base for recommend-
ing code for exception solution. From our analysis, we also
found several Windows errors, such as 0x80004005, searched
very frequently. These type of analysis can be helpful to iden-
tify emerging issues such as OS upgrade problem, frame-
work version synchronization problem, etc.

• Analysis from RQ2 indicates that ID-based exceptions take
less effort or time to ﬁnd a solution than Name-based excep-
tion. In terms of PL speciﬁc analysis, C# exceptions and Java
takes similar effort, while Python takes higher effort than
Java and C#. RQ3 indicates that ID based exceptions are
less successful than Name-based exceptions. Also, among
the three Programming Languages, C# has the lowest search
success. Prior work [21] on search effort analysis ﬁnds that
effort has a high correlation with user satisfaction. That in-
dicates that C# exceptions searches are less successful, so
developer tends to put less effort or time for searching and
abandon search at some point. This is a very critical ﬁnding
to have the necessity to improve C# exception handling doc-
umentation and posts in Q&A sites. The same issue is also
identiﬁed for ID-based exceptions.

Figure 9: Word count comparison for exception search queries

help for a wide range of Microsoft products. Github is the fourth
most popular web domain for helping ﬁnd solutions to exceptions.

35135

28257

t
n
u
o
C
k
c
i
l

C

40000
35000
30000
25000
20000
15000
10000
5000
0

6537 5378 4374 3040 2410 2236 2224 2052

Figure 11: Most popular websites used for debugging excep-
tions

For the Java programming language, stackoverﬂow.com is the
most popular web domain which is 17.44 times more popular than
the Java ofﬁcial community site. stackoverﬂow.com is also the most
popular solution web domain for C#, even though Microsoft main-
tains several forums and ofﬁcial help sites. For Python exceptions,
stackoverﬂow.com is 35.79 times more popular than the ofﬁcial Python
forum. The analysis on Web domain help sites indicates that even
though each PL maintains ofﬁcial documentation and community
sites, statoverﬂow due to its community effort dominates against
them.

<
=
?
@
A
B
C
E
F
G
H
I
J
K
P
Q
T
U
V
X
Y
k
‘
a
b
c
 
Conference’17, July 2017, Washington, DC, USA

Foyzul Hassan, Chetan Bansal, Nachiappan Nagappan, Thomas Zimmermann, and Ahmed Hassan Awadallah

t
n
u
o
C
d
r
o
W

.
g
v
A

35
30
25
20
15
10
5
0

t
n

d
r

20

ij

fh

14
12
10

e

d

4
2
0

r
o
r
r
e
e
m
a
g

…
i
s
r
e
v
s
s
a
l
c
d
e
t
r
o
p
p
u
s
n
u

2
4
5

n
o
i
t
p
e
c
x
e
e
s
r
a
p
x
a
s

n
o
i
t
p
e
c
x
e
t
s
a
c
s
s
a
l
c

n
o
i
t
p
e
c
x
e

l

sr

n
o
i
t
p
e
c
x
e
e
m

i
t
n
u
r

n
o
i
t
p
e
c
x
e
r
o
r
r
e
x
a
t
n
y
s
l

sq

n
o
i
t
p
e
c
x
e
e
t
a
t
s
l
a
g
e

l
l
i

n
o
i
t
p
e
c
x
e
e

hn
s
d
n
a
h
l
s
s

t
n
u
o
C
d
r
o
W

.
g
v
A

20
18
16
14
12
10

(cid:132)

(cid:131)

4
2
0

1

s|
c

7
1
0
0
s
c

s(cid:127)
c

n
o
i
t
p
e
c
x
e
d
a
o
e

l

l
i
f

…
e
e
g
n
a
r
f
o
t
u
o
t
n
e
m
u
g
r
a

1
0
0
5
s
c

1
0
0
0
d
a

n
o
i
t
p
e
c
x
e
t
l
u
a
f

n
o
i
t
p
e
c
x
e
t
e
k
c
o
s

n
o
i
t
p
e
c
x
e
y
t
i
r
u
c
e
s

r
o
r
r
e
t
n
e
m
n
o
r
i
v
n
e

r
o
r
r
e
e
d
o

n(cid:137)
e
e

n(cid:133)
u

1

6

0
0
1

r
o
r
r
e
e
d
o

e(cid:142)
d
e

n(cid:138)
u

r
o
r
r

s(cid:143)
s

r
o
r
r
e
e
m

i
t
n
u
r

r
o
r
r
e
d
e
s
u

e(cid:149)
r
n
o
i
t

e(cid:148)
n

r
o
r
r
e
s
o

r
o
r
r
e
e

v(cid:150)

r
o
r
r

n(cid:154)

s(cid:153)

(a) Java

(b) C#
Figure 10: Most verbose exceptions from Java, C# and Python

(c) Python

5058

t
n
u
o
C
k
c
i
l

C

6000

5000

4000

3000

2000

1000

0

634 602 460

290 218 158 158 136 125

3663

t
n
u
o
C
k
c
i
l

C

4000
3500
3000
2500
2000
1500
1000
500
0

617

368 237 235 218 151 91 83

t
n
u
o
C
k
c
i
l

C

16000

14000

12000

10000

8000

6000

4000

2000

0

14317

2795

400 180 82 82 79 76 70 65

(a) Java

(b) C#
Figure 12: PL speciﬁc popular websites for exception debugging

(c) Python

• Analysis from RQ4 indicates that C# generates more ver-
bose exceptions than Java and Python. According to the re-
cent study on web search [71], developers search though ex-
ception messages generated by the compiler or framework
with partial message from client code. Prior study [56] ﬁnds
that code-related searches are more verbose than non-code
related searches. So, the exception search success rate for
C# should be higher than the other two programming lan-
guages. But RQ3 analysis ﬁnds that the success rate of C#
search is lower than Java and Python. Findings of these two
RQs sheds light on the necessity of reviewing the context
and information generated by C# framework exceptions.
• Although several research works [34, 45, 50, 58, 67] have
used stackoverﬂow.com and GitHub.com for different soft-
ware engineering research purpose such as code recommen-
dation, developer intent analysis, mining code repository, etc.,
but this is the ﬁrst work with such a large set of user search
data and the study identiﬁes the popularity of these community-
based Q&A sites. Also recognizes that the necessity of com-
munity engagement for making a framework popular and
easy to work with.

• Finally, with our proposed exception extraction model, ex-
ception type can be extracted without manual effort. This ap-
proach can also be extended for APIs, frameworks, etc. for
user search behavior analysis.

7 THREATS TO VALIDITY
Our empirical study has some limitations that we would like to rec-
ognize:

Construct validity: Our metrics deﬁned for success might not di-
rectly be identiﬁable with success in all scenarios. This is alleviated
to a large degree by the fact that these are standard metrics [21, 29]
deﬁned and used in the IR [1, 52, 55] community for several years.
External Validity: There are three main external validity con-
cerns. Temporal: Our results are obtained in the given time frame
only. It is possible that the results might vary for a different time
frame. Given our unintentional and 50 day time period selection,
we hope to alleviate this problem. Geographic: Our data is based
on search queries from United States with only English language
queries. Analyzing differences in behavior across different locales,
geographies and client form factors is an interesting and important
topic but is out of scope for this work. Selection bias: The results
could possibly be different should another GPSE be used. We think
this is alleviated by the fact that we performed our analysis on a
large sample of 5 billion search queries.

8 CONCLUSION
In this paper, we have investigated for the ﬁrst time how users
search and ﬁnd information about exceptions using web search. Our
study identiﬁed one key implication that even with having more
verbose exception message, exception search can suffer with less

l
m
p
s
t
u
v
w
x
y
z
{
}
~
(cid:128)
(cid:129)
(cid:130)
 
 
(cid:134)
(cid:135)
(cid:136)
(cid:139)
(cid:140)
(cid:141)
(cid:144)
(cid:145)
(cid:146)
(cid:147)
(cid:151)
(cid:152)
(cid:155)
(cid:156)
(cid:157)
 
 
 
 
 
An Empirical Study of Software Exceptions in the Field using Search Logs

Conference’17, July 2017, Washington, DC, USA

search success. Development community should look carefully at
the reasons behind the low search success. Also, our study iden-
tiﬁes the importance of community Q&A sites for faster develop-
ment and debugging. This information helps identify and motivate
the importance of improving the documentation support for excep-
tions. Developer websites like StackOverﬂow and GitHub can also
leverage the methodology and metrics proposed in this work for
improving developer experience. Given the large body of work on
software engineering recommendations [28], adding tool support in
IDE’s to have better suggestions for ﬁxing exceptions would be of
strong interest to the broader community. Additionally, in public
forums, enhanced exception documentation or solution suggestions
for most frequent, most search effort-intensive, or less successful
exceptions can reduce developer effort. In the future, we plan to in-
corporate qualitative study to analyze exception search expectation
from developer’s point of view.
Data sharing and availability: The search data unfortunately can-
not be shared publicly. This is due to legal laws and not due to inde-
pendent choice. Search queries are very personal data and GDPR [23]
in Europe and equivalent privacy laws in other countries strictly
govern the access to, usage and research that can be carried out on
this data without speciﬁcally identifying an individual or groups of
individuals. Interested researchers should contact us about the avail-
ability of similar data. Upon completion of the necessary legal steps
and the legal paperwork, it may be possible to give access to similar
search data for academic researchers.

REFERENCES
[1] 2010. The effects of query bursts on web search. In Proceedings - 2010
IEEE/WIC/ACM International Conference on Web Intelligence, WI 2010, Vol. 1.
374–381. https://doi.org/10.1109/WI-IAT.2010.59

Accessed: 2019-06-20.

[3] 2019. Java Exception List. https://programming.guide/java/list-of-java-exceptions.html.

Accessed: 2019-06-20.

[4] 2019. Parserator. https://parserator.datamade.us/. Accessed: 2019-06-20.
[5] 2019. Python Exception List. https://docs.python.org/3/library/exceptions.html.

Accessed: 2019-06-20.

[6] 2020. Krugle. https://www.krugle.com/. Accessed: 2020-04-30.
[7] Qingyao Ai, Susan T. Dumais, Nick Craswell, and Dan Liebling. 2017.
Characterizing Email Search Using Large-Scale Behavioral Logs and Sur-
veys. In Proceedings of the 26th International Conference on World Wide
Web (Perth, Australia) (WWW ’17). International World Wide Web Confer-
ences Steering Committee, Republic and Canton of Geneva, CHE, 1511–1520.
https://doi.org/10.1145/3038912.3052615

[8] L. Azzopardi, D. Kelly, and K. Brennan. 2013. How Query Cost Affects Search

Behavior. 23–32.

[9] Leif Azzopardi, Ryen W. White, Paul Thomas, and Nick Craswell. 2020.
for Heterogeneous Search Engine Re-
Data-Driven Evaluation Metrics
the 2020 Conference on Human Infor-
In Proceedings of
sult Pages.
mation Interaction and Retrieval
(CHIIR ’20).
Association for Computing Machinery, New York, NY, USA, 213–222.
https://doi.org/10.1145/3343413.3377959

(Vancouver BC, Canada)

[10] Sushil Bajracharya, Trung Ngo, Erik Linstead, Yimeng Dou, Paul Rigor, Pierre
Baldi, and Cristina Lopes. 2006. Sourcerer: a search engine for open source code
supporting structure-based search. In Companion to the 21st ACM SIGPLAN sym-
posium on Object-oriented programming systems, languages, and applications.
ACM, 681–682.

[11] Sushil Krishna Bajracharya and Cristina Videira Lopes. 2012. Analyzing and
mining a code search engine usage log. Empirical Software Engineering 17, 4
(01 Aug 2012), 424–466. https://doi.org/10.1007/s10664-010-9144-6

[12] Chetan Bansal, Pantazis Deligiannis, Chandra Maddila, and Nikitha Rao. 2020.
Studying Ransomware Attacks Using Web Search Logs. In Proceedings of the
43rd international ACM SIGIR conference on Research & development in infor-
mation retrieval. https://doi.org/10.1145/3397271.3401189

[13] Chetan Bansal, Thomas Zimmermann, Ahmed Hassan Awadallah, and Nachiap-
pan Nagappan. 2019. The Usage of Web Search for Software Engineering. arXiv

preprint arXiv:1912.09519 (2019).

[14] Andrew Carlson, Scott Gaffney, and Flavian Vasile. 2009. Learning a Named
Entity Tagger from Gazetteers with the Partial Perceptron.. In AAAI Spring Sym-
posium: Learning by Reading and Learning to Read. 7–13.

[15] Stevie Chancellor and Scott Counts. 2018. Measuring employment demand us-
ing internet search data. In Proceedings of the 2018 CHI Conference on Human
Factors in Computing Systems. ACM, 122.

[16] Yan Chen, Sang Won Lee, Yin Xie, YiWei Yang, Walter S. Lasecki, and Steve
Oney. 2017. Codeon: On-Demand Software Development Assistance. In Pro-
ceedings of the 2017 CHI Conference on Human Factors in Computing Systems
(Denver, Colorado, USA) (CHI ’17). Association for Computing Machinery, New
York, NY, USA, 6220–6231. https://doi.org/10.1145/3025453.3025972

[17] Nigel Collier, Chikashi Nobata, and Jun-ichi Tsujii. 2000. Extracting the names
of genes and gene products with a hidden Markov model. In Proceedings of the
18th conference on Computational linguistics-Volume 1. Association for Compu-
tational Linguistics, 201–207.

[18] C. S. Corley, F. Lois, and S. Quezada. 2015. Web usage patterns of developers.
In 2015 IEEE International Conference on Software Maintenance and Evolution
(ICSME). 381–390. https://doi.org/10.1109/ICSM.2015.7332489

[19] Thomas Durieux, Rui Abreu, Martin Monperrus, and Tegawendé F. Bissyandé.
2019. Interviewing the Most Successful Bot on GitHub: Dr Travis CI on 35+ Mil-
lion of its Jobs. CoRR abs/1904.09416 (2019). http://arxiv.org/abs/1904.09416
[20] Julien Fayolle, Fabienne Moreau, Christian Raymond, Guillaume Gravier, and
Patrick Gros. 2010. CRF-based combination of contextual features to improve a
posteriori word-level conﬁdence measures. In Eleventh Annual Conference of the
International Speech Communication Association.

[21] Steve Fox, Kuldeep Karnawat, Mark Mydland, Susan Dumais, and Thomas
White. 2005. Evaluating Implicit Measures to Improve Web Search. ACM Trans.
Inf. Syst. 23, 2 (April 2005).

[22] Jerome Friedman, Trevor Hastie, and Rob Tibshirani. 2010. Regularization paths
for generalized linear models via coordinate descent. Journal of statistical soft-
ware 33, 1 (2010), 1.

[23] gdpr.eu. 2019. General Data Protection Regulation. https://gdpr-info.eu/.
[24] Sonia Haiduc, Gabriele Bavota, Andrian Marcus, Rocco Oliveto, Andrea De Lu-
cia, and Tim Menzies. 2013. Automatic Query Reformulations for Text Retrieval
in Software Engineering. In Proceedings of the 2013 International Conference on
Software Engineering (San Francisco, CA, USA) (ICSE ’13). IEEE Press, Piscat-
away, NJ, USA, 842–851. http://dl.acm.org/citation.cfm?id=2486788.2486898
Improving named
entity translation by exploiting comparable and parallel corpora. ACQUISITION
AND MANAGEMENT OF MULTILINGUAL LEXICONS (2007), 35.

[25] Ahmed Hassan, Haytham Fahmy, and Hany Hassan. 2007.

[26] Ahmed Hassan, Rosie Jones, and Kristina Lisa Klinkner. 2010. Beyond DCG:
User Behavior As a Predictor of a Successful Search. In Proceedings of the
Third ACM International Conference on Web Search and Data Mining (New
York, New York, USA) (WSDM ’10). ACM, New York, NY, USA, 221–230.
https://doi.org/10.1145/1718487.1718515

[27] F. Hassan and Xiaoyin Wang. 2017. Mining Readme Files to Support Automatic
Building of Java Projects in Software Repositories. In 2017 IEEE/ACM 39th In-
ternational Conference on Software Engineering Companion (ICSE-C). 277–279.
https://doi.org/10.1109/ICSE-C.2017.114

Strath-
[28] Reid Holmes, Robert J. Walker, and Gail C. Murphy. 2005.
cona Example Recommendation Tool. In Proceedings of
the 10th Euro-
pean Software Engineering Conference Held Jointly with 13th ACM SIG-
SOFT International Symposium on Foundations of Software Engineering
(Lisbon, Portugal) (ESEC/FSE-13). ACM, New York, NY, USA, 237–240.
https://doi.org/10.1145/1081706.1081744

Characterizing Search Intent Diversity into Click Models.

[29] Botao Hu, Yuchen Zhang, Weizhu Chen, Gang Wang, and Qiang Yang.
In
the 20th International Conference on World Wide Web
(WWW ’11). ACM, New York, NY, USA, 17–26.

2011.
Proceedings of
(Hyderabad,
https://doi.org/10.1145/1963405.1963412

India)

[30] Shagun Jhaver, Justin Cranshaw, and Scott Counts. 2019. Measuring Professional
Skill Development in US Cities Using Internet Search Queries. In Proceedings of
the International AAAI Conference on Web and Social Media, Vol. 13. 267–277.
[31] Z. Jia, S. Li, T. Yu, X. Liao, J. Wang, X. Liu, and Y. Liu. 2019. Detecting Error-
Handling Bugs without Error Speciﬁcation Input. In 2019 34th IEEE/ACM Inter-
national Conference on Automated Software Engineering (ASE). 213–225.
[32] Jiepu Jiang, Ahmed Hassan Awadallah, Xiaolin Shi, and Ryen W. White.
2015. Understanding and Predicting Graded Search Satisfaction. In Proceed-
ings of the Eighth ACM International Conference on Web Search and Data
Mining (Shanghai, China) (WSDM ’15). ACM, New York, NY, USA, 57–66.
https://doi.org/10.1145/2684822.2685319

[33] Siddhartha Jonnalagadda, Trevor Cohen, Stephen Wu, Hongfang Liu, and Gra-
ciela Gonzalez. 2013. Using empirically constructed lexical resources for named
entity recognition. Biomedical informatics insights 6 (2013), BII–S11664.

[2] 2019. CSharp Exception List. https://powershellexplained.com/2017-04-07-all-dotnet-exception-list.

Conference’17, July 2017, Washington, DC, USA

Foyzul Hassan, Chetan Bansal, Nachiappan Nagappan, Thomas Zimmermann, and Ahmed Hassan Awadallah

[34] Kisub Kim, Dongsun Kim, Tegawendé F. Bissyandé, Eunjong Choi, Li Li,
Jacques Klein, and Yves Le Traon. 2018. FaCoY: A Code-to-Code Search En-
gine. In Proceedings of the 40th International Conference on Software Engineer-
ing (Gothenburg, Sweden) (ICSE ’18). Association for Computing Machinery,
New York, NY, USA, 946–957. https://doi.org/10.1145/3180155.3180187
[35] John D. Lafferty, Andrew McCallum, and Fernando C. N. Pereira. 2001. Con-
ditional Random Fields: Probabilistic Models for Segmenting and Labeling Se-
quence Data. In Proceedings of the Eighteenth International Conference on Ma-
chine Learning (ICML ’01). Morgan Kaufmann Publishers Inc., San Francisco,
CA, USA, 282–289. http://dl.acm.org/citation.cfm?id=645530.655813

[36] Chang Liu, Jingjing Liu, and Zengwang Yan. 2018. Personalizing Informa-
tion Retrieval Using Search Behaviors and Time Constraints. In Proceedings
of the 2018 Conference on Human Information Interaction and Retrieval (New
Brunswick, NJ, USA) (CHIIR ’18). Association for Computing Machinery, New
York, NY, USA, 261–264. https://doi.org/10.1145/3176349.3176878

[37] Dong C. Liu and Jorge Nocedal. 1989. On the Limited Memory BFGS Method
for Large Scale Optimization. Math. Program. 45, 1-3 (Aug. 1989), 503–528.
http://dl.acm.org/citation.cfm?id=3112655.3112866

[38] Xiaohua Liu, Shaodian Zhang, Furu Wei, and Ming Zhou. 2011.

Rec-
the 49th An-
ognizing Named Entities
the Association for Computational Linguistics: Human
nual Meeting of
Language Technologies - Volume 1 (Portland, Oregon)
(HLT ’11). As-
sociation for Computational Linguistics, Stroudsburg, PA, USA, 359–367.
http://dl.acm.org/citation.cfm?id=2002472.2002519

In Proceedings of

in Tweets.

[39] Hongyu Lu, Min Zhang, and Shaoping Ma. 2018. Between Clicks and Sat-
isfaction: Study on Multi-Phase User Preferences and Satisfaction for Online
News Reading. In The 41st International ACM SIGIR Conference on Research
and Development in Information Retrieval (Ann Arbor, MI, USA) (SIGIR
’18). Association for Computing Machinery, New York, NY, USA, 435–444.
https://doi.org/10.1145/3209978.3210007

[40] Cheng Luo, Fan Zhang, Xue Li, Yiqun Liu, Min Zhang, Shaoping Ma,
and Delin Yang. 2016. Manipulating Time Perception of Web Search
Users. In Proceedings of
the 2016 ACM on Conference on Human Infor-
mation Interaction and Retrieval (Carrboro, North Carolina, USA) (CHIIR
’16). Association for Computing Machinery, New York, NY, USA, 293–296.
https://doi.org/10.1145/2854946.2854994

[41] Xuezhe Ma and Eduard Hovy. 2016. End-to-end sequence labeling via bi-

directional lstm-cnns-crf. arXiv preprint arXiv:1603.01354 (2016).

[42] Jiaxin Mao, Yiqun Liu, Ke Zhou, Jian-Yun Nie, Jingtao Song, Min Zhang, Shaop-
ing Ma, Jiashen Sun, and Hengliang Luo. 2016. When Does Relevance Mean
Usefulness and User Satisfaction in Web Search?. In Proceedings of the 39th
International ACM SIGIR Conference on Research and Development in Informa-
tion Retrieval (Pisa, Italy) (SIGIR ’16). Association for Computing Machinery,
New York, NY, USA, 463–472. https://doi.org/10.1145/2911451.2911507
[43] Lee Martie, André van der Hoek, and Thomas Kwak. 2017. Understand-
ing the Impact of Support for Iteration on Code Search. In Proceedings of
the 2017 11th Joint Meeting on Foundations of Software Engineering (Pader-
born, Germany) (ESEC/FSE 2017). ACM, New York, NY, USA, 774–785.
https://doi.org/10.1145/3106237.3106293

[44] Rishabh Mehrotra, Ashton Anderson, Fernando Diaz, Amit Sharma, Hanna Wal-
lach, and Emine Yilmaz. 2017. Auditing Search Engines for Differential Satisfac-
tion Across Demographics. In Proceedings of the 26th International Conference
on World Wide Web Companion (WWW ’17 Companion).

[45] Na Meng, Stefan Nagy, Danfeng (Daphne) Yao, Wenjie Zhuang, and Gus-
tavo Arango Argoty. 2018. Secure Coding Practices in Java: Challenges and Vul-
nerabilities. In Proceedings of the 40th International Conference on Software En-
gineering (Gothenburg, Sweden) (ICSE ’18). Association for Computing Machin-
ery, New York, NY, USA, 372–383. https://doi.org/10.1145/3180155.3180201
[46] Stuart E. Middleton and Vadims Krivcovs. 2016. Geoparsing and Geosemantics
for Social Media: Spatiotemporal Grounding of Content Propagating Rumors to
Support Trust and Veracity Analysis During Breaking News. ACM Trans. Inf.
Syst. 34, 3, Article 16 (April 2016), 26 pages. https://doi.org/10.1145/2842604

[47] Mozilla.org.

HTTP.
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language.

Accept-Language

2019.

[48] S. Nanz and C. A. Furia. 2015. A Comparative Study of Programming Languages
in Rosetta Code. In 2015 IEEE/ACM 37th IEEE International Conference on
Software Engineering, Vol. 1. 778–788. https://doi.org/10.1109/ICSE.2015.90

[49] Seyed Mehdi Nasehi, Jonathan Sillito, Frank Maurer, and Chris Burns. 2012.
What makes a good code example?: A study of programming Q&A in Stack-
Overﬂow. In 2012 28th IEEE International Conference on Software Maintenance
(ICSM). IEEE, 25–34.

[50] A. T. Nguyen, P. C. Rigby, T. Nguyen, D. Palani, M. Karanﬁl, and T. N. Nguyen.
2018. Statistical Translation of English Texts to API Code Templates. In 2018
IEEE International Conference on Software Maintenance and Evolution (IC-
SME). 194–205. https://doi.org/10.1109/ICSME.2018.00029

[51] Naoaki Okazaki. 2007. CRFsuite: a fast implementation of Conditional Random

Fields (CRFs). http://www.chokkan.org/software/crfsuite/

[52] K. Ong, K. Järvelin, M. Sanderson, and F. Scholer. 2017. Using Information
Scent to Understand Mobile and Desktop Web Search Behavior. 295–304.
[53] John Paparrizos, Ryen W White, and Eric Horvitz. 2016. Detecting devastating
diseases in search logs. In Proceedings of the 22nd ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining. ACM, 559–568.

[54] Lawrence R. Rabiner. 1990. Readings in Speech Recognition. Morgan Kauf-
mann Publishers Inc., San Francisco, CA, USA, Chapter A Tutorial on Hid-
den Markov Models and Selected Applications in Speech Recognition, 267–296.
http://dl.acm.org/citation.cfm?id=108235.108253

[55] Filip Radlinski and Thorsten Joachims. 2005. Query chains: learning to rank from
implicit feedback. In Proceedings of the eleventh ACM SIGKDD international
conference on Knowledge discovery in data mining. ACM, 239–248.

[56] Md Masudur Rahman, Jed Barson, Sydney Paul, Joshua Kayani, Federico Andrés
Lois, Sebastián Fernandez Quezada, Christopher Parnin, Kathryn T. Stolee, and
Baishakhi Ray. 2018. Evaluating How Developers Use General-purpose Web-
search for Code Retrieval. In Proceedings of the 15th International Conference
on Mining Software Repositories (Gothenburg, Sweden) (MSR ’18). ACM, New
York, NY, USA, 465–475. https://doi.org/10.1145/3196398.3196425

[57] Nikitha Rao, Chetan Bansal, Subhabrata Mukherjee, and Chandra Mad-
Product Insights: Analyzing Product Intents in Web Search.

dila. 2020.
arXiv:2005.08591 [cs.IR]

[58] Ayushi Rastogi, Nachiappan Nagappan, Georgios Gousios, and André van der
Hoek. 2018. Relationship between Geographical Location and Evaluation of
Developer Contributions in Github. In Proceedings of the 12th ACM/IEEE In-
ternational Symposium on Empirical Software Engineering and Measurement
(Oulu, Finland) (ESEM ’18). Association for Computing Machinery, New York,
NY, USA, Article 22, 8 pages. https://doi.org/10.1145/3239235.3240504

[59] Dan Roth and Wen-tau Yih. 2005.

Integer Linear Programming Inference for
Conditional Random Fields. In Proceedings of the 22Nd International Confer-
ence on Machine Learning (Bonn, Germany) (ICML ’05). ACM, New York, NY,
USA, 736–743. https://doi.org/10.1145/1102351.1102444

[60] Caitlin Sadowski, Kathryn T. Stolee, and Sebastian Elbaum. 2015. How
the
Developers Search for Code: A Case Study.
2015 10th Joint Meeting on Foundations of Software Engineering (Berg-
(ESEC/FSE 2015). ACM, New York, NY, USA, 191–201.
amo,
https://doi.org/10.1145/2786805.2786855

In Proceedings of

Italy)

[61] Demóstenes Sena, Roberta Coelho, Uirá Kulesza, and Rodrigo Bonifácio. 2016.
Understanding the Exception Handling Strategies of Java Libraries: An Empirical
Study. In Proceedings of the 13th International Conference on Mining Software
Repositories (Austin, Texas) (MSR ’16). Association for Computing Machinery,
New York, NY, USA, 212–222. https://doi.org/10.1145/2901739.2901757
[62] Milad Shokouhi, Umut Ozertem, and Nick Craswell. 2016. Did You Say U2 or
YouTube?: Inferring Implicit Transcripts from Voice Search Logs (WWW ’16).
1215–1224. https://doi.org/10.1145/2872427.2882994

[63] Susan Elliott Sim, Medha Umarji, Sukanya Ratanotayanon, and Cristina V. Lopes.
2011. How Well Do Search Engines Support Code Retrieval on the Web?
ACM Trans. Softw. Eng. Methodol. 21, 1, Article 4 (Dec. 2011), 25 pages.
https://doi.org/10.1145/2063239.2063243

[64] Renuka Sindhgatta. 2006. Using an Information Retrieval System to Retrieve
Source Code Samples. In Proceedings of the 28th International Conference on
Software Engineering (Shanghai, China) (ICSE ’06). ACM, New York, NY, USA,
905–908. https://doi.org/10.1145/1134285.1134448

[65] Kathryn T. Stolee, Sebastian Elbaum, and Daniel Dobos. 2014. Solving the
Search for Source Code. ACM Trans. Softw. Eng. Methodol. 23, 3, Article 26
(June 2014), 45 pages. https://doi.org/10.1145/2581377

[66] Jeffrey Stylos and Brad A Myers. 2006. Mica: A web-search tool for ﬁnding api
components and examples. In Visual Languages and Human-Centric Computing
(VL/HCC’06). IEEE, 195–202.

[67] B. Vasilescu, V. Filkov, and A. Serebrenik. 2013. StackOverﬂow and GitHub:
Associations between Software Development and Crowdsourced Knowledge. In
2013 International Conference on Social Computing. 188–195.

[68] Anthony J. Viera and Joanne M. Garrett. 2005. Understanding interobserver

agreement: the kappa statistic. Family Medicine 37.5 (2005), 360–363.

[69] Yefeng Wang. 2009. Annotating and Recognising Named Entities in Clinical
Notes. In ACL 2009, Proceedings of the 47th Annual Meeting of the Association
for Computational Linguistics and the 4th International Joint Conference on Nat-
ural Language Processing of the AFNLP, 2-7 August 2009, Singapore, Student
Research Workshop. 18–26.

[70] Qikang Wei, Tao Chen, Ruifeng Xu, Yulan He, and Lin Gui. 2016. Disease
named entity recognition by combining conditional random ﬁelds and bidirec-
tional recurrent neural networks. Database 2016 (2016).

[71] Xin Xia, Lingfeng Bao, David Lo, Pavneet Singh Kochhar, Ahmed E.
search
Empirical Software Engineering 22 (04 2017).

Hassan, and Zhenchang Xing. 2017.
for on the web?
https://doi.org/10.1007/s10664-017-9514-4

What do developers

[72] Hongyu Zhang, Anuj Jain, Gaurav Khandelwal, Chandrashekhar Kaushik, Scott
Ge, and Wenxiang Hu. 2016. Bing Developer Assistant: Improving Developer
Productivity by Recommending Sample Code. In Proceedings of the 2016 24th

An Empirical Study of Software Exceptions in the Field using Search Logs

Conference’17, July 2017, Washington, DC, USA

ACM SIGSOFT International Symposium on Foundations of Software Engineer-
ing (Seattle, WA, USA) (FSE 2016). Association for Computing Machinery, New

York, NY, USA, 956–961. https://doi.org/10.1145/2950290.2983955

