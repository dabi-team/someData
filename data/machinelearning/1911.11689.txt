Join Query Optimization with Deep Reinforcement
Learning Algorithms

Jonas Heitz
Zurich University of Applied Sciences
Switzerland
J.Heitz@bluewin.ch

Kurt Stockinger
Zurich University of Applied Sciences
Switzerland
Kurt.Stockinger@zhaw.ch

9
1
0
2

v
o
N
6
2

]

B
D
.
s
c
[

1
v
9
8
6
1
1
.
1
1
9
1
:
v
i
X
r
a

ABSTRACT
Join query optimization is a complex task and is central to
the performance of query processing. In fact it belongs to
the class of NP-hard problems. Traditional query optimizers
use dynamic programming (DP) methods combined with a
set of rules and restrictions to avoid exhaustive enumeration
of all possible join orders. However, DP methods are very
resource intensive. Moreover, given simplifying assumptions
of attribute independence, traditional query optimizers rely
on erroneous cost estimations, which can lead to suboptimal
query plans.

Recent success of deep reinforcement learning (DRL) cre-
ates new opportunities for the ﬁeld of query optimization
to tackle the above-mentioned problems. In this paper, we
present our DRL-based Fully Observed Optimizer (FOOP)
which is a generic query optimization framework that en-
ables plugging in diﬀerent machine learning algorithms. The
main idea of FOOP is to use a data-adaptive learning query
optimizer that avoids exhaustive enumerations of join orders
and is thus signiﬁcantly faster than traditional approaches
based on dynamic programming. In particular, we evaluate
various DRL-algorithms and show that Proximal Policy Op-
timization signiﬁcantly outperforms Q-learning based algo-
rithms. Finally we demonstrate how ensemble learning tech-
niques combined with DRL can further improve the query
optimizer.

1.

INTRODUCTION

Query optimization has been studied over decades and
is one of the key aspects in database management systems
(DBMS). However, one of the biggest challenges in query op-
timization is join order optimization, i.e. to ﬁnd the optimal
order of executing joins such that the query costs and hence
the query execution time is minimized [21]. Since join order
optimization belongs to the class of NP-hard problems [16],
exhaustive query plan enumeration is a prohibitive task for
large databases with multi-way join queries. Hence, query

optimization is often considered as a trade-oﬀ between the
quality of a query plan and the time spent optimizing it.

Query optimization strategies of many commercial DBM-
Ses are based on ideas introduced in System R [2] or in the
Volcano Optimizer Generator [8]. These systems use dy-
namic programming (DP) combined with a set of rules to
ﬁnd good query plans. These rules prune the search space
of potential query plans, which reduces the time spent op-
timizing the query but also lowers the chance that the op-
timal query plan is found in the large search space. Tra-
ditional query optimizers suﬀer from a second issue besides
the limitation of the search strategies. They rely on cost
models to estimate the cost of executing a query. These
cost models are built on cardinality estimations which are
based on quantile statistics, frequency analysis or even non-
theoretically grounded methods [16]. Errors in the cardinal-
ity estimation often lead to suboptimal query plans. More-
over, traditional query optimizers do not learn from prior
executed queries. Even though concepts of learning opti-
mizers are around since LEO [32], these approaches have
not been widely adopted. As the work of Leis et al.
[16]
shows, there is a need for data-adaptive learning query op-
timizers for large analytical databases.

Recent success in deep reinforcement learning (DRL) has
brought new opportunities to the ﬁeld of query optimiza-
tion. For example, ReJoin [21] and DQ [14] propose their
approaches to use DRL to optimize join queries. Both pa-
pers apply diﬀerent DRL algorithms in their query opti-
mizers. However, there is no generic query optimization
framework which allows studying diﬀerent machine learning
algorithms and hence enables a direct comparison between
diﬀerent methods.

In this paper we introduce a DRL-based Fully Observed
Optimizer (FOOP) for databases. FOOP allows reinforce-
ment learning (RL) algorithms to track all relations and
intermediate results during the query optimization process,
similar to the observations during a game of Go [31]. FOOP
is inspired by ReJoin [21] and DQ [14] and enhances them
with the most recent modules introduced in DLR research
like Double Deep Q-Networks and Priority Replay. We show
that FOOP produces query plans with similar quality to
traditional query optimizers using signiﬁcantly less time for
optimization.

1

 
 
 
 
 
 
The paper makes the following contributions:

• With FOOP we introduce query optimization as a fully
observable RL problem, which allows RL algorithms to
track all relations and intermediate results during the
optimization process. We place FOOP in the applica-
tion layer, which makes the optimizer DBMS indepen-
dent.

• To the best of our knowledge, this paper presents the
ﬁrst face-to-face comparison of DRL algorithms vanilla
Deep Q-Network, Double Deep Q-Network with Prior-
ity Replay and Proximal Policy Optimization in query
optimization.

• FOOP produces query plans with cost estimations in a
similar range to traditional query optimizers by using
optimization algorithms with signiﬁcantly lower run-
time complexity.

The paper is organized as follows. Section 2 reviews the
literature in the areas of query optimization. Section 3 pro-
vides the background knowledge about query optimization
and the basics of reinforcement learning. Section 4 intro-
duces the architecture and the featurization of our learning
optimizer FOOP. Section 5 provides a detailed evaluation of
the experiments with FOOP. Finally, we present our conclu-
sions and future work in Section 6.

2. RELATED WORK

Query optimization is a well-studied problem in the data-
base community with many diﬀerent solutions proposed over
the last decades. Pioneering work dates back to static query
optimization of System R [2] and the Vulcano Optimizer
Generator [8], which has been widely used in commercial
systems [10]. Later, researchers introduced new architec-
tures for query optimization, where queries are continuously
optimized and validated during query processing [3] [23]. In
2001 IBM introduced the learning optimizer LEO for DB2,
which is based on the architecture of static query optimiza-
tion and is able to learn from its mistakes [32].

Lohman states in his blog post [18] that query optimiza-
tion is still a unsolved problem and pointed out that most
query benchmarks used in research do not reﬂect databases
in the real world. Leis et al. picked up on that thought and
created a new query benchmark to demonstrate the issues
of query optimizers in commercial DBMSes [16].

Recent progress in machine learning established new ways
to tackle those open problems. For instance, some approaches
try to mitigate the issue of cardinality estimation errors by
introducing machine learning models to predict the costs or
the execution time of queries [39] [38] [1] [5] [17] [20].

Others apply more modern machine learning approaches
leveraging recent advanced in reinforcement learning [37]
[22]. The main idea of [22] is to automatically tune a particu-
lar database and to improve the performance of query execu-
tion by using the feedback from past query executions. Oritz
et al. studied how state representation aﬀects query opti-
mization when using reinforcement learning [27] for static
query optimization. The Skinner DB system uses reinforce-
In
ment learning for continuous query optimization [36].
that approach, queries are dynamically improved on the
base of a regret bounded quality measure. Most recently
Marcus et al. introduced the end-to-end learning optimizer

Neo [19] which is inspired by AlphaGo [31]. Neo uses a
learned cost model based on neuoral networks (NN) to guide
a search algorithm through the large search space of all pos-
sible query plans. The approach was motivated by the NN-
guided Monte Carlo Tree Search which got famous through
AlphaGoZero.

For our paper, we focus on Q-learning and policy gradi-
ent based reinforcement learning, which got popular after
the publication of the Atari paper by DeepMind [24]. The
closest works to ours are ReJoin [21] and DQ [14]. ReJoin
uses policy gradient methods to ﬁnd a good policy for join
order enumeration, whereas DQ focus on a Deep Q-Network
architecture to optimize their query plans. Both papers rely
on traditional cost models to ﬁnd optimal query plans –
which is suboptimal in terms of erroneous cardinality esti-
mations. However, DQ introduces a mechanism to ﬁne-tune
their Deep Q-Network on the query execution times to mit-
igate this issue. The advantage of Deep-Q-Networks and
policy gradient methods over the NN-guided plan search of
Neo is the shorter training time.

The key advantage of our approach over all other ap-
proaches is that we provide a generalized architecture, which
allows to use diﬀerent front line RL algorithms with minimal
eﬀort. FOOP places the query optimizer in the application
layer which makes the approach DBMS independent. Fur-
ther, we introduce query optimization as a fully observed
RL problem, which allows the RL algorithms to learn new
aspects about the query execution performance which might
be diﬃcult to achieve with traditional cost-based optimiz-
ers.

3. BACKGROUND

In this section, we provide background knowledge about
query optimization and reinforcement learning (RL). First,
we elaborate why query optimization is still an unsolved
problem and its main issues. Later we give a brief intro-
duction into RL and describe the methods we use for our
learning query optimizer.

3.1 Query Optimization

The goal of a query optimizer in a database system is to
translate queries, which are written in a declarative language
(e.g. SQL), into an eﬃcient query execution plan.

3.1.1 Complexity

To understand the complexity of query optimization, we
look at the join optimization problem, a sub problem of
query optimization in database systems. Join order opti-
mization is the task of ﬁnding the best arrangement of re-
lations (tables) in a multi-way join such that the estimated
execution cost is minimized. In other words, we try to ﬁnd
best query execution plan for a given query.

One of the simplest solutions to solve this optimization
problem is to only consider all possible permutations of those
relations that are involved in the join. In this case, every
(join) query with n relations can be expressed with n! diﬀer-
ent join paths. For instance, the query ’A (cid:46)(cid:47) B (cid:46)(cid:47) C’ could
be executed either as ’A (cid:46)(cid:47) B (cid:46)(cid:47) C’, or ’C (cid:46)(cid:47) B (cid:46)(cid:47) A’, or
’A (cid:46)(cid:47) C (cid:46)(cid:47) B’ etc. This problem has the complexity O(n!).
The simplifying assumption for this complexity estimation
is to not distinguish between the left-side and the right-side
of the join operators. However, a query optimizer also needs
to take into account aspects of physical query optimization.

2

For instance, a join could be executed as a nested loop join,
a hash join, a sort-merge join, etc. As a consequence, the
complexity of query optimization grows rapidly. According
to the principal of Catalan Numbers [4], the number of all
possible binary (query) tree shapes for a j-way-join-query is
(2j)!/(j! ∗ (j + 1)!) [4], where a j-way-join has n relations
(j = n − 1).

As a running example for this paper, assume a small

database with the following schema depicted in Figure 1:

Figure 1: Sample database

Further assume that we want to optimize the following
query:
’P (cid:46)(cid:47) OI (cid:46)(cid:47) O (cid:46)(cid:47) C’. Let us now analyze all pos-
sible query plans for the above-mentioned query. Figure 2
shows some binary tree shapes (query execution plans) of
our three-way-join-query.

Figure 2: Some possible binary-tree shapes for a three-way-
join-query (P refers to product, OI to orderItem, O to order
and C to customer).

The complexity of the problem even rises, if we consider
multiple diﬀerent join algorithms or additional methods like
selections, projections, etc. The query optimization litera-
ture often uses just the lower bound complexity of Ω(n!).
However, ﬁnding an optimal query plan in a large search
space of Ω(n!) is daunting task. Moreover, since join oper-
ations of relational database systems are commutative and
associative, it is not surprising that query optimization be-
longs to the class of NP-hard problems [13].

3.1.2 Components

In this subsection we look into the key components of a
query optimizer. Many DBMSes follow the traditional text-
book architecture of System R [2] and the Volcano Optimizer
Generator [8]. The architecture of these query optimizers is
modular and consists of at least two components that we
will analyze below. Moreover, we use PostgreSQL [34], as a
representative of widely used open source DBMS, to show
how those modules are implemented.

3

• Query planner: The planner (also called plan enu-
merator) is the central module of the optimizer. It ex-
amines various possible query plans and chooses the
optimal one based on a certain cost model. How-
ever, since exhaustive enumeration of all possible query
plans is often computationally too expensive [9], query
planers typically use heuristics to reduce the search
complexity. For instance, System R uses dynamic pro-
gramming combined with a set of rules, to reduce the
search space [13]. Also PostgreSQL uses a dynamic
programming algorithm but switches to a greedy or
genetic approach if a query exceeds a certain size [16].
To reduce the complexity of the problem, traditional
query optimizers typically only consider left-deep query
trees and prohibit Cartesian products [13].

• Cost model: The cost model delivers the cost es-
timations for a query plan according to diﬀerent as-
sumptions and statistics about the database [9].
In
the case of PostgreSQL, the cost model uses a com-
plex combination of estimated CPU-, I/O-costs and
cardinality estimations [16]. Further more, the cardi-
nality is predicted in simple cases (e.g.
for the base
table) with quantile statistics, frequency analysis or
distinct counts. For complex predicates, PostgreSQL
uses non-theoretically grounded constants [16].

3.1.3 Open Issues

There are multiple unsolved issues in query optimization.

In the following we present three of them:

• Query planner limitations: Many query optimizers
only use left-deep query trees, since exhaustive enu-
meration would be too time consuming. The target of
this constraint is to lower the complexity of the prob-
lem to O(n!) [13]. However, this approach reduces the
chance that the optimizer ﬁnds the optimal query plan.
Usually the best left-deep query tree is close to the op-
timal query plan. Unfortunately, that is not true for
large analytical databases in combination with com-
plex queries, where this search space reduction can
have time consuming consequences during query ex-
ecution [16].

• Query optimization benchmarks: Traditional query
optimizers do not work well with databases where the
values between diﬀerent columns are correlated or ta-
bles contain data following non-uniform distributions.
Real world data sets are usually non-uniformly dis-
[16]
tributed and are highly correlated, as Leis et al.
pointed out. Further, they showed that the bench-
marks TPC-H, TPC-DS and the Star Schema Bench-
mark (SSB), which are mainly used to compare and
evaluate query optimizers, are based on data sets with
uniform distribution and independent columns [16].
This means that traditional query optimizers, that are
tuned based on these benchmarks, are optimized on a
corner case, which does not represent the majority of
real world databases [16].

• Estimation errors: Further quantile statistics can
be misleading on data sets with a non-uniform distri-
bution and the correlated columns cannot get detected

since the various columns do not get compared in tra-
ditional query optimizers. These issues result in esti-
mation errors from the cost model. Faulty cost estima-
tions lead the planner on a wrong track to suboptimal
query plans [9].

3.2 Reinforcement Learning (RL)

Reinforcement learning can be considered as ”learning
what to do” with the goal to map situations to actions [33] –
which gets close to our understanding of the nature of learn-
ing. Consider, for instance, an infant waving its arms and
looking around trying to interact with the environment. At
this stage the infant does not have a teacher, it just pro-
duces information about cause and eﬀect, which action has
which consequence [33].

When we look at this paradigm from a computer science
perspective, we can interpret it as a function. The function
tries to maximize a reward signal, without being told which
action it has to take [33]. Bellmann’s ’Principle of Opti-
mality’ and the concept of dynamic programming laid the
foundation for RL to be applied in computer science [14].
Dynamic programming has is already been used in query
optimization for decades. Moreover, recent improvements
in deep reinforcement learning seem to be a promising solu-
tion for query optimization. Hence, we will now revise the
main concepts of reinforcement learning that we use for our
query optimizer.

First we introduce the Markov Decision Process [14] as
the foundation of RL. Afterwards we discuss Q-learning and
Policy Gradient Methods [33].

3.2.1 Markov Decision Process (MDP)

From a technical perspective, RL is a class of stochastic
optimization methods that can be formulated as a Markov
Decision Process (MDP) [14]. The basic idea is that an
agent takes a sequence of actions with the goal to optimize
a given objective in an MDP model.

MDPs are an extension of Markov Chains and have to sat-
isfy the Markov Property, i.e. future state progressions only
depend on the current state and not on states and actions
taken in the past. An MDP is therefore formalized as the
following ﬁve-tuple [14]:

(cid:104)S, A, P (s, a), R(s, a), S0(cid:105)

(1)

• S stands for states in which the agent can be.

• A stands for actions the agent can take to get to a new

state.

• St+1 ∼ P (s, a) is the new state you reach through tak-

ing action a in state s.

• R(s, a) stands for the reward the agent receives for

being in state s and taking action a.

• S0 is the initial state the in which agent starts.

The overall goal is to ﬁnd a decision policy π : S (cid:55)→ A
(a function that maps states to actions), such that the ex-
pected reward is maximized [14]. Therefore, MDPs can be
considered as a ”learning from interactions”. Figure 3 illus-
trates how these interactions work: The agent is the learner,
takes actions and interacts with the environment. Moreover,

the agent receives state information and rewards form the
environment [33]. The state information is encoded and typ-
ically called observations.

Figure 3: Agent-environment interface for MDP interaction

3.2.2 Q-learning

Temporal-Diﬀerence (TD) learning is a central concept of
RL. It combines the ideas of Monte Carlo (MC) and Dy-
namic Programming (DP). TD learns directly from raw ex-
perience like MC and updates estimates without waiting for
the ﬁnal outcome like DP [33]. One of these TD control
algorithms is called Q-learning, that learns the action-value
function Q(s, a). This function tells the agent how good it
is to take action a while being in the state s.

Q-learning is an oﬀ-policy function, which means it is in-
dependent of the policy being followed. This simpliﬁes the
analysis of the algorithm drastically and allows fast conver-
gence. Nevertheless, the current policy has an inﬂuence,
since it determines which state-action pairs are visited and
updated [33].

In traditional Q-learning there is a memory table which
stores all Q-values [33]. However, typically there are too
many combinations of states and actions to store and to
compute in query optimization and other RL problems. To
overcome that, we need to approximate the action-value
function Q(s, a). Any function approximator can be used,
e.g. linear functions, non-linear functions, etc.

Neural networks (NN) have proven to be a good function
approximator for non-linear functions [6]. So it is not sur-
prising that the combination of NNs and RL are the key idea
behind the recent success of autonomously playing Atari [25]
and Go [31]. Relating to the Q-function approximation,
Mnih et al.
[25] introduced the Deep Q-Network (DQN).
The major challenges for using NNs in RL is that the in-
puts for the NN have to be independent [6]. However, the
input data is correlated by deﬁnition, since we collect expe-
rienced observations in RL during execution. To overcome
this problem, Mnih et al.
[25] proposed experience replay
and target network :

• Experience replay: Experience replay is a buﬀer of
historically gathered observation data from which the
NN can randomly sample. This makes the training
process more independent [25].

• Target network: There are two identical NNs cre-
ated (θ−, θ). The ﬁrst NN is trained on all state-value
updates. At certain intervals, the ﬁrst NN sends the
trained weights to the second NN, which does not re-
quire additional training. The second network can thus

4

be used to fetch the Q-values. This method helps to
stabilize the training process [25].

The problem can now be expressed with a maximization
function shown in Equation 2, which is optimized using
stochastic gradient descent.

L = Rt+1 + γt+1maxQ(St+1, At+1; θ−

t ) − Q(St, At; θt)2 (2)

• St, At, Rt are the state, action and reward at time t.

• γ is the discount factor for the long term reward.

• Q() is the Q-function and θ, θ− are the weights of the

NN which approximates the Q-function.

The introduction of DQNs has been a major milestone in
DRL. However, there are still several limitations. Hence,
Hessel et al. [11] summarized and combined some methods
to improve the ”vanilla” DQN. Some of their improvements
are as follows:

• Double DQN (DDQN): In standard DQNs, the
learning process is aﬀected by an overestimation bias,
resulting from the maximization step in Equation 2.
DDQNs reduce the overestimation by using decoupling
techniques, as shown in Equation 3 [11].

L =Rt+1 + γQ(St+1, maxQ(St+1, At+1; θ−

t ); θt)−

Q(St, At; θt)2

(3)

• Prioritized replay: DQNs with experience replay
sample uniformly from the replay buﬀer.
’Ideally, we
want to sample those transitions, from which there is
much to learn, more frequently’ [11]. Schaul et al. [29]
propose to sample transitions with the probability pt,
which is relative to the last encountered absolute TD
error, as a measurement for the learning potential:

pt ∝ |r + γmaxQ(St+1, At+1; θ−) − Q(St, At; θ)| (4)

To bias the model towards recent transitions, the new
inserted transitions receive maximum priority [11].

3.2.3 Policy Gradient Methods

So far we talked about action-value methods, which learn
values of actions and then select actions based on their es-
timated action value. Policy Gradient Methods work dif-
ferently. They learn a parameterized policy πθ that selects
actions without consulting a value function.

Nevertheless, the value function is still used to learn the
policy parameter [33]. θ represents the vector of the policy
parameters. RL aims to identify the policy parameter θ,
which optimizes the expected reward Rπ(θ). Unfortunately,
it is not possible to compute Rπ(θ) precisely, because that
would mean to exhaustively compute every possible path.
This is why gradient methods search for the optimal policy
parameters θ with an estimator E, i.e. the gradient of the
reward (E(θ) ≈ ∇θRπ(θ)) [21]. The policy πθ can be repre-
sented as a NN, where the vector θ is used as the weights of
the NN. This method is called policy gradient deep learning
[21].

Many policy gradient methods are computationally too
complex for real world tasks. The issue is due to the natu-
ral policy gradient, which involves a second-order derivative
matrix. Proximal Policy Optimization (PPO) introduced
by Schulman et al.
[30] is one of the policy gradient deep
learning methods which uses a diﬀerent approach. It real-
izes fast convergence and reliable performance from Trust
Region Policy Optimization (TRPO), while using a ﬁrst or-
der optimizer like gradient descent. Similar to TRPO, PPO
initializes a trust region in which the algorithm is allowed to
look for a better policy [30]. In TRPO a surrogate objective
function is deﬁned, which is maximized to a constraint based
on the size of the policy update. This problem can be ap-
proximately solved using the conjugate gradient algorithm
after a linear approximation to the objective function and
a quadratic approximation to the constraint [30]. In PPO,
the constraint is formulized as a penalty in the objective
function to avoid the quadratic approximation.

A step further, PPO can also be implemented with the

Clipped Surrogate Objective function [30].

rt(θ) =

πθ(At|St)
πθold (At|St)

(5)

In the equation above, πθ is the new policy and πθold
is the old policy. The advantage of this function is that
instead of penalising large policy changes, these changes are
discouraged if they are ”outside of the comfort zone” as
shown in Equation 6.

LCLIP = Et[min(rt(θ) ˆAt, clip(rt(θ), 1 − (cid:15), 1 + (cid:15)) ˆAt)]

(6)

The comfort zone is deﬁned with the hyperparameter (cid:15).
clip(rt(θ), 1 − (cid:15), 1 + (cid:15)) is the clipping function, which clips
the probability ratio of the surrogate objective. ˆAt is the
advantage estimation function at time step t. At the end,
we take the minimum of the clipped and unclipped objective,
so that the ﬁnal objective is the lower (pessimistic) bound
[30].

3.2.4 Concluding Remarks on RL

In summary, experimental results show that PPO reaches
high performance based on a simplistic model, while Q-
learning with function approximation is poorly understood
and suﬀers from a lack of robustness [30]. In this paper we
will test this hypothesis and perform a direct comparison of
these important DRL methods applied to query optimiza-
tion.

4. ARCHITECTURE

In this section we introduce FOOP - a Fully Observed
Optimizer - that uses RL for query optimization. In a ﬁrst
step, we show how to model query optimization as a Markov
Decision Process (MDP). Secondly, we discuss how to rep-
resent queries and database information as feature vectors
that can be used for deep reinforcement learning. The major
research challenge is to ﬁnd a good feature representation as
well as the right reinforcement learning algorithm such that
the learning process produces a model which generalizes well
and does not get trapped in local optima or never stabilizes.

5

4.1 Modeling

To express a problem as an RL problem, we need to for-
mulate it as an MDP, which consists of a ﬁve-tuple, as men-
tioned in Equation 1 in Section 3.2.1. For the sake of read-
ability, we repeat the speciﬁcation here:

(cid:104)S, A, P (s, a), R(s, a), S0(cid:105)

(7)

We will now walk through each of these components and
describe them with concrete examples based on our sample
database shown in Figure 1 and the query ’P (cid:46)(cid:47) OI (cid:46)(cid:47) O (cid:46)(cid:47)
C’:

• S (states): The states are all possible (sub)query plans.
The complete query plans are the terminal states. Since
FOOP is fully observed, we show all involved relations
at any time. For our sample query, a sub set of all
states is as follows:
S = [P ; OI; O; C], [(P, OI); O; C], [(OI, P ); O; C], ...

In the example above, every state is represented by
square brackets ”[]”. For instance, [P;OI;O;C] is the
initial state. Each relation that is not joined yet,
is separated with a semicolon. The second state is
[(P,OI);O;C] where the parentheses ”()” indicate a sub
query plan.

• A (actions): The actions are all possible joins included
in all query plans. Hence, the total action space is a
list with a size larger than n! where n is the number
of relations contained in all queries. For our running
example, the action space is as follows:

A = (P (cid:46)(cid:47) OI), (OI (cid:46)(cid:47) P ), (OI (cid:46)(cid:47) O), (O (cid:46)(cid:47) C),
(C (cid:46)(cid:47) O), (C (cid:46)(cid:47) B), ...

In Section 4.2.2 we will discuss a potential simpliﬁca-
tion to reduce the complexity of the action space.

• St+1 ∼ P (s, a) is the new state you reach when you

are in state s and take action a. Assume
s = [(P, OI); O; C] and a = (C (cid:46)(cid:47) O). Then the new
state is P (s, a) = [(P, OI); (C, O)].

• R(s, a) is the reward being in state s while taking ac-
tion a: The rewards are the negative costs of the re-
sulting query plan. The costs are evaluated only in
a terminal state. In other words, FOOP only receives
the costs for the ﬁnal query plan and not for sub query
plans. We introduce the cost model and the reward
handling in Section 4.2.3.

• S0 for initial state: The initial state is: [P ; OI; O; C].

4.2 Featurization

RL learning algorithms need an environment in which
they can interact with the MDP as explained in Section
3.2.1. We will now describe all the components of the agent-
environment that are necessary to solve a query optimization
problem with reinforcement learning.

4.2.1 Observation/State

An observation represents the state in which the agent
currently is. Since we want to provide as much information
as possible to our learning algorithms, we formulate query
optimization as a fully observed RL problem. Hence, the

information of the database and the respective queries have
to be encoded in such a way that the representation can
be learned by the RL algorithms. The encoded observation
serves as input for a neural network (NN) in order to learn
from the observations.

For the encoding we followed partly the idea of Krishnan
et al.
[14], where each column of the database is used as
a single feature. A state is represented as a binary one-
hot vector where every digit represents a column of the
database. The size of the vector corresponds to the number
of all columns over all tables. This vector is used twice (see
left example in Figure 4): The ﬁrst vector represents the
original query and marks which columns are involved in the
query. Since the query involves all tables, all columns are
set to 1. The second vector represents the state of the sub
query plan. In initial state S0 all columns are set to zero.

The next step is to perform an action. In this case, ac-
tion A0 suggests to execute the sub query C (cid:46)(cid:47) O. As a
consequence, state S1 needs to be updated. In particular,
all columns that are involved in this join need to be set to 1
in the second vector. Afterwards action A1 is executed and
state S2 needs to be updated, etc.

Our proposed approach FOOP extends that idea as you
can see on the right side in Figure 4. Instead of just having
a vector that represents the currently joined sub query, we
create a symmetric matrix. This matrix represents a table
or a sub query in each row. All rows of the matrix together
include the needed tables for the ﬁnal query. With this
matrix, we represent the whole database during the process
of query execution.

In the initial state S0, the matrix represents all necessary
tables for the query in a separate row. For instance, row 0
has the ﬁrst three bits set to represent table P. Row 1 has
the bits 4 to 6 set, to represent table OI, etc.

Then action A0 performs the sub query C (cid:46)(cid:47) O, which
involves the tables O and C that are represented by the
vector [3 2].

Next, state S1 needs to be updated. We can see that
rows 0 and 1 still represent the tables P and OI, i.e. the
respective columns are set to 1. However, row 3 contains
the result of the join (C (cid:46)(cid:47) O). Due to the fact that the
input vectors of NNs always have to have the same size, we
are forced to keep row 2 as an empty row.

In every further step we add a table to the sub query, until
there is just the ﬁnal query left as presented in the last step
S3.

The advantage of our new featurization approach is as fol-
lows: The reinforcement agent knows at any state which sub
queries still have to be joined to reach a terminal state. In
addition, the agent also sees which sub queries were already
joined in the past.

4.2.2 Actions

We will now discuss how agents take actions and thus
provide details on how we construct the action space. To
create our action space, we can come back to our observa-
tion matrix. Every row of the observation matrix is a join
candidate, as you can see in state S0 of Figure 5. To con-
struct the action space, we take all combinations of all join
candidates for joining two tables.

This results in an action space of n ∗ (n − 1), where n is
the total number of tables in the database (as shown in the
lower half of Figure 5). For instance, row 0 represents the

6

Figure 4: Observation featurization in DQ by Krishnan et al. and FOOP presented on the sample query ’P (cid:46)(cid:47) OI (cid:46)(cid:47) O (cid:46)(cid:47) C’
using the sample database shown in Figure 1.

join P (cid:46)(cid:47) OI. Row 1 represents the join P (cid:46)(cid:47) O, etc. In
our example, we assume that row 11 (which is highlighted
in yellow) is selected by a random agent.

Figure 5: Action featurization in FOOP

As mentioned in Section 4.2.1 there are empty rows in the
observation matrix, during the query optimization process.
This means, not all rows in our observation matrix are valid
join candidates. Due to that, we have invalid actions (high-
lighted in light gray) in our action space, as you can see in
the right lower part of Figure 5. All these actions are invalid
since they would join row 2, which is an empty row and thus
not a join candidate.

Having invalid actions is a common issue in DRL. We
solved that issue by creating an action masking layer in the
NN, similar to the approach of Lee et al.
for playing au-
tonomously StarCraft II [15]. The basic idea is that the
output layer of the NN is multiplied with an action mask.
This results in a new output, where the values of the invalid
actions are set to zero. The action mask has the size of all

7

possible actions (valid actions are represented with a 1 and
invalid actions with 0).

4.2.3 Reward

We will now discuss how agents receive a reward when ex-
ecuting an action. A reward is deﬁned as the negative costs
of a query plan. Unfortunately, it would be too time con-
suming to execute every planed query on a DBMS. There-
fore, we need to fall back to cost models of traditional query
optimizers. Even though these cost models are sometimes
erroneous, they serve as good priors for training a machine
learning model. We will now introduce the cost model and
show how we integrate it into the agent environment.

• Cost Model: We decided to take the cost model,

which was introduced in [16]:

C(Q) =






τ ∗ |R|;
... if Q = R
|Q| + C(Ql) + C(Qr);
... if Q = Ql (cid:46)(cid:47)hj Qr
C(Ql) + λ ∗ |Ql| ∗ max( |Ql(cid:46)(cid:47)R|)
|Ql|
... if Q = Ql (cid:46)(cid:47)ij Qr, Qr = R

, 1);






(8)

In the Equation 8 above,

– R stands for a base relation.

– Q stands for a (sub)query, where Ql is the left

side of a join and Qr the right side.

– τ ≤ 1 is a parameter, which discounts a table scan

compared to a join.

– λ ≥ 1 is a constant to approximate by how much
an index lookup is more expensive than a hash
table lookup.

– |

| stands for the cardinality estimation function.

– hj and ij stand for hash join and index nested

loop join, respectively.

The cost model is tailored for main-memory databases.
That means it only measures the number of tuples that
pass through each operator and it does not take I/O
costs into account. Further, it only distinguishes be-
tween hash joins (hj) and index nested loop joins (ij).
This cost model is very simplistic compared to cost
models of commercial DBMSes. Nevertheless it per-
forms very similar to the cost model of PostgreSQL
as Leis et al.
[16] pointed out. We set the constants
according to the paper (τ = 0.2, λ = 2) [16].

• Reward Mapping: As mentioned above, the nega-
tive costs are the reward for our RL model. The cost
model applied on a large database produces cost values
in the range of 106 to 1018. DRL methods usually op-
erate with reward values in the range (-10,10). Hence,
we need to normalize the cost values to a usable range
for the RL algorithms. We use a square root func-
tion shown in Equation 9 to normalize the cost values.
Linear normalization did not work well, due to the dis-
tribution of the cost values.

N (Q) =

√

(cid:112)C(Q)
upperbound

∗ −10

(9)

Since good query plans are just a small fraction of the
whole space of all possible query plans, we clip our
reward space. In Figure 6 you see the mapping of the
cost values to the reward. The square root function is
applied on all cost values lower than 1013, with 1013
as the upperbound. The cost values bigger than 1013
are clipped to the min reward of −10.

Figure 6: Mapping of the costs values to the reward scale
(-10,0).

5. EVALUATION

In this section, we present and discuss the results of the
experiments using various reinforcement learning techniques
for query optimization. In particular, we will address the
following research questions:

• How eﬀective are Q-learning and policy gradient-based
reinforcement learning approaches for query optimiza-
tion?

8

• Which of these approaches shows the best performance?

• Can we even further improve the above mentioned ap-
proaches by applying ensemble learning techniques?

5.1 Experimental Setup

All experiments were performed on a laptop running Ubun-
tu version 18.04.1 with a 4-core Intel Core i7 8650U CPU
(1.90-4.20 GHz), 16 GB of RAM and no GPU module.

We implemented our approach1 as an extension of gym
from OpenAI [26] in Python. This allows using the RL
interface from OpenAI and the baseline RL algorithms pro-
vided by Ray RLLib [35]. The NN models are written with
Tensorﬂow [7]. Our query optimizer is located in the ap-
plication layer, so we are independent from the DBMS. To
calculate the expected costs as explained in Section 4.2.3
we use the cardinality estimator from PostgreSQL 10.6 [34].
Furthermore, for our end-to-end performance experiment we
use PostgreSQL 10.6 [34] as the query execution engine.

For the evaluation we use the Join Order Benchmark (JOB)
introduced by Leis et al.
[16]. The benchmark consists of
queries with 3 to 16 joins, with an average of 8 joins per
query. There are 33 diﬀerent query structures. Each struc-
ture exists in 2 to 6 diﬀerent variants, which results in a
query set of 113 queries. All queries are realistic in a sense
that they answer a question of a movie enthusiast and are
not constructed to ’trick’ a query optimizer [16].

JOB is based on the IMDB data set [12], which is freely
available. The IMDB is a real-world data set consisting of
21 tables. It contains information about movies and movie
related facts like actors, directors etc. We use the same
[16] do. The data
snapshot from May 2013 as Leis et al.
set comprises 3.6 GB of highly correlated and non-uniformly
distributed data. The largest tables are: cast inf o with 36
million rows and movie inf o with 15 million rows [16].

If not further speciﬁed, all results are presented on all 113
JOB queries. To ensure that the performance is evaluated
only on queries which have not been seen by the model dur-
ing training, we use the 4-fold cross validation introduced
by Krishnan et al.
[14]. Each of the 113 queries occurs at
least in one test set. The train and test sets consist of 80
and 33 queries, respectively.

5.2 Evaluation of RL algorithms

In the ﬁrst part of the evaluation we will analyze the per-
formance of diﬀerent RL algorithms. We will start with deep
Q-networks (DQN) and discuss some enhancements. After-
wards we will analyze proximal policy optimization (PPO).

5.2.1 Deep-Q-Networks (DQN)

Let us start with the evaluation of the DQNs, which we
introduced in Section 3.2.2. We begin with the vanilla DQN,
which was used in the DQ paper [14] and that we have im-
plemented and conﬁgured according to the information pro-
vided in the paper.

The most important hyper-parameter values of the vanilla
DQN can be found in Table 1. The full set of parameter
values can be found on our github repository2. The vanilla

1The source code of our approach can be found at
https://github.com/heitzjon/mt-join-query-optimization-
with-drl
2https://github.com/heitzjon/mt-join-query-optimization-
with-drl/blob/master/agents/run/conﬁgs.py

DQN is trained over 4000 iterations. The learning starts af-
ter time step 1000 and the target network gets updated every
500 time steps. For this model we use 2-step Q-learning and
a neural network with two hidden layers with 256 neurons
each.

As introduced in Section 4.2.3, our DQN uses the expected
costs calculated by the cost model Equation 8 as the negative
reward for each query. We only give the DQN a reward
signal after planing the full query, to reach a stable learning
process and to give the DQN a chance to learn.

Parameter
Training iterations:
Learning starts (in time steps):
Target network update (in time steps):
n-step Q-learning:
Hidden layers:

Value
4000
1000
500
2
[256 256]

Table 1: Hyper-parameter values of Vanilla DQN network

The results on the left side of Figure 7 show the estimated
cost values trained on 80 queries and tested on 33 queries.
The cost value is computed based on the cost model shown
in Section 4, see Equation 8.

We can see that the average cost value for the deep-Q-
network (DQN) is around 0.2*1e10 (see left side of Figure 7).
However, the minimal and maximal value range between
0.1*1e10 and 3.5*1e10, which indicates a high variance in
the estimated query costs resulting in expensive query plans
for about half of the observed queries.

In order to reduce the high variance of the estimated
costs and to reach a more stable optimization solution, we
extended the vanilla DQN. In particular, we extended the
vanilla DQN model with double DQN and priority replay. In
addition, we used a larger neural network (NN) to achieve
a higher abstraction level for ﬁnding an optimal Q-function.
The conﬁguration of the DDQN is listed in Table 2. The
DDQN is trained over 40,000 iterations. The learning starts
after time step 160,000 and the target network gets updated
every 32,000 time steps. For this model we use 2-step Q-
learning as well and a neural network with two hidden layers
of 6,272 and 1,568 neurons each.

The results of the double deep-Q-network (DDQN) with

priority replay are shown on the right side in Figure 7.

Parameter
Training iterations:
Learning starts (in time steps):
Target network update (in time steps):
n-step Q-learning:
Hidden layers:

Value
40,000
160,000
32,000
2
[6272 1568]

Table 2: Hyper-parameter values of the double deep-Q-
network

Figure 7 shows the cost spread oﬀ all 113 queries. Even
though the median cost value (green line) of DQN and DDQN
is very similar, the inter-quartile range (blue box) of the
vanilla DQN is by a factor of two larger than the one of the
DDQN. In addition, the maximum cost value of the vanilla
DQN is by a factor of two larger than the maximum of the
DDQN. The minimum values of the vanilla DQN and DDQN
are similar. In short, the Q-function of DDQN produces far
less expensive query plans than the vanilla DQN.

Figure 7: Cost values for optimizing 113 queries using
reinforcement learning algorithms. The ﬁgure compares
a vanilla deep-Q-network (DQN) with a double deep-Q-
network (DDQN) using priority replay.

5.2.2 Proximal Policy Optimization (PPO)

In the second step we evaluate proximal policty optimiza-
tion (PPO), which is used in ReJoin [21]. We have imple-
mented that approach using the reinforcement learning al-
gorithms provided by RLLib of Ray3. The basics of PPO are
introduced in Section 3.2.3. Unfortunately, the ReJoin [21]
paper does not provide the conﬁguration of the used PPO
model. Due to that we created and tuned our own conﬁgura-
tion, which you can ﬁnd in Table 3. The full set of parameter
values can be found on our github repository4. The PPO is
trained over 200,000 iterations. During the training process
we clip policies with a bigger deviation than 0.3. Further-
more, we us for our model a neural network with two hidden
layers of 256 neurons.

Parameter
Training iterations:
Clipping coeﬃcient ((cid:15)):
Hidden layers:

Value
200,000
0.3
[256 256]

Table 3: Hyper-parameter values of the PPO network

PPO outperforms both DQN conﬁgurations, as presented
on the left side of Figure 8. PPO is able to reduce the inter-
quartile range and the maximum by more than a factor of
two compared to DDQN.

5.3 Enhance RL models

In this section we will to evaluate how we can improve the
DRL models. First, we will discuss how the split of train-
ing and test data aﬀects the learning process. Afterwards
we introduce ensemble learning to improve the DRL-based
query optimizer.

5.3.1 Re-Arranging Training and Test Data Sets

3https://github.com/ray-project/ray
4https://github.com/heitzjon/mt-join-query-optimization-
with-drl/blob/master/agents/run/conﬁgs.py

9

Figure 8: Comparing three diﬀerent DRL algorithms in FOOP a) on a random training data, b) after adapting the training
and test data sets and c) with Ensemble Learning

In our previously presented experiments, we used a ran-
dom data split for generating training and test sets. As
[14] pointed out, it is important that the
Krishnan et al.
training queries cover all relations and use all important
relationships in the database. So we introduce a new train-
ing/test data split, which can be found in our github repos-
itory5. The key requirements for the data split are:

• All relations have to be represented in every training

set.

• The training sets have to contain all possible join con-

ditions.

• To have accurate test conditions, every test set has
to contain the largest possible variety of diﬀerent join
queries.

We ran our experiments with the new data split for the
training and test set. The results are shown in the middle
of Figure 8. As we can see, the new arrangement of the
training and test data improves the query optimization per-
formance of all models. Especially the inter-quartile range
and the maximum of DQN and DDQN can be reduced sig-
niﬁcantly. Nevertheless, PPO still outperforms the DQN
models. The better performance can be explained by the
new training sets, which cover all relations and join condi-
tions of the database. This enables the DRL-based optimizer
to reduce overﬁtting of the Q-function and policy-function.

5.3.2 Ensemble Learning

In RL the training process is a stochastic process. This
means that the learned policies from diﬀerent training runs
can have divergences resulting in diﬀerent optimal query
plans for the same query. Ensemble learning is a method,
which helps us to transform that issue into a beneﬁt. En-
semble learning is often used to combine multiple learning
algorithms, with the aim to create better predictions than

5https://github.com/heitzjon/mt-join-query-optimization-
with-drl/tree/master/agents/queries/crossval sens

a single learning algorithm. In other words, the agent asks
for a second or a third opinion before taking a decision [28].
To apply ensemble learning, we ﬁrst train every DRL
model ﬁve times and thus receive ﬁve diﬀerent learned poli-
cies. Afterwards use all ﬁve learned policies to optimize a
given query. As a result, we will receive ﬁve diﬀerent ”op-
timal” query plans. Finally, we chose the query plan with
the lowest costs.

The results of using three diﬀerent DRL-based query opti-
mization with ensemble learning are shown on the right side
of Figure 8. We are able to reduce the inter-quartile range
and the maximum of all models signiﬁcantly. In addition,
we were even able to lower the median of all three models.
It is not surprising, that we get better results, since we take
just the best query plans from ﬁve diﬀerent learned policies.
Moreover, we could also reduce the amount of outliers.

5.4 Comparison to other Approaches

So far we compared the DRL algorithms introduced in
ReJoin [21] and DQ [14]. However, for DQ we used the
featurization of FOOP. The advantage of FOOP’s featuriza-
tion is that the learning algorithms have more information
about the query execution process resulting in a smaller ac-
tion space.

Now we will compare these approaches to a traditional
query optimization approach based on dynamic program-
ming to better understand the advantages and disadvantage
of DRL-based approaches.

5.4.1 Dynamic Programming with Left-Deep Plans
DP algorithms were introduced to query optimization in
System R [2] and are still widely used in commercial DBM-
Ses. The basic assumption of these algorithms is that the
optimal sub query plan is part of the optimal query plan.
The algorithm therefore compares sub queries, which have
the same outcome, and picks the sub query with the lowest
costs to proceed. However, this process is very memory- and
computing-intensive, especially for large queries.

10

Figure 9: Comparison of FOOP to DP left-deep

Figure 10: Query-by-query comparison of FOOP with PPO
and DP left-deep

Typical approaches use a recursive process which grows
on a lower bound of n! where n represents the number of
relations in the query. To reduce that complexity, System R
[2] introduces rules like ’left-deep query trees only’ and ’no
cross joins’. We implemented the bottom-up DP algorithm
from System R [2] with restrictions to left-deep trees. The
algorithm can be found in our github repository. Note that
this approach is still very compute-intensive. Hence, DBM-
Ses like PostgreSQL limit the size of queries processed by
dynamic program (e.g. 8-way-joins). When queries contain
more than 8 relations to join, the optimizer greedily selects
the remaining relations or uses genetic algorithms for opti-
mization.

In Figure 9 we compare the three previously discussed
DRL-based optimization strategies against dynamic program-
ming (DP). As we can see, DP outperforms the DRL-based
approaches. However, the optimization run time complexity
for, e.g. PPO, is much better than for dynamic program-
ming as we will show in Section 5.5.

Let us now take a closer look at PPO when compared
In particular, we will analyze

to dynamic programming.

11

Figure 11: The heatmap to shows how often particular ta-
bles are accessed by the queries in the training set, test set
and the outliers.

the join complexity of the queries. The x-axes of Figure 10
shows the queries sorted by number of joins ranging from 3
to 16. We can see that for a large number of queries PPO
even outperforms dynamic programming. However, PPO
has about 6 outliers that decrease the overall performance.
We will now analyze these outliers in more detail.

5.4.2 Outlier Analysis

During the analysis of the outliers we observed that all
6 outlier queries come from two diﬀerent query templates
of the JOB benchmark.
In particular, the outlier queries
belong to the templates 25 and 31. These outliers can be
explained by the occurrence of the diﬀerent tables in the
training set versus the test data set. Figure 11 shows the
occurrence of the tables as a heatmap. The color red in-
dicates that the respective table is heavily used, i.e.
it is
”hot”, while the color blue indicates that the respective ta-
ble is hardly used, i.e. it is ”cold”. We can observe that for
outlier queries there is a higher number of ”hot” tables in
the test data, while the respective tables in the training data
tend to be ”colder”. In other words, the test data does not
contain enough training examples and hence these queries
could not be learned well.

5.5 Training Time

In contrast to traditional query optimizers, DRL-based
query optimizers initially need to be trained before they can
be used.
In this section we describe the training latency
of the diﬀerent DRL-models used in FOOP. The training
process of vanilla DQN over 4,000 time steps and DDQN
over 40,000 time steps takes about 7 minutes each. The
PPO model is trained over 200,000 time steps and takes
roughly 25 minutes.

The training process in FOOP with ensemble learning in-
creases by a factor of ﬁve, since we train each model ﬁve
times. The DQN models take 45 minutes and the PPO
model even needs 125 minutes to complete the training pro-
cess. In comparison, ReJoin needs 3 hours to complete the
training process on a slightly smaller hardware conﬁgura-
tion.

One of the biggest advantage of query optimization with
DRL is, that the optimization latency is linear to the used
relations of a query [21], which results in a complexity of
O(n). The latency grows linear with the join size, even if

we use ensemble learning to improve our query plans, as
presented in Figure 12. Left-deep DP, on the other hand,
has an optimization latency which is factorial to the relations
of the query, this corresponds to the complexity of O(n!).

Figure 12: Comparing optimization latency of FOOP with
DP left-deep DP.

6. CONCLUSION AND LIMITATION

In this paper we analyzed various deep reinforcement learn-
ing algorithms for query optimization and introduced FOOP
- a deep reinforcement learning-based Fully Observed Opti-
mizer. FOOP is currently limited to join order optimization
but can easily be extended to optimize select-project-join
queries or even non-relational operators as presented in DQ
[14]. FOOP is implemented in an RL-friendly environment
which enables experimenting with the most cutting-edge RL
algorithms.

Our experimental evaluation shows that Proximal Policy
Optimization (PPO) reinforcement learning algorithms out-
perform Deep Q-Networks (DQN) in the task of join order
optimization. We also suggest to use ensemble learning in
combination with DRL to mitigate stability issues of the
stochastic training process. The results demonstrate that
ensemble learning signiﬁcantly improves the overall perfor-
mance of the RL algorithms. FOOP produces query plans
with cost estimations in a similar range to traditional query
optimizers based on left-deep dynamic programming algo-
rithms. However, the optimization latency of FOOP is sig-
niﬁcantly lower than for left-deep DP algorithms.

Based on our experiments, we see the following avenues

of further research:

• One of the disadvantages of deep reinforcement learn-
ing is that pre-training certain models is very compute-
intensive. One solution to overcome this problem is to
integrate bootstrapped expert knowledge into the pre-
training phase for faster learning.

• Some of the cost models of traditional query optimizers
suﬀer from erroneous cardinality estimations. To solve
this problem, one could add a ﬁne-tuning step to the
training process to reuse cardinality data from already
executed queries.

12

• In order to provide an end-to-end query optimizer,
FOOP needs to be extended with further functions
like selections, projections as well as aggregations.

Acknowledgement
We would like to thank Joseph Hellerstein and Zongheng
Yang for the fruit-full discussions about DRL in query opti-
mization. The advice given by Michael Grossniklaus about
query optimization and Paul Bertucci about database tun-
ing has been a great help. We also want to thank Katha-
rina Rombach for the many discussions about reinforcement
learning.

7. REFERENCES
[1] Mert Akdere, Ugur C¸ etintemel, Matteo Riondato, Eli
Upfal, and Stanley B Zdonik. Learning-based query
performance modeling and prediction. In 2012 IEEE
28th International Conference on Data Engineering,
pages 390–401. IEEE, 2012.

[2] Morton M. Astrahan, Mike W. Blasgen, Donald D.
Chamberlin, Kapali P. Eswaran, Jim N Gray,
Patricia P. Griﬃths, W Frank King, Raymond A.
Lorie, Paul R. McJones, James W. Mehl, et al. System
r: relational approach to database management. ACM
Transactions on Database Systems (TODS),
1(2):97–137, 1976.

[3] Ron Avnur and Joseph M Hellerstein. Eddies:

Continuously adaptive query processing. In ACM
sigmod record, volume 29, pages 261–272. ACM, 2000.

[4] Matej Crepinˇsek and Luka Mernik. An eﬃcient

representation for solving catalan number related
problems. International journal of pure and applied
mathematics, 56(4):598–604, 2009.

[5] Archana Ganapathi, Harumi Kuno, Umeshwar Dayal,

Janet L Wiener, Armando Fox, Michael Jordan, and
David Patterson. Predicting multiple metrics for
queries: Better decisions enabled by machine learning.
In 2009 IEEE 25th International Conference on Data
Engineering, pages 592–603. IEEE, 2009.

[6] Ian Goodfellow, Yoshua Bengio, Aaron Courville, and
Yoshua Bengio. Deep learning, volume 1. MIT press
Cambridge, 2016.

[7] Google Brain Team. Tensorﬂow: An end-to-end open

source machine learning platform.
https://www.tensorﬂow.org/, June 2019.

[8] Goetz Graefe and William McKenna. The volcano

optimizer generator. Technical report, COLORADO
UNIV AT BOULDER DEPT OF COMPUTER
SCIENCE, 1991.

[9] Jonas Heitz and Kurt Stockinger. Learning cost
model: Query optimization meets deep learning.
Zurich University of Applied Science, Project Thesis,
2019.

[10] Joseph M Hellerstein and Michael Stonebraker.
Readings in database systems. MIT Press, 2005.
[11] Matteo Hessel, Joseph Modayil, Hado Van Hasselt,

Tom Schaul, Georg Ostrovski, Will Dabney, Dan
Horgan, Bilal Piot, Mohammad Azar, and David
Silver. Rainbow: Combining improvements in deep
reinforcement learning. In Thirty-Second AAAI
Conference on Artiﬁcial Intelligence, 2018.

Gehrke, and S Sathiya Keerthi. Learning state
representations for query optimization with deep
reinforcement learning. arXiv preprint
arXiv:1803.08604, 2018.

[28] Robi Polikar. Ensemble based systems in decision
making. IEEE Circuits and systems magazine,
6(3):21–45, 2006.

[29] Tom Schaul, John Quan, Ioannis Antonoglou, and

David Silver. Prioritized experience replay. arXiv
preprint arXiv:1511.05952, 2015.

[30] John Schulman, Filip Wolski, Prafulla Dhariwal, Alec

Radford, and Oleg Klimov. Proximal policy
optimization algorithms. arXiv preprint
arXiv:1707.06347, 2017.

[31] David Silver, Aja Huang, Chris J Maddison, Arthur
Guez, Laurent Sifre, George Van Den Driessche,
Julian Schrittwieser, Ioannis Antonoglou, Veda
Panneershelvam, Marc Lanctot, et al. Mastering the
game of go with deep neural networks and tree search.
nature, 529(7587):484, 2016.

[32] Michael Stillger, Guy M Lohman, Volker Markl, and
Mokhtar Kandil. Leo-db2’s learning optimizer. In
VLDB, volume 1, pages 19–28, 2001.

[33] Richard S Sutton and Andrew G Barto. Reinforcement

learning: An introduction. MIT press, 2018.

[34] The PostgreSQL Global Development Group.

Postgresql: The world’s most advanced open source
relational database. https://www.postgresql.org/,
January 2019.

[35] The Ray Team. Rllib: Scalable reinforcement learning.
https://ray.readthedocs.io/en/latest/rllib.html, June
2019.

[36] Immanuel Trummer, Samuel Moseley, Deepak Maram,
Saehan Jo, and Joseph Antonakakis. Skinnerdb:
regret-bounded query evaluation via reinforcement
learning. Proceedings of the VLDB Endowment,
11(12):2074–2077, 2018.

[37] Wei Wang, Meihui Zhang, Gang Chen, HV Jagadish,

Beng Chin Ooi, and Kian-Lee Tan. Database meets
deep learning: challenges and opportunities. ACM
SIGMOD Record, 45(2):17–22, 2016.

[38] Wentao Wu, Yun Chi, Hakan Hac´ıg¨um¨u¸s, and
Jeﬀrey F Naughton. Towards predicting query
execution time for concurrent and dynamic database
workloads. Proceedings of the VLDB Endowment,
6(10):925–936, 2013.

[39] Elif Ezgi Yusufoglu, Murat Ayyildiz, and Ensar Gul.

Neural network-based approaches for predicting query
response times. In 2014 International Conference on
Data Science and Advanced Analytics (DSAA), pages
491–497. IEEE, 2014.

[12] IMDB Inc. Imdb. https://www.imdb.com/interfaces/,

2019.

[13] Yannis E Ioannidis. Query optimization. ACM

Computing Surveys (CSUR), 28(1):121–123, 1996.
[14] Sanjay Krishnan, Zongheng Yang, Ken Goldberg,
Joseph Hellerstein, and Ion Stoica. Learning to
optimize join queries with deep reinforcement
learning. arXiv preprint arXiv:1808.03196, 2018.
[15] Dennis Lee, Haoran Tang, Jeﬀrey O Zhang, Huazhe
Xu, Trevor Darrell, and Pieter Abbeel. Modular
architecture for starcraft ii with deep reinforcement
learning. In Fourteenth Artiﬁcial Intelligence and
Interactive Digital Entertainment Conference, 2018.

[16] Viktor Leis, Andrey Gubichev, Atanas Mirchev, Peter

Boncz, Alfons Kemper, and Thomas Neumann. How
good are query optimizers, really? Proceedings of the
VLDB Endowment, 9(3):204–215, 2015.

[17] Jiexing Li, Arnd Christian K¨onig, Vivek Narasayya,

and Surajit Chaudhuri. Robust estimation of resource
consumption for sql queries using statistical
techniques. Proceedings of the VLDB Endowment,
5(11):1555–1566, 2012.

[18] Guy Lohman. Is query optimization a solved problem.

In Proc. Workshop on Database Query Optimization,
page 13. Oregon Graduate Center Comp. Sci. Tech.
Rep, 2014.

[19] Ryan Marcus, Parimarjan Negi, Hongzi Mao, Chi

Zhang, Mohammad Alizadeh, Tim Kraska, Olga
Papaemmanouil, and Nesime Tatbul. Neo: A learned
query optimizer. arXiv preprint arXiv:1904.03711,
2019.

[20] Ryan Marcus and Olga Papaemmanouil. Wisedb: a
learning-based workload management advisor for
cloud databases. Proceedings of the VLDB
Endowment, 9(10):780–791, 2016.

[21] Ryan Marcus and Olga Papaemmanouil. Deep

reinforcement learning for join order enumeration. In
Proceedings of the First International Workshop on
Exploiting Artiﬁcial Intelligence Techniques for Data
Management, page 3. ACM, 2018.

[22] Ryan Marcus and Olga Papaemmanouil. Towards a

hands-free query optimizer through deep learning.
arXiv preprint arXiv:1809.10212, 2018.

[23] Volker Markl, Vijayshankar Raman, David Simmen,
Guy Lohman, Hamid Pirahesh, and Miso Cilimdzic.
Robust query processing through progressive
optimization. In Proceedings of the 2004 ACM
SIGMOD international conference on Management of
data, pages 659–670. ACM, 2004.

[24] Volodymyr Mnih, Koray Kavukcuoglu, David Silver,

Alex Graves, Ioannis Antonoglou, Daan Wierstra, and
Martin Riedmiller. Playing atari with deep
reinforcement learning. arXiv preprint
arXiv:1312.5602, 2013.

[25] Volodymyr Mnih, Koray Kavukcuoglu, David Silver,

Andrei A Rusu, Joel Veness, Marc G Bellemare, Alex
Graves, Martin Riedmiller, Andreas K Fidjeland,
Georg Ostrovski, et al. Human-level control through
deep reinforcement learning. Nature, 518(7540):529,
2015.

[26] OpenAI. Gym. https://gym.openai.com, June 2019.
[27] Jennifer Ortiz, Magdalena Balazinska, Johannes

13

