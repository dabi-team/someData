Batch Tournament Selection for Genetic Programming
The quality of lexicase, the speed of Tournament

Vinícius V. de Melo
Data Science Team
SkipTheDishes Restaurant Services
Inc.
Winnipeg, MB, Canada
vinicius.melo@skipthedishes.ca

Danilo Vasconcellos Vargas
Faculty of Information Science and
Electrical Engineering
Kyushu University
Fukuoka, Japan
vargas@inf.kyushu-u.ac.jp

Wolfgang Banzhaf
CSE Dept & BEACON Center
Michigan State University
East Lansing, MI, USA
banzhafw@msu.edu

9
1
0
2

r
p
A
8
1

]
E
N
.
s
c
[

1
v
8
5
6
8
0
.
4
0
9
1
:
v
i
X
r
a

ABSTRACT
Lexicase selection achieves very good solution quality by introduc-
ing ordered test cases. However, the computational complexity of
lexicase selection can prohibit its use in many applications. In this
paper, we introduce Batch Tournament Selection (BTS), a hybrid
of tournament and lexicase selection which is approximately one
order of magnitude faster than lexicase selection while achieving
a competitive quality of solutions. Tests on a number of regres-
sion datasets show that BTS compares well with lexicase selection
in terms of mean absolute error while having a speed-up of up
to 25 times. Surprisingly, BTS and lexicase selection have almost
no difference in both diversity and performance. This reveals that
batches and ordered test cases are completely different mechanisms
which share the same general principle fostering the specialization
of individuals. This work introduces an efficient algorithm that
sheds light onto the main principles behind the success of lexicase,
potentially opening up a new range of possibilities for algorithms
to come.

CCS CONCEPTS
• Computing methodologies → Genetic programming; Selec-
tion algorithm;

KEYWORDS
Selection algorithm, Genetic Programming, Symbolic Regression

ACM Reference Format:
Vinícius V. de Melo, Danilo Vasconcellos Vargas, and Wolfgang Banzhaf.
2019. Batch Tournament Selection for Genetic Programming: The quality of
lexicase, the speed of Tournament. In Genetic and Evolutionary Computation
Conference (GECCO ’19), July 13–17, 2019, Prague, Czech Republic. ACM,
New York, NY, USA, 9 pages. https://doi.org/10.1145/3321707.3321793

1 INTRODUCTION
In traditional Genetic Programming and similar algorithms, the fit-
ness of an individual is quantified as its aggregate performance over
the test cases of a training set. The aggregation produces a quality

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
GECCO ’19, July 13–17, 2019, Prague, Czech Republic
© 2019 Association for Computing Machinery.
ACM ISBN 978-1-4503-6111-8/19/07. . . $15.00
https://doi.org/10.1145/3321707.3321793

measure such as Mean Absolute Error (MAE), Correlation Coefficient,
or a Loss Function. In order to choose parents for reproduction or
to truncate the population for survival into the next generation
selection methods such as roulette wheel or tournament selection
employ this aggregated fitness measure for deciding which individ-
uals are worth reproducing. However, lumping together the overall
behavior of a program or algorithm into one number – despite it
arising from probably thousands of fitness cases – has been found
to throw away valuable information [5].

Over the years, a number of approaches have been tried to make
better use of individual fitness cases. The most extreme sugges-
tion was to use a randomly chosen fitness case on a randomly
chosen individual for evaluation [9], assuming that a useful fit-
ness measure emerges by averaging over the long run. This ex-
treme approach was used in cases where fitness evaluation takes
a long time, like in robotics, rendering evaluation otherwise close
to impossible. Other effective approaches were suggested, too, like
creating sub-populations for each similar input which results in
the concept of niched fitness (multiple fitness functions divided
in sub-populations) [12, 15], replacing the test cases by a model
function [10], and more generally in EC, to use a surrogate fitness
function [4].

A few years ago, lexicase selection [13] was proposed as an alter-
native that also considers all fitness cases. Lexicase selection works
by testing on fitness cases separately but systematically through
simply changing the order of their application, thus giving individ-
uals that behave well on particular fitness cases, but not in general,
a chance to have offspring. Lexicase selection works nicely for dis-
crete problems, while ϵ-Lexicase [6] has been recently proposed
for continuous problems.

Although lexicase parent selection improves the search, it de-
mands very high computational efforts because all individuals in
the population must be compared on a large number of fitness
cases. These numbers shrink as it advances in the fitness cases, but
it may take a while to select a single parent. Following lexicase’s
approach, we propose the Batch Tournament Selection. It splits
fitness cases into batches and runs regular tournament selection on
them. A batch of size one is equivalent to lexicase selection, while a
batch containing all cases is equivalent to a canonical tournament
selection algorithm. By tuning the batch size parameter, one may
approximate the quality of Lexicase with the speed of canonical
tournaments.

One of the important aspects of lexicase selection is its success in
keeping a population diverse over repeated rounds of selection. As
well, since the selection pressure is constantly changing, lexicase

 
 
 
 
 
 
GECCO ’19, July 13–17, 2019, Prague, Czech Republic

V. V. de Melo et al.

selection helps to avoid overfitting and produces better solutions
faster. There are also problems with Lexicase as when it does ”hy-
perselection”, i.e. when the population is reduced to just one niche,
thus getting stuck on the way to an optimal solution.

Here we want to address the issues of speed and diversity and
propose an algorithm that combines strong features of tournament
selection with those of Lexicase in our algorithm called batch tour-
nament selection (BTS).

The paper is organized as follows: Section 2 discusses selection
algorithms, Section 3 introduces batch tournament selection and
its variant, Batch Tournament Selection Shuffled (BTSS). Section 4
reports our results and Section 5 presents our conclusions.

2 SELECTION ALGORITHMS
Evolution needs selection to bring forth better candidate solutions.
Throughout evolution, these better candidate solutions will help
generate even better ones. This will drive evolution towards candi-
date solutions with high fitness. However, the process of generating
better candidate solutions is constrained by time as well as the need
for an important ingredient, diversity. Time-consuming selection
procedures will often cause a slow-down, preventing runs from
achieving satisfactory results in a timely manner and prohibiting
their use in real time applications. Moreover, populations that lack
diversity will consequently fail to explore the fitness landscape.

Selection pressure and diversity are opposing forces in evolu-
tion with time being the overall constraint that often allows sim-
ple/approximate solutions to thrive over complex/exact ones. De-
pending on the selection method chosen, a completely different
trade-off between selection pressure, diversity and time takes place.
Proportionate reproduction (roulette) was one of the first proposed
selection methods. It is not easy to control selection pressure in
roulette wheel selection, but the time complexity when efficiently
coded can achieve O(N ∗ T ) for population of size N and T test
cases.

Tournament selection is another widely known method which
selects individuals based on tournament winners. Since weaker
individuals have less chance to win in bigger tournaments, the
tournament size provides the selection pressure [8]. Tournament
selection is a relatively fast method with time complexity O(N ∗ T ).
It can be easily parallelized and has a selection pressure that can be
easily adjusted [1].

Recently, lexicase selection was proposed. It selects individuals
that perform well in random test sequences. In this manner, the
variance of the sequence distribution provides a good trade-off
between diversity and selection pressure [13]. Interestingly, random
test sequences force candidate solutions to solve small portions of
the problem well and therefore tends to select candidate solutions
which are specialists. This is in stark contrast with the widespread
use of average of solutions which selects for generalists. In fact,
Lexicase has been shown to outperform other methods in many
different scenarios [2, 3, 7]. A big disadvantage, however, lies in its
2 ∗ T ).
time complexity which is O(N
La Cava et. al [6] introduced ϵ-Lexicase, a new form of lexi-
case selection for symbolic regression in the continuous domain,
whereas Lexicase was originally proposed for discrete problems. It
was compared with tournament selection and age-fitness Pareto

optimization on a series of regression data sets. Different versions
of ϵ-Lexicase were capable of producing fitter models than the other
methods. The authors also proposed a strategy to automatically
adapt ϵ based on the population performance distribution, which
produced a very small computational overhead while achieving
high-quality results. This is the version employed as baseline in
this paper, here named Ae-Lex.

3 BATCH TOURNAMENT SELECTION
In batch tournament selection (BTS) fitness cases are, in each gen-
eration, split into batches and all batches are processed. BTS first
orders the fitness cases by their error, so cases with a similar diffi-
culty level belong to the same batch. On the other hand, a second
version of the algorithm, BTSS, shuffles the cases in addition to
grouping them in batches.

For each batch, the method first calculates the fitness, such as
MAE, of each individual in the population. It then follows with
a tournament selection in which randomly selected individuals
participate. In each tournament, the participating individual that
performs best on that particular batch survives to the next gen-
eration. The method then goes to the next batch, repeating the
procedure, until all batches are processed. If the number of selected
individuals is smaller than the population size then the process
repeats with new batches.

BTS and BTSS return a list of k parents selected for mating.
Considering a parent is selected from a single batch, only k batches
are needed. Thus, although all individuals must be evaluated in all
their fitness cases, not all fitness cases may be considered in the
comparison for selecting the k parents. If the number of batches is
smaller than k, a new round starts from the first batch to continue
selecting parents. Ae-Lex, on the other hand, may need to examine
the entire data set if candidate parents are clones of each other and
the duplicates are not removed. However, since Ae-Lex maintains
a large population diversity, this cloning effect was observed only
in a small part of the population.

Here, we tested two approaches. In the first one, BTS, we study
a type of phenotypic clustering in which fitness cases are ordered
by their difficulty level. To do so, the error of each fitness case
is calculated (such as MAE, Mean Squared Error, or Root Mean
Squared Error) and cases with similar difficulty are grouped in the
same batch. To force BTS to select individuals that perform best
in the most difficult cases and let the selection of individuals for
easy cases depend on the batch size, we use a descending order of
difficulty for batches. In other words, the first batch contains the
hardest examples while the last batch contains the easiest ones. For
a detailed description of BTS, please refer to Algorithm 1.

The second approach, called BTSS, makes use of mixed difficulty
test cases within batches. Fitness cases are permuted, not sampled
with repetition. In this approach, individuals must perform well
on all difficulty levels to be selected. Thus, it results in a different
type of selection pressure when compared with the heterogenous
difficulty of batches from BTS. Since the examples within a batch
are randomly selected, it might, however, happen that a batch has
only easy cases allowing poor-quality individuals to be selected but
that should be a rare occurrence.

Batch Tournament Selection for Genetic Programming

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

Algorithm 1 A simple pseudocode for BTS. Since we are minimizing the error, we use min to select the best individual. Collection indices
start in 1.

population the entire population

k the number of parents to be selected

Input

Output

batch_size
tourn_size
shuffle
selected_individuals

the size of each batch, i.e., the number of cases in each batch
the number of individuals to be selected for tournament
a boolean indicating whether the cases should be shuffled before creating the batches
the collection of parents

function selBatchTournament(population, k, batch_size, tourn_size, shuffle)

if shuffle then

idx_cases_batch = 1,...,|population[1].case_error| // An array of indexes: case_error contains the error for each case
shuffle(idx_cases_batch)

else

// Order by difficulty according to the fitness of the best solution so far
best = find_best(population)
idx_cases_batch = order(best.case_error) // The index of the cases in decreasing order (harder cases first)

end if

// Break into chunks of size batch_size
_batches = split(idx_cases_batch, batch_size)
indexes = 1,...,|population| // An array of indexes

// Select k individuals
selected_individuals = [ ] // An empty collection
while |selected_individuals| < k do

batches = clone(_batches) // Create the batch queue

while |batches| > 0 and |selected_individuals| < k do

idx_candidates = random_selection(indexes, tourn_size) // Tournament candidates per batch

// Calculate the candidate fitness for the batch
cand_fitness_for_this_batch = [ ]
for idx in idx_candidates:

errors = [ ]
for b in batches[1]: // Contains the index of the cases in the first batch in the queue

errors.append (population[idx].case_error[idx_cases_batch[b]])

end for
cand_fitness_for_this_batch.append( mean(errors) )

end for

idx_winner = index_min(cand_fitness_for_this_batch)
winner = population[idx_candidates[idx_winner]]
selected_individuals.append(winner) // Store the winner of each batch
batches.pop(1) // Remove the current batch from the queue

end while

end while

return selected_individuals // Return a collection of individuals

end function

4 EXPERIMENTAL ANALYSIS
4.1 Computational environment
All tests run in a machine with the following environment: Ubuntu
18.04, Anaconda Python 2.7.15, Deap 1.2. The machine itself is
an Intel(R) Xeon(R) Silver 4114 CPU @ 2.50GHz. The code is not
numpy optimized. Numpy was used in BTS, BTSS and Ae_Lex only
for calculating the mean, median, minimum, shuffling and ordering
the solutions.

4.2 Data sets
In the experiments, data sets that are widely employed in machine-
learning and symbolic regression [6, 11] research were chosen. As
in [6], we normalized the features of the data sets (not the response)
to zero mean, unit variance and randomly partitioned into five
disjoint sets of the same size. Later, we executed the methods five
times (different seeds) with a 5-fold cross-validation (5 × 5-CV) for
each configuration in a grid-search.

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

V. V. de Melo et al.

Table 1: data sets and description.

Name

airfoil

concrete

energyCooling

energyHeating

towerData

wineRed

wineWhite

yacht

Variables

Training cases

Test cases

5

8

8

8

25

11

11

6

1202

824

614

614

3999

1279

3918

614

301

206

154

154

1000

320

980

154

4.3 GP configuration
The general parameter settings for the algorithms are shown in
Table 2 and follows the configuration used in [6]. MAE was chosen
as the fitness function to guide the evolution process. Moreover, we
performed a grid-search on batch and tournament sizes for both
BTS and the canonical tournament.

Table 2: General parameter settings. Operators are protected,
meaning they return 1.0 on failure.

Parameter

Independent runs

Initialization

Number of generations

Population size

Maximum initial depth

Maximum depth

Batch sizes

Tournament sizes

Shuffle

Elite

Crossover operator

Crossover rate

Setting

25

Ramped half/half

1000

1000

3

7

2, 4, 8, 16, 32, 64, 128

2, 4, 8, 16, 32, 64, 128

True, False

1

One-point

90%

Mutation operator

Uniform (new random subtree)

Mutation rate

10%

Terminal set

{x, ERC, +, −, ∗, /, sin, cos, exp, log}

ERC range

[-1, 1]

4.4 Analysis
We analyzed how our approaches perform in many configurations
and later compared each of them, individually, to Ae-Lex. The
objective is to investigate how the parameters affect the search
and to evaluate the general performance against Ae-Lex. Therefore,

the key question we are trying to answer is: can BTS or BTSS be
competitive to Ae-Lex in terms of solution quality but considerably
faster?

We do not intend to find the perfect configuration that is the
best for all problems since there is no free lunch. In fact, we intend
to observe, from the experiments, which configurations perform
best for the specific data sets and GP configuration used in this
paper that can be suggested as initial trials for GP practitioners and
which do not show a good performance and could be avoided.

To reduce the configurations for comparison, for each data set,
we first select the top five configurations according to the Median
MAE (MMAE) on the training set. Then, we summarize the experi-
mental results on the test set (Note that we are not selecting the best
on the test set). To analyze the behavior of the proposed method
as well as compare it with existing ones, the median performance
curve of the best fitness (calculated as MAE) over all runs, a boxplot
of the best fitness and running time are used.

Moreover, we present a hypothesis test using Wilcoxon Rank
Sum with Holm correction. In this context, α = 5% is used to
evaluate how the methods performed against Ae-Lex (baseline) on
each data set.

4.5 Results and discussion
Here we will adopt the following nomenclature: 1) BTS/bs/ts, 2)
BTSS/bs/ts, and 3) Tourn/ts in which Tourn refers to tournament
selection, BTS and BTSS are the proposed algorithms and both bs
and ts stands for respectively the batch size and tournament size.
Notice that BTS is batch tournament selection in which cases are
ordered by their difficulty, i.e., differently from BTSS no shuffling
is employed. Moreover, we will use Ae-Lex to mean Automatic
ϵ-Lexicase selection.

4.5.1 Performance Analysis. Figure 1 shows the performance
curves for the top five configurations on each data set. BTS and BTSS
perform similarly to Ae_Lex while the canonical tournament selec-
tion shows the worst overall performance. On towerData, wineRed,
and wineWhite data sets, BTS/BTSS are shown to easily outperform
Ae_Lex and tournament while achieving a similar performance to
Ae_Lex on the other data sets. Tournament selection shows the
highest MAE on most data sets, with the worst performance on
towerData data set.

However, many of the curves overlap in the last generations.
Aside from towerData, wineRed and whiteRed, it is hard to tell if
any algorithms had a superior performance. To solve this problem
and allow for a better analysis, in Figure 2 the last 100 generations
are plotted separately. Now it is possible to observe that BTS/BTSS
had similar or better performance than Ae-Lex in most of the data
sets with the only exception being the yacht one. MAE related
boxplots (Figure 3) further confim the results observed in Figures 1
and 2.

Thus, BTS and BTSS are shown to achieve similar if not superior
performance to Ae-Lex. Interestingly, BTS and BTSS are based on a
simpler computation which allows it to reach speed-ups of circa
25 (Table 5 and Figure 4). This speedup derives from the fact that
both BTS and BTSS behave similarly to tournament selection and
therefore have a lower computation complexity than Ae-Lex.

Batch Tournament Selection for Genetic Programming

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

Figure 1: Curves showing the MMAE on the test set.

Figure 2: Curves zoomed on the last 100 generations showing the MMAE on the test set.

In Figure 5, the frequency for the top five configurations are
displayed. Small batches that are big enough to decrease random-
ness but small enough to allow for specialization are usually among
the best configurations. Moreover, batches that change constantly
create selection pressures that vary from generation to generation,
decreasing the effects of any specialization that could take place.
This explains the slight improvement of BTS over BTSS. In other
words, in comparison with shuffled batches (BTSS), batches that are
ordered by difficulty (BTS) tend to keep batches without changes
throughout generations. This allows for better specializations. Hav-
ing said that, the probability distribution of batches is constant in
BTSS and therefore there is a number of batch permutations that

are more probable than others. Therefore, BTSS also allows for
certain specializations to appear.

4.5.2 Diversity Analysis. In this paper, we are using a straight-
forward diversity measure that considers only the individual’s value
(its fitness), not its structure. Thus, if two completely different indi-
viduals provide the same result (fitness) they are considered equal.
Here we are interested in how the individuals perform, not how
they look like. Structural analysis can be done in a future work.

Diversity in both lexicase and tournament selection depend on
how competition takes place and both batch as well as tournament
size play important roles. To analyze deeply the diversity behavior,

1020304002505007501000GenerationMean absolute error (test)AlgorithmBTS/16/128BTS/4/16BTS/4/32BTS/8/16BTS/8/64BTSS/32/128BTSS/32/64BTSS/4/128BTSS/8/128BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8airfoil51015202502505007501000GenerationMean absolute error (test)AlgorithmBTS/128/64BTS/16/32BTS/4/64BTS/64/32BTS/8/128BTSS/128/64BTSS/32/64BTSS/64/128BTSS/8/128BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8concrete24602505007501000GenerationMean absolute error (test)AlgorithmBTS/4/16BTS/4/64BTS/8/16BTS/8/32BTS/8/64BTSS/16/32BTSS/16/64BTSS/4/32BTSS/4/64BTSS/8/32Ae-LexTourn/16Tourn/2Tourn/4Tourn/8energyCooling24602505007501000GenerationMean absolute error (test)AlgorithmBTS/16/32BTS/16/64BTS/4/64BTS/8/32BTS/8/64BTSS/16/32BTSS/16/64BTSS/4/64BTSS/8/32BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/4Tourn/8energyHeating3040506002505007501000GenerationMean absolute error (test)AlgorithmBTS/16/64BTS/64/32BTS/64/64BTS/8/128BTS/8/64BTSS/16/64BTSS/32/128BTSS/32/64BTSS/64/128BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8towerData0.60.81.002505007501000GenerationMean absolute error (test)AlgorithmBTS/16/128BTS/32/16BTS/4/64BTS/8/32BTS/8/64BTSS/16/16BTSS/32/64BTSS/4/64BTSS/64/128BTSS/8/128Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8wineRed0.60.70.80.902505007501000GenerationMean absolute error (test)AlgorithmBTS/128/16BTS/64/128BTS/64/16BTS/64/32BTS/8/64BTSS/128/128BTSS/128/32BTSS/128/64BTSS/32/128BTSS/32/32Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8wineWhite2.55.07.502505007501000GenerationMean absolute error (test)AlgorithmBTS/16/32BTS/16/64BTS/2/128BTS/4/16BTS/4/32BTSS/16/32BTSS/16/64BTSS/2/128BTSS/2/32BTSS/8/128Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8yacht3.54.04.55.05.59009259509751000GenerationMean absolute error (test)AlgorithmBTS/16/128BTS/4/16BTS/4/32BTS/8/16BTS/8/64BTSS/32/128BTSS/32/64BTSS/4/128BTSS/8/128BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8airfoil5.56.06.57.09009259509751000GenerationMean absolute error (test)AlgorithmBTS/128/64BTS/16/32BTS/4/64BTS/64/32BTS/8/128BTSS/128/64BTSS/32/64BTSS/64/128BTSS/8/128BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8concrete1.21.31.41.51.61.79009259509751000GenerationMean absolute error (test)AlgorithmBTS/4/16BTS/4/64BTS/8/16BTS/8/32BTS/8/64BTSS/16/32BTSS/16/64BTSS/4/32BTSS/4/64BTSS/8/32Ae-LexTourn/16Tourn/2Tourn/4Tourn/8energyCooling0.60.91.21.59009259509751000GenerationMean absolute error (test)AlgorithmBTS/16/32BTS/16/64BTS/4/64BTS/8/32BTS/8/64BTSS/16/32BTSS/16/64BTSS/4/64BTSS/8/32BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/4Tourn/8energyHeating27.530.032.535.037.59009259509751000GenerationMean absolute error (test)AlgorithmBTS/16/64BTS/64/32BTS/64/64BTS/8/128BTS/8/64BTSS/16/64BTSS/32/128BTSS/32/64BTSS/64/128BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8towerData0.4750.5000.5250.5509009259509751000GenerationMean absolute error (test)AlgorithmBTS/16/128BTS/32/16BTS/4/64BTS/8/32BTS/8/64BTSS/16/16BTSS/32/64BTSS/4/64BTSS/64/128BTSS/8/128Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8wineRed0.560.570.580.599009259509751000GenerationMean absolute error (test)AlgorithmBTS/128/16BTS/64/128BTS/64/16BTS/64/32BTS/8/64BTSS/128/128BTSS/128/32BTSS/128/64BTSS/32/128BTSS/32/32Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8wineWhite0.60.70.80.91.01.19009259509751000GenerationMean absolute error (test)AlgorithmBTS/16/32BTS/16/64BTS/2/128BTS/4/16BTS/4/32BTSS/16/32BTSS/16/64BTSS/2/128BTSS/2/32BTSS/8/128Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8yachtGECCO ’19, July 13–17, 2019, Prague, Czech Republic

V. V. de Melo et al.

Figure 3: Boxplots of the MAE on the test set.

Figure 4: Boxplots of the total running time in seconds.

234567BTSBTSSAe-LexTournMean absolute error (test)AlgorithmBTS/16/128BTS/4/16BTS/4/32BTS/8/16BTS/8/64BTSS/32/128BTSS/32/64BTSS/4/128BTSS/8/128BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8airfoil56789BTSBTSSAe-LexTournMean absolute error (test)AlgorithmBTS/16/32BTS/2/64BTS/64/32BTS/8/128BTS/8/64BTSS/4/128BTSS/64/128BTSS/64/32BTSS/8/128BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8concrete1.001.251.501.752.00BTSBTSSAe-LexTournMean absolute error (test)AlgorithmBTS/4/16BTS/4/64BTS/8/16BTS/8/32BTS/8/64BTSS/16/32BTSS/16/64BTSS/4/32BTSS/4/64BTSS/8/32Ae-LexTourn/16Tourn/2Tourn/4Tourn/8energyCooling0.51.01.52.0BTSBTSSAe-LexTournMean absolute error (test)AlgorithmBTS/16/32BTS/16/64BTS/4/64BTS/8/32BTS/8/64BTSS/16/32BTSS/16/64BTSS/4/64BTSS/8/32BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/4Tourn/8energyHeating2530354045BTSBTSSAe-LexTournMean absolute error (test)AlgorithmBTS/16/128BTS/16/64BTS/64/128BTS/64/32BTS/8/64BTSS/128/128BTSS/128/64BTSS/16/128BTSS/32/128BTSS/32/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8towerData0.450.500.55BTSBTSSAe-LexTournMean absolute error (test)AlgorithmBTS/16/8BTS/2/128BTS/32/64BTS/8/128BTS/8/64BTSS/128/128BTSS/32/128BTSS/32/32BTSS/32/64BTSS/8/128Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8wineRed0.540.560.580.600.62BTSBTSSAe-LexTournMean absolute error (test)AlgorithmBTS/128/128BTS/128/16BTS/128/64BTS/16/16BTS/64/32BTSS/128/128BTSS/128/16BTSS/128/64BTSS/32/32BTSS/64/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8wineWhite0.51.01.52.0BTSBTSSAe-LexTournMean absolute error (test)AlgorithmBTS/16/32BTS/4/16BTS/4/64BTS/64/2BTS/8/32BTSS/16/64BTSS/4/128BTSS/4/32BTSS/4/64BTSS/8/128Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8yacht010000200003000040000BTSBTSSAe-LexTournTotal running time (seconds) AlgorithmBTS/16/128BTS/4/16BTS/4/32BTS/8/16BTS/8/64BTSS/32/128BTSS/32/64BTSS/4/128BTSS/8/128BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8airfoil050001000015000BTSBTSSAe-LexTournTotal running time (seconds) AlgorithmBTS/16/32BTS/2/64BTS/64/32BTS/8/128BTS/8/64BTSS/4/128BTSS/64/128BTSS/64/32BTSS/8/128BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8concrete05000100001500020000BTSBTSSAe-LexTournTotal running time (seconds) AlgorithmBTS/4/16BTS/4/64BTS/8/16BTS/8/32BTS/8/64BTSS/16/32BTSS/16/64BTSS/4/32BTSS/4/64BTSS/8/32Ae-LexTourn/16Tourn/2Tourn/4Tourn/8energyCooling0500010000150002000025000BTSBTSSAe-LexTournTotal running time (seconds) AlgorithmBTS/16/32BTS/16/64BTS/4/64BTS/8/32BTS/8/64BTSS/16/32BTSS/16/64BTSS/4/64BTSS/8/32BTSS/8/64Ae-LexTourn/16Tourn/2Tourn/4Tourn/8energyHeating0250005000075000BTSBTSSAe-LexTournTotal running time (seconds) AlgorithmBTS/128/32BTS/16/128BTS/16/64BTS/64/32BTS/8/64BTSS/128/128BTSS/128/64BTSS/16/128BTSS/32/128BTSS/32/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8towerData010000200003000040000BTSBTSSAe-LexTournTotal running time (seconds) AlgorithmBTS/16/8BTS/2/128BTS/32/64BTS/8/128BTS/8/64BTSS/128/128BTSS/32/128BTSS/32/32BTSS/32/64BTSS/8/128Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8wineRed0200004000060000BTSBTSSAe-LexTournTotal running time (seconds) AlgorithmBTS/128/128BTS/128/16BTS/128/64BTS/16/16BTS/64/32BTSS/128/128BTSS/128/16BTSS/128/64BTSS/32/32BTSS/64/64Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8wineWhite0500010000BTSBTSSAe-LexTournTotal running time (seconds) AlgorithmBTS/16/32BTS/4/16BTS/4/64BTS/64/2BTS/8/32BTSS/16/64BTSS/4/128BTSS/4/32BTSS/4/64BTSS/8/128Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8yachtBatch Tournament Selection for Genetic Programming

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

Table 3: Quality and speedup. Wilcoxon-Rank sum test (α = 5%) with Ae-Lex as baseline where symbol ’-’ means the method
had lower MMAE than Ae-Lex, and ’+’ means the opposite. We compare only to the Ae-Lex (the baseline).

airfoil

concrete

energyCooling

energyHeating

Algorithm

MMAE

Speedup

Algorithm

MMAE Speedup

Algorithm

MMAE Speedup Algorithm MMAE Speedup

Ae-Lex
BTSS/8/128
BTSS/32/64
BTSS/8/64
BTSS/32/128
BTSS/4/128
BTS/4/32
BTS/8/64
BTS/16/128
BTS/4/16
BTS/8/16

3.129
3.274
3.279
3.286
3.334+
3.377+
3.467+
3.467+
3.526+
3.557+
3.626+
towerData
MMAE

Algorithm

1.00
11.30
12.61
16.22
7.55
11.46
20.77
14.30
8.10
25.84
23.63

Ae-Lex
BTSS/64/32
BTSS/64/128
BTSS/8/64
BTSS/8/128
BTSS/4/128
BTS/8/128
BTS/8/64
BTS/2/64
BTS/64/32
BTS/16/32

5.424
5.223
5.234
5.337
5.350
5.370
5.444
5.583
5.745+
5.841+
5.883+
wineRed

1.00
7.76
3.05
9.79
6.08
6.48
5.27
8.72
9.85
6.96
11.53

Ae-Lex
BTSS/4/64
BTS/8/64
BTSS/16/32
BTS/4/64
BTS/8/16
BTS/4/16
BTSS/8/32
BTS/8/32
BTSS/16/64
BTSS/4/32

1.279
1.189
1.237
1.258
1.267
1.313
1.355
1.370
1.411
1.423
1.571+
wineWhite

1.00
12.73
11.23
14.18
11.61
20.12
19.22
17.16
14.82
10.48
18.80

Ae-Lex
BTSS/4/64
BTSS/16/64
BTS/16/32
BTS/8/64
BTSS/8/64
BTS/4/64
BTSS/16/32
BTS/8/32
BTSS/8/32
BTS/16/64

0.733
0.689
0.697
0.740
0.769
0.777
0.785
0.820
0.856+
0.856+
0.940+
yacht

1.00
13.89
11.69
15.13
12.44
12.83
13.04
17.64
19.32
19.86
10.44

Speedup

Algorithm

MMAE Speedup

Algorithm

MMAE Speedup Algorithm MMAE Speedup

Ae-Lex
BTS/16/128
BTSS/32/128
BTSS/32/64
BTSS/128/128
BTS/64/32
BTSS/128/64
BTS/8/64
BTS/16/64
BTSS/16/128
BTS/128/32

32.423
27.358−
27.505−
27.843−
28.036−
28.266−
28.275−
28.826−
29.224−
29.594−
30.142

1.00
13.29
12.32
18.35
5.95
18.48
10.23
23.83
19.91
14.90
13.49

Ae-Lex
BTS/8/128
BTSS/32/128
BTS/8/64
BTS/32/64
BTSS/8/128
BTSS/128/128
BTSS/32/32
BTSS/32/64
BTS/2/128
BTS/16/8

0.472
0.449
0.463
0.464
0.467
0.468
0.480
0.481
0.503
0.505
0.558

1.00
7.58
6.22
12.26
8.59
8.67
3.04
15.90
10.63
8.14
27.11

Ae-Lex
BTSS/128/128
BTSS/64/64
BTS/64/32
BTSS/128/16
BTSS/128/64
BTS/128/16
BTS/128/64
BTS/128/128
BTSS/32/32
BTS/16/16

0.603
0.524−
0.529−
0.550−
0.560−
0.570−
0.574−
0.592−
0.593−
0.594−
0.611

1.00
4.79
11.57
14.41
17.79
8.16
16.81
6.36
3.60
20.05
24.86

Ae-Lex
BTS/64/2
BTS/16/32
BTSS/16/64
BTS/4/16
BTSS/4/128
BTS/4/64
BTSS/4/32
BTSS/4/64
BTSS/8/128
BTS/8/32

0.686
0.648
0.697
0.702
0.708
0.709
0.729
0.759
0.759
0.765
0.870

1.00
20.78
10.05
7.06
16.24
5.30
7.95
12.26
8.41
4.93
11.34

we did some experiments comparing some of the best performing
algorithms in terms of diversity (Figure 6). It is clear that pure tour-
naments do not reach the diversity of Ae-Lex. This happens because
in tournaments generalists are usually favoured. Which causes the
entire population to be similar (Tourn/2 is an exception because
the size of the tournament is small enough to make the influence
of the tournament almost zero. Consequently, selection becomes
mostly random. This naturally allows for a higher diversity with a
trade-off on quality of solutions). Regarding Ae-Lex and BTS/BTSS,
around 5 layers of diversity can be observed in Figure 6: Ae −
Lex > BT SS4/32, BT SS4/128, BT S4/16 > BT SS8/16, BT S8/16 >
BT S8/32, BT SS16/32, BT S8/64, BT SS16/64 > BT S128/8. This se-
quence can be explained by recalling the roles of both batch size
and tournament size. In one hand, batch size controls the overall
competition scenario. When batch size is big, batches will tend to
have a similar distribution, reducing the niching effect and con-
sequently favouring general solutions. Small batches have the op-
posite effect. Since general solutions are similar by definition, the
overall diversity of the population decreases. This explains why
bigger batch sizes result in less diversity. In fact, all the 5 layers
shown in Figure 6 respect this sequence.

Regarding the tournament size, it does not influence diversity
strongly. Notice that even if they allow some sub-optimal individu-
als to survive, these sub-optimal individuals have a small chance of
surviving the following generation. Thus, tournament can be seen
mostly as an approximation to the maximum function of selecting

the optimum individuals. Having said that, very small tournament
sizes may cause generalists to survive even in small batches. This
happens because the chance of a specialist individual being cho-
sen to compete in a favourable batch is smaller. Therefore, general
solutions which perform better overall would be favoured. This
partially explains the diversity of BTS128/8 but the batch size of 128
is also strongly affecting the diversity towards general solutions.
Moreover, Figure 6 demonstrates that tournament size of 16, 32 and
128 achieve similar diversity.

In summary, BTS and BTSS show that the use of batches can
achieve a diversity that rivals Ae-Lex while being efficient. Canoni-
cal tournament selection runs fail to achieve the level of diversity
which further explains their poor solution quality.

4.5.3 Batches and Ordered Test Cases. Surprisingly, both BTS
and BTSS do not use ordered test cases but batches while achieving
similar accuracy and diversity to Ae-Lex. Batches may have a totally
different characteristic but both batches and test sequences allow
for specialization to happen. In test sequences, order of test cases
creates a priority which fosters specialization. In batches, groups
of test cases define niches in which specialization happens.

5 ON THE SURVIVAL OF SPECIALISTS
In Nature, there is no global fitness function. Geography plays a
big role in dividing species into niches. And even in narrow places,
species find ways to survive which differ from each other, creating
in fact different fitness functions. Diversity is itself a byproduct

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

V. V. de Melo et al.

of specialization caused by natural multi-objectivization. In fact,
diversity measures within a single population have already been
shown to not help evolution, causing a deleterious conflict between
diversity and selection pressure that can only be solved with sub-
populations and multiple objectives [14].

In BTS and BTSS, similarly to Ae-Lex, diversity is achieved
through specialization and multi-objectivization. Batches can be
seen as different fitness functions (multi-objectivization) which
create different selection pressures, allowing for diversity to ap-
pear naturally. Specialization seems to arrive as a consequence of
batches with few changes throughout generations.

6 CONCLUSIONS
In this paper, we proposed the BTS, which combines the ability of
lexicase selection to provide accurate solutions with the compu-
tational complexity of simple tournament selection. Interestingly,
BTS achieves with batches a diversity similar to lexicase selection,
showing that batches are indeed very similar in behavior to the
ordering of test cases.

We argued that the similarity here derives from the fact that
both BTS and lexicase selection foster specialization of individuals.
In fact, fitness differs from batch to batch and therefore it can
be said that different fitness measurements take place within a
population. Consequently, BTS allows for multi-objectivization to
appear, increasing diversity and driving specialization forward.

In summary, this work shows the following:

• Up to 25 Times Speed Up With Similar Performance -
BTS and BTSS provided a speed up of up to 25 times when
compared to Ae-Lex. This is a consequence of BTS and BTSS
still having the computational complexity of tournament
selection while having the accuracy of Ae-Lex.

• The Similarity Between Batches and Ordered Test Ca-
ses - The tests show that batches have a similar behavior
to ordered test cases although the principle behind their
mechanisms are completely different. This reveals that the
main reason for Lexicase’s success may not be the ordered
test cases but a more general principle which can be achieved
in different ways.

• The Specialization and Multi-objectivization Hypoth-
esis - This work sheds light on the inner workings of lexi-
case selection by creating an algorithm with similar behavior
through a completely different mechanism. In fact, the sim-
ilarity can be seen not only in terms of accuracy but also
of diversity, demonstrating that the main principle behind
Lexicase is conserved.

In summary, we propose an algorithm that can rival the state-
of-the-art algorithms in performance while being one order of
magnitude faster. Moreover, investigations into the diversity and
overall performance of the proposed algorithms show a surprising
similarity to lexicase selection, shedding light on the main principle
behind Lexicase’s success.

ACKNOWLEDGMENTS
This work was supported by JST, ACT-I Grant Number JP-50166,
Japan.

Figure 5: Frequency for configurations that reside in the
top-five for any of the data sets. Notice that we do not de-
pict a rank here but how many times each configuration was
among the best. A blank cell means that this configuration
was not in the top-five for any of the data sets.

Figure 6: Diversity of the population over the generations
for the top-five overall configuration.

111121321111313132236312123323323111423BTSSBTS2481632641282816326412828163264128Batch sizeTournament size0.30.40.50.60.70.80.902505007501000GenerationMean percentage of unique individualsAlgorithmBTS/4/16BTS/8/16BTS/8/32BTS/8/64BTS/128/8BTSS/16/32BTSS/16/64BTSS/4/128BTSS/4/32BTSS/8/16Ae-LexTourn/16Tourn/2Tourn/32Tourn/4Tourn/8All datasetsBatch Tournament Selection for Genetic Programming

GECCO ’19, July 13–17, 2019, Prague, Czech Republic

REFERENCES
[1] David E Goldberg and Kalyanmoy Deb. 1991. A comparative analysis of selection
schemes used in genetic algorithms. In Foundations of Genetic Algorithms. Vol. 1.
Elsevier, 69–93.

[2] Thomas Helmuth and Lee Spector. 2015. General program synthesis benchmark
suite. In Proceedings of the 2015 Annual Conference on Genetic and Evolutionary
Computation. ACM, 1039–1046.

[3] Thomas Helmuth, Lee Spector, and James Matheson. 2015. Solving uncom-
promising problems with lexicase selection. IEEE Transactions on Evolutionary
Computation 19, 5 (2015), 630–643.

[4] Yaochu Jin. 2011. Surrogate-assisted evolutionary computation: Recent advances
and future challenges. Swarm and Evolutionary Computation 1, 2 (2011), 61–70.
[5] Krzysztof Krawiec and Paweł Liskowski. 2015. Automatic derivation of search
objectives for test-based genetic programming. In European Conference on Genetic
Programming. Springer, 53–65.

[6] William La Cava, Lee Spector, and Kourosh Danai. 2016. Epsilon-lexicase selec-
tion for regression. In Proceedings of the Genetic and Evolutionary Computation
Conference 2016. ACM, 741–748.

[7] Pawel Liskowski, Krzysztof Krawiec, Thomas Helmuth, and Lee Spector. 2015.
Comparison of semantic-aware selection methods in genetic programming. In
Proceedings of the Companion Publication of the 2015 Annual Conference on Genetic
and Evolutionary Computation. ACM, 1301–1307.

[8] Brad L Miller, David E Goldberg, et al. 1995. Genetic algorithms, tournament
selection, and the effects of noise. Complex Systems 9, 3 (1995), 193–212.

[9] Peter Nordin and Wolfgang Banzhaf. 1997. An on-line method to evolve behavior
and to control a miniature robot in real time with genetic programming. Adaptive
Behavior 5, 2 (1997), 107–140.

[10] Peter Nordin, Wolfgang Banzhaf, and Markus Brameier. 1998. Evolution of a
world model for a miniature robot using genetic programming. Robotics and
Autonomous Systems 25, 1-2 (1998), 105–116.

[11] Luiz Otavio VB Oliveira, Fernando EB Otero, and Gisele L Pappa. 2016. A
dispersion operator for geometric semantic genetic programming. In Proceedings
of the Genetic and Evolutionary Computation Conference 2016. ACM, 773–780.

[12] Mihai Oltean and C. Grosan. 2003. A Comparison of Several Linear Genetic

Programming. TECHNIQUES, COMPLEX-SYSTEMS 14 (2003), 282–311.

[13] Lee Spector. 2012. Assessment of problem modality by differential performance of
lexicase selection in genetic programming: a preliminary report. In Proceedings of
the 14th annual Conference Companion on Genetic and Evolutionary Computation.
ACM, 401–408.

[14] Danilo Vasconcellos Vargas, Junichi Murata, Hirotaka Takano, and Alexandre
Cláudio Botazzo Delbem. 2015. General sub-population framework and taming
the conflict inside populations. Evolutionary Computation 23, 1 (2015), 1–36.
[15] Danilo Vasconcellos Vargas, Hirotaka Takano, and Junichi Murata. 2013. Self
organizing classifiers and niched fitness. In Proceedings of the fifteenth annual
Conference on Genetic and Evolutionary Computation Conference. ACM, 1109–
1116.

