Divide, Conquer, and Combine: a New Inference Strategy
for Probabilistic Programs with Stochastic Support

Yuan Zhou 1 Hongseok Yang 2 Yee Whye Teh 3 Tom Rainforth 3

0
2
0
2

l
u
J

6
1

]
L
M

.
t
a
t
s
[

3
v
4
2
3
3
1
.
0
1
9
1
:
v
i
X
r
a

Abstract
Universal probabilistic programming systems
(PPSs) provide a powerful framework for spec-
ifying rich probabilistic models. They further
attempt to automate the process of drawing infer-
ences from these models, but doing this success-
fully is severely hampered by the wide range of
non–standard models they can express. As a re-
sult, although one can specify complex models in
a universal PPS, the provided inference engines of-
ten fall far short of what is required. In particular,
we show that they produce surprisingly unsatisfac-
tory performance for models where the support
varies between executions, often doing no bet-
ter than importance sampling from the prior. To
address this, we introduce a new inference frame-
work: Divide, Conquer, and Combine, which re-
mains efﬁcient for such models, and show how it
can be implemented as an automated and generic
PPS inference engine. We empirically demon-
strate substantial performance improvements over
existing approaches on three examples.

1. Introduction

Probabilistic programming systems (PPSs) provide a ﬂex-
ible platform where probabilistic models are speciﬁed as
programs and inference procedures are performed in an au-
tomated manner. Some systems, such as BUGS (Tesauro
et al., 2012) and Stan (Carpenter et al., 2017), are primarily
designed around the efﬁcient automation of a small num-
ber of inference strategies and the convenient expression of
models for which these inference strategies are suitable.

Universal PPSs, such as Church (Goodman et al., 2008),
Venture (Mansinghka et al., 2014), Anglican (Wood et al.,

1Department of Computer Science, University of Oxford,
United Kingdom 2School of Computer Science, KAIST, South Ko-
rea 3Department of Statistics, University of Oxford, United King-
dom. Correspondence to: Yuan Zhou <yuan.zhou@cs.ox.ac.uk>.

Proceedings of the 37 th International Conference on Machine
Learning, Vienna, Austria, PMLR 119, 2020. Copyright 2020 by
the author(s).

Figure 1. MAP estimate of the means and covariances of a Gaus-
sian mixture model in the cases of K = 1 and K = 2 clusters. If
K is itself random, the model has stochastic support as the param-
eters of the second cluster, e.g. its mean, only exist when K = 2.

2014), and Pyro (Bingham et al., 2018), on the other hand,
are set up to try and support the widest possible range of
models a user might wish to write. Though this means that
such systems can be used to write models which would
be otherwise difﬁcult to encode, this expressiveness comes
at the cost of signiﬁcantly complicating the automation of
inference. In particular, models may contain random vari-
ables with mixed types or have varying, or even unbounded,
dimensionalities; characteristics which cause signiﬁcant
challenges at the inference stage.

In this paper, we aim to address one of the most challenging
model characteristics: variables whose very existence is
stochastic, often, though not always, leading to the overall
dimensionality of the model varying between realizations.
Many practical models posses this characteristic. For exam-
ple, many models contain a variable controlling an allowed
number of states, such as the number of clusters in a mix-
ture model (see Figure 1, Richardson & Green 1997; Nobile
& Fearnside 2007), or the number of states in a HMM or
change point model (Fox et al., 2008). More generally, many
inference problems involve some sort of Bayesian model
averaging where the constituent models do not share the
exact same set of parameters. Other models are inherently
deﬁned on spaces with non-static support, such as probabilis-
tic context free grammars (PCFGs) (Manning et al., 1999),
program induction models (Perov & Wood, 2014), kernel
or function induction models (Schaechtle et al., 2016; Janz
et al., 2016), many Bayesian non-parametric models (Roy
et al., 2008; Teh, 2010), and a wide range of simulator–based
models (Le et al., 2016; Baydin et al., 2019).

 
 
 
 
 
 
Divide, Conquer, and Combine

These models can be easily expressed in universal PPSs via
branching statements, stochastic loops, or higher-order func-
tions (see e.g. Figure 2). However, performing inference in
them is extremely challenging, with the desire of PPSs to
automate this inference complicating the problem further.

A number of automated inference engines have been
proposed to provide consistent estimates in such set-
tings (Wingate et al., 2011; Wood et al., 2014; Tolpin &
Wood, 2015; Ge et al., 2018; Bingham et al., 2018). How-
ever, they usually only remain effective for particular sub-
classes of problems. In particular, we will show that they can
severely struggle on even ostensibly simple problems, often
doing no better, and potentially even worse, than importance
sampling from the prior.

To address these shortfalls, we introduce a completely new
framework—Divide, Conquer, and Combine (DCC)—for
performing inference in such models. DCC works by di-
viding the program into separate straight-line sub-programs
with ﬁxed support, conquering these separate sub-programs
using an inference strategy that exploits the ﬁxed support
to remain efﬁcient, and then combining the resulting sub-
estimators to an overall approximation of the posterior. The
main motivation behind this approach is that the difﬁculty
in applying Markov chain Monte Carlo (MCMC) strategies
to such programs lies in the transitioning between variable
conﬁgurations; within a given conﬁguration efﬁcient in-
ference might still be challenging, but will be far easier
than tackling the whole problem directly. Furthermore, this
approach also allows us to introduce meta-strategies for al-
locating resources between sub-programs, thereby explicitly
controlling the exploration-exploitation trade-off for the in-
ference process in a manner akin to Rainforth et al. (2018);
Lu et al. (2018). To demonstrate its potential utility, we
implement a speciﬁc realization of our DCC framework as
an automated and general-purpose inference engine in the
PPS Anglican (Wood et al., 2014), ﬁnding that it is able to
achieve substantial performance improvements and tackle
more challenging models than existing approaches.

To summarize, our key contributions are as follows:

• We highlight shortcomings of existing PPS inference

engines in the presence of stochastic support;

• We introduce a new framework, DCC, for performing

inference in such problems;

• We implement a speciﬁc realization of this DCC frame-

work in the PPS Anglican.

2. Probabilistic Programming

In universal PPSs (Goodman et al., 2008; Mansinghka et al.,
2014; Wood et al., 2014; Bingham et al., 2018; Ge et al.,
2018), a program may denote a model with varying support:
different realizations of a program may lead to different
sets of variables being sampled. For example, in Figure 2,

y1 9]
(if (< z0 0)

1 (let [z0 (sample (normal 0 2))
2
3
4
5
6
7
8
9
10

(let [z1 (sample (normal -5 2))]
(observe (normal z1 2) y1)
[z0 z1])

(observe (normal z3 2) y1))
[z0 z2 z3])))

(let [z2 (sample (normal 5 2))

z3 (sample (normal z2 2))]

Figure 2. Example program with stochastic support (top) and its
possible execution traces (bottom). The two branches of the if
each produce a different sample path, denoted as A1 and A2, and
each have a different supports denoted as X1 and X2 respectively.

there are two possible variable conﬁgurations, [z0, z1] and
[z0, z2, z3], due to the stochastic control-ﬂow.

To aid exposition and formalize these programs, we will
use the formalization of the particular universal PPS Angli-
can (Wood et al., 2014; Tolpin et al., 2016), but note that
our ideas are applicable to other universal PPSs. Angli-
can extends the syntax of Clojure with two special forms:
sample and observe, between which the distribution
of the program is deﬁned. sample statements are used
to draw random variables, while observe statements are
used to condition on data. Informally, they can be thought
of as prior and likelihood terms, respectively.

The density of an Anglican program is derived by executing
it in a forward manner, drawing from sample statements
when encountered, and keeping track of density compo-
nents that originate from the sample and observe terms.
Speciﬁcally, let {xi}nx
i=1 = (x1, . . . , xnx ) represent the ran-
dom variables generated from the encountered sample
statements, where the ith statement among them has lexical
program address ai, input ηi, and density fai(xi|ηi). Analo-
gously, let {yj}ny
j=1 = (y1, . . . , yny ) represent the observed
values of the ny observe statements encountered during
execution, which have lexical addresses bj and correspond-
ing densities gbj (yj|φj), where φj is analogous to ηi. The
density is now given by π(x) = γ(x)/Z where

γ(x) :=

nx(cid:89)

i=1

fai(xi|ηi)

ny
(cid:89)

j=1

gbj (yj|φj),

(1)

Z :=

(cid:90) nx(cid:89)

i=1

fai(xi|ηi)

ny
(cid:89)

j=1

gbj (yj|φj)dx1:nx,

(2)

ArXivDivide, Conquer, and Combine

and the associated reference measure is implicitly deﬁned
through the executed sample statements. Note that every-
thing here (i.e. nx, ny, x1:nx, y1:ny , a1:nx , b1:ny , η1:nx, and
φ1:ny ) is a random variable, but each is deterministically
calculable given x1:nx (see §4.3.2 of Rainforth (2017)).

From this, we see that it is sufﬁcient to denote an exe-
cution trace (i.e. realization) of an Anglican program by
the sequence of the addresses of the encountered sample
statements and the corresponding sampled values, namely
[ai, xi]nx
i=1.1 For clarity, we refer to the sequence a1:nx as
the path of an execution trace and x1:nx as the draws. A
program with stochastic support can now be more formally
deﬁned as one for which the path a1:nx varies between real-
izations: different values of the path correspond to different
conﬁgurations of variables being sampled.

3. Shortcomings of Existing Inference Engines

In general, existing inference engines that can be used for (at
least some) problems with stochastic support can be grouped
into ﬁve categories: importance/rejection sampling, particle
based inference algorithms (e.g. SMC, PG, PIMH, PGAS,
IPMCMC, RM-SMC, PMMH, SMC2), MCMC approaches
with automated proposals (e.g. LMH, RMH), MCMC ap-
proaches with user–customized proposals (e.g. RJMCMC),
and variational approaches (VI, BBVI). More details on
each are provided in Appendix A.

Importance/rejection sampling approaches can straightfor-
wardly be applied in stochastic support settings by using
the prior as the proposal, but their performance deteriorates
rapidly as the dimensionality increases. Particle–based ap-
proaches offer improvements for models with sequential
structure (Wood et al., 2014), but become equivalent to
importance sampling when this is not the case.

Some variational inference (VI) approaches can, at least in
theory, be used in the presence of stochastic support (Bing-
ham et al., 2018; Cusumano-Towner et al., 2019), but this
can require substantial problem–speciﬁc knowledge to con-
struct a good guide function, requires a host of practical
issues to be overcome (Paige, 2016, Chapter 6), and is
at odds with PPSs desire for automation. Furthermore,
these approaches produce inconsistent estimates and cur-
rent engines often give highly unsatisfactory practical per-
formance as we will show later. When using such meth-
ods, it is common practice to side–step the complications
originating from stochastic support by approximating the
model with a simpler one with ﬁxed support. For example,
though Pyro can ostensibly support running VI in models
with stochastic support, their example implementation of

1Strictly speaking, the addresses ai can be deterministically
derived from the sampled values for a given program. However,
for our purposes it will be convenient to think about ﬁrst sampling
the path a1:nx and then sampling x1:nx conditioned on this path.

Figure 3. Kernel density estimation of the synthetic data (black) of
the univariate mixture model and the posterior predictive distribu-
tion from BBVI (brown) and RMH (green) in Anglican.

a Dirichlet process mixture model (https://pyro.ai/
examples/dirichlet_process_mixture.html) uses
ﬁxed support approximations by assuming a bounded num-
ber of mixture components before stripping clusters away.

Because of these issues, arguably the current go–to ap-
proaches for programs with stochastic support are special-
ized MCMC approaches (Wingate et al., 2011; Roberts et al.,
2019). However, these are themselves far from perfect and,
as we show next, they often given performance far worse
than one might expect.

A demonstrative example Consider the following simple
mixture model with an unknown number of clusters K

K ∼ Poisson(9)+1, µk ∼ Uniform

(cid:18) 20(k − 1)
K

(cid:19)
,

,

20k
K

zn ∼ Cat({1/K, ..., 1/K}), yn ∼ N (µzn , 0.12).

Here µ1:K are the cluster centers, z1:N are the cluster as-
signments, and y1:N is the observed data. When conducting
inference, we can analytically marginalize out the cluster as-
signments z1:N and perform inference on K and µ1:K only.
However, as the prior on K is a Poisson distribution, the
number of parameters in the model is unbounded. Using the
model itself, we generated a synthetic dataset of y1:150 for
an one-dimensional mixture of ﬁve clusters (i.e. K = 5).

We now wish to perform inference over both the number of
clusters K and the cluster means µ1:K, so that we can make
predictions from the posterior predictive distribution. Two
approaches we might try are VI, for which we use Angli-
can’s black-box variational inference (BBVI) implementa-
tion (Ranganath et al., 2014; Paige, 2016), and MCMC, for
which we take its RMH algorithm (Le, 2015), a derivative
of the single-site MH algorithm of (Wingate et al., 2011)
(see below). Unfortunately, as we see in Figure 3, both
approaches fail spectacularly and produce posterior predic-
tive distributions that bare little resemblance to the data. In
particular, they fail to properly encapsulate the number of
clusters. As we will show in §7.1, importance sampling
and particle–based inference engines fare no better for this
problem. In fact, we are not aware of any fully automated in-
ference engine that is able to give satisfactory performance,
despite the apparent simplicity of the problem.

05101520X0.00.51.0DensitydataBBVIRMHDivide, Conquer, and Combine

3.1. Why is MCMC so Hard with Stochastic Support?

To run MCMC on a program with stochastic support, one
needs to be able to construct a transition kernel that is
able to switch between the conﬁgurations; many popular
MCMC methods, like Hamiltonian Monte Carlo (HMC),
cannot be applied. One can either look to construct this
transition kernel manually through a carefully chosen user–
speciﬁed trans–dimensional proposal and then using a re-
versible jump MCMC (RJMCMC) scheme (Green, 1995;
2003; Roberts et al., 2019; Cusumano-Towner et al., 2019),
or use a general–purpose kernel that works on all mod-
els (Wingate et al., 2011; Goodman & Stuhlm¨uller, 2014).

The predominant approaches for the latter are the single-
site MH (a.k.a. LMH) algorithm (Wingate et al., 2011)
and its extensions (Yang et al., 2014; Le, 2015; Tolpin
et al., 2015; Ritchie et al., 2016b). LMH is based around a
Metropolis-within-Gibbs (MwG) approach on the program
traces (Brooks et al., 2011), whereby one ﬁrst samples a
variable in the execution trace, i ∈ 1 : nx, uniformly at ran-
dom and then proposes a MwG transition to this variable,
xi → x(cid:48)
i, followed by an accept/reject step. Anglican’s
RMH is a particular case of this LMH approach where
the proposal is a mixture of resampling xi from the prior
fai(xi|ηi) and a local random walk proposal p(x(cid:48)

i|xi).

The problem with LMH approaches is that if the transition
of xi inﬂuences the downstream control ﬂow of the program,
the downstream draws no longer produce a valid execution
trace and so must be redrawn, typically using the prior. This
can cause the mixing of the sampler over conﬁgurations to
become extremely slow; the need to transit between conﬁg-
urations bottlenecks the system.

This problem is also far from speciﬁc to the exact transition
kernel used by LMH samplers: it is also extremely chal-
lenging to hand–craft RJMCMC proposals to be effective.
Namely, proposing changes in the conﬁguration introduces
new variables that might not be present in the current conﬁg-
uration, such that our proposal for them effectively becomes
an importance sampling proposal. Furthermore, the poste-
rior on the other variables may shift substantially when the
conﬁgurations changes.

In short, one loses a notion of locality: having a sample
in a high density region of one conﬁguration typically pro-
vides little information about which regions have a high
density for another conﬁguration. For example, in a mixture
model shown in Figure 1, having a good characterization of
µ1|K = 1 provides little information about the distribution
of µ1|K = 2, as shown by the substantial change in their
mode, µ∗
1. It is thus extremely difﬁcult to design proposals
which maintain a high acceptance rate when proposing a
new conﬁguration: once in a high density region of one
conﬁguration, it becomes difﬁcult to switch to another con-

ﬁguration. This problem is further compounded by the fact
that RJMCMC only estimates the relative mass of each
conﬁguration through the relative frequency of transitions,
giving a very slow convergence for the overall sampler.

4. Divide, Conquer, and Combine

The challenges for running MCMC methods on programs
with stochastic support stem from the difﬁcultly in transi-
tioning between conﬁgurations properly. To address this,
we now introduce a completely new inference framework
for these programs: Divide, Conquer, and Combine (DCC).
Unlike most existing inference approaches which directly
target the full program density (i.e. (1)), DCC breaks the
problem into individual sub-problems with ﬁxed support
and tackles them separately. Speciﬁcally, it divides the over-
all program into separate straight-line sub-programs accord-
ing to their execution paths, conquers each sub-program by
running inference locally, and combines the results together
to form an overall estimate in a principled manner.

In doing this, DCC transfers the problem of designing an
MCMC proposal which both efﬁciently transitions between
paths (i.e. varying conﬁgurations) and mixes effectively over
the draws on that path, to that of a) performing inference
locally over the draws of each given path, and b) learning
the relative marginal posterior mass of these paths. This
separation brings the beneﬁt that the inference for a given
path can typically be performed much more efﬁciently than
when using a global sampler, as it can exploit the ﬁxed sup-
port and does not need to deal with changes in the variable
conﬁguration. Furthermore, it allows the relative posterior
mass to be estimated more reliably than with global MCMC
schemes, for which this is estimated implicitly through the
relative frequency of the, typically infrequent, transitions.

We now explain the general setup for each component of
DCC. Speciﬁc strategies for each will be introduced in §6,
while an overview of the approach is given in Algorithm 1.

4.1. Divide

The aim of DCC’s divide step is to split the given proba-
bilistic program into its constituent straight-line programs
(SLPs), where each SLP is a partition of the overall program
corresponding to a particular sequence of sample addresses
encountered during execution, i.e. a particular path a1:nx .
Each SLP has a ﬁxed support as the set of variables it draws
are ﬁxed by the path, i.e. the program draws from the same
ﬁxed set of sample statements in the same order.

Introducing some arbitrary indexing for the set of SLPs, we
use Ak to denote the path for the kth SLP (i.e. a1:nx,k = Ak
for every possible realization of this SLP). The set of of all
possible execution paths is now given by A = {Ak}K
k=1,
where K must be countable (but need not be ﬁnite). For the

Divide, Conquer, and Combine

example in Figure 2, this set consists of two paths A1 =
[#l1, #l4] and A2 = [#l1, #l7, #l8], where we use #lj
to denote the lexical address of the sample statement is
on the jth line. Note that, for a given program, each SLP
is uniquely deﬁned by its corresponding path Ak; we will
sometimes use Ak to denote an SLP.

Dividing a program into its constituent SLPs implicitly par-
titions the overall target density into disjoint regions, with
each part deﬁning a sub-model on the corresponding sub-
space. The unnormalized density γk(x) of the SLP Ak is
deﬁned with respect to the variables {xi}nx,k
i=1 that are paired
with the addresses {ai}nx,k
i=1 of Ak (where we have used
the notation nx,k to emphasize that this is now ﬁxed). We
use Xk to denote its corresponding support. Note that the
union of all the Xk is the support of the original program,
X = (cid:83)K
k=1 Xk. Analogously to (1), we now have that the
density of SLP k is πk(x) = γk(x)/Zk where

γk(x) := γ(x)I[x ∈ Xk]
nx,k
(cid:89)

= I[x ∈ Xk]

fAk[i](xi|ηi)

(cid:90)

Zk :=

x∈Xk

i=1

γk(x)dx.

ny
(cid:89)

j=1

gbj (yj|φj), (3)

(4)

Unlike for (1), nx,k and Ak are now, critically, deterministic
variables so that the support of the problem is ﬁxed. Though
bj and ny may still be stochastic, they do not effect the
reference measure of the program and so this does not cause
a problem when trying to perform MCMC sampling.

Following our example in Figure 2, for A1 we have
x1:2 = [z0, z1], X1 = {[x1, x2] ∈ R2 | x1 < 0}, and
γ1(x) = N (x1; 0, 2)N (x2; −5, 2)N (y1; x2, 2)I[x1 < 0].
For A2, we instead have x1:3 = [z0, z2, z3], X2 =
{[x1, x2, x3] ∈ R3
| x1 ≥ 0} and γ2(x) =
N (x1; 0, 2)N (x2; 5, 2)N (x3; x2, 2)N (y1; x3, 2)I[x1 ≥ 0].

To implement this divide step, we now need a mechanism
for establishing the SLPs. This can either be done by trying
to extract them all upfront, or by dynamically discovering
them as the inference runs, see §6.2.

4.2. Conquer

Given access to the different SLPs produced by the divide
step, DCC’s conquer step looks to carry out the local in-
ference for each. Namely, it aims to produce a set of esti-
mates for the individual SLP densities πk(x) and the corre-
sponding marginal likelihoods Zk. As each SLP has a ﬁxed
support, this can be achieved with conventional inference
approaches, with a large variety of methods potentially suit-
able. Note that πk(x) and Zk need not be estimated using
the same approach, e.g. we may use an MCMC scheme to
estimate πk(x) and then introduce a separate estimator for
Zk. One possible estimation strategy is given in §6.1.

Algorithm 1 Divide, Conquer, and Combine (DCC)
Input: Program prog , number of iterations T
Output: Posterior approx ˆπ, ML estimate ˆZ
1: Obtain initial set of discovered SLPs ˆA (cid:46) §4.1, §6.2
2: Compute initial estimates ∀Ak ∈ ˆA
(cid:46) §4.2, §6.1
3: for t = 1, . . . , T do
4:
5:
6:

Choose an SLP Ak ∈ ˆA to update
(cid:46) §6.3
Update local estimates ˆπk and ˆZk
(cid:46) §4.2, §6.1
[Optional] Look for undiscovered SLPs (e.g. using a
global proposal), add any found to ˆA
(cid:46) §6.2

7: end for
8: Combine local approximations as per (5)

(cid:46) §4.3

An important component in carrying out this conquer step
effectively is to note that it is not usually necessary to obtain
estimates of equally-high ﬁdelity for all SLPs. Speciﬁcally,
SLPs with small marginal likelihoods Zk only make a small
contribution to the overall density and thus do not require as
accurate estimation as SLPs with large Zk. As such, it will
typically be beneﬁcial to carry out resource allocation as
part of the conquer step, that is, to generate our estimates in
an online manner where at each iteration we use information
from previous samples to decide the best SLP(s) to update
our estimates for. See §6.3 for one possible such strategy.

4.3. Combine

The role of DCC’s combine step is to amalgamate the local
estimates from the individual SLPs to an overall estimate
of the distribution for the original program. For this, we
can simply note that, because the supports of the individual
SLPs are disjoint and their union is the complete program,
we have γ(x) = (cid:80)K
k=1 γk(x) and Z = (cid:80)K
k=1 Zk, such that
the unnormalized density and marginal likelihoods are both
additive. Consequently, we have

π(x) =

(cid:80)K

k=1 γk(x)
(cid:80)K
k=1 Zk

=

(cid:80)K

k=1 Zkπk(x)
(cid:80)K
k=1 Zk

≈

(cid:80)K

k=1
(cid:80)K

ˆZk ˆπk(x)
ˆZk

k=1

=: ˆπ(x)

(5)

where ˆπk(x) and ˆZk are the SLP estimates generated during
the conquer step. Note that, by proxy, this also produces the
overall marginal likelihood estimate ˆZ := (cid:80)K

ˆZk.

k=1

When using an MCMC sampler for πk(x), ˆπk(x) will take
the form of an empirical measure comprising of a set of
(cid:80)Nk
samples, i.e. ˆπk(x) = 1
m=1 δˆxk,m (x). If we use an
Nk
importance sampling or particle ﬁltering based approach
instead, our empirical measure will compose of weighted
samples. We note that in this case, the ˆZk term in the numer-
ator of (5) will cancel with any potential self-normalization
term used in ˆπk(x), such that we can think of using the
k=1 ˆγk(x))/((cid:80)K
estimate π(x) ≈ ((cid:80)K

ˆZk).

k=1

Divide, Conquer, and Combine

5. Theoretical Correctness

We now demonstrate that the outlined general DCC ap-
proach is consistent (as T → ∞ where T is the number of
iterations) given some simple assumptions about the individ-
ual component strategies. At a high level, these assumptions
are that the estimators used for each SLP, ˆπk and ˆZk, are
themselves consistent, we use an SLP extraction strategy
that will eventually uncover all of the SLPs with ﬁnite proba-
bility mass, and our resource allocation strategy selects each
SLP inﬁnitely often given an inﬁnite number of iterations.

More formally we have the following result
Theorem 1. If Assumptions 1-5 in Appendix C hold, then
the empirical measure, ˆπ (·), produced by DCC converges
weakly to the conditional distribution of the program in the
limit of large number of iterations T :

ˆπ (·) d→ π (·)

as T → ∞.

The proof is provided in Appendix C. We note that it is
typically straightforward to ensure that these assumptions
hold; the speciﬁc approaches we outline next satisfy them.

6. DCC in Anglican

We now outline a particular realization of our DCC frame-
work. It is implemented in Anglican and can be used to
run inference automatically for any valid Anglican program.
As part of this, we suggest particular strategies for the indi-
vidual components left unspeciﬁed in the last section, but
emphasize that these are far from the only possible choices;
DCC should be viewed more as a general framework. Ad-
ditional details including a complete algorithm block are
given in the appendices.

6.1. Local Estimators

Recall that the goal for the local inference is to estimate
the local target density πk(x) and the local marginal likeli-
hood Zk. Straightforward choices include (self-normalized)
importance sampling and SMC as both return a marginal
likelihood estimate ˆZk. However, knowing good proposals
for these a priori is challenging and, as we discussed in §3,
na¨ıve choices are unlikely to perform well.

Thankfully, each SLP has a ﬁxed support, which means
many of the complications that make inference challenging
for universal PPSs no longer apply. In particular, we can
use conventional MCMC samplers—such as MH, HMC, or
MwG—to approximate πk(x). Due to the fact that individ-
ual variable types may be unknown or not even ﬁxed, we
have elected to use MwG in our implementation, but note
that more powerful inference approaches like HMC may be
preferable when they can be safely applied. To encourage
sample diversity and assist in estimating Zk (see below), we
further run N independent MwG samplers for each SLP.

As MCMC samplers do not directly provide an estimate for
Zk, we must introduce a further estimator that uses these
samples to estimate it. For this, we use PI-MAIS (Martino
et al., 2017). Details are given in Appendix D.

6.2. Discovering SLPs

To divide a given model into its constituent sub-models
expressed by SLPs, we need a mechanism for discovering
them automatically. One possible approach would be to
analyze the source code of the program using static analysis
techniques (Chaganty et al., 2013; Nori et al., 2014), thereby
extracting the set of possible execution paths of the program
at compilation time. Though potentially a viable choice in
some scenarios, this can be difﬁcult to achieve for all possi-
ble programs in a universal PPS. For example, the number
of possible paths may be unbounded. We therefore take
an alternative approach that discovers SLPs dynamically at
run–time as part of the inference. In general, it maintains
a set of SLPs encountered so far, and remembers any new
SLP discovered by the MCMC proposals at each iteration.

Our approach starts by executing the program forward for
T0 iterations to generate some sample execution traces from
the prior. The paths traversed by these sampled traces are
recorded, and our set of SLPs is initialized as that of these
recorded paths. At subsequent iterations, after each local
inference iteration, we then perform one global MCMC step
based on our current sub-model and trace, producing a new
trace with path Ak(cid:48) that may or may not have changed. If
Ak(cid:48) corresponds to an existing SLP, this sample is discarded
(other than keeping count of the number of proposed tran-
sitions into each SLP). However, if it corresponds to an
unseen path, it is added to our set of SLPs as a new sub-
model, followed by Tw MCMC steps restricted to that path
to burn-in. The sample of the ﬁnal step will be stored as
initiation for the future local inference on that path.

The key difference between our strategy and running a single
global MCMC sampler (e.g. RMH), is that we do not need
this new sample to be accepted for the new SLP to be “dis-
covered”. Because, as we explained in § 3, making effective
proposals into a high–density region of a new conﬁguration
is very challenging, it is unlikely that the new trace sample
we propose has high density: even if it corresponds to a
path with large Zk, we are unlikely to immediately sample
a good set of draws to accompany it. Therefore, the global
MCMC sampler is very likely to miss or forget new SLPs
since it accepts/rejects movements based on one sample.

DCC, on the other hand, overcomes this problem by ﬁrst
remembering the path information of any newly proposed
SLP, and then carrying out a few local warm-up iterations,
before deciding whether an SLP is a promising sub-model
or not in later exploration. As a result, DCC does not suf-
fer from the reliance on forward sampling as per RMH to

Divide, Conquer, and Combine

Figure 4. Results for DCC and baselines for the GMM example outlined in §3. [Left] Convergence in squared error in log marginal
likelihood estimate || log ˆZ − log Ztrue ||2. The solid line corresponds to the median across 15 runs and the shading region 25% − 75%
quantiles. Note that none of IS, RMH, PG, IPMCMC, and BBVI provide such at estimate, hence their omission; an additional baseline
of drawing importance samples from a proposal centered on and RMH chain was considered instead. [Right] Final estimates for
p(K = 5 | y1:Ny ) for each of the 15 runs, for the ground truth is roughly 0.9998. In both cases, the ground truth was estimated using a
very large number of importance samples with a manually adapted proposal. We see that DCC substantially outperforms the baselines.

discover new SLPs. Moreover, our scheme inherits the hill-
climbing behavior of MCMC to discover SLP in a more
efﬁcient way: it can ﬁnd the sub-models of high posterior
mass even under an extremely small prior probability, as
will be shown in §7.2. Note that there are some subtleties
to maintain the efﬁciency as the number of possible SLPs
grow large, see Appendix E for further details.

6.3. Allocating Resources Between SLPs

At each iteration we must choose an SLP from those dis-
covered to perform local inference on. Though valid, it is
not wise to split our computational resources evenly among
all SLPs; it is more important to ensure we have accurate
estimates for SLPs with large Zk. Essentially, we have a
multi-armed bandit problem where we wish to develop a
strategy of choosing SLPs that will lead to the lowest er-
ror in our overall ﬁnal estimate ˆπ. Though it might seem
that this is a problem that DCC has introduced, it is actu-
ally an inherent underlying problem that must always be
solved for models with stochastic support; DCC is simply
making the problem explicit. Namely, we do not know up-
front which SLPs have signiﬁcant mass and so any inference
method must deal with the computational trade–off involved
in ﬁguring this out. Conventional approaches do this in an
implicit, and typically highly inefﬁcient, manner. For exam-
ple, MCMC relies on the relatively frequency of individual
transitions between SLPs to allocate resources, which will
generally be extremely inefﬁcient for ﬁnite budgets.

To address this, we introduce a resource allocation scheme
based on an upper conﬁdence bounding (UCB) approach
developed in Rainforth et al. (2018). Speciﬁcally, we use
the existing SLPs estimates to construct a utility function
that conveys the relative merit of reﬁning the estimates
for each SLP, balancing the need for exploitation, that is
improving the estimates for SLPs currently believed to have
large relative Zk, and exploration, that is improving our
estimates for SLPs where our uncertainty in Zk is large.
At each iteration, we then update the estimate for the SLP

which has the largest utility, deﬁned as

Uk :=

1
Sk

(cid:18) (1 − δ)ˆτk
maxk{ˆτk}

+

δ ˆpk
maxk{ˆpk}

+

(cid:19)

β log (cid:80)
√
Sk

k Sk

where Sk is the number of times we have previously per-
formed local inference on Ak; ˆτk is the current estimate
of the “reward” of Ak, incorporating both how much mass
the SLP contains and how efﬁcient our estimates are for it;
ˆpk is a targeted exploration term that helps identify promis-
ing SLPs that we are yet to establish good estimates for;
0 ≤ δ ≤ 1 is a hyperparameter controlling the trade–off
between these terms; and β > 0 is the standard optimism
boost hyper-parameter. For more details see Appendix F.

7. Experiments

7.1. Gaussian Mixture Model (GMM)

We now further investigate the GMM example with an un-
known number of clusters introduced in §3. Its program
code written in Anglican is provided in Appendix G.1. We
compare the performance of DCC against ﬁve baselines: im-
portance sampling (from prior) (IS), RMH (Le, 2015), Parti-
cle Gibbs (PG) (Andrieu et al., 2010), interacting Particle
MCMC (IPMCMC) (Rainforth et al., 2016), and Black-box
Variational Inference (BBVI) (Paige, 2016), taking the same
computational budget of 106 total samples for each.

We ﬁrst examine the convergence of the overall marginal
likelihood estimate ˆZ. Here IS is the only baseline which
can be used directly, but we also consider drawing impor-
tance samples centered around the RMH chain in a manner
akin to PI-MAIS. Figure 4 [Left] shows that DCC outper-
forms both by many orders of magnitude. The sudden drop
in the error for DCC is because the dominant sub-model
with K = 5 is typically discovered after taking around 104
samples. Further investigation of that SLP allows DCC to
improve the accuracy of the estimate. DCC has visited 23
to 27 sub-models (out of inﬁnitely many) among all 15 runs.

102103104105106Total Cost106104102100102104106Squared ErrorDCCISIS from RMHDCC (ours)ISRMHPGIPMCMCBBVI0.00.51.0p(K=5|Y)Ground TruthDivide, Conquer, and Combine

We next examine the posterior distribution of K and report
the estimates of p(K = 5 | y1:Ny ) in Figure 4 [Right]. We
see that all methods other than DCC struggle. Here , the
accuracy of the posterior of K reﬂects the accuracy in es-
timating the relative masses of the different SLPs, i.e. Zk,
explicitly or implicitly. The dimension of this model varies
between one and inﬁnity and the posterior mass is concen-
trated in a small sub-region (K = 5) with small prior mass.
It is therefore challenging for the baselines to either to learn
each marginal likelihood simultaneously (eg. in IS) or to
estimate the relative masses implicitly through transitions
between conﬁgurations using an MCMC sampler. By break-
ing down the model into sub-problems, DCC is able to
overcome these challenges and provide superior posterior
estimator for the overall model.

7.2. GMM with Misspeciﬁed Prior

To further test the capability of each method to discover
SLPs—and to examine the MCMC-esque behavior for DCC
in SLP space in particular—we adjust the GMM example
above slightly so that K now has a, high misspeciﬁed, prior
of Poisson(90)+1, keeping everything else the same. The
dominant SLP is still K = 5 (with around 0.9976 posterior
mass), but his now has an extremely low prior probability
(around 10−14). Consequently, ﬁnding this dominant SLP
is only practically possible if the algorithm exhibits an ef-
fective hill climbing behavior in SLP space. We only now
compare DCC to RMH on the basis that: a) none of the
baselines could deal with simpler case before, such that they
will inevitably not be able to deal with this harder problem;
and b) RMH is the only baseline where one might expect to
see some hill climbing behavior in SLP space.

Figure 5(a) shows the trace plot for the SLP visit history
(i.e. sampled K at each iteration) of each method. As we
can see in the bottom plot, DCC starts from the SLPs of K
around 90, inﬂuenced by the prior, and gradually discov-
ers smaller Ks with higher posterior mass, also exploring
large values of K as well. This implies a MCMC-esque hill-
climbing behavior guided by our SLP discovery scheme.
Moreover, the trace plot also demonstrates the resource allo-
cation within DCC where it gradually spends more computa-
tion for SLPs with lower Ks while still maintaining a degree
of exploration. Both factors are essential for the resulting
accurate posterior approximation shown in Figure 5(b).

By comparison, RMH gets stuck in its initialized SLP (Fig-
ure 5(a) top): for the one run shown it only makes one suc-
cessful transition to another SLP and never gets anywhere
close to region of SLPs with signiﬁcant mass. Equivalent be-
havior was experience in all the other runs (not shown). As
a result, it does not produce a reasonable posterior estimate
as shown Figure 5(b); in fact, it always returns an estimate
of exactly 0 as it never discovers this SLP. It is worth noting
that the local mixing of RMH between SLPs here is even

(a) SLP visit order

(b) ˆp(K = 5 | y1:Ny )

Figure 5. Comparison of DCC to RMH on GMM with misspeciﬁed
prior. [Left] visit order of SLPs (i.e. sampled K at each iteration)
for single run. [Right] ﬁnal posterior estimates for 5 different runs.

worse than in the previous example. This is because the
larger K at which the sampler is initialized induces a higher
dimensional space on program draws, i.e. µ1:K. This is
catastrophic for RMH because it is effectively importance
sampling when transitioning between SLPs and thus suffers
acutely from the curse of dimensionality. DCC, meanwhile,
gracefully deals with this because of its ability to remember
SLPs that are proposed but not accepted and then subse-
quently perform effective localized inference that exploits
hill–climbing effects in the space of the draws of that SLP.

7.3. Function Induction

Function induction is an important task for automated ma-
chine learning (Duvenaud et al., 2013; Kusner et al., 2017).
In PPSs, it is typically tackled using a probabilistic context
free grammar (PCFG) (Manning et al., 1999). Here we
consider such a model where we specify the structure of a
candidate function using a PCFG and a distribution over the
function parameters, and estimate the posterior of both for
given data. Our PCFG consists of four production rules with
ﬁxed probabilities: e → {x | x2 | sin(a∗e) | a∗e+b∗e},
where x and x2 are terminal symbols, a and b are unknown
coefﬁcient parameters, and e is a non-terminal symbol. The
model also has prior distributions over each coefﬁcient pa-
rameters. See Appendix G.2 for details.

To generate a function from this model, we must sample
both a PCFG rollout and the corresponding parameters. Let
Θ be the collection of all the latent variables used in this
generative process. That is, Θ consists of the sequence of
the discrete variables recording the choices of the grammar
rules and all coefﬁcients in the sampled structure. Condi-
tioned on the training data D, we want to infer the posterior
distribution p(Θ|D), and calculate the posterior predictive
distribution p(D(cid:48)|D) for test data D(cid:48) = {xn, yn}N

n=1.

In our experiment, we control the number of sub-models by
requiring that the model use the PCFG in a restricted way:
a sampled function structure should have depth at most 3

090180270360KRMHK=5Iterations090180270360KDCCDCCRMH0.00.20.40.60.81.0p(K=5|Y)Ground TruthDivide, Conquer, and Combine

(a) DCC (ours)

(b) IS

(c) RMH

Figure 6. Posterior distribution p(Θ|D) estimated by DCC, IS, and RMH under the same computation. Blue points represent the observed
data D and orange ones the test data D(cid:48). Grey lines are the posterior samples of the functions from the run with the highest LPPD among
15 independent runs of the three algorithms.

Table 1. Mean and one standard derivation of the LPPD over 15 independent runs.
DCC (ours)

IS
-73.180 ± 1.08

RMH
-32.693 ± 8.51

PG
-200.824 ± 126.63

IPMCMC
-70.580 ± 4.71

LPPD -28.560 ± 0.41

and cannot use the plus rule consecutively. We generate a
synthetic dataset of 30 training data points from the function
f (x) = −x + 2 sin(5x2) and compare the performance of
DCC to our baselines on estimating the posterior distribution
and the posterior predictive under the same computational
budget of 106 samples and 15 independent runs. BBVI is
omitted from this experiment due to it failing to run at all.

Figure 6 shows the posterior samples generated by DCC, IS,
and RMH for one run, with the training data D marked blue
and the test data D(cid:48) in orange. The DCC samples capture the
periodicity of the data and provides accurate extrapolation,
while retaining an appropriate degree of uncertainty. This
indicates good inference results on both the structure of a
function and the coefﬁcients. Though RMH does ﬁnd some
good functions, it becomes stuck in a particular mode and
does not fully capture the uncertainty in the model, leading
to poor predictive performance.

n=1 log (cid:82)

Table 1 shows the test log posterior predictive density
(LPPD), (cid:80)N
Θ p(yn|xn, Θ)p(Θ|D)dΘ, of all ap-
proaches. DCC substantially outperforms all the baselines
both in terms of predictive accuracy and stability. IS, PG,
and IPMCMC all produced very poor posterior approxima-
tions leading to very low LPPDs. RMH had an LPPD that
is closer to DCC, but which is still substantially inferior.

A further issue with RMH was its high variance of the
LPPD. This is caused by this model being multi-modal and
RMH struggling to move: it gets stuck in a single SLP and
fails to capture the uncertainty. Explicitly, 4 sub-models
(out of 26) contain most of the probability mass. Two of
them are functions of the form used to generate the data,
f (x) = a1x + a2 sin(a3x2), modulo symmetry of the +
operator. The other two have the form f (x) = a1 sin(a2x)+
a3 sin(a4x2), which can also match the training data well
in the region (−1.5, 1.5) as a1 sin(a2x) ≈ a1a2x for small
values of a2x. Note that the local distributions are also multi-

Figure 7. Convergence of
DCC’s log Zk estimate
for each SLP and corre-
sponding total amount of
resources spent.

modal due to various symmetries, for example a1 sin(a2x2)
and −a1 sin(−a2x2), meaning the local inference task is
non-trivial even in low dimensions.

To test the effectiveness of the resource allocation strat-
egy, we further investigate the computational resources
spent for each SLP by looking at the convergence of the
local marginal likelihood estimates ˆZk. In Figure 7, the
sub-models 15 and 18 correspond to the form f (x) =
a1x + a2 sin(a3x2) and its mirror, which contain the most
posterior mass. The sub-models 23 and 24 correspond to
f (x) = a1 sin(a2x) + a3 sin(a4x2) and are the second
largest modes. Figure 7 implies that DCC indeed spends
more computational resource on sub-models with high prob-
ability mass (as signiﬁed by the higher ﬁnal total cost), while
also exploring the other sub-models occasionally.

8. Conclusions

In this paper, we have proposed Divide, Conquer, and Com-
bine (DCC), a new inference strategy for probabilistic pro-
grams with stochastic support. We have shown that, by
breaking down the overall inference problem into a number
of separate inferences of sub-programs with ﬁxed support,
the DCC framework can provide substantial performance
improvements over existing approaches which directly tar-
get the full program. To realize this potential, we have
shown how to implement a particular instance of DCC as an
automated engine in the PPS Anglican and shown that this
outperforms existing baselines on three example problems.

0250004500070000Total Cost1401201008060logZkk=15k=18k=23k=24Divide, Conquer, and Combine

Acknowledgements

YZ is sponsored by China Scholarship Council (CSC). HY
was supported by the Engineering Research Center Pro-
gram through the National Research Foundation of Korea
(NRF) funded by the Korean Government MSIT (NRF-
2018R1A5A1059921), and also by Next-Generation Infor-
mation Computing Development Program through the Na-
tional Research Foundation of Korea (NRF) funded by the
Ministry of Science, ICT (2017M3C4A7068177). YWTs
and TRs research leading to these results has received fund-
ing from the European Research Council under the Euro-
pean Unions Seventh Framework Programme (FP7/2007-
2013)/ ERC grant agreement no. 617071. TR was also sup-
ported in part by Junior Research Fellowship from Christ
Church, University of Oxford and and in part by EPSRC
funding under grant EP/P026753/1.

References

Andrieu, C., Doucet, A., and Holenstein, R. Particle Markov
chain Monte Carlo methods. Journal of the Royal Statis-
tical Society: Series B (Statistical Methodology), 72(3):
269–342, 2010.

Baydin, A. G., Shao, L., Bhimji, W., Heinrich, L., Naderi-
parizi, S., Munk, A., Liu, J., Gram-Hansen, B., Louppe,
G., Meadows, L., et al. Efﬁcient probabilistic inference
in the quest for physics beyond the standard model. In
Advances in Neural Information Processing Systems, pp.
5460–5473, 2019.

Bingham, E., Chen, J. P., Jankowiak, M., Obermeyer, F.,
Pradhan, N., Karaletsos, T., Singh, R., Szerlip, P., Hors-
fall, P., and Goodman, N. D. Pyro: Deep Universal Prob-
abilistic Programming. Journal of Machine Learning
Research, 2018.

Brooks, S., Gelman, A., Jones, G., and Meng, X.-L. Hand-
book of markov chain monte carlo. CRC press, 2011.

Carpenter, B., Gelman, A., Hoffman, M. D., Lee, D.,
Goodrich, B., Betancourt, M., Brubaker, M., Guo, J.,
Li, P., and Riddell, A. Stan: A probabilistic programming
language. Journal of statistical software, 76(1), 2017.

Carpentier, A., Munos, R., and Antos, A. Adaptive strategy
for stratiﬁed monte carlo sampling. Journal of Machine
Learning Research, 16:2231–2271, 2015.

Chaganty, A., Nori, A., and Rajamani, S. Efﬁciently sam-
pling probabilistic programs via program analysis. In
Artiﬁcial Intelligence and Statistics, pp. 153–160, 2013.

Cusumano-Towner, M. F., Saad, F. A., Lew, A. K., and
Mansinghka, V. K. Gen: a general-purpose probabilistic
programming system with programmable inference. In

Proceedings of the 40th ACM SIGPLAN Conference on
Programming Language Design and Implementation, pp.
221–236, 2019.

Doucet, A., De Freitas, N., and Gordon, N. An introduction
to sequential monte carlo methods. In Sequential Monte
Carlo methods in practice, pp. 3–14. Springer, 2001.

Duvenaud, D., Lloyd, J. R., Grosse, R., Tenenbaum, J. B.,
and Ghahramani, Z. Structure discovery in nonparametric
regression through compositional kernel search. arXiv
preprint arXiv:1302.4922, 2013.

Fox, E. B., Sudderth, E. B., Jordan, M. I., and Willsky,
A. S. An hdp-hmm for systems with state persistence.
In Proceedings of the 25th international conference on
Machine learning, pp. 312–319, 2008.

Ge, H., Xu, K., and Ghahramani, Z. Turing: A language
for ﬂexible probabilistic inference. In International Con-
ference on Artiﬁcial Intelligence and Statistics, pp. 1682–
1690, 2018.

Goodman, N. D. and Stuhlm¨uller, A. The Design and Im-
plementation of Probabilistic Programming Languages.
http://dippl.org, 2014. Accessed: 2020-2-6.

Goodman, N. D. and Stuhlm¨uller, A. The design and im-
plementation of probabilistic programming languages,
2014.

Goodman, N. D., Mansinghka, V. K., Roy, D. M., Bonawitz,
K., and Tenenbaum, J. B. Church: A Language for Gen-
erative Models. In In UAI, pp. 220–229, 2008.

Green, P. J. Reversible jump markov chain monte carlo com-
putation and bayesian model determination. Biometrika,
82(4):711–732, 1995.

Green, P. J. Trans-dimensional markov chain monte carlo.
Oxford Statistical Science Series, pp. 179–198, 2003.

Hoffman, M. D., Blei, D. M., Wang, C., and Paisley, J.
Stochastic variational inference. The Journal of Machine
Learning Research, 14(1):1303–1347, 2013.

Janz, D., Paige, B., Rainforth, T., van de Meent, J.-W., and
Wood, F. Probabilistic structure discovery in time series
data. arXiv preprint arXiv:1611.06863, 2016.

Kucukelbir, A., Tran, D., Ranganath, R., Gelman, A., and
Blei, D. M. Automatic differentiation variational infer-
ence. The Journal of Machine Learning Research, 18(1):
430–474, 2017.

Kusner, M. J., Paige, B., and Hern´andez-Lobato, J. M.
In Proceedings of
Grammar variational autoencoder.
the 34th International Conference on Machine Learning-
Volume 70, pp. 1945–1954. JMLR. org, 2017.

Divide, Conquer, and Combine

Le, T. A. Inference for higher order probabilistic programs.

Masters thesis, University of Oxford, 2015.

Le, T. A., Baydin, A. G., and Wood, F. Inference compi-
lation and universal probabilistic programming. arXiv
preprint arXiv:1610.09900, 2016.

Lu, X., Rainforth, T., Zhou, Y., van de Meent, J.-W.,
and Teh, Y. W. On exploration, exploitation and learn-
ing in adaptive importance sampling. arXiv preprint
arXiv:1810.13296, 2018.

Manning, C. D., Manning, C. D., and Sch¨utze, H. Foun-
dations of statistical natural language processing. MIT
press, 1999.

Mansinghka, V., Selsam, D., and Perov, Y. Venture: a higher-
order probabilistic programming platform with pro-
grammable inference. arXiv preprint arXiv:1404.0099,
2014.

Martino, L., Elvira, V., Luengo, D., and Corander, J. Lay-
ered adaptive importance sampling. Statistics and Com-
puting, 27(3):599–623, 2017.

Metropolis, N. and Ulam, S. The Monte Carlo method.
Journal of the American statistical association, 44(247):
335–341, 1949.

Narayanan, P., Carette, J., Romano, W., Shan, C.-c., and
Zinkov, R. Probabilistic inference by program transfor-
mation in hakaru (system description). In International
Symposium on Functional and Logic Programming, pp.
62–79. Springer, 2016.

Nobile, A. and Fearnside, A. T. Bayesian ﬁnite mixtures
with an unknown number of components: The allocation
sampler. Statistics and Computing, 17(2):147–162, 2007.

Nori, A., Hur, C.-K., Rajamani, S., and Samuel, S. R2: An
efﬁcient mcmc sampler for probabilistic programs. In
Twenty-Eighth AAAI Conference on Artiﬁcial Intelligence,
2014.

Paige, T. B. Automatic inference for higher-order prob-
abilistic programs. PhD thesis, University of Oxford,
2016.

Perov, Y. N. and Wood, F. D. Learning probabilistic pro-

grams. arXiv preprint arXiv:1407.2646, 2014.

Rainforth, T., Zhou, Y., Lu, X., Teh, Y. W., Wood, F.,
Inference trees:
Yang, H., and van de Meent, J.-W.
Adaptive inference with exploration. arXiv preprint
arXiv:1806.09550, 2018.

Ranganath, R., Gerrish, S., and Blei, D. Black box varia-
tional inference. In Artiﬁcial Intelligence and Statistics,
pp. 814–822, 2014.

Richardson, S. and Green, P. J. On bayesian analysis of
mixtures with an unknown number of components (with
discussion). Journal of the Royal Statistical Society: se-
ries B (statistical methodology), 59(4):731–792, 1997.

Ritchie, D., Horsfall, P., and Goodman, N. D. Deep amor-
tized inference for probabilistic programs. arXiv preprint
arXiv:1610.05735, 2016a.

lightweight

Ritchie, D., Stuhlm¨uller, A., and Goodman, N. D.
incrementalized MCMC for prob-
C3:
abilistic programs using continuations and callsite
caching. In Proceedings of the 19th International Con-
ference on Artiﬁcial Intelligence and Statistics, AIS-
TATS 2016, Cadiz, Spain, May 9-11, 2016, pp. 28–37,
2016b. URL http://proceedings.mlr.press/
v51/ritchie16.html.

Roberts, D., Gallagher, M., and Taimre, T. Reversible jump
probabilistic programming. In The 22nd International
Conference on Artiﬁcial Intelligence and Statistics, pp.
634–643, 2019.

Roy, D. M., Teh, Y. W., et al. The mondrian process. In

NeurIPS, pp. 1377–1384, 2008.

Schaechtle, U., Saad, F., Radul, A., and Mansinghka, V.
Time series structure discovery via probabilistic program
synthesis. arXiv preprint arXiv:1611.07051, 2016.

´Scibior, A., Kammar, O., and Ghahramani, Z. Functional
programming for modular bayesian inference. Proceed-
ings of the ACM on Programming Languages, 2(ICFP):
1–29, 2018.

Teh, Y. W. Dirichlet process., 2010.

Tesauro, G., Rajan, V., and Segal, R. Bayesian inference in
Monte-Carlo tree search. arXiv preprint arXiv:1203.3519,
2012.

Rainforth, T. Automating Inference, Learning, and Design
using Probabilistic Programming. PhD thesis, University
of Oxford, 2017.

Tolpin, D. and Wood, F. Maximum a Posteriori Estimation
by Search in Probabilistic Programs. In Eighth Annual
Symposium on Combinatorial Search, 2015.

Rainforth, T., Naesseth, C., Lindsten, F., Paige, B., Van-
demeent, J.-W., Doucet, A., and Wood, F. Interacting
particle markov chain monte carlo. In International Con-
ference on Machine Learning, pp. 2616–2625, 2016.

Tolpin, D., van de Meent, J., Paige, B., and Wood, F. D.
Output-sensitive adaptive metropolis-hastings for proba-
bilistic programs. In Machine Learning and Knowledge
Discovery in Databases - European Conference, ECML

Divide, Conquer, and Combine

PKDD 2015, Porto, Portugal, September 7-11, 2015, Pro-
ceedings, Part II, pp. 311–326, 2015. doi: 10.1007/
978-3-319-23525-7\ 19. URL https://doi.org/
10.1007/978-3-319-23525-7_19.

Tolpin, D., van de Meent, J.-W., Yang, H., and Wood, F.
Design and implementation of probabilistic programming
language anglican. In Proceedings of the 28th Symposium
on the Implementation and Application of Functional
programming Languages, pp. 1–12, 2016.

Wingate, D. and Weber, T. Automated variational in-
ference in probabilistic programming. arXiv preprint
arXiv:1301.1299, 2013.

Wingate, D., Stuhlm¨uller, A., and Goodman, N. Lightweight
implementations of probabilistic programming languages
via transformational compilation. In Proceedings of the
Fourteenth International Conference on Artiﬁcial Intelli-
gence and Statistics, pp. 770–778, 2011.

Wood, F., van de Meent, J. W., and Mansinghka, V. A
New Approach to Probabilistic Programming Inference.
In Artiﬁcial Intelligence and Statistics, pp. 1024–1032,
2014.

Yang, L., Hanrahan, P., and Goodman, N. Generating efﬁ-
cient mcmc kernels from probabilistic programs. In Arti-
ﬁcial Intelligence and Statistics, pp. 1068–1076, 2014.

Appendix for Divide, Conquer, and Combine: a New Inference Strategy
for Probabilistic Programs with Stochastic Support

A. Existing PPSs and Inference Engines for Probabilistic Programs with Stochastic Support

Table 2. List of popular universal PPSs and their supported inference algorithms for models with stochastic support.3

Rejection

IS

SMC PMCMC VI

Customized
proposal MCMC

Automated
proposal MCMC

Venture
(Mansinghka et al., 2014)
WebPPL
(Goodman & Stuhlm¨uller, 2014)
MonadBayes
( ´Scibior et al., 2018)
Anglican
(Wood et al., 2014)
Turing.jI
(Ge et al., 2018)
Pyro
(Bingham et al., 2018)
Gen
(Cusumano-Towner et al., 2019)
Hakaru
(Narayanan et al., 2016)
Stochaskell
(Roberts et al., 2019)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

In Table 2 above, we have listed which inference engines from the ﬁve categories in §3 are supported by each of the
most popular universal PPSs. The fundamental difﬁculty in performing inference on probabilistic models with stochastic
support is that the posterior mass of such models is usually concentrated in one or many separated sub-regions which are
non-trivial to be fully discovered, especially in a high dimensional space. Moreover, even if a variable exists in different
variable conﬁgurations, the posterior might shift substantially like the mean µ1 for the GMM shown in the Figure 1, which
complicates the design for a “proper” proposal distribution, let alone automate this procedure in PPS. We now have a
more detailed look at each category with the related PPSs and uncover the reasons why these engines are not suitable for
probabilistic programs with stochastic support.

Importance/rejection sampling Basic inference schemes, such as importance sampling (IS) and rejection sampling (RS),
are commonly supported by many PPSs due to their generality and simplicity. See Table 2. They can be directly applied
to a model with stochastic support, but their performance deteriorates rapidly (typically exponentially) as the dimension
of the model increases; they suffer acutely from the curse of dimensionality. Furthermore, their validity relies on access
to a valid proposal. This can often be easily ensured, e.g. by sampling from the prior, but doing this while also ensuring
the proposal is efﬁcient can be very challenging; the prior is only a practically viable proposal for very simple problems.
Though schemes for developing more powerful proposals in amortized inference settings have been developed (Le et al.,
2016; Ritchie et al., 2016a), these are not appropriate for conventional inference problems.

3All information are taken from the published paper or the online manual.

Appendix: Divide, Conquer, and Combine

Particle based methods Particle based inference methods, such as Sequential Monte Carlo (SMC) (Doucet et al., 2001),
can offer improvements for models with natural sequential structure (Wood et al., 2014; Rainforth et al., 2016). More
explicitly, SMC improves IS when there exist interleaved observe statements in the model program. However, it similarly
rapidly succumbs to the curse of dimensionality in the more general case where this does not occur. Such methods also
cannot be used at all if the number of observe statements is not ﬁxed, which can be common for stochastic support problems.

One might then tend to more sophisticated methods such as particle MCMC (PMCMC) methods (Andrieu et al., 2010) but
unfortunately these suffer from the same underlying issues. The basic setups of PMCMC include the Particle Independent
Metropolis Hasting (PIMH) (in Anglican and Turing.jI) and Particle Gibbs (PG) (in Anglican and Turing.jI (Ge et al., 2018)),
where one uses, respectively, independent and conditional SMC sweeps as the proposal within the MCMC sampler. These
building-block sweeps suffer from exactly the same issue as conventional SMC, and thus offer no advantage over simple
importance sampling without interleaved observe statements.

These advanced variants do though allow one to treat global parameters separately: they update the global parameters using
a Metropolis–within–Gibbs (MwG) step and then update the rest latent variables using a (conditional) SMC sweep with
those global parameter values. When combined with PIMH, this leads to Particle Marginal Metropolis Hasting (PMMH)
algorithm (available in WebPPL (Goodman & Stuhlm¨uller, 2014), Turing.jI and MonadBayes ( ´Scibior et al., 2018)). It
already constitutes a valid step for PG. Unfortunately, in both cases this MwG suffers from exactly the same issues as
those already discussed for LMH. As such, these approaches again offer little advantage over importance sampling without
sequential problem structure.

Variational inference Following the discussion in § 3, three universal PPSs under our survey that allow Variational
Inference (VI) in stochastic support settings are Pyro (Bingham et al., 2018), Gen (Cusumano-Towner et al., 2019) and
Anglican (Wood et al., 2014) (note many others allow VI for statistic support, but cannot be used when the support varies).
Pyro supports Stochastic Variational Inference (SVI) (Hoffman et al., 2013; Wingate & Weber, 2013; Kucukelbir et al.,
2017) and allows an auto-generated guide function (AutoGuide), i.e. the variational proposal, or a user-speciﬁed guide.
However, AutoGuide only works for some basic probabilistic programs, which we cannot directly apply for the GMM
example in § 3. With the customized guide, one cannot deal with the exact same model because of the need to upper-bound
the number of the variational parameters according to the tutorial4.

Both Gen and Anglican support the Black box Variational Inference (BBVI) (Ranganath et al., 2014). We have tested
the Anglican’s BBVI with the GMM example in § 3, but it does not provide very accurate estimates as can be seen in the
Figure 3.

One key challenge for implementing VI dealing with models with stochastic support is that one might still have never-before-
seen variables after ﬁnite number of training steps. Moreover, it is usually very challenging in stochastic support settings to
ensure that the variational family is deﬁned in a manner that ensures the KL is well deﬁned. For example, if using KL(q||p)
(for proposal q and target p), then the KL will be inﬁnite if q places support anywhere p does not. Controlling this with
static support is usually not especially problematic, but in stochastic support settings it can become far more challenging.

Overcoming these complications is beyond the scope of our paper but could be a potential interesting direction for future
work.

MCMC with customized proposal To perform Markov chain Monte Carlo (MCMC) methods (Metropolis & Ulam,
1949) on the models with stochastic support, one needs to construct the transitional kernel such that the sampler can switch
between conﬁgurations. A number of PPSs such as Hakaru, Turing.jI, Pyro and Gen allow the user to customize the kernel
for Metropolis Hastings (a.k.a programmable kernel) whereas Stohaskell explicitly supports reversible jump Markov chain
Monte Carlo (RJMCMC) (Green, 1995; 2003) methods. However, their application is fundamentally challenging as we have
discussed in § 3 due to the difﬁculty in designing proposals which can transition efﬁciently as well as the posterior shift on
the variable under different conﬁguration.

MCMC with automated proposal One MCMC method that can be fully automated for PPSs is the Single-site Metropolis
Hastings or the Lightweight Metropolis Hastings algorithm (LMH) of (Wingate et al., 2011) and its extensions (Yang et al.,
2014; Tolpin et al., 2015; Le, 2015; Ritchie et al., 2016b), for which implementations are provided in a number of systems
such as Venture (Mansinghka et al., 2014), WebPPL and Anglican. In particular, Anglican supports LMH and its variants,

4https://pyro.ai/examples/dirichlet_process_mixture.html

Appendix: Divide, Conquer, and Combine

Random-walk lightweight Metropolis Hastings (RMH) (Le, 2015), which uses a mixture of prior and local proposal to
update the selected entry variable xi along the trace x1:nx .

Many shortcomings of LMH and RMH have been discussed in §3 and we reiterate a few points here. Though widely
applicable, LMH relies on proposing from the prior whenever the conﬁguration changes for the downstream variables. This
inevitably forms a highly inefﬁcient proposal (akin to importance sampling from the prior), such that although samples
from different conﬁgurations might be proposed frequently, these samples might not be “good” enough to be accepted. This
usually causes LMH get stuck in one sub-mode and struggles to switch to other conﬁgurations. For example, we have
observed this behavior in the GMM example in Figure 4. As a result, LMH typically performs very poorly for programs
with stochastic support, particularly in high dimensions.

Note that LMH/RMH could have good mixing rates for many models with ﬁxed support in general akin to standard
Metropolis-within-Gibbs methods. This is because when xi is updated, the rest of the random variables can still be re-used,
which ensures a high acceptance rate. That is also why we can still use LMH/RMH as the local inference algorithm within
the DCC framework for a ﬁxed SLP to establish substantial empirical improvements.

B. Detailed Algorithm Block for DCC in Anglican

Algorithm 2 An Implementation of DCC in Anglican
Input: Program prog , number of iterations T , inference hyper-parameters Φ (e.g. number of initial iterations T0, times

proposed threshold C0),

Output: Posterior approximation ˆπ and marginal likelihood estimate ˆZ
1: Execute prog forward multiple times (i.e. ignore observes) to obtain an initial set of discovered SLPs Atotal
2: for t = 1, . . . , T do
3:
4:
5:
6:

Select the model(s) k(cid:48) in Atotal whose proposed times Ck(cid:48) ≥ C0 and add them into Aactive
if exist any new models then

Initialize the inference with N parallel MCMC chains
Perform Tinit optimization step for each chain by running a “greedy” RMH locally and only accepting samples
with higher ˆγk to boost burning-in; store only the last MCMC samples as the initialization for each chain
Draw M importance samples using each previous MCMC samples as proposal to generate initial estimate for ˆZk

end if
Step 1: select a model Ak∗
Choose a sub-model with index k∗ with the maximum utility value as per Equation 14
Step 2: perform local inference on Ak∗
Perform one or more RMH step locally for all N chains of model K ∗ to update ˆπk∗
Draw M importance samples using each previous MCMC samples as proposal to update ˆZk∗
Step 3: explore new models (optional)
Perform one RMH step using a global proposal for all N chains to discover more SLPs Ak(cid:48)(cid:48)
Add Ak(cid:48)(cid:48) to Atotal if Ak(cid:48)(cid:48) /∈ Atotal; increment the Ck(cid:48)(cid:48)

12:
13:
14: end for
15: Combine local approximations into overall posterior estimate ˆπ and overall marginal likelihood estimate ˆZ as per (5)

7:
8:

9:

10:
11:

C. Details for Proof of Theoretical Correctness

In this section, we provide a more formal demonstration of the consistency of the DCC algorithm. We start by explaining
the required assumptions, before going on to the main theoretical result.

More formally, our ﬁrst assumption, which may initially seem highly restrictive but turns out to be innocuous, is that we
only split our program into a ﬁnite number of sub-programs:

Assumption 1. The total number of sub-programs K is ﬁnite.

We note that this assumption is not itself used as part of the consistency proof, but is a precursor to Assumptions 4 and 5
being satisﬁable. We can always ensure the assumption is satisﬁed even if the number of SLPs is inﬁnite; we just need to be
careful about exactly how we specify a sub-program. Namely, we can introduce a single sub-program that combines all

Appendix: Divide, Conquer, and Combine

the SLPs whose path is longer than nthresh, i.e. those which invoke nx > nthresh sample statements, and then ensure that the
local inference run for this speciﬁc sub-program is suitable for problems with stochastic support (e.g. we could ensure we
always use importance sampling from the prior for this particular sub-program). If nthresh is then set to an extremely large
value such that we can safely assume that the combined marginal probability of all these SLPs is negligible, this can now be
done without making any notable adjustments to the practical behavior of the algorithm. In fact, we do not even envisage
this being necessary for actual implementations of DCC: it is simply a practically inconsequential but theoretically useful
adjustment of the DCC algorithm to simplify its proof of correctness. Moreover, the fact that we will only ever have ﬁnite
memory to store the SLPs means that practical implementations will generally have this property implicitly anyway.

For better notational consistency with the rest of the paper, we will use the slightly inexact convention of referring to each
of these sub-programs as an SLP from now on, such that the K th “SLP” may actually correspond to a collection of SLPs
whose path length is above the threshold if the true number of SLPs is inﬁnite.

Our second and third assumptions simply state that our local estimators are consistent given sufﬁcient computational budget:

Assumption 2. For every SLP k ∈ {1, . . . , K}, we have a local density estimate ˆπk (taking the form on an empirical
measure) which converges weakly to the corresponding conditional distribution of that SLP πk in limit of large allocated
budget Sk, where πk(x) ∝ γ(x)I[x ∈ Xk], γ(x) is the unnormalized distribution of the program, and Xk is the support
corresponding to the SLP k.
Assumption 3. For every SLP, we have a local marginal probability estimate ˆZk which converges in probability to the
corresponding to true marginal probability Zk = (cid:82) γ(x)I[x ∈ Xk]dx in limit of large allocated budget Sk. We further
assume that if Zk = 0, then ˆZk also equals 0 with probability 1 (i.e. we never predict non-zero marginal probability for
SLPs that contain no mass).

The ﬁnal part of this latter assumption, though slightly unusual, will be satisﬁed by all conventional estimators: it effectively
states that we do not assign ﬁnite mass in our estimate to any SLP for which we are unable to ﬁnd any valid traces with
non-zero probability.

Our next assumption is that the SLP extraction strategy will uncover all K SLPs in ﬁnite time.

Assumption 4. Let Tfound denote the number of iterations the DCC approach takes to uncover all SLPs with Zk > 0. We
assume that Tfound is almost surely ﬁnite, i.e. P (Tfound < ∞) = 1.

A sufﬁcient, but not necessary, condition for this assumption to hold is to use a method for proposing SLPs that has a
non-zero probability of proposing a new trace from the prior. This condition is satisﬁed by LMH style proposals like the
RMH proposal we adopt in practice. We note that as with Assumption 1, this assumption is not itself used as part of the
consistency proof, but is a precursor to Assumption 5 (below) being satisﬁable.

Our ﬁnal assumption is that our resource allocation strategy asymptotically allocates a ﬁnite proportion of each of its
resources to each SLP with non-zero marginal probability:

Assumption 5. Let T denote the number of DCC iterations and Sk(T ) the number of times that we have chosen to allocate
resources to an SLP k after T iterations. We assume that there exists some (cid:15) > 0 such that

∀k ∈ {1, . . . , K}. Zk > 0 =⇒

Sk(T )
T

> (cid:15).

(6)

Given these assumptions, we are now ready to demonstrate the consistency of the DCC algorithm as follows:

Theorem 1. If Assumptions 1-5 in Appendix C hold, then the empirical measure, ˆπ (·), produced by DCC converges weakly
to the conditional distribution of the program in the limit of large number of iterations T :

ˆπ (·) d→ π (·)

as T → ∞.

Proof. By Assumption 5, we have that for all k with Zk > 0, Sk → ∞ as T → ∞. Using this along with Assumptions 2
and 3 gives us that, in the limit T → ∞,

ˆZk

p
→ Zk ∀k ∈ {1, . . . , K}

ˆπk(·) d→ πk(·) ∀k ∈ {1, . . . , K} with Zk > 0

(7)

(8)

so that all our local estimates converge.

Appendix: Divide, Conquer, and Combine

The result now follows through a combination of Equation 5, linearity, and Slutsky’s theorem. Namely, let us consider an
arbitrary bounded continuous function f : X → R, for which we have
(cid:82) f (x) (cid:80)K
ˆZk ˆπk(dx)
(cid:80)K
ˆZk
(cid:82) f (x) ˆZk ˆπk(dx)
(cid:80)K
ˆZk

f (x)ˆπ(dx) =

(cid:80)K

k=1

k=1

k=1

=

(cid:90)

.

k=1

Given Equations (7) and (8), using Slutsky’s theorem, we can conclude that as T → ∞, the above integral converges to

(cid:80)K

k=1

(cid:82) f (x)Zkπk(dx)
(cid:80)K

k=1 Zk

(cid:82) f (x) (cid:80)K
k=1 Zkπk(dx)
Z
(cid:82) f (x)γ(dx)
Z

=

=

= Eπ(x)[f (x)].

We thus see that the estimate for the expectation of f (x), which is calculated using our empirical measure ˆπ (·), converges to
its true expectation under π(·). As this holds for an arbitrary integrable f (x), this ensures, by deﬁnition, that ˆπ (·) converges
in distribution to π(·), thereby giving the desired result.

We ﬁnish by noting that our choices for the particular DCC implementation in Anglican straightforwardly ensure that these
assumptions are satisﬁed (provided we take the aforementioned care around Assumption 1). Namely:

• Using RMH for the local inferences will provide ˆπk that satisﬁes Assumption 2.

• Using PI-MAIS will provide ˆZk that satisﬁes Assumption 3 provided we construct this with a valid proposal.

• The method for SLP extraction has a non-zero probability of discovering any of the SLPs with Zk > 0 at each iteration
because it has a non-zero probability of proposing a new trace from prior, which then itself has a non-zero probability
of proposing each possible SLP.

• The resource allocation strategy will eventually choose each of its possible actions with non-zero rewards (which in our

case are all SLPs with Zk > 0) inﬁnitely often, as was proven in (Rainforth et al., 2018).

D. Additional Details on Local Estimators

Recall that the goal for the local inference is to estimate the local target density πk(x) (where we only have access to γk(x)),
and the local marginal likelihood Zk for a given SLP Ak. Each SLP has a ﬁxed support, i.e. a ﬁxed conﬁguration of the
random variables, now where many of the complicated factors from varying support no longer apply.

To estimate the local target density πk(x) for a given SLP Ak, DCC establishes a multiple-chain MCMC sampler in order to
ensure a good performance in the setting with high dimensional and potentially multi-modal local densities. Explicitly, we
perform one RMH step in each chain for N independent chains in total at each iteration. Suppose the total iteration to run
local inference in Ak is Tk. With all the MCMC samples (ˆx(k)
N
(cid:88)

) within Ak, we then have the estimator

1:N,1:Tk
Tk(cid:88)

(9)

ˆπk(x) :=

1
N Tk

δˆx(k)

n,t

(·).

n=1

t=1

As MCMC samplers do not directly provide an estimate for Zk, we must introduce a further estimator that uses these
samples to estimate it. For this, we use PI-MAIS (Martino et al., 2017). Though ostensibly an adaptive importance sampling
algorithm, PI-MAIS (Martino et al., 2017) is based around using the set of N proposals each centered on the outputs of an
MCMC chain. It can be used to generates marginal likelihood estimates from a set of MCMC chains, as we require.

More precisely, given the series of previous generated MCMC samples, ˆx(k)
, PI-MAIS introduces a mixture proposal
distribution for each iteration of the chains by using the combination of separate proposals (e.g. a Gaussian) centered on

1:N,1:Tk

each of those chains:

Appendix: Divide, Conquer, and Combine

q(k)
t

(·|ˆx(k)

1:N,t) :=

1
N

N
(cid:88)

n=1

n,t (·|ˆx(k)
q(k)
n,t)

for t ∈ {1, 2, . . . , Tk}.

(10)

This can then be used to produce an importance sampling estimate for the target, with Rao-Blackwellization typically applied
across the mixture components, such that M samples, (˜x(k)
n,t,m)M

m=1, are drawn separately from each q(k)

n,t with weights

˜w(k)

n,t,m :=

γk(˜x(k)
(˜x(k)

n,t,m)
n,t,m|ˆx(k)
n,t)

q(k)
t

with ˜x(k)

n,t,m ∼ q(k)

n,t (·|ˆx(k)
n,t),

for m ∈ {1, . . . , M } and n ∈ {1, . . . , N }.

(11)

We then have the marginal likelihood estimate ˆZk as

ˆZk :=

1
N TkM

N
(cid:88)

Tk(cid:88)

M
(cid:88)

n=1

t=1

m=1

˜w(k)

n,t,m.

(12)

An important difference for obtaining ˆZk using an adaptive IS scheme with multiple MCMC chain as the proposal, compared
to vanilla importance sampling (from the prior), is that MCMC chains form a much more efﬁcient proposal than the prior
as they gradually converge to the local target distribution πk(x). These chains are running locally, i.e. restricted to the
SLP Ak, which means that the issues of the LMH transitioning between SLPs as discussed in §3 no longer apply and local
LMH could maintain a much higher mixing rate where it becomes the standard MwG sampler on a ﬁxed set of variables.
Furthermore, the beneﬁt of having multiple chains is that they will approximate a multi-modal local density better. With N
chains, we no longer require one chain to discover all the modes but instead only need each mode being discovered by at
least one chain. As a result, Equation 12 provides a much more accurate estimator than basic methods.

An interesting point of note is that one can also use the importance samples generated by the PI-MAIS for the estimate
ˆπk(x), where ˆπk(x) from Equation 9 will be

ˆπk(x) :=

N
(cid:88)

Tk(cid:88)

M
(cid:88)

n=1

t=1

m=1

¯w(k)

n,t,mδ˜x(k)

n,t,m

(·), where ¯w(k)

n,t,m := ˜w(k)

n,t,m

(cid:30) N
(cid:88)

Tk(cid:88)

M
(cid:88)

n=1

t=1

m=1

˜w(k)

n,t,m.

(13)

The relative merits of these approaches depend on the exact problem. For problems where the PI-MAIS forms an efﬁcient
adaptive importance sampler, the estimate it produces will be preferable. However, in some cases, particularly high-
dimensional problems, this sampler may struggle, so that it is more effective to take the original MCMC samples. Though it
might seem that we are doomed to fail anyway in such situations, as the struggling of the PI-MAIS estimator is likely to
indicate our Zk estimates are poor, this is certainly not always the case. In particular, for many problems, one SLP will
dominate, i.e. Zk∗ (cid:29) Zk(cid:54)=k∗ for some k∗. In that case, we do not necessarily need accurate estimates of the Zk’s to achieve
an overall good approximation of the posterior. We just need to identify the dominant Zk.

E. Additional Details on SLP Extraction

To better understand our SLP extraction procedure, one can imagine that we maintain two stacks of information of SLPs:
one total stack and one active stack (Atotal and Aactive respectively in Algorithm 2). The total stack records all
the information of all discovered SLPs and the active stack keeps the SLPs that are believed to be promising so far.

Let’s now have a detailed look at Algorithm 2 together. To prevent the rate of models being generated from outstripping
our ability to perform inference on current models, we probably only want to perform inference on a subset of all possible
sub-models given ﬁnite computational budget, which is Aactive. However, to determine which SLP might be good, i.e.
have high posterior mass, is somewhat part of the job of the inference. Therefore, in DCC, we propose that if a model
in {Atotal \ Aactive} is “close” enough to the promising models discovered so far as in Aactive, it would be regarded as
being potentially good and added to Aactive. To quantify the closeness, we count how many times a discovered SLP not in
Aactive gets proposed by a model in Aactive during the global exploration step (at line 13, Algorithm 2). We will add a
newly discovered SLP into Aactive for the resource allocation only when its count reaches some threshold C0 (line 3).
One might worry the number of models in Aactive might still go beyond the capacity of the inference engine. We have
considered the following design choices to avoid this situation in the DCC in Anglican. The ﬁrst one is to increase C0
accordingly as the iteration grows. Intuitively, an SLP needs to be proposed more often to demonstrate that it might be
a good one when more computational resources are provided. Another design choice is to control the total number of
sub-models in Aactive. For instance, before one can add a new model in Aactive, one needs to take an SLP out of Aactive,

Appendix: Divide, Conquer, and Combine

e.g. the one with the least ˆγk, if the upper bound of the total “active” number has reached. Our DCC also randomly chooses
one “non-active” SLPs to perform local inference to ensure the overall correctness.

These design choices, though, are not always necessary if the number of possible sub-models does not explode naturally.
For example, in the GMM example, this number is controlled by the value of a Poisson random variable which diminishes
quickly, in which case we do not need to further bound the number of active sub-models. But when it comes to the GMM
with the misspeciﬁed prior where the possible number of active models can easily grow quickly, these design choices
become essential. They prevent too much computation resources from being waste on keeping discovering new sub-models
rather than being used to perform inference in the discovered ones.

From the practical perspective, one might also want to “split” on discrete variables as their values are likely to affect the
downstream program path. This means that for speciﬁc discrete variable(s), not only their addresses but also their values are
included in deﬁning a program path. It equivalently transforms sampling a discrete variable to observing the variable being
a ﬁxed value. The beneﬁt of doing so is when performing inference locally, we no longer need to propose changes for that
discrete variable but instead evaluate its conditional probability. Therefore, we can “avoid” proposing samples out of current
SLP too often to waste the computation. The posterior of that discrete variable can be obtained from the local marginal
likelihood estimates. In our implementation of DCC in Anglican, we require the user to specify which discrete variables that
they want to “split” on. Automatically distinguishing which discrete variable will or will not affect program paths is beyond
the scope of this paper, and we shall leave it for future work.

F. Additional Details on Resource Allocation

Once a new candidate of SLP has been selected to be added into Aactive, DCC ﬁrstly performs Tinit optimization steps to
boost initialization of inference. Informally, we want to burn in the MCMC chains quickly such that the initialization of
each chain would be close to the local mode of the target distribution. By doing so, DCC applies a “greedy” RMH where it
only accepts the MCMC samples with the larger ˆγk, which enforces the hill-climbing behavior in MCMC to discover modes.
Note that only the MCMC samples of the last step in the optimization will be stored as the initialization of each chain and
therefore this optimization strategy will not affect the correctness of the local inference.

As introduced in § 6.3, the resource allocation scheme is based on an Upper Conﬁdence Bound (UCB) scheme (Carpentier
et al., 2015) developed by Rainforth et al. (2018). We recall the utility function for each SLP being
(cid:18) (1 − δ)ˆτk
maxk{ˆτk}

δ ˆpk
maxk{ˆpk}

β log (cid:80)
√
Sk

Uk :=

1
Sk

k Sk

(14)

+

+

(cid:19)

where Sk is the number of times that Ak has been chosen to perform local inference so far, ˆτk is the “exploitation target” of
Ak, ˆpk is a target exploration term, and δ and β are hyper-parameters.

k + (1 + κ)σ2

As proved by Rainforth et al. (2018, §5.1), the optimal asymptotic allocation strategy is to choose each Ak in proportion
to ˆτk = (cid:112)Z 2
k is the
variance of the weights of the individual samples used to generate Zk. Intuitively, this allocates resources not only to the
SLPs with high marginal probability mass, but also to the ones having high variance on our estimate of it. We normalize
each ˆτk by the maximum of ˆτ1:K as the reward function in UCB is usually in [0, 1].

k where κ is a smoothness hyper-parameter, Zk is the local marginal likelihood, and σ2

The target exploration term ˆpk is a subjective tail-probability estimate on how much the local inference could improve
in estimating the local marginal likelihood if given more computations. This is motivated by the fact that estimating Zk
accurately is difﬁcult, especially at the early stage of inference. One might miss substantial modes if only relying on
optimism boost to undertake exploration. As per (Rainforth et al., 2018), we realize this insight by extracting additional
information from the log weights. Namely, we deﬁne ˆpk := P ( ˆwk(Ta) > wth ) ≈ 1 − Ψk(log wth )Ta , which means the
probability of obtaining at least one sample with weight w that exceeds some threshold weight wth if provided with Ta
“look-ahead” samples. Here Ψk(·) is a cumulative density estimator of the log local weights (eg. the cumulative density
function for the normal distribution), Ta is a hyperparameter, and wth can be set to the maximum weight so far among all
SLPs. If ˆpk is high, it implies that there is a high chance that one can produce higher estimates of Zk given more budget.

Appendix: Divide, Conquer, and Combine

(defdist lik-dist

; auxiliary bindings

[mus std-scalar]
[]
(sample* [this] nil) ;; not used
(observe* [this y] ;; customize likelihood

(reduce log-sum-exp

(map #(- (observe* (normal %1 std-scalar) y) (log (count mus)))

mus))))

(with-primitive-procedures [lik-dist]

(defquery gmm-open [data]

(let [poi-rate 9

;; sample the number of total clusters
K (+ 1 (sample (poisson poi-rate)))
lo 0.
up 20.
;; sample the mean for each k-th cluster
mus (loop [k 0

mus []]

(if (= k K)

mus ;; return mus
(let [mu-k (sample (uniform-continuous

(+ lo (* (/ k K) (- up lo)))
(+ lo (* (/ (+ k 1) K) (- up lo)))))]

(recur (inc k) (conj mus mu-k)))))

obs-std 0.1]

;; evaluate the log likelihood
(map (fn [y] (observe (lik-dist mus obs-std) y)) data)
;; output
(cons K mus))))

Figure 8. Code example of GMM in Anglican

G. Details on Experiments

G.1. Gaussian Mixture Model

The Gaussian Mixture Model deﬁned in §3 can be written in Anglican as in Figure 8. The kernel density estimation of the
data is shown Figure 3 (black line) with the raw data ﬁle provided in the code folder.

G.2. Function Induction

The Anglican program for the function induction model in in §7.3 is shown in Figure 9. The prior distribution for applying
each rule R = {e → x | x2 | sin(a ∗ e) | a ∗ e + b ∗ e} is PR = [0.3, 0.3, 0.2, 0.2]. To control the exploding of the number
of sub-models, we set the maximum depth of the function structure being three and prohibit consecutive plus. Both our
training data (blue points) and test data (orange points) displayed in Figure 6 are generated from f (x) = −x + 2 sin(5x2)
with observation noise being 0.5 and the raw data ﬁles are provided in the code folder.

Appendix: Divide, Conquer, and Combine

(defm gen-prog [curr-depth max-depth prev-type]

(let [expr-type (if (< curr-depth max-depth)

(if (= prev-type 3)

(sample (discrete [0.35
(sample (discrete [0.3

0.35

0.3

0.3]))
0.2 0.2])))

(sample (discrete [0.5 0.5])))]

(cond

(= expr-type 0)
(if (nil? prev-type)

(let [_ (sample (normal 0 1))]

’x)

’x)

(= expr-type 1)
(let [_ (sample (normal 0 1))]

(list ’* ’x ’x))

(= expr-type 2)
(let [a (sample (normal 0 1))

curr-depth (+ curr-depth 1)
expr-sin (list ’Math/sin

(list ’* a (gen-prog curr-depth max-depth expr-type)))]

expr-sin)

(= expr-type 3)
(let [a (sample (normal 0 1))
b (sample (normal 0 1))
curr-depth (+ curr-depth 1)
expr-plus (list ’+

(list ’* a (gen-prog curr-depth max-depth expr-type))
(list ’* b (gen-prog curr-depth max-depth expr-type)))]

expr-plus))))

(defm gen-prog-fn [max-depth]

(list ’fn [’x] (gen-prog 1 max-depth nil)))

(defquery pcfg-fn-new [ins outs]

(let [obs-std 0.5
max-depth 3
f (gen-prog-fn max-depth)
f-x (mapv (eval f) ins)]

(map #(observe (normal %1 obs-std) %2) f-x outs)
f))

Figure 9. Code example of the Function Induction model in Anglican

