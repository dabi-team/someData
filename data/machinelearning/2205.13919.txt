2
2
0
2

y
a
M
7
2

]

G
L
.
s
c
[

1
v
9
1
9
3
1
.
5
0
2
2
:
v
i
X
r
a

Fast Causal Orientation Learning in Directed Acyclic Graphs

Ramin Safaeian
Department of Electrical Engineering
Sharif University of Technology
Tehran, Iran

Saber Salehkaleybar
Department of Electrical Engineering
Sharif University of Technology
Tehran, Iran

Mahmoud Tabandeh
Department of Electrical Engineering
Sharif University of Technology,
Tehran, Iran

ramin.safaeian@ee.sharif.edu

saleh@sharif.edu

tabandeh@sharif.edu

Abstract
Causal relationships among a set of variables are commonly represented by a directed
acyclic graph. The orientations of some edges in the causal DAG can be discovered from
observational/interventional data. Further edges can be oriented by iteratively applying
so-called Meek rules.
Inferring edges’ orientations from some previously oriented edges,
which we call Causal Orientation Learning (COL), is a common problem in various causal
discovery tasks. In these tasks, it is often required to solve multiple COL problems and
therefore applying Meek rules could be time consuming. Motivated by Meek rules, we
introduce Meek functions that can be utilized in solving COL problems.
In particular,
we show that these functions have some desirable properties, enabling us to speed up the
process of applying Meek rules. In particular, we propose a dynamic programming (DP)
based method to apply Meek functions. Moreover, based on the proposed DP method,
we present a lower bound on the number of edges that can be oriented as a result of
intervention. We also propose a method to check whether some oriented edges belong
to a causal DAG. Experimental results show that the proposed methods can outperform
previous work in several causal discovery tasks in terms of running-time.
Keywords: Causal Discovery, Structural Causal Models, Meek Rules, Causal Orientation
Learning, Experiment Design

1. Introduction

Recovering causal relationships from data is one of the ultimate goal in the empirical sci-
ences. The behavior of a complex system is not fully understood unless one can infer how
diﬀerent variables in the system inﬂuence each other. Without such complete understand-
ing, it might be infeasible to predict how the system behaves in response to some target
interventions.

In the literature, the causal relationships among a set of variables in a system are
commonly represented by a directed acyclic graph (DAG) where there is a directed edge
from variable X to variable Y if X is the direct cause of Y . From observational data, under
causal suﬃciency and faithfulness assumptions, the true causal graph can be identiﬁed up
to a Markov equivalence class (MEC) which is the set of all DAGs representing the same
set of conditional independences among the variables. It has been shown that all DAGs

1

 
 
 
 
 
 
in an MEC has the same skeleton1 and the set of v-structures2 (Verma and Pearl, 1992).
Given the skeleton and set of v-structures, Meek (1995) proposed four rules, called Meek
rules, to orient further edges in the graph by making no directed cycles or new v-structures.
These rules are applied iteratively on the causal graph until no further edges can be oriented
by applying any of these rules. However, some edges might be remained undirected even
after applying Meek rules. The resulted graph is commonly called the essential graph which
represented a summary of all DAGs in MEC in the sense that if there is a directed edge from
X to Y in the essential graph, the same orientation holds in all DAGs in MEC. Otherwise,
there exist at least two DAGs with the opposite directions of edge between X and Y .

In order to identify the whole causal structure, the golden standard procedure is to
perform interventions in the system. For instance, by performing perfect randomized in-
tervention on a variable, we are able to recover orientations of all edges incident with the
intervened variable (He and Geng, 2008). Based on these new oriented edges, we can apply
Meek rules again to discover further edges’ orientations.

In both scenarios mentioned above (obtaining essential graph from observational data
or discovering orientation of undirected edges from interventional data), we try to solve
the problem of inferring new edges’ orientations based on our current knowledge about
the causal structure which might come from observational data, interventional data, or
some prior knowledge. The discovered orientations should not make any new cycle or v-
structure in the causal graph. We call this problem, “causal orientation learning (COL)”
problem. Meek rules can be utilized as a basis to solve COL problem. However, in various
applications of causal structure learning (see the related work), it is required to solve several
COL problems. Unfortunately, executing Meek rules for solving multiple COL problems
might be time-consuming since these rules are applied for each problem separately in an
iterative manner. Moreover, in some of the applications, the COL problems have structural
similarities and the solution for one of the problems can be reused in other ones. In this
paper, our main goal is to devise a solution to solve multiple COL problems eﬃciently in
time. Moreover, the proposed solution can be used as a subroutine in various settings for
causal structure learning. In the next part, we review some of these settings in which COL
problem arises along with the solutions that have been proposed in the literature. Two
main problems that we review here, are counting size of MEC and experiment design.

First, we consider the problem of counting size of MEC. The number of DAGs in an MEC
can give an indication of the “causal complexity” of the underlying true causal structure.
For instance, in order to determine the range of possible causal strengths of variables on a
target variable, in one of the algorithms in (Maathuis et al., 2009), it has been proposed to
enumerate all DAGs in an MEC and estimate the causal strength of each parent of the target
variable in the corresponding DAG. Herein, the size of MEC shows the time complexity
of the estimation procedure. As another example, He and Geng (2008) proposed multiple
scores, based on the possible sizes of an MEC after performing intervention on each variable.
The variable with the highest score is selected for doing intervention (we will discuss this
problem in more detail in the next part). In fact, remaining too many DAGs in the resulted

1. Two directed graphs have the same skeleton if they have the same set of vertices and edges regardless

of their orientations.

2. Three variables X, Y, and Z form a v-structure in a graph if X and Y are the direct cause of Z and they

are not connected to each other.

2

MEC after performing an intervention indicates the candidate variable is not suitable to be
intervened on.

He et al. (2015) proposed the ﬁrst eﬃcient algorithm for counting the size of MEC
instead of enumerating all DAGs. They ﬁrst presented ﬁve closed-form formulas that can
be used to calculate size of MECs having some speciﬁc relations between the number of
nodes and edges. Next, they showed that counting size of an MEC can be partitioned
into smaller sub-classes and the size of each of them can be computed in an iterative
manner. In particular, the components corresponding to sub-classes (which are commonly
called chain components) are obtained by removing the directed edges from the essential
graph of MEC. In order to ﬁnd the size of each sub-class, it is required to consider each
variable in the corresponding component to be root and solve a COL problem to obtain
further chain components in it. This procedure should be done recursively on each variable
in the resulted components. Thus, we need to solve several COL problems and it may
become time-consuming as the number of nodes increases. He et al. (2015) proposed an
eﬃcient algorithm to solve each COL problem separately which resembles applying Meek
rules carefully according to properties of sub-classes. However, this solution still needs
to solve multiple COL problems and does not reuse the results of a COL problem in the
another one. He and Yu (2016) introduced a special structure of “core graphs” and showed
that the size of MEC is a polynomial of number of vertices given its core graph. Moreover,
they proposed an algorithm in order to obtain this polynomial.
Inside this algorithm,
similar to their previous work, it is required to solve multiple COL problems in order to ﬁnd
chain components in the essential graphs. Ghassami et al. (2019) and Talvitie and Koivisto
(2019) proposed a dynamic programming based solution in order to compute the size of
MEC. In this solution, whenever size of a chain component is computed, it is stored in
memory and will be used later if we encounter the same chain component. In both works,
it is necessary to solve multiple COL problems to obtain chain components and clique trees
were utilized to eﬃciently orient edges in each COL problem.

Another important problem related to COL problem is experiment design problem.
The whole causal structure can be recovered with suﬃcient number of interventions if it
is feasible to intervene in the system. However, in most applications, performing inter-
ventions is too time-consuming or costly. The problem of experiment design is to devise
a set of experiments where each experiment consists of multiple interventions performed
simultaneously. The maximum number of interventions in each experiment is usually set
to a ﬁxed value (in some previous work, this value is equal to one (Hauser and Buhlmann,
2014; He and Geng, 2008; Ghassami et al., 2018)). The experiment design problem can be
studied in two settings of passive or active learning. In the active setting, the experiments
are performed sequentially and the result of an experiment is used in designing latter ones.
More speciﬁcally, it is commonly assumed that the orientations of all edges incident with
an intervened variable can be recovered by performing perfect randomized interventions.
Based on these newly oriented edges, we can solve a COL problem to ﬁnd resulted chain
components after doing intervention. The goal is to recover the whole causal structure with
minimum number of interventions. In contrary, in the passive setting, we have a limited
budget for performing experiments. All the experiments are designed based on the MEC
obtained from observational data and performed in parallel. According to the results of
experiments, we solve a COL problem to orient as much edges as possible. Here, the goal

3

is to design a set of limited number of experiments (the number of interventions in each
experiment is usually set to one) to recover the most part of the causal structure.

In the passive setting, He and Geng (2008) proposed a naive approach to enumerate all
DAGs in an MEC and select a set of variables for interventions with minimum size such
that all possible underlying DAGs can be recovered from the results of interventions after
solving a COL problem. Ghassami et al. (2018) proposed a greedy algorithm to select the
target interventions by sampling DAGs from the MEC and estimating the average number
of edges oriented as a result of intervention. Again, in the sampling procedure, it is required
to solve several COL problems similar to counting size of MECs. Kocaoglu et al. (2017)
proposed an algorithm for experiment design where there exists a cost for intervening each
variable. They showed that the optimal solution can be obtained in polynomial time in the
case of causal strucutre being a tree or a clique tree.

In the active setting, He and Geng (2008) introduced an entropy based score to select
the intervened variable in each step. In this score, it is required to compute the size of MEC
for any possible orientations of edges incident with a given variable. Hauser and Buhlmann
(2014) proposed a minimax criterion in order to select the target intervention. First, for
any given variable, it is required to obtain the maximum number of undirected edges in
the essential graphs that are consistent with diﬀerent possible orientations of edges incident
with the given variable. Next, from these variables, the one that minimizes this criterion
is selected. In order to compute this criterion, Hauser and Buhlmann (2014) presented an
algorithm where, for any feasible orientations of edges connected to a given variable, the
number of oriented edges as a result of these newly oriented edges is obtained by solving
a COL problem through running LexBFS algorithm. In fact, one can utilize LexBFS algo-
rithm to ﬁnd an ordering over a chain component and orient edges based on this ordering
without making directed cycles or v-structures. Shanmugam et al. (2015) proposed a score
based on graph coloring and separating system in order to select the node for the interven-
tion. After observing the result of an intervention, a COL problem is solved to orient further
edges by simply applying Meek rules. Ness et al. (2017) focused on Bayesian approach to
learn the causal structure based on a prior probability distribution on the underlying graph.
They introduced an information gain to select the variables for performing interventions.
Similarly, Agrawal et al. (2019) studied the problem of experiment design from Bayesian
perspective considering limited number of samples. They proposed a greedy algorithm with
guarantee on approximation quality. Greenewald et al. (2019) also considered a Bayesian
approach with the assumption of all chain components being trees. They proposed an al-
gorithm with an approximation ratio of 2, in the sense that the number of interventions is
at most twice the minimum achievable number. Teshnizi et al. (2020) proposed an eﬃcient
algorithm, called LazyIter, for iterating over MECs for all possible orientations of edges
incident with a variable. Hence, it is required to solve multiple COL problems simultane-
ously. The authors exploited the similarities among possible essential graphs to avoid the
recalculation of edges’ orientations for each of them separately. The proposed algorithm
has been utilized to solve problems of counting size of MEC and experiment design. Be-
sides counting size of MEC and experiment design problems, there exist some other related
works to COL problem. For instance, Chickering (1995) proposed an algorithm to recover
oriented edges in the MEC of a DAG, given its skeleton and v-structures. Ramsey et al.
(2017) considered a limited version of faithfulness assumption and presented a search algo-

4

rithm to considerably speed up the process of ﬁnding the essential graph from the samples,
at the expense of allowing graphs to violate Markov factorization, i.e., for the conditional
dependence and independence relations estimated from the samples. They also evaluated
this model in large graphs with multi-million nodes.
The contributions of this paper are threefold:
• We introduce rigorous mathematical representations of Meek rules, which we call
Meek functions. Equipped with these functions, we present key properties of these
functions that enable us to execute them separately on a causal graph and aggeragate
their outputs in order to obtain the ﬁnal result. Based on these properties, we can
speed up the process of applying Meek rules for solving a COL problem.

• As mentioned before, in some cases, we are required to solve multiple COL prob-
lems with similar causal structures (such as COL problems in the experiment design
problem). By exploiting Meek functions’ properties, we can keep the results of some
computations and reuse them in other similar COL problem. Based on this idea,
we propose a method to solve experiment design problem in the active setting in an
eﬃcient manner.

• We present a method to check eﬃciently whether a set of edges’ orientations (which
might come from some prior knowledge) are consistent in the sense that there is a
DAG with the same orientations for the given edges.

• We propose an eﬃcient method to compute a lower bound on the number of oriented
edges as a result of intervention. This lower bound can be utilized to select variables
for intervention according to the minimax criterion (Hauser and Buhlmann, 2014).
Experiments show that the gap between the lower bound and the true value is small
and the same set of variables are selected if we use lower bounds instead of true ones.

The rest of this paper is organized as follows: We begin with some background and
terminologies in Section 2. We then introduce a rigorous representation of Meek rules and
present some their key properties in Section 3. In Section 4, based on these properties, we
present methods for applying Meek rules on causal graphs and checking the consistency
of some edges’ orientations in a DAG. We also propose a lower bound on the number of
oriented edges as a result of intervention. In Section 5, we report our experimental results
for the proposed methods and the lower bound. Finally, in Section 6, we conclude the paper
and discuss some possible directions for future research.

2. Background and Terminology

A graph G = (V, E) is represented by a set of nodes V and a set of edges E. We denote
the undirected edge between a pair of nodes v1, v2 ∈ V, by v1
v2. A directed edge from
node v1 to node v2 is also denoted by v1 → v2. We assume that there exists at most one
edge either directed or undirected between each two nodes. We denote the set of all nodes
that are connected to node v by neigh(v). We also deﬁne N eigh(v) = neigh(v) ∪ {v}. We
call a subset of nodes of an undirected graph as clique if every two nodes in that subset are
adjacent. A clique is maximal if it is not a subset of a larger clique. We denote the set of
maximal cliques in the neighborhood of node v by C(v).

5

We say a graph G is partially directed acyclic graph (PDAG) if it does not have any
directed cycle (Peters et al., 2017). A graph G is called directed acyclic graph (DAG) if it
is PDAG and all the edges in G are directed. We say that node v1 is a parent of node v2
if there is a directed edge from v1 to v2 in graph G. Moreover, the descendants of a node
v1 is the set of nodes that there are directed paths from v2 to them. An induced sub-graph
of graph G containing vertices T ⊆ V is deﬁned to be a set of edges that contains all
those edges in E with both end points in T and it is denoted by E[T]. We call an induced
sub-graph in the form of v1 → v2 ← v3 as a v-structure. If a graph has no partially directed
cycle, it is called a chain graph. Removing all directed edges in a chain graph leaves some
undirected disjoint chain graphs. These chain graphs are called, chain components. An
undirected graph is said to be chordal if there exists a cord in any cycle with length more
than three.

Consider the set of variables X = {X1, · · · , Xn} in the system. Causal relationships
between these variables are usually modeled by a DAG G, where each variable in X is
mapped to one of the nodes in G, and an arrow between two nodes, like v1 → v2, shows
the corresponding variable of v1 in X as a direct cause of the corresponding variable of
v2 in X . We call this DAG, which represents causal relationships between variables, as a
“causal DAG”. We say that a joint distribution P over X satisﬁes Markov property with
respect to G if any variable of G is independent of its non-descendants given its parents.
Under causal suﬃciency and faithfulness assumptions, any conditional independence in P
can be inferred by Markov property (Spirtes et al., 2000). The set of all DAGs that encode
the same conditional independence assertions are called Markov equivalence class (MEC).
An essential graph corresponding to an MEC is a graph that has the same skeleton as all
DAGs in that MEC and an edge is directed in essential graph if that edge has the same
direction in those all DAGs. It can be shown that the essential graph is a chain graph with
chordal chain components, where each chain component is an undirected and connected
chordal graph (UCCG for short) (Andersson et al., 1997). We denote chain components
of a graph G by C(G). Note that the chain components are obtained by removing all the
directed edges from the essential graph, where whole v-structures are identiﬁed. Thus, in
any chain component, there is no undiscovered v-structure. In this manuscript, we use the
term UCCG for denoting one of the chain components of an essential graph.

From the observational distribution P , the essential graph of underlying ground truth
DAG can be recovered by performing conditional independence tests (Spirtes et al., 2000).
For further orienting the undirected edges, we need to intervene in the system. We use
the same notion of hard intervention as in Eberhardt et al. (2005) and Pearl (2009). The
procedure of intervention on a random variable X is to force this variable to get its values
from an independent randomized distribution, regardless of the values of its parents. For
a set of interventions I, two DAGs G1 and G2 are called I-Markov equivalent if they are
statistically indistinguishable under interventions in I. Interventional MEC (I-MEC) is the
set of all DAGs that are I-Markov equivalent. Moreover, the summary of all DAGs in an
I-MEC can be presented by an essential graph, which we call I-essential graph.

In this paper, we assume that inﬁnite samples from any observational or interventional
distributions are available. Thus, the true essential graph of underlying causal model is
available.

6

3. Causal Edge Orientation

In this section, we ﬁrst describe Meek rules (Meek, 1995). These rules enable us to orient
further edges since we know the underlying causal graph is a DAG. Then, in the next
section, we present a mathematical representation for Meek rules. Speciﬁcally, we deﬁne
Meek functions that help us to formulate the Meek rules in more rigorous way. In the last
part, we present some properties of Meek functions. As we will see later, these properties
can be utilized to solve COL problems in an eﬃcient manner.

3.1 Meek rules

As we mentioned in the previous section, the essential graph is a partially directed acyclic
graph that will be identiﬁed from the observational distribution (Spirtes et al., 2000). Note
that the skeleton and all the v-structures of the essential graph are the same as the skeleton
and v-structures of underlying causal DAG and they can be identiﬁed by performing some
conditional independence tests (Verma and Pearl, 1992). Additional edges in the essential
graph can be oriented based on these two facts: (a) there is no more undiscovered v-
structure, and (b) the underlying causal DAG is acyclic. Every such additional edges can
be identiﬁed by repeatedly applying Meek rules (Meek, 1995). It can be shown that Meek
rules are complete and sound in recovering the essential graph (Meek, 1995).

There are four Meek rules that are given in Table 1. In this table, we illustrate how an
edge will be oriented after applying each Meek rule. Each column corresponds to one of
the Meek rules. The graph in the ﬁrst row in each column will be converted to the graph
in the second row in that column after applying the corresponding Meek rule. Thus, some
undirected edges in the graph in the ﬁrst row have been oriented in the graph in the second
row. By considering all possible orientations for corresponding sub-graphs of Meek rules 3
and 4 , it can be shown that there is no need to consider orientations of dashed lines for
applying these Meek rules as long as the dashed lines do not belong to a v-structure.

In addition to applying Meek rules to obtain essential graph, we can utilize them to
orient further edges after performing an intervention on a node to obtain I-essential graph.
In this case, after performing a perfect randomized intervention, the orientations of all edges
between the intervened node and its neighbors will be recovered (He and Geng, 2008). Ap-
plying Meek rules on the graph with these new oriented edges, results in orienting additional
edges. This procedure will be continued till no edge can be discovered. The resulted graph
would be the I-essential graph after the intervention.

To wrap up, applying Meek rules on a graph with some new directed edges (for instance,
oriented edges in the neighborhood of a node after performing an intervention), may recover
the orientations of further edges in the graph. Having more directed edges means that more
causal relations have been revealed from the underlying causal graph. Thus, Meek rules can
be seen as a tool to infer new causal orientations based on some prior knowledge about the
causal graph. We will present a more formal representation of these rules in the next part.

3.2 Meek Functions

In this part, we deﬁne Meek functions. These functions take a set of edges as their inputs
and return another set containing already directed edges in the input set and some new edges

7

Table 1: Meek rules

Rule

Meek Rule 1 Meek Rule 2

Corresponding
sub-graph

After applying
Meek rule on
corresponding
sub-graph

Corresponding
candidate
sub-graph

vi

vk

vi

vk

vi

vi

vk

vi

vk

vi

vj

vj

vj

vj

vk

vj

vk

vj

Meek Rule 3
vi

Meek Rule 4
vi

vj

vl

vj

vl

vj

vl

vl

vl

vl

vk

vi

vk

vi

vk

vj

vj

vj

vk

vi

vk

vi

vk

that are oriented as a result of repeatedly applying one of the Meek rules. Furthermore,
we deﬁne a “candidate sub-graph” for each of these functions. Candidate sub-graph is an
induced sub-graph, with minimal number of nodes, that applying particular Meek rule on
that sub-graph, results in orienting one or more edges inside that sub-graph. We give a
concise deﬁnition of candidate sub-graphs for each of the Meek functions in the following.
We ﬁrst provide some deﬁnitions.

Deﬁnition 1 (Mixed-edge union operator) Let A and B be sets of some directed and
undirected edges. We deﬁne A ⊔ B as a set of edges with the following property:

A ⊔ B = C\{vi

vj|vi → vj ∈ C or vj → vi ∈ C, ∀i, j ∈ V},

where C = A ∪ B. In other words, A ⊔ B keeps the directed edge vi → vj if it exists in A
or B. Moreover, it keeps the undirected edge vi
vj if this edge has not been oriented in
either A or B.

Deﬁnition 2 (Skeleton of a graph) Let G = (V, E) be a PDAG, V be the set of nodes
and E be the set of edges. Assume that we replace all directed edges in this partially directed
graph with the undirected ones. We denote the set of all edges in this undirected graph with
E. Thus, we have:

E = {vi

vj|vi → vj ∈ E or vi

vj ∈ E, ∀i, j ∈ V} .

8

Deﬁnition 3 (Set of directed edges) Let G = (V, E) be a PDAG. We denote the set of
all directed edges in E by

−→
E :
−→
E = {vi → vj|vi → vj ∈ E, ∀i, j ∈ V} .

Now, we deﬁne a candidate sub-graph for each Meek rule. These candidate sub-graphs
are depicted in the third row in Table 1. Examples for Meek candidate sub-graphs are
shown in Figure 1. The candidate sub-graphs for Meek rules 1, 2 and 3 are as the same
of their corresponding sub-graphs, while Meek rule 4 candidate sub-graph deviates from its
corresponding sub-graph. In the following, we show that applying Meek rules are sound
and complete. The proof of all lemmas and theorems are given in the appendix.

Theorem 4 (Orientation soundness) Considering candidate sub-graphs in Table 1, the
four orientation rules are sound.

Based on the above deﬁnitions, we are now ready to deﬁne Meek functions. More

speciﬁcally, let G = (V, E) be a PDAG with set of nodes V and set of edges E.

Deﬁnition 5 (Meek functions) We deﬁne Mi as a function that takes E as input and
returns the set of edges EMi as the result of applying Meek rule i repeatedly on the cor-
responding candidate sub-graphs of Meek rule i in E until no candidate sub-graph can be
found and as a result no more edge can be oriented by this rule. In other words, we have:
Mi(E) = EMi.

Remark 6 Since there exists no candidate sub-graph for Meek rule i in the result of Mi(E),
we have: Mi(Mi(E)) = Mi(E).

Furthermore, in some parts of the paper, we overload the notation of Meek function
M1 with the second argument Ef , which is called as “forbidden edges”. The overloaded
function is in the form of M1(E, Ef ). Forbidden edges are the edges that Meek function
M1 does not allow to orient those edges. We use this type of function M1 for the recovering
essential graphs in Section 5. In the following, we give examples of both types of function
M1.

Example 1 Given a graph G = (V, E), where V = {v1, v2, v3, v4} and E = {v1 →
v2, v2

v4}, we have:

v3, v3

M1(E) = {v1 → v2, v2 → v3, v3 → v4}
M1(E, {v2

v3}) = {v1 → v2, v2

v3, v3

v4}

In practice, we need to apply multiple Meek functions to discover more edges’ ori-
entation. Any combination of Meek rules can be considered. For example, we deﬁne
M123(E) = EM123 as a function that takes set of edges E as input and returns the set
of edges EM123 as the result, by applying Meek rules 1, 2, and 3 in any order, repeatedly,
till no new edge can be discovered by applying any of these Meek rules. Again, the function
M123 has the property that M123(M123(E)) = M123(E).

Now, we deﬁne minimal PDAG (for short MPDAG), which is the minimal graph, in

terms of number of oriented edges, for representing equivalence class of a DAG.

9

va

ve

vc

vd

vb

(a)

va

ve

vc

va

vb

(b)

(c)

va

va

ve

vd

vc

vd

vd

vb

(d)

vb

(e)

Figure 1: (a): A partially directed acyclic graph (G). (b): Induced candidate sub-graph of
G for Meek rule 1. (c): Induced candidate sub-graph of G for Meek rule 2. (d): Induced
candidate sub-graph of G for Meek rule 3. (e): Induced candidate sub-graph of G for Meek
rule 4.

Deﬁnition 7 (Minimal PDAG) A minimal PDAG is a PDAG which is obtained by re-
placing some directed edges in a DAG with unidrected one, those edges that do not participate
in a v-structure. We denote a minimal PDAG by Go = (V, E).

The following two theorems guarantee that applying Meek functions on the correspond-
ing candidate sub-graphs are complete. One of these theorems is on the completeness of
applying Meek functions on MPDAG, and the other one is on the completeness of applying
Meek functions on MPDAG which has the some further oriented edge, which are selected
from one of the DAGs in the corresponding MEC.

Deﬁnition 8 (Maximally oriented graph) A PDAG G = (V, E) in the MEC of a
vj
MPDAG Go is a maximally oriented graph such that for each undirected edge vi
in G, if there exist DAGs D1 = (V, E1) and D2 = (V, E2) in the MEC of Go such that we
−→
E ⊆ E1 and
have vi → vj ∈ E1 and vj → vi ∈ E2, where

−→
E ⊆ E2.

Theorem 9 (Orientation completeness on MPDAG) Let Go = (V, E) be a MPDAG.
The result of applying M123 on E is a maximally oriented graph.

Theorem 10 (Orientation completeness) Let G = (V, E) be a MPDAG, including
some further directed edges, which are selected from one of the DAGs in MEC of its
MPDAG. The result of applying M1234 on E is a maximally oriented graph with respect
to

−→
E .

In the next part, we present some key properties of these functions.

3.3 Meek functions Properties

In the previous part, we deﬁned four Meek functions inspired by Meek rules (Meek, 1995).
In this part, we describe key properties of these functions. By exploiting these properties, we
can accelerate executing Meek functions and utilize it as tools to design eﬃcient algorithms
for the problem of experiment design or checking the consistency of prior knowledge with
the observational or interventional data (see Section 4). Before presenting the properties,

10

we deﬁne the partially directed and connected chordal graph (for short PCCG). In fact,
PCCG is a representation of one of the chain components of an essential graph, where some
of its edges are oriented according to one of the DAGs in the corresponding MEC.

Deﬁnition 11 (Partially directed and connected chordal graph) A PDAG G = (V, E)
is a PCCG if:

• Skeleton of G is a UCCG.
• −→

E in not empty.

• There is a DAG in the MEC of G with essential graph equal to skeleton of G, which

is also consistent with

−→
E 3.

In the following lemma, we will provide some properties of Meek functions on PCCGs.

Lemma 12 (Meek functions properties on PCCGs) Let G = (V, E) be a PCCG.
The following properties hold for Meek functions:

1. For any T ⊆ V, we have: M1234(E[T]) = M124(E[T])

2. For Mi ∈ {M1, M4, M14}, we have: Mi(E) =

Mi({vi → vj} ⊔ E).

−→E

vi→vj ∈
F

3. M124 (E) = M14(M2(E)).

4. For any subset S = {vi → vk, vk → vj, vi

vj} ⊆ E, we have:

M14(M2(S) ⊔ E\S) = M14(E) ⊔ M2(S).

In the following, we provide some intuitions of the above properties. Based on property
1, function M3 does not change the result when it is applied on a PCCG. This is due to the
fact that there will be no v-structure in these type of graphs, and as a result there will be
no candidate sub-graph for Meek rule 3. Thus, there is no need to apply this function on
the mentioned graphs.

The property 2 states that all the information in order to reveal additional edges’ ori-
In
entations as a result of applying one of the functions M1,M4 or M14 are in the
other words, if an edge is oriented after applying Meek functions M1,M4 or M14 on set
E, consequently, this edge will be oriented by applying Meek functions M1,M4 or M14 on
−→
e ⊔ E, for some e ∈
E . This property has two appealing consequences. First, the result
of applying mentioned Meek functions can be computed once and used multiple times such
as in the problem of experiment design (see Section 4). Second, we can devise a dynamic
programming method to apply Meek functions which reduces the running times (see Section
4).

−→
E .

By applying Meek function M124 on set of edges E, some undirected edges will be
oriented in E. Property 3 asserts that we can recover all these edges, by consecutively
applying function M14 after function M2 on E.

3. As the PCCG is a representation for partially oriented chain component, this constraint enforces to

consider only DAGs with consistent skeleton and no v-structure.

11

A candidate sub-graph for Meek rule 2 is in the form of {vi → vk, vk → vj, vi

vj}.
After applying function M2 on this candidate sub-graph, vi
vj edge will be oriented as
vi → vj. Property 4 states that discovering this edge’s orientation cannot help in orienting
further edges, even we apply function M14 on the set of edges including this directed edge.

In the next lemma, we express two properties for MPDAGs.

Lemma 13 (Meek functions properties on MPDAGs) Let Go = (Vo, Eo) be a MPDAG.
The following properties hold for Meek functions:

1. M1234(Eo) = M12(M3(Eo)).

2. M1(Eo) =

−→Eo

vi→vj ∈
F

M1({vi → vj} ⊔ Eo, Eo\{vi

vj}).

Based on the Theorem 9, we know that Meek function M4 is not necessary to be applied
in order to obtain the essential graph . Thus, we can omit this function from the functions
that must be applied. Moreover, candidate sub-graph for Meek rule 3 cannot be occurred
as a result of applying other Meek functions. This is because there is a v-structure in
the candidate sub-graph for Meek rule 3 and applying any of other Meek functions cannot
generate a new v-structure. Hence, from property 1, we can imply that it is just needed to
ﬁrst apply function M3 and then apply the other two functions.

Similar to Property 2 in Lemma 12, in Property 2 in Lemma 13, we use only directed
edges in Eo for orienting further edges in graph Go. In this property, we take v-structures
as the forbidden edges argument of Meek function M1 to avoid orient them in the reverse
direction.

After performing an intervention on an arbitrary node v in G, we can identify the direc-
tion of all the edges incident with node v (He and Geng, 2008; Eberhardt et al., 2005). We
know that these edges are enough to recover the I-essential graph (Hauser and Buhlmann,
2014). Moreover, according to Theorem 10, all the recoverable orientations can be identiﬁed
by applying Meek functions. Furthermore, various possible orientations of incident edges
yield diﬀerent possible I-essential graphs. For instance, Hauser and Buhlmann (2014) used
this idea to compute a score function to select a node for performing an intervention.

In the following, we deﬁne intervened and connected chordal graph (for short ICCG).
Suppose a node v in a UCCG G = (V, E) has been intervened on. After intervention, all
the edges connected to this node, will be oriented. We denote the sets of nodes that have in-
going edges toward and outgoing edges from node v by I and O, respectively. Furthermore,
we have O = neigh(v)\I.

Deﬁnition 14 (Intervened connected chordal graph) We say PCCG G = (V, E) is
−→
an ICCG if there exists only one node v ∈ V such that
E = S, where S = {vi → v|vi ∈
I} ⊔ {v → vo|vo ∈ O} and O = neigh(v)\I.

An ICCG is a representation for I-essential graph which is obtained after performing inter-
vention on a node in a UCCG. This is because, based on the Hauser and Buhlmann (2014),
knowing all the in-goring edges toward intervened node, is a complete representation of
I-essential graph. According to Proposition 6 in Hauser and Buhlmann (2014), set I is a
subset of a maximal clique in the neighborhood of node v. An example of ICCG is shown
in Example 2.

12

Remark 15 An ICCG is a special case of PCCG. Thus, the properties for PCCGs hold
for ICCGs.

In the Lemma 16, we provide one properties for ICCGs.

Lemma 16 (Meek function property on ICCGs) Let G = (V, E) be an ICCG. De-
noting all the induced candidate sub-graphs for Meek rule 2 in E[N eigh(v)] by CM2(v), we
have:

M2(E) =





Ci∈CM2 (v)
G

M2(Ci)



⊔ E.



This property asserts that, after performing an intervention, the candidate sub-graphs
−→
E as their directed edges are suﬃcient to compute result of applying
that consists of edges in
function M2. Hence, we can obtain the result of this part in two steps: (1) extracting
candidate sub-graphs for function M2, (2) apply this function to only extracted candidate
sub-graphs instead of applying to set of all edges. This procedure accelerates the execution
of function M2.

In some applications of COL problems, such as those mentioned in Section 3, we need
to apply function M124 on a given ICCG. This is because we do not have any v-structure
in those types of graphs and as a result we do not need to apply Meek function M3.
The conventional method is to repeatedly apply Meek rules 1, 2 and 4 on sub-graphs
corresponding to these rules, till no more edge can be oriented. The following theorem
states one of the key properties of Meek functions where applying function M124 can be
decomposed to applying function M14 and M2. This theorem ensures that the result of
decomposition method is the same as the conventional one of applying Meek rules.

Theorem 17 (Decomposition of applying M124 on ICCGs) Let G = (V, E) be an
ICCG. Applying function M124 on set E can be decomposed as follows:

M124(E) =





−→E
Ge∈

M14({e} ⊔ E)



G







Ci∈CM2 (v)
G

M2(Ci)



,



where CM2(v) is collection of all induced candidate sub-graphs for Meek rule 2 in the sub-
graph E[N eigh(v)].

In the next section, we exploit these properties of Meek functions in solving COL prob-

lems in diﬀerent applications.

4. Applications of COL Problems

In this section, we utilize Meek function properties in diﬀerent problems such as experiment
design or checking the edge orientation consistency with a prior knowledge. In particular,
in Section 4.1, we introduce a new method that accelerates computing Meek functions. In
Section 4.2, we propose a lower bound on number of edges that can be oriented as a result

13

of performing an intervention on a variable. This lower bound can be used as a measure for
designing experiments. In the last part, given a graph with set of combined directed and
undirected edges, we check whether directed edges in the given graph belong to a DAG or
not.

4.1 Fast Computation of I-essential Graphs

In this part, we propose a novel method for eﬃciently discovering the orientations of ad-
ditional edges that can be identiﬁed after performing an intervention4. This method uses
mentioned properties of Meek functions in the previous section. An I-essential graph is char-
acterized by oriented edges in the neighboring of intervened node (Hauser and Buhlmann,
2014). In order to recover orientations of further edges, Meek functions must be applied.
As we mentioned in the previous section, it suﬃces to apply Meek function M124. Based on
Theorem 17, we can decompose the output of Meek function M124 computation into two
parts: (a) The output of applying Meek function M14, (b) The output of applying Meek
function M2. Hence, accelerating the computation of Meek functions M14 and M2 will re-
duce the running time of executing Meek function M124. In the following, we describe the
procedure in which we accelerate these functions.

We ﬁrst describe our method for applying Meek function M14 in an eﬃcient manner.
Let G = (V, E) be a PCCG. Based on property 2 of Lemma 12, we can imply that Meek
function M14 can be computed by performing mixed edge union on the results of applying
this function on graphs that each of them has only one directed edge. We take advantage
vd be an undirected edge in the set of
of this property to accelerate this function. Let vs
edges E. For any edge vs

vd ∈ E, we deﬁne DP [vs → vd] as follows:

DP [vs → vd] = M14({vs → vd} ⊔ E).

(1)

In the following, we propose a dynamic programming method for computing the above

function.

Proposition 18 The following equation holds for DP function in (1):

DP [vs → vd] = 

DP [vl → vk]

{vs → vd} ,

−→
E′

Gvl→vk∈




G




where E′ = M14({vs → vd} ⊔ E[N eigh(vd)])\ {vs → vd}.

Proposition 18 suggests a method to compute the result of applying Meek function M14
on a graph with one directed edge based on a dynamic programming method. According
to Proposition 18, we need to apply Meek function M14 results in the neighborhood of
vd. Hence, it suﬃces to check two candidate sub-graphs for Meek rules 1 and 4 in the
neighborhood of vd for further edges orientation.

Figure 2 illustrates these two sub-graphs. Note that there is no edge between nodes vs
and vj. So, in order to ﬁnd candidate sub-graphs that are shown in Figure 2, we attempt

4. Similar to the method proposed in this part, we can accelerate the procedure of obtaining the essential

graph. We will describe this method in Section 5.

14

vs

vd

vi

(a)

vj

vs

vj

vd

(b)

Figure 2: (a): Candidate sub-graph for Meek rule 4. (b): Candidate sub-graph for Meek
rule 1.

to ﬁnd some node vj /∈ neigh(vs). In the following, we design an algorithm that computes
and stores the DP results using these sub-graphs.

In Algorithm 1, we suggest a recursive implementation that computes and stores DP
results. This algorithm shows how one null entry of DP table can be ﬁlled. We ﬁrst initialize
DP [vs → vd] with vs → vd in Line 4. According to the sub-graphs in Figure 2, there is no
edge between nodes vs and vj. Thus, we search for node vj ∈ neigh(vd)\neigh(vs) in Line 5.
For any such node vj, using Meek function M1, we must orient the edge vd
vj as vd → vj.
For the next step, we must compute the union of DP [vs → vd] and DP [vd → vj]. In Lines
6-8, we check whether the entry vd → vj in DP is null or not. If DP is already calculated,
we can compute the union. Otherwise, we go through another function call to calculate this
entry. Lines 9-12 correspond to the case in Figure 2(a). In this case, we search for a node
vi in the neighborhood of all three nodes vs, vd and vj. For any such node vi, using Meek
vj as vi → vj and then compute the union of
function M4, we must orient the edge vi
DP [vs → vd] and DP [vi → vj]. After all these recursive function calls are completed, the
DP result for vs → vd will be available. Note that in the procedure of obtaining one entry
of DP table, multiple indices of this table might be ﬁlled.

Theorem 19 Computational complexity of ﬁlling all entries of DP table using Algorithm
1 is in the order of O(|E|∆2), where ∆ is the maximum degree in the graph.

Since we compute DP for each edge in both directions, DP table size is two times of the
number of edges. In the rest of this paper, we will assume that DP entries are available.
In the next section, we will see that having DP table is helpful in applications that have
high-demands of applying Meek functions M14.

Having the DP table, now we show how it can be utilized to apply M14 function on a
graph whose some edges are oriented as a result of intervention on a node. In the following
lemma, we will show that the result of applying M14 can be accelerated by both using
already calculated DP table and also taking advantage of property 2 in Lemma 12.

Lemma 20 (Applying M14 on PCCGs) Let G = (V, E) be a ICCG, which is obtained
after intervention on node v. The result of applying M14 on E can be obtained as follows:

where S′ = {vi → v|vi ∈ I} ⊔ {v → vo|vo ∈ O, I ⊆ neigh(vo)}.

M14 (E) =

DP [vl → vk],

Gvl→vk∈S′

15

Algorithm 1 Computation of M14({vs → vd} ⊔ E)
1: Input: G = (V, E), a PCCG
2: Output: Oriented edges as a result of applying function M14 on {vs → vd} ⊔ E which

is equal to DP [vs → vd]

3: function OrientOneEdge(DP, vs, vd)
4:

DP [vs → vd] ← {vs → vd}
for vj ∈ neigh(vd)\neigh(vs) do

5:

6:

7:

8:

9:

10:

11:

12:

if DP [vd → vj] = N U LL then

DP ← OrientOneEdge(DP, vd, vj)
DP [vs → vd] ← DP [vs → vd] ⊔ DP [vd → vj]
for vi ∈ neigh(vs) ∩ neigh(vd) ∩ neigh(vj ) do

if DP [vi → vj] = N U LL then

DP ← OrientOneEdge(DP, vi, vj)
DP [vs → vd] ← DP [vs → vd] ⊔ DP [vi → vj]

13: Return DP

Based on the previous lemma, we can obtain the result of Meek function M14 by merely
combining some entries of DP table. Thus, for further acceleration of function M124, it
suﬃces to accelerate applying Meek function M2. Using properties 3 and 4 in Lemma 12
allows us to obtain the result of Meek function M2 on a graph without explicitly applying it.
The next theorem suggests a fast method to discover new edges’ orientations after applying
Meek function M124.

Theorem 21 (Applying M124 to obtain I-essential graph) Let graph G = (V, E) be
an ICCG, which is obtained after intervention on node v. The result of applying M124 on
set E can be obtained as follows:

M124(E) =




Gvl→vk∈S′

DP [vl → vk]




G

{vi → vo|vi ∈ I, vo ∈ Vc}

where S′ = {vi → v|vi ∈ I} ⊔ {v → vo|vo ∈ Vc}, and Vc = {vo|vo ∈ O, I ⊆ neigh(vo)}.





Example 2 Figure 3(a) illustrates a UCCG G = (V, E). Assume that an intervention was
performed on node v3 and the ICCG in Figure 3(b) was obtained. Entries of DP table for
all possible edges’ orientations are given in Figure 3(c). From the graph, we have I = {v4},
O = {v2} and S = {v4 → v3, v3 → v2}. Furthermore, we have S′ = S. Therefore, according
to Theorem 21, the result of applying Meek function M124 can be obtained as follows:

M124 (E ⊔ S) =



DP [vl → vk]



{v4 → v2}

vl→vk∈S
G

G
= {v3 → v2, v4 → v1, v2 → v1, v1 → v5, v4 → v3, v4 → v2}.





16

v1

v5

v2

v3

v4

(a)

v1

v5

v2

v3

v4

(b)

Index
v2 → v1
v4 → v1
v3 → v2
v4 → v2

v4 → v3

v5 → v1

DP Value
{v2 → v1,v1 → v5,v4 → v1,v1 → v5}
{v4 → v1,v1 → v5}
{v3 → v2,v4 → v1,v2 → v1,v1 → v5}
{v4 → v2}

{v4 → v3}

{v5 → v1,v1 → v2,v2 → v3,
v1 → v4,v4 → v3}

Index
v1 → v2
v1 → v4
v2 → v3
v2 → v4

v3 → v4

v1 → v5

DP Value
{v1 → v2,v2 → v3,v4 → v3}
{v1 → v4,v2 → v3,v4 → v3}
{v2 → v3}
{v2 → v4}
{v3 → v4, v4 → v1,
v1 → v5, v2 → v1}

{v1 → v5}

Figure 3: (a): UCCG G = (V, E). (b): Obtained ICCG after intervention on node v3. (c):
DP values with respect to graph G.

(c)

4.2 Lower Bound on the Number of Discovered Edges’ Orientations

In the literature of experiment design, several objective functions have been proposed to
determine which node should be intervened on in order to recover as many edges’ orienta-
tions as possible. One of the main objective function is in the form of minimax where we
try to ﬁnd that for each node how many edges’ orientations will be discovered in the worst
case scenario if we decide to intervene on that node. A naive solution is to consider all the
possible orientations for the edges incident with a node and then compute the number of
oriented edges can be discovered in the worst case for each of these cases. However, this
solution may become very time consuming and it cannot be applied in medium-size or large
graphs. Here, we propose a method to calculate a lower bound on number of edges that
can be oriented as a result of intervening on each node.

We consider a UCCG G = (V, E) with set of nodes V and set of edges E. We denote
the set of all maximal cliques in the neighborhood of a node v ∈ V by C(v). For computing
the lower bound on a node such as v, we partition all the possible edges orientations that
are connected to this node, into two cases: (1) There exists a maximal clique Ck ∈ C(v),
where at least one edge from a node vi ∈ Ck is in-going toward node v and all the edges
between node v and neigh(v)\Ck are outgoing from node v, (2) All edges that are connected
to node v are outgoing from this node. For the ﬁrst case, we compute a lower bound for
each maximal clique Ck ∈ C(v) which means how many edges, at least, will be oriented
after performing intervention on node v, considering edges’ orientations in this case. For
the second case, we obtain the true value of number of edges that can oriented. Finally, we
compute the lower bound based on these two cases.

17

Here, ﬁrst we describe the lower bound on a maximal clique. We will obtain the lower
bound on a maximal clique by partitioning the problem into two settings: (a) computing
number of edges that will be oriented when all edges are from maximal clique to node v.
We denote this number by LI. (b) computing a lower bound on the number of edges when
at least one edge is from a node in the maximal clique to node v and at least one edge is
oriented in the reverse direction, i.e., from node v to a node in the maximal clique. We
denote this lower bound by LC.

For the ﬁrst setting, we can exactly ﬁnd the number of oriented edges as a result of
intervention. In the second setting, there exists an edge vi → v that is from node vi ∈ Ck
toward node v and an edge v → vo that is from node v to a node vo ∈ Ck. Consider the
set of all in-going edges for the nodes vi ∈ V and all out-going edges for the nodes vo ∈ V.
Every edge in this set will be separately considered for orienting further edges and other
edges in this set do not contribute to this process. Next, by post-processing these results,
we obtain a lower for this maximal clique Ck.

In order to compute LC, we ﬁrst obtain the set of edges that are oriented as a result
of applying Meek functions on edges from node v to nodes in neigh(v)\Ck, and we denote
this set by R. Next, we obtain a lower bound on the number of edges that can be oriented,
when we know there exist exactly j number of edges from nodes in clique Ck to node v,
excluding those that are in set R. We denote this lower bound by Pj. For computing Pj, we
consider all possible cases that there are exactly j number of edges from clique Ck to node
v. Let I be the set of these edges in one of these cases where |I| = j. Now, for any vi ∈ I,
we consider the orientations of edges from v to neigh(v)\Ck and vi → v as the input and
apply Meek functions in order to recover the orientations of further edges. By removing the
set R from the resulted oriented edges, we can deduce the set of edges that can be oriented
based on the edge vi → v. We repeat this procedure for any node vi ∈ I, and by considering
the best case (i.e., picking the case resulting in maximum number of directed edges), we
can obtain a lower bound on the number of edges that can be oriented by the whole edges
{vi → v|vi ∈ I}. This is due to the fact that we just use the orientation of one of the edges
in {vi → v|vi ∈ I} in each of the cases for deriving the lower bound. Moreover, there might
be multiple options for the set I with size j. Hence, we need to consider all these options
and pick the worst one as the lower bound Pj. Similarly, we can obtain a lower bound when
we know there exist exactly j number of edges from v to nodes in clique Ck. We denote
this lower bound by Qj.

Next, we try to orient edges in induced sub-graph E[Ck]. We can exactly compute the
number of oriented edges in this set, if we assume that there exist exactly j edges from nodes
in clique Ck to node v. We will show in Lemma 22 that this value is equal to j|Ck − j|.
Note that having j ingoing edges to v means that we will have |Ck| − j outgoing edges from
node v to clique Ck.

Finally, we consider the edges that we did not take into account in the previous steps but
they will be oriented as a result of intervention. In particular, after performing intervention
on v, all the edges between nodes in clique Ck and node v will be oriented. We consider
one ingoing edge toward v in computing Pj and one outgoing edge from v in computing Qj.
Thus, we need to consider |Ck − 2| remaining oriented edges in our lower bound.

18

In the following, based on Pj’s and Qj’s, we present a lower bound on number of edges
that can be oriented by intervening on node v, constraint to have at least one ingoing edge
toward node v.

Lemma 22 (Lower bound for the case of a maximal clique) Consider the set of IC-
CGs that can be obtained after intervention on node v, such that we have I ⊆ Ck ∈ C(v),
I 6= ∅ and O = neigh(v)\Ck. The lower bound on number of oriented edges for all possible
sets I, L(Ck, v), can be obtained as follows:

where,

L(Ck, v) = min(LI , LC ),

LI =

vi∈Ck
G

(cid:12)
(cid:12)
(cid:12)
(cid:12)
LC = |R| +
(cid:12)
(cid:12)

DP [vi → v]
(cid:12)
(cid:12)
(cid:12)
(cid:12)
min
(cid:12)
l∈{1,...,|Ck|−1}
(cid:12)

Pl + Q|Ck|−l + |l|(|Ck| − |l|) + (|Ck| − 2)

R =

DP [v → vo]

Gvo∈neigh(v)\Ck

Pj = min

|I|=j,I⊂Ck

max
vi∈I

|(DP [vi → v] ⊔{vi → vo|vo ∈ neigh(vi) ∩ neigh(v)\Ck}) \R|

Qj =

min
|O|=j,O⊂Ck

max
vo∈O

|DP [v → vo]\R|.

In Lemma 22, the minimum value of settings (a) and (b) is considered as a lower bound
for the setting where the maximal clique Ck has at least one outgoing edge toward the
target node. In this bound, the computation of LI is straight forward. In order to compute
LC, we need to consider all the cases of having l = 1, · · · , |Ck| − 1 number of edges from
the maximal clique Ck to node v and compute Pl and Q|Ck|−l (note that we have |Ck| − l
number of edges from node v to the maximal clique). In each case, we also need to take
into account the size of the set R, the number of oriented edges in the induced sub-graph
E[Ck], i.e., |l|(|Ck| − |l|), and the other edges that are oriented as the result of intervention
on v, i.e., |Ck| − 2. By picking the worst case scenario for diﬀerent values of l, we can obtain
the lower bound LC .

In order to compute Pl and Q|Ck|−l, we can enumerate all the possible sets I of size
l which might be time consuming.
Instead, we present Algorithm 2 which can compute
L(Ck, v) in an eﬃcient manner. In Line 5, we compute LI and we compute set R in Line 6.
In Lemma 22, we need to compute the number of oriented edges as a result of applying Meek
function M14 in the worst case for two scenarios; In the ﬁrst scenario, only one directed edge
exists from a node in maximal clique Ck to node v while in the second scenario, only one
directed edge exists from node v to maximal clique Ck. In Line 9, we obtain the number
of edges that can be oriented as a result of applying Meek function M14 where there exists
a directed edge from maximal clique Ck to node v, i.e., DP [vr → v]. In Line 10, we obtain
the number of edges that can be oriented as a result of applying Meek function M14 where
there exists a directed edge from node v toward maximal clique Ck, i.e., DP [v → vr]. In
Line 11, we sort the obtained values of P and Q in the ascending order. In Lines 12-13, we

19

search for minimum number of oriented edges where the number of ingoing edges toward
node v can be varied from 1 to |Ck| − 1. Selecting l-th item from sorted variables P and Q
is the same as considering values of Pl and Ql in Lemma 22, respectively. To see why this
is true, note that for achieving the lower bound Pl, we just need to consider l ingoing edges
toward node v corresponding to the l lowest values in array P as the set I. In the same
vein, it can be seen that l-th entry of array Q is equal to Ql.

Algorithm 2 Computation of maximal clique lower bound

1: Input: A UCCG G = (V, E)
2: Output: lower bound on number of oriented edges after applying Meek functions
3: function L(G, Ck, v, DP )
4:

vi∈Ck

DP [vi → v]
DP [v → vo]
(cid:12)
(cid:12)
(cid:12)

r ← 0
L ←
R =
(cid:12)
vo∈neigh(v)\Ck
F
(cid:12)
for vr ∈ Ck do
(cid:12)
F
r ← r + 1
P [r] = |
Q[r] = |DP [v → vr]\R|
(cid:16)
F
P ← sort(P ),Q ← sort(Q)
for l ← 1 : |Ck| − 1 do

DP [vr → v]

5:

6:

7:

8:

9:

10:

11:

12:

13:

vo∈neigh(vi)∩neigh(v)\Ck

{vr → vo}

\R|

(cid:17)

L = min(L, |R| + P [l] + Q[|Ck| − l] + l(|Ck| − l)) + (|Ck| − 2)

14: Return L

Remark 23 Having access to entries of DP table, the computational complexity of Algo-
rithm 2 for a node v and maximal clique Ck is O(ω log ω), where ω is the clique number.

In the following, we propose a lower bound on number of oriented edges as a result of
performing an intervention on a node. We do not consider any assumption on edges’ orien-
tations. Possible orientations of edges incident with the intervened node can be partitioned
into two groups: In the ﬁrst group, all the edges in the neighborhood of the target node are
outgoing from it. In the second group, there is an edge (or possibly edges) from a maximal
clique to the target node. In Lemma 22, we investigated the lower bound for a maximal
clique with at least one ingoing edge toward the target node. Hence, the lower bound in
second group can be achieved by calculating the minimum value of lower bounds for all
maximal cliques in the neighborhood of the target node. Finally, the lower bound on a
target node can be obtained as given in the following lemma.

Theorem 24 (Lower bound for the case of a node) The lower bound on the number
of edges that will be oriented after performing an intervention on node v, L(v), in an
arbitrary UCCG G can be obtained as follows:

L(v) = min

(cid:12)

(cid:12)
Gvo∈neigh(v)
(cid:12)
(cid:12)

(cid:12)
(cid:12)

DP [v → vo]
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

20

, min
Ck∈C(v)

L(Ck, v)



.



Remark 25 The computational complexity of lower bound in Theorem 24 for a node v is
O(M ω log ω), where ω is the clique number, and M is the maximum number of maximal
cliques in the neighborhood of a node.

4.3 Orientation Consistency

In this part, we assume that there is an expert who reveals the orientations of some undi-
rected edges in a PDAG. This prior knowledge can also be obtained from a partial ordering
on nodes (Hauser and Buhlmann, 2012; Wang et al., 2017) or restricting the causal relation-
ships to a certain model (Eigenmann et al., 2017; Hoyer et al., 2012; Rothenhausler et al.,
2018). We will take advantage of Meek functions’ properties in the previous section to
validate the correctness of these orientations in an eﬃcient manner.

Suppose that we are trying to recover the underlying ground truth graph, and our
identiﬁcation algorithm discovered a PCCG. In this stage, an expert suggests to orient
some further undirected edges in the obtained PCCG based on a domain knowledge. We
are interested in checking whether the combination of already directed edges and recently
added orientations are consistent or not. As underlying ground truth graph is a DAG, we
just need to ﬁnd a DAG being compatible with all the given directed edges. To do so, in
the following, we ﬁrst provide some deﬁnitions.

Deﬁnition 26 (Consistent edges) Consider a graph G = (V, E) with set of nodes V and
set of edges E. We say that in a graph with skeleton E, two directed edges vi → vj, vr → vt in
−→
E are consistent edges if for any vk → vl ∈ DP [vi → vj], we have: vl → vk /∈ DP [vr → vt].

Deﬁnition 27 (Consistent set) Consider a PCCG G = (V, E) with set of nodes V and
−→
E in structure E is a consistent set if
set of edges E. We say that the set of directed edges
each pair of directed edges in this set are consistent.

For a DAG G with the set of edges E, any set of E′ ⊆

−→
E is a consistent set on a
graph with structure E, where there is no v-structure in G. This is because applying Meek
function M14 on E′ ⊔ E does not make any conﬂict in edges orientation.

Now, we will use the deﬁnition of edge consistency to validate the domain knowledge
of the expert. Consider a graph that consists of a combination of directed and undirected
edges. The following theorem presents two conditions to check whether these directed edges
are subset or equal to edges in a directed acyclic graph or not.

Theorem 28 Consider a PCCG G = (V, E) with set of nodes V and set of edges E. There
−→
E′ and E = E′
exists a DAG G′ = (V′, E′) which is in the MEC of graph G, such that
if and only if:

−→
E ⊆

• There is no directed cycle in E.

• E is a consistent set.

We can utilize Theorem 28 to validate the domain knowledge of the expert. To do so,
we check whether any pair of directed edges in E are consistent from the DP table. For
detecting a directed cycle, we can execute DFS algorithm from all vertices on a graph that
is extracted from G by removing its undirected edges.

21

5. Experiments

In this section, we provide some experiments for various application of COL problems based
on our results in previous sections. We propose diﬀerent algorithms in each subsection in
the following. We utilize DP table in designing almost all of these algorithms. Hence,
we call the class of the proposed algorithms “Causal Orientation Learning with Dynamic
programming (COLD)”. In our experiments, we deﬁne the edge density as the ratio of edges
to the maximum number of possible edges in a graph of size n, i.e., n(n − 1)/2. Moreover,
we deﬁne the average degree as the ratio of edges to the number of the nodes.

In all experiments, we generated chordal graphs by the method which has been presented
in Markenzon et al. (2008). For each point in all ﬁgures, we averaged over 100 instances of
the chordal graphs, otherwise we explicitly mention it. Our generated graphs are based on
the similar networks given in bnlearn5. The codes for proposed methods in this part are
available in https://github.com/raminsafaeian/COLD.

5.1 Recovering Essential Graphs

One of the well-known methods for obtaining the essential graph from the observational data
is PC algorithm (Spirtes et al., 2000). This algorithm has three main steps: (1) performing
conditional independence tests between random variables in order to construct skeleton (2)
identifying v-structures from separation sets (3) discovering more edges’ orientations by
applying Meek rules on graph including v-structures. According to Theorem 9, for further
recovering edges’ orientations, it suﬃces to apply Meek rules 1, 2 and 3 in third step of PC
algorithm. In the following we propose a method to accelerate obtaining essential graph.

Similar to our previous DP table construction in Algorithm 1, and considering Property
2 in Lemma 13, we propose DPO method for the case that there exist v-structures in the
graph. We show how one entry of DPO table is ﬁlled in Algorithm 3. The main diﬀerence
between this algorithm and what we proposed in Algorithm 1 is that the Meek function M4
is removed and v-structures orientations are considered for further recovering other edges’
orientations. Using DPO table enables us to accelerate Meek function M1 which in turn
will accelerate execution time of getting the essential graph from the MPDAG.

Consider an MPDAG G = (V, E) with set of nodes V and set of edges E. We propose
Algorithm 4 for discovering further edges’ orientations in order to obtain the essential graph.
Based on Property 1 in Lemma 13, we apply Meek function M3 once, in the beginning of
algorithm in Line 7. In Lines 8-14, we repetitively orient further edges by applying Meek
functions M1 and M2. Applying Meek function M1 is based on our DPO table in Lines
9-12. We call this algorithm “COLD (Essential)”.

We compared the execution time of our proposed COLD algorithm with the conventional
method for the third step of PC algorithm. Conventional method is the one that we apply
Meek rules in no particular order to orient further edges, until no more edge can be oriented.
In order to have a fair comparison, we implemented a function for the applying Meek
rules similar to the one in Kalisch et al. (2012) library in python and considered it as
the conventional method. For generating MPDAGs, we ﬁrst constructed random chordal
graphs. Then, we use lexicographic BFS or LexBFS (Rose, 1970) to consider an ordering

5. https://www.bnlearn.com/

22

on the vertices and obtain a DAG. Then, we remove one of the edges such that at least one
v-structure be created. Then, we will get the MPDAG from this generated DAG.

Algorithm 3 Computation of M1({vs → vd} ⊔ E) using dynamic programming method,
considering v-structures.

1: Input: G = (V, E), a MPDAG
2: Output: Oriented edges as a result of applying function M1 on {vs → vd} ⊔ E which

is in DP O[vs → vd]

3: Ev ← set of v-structure sub-graphs in E
4: function OrientOneEdge(DP O, vs, vd, Ev)
5:
6:

DP O[vs → vd] ← {vs → vd}
for vj ∈ neigh(vd)\neigh(vs) do

7:

8:

9:

10:

if vj → vd /∈ Ev then

if DP O[vd → vj] = N U LL then

DP O ← OrientOneEdge(DP O, vd, vj, Ev)
DP O[vs → vd] ← DP O[vs → vd] ⊔ DP O[vd → vj]

11: Return DP O

Algorithm 4 COLD (Essential)

1: Input: MPDAG graph G = (V, E)
2: Output: Essential graph of G
3: Fill all DP O entries with N U LL value
4: function Essential(G)
5:

Ev ← set of v-structure sub-graphs in E
Eo ← E
Et = M3(E)
while |

−→
E t| > 0 do

for vs → vd ∈

−→
E t do

if DP O[vs → vd] = N U LL then

DP O ← OrientOneEdge(DP O, vs, vd, Ev)

Eo = Eo ⊔ DP O[vs → vd]
−→
E o

Et = M2(Eo)\

6:

7:

8:

9:

10:

11:

12:

13:

end

14:
15: Return G = (V, Eo)

Figure 4(a) shows the execution time of COLD (Essential) and conventional method
versus number of edges for graphs with 3000 nodes. As can be seen, the COLD (Essential) is
outperform the conventional method by a factor up to 20788. For instance, for a graph with
3000 nodes and 4000 edges, the execution time of COLD (Essential) is about 0.0335 seconds,
while the execution time of conventional method is about 696.4 seconds. Comparison of
these two methods for graphs with ﬁxed average degree, 2.2, versus number of graph nodes
is depicted in 4(b). Again, the proposed algorithm has much lower execution time with

23

)
c
e
s
(

e
m
T

i

103

102

101

100

10-1

10-2

10-3

COLD (Essential)
Conventional (Kalisch)

4000

6000

8000

10000

Number of Edges

(a)

)
c
e
s
(

e
m
T

i

104

103

102

101

100

10-1

10-2

10-3

COLD (Essential)
Conventional (Kalisch)

1000 2000 3000 4000 5000 6000
Number of Nodes
(b)

Figure 4: (a): Comparison between execution times of COLD (Essential) and conventional
method, given a MPDAG, versus the number of edge for graphs with 3000 number of nodes
(b): Comparison between execution times of COLD (Essential) and conventional method
versus the number of nodes for graphs with average degree of 2.2.

respect to the conventional method. For instance, for graphs of size 6000, the speed up
ratio is about 24910, where the execution times of COLD (Essential) and conventional
method are 0.0994 and 2476 seconds, respectively.

5.2 Accelerating MEC Size Computation

The size of a MEC is the number of DAGs it contains. Main approach in previous work is
to partition existing DAGs in an MEC in order to count them. Total number of DAGs can
be computed by summation over the number of DAGs in each partition. There are diﬀerent
methods for such a partitioning. For instance, He et al. (2015) performed partitioning of
DAGs in an MEC based on their roots6. Additionally, they proposed some closed-form
formula to compute number of DAGs in an MEC when there is a speciﬁc relation between
number of edges and number of nodes in the graph. They extended their work by considering
some special structure “core graphs” in He and Yu (2016) to eﬃciently count the number of
DAGs in an MEC. Ghassami et al. (2019) proposed to partition the MEC based on its clique
tree representation. Additionally, they have proposed a dynamic programming method to
store the computed size of each sub-graph to avoid multiple calculation of its size. Similar
to Ghassami et al. (2019), Talvitie and Koivisto (2019) proposed a dynamic programming
method for MEC size calculation. Recently, Teshnizi et al. (2020) proposed to compute

6. A node is deﬁned as a root when all the edges are outgoing from this node toward its neighbors.

24

 
 
the MEC size by partitioning DAGs in MEC by all possible orientations for edges that are
connected to a node.

We can take advantage of Meek functions properties to accelerate any previous method
that uses Meek rules as a subroutine. Herein, as an example, we will accelerate MEC size
computation method proposed by He et al. (2015). In this method, given a UCCG G, its
size can be computed as follows:

Size(G) =

Size(Ci),

v∈V
X

YCi∈C(Gv)

where Size(G) is the size of MEC corresponding to G and Gv is a graph as a result of
setting node v as a root in graph G. We utilize our proposed Meek function properties,
such as Proposition 18 and Theorem 21, and also dynamic programming method proposed
by Ghassami et al. (2019) to accelerate UCCG size calculation. We present our proposed
algorithm for counting number of DAGs in an MEC as “COLD (MECSize)”, in Algorithm
5.

In Algorithm 5, Lines 7-11 is based on what have been proposed in He et al. (2015).
In these lines, we check whether the UCCG satisﬁes a speciﬁc relation between number of
nodes and edges. We can determine the MEC size of these graphs merely from number of
nodes. If we cannot calculate MEC size based on these lines, we execute Lines 12-13 to
know whether we have already computed the MEC size for this UCCG or not. If that is
the case, we will use the stored value in the memory. Otherwise, we execute Lines 14-17 for
MEC size computation. In Line 15, we obtain the edges that can be oriented as a result of
considering a node v to be a root. In Line 16, we remove these directed edges from the graph
and extract the chain components of the remaining graph. For each chain component, the
size function will be called in Line 17. Finally, in Line 18, we store the computed size in
memory for using in the next calls.

We compared COLD (MECSize) algorithm with the previous state of the art algorithm,
LazyCount (Teshnizi et al., 2020) and a former work MemoMAMO (Talvitie and Koivisto,
2019). The size of graphs in this experiment is equal to 30. As can be seen in Figure 5, our
proposed algorithm performs better than the others for a wide range of number of edges.
Moreover, performance of LazyCount degrades by decreasing the number of edges. While
performance of MemoMAMO degrades by increasing the number of edges. For instance, for
graphs with 350 edges, the speed up ratios with respect to MemoMAMO and LazyCount
are 2.88 and 1.83, respectively.

5.3 Acceleration of Experiment Design in Active Learning Setting

In active learning setting, we determine the nodes for next interventions after observing the
results of previous interventions. Some previous work tried to use gathered data from pre-
vious interventions to design next intervention set based on a Bayesian method (Ness et al.,
2017; Greenewald et al., 2019; Agrawal et al., 2019). For instance, Greenewald et al. (2019)
proposed a method to search for a node that has the maximum posterior probability
to be a root variable. This method is mainly suitable for graphs with tree structures.
Some other work assumed that inﬁnite samples are available after performing intervention
(Hauser and Buhlmann, 2014; He and Geng, 2008; Kocaoglu et al., 2017; Shanmugam et al.,

25

Algorithm 5 COLD (MECSize) Algorithm

1: Input: UCCG G = (V, E)
2: Output: |M EC(G)|
3: SizeDP is a storage indexed with set of nodes T and is initialized by NULL for each

T ⊆ V

4: function Count(G = (V, E))
5:

p ← |V|
switch |E| do

6:

7:

8:
9:

10:

11:

12:

13:

14:

15:

16:

17:

18:

19:

case p − 1 return p;
case p return 2p;
case p(p − 1)/2 − 2 return (p2 − p − 4)(p − 3)!;
case p(p − 1)/2 − 1 return 2(p − 1)! − (p − 2)!;
case p(p − 1)/2 return p!;

if V is in SizeDP then
return SizeDP [V]

for each v in V do

vo∈neigh(v) DP [v → vo]

Er =
G′ ← G = (V, E\Er)
Sv =

F

Ci∈C(G′) Count(Ci)
v∈V Sv

SizeDP [V] =
Q
return SizeDP [V]

P

2015; Ghassami et al., 2018). Therefore, the edges’ orientations incident to the intervened
variable can be exactly determined.

In the case of inﬁnite samples, previous works have considered diﬀerent objective func-
tions for the problem of experiment design. He and Geng (2008) proposed to select can-
didate intervention nodes based on mutual information criterion. Another approach that
has been proposed by this work is to select a node with maximum number of neighbors.
Hauser and Buhlmann (2014) considered an objective function to select a node for inter-
vention that results in orienting maximum number of edges in the worst case scenario after
the intervention. More speciﬁcally, for a given UCCG G = (V, E), the following objective
function is considered:

v⋆ ∈ argmax

v∈V

min
I⊆Ck,Ck∈C(v)

M124

S ⊔ E

,

(cid:12)
(cid:12)

(cid:0)

(cid:1)(cid:12)
(cid:12)

where S = {vi → v|vi ∈ I} ⊔ {v → vo|vo ∈ neigh(v)\I}. We call this objective function,
“MinMax” function. In MinMax function, for every node in the graph, the minimum number
of oriented edges, in the worst case, will be computed when we intend to perform an interven-
tion on that node. The possible edges’ orientation after intervention will be partitioned by
considering diﬀerent ingoing edges toward the target node (Hauser and Buhlmann, 2014).
We know that the ingoing edges must be a subset of a maximal clique. Thus, we search over
all possible ingoing edges sets like I in every maximal clique Ck. For each of these orienta-
tions, we apply Meek function M124 to discover further edges’ orientations. As mentioned
earlier, using Meek function properties, we can accelerate any function that needs Meek

26

COLD (MECSize)
LazyCount
MemoMAMO

103

102

101

100

10-1

10-2

)
c
e
s
(

e
m
T

i

10-3

50

100

150
250
200
Number of edges

300

350

Figure 5: Running times of COLD (MECSize), LazyCount, and MemoMAMO for graphs
with 30 number of nodes.

rules to be applied. In the following, we show that using our proposed method for comput-
ing Meek function results, we can accelerate the process of optimizing MinMax objective
function.

We compared our proposed algorithm, which we call “COLD (MinMax)”, with LazyIter
(Teshnizi et al., 2020) method, which is the state of art in solving MinMax problem. COLD
(MinMax) uses DP tables and utilizes Theorem 21 to apply Meek rules, rather than applying
conventional Meek rules. The execution times for these two methods are given in Figure 6.
The curves are the average of execution times over 100 generated chordal graphs. Figure
6(a) shows that the execution time of ﬁnding the best node versus number of edges for
graphs with 1000 number of nodes. Figure 6(b) shows the execution time of ﬁnding the
best node versus number of node for graphs graphs with 1.1 average degree.

As can be seen in Figure 6, the execution time of our proposed algorithm is considerably
less than the one for LazyIter Algorithm. As expected, we gain by avoiding from applying
the enormous number of Meek rules using DP table.

5.4 Quality of the Proposed Lower Bound

In this section, we investigate the quality of our proposed lower bound with respect to
number of edges that can be oriented in the worst case scenario for each node. We evaluated
the lower bound in two cases: 1- The edge density is ﬁxed and we increase the number of
nodes, 2- The number of nodes is ﬁxed and we increase the number of edges. We provide the
summary of these simulation results for these two cases in Table 2 and 3, respectively. Note

27

 
104

103

102

)
c
e
s
(

e
m
T

i

101

1500

COLD (MinMax)
LazyIter

COLD (MinMax)
LazyIter

104

103

)
c
e
s
(

e
m
T

i

102

101

100

2000

2500
Number of edges

3000

(a)

3500

10-1

1000

2000

3000

4000

5000

6000

Number of nodes
(b)

Figure 6: (a): Comparison between execution times of COLD (MinMax) and LazyIter
(Teshnizi et al., 2020) versus number of edges for graphs with 1000 number of nodes (b):
Comparison between execution times of COLD (MinMax) and LazyIter (Teshnizi et al.,
2020) versus number of nodes for graphs with 1.1 average degree.

that for ﬁnding the minimum number of oriented edges in the worst case, we enumerated
all consistent DAGs.

|V| Edge density Exact % Norm. avg. worst case Mean gap Avg. Time (Sec)
0.0029
20
0.0088
30
0.0159
40
0.0213
50
0.0228
60

0.9915
0.9827
0.9722
0.9708
0.9627

0.0080
0.0444
0.1596
0.4981
1.2824

0.0245
0.1190
0.2843
0.5328
0.8143

0.4
0.4
0.4
0.4
0.4

Table 2: Lower bound comparison with the true value for diﬀerent number of oriented edges
with ﬁxed edge density

In these tables, the “exact %” column shows in how many cases, our proposed lower
In “norm avg worst case” column, we considered the
bound is equal to the true value.
maximum diﬀerence between the true value and the proposed lower bound over all nodes
for each graph, and then averaged over all graphs and divided it by the number of existed
edges for that setting. In “mean gap” column, we computed the average diﬀerence between
the true value and the lower bound for each node in all graphs. The last column shows the
average execution time for computing the lower bounds for all nodes in each graph.

28

 
 
|V| Edge density Exact % Norm. avg. worst case Mean gap Avg. Time (Sec)
0.0002
40
0.0071
40
0.0120
40
0.0159
40
0.0157
40
0.0129
40
0.0104
40

0.0064
0.0319
0.0843
0.1596
0.2605
0.3654
0.4671

0.0004
0.0563
0.1549
0.2843
0.3555
0.4136
0.4338

0.9996
0.9854
0.9779
0.9722
0.9762
0.9781
0.9825

0.1
0.2
0.3
0.4
0.5
0.6
0.7

Table 3: Lower bound comparison with the true value for diﬀerent edge density with ﬁxed
number of nodes

The results in Table 2 and 3 show that in almost all cases, the lower bound is exactly
equal to the true value. Moreover, in other few cases, the gap between the lower bound and
the true value is negligible.

5.5 Intervention Design Based on the Lower Bound Criterion

In this part, we propose a new objective function to ﬁnd the best node for intervention. This
function reduces the computational complexity while preserving the number of interventions
in order to fully identify the whole causal structure. Our objective function is deﬁned as
the following:

v⋆ ∈ argmax

v∈V

L(v),

where the L(v) is the lower bound on number of oriented edges after intervention on node v.
Based on the above objective function we select a node for intervention that has maximum
lower bound with respect to the other nodes.

In the previous part, we evaluated the quality of our proposed lower bound. The reason
for using lower bound instead of the true value is that lower bound is a good estimator of
it while saving the computation time. We compared our heuristic algorithm based on our
lower bound which we call it “COLD (LB)” with the one that we proposed in Section 5.3,
i.e., COLD (MinMax).

The result of comparison between two algorithms COLD (MinMax) and COLD (LB) is
shown in Figure 7. We see that COLD (LB) is considerably faster than COLD (MinMax) in
both cases of increasing number of nodes (Figure 7(a)) or increasing number of edges (Figure
7(c)). We plot the average number of interventions that is needed for full identiﬁcation in
Figure 7(b) and 7(d). We can see that in both of these plots, the average number of
interventions for full identiﬁcation is the same for both algorithms.

In this part, we evaluate our algorithm for the ﬁnite-sample case. Here, our main
goal is to demonstrate how one can use the inﬁnite sample based algorithms in the ﬁnite
sample case. Thus, we just compared our algorithm with two baselines: 1- “Random Naive”
algorithm, which always selects a random node for the next intervention from the set of all
nodes, and 2- “Random Chordal” algorithm, which selects a random node from set of nodes

29

103

102

101

100

10-1

10-2

)
c
e
s
(

e
m
T

i

10-3

20

)
c
e
s
(

e
m
T

i

103

102

101

100

10-1

10-2

10-3

COLD (LB.)
COLD (MinMax)

40

30
Number of nodes
(a)

50

COLD (LB.)
COLD (MinMax)

19

17

15

13

11

9

7

s
n
o

i
t

n
e
v
r
e

t

n

I

f

o
r
e
b
m
u
N

5
20

s
n
o
i
t
n
e
v
r
e
t
n
I

f
o

r
e
b
m
u
N

16

15

14

13

12

11

10

9

8

100

200

300
Number of edges

400

COLD (LB.)
COLD (MinMax)

30
Number of nodes

40

50

(b)

COLD (LB.)
COLD (MinMax)

100

200

300
Number of edges

400

(c)

(d)

Figure 7: Comparison between COLD (LB) and COLD (MinMax) (a): execution time
(b): Average number of
versus number of nodes for graphs with edge density of 0.35.
interventions for full identiﬁcation versus number of nodes for graphs with edge density of
0.35. (c): execution times versus number of edges for graphs with 40 nodes. (d): Average
number of interventions that is needed for full identiﬁcation versus number of edges for
graphs with 40 nodes.

that those nodes have at least one connected undirected edge in the obtained I-essential
graph after each intervention.

30

 
 
 
 
 
 
300 Samples

625 Samples

1250 Samples

0.65

0.55

0.45

0.35

0.25

COLD (LB)
Random Chordal
Random Naive

0.65

0.55

0.45

0.35

0.25

1

2

3

4

1

2

3

4

1

2

3

4

2500 Samples

5000 Samples

10000 Samples

0.65

0.55

0.45

0.35

0.25

0.65

0.55

0.45

0.35

0.25

0.65

0.55

0.45

0.35

0.25

0.65

0.55

0.45

0.35

0.25

D
H
S
e
g
a
r
e
v
A

1

2

3

4

1

2

3

4

1

2

3

4

Number of Interventions

Figure 8: Average SHD values of COLD (LB), Random chordal, and Random Naive versus
number of interventions for graphs with 25 nodes and 35 edges.

We considered 3000 randomly generated linear Gaussian causal model for graph with
25 nodes and 35 edges. All edges coeﬃcients were sampled uniformly from [−1.5, −0.5] ∪
[0.5, 1.5] and error variances were uniformly sampled from [0.01, .2]. We consider a budget
of at most four interventions. We compared our proposed COLD (LB) algorithm, with Ran-
dom Naive and Random Chordal algorithms for the number of samples 300, 625, 1250, 2500,
5000, 10000. Figure 8 shows the result of these simulations. We use the structural hamming
distance (SHD), which is deﬁned in Brown et al. (2005), for comparing the identiﬁcation
rate for each of these algorithms. We divided the SHD value of each graph in each step of
intervention by number of edges and averaged over all instances. Note that limited number
of samples may cause to converge to a wrong DAG. In this stage, Random Chordal and
COLD (LB) algorithms stop intervening on nodes. Thus, their SHD will remain unchanged
after a number of interventions. In order to compare these algorithms with Random Naive
algorithm, which has not any stopping rule, we consider the average SHD value in the last
intervention before getting a DAG as the SHD value for the following steps of interven-
tions. Although, the number of interventions in Random Naive algorithm is more than the
ones in the other two algorithms, simulation results show that our COLD (LB) Algorithm
outperforms baselines even in the small number of samples.

31

 
5.6 Practical Trick

In this part, we add a practical trick to enhance the acceleration of some of the applications
In applications such as MinMax problem or
that have been discussed in this section.
obtaining the lower bound in previous part, we can stop the computation as early as we
know that the selected node cannot be the desired solution. We call this “early stopping
trick”. For example, suppose we have executed the lower bound algorithm on a part of
nodes in the graph and obtain that the maximum lower bound among these nodes. We
select another node such v to compute its corresponding lower bound. If in the process
of computing some LC, we ﬁnd that the lower bound of the node v is less than what we
have already obtained, we immediately terminate the process of this node and we do not
consider it as our desired solution.

)
c
e
s
(

e
m
T

i

103

102

101

100

10-1

10-2

10-3

COLD (MinMaxPT)
COLD (MinMax)
LazyIter

COLD (MinMaxPT)
COLD (MinMax)
LazyIter

103

102

101

100

10-1

10-2

)
c
e
s
(

e
m
T

i

100

200

300
Number of edges

(a)

400

10-3

20

30

40

50

Number of nodes
(b)

Figure 9: (a): Comparison between execution times of COLD (MinMaxPT), COLD (Min-
Max) and LazyIter (Teshnizi et al., 2020) versus number of edges for graphs with 40 nodes
(b): Comparison between execution times of COLD (MinMaxPT), COLD (MinMax) and
LazyIter (Teshnizi et al., 2020) versus number of nodes for graphs with edges density of
0.35.

In order to evaluate the gain we can get from this trick, we utilize it in selecting a
target intervention by considering MinMax objective function in the active learning setting.
We call the proposed algorithm using this trick “COLD (MinMaxPT)”. Here, we compare
this method with COLD (MinMax) that has been proposed previously in this section. The
execution times of these two algorithms are shown in Figure 9. In both cases, i.e., increasing
number of edges with ﬁxed number of nodes (Figure 9(a)) or increasing number of nodes
with ﬁxed edge density (Figure 9(b)), using practical trick improves the computation time
for solving MinMax problem.

32

 
 
6. Conclusion

In this paper, we focused on the COL problem which may appear in many causal discovery
tasks. Traditionally, Meek rules can be applied in order to solve a COL problem. Here, we
presented a mathematical representation of these rules with Meek functions. Based on this
representation, we provided some desirable properties for these functions. These properties
enable us to simplify or accelerate solving COL problems. For example, we utilized these
properties to accelerate diﬀerent causal discovery problems such as solving experiment de-
sign problems where we need to apply Meek rules multiple times. Additionally, we took
advantage of these properties to obtain a tight lower bound on number of oriented edges
for a target intervention in a causal graph. To the best of our knowledge, this is the ﬁrst
lower bound on number of oriented edges for a target intervention. Furthermore, we used
these rules to check whether the prior knowledge acquired from an expert in orienting some
undirected edges in causal graph is compatible with already oriented edges or not. We pro-
posed a heuristic algorithm that solves experiment design problem in active setting based
on lower bound which reduce the execution time signiﬁcantly.

As an interesting future research direction, one can use Meek properties to obtain an
upper bound for number of oriented edges after performing intervention. Furthermore,
designing algorithms based on these Meek properties is another possible research direction
for experiment design in passive setting.

33

Appendices

Proof Sketch.

Lemma 12 provides Meek function properties on PCCGs. We prove this lemma by showing
each property of that in Sections E, F, G, and H. Lemma 20 is related to applying Meek
functions M14 on PCCGs and it is proved by using Lemma 12. According to Lemma 12 and
Lemma 16, which is about Meek function properties on ICCGs, Theorem 17 is proved. This
theorem asserts that Meek functions M124 can be decomposed to union of applying Meek
functions M14 and M2. Using Theorem 17 and Lemma 20, we prove the Theorem 21 which
introduces a method to obtain I-essential graph. Based on the below sketch, we derive the
proof of Lemma 22, lower bound for a maximal clique, by using a few lemmas and theorems
depicted in the following ﬁgure. Finally, the proof of Theorem 24, lower bound for a case
of node, is using Theorem 21 and Lemma 22.

Lemma 12(E, F, G, H)

Lemma 16(J)

Proposition 18(M)

Theorem 17(L)

Lemma 20(O)

Lemma 32(Q)

Theorem 21(P)

Lemma 22(Q)

Theorem 24(R)

34

A. Proof of Theorem 4

Corresponding sub-graphs for Meek rule 1, 2 and 3 are as the same of their corresponding
candidate sub-graphs. Thus, based on the Meek (1995), applying these rules on their
corresponding candidate sub-graphs are sound. We use the the following lemma to prove
the soundness of applying Meek rule 4 on its corresponding candidate sub-graph.

Lemma 29 The result of applying Meek rule 1 and then Meek rule 4 on corresponding can-
didate sub-graph for Meek rule 4 is the same as of applying Meek rule 4 on its corresponding
sub-graph.

Proof As dashed lines in Table 1 cannot be part of a v-structure, the edge vk
vl in corre-
sponding sub-graph of Meek rule 4 can be either directed as vk → vl or undirected as vk
vl
vl, this
in its corresponding candidate sub-graph in Table 1. In the case of having vk
edge will be oriented as vk → vl by applying Meek rule 1 on sub-graph {vj → vk, vk
vl}.
Thus, after applying Meek rule 1 on the corresponding candidate sub-graph for Meek rule
4, we get the corresponding sub-graph for Meek rule 4. Therefore, the proof is complete.

Based on the Lemma 29, applying Meek rule 1 and 4 on corresponding candidate sub-
graph for Meek rule 4 is as the same as the applying Meek rule 4 on corresponding sub-graph
for Meek rule 4. As applying Meek rules are sound (Meek, 1995), applying Meek rule 4 on
corresponding candidate sub-graph will be sound.

B. Proof of Theorem 9

Applying Meek rules 1, 2 and 3 on a MPDAG is complete (Meek, 1995). Additionally,
corresponding sub-graphs for Meek rule 1, 2 and 3 are as the same of their corresponding
candidate sub-graphs. Therefore, applying Meek functions 1, 2 and 3 on a MPDAG is
complete.

C. Proof of Theorem 10

Applying Meek rules on a MPDAG, with some further oriented edges is complete (Meek,
1995). Additionally, corresponding sub-graphs for Meek rule 1, 2 and 3 are as the same of
their corresponding candidate sub-graphs. Moreover, based on the Lemma 29, the result of
applying Meek function M4 on set of edges is equal or subset of the results of repeatedly
applying Meek rule 1 and Meek rule 4 on that set. Therefore, applying Meek functions 1,
2, 3 and 4 on a graph is complete.

D. Proof of Property 1 in Lemma 13

According to Spirtes et al. (2000), having skeleton and the discovered v-structures, applying
Meek function M123 is enough for discovering further edges’ orientations to obtain the
essential graph. Moreover, with the inﬁnite samples from observational data, there will be
no undiscovered v-structure sub-graph in the identiﬁed graph. As there is no undiscovered
v-structure sub-graph, no new v-structure will be discovered by identifying more edges’
orientations rather than those that exist in essential graph. Hence, it suﬃces to apply Meek
function M3 once before applying other Meek functions.

35

E. Proof of Property 1 in Lemma 12

As G is a PCCG, no v-structure sub-graph exists in G. This is because all v-structures
in causal DAG are discovered in the procedure of obtaining essential graph and removed.
Considering the fact that there is a v-structure in candidate sub-graph for Meek rule 3, we
cannot ﬁnd any candidate sub-graph for Meek rule 3 in E. Thus, applying Meek function
M3 on graph G can not discover any further edges’ orientations.

F. Proof of property 2 in Lemma 12

Given a PCCG G = (V, E) with set of nodes V and set of edges E, we will show the
following holds:

Mi(E) =

Mi({vi → vj} ⊔ E),

−→E

Gvi→vj∈

where Mi is one of the Meek functions M1, M4 or M14. We can write Mi as follows:

Mi(E) = Mi 

Mi({vi → vj} ⊔ E)

= Mi 

Eij

,

−→E

Gvi→vj ∈







−→E

Gvi→vj∈







F

vi→vj ∈

where Eij = Mi({vi → vj} ⊔ E). We will show that the right hand side of above equation
is equal to E′ =
−→E Eij. By contradiction, suppose that there are some edges which
are not in E′ but they will be oriented by applying Meek function Mi on E′. Therefore,
there would be at least some edge like vt → vr which is in a candidate sub-graph, having
directed edges in E′. Moreover, it has been oriented by applying Meek function Mi on
this candidate sub-graph. Note that there should be such an edge like vt → vr, otherwise
E′ = Mi(E′). Now, assume that the edge vt → vr has been oriented by applying Meek
vr}, such
function Mi on a candidate sub-graph for Meek rule 1, like {vm → vt, vt
that we have vm → vt ∈ Eqw for some vq → vw ∈
. However, the
edge vt
vr has been oriented by applying Meek function M1 on vq → vw, and we have
vt → vr ∈ E′, which is a contradiction. Similar to proof of candidate sub-graph for Meek
rule 1, we can prove this for candidate sub-graph for Meek rule 4, and the proof is complete.

vi → vj|vi → vj ∈

−→
E

o

n

G. Candidate sub-graphs for Meek rule 2 can not be genetated as a reult of
applying Meek function M14

Lemma 30 Let G = (V, E) be a PCCG, V be the set of nodes and E be the set of edges.
There exist some candidate sub-graphs for Meek rule 2 in G and no new candidate sub-graph
for this rule is generated after applying Meek functions M14 on E.

We prove this lemma by contradiction. A candidate sub-graph for Meek rule 2 is depicted
in Figure 10. We assume that one of the directed edges in the candidate sub-graph for Meek
rule 2 is already oriented and the other one will be oriented by one of the Meek functions
M1 or M4. All possible scenarios have been depicted in Table 4. Note that in PCCGs,
sub-graphs are chordal and there exist no v-structure before or after applying any Meek

36

Table 4: Diﬀerent cases in Lemma 30 for orienting one edge in order to make a candidate
sub-graph for Meek rule 2

Case 1

E′ = {vq → vi} ⊔ E
vi → vj ∈ M1(E′)

Case 2

E′ = {vq → vj} ⊔ E
vj → vk ∈ M1(E′)

vq ∈ neigh(vk)

vk

vq /∈ neigh(vk)

vk

vq ∈ neigh(vi)

vk

vk

vq

vj
vq

vj

vj

vi

vi

vi

vi

vq

contradiction on vj → vk
vk → vj ∈ M4(E′)

vi → vk ∈ M1(E′)

vi → vk ∈ M4(E′)

vq /∈ neigh(vi)

vj

vq

contradiction on vi → vj
vj → vi ∈ M1(E′)

vq /∈ neigh(vk)

Case 3

E′ = {vw → vq} ⊔ E
vi → vj ∈ M4(E′)
vi → vj /∈ M1(E′)

vq ∈ neigh(vk)
vw /∈ neigh(vk)

vq ∈ neigh(vk)
vw ∈ neigh(vk)

vq /∈ neigh(vi)

Case 4

E′ = {vw → vq} ⊔ E
vj → vk ∈ M4(E′)
vj → vk /∈ M1(E′)

vq ∈ neigh(vi)
vw /∈ neigh(vi)

vq ∈ neigh(vi)
vw ∈ neigh(vi)

37

vk

vi

vj

vq vw

vk

vi

vj

vq vw

vk

vi

vi → vk ∈ M4(E′)

vi → vk ∈ M4(E′)

vj

vq vw

contradiction on vj → vk
vk → vj ∈ M4(E′)

vi

vi

vi

vk

vk

vk

vj

vj

vj

vq

vw

vq

vw

vq

vw

contradiction on vi → vj
vj → vi ∈ M4(E′)

contradiction on vi → vj
vj → vi ∈ M4(E′)

vi → vk ∈ M4(E′)

vk

vi

vj

Figure 10: Meek candidate sub-graph for Meek rule 2

functions. We will see that two types of contradictions will be encountered in all of these
cases. In some cases, there will be a conﬂict in direction of recently oriented edges with
the already directed edges in the candidate sub-graph. In some other cases, we see that an
undirected edge in candidate sub-graph will be oriented and there is no need to apply Meek
function M2. Hence, for both of these cases, there will be no candidate sub-graph for Meek
rule 2. In the following, we will study each of these cases in Table 4.

In depicted graphs in Table 4, we use diﬀerent colors to distinguish diﬀerent types of
oriented edges. In all of these graphs, black oriented edges are the edges in Meek function
M2 candidate sub-graph. The red oriented edge is the one that will be oriented as a result
of applying Meek function M2. The green oriented edge is supposed to be the edge that
applying Meek functions M1 or M4 on that, results in orienting one further edge in order
to construct Meek candidate sub-graph for function M2. The blue oriented edges are the
result of applying Meek function M1, M4 or M14 on green oriented edge in each graph.
Note that the blue edges are a part of edges that can be oriented based on green edges and
knowing their orientations is enough to prove the properties in the lemma.

In the ﬁrst case, we investigate the scenario that the edge vi → vj has been oriented
as a result of applying Meek function M1 on an existing edge vq → vi. As vi → vj ∈
M1({vq → vi} ⊔ E), we know vq /∈ neigh(vj ). Thus, two diﬀerent cases vq /∈ neigh(vk) and
vq ∈ neigh(vk) can be considered. In the case of vq ∈ neigh(vk), the edge vk
vj will
be oriented in opposite direction of vj → vk, which is a contradiction. In the second case,
vq /∈ neigh(vk), the edge vi → vk will be oriented as a result of applying Meek function M1.
Hence, in both cases, no candidate sub-graph for Meek rule 2 will be created.

In the second case, we consider the scenario that the edge vj → vk has been oriented as a
result of applying Meek function M1 on an existing edge vq → vj. As vj → vk ∈ M1({vq →
vj} ⊔ E), we know vq /∈ neigh(vk). Two diﬀerent cases can be considered: vq /∈ neigh(vi)
and vq ∈ neigh(vi). In the case of vq ∈ neigh(vi), the edge vi → vk will be oriented as a
result of applying Meek function M4({vq → vj} ⊔ E). In the other case, vq /∈ neigh(vi),
vj will be oriented in opposite direction of vi → vj, which is a contradiction.
the edge vi
Therefore, no candidate sub-graph for Meek rule 2 will be created.

In the third case, we assume that the edge vi → vj has been oriented as a result
of applying Meek function M4 on a set {vw → vq} ⊔ E, and we also know that vi →
vj /∈ M1({vw → vq} ⊔ E) (see Table 4). As vi → vj ∈ M4({vw → vq} ⊔ E), we know
vw /∈ neigh(vj ). We partition the possible skeletons in three cases: (A) vq /∈ neigh(vk), (B)
vq ∈ neigh(vk), and vw /∈ neigh(vk) (C) vq ∈ neigh(vk) and vw ∈ neigh(vk). In case A, we
know vq → vj ∈ M4({vw → vq} ⊔ E), and therefore, we have vi → vk ∈ M4({vq → vj} ⊔ E).

38

In case B, we have vi → vk ∈ M4({vw → vq} ⊔ E). In case C, the edge vj
oriented in opposite direction of vj → vk, which is a contradiction.

vk will be

In the fourth case, we assume that the edge vj → vk has been oriented as a result of
applying M4 on a set {vw → vq} ⊔ E, and also we know vj → vk /∈ M1({vw → vq} ⊔ E).
As vj → vk ∈ M4({vw → vq} ⊔ E), we know vw /∈ neigh(vk). We partition the possible
skeletons for the mentioned scenario in three cases: (A) vq /∈ neigh(vi), (B) vq ∈ neigh(vi),
and vw /∈ neigh(vi) (C) vq ∈ neigh(vi) and vw ∈ neigh(vi). In case A, we know vq → vk ∈
M4({vw → vq} ⊔ E), and therefore, we have vj → vi ∈ M4({vq → vk} ⊔ E), which is a
contradiction. In case B, we have vj → vi ∈ M4({vw → vq} ⊔ E), which is a contradiction.
In the case C, we have vi → vk ∈ M4({vw → vq} ⊔ E). Therefore, there is no candidate
sub-graph for Meek rule 2 in all of possible scenarios. Thus, the proof is complete.

H. Proof of Property 3 in Lemma 12

We write Meek function M124(E) as follows:

M124(E) = M124(M14(M2(E))) = M124(E′) = E′ ⊔ EN ,

−→
where E′ = M14(M2(E)). Note that
E ⊆ M14(M2(E)). It suﬃces to show EN is an empty
set. We prove this by contradiction. Suppose S ⊆ E′ is a candidate sub-graph for Meek
rule 1, 2 or 4 and Mi is one of the Meek functions M1, M2 or M4. Assume that there exists
an edge en ∈ EN such that en /∈ E′. We have:

M124(S ⊔ E′\S) = M124(S ⊔ (E′\S) ⊔ {en}),

where edge en has been oriented in the result of applying one of the Meek functions M1, M2
or M4 on candidate sub-graph S. In the case of en ∈ M1(E′) and en ∈ M4(E′), we will have
en ∈ E′ which is a contradiction. In the case of en ∈ M2(E′), we know that S * M2(E).
This is because it is not possible to have a candidate sub-graph of Meek rule 2 on the result
of Meek function M2. Furthermore, we know from the Lemma 30 that candidate sub-graph
for Meek rule 2 cannot be generated as a result of applying Meek function M14. Hence, we
will have S * E′ which is a contradiction.

I. Proof of Property 4 in Lemma 12

We want to show that for any subset S = {vi → vk, vk → vj, vi

vj} ⊆ E, we have:

M14(M2(S) ⊔ E\S) = M14(E) ⊔ M2(S).

Equivalently, we want to show that:

vi → vk
vk → vj
vi → vj

M14 







⊔ E










vi → vk
vk → vj
vi
vj

vi → vk
vk → vj
vi
vj








= M14 

= M14 



39

vi → vk
vk → vj
vi → vj

⊔






⊔ {vi → vj} .






(2)

(3)

⊔ E

⊔ E


















−→
E exist in the set of edges as a result of
The last equation holds because the edges in
applying any Meek function. Furthermore, according to Property 2 in Lemma 12, for any
e1 ∈

−→
E , we have:

M14(E) =

M14({e} ⊔ E)

−→E
Ge∈

= 

M14({e} ⊔ E)

⊔ M14({e1} ⊔ E)

−→E \{e1}

Ge∈




= M14(E ⊔

−→
E \{e1}) ⊔ M14({e1} ⊔ E),




where the third equality is due to Property 2 in Lemma 12. Based on above equation, we
can decompose the left side of (2) as follows:

vi → vk
vk → vj
vi → vj




⊔ E




M14 



It suﬃces to show that:



= M14 











vi → vk
vk → vj
vj
vi

⊔ E










⊔ M14 







vk
vi
vk
vj
vi → vj

⊔ E

.










vk
vi
vj
vk
vi → vj




⊔ E



\{vi → vj} ⊆ M14 




vi → vk
vk → vj
vj
vi







⊔ E





M14 











In order to show this relation, we depict all possible skeletons, containing sub-graph {vi →
vk, vk → vj, vi → vj}, for further edges’ orientations in Table 5. Note that in PCCGs,
sub-graphs are chordal and there exist no v-structure before or after applying any Meek
functions. We intend to determine all additional edges that can be oriented as a result
of applying Meek function M14 on E ⊔ {vi → vj}. Hence, if this function can orient any
further edges, then there should be a node vq ∈ neigh(vj ), and also, an edge vj
vq in all
possible skeletons. This edge will be oriented as a result of applying Meek function M14 on
E ⊔ {vi → vj}. In the following, we will investigate each case in Table 5, and we will show
that the above equation holds.



In case 1, the edge vj → vq has been oriented as a result of applying Meek function M1
on E ⊔ {vi → vj}. This edge will also be oriented as a result of applying Meek function M1
on set E ⊔ {vk → vj}. Hence, there is no new information in applying Meek function M14
on set E ⊔ {vi → vj}.

In the case 2, the edges vj → vq and vk → vq have been oriented as a result of applying

Meek function M4 on E ⊔ {vi → vj}. We have {vj → vq, vk → vq} ⊆ M4(E ⊔ {vi → vk}).

In the case 3, the edges vj → vq and vw → vq have been oriented as a result of applying
Meek function M4 on E ⊔ {vi → vj}. We have vi → vw ∈ M4(E ⊔ {vk → vj}) and
{vj → vq, vw → vq} ⊆ M4(E ⊔ {vi → vw}).

In the case 4, the edges vj → vq and vw → vq have been oriented as a result of applying

Meek function M4 on E ⊔ {vi → vj}. We have {vj → vq, vw → vq} ⊆ M4(E ⊔ {vk → vj}).

40

Table 5: Applying Meek function M14 on candidate sub-graph for Meek rule 2

Case 1

Case 2

Case 3

Case 4

vq /∈ neigh(vi)

vq /∈ neigh(vk)

vq /∈ neigh(vk)
vq

vq ∈ neigh(vk)

vw /∈ neigh(vk)
vq
vw

vw ∈ neigh(vk)
vq
vw

vj

vi

vj

vi

vj

vi

vj

vi

vk

vq

vk

vk

vk

Case 5

Case 6

vq ∈ neigh(vk)

vw /∈ neigh(vk)

vw

vq

vj

vk

vi

vq

vw ∈ neigh(vk)

vw

vi

vj

vk

In the case 5, the edge vw → vq has been oriented as a result of applying Meek function
M4 on E ⊔ {vi → vj}.
In the other hand, this edge has been oriented in the opposite
direction, i.e., vq → vw as a result of applying Meek function M4 on E ⊔ {vk → vj}, which
is a contradiction.

In the case 6, the edges vw → vq, vj → vq and vk → vq have been oriented as a result of
applying Meek function M4 on E⊔{vi → vj}. Herein, for the set of nodes T = {vi, vk, vj, vq},
we have {vk → vq, vj → vq} ⊆ M4(E[T] ⊔ {vi → vk}). Additionally, for the set of nodes
T = {vi, vk, vw, vq}, we have {vw → vq, vk → vq} ⊆ M4(E[T] ⊔ {vi → vk}).

J. Proof of Lemma 16

We know S = {vi → v|vi ∈ I} ⊔ {v → vo|vo ∈ O} where S ⊆ E,
I ∪ O. We want to show that:

−→
S =

−→
E and neigh(v) =

M2(E) =





Ci∈CM2 (v)
G

M2(Ci)



⊔ E.



It suﬃces to show that orienting new edges as a result of applying Meek function M2 on
set of edges E does not make any new candidate sub-graph for Meek rule 2, more than
those that exist in set E[N eigh(v)] before applying Meek function M2. We will show that
no new candidate sub-graph for Meek rule 2 will be generated neither in E[N eigh(v)] nor
in an candidate sub-graph, having at least one edge outside E[N eigh(v)].

For the ﬁrst case, Figure 11 shows the only possible skeleton for making new candi-
date sub-graph for Meek rule 2 in E[N eigh(v)]. Note that all the edges incident with v
have already been oriented. As a result, in order to have a new candidate sub-graph in

41

E[N eigh(v)] it should be a triangle with three nodes like {vs, vd, vj} which are in neighbor
of v. In Figure 11(a), assume the red arrow edge, i.e., {vd → vs} is oriented as a result of
vs}. Now, we
applying Meek function M2 on candidate sub-graph {vd → v, v → vs, vd
show that the triangle {vs, vd, vj} cannot form a new candidate sub-graph for Meek rule
2. There exist two options for the orientation of edge v
vj. In Figure 11(b), we orient
this edge as v → vj. As a result of applying Meek function M2 on candidate sub-graph
vj will be oriented as vd → vj. Thus, no new
vj}, the edge vd
{vd → v, v → vj, vd
vj as vj → v, shown in
candidate sub-graph is made. In the case of orienting the edge v
Figure 11(c), we cannot obtain new candidate sub-graph for Meek rule 2. Hence, we can
imply that no new candidate sub-graph will be made within sub-graph E[N eigh(v)].

For the second case, we show that it is not possible to make a new candidate sub-graph,
containing at least one node not being in N eigh(v). First we show that it is not possible
to orient any edge which exactly one of its end-points is in neigh(v). By showing this, as
a result, no edges will be oriented outside the sub-graph E[N eigh(v)]. We prove this by
contradiction. For having a candidate sub-graph of this kind, the only possible scenario is to
vn}, such that we have {vm, vn} ⊆ neigh(v)
have a structure like {vt → vm, vm → vn, vt
vn} ⊆ E\E[N eigh(v)] and we intend
and vt ∈ V\N eigh(v). Thus, we have {vt
to orient the only undirected edge in this candidate sub-graph by applying Meek function
M2. Now, we study whether such directed edge vt → vm exists in our scenario. To orient
vt → vm, we need another candidate sub-graph of Meek rule 2, having two edges outside
E[N eigh(v)] (note that one of them is vt
vm). The other edge should have already
oriented by another candidate sub-graph for Meek rule 2 with the same property that it has
two edges outside E[N eigh(v)]. However, this continues relying on some other edges outside
E[N eigh(v)], while the number of edges of this type is ﬁnite, and it gives a contradiction.

vm, vt

vs

vd

v

(a)

vj

vs

vj

vs

vd

v

(b)

vj

vd

v

(c)

Figure 11: Possible orientations for making new candidate sub-graph for Meek rule 2

K. Proof of Property 2 in Lemma 13

The proof of Property 2 is exactly the same as the proof of Property 2 in Lemma 12 as
adding some forbidden edges does not aﬀect the proof. Note that we do not assume that
the graph is chordal or there is no v-structures for proving Property 2 in Lemma 12.

42

L. Proof of Theorem 17

From Property 3 of Lemma 12, we have:

Substituting M2(E) from Lemma 16 in the above equation, we have:

M124(E) = M14(M2(E))

M124(E) = M14 


Ci∈CM2 (v)
G

M2(Ci) ⊔ E

,





where the CM2(v) is set of all candidate sub-graphs for Meek rule 2 in E[N eigh(v)]. From
Property 4, we can infer that:

M14 

Thus, we can write:

Ci∈CM2 (v)
G

M2(Ci) ⊔ E





= M14(E) ⊔





Ci∈CM2 (v)
G

M2(Ci)



.



M124(E) = M14(E) ⊔

M2(Ci)



.



Ci∈CM2 (v)
G


Finally, plugging M14(E) from Property 2 of Lemma 12 into the above equation, we have:



M124(E) =





−→E
Ge∈

M14

{e} ⊔ E

(cid:0)

(cid:1)

⊔









Ci∈CM2 (v)
G

M2(Ci)



.



Therefore, the proof is complete.

M. Proof of Proposition 18

Consider a PCCG G = (V, E) with set of nodes V and set of edges E. Suppose that vs → vd
−→
E = {vs → vd}. By deﬁning T , N eigh(vd), we
is the only oriented edge in the set E, i.e.,
have:

M14

{vs → vd} ⊔ E

= M14

{vs → vd} ⊔ E′ ⊔ E

= EM14,

(cid:0)
where E′ = M14({vs → vd} ⊔ E[T])\{vs → vd}. From Property 2 of Lemma 12, we can
write:

(cid:1)

(cid:1)

(cid:0)

M14

{vs → vd} ⊔ E′ ⊔ E

= M14

E′ ⊔ E

⊔ M14

{vs → vd} ⊔ E

.

Furthermore, we have:

(cid:0)

(cid:1)

(cid:0)

(cid:1)

(cid:0)

(cid:1)

M14

{vs → vd} ⊔ E

\{vs → vd} = EM14\{vs → vd}

(cid:0)

M14
(cid:1)

E′ ⊔ E

= EM14\{vs → vd}.

(cid:1)

(cid:0)

43

Thus, we have:

M14

{vs → vd} ⊔ E

= M14

E′ ⊔ E

⊔ {vs → vd}.

(cid:0)
(cid:0)
Finally, we obtain from Property 2 in Lemma 12:

(cid:1)

(cid:1)

DP [vs → vd] = 




N. Proof of Theorem 19

−→
E′

Gvl→vk∈

DP [vl → vk]

{vs → vd} .

G




We know that calling function in Algorithm 1, may cause multiple another calls of this
function in a recursive manner. Here, we prove that calling this function with directed edge
vs → vd as input cannot occurred inside in calling another function with the same input as
vs → vd. We prove this by using the following lemma:

Lemma 31 Given a PCCG G = (V, E) with set of nodes V and set of edges E. For any
vs ∈ V and for any edge vr → vk ∈ M14(E ⊔ {vs → vd}), there exists a directed path from
vs to vr.

Proof We prove this statement by an induction on the number of steps taken by Meek
function M14. In the base case, if we apply Meek rule 1, then we orient some edge vd → vj.
Thus, there is the directed path vs → vd → vj from vs to vj. Moreover, if we apply Meek
rule 4 in the ﬁrst step, two edges like vd → vj and vk → vj will be oriented (see Table 1)
and there is the directed path vs → vd → vj from vs to vj. Now, for the induction step,
assume that induction hypothesis holds up to step r, i.e., for any oriented edge like vi → vr
from Meek function M1, there is a directed path from vs to vr. Suppose that in step r+1,
a new edge like vr → vk is oriented by applying Meek rule 1 on some edge vi → vr. Since
we know that there is a directed path from vs to vr, the same holds from vs to vk. In the
case that new edge is oriented by applying Meek function M4 on some previous oriented
edge like vi → vr, it can be easily seen that (see Table 1), there would be a directed edge
from vr to the head vertex of the newly oriented edge. Based on the induction hypothesis
we can infer that there is a directed path from vs to head vertex of the new oriented edge
and the proof is complete.

Based on Lemma 31, we will get a directed cycle if such a mentioned recursive call is
happened. In this scenario, we will have a directed path from node vs to itself. As the
underlying graph is a causal DAG, that cannot be happened. Thus, we have not multiple
function calls with the same input. Additionally, as we have stored the resulted oriented
edges after applying Meek rules on that edge, we did not call that edge again. Therefore,
we call this function for each edge once. For ﬁlling all entries of DP table, we must call
this function 2|E| times. Moreover, we have a nested for-loop in each call which takes
O(∆2) operations. Hence, in total, the computational complexity would be in the order of
O(|E|∆2).

44

O. Proof of Lemma 20

We know S = {vi → v|vi ∈ I} ⊔ {v → vo|vo ∈ O} ⊆ E. From Property 2 of Lemma 12, we
have:

M14(E) =

M14

{vi → v} ⊔ E

M14

{v → vo} ⊔ E

.




(cid:1)

We deﬁne set of nodes Oc as {vo|vo ∈ O, I ⊆ neigh(vo)}. Hence, we rewrite the above
equation as the following:

vo∈O
G

vi∈I
G

G



!

(cid:0)

(cid:0)

(cid:1)

M14(E) =





vi∈I
G

M14

{vi → v} ⊔ E

(cid:0)





(cid:1)

M14

{v → vo} ⊔ E

G

vo∈Oc
G

(cid:0)

!

(cid:1)

For each node vo ∈ O\Oc, there exists a node vk ∈ I such that vk /∈ neigh(vo), thus we
have v → vo ∈ M14({vk → v} ⊔ E). Therefore, we have the following relation:

G

Gvo∈O\Oc





M14

{v → vo} ⊔ E

.



(cid:0)

(cid:1)



M14

{v → vo} ⊔ E

⊆ M14

{vk → v} ⊔ E

⊆

M14

{vi → v} ⊔ E

.

(cid:0)
Thus, we have:

(cid:1)

(cid:0)

vi∈I
G

(cid:1)

(cid:0)

(cid:1)

M14

{v → vo} ⊔ E

⊆

M14

{vi → v} ⊔ E

.

Gvo∈O\Oc

(cid:0)

vi∈I
G

(cid:1)

(cid:0)

(cid:1)

Hence, we can write:

M14(E) =

=

=



vi∈I
G


Gvl→vk∈S′

M14

{vi → v} ⊔ E



(cid:0)
M14

(cid:1)


{vl → vk} ⊔ E

(cid:0)

DP [vl → vk],

(cid:1)

M14

{v → vo} ⊔ E

G

vo∈Oc
G

(cid:0)

!

(cid:1)

Gvl→vk∈S′

where S′ = {vi → v|vi ∈ I} ⊔ {v → vo|vo ∈ O, I ⊆ neigh(vo)}.

P. Proof of Theorem 21

Having S = {vi → v|vi ∈ I} ⊔ {v → vo|vo ∈ O} and

−→
S =

−→
E , from Theorem 17, we have:

M124(E) =

M14({e} ⊔ E)





−→E
Ge∈



⊔





Ci∈CM2 (v)
G

M2(Ci)



.





45

 
 
 
Substituting the ﬁrst term with its equivalent term in Lemma 20, we have:

M124(E) =



DP [vl → vk]





M2(Ci)



,

Gvl→vk∈S′



Ci∈CM2 (v)
G

G







where S′ = {vi → v|vi ∈ I} ⊔ {v → vo|vo ∈ Oc} and Oc = {vo|vo ∈ O, I ⊆ neigh(vo)}. By
deﬁning Ineigh(vo) = {vi|vi ∈ I ∩ neigh(vo)}, we have the following equation:

M2(Ci) =

vi → vo|vi ∈ Ineigh(vo), vo ∈ Oc

vi → vo|vi ∈ Ineigh(vo), vo ∈ O\Oc

.

Ci∈CM2 (v)
G

(cid:8)

(cid:9) G (cid:8)

(cid:9)

From the deﬁnition of Oc, we know that for each vo ∈ Oc, we have I ⊆ neigh(vo). Hence,
for each vo ∈ Oc, we have Ineigh(vo) = I. Thus, for the ﬁrst term in the above equation, we
have:

vi → vo|vi ∈ Ineigh(vo), vo ∈ Oc

= {vi → vo|vi ∈ I, vo ∈ Oc} .

Therefore, it suﬃces to show that:

(cid:8)

(cid:9)

vi → vo|vi ∈ Ineigh(vo), vo ∈ O\Oc

⊆

DP [vl → vk]

(cid:8)

Gvl→vk∈S′

(cid:9)

Having vi ∈ Ineigh(vo) and vo ∈ O\Oc, for each edge vi
I\Ineigh(vo), and a sub-graph E[{vi, vo, vt, v}] = {vt → v, v → vo, vi → v, vt
the graph. Thus, we will have:

vo ∈ E, there exists a node vt ∈
vo} in

vi, vi

Furthermore, we have {vt → v} ⊂ S′. Thus, we can write:

vi → vo ∈ DP [vt → v].

{vi → vo} ⊆ DP [vt → v] ⊆

DP [vl → vk].

Gvl→vk∈S′

Hence, we can conclude that:

M124(E) =

DP [vl → vk]

(vi → vo|vi ∈ I, vo ∈ Oc)

Gvl→vk∈S′
where S′ = {vi → v|vi ∈ I} ⊔ {v → vo|vo ∈ O, I ⊆ neigh(vo)}.

G











Q. Proof of Lemma 22

−→
E = S = {vi → v|vi ∈
We denote the obtained ICCGs with G = (V, E). We know that
I} ⊔ {v → vo|vo ∈ O} in which I ⊆ Ck. We divide the problem of calculating the lower
bound into two cases.
In the ﬁrst case, all the edges are from nodes in maximal clique
toward the intervened node, v, i.e., I = Ck. In the second case, we consider that there
is an edge from a node in maximal clique toward node v and also, there is an edge from
intervened node v toward a node in maximal clique, i.e., I ⊂ Ck.

46

We use Theorem 21 for calculating number of oriented edges in the ﬁrst case. We have
I = Ck. Thus, we know Oc = ∅ and S = {vi → v|vi ∈ Ck}. Hence, in this case, number of
oriented edges after applying Meek function M124, |M124(E)|, is equal to the following:

|M124(E)| = LI =

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
Now, we will investigate the second case. For sake of simplicity, ﬁrst, we assume that the set
(cid:12)
of nodes that have edges from nodes in maximal clique Ck to intervened node v is known.
Then, we calculate the minimum number of oriented edges for any possible orientation of
edges between maximal clique Ck and intervened node v. After intervention, we have:

vi∈I
G

DP [vi → v]
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

.

M124(E) =M124 






vi∈I
G

{vi → v}



G







Gvo∈neigh(v)\I

{v → vo} ⊔ E









Using Theorem 17, we decompose Meek function M124 to Meek functions M2 and M14:

M124(E) =M14 

M2 






vi∈I
G

{vi → v}



G







Gvo∈neigh(v)\I





{vi → v}



G







Gvo∈neigh(v)\I

vi∈I
G

{v → vo} ⊔ E





{v → vo} ⊔ E





G




.





Based on Property 2 in Lemma 12, we extract mixed edge union from inside of Meek
function M14:

vi∈I
G

M124(E) =




M2 


M14({vi → v} ⊔ E)



G







Gvo∈neigh(v)\I

M14({v → vo} ⊔ E)



G







vi∈I
G

{vi → v}



G







Gvo∈neigh(v)\I

{v → vo} ⊔ E



.







We know that I ⊆ Ck, therefore we have:

neigh(v)\I = neigh(v)\Ck ∪ Ck\I.

Thus, we can write:

M14({v → vo} ⊔ E) =

Gvo∈neigh(v)\I





Gvo∈neigh(v)\Ck

47

M14({v → vo} ⊔ E)



G







Gvo∈Ck\I

M14({v → vo} ⊔ E)



.



Substituting M14 function with the DP value in Proposition 18, we will have:

M14({v → vo} ⊔ E) =

Gvo∈neigh(v)\I
In the other hand, we have:





Gvo∈neigh(v)\Ck

DP [v → vo]



G







M14({vi → v} ⊔ E) =

DP [vi → v].

vi∈I
G

vi∈I
G

Therefore, we can write:

Gvo∈Ck\I

DP [v → vo]

.





M124(E) =



DP [v → vo]



Gvo∈neigh(v)\Ck




M2 

According to Lemma 16, we can write:

DP [vi → v]

vi∈I
G

G

















Gvo∈Ck\I

DP [{v → vo}]





G

G

vi∈I
G

{vi → v}



G







Gvo∈neigh(v)\I

{v → vo} ⊔ E



.







M2 






vi∈I
G

{vi → v}





{v → vo} ⊔ E



=



Gvo∈neigh(v)\I

G





{vi → vo|vi ∈ I, vo ∈ Ck\I} ⊔ {vi → vo|vi ∈ I, vo ∈ neigh(v) ∩ neigh(vi)\Ck} .





Therefore, we can obtain the result of applying Meek function M124 on set E with the
following equation:

M124(E) = T1 ⊔ T2 ⊔ T3 ⊔ T4.

where,

T1 =

DP [v → vo],

Gvo∈neigh(v)\Ck

T2 = {vi → vo|vi ∈ I, vo ∈ Ck\I} ,

DP [vi → v]

{vi → vo|vi ∈ I, vo ∈ neigh(v) ∩ neigh(vi)\Ck}

vi∈I
G

G

\T1,





T3 =

T4 =







DP [v → vo]



\T1.

Gvo∈Ck\I





Now, our goal is to calculate |M124(E)|. To do so, we want to prove that the intersection of
any two sets selected from the sets T1, T2, T3, T4 is empty. In order to show this, we ﬁrst
state the following Lemma 32.

48

Lemma 32 Consider a UCCG G = (V, E) with set of nodes V and set of edges E. Suppose
that there exists a maximal clique Ck in the neighborhood of node v. The following relations
hold:

• For any v1
• For any v1

vo]\{v → vo}.

• For any {v1

v2 ∈ E[Ck] and vi ∈ Ck, we have v1 → v2 /∈ DP [vi → v].

v2 ∈ E[N eigh(v)] and vo ∈ neigh(v), we have v1 → v2 /∈ DP [v →

v2, v3

v4} ⊆ {v

vt|vt ∈ Ck}, we have v1 → v2 /∈ DP [v3 → v4].

Proof It can be shown that there exist a DAG in the Markov equivalence class of graph G,
such that this DAG consists of some edges that are oriented from nodes in a clique in the
neighborhood of node v to this node (see Proposition 6 in Hauser and Buhlmann (2014)).
We call such orientations in which there exist a DAG in the MEC as valid orientations.
Based on this fact, we prove the relations by contradiction. For proving the ﬁrst relation,
assume that we have v1 → v2 ∈ DP [vi → v]. Thus, according to Lemma 31, there exists a
directed path from node v to node v2. As v2 and vi are in the maximal clique Ck, we can
have valid orientations of v2 → v and vi → v without making a new v-structure. Hence,
there would be a directed cycle v → · · · → v2 → v which is a contradiction. Therefore,
there exists no DAG and we can imply that: v1 → v2 /∈ DP [vi → v].

In order to show the second relation, suppose that we have v1 → v2 ∈ DP [v → vo].
We partition the problem in three cases: v2 = v, v2 = vo and v2 ∈ neigh(v)\vo. In the
ﬁrst case, according to Lemma 31, there will be a directed path v → vo... → v which is a
directed cycle. In the second case, according to Lemma 31, there will be a directed path
vo → ... → v1 → vo which is a directed cycle. In the third case, having the valid orientations
v2 → v and v → vo, we have a directed path v → vo... → v2 → v which is a directed cycle
and there exists no DAG. This is a contradiction.

For proving the third relation, assume we have v1 → v2 ∈ DP [v3 → v4]. This means
that orienting the edge v3 → v4 orients the edge v1 → v2, and we cannot have a DAG
including directed edges v3 → v4 and v2 → v1. However, according to Proposition 6 in
Hauser and Buhlmann (2014), such orientations are valid orientations and there exists a
DAG, including those directed edges. Thus, this is a contradiction and the proof is com-
plete.

According to Lemma 32, we will show that intersection of sets T1, T2, T3, T4 is empty.
Hence, the number of elements in M124(E), i.e., |M124(E)|, can be computed by adding the
number of elements in each of the sets T1, T2, T3, T4.

First, it can be seen that T2 ⊆ E[Ck]. Furthermore, based on the second relation in
Lemma 32, we cannot ﬁnd any edge v1 → v2 ∈ T1 for nodes v1, v2 ∈ Ck. Therefore, we
have T1 ∩ E[Ck] = ∅. Additionally, we already removed all T1 elements from the sets T3
and T4. Thus, we can write:

T1 ∩ (T2 ⊔ T3 ⊔ T4) = ∅.

In the following we prove that T3 ∩ E[Ck] = ∅ and T4 ∩ E[Ck] = ∅. Based on the second
relation in Lemma 32, we cannot ﬁnd any edge v1 → v2 ∈ T4 for set of nodes v1, v2 ∈ Ck.

49

Moreover, we can deﬁne the following two sets T1

3 and T2

3 such that T3 = T1

3 ⊔ T2
3:

DP [vi → v]



\T1,

T1

3 =

T2

3 =





vi∈I
G

{vi → vo|vi ∈ I, vo ∈ neigh(v) ∩ neigh(vi)\Ck}

\T1.



(cid:16)G

(cid:17)

We know that T
relation in Lemma 32, we cannot ﬁnd any edge v1 → v2 ∈ T1
we have T3 ∩ E[Ck] = ∅ and we can write:

1
2
3 ∩ E[Ck] = ∅. Again based on the ﬁrst
3 ∩ E[Ck] = ∅. It suﬃces to show T
3 for nodes v1, v2 ∈ Ck. Hence,

T2 ∩ (T3 ⊔ T4) = ∅.

Finally, we will show that: T3 ∩ T4 = ∅. To do so, we prove the following two relations:

T3 ⊆ E[N eigh(v)]\{v
T4 ⊆ {v

vo|vo ∈ Ck\I} ⊔ E\E[N eigh(v)].

vo|vo ∈ Ck\I},

(4)

(5)

2
For proving the relation (5), consider set T3. We know T
3 ⊆ E[N eigh(v)]\{v
vo|vo ∈
1
Ck\I}. Thus, it suﬃces to show: T
vo|vo ∈ Ck\I}. Based on
3 ⊆ E[N eigh(v)]\{v
Proposition 18, in the ﬁrst step of DP calculation for each edge vi → v, we orient the edges
inside the sub-graph E[N eigh(v)]. The edges that are in DP [vi → v] and E[N eigh(v)], can
be categorized into two types. In the ﬁrst type, at least one of the endpoint of the edge is v.
According to third relation in Lemma 32, for these edges like v → v2, we cannot orient edges
v2 for any v2 ∈ Ck. Thus, we conclude that: M14({v → v2} ⊔ E) ⊆ T1. For the second
v
type of the edges, none of the endpoints of edges is the node v. For this type of edges like
v1 → v2, we cannot have {v1, v2} ⊆ Ck due to the ﬁrst relation in Lemma 32. Furthermore,
we cannot have v2 ∈ Ck. Since if we have v2 ∈ Ck, then v1 6∈ Ck. Moreover, based on
Proposition 6 in Hauser and Buhlmann (2014), by considering the valid orientation v2 → v,
we will have a cycle as {v → v1, v1 → v2, v2 → v}. Additionally, for each edge of this type
there is always an edge v → v2, where v2 ∈ neigh(v)\Ck. Therefore, it suﬃces to show
that, E1\E1[N eigh(v)] ⊆ M14({v → v2} ⊔ E), where E1 = M14({v1 → v2} ⊔ E). We depict
all possible skeletons in Table 6. Note that we consider the cases in which applying Meek
function orients edges outside the sub-graph E[N eigh(v)]. Therefore, in all of these cases
v3 /∈ neigh(v). Additionally, in all of these cases, the red edges are the ones that have been
oriented as a result of applying Meek function M14 on v1 → v2, and as can be seen, these
edges are also oriented as a result of applying Meek functions M14 on v → v2. Based on the
Proposition 18, for discovering more edges’ orientation outside the sub-graph E[N eigh(v)],
we must compute DP function in the sub-graph E[N eigh(v3)] ,where only red edges are
oriented. Thus, as we depict all possible cases, we conclude that every edges that will be
oriented outside the sub-graph E[N eigh(v)] as a result of M14({v1 → v2} ⊔ E) is also in
M14({v → v2} ⊔ E) ⊆ T1. Thus, we have T3 ⊆ E[N eigh(v)]. In addition, based on the

50

Table 6: Diﬀerent orientations for applying Meek function on vi → v

Case 1
vi

Case 2
vi

Case 3
vi

v1

v

v1

v

v1

v4

v2

v4

v2

v

v2

v3

v3

v3

third relation in Lemma 32, no edge that is between node v and clique Ck will be oriented
in T1

3. Thus, we can write:

T3 ⊆ E[N eigh(v)]\{v

vo|vo ∈ Ck\I}

For relation (6), based on Lemma 32, the result of applying Meek function M14 on set
{v → vo}∪E cannot orient any edge inside the sub-graph E[N eigh(v)]\{v → vo}. According
to these two relations, we can write:

To wrap up, the following equation holds:

T3 ∩ T4 = ∅.

T1 ∩ (T2 ⊔ T3 ⊔ T4) = ∅,
T2 ∩ (T3 ⊔ T4) = ∅,
T3 ∩ T4 = ∅.

Hence, we will have:

|M124(E)| = |T1| + |T2| + |T3| + |T4|.

Now, we can exactly compute the number of oriented edges after applying Meek function
M124 on set E. We can compute T1 from the DP table. T2 can also be obtained easily.
Now, we want to ﬁnd the minimum value for the size of sets T3 and T4. First, we consider
the set T3. Recall that the deﬁnitions of Pj and Qj are:

Pj , min

|I|=j,I⊂Ck

Qj ,

min
|O|=j,O⊂Ck

DP [vi → v]

max
vi∈I (cid:12)

(cid:12)
(cid:12)
(cid:12)

|DP [v → vo]\T1|.
max
(cid:12)
vo∈O
(cid:12)

vo∈neigh(vi)∩neigh(v)\Ck
G

{vi → vo}





\T1(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

Now, it can be seen that:

DP [vi → v]

vo∈neigh(vi)∩neigh(v)\Ck
G

{vi → vo}





≤

\T1(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

{vi → vo|vi ∈ I, vo ∈ neigh(v) ∩ neigh(vi)\Ck}

DP [vi → v]

G

vi∈I
G

max
vi∈I (cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)

51





.

\T1(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

But the right hand side of the above inequality is |T3|. Hence, we can imply that

Pj ≤ |T3|. Similarly, we can show that Qj ≤ |T4|.

Finally, we will have:

|T1| = |R|,
|T2| = |I|(|Ck| − |I|),
|T3| ≥ Pj,
|T4| ≥ Qj.

Thus, when the set I is known, we will have:

|M124(E)| ≥ |R| + P|I| + Q(|Ck|−|I|) + |I|(|Ck| − |I|) + (|Ck| − 2).

Note that for obtaining P|I| and Q(|Ck|−|I|), we just consider two edges between the Ck and
v. Therefore, the last term is for those remaining |Ck| − 2 edges that are between clique
and node v and they will deﬁnitely be oriented after intervention. Note that, based on the
second and third relation, these edges have not been considered in computing Qj and Pj
values and also they have not been oriented in set R. If we consider all possible sets for set
I, where |I| = l, we will have:

|M124(E)| ≥ LC = |R| +

min
l={1,...,|Ck|−1}

Pl + Q|Ck|−l + |l|(|Ck| − |l|) + (|Ck| − 2).

Finally we can infer that:

R. Proof of Theorem 24

L(Ck, v) = min(LI , LC ).

After intervention on node v, we will discover orientations of edges in the neighborhood of
intervened node v. We denote the obtained ICCG by G′ = (V, E′). Additionally, we denote
set of nodes that have edges toward node v with I. Furthermore, we denote the set of all
maximal cliques in the neighborhood of node v by C(v). As edges that are orientated from
intervention do not generate a new v-structure in the graph, there exists a maximal clique
Ck ∈ C(v), such that I ⊆ Ck.

After intervention, two cases can be considered: (a) All edges are outgoing from node v
toward the nodes in the neighborhood of node v (b) At least there exists one edge from a
node in the neighborhood of node v to node v. In the ﬁrst case, i.e., I = ∅, using Theorem
21, the number of oriented edges after intervention is equal to the following equation:

|M124(E′)| =

Gvo∈neigh(v)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

.
DP [v → vo]
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

In the second case, i.e., I ⊆ Ck and |I| > 0, based on Lemma 22, the lower bound on

number of oriented edges can be written as follows:

52

|M124(E′)| ≥ min

Ck∈C(v)

L(Ck, v).

Hence, the lower bound on number of oriented edges after intervention on node v, L(v),

can be calculated as the following:

|M124(E′)| ≥ L(v) = min

S. Proof of Theorem 28

 (cid:12)
Gvo∈neigh(v)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

DP [v → vo]
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

, min
Ck∈C(v)

L(Ck, v)

!

.

We know the PCCG G consists of the combination of both directed and undirected edges.
For the “only if” part, we know that there is a causal DAG with the same skeleton as graph
G, including directed edges in E. We can imply that there is no cycle in E and all edges
in E are consistent. For the ”if” part, we know that there is no cycle in E and the set E
is consistent. We want to show that there will be a causal DAG with the same skeleton as
graph G, including directed edges in E.

To prove this, we will use an algorithm that constructs a DAG from our graph G, if the
mentioned constraints are satisﬁed. Algorithm 6 takes G as its input and returns a causal
DAG, including no v-structure if the constraints are satisﬁed. This algorithm guarantees
that generated DAG contains all directed edges in E and has the same skeleton as E and
it has no v-structure. In Line 5 in Algorithm 6, we apply Meek functions M124 on set E.
Through Lines 6-9, we orient undirected edges that are existed in set E.
In Line 7, we
select an arbitrary node, and in Line 8, we orient all undirected edges in the neighborhood
of this node as out-going edges. Thus, all the edges in the neighborhood of this node will
be oriented and we denote the set of these oriented edges by S. In Line 9, we obtain the
result of applying Meek functions M124 on set S ⊔ E. Also, we add the oriented edges to
the output DAG G.

Algorithm 6 Causal DAG Construction Algorithm

1: Input: PCCG G = (V, E)
2: Output: DAG G = (VG, EG)
3: function P DAG2DAG(G)
4:

VG ← V
EG ← M124(E)
−→
E G| do
while |E| 6= |

5:

6:

7:
8:

9:

v ← an arbitrary node from {vl|∃vk ∈ VG, vl
S ← {vi → v|vi → v ∈ EG} ⊔ {v → vo|v → vo ∈ EG or v
EG ← M124(EG ⊔ S)

vk ∈ EG}

vo ∈ EG}

10:

return G

Based on our assumptions, we know that PDAG G has no cycle. Additionally, the

following lemma expresses it has no v-structure.

53

Lemma 33 For any graph G = (V, E), there is no v-structure in E if E is a consistent
set.

Proof We prove this by contradiction. Suppose a v-structure like {vi → vj, vj ← vk}
exists in E. Thus, we have vj → vk ∈ DP [vi → vj]. This is a contradiction because E is a
consistent set.

It suﬃces to show no new cycle and no new v-structure will be generated during running
Algorithm 6. First, we will show that no v-structure will be appeared in the output graph
of Algorithm 6.

To do so, we will prove that orienting further edges, either by applying Meek function
M124 on set E or adding new directed edges such as those in the constructing set S in
Algorithm 6, does not generate any new v-structure. Before providing the proof, we state
the following lemma that helps in proving mentioned statement.

vs

vj

vd

vi

(c)

vs

vs

vd

(a)
vd

vi

(d)

vj

vs

vj

vs

vj

vj

vd

(b)
vd

vi

(e)

Figure 12: reverse orientation of edges oriented by applying function M1 or M4

Lemma 34 Consider a graph G = (V, E) with set of nodes V and set of edges E. If we
have vi → vj ∈ DP [vk → vl], we will have vl → vk ∈ DP [vj → vi].

Proof First, we prove that this lemma holds for candidate sub-graphs for Meek rule 1
and 4. Then, we extend this result for applying Meek function M14 on a general graph.
In Figure 12, the blue edges are oriented as the result of applying Meek function on black
edges. We depict the candidate sub-graph for Meek rule 1 in the Figure 12(a).
In this
graph, the directed edge vs → vd orients the edge vd → vj. According to Figure 12(b), if we
orient the edge vd → vj in reverse direction, i.e., vj → vd, the edge vs → vd will be oriented
in the reverse direction, i.e., vd → vs.

The candidate sub-graph for Meek rule 4 is depicted in Figure 12(c). In this sub-graph,
by applying Meek function M4, directed edge vs → vd will orient two edges vi → vj and
vd → vj. According to the graphs in Figure 12(d)(Figure 12(e)), if we orient the edge
vd → vj(vi → vj) in reverse direction, i.e., vj → vd(vj → vi), the edge vs → vd will be

54

oriented in the reverse direction, i.e., vd → vs. Hence, we proved that this lemma holds for
candidate sub-graphs of Meek function M1 and M4.

Based on the above observation, we will show the statement in the lemma holds in a
general graph. Assume we know vi → vj ∈ DP [vk → vl]. The edge vi → vj has been ori-
ented in a repetitive sequence of applying Meek function M1 and M4 in the corresponding
candidate sub-graphs. Based on the above results, we can reveres the sequence of applying
Meek functions on each candidate sub-graphs in order to orient the edge vl
vk as vl → vk,
and the proof is complete.

Based on the Lemma 33, if we show that the set of directed edges after execution of
Algorithm 6 is consistent, we can conclude no v-structure exists in the output DAG. To do
so, we prove following three facts: 1) The set of directed edges as a result of applying Meek
function M124 in Line 5 is consistent. 2) The set S is consistent with already directed edges.
3) The set M124(EG ⊔ S) is consistent.

1) We prove this by induction on the number of steps taken by applying Meek function
M124. For the base case, it is obvious that the edges in E are consistent. For the induction
step, suppose that the directed edges up to step r are consistent. We show that the directed
edges will be remained consistent after step r + 1. We prove this by contradiction. Assume
that we orient new edge vi → vj in step r + 1 by applying one of the Meek functions and
vk ∈ E we
there exists an already directed edge vr → vt, such that for some edges vl
have vl → vk ∈ DP [vi → vj], but vk → vl ∈ DP [vr → vt]. Two cases can be considered:

• In the ﬁrst case, we have: vi → vj ∈ M14(E). Thus, there exists an edge vq → vw
such that vi → vj ∈ DP [vq → vw] and as a result vl → vk ∈ DP [vq → vw]. This is a
contradiction, because we know the edges vq → vw and vr → vt are consistent.

• In this case, there exists a Meek rule 2 candidate sub-graph, such that we have:
It can be shown that if vl → vk ∈
vi → vj ∈ M2({vi → vm, vm → vj, vi
DP [vi → vj], we will have vl → vk ∈ DP [vi → vm] ⊔ DP [vm → vj] according
to Property 4 in Lemma 12. This is a contradiction, because the edges vi → vm,
vm → vj and vr → vt are consistent.

vj}).

2) In this case, we want to prove that the oriented edges in S are consistent with already
directed edges. We prove this by contradiction. Assume we orient the edge v
vj as v → vj
in the procedure of orienting edges in S and there exists an already directed edge vr → vt,
such that vl → vk ∈ DP [v → vj] and vk → vl ∈ DP [vr → vt]. Based on the Lemma 34, if
we have vl → vk ∈ DP [v → vj], we will have vj → v ∈ DP [vk → vl]. Having the relations
v should be already oriented as
vj → v ∈ DP [vk → vl] and vk → vl ∈ DP [vr → vt], vj
vj → v when we apply Meek function M124 in Line 5 and Line 9, which is a contradiction.
3) In part 2, we stated that the union of set S and set EG is consistent. Thus, based
on part 1, oriented edges as a result of applying Meek function M124 on EG ⊔ E is also
consistent. Therefore, the proof is complete.

Next, we will show that no cycle will be generated in the output graph EG during the
execution of Algorithm 6. In the following lemma, we ﬁrst prove that we do not have any
directed cycle in this graph if there is no directed cycle of length three.

55

Lemma 35 There is no directed cycle in a chordal graph if there exists no directed cycle
of length three in that chordal graph.

Proof Given a graph G = (V, E) with set of nodes V and set of edges E. Suppose there is
a directed cycle (v1, ..., vi, ..., vj , ..., v1) with length N in graph G. Without loss of generality,
we assume that there is a chord between nodes vi and vj. Thus, based on the direction of
edges between nodes vi and vj, we know one of the paths (v1, ..., vi, vj, ..., v1) or (vi, ..., vj , vi)
will be a directed cycle with length less than N . Thus, we can obtain a cycle with length
less than N from the original directed cycle. We can repeat this procedure until end up
with a directed cycle of size three. Hence we can conclude that a cycle of size three exists
in a choral graph with directed cycle.

We know there is no cycle of length 3 in the set E, and we will show that no such
cycle will be generated during the execution of Algorithm 6. To do so, we need to prove
three facts: 1) No cycle will be generated in Line 5. 2) No cycle will be generated during
constructing S in Line 8. 3) No cycle will be created as the result of applying M124 on
EG ⊔ S. We will prove them in the sequel.

Recall that the directed edges in EG remain consistent during execution of Algorithm 6.

We will use this statement in the following proofs.

1) We prove this by induction on the number of steps taken by applying Meek function
M124. For the base case, it is obvious that there is no cycle of length three in the set
E. For the induction step, suppose that there is no directed cycle of length three up to
step r. We show that no such a cycle will be generated in step r + 1. We show this
by contradiction. First, consider Meek function M2. Applying this function on a Meek
candidate sub-graph does not generate a cycle on that sub-graph. Therefore, we only
consider the case in which the oriented edge as the result of applying Meek function M2
in a candidate sub-graph makes cycle in another sub-graph. In that case we will have the
vl}. In such sub-graph,
following structure as {vi → vj, vj → vk, vk → vl, vl → vi, vj
we have vl → vk ∈ DP [vi → vj]. This means the mentioned orientations violates the
consistency, which is a contradiction.

The all sub-graphs that are able to make a new cycle after applying Meek function M1
or M4 are depicted in Table 7. We check each of these cases and show that none of them
can make a cycle. Case 1 and 2 belong to Meek function M1, and the remaining two cases
are for Meek function M4. Black edges are already oriented and the red edge is the one that
applying speciﬁc Meek function on that edge will orient green edges. We intend to check
whether the green edge makes a cycle or not. As the ﬁrst case violates the consistency,
it cannot be happened. In case 2, no cycle is generated. In case 3, similar to case 1, the
consistency is violated. Finally, no cycle will be generated in case 4.

2) In this case, we orient some edges connected to node v. Thus, for making a cycle C
by orienting some edges during the S construction, two case can be considered. In addition
of already directed edges, one (the ﬁrst case) or two (the second case) edges are oriented in
C in the procedure of S construction. The ﬁrst case cannot be occurred because it means
we have a Meek candidate sub-graph M2 while the Meek functions M124 in Line 5 or Line 9
has already been applied. In the second case, if both edges are oriented, they are out-going
edges and cannot make a cycle.

56

Table 7: Diﬀerent cases that make cycle after applying Meek function M1 or M4

Case 1

Case 2

Case 3

Case 4

Meek function M1
v1
v1

Meek function M4
v1
v1

v4

v2

v4

v2

v4

v2

v4

v2

v3

v3

v3

v3

3) In this part, we prove that the set of directed edges in the result of applying Meek
function M124 on S ⊔ EG cannot generate a cycle. To do so, we recall from part 1 that
applying Meek function M124 on a set with the consistent directed edges cannot make a
cycle. As we showed, the union of set S and set EG is consistent, no cycle exists in the
result of applying Meek function M124 on this set.

All in all, we proved that for any E as an input that is satisfying our assumptions, the
set of directed edges after each iteration of the algorithm are subset or equal of a causal
DAG in true MEC. As the number of edges are ﬁnite, the algorithm terminates and return
a causal DAG in true MEC and the proof is complete.

57

References

Raj Agrawal, Chandler Squires, Karren Yang, Karthikeyan Shanmugam, and Caroline Uh-
ler. Abcd-strategy: Budgeted experimental design for targeted causal structure discovery.
Proceedings of Machine Learning Research, 89, 2019.

Steen A. Andersson, David Madigan, and Michael D. Perlman. A characterization of markov

equivalence classes for acyclic digraphs. Annals of Statistics, 25(2):505–541, 1997.

Laura E. Brown, Ioannis Tsamardinos, and Constantin F. Aliferis. A comparison of novel
and state-of-the-art polynomial bayesian network learning algorithms. Proceedings of the
20th National Conference on Artiﬁcial Intelligence, page pp.739–745, 2005.

David Maxwell Chickering. A transformational characterization of equivalent bayesian-
network structures. Proceedings of Eleventh Conference on Uncertainty in Artiﬁcial in-
telligence, Montreal, QU, pages pages 87–98, 1995.

Frederick Eberhardt, Clark Glymour, and Richard Scheines. On the number of experiments
suﬃcient and in the worst case necessary to identify all causal relations among n variables.
Proceedings of the 21st Conference on Uncertainty in Artiﬁcial Intelligence (UAI), page
178–184, 2005.

Marco F Eigenmann, Preetam Nandy, and Marloes H Maathuis. Structure learning of linear
gaussian structural equation models with weak edges. arXiv preprint arXiv:1707.07560,
2017.

AmirEmad Ghassami, Saber Salehkaleybar, Negar Kiyavash, and Elias Bareinboim. Bud-
geted experiment design for causal structure learning. International Conference on Ma-
chine Learning, page 1724–1733, 2018.

AmirEmad Ghassami, Saber Salehkaleybar, Negar Kiyavash, and Kun Zhang. Counting
and sampling from markov equivalent dags using clique trees. Proceedings of the AAAI
Conference on Artiﬁcial Intelligence, 33:3664–3671, Jul 2019.

Kristjan Greenewald, Dmitriy Katz, Karthikeyan Shanmugam, Sara Magliacane, Murat
Kocaoglu, Enric Boix-Adsera, and Guy Bresler. Sample eﬃcient active learning of causal
trees. 33rd Conference on Neural Information Processing Systems (NeurIPS), 2019.

Alain Hauser and Peter Buhlmann. Characterization and greedy learning of interventional
markov equivalence classes of directed acyclic graphs. Journal of Machine Learning Re-
search, 13(1):2409–2464, August 2012.

Alain Hauser and Peter Buhlmann. Two optimal strategies for active learning of causal
models from interventional data. International Journal of Approximate Reasoning, 55(4):
926–939, Jun 2014.

Yangbo He and Zhi Geng. Active learning of causal networks with intervention experiments
and optimal designs. The Journal of Machine Learning Research, 9(Nov):2523–2547,
2008.

58

Yangbo He and Bin Yu. Formulas for counting the sizes of markov equivalence classes of

directed acyclic graphs. arXiv preprint arXiv:1610.07921, 2016.

Yangbo He, Jinzhu Jia, and Bin Yu. Counting and exploring sizes of markov equivalence
classes of directed acyclic graphs. The Journal of Machine Learning Research, 16(1):
2589–2609, 2015.

Patrik O Hoyer, Aapo Hyvarinen, Richard Scheines, Peter L Spirtes, Joseph Ramsey, Gus-
tavo Lacerda, and Shohei Shimizu. Causal discovery of linear acyclic models with arbi-
trary distributions. arXiv preprint arXiv:1206.3260, 2012.

Markus Kalisch, Martin Machler, Diego Colombo, Marloes H. Maathuis,

Peter B¨uhlmann.
package pcalg.
Journal of Statistical Software,
https://www.jstatsoft.org/article/view/v047i11.

inference using

Causal

and
graphical models with the R
URL

47(11):1–26,

2012.

Murat Kocaoglu, Alex Dimakis, and Sriram Vishwanath. Cost-optimal learning of causal

graphs. In International Conference on Machine Learning, 2017.

Marloes H. Maathuis, Markus Kalisch, and Peter Buhlmann.

Estimating high-
dimensional intervention eﬀects from observational data. The Annals of Statistics, page
37(6A):3133–3164, 2009.

Lilian Markenzon, Oswaldo Vernet, and Luiz Henrique Araujo. Two methods for the gen-

eration of chordal graphs. Ann. of Op. Res., 157(1):47–60, 2008.

Christopher Meek. Causal inference and causal explanation with background knowledge.
Proceedings of the Eleventh Conference on Uncertainty in Artiﬁcial Intelligence, page
403–410, 1995.

Robert O Ness, Karen Sachs, Parag Mallick, and Olga Vitek. A bayesian active learning
In International Conference on

experimental design for inferring signaling networks.
Research in Computational Molecular Biology, Springer, page 134–156, 2017.

Judea Pearl. Causality. Cambridge university press, 2009.

Jonas Peters, Dominik Janzing, and Bernhard Scholkopf. Elements of causal inference:

foundations and learning algorithms. MIT press, 2017.

Joseph Ramsey, Madelyn Glymour, Ruben Sanchez-Romero, and Clark Glymour. A mil-
lion variables and more: the fast greedy equivalence search algorithm for learning high-
dimensional graphical causal models, with an application to functional magnetic reso-
nance images.
International Journal of Data Science and Analytics, page pages 1–9,
2017.

Donald J. Rose. Triangulated graphs and the elimination process. J. Math. Anal. Appl.,

page 597–609, 1970.

Dominik Rothenhausler, Jan Ernest, and Peter Buhlmann. Causal inference in partially
linear structural equation models: identiﬁability and estimation. Ann. Stat. To appear,
2018.

59

Karthikeyan Shanmugam, Murat Kocaoglu, Alexandros, G. Dimakis, and Sriram Vish-
wanath. Learning causal graphs with small interventions. In Advances in Neural Infor-
mation Processing Systems, page 3195–3203, 2015.

Peter Spirtes, Clark Glymour, and Richard Scheines. Causation, prediction, and search.

MIT press, 2000.

Topi Talvitie and Mikko Koivisto. Counting and sampling markov equivalent directed
acyclic graphs. In The Thirty-Third AAAI Conference on Artiﬁcial Intelligence, 9(Nov):
7984–7991, 2019.

Ali Ahmadi Teshnizi, Saber Salehkaleybar, and Negar Kiyavash. Lazyiter: A fast algo-
rithm for counting markov equivalent dags and designing experiments. In International
Conference on Machine Learning, page 1663–1671, 2020.

Thomas Verma and Judea Pearl. An algorithm for deciding if a set of observed indepen-
dencies has a causal explanation. Uncertainty in Artiﬁcial Intelligence, pages 323–330,
1992.

Yuhao Wang, Liam Solus, Karren Yang, and Caroline Uhler. Permutation-based causal
inference algorithms with interventions. In Advances in Neural Information Processing
Systems, page 5822–5831, 2017.

60

