Induction of Subgoal Automata for Reinforcement Learning

Daniel Furelos-Blanco,1 Mark Law,1 Alessandra Russo,1 Krysia Broda,1 Anders Jonsson2
1Imperial College London, United Kingdom, 2Universitat Pompeu Fabra, Barcelona, Spain
{d.furelos-blanco18, mark.law09, a.russo, k.broda}@imperial.ac.uk, anders.jonsson@upf.edu

9
1
0
2

v
o
N
9
2

]

G
L
.
s
c
[

1
v
2
5
1
3
1
.
1
1
9
1
:
v
i
X
r
a

Abstract

In this work we present ISA, a novel approach for learning
and exploiting subgoals in reinforcement learning (RL). Our
method relies on inducing an automaton whose transitions are
subgoals expressed as propositional formulas over a set of ob-
servable events. A state-of-the-art inductive logic program-
ming system is used to learn the automaton from observation
traces perceived by the RL agent. The reinforcement learning
and automaton learning processes are interleaved: a new re-
ﬁned automaton is learned whenever the RL agent generates
a trace not recognized by the current automaton. We evalu-
ate ISA in several gridworld problems and show that it per-
forms similarly to a method for which automata are given in
advance. We also show that the learned automata can be ex-
ploited to speed up convergence through reward shaping and
transfer learning across multiple tasks. Finally, we analyze
the running time and the number of traces that ISA needs to
learn an automata, and the impact that the number of observ-
able events has on the learner’s performance.

1

Introduction

Reinforcement learning (RL) (Sutton and Barto 1998) is a
family of algorithms where an agent acts in an environment
with the purpose of maximizing the total amount of reward
it receives. These algorithms have played a key role in major
breakthroughs like human-level video game playing (Mnih
et al. 2015) or mastering complex board games (Silver et al.
2018). However, current methods lack the ability to gener-
alize and transfer between tasks. For example, they cannot
learn to play chess using the knowledge of sh¯ogi.

Advances in achieving generalization and transfer in RL
are mainly due to abstractions (Ho et al. 2019; Konidaris
2019). Hierarchical reinforcement learning methods, which
divide a single task into several subtasks that can be solved
separately, are among the most promising approaches to ab-
stracting RL tasks. Common frameworks for hierarchical RL
are HAMs (Parr and Russell 1997), options (Sutton, Precup,
and Singh 1999) and MAXQ (Dietterich 2000).

Abstract hierarchies can be naturally represented using
automata, which have been used effectively in task abstrac-
tion, not only in RL (Parr and Russell 1997; Toro Icarte et

Copyright c(cid:13) 2020, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

al. 2018), but also in related areas like automated planning
(Bonet, Palacios, and Geffner 2009; Hu and De Giacomo
2011; Segovia-Aguas, Jim´enez, and Jonsson 2018). How-
ever, these RL approaches use handcrafted automata instead
of learning them from data. It is largely an open problem in
RL how to autonomously decompose a task into an automa-
ton that can be exploited during the RL process.

In this paper, we address this problem and propose ISA
(Induction of Subgoal Automata for Reinforcement Learn-
ing), a method for learning and exploiting a minimal au-
tomaton from observation traces perceived by an RL agent.
These automata are called subgoal automata since each
transition is labeled with a subgoal, which is a boolean
formula over a set of observables. Subgoal automata can
be expressed in a logic programming format and, thus, be
learned using state-of-the-art inductive logic programming
(ILP) systems (Law, Russo, and Broda 2015). The resulting
subgoal automaton can be exploited by an RL algorithm that
learns a different policy for each automaton state, each aim-
ing to achieve a subgoal. This decomposition allows learning
multiple subpolicies simultaneously and transferring knowl-
edge across multiple tasks. ISA interleaves the RL and au-
tomaton learning processes such that the agent can imme-
diately leverage the new (partially correct) learned subgoal
automaton: when a trace is not correctly recognized by the
automaton, a new one is learned.

We evaluate ISA in several gridworld problems and show
that it learns subgoal automata and policies for each of these.
Speciﬁcally, it performs similarly to a method for which au-
tomata are given in advance. Furthermore, the learned au-
tomata can be exploited to speed up convergence through
reward shaping and transfer learning.

The paper is organized as follows. Section 2 introduces
the background of our work. Section 3 formally presents the
problem we address and our method for solving it, while
Section 4 describes the results. We discuss related work in
Section 5 and conclude in Section 6.

2 Background
In this section we brieﬂy summarize the key background
concepts used throughout the paper: reinforcement learning
and inductive learning of answer set programs.

 
 
 
 
 
 
Reinforcement Learning
Reinforcement learning (RL) (Sutton and Barto 1998) is
a family of algorithms for learning to act in an unknown
environment. Typically, this learning process is formulated
as a Markov Decision Process (MDP), i.e., a tuple M =
(cid:104)S, A, p, r, γ(cid:105), where S is a ﬁnite set of states, A is a ﬁnite
set of actions, p : S × A → ∆(S) is a transition probability
function1, r : S × A × S → R is a reward function, and
γ ∈ [0, 1) is a discount factor. At time t, the agent observes
state st ∈ S, executes action at ∈ A, transitions to the next
state st+1 ∼ p(·|st, at) and receives reward r(st, at, st+1).
We consider episodic MDPs that terminate in a given set
of terminal states. We distinguish between goal states and
undesirable terminal states (i.e., dead-ends). Let ST ⊆ S be
the set of terminal states and SG ⊆ ST the set of goal states.
The aim is to ﬁnd a policy π : S → ∆(A), a mapping from
states to probability distributions over actions, that maxi-
mizes the expected sum of discounted reward (or return),
Rt = E[(cid:80)n

k=t γk−trk], where n is the last episode step.

In model-free RL the transition probability function p
and reward function r are unknown to the agent, and a
policy is learned via interaction with the environment. Q-
learning (Watkins 1989) computes an action-value function
Qπ(s, a) = E[Rt|st = s, at = a] that estimates the re-
turn from each state-action pair when following an approx-
imately optimal policy. In each iteration the estimates are
updated as

Q (s, a) α←− r (s, a, s(cid:48)) + γ max
a(cid:48)

Q (s(cid:48), a(cid:48)) ,

where x α←− y is shorthand for x ← x + α (y − x), α is a
learning rate and s(cid:48) is the state after applying a in s. Usually,
an (cid:15)-greedy policy selects a random action with probability
(cid:15) and the action maximizing Q(s, a) otherwise. The policy
is induced by the action that maximizes Q(s, a) in each s.

Options
(Sutton, Precup, and Singh 1999) address tempo-
ral abstraction in RL. Given an MDP M = (cid:104)S, A, p, r, γ(cid:105),
an option is a tuple ω = (cid:104)Iω, πω, βω(cid:105) where Iω ⊆ S is
the option’s initiation set, πω : S → ∆(A) is the option’s
policy, and βω : S → [0, 1] is the option’s termination con-
dition. An option is available in state s ∈ S if s ∈ Iω. If
the option is started, the actions are chosen according to πω.
The option terminates at a given state s ∈ S with probability
βω(s). The action set of an MDP can be augmented with op-
tions, which can be either handcrafted or automatically dis-
covered. An MDP extended with options is a Semi-Markov
Decision Process (SMDP); the learning methods for MDPs
still apply to SMDPs. To improve sample-efﬁciency, the ex-
periences (s, a, r, s(cid:48)) generated by an option’s policy can be
used to update other options’ policies. This transfer learning
method is called intra-option learning (Sutton, Precup, and
Singh 1998).

Inductive Learning of Answer Set Programs
In this section we describe answer set programming (ASP)
and the ILASP system for learning ASP programs.
1For any ﬁnite set X, ∆(X) = {µ ∈ RX : (cid:80)

x µ(x) =

1, µ(x) ≥ 0 (∀x)} is the probability simplex over X.

Answer Set Programming (ASP)
(Gelfond and Kahl
2014) is a declarative programming language for knowledge
representation and reasoning. An ASP problem is expressed
in a logical format and the models (called answer sets) of its
representation provide the solutions to that problem.

A literal is an atom a or its negation not a. Given an
atom h and a set of literals b1, . . . , bn, a normal rule is of
the form h : - b1, . . . , bn, where h is the head and b1, . . . , bn
is the body of the rule. Rules of the form : - b1, . . . , bn are
called constraints. In this paper, we assume an ASP program
P to be a set of normal rules and constraints. Given a set of
ground atoms (or interpretation) I, a ground normal rule is
satisﬁed if the head is satisﬁed by I when the body literals
are satisﬁed by I. A ground constraint is satisﬁed if the body
is not satisﬁed by I. The reduct P I of a program P with re-
spect to I is built by removing all rules including not a such
that a ∈ I from P . I is an answer set of P iff (1) I satisﬁes
the rules of P I , and (2) no subset of I satisﬁes the rules of
P I .

ILASP (Law, Russo, and Broda 2015) is a system for
learning ASP programs from partial answer sets. A context-
dependent partial interpretation (CDPI) (Law, Russo, and
Broda 2016) is a pair (cid:104)(cid:104)einc, eexc(cid:105), ectx(cid:105), where (cid:104)einc, eexc(cid:105)
is a partial interpretation and ectx is an ASP program, called
context. A program P accepts e iff there is an answer set
A of P ∪ ectx such that einc ⊆ A and eexc ∩ A = ∅.
An ILASP task (Law, Russo, and Broda 2016) is a tuple
T = (cid:104)B, SM , E(cid:105) where B is the ASP background knowl-
edge, SM is the set of rules allowed in the hypotheses, and
E is a set of CDPIs, called examples. A hypothesis H ⊆ SM
is a solution of T iff ∀e ∈ E, B ∪ H accepts e.

3 Methodology
In this section we describe ISA, our method that inter-
leaves the learning of subgoal automata with the learning
of policies for achieving these subgoals. The tasks we con-
sider are episodic MDPs M = (cid:104)S, A, p, r, γ, ST , SG(cid:105) where
r(s, a, s(cid:48)) = 1 if s(cid:48) ∈ SG and 0 otherwise.

The automaton transitions are deﬁned by a logical for-
mula over a set of observables O. A labeling function L :
S → 2O maps an MDP state into a subset of observables
O ⊆ O (or observations) perceived by the agent at that state.
We use the OFFICEWORLD environment (Toro Icarte
et al. 2018) to explain our method. It consists of a grid
(see Figure 1a) where an agent ( ) can move in the four
cardinal directions, and the set of observables is O =
{(cid:75), (cid:66), o, A, B, C, D, ∗}. The agent picks up coffee and the
mail at locations (cid:75) and (cid:66) respectively, and delivers them to
the ofﬁce at location o. The decorations ∗ are broken if the
agent steps on them. There are also four locations labeled A,
B, C and D. The observables A, B, C and D, and decora-
tions ∗ do not share locations with other elements. The agent
observes these labels when it steps on their locations. Three
tasks with different goals are deﬁned on this environment:
COFFEE (deliver coffee to the ofﬁce), COFFEEMAIL (de-
liver coffee and mail to the ofﬁce), and VISITABCD (visit
A, B, C and D in order). The tasks terminate when the goal
is achieved or a ∗ is broken (this is a dead-end state).

8
7
6
5
4
3
2
1
0

D

∗

A

(cid:75)

∗

o

∗

∗

(cid:66)

∗

C

∗

B

0 1 2 3 4 5 6 7 8 9 10 11

(a)

Execution trace
T = (cid:104)s4,6, ←, 0, s3,6, →, 0,

s4,6, ↓, 0, s4,5, ↓, 1, s4,4(cid:105)

Observation trace
TL,O = (cid:104){}, {(cid:75)}, {}, {}, {o}(cid:105)

Compressed observation trace
ˆTL,O = (cid:104){}, {(cid:75)}, {}, {o}(cid:105)

(b)

otherwise

start

(cid:75) ∧ ¬o

u0

(cid:75) ∧ o

o

u1

otherwise

uA

∗

(c)

∗

uR

Figure 1: The OFFICEWORLD environment (Toro Icarte et al. 2018). Figure (a) is an example grid, (b) shows a positive execu-
tion trace in the example grid for the COFFEE task and its derived observation traces, and (c) shows the COFFEE automaton.

Traces
An execution trace T is a ﬁnite state-action-reward se-
quence T = (cid:104)s0, a0, r1, s1, a1, . . . , an−1, rn, sn(cid:105) induced
by a (changing) policy during an episode. An execution trace
is positive if sn ∈ SG, negative if sn ∈ ST \ SG, and incom-
plete if sn /∈ ST , denoted by T +, T − and T I respectively.
An observation trace TL,O is a sequence of observation
sets Oi ⊆ O, 0 ≤ i ≤ n, obtained by applying a label-
ing function L to each state si in an execution trace T . A
compressed observation trace ˆTL,O is the result of remov-
ing contiguous duplicated observation sets from TL,O. Fig-
ure 1b shows an example of a positive execution trace for
the COFFEE task together with the derived observation trace
and the resulting compressed trace.

A set of execution traces is a tuple T = (cid:104)T +, T −, T I (cid:105),
where T +, T − and T I are sets of positive, negative and
incomplete traces, respectively. The sets of observation and
compressed observation traces are denoted TL,O and ˆTL,O.

Subgoal Automata
A subgoal automaton is a tuple A = (cid:104)U, O, δ, u0, uA, uR(cid:105)
where U is a ﬁnite set of states, O is a set of observables
(or alphabet), δ : U × 2O → U is a deterministic transition
function that takes as arguments a state and a subset of ob-
servables and returns a state, u0 ∈ U is a start state, uA ∈ U
is the unique accepting state, and uR ∈ U is the unique re-
jecting state.

A subgoal automaton A accepts an observation trace
TL,O = (cid:104)O0, . . . , On(cid:105) if there exists a sequence of automa-
ton states u0, . . . , un+1 in U such that (1) δ(ui, Oi) = ui+1
for i = 0, . . . , n, and (2) un+1 = uA. Analogously, A re-
jects TL,O if un+1 = uR.

When a subgoal automaton is used together with an MDP,
the actual states are (s, u) pairs where s ∈ S and u ∈ U .
Therefore, actions are selected according to a policy π : S ×
U → ∆(A) where π(a|s, u) is the probability for taking
action a ∈ A at the MDP state s ∈ S and the automaton
state u ∈ U . At each step, the agent transitions to (s(cid:48), u(cid:48))

where s(cid:48) is the result of applying an action a ∈ A in s,
while u(cid:48) = δ(u, L(s(cid:48))). Then, the agent receives reward 1 if
u(cid:48) = uA and 0 otherwise.

Figure 1c shows the automaton for the COFFEE task of
the OFFICEWORLD domain. Each transition is labeled with
a logical condition ϕ ∈ 3O that expresses the subgoal to be
achieved2. The sequence of visited automaton states for the
trace in Figure 1b would be (cid:104)u0, u1, u1, u1, uA(cid:105).

Relationship with options. Each state u ∈ U in a sub-
goal automaton encapsulates an option ωu = (cid:104)Iu, πu, βu(cid:105)
whose policy πu attempts to satisfy an outgoing transition’s
condition. Formally, the option termination condition βu is:
(cid:26)1 if ∃u(cid:48) (cid:54)= u, ϕ ∈ 3O|L(s(cid:48)) |= ϕ, δ(u, ϕ) = u(cid:48)
0 otherwise

βu(s) =

.

That is, the option at automaton state u ∈ U ﬁnishes at MDP
state s ∈ S if there is a transition to a different automaton
state u(cid:48) ∈ U such that the transition’s condition ϕ is satisﬁed
by the next observations L(s(cid:48)). Note that at most one transi-
tion can be made true since the automaton is deterministic.
The initiation set Iu is formed by all those states that sat-

isfy the incoming conditions:
Iu = {s ∈ S | δ (u(cid:48), ϕ) = u, L (s) |= ϕ, u (cid:54)= u(cid:48), u (cid:54)= u0} .
In the particular case of the initial automaton state u0 ∈ U ,
its initiation set Iu0 = S is the whole state space since there
is no restriction imposed by any previous automaton state.

Note that we do not add options to the set of primitive
actions, which would make the decision process more com-
plex since more alternatives are available. Instead, subgoal
automata keep the action set unchanged, and which option
to apply is determined by the current automaton state.

Learning Subgoal Automata from Traces
This section describes our approach for learning an au-
tomaton. We formalize the automaton learning task as a

2Note that ϕ ∈ 3O because each observable can appear as pos-

itive or negative, or not appear in the condition.

L,O, T I

L,O, T −

tuple TA = (cid:104)U, O, TL,O(cid:105), where U ⊇ {u0, uA, uR} is
a set of states, O is a set of observables, and TL,O =
(cid:104)T +
L,O(cid:105) is a set of (possibly compressed) obser-
vation traces (abbreviated as traces below). An automaton A
is a solution of TA if and only if accepts all positive traces
T +
L,O, rejects all negative traces T −
L,O, and neither accepts
nor rejects incomplete traces T I

The automaton learning task TA is mapped into an ILASP
task M (TA) = (cid:104)B, SM , E(cid:105). Then, the ILASP system is
used to learn the smallest set of transitions (i.e., a minimal
hypothesis) that covers the example traces.

L,O.

We deﬁne the components of the ILASP task M (TA) be-
low. An ILASP task speciﬁes the maximum size of a rule
body. To allow for an arbitrary number of literals in the bod-
ies, we learn the negation ¯δ of the actual transitions δ. Thus,
we do not limit the number of conjuncts, but the number of
disjuncts (i.e., the number of edges between two states). We
denote the maximum number of disjuncts by max |δ(x, y)|.

Hypothesis space. The hypothesis space SM is formed by
two kinds of rules:
1. Facts of the form ed(X, Y, E). indicating there is a transi-
tion from state X ∈ U \ {uA, uR} to state Y ∈ U \ {X}
using edge E ∈ [1, max |δ(x, y)|].

2. Normal rules whose head is of the form ¯δ(X, Y, E, T)
stating that the conditions of the transition from state
X ∈ U \ {uA, uR} to state Y ∈ U \ {X} in edge
E ∈ [1, max |δ(x, y)|] do not hold at time T. These con-
ditions are speciﬁed in the body, which is a conjunction
of obs(O, T) literals indicating that observable O ∈ O is
seen at time T. The atom step(T) expresses that T is a
timestep. The body must contain at least one obs literal.

Note that the hypothesis space does not include (i) loop
transitions, and (ii) transitions from uA and uR. Later, we
deﬁne (i) in the absence of external transitions.

Given a subgoal automaton A, we denote the set of ASP
rules that describe it by M (A). The rules below correspond
to the (u0, u1) and (u0, uA) transitions in Figure 1c:

ed(u0, u1, 1). ed(u0, uA, 1).
¯δ(u0, u1, 1, T) : - not obs((cid:75), T), step(T).
¯δ(u0, u1, 1, T) : - obs(o, T), step(T).
¯δ(u0, uA, 1, T) : - not obs(o, T), step(T).
¯δ(u0, uA, 1, T) : - not obs((cid:75), T), step(T).
L,O, T −

L,O, T I

Examples. Given TL,O = (cid:104)T +
L,O(cid:105), the exam-
ple set is deﬁned as E = {(cid:104)e∗, CTL,O (cid:105) | ∗ ∈ {+, −, I},
L,O}, where e+ = (cid:104){accept}, {reject}(cid:105), e− =
TL,O ∈ T ∗
(cid:104){reject}, {accept}(cid:105) and eI = (cid:104){}, {accept, reject}(cid:105)
are the partial interpretations for positive, negative and in-
complete examples. The accept and reject atoms express
whether a trace is accepted or rejected by the automaton;
hence, positive traces must only be accepted, negative traces
must only be rejected, and incomplete traces cannot be ac-
cepted or rejected.

Given a trace TL,O = (cid:104)O0, . . . , On(cid:105), a context is de-
ﬁned as: CTL,O = {obs(O, T). | O ∈ OT, OT ∈ TL,O} ∪
{last(n).}, where last(n) indicates that the trace ends
at time n. We denote by M (TL,O) the set of ASP facts

that describe the trace TL,O. For example, M (TL,O) =
{obs(a, 0). obs(b, 2). obs(c, 2). last(2).} for the trace
TL,O = (cid:104){a}, {}, {b, c}(cid:105).

Background knowledge. The next paragraphs describe
the background knowledge B components: B = BU ∪
Bstep ∪ Bδ ∪ Bst. First, BU is a set of facts of the form
state(u). for each u ∈ U . The set Bstep deﬁnes a ﬂuent
step(T) for 0 ≤ T ≤ T(cid:48) + 1 where T(cid:48) is the step for which
last(T(cid:48)) is deﬁned.

The subset Bδ deﬁnes rules for the automaton transition
function. The ﬁrst rule deﬁnes all the possible edge iden-
tiﬁers, which is limited by the maximum number of edges
between two states. The second rule states that there is an
external transition from state X at time T if there is a transi-
tion from X to a different state Y at that time. The third rule is
a frame axiom: state X transitions to itself at time T if there
are no external transitions from it at that time. The fourth
rule deﬁnes the positive transitions in terms of the learned
negative transitions ¯δ and ed atoms. The ﬁfth rule preserves
determinism: two transitions from X to two different states Y
and Z cannot hold at the same time. The sixth rule forces all
non-terminal states to have an edge to another state.





Bδ =

edge id(1.. max |δ(x, y)|).

ext δ(X, T) : - δ(X, Y, , T), X!=Y.
δ(X, X, 1, T) : - not ext δ(X, T), state(X), step(T).
δ(X, Y, E, T) : - ed(X, Y, E), not ¯δ(X, Y, E, T), step(T).

: - δ(X, Y, , T), δ(X, Z, , T), Y!=Z.
: - not ed(X, , ), state(X), X!=uA, X!=uR.



The subset Bst uses st(T, X) atoms, indicating that the
agent is in state X at time T. The ﬁrst rule says that the agent
is in u0 at time 0. The second rule determines that at time
T+1 the agent will be in state Y if it is in a non-terminal
state X at time T and a transition between them holds. The
third (resp. fourth) rule deﬁnes that the example is accepted
(resp. rejected) if the state at the trace’s last timestep is uA
(resp. uR).



st(0, u0).
st(T+1, Y) : - st(T, X), δ(X, Y, , T), X!=uA, X!=uR.
accept : - last(T), st(T+1, uA).
reject : - last(T), st(T+1, uR).

Bst =








Lemma 1 and Theorem 1 capture the correctness of the

encoding. We omit the proofs for brevity.
Lemma 1 (Correctness of the ASP encoding). Given an au-
tomaton A and a ﬁnite trace T ∗
L,O, where ∗ ∈ {+, −, I},
M (A) ∪ B ∪ M (T ∗
L,O) has a unique answer set S and (1)
accept ∈ S iff ∗ = +, and (2) reject ∈ S iff ∗ = −.
Theorem 1. Given an automaton learning task TA =
(cid:104)U, O, TL,O(cid:105), an automaton A is a solution of TA iff M (A)
is an inductive solution of M (TA) = (cid:104)B, SM , E(cid:105).

Interleaved Automata Learning Algorithm
This section describes ISA (Induction of Subgoal Automata
for Reinforcement Learning), a method that combines rein-
forcement and automaton learning. First, we describe the RL
algorithm that exploits the automaton structure. Second, we
explain how these two learning components are mixed.

Reinforcement learning algorithm. The RL algorithm
we use to exploit the automata structure is QRM (Q-learning
for Reward Machines) (Toro Icarte et al. 2018). QRM main-
tains a Q-function for each automaton state, which are up-
dated with Q-learning updates of the form:

Qu (s, a) α←− r + γ max
a(cid:48)

Qu(cid:48) (s(cid:48), a(cid:48)) ,

where, in our case, r = 1 if u(cid:48) = uA and 0 otherwise. Note
that the bootstrapped action-value depends on the next au-
tomaton state u(cid:48).

QRM performs this update for all the automaton states,
so all policies are simultaneously updated based on the
(s, a, s(cid:48)) experience. Note this is a form of intra-option
learning (Sutton, Precup, and Singh 1998): we update the
policies of all the states from the experience generated by a
single state’s policy. In the tabular case, QRM is guaranteed
to converge to an optimal policy in the limit. Note that QRM
(and thus, ISA) is still applicable in domains with large state
spaces by having a Deep Q-Network (Mnih et al. 2015) in
each automaton state instead of a Q-table.

(cid:46) Set of counterexamples

Algorithm 1 ISA algorithm for a single task
1: A ← INITAUTOMATON({u0, uA, uR})
2: TL,O ← {}
3: INITQFUNCTIONS(A)
4: for l = 0 to num episodes do
s ← ENVINITIALSTATE()
5:
up ← δ(u0, L(s))
6:
TL,O ← (cid:104)L(s)(cid:105)
7:
if ISCOUNTEREXAMPLE(s, up) then
8:
9:
10:

ONCOUNTEREXAMPLEFOUND(TL,O)
up ← δ(u0, L(s))

(cid:46) Initialize trace

ONCOUNTEREXAMPLEFOUND(TL,O)
break

for t = 0 to length episode do
a, s(cid:48) ← ENVSTEP(s, up)
uq ← δ(up, L(s(cid:48)))
UPDATEOBSTRACE(L(s(cid:48)), TL,O)
if ISCOUNTEREXAMPLE(s(cid:48), uq) then

11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21: function ONCOUNTEREXAMPLEFOUND(TL,O)
22:
23:
24:

TL,O ← TL,O ∪ {TL,O}
A ← FINDMINIMALAUTOMATON(TL,O)
INITQFUNCTIONS(A)

UPDATEQFUNCTIONS(s, a, s(cid:48), L(s(cid:48)))
s ← s(cid:48); up ← uq

else

ISA algorithm. Algorithm 1 is the ISA pseudocode for a
single task and is explained below:
1. The initial automaton (line 1) has initial state u0, accept-
ing state uA and rejecting state uR. The automaton does
not accept nor reject anything. The set of counterexample
traces and the Q-functions are initialized (lines 2-3).
2. When an episode starts, the current automaton state up
is u0. One transition is applied depending on the agent’s
initial observations L(s) (lines 5-6). In Figure 1c, if the
agent initially observes {(cid:75)}, the actual initial state is u1.

3. At each step, we select an action a in state s using an (cid:15)-
greedy policy (line 12), and update the automaton state up
and observation trace TL,O (lines 13-14). If no counterex-
ample is found (line 18), the Q-functions of all automaton
states are updated (line 19) and the episode continues.
4. Let u be the current automaton state and s the MDP state.
A counterexample trace is found (lines 8, 15) if (a) multi-
ple outgoing transitions from u hold, or (b) the automaton
does not correctly recognize s (e.g., s ∈ SG ∧ u (cid:54)= uA).

5. If a counterexample trace TL,O is found (lines 21-24):
L,O if s ∈ SG, to T −

(a) Add it to T +

L,O if s ∈ ST \ SG and

to T I

L,O if s /∈ ST (line 22).

(b) Run the automaton learner (line 23), using iterative
deepening to select the number of automaton states.
• When a new automaton is learned, we reset all the Q-
functions (e.g., setting all Q-values to 0) (line 24).
• If a counterexample is detected at the beginning of the
episode (line 8), the automaton state is reset (line 10),
else the episode ends (line 17).

ISA does not start learning automata until we ﬁnd a pos-
itive example (i.e., the goal is achieved). Resetting all the
Q-functions causes the agent to forget everything it learned.
To mitigate the forgetting effect and further exploit the au-
tomata structure, we employ reward shaping.

Reward shaping. Ng, Harada, and Russell (1999) pro-
posed a function that provides the agent with additional re-
ward to guide its learning process while guaranteeing that
optimal policies remain unchanged:

F (s, a, s(cid:48)) = γΦ (s(cid:48)) − Φ (s) ,
where γ is the MDP’s discount factor and Φ : S → R is
a real-valued function. The automata structure can be ex-
ploited by deﬁning F : U × U → R in terms of the automa-
ton states instead of the MDP states:

F (u, u(cid:48)) = γΦ (u(cid:48)) − Φ (u) ,
where Φ : U → R. Intuitively, we want F ’s output to be
high when the agent gets closer to uA. Thus, we deﬁne Φ as

Φ (u) = |U | − d (u, uA) ,

where |U | is the number of states in the automaton (an upper
bound for the maximum ﬁnite distance between u0 and uA),
and d(u, uA) is the distance between state u and uA. If uA
is unreachable from a state u, then d(u, uA) = ∞.

Theorem 2 shows that if the target automata is in the hy-
pothesis space, there will only be a ﬁnite number of learning
steps in the algorithm before it converges on the target au-
tomata (or an equivalent automata).
Theorem 2. Given a target ﬁnite automaton A∗, there
is no inﬁnite sequence σ of automaton-counterexample
pairs (cid:104)Ai, ei(cid:105) such that ∀i: (1) Ai covers all examples
e1, . . . , ei−1, (2) Ai does not cover ei, and (3) Ai is in the
ﬁnite hypothesis space SM .

Proof. By contradiction. Assume that σ is inﬁnite. Given
that SM is ﬁnite, the number of possible automata is ﬁnite.

start

u0

All

+

-

I

COFFEE

6.6 (0.5)

2.2 (0.2)

2.3 (0.2)

2.1 (0.3)

(cid:75) ∧ ¬(cid:66)

¬(cid:75) ∧ (cid:66)

COFFEEMAIL

34.5 (2.9)

5.5 (0.4)

9.9 (0.9)

19.1 (2.2)

(cid:75) ∧ (cid:66) ∧ o

VISITABCD

32.5 (2.1)

1.7 (0.2)

11.6 (0.8)

19.2 (1.7)

u1

(cid:66) ∧ o

uA

(cid:75) ∧ o

u2

Table 1: Average number of examples needed for setting S.

start

u0

∗

uR

A

∗

∗

∗

u1

B

u2

C

u3

D

uA

(cid:75) ∧ (cid:66) ∧ ¬o

o

u3

(cid:66) ∧ ¬o

(cid:75) ∧ ¬o

(a) VISITABCD

(b) COFFEEMAIL

Figure 2: Automata for two OFFICEWORLD tasks. Self-
loops and transitions to uR in (b) are omitted. The shaded
state IDs can be interchanged without Bsym. The dashed
state IDs are still interchangeable even when using Bsym.

Hence, some automaton A must appear in σ at least twice,
say as Ai = Aj, i < j. By deﬁnition, Ai does not cover ei
and Aj covers ei. This is a contradiction.

4 Experimental Results
We evaluate3 ISA using the OFFICEWORLD domain and the
three tasks introduced in Section 3. The automata we com-
pute using our method are forced to be acyclic. Besides,
we add a simple symmetry breaking constraint Bsym to the
task’s background knowledge to avoid considering isomor-
phic automata. Figure 2 shows two automata whose state
IDs u1, u2 and u3 can be used indifferently. Our symmetry
breaking method (1) assigns an integer index to each state4
and (2) imposes that states must be visited in increasing or-
der of indices. For example, if we assign indices 0. . . 3 to
u0, . . . , u3, positive traces in Figure 2a always yield the se-
quence (cid:104)u0, u1, u2, u3, uA(cid:105). However, this is not enough to
break all symmetries in Figure 2b: u1 and u2 can still be
switched since they cannot be in the same path to uA or uR.
Tabular Q-learning is used to learn the Q-function at each
automaton state with parameters α = 0.1, (cid:15) = 0.1, and
γ = 0.99. The agent’s state is its position. ISA receives a set
of 100 randomly generated grids5. One episode is run per
grid in sequential order until reaching 20,000 episodes for
each grid. The maximum episode length is 100 steps.

For some experiments we consider the multitask setting,
where an automaton is learned for every task from the set of
grids. Thus, there is a Q-table for each task-grid-automaton
state triplet updated at every step. One episode is run per
task-grid until 20,000 episodes are performed for each pair.
When reward shaping is on, the shaping function’s output
is set to -100 in case it is −∞. This occurs when the next
automaton state is uR since there is no path from it to uA.

3Code: github.com/ertsiger/induction-subgoal-automata-rl.
4u0 has the lowest value, while uA and uR have the highest.
5Each grid has the same size and walls as Figure 1a. The ob-

servables and the agent are randomly placed.

The different settings are referenced as S (single task), M
(multitask) and R (reward shaping), all using the same set of
100 random grids. We execute 10 runs for each setting.

We use ILASP to learn the automata from compressed ob-
servation traces and set max |δ(x, y)| to 1. All experiments
ran on 3.40GHz Intel R(cid:13) CoreTM i7-6700 processors.

ISA performs similarly to QRM. Figure 3 shows the
tasks’ average learning curve for ISA and QRM (where the
automaton is given beforehand) across 10 runs. The ISA
curves converge similarly to the analogous QRM’s. When
reward shaping is used, convergence speeds up dramatically.
The multitask settings converge faster since an agent is also
trained from other agents’ experiences in different tasks.

The vertical lines are episodes where an automaton is
learned, and often occur during the ﬁrst episodes: this is the
main reason why the learning and non-learning curves are
similar. Less frequently, automata learning also happens at
intermediate phases in the COFFEE and COFFEEMAIL tasks
which make the agent forget what it learned. In these cases,
recovery from forgetting happens faster in the multitask set-
tings because of the reason above. Reward shaping has a
positive effect on the learner: not only is convergence faster,
it also helps the agent to discover helpful traces earlier.

ISA’s automata learning results. Table 1 shows the aver-
age number of examples needed to learn the ﬁnal automata
for setting S (the results for other settings are similar). Ta-
ble 2 shows the average time needed for computing all the
automata, which is negligible with respect to ISA’s total
running time. For both tables, the standard error is shown
in brackets. First, we observe that the most complex tasks
(COFFEEMAIL and VISITABCD) need a higher number of
examples and more time to compute their corresponding au-
tomata. However, while the total number of examples for
these tasks are similar, the time is higher for VISITABCD
possibly because the longest path from u0 to uA is longer
than in COFFEEMAIL. Second, we see that the number of
positive and incomplete examples are usually the smallest
and the largest respectively. Note that the number of posi-
tive examples is approximately equal to the number of paths
from u0 to uA. The paths described by the positive examples
are reﬁned through the negative and incomplete ones. Fi-
nally, Table 2 shows slight variations of time across settings.
The different experimental settings and the exploratory na-
ture of the agent are responsible for coming up with differ-
ent counterexamples and, thus, cause these variations. There
is not a clear setting which leads to faster automata learn-
ing across domains. The design of exploratory strategies that
speed up automata learning is possible future work.

(a) COFFEE

(b) COFFEEMAIL

(c) VISITABCD

Figure 3: Learning curves for different OFFICEWORLD tasks. The vertical lines are episodes where an automaton is learned.

S

S+R

M

M+R

COFFEE

0.5 (0.0)

0.4 (0.0)

0.3 (0.0)

0.4 (0.0)

COFFEEMAIL

43.3 (12.1)

36.9 (6.0)

24.8 (3.6)

24.6 (2.7)

VISITABCD

63.0 (11.4)

68.5 (13.0)

48.4 (8.8)

69.6 (8.1)

Table 2: Average ILASP running time.

ISA learns automata faster with few observables. To
test the effect of the observable set O on ILASP’s perfor-
mance, we run the experiments using setting S but employ-
ing only the observables that each task needs, e.g., O =
{(cid:75), o, ∗} in the COFFEE task. The biggest changes occur in
COFFEEMAIL, where the total number of examples is 46%
smaller. The sets of positive, negative and incomplete exam-
ples are 27%, 42% and 53% smaller. Besides, the automata
are computed 92% faster. Thus, we see that the number of
observables has an impact on the performance: the RL pro-
cess is halted less frequently and automata are learned faster.
This performance boost in COFFEEMAIL can be due to the
fact that it has more paths to uA; thus, irrelevant symbols do
not need to be discarded for each of these. This is conﬁrmed
by the fact that while the number of positives is roughly the
same, the number of incomplete examples greatly decreases.

5 Related Work
Hierarchical RL (HRL). Our method is closely related
to the options framework for HRL, and indeed we deﬁne
one option per automaton state. The key difference from
other HRL approaches, like HAMs (Parr and Russell 1997),
MAXQ (Dietterich 2000) and the common way of using op-
tions, is that we do not learn a high-level policy for select-
ing among options. Rather, the high-level policy is implic-
itly represented by the automaton, and the option to execute
is fully determined by the current automaton state. Conse-
quently, while HRL policies may be suboptimal in general,
the QRM algorithm we use converges to the optimal policy.
Our approach is similar to HAMs in that they also use an
automaton. However, HAMs are non-deterministic automata
whose transitions can invoke lower level machines and are
not labeled by observables (the high-level policy consists in

deciding which transition to ﬁre). Leonetti, Iocchi, and Pa-
trizi (2012) synthesize a HAM from the set of shortest solu-
tions to a non-deterministic planning problem, and use it to
reﬁne the choices at non-deterministic points through RL.

Option discovery.
ISA is similar to bottleneck option dis-
covery methods, which ﬁnd “bridges” between regions of
the state space. In particular, ISA ﬁnds conditions that con-
nect two of these regions. McGovern and Barto (2001) use
diverse density to ﬁnd landmark states in state traces that
achieve the task’s goal. This approach is similar to ours be-
cause (1) it learns from traces; (2) it classiﬁes traces into
different categories; and (3) it interleaves option discovery
and learning.

Just like some option discovery methods (McGovern and
Barto 2001; Stolle and Precup 2002), our approach requires
the task to be solved at least once. Other methods (Men-
ache, Mannor, and Shimkin 2002; S¸ ims¸ek and Barto 2004;
S¸ ims¸ek, Wolfe, and Barto 2005; Machado, Bellemare, and
Bowling 2017) discover options without solving the task.

Grammars are an alternative to automata for expressing
formal languages. Lange and Faisal (2019) induce a straight-
line grammar from action traces to discover macro-actions.

Reward machines (RMs). Subgoal automata are similar
to RMs (Toro Icarte et al. 2018). There are two differences:
(1) RMs do not have explicit accepting and rejecting states,
and (2) RMs use a reward-transition function δr : U × U →
R that returns the reward for taking a transition between two
automaton states. Note that our automata are a speciﬁc case
of the latter where δr(·, uA) = 1 and 0 otherwise.

Recent work has focused on learning RMs from experi-
ence using discrete optimization (Toro Icarte et al. 2019) and
grammatical inference algorithms (Xu et al. 2019). While
these approaches can get stuck in a local optima, ISA re-
turns a minimal automaton each time it is called. Just as our
method, they use an ‘a priori’ speciﬁed set of observables.

In contrast to the other learning approaches, in the future
we can leverage ILP to (1) transfer knowledge between au-
tomata learning tasks (e.g., providing a partial automaton as
the background knowledge), (2) support examples generated
by a noisy labeling function, and (3) easily express more
complex conditions (e.g., using ﬁrst-order logic).

05000100001500020000Numberofepisodes0.00.20.40.60.81.0AveragerewardQRM(S)QRM(S+R)QRM(M)QRM(M+R)ISA(S)ISA(S+R)ISA(M)ISA(M+R)05000100001500020000Numberofepisodes0.00.20.40.60.81.0AveragerewardQRM(S)QRM(S+R)QRM(M)QRM(M+R)ISA(S)ISA(S+R)ISA(M)ISA(M+R)05000100001500020000Numberofepisodes0.00.20.40.60.81.0AveragerewardQRM(S)QRM(S+R)QRM(M)QRM(M+R)ISA(S)ISA(S+R)ISA(M)ISA(M+R)Camacho et al. (2019) convert reward functions expressed
in various formal languages into RMs, and propose a reward
shaping method that runs value iteration on the RM states.

6 Conclusions and Future Work
In this paper we have proposed ISA, an algorithm for learn-
ing subgoals by inducing a deterministic ﬁnite automaton
from observation traces seen by the agent. The automaton
structure can be exploited by an existing RL algorithm to
increase sample efﬁciency and transfer learning. We have
shown that our method performs comparably to an algorithm
where the automaton is given beforehand.

Improving the scalability is needed to handle more com-
plex tasks requiring automata with cycles or longer exam-
ples. In the future, we will further explore symmetry break-
ing techniques to reduce the hypothesis space (Drescher,
Tifrea, and Walsh 2011) and other approaches automata
learning, like RNNs (Weiss, Goldberg, and Yahav 2018;
Michalenko et al. 2019). Discovering the observables used
by the automata is also an interesting path for future work.

Acknowledgments
Anders Jonsson is partially supported by the Spanish grants
TIN2015-67959 and PCIN-2017-082.

References
Bonet, B.; Palacios, H.; and Geffner, H. 2009. Automatic Deriva-
tion of Memoryless Policies and Finite-State Controllers Using
Classical Planners. In ICAPS.
Camacho, A.; Icarte, R. T.; Klassen, T. Q.; Valenzano, R. A.; and
McIlraith, S. A. 2019. LTL and Beyond: Formal Languages for
Reward Function Speciﬁcation in Reinforcement Learning. In IJ-
CAI.
Dietterich, T. G. 2000. Hierarchical Reinforcement Learning with
the MAXQ Value Function Decomposition. JAIR 13:227–303.
Drescher, C.; Tifrea, O.; and Walsh, T. 2011. Symmetry-breaking
Answer Set Solving. AI Commun. 24(2):177–194.
Gelfond, M., and Kahl, Y. 2014. Knowledge Representation, Rea-
soning, and the Design of Intelligent Agents: The Answer-Set Pro-
gramming Approach. Cambridge University Press.
Ho, M. K.; Abel, D.; Grifﬁths, T. L.; and Littman, M. L. 2019.
The value of abstraction. Current Opinion in Behavioral Sciences
29:111 – 116. SI: 29: Artiﬁcial Intelligence (2019).
Hu, Y., and De Giacomo, G. 2011. Generalized Planning: Synthe-
sizing Plans that Work for Multiple Environments. In IJCAI.
Konidaris, G. 2019. On the necessity of abstraction. Current Opin-
ion in Behavioral Sciences 29:1 – 7. SI: 29: Artiﬁcial Intelligence
(2019).
Lange, R. T., and Faisal, A. 2019. Semantic RL with Action Gram-
mars: Data-Efﬁcient Learning of Hierarchical Task Abstractions .
CoRR abs/1907.12477.
Law, M.; Russo, A.; and Broda, K. 2015. The ILASP System for
Learning Answer Set Programs.
Law, M.; Russo, A.; and Broda, K. 2016.
Iterative Learning of
Answer Set Programs from Context Dependent Examples. TPLP
16(5-6):834–848.
Leonetti, M.; Iocchi, L.; and Patrizi, F. 2012. Automatic Genera-
tion and Learning of Finite-State Controllers. In AIMSA.

Machado, M. C.; Bellemare, M. G.; and Bowling, M. H. 2017.
A Laplacian Framework for Option Discovery in Reinforcement
Learning. In ICML.
McGovern, A., and Barto, A. G. 2001. Automatic Discovery of
Subgoals in Reinforcement Learning using Diverse Density.
In
ICML.
Menache, I.; Mannor, S.; and Shimkin, N. 2002. Q-Cut - Dynamic
Discovery of Sub-goals in Reinforcement Learning. In ECML.
Michalenko, J. J.; Shah, A.; Verma, A.; Baraniuk, R. G.; Chaud-
huri, S.; and Patel, A. B. 2019. Representing Formal Languages: A
Comparison Between Finite Automata and Recurrent Neural Net-
works. CoRR abs/1902.10297.
Mnih, V.; Kavukcuoglu, K.; Silver, D.; Rusu, A. A.; Veness, J.;
Bellemare, M. G.; Graves, A.; Riedmiller, M. A.; Fidjeland, A.;
Ostrovski, G.; Petersen, S.; Beattie, C.; Sadik, A.; Antonoglou, I.;
King, H.; Kumaran, D.; Wierstra, D.; Legg, S.; and Hassabis, D.
2015. Human-level control through deep reinforcement learning.
Nature 518(7540):529–533.
Ng, A. Y.; Harada, D.; and Russell, S. J. 1999. Policy Invari-
ance Under Reward Transformations: Theory and Application to
Reward Shaping. In ICML.
Parr, R., and Russell, S. J. 1997. Reinforcement Learning with
Hierarchies of Machines. In NeurIPS.
Segovia-Aguas, J.; Jim´enez, S.; and Jonsson, A. 2018. Computing
Hierarchical Finite State Controllers with Classical Planning. JAIR
62:755–797.
Silver, D.; Hubert, T.; Schrittwieser, J.; Antonoglou, I.; Lai, M.;
Guez, A.; Lanctot, M.; Sifre, L.; Kumaran, D.; Graepel, T.; Lill-
icrap, T.; Simonyan, K.; and Hassabis, D. 2018. A general re-
inforcement learning algorithm that masters chess, shogi, and Go
through self-play. Science 362(6419):1140–1144.
S¸ ims¸ek, ¨O., and Barto, A. G. 2004. Using Relative Novelty to
Identify Useful Temporal Abstractions in Reinforcement Learning.
In ICML.
S¸ ims¸ek, ¨O.; Wolfe, A. P.; and Barto, A. G. 2005. Identifying Useful
Subgoals in Reinforcement Learning by Local Graph Partitioning.
In ICML.
Stolle, M., and Precup, D. 2002. Learning Options in Reinforce-
ment Learning. In SARA.
Sutton, R. S., and Barto, A. G. 1998. Reinforcement Learning: An
introduction. MIT Press.
Sutton, R. S.; Precup, D.; and Singh, S. P. 1998.
Learning about Temporally Abstract Actions. In ICML.
Sutton, R. S.; Precup, D.; and Singh, S. P. 1999. Between MDPs
and Semi-MDPs: A Framework for Temporal Abstraction in Rein-
forcement Learning. Artif. Intell. 112(1-2):181–211.
Toro Icarte, R.; Klassen, T. Q.; Valenzano, R. A.; and McIlraith,
S. A. 2018. Using Reward Machines for High-Level Task Speciﬁ-
cation and Decomposition in Reinforcement Learning. In ICML.
Toro Icarte, R.; Waldie, E.; Klassen, T. Q.; Valenzano, R.; Castro,
M. P.; and McIlraith, S. A. 2019. Learning Reward Machines for
Partially Observable Reinforcement Learning. In NeurIPS.
Watkins, C. 1989. Learning from Delayed Rewards. Ph.D. Disser-
tation, King’s College, Cambridge, UK.
Weiss, G.; Goldberg, Y.; and Yahav, E. 2018. Extracting Automata
from Recurrent Neural Networks Using Queries and Counterexam-
ples. In ICML.
Xu, Z.; Gavran, I.; Ahmad, Y.; Majumdar, R.; Neider, D.; Topcu,
U.; and Wu, B. 2019. Joint Inference of Reward Machines and
Policies for Reinforcement Learning. CoRR abs/1909.05912.

Intra-Option

