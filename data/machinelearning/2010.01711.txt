A Generative Machine Learning Approach to
Policy Optimization in Pursuit-Evasion Games

1st Shiva Navabi
Electrical and Computer Engineering Department
University of Southern California
Los Angeles, USA
navabiso@usc.edu

2nd Osonde A. Osoba
RAND Corporation
Santa Monica, USA
oosoba@prgs.edu

Abstract—We consider a pursuit-evasion game [11]
played between two agents, ‘Blue’ (the pursuer) and ‘Red’
(the evader), over T time steps. Red aims to attack Blue’s
territory. Blue’s objective is to intercept Red by time T and
thereby limit the success of Red’s attack. Blue must plan its
pursuit trajectory by choosing parameters that determine
its course of movement (speed and angle in our setup)
such that it intercepts Red by time T . We show that Blue’s
path-planning problem in pursuing Red, can be posed as
a sequential decision making problem under uncertainty.
Blue’s unawareness of Red’s action policy renders the
analytic dynamic programming approach intractable for
ﬁnding the optimal action policy for Blue. In this work,
we are interested in exploring data-driven approaches to
the policy optimization problem that Blue faces. We apply
generative machine learning (ML) approaches to learn
optimal action policies for Blue. This highlights the ability
of generative ML model to learn the relevant implicit
representations for the dynamics of simulated pursuit-
evasion games. We demonstrate the effectiveness of our
modeling approach via extensive statistical assessments.
This work can be viewed as a preliminary step towards
further adoption of generative modeling approaches for
addressing policy optimization problems that arise in the
context of multi-agent learning and planning [1].

Index Terms—Generative machine learning, generative
adversarial networks, policy optimization, pursuit-evasion
games, repeated adversarial games, opponent modeling.

I. INTRODUCTION

We consider the problem of optimizing an agent’s
action policy for achieving a desired objective in a multi-
stage game against an opponent. We frame the problem
as a pursuit-evasion game [11] where an agent (Blue)
chases its enemy (Red) with the objective of catching
Red before it reaches a critical region in Blue’s territory.
Such scenarios can arise in practice in aircraft pursuit
interactions. Blue needs to judiciously decide on its
motion-associated parameters (such as speed, orienta-
tion, & acceleration) in order to catch the enemy in a
timely fashion. The strategic nature of the Red agent
imposes a further level of complexity. The Blue agent
needs to dynamically monitor Red’s course of movement
and adjust its path accordingly so as to stand a reasonable
chance of neutralizing Red’s invasion. Blue’s decision
problem also needs to account for inherent physical
constraints (like limited fuel availability) when planning
its path.

A. Framing the Decision Problem

Let A denote the set of admissible actions (i.e., the
admissible motion-associated parameter values) avail-
able to Blue. From a game-theoretic standpoint, Blue’s
decision problem can be formulated as ﬁnding the best
response against Red in each round of the n-stage game:

a∗
i := argmax

a∈A

Qi(a, hi) , i = 1, . . . , n ,

(1)

where a∗
i represents the optimal action for Blue in the
ith stage of the game. a∗
(in (1)) is the maximizer
i
of the value function Qi(·) which depends on Blue’s
action a as well as Blue’s information in the ith stage
denoted as hi. hi includes Blue’s observations of Red’s

0
2
0
2

t
c
O
3
1

]

G
L
.
s
c
[

2
v
1
1
7
1
0
.
0
1
0
2
:
v
i
X
r
a

chosen actions in the unfolded stages of the game. In
a pursuit-evasion game setup Qi(a, hi) may indicate
the effectiveness of Blue’s adopted movement trajectory
(encoded in a) in thwarting Red’s invasion in a timely
fashion. For instance, Qi(a, hi) could be a measure of
the ultimate spatial proximity between Blue and Red in
the terminal stage of the pursuit-evasion game, when
given the information hi Blue chooses action a in stage
i.

We are interested in developing a computational model
for the optimal action policy for Blue’s decision problem
in each stage of the game. Let π∗
i (·) denote the optimal
stochastic action policy for Blue’s decision problem in
the ith stage of the game. Given hi, π∗
i (hi) outputs the
optimal action for Blue in response to Red’s actions as
observed by Blue (included in hi). In this work, we
consider addressing a probabilistic relaxation of Blue’s
policy optimization problem. More precisely, given some
hi in the ith stage of the game we seek to ﬁnd the
stochastic action policy π∗
i (·) such that for any small
(cid:15) > 0

(cid:16)

P

|Qi(π∗

i (hi), hi) − Qi(a∗

i , hi)| > (cid:15)

(cid:17)

≈ 0.

(2)

That is, we aim to ﬁnd the stochastic action policy π∗
i (·)
such that given any hi, it would optimize the value
function Qi(·) with high probability. Focusing on the
probabilistic relaxation in (2) expands the set of appli-
cable models that can suitably represent Blue’s action
policy. In particular, the generative modeling frameworks
such as Generative Adversarial Networks (GANs) [8]
and Variational Autoencoders (VAEs) [13], [17] devel-
oped under the generative machine learning paradigm
[3] seem to be a great ﬁt for this purpose. Given that
generative models can provide implicit representations of
the probability distributions of interest, we can use them
to represent Blue’s (stochastic) action policy. The trained
generative model can be efﬁciently queried for samples
from the target stochastic policy (i.e., π∗
i (·) in our setup)
in response to a Red challenge. The policy responses can
then be ﬁltered or ranked to approach optimality.
We can also rely on Monte Carlo theories and meth-
ods [12], [16] to guarantee useful approximations of
the quality of the policy responses. In principle, this
approach enables us to ﬁnd the best response in any
instance of Blue’s decision problem in (1) with high
probability and rule out sub-optimal or even unfavorable
actions that may be recommended by the generative
model with non-zero probability.

The work reported in this paper shows how we con-
struct and optimize GAN-based decision architectures
and deploy them in a sequential fashion to address
Blue’s decision problem in the multi-stage game against
an adversarial agent (Red). We provide results from
extensive simulation experiments based on a synthetic
two-stage pursuit-evasion game setup to demonstrate
effectiveness of our proposed decision model. Our work
can be viewed as a preliminary step towards further
applications of deep generative modeling approaches

 
 
 
 
 
 
[14] in simultaneously addressing the opponent modeling
[5] and policy optimization [18] problems that are long-
standing challenges in multi-agent systems. Indeed ex-
tensive research is required to address more complicated
aspects of the multi-agent decision problems including
non-stationarity of the agents [10].

II. PROBLEM SETUP

Notation: x1:n is the short-hand for

the vector
(x1, . . . , xn). ∆(A) denotes the space of all probability
distributions with the support equal to the set A. P
denotes the probability measure. Random variables are
denoted by upper case letters (e.g., V, R, B, X, Y, Θ),
their realizations by the corresponding lower case let-
ters (e.g., v, r, b, x, y, θ). N (µ, σ) denotes the Gaussian
probability distribution with mean value µ and standard
deviation σ.

Consider a pursuit-evasion game [11] between two
players: ‘Blue’ (the pursuer) and ‘Red’ (the evader). Blue
attempts to protect its territory against Red’s attack. The
game is played over T time steps in two equally long
consecutive stages. At time t = 0, Red initiates the
game by moving towards a target on Blue’s territory
from its initial location (X R
0 , Y R
0 ) on the 2D plane.
Red’s movement within the ﬁrst T
2 time steps (stage 1)
is modeled as a monotonous motion on the 2D plane,
governed by the initial speed V R
1 and initial angle ΘR
1
parameters that are decided by Red at time t = 0.
Right after Red starts moving, Blue observes the pair of
parameters (V R
1 ) and based on that, starts a chase
towards the point it projects Red to end up after moving
for T time steps in accordance with the speed and angle
T , ˜Y R
pair (V R
T ) denote Red’s destination
as initially projected by Blue based on the observed
parameters (V R

1 ). Let ( ˜X R

1 , ΘR

1 , ΘR

1 , ΘR

1 ).

Blue starts chasing Red from its ﬁxed initial location
(X B
0 , Y B
0 ). Blue’s chase is modeled as a monotonous
motion on the 2D plane, governed by the initial speed
V B
1 that are decided by Blue
1
such that it can catch Red at time t = T at the projected
destination ( ˜X R

and the initial angle ΘB

T , ˜Y R
T ).

At the end of time t = T
, Y B

location (X B
new destination that meets the following two criteria:

2 , Red observes Blue’s current
) and adjusts its path so as to reach a

T
2

T
2

• Red ends up on its safety zone which is delineated
T , ˜Y R
by the perimeter of a circle centered at ( ˜X R
T )
with radius equal to δ% of the distance between
T , ˜Y R
(X R
T ).
• Red reaches the farthest from Blue’s location at
), while remaining on

0 ) and ( ˜X R

0 , Y R

, Y B

2 , i.e., (X B

T
2

T
2

time t = T
its safety circle.

At time t = T

Red’s movement within times t = T
2 + 1, . . . , T is
governed by the new pair of parameters (V R
2 , ΘR
2 ) that
are chosen such that the above two criteria are satisﬁed.
2 Blue notices the alteration in Red’s
trajectory through observing the new pair
movement
2 , ΘR
(V R
2 ). Blue then updates its prediction about Red’s
destination. It then updates its speed and angle parame-
ters to change its course of movement from time t = T
2
onward so that it can catch Red at time t = T . Let
(V B
2 ) denote the speed and angle parameters that
Blue chooses in stage 2. In choosing V B
2 , Blue must
1 + V B
satisfy the constraint V B
2 ≤ V , where V is a
predetermined upper limit. This condition is imposed to
reﬂect constraints such as limited fuel, engine power,
etc that an aircraft faces over the course of an actual
pursuit maneuver [11]. Limitations of this sort call for
far-sighted upfront decisions in Blue’s motion planning
so that it stands a reasonable chance of catching Red
before it destroys Blue’s territory.

2 , ΘB

A. Problem Formulation

In this paper, we are interested in addressing the path
planning problem that Blue faces in pursing Red. We
aim to design action policies that Blue can consult to
optimally choose its speed and angle at each stage of
the game. Let σi denote the stochastic action policy that
, ΘB
generates the speed and angle pair (V B
i ). From now
i
on, we refer to (V B
i ) =: Bi and (V R
i ) =: Ri
i
i
as the action taken by Blue and Red, respectively, in the
ith stage of the game (i = 1, 2).

, ΘB

, ΘR

1) Information Structure and Action Policies: Let
hi denote all the information that Blue knows at the
beginning of stage i. We call hi the history at stage i
which is given as:

h1 := {r1} , h2 := {r1:2, b1} ,

(3)

i , θR

i , θB

where ri = (vR
i ) and bi = (vB
i ) denote the
actions chosen by Red and Blue, respectively, in the ith
stage of the game. Let Hi denote the set of all possible
values of hi. For any h1, σ1(h1) ∈ ∆(B1) is represented
by the conditional probability density function (pdf)
P(B1|h1) =: π1(·|h1) under which action b1 is chosen
in stage i = 1 with probability π1(b1|h1). Similarly,
given the history h2, σ2(h2; V ) ∈ ∆(B2) is represented
by the conditional pdf P(B2|h2, V ) =: π2(·|h2, V )
under which action b2 is chosen in stage i = 2 with
probability π2(b2|h2, V ). Bi := V B
i denotes the
set of admissible actions for Blue in stage i, where V B
i
and ΦB
i are the sets of admissible speed and angle values,
respectively, for Blue in stage i.

i × ΦB

Remark 1. Modeling Blue’s action policies σ1:2 as
stochastic policies is without loss of generality as they
subsume deterministic ones. If the optimal action policy
for Blue turns out to be deterministic, it will manifest
in the probability with which the optimal action is
played under the emergent stochastic policy: the optimal
action will be preferred inﬁnitely higher than the sub-
optimal ones. Furthermore, given that Blue is faced with
continuous action spaces V B
i , i = 1, 2 containing
inﬁnitely many actions, modeling σ1:2 in the form of
probability distributions is more suitable [18, Chapter
13].

i × ΦB

Let ¯h2 := {b1, r1} denote the set of all the information
that Red knows at the beginning of stage i = 2. Let
H2 denote the set of all possible values of ¯h2. Let the
mapping ρ : H2 −→ R2 denote the action policy that
Red consults to choose action R2. That is, for any ¯h2,
ρ(¯h2) outputs some action r2 ∈ R2, where R2 denotes
the set of admissible actions for Red in stage i = 2.

2) Blue’s Decision Problem: Blue’s objective is to
get as close to Red as possible at time step t = T ,1
while satisfying its speed upper bound constraint. Blue’s
problem can then be formulated as follows

(cid:110) »

E

min
σ1:2
subject to V B

1 + V B

2 ≤ V ,

(X B

T − X R

T )2 + (Y B

T − Y R

T )2

where for a ∈ {R, B}

X a

T = X a

0 +

T = Y a
Y a

0 +

T
2
T
2

1 cos(Θa
V a

1) +

1 sin(Θa
V a

1) +

T
2
T
2

2 cos(Θa
V a

2),

2 sin(Θa
V a

2),

(cid:111)

(4)

(5)

(6)

in which realization of the pair (V B
i ) = Bi is output
i
by the stochastic action policy σi(·) as described above.
For Red, realization of the pair (V R
2 ) = R2 is output
by the action policy ρ(·). According to the description

2 , ΘR

, ΘB

1Ideally, Blue wants to catch Red at time t = T , i.e., plan its

movement such that exactly xB

T = xR

T and yB

T = yR
T .

0 , Y R

0 , Y B

0 , Y B

Figure 1: An instance of the two-stage pursuit-evasion game displayed in three snapshots at times t = 0, 10, 20. (a) just
depicts the initial locations of Red and Blue at time t = 0: Red starts its path from (X R
0 ) = (10, 50) (marked by •)
while Blue starts its path from (X B
0 ) = (90, 50) (marked by ×××). (b) depicts Red’s and Blue’s paths traveled during
the ﬁrst stage of the game, i.e., from time t = 0 up until t = 11. Each • and ××× marks Red’s and Blue’s locations,
respectively, at the end of the corresponding time step on their associated paths. Red initiates the game at time t = 0 by
moving from its initial location towards some target on Blue’s territory (see (b)). Blue starts chasing Red from its initial
location (X B
0 ) at time t = 0. (c) shows the full trajectories of Red’s and Blue’s movements as unfolded at termination
of the two-stage game, i.e., time t = 20. The game instance illustrated in (a)-(c) represents a successful chase maneuver
for Blue, i.e., one where Blue’s path coincides with Red’s path on Red’s safety circle delineated in the (c), exactly at time
t = 20, without violating the speed upper bound V , i.e., Blue’s speed parameters satisfy V B
2 ≤ V . The yellow
crosses ××× in (c) mark Red’s path as initially projected by Blue, had it not changed its course of movement in the second
half of the game. As can be seen in (c), at time t = 11 Red deviates from the yellow line due to switching to a new path
governed by a new pair of speed and angle parameters decided based on Red’s observation of Blue’s location at that time.
(d) depicts the pursuit-evasion game with the exact same Red’s path in stage 1 as in (b), in which Blue’s entire path is
planned based on the parameters (V, Θ) that it decides after observing (V R
1 ) at time t = 0. The initial locations of
Red and Blue at time t = 0 are the same as in (a). While Blue’s trajectory emerges as a single line, Red still responds to
its observation of Blue’s location at time t = 11 and updates its path accordingly. As can be seen in (d), at time t = 11
Red deviates from the yellow line toward its updated destination on its safety circle. Remaining on its initially decided
path, Blue therefore ends up near the point it initially had projected Red to get to by t = 20, i.e., the end-point of the
yellow line.

1 + V B

1 , ΘR

of the two-step game, ρ can be characterized in terms of
the solution to the following functional optimization:

ρ := argmax

f

subject to

(cid:113)

(X R

T − X B

)2 + (Y R

T − Y B

T
2

)2

(7)

T
2

(X R

T , Y R

T ) on Red’s safety circle,

T , Y R

where (X R
2 , ΘR
(V R
being optimized in (7).

T ) are given by (5)-(6)

in which
2 ) = R2 are output by the mapping f that is

Remark 2. Note that Red can be viewed as a stationary
agent [10], [4] in the sense that its strategy for plan-
ning its course of movement remains unchanged in re-
sponse to Blue’s actions: its action policy ρ for deciding
(V R
2 ) is always determined from the optimization
problem in (7).

2 , ΘR

The pair of parameters (V R

1 ) = R1 that Red uses
to initiate the game are drawn at random from some
probability distribution with predetermined statistics in
a way that would direct Red towards Blue’s territory.

1 , ΘR

Assumption 1. The policy ρ is not known to Blue.

From Equations (4)-(6) it

is clear that Blue’s ob-
jective in (4) depends on its choice of the parameters
(V B
2 ) encapsulated in actions B1 and
B2. Let J(B1:2) denote Blue’s objective in (4).

1 ), (V B

2 , ΘB

1 , ΘB

III. SOLUTION METHOD

In this section we develop a solution method for

addressing Blue’s decision making problem in (4).

A. Dynamic Program

Given that Blue faces a sequential decision making
problem under uncertainty, the optimal action policies
σ∗
1:2 can be characterized as the solution to a dynamic
program with the value functions given below:

U2(h2) :=

=:

min
σ2(h2;V )∈∆(B2)
min
σ2(h2;V )∈∆(B2)

(cid:104)
E

J(b1, σ2(h2; V )) | h2

ν2(h2, σ2(h2; V ))

U1(h1) :=

=:

min
σ1(h1)∈∆(B1)
min
σ1(h1)∈∆(B1)

(cid:104)
E

U2(H2) | h1

(cid:105)

ν1(h1, σ1(h1)),

(cid:105)

(8)

(9)

is

the collection of

where H2
random variables
{R1:2, B1}. The functions ν1(·) and ν2(·) are referred
to as cost-to-go in stages 1 and 2, respectively.

Assumption 1 implies that Blue does not know the
function form of the mapping J(·). Therefore, the opti-
mal policies σ∗
1:2 cannot be found analytically through
solving the dynamic program in (8)-(9) simply because
they are not well-deﬁned from Blue’s perspective.

While Blue’s problem cannot be solved analytically,
if we have data samples containing motion-associated
parameters (i.e., actions) chosen by Red and Blue in
numerous game scenarios, Blue’s policy optimization
problem can then be resolved through a data-driven
approach. Given a sufﬁciently rich and diverse data set of
numerous game scenarios played by Red and Blue, Red’s
action policy ρ can be learned from those sample game
scenarios. Given the stationarity of Red as an agent (see
Remark 2), once a suitable learning model has captured
and encoded a sufﬁciently accurate representation of ρ
through exposure to many data sampels, it can be used
to ﬁnd the optimal action policies σ∗

1:2 for Blue.

In this paper, we explore a generative machine learn-
ing approach to address Blue’s decision making problem
through ﬁnding implicit representations of σ∗
1:2. Several
paradigms are developed for constructing and optimizing
generative models [7]. Variational Autoencoders (VAEs)
[13], [17] and Generative Adversarial Networks (GANs)
[8] are among the most popular frameworks. In this
work, we design and train GAN architectures as decision
models that implicitly learn representations of the proba-
bility distributions underlying the optimal action policies
σ∗
1:2. These optimized GAN-based decision models can
then be queried to output the optimal choice of actions
B1 and B2. We use a large (synthetic) data set con-
taining numerous scenarios of the described two-stage
pursuit-evasion game played by Red and Blue. We use
the feature values associated with each game instance
to train, optimize and evaluate the constructed GAN
architectures.

Since the optimal policies σ∗

i , i = 1, 2 take the
form of conditional probability distributions, denoted as
1(·|h1), π∗
π∗
2(·|h2, V ), we borrow the class-conditional
implementation of GANs proposed in [15] and [6]. We
input Blue’s observations to the generative model in
order to properly direct the actions output by the model.

¯vR [spatial units / time step]
5

σR
v
0.7

¯θR [degrees]
60◦

σR
θ
8◦

V
12

δ
10

T
20

Table I: Simulation setup.

Additionally we consider inputting other information
features into the generative model, such as the upper
bound on the speed values for Blue (i.e., V ) in order to
properly preserve the coupling between Blue’s decisions
in the two stages of the game. In sequel, we describe
our data set and the structure of the generative models
that we constructed.

B. Simulated Trajectories

1 , θR

1 ), (vB

We use a synthetic data set that contains 15000 in-
stances of the described two-stage pursuit-evasion game
played between Red and Blue. Each instance of the
game is recorded with its associated feature values in
{(vR
2 ), dRB},
where dRB denotes the Euclidean distance between the
end-points of Red’s (i.e., (X R
20, Y R
20)) and Blue’s (i.e.,
(X B
20 )) corresponding trajectories traveled in that
instance (see the objective in (4)). V − vB
1 is the speed
upper bound for vB

2 in the given game instance.

2 , V − vB

1 ), (vR

2 ), (vB

20, Y B

1 , θB

1 , θB

2 , θR

1 , θR

To generate each pair of trajectories for the two
the values of the parameters (V R
1 ) that
players,
initiate a game instance, are drawn at random from a pair
v ) and N (¯θR, σR
of Gaussian distributions N (¯vR, σR
θ ),
where ¯vR and ¯θR are the mean values and, σR
v and σR
θ
denote the standard deviations. The values of the remain-
1 , θB
ing parameters (vB
1 ), (vR
2 ) cor-
1 , θR
responding to each random draw of the pair (V R
1 )
were simulated according to the description of the two-
stage pursuit-evasion game at the beginning of Section
II.

2 , V −vB

2 ), (vB

1 , θB

2 , θR

For the particular data set generated to carry out the
experiments presented in the current paper, the statistics
of the Gaussian distributions as well as the upper bound
V were selected such that around 88% of the generated
game instances constituted a successful pursuit maneuver
for Blue, i.e., resulting in end-point distances dRB = 0.
The simulation setup used to synthesize the game in-
stances for the experiments discussed in this paper is
outlined in Table I.

1 +V B

Figure 1 demonstrates an instance of the described
two-stage pursuit-evasion game in three snapshots. In
the game instance displayed in Figure 1.(a)-(c), Blue
successfully catches Red at time t = 20 without violating
the speed constraint V B
2 ≤ V (as evident in Figure
1.(c)). Figure 1 contrasts Blue’s two-step path planning
with a single-step path planning where Blue plans its
entire path at time t = 0, without updating its speed
and angle parameters in response to the change in Red’s
course of movement that occurs in stage 2 (see Figure
1.(d)). As a result, Blue fails to catch Red at time t = 20.
Instead, Blue ends up at the destination it initially pro-
jected for Red, i.e., the end-point of the yellow-crossed
line. The yellow-crossed line marks Red’s trajectory, had
it not updated its path at time t = 11.

C. Generative Model Architectures

In this work, following the conditional variant of
GANs, we construct two generator networks, one for
Blue’s decision at each stage of the game. Let Gi
denote the generator network that is trained to represent
the conditional pdf π∗
i which characterizes the optimal
stochastic policy σ∗
i . Once trained and optimized, given
Blue’s observation of Ri, generator Gi can be queried
to output bi as the action recommended to Blue in stage
i.

The input-output structure of the generative networks
that we constructed are shown in Figure 2. Generator
G1 (the green block) is fed Blue’s observation of R1

(cid:104)(cid:104)(cid:104)(cid:104)(cid:104)(cid:104)(cid:104)(cid:104)(cid:104)(cid:104)(cid:104)

Hyper-parameters

Module
Generative Network
Discriminative Network

# neurons in HL1 # neurons HL2

Input Noise Dimension

96
64

64
32

2
2

Table II: GAN Architecture Setting: the generative and
discriminative networks each constitute two hidden layers
denoted as HL1 and HL2.

as input along with a random draw of the independent
Gaussian noise Z1 and a quality score s1. These features
altogether are then decoded by the generative network
into the action b1 that determines Blue’s path in stage 1.
The quality score s1 is a measure of the effectiveness of
action b1 that is output by G1 in response to the observed
value of R1. In our work, for the training phase we use
a normalized version of the Euclidean distance between
the end-points of Red’s and Blue’s corresponding spatial
trajectories in each instance of the game, as the quality
score s1. Later, we elaborate on the procedure that we
use to construct the score s1 for each sample pair of Red
and Blue trajectories.

Generator G2 (the blue block in Figure 2) is fed more
information as inputs compared to G1: In addition to
the independent latent noise draw Z2 and the observed
realizations of R1 and R2, G2 is also fed the upper-
bound (V −vB
1 ) on the stage 2 speed V B
2 so as to capture
and preserve the coupling between Blue’s decisions in
the two consecutive stages of the game. Moreover, the
quality score s2 is fed to G2 so as to direct the generator
towards outputting a highly effective action B2 for Blue
in response to the realized R1 and R2. Similar to s1,
the quality score s2 is generated based on a normalized
version of the Euclidean distance between the end-points
of Red’s and Blue’s corresponding paths in each game
instance. More speciﬁcally,
RB denote the end-
point distance between Red and Blue’s corresponding
paths in the ith game instance in the data set and let
η(di
RB normalized
across the training data set. 0 and 1 are the normalized
lower and upper bounds, respectively, on the normalized
end-point distance values in the data set. We then deﬁne
si
2 := 1 − η(di
RB) as the quality score assigned to a pair
of Red’s and Blue’s paths with the end-point distance
RB.2 Therefore, the smaller the distance di
di
RB, the larger
the corresponding score si
2. After the model is trained,
we can query generator G2 with high score values s2
within the normalized [0, 1] regime to guide it towards
outputting highly effective actions B2 for Blue in stage
2.

RB) ∈ [0, 1] denote the distance di

let di

From the dynamic programming formulation in (8)-
(9) it is clear that the characterization of σ∗
1 depends
on the terminal value function U2(·) and thus, requires
σ∗
2 to be resolved. Therefore, given that G1 implicitly
represents σ∗
1(·), its training requires G2 to be trained.
Given the quality scores s2 computed across the training
data samples as described above, we ﬁrst train generator
G2 and then use that to construct the quality scores
s1 for all the game instances in the training data set.
These scores are then used to train generator G1. Both
generators are modeled with fully-connected multi-layer
neural networks. The setup that we used to construct
the GAN architectures in terms of the constituent hyper-
parameters is outlined in Table II.3 Next, we describe the
procedure we designed to construct the quality scores s1.

2Note that quality score s2 computed as such for a pair of Red
and Blue trajectories associated with some h2, b2, is nothing but a
normalized version of the cost-to-go function ν2(·) in (8) evaluated
at h2, b2. Indeed the end-point distance dRB resulting from h2, b2
equals ν2(h2, b2).

3The setup outlined in Table II was chosen after experimentation
with several architectures with different numbers of hidden layers,
neurons in each layer, etc.

1) Construction of the quality score s1: Assuming
generator G2 is trained, the procedure that we use to
construct the quality scores s1 for the game instances
in the data set is outlined in Algorithm 1. For the ith
game instance, the values of the features {(R1:2), V −
V B
1 }i along with the maximum normalized quality score
¯s2(≈ 1) and the random noise input Z2 are fed to the
optimized G2 to generate action B2. Using a Monte
Carlo sampling approach, for each game instance, G2
is queried NM C times (e.g., 30 times) to generate
NM C recommendations for B2. The resultant end-point
distances dj
RB corresponding to each generated action

NM C(cid:80)
j=1

:=

1
NM C

(B2)j are then averaged as αi

dj
RB.
These averaged quantities αi’s associated with each
game instance in the data set, are then stacked and
normalized across the entire data set. So that given each
αi, η(αi) ∈ [0, 1] gives its normalized value. Then, for
the ith game instance: si

1 = 1 − η(αi).

The quantities αi are connected to the cost-to-go
function ν1(·) in (9) in the same way that the end-point
distances di
RB are connected to ν2(·) in (8) (see footnote
2). Basically, given the feature values h1, b1 (see (3))
associated with the ith game instance, the corresponding
quantity αi represents an approximation of ν1(h1, b1)
(see (8)). Therefore given the input features h1, b1, the
quality score mapping si
1 = 1 − η(·) approximately
outputs a normalized version of ν1(h1, b1).

Algorithm 1 Pseudocode for construction of s1 scores

1: for i = 1 to |D| do
di ←− [
]
2:
for j = 1 to NM C do
3:
4:

query G2 with the input

feature values
1 }i associated with the ith game in-

{r1:2, V − vB
stance, ¯s2(≈ 1) and the latent noise draw z2

Use (b2)j output by G2, to obtain the corre-
RB between the resul-

sponding end-point distance dj
tant Red and Blue trajectories
di ←− [ di , dj

RB ]

end for
αi ←− average of the entries in di vector
1 ←− 1 − η(αi)
si

5:

6:
7:

8:
9:
10: end for
11: return {si

1}|D|

i=1

IV. EVALUATION OF THE SEQUENTIAL DECISION
ARCHITECTURE

After G1 and G2 are trained, they can be queried
sequentially to generate the actions B1 and B2, respec-
tively. The evaluation procedure is illustrated in Figure 2.
For each R1 that initiates a game instance, G1 is queried
with the realized R1 and the score ¯s1(≈ 1), as well as
a random noise draw z1. The action B1 output by G1 is
then used to plan Blue’s spatial trajectory in stage 1 in
response to Red’s path induced by the realized R1. The
action R2 that is chosen by Red in stage 2 is recovered
(see the pink block in Figure 2) from Red’s action policy
ρ (see (7)). Action R2 that is observed by Blue in stage
2 is then fed to G2 along with the realizations of the
other input features (see Figure 2). G2 outputs the action
B2 which is used by Blue to plan its path in stage 2
in response to Red’s updated trajectory. The resultant
end-point distance dRB can then be calculated according
to the Euclidean distance metric in (4). These distances
are then aggregated across all the game instances in the
test data set to statistically assess the performance of the
decision model.

Figure 2: Illustration of the procedure used to test the
two-step decision model.

A. Decision Benchmarks

We considered two different benchmark decision mod-
els to assess the performance of our proposed two-
step decision model against them. We describe these
benchmarks below.

Single-step decision benchmark: Under this bench-
mark decision policy, Blue plans its entire trajectory
based solely on its initial observation of R1. This bench-
mark, too, is constructed using the GAN model, but it
consists of a single generator that is queried with the
observed value of R1 in stage 1 as well as the random
noise input.4 It then recommends action B that is used
by Blue to plan its entire trajectory in the form of a
single line over the course of the two stages of the
game. Under this single-step benchmark, observation of
R2 is not incorporated to adjust Blue’s trajectory in stage
2. Comparison of our two-step decision model against
this benchmark would thus shed light on the effect of
incorporating Blue’s mid-course observation of R2 in
the quality of its long-range path planning.

An example of the pursuit-evasion game where Blue
continues on a single path that it plans based solely on
its initially decided speed and angle parameters (V, Θ) is
shown in Figure 1.(d). Note that Blue still faces the speed
constraint V B
2 = 2V ≤ V . Hence if 2V > V ,
Blue’s speed in stage 2 drops to V − V .

1 + V B

Randomized two-step decision benchmark: To
demonstrate the effect of using GAN architectures in
constructing the decision model, we also consider a pair
of randomized decision policies with statistics inferred
from the training data set. More speciﬁcally, under the
randomized decision benchmark, the pair of speed and
angle parameters (V B
i ) that constitutes action Bi,
i
are drawn from a two-dimensional Gaussian distribution
θ]T denotes the mean
N (
vector and Σi denotes the covariance matrix. The statis-
tics of these Gaussian distributions are given by the
corresponding sample statistics computed based on the
samples in the training data set.

µi, Σi) where,
¯

:= [µi

v, µi

, ΘB

µi
¯

B. Generated Trajectories: Examples

Figure 3 demonstrate two sets of pursuit-evasion game
scenarios (one per row) that emerge under our proposed
two-step decision model (left column), single-step (mid-
dle column) and the randomized (right column) decision
benchmarks. In each of the three images shown within
each row in Figure 3, the game is initiated by the same
realized action R1. Therefore, we can visually compare
how Blue responds to the same Red’s path in stage 1
under each of the three decision models. In these exam-
ples it is visually evident that the path generated for Blue
using the actions recommended by the two-step decision
model has enabled Blue to get much closer to Red’s
destination at time t = 20 compared to the benchmarks.
We observe that the Blue trajectories generated under

4The generator in this GAN-based decision benchmark was trained
using a procedure very similar to the one we used to train G1 and G2
(see Section III-C).

the two-step decision model almost coincide with Red’s
paths at time t = 20. However, the trajectories that result
under the benchmarks end up at points much farther from
the end-point of Red trajectory.

C. Statistical Assessment

To statistically evaluate the performance of our pro-
posed decision architecture, we generated spatial trajec-
tories for Blue using the actions recommended by the
two-step decision model, in response to Red’s initiated
paths in all the game instances in the test data set which
contained 3750 samples. For each game instance we also
generated trajectories for Blue using the single-step and
randomized decision benchmarks. For each resultant pair
of Red and Blue trajectories under each of these three
decision models, we recorded the corresponding end-
point distances between the paths.

i and dr

We computed the difference between the end-point
distance values that result under the two-step model and
the two benchmarks, on each game instance. Let d∗
i
denote the end-point distance between Red and Blue
trajectories that emerge in the ith game instance under
the two-step model. Let ds
i denote the end-point
distances between Red and Blue trajectories in the same
game instance, that emerge under the single-step and
randomized decision benchmarks, respectively. Deﬁne
δ∗s
i as the difference between the end-point
i
distances that result under the two-step model (d∗
i ) and
the single-step benchmark (ds
i ) in the ith game instance.
In a similar fashion deﬁne and interpret the distance
measures δ∗r
i for the
i
ith game instance.

i and δsr
i

i − dr

i − dr

i − ds

:= d∗

:= ds

:= d∗

We trained 50 instances of the two-step decision
model and evaluated each of them separately. In each
of these experiments 75% of the samples were used for
training while 25% were used for testing. While testing
each trained instance of the two-step decision model,
we computed the values of the three measures δ∗s
, δ∗r
i
i
and δsr
across all the 3750 game instances in the test
i
data set, and stored their sample-mean values for each of
the trained 50 instances of the two-step decision model.
These sample-mean values are box plotted in Figure 4.
Box plots of the average δ∗r and δsr quantities are
displayed in rows 1 and 2, respectively, in Figure 4(a).
We see that all the resultant values including the few out-
liers are negative. This implies that on an aggregate level
both two-step and single-step decision models which are
GAN-based architectures, outperform the randomized
decision benchmark in terms of the resultant end-point
distances between Red and Blue trajectories. Figure 4.(b)
displays the box plot corresponding to the average δ∗s
quantities. Again all the resultant values are negative
which indicates the superiority of the two-step decision
model to the single-step benchmark, in terms of the
end-point distance between Red and Blue trajectories.
These assessments support the idea that incorporating
Blue’s mid-course observations in adaptively planning its
trajectory in response to alterations in Red’s path leads
to more effective paths for Blue in terms of their ultimate
closeness to Red’s destination.

D. Speed Constraint Satisfaction

Recall

that Blue faces a constrained optimization
problem in planning its trajectory: sum of its speed
values in stages 1 and 2 cannot exceed the upper bound
V (see (4)). Therefore, it would be interesting to examine
whether the speed values output by the GAN-based
decision architectures satisfy this constraint. This would
then demonstrate the capability of these GAN-based
models in implicitly learning and encoding constraints
of this sort. To investigate this property, we recorded
the number of speed constraint violations that occurred

Decision Model
Two-step decision model
Single-step decision benchmark
Randomized decision benchmark

# Speed constraint violations
247
46
102

Table III: Speed constraint violations occurred under
each decision model.

under each decision model when evaluating them on the
test data set (3750 samples). The results are outlined in
Table III. We observe that the two-step decision model
has resulted in the highest number of speed constraint vi-
olations among the three decision models. Whereas, the
single-step decision benchmark has resulted in the fewest
of such violations with relatively signiﬁcant difference.
The number of constraint violations being the highest
under the two-step decision model, might be attributed
to its greater model complexity. Recall that the two-
step decision model consists of two generators that are
queried in a sequential fashion (see Figure 2). Therefore,
the number of input features as well as the number of
constituent neural networks in the structure of the two-
step model is much larger compared to those in the
single-step model which consists of a single generator.
Nevertheless, the number of speed constraint violations
is relatively small
three models, compared to
the size of the test data set (e.g., ≈ 6.6% of the test
data samples, under the two-step model). Therefore, in
practice the decision model can be queried multiple
times to obtain feasible recommendations for the speed
parameter. This observation is solely reﬂective of the
these experiments.
data set
Further studies are needed in order to achieve more
conclusive observations and insights about the relation
between the model complexity and implicit learning of
the problem constraints.

that we used to conduct

in all

E. Quality Scores Sensitivity Analysis

that

As discussed in Section III-C, the quality scores s1,
s2 fed to the two-step decision model as part of the
input features (see Figure 2) are intended to provide
some control over the effectiveness of the actions rec-
ommended by the model. Recall
in our design,
higher score values within the regime [0, 1] are indicative
of better trajectories for Blue. Therefore, we expect
the model
to give rise to more effective trajectories
for Blue once queried with higher values of s1 and
s2. To test
this hypothesis, we queried the two-step
decision model with various settings for s1, s2 values.
For each setting we contrasted the input values for
s1, s2 with the quality score computed for the emerging
Red and Blue trajectories. More precisely, let di(s1, s2)
denote the end-point distance between the Red and
Blue trajectories that emerge when the model is queried
with s1, s2 values. Let η(di(s1, s2)) ∈ [0, 1] denote the
normalized version of the distance di(s1, s2), where the
normalization carried out via η(·) is with reference to
the end-point distance values in the training data set.
We then use 1 − η(di(s1, s2)) as the realized quality
score associated with the ith game instance in the test
data set. Figure 5 shows the histograms of these realized
quality scores under three different settings for s1 and
s2 input values. We observe that on an aggregate level,
these realized scores are relatively correlated with the
input values for s1 and s2: the higher the input score
values, the higher the realized quality score. As can
be seen, under the settings s1 = 0.95, s2 = 0.98 and
s1 = 0.55, s2 = 0.6 the great majority of the realized
quality scores lie above 0.8, with the skewness being
further negative under the former. Whereas, the smaller
input score values s1 = 0.15, s2 = 0.2 have resulted in
much poorer realized scores: nearly half of the emerging

Figure 3: Examples of Red’s and Blue’s corresponding trajectories that emerged under the actions generated by the two-
step decision model (left column), single-step (middle column) and randomized (right column) decision benchmarks. In
the images in each row, Red initiates the game with the exact same realization of R1.

gives rise to. By inputting higher score values in the
normalized regime [0, 1] we can prompt the two-step
model to generate better trajectories for Blue, i.e., ones
that enable Blue to get closer to Red’s destination by
time t = 20.

V. CONCLUSION
We studied a two-stage pursuit-evasion game played
between two agents, Blue (the pursuer) and Red (the
evader), over T = 20 time steps. We focused on the
decision making problem that Blue faces, i.e., choosing
its motion-associated parameters (speed and angle) such
that it can catch Red at time T . We developed generative
model architectures to implicitly learn and represent
Blue’s optimal action policy for deciding its speed and
angle parameter values in each stage of the game. In
particular, we constructed GAN architectures consisting
of two generative networks that need to be queried in
a sequential fashion to generate the optimal actions for
Blue in each stage of the game. We devised a scoring
system that can be used to control the quality of the
actions output by the model, in terms of the effectiveness
of the pursuit path they give rise to for Blue. We
conducted various statistical assessments to demonstrate
performance of the developed framework. The obtained
results suggest that generative modeling methods offer
considerable potential for addressing the strategic long-
range decision making problems based on data-driven
approaches.

Extending the present study to consider pursuit-
evasion game scenarios in presence of more sophisticated
path-planning constraints beyond the speed limitations,
is an interesting future direction. Moreover, investigating
pursuit-evasion games under an inﬁnite time-horizon is
an important extension to the present work that needs to
be explored in future. In addition, experimenting with
other generative modeling frameworks such as VAEs
would provide further insights into the effectiveness of
generative machine learning paradigm for policy opti-
mization in multi-agent planning problems.

Finally, the decision models discussed in this paper
implicitly incorporate approximations of the Red agent’s

Figure 4: Box plots of the summary statistics (sample av-
erages) of the difference between each pair of models, in
terms of the resultant end-point distances. (a) corresponds
to the average difference between the GAN-based models
and the randomized benchmark. (b) corresponds to the av-
erage difference between the two-step decision model and
the single-step benchmark. Notice that all the resultant
values are negative. This means that both GAN-based
models outperform the randomized benchmark (a) and,
the two-step decision model is superior to the single-step
benchmark (b). The plots are based on the evaluation of
50 separately trained instances of the two-step decision
model.

game scenarios in the test set have scored below 0.8 in
this case.

The observations we made based on Figure 5 imply
that the input features s1, s2 provide some control over
the quality of the trajectories that the two-step model

Figure 5: Histograms of the emerging quality scores resulting under three different settings of the quality score values s1
and s2 fed to the two-step decision model. The histogram skewness becomes further negative as the input values for s1
and s2 increase: the higher the input scores, the smaller the resultant end-point distances between the emerging Red and
Blue trajectories.

[16] Shakir Mohamed, Mihaela Rosca, Michael Figurnov, and Andriy
Mnih. Monte carlo gradient estimation in machine learning. arXiv
preprint arXiv:1906.10652, 2019.

[17] Danilo Jimenez Rezende, Shakir Mohamed, and Daan Wierstra.
Stochastic backpropagation and approximate inference in deep
generative models. arXiv preprint arXiv:1401.4082, 2014.
[18] Richard S Sutton and Andrew G Barto. Reinforcement learning:

An introduction. MIT press, 2018.

behavior. Modeling adversary behavior in a game is
referred to as opponent modeling. Our work is partic-
ularly related to implicit opponent modeling [1, Section
4.8.1] where certain aspects of the opponent’s strategy or
behavior are implicitly encoded in various representation
forms to be used for downstream computations such as
policy optimization. Further work is needed to explore
the development and incorporation of better opponent
models in the game discussed here. For example, He
et al.
in [9] develop a framework where instead of
explicitly predicting the opponent’s behavior, a hidden
representation of the opponent is learned and then used
in [2]
to compute an adaptive response. Bard et al
construct a portfolio of policies ofﬂine and then use
online learning algorithms to select the best response
strategy from the portfolio during online interactions.

REFERENCES

[1] Stefano V Albrecht and Peter Stone. Autonomous agents mod-
elling other agents: A comprehensive survey and open problems.
Artiﬁcial Intelligence, 258:66–95, 2018.

[2] Nolan Bard, Michael Johanson, Neil Burch, and Michael Bowl-
ing. Online implicit agent modelling. In Proceedings of the 2013
international conference on Autonomous agents and multi-agent
systems, pages 255–262, 2013.

[3] Yoshua Bengio et al. Learning deep architectures for ai. Foun-
dations and trends® in Machine Learning, 2(1):1–127, 2009.
[4] Lucian Bus¸oniu, Robert Babuˇska, and Bart De Schutter. Multi-
In Innovations in
agent reinforcement learning: An overview.
multi-agent systems and applications-1, pages 183–221. Springer,
2010.

[5] David Carmel and Shaul Markovitch. Opponent modeling in
multi-agent systems. In International Joint Conference on Arti-
ﬁcial Intelligence, pages 40–52. Springer, 1995.

[6] Jon Gauthier. Conditional generative adversarial nets for con-
volutional face generation. Class Project for Stanford CS231N:
Convolutional Neural Networks for Visual Recognition, Winter
semester, 2014(5):2, 2014.

[7] Ian Goodfellow. Nips 2016 tutorial: Generative adversarial

networks. arXiv preprint arXiv:1701.00160, 2016.

[8] Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu,
David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua
In Advances in neural
Bengio. Generative adversarial nets.
information processing systems, pages 2672–2680, 2014.

[9] He He, Jordan Boyd-Graber, Kevin Kwok, and Hal Daum´e III.
Opponent modeling in deep reinforcement learning. In Interna-
tional Conference on Machine Learning, pages 1804–1813, 2016.
[10] Pablo Hernandez-Leal, Michael Kaisers, Tim Baarslag, and En-
rique Munoz de Cote. A survey of learning in multiagent
arXiv preprint
environments: Dealing with non-stationarity.
arXiv:1707.09183, 2017.

[11] Rufus Isaacs. Differential games: a mathematical theory with
applications to warfare and pursuit, control and optimization.
Courier Corporation, 1999.

[12] Herman Kahn. Applications of monte carlo. Technical report,

RAND Corp., Santa Monica, Calif., 1954.

[13] Diederik P Kingma and Max Welling. Auto-encoding variational

bayes. arXiv preprint arXiv:1312.6114, 2013.

[14] Durk P Kingma, Shakir Mohamed, Danilo Jimenez Rezende, and
Max Welling. Semi-supervised learning with deep generative
models. In Advances in neural information processing systems,
pages 3581–3589, 2014.

[15] Mehdi Mirza and Simon Osindero.

Conditional generative

adversarial nets. arXiv preprint arXiv:1411.1784, 2014.

