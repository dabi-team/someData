Welfare-Preserving ε-BIC to BIC Transformation with
Negligible Revenue Loss∗

Vincent Conitzera, Zhe Fengb, David C. Parkesc, and Eric Sodomkad

aDuke University
conitzer@cs.duke.edu
bGoogle Research
zhef@google.com
cHarvard University
parkes@eecs.harvard.edu
dFacebook Research
sodomka@facebook.com

August 3, 2021

Abstract

In this paper, we provide a transform from an ε-BIC mechanism into an exactly BIC mecha-
nism without any loss of social welfare and with additive and negligible revenue loss. This is the
ﬁrst ε-BIC to BIC transformation that preserves welfare and provides negligible revenue loss.
The revenue loss bound is tight given the requirement to maintain social welfare. Previous ε-BIC
to BIC transformations preserve social welfare but have no revenue guarantee (Bei and Huang,
2011), or suﬀer welfare loss while incurring a revenue loss with both a multiplicative and an ad-
ditive term, e.g., Daskalakis and Weinberg (2012); Rubinstein and Weinberg (2018); Cai et al.
(2021). The revenue loss achieved by our transformation is incomparable to these earlier ap-
proaches and can be signiﬁcantly less. Our approach is diﬀerent from the previous replica-
surrogate matching methods and we directly make use of a directed and weighted type graph
(induced by the types’ regret), one for each agent. The transformation runs a fractional rotation
step and a payment reducing step iteratively to make the mechanism Bayesian incentive compat-
ible. We also analyze ε-expected ex-post IC (ε-EEIC) mechanisms (D¨utting et al., 2014). We
provide a welfare-preserving transformation in this setting with the same revenue loss guarantee
for uniform type distributions and give an impossibility result for non-uniform distributions.
We apply the transform to linear-programming based and machine-learning based methods of
automated mechanism design.

1
2
0
2

g
u
A
3

]
T
G
.
s
c
[

3
v
9
7
5
9
0
.
7
0
0
2
:
v
i
X
r
a

∗

Part of the work was done when Zhe Feng was a PhD student at Harvard University, where he was supported by

a Google PhD fellowship. The ﬁrst version of this paper was posted on arXiv on July 19, 2020.

 
 
 
 
 
 
1

Introduction

Optimal mechanism design is very challenging in multi-dimensional settings such as those for selling
multiple items, such as those that arise in the sale of wireless spectrum licenses or the allocation
of advertisements to slots in internet advertising. Recognizing this challenge, there is considerable
interest in adopting algorithmic approaches to address these problems of economic design. These
include polynomial-time black-box reductions from multi-dimensional revenue maximization to the
algorithmic problem for virtual welfare optimization, e.g.,(Cai et al., 2012b,a, 2013), and the ap-
plication of methods from linear programming (Conitzer and Sandholm, 2002, 2004) and machine
learning (D¨utting et al., 2014; Feng et al., 2018; Duetting et al., 2019) to automated mechanism
design.

Moreover, it is common in practical settings that it is important consider both social welfare
(eﬃciency) and revenue. For example, national governments that use auctions to sell wireless
spectrum licenses care both about the eﬃciency of the allocation as this promotes valuable use as
well as the revenue that ﬂows from auctions into the budget. In regard to online advertising, there
are various works that explore this trade-oﬀ between welfare and revenue. Display advertising has
focused on yield optimization (i.e., maximizing a combination of revenue and the quality of ads
shown) (Balseiro et al., 2014), and work in sponsored search auctions has considered a squashing
parameter that trades oﬀ eﬃciency and revenue (Lahaie and Pennock, 2007). At the same time,
there is a surprisingly small theoretical literature that considers both welfare and revenue properties
together (e.g., Diakonikolas et al. (2012)).

At the same time, the use of computational methods for economic design often comes with a
limitation, which is that the output mechanism may only be approximately incentive compatible
(IC); e.g., the black-box reductions are approximately IC when the algorithmic problems are solved
in polynomial time, the LP approach works on a discretized space to reduce computational cost
but thereby achieves a mechanism that is only approximately IC in the full space, and the machine
learning approaches train a mechanism over ﬁnite training data and achieve approximate IC on the
full type distribution. While it has been debated as to whether approximate incentive compatibility
may suﬃce, e.g., (Carroll, 2012; Lubin and Parkes, 2012; Azevedo and Budish, 2019), this does add
an additional layer of unpredictability to the performance of a designed mechanism. First, the fact
that an agent can gain only a small amount from deviating does not preclude strategic behavior—
perhaps the agent can easily identify a useful deviation, for example through repeated interactions,
that reliably provides increased proﬁt. This can be a problem when strategic responses lead to
an unraveling of the desired economic properties of the mechanism (we provide such an example
in this paper). The possibility of strategic reports by participants has additional consequences as
well, for example making it more challenging for a designer to conﬁdently measure ex-post welfare
after outcomes are realized.

For the above reasons, there is considerable interest in methods to transform an ε-Bayesian
incentive compatible (ε-BIC) mechanism to an exactly BIC mechanism (Daskalakis and Weinberg,
2012; Rubinstein and Weinberg, 2018; Cai et al., 2021), or an ε-expected ex-post IC (ε-EEIC) mech-
anisms (D¨utting et al., 2014; Duetting et al., 2019) into an exactly BIC mechanism. The main
question we want to answer in this paper is:

Given an ε-BIC/ε-EEIC mechanism, is there an exact BIC mechanism that maintains
social welfare and achieves negligible revenue loss compared with the original mechanism
under truthful reports? If so, can we ﬁnd the transformed, BIC mechanism eﬃciently?

In this paper, we provide the ﬁrst ε-BIC to BIC transform that is welfare-preserving while
also ensuring only negligible revenue loss relative to the baseline mechanism. This simultaneous

2

attention to the properties of both welfare and revenue is of practical importance. An immediate
corollary of our main result is the well known result from economic theory, namely that eﬃcient
allocations can be implemented in an incentive-compatible way. For example, the transform can
be applied to a ﬁrst-price, sealed-bid auction to achieve an eﬃcient and BIC auction.

Our approach is diﬀerent from the previous replica-surrogate matching methods and we directly
make use of a directed and weighted type graph (induced by the types’ regret), one for each agent.
The transformation runs a fractional rotation step and a payment reducing step iteratively to make
the mechanism Bayesian incentive compatible.

The transform also satisﬁes another appealing property, which is that of allocation-invariance.
The transformed mechanism maintains the same distribution on outcomes, allocations for example,
as the baseline mechanism (focusing here on the non-monetary part of the output of the mech-
anism).1 This property is useful in many scenarios. Consider, for example, a principal such as
Amazon that is running a market and also incurs a resource cost for diﬀerent outcomes (e.g. ware-
house storage cost). With this allocation-invariance property, then not only is the welfare the same
(or better) and the revenue loss negligible, but the resource cost (averaged over iterations of the
mechanism) of the principal is preserved by the transform.

1.1 Model and Notation

. Let

i be the joint type proﬁle of the other agents,

. Each agent
We consider a general mechanism design setting with a set of n agents N =
}
i has a private type ti. We denote the entire type proﬁle as t = (t1, . . . , tn), which is drawn from a
joint distribution
Fi. Let
Fi be the marginal distribution of agent i and
Ti be the support of
i be the associated marginal type distribution.
t
−
Let
i, respectively. In this setting, there
is a set of feasible outcomes denoted by
, typically an allocation of items to agents. Later in
the paper, we sometimes also use “outcome” to refer to the output of the mechanism, namely the
allocation together with the payments, when this is clear from the context.

F
T1 × · · · × Tn and

i be the support of

1, . . . , n
{

F−
F

and

F−

T−

O

=

T

denote the jth possible type of agent i, where j

We focus on the discrete type setting, i.e.,
= mi. Let t(j)
i
R

Ti is a ﬁnite set containing mi possible types, i.e.,
[mi]. For all i and ti,
∈
0 is a valuation that maps a type ti and outcome o to a non-negative real number.
), possibly
= (x, p) is a pair of allocation rule xi :
0. We slightly abuse notation, and also use vi
, with the expectation taken with respect

|Ti|
vi : (ti, o)
≥
A direct revelation mechanism
randomized, and expected payment rule pi :
to deﬁne the expected value of bidder i for mechanism
to the randomization used by the mechanism, that is

T →

T →

∆(

M

M

→

O

R

≥

i, ˆt

∀

∈ T

, vi(ti, x(ˆt)) = E

x(ˆt)[vi(ti, o)],

o

∼

(1)

for true type ti and reported type proﬁle ˆt. When the reported types are ˆt = (ˆt1, . . . , ˆtn), the output
Mi(ˆt) = (xi(ˆt), pi(ˆt)). We deﬁne the utility of agent i
of mechanism
with true type ti and a reported type ˆti given the reported type proﬁle ˆt
i of other agents as a
−
quasilinear function,

for agent i is denoted as

M

For a multi-agent setting, it will be useful to also deﬁne the interim rules.

ui(ti,

(ˆt)) = vi(ti, x(ˆt))

M

pi(ˆt).

−

(2)

Deﬁnition 1 (Interim Rules of a Mechanism). For a mechanism
payment rule p, the interim allocation rule X and payment rule P are deﬁned as,
Et
i[pi(ti; t

i)], Pi(ti) = Et

i[xi(ti; t

with allocation rule x and
i, ti ∈ Ti, Xi(ti) =

i)].

M

∀

i

i

∈F−

−
1This allocation-invariance is ex ante, i.e., it is with respect to the prior distribution over types.

−

∈F−

−

−

3

In this paper, we assume we have oracle access to the interim quantities of mechanism

.
M

Assumption 1 (Oracle Access to Interim Quantities). For any mechanism
, given any type
proﬁle t = (t1, . . . , tn), we receive the interim allocation rule Xi(ti) and payments Pi(ti), for all
i, ti.

M

We deﬁne the menu of a mechanism

in the following way.

M

Deﬁnition 2 (Menu). For a mechanism
menu size of agent i is denoted as

.
|Mi|

, the menu of bidder i is the set

M

{Mi(t)
}t

∈T

. The

In mechanism design, there is a focus on designing incentive compatible mechanisms, so that
truthful reporting of types is an equilbrium. This is without loss of generality by the revelation
principle.

It has also been useful to work with approximate-IC mechanisms, and these have been studied in
various papers, e.g. (Daskalakis and Weinberg, 2012; Cai and Zhao, 2017; Rubinstein and Weinberg,
2018; Cai et al., 2021; D¨utting et al., 2014; Duetting et al., 2019; Feng et al., 2018; Balcan et al.,
2019; Lahaie et al., 2018; Feng et al., 2019).

In this paper, we focus on two deﬁnitions of approximate incentive compatibility, ε-BIC and

ε-expected ex post incentive compatible (ε-EEIC).

Deﬁnition 3 (ε-BIC Mechanism). A mechanism

is ε-BIC iﬀ for all i, ti,

M

Et

−

i

∼F−

i[ui(ti,

(t))]

M

≥

max
ˆti
i

∈T

Et

−

i

∼F−

i[ui(ti,

(ˆti; t

M

i))]

−

−

ε

Deﬁnition 4 (ε-expected ex post IC (ε-EEIC) Mechanism (D¨utting et al., 2014)). A mechanism

is ε-EEIC if and only if for all i, Et

M

maxˆti

∈T

i ui(ti,

(ˆti; t

M

i))

−

−

ui(ti,

(t))

M

ǫ.

≤

is ε-EEIC iﬀ no agent can gain more than ε ex post regret, in expectation
A mechanism
M
(where ex post regret is the amount by which an agent’s utility can be
over all type proﬁles t
improved by misreporting to some ˆti given knowledge of t, instead of reporting its true type ti). A
0-EEIC mechanism is essentially DSIC.2

∈ T

(cid:2)

(cid:3)

We can also consider an interim version of ε-EEIC, termed as ε-expected interim IC (ε-EIIC),

which is deﬁned as

Eti

i
∼F

Et

−

i

∼F−

i [ui(ti,

(ti; t

M

i))]

−

Eti

i
∼F

≥

(cid:2)

(cid:3)

max
t′i∈T
i

(cid:20)

Et

−

i

i

∼F−

ui(ti,

(t′i; t

M

i))

−

(cid:2)

ε

−

(cid:21)

(cid:3)

All our results for ε-EEIC to BIC transformation hold for ε-EIIC mechanism. Indeed, we prove
that any ε-EEIC mechanism is also ε-EIIC in Lemma 1 in the Appendix.

Another important property of mechanism design is individual rationality (IR), and we deﬁne
two standard versions of IR (ex-post/interim IR) in Appendix B. The transformation that we
provide from ε-BIC/ε-EEIC to BIC preserves individual rationality:
if the original mechanism is
interim IR then the mechanism achieved after transformation is interim IR, and if the the original
mechanism is ex-post IR then the mechanism achieved after transformation is ex-post IR.

For a mechanism

, let RM(

) and W M(

M

F

respectively, when agent types are sampled from
applies equally to an IC or non-IC mechanism.

F

F

) represent the expected revenue and social welfare,
truthfully 3. This deﬁnition

and they play

M

2For discrete type settings, 0-EEIC is exactly DSIC. For the continuous type case, a 0-EEIC mechanism is DSIC

up to zero measure events.

3In this paper, we consider the revenue and welfare performance of the untruthful mechanisms with truthful
reports, which is commonly used in the literature. It is an interesting future direction to consider the performance of
untruthful mechanisms under equilibrium reporting.

4

Deﬁnition 5 (Expected Social Welfare and Revenue). For a mechanism
types drawn from distribution
F
and the expected social welfare for truthful reports is W M(

, the expected revenue for truthful reports is RM(

) = Et

M

[

) = Et
F
n
i=1 vi(ti, x(t))].

∼F

= (x, p) with agents’

n
i=1 pi(t)],

F

∼F

[

P

We focus on welfare-preserving transforms that provide negligible revenue loss.

P

Deﬁnition 6 (Welfare-preserving Transformation with Negligible Revenue Loss). Given an ε-
, a welfare-preserving transform that provides
BIC/ε-EEIC mechanism
W M(
negligible revenue loss outputs a mechanism
RM(

M′ such that, W M′(
F

over type distribution

r(ε), where r(ε)

) and RM′(

0 as ε

M

0.

≥

≥

F

F

F

)

)

)

F

−

→

→

1.2 Previous ε-BIC to BIC transformations

There are existing algorithms for transforming any ε-BIC mechanism to an exactly BIC mecha-
nism with only negligible revenue loss (Daskalakis and Weinberg, 2012; Rubinstein and Weinberg,
2018; Cai et al., 2021). The central tools and reductions in these papers build upon the method of
replica-surrogate matching (Hartline and Lucier, 2010; Hartline et al., 2011; Bei and Huang, 2011).
Here we brieﬂy introduce replica-surrogate matching and its application to an ε-BIC to BIC trans-
formation.
Replica-surrogate matching. For each agent i, construct a bipartite graph Gi = (
The nodes in
agent i,
Fi. The nodes in
true type ti is added in
of the edge between a replica r(j)

Ri ∪ Si, E).
Ri are called replicas, which are types sampled i.i.d. from the type distribution of
Fi. In particular, the
Ri. There is an edge between each replica and each surrogate. The weight
is induced by the mechanism, and deﬁned as

Si are called surrogates, and also sampled from

and a surrogate s(k)

wi(r(j)
i

, s(k)) = Et

−

i

i

∈F−

vi(r(j)
i

, x(s(k)
i

, t

−

(1

η)

Et

−

·

−

−

i

i

∈F−

pi(s(k)
i

, t

−

.

(3)

i)
i

h

The replica-surrogate matching computes the maximum weight matching in Gi.

i

h

i

i))
i

M

M′ = (x, (1

ε-BIC to BIC transformation by Replica-Surrogate Matching (Daskalakis and Weinberg,
2012). We brieﬂy describe this transformation, deferring the details to Appendix A. Given a mech-
= (x, p), this transformation constructs a bipartite graph between replicas (include the
anism
true type ti) and surrogates, as described above. The approach then runs VCG matching to com-
pute the maximum weighted matching for this bipartite graph, and charges each agent its VCG
payment. For unmatched replicas in the VCG matching, the method randomly matches a sur-
rogate. Let
η)p) be the modiﬁed mechanism. If the true type ti is matched to a
surrogate si, then agent i uses si to compete in
M′ is x(s), given matched
surrogate proﬁle s, and the payment of agent i (matched in VCG matching) is (1
η)pi(s) plus the
VCG payment from the VCG matching, where η is the parameter in replica-surrogate matching .
If ti is not matched in the VCG matching, the agent gets nothing and pays zero.
This replica-surrogate matching transform does not preserve welfare.

Indeed, the replica-
surrogate matching transformation must suﬀer welfare loss in some cases.4 Turning to revenue, the
is
revenue loss of the replica-surrogate matching mechanism relative to the orginal mechanism
guaranteed to be at most ηRev(

M′. The outcome of

(Daskalakis and Weinberg, 2012; Rubinstein and Weinberg,

M

)+

−

−

M

O

nε
η

(cid:16)

(cid:17)

4The previous ε-BIC to BIC transformations (Daskalakis and Weinberg, 2012; Rubinstein and Weinberg, 2018;
Cai et al., 2021) don’t state the welfare loss guarantee clearly. Consider Example 1 shown in Section 1.3, the original
ε-BIC mechanism already maximizes welfare and the optimal allocation is unique, any unmatched type in replica-
surrogate matching creates a welfare loss. Particularly, the welfare loss is unbounded when (inappropriately) choosing
η < ε
√m

1 in replica-surrogate matching.

−

5

2018), and has both a multiplicative and an additive term. Cai et al. (2021) proposes a poly-
nomial time algorithm for performing this transform with only sample access to the type dis-
tribution and query access to the original ε-BIC mechanism. The transform extends replica-
surrogate matching and Bernoulli factory techniques proposed by Dughmi et al. (2017) to handle
negative weights in the bipartite graph and provides the same revenue property as the previous
work (Daskalakis and Weinberg, 2012; Rubinstein and Weinberg, 2018), without preserving social
welfare.5 In this work, we assume oracle access to the interim quantities of the original ε-BIC mech-
anism, following the model of Hartline and Lucier (2010); Hartline et al. (2011); Bei and Huang
(2011); Daskalakis and Weinberg (2012); Rubinstein and Weinberg (2018). How to generalize the
proposed transform to the setting that only has sample access to the type distribution and runs in
polynomial time will be an interesting future work.

The black-box reduction of Bei and Huang (2011) focuses on preserving welfare only. Indeed,
it can be regarded as a special case of this replica-surrogate matching method, where the weight
of the bipartite graph only depends on the valuations and not the prices (η = 1 in Eq. (3)), and
the replicas and surrogates are both
Ti (there is no sampling for replicas and surrogates). For
this reason, the transform described in Bei and Huang (2011) can preserve social welfare but may
provide arbitrarily bad revenue (see Example 1).

1.3 Our Contributions

We ﬁrst state the main result of the paper, which provides a welfare-preserving transform from
approximate BIC to exact BIC with negligible revenue loss. This result holds for the general
1 agents and independent private types and is not restricted to
mechanism design setting with n
allocation problems.

≥

M

Main Result 1 (Theorem 6). With n
IR mechanism
reports, there exists a BIC and IR mechanism
R
access to the interim quantities of
P
most poly(
i |Ti|

1 agents and independent private types, and an ε-BIC and
that achieves W expected social welfare and R expected revenue given truthful
M′ that achieves at least W social welfare and
ε revenue. The transformation is (ex ante) allocation-invariant. Given an oracle
M′ is at

, the running time of the transformation from

n
i=1 |Ti|

M

M

to

≥

−

).

P

The transformation works directly on the type graph of each agent, and it is this that allows
us to maintain social welfare— indeed, we may even improve social welfare in our transformation.
In contrast, the transformation from Bei and Huang (2011) can incur unbounded revenue loss (see
Example 1, in which it loses all revenue) and existing approaches (Daskalakis and Weinberg, 2012;
Cai and Zhao, 2017; Rubinstein and Weinberg, 2018; Cai et al., 2021) with negligible revenue loss
can lose social welfare (see Example 1).

Choosing η = √ε, the revenue loss of existing transforms (Daskalakis and Weinberg, 2012;
Cai and Zhao, 2017; Rubinstein and Weinberg, 2018; Cai et al., 2021) is at most √εRev(
) +
O(n√ε), with both a multiplicative and an additive-loss in revenue, while our revenue loss is
additive. In the case that the original revenue, Rev(
), is order-wise smaller than the number
of types, i.e., Rev(
), the existing transforms provide a better revenue bound (at

) = o(

M

M

M

i |Ti|

P

5Dughmi et al. (2017) propose a general transformation from any black-box algorithm A to a BIC mechanism that
only incurs negligible loss of welfare, with only polynomial number queries to A, by using Bernoulli factory techniques.
This approach has no guarantee on the revenue loss. Cai et al. (2021) generalize Bernoulli factory techniques in the
replica-surrogate matching to transform any ε-BIC mechanism to a BIC mechanism that only incurs negligible loss
of revenue, with polynomial number queries to the original ε-BIC mechanism and polynomial number samples from
the type distribution.

6

some cost of welfare loss). But when the revenue is relatively larger than the number of types,
i.e., Rev(
), our transformation can achieve strictly better revenue than these earlier
approaches while also preserving welfare.

) = Ω(

i |Ti|

M

Before describing our techniques we illustrate these properties through a single agent, two
), our

outcome example in Example 1. We show that even for the case that Rev(M ) = o(
transformation can strictly outperform existing transforms w.r.t revenue loss.

i |Ti|

P

P

t(1),
{

T

=

Example 1. Consider a single agent with m types,
, where the type distribution
}
is uniform. Suppose there are two outcomes, the agent with type t(j)(j = 1, . . . , m
1) values
outcome 1 at 1 and values outcome 2 at 0. The agent with type t(m) values outcome 1 at 1 + ε and
outcome 2 at √m. The mechanism
gives outcome 1 to the agent with a price of 1, and if the agent reports type t(m),
2 to the agent with a price of √m.
expected revenue achieved by

∈
M
−
gives outcome
is ε-BIC, because the agent with type t(m) has a regret ε. The
maximizes social welfare, 1 + √m
1
m .
−
m revenue and preserves

Our transformation decreases the payment of type t(m) by ε for a loss of ε

we consider is: if the agent reports type t(j), j

M
is 1 + √m
m . In addition,
−

M

M

M

M

· · ·

[m

1],

−

1

, t(m)

the social welfare.

The transformation by Bei and Huang (2011) preserves the social welfare, however, the VCG
payment (envy-free prices) is 0 for each type. Therefore, Bei and Huang (2011)’s approach loses
all revenue.

Moreover, the approaches that make use of replica-surrogate matching (Daskalakis and Weinberg,
2012; Rubinstein and Weinberg, 2018; Cai et al., 2021, e.g.) lose at least ε
1 revenue, which
is about (√m + 1) times larger than the revenue loss of our transformation. We argue this claim
by a case analysis,

m + ε
√m

−

• If η

≥

ε
√m

1 , the VCG matching is the identical matching and the VCG payment is 0 for
−

each type. In total, the agent loses at least η

√m+m

−

1

ε

m + ε
√m

1 expected revenue.

∈
(1

• If η < ε
√m
−
[m
−
η)

1 , the agent with type t(m) will be assigned outcome 1 (t(m) is matched to some
1], in VCG matching) and the VCG payment is η. Thus, type t(m) loses at least
1], if t(j) is matched in VCG
1].
1

t(j), j
1 revenue. For any type t(j), j
√m
matching, the VCG payment is 0, since it will be matched to another type t(k), k
Each type t(j), j
expected revenue.
√m

−
∈
−
1] loses at least η revenue. Overall the agent loses at least √m
m

[m
−
In addition, since the type t(m) is assigned outcome 1, we lose at least

η = √m

[m

[m

−

−

−

−

−

∈

∈

ε

·

m

≥

−

1
−
m

−

expected social welfare.

Moreover, there is a chance that a type is not matched, in which case the social welfare is

reduced.

M
f (t)x′(t) =

Our transformation satisﬁes also satisﬁes an appealing allocation-invariance property (see Def-
= (x, p), the transform outputs a BIC mechanism
inition 7). Given an ε-BIC mechanism
M′ = (x′, p′) that satisﬁes
f (t)x(t). As noted above, this property would
t
∈T
be of interest, for example, to a principal who is operating the logistics for provisioning goods
sold through the mechanism. Because of allocation-invariance, the principal knows that the dis-
tribution on goods sold is unchanged as a result of the transform and thus logistical aspects in
regard to inventory storage are unchanged. The previous transformations (Bei and Huang, 2011;
Daskalakis and Weinberg, 2012; Rubinstein and Weinberg, 2018; Cai et al., 2021) don’t satisfy this
allocation-invariance property.

t
∈T

P

P

We also support ε-expected ex-post IC (ε-EEIC), which is motivated by work on the use of ma-
chine learning to achieve approximate IC mechanisms in multi-dimensional settings (D¨utting et al.,
2014; Feng et al., 2018; Duetting et al., 2019). In comparison with ε-BIC, the ε-EEIC metric only

7

guarantees at most ε ex-post gain in expectation over type proﬁles, with no interim guarantee for
any particular type. It is incomparable in strength with ǫ-BIC because ε-EEIC also strengthens
ε-BIC in working with ex-post regret rather than interim regret. Our second main result shows
how to transform an ε-EEIC mechanism to a BIC mechanism. For this, we need the additional
assumption of a uniform type distribution and prove that this is necssary to achieve a transform
with suitable properties.

Main Result 2 (Informal Theorem 5 and Theorem 6). For n
1 agents with independent uniform
type distribution, our ε-BIC to BIC transformation can be applied to an ε-EEIC mechanism and all
results in Main Result 1 hold here. For a non-uniform type distribution, we show an impossibility
result for an ε-EEIC to BIC, welfare-preserving transformation with only negligible revenue loss,
even for the single agent case.

≥

Moreover, we also argue that our revenue loss bounds are tight given the requirement to maintain

social welfare. This holds for both ε-BIC mechanisms and ε-EEIC mechanisms.

Main Result 3 (Informal Theorem 2 and Theorem 7). There exists an ε-BIC/ε-EEIC and IR
mechanism for n
1 agents with independent uniform type distribution, for which any welfare-
preserving transformation must suﬀer Ω(

ε) revenue loss.

≥

i |Ti|

We also apply the transform to automated mechanism design in Section 5, considering both a
linear-programming and machine learning framework and looking to maximize a linear combination
of expected revenue and social welfare, i.e., µλ(
), for some
λ

. We summarize the result of this application.

[0, 1] and type distribution

) + λW M(

λ)RM(

) = (1

,
M

−

F

F

F

P

∈

F

n

=

Main Result 4 (Informal Theorem 10 and Theorem 11). For n agents with independent type
T1 × · · · × Tn and an α-approximation LP algorithm ALG to output an
distribution
i=1Fi on
×
T
αOPT, there exists a BIC and IR
)
ε-BIC (ε-EEIC) and IR mechanism
,
with µλ(
≥
F
M
n
ε. Given oracle access to the interim
mechanism
M′, s.t., µλ(
λ)
i=1 |Ti|
M′ is at most poly(
, rtALG(x)),
quantities of
M
) is the running time of ALG and x is the bit complexity of the input. Similar results
where rtALG(
·
hold for a machine-learning based approach, in a PAC learning manner.

, the running time to output the mechanism

i=1 |Ti|

M
αOPT

M′,

F
(1

on

P

P

−

−

≥

F

)

Compared with the previous transformations that are able to achieve negligible revenue loss (Daskalakis and Weinberg,

2012; Rubinstein and Weinberg, 2018; Cai et al., 2021), our transformation achieves a better blended
objective of welfare and revenue when λ is close to 1 since we preserve welfare of the original mech-
anism after transformation.

1.4 Our Techniques

Instead of constructing a bipartite replica-surrogate graph, our transformation makes use of a
directed, weighted type graph, one for each agent. For simplicity of exposition, we can consider a
single agent with a uniform type distribution.

Given an ε-BIC mechanism,

, E), where each node represents a
, we construct a graph G = (
possible type of the agent and there is an edge from node t(j) to t(k) if the output of the mechanism
for type t(k) is weakly preferred by the agent for true type t(j) in
u(t(j),
misreporting t(k), i.e.,

≥
(t(j))). The weight wjk of edge (t(j), t(k)) is deﬁned as the regret of type t(j) by not

, i.e. u(t(j),

(t(k)))

M

M

M

M

T

wjk = u(t(j),

(t(k)))

M

u(t(j),

ε(t(j))).

M

−

8

(4)

The transformation method then iterates over the following two steps, constructing a trans-
formed mechanism from the original mechanism. We brieﬂy introduce the two steps here and defer
to Figure 2 for detailed description.

Step 1. If there is a cycle

in the type graph with at least one positive-weight edge, then all
types in this cycle weakly prefer their descendant in the cycle and one or more strictly prefers their
descendant. In this case, we “rotate” the outcome and payment of types against the direction of
the cycle, to let each type receive a weakly better outcome compared with its current outcome. We
repeat Step 1 until all cycles in the type graph are removed.

C

Step 2. We pick a source node, if any, with a positive-weight outgoing edge (and thus regret
for truthful reporting). We decrease the payment made by this source node, as well as decreasing
the payment made by each one of its ancestors (note the lack of cycles at this point) by the same
amount, until we create a new edge in the type graph with weight zero, such that the modiﬁcation
to payments is about to increase regret for some type. If at any point we create a cycle, we move to
Step 1. Otherwise, we repeat Step 2 until there are no source nodes with positive-weight, outgoing
edges.

The algorithm works on the type graph induced by the original, approximately IC mechanism,
, and directly modiﬁes the mechanism for each type, to make the mechanism IC. This allows
M
the transformation to preserve welfare and provides negligible revenue loss. Step 2 has no eﬀect
on welfare, since it only changes (interim) payment for each type. Step 1 is designed to remove
cycles created in Step 2 so that we can run Step 2, while preserving welfare simultaneously. Both
steps reduce the total weight of the type graph, which is equivalent to reducing the regret in the
mechanism to make it IC. We illustrate the transform in Fig. 1.

For a single agent with non-uniform type distribution, we handle the unbalanced density prob-
ability of each type by redeﬁning the type graph, where the weight of the edge in type graph is
weighted by the product of the probability of the two nodes that are incident to an edge. We
propose a new Step 1 by introducing fractional rotation, such that for each cycle in the type graph,
we rotate the allocation and payment with a fraction for any type t(j) in the cycle. By carefully
choosing the fraction for each type in the cycle, we can argue that our transformation preserves
welfare and provides negligible revenue loss.

The multi-agent setting reduces to the single-agent case, building a type graph for each agent
induced by the interim rules (see Appendix C.6 for the construction of this type graph). With
oracle access to the interim quantities of the original mechanism, we build the type graph of each
agent i in poly(
) time. We then apply the transform for each type graph of agent i, induced by
the interim rules.

|Ti|

This is analogous to a replica-surrogate matching approach, which also deﬁnes the weights
between replicas and surrogates by interim rules and runs the replica-surrogate matching for the
reported type of each agent. Replica-surrogate matching uses this sampling technique to make
the distribution of reported types of each agent equal to the distribution of the true type.
In
comparison, Steps 1 and 2 of our transform leave the type distribution unchanged, so that the
transform attains this property for free. Then we can apply our transformation for each type graph
separately. The new challenge in our transformation is feasibility, i.e., establishing consistency of
the agent-wise rotations to interim quantities. We show the transformation for each type graph
guarantees feasibility by appeal to Border’s lemma (Border, 1991). Our transformation can also be
directly applied to an ε-EEIC mechanism in the case that each agent has an independent uniform
type distribution.6

6This need to transform an infeasible,

IC mechanism into a feasible and IC mechanism also arises in
Narasimhan and Parkes (2016), who use a method from Hashimoto (2018) to correct for feasibility violations that

9

t(1)

t(2)

Type graph G = (

T

, E)

Update the graph

Step 1

t(l)

t(1)

t(3)

t(2)

Step 2

Update the graph

t′

t(1)

The ancestors of t(1)

T

Figure 1: Visualization of the transformation for a single agent with a uniform type distribution: we start
, E), where each edge (t(1), t(2)) represents the agent weakly prefers the allocation
from a type graph G(
and payment of type t(2) rather than his true type t(1). The weight of each edge is denoted in Eq. (4). In the
graph, we use solid lines to represent the positive-weight edges, and dashed lines to represent zero-weight
edges. We ﬁrst ﬁnd a shortest cycle, and rotate the allocation and payment along the cycle and update the
graph (Step 1). We keep doing Step 1 to remove all cycles. Then we pick a source node t(1), and decrease
the payment of type t(1) and all the ancestors of t(1) until we reduce the weight of one outgoing edge from
t(1) to zero or we create a new zero-weight edge from t′ to t(1) or one of the ancestors of t(1) (Step 2).

2 Warm-up: Single agent with Uniform Type Distribution

j

∀

∈

, i.e.

[m], f (t(j)) = 1

In this section, we consider the case of a single agent and a uniformly distributed type distribution
m . Even for this simple case, the proof is non-trivial. Moreover, the
F
technique for this simple case can be extended to handle more intricate cases. The main result
in this section is Theorem 1, which makes use of a constructive proof to modify a ε-EEIC/ε-BIC
mechanism to a BIC mechanism. An interesting observation is that ε-EEIC may only provide mε-
BIC for a uniform type distribution, which indicates that transforming ε-EEIC may incur a worse
revenue loss bound. However, Theorem 1 shows we can achieve the same revenue loss bound for
both ε-BIC and ε-EEIC.

Theorem 1. Consider a single agent, with m diﬀerent types
uniform type distribution
expected social welfare and R expected revenue, there exists a BIC and IR mechanism
achieves at least W expected social welfare and R
running time of the transformation from

, and a
, which achieves W
(cid:9)
M′ that
, the
M

. Given an ǫ-EEIC/ε-BIC and IR mechanism

mε revenue. Given an oracle access to

M

· · ·

to

=

F

).

(cid:8)

T

t(1), t(2),

, t(m)

−
M′ is at most poly(

|T |

M

Proof Sketch. We construct a weighted directed graph G = (

T
result from statistical machine learning while preserving strategy-proofness.

, E) induced by mechanism

,
M

10

(cid:8)

(cid:9)

· · ·

M

, t(l)

t(1), t(2),

= (x, p), ﬁnd the shortest cycle

Step 1 (Rotation step). Given the graph G induced by
C
in G that contains at least one edge with positive weight. Without loss of generality, we represent
=
. Then rotate the allocation and payment rules for these nodes in cycle
C
. Now we slightly abuse the notation of subscripts, s.t. t(l+1) = t(1). Speciﬁcally, the allocation
C
and payment rules for each t(j)
, x′(t(j)) = x(t(j+1)), p′(t(j)) = p(t(j+1)). For other nodes,
[l], x′(t(j)) = x(t(j)), p′(t(j)) = p(t(j)). Then
we keep the allocation and payment rules, i.e.
we update the mechanism
by adopting allocation and payment rules x′, p′ to form a new
M′, and update the graph G (We still use G to represent the updated graph for
mechanism
notation simplicity). If there are no cycles in G that contain at least one positive-weight-edge,
move to Step 2. Otherwise, we repeat Step 1.
Step 2 (Payment reducing step). Given the current updated graph G and mechanism
M′,
pick up a source node t, i.e., a node with no incoming positive-weight edges. Let outgoing
edges with positive weights associated with node t be a set of Et, and let εt be the minimum
non-negative regret of type t, i.e.

j /
∈

∈ C

M

∀

εt =

min
t(j):(t,t(j))

Et

∈

u(t,

′(t(j)))

M

u(t,

′(t))

M

−

i
h
t′ ∈ T
t′
Consider the following set of nodes St ⊆ T
The weight zero edge is also counted as a directed edge. Denote εt as
(cid:12)
(cid:12)

, such that St =

} ∪ {

t
{

εt = min
St,¯t
t′ /
∈
∈

St

u(t′,

′(t′))

M

u(t′,

−

M

′(¯t))

(5)

is the ancestor of t

.
}

(6)

(cid:3)
Then we decrease the expected payment of all ¯t
. This process will only create
εt, εt}
St by min
∈
{
new edges with weight zero. If we create a new cycle with at least one edge with positive weight
in E, we move to Step 1. Otherwise, we repeat Step 2.

(cid:2)

Figure 2: ε-BIC/ε-EEIC to BIC transformation for single agent with uniform type distribution

following the approach shown in Section 1.4. We apply the iterations of Step 1 and Step 2 (see
Fig. 2), to reduce the total weight of edges in E to zero.

First, we show the transformation maintains IR, since neither Step 1 nor Step 2 reduces utility.
We then argue that the transformation in Fig. 2 will reduce the total weight of the graph to zero
with no loss of social welfare, and incur at most mε revenue loss. To show this, we prove the
following two auxiliary claims in Appendix C.1 and C.2, respectively.

Claim 1. Each Step 1 achieves the same revenue and incurs no loss of social welfare, and reduces
the total weight of the graph by at least the weights of cycle

.

C

Claim 2. Each Step 2 can only create new edges with zero weight, and does not decrease social
welfare. Each Step 2 will reduce the weight of each positive-weight, outgoing edge associated with t
by min

, where ¯εt and εt are deﬁned in Eq. (5) and Eq. (6) respectively.

εt, εt}
{

Given the above two claims, we argue our transformation incurs no loss of social welfare.
The transformation only loses revenue at Step 2, for each source node t, we decrease at most
payments over all the types.7 In this transformation, after each Step 1 or Step 2, the
m min
εt, εt}
{
weight of the outgoing edge of each node t is still bounded by maxj
.

(t(j)))

u(t,

u(t,

(t))

M

−

M

(cid:9)
7Actually, we can get a slightly tighter bound. Since no cycle exists in the type graph after Step 1, there is at
least one node is not the ancestor of t. Therefore the revenue decrease is bounded by (m − 1) min{εt, εt}, actually.

(cid:8)

11

This is because Step 1 does not create new outcome (allocation and payment) and Step 2 will
not increase the weight of each edge. Therefore, in Step 2, we decrease payments by at most
m maxj
in order to reduce the weights of all outgoing edges associated
(t))
with t to zero. Therefore, the total revenue loss in expectation is

(t(j)))

u(t,

u(t,

M

M

−

(cid:8)

(cid:9)

1
m ·

Xt
∈T

m max

j

u(t,

(cid:16)

(t(j)))

M

u(t,

−

(t))

M

(cid:17)

mε,

≤

where the inequality is because of the deﬁnition of ε-BIC/ε-EEIC mechanism.
Running time. At each Step 1, we strictly reduce the weight of one edge with positive weight
to 0 in the graph. The running time of each Step 1 and Step 2 is poly(
). In total, there are at
most

2 edges. Thus, the total running time is poly(

|T |

).

|T |

|T |

2.1 Lower Bound on Revenue Loss

In the transformation in Figure 2, the revenue loss is bounded by mε. This revenue loss bound is
tight up to a constant factor while insisting on maintaining social welfare.

Theorem 2. There exists an ε-BIC (ε-EEIC) and IR mechanism
for a single agent with uniform
type distribution for which any ε-BIC and IR to BIC and IR transformation (without loss of social
welfare) must suﬀer at least Ω(mε) revenue loss.

M

}

T

∀

≥

−

=

· · ·

, t(m)

t(1),
{

and f (t(j)) = 1/m,

2, the agent with type t(j) values outcome j

Proof. Consider a single agent with m types,
j. There
are m possible outcomes. The agent with type t(1) values outcome 1 at ε and the other outcomes
at 0. For any type t(j), j
1 at jε, outcome j at
jε, and the other outcomes at 0. The original mechanism is: if the agent reports type t(j), gives
the outcome j to the agent and charges jε. There is a ε regret to an agent with type t(j+1) for not
reporting type t(j), thus the mechanism is ε-BIC. Since this ε-BIC mechanism already maximizes
social welfare, we cannot change the allocation in the transformation. Thus, we can only change
the payment of each type to reduce the regret. Consider the sink node t(1), to reduce the regret of
the agent with type t(2) for not reporting t(1), we can increase the payment of type t(1) or decrease
the payment of type t(2). However, increasing the payment of type t(1) breaks IR, then we can only
decrease the payment of t(2). To reduce the regret between t(2) to t(1), we need to decrease the
payment of t(2) at least by ε. After this step, the regret of type t(3) for not reporting t(2) will be at
least 2ε and t(2) will be the new sink node. Similarly, t(3) needs to decrease at least 2ε payment (if
t(2) increase the payment, it will envy the output of t(1) again). So on and so forth, and in total,
1)ε
the revenue loss is at least ε+2ε+

1)ε

···

−

.

+(m
m

= (m
−
2

2.2 Tighter Bound of Revenue Loss for Settings with Finite Menus

In some settings, the total number of possible types of an agent may be very large and yet the
menu size can remain relatively small. In particular, suppose that a mechanism
has a small
m, where m is the number of types and C is the menu
number of outputs, i.e.,
size. Given this, we can provide a tighter bound on revenue loss for this setting in the following
theorem. The complete proof is deferred to Appendix C.3.

= C and C

|M|

M

≪

Theorem 3. Consider a single agent with m diﬀerent types
a uniform type distribution
. Given an ǫ-BIC mechanim
that achieves S expected social welfare and R revenue, there exists an BIC mechanism
achieves at least S social welfare and R

t(1), t(2),
{
with C diﬀerent menus (C

, sampled from
}
m)
≪
M′ that

Cε revenue.

T
M

, t(m)

· · ·

=

F

−

12

3 Single Agent with General Type Distribution

In this section, we consider a setting with a single agent that has a non-uniform type distribution.
A naive idea is that we can “divide” a type with a larger probability to several copies of the same
type, each with equal probability, and then apply our proof of Theorem 1 to get a BIC mechanism.
However, this would result in a weak bound on the revenue loss, since we would divide the m types
into multiple, small pieces. This section is divided into two parts. First we show our transformation
for an ε-BIC mechanism in this setting. Second, we show an impossibility result for an ε-EEIC
mechanism, that is, without loss of welfare, no transformation can achieve negligible revenue loss.

3.1

ε-BIC to BIC Transformation

We propose a novel approach for a construction for the case of a single agent with a non-uniform
type distribution. The proof is built upon Theorem 1, however, there is a technical diﬃculty to
directly apply the same approach for this non-uniform type distribution case. Since each type has
a diﬀerent probability, we cannot rotate the allocation and payment in the same way as in Step 1
in the proof of Theorem 1.

We instead redeﬁne the type graph G = (

, E), where the weight of the edge is now weighted
by the product of the probability of the two nodes that are incident to an edge. We also modify
the original rotation step shown in Fig. 2 in Appendix C.4: for each cycle in the type graph, we
rotate the allocation and payment with the fraction of f (t(k))
for any type t(j) in the cycle, where
f (t(j))
f (t(k)) is the smallest type probability of the types in the cycle. This step is termed as ”fractional
rotation step.” We summarize the results in Theorem 4 and show the proof in Appendix C.4.

T

Theorem 4. Consider a single agent with m diﬀerent types,
a general type distribution
social welfare and R expected revenue, there exists a BIC and IR mechanism
mε revenue.
least W social welfare and R

. Given an ε-BIC and IR mechanim
(cid:8)

drawn from
· · ·
that achieves W expected
(cid:9)
M′ that achieves at

M

=

F

T

t(1), t(2),

, t(m)

−

Allocation-invariant Transformation. In addition to the welfare and revenue guarantee achieved
by this transformation, the transform has another desired property, as deﬁned below.

Deﬁnition 7 (Allocation-invariance property). Two mechanisms
are (ex ante) allocation-invariant if and only if

f (t)x(t) =

t
∈T

= (x, p) and
f (t)x′(t).

M′ = (x′, p′)

M
t
∈T

For the single agent setting with a general type distribution, the transform only changes the
allocation rules in Step 1. Since we use the fractional rotation in Step 1, the quantity
f (t)x(t)
is maintained after each Step 1. Then, it is straightforward to show that the transform satisﬁes
this allocation-invariance property.8

t
∈T

P

P

P

3.2

Impossibility Result for ε-EEIC Transformation

As mentioned above, given any ε-BIC for a single agent with a general type distribution, we
can transform to an exactly BIC mechanis with no loss of welfare and negligible loss of revenue.
However, the same claim doesn’t hold for ε-EEIC. Theorem 5 shows that no transformation can
achieve negligible revenue loss while insisting on welfare preservation. The proof is provided in
Appendix C.5.

8By contrast, the previous transformations (Daskalakis and Weinberg, 2012; Rubinstein and Weinberg, 2018;
Cai et al., 2021) cannot preserve the distribution of the allocation, even for the single agent and uniform type
distribution case.

13

Theorem 5. There exists a single agent with a non-uniform type distribution, and an ε-EEIC and
IR mechanism, for which there is no IC transformation that preserves social welfare and IR and
achieves negligible revenue loss.

4 Multiple Agents with Independent Private Types

First, we state our positive result for a setting with multiple agents and independent, private types
Fi can be non-
(Theorem 6). We assume each agent i’s type ti is independently drawn from
i=1Fi. The complete proof of
uniform). Then
the following theorem is shown in Appendix C.6.

is a product distribution that can be denoted as

Fi (

×

F

n

Theorem 6. With n agents and independent private types, and an ε-BIC and IR mechanism
that achieves W expected social welfare and R expected revenue, there exists a BIC and IR
M
mechanism
ε revenue. The same
result holds for an ε-EEIC mechanism with multiple agents, in the case that each agent has an
, the
independent uniform type distribution. Given an oracle access to the interim quantities of
to
running time of the transformation from

M′ that achieves at least W social welfare and R

n
i=1 |Ti|

P
M′ is at most poly(

i |Ti|

M

M

−

).

Allocation-invariant Transformation. The transformation for multiple agents with indepen-
dent private types is also allocation-invariant. To prove this, we can observe for

= (x, p) that

P

M

f (t)x(t) =

Xt
∈T

Xti
∈T

i

fi(ti)

Et

−

·

i

∼F−

i[x(ti, t

i)] =

−

fi(ti)Xi(ti).

Xti
∈T

i

Then, by Eq. (8) in the proof of Theorem 6 (Appendix C.6), we have

t
∈T

f (t)x(t) for the transformed mechanism

M′ = (x′, p′).

Lower bound on revenue loss. Similarly to single agent case, we can also prove a lower bound of
P
revenue loss of any welfare-preserving transformation for multiple agents with independent private
types. We summarize this result in Theorem 7, and show the proof in Appendix C.7.

f (t)x′(t) =

t
∈T

P

Theorem 7. For any number n
1 of agents with independent uniform type distribution, there
exists an ε-BIC/ε-EEIC and IR mechanism, for which any welfare-preserving transformation must
suﬀer at least Ω(

ε) revenue loss.

≥

i |Ti|

4.1

Impossibility Results

P

In our main positive result (Theorem 6), we assume independent private types and the target of
transformation is BIC mechanism. These two assumptions are near-tight. See Appendix C.8 and
Appendix C.9 for proofs.

Theorem 8 (Failure of interdependent type). There exists an ε-BIC mechanism
interdependent type distribution
over

w.r.t an
(see Deﬁnition 9 in Appendix B), such that no BIC mechanism

F
can achieve negligible revenue loss compared with

M

.
M

F

Theorem 8 provides a counterexample to show that if we allow for interdependent types, where
the value of one agent depends on the type of another, there is no way to construct a BIC mech-
anism without negligible revenue loss compared with the original ε-BIC mechanism even if we
remove the requirement of welfare preservation. This leaves an open question is whether there is a
counterexample for an ε-BIC transform for correlated, private types.

14

Theorem 9 (Failure of DSIC target). There exists an ε-BIC mechanism
distribution
with

, such that no DSIC mechanism over

deﬁned on a type
can achieve negligible revenue loss compared

M

F

F

.
M

Theorem 9 gives an impossibility result for the setting that we start from an ε-BIC mechanism.
We leave open the question as to whether it is possible to transform an ε-EEIC mechanism to a
DSIC mechanism with zero loss of social welfare and negligible loss of revenue, for multiple agents
with independent uniform type distribution.

5 Application to Automated Mechanism Design

In this section, we apply the transform to linear-programming based and machine-learning based
approaches to automated mechanism design (AMD) (Conitzer and Sandholm, 2002), where the
mechanism is automatically created for the setting and objective at hand.

We state the main results for the following, blended design objective of revenue and welfare, for

a given λ

∈

[0, 1] and type distribution

,

F

Let OPT = max
:
M
mechanism deﬁned on
a machine-learning based approach.

M
F

F

µλ(

) = (1

λ)RM(

,
M
is BIC and IR µλ(
) be the optimal objective achieved by a BIC and IR
. We consider two diﬀerent AMD approaches, an LP-based approach and

) + λW M(

,
M

(7)

−

F

F

F

).

LP-based AMD. As explained in more detail in Appendix D, an LP-based approach to BIC
In
mechanism design introduces a decision variable for each outcome and each type proﬁle.
practice, the type space of each agent may be exponential in the number of items for multi-item
auctions, and the number of type proﬁles is exponential in the number of agents. To address
) and construct
this challenge, it is necessary to discretize
| ≪ |Ti|
+
, that is,
the coupled type distribution
i
T
+
the mass of each point in Ti is associated with the nearest point in
.) Then we can apply
i
T
+
an LP-based AMD approach for type distribution
,
n ). Even though the LP
+, the mechanism
, by the same
returns an mechanism deﬁned only on
+, and
coupling technique. For example, given any type proﬁle t
takes t+ as the input. This coupling technique makes the mechanism only
the mechanism
approximately IC. Suppose, in particular, that we have an α-approximation LP algorithm that
αOPT. By an application
outputs an ε-BIC and IR mechanism
of the transform to

+
1 ,
can be deﬁned on
, there is a coupled t+

+
i . (e.g., by rounding down to the nearest points in

M
, we have the following theorem.

Ti to a coarser space

, such that µλ(

F
M
∈ T

+ = (

,
M

over

∈ T

+
i

+
i

M

· · ·

, (

|T

≥

F

F

F

F

F

T

T

T

)

M

Theorem 10 (LP-based AMD). For n agents with independent type distribution
LP-based AMD approach for coarsened distribution
ε-BIC and IR mechanism
α

M
(0, 1), then there exists a BIC and IR mechanism

+ on coarsened type space
αOPT, for some λ

F
λ)R + λW

, with (1

on

T
∈

−

F

≥
M′ such that

∈

n

i=1Fi, and an
×
+ that gives an
[0, 1], and some

µλ(

′,

)

F

≥

αOPT

(1

−

−

M

ε.

|Ti|

n

λ)

Xi=1
on

Given oracle access to the interim quantities of

and an α-approximation LP solver
with running time rtLP (x), where x is the bit complexity of the input, the running time to output
, rtLP (poly(
the mechanism

M

F

M′ is at most poly(

i |Ti|

+
i

, 1
ε )).
|

i |T

P

P

15

Machine-learning based AMD. RegretNet uses an artiﬁcial neural network to learn approximately-
incentive compatible auctions for multi-dimensional mechanism design (Duetting et al., 2019). See
Appendix D for more details of the application of RegretNet to a setting in which the design goal
is a blend of revenue and welfare. RegretNet outputs an ε-EEIC mechanism. Suppose that Regret-
. To train RegretNet,
Net is used in a setting with an independent, uniform type distribution
we randomly draw S samples from
to form a training data
H
S
be the function space modeled by RegretNet and suppose a PAC-learner that outputs an ε-EEIC
µλ( ˆ
ε holds with probability at
mechanism
M
. By an application of the transform to
least 1

sup ˆ
, such that µλ(
δ, by observing S = S(ε, δ) i.i.d samples from

and train the model on

M ∈ H

,
M

. Let

on

≥

−

F

F

F

F

F

S

)

)

,

M∈H
F

−

, we have the following theorem.

M
Theorem 11 (RegretNet AMD). For n agents with independent uniform type distribution
T1,
over
on
· · ·
µλ(
)
sup ˆ
≥
on S = S(ε, δ) i.i.d samples from
exists a BIC and IR mechanism

n
i=1Fi
×
with
F
[0, 1], trained
is the function class modeled by RegretNet, then there
δ, such that

Tn), and RegretNet to generate an ε-EEIC and IR mechanism
ε holds with probability at least 1
δ, for some λ
, where

−
F
M′, with probability at least 1

µλ( ˆ
M

M
∈

= (
)

T
,
M

M∈H

H

−

−

F

F

,

,

µλ(

′,

)

M

F

≥

sup
ˆ

µλ( ˆ
M

,

)

F

−

(1

−

n

λ)

ε
|Ti|

−

ε.

Given oracle access to the interim quantities of

Xi=1
and a PAC-learner with running time
rtRegretN et(x), where x is the bit complexity of the input, the running time to output the mechanism
M′ is at most poly(

, ε, rtRegretN et(poly(S, 1

i |Ti|

ε )).

M∈H

M

on

F

6 Conclusion

P

In this paper, we have proposed the ﬁrst ε-BIC to BIC transformation that achieves negligible
revenue loss with no loss in social welfare. Our transformation diﬀers from the previous replica-
surrogate matching approaches because we would like to preserve welfare. In its place, we directly
make use of a directed and weighted type graph (induced by the types’ regret), one for each agent.
The transformation runs a fractional rotation step and a payment reducing step iteratively to make
the mechanism Bayesian incentive compatible. We also proved that the revenue loss bound of
ε is tight given the requirement that the transform should maintain social welfare. Our
transformation also satisﬁes (ex ante) allocation-invariance property, which cannot be attained by
P
the previous replica-surrogate matching. In addition, we have demonstrated that the transformation
can be applied to an ε-EEIC mechanism with multiple agents in the case that each agent has a
independent uniform type distribution, and provided an impossibility result for the case of a non-
uniform distribution and just one agent.

i |Ti|

There remain some interesting open questions:
• Can we design a polynomial time algorithm for an ε-BIC to BIC transformation with negligible
revenue loss and without loss of welfare given only query access to the original mechanism
and sample access to type distribution? (Our polynomial time results assume oracle access
to the interim quantities.)

• Is it possible to transform an ε-EEIC mechanism to a DSIC mechanism, for multiple agents
and with an independent, uniform type distribution, without loss of welfare, and with only
negligible revenue loss?

• If we only focus on the revenue perspective, is it possible to ﬁnd an ε-EEIC to DSIC trans-

formation, perhaps even in the non-uniform case?

16

• Theorem 8 gives an impossibility result for the setting with interdependent type distribution.
Is it possible to extend our transformation to the correlated type distribution setting, or prove
an impossibility result there?

References

Eduardo M Azevedo and Eric Budish. 2019. Strategy-proofness in the Large. Review of Economic

Studies 86, 1 (2019), 81–116.

M. Balcan, T. Sandholm, and E. Vitercik. 2019. Estimating Approximate Incentive Compatibility.
In Proceedings of the 2019 ACM Conference on Economics and Computation (EC’19). 867.

S. R. Balseiro, J. Feldman, V. Mirrokni, and S. Muthukrishnan. 2014. Yield Optimization of Display

Advertising with Ad Exchange. Management Science 60, 12 (2014), 2886–2907.

Xiaohui Bei and Zhiyi Huang. 2011. Bayesian Incentive Compatibility via Fractional Assignments.
Proceedings of the 2011 Annual ACM-SIAM Symposium on Discrete Algorithms (2011), 720–733.

K. C. Border. 1991. Implementation of Reduced Form Auctions: A Geometric Approach. Econo-

metrica 59, 4 (1991).

Y. Cai, C. Daskalakis, and M. S. Weinberg. 2012a. Optimal Multi-dimensional Mechanism Design:
Reducing Revenue to Welfare Maximization. In Proceedings of the 53rd IEEE Symposium on
Foundations of Computer Science. 130–139.

Y. Cai, C. Daskalakis, and S. M. Weinberg. 2012b. An algorithmic characterization of multi-
dimensional mechanisms. In Proceedings of the 44th ACM Symposium on Theory of Computing.

Y. Cai, C. Daskalakis, and S. M. Weinberg. 2013. Understanding Incentives: Mechanism Design
Becomes Algorithm Design. In Proceedings of the 54th IEEE Symposium on Foundations of
Computer Science. 618–627.

Y. Cai, A. Oikonomou, G. Velegkas, and M. Zhao. 2021. An Eﬃcient ε-BIC to BIC Transformation
and Its Application to Black-Box Reduction in Revenue Maximization. In Proceedings of the
32nd Annual ACM-SIAM Symposium on Discrete Algorithms (SODA).

Y. Cai and M. Zhao. 2017. Simple Mechanisms for Subadditive Buyers via Duality. In Proceedings

of the 49th ACM Symposium on Theory of Computing. 170–183.

Gabriel Carroll. 2012. When Are Local Incentive Constraints Suﬃcient? Econometrica 80, 2

(2012), 661–686.

V. Conitzer and T. Sandholm. 2002. Complexity of Mechanism Design. In Proceedings of the 18th

Conference on Uncertainty in Artiﬁcial Intelligence. 103–110.

V. Conitzer and T. Sandholm. 2004. Self-interested automated mechanism design and implications
for optimal combinatorial auctions. In Proceedings of the 5th ACM Conference on Electronic
Commerce. 132–141.

C. Daskalakis and S. M. Weinberg. 2012. Symmetries and Optimal Multi-Dimensional Mechanism

Design. In Proceedings of the 13th ACM Conference on Electronic Commerce. 370–387.

17

Ilias Diakonikolas, Christos Papadimitriou, George Pierrakos, and Yaron Singer. 2012. Eﬃciency-

Revenue Trade-Oﬀs in Auctions. In Automata, Languages, and Programming. 488–499.

P. Duetting, Z. Feng, H. Narasimhan, D. Parkes, and S. S. Ravindranath. 2019. Optimal Auctions
through Deep Learning. In Proceedings of the 36th International Conference on Machine Learning
(Proceedings of Machine Learning Research), Kamalika Chaudhuri and Ruslan Salakhutdinov
(Eds.), Vol. 97. PMLR, Long Beach, California, USA.

S. Dughmi, J. D. Hartline, R. Kleinberg, and R. Niazadeh. 2017. Bernoulli Factories and Black-Box
Reductions in Mechanism Design. In Proceedings of the 49th Annual ACM SIGACT Symposium
on Theory of Computing.

P. D¨utting, F. Fischer, P. Jirapinyo, J. Lai, B. Lubin, and D. C. Parkes. 2014. Payment Rules
through Discriminant-Based Classiﬁers. ACM Transactions on Economics and Computation 3,
1 (2014), 5.

Z. Feng, H. Narasimhan, and D. C. Parkes. 2018. Deep Learning for Revenue-Optimal Auctions
with Budgets. In Proceedings of the 17th International Conference on Autonomous Agents and
Multiagent Systems. 354–362.

Z. Feng, O. Schrijvers, and E. Sodomka. 2019. Online Learning for Measuring Incentive Compati-

bility in Ad Auctions. In The World Wide Web Conference (WWW ’19). 2729–2735.

J. D. Hartline, R. Kleinberg, and A. Malekian. 2011. Bayesian Incentive Compatibility via Match-
ings. In Proceedings of the Twenty-Second Annual ACM-SIAM Symposium on Discrete Algo-
rithms.

J. D. Hartline and B. Lucier. 2010. Bayesian Algorithmic Mechanism Design. In Proceedings of the

Forty-Second ACM Symposium on Theory of Computing.

T. Hashimoto. 2018. The generalized random priority mechanism with budgets. Journal of Eco-

nomic Theory 177 (2018), 708 – 733.

S. Lahaie, A. M. Medina, B. Sivan, and S. Vassilvitskii. 2018. Testing Incentive Compatibility
in Display Ad Auctions. In Proceedings of the 27th International World Wide Web Conference
(WWW).

S. Lahaie and D. M. Pennock. 2007. Revenue Analysis of a Family of Ranking Rules for Keyword
Auctions. In Proceedings of the 8th ACM Conference on Electronic Commerce (EC). 50–56.

Benjamin Lubin and David C. Parkes. 2012. Approximate strategyproofness. Current Science 103,

9 (2012), 1021–1032.

H. Narasimhan and D. C. Parkes. 2016. A General Statistical Framework for Designing Strategy-
proof Assignment Mechanisms. In Proceedings of the Conference on Uncertainty in Artiﬁcial
Intelligence.

A. Rubinstein and M. S. Weinberg. 2018. Simple Mechanisms for a Subadditive Buyer and Appli-

cations to Revenue Monotonicity. ACM Trans. Econ. Comput. (2018).

A. C-C. Yao. 2017. Dominant-Strategy versus Bayesian Multi-item Auctions: Maximum Revenue
Determination and Comparison. In Proceedings of the 18th ACM Conference on Economics and
Computation. 3–20.

18

Appendix

A Details of Replica-Surrogate Mechanism

We show the detailed description of Replica-Surrogate Mechanism in Fig. 3.

Phase 1: Surrogate Sale. For each agent i,

M

• Modify mechanism

sampled i.i.d from

to multiply all prices it charges by a factor of (1

the mechanism resulting from this modiﬁcation.

• Given the reported type ti, create r

M′ be
Fi and r surrogates
• Construct a weighted bipartite graph between replicas (including agent i’s true type ti)
and surrogates. The weight of the edge between a replica r(j) and a surrogate s(k) is the
interim utility of agent i when he misreports type s(k) rather than the true type r(j) in
mechanism

Fi. r is the parameter of the algorithm to be decided later.

1 replicas sampled i.i.d from

η). Let

−

−

M′, i.e.,

wi(r(j), s(k)) = Et

−

i

i

∈F−

vi(r(j), x(s(k), t

−

(1

η)

Et

−

·

−

−

i

i

∈F−

pi(s(k), t

−

i)
i

h

i))
i

h

• Let wi((r(j), s(k))) be the value of replica r(j) for being matched to surrogate s(k). Com-
pute the VCG matching and prices, that is, compute the maximum weighted matching
w.r.t wi(
If a replica is unmatched in the
,
·
VCG matching, match it to a random unmatched surrogate.

) and the corresponding VCG payments.
·

Phase 2: Surrogate Competition.

• Let ~si denote the surrogate chosen to represent agent i in phase 1, and let ~s be the entire

surrogate proﬁle. We let the surrogates ~s play

M′.

• If agent i’s true type ti is matched to a surrogate through VCG matching, charge agent
i the VCG price that he wins the surrogate and award (allocate) agent i, xi(s) (Note
η)pi(s)). If agent i’s true type is not matched in VCG
M′ also charges agent i, (1
matching and matched to a random surrogate, the agent gets nothing and pays 0.

−

Figure 3: Replica-Surrogate Matching Mechanism.

B Omitted Deﬁnitions

Deﬁnition 8 (Individual Rationality). A BIC/ε-BIC mechanism
rationality (interim IR) iﬀ for all i, vi:

M

satisﬁes interim individual

Et

−

i

∼F−

i[ui(ti,

(t))]

M

0

≥

This becomes ex-post individual rationality (ex-post IR) iﬀ for all i, ti, t
probability 1, over the randomness of the mechanism.

−

i, ui(ti,

(t))

M

≥

0 with

Deﬁnition 9 (Interdependent private type). Each agent i
[n] has a private signal si, which
captures her private information and the type of every agent ti depends on the entire signal proﬁle,
s = (s1,

, sn).

∈

· · ·

19

C Omitted Proofs

C.1 Proof of Claim 1

T \C

will not increase. Third, since

Proof. First, in Step 1, since we only rotate the allocation and payment of nodes in
weight of the edges from nodes in
to nodes in
C
to
achieves a utility no worse than before, so that the weight of each outgoing edge from nodes in
is the shortest cycle, there are no other edges among
nodes in
by
nodes in
this rotation. It follows that this rotation decreases the total weights of graph G by the weights of
, t(l) is still the same, since Step 1 only
C
rotates the allocation and payment rules, and the probability of each type is the same. Combining
the fact that each node gets a weakly preferred outcome, the social welfare does not decrease.

. Finally, the expected revenue achieved by types t(1),

, which implies we cannot create new edges among nodes in

remains the same. Second, each node in

in addition to edges in

, the total

T \C
C

· · ·

C

C

C

C

C

C

C.2 Proof of Claim 2

∈
St, then u(ˆt,

Proof. In Step 2, we ﬁrst prove that it can only create new edges with zero weight. A new edge
created by Step 2 can only point to a node ¯t
St. We show by contradiction, suppose we create
a positive weight edge from ˆt to ¯t
M′(ˆt)) > 0 for the current updated
M′(¯t))
M′, we have
mechanism
′(ˆt)) < u(ˆt,
u(ˆt,
u(ˆt,
≤
= u(ˆt,

′(¯t)) < u(ˆt,
′(¯t)) + u(t′′,
′(¯t)) + u(ˆt,
′(ˆt)),

′(¯t)) + εt
′(t′′))
′(ˆt))

(By deﬁnition of t′′)

M
′(¯t))

−
u(ˆt,

′(¯t))

u(t′′,

u(ˆt,

u(ˆt,

M

M

M

M

M

M

M

M

−

−

≤

∈

M

which proves our claim. Second, it is straightforward to verify that Step 2 doesn’t decrease social
welfare since we only decrease payment in Step 2. Finally, in Step 2, we reduce the weight of every
positive-weight outgoing edge associated with t by min
. This is because for any node t′, s.t.
there is a positive-weight edge between t and t′, t′ cannot be the ancestor of t, otherwise, there is
already a cycle, which contradicts Step 1.

εt, ¯εt}
{

C.3 Proof of Theorem 3

, E) as in the proof of Theorem 1.
Proof. We construct the same weighted directed graph G = (
Again, the target is to reduce the total weight of G to zero, which leads to a BIC mechanism. We
= C, and we have for each type t(i), that there exists a menu
denote Me as the menus and
(t(j)), there is an
me ∈
directed edge with weight zero from t(i) to t(j), and vice versa. We denote the distribution of each
menu me as,

(t(i)) = me. If t(i) and t(j) share a same menu, i.e.,

(t(i)) =

Me, s.t.

Me|
|

M

M

M

T

Since

M

g(me) =

f (t).

T :
Xt
M
∈

ε(t)=me

is ε-BIC, the weight of each edge is bounded by ε. We still apply Step 1 and Step 2

in graph G proposed in Theorem 1, however, we count the revenue loss over menu space.

First, in Step 1, we only rotate the allocation and payment (menu) along the cycle, it will not
change the allocation and payment of each menu. In addition, it will not the distribution of menus,
g(me) is preserved for each me.

20

In Step 2, consider a source node t, and let the corresponding menu be m′e (the output of the
current mechanism with type t). Every type with m′e is the ancestor of type t, when we decrease
, the payment for each type t′ associated with menu m′e will
the payment of type t by min
εt, ¯εt}
{
= m′e and t′′ is an
be decreased by the same amount. If there is a type t′′ with a diﬀerent menu m′′e 6
ancestor of t, then all the types associated with menu m′′e are the ancestors of t. Thus, in Step 2,
the payment of the types with the same menu must be decreased by the same amount. Therefore,
Step 2 only changes the payment of each menu by the same amount, and does not change the
distribution of each menu, i.e. g(me) is the same for each me ∈
Moreover, if there is an edge (t(j), t(k)) with positive weight and if t(j) and t share the same
menu, then (1) t(k) must be in diﬀerent menus, and (2) t(k) is not the ancestor of t, otherwise,
there exists a cycle, which contains a positive-weight edge. Therefore, in Step 2, if we decrease the
εt, εt}
payment of type t by min
. In
{
.
εt, εt}
other words, we reduce the regret of all the nodes in menu me by min
{

, we also reduce the weight of edge (t(j), t(k)) by min

Since the weight of each edge is bounded by ε, then we may decrease the expected payment at
most ε to reduce all the regret of the nodes belonging to menu me. In total, the revenue loss is
bounded by Cε.

εt, εt}
{

Me.

C.4 Proof of Theorem 4

Proof. We construct a weighted directed graph G = (
A directed edge e = (t(j), t(k))
∈
payment) of t(k) is weakly preferred by true type t(j), i.e. u(t(j),
the weight of edge e is

, E), diﬀerent with the one in Theorem 1.
E is drawn from t(j) to t(k) when the outcome (allocation and
(t(j))), and

u(t(j),

(t(k)))

M

M

≥

T

w(e) = f (t(j))

f (t(k))

·

·

u(t(j),

(t(k)))

M

−

u(t(j),

M

(t(j)))
i

h

M

It is straightforward to see that

is BIC iﬀ the total weight of all edges in G is zero.

We show the modiﬁed transformation for this setting in Fig. 4. Firstly, it is trivial that our
transformation preserves IR, since neither Step 1 nor Step 2 reduces utility. Then we show this
modiﬁed Step 1 will strictly decrease the total weights of the graph G and has no negative eﬀect
on social welfare and revenue.

First, we observe each type in

achieves utility no worse than before, by truthful reporting.

Then, the weight of each outgoing edge from a type in

to a type in

will not increase.

C

does not increase. To prove this, we assume w(t, t(j))

Second, we claim the total weight of edges from any node (type) t

C to nodes (types) in
, i.e. there is a edge from t to
C
any t(j)
in G. This is WLOG, because if there is no edge between t to some t(j)
C, we can
just add an edge from t to t(j) with weight zero, and this does not change the total weight of the
graph. We denote the mechanism updated after one use of Step 1 as
M′, and denote the weight
, 0). The
]+ be the function max(
M′. Let [
function w′ for the graph G′ that is constructed from
·
·

∈ T \

t(j)

∈ C

∈ C

≥

0,

∈

∀

C

T \C

21

total weight from t to t(j)

according to the mechanism

M′ = (x′, p′) is

∈ C

w′(t, t(j))

Xt(j)
∈C
l

=

=

≤

=

=

f (t(j))f (t)

u(t,

′(t(j)))

M

u(t,

−

′(t))

M

+

(cid:3)

Xj=1
l

(cid:2)
f (t(j))f (t)

Xj=1
(In the fractional rotation step,

"

(f (t(j))

−

f (t(k)))u(t,

M

(t(j))) + f (t(k))
f (t(j))

u(t,

·

(t(j+1)))

M

u(t,

−

(t))

M

#+

′(t) =

M

(t),

t

∀

M
ε(t(j)))

u(t,

−

)

∈ T \C
ε(t))

M

+

l

f (t)

Xj=1

l

+

·

(cid:16)(cid:0)
f (t(k))

f (t(j)))

f (t(k))

u(t,

−

(cid:1)(cid:2)

M

u(t,

(t(j+1)))

u(t,

(t))

(cid:2)

M

Xj=1

−
(By rearranging the algebra and the fact that [x + y]+ ≤
(t(j)))

f (t(j))

ε(t))

f (t)

u(t,

u(t,

M

(cid:17)

(cid:3)

l

+

·

·

M

−

M

+

(cid:3)

[x]+ + [y]+)

Xj=1
(By the fact that
w(t, t(j))

(cid:2)

t(1),
{

, t(l)

}

· · ·

forms a cycle and t(l+1) = t(1))

(cid:3)

Xt(j)
∈C

C

Modiﬁed Step 1 (Fractional rotation step). Given a mechanism
shortest cycle
of generality, we represent
that f (t(k)) = mink

= (x, p), ﬁnd the
in G that contains at least one edge with positive weight in E. Without loss
[l], such
[l] f (t(k)). Next, we rotate the allocation and payment rules of types along
∈
[l]. Now we slightly abuse the notation

(cid:9)
with fraction of f (t(k))/f (t(j)) for each type t(j), j

. Then we ﬁnd the node t(k), k

C
of subscripts, s.t. t(l+1) = t(1). Speciﬁcally, the allocation and payment rules for each t(j),

t(1), t(2),

, t(l)

M

· · ·

=

∈

∈

(cid:8)

C

x′(t(j)) =

p′(t(j)) =

f (t(j))

f (t(j))

−

−

(cid:2)

(cid:2)

f (t(k))

(cid:3)
f (t(k))

x(t(j)) + f (t(k))x(t(j+1))
f (t(j))
p(t(j)) + f (t(k))p(t(j+1))
f (t(j))
(cid:3)

,

.

Then we update mechanism
to adopt allocation and payment rules x′, p′ to form a new
mechanism
M′ and reconstruct the graph G. If this has the eﬀect of removing all cycles that
contain at least one positive-weight-edge in G, then move to Step 2. Otherwise, we repeat
Step 1.
Modiﬁed Step 2 (Payment reducing step). Exactly the same as Step 2 in Theorem 1.

M

Figure 4: ε-BIC to BIC transformation for single agent with general type distribution.

Thus, we prove our claim that the total weight of edges from any node (type) t

(types) in

C

does not increase.

C to nodes

∈ T \

22

M

l

Xj=1

f (t(j))

·

Third, by each use of modiﬁed Step 1, we remove one cycle and reduce the weight of edge

(t(i), t(i+1)) to zero, thus, we decrease the total weight at least by f (t(k))f (t(k+1))(u(t(k),
u(t(k),

(t(k))).

M

(t(k+1)))

−

Finally, after one use of Step 1, the expected revenue achieved by types in

maintains, because

C

p′(t(j)) =

(f (t(j))

f (t(k)))

·

−

p(t(j)) + f (t(k))

p(t(j+1))

·

f (t(j))p(t(j)) + f t(k)

p(t(j))

f (t(j))p(t(j))

Xj

p(t(j+1))

−

(Because t(l+1) = t(1))

=

=

Xj

Xj

Xj

The modiﬁed Step 2 is the same as Step 2 in Fig. 2. At each step 2, we decrease the total
. We count the revenue loss as follows, in each Step 2, if

, the expected revenue loss is bounded by

εt, εt}
weight of the graph by at least min
{
εt, εt}
we decrease the payment of t by min
{
f (t(j)) min

εt, εt} ≤
{

min

εt, εt}
{

Xj

Since the weight of each edge is bounded by ε, to reduce the weight of outgoing edges of t to
zero, we may decrease the expected revenue by ε. Therefore, in total, the expected revenue loss is
bounded by mε.

C.5 Proof of Theorem 5

ε

2 −

, t(m)

=
2) ,

T
1
2(m

1 at m + (j

t(1),
{
j
∀

2m , f (t(2)) = ε

2m and f (t(j)) =

Proof. We construct the type distribution and the ε-EEIC mechanism similar to the one in The-
orem 2. We consider a single agent with m types
. The type distribution is
}
· · ·
f (t(1)) = 1
3. The agent with type t(1) values
outcome 1 at ε and the other outcomes at 0. For any type t(j), j
2, the agent with type t(j)
values outcome j
1)ε, and the other outcomes at 0.
1)ε, outcome j at m + (j
The mechanism we consider is: (1) if the agent reports type t(1), gives the outcome 1 to the agent
and charges ε. (2) if the agent reports t(j), j
2, gives the outcome j to the agent and charges
1)ε. There is a m regret to the agent for not misreporting type t(1) with true type t(2) and
m + (j
a regret ε for not reporting t(j) with true type t(j+1), for any j
2. It is easy to verify that this
mechanism is ε-EEIC (the probability of type t(2) is small) and already maximizes social welfare.
Thus, we can only change the payment to reduce the regret of each type. Following the same
argument as in Theorem 2, to reduce all the regret of the types, the revenue loss in total is at least

−

≥

≥

≥

≥

−

−

−

−

m

f (t(2))m +

f (t(j))(m + (j

Xj=3

2)ε) =

−

=

ε
2

ε
2

+

+

1
2(m

m
2

+

2)

−
(m

m

m + (j

Xj=3
1)ε
−
4

m
2

≥

2)ε

−

C.6 Proof of Theorem 6

The earlier proof approach for single agent case does not immediately extend to the multi-agent
setting. However, since our target is a BIC mechanism, we can work with interim rules (see

23

Deﬁnition 1), and this provides an approach to the transformation. The interim rules reduce the
dimension of type space and separate the type of each agent. With this, we can construct a separate
type graph for each agent, now based on the interim rules.

To simplify the presentation, we deﬁne the induced mechanism for each agent i of a mechanism
as follows.

The following lemma shows that given an ε-BIC/ε-EEIC mechanism, then the induced mecha-

M
) and interim payment rule Pi :

= (x, p), an induced mechanism
Ti →

Mi =
R
0.
f

≥

Pi(ti).

M
Deﬁnition 10 (Induced Mechanism). For a mechanism
∆(
(Xi, Pi) is a pair of interum allocation rule Xi :
O
Mi(ti)) = vi(ti, Xi(ti))
Denote the utility function ui(ti,
−
f

Ti →

nism for each agent is also ε-BIC/ε-EEIC.

Lemma 1. For a ε-EEIC/ε-BIC mechanism
ε-EEIC/ε-BIC.

M

Proof. By ε-BIC deﬁnition, each induced mechanism

is ε-BIC. Now, we turn to consider ε-EEIC mechanism

M

, any induced mechanism

Mi for each agent i is
f
Mi must be ε-BIC, if the original mechanism
, for any induced mechanism
f
Mi(ti))
ui(ti,
(cid:21)
f
−

ui(ti,

(t′i; t

(ti; t

Mi

M

i))

i))

f

−

M

M

−

Eti

i
∼F

max
t′i∈T
i

(cid:20)

ui(ti,

−

Mi(t′i))
f
i
∼F−

ui(ti,

Et

−

i

= Eti

i
∼F

(cid:20)

Eti

i
∼F

≤

max
t′i∈T
i
Et

i

−

∼F−

i

(cid:20)

(cid:20)

(cid:2)
max
t′i∈T
i

ui(ti,

(t′i; t

M

i))

−

−

ui(ti,

(ti; t

M

−

(cid:3)
i))

(cid:21)

(cid:21)(cid:21)

(By Jenson’s inequality and convexity of max function)

= Et

max
t′i∈T
i

ui(ti,

(t′i; t

i))

ui(ti,

∼F

M
(By independence of agents’ types)

−

(cid:20)

−

(ti; t

M

−

i))
(cid:21)

ε.

≤

Given Lemma 1, we can construct a single type graph for each agent based on the induced
mechanism and apply the same technique for each graph as the one in Theorem 4. The challenge
will be to also handle feasibility of the resulting mechanism. We summarize these approaches in
the following proof for Theorem 6.

Proof of Theorem 6. Here, we focus on the ε-BIC setting. The proof for ε-EEIC with independent
uniform type distribution is analogous.
We construct a graph Gi = (

from t(j)

i

to t(k)
i

if and only if u(t(j)

wi((t(j)
i

, t(k)
i

)) = fi(tj)

·

[n], such that there is a directed edge
i(t(j)

Ti, Ei) for each agent i
u(t(j)
,
))
,
i

i(t(k)
i

i

∈
ε
M

ε
M
fi(t(k)
g
i

≥
u(t(j)
i

)

·

(cid:16)

,

Mi(t(k)

g
i

))

f

i )) and the weight is
Mi(t(j)
i )
(cid:17)

u(t(j)
i

−

,

f

i, we can
Based on Lemma 1, each graph is constructed by an ε-BIC induced mechanism
apply the same constructive proof in Theorem 4 to reduce the total weight of each graph Gi to
be 0. An astute reader may have already realized that changing type graph Gi may aﬀect other

g

ε
M

24

graphs, since we probably change the distribution of the reported type of agent i. However, in our
transformation, both Step 1 and Step 2 don’t change the density probability of each type (we only
change the interim allocation and payment for each type), therefore when we do transformation for
one type graph Gi of agent i, it has no eﬀect on the interim rules of the other agents.

Here, if the total weight of all graphs Gi are all 0, it implies that any induced mechanism
i
is IC. Therefore, we make the mechanism BIC. Similarly, the new mechanism after transformation
g
achieves at least the same social welfare and the revenue loss of each graph Gi is bounded by miε,
Hence, the total revenue loss is bounded by

n
i=1 miε =
What is left to show is that using modiﬁed steps 1 and 2 on each graph Gi shown in Theorem 4
does not violate the feasibility of the mechanism. We only change the allocation of each type in
modiﬁed Step 1 (Rotation step). Denote by Xi the interim allocation for agent i before one rotation
step, and let X ′i denote the updated interim allocation for agent i after one rotation step. We then
claim in the modiﬁed Step 1 in Theorem 4,

n
i=1 |Ti|

P

P

ε.

ε
M

fi(ti)Xi(ti) =

fi(ti)X ′i(ti).

(8)

Xti
∈T
To prove this claim, WLOG, we consider a l length cycle

Xti
∈T

i

i

Step 1. Let k = arg minj
ti ∈ Ti\C
change in modiﬁed Step 1, i.e.,
and let t(l+1) = t(1). For the types in cycle

∀

, t(l)
i }
[l] fi(t(j)). We observe the interim allocation of the types in
∈

in modiﬁed
don’t
Ti\C
, Xi(ti) = X ′i(ti). We slightly abuse the notation here,

t(1)
i
{

, t(2)
i

· · ·

=

C

,

,

C
(f (t(j))

·

−

f (t(k)))Xi(t(k)) + f (t(k))
f (t(j))

·

Xi(t(j+1))

fi(t(j))X ′i(t(j)) =

f (t(j))

[l]
Xj
∈

=

[l]
Xj
∈

[l]
Xj
∈

fi(t(j))Xi(t(j)),

which validates the claim. Therefore, by Border’s lemma (Border, 1991), the rotation step maintains
the feasibility of the allocation.
Running time. Suppose we have oracle access to the interim quantities of the original mechanism,
we can build each Gi in poly(
)
|Ti|
following the same argument for single agent. In total the running time is ploy(

) time. Then, the running time for each type graph Gi is poly(

|Ti|

).
i |Ti|

C.7 Proof of Theorem 7

P

Proof. It is straightforward to construct an example such that the type graph of each agent in-
duced by the interim rules is the same as the type graph constructed by the mechanism shown
o(1)
in Theorem 2. For instance, agent i values outcomes
in the same way as the
i
{
one constructed in Theorem 2. We assume the outcome o(j)
[mi].
Indeed, this is also ε-DSIC mechanism. Thus, we show for this case, that the revenue loss must
be at least Ω(
ε), if we want to maintain the social welfare, following the same argument in
Theorem 2.

· · ·
are disjoint, for any i and j

, o(mi)
i

i |Ti|

∈

}

,

i

P

C.8 Proof of Theorem 8

Proof. Consider a setting with two items A and B and two unit-demand agents 1 and 2. The two
agents share the same preference order on items. Moreover, agent 1 is informed about which is
better, while agent 2 has no information. Agent 1 values the better item at 1 + ε and the other
item at 1. Agent 2 values the better item at 2 and the other item at 0.

25

There exists an ε-IC mechanism: ask agent 1 which item is better, and give this item to agent
2 for a price of 2 and give agent 1 the other item for a price of 1. The total welfare and revenue is 3
if agent 1 reports truthfully. Bidder 1 can get ε more utility by misreporting, in which case it will
get the better item for the same price. From this, we can conﬁrm that this is an ε-IC mechanism.

For any IC mechanism, by weak monotonicity, we have vA(x(A))

−
vB(x(B)), where vA be the type that the better item is A, and similarly for vB. x(A) is the
allocation if agent 1 reports A the better item and similarly for x(B). This means that when agent
1 reporting A rather than B, either agent 1 is assigned item A with weakly higher probability, or
agent 1 is assigned item B with weakly less probability. We only consider the former case, and the
latter one holds analogously. In the former case, we have either:

vA(x(B))

vB(x(A))

−

≥

(1) agent 1 is getting at least half of A when reporting A, and the total revenue and social

welfare are each at most 0.5

2 + 0.5

(1 + ǫ) + 1 = 2.5 + ǫ/2, or

×

×

(2) agent 1 is getting at most half of A when reporting B, and the total revenue and social

welfare are each at most 2 + 0.5 = 2.5.

Either way, we will deﬁnitely lose at least 0.5

the ε-IC mechanism above BIC.

−

C.9 Proof of Theorem 9

ε/2 for revenue and social welfare when making

Proof. The construction of this ε-BIC mechanism is strictly generalized by the mechanism in (Yao,
2017). Consider a 2-agent, 2-item auction, each agent i values item j, tij. tij is i.i.d sampled from
, i.e. P(tij = 1) = P(tij = 2) = 0.5. The ε-BIC mechanism is
a uniform distribution over set
1, 2
}
{
shown as below,

If t2 = (1, 1), give both items to agent 1 for a price of 3.
If t2 = (1, 2) and t1 = (1, 2), give both items randomly to agent 1 or 2 for a price of 1.5.
If t1 = (2, 1) and t2 = (1, 2), give item 1 to agent 1 and give item 2 to agent 2, with a
price of 2 for each.
If t2 = (1, 2) and t1 = (2, 2), give both items to agent 1 for a price 3.75 + ε.
If t1 = t2 = (2, 2), give both items randomly to agent 1 or agent 2 for a price 2.
For other cases, we get the mechanism by the symmetries of items and agents.

It is straightforward to verify that this is an ε-BIC mechanism and the expected revenue is
3.1875 + ε/16. However, Yao (2017) characterizes that optimal DSIC mechanism achieves expected
3.125. This conclude the proof.

D Omitted Details of Applications

In this section, we give a brief introduction to LP-based AMD and RegretNet AMD.

D.1 LP-based Approach

The LP-based approach considered in this paper is initiated by (Conitzer and Sandholm, 2002).
We consider n agents with type distribution
and each
O, we deﬁne xk(t) as the probability of choosing ok when the reported types are t
outcome ok ∈
and pi(t) as the expected payment of agent i when the reported types are t. xk(t) and pi(t) are
both decision variables.

. For each type proﬁle t

deﬁned on

∈ T

F

T

26

Then we can formulate the mechanism design problem as the following linear programming,

max
x,p

(1

−

λ)Et

∼F "

Xi

pi(t)

#

+ λEt

∼F 

xk(t)

Xi

O
Xk:ok∈

vi(ti, ok)



s.t. Et

−

i 

O
Xk:ok∈


Et

−

i 

O
Xk:ok∈


xk(ti, t

−

i)vi(ti, ok)

−

i)



−

≥

Et

−


pi(ti, t

xk(t)vi(ti, ok)

pi(t)



0,

∀

≥

−


i, t




xk(t′i, t

−

i)vi(ti, ok)

pi(t′i, t

i)



,

∀

−

i, ti, t′i

−



i 

O
Xk:ok∈


where the ﬁrst constraint is for BIC and the second is for interim-IR. In this case, the type space
T
is discrete, thus the expectation can be explicitly represented as the linear function with decision
variables.

D.2 RegretNet Approach

RegretNet (Duetting et al., 2019) is a generic data-driven, deep learning framework for multi-
dimensional mechanism design. We only brieﬂy introduce the RegretNet framework here and refer
the readers to (Duetting et al., 2019) for more details.

RegretNet uses a deep neural network parameterized by w

as well as the valuation (through allocation function xw :
vw
i

0 and pw
i

∆(O)

0. Denote utility function as,

R

R

:

:

Ti ×

→

≥

∈
T →

≥

T →
i (ti, ˆt) = vi(ti, xw(ˆt))
uw

pw
i (ˆt).

−

Rd to model the mechanism
,
M
∆(O)) and payment functions:

RegretNet is trained on a training data set
the empirical revenue subject to the empirical regret being zero for all agents:

of S type proﬁles i.i.d sampled from

S

to maximize

F

λ

1

−
S

n

pw
i (t) +

λ
S

Xi=1
Xt
∈S
uw
i (ti, (t′i, t

i))

−

−

max
Rd
w
∈
1
S

max
t′i∈T
i

∈S (cid:20)
Xt

n

vw
i (ti, x(t))

Xi=1
Xt
∈S
uw
i (ti, t)
(cid:21)

= 0,

i

∀

s.t.

The objective is the empirical version of learning target in 7. The constraint is for EEIC requirement
and IR is hard coded in RegretNet to be guaranteed. Let
be the functional class modeled by
RegretNet through parameters w. In this paper, we assume there exists an PAC learning algorithm
that can produce a RegretNet to model an ε-EEIC mechanism

, such that

deﬁned on

H

M ∈ H

F

µλ(

′,

M

)

F

≥

sup
ˆ

M∈H

µλ( ˆ
M

,

)

F

−

(1

−

λ)

n

Xi=1

ε
|Ti|

−

ε,

holds with probability at least 1

−

δ, by observing S = S(ε, δ) i.i.d samples from

.

F

27

