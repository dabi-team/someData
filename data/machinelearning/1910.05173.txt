9
1
0
2

t
c
O
4
1

]

G
L
.
s
c
[

2
v
3
7
1
5
0
.
0
1
9
1
:
v
i
X
r
a

EVOLVING GAUSSIAN PROCESS KERNELS
FROM ELEMENTARY MATHEMATICAL EXPRESSIONS

A PREPRINT

Ibai Roman
Intelligent Systems Group
University of the Basque Country UPV/EHU
20018 Donostia, Spain
ibai.roman@ehu.eus

Roberto Santana
Intelligent Systems Group
University of the Basque Country UPV/EHU
20018 Donostia, Spain
roberto.santana@ehu.eus

Alexander Mendiburu
Intelligent Systems Group
University of the Basque Country UPV/EHU
20018 Donostia, Spain
alexander.mendiburu@ehu.eus

Jose A. Lozano
Intelligent Systems Group
University of the Basque Country UPV/EHU
20018 Donostia, Spain
Basque Center for Applied Mathematics BCAM
48009 Bilbao, Spain
ja.lozano@ehu.eus

October 15, 2019

ABSTRACT

Choosing the most adequate kernel is crucial in many Machine Learning applications. Gaussian
Process is a state-of-the-art technique for regression and classiﬁcation that heavily relies on a kernel
function. However, in the Gaussian Process literature, kernels have usually been either ad hoc
designed, selected from a predeﬁned set, or searched for in a space of compositions of kernels which
have been deﬁned a priori. In this paper, we propose a Genetic-Programming algorithm that represents
a kernel function as a tree of elementary mathematical expressions. By means of this representation,
a wider set of kernels can be modeled, where potentially better solutions can be found, although
new challenges also arise. The proposed algorithm is able to overcome these difﬁculties and ﬁnd
kernels that accurately model the characteristics of the data. This method has been tested in several
real-world time-series extrapolation problems, improving the state-of-the-art results while reducing
the complexity of the kernels.

Keywords Evolutionary search · Gaussian Processes · Genetic-Programming · Kernel Selection · Time-series
extrapolation

1

Introduction

Gaussian Processes (GPs) [1] are one of the most used techniques in Machine Learning for regression and classiﬁcation
tasks. Furthermore, they have also been applied to optimization tasks under the umbrella of Bayesian optimization
[2]. A GP is a collection of random variables, any ﬁnite set of which has a joint Gaussian distribution. It is completely
deﬁned by a mean function and a covariance function described in terms of a Positive Semi-Deﬁnite (PSD) kernel.
The assumption in a GP is that, as the similarity between two solutions increases, so does the similarity of the output
function at these solutions. The kernel function encodes the particular manner in which the similarity between any two
solutions is deﬁned, which makes it a key element in any application of GPs.

While there is a repertoire of kernel functions available in the literature [1, 3, 4], the choice of the most appropriate
kernel for a given problem is not straightforward. Moreover, kernels usually have some parameters that need to be

 
 
 
 
 
 
A PREPRINT - OCTOBER 15, 2019

adjusted, which hardens the kernel selection problem. These parameters, often called hyperparameters, are usually
tuned by maximizing a given metric (e.g., the marginal likelihood) [5].

In early applications of GPs, the kernel function used to be designed by an expert [1], or selected from a predeﬁned set
[6]. However, some recent works tackle the question of automating the choice of the kernel [7, 8, 9]. Compositional
kernel search is one of the most used techniques when automating the kernel choice. In this technique, the kernel is
always the combination of a limited number of a priori deﬁned kernels, and the kernel selection is reframed as a search
in the space of possible kernel compositions. The compositional kernel search approaches take advantage of some
operands (e.g., sum, product, ...) that guarantee the composed kernel is PSD as long as its components are also PSD.
For example, in [7] and [9], the kernel search is carried out by means of a greedy search procedure. A similar approach
is presented in [8], although in this work the search is guided by Genetic-Programming (GenProg1) [10]. The solutions
proposed by these methods have shown their ability to capture function properties such as smoothness, trends and
periodicity [7, 9]. In addition, as the behavior of the base kernels and the operands is well-known, the behavior of their
composition may be guessed by an expert [7]. On the contrary, these kernel search methods usually end up with very
complicated kernels, including many hyperparameters, which make them expensive to optimize. Moreover, it must
be noted that these approaches rely on kernels that have already been proposed in the literature. There is no reason to
believe that kernels obtained by composing a limited set of human-designed kernels are optimal for arbitrary problems.
Furthermore, using previously designed kernels as building blocks could bias the search and prevent the exploration of
more promising candidates.

In this paper, instead of considering a reduced set of base kernels as building blocks, we propose using a set of
elementary mathematical expressions (e.g., product, sum, exponent, etc.) to serve as components of a wider set of
kernels. Our hypothesis is that, by enlarging the space of possible solutions, the representation capability of GPs is
expanded, allowing more accurate kernels with a lower number of hyperparameters to be found.

Searching for the most appropriate solution in the space of mathematical expressions is very challenging due to the vast
number of kernels that can be generated and the lack of guarantee that these kernels satisfy the PSD property. Note that,
before evaluating a kernel, its hyperparameters should be optimized, which limits the number of kernels that can be
explored due to the computational effort required to ﬁnd these hyperparameters. We propose a novel GenProg method,
EvoCov, which is able to overcome these challenges and learn adequate kernel functions for each problem. This method
does not rely on previously proposed kernels, and thus, new kernels may naturally arise.

Although we focus on regression problems in this work, our contribution can be easily extended to other GP applications,
such as classiﬁcation. Moreover, some of the components designed in EvoCov could be extended to other GenProg
applications.

The remainder of the paper is structured as follows: In the next section, a background on GP regression is provided,
including the presentation of the best known GP kernel functions. In Section 3, we present our kernel representation
approach, based on elementary mathematical expressions. In Section 4, a novel GenProg method, EvoCov, is proposed
to search for GP kernel functions based on such grammar. In Section 5, a review on related work is provided. Next,
in Section 6, we present an empirical validation of the algorithm and comparisons with other methods. Finally, in
Section 7, the conclusions and the future work are presented.

2 Gaussian Process Regression

A GP is a stochastic process, deﬁned by a collection of random variables, any ﬁnite number of which have a joint
Gaussian distribution [1]. A GP can be interpreted as a distribution over functions, and each sample of a GP as a
function.

GPs can be completely deﬁned by a mean function m(x) and a covariance function, which depends on a PSD kernel
k(x, x(cid:48)). Given that, a GP can be expressed as follows:

f (x) ∼ GP (m(x), k(x, x(cid:48)))

(1)

where we assume that x ∈ Rd.

1Note that we keep the acronym GP to refer to Gaussian Process, and GenProg to refer to Genetic-Programming.

2

A PREPRINT - OCTOBER 15, 2019

A GP can be used for regression by getting its posterior distribution given some (training) data. The joint distribution
between the training outputs f = (f1, f2, ..., fn) (where fi ∈ R, i ∈ {1, ..., n} and n ∈ N) and the test outputs
f∗ = (fn+1, fn+2, ..., fn+n∗ ) is given by:

(cid:21)

(cid:20) f
f∗

(cid:18)

∼ N

M (X∗),

(cid:20) K(X, X) K(X, X∗)
K(X∗, X) K(X∗, X∗)

(cid:21)(cid:19)

(2)

where N (µ, Σ) is a multivariate Gaussian distribution, X = (x1, x2, ..., xn) (xi ∈ Rd, i ∈ {1, ..., n} and n ∈ N)
corresponds to the training inputs and X∗ = (xn+1, xn+2, ..., xn+n∗ ) to the test inputs. K(X, X∗) denotes the n × n∗
matrix of the covariances evaluated for all the (X, X∗) pairs.

The predictive Gaussian distribution can be found by obtaining the conditional distribution given the training data and
the test inputs:

f∗|X∗, X, f ∼ N ( ˆM (X∗), ˆK(X∗, X∗))

ˆM (X∗) = M (X∗) + K(X∗, X)K(X, X)−1f

ˆK(X∗, X∗) = K(X∗, X∗) − K(X∗, X)K(X, X)−1K(X, X∗)

(3)

As in many previous works [11, 6, 12], we consider an a priori equal-to-zero mean function (m(x) = 0) to focus on the
kernel search problem.

2.1 Covariance function

GP models use a PSD kernel to deﬁne the covariance between any two function values [3]:

A PSD kernel is a symmetric function k : Rd × Rd → R that satisﬁes

cov (f (x), f (x(cid:48))) = k(x, x(cid:48))

n
(cid:88)

n
(cid:88)

i=1

j=1

aiajk(xi, xj) ≥ 0

(4)

(5)

for any n ∈ N, x1, ..., xn ∈ Rd and a1, ..., an ∈ R.
If a kernel function holds Equation (5), then the covariance matrix C, where cij = k(xi, xj), n ∈ N and x1, ..., xn ∈ Rd
is:

• symmetric, i.e., C = C T .
• a PSD matrix. A matrix is PSD if and only if vT Cv ≥ 0 for all real vectors v ∈ Rn. It is equivalent to say

that all its eigenvalues are non-negative.

2.2 Well-known kernel functions

In this section, we introduce some of the best-known kernel functions. These kernels can be divided into two main
families: stationary and non-stationary kernels [4].

A stationary kernel is translation invariant. Among the stationary kernels, we focus on isotropic kernels, as they are the
most used kernel functions in the literature. In such kernels, the covariance function depends on the norm:

k(x, x(cid:48)) = ˆk(r) where r =

1
θl

(cid:107)x − x(cid:48)(cid:107)

(6)

where θl is the lengthscale hyperparameter and ˆk a function that guarantees that the kernel is PSD. The lengthscale
hyperparameter can be also a vector that expresses the relevance of each dimension d, as suggested in Automatic
Relevance Determination (ARD) approaches [13, 14].

On the other hand, non-stationary kernels are the ones that may vary with translation. Within this family, the most
common kernels are those that depend on the dot product of the input vectors. These kernels are usually referred to as
dot-product kernels:

(x − θs1) (x(cid:48) − θs1)T

(7)

k(x, x(cid:48)) = ˆk(s) where s =

3

1
θl

A PREPRINT - OCTOBER 15, 2019

where θl is again the lengthscale hyperparameter, θs is the shift hyperparameter and 1 is a vector of ones.

Table 1 shows eleven well-known kernels generally used in GP applications [1, 3]. The Squared Exponential (SE)
kernel, also known as radial basis function (RBF), is one of the most popular choices, and it is described as kSE in the
table. This kernel is known to capture the smoothness property of the objective functions.

Constant
White Noise
Exponential
γ-exponential
Squared Exp.
Matern 12
Matern 32
Matern 52
Rat. Quadratic

Periodic

Linear

Kernel function expressions
kCON (x, x(cid:48)) = θc
kW N (x, x(cid:48)) = θc δ(x, x(cid:48))
ˆkE(r) = θ2
ˆkEγ(r) = θ2
ˆkSE(r) = θ2
ˆkM 12(r) = θ2
ˆkM 32(r) = θ2
0
ˆkM 52(r) = θ2
0
ˆkRQ(r) = θ2
0
ˆkP ER(r) = θ2
ˆkLIN (s) = s

0 exp (−r)
0 exp (−rγ)
0 exp (cid:0)− 1
2 r2(cid:1)
0exp (−r)
√
3r(cid:1) exp (cid:0)−
(cid:0)1 +
√
(cid:0)1 +
5r + 5
(cid:0)1 + 1
2α r2(cid:1)−α
(cid:16)
− 2 sin2(πr)
0 exp
θ2
p

(cid:17)

√
3r(cid:1)
3 r2(cid:1) exp (cid:0)−

√

5r(cid:1)

Table 1: Well-known kernel functions. θ0 and θp are the kernel hyperparameters called amplitude and period respectively.
δ is the Kronecker delta.

2.3 Model selection

The choice of the kernel function and its hyperparameters has a critical inﬂuence on the behavior of the model, and it is
crucial to achieve good results in any application of GPs. This selection has been usually made by choosing one kernel
a priori, and then adjusting the hyperparameters of the kernel function so to optimize a given metric for the data.

Although a variety of methods have also been proposed to optimize the hyperparameters [15, 16, 17, 18], the most
common approach is to ﬁnd the hyperparameter set that maximizes the log marginal likelihood (LML):

log p (f |X, θ) = −

1
2

mT

a K −1

a ma −

with

ma = f − M (X)
Ka = K(X, X)

1
2

log |Ka| −

n
2

log 2π

(8)

where θ is the set of hyperparameters of the kernel and n is the length of X.

Alternatively, a leave-one-out cross validation (LOOCV) metric was proposed [1], where the likelihood of the posterior
distributions are added:

LLOO(X, f , θ) =

n
(cid:88)

i=1

log p (fi|X, f−i, θ)

log p (fi|X, f−i, θ) = −

(fi − µi)2
2σ2
i

−

1
2

log σ2

i −

1
2

log 2π

(9)

where µi and σi are the posterior mean and variance for xi given X−i and f−i

2.

The selection of the right set of hyperparameters is known to be a hard problem, particularly when few observations are
available [12, 19, 20]. Although in most cases the gradient of the LML and the LOOCV has a closed-form expression,
depending on the problem, these functions can be multi-modal and a greedy search procedure may lead to suboptimal
results.

2X−i notation is used to indicate that xi was removed from X.

4

A PREPRINT - OCTOBER 15, 2019

2.4 Kernel composition

When creating new kernels, it is usually difﬁcult to prove whether they are PSD or not. However, there are certain
operations which guarantee that if the source kernels are PSD, the result is also a PSD kernel [3, 21]. Below we list
some of the operations that are guaranteed to keep the positive semi-deﬁniteness of its components:

• Sum: k(x, x(cid:48)) = k1(x, x(cid:48)) + k2(x, x(cid:48)).
• Product: k(x, x(cid:48)) = k1(x, x(cid:48)) × k2(x, x(cid:48)).
• Polynomial: k(x, x(cid:48)) = p(k1(x, x(cid:48))), where p is a polynomial function with non-negative coefﬁcients.
• Exponential: k(x, x(cid:48)) = exp(k1(x, x(cid:48))).
• Composition with a function: k(x, x(cid:48)) = f (x)k1(x, x(cid:48))f (x(cid:48)), with f : Rd → R.
• Mapping: k(x, x(cid:48)) = k1(Ψ(x), Ψ(x(cid:48))), with Ψ : Rd → Rd.

3 Gaussian Process kernel representation as elementary mathematical expression trees

While previous approaches have proposed the composition of kernel functions, in this work we break down the
well-known kernels of Table 1 into basic mathematical expressions, in order to use them as the building blocks for new
kernels. Thus, these well-known kernel functions and their sum/product compositions are a subset of our search space.

The kernel functions are described as an expression tree, composed by the set of the operators and terminals shown in
Table 2. The expression tree is strongly-typed [22], as the output of each node matches the input type of its ancestor.

Our grammar considers a pair of input vectors (their symbol is denoted as x) and a vector of hyperparameters (denoted
as hp1, hp2, ...) as arguments of the kernel function. As in [23], the grammar also contains the spectral transformation,
in order to allow periodic kernels. Furthermore, the square distance and dot product are included as described in
Section 2.1. Note that the expressions denoted by the symbols euc and hp do not modify the input. These expressions
are included to constrain the random kernel generation as explained in detail in Section 4.1.1. In addition, our grammar
includes the +, ×, and ˆ arithmetic operators, having their usual meanings (addition, product and power, respectively).
Note that we only allow hyperparameters as the exponent in the power operator. The same interpretation is given to the
unary operators, such as the square root and the natural exponent. The power to the minus one is also added as an unary
operator (denoted as div). Finally, our grammar considers some constants that are commonly found in kernel functions
as terminals. Although the White Noise kernel could be included as a terminal in the grammar, it is added to all the
kernels generated during the search in order to model the noise (See Section 6.2).

4 Evolving kernel functions based on the new grammar

Once the grammar has been introduced, we present our GenProg approach for GP kernel search, EvoCov. This algorithm
takes into account two challenges related to this problem: The cost of evaluating the ﬁtness function (mainly due to
hyperparameter optimization) and the fact that many of the kernels generated during the search are not PSD.

Our GenProg approach is shown in Algorithm 1. First, an initial population of N kernels is generated. In order to do so,
each individual is created at random, limited by a maximum (dmax) and a minimum (dmin) depth. Each generation, the
whole population is evaluated. Next, the relative improvement is measured. If the relative improvement in the current
population is greater than a threshold β, a new population is generated through selection and variation. After selecting
the µ best individuals, the algorithm randomly chooses the variation method between a mutation or a crossover operator
(with probability pm and pcx respectively, where pcx = 1 − pm) to generate an offspring population of N − µ new
individuals. The next population is made up of the selected individuals and the offspring population3. When the relative
improvement is lower or equal to the threshold, the best individual is saved and the current population is replaced by a
randomly generated one. This procedure is repeated for G generations, until the last population is evaluated and the
best individual found during the whole process is returned.

In this section we describe each of the methods used by Algorithm 1. First, we address the issue of randomly generating
new kernels for the initial population. The distinguished characteristic of our proposal for generating the random kernels
is that it does not take into account any kernel proposed in the literature, while guaranteeing a minimum depth and a
maximum depth. Then, we provide the variation operators conceived to generate kernels that are likely to inherit useful
properties from the selected ones. A method to control the depth of the trees created by the variation operators is also

3Note that, some individuals may be evaluated several times as is explained in Section 4.3.2.

5

A PREPRINT - OCTOBER 15, 2019

Input

Expression

Symbol
x
hp0
hp1
...
hpt

euc

.
s
g
r
A

e
l
b
a
t
s
e
N

t
o
N

e
l
b
a
t
s
e
N

s
l
a
n
i
m
r
e
T

(x, x(cid:48))

spectral

(x, x(cid:48)), θp

(ˆx, ˆx(cid:48)), θl

sq_dist
dot_prod (ˆx, ˆx(cid:48)), θs, θl

θ
x, θ
w, v
w, v
w
w
w
w

hp
power
add
multiply
div
exp
sqrt
square
−1
−0.5
0.5
1
2
3
5

ˆx =

ˆx(cid:48) =

(cid:21)T

ˆx = x
ˆx(cid:48) = x(cid:48)
(cid:20)sin(θp ∗ x)
cos(θp ∗ x)
(cid:20)sin(θp ∗ x(cid:48))
cos(θp ∗ x(cid:48))
(cid:107)ˆx − ˆx(cid:48)(cid:107)2
(ˆx − θs) . (ˆx(cid:48) − θs)T

(cid:21)T

z = 1
θ2
l

z = 1
θl

z = θ
z = wθ
z = w + v
z = w × v
z = w−1
z = ew
√
z =
w
z = w2
z = −1
z = −0.5
z = 0.5
z = 1
z = 2
z = 3
z = 5

Output
(x, x(cid:48))
θ
θ
...
θ

(ˆx, ˆx(cid:48))

(ˆx, ˆx(cid:48))

z

z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z

Table 2: Set of expressions used by the grammar. Column "Symbol" refers to the symbol given to each expression
in the grammar. In column "Expression" the assignments (=) of the mathematical expressions to the outputs are
shown. Finally, Columns "Input" and "Output" indicate the input and output types of each expression respectively. In
these columns, (x, x)(cid:48) represents the input vector type, while (ˆx, ˆx(cid:48)) shows the transformed input vector type. The
hyperparameter type is denoted as θ and the z, v, w variables belong to the cov type.

introduced. Next, we explain how the GenProg kernels are evaluated. Finally, for comparison proposes, we include two
simpler methods: Random Search and Go With The First.

4.1

Initial population

We generate kernel functions at random and discard the non-PSD ones until the desired population size is reached.

4.1.1 Random generation

We propose a strongly-typed grow method to randomly generate kernel expression trees, based on the work done in
[10]. This is achieved by a recursive process where, at each step, a random terminal or operator is added.

When randomly generating solutions, some of the solutions may be small and trivial, and some other may be too
complex. Thus, we propose a method to control the depth of the generated trees by setting a minimum (dmin) and a
maximum depth (dmax). As can be seen in Table 2, some of the expressions have at least one input that matches the
output type. These expressions guarantee that, once selected, the iterative procedure can continue growing this branch,
i.e., these expressions are nestable.

As can be seen in Algorithm 2, during the recursive process, we select a random expression depending on the current
type. If the minimum depth has not been reached, only the operators that can be nested are used. Then, until the
maximum depth is reached, any operator can be selected. Finally, when the maximum depth is reached, only the
terminals, arguments and the operators that can not be nested are used, limiting the depth of the tree.

6

A PREPRINT - OCTOBER 15, 2019

(cid:46) Restart procedure

(cid:46) No candidate expressions

|bestf itnessi|

EVALUATE(pop)
bestf itnessi = BESTFITNESS(pop)
relimprov = bestf itnessi−1−bestf itnessi
if β < relimprov then

best = ∅
pop = GENRANDPOP(N , dmin, dmax)
bestf itness0 = ∞
i = 1
while i < G do

Algorithm 1 EvoCov algorithm
1: procedure EVOCOV(N , G, µ, pm, pcx, β, dmin, dmax)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
end while
21:
EVALUATE(pop)
22:
best = SELECT(pop ∪ {best}, 1)
23:
return best
24:
25: end procedure

sel = SELECT(pop, µ)
of f spring = VARIATE(sel, N − µ, pm, pcx)
pop = of f spring ∪ sel
bestf itnessi−1 = bestf itnessi

best = SELECT(pop ∪ {best}, 1)
pop = GENRANDPOP(N , dmin, dmax)
bestf itnessi−1 = ∞

end if
i = i + 1

else

end if

candexprs = candexprs ∪ nests

candexprs = candexprs ∪ terms

end if
if 4 <= dmax then

candexprs = candexprs ∪ notnests
if dmin <= 1 then

terms = GETTERMINALSANDARGS(type)
notnests = GETNOTNESTABLE(type)
nests = GETNESTABLE(type)
candexprs = ∅
if dmin <= 3 then

Algorithm 2 Random Generation of expression trees
1: procedure TYPEDGROW(dmin, dmax, type)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
end for
26:
return expr
27:
28: end procedure

end if
expr = RANDOMCHOICE(candexprs)
if NINPUT(expr) == 0 then

end if
if candexprs is ∅ then

end if
for input in expr do

return expr

candexprs = terms ∪ notnests ∪ nests

inputtype = TYPE(input)
subexpr = TYPEDGROW(dmin − 1, dmax − 1, inputtype)
APPEND(expr, subexpr)

7

A PREPRINT - OCTOBER 15, 2019

4.1.2 Checking positive semi-deﬁniteness

Non-PSD kernels should be excluded from our search space as they are not valid for GP. Although it is computationally
unfeasible to guarantee that every single kernel is PSD, we follow an efﬁcient method to identify most of the non-PSD
kernels, similar to the work carried out in the SVM literature [24, 25, 26].

As mentioned in Section 2.1, any covariance matrix generated by a PSD kernel has to be symmetric and also PSD. To
identify non-PSD kernels, we generate w random uniformly distributed data sets X = (x1, x2, ..., xn) (where xi ∈ Rd,
i ∈ {1, ..., n} and n ∈ N) and check the covariance matrix C produced by the kernel for each data set. If any covariance
matrix matches the following cases, the kernel is rapidly discarded:

• C (cid:54)= C T : As previously mentioned, the covariance matrix given by a PSD kernel should be symmetric.
• Any cii is negative: It has been proved [27] that, if any of the elements in the main diagonal are negative, the

covariance matrix is not PSD.

• Any of the eigenvalues of C is negative: Similarly, all the eigenvalues of the covariance matrix should be

non-negative.

Not matching these cases is necessary but not sufﬁcient for a kernel to be PSD. If after meeting this condition, during the
evaluation step, we ﬁnd out that the kernel is not PSD, the ﬁtness value of the kernel is penalized. However, this validity
check is severe enough to avoid most of the false positives. Among the kernels that were generated and validated during
the experiments conducted in this paper, only 0.67% were not evaluable.

4.2 Variation operators for kernel generation

Our kernel search method is based on perturbation or variation methods that modify previous solutions to obtain new
ones. We use two variation operators, which are randomly selected every VARIATE function call in Algorithm 1: A
crossover operator, which combines two kernel functions to generate a new one that keeps some of the features of its
parents, and a mutation operator, which introduces slight modiﬁcations to the original kernel to obtain a new individual.
We also explain how we control the depth of the trees generated by these variation methods.

4.2.1 Crossover

A purely random crossover operator hardly ever produces PSD kernels. Since kernel function evaluation is a computa-
tionally costly process, we would like to avoid non-PSD kernels. As explained in Section 2.4, the product or the sum
of two PSD kernels is also PSD. Hence, a crossover method could just combine two PSD kernels with any of these
operators to generate a new PSD kernel. However, this procedure rapidly increases the depth of the expression trees.

Therefore, we propose a crossover operator that randomly selects a subtree from each kernel and combines them with
the sum or the product operator. As this method does not guarantee that the resulting kernel is PSD, this operation must
be repeated if a non-PSD kernel is found. Nevertheless, the method increases the chance of obtaining a PSD kernel,
since if both of the subtrees are PSD, the result is guaranteed to be also PSD.

4.2.2 Mutation

The mutation operator works by randomly selecting one of the following methods in a type-safe manner:

Insert: Inserts an elementary mathematical expression (see Table 2) at a random position in the tree, as long as their
output types agree. The subtree at the chosen position is used as the input of the created expression. If more
inputs are required by the new primitive, new terminals are chosen at random.

Shrink: This operator shrinks the expression tree by randomly choosing a branch and replacing it with one of the

branch inputs (also randomly chosen) of the same type.

Uniform: Randomly selects a point in the expression tree and replaces a subtree at that point by the subtree generated
using our random generation method (Described in detail in Section 4.1.1). Note that the output type of the
random generated subtree must match the output type of the replaced one.

Node Replacement: Replaces a randomly chosen operator from the kernel expression by an operator with the same

number of inputs and types, also randomly chosen.

As these methods do not guarantee that the generated kernels are PSD, mutations are repeated if a non-PSD kernel is
detected (see Section 4.1.2).

8

A PREPRINT - OCTOBER 15, 2019

4.2.3 Bloat control

None of the variation methods limit the depth of the kernel expression. Depending on the operators, the depth of the
expression trees may increase without any limit during the search, making the resulting kernel functions complex and
useless for practical applications. This is a well known problem in GenProg literature, known as bloating [10]. In our
work, when the depth of a kernel expression becomes larger than omax, we discard the expression. In this case, the
mutation or the crossover method is repeated until a kernel with the desired depth is obtained, or a limit of ρmax trials
is reached. If this number of trials is exceeded, one of the parent kernels is returned unchanged.

4.3 Evaluation

In our approach, in contrast to other GenProg applications, the solutions do not encode all the necessary information to
be evaluated. In order to evaluate each kernel, we need to set the value of the hyperparameters. Thus, the ﬁtness of
the solutions depends on the results of the hyperparameter optimization. Both search procedures, the selection of the
best hyperparameters for each kernel and the selection of the best kernel given these hyperparameters, are illustrated in
Figure 1.

Figure 1: Two nested search procedures: The selection of the best hyperparameters for each kernel is made according to
a given metric, such as LML or LOOCV, and the selection of the best kernel according to the BIC.

As in [9], we use the Bayesian Information Criterion (BIC) [28] as a quality metric for each kernel. BIC is a metric for
model selection which adds a regularization term to the LML to penalize the complexity of the kernels. This metric
serves as the ﬁtness function of our GenProg algorithm and it can be expressed as follows:

BIC(ki) = −2 log p (f |X, ki, θi,best) + q log n

(10)

where q is the number of hyperparameters of the kernel and n is the number of data points in X. θi,best is the best
hyperparameter set for the kernel ki according to a given metric.

Before computing the BIC associated to a given kernel, the hyperparameters have to be optimized. As we have seen in
Section 2.3, several metrics (LML, LOOCV, ...) can be used to measure the quality of each hyperparameter set. Thus,
we ﬁnd the best hyperparameter set for kernel i as follows:

θi,best = argmaxj METRIC (f , X, ki, θi,j)

(11)

4.3.1 Hyperparameter Optimization Algorithm

The hyperparameters are optimized by means of Powell’s local search algorithm [29]. As this algorithm is not bounded,
the search space has to be constrained by penalizing non-feasible hyperparameter sets. On the other hand, as the
function to optimize might be multi-modal, a multi-start approach was used, performing a restart every time the stopping
criteria of the Powell’s algorithm are met, and getting the best overall result. Note that, as a result of the inclusion of
the randomized restarts, the hyperparameters found for a certain kernel in two independent evaluations may not be the
same. In fact, this implies that the ﬁtness function optimized by the GenProg algorithm, i.e., BIC, is stochastic.

9

θ1,1k1METRIC1,1θ1,2...θ1,jθ1,bestargmaxjMETRIC1,2METRIC1,jθ2,1k2METRIC2,1θ2,2...θ2,jθ2,bestargmaxjMETRIC2,2METRIC2,jθi,1kiMETRICi,1θi,2...θi,jθi,bestargmaxjMETRICi,2METRICi,jkbestargmaxiBIC1BIC2BICi...A PREPRINT - OCTOBER 15, 2019

4.3.2 Random Restarts and Hyperparameter inheritance

The initial solutions for the restarts of the hyperparameter optimization algorithm are sampled from two different
distributions depending on the origin of the kernel. In the randomly generated kernels, the initial hyperparameters for
these restarts are sampled from a uniform distribution within the search bounds. On the other hand, if a kernel is gener-
ated through any of the variation methods, we take advantage of the information gathered in previous hyperparameter
optimization procedures by adapting the inheritance technique described in [9] and [7] to the particularities of GenProg.
Instead of restarting the multi-start optimization from a uniform distribution, each restart is sampled from a Gaussian
distribution centered on the hyperparameter values of the parent individuals and with a pre-deﬁned variance (σθ). This
inheritance method is particularly useful when the variation performs few changes to the expression tree.

Note that, in Algorithm 1, the selected individuals are kept for the next population and the whole population is evaluated
each generation. Thus, some individuals may be evaluated several times during the search. This procedure, along
with the hyperparameter inheritance, allows the selected individuals to keep optimizing their hyperparameters across
generations, and compete fairly with the individuals in the offspring population, which inherit the hyperparameters.

4.4 Selection

We perform a search in the kernel function space to ﬁnd the kernel that maximizes the BIC. Thus, the selection operator
shown in Algorithm 1 selects the µ best kernels according to the BIC metric by applying truncation selection.

4.5 Alternative search methods

In order to verify that every component of the proposed GenProg algorithm is providing a beneﬁt to the kernel search,
we introduce two algorithms to be used as a baseline in the experiments. First, we describe a Random Search algorithm
to test the contribution of the components of EvoCov with the exception of the random generation method. Then, we
propose a Go With The First algorithm, which does not depend on the crossover operator, in order to measure the gain
produced by this operator.

4.5.1 Random Search

This Random Search method generates a random population by iteratively following the random generation method
described in Section 4.1.1 until the desired population size is achieved (N ). Next, it chooses the best solution according
to the selection criterion described in Section 4.4.

4.5.2 Go With The First

This algorithm generates an initial population of size G and, for each individual, a hill-climbing procedure is applied
for N evaluations. This procedure is carried out by generating a random mutation, and keeping the best solution
between the original and the mutated one. Once all the individuals in the population have been optimized following this
procedure, the worst one according to the selection criteria is discarded. This whole process is repeated until only one
kernel is left.

5 Related work

In this section, we review the work carried out in the literature related to this paper. First, we discuss works that design
ad hoc kernels based on expert knowledge. Subsequently, we review the works which propose an automatic design of
kernels.

In ad hoc kernel approaches [1, 30], the authors assume that the choice of the kernel function is clear from a priori
knowledge about the problem. Then, the hyperparameters are optimized to adjust each kernel. In [1], an ad hoc kernel
is introduced to ﬁt the Mauna Loa Atmospheric CO2 time-series, which is a well-known problem in the GP literature
due to its several periodic patterns. On the other hand, in [31], the authors propose a product of a Squared Exponential
and a periodic kernel to construct a control signal. Similarly, the authors of [30] designed an ad hoc kernel to predict
the number of occurrences of certain hashtags in Twitter, given the past records. Finally, the authors of [32] took
advantage of the Bochner Theorem [33] to design kernels that were able to model the periodical patterns of time-series.
Regarding the hyperparameter optimization, Deep Learning methods have also been applied to pre-train and ﬁne-tune
the hyperparameters of the covariance functions [34].

Regarding the automatic design of kernels, many works have followed the kernel composition approach by using
the properties shown in Section 2.4 to generate new kernels [8, 9]. Authors of [8] propose a GenProg method for

10

A PREPRINT - OCTOBER 15, 2019

compositional kernel search, using the well-known kernels shown in Table 1 as building blocks. They also consider
the sum, product and scale as primitives, along with a dimension mask. The hyperparameters where not included in
the grammar, as only the hyperparameters present in the well-known kernels are considered. The experimentation of
this work was limited to the Mauna Loa Atmospheric CO2 time-series and some synthetic 2-dimensional data sets. In
addition to GenProg, other search methods have been proposed to search for kernel composition structures in GPs, such
as the greedy search procedure proposed in [9]. In that work, the best kernel function in terms of BIC is searched in
the space of possible compositions (sums and products) of simpler kernels. In [7], the authors improve the previous
approach by adding change-point and change-window kernels. Finally, in [35], Bayesian Optimization was used to
search in the model space.

The idea of using elementary mathematical expressions as building blocks of kernel functions has been applied to
other ﬁelds, such as Support Vector Machines (SVMs) [25] and Relevance Vector Machines (RVMs) [36]. Some of
these approaches [36, 37, 38] do not guarantee that kernels are PSD. In SVM and RVM, although kernels theoretically
have to be PSD in order to do the kernel-trick, in practice, many kernels can be used even if they are not of this kind.
Some other approaches, such as [39] and [40], guarantee that the kernels are PSD by means of the kernel composition
properties shown in Section 2.4, similar to the compositional kernel search methods in the GP literature. Finally, in
[24], [25] and [26] the non-PSD kernels are penalized or discarded as in our approach. The authors of [25] and [26]
propose a method to penalize (giving the worst possible ﬁtness) the non-PSD kernels in evaluation time. On the other
hand, in [24], if during the random generation a non-PSD kernel is found, it is discarded and the creation is retried.
However, as stated by the authors, their approach was not able to improve the results of the standard kernels in SVM.
The above mentioned approaches deal with hyperparameters by means of optimizing small grids or adding random
constants to the GenProg grammar. To the best of our knowledge, more complex techniques such as the hyperparameter
inheritance have not been applied in this context.

6 Experiments

In this section, we describe the experiments we carried out to analyze the performance of our proposal. We solve
extrapolation problems from real-world time-series and compare our proposal to the main methods discussed in
Section 5 (compositional kernel methods and ad hoc kernel approaches) in such tasks. The goal of our experiments is
three-fold:

• To compare EvoCov to state-of-the-art methods that rely on kernel composition.
• To compare our proposal to the ad hoc kernels proposed in the literature.
• To study the inﬂuence of the metric used to optimize the hyperparameters in time-series extrapolation problems.

First, an introduction to the time-series extrapolation problem is given, before describing the experimental setup. Then,
three experiments are shown, one for each objective of the experimentation.

6.1 Time-series extrapolation problems

The objective in time-series extrapolation is to predict future time-stamp values given some previous data. While
properties like the smoothness of the data have been extensively studied in GP literature for interpolation problems,
other properties required in extrapolation have not been studied to the same extent, such as periodicities and trends.

Real-world time-series problems have been considered for the evaluation of our methods, as they are more realistic than
the synthetic environments. The selected problems are characterized by a limited amount of usually noisy data with
strong variations between training and test sets.
In Table 3, the real-world time-series used in the ﬁrst two experiments are described4. Following the work done in [7],
we have trained all the algorithms on the ﬁrst 90% of the data, predicted the remaining 10%, and then computed the
root mean squared error (RMSE) for that 10%.

6.2 Experimental Setup

Our algorithms were coded in Python, based on the EA software DEAP5 [41]. For the GP regression, a noisy approach
was used, adding a white noise kernel to all the generated kernels, including a noise hyperparameter. For the random
generation method, dmin = 5 and dmax = 15 were used to limit the size of each expression tree. In order to discard

4The time-series data can be found at https://datamarket.com/data/list/?q=provider:tsdl
5https://deap.readthedocs.io

11

A PREPRINT - OCTOBER 15, 2019

Name
Airline
Solar
Mauna Loa Atmospheric CO2
Beveridge Wheat Price Index
Daily minimum temperatures in Melbourne
Internet trafﬁc data (bits)
Monthly average daily calls
Monthly critical radio frequencies
Monthly production of gas in Australia
Monthly prod. of sulphuric acid in Australia
Monthly U.S. male unemployment
Number of daily births in Quebec
Real daily wages in England (£)

Properties
P, AT
P, C
P, AT
P, C
P N
P+

Size
144
402
545
370
1000
1000
180 N, C
240
476
462 N
408
1000 N
735 EXP

P+
P, AT

P, AT

Table 3: Description of the time-series used in the experiments. The visually identiﬁable periodic patterns are described
with the letter P, and if many periods are present, P+ is shown. The ascendant trends are represented by AT and
exponential growths by EXP. N denotes the presence of noise, while C indicates a trend change at some point in the
time-series.

the non-PSD kernels, the positive semi-deﬁniteness conditions described in Section 4.1.2 were checked in w = 20
random data sets. On the other hand, to avoid bloating, a maximum depth of omax = 40 was allowed, and the number
of attempts was limited to ρmax = 250 in each variation operator.

In the Random Search algorithm, N = 20000 was set to generate the initial population. Similarly, in the Go With The
First algorithm, G = 13 generations and N = 200 local search evaluations were used in order to have a comparable
evaluation budget. Finally, in the EvoCov approach, N = 141, G = 141, µ = 14, pm = 0.4, pcx = 0.6 and β = 1e−5
were set. Due to the stochastic nature of our algorithms, each kernel search process was repeated 10 times in all the
experiments.

Regarding the hyperparameter optimization, every restart of the Powell’s optimization algorithm, a Gaussian noise
with σθ = 0.1 was added to the inherited hyperparameters. Since the computational time required to evaluate
the hyperparameters increases quadratically with the size of the time-series, in order to keep the computational
cost of optimizing these hyperparameters similar in all the problems, we decided to adjust the number of evalu-
ations allowed in the hyperparameter optimization depending on the length of the time-series. Thus, we allow
max_f un_call = ref _f un_call ∗
current_ts_len2 evaluations, where current_ts_len is the length of the current
time-series and ref _f un_call is a parameter of the algorithm. In the experiment shown in Section 6.3, we allow
ref _f un_call = 5000 evaluations, and in the rest of the experiments ref _f un_call = 300.

3502

6.3 Metric comparison for hyperparameter optimization

In GP literature, hyperparameter optimization is considered a crucial task. Most of the works carried out in this ﬁeld rely
on the LML for hyperparameter optimization [8, 9]. However, it has been reported that the LML may lead to suboptimal
results under certain conditions, where LOOCV could be more robust[42]. Regarding the kernel optimization, having a
consistent method to optimize the hyperparameters helps to obtain more reliable evaluations of the individuals. Hence,
we decided to perform a preliminary experiment to test if other alternative metrics to LML and LOOCV can improve
the results in time-series extrapolation problems.

Apart from the well-known LML and LOOCV, we tested other metrics speciﬁcally designed to optimize the hyperpa-
rameters in extrapolation problems. While the LML measures the probability of the training data given the prior GP, the
goal in extrapolation is to increase the probability of the test data given the posterior GP. Thus, along with the prior
LML, we also measure the posterior LML. By splitting the train set into some train-train and train-test sets, we get
the posterior GP given the train-train set, and measure the probability of the train-test set given this model, i.e., the
posterior LML. On the other hand, the LOOCV measures the ability of the GP to interpolate. To create a version of the
LOOCV metric for extrapolation, we compute the sum of the posterior probabilities of each of the data points in the
train-test set, and call it Sum of Posterior Likelihoods (SoPL). Finally, having the train-train and train-test sets, the
RMSE in the train-test set is also used as a measure given the train-train set.

To compare the performance of these metrics, we considered the best kernels found in [9] for all the time-series
described in Section 6.1. For each metric and time-series, we carried out an optimization process with the Powell’s

12

A PREPRINT - OCTOBER 15, 2019

algorithm, in order to ﬁnd which one leads to the best results in terms of the RMSE in the test set. Each optimization
process starts from a random hyperparameter set and stops when 5000 samples have been taken. Due to the randomness
of the process, 10 trials were carried out.

In Table 4, the average results are shown for the thirteen time-series. The SoPL outperforms the rest of the metrics in
ﬁve of the problems, while LML gets the best overall results in four time-series and RMSE is the best choice in three.
Those three metrics are superior to posterior LML and LOOCV, as the former is only able to obtain the best results in
the Daily Minimum Temperatures in Melbourne time-series, and the latter is not able to beat other metrics in any of the
problems. As expected, in these extrapolation problems LOOCV is the metric with the worst performance.

Airline
Solar
Mauna Loa Atmospheric CO2
Beveridge Wheat Price Index
Daily min. temps. in Melbourne
Internet trafﬁc data (bits)
Monthly average daily calls
Monthly critical radio frequencies
Monthly prod. of gas in Aus.
Monthly prod. of sul. acid in Aus.
Monthly U.S. male unemployment
Number of daily births in Quebec
Real daily wages in England (£)

-LML
37.00
269.12
4.40
54.13
4.92
49352.14
212.22
2.14
13791.03
39.58
142.30
44.78
23.26

-LOOCV -Post. LML
157.96
925.25
3.94
67.94
4.62
38259.26
1460.47
1.27
26403.55
56.56
265.76
49.84
15.16

230.27
539.64
37.61
99.64
6.63
4994073.33
43078.20
2.01
179944.80
1979.48
4436.13
16203.27
40.97

-SoPL
57.10
279.24
2.34
52.58
5.62
23756.89
844.32
0.74
18066.63
53.42
192.34
44.54
15.38

RMSE
97.34
132.04
3.19
266.37
4.67
25970.23
55.08
1.63
50771.39
67.89
219.65
46.40
13.61

Table 4: Hyperparameter optimization metrics compared across different time-series. The average RMSE in the test set
is shown for each metric. Smaller is better in all cases, as the negative LML, LOOCV, posterior LML and SoPL are
shown. The best results for each time-series are shown in bold.

Statistical tests were used to determine if there is a metric that is more robust than the others in time-series extrapolation
problems6. First, we averaged all the RMSE results for each metric and time-series, and applied the Friedman’s test
[44]. We found signiﬁcant differences between all the metrics (p-value = 8.454e−5). Then, we applied a post-hoc test
based on Friedman’s test, and adjusted its results with the Shaffer’s correction [45]. In Figure 2, the critical differences
between the metrics are shown. As can be seen, there are no signiﬁcant differences between SoPL, LML, RMSE and
posterior LML. Similarly, the results between LOOCV and posterior LML do not differ signiﬁcantly.

Figure 2: Critical differences diagram. The metrics are ordered following the results in their ranking. The metrics with
no signiﬁcant differences between them are matched with a straight line.

Overall, it can be seen that there is no metric best suited for all the time-series, and the choice of the best metric depends
on the problem.

As the differences between LML and SoPL are not signiﬁcant, we used two variants of EvoCov for the following
experiments, one using LML to optimize the hyperparameters (EvoCov LML) and the other using SoPL (EvoCov
SoPL).

6The tests were carried out using the SCMAMP R package [43]

13

2345SoPLLMLRMSEPost_LMLLOOCVA PREPRINT - OCTOBER 15, 2019

6.4 Comparing our proposal to compositional kernel search approaches

In kernel learning tasks, the compositional kernel search approaches hold the state-of-the-art results in the GP literature.
In this section we describe the exploratory experiment we carried out initially, and the benchmark where we compare
our algorithms to the compositional kernel search approaches.

6.4.1 Initial Experiment

To begin with, we performed an initial experimentation to test whether better kernels can be found with our grammar,
compared to the kernel composition approaches. Particularly, we would like to know:

1. Whether it is possible to improve the composed kernels by means of manipulating elementary mathematical

expressions, as we propose in this paper.

2. Whether the tree-based representation of kernels, along with the variation operators, allow such an improve-

ment.

Given the best kernels found in [9] for all the time-series, we generated 200 random mutations according to the method
described in Section 4.2.2. Next, we performed a hyperparameter optimization process using the LML metric for each
mutation, departing from the best hyperparameter values found in the original work. Finally, we measured the RMSE in
the test set for all these mutations against the RMSE provided in [9].

As can be seen in Figure 3, there are many mutated kernels that obtain a better RMSE than the original one for the
Mauna Loa Atmospheric CO2 time-series. Moreover, some of those kernels have fewer hyperparameters than the best
kernel achieved in [9] (9 instead of 10).

Figure 3: RMSE and number of hyperparameters of the 200 random mutations for the Mauna Loa Atmospheric
CO2 time-series. The dark triangle represents the original kernel, and the straight lines represent its number of
hyperparameters and RMSE.

In Table 5, similar results to the Mauna Loa Atmospheric CO2 can be found for the rest of the time-series. Among the
200 randomly generated kernels in each of the time-series, there are some kernels that are better ﬁtted according to the
RMSE. Furthermore, in 12 out of 13 time-series there are mutated kernels that have better results in RMSE, with fewer
hyperparameters.

As we have shown in this exploratory experiment, we conclude that it is possible to improve the results obtained by
compositional kernel search approaches by means of manipulating elementary mathematical expressions. We can also
conﬁrm that the mutation operator presented in this work allows such improvements.

6.4.2 Benchmark

In view of results obtained in the previous section, we tested EvoCov, along with the proposed alternative search
methods, in the benchmark presented in [7]. To the best of our knowledge, this work provides the most extensive
comparison in the literature in time-series extrapolation with GPs. In this benchmark the following algorithms can be
found:

14

6789101112# of hyperparameters1234567RMSEA PREPRINT - OCTOBER 15, 2019

Name
Airline
Solar
Mauna Loa Atmospheric CO2
Beveridge Wheat Price Index
Daily min. temps. in Melbourne
Internet trafﬁc data (bits)
Monthly average daily calls
Monthly critical radio frequencies
Monthly prod. of gas in Aus.
Monthly prod. of sul. acid in Aus.
Monthly U.S. male unemployment
Number of daily births in Quebec
Real daily wages in England (£)

Better ﬁtted
0.38
0.55
0.18
0.40
0.23
0.24
0.50
0.36
0.71
0.56
0.47
0.48
0.38

Simpler Both
0.13
0.21
0.05
0.11
0.00
0.07
0.20
0.05
0.30
0.23
0.15
0.13
0.08

0.43
0.32
0.34
0.19
0.27
0.38
0.48
0.30
0.41
0.43
0.38
0.32
0.28

Table 5: Results of the initial experiment. In the ﬁrst column, the ratio of mutated kernels that are better ﬁtted, in terms
of RMSE, than the best kernel achieved in [9] is shown. The ratio of kernels that are simpler, according to the number
of hyperparameters, is illustrated in the second column. In the last column, the ratio of kernels that are both better ﬁtted
and simpler can be found.

Eureqa: A Symbolic Regression engine that uses genetic algorithms to search in the space of the possible equations
[46]. Although this approach may seem similar to our work, Eureqa learns the predictive function itself, while
our approach provides a probabilistic prediction by means of a GP.

Linear Regression (LIN): The basic linear regression is approximated by a GP with a Linear kernel. The hyperpa-

rameters are learned by the LML optimization.

Squared Exponential (SE): A GP with the Squared Exponential kernel shown in Table 1 is used. The hyperparameters

are also learned by optimizing the LML.

Bayesian variant of multiple kernel learning (MKL): A weighted sum of base kernels is used to construct more

complex ones [47].

Change Point (CP) Modeling: A GP based approach allowing changepoints in kernels, that is, a combination of

kernels where the weight of each of the components depends on the inputs [48, 49, 50].
Spectral Mixture Kernels (SK): These kernels model the spectral density with a Gaussian mixture [32].
Trend-Cyclical-Irregular (TCI) Models: The statistical model described in [51] is approximated by means of a GP

and combining the periodic kernels with linear ones as covariance function.
GPSS: The greedy GP kernel search method described in [9] is used, as discussed in Section 5.
ABCD accuracy: An improvement of GPSS, introduced in [7], which includes the ChangeWindow and ChangePoint

kernels.

ABCD interpretability: A modiﬁcation of the previous approach that focuses on interpretability. This approach favors
additive components as they are more interpretable by the practitioners. Similarly, the authors decided to
remove the Rational Quadratic kernel as it is more difﬁcult to describe automatically [7].

All the compositions of kernels that are included in GPSS can be represented in our grammar. Thus, the search space of
EvoCov is a superset of the search space of GPSS. On the other hand, ABCD approaches include ChangeWindow and
ChangePoint kernels that cannot be modeled with the current grammar of EvoCov. Hence, different kernels can be
found by these approaches.

Table 6 shows the numerical results of the experimentation for each time-series, while in Figure 4, the overall results
are shown. EvoCov is presented in two variants, one using LML to optimize the hyperparameters, and the other
variant using the SoPL metric. Note that RMSEs are standardized by dividing by the smallest RMSE achieved in the
experiments for each data set, so that the best performance on each data set has a value of 1. Also, it is worth mentioning
that, in the experiments conducted in [7], only one trial for each time-series and algorithm was carried out7, and, for our
algorithms, the mean and the best of ten trials is shown.

As we can see in Table 6, EvoCov LML achieves the best average result and beats the rest of the algorithms in the
Mauna Loa Atmospheric CO2 time-series. Moreover, its median result is the second best, very close to the best one.

7The results were gathered from the supplementary material of [7].

15

A PREPRINT - OCTOBER 15, 2019

ABCD acc. GPSS ABCD intr.

CP

LIN MKL

SE

SP-bic

TCI

Airline
Solar
Mauna Loa Atmospheric CO2
Beveridge Wheat Price Index
Daily min. temps. in Melbourne
Internet trafﬁc data (bits)
Monthly average daily calls
Monthly critical radio frequencies
Monthly prod. of gas in Aus.
Monthly prod. of sul. acid in Aus.
Monthly U.S. male unemployment
Number of daily births in Quebec
Real daily wages in England (£)
Mean
Median

1.338
1.656
3.461
1.133
1.008
1.462
2.981
5.606
1.005
1.105
2.911
1.173
3.029
2.144
1.462

1.352
2.130
1.460
1.106
1.00*
1.698
2.255
3.316
3.325
1.816
1.664
1.251
3.244
1.971
1.698

2.465
2.082
2.468
1.256
1.005
2.962
1.00*
3.404
2.058
1.596
2.730
1.108
3.997
2.164
2.082

5.629
1.705
4.291
1.063
1.354
6.099
3.539
5.652
3.159
2.488
2.235
2.042
5.835
3.469
3.159

5.797
1.767
7.865
1.084
1.517
7.209
28.760
7.790
2.656
3.893
1.348
2.167
4.246
5.854
3.893

5.554
1.650
4.296
3.189
1.354
5.976
1.798
5.652
2.910
1.782
2.304
2.047
3.160
3.206
2.910

37.804
2.655
4.561
3.225
2.729
6.044
22.628
15.291
2.865
1.198
2.544
1.839
5.350
8.364
3.225

1.174
1.989
3.258
3.188
1.031
4.944
11.035
1.806
1.620
1.576
4.812
1.707
3.634
3.213
1.989

1.693
1.700
3.179
3.188
1.004
3.130
1.798
4.168
1.523
1.991
3.012
1.725
3.116
2.402
1.991

eureqa Random Search Go With The First
Mean
Mean
1.446
3.311
1.837
2.394
1.499
23.441
2.370
2.078
1.005
1.031
3.893
10.779
6.822
7.764
1.346
2.687
2.754
5.017
1.519
2.043
1.585
5.247
1.128
1.738
3.595
3.041
2.362
5.428
1.559
2.684

3.799
4.358
6.278
1.394
1.286
9.149
493.303
2.545
2.739
2.181
3.006
2.138
1.00*
41.014
2.739

Best
1.018
1.082
1.00*
1.00*
1.002
1.641
1.328
1.00*
1.00*
1.00*
1.299
1.00*
2.992

Best
1.178
1.00*
8.531
1.010
1.002
5.320
1.206
1.314
1.794
1.679
1.315
1.300
2.610

EvoCov LML
Best Mean
1.307
1.00*
1.844
1.073
1.349
1.073
1.293
1.044
1.024
1.003
3.626
1.00*
2.814
1.163
1.682
1.069
2.499
1.059
1.426
1.081
1.742
1.00*
1.210
1.049
3.554
2.881
1.951
1.478

EvoCov SoPL
Best Mean
1.559
1.106
1.597
1.011
2.498
1.077
1.774
1.317
1.019
1.005
4.824
1.459
11.692
1.446
4.077
1.778
2.340
1.387
2.328
2.034
1.836
1.168
1.447
1.135
2.561
1.277
2.998
1.831

Table 6: Standardized RMSE for each extrapolation problem and algorithm is shown. In our approaches, the mean and
the best values of the results are illustrated. The best results on average for each time-series are shown in bold, while
the best results overall are highlighted by an asterisk.

Airline
Solar
Mauna Loa Atmospheric CO2
Beveridge Wheat Price Index
Daily min. temps. in Melbourne
Internet trafﬁc data (bits)
Monthly average daily calls
Monthly critical radio frequencies
Monthly prod. of gas in Aus.
Monthly prod. of sul. acid in Aus.
Monthly U.S. male unemployment
Number of daily births in Quebec
Real daily wages in England (£)
Mean

ABCD acc. GPSS ABCD intr.
12
19
12
13
8
26
16
13
21
17
10
6
19
14.8

12
23
10
14
9
18
18
15
28
19
13
-
-
16.3

15
13
11
7
9
15
19
9
21
17
15
11
13
13.5

CP LIN MKL SE SP-bic TCI Random Search Go With The First EvoCov LML EvoCov SoPL
8.5
6.1
6.3
4.8
10.8
6.7
5.8
5.4
5.3
4.5
6.3
4.1
7.6
5.1
8.0
6.0
8.7
5.8
7.2
5.4
8.3
6.4
7.0
5.0
5.6
3.0
7.3
5.3

16
13
12
7
9
13
7
12
13
12
18
9
10
11.6

10.2
7.0
7.0
6.6
4.2
10.1
11.3
7.6
13.4
7.5
7.1
6.8
6.3
8.1

6.3
5.4
4.9
4.9
4.5
6.0
8.2
6.1
8.0
6.5
4.8
5.6
5.0
5.9

8
10
8
5
7
8
7
8
11
9
8
6
7
7.8

5
7
5
5
6
5
7
5
5
7
4
5
7
5.6

8
18
5
13
6
13
11
5
18
13
9
5
18
10.9

3
3
3
3
3
3
3
3
3
3
3
3
3
3

4
4
4
4
4
4
4
4
4
4
4
4
4
4

Table 7: Number of hyperparameters for each extrapolation problem and algorithm. The noise hyperparameter is also
considered. In our approaches, the average number of hyperparameters is shown. In ABCD acc. some data is missing
as it could not be found in the supplementary material of [7].

Figure 4: Standardized RMSE of each algorithm in each problem. Note that the results of our algorithms have more
observations due to the 10 trials.

The best trials of this algorithm outperform the rest of the algorithms in three other problems. Our Go With The First
algorithm is the best choice in Monthly critical radio frequencies time-series, and its best trials were better than the
other algorithms in 6 problems. Although its average performance is not as good as EvoCov LML, it was able to
achieve the third best median RMSE. EvoCov SoPL shows the best behavior in Solar time-series. On the contrary, this
approach obtains poor results in Monthly average daily calls, compromising its average result. The Random Search was
able to get the best result for the Solar time-series in its best trial. However, this algorithm has a worse performance
than those already mentioned, conﬁrming the contribution of the mutation and crossover operators. Regarding the
compositional kernel search approaches, GPSS approach gets the second best mean result, and is able to beat the rest
of the algorithms in Daily minimum temperatures in Melbourne time-series. ABCD accuracy obtains the third best
mean result. This algorithm gets the best median result and holds the best results in three of the time-series. ABCD
interpretability, with worse results than ABCD accuracy according to the mean, is the best approach in Monthly average
daily calls and Number of daily births in Quebec problems. On the other hand, there are some other time-series, such
as Beveridge Wheat Price Index, Monthly U.S. male unemployment and Airline, where the algorithms based on the
CP, Linear and Spectral kernels, get better results than compositional kernel search approaches. Finally, out of the GP

16

llllllllllllllllllllllllllll12345CPABCD inter.ABCD acc.GPSSLINMKLSESP−bicTCIeureqaRandomSearchGo withthe firstEvoCovLMLEvoCovSoPLlllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllStandardised RMSEA PREPRINT - OCTOBER 15, 2019

approaches, Eureqa outperforms the rest of the approaches in Real daily wages in England time-series. However, this
symbolic regression engine is worse than EvoCov LML in the rest of the time-series.

Table 7 shows the number of hyperparameters of the best kernel found for each algorithm in each problem. It can be
seen that the compositional kernel approaches (ABCD interpretability, ABCD accuracy and GPSS) have always more
hyperparameters than any of our approaches on average. The only exception can be found in Number of daily births in
Quebec time-series, where ABCD interpretability uses 6 hyperparameters, and EvoCov LML and EvoCov SoPL use 6.8
and 7.0 hyperparameters respectively.

Overall, EvoCov LML is a competitive approach compared to the current state-of-the-art compositional kernel search
approaches. In spite of not including the ChangePoint and ChangeWindow kernels, this approach is able to obtain
comparable results to ABCD accuracy, with kernels that have fewer hyperparameters, which makes them easier to
optimize.

6.5 Comparing our proposal to ad hoc kernel approaches

As we have mentioned in Section 5, many works in GPs propose a human-designed speciﬁc kernel for each particular
problem. One of the most recent works can be found in [30], where the number of tweets in the Twitter timeline that
contain a given hashtag was predicted by means of a GP. The authors show that this information can be useful to predict
the hashtags that a tweet has, given its content. They propose an ad hoc kernel, Periodic Spikes (PS), that captures the
periodicities of these hashtag time-series. For example, the #goodmorning hashtag shows a clear periodic pattern, as it
is more frequently tweeted in the mornings. On the other hand, there are some hashtags, such as #np (now playing), that
do not follow the periodic pattern mentioned above, and according to the authors, there are kernels better suited than PS
for these problems. Our proposal should be able to identify these situations, and offer the best possible kernel without
human intervention.

Hence, we carried out the same experiment as in [30], where #goodmorning, #breakfast, #confessionhour, #fail, #fyi
and #raw hashtags are predicted8. For each hashtag, the number of tweets per hour was collected, using one month
for training and the other to test, except for the #goodmorning hashtag, as in the original paper, where 3 weeks were
gathered, having 2 weeks to train and the last one to test.

In Figure 5, an example of the hashtag prediction is shown. The number of occurrences of the #goodmorning hashtag is
shown per hour, along with the best model given by our approach in a single run. In this problem, a periodic trend can
be appreciated, which is successfully captured by our model.

Figure 5: Extrapolation of #goodmorning hashtag time-series. The black dots represent the last samples of the train
set, while the red triangles show the samples of the test set. The prediction given by a GP with a kernel learned by the
EvoCov LML method is illustrated with a continuous blue curve for the mean and the light blue shadow shows 3 times
the standard deviation.

8Data can be found in https://web.sas.upenn.edu/danielpr/resources/

17

2011-01-172011-01-240.250.000.250.500.751.001.25# of hashtags per hour (Normalized)A PREPRINT - OCTOBER 15, 2019

Table 8 shows a comparison between EvoCov LML, EvoCov SoPL and the PS kernel. The experiments with the
PS kernel were carried out using our software, and ref _f un_call = 5000 samples were allowed to ﬁnd the best
hyperparameters for this kernel. As can be seen, EvoCov SoPL is the best approach on average, and it obtains the best
results in the #confessionhour problem. EvoCov LML is able to get the best score in the #fail and #fyi hashtags, ﬁnding
a complex periodic pattern. It is also worth mentioning that the best trials of this algorithm obtain the best results in
four out of ﬁve problems. However, in simpler periodic time-series, such as #goodmorning, #breakfast and #raw, the
PS kernel is the best choice, getting the best median result.

#goodmorning
#breakfast
#confessionhour
#fail
#fyi
#raw
Mean
Median

PS

1.072
1.014
323.949
1.028
1.051
1.159
54.879
1.062

EvoCov LML
Best
1.00*
1.00*
1.048
1.00*
1.00*
1.00*

Mean
1.074
1.085
220.262
1.018
1.012
1.407
33.989
1.077

EvoCov SoPL
Mean
Best
1.528
1.374
1.021
1.021
147.540
1.00*
1.019
1.003
1.045
1.031
1.554
1.543
23.069
1.236

Table 8: The PS ad hoc kernel compared to EvoCov LML and EvoCov SoPL, in hashtag prediction problems.
Standardized RMSE for each extrapolation problem and algorithm is shown. In our approaches, the mean and the best
results are illustrated. The best results on average are shown in bold, while the best results overall are highlighted by an
asterisk.

Table 9 shows the number of hyperparameters used by different approaches. As expected, our approaches use more
hyperparameters than the PS kernel, as this kernel is speciﬁcally designed for these problems.

#goodmorning
#breakfast
#confessionhour
#fail
#fyi
#raw
Mean

PS EvoCov LML EvoCov SoPL
7.9
7.9
9.0
6.2
7.8
14.4
5.0
6.2
4.3
3.1
6.8
12.6
6.8
8.4

3
3
3
3
3
3
3

Table 9: Number of hyperparameters for each extrapolation problem and algorithm. The noise hyperparameter is also
considered. In our approaches, the average number of hyperparameters is shown.

The PS kernel is still able to hold the best results in three out of six problems. On the other hand, the EvoCov approaches,
without any expertise about the problem, are able to obtain similar predictions to PS, even improving the results of the
PS kernel in the rest of the problems. Also note that the EvoCov approaches are able to get better average results than
the PS kernel, showing a more adaptable behavior.

7 Conclusions

Kernel functions are widely used in several Machine Learning methods. GPs are one of these techniques, where a PSD
kernel is used as a covariance function. This kernel function has to be carefully selected to achieve good results in any
GP application. Although initial approaches used to rely on predeﬁned kernels or ad hoc solutions for speciﬁc problems,
there is an increasing interest in automatically learning these kernels. In this work, we have presented an evolutionary
approach to learn kernel functions for GPs. While other approaches are based on kernel composition, in our approach,
kernels are modeled by means of basic mathematical expressions.

This work has made the following contributions:

• Basic mathematical expressions as building blocks for GP kernels: We propose to bring the progress made
in other Machine Learning areas to the GPs by considering its covariance function as a program that can be
learned.

18

A PREPRINT - OCTOBER 15, 2019

• Fast PSD check for GP kernels: Although some of the kernels generated by this new random method are not
PSD, we have deﬁned a kernel validation procedure that rapidly discards most non-PSD expression trees based
on the properties of the covariance matrix.

• Hyperparameter inheritance: We have incorporated hyperparameter inheritance within GenProg, improving

the efﬁciency of the algorithm.

• Metric comparison for hyperparameter optimization: We provide valuable insights about the suitability and

performance of several metrics for hyperparameter optimization in extrapolation problems.

• Extensive benchmark in realistic problems: We have evaluated our proposal in an extensive benchmark of

realistic problems, showing that our agnostic algorithm is competitive to a wide range of methods.

Altogether, these contributions enabled the design of a GenProg variant which is able to improve the state-of-the-art
results in the application of GP to time-series extrapolation. We can conclude that there is no need to rely on a priori
deﬁned kernels for GP time-series extrapolation problems, as it is possible to learn simpler and better kernels by
evolving mathematical expression trees that satisfy the PSD restrictions.

Further research in the grammar is suggested, extending it to ChangePoint and ChangeWindow kernels. On the other
hand, we propose continuing the work carried out to measure the performance of the hyperparameter optimization
metrics for GP extrapolation problems.

Acknowledgments

This work has been partially supported by the Basque Government (IT1244-19 and ELKARTEK programs), and
Spanish Ministry of Economy and Competitiveness MINECO (project TIN2016-78365-R). Jose A. Lozano is also
supported by BERC 2018-2021 (Basque government) and Severo Ochoa Program SEV-2017-0718 (Spanish Ministry of
Economy and Competitiveness), while Ibai Roman has held a predoctoral grant from the Basque Government.

References

[1] C. E. Rasmussen and C. K. Williams. Gaussian processes for machine learning. MIT Press, 2006.
[2] Jonas Mockus, V. Tiesis, and A. Zilinskas. The application of Bayesian methods for seeking the extremum. In

Towards Global Optimization, volume 2, pages 117–129. Elsevier, 1978.

[3] David Duvenaud. Automatic model construction with Gaussian processes. Thesis, University of Cambridge, 2014.
[4] Marc G. Genton. Classes of Kernels for Machine Learning: A Statistics Perspective. J. Mach. Learn. Res.,

2:299–312, March 2002.

[5] Manuel Blum and Martin Riedmiller. Optimization of Gaussian Process Hyperparameters using Rprop. In
European Symposium on Artiﬁcial Neural Networks, Computational Intelligence and Machine Learning, 2013.
[6] Eric Brochu, Vlad M. Cora, and Nando de Freitas. A Tutorial on Bayesian Optimization of Expensive Cost
Functions, with Application to Active User Modeling and Hierarchical Reinforcement Learning. arXiv:1012.2599
[cs], December 2010. arXiv: 1012.2599.

[7] James Robert Lloyd, David Duvenaud, Roger Grosse, Joshua Tenenbaum, and Zoubin Ghahramani. Automatic
Construction and Natural-Language Description of Nonparametric Regression Models. In Twenty-Eighth AAAI
Conference on Artiﬁcial Intelligence, June 2014.

[8] Gabriel Kronberger and Michael Kommenda. Evolution of Covariance Functions for Gaussian Process Regression
Using Genetic Programming. In Computer Aided Systems Theory - EUROCAST 2013, Lecture Notes in Computer
Science, pages 308–315. Springer, Berlin, Heidelberg, February 2013.

[9] David Duvenaud, James Lloyd, Roger Grosse, Joshua Tenenbaum, and Ghahramani Zoubin. Structure Discovery
in Nonparametric Regression through Compositional Kernel Search. In Proceedings of The 30th International
Conference on Machine Learning, pages 1166–1174, 2013.

[10] John R. Koza. Genetic Programming: On the Programming of Computers by Means of Natural Selection. MIT

Press, 1992.

[11] Wei Chu and Zoubin Ghahramani. Gaussian Processes for Ordinal Regression. Journal of Machine Learning

Research, 6(Jul):1019–1041, 2005.

[12] Ziyu Wang and Nando de Freitas. Theoretical Analysis of Bayesian Optimisation with Unknown Gaussian Process

Hyper-Parameters. arXiv:1406.7758 [cs, stat], June 2014. arXiv: 1406.7758.

19

A PREPRINT - OCTOBER 15, 2019

[13] David J. C. MacKay. Bayesian Methods for Backpropagation Networks. In Models of Neural Networks III,

Physics of Neural Networks, pages 211–254. Springer, New York, NY, 1996.

[14] Radford M. Neal. Bayesian Learning for Neural Networks. Lecture Notes in Statistics. Springer-Verlag, New

York, 1996.

[15] S. Sundararajan and S. S. Keerthi. Predictive Approaches for Choosing Hyperparameters in Gaussian Processes.

Neural Computation, 13(5):1103–1118, 2001.

[16] D. J. J. Toal, N. W. Bressloff, and A. J. Keane. Kriging Hyperparameter Tuning Strategies. AIAA Journal,

46(5):1240–1252, 2008.

[17] Roman Garnett, Michael A. Osborne, and Philipp Hennig. Active Learning of Linear Embeddings for Gaussian
Processes. In Proceedings of the Thirtieth Conference on Uncertainty in Artiﬁcial Intelligence, UAI’14, pages
230–239, Arlington, Virginia, United States, 2014. AUAI Press.

[18] D. J. J. Toal, N. W. Bressloff, A. J. Keane, and C. M. E. Holden. The development of a hybridized particle swarm

for kriging hyperparameter tuning. Engineering Optimization, 43(6):675–699, 2011.

[19] Romain Benassi, Julien Bect, and Emmanuel Vazquez. Robust Gaussian Process-Based Global Optimization
Using a Fully Bayesian Expected Improvement Criterion. In Carlos A. Coello Coello, editor, Learning and
Intelligent Optimization, number 6683 in Lecture Notes in Computer Science, pages 176–190. Springer Berlin
Heidelberg, 2011.

[20] Adam D. Bull. Convergence Rates of Efﬁcient Global Optimization Algorithms. J. Mach. Learn. Res., 12:2879–

2904, 2011.

[21] Nicolas Durrande, David Ginsbourger, and Olivier Roustant. Additive covariance kernels for high-dimensional
Gaussian process modeling. Annales de la Faculté de Sciences de Toulouse, Tome 21(numéro 3):p. 481–499,
2012.

[22] David J. Montana. Strongly Typed Genetic Programming. Evolutionary Computation, 3(2):199–230, June 1995.

[23] Nooshin HajiGhassemi and Marc Deisenroth. Analytic Long-Term Forecasting with Periodic Gaussian Processes.

In PMLR, pages 303–311, April 2014.

[24] Patrick Koch, Bernd Bischl, Oliver Flasch, Thomas Bartz-Beielstein, Claus Weihs, and Wolfgang Konen. Tuning

and evolution of support vector kernels. Evolutionary Intelligence, 5(3):153–170, September 2012.

[25] L. Diosan, A. Rogozan, and J. P. Pecuchet. Evolving kernel functions for SVMs by genetic programming. In Sixth

International Conference on Machine Learning and Applications (ICMLA 2007), pages 19–24, 2007.

[26] Tom Howley and Michael G. Madden. An Evolutionary Approach to Automatic Kernel Construction. In Artiﬁcial
Neural Networks – ICANN 2006, Lecture Notes in Computer Science, pages 417–426. Springer, Berlin, Heidelberg,
September 2006.

[27] Fuzhen Zhang. Positive Semideﬁnite Matrices. In Matrix Theory, Universitext, pages 199–252. Springer, New

York, NY, 2011.

[28] Gideon Schwarz. Estimating the Dimension of a Model. The Annals of Statistics, 6(2):461–464, March 1978.

[29] M. J. D. Powell. An efﬁcient method for ﬁnding the minimum of a function of several variables without calculating

derivatives. The Computer Journal, 7(2):155–162, January 1964.

[30] Daniel Preo¸tiuc-Pietro and Trevor Cohn. A temporal model of text periodicities using Gaussian Processes. In
Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 977–988,
2013.

[31] E. D. Klenske, M. N. Zeilinger, B. Schölkopf, and P. Hennig. Nonparametric dynamics estimation for time periodic
systems. In 2013 51st Annual Allerton Conference on Communication, Control, and Computing (Allerton), pages
486–493, October 2013.

[32] Andrew Wilson and Ryan Adams. Gaussian Process Kernels for Pattern Discovery and Extrapolation.

In

Proceedings of The 30th International Conference on Machine Learning, pages 1067–1075, 2013.

[33] Salomon Bochner. Lectures on Fourier Integrals. (AM-42). Princeton University Press, 1959. Google-Books-ID:

O1jQCwAAQBAJ.

[34] Geoffrey E Hinton and Ruslan R Salakhutdinov. Using Deep Belief Nets to Learn Covariance Kernels for
Gaussian Processes. In J. C. Platt, D. Koller, Y. Singer, and S. T. Roweis, editors, Advances in Neural Information
Processing Systems 20, pages 1249–1256. Curran Associates, Inc., 2008.

20

A PREPRINT - OCTOBER 15, 2019

[35] Gustavo Malkomes, Charles Schaff, and Roman Garnett. Bayesian optimization for automated model selection.
In D. D. Lee, M. Sugiyama, U. V. Luxburg, I. Guyon, and R. Garnett, editors, Advances in Neural Information
Processing Systems 29, pages 2900–2908. Curran Associates, Inc., 2016.

[36] Wu Bing, Zhang Wen-qiong, Chen Ling, and Liang Jia-hong. A GP-based kernel construction and optimization
method for RVM. In 2010 The 2nd International Conference on Computer and Automation Engineering (ICCAE),
volume 4, pages 419–423, February 2010.

[37] Tom Howley and Michael G. Madden. The Genetic Kernel Support Vector Machine: Description and Evaluation.

Artiﬁcial Intelligence Review, 24(3-4):379–395, November 2005.

[38] Christian Gagné, Marc Schoenauer, Michèle Sebag, and Marco Tomassini. Genetic Programming for Kernel-
Based Learning with Co-evolving Subsets Selection. In Parallel Problem Solving from Nature - PPSN IX, Lecture
Notes in Computer Science, pages 1008–1017. Springer, Berlin, Heidelberg, 2006.

[39] Laura Dio¸san, Alexandrina Rogozan, and Jean-Pierre Pecuchet. Improving classiﬁcation performance of Support
Vector Machine by genetically optimising kernel shape and hyper-parameters. Applied Intelligence, 36(2):280–294,
March 2012.

[40] Keith M. Sullivan and Sean Luke. Evolving Kernels for Support Vector Machine Classiﬁcation. In Proceedings of
the 9th Annual Conference on Genetic and Evolutionary Computation, GECCO ’07, pages 1702–1707, New York,
NY, USA, 2007. ACM.

[41] Félix-Antoine Fortin, François-Michel De Rainville, Marc-André Gardner, Marc Parizeau, and Christian Gagné.
DEAP: Evolutionary Algorithms Made Easy. Journal of Machine Learning Research, 13(Jul):2171–2175, 2012.
[42] François Bachoc. Cross Validation and Maximum Likelihood estimations of hyper-parameters of Gaussian

processes with model misspeciﬁcation. Computational Statistics & Data Analysis, 66:55–69, 2013.

[43] Borja Calvo and Guzmán Santafé. scmamp: Statistical Comparison of Multiple Algorithms in Multiple Problems.

The R Journal, 8(1):248–256, 2016.

[44] Milton Friedman. The use of ranks to avoid the assumption of normality implicit in the analysis of variance.

Journal of the american statistical association, 32(200):675–701, 1937.

[45] Juliet Popper Shaffer. Modiﬁed Sequentially Rejective Multiple Test Procedures. Journal of the American

Statistical Association, March 2012.

[46] Michael Schmidt and Hod Lipson. Eureqa (version 0.98 beta)[software]. Nutonian, Somerville, Mass, USA, 2013.
[47] Francis R. Bach, Gert R. G. Lanckriet, and Michael I. Jordan. Multiple Kernel Learning, Conic Duality, and the
SMO Algorithm. In Proceedings of the Twenty-ﬁrst International Conference on Machine Learning, ICML ’04,
pages 6–, New York, NY, USA, 2004. ACM.

[48] R. Garnett, M. A. Osborne, S. Reece, A. Rogers, and S. J. Roberts. Sequential Bayesian Prediction in the Presence

of Changepoints and Faults. The Computer Journal, 53(9):1430–1446, November 2010.

[49] Yunus Saatçi, Ryan Turner, and Carl Edward Rasmussen. Gaussian Process Change Point Models. In Proceedings
of the 27th International Conference on International Conference on Machine Learning, ICML’10, pages 927–934.
Omnipress, 2010.

[50] Emily B. Fox and David B. Dunson. Multiresolution Gaussian Processes. In F. Pereira, C. J. C. Burges, L. Bottou,
and K. Q. Weinberger, editors, Advances in Neural Information Processing Systems 25, pages 737–745. Curran
Associates, Inc., 2012.

[51] D.A. Lind, W.G. Marchal, and S.A. Wathen. Basic Statistics for Business & Economics. McGraw-Hill/Irwin

series Business statistics. McGraw-Hill/Irwin, 2006.

21

