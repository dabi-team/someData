1
2
0
2

p
e
S
9
2

]

G
L
.
s
c
[

2
v
8
2
2
0
1
.
6
0
9
1
:
v
i
X
r
a

arXiv: arXiv:1906.10228

A Theoretical Connection Between
Statistical Physics and Reinforcement Learning

Jad Rahme and Ryan P. Adams

Princeton University
{jrahme,rpa}@princeton.edu

Abstract: Sequential decision making in the presence of uncertainty and stochastic dynamics gives
rise to distributions over state/action trajectories in reinforcement learning (RL) and optimal control
problems. This observation has led to a variety of connections between RL and inference in probabilistic
graphical models (PGMs). Here we explore a diﬀerent dimension to this relationship, examining
reinforcement learning using the tools and abstractions of statistical physics. The central object in the
statistical physics abstraction is the idea of a partition function Z, and here we construct a partition
function from the ensemble of possible trajectories that an agent might take in a Markov decision
process. Although value functions and 𝑄-functions can be derived from this partition function and
interpreted via average energies, the Z-function provides an object with its own Bellman equation
that can form the basis of alternative dynamic programming approaches. Moreover, when the MDP
dynamics are deterministic, the Bellman equation for Z is linear, allowing direct solutions that are
unavailable for the nonlinear equations associated with traditional value functions. The policies learned
via these Z-based Bellman updates are tightly linked to Boltzmann-like policy parameterizations. In
addition to sampling actions proportionally to the exponential of the expected cumulative reward as
Boltzmann policies would, these policies take entropy into account favoring states from which many
outcomes are possible.

1. Introduction

One of the central challenges in the pursuit of machine intelligence is robust sequential decision making. In a
stochastic and uncertain environment, an agent must capture information about the distribution over ways
they may act and move through the state space. Indeed, the algorithmic process of planning and learning itself
can lead to a well-deﬁned distribution over state/action trajectories. This observation has led to a variety
of connections between reinforcement learning (RL) and inference in probabilistic graphical models (PGMs)
(Levine, 2018). In some ways this connection is unsurprising: belief propagation (and its relatives such as
the sum-product algorithm) is understood to be an example of dynamic programming (Koller and Friedman,
2009) and dynamic programming was developed to solve control problems (Bellman, 1966; Bertsekas, 1995).
Nevertheless, the exploration of the connection between control and inference has yielded fruitful insights
into sequential decision making algorithms (Kalman, 1960; Attias, 2003; Ziebart, 2010; Kappen, 2011; Levine,
2018).

In this work, we present another point of view on reinforcement learning as a distribution over trajectories,
one in which we draw upon useful abstractions from statistical physics. This view is in some ways a
natural continuation of the agenda of connecting control to inference, as many insights in probabilistic
graphical models have deep connections to, e.g., spin glass systems (Hopﬁeld, 1982; Yedidia et al., 2001;
Zdeborov´a and Krzakala, 2016). More generally, physics has often been a source of inspiration for ideas in
machine learning (MacKay, 2003; Mezard and Montanari, 2009). Boltzmann machines (Ackley et al., 1985),
Hamiltonian Monte Carlo (Duane et al., 1987; Neal et al., 2011; Betancourt, 2017) and, more recently, tensor
networks (Stoudenmire and Schwab, 2016) are a few examples. In addition to direct inspiration, physics
provides a compelling framework to reason about certain problems. The terms momentum, energy, entropy,
and phase transition are ubiquitous in machine learning. However, abstractions from physics have generally
not been so far helpful for understanding reinforcement learning models and algorithms. That is not to say
there is a lack of interaction; RL is being used in some experimental physics domains, but physics has not
yet as directly informed RL as it has, e.g., graphical models (Carleo et al., 2019).

Nevertheless, we should expect deep connections between reinforcement learning and physics: an RL
agent is trying to ﬁnd a policy that maximizes expected reward and many natural phenomena can be

1

 
 
 
 
 
 
viewed through a minimization principle. For example, in classical mechanics or electrodynamics, a mass
or light will follow a path that minimizes a physical quantity called the action, a property known as the
principle of least action. Similarly, in thermodynamics, a system with many degrees a freedom—such as
a gas—will explore its conﬁguration space in the search for a conﬁguration that minimizes its free energy.
In reinforcement learning, rewards and value functions have a very similar ﬂavor to energies, as they are
extensive quantities and the agent is trying to ﬁnd a path that maximizes them. In RL, however, value
functions are often treated as the central object of study. This stands in contrast to statistical physics
formulations of such problems in which the partition function is the primary abstraction, from which all the
relevant thermodynamic quantities—average energy, entropy, heat capacity—can be derived. It is natural to
ask, then, is there a theoretical framework for reinforcement learning that is centered on a partition function,
in which value functions can be interpreted via average energies?

In this work, we show how to construct a partition function for a reinforcement learning problem. In
a deterministic environment (Section 2), the construction is elementary and very natural. We explicitly
identify the link between the underlying average energies associated with these partition functions and
value functions of Boltzmann-like stochastic policies. As in the inference-based view on RL, moving from
deterministic to stochastic environments introduces complications. In Section 3.2, we propose a construction
for stochastic environments that results in realistic policies. Finally, in Section 4, we show how the partition
function approach leads to an alternative model-free reinforcement learning algorithm that does not explicitly
represent value functions.

We model the agent’s sequential decision-making task as a Markov decision process (MDP), as is typical.
The agent selects actions in order to maximize its cumulative expected reward until a ﬁnal state is reached.
The MDP is deﬁned by the objects (S, A, R, P). S and A are the sets of states and actions, respectively.
P(𝑠, 𝑎, 𝑠′) = P(𝑠′ | 𝑠, 𝑎) is the probability of landing in state 𝑠′ after taking action 𝑎 from state 𝑠. R(𝑠, 𝑎, 𝑠′)
is the reward resulting from this transition. We also make the following additional assumptions: 1) S is
ﬁnite, 2) all rewards R(𝑠, 𝑎, 𝑠′) are bounded from above by Rmax and deterministic, and 3) the number of
available actions is uniformly bounded over all states by 𝑑. We also allow for terminal states to have rewards
even though there are no further actions and transitions. We denote these ﬁnal-state rewards by R(𝑠 𝑓 ). By
shifting all rewards by Rmax we can assume without loss of generality that Rmax = 0 making all transition
rewards R(𝑠, 𝑎, 𝑠′) non positive. The ﬁnal state rewards R(𝑠 𝑓 ) are still allowed to be positive however.

2. Partition Functions for Deterministic MDPs

Our starting point is to consider deterministic Markov decision processes. Deterministic MDPs are those in
which the transition probability distributions assign all their mass to one state. Deterministic MDPs are a
widely studied special case (Madani, 2002; Wen and Van Roy, 2013; Dekel and Hazan, 2013) and they are
realistic for many practical control problems, such as robotic manipulation and locomotion, drone maneuver
or machine-controlled scientiﬁc experimentation. For the deterministic setting, we will use 𝑠 + 𝑎 to denote
the state that follows the taking of action 𝑎 in state 𝑠. Similarly, we will denote the reward more concisely
as R(𝑠, 𝑎).

2.1. Construction of State-Dependent Partition Functions

To construct a partition function, two ingredients are needed: a statistical ensemble, and an energy function 𝐸
on that ensemble. We will construct our ensembles from trajectories through the MDP; a trajectory 𝜔 is a
sequence of tuples 𝜔 = (𝑠0, 𝑎0, 𝑟0), (𝑠1, 𝑎1, 𝑟1), . . . , (𝑠𝑇 , 𝑎𝑇 , 𝑟𝑇 ) such that state 𝑠𝑇 +1 is a terminal state. We use
the notation 𝑠𝑡 (𝜔), 𝑎𝑡 (𝜔), and 𝑟𝑡 (𝜔) to indicate the state, action, and reward, respectively, of trajectory 𝜔
at step 𝑡. Each state-dependent ensemble Ω(𝑠) is then the set of all trajectories that start at 𝑠, i.e., for
which 𝑠0 (𝜔) = 𝑠. We will use these ensembles to construct a partition function for each state 𝑠 ∈ S. Taking |𝜔|
to be the length of the trajectory, we write the energy function as

| 𝜔 |−1

𝐸 (𝜔) = −

𝑟𝑡 (𝜔) − 𝑅(𝑠 | 𝜔 |) = −

𝑡=0
Õ

2

𝑟𝑡 (𝜔) .

| 𝜔 |

𝑡=0
Õ

(1)

The form on the right takes a notational shortcut of deﬁning 𝑟 | 𝜔 | (𝜔) := 𝑅(𝑠𝑇 +1) for the reward of the terminal
state. Since the agent is trying to maximize their cumulative reward, 𝐸 (𝜔) is a reasonable measure of the
agent’s preference for a trajectory in the sense that lower energy solutions accumulate higher rewards. Note
in particular that the ground state conﬁgurations are the most rewarding trajectories for the agent. With
the ingredients Ω(𝑠) and 𝐸 (𝜔) deﬁned, we get the following partition function

Z(𝑠, 𝛽) =

𝑒−𝛽 𝐸 ( 𝜔) =

𝑒𝛽

| 𝜔|

𝑡=0 𝑟𝑡 ( 𝜔) .

Õ𝜔 ∈Ω(𝑠)

Õ𝜔 ∈Ω(𝑠)

Í

(2)

In this expression, 𝛽 ≥ 0 is a hyper-parameter that can be interpreted as the inverse of a temperature.
(This interpretation comes from statistical physics where 𝛽 = 1
𝐾𝐵𝑇 , where 𝐾𝐵 is the Boltzmann constant.)
This partition function does not distinguish between two trajectories having identical cumulative rewards
but diﬀerent lengths. However, among equivalently rewarding trajectories, it seems natural to prefer shorter
trajectories. One way to encode this preference is to add an explicit penalty 𝜇 ≤ 0 on the length |𝜔| of a
trajectory, leading to a partition function

Z(𝑠, 𝛽) =

𝑒−𝛽 𝐸 ( 𝜔)+𝜇 | 𝜔 | .

Õ𝜔 ∈Ω(𝑠)

(3)

In statistical physics, 𝜇 is called a chemical potential and it measures the tendency of a system (such as
a gas) to accept new particles. It is sometimes inconvenient to reason about systems with a ﬁxed number
of particles, adding a chemical potential oﬀers a way to relax that constraint, allowing a system to have a
varying number of particles while keeping the average ﬁxed.

Note that since MDPs can allow for both inﬁnitely long trajectories and inﬁnite sets of ﬁnite
trajectories, Ω(𝑠) can be inﬁnite even in relatively simple settings. In Appendix A.1, we ﬁnd that a suﬃcient
condition for Z(𝑠, 𝛽) to be well deﬁned is taking 𝜇 < − log 𝑑. As written, the partition function in Eq. 3 is
ambiguous for ﬁnal states. For clarity we deﬁne Z(𝑠 𝑓 , 𝛽) := 𝑒𝛽 𝑅 (𝑠 𝑓 ) for a terminal state 𝑠 𝑓 . We will refer to
these as the boundary conditions.

Mathematically, the parameter 𝜇 has a similar role as the one played by 𝛾, the discount rate commonly
used in reinforcement learning problems. They both make inﬁnite series convergent in an inﬁnite horizon
setting, and ensure that the Bellman operators are contractions in their respective frameworks (A.3 ,B.3).
However, when using 𝛾, the order in which the rewards are observed can have an impact on the learned
policy which does not happen when 𝜇 is used. This could be a desirable property for some problems as it
uncouples rewards from preferences for shorter paths.

2.2. A Bellman Equation for Z

As we have deﬁned an ensemble Ω(𝑠) for each state 𝑠 ∈ S, there is a partition function Z(𝑠, 𝛽) deﬁned for
each state. These partition functions are all related through a Bellman-like recursion:

Z(𝑠, 𝛽) =

𝑒𝛽 R(𝑠,𝑎)+𝜇 Z(𝑠 + 𝑎, 𝛽) ,

(4)

where, as before, 𝑠 + 𝑎 indicates the state deterministically following from taking action 𝑎 in state 𝑠. This
Bellman equation can be easily derived by decomposing each trajectory 𝜔 ∈ Ω(𝑠) into two parts: the ﬁrst
transition resulting from taking initial action 𝑎 and the remainder of the trajectory 𝜔′ which is a member
of Ω(𝑠 + 𝑎). The total energy and length can also be decomposed in the same way, so that:

𝑎
Õ

Z(𝑠, 𝛽) =

𝑒−𝛽 𝐸 ( 𝜔)+𝜇 | 𝜔 | =

Õ𝜔 ∈Ω(𝑠)

𝑒𝛽 R(𝑠,𝑎)+𝜇

Õ𝜔 ∈Ω(𝑠)
𝑒𝛽

| 𝜔|
𝑡=0 𝑟𝑡 ( 𝜔)+𝜇 | 𝜔 |

𝑒𝛽

Í

=

=

Õ𝑎 ∈A

𝑒𝛽 R(𝑠,𝑎)+𝜇 Z(𝑠 + 𝑎, 𝛽) .

| 𝜔|
𝑡=1 𝑟𝑡 ( 𝜔)+𝜇 ( | 𝜔 |−1) =

𝑒𝛽 R(𝑠,𝑎)+𝜇

𝑒−𝛽 𝐸 ( 𝜔′)+𝜇 | 𝜔′ |

Õ𝜔′ ∈Ω(𝑠+𝑎)

Í

Õ𝑎 ∈A

Õ𝜔′ ∈Ω(𝑠+𝑎)

Note in particular that this Bellman recursion is linear in Z.

𝑎
Õ

3

2.3. The Underlying Value Function and Policy

The partition function can be used to compute an average energy to shed light on the behavior of the system.
This average is computed under the Boltzmann (Gibbs) distribution induced by the energy on the ensemble
of trajectories :

P(𝜔 | 𝛽, 𝜇, 𝑠0(𝜔) = 𝑠) =

1Ω(𝑠) (𝜔)
Z(𝑠, 𝛽)

𝑒−𝛽 𝐸 ( 𝜔)+𝜇 | 𝜔 | .

(5)

In probabilistic machine learning, this is usually how one sees the partition function: as the normalizer for an
energy-based learning model or an undirected graphical model (see, e.g., Murray and Ghahramani (2004)).
Under this probability distribution, high-reward trajectories are the most likely but sub-optimal ones could
still be sampled. This approach is closely related to the soft-optimality approach to RL (Levine, 2018).
This distribution over trajectories allows us to compute an average energy for state 𝑠 either as an explicit
expectation or as the partial derivative of the log partition function with respect to the inverse temperature:

h𝐸i =

Õ𝜔 ∈Ω(𝑠)

1
Z(𝑠, 𝛽)

𝑒−𝛽 𝐸 ( 𝜔)+𝜇 | 𝜔 | 𝐸 (𝜔) = −

𝜕
𝜕 𝛽

log Z(𝑠, 𝛽) .

(6)

The negative of the average energy is the value function: 𝑉 (𝑠, 𝛽) := −h𝐸i = 𝜕
𝜕𝛽 log Z(𝑠, 𝛽). This is an
intuitive result: recall that the energy 𝐸 (𝜔) is low when the trajectory 𝜔 accumulates greater rewards,
so lower average energy indicates that the expected cumulative reward—the value—is greater. Since the
partition functions {Z(𝑠, 𝛽)}𝑠 ∈𝑆 are connected by a Bellman equation, we expect that the underlying value
functions {𝑉 (𝑠, 𝛽)}𝑠 ∈𝑆 would be connected in a similar way, and there is indeed a non-linear Bellman recursion:

𝑉 (𝑠, 𝛽) = 𝜕
𝜕 𝛽

log Z(𝑠, 𝛽) =

1
Z(𝑠, 𝛽)
𝑒𝛽 R(𝑠,𝑎)+𝜇 𝜕
𝜕 𝛽

𝜕
𝜕 𝛽

Z(𝑠, 𝛽) =

1
Z(𝑠, 𝛽)

𝜕
𝜕 𝛽

Õ𝑎 ∈A

𝑒𝛽 R(𝑠,𝑎)+𝜇 Z(𝑠 + 𝑎, 𝛽)

Z(𝑠 + 𝑎, 𝛽) + R(𝑠, 𝑎)𝑒𝛽 R(𝑠,𝑎)+𝜇 Z(𝑠 + 𝑎, 𝛽) .

=

1
Z(𝑠, 𝛽)

Õ𝑎 ∈A

The derivative rule for natural log gives us 𝜕
𝜕𝛽

Z(𝑠, 𝛽) = Z(𝑠, 𝛽) 𝜕

𝜕𝛽 log Z(𝑠, 𝛽) = Z(𝑠, 𝛽)𝑉 (𝑠, 𝛽), so:

𝑉 (𝑠, 𝛽) =

1
Z(𝑠, 𝛽)

=

1
Z(𝑠, 𝛽)

Õ𝑎 ∈A

Õ𝑎 ∈A

𝑒𝛽 R(𝑠,𝑎)+𝜇Z(𝑠 + 𝑎, 𝛽)𝑉 (𝑠 + 𝑎, 𝛽) + R(𝑠, 𝑎)𝑒𝛽 R(𝑠,𝑎)+𝜇 Z(𝑠 + 𝑎, 𝛽)

𝑒𝛽 R(𝑠,𝑎)+𝜇Z(𝑠 + 𝑎, 𝛽) [𝑉 (𝑠 + 𝑎, 𝛽) + R(𝑠, 𝑎)] .

(7)

Note that the quantities 𝑒𝛽 R(𝑠,𝑎)+𝜇Z(𝑠 + 𝑎, 𝛽) inside the summation of Eq. 7 are positive and sum to Z(𝑠, 𝛽)
due to the Bellman recursion for Z(𝑠, 𝛽) from Eq. 4. Thus we can view this Bellman equation for 𝑉 (𝑠, 𝛽) as
an expectation under a distribution on actions, i.e., a policy:

𝑉 (𝑠, 𝛽) =

𝜋(𝑎 | 𝑠) [𝑉 (𝑠 + 𝑎, 𝛽) + R(𝑠, 𝑎)]

𝜋(𝑎 | 𝑠) =

Õ𝑎 ∈A

Z(𝑠 + 𝑎, 𝛽)
Z(𝑠, 𝛽)

𝑒𝛽 R(𝑠,𝑎)+𝜇 .

(8)

𝜋𝐵

selects

actions

proportionally

The policy 𝜋 resembles a Boltzmann policy but
is not. A Boltzmann
cumulative
the
policy
reward: 𝜋B(𝑎 | 𝑠) ∝ exp ( 𝛽 [R(𝑠, 𝑎) + 𝑉 (𝑠 + 𝑎)]). In particular, 𝜋𝐵 does not take entropy into account:
if two actions have the same expected optimal value, they will be picked with equal probability regardless
of the possibility that one of them could achieve this optimality in a larger number of ways. In the partition
function view, 𝜋 does take entropy into account and to clarify this diﬀerence we will look at the two extreme
cases 𝛽 → {0, ∞}.

strictly speaking it
exponential

expected

their

to

of

4

When 𝛽 → 0, where the temperature of the system is inﬁnite, rewards become irrelevant and we ﬁnd
𝜔 ∈Ω(𝑠+𝑎) 𝑒 𝜇 | 𝜔 | . This means that 𝜋 is picking action 𝑎 proportionally to the number of
that: 𝜋(𝑎 | 𝑠) ∝
trajectories that begin with 𝑠 + 𝑎. Here the counting of trajectories happens in a weighted way: longer
trajectories contribute less than shorter ones. This is diﬀerent from a Boltzmann policy that would pick
actions uniformly at random.

Í

When 𝛽 → ∞, the low-temperature limit, we ﬁnd in Section A.2
𝜋(𝑎 | 𝑠) ∝ 𝑁max(𝑠 + 𝑎) exp ( 𝛽 [R(𝑠, 𝑎) + 𝑉 (𝑠 + 𝑎)])
that
where
is a weighted count of the number of optimal
𝑁max(𝑠 + 𝑎)
trajectories that begin at the state 𝑠 + 𝑎. Boltzmann policies
completely ignore the 𝑁max entropic factor.

𝑆0

𝑆1

𝑆2

𝑆3

To illustrate this diﬀerence more clearly, we consider the
deterministic decision tree MDP shown in Figure 1 where 𝑆0
is the initial state and the leafs 𝑆4, 𝑆5, 𝑆6, and 𝑆7 are the
ﬁnal states. The arrows represent the actions available at each state. There are no rewards and
the boundary conditions are: R(𝑆4) = R(𝑆5) = R(𝑆6) = 1 and R(𝑆7) = 0. This gives us the boundary
condition: Z(𝑆4, 𝛽) = Z(𝑆5, 𝛽) = Z(𝑆6, 𝛽) = 𝑒𝛽 and Z(𝑆7, 𝛽) = 1. Computing the Z-functions at
the
intermediate states 𝑆1, 𝑆2 and 𝑆3 we ﬁnd: Z(𝑆1, 𝛽) = 2𝑒𝛽+𝜇, Z(𝑆2, 𝛽) = 𝑒𝛽+𝜇 and Z(𝑆3, 𝛽) = 𝑒 𝜇. Finally we
have Z(𝑆0, 𝛽) = 3𝑒𝛽+2𝜇 + 𝑒2𝜇. The underlying policy for picking the ﬁrst action is given by:

Fig 1: Decision Tree MDP

𝑆4

𝑆5

𝑆6

𝑆7

𝜋𝛽 (1 | 0) =

2𝑒𝛽+2𝜇
3𝑒𝛽+2𝜇 + 𝑒2𝜇
When 𝛽 → 0, we get: 𝜋0(1 | 0) = 1
2 , 𝜋0(2 | 0) = 1
three actions with equal probability. The policy 𝜋 is biased towards the heavier subtree.
3 , 𝜋∞(2 | 0) = 1
When 𝛽 → ∞ we get: 𝜋∞(1 | 0) = 2
and 2 with a probability of 1

𝑒𝛽+2𝜇
3𝑒𝛽+2𝜇 + 𝑒2𝜇
4 , 𝜋0(3 | 0) = 1

3 , 𝜋∞(3 | 0) = 0. A Boltzmann policy would pick action 1
2 . 𝜋 prefers states from which many possible optimal trajectories are possible.

𝑒2𝜇
3𝑒𝛽+2𝜇 + 𝑒2𝜇
4 . A Boltzmann policy would pick these

𝜋𝛽 (2 | 0) =

𝜋𝛽 (3 | 0) =

(9)

2.4. A Planning Algorithm

When the dynamics of the environment are known, it is possible to to learn Z(𝑠, 𝛽) by exploiting the Bellman
equation (4). We denote by 𝑠 → 𝑠′ the property that there exists an action 𝑎 that takes an agent from state 𝑠
to state 𝑠′. The reward associated with this transition will be denoted R(𝑠 → 𝑠′). Let Z( 𝛽) = [Z(𝑠, 𝛽)] 𝑠 ∈S be
the vector of all partition functions and 𝐶 ( 𝛽) ∈ R|S |× |S | be the matrix:

𝐶 ( 𝛽)𝑠,𝑠′ = 1𝑠→𝑠′𝑒𝛽R(𝑠→𝑠′)+𝜇 + 1𝑠=𝑠′=ﬁnal state

(10)

𝐶 ( 𝛽) is a matrix representation of the Bellman operator in Eq. 4. With these notations, the Bellman equations
in (4) can be compactly written as: Z( 𝛽) = 𝐶 ( 𝛽) Z( 𝛽) highlighting the fact that Z( 𝛽) is a ﬁxed point of the
map: 𝜙 : 𝑋 → 𝐶 ( 𝛽) 𝑋. In Appendix A.3, we show that 𝜙 is a contraction which makes it possible to learn Z( 𝛽)
by starting with an initial vector Z0 having compatible boundary conditions and successively iterating the
map 𝜙: Z𝑛+1 = 𝐶 ( 𝛽)Z𝑛. We could also interpret Z( 𝛽) as an eigenvector of 𝐶 ( 𝛽). In this context, this algorithm
is simply doing a power method.

Interestingly, we can learn Z( 𝛽) by solving the underdetermined linear system [𝐼 |S | − 𝐶 ( 𝛽)] Z( 𝛽) = 0 |S |
with the right boundary conditions. We show in Appendix A.2 that the policies learned are related to
Boltzmann policies which produce non linear Bellman equations at the value function level:

𝑉 (𝑠, 𝛽) =

𝑎
Õ

𝑒𝛽 (R(𝑠,𝑎)+𝛾𝑉 (𝑠+𝑎,𝛽))
W(𝑠, 𝛽)

[𝑟 (𝑠,𝑎) + 𝛾𝑉 (𝑠 + 𝑎, 𝛽)]

(11)

𝑎 𝑒𝛽 (R(𝑠,𝑎)+𝛾𝑉 (𝑠+𝑎,𝛽)) is a normalization constant diﬀerent
where 𝛾 is the discount factor and W(𝑠, 𝛽) =
from Z(𝑠, 𝛽). By working with partition functions we transformed a non linear problem into a linear one.
This remarkable result is reminiscent of linearly solvable MDPs (Todorov, 2007).

Í

Once Z is learned the agent’s policy is given by: P(𝑎 | 𝑠) ∝ 𝑒𝛽R(𝑠,𝑎) Z(𝑠 + 𝑎, 𝛽).

5

3. Partition functions for Stochastic MDPs

We now move to the more general MDP setting. The dynamics of the environment can now be stochastic.
However, as mentioned at the end of the introduction, we still assume that given an initial state 𝑠, an action 𝑎,
and a landing state 𝑠′, the reward R(𝑠, 𝑎, 𝑠′) is deterministic.

3.1. A First Attempt: Averaging the Bellman Equation

A ﬁrst approach to incorporating the stochasticity of the environment is to average the right-hand side of
the Bellman equation (4) and deﬁne Z(𝑠, 𝛽) as the solution of:

Z(𝑠, 𝛽) =

E𝑠′ |𝑠,𝑎

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

=

P(𝑠′ | 𝑠, 𝑎) 𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽) .

(12)

𝑎
Õ

h

i

𝑎,𝑠′
Õ

Interestingly, the solution of this equation can be constructed in the same spirit of Section 2.1 by
summing a functional over the set of trajectories. If we deﬁne 𝐿(𝜔) to be the log likelihood of a
trajectory: 𝐿(𝜔) =

log P(𝑠𝑡+1 | 𝑠𝑡 , 𝑎𝑡 ) then Z(𝑠, 𝛽) is deﬁned by

| 𝜔 |−1
𝑡=0

Í

Z(𝑠, 𝛽) =

𝑒−𝛽𝐸 ( 𝜔)+𝜇 | 𝜔 |+𝐿 ( 𝜔) ,

(13)

Õ𝜔 ∈Ω(𝑠)

satisﬁes the Bellman equation (12). The proof can be found in Appendix B.1. In Appendix B.2 we derive
the Bellman equation satisﬁed by the underlying value function 𝑉 (𝑠, 𝛽) and we ﬁnd:

𝑉 (𝑠, 𝛽) =

𝑎,𝑠′
Õ

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)
Z(𝑠, 𝛽)

× P(𝑠′ | 𝑠, 𝑎) × (R(𝑠, 𝑎, 𝑠′) + 𝑉 (𝑠′, 𝛽)) .

(14)

This Bellman equation does not correspond to a realistic policy; the policy depends on the landing state 𝑠′
which is a random variable. The agent’s policy and the environment’s transitions cannot be decoupled. This
is not surprising, from Eq. 13 we see that Z puts rewards and transition probabilities on an equal footing.
As a result an agent believes they can choose any available transition as long as they are willing to pay the
price in log probability. This encourages risky behavior: the agent is encouraged to bet on highly unlikely
but beneﬁcial transitions. These observations were also noted in Levine (2018).

3.2. A Variational Approach

Constructing a partition function for a stochastic MDP is not straightforward because there are two types
of randomness: the ﬁrst comes from the agent’s policy and the second from stochasticity of the environment.
Mixing these two sources of randomness can lead to unrealistic policies as we saw in Section 3.1. A more
principled approach is needed.

We construct a new deterministic MDP (˜S, ˜A, ˜R, ˜P) from (S, A, R, P). We take ˜S to be the space of
probability distributions over S, similar to belief state representations for partially-observable MDPs (Astrom,
1965; Sondik, 1978; Kaelbling et al., 1998). We make the assumption that the actions A are the same for
all states and take ˜A = A. For 𝜌 ∈ ˜S and 𝑎 ∈ ˜A we deﬁne ˜P(𝜌, 𝑎) := 𝑃𝑎
𝑇 𝜌 where 𝑃𝑎 is the transition matrix
corresponding to choosing action 𝑎 in the original MDP. We deﬁne ˜R(𝜌, 𝑎) := E𝑠∼𝜌

E𝑠′ |𝑠,𝑎 [R(𝑠, 𝑎, 𝑠′)]

S being ﬁnite, it has a ﬁnite number 𝑀 of ﬁnal states which we denote { 𝑓𝑖}𝑖 ∈{1, ··· , 𝑀 }. The ﬁnal states
(cid:2)
𝑀
𝑖=1 𝛼𝑖 = 1 and 𝛿 𝑓𝑖 is a Dirac delta function at
𝑀
𝑖=1 𝛼𝑖R( 𝑓𝑖). This leads to the

of ˜S are of the form 𝜌 𝑓 =
state 𝑓𝑖. The intrinsic value 𝜌 𝑓 of such a ﬁnal state is then given by R(𝜌 𝑓 ) =
boundary conditions:

𝑀
𝑖=1 𝛼𝑖𝛿 𝑓𝑖 where 0 ≤ 𝛼𝑖 ≤ 1 verify

Í

Í

(cid:3)

.

Í

Z(𝜌 𝑓 ) = exp

𝛽

𝑀

Õ𝑖=1

𝛼𝑖R(𝑠 𝑓𝑖 )

6

=

!

𝑀

Ö𝑖=1

Z( 𝑓𝑖, 𝛽) 𝛼𝑖 .

(15)

 
This new MDP (˜S, ˜A, ˜R, ˜P) is deterministic, and we can follow the same approach of Section 2 and construct
a partition function Z(𝜌, 𝛽) on ˜S. Z(𝑠, 𝛽) can be recovered by evaluating Z(𝛿𝑠, 𝛽). From this construction
we also get that Z(𝜌, 𝛽) satisﬁes the following Bellman equation:
𝑒𝛽R(𝜌,𝑎)+𝜇 Z(𝑃𝑎

Z(𝜌, 𝛽) =

𝑇 𝜌, 𝛽) .

(16)

𝑎
Õ

Just as it is the case for deterministic MDPs, the Bellman operator associated with this equation is
a contraction. This is proved in Appendix B.3. However ˜S is now inﬁnite which makes solving Eq. 16
intractable. We adopt a variational approach which consists in ﬁnding the best approximation of Z(𝜌, 𝛽)
within a parametric family {Z 𝜃 } 𝜃 ∈Θ. We measure the ﬁtness of a candidate through the following loss
function: Δ(𝜃) = 1
|S |

𝑎 𝑒𝛽R( 𝛿𝑠 ,𝑎)+𝜇 Z 𝜃 (𝑃𝑎

Z 𝜃 (𝛿𝑠, 𝛽) −

𝑇 𝛿𝑠, 𝛽)

𝑠 ∈S

2

.

(cid:0)

Í

For illustration purposes, and inspired by the form of the boundary conditions (15), we consider a
𝜌𝑖 , where 𝜃 ∈ R|S |.
simple parametric family given by the partition functions of the form Z 𝜃 (𝜌) =
The optimal 𝜃 can be found using usual optimization techniques such as gradient descent. By evaluation
Z(𝑆𝑖)𝜌𝑖 .
of Z 𝜃 at 𝜌 = 𝛿𝑆𝑖 we see that we must have 𝜃𝑖 = Z(𝛿𝑆𝑖 ) = Z(𝑆𝑖) and consequently we have Z 𝜃 (𝜌) =
The optimal solution satisﬁes the following Bellman equation:

|S |
𝑖=1 𝜃𝑖

|S |
𝑖=1

Î

Í

(cid:1)

Z(𝑠, 𝛽) ≈

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

P(𝑠′ |𝑠,𝑎)

Î

(17)

h
The underlying value function veriﬁes 𝑉 (𝑠, 𝛽) ≈
policy 𝜋 is given by 𝜋(𝑎 | 𝑠) ∝
Í
as its only dependency is on the current state, not a future one, unlike the policies arising from Eq. 14.

𝑎,𝑠′ 𝜋(𝑎 | 𝑠) P(𝑠′ | 𝑠, 𝑎) (R(𝑠, 𝑎, 𝑠′) + 𝑉 (𝑠′, 𝛽)) where the
. This approach leads to a realistic policy

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

P(𝑠′ |𝑠,𝑎)

𝑠′ ∈S

i

𝑎
Õ

Ö𝑠′ ∈S

Î

(cid:2)

(cid:3)

Í

4. The Model-Free Case

4.1. Construction of State-Action-Dependent Partition Function

In a model free setting, where the transition dynamics are unknown, state-only value functions such as 𝑉 (𝑠)
are less useful than state-action value functions such as 𝑄(𝑠, 𝑎). Consequently, we will extend our construction
to state-action partition functions Z(𝑠, 𝑎, 𝛽). For a deterministic environment, we extend the construction in
Section 2 and deﬁne Z(𝑠, 𝑎, 𝛽) by

Z(𝑠, 𝑎, 𝛽) =

𝑒−𝛽𝐸 ( 𝜔)+𝜇 | 𝜔 | =

𝑒𝛽

| 𝜔|
𝑖=0 𝑟𝑖 +𝜇 | 𝜔 |

(18)

Õ𝜔 ∈Ω(𝑠,𝑎)
where Ω(𝑠, 𝑎) denotes the set of trajectories having (𝑠0, 𝑎0) = (𝑠, 𝑎). Since Ω(𝑠) =
Z(𝑠, 𝛽) =
equation:

𝑎 ∈A Ω(𝑠, 𝑎), we have
𝑎 Z(𝑠, 𝑎, 𝛽). As a consequence of this construction, Z(𝑠, 𝑎, 𝛽) satisﬁes the following linear Bellman

Õ𝜔 ∈Ω(𝑠,𝑎)

Ð

Í

Z(𝑠, 𝑎, 𝛽) = 𝑒𝛽R(𝑠,𝑎)+𝜇

Z(𝑠 + 𝑎, 𝑎′, 𝛽) .

(19)

This Bellman equation can be easily derived by decomposing each trajectory 𝜔 ∈ Ω(𝑠, 𝑎) into two parts:
the ﬁrst transition resulting from taking initial action 𝑎 and the remainder of the trajectory 𝜔′ which is a
member of Ω(𝑠 + 𝑎, 𝑎′) for some action 𝑎′ ∈ A . The total energy and length can also be decomposed in the
same way, so that:

𝑎′
Õ

Z(𝑠, 𝑎, 𝛽) =

𝑒−𝛽𝐸 ( 𝜔)+𝜇 | 𝜔 | =

𝑒𝛽

| 𝜔|
𝑖=0 𝑟𝑖 +𝜇 | 𝜔 |

Õ𝜔 ∈Ω(𝑠,𝑎)
= 𝑒𝛽 R(𝑠,𝑎)+𝜇

= 𝑒𝛽 R(𝑠,𝑎)+𝜇

𝑒𝛽

Í

Õ𝜔 ∈Ω(𝑠,𝑎)

Í

Õ𝜔 ∈Ω(𝑠,𝑎)
𝑡=1 𝑟𝑡 ( 𝜔)+𝜇 ( | 𝜔 |−1) = 𝑒𝛽 R(𝑠,𝑎)+𝜇

| 𝜔|

𝑒−𝛽 𝐸 ( 𝜔′)+𝜇 | 𝜔′ |

𝑒−𝛽 𝐸 ( 𝜔′)+𝜇 | 𝜔′ | = 𝑒𝛽 R(𝑠,𝑎)+𝜇

Z(𝑠 + 𝑎, 𝑎′, 𝛽).

Õ𝜔′ ∈Ω(𝑠+𝑎)

Õ𝑎′ ∈A

Õ𝜔′ ∈Ω(𝑠+𝑎,𝑎′)

7

Õ𝑎′ ∈A

In the same spirit of Section 2.3, one can show that
𝑄(𝑠, 𝑎, 𝛽) = 𝜕

𝜕𝛽 log Z(𝑠, 𝑎, 𝛽) satisﬁes a Bellman equation:

the average underlying value function

𝑄(𝑠, 𝑎, 𝛽) = R(𝑠, 𝑎) +

𝜋(𝑎′ | 𝑠 + 𝑎) 𝑄(𝑠 + 𝑎, 𝑎′, 𝛽)

𝜋(𝑎 | 𝑠) =

Õ𝑎′

Z(𝑠, 𝑎, 𝛽)
𝑎′ Z(𝑠, 𝑎′, 𝛽)

(20)

𝑄(𝑠, 𝑎, 𝛽) can be then reinterpreted as the 𝑄-function of the policy 𝜋. Similarily to the results of Section 2.3
and Appendix A.2, the policy 𝜋 can be thought of a Boltzmann policy of parameter 𝛽 that takes entropy
into account. This construction can be extend to a stochastic environments by following the same approach
used in Section 3.2.

Í

In the following we show how learning the state-action partition function Z(𝑠, 𝑎, 𝛽) leads to an alternative

approach to model-free reinforcement learning that does not explicitly represent value functions.

4.2. A Learning Algorithm

In 𝑄-Learning, the update rule typically consists of a linear interpolation between the current value estimate
and the one arising a posteriori:

𝑄(𝑠𝑡 , 𝑎𝑡 ) ← (1 − 𝛼)𝑄(𝑠𝑡 , 𝑎𝑡 ) + 𝛼

𝑟𝑡 + 𝛾 max
𝑎𝑡+1

𝑄(𝑠𝑡+1, 𝑎𝑡+1)

(cid:18)

(cid:19)

(21)

where 𝛼 ∈ [0, 1] is the learning rate and 𝛾 is the discount factor. For Z-functions we will replace the linear
interpolation with a geometric one. We take the update rule for Z-functions to be the following:

Z(𝑠𝑡 , 𝑎𝑡 , 𝛽) ← Z(𝑠𝑡 , 𝑎𝑡 , 𝛽)1−𝛼 ×

𝑒𝛽𝑟𝑡 +𝜇

Z(𝑠𝑡+1, 𝑎𝑡+1, 𝛽)

𝑎𝑡+1
Õ

𝛼

.

!

(22)

To understand what this update rule is doing, it is insightful to look at how how the underlying 𝑄-function,
𝑄(𝑠, 𝑎) = 𝜕

𝜕𝛽 log Z(𝑠𝑡 , 𝑎𝑡 , 𝛽) is updated. We ﬁnd:

𝑄(𝑠𝑡 , 𝑎𝑡 , 𝛽) ← (1 − 𝛼)𝑄(𝑠𝑡 , 𝑎𝑡 , 𝛽) + 𝛼

𝑟𝑡 +

Z(𝑠𝑡+1, 𝑎𝑡+1, 𝛽)
𝑎′ Z(𝑠𝑡+1, 𝑎′, 𝛽)

𝑄(𝑠𝑡+1, 𝑎𝑡+1, 𝛽)

.

!

𝑎𝑡+1
Õ

(23)

We see that we recover a weighted version of the SARSA update rule. This update rule is referred to as
expected SARSA. Expected SARSA is known to reduce the variance in the updates by exploiting knowledge
about stochasticity in the behavior policy and hence is considered an improvement over vanilla SARSA
(Van Seijen et al., 2009).

Í

Since the underlying update rule is equivalent to the expected SARSA update rule, we can use any
exploration strategy that works for expected SARSA. One exploration strategy could be 𝜖-greedy which
consists in taking action 𝑎 = argmax𝑎 ∈AZ(𝑠, 𝑎, 𝛽) with probability 1 − 𝜖 and picking an action uniformly
at random with probability 𝜖. Another possibility would be a Boltzmann-like exploration which consists in
taking action 𝑎 with probability P(𝑎 | 𝑠) ∝ Z(𝑠, 𝑎, 𝛽).

We would like to emphasize that even though the expected SARSA update is not novel, the learned
policies through this updates rule are proper to the partition-function approach. In particular, the learned
policies 𝜋(𝑎 | 𝑠) ∝ Z(𝑠, 𝑎, 𝛽) are Boltzmann-like policies with some entropic preference properties as described
in Section 2.3 and Appendix A.2.

5. Conclusion

In this article we discussed how planning and reinforcement learning problems can be approached through
the tools and abstractions of statistical physics. We started by constructing partition functions for each
8

 
 
state of a deterministic MDP and then showed how to extend that deﬁnition to the more general stochastic
MDP setting through a variational approach. Interestingly, these partition functions have their own Bellman
equation making it possible to solve planning and model-free RL problems without explicit reference to
value functions. Nevertheless, conventional value functions can be derived from our partition function and
interpreted via average energies. Computing the implied value functions can also shed some light on the
policies arising from these algorithms. We found that the learned policies are closely related to Boltzmann
policies with the additional interesting feature that they take entropy into consideration by favoring states
from which many trajectories are possible. Finally, we observed that working with partition functions is
more natural in some settings. In a deterministic environment for example, near-optimal Bellman equations
become linear which is not the case in a value-function-centric approach.

6. Acknowledgments

We would like to thank Alex Beatson, Weinan E, Karthik Narasimhan and Geoﬀrey Roeder for helpful
discussions and feedback. This work was funded by a Princeton SEAS Innovation Grant and the Alfred P.
Sloan Foundation.

References

D Ackley, G Hinton, and T Sejnowski. A learning algorithm for Boltzmann machines. Cognitive Science, 9

(1):147–169, 1985.

Karl J Astrom. Optimal control of Markov processes with incomplete state information. Journal of

Mathematical Analysis and Applications, 10(1):174–205, 1965.

Hagai Attias. Planning by probabilistic inference. In International Conference on Artiﬁcial Intelligence and

Statistics, 2003.

Richard Bellman. Dynamic programming. Science, 153(3731):34–37, 1966.
Dimitri P Bertsekas. Dynamic programming and optimal control, volume 1. Athena scientiﬁc Belmont, MA,

1995.

Michael Betancourt.

A conceptual

introduction to Hamiltonian Monte Carlo.

arXiv preprint

arXiv:1701.02434, 2017.

Giuseppe Carleo, Ignacio Cirac, Kyle Cranmer, Laurent Daudet, Maria Schuld, Naftali Tishby, Leslie

Vogt-Maranto, and Lenka Zdeborov´a. Machine learning and the physical sciences, 2019.

Ofer Dekel and Elad Hazan. Better rates for any adversarial deterministic MDP. In International Conference

on Machine Learning, pages 675–683, 2013.

Simon Duane, Anthony D Kennedy, Brian J Pendleton, and Duncan Roweth. Hybrid Monte Carlo. Physics

Letters B, 195(2):216–222, 1987.

John J Hopﬁeld. Neural networks and physical systems with emergent collective computational abilities.

Proceedings of the National Academy of Sciences, 79(8):2554–2558, 1982.

Leslie Pack Kaelbling, Michael L Littman, and Anthony R Cassandra. Planning and acting in partially

observable stochastic domains. Artiﬁcial intelligence, 101(1-2):99–134, 1998.

Rudolph Emil Kalman. A new approach to linear ﬁltering and prediction problems. Journal of Basic

Engineering, 82(1):35–45, 1960.

Hilbert J Kappen. Optimal control theory and the linear Bellman equation. In D Barber, A T Cemgil, and

S Chiappa, editors, Bayesian Time Series Models. Cambridge University Press, 2011.

Daphne Koller and Nir Friedman. Probabilistic graphical models: principles and techniques. MIT press, 2009.
Sergey Levine. Reinforcement learning and control as probabilistic inference: Tutorial and review, 2018.
David JC MacKay. Information theory, inference and learning algorithms. Cambridge university press, 2003.
In Proceedings of
Omid Madani.
the Eighteenth conference on Uncertainty in Artiﬁcial Intelligence, pages 311–318. Morgan Kaufmann
Publishers Inc., 2002.

Polynomial value iteration algorithms for deterministic MDPs.

Marc Mezard and Andrea Montanari. Information, physics, and computation. Oxford University Press, 2009.

9

Iain Murray and Zoubin Ghahramani. Bayesian learning in undirected graphical models: approximate MCMC
algorithms. In Proceedings of the 20th Conference on Uncertainty in Artiﬁcial Intelligence, pages 392–399.
AUAI Press, 2004.

Radford M Neal et al. MCMC using Hamiltonian dynamics. Handbook of Markov Chain Monte Carlo, 2

(11):2, 2011.

Edward J Sondik. The optimal control of partially observable Markov processes over the inﬁnite horizon:

Discounted costs. Operations Research, 26(2):282–304, 1978.

Edwin Stoudenmire and David J Schwab. Supervised learning with tensor networks. In Advances in Neural

Information Processing Systems, pages 4799–4807, 2016.

Emanuel Todorov. Linearly-solvable Markov decision problems.

In Advances in Neural Information

Processing Systems, pages 1369–1376, 2007.

Harm Van Seijen, Hado Van Hasselt, Shimon Whiteson, and Marco Wiering. A theoretical and empirical
In 2009 IEEE Symposium on Adaptive Dynamic Programming and

analysis of expected SARSA.
Reinforcement Learning, pages 177–184. IEEE, 2009.

Zheng Wen and Benjamin Van Roy. Eﬃcient exploration and value function generalization in deterministic

systems. In Advances in Neural Information Processing Systems, pages 3021–3029, 2013.

Jonathan S Yedidia, William T Freeman, and Yair Weiss. Generalized belief propagation. In Advances in

Neural Information Processing Systems, pages 689–695, 2001.

Lenka Zdeborov´a and Florent Krzakala. Statistical physics of inference: Thresholds and algorithms. Advances

in Physics, 65(5):453–552, 2016.

Brian D Ziebart. Modeling Purposeful Adaptive Behavior with the Principle of Maximum Causal Entropy.

PhD thesis, University of Washington, 2010.

10

Appendix A: Deterministic MDPs

A.1. Z(𝒔, 𝜷) is well deﬁned

Proposition 1. Z(𝑠, 𝛽) =
Proof. The MDP being ﬁnite, S has a ﬁnite number of ﬁnal state we can then ﬁnd a constant 𝐾 such that,
for all ﬁnal states 𝑠 𝑓 we have R(𝑠 𝑓 ) ≤ 𝐾.

𝑖=0 𝑟𝑖 +𝜇 | 𝜔 | is well deﬁned for 𝜇 < − log 𝑑.

𝜔 ∈Ω(𝑠) 𝑒𝛽

Í

Í

| 𝜔|

Z(𝑠, 𝛽) =

Õ𝜔 ∈Ω(𝑠)

=

Õ𝜔 ∈Ω(𝑠)

≤ 𝑒𝛽𝐾

| 𝜔|
𝑖=0 𝑟𝑖 +𝜇 | 𝜔 |

| 𝜔|−1
𝑖=0

𝑟𝑖 +𝛽R(𝑠| 𝜔| )+𝜇 | 𝜔 |

𝑒𝛽

𝑒𝛽

Í

Í

Õ𝜔 ∈Ω(𝑠)

| 𝜔|−1
𝑖=0

𝑟𝑖 +𝜇 | 𝜔 |

𝑒𝛽

Í

𝑒 𝜇 | 𝜔 |

Õ𝜔 ∈Ω(𝑠)
𝑒 𝜇𝑛

1

Õ𝜔 ∈Ω(𝑠), | 𝜔 |=𝑛

𝑒 𝜇𝑛𝑑𝑛

(𝑒 𝜇+log 𝑑)𝑛

Õ𝑛∈N

Õ𝑛∈N

Õ𝑛∈N

≤ 𝑒𝛽𝐾

≤ 𝑒𝛽𝐾

≤ 𝑒𝛽𝐾

= 𝑒𝛽𝐾

Where used the fact that all rewards {𝑟𝑖 }𝑖 ∈{0,..., | 𝜔 |−1} are non positive and that the number of available
𝑛∈N (𝑒 𝜇+log 𝑑)𝑛 becomes convergent and
actions at each state is bounded by 𝑑. When 𝜇 < − log 𝑑, the sum
(cid:3)
Z(𝑠, 𝛽) is well deﬁned.
Remark 1. 𝜇 < − log 𝑑 is a suﬃcient condition, but not a necessary one. Z(𝑠, 𝛽) could be well deﬁned for
all values of 𝜇. This happens for instance when Ω(𝑠) is ﬁnite for all 𝑠.

Í

A.2. The underlying policy is Boltzmann-like

𝑖=0 𝑟𝑖 +𝜇 | 𝜔 | will become dominated by the contribution of few of its
For high values of 𝛽, the sum
terms. As 𝛽 → +∞, the sum will be dominated by the contribution of the paths with the biggest reward. We
have

𝜔 ∈Ω(𝑠) 𝑒𝛽

Í

Í

| 𝜔|

log Z(𝑠, 𝛽) ∼
𝛽→∞

We see that 𝑉 (𝑠, 𝛽) = 𝜕

𝜕𝛽 log Z(𝑠, 𝛽) →

𝛽→∞

max

𝛽 max

| 𝜔 |

𝑟𝑖 (𝜔), 𝜔 ∈ Ω(𝑠)

(

Õ𝑖=0
| 𝜔 |
𝑖=0 𝑟𝑖 (𝜔), 𝜔 ∈ Ω(𝑠)

)

.

o

| 𝜔 |

Since the MDP is ﬁnite and deterministic, it has a ﬁnite number of transitions and rewards. Consequently,
takes discrete values, in particular, there is a ﬁnite gap Δ between the maximum
the set
value and the second biggest value of this set. Let’s denote by Ωmax(𝑠) the set of trajectories that achieve
this maximum and by 𝑁max(𝑠) =

𝑖=0 𝑟𝑖 (𝜔), 𝜔 ∈ Ω(𝑠)

𝑒 𝜇 | 𝜔 | .

nÍ

o

nÍ

𝑁max(𝑠) counts the number of trajectories Ωmax(𝑠) in a weighted way: longer trajectories contribute less
than shorter ones. It is a measure of the size of Ωmax(𝑠) that takes into account our preference for shorter
trajectories. Putting everything together we get:

𝜔 ∈Ωmax (𝑠)
Í

Z(𝑠, 𝛽)
𝑒𝛽𝑉 (𝑠,𝛽)

(cid:18)

− 𝑁max(𝑠)

𝑒−𝛽Δ

≤
𝛽→∞

(cid:19)

11

Õ𝜔 ∈Ω(𝑠)

𝑒 𝜇 | 𝜔 | →
𝛽→∞

0

This shows that Z(𝑠, 𝛽) ∼
𝛽→∞

𝑁max(𝑠) 𝑒𝛽𝑉 (𝑠,𝛽) , which results in the following policy for 𝛽 >> 1:

𝜋(𝑎 | 𝑠) ∝

𝛽→∞

𝑁max(𝑠 + 𝑎)𝑒𝛽 (R(𝑠,𝑎)+𝑉 (𝑠+𝑎,𝛽))

𝜋 diﬀers from a traditional Boltzmann policy in the following way: if we have two actions 𝑎1 and 𝑎2 such
that R(𝑠, 𝑎1) + 𝑉 (𝑠 + 𝑎1, 𝛽) = R(𝑠, 𝑎2) + 𝑉 (𝑠 + 𝑎2, 𝛽) but there are twice more optimal trajectories spanning
from 𝑠 + 𝑎1 than there are from 𝑠 + 𝑎2 then action 𝑎1 will be chosen twice as often as 𝑎2. This is to contrast
with the usual Boltzmann policy that will pick 𝑎1 and 𝑎2 with equal probability. When 𝑁max(𝑠) is the same
for all 𝑠, we recover a Boltzmann policy. When 𝛽 → +∞ the policy converges to a an optimal policy and 𝑉
converges to the optimal value function.

A.3. 𝑿 → 𝑪(𝜷) 𝑿 is a contraction

Proposition 2. Let
𝐶 ( 𝛽)𝑠,𝑠′ = 1𝑠→𝑠′𝑒𝛽R(𝑠→𝑠′)+𝜇 + 1𝑠=𝑠′=ﬁnal state. The map deﬁned by

n

X( 𝛽) =

𝑍 ∈ R|S |
+

such for all ﬁnal states 𝑠 𝑓 we have 𝑍𝑠 𝑓

= 𝑒𝛽R(𝑠 𝑓 )

and let

o

X( 𝛽) → X( 𝛽)
𝑋

→ 𝐶 ( 𝛽) 𝑋

𝜓 :

(

is a contraction for the sup-norm:

||𝑥||∞ = max

𝑖 ∈{1, ··· , |S | }

|𝑥𝑖 |.

Proof. X( 𝛽) is the set of all possible partition functions with compatible boundary conditions. The
matrix 𝐶 ( 𝛽) is more explicitly deﬁned by:





𝐶 ( 𝛽)𝑠,𝑠′ =

1
0
𝑒𝛽R(𝑠→𝑠′)+𝜇

if s = s’ and state s is a ﬁnal state.
if there is no one step transition from state s to state s’.
if the transition from state s to state s’ generates reward R(𝑠 → 𝑠′).

Because 𝐶 ( 𝛽)𝑠,𝑠 = 1 when 𝑠 is a ﬁnal state, the map 𝜓 is well deﬁned (i.e. X( 𝛽) → X( 𝛽)). Since the MDP is
ﬁnite, it has a ﬁnite number of ﬁnal state so there exists a constant 𝐾 such that, for all ﬁnal states 𝑠 𝑓 we
have R(𝑠 𝑓 ) ≤ 𝐾.

Let 𝑋1, 𝑋2 ∈ X( 𝛽) we have:

k𝜓( 𝑋1) − 𝜓( 𝑋2) k∞

= max

𝑖 ∈{1, ··· , |S | }

(𝐶 ( 𝛽) 𝑋1 − 𝐶 ( 𝛽) 𝑋2)𝑖

Without loss of generality we can assume that the MDP has 𝑚 ﬁnal states that are labeled |S| − 𝑚 + 1, · · · , |S|.
Under this assumption we have:

(cid:12)
(cid:12)

(cid:12)
(cid:12)

max
𝑖 ∈{1, ··· , |S | }

|( 𝑋1 − 𝑋2)𝑖 | =

max
𝑖 ∈{1, ··· , |S |−𝑚}

|( 𝑋1 − 𝑋2)𝑖 |

This is because 𝑋1 and 𝑋2 have the same boundary conditions: ∀ 𝑠 𝑓 ∈ {|S| − 𝑚 + 1, · · · , |S|}, ( 𝑋1)𝑠 𝑓
Since 𝐶 ( 𝛽)𝑠 𝑓 ,𝑠 𝑓
conditions, we have: ∀𝑠 𝑓 ∈ {|S| − 𝑚 + 1, · · · , |S|}, [𝐶 ( 𝛽) 𝑋1] 𝑠 𝑓

= ( 𝑋2)𝑠 𝑓 .
is the index a ﬁnal state, 𝐶 ( 𝛽) 𝑋1 and 𝐶 ( 𝛽) 𝑋2 still have the same boundary

= [𝐶 ( 𝛽) 𝑋2] 𝑠 𝑓 . This gives us:

= 1 if 𝑠 𝑓

max
𝑠 ∈{1, ··· , |S | }

(𝐶 ( 𝛽) 𝑋1 − 𝐶 ( 𝛽) 𝑋2)𝑠

=

max
𝑠 ∈{1, ··· , |S |−𝑚}

(𝐶 ( 𝛽) 𝑋1 − 𝐶 ( 𝛽) 𝑋2)𝑠

For 𝑠 ∈ {1, · · · , |S|}, we have:

(cid:12)
(cid:12)
(𝐶 ( 𝛽) 𝑋1 − 𝐶 ( 𝛽) 𝑋2)𝑠

(cid:12)
(cid:12)
=

(cid:12)
(cid:12)
|S |
𝑠′=1 [𝐶 ( 𝛽)] 𝑠,𝑠′ ( 𝑋1 − 𝑋2)𝑠′

.

(cid:12)
(cid:12)

(cid:12)
Í
(cid:12)
Since there are at most 𝑑 available actions at each state and the environment is deterministic, at
(cid:12)
12

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

most 𝑑 coeﬃcients 𝐶 ( 𝛽)𝑠,𝑠′ in this sum are non zero. Because the rewards are non positive, the non zero
ones can be bounded by 𝑒 𝜇.

Putting all these pieces together we can write:
get:

|S |
𝑠′=1 [𝐶 ( 𝛽)] 𝑠,𝑠′ ( 𝑋1 − 𝑋2)𝑠′

≤ 𝑑 × 𝑒 𝜇 k 𝑋1 − 𝑋2k∞. Finally we

(cid:12)
Í
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

k𝐶 ( 𝛽) 𝑋1 − 𝐶 ( 𝛽) 𝑋2k∞ ≤

𝑑 × 𝑒 𝜇

k 𝑋1 − 𝑋2k∞

This proves that 𝜓 is a contraction.

<1 because 𝜇<− log 𝑑

|

{z

}

(cid:3)

Remark 2. We see here another mathematical similarity between the discount factor 𝛾 < 1 usually used in
RL and the chemical potential 𝜇 < − log 𝑑. They both ensure that the Bellman operators are contractions.

Appendix B: Stochastic MDPs

B.1. Averaging the Bellman Equation and adding a likelihood cost are equivalent

Proposition 3. The partition function Z(𝑠, 𝛽) deﬁned by Z(𝑠, 𝛽) :=
the following Bellman equation:

Z(𝑠, 𝛽) =

E𝑠′ |𝑠,𝑎

Í
𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

𝜔 ∈Ω(𝑠) 𝑒−𝛽𝐸 ( 𝜔)+𝜇 | 𝜔 |+𝐿 ( 𝜔)

satisﬁes

h
Proof. The proof follows the same path as the one in Section 2.2. We decompose each trajectory 𝜔 ∈ Ω into
two parts: the ﬁrst transition resulting from taking a ﬁrst action 𝑎 and the rest of the trajectory 𝜔′. The
energy, the length and the likelihood of the trajectory can be decomposed in a similar way as the sum of the
contribution of the ﬁrst transition and the contribution of the rest of the trajectory. We get:

i

𝑎
Õ

Z(𝑠, 𝛽) =

𝑒−𝛽𝐸 ( 𝜔)+𝜇 | 𝜔 |+𝐿 ( 𝜔)

=

=

=

=

Õ𝜔 ∈Ω(𝑠)

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇+log(P(𝑠′ |𝑠,𝑎)

𝑒−𝛽𝐸 ( 𝜔′)+𝜇 | 𝜔′ |+𝐿 ( 𝜔′)

𝑎,𝑠′
Õ

Õ𝑎,𝑠′

𝑎,𝑠′
Õ

𝑎
Õ

Õ𝜔′ ∈Ω(𝑠′)
𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇+log(P(𝑠′ |𝑠,𝑎) Z(𝑠′, 𝛽)

P(𝑠′ | 𝑠, 𝑎) 𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

E𝑠′ |𝑠,𝑎

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

h

i

This proves the equivalence.

B.2. Deriving the Unrealistic Bellman Equation

Proposition 4. The value function 𝑉 (𝑠, 𝛽) = 𝜕

𝜕𝛽 log Z(𝑠, 𝛽) where

satisﬁes the following Bellman equation:

Z(𝑠, 𝛽) =

𝑒−𝛽𝐸 ( 𝜔)+𝜇 | 𝜔 |+𝐿 ( 𝜔)

Õ𝜔 ∈Ω(𝑠)

𝑉 (𝑠, 𝛽) =

𝑎,𝑠′
Õ

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)
Z(𝑠, 𝛽)

13

P(𝑠′ | 𝑠, 𝑎) [R(𝑠, 𝑎, 𝑠′) + 𝑉 (𝑠′, 𝛽)]

(cid:3)

 
 
Proof. From Appendix
Z(𝑠, 𝛽) =

B.1
we
𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

𝑎 E𝑠′ |𝑠,𝑎

known

that

Z(𝑠, 𝛽)

satisﬁes

the

Bellman

equation:

.

(cid:3)

log Z(𝑠, 𝛽)

Í

(cid:2)

𝑉 (𝑠, 𝛽) = 𝜕
𝜕 𝛽
= 𝜕
𝜕 𝛽

log

E𝑠′ |𝑠,𝑎

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

!

i

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

!

𝑎
Õ
𝜕
𝜕 𝛽  

h
E𝑠′ |𝑠,𝑎

𝑎
Õ
E𝑠′ |𝑠,𝑎

E𝑠′ |𝑠,𝑎

(cid:20)

(cid:20)

=

=

=

=

=

=

=

1
Z(𝑠, 𝛽)

1
Z(𝑠, 𝛽)

1
Z(𝑠, 𝛽)

1
Z(𝑠, 𝛽)

1
Z(𝑠, 𝛽)

1
Z(𝑠, 𝛽)

Õ𝑎,𝑠′

𝑎
Õ

𝑎
Õ

𝑎
Õ

𝑎
Õ

𝑎
Õ

h

i
𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

𝜕
𝜕 𝛽
R(𝑠, 𝑎, 𝑠′) 𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽) + 𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 𝜕
𝜕 𝛽

(cid:17)(cid:21)

(cid:16)

Z(𝑠′, 𝛽)

(cid:21)

E𝑠′ |𝑠,𝑎

"  

R(𝑠, 𝑎, 𝑠′) +

E𝑠′ |𝑠,𝑎

R(𝑠, 𝑎, 𝑠′) +

𝜕
𝜕 𝛽

Z(𝑠′, 𝛽)
𝜕
𝜕𝛽
Z(𝑠′, 𝛽)

!

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

#

log Z(𝑠′, 𝛽)

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

(cid:20) (cid:18)
(R(𝑠, 𝑎, 𝑠′) + 𝑉 (𝑠′, 𝛽)) 𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)

(cid:19)

E𝑠′ |𝑠,𝑎

h

𝑒𝛽R(𝑠,𝑎,𝑠′)+𝜇 Z(𝑠′, 𝛽)
Z(𝑠, 𝛽)

P(𝑠′ | 𝑠, 𝑎) [R(𝑠, 𝑎, 𝑠′) + 𝑉 (𝑠′, 𝛽)]

(cid:21)

i

(cid:3)

B.3. The Bellman operator of Z(𝝆, 𝜷) is a contraction

Proposition
and X( 𝛽) =
The map deﬁned by

(cid:8)

5.

Let
𝑋 ∈ 𝐶0 (D, R) s.t. 𝑋 (𝜌 𝑓 ) = exp

𝛽

𝑀
𝑖=1 𝛼𝑖R( 𝑓𝑖)

D = {𝛼 ∈ R|S | such that ∀𝑖 ∈ 1, · · · , |S|, 0 ≤ 𝛼𝑖 ≤ 1 and

for mixtures of ﬁnal states 𝜌 𝑓 =
Í
Í

, |S |
𝑖=1 𝛼𝑖 = 1}
𝑀
.
𝑖=1 𝛼𝑖𝛿 𝑓𝑖

(cid:9)

(cid:2)
X( 𝛽) → X( 𝛽)

Í

(cid:3)

𝜓 :

𝑋

→

D → R
𝜌 →

(

𝑎 𝑒𝛽R(𝜌,𝑎)+𝜇 𝑋 (𝑃𝑎

𝑇 𝜌, 𝛽)





is a contraction for the sup-norm: k 𝑋 k∞ = max
𝜌∈D

| 𝑋 (𝜌)|.

Í

Proof. D is the standard (|S| − 1)-simplex in R|S | and X( 𝛽) be the set of continuous functions on D
satisfying the right boundary conditions. The original MDP is ﬁnite, consequently it has a ﬁnite number 𝑀
of ﬁnal state and it is possible to ﬁnd a constant 𝐾 such that, for all ﬁnal states 𝑠 𝑓 we have R(𝑠 𝑓 ) ≤ 𝐾.

Let 𝑋1, 𝑋2 ∈ X( 𝛽). 𝑋1 and 𝑋2 have the same boundary conditions by construction. Not only that,
𝜓( 𝑋1) and 𝜓( 𝑋2) have also the same boundary conditions since the map 𝜓 doesn’t alter boundary conditions.
Consequently we have:

k𝜓( 𝑋1) − 𝜓( 𝑋2) k∞

= max
𝜌∈D

|𝜓( 𝑋1) (𝜌) − 𝜓( 𝑋2) (𝜌)| =

max
𝜌∈D, 𝜌 non ﬁnal

|𝜓( 𝑋1) (𝜌) − 𝜓( 𝑋2) (𝜌)|

14

 
Finally we can write:

k𝜓( 𝑋1) − 𝜓( 𝑋2) k∞

=

=

≤

≤

max
𝜌∈D, 𝜌 non ﬁnal

|𝜓( 𝑋1) (𝜌) − 𝜓( 𝑋2) (𝜌)|

max
𝜌∈D, 𝜌 non ﬁnal

max
𝜌∈D, 𝜌 non ﬁnal

𝑑 × 𝑒 𝜇

𝑒𝛽R(𝜌,𝑎)+𝜇

𝑒𝛽R(𝜌,𝑎)+𝜇

(cid:12)
𝑎
(cid:12)
Õ
(cid:12)
(cid:12)
(cid:12)
(cid:12)
𝑎
(cid:12)
Õ
(cid:12)
k 𝑋1 − 𝑋2k∞
(cid:12)
(cid:12)

𝑋1(𝑃𝑎

𝑇 𝜌, 𝛽) − 𝑋2(𝑃𝑎

𝑇 𝜌, 𝛽)

(cid:2)
× k 𝑋1 − 𝑋2k∞

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:3)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

<1 because 𝜇<− log 𝑑

{z
Where we use the fact that all rewards are non positive and that the number of available actions is bounded
by 𝑑. This concludes the proof that the Bellman operator of Z(𝜌, 𝛽) is a contraction.

|

}

This proof is generalization of the proof presented in Appendix A.3 for MDPs with ﬁnite state spaces.

(cid:3)

15

 
 
