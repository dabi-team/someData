Functorial String Diagrams for Reverse-Mode Automatic Differentiation

MARIO ALVAREZ-PICALLO, Huawei Research Centre, United Kingdom
DAN R. GHICA, Huawei Research Centre, United Kingdom and University of Birmingham, United Kingdom
DAVID SPRUNGER, University of Birmingham, United Kingdom
FABIO ZANASI, University College London, United Kingdom

We enhance the calculus of string diagrams for monoidal categories with hierarchical features in order to capture closed monoidal

(and cartesian closed) structure. Using this new syntax we formulate an automatic differentiation algorithm for (applied) simply typed

lambda calculus in the style of [Pearlmutter and Siskind 2008] and we prove for the first time its soundness. To give an efficient yet

principled implementation of the AD algorithm we define a sound and complete representation of hierarchical string diagrams as a

class of hierarchical hypergraphs we call hypernets.

Additional Key Words and Phrases: string diagrams, automatic differentiation, graph rewriting, hierarchical hypergraphs

1 INTRODUCTION

This paper covers three main topics which support, motivate, and reinforce each other: reverse automatic differenti-
ation (AD), string diagrams, and (hyper)graph rewriting.

AD is an established technique for evaluating the derivative of a function specified by a computer program, a

particularly challenging exercise when the program contains higher-order sub-terms. This technique came to recent

prominence due to its important role in algorithms for machine learning [Baydin et al. 2017]. We focus in particular

on the influential algorithm defined in [Pearlmutter and Siskind 2008], which lies at the foundation of many practical
implementations of AD. The main novel contribution of our paper is to prove, for the first time, the soundness of this

particular style of AD algorithm.

String diagrams are a formal graphical syntax used in the representation of morphisms in monoidal categories [Selinger

2010] which is finding an increasing number of applications in a wide range of mathematical, physical, and engineering
domains. We contribute to the development of string diagrams by formulating a new hierarchical string diagram
calculus, with associated equations, suitable for the representation of closed monoidal (and cartesian closed) structures.

This innovation is, as we shall see in the paper, warranted: the hierarchical string diagrammatic syntax allows for a

more intelligible formulation of a complex algorithm and, most importantly, a new style of inductive argument which

leads to a relatively simple proof of soundness.

Finally, hierarchical hypergraphs are given as a concrete and efficient representation of hierarchical string diagrams,

which pave the way towards efficient and effective implementation of AD as graph rewriting in the well established
framework of double-pushout (DPO) rewriting [Ehrig and Kreowski 1976]. Moreover, we identify a class of hier-
archical hypergraphs, which we call hypernets, which are a sound and complete representation of the hierarchical

string diagram calculus. This is the third and final contribution of our paper.

Authors’ addresses: Mario Alvarez-Picallo, Programming Languages Laboratory, Huawei Research Centre, 2 Semple Str., Edinburgh, Scotland, EH3
8BL, United Kingdom, mario.alvarez.picallo@huawei.com; Dan R. Ghica, Programming Languages Laboratory, Huawei Research Centre, 2 Semple Str.,
Edinburgh, Scotland, EH3 8BL, United Kingdom, dan.ghica@gmail.com, Computer Science and University of Birmingham, Birmingham, England, B15
2TT, United Kingdom; David Sprunger, Computer Science, University of Birmingham, Birmingham, England, B15 2TT, United Kingdom, d.sprunger@
bham.ac.uk; Fabio Zanasi, Computer Science, University College London, London, England, WC1E 6BT, United Kingdom, f.zanasi@ucl.ac.uk.

1
2
0
2

l
u
J

8
2

]
L
P
.
s
c
[

1
v
3
3
4
3
1
.
7
0
1
2
:
v
i
X
r
a

 
 
 
 
 
 
2

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

2 HIGHER-ORDER STRING DIAGRAMS

String diagrams are a convenient alternative notation for constructing morphisms, in particular in (strict) monoidal

categories. In this paper we largely build on the syntax proposed in [Melliès 2006], with only a few cosmetic changes

aimed at making higher-order concepts more perspicuous. String diagrams in this work are to be read from top to

bottom.

2.1 Functorial string diagrams

We start with the basic language of categories, ranged over by
ranged over by 𝐴, 𝐵, . . . and two families of terminal symbols, identities id𝐴 : 𝐴

. . .. This language consists of a collection of objects
𝐴, represented as an 𝐴-labelled

D

C

,

→

vertical stem

, and morphisms 𝑓 : 𝐴

→

𝐵, represented by labelled boxes with an 𝐴-labelled top stem (which we

sometimes call input or operand) and a 𝐵-labelled bottom stem (which we call output or result)
(families of) terminal symbols in the diagram language with particular geometrical shapes instead of labelled boxes,

. We may distinguish

much in the way we have artificially disgtinguished identities from other morphisms.

Terms, ranged over by 𝑓 , 𝑔, . . ., are created using composition. Given 𝑓 : 𝐴

𝐶
as the stacking of the diagrams for 𝑓 and 𝑔. Since the output of 𝑓 must match the input of 𝑔 we connect the corresponding

𝐶 we write 𝑓 ; 𝑔 : 𝐴

𝐵, and 𝑔 : 𝐵

→

→

→

stems, to give a graph-like appearance to the string diagram

. We enforce two properties of composition familiar
= 𝑓 ; 𝑔; ℎ. This identification is
from category theory. First, composition is associative, meaning
subsumed by the diagrammatic notation. Second, we require the identity axiom 𝑓 ; id = id; 𝑓 = 𝑓 . Diagrammatically,
this means the lengths of the stems of a diagram can be lengthened or shortened without ambiguity.

; ℎ = 𝑓 ;

𝑔; ℎ
(

𝑓 ; 𝑔

)

)

(

We extend our string diagram language with labelled frames which indicate mappings
between morphisms of different categories. The application of a mapping 𝐹 to a morphism,
as a string diagram, is indicated by drawing an 𝐹 -labelled frame around the morphism and
modifying the stems of the diagram as appropriate, as seen in Fig. 1. Note that in this diagram

the stems and morphims inside the frame are a different color to the frame and the stems

outside the frame. This is an indication that objects and morphisms belong to potentially

distinct categories. When the map goes from a category to itself, we may use the same color

inside and out of the frame, but often leave the frame itself a different color to emphasize

the mapping.

Fig. 1. An example frame

Such morphism mapping 𝐹 constitutes a functor if it satisfies the following properties. First, there must be a mapping
for all
𝐵 in the source category. Second, this mapping must respect basic categorical structures, expressed in the
for the identity functor. Given two functors 𝐹, 𝐺 with matching

on objects, which we also denote 𝐹 by common abuse of notation, such that 𝐹𝑖
𝑓 : 𝐴
language of string diagrams in Fig. 2. We use 1
domains and codomains we write 𝐹𝐴 = 𝐹

and 𝐹𝐺𝐴 = 𝐹

in the sequel.

and 𝐹𝑜

= 𝐹

= 𝐹

→

𝐴

𝐴

𝐴

𝐵

C

)

(

(

)

)

(

(

)

𝑓

𝑓

(

)

𝐺
(

(

))

AfABfдACBfABFFo(f)Fi(f)Functorial string diagrams for RAD

3

(a) Uniform on inputs and outputs

(b) Respect identity

(c) Respect composition

Fig. 2. Properties of functors

The diagrammatic notation can be generalised to bifunctors in the obvious way, by drawing two side-by-side boxes
for the arguments. One bifunctor that plays a special role in string diagram is the tensor product or monoidal product, in
particular when it is strict. The tensor is represented diagrammatically as:

=

=

The diagram above contains three representations. In the first one we can see tensor as a bifunctor, with the

two separate boxes indicating the two arguments of the bifunctor. The second one is special notation for the tensor,

essentially hiding the functorial box and using a graphical convention (the horizontal line) to represent the ‘unravelling’

of the tensored-labelled stem into components. Finally, the third one is special notation for strict monoidal tensor, in
which the tensor 𝐴
isomorphisms and makes the tensor associative on the nose:

𝐶 is represented as the list of its components

. The strict diagram absorbs the associativity

𝐴, 𝐶

⊗

[

]

=

=

Henceforth we will work in the strict setting, but it will be sometimes convenient to de-strictify a diagram and group

individual stems in stems with tensor types. Coherence (and strictness) ensure that such de-strictifiations can be always

performed unambiguously.

In the strict setting we also have special notation for the unit 𝐼 of the tensor, which we represent as the empty list;

identity on 𝐼 is represented as empty space. It is immediate then, diagrammatically, that 𝑓

id𝐼 = id𝐼

𝑓 = 𝑓 .

We further extend the string diagram with the concept of natural transformation between functors with the same

domains and same codomains. Natural transformations are object-indexed families of morphisms written as 𝜃𝐴 : 𝐹𝐴
𝐺) which obey the following family of axioms, expressed in the language of string diagrams as:
𝐺𝐴 (or just 𝜃 : 𝐹

→

→

⊗

⊗

fABFFo(f)Fi(f)=fABFF(B)F(A)AFF(A)F(A)F(A)=fдfдACBFF(C)F(A)FF(B)F(A)=FF(C)CBBAfAB⊗B⊗DA⊗CдCDfдABDCA⊗CB⊗DfдABDCfдhfдhhдf4

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

=

One particularly interesting example of natural transformation is symmetry, written as 𝛾𝐴,𝐵 : 𝐴

𝐴, for
which we use the special geometric shape of two crossing wires. The fact that it is a natural transformation immediately

→

⊗

⊗

𝐵

𝐵

imples that

Symmetry is also an involution, i.e. 𝛾𝐴,𝐵; 𝛾𝐵,𝐴 = id𝐴
For functors 𝐹 :

id𝐵.

⊗

(called the counit),
𝐺𝐹 (called the unit) exist, they form an adjunction if and only if they satisfy the following family of axioms:

such that natural transformations 𝜖 : 𝐹𝐺

and 𝐺 :

D → C

C → D

→

1

C

𝜂 : 1

D →

For all

and

we have that

and

.

In this situation, we say 𝐹 is a left adjoint and 𝐺 is the right adjoint.

We adopt the convention of writing the counit of an adjunction as a downward pointing semicircle, the unit as an

upward pointing semicircle, and omitting the label when the map is clear from context. Note that [Melliès 2006] does

not discuss adjunctions specifically, although the streamling of the notations and calculations with adjunctions is a

prime benefit of the string diagram notation, and no additional technical content is required.

2.2 String diagrams for monoidal-closed and cartesian-closed categories

Monoidal closed categories and cartesian closed categories are categorical models for the linear and simply-typed
lambda calculus, respectively. A monoidal closed category arises if for every object 𝑋 in the category, the (endo)functor
𝐹𝑋

= 𝑋 ⊸ 𝐴. Diagrammatically, we depict these functors as:

𝑋 has a right adjoint 𝐺𝑋

= 𝐴

𝐴

𝐴

(

)

⊗

(

)

and

fABGGBGAθAFAfABFFBFAθBGB:=γfд=дfFGXXϵXηYGFYYFFGFA=FAFAFAGGAGFGA=GAGAfABFXFXBFXAfAB:=XfABGXGXBGXAfABX⊸X⊸BX⊸A:=Functorial string diagrams for RAD

5

Instantiated to the families of functors 𝐹𝑋 , 𝐺𝑋 above, the naturality and adjunction equations are expressed in string
diagrams as in Fig. 3. The counit of the adjunction is normally called eval, and we call the unit coeval for the sake of

symmetry in terminology and by analogy with compact-closed categories.

(a) Eval and coeval are natural transformations

(b) Eval and coeval form an adjunction

Fig. 3. String diagram representation of MCC axioms.

To further expand our diagrammatic language to cartesian closed categories, one easy way is to add natural

transformations 𝛿𝐴 : 𝐴
⊗
id𝐴 [Heunen and Vicary 2012]. We represent both of these natural transformations with a black dot, disambiguated by

𝐼 (weakening) such that 𝛿𝐴; 𝜔𝐴

𝐴 (contraction) and 𝜔𝐴 : 𝐴

id𝐴 = id𝐴 = 𝛿𝐴; 𝜔𝐴

→

→

𝐴

⊗

⊗

the quantity of results. The monoid equations are

. Copying and discarding are both consequences of

naturality, i.e.

and

, respectively.

Here we have presented adjunctions with unit and counit natural transformations. An equivalent description of

adjunctions involves a natural bijection between sets of morphisms. In the case of monoidal or cartesian closed categories,

this bijection is between
. This bijection is known as “currying”, and is a more germane
presentation for the lambda calculus. We define abstraction, the composition of the unit of the adjunction with the
functorial box for 𝐺, as syntactic sugar denoted by a plain box with rounded corners.

and

C(

C(

⊗

)

)

Γ

𝐴, 𝐵

Γ, 𝐴 ⊸ 𝐵

:=

BAX⊸X⊸AX⊸BtXBtX⊸AXB=BAX⊸X⊸(A⊗X)tAX⊸(B⊗X)=tAXX⊸(B⊗X)X⊸X⊸A=X⊸AXX⊸AX⊸A=AXAXAXX⊸(A⊗X)==fff=f=tBAΓA⊸ΓA⊸(Γ⊗A)A⊸BtΓΓA⊸BAB6

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

This structure for abstraction gives our notion of a hierarchical string diagram, which is to say a string diagram which

may contain other string diagrams in these boxes.

2.2.1

Foliations. Terms written as string diagrams can be presented in a particular form, which will turn out to lead to

some useful insights:

Definition 2.1 (Foliations). A foliation is a string diagram written as the sequential composition of a list of diagrams
called leafs. A singleton leaf is a diagram consisting of a non-identity atomic string diagram (symmetry, evaluation,
operation, contraction, or weakening) or an abstraction, tensored with any number of identities. A maximally sequential
foliation is a foliation comprising only singleton leafs. A maximally sequential hierarchical foliation is a maximally

sequential foliation which is either abstraction free, or in which all abstracted diagrams are also maximally sequential

hierarchical foliations.

For instance, if 𝑓 , 𝑔 are not identities then the maximally sequential foliations of 𝑓

𝑔
⊗

are

𝑓

(

𝑖𝑑

⊗

;

)

(

𝑖𝑑

𝑔
⊗

)

and

𝑖𝑑

(

𝑔

𝑓

;

)

(

⊗

𝑖𝑑

)

⊗

. The following is an obvious generalisation of a folklore theorem about monoidal categories.

Lemma 2.2. Any hierarchical string diagram can be written as a (non-unique) maximally sequential hierarchical

foliation.

The proof is straightforward. The graphical intuition which underlies the proof is that whenever two morphisms are

“level” in a diagram one of them can be “shifted” using identities, then tensors and compositions can be reorganised

using the functorialty of the tensor.

Foliations are convenient because syntactic transformations can be presented recursively on the foliation. This spares

us the need to define ‘big’ rules for sequential and tensorial composition. Instead only ‘small’ rules for composing

a term with a singleton leaf are required. This makes transformations easier to specify, and also makes for simpler

inductive proofs, using the foliation as a list.

2.3 Explicit substitution in string diagrams

In this section we illustrate the use of hierarchical string diagrams to represent the simply typed lambda calculus with

explicit substitutions. This is an interesting example in its own right, but more importantly it sets the scene for the next

section, where we define an automatic differentiation algorithm. The explicit substitutions play an essential role, as

they give us a handle on managing closures, which the AD algorithm requires.

Hierarchical string diagrams with rules for copying and discarding are a ready-made graphical syntax for the lambda

calculus with explicit substitutions [Abadi et al. 1991]. Syntactically, these calculi fall mainly in two categories, those

using deBruijn indices or those using named variables. The former have better formal properties and their formalisation

can be mechanised, but are not a very human-readable notation. The latter are easier to read but have some subtle

failures of alpha equivalence. Formalising alpha equivalence for calculi of explicit substitution is a somewhat tricky

problem, the solution of which leads back to rather intricate notations [Fernández and Gabbay 2007]. String diagrams

thus seem like an improved syntax for explicit substitutions, as they are both formal and, we contend, rather readable.

The graphical notation is variable-free therefore alpha equivalence is not an issue, and other equational properties are

also rendered obvious by the diagrammatic representation.

fдfдfдFunctorial string diagrams for RAD

7

(a)

Γ

(cid:74)

⊢

𝑡𝑢:𝐵

(cid:75)

(b)

Γ

(cid:74)

⊢

𝜆𝑥 .𝑡 :𝐴 ⊸ 𝐵

(cid:75)

Fig. 4. Interpretation of Λes-terms

(c)

Γ

(cid:74)

𝑡

𝑢
[

𝑥
/

]

:𝐵

⊢

(cid:75)

We pick for comparison a presentation of the calculus of explicit substitutions with named variables [Kesner 2007],
leaving aside alpha equivalence. A Λes-term is inductively defined as a variable 𝑥, an application 𝑡 𝑢, an abstraction
𝜆𝑥 .𝑡 or a substituted term 𝑡
both bind 𝑥
in 𝑡. The set of free variables of a term 𝑡, denoted 𝑡 is defined as usual.
𝑢
𝑥
/

, an explicit substitution, is not a term because of the way variable 𝑥 is bound. By

, where 𝑡 and 𝑢 are Λes-terms and 𝑥 a variable. The terms 𝜆𝑥 .𝑡 and 𝑡

Note that the syntactic object

contrast, in deBruijn formulations of the lambda calculus with explicit substitutions, substitutions are terms.

𝑢
/

𝑢
/

𝑥

𝑥

]

[

]

[

]

[

The following key equations and reduction rules are considered:

𝑢
/

]

𝑦 ∉ 𝑢

𝑥 ∉ 𝑣

∧

𝑥
] [
𝑢
/

]

𝑦
[
𝑡

𝑣
/
𝑥
[
𝑢

𝑡

𝑡

𝑥
[

𝑢
/

𝑣
𝑦
] [
/
𝜆𝑥 .𝑡

(
𝑥

𝑡

𝑥
[
𝑥
[

𝑥

𝑥

) [

) [

𝑡 𝑢

(
𝜆𝑦.𝑡

(

𝑡

𝑥
[

𝑢
/

𝑦
] [

= 𝑡

→

]
𝑢
)
𝑢
/
𝑢
/

] →

] →

] →

] →

] →

𝑣
/
𝑣
/
𝑣
/

𝑡

𝑥

𝑣
[
/
𝜆𝑦.𝑡

𝑢

𝑥

𝑣
/

]

[

]
𝑥
[
𝑢
/

𝑣
/
𝑦
[

]
𝑣
/

]]

𝑡

𝑥
[

(CE)

(BR)

(Var)

(Gc)

(App)

(Lamb)

(Comp)

𝑥 ∉ 𝑡

𝑥 ≠ 𝑦

We qualify these as ‘key’ because for more precise resource analysis the (Lamb) and (Comp) rewrites usually are given

‘linear’ forms depending on whether the substituted variable occurs in the term or not. For our purposes here we can

assume the linear versions are subsumed by the general version and the (Gc) axiom.

The string diagram interpretation of Λes is given in Fig. 4. The proof of soundness is a straightforward exercise.
Some of the axioms are simply instances of the identity (Var), associativity of composition (Comp), and naturality of

the contraction (App) or weakening (Gc) — we leave them as an exercise. The two non-trivial axioms and their proofs

are in Fig. 5.

Finally, the CE structural rule is also rather interesting, as it requires proving that

=

. The proof is an

immediate consequence of the functoriality of the tensor and of the identity law. What is interesting is that the two
diagrams look very similar as graphs. Indeed, the intuition that diagrams represented by isomorphic graphs denote

equal morphisms will be made rigorous in Sec. 4.

tBΓutBAΓA⊸ΓA⊸(Γ⊗A)A⊸ButBΓtuvtuv8

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

(a) Proving (BR) using functoriality of

− ⊗

=

=
𝐴, naturality of eval, and adjunction cancellation

=

=

(b) Proving (Lamb) using naturality of coeval and functoriality of 𝐴 ⊸

−

Fig. 5. Axioms of the Λes and their proofs.

To emphasise the syntactic nature of the transformation we will call the objects the types of the diagrams. Since we

are situated in a strict-monoidal setting we will write a composite tensor of objects as a list of types. We write a generic

typed term 𝑡 : 𝐴1 ⊗ · · · ⊗

𝐴𝑚 ⊸ 𝐴′1 ⊗ · · · ⊗

𝐴′𝑛 in the language of string diagrams as

(cid:18)

:

3 A GRAPHICAL AD ALGORITHM

[
[

𝐴1, . . . , 𝐴𝑚
, . . . , 𝐴′𝑛
𝐴′1

(cid:19)

.

]
]

This section represents the main technical result of our paper, to define and and prove the soundness of an algorithm for

performing reverse-mode automatic differentiation on hierarchical string diagrams. The algorithm can be considered a

simplified version of that presented in [Pearlmutter and Siskind 2008]. This algorithm is remarkable for being one of

the first such algorithms that can be applied to code containing closures and higher-order functions. It is particularly in

the treatment of higher-order features where we draw inspiration from their work.

The soundness property of the algorithm is technically interesting because simple inductive proofs of correctness do

not seem possible. If simply taking the gradient of a higher-order function, the algorithm is actually unsound. However,

when taking the gradient of a function with ground-type inputs and outputs only, the results are correct even if the

function contains higher-order terms.

Unlike the original algorithm, however, we do not provide automatic differentiation as a first-class entity. This means,
implicitly, that we also do not have a means to perform ‘higher order differentiation’ in the sense of differentiating the

differential operator itself. In the original work, this was achieved by extending the language with rich runtime reflection

tBAΓA⊸ΓA⊸(Γ⊗A)A⊸BuBBAΓΓututBΓtBAΓA⊸A⊸BCuΓCtBAΓA⊸A⊸BCuΓCA⊸AΓtBAΓA⊸A⊸BuCΓt······Functorial string diagrams for RAD

9

capabilities whose formalisation is entirely outside of the scope of our paper. Our algorithm instead is formulated as a

meta-level set of rules on hierarchical string diagrams or, in actual implementation, on their hypernet representation.

This is akin to the source-to-source transformation approach to automatic differentiation.

The setting for this algorithm is that of a (strict) cartesian closed category generated from one object 𝑜 ::=
R
representing the real numbers, and a collection of primitive operations (addition, multiplication, trigonometric functions,

,

etc.) and their gradients, along with a collection of nullary primitive operations for real constants. Among these, real

addition

and zero must be included. In the string diagrams throughout this section we represent constants as a

triangle instead of a box, just for improved readability. We write

and

for the obvious extension of

and

to

bundles.

Each of the provided primitive operations must also come equipped with a pullback diagram: for a primitive operation

of type

(cid:16) 𝐵
𝐵′

(cid:17)

, its pullback diagram

must have type

(cid:17)

(cid:16)𝐵 :: 𝐵′
𝐵

. We make no assumptions about the pullback

diagram of an operator, other than its type. However, the correctness result in this section will require pullback diagrams

to be ‘correct’ implementations of the gradient of the corresponding operation.

3.1 Rewrite rules on string diagrams

The AD algorithm consists of three separate sets of transformations, the application of which we denote by differently
coloured boxes around a diagram. We emphasise that these boxes represent meta-level transformations, and are not to

be confused with object-level entities such as the rounded rectangles that we use to denote abstraction.

To reduce clutter we use coloured boxes rather than labelled frames to indicate string-diagram transformations. The

first transformation, whose only rewrite rule can be found in Fig. 6, is denoted by a blue box and is the entry point of
the algorithm. Given an input diagram with operands of type 𝐵 and results of type 𝐵′, this transformation produces an
adjoint diagram with operands of type 𝐵 and results of type 𝐵 ::
, corresponding to the result of the original
diagram plus an abstraction, the backpropagator, that computes the gradient of the original diagram at the point at

𝐵′ ⊸ 𝐵

]

[

which the adjoint diagram is evaluated. In particular, if the original diagram produces a single result of type
evaluating the backpropagator at 1.0 we will obtain the gradient of the original diagram.

R

, when

This transformation consists, in turn, of two components: a forward
pass transformation (in orange), rewrite rules in Fig. 7a) and a reverse pass

transformation (in green), rewrite rules in Fig. 7b). As the naming suggests,

these correspond to the forward and reverse passes commonly employed

in reverse-mode AD. The forward pass executes the original function ‘as is’,

whereas the reverse pass computes the gradient of every sub-expression,

in reverse order of execution. In our algorithm, as is usually the case in

reverse-mode AD systems, some intermediate values computed during the

forward pass are preserved and passed along to the diagram corresponding
to the reverse pass. This is shown in Fig. 6 as a bundle of type 𝐵′′ flowing
from the forward-pass computation into the backpropagator.

The rewrites for the forward-pass transformation, depicted in Fig. 7a, are

self-explanatory, as they are limited to constructing a copy of the original

Fig. 6. Adjoint rule

diagram. Only two cases (those for evaluation and abstraction) merit some attention. For abstraction, the diagram

+0⊕0+0op······op⋆······f7→ffBBB⊸B′BB′BBBBB′B′B⊸B′B′B′B′′B′′10

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

(a) Rewrites defining the forward pass

(b) Rewrites defining the reverse pass

Fig. 7. Forward and reverse pass rewrites

enclosed by the bubble is recursively transformed using the blue rule — that is, any abstraction in the primal diagram is

replaced by a new abstraction that computes the adjoint of the original one. Then, when function evaluation in the

primal diagram is translated by the forward pass, the result of the adjoint application contains both the result of the

original abstraction and a backpropagator which is not used in the forward pass but is set aside for the reverse pass.

дr7→дrBRRRB′B′B′B′BBB7→BBBBд7→дBBB′B′B′B′AAAAAA7→ддBBBBB′B′B′B′AAдд7→ffBBB′B′B3B1B2B1⊸B2B3B1B1B3B3B3B2B1⊸B2B1B1⊸(B2::[B2⊸B1])B′B′BBB1⊸(B2::[B2⊸B1])7→ддBBBBB′B′B2B2B2B′B2⊸B1B1B′B1⊸B2B1⊸B2Whereβ=B1⊸(B2::[B2⊸B1])βB1opop7→ддBBBBB′B′B′B′B′′B′′B′′AAA7→дrBBRRB′B′RB′дBB′B7→BBBBд7→⊕дBB′B′B′′B′BB′B′′B′′B′′B′′B′′BB7→д0дBBB′B′B′BB′BB′′B′′B′′7→ддfBBB′B′B3B1B2B1⊸B2B3B3B′B3BB′B1⊸B2B7→ддBB′B′B2B2B1⊸B2B2⊸(B1::B3)B2B1B3B1B1⊸B2B′B′BBBд7→op⋆opдBBB′B′B′′AAB′AB′′B′′BB′BB′′Functorial string diagrams for RAD

11

Fig. 8. Pullback diagrams for some common operations

The rules governing the reverse pass transformation, in Fig. 7b, are more involved, so we provide here an intuitive

explanation for each. The first rule, which handles constants, states that constants do not contribute to the gradient of

the graph. The second rule computes the gradient of the identity function to be the identity. Contraction is transformed

into addition, since the gradient of the diagonal map

is the addition of tangent vectors, and weakened variables

⟩
become zero. Each primitive operation is replaced by its corresponding pullback diagram, which receives as additional

⟨

id, id

operands the copies of the inputs to the operation in the forward pass. This is why we require that every primitive

operation to be mapped to a pullback diagram of the appropriate type. Some examples of pullback diagrams for common

operations can be found in Fig. 8.

The reverse pass handling of application and abstraction are, both in the original algorithm and in our interpretation

of it, difficult to back up with compelling intuitions, but we shall try our best.

Remember that the forward pass transforms every abstraction in the primal diagram in order to compute the original

value together with a backpropagator. The latter is captured by the reverse pass in every application rule. When

rewriting an application node, the reverse pass instead applies the backpropagator given by the forward rule. This

backpropagator in turn produces a wire for every operand of the body of the original abstraction, which are swapped

into the correct order. The abstraction rule in the reverse pass then expects the sensitivity of an abstraction to consist

of a bundle of wires corresponding to the sensitivities of each captured wire.

As an example illustrating this algorithm and its handling of closures in particular, we provide in Fig. 9a a diagram

that might result from a program like let mul y = x * y in mul x + x, with the free variable x corresponding to its

single operand. On the right, in Fig. 9b, we show the result of applying the adjoint transformation to this diagram (see
Appendix ?? for an animated step-by-step derivation). It is a mere calculation to check that the resulting backpropagator,
when applied to input 1, can be evaluated to the correct derivative of the polynomial 𝑥 2

𝑥.

+

Lemma 3.1. The rewriting systems in Fig. 7a and Fig. 7b have the diamond property, up to a permutation of the output

wires.

Proof (Sketch). Every rule erases one node in the fringe of the left-hand side diagram, and that no two rules can be

applied to erase the same node. Therefore, if two rules can apply to the same diagram, it must be the case that they apply

to different fringe nodes. It is then easily checked that every pair of such rules commutes, modulo a permutation of the

wires that are propagated from the forward to the reverse pass. For a concrete example, consider the two sequences of

rewrites in Fig. 10.

□

Remark 1. The proof above, although very simple, illustrates a proof method that is made possible by using string
diagrams: induction on the length of the foliation of the diagram (Def. 2.1). The ‘fringe’ mentioned in the proof above is
simply the ‘bottom’ (in this case) leaf in the chosen foliation, noting that the foliation is not unique. This proof method

also benefits additionally from absence of names and all related bureaucratic concerns (free vs. bound, alpha equivalence,

capture-avoiding substitution).

+⋆=×⋆=××−⋆=−sin⋆=×cos12

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

(a) Primal diagram

↦→

↦→

↦→

↦→

↦→

↦→

(b) Adjoint diagram

↦→

Fig. 9. The AD transformation on a string diagram diagram computing 𝑥 2

𝑥

+

↦→

↦→

↦→

↦→

Fig. 10. Two possible rewrite sequences stemming from two distinct foliations

+××++××+××+×++++×+++×+++×××+++×××д+×д×+д××д×+д×+Functorial string diagrams for RAD

13

3.2 Reverse derivative categories

In order to prove that the algorithm we have given is correct, we need to select an appropriate semantic domain that

reflects the behaviour of the gradient operator from calculus. The obvious choice is the setting of reverse derivative

categories [Cockett et al. 2019]. In simple terms, these are cartesian categories equipped with a ‘reverse differential

combinator’ which behaves, in a suitable sense, like taking the gradient of a function in multivariate calculus. For a
more thorough treatment and explanation, we refer the reader to loc. cit.. They are defined as follows:

Definition 3.2. [Cockett et al. 2019, Def. 13] A reverse derivative category is a cartesian left-additive category endowed
𝑋 which satisfies the following

𝑌 to a morphism R

: 𝑋

𝑌

𝑓

with a combinator R sending each morphism 𝑓 : 𝑋
conditions:

→

[

]

×

→

] ◦ ⟨

[

id
]
𝑓 , 𝑔

[RD.1] R

[RD.2] R

[RD.3] R

𝑓

[
𝑢
[

+

[RD.4] R

[⟨
𝑔
[RD.5] R
[
[RD.6] 𝜋2 ◦
[RD.7] 𝜋2 ◦

◦
R

[

[
𝑓

𝑔

[

⟩]

= R
]
𝑓 , 𝑔
+
= 𝜋1, R
= R
= R
[
𝑓
R
[
𝜋2 ◦
R
R
[

]
R

[

[

𝑓

𝑓

𝑔
R
[
= R
=

] +

ℎ
⟩
𝜋1]
𝑓
] ◦ (

= 0
𝑢
R
[
𝜋2]
] ◦ (
id

0
]

and R
[
𝑓 , 𝑔

]
𝑢
] ◦ ⟨
[
𝜋2, 0
⟩
⟨
𝜋1) +
id
×
𝜋1, R
𝑔
] ◦ (
[
id, 0
id
0, id

⟩ ×

⟩ +
and R
[
𝑔
R
[
𝑓

×

) ◦ ⟨

id

)⟩

×

] ◦ ⟨

]] ◦ (⟨
R
R

𝑓

[

[

]] ◦ (⟨

id
⟩ ×
0, id

]]] ◦ (⟨
𝑓
R
R
[
[
𝜋2 ◦

[

R
R
[
[
= 𝜋2 ◦

] ◦ ⟨
=

id

𝑓 , ℎ
⟩
0, 𝜋2⟩
𝜋2)
×

⟨

and R

𝑢
[

𝑓 , 0

⟩

] ◦ ⟨

= 0

and R

!
]

[

= 0.

𝑓

[

id

𝜋2)

×

] ◦ (

𝜋1, 0

= R

𝜋2⟩
×
id, 0
id
⟩ ×
id, 0

)

)]] ◦ (⟨
id

⟩ ×

)]] ◦ (⟨

id

𝜋1 ×

) ◦ ⟨

𝜋1, 𝜋2 ×

𝜋2⟩

⟩ ×

One caveat of reverse derivative categories is that they do not naturally accommodate higher-order functions. Indeed,

there is no natural notion of a reverse derivative category with exponentials In contrast, cartesian differential categories
which can be extended to differential 𝜆-categories [Bucciarelli et al. 2010] — cartesian differential categories which are
cartesian closed and where the differential combinator is ‘well-behaved’ with respect to abstraction. This limitation

is of no concern to us, however: we do not claim that the AD algorithm in this paper produces correct gradients for

arbitrary higher-order diagrams, only for those whose inputs and outputs have first-order types – even if they do

contain higher-order sub-terms. The first-order setting of reverse derivative categories is sufficient.

Henceforth, we will assume that the strict cartesian category generated by the object

and the collection of primitive

R

operators and pullback diagrams defined above is a reverse derivative category. We will use the notation

to denote

the reverse derivative R(cid:2)
satisfies:

(cid:3) in diagrammatic form. In addition, we require that this reverse derivative category

The 0 of the left-additive structure coincides with

The

+

of the left-additive structure coincides with

For each primitive operation

, we have

=

•

•

•

Using this notation, all the equations in Definition 3.2 can be written diagramatically. The graphical translation of
conditions [RD.1] and [RD.3]-[RD.5], which will be relevant to us later, can be found in Fig. 11.

f······f······0+op······op⋆······op······14

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

Fig. 11. Reverse differential axioms as string diagrams

3.3 Correctness

Our proof of correctness proceeds in two steps. First, we prove that our AD transformation is compatible with Beta

reduction, that is to say, whenever two diagrams are equivalent modulo Beta reduction, then so are their adjoints.

Then, we show that the AD transformation is correct for diagrams featuring only first-order nodes (that is to say, no

abstractions or applications). For both of these steps, we will make use of the following technical result, which simply

states that the forward and reverse passes are compositional.

=

=

(a) AD and composition

↦→
(b) AD and Beta reduction

Fig. 12. AD is compatible with composition and reduction

Lemma 3.3. The forward and reverse pass rewriting rules in Fig. 7 satisfy the diagrammatic version of the chain rule,

that is to say, Eqn. 12a holds.

+=RRRRRRRRRR=rRRR=00B1B2AAB1B2AB1B2AAB1B2Afдfд⊕=B1BB2BB1B2BBBBBB1B2fдfдf=B1B3B3B1B1B1B1B1B3B2B2B2B2B3B2fдfдfдfдhfhfhhffFunctorial string diagrams for RAD

15

↦→

↦→

↦→

↦→

↦→

↦→
Fig. 13. Beta-soundness of AD

↦→

Proof. A trivial induction on the maximally sequential hierarchical foliation of 𝑓 .

□

Lemma 3.4. The rewriting rules in Fig. 7 are compatible with beta reduction (Eqn. 12b holds).

Proof. The proof proceeds by straightforward application of the rewrite rules. We provide the calculation in full in

Fig. 13 (an animated version of which can be be found in Appendix ??).

□

Lemma 3.5. For every diagram

whose operands and results are all of a first-order type, there is a Beta-equivalent

diagram

outputs.

that contains no instances of abstraction or evaluation and whose every node has all first-order inputs and

Proof. Since our graphical language is simply-typed, evaluation of the diagram

is guaranteed to terminate,
following an argument similar to the proofs of strong normalisation for the simply-typed 𝜆-calculus (such as the one in
[Girard et al. 1989, Chapter 6]), or for interaction nets (e.g. [Mackie 2000]). Such a normal form cannot contain any

redexes, and so any application or evaluation node must be connected to an operand or a result wire, which cannot be

the case as these have all first-order types.

□

hfhfhfhfhfhhfhhfhfhfhfhfhfhfhff······f′······f······16

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

Theorem 3.6. For every diagram

whose operands and results are all first-order, Eqn. 14a holds.

=

=

(a) Adjoint application

(b) Application after Beta reduction

Eqn. 14. First-order soundness for AD

Proof. Applying Lemma 3.5 and Lemma 3.4, it suffices to consider the case where

contains no instances of

application or evaluation. Applying the rewrite rule in Fig. 6 and calculating gives the diagram in Eqn. 14b. The result

then follows by induction on the foliation of the diagram

. We show one case in full.

=

=

=

=

=

=

=

=

=

□

4 HIERARCHICAL HYPERGRAPHS AND REWRITING

Even though string diagrams are convenient for mathematical reasoning, the actual implementation of string diagram

rewriting poses a challenge. In order to perform a rewrite step, we need to find a match in a string diagram, but the

presence of a redex may depend on which representation of the diagram we pick among ones that are equivalent

according to the laws of symmetric monoidal categories [Bonchi et al. 2016]. A solution is identifying a data structure

f······fB1B1B2B1B2fB1B2B1B1B2ffB1B2B1B3B1fB1B2B1B1B2f······f······fffffffff+f+ff+ffffffFunctorial string diagrams for RAD

17

interpreting string diagrams with the property that equivalent representations of a string diagram all have the same

interpretation. For standard string diagrams in symmetric monoidal categories, such a data structure is provided by
hypergraphs with interfaces, and the interpretation allows to model string diagram rewriting efficiently as double-
pushout rewriting of the corresponding hypergraphs [Bonchi et al. 2016]. In this section, we do something similar
for our hierarchical hypergraphs: we devise a suitable combinatorial structure, called hypernets, and show that two

hierarchical hypergraphs are interpreted as the same hypernet whenever they are equivalent modulo the laws of

symmetric monoidal categories (theorem 4.12). This allows us to conclude that string diagram rewriting for hierarchical

hypergraphs can be ‘implemented’ as double-pushout rewriting of hypernets (theorem 4.14).

Hierarchical hypergraphs have been used before many times, see e.g. [Bruni et al. 2010b; Drewes et al. 2002; Palacz

2004]. Our approach is broadly similar, but with enough subtle differences that it is necessary to give our own definitions.

For a more detailed comparison, see Sec. 5.2.

4.1 Hierarchical hypergraphs and hypernets

A hierarchical hypergraph is a labelled, directed hypergraph with a parent relationship which determines the hierarchical
structure. We fix sets of vertex and edge labels Σ𝑉 and Σ𝐸 . When comparing hierarchical hypergraphs to string diagrams,
Σ𝑉 should also be the set of base types in the string diagrams, while Σ𝐸 should be the added operations.

𝑉 , 𝐸, 𝑠, 𝑡, ℓ𝑉 , ℓ𝐸, 𝑝𝑉 , 𝑝𝐸
Definition 4.1. A hierarchical hypergraph is a tuple
(
finite set of edges 𝐸, source and target functions 𝑠, 𝑡 : 𝐸
and parent functions 𝑝𝑉 : 𝑉

1 and 𝑝𝐸 : 𝐸

→
1.

𝐸

𝐸

𝑉 ∗, labelling functions ℓ𝑉 : 𝑉

)

comprising a finite set of vertices 𝑉 , a
1,

Σ𝑉 and ℓ𝐸 : 𝐸

Σ𝐸

→

+

→

→

+

→

+

While the source, target, and labelling functions are standard for labelled, directed hypergraphs, we must add some

conditions to the the parent functions. First, we require an edge and any of its source and target vertices to have
the same parent: namely that 𝑝𝑉
for all 𝑣
𝑣 ′)
relation must be acyclic, so that repeatedly applying 𝑝𝐸 should eventually end up in the right summand of 𝐸
precisely, we assume for all 𝑒
𝐸
𝑝𝐸,

≥
1 is the extension of 𝑝𝐸 adding 𝑝𝐸,

respectively. Second, the parent

1 such that
=

is the element of 1 and

𝐸 there is some 𝑘

and 𝑣 ′ ∈

1. More

where

= 𝑝𝑉

= 𝑝𝐸

𝑝𝐸,

: 𝐸

⊥)

⊥

⊥

=

+

∈

∈

1

𝑒

𝑒

𝑒

𝑒

𝑣

𝑠

𝑘

)

(

)

(

)

(

(

(

)

)

(

(

𝑡

⊥ (⊥)

.
⊥

⊥

+

→

+

When the parent of a vertex or edge is the element

from the right summand, we say it is a outermost vertex or
, we say (with some abuse) that it is unlabelled. When considering multiple

⊥

outermost edge. If the label of an edge is

⊥

hierarchical hypergraphs, we use subscripts to disambiguate these data.

We borrow terms from graph theory for hierarchical hypergraphs. An important example is that we call a hierarchical
hypergraph connected when for every pair of outermost vertices, there is a sequence of edges (oriented either forward

or reverse) joining the two vertices.

𝑗

𝑣

F

𝑝𝑉

In every hierarchical hypergraph

, associated to every edge ˆ𝑒 is a
subgraph consisting of edges 𝑒 (and vertices 𝑣) satisfying 𝑝𝑘
= ˆ𝑒 (and
𝐸,
𝑝𝐸,
0). We denote this subgraph
(
Fˆ𝑒 and call it “the inner hypergraph of ˆ𝑒”. If a subgraph
G
for all 𝑒
hypergraph
has the property that
G
down-closed. When depicting a hierarchical hypergraph, we indicate the

= ˆ𝑒) for some 𝑘

of a hierarchical

1 (and 𝑗

, we call

⊆ G

𝑒
F

⊥ (

⊥)

))

F

≥

≥

∈

𝐸

G

𝑒

(

)

(

inner hypergraph of an edge by nesting the inner subgraph within its edge,

like abstraction in hierarchical string diagrams. An example can be seen

in Fig. 15.

Fig. 15. An example hierarchical hypergraph

fevABCAB⊸CB⊸C18

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

We give an example hierarchical hypergraph in Fig. 15. This hypergraph
has six vertices (the six black dots), which we name 𝑣1, . . . , 𝑣6 from top to
𝑣1)
bottom then left to right. These vertices are labelled as follows: ℓ𝑉
=
(
ℓ𝑉
= 𝐶. There
= ℓ𝑉
𝑣3)
(
are three edges: 𝑒1 with label 𝑓 , 𝑒2 with label 𝑒𝑣, and 𝑒3 unlabelled but with an inner hypergraph. The sources and
targets of these edges are mostly clear (and mostly one-element lists), except 𝑠
. As mentioned above, 𝑒3 is
the parent edge for most of the graph, so 𝑝𝐸
and for all other edges and vertices the parent
function returns 𝑒3.

= 𝐵 ⊸ 𝐶, and ℓ𝑉

𝑣4, 𝑣3]

= 𝐴, ℓ𝑉

= 𝐵, ℓ𝑉

𝑣6)

𝑣6)

𝑣5)

𝑣1)

𝑣4)

𝑣2)

𝑒2)

𝑒3)

= 𝑝𝑉

= 𝑝𝑉

⊥

=

=

(

(

(

(

[

(

(

(

(

Definition 4.2. In a hierarchical hypergraph

, a vertex is an input vertex if it never occurs as a target, an output
vertex if it never occurs as a source, an interface if it is either an input or an output vertex, and an isolated vertex if it is

G

both an input and an output vertex.

We think of vertices of hierarchical hypergraphs as representing objects in a category and edges representing

morphisms from the product of the source objects to the product of the target objects. However, hierarchical hypergraphs

are generally much more expressive than string diagrams: multiple edges can use the same vertex as a source or a

target, and there could be cycles in the graph. We will therefore be interested in a more restricted class of hypergraphs,

which we call hypernets.

Definition 4.3. A hypernet is a hierarchical hypergraph

all vertices occur as a source for at most one 𝑒 (and at most once in 𝑠
𝑒 (and at most once in 𝑡
and only if

𝑒
(
), (4) there are specified total orderings on the input and output vertices, and (5) ℓ𝐸

𝑒 is the empty hypergraph.

), (3) all vertices occur as a target for at most one

≠

𝑒

(

)

⊥

if

𝑒

(

)

)

with the following additional properties: (1) acyclicity, (2)

H

H

For now, we return our focus to hierarchical hypergraphs and situate them in a category.

Definition 4.4. A morphism of hierarchical hypergraphs 𝜙 :
𝐸
.

and 𝜙𝐸 : 𝐸

𝑉

𝜙𝑉 : 𝑉

F →

G

F →

G

F → G

is a pair of functions 𝜙 =

𝜙𝑉 , 𝜙𝐸

(

with

)

These functions are required to respect the structure of the hierarchical hypergraphs in the following senses:

(1) 𝜙 ∗𝑉 ◦
(2) 𝜙 ∗𝑉 ◦
(3) ℓ𝑉 ,

G

𝑠

F

= 𝑠
= 𝑡
𝑡
F
= 𝜙𝑉

G ◦

G ◦
ℓ𝑉 ,

◦

𝜙𝐸
𝜙𝐸

F

(4) ℓ𝐸,
G
𝜙𝐸
(5)
𝜙𝐸

(6)

(

(

= 𝜙𝐸
𝑝𝑉 ,
𝑝𝐸,

ℓ𝐸,
𝑣

◦

F)(
𝑒
F)(

)

◦

◦

F
=
)

=

𝑝𝑉 ,
(
𝑝𝐸,

(

G ◦

G ◦

𝜙𝑉
𝜙𝐸

𝑣

if 𝑝𝑉
)
if 𝑝𝐸

)(
𝑒

)(

)

𝑣

𝐸

(
𝑒

) ∈
𝐸

(

) ∈

Note that we do not require that outermost vertices and edges are sent to outermost vertices and edges, due to the

condition in (5) and (6). If conditions (5) and (6) hold for all 𝑣 and 𝑒, we say the morphism is strict.

Hierarchical hypergraphs and the morphisms between them form a category. This category clearly has finite

coproducts given by disjoint union. We investigate pushouts in this category in order to support double pushout
rewriting. When restricted to strict morphisms, all pushouts exist and can be computed as in Set. Unfortunately, the

category of hierarchical hypergraphs with strict morphisms is not expressive enough for the rewriting tasks we require.

When allowing all hierarchical hypergraph morphisms, the category does not have all pushouts or even pushouts

along monos. This is primarily due to ambiguities in the parents of outermost vertices and edges. Two non-strict

morphisms can embed a graph into two unmergeable parts of different graphs. However, there are enough pushouts in

this category to support the double pushout structure we need.

19

are

Functorial string diagrams for RAD

In essence, given an arbitrary span

−→ R
isomorphic together with a (monomorphic) matching

←− K

L

𝑙

𝑟

with the property that the outermost interfaces of

and

L

R

of the leftmost graph in the span in another hierarchical

𝑚

L

−−→ G

G− and

H

completing the following

hypergraph, the next few lemmas give conditions for a unique (up to isomorphism)

diagram, where all squares are pushouts:

L
𝑚
(cid:121)

𝜄

,

[

L ]

L
←−−−−−−

𝐼

+ L

(cid:121)

𝑛

𝜙

+L

Here 𝐼 is a copy of the outermost interface vertices of

G

←−−−−−− G− + L

𝐼

𝑙
+
←−−−−−−

𝐼

+ K

(cid:121)

𝑛

+K

𝐼

𝑟
+
−−−−−−→

𝐼

+ R

(cid:121)

𝑛

+R

𝐼

𝑙
+

←−−−−−− G− + K
(and

L

𝐼

𝑟
+
−−−−−−→ G− + R
(resp. 𝜄
) and 𝜄
R

L

R

𝜄

,

[

R

R ]
−−−−−−→ R
𝑝
(cid:121)

𝜓

−−−−−−→ H
) is the inclusion of these vertices in

the graph. That the inner two squares are the only pushout or pushout complement in this format is straightforward.
Lemma 4.8 gives the requirements on 𝑚 in the leftmost square to make it a pushout complement. These conditions
entail 𝑛 being a mono, which we will see in Lemma 4.7 is an important critera to get the existence of a pushout in the
rightmost square.

Example 4.5. We will illustrate the graph rewriting process with a running example. For now, we just give an example

of the input data we are expecting: a span and a matching. We start with a span corresponding to a particular instance

of the Abs rule and a matching of the left-hand side of this span in another hierarchical hypergraph.

To avoid clutter, we omit the vertex labels and do not give a full description of the morphisms other than to say they

𝑚

←−−

𝑙

←−

𝑟

−→

are the obvious map preserving edge labels. The goal of this section is to formally describe how the copy of

replaced with a copy of

.

R

Definition 4.6. Suppose 𝐼 is a hierarchical hypergraph consisting of only isolated vertices, and let 𝜙 : 𝐼

𝜓 : 𝐼

be morphisms. We say 𝜙 and 𝜓 have complimentary images if
→ G
(1) 𝑝𝑉
𝜙𝑉
(
(
𝜓𝑉
(2) 𝑝𝑉
𝑖
))
(
(
𝑖
(3) either 𝜙𝑉

for all 𝑖, 𝑗
𝑉𝐼 ,
𝑉𝐼 , and
for all 𝑖, 𝑗
never occurs as a source and 𝜓𝑉

= 𝑝𝑉
= 𝑝𝑉

𝜙𝑉
(
𝜓𝑉
(

))

))

))

∈

∈

(

(

𝑖

𝑖

𝑗

𝑗

(

)

never occurs as a target or vice versa.

(

)

in

is

G

L

and

→ F

+×∆evG+×L+×K+×R20

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

Though the following result does not completely characterize pushouts in this category, it gives enough pushouts

for us to construct the rightmost square in the diagram above.

Lemma 4.7. Suppose 𝐼 is a hypergraph of isolated vertices, 𝜙 : 𝐼

, and the images of the vertices under 𝜓 : 𝐼

connected hypergraph
id

𝜓

𝐼

F
𝜙,id
[
F ]
−−−−−−→ F

G + F

+
F
←−−−−−

has a pushout.
If further 𝜙 and 𝜓 are monos and they have complimentary images, then

+ F

→ F

→ G

is as well.

sends all vertices of 𝐼 to outermost vertices in the
have a single common parent. Then the span

and

G

F

being hypernets implies the pushout

Proof. The pushout can be formed by taking the disjoint union of

F
the respective maps. The parent of the outermost vertices and edges of
𝜓

(

𝑖
. The remaining properties of hierarchical hypergraphs are straightforward.
)
That 𝜙 and 𝜓 are monos with complimentary images ensures that when this identification occurs, equivalence classes
) and that the resulting equivalence class is

of vertices have at most two representatives (one from

and one from

and

, then identifying the images of 𝐼 under
is defined to be the common parent of the

G

used as an input or an output by at most one edge from either graph. This makes the quotient is a hypernet.

□

F

G

F

Next we establish the result constructing pushout complements in the leftmost square.

Lemma 4.8. Suppose 𝐼 is a hypergraph of isolated vertices, 𝜙 : 𝐼

is a bijection of vertices of 𝐼 with outermost
interface vertices in the connected graph
is a monomorphism with the following properties:
(1) the image of 𝑚 is down-closed, and (2) edges in outside the image of 𝑚 are incident only with vertices outside the image of
𝑚 or vertices in
G− such that
. Further, 𝑛 is a monomorphism.
is a pushout complement to

. Then there is a unique graph

. Further suppose 𝑚 :

+ F → G− + F

G− + F → G)

(G− + F

F → G

𝑚
(

→ F

, 𝜉 :

+ F

: 𝐼

, 𝑛

)(

F

𝜙

◦

)

𝐼

𝑚, 𝜙
(

)

Proof. Note that condition (2) is the dangling condition from double pushout rewriting, and that 𝑚 is a monomor-
. The

phism strengthens the identification condition. Hence, it is not surprising to define

∖

∖

𝜙

𝐼

G− :=

G

𝑚
(

(F )

𝑚
(

◦

)(

))

wrinkle introduced by hierarchical hypergraphs is the hierarchy: down-closedness (1) is required in order to remove
(most of) the image of 𝑚 from
image of 𝑚 in
after deletion.

, this condition ensures all of its children are also in the image, so we do not need to redefine its parent

without introducing ambiguity in the parent relationships. When an edge is in the

G

G

□

Example 4.9. With an understanding of how these pushouts and pushout complements are constructed, we now

complete example 4.5. The graphs formed in the pushout diagram are shown in Fig. 16.

The leftmost pushout (complement) square excises the matching of

from the graph in which it is embedded.
while the portion of the morphism from 𝐼 marks where the result should be

L

The next two squares replace

with
G−. Finally, the rightmost pushout glues

L

R

reinserted in

back into

G−.

R

Remark 2. This example illustrates one of the distinctive features of our approach to hierarchical hypergraph rewriting,
namely the ability to send outermost vertices (and edges) to inner vertices (and edges). This is crucial, because both legs of

the span require it. Equally crucial, but maybe less obvious, is that morphisms can sent outermost vertices (and edges) to

images with different parents, as seen in the right leg of the span. It is these novel properties that provide the required level
of expressiveness we need to formulate our string diagram equations as graph rewrites.

Functorial string diagrams for RAD

21

Fig. 16. Pushout rewriting example

4.2 Soundness and completeness

Now that we understand how hierarchical hypergraphs can be rewritten, we turn to the the connection between string
diagrams and hypernets. Suppose we fix a set of basic types Σ𝑉 and a set of operations Σ𝐸 from which the string
diagrams of section 2 are built. From these basic types, generate types according to the rules of ??. We restrict vertex

labels for our hypernets to these atomic types. Just as with string diagrams, there is a notion of well-typedness for

hypernets.

Definition 4.10. A well-typed hypernet

satisfies the following properties. (1) If ℓ𝐸

is an operation, then the types

𝑒

H
match the input types of this operation and similarly the types of 𝑡
)
=

of 𝑠
(
ℓ𝐸
𝑒
let 𝐿𝑜 be the list of types on the output interfaces of
𝑡

, let 𝐿𝑖 be the types of the list of input interfaces in

H

⊥

𝑒

)

(

=

𝐿𝑎 ⊸ 𝐿𝑜

𝑒

(

)

(

)

(

.

)

match the output types of ℓ𝐸

. (2) If

𝑒

(

)

𝑒 in the interface order given on the hypernet. Similarly
:: 𝐿𝑎 = 𝐿𝑖 and

𝑒 . Then there is a list of types 𝐿𝑎 such that 𝑠

H

𝑒

𝑒

(

)

(

)

As we will see, though property (4) of hypernets (a specified total ordering on sources and targets) is not so important

in rewriting, it is necessary to establish a typing for hypernets. To reflect this, we depict the interface ordering graphically

+×L+×I+L+×I+K+×I+R+×R+×∆evG∆ev+×G−+L∆ev+×G−+K∆ev+×G−+R∆ev+×H22

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

by drawing a copy of the interface in the specified ordering left-to-right in a blue box and the correspondence between

the ordered interface and the hypergraph.

(a) Copy

(b) Discard

(c) Identity

(d) Symmetry

Fig. 17. Interpretation of string diagrams in hypernets

Every string diagram has an interpretation as a hypernet with these labels, inductively defined based on a(ny)

decomposition of the string diagram. For base cases, contraction, weakening, evaluation, and any of the basic operations
are interpreted as a single hyperedge with the corresponding label from Σ𝐸 . Identity and unary swap are slightly subtle:
in the hypernet representation they do not require an edge. Rather, they are graphs of isolated vertices with different

input and output orderings, as show in Figures 17c and 17d. For induction steps, compositions and abstraction are as

expected, with abstraction taking advantage of the hierarchical structure. We write
diagram 𝑆 under this scheme.

𝑆
(cid:74)

(cid:75)

for the interpretation of a string

Note that this interepretation scheme absorbs the equations required of a symmetric monoidal category. Sequentially

composing an identity hypernet with any other hypernet (that can be composed with that identity) results in a hypernet

isomorphic to the given hypernet. Similarly, associativity of compositions and tensoring with the unit also yield

isomorphic hypernets. Finally, the two sides of the equations for naturality and idempotency of symmetry, when

interpreted under this scheme, also result in isomorphic hypernets.

In the other direction, we can show that every hypernet arises as the interpretation of a string diagram, and further

that all string diagrams which have a given hypernet as their interpretation are equivalent modulo the equations

of symmetric monoidal categories. Before we do this, it is useful to establish a result about hypernets similar to the

foliation decomposition of lemma 2.2.

Lemma 4.11. Let

be a hypernet, and

be a connected, down-closed, outermost-level subnet. Then there is a

H
into the sequential composition of (1) a hypernet, (2) the parallel composition of

G ⊆ H

with some identity

G

decomposition of

H
hypernets, and (3) another hypernet.

Proof. Topologically sort the hypernet. The edges after the last edge of

form (3). Edges before the last of

but

not including any edges from

any outputs of (1) not used in

G

G

form (1). Finally, any edges of

form (2).

G

Note that this decomposition is certainly not unique.

G

, together with new vertices (identity hypernets) for

G

□

Theorem 4.12 (Hierarchical Definability). Let 𝐻 be well-typed hypernet. There exists a string diagram 𝑆 such that
= 𝐻 . If 𝑆 ′ is any other string diagram with the property that

= 𝐻 , then 𝑆 =𝑆𝑀𝐶 𝑆 ′.

𝑆 ′
(cid:74)

(cid:75)

𝑆
(cid:74)

(cid:75)

∆!Functorial string diagrams for RAD

23

Proof. For existence, we induct on the number of edges of the hypernet. If the hypernet has no edges, the output

ordering is some permutation of the input ordering. Since all permutations are generated by the set of adjacent

transpositions, there is a combination of unary swaps which has this hypernet as its interpretation.

If the hypernet has at least one edge, it has a outermost-level edge. Let 𝑒 be an arbitrary outermost-level edge, and
G
be the hypernet inside 𝑒 (if there is one). By lemma 4.11, we can decompose this hypernet into three pieces. Hypernets
(1) and (3) do not contain 𝑒, so by the induction hypothesis they have a string diagram representation. If (2) has a basic
label, it is the interpretation of the corresponding symbol in the signature. If (2) does not have a basic label (and thus

has an interior hypernet), the induction hypothesis again tells us the interior is the interpretation of a string diagram.
Then 𝑒 is the interpretation of the abstraction of that string diagram. The sequential composition of these three string
diagrams is then a string diagram represented by 𝐻 .
□

We denote the string diagram (up to symmetric monoidal axioms) of a hypernet 𝐻 as

Lemma 4.13. Let

be a hypernet. For every connected subnet

H

(1) of Lem. 4.8), there is a decomposition of the string diagram

which includes the string diagram

G ⊆ H
(cid:76)H (cid:77)

Proof. Combine Lem. 4.11 and Thm. 4.12.

.
(cid:76)G(cid:77)

□

.
(cid:77)
which contains all its descendents (as in assumption

𝐻
(cid:76)

Axioms of the Cartesian structure are not “baked in” to the hypernet structure in the way the properties of symmetric

monoidal structures are. Instead, these equations are modeled by bidirectional rewriting rules.

Theorem 4.14. Every equation of Cartesian closed categories has a corresponding bidirectional rewrite rule. That is, for
such

every equation 𝐿 = 𝑅 of Cartesian closed categories (expressed as string diagrams) there is a rewrite rule
that applying this rule in a hypernet

𝑅
(cid:75) ↔ (cid:74)

𝐿
(cid:74)

(cid:75)

Proof. It is a straightforward, but tedious, exercise to find spans in the style of example 4.5 relating the left- and

right-hand sides of each required equation, and checking that they satisfy the conditions of lemmas 4.7 and 4.8.

□

5 RELATED WORK

5.1 String diagrams

Cartesian closed categories have been thoroughly studied in the context of logic and type theory, because of the
well-known correspondence of their internal language with 𝜆-calculus and intuitionistic logic [Sørensen and Urzyczyn
2006]. The linear version of this triad involves monoidal rather than cartesian categories, but also proof nets, and linear

logic, as indicated already in the original paper [Girard 1987]. [Melliès 2006] provides the foundation on which we

build our language of string diagrams, noting that all the basic ingredients are already there.

The route of using an enhancement of the monoidal closed structure with additional properties to control sharing is

fruitful and has been employed many times. For example it is found in [Bonchi et al. 2018], where the manipulation

of variables endowed with algebraic theories is modeled as a cartesian structure on the top of a linear structure, or

in [Ghica 2007] to specify multiplexers and demultiplexers in high-level synthesis.

To the best of our knowledge, we provide the first fully specified string diagrammatic language for cartesian

closed categories generated as a graphical syntax quotiented by equations. Our approach shares similarities with the
formalisms of sharing graphs for describing 𝜆-calculus computations [Lamping 1990]. The main difference is that string
diagrams, albeit graphical in appearance, can be manipulated as a syntax, whereas sharing graphs are usually studied

as combinatorial objects. Unlike syntax, reasoning about graphs algebraically requires a higher degree of technical

24

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

sophistication [Guerrini 1999]. Finally, sharing graphs are typically used to study low-level computational models

for functional languages, in particular quantitative models [Muroya and Ghica 2019], whereas our approach is more

focussed on equational reasoning and rewriting, and does not have the ambition of investigating the resources employed

during computation.

Monoidal closed categories extend not only to cartesian closed categories, but also to ★-autonomous categories. This
second variation is very much relevant to the study of multiplicative linear logic and it has been extensively studied in

terms of proof nets. Our graphical calculus is essentially different from proof nets. The grammar of generating morphism

does not stem from a sequent calculus, and we capture the intended semantics via equations rather than a correctness

criterion. But the connection might be made precise relying on the existing translations between proof nets and string

diagrams [Hughes 2005; Shulman 2020]. This is not the only possible extension. For example, another direction of

extending monoidal categories is to traced monoidal categories [Hasegawa 1997], which has interesting applications to

modeling circuits with feedback [Ghica et al. 2017]. Finally, a different style of hierarchical string diagrams appear in

the literature to represent universal properties graphically such as Kan extensions [Hinze 2012] and free monads [Piróg

and Wu 2016].

The only other proposal for a string-diagram language for monoidal closed categories which we are aware of is that

of [Baez and Stay 2010]. We found a great deal of inspiration in their proposal, but in the process of fully working out
the equational properties and the combinatorial structure we felt compelled to deviate somewhat from loc. cit.. To keep
the language of types as simple as possible and as strict as possible they propose an intriguing graphical innovation, a

so-called clasp operator on stems. The exponential type is represented, using the clasp, as
. Much like in
our own language, a bubble is used to represent currying. A simple example which uses both these graphical devices is

𝑌 , represented as

the name of a function 𝑓 : 𝑋
details in particular for the clasp, e.g. how it can be used to represent higher-order objects (e.g.

. We found it difficult to work out some of the unspecified
⊸ 𝐶). But,
more fundamentally, it was unclear to us what status we can give the clasp both as a syntactic and as a combinatorial
object. To conclude, the approach in loc. cit. is ambitious and innovative and, if the details were figured out, potentially

𝐴 ⊸ 𝐵

→

(

)

more elegant in that it preserves an appealing visual parallel between monoidal closed and compact closed structures.

However, filling in the missing details proved to be too challenging.

5.2 Rewriting of hierarchical graphs

The notion of hierarchical hypergraph used in this paper is closely inspired by, and a formalisation of the graphs used

in [Ghica et al. 2019].

Although there is no consensus on a standard definition of hierarchical graphs, the various approaches to rewriting

on these structures [Bruni et al. 2010b; Drewes et al. 2002; Palacz 2004] give slight variations on the idea of graphs

containing other graphs and notions of morphism between them. Some of the variations are minor: our hierarchical

hypergraphs are directed, but some works do not make this choice [Drewes et al. 2002]. Other differences are much

more stark. Sometimes edges are permitted to connect vertices with different parents, as in [Palacz 2004], sometimes

this is prohibited (as it is here), and sometimes it is possible with the aid of an explicit renaming function, as in [Bruni

et al. 2010b]. Some approaches consider only “strict morphisms” sending items in the outermost level to the outermost

Functorial string diagrams for RAD

25

level, but others consider a larger class where this need not hold. Due to the subtle but technically significant differences

between our requirements and the properties of previous works, it was not possible to reuse previous work wholesale,

and we found it necessary to introduce our own variation.

The formal correspondence between monoidal closed categories and hierarchical hypergraphs lies in a tradition

of analogous results relating string diagram rewriting and double-pushout hypergraph rewriting, see [Bonchi et al.

2016]. To the best of our knowledge, such correspondence has not been spelled out in the way presented in our work,

although the idea of linking the exponential structure of closed categories with the hierarchy structure of hierarchical

hypergraphs may be found in [Coccia et al. 2002]. Although it does not uses string diagrams or other categorical tools,

the algebraic specification language for hierarchical graphs studied in [Bruni et al. 2010a] is aiming towards similar

goals.

5.3 Syntax as a graph-like data structure

Representing intermediate stages of the compiler as graphs is a long-established practice in compiler design and
engineering. Graphs are an efficient syntactic representation which are recognised as a better target for optimisation
and analysis than raw text. In its simplest incarnation the graph representation of terms is just a abstract syntax tree,

but more sophisticated representations were increasingly used [Click and Paleczny 1995], sometimes leading to specific

and novel optimisation techniques [Nandi et al. 2020].

The use of graph-like representation outside of compiler engineering has a lot of untapped potential, as advocated

by some [Ghica 2020]. This is not entirely new, for example interaction nets are a graph-like semantics of higher-order

computation [Lafont 1990], but they are specified at a fairly high level of informality which string diagrams and

hypernets make fully formal in two different ways.

Although not presented explicitly as a string diagram language, the treatment of closures in [Schweimeier and
Jeffrey 1999] is related in methodology to our work, although the use of partially-traced partially-closed pretmonoidal
categories as the categorical setting, in order to accommodate for effects, is significantly different than our cartesian

closed categorical language.

Finally, another related line of work which we found inspirational is the use of graph-like languages inspired by proof

nets to bridge the gap between syntax and abstract machines, in order to provide a quantitative analysis of reduction

strategies for the lambda calculus [Accattoli 2015].

5.4 Automatic differentiation

Our AD algorithm is an adaptation of [Pearlmutter and Siskind 2008]. Beyond the presentation based on string diagrams,

the main differences are that our algorithm applies to simply-typed, recursion-free code and it acts as a source-to-source

transformation, lacking the reflection features that enabled higher-order differentiation in the original work. We chose

to focus on this algorithm for a few reasons: first, reverse-mode AD is both more immediately useful (see [Baydin

et al. 2017] for a comparison of both approaches) and harder to implement and prove correct than forward-mode AD.

Simple forward-mode AD algorithms based on operator overloading [Karczmarczuk 1998; Pearlmutter and Siskind

2007] capable of handling higher-order functions predate [Pearlmutter and Siskind 2008]. Second, it is to our knowledge
the first published algorithm for performing reverse-mode AD on higher-order code1, it forms the basis of a number
of efficient implementations [Baydin et al. 2016; Siskind and Pearlmutter 2016] and does not require more complex

1An earlier algorithm appears in [Karczmarczuk 2000], however it is argued in [Pearlmutter and Siskind 2008] that this algorithm results in different
computation graphs – and worse asymptotic complexity – than ‘traditional’ reverse-mode AD

26

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

features, unlike e.g. [Wang et al. 2019] which makes use of mutable state and continuations or [Brunel et al. 2020]

which relies on a limited form of continuations to encode dual spaces.

A wave of recent research has also tackled the issues of correctness in automatic differentiation. Notably, [Brunel

et al. 2020] and [Vákár 2021] provide correct reverse-mode AD algorithms capable of handling closures. Unlike the first

work, however, our algorithm is purely functional and, while the second one can correctly differentiate terms with

higher-order inputs and outputs, it achieves so by using a more expensive representation of tangents of function spaces.

The main contribution of our approach, however, is the simplicity of the involved proofs thanks to our diagrammatic

notation which we believe improves on the readability of the original paper [Pearlmutter and Siskind 2008] and the

denser proofs in newer literature [Brunel et al. 2020; Huot et al. 2020; Vákár 2021].

6 CONCLUSION AND FURTHER WORK

In this paper we have presented a recipe for provably correct reverse automatic differentiation built around a new,

hierarchical, calculus of string diagrams. As we have seen, the string diagram presentation simplifies much of a

bookkeeping of variables which a term calculus would require, which, we believe, makes a complicated algorithm more

readable. More importantly, the new perspective offered by string diagrams and in particular the presentation of terms
as foliations opens the door for new and useful proof techniques. Finally, the combinatorial representation of string

diagrams as hypergraphs makes it possible to formulate automatic differentiation using the established language of

DPO graph rewriting.

In this paper we have not discussed implementation matters, yet these are of the essence. This algorithm is a practical

one and it can be incorporated into real-life compilers for real-life programming languages. We surmise that the new

an improved perspective on AD that string diagrams offers will help handle other challenging features of real-life

languages, such as effects and, in particular, the crucial role that closures play. This is work is ongoing.

ACKNOWLEDGMENTS

This material is based upon work supported by the Engineering and Physical Sciences Research Council (UK) under

Grant EP/V001612/1 (Nominal String Diagrams).

REFERENCES

Martín Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques Lévy. 1991. Explicit Substitutions. J. Funct. Program. 1, 4 (1991), 375–416. https:

//doi.org/10.1017/S0956796800000186

Beniamino Accattoli. 2015. Proof nets and the call-by-value 𝜆-calculus. Theor. Comput. Sci. 606 (2015), 2–24. https://doi.org/10.1016/j.tcs.2015.08.006
John Baez and Mike Stay. 2010. Physics, topology, logic and computation: a Rosetta Stone. In New structures for physics. Springer, 95–172. https:

//doi.org/10.1007/978-3-642-12821-9_2

Atilim Gunes Baydin, Barak A. Pearlmutter, Alexey Andreyevich Radul, and Jeffrey Mark Siskind. 2017. Automatic Differentiation in Machine Learning: a

Survey. J. Mach. Learn. Res. 18 (2017), 153:1–153:43.

Atilim Günes Baydin, Barak A. Pearlmutter, and Jeffrey Mark Siskind. 2016. DiffSharp: An AD Library for .NET Languages. CoRR abs/1611.03423 (2016).

arXiv:1611.03423 http://arxiv.org/abs/1611.03423

Filippo Bonchi, Fabio Gadducci, Aleks Kissinger, Pawel Sobocinski, and Fabio Zanasi. 2016. Rewriting modulo symmetric monoidal structure. In Proceedings
of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science, LICS ’16, New York, NY, USA, July 5-8, 2016, Martin Grohe, Eric Koskinen, and
Natarajan Shankar (Eds.). ACM, 710–719. https://doi.org/10.1145/2933575.2935316

Filippo Bonchi, Pawel Sobocinski, and Fabio Zanasi. 2018. Deconstructing Lawvere with distributive laws. J. Log. Algebraic Methods Program. 95 (2018),

128–146. https://doi.org/10.1016/j.jlamp.2017.12.002

Aloïs Brunel, Damiano Mazza, and Michele Pagani. 2020. Backpropagation in the simply typed lambda-calculus with linear negation. Proc. ACM Program.

Lang. 4, POPL (2020), 64:1–64:27. https://doi.org/10.1145/3371132

Functorial string diagrams for RAD

27

Roberto Bruni, Fabio Gadducci, and Alberto Lluch-Lafuente. 2010a. An Algebra of Hierarchical Graphs. In Trustworthly Global Computing - 5th International
Symposium, TGC 2010, Munich, Germany, February 24-26, 2010, Revised Selected Papers (Lecture Notes in Computer Science), Martin Wirsing, Martin
Hofmann, and Axel Rauschmayer (Eds.), Vol. 6084. Springer, 205–221. https://doi.org/10.1007/978-3-642-15640-3_14

Roberto Bruni, Fabio Gadducci, and Alberto Lluch-Lafuente. 2010b. An Algebra of Hierarchical Graphs and its Application to Structural Encoding. Sci.

Ann. Comput. Sci. 20 (2010), 53–96.

Antonio Bucciarelli, Thomas Ehrhard, and Giulio Manzonetto. 2010. Categorical models for simply typed resource calculi. Electronic Notes in Theoretical

Computer Science 265 (2010), 213–230.

Cliff Click and Michael Paleczny. 1995. A Simple Graph-Based Intermediate Representation. In Proceedings ACM SIGPLAN Workshop on Intermediate

Representations (IR’95), San Francisco, CA, USA, January 22, 1995, Michael D. Ernst (Ed.). ACM, 35–49. https://doi.org/10.1145/202529.202534

Matteo Coccia, Fabio Gadducci, and Ugo Montanari. 2002. GS.Lambda Theories: A Syntax for Higher-Order Graphs. In Category Theory and Computer
Science, CTCS 2002, Ottawa, Canada, August 15-17, 2002 (Electronic Notes in Theoretical Computer Science), Richard Blute and Peter Selinger (Eds.),
Vol. 69. Elsevier, 83–100. https://doi.org/10.1016/S1571-0661(04)80560-7

Robin Cockett, Geoffrey Cruttwell, Jonathan Gallagher, Jean-Simon Pacaud Lemay, Benjamin MacAdam, Gordon Plotkin, and Dorette Pronk. 2019.

Reverse derivative categories. arXiv preprint arXiv:1910.07065 (2019).

Frank Drewes, Berthold Hoffmann, and Detlef Plump. 2002. Hierarchical Graph Transformation. J. Comput. Syst. Sci. 64, 2 (2002), 249–283. https:

//doi.org/10.1006/jcss.2001.1790

Hartmut Ehrig and Hans-Jörg Kreowski. 1976. Parallelism of Manipulations in Multidimensional Information Structures. In Mathematical Foundations of
Computer Science 1976, 5th Symposium, Gdansk, Poland, September 6-10, 1976, Proceedings (Lecture Notes in Computer Science), Antoni W. Mazurkiewicz
(Ed.), Vol. 45. Springer, 284–293. https://doi.org/10.1007/3-540-07854-1_188

Maribel Fernández and Murdoch Gabbay. 2007. Nominal rewriting. Inf. Comput. 205, 6 (2007), 917–965. https://doi.org/10.1016/j.ic.2006.12.002
Dan R. Ghica. 2007. Geometry of synthesis: a structured approach to VLSI design. In Proceedings of the 34th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages, POPL 2007, Nice, France, January 17-19, 2007, Martin Hofmann and Matthias Felleisen (Eds.). ACM, 363–375.
https://doi.org/10.1145/1190216.1190269

Dan R. Ghica. 2020. Operational Semantics with Hierarchical Abstract Syntax Graphs. In Proceedings 11th International Workshop on Computing with
Terms and Graphs, TERMGRAPH@FSCD 2020, Online, 5th July 2020 (EPTCS), Patrick Bahr (Ed.), Vol. 334. 1–10. https://doi.org/10.4204/EPTCS.334.1
Dan R. Ghica, Achim Jung, and Aliaume Lopez. 2017. Diagrammatic Semantics for Digital Circuits. In 26th EACSL Annual Conference on Computer Science
Logic, CSL 2017, August 20-24, 2017, Stockholm, Sweden (LIPIcs), Valentin Goranko and Mads Dam (Eds.), Vol. 82. Schloss Dagstuhl - Leibniz-Zentrum
für Informatik, 24:1–24:16. https://doi.org/10.4230/LIPIcs.CSL.2017.24

Dan R. Ghica, Koko Muroya, and Todd Waugh Ambridge. 2019. Local Reasoning for Robust Observational Equivalence. CoRR abs/1907.01257 (2019).

arXiv:1907.01257

Jean-Yves Girard. 1987. Linear Logic. Theor. Comput. Sci. 50 (1987), 1–102. https://doi.org/10.1016/0304-3975(87)90045-4
Jean-Yves Girard, Paul Taylor, and Yves Lafont. 1989. Proofs and types. Vol. 7. Cambridge university press Cambridge.
Stefano Guerrini. 1999. A General Theory of Sharing Graphs. Theor. Comput. Sci. 227, 1-2 (1999), 99–151. https://doi.org/10.1016/S0304-3975(99)00050-X
Masahito Hasegawa. 1997. Recursion from Cyclic Sharing: Traced Monoidal Categories and Models of Cyclic Lambda Calculi. In Typed Lambda Calculi
and Applications, Third International Conference on Typed Lambda Calculi and Applications, TLCA ’97, Nancy, France, April 2-4, 1997, Proceedings (Lecture
Notes in Computer Science), Philippe de Groote (Ed.), Vol. 1210. Springer, 196–213. https://doi.org/10.1007/3-540-62688-3_37

Chris Heunen and Jamie Vicary. 2012. Lectures on categorical quantum mechanics. Computer Science Department. Oxford University (2012). http:

//www.cs.ox.ac.uk/files/4551/cqm-notes.pdf

Ralf Hinze. 2012. Kan Extensions for Program Optimisation Or: Art and Dan Explain an Old Trick. In Mathematics of Program Construction - 11th
International Conference, MPC 2012, Madrid, Spain, June 25-27, 2012. Proceedings (Lecture Notes in Computer Science), Jeremy Gibbons and Pablo
Nogueira (Eds.), Vol. 7342. Springer, 324–362. https://doi.org/10.1007/978-3-642-31113-0_16

Dominic Hughes. 2005. Simple free star-autonomous categories and full coherence. CoRR (2005). https://arxiv.org/abs/math/0506521
Mathieu Huot, Sam Staton, and Matthijs Vákár. 2020. Correctness of Automatic Differentiation via Diffeologies and Categorical Gluing. In Foundations of
Software Science and Computation Structures - 23rd International Conference, FOSSACS 2020, Held as Part of the European Joint Conferences on Theory
and Practice of Software, ETAPS 2020, Dublin, Ireland, April 25-30, 2020, Proceedings (Lecture Notes in Computer Science), Jean Goubault-Larrecq and
Barbara König (Eds.), Vol. 12077. Springer, 319–338. https://doi.org/10.1007/978-3-030-45231-5_17

Jerzy Karczmarczuk. 1998. Functional Differentiation of Computer Programs. In Proceedings of the third ACM SIGPLAN International Conference on
Functional Programming (ICFP ’98), Baltimore, Maryland, USA, September 27-29, 1998, Matthias Felleisen, Paul Hudak, and Christian Queinnec (Eds.).
ACM, 195–203. https://doi.org/10.1145/289423.289442

Jerzy Karczmarczuk. 2000. Adjoint codes in functional framework. In Informal presentation at the Haskell Workshop, Colloquium PLI 2000, Montreal.

Citeseer.

Delia Kesner. 2007. The Theory of Calculi with Explicit Substitutions Revisited. In Computer Science Logic, 21st International Workshop, CSL 2007, 16th
Annual Conference of the EACSL, Lausanne, Switzerland, September 11-15, 2007, Proceedings (Lecture Notes in Computer Science), Jacques Duparc and
Thomas A. Henzinger (Eds.), Vol. 4646. Springer, 238–252. https://doi.org/10.1007/978-3-540-74915-8_20

Yves Lafont. 1990. Interaction Nets. In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, San Francisco,

California, USA, January 1990, Frances E. Allen (Ed.). ACM Press, 95–108. https://doi.org/10.1145/96709.96718

28

Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi

John Lamping. 1990. An Algorithm for Optimal Lambda Calculus Reduction. In Conference Record of the Seventeenth Annual ACM Symposium on Principles
of Programming Languages, San Francisco, California, USA, January 1990, Frances E. Allen (Ed.). ACM Press, 16–30. https://doi.org/10.1145/96709.96711

Ian Mackie. 2000. Interaction nets for linear logic. Theor. Comput. Sci. 247, 1-2 (2000), 83–140. https://doi.org/10.1016/S0304-3975(00)00198-5
Paul-André Melliès. 2006. Functorial Boxes in String Diagrams. In Computer Science Logic, 20th International Workshop, CSL 2006, 15th Annual Conference
of the EACSL, Szeged, Hungary, September 25-29, 2006, Proceedings (Lecture Notes in Computer Science), Zoltán Ésik (Ed.), Vol. 4207. Springer, 1–30.
https://doi.org/10.1007/11874683_1

Koko Muroya and Dan R. Ghica. 2019. The Dynamic Geometry of Interaction Machine: A Token-Guided Graph Rewriter. Log. Methods Comput. Sci. 15, 4

(2019). https://doi.org/10.23638/LMCS-15(4:7)2019

Chandrakana Nandi, Max Willsey, Adam Anderson, James R. Wilcox, Eva Darulova, Dan Grossman, and Zachary Tatlock. 2020. Synthesizing structured
CAD models with equality saturation and inverse transformations. In Proceedings of the 41st ACM SIGPLAN International Conference on Programming
Language Design and Implementation, PLDI 2020, London, UK, June 15-20, 2020, Alastair F. Donaldson and Emina Torlak (Eds.). ACM, 31–44. https:
//doi.org/10.1145/3385412.3386012

Wojciech Palacz. 2004. Algebraic hierarchical graph transformation. J. Comput. Syst. Sci. 68, 3 (2004), 497–520. https://doi.org/10.1016/S0022-0000(03)00064-

3

Barak A. Pearlmutter and Jeffrey Mark Siskind. 2007. Lazy multivariate higher-order forward-mode AD. In Proceedings of the 34th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, POPL 2007, Nice, France, January 17-19, 2007, Martin Hofmann and Matthias Felleisen (Eds.). ACM,
155–160. https://doi.org/10.1145/1190216.1190242

Barak A. Pearlmutter and Jeffrey Mark Siskind. 2008. Reverse-mode AD in a functional framework: Lambda the ultimate backpropagator. ACM Trans.

Program. Lang. Syst. 30, 2 (2008), 7:1–7:36. https://doi.org/10.1145/1330017.1330018

Maciej Piróg and Nicolas Wu. 2016. String diagrams for free monads (functional pearl). In Proceedings of the 21st ACM SIGPLAN International Conference
on Functional Programming, ICFP 2016, Nara, Japan, September 18-22, 2016, Jacques Garrigue, Gabriele Keller, and Eijiro Sumii (Eds.). ACM, 490–501.
https://doi.org/10.1145/2951913.2951947

Ralf Schweimeier and Alan Jeffrey. 1999. A Categorical and Graphical Treatment of Closure Conversion. In Fifteenth Conference on Mathematical Foundations
of Progamming Semantics, MFPS 1999, Tulane University, New Orleans, LA, USA, April 28 - May 1, 1999 (Electronic Notes in Theoretical Computer
Science), Stephen D. Brookes, Achim Jung, Michael W. Mislove, and Andre Scedrov (Eds.), Vol. 20. Elsevier, 481–511. https://doi.org/10.1016/S1571-
0661(04)80090-2

Peter Selinger. 2010. A survey of graphical languages for monoidal categories. In New structures for physics. Springer, 289–355. https://arxiv.org/abs/0908.

3347

Michael Shulman. 2020.
Jeffrey Mark Siskind and Barak A. Pearlmutter. 2016. Efficient Implementation of a Higher-Order Language with Built-In AD. CoRR abs/1611.03416 (2016).

-autonomous envelopes and 2-conservativity of duals. CoRR (2020). arXiv:2004.08487

∗

arXiv:1611.03416 http://arxiv.org/abs/1611.03416

Morten Heine Sørensen and Pawel Urzyczyn. 2006. Lectures on the Curry-Howard isomorphism. Elsevier.
Matthijs Vákár. 2021. Reverse AD at Higher Types: Pure, Principled and Denotationally Correct. In Programming Languages and Systems - 30th European
Symposium on Programming, ESOP 2021, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2021, Luxembourg
City, Luxembourg, March 27 - April 1, 2021, Proceedings (Lecture Notes in Computer Science), Nobuko Yoshida (Ed.), Vol. 12648. Springer, 607–634.
https://doi.org/10.1007/978-3-030-72019-3_22

Fei Wang, Daniel Zheng, James M. Decker, Xilun Wu, Grégory M. Essertel, and Tiark Rompf. 2019. Demystifying differentiable programming: shift/reset

the penultimate backpropagator. Proc. ACM Program. Lang. 3, ICFP (2019), 96:1–96:31. https://doi.org/10.1145/3341700

