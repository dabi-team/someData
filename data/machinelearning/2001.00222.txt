0
2
0
2

n
a
J

1

]

C
D
.
s
c
[

1
v
2
2
2
0
0
.
1
0
0
2
:
v
i
X
r
a

Ripple: A Practical Declarative Programming Framework for Serverless Compute

Shannon Joyner1, Michael MacCoss2, Christina Delimitrou1, and Hakim Weatherspoon1
1Cornell University, 2University of Washington
1{sj677,delimitrou,hw228}@cornell.edu, 2maccoss@uw.edu

Abstract
Serverless computing has emerged as a promising alterna-
tive to infrastructure- (IaaS) and platform-as-a-service (PaaS)
cloud platforms for applications with ample parallelism and
intermittent activity. Serverless promises greater resource
elasticity, signiﬁcant cost savings, and simpliﬁed application
deployment. All major cloud providers, including Amazon,
Google, and Microsoft, have introduced serverless to their
public cloud offerings. For serverless to reach its potential,
there is a pressing need for programming frameworks that
abstract the deployment complexity away from the user. This
includes simplifying the process of writing applications for
serverless environments, automating task and data partition-
ing, and handling scheduling and fault tolerance.

We present Ripple, a programming framework designed to
speciﬁcally take applications written for single-machine execu-
tion and allow them to take advantage of the task parallelism
of serverless. Ripple exposes a simple interface that users can
leverage to express the high-level dataﬂow of a wide spectrum
of applications, including machine learning (ML) analytics,
genomics, and proteomics. Ripple also automates resource
provisioning, meeting user-deﬁned QoS targets, and handles
fault tolerance by eagerly detecting straggler tasks. We port
Ripple over AWS Lambda and show that, across a set of di-
verse applications, it provides an expressive and generalizable
programming framework that simpliﬁes running data-parallel
applications on serverless, and can improve performance by
up to 80x compared to IaaS/PaaS clouds for similar costs.

1. Introduction

An increasing number of popular applications are hosted on
public clouds [22, 23, 33, 44, 54]. These include many in-
teractive, latency-critical services with intermittent activity,
for which the current Infrastructure-as-a-Service (IaaS) or
Platform-as-a-Service (PaaS) resource models result in cost
inefﬁciencies, due to idle resources. Serverless computing has
emerged over the past few years as a cost-efﬁcient alternative
for such applications, with the added beneﬁt that the cloud
provider handles all data management, simplifying deploy-
ment and maintenance for the end user. Under a serverless
framework, the cloud provider offers ﬁne-grained resource al-
locations to users who only pay a small amount for them when
a task is executing, resulting in much lower hosting costs.

Several cloud providers have introduced serverless offerings
to their public cloud models, including AWS Lambda [4],
Google Functions [10], and Azure Functions [11]. In all cases,
with small variations, a user launches one or more “functions”,

which the provider maps to one or more machines. Functions
take less than a second to spawn, and most providers allow the
user to spawn hundreds of functions in parallel. This makes
serverless a good option for extremely parallelizable tasks, or
for services with intermittent activity and long idle periods.

Big data, scientiﬁc, and certain classes of machine learning
(ML) analytics are good candidates for serverless, as they tend
to have ample task parallelism, and their storage and compute
requirements continue to increase exponentially [27,47,65,70].
Hosting such services on traditional IaaS and PaaS clouds
incurs signiﬁcantly higher costs compared to serverless, since
instances need to be maintained for long periods of time to
ensure low start-up latencies. Alternatively, if optimizing for
cost, tasks from large jobs are subject to long queueing times
until resources become available, despite tasks being ready to
execute. When the input load is bursty the reverse is also true,
with provisioned resources remaining idle during periods of
low load. While cloud providers have auto-scaling systems
in place to provide some elasticity in the number of allocated
instances as load ﬂuctuates [3], elasticity is offered at instance
granularity. Additionally, scaling out is not instantaneous,
resulting in unpredictable or degraded performance, which is
especially harmful for short-running tasks.

The premise of serverless is improving resource elasticity,
and cost efﬁciency. To realize this we need programming
frameworks that can (i) extract parallelism from existing cloud
applications, (ii) simplify writing new applications for server-
less compute, (iii) manage data dependencies between func-
tions transparently to the user, and (iv) automatically handle
resource elasticity, data partitioning, fault tolerance, and task
scheduling to mask the performance unpredictability public
clouds are subject to [21, 34, 35, 45, 66, 67, 74–76].

Serverless frameworks additionally need to be pro-
grammable enough for users to express generic applications
at a high-level, and ﬂexible enough to circumvent the limita-
tions of current serverless offerings, such as AWS Lambda,
which limits each function to 512MB of disk space and a 15
minute runtime. Existing analytics and ML frameworks, like
Hadoop [68], Spark [2], and TensorFlow [16], can handle
some of these requirements, but need to run over an active
cluster by default. This is problematic in the case of server-
less frameworks where resources are frequently allocated
and reclaimed, requiring the framework to be re-deployed
across runs. Additionally, such general-purpose frameworks
are storage-demanding, in terms of both memory and disk,
consuming a large fraction of the limited system resources
allocated per serverless function.

 
 
 
 
 
 
Figure 1: Overview of Ripple’s operation, from converting a monolithic application to
serverless, to proﬁling and deploying the service to AWS Lambda.

parallelism,

We present Ripple, a programming
framework designed speciﬁcally for
serverless computing platforms that
run highly data-parallel applications.
Ripple exposes a high-level declara-
tive programming interface that en-
ables programmers to express the in-
herent parallelism in their computa-
tion, as well as phases that must be
executed serially. The framework is
general enough to capture execution
patterns of a wide range of analytics
and scientiﬁc applications, including
ML analytics and bioinformatics. Ripple uses serverless for
all computation phases, removing the need for maintaining
long-term instances. It also handles work partitioning automat-
ically, assigning input data chunks to serverless functions, and
synchronizing them when required. Ripple also allows users
to express priorities and deadlines for their jobs, implementing
a variety of scheduling policies, including round-robin, FIFO,
and deadline-based scheduling. Furthermore, Ripple leverages
information about previously-seen jobs to automatically infer
the degree of concurrency (number of Lambdas per phase) that
will allow a new job to meet its QoS requirements. Finally, it
handles fault tolerance transparently to the user, respawning
failing or under-performing tasks.

We evaluate Ripple using AWS Lambda. The design of the
framework is portable across serverless frameworks, including
Google Functions and Azure Functions, with minimal modi-
ﬁcations. We focus on three large-scale cloud frameworks, a
proteomics framework, DNA compression, and a kNN-based
classiﬁcation service used to identify buildings in satellite
imaging data [15, 24, 63]. We show that Ripple offers a simple
way for users to express the pipelines of complex applications
in a few lines of code, and that serverless computing offers
dramatic performance improvements for data-parallel applica-
tions, especially as the size of their datasets increases. Specif-
ically, we show that Ripple can be up to 80× faster than an
EC2 cluster, and 30% cheaper than PyWren [49] for a similar
runtime. We also demonstrate that Ripple automatically han-
dles the resource provisioning of a given job meeting its QoS
target, and can support different scheduling and fault tolerance
mechanisms that further improve performance predictability.
Ripple is open-source software under a GPL license.

2. Background

2.1. Advantages of Serverless

Serverless allocates ﬁne-grained resources for a limited time,
which reduces the overprovisioning problem current datacen-
ters experience [30–34, 36, 57, 66]. It also simpliﬁes cloud
management; users simply upload the code they wish to exe-
cute to the cloud, and cloud providers handle the state manage-
ment and resource provisioning. If an application has ample

2

serverless achieves much better performance for comparable
cost to traditional PaaS or IaaS platforms [40, 42, 43].

Users only pay when a serverless function is running, mak-
ing the model well-suited for applications with intermittent
activity. Traditional cloud instances can be rented and freed
up on-demand, but initializing a new instance takes at least
30s. In comparison, spawning and destroying a serverless
function takes a few milliseconds. For short-running tasks
that complete in a few seconds, the overhead of instantiat-
ing and releasing cloud instances can have a dramatic impact
on execution latency. Some of the most popular serverless
computing offerings at the moment include AWS Lambda,
Google Functions, Azure Functions, OpenLambda, and Open-
Whisk [1, 4, 10, 11, 48].

2.2. Limitations of Serverless

Despite its increasing popularity, serverless still needs to over-
come several system challenges. First, while cloud providers
make triggering serverless functions easy, they do not cur-
rently offer an easy way to share state between functions. If
a user wants to combine results from multiple functions, or
save state to use later in the pipeline, this state needs to be
saved in remote storage – S3 for AWS Lambda – potentially
degrading application performance [4, 5]. Second, current
serverless functions are resource-constrained, typically being
limited to a single CPU, a couple GB of memory, and a few
hundred MB of disk space. This limits the type of computa-
tion that can be hosted on serverless, especially given the fact
that current platforms do not offer a way for users to partition
their work to functions in a programmable and systematic
way. This is especially challenging for non-expert cloud users
running applications with complex workﬂows, where the de-
gree of available parallelism varies across execution phases.
Third, despite the increased visibility cloud providers have
into serverless applications as opposed to traditional PaaS- or
IaaS-hosted applications, current platforms still do not have
a way for users to express a quality-of-service (QoS) target
for their applications that the cloud provider must meet. This
is especially detrimental in serverless frameworks where re-
source sharing, even of a single CPU, is much more prevalent

RippleNewmonolithicappλλλλλλλλλλλSGDCanaryrunProvision& DeployCanaryrun………RippleApp converted to serverlesspipelineλλλλλλλλλλλλλλλλλλDescription
Split a ﬁle into small data chunks

Ripple Programming Interface
Arguments
split_size: (optional) Number of lines per chunk; default 1MB.

Combine multiple ﬁles

identifier: (optional) Field to sort resulting items by.

split

combine

top

Return the top items in a ﬁle

identifier: Field to sort items by.
number: Number of items to return.

match

Match ﬁles to i keyword

map

Map each item to an input

sort

partition

Sort ﬁle using Radix sort
Return n equally spaced ranges (used
for Radix sort)

run

Invoke Lambda function

find: Property to look for; e.g., highest score sum.
identifier: Field to sort items by.

input_key: Key parameter to set input name to for next phase.
map_table: Table containing list of ﬁles to map.
table_key: Key parameter to set table name to for next phase.
directories: (optional) Use table directories to map.

identifier: Field to sort items by.

identifier: Field used to partition the items into ranges.

application: The name of the application ﬁle to execute.
output_format: (optional) Format of the output ﬁle.

Table 1: The programming interface of Ripple.

than in traditional cloud systems, and hence applications are
more prone to unpredictable performance due to interference.
The challenges and opportunities of serverless put increased
pressure on programming frameworks that simplify porting
traditional cloud applications on to serverless platforms in a
way that masks their current limitations.

3. Ripple Design

We propose Ripple, a general-purpose programming frame-
work for serverless that targets applications with ample paral-
lelism. Ripple follows the model of a high-level declarative
language; a user expresses a job’s dataﬂow at a high level,
and Ripple abstracts away the complexity of data partitioning
(Sec. 3.1), task scheduling (Sec. 3.4), resource provisioning
(Sec. 3.2), and fault tolerance (Sec. 3.3). Fig. 1 shows the
high-level overview of the framework.

3.1. Ripple Programming Framework

Ripple exposes a concise programming interface of eight prin-
cipal functions that users can leverage to express the most
common parts of their services’ dataﬂow, including parallel
and serial phases, and dependencies between dataﬂow stages.
Each function can be used in one or more stages of a job. The
programming interface is shown in Table 1. Apart from the
eight functions in the table, users can also upload arbitrary
operations, and invoke them through the run function.

Algorithm 1 shows an example Ripple application for port-
ing a simple DNA compression algorithm to AWS Lambda.
The config parameter contains the basic setup parameters,
such as the default amount of memory to use for functions.
The pipeline is initialized by specifying the job conﬁgura-
tion and the result and logs locations. Next, an input variable

import ripple
// Configure region and Lambda resources
config = {

" region ": "use -west -2",
"role": "aws -role",
" memory_size ": 2240 ,

}
// Express computation phases
pipeline = ripple . Pipeline (

name=" compression ",
table ="s3 ://my - bucket ",
log="s3 ://my -log",
timeout =600 ,
config = config

)
// Define input data
in = pipeline .input( format =" new_line ")
// Declare how to sort input data
step = input.sort(

identifier =" start_position ",
params ={" split_size ": 500*1000*1000} ,
config ={" memory_size ": 3008}

)
// Declare compression method
step = step.run(

" compress_methyl ",
params ={" pbucket ": "s3 ://my - program "}

)
// Create and upload functions
pipeline . compile ("json/ compile .json")

Listing 1: Ripple Conﬁguration for DNA Compression.

is declared. The input variable declares the data format of the
input dataset, which helps Ripple determine how to split and
manipulate the data. The input DNA ﬁles can be gigabytes
in size, signiﬁcantly more than the 512MB of disk space or
3GB of memory space offered by Lambda. The compression
algorithm relies on ﬁnding sequences with similar preﬁxes.
Therefore, Ripple calls sort on the input ﬁle, which sorts
the ﬁle into 500MB chunks. The user can also provide an

3

application-speciﬁc hint on the split size a function should
handle. In this example, sort needs more than 2240MB, so
the memory allocation is 3008MB instead. The next step com-
presses the input shards, invoked via Ripple’s run function.
The application function returns the paths of the ﬁles that
Ripple should pass to the next pipeline step.

Once the user speciﬁes all execution steps, they can compile
the pipeline, which generates the JSON ﬁle Ripple uses to set
up the serverless functions. Ripple then uploads the code and
dependencies to AWS, and schedules the generated tasks.

3.2. Automating Resource Provisioning

One of the main premises of serverless is simplifying resource
provisioning, by letting the cloud provider handle resource
allocation and elastic scaling. Serverless frameworks today
still do not achieve that premise, by requiring the user to
specify the number of serverless functions a job is partitioned
In addition to allowing users to specify priorities
across.
among their jobs (Sec. 3.4), Ripple also automates the resource
provisioning and scaling process for submitted applications.
Speciﬁcally, when a new application is submitted to AWS
Lambda via Ripple, the user also expresses a deadline that the
job needs to complete before [69,72]. Ripple uses that deadline
to determine the right resources for that job, depending on
whether the job consists of one or multiple phases.
Single-phase jobs: This is the simplest type of serverless jobs,
where the input data is partitioned, processed, and the result
is combined, and either stored on S3 or sent directly to the
user. In this case, Ripple just needs to determine the number
of Lambdas needed for processing. Ripple uses a two-step
process to determine the appropriate degree of concurrency.
First it selects a small partition of the original input dataset,
min(20MB,full_input), called canary input. 1 By default
Ripple selects the canary input starting from the beginning of
the dataset, unless otherwise speciﬁed by the user. It then uses
the canary input as the input dataset for two small jobs, each
with different data split sizes per Lambda. One job runs with
the default split size for AWS Lambda, 1MB, and the other
with the split size Lambdas would have if the job used its max-
imum allowed concurrency limit (1,000 on AWS by default).
To track task progress when enforcing different resource allo-
cations, Ripple implements a simple tracing system detailed
in Sec. 4. Ripple’s tracing system collects the per-Lambda and
per-job execution time (including the overheads for work par-
titioning and result combining), and uses this information to
infer the performance of the job with any split size. Inference
happens via Stochastic Gradient Descent (SGD), where SGD’s
input is a table with jobs as rows and split sizes as columns.
SGD has been shown to accurately infer the performance of
applications on non-proﬁled conﬁgurations, using only a small
amount of proﬁling information [30, 33, 51, 53], in the context
of cluster scheduling, heterogeneous multicore conﬁguration,

1The 20MB lower limit is determined empirically to be sufﬁcient for our

applications, and can be tuned for different services.

and storage system conﬁguration. As new jobs are scheduled
by Ripple, the number of rows in the table increases. Given
that input dataset sizes varies across jobs, the table includes
proﬁling information on a diverse set of split sizes, including
one split size (default=1MB) that is consistent across all jobs.
Once Ripple determines the level of concurrency that will
achieve a job’s speciﬁed deadline, it launches the full applica-
tion and monitors its performance. If measured performance
deviates from the estimated performance with that degree of
concurrency, Ripple updates the table with the measured infor-
mation to improve prediction accuracy over time.

Apart from specifying per-job deadlines, users can also re-
quest that Ripple tries to achieve the best possible performance
for a job, given AWS’s resource limits, or alternatively, they
can specify an upper limit for the cost they are willing to spend
for a job, in which case Ripple maximizes performance under
that cost constraint.
Multi-phase jobs: Typical serverless applications involve
multiple phases of high concurrency, which may be interleaved
with sequential phases that combine intermediate results. The
process Ripple follows to provision such jobs is similar to
the one described above, with the difference that columns in
the SGD table are now ratios of concurrency degrees across
phases. Ripple also needs to increase the number of canary
runs to ensure high prediction accuracy from two for single-
phase jobs to four for multi-phase jobs. Split sizes per phase
are selected in [1MB,fullDataset/maxLambdas] as before. If
measured performance deviates from estimated, Ripple again
updates the corresponding column in the table to improve
accuracy the next time a similar job is scheduled.

Note that higher Lambda concurrency does not necessar-
ily translate to better performance for three reasons. First,
getting a speedup as Lambdas increase is contingent on the
available parallelism in a job’s computation. Applications
with a low inherent parallelism will not beneﬁt from a higher
degree of concurrency, while also incurring higher costs for
the increased number of serverless functions. Second, paral-
lelism does not come for free, as work and data needs to be
partitioned and distributed across tasks, and results need to
be reassembled and combined before computation can pro-
ceed. This is especially the case for multi-stage job pipelines,
where parallel phases are interleaved with phases that combine
intermediate results. Third, a larger number of concurrent
serverless functions also increases the probability that some
of these tasks will become stragglers and degrade the entire
job’s execution time.

Obtaining a small amount of proﬁling information before
provisioning a new job allows Ripple to identify if either of the
ﬁrst two reasons that would prevent a job from beneﬁting from
higher concurrency are present. The third reason is impacted
both by job characteristics, e.g., faulty data chunks can cause
some Lambdas to become stragglers, and by the state of the
serverless cluster, e.g., some Lambdas can underperform due
to interference between tasks sharing system resources. To

4

address underperforming tasks, we also implement a fault
tolerance mechanism in Ripple, detailed below.

of equal priorities revert to Round-Robin. Unless otherwise
speciﬁed, we use the FIFO scheduler by default.

3.3. Fault Tolerance

4. Implementation

Task failures are common in data-parallel analytics jobs. Fur-
thermore, straggler tasks are a well-documented occurrence,
where a small number of under-performing tasks delay the
completion of the entire application [17, 19, 20, 46, 55, 73].
AWS Lambda does not provide handlers to running functions,
therefore a function’s progress cannot be directly monitored.
Instead, Ripple collects execution logs for each Lambda re-
quest based on when they write to S3. These logs do not only
prevent duplicate requests, but contain payload information to
re-execute failed Lambda processes. If Ripple detects that a
function has not been logged within the user-speciﬁed timeout
period from its instantiation, it will re-execute that function.
This also helps minimize the impact of stragglers, as Ripple
can eagerly respawn tasks that are likely to under-perform.

3.4. Scheduling Policies

Cloud users typically submit more than one job to a public
cloud provider. AWS Lambda at the moment implements a
simple FIFO2 scheduling policy, which means that Lambdas
submitted ﬁrst will also start running ﬁrst. This does not allow
a lot of ﬂexibility, especially when different jobs have different
priorities or must meet execution time deadlines.

Ripple implements several scheduling policies users can
select when they submit their applications. To prevent con-
ﬂicts between scheduling policies speciﬁed in different jobs, a
scheduling policy applies to all active jobs managed by Rip-
ple. Ripple precomputes the best task schedule based on the
speciﬁed scheduling policies, and enforces scheduling policies
by reordering tasks client-side, and deploying them in that or-
der on AWS Lambda. Below we summarize each scheduling
policy supported in Ripple.
FIFO: This is the default scheduling policy implemented
by AWS Lambda. Functions are executed in the order of
submission. Under scenarios of high load, FIFO can lead to
long queueing latencies.
Round-Robin: Ripple interleaves the phases of each job
to allocate approximately equivalent time intervals to each
application. Round-Robin penalizes the execution time of
the ﬁrst few jobs, but reduces queueing delays, and improves
fairness compared to FIFO.
Priorities: Priorities in Ripple are deﬁned at job granularity,
with high-priority jobs superseding concurrently-submitted
low-priority jobs. If a high priority job arrives when the user
has reached their resource quota on Lambda (1,000 active
Lambdas by default), Ripple will pause low priority jobs,
schedule the high priority application, and resume the for-
mer when the high priority job has completed. Applications

2Launching Lambdas happens in a “mostly” FIFO order, however the

exact ordering is not strictly enforced.

Ripple is written in approximately 5,000 lines of code in
Python, including application speciﬁc code and conﬁgura-
tions. The eight functions shown in Table 1 are also written in
Python. A user can create arbitrary functions, as long as the
functions adhere to Ripple’s run template. Currently, Ripple
supports interactions with AWS Lambda and S3. However,
Ripple’s API has been designed to be abstractable to other
providers, including Windows Azure and Google.
Job conﬁguration: A user ports a new application by using
the Ripple API to create the application pipeline. This pipeline
is compiled to a JSON conﬁguration ﬁle. The conﬁguration
ﬁle indicates which Lambda functions to use and the order
in which to execute the functions. If the application requires
manipulation of ﬁle formats that the framework does not sup-
port by default—such as newline separated, TSV, FASTA,
mzML)—, users simply need to implement a format ﬁle for
the framework to know how to parse the input ﬁles. Users also
need to create two tables: one to store the input, intermediate,
and output ﬁles, and another for the log ﬁles Ripple maintains
to manage the execution of functions.

To deploy an application, the user follows an automated
setup process in Ripple, which takes their conﬁguration ﬁle
and uploads all necessary code to AWS. The maximum deploy-
ment package size AWS currently allows is 50MB. However,
AWS provides layers for users to import extra dependencies.
Ripple checks the user’s program for a list of common de-
pendencies, such as numpy or scikit-learn, and links the
functions to their corresponding dependencies [12, 13]. If the
layer does not exist, the user can create and add the new layer
to Ripple. Ripple does not use any additional containeriza-
tion or virtualization processes beyond what AWS Lambda
implements by default.

Tracing and monitoring: Ripple needs to monitor the execu-
tion of active functions to adhere to the speciﬁed scheduling
policies, and ensure performant and fault tolerant operation.
Since AWS Lambda does not provide handlers to active func-
tions, Ripple periodically polls S3 to see if a function has
ﬁnished, and records the function instantiation and comple-
tion events in its execution log. The asynchronous nature of
Lambda makes identifying failed functions challenging. For
every job, Ripple spawns a thread to monitor the job’s progress
based on its logs. Ripple waits until the timeout period spec-
iﬁed by the user for a given function’s log. If the log does
not appear, Ripple re-invokes the function. For scheduling
algorithms, such as deadline-based scheduling, Ripple needs
the ability to “pause” a job. To enable this, we specify a pause
parameter for each job that indicates when functions for that
job should stop executing. To re-execute, Ripple re-triggers
the pipeline, and checks if the task has already executed. If so,

5

Application
SpaceNet
Proteomics
DNA Compression

JSON ﬁle
16
25
13

run functions
250
86
36

Table 2: Lines of Ripple code for each application. “JSON ﬁle”
shows the LoC for the conﬁguration ﬁle, and “run functions”
shows the LoC for the speciﬁc logic of the application.

the function simply re-triggers its child processes. We have
veriﬁed that the tracing system has no noticeable impact on
either Lambda throughput or latency.

Testing library: Due to the asynchronous nature of server-
less, testing can be difﬁcult as logs are spread over multiple
ﬁles. Ripple contains logic to make testing code easier. A user
can specify ﬁles to use as source data and Ripple will locally
and serially go through each stage of the pipeline.

Fault tolerance: Finally, Ripple itself may fail for a number
of reasons, including network outage, server failure, or internal
error. To ensure that such a failure does not leave active
functions unmanaged, we maintain Ripple’s execution log in
persistent storage, such that, if a failure occurs, a hot stand-by
master can take over management of the service.

5. Applications

We use three applications to demonstrate the practicality and
generality of Ripple. In all cases, the modiﬁcations needed to
port the original applications to Ripple are minimal. Ripple
exposes a high-level declarative interface, which enables users
to take code designed to run on a single-machine and port
it to a serverless platform. Below we describe each of the
application frameworks we port on Ripple. The logic of the
protein analytics and DNA compression applications did not
require any changes to be ported to Ripple. The SpaceNet
Building Border Identiﬁcation application was reimplemented
in Python, given AWS’s languages limitations. Table 2 shows
the Ripple lines of code needed for the Ripple JSON conﬁg-
uration ﬁle, and for the run function that is speciﬁc to each
application’s logic.

5.1. SpaceNet Building Border Identiﬁcation

SpaceNet hosts a series of challenges, including identifying
buildings from satellite images [15]. The developers provide
TIFF training and test images of different areas, only some of
which contain buildings. We implemented our own solution
for this challenge using a K-Nearest Neighbor (kNN) algo-
rithm [14]. For each pixel in the training images, we use the
SpaceNet solutions to classify the pixel as a border, inside or
outside the building. In the test image, we identify the most
similar pixels in the training images, and classify the test pix-
els accordingly. SpaceNet offers both high resolution, 3-band
images, and low resolution, 8-band images. For our experi-
ments, we used the 3-band training and test images. Fig. 2

Figure 2: Pipeline for SpaceNet. The convert shards the in-
put data. map pairs test with training data chunks. The KNN
stage performs a brute force KNN. The ﬁrst combine stage
ﬁnds the absolute nearest neighbors for every pixel, and the
second combine stage combines all results into one ﬁle. The
last stage colors the identiﬁed border pixels.

shows the Ripple pipeline for SpaceNet.

5.2. Proteomics

Tide is a protein analytics tool used for analyzing protein
sequences [24]. Tide takes experimental data and scores them
against theoretical se-
quences, deﬁned in a
ﬁle containing protein
sequences predicted
from the genome se-
quence [24, 39]. Ex-
Figure 3: Proteomics with Tide [24].
perimental sequences
We ﬁrst split the input into shards.
are in mzML format,
Next, Tide, determines the protein
an XML-based for-
composition of each chunk. The
mat [25, 59], and the-
output is processed by Percolator.
oretical sequences are
in FASTA format [38]. Results from Tide are often given to
an ML application called Percolator to score the conﬁdence
of the protein composition identiﬁcation [50]. We evaluate
both Tide and Percolator in a single pipeline. Fig. 3 shows the
Ripple pipeline for the proteomics application.

5.3. DNA Compression

METHCOMP is an application to compress and decompress
DNA methylation data [63]. The data from this pipeline are
stored in a BED format, which is newline delimited [6]. This
format remains human-readable, but readability comes at the
expense of high storage costs. Nonetheless, METHCOMP
is both memory- and disk-intensive and the algorithm does
not use threads or multiple cores by default. Figure 4 shows
the Ripple pipeline for the METHCOMP application. The
compression pipeline was modiﬁed to sort the input dataset.

6. Methodology

We run each application on AWS Lambda using Ripple. Un-
less otherwise speciﬁed, we run experiments in regions that
had a max concurrency of 1,000 functions. We compare Ripple
to two other setups; AWS EC2 with resource autoscaling [3],

6

MapCombineCombineCombineConvertKNNKNNKNNMap...............DrawKNNCombineTideSplitPercolator......TideTideCombineCombineFigure 4: Pipeline for DNA compression. The input BED ﬁle is
sorted using Radix sort. This involves ﬁnding pivots in chunk
segments. Once pivots are found, the ﬁle is split, and chunks
are compressed in parallel.

and PyWren [49].
EC2 Autoscaling: We use the Amazon Elastic MapReduce
(EMR) cluster to compare Ripple to EC2 autoscaling. EMR
only allows servers to be added if usage for one or more
resources (CPU, memory) is above a certain threshold for
more than ﬁve minutes. Figure 5 shows how Tide scales using
EMR’s default policy if a job is sent every 10 seconds for an
hour. A server is added if CPU utilization is above 70%, and
removed if CPU utilization is below 30%. The bottom portion
of the graph shows the number of pending jobs. The default 5
minute scaling policy could not handle rapid load increases,
taking almost 2 hours to process all requests and an additional
2 hours to terminate all servers.

To show that even a more agile version of EC2’s autoscal-
ing has suboptimal elasticity compared to Ripple, we also
implemented a version of EC2 autoscaling that increments and
decrements instances at 10s granularity. We implemented this
policy using the boto3 API, and ran all jobs inside Docker
containers to simplify scaling out [7, 8]. Since the Docker
containers often needed signiﬁcant disk space, for every EC2
machine, we allocated a 26GB volume of persistent storage.
PyWren: PyWren is an open-source programming frame-
work for serverless, and the most closely-related prior work to
Ripple [49]. PyWren is designed following the MapReduce
style of distributed processing, with mappers running on AWS
Lambda as a single map phase, followed by reducers running
on traditional EC2 instances.
Below we describe each application’s setup in Ripple, PyWren,
and EC2.

6.1. SpaceNet Building Border Identiﬁcation

We use 1,000 images to train the border classiﬁer. The feature
vector for each pixel was the RGB value of the pixel and
its 8 surrounding neighbors. We store these results in an S3
bucket. For each test image, we use the 100 closest neighbors
to classify a pixel. Finally, we color the identiﬁed border
pixels. For all implementations, we use the scikit-learn
library to compute kNN using brute force [13]. For SpaceNet,
we ran all Lambda experiments in a region where the max
concurrency was 5K functions.
Ripple setup: We create a function to convert TIFF testing
images to their feature vectors. Given the amount of training
and testing data, we split testing images into subsets of 1,000
pixels, and mapped each subset to a subset of training data to

run kNN. This typically resulted in approximately 180 sub-
sets of pixels, each paired with around 40 chunks of training
data, and a total of 7K Lambdas. Results are combined in
two phases; the ﬁrst phase found the absolute 100 nearest
neighbors for each pixel, and the second phase concatenated
the partial outputs. Each pipeline stage is triggered when the
output of the previous phase is written to S3.
PyWren
setup:
For fairness, we at-
tempted to run all
parallel
tasks on
Lambda; however,
the ﬁrst combine
step caused out of
memory errors on
Lambda; we sub-
sequently moved
the combine tasks
to a r4.16xlarge
EC2 instance.
EC2 setup: Computing the k nearest neighbors is very mem-
ory intensive, so we use r5a.xlarge machines.

Figure 5: Tide runtime on EC2 for a uni-
form simulation using the default au-
toscaling policy (in 5min intervals).

6.2. Proteomics

Ripple setup: Tide frequently consumes more than the max
3GB offered by Lambda. Therefore, the ﬁrst step is splitting
the mzML input ﬁle into small chunks. We then run Tide
on each ﬁle. Afterwards, we combine the results in a single
output ﬁle. For all experiments, we used human FASTA ﬁles.
PyWren setup:
Tide is both CPU- and memory-
intensive, therefore we use Lambda for parallel phases, and a
t2.xlarge EC2 instance for serial computation.
EC2 setup: We again use t2.xlarge instances.

6.3. DNA Compression

Ripple setup: We ﬁrst use Ripple’s sort to sort the input so
that similar sequences are near each other, and subsequently
compress each data chunk.
PyWren setup: We again use Lambda for parallel phases,
and a t2.xlarge EC2 instance for serial computation.
EC2 setup: As before, we use t2.xlarge instances.

7. Evaluation

Below, we answer ﬁve questions, pertaining to the perfor-
mance, cost, fault tolerance, and scalability of Ripple, as well
as its ability to preserve the QoS requirements of diverse jobs.
• How able is Ripple’s provisioning system to preserve QoS

for incoming jobs (Sec. 7.1)?

• How robust is Ripple across job distributions (Sec. 7.2)?
• How does Ripple compare to PyWren (Sec. 7.3)?
• How does Ripple scale as job concurrency increases

(Sec. 7.4)?

7

CombinePivotSplitSplit......PivotPivotCombineCombineBED FILESSortSortCombineCombine......CombineCompressCompress050100150200VCPUsRunning JobsTotal JobsPending Jobs020004000600080001000012000Time (Seconds)0200overheads are always less than 4% of the job’s execution time.
Performance predictability: Fig. 6b shows the distribution
of execution time for 100 jobs of each application class with
Ripple’s provisioning mechanism, compared to (i) using the
default 1MB data chunk size, and (ii) always using the max-
imum number of Lambdas that AWS allows (1,000 for our
setting). Across all application classes Ripple achieves the
best performance, especially in the case of kNN classiﬁcation,
where resource demands are high, and incorrect provisioning
has a severe impact on execution time. More importantly,
performance with Ripple is highly predictable, despite the
framework not having control over where serverless functions
are physically placed on AWS. This is in part because Ripple
selects the number of Lambdas to be sufﬁcient to exploit the
job’s parallelism, but not high enough to cause long queue-
ing delays from AWS’s resource limit, and in part because
of Ripple’s straggler detection technique. Straggler respawn-
ing reduces variability by respawning the few tasks that are
underperforming due to interference or faulty data records.

In comparison, execution time for the 1MB and maxLamb-
das policies varies widely and experiences long tails, espe-
cially when using the maximum concurrency allowed. There
are two reasons for this. First, when using the default data
chunk size with very large input datasets, as is the case with
the examined applications, the number of total Lambdas that
need to execute exceeds the total allowed limit by a lot, lead-
ing to long queueing delays, as functions wait for resources
to become available. Even if AWS’s resource limit increased,
ﬁne-grained parallelism does not come for free, incurring over-
heads for work partitioning, synchronization, and combining
the per-function outputs. Second, when using the maximum
number of allowed Lambdas with large datasets, e.g., 500GB,
each function is still responsible for a large amount of data,
333MB in this case. Given the strict time limit Lambdas
have today, this causes several functions to time out and be
respawned by AWS. Note that this is not a case of a func-
tion becoming a straggler, and Ripple’s straggler respawning
technique would only increase the system load further by
respawning functions that will time out again.

Table 3 also shows the cost for each policy across applica-
tions. Ripple incurs the lowest cost, since it avoids excessive
task queueing and respawning. The maxLambdas policy has
the highest cost in the resource-intensive SpaceNet application
which results in many Lambdas timing out and needing to
rerun, while for the other two scenarios, the excessive number
of Lambdas used by the 1MB default split size policy incurs
the highest cost, since the increased number of Lambdas does
not also result in faster execution.

7.2. Workload Distributions

We now show Ripple’s elasticity under different job arrival
distributions, compared to Amazon EC2. We examine uniform,
bursty, and diurnal load patterns.

Figure 6: (a) Error between execution time estimated by SGD
in Ripple across the three applications, and measured execu-
tion time with the corresponding resource conﬁguration. (b)
Performance with Ripple compared to using the default 1MB
data chunks per Lambda, and the maximum number of Lamb-
das allowed, across the three applications.

Application

SpaceNet
Proteomics
DNA Compression

Cost

Ripple
$2.77
$0.42
$0.36

1MB Max Lambdas
$3.81
$0.61
$0.51

$4.61
$0.53
$0.42

Table 3: Cost across applications for (i) Ripple, (ii) the default
split size, and (iii) the max number of concurrent Lambdas.

• How does the fault tolerance mechanism in Ripple affect

application performance (Sec. 7.5)?

7.1. Automated Provisioning

Performance estimation accuracy: We ﬁrst examine Rip-
ple’s ability to correctly provision resources in a serverless
cluster. We assume that jobs from all three applications are
submitted, and for simplicity, each job is trying to maximize
its performance, instead of specifying a particular deadline. As
discussed in Section 3, Ripple will ﬁrst launch two short-lived
canary runs for each job, with different degrees of concurrency,
apply SGD to infer their performance with all other concur-
rency degrees, and determine the conﬁguration that minimizes
execution time for each new job. Fig. 6a shows the distribu-
tion of error between the performance estimated by Ripple
using Stochastic Gradient Descent (SGD) and the actual per-
formance measured on an AWS Lambda cluster when running
with the corresponding degree of concurrency. Errors are low
across all three applications, which allows Ripple to accurately
determine the number of Lambdas per execution phase that
will maximize an application’s performance. The higher errors
at the tails of the three violin plots correspond to the ﬁrst few
jobs that arrive, at which point Ripple’s knowledge of applica-
tion characteristics is limited, and the number of applications
in the SGD matrix is small. As more applications arrive in the
system, the estimation accuracy improves.

Proﬁling and inference with SGD incur some scheduling
overheads to each application. For the examined applications,
proﬁling overheads range from 260ms for jobs with 1-3 stages
to 6s for jobs with many stages, like the kNN classiﬁcation.
Inference overheads are less than 60ms in all cases. Aggregate

8

K-NNTideDNA Compr.0246810121416Inference Error (%)K-NNTideDNA Compr.051015202530354045Execution Time (min)RippleDefault (1MB)Max Lambdas(a) Ripple

(b) Amazon EC2

(a) Ripple

(b) EC2

Figure 7: Tide performance under uniform load, with 1 job per
10s. (a) and (b) show the total vCPUs used (green), and the
total (brown) and running jobs on the top (red). In the bottom,
we show the pending jobs waiting to run (yellow).

Figure 9: Tide performance under diurnal load. Over 30min,
we increased the jobs from 0 to 15 and back to 0.
(a) and
(b) show the used vCPUs (green), and the total (brown) and
running jobs (red). The bottom shows pending jobs (yellow).

(a) Ripple

(b) EC2

Figure 8: Tide performance under bursty load (1 job/min). Ev-
ery 90 min, a burst of 100 jobs arrives. (a) and (b) show the
used vCPUs (green), and the total (brown) and running jobs
(red). The bottom shows the pending jobs (yellow).

Uniform: In the case of the Tide proteomics framework, we
create a uniform workload by sending a new job every 10s for
an hour. Figure 7 shows that both for EC2 and Lambda, due to
the frequency of job arrivals, there is always at least a task run-
ning, with Ripple being able to immediately scale to meet the
resource demands. EC2 was able to handle the input load once
enough machines were launched, but as a result of the initial
adjustment period, it took an additional 6 minutes to ﬁnish
the entire scenario. With Ripple, the average job completion
time was 4.5× faster than EC2, 2min on average, whereas
the average job completion time for EC2 was approximately
8.5min. The cost for Lambda is also lower compared to EC2.
Similarly, DNA compression achieves 8× faster execution
with Ripple compared to EC2 under a uniform load (85s with
Ripple as opposed to 11min with EC2).

We also examine a uniform workload distribution for
SpaceNet, where we sent one job every 5 minutes for an hour.
Figure 10 shows the results for Ripple and EC2. Both Rip-
ple and EC2 were immediately able to handle new incoming
requests; however, due to the memory requirements of each
classiﬁcation job, the average job completion time for Ripple
was more than an order of magnitude faster (i.e., 80× faster)
at 4.5 minutes, with EC2 requiring approximately 6 hours to
complete an equal amount of work.

Bursty: We now initiate a Tide job every minute for 8 hours.

(a) Ripple

(b) EC2

Figure 10: SpaceNet performance under a uniform workload.
Over an hour, we send 1 job every 5min. Both graphs show
the vCPUs used by running jobs (green), as well as the total
number of jobs actively processed (red).

Every 90min, we additionally send a burst of 100 jobs to emu-
late a sudden load spike. Figure 8 shows that, while the burst is
happening, Ripple used almost 700 vCPUs for approximately
400 concurrent functions, which allowed it to immediately
handle all 100 jobs with no performance degradation for any
individual job. EC2, on the other hand, incurs the VM instanti-
ation overhead, and hence takes a long time to scale resources
to meet the requirements of all 100 jobs. The ﬁgure shows
that initially most jobs remained idle in the admission queue
as they are waiting for more instances to be spawned. After
the initial burst, EC2 did a better job at handling the burst;
however, this was mostly because the machines were not given
enough time to terminate during the non-bursty periods. Rip-
ple, on the other hand, was able to handle the bursts by rapidly
scaling up and down the number of active Lambdas, without
incurring high costs by retaining unused resources during peri-
ods of low load. As a result, the average job completion time
was 5× faster for Ripple at about 2min, compared to 10min
for EC2. The results are similar for DNA compression, with
Ripple achieving 8× faster execution compared to EC2.

Diurnal: Finally, we examine a diurnal job arrival distribution,
which emulates the load ﬂuctuation of many user-interactive
cloud applications [37, 56, 57, 60]. During a 30 minute interval
within a larger 4 hour period, we progressively increase the
number of arriving jobs, and then progressively decrease back
to zero new jobs. We repeat this pattern multiple times within

9

vCPUsRunning jobsTotal jobsPending jobs050100050010001500200025003000350040004500Time (Seconds)010005010001000200030004000Time (Seconds)0100vCPUsRunning jobsTotal jobsPending jobs020040060080010001200050001000015000200002500030000Time (Seconds)0100050100050001000015000200002500030000Time (Seconds)0100vCPUsRunning jobsTotal jobsPending jobs050100150200020004000600080001000012000Time (Seconds)0100050100150200020004000600080001000012000Time (Seconds)01000500100015002000250030003500Time (Seconds)04008001200160020002400280032003600VCPUsRunning Jobs050001000015000200002500030000Time (Seconds)0369121518(a) Cost Comparison

(b) vCPUs Comparison

Figure 11: Comparison between PyWren and Ripple for
SpaceNet: (a) shows the cumulative cost of Lambda for Rip-
ple and PyWren, as well as the cost of EC2 and overall cost
for PyWren; (b) shows a comparison of the number of vCPUs
used at each point in time by the two frameworks.

(a) 100 concurrent

(b) 1,000 concurrent

Figure 12: Performance of 100 versus 1,000 concurrent Tide
jobs. The graphs show a breakdown of the number of Lamb-
das actively used during each execution phase.

the 4 hour period. Figure 9 shows the diurnal results for Ripple
and EC2. The results show that the average job completion
time was 6.75× faster for Ripple at about 2 minutes, whereas
it was 13.5 minutes for EC2.

7.3. PyWren Comparison

We now use the SpaceNet application to compare Ripple and
PyWren. We send one SpaceNet job to each framework. To
allow for the increased compute and memory requirements
of SpaceNet, we perform this experiment in an AWS region
where the max function concurrency was 5,000 Lambdas. Fig-
ure 11 shows a comparison of the number of vCPUs and the
cumulative cost for each framework. The runtime for Ripple
was 25.7% faster at about 140 seconds, while the runtime for
PyWren was about 176 seconds. Part of the reason is that
Ripple can explicitly invoke the next stage of the pipeline,
whereas stages in PyWren have to wait for S3 results. For
SpaceNet, the maximum concurrency of a stage is 6,764 func-
tions. This meant PyWren had to launch almost 7K functions
simultaneously. Because Ripple provisions each execution
phase separately, it did not need 7K functions for every stage
of the pipeline, avoiding resource and cost inefﬁciencies. This
translates to a $2.77 cost for a single run for Ripple and $3.61,
for PyWren. The cost of the EC2 machine during this period
was $0.13. The rest of the cost difference was caused by the
difference in the runtime of individual serverless functions.

10

Figure 13: (a) CDF of Lambda completion time for 20 DNA com-
(b)
pression jobs, with and without Ripple’s fault tolerance.
Comparison between normal and re-spawned tasks by Ripple.

7.4. Job Concurrency

We now evaluate how well Ripple scales with the number of
concurrent jobs. Figure 12 shows the per-stage execution time
breakdown for 100 concurrent Tide jobs versus 1,000 jobs. 100
concurrent jobs do not generate enough Lambdas to reach the
function limit, while 1,000 concurrent jobs almost immediately
hit this limit. The ﬂuctuation in the number of active Lambdas
across phases for both concurrency levels is approximately
the same, despite the higher concurrency experiment reaching
the upper Lambda limit. The total runtime was about twice as
long for 1,000 concurrent jobs and, in general, used twice the
number of serverless functions.

7.5. Fault Tolerance

We now quantify the effectiveness of Ripple’s fault tolerance
mechanism. We run 20 DNA compression jobs in parallel, and
force a 10% failure probability on each task. In the case of Rip-
ple, under-performing tasks, i.e., tasks not making sufﬁcient
progress are proactively re-spawned to avoid performance
degradation. Figure 13 shows the impact of the fault toler-
ance mechanism on execution time, compared to the baseline
AWS system. When no fault tolerance is used, only 4 jobs
complete successfully without their Lambdas reaching the 5
minute timeout limit, and being terminated. Instead, when
Ripple proactively detects and re-spawns stragglers, all jobs
complete within AWS Lambda’s time limit, as seen in the CDF
of Fig. 13a. Fig. 13b shows the tasks that had to be re-spawned
by Ripple to avoid degrading the overall job’s execution time.

8. Related Work

8.1. Programming Frameworks for Serverless

The past few years a number of programming frameworks
for serverless have been designed that either target speciﬁc
applications, or focus on generality.

PyWren: PyWren targets general-purpose computation,
and offers a simple programming framework in Python that
evaluates the viability of serverless for distributed computing
applications [49]. The authors show that embarrassingly paral-
lel workﬂows, such as computational imaging, solar physics,
and object recognition, can be implemented in a straightfor-
ward way using AWS Lambda. PyWren divides computa-

0255075100125150175Runtime (Seconds)01234567Cumulative Cost ($)RipplePyWren (Lambda)PyWren (EC2)PyWren (Total)0255075100125150175Runtime (Seconds)01000200030004000500060007000VCPUsRipplePyWrention into map and reduce phases, similar to the MapReduce
model [29], with mappers using Lambdas to run in parallel,
while reducers rely on long-running EC2 instances for serial
computation. Locus [64] extends PyWren, and uses a mixture
of S3 and Redis to scale sorting on Lambda.

PyWren highlights the potential of serverless for jobs with
a single parallel phase and computationally-expensive serial
phases, such as reduce, which can run on a long-running EC2
instance. Unfortunately the fact that PyWren still relies on
long-running instances for serial execution phases reduces
the performance and cost beneﬁts of serverless. Addition-
ally, since PyWren uses both serverless and EC2 for the job’s
workﬂow, cloud maintenance remains complicated for users
who must manage both serverless and on-demand resources.
Finally, since PyWren provisions Lambdas for the entire job
once, it cannot adjust to the different degrees of parallelism
different computation phases often have, hurting resource efﬁ-
ciency, and limiting the complexity of supported tasks.

EMR Cluster: EMR Cluster dynamically adjusts the size
of a cluster depending on a user’s resource needs [9]. Spark
can run on top of EMR Cluster, and users are charged on a
per-second granularity. However, it can take several minutes
to launch a new machine in an EMR Cluster, unlike serverless,
where functions are initialized in under a second.

mu: mu is a serverless framework targeting a speciﬁc class
of applications, namely video processing, and is used by the
ExCamera video encoding service [43]. mu uses AWS Lambda
for both map and reduce tasks, each framed as a short-lived
In addition to AWS Lambda, mu requires a long-
worker.
lived EC2 server for the Coordinator, and another long-lived
EC2 server to act as the Rendezvous Server. The Coordinator
assigns tasks to workers and tracks application state, and the
Rendezvous Server passes messages between workers.

GG: gg is a serverless framework where dependencies
between tasks, such as distributed compilation, are explic-
itly known in advance. Similar to mu, gg exploits serverless
to parallelize interdependent tasks [41], showing signiﬁcant
speedups for computation with irregular dependencies, such as
software compilation. However, gg requires the dependency
tree for a task to be pre-computed, making it impractical for
cases where job dependencies are not known in advance, or
when dependencies depend on the input.

SAND: SAND is a framework designed to simplify inter-
actions between serverless functions [18]. Currently, public
clouds do not provide a way for the user to express how func-
tions interact with each other, optimizing instead for individual
function execution. SAND co-locates functions from the same
pipeline on the same physical machine, and reuses the same
containers for a pipeline’s functions. While beneﬁcial for per-
formance and resource utilization, SAND assumes full cluster
control to enforce function placement to machines, which is
not possible in public cloud providers.

Pocket: The short execution times of Lambda functions

require fast communication between functions and storage.
Like Locus, Pocket addresses this by dynamically scaling
storage to meet a given performance and cost constraint [52,
53]. Pocket relies on user-provided hints on the performance
criticality of different jobs, their storage requirements, and
their provisioning needs in terms of Lambda functions.

While all these frameworks highlight the increasing im-
portance of developing systems for serverless compute, they
currently do not provide the automated resource provisioning,
scheduling, and fault tolerance mechanisms cloud applications
need to meet their QoS requirements.

8.2. Dataﬂow Frameworks

Dataﬂow frameworks have been an active area of research
in both academic and industrial settings for over 15 years,
particularly in the context of analytics and ML applications.

Analytics Frameworks: MapReduce [29] innovated using
parallel, stateless dataﬂow computation for large analytics
jobs, while Spark [2] focused on improving the performance
and fault tolerance of interactive and iterative jobs by adding
in-memory caching to persist state across computation phases.
DryadLINQ [71] is another example of a framework that pro-
vided abstractions on top of a MapReduce-like system, en-
abling developers to write high-level programs, which the
system transparently compiles into distributed computation.

ML Frameworks: GraphLab [58] and Naiad [62] are both
programming frameworks optimized for ML applications. Dis-
tBelief [28], TensorFlow [16], and MXNet [26] provide similar
capabilities, focusing on deep neural networks. All three pro-
vide higher-level APIs for deﬁning dataﬂows which consist
of stateless, independent workers and stateful servers for shar-
ing global parameters. TensorFlow’s dataﬂow graph is static;
unlike Ripple, it cannot handle dynamically-generated compu-
tation graphs. Ray [61] enables dynamic graphs, but its design
is speciﬁc to reinforcement learning pipelines, while Ripple
targets general parallel computation.

9. Conclusion

We presented Ripple, a high-level declarative programming
framework for serverless compute. Ripple allows users to
express the dataﬂow of complex pipelines at a high-level, and
handles work and data partitioning, task scheduling, fault tol-
erance, and provisioning automatically, abstracting a lot of
the low-level system complexity from the user. We port three
large ML, genomics, and proteomics applications to Ripple,
and show signiﬁcant performance beneﬁts compared to tradi-
tional cloud deployments. We also show that Ripple is able to
accurately determine the degree of concurrency needed for an
application to meet its performance requirements, and further
improves performance predictability by detecting straggler
tasks eagerly and respawning them. Finally, we showed that
Ripple is robust across different job arrival distributions and
different degrees of concurrency, and implements a number

11

of scheduling policies, including round-robin, priorities, and
deadline-based scheduling.

Code Availability

Ripple is open-source software under a GPL license (https:
//github.com/delimitrou/Ripple), and is already in use
by several research groups.

Acknowledgements

We sincerely thank Robbert van Renesse, Zhiming Shen,
Shuang Chen, Yanqi Zhang, Yu Gan, and Neeraj Kulkarni
for their feedback on earlier versions of this manuscript. This
work was partially supported by NSF grant CNS-1704742,
NSF grant CNS-1422088, a Facebook Faculty Research
Award, a VMWare Research Award, a John and Norma Balen
Sesquicentennial Faculty Fellowship, and generous donations
from GCE, Azure, and AWS.

References

[1] Apache openwhisk. https://openwhisk.apache.org.
[2] Apache spark. https://spark.apache.org/.
[3] Aws autoscale. https://aws.amazon.com/autoscaling/.
[4] Aws lambda. https://aws.amazon.com/lambda/.
[5] Aws step functions. https://aws.amazon.com/step-functions.
[6] bedmethyl. https://www.encodeproject.org/wgbs#outputs.
[7] Boto 3. https://boto3.amazonaws.com.
[8] Docker. https://www.docker.com/.
[9] Emr cluster. https://aws.amazon.com/emr/.
[10] Google

https://cloud.google.com/

functions.

cloud

functions/.

[11] Microsoft azure functions.

https://azure.microsoft.com/

en-us/services/functions/.
[12] Numpy. http://www.numpy.org/.
[13] scikit-learn. https://scikit-learn.org/.
[14] An introduction to kernel and nearest-neighbor nonparametric regres-

sion. The American Statistician, 1992.

[15] Spacenet on amazon web services (aws). The SpaceNet Catalog, 2018.
[16] Martín Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy
Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Geoffrey Irv-
ing, Michael Isard, Manjunath Kudlur, Josh Levenberg, Rajat Monga,
Sherry Moore, Derek G. Murray, Benoit Steiner, Paul Tucker, Vijay Va-
sudevan, Pete Warden, Martin Wicke, Yuan Yu, and Xiaoqiang Zheng.
Tensorﬂow: A system for large-scale machine learning. In Proceedings
of the 12th USENIX Conference on Operating Systems Design and
Implementation, OSDI’16, pages 265–283, Berkeley, CA, USA, 2016.
USENIX Association.

[17] Faraz Ahmad, Srimat T. Chakradhar, Anand Raghunathan, and T. N.
Vijaykumar. Tarazu: optimizing mapreduce on heterogeneous clusters.
In Proceedings of the International Conference on Architectural Sup-
port for Programming Languages and Operating Systems (ASPLOS).
London, UK, 2012.

[18] Istemi Ekin Akkus, Ruichuan Chen, Ivica Rimac, Manuel Stein, Klaus
Satzke, Andre Beck, Paarijaat Aditya, and Volker Hilt. Sand: To-
wards high performance serverless computing. 2018 USENIX Annual
Technical Conference (USENIX ATC’18), 2018.

[19] Ganesh Ananthanarayanan, Ali Ghodsi, Scott Shenker, and Ion Stoica.
Effective straggler mitigation: Attack of the clones. In Proceedings of
the USENIX Symposium on Networked Systems Design and Implemen-
tation (NSDI). Lombard, IL, 2013.

[20] Ganesh Ananthanarayanan, Srikanth Kandula, Albert Greenberg, Ion
Stoica, Yi Lu, Bikas Saha, and Edward Harris. Reining in the outliers
in map-reduce clusters using mantri. In Proceedings of the 9th USENIX
conference on Operating Systems Design and Implementation (OSDI).
Vancouver, CA, 2010.

[21] Aman Bakshi and Yogesh B. Dujodwala. Securing cloud from ddos
attacks using intrusion detection system in virtual machine. In Proc. of
the Second International Conference on Communication Software and
Networks (ICCSN). 2010.

12

[22] Luiz Barroso. Warehouse-scale computing: Entering the teenage

decade. ISCA Keynote, SJ, June 2011.

[23] Luiz Barroso and Urs Hoelzle. The Datacenter as a Computer: An In-
troduction to the Design of Warehouse-Scale Machines. MC Publishers,
2009.

[24] WS Noble BJ Diament. Faster sequest searching for peptide identiﬁ-
cation from tandem mass spectra. In Journal of Proteome Research,
2011.

[25] Matthew C Chambers, Brendan Maclean, Robert Burke, Dario Amodei,
Daniel L Ruderman, Steffen Neumann, Laurent Gatto, Bernd Fischer,
Brian Pratt, Jarrett Egertson, Katherine Hoff, Darren Kessner, Na-
talie Tasman, Nicholas Shulman, Barbara Frewen, Tahmina A Baker,
Mi-Youn Brusniak, Christopher Paulse, David Creasy, Lisa Flashner,
Kian Kani, Chris Moulding, Sean L Seymour, Lydia M Nuwaysir,
Brent Lefebvre, Frank Kuhlmann, Joe Roark, Paape Rainer, Suckau
Detlev, Tina Hemenway, Andreas Huhmer, James Langridge, Brian
Connolly, Trey Chadick, Krisztina Holly, Josh Eckels, Eric W Deutsch,
Robert L Moritz, Jonathan E Katz, David B Agus, Michael MacCoss,
David L Tabb, and Parag Mallick. A cross-platform toolkit for mass
spectrometry and proteomics. Nature Biotechnology, 2012.

[26] Tianqi Chen, Mu Li, Yutian Li, Min Lin, Naiyan Wang, Minjie Wang,
Tianjun Xiao, Bing Xu, Chiyuan Zhang, and Zheng Zhang. Mxnet:
A ﬂexible and efﬁcient machine learning library for heterogeneous
distributed systems. CoRR, abs/1512.01274, 2015.

[27] Charles E. Cook, Mary Todd Bergman, Robert D. Finn, Guy Cochrane,
Ewan Birney, and Rolf Apweiler. The european bioinformatics institute
in 2016: Data growth and integration. Nucleic Acids Research, 2016.
[28] Jeffrey Dean, Greg S. Corrado, Rajat Monga, Kai Chen, Matthieu
Devin, Quoc V. Le, Mark Z. Mao, Marc’Aurelio Ranzato, Andrew Se-
nior, Paul Tucker, Ke Yang, and Andrew Y. Ng. Large scale distributed
deep networks. In Proceedings of the 25th International Conference
on Neural Information Processing Systems - Volume 1, NIPS’12, pages
1223–1231, USA, 2012. Curran Associates Inc.

[29] Jeffrey Dean and Sanjay Ghemawat. Mapreduce: simpliﬁed data
processing on large clusters. In Proceedings of the Symposium on
Operating Systems Design and Implementation (OSDI), pages 137–
150. San Francisco, CA, December 2004.

[30] Christina Delimitrou and Christos Kozyrakis. Paragon: QoS-Aware
In Proceedings of the
Scheduling for Heterogeneous Datacenters.
Eighteenth International Conference on Architectural Support for Pro-
gramming Languages and Operating Systems (ASPLOS). Houston, TX,
USA, 2013.

[31] Christina Delimitrou and Christos Kozyrakis. QoS-Aware Scheduling
in Heterogeneous Datacenters with Paragon. In ACM Transactions on
Computer Systems (TOCS), Vol. 31 Issue 4. December 2013.

[32] Christina Delimitrou and Christos Kozyrakis. Quality-of-Service-
Aware Scheduling in Heterogeneous Datacenters with Paragon. In
IEEE Micro Special Issue on Top Picks from the Computer Architec-
ture Conferences. May/June 2014.

[33] Christina Delimitrou and Christos Kozyrakis. Quasar: Resource-
In Proceedings of
Efﬁcient and QoS-Aware Cluster Management.
the Nineteenth International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS). Salt Lake
City, UT, USA, 2014.

[34] Christina Delimitrou and Christos Kozyrakis. HCloud: Resource-
Efﬁcient Provisioning in Shared Cloud Systems. In Proceedings of
the Twenty First International Conference on Architectural Support
for Programming Languages and Operating Systems (ASPLOS), April
2016.

[35] Christina Delimitrou and Christos Kozyrakis. Bolt: I Know What
You Did Last Summer... In The Cloud. In Proc. of the Twenty Second
International Conference on Architectural Support for Programming
Languages and Operating Systems (ASPLOS), 2017.

[36] Christina Delimitrou, Daniel Sanchez, and Christos Kozyrakis. Tarcil:
Reconciling Scheduling Speed and Quality in Large Shared Clusters.
In Proceedings of the Sixth ACM Symposium on Cloud Computing
(SOCC), August 2015.

[37] Christina Delimitrou, Sriram Sankar, Aman Kansal, and Christos
Kozyrakis. ECHO: Recreating Network Trafﬁc Maps for Datacen-
ters of Tens of Thousands of Servers. In Proceedings of the IEEE
International Symposium on Workload Characterization (IISWC). San
Diego, CA, USA, 2012.

[38] Lipman DJ and Pearson WR. Rapid and sensitive protein similarity

searches. Science, 1985.

[39] JK Eng, AL McCormack, and JR Yates. An approach to correlate
tandem mass spectral data of peptides with amino acid sequences
in a protein database. In Journal of the American Society for Mass
Spectrometry, 1994.

[40] Sadjad Fouladi, John Emmons, Emre Orbay, Catherine Wu, Riad S.
Wahby, and Keith Winstein. Salsify: Low-latency network video
through tighter integration between a video codec and a transport
protocol. In 15th USENIX Symposium on Networked Systems Design
and Implementation (NSDI 18), pages 267–282, Renton, WA, April
2018. USENIX Association.

[41] Sadjad Fouladi, Dan Iter, Shuvo Chatterjee, Christos Kozyrakis Matei
Zaharia, and Keith Winstein. A thunk to remember: make-j1000 (and
other jobs) on functions-as-a-service infrastructure. 2017.

[42] Sadjad Fouladi, Francisco Romero, Dan Iter, Qian Li, Shuvo Chat-
terjee, Christos Kozyrakis, Matei Zaharia, and Keith Winstein. From
laptop to lambda: Outsourcing everyday jobs to thousands of transient
functional containers. In 2019 USENIX Annual Technical Conference
(USENIX ATC 19), pages 475–488, Renton, WA, July 2019. USENIX
Association.

[43] Sadjad Fouladi, Riad S. Wahby, Brennan Shacklett, Karthikeyan Vasuki
Balasubramaniam, William Zeng, Rahul Bhalerao, Anirudh Sivara-
man, George Porter, and Keith Winstein. Encoding, fast and slow:
Low-latency video processing using thousands of tiny threads. In 14th
USENIX Symposium on Networked Systems Design and Implementa-
tion (NSDI 17), pages 363–376, Boston, MA, March 2017. USENIX
Association.

[44] Yu Gan, Yanqi Zhang, Dailun Cheng, Ankitha Shetty, Priyal Rathi,
Nayantara Katarki, Ariana Bruno, Justin Hu, Brian Ritchken, Bren-
don Jackson, Kelvin Hu, Meghna Pancholi, Brett Clancy, Chris Colen,
Fukang Wen, Catherine Leung, Siyuan Wang, Leon Zaruvinsky, Ma-
teo Espinosa, Yuan He, and Christina Delimitrou. An Open-Source
Benchmark Suite for Microservices and Their Hardware-Software Im-
plications for Cloud and Edge Systems. In Proceedings of the Twenty
Fourth International Conference on Architectural Support for Program-
ming Languages and Operating Systems (ASPLOS), April 2019.
[45] Yu Gan, Yanqi Zhang, Kelvin Hu, Yuan He, Meghna Pancholi, Dailun
Cheng, and Christina Delimitrou. Seer: Leveraging Big Data to Nav-
igate the Complexity of Performance Debugging in Cloud Microser-
vices. In Proceedings of the Twenty Fourth International Conference
on Architectural Support for Programming Languages and Operating
Systems (ASPLOS), April 2019.

[46] Rohan Gandhi and Amit Sabne. Finding stragglers in hadoop. In

Technical Report. 2011.

[47] Stuart Geman and Donald Geman. Stochastic relaxation, gibbs distri-
butions, and the bayesian restoration of images. IEEE Trans. Pattern
Anal. Mach. Intell., 6(6):721–741, November 1984.

[48] Scott Hendrickson, Stephen Sturdevant, Tyler Harter, Venkateshwaran
Venkataramani, Andrea C. Arpaci-Dusseau, and Remzi H. Arpaci-
Dusseau. Serverless computation with openlambda. 8th USENIX
Workshop on Hot Topics in Cloud Computing (HotCloud 16), 2016.

[49] Eric Jonas, Shivaram Venkataraman, Ion Stoica, and Benjamin Recht.
Occupy the cloud: Distributed computing for the 99%. CoRR,
abs/1702.04024, 2017.

[50] L Kall, JD Canterbury, WS Noble J Weston, and MJ MacCoss. Semi-
supervised learning for peptide identiﬁcation from shotgun proteomics
datasets. 2007.

[51] Ana Klimovic, Heiner Litz, and Christos Kozyrakis. Selecta: Het-
erogeneous cloud storage conﬁguration for data analytics. In 2018
USENIX Annual Technical Conference (USENIX ATC 18), pages 759–
773, Boston, MA, July 2018. USENIX Association.

[52] Ana Klimovic, Yawen Wang, Christos Kozyrakis, Patrick Stuedi, Jonas
Pfefferle, and Animesh Trivedi. Pocket: Emphemeral storage for
serverless analytics. USENIX ATC, 2018.

[53] Ana Klimovic, Yawen Wang, Christos Kozyrakis, Patrick Stuedi, Ani-
mesh Trivedi, and Jonas Pfefferle. Pocket: Ephemeral storage for
serverless analytics. October 2018.

[54] Christos Kozyrakis, Aman Kansal, Sriram Sankar, and Kushagra Vaid.
Server engineering insights for large-scale online services. IEEE Micro,
30(4):8–19, July 2010.

[55] Jimmy Lin. The curse of zipf and limits to parallelization: A look
at the stragglers problem in mapreduce. In Proceedings of LSDS-IR
Workshop. Boston, MA, 2009.

[56] David Lo, Liqun Cheng, Rama Govindaraju, Luiz André Barroso, and
Christos Kozyrakis. Towards energy proportionality for large-scale
latency-critical workloads. In Proceedings of the 41st Annual Inter-
national Symposium on Computer Architecuture (ISCA). Minneapolis,
MN, 2014.

[57] David Lo, Liqun Cheng, Rama Govindaraju, Parthasarathy Ran-
ganathan, and Christos Kozyrakis. Heracles: Improving resource
efﬁciency at scale. In Proc. of the 42Nd Annual International Sympo-
sium on Computer Architecture (ISCA). Portland, OR, 2015.

[58] Yucheng Low, Joseph Gonzalez, Aapo Kyrola, Danny Bickson, Carlos
Guestrin, and Joseph M. Hellerstein. Graphlab: A new framework for
parallel machine learning. CoRR, abs/1006.4990, 2010.

13

[59] Lennart Martens, Matthew Chambers, Marc Sturm, Darren Kessner,
Fredrik Levander, Jim Shofstahl, Wilfred H. Tang, Andreas Rompp,
Steffen Neumann, Angel D. Pizarro, Luisa Montecchi-Palazzi, Natalie
Tasman, Mike Coleman, Florian Reisinger, Puneet Souda, Henning
Hermjakob, Pierre-Alain Binz, and Eric W. Deutsch. mzml - a commu-
nity standard for mass spectrometry data. In Molecular and Cellular
Proteomics, 2010.

[60] David Meisner, Christopher M. Sadler, Luiz André Barroso, Wolf-
Dietrich Weber, and Thomas F. Wenisch. Power management of online
data-intensive services. In Proceedings of the 38th annual international
symposium on Computer architecture, pages 319–330, 2011.

[61] Philipp Moritz, Robert Nishihara, Stephanie Wang, Alexey Tumanov,
Richard Liaw, Eric Liang, Melih Elibol, Zongheng Yang, William Paul,
Michael I. Jordan, and Ion Stoica. Ray: A distributed framework for
emerging ai applications. In Proceedings of the 12th USENIX Con-
ference on Operating Systems Design and Implementation, OSDI’18,
pages 561–577, Berkeley, CA, USA, 2018. USENIX Association.
[62] Derek G. Murray, Frank McSherry, Rebecca Isaacs, Michael Isard,
Paul Barham, and Martín Abadi. Naiad: A timely dataﬂow system.
In Proceedings of the Twenty-Fourth ACM Symposium on Operating
Systems Principles, SOSP ’13, pages 439–455, New York, NY, USA,
2013. ACM.

[63] Jianhao Peng, Olgica Milenkovic, and Idoia Ochoa. Methcomp: a
special purpose compression platform for dna methylation data. Bioin-
formatics, 34(15):2654–2656, 2018.

[64] Shivaram Venkataraman Qifan Pu and Ion Stoica. Shufﬂing, fast and
slow: Scalable analytics on serverless infrastructure. NSDI, 2019.
[65] Benjamin Recht, Christopher Re, Stephen Wright, and Feng Niu. Hog-
wild: A lock-free approach to parallelizing stochastic gradient descent.
In J. Shawe-Taylor, R. S. Zemel, P. L. Bartlett, F. Pereira, and K. Q.
Weinberger, editors, Advances in Neural Information Processing Sys-
tems 24, pages 693–701. Curran Associates, Inc., 2011.

[66] Charles Reiss, Alexey Tumanov, Gregory Ganger, Randy Katz, and
Michael Kozych. Heterogeneity and dynamicity of clouds at scale:
Google trace analysis. In Proceedings of SOCC. 2012.

[67] Thomas Ristenpart, Eran Tromer, Hovav Shacham, and Stefan Savage.
Hey, you, get off of my cloud: Exploring information leakage in third-
party compute clouds. In Proc. of the ACM Conference on Computer
and Communications Security (CCS). Chicago, IL, 2009.

[68] Konstantin Shvachko, Hairong Kuang, and Sanjay Radia. The hadoop

distributed ﬁle system. 2010.

[69] Anand Srinivasan and Sanjoy Baruah. Deadline-based scheduling of
periodic task systems on multiprocessors. Inf. Process. Lett., 84(2):93–
98, October 2002.

[70] Zachary D. Stephens, Skylar Y. Lee, Faraz Faghri, Roy H. Campbell,
Chengxiang Zhai, Miles J. Efron, Ravishankar Iyer, Michael C. Schatz,
Saurabh Sinha, and Gene E. Robinson. Big data: Astronomical or
genomical? PLoS Biol, 2015.

[71] Yuan Yu, Michael Isard, Dennis Fetterly, Mihai Budiu, Úlfar Erlings-
son, Pradeep Kumar Gunda, and Jon Currey. Dryadlinq: A system for
general-purpose distributed data-parallel computing using a high-level
language. In Proceedings of the 8th USENIX Conference on Operating
Systems Design and Implementation, OSDI’08, pages 1–14, Berkeley,
CA, USA, 2008. USENIX Association.

[72] Matei Zaharia, Dhruba Borthakur, Joydeep Sen Sarma, Khaled Elmele-
egy, Scott Shenker, and Ion Stoica. Delay scheduling: a simple tech-
nique for achieving locality and fairness in cluster scheduling.
In
Proceedings of the European conference on Computer systems (Eu-
roSys). Paris, France, 2010.

[73] Matei Zaharia, Andy Konwinski, Anthony Joseph, Randy Katz, and
Ion Stoica. Improving mapreduce performance in heterogeneous envi-
ronments. In Proceedings of the 8th USENIX Symposium on Operating
Systems Design and Implementation (OSDI). San Diego, CA, 2008.

[74] Yinqian Zhang, Ari Juels, Alina Oprea, and Michael K. Reiter. Home-
alone: Co-residency detection in the cloud via side-channel analysis.
In Proc. of the IEEE Symposium on Security and Privacy. Oakland,
CA, 2011.

[75] Yinqian Zhang, Ari Juels, Michael K. Reiter, and Thomas Ristenpart.
Cross-tenant side-channel attacks in paas clouds. In Proc. of the ACM
SIGSAC Conference on Computer and Communications Security (CCS).
Scottsdale, AZ, 2014.

[76] Yinqian Zhang, Ari Juels, Michael K. Reiter, and Thomas Ristenpart.
Cross-vm side channels and their use to extract private keys. In Pro-
ceedings of the ACM Conference on Computer and Communications
Security (CCS). Raleigh, NC, 2012.

