1
2
0
2

g
u
A
4
2

]

G
L
.
s
c
[

1
v
8
2
6
2
0
.
9
0
1
2
:
v
i
X
r
a

2LM-M LLR polymer v23: September 7, 2021

1

A Method for Inferring Polymers Based on Linear
Regression and Integer Programming

Ryota Ido1, Shengjuan Cao1, Jianshen Zhu1, Naveed Ahmed Azam1, Kazuya Haraguchi1, Liang
Zhao2, Hiroshi Nagamochi1 and Tatsuya Akutsu3

1Department of Applied Mathematics and Physics, Kyoto University, Kyoto 606-8501, Japan
2Graduate School of Advanced Integrated Studies in Human Survavibility (Shishu-Kan), Kyoto University,
Kyoto 606-8306, Japan
3Bioinformatics Center, Institute for Chemical Research, Kyoto University, Uji 611-0011, Japan

Abstract
A novel framework has recently been proposed for designing the molecular structure of
chemical compounds with a desired chemical property using both artiﬁcial neural net-
works and mixed integer linear programming. In this paper, we design a new method
for inferring a polymer based on the framework. For this, we introduce a new way of
representing a polymer as a form of monomer and deﬁne new descriptors that feature
the structure of polymers. We also use linear regression as a building block of con-
structing a prediction function in the framework. The results of our computational
experiments reveal a set of chemical properties on polymers to which a prediction
function constructed with linear regression performs well. We also observe that the
proposed method can infer polymers with up to 50 non-hydrogen atoms in a monomer
form.

Keywords: Machine Learning, Linear Regression, Integer Programming, Polymers,
Cheminformatics, Materials Informatics, QSAR/QSPR, Molecular Design.

1

Introduction

Background In recent years, molecular design has received a great deal of attention from various
research ﬁelds such as chemoinformatics, bioinformatics, and materials informatics [1, 2, 3]. In
particular, extensive studies have been done for molecular design using artiﬁcial neural networks
(ANNs). Various ANN models have been applied in these studies, which include recurrent neural
networks [4, 5], variational autoencoders [6], grammar variational autoencoders [7], generative
adversarial networks [8, 9], and invertible ﬂow models [10, 11]. Many of these studies employ
graph convolution techniques [12] to eﬀectively handle molecules represented as chemical graphs.
Molecular design has also been studied for many years in chemoinformatics, under the name of
inverse quantitative structure activity relationship (inverse QSAR). The purpose of this framework
is to seek for chemical structures having desired chemical activities under some constraints, where
the task of prediction of chemical activities from their chemical structures is referred to as QSAR
(or, forward QSAR). In both forward and inverse QSAR, chemical structures are represented as
undirected graphs (chemical graphs). Then, chemical graphs are transformed into vectors of real or
integer numbers, which are called descriptors in chemoinformatics and vectors correspond to feature
vectors in machine learning. One of the typical approaches to inverse QSAR is to infer feature

 
 
 
 
 
 
2LM-M LLR polymer v23: September 7, 2021

2

vectors from given chemical activities and constraints and then reconstruct chemical graphs from
these feature vectors [13, 14, 15]. However, the reconstruction itself is a challenging task because
it is known to be NP-hard (i.e., theoretically intractable) [16]. Such a diﬃculty is also suggested
from a huge size of chemical graph space. For example, the number of chemical graphs with up
to 30 atoms (vertices) C, N, O, and S may exceed 1060 [17]. Due to this inherent diﬃculty, most
methods for inverse QSAR, including recent ANN-based ones, do not guarantee optimal or exact
solutions.

The targets of most of the inverse QSAR methods and ANN-based molecular design meth-
ods had been small chemical compounds. On the other hand, it is known that macromolecules,
especially polymers, have also a wide range of applications in both medical science and material
science [18, 19]. Accordingly, several studies have recently been done on computational design of
polymers [20, 21]. However, it was pointed out that very few studies addressed the representation
of polymer structures [22], and thus the development of novel and useful representation methods
for polymers remains a challenge.

G : class of chemical

  graphs

Stage 1

Stage 5

Stage 2

f : feature 
    function 

  1
*
  2
*

.
.
.

   (cid:842)

f(   *)
i

.
.
.

(cid:842)
f(    )

a: property 
    function 

 RK

x:=f(  )

(cid:66)

(cid:66)
(cid:66)
y*<h(x*)<y*
(cid:66)
x* 

Stage 3
h: prediction 
        function 

R
a(  )
h(x)
(cid:66)
y*,y*
(cid:66)

 input

ANN 

N

Stage 4

s: topological
  specification

   (cid:842)
g  :
(cid:66)
(cid:66)
(cid:66)
no    *    G s.t.  y*<h(f(   *))<y*
(cid:66)

   (cid:842)

x*

deliver

detect

output

C1:

C2:

function

h  
function f
graph constraints

MILP

M(g,x,y;C1,C2)

M(x,y;C1)

M(g,x;C2)

Figure 1: An illustration of a framework for inferring a set of chemical graphs C∗.

Framework Akutsu and Nagamochi [23] proved that the computation process of a given ANN can
be simulated with a mixed integer linear programming (MILP). Based on this, a novel framework
for inferring chemical graphs has been developed and revised [24, 25, 26], as illustrated in Figure 1.
It constructs a prediction function in the ﬁrst phase and infers a chemical graph in the second
phase. The ﬁrst phase of the framework consists of three stages. In Stage 1, we choose a chemical
property π and a class G of graphs, where a property function a is deﬁned so that a(C) is the value
of π for a compound C ∈ G, and collect a data set Dπ of chemical graphs in G such that a(C) is
available for every C ∈ Dπ. In Stage 2, we introduce a feature function f : G → RK for a positive
integer K. In Stage 3, we construct a prediction function η with an ANN N that, given a vector
x ∈ RK, returns a value y = η(x) ∈ R so that η(f (C)) serves as a predicted value to the real value
a(C) of π for each C ∈ Dπ. Given two reals y∗ and y∗ as an interval for a target chemical value,
the second phase infers chemical graphs C∗ with y∗ ≤ η(f (C∗)) ≤ y∗ in the next two stages. We
have obtained a feature function f and a prediction function η and call an additional constraint

 
2LM-M LLR polymer v23: September 7, 2021

3

on the substructures of target chemical graphs a topological speciﬁcation. In Stage 4, we prepare
the following two MILP formulations:

- MILP M(x, y; C1) with a set C1 of linear constraints on variables x and y (and some other

auxiliary variables) simulates the process of computing y := η(x) from a vector x; and

- MILP M(g, x; C2) with a set C2 of linear constraints on variable x and a variable vector g that
represents a chemical graph C (and some other auxiliary variables) simulates the process of
computing x := f (C) from a chemical graph C and chooses a chemical graph C that satisﬁes
the given topological speciﬁcation σ.

Given an interval with y∗, y∗ ∈ R, we solve the combined MILP M(g, x, y; C1, C2) to ﬁnd a feature
vector x∗ ∈ RK and a chemical graph C† with the speciﬁcation σ such that f (C†) = x∗ and
y∗ ≤ η(x∗) ≤ y∗ (where if the MILP instance is infeasible then this suggests that there does not
exist such a desired chemical graph). In Stage 5, we generate other chemical graphs C∗ such that
y∗ ≤ η(f (C∗)) ≤ y∗ based on the output chemical graph C†.

MILP formulations required in Stage 4 have been designed for chemical compounds with cycle
index 0 (i.e., acyclic) [25, 27], cycle index 1 [28] and cycle index 2 [29], where no sophisticated
topological speciﬁcation was available yet. Azam et al. [27] introduced a restricted class of acyclic
graphs that is characterized by an integer ρ, called a “branch-parameter” such that the restricted
class still covers most of the acyclic chemical compounds in the database. Akutsu and Nag-
amochi [30] extended the idea to deﬁne a restricted class of cyclic graphs, called “ρ-lean cyclic
graphs” and introduced a set of ﬂexible rules for describing a topological speciﬁcation. Recently,
Tanaka et al. [31] (resp., Zhu et al. [26]) used a decision tree (resp., linear regression) to construct a
prediction function η in Stage 3 in the framework and derived an MILP M(x, y; C1) that simulates
the computation process of a decision tree (resp., linear regression).

Two-layered Model Shi et al. [32] proposed a method, called a two-layered model for representing
the feature of a chemical graph in order to deal with an arbitrary graph in the framework. In the
two-layered model, a chemical graph C with a parameter ρ ≥ 1 is regarded as two parts: the
exterior and the interior of the hydrogen-suppressed chemical graph hCi obtained from C by
removing hydrogen. The exterior consists of maximal acyclic induced subgraphs with height at
most ρ in hCi and the interior is the connected subgraph of hCi obtained by ignoring the exterior.
Shi et al. [32] deﬁned a feature vector f (C) of a chemical graph C to be a combination of the
frequency of adjacent atom pairs in the interior and the frequency of chemical acyclic graphs among
the set of chemical rooted trees Tu rooted at interior-vertices u. Tanaka et al. [31] constructed a
prediction function with a decision tree by using the feature vector by Shi et al. [32]. Recently,
Zhu et al. [26] extended the model to treat chemical elements of multiple valence and chemical
compounds with cations and anions.

Contribution In order to extend our MILP-based framework for designing novel polymers, we
modify the method due to Zhu et al. [26]. For this, we introduce a new way of representing a
polymer as a form of monomer and deﬁne new descriptors that feature the structure of polymers.
We modify the MILP formulation proposed by Zhu et al. [26] due to the change of feature function
f (the detail of the MILP M(g, x; C2) can be found in Appendix E). To generate target chem-
ical graphs C∗ in Stage 5, we also use and modify the dynamic programming algorithm due to
Zhu et al. [26].

2LM-M LLR polymer v23: September 7, 2021

4

We implemented the framework based on the reﬁned two-layered model and a prediction func-
tion by linear regression. A polymer was inferred by using the framework for the ﬁrst time in this
paper, where Tanaka et al. [31] studied constructing a prediction function with a decision tree for
some polymer properties but have not argued topological speciﬁcation of polymers and inference
of a polymer. The results of our computational experiments reveal a set of chemical properties on
polymers to which a prediction function constructed with linear regression on our feature function
performs well. We also observe that the proposed method can infer a polymer with up to 50
non-hydrogen atoms in a monomer form.

The paper is organized as follows. Section 2 introduces some notions on graphs, a modeling of
chemical compounds and deﬁne a new monomer representation of polymers. Section 3 describes the
two-layered model for polymers. Section 4 reports the results on some computational experiments
conducted for eight chemical properties on polymers such as glass transition and experimental
amorphous density. Section 5 makes some concluding remarks.

Some technical details are given in Appendices: Appendix A for the idea of linear regression
and an MILP M(x, y; C1) formulated by Zhu et al. [26] that simulates a process of computing a
prediction function constructed by linear regression; Appendix B for all descriptors in our feature
function on polymers; Appendix C for a full description of a topological speciﬁcation; Appendix D
for the detail of test instances used in our computational experiment for Stages 4 and 5; and
Appendix E for the details of our MILP formulation M(g, x; C2). Note that the modiﬁcation of the
dynamic programming algorithm is not given in Appendices because it is slight and straightforward.

2 Preliminary

This section introduces some notions and terminologies on graphs, modeling of chemical compounds
and our choice of descriptors.

Let R, Z and Z+ denote the sets of reals, integers and non-negative integers, respectively. For

two integers a and b, let [a, b] denote the set of integers i with a ≤ i ≤ b.

Graph Given a graph G, let V (G) and E(G) denote the sets of vertices and edges, respectively.
For a subset V ′ ⊆ V (G) (resp., E′ ⊆ E(G)) of a graph G, let G − V ′ (resp., G − E′) denote
the graph obtained from G by removing the vertices in V ′ (resp., the edges in E′), where we
remove all edges incident to a vertex in V ′ in G − V ′. An edge subset E′ ⊆ E(G) in a connected
graph G is called separating (resp., non-separating) if G − E′ becomes disconnected (resp., G − E′
remains connected). The rank r(G) of a graph G is deﬁned to be the minimum |F | of an edge
subset F ⊆ E(G) such that G − F contains no cycle, where r(G) = |E(G)| − |V (G)| + 1 for a
connected graph G. Observe that r(G − E′) = r(G) − |E′| holds for any non-separating edge subset
E′ ⊆ E(G). An edge e ∈ E(G) in a connected graph G is called a bridge if {e} is separating. For
a connected cyclic graph G, an edge e is called a core-edge if it is in a cycle of G or is a bridge
e = u1u2 such that each of the connected graphs Gi, i = 1, 2 of G − e contains a cycle. A vertex
incident to a core-edge is called a core-vertex of G. A path with two end-vertices u and v is called
a u, v-path. A set F of edges in G is called a circular set if G contains a cycle C that contains all
edges in F and for every edge e ∈ F , F \ {e} is the set of all bridges e′ ∈ F in the graph G − e.

2LM-M LLR polymer v23: September 7, 2021

5

We deﬁne a rooted graph to be a graph with a designated vertex, called a root. For a graph
G possibly with a root, a leaf-vertex is deﬁned to be a non-root vertex with degree 1. We call
the edge uv incident to a leaf vertex v a leaf-edge, and denote by Vleaf(G) and Eleaf (G) the sets of
leaf-vertices and leaf-edges in G, respectively. For a graph or a rooted graph G, we deﬁne graphs
Gi, i ∈ Z+ obtained from G by removing the set of leaf-vertices i times so that

G0 := G; Gi+1 := Gi − Vleaf(Gi),

where we call a vertex v a tree vertex if v ∈ Vleaf(Gi) for some i ≥ 0. Deﬁne the height ht(v) of
each tree vertex v ∈ Vleaf(Gi) to be i; and ht(v) of each non-tree vertex v adjacent to a tree vertex
to be ht(u) + 1 for the maximum ht(u) of a tree vertex u adjacent to v, where we do not deﬁne
height of any non-tree vertex not adjacent to any tree vertex. We call a vertex v with ht(v) = k
a leaf k-branch. The height ht(T ) of a rooted tree T is deﬁned to be the maximum of ht(v) of a
vertex v ∈ V (T ). For an integer k ≥ 0, we call a rooted tree T k-lean if T has at most one leaf
k-branch. For an unrooted cyclic graph G, we regard that the set of non-core-edges in G induces
a collection T of trees each of which is rooted at a core-vertex, where we call G k-lean if each of
the rooted trees in T is k-lean.

2.1 Modeling of Chemical Compounds

We review a modeling of chemical compounds (monomers) and introduce a new way of representing
a polymer as a form of monomer.

To represent a chemical compound, we introduce a set of chemical elements such as H (hydro-
gen), C (carbon), O (oxygen), N (nitrogen) and so on. To distinguish a chemical element a with
multiple valences such as S (sulfur), we denote a chemical element a with a valence i by a(i), where
we do not use such a suﬃx (i) for a chemical element a with a unique valence. Let Λ be a set
of chemical elements a(i). For example, Λ = {H, C, O, N, P, S(2), S(4), S(6)}. Let val : Λ → [1, 6] be
a valence function. For example, val(H) = 1, val(C) = 4, val(O) = 2, val(P) = 5, val(S(2)) = 2,
val(S(4)) = 4 and val(S(6)) = 6. For each chemical element a ∈ Λ, let mass(a) denote the mass of a.
A chemical compound is represented by a chemical graph deﬁned to be a tuple C = (H, α, β) of
a simple, connected undirected graph H and functions α : V (H) → Λ and β : E(H) → [1, 3]. The
set of atoms and the set of bonds in the compound are represented by the vertex set V (H) and the
edge set E(H), respectively. The chemical element assigned to a vertex v ∈ V (H) is represented
by α(v) and the bond-multiplicity between two adjacent vertices u, v ∈ V (H) is represented by
β(e) of the edge e = uv ∈ E(H). We say that two tuples (Hi, αi, βi), i = 1, 2 are isomorphic if
they admit an isomorphism φ, i.e., a bijection φ : V (H1) → V (H2) such that uv ∈ E(H1), α1(u) =
a, α1(v) = b, β1(uv) = m ↔ φ(u)φ(v) ∈ E(H2), α2(φ(u)) = a, α2(φ(v)) = b, β2(φ(u)φ(v)) = m.
When Hi is rooted at a vertex ri, i = 1, 2, (Hi, αi, βi), i = 1, 2 are rooted-isomorphic (r-isomorphic)
if they admit an isomorphism φ such that φ(r1) = r2.

For a notational convenience, we use a function βC : V (H) → [0, 12] for a chemical graph
C = (H, α, β), such that βC(u) means the sum of bond-multiplicities of edges incident to a vertex
u; i.e.,

βC(u) , X

uv∈E(H)

β(uv) for each vertex u ∈ V (H).

2LM-M LLR polymer v23: September 7, 2021

6

For each vertex u ∈ V (H), deﬁne the electron-degree eledegC(u) to be

eledegC(u) , βC(u) − val(α(u)).

For each vertex u ∈ V (H), let degC(v) denote the number of vertices adjacent to u in C.

For a chemical graph C = (H, α, β), let Va(C), a ∈ Λ denote the set of vertices v ∈ V (H)
such that α(v) = a in C and deﬁne the hydrogen-suppressed chemical graph hCi to be the graph
obtained from H by removing all the vertices v ∈ VH(C).

v1
*

*
e0

*
e4

v2
*

*
e3

*
e2

v1
*

*
e1

n

*
e1

*
e4

v2
*

*
e3

*
e2

*
e6

*
e5

(b)

*
e6

*
e5

(a)

Figure 2: (a) A repeating unit of polymer: thioBis(4-phenyl)carbonate, where e∗
connecting-edges and v∗
in (a), where the link-edges are depicted with thick lines and v∗

1 are the
2 are the connecting-vertices; (b) A monomer form of the polymer
2 are the connecting-vertices.

1 and v∗

0 and e∗

1 and v∗

Polymers In this paper, we treat a polymer that is a linear concatenation of a single repeating
unit with two connecting-edges of e∗
1 such that two adjacent units in the concatenation are
joined with the connecting-edges. We call the two vertices incident to the two connecting-edges
the connecting-vertices. Figure 2(a) illustrates an example of a repeating unit of such a polymer,
where v∗

2 are the connecting-vertices.

1 and v∗

0 and e∗

2 into two edges and merging e∗

Tanaka et al. [31] proposed a modeling of a polymer as a monomer with no connecting-edges
by introducing an artiﬁcial chemical element a∗ to which the original two connecting-edges of
a repeating unit become newly incident. When the number of repeating units in a polymer is
extremely large, other edges in the repeating unit may have a similar role with the connecting-
edges. For example, edge e∗
2 of the repeating unit in Figure 2(a) can serve as the connecting-edges
of a diﬀerent repeating unit by splitting e∗
1 into a single edge.
To take this into consideration, this paper introduces a new way of representing a polymer as
a monomer form. We call an edge e in a repeating unit of a polymer a link-edge if it is passed by
every path between the connecting-edges e∗
1. For example, the link-edges in the repeating
unit in Figure 2(a) are given by e∗
6. To represent a polymer as a monomer, we regard
0 and e∗
the two connecting-edges e∗
1, as illustrated in Figure 2(b). We call the
resulting chemical graph the monomer representation, where we also call the edge e∗
1 a link-edge in
the representation. We still call the vertices incident to e∗
1 the connecting-vertices and distinguish
them from other vertices because a polymer that is synthesized from a speciﬁed repeating unit
actually may end with the connecting-vertices. (A polymer of a cyclic sequence of a repeating unit
that has no particular ends can be modeled as our monomer representation with no connecting-
vertices.) In what follows, a polymer is represented by the monomer representation C, and the set
of link-edges in C is denoted by Elnk(C). Note that the set Elnk(C) is a circular set in C.

2, e∗
1 as a single edge e∗

0 and e∗

3, . . . , e∗

0 and e∗

2LM-M LLR polymer v23: September 7, 2021

7

3 Two-layered Model

This section reviews the two-layered model proposed by Zhu et al. [26] and makes a necessary
modiﬁcation so as to apply it to the case of polymers.

Let C = (H, α, β) be a chemical graph and ρ ≥ 1 be an integer, which we call a branch-

parameter.

A two-layered model of C is a partition of the hydrogen-suppressed chemical graph hCi into
an “interior” and an “exterior” in the following way. We call a vertex v ∈ V (hCi) (resp., an edge
e ∈ E(hCi)) of C an exterior-vertex (resp., exterior-edge) if ht(v) < ρ (resp., e is incident to an
exterior-vertex) and denote the sets of exterior-vertices and exterior-edges by V ex(C) and Eex(C),
respectively, and denote V int(C) = V (hCi) \ V ex(C) and Eint(C) = E(hCi) \ Eex(C), respectively.
We call a vertex in V int(C) (resp., an edge in Eint(C)) an interior-vertex (resp., interior-edge).
The set Eex(C) of exterior-edges forms a collection of connected graphs each of which is regarded
as a rooted tree T rooted at a vertex v ∈ V (T ) with the maximum ht(v). Let T ex(hCi) denote
the set of these chemical rooted trees in hCi. The interior of C is deﬁned to be the subgraph
(V int(C), Eint(C)) of hCi.

Diﬀerently from standard monomers, we distinguish the link-edges in the monomer form of
a polymer from other edges in order to feature the topological structure of the polymer. Fig-
ure 3 illustrates an example of a hydrogen-suppressed polymer hCi with Elnk(C) = {u1u15,
u5u15, u3u16, u16u17, u17u18, u4u18}.

For a branch-parameter ρ = 2, the interior of the chemical graph hCi in Figure 3 is ob-
tained by removing the set of vertices with degree 1 ρ = 2 times; i.e., ﬁrst remove the set V1 =
{w1, w2, . . . , w19} of vertices of degree 1 in hCi and then remove the set V2 = {w20, w16, . . . , w26}
of vertices of degree 1 in hCi − V1, where the removed vertices become the exterior-vertices of hCi.

-N
u21

u1
C

*

S(6)
u22

u2
C

w11
O
u3
C

u16
C

u17
C

*
C
u15

u18
C

u24
O

u6
C

u19
C

u20
C

u23
S(2)

u9
C

u10
C

C
w12

u28

C

O
w13

u4
C

u12

P

u11
C

u13
C

u7

C

w20

O

C

u8

w21

C

C
w1

C
w2

C
w3

u25

C

w22

C

C
w6

u26

C

w23

C

C
w4

C
w5

C
w7

C
w8

u27

C

O
w10

C

w24

C

w9

O

C
w16 w17

u29

C

w25

C

C
w14

C
w15

u5
C

u14

C

C

w26

Cl
w18

Cl
w19

Figure 3: An illustration of the hydrogen-suppressed monomer representation hCi obtained from
a polymer C by removing all the hydrogens, where the link-edges are depicted with thick lines and
V ex(C) = {wi | i ∈ [1, 26]} and V int(C) = {ui | i ∈ [1, 29]} for ρ = 2 and the connecting-vertices
are marked with asterisks.

2LM-M LLR polymer v23: September 7, 2021

8

For each interior-vertex u ∈ V int(C), let Tu ∈ T ex(hCi) denote the chemical tree rooted at u
(where possibly Tu consists of vertex u) and deﬁne the ρ-fringe-tree C[u] to be the chemical rooted
tree obtained from Tu by putting back the hydrogens originally attached with Tu in C. Let T (C)
denote the set of ρ-fringe-trees C[u], u ∈ V int(C). Figure 4 illustrates the set T (C) = {C[ui] | i ∈
[1, 29]} of the 2-fringe-trees of the example C in Figure 3.

C

C

C

C

C

C

 [u1]
y1

 [u2]
y1

 [u4]
y1

H
 [u3]
y6

H
 [u5]
y6

H
 [u6]
y6

C

C

C

C

H

C
 [u16]
y15

H
 [u18]
y6

H H
 [u19]
y11

O
 [u17]
y18

C
 [u20]
y1

C
 [u7]
y25
-
N
 [u21]
y4

C
C
 [u8]
y28

S(6)

H H

O
 [u22]
y19

C

O

H H

CC

C

H H

C
 [u9]
y1

C

C

P

C

O
 [u10]
y18

H
 [u11]
y6

O
C
 [u12]
y23

H H
 [u13]
y11

S(2)
 [u23]
y5

O
 [u24]
y2

C

C

C

C

C

H H

C

C

H H

C

C
 [u25]
y29

C
C
 [u26]
y28

C
 [u27]
y24

C

C

Cl
Cl
 [u14]
y30

C

H
 [u28]
y6

C

H H
 [u15]
y11

C

C

H

C
C
 [u29]
y27

Figure 4: The set T ex(C) of 2-fringe-trees C[ui], i ∈ [1, 29] of C with hCi in Figure 3, where the
root of each tree is depicted with a gray circle and the hydrogens attached to non-root vertices are
omitted in the ﬁgure.

Feature Function The feature of an interior-edge e = uv ∈ Eint(C) such that α(u) = a,
deghCi(u) = d, α(v) = b, deghCi(v) = d′ and β(e) = m is represented by a tuple (ad, bd′, m), which
is called the edge-conﬁguration of the edge e, where we call the tuple (a, b, m) the adjacency-
conﬁguration of the edge e.

For an integer K, a feature vector f (C) of a chemical graph C is deﬁned by a feature function

f that consists of K descriptors. We call RK the feature space.

Tanaka et al. [31] deﬁned a feature vector f (C) ∈ RK to be a combination of the frequency of
edge-conﬁgurations of the interior-edges and the frequency of chemical rooted trees among the set
of chemical rooted trees C[u] over all interior-vertices u. Zhu et al. [26] additionally included two
descriptors that feature the leaf-edges and the rank of a chemical graph. In this paper, we further
introduce new descriptors that features the link-edges in the monomer representation of polymers
(see Appendix B for all descriptors in our feature function on polymers). Note that introduction
of new descriptors requires us to modify the subsystem of simulating the computation process
of a feature function f in an MILP M(x, y; C1). We use the same MILP formulation used by
Zhu et al. [26] for M(x, y; C1) by making a necessary modiﬁcation (see Appendix E for the details
of our MILP formulation M(g, x; C2)).
Topological Speciﬁcation Tanaka et al. [31] also introduced a set of rules for describing a
topological speciﬁcation in the following way:

(i) a seed graph GC as an abstract form of a target chemical graph C;
(ii) a set F of chemical rooted trees as candidates for a tree C[u] rooted at each interior-vertex

2LM-M LLR polymer v23: September 7, 2021

9

u in C; and

(iii) lower and upper bounds on the number of components in a target chemical graph such as

chemical elements, double/triple bonds and the interior-vertices in C.

: E(＞2)={a1,a2,a3,a4}

- 

: E(0/1)={a10} 

: E(＞1)={a5,a6,...,a9}  

- 

: E(=1)={a11,a12,...,a18}

C

O

N

y1

y2

y3

-

N

y4

y5

u1

a11
u6
a7

u7

a5

a3

a12

u8

a6

u2

a1

u3

a8

a2

a10

a4
u9
a9

u10

u11

u4

a14

a13

a15

a16

u12

u13

a17

u5
a18
u14

(a) A seed graph GC=(VC,EC) with  EC    ={a1,a2}  

lnk

C

C

C

C

H

C
y15

H H

C
y16

C
y17

O
y18

C

C

H H

C

O

H H

C

C

S(2)

C

O

N

S(2)

P

C

N

S(6)

P

H
y6

H
y7
S(6)

H
y8

H
y9

H
y10

C

N

H H
H H
y11 y12
C

H H
y13

H H
y14
P

H H

O
y19

C

C

H

C
y27

C
C
y20

C

C
y21

C

O
y22

C

O
y23

C

C

C

C

C

C

C

H H

C

C
y28

C

C

Cl

Cl

y30

C
y24

C
y25

C

C

C

y29
y26
(b) A set      of chemical rooted trees 

(a) A seed graph GC with Elnk

C = {a1, a2}, where the vertices in VC are depicted with
Figure 5:
gray circles, the edges in E(≥2) are depicted with dotted lines, the edges in E(≥1) are depicted
with dashed lines, the edges in E(0/1) are depicted with gray bold lines and the edges in E(=1) are
depicted with black solid lines; (b) A set F = {ψ1, ψ2, . . . , ψ30} ⊆ F (Dπ) of 30 chemical rooted
trees ψi, i ∈ [1, 30], where the root of each tree is depicted with a gray circle, where the hydrogens
attached to non-root vertices are omitted in the ﬁgure.

Figure 5(a) and (b) illustrate examples of a seed graph GC and a set F of chemical rooted
trees, respectively. Given a seed graph GC, the interior of a target chemical graph C is constructed
from GC by replacing some edges a = uv with paths Pa between the end-vertices u and v and by
attaching new paths Qv to some vertices v. For example, the chemical graph hCi in Figure 3 is
constructed from the seed graph GC in Figure 5(a) as follows.
- First replace nine edges a1 = u1u5, a2 = u3u4, a3 = u1u2, a4 = u2u9, a5 = u1u2, a6 = u2u3, a7 =

u6u7, a8 = u3u9 and a9 = u9u10 in GC with new paths Pa1 = (u1, u15, u5), Pa2 = (u3, u16, u17, u18, u4),
Pa3 = (u1, u19, u20, u2), Pa4 = (u2, u23, u9), Pa5 = (u1, u21, u2), Pa6 = (u2, u22, u3), Pa7 =
(u6, u24, u7), Pa8 = (u3, u9) = a8 and Pa9 = (u9, u10), respectively to obtain a subgraph G1
of hCi.

- Next attach to this graph G1 three new paths Qu9 = (u9, u26), Qu10 = (u10, u27), Qu18 =
(u18, u28, u29) and Qu20 = (u20, u25) to obtain the interior of hCi, as illustrated in Figure 6.
- Finally attach to the interior 29 trees selected from the set F and assign chemical elements
and bond-multiplicities in the interior to obtain a chemical graph C in Figure 3. In Figure 4,
ψ1 ∈ F is selected for C[ui], i ∈ {1, 2, 4, 9, 20}. Similarly ψ2 for C[u24], ψ4 for C[u21], ψ5 for
C[u23], ψ6 for C[ui], i ∈ {3, 5, 6, 11, 18, 28}, ψ11 for C[ui], i ∈ {13, 15, 19}, ψ15 for C[u16], ψ18 for
C[ui], i ∈ {10, 17}, ψ19 for C[u22], ψ23 for C[u12], ψ24 for C[u27], ψ25 for C[u7], ψ27 for C[u29],
ψ28 for C[ui], i ∈ {8, 26}, ψ29 for C[u25] and ψ30 for C[u14].

Our deﬁnition of a topological speciﬁcation is analogous with the one by Zhu et al. [26] except

2LM-M LLR polymer v23: September 7, 2021

10

Pa5

u21

u1

Pa6

u22

u2

a11

u6

u24

Pa7

a12

u7

u8

u19

u20

Pa3

Qu19

u25

a8
u9

Qu9

u23

Pa4

u26

u3

Pa9

Pa1

u16

u10
Qu10
u27

u15

Pa2

u18

u17

Qu18

u11

u4

a14

a13

u5

a15

a16

u12

u13

a18
u14

a17

u28

u29

Figure 6: A graph obtained from the seed graph GC in Figure 5(a), where each path Qu rooted
at a vertex u is depicted with arrows and the vertices newly introduced from GC are depicted with
white circles.

for a necessary modiﬁcation due to our polymer model with link-edges (see Appendix C for a full
description of topological speciﬁcation).

4 Computational Results

We implemented our method of Stages 1 to 5 for inferring chemical graphs under a given topological
speciﬁcation and conducted experiments to evaluate the computational eﬃciency. We executed
the experiments on a PC with Processor: Core i7-9700 (3.0GHz; 4.7 GHz at the maximum) and
Memory: 16 GB RAM DDR4.

Results on Phase 1. We have conducted experiments of linear regression for ten chemical
properties on polymers among which we report the following eight properties to which the test
coeﬃcient of determination R2 attains at least 0.76: experimental amorphous density (AmD),
dielectric constant (DeC), heat capacity liquid (HcL), heat capacity solid (HcS), mol volume
(MlV), permittivity (Prm), refractive index (RfId) and glass transition(Tg). All these data
sets are provided by Bicerano [36], where we did not include any polymer whose chemical formula
could not be found by its name in the book. For property RfId, we remove the following polymer
as an outlier from the original data set: 2-decyl-1 4-butadiene C with a(C) = 0.4899.

We implemented Stages 1, 2 and 3 in Phase 1 as follows.

Stage 1. We set a graph class G to be the set of all polymers with any graph structure, and set
a branch-parameter ρ to be 2. We represent a polymer as a monomer representation.

For each of the properties, we ﬁrst select a set Λ of chemical elements and then collect a data
set Dπ on the polymers over the set Λ of chemical elements. To construct the data set Dπ, we
eliminated chemical compounds such that the monomer representation C that does not satisfy
one of the following: C is connected; the number of non-hydrogen neighbors of each atom C is at
most 4; and the number of end-vertices of the linked-edges in C is at least two (i.e., no self-loop
is a link-edge in the monomer form). Since the observed values of property Prm are measured by

2LM-M LLR polymer v23: September 7, 2021

11

diﬀerent frequencies, we include an extra descriptor fq that represents the frequency used for each
polymer Ci ∈ Dπ in our feature vector f (Ci).

Table 1 shows the size and range of data sets that we prepared for each chemical property in

Stage 1, where we denote the following:
- Λ: the set of elements used in the data set Dπ; Λ is one of the following six sets: Λ1 =
{H, C, O, N}; Λ2 = {H, C, O(1), O(2), N}; Λ3 = {H, C, O, N, Cl}; Λ4 = {H, C, O, N, Cl, S(2)}; Λ5 =
{H, C, O, N, Cl, S(2), S(6)}; and Λ6 = {H, C, O(1), O(2), N, Cl, Si(4), F}, where a(i) for a chemical el-
ement a and an integer i ≥ 1 means that a chemical element a with valence i.

- |Dπ|: the size of data set Dπ over Λ for the property π.
- n, n: the minimum and maximum values of the number n(C) of non-hydrogen atoms in the

polymers C in Dπ.

- a, a: the minimum and maximum values of a(C) for π over the polymers C in Dπ.
- |Γ|: the number of diﬀerent edge-conﬁgurations of interior-edges over the compounds in Dπ.
- |F |: the number of non-isomorphic chemical rooted trees in the set of all 2-fringe-trees in the

polymers in Dπ.

- K: the number of descriptors in a feature vector f (C).

Stage 2. We used the new feature function deﬁned in our chemical model without suppressing
hydrogen (see Appendix B for the detail). We standardize the range of each descriptor and the
range {t ∈ R | a ≤ t ≤ a} of property values a(C), C ∈ Dπ.

Stage 3. For each chemical property π, we select a penalty value λπ in the Lasso function from
36 diﬀerent values from 0 to 100 by conducting linear regression as a preliminary experiment.

We conducted an experiment in Stage 3 to evaluate the performance of the prediction function
based on cross-validation. For a property π, an execution of a cross-validation consists of ﬁve trials
of constructing a prediction function as follows. First partition the data set Dπ into ﬁve subsets
D(k)
π , k ∈ [1, 5] randomly; for each k ∈ [1, 5], the i-th trial constructs a prediction function η(k) by
conducting a linear regression with the penalty term λπ using the set Dπ \ D(k)
π as a training data
set. We used scikit-learn version 0.23.2 with Python 3.8.5 for executing linear regression with Lasso
function. For each property, we executed ten cross-validations and we show the median of test
coeﬃcient of determination R2(η(k), D(k)
π ), k ∈ [1, 5] over all ten cross-validations (see Appendix A
for the deﬁnition coeﬃcient of determination R2(η, D) for a prediction function η over a data set
D). Recall that a subset of descriptors is selected in linear regression with Lasso function and let
K ′ denote the average number of selected descriptors over all 50 trials. The running time per trial
in a cross-validation was at most one second.

Table 1 shows the results on Stages 2 and 3, where we denote the following:

- λπ: the penalty value in the Lasso function selected for a property π, where aEb means a × 10b;
- K ′: the average of the number of descriptors selected in the linear regression over all 50 trials

in ten cross-validations;

- test R2: the median of test coeﬃcient of determination R2 over all 50 trials in ten cross-

validations.
From Table 1, we see that the number K ′ of selected descriptors is around 15 to 50 over all
properties π and that the number K ′ becomes slightly larger when the set Λ of speciﬁed chemical
elements is large for the same property π.

2LM-M LLR polymer v23: September 7, 2021

12

π

Λ |Dπ| n, n
4, 45
86
4, 45
93
4, 22
37
4, 25
52
4, 32
55
4, 45
54
4, 45
59
4, 45
86
4, 45
93
4, 45
112
4, 45
131
4, 29
91
4, 29
124
4, 58
204
4, 58
232

AmD Λ1
AmD Λ4
DeC Λ4
HcL Λ1
HcL Λ5
HcS Λ1
HcS Λ5
MlV Λ1
MlV Λ4
Prm Λ1
Prm Λ3
RfId Λ2
RfId Λ6
Tg
Λ1
Tg
Λ5

Table 1: Results in Phase 1.

a, a
0.838, 1.34
0.838, 1.45
2.13, 3.4
105.7, 677.8
105.7, 678.1
84.5, 720.5
84.5, 720.5
60.7, 466.6
60.7, 466.6
2.23, 4.91
2.23, 4.91
1.4507, 1.683
1.339, 1.683
171, 673
171, 673

|Γ|
28
31
22
22
27
26
32
28
31
25
25
26
32
32
36

|F | K
83
25
94
30
72
19
67
17
81
20
75
20
92
24
83
25
94
30
69
15
73
17
96
35
124
50
101
36
118
43

λπ
5.0E−4
6.0E−4
4.0E−3
7.0E−4
2.0E−4
5.0E−4
5.0E−4
2.0E−5
2.0E−6
4.0E−5
5.0E−5
9.0E−4
9.0E−4
9.0E−5
9.0E−5

K ′
17.7
17.0
6.7
14.2
28.3
16.4
18.9
39.1
60.8
23.7
27.3
22.0
27.8
40.0
45.8

test R2
0.914
0.918
0.761
0.990
0.987
0.968
0.961
0.996
0.994
0.801
0.784
0.852
0.832
0.902
0.894

Results on Phase 2. To execute Stages 4 and 5 in Phase 2, we used a set of two instances Ia
and Ib. We here present their seed graphs GC (see Appendices C and D for the details of them).
The seed graph GC of instance Ia is given by the graph in Figure 5(a). Instance Ib is introduced
to represent a set of polymers that includes the four examples of polymers in Figure 7. The seed
graph of instance Ib is illustrated in Figure 8(a).

Stage 4. We executed Stage 4 for four properties π ∈ {AmD, HcL, RfId, Tg}. For the MILP
formulation M(x, y; C1) in Section A, we use the prediction function ηw,b that attained the median
test R2 in Table 1. To solve an MILP in Stage 4, we used CPLEX version 12.10.

For property Prm, we also need to specify the frequency fq under which the value a(C) is
observed, and set lower and upper bounds fq, fq ∈ R on the frequency to be fq := 60 and fq :=
1.0 × 107 in this experiment.

Tables 2 shows the computational results of the experiment in Stage 4 for the four properties

AmD, HcL, Prm, RfId and Tg, respectively, where we denote the following:
- π: a property π ∈ {AmD, HcL, RfId, Tg};
- inst.: instance Ia or Ib;
- nLB: a lower bound on the number of non-hydrogen atoms;
- y∗, y∗: lower and upper bounds y∗, y∗ ∈ R on the value a(C) of a polymer C to be inferred;
- #v (resp., #c): the number of variables (resp., constraints) in the MILP in Stage 4;
- I-time: the time (sec.) to solve the MILP in Stage 4;
- n: the number n(C†) of non-hydrogen atoms in the monomer representation C† inferred in
Stage 4, where “none” means that no desired polymer exists for the topological speciﬁcation;
- nint: the number nint(C†) of interior-vertices in the monomer representation C† inferred in

2LM-M LLR polymer v23: September 7, 2021

13

(i) 1_1-(2-methylPropane)Bis(4-phenyl)carbonate

(ii) 2_2-pentaneBis(4-phenyl)carbonate 

(iii) 1_1-dichloroethyleneBis(4-phenyl)carbonate 

(iv) thioBis(4-phenyl)carbonate

(i) 1 1-(2-methylPropane)Bis(4-phenyl)carbonate;
Figure 7: An illustration of four polymers:
(ii) 2 2-pentaneBis(4-phenyl)carbonate;
(iv)
thioBis(4-phenyl)carbonate, where hydrogens are omitted and connecting edges are depicted with
thick lines.

(iii) 1 1-dichloroethyleneBis(4-phenyl)carbonate;

: E(＞2)={a1,a2}

- 

: E(=1)={a3,a4,...,a14}

a13

a12 u11
u10

C2

a11

a10

u12

a14

u7

a9

u9

u8

a1

a2

a8

a7

u5

u6

a3

u4

C1

u1

a6

u3

u2

a4

a5

C

y1

O

y2

S(2)
y3

C

O

N

C

N

C

C

H
y4

H
y5

H
y6

H H
y7

H H
y8

H

C
y9

C

O

C

C

C

C

C

C

O

C

C

C

C

H

H H

C
y10
C

C

y11

y12

C
y13

C
y14

C

C
y15

C

C

Cl

Cl

y16

y17

(i) A seed graph GC=(VC,EC) with  EC    ={a1,a2}  

lnk

(ii) A set      of chemical rooted trees 

Figure 8:

(i) A seed graph GC for Ib; (ii) A set F of chemical rooted trees.

Stage 4; and

- η: the predicted property value η(f (C†)) of the polymer C† inferred in Stage 4.

In Table 2, η(f (C†)) is the predicted value of property π of a polymer C† constructed by solving
an MILP in Stage 4, where we see that each η(f (C†)) actually satisﬁes the speciﬁed lower and
upper bounds on a target chemical value.

We set lower and upper bounds on a target chemical value for property HcL with Λ1 so that
(y∗, y∗) is the maximal range of the observed values over the data set Dπ; i.e., (y∗, y∗) := (a, a) =
(105.7, 678.1). Similarly for property RfId with Λ6, we set (y∗, y∗) := (a, a) = (1.339, 1.683). For
an example of Ia with AmD, it holds that y∗ ≤ η(f (C†)) ≤ y∗ with y∗ = 0.885, y∗ = 0.890 and

2LM-M LLR polymer v23: September 7, 2021

14

π

HcL

Prm

inst. nLB
30
25
30
30
30
35
30
40
30
45

AmD Ia
Ib
Ia
Ib
Ia
Ib
Ia
Ib
Ia
Ib

RfId

Tg

Table 2: Results of Stages 4 and 5.

y∗, y∗
0.885, 0.890
1.344, 1.350
105.7, 678.1
658.8, 660.2
4.128 4.150
3.158 3.188
1.339, 1.683
1.406, 1.422
180.0, 181.6
180.6, 182.8

#v
11247
7125
12171
8469
9878
8999
9979
10460
12245
12953

#c
12964
7690
13017
9916
12547
12112
12661
15035
13102
18549

I-time
6.20
2.54
31.0
1.51
10.7
2.03
92.1
2.61
17.0
32.8

n nint
49 30
28 22
none
32 20
50 30
41 24
none
47 27
50 30
55 28

η
0.889
1.347
-
660.0
4.150
3.188
-
1.413
181.06
182.20

D-time C-LB #C
64
0.285
100
0.188
-
-
100
0.189
24
0.166
100
0.190
-
-
100
0.202
36
0.220
100
0.196

64
2610
-
576
24
1.5E4
-
7.8E5
36
6.3E5

η(f (C†)) = 0.889. For instance Ia with HcL and RfId, Table 2 reveals that there is no chemical
graph that satisﬁes the topological speciﬁcation Ia. These infeasible instance and instance Ib with
π =Tg took around 30 to 90 seconds. For the other cases, solving an MILP for inferring a polymer
with around 50 non-hydrogen atoms in the monomer form is around 2 to 15 seconds.

Figure 9(i) (resp., (ii)) illustrates the chemical graph C† inferred from Ia (resp., Ib) with

(y∗, y∗) = (0.885, 0.890) of AmD (resp., (y∗, y∗) = (658.8, 660.2) of HcL) in Table 2.

*

*

(i)

*

*

(ii)

*

*

(iii)

Illustrations of polymers, where the link-edges are depicted with thick lines and the
Figure 9:
connecting-vertices are marked with asterisks. (i) A polymer C† with η(f (C†)) = 0.889 inferred
from Ia with (y∗, y∗) = (0.885, 0.890) of AmD; (ii) A polymer C† with η(f (C†)) = 660.0 inferred
from Ib with (y∗, y∗) = (658.8, 660.2) of HcL. (iii) A polymer C† inferred from Ib with lower and
upper bounds on the predicted property value ηπ(f (C†)) of property π ∈ {AmD, HcL, Tg} in
Table 3.

From Table 2, we observe that instances with around 30 to 55 non-hydrogen atoms in the

2LM-M LLR polymer v23: September 7, 2021

15

monomer representation are solved in around 2 to 30 seconds when they are feasible.

Inferring a polymer with target values in multiple properties
Once we obtained prediction functions ηπ for several properties π, it is easy to include MILP
formulations for these functions ηπ into a single MILP M(x, y; C1) so as to infer a chemical graph
that satisﬁes given target values y∗ for these properties at the same time. As an additional
experiment in Stage 4, we conducted a computational experiment for inferring a polymer that
has a desired predicted value each of some three properties π1, π2 and π3. For a combination of
three properties, we selected two sets P1 = {AmD, HcL, Tg} and P2 = {HcS, MlV, RfId},
where we used the prediction function ηπ for each property π ∈ Pi constructed in Stage 3. Table 3
shows the result of Stage 4 for inferring a chemical graph C† from instance Ib with a set Λ(Pi)
of chemical elements for the set Pi of properties such that Λ(P1) = Λ3 = {H, C, O, N, Cl, S(2)} and
Λ(P2) = {H, C, O(2), N, Cl}, where we denote the following:
- Pi, i = 1, 2: a combination of three properties, where P1 = {AmD, HcL, Tg} and P2 = {HcS,

MlV, RfId};

- π: one of the three properties in Pi, i = 1, 2 used in the experiment;
- y∗
π
property π ∈ Pi, i = 1, 2 for a polymer C† to be inferred;

lower and upper bounds y∗
π

, y∗
π:

, y∗

π ∈ R on the predicted property value ηπ(f (C†)) of

- #v (resp., #c): the number of variables (resp., constraints) in the MILP in Stage 4;
- I-time: the time (sec.) to solve the MILP in Stage 4;
- n: the number n(C†) of non-hydrogen atoms in the monomer representation C† inferred in

Stage 4; and

- nint: the number nint(C†) of interior-vertices in the monomer representation C† inferred in

Stage 4;

- ηπ: the predicted property value ηπ(f (C†)) of property π ∈ Pi, i = 1, 2 for the polymer C†

inferred in Stage 4.

Table 3: Results of Stage 4 for instance Ib with speciﬁed target values of the three properties in
Pi, i = 1, 2.

Pi nLB

π

y∗
π

, y∗
π

#v

#c

I-time n

nint

P1

P2

AmD 1.200, 1.224
624.0, 628.0
171.0, 174.0
539, 541
393, 395

25 HcL
Tg
HcS
45 MlV

RfId 1.4507, 1.479

7525

8211

3.09

31

18

12162

18536

210.2

45

29

ηπ
1.217
625.9
171.55
540.7
394.3
1.46

Fig. 9(iii) illustrates the polymer C† inferred from Ib with (y∗
π1

, y∗

π1) = (1.200, 1.224), (y∗
π2

, y∗

π2) =

(624.0, 628.0) and (y∗
π3
Stage 5. We executed Stage 5 to generate a more number of target chemical graphs C∗, where
we call a chemical graph C∗ a chemical isomer of a target chemical graph C† of a topological

π3) = (171.0, 174.0) for π1 =AmD, π2 =HcL and π3 =Tg, respectively.

, y∗

2LM-M LLR polymer v23: September 7, 2021

16

speciﬁcation σ if f (C∗) = f (C†) and C∗ also satisﬁes the same topological speciﬁcation σ. For
this, we executed the same algorithm used by Zhu et al. [26]. We computed chemical isomers C∗ of
each target chemical graph C† inferred in Stage 4. We execute an algorithm for generating chemical
isomers of C† up to 100 when the number of all chemical isomers exceeds 100. The algorithm can
evaluate a lower bound on the total number of all chemical isomers C† without generating all of
them.

Tables 2 shows the computational results of the experiment in Stage 5 for properties AmD,

HcL, RfId and Tg, respectively, where we denote the following:
- D-time: the running time (sec.) to execute the dynamic programming algorithm in Stage 5 to
compute a lower bound on the number of all polymers C∗ of C† and generate all (or up to 100)
chemical isomers C∗;

- C-LB: a lower bound on the number of all chemical isomers C∗ of C†, where aEb means a ×

10b; and

- #C: the number of all (or up to 100) chemical isomers C∗ of C† generated in Stage 5.

From Table 2, we observe that the number of isomers C∗ of an output polymer C† varies on
each case, where the polymer C† admits only 24 isomers C∗ for instance Ia and π =Prm and over
6.3 × 105 for instance Ib and π =Tg. The computation time for generating at most 100 isomers
C∗ and estimating a lower bound C-LB is at most 0.3 second for all cases in our experiment.

5 Concluding Remarks

In this paper, we designed a method for inferring polymers based on the framework for monomers
proposed by Akutsu and Nagamochi [23]. To treat a polymer as a form of monomers with no
connecting-edges, we introduce a new way of representing a polymer with a monomer form by
distinguishing link-edges from other edges in polymers. Since the link-edges of a polymer are
characteristic to the polymer, we included new descriptors that feature the link-edges of a polymer
into our feature vector. We constructed prediction functions by linear regression for eight chemical
properties on polymers in Phase 1 of the framework. We inferred polymers for the ﬁrst time in
Phase 2 of the framework. The results of our computational experiments suggest that the method
still can infer a polymer with 50 non-hydrogen atoms in the monomer form in a reasonable running
time.

There are some chemical properties on polymers to which linear regression did not provide a
good prediction function. It is left as a future work to use other learning methods such as decision
trees and neural networks and ﬁnd new eﬀective descriptors in order to construct a prediction
function with a better performance for these chemical properties on polymers.

References

[1] Tetko, I.V., Engkvist, O.: From big data to artiﬁcial intelligence: chemoinformatics meets

new challenges. J. Cheminformatics 12, 74 (2020)

2LM-M LLR polymer v23: September 7, 2021

17

[2] Xia, X.: Current topics in medicinal chemistry, Bioinformatics and drug discovery, 17,

1709-1726 (2017)

[3] Sanchez-Lengeling, B., Aspuru-Guzik, A.: Inverse molecular design using machine learning:

Generative models for matter engineering, Science, 361, 360-365, (2018)

[4] Segler, M.H.S., Kogej, T., Tyrchan, C., Waller, M.P.: Generating focused molecule libraries

for drug discovery with recurrent neural networks. ACS Cent. Sci. 4, 120–131 (2017)

[5] Yang, X., Zhang, J., Yoshizoe, K., Terayama, K., Tsuda, K.: ChemTS: an eﬃcient python

library for de novo molecular generation. STAM 18, 972–976 (2017)

[6] G´omez-Bombarelli, R., Wei, J.N., Duvenaud, D., Hern´andez-Lobato, J.M., S´anchez-Lengeling,
B., Sheberla, D., Aguilera-Iparraguirre, J., Hirzel, T.D., Adams, R.P., Aspuru-Guzik, A.:
Automatic chemical design using a data-driven continuous representation of molecules. ACS
Cent. Sci. 4, 268–276 (2018)

[7] Kusner, M.J., Paige, B., Hern´andez-Lobato, J.M.: Grammar variational autoencoder. Proc.
of the 34th International Conference on Machine Learning-Volume 70, 1945–1954 (2017)

[8] De Cao, N., Kipf, T.: MolGAN: An implicit generative model for small molecular graphs.

arXiv:1805.11973 (2018)

[9] Prykhodko, O., Johansson, S. V., Kotsias, P-C., Ar´us-Pous, J., Bjerrum, E. J., Engkvist,
O., Chen, H.: A de novo molecular generation method using latent vector based generative
adversarial network. J. Cheminformatics, 11, 74 (2019)

[10] Madhawa, K, Ishiguro, K., Nakago, K., Abe, M.: GraphNVP: an invertible ﬂow model for

generating molecular graphs. arXiv 1905.11600 (2019)

[11] Shi, C., Xu, M., Zhu, Z., Zhang, W., Zhang, M., Tang, J.: GraphAF: a ﬂow-based autore-

gressive model for molecular graph generation. arXiv:2001.09382 (2020)

[12] Kipf, T. N., Welling, M.: Semi-supervised classiﬁcation with graph convolutional networks.

arXiv:1609.02907 (2016)

[13] Miyao, T., Kaneko, H., Funatsu, K.:

Inverse QSPR/QSAR analysis for chemical structure

generation (from y to x). J. Chem. Inf. Model. 56, 286–299 (2016)

[14] Ikebata, H., Hongo, K., Isomura, T., Maezono, R., Yoshida, R.: Bayesian molecular design

with a chemical language model. J. Comput. Aided Mol. Des. 31, 379–391 (2017)

[15] Rupakheti, C., Virshup, A., Yang, W., Beratan, D.N.: Strategy to discover diverse optimal

molecules in the small molecule universe. J. Chem. Inf. Model. 55, 529–537 (2015)

[16] Akutsu, T., Fukagawa, D., Jansson, J., Sadakane, K.: Inferring a graph from path frequency.

Discrete Appl. Math. 160, 10-11, 1416–1428 (2012)

2LM-M LLR polymer v23: September 7, 2021

18

[17] Bohacek, R.S., McMartin, C., Guida, W.C.: The art and practice of structure-based drug

design: A molecular modeling perspective. Med. Res. Rev. 16, 3–50 (1996)

[18] Connor, E. F., Lees, I., Maclean, D.: Polymers as drugs - Advances in therapeutic applications
of polymer binding agents, J. Polym. Sci., Part A: Polym. Chem., 55, 3146-3157 (2017)

[19] Miccio, L. A., Schwartz, G. A.: From chemical structure to quantitative polymer properties

prediction through convolutional neural networks. Polymer, 193, 122341 (2020)

[20] Kumar, J. N., Li, Q., Jun, Y.: Challenges and opportunities of polymer design with machine
learning and high throughput experimentation. MRS Communications, 9, 537544 (2019)

[21] Wu, S., Kondo, Y., Kakimoto, M., Yang, B., Yamada, H., Kuwajima, I., Lambard, G., Hongo,
K., Xu, Y., Shiomi, J., Schick, C., Morikawa, J., Yoshida, R.: Machine-learning-assisted
discovery of polymers with high thermal conductivity using a molecular design algorithm. npj
Computational Materials, 5, 66 (2019)

[22] David, L., Thakkar, A., Mercado, R., Engkvist, O.: Molecular representations in AI-driven

drug discovery: a review and practical guide. J. Cheminformatics, 12, 56 (2020)

[23] Akutsu, T., Nagamochi, H.: A mixed integer linear programming formulation to artiﬁcial
neural networks. Proc. of the 2nd Int. Conf. on Information Science and Systems, 215–220
(2019)

[24] Azam, N. A., Chiewvanichakorn, R., Zhang, F., Shurbevski, A., Nagamochi, H., Akutsu,
T.: A method for the inverse QSAR/QSPR based on artiﬁcial neural networks and mixed
integer linear programming. Proc. of the 13th International Joint Conference on Biomedical
Engineering Systems and Technologies – Volume 3: BIOINFORMATICS, 101–108 (2020)

[25] Zhang, F., Zhu, J., Chiewvanichakorn, R., Shurbevski, A., Nagamochi, H., Akutsu, T.: A
new integer linear programming formulation to the inverse QSAR/QSPR for acyclic chemical
compounds using skeleton trees. The 33rd International Conference on Industrial, Engineering
and Other Applications of Applied Intelligent Systems, September 22-25, 2020, Kitakyushu,
Japan, Springer LNCS 12144, 433–444 (2020)

[26] Zhu, J., Azam, N. A., Haraguchi, K., Zhao, L., Nagamochi, H., Akutsu, T.: A method
for molecular design based on linear regression and integer programming. 12th International
Conference on Bioscience, Biochemistry and Bioinformatics (ICBBB 2022), Tokyo, Japan
during January 7-10, 2022 (to appear)

[27] Azam, N. A., Zhu, J., Sun, Y., Shi, Y., Shurbevski, A., Zhao, L., Nagamochi, H., Akutsu,
T.: A novel method for inference of acyclic chemical compounds with bounded branch-
height based on artiﬁcial neural networks and integer programming. Algorithms for Molecular
Biology, 16, 18 (2021)

[28] Ito, R., Azam, N. A., Wang, C., Shurbevski, A., Nagamochi, H., Akutsu, T.: A novel method
for the inverse QSAR/QSPR to monocyclic chemical compounds based on artiﬁcial neural

2LM-M LLR polymer v23: September 7, 2021

19

networks and integer programming. BIOCOMP2020, Las Vegas, Nevada, USA, 27-30 July
(2020)

[29] Zhu, J., Wang, C., Shurbevski, A., Nagamochi, H., Akutsu, T.: A novel method for inference
of chemical compounds of cycle index two with desired properties based on artiﬁcial neural
networks and integer programming. Algorithms 13, 5, 124 (2020)

[30] Akutsu, T., Nagamochi, H.: A novel method for inference of chemical compounds with
prescribed topological substructures based on integer programming. arXiv: 2010.09203 (2020)

[31] Tanaka, K., Zhu, J., Azam, N. A., Haraguchi, K., Zhao, L., Nagamochi, H., Akutsu, T.:
An inverse QSAR method based on decision tree and integer programming. The 17th Inter-
national Conference on Intelligent Computing, August 12-15, 2021, in Shenzhen, China, In:
Huang D.S., Jo K.H., Li J., Gribova V., Hussain A. (eds) Intelligent Computing Theories and
Application, ICIC 2021, Lecture Notes in Computer Science, vol. 12837. Springer, Cham.

[32] Shi, Y., Zhu, J., Azam, N. A., Haraguchi, K., Zhao, L., Nagamochi, H., Akutsu, T.: An
inverse QSAR method based on a two-layered model and integer programming. International
Journal of Molecular Sciences 22, 2847 (2021)

[33] Ghasemi, F., Mehridehnavi, A., P´erez-Garrido, A., P´erez-S´anchez, H.: Neural network and
deep-learning algorithms used in QSAR studies: merits and drawbacks. Drug Discovery
Today 23, 1784–1790 (2018)

[34] Hoerl, A., Kennard, R.: Ridge regression. In Encyclopedia of Statistical Sciences. New York:

Wiley, 8, pp. 129–136 (1988)

[35] Tibshirani, R.: Regression shrinkage and selection via the lasso. J. R. Statist. Soc. B 58,

267–288 (1996)

[36] Bicerano, J.: Prediction of Polymer Properties. 3rd Edition, Revised and Expanded. CRC

Press (2002)

2LM-M LLR polymer v23: September 7, 2021

20

Appendix

A Linear Regressions

This section reviews the method for linear regression used by Zhu et al. [26] in the framework of
inferring chemical graphs.

For an integer p ≥ 1 and a vector x ∈ Rp, the j-th entry of x is denoted by x(j), j ∈ [1, p].
Let D be a data set of chemical graphs C with an observed value a(C) ∈ R, where we denote

by ai = a(Ci) for an indexed graph Ci.

Let f be a feature function that maps a chemical graph C to a vector f (C) ∈ RK where we
denote by xi = f (Ci) for an indexed graph Ci. For a prediction function η : RK → R, deﬁne an
error function

Err(η; D) , X
Ci∈D

(ai − η(f (Ci)))2 = X
Ci∈D

(ai − η(xi))2,

and deﬁne the coeﬃcient of determination R2(η, D) to be

R2(η, D) , 1 −

a)2 for
e
For a feature space RK, a hyperplane is deﬁned to be a pair (w, b) of a vector w ∈ RK and a
real b ∈ R. Given a hyperplane (w, b) ∈ RK+1, a prediction function ηw,b : RK → R is deﬁned by
setting

a =
e

a(C).

Err(η; D)
PCi∈D(ai −

1
|D| X
C∈D

ηw,b(x) , w · x + b = X

w(j)x(j) + b.

j∈[1,K]

We observe that such a prediction function can be represented as an ANN with an input layer
with K nodes uj, j ∈ [1, K] and an output layer with a single node v such that the weight of edge
arc (uj, v) is set to be w(j), the bias of node u is set to be b and the activation function at node
u is set to be a linear function. However, a learning algorithm for an ANN may not ﬁnd a set
of weights w(j), j ∈ [1, K] and b that minimizes the error function, since the algorithm simply
iterates modiﬁcation of the current weights and biases until it terminates at a local optima in the
minimization.

We wish to ﬁnd a hyperplane (w, b) that minimizes the error function Err(ηw,b; D). In many
cases, a feature vector f contains descriptors that do not play an essential role in constructing
a good prediction function. When we solve the minimization problem, the entries w(j) for some
descriptors j ∈ [1, K] in the resulting hyperplane (w, b) become zero, which means that these
descriptors were not necessarily important for ﬁnding a prediction function ηw,b. It is proposed that
solving the minimization with an additional penalty term τ to the error function often results in a
more number of entries w(j) = 0, reducing a set of descriptors necessary for deﬁning a prediction
function ηw,b. For an error function with such a penalty term, a Ridge function 1
2|D| Err(ηw,b; D) +
λ[Pj∈[1,K] w(j)2 + b2] [34] and a Lasso function 1
2|D| Err(ηw,b; D) + λ[Pj∈[1,K] |w(j)| + |b|] [35] are
known, where λ ∈ R is a given real number.

Given a prediction function ηw,b, we can simulate a process of computing the output ηw,b(x)
for an input x ∈ RK as an MILP M(x, y; C1) in the framework. By solving such an MILP for

2LM-M LLR polymer v23: September 7, 2021

21

a speciﬁed target value y∗, we can ﬁnd a vector x∗ ∈ RK such that ηw,b(x∗) = y∗.
Instead of
specifying a single target value y∗, we use lower and upper bounds y∗, y∗ ∈ R on the value a(C)
of a chemical graph C to be inferred. We can control the range between y∗ and y∗ for searching a
chemical graph C by setting y∗ and y∗ to be close or diﬀerent values. A desired MILP is formulated
as follows.

M(x, y; C1): An MILP formulation for the inverse problem to prediction function

constants:
- A hyperplane (w, b) with w ∈ RK and b ∈ R;
- Real values y∗, y∗ ∈ R such that y∗ < y∗;
- A set IZ of indices j ∈ [1, K] such that the j-th descriptor dcpj(C) is always an integer;
- A set I+ of indices j ∈ [1, K] such that the j-th descriptor dcpj(C) is always non-negative;
- ℓ(j), u(j) ∈ R, j ∈ [1, K]: lower and upper bounds on the jth-descriptor;
variables:
- Non-negative integer variable x(j) ∈ Z+, j ∈ IZ ∩ I+;
- Integer variable x(j) ∈ Z, j ∈ IZ \ I+;
- Non-negative real variable x(j) ∈ Z+, j ∈ I+ \ IZ;
- Real variable x(j) ∈ Z, j ∈ [1, K] \ (IZ ∪ I+);
constraints:

ℓ(j) ≤ x(j) ≤ u(j), j ∈ [1, K],

y∗ ≤ X

w(j)x(j) + b ≤ y∗,

j∈[1,K]

(1)

(2)

objective function:
none.

The number of variables and constraints in the above MILP formulation is O(K). It is not

diﬃcult to see that the above MILP is an NP-hard problem.

The entire MILP for Stage 4 consists of the two MILPs M(x, y; C1) and M(g, x; C2) with no
objective function. The latter represents the computation process of our feature function f and a
given topological speciﬁcation. See Appendix E for the details of MILP M(g, x; C2).

B A Full Description of Descriptors

Our deﬁnition of feature function is analogous with the one by Zhu et al. [26] except for a necessary
modiﬁcation due to our polymer model with link-edges.

Associated with the two functions α and β in a chemical graph C = (H, α, β), we introduce
functions ac : V (E) → (Λ \ {H}) × (Λ \ {H}) × [1, 3], cs : V (E) → (Λ \ {H}) × [1, 6] and ec : V (E) →
((Λ \ {H}) × [1, 6]) × ((Λ \ {H}) × [1, 6]) × [1, 3] in the following.

2LM-M LLR polymer v23: September 7, 2021

22

To represent a feature of the exterior of C, a chemical rooted tree in T (C) is called a fringe-

conﬁguration of C.

We also represent leaf-edges in the exterior of C. For a leaf-edge uv ∈ E(hCi) with deghCi(u) =

1, we deﬁne the adjacency-conﬁguration of e to be an ordered tuple (α(u), α(v), β(uv)). Deﬁne

Γlf
ac

, {(a, b, m) | a, b ∈ Λ, m ∈ [1, min{val(a), val(b)}]}

as a set of possible adjacency-conﬁgurations for leaf-edges.

To represent a feature of an interior-vertex v ∈ V int(C) such that α(v) = a and deghCi(v) = d
(i.e., the number of non-hydrogen atoms adjacent to v is d) in a chemical graph C = (H, α, β),
we use a pair (a, d) ∈ (Λ \ {H}) × [1, 4], which we call the chemical symbol cs(v) of the vertex
v. We treat (a, d) as a single symbol ad, and deﬁne Λdg to be the set of all chemical symbols
µ = ad ∈ (Λ \ {H}) × [1, 4].

We deﬁne a method for featuring interior-edges as follows. Let e = uv ∈ Eint(C) be an
interior-edge e = uv ∈ Eint(C) such that α(u) = a, α(v) = b and β(e) = m in a chemical graph
C = (H, α, β). To feature this edge e, we use a tuple (a, b, m) ∈ (Λ \ {H}) × (Λ \ {H}) × [1, 3],
which we call the adjacency-conﬁguration ac(e) of the edge e. We introduce a total order < over
the elements in Λ to distinguish between (a, b, m) and (b, a, m) (a 6= b) notationally. For a tuple
ν = (a, b, m), let ν denote the tuple (b, a, m).

Let e = uv ∈ Eint(C) be an interior-edge e = uv ∈ Eint(C) such that cs(u) = µ, cs(v) = µ′ and
β(e) = m in a chemical graph C = (H, α, β). To feature this edge e, we use a tuple (µ, µ′, m) ∈
Λdg×Λdg×[1, 3], which we call the edge-conﬁguration ec(e) of the edge e. We introduce a total order
< over the elements in Λdg to distinguish between (µ, µ′, m) and (µ′, µ, m) (µ 6= µ′) notationally.
For a tuple γ = (µ, µ′, m), let γ denote the tuple (µ′, µ, m).

Let π be a chemical property for which we will construct a prediction function η from a feature

vector f (C) of a chemical graph C to a predicted value y ∈ R for the chemical property of C.

We ﬁrst choose a set Λ of chemical elements and then collect a data set Dπ of chemical com-
pounds C whose chemical elements belong to Λ, where we regard Dπ as a set of chemical graphs
C that represent the chemical compounds C in Dπ. To deﬁne the interior/exterior of chemical
graphs C ∈ Dπ, we next choose a branch-parameter ρ, where we recommend ρ = 2.

Let Λint(Dπ) ⊆ Λ (resp., Λex(Dπ) ⊆ Λ) denote the set of chemical elements used in the set
V int(C) of interior-vertices (resp., the set V ex(C) of exterior-vertices) of C over all chemical graphs
C ∈ Dπ, and Γint(Dπ) (resp., Γlnk(Dπ)) denote the set of edge-conﬁgurations used in the set Eint(C)
of interior-edges (resp., the set Elnk(C) of linked-edges) in C over all chemical graphs C ∈ Dπ. Let
F (Dπ) denote the set of chemical rooted trees ψ r-isomorphic to a chemical rooted tree in T (C)
over all chemical graphs C ∈ Dπ, where possibly a chemical rooted tree ψ ∈ F (Dπ) consists of a
single chemical element a ∈ Λ \ {H}.

We deﬁne an integer encoding of a ﬁnite set A of elements to be a bijection σ : A → [1, |A|],
where we denote by [A] the set [1, |A|] of integers. Introduce an integer coding of each of the sets
Λint(Dπ), Λex(Dπ), Γint(Dπ) and F (Dπ). Let [a]int (resp., [a]ex) denote the coded integer of an
element a ∈ Λint(Dπ) (resp., a ∈ Λex(Dπ)), [γ] denote the coded integer of an element γ in Γint(Dπ)
and [ψ] denote an element ψ in F (Dπ).

We assume that a chemical graph C treated in this paper satisﬁes deghCi(v) ≤ 4 in the hydrogen-

suppressed graph hCi.

2LM-M LLR polymer v23: September 7, 2021

23

In our model, we use an integer mass∗(a) = ⌊10 · mass(a)⌋, for each a ∈ Λ.
We deﬁne the feature vector f (C) of a polymer C = (H, α, β) ∈ Dπ to be a vector that consists
of the following non-negative integer descriptors dcpi(C), i ∈ [1, K], where K = 14 + |Λint(Dπ)| +
|Λex(Dπ)| + |Γint(Dπ)| + |Γlnk(Dπ)| + |Λdg| + |F (Dπ)| + |Γlf

ac|.

1. dcp1(C): the number |V (H)| − |VH| of non-hydrogen atoms in C.

2. dcp2(C): the number |V int(C)| of interior-vertices in C.

3. dcp3(C): the number |Elnk(C)| of link-edges in C. This descriptor is newly introduced in

this paper to feature a structure of polymers.

4. dcp4(C): the average ms(C) of mass∗ over all atoms in C;
|V (H)| Pv∈V (H) mass∗(α(v)).

i.e., ms(C) , 1

5. dcpi(C), i = 4 + d, d ∈ [1, 4]: the number dg

d(C) of non-hydrogen vertices v ∈ V (H) \ VH of

H

degree deghCi(v) = d in the hydrogen-suppressed chemical graph hCi.

6. dcpi(C), i = 8 + d, d ∈ [1, 4]: the number dgint

d (C) of interior-vertices of interior-degree

degCint(v) = d in the interior Cint = (V int(C), Eint(C)) of C.

7. dcpi(C), i = 12 + m, m ∈ [2, 3]: the number bdint
m (C) , {e ∈ Eint(C) | β(e) = m}.

m in C; i.e., bdint

m (C) of interior-edges with bond multiplicity

8. dcpi(C), i = 14 + [a]int, a ∈ Λint(Dπ): the frequency naint
element a in the set V int(C) of interior-vertices in C.

a (C) = |Va(C) ∩ V int(C)| of chemical

9. dcpi(C), i = 14 + |Λint(Dπ)| + [a]ex, a ∈ Λex(Dπ): the frequency naex
of chemical element a in the set V ex(C) of exterior-vertices in C.

a (C) = |Va(C) ∩ V ex(C)|

10. dcpi(C), i = 14 + |Λint(Dπ)| + |Λex(Dπ)| + [γ], γ ∈ Γint(Dπ): the frequency ecγ(C) of edge-

conﬁguration γ in the set Eint(C) of interior-edges in C.

11. dcpi(C), i = 14 + |Λint(Dπ)| + |Λex(Dπ)| + |Γint(Dπ)| + [γ], γ ∈ Γlnk(Dπ): the frequency
ecγ(C) of edge-conﬁguration γ in the set Elnk(C) of link-edges in C. This descriptor is newly
introduced in this paper to feature link-edges of polymers.

12. dcpi(C), i = 14 + |Λint(Dπ)| + |Λex(Dπ)| + |Γint(Dπ)| + [µ], µ ∈ Λint

dg : the frequency of chemical

symbols µ = α(u) deghCi(u) of connecting-vertices u in C.

13. dcpi(C), i = 14 + |Λint(Dπ)| + |Λex(Dπ)| + |Γint(Dπ)| + |Γlnk(Dπ)| + |Λdg| + [ψ], ψ ∈ F (Dπ):

the frequency fcψ(C) of fringe-conﬁguration ψ in the set of ρ-fringe-trees in C.

14. dcpi(C), i = 14 + |Λint(Dπ)| + |Λex(Dπ)| + |Γint(Dπ)| + |Γlnk(Dπ)| + |Λdg| + |F (Dπ)| + [ν],

ν ∈ Γlf

ac: the frequency aclf

ν (C) of adjacency-conﬁguration ν in the set of leaf-edges in hCi.

2LM-M LLR polymer v23: September 7, 2021

24

C Specifying Target Chemical Graphs

Our deﬁnition of topological speciﬁcation is analogous with the one by Zhu et al. [26] except for a
necessary modiﬁcation due to our polymer model with link-edges.

Seed Graph

A seed graph for a polymer is deﬁned to be a graph GC = (VC, EC) with a speciﬁed edge subset Elnk
C
such that the edge set EC consists of four sets E(≥2), E(≥1), E(0/1) and E(=1), where each of them can
be empty, and Elnk
C ⊆ E(≥2) ∪ E(≥1) ∪ E(=1). Figure 5(a)
illustrates an example of a seed graph, where VC = {u1, u2, . . . , u14}, E(≥2) = {a1, a2, a3, a4},
E(≥1) = {a5, a6, . . . , a9}, E(0/1) = {a10}, E(=1) = {a11, a12, . . . , a18} and Elnk

C is a circular set in GC such that ∅ 6= Elnk

C = {a1, a2}.

A subdivision S of GC is a graph constructed from a seed graph GC according to the following

rules:

- Each edge e = uv ∈ E(≥2) is replaced with a u, v-path Pe of length at least 2;

- Each edge e = uv ∈ E(≥1) is replaced with a u, v-path Pe of length at least 1 (equivalently e is

directly used or replaced with a u, v-path Pe of length at least 2);

- Each edge e ∈ E(0/1) is either used or discarded; and

- Each edge e ∈ E(=1) is always used directly.

The set of link-edges in the monomer representation C of an inferred polymer consists of edges
C ∩ (E(=1) ∪ E(≥1)) or edges in paths Pe for all edges e = uv ∈ Elnk
C ∩ (E(≥1) ∪ E(≥2)) in a

in Elnk
subdivision S of GC.

A target chemical graph C = (H, α, β) will contain S as a subgraph of the interior H int of C.

Interior-speciﬁcation

A graph H ∗ that serves as the interior H int of a target chemical graph C will be constructed as
follows. First construct a subdivision S of a seed graph GC by replacing each edge e = uu′ ∈
E(≥2) ∪ E(≥1) with a pure u, u′-path Pe. Next construct a supergraph H ∗ of S by attaching a leaf
path Qv at each vertex v ∈ VC or at an internal vertex v ∈ V (Pe) \ {u, u′} of each pure u, u′-path
Pe for some edge e = uu′ ∈ E(≥2) ∪ E(≥1), where possibly Qv = (v), E(Qv) = ∅ (i.e., we do not
attach any new edges to v). We introduce the following rules for specifying the size of H ∗, the
length |E(Pe)| of a pure path Pe, the length |E(Qv)| of a leaf path Qv, the number of leaf paths
Qv and a bond-multiplicity of each interior-edge, where we call the set of prescribed constants an
interior-speciﬁcation σint:

- Lower and upper bounds nint

LB, nint

UB ∈ Z+ on the number of interior-vertices of a target chemical

graph C.

- Lower and upper bounds nlnk

LB, nlnk

UB ∈ Z+ on the number of link-edges of a target chemical

graph C.

2LM-M LLR polymer v23: September 7, 2021

25

- For each edge e = uu′ ∈ E(≥2) ∪ E(≥1),

a lower bound ℓLB(e) and an upper bound ℓUB(e) on the length |E(Pe)| of a pure u, u′-path
Pe. (For a notational convenience, set ℓLB(e) := 0, ℓUB(e) := 1, e ∈ E(0/1) and ℓLB(e) := 1,
ℓUB(e) := 1, e ∈ E(=1).)

a lower bound blLB(e) and an upper bound blUB(e) on the number of leaf paths Qv attached

at internal vertices v of a pure u, u′-path Pe.

a lower bound chLB(e) and an upper bound chUB(e) on the maximum length |E(Qv)| of a leaf

path Qv attached at an internal vertex v ∈ V (Pe) \ {u, u′} of a pure u, u′-path Pe.

- For each vertex v ∈ VC,

a lower bound chLB(v) and an upper bound chUB(v) on the number of leaf paths Qv attached

to v, where 0 ≤ chLB(v) ≤ chUB(v) ≤ 1.

a lower bound chLB(v) and an upper bound chUB(v) on the length |E(Qv)| of a leaf path Qv

attached to v.

- For each edge e = uu′ ∈ EC, a lower bound bdm,LB(e) and an upper bound bdm,UB(e) on
the number of edges with bond-multiplicity m ∈ [2, 3] in u, u′-path Pe, where we regard Pe,
e ∈ E(0/1) ∪ E(=1) as single edge e.

We call a graph H ∗ that satisﬁes an interior-speciﬁcation σint a σint-extension of GC, where the

bond-multiplicity of each edge has been determined.

Table 4 shows an example of an interior-speciﬁcation σint to the seed graph GC in Figure 5.
Figure 6 illustrates an example of an σint-extension H ∗ of seed graph GC in Figure 5(a) under

the interior-speciﬁcation σint in Table 4.

Chemical-speciﬁcation

Let H ∗ be a graph that serves as the interior H int of a target chemical graph C, where the
bond-multiplicity of each edge in H ∗ has be determined. Finally we introduce a set of rules
for constructing a target chemical graph C from H ∗ by choosing a chemical element a ∈ Λ and
assigning a ρ-fringe-tree ψ to each interior-vertex v ∈ V int. We introduce the following rules for
specifying the size of C, a set of chemical rooted trees that are allowed to use as ρ-fringe-trees
and lower and upper bounds on the frequency of a chemical element, a chemical symbol, an edge-
conﬁguration, and a fringe-conﬁguration where we call the set of prescribed constants a chemical
speciﬁcation σce:

- Lower and upper bounds nLB, n∗ ∈ Z+ on the number of vertices, where nint

LB ≤ nLB ≤ n∗.

- A subset F ∗ ⊆ F (Dπ) of chemical rooted trees ψ with ht(hψi) ≤ ρ, where we require that every
ρ-fringe-tree C[v] rooted at an interior-vertex v in C belongs to F ∗. Let Λex denote the set of
chemical elements assigned to non-root vertices over all chemical rooted trees in F ∗.

2LM-M LLR polymer v23: September 7, 2021

26

Table 4: Example 1 of an interior-speciﬁcation σint.

LB = 20 nint
nint

a9
1
6
0
1
0
0

a2
4
6
1
4
2
6

LB = 2 nlnk
UB = 30 nlnk
UB = 24
a7
a6
a5
a4
a3
1
1
2
2
3
6
3
3
5
6
0
0
0
0
1
1
1
2
3
4
0
0
0
0
1
3
3
3
3
6

a8
a1
1
2
2
3
0
0
1
1
0
0
3
0
u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14
0
0
0
1
1
1
0
0
0
4
4
4
a14
a8
a1
1
0
0
1
1
1
0
0
0
1
1
1

0
1
0
4
a2
0
2
0
1

0
1
0
4
a11
0
1
0
1

0
1
0
4
a12
0
1
0
1

0
1
0
4
a10
0
1
0
1

0
1
0
4
a13
0
1
0
1

0
1
0
4
a3
0
1
0
1

0
1
0
4
a4
0
1
0
1

0
1
0
4
a5
0
1
0
1

0
1
0
4
a6
0
1
0
1

0
1
0
4
a7
0
1
0
1

1
1
1
6
a9
0
1
0
1

ℓLB(ai)
ℓUB(ai)
blLB(ai)
blUB(ai)
chLB(ai)
chUB(ai)

blLB(ui)
blUB(ui)
chLB(ui)
chUB(ui)

bd2,LB(ai)
bd2,UB(ai)
bd3,LB(ai)
bd3,UB(ai)

a15
0
1
0
1

a16
0
1
0
1

a17
0
1
0
1

a18
0
1
0
1

- A subset Λint ⊆ Λint(Dπ), where we require that every chemical element α(v) assigned to an
a (C) and
a (C)) denote the number of vertices (resp., interior-vertices and exterior-vertices) v such

interior-vertex v in C belongs to Λint. Let Λ := Λint ∪ Λex and naa(C) (resp., naint
naex
that α(v) = a in C.

- A set Λint

dg ⊆ Λ × [1, 4] of chemical symbols.

- Subsets Γlnk ⊆ Γint of Γint(Dπ) of edge-conﬁgurations (µ, µ′, m) with µ ≤ µ′, where we require
that the edge-conﬁguration ec(e) of an interior-edge (resp., a link-edge) e in C belongs to Γint
(resp., Γlnk). We do not distinguish (µ, µ′, m) and (µ′, µ, m).

- Deﬁne Γint

ac (resp., Γlnk

(ad, bd′, m) ∈ Γt}, t ∈ {int, lnk}. Let acint
number of interior-edges (resp., link-edges) e such that ac(e) = ν in C.

ac ) to be the set of adjacency-conﬁgurations such that Γt
ν (C), ν ∈ Γint

ac (resp., aclnk

ν (C), ν ∈ Γlnk

ac := {(a, b, m) |
ac ) denote the

- Subsets Λ∗(v) ⊆ {a ∈ Λint | val(a) ≥ 2}, v ∈ VC, we require that every chemical element α(v)

assigned to a vertex v ∈ VC in the seed graph belongs to Λ∗(v).

- Lower and upper bound functions naLB, naUB : Λ → [0, n∗] and naint

LB, naint

UB : Λint → [0, n∗] on

the number of interior-vertices v such that α(v) = a in C.

- Lower and upper bound functions nsint

LB, nsint

UB : Λint

dg → [0, n∗] on the number of interior-vertices

v such that cs(v) = µ in C.

2LM-M LLR polymer v23: September 7, 2021

27

- Lower and upper bound functions nscnt

LB, nscnt

UB : Λint

dg → [0, 2] on the number of connecting-vertices

v such that cs(v) = µ in C.

- Lower and upper bound functions acint

LB, aclnk
number of interior-edges (resp., link-edges) e such that ac(e) = ν in C.

ac → Z+ (aclnk

UB : Γint

LB, acint

UB : Γlnk

ac → Z+) on the

- Lower and upper bound functions ecint

LB, ecint

UB : Γint → Z+ (resp., eclnk

LB, eclnk

UB : Γlnk → Z+) on the

number of interior-edges (resp., link-edges) e such that ec(e) = γ in C.

- Lower and upper bound functions fcLB, fcUB : F ∗ → [0, n∗] on the number of interior-vertices v

such that C[v]fr is r-isomorphic to ψ ∈ F ∗ in C.

- Lower and upper bound functions aclf
acC with adjacency-conﬁguration ν.

LB, aclf

UB : Γlf

ac → [0, n∗] on the number of leaf-edges uv in

We call a chemical graph C that satisﬁes a chemical speciﬁcation σce a (σint, σce)-extension of

GC, and denote by G(GC, σint, σce) the set of all (σint, σce)-extensions of GC.

Table 5 shows an example of a chemical-speciﬁcation σce to the seed graph GC in Figure 5.
Figure 3 illustrates an example of a (σint, σce)-extension of GC obtained from the σint-extension

H ∗ in Figure 6 under the chemical-speciﬁcation σce in Table 5.

2LM-M LLR polymer v23: September 7, 2021

28

Table 5: Example 2 of a chemical-speciﬁcation σce.

nLB = 30, n∗ = 50.
branch-parameter: ρ = 2
Each of sets F (v), v ∈ VC and FE is set to be
the set F of chemical rooted trees ψ with ht(hψi) ≤ ρ = 2 in Figure 5(b).
Λ = {H, C, N, O, S(2), S(6), P = P(6), Cl} Λint
Γint
ac
Γint

dg = {C2, C3, C4, N2, N3, O2, S(2)2, S(6)3, P4}

ν1 = (C, C, 1), ν2 = (C, C, 2), ν3 = (C, N, 1), ν4 = (C, O, 1), ν5 = (C, S(2), 1), ν6 = (C, S(6), 1), ν7 = (C, P, 1)
γ1 = (C2, C2, 1), γ2 = (C2, C2, 2), γ3 = (C2, C3, 1), γ4 = (C2, C3, 2), γ5 = (C2, C4, 1), γ6 = (C3, C3, 1),
γ7 = (C3, C3, 2), γ8 = (C3, C4, 1), γ9 = (C2, N3, 1), γ10 = (C3, N2, 1), γ11 = (C4, N2, 1), γ12 = (C2, O2, 1),
γ13 = (C3, O2, 1), γ14 = (C2, S(2)2, 1), γ15 = (C3, S(2)2, 1), γ16 = (C4, S(2)2, 1), γ17 = (C3, S(6)3, 1),
γ18 = (C4, S(6)3, 1), γ19 = (C2, P4, 1), γ20 = (C3, P4, 1)
1 = (C, C, 1), ν′
ν′
1 = (C2, C2, 1), γ′
γ′
7 = (C3, N2, 1), γ′
γ′

2 = (C2, C3, 1), γ′
8 = (C2, S(2)2, 1), γ′

9 = (C3, S(2)2, 1), γ′

10 = (C4, S(2)2, 1)

5 = (C3, C3, 2), γ′

4 = (C3, C3, 1), γ′

3 = (C2, C4, 1), γ′

6 = (C2, N3, 1),

2 = (C, C, 2), ν′

3 = (C, N, 1), ν′

4 = (C, S(2), 1)

Γlnk
ac
Γlnk

Λ∗(ui) = {C}, i ∈ {1, 2, 3, 4, 5, 6, 9}, Λ∗(u8) = {O}, Λ∗(u12) = {C, P},
Λ∗(ui) = {C, O, N}, i ∈ [1, 14] \ {1, 2, 3, 4, 5, 6, 8, 9, 12}
N O S(2)
0
1
1
4
8
8

naLB(a)
naUB(a)

S(6)
0
4

naint
naint

P Cl

10
25

N O S(2)
0
0
1
2
5
4

C

H

C

S(6)
0
2

P

0
2

0
1

0
1

0
4

0
4

0
5

0
3

0
1

0
5

0
5

0
1

25
50

5
15

LB(a)
40
UB(a)
80
C2 C3 C4 N2 N3 O2 S(2)2 S(6)3 P4
0
3
1
12
C2 C3 C4 N2 N3 O2 S(2)2 S(6)3 P4
0
0
0
2
ν1
0
30
γ1
0
4
ν′
1
LB(γ′)
0
UB(γ′)
10
ψ ∈ {ψi | i = 1, 6, 11} ψ ∈ F ∗ \ {ψi | i = 1, 6, 11}

0
2
ν6
0
3
γi, i ∈ [6, 13] γi, i ∈ [14, 20]

γ′
i, i ∈ [1, 10]
0
4

0
2
ν2
0
10
γ2
0
15
ν′
2
0
5

0
2
ν4
0
10
γ4
0
5
ν′
4
0
5

0
2
ν3
0
10
γ3
0
5
ν′
3
0
5

0
2
ν5
0
2
γ5
0
10

eclnk
eclnk

ν7
0
3

0
5

0
2

1
10

0
3

ν ∈ {(C, C, 1), (C, C, 2)} ν ∈ Γlf

ac \ {(C, C, 1), (C, C, 2)}

0
10

0
8

nsint
nsint

LB(µ)
UB(µ)

nscnt
nscnt

LB(µ)
UB(µ)

acint
acint

LB(ν)
UB(ν)

ecint
ecint

LB(γ)
UB(γ)

aclnk
aclnk

LB(ν′)
UB(ν′)

fcLB(ψ)
fcUB(ψ)

aclf
aclf

LB(ν)
UB(ν)

2LM-M LLR polymer v23: September 7, 2021

29

D Test Instances for Stages 4 and 5

We prepared the following instances Ia and Ib for conducting experiments of Stages 4 and 5 in
Phase 2.

In Stages 4 and 5, we use four properties π ∈ {AmD, HcL, RfId, Tg} and deﬁne a set
Λ(π) of chemical elements as follows: Λ(AmD) = Λ4 = {H, C, N, O, Cl, S(2)}, Λ(HcL) = Λ(Tg) =
Λ5 = {H, C, O, N, Cl, S(2), S(6)}, Λ(RfId) = Λ6 = {H, C, O(1), O(2), N, Cl, Si(4), F} and Λ(Prm) = Λ3 =
{H, C, O, N, Cl}.

(a) Ia = (GC, σint, σce): The instance used in Appendix C to explain the target speciﬁcation. For

each property π ∈ {AmD, HcL, RfId, Tg, Prm}, we replace Λ = {H, C, N, O, S(2), S(6), P(5), Cl}
in Table 5 with Λ(π) ∩ {S(2), S(6), P(5), Cl} and remove from the σce all chemical symbols,
edge-conﬁgurations and fringe-conﬁgurations that cannot be constructed from the replaced
element set (i.e., those containing a chemical element in {S(2), S(6), P(5), Cl} \ Λ(π)).

LB := 14, nint

dg to be the set of

UB := n∗ := nLB + 10, nlnk

(b) Ib = (GC, σint, σce): An instance that represents a set of polymers that includes the four
examples of polymers in Fig. 7. We set a seed graph GC = (VC, EC = E(=1)) to be the
graph with two cycles C1 and C2 in Fig. 8(a), where we set E(≥2) = Elnk
C = {a1, a2} and
E(=1) = {a3, a12, . . . , a14}.
Set Λ := Λ(π) for each property π ∈ {AmD, HcL, RfId, Tg}, and set Λint
all possible chemical symbols in Λ × [1, 4].
Set Γint (resp., Γlnk) to be the set of edge-conﬁgurations of the interior-edges (resp., the link-
edges) used in the four examples of polymers in Fig. 7. Set Γint
ac (resp., Γlnk
ac ) to be the set of
the adjacency-conﬁgurations of the edge-conﬁgurations in Γint (resp., Γlnk).
We specify nLB for each property π and set nint
nlnk
UB := 2 + max{nLB − 15, 0}.
For each link-edge ai ∈ E(≥2) = Elnk
C = {a1, a2}, set ℓLB(ai) := 2 + max{⌊(nLB − 15)/4⌋, 0},
ℓUB(ai) := ℓLB(ai)+5, blLB(ai) := 0, blUB(ai) := 3, chLB(ai) := 0, chUB(ai) := 5, bd2,LB(ai) :=
0 and bd2,UB(ai) := ⌊ℓLB(ai)/3⌋.
To form two benzene rings from the two cycles C1 and C2, set Λ∗(u) := {C}, blLB(u) :=
blUB(u) := chLB(u) := chUB(u) := 0, u ∈ VC, bd2,LB(ai) := bd2,UB(ai) := 0, i ∈ {3, 5, 7, 9, 11, 13},
bd2,LB(ai) := bd2,UB(ai) := 1, i ∈ {4, 6, 8, 10, 12, 14}.
Not to include any triple-bond, set bd3,LB(a) := bd3,UB(a) := 0, a ∈ EC.
LB and aclf
LB, nscnt
Set lower bounds naLB, naint
Set upper bounds naUB(a) := n∗, na ∈ {H, C}, naUB(a) := 5 + max{nLB − 15, 0}, a ∈ {O, N},
naUB(a) := 2 + max{⌊(nLB − 15)/4⌋, 0}, a ∈ Λ \ {H, C, O, N}, nscnt
dg , and naint
UB,
UB and aclf
nsint
Set F to be the set of the 17 chemical rooted trees ψi, i ∈ [1, 17] in Fig. 8(b). Set FE :=
F (v) := F , v ∈ VC and fcLB(ψ) := 0, ψ ∈ F , fcUB(ψi) := 12 + max{nLB − 15, 0}, i ∈ [1, 4],
fcUB(ψi) := 8 + max{⌊(nLB − 15)/2⌋, 0}, i ∈ [5, 12] and fcUB(ψi) := 5 + max{⌊(nLB −
15)/4⌋, 0}, i ∈ [13, 17], ψi ∈ F .

UB(µ) := 2, µ ∈ Λint

UB to be n∗.

LB to be 0.

UB, aclnk

UB, eclnk

LB, aclnk

UB, acint

LB, eclnk

LB, acint

LB, nsint

LB, ecint

LB, ecint

LB := 2,

2LM-M LLR polymer v23: September 7, 2021

30

E All Constraints in an MILP Formulation for Chemical

Graphs

Our deﬁnition of an MILP formulation MILP M(g, x; C2) is analogous with the one by Zhu et al. [26]
except for a necessary modiﬁcation due to our polymer model with link-edges.

We deﬁne a standard encoding of a ﬁnite set A of elements to be a bijection σ : A → [1, |A|],
where we denote by [A] the set [1, |A|] of integers and by [e] the encoded element σ(e). Let ǫ
denote null, a ﬁctitious chemical element that does not belong to any set of chemical elements,
chemical symbols, adjacency-conﬁgurations and edge-conﬁgurations in the following formulation.
Given a ﬁnite set A, let Aǫ denote the set A ∪ {ǫ} and deﬁne a standard encoding of Aǫ to be a
bijection σ : A → [0, |A|] such that σ(ǫ) = 0, where we denote by [Aǫ] the set [0, |A|] of integers
and by [e] the encoded element σ(e), where [ǫ] = 0.

Let σ = (GC, σint, σce) be a target speciﬁcation, ρ denote the branch-parameter in the speciﬁ-

cation σ and C denote a chemical graph in G(GC, σint, σce).

E.1 Selecting a Cyclical-base

Recall that

E(=1) = {e ∈ EC | ℓLB(e) = ℓUB(e) = 1};
E(≥1) = {e ∈ EC | ℓLB(e) = 1, ℓUB(e) ≥ 2}; E(≥2) = {e ∈ EC | ℓLB(e) ≥ 2};

E(0/1) = {e ∈ EC | ℓLB(e) = 0, ℓUB(e) = 1};

A subset Elnk
tation C of an inferred polymer.

C ⊆ E(=1) ∪ E(≥1) ∪ E(≥2) is given for introducing link-edges in the monomer represen-

- Every edge ai ∈ E(=1) is included in hCi;

- Each edge ai ∈ E(0/1) is included in hCi if necessary;

- For each edge ai ∈ E(≥2), edge ai is not included in hCi and instead a path

Pi = (vC

tail(i), vT

j−1, vT

j, . . . , vT

j+t, vC

head(i))

of length at least 2 from vertex vC
structed in hCi; and

tail(i) to vertex vC

head(i) visiting some vertices in VT is con-

- For each edge ai ∈ E(≥1), either edge ai is directly used in hCi or the above path Pi of length

at least 2 is constructed in hCi.

Let tC , |VC| and denote VC by {vC
i | i ∈ [1, tC]}. Regard the seed graph GC as a digraph
j′ when j < j′.
such that each edge ai with end-vertices vC
j and vC
For each directed edge ai ∈ EC, let head(i) and tail(i) denote the head and tail of eC(i); i.e.,
ai = (vC

j′ is directed from vC

j to vC

tail(i), vC

head(i)).

Deﬁne

kC , |E(≥2) ∪ E(≥1)|,

kC , |E(≥2)|,
f

2LM-M LLR polymer v23: September 7, 2021

31

and denote EC = {ai | i ∈ [1, mC]},

E(≥2) = {ak | k ∈ [1,

kC]}, E(≥1) = {ak | k ∈ [
f

kC + 1, kC]},
f

E(0/1) = {ai | i ∈ [kC + 1, kC + |E(0/1)|]} and E(=1) = {ai | i ∈ [kC + |E(0/1)| + 1, mC]}.

Let I(=1) denote the set of indices i of edges ai ∈ E(=1). Similarly for I(0/1), I(≥1) and I(≥2). Let
Ilnk denote the set of indices i of edges ai ∈ Elnk
C .

To control the construction of such a path Pi for each edge ak ∈ E(≥2) ∪ E(≥1), we regard the
index k ∈ [1, kC] of each edge ak ∈ E(≥2) ∪ E(≥1) as the “color” of the edge. To introduce necessary
linear constraints that can construct such a path Pk properly in our MILP, we assign the color k
to the vertices vT

j+t in VT when the above path Pk is used in hCi.

j, . . . , vT

j−1, vT

(=1)(s) (resp., E−

s. Similarly for E+

For each index s ∈ [1, tC], let IC(s) denote the set of edges e ∈ EC incident to vertex vC

and E+
of ai is vertex vC
Let IC(s) denote the set of indices i of edges ai ∈ IC(s). Similarly for I +
I −
(0/1)(s), I +
(≥1)(s), I −
I(≥1) ∪ I(0/1) ∪ I(=1).
constants:

s,
(=1)(s)) denote the set of edges ai ∈ E(=1) such that the tail (resp., head)
(≥2)(s).
(0/1)(s),
kC + 1, mC] =
f

(=1)(s), I −
(≥2)(s). Note that [1, kC] = I(≥2) ∪ I(≥1) and [

(≥2)(s) and E−
(=1)(s), I +

(≥2)(s) and I −

(0/1)(s), E−

(0/1)(s), E+

(≥1)(s), E−

(≥1)(s), E+

(≥1)(s), I +

- n∗ ∈ Z: an upper bound on the number n(C) of non-hydrogen atoms in C;

- tC = |VC|,

kC = |E(≥2)|, kC = |E(≥2) ∪ E(≥1)|, tT = nint
f

ai ∈ EC \ (E(≥2) ∪ E(≥1)) holds i ∈ [kC + 1, mC];

UB − |VC|, mC = |EC|. Note that

- ℓLB(k), ℓUB(k) ∈ [1, tT], k ∈ [1, kC]: lower and upper bounds on the length of path Pk;

- n(=1)
lnk = |Ilnk ∩ E(=1)| = |Ilnk ∩ {[kC + |E(0/1)| + 1, mC}|: the number of link-edges created from
E(=1);

- nlnk

LB, nlnk

UB ∈ [0, n∗]: lower and upper bounds on the number of link-edges of a target polymer C;

variables:

- eC(i) ∈ [0, 1], i ∈ [1, mC]: eC(i) represents edge ai ∈ EC, i ∈ [1, mC] (eC(i) = 1, i ∈ I(=1);

eC(i) = 0, i ∈ I(≥2)) (eC(i) = 1 ⇔ edge ai is used in hCi);

- vT(i) ∈ [0, 1], i ∈ [1, tT]: vT(i) = 1 ⇔ vertex vT

i is used in hCi;

- eT(i) ∈ [0, 1], i ∈ [1, tT + 1]: eT(i) represents edge eT

i−1, vT

i) ∈ ET, where eT

1 and eT

tT+1

are ﬁctitious edges (eT(i) = 1 ⇔ edge eT

i = (vT
i is used in hCi);

- χT(i) ∈ [0, kC], i ∈ [1, tT]: χT(i) represents the color assigned to vertex vT
i is assigned color k; χT(i) = 0 means that vertex vT

vertex vT

i is not used in hCi);

i (χT(i) = k > 0 ⇔

- clrT(k) ∈ [ℓLB(k) − 1, ℓUB(k) − 1], k ∈ [1, kC], clrT(0) ∈ [0, tT]: the number of vertices vT

i ∈ VT

with color c;

2LM-M LLR polymer v23: September 7, 2021

- δT

χ (k) ∈ [0, 1], k ∈ [0, kC]: δT

χ (k) = 1 ⇔ χT(i) = k for some i ∈ [1, tT];

- χT(i, k) ∈ [0, 1], i ∈ [1, tT], k ∈ [0, kC] (χT(i, k) = 1 ⇔ χT(i) = k);

+
C(i) ∈ [0, 4], i ∈ [1, tC]: the out-degree of vertex vC
−
C(i) ∈ [0, 4], i ∈ [1, tC]: the in-degree of vertex vC

i with the used edges eC in EC;

i with the used edges eC in EC;

-

-

deg
g
deg
g

- nlnk ∈ [nlnk

LB, nlnk

UB]: the number of link-edges in C;

constraints:

eC(i) + clrT(i) ≥ 1,

eC(i) = 1,
eC(i) = 0, clrT(i) ≥ 1,
clrT(i) ≤ tT · (1 − eC(i)),

i ∈ I(=1),
i ∈ I(≥2),
i ∈ I(≥1),

32

(3)

(4)

(5)

c∈I −

(≥1)(i)∪I −

X
(0/1)(i)∪I −

(=1)(i)

eC(c) =

−
C(i),

deg
g

c∈I +

(≥1)(i)∪I +

X
(0/1)(i)∪I +

(=1)(i)

eC(c) =

+
C(i),

deg
g

i ∈ [1, tC],

(6)

χT(i, 0) = 1 − vT(i), X
k∈[0,kC]

χT(i, k) = 1, X
k∈[0,kC]

k · χT(i, k) = χT(i),

i ∈ [1, tT],

(7)

χT(i, k) = clrT(k),

X
i∈[1,tT]

tT · δT

χ (k) ≥ X
i∈[1,tT]

χT(i, k) ≥ δT

χ (k),

k ∈ [0, kC],

(8)

vT(i − 1) ≥ vT(i),
kC · (vT(i − 1) − eT(i)) ≥ χT(i − 1) − χT(i) ≥ vT(i − 1) − eT(i),

i ∈ [2, tT],

(9)

(clrT(k) + 1) + n(=1)

lnk = nlnk.

X
k∈Ilnk∩[1,kC]

(10)

E.2 Constraints for Including Leaf Paths

Let
{u1, u2, . . . , up} so that

tC denote the number of vertices u ∈ VC such that blUB(u) = 1 and assume that VC =
e

Deﬁne the set of colors for the vertex set {ui | i ∈ [1,

blUB(ui) = 1, i ∈ [1,

tC] and blUB(ui) = 0, i ∈ [
e

tC + 1, tC].
e
tC]} ∪ VT to be [1, cF] with
e

cF ,

tC + tT = |{ui | i ∈ [1,
e

tC]} ∪ VT|.
e

i, i ∈ [1,

Let each vertex vC
tC] (resp., vT
e
[1, cF]). When a path P = (u, vF
j, vF
assign the color i ∈ [1, cF] of the vertex u to the vertices vF
constants:

j+1, . . . , vF

i ∈ VT) correspond to a color i ∈ [1, cF] (resp., i +

tC ∈
e
j+t) from a vertex u ∈ VC ∪ VT is used in hCi, we

j, vF

j+1, . . . , vF

j+t ∈ VF.

2LM-M LLR polymer v23: September 7, 2021

33

- cF: the maximum number of diﬀerent colors assigned to the vertices in VF;

- nint

LB, nint

UB ∈ [2, n∗]: lower and upper bounds on the number of interior-vertices in C;

- blLB(i) ∈ [0, 1], i ∈ [1,
rooted at a vertex vC
i;

tC]: a lower bound on the number of leaf ρ-branches in the leaf path
e

- blLB(k), blUB(k) ∈ [0, ℓUB(k) − 1], k ∈ [1, kC] = I(≥2) ∪ I(≥1):

lower and upper bounds on the
number of leaf ρ-branches in the trees rooted at internal vertices of a pure path Pk for an edge
ak ∈ E(≥1) ∪ E(≥2);

variables:

- nint

G ∈ [nint

LB, nint

UB]: the number of interior-vertices in C;

- vF(i) ∈ [0, 1], i ∈ [1, tF]: vF(i) = 1 ⇔ vertex vF

i is used in C;

- eF(i) ∈ [0, 1], i ∈ [1, tF + 1]: eF(i) represents edge eF

i = vF

i−1vF

i, where eF

1 and eF

ﬁctitious edges (eF(i) = 1 ⇔ edge eF

i is used in C);

tF+1 are

- χF(i) ∈ [0, cF], i ∈ [1, tF]: χF(i) represents the color assigned to vertex vF

i (χF(i) = c ⇔ vertex

vF

i is assigned color c);

- clrF(c) ∈ [0, tF], c ∈ [0, cF]: the number of vertices vF

i with color c;

- δF

χ (c) ∈ [blLB(c), 1], c ∈ [1,

χ (c) = 1 ⇔ χF(i) = c for some i ∈ [1, tF];

tC]: δF
e

- δF

χ (c) ∈ [0, 1], c ∈ [

χ (c) = 1 ⇔ χF(i) = c for some i ∈ [1, tF];

tC + 1, cF]: δF
e

- χF(i, c) ∈ [0, 1], i ∈ [1, tF], c ∈ [0, cF]: χF(i, c) = 1 ⇔ χF(i) = c;

- bl(k, i) ∈ [0, 1], k ∈ [1, kC] = I(≥2) ∪ I(≥1), i ∈ [1, tT]: bl(k, i) = 1 ⇔ path Pk contains vertex vT

i

as an internal vertex and the ρ-fringe-tree rooted at vT

i contains a leaf ρ-branch;

constraints:

χF(i, 0) = 1 − vF(i), X
c∈[0,cF]

χF(i, c) = 1, X
c∈[0,cF]

c · χF(i, c) = χF(i),

i ∈ [1, tF],

(11)

χF(i, c) = clrF(c),

X
i∈[1,tF]

tF · δF

χ (c) ≥ X
i∈[1,tF]

χF(i, c) ≥ δF

χ (c),

c ∈ [0, cF],

(12)

eF(1) = eF(tF + 1) = 0,

(13)

vF(i − 1) ≥ vF(i),
cF · (vF(i − 1) − eF(i)) ≥ χF(i − 1) − χF(i) ≥ vF(i − 1) − eF(i),

i ∈ [2, tF],

(14)

2LM-M LLR polymer v23: September 7, 2021

bl(k, i) ≥ δF
χ (

tC + i) + χT(i, k) − 1,
e

k ∈ [1, kC], i ∈ [1, tT],

X
k∈[1,kC],i∈[1,tT]

bl(k, i) ≤ X
i∈[1,tT]

δF
χ (

tC + i),
e

blLB(k) ≤ X
i∈[1,tT]

bl(k, i) ≤ blUB(k),

k ∈ [1, kC],

tC + X
i∈[1,tT]

vT(i) + X
i∈[1,tF]

vF(i) = nint
G .

E.3 Constraints for Including Fringe-trees

34

(15)

(16)

(17)

(18)

Recall that F (Dπ) denotes the set of chemical rooted trees ψ r-isomorphic to a chemical rooted
tree in T (C) over all chemical graphs C ∈ Dπ, where possibly a chemical rooted tree ψ ∈ F (Dπ)
consists of a single chemical element a ∈ Λ \ {H}.

To express the condition that the ρ-fringe-tree is chosen from a rooted tree Ci, Ti or Fi, we

introduce the following set of variables and constraints.

constants:

- nLB: a lower bound on the number n(C) of non-hydrogen atoms in C, where nLB, n∗ ≥ nint
LB;

- chLB(i), chUB(i) ∈ [0, n∗], i ∈ [1, tT]: lower and upper bounds on ht(hTii) of the tree Ti rooted

at a vertex vC

i;

- chLB(k), chUB(k) ∈ [0, n∗], k ∈ [1, kC] = I(≥2) ∪ I(≥1): lower and upper bounds on the maximum
height ht(hT i) of the tree T ∈ F (Pk) rooted at an internal vertex of a path Pk for an edge
ak ∈ E(≥1) ∪ E(≥2);

- Prepare a coding of the set F (Dπ) and let [ψ] denote the coded integer of an element ψ in

F (Dπ);

- Sets F (v) ⊆ F (Dπ), v ∈ VC and FE ⊆ F (Dπ) of chemical rooted trees T with ht(T ) ∈ [1, ρ];

- Deﬁne F ∗ := Sv∈VC

i ∈ [1, tF];

F (v) ∪ FE, F C
i

:= F (vC

i), i ∈ [1, tC], F T
i

:= FE, i ∈ [1, tT] and F F
i

:= FE,

- fcLB(ψ), fcUB(ψ) ∈ [0, n∗], ψ ∈ F ∗: lower and upper bound functions on the number of interior-

vertices v such that C[v] is r-isomorphic to ψ in C;

- F X

i [p], p ∈ [1, ρ], X ∈ {C, T, F}: the set of chemical rooted trees T ∈ F X

i with ht(hT i) = p;

2LM-M LLR polymer v23: September 7, 2021

35

- nH([ψ]) ∈ [0, 3ρ], ψ ∈ F ∗: the number n(hψi) of non-root hydrogen vertices in a chemical rooted

tree ψ;

- htH([ψ]) ∈ [0, ρ], ψ ∈ F ∗: the height ht(hψi) of the hydrogen-suppressed chemical rooted tree

hψi;

- deg

H
r ([ψ]) ∈ [0, 3], ψ ∈ F ∗: the number degr(hψi) of non-hydrogen children of the root r of a

chemical rooted tree ψ;

- deghyd

r

([ψ]) ∈ [0, 3], ψ ∈ F ∗: the number degr(ψ) − degr(hψi) of hydrogen children of the root r

of a chemical rooted tree ψ;

- vion(ψ) ∈ [−3, +3], ψ ∈ F ∗: the ion-valence of the root in ψ;

- aclf

ν (ψ), ν ∈ Γlf

ac: the frequency of leaf-edges with adjacency-conﬁguration ν in ψ;

- aclf

LB, aclf

UB : Γlf

ac → [0, n∗]: lower and upper bound functions on the number of leaf-edges uv in

acC with adjacency-conﬁguration ν;

variables:

- nG ∈ [nLB, n∗]: the number n(C) of non-hydrogen atoms in C;

- vX(i) ∈ [0, 1], i ∈ [1, tX], X ∈ {T, F}: vX(i) = 1 ⇔ vertex vX

i is used in C;

- δX

fr (i, [ψ]) ∈ [0, 1], i ∈ [1, tX], ψ ∈ F X
rooted at vertex vX

i in C;

i , X ∈ {C, T, F}: δX

fr (i, [ψ]) = 1 ⇔ ψ is the ρ-fringe-tree

- fc([ψ]) ∈ [fcLB(ψ), fcUB(ψ)], ψ ∈ F ∗: the number of interior-vertices v such that C[v] is r-

isomorphic to ψ in C;

- aclf([ν]) ∈ [aclf

LB(ν), aclf

UB(ν)], ν ∈ Γlf

ac: the number of leaf-edge with adjacency-conﬁguration ν

in C;

- degex

X (i) ∈ [0, 3], i ∈ [1, tX], X ∈ {C, T, F}: the number of non-hydrogen children of the root of

the ρ-fringe-tree rooted at vertex vX

i in C;

- hyddegX(i) ∈ [0, 4], i ∈ [1, tX], X ∈ {C, T, F}: the number of hydrogen atoms adjacent to vertex

vX

i (i.e., hyddeg(vX

i)) in C = (H, α, β);

- eledegX(i) ∈ [−3, +3], i ∈ [1, tX], X ∈ {C, T, F}: the ion-valence vion(ψ) of vertex vX

i (i.e.,

eledegX(i) = vion(ψ) for the ρ-fringe-tree ψ rooted at vX

i) in C = (H, α, β);

- hX(i) ∈ [0, ρ], i ∈ [1, tX], X ∈ {C, T, F}: the height ht(hT i) of the hydrogen-suppressed chemical

rooted tree hT i of the ρ-fringe-tree T rooted at vertex vX

i in C;

- σ(k, i) ∈ [0, 1], k ∈ [1, kC] = I(≥2) ∪ I(≥1), i ∈ [1, tT]: σ(k, i) = 1 ⇔ the ρ-fringe-tree Tv rooted at

vertex v = vT

i with color k has the largest height ht(hTvi) among such trees Tv, v ∈ VT;

2LM-M LLR polymer v23: September 7, 2021

36

constraints:

δC
fr(i, [ψ]) = 1,

X
ψ∈F C
i
fr (i, [ψ]) = vX(i),
δX

X
ψ∈F X
i

H
r ([ψ]) · δX

fr (i, [ψ]) = degex

X (i),

deg

X
ψ∈F X
i

deghyd
r

X
ψ∈F X
i

([ψ]) · δX

fr (i, [ψ]) = hyddegX(i),

vion([ψ]) · δX

fr (i, [ψ]) = eledegX(i),

X
ψ∈F X
i

i ∈ [1, tC],

i ∈ [1, tX], X ∈ {T, F},

(19)

i ∈ [1, tX], X ∈ {C, T, F},

(20)

fr(i, [ψ]) ≥ vF(i) − eF(i + 1),
δF

i ∈ [1, tF] (eF(tF + 1) = 0),

(21)

htH([ψ]) · δX

fr (i, [ψ]) = hX(i),

i ∈ [1, tX], X ∈ {C, T, F},

(22)

X
ψ∈F F

i [ρ]

X
ψ∈F X
i

X
ψ∈F X
i
i∈[1,tX],X∈{C,T,F}

nH([ψ]) · δX

fr (i, [ψ]) + X

vX(i) + tC = nG,

(23)

i∈[1,tX],X∈{T,F}

X
i∈[1,tX],X∈{C,T,F}

δX
fr (i, [ψ]) = fc([ψ]),

ψ ∈ F ∗,

(24)

X

ψ∈F X

i ,i∈[1,tX],X∈{C,T,F}

aclf

ν (ψ) · δX

fr (i, [ψ]) = aclf([ν]),

hC(i) ≥ chLB(i) − n∗ · δF

χ (i), clrF(i) + ρ ≥ chLB(i),

hC(i) ≤ chUB(i), clrF(i) + ρ ≤ chUB(i) + n∗ · (1 − δF

χ (i)),

ν ∈ Γlf
ac,

(25)

i ∈ [1,

tC],
e

(26)

chLB(i) ≤ hC(i) ≤ chUB(i),

i ∈ [

tC + 1, tC],
e

(27)

clrF(

tC + i) + 1 − χT(i, k)),
hT(i) ≤ chUB(k) + n∗ · (δF
χ (
e
tC + i) − χT(i, k)),
tC + i) + ρ ≤ chUB(k) + n∗ · (2 − δF
χ (
e
e

k ∈ [1, kC], i ∈ [1, tT],

(28)

2LM-M LLR polymer v23: September 7, 2021

37

σ(k, i) = δT

χ (k),

X
i∈[1,tT]

k ∈ [1, kC],

(29)

χT(i, k) ≥ σ(k, i),
hT(i) ≥ chLB(k) − n∗ · (δF
tC + i) + 1 − σ(k, i)),
χ (
e
tC + i) + ρ ≥ chLB(k) − n∗ · (2 − δF
tC + i) − σ(k, i)),
χ (
e
e

clrF(

k ∈ [1, kC], i ∈ [1, tT].

(30)

E.4 Descriptor for the Number of Speciﬁed Degree

We include constraints to compute descriptors for degrees in C.

variables:

- degX(i) ∈ [0, 4], i ∈ [1, tX], X ∈ {C, T, F}: the number of non-hydrogen atoms adjacent to

vertex v = vX

i (i.e., deghCi(v) = degH(v) − hyddegC(v)) in C = (H, α, β);

- degCT(i) ∈ [0, 4], i ∈ [1, tC]: the number of edges from vertex vC

i to vertices vT

j, j ∈ [1, tT];

- degTC(i) ∈ [0, 4], i ∈ [1, tC]: the number of edges from vertices vT

j, j ∈ [1, tT] to vertex vC

i;

dg(i, d) ∈ [0, 1], i ∈ [1, tC], d ∈ [1, 4], δX
- δC
dg(i, d) = 1 ⇔ degX(i) + hyddegX(i) = d;
δX

dg(i, d) ∈ [0, 1], i ∈ [1, tX], d ∈ [0, 4], X ∈ {T, F}:

- dg(d) ∈ [dgLB(d), dgUB(d)], d ∈ [1, 4]: the number of interior-vertices v with degH(vX

C = (H, α, β);

i) = d in

- degint

C (i) ∈ [1, 4], i ∈ [1, tC], degint

X (i) ∈ [0, 4], i ∈ [1, tX], X ∈ {T, F}: the interior-degree
i) in the interior H int = (V int(C), Eint(C)) of C; i.e., the number of interior-edges

degH int(vX
incident to vertex vX

i;

dg,C(i, d) ∈ [0, 1], i ∈ [1, tC], d ∈ [1, 4], δint
- δint
dg,X(i, d) = 1 ⇔ degint
δint

X (i) = d;

dg,X(i, d) ∈ [0, 1], i ∈ [1, tX], d ∈ [0, 4], X ∈ {T, F}:

- dgint(d) ∈ [dgLB(d), dgUB(d)], d ∈ [1, 4]: the number of interior-vertices v with the interior-

degree degH int(v) = d in the interior H int = (V int(C), Eint(C)) of C = (H, α, β).

constraints:

X
(≥2)(i)∪I +

k∈I +

(≥1)(i)

δT
χ (k) = degCT(i),

X
(≥2)(i)∪I −

k∈I −

(≥1)(i)

δT
χ (k) = degTC(i),

i ∈ [1, tC],

(31)

−
C(i) +

deg
g

deg
g

+
C(i) + degCT(i) + degTC(i) + δF

χ (i) = degint

C (i),

i ∈ [1,

tC],
e

(32)

2LM-M LLR polymer v23: September 7, 2021

−
C(i) +

deg
g

deg
g

+

C(i) + degCT(i) + degTC(i) = degint

C (i),

degint

C (i) + degex

C (i) = degC(i),

i ∈ [

tC + 1, tC],
e

i ∈ [1, tC],

fr(i, [ψ]) ≥ 2 − degint
δC

C (i)

i ∈ [1, tC],

X
ψ∈F C

i [ρ]

38

(33)

(34)

(35)

2vT(i) + δF
χ (
T (i) + degex
degint

tC + i) = degint
e

T (i),
T (i) = degT(i),

vF(i) + eF(i + 1) = degint
degint

F (i),
F (i) = degF(i),

F (i) + degex

i ∈ [1, tT] (eT(1) = eT(tT + 1) = 0),

(36)

i ∈ [1, tF] (eF(1) = eF(tF + 1) = 0),

(37)

X
d∈[0,4]

δX
dg(i, d) = 1, X
d∈[1,4]

d · δX

dg(i, d) = degX(i) + hyddegX(i),

X
d∈[0,4]

δint
dg,X(i, d) = 1, X
d∈[1,4]

d · δint

dg,X(i, d) = degint

X (i),

i ∈ [1, tX], X ∈ {T, C, F},

(38)

X
i∈[1,tC]
δint
dg,C(i, d) + X
i∈[1,tT]

δC
dg(i, d) + X
i∈[1,tT]
δint
dg,T(i, d) + X
i∈[1,tF]

δT
dg(i, d) + X
i∈[1,tF]
dg,F(i, d) = dgint(d),
δint

δF
dg(i, d) = dg(d),

X
i∈[1,tC]

d ∈ [1, 4].

(39)

E.5 Assigning Multiplicity

We prepare an integer variable β(e) for each edge e in the scheme graph SG to denote the bond-
multiplicity of e in a selected graph H and include necessary constraints for the variables to satisfy
in H.

constants:

- βr([ψ]): the sum βψ(r) of bond-multiplicities of edges incident to the root r of a chemical rooted

tree ψ ∈ F ∗;

variables:

2LM-M LLR polymer v23: September 7, 2021

39

- βX(i) ∈ [0, 3], i ∈ [2, tX], X ∈ {T, F}: the bond-multiplicity of edge eX

i in C;

- βC(i) ∈ [0, 3], i ∈ [

E(≥1) ∪ E(0/1) ∪ E(=1) in C;

kC + 1, mC] = I(≥1) ∪ I(0/1) ∪ I(=1): the bond-multiplicity of edge ai ∈
f

- βCT(k), βTC(k) ∈ [0, 3], k ∈ [1, kC] = I(≥2) ∪ I(≥1): the bond-multiplicity of the ﬁrst (resp., last)

edge of the pure path Pk in C;

- β∗F(c) ∈ [0, 3], c ∈ [1, cF =

rooted at vertex vC

c, c ≤

tC + tT]: the bond-multiplicity of the ﬁrst edge of the leaf path Qc
e
tC or vT
e

tC in C;
e

, c >

c−ftC

- βX

ex(i) ∈ [0, 4], i ∈ [1, tX], X ∈ {C, T, F}: the sum βC[v](v) of bond-multiplicities of edges in the
ρ-fringe-tree C[v] rooted at interior-vertex v = vX

i;

- δX

β (i, m) ∈ [0, 1], i ∈ [2, tX], m ∈ [0, 3], X ∈ {T, F}: δX

β (i, m) = 1 ⇔ βX(i) = m;

- δC

β (i, m) ∈ [0, 1], i ∈ [

kC, mC] = I(≥1) ∪ I(0/1) ∪ I(=1), m ∈ [0, 3]: δC
f

β (i, m) = 1 ⇔ βC(i) = m;

β (k, m), δTC
- δCT
δTC
β (k, m) = 1) ⇔ βCT(k) = m (resp., βTC(k) = m);

β (k, m) ∈ [0, 1], k ∈ [1, kC] = I(≥2) ∪ I(≥1), m ∈ [0, 3]: δCT

β (k, m) = 1 (resp.,

- δ∗F

β (c, m) ∈ [0, 1], c ∈ [1, cF], m ∈ [0, 3], X ∈ {C, T}: δ∗F

β (c, m) = 1 ⇔ β∗F(c) = m;

- bdint(m) ∈ [0, 2nint

UB], m ∈ [1, 3]: the number of interior-edges with bond-multiplicity m in C;

- bdX(m) ∈ [0, 2nint

UB], X ∈ {C, T, CT, TC}, bdX(m) ∈ [0, 2nint

UB], X ∈ {F, CF, TF}, m ∈ [1, 3]: the

number of interior-edges e ∈ EX with bond-multiplicity m in C;

constraints:

eC(i) ≤ βC(i) ≤ 3eC(i), i ∈ [

kC + 1, mC] = I(≥1) ∪ I(0/1) ∪ I(=1),
f

eX(i) ≤ βX(i) ≤ 3eX(i),

i ∈ [2, tX], X ∈ {T, F},

χ (k) ≤ βCT(k) ≤ 3δT
δT

χ (k),

χ (k) ≤ βTC(k) ≤ 3δT
δT
χ (c) ≤ βXF(c) ≤ 3δF
δF

χ (k),
χ(c),

k ∈ [1, kC],
c ∈ [1, cF]

(40)

(41)

(42)

(43)

X
m∈[0,3]

δX
β (i, m) = 1, X
m∈[0,3]

m · δX

β (i, m) = βX(i),

i ∈ [2, tX], X ∈ {T, F},

(44)

X
m∈[0,3]

δC
β (i, m) = 1, X
m∈[0,3]

m · δC

β (i, m) = βC(i),

i ∈ [

kC + 1, mC],
f

(45)

2LM-M LLR polymer v23: September 7, 2021

40

X
m∈[0,3]

δCT
β (k, m) = 1, X
m∈[0,3]

X
m∈[0,3]

δTC
β (k, m) = 1, X
m∈[0,3]

m · δCT

β (k, m) = βCT(k),

k ∈ [1, kC],

m · δTC

β (k, m) = βTC(k),

k ∈ [1, kC],

X
m∈[0,3]

δ∗F
β (c, m) = 1, X
m∈[0,3]

m · δ∗F

β (c, m) = β∗F(c),

c ∈ [1, cF],

(46)

βr([ψ]) · δX

fr (i, [ψ]) = βX

ex(i),

i ∈ [1, tX], X ∈ {C, T, F},

(47)

X
ψ∈F X
i

δC
β (i, m) = bdC(m), X
i∈[2,tT]

X
f
kC+1,mC]
δCT
β (k, m) = bdCT(m), X
k∈[1,kC]

i∈[

X
k∈[1,kC]

δT
β (i, m) = bdT(m),

δTC
β (k, m) = bdTC(m),

X
i∈[2,tF]

δF
β (i, m) = bdF(m), X
c∈[1,ftC]

δ∗F
β (c, m) = bdCF(m),

δ∗F
β (c, m) = bdTF(m),

X
c∈[ftC+1,cF]

bdC(m) + bdT(m) + bdF(m) + bdCT(m) + bdTC(m) + bdTF(m) + bdCF(m) = bdint(m),
m ∈ [1, 3].

(48)

E.6 Assigning Chemical Elements and Valence Condition

We include constraints so that each vertex v in a selected graph H satisﬁes the valence condition;
i.e., βC(v) = val(α(v)) + eledegC(v), where eledegC(v) = vion(ψ) for the ρ-fringe-tree C[v] r-
isomorphic to ψ. With these constraints, a chemical graph C = (H, α, β) on a selected subgraph
H will be constructed.

constants:

- Subsets Λint ⊆ Λ \ {H}, Λex ⊆ Λ of chemical elements, where we denote by [e] (resp., [e]int and

[e]ex) of a standard encoding of an element e in the set Λ (resp., Λint

ǫ and Λex

ǫ );

- A valence function: val : Λ → [1, 6];

- A function mass∗ : Λ → Z (we let mass(a) denote the observed mass of a chemical element

a ∈ Λ, and deﬁne mass∗(a) , ⌊10 · mass(a)⌋);

- Subsets Λ∗(i) ⊆ Λint, i ∈ [1, tC];

- naLB(a), naUB(a) ∈ [0, n∗], a ∈ Λ:

lower and upper bounds on the number of vertices v with

α(v) = a;

2LM-M LLR polymer v23: September 7, 2021

41

- naint

LB(a), naint
v with α(v) = a;

UB(a) ∈ [0, n∗], a ∈ Λint: lower and upper bounds on the number of interior-vertices

- αr([ψ]) ∈ [Λex], ∈ F ∗: the chemical element α(r) of the root r of ψ;

- naex

a ([ψ]) ∈ [0, n∗], a ∈ Λex, ψ ∈ F ∗: the frequency of chemical element a in the set of non-rooted

vertices in ψ, where possibly a = H;

- A positive integer M ∈ Z+: an upper bound for the average ms(C) of mass∗ over all atoms in

C;

variables:

- βCT(i), βTC(i) ∈ [0, 3], i ∈ [1, tT]: the bond-multiplicity of edge eCT

j,i (resp., eTC

j,i) if one exists;

- βCF(i), βTF(i) ∈ [0, 3], i ∈ [1, tF]: the bond-multiplicity of eCF

j,i (resp., eTF

j,i) if one exists;

ǫ

- αX(i) ∈ [Λint

], δX
αX(i) = 0) ⇔ δX
used in C);

α (i, [a]int) ∈ [0, 1], a ∈ Λint
α (i, [a]int) = 1 (resp., δX

, i ∈ [1, tX], X ∈ {C, T, F}: αX(i) = [a]int ≥ 1 (resp.,
i is not

i) = a ∈ Λ (resp., vertex vX

ǫ
α (i, 0) = 0) ⇔ α(vX

- δX

α (i, [a]int) ∈ [0, 1], i ∈ [1, tX], a ∈ Λint, X ∈ {C, T, F}: δX

α (i, [a]t) = 1 ⇔ α(vX

i) = a;

- Mass ∈ Z+: Pv∈V (H) mass∗(α(v));
- ms ∈ R+: Pv∈V (H) mass∗(α(v))/|V (H)|;
- δatm(i) ∈ [0, 1], i ∈ [nLB + naLB(H), n∗ + naUB(H)]: δatm(i) = 1 ⇔ |V (H)| = i;

- na([a]) ∈ [naLB(a), naUB(a)], a ∈ Λ: the number of vertices v ∈ V (H) with α(v) = a, where

possibly a = H;

- naint([a]int) ∈ [naint
with α(v) = a;

LB(a), naint

UB(a)], a ∈ Λ, X ∈ {C, T, F}: the number of interior-vertices v ∈ V (C)

- naex

X ([a]ex), naex([a]ex) ∈ [0, naUB(a)], a ∈ Λ, X ∈ {C, T, F}: the number of exterior-vertices

rooted at vertices v ∈ VX and the number of exterior-vertices v such that α(v) = a;

constraints:

βCT(k) − 3(eT(i) − χT(i, k) + 1) ≤ βCT(i) ≤ βCT(k) + 3(eT(i) − χT(i, k) + 1), i ∈ [1, tT],
βTC(k) − 3(eT(i + 1) − χT(i, k) + 1) ≤ βTC(i) ≤ βTC(k) + 3(eT(i + 1) − χT(i, k) + 1), i ∈ [1, tT],
k ∈ [1, kC],

(49)

β∗F(c) − 3(eF(i) − χF(i, c) + 1) ≤ βCF(i) ≤ β∗F(c) + 3(eF(i) − χF(i, c) + 1), i ∈ [1, tF],
β∗F(c) − 3(eF(i) − χF(i, c) + 1) ≤ βTF(i) ≤ β∗F(c) + 3(eF(i) − χF(i, c) + 1), i ∈ [1, tF], c ∈ [

c ∈ [1,

tC],
e
tC + 1, cF],
e
(50)

2LM-M LLR polymer v23: September 7, 2021

42

α (i, [a]int) = 1, X
δC
X
a∈Λint
a∈Λint
α (i, [a]int) = vX(i), X
δX
a∈Λint

X
a∈Λint

[a]int · δX

α (i, [a]int) = αC(i),

i ∈ [1, tC],

[a]int · δX

α (i, [a]int) = αX(i),

i ∈ [1, tX], X ∈ {T, F},

(51)

αr([ψ]) · δX

fr (i, [ψ]) = αX(i),

i ∈ [1, tX], X ∈ {C, T, F},

(52)

X
ψ∈F X
i

X
j∈IC(i)

βC(j) + X

βCT(k) + X

βTC(k)

k∈I +

(≥2)(i)∪I +

(≥1)(i)

k∈I −

(≥2)(i)∪I −

(≥1)(i)

+β∗F(i) + βC

ex(i) − eledegC(i) = X
a∈Λint

val(a)δC

α (i, [a]int),

i ∈ [1,

tC],
e

(53)

βC(j) + X

βCT(k) + X

βTC(k)

k∈I +

(≥2)(i)∪I +

(≥1)(i)

k∈I −

(≥2)(i)∪I −

(≥1)(i)

X
j∈IC(i)

+βC

ex(i) − eledegC(i) = X
a∈Λint

val(a)δC

α (i, [a]int),

i ∈ [

tC + 1, tC],
e

(54)

βT(i) + βT(i+1) + βT

ex(i) + βCT(i) + βTC(i)

+β∗F(

tC + i) − eledegT(i) = X
e
a∈Λint

val(a)δT

α (i, [a]int),

i ∈ [1, tT] (βT(1) = βT(tT + 1) = 0),

(55)

βF(i) + βF(i+1) + βCF(i) + βTF(i)

+βF

ex(i) − eledegF(i) = X
a∈Λint

val(a)δF

α(i, [a]int),

i ∈ [1, tF] (βF(1) = βF(tF + 1) = 0),

(56)

X
i∈[1,tX],i∈[1,tX]

α (i, [a]int) = naX([a]int),
δX

a ∈ Λint, X ∈ {C, T, F},

(57)

naex

a ([ψ]) · δX

fr (i, [ψ]) = naex

X ([a]ex),

a ∈ Λex, X ∈ {C, T, F},

(58)

X
ψ∈F X
i

2LM-M LLR polymer v23: September 7, 2021

naC([a]int) + naT([a]int) + naF([a]int) = naint([a]int),
X ([a]ex) = naex([a]ex),

naex

X
X∈{C,T,F}
naint([a]int) + naex([a]ex) = na([a]),
naint([a]int) = na([a]),
naex([a]ex) = na([a]),

a ∈ Λint,
a ∈ Λex,

a ∈ Λint ∩ Λex,
a ∈ Λint \ Λex,
a ∈ Λex \ Λint,

α (i, [a]int) = 1,
δC

X
a∈Λ∗(i)

i ∈ [1, tC],

mass∗(a) · na([a]) = Mass,

X
a∈Λ

43

(59)

(60)

(61)

(62)

X
i∈[nLB+naLB(H),n∗+naUB(H)]

δatm(i) = 1,

X
i∈[nLB+naLB(H),n∗+naUB(H)]

i · δatm(i) = nG + naex([H]ex),

Mass − M · (1 − δatm(i)) ≤ i · ms ≤ Mass + M · (1 − δatm(i)),

i ∈ [nLB + naLB(H), n∗ + naUB(H)].
(63)

E.7 Constraints for Bounds on the Number of Bonds

We include constraints for speciﬁcation of lower and upper bounds bdLB and bdUB.
constants:

- bdm,LB(i), bdm,UB(i) ∈ [0, nint

UB], i ∈ [1, mC], m ∈ [2, 3]: lower and upper bounds on the number

of edges e ∈ E(Pi) with bond-multiplicity β(e) = m in the pure path Pi for edge ei ∈ EC;

variables :

- bdT(k, i, m) ∈ [0, 1], k ∈ [1, kC], i ∈ [2, tT], m ∈ [2, 3]: bdT(k, i, m) = 1 ⇔ the pure path Pk for
i) = m;

edge ek ∈ EC contains edge eT

i with β(eT

constraints:

bdm,LB(i) ≤ δC

β (i, m) ≤ bdm,UB(i), i ∈ I(=1) ∪ I(0/1), m ∈ [2, 3],

bdT(k, i, m) ≥ δT

β (i, m) + χT(i, k) − 1,

k ∈ [1, kC], i ∈ [2, tT], m ∈ [2, 3],

(64)

(65)

2LM-M LLR polymer v23: September 7, 2021

X
j∈[2,tT]

δT
β (j, m) ≥ X

bdT(k, i, m), m ∈ [2, 3],

k∈[1,kC],i∈[2,tT]

44

(66)

bdm,LB(k) ≤ X
i∈[2,tT]

bdT(k, i, m) + δCT

β (k, m) + δTC

β (k, m) ≤ bdm,UB(k),

k ∈ [1, kC], m ∈ [2, 3].

(67)

E.8 Descriptor for the Number of Adjacency-conﬁgurations

We call a tuple (a, b, m) ∈ (Λ \ {H}) × (Λ \ {H}) × [1, 3] an adjacency-conﬁguration. The adjacency-
conﬁguration of an edge-conﬁguration (µ = ad, µ′ = bd′, m) is deﬁned to be (a, b, m). We include
constraints to compute the frequency of each adjacency-conﬁguration in an inferred chemical graph
C.
constants:

- A set Γint of edge-conﬁgurations γ = (µ, µ′, m) with µ ≤ µ′;

- Let γ of an edge-conﬁguration γ = (µ, µ′, m) denote the edge-conﬁguration (µ′, µ, m);

< = {(µ, µ′, m) ∈ Γint | µ < µ′}, Γint

= = {(µ, µ′, m) ∈ Γint | µ = µ′} and Γint

> = {γ | γ ∈

- Let Γint
Γint
< };

- Let Γint

ac,<, Γint
in the sets Γint

ac,= and Γint
< , Γint

= and Γint

> , respectively;

ac,> denote the sets of the adjacency-conﬁgurations of edge-conﬁgurations

- Let ν of an adjacency-conﬁguration ν = (a, b, m) denote the adjacency-conﬁguration (b, a, m);

- Prepare a coding of the set Γint

ac ∪ Γint

ac,> and let [ν]int denote the coded integer of an element ν

in Γint

ac ∪ Γint

ac,>;

- Choose subsets

ΓF
ΓC
ac,
ac,
e
e
adjacency-conﬁgurations exactly, set
ac ∪ Γint
Γint

ΓCT
ac ,
e

ΓTC
ac ,
e

ΓT
ac,
e

ac,>;

ac ⊆ Γint
ΓTF
ΓCF
ac ,
e
e
ΓT
ΓC
ac :=
ac :=
e
e

ac ∪ Γint
ac,>; To compute the frequency of
ΓCT
:=
:=
ac
e

ΓTC
ac
e

ΓCF
ac
e

ΓTF
ac
e

ac :=

ΓF
e

:=

:=

- acint

LB(ν), acint

UB(ν) ∈ [0, 2nint

UB], ν = (a, b, m) ∈ Γint
ac :

interior-edges e = uv with α(u) = a, α(v) = b and β(e) = m;

lower and upper bounds on the number of

- A subset Γlnk
ac ∩ Γint
Γlnk

ac ⊆ Γint
ac,= and Γint

ac for adjacency-conﬁgurations of link-edges. Let Γlnk
ac,> = {(b, a, m) | (a, b, m) ∈ Γlnk

ac,<};

ac,< = Γlnk

ac ∩ Γint

ac,<, Γlnk

ac,= =

- aclnk

LB(ν), aclnk

UB(ν) ∈ [0, 2nint

UB], ν = (a, b, m) ∈ Γlnk
ac :

link-edges e = uv with α(u) = a, α(v) = b and β(e) = m;

lower and upper bounds on the number of

variables:

2LM-M LLR polymer v23: September 7, 2021

45

- acint([ν]int) ∈ [acint

LB(ν), acint

UB(ν)], ν ∈ Γint

ac : the number of interior-edges with adjacency-conﬁguration

ν;

- acC([ν]int) ∈ [0, mC], ν ∈

ac: the
number of edges eC ∈ EC (resp., edges eT ∈ ET and edges eF ∈ EF) with adjacency-conﬁguration
ν;

ac, acT([ν]int) ∈ [0, tT], ν ∈
ΓC
e

ac, acF([ν]int) ∈ [0, tF], ν ∈
ΓT
e

ΓF
e

- acCT([ν]int) ∈ [0, min{kC, tT}], ν ∈

[0,
eTC ∈ ETC and edges eCF ∈ ECF and eTF ∈ ETF) with adjacency-conﬁguration ν;

ac , acTF([ν]int) ∈ [0, tT], ν ∈
ΓCF
e

ac , acTC([ν]int) ∈ [0, min{kC, tT}], ν ∈
ΓCT
e

ac , acCF([ν]int) ∈
ΓCT
e
ac : the number of edges eCT ∈ ECT (resp., edges
ΓTF
e

tC], ν ∈
e

- δC

ac(i, [ν]int) ∈ [0, 1], i ∈ [
ac, δF
ΓT
[2, tT], ν ∈
e
adjacency-conﬁguration ν;

kC + 1, mC] = I(≥1) ∪ I(0/1) ∪ I(=1), ν ∈
f

ac(i, [ν]int) ∈ [0, 1], i ∈ [2, tF], ν ∈

ac(i, [ν]int) = 1 ⇔ edge eX

ac(i, [ν]int) ∈ [0, 1], i ∈
i has

ac, δT
ΓC
e

ac: δX
ΓF
e

ac (k, [ν]int), δTC
- δCT
δTC
ac (k, [ν]int) = 1) ⇔ edge eCT
conﬁguration ν;

ac (k, [ν]int) ∈ [0, 1], k ∈ [1, kC] = I(≥2) ∪ I(≥1), ν ∈
tail(k),j (resp., eTC

ac (k, [ν]int) = 1 (resp.,
head(k),j) for some j ∈ [1, tT] has adjacency-

ac : δCT
ΓCT
e

- δCF

ac (c, [ν]int) ∈ [0, 1], c ∈ [1,
adjacency-conﬁguration ν;

tC], ν ∈
e

ac : δCF
ΓCF
e

ac (c, [ν]int) = 1 ⇔ edge eCF

c,i for some i ∈ [1, tF] has

- δTF

ac (i, [ν]int) ∈ [0, 1], i ∈ [1, tT], ν ∈
adjacency-conﬁguration ν;

ac : δTF
ΓTF
e

ac (i, [ν]int) = 1 ⇔ edge eTF

i,j for some j ∈ [1, tF] has

- αCT(k), αTC(k) ∈ [0, |Λint|], k ∈ [1, kC]: α(v) of the edge (vC

tail(k), v) ∈ ECT (resp., (v, vC

head(k)) ∈

ETC) if any;

- αCF(c) ∈ [0, |Λint|], c ∈ [1,

tC]: α(v) of the edge (vC
e

c, v) ∈ ECF if any;

- αTF(i) ∈ [0, |Λint|], i ∈ [1, tT]: α(v) of the edge (vT

i, v) ∈ ETF if any;

- ∆C+

ac (i), ∆C−

ac (i), ∈ [0, |Λint|], i ∈ [

ac (i), ∆T−
kC+1, mC], ∆T+
f
ac (i) = 0 (resp., ∆X+
ac (i) = ∆X−

ac (i) ∈ [0, |Λint|], i ∈ [2, tT], ∆F+
ac (i) = α(u) and ∆X−

ac (i), ∆F−
ac (i) = α(v)) ⇔ edge

ac (i) ∈

[0, |Λint|], i ∈ [2, tF]: ∆X+
eX

i = (u, v) ∈ EX is used in C (resp., eX

i 6∈ E(G));

(k), ∆CT−
- ∆CT+
ac
∆CT+
(k) = α(u) and ∆CT−
ac
used in C (resp., otherwise);

ac

ac

(k) ∈ [0, |Λint|], k ∈ [1, kC] = I(≥2) ∪ I(≥1): ∆CT+

(k) = ∆CT−
(k) = 0 (resp.,
tail(k),j = (u, v) ∈ ECT for some j ∈ [1, tT] is

ac

ac

(k) = α(v)) ⇔ edge eCT

- ∆TC+
ac
∆CT−
ac

(k), ∆TC−
(k);

ac

(k) ∈ [0, |Λint|], k ∈ [1, kC] = I(≥2) ∪ I(≥1): Analogous with ∆CT+

ac

(k) and

- ∆CF+
ac

(c) ∈ [0, |Λint|], ∆CF−

ac

(c) ∈ [0, |Λint|], c ∈ [1,

α(u) and ∆CF−
otherwise);

ac

(c) = α(v)) ⇔ edge eCF

(c) =
ac
c,i = (u, v) ∈ ECF for some i ∈ [1, tF] is used in C (resp.,

(c) = 0 (resp., ∆CF+

tC]: ∆CF+
e

(c) = ∆CF−

ac

ac

- ∆TF+
ac

(i) ∈ [0, |Λint|], ∆TF−

ac

(i) ∈ [0, |Λint|], i ∈ [1, tT]: Analogous with ∆CF+

ac

(c) and ∆CF−

ac

(c);

2LM-M LLR polymer v23: September 7, 2021

46

- aclnk([ν]int) ∈ [aclnk

LB(ν), aclnk

UB(ν)], ν ∈ Γlnk

ac : the number of link-edges with adjacency-conﬁguration

ν;

- aclnk

C ([ν]int), aclnk

T ([ν]int) ∈ [0, mC], ν ∈ Γlnk

ac : the number of link-edges eC ∈ EC (resp., edges

eT ∈ ET) with adjacency-conﬁguration ν;

- aclnk

CT([ν]int) ∈ [0, min{kC, tT}], aclnk

TC([ν]int) ∈ [0, min{kC, tT}], ν ∈ Γlnk

ac : the number of link-edges

eCT ∈ ECT (resp., link-edges eTC ∈ ETC) with adjacency-conﬁguration ν;

(i, [ν]int) ∈ [0, 1], i ∈ [2, tT], ν ∈ Γlnk

- δT,lnk
ac
with adjacency-conﬁguration ν;

ac : δT,lnk
ac

(i, [ν]int) = 1 ⇔ edge eT

i ∈ ET is a link-edge

constraints:

acC([ν]int) = 0,
acT([ν]int) = 0,
acF([ν]int) = 0,
acCT([ν]int) = 0,
acTC([ν]int) = 0,
acCF([ν]int) = 0,
acTF([ν]int) = 0,

X
(a,b,m)=ν∈Γint
ac

acC([ν]int) = X

δC
β (i, m),

i∈[

f
kC+1,mC]
acT([ν]int) = X
i∈[2,tT]
acF([ν]int) = X
i∈[2,tF]

δT
β (i, m),

δF
β (i, m),

X
(a,b,m)=ν∈Γint
ac

X
(a,b,m)=ν∈Γint
ac

X
(a,b,m)=ν∈Γint
ac

X
(a,b,m)=ν∈Γint
ac

X
(a,b,m)=ν∈Γint
ac

acCT([ν]int) = X
k∈[1,kC]
acTC([ν]int) = X
k∈[1,kC]
acCF([ν]int) = X
c∈[1,ftC]

δCT
β (k, m),

δTC
β (k, m),

δ∗F
β (c, m),

X
(a,b,m)=ν∈Γint
ac

acTF([ν]int) = X

δ∗F
β (c, m),

c∈[ftC+1,cF]

ν ∈ Γint
ν ∈ Γint
ν ∈ Γint
ν ∈ Γint
ν ∈ Γint
ν ∈ Γint
ν ∈ Γint

ac \
ac \
ac \
ac \
ac \
ac \
ac \

ΓC
ac,
e
ΓT
ac,
e
ΓF
ac,
e
ΓCT
ac ,
e
ΓTC
ac ,
e
ΓCF
ac ,
e
ΓTF
ac ,
e

m ∈ [1, 3],

m ∈ [1, 3],

m ∈ [1, 3],

m ∈ [1, 3],

m ∈ [1, 3],

m ∈ [1, 3],

m ∈ [1, 3],

(68)

(69)

2LM-M LLR polymer v23: September 7, 2021

47

ν=(a,b,m)∈

X

ac(i, [ν]int) = βC(i),

m · δC
e
ΓC
ac
[a]intδC
ac(i, [ν]int) = αC(tail(i)),
e
ΓC
ac
[b]intδC

ac(i, [ν]int) = αC(head(i)),

∆C+

ac (i) + X
ν=(a,b,m)∈

∆C−

ac (i) + X

ν=(a,b,m)∈eΓC
ac
∆C+

ac (i) ≤ 2|Λint|(1 − eC(i)),
ac (i) + ∆C−
ac(i, [ν]int) = acC([ν]int),
δC

X
f
kC+1,mC]

i∈[

X
f
kC+1,mC]

i∈Ilnk∩[

ac(i, [ν]int) = aclnk
δC

C ([ν]int),

X
ν=(a,b,m)∈eΓT
ac
[a]intδT
e
ΓT
ac

∆T+

ac (i) + X
ν=(a,b,m)∈

m · δT

ac(i, [ν]int) = βT(i),

ac(i, [ν]int) = αT(i − 1),

∆T−

ac (i) + X

[b]intδT

ac(i, [ν]int) = αT(i),

∆T+

ν=(a,b,m)∈eΓT
ac
ac (i) ≤ 2|Λint|(1 − eT(i)),
ac (i) + ∆T−
ac(i, [ν]int) = acT([ν]int),
δT

X
i∈[2,tT]

i ∈ [

kC + 1, mC],
f
ΓC
ac,
e

ν ∈

ν ∈ Γlnk

ac ∪ Γlnk

ac,>,

i ∈ [2, tT],
ΓT
ac,
e

ν ∈

ac(i, [ν]int)+ X
δT

χT(i, k) ≥ 2δT,lnk

ac

(i, [ν]int),

i ∈ [2, tT],

k∈Ilnk∩[1,kC]

δT,lnk
ac

(i, [ν]int) ≥ δT

ac(i, [ν]int)+ X

χT(i, k)−1,

i ∈ [2, tT],

k∈Ilnk∩[1,kC]

δT,lnk
ac

X
i∈[2,tT]

(i, [ν]int) = aclnk

T ([ν]int),

ν ∈ Γlnk

ac ∪ Γlnk

ac,>,

(70)

(71)

(72)

(73)

2LM-M LLR polymer v23: September 7, 2021

48

X

m · δF

ac(i, [ν]int) = βF(i),

∆F+

ac (i) + X
ν=(a,b,m)∈

ν=(a,b,m)∈

e
ΓF
ac
[a]intδF
e
ΓF
ac

ac(i, [ν]int) = αF(i − 1),

∆F−

ac(i, [ν]int) = αF(i),

[b]intδF
ac (i) + X
e
ν=(a,b,m)∈
ΓF
ac
ac (i) ≤ 2|Λex|(1 − eF(i)),
ac (i) + ∆F−
ac(i, [ν]int) = acF([ν]int),
δF

∆F+

X
i∈[2,tF]

i ∈ [2, tF],
ΓF
ac,
e

ν ∈

(74)

αT(i) + |Λint|(1 − χT(i, k) + eT(i)) ≥ αCT(k),
αCT(k) ≥ αT(i) − |Λint|(1 − χT(i, k) + eT(i)),
ac (k, [ν]int) = βCT(k),

m · δCT

X
ν=(a,b,m)∈

e
ΓCT
ac
[a]intδCT

∆CT+
ac

(k) + X
ν=(a,b,m)∈

e
ΓCT
ac

ac (k, [ν]int) = αC(tail(k)),

∆CT−
ac

(k) + X
ν=(a,b,m)∈

e
ΓCT
ac

[b]intδCT

ac (k, [ν]int) = αCT(k),

∆CT+
ac

(k) + ∆CT−

(k) ≤ 2|Λint|(1 − δT
χ (k)),
ac
ac (k, [ν]int) = acCT([ν]int),
δCT

X
k∈[1,kC]

i ∈ [1, tT],

k ∈ [1, kC],
ΓCT
ac ,
e

ν ∈

ac (i, [ν]int) = aclnk
δCT

CT([ν]int),

X
i∈Ilnk∩[1,kC]

ν ∈ Γlnk

ac ∪ Γlnk

ac,>,

(75)

(76)

αT(i) + |Λint|(1 − χT(i, k) + eT(i + 1)) ≥ αTC(k),
αTC(k) ≥ αT(i) − |Λint|(1 − χT(i, k) + eT(i + 1)),
ac (k, [ν]int) = βTC(k),

m · δTC

X
ν=(a,b,m)∈

e
ΓTC
ac
[a]intδTC

ac (k, [ν]int) = αTC(k),

∆TC+
ac

(k) + X
ν=(a,b,m)∈

e
ΓTC
ac
[b]intδTC

∆TC−
ac

(k) + X
ν=(a,b,m)∈
∆TC+
ac

e
ΓTC
ac
(k) + ∆TC−

ac (k, [ν]int) = αC(head(k)),

(k) ≤ 2|Λint|(1 − δT
χ (k)),
ac
ac (k, [ν]int) = acTC([ν]int),
δTC

X
k∈[1,kC]

i ∈ [1, tT],

k ∈ [1, kC],
ΓTC
ac ,
e

ν ∈

(77)

2LM-M LLR polymer v23: September 7, 2021

ac (i, [ν]int) = aclnk
δTC

TC([ν]int),

X
i∈Ilnk∩[1,kC]

αF(i) + |Λint|(1 − χF(i, c) + eF(i)) ≥ αCF(c),
αCF(c) ≥ αF(i) − |Λint|(1 − χF(i, c) + eF(i)),
ac (c, [ν]int) = β∗F(c),

m · δCF

X
ν=(a,b,m)∈

e
ΓCF
ac
[a]intδCF
ac (c, [ν]int) = αC(head(c)),

∆CF+
ac

(c) + X
ν=(a,b,m)∈

e
ΓCF
ac

∆CF−
ac

[b]intδCF

(c) + X
ν=(a,b,m)∈
(c) ≤ 2 max{|Λint|, |Λint|}(1 − δF

ac (c, [ν]int) = αCF(c),

e
ΓCF
ac

χ (c)),
ac (c, [ν]int) = acCF([ν]int),
δCF

∆CF+
ac

(c) + ∆CF−

ac

X
c∈[1,ftC]

49

(78)

(79)

ν ∈ Γlnk

ac ∪ Γlnk

ac,>,

i ∈ [1, tF],

c ∈ [1,

ν ∈

tC],
e
ΓCF
ac ,
e

αF(j) + |Λint|(1 − χF(j, i +
αTF(i) ≥ αF(j) − |Λint|(1 − χF(j, i +

tC) + eF(j)) ≥ αTF(i),
e
tC) + eF(j)),
e

m · δTF

ac (i, [ν]int) = β∗F(i +

tC),
e

X
ν=(a,b,m)∈eΓTF
ac

∆TF+
ac

(i) + X
ν=(a,b,m)∈

∆TF−
ac

(i) + X
ν=(a,b,m)∈

e
ΓTF
ac

e
ΓTF
ac
[b]intδTF

[a]intδTF

ac (i, [ν]int) = αT(i),

ac (i, [ν]int) = αTF(i),

∆TF+
ac

(i) + ∆TF−

ac

(i) ≤ 2 max{|Λint|, |Λint|}(1 − δF

tC)),
e
ac (i, [ν]int) = acTF([ν]int),
δTF

χ (i +

X
i∈[1,tT]

X
X∈{C,T,F,CT,TC,CF,TF}

(acX([ν]int) + acX([ν]int)) = acint([ν]int),

j ∈ [1, tF],

(80)

i ∈ [1, tT],
ΓTF
ac ,
e

ν ∈

ν ∈ Γint

ac,<,

X
X∈{C,T,F,CT,TC,CF,TF}

acX([ν]int) = acint([ν]int),

ν ∈ Γint

ac,=,

(81)

X
X∈{C,T,CT,TC}

(aclnk

X ([ν]int) + aclnk

X ([ν]int)) = aclnk([ν]int),

X
X∈{C,T,CT,TC}

aclnk

X ([ν]int) = aclnk([ν]int),

ν ∈ Γlnk

ac,<,

ν ∈ Γlnk

ac,=,

(82)

2LM-M LLR polymer v23: September 7, 2021

aclnk([ν]int) = nlnk.

X
ν∈ν∈Γlnk
ac

50

(83)

E.9 Descriptor for the Number of Chemical Symbols

We include constraints for computing the frequency of each chemical symbol in Λdg. Let cs(v)
denote the chemical symbol of an interior-vertex v in a chemical graph C to be inferred; i.e.,
cs(v) = µ = ad ∈ Λdg such that α(v) = a and deghCi(v) = degH (v)−deghyd
C (v) = d in C = (H, α, β).
constants:

- A set Λint

dg of chemical symbols;

- Prepare a coding of each of the two sets Λint

dg and let [µ]int denote the coded integer of an element

µ ∈ Λint
dg ;

- Choose subsets
dg :=

ΛC
e

dg :=

ΛT
e
variables:

ΛF
ΛT
ΛC
dg,
dg,
e
e
e
dg := Λint
ΛF
dg ;
e

dg ⊆ Λint

dg : To compute the frequency of chemical symbols exactly, set

- nsint([µ]int) ∈ [0, nint

UB], µ ∈ Λint

dg : the number of interior-vertices v with cs(v) = µ;

- δX

ns(i, [µ]int) ∈ [0, 1], i ∈ [1, tX], µ ∈ Λint

dg , X ∈ {C, T, F};

constraints:

X
e
ΛX
dg∪{ǫ}

µ∈

ns(i, [µ]int) = 1, X
δX
µ=ad∈

e
ΛX
dg

[a]int · δX

ns(i, [µ]int) = αX(i),

d · δX

ns(i, [µ]int) = degX(i),

X
e
µ=ad∈
ΛX
dg

i ∈ [1, tX], X ∈ {C, T, F},

(84)

X
i∈[1,tC]

ns(i, [µ]int) + X
δC
i∈[1,tT]

ns(i, [µ]int) + X
δT
i∈[1,tF]

ns(i, [µ]int) = nsint([µ]int),
δF

µ ∈ Λint
dg .

(85)

E.10 Descriptor for the Number of Edge-conﬁgurations

We include constraints to compute the frequency of each edge-conﬁguration in an inferred chemical
graph C.
constants:

- A set Γint of edge-conﬁgurations γ = (µ, µ′, m) with µ ≤ µ′, where we let γ denote (µ′, µ, m);

2LM-M LLR polymer v23: September 7, 2021

51

- Let Γint

< = {(µ, µ′, m) ∈ Γint | µ < µ′}, Γint

= = {(µ, µ′, m) ∈ Γint | µ = µ′} and Γint

> = {(µ′, µ, m) |

(µ, µ′, m) ∈ Γint

< };

- Prepare a coding of the set Γint ∪ Γint

> and let [γ]int denote the coded integer of an element γ in

Γint ∪ Γint
> ;

ΓTC
ec
e
UB], γ = (µ, µ′, m) ∈ Γint:

- Choose subsets

ΓCT
ΓTC
ec ,
ec ,
e
e
ΓC
ec :=
conﬁgurations exactly, set
e

ΓC
ec,
e

ΓT
ec,
e

ΓF
ΓCF
ΓTF
ec ⊆ Γint ∪ Γint
ec,
ec ,
> ; To compute the frequency of edge-
e
e
e
ΓF
ΓCT
ΓT
ec :=
:=
ec :=
ec
e
e
e

:= Γint ∪ Γint
> ;

ΓTF
ec
e

ΓCF
ec
e

:=

:=

- ecint

LB(γ), ecint

UB(γ) ∈ [0, 2nint

lower and upper bounds on the number of

interior-edges e = uv with cs(u) = µ, cs(v) = µ′ and β(e) = m;

- A subset Γlnk ⊆ Γint for edge-conﬁgurations of link-edges. Let Γlnk

< = Γlnk ∩Γint

< , Γlnk

= = Γlnk ∩Γint
=

and Γint

> = {(b, a, m) | (a, b, m) ∈ Γlnk

< };

- eclnk

LB(γ), eclnk

UB(γ) ∈ [0, 2nint

UB], γ = (µ, µ′, m) ∈ Γint:

lower and upper bounds on the number of

link-edges e = uv with cs(u) = µ, cs(v) = µ′ and β(e) = m;

- nscnt

LB([µ]), nscnt

UB([µ]) ∈ [0, 2], µ ∈ Λint
dg :

lower and upper bounds on the number of connecting-

vertices v with cs(v) = µ; Deﬁne
Γcnt
< := {(µ, µ′, 1) ∈ γ ∈ Γlnk
Γcnt
> := {(µ, µ′, 1) ∈ γ ∈ Γlnk
= := {(µ, µ, 1) ∈ γ ∈ Γlnk
Γcnt

< | µ, µ′ ∈ Λint
> | µ, µ′ ∈ Λint
= | µ ∈ Λint

dg , nscnt

UB(µ) = 2};

dg , nscnt
dg , nscnt

LB(µ) ≤ 1 ≤ nsUB(µ), nscnt
LB(µ) ≤ 1 ≤ nsUB(µ), nscnt

LB(µ′) ≤ 1 ≤ nsUB(µ′)};
LB(µ′) ≤ 1 ≤ nsUB(µ′)};

variables:

- ecint([γ]int) ∈ [ecint

LB(γ), ecint

UB(γ)], γ ∈ Γint: the number of interior-edges with edge-conﬁguration

γ;

- ecC([γ]int) ∈ [0, mC], γ ∈

ec: the
number of edges eC ∈ EC (resp., edges eT ∈ ET and edges eF ∈ EF) with edge-conﬁguration γ;

ΓC
ec, ecT([γ]int) ∈ [0, tT], γ ∈
e

ΓT
ec, ecF([γ]int) ∈ [0, tF], γ ∈
e

ΓF
e

- ecCT([γ]int) ∈ [0, min{kC, tT}], γ ∈

[0,
eTC ∈ ETC and edges eCF ∈ ECF and eTF ∈ ETF) with edge-conﬁguration γ;

ΓCF
ec , ecTF([γ]int) ∈ [0, tT], γ ∈
e

ΓCT
ec , ecTC([γ]int) ∈ [0, min{kC, tT}], γ ∈
e

ΓCT
ec , ecCF([γ]int) ∈
e
ΓTF
ec : the number of edges eCT ∈ ECT (resp., edges
e

tC], γ ∈
e

- δC

ec(i, [γ]int) ∈ [0, 1], i ∈ [
ec, δF
ΓT
[2, tT], γ ∈
e
conﬁguration γ;

kC + 1, mC] = I(≥1) ∪ I(0/1) ∪ I(=1), γ ∈
f

ec(i, [γ]int) ∈ [0, 1], i ∈ [2, tF], γ ∈

ec, δT
ΓC
e
ec(i, [γ]t) = 1 ⇔ edge eX

ec(i, [γ]int) ∈ [0, 1], i ∈
i has edge-

ec: δX
ΓF
e

- δCT

ec,C(k, [γ]int), δTC
(resp., δTC
conﬁguration γ;

ec,C(k, [γ]int) ∈ [0, 1], k ∈ [1, kC] = I(≥2) ∪ I(≥1), γ ∈

ec,C(k, [γ]int) = 1) ⇔ edge eCT

tail(k),j (resp., eTC

ec,C(k, [γ]int) = 1
ec : δCT
ΓCT
e
head(k),j) for some j ∈ [1, tT] has edge-

- δCF

ec,C(c, [γ]int) ∈ [0, 1], c ∈ [1,
has edge-conﬁguration γ;

tC], γ ∈
e

ec : δCF
ΓCF
e

ec,C(c, [γ]int) = 1 ⇔ edge eCF

c,i for some i ∈ [1, tF]

2LM-M LLR polymer v23: September 7, 2021

52

- δTF

ec,T(i, [γ]int) ∈ [0, 1], i ∈ [1, tT], γ ∈
has edge-conﬁguration γ;

ec : δTF
ΓTF
e

ec,T(i, [γ]int) = 1 ⇔ edge eTF

i,j for some j ∈ [1, tF]

- degCT

T (k), degTC
ECT (resp., (v, vC

head(k)) ∈ ETC) if any;

T (k) ∈ [0, 4], k ∈ [1, kC]: deghCi(v) of an end-vertex v ∈ VT of the edge (vC

tail(k), v) ∈

- degCF

F (c) ∈ [0, 4], c ∈ [1,

tC]: deghCi(v) of an end-vertex v ∈ VF of the edge (vC
e

c, v) ∈ ECF if any;

- degTF

F (i) ∈ [0, 4], i ∈ [1, tT]: deghCi(v) of an end-vertex v ∈ VF of the edge (vT

i, v) ∈ ETF if any;

- ∆C+

ec (i), ∆C−

ec (i), ∈ [0, 4], i ∈ [

kC + 1, mC], ∆T+
f
ec (i) = 0 (resp., ∆X+
ec (i) = ∆X−

ec (i), ∆T−

[0, 4], i ∈ [2, tF]: ∆X+
edge eX

i = (u, v) ∈ EX is used in hCi (resp., eX

ec (i) = deghCi(u) and ∆X−
i 6∈ E(hCi));

ec (i) ∈ [0, 4], i ∈ [2, tT], ∆F+

ec (i), ∆F−
ec (i) ∈
ec (i) = deghCi(v)) ⇔

ec

(k), ∆CT−
(k) = deghCi(u) and ∆CT−

- ∆CT+
ec
∆CT+
ec
j ∈ [1, tT] is used in hCi (resp., otherwise);

(k) ∈ [0, 4], k ∈ [1, kC] = I(≥2) ∪ I(≥1): ∆CT+

(k) = 0 (resp.,
ec
(k) = deghCi(v)) ⇔ edge eCT
tail(k),j = (u, v) ∈ ECT for some

(k) = ∆CT−

ec

ec

- ∆TC+
ec

(k), ∆TC−

ec

(k) ∈ [0, 4], k ∈ [1, kC] = I(≥2) ∪ I(≥1): Analogous with ∆CT+

ec

(k) and ∆CT−

ec

(k);

(c) ∈ [0, 4], c ∈ [1,

(c) = 0 (resp., ∆CF+
tC]: ∆CF+
(c), ∆CF−
(c) = deghCi(u) and
e
c,j = (u, v) ∈ ECF for some j ∈ [1, tF] is used in hCi (resp.,
(c) = deghCi(v)) ⇔ edge eCF

(c) = ∆CF−

ec

ec

ec

ec

- ∆CF+
ac
∆CF−
ec
otherwise);

- ∆TF+
ec

(i), ∆TF−

ec

(i) ∈ [0, 4], i ∈ [1, tT]: Analogous with ∆CF+

ec

(c) and ∆CF−

ec

(c);

- eclnk([γ]int) ∈ [eclnk

LB(γ), eclnk

UB(γ)], γ ∈ Γlnk: the number of link-edges with edge-conﬁguration γ;

- eclnk

C ([γ]int), eclnk

T ([γ]int) ∈ [0, mC], γ ∈ Γlnk: the number of link-edges eC ∈ EC (resp., edges

eT ∈ ET) with edge-conﬁguration γ;

- eclnk

CT([γ]int) ∈ [0, min{kC, tT}], eclnk

TC([γ]int) ∈ [0, min{kC, tT}], γ ∈ Γlnk: the number of link-edges

eCT ∈ ECT (resp., link-edges eTC ∈ ETC) with adjacency-conﬁguration γ;

(i, [γ]int) ∈ [0, 1], i ∈ [2, tT], γ ∈ Γlnk: δT,lnk

(i, [γ]int) = 1 ⇔ edge eT

i ∈ ET is a link-edge

ec

- δT,lnk
ec
with edge-conﬁguration γ;

- δcnt([γ]int) ∈ [0, 1], γ ∈ Γcnt

< ∪ Γcnt

= ∪ Γcnt

> : δcnt([γ]int) = 1 ⇔ ec(e) = γ for the link-edge e joining

connecting-vertices;

constraints:

2LM-M LLR polymer v23: September 7, 2021

53

ecC([γ]int) = 0,
ecT([γ]int) = 0,
ecF([γ]int) = 0,
ecCT([γ]int) = 0,
ecTC([γ]int) = 0,
ecCF([γ]int) = 0,
ecTF([γ]int) = 0,

γ ∈ Γint \
γ ∈ Γint \
γ ∈ Γint \
γ ∈ Γint \
γ ∈ Γint \
γ ∈ Γint \
γ ∈ Γint \

ΓC
ec,
e
ΓT
ec,
e
ΓF
ec,
e
ΓCT
ec ,
e
ΓTC
ec ,
e
ΓCF
ec ,
e
ΓTF
ec ,
e

X
(µ,µ′,m)=γ∈Γint

ecC([γ]int) = X

δC
β (i, m),

i∈[

f
kC+1,mC]
ecT([γ]int) = X
i∈[2,tT]
ecF([γ]int) = X
i∈[2,tF]

δT
β (i, m),

δF
β (i, m),

X
(µ,µ′,m)=γ∈Γint

X
(µ,µ′,m)=γ∈Γint

X
(µ,µ′,m)=γ∈Γint

X
(µ,µ′,m)=γ∈Γint

X
(µ,µ′,m)=γ∈Γint

ecCT([γ]int) = X
k∈[1,kC]
ecTC([γ]int) = X
k∈[1,kC]
ecCF([γ]int) = X
c∈[1,ftC]

δCT
β (k, m),

δTC
β (k, m),

δ∗F
β (c, m),

X
(µ,µ′,m)=γ∈Γint

ecTF([γ]int) = X

δ∗F
β (c, m),

c∈[ftC+1,cF]

X

γ=(ad,bd′,m)∈

[(a, b, m)]int · δC
e
ΓC
ec
∆C+

ec (i) + X

ec(i, [γ]int) = X
e
ΓC
ac

ν∈

[ν]int · δC

ac(i, [ν]int),

d · δC

ec(i, [γ]int) = degC(tail(i)),

γ=(ad,µ′,m)∈eΓC
ec

∆C−

ec (i) + X

ec(i, [γ]int) = degC(head(i)),

γ=(µ,bd,m)∈

d · δC
e
ΓC
ec
∆C+

X
f
kC+1,mC]

i∈[

ec (i) ≤ 8(1 − eC(i)),
ec (i) + ∆C−
ec(i, [γ]int) = ecC([γ]int),
δC

m ∈ [1, 3],

m ∈ [1, 3],

m ∈ [1, 3],

m ∈ [1, 3],

m ∈ [1, 3],

m ∈ [1, 3],

m ∈ [1, 3],

i ∈ [

kC + 1, mC],
f
ΓC
ec,
e

γ ∈

(86)

(87)

(88)

2LM-M LLR polymer v23: September 7, 2021

54

X
f
kC+1,mC]

i∈Ilnk∩[

ec(i, [γ]int) = eclnk
δC

C ([γ]int),

γ ∈ Γlnk ∪ Γlnk
> ,

(89)

X

γ=(ad,bd′,m)∈

[(a, b, m)]int · δT
e
ΓT
ec
∆T+

ec (i) + X

ec(i, [γ]int) = X
e
ΓT
ac

ν∈

d · δT
e
ΓT
ec

γ=(ad,µ′,m)∈

∆T−

ec (i) + X

[ν]int · δT

ac(i, [ν]int),

ec(i, [γ]int) = degT(i − 1),

γ=(µ,bd,m)∈
∆T+

ec(i, [γ]int) = degT(i),

d · δT
e
ΓT
ec
ec (i) + ∆T−
ec (i) ≤ 8(1 − eT(i)),
ec(i, [γ]int) = ecT([γ]int),
δT

X
i∈[2,tT]

i ∈ [2, tT],
ΓT
ec,
e

γ ∈

(90)

ec(i, [γ]int)+ X
δT

χT(i, k) ≥ 2δT,lnk

ec

(i, [γ]int),

i ∈ [2, tT],

k∈Ilnk∩[1,kC]

δT,lnk
ec

(i, [γ]int) ≥ δT

ec(i, [γ]int)+ X

χT(i, k)−1,

i ∈ [2, tT],

k∈Ilnk∩[1,kC]

δT,lnk
ec

X
i∈[2,tT]

(i, [γ]int) = eclnk

T ([γ]int),

γ ∈ Γlnk ∪ Γlnk
> ,

(91)

X

γ=(ad,bd′,m)∈

[(a, b, m)]int · δF
e
ΓF
ec
∆F+

ec (i) + X

ec(i, [γ]int) = X
e
ΓF
ac

ν∈

ec(i, [γ]int) = degF(i − 1),

[ν]int · δF

ac(i, [ν]int),

∆F−

ec (i) + X

ec(i, [γ]int) = degF(i, 0),

d · δF
e
ΓF
ec

d · δF
e
ΓF
ec

γ=(ad,µ′,m)∈

γ=(µ,bd,m)∈
∆F+

ec (i) + ∆F−
ec (i) ≤ 8(1 − eF(i)),
ec(i, [γ]int) = ecF([γ]int),
δF

X
i∈[2,tF]

i ∈ [2, tF],
ΓF
ec,
e

γ ∈

(92)

2LM-M LLR polymer v23: September 7, 2021

55

X

[(a, b, m)]int · δCT

γ=(ad,bd′,m)∈

e
ΓCT
ec
∆CT+
ec

degT(i) + 4(1 − χT(i, k) + eT(i)) ≥ degCT
degCT

T (k),
T (k) ≥ degT(i) − 4(1 − χT(i, k) + eT(i)),
ac (k, [ν]int),

[ν]int · δCT

ec,C(k, [γ]int) = X
e
ΓCT
ac

ν∈

(k) + X

d · δCT

ec,C(k, [γ]int) = degC(tail(k)),

γ=(ad,µ′,m)∈

e
ΓCT
ec

∆CT−
ec

(k) + X

d · δCT

ec,C(k, [γ]int) = degCT

T (k),

γ=(µ,bd,m)∈
∆CT+
ec

e
ΓCT
ec
(k) + ∆CT−

ec

(k) ≤ 8(1 − δT
χ (k)),
ec,C(k, [γ]int) = ecCT([γ]int),
δCT

X
k∈[1,kC]

i ∈ [1, tT],

k ∈ [1, kC],
ΓCT
ec ,
e

γ ∈

ec (i, [γ]int) = eclnk
δCT

CT([γ]int),

X
i∈Ilnk∩[1,kC]

γ ∈ Γlnk ∪ Γlnk
> ,

degT(i) + 4(1 − χT(i, k) + eT(i + 1)) ≥ degTC
degTC
[(a, b, m)]int · δTC

T (k),
T (k) ≥ degT(i) − 4(1 − χT(i, k) + eT(i + 1)),
ac (k, [ν]int),

[ν]int · δTC

ec,C(k, [γ]int) = X
e
ΓTC
ac

X

γ=(ad,bd′,m)∈

e
ΓTC
ec

ν∈
d · δTC

∆TC+
ec

(k) + X

ec,C(k, [γ]int) = degTC

T (k),

∆TC−
ec

(k) + X

ec,C(k, [γ]int) = degC(head(k)),

γ=(ad,µ′,m)∈eΓTC
ec
d · δTC

γ=(µ,bd,m)∈

e
ΓTC
ec
∆TC+
ec

ec

(k) + ∆TC−

(k) ≤ 8(1 − δT
χ (k)),
ec,C(k, [γ]int) = ecTC([γ]int),
δTC

X
k∈[1,kC]

i ∈ [1, tT],

k ∈ [1, kC],
ΓTC
ec ,
e

γ ∈

ec (i, [γ]int) = eclnk
δTC

TC([γ]int),

X
i∈Ilnk∩[1,kC]

γ ∈ Γlnk ∪ Γlnk
> ,

(93)

(94)

(95)

(96)

2LM-M LLR polymer v23: September 7, 2021

56

degF(i) + 4(1 − χF(i, c) + eF(i)) ≥ degCF
degCF

F (c),
F (c) ≥ degF(i) − 4(1 − χF(i, c) + eF(i)),
ac (c, [ν]int),

ec,C(c, [γ]int) = X
e
ΓCF
ac
ec,C(c, [γ]int) = degC(c),

ν∈
d · δCF

(c) + X

[ν]int · δCF

X

[(a, b, m)]int · δCF

γ=(ad,bd′,m)∈

e
ΓCF
ec

∆CF+
ec

γ=(ad,µ′,m)∈

e
ΓCF
ec
d · δCF

∆CF−
ec

(c) + X

ec,C(c, [γ]int) = degCF

F (c),

γ=(µ,bd,m)∈
∆CF+
ec

e
ΓCF
ec
(c) + ∆CF−

ec

(c) ≤ 8(1 − δF

χ (c)),
ec,C(c, [γ]int) = ecCF([γ]int),
δCF

X
c∈[1,ftC]

[(a, b, m)]int · δTF

degF(j) + 4(1 − χF(j, i +
degTF

tC) + eF(j)) ≥ degTF
e

F (i) ≥ degF(j) − 4(1 − χF(j, i +
ec,T(i, [γ]int) = X
e
ΓTF
ac
ec,T(i, [γ]int) = degT(i),

ν∈
d · δTF

(i) + X

[ν]int · δTF

F (i),
tC) + eF(j)),
e
ac (i, [ν]int),

∆TF+
ec

X

γ=(ad,bd′,m)∈

e
ΓTF
ec

γ=(ad,µ′,m)∈eΓTF
ec

∆TF−
ec

(i) + X

d · δTF

ec,T(i, [γ]int) = degTF

F (i),

γ=(µ,bd,m)∈
∆TF+
ec

e
ΓTF
ec
(i) + ∆TF−

X
i∈[1,tT]

(i) ≤ 8(1 − δF

tC)),
ec
e
ec,T(i, [γ]int) = ecTF([γ]int),
δTF

χ (i +

X
X∈{C,T,F,CT,TC,CF,TF}

(ecX([γ]int) + ecX([γ]int)) = ecint([γ]int),

i ∈ [1, tF],

c ∈ [1,

γ ∈

tC],
e
ΓCF
ec ,
e

j ∈ [1, tF],

i ∈ [1, tT],
ΓTF
ec ,
e

γ ∈

γ ∈ Γint
< ,

(97)

(98)

X
X∈{C,T,F,CT,TC,CF,TF}

ecX([γ]int) = ecint([γ]int),

γ ∈ Γint
= ,

(99)

X
X∈{C,T,CT,TC}

(eclnk

X ([γ]int) + eclnk

X ([γ]int)) = eclnk([γ]int),

X
X∈{C,T,CT,TC}

eclnk

X ([γ]int) = eclnk([γ]int),

eclnk([γ]int) = nlnk,

X
γ∈Γlnk

γ ∈ Γlnk
< ,

γ ∈ Γlnk
= .

(100)

(101)

2LM-M LLR polymer v23: September 7, 2021

57

nscnt

LB([µ]) ≤ δcnt(1, [µ]) + δcnt(2, [µ]) ≤ nscnt

UB([µ]),

γ∈Γcnt

= ∪Γcnt
>

δcnt([γ]int) = 1,

X
< ∪Γcnt
eclnk([γ]int) ≥ δcnt([γ]int),
eclnk([γ]int) ≥ δcnt([γ]int),

µ ∈ Λint
dg ,

(102)

γ ∈ Γcnt

< ∪ Γcnt
=
γ ∈ Γcnt
>

(103)

E.11 Constraints for Normalization of Feature Vectors

By introducing a tolerance ε > 0 in the conversion between integers and reals, we include the
following constraints for normalizing of a feature vector x = (x(1), x(2), . . . , x(K)):

(1 − ε)(x(j) − min(dcpj; Dπ))
max(dcpj; Dπ) − min(dcpj; Dπ)

≤

x(j) ≤
b

(1 + ε)(x(j) − min(dcpj; Dπ))
max(dcpj; Dπ) − min(dcpj; Dπ)

, j ∈ [1, K].

(104)

An example of a tolerance is ε = 1 × 10−5.

We use the same conversion for descriptor xj = ms.

