Smartphone Impostor Detection with Built-in
Sensors and Deep Learning

Guangyuan Hu
Princeton University
Princeton, NJ
gh9@princeton.edu

Zecheng He
Princeton University
Princeton, NJ
zechengh@princeton.edu

Ruby Lee
Princeton University
Princeton, NJ
rblee@princeton.edu

0
2
0
2

b
e
F
0
1

]

R
C
.
s
c
[

1
v
4
1
9
3
0
.
2
0
0
2
:
v
i
X
r
a

Abstract—In this paper, we show that sensor-based impostor
detection with deep learning can achieve excellent impostor
detection accuracy at lower hardware cost compared to past
work on sensor-based user authentication (the inverse problem)
which used more conventional machine learning algorithms.
While these methods use other smartphone users’ sensor data
to build the (user, non-user) classiﬁcation models, we go further
to show that using only the legitimate user’s sensor data can
still achieve very good accuracy while preserving the privacy
of the user’s sensor data (behavioral biometrics). For this use
case, a key contribution is showing that the detection accuracy
of a Recurrent Neural Network (RNN) deep learning model
can be signiﬁcantly improved by comparing prediction error
distributions. This requires generating and comparing empirical
probability distributions, which we show in an efﬁcient hard-
ware design. Another novel contribution is in the design of
SID (Smartphone impostor Detection), a minimalist hardware
accelerator that can be integrated into future smartphones for
efﬁcient impostor detection for different scenarios. Our SID
module can implement many common Machine Learning and
Deep Learning algorithms. SID is also scalable in parallelism and
performance and easy to program. We show an FPGA prototype
of SID, which can provide more than enough performance for
real-time impostor detection, with very low hardware complexity
and power consumption (one to two orders of magnitude less
than related performance-oriented FPGA accelerators). We also
show that the FPGA implementation of SID consumes 64.41X
less energy than an implementation using the CPU with a GPU.

I. INTRODUCTION

We rely heavily on our smartphones not only for communica-
tion but also to store conﬁdential and private data. Smartphones
make it more convenient for us to access our data anywhere,
anytime, on mobile devices.

However, smartphone theft is one of the most severe threats
to smartphone users, leading to a loss of conﬁdentiality and
private data [26]. Impostors are attackers who take over a
smartphone and perform actions allowed for the smartphone
owner but not for others. Impostor attacks are critical threats
to the conﬁdentiality, privacy and integrity of the secrets and
personal information stored in the smartphone and accessible
online through the smartphone. For powerful attackers who
already know or can bypass the legitimate smartphone user’s
password or personal
identiﬁcation number (PIN), can a
defense-in-depth mechanism be provided to detect impostors
quickly before further damage is done? We show how this
can be done effectively and implicitly, using an algorithm and
architecture approach in this paper.

Implicit impostor detection mechanism built into the smart-
phone would make stealing smartphones less attractive if
the smartphone can detect the impostor, and automatically
prevent access to conﬁdential information when an impostor is
detected. Unlike explicit authentication with passwords, PINs
or ﬁngerprints, we would like to detect a potential impostor by
looking for intrinsic differences in smartphone user behavior
(also known as behavioral biometrics). For example, is it
feasible to detect an impostor as he is just walking with the
smartphone?

Our ﬁrst insight is, the ubiquitous inclusion of motion
sensors, e.g. 3-axis accelerometer and the 3-axis gyroscope,
in smartphones provide a great opportunity to capture a
user’s motion patterns. We use data from these two widely-
available sensors to characterize the motion of a potential
thief currently holding the smartphone, as he is walking away
from the theft scene, etc. In the literature, implicit smartphone
authentication using sensors is primarily modeled as a binary
classiﬁcation problem using conventional Machine Learning
(ML) algorithms like Support Vector Machine (SVM) and
Kernel Ridge Regression (KRR) [12].

However, these classiﬁcation approaches require both the
legitimate user’s sensor data and the sensor data from other
users for training. This causes serious privacy issues as users
must submit their sensitive behavioral data. In this paper,
we explicitly consider the trade-off of security and privacy
by investigating one-class anomaly detection for impostor
detection. We show that using only the legitimate user’s sensor
data, we can still achieve very good accuracy while preserving
the privacy of the user’s sensor data, i.e. the user’s behavioral
biometrics.

Our intuition is to build a Recurrent Neural Network (RNN)
based deep learning (DL) model that can represent the normal
user’s behavior. A large deviation of the observed behavior from
the model’s prediction indicates that the smartphone is used
by an impostor. Different from previous work on using RNN
for anomaly detection, we show that the detection accuracy of
an RNN model can be signiﬁcantly improved by generating
and comparing empirical prediction error distributions (PEDs)
rather than just comparing it with a threshold.

To reduce the attack surface and reduce the cost of impostor
detection, we design a small and energy-efﬁcient hardware
module for impostor detection. Unlike previous work on
the maximum
ML/DL accelerators whose goal

is to get

 
 
 
 
 
 
performance from one or a few speciﬁc ML or DL algorithms
(e.g. Convolutional Neural Networks ), our goal is not to
maximize performance, but to provide sufﬁcient performance
at low cost and low power consumption. Likewise, our goal is
also different from past work that focuses on minimizing power
consumption – rather, we consider a broader goal of trade-offs
in security, usability and privacy, with execution time, memory
and energy consumption.

We design Smartphone Impostor Detector (SID) to show
that we can efﬁciently and effectively solve a real security
problem with small hardware footprint and energy consumption.
SID reuses functional units where possible to reduce size
and cost. Yet it is also scalable for higher performance if
more parallel datapath tracks are implemented. It is designed
to support not only the best deep learning algorithms we
found for impostor detection in both user scenarios (with and
without other users’ data for training), but can also support
other Machine Learning algorithms, calculations of empirical
probability distributions and statistical tests. Programmability
support provides ﬂexibility in the choice of algorithms and
trade-offs in security, privacy, usability and cost.

Our key contributions are:

• We conduct a comprehensive comparison of ML and
DL based classiﬁcation and one-class outlier detection
algorithms for impostor detection. We explicitly consider
the trade-offs among security, privacy and usability. Our
models achieve 97-98% accuracy in impostor detection for
the multi-user scenario (2-class models), and up to 92%
accuracy in the single-user scenario (1-class models).
• We show that the detection accuracy of a Recurrent Neural
Network (RNN) deep learning model, e.g. LSTM and GRU,
can be signiﬁcantly improved by comparing prediction error
distributions.

• We propose a hardware module that is versatile, scalable
and efﬁcient for performing impostor detection without
preprocessing or postprocessing on other devices.

• We show the trade-off between detection accuracy with
performance, storage and energy consumption when ML/DL
models are mapped to our SID module.

• We show a major difference in size between the SID module

and existing accelerators with a similar RNN target.

• We show SID uses 64.4X less energy than a platform with

a GPU.

II. MOTIVATION AND THREAT MODEL

Our threat model includes powerful attackers who can
bypass the conventional explicit authentication mechanisms,
e.g. personal identiﬁcation number (PIN), password, voice or
ﬁngerprint. The explicit authentication bypassing could occur
in different ways. For example, the PIN/password may not
be strong enough. The attacker can actively ﬁgure out the
weak pin/password by guessing or social engineering. Another
example is the attacker taking the phone after the legitimate user
has entered the secret or biometric for explicit authentication.
Once the explicit authentication is bypassed, the attacker
can ﬁnd and kill any suspicious impostor detection program

running as a software process. Hence, we consider a hardware
solution that cannot be disabled in this way.

We assume the smartphone has common, built-in motion
sensors, e.g. the accelerometer and the gyroscope. We assume
that the sensor readings are always available.

Our approach can be used with any explicit user authentica-
tion mechanism and can provide an extra layer of security
in a defense-in-depth approach. Our detection mechanism
does not conﬂict with the conventional explicit authentication
but prevents, as much as possible, the exposure of secret
information/services to an impostor even when the explicit
authentication is broken.

While this paper assumes a single legitimate user of a
smartphone, our detection methodology can be easily extended
to allow multiple legitimate users sharing a smartphone, e.g.,
members in a family or tight-knit team.

III. METHODOLOGY FOR IMPOSTOR DETECTION

Our proposed impostor detection methodology jointly opti-
mizes the security enhancement and the cost of implementation.
We consider the security enhancement part in this section,
the cost of implementation in Section IV and trade-offs in
Section V. Within security enhancement, our methodology
explicitly takes three important factors into consideration: attack
detection capability (security), usability and user data privacy
of the solution.

A. Security and Usability Trade-off

A good implicit impostor detection solution needs to both be
able to detect suspicious impostors and not affect the legitimate
user’s utilization. At the center of this trade-off is the selection
of an appropriate model for impostor detection. One of our key
intuitions and takeaways of our methodology is that choosing
the right model is more important for achieving security and
performance goals than increasing the model size or adding
hardware complexity to accelerate a model.

Previous work on implicit smartphone user authentication
mostly leverage the (user, non-user) binary classiﬁcation
techniques [7], [12], [27]. This scenario requires training
models using both data from the real user and potential attackers
and we call it the scenario of impostor detection-as-a-service
(IDaaS) or Scenario 1 in this paper. The service provider is
a centralized party. All end-users (customers) register their
phones to the service provider by providing their patterns
on motion recorded by the smartphone. The service provider
collects data from all customers, creating a model for each
customer using the entire data from all customers. For a speciﬁc
customer, the data from him/herself are labeled as benign (the
user’s), while all data from other customers are labeled as
malicious (non-user’s).

We follow the literature and start with selecting certain
classiﬁcation-based machine learning and deep learning models.
The goal is to ﬁnd the algorithms which give the best accuracy
for impostor detection (security) and legitimate user recognition
(usability).

2

We ﬁrst investigate three representative ML algorithms:
logistic regression (LR), support vector machine (SVM) and
kernel ridge regression (KRR). Logistic regression intrinsically
provides the probability of a class and thus can be naturally
leveraged as the warning score. We evaluate SVM because it is a
powerful and commonly used linear model, which can establish
a non-linear boundary using the kernel method (Appendix A).
KRR alleviates over-ﬁtting by penalizing large parameters.
It is suitable for learning with limited data and achieves the
highest detection rate in the literature [12]. Since these machine
learning algorithms require heuristic feature selection, we also
try the simplest deep learning model, i.e. multi-layer perceptron
(MLP). MLP is a non-linear classiﬁer and can automatically
extract intricate patterns from raw data, without heuristic and
tedious hand-crafting. Details of these algorithms and their
equations are given in Appendix A.
Metrics. In order to quantify both factors, i.e. security and
usability, of a given binary classiﬁcation technique for impostor
detection, we consider the metrics: true negative rate (TNR)
and true positive rate (TPR). Note that a ”positive” outcome
is the detection of an impostor, while a ”negative” outcome
implies the legitimate user is detected.

Usability is represented by TNR, which is the percentage of
samples when the real user is correctly recognized. Security can
be measured using TPR, which is the percentage of samples
when a wrong user gets detected and rejected. Eq (1) gives
the formula for TNR and TPR, as well as for the metrics
commonly used in comparing the ML/DL models: accuracy,
recall, precision and F1.

T NR =

T PR ==

T N
T N + FP
T P
T P + FN

Accuracy =

T N + T P
T N + FP + T P + FN

Recall(R) = T PR

Precision(P) =

F1score =

T P
T P + FP
2 × Recall × Precision
Recall + Precision

(1)

B. Privacy and usability trade-off

The aforementioned binary classiﬁcation machine learning
approaches can only be applied to the IDaaS scenarios where
the data from other users are available. Unfortunately, many
smartphone users do not want to share their sensor data
for privacy reasons and for fear of being attacked in the
network or the cloud. For data privacy concerns [1], [2] about
users’ behavioral biometric data, we need to consider another
important scenario where the smartphone user only has his/her
own data for training. Therefore, the impostor detection in this
scenario can be formalized as a one-class classiﬁcation, i.e.
outlier detection problem. We call this local anomaly detection
(LAD) or Scenario 2 in this paper.

Although most of the previous work of continuous smart-
phone authentication concentrate on binary classiﬁcations,

3

there exists some preliminary pioneering work on one-class
classiﬁcation [10], [11], [13]. However, none of these work
leverage deep learning techniques on one-class smartphone
authentication.

We consider three representative algorithms to deal with
the lack of positive (non-user) training data, i.e. One-Class
SVM (OCSVM), Long Short-Term Memory (LSTM) and Gated
Recurrent Unit (GRU). We propose enhancing the deep learning
models, LSTM and GRU, with the comparison of reference
and actual Prediction Error Distributions (PED’s). We show
in Section III-D that generating and comparing the prediction
error distributions is the key to a successful detection for this
Scenario 2. The ML/DL prediction algorithm appears to be
only of secondary importance, and does not even have to be
very accurate.
OCSVM. OCSVM is an extension of normal SVM, by
separating all the data points from the origin in the feature
space and maximizing the distance from this hyperplane to the
origin. Intuitively, the OCSVM looks for the minimum support
of the normal data, and recognizes points outside this support
as anomalies. The kernel method (Appendix A) can also be
applied to establish a non-linear boundary.
LSTM. Different from the above discussed stateless models
(SVM, KRR, OCSVM, etc.), the LSTM model has two hidden
states (ht and ct ) which can remember the previous input
information. When being used to model temporal sequences,
an LSTM cell updates its hidden states (ht , ct ) for each input
time-frame using the previous states (ht−1, ct−1) and the current
input xt as described in Eq (2). Three control gates, the forget
gate ft , the input gate it and the output gate ot , are used
to determine how much of the old states are preserved. This
signiﬁcantly prevents the gradient vanishing problem in training
deep neural networks. In Eq (2), the W’s and U’s are weight
matrices, and the b’s are bias vectors.

candt = tanh(Wc × xt +Uc × ht−1 + bc)
ft = σ (Wf × xt +U f × ht−1 + b f )
it = σ (Wi × xt +Ui × ht−1 + bi)
ot = σ (Wo × xt +Uo × ht−1 + bo)
ct = ft (cid:12) ct−1 + it (cid:12) candt
ht = ot (cid:12) tanh(ct )

(2)

GRU. We replace the cell model with a more light-weight
Gated Recurrent Unit (GRU) model, described in Eq (3).

zt = σ (Wz × xt +Uz × ht−1 + bz)
rt = σ (Wr × xt +Ur × ht−1 + br)
ht = (1 − zt ) (cid:12) ht−1 + zt (cid:12) σ (Whxt +Ur(rt (cid:12) ht−1) + bh)

(3)

We use an LSTM or GRU model as an outlier detector
[17], by training it to predict the next sensor reading, and
investigate the prediction errors. The intuition is, an LSTM
model trained on only the normal user’s data predicts better for
his/her behavior than the other users’ (potentially an impostor)
behavior. The deviation of the real monitored behavior from
the predicted behavior indicates the anomalies. Typically, a

threshold value is used to decide if the prediction error is
normal or not. A key contribution we make is to show that the
choice of deep learning models, e.g. LSTM or GRU, is not
the most important factor for good performance, if Prediction
Error Distributions are leveraged.
LSTM/GRU + Prediction Error Distribution (PED). Our
intuition is that a single prediction error may signiﬁcantly vary,
but the probability distribution of the errors is stable. Therefore,
comparing the difference between the observed PED and a
reference PED from the real user’s validation data is more
stable than comparing the average prediction error.

As we do not need to assume the prior distribution of PED,
non-parametric tests are powerful tools to determine if two
distributions are the same. The Kolmogorov-Smirnov (KS) test
is a statistical test that determines whether two i.i.d sets of
samples are from the same distribution. The KS statistic for
two sets with n and m samples is:

Dn,m = supx|Fn(x) − Fm(x)|

(4)

where Fn and Fm are the empirical distribution functions of
two sets of samples respectively, i.e. Fn(t) = 1
i=1 1xi≤t , and
sup is the supremum function. The null hypothesis that the two
sets of samples are i.i.d. sampled from the same distribution,
is rejected at level α if:

n ∑n

Dn,m > c(α)

(cid:114) n + m
nm

(5)

where c(α) is a pre-calculated value and can be found in the
standard KS test lookup table.

C. Experimental Settings

We evaluate the models for impostor detection using the
UCI [6] Human Activities and Postural Transitions (HAPT)
dataset [21]. The HAPT dataset contains smartphone sensor
readings. The smartphone is worn on the waist of a group of
30 participants of various ages from 19 to 48. The participants
were asked to perform six activities including standing, sitting,
walking, etc. and the transitions between them. The sensor
readings are collected and labeled with both the activity and
user ID. Each reading consists of the 3-axial measurements of
both the linear acceleration and angular velocity, so it could
be treated as a 6-element vector. The sensors are sampled at
50Hz. We use the WALK dataset in HAPT to determine the
feasibility of user versus impostor classiﬁcation using the two
most common built-in motion sensors and just one common
type of motion.

We select 25 out of the 30 users in the HAPT dataset as
the registered users while the other 5 users act as unregistered
users. For each registered user, models are trained using his/her
data and randomly picked sensor data of the other 24 registered
users. In the training process, all the data from the other 24
registered users are labeled as positive for impostor detection
and not the correct user. The unregistered users are used in
testing to examine whether unseen attackers can be successfully
detected.

As [12] reports very high accuracy for recognizing users
the same KRR model

using sensor data, we implement

which ﬁrst computes 14 features: for each of the 2 sensors
(accelerometer and gyroscope), 4 are common statistics like
min, max, mean and standard deviation, in the time domain
and 3 are frequency domain features.

D. Security vs Usability Evaluation

We show the results of two-class classiﬁcation in Table I.
We choose a window size of 64 1 sensor readings because this
window size covers 1-2 full human steps given the sensors are
sampled at 50 Hz. We observe that the SVM model performs
the best for all the metrics. Surprisingly, it also performs better
than KRR with manually selected features. However, the simple
deep learning model, MLP, performs almost as well, and costs
less; SVM requires more storage and execution time than MLP
for a marginal 1-2% of accuracy increase (see left half of
Figure 5 and Figure 6 in Section V). These two ﬁgures will
also show that, MLP with 2 hidden levels (MLP-200-100)
is better, from the memory and execution-time performance
perspective, than MLP with one hidden layer but more nodes
(MLP-500), while both have 97% accuracy.

Models

LR
KRR
SVM
MLP-50
MLP-100
MLP-200
MLP-500
MLP-50-25
MLP-100-50
MLP-200-100

TNR
(%)
80.77
88.91
99.26
98.31
98.60
98.41
98.68
98.13
98.44
98.47

All Users

TPR/Recall
(%)
66.05
82.66
97.57
92.70
94.65
95.72
95.47
94.49
95.45
95.72

Accuracy
(%)
73.41
85.78
98.42
95.51
96.63
97.06
97.07
96.31
96.95
97.10

P

0.77
0.87
0.99
0.98
0.98
0.98
0.99
0.98
0.98
0.98

F1

0.69
0.83
0.98
0.94
0.96
0.97
0.96
0.96
0.96
0.97

TABLE I: Impostor detection in the IDaaS secnario, using
binary classiﬁcation ML and DL models, achieves 97%-98%
accuracy.

We use the same experimental settings on HAPT dataset for
the evaluation of one-class outlier detection approaches. We
train an OCSVM model with a ﬁxed window size of 64. The
latency for detection is a multiple of 20-ms (e.g.,64x, or 1.28
seconds) which is comparable to the time for an impostor to
act. The LSTM or GRU model makes predictions for every
sensor reading in a ﬁxed window of size 200. The classiﬁcation
results of LSTM-# and GRU-# (rows 2 through 6 in Table II,
# is the size of hidden states) are given by comparing the
average prediction error with a threshold obtained from the
validation set. The PED-enhanced LSTM or GRU leverages
the distribution of prediction errors within the same window
as LSTM or GRU. We ﬁrst randomly choose 20 samples
of prediction errors from the validation set and use them
to represent the reference PEDs. In the testing phase, the
prediction error distribution of each testing sample is compared
to all the reference distributions. If half of the KS-test-statistics
are larger than a commonly used p-value threshold, e.g. 0.05 in
our experiment, the current sample is considered as abnormal.

1It is easier to extract FFT features if the window size is a power of 2.

4

We show the results of three types of one-class models, i.e.
OCSVM, LSTM/GRU, and LSTM or GRU + PED, in Table II.
The one-class SVM achieves an average accuracy of 69.2%,
thirty percent worse than classiﬁcation models trained with
positive data involved. The standard LSTM or GRU models
have an accuracy of ∼ 70%, only slightly better than the one-
class SVM model, regardless of the network architecture. On
the contrary, there exists a signiﬁcant improvement if PED and
statistical KS test are leveraged, e.g. the accuracy of LSTM or
GRU models + KS test reach 89.0% or 92.3%, respectively.
We conclude that, neither the choice of deep learning models,
e.g. LSTM or GRU (3.5% gain), nor the design of network
architectures (1.5% gain) is the ﬁrst essential factor for good
performance. However, it is the Prediction Error Distributions
and KS test that provide the signiﬁcant increase in detection
capability, i.e. +19.2% for the best LSTM and +19.4% for
the best GRU. Without loss of generality, we use the more
conservative numbers for LSTM in the rest of the paper (GRU
will be slightly better).

Once PED and KS are used, we observe that the PED-LSTM-
200-OCSVM and PED-LSTM-200-VOTE tradeoff between
security and usability, respectively. The PED-LSTM-200-
OCSVM achieves a high TPR of 92.25% but a lower TNR of
74.82%, i.e. a “strict” detection providing good security against
impostors but can erroneously reject the real user. The voting-
based method, i.e. PED-LSTM-200-VOTE, achieves a high
TNR of 94.62% but a lower TPR of 83.31%, which means it is
a “lenient” detection mechanism providing good usability for
the correct user but limited security against impostors. Both
approaches signiﬁcantly outperform the non-PED (non-KS)
approaches.

Given that adding the KS test is critical to improving the
detection accuracy in this scenario, we provide the hardware
support for generating empirical PEDs and computing the KS
statistic in Section IV-D.

Models

OCSVM
LSTM-50
LSTM-100
LSTM-200
LSTM-500
GRU-200
PED-LSTM-
200-OCSVM
PED-GRU-
200-OCSVM
PED-LSTM-
200-Vote
PED-GRU-
200-Vote

TNR
(%)
64.24
72.43
72.20
67.88
67.57
69.12

74.82

All Users

TPR/Recall
(%)
74.19
67.04
69.27
71.60
74.42
76.68

Accuracy
(%)
69.22
69.74
70.73
69.74
70.99
72.9

92.25

83.53

P

0.59
0.57
0.58
0.58
0.60
0.63

0.80

F1

0.65
0.60
0.62
0.62
0.65
0.68

0.84

78.47

93.58

86.03

0.82

0.86

94.62

83.31

88.97

0.91

0.83

96.86

87.79

92.33

0.94

0.88

TABLE II: Impostor detection accuracy in the LAD secnario,
using one-class models

Note that our impostor detection methodology is an extra
layer in a defense-in-depth approach that does not conﬂict with
explicit authentication using PIN, voice or ﬁngerprint. Very high
sensitivity levels (95%-99%) are achieved for accuracy, security

(TPR) and usability (TNR) when SVM or MLP models are
used in the IDaaS scenario. If sensor data privacy is required,
the accuracy is lower but still acceptable: security (92%-93%)
or usability (94%-96%) can be achieved using our enhanced
LSTM or GRU models, depending on one’s needs. Although
the accuracy is not perfect, it is actually comparable to the state-
of-the-art one class smartphone authentication using various
handcrafted features and complex model fusion [11] in the
literature.

IV. SID HARDWARE MODULE

Our goal is to design a small but versatile and programmable
hardware module that can be integrated into a smartphone to
perform impostor detection, without needing computation on
another processor or accelerator. Design goals for our Smart-
phone Impostor Detector (SID) are:
• Flexibility for different ML/DL models and trade-offs of
security, usability, privacy, execution time, storage and
energy consumption,

• Scalability for more performance,
• Reduced memory storage and access,
• Minimized energy consumption, and
• Reduced attack surface for better security.

While our primary goal is to design SID to be able to
perform the best algorithms for impostor detection, namely,
MLP and SVM for the IDaaS binary classiﬁcation scenario,
and one-class PED-LSTM/GRU for the local detection scenario,
we also want it to be ﬂexible enough to support other ML/DL
algorithms as well, possibly for future security needs. For
performance scalability, we design SID to allow more parallel
tracks to be implemented, if desired. An innovative aspect of
our design is that the SID macro instructions implementing
the selected ML/DL algorithm do not even have to be changed
when the number of parallel tracks is increased. We also
design SID to reduce memory trafﬁc by reusing operands and
having local storage in the execution stage. To be feasible for
implementation in a smartphone, we design SID for reduced
energy consumption to alleviate smartphone battery usage.
To reduce the attack surface, SID should be able to support
detection without subsequent processing on another device like
the CPU. For example, our SID also does statistical testing,
which is important to enhance ML/DL models. This includes
collecting and comparing empirical probability distributions.

A. Architecture Overview

For ﬂexibility, we want SID to be able to support different
ML/DL algorithms, for different security/usability/privacy/cost
trade-offs, as well as future security needs.

An overview of SID is shown in Figure 1. Unlike vector
machines with vector registers of ﬁxed length, we use memory
(BRAM in the FPGA) to store the vector or matrix operands
and results. The memory controlled by macro instructions in
SID is more efﬁcient since it does not have ﬁxed vector lengths
and operates seamlessly with our automatic determination of
the number of times to execute a vector or matrix operation.
We also have a small local scratchpad memory for faster access

5

the FSM (in decode stage in Figure 1) updates the number
of uncomputed iterations, according to the number of parallel
tracks, to decide when a macro-instruction ﬁnishes (details
in the following paragraphs). This means the same code can
run on the SID hardware modules with a different number of
parallel tracks without modiﬁcation.

The format of a SID macro instruction is shown in Ta-
ble III. The Mode ﬁeld speciﬁes one of the operation modes
in Table IV, and the Length and Width ﬁelds initialize
the control FSM and indicate when the execution of the
macrio instruction ﬁnishes. The control FSM has three state
registers, reg length, reg width and reg width copy, to track
the number of iterations that have not been ﬁnished and
automatically decide when to stop the FSM and move to the
next instruction (which initiates a new FSM). The FSM can
be conﬁgured by instructions in two ways: the one-dimension
iteration and the matrix-vector iteration.

The one-dimension iteration in a vector operation uses
only the reg length. The value of reg length is initialized
by the length ﬁeld of the instruction. During execution,
reg length is decreased every cycle by N(track), which is
the number of parallel tracks, until reg length is no larger
than N(track) and the FSM lets the module fetch the next
instruction.

The matrix-vector iteration, is used in a tiling manner. It in-
volves all three state registers. Figure 2 shows how the FSM gets
updated every cycle in the matrix-vector multiplication mode.
When an instruction for matrix-vector operation is fetched,
the length ﬁeld initializes reg length and the width ﬁeld
initializes both reg width and reg width copy. reg width,
which gets decremented every cycle, controls the downward
iteration along a matrix column. When one inner iteration using
reg width is ﬁnished, reg width copy reﬁlls reg width and
reg length gets decremented by N(track), which is the number
of parallel tracks as deﬁned above. This corresponds to moving
to the next slice of matrix columns. When the last slice of
columns in the matrix is computed, the next instruction can
be fetched.

Fig. 2: FSM for matrix-vector iteration, e.g. Mvmul. N(track)
is the number of parallel tracks.

6

Fig. 1: A SID module implementing vector and matrix
operations deﬁned in Table IV

to intermediate results during a macro operation. The scratch-
pad is used to reduce the memory trafﬁc for matrix-vector
multiplication and other vector operations (Section IV-C).

We propose a minimal implementation of a SID module
with four parallel tracks in the datapath, as shown in Figure 1.
Each track consists of a Look-up Table (LUT), a Multiplier
and an Adder, which are put into three consecutive EXEcution
stages. Section IV-B shows how SID is programmed, how it
controls the execution of macro instructions and how SID is
scalable for loops. We describe the operations implemented
with maximal functional unit reuse and the memory access
reduction in Section IV-C. An efﬁcient implementation of
empirical probability distribution generation and comparison
is given in Section IV-D.
Integration in smartphone hardware system. Compared
to conventional processing which requires the sensor data to
be saved in main memory and then read out by application
processors or other computation devices, integrating a detection
module closer to the sensors can reduce the attack surface and
save the overhead of memory accesses. Modern smartphones
have already implemented the interface to write the collected
sensor input to a cache memory for efﬁcient signal process-
ing [5]. The SID module can leverage a similar interface (the
input ”Motion Sensors” in Figure 1). A valid incoming sensor
input can reset the program counter of SID to the beginning
of the detection program.

127

124

123

110

109

96

Mode
4 bits

Length
14 bits

Width
14 bits

95
64
Addr x
32 bits

63
32
Addr y
32 bits

31
0
Addr z
32 bits

TABLE III: SID Macro Instruction with Automatic Scalable
FSM Control

B. Scalable FSM Control with Macro Operations

We provide a scalable programming interface to allow
ML/DL models with different operations and sizes. The
software in SID is a sequence of macro-instructions, which
encode a ﬂexible number of iterations for an entire vector or
matrix operation. Each macro instruction initializes the ﬁnite
state machine (FSM) state of the control unit to indicate the
number of iterations of the speciﬁed operation. Each cycle,

DatapathControlLUTEXE0LUTLUTLUTEXE1MULMULMULMULEXE2ADDADDADDADDWRReadAddrWriteDataLocal ScratchpadInstructionRAMPCInst[PC]Write Addr (WR) DecodeEXE1EXE0EXE2WRBlockRAMFetchFSMMemoryManage-mentUnitMotionSensorWidth > 1:Reg_L= LengthReg_W= Width –1Reg_Wcopy= Width Reg_L<= N(Track)&& Reg_W= 1Reg_W> 1:Reg_W= Reg_W-1Length <= N(Track)&& Width= 1Reg_L> N(Track)&& Reg_W= 1:Reg_W= Reg_WcopyReg_L= Reg_L-N(Track)Reg_L> N(Track) && Reg_Wcopy> 1:Reg_W= Reg_Wcopy-1Length > N(Track) && Width  = 1:Reg_L= Length -N(Track) Reg_W= 1, Reg_Wcopy= 1 Reg_L> N(Track)&& Reg_Wcopy= 1:Reg_W= Reg_WcopyReg_L= Reg_L-N(Track)Reg_L<= N(Track)&& Reg_W= 1Fetchthe nextinstructionContinueto processa column sliceSwitch tothe nextcolumn sliceOperation
Modes

Description

Vadd

Vsub

Vmul

Vsgt

Vsig
Vtanh
Vexp

Mvmul

VSsgt

Vmaxabs

Vsqnorm

Vargmax

Vmin

Vmax2

VFFT

Vsqrt

Element-wise addition
of two vectors
Element-wise subtraction
of two vectors
Element-wise multiplication
of two vectos
Element-wise set-greater-than
of two vectors
Sigmoid function of a vector
Tanh function of a vector
Exponential function of a vector
Multiplication of a
matrix and a vector
Set-greater-than to compare a
scalar and a vector’s elements
Find the maximum absolute
value of a vector
Squared L2-norm of a vector

Find the index of the
maximum in a vector
Find the minimum in a vector
Find the second largest
number in a vector
Compute the Fourier
transform of a vector
Compute the square root
of each element in a vector

LR KRR

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

IDaaS

SVM w/
Gaussian
Kernel

MLP

OCSVM w/
Gaussian
Kernel

LAD

LSTM GRU KS-test

PED-
LSTM/GRU
-OCSVM

PED-
LSTM/GRU
-Mvote

Support
Status

(cid:88)

(cid:88)

(cid:88)
(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)
(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)
(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)
(cid:88)
(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)
(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

Yes

Yes

Yes

Yes

Yes
Yes
Yes

Yes

Yes

Yes

Yes

No

No

No

No

No

TABLE IV: Computation primitives needed by different ML/DL models and statistical testing.

This encoding-control mechanism has the advantages of both
scalability and performance. The design is scalable since the
hardware is aware of the number of parallel data tracks that are
implemented and can perform automatic control of the loop(s).
For performance, the control by FSM avoids using branch
instructions for frequent jump-backs as needed in general-
purpose processors, which can take up a large portion of
processor throughput for simple loop bodies.

C. Functional Operations Supported

Our basic hardware module, SID, supports all the operations
from Vadd through Vsqnorm in Table IV. The instructions
from Vargmax to Vsqrt (at the bottom of Table IV) are needed
only for extracting the features, e.g. computing minimum, maxi-
mum, square-root, Fourier transform frequency components, for
a KRR algorithm [12]. We decide not to implement these since
they introduce signiﬁcant hardware complexity while achieving
lower accuracy than the other algorithms (see Table I).

For a detection algorithm, programming SID is directly
writing a sequence of instructions corresponding to the opera-
tions in the equations for model inference, and specifying the
sizes of the matrices and vectors, i.e. model parameters, in the
instruction.

We describe brieﬂy the vector and matrix-vector operation
modes supported by going down the rows of Table IV. Key
design optimizations are reusing functional units to reduce the
hardware cost, automatic FSM operation, tiling and adding the
local scratchpad memory to reduce memory accesses.

Basic vector-vector operations. The addition (Vadd), sub-
traction (Vsub) and multiplication (Vmul) are straightforward.
Vector comparison (Vsgt) is implemented as a set-greater-than

(SGT) operation where

c[i] =

(cid:40)

1, a[i] ≥ b[i]
0, a[i] < b[i]

, i = 0, ..., len(c) − 1

(6)

In the SID module, Vadd, Vsub and Vsgt modes are computed
in parallel by the 4 parallel tracks shown in Figure 1 in the
adder stage (EXE2). The Vmul mode only uses the multiplier
stage (EXE1) for parallel multiplication.
Reuse of functional units in vector non-linear functions.
When computing non-linear functions like sigmoid (Vsig),
tanh (Vtanh) and exponential (Vexp), we use the look-up table
(LUT) implementation to compute the linear approximation.
This avoids needing to implement complex non-linear functions,
while providing the ﬂexibility of implementing arbitrary non-
linear functions by table lookup of the slope and intercept for
linear approximation. An added beneﬁt of our approach over
prior work [4] is that we place the LUTs before the multipliers
and adders in the three consecutive execution stages so that
no extra multipliers or adders are needed. The ELE0 (LUT)
stage of SID outputs a slope, k(i), and an intercept, b(i), for
each input value. The interpolation is then computed in the
later two stages as Z[i] = k[i] × X[i] + b[i] with Z[i] being the
value of the non-linear function for input X[i].
Local scratchpad with tiling and reuse of adders in matrix-
vector multiplication. MVmul mode computes the product of
a weight matrix and an input vector. We have two optimizations
for MVmul mode.

First, instead of having another adder tree stage to sum the
products computed in the EXE1 stage, we put multiplexers
before the adders in EXE2 stage to reuse the adders, which
saves on hardware cost. In the 4-track example, the ﬁrst three
adders sum the four products. The fourth one adds the sum to

7

the partial sum read from the local scratchpad and writes the
new partial sum back to the local scratchpad if the computation
is not ﬁnished.

Fig. 3: The macro instruction (top) and tiling (bottom) of the
matrix-vector multiplication in the MVmul Mode

Second, we use a local scratchpad memory and loop tiling
to save the latency of storing and accessing partial sums from
memory and also reduce the memory trafﬁc. A speciﬁcation of
a matrix-vector multiplication is shown in Figure 3 followed
by the pseudo-code description of tiling. N track and N local
in the pseudo-code are implementation parameters of SID that
are provided to the instruction generator. When an output entry
of the vector O cannot be computed in one cycle, its partial
sum is stored in the local scratchpad memory in the EXE2
stage (see Figure 1) so that it does not need to be fetched
from memory every cycle. Also, every cycle, N track weights
(the inner loop of jj) in the same row and their corresponding
input elements are multiplied and added to one partial sum.
The weights at the same location in the rows below (the loop
of ii) will be used in the following cycles, so the input data
is reused. The same reuse of the input data is exploited for
all columns (the loop of j). A single MvMul instruction can
perform all the loops except the ﬁrst loop of i. When the local
scratchpad memory cannot hold all the partial sums, the loop
of i is performed using multiple MvMul instructions, each of
which corresponds to an FSM in Figure 2.
Adding vector-scalar comparison for statistical test. The
vector-scalar comparison mode, VSsgt, is required by the
statistical test support (see Section IV-D). It is computed
by setting an output element to one if the corresponding
element in the input vector is larger than the other scalar
operand, otherwise zero. During execution, the scalar is kept
in the pipeline, and the vector elements are streamed in for
comparison.
Using local scratchpad for fast accesses to intermediate
results. Besides Mvmul, other operation modes, which need
to store intermediate results, may also use the local scratchpad
to avoid always reading them from memory outside the
SID module. The Vmaxabs mode compares the absolute values
of input elements in EXE2 stage by doing subtraction with the

adders. A temporary maximum is stored in the local scratchpad
and gets updated every cycle. The Vsqnorm mode computes
the squared L2-norm of a vector. The scratchpad is also used
in this mode to store the partial sum of V [i]2 (V is the input
vector) which are computed by the multipliers and adders in
EXE1 and EXE2 stages.

D. Support for Distribution Representation and Comparison
A novel contribution of this work is to show that the
statistical test for comparing empirical probability distributions
can be done efﬁciently using the multipliers and adders
already needed for the ML/DL algorithms. To the best of our
knowledge, we are the ﬁrst to describe the following simple
and efﬁcient hardware support for comparing PEDs and the
KS test.

We implement the KS test using a ﬁve-step workﬂow and
show an example in Figure 4. The grey dotted boxes represent
inputs, including the reference prediction error distribution
(PED) and the observed PED and the output. The reference
PED is collected in the training phase and is represented by
reference bin boundaries and a cumulative histogram. The
observed RED is collected online and represented by a series
of observed errors.

Step (cid:172): compare an observed error with bin boundaries. The
output of this step is a vector of “0”s and “1”s. “1” represents
that the corresponding bin boundary is greater than the observed
error, and “0” otherwise. This step requires a new operation for
vector-scalar comparison (VSsgt described in Section IV-C).
Step (cid:173): accumulate all binary vectors from (cid:172). The accumulated
vector, namely “observed histogram”, conceptually represents
the cumulative histogram of the observed errors using the
reference bins. Step (cid:174) and step (cid:175): ﬁnd the largest difference
in the reference and observed histograms, i.e. the KS statistic
Dn,m in Eq (4). Step (cid:174) is a vector subtraction and step (cid:175) is a
new operation, Vmaxabs (described in Section IV-C), to ﬁnd
the maximum absolute value in a vector. Step (cid:176): compare Dn,m
with a threshold, which is treated as a single-entry vector, to
determine normality. Hence, we only need two extra operation
modes, VSsgt and Vmaxabs, to support KS testing.

Fig. 4: An example of ﬁve-step KS test. Only two new operation
primitives, VSsgt and Vmaxabs, are implemented in step (cid:173)
and (cid:175) to support KS test.

8

  , ⋯  ,   ⋮⋱⋮    , ⋯    ,     ⋮    =  ⋮    MVmullwAddr(I)Addr(W)Addr(O)Width = wLength = l// N(local): The number of entries in the local scratchpad// N(track): The number of parallel computing tracksfor (i= 0; i< l; i+= N(local))for (j = 0; j < w; j += N(track))  // Encoded in one Mvmulinstructionfor (ii = 0; ii < N(local); ii ++)for (jj= 0; jj< N(track); jj++)  // Computed every cycle i∗N(local)+ii +=  i∗N(local)+ii, j∗N(track)+jj ∗ j∗N(track)+jj1.21.63.04.35.000001000000000100011Reference BinsObserved HistogramTest Error: 4.50001200000Test Error: 9.500012①01234Reference Histogram0-1-2-2-2max{|·|}Normal?②+<②+②+Test Error: 3.5①<①<Init-③④2Dn,m②②②③⑤TThreshold< ( )     V. EVALUATION

A. Model Performance and Trade-offs

Figure 5 compares different machine learning and deep
learning algorithms for their trade-offs between execution
time (orange bars with crosshatch) and accuracy (red line)
on the SID module and the CPU-GPU platform. The models to
the left of the black dashed line are used in the IDaaS scenario
when sensor data from other users are available. The models
trained without the other users’ data in the LAD scenario are
to the right of the dashed line. Although the SVM algorithm
achieves slightly higher accuracy than MLP-200-100 (98.4%
versus 97.1%), it needs signiﬁcantly longer execution time.

a slightly higher detection accuracy with a smaller model size
than MLP-500. The SVM model has little improvement on
the accuracy over MLP-200-100 but incurs the highest cost
in terms of memory usage as it has to store many support
vectors. Hence, MLP-200-100 appears to be the best for the
cost (execution time + memory usage) versus accuracy trade-
off.

In the LAD scenario which preserves the sensor data privacy,
the standard LSTM-200 solution requires more space than the
OCSVM model but gives a similar accuracy of 69%. However,
The LSTM-based models enhanced with KS-test, PED-LSTM-
200-OCSVM and PED-LSTM-200-Vote, take 1.8% and 0.6%
more space, respectively, but can signiﬁcantly improve the
overall accuracy. They are better choices in the cost-versus-
accuracy trade-off as the improvement in accuracy is signiﬁcant,
and a user can choose one or the other based on his/her need
for better security or usability (Section III-D).

Fig. 5: Execution time and accuracy of models

For the one-class models in the LAD scenario, we ﬁnd that
the KS test technique increases the detection accuracy, but
also needs additional execution time. Compared to the LSTM-
200 model which involves only LSTM and error computation
and has low accuracy, PED-LSTM-200-OCSVM increases the
execution time on SID by 44.9%, to which KS test contributes
41.7% and the following one-class SVM contributes the re-
maining 3.2%. PED-LSTM-200-Vote increases the execution
time by 41.8%, compared to the basic LSTM model, and the
execution time is mostly spent in computing the KS test. The
majority vote part only contributes less than 0.1%.

To achieve real-time detection of an impostor, the total
execution time should be less than the period of sensor reading
(PoS). We also tried a CPU-only platform with 32 Intel Xeon
E5-2667 cores, it fails to meet this requirement. Running a
single prediction on one sensor sample with the LSTM-200
model takes more than 20 ms, i.e. the PoS of our dataset for the
smartphone sensor sampling rate of 50Hz. The SID module and
our CPU-GPU platform which has a NVIDIA GTX 1080Ti
GPU can meet the requirement to provide enough performance,
however, the latter consumes much more energy as we will
show in Section V-D.

B. Model Memory Usage

Figure 6 compares models used in the IDaaS and LAD
scenarios, in terms of their accuracy and the size of the model
parameters. The red line stands for the average accuracy. In the
IDaaS scenario, we see that a 2-layer MLP-200-100 can achieve

9

Fig. 6: Number of parameters and accuracy of models

C. Hardware Design Complexity

Functionality

Platform

DeltaRNN

C-LSTM

Supports Gated
Recurrent Unit
only

Xilinx Zynq-7000
All Programmable
SoC

Supports LSTM
only

Alpha Data’s
ADM-7V3

FPGA

Kintex-7 XC7Z100

Xilinx Virtex-7

Design Tool
Quantization
Slice LUT
Slice Flip-ﬂop
DSP
BRAM
Clock Freq

Power (W)

Vivado 2017.2
16-bit ﬁxed point
261,357 (31.52X)
119,260 (31.40X)
768 (48X)
457.5 (0.94X)
125MHz
Static: 7.9
Running: 15.2

Xilinx SDx 2017.1
16-bit ﬁxed point
406,861 (49.07X)
402,876 (106.07X)
2675 (167.19X)
966 (1.98X)
200MHz

Running: 22

SID
Supports LSTM
and other RNNs,
ML models and
statistical tests
Xilinx Zynq-
7000 SoC ZC706
Evaluation Kit
XC7Z045
FFG900
Vivado 2016.2
32-bit ﬁxed point
8,292 (1X)
3,798 (1X)
16 (1X)
489 (1X)
115MHz
Static: 0.12
Running: 0.62

TABLE V: Hardware utilization and power compared to
performance-oriented RNN accelerators

We implement an FPGA prototype of the SID module. The
implementation has four parallel tracks and a 256-byte scratch-
pad. The size of the data RAM is 1.75MB (448 × 4kB BRAM
blocks) and the size of the instruction RAM is 128KB (32×4kB
BRAM blocks). We use 32-bit ﬁxed-point numbers, since

MLP-50MLP-500MLP-50-25MLP-200-100SVMOCSVMLSTM-200PED-LSTM-200-OCSVMPED-LSTM-200-Votemodel name0.00.20.40.60.81.01.21.41.6Execution Time (ms)CPUGPUSID020406080100Average Accuracy (%)Comparison of Execution Time of ModelsMLP-50MLP-500MLP-50-25MLP-200-100SVMOCSVMLSTM-200PED-LSTM-200-OCSVMPED-LSTM-200-Votemodel name0200400600800100012001400Model Size (KB)020406080100Average Accuracy (%)Accuracy vs Memory Usageprior work [14] has shown signiﬁcant accuracy degradation
with 16-bit numbers. The platform board is Xilinx Zynq-7000
SoC ZC706 evaluation kit. The hardware implementation is
generated with Vivado 2016.2.

In Table V, we compare SID to two FPGA implementations
of RNN accelerators, DeltaRNN [8] and C-LSTM [25], as the
LSTM or GRU RNN computation is used in the LAD scenario
and accounts for most of its execution time and memory
usage. DeltaRNN ignores the minor change in the input of
gated recurrent unit (GRU) RNN to reuse the old computation
result and thus reduces the computation workload. C-LSTM
shows that, some matrices in LSTM can be represented as
multiple block-circulant matrices and reduces the storage and
computation complexity. These two accelerators are capable
of inferring the RNN but lack the support for generating
and comparing empirical PED’s, which we have shown is
indispensable to achieve acceptable accuracy.

The FPGA resource usage of Slice LUTs, Slice Flip-ﬂops
and DSPs of SID are one or two orders of magnitude less
than the other two, which shows a major difference between
the minimalist SID module and the performance-oriented
accelerators. We measure the FPGA power consumption using
TI Fusion Digital Power Designer tool. The power consumption
is an order of magnitude less, making it more suitable for a
smartphone. We use an FPGA implementation as a prototype
of SID to compare with existing FPGA accelerators. Further
power reduction is achievable using an ASIC implementation
in real smartphone products.

D. Energy Consumption versus CPUGPU

We evaluate the energy consumption of platforms supporting
the impostor detection algorithms within one period of sensor
reading (PoS), which is also the period of real-time detection.
The energy consumption includes that consumed during execu-
tion when the devices are actively running and also the energy
when they ﬁnish execution and become idle. Speciﬁcally, the
equations to model the energy consumption of the CPUGPU
platform and the SID platform are given in Eq (7). Prun and
Pidle are the power consumption when a device is running the
detection algorithms or in the idle state. t∗ is the time when the
corresponding device is executing the algorithm. T is the PoS,
so T − t∗ is the time within a PoS when the corresponding
device is not executing anything.

E(CPUGPU) = Prun(CPU) × tCPU + Pidle(CPU) × (T − tCPU )+

Prun(GPU) × tGPU + Pidle(GPU) × (T − tGPU )

(7)

E(SID) =Prun(SID) × tSID + Pidle(SID) × (T − tSID)

We then apply our model to compare the energy consumption
used by the two platforms within a single period of sensor
reading. We present a conservative comparison by not including
the CPU energy in the equation of E(CPUGPU) as the CPU
typically runs many processes and the statistical computations
it does for impostor detection may not add much to the total
energy consumption.

The idle and running power of GPU and SID are given
in Table VI. The GPU power is measured using the nvidia-
smi tool when the GPU is idle or is running the detection

10

GPU
SID

Idle Power (W)
8
0.12

Running Power (W)
56
0.62

TABLE VI: Idle and running power of different devices

algorithm. The power consumption of our SID module is as
given in Table V. Figure 7 shows the energy consumption
normalized to the SID platform when running the models on
the two platforms. The average consumption for all models
on the CPU-GPU platform is 64.41X higher than that of the
SID platform. Interestingly, the ratio of energy consumption
is close to the ratio of idle powers of the two platforms
( 8
0.12 = 66.66). The takeaway is that when the execution
time is short compared to the PoS (Section V-A), the energy
consumption is determined by that consumed in the idle state,
which complies with our effort to reduce hardware cost and
static power. SID also frees up the GPU for its original graphics
purposes, rather than tying it up for impostor detection.

Fig. 7: Normalized energy consumed by the impostor detection
algorithms within one sensor reading period

VI. RELATED WORK

Dedicated accelerators for a single machine learning (ML)
algorithm have been built by researchers, e.g. for SVM [18]
[19], for k-th neatest neighbors [23] and for k-means [3].

Accelerators are also built for deep learning (DL) algo-
rithms, e.g. for deep neural networks (DNNs). Many of
these accelerators are designed with insights identiﬁed in
software execution. EIE [9] and Minerva [20] exploit data
sparsity of weights and activations during inference to improve
performance and energy efﬁciency. The sparsity in training
is exploited in [22] to improve performance. Minerva [20]
presents a framework to reduce power consumption by ﬁnding
the optimal data quantization in the accelerator with software
exploration. Weight sharing in CNN is identiﬁed by [24] in early
software exploration before designing a dedicated accelerator.
These accelerators beneﬁt from different properties of DNN
models to improve performance or energy efﬁciency, but the
versatility for implementing other ML/DL algorithms is not
considered, as we do for SID.

Some hardware accelerators also target supporting multiple
machine learning models. [16] evaluates the acceleration of

MLP-50MLP-500MLP-50-25MLP-200-100SVMOCSVMLSTM-200PED-LSTM-200-OCSVMPED-LSTM-200-Votemodel name010203040506070Normalized Energy ConsumptionComparison of Energy ConsumptionCPUGPUSIDfour models in an embedded CPU-GPU-Accelerator system.
MAPLE [15] accelerates the vector and matrix operations found
in ﬁve classiﬁcation workloads. PuDianNao [14] highlights the
non-vector operations and data locality in seven ML techniques.
While these work support their chosen ML/DL algorithms, they
do not support other needed processing such as statistical KS
tests as we do.

For minimalist hardware design, we incorporate conventional
energy-saving techniques, e.g. the tiling method [4], that can
beneﬁt multiple ML/DL algorithms. We do not implement
hardware modules for a speciﬁc ML/DL algorithm. To the best
of our knowledge, we are the ﬁrst to explore the direction of
delivering versatility and sufﬁcient hardware performance to
solve a critical security problem, like smartphone impostor de-
tection, with reduced energy consumption, rather than shooting
for maximum performance or minimum power efﬁciency.

dependent variable (impostor or not), i.e.:

ˆy = f (wT x + b)
(8)
where x denotes the input, wT represents the transpose of w,
and f (z) = 1
1+e−z is the logistic function. The model prediction
ˆy ∈ (0, 1) can be interpreted as the probability of x being an
impostor. The model parameters w and b are trained to ﬁt the
training data by minimizing the cross-entropy loss.
Support Vector Machine is a popular linear model in machine
learning. To perform a binary classiﬁcation, it identiﬁes a
hyperplane (wT x + b in Eq (9)) as the decision boundary where
w is the normal vector of the hyperplane. Sign(·) is the sign
function. Unlike the logistic regression, w and b are trained
by maximizing the hinge loss. A property of the SVM is w
can be represented by a weighted average of support vectors
(a subset of data points in the training set).

VII. CONCLUSIONS

We show how sensors in a smartphone can be used to detect
smartphone impostors and theft by identifying the current user
using Deep Learning models like MLP and LSTM or GRU
and the empirical PED’s. We explore the algorithms that are
needed in two scenarios, IDaaS and LAD, when users can or
cannot use other people’s data for training.

We design a hardware module, SID , to support the best
impostor detection algorithms we found in both scenarios. It
is also versatile enough to support other ML/DL algorithms
as well as collecting and comparing empirical probability
distributions that we use to represent user behavior. This enables
users of SID to tradeoff security with data privacy in choosing
one of the two scenarios, as well as choosing trade-offs in
security with usability and accuracy with execution time and
memory storage. Our SID macro instructions can also map the
same code to SID hardware substrates with different amounts
of parallel computation tracks. For efﬁciency, SID reduces
hardware resource usage by maximally reusing functional units.
Our evaluation shows that our FPGA implementation of SID has
a major difference with accelerators targeting similar ML/DL
models: SID provides sufﬁcient performance with minimal
hardware and energy costs, which are one to two orders of
magnitude less than performance-oriented FPGA accelerators.
Using a general energy consumption model, we also show that
the consumption of the FPGA implementation of a SID module
is 64.41X smaller than the CPU-GPU platform.

We hope to have shown a new direction for computer
architecture in the ML/DL domain: consider broader goals
and trade-offs for real security (or other domain) needs rather
than focus on optimizing just performance or power. Also, we
hope to have shown the importance of a design methodology
that considers both algorithm and architecture optimizations in
solving critical problems like impostor detection, preventing
subsequent conﬁdentiality and integrity breaches.

APPENDIX A
CLASSIFICATION ALGORITHMS

Logistic Regression uses a logistic function to model a binary

ˆy = sign(wT x + b) = sign(

N
∑
i=1

ai(cid:104)vi, x(cid:105) + b)

(9)

where N is the number of support vectors, vi’s are the support
vectors, ai’s are the weights in representing w of support vectors
and < · > is the inner product of vectors.

If the data points are not linearly separable in the original
space, a typical way is to map the data into a high-dimensional
space where they can be linearly separated. A kernel function
can be leveraged to obtain an equivalent classiﬁer in the high-
dimensional space, by replacing the inner product in Eq (9).
The kernel function used in this paper is the Gaussian Kernel,
i.e. κ(u, v) = e−γ(cid:107)u−v(cid:107)2
Kernel Ridge Regression. Similar to SVM, ridge regression
can be used as a linear classiﬁer for binary classiﬁcation:

.

ˆy = sign(wT x + b)

(10)

However, different from SVM and logistic regression, ridge
regression is a technique speciﬁcally designed to deal with
ill-posed problems with very limited data, by introducing an
extra l2 norm of w in the loss function during training. Kernel
ridge regression (KRR) is when the same kernel trick as for
SVM can be applied to ridge regression.
Multi-layer Perceptron (MLP) is a family of feed-forward
neural network models, consisting of an input layer, an output
layer and one or more hidden layers in between. Each layer of
neurons linearly transforms all signals from the previous layer,
applies a non-linear activation function and outputs to the next
layer. Finally, a softmax function 2 is applied to output the
probabilities of classes. Formally,

h1 = f (W T

1 x + b1)

...

hn = f (W T
ˆy = so f tmax(hn)

n hn−1 + bn)

where hi denotes the output of layer i, f denotes a non-linear
activation function, e.g. sigmoid or ReLU 3. Similar to logistic

2Softmax(z) = ezi
∑i ezi
3ReLU(z) = z if z ≥ 0, else 0

11

regression, the weight-matrix W ’s and the bias b’s are trained
by minimizing the cross-entropy loss.

REFERENCES

[1] https://www.forbes.com/sites/daveywinder/2019/09/05/facebook-
security-snafu-exposes-419-million-user-phone-numbers/
#5a0d83961ab7, 2019.

[2] https://www.wsj.com/articles/google-exposed-user-data-feared-

repercussions-of-disclosing-to-public-1539017194?mod=hp lead pos1,
2019.

[3] T. Chen and S. Chien, “Flexible hardware architecture of hierarchical
k-means clustering for large cluster number,” IEEE Transactions on Very
Large Scale Integration (VLSI) Systems, vol. 19, no. 8, pp. 1336–1345,
Aug 2011.

[4] T. Chen, Z. Du, N. Sun, J. Wang, C. Wu, Y. Chen, and O. Temam,
“Diannao: A small-footprint high-throughput accelerator for ubiquitous
machine-learning,” in Proceedings of the 19th International Conference
on Architectural Support for Programming Languages and Operating
Systems, ser. ASPLOS ’14. New York, NY, USA: ACM, 2014, pp. 269–
284. [Online]. Available: http://doi.acm.org/10.1145/2541940.2541967
[5] L. Codrescu, “Architecture of the hexagon 680 dsp for mobile imaging
and computer vision,” in 2015 IEEE Hot Chips 27 Symposium (HCS).
IEEE, 2015, pp. 1–26.

[6] D. Dheeru and E. Karra Taniskidou, “UCI machine learning repository,”

2017. [Online]. Available: http://archive.ics.uci.edu/ml

[7] M. Frank, R. Biedert, E. Ma, I. Martinovic, and D. Song, “Touchalytics:
On the applicability of touchscreen input as a behavioral biometric for
continuous authentication,” IEEE transactions on information forensics
and security, vol. 8, no. 1, pp. 136–148, 2012.

[8] C. Gao, D. Neil, E. Ceolini, S.-C. Liu, and T. Delbruck, “Deltarnn: A
power-efﬁcient recurrent neural network accelerator,” in Proceedings of
the 2018 ACM/SIGDA International Symposium on Field-Programmable
Gate Arrays. ACM, 2018, pp. 21–30.

[9] S. Han, X. Liu, H. Mao, J. Pu, A. Pedram, M. A. Horowitz, and
W. J. Dally, “Eie: efﬁcient inference engine on compressed deep neural
network,” in 2016 ACM/IEEE 43rd Annual International Symposium on
Computer Architecture (ISCA).

IEEE, 2016, pp. 243–254.

[10] M. Kazachuk, A. Kovalchuk, I. Mashechkin, I. Orpanen, M. Petrovskiy,
I. Popov, and R. Zakliakov, “One-class models for continuous authen-
tication based on keystroke dynamics,” in International Conference on
Intelligent Data Engineering and Automated Learning. Springer, 2016,
pp. 416–425.

[11] R. Kumar, P. P. Kundu, and V. V. Phoha, “Continuous authentication using
one-class classiﬁers and their fusion,” in 2018 IEEE 4th International
Conference on Identity, Security, and Behavior Analysis (ISBA).
IEEE,
2018, pp. 1–8.

[12] W.-H. Lee and R. B. Lee, “Implicit smartphone user authentication with
sensors and contextual machine learning,” in Dependable Systems and
Networks (DSN), 2017 47th Annual IEEE/IFIP International Conference
on.

IEEE, 2017, pp. 297–308.

[13] P. Liatsis and Q. D. Tran, “One-class classiﬁcation in multimodal biome-
trie authentication,” in 2017 International Conference on Infocom Tech-
nologies and Unmanned Systems (Trends and Future Directions)(ICTUS).
IEEE, 2017, pp. 37–42.

[14] D. Liu, T. Chen, S. Liu, J. Zhou, S. Zhou, O. Teman, X. Feng, X. Zhou,
and Y. Chen, “Pudiannao: A polyvalent machine learning accelerator,” in
Proceedings of the Twentieth International Conference on Architectural
Support
for Programming Languages and Operating Systems, ser.
ASPLOS ’15. New York, NY, USA: ACM, 2015, pp. 369–381.
[Online]. Available: http://doi.acm.org/10.1145/2694344.2694358
[15] A. Majumdar, S. Cadambi, M. Becchi, S. T. Chakradhar, and H. P.
Graf, “A massively parallel, energy efﬁcient programmable accelerator
for learning and classiﬁcation,” ACM Transactions on Architecture and
Code Optimization (TACO), vol. 9, no. 1, p. 6, 2012.

[16] A. Majumdar, S. Cadambi, and S. T. Chakradhar, “An energy-efﬁcient
heterogeneous system for embedded learning and classiﬁcation,” IEEE
embedded systems letters, vol. 3, no. 1, pp. 42–45, 2011.

[17] P. Malhotra, L. Vig, G. Shroff, and P. Agarwal, “Long short term memory
networks for anomaly detection in time series,” in Proceedings. Presses
universitaires de Louvain, 2015, p. 89.

[18] M. Papadonikolakis and C. Bouganis, “Novel cascade fpga accelerator
for support vector machines classiﬁcation,” IEEE Transactions on Neural
Networks and Learning Systems, vol. 23, no. 7, pp. 1040–1052, July
2012.

[19] M. Papadonikolakis and C.-S. Bouganis, “A heterogeneous fpga archi-
tecture for support vector machine training,” in 2010 18th IEEE Annual

12

International Symposium on Field-Programmable Custom Computing
Machines.

IEEE, 2010, pp. 211–214.

M. Platzner, “A hardware accelerator for k-th nearest neighbor thinning.”
in ERSA. Citeseer, 2008, pp. 245–251.

[20] B. Reagen, P. Whatmough, R. Adolf, S. Rama, H. Lee, S. K. Lee,
J. M. Hern´andez-Lobato, G.-Y. Wei, and D. Brooks, “Minerva: Enabling
low-power, highly-accurate deep neural network accelerators,” in 2016
ACM/IEEE 43rd Annual International Symposium on Computer Archi-
tecture (ISCA).

IEEE, 2016, pp. 267–278.

[21] J.-L. Reyes-Ortiz, L. Oneto, A. Sam`a, X. Parra, and D. Anguita,
“Transition-aware human activity recognition using smartphones,” Neuro-
computing, vol. 171, pp. 754–767, 2016.

[22] M. Rhu, M. O’Connor, N. Chatterjee, J. Pool, Y. Kwon, and S. W.
Keckler, “Compressing dma engine: Leveraging activation sparsity for
training deep neural networks,” in 2018 IEEE International Symposium
on High Performance Computer Architecture (HPCA).
IEEE, 2018, pp.
78–91.

[23] T. Schumacher, R. Meiche, P. Kaufmann, E. L¨ubbers, C. Plessl, and

[24] M. Song, K. Zhong, J. Zhang, Y. Hu, D. Liu, W. Zhang, J. Wang, and
T. Li, “In-situ ai: Towards autonomous and incremental deep learning
for iot systems,” in 2018 IEEE InternatiOnal SympOsium On High
PerfOrmance COmputer Architecture (HPCA).
IEEE, 2018, pp. 92–103.
[25] S. Wang, Z. Li, C. Ding, B. Yuan, Q. Qiu, Y. Wang, and Y. Liang, “C-
lstm: Enabling efﬁcient lstm using structured compression techniques on
fpgas,” in Proceedings of the 2018 ACM/SIGDA International Symposium
on Field-Programmable Gate Arrays. ACM, 2018, pp. 11–20.
[26] Y. Wang, K. Streff, and S. Raman, “Smartphone security challenges,”

Computer, vol. 45, no. 12, pp. 52–58, 2012.

[27] N. Zheng, K. Bai, H. Huang, and H. Wang, “You are how you touch:
User veriﬁcation on smartphones via tapping behaviors,” in 2014 IEEE
22nd International Conference on Network Protocols.
IEEE, 2014, pp.

221–232.

13

