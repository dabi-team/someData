0
2
0
2

v
o
N
0
1

]
E
S
.
s
c
[

1
v
2
6
9
4
0
.
1
1
0
2
:
v
i
X
r
a

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

1

Characterization and Automatic Update of
Deprecated Machine-Learning API Usages

Stefanus Agus Haryono, Ferdian Thung, David Lo, Julia Lawall, Lingxiao Jiang

Abstract—Due to the rise of AI applications, machine learning libraries have become far more accessible, with Python being the most
common programming language to write them. Machine learning libraries tend to be updated periodically, which may deprecate
existing APIs, making it necessary for developers to update their usages. However, updating usages of deprecated APIs is typically not
a priority for developers, leading to widespread usages of deprecated APIs which expose library users to vulnerability issues. In this
paper, we built a tool to automate these updates. We ﬁrst conducted an empirical study to seek a better understanding on how updates
of deprecated machine-learning API usages in Python can be done. The study involved a dataset of 112 deprecated APIs from
Scikit-Learn, TensorFlow, and PyTorch. We found dimensions of deprecated API migration related to its update operation (i.e.,
the required operation to perform the migration), API mapping (i.e., the number of deprecated and its corresponding updated APIs),
and context dependency (i.e., whether we need to consider surrounding contexts when performing the migration). Guided by the
ﬁndings on our empirical study, we created MLCatchUp, a tool to automate the update of Python deprecated API usage that
automatically infers the API migration transformation through comparison of the deprecated and updated API signatures. These
transformations are expressed in a Domain Speciﬁc Language (DSL). We evaluated MLCatchUp using test dataset containing 258 ﬁles
with 514 API usages that we collected from public GitHub repositories. In this evaluation, MLCatchUp achieves a precision of 86.19%.
We further improve the precision of MLCatchUp by adding a feature that allows it to accept additional user input to specify the
transformation constraints in the DSL for context-dependent API migration. Using this addition, MLCatchUp achieves a precision of
93.58%, which is a 7.39% precision improvement from our original solution.

Index Terms—Python, Program Transformation, Automatic Update, Deprecated API, Domain Speciﬁc Language

(cid:70)

1 INTRODUCTION

The popularity of machine learning has surged in recent
years, among both developers and researchers. Currently,
the most popular programming language for machine learn-
ing is Python, due to the vast amount of Python libraries
that support and provide machine learning capability. Fur-
thermore, these libraries offer easy to use APIs, which allow
developers to utilize machine learning without knowing the
low-level implementation details.

Libraries are typically updated from time to time to add
new features, ﬁx bugs, or improve performance. With each
new update, changes in the library’s APIs are inevitable,
which may include API deprecations. Usages of deprecated
APIs must be replaced with their corresponding updated
APIs to ensure that the code works with the future ver-
sion of the library. Such deprecation also occurs in Python
machine learning libraries. Using the latest version of ma-
chine learning library is important for the performance and
security of the program. Han et al. [1] stated that to take
full advantage of deep learning libraries, users must always
keep up to date with the latest library versions. A study
by Wang et al. [2] supports a similar argument, stating that
using an older version of deep learning library may expose
library users to security issues and worse performance.

However, updating usages of deprecated APIs can be
cumbersome and time-consuming. This affect some devel-

•

•

S. A. Haryono, F. Thung, D. Lo, and L. Jiang are with School of
Information Systems, Singapore Management University, Singapore.
E-mail:{stefanusah,ferdianthung,davidlo,lxjiang}@smu.edu.sg
J. Lawall is with Inria, France.
E-mail:Julia.Lawall@inria.fr

opers to prefer using the older versions of a library, as
demonstrated by several studies [1], [2], [3]. Hence, provid-
ing a better alternative to manually updating the usages
of Python deprecated machine learning library APIs can
beneﬁt many developers. Although deprecation of machine
learning library APIs is common, each deprecation affects
the API usages differently. Some deprecations can be ﬁxed
easily while others may require a deep understanding of
the workﬂow or functionality of the API. No studies have
attempted to get a better understanding on the depre-
cated API migration pattern for Python machine-learning
libraries.

Prior to this study, several attempts have been made to
automate the update of deprecated API usages in other pro-
gramming languages. A4 [4] is an approach for automatic
Android API migration by learning API migration patterns
from code examples. AppEvolve [5], provides automated
API usage update for Android by using before- and after-
update code example to create an update patch. Extending
AppEvolve, CocciEvolve [6] provides an automated API
usage update for Android using only a single after-update
example, providing an easily readable transformation ex-
pressed in the form of semantic patch language (SmPL).
NEAT [7] generates transformation rules for deprecated An-
droid API usage replacements without any usage example.
NEAT constructs signature graph to do the type conversions
required by the API replacement. No previous work has
targeted Python API deprecation.

In this study, we followed an ”as simple as possible,
but no simpler” approach – as advocated in many recent
studies [8], [9], [10] – by ﬁrst doing an empirical study to

 
 
 
 
 
 
JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

ascertain the level of innovation needed and then designing
a suitably complex solution to address the problem at hand.
Through this empirical study, we aim to discover depre-
cated API migration dimensions in popular Python machine
learning libraries. Within each dimension, we deﬁne the
categories of deprecated API migrations that exist in Python
machine learning libraries.

For our case study, we picked a subset of the available
Python machine libraries based on the number of GitHub
repositories that depend on the library (obtained through
GitHub dependency graph1). According to this statistic,
as of August 2020, more than 120,000 repositories utilize
Scikit-learn, while more than 82,000 repositories use
Tensorflow. Keras and Pytorch each have at least
52,000 and 34,000 utilizing repositories respectively. How-
ever, since Keras is included within TensorFlow as of
January 2017,2 we picked Scikit-Learn, TensorFlow,
and PyTorch as our case study libraries. We collected API
deprecation messages from the documentation and changel-
ogs of the last two years’ (July 2018 - August 2020) major
and minor releases of these libraries, where we found a
total of 112 distinct APIs that were deprecated. We uti-
lized manual thematic analysis and found three common
dimensions in deprecated API migration, namely the chosen
update operation (based on the type of operation done in
the API migration), the API mapping (based on the number
of deprecated and updated APIs), and the need for context
dependency (based on whether the API migration depends
on information in the surrounding usage context). We also
labelled each of the collected deprecated APIs based on the
categories within each dimension to learn their distribution.
Based on the ﬁndings in the empirical study, we propose
a tool to automate the update of Python deprecated API
usages called MLCatchUp. MLCatchUp takes as input the
deprecated API signature, the updated API signature, and
the ﬁle to be updated. It then automatically infers the
required transformation by comparing the deprecated and
updated APIs’ signatures. The inferred transformations are
expressed in the form of a Domain Speciﬁc Language (DSL)
that we built based on the results of our empirical study.

A comparison of features between MLCatchUp and
other similar refactoring and automatic API usage update
tools [4], [5], [6], [7] is shown in Table 1. Compared to the
tools from previous studies, MLCatchUp is the only tool
that supports the Python language along with its unique
features. Python has several unique features, including pa-
rameter default values, two types of parameters (positional
parameter and keyword parameter), the usage of whites-
paces and indentation as separator, and dynamic typing. A
keyword parameter is a type of parameter that can only
be addressed through its name, which is in contrast with
positional parameter that can be addressed through both
its position and name. The usage of whitespaces and in-
dentation as separator makes parsing Python code different
from other languages which typically depends on a speciﬁc
symbol (e.g. Java and C which use semicolons and brackets).
Among the previous tools, the closest work to ours is NEAT

TABLE 1: Comparison of features between various auto-
mated API usage update tools

2

MLCatchUp

A4, AppEvolve,
CocciEvolve

NEAT

Automated API us-
age update
Requires API mi-
gration example
Default parameter
support
Keyword parame-
ters support
Python
support

language

[7]. However, the NEAT algorithm does not work well
for Python. NEAT requires the parameter types of all API
within a library to perform the automatic update. The need
of parameter types for all API within the library means
that we also need to label the type for APIs that are not
deprecated. Due to the dynamic nature of Python, we would
need to do this parameter types labelling manually, which
renders NEAT no longer fully automatic.

We evaluated MLCatchUp using a dataset that we col-
lected from public GitHub repositories using our proto-
type Python API usage GitHub search tool. Our evaluation
dataset is comprised of 258 ﬁles containing 514 deprecated
API usages from 66 different Python machine learning li-
brary APIs. The update results created by MLCatchUp are
manually labelled by Python programmers with at least 4
years of experience who are not co-authors of this study.
Based on the evaluation result, MLCatchUp achieves a
precision of 86.19%. We also conducted a qualitative study
on the failed update results, where we found one of the
main faults to be MLCatchUp’s inability to infer transfor-
mation constraints for context-dependent deprecated API
migrations. To mitigate this problem, we add a feature into
MLCatchUp to accept additional user input in the form of a
transformation constraint. Using this feature, we conducted
a follow-up experiment where MLCatchUp achieved 93.58%
precision.

MLCatchUp is beneﬁcial for library users, library devel-
opers, and future researchers who aim to ease the process
of updating deprecated API usages. For library users, ML-
CatchUp can be used to assist them in updating the usages
of deprecated API within their codebase, signiﬁcantly re-
ducing the time required to update into a newer version
of a library. Library developers can create a script that
makes use of MLCatchUp to update deprecated API usages
within code. This script can then be distributed alongside
the update of the library, making it easier for users to update
the library. For future researchers, MLCatchUp can be a
foundation for studies and tools on automated deprecated
API usage update, especially for the Python programming
language.

In summary, the main contributions of this work are as

follows:

1. https://docs.github.com/en/github/visualizing-repository-data-

with-graphs/about-the-dependency-graph

2. https://www.fast.ai/2017/01/03/keras/

• We collect a list of Python deprecated APIs from the
releases over the last two years of Scikit-Learn,
TensorFlow, and PyTorch by manually reading their

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

major and minor releases changelogs.

• We deﬁne the dimensions of Python deprecated API
usage migrations and compute the distributions for
each dimension’s categories to determine which type
of API usage migration should be prioritized in the
creation of an update tool.

• We create MLCatchUp, an automated Python API us-
age update tool that can infer the required API trans-
formation automatically. To the best of our knowledge,
we are the ﬁrst to create such a tool for Python.

• We evaluate MLCatchUp using our manually collected
dataset of 514 deprecated API usages collected from
public Github repositories, where MLCatchUp achieves
86% precision.
The rest of this paper is organized as follows. Section 2
discusses our empirical study of Python deprecated API
usage migrations and our ﬁndings from this study. Section 3
talks about the structure and features of our Python API
usage automated update tool, MLCatchUp. Section 4 de-
scribes our evaluation of MLCatchUp, including the dataset
used, the evaluation results, and our ﬁndings. Section 5 talks
about the threats to validity of our work. Section 6 discusses
related works on API deprecation and program transforma-
tion. Finally, Section 7 summarizes and concludes our work
and talks about the possibilities for future work.

2 EMPIRICAL STUDY

Through this empirical study, we seek to get a better un-
derstanding of the categories of deprecated API migrations
when updating usages of deprecated machine-learning APIs
in Python. We also measure the distribution of these cate-
gories to better comprehend which categories are the most
relevant to Python machine-learning libraries. Using these
ﬁndings and analysis, our aim is to create a tool that can
automate the process of updating the usage of deprecated
Python machine learning APIs.

The process of our empirical study is as follows. First,
we deﬁne the research questions that we attempt to answer.
Second, we select the libraries and APIs that we use as
our case study and deﬁne our approach in collecting those
APIs. Third, we analyze the categories of deprecated API
migration from our case study to answer our ﬁrst research
question. Finally, we measure the distribution of the depre-
cated API migration categories within our case study APIs
to answer the second research question.

2.1 Research Questions

In this empirical study, we analyze the API migration di-
mensions of Python machine learning libraries and their
prevalence in these libraries. We ask the following research
questions:
• RQ1 What are the dimensions of the API migrations for Python

machine-learning deprecated API usages?
Currently, the API migration dimensions in deprecated
Python APIs are unknown. Understanding these dimen-
sions and their categories would help us in designing an
automatic deprecated API migration tool.

• RQ2 What is the distribution of deprecated API migrations in

Python machine-learning libraries?

3

Understanding the frequency of each API migration di-
mension and its categories will help researchers to deter-
mine the most common API migrations. Having such an
understanding is beneﬁcial in creating tools to ease the
process of updating deprecated APIs. Information on the
frequency of each API migration dimension’s categories
will help researchers and API migration tool developers
in determining what type of API migration should be
prioritized in the creation of an update tool.

2.2 Case Study Data Collection

One of the main problems in collecting API deprecations
from Python machine-learning libraries is that there are no
clear speciﬁcations or standards on how the deprecations
are documented. Each of these machine learning libraries
has a different way of documenting their API deprecations.
Moreover, even within the same library, the documentation
for API deprecation varies. While Python provides a warn-
ing function that can be used to mark a deprecated API,3 it
is not commonly used by API developers.

As a consequence of the varying deprecation documen-
tation, there is no automatic approach capable of listing
the deprecations of machine learning library APIs. Fur-
thermore the documentation and changelogs of all of the
libraries that we consider are in the form of unstructured
text, making it even harder to automatically collect the API
deprecations. Thus, we collected the API deprecations by
manually reading the changelog of each library. To ease our
search, we focused on looking for text containing the word
”deprecat-” and ”replace-”, which indicates API deprecation
or replacement. For scikit-learn, the changelog is avail-
able in their ofﬁcial documentation page.4 For Pytorch5
and TensorFlow,6 the changelog can be found in their
GitHub release page.

We thoroughly read the documentation provided by
each library to collect a list of API deprecations and their
updated APIs. We limit our manual collection effort to the
changelogs of major and minor releases in the last two years
(July 2018 - August 2020). For scikit-learn, we read
the changelogs of versions 0.21.0, 0.22.0, and 0.23.0. For
Pytorch, our study includes the changelogs of versions
0.4.1, 1.0.0, 1.1.0, 1.2.0, 1.3.0, 1.4.0, 1.5.0, and 1.6.0. Lastly,
we included the changelogs of TensorFlow versions 1.9.0,
1.10.0, 1.11.0, 1.12.0, 1.13.0, 1.14.0, 1.15.0, 2.0.0, 2.1.0, 2.2.0,
and, 2.3.0.

From the documentation, we found a total of 112 pairs of
deprecated APIs and their updated APIs, distributed across
the libraries as shown in Table 2. TensorFlow has the high-
est number of deprecated APIs due to a signiﬁcant update
from version 1.x to 2.x, which introduced a compatibility
API module. This compatibility module provides an inter-
face to make use of deprecated APIs from the older version
of TensorFlow. The creator of TensorFlow recommends to
immediately update any use of the compatibility module
API to the newer API in the 2.x versions.7

3. https://docs.python.org/3/library/warnings.html
4. https://scikit-learn.org/stable/whats˙new/v0.23.html
5. https://github.com/pytorch/pytorch/releases
6. https://github.com/TensorFlow/TensorFlow/releases
7. https://www.tensorﬂow.org/guide/upgrade

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
TABLE 2: Number of Deprecated APIs in Machine-Learning
Libraries

Library
Scikit-Learn
TensorFlow
PyTorch
Total

# Deprecated APIs
22
54
36
112

2.3 RQ1: Deprecated API Migration Dimensions

In this research question, we aim to ﬁnd the deprecated API
migration dimensions in Python machine-learning libraries.
To answer this research question, we utilized thematic
analysis, which is a qualitative data analysis method for
systematically identifying, organizing, and offering insight
into patterns or themes across a dataset [11]. We followed
the six steps of thematic analysis using the 112 deprecated
APIs that we collected. These steps are as follows:

1) Familiarization with the data. Familiarization with the
data is done by thoroughly reading and analyzing the
deprecated API migration data that we collected. In
our study, data refers to the deprecated and updated
signatures of the 112 deprecated APIs that we collected.
2) Initial coding of the data. Code refers to the patterns or
actions of the API migrations that are done to update
the usage of deprecated APIs.

3) Searching for themes. In our study, the themes that we
aim to collect are the dimensions of deprecated API
migrations. In this step, we search for the common
dimensions of API migration that appear in multiple
different deprecated APIs.

4) Reviewing themes. We review the dimensions of API
migrations that we found to ensure that all of the
found dimensions are relevant. Similar dimensions are
merged, while irrelevant dimensions are discarded.
5) Deﬁning and naming themes. We deﬁne the dimensions of
deprecated API migrations and provide an informative
name for each dimension that reﬂects its themes and
meaning.

6) Writing up the results. Finally, we write the result of our
analysis, which is compiled in the empirical study of
this paper.
We found three dimensions of deprecated API migration,
which are related to the update operation required to perform
the migration, the API mapping from the deprecated to the
updated APIs, and the context dependence of the migration
(see Section 2.4 for the distribution of these dimensions).
The deﬁnitions of these dimensions and their categories are
as follows:
Update Operation. We observe common patterns in the
updates required to migrate a deprecated API to its updated
APIs by looking at the differences between the signatures of
the two APIs. We found the following categories of update
operations:
• Remove parameter: This operation removes the depre-
cated API usage function parameter(s). An example of
this update operation can be seen in Figure 1. In this
example, the API sklearn.cluster.KMeans has the
deprecated parameter n_jobs in line 2. After the update,
the parameter is removed, with the result shown in line 3.

4

1
2
3

-
+

from sklearn.cluster import KMeans
clusterer = KMeans(n_clusters = 3, n_jobs = 1)
clusterer = KMeans(n_clusters = 3)

Fig. 1: Remove parameter operation to migrate dep-
recated sklearn.cluster.KMeans API usage from
scikit-learn version 0.23.0

1
2
3
4
5

-
+

import torch
t_0 = torch.randn((3, 3))
t_1 = torch.ones_like(t_0)
t_add = torch.add(t_0, 10, t_1)
t_add = torch.add(t_0, t_1, alpha=10)

Fig. 2: Positional to keyword parameter operation to migrate
deprecated torch.add API usage from PyTorch version
1.5.0

• Rename parameter: This operation replaces one or more
keyword parameter names with a new name. Similar
to remove parameter deprecation, this update operation
only affect API usages where the deprecated keyword
parameter is explicitly declared.

• Convert positional parameter to keyword parameter:
This operation removes the positional parameter(s) and
uses their value(s) to create new keyword parameter(s)
within the API usage. An example of this update op-
eration can be seen in Figure 2. In this example, the
torch.add API’s second positional parameter is depre-
cated and replaced with the keyword parameter alpha.
The deprecated API usage can be seen in line 4, while the
updated code can be seen in line 5.

• Rename a method: This operation renames the function
and/or the module of the API that is deprecated into a
new updated name. Figure 3 shows an example of this
update operation for a torch.gels API usage in line
3. The torch.gels method name is deprecated and is
replaced with the new name torch.lstsq.

• Add a parameter: This operation adds a positional/key-
word parameter to an API invocation, as illustrated
in Figure 4. In lines 3-5, we can see the deprecated
torch.nn.functional.affine_grid API usage, in
which the keyword parameter align_corners is not
speciﬁed. To update this deprecated API usage, a new
keyword parameter align_corners needs to be added
as can be seen in lines 6-7.

• Change a parameter type: This operation changes the
type of a deprecated API usage parameter. The operation
ﬁrst checks whether the type of the current API argu-
ment matches the new type of the updated API. If the
current argument type does not match the new type, the
deprecated API argument needs to be changed to follow

1
2
3
4

-
+

import torch
def solve(A, b, out=None, bias=True):

x, _ = torch.gels(b, A)
x, _ = torch.lstsq(b, A)

Fig. 3: Rename method operation to migrate deprecated
torch.gels API usage from PyTorch version 1.3.0

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

5

1
2
3
4
5
6
7

-
+
+

def forward(self, input_image, affine_params):

affine_params = affine_params.view(-1, 2, 3)
affine_grid = torch.nn.functional.affine_grid(

affine_params, (input_image.size(0),
input_image.size(1), *self.img_size))
input_image.size(1), *self.img_size),
align_corners=True)

Fig. 4: Add parameter operation to migrate deprecated
torch.nn.functional.affine_grid API usage from
PyTorch version 1.3.0

1
2
3
4
5
6
7
8

-
-
+
+
+
+

import sklearn
def check_estimator(TestEstimator):

sklearn.utils.estimator_checks.check_

estimator(SklearnWrapperClassifier)

if isinstance(TestEstimator,

sklearn.base.BaseEstimator):
sklearn.utils.estimator_checks.check_

estimator(SklearnWrapperRegressor)

5: Migration for sklearn.utils.estimator_
Fig.
checks.check_estimator deprecated API usage from
scikit-learn version 0.23.0

the new type speciﬁcation. In this operation, a previously
valid type may no longer be usable in the parameter. The
creation of new variables or values may be needed in this
update operation. Figure 5 provides an example of this
operation for sklearn.utils.estimator_checks.
check_estimator deprecated API usage. In this exam-
ple, the allowed parameter type in the updated API is
changed to only the Estimator type. To update this
deprecated API usage, a type check is added for the
function invocation argument (lines 5-8) to ensure that its
value is suitable for the updated API.

• Add a constraint to a parameter value: This operation
adds a constraint to the value of the API parameter due
to a change in the permitted value of the parameter. This
operation adds a value check for the API argument to
ensure that the current value of the argument ﬁts the
newly permitted range of values of the API parameter.
If the current argument does not ﬁt, we need to modify its
value accordingly. An example of this update operation
is shown in Figure 6 for torch.normal deprecated API
usage. In this example, the value of the out argument
must have the same size as the mean and std arguments.
To update the usage of this deprecated API, we add an if
statement that checks the sizes of these objects (line 4-5)
• Remove API: This operation removes the deprecated
API without replacing its usage with any updated API.
This is typically used when the deprecated API is no
longer needed or no longer has any effect when invoked.

1
2
3
4
5
6

-
+
+
+

import torch
def normal(mean, std, output):

torch.normal(mean, std, out=output)
if mean.size()==output.size() and

std.size()==output.size():
torch.normal(mean, std, out=output)

Fig. 6: Migration for torch.normal deprecated API usage
from torch version 1.5.0

1
2
3
4

-
-

from sklearn.linear_model import
logistic_regression_path

classificador = logistic_regression_path(

X=previsores_teste, y=classe_treinamento)

Fig. 7: Migration for sklearn.linear_model.logistic_
regression_path deprecated API usage from sklearn
version 0.21.0

from sklearn.model_selection import KFold
def KFold_Selection(seed):

if seed is not None:

KFold(random_state = seed, shuffle=True)

else:

KFold(random_state = seed)

1
2
3
4
5
6
7
8

+

+
+

Fig. 8: Context-dependent change deprecated API migration
example for sklearn.model_selection.KFold from
scikit-learn version 0.22.0

Figure 7 shows an example of this update operation for
sklearn.linear_model.logistic_regression_
path. To update this deprecated API usage,
deprecated API is removed (line 2).

the

API Mapping. The type of mapping represents the ratio
between the number of the deprecated and updated APIs
involved in the migration. We found three types of map-
pings from our investigation:
• 1:1 API mapping: It occurs when a deprecated API is

modiﬁed or replaced by a single updated API.

• 1:N API mapping: It occurs when a deprecated API is

modiﬁed or replaced by at least two updated APIs.

• 1:0 API mapping: It occurs when a deprecated API is

removed without any suggested replacement.

Context Dependency. It indicates whether the deprecated
API migration depends on the context of the deprecated
API usage. This context refers to the value and type of
the arguments in the deprecated API usage. We found two
categories of context dependency.
• Context-dependent update. It is a migration where the
required update depends on the value of one or more ar-
guments of the API invocation. An example of this case is
found in the sklearn.model_selection.KFold API,
where the usage is only deprecated if the random_state
argument is not None, in which case the shuffle argu-
ment must be set to True. Otherwise, there is no change
to the API. For example, in Figure 8, the update is done
by adding an if statement that checks the value of the
contextual variable seed used as the random_state
argument.

• Context-independent update. This migration is not af-

fected by the value of the API invocation arguments.

2.4 RQ2: Migration Dimensions Distribution

In the second research question, we are interested in the
distribution of deprecated API migration categories within
the dimensions deﬁned in Section 2.3: update operation, API

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
TABLE 3: Distribution of the case study API based on the
required update operation to perform the migration

Remove Param
Rename Param
PosToKey Param
Rename Method
Add Parameter
Change Param Type
Add Param Value Con-
straint
Remove API

Scikit-learn
12
0
0
4
2
2
1

PyTorch
1
1
8
18
1
3
4

TensorFlow
0
25
0
17
9
0
0

1

0

3

TABLE 4: Distribution of the case study API based on its
API mapping

Scikit-learn
21
0
1

PyTorch
36
0
0

TensorFlow
50
1
3

1:1
1:N
1:0

mapping, and context dependency. For this purpose, we
labelled each of the 112 APIs based on the three dimensions
and their categories.

First we label the APIs based on the update opera-
tion. The result of this labelling can be seen in Table 3.
The most common operations vary according to the li-
brary. We found that most deprecated API migrations in
scikit-learn involve removing parameter. PyTorch and
TensorFlow deprecated API migrations mainly rename
methods. TensorFlow API migrations also often rename
parameters. Among the update operations, change parame-
ter type, add constraint to parameter value, and remove API
are the least commonly used, amounting to 5 or fewer APIs
for each update operation.

We also label each API based on its API mapping, as
shown in Table 4. Almost all deprecated API migrations fol-
low the 1:1 transformation, suggesting that API developers
prefer a straightforward, less complex API update. Out of
the 112 APIs, only 1 API follows the 1:N update category.
The 1:0 category is found in 4 APIs.

Then, we label each API based on its update context.
The results of this labelling can be seen in Table 5. The
majority of the API updates are context-independent. Out
of 112 APIs, only 9 API updates are context-dependent.

TABLE 5: Distribution of the case study API based on the
contextual dependency of the API update

Context-independent
Context-dependent

Scikit-learn
19
3

PyTorch
30
6

TensorFlow
54
0

From these distributions within the three dimensions
we found that simpler updates are preferred among dif-
ferent Python machine learning libraries. Rename method,
rename parameter, add parameter, and remove parameter
are the most commonly used, each with at least 10 APIs
using the approach. 107 out of 112 APIs follow the 1:1
update mapping, suggesting a tendency towards a less com-
plex updates. Finally, majority of API updates are context-
independent, which is the case for 103 out of 112 APIs. We
leverage these ﬁndings to guide our priorities in creating

6

automated update tool for Python machine learning depre-
cated API usage.

3 AUTOMATED UPDATE FOR PYTHON DEPRE-
CATED API USAGES
Based on the ﬁndings of our empirical study and the fact
that Python deprecated APIs are still being used by devel-
opers, we are interested in creating an automated approach
to update the usage of Python deprecated APIs. We incor-
porate the ﬁndings of our empirical study in creating this
update tool, mainly to direct the types of transformations
that the tool should support.

We create MLCatchUp, a tool that provide automated
update for Python deprecated API usage. MLCatchUp infers
the required transformations for the update by comparing
the difference between the deprecated API signature and
the updated API signature. Using these API signatures and
a code containing the usage of deprecated API as an input,
MLCatchUp will automatically provide a new version of
the code where all usages of the speciﬁed deprecated APIs
are replaced with the corresponding updated API. During
the transformation process, MLCatchUp utilizes a domain
speciﬁc language to make its transformation more readable
for the users. In the following subsections, we discuss in
detail on the architecture and features of MLCatchUp.

3.1 MLCatchUp Architecture

The architecture and pipeline of MLCatchUp are given in
Figure 9. There are two main inputs to MLCatchUp, namely
the input Python ﬁle (O-1), and the input API signatures
(O-2). The input Python ﬁle is the ﬁle that is going to be
updated, while the input API signatures are the deprecated
API signature and the updated API signature. The input
Python ﬁle is transformed into its AST using the abstract
syntax tree module provided by Python8 (S-1), creating the
input ﬁle AST (O-3). From this AST, MLCatchUp detects
and locates the usage of the deprecated API based on the
deprecated API signature. Our approach in this deprecated
API detection is adapted from the work of Wang et al. [2],
which is done through the normalization of all API usages
into their fully qualiﬁed name, and comparisons of these
names to the deprecated API signature.

Input API signatures are used in the transformation
inference process (S-2) where the necessary transformations
for the API migration are automatically inferred. The neces-
sary transformations are in the form of DSL commands (O-
4), containing a series of atomic operations required for the
update (e.g. rename method, rename parameter, etc.) which
are to be performed sequentially. The DSL is then parsed
by the DSL parser (S-3) into a list of operations that can be
executed by MLCatchUp. These operations are applied to
the input ﬁle AST (S-4), producing the updated AST (O-5).
The updated AST is then compared with the input ﬁle
AST by using the code diff checker (S-5), which lists all
the code differences between the two ASTs and outputs the
update diff (O-6). Finally, based on the code differences in
the update diff (O-6), the update is applied to the input
Python ﬁle (S-6) by making only the necessary changes to

8. https://docs.python.org/3/library/ast.html

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

7

Fig. 9: MLCatchUp Architecture

the API usages without any modiﬁcation to the original
code comments and spacing. This results in the updated
input ﬁle (O-7).

In the following sections, we describe in detail the main
components of the MLCatchUp automated update process.
Section 3.2 explains the transformation operations provided
by MLCatchUp and their DSL equivalents. This section
also describes the grammar of the DSL that is used by
MLCatchUp. Section 3.3 discusses how our approach creates
the automatic transformation based on the deprecated and
updated API signatures.

3.2 Transformation Operations and DSL

In providing the required update to mitigate the usage of
a deprecated API, MLCatchUp makes use of several basic
transformation operations. We choose the required basic
transformation operations based on the result of our empir-
ical study, where we found that the varieties of deprecated
API migration can be summarized into 8 different update
operations, as described in Section 2.3.

We leverage these ﬁndings as the building block of the
automatic update functionality provided by MLCatchUp.
Each operation within MLCatchUp is paired with a cor-
responding construct in the domain speciﬁc language to
describe the transformation. The required transformation
operations for each API migration are inferred automati-
cally, as we will discuss in Section 3.3. This transformation
inference process will produce a DSL script that speciﬁes all
the required transformations between a pair of deprecated
and updated API. The grammar of the DSL in EBNF (Ex-
tended Backus–Naur Form) is shown in Figure 10.

Each transformation listed in the DSL grammar corre-
sponds to a basic transformation operation provided by ML-
CatchUp. The mapping between each basic transformation
operation and its DSL grammar is shown in Table 6.

3.3 Transformation Inference

MLCatchUp automatically infers the required change to
update the usage of the deprecated API using the dep-
recated and updated API signatures as its inputs. Based

TABLE 6: Mapping between each transformation operation
and its DSL grammar

Transformation
Operation
Rename Method
Rename Parameter
Remove Parameter
Convert Positional to
Keyword Parameter
Add Parameter
Change Parameter
Type
Add Constraint to
Parameter Value
Remove API

DSL Grammar

<rename method>
<rename parameter>
<remove parameter>

<positional

to keyword parameter>

<add parameter>

<type constraint>

<value constraint>

<remove api>

on these signatures, MLCatchUp produces DSL commands
containing the steps required to update code containing
deprecated API usages.

We deﬁne an API signature as the fully qualiﬁed name
of the API and the list of parameters available for the API,
where each parameter consists of its name, type, and an
optional default value. A fully qualiﬁed API name consists
of the API module names and the API function name. This
information is sufﬁcient as Python does not provide method
overloading. The API parameter deﬁnition is declared in the
form of a comma separated list of positional and keyword
parameters, where each parameter has a speciﬁc type and
may include a default value. To separate positional and
keyword parameters, the symbol * is used. The syntax that
is accepted by MLCatchUp for API signatures is shown in
Figure 11.

The difference between the deprecated API signature
and the updated API signature is used to automatically infer
the required transformation for the API usage update. The
pseudocode of this transformation inference is shown in Al-
gorithm 1. The transformation inference takes as inputs the
deprecated API signature and the updated API signature.
Using these inputs, several steps are done to produce the
DSL commands to update the deprecated API usage. First,
if the updated API signature is an empty string, we add
a remove_api operation (lines 2-3). If the updated API

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

8

(cid:104)transformations(cid:105)

(cid:104)transformation(cid:105)

(cid:104)rename method(cid:105)

(cid:104)rename parameter(cid:105)

::= (cid:104)transformation op(cid:105) [ if (cid:104)transformation constraint(cid:105) ]; +
::= (cid:104)rename method(cid:105)
|
|
|
|

(cid:104)rename parameter(cid:105)
(cid:104)remove parameter(cid:105)
(cid:104)positional to keyword parameter(cid:105)
(cid:104)add parameter(cid:105)

::= rename method (cid:104)old method(cid:105) to (cid:104)new method(cid:105)

::= rename parameter

(cid:104)old parameter name(cid:105)

to

(cid:104)new parameter name(cid:105)

for

(cid:104)old method(cid:105)

(cid:104)remove parameter(cid:105)

::= remove parameter (cid:104)old parameter name(cid:105) for (cid:104)old method(cid:105)

(cid:104)positional to keyword parameter(cid:105)

(cid:104)add parameter(cid:105)

(cid:104)remove api(cid:105)

(cid:104)transformation constraint(cid:105)

::= positional

position
(cid:104)new parameter name(cid:105) for (cid:104)old method(cid:105)

to keyword

(cid:104)parameter position(cid:105)

keyword

::= add parameter (cid:104)new parameter name(cid:105) with value (cid:104)expression(cid:105) for (cid:104)old method(cid:105)
::= remove api (cid:104)old method(cid:105)
::= (cid:104)transformation constraint(cid:105) and (cid:104)transformation constraint(cid:105)
(cid:104)transformation constraint(cid:105) or (cid:104)transformation constraint(cid:105)
|
[not] (cid:104)old parameter(cid:105) (cid:104)constraint deﬁnition(cid:105)
|

(cid:104)constraint deﬁnition(cid:105)

(cid:104)type constraint(cid:105)

(cid:104)value constraint(cid:105)

(cid:104)old method(cid:105)

(cid:104)new method(cid:105)

(cid:104)old parameter name(cid:105)

(cid:104)new parameter name(cid:105)

(cid:104)parameter position(cid:105)

(cid:104)type(cid:105)

(cid:104)expression(cid:105)

::= (cid:104)type constraint(cid:105)
(cid:104)value constraint(cid:105)
|

::= has type (cid:104)type(cid:105)
::= has value (cid:104)expression(cid:105)
∈ a set of deprecated API signature
∈ a set of updated API signature
∈ a set of parameter name
∈ a set of parameter name
∈ a set of positive number
∈ a tfpdef9
∈ a expr stmt9

Fig. 10: Grammar of the MLCatchUp domain speciﬁc language

After removing identical parameters, we compare the
remaining API parameters from the two API signatures.
Two possible actions are taken during this comparison.
First, if two API parameters have the same type but dif-
ferent keyword names, we add a rename_parameter
operation into the DSL (lines 11-14). Second, if two API
parameters have the same type, but there is a positional
parameter in the deprecated API signature and a key-
word parameter in the updated API signature, we add
a positional_to_keyword_parameter operation (lines
15-18). Then, we check whether there are any remaining API
parameters in the deprecated and the updated API signa-
tures. Each of the remaining API parameters in the dep-
recated API signature is added as a remove_parameter
operation into the DSL commands (lines 19-21). Finally, for
each remaining API parameter in the updated API signa-
ture, we add an add_parameter operation.

As an illustration, consider the TensorFlow.compat.
v1.to_float() deprecated API. This API usage
the TensorFlow.
needs
cast(dtype=TensorFlow.float32) API. Using these
API signatures, MLCatchUp performs the transformation

be updated to use

to

Fig. 11: Syntax of MLCatchUp API signature

signature is not empty, we compare the fully qualiﬁed name
(line 5) of the deprecated and updated API signature, and
add a rename_method operation if the names differ (line
6). Then, we eliminate identical API parameters from both
API signatures (line 8), as the same parameters between
the two APIs will not affect the API update. Two API
parameters are considered identical if they have the same
keyword or position, and the same type.

9. https://docs.python.org/3.6/reference/grammar.html

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

Algorithm 1: MLCatchUp automatic inference

Input

: D ∈ deprecated API signature
U ∈ updated API signature;

Output: Update transformation DSL commands

9

Cmds
1 Cmds ← null
2 if U ≡ null then
3
4 else
5

Cmds.add(remove AP I(Uname))

if Dname (cid:54)= Uname then

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

Cmds.add(rename method(Dname, Uname))

end
D, U ← eliminate identical param(D, U )
foreach Parameter P ∈ Dparam do

foreach Parameter Q ∈ Uparam do

while ∃ (Ptype ≡ Qtype ∧ Pname (cid:54)=
Qname) do

Cmds.add(rename parameter(P, Q))
D, U ← remove used param(P, Q)

end
while ∃ (Ptype ≡ Qtype ∧ P is a positional
param ∧ Q is a keyword param) do

Cmds.add(
positional to keyword parameter(
P, Q))
D, U ← remove used param(P, Q)

end
while ∃ (P ∈ Dparam ∧ P /∈ Uparam) do
Cmds.add(remove parameter(P ))

end
while ∃ (Q ∈ Uparam) do

Cmds.add(add parameter(Q))

end

end

end

28
29 end
30 return Cmds

inference using the described steps. First, MLCatchUp
ﬁnds a difference between the fully qualiﬁed name of the
deprecated API and the fully qualiﬁed name of the updated
API, and thus a rename_method operation is added. Then,
MLCatchUp ﬁnds that there are no identical parameters
between the two API signatures, leaving only a single API
parameter in the updated API signature. This parameter
is added as an add_parameter operation. The value of
the argument added in the add_parameter operation is
obtained from the default parameter value listed in the
API signature. The produced DSL commands are shown in
Figure 12.
These

ap-
plied
deprecated
containing
TensorFlow.compat.v1.to_float() API usage. First,
the ﬁle needs to be parsed into its AST. Then, each DSL
command is parsed and translated into the corresponding
transformation that is applied to the AST. After all the
transformations are applied,
the AST is changed back
into the code form and the code differences between the
updated code and the deprecated code are presented to the

commands

then

DSL

ﬁles

can

the

be

to

12: DSL

Fig.
commands
tensorFlow.compat.v1.to_float() usages
tensorflow.cast(dtype=tensorflow.float32)

produced

convert
to use

to

1
2
3
4
5
6
7

import TensorFlow.compat.v1 as tf
+ from TensorFlow import cast
def parse_example(d):

-
+

img = tf.decode_raw(d[’image_raw’], tf.uint8)
d[’image’] = tf.to_float(img)
d[’image’] = cast(img, dtype=TensorFlow.float32)
return d

Fig. 13: Migration result for TensorFlow.compat.v1.
to_float() deprecated API usage from TensorFlow ver-
sion 2.0.0

users. Based on these code differences, MLCatchUp applies
the transformation to the original code, making only the
necessary changes towards the deprecated API usages,
retaining the comments and spacing of the original code.
An example result of the update is shown in the code diff in
Figure 13.

While MLCatchUp can infer the required transformation
operations, MLCatchUp is unable to infer the required in-
formation regarding any added constraints for the trans-
formation itself. Indeed the API signatures do not provide
such information. To mitigate this problem, we allow ML-
CatchUp to be run with an optional argument in which
the user can specify the transformation constraint as an
input. This input constraint must be written using the
MLCatchUp domain speciﬁc language. An example of the
inferred DSL script and the provided input constraint for
the sklearn.model_selection.KFold API update is
shown in Figure 14.

In

Figure

see
is

from the API
that
14, we
infer
that
to
signatures, MLCatchUp
able
sklearn.model_selection.KFold
deprecated
API usage needs to be updated with the addition of
shuffle:bool=True parameter. However, MLCatchUp is
unable to obtain the transformation constraint information
from the API signatures, providing an incomplete inferred
series of transformation commands. In actuality, the add
parameter update operation should only be done if the
value of random_state parameter is not None. This
constraint is expressed through a user input constraint.

4 MLCATCHUP EVALUATION

To evaluate MLCatchUp, we conducted an experiment to
analyze the update results. In this section, we explain the
setting, data, and results of this evaluation. We also conduct
a qualitative study on the kinds of deprecated API usages

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

10

TABLE 7: MLCatchUp experiments results

Evaluation
Without added constraints
With added constraints

TP
443
481

FP
71
33

Precision
86.19%
93.58%

usages, 89 ﬁles contain Tensorflow API usages, and 124
ﬁles contain PyTorch API usages.

4.3 Experiment Setting

We conducted an experiment to evaluate the ability of
MLCatchUp to update the usages of deprecated APIs. We
aim to measure how precise are the updates produced by
MLCatchUp through this experiment. With this goal in
mind, we calculated the precision of the update result. We
deﬁne precision as the percentage of the correct updates
performed during the test. The formulas for precision is
shown below:

P recision =

T P
T P + F P

Instances of deprecated API usages are automatically
detected and updated using MLCatchUp based on the input
API signatures and the inferred transformations. For each
updated API usage, there are three possible labels:
1) True Positive (TP): deprecated API usage is updated

correctly

2) False Positive (FP): deprecated API usage is updated

incorrectly, i.e. the updated API usage is incorrect

To label the update result, we employed the help of three
Python programmers with at least four years of experience.
These programmers are non-authors, and were given in-
struction and training before they conducted the labelling
process. Each instance of the deprecated API usages is
labelled by two different programmers. If any labelling
disagreement arises between the two programmers, we con-
ducted a discussion until a consensus is achieved. Through-
out the labelling process, only two labelling disagreements
occured, which results in 99.61% inter-rater reliability.

4.4 Experiment Result Without User-Provided Con-
straints

We evaluated MLCatchUp following the scenario described
in Section 4.3. The transformation operations for each depre-
cated API usages are automatically inferred by MLCatchUp
from their deprecated and updated API signatures. These
transformation operations are then applied to the ﬁle con-
taining the deprecated API usage, producing the updated
ﬁle. The result of this experiment is shown in the second
row of Table 7.

From the experiment, MLCatchUp achieved a precision
of 86.19%. There are 71 updated code that are labelled
as false positives, indicating instances of deprecated API
usages that were not updated correctly by MLCatchUp. One
of the main reasons for the presence of false positive results
is due to the transformation constraint not being present
for context-dependent updates because such a constraint
cannot be automatically inferred by MLCatchUp.

Fig. 14: DSL commands with input constraint for migrat-
ing sklearn.model_selection.KFold deprecated API
usage from scikit-learn version 0.23.0

that cannot be updated successfully by MLCatchUp and
discuss the possible approaches to mitigate them for future
work.

4.1 Dataset Collection

Based on our empirical study, we use deprecated APIs from
Scikit-learn, TensorFlow, and Keras libraries for
our evaluation. We consider the 112 identiﬁed deprecated
APIs from the three libraries. In order to provide a realistic
evaluation, we use real API usages for our evaluation. With
this in mind, we directed our API usage search towards pub-
lic GitHub repositories, which contain code from developers
across the globe.

At ﬁrst, we tried to use the GitHub code search API10 by
using the deprecated API signature as the text-based search
query. However, a lot of irrelevant results were returned,
as the search cannot differentiate between API usages and
other code elements. Accordingly, we created a prototype
GitHub search engine that is able to accurately ﬁnd code
containing usage of Python APIs.

We adapted the work of Wang et al. [2] to build this
search tool. Our search tool makes use of the GitHub search
API, allowing up to 1,000 repositories to be retrieved for
each search query. For the deprecated API usage detection,
we utilized API normalization which rewrites all API usages
in the code with their fully qualiﬁed name. Each fully qual-
iﬁed name is matched with the deprecated API signature to
detect usages of deprecated APIs in the code. We also added
multiprocessing capability to our search tool, reducing the
execution time. Using the deprecated API signatures as the
input, we collected our evaluation data.

4.2 Evaluation Dataset

Using our search tool, we collected code containing dep-
recated API usages from GitHub public repositories for
the 112 case study APIs. Out of the 112 APIs, we found
public code usages for only 66 APIs. For each of these 66
APIs, we collected at most ﬁve ﬁles containing deprecated
API usage for our evaluation dataset. For deprecated APIs
used by more than ﬁve ﬁles, we randomly selected the ﬁve
ﬁles. Meanwhile, for deprecated APIs used by only ﬁve
or fewer ﬁles, we used all of the ﬁles for our evaluation.
In total, we collected 258 ﬁles containing 514 API usages
from 66 different APIs. 45 ﬁles contain Scikit-learn API

10. https://developer.github.com/v3/search/

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

11

1
2

- torch.addcdiv(input, tensor, other)
+ input + torch.floor_divide(tensor, other)

Fig. 15: Migration for torch.addcdiv deprecated API
usage from Torch version 1.6.0

1
2
3
4
5
6
7

sparse_indices, tf.cast(tf.shape(shape),
tf.int64), indices_gathered)

- indices_scattered = tf.compat.v1.sparse_to_dense(
-
-
+ sparse_tensor = tf.sparse.SparseTensor(sparse_indices,
+
+
+ indices_scattered = tf.sparse.to_dense(sparse_tensor)

indices_gathered, tf.cast(tf.shape(shape),
tf.int64))

4.5 Adding Constraints to MLCatchUp’s Inferred DSL

We further improve the transformation precision of ML-
CatchUp by adding user-speciﬁed transformation con-
straints for context-dependent deprecated API usage up-
dates. Within the evaluation dataset, we found that there
are 21 ﬁles containing 49 context-dependent deprecated API
usages. Failures in updating these API usages is one of the
main contributors for the false positive updates produced
by MLCatchUp.

While MLCatchUp is unable to automatically infer the
required transformation constraint from the API signatures,
MLCatchUp does provide the capability to include such
constraints in its transformation. In particular, MLCatchUp
accepts transformation constraint in its DSL, as shown
in <transformation_constraint> non-terminal in Fig-
ure 10.

Using this additional input, we conducted a follow-up
experiment on MLCatchUp using the same test dataset. We
manually deﬁne the required transformation constraints for
each context-dependent deprecated API usage migration
and add them as an input to MLCatchUp. In total, we
manually write 7 transformation constraints. The result of
this follow-up experiment is shown in the third row of
Table 7.

Using the additional

input constraints, MLCatchUp
achieves 93.58% precision, which is a 7.39% improvement
compared to the previous experiment. From the 49 context-
dependent deprecated API usages, 38 are updated suc-
cessfully. While the addition of the user input constraints
improves the overall precision of MLCatchUp update result,
there remain some false positives. Out of the 514 deprecated
API usages, 33 are updated incorrectly. To understand the
reasons for these failures, we conducted a qualitative study,
which we will discuss in the next sub-section.

4.6 MLCatchUp’s Failed Migrations

Based on our evaluation of MLCatchUp, we see that there
are 33 instances of deprecated API usage that are updated
incorrectly. We analyze these cases, aiming to ﬁnd the rea-
sons of these failed migrations. The reasons are:
1) API usage migration involving arithmetic operations. Depre-
cated API usage migration may involve arithmetic oper-
ations between the updated API usage and other values.
This arithmetic operation is not handled by MLCatchUp.
This case is found in the torch.addcdiv deprecated
API migration, shown in Figure 15. In this example, the
deprecated API usage (line 1) needs to be replaced into
an arithmetic operation between the input parameter of
the deprecated API usage and a torch.floor_divide
API invocation (line 2). In the future, we can add support
for arithmetic operation in MLCatchUp to handle this
type of API migration.

Fig. 16: Migration for tensorflow.compat.v1.sparse_
to_dense deprecated API usage from Tensorflow ver-
sion 2.0.0

1
2
3
4

+

import torch
def MAPE_torch(pred, mask):

mask = torch.gt(true, mask - 0.01)
pred = torch.masked_select(pred, mask)

Fig. 17: Migration for torch.masked_select deprecated
API usage from PyTorch version 1.2.0

2) API usage migration involving 1:N API mapping. Currently,
MLCatchUp only handles API usage migrations with
1:1 and 1:0 API mappings, which are the most common
API mapping migration categories of Python deprecated
API usage. An example of the 1:N case is found in
tensorflow.compat.v1.sparse_to_dense
the
deprecated API migration, where the update requires
an invocation of tensorflow.sparse.
adding
SparseTensor and changing the API name of
tensorflow.compat.v1.sparse_to_dense
to
tensorflow.sparse_to_dense. This API migration
is illustrated in Figure 16.
In the future, it is possible to extend the operations
provided by MLCatchUp to include operations adding
new API invocations. We would also need to enable the
automatic transformation inference to infer the required
transformations for a 1:N API migration mapping.

3) API usage migration involving value and/or type modiﬁca-
tions of the parameter values. MLCatchUp addresses the
problem of parameter value or type change through
the usage of transformation constraints. However, this
approach can be insufﬁcient as some deprecated APIs
require the parameter values to be updated, which typ-
ically include constructing a new value through mathe-
matical operations or other API invocations. An example
of this case is found in the torch.masked_select
deprecated API usage, which is shown in Figure 17. In
the deprecated version, torch.masked_select allows
for IntTensor as its second positional parameter. In
the updated version, the second positional parameter
must be of type BoolTensor, hence the conversion is
done using the torch.gt API in line 3. In the future,
it is possible to add more operations into MLCatchUp
that would enable modiﬁcations of the values of API
parameters.

4) API usage migration involving parameter name and po-
sition changes of multiple API parameters with the same
type. In this deprecated API migration, the deprecated
API parameter names are changed into the new names
described in the updated API signature. However, to
infer the new names for the deprecated API parame-

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

12

documentation and changelogs. From this list, we deﬁned
the dimensions and categories of Python deprecated API
usage migrations. It is possible that our list of APIs is
incomplete as there might be API deprecations that were
not documented properly. However, as we collected our list
of deprecated APIs from the ofﬁcial documentations of each
library, we believe that our list is complete enough without
any major defect.

Threats to internal validity also apply to the accuracy
of the labelling done in the MLCatchUp evaluation. As the
update result labelling is done by humans, there exists a
possibility of human error. To mitigate this problem, each
instance of the deprecated API usages is labelled by two
different programmers. If any disagreement occurs, a dis-
cussion is conducted to achieve a consensus.

Threats to construct validity relate to the suitability of the
evaluation metric that we chose for MLCatchUp evaluation.
We used precision as the metric to evaluate the update re-
sults of MLCatchUp by measuring the percentage of correct
update produced by MLCatchUp in our test dataset of 258
ﬁles. This metric has also been used to evaluate existing
tools on automatic update of deprecated APIs [4], [5], [6],
[7]. Thus, we believe the threats are minimal.

6 RELATED WORK

API deprecation. API deprecation is a topic that has been
studied extensively [12], [13], [14], [15], [16], [17], [18], [19],
[20]. Zhou and Walker [12] created a lightweight framework
to detect deprecated API usages in source code examples on
the web for Android API usage. Brito et al. [13] proposed
a recommendation tool to infer replacement messages by
mining solutions adopted by developers. This recommen-
dation tool aims to help developers to ﬁnd deprecated API
alternatives. Sawant et al. [14], [15] explored the reaction
of API users towards API deprecations. They found that
most developers do not update their API usages due to
the cost of update not being worth it. When they do react,
they prefer to ﬁx the code by deleting the deprecated API
instead of replacing it with the updated API. A similar study
by Hora et al. [16] explored the impact of API evolution
and found that API changes can affect the whole ecosytem.
They also found that client developers need some time to
discover and apply the new APIs, while the majority does
not react at all. Xavier et al. [17] found that the frequency
of API deprecations increase over time and systems that are
more popular have higher frequency of deprecations. Li et
al. [18] characterize deprecated Android APIs and found
that usage of deprecated APIs are mostly found in popular
libraries. Our study is focused on the API deprecation of
Python machine learning libraries. We manually collected
a list of 112 deprecated APIs from three popular Python
machine learning libraries, Scikit-learn, PyTorch, and
Tensorflow. We investigated the common patterns in the
API migration of these deprecated APIs.

API migration. Multiple works and studies on API mi-
gration have been done [19], [20], [21], [22], [23], [24]. Bogart
et al. [19] found that different programming ecosystems
have different expectations towards API breaking changes.
Cossette and Walker [20] conducted a retroactive study
on API incompatibilities between several versions of Java

Fig. 18: Incorrect DSL commands produced by MLCatchUp
for torch.stft deprecated API usage migration from
PyTorch version 0.4.1

ters, MLCatchUp makes use of the parameter position
and type. If there are multiple parameter name and
position changes, MLCatchUp may infer an incorrect
transformation for the API migration. An example of
this case is found in the migration of the torch.stft
deprecated API usage, which is shown in Figure 18. In
this case, there are three API parameters with type int
that need to be renamed. MLCatchUp produces incorrect
rename_parameter operations for two API parame-
ters, which are frame_length parameter that should
be renamed into win_length and fft_size parameter
that should be renamed into n_fft. To mitigate this
problem, we can improve the transformation inference
done by MLCatchUp to not only infer the API parameter
transformations based on their type and position, but
also through parameter name similarity.

5 THREATS TO VALIDITY
Threats to external validity relate to the generalizabil-
ity of our ﬁndings. Our research investigated 112 APIs
from three Python machine learning libraries, namely
Scikit-Learn, TensorFlow, and PyTorch. These were
the most popular machine learning libraries and contain
APIs that have been deprecated in the last 2 years. We made
this pragmatic choice to address the recent pain points that
many developers face. We designed MLCatchUp based on
the results of our empirical study, which may not hold true
for other libraries and APIs. There were also cases where
MLCatchUp is unable to produce correct update, which we
discussed in Section 4.6. In the future, we plan to extend
our study to cover more recent releases of popular ML
libraries – the landscape of ML libraries may continue to
change and other ML libraries may become more popular
than the three we investigated. We also plan to address the
limitations of MLCatchUp, mainly its inability to migrate
1:N API mappings.

Threats to internal validity relate to the accuracy and error
that might have happen during our analysis. We manually
collected the list of deprecated APIs based on the library

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

libraries. From their manual analysis, they found that the
majority of API changes cannot be automatically trans-
formed without severe restrictions and that the majority of
changes to an API were not documented properly. The tool
apiwave [21] keeps track of API popularity and migration of
major frameworks and libraries from top 650 GitHub Java
projects. Li et al. [22] conducted an empirical study on web
API evolution by analyzing the evolution of ﬁve popular
web APIs. They found that web APIs evolve in limited pat-
terns and that most of the API changes in web APIs involve
refactoring. Dig and Johnson [23] study the requirements for
API migration tools by analyzing the API changes of three
frameworks and one library in Java. They found that from
their case studies, more than 80% of the API changes are
refactoring, indicating an important role of refactoring in
API migration. Xia et al. [24] performs large-scale study on
the current practice of handling evolution-induced compati-
bility issues in Android apps. They proposed RAPID, an au-
tomated tool to determine whether a compatibility issue has
been addressed or not through utilization of static analysis
and machine learning techniques. Our study is focused on
the API migration of Python machine learning deprecated
API usages. We deﬁned the dimensions of API migration
for Python machine learning deprecated API usages using
the case study of 112 deprecated APIs.

Program transformation. Works on program transfor-
mation has also been done [4], [5], [6], [7], [25], [26], [27],
[28], [29], [30], [31], [32]. LASE [25] is an Eclipse plug-in
that provides an example-based program transformation.
LASE is able to create a context-aware edit script from code
examples, and uses the script to transform the code. Sydit
is a program transformation tool that helps developers in
systematic editing task involving similar changes in multi-
ple places. Given a source and target method, Sydit learns
and applies systematic edits which results are displayed
to the programmer to review and approve. REFAZER [26]
was proposed by Rolim et al. to automatically learn pro-
gram transformations through observation of code edits
performed by developers. REFAZER synthesize program
transformations for Python code by leveraging inductive
programming using input-output examples. Coccinelle [27],
[28], a program matching and transformation tool for C
language, allows program developers to write code manip-
ulation rules in terms of code structure. Transformation in
Coccinelle is expressed in the form of semantic patch lan-
guage (SmPL), which has a syntax similar to a code diff. A
port of Coccinelle for Java language, called Coccinelle4J was
also proposed by Kang et al. [29]. SPINFER [32] is capable
of automatically inferring Coccinelle semantic patches from
existing code change examples for the Linux kernel. SPIN-
FER considers similar code fragments and control ﬂows in
the changes to identify the change patterns.

A4 [4] is an approach to assist developers with Android
API migration by leveraging source code examples to learn
the API migration patterns. A4 can either automatically
migrate API calls with little to no extra modiﬁcations or
provide a guidance to assist with the migration. More
recently, Fazzini et al. [5] created AppEvolve which trans-
forms the usage of deprecated Android APIs into backward-
compatible updated code by learning from code examples.
Haryono et al. [6] presented a new tool for automatic

13

Android API update called CocciEvolve which is built
on Coccinelle4J. CocciEvolve shows an improvement from
AppEvolve in the form of readable transformations and its
capability to produce working updates with only a single
update example. Thung et al. [7] proposed NEAT, a tool
to generate transformation rules that can assist developers
in deprecated API replacement without code example for
Android APIs. NEAT uses the signature graph from the
source code of the API library to convert between one type
and another. In our work, we proposed MLCatchUp, which
automates the update of Python machine learning depre-
cated API usages. MLCatchUp does not require any code
example to provide its transformation, but rather infers the
required transformations through the difference between
the deprecated and updated API signatures and presents
these transformations in the form of a DSL. MLCatchUp is
built for the Python programming language, bringing a set
of difﬁculties previously unseen in other programming lan-
guages, such as positional and keyword parameters, default
parameter values, usage of whitespaces as separator, and
dynamic typing which allows a variable to have different
types during the program execution.

7 CONCLUSION AND FUTURE WORK
We conducted an empirical study to learn the dimensions
of the API migrations required by Python deprecated APIs.
We manually collected a list of 112 APIs and their updated
API signatures from three popular Python machine learning
libraries: Scikit-Learn, TensorFlow, and PyTorch.
Using manual thematic analysis, we found three dimensions
in the deprecated API migrations: update operation, API
mapping, and context dependency.

Based on ﬁndings in our empirical study, we created
MLCatchUp, an automated tool to update the usage of
Python deprecated APIs. MLCatchUp automatically infers
the transformation operations to migrate and update the
usage of a deprecated API. Given the API signatures and
the ﬁle containing deprecated API usages, MLCatchUp au-
tomatically lists the transformations in the form of a DSL
and updates the deprecated API usage within the ﬁle. We
evaluated MLCatchUp using a dataset of 258 ﬁles contain-
ing 514 API usages from 66 different APIs. MLCatchUp
achieved 86.19% precision. We further improve MLCatchUp
by adding transformation constraints input, allowing it
to process the update for context-dependent deprecated
API usage update. With this improvement, MLCatchUp
achieved 93.58% precision, a 7.39% precision improvement
from experiment without user-added constraint.

For future work, we plan to extend our study to other
popular Python libraries, including non-machine learning
libraries. By increasing the scope of the case study, we may
encounter more variety of deprecated APIs and their migra-
tions. We also plan to address the current shortcomings of
MLCatchUp, namely its inability to create 1:N API mapping
migration updates, etc.

REFERENCES

[1]

J. Han, S. Deng, D. Lo, C. Zhi, J. Yin, and X. Xia, “An empirical
study of the dependency networks of deep learning libraries,” in
ICSME, 2020.

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

14

[2]

J. Wang, L. Li, K. Liu, and H. Cai, “Exploring how deprecated
Python library APIs are (not) handled,” in FSE, 2020.

[3] R. Kula, D. German, A. Ouni, T. Ishio, and K. Inoue, “Do de-
velopers update their library dependencies?” Empirical Software
Engineering, vol. 23, no. 1, p. 384–417, Feb. 2018.

[4] M. Lamothe, W. Shang, and T.-H. Chen, “A4: Automatically as-
sisting Android API migrations using code examples,” ArXiv, vol.
abs/1812.04894, 2018.

[5] M. Fazzini, Q. Xin, and A. Orso, “Automated API-usage update

[6]

for Android apps,” in ISSTA. ACM, 2019, pp. 204–215.
S. A. Haryono, F. Thung, H. J. Kang, L. Serrano, G. Muller,
J. Lawall, D. Lo, and L. Jiang, “Automatic Android deprecated-
API usage update by learning from single updated example,” in
IEEE International Conference on Program Comprehension, 2020.
[7] F. Thung, H. Kang, L. Jiang, and D. Lo, “Towards generating trans-
formation rules without examples for Android API replacement,”
09 2019, pp. 213–217.

[8] W. Fu and T. Menzies, “Easy over hard: a case study on deep

learning,” 08 2017, pp. 49–60.

[9] Z. Liu, X. Xia, A. E. Hassan, D. Lo, Z. Xing, and X. Wang,
“Neural-machine-translation-based commit message generation:
How far are we?” in 2018 33rd IEEE/ACM International Conference
on Automated Software Engineering (ASE), 2018, pp. 373–384.
[10] S. Majumder, N. Balaji, K. Brey, W. Fu, and T. Menzies, “500+ times
faster than deep learning: a case study exploring faster methods
for text mining stackoverﬂow,” 05 2018, pp. 554–563.

[11] V. Braun and V. Clarke, “Using thematic analysis in psychology,”
Qualitative Research in Psychology, vol. 3, pp. 77–101, 01 2006.
[12] J. Zhou and R. Walker, “API deprecation: a retrospective analysis
and detection method for code examples on the web,” 11 2016, pp.
266–277.

[13] G. Brito, A. Hora, M. Valente, and R. Robbes, “On the use of
replacement messages in API deprecation: An empirical study,”
Journal of Systems and Software, vol. 137, 12 2017.

[14] A. A. Sawant, G. Huang, G. Vilen, S. Stojkovski, and A. Bacchelli,
“Why are features deprecated? an investigation into the motiva-
tion behind deprecation,” in 2018 IEEE International Conference on
Software Maintenance and Evolution (ICSME), 2018, pp. 13–24.
[15] A. Sawant, R. Robbes, and A. Bacchelli, “On the reaction to
deprecation of 25,357 clients of 4+1 popular Java APIs,” 10 2016,
pp. 400–410.

[16] A. Hora, R. Robbes, M. Valente, N. Anquetil, A. Etien, and
S. Ducasse, “How do developers react to API evolution? a large-
scale empirical study,” Software Quality Journal, pp. 1–31, 10 2016.
[17] L. Xavier, A. Brito, A. Hora, and M. Valente, “Historical and
impact analysis of API breaking changes: A large-scale study,”
02 2017, pp. 138–147.

[18] L. Li, J. Gao, T. F. Bissyand´e, L. Ma, X. Xia, and J. Klein,
“Characterising deprecated Android APIs,” in Proceedings of the
15th International Conference on Mining Software Repositories (MSR).
ACM, 2018, pp. 254–264.

[19] C. Bogart, C. K¨astner, J. Herbsleb, and F. Thung, “How to break
an API: Cost negotiation and community values in three software

ecosystems,” in Proceedings of the 2016 24th ACM SIGSOFT Inter-
national Symposium on Foundations of Software Engineering, ser. FSE
2016. New York, NY, USA: Association for Computing Machinery,
2016, p. 109–120.

[20] B. Cossette and R. J. Walker, “Seeking the ground truth: a retroac-
tive study on the evolution and migration of software libraries,”
in SIGSOFT FSE, 2012.

[21] A. Hora and M. T. Valente, “Apiwave: Keeping track of API
popularity and migration,” in 2015 IEEE International Conference
on Software Maintenance and Evolution (ICSME), 2015, pp. 321–323.
[22] J. Li, Y. Xiong, X. Liu, and L. Zhang, “How does web service API
evolution affect clients?” in 2013 IEEE 20th International Conference
on Web Services, 2013, pp. 300–307.

[23] D. Dig and R. Johnson, “The role of refactorings in API evolu-
tion,” in 21st IEEE International Conference on Software Maintenance
(ICSM’05), 2005, pp. 389–398.

[24] H. Xia, Y. Zhang, Y. Zhou, X. Chen, Y. Wang, X. Zhang, S. Cui,
G. Hong, X. Zhang, M. Yang, and Z. Yang, “How Android devel-
opers handle evolution-induced API compatibility issues: A large-
scale study,” in Proceedings of the ACM/IEEE 42nd International
Conference on Software Engineering, ser. ICSE ’20. New York, NY,
USA: Association for Computing Machinery, 2020, p. 886–898.
[25] J. Jacobellis, N. Meng, and M. Kim, “LASE: An example-based
program transformation tool for locating and applying systematic
edits,” in 2013 35th International Conference on Software Engineering
(ICSE), 2013, pp. 1319–1322.

[26] R. Rolim, G. Soares, L. D’Antoni, O. Polozov, S. Gulwani, R. Gheyi,
R. Suzuki, and B. Hartmann, “Learning syntactic program trans-
formations from examples,” in ICSE.
IEEE Press, 2017, pp. 404–
415.

[27] J. Lawall and G. Muller, “Coccinelle: 10 years of automated evolu-
tion in the Linux kernel,” in USENIX Annual Technical Conference,
2018, pp. 601–614.

[28] J. Brunel, D. Doligez, R. R. Hansen, J. L. Lawall, and G. Muller,
“A foundation for ﬂow-based program matching: using temporal
logic and model checking,” in Principles of Programming Languages
(POPL). ACM, 2009, pp. 114–126.

[29] H. J. Kang, F. Thung, J. Lawall, G. Muller, L. Jiang, and D. Lo,
“Semantic patches for Java program transformation (experience
report),” in 33rd European Conference on Object-Oriented Program-
ming (ECOOP 2019).
Schloss Dagstuhl-Leibniz-Zentrum fuer
Informatik, 2019.

[30] N. Meng, M. Kim, and K. S. McKinley, “Systematic editing: Gen-
erating program transformations from an example,” in Proceedings
of the 32nd ACM SIGPLAN Conference on Programming Language
Design and Implementation, ser. PLDI ’11. New York, NY, USA:
Association for Computing Machinery, 2011, p. 329–342.

[31] N. Meng, M. Kim, and K. McKinley, “Sydit: Creating and applying
a program transformation from an example,” 09 2011, pp. 440–443.
[32] L. Serrano, V.-A. Nguyen, F. Thung, L. Jiang, D. Lo, J. Lawall, and
G. Muller, “SPINFER: Inferring semantic patches for the Linux
kernel,” in 2020 USENIX Annual Technical Conference (USENIX ATC
20). USENIX Association, Jul. 2020, pp. 235–248.

