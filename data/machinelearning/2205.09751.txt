2
2
0
2

r
p
A
8
2

]
E
N
.
s
c
[

1
v
1
5
7
9
0
.
5
0
2
2
:
v
i
X
r
a

Taylor Genetic Programming for Symbolic Regression

Baihe He
Beijing Key Laboratory of Petroleum
Data Mining, China University of
Petroleum
Beijing, China
hebaihe@hotmail.com

Qiang Lu∗
Beijing Key Laboratory of Petroleum
Data Mining, China University of
Petroleum
Beijing, China
luqiang@cup.edu.cn

Qingyun Yang
Beijing Key Laboratory of Petroleum
Data Mining, China University of
Petroleum
Beijing, China
yangqingyun.cup@hotmail.com

Jake Luo
Department of Health Informatics
and Administration, University of
Wisconsin Milwaukee
Milwaukee, United States
jakeluo@uwm.edu

Zhiguang Wang
Beijing Key Laboratory of Petroleum
Data Mining, China University of
Petroleum
Beijing, China
cwangzg@cup.edu.cn

ABSTRACT
Genetic programming (GP) is a commonly used approach to solve
symbolic regression (SR) problems. Compared with the machine
learning or deep learning methods that depend on the pre-defined
model and the training dataset for solving SR problems, GP is more
focused on finding the solution in a search space. Although GP has
good performance on large-scale benchmarks, it randomly trans-
forms individuals to search results without taking advantage of
the characteristics of the dataset. So, the search process of GP is
usually slow, and the final results could be unstable. To guide GP
by these characteristics, we propose a new method for SR, called
Taylor genetic programming (TaylorGP)1. TaylorGP leverages a
Taylor polynomial to approximate the symbolic equation that fits
the dataset. It also utilizes the Taylor polynomial to extract the
features of the symbolic equation: low order polynomial discrimi-
nation, variable separability, boundary, monotonic, and parity. GP
is enhanced by these Taylor polynomial techniques. Experiments
are conducted on three kinds of benchmarks: classical SR, machine
learning, and physics. The experimental results show that TaylorGP
not only has higher accuracy than the nine baseline methods, but
also is faster in finding stable results.

CCS CONCEPTS
• Computing methodologies → Genetic programming.

KEYWORDS
Taylor polynomials, genetic programming, symbolic regression

1 INTRODUCTION
Symbolic regression (SR) refers to finding a symbolic equation 𝑓𝜃
fitted to a given dataset (𝑋, 𝑌 ) from the mathematical expression
space, i.e., 𝑓𝜃 (𝑋 ) = 𝑌 . The mathematical expression space is huge,
even for rather simple symbolic equations. For example, if a sym-
bolic equation is represented by a binary tree with a maximum
depth of 4, with 20 variables (𝑥1, 𝑥2, ..., 𝑥20) and 18 basic functions
(such as +, − and sqrt), the size of the space is 8.2 × 10162 [25].

∗Corresponding author.
1Code and appendix at https://kgae-cup.github.io/TaylorGP/

Therefore, finding a good symbolic equation for the data from the
huge possible search space is a challenging task.

Research communities of evolutionary computation (EC) and
machine learning (ML) have been trying to solve the SR problems
from their perspectives. The EC methods, especially genetic pro-
gramming (GP) methods [14, 26, 36, 44], are designed to search the
mathematical expression space by evolving the encoding of each
individual in a population. The main advantage of the GP approach
is that the algorithm components are generalizable and adaptive, in-
cluding processes such as selection, crossover, mutation, and fitness
evaluation. Using these components, the GP algorithm randomly
searches for a model 𝑓𝜃 that fits the dataset in the mathematical
expression space, unlike machine learning methods (e.g., neural
networks) that try to find and optimize a set of parameters 𝜃 under
known models 𝑓 . However, the GP search process usually does
not consider the features of the given dataset, which could be an
opportunity for improvement. The ML (including neural networks)
methods [2, 22, 28, 33, 42, 47] find parameters 𝜃 in pre-defined mod-
els 𝑓 so that the models fit the dataset, i.e., 𝑓𝜃 (𝑋 ) = 𝑌 . Machine
learning methods heavily utilize the features of a dataset to guide
the search and optimization for parameters. Therefore, the parame-
ter search process is effective. However, when solving SR problems,
though the machine learning approaches could quickly recover
some correct symbolic equations 𝑓𝜃 s , the results are commonly
biased by the pre-defined regression model 𝑓 s as well as the train-
ing dataset. For example, in a recent evaluation [5] of algorithms
for SR problems using large-scale benchmarks, the results show
that the top three approaches are still GP-based approaches, and
GP approaches still have a substantial advantage over machine
learning-based approaches.

In this paper, we propose a new GP approach called the Taylor
Genetic Programming (TaylorGP). To overcome the common GP’s
drawback – a search process without considering the data features,
we embed Taylor features into GP and leverage the features to
guide GP to search for solutions. TaylorGP, as shown in Figure
1, first obtains a 𝑘-order Taylor polynomial at a point from the
given dataset. According to the Taylor’s theorem, the 𝑘-order Tay-
lor polynomial approximates a smooth function that fits the given
dataset near the point. Moreover, the 𝑘-order Taylor polynomial

 
 
 
 
 
 
Baihe He, Qiang Lu, Qingyun Yang, Jake Luo, and Zhiguang Wang

SVM, and XGBoost, on the three types of benchmarks: classical
SR [34], AIFeynman [47], and Penn machine learning benchmarks
[41].

The remainder of this paper is organized as follows. In Section 2,
we detail related work. Section 3 presents the Taylor features. Then,
we propose the Taylor genetic programming in Section 4. Section 5
and 6 report the experimental results and discussion. Finally, we
conclude the paper in Section 6.

2 RELATED WORK
2.1 Machine learning for symbolic regression
The regression analysis in machine learning, such as linear regres-
sion [50], SVM [10], XGBoost [8], and neural network(NN) [30],
can be viewed as a special case of SR. Different from SR that needs
to find both the model and its parameter values, machine learning
aims to find the values (𝜃 ) of parameters in a pre-defined model
𝑓 , so that 𝑓𝜃 (𝑋 ) = 𝑌 . Many ML methods, such as deep neural
networks, usually applies the gradient descent method to obtain
the target parameter set 𝜃 . Neural networks [2, 23, 28, 42, 43] are
trained to learn from a dataset (𝑋, 𝑌 ) to generate a mathematical
equation 𝑓 (𝑋 ) = 𝑌 according to the features of the training dataset
{(𝑋, 𝑌 ), F }. For example, GrammarVAE (GVAE) [28] trains a vari-
ational autoencoder [23] to directly encode from and decode to
the parse trees using a context-free grammar. Recently, DSR [42]
employed a recurrent neural network trained by a reinforcement
learning algorithm (RL) for SR. The algorithm uses a risk-seeking
policy gradient to emit a distribution over tractable mathemati-
cal expressions. According to the distribution, DSR samples the
mathematical expressions with constant placeholders and obtains
these constants with the nonlinear optimization algorithm – BFGS
[15]. Inspired by the recent successes of pre-trained models on large
datasets, such as BERT [13] and GPT [4], NeSymReS [2] pre-trains a
model called Set Transformer on hundreds of millions of equations
to generate a distribution of mathematical expressions according
to the given dataset (𝑋, 𝑌 ). In addition, NeSymReS samples mathe-
matical expressions with constant placeholders by the beam search
on the distributions and uses BFGS to optimize these constants.

Besides the above neural networks for SR, EQL [32, 43] designs a
shallow fully-connected neural network where standard activation
functions (e.g., 𝑡𝑎𝑛ℎ, ReLU) are replaced with basic functions (e.g.,
"+", "×, "𝑠𝑖𝑛). Once the neural network is trained, it can represent a
symbolic equation fitted to the given dataset. AIFeynman [46, 47]
employs neural networks to map the given dataset into simplifying
properties (e.g., symmetries, separability, and compositionality).
The method then uses a brute-force recursive algorithm guided
by these simplifying properties and a suite of physics-inspired
techniques to search possible symbolic expressions.

The above machine learning methods, especially deep learning
methods, have an excellent ability to discover mathematical equa-
tions on some specific benchmarks. However, experiments on the
large-scale benchmarks [5] indicate that the mathematical equa-
tions found by ML or DL are less accurate than those found by
GP-based methods. For example, four of the top five methods and
six of the top ten methods are GP-based methods, and the other
top methods are ensemble tree-based methods, such as XGBoost
and LightGBM [19]. Surprisingly, the top methods do not include

Figure 1: Taylor genetic programming.

can show the local features of the smooth function (called Taylor
features). Taylor features include three key components: variable
separability, low order polynomial discrimination, and function fea-
ture. Using the variable separability, TaylorGP can decompose the
multivariate Taylor polynomial 𝑇 into multiple univariate Taylor
polynomials 𝑇𝑖𝑠. For example, the two-variable Taylor polynomial
"1.1𝑥 + 0.2𝑥 2 − 3.7 + 1.5𝑦 − 0.25𝑦3 + 0.0125𝑦5" can be decomposed
into two univariate Taylor polynomials "1.1𝑥 + 0.2𝑥 2 − 3.7" and
"1.5𝑦 − 0.25𝑦3 + 0.0125𝑦5" according the variable separability. Tay-
lorGP then applies the polynomial discrimination to determine
whether each 𝑇𝑖 is a polynomial. If 𝑇𝑖 is not a polynomial, TaylorGP
runs the function feature evolution method to find symbolic equa-
tions to fit 𝑇𝑖 . The function feature evolution method creates a set
of rules based on the function features to recombine 𝜆 individuals.
The method also employs the individual initialization method to
randomly generate 𝛽 individuals to prevent premature convergence.
TaylorGP finally assembles mathematical expressions of all 𝑇𝑖 s to
generate the final symbolic equation.

As the Taylor features are directly induced from the coefficients
in the 𝑘-order Taylor polynomial, obtaining the features are simple
and quick. For example, the coefficient of each two-variable prod-
uct term "𝑥𝑚𝑦𝑛" in "1.1𝑥 + 0.2𝑥 2 − 3.7 + 1.5𝑦 − 0.25𝑦3 + 0.0125𝑦5"
is zero, meaning the Taylor polynomial is variable separable. So,
embedding these features into GP does not increase the GP’s com-
puting time complexity. Moreover, the search process guided by
the Taylor features enables TaylorGP to find a correct symbolic
equation quicker than without using the features.

The main contributions of this paper are the following:
(1) We propose a simple yet powerful Taylor genetic program-
ming (TaylorGP) method for symbolic regression. TaylorGP com-
bines the general characteristics of GP’s solution search strate-
gies (e.g., mutation, crossover) with the ML (NN)’s feature-directed
search.

(2) We design a new Taylor feature extraction method. Using a
Taylor polynomial obtained from a dataset, the method can map the
dataset into features that can represent the properties of a target
symbolic equation. Moreover, we create a function feature evolution
method to transform individuals according to these features.

(3) We demonstrate that TaylorGP significantly outperforms
state-of-the-art approaches, such as FFX[33], GSGP [38], BSR [18],

Foreach𝑇!𝑥!DataObtainingak-orderTaylorpolynomial𝑇𝑥,𝑦=&!"#$1𝑘!𝑥−𝑥%⋅𝜕𝜕𝑥+𝑦−𝑦%⋅𝜕𝜕𝑦$𝑓(𝑥%,𝑦%)≈1.1𝑥+0.2𝑥"−3.7+1.5𝑦−0.25𝑦#+0.0125𝑦$Decomposingthek-orderTaylorpolynomial(1.1𝑥+0.2𝑥"−3.7)+(1.5𝑦−0.25𝑦#+0.0125𝑦$)•+separability𝑇𝑥%,…,𝑥&=𝑇%𝑥%+⋯+𝑇&(𝑥&)•×separability𝑇𝑥%,…,𝑥&=𝑇%𝑥%×⋯×𝑇&(𝑥&)is_polynomialFunctionFeatureEvolutionfor𝑇!𝑥!•odd/even𝑇!−𝑥!=−𝑇!𝑥!𝑇!−𝑥!=𝑇!𝑥!•boundaryExtractingfunctionfeaturefrom𝑇!𝑥!•initializes𝑛individualsinthefunctionboundary•recombines𝛼individualsaccordingtothesefeatures•randominitializes𝛽individuals•select𝑛individualsasthenextpopulation1.5𝑦−0.25𝑦#+0.0125𝑦$NoAssemblingmathematicalexpressions1.1𝑥+0.2𝑥"−3.7Yes1.5sin𝑦,1.5y−0.25𝑦",…1.1𝑥+0.2𝑥"+1.5sin(𝑦)−3.71.1𝑥+0.2𝑥"+1.5sin(𝑦)−3.71.1𝑥+0.2𝑥"+1.5y−0.25y"−3.7…𝑇!𝑥!∈[𝑎,𝑏]or•monotonic𝑇!𝑥!’≥𝑇!𝑥!(or𝑇!𝑥!’≤𝑇!𝑥!(Taylor Genetic Programming for Symbolic Regression

the two neural network methods, DSR and AIFeynman. Further-
more, the neural network methods seem to be more dependent on
the training dataset. Neural networks could not discover a correct
mathematical equation if their structures (layer by layer) could not
extract valid features from the dataset.

2.2 Genetic programming for symbolic

regression

GP [26] is still a commonly used approach to deal with SR. GP
uses evolutionary operators – crossover, mutation, and selection,
to change the individual encoding and generate better offspring for
searching a solution in the mathematical expression space. Vari-
ous GPs employ different individual encodings to represent math-
ematical equations, such as tree-encoded GPs [7, 26, 35, 38, 45],
graph-encoded GPs [37, 44], and linearly encoded GPs [3, 14, 31].
For the mathematical expression space, the presence of real con-
stants accounts for a significant portion of the size of the space. For
example, the size of the aforementioned problem in the Introduc-
tion section is 8.2 × 10162. In comparison, without real constants,
its size is 1.054 × 1019 [25]. So, some GP methods [24, 27, 51] with
a constant optimizer are proposed to search the space. These meth-
ods represent the skeleton of a mathematical expression by using
constant placeholders. And a constant optimizer is used to find
the values in these constant placeholders. AEG-GP [24, 25] uses
the abstract expression grammar to represent the skeleton of a
mathematical expression and utilizes PSO [21] to find constant
values. Unlike AEG-GP, PGE [51] is a deterministic SR algorithm
that offers reliable and reproducible results. While PGE maintains a
tree-based representation and Pareto non-dominated sorting from
GP, it replaces the genetic operators and random numbers with
grammar rules. The method also uses nonlinear regression to fit
the constants of a mathematical equation. The approaches to GP-
based feature engineering, such as GP-based feature construction
[27], MRGP [1], FEW [29], M3GP [40], and FEAT [6], utilize EC to
search for possible representations and couple with an ML model
to handle the parameters of the representations. Different from
GP-based feature engineering approaches, FFX [33] is a determin-
istic SR algorithm. It enumerates a massive set of basic features
(basis functions–𝐵𝑖 (𝑥)) by a production rule. It then find coefficient
values(𝑎) in "𝑦 = 𝑎0 +(cid:205)𝑁
𝑎𝑖 ×𝐵𝑖 (𝑥)" by using pathwise regularized
𝑖=1
learning.

The other research line uses the hybrid of a neural network and a
GP, called DL-GP. DL-GPs [11, 39, 52, 53] leverage a neural network
to obtain features from the given dataset and apply these features to
guide GP. For example, Xing et al. [52] design an encoder-decoder
neural network based on super-resolution ResNet to predicate the
importance of each mathematical operator from the given data; and
utilize the importance of each mathematical operator to guide GP.
Cranmer et al. [11] train a graph neural network to represent sparse
latent features of the given dataset, and employ GP to generate
symbolic expressions fitted to these latent features. The DL-GPs
still depend on the time-consuming training work and the training
dataset.

Like AIFeynman, TaylorGP also needs to extract the symbolic
equation’s properties (e.g., separability and low-order polynomial)
from the given dataset. However, the difference is that AIFeynman

employs a neural network to obtain these properties while TaylorGP
achieves the goal using the coefficients in the Taylor series on the
given dataset. Therefore, TaylorGP does not need to train a model
and does not depend on the training data.

3 TAYLOR FEATURES ANALYSIS
3.1 Obtaining a Taylor polynomial
Taylor’s theorem [17] states that if a function 𝑓 has 𝑛 +1 continuous
derivatives on an open interval containing 𝑎, for each 𝑥 in the
interval,

𝑓 (𝑥) =

(cid:34) 𝑛
∑︁

𝑘=0

𝑓 (𝑘) (𝑎)
𝑘!

(cid:35)

(𝑥 − 𝑎)𝑘

+ 𝑅𝑛+1 (𝑥).

(1)

So, the 𝑘-order Taylor polynomial ((cid:205)𝑛
mates to 𝑓 around 𝑎.

𝑘=0

𝑓 (𝑘 ) (𝑎)
𝑘!

(𝑥 − 𝑎)𝑘 ) approxi-

Given a dataset (𝑋, 𝑌 ), for any point (𝑥0, 𝑦0) ∈ (𝑋, 𝑌 ), the 𝑘-
order Taylor polynomial around the point can be obtained by the
following three steps. First, select 𝑘 points ({(𝑥1, 𝑦1), ..., (𝑥𝑘, 𝑦𝑘 )})
around (𝑥0, 𝑦0) from the dataset. Next, according to the selected 𝑘
points, gather 𝑘 𝑘-order Taylor polynomials by Equation 2.

𝑓 (𝑘) (𝑥0) ≈ 𝑓 (𝑥1) − 𝑓 (𝑥0)
𝑓 (𝑘) (𝑥0) ≈ 𝑓 (𝑥2) − 𝑓 (𝑥0)




(𝑥1 − 𝑥0) 𝑓 ′ (𝑥0) + . . . + (𝑥1−𝑥0)𝑘
(𝑥2 − 𝑥0) 𝑓 ′ (𝑥0) + . . . + (𝑥2−𝑥0)𝑘
𝑘!
. . .
(𝑥𝑘 − 𝑥0) 𝑓 ′ (𝑥0) + . . . + (𝑥𝑘 −𝑥0)𝑘

𝑘!

𝑘!

𝑓 (𝑘) (𝑥0) ≈ 𝑓 (𝑥𝑘 ) − 𝑓 (𝑥0)


(2)
, where 𝑓 (𝑥𝑖 ) = 𝑦𝑖 . The final step is to obtain the 𝑘 derivatives (𝐹 )
by Equation 3

(𝑎), 𝑓 ′′
, where 𝐹 = [𝑓 ′
𝑦0]𝑇 . For each 𝑎𝑖 𝑗 ∈ 𝐴, 𝑎𝑖 𝑗 = (𝑥𝑖 −𝑥0) 𝑗
Taylor polynomial.

𝑗!

𝐹 ≈ 𝐷𝐴−1

(3)
(𝑎), ..., 𝑓 (𝑘) (𝑎)]𝑇 , 𝐷 = [𝑦1−𝑦0, 𝑦2−𝑦0, ..., 𝑦𝑘 −
. 𝐹 can generate the 𝑘-order

Scaling to a high dimensional dataset. Mathematically, the
3.1.1
higher the order of 𝑘, the more accurate the Taylor polynomial is.
However, in practice, 𝑘 can not be too high in a high dimensional
dataset 𝐷 because of the two following limitations. According to
the Taylor’s theorem for multivariate functions [16], the 𝑛-variable
𝑘-order Taylor polynomial has 𝐶𝑛
𝑛+𝑘 − 1 points need
to be sampled around the point to obtain the Taylor polynomial.
However, if 𝑘 is too high, 𝐶𝑛
𝑛+𝑘 −1 will be greater than all points in 𝐷.
This is impossible. Therefore, 𝑘 must be limited so that 𝐶𝑛
𝑛+𝑘 − 1 <
|𝐷 |. The other limitation is that, if 𝑘 is too high, the inverse of the
matrix 𝐴 in Equation 3 would be a big challenge to compute since
𝐴 is an ultra-large-scale ((𝐶𝑛
𝑛+𝑘 − 1)) matrix. So, we
usually set 𝑘 = 1 𝑜𝑟 2 in a high-dimensional dataset because of the
two limitations.

𝑛+𝑘 terms. So, 𝐶𝑛

𝑛+𝑘 − 1) × (𝐶𝑛

3.2 Extracting Taylor features
Since the above 𝑘-order Taylor polynomial is generated from a
given dataset (𝑋, 𝑌 ), it can approximate a function 𝑓 that fits the
dataset (i.e., 𝑓 (𝑋 ) = 𝑌 ) around a point (𝑥0, 𝑦0). It can also represent
some 𝑓 ’s local features, called Taylor features. This paper discusses
the Taylor features, low order polynomial, variable separability,
function boundary, monotony and parity.

3.2.1 Low order polynomial discrimination. For SR, a key problem
is to discriminate whether there is (or only) a low-order polynomial
that can represent the given dataset. If it exists, a linear regres-
sion algorithm can be used to get it and the algorithm could solve
SR quickly. The 𝑘-order Taylor polynomial can easily solve the
discrimination problem owing to its coefficients. If a function is
a 𝑘-order polynomial, its Taylor expansion at a point is also a 𝑘-
order polynomial. For example, for "1.1𝑥 + 0.2𝑥 2 − 3.7", its Taylor
expansion at 𝑥 = 1 is also ’1.1𝑥 + 0.2𝑥 2 − 3.7’. While, if a function
is not a 𝑘-order polynomial, its Taylor expansion at a point is an
infinite-order polynomial. For 1.5𝑠𝑖𝑛(𝑥), its Taylor expansion is an
infinite order polynomial. So, for the 𝑘-order Taylor polynomial
obtained from a dataset, in each term whose degree is greater than
𝑖 (𝑖 < 𝑘), if the coefficient is zero, the function that 𝑘-order Taylor
polynomial approximates is a low 𝑖-order polynomial.

3.2.2 Variable separability. For a multivariate function 𝑓 (𝑥1, ..., 𝑥𝑛),
if there is an operator "◦" that lets 𝑓 (𝑥1, ..., 𝑥𝑛) = 𝑓1 (𝑥𝑖, ..., 𝑥𝑘 )
◦𝑓2 (𝑥𝑚, ..., 𝑥𝑝 ) where the two variable sets, {𝑥𝑖, ..., 𝑥𝑘 } and {𝑥𝑚,...,𝑥𝑝
}, both belong to {𝑥1, ..., 𝑥𝑛 }, and {𝑥𝑖, ..., 𝑥𝑘 } ∩ {𝑥𝑚, ..., 𝑥𝑝 } = 𝜙, it
is called "◦" separability. The separability property can decompose
a complex multivariate function into multiple simple functions.

If "◦" is addition or multiplication, it is called addition sep-
arability or multiplication separability, respectively. The 𝑛-
variable 𝑘-order Taylor polynomial can represent the two sepa-
rability properties, respectively. For the Taylor polynomial, if the
coefficient in each multi-variable term is zero, the function that the
Taylor polynomial approximates is addition separability. As shown
in Figure 1, the Taylor expansion of "1.1𝑥 + 0.2𝑥 2 + 1.5𝑠𝑖𝑛(𝑦) − 3.7"
is "1.1𝑥 + 0.2𝑥 2 − 3.7 + 1.5𝑦 − 0.25𝑦3 + 0.0125𝑦5", where the coeffi-
cient in each multi-variable term is zero, i.e., 𝑐 in each 𝑐𝑥𝑖𝑦 𝑗 is 0.
So, according to the addition separability, the Taylor polynomial
is decomposed into multiple polynomials, such as "1.1𝑥 + 0.2𝑥 2 +
1.5𝑠𝑖𝑛(𝑦) − 3.7 ≈ (1.1𝑥 + 0.2𝑥 2 − 3.7) + (1.5𝑦 − 0.25𝑦3 + 0.0125𝑦5)".
The above method about addition separability also can be used
to discriminate multiplication separability. Because, if a function
is multiplication separability, i.e., 𝑓 (𝑥1, ..., 𝑥𝑛) = 𝑓1 (𝑥𝑖, ..., 𝑥𝑘 ) ×
𝑓2 (𝑥𝑚, ..., 𝑥𝑝 ), then log 𝑓 (𝑥1, ..., 𝑥𝑛) = log 𝑓1 (𝑥𝑖, ..., 𝑥𝑘 ) + log 𝑓2 (𝑥𝑚,
..., 𝑥𝑝 ). So, if the 𝑛-variable 𝑘-order Taylor polynomial obtained
after computing the log of the dataset is addition separability, then
the function is the multiplication separability.

3.2.3 Boundary. The 𝑘-order Taylor polynomial can be used to
evaluate the boundary of the function 𝑓 that it approximates to
at the interval [𝑥𝑎, 𝑥𝑏 ]. Since it is a polynomial, its boundary is
computed by interval arithmetic [12]. For example, the boundary
of the Taylor polynomial "1.1𝑥 + 0.2𝑥 2 − 3.7", where 𝑥 ∈ [−1, 1], is
"[−1.1, 1.1] + 0.2 × [0, 1] − 3.7 = [−4.8, −2.4]".

3.2.4 Monotonic. For all points (𝑥𝑖, 𝑦𝑖 ) in a dataset (X,Y), if 𝑦𝑖 ≥ 𝑦 𝑗
and 𝑥𝑖 ≥ 𝑥 𝑗 , the function that the dataset represents is a monotonic-
increasing function. Otherwise, if 𝑦𝑖 ≥ 𝑦 𝑗 and 𝑥𝑖 ≤ 𝑥 𝑗 , the function
is a monotonic-decreasing function.

3.2.5 Parity. If the 𝑘-order Taylor polynomial 𝑇 (𝑥) is an odd or
even function, i.e., 𝑇 (−𝑥) = −𝑇 (𝑥) or 𝑇 (−𝑥) = 𝑇 (𝑥), then the
function that it approximates is also an odd or even function. While
the method is simple, testing all points is time-consuming.

Baihe He, Qiang Lu, Qingyun Yang, Jake Luo, and Zhiguang Wang

Another method is to count odd-order terms and even-order
terms in the 𝑘-order Taylor polynomial except for the 0-order term
(constant term). If the 𝑘-order Taylor polynomial only contains odd
(or even) order terms, it is an odd (or even) function. For example,
given that 𝑓 (𝑥) = 1.5𝑠𝑖𝑛(𝑥) − 3.7 and its Taylor polynomial is
1.5𝑥 − 0.25𝑥 3 + 0.0125𝑥 5 + ... + 4.217𝑒 − 15𝑥 17 − 3.7 at the point 𝑥 = 0,
after removing the 0-order term "−3.7", the Taylor polynomial only
contain odd-order terms, such as "0.25𝑥 3"and "0.0125𝑥 5". So, it is
an odd function.

4 TAYLOR GENETIC PROGRAMMING
TaylorGP, as shown in Figure 1, includes the following six steps: 1)
obtaining a Taylor polynomial 𝑇 from a given dataset, 2) decompos-
ing the Taylor polynomial into multiple simple Taylor polynomials
({𝑇1,𝑇2, ...,𝑇𝑛 }), 3) discriminating the low order polynomial, 4) ex-
tracting function features, 5) running the function feature evolution
method, and 6) assembling mathematical expressions. How to exe-
cute the steps: 1), 2), 3), and 4) has been introduced in Section 3. Step
6) is simple, which only composes the mathematical expressions
found by each simple Taylor polynomials into various complete
mathematical equations and evaluates them. So, the following con-
tent details step 5).

The function feature evolution method (FFEM), as shown in Algo-
rithm 1, evolves individuals based on the function feature 𝐹 that
includes boundary, monotonic, and parity. FFEM mainly contains
two evolvable operators, individual initialization (initIndividual-
ByFeatures) and individual recombination (recombineByFeatures).
The individual initialization operator randomly generates individu-
als that satisfy the function feature. The individual recombination
operator transforms individuals to ensure that the generated in-
dividuals satisfy the function feature. In each generation, FFEM
leverages individual recombination to produce offspring with the
probability 𝛼; utilizes the individual initialization to produce off-
spring with the probability 𝛽; saves individuals as other offspring
with the probability (1 − 𝛼 − 𝛽).

4.1 Individual initialization
The probability of randomly generating an individual that satisfies
the function feature 𝐹 is very small. And the process for obtaining
𝑁 number of these candidate individuals is very time-consuming.
To speed up the process, the individual initialization operator first
segments the mathematical expression space into many sub-spaces.
It then evaluates the function features of these sub-spaces. Finally,
it randomly selects the sub-spaces that satisfy 𝐹 and randomly
generates individuals in these sub-spaces until they satisfy 𝐹 .

Segmenting mathematical expression space . A tree can be
4.1.1
used to represent a mathematical expression. A tree with depth ℎ
also shows a sub-space that contains all mathematical expressions
expanded from the tree. Moreover, all trees with depth ℎ represent a
segment of the mathematical expression space. For example, given a
basic function set {+, 𝑠𝑖𝑛} and a variable set {𝑥, 𝑐}, the mathematical
expression space is divided into the sub-spaces encoded by trees
with depth 3, such as "+ +𝑠𝑖𝑛𝑐𝑥𝑥", "+ + +𝑥𝑐𝑐", "+𝑠𝑖𝑛𝑠𝑖𝑛𝑥𝑥", and "𝑠𝑖𝑛 +
𝑥𝑐". The sub-space "+ + 𝑠𝑖𝑛𝑐𝑥𝑥" is a mathematical expression "𝑐 +
𝑥 + 𝑠𝑖𝑛(𝑥)", which contains all mathematical expressions expanded
from "+ + 𝑠𝑖𝑛𝑐𝑥𝑥", such as "+ + 𝑠𝑖𝑛 + 𝑐𝑥𝑥𝑥"="(𝑐 + 𝑥) + 𝑠𝑖𝑛(𝑥) + 𝑥".

Taylor Genetic Programming for Symbolic Regression

Algorithm 1 function feature evolution method
Input: (𝑋𝑖, 𝑌𝑖 ), 𝛼, 𝛽, threshold, maxGen,𝐹
Output: best

1: 𝑃 ← initIndividualByFeatures(𝐹 ,popsize=𝑁 )
2: best ← selectBestIndividual(𝑃)
3: while best.fitness ≤ threshold and 𝑔 < maxGen do
4:

for all 𝑖 = 1 to 𝑁 do

5:

6:

7:

8:

9:

10:

11:

12:

13:

𝑝1, 𝑝2 ← randomSelectTwoIndividuals(𝑃)
if rand() < 𝛼 then

child ← recombineByFeatures(𝑝1, 𝑝2,𝐹 )

else if rand() < 𝛼 + 𝛽 then

child ← initIndividualByFeatures(𝐹 ,popSize=1)

else

child ← 𝑝1

end if
nextP [𝑖] ← child

14:

15:

16:

end for
𝑃 ← nextP
best ← min(best, selectBestIndividual(𝑃,(𝑋𝑖, 𝑌𝑖 )))
𝑔 + +
17:
18: end while
19: return best

4.1.2 Evaluating sub-space. Interval arithmetic [12] can be used to
compute the boundary of a sub-space. In the tree that represents the
sub-space, if there is a path from a leaf node to the root node con-
sisting of unbound functions (𝑥, +, −, ×, /, 𝑎𝑥 , ln, ...), the boundary
of the sub-space is [−∞, ∞]. Otherwise, it is computed by interval
arithmetic. For example, for the sub-space "+ + 𝑠𝑖𝑛𝑐𝑥𝑥", there is
a path "𝑥 + +", so its boundary is [−∞, ∞]. There is no such path
for the sub-space "+𝑠𝑖𝑛𝑠𝑖𝑛𝑥𝑥", so its boundary is [-2,2] obtained by
interval arithmetic.

A sub-space’s non-monotonic or monotonic increasing/decrease
is determined by its derivative 𝑑. If 𝑑 ≥ 0 (or 𝑑 ≤ 0) in all variable
values, it is a monotone increasing (decreasing) function. Otherwise,
it is a non-monotone function. The sub-space is an odd/even func-
tion according to "𝑓 (−𝑥) = −𝑓 (𝑥)" or "𝑓 (−𝑥) = 𝑓 (𝑥)" for all values
in 𝑥. For the sub-space "+ + 𝑠𝑖𝑛𝑐𝑥𝑥=𝑐 + 𝑥 + 𝑠𝑖𝑛(𝑥)", its derivative
is "1 + 𝑐𝑜𝑠 (𝑥)", meaning that it is a monotone-increasing function.
Owing to "𝑐" in "𝑐 +𝑥 +𝑠𝑖𝑛(𝑥)", it is a non-odd and non-even function.

4.1.3 Generating individual. The method "generating individual"
obtains the segmented sub-spaces whose boundaries contain the
given boundary. It then randomly selects a sub-space from these
sub-spaces. If the sub-space does not satisfy the given monotony
and parity requirements, the method randomly generates a new
individual from the sub-space until it satisfies the given function
features. Otherwise, the method randomly generates an individual
based on the following rules, as listed in Table 1. For example,
given the function features {[−10, 10], 𝑜𝑑𝑑 }, for the selected sub-
space "+ + 𝑠𝑖𝑛𝑐𝑥𝑥=𝑐 + 𝑥 + 𝑠𝑖𝑛(𝑥)", it is a non-odd and non-even
function. So, the method randomly generates individuals until an
individual is an odd function whose boundary contains [−10, 10].
For the selected sub-space "+ + 𝑠𝑖𝑛𝑥𝑥𝑥=2𝑥 + 𝑠𝑖𝑛(𝑥)", it is an odd
function. So, the method randomly constructs an odd function (e.g.,

𝑠𝑖𝑛(𝑥)). It then combines the odd function and the selected sub-
space according to an operator randomly selected (e.g. "+") from
{+, −, ×, /, 𝑓 (𝑔(𝑥)}. With these steps the method finally generates
an individual "2𝑥 + 2𝑠𝑖𝑛(𝑥)" whose boundary contains [−10, 10].

Table 1: Function Combination Rules

op

𝑓 (𝑥)

𝑔(𝑥)

results

+
+
−
−
×, /
×, /
×, /
𝑓 (𝑔(𝑥))
𝑓 (𝑔(𝑥))
𝑓 (𝑔(𝑥))
𝑓 (𝑔(𝑥))
+
×

odd
odd
even
even
odd
odd
even
even
odd
odd
even
even
even
odd
even
even
odd
odd
odd
even
even
odd
↗ ↗
↗ ↗
𝑓 (𝑔(𝑥)) ↗ ↗

odd
even
odd
even
even
even
odd
even
odd
even
even
↗
↗
↗

"↗" represents a monotone-increasing function. The monotone-decreasing func-
tion has similar properties to the monotone-increasing function.

4.2 Individual recombination
According to the rules in Table 1, the individual recombination op-
erator recombines two individuals from the population to construct
an individual that satisfies the given function feature. Meanwhile,
if the recombined individual exceeds the limit length, the operator
prunes it to avoid the individual bloating. For example, given a
function feature – odd function, the operator recombines the two
individuals "2𝑥 + 2𝑠𝑖𝑛(𝑥)" and 𝑥 + 𝑥 3 with "+". The recombined
individual "2𝑥 + 2𝑠𝑖𝑛(𝑥) + 𝑥 + 𝑥 3" exceeds the limited length 12. It
then prunes "𝑠𝑖𝑛(𝑥)" in the individual and replaces "𝑠𝑖𝑛(𝑥)" with
"𝑥" according to "𝑓 (𝑔(𝑥))". The method in the end generates the
individual "5𝑥 + 𝑥 3" whose length is 9.

5 EXPERIMENT
5.1 Datasets
We evaluate the performance of TaylorGP on three kinds of bench-
marks: classical Symbolic Regression Benchmarks (SRB) [34], Penn
Machine Learning Benchmarks (PMLB) [41], and Feynman Sym-
bolic Regression Benchmarks (FSRB) [47]. SRB consists of twenty-
three SR problems derived from the five canonical symbolic re-
gression benchmarks, Nguyen [48], Korns [24], Koza [9], Keijzer
[20], and Vladislavleva [49]. PMLB includes seven regression tasks
and three classification tasks. FSRB contains forty-eight Feynman
equations in [47]. The distribution of the total 81 benchmark sizes
by samples and features is shown in Figure 2. The details of these
benchmarks are listed in the appendix.

5.2 Algorithm Parameter Settings
We compare TaylorGP with two kinds of baseline algorithms 2: four
symbolic regression methods and five machine learning methods.

2The nine baseline algorithms are implemented in SRBench [5]

Baihe He, Qiang Lu, Qingyun Yang, Jake Luo, and Zhiguang Wang

6 RESULTS AND DISCUSSION
6.1 Performance Metrics
TaylorGP and nine baseline algorithms run 30 times on each bench-
mark. Their fitness results are listed in the appendix. In addition,
the following 𝑅2 test [5] is introduced to evaluate the performance
of these algorithms on these benchmarks.

R2 = 1 −

(cid:205)𝑛
𝑖=1 ( ˆ𝑦𝑖 − 𝑦𝑖 )2
(cid:205)𝑛
𝑖=1 ( ¯𝑦 − 𝑦𝑖 )2

,

(4)

, where 𝑦𝑖 is the value in the dataset, ¯𝑦 is mean and ˆ𝑦𝑖 is the output
value of the best solution.

Figure 3 illustrates the normalized 𝑅2 scores of the ten algorithms
running 30 times on all benchmarks. Since the normalized 𝑅2 closer
to 1 indicates better results, overall TaylorGP can find more accurate
results than other algorithms. Moreover, TaylorGP’s results are
more stable. The normalized 𝑅2 scores of the ten algorithms on each
benchmark (in the appendix) show that TaylorGP can outperform
the nine baseline algorithms on most benchmarks.

Figure 3: Normalized 𝑅2 scores of the ten algorithms.

Table 3 shows that TaylorGP still outperforms the nine base-
line algorithms on the pairwise statistical comparisons with the
Wilcoxon signed-rank test. Except for TaylorGP, it is not easy to
find one algorithm outperform all other algorithms consistently on
the benchmarks.

6.2 Discussion
Why does TaylorGP outperform the nine baseline algorithms on
most benchmarks? The main reason is that the Taylor features can
guide TaylorGP to search the problem space more effectively than
the baselines. Compared with the other five ML methods, TaylorGP
does not need to construct a predefined model to find a model that
fits the given dataset. Therefore, on large-scale benchmarks, it can
find better results. Compared with other GPs that need to search
the whole mathematical expression space, TaylorGP’s search space
is smaller. So, it can find the correct results faster.

6.2.1 Convergence Analysis. We compare TaylorGP with the other
three SR methods, GPLearn, GSGP, and BSR. Two benchmarks are
used in the following evaluation. One benchmark is the "𝑥𝑥1
0 " from

Figure 2: Properties of Benchmarks.

Table 2: Algorithm parameters

Parameter

Function Set
Max Generations
Population Size
Crossover Rate
Mutation Rate
Copy Rate
Stopping Threshold

Function Set
max generations
Population Size
Crossover Rate
Mutation Rate
Copy Rate
Stopping Threshold

Function Set
Max Generations
Population Size
Crossover Rate
Mutation Rate
Stopping Threshold

Function Set
MM
k
Stopping Threshold

None

Normalize

Kernal
Gamma
Regularization

Value
+,−,×,÷,sin,cos,𝑙𝑛(|𝑛|),𝑒𝑥𝑝,𝑠𝑞𝑟𝑡
10000
1000
0.7
0.2
0.1
1e-5
+,−,×,÷,sin,cos,𝑙𝑛(|𝑛|),𝑒𝑥𝑝,𝑠𝑞𝑟𝑡
10000
1000
0.7
0.2
0.1
1e-5

+,−,×,÷
10000
1000
0.7
0.2
1e-5
+,−,×,÷,sin,cos,𝑙𝑛(|𝑛|),𝑒𝑥𝑝,𝑠𝑞𝑟𝑡
10000
2
1e-5

FALSE

’linear’, ’poly’, ’rbf’, ’sigmoid’
0.01,0.1,1,10
0.001,0.1,1

Number of Estimators
Max Features

10, 100, 1000
’sqrt’,’log2’,None

Name

TaylorGP

GPLearn

GSGP

BSR

FFX

LR

KR

RF

SVM

XGBoost

Kernal

‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’

Learning Rate
Gamma

0.0001,0.01, 0.05, 0.1, 0.2
0,0.1,0.2,0.3,0.4

The symbolic regression methods include GPlearn3, FFX [33], geo-
metric semantic genetic programming (GSGP)[38] and bayesian
symbolic regression (BSR) [18]. The machine learning methods
include linear regression (LR), kernel ridge regression (KR), ran-
dom forest regression (RF), support vector machines (SVM), and
XGBoost [8]. The detailed parameters of each algorithm are tuned
according to Table 2.

3https://github.com/trevorstephens/gplearn

2010812038040048810004000No. of Samples0510152025No. of FeaturesPMLBSRBFSRBTaylorGPGPLearnFFXLRKRRFSVMXGBoostGSGPBSR-0.4-0.20.00.20.40.6Score(Normalized R2)TaylorGPXGBoostGSGPBSR0.6900.6910.6920.693Taylor Genetic Programming for Symbolic Regression

Table 3: Wilcoxon signed-rank test of normalized 𝑅2 scores for pairwise statistical comparisons.

TaylorGP GPLearn

FFX

LR

KR

RF

SVM

XGBoost

GSGP

GPLearn
FFX
LR
KR
RF
SVM
XGBoost
GSGP
BSR

5.73e-13
8.87e-11
5.86e-15
2.73e-15
4.31e-14
2.84e-15
6.72e-05
1.08e-04
3.09e-03

6.55e-03
8.70e-01
1.00e+00
1.00e+00
5.34e-01
1.00e+00
1.00e+00
1.00e+00

9.82e-01
1.00e+00
1.00e+00
1.00e+00
1.00e+00
1.00e+00
1.00e+00

1 bold number means that 𝑝 < 0.05.

1.00e+00
1.00e+00
7.74e-01
1.00e+00
1.00e+00
1.00e+00

8.04e-01
2.28e-05
1.00e+00
1.00e+00
1.00e+00

1.36e-05
1.00e+00
1.00e+00
1.00e+00

1.00e+00
1.00e+00
1.00e+00

2.43e-03
3.62e-02

9.84e-02

SRB. The other is the "𝑈 = 1
𝑘𝑠𝑝𝑟𝑖𝑛𝑔𝑥 2" from FSRB. We illustrate
2
how the Taylor features help TaylorGP quickly find the correct
results through the two benchmarks. Figures 4 and 5 show the
processes of the four methods running on the two benchmarks,
respectively.

Figure 5: Convergence Comparison for "𝑈 = 1
2
where 𝑘𝑠𝑝𝑟𝑖𝑛𝑔 and 𝑥 are variables.

𝑘𝑠𝑝𝑟𝑖𝑛𝑔𝑥 2",

Figure 4: Convergence Comparison for "𝑥𝑥1
0 ".

For the benchmark "𝑥𝑥1

𝑥1 + 163.688𝑥 2

0 " where 𝑥0 and 𝑥1 both are in [2, 4], com-
pared with GPLearn, GSGP and BSR, TaylorGP can find the optimal
result "𝑒𝑥𝑝 (𝑙𝑜𝑔(𝑥0)𝑥1) = 𝑥𝑥1
0 " at the 1000th generation. While the
other three algorithms still can not find the optimal results until
they run for 10,000 generations. TaylorGP first generates the Taylor
+ 15.171𝑥 2
0 + 2.932𝑥 3
polynomial "(2.596𝑒 − 3)𝑥 4
𝑥 2
𝑥1 − 7.828𝑥 3
1 −
0
0
0
1 + 710.31𝑥0𝑥1 −
− 167.424𝑥0𝑥 2
0 + 11.398𝑥0𝑥 3
100.026𝑥 2
0
1
932.144𝑥0 + 1.636𝑥 4
1 − 1393.536𝑥1 + 1590.457"
+ 416.67𝑥 2
1 − 47.859𝑥 3
1
at the point(2,2). According to the Taylor polynomial, the function
boundary is [4.233, 230.513], and the function is monotonically
increasing. The two Taylor features can reduce the space used to
initialize individuals. As "log(𝑥0)", "𝑥0 × 𝑥1", and "𝑒𝑥𝑝 (𝑥0)" all are
monotone increasing functions at the range [2,4], they are very
likely to be selected as initialized. The individual recombination that
recursively merges the three functions using the operator 𝑓 (𝑔(𝑥))
in Table 1 may generate "𝑒𝑥𝑝 (𝑙𝑜𝑔(𝑥0)𝑥1)". So, TaylorGP, compared
with the other three algorithms, can initialize better individuals
and get the optimal result earlier, as shown in Figure 4.

For the Feynman benchmark "𝑈 = 1
2

𝑘𝑠𝑝𝑟𝑖𝑛𝑔𝑥 2", TaylorGP finds
the optimal results at the 0th generation, because TaylorGP can
directly obtain 0.2𝑘𝑠𝑝𝑟𝑖𝑛𝑔𝑥 2 owing to the low polynomial discrimi-
nation. TaylorGP achieves the Taylor polynomial "(1.454𝑒 − 6)𝑥 3
−
0
1 + (5.809𝑒 − 6)𝑥0𝑥1 +
(1.181𝑒 − 6)𝑥 2
0
(9.249𝑒 − 6)𝑥0 − (2.53𝑒 − 6)𝑥 3
1 − (6.481𝑒 − 5)𝑥1 +
1
(5.579𝑒 − 5)" from the benchmark. After omitting insignificant co-
efficients that are less than 𝑒 − 4, the Taylor polynomial is "0.5𝑥0𝑥 2
1 ".
As the RMSE of "0.5𝑥0𝑥 2
1 " is less than the stopping threshold 𝑒 − 5,
it is the final result that TaylorGP finds.

0 + (0.5)𝑥0𝑥 2
+ (2.041𝑒 − 5)𝑥 2

𝑥1 − (7.784𝑒 − 6)𝑥 2

Besides the two figures, the figures of the convergence compari-
son that the four algorithms run on the other benchmarks are listed
in the appendix.

Fitness Analysis. Figure 6 illustrates that TaylorGP, when
6.2.2
compared with the nine baseline algorithms, can obtain more ac-
curate and stable results on the two benchmarks, SRB and FSRB.
However, on the benchmark PMLB, the two algorithms, FFX and
XGBoost, outperform TaylorGP. This is due to PMLB has more fea-
tures (variables) than the other two benchmark sets, Figure 6 shows
that TaylorGP has the best performance (normalized 𝑅2 score) on
the-low dimensional datasets. In contrast, its performance degrades
as the dataset’s dimension increases. For a high dimension dataset,
TaylorGP can only obtain a low order Taylor polynomial according

Baihe He, Qiang Lu, Qingyun Yang, Jake Luo, and Zhiguang Wang

(b) FSRB
Figure 6: Normalized 𝑅2 comparisons of the ten SR methods on classical Symbolic Regression Benchmarks (SRB), Feynman
Symbolic Regression Benchmarks (FSRB), and Penn Machine Learning Benchmarks (PMLB), respectively.

(c) PMLB

(a) SRB

to the analysis in Section 3.1.1. However, the low order Taylor poly-
nomial may not approximate the real function that fits the given
high-dimensional dataset. The Taylor features extracted from the
Taylor polynomial may be incorrect or incomplete; therefore the
features cannot help TaylorGP find a correct result.

6.2.3 The accuracy of extracting Taylor features. As the real func-
tion that fits the dataset in PMLB is unknown, Table 4 lists the
accuracy of extracting each Taylor feature on SRB and FSRB (total
71 benchmarks). TaylorGP can correctly identify the two Taylor
features, monotone and boundary, on all benchmarks, meaning that
the two Taylor features always help Taylor reduce the search space.
However, TaylorGP recognizes the variable separability and
even/odd function with low accuracies (12.5% and 36.7%). For iden-
tifying the variable separability and the odd/even function, Tay-
lorGP requires that the Taylor polynomial can not contain some
order terms, i.e., the coefficients in these order terms must be zero.
However, as the Taylor polynomial approximates the real function
around a point, some inconsistencies exist between the polynomial
and the real function. The coefficients on these terms are slight er-
rors. These slight error coefficients affect the recognition of the vari-
able separability and the odd/even function. For example, for 𝑠𝑖𝑛(𝑥),
its Taylor polynomial at the point (0,0) is " 1
𝑥 7+...".
1!
However, according to Equation 3, TaylorGP sets a 4-order Taylor
polynomial and obtains the polynomial "0.015+ 1
𝑥 3"
1!
from the given dataset. The polynomial is not an odd function due
to the two coefficients, "0.015" and "0.003". To prevent this from
happening, we set a threshold for these coefficients and omit the
terms whose coefficients are less than the threshold. However, it
is not easy to get a suitable threshold for the Taylor polynomial
because of the diversity of datasets.

𝑥 +0.003𝑥 2 − 1
3!

𝑥 5− 1
7!

𝑥 3+ 1
5!

𝑥− 1
3!

Table 4: The accuracy of extracting Taylor features on 71
benchmarks.

Taylor Features

Accuracy Correct No Ground Truth No

LowOrderPoly
Separability
Boundary
Odd/even function
Monotone

73.9%
12.5%
100.0%
36.7%
100.0 %

17
3
71
18
10

23
24
71
49
10

Although the two Taylor features (variable separability, odd/even
function) have a low recognition accuracy, they still can help Tay-
lorGP to find the correct symbolic equation, such as running Tay-
lorGP on the two above benchmarks, "𝑥𝑥1
𝑘𝑠𝑝𝑟𝑖𝑛𝑔𝑥 2".
So, TaylorGP can utilize the Taylor features to reduce its search
space and speed up its search.

0 " and "𝑈 = 1
2

7 CONCLUSION
This paper proposes a new method called TaylorGP to search the
mathematical expression space using Taylor features. As most of
the Taylor features are obtained by the coefficients in a Taylor
polynomial, the modeling process can be computationally efficient
and straightforward to implement. TaylorGP leverages the two
operators based on Taylor features, individual initialization, and
individual recombination, to evolve the population. Experiments
show that TaylorGP can quickly find the correct result with the
help of the two evolution operators.

However, TaylorGP will degrade when the dataset dimension in-
creases because of the local approximation of the Taylor polynomial.
In a high-dimensional dataset, a low order Taylor polynomial ob-
tained from the dataset only represents the dataset’s local features,
not global features. So, our future work will involve investigating
how to utilize many low-order Taylor polynomials to represent
global features in high-dimensional datasets.

ACKNOWLEDGMENTS
This work is supported by China National Key Research Project
(No.2019YFC0312003)

REFERENCES
[1] Ignacio Arnaldo, Krzysztof Krawiec, and Una-May O’Reilly. 2014. Multiple
regression genetic programming. In Proceedings of the 2014 Annual Conference on
Genetic and Evolutionary Computation. 879–886.

[2] Luca Biggio, Tommaso Bendinelli, Alexander Neitz, Aurelien Lucchi, and Giambat-
tista Parascandolo. 2021. Neural Symbolic Regression that scales. In Proceedings of
the 38th International Conference on Machine Learning, Vol. 139. PMLR, 936–945.
[3] Markus F Brameier and Wolfgang Banzhaf. 2007. Linear genetic programming.

Springer Science & Business Media.

[4] Tom B Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan,
Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda
Askell, et al. 2020. Language models are few-shot learners. arXiv preprint
arXiv:2005.14165 (2020).

TaylorGPGPLearnFFXLRKRRFSVMXGBoostGSGPBSR0.00.10.20.30.40.50.60.7Score(Normalized R2)TaylorGPXGBoostGSGPBSR0.69200.69250.6930TaylorGPGPLearnFFXLRKRRFSVMXGBoostGSGPBSR-0.4-0.20.00.20.40.6Score(Normalized R2)TaylorGPXGBoostGSGPBSR0.692250.692500.692750.69300TaylorGPGPLearnFFXLRKRRFSVMXGBoostGSGPBSR0.10.20.30.40.50.60.7Score(Normalized R2)Taylor Genetic Programming for Symbolic Regression

[5] William La Cava, Patryk Orzechowski, Bogdan Burlacu, Fabricio Olivetti de
Franca, Marco Virgolin, Ying Jin, Michael Kommenda, and Jason H. Moore. 2021.
Contemporary Symbolic Regression Methods and their Relative Performance.
In Advances in Neural Information Processing Systems Datasets and Benchmarks
Track.

[6] William La Cava, Tilak Raj Singh, James Taggart, Srinivas Suri, and Jason Moore.
2019. Learning concise representations for regression by evolving networks of
trees. In International Conference on Learning Representations.

[7] Q. Chen, B. Xue, and M. Zhang. 2019.

Improving Generalization of Genetic
Programming for Symbolic Regression With Angle-Driven Geometric Semantic
Operators.
IEEE Transactions on Evolutionary Computation 23, 3 (June 2019),
488–502.

[8] Tianqi Chen and Carlos Guestrin. 2016. Xgboost: A scalable tree boosting system.
In Proceedings of the 22nd acm sigkdd international conference on knowledge
discovery and data mining. 785–794.

[9] Steffen Christensen and Franz Oppacher. 2002. An Analysis of Koza’s Computa-
tional Effort Statistic for Genetic Programming. In Genetic Programming, James A.
Foster, Evelyne Lutton, Julian Miller, Conor Ryan, and Andrea Tettamanzi (Eds.).
Springer Berlin Heidelberg, Berlin, Heidelberg, 182–191.

[10] Corinna Cortes and Vladimir Vapnik. 1995. Support-vector networks. Machine

learning 20, 3 (1995), 273–297.

[11] Miles Cranmer, Alvaro Sanchez Gonzalez, Peter Battaglia, Rui Xu, Kyle Cranmer,
David Spergel, and Shirley Ho. 2020. Discovering Symbolic Models from Deep
Learning with Inductive Biases. In Advances in Neural Information Processing
Systems, Vol. 33. Curran Associates, Inc., 17429–17442.

[12] Hend Dawood. 2011. Theories of interval arithmetic: mathematical foundations

and applications. LAP Lambert Academic Publishing.

[13] Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT:
Pre-training of Deep Bidirectional Transformers for Language Understanding. In
NAACL. Association for Computational Linguistics, 4171–4186.

[14] Candida Ferreira. 2001. Gene Expression Programming: a New Adaptive Algo-

rithm for Solving Problems. Complex Systems 13, 2 (2001), 87–129.

[15] Roger Fletcher. 2013. Practical methods of optimization. John Wiley & Sons.
[16] Mark H Holmes. 2009. Introduction to the foundations of applied mathematics.

(2009).

[17] Harold Jeffreys, Bertha Jeffreys, and Bertha Swirles. 1999. Methods of mathemati-

cal physics. Cambridge university press.

[32] Georg Martius and Christoph H Lampert. 2016. Extrapolation and learning

equations. arXiv preprint arXiv:1610.02995 (2016).

[33] Trent McConaghy. 2011. FFX: Fast, scalable, deterministic symbolic regression
technology. In Genetic Programming Theory and Practice IX. Springer, 235–260.
[34] James McDermott, David R. White, Sean Luke, Luca Manzoni, Mauro Castelli,
Leonardo Vanneschi, Wojciech Jaskowski, Krzysztof Krawiec, Robin Harper,
Kenneth De Jong, and Una-May O’Reilly. 2012. Genetic Programming Needs
Better Benchmarks (GECCO ’12). Association for Computing Machinery, New
York, NY, USA, 791–798.

[35] Robert I. McKay, Nguyen Xuan Hoai, Peter Alexander Whigham, Yin Shan, and
Michael O’Neill. 2010. Grammar-based Genetic Programming: a survey. Genetic
Programming and Evolvable Machines 11, 3 (Sept. 2010), 365–396.

[36] Julian Francis Miller. 2019. Cartesian genetic programming: its status and future.

Genetic Programming and Evolvable Machines (Aug. 2019), 1–40.

[37] Julian Francis Miller and Simon L. Harding. 2008. Cartesian Genetic Program-
ming. In Proceedings of the 10th Annual Conference Companion on Genetic and
Evolutionary Computation (GECCO ’08). ACM, New York, NY, USA, 2701–2726.
[38] Alberto Moraglio, Krzysztof Krawiec, and Colin G. Johnson. 2012. Geometric
Semantic Genetic Programming. In Parallel Problem Solving from Nature - PPSN
XII. Vol. 7491. Springer Berlin Heidelberg, Berlin, Heidelberg, 21–31.

[39] T Nathan Mundhenk, Mikel Landajuela, Ruben Glatt, Claudio P Santiago,
Daniel M Faissol, and Brenden K Petersen. 2021. Symbolic Regression via Neural-
Guided Genetic Programming Population Seeding. In Advances in Neural Infor-
mation Processing Systems.

[40] Luis Muñoz, Leonardo Trujillo, Sara Silva, Mauro Castelli, and Leonardo Van-
neschi. 2019. Evolving multidimensional transformations for symbolic regression
with M3GP. Memetic Computing 11, 2 (2019), 111–126.

[41] Randal S. Olson, William La Cava, Patryk Orzechowski, Ryan J. Urbanowicz,
and Jason H. Moore. 2017. PMLB: a large benchmark suite for machine learning
evaluation and comparison. BioData Mining 10, 36 (11 Dec 2017), 1–13.

[42] Brenden K Petersen, Mikel Landajuela Larma, Terrell N Mundhenk, Claudio Prata
Santiago, Soo Kyung Kim, and Joanne Taery Kim. 2021. Deep symbolic regression:
Recovering mathematical expressions from data via risk-seeking policy gradients.
In International Conference on Learning Representations.

[43] Subham Sahoo, Christoph Lampert, and Georg Martius. 2018. Learning equations
for extrapolation and control. In International Conference on Machine Learning.
PMLR, 4442–4450.

[18] Ying Jin, Weilin Fu, Jian Kang, Jiadong Guo, and Jian Guo. 2019. Bayesian symbolic

[44] Michael Schmidt and Hod Lipson. 2009. Distilling Free-Form Natural Laws from

regression. arXiv preprint arXiv:1910.08892 (2019).

Experimental Data. Science 324, 5923 (2009), 81–85.

[19] Guolin Ke, Qi Meng, Thomas Finley, Taifeng Wang, Wei Chen, Weidong Ma,
Qiwei Ye, and Tie-Yan Liu. 2017. Lightgbm: A highly efficient gradient boosting
decision tree. Advances in neural information processing systems 30 (2017), 3146–
3154.

[20] Maarten Keijzer. 2003. Improving symbolic regression with interval arithmetic
and linear scaling. In European Conference on Genetic Programming. Springer,
70–82.

[21] James Kennedy and Russell Eberhart. 1995. Particle swarm optimization. In
Proceedings of ICNN’95-international conference on neural networks, Vol. 4. IEEE,
1942–1948.

[22] Samuel Kim, Peter Y Lu, Srijon Mukherjee, Michael Gilbert, Li Jing, Vladimir
Čeperić, and Marin Soljačić. 2020. Integration of neural network-based symbolic
regression in deep learning for scientific discovery. IEEE Transactions on Neural
Networks and Learning Systems (2020).

[23] Diederik P Kingma and Max Welling. 2013. Auto-encoding variational bayes.

arXiv preprint arXiv:1312.6114 (2013).

[24] Michael F Korns. 2011. Accuracy in symbolic regression. In Genetic Programming

Theory and Practice IX. Springer, 129–151.

[25] Michael F Korns. 2013. A baseline symbolic regression algorithm. In Genetic

Programming Theory and Practice X. Springer, 117–137.

[26] Koza and John R. 1994. Genetic Programming as a Means for Programming
Computers by Natural Selection. Statistics and Computing 4, 2 (June 1994), 87–
112.

[27] Krzysztof Krawiec. 2002. Genetic programming-based construction of features
for machine learning and knowledge discovery tasks. Genetic Programming and
Evolvable Machines 3, 4 (2002), 329–343.

[28] Matt J Kusner, Brooks Paige, and José Miguel Hernández-Lobato. 2017. Grammar
variational autoencoder. In International Conference on Machine Learning. PMLR,
1945–1954.

[29] William La Cava and Jason Moore. 2017. A General Feature Engineering Wrapper
for Machine Learning Using 𝜖-Lexicase Survival. In European Conference on
Genetic Programming. Springer, 80–95.

[30] Yann LeCun, Yoshua Bengio, and Geoffrey Hinton. 2015. Deep learning. nature

521, 7553 (2015), 436–444.

[31] Qiang Lu, Shuo Zhou, Fan Tao, Jake Luo, and Zhiguang Wang. 2021. Enhancing
gene expression programming based on space partition and jump for symbolic
regression. Information Sciences 547 (2021), 553–567.

[45] Leonardo Trujillo, Luis Muñoz, Edgar Galván-López, and Sara Silva. 2016. neat
genetic programming: Controlling bloat naturally. Information Sciences 333 (2016),
21–43.

[46] Silviu-Marian Udrescu, Andrew Tan, Jiahai Feng, Orisvaldo Neto, Tailin Wu,
and Max Tegmark. 2020. AI Feynman 2.0: Pareto-optimal symbolic regression
exploiting graph modularity. arXiv preprint arXiv:2006.10782 (2020).

[47] Silviu-Marian Udrescu and Max Tegmark. 2020. AI Feynman: A physics-inspired
method for symbolic regression. Science Advances 6, 16 (2020), eaay2631.
[48] Nguyen Quang Uy, Nguyen Xuan Hoai, Michael O’Neill, Robert I McKay, and
Edgar Galván-López. 2011. Semantically-based crossover in genetic program-
ming: application to real-valued symbolic regression. Genetic Programming and
Evolvable Machines 12, 2 (2011), 91–119.

[49] Ekaterina J Vladislavleva, Guido F Smits, and Dick Den Hertog. 2008. Order
of nonlinearity as a complexity measure for models generated by symbolic
regression via pareto genetic programming. IEEE Transactions on Evolutionary
Computation 13, 2 (2008), 333–349.

[50] Sanford Weisberg. 2005. Applied linear regression. Vol. 528. John Wiley & Sons.
[51] Tony Worm and Kenneth Chiu. 2013. Prioritized grammar enumeration: symbolic
regression by dynamic programming. In Proceedings of the 15th annual conference
on Genetic and evolutionary computation. 1021–1028.

[52] Hengrui Xing, Ansaf Salleb-Aouissi, and Nakul Verma. 2021. Automated Sym-
bolic Law Discovery: A Computer Vision Approach. In Proceedings of the AAAI
Conference on Artificial Intelligence, Vol. 35. 660–668.

[53] Jinghui Zhong, Yusen Lin, Chengyu Lu, and Zhixing Huang. 2018. A deep learn-
ing assisted gene expression programming framework for symbolic regression
problems. In International Conference on Neural Information Processing. Springer,
530–541.

