Fitted Q-Learning for Relational Domains

Srijita Das1 , Sriraam Natarajan1 , Kaushik Roy1 , Ronald Parr2 , Kristian Kersting3
1Department of Computer Science, The University of Texas at Dallas, USA
2Department of Computer Science, Duke University, USA
3Department of Computer Science and Centre for Cognitive Science, TU Darmstadt, Germany
{Srijita.Das, Sriraam.Natarajan, Kaushik.Roy}@utdallas.edu,
parr@cs.duke.edu, kersting@cs.tu-darmstadt.de

0
2
0
2

n
u
J

0
1

]

G
L
.
s
c
[

1
v
5
9
5
5
0
.
6
0
0
2
:
v
i
X
r
a

Abstract

We consider the problem of Approximate Dynamic Program-
ming in relational domains.
Inspired by the success of ﬁt-
ted Q-learning methods in propositional settings, we develop
the ﬁrst relational ﬁtted Q-learning algorithms by represent-
ing the value function and Bellman residuals. When we ﬁt
the Q-functions, we show how the two steps of Bellman op-
erator; application and projection steps can be performed us-
ing a gradient-boosting technique. Our proposed framework
performs reasonably well on standard domains without using
domain models and using fewer training trajectories.

1

Introduction

Value function approximation in Reinforcement Learning
(RL) has long been viewed using the lens of feature dis-
covery (Parr et al. 2007). A set of classical approaches
for this problem based on Approximate Dynamic Program-
ming (ADP) is the ﬁtted value iteration algorithm (Boyan
and Moore 1995; Ernst, Geurts, and Wehenkel 2005; Ried-
miller 2005), a batch mode approximation scheme that em-
ploys function approximators in each iteration to represent
the value estimates. Another popular class of methods that
address this problem is Bellman error based methods (Men-
ache, Mannor, and Shimkin 2005; Keller, Mannor, and Pre-
cup 2006; Parr et al. 2007). The key intuition is that the
Bellman error has positive dot product with the true value
function and, thus, adding basis functions based upon the
Bellman error can lead to a good approximation to the true
value function.

Here, we consider relational domains that are typically
described using parameterized state-action spaces. While
it is conceivable to instantiate each object and construct a
grounded MDP, given the variable number of objects, this
can yield substantially large state-action spaces that ren-
der solving the grounded MDP intractable in practice. On
the other hand, as noted by Tadepalli et al. (2004), typical
function approximators do not generalize well when applied
to relational domains. Consequently, a class of RL meth-
ods, called Relational Markov Decision Process (RMDPs),
have been developed for learning optimal behaviour in these
worlds, and methods that directly learn and reason at the
ﬁrst-order level have been developed in the broad area
of Relational Reinforcement Learning (RRL) (Price and
Boutilier 2001; Sanner and Boutilier 2009; Wang, Joshi,

and Khardon 2008; Tadepalli, Givan, and Driessens 2004;
Wu and Givan 2007). While speciﬁc methodologies differ,
most of these methods operate at a symbolic level and de-
ﬁne the mathematical operations on these symbols to learn
the values of the parameterized states (which can essentially
be viewed as a “group” of states in classical RL). Most of
these methods, however, are exact methods. A notable ex-
ception is by Guestrin et al. (2003), who developed approxi-
mate learning for RMDPs by representing and learning value
functions in a stage-wise manner.

Inspired by the success of approximate value function
learning for propositional domains, we propose the ﬁrst set
of approximate Q-value function learning methods for
relational domains. We take two speciﬁc approaches – ﬁrst
is to represent the lifted Q-value functions and the second
is to represent the Bellman residuals – both using a set of
relational regression trees (RRTs) (Blockeel and De Raedt
1998). A key aspect of our approach is that it is model-free,
which most of the RMDP algorithms assume. The only ex-
ception is Fern et al. (2006), who directly learn in policy
space. Our work differs from their work in that we directly
learn value functions and eventually policies from them
and adapt the most recently successful relational gradient-
boosting (RFGB) (Natarajan et al. 2014), which has been
shown to outperform learning relational rules one by one.

Our work can be seen as learning functions over re-
lational domains that permit the efﬁcient combination of
these functions without explicitly considering the entire
space of models. Wu and Givan (2007) approximate the
value function by using beam search with relational fea-
tures that are iteratively learned from sampled trajectories.
Our approach uses gradient boosting where we learn sets
of conjunctive features as paths from the root to the leaf
of each RRT and lift the arguments of ﬁtted Q-learning in
propositional domains (Ernst, Geurts, and Wehenkel 2005;
Tosatto et al. 2017) to relational domains.
Indeed, if we
knew that the target Q function belongs to a speciﬁc class
and use this information to model the value function there
is no need of trees and boosting. However, in relational do-
mains this information is almost never available: without dif-
ﬁcult feature engineering, the shape of the value function is
almost always unknown – a reason why some work directly
operated at the policy level (Fern, Yoon, and Givan 2006;
Kersting and Driessens 2008).

 
 
 
 
 
 
representable value functions considered by the hypothesis
class of a function approximator. A projection operator Π is
used to project the true value function to the representable
subspace of function represented by the approximator. The
Bellman error is the expected difference between value esti-
mates from successor states and current state: BE(s, a) =

(cid:32)

(cid:88)

s(cid:48)

P (s(cid:48)|s, a)[R + γ max

a(cid:48)

Q(s(cid:48), a(cid:48))]

− Q(s, a)

(2)

(cid:33)

The estimate Q(s, a), which is an approximation of the true
function, is the projected parameterised Q function in the
representable function space. The empirical Bellman opera-
tor T ∗ : R|S|×|A| → R|S|×|A| is the ﬁrst term in the above
equation with sampled next states rather than an explicit ex-
pectation. The empirical Bellman error can be deﬁned as
T ∗Q(s, a)−Q(s, a). Applying the Bellman operator to a Q-
function in a representable subspace may result in a Q func-
tion in a different subspace, necessitating projecting back to
the representable subspace using a projection operator Π.

Approximate Dynamic Programming (ADP): For large
domains, approximate methods can be used to estimate the
Q-function so that the function need not be stored for every
state-action pair. Some of the popular approaches for Q-
function (or value function) approximation in propositional
domains like Least Squares Temporal Difference (LSTD)
Learning (Boyan 1999), Least Squares Policy Evaluation
(LSPE) (Yu and Bertsekas 2009) and Least Sqaure Policy
iteration (LSPI) (Lagoudakis and Parr 2003) approximate
the Q-function as linear function of the parameter vector
i.e: ˆQ(s, a) = w · φ where w is the parameter of the Q-
function and φ is the feature vector representing the state
space. These features are also called basis functions and are
ideally linearly independent of each other. Our work can
be seen as extending this line of work by approximating
the Q-functions and/or the Bellman residuals using a non-
parameteric relational representations.

The ADP framework is a collection of RL methods where
the values or policies are approximated using information
from samples. LSTD, for example, uses a least squares ap-
proximation to the temporal difference learning paradigm.
The main component of ADP approaches such as LSTD
is the computation of weights for the approximation of the
value function. In relational domains, groups of states are
typically indistinguishable w.r.t. the values that they assume
allow parameter sharing. For example, in a blocks world,
many conﬁgurations could have similar ground state values
as they exhibit similar properties such as similar towers etc.
Consequently, it is possible to learn a lifted representation
such as the one by Wu and Givan (Wu and Givan 2007) that
can reason over sets of feature values.

Fitted-Q learning: Fitted Q-learning (Ernst, Geurts, and
Wehenkel 2005) is a form of ADP which approximates the
Q-function by breaking down the problem into a series of re-
gression tasks. Hence, each iteration of Fitted-Q iteration is
similar to essentially solving a supervised regression prob-
lem. At every iteration of Fitted-Q iteration, the empirical
Bellman operator is applied to the current Q-function ap-
proximation. Each Regression model then tries to ﬁnd the

Figure 1: Proposed framework for GBQL

More precisely, we make the following key contributions:
(1) We develop a uniﬁed framework for handling relational
RL problems by exploring the use of relational trees to
model the Q-values and Bellman residuals. (2) We outline
the connections between the boosted approach to the classi-
cal RL methods for value function approximation (Bellman
error, aggregate and tile coding methods). We show that our
method can be viewed as encompassing these different ap-
proximation techniques. (3) Finally, we demonstrate empir-
ically the effectiveness and the generalization ability of our
proposed approach where our results are on par with other
RMDP/planning methods without using domain models and
with fewer training trajectories. Without extensive feature
engineering, it is difﬁcult—if not impossible—to apply stan-
dard methods within relational domains in which there is a
varying number of objects and relations.

The rest of the paper is organized as follows. After in-
troducing the necessary background on RL, value function
approximation and relational learning in the next section, we
outline the algorithm and analyze its properties. Before con-
cluding and presenting future work, we present the empirical
evaluation of the proposed approach on three classical Rela-
tional RL domains.

2 Background
Markov Decision Processes (MDPs): An MDP is de-
scribed by a tuple (S, A, R, P, γ) where S is the state space,
A is the action space, R is the reward function,P is the tran-
sition probability deﬁned as P : S × A → [0, 1]. For inﬁnite
horizon problems, a discount factor γ ∈ [0, 1) is speciﬁed
to trade-off between current and future reward. In state st,
after taking action at, the agent receives a reward Rt ∼ R.
A policy π is a mapping from S to a probability distribution
over action-space A given a state. The optimal Q-value (ex-
pected reward) of a particular state action pair is given by
the Bellman optimality equation:
(cid:88)

P (s(cid:48)|s, a)[R + γ max

Q∗(s(cid:48), a(cid:48))]

Q∗(s, a) =

(1)

s(cid:48)

a(cid:48)

Bellman Error: For a ﬁxed policy π, the true Q function
Qπ can be complex and might not lie in the subspace of

best parameters to minimize the regression error. The Q-
functions learned by such regression models lie in a sub-
space of all functions represented by the regression model
and hence are an approximation of the true function.

We employ Functional Gradient Boosting (Friedman
2001) in relational domains (Getoor 2007; De Raedt et al.
2016) to capture the Bellman error for every Q-learning it-
eration and obtain lifted basis functions in a non-parametric
fashion. In domains where we require probabilistic policies,
a Gibbs distribution over the values can be used to model
probabilistic action choices. While it is conceivable to learn
policies directly as performed by policy gradient approach
of Kersting and Driessens (2008) or imitation learning by
Natarajan et al. (2011), our methods approximate the Q-
values or the Bellman error using gradient boosting.

Tree-based RRL: Our work is inspired by Dzeroski et
al. (2001) on learning single regression tree for RRL. This
work was later extended by others (Driessens and Ramon
2003; Driessens and Dˇzeroski 2004; Driessens, Ramon,
and Blockeel 2001; G¨artner, Driessens, and Ramon 2003)
w.r.t building incremental RRTs, providing guidance to the
learner and regression algorithms using kernels and gaus-
sian processes. However, our work is different in two key
aspects: (1) We are more sample efﬁcient in that we do learn
only from a smaller set of sampled trajectories in each itera-
tion while their methods use all the trajectories when learn-
ing the Q function, and (2) we adapt multiple stage wise
grown boosted RRTs for Q function approximation in two
different ways as discussed later.

3 Gradient Boosted Fitted Q-learning
Set up: We consider learning to act in relational, discrete,
noisy domains where the domains consist of multiple inter-
acting objects. We adopt the RMDP deﬁnition of Fern et
al. (Fern, Yoon, and Givan 2006), where S and A of the
original MDPs are represented by a set of objects O, a set of
predicates P and set of action types Y. As with their deﬁni-
tion, we use facts to denote a predicate grounded with a spe-
ciﬁc instantiation. For example on(a, b) is a grounding of a
predicate on(X, Y ). Thus a set of ground facts will then de-
ﬁne the state of the MDP and S is the set of all the possible
facts in the domain. We make a closed-world assumption,
in that facts that are not observed are assumed to be false.
Similarly, the action is a grounded action type. For exam-
ple pickup(a) is an action which is obtained by grounding
pickup(A) with A = a.

the goal

Given this problem deﬁnition,

is to learn
Q(s, a), ∀s, a. However, the learning occurs at a symbolic
representation, i.e., we learn Q(X, A) for all the objects (or
partial instantiations of the objects X) and the action types
A. Consequently, the learned representation is a lifted one
while the training examples/observations are at the propo-
sitional level. To represent these lifted representations, as
mentioned earlier, we use RFGB (Natarajan et al. 2014;
Natarajan et al. 2012; Natarajan et al. 2011) and a single
tree, TILDE (Blockeel and De Raedt 1998), for approximat-
ing the Q-value functions.

The key idea in RFGB is that like its propositional coun-
terpart, a functional representation is used to model the

Q-function values. The gradients are obtained w.r.t.
this
function and are approximated using regression functions at
In relational domains,
each step of gradient computation.
these regression functions are Relational Regression Trees
(RRTs) (Blockeel and De Raedt 1998).
In this work, we
consider three types of Q-value function approximations –
single relational tree, and two variants of boosted relational
trees.

Boosted Regression Trees for Gradients: During learn-
ing, in each iteration of RFGB, gradients are computed for
each training example w.r.t the loss function and an RRT is
learned at each gradient step to ﬁt to these gradients from
previous iterations. The intuition is that the direction of
these approximately learned gradients is similar to the orig-
inal gradients. Given a set of positive examples and poten-
tially some negative examples (in some cases, these are com-
puted using closed-world assumption), the goal is to ﬁt a
function F as a set of relational regression trees. While pre-
viously this idea had been employed in the context of rela-
tional classiﬁcation (Natarajan et al. 2012; Khot et al. 2011;
Ramanan et al. 2018), the use of RFGB for value function
approximation, requires extending them to regression.

In the context of regression, a typical loss function used
is the squared error. The squared error with respect to a sin-
gle example (xk, yk) is l(xk, yk) = (yk − F (xk))2, where
yk is the true (regression) value and F (xk) is the value es-
timated by the regression function F . The (functional) gra-
dient of an example xk at the end of m iterations is, ∆k
m =
∂l(xk,yk)
∂F:m−1(xk) = yk − F:m−1(xk), where F:m−1 denotes the
sum of all the gradients computed through the mth itera-
tion of relational functional gradient boosting. Since we
are in a functional space, the gradients are calculated with
respect to the function F and not the parameters. The ﬁ-
nal regression function F after m rounds of boosting is
Fm = F0 + ∆1 + ∆2 + · · · + ∆m.

In our case, yk is the Q value of the current state-action
pair (sk, ak) 1 after applying the empirical Bellman opera-
tor T ∗ and F is the Q-value for the current state-action pair
as approximated by the model Fm. xk in the above equa-
tion corresponds to all the relevant features of the current
state sk. Recall that in relational domains, for the same set
of predicates, different states could have different number
of instantiated (grounded) features. For instance, the pred-
icate on(X, table) can yield different number of blocks in
different states. RFGB employs RRTs to lift the represen-
tation such that it is independent of the number of ground
instances. To account for this, we redeﬁne the loss function
as,

l(s, a) =

(cid:88)

(s,a)∈τ

(ˆu(s, a) − ˆQ(s, a))2

(3)

where ˆu(s, a) is the point wise regression value which gets
ﬁtted to the new model. τ refers to the set of sampled train-
ing trajectories.

1We use i to denote the Q-learning iterations, k to denote the
example index (state-action pairs) and m to denote the boosting
iterations from here on.

Algorithm 2 TreeBoost learning
1: function TREEBOOST(E,M )
2:
3:
4:

for 1 ≤ m < M do

Initialize : Set F0:=LEARNRRT(E)

(cid:46) Learn relational regression tree to ﬁt ˆu(s, a)
(cid:46) Iterate through M gradient

steps

5:
6:

7:

Fm := Fm−1
§i=GENGRADIENTS(E,Fm,A)

(cid:46) Compute

gradients, for action ai ∈ A

∆m=LEARNRRT(E,§i)

(cid:46) Learn relational

regression tree to ﬁt the gradients §i

Fm := Fm + ∆m

8:
end for
9:
return FM
10:
11: end function

satisﬁed and the right branch is when it does not hold. The
root node checks if a truck B is in the destination city D at
the current state. This state will have the highest Q-value.
The leaf values denote the Q value of the state-action pair
that satisfy any particular path. Note that all the states and
actions in this Figure are lifted i.e., parameterized. In the
general case, these could be partially grounded, for instance
TruckIn(A,Paris,E). RFGB can learn at the fully lifted level,
partially instantiated level or the ground level based on the
language bias provided during learning.

With RRTs for computing gradients at hand, we now
present
the algorithm for learning the approximate Q-
functions of relational MDPs using RFGB. Speciﬁcally,
Algs 1 and 2 present the outline of our proposed approach,
called Relational Gradient-Boosted Q- Learning (GBQL).
GBQL takes as input the number of Q-learning iterations
N, the number of iterations for basis function computation
M, the number of training trajectories for each iteration of
Q-learning p and an access to the domain simulator ρ (a
setting similar to that of Parr et al. (2007)). At each iter-
ation a set of trajectories τ are sampled from the simula-
tor ρ. The relational simulator ρ takes as input the current
state st and action at at time step t and returns the next rela-
tional state st+1. For every (st, at) pair, the simulator also

Figure 2: An example Relational Regression Tree representing the
structure of the Q-function for Unload action on Logistics domain.

Algorithm 1 GBQL learning
1: function GBQL(N ,M ,p,ρ)
Initialize : Set ˆQ0 := 0
2:
for 1 ≤ i ≤ N do
3:
E := {∅}
4:
for 1 ≤ j ≤ p do
5:
6:
7:
8:
9:
10:
11:
12:
13:

end for
for 1 ≤ k ≤ |D| do

s0 ∼ P (S)

(cid:46) # of Q-learning iterations
(cid:46) Stores tuple (sk, ak, ˆu(sk, ak))

(cid:46) generate mini batch of trajectories

(cid:46) Choose s0 from initial state distribution
Generate τj starting from s0 by accessing ρ

(cid:46) Iterate over all (sk, ak, sk+1) in τ

ˆu(sk, ak) := (1 − α) ˆQ:i−1(sk, ak)

+α[R + γ maxa(cid:48) ˆQ:i−1(sk+1, a(cid:48))]

E = E ∪ {sk, ak, ˆu(sk, ak)}

end for
ˆQi = TREEBOOST(E, M )

14:
15:
16:
end for
17:
return ˆQN
18:
19: end function

Thus, the goal is to minimize the difference between the
regression value of the current state-action pair (empirical
value) and the current Q-value according to the model. For
every lifted state-action pair (sk, ak), ˆu(sk, ak) referred
in (3) is obtained by applying the Bellman operator,

ˆu(sk, ak) = (1 − α) ˆQ:i−1(sk, ak)

+ α[R + γ maxa(cid:48) ˆQ:i−1(sk+1, a(cid:48))]

(4)

α is a learning rate and ˆQ:i−1(sk, ak) is the Q-value of
(sk, ak) as returned by RFGB through the (i − 1)st Q-
iteration, sk+1 refers to the successor state of sk in the sam-
ple. The learning rate α is set close to 1 so that the previ-
ous estimates of the current state-action values have a small
contribution to the new estimate. At each boosting iteration
m, every training example k includes a gradient ∆k
i:m and a
new RRT is trained to ﬁt these ∆k
i:m
is computed as,

i:m, ∀i. The gradient ∆k

∆k

i:m = ˆu(sk, ak) − ˆQm−1:i(sk, ak),

(5)

where

i:2 + . . . + ∆k

ˆQm−1:i(sk, ak) = ∆k

i:1 + ∆k
ˆQm−1:i is the Q value after i iterations of Q-learning and
m − 1 iterations of boosting. The ﬁnal regression value over
a lifted state-action pair (sk, ak) is the sum of regression
values after all M rounds of boosting: ˆQ:i(sk, ak) =

i:m−1

(6)

i:2 + . . . + ∆k

ˆQM :i(sk, ak) = ∆k

i:1 + ∆k
The ﬁnal Q-function, after N Q-iterations, is ˆQ:N , and it
deﬁnes a value for each lifted state as a sum of M gradients.
An example of a RRT learned in the logistics domain is
shown in Fig. 2, where the inner nodes represent a ﬁrst order
conjunction (test). The left branch indicates that the test is

(7)

i:M

returns a reward function Rt+1 which is designed accord-
ing to the problem being solved. At every Q-learning iter-
ation, p mini batches of trajectory τ1, τ2, · · · τp are sampled
from the simulator. A relational trajectory τi is deﬁned by
a sequence of relational facts and actions taken over a se-
quence of time steps until a ﬁxed predeﬁned goal is reached,
i.e τi = {(s0, a0), (s1, a1), · · · (sg, .)} where sg is the goal
state. The initial state s0 is chosen from an initial state dis-
tribution P (S). For every (cid:104)state, action, nextstate(cid:105) tuple
in the trajectory ( such tuples in every iteration is appended
to a set D) , the value for the current state-action pair is
updated using the Bellman operator (line 13). Next, every
state-action pair and its corresponding q-value after applying
Bellman operator are added to the training set for a function
call to the TREEBOOST algorithm (lines 14 − 16).

For every (cid:104)state, action, value(cid:105) tuple in the data set E,
the goal is to learn a set of RRTs to approximate the Q-values
compactly. In our case, these correspond to ﬁnding the com-
binations of the set of (relational) features that best approx-
imate the value of the current state-action pair. Note that
in each iteration of the TREEBOOST procedure (indexed by
m), a single regression tree is learned and added to the ini-
tial model (line 2). The LEARNRRT function takes the ex-
amples and the initial q-values ˆu(s, a) as input and learns
a single RRT. An RRT is learnt over relational features by
scoring each test node (we use weighted variance as scoring
function) and choosing the best node to split. In the next
boosting iteration, the regression value is updated with the
difference between the original value ˆu(s, a) and the value
returned by the current set of trees as shown in (5) – func-
tion call to GENGRADIENTS in line 6. The key here is that
TREEBOOST is essentially performing a series of gradient
steps to best ﬁt the Q value of each state-action pair accord-
ing to the sampled training set. Each tree corresponds to a
single gradient in that direction, and the ﬁnal value is the
sum of all the values from the different regression trees as
shown in (7). Hence, each call to TREEBOOST returns sin-
gle set of regression trees for every lifted action type in A.

Now, in the main GBQL procedure, the set of trees (Q-
function) learned in the previous iteration are used to update
the Q value of state action pair at the current iteration while
applying the Bellman operator. To generate the next set of
trajectories for the next iteration from the simulator ρ, we
follow an (cid:15)-greedy policy where we choose a random action
with a probability (cid:15) and the best action with respect to the
current Q-function estimates with probability (1 − (cid:15)) for a
given state. Figure 1 shows how the simulator ρ is integrated
with the GBQL framework.

These set of learned regression trees at any iteration are
the (relational) basis functions for that iteration. One could
also not boost the trees but directly ﬁt a single RRT to the
q-values. These form the two different methods for ﬁtted-q
as shown in Fig. 4.

Single Regression Tree for Bellman Residuals: We
adapt the work of Tosatto et al. (2017) for relational do-
mains and present an alternate method of boosting. Fig. 3
presents an overview of our proposed approach, which we
call Relational Boosted Fitted-Q (RBFQ). We explicitly
calculate the Bellman residual o(sk, ak) from samples in ev-

Figure 3: Boosted RBFQ Q-function representations for ﬁtting
Bellman error.

ery iteration i of Q-learning as, o(sk, ak) =

[R + γ max

a(cid:48)

ˆQ:i−1(sk+1, a(cid:48))] − ˆQ:i−1(sk, ak)

(8)

where ˆQ:i−1(sk, ak) is the Q-value of (sk, ak) as returned
by RBFQ through the (i − 1)st Q-iteration and is deﬁned as

ˆQ:i−1(sk, ak) =

i−1
(cid:88)

j=1

ˆQj(sk, ak)

(9)

ˆQj(sk, ak) is the Q-value of (sk, ak) as returned by the jth
Q-iteration. o(sk, ak) in Equation 8 is equivalent to the Bell-
man error estimate deﬁned in Equation 2 except that instead
of expected Bellman error over all possible successor states
sampled from the underlying transition function, this is cal-
culated directly from the sample. We compute the Bellman
residual o(sk, ak) for each state-action pair in the trajectory
set and ﬁt a single weak RRT. The representation learnt for
the Bellman residual is a lifted representation where every
inner node of the RRT contains conjunction of ﬁrst order
logic predicate and each leaf node contains the approxi-
mated Q-value of sets of state-action pair that satisﬁes the
test conditions along a branch. For Q-learning iteration i,
the learnt Q-function is an additive one over all the previous
Q-functions approximated so far as in Equation 9.

Note that while RBFQ algorithm is similar in spirit to
GBQL, there are several key differences. While in GBQL,
we apply the Bellman operator T ∗ and learn the ﬁrst RRT
in every Q iteration, here,we calculate the Bellman resid-
ual (T ∗Q − Q) and learn the RRTs. The Bellman residu-
als can be seen as the gradients ∆m for GBQL, however,
these gradients are learnt in different Q-learning iterations
unlike GBQL. Another key difference is that in GBQL, in
every Q-learning iteration, the Bellman operator is applied
once and then the gradients are ﬁtted by a series of Gradient
Boosted RRTs in the same iteration. However in RBFQ, in
every iteration, an RRT is learnt for Bellman residual and
in subsequent Q learning iterations, an additive model over
all the previously learnt Q-functions are considered for cal-
culating the Bellman residual. We hypothesize that directly
ﬁtting the Bellman residuals can lead to better ﬁts in some
important states, approximating the Q-values could result in
an improvements on the entire state space on an average.
We verify this hypothesis empirically.

Figure 4: Boosted GBQL and non-boosted (RRT) Q-function representations for ﬁtting Bellman error.

4 Relation to Classical ADP Approaches
Aggregate approaches group (cluster) states and learn values
over these clusters. For instance, let S = {s1, ..., sn} denote
the set of states and C = {C1, ..., CR} the clusters. Then the
value of a state is calculated as, V (s) = (cid:80)
i βi · I(s ∈ Ci)
where βi is the weight on the cluster. In our method, the
grouping is obtained naturally. Each path from root to leaf
is a ﬁrst-order logic clause which is a lifted representation of
the ground states. βi can be viewed as the weights learned
in the leaves of each branch of a tree. Since each state only
satisﬁes one path, each tree will yield only one β for a state.
A key advantage of GBQL over the aggregate features is
that in the latter, the transition function of one state from a
cluster to another P (Ci(s)|Cj(s), a) is not easy to compute
and need to be designed carefully, a problem that is avoided
in our model-free setting.

It is possible to view our GBQL procedure as a projection
into a space of piecewise-constant value functions, but such
value functions have limited representational power. One
way to get greater representational power would be to keep
trees or entire Q-functions from previous iterations. Previ-
ous Q-functions would now become basis vectors and Q-
function approximation could be used to combine these ba-
sis vectors to form a new Q-function. We will explore this
connection in the future. Currently, we discard the trees
from the previous iteration for efﬁciency and scalability to
large relational tasks in GBQL.

Indeed, a related method for solving ADP is that of tile-
coding (Whiteson et al. 2007), a linear piece-wise approxi-
mator that partitions the state space into (potentially overlap-
ping) regions called tiles. These are essentially axis-parallel
hyper-cuboids learned from the original state space.
It is
easy to see that our method can be considered as learning
these tiles since each tree can be considered as deﬁning a
tile in the original space. While the original method (Albus
1981) also used Bellman error to identify the tiles, it was a
heuristic based method. GBQL on the other hand, can be
viewed as performing a gradient descent in the Bellman er-
ror space (when viewed in a functional form).

Another direction related to our work is the recent work
on Deep RL. Deep Q networks (DQN), ﬁrst introduced by

Mnih et al. (2015) and later extended by others (Hausknecht
and Stone 2015; Van Hasselt, Guez, and Silver 2016;
Mnih et al. 2016; Anschel, Baram, and Shimkin 2017) can
also be seen as ﬁtted Q-iteration where the Q-functions are
approximated by Deep Neural networks. Similar to DQN
which uses a non-linear function approximator to estimate
the Q values, we use gradient boosted trees which are also
non-linear function approximators. The major difference be-
tween this line of work with ours is that while they operate
at propositional level and approximate the Q-values of every
state action pair encountered, we lift the Q-functions to the
relational setting where the gradient boosted ﬁrst order trees
are used to capture the structure of the domain. Recently,
Zambaldi et al. (2019) proposed to use attention mechanism
to capture the interactions between the various entities in the
domain. While this work captures the relation existing in
structured domain, they are implicitly captured by the atten-
tion aware Neural network architecture (Santoro et al. 2018)
and therefore relations are not speciﬁed before learning. We
on the other hand, employ a symbolic representation that
speciﬁes relationships between entities through expressive
ﬁrst order logic predicates explicitly. Thus we allow for en-
coding domain and common sense knowledge in a meaning-
ful way. Finally, Jiang et al. (2019) used symbolic methods
with Neural networks by using differentiable ILP which can
directly feed in as a differentiable function to Neural net-
works. While they use policy gradient and operate in policy
space, we use lifted representation in the Q-function space
and non-differentiable ILP to capture symmetries existing in
the state space.

5 Experimental Evaluation
We evaluated our proposed GBQL and RBFQ algorithms
on tasks from the well known Blocks-world domain and
the Logistics domain. These domains are rich in structure
and are in general considered challenging to many plan-
ning/learning algorithms. Unlike several known algorithms,
ours is a model-free algorithm that can potentially learn from
a small number of trajectories/instances. To test for general-
ization, we vary the number of objects between training and
testing.

(a) Stack

(b) Unstack

(c) On

(d) Logistics

Figure 5: Mean absolute Bellman training error for different RRL domains

(a) Stack

(b) Unstack

(c) On

(d) Logistics

Figure 6: Average cumulative reward as a function of the number of Q-learning instances. Higher is better.

Through the evaluation, we aim to answer the following

questions explicitly:
Q1: How does the training error (Bellman residual) vary

w.r.t the number of iterations?

Q2: How does the test set reward change over time?
Q3: How does the performance vary with a differing num-
ber of objects during testing (i.e., generalization per-
formance)?

Q4: How does GBQL and RBFQ compare against each

other?

To this effect, we developed a strong baseline. Speciﬁcally,
we replace the gradient-boosting of ﬁtted Q-values with a
single relational tree (RRT). This is to say that in line 16
of the GBQL algorithm, we replace the function call to the
boosting algorithm with a function call to a single relational
tree learner. Before we explain the experimental baseline,
we present the tasks.

1. Blocks World (Stack task): The blocks world do-
main (Slaney and Thi´ebaux 2001) consists of blocks
stacked on top of each other to form towers. The goal
of the agent in this task is to stack all the blocks on a
single tower. The initial state consists of a random con-
ﬁguration of the blocks on the ﬂoor. The state representa-
tion for this task consists of predicates like: clear, On,
heightlessthan, isFloor etc. The action pred-
icate in this domain is move and the agent learns to
move a block from one tower to another to build a sin-
gle tower. The reward function was set to +2 for the goal
and −(1/Hmax) for the intermediate steps, where Hmax
refers to the height of the highest tower in a state. The
intuition is that conﬁgurations closer to the goal state will

get a higher reward.We trained the agent on problems with
3, 4 and 5 number of blocks and tested the policy learnt on
problems containing 6 and 7 blocks to demonstrate gen-
eralization ability.

2. Blocks World (Unstack task): The Unstack task is an-
other subproblem in the blocks world domain where the
goal of the agent is to unstack all the blocks on the ﬂoor.
Similar to stack task, the initial state consists of a random
conﬁguration of blocks on the ﬂoor. The number of predi-
cate is the same and the action predicate for this domain is
move where the agent can move a block from one tower
to another or to the ﬂoor. The reward function is +10 for
the goal and −(1 − Si) for the intermediate steps where
Si refers to the fraction of blocks on ﬂoor in the current
state. Reaching the goal conﬁguration is more difﬁcult
than the stacking task, hence the reward for the goal state
is set to a higher value. The intuition behind the interme-
diate reward is that the states where a higher fraction of
blocks are on the ﬂoor are closer to goal and hence should
be penalized less. For this domain, we train the agent on
4, 5 and 6 blocks and test the policy learnt on problems
containing 7 blocks.

3. Blocks World (ON task): The goal of the agent is to
stack a speciﬁc block on top of another block. This prob-
lem is comparatively difﬁcult because the optimal pol-
icy here is hierarchical in nature and the order of the
subgoals needs to be learnt. For example, in order to
move a block on top of another block, (1) both the blocks
should be clear (2) the upper block should be moved on
top of the target block. The state consists of predicates
like clear, on, sametower, isFloor, goalon etc.
The goalon predicate is used to represent the goal state;

goalon(b1,b2) means that the goal is to put block b2
on top of b1. The action predicate is move where the
agent can move a block on top of another block or on the
ﬂoor. The reward is +10 for the goal state. For the inter-
mediate states, a small negative reward is provided when a
block is moved from a different tower than the goal tower.
This is because blocks should be moved from the towers
containing the goal blocks in order to make them clear.
We train the agent on 4 blocks and test the policy learnt
on problems containing 5, 6 and 7 blocks.

4. Logistics:

This

another

classical domain in
is
RRL (Boutilier, Reiter, and Price 2001).
This do-
main consists of entities like trucks, boxes and cities. The
trucks can move from one city to another. The goal of
the agent for this task is to unload at least one box in the
destination city. The initial state consists of a random
conﬁguration of trucks and boxes in all the cities except
for the destination city. The state consists of predicates
like: boxOn, truckIn, boxIn, destination etc.
The actions include the following target predicates:
load, unload and move. The reward function is +1
for the goal and −0.2 for the intermediate steps. We
train the agent on problems containing 5 cities, 3 trucks
and 3 boxes. We evaluate the learnt policy on problems
containing 7 cities, 3 trucks and 5 boxes.

Evaluation Methodology: In every iteration of GBQL
and RBFQ, we sampled 5 trajectories from a random initial
state and test the Q-function learnt by executing the policy
greedily on a random 10 test trajectories. To keep the eval-
uation fair, we varied the number of objects between train
and test trajectories as mentioned earlier for each task. Each
of the training and test trajectories is initialized by a ran-
dom initial state sampled from the initial state distribution
of the domain. All the experiments are averaged over 10
runs. In subsequent Q-learning iterations, we sample trajec-
tories from the simulator using (cid:15)-greedy policy and the (cid:15) is
decayed over time by a ﬁxed decay. For every domain, we
used 10% of sampling from the previous history also typi-
cally known as experience replay (Lin 1992) in RL litera-
ture. For GBQL, based on the performance on the training
trajectories, we chose the number of gradient boosted trees
at each iteration to be between 5 and 10.

Baselines: As mentioned earlier, we chose a single re-
gression tree (RRT) as the strong baseline. This RRT
baseline is similar to Dvzeroski et al.’s work (Dˇzeroski,
De Raedt, and Driessens 2001) with a key difference that
we approximate the Q-values by sampling trajectories from
the current policy as opposed to learning from entire expe-
rience. Comparison with Deep RL methods is out of scope
for this work as the goal is not necessarily to demonstrate the
usefulness of gradient-boosting as a function approximator
but to demonstrate the ability to incorporate symbolic repre-
sentations faithfully during learning. Also, as demonstrated
in several prior work on Statistical Realtional AI models (De
Raedt et al. 2016), constructing a ﬂat feature vector from a
symbolic structure to train a deep model can lead to loss of
information including auto-correlation and linkage (Jensen
and Neville 2002).

Domain
Stack
Unstack
On
Logistics

RRT
0.76(±0.19)
0.57(±0.32)
0.32(±0.22)
0.61(±0.21)

GBQL
0.82(±0.11)
0.79(±0.28)
0.24(±0.17)
0.8(±0.12)

RBFQ
0.78(±0.13)
0.79(±0.28)
0.24(±0.19)
0.84(±0.08)

Table 1: % goals reached on test trajectory by RRT, GBQL and
RBFQ after executing the learnt Q-function

Results: To answer Q1, it can be observed from the re-
sults reported in Figure 5 that the proposed GBQL and
RBFQ methods clearly demonstrate a decreasing Bellman
error as training progresses on the different tasks. For the
stacking task, the bellman error decreases almost uniformly
for both GBQL and RRT. For RBFQ, the mean absolute
bellman error reduces signiﬁcantly in the beginning but in-
creases with iterations and converges to almost the same
point as the other two algorithms. However, for the logis-
tics domain, it can be seen that GBQL converges faster than
RRT. For the unstack task, it can be seen that the error curve
for both GBQL and RRT follow the same shape and de-
creases steeply, however, the Bellman error for GBQL con-
verges faster than RRT.

For the unstack task, since it is a challenging one, we
injected a few expert trajectories instead of fully random
exploration in the early iterations. This can be a possible
reason for why the Bellman error decreases steeply for this
domain. However, induction of expert trajectories does not
have any effect on RBFQ. Also, it seems from the results
that inductive bias in the form of expert trajectories had more
impact on the gradient boosted GBQL model than RRT as
can be seen from the early convergence of GBQL. For the
ON task, bellman error for both GBQL and RRT follows
the same shape and converges, however, the bellman error
for RBFQ is quite high and does not reduce with increasing
iterations. This allows us to answer Q1 afﬁrmatively.

The average cumulative reward accumulated over the un-
seen test trajectories with varying number of objects is
shown in Figure 6. The average cumulative reward increases
in the early iterations and converges as can be seen from
the Figure 6(d) especially for logistics domain. Also, in the
logistics domain, the average reward for RBFQ converges
much faster than GBQL and RRT and exhibits less variance.
The cumulative reward for unstack task shows a high vari-
ance for both GBQL and RRT. We speculate that the reason
for this is the use of reward shaping which leads to higher
variance in this domain. However, in spite of this heuristic
being used for the Stacking task, the variance of Stack task is
lesser than that of Unstack task. This is because on average,
the length of test trajectory to reach the goal is higher for Un-
stack task than Stack task and thus, the higher variance. For
the ON task, GBQL and RRT converges much faster than
RBFQ; however, the cumulative reward collected by RBFQ
increases over time. The above discussions address the ques-
tion Q2 in that the average reward does increase over time.
To address the issue of generalization, we consider the
fraction of times that the goal is reached in all the tasks af-
ter 20-25 iterations of training in all the domains. Given

signiﬁcant time, all the methods will result in solving most
problems. Hence, we computed the percentage of goals
reached as the fraction of problems in which the solution
was achieved within a certain threshold of the optimal num-
ber of steps (2 more steps). As can be observed from Table 1,
GBQL and RBFQ achieves a better test set performance
than RRT across in 3 out of 4 tasks. This answers Q3 afﬁr-
matively in that better generalization is achieved across all
the domains by the proposed gradient boosted learning. Fi-
nally, it appears that from our experiments, RBFQ achieves
lower Bellman error on some critical states but has a higher
error across the states leading to an overall higher error. Our
immediate future direction is to investigate deeper the ques-
tion of whether directly approximating the Bellman error
with some guidance can lead to a better average reward. Cur-
rently, Q4 does not have a deﬁnitive answer. The results are
split between RBFQ and GBQL methods.

Our initial results demonstrate that both RBFQ and
GBQL cannot capture effective policies in a hierarchical do-
main like the ON task. In such a domain, RRT performs bet-
ter than the two boosted algorithms though the changes are
not statistically signiﬁcant. The Bellman error for RBFQ
increases sometimes like in the logistics domain unlike the
other two algorithms where it always decreases. This sug-
gests that since RBFQ derives it’s Q-function as a combi-
nation of all the basis function learnt so far, the projection
operation on the representable subspace of function is not
accurate, hence leading to increase in Bellman error. How-
ever, RBFQ is agnostic to inductive bias in the form of
expert (or even noisy) trajectories unlike the other two al-
gorithms as can be seen from Figure 5(b) of Unstack task
where there is a signiﬁcant reduction in Bellman error in
early iterations for GBQL and RRT. Also, average cumu-
lative reward on unseen trajectories shows a high variance
for Unstack task(Figure 6(b)) for GBQL and RRT; however
RBFQ is stable and shows lower variance suggesting that
RBFQ is stabler to complex reward functions given we use
reward shaping in this task to guide the intermediate steps.

6 Conclusion
We introduced Relational Approximate Dynamic Program-
ming (ADP) and presented the ﬁrst set of algorithms GBQL
and RBFQ that approximates the Q-values or the Bellman
error using a non-parameteric gradient-boosting method.
The intuition underlying these algorithms is that one can ap-
proximate the value function over a set of objects and rela-
tions as a set of RRTs learned in a sequential manner. The
Bellman operator application step corresponds to the eval-
uation of these trees for a given state action pair and the
projection step corresponds to the learning of these trees us-
ing gradient-boosting. Our experiments clearly demonstrate
the effectiveness of this approach in factored state space.
Most importantly, gradient boosting paves the way to deal
jointly with propositional and relational features; one only
has to adapt the gradient regression examples correspond-
ingly. We also demonstrated the generalization ability of the
algorithms with our empirical evaluation for intra-domain
transfer learning.

These initial results suggest several interesting avenues

for future work. First is evaluating the algorithm on larger
problems with hybrid tasks. Second is exploring various
sampling strategies in GBQL for picking trajectories from
current policy. Third is extending our work to generalized
continuous state-action spaces, multi-agent settings and po-
tentially Partially Observable Markov Decision Processes
(POMDPs). Next is understanding how rich human inputs
can be used to guide the algorithms. Since we are in a sym-
bolic setting, it must be possible for the human to directly
provide advice to the system at a high-level. Exploring the
use of such knowledge in the context of effective learning
remains an interesting direction. Finally, an effective com-
bination of policy gradient and ﬁtted VI methods needs to
be explored.

Acknowledgements
SN, SD & RP gratefully acknowledge the support of NSF
grant IIS-1836565. KK acknowledges the support of the
Federal Ministry of Economic Affairs and Energy (BMWi)
project “Scalable adaptive production systems through AI-
based resilience optimization” (SPAICER, funding refer-
ence 01MK20015E), funded within the AI innovation com-
petition “Artiﬁcial intelligence as a driver for economically
relevant ecosystems“. Any opinions, ﬁndings and conclu-
sion or recommendations are those of the authors and do not
necessarily reﬂect the view of the US government.

References
Albus, J. S. 1981. Brains, behavior, and robotics. Byte
books Peterborough, NH.
Anschel, O.; Baram, N.; and Shimkin, N. 2017. Averaged-
dqn: Variance reduction and stabilization for deep reinforce-
ment learning. In ICML.
Blockeel, H., and De Raedt, L. 1998. Top-down induction
of ﬁrst-order logical decision trees. AIJ.
Boutilier, C.; Reiter, R.; and Price, B. 2001. Symbolic dy-
namic programming for ﬁrst-order mdps. In IJCAI.
Boyan, J. A., and Moore, A. W. 1995. Generalization in re-
inforcement learning: Safely approximating the value func-
tion. NIPS.
Boyan, J. A. 1999. Least-squares temporal difference learn-
ing. In ICML.
De Raedt, L.; Kersting, K.; Natarajan, S.; and Poole, D.
2016. Statistical Relational Artiﬁcial Intelligence: Logic,
Probability, and Computation. Morgan & Claypool Pub-
lishers.
Driessens, K., and Dˇzeroski, S. 2004. Integrating guidance
into relational reinforcement learning. MLJ.
Driessens, K., and Ramon, J. 2003. Relational instance
In
based regression for relational reinforcement learning.
ICML.
Driessens, K.; Ramon, J.; and Blockeel, H. 2001. Speeding
up relational reinforcement learning through the use of an
incremental ﬁrst order decision tree learner. In ECML.
Dˇzeroski, S.; De Raedt, L.; and Driessens, K. 2001. Rela-
tional reinforcement learning. MLJ.

Ernst, D.; Geurts, P.; and Wehenkel, L. 2005. Tree-based
batch mode reinforcement learning. JMLR.
Fern, A.; Yoon, S.; and Givan, R. 2006. Approximate pol-
icy iteration with a policy language bias: Solving relational
markov decision processes. JAIR.
Friedman, J. H. 2001. Greedy function approximation: a
gradient boosting machine. Annals of statistics.
G¨artner, T.; Driessens, K.; and Ramon, J. 2003. Graph
kernels and gaussian processes for relational reinforcement
learning. In ILP.
Getoor, L. 2007. Introduction to statistical relational learn-
ing. MIT press.
Guestrin, C.; Koller, D.; Gearhart, C.; and Kanodia, N.
2003. Generalizing plans to new environments in relational
mdps. In IJCAI.
Hausknecht, M., and Stone, P. 2015. Deep recurrent q-
learning for partially observable mdps. In AAAI Fall Sympo-
sium Series.
Jensen, D., and Neville, J. 2002. Linkage and autocorre-
lation cause feature selection bias in relational learning. In
ICML.
Jiang, Z., and Luo, S. 2019. Neural logic reinforcement
learning. In ICML.
Keller, P. W.; Mannor, S.; and Precup, D. 2006. Auto-
matic basis function construction for approximate dynamic
programming and reinforcement learning. In ICML.
Kersting, K., and Driessens, K. 2008. Non-parametric pol-
icy gradients: A uniﬁed treatment of propositional and rela-
tional domains. In ICML.
Khot, T.; Natarajan, S.; Kersting, K.; and Shavlik, J. 2011.
Learning markov logic networks via functional gradient
boosting. In ICDM.
Lagoudakis, M. G., and Parr, R. 2003. Least-squares policy
iteration. JMLR.
Lin, L.-J. 1992. Self-improving reactive agents based on
reinforcement learning, planning and teaching. MLJ.
Menache, I.; Mannor, S.; and Shimkin, N. 2005. Basis func-
tion adaptation in temporal difference reinforcement learn-
ing. Annals of Operations Research.
Mnih, V.; Kavukcuoglu, K.; Silver, D.; Rusu, A. A.; Veness,
J.; Bellemare, M. G.; Graves, A.; Riedmiller, M.; Fidjeland,
A. K.; Ostrovski, G.; et al. 2015. Human-level control
through deep reinforcement learning. Nature.
Mnih, V.; Badia, A. P.; Mirza, M.; Graves, A.; Lillicrap,
2016.
T.; Harley, T.; Silver, D.; and Kavukcuoglu, K.
Asynchronous methods for deep reinforcement learning. In
ICML.
Natarajan, S.; Joshi, S.; Tadepalli, P.; Kersting, K.; and
Shavlik, J. 2011. Imitation learning in relational domains:
A functional-gradient boosting approach. In IJCAI.

Natarajan, S.; Khot, T.; Kersting, K.; Gutmann, B.; and
Shavlik, J. 2012. Gradient-based boosting for statistical re-
lational learning: The relational dependency network case.
MLJ.
Natarajan, S.; Kersting, K.; Khot, T.; and Shavlik, J. 2014.
In Boosted Statistical Relational Learners.
Introduction.
Springer.
Parr, R.; Painter-Wakeﬁeld, C.; Li, L.; and Littman, M.
2007. Analyzing feature generation for value-function ap-
proximation. In ICML.
Price, B., and Boutilier, C. 2001. Imitation and reinforce-
ment learning in agents with heterogeneous actions. In Con-
ference of the Canadian Society for Computational Studies
of Intelligence.
Ramanan, N.; Kunapuli, G.; Khot, T.; Fatemi, B.; Kazemi,
S. M.; Poole, D.; Kersting, K.; and Natarajan, S. 2018.
Structure learning for relational logistic regression: An en-
semble approach. In KR.
Riedmiller, M. 2005. Neural ﬁtted q iteration-ﬁrst expe-
riences with a data efﬁcient neural reinforcement learning
method. In ECML.
Sanner, S., and Boutilier, C. 2009. Practical solution tech-
niques for ﬁrst-order mdps. AIJ.
Santoro, A.; Faulkner, R.; Raposo, D.; Rae, J.; Chrzanowski,
M.; Weber, T.; Wierstra, D.; Vinyals, O.; Pascanu, R.; and
Lillicrap, T. 2018. Relational recurrent neural networks. In
NIPS.
Slaney, J., and Thi´ebaux, S. 2001. Blocks world revisited.
AIJ.
Tadepalli, P.; Givan, R.; and Driessens, K. 2004. Relational
reinforcement learning: An overview. In ICML-Workshop
on Relational Reinforcement Learning.
Tosatto, S.; Pirotta, M.; D’Eramo, C.; and Restelli, M. 2017.
Boosted ﬁtted q-iteration. In ICML.
Van Hasselt, H.; Guez, A.; and Silver, D. 2016. Deep rein-
forcement learning with double q-learning. In AAAI.
Wang, C.; Joshi, S.; and Khardon, R. 2008. First order
decision diagrams for relational mdps. JAIR.
Whiteson, S.; Taylor, M. E.; Stone, P.; et al. 2007. Adap-
tive tile coding for value function approximation. Computer
Science Department, University of Texas at Austin.
Wu, J.-H., and Givan, R. 2007. Discovering relational do-
main features for probabilistic planning. In ICAPS.
Yu, H., and Bertsekas, D. P. 2009. Convergence results for
some temporal difference methods based on least squares.
IEEE Transactions on Automatic Control.
Zambaldi, V.; Raposo, D.; Santoro, A.; Bapst, V.; Li, Y.;
Babuschkin, I.; Tuyls, K.; Reichert, D.; Lillicrap, T.; Lock-
hart, E.; et al. 2019. Deep reinforcement learning with rela-
tional inductive biases. In ICLR.

