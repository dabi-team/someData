0
2
0
2

y
a
M
8
2

]
L
P
.
s
c
[

4
v
4
9
7
7
0
.
7
0
9
1
:
v
i
X
r
a

Generating Correctness Proofs with Neural
Networks

Alex Sanchez-Stern
UC San Diego
USA
alexss@eng.ucsd.edu

Lawrence Saul
UC San Diego
USA
saul@cs.ucsd.edu

Yousef Alhessi
UC San Diego
USA
yalhessi@eng.ucsd.edu

Sorin Lerner
UC San Diego
USA
lerner@cs.ucsd.edu

Abstract
Foundational verification allows programmers to build
software which has been empirically shown to have high
levels of assurance in a variety of important domains.
However, the cost of producing foundationally verified
software remains prohibitively high for most projects,
as it requires significant manual effort by highly trained
experts. In this paper we present Proverbot9001, a proof
search system using machine learning techniques to pro-
duce proofs of software correctness in interactive the-
orem provers. We demonstrate Proverbot9001 on the
proof obligations from a large practical proof project,
the CompCert verified C compiler, and show that it
can effectively automate what were previously manual
proofs, automatically producing proofs for 28% of theo-
rem statements in our test dataset, when combined with
solver-based tooling. Without any additional solvers, we
exhibit a proof completion rate that is a 4X improvement
over prior state-of-the-art machine learning models for
generating proofs in Coq.

CCS Concepts: ‚Ä¢ Computing methodologies ‚Üí
Symbolic and algebraic manipulation; Machine
learning.

Keywords: Machine-learning, Theorem proving

Permission to make digital or hard copies of all or part of this
work for personal or classroom use is granted without fee provided
that copies are not made or distributed for profit or commercial
advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned
by others than the author(s) must be honored. Abstracting with
credit is permitted. To copy otherwise, or republish, to post on
servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.

MAPL ‚Äô20, June 15, 2020, London, UK
¬© 2020 Copyright held by the owner/author(s). Publication rights
licensed to ACM.
ACM ISBN 978-1-4503-7996-0/20/06. . . $15.00
https://doi.org/10.1145/3394450.3397466

ACM Reference Format:
Alex Sanchez-Stern, Yousef Alhessi, Lawrence Saul, and Sorin
Lerner. 2020. Generating Correctness Proofs with Neural
Networks. In Proceedings of the 4th ACM SIGPLAN Interna-
tional Workshop on Machine Learning and Programming Lan-
guages (MAPL ‚Äô20), June 15, 2020, London, UK . ACM, New
York, NY, USA, 15 pages. https://doi.org/10.1145/3394450.
3397466

Introduction

1
A promising approach to software verification is founda-
tional verification. In this approach, programmers use
an interactive theorem prover, such as Coq [14] or Is-
abelle/HOL [35], to state and prove properties about
their programs. Foundational verification has shown
increasing promise over the past two decades; it has
been used to prove properties of programs in a variety of
settings, including compilers [28], operating systems [23],
database systems [31], file systems [8], distributed sys-
tems [39], and cryptographic primitives [3].

One of the main benefits of foundational verification is
that it provides high levels of assurance. The interactive
theorem prover makes sure that proofs of program prop-
erties are done in full and complete detail, without any
implicit assumptions or forgotten proof obligations. Fur-
thermore, once a proof is completed, foundational proof
assistants can generate a representation of the proof in
a foundational logic; these proofs can be checked with a
small kernel. In this setting only the kernel needs to be
trusted (as opposed to the entire proof assistant), leading
to a small trusted computing base. As an example of
this high-level of assurance, a study of compilers [41] has
shown that CompCert [28], a compiler proved correct
in the Coq proof assistant, is significantly more robust
than its non-verified counterparts.

Unfortunately, the benefits of foundational verification
come at a great cost. The process of performing proofs in
a proof assistant is extremely laborious. CompCert [28]
took 6 person-years and 100,000 lines of Coq to write
and verify, and seL4 [23], which is a verified version of

 
 
 
 
 
 
MAPL ‚Äô20, June 15, 2020, London, UK

Alex Sanchez-Stern, Yousef Alhessi, Lawrence Saul, and Sorin Lerner

a 10,000 line operating system, took 22 person-years
to verify. The sort of manual effort is one of the main
impediments to the broader adoption of proof assistants.
In this paper, we present Proverbot9001, a novel sys-
tem that uses machine learning to help alleviate the
manual effort required to complete proofs in an interac-
tive theorem prover. Proverbot9001 trains on existing
proofs to learn models. Proverbot9001 then incorporates
these learned models in a tree search process to complete
proofs. The source of Proverbot9001 is publicly available
on GitHub 1.

The main contribution of this paper is bringing domain
knowledge to the feature engineering, model architecture,
and search procedures of machine-learning based systems
for interactive theorem proving. In particular, our work
distinguishes itself from prior work on machine learning
for proofs in three ways:

1. A two part tactic-prediction model, in which pre-
diction of tactic arguments is primary and informs
prediction of tactics themselves.

2. An argument prediction architecture which makes
use of recurrent neural networks over sequential
representations of terms.

3. Several effective tree pruning techniques inside of

a prediction-guided proof search.

We tested Proverbot9001 end-to-end by training on
the proofs from 162 files from CompCert, and testing on
the proofs from 13 files2. When combined with solver-
based tooling (which alone can only solve 7% of proofs),
Proverbot9001 can automatically produce proofs for 28%
of the theorem statements in our test dataset (138/501).
In our default configuration without external solvers,
Proverbot9001 solves (produces a checkable proof for)
19.36% (97/501) of the proofs in our test set, which is
a nearly 4X improvement over the previous state of the
art system that attempts the same task [40]. Our model
is able to reproduce the tactic name from the solution
32% of the time; and when the tactic name is correct,
our model is able to predict the solution argument 89%
of the time. We also show that Proverbot9001 can be
trained on one project and then effectively predict on
another project.

2 Background
2.1 Foundational Verification
Program verification is a well studied problem in the pro-
gramming languages community. Most work in this field
falls into one of two categories: solver-backed automated
(or semi-automated) techniques, where a simple proof is
checked by a complex procedure; and foundational logic

1https://github.com/UCSD-PL/proverbot9001
2This training/test split comes from splitting the dataset 90/10,
and then removing from the test set files that don‚Äôt contain proofs.

Figure 1. (a) A feed-forward neural network, where
each individual gray circle is a perceptron (b) An in-
dividual perceptron, which multiplies all the inputs by
weights, sums up the results, and then applies a non-
linear function ùëì .

based techniques, where a complex proof is checked by
a simple procedure.

While research into solver-backed techniques has pro-
duced fully-automated tools in many domains, these
approaches are generally incomplete, failing to prove
some desirable propositions. When these procedures fail,
it is often difficult or impossible for a user to complete
the proof, requiring a deep knowledge of the automation.
In contrast, foundational verification techniques require
a heavy initial proof burden, but scale to any propo-
sition without requiring a change in proof technique.
However, the proof burden of foundational techniques
can be prohibitive; CompCert, a large and well-known
foundationally verified compiler, took 6 person-years of
work to verify [27], with other large verification projects
sporting similar proof burdens.

Interactive Theorem Provers

2.2
Most foundational (and some solver-backed) verification
is done in an interactive theorem prover. Interactive
theorem provers allow the user to define proof goals
alongside data and program definitions, and then prove
those goals interactively, by entering commands which
manipulate the proof context. The name and nature of
these commands varies by the proof assistant, but in
many foundational assistants, these commands are called
‚Äútactics‚Äù, and coorespond to primitive proof techniques
like ‚Äúinduction‚Äù, as well as search procedures like ‚Äúomega‚Äù
(which searches for proofs over ring-like structures). Proof
obligations in such proof assistants take the form of a
set of hypotheses (in a Curry-Howard compatible proof
theory, bound variables in a context), and a goal (a
target type); proof contexts may consist of multiple
proof obligations.

2.3 Machine Learning and Neural Networks
Machine learning is an area of computer science dating
back to the 1950s. In problems of supervised learning,
the goal is to learn a function from labeled examples
of input-output pairs. Models for supervised learning
parameterize a function from inputs to outputs and have

outin0in1in2in3in0in1inn+f(a)(b)√óout√ó√óGenerating Correctness Proofs with Neural Networks

MAPL ‚Äô20, June 15, 2020, London, UK

Figure 2. A recurrent neural network. Inputs are in
blue boxes at the bottom, and each iteration produces
an output value, as well as a new state value for the next
iteration.

Figure 3. The overall architecture of Proverbot9001,
built using CoqSerapi, Python, and PyTroch.

a procedure to update the parameters from a data set
of labeled examples. Machine learning has traditionally
been applied to problems such as handwriting recogni-
tion, natural language processing, and recommendation
systems.

Neural Networks are a particular class of learned model
where layers of nodes are connected together by a lin-
ear combination and a non-linear activation function, to
form general function approximators. Neural Networks
have a variety of structures, some forming a straightfor-
ward ‚Äústack‚Äù of nodes with some connections removed
(convolutional), and others, such as those used for natu-
ral language processing, using more complex structures
like loops.

We will make use of two different kinds of neural net-
works: feed-forward networks and recurrent neural net-
works. Figure 1(a) shows the structure of a feed-forward
network, where each gray circle is a perceptron, and
Figure 1(b) shows individual structure of a perceptron.
Figure 2 shows the structure of a recurrent neural net-
work (RNN). Inputs are shown in blue, outputs in green
and computational nodes in gray. The computational
nodes are Gated Recurrent Network nodes, GRU for
short, a commonly used network component with two
inputs and two outputs [10]. The network is recurrent
because it feeds back into itself, with the state output
from the previous iteration feeding into the state input
of the next iteration. When we display an RNN receiving
data, we visually unfold the RNN, as shown on the right
side of Figure 2, even though in practice there is still
only one GRU node. The right side of Figure 2 shows
an example RNN that processes tokens of a Coq goal,
and produces some output values.

3 Overview
In this section, we‚Äôll present Proverbot9001‚Äôs prediction
and search process with an example from CompCert.
You can see the top-level structure of Proverbot9001 in
Figure 3.

Consider the following theorem from the CompCert

compiler:

Figure 4. A graph of a Proverbot9001 search. In green
are the tactics that formed part of the discovered solution,
as well as the lemma name and the QED. In orange are
nodes that resulted in a context that is at least as hard
as one previously found (see Section 7).

Definition binary_constructor_sound
(cstr: expr -> expr -> expr)
(sem: val -> val -> val) : Prop :=

forall le a x b y,
eval_expr ge sp e m le a x ->
eval_expr ge sp e m le b y ->
exists v, eval_expr ge sp e m le (cstr a b) v

/\ Val.lessdef (sem x y) v.

Theorem eval_mulhs:

binary_constructor_sound mulhs Val.mulhs.

Proof.
...

This theorem states that the mulhs expression con-
structor is sound with respect to the specification
Val.mulhs.

At the beginning of the proof of eval_mulhs, Prover-
bot9001 predicts three candidate tactics, econstructor,
eauto, and unfold binary_constructor_sound. Once
these predictions are made, Proverbot9001 tries running
all three, which results in three new states of the proof
assistant. In each of these three states, Proverbot9001
again makes predictions for what the most likely tactics
are to apply next. These repeated predictions create a

not(eqxy)613425inoutVisually UnfoldGGGGGGGSearchCoq InterfaceNeural Network Prediction ModelTheorem To ProveProofProof StatesPredictionsCommandsProof Stateseval_mulhseconstructorunfold binary_constructor_soundeautosimpltry omegaeautointrossimpleautoinv HTrivialExistsQEDTrivialExistsinv H0substeconstructorMAPL ‚Äô20, June 15, 2020, London, UK

Alex Sanchez-Stern, Yousef Alhessi, Lawrence Saul, and Sorin Lerner

Tactics
ùíØ
Tactic arguments
ùíú
Proof commands
ùíû = ùíØ √ó ùíú
Identifiers
‚Ñê
Propositions
ùí¨
Goals
ùí¢ = ùí¨
Hypotheses
‚Ñã = ‚Ñê √ó ùí¨
ùí™ = [‚Ñã] √ó ùí¢ Obligations
ùíÆ = [ùí™ √ó [ùíû]] Proof states

Figure 5. Formalism to model a Proof Assistant

search tree, which Proverbot9001 explores in a depth
first way. The proof command predictions that Prover-
bot9001 makes are ordered by likelihood, and the search
explores more likely branches first.

Figure 4 shows

the resulting search tree for
eval_mulhs. The nodes in green are the nodes that pro-
duce the final proof. Orange nodes are predictions that
fail to make progress on the proof (see Section 7); these
nodes are not expanded further. All the white nodes to
the right of the green path are not explored, because the
proof in the green path is found first.

4 Definitions
In the rest of the paper, we will describe the details
of how Proverbot9001 works. We start with a set of
definitions that will be used throughout. In particular,
Figure 5 shows the formalism we will use to represent the
state of an in-progress proof. A tactic ùúè ‚àà ùíØ is a tactic
name. An argument ùëé ‚àà ùíú is a tactic argument. For
simplicity of the formalism, we assume that all tactics
take zero or one arguments. We use ‚Ñê for the set of
Coq identifiers, and ùí¨ for the set of Coq propositions.
A proof state ùúé ‚àà ùíÆ is a state of the proof assistant,
which consists of a list of obligations along with their
proof command history. We use [ùëã] to denote the set
of lists of elements from ùëã. An obligation is a pair of:
(1) a set of hypotheses (2) a goal to prove. A hypothesis
is a proposition named by an identifier, and a goal is a
proposition.

5 Predicting a Single Proof Step
We start by explaining how we predict individual steps
in the proof. Once we have done this, we will explain
how we use these proof command predictions to guide a
proof search procedure.

We define ùíü[ùúè ] to be a scoring function over ùúè , where

larger scores are preferred over smaller ones:

ùíü[ùúè ] = ùúè ‚Üí R

We define a ùúè -predictor ‚Ñõ[ùúè ] to be a function that takes
a proof state ùúé ‚àà ùíÆ (i.e. a state of the proof assistant

under which we want to make a prediction) and returns
a scoring function over ùúè . In particular, we have:

‚Ñõ[ùúè ] = ùíÆ ‚Üí ùíü[ùúè ]
Our main predictor ùëÉ will be a predictor of the next
step in the proof, i.e. a predictor for proof commands:

ùëÉ : ‚Ñõ[ùíØ √ó ùíú]
We divide our main predictor into two predictors, one
for tactics, and one for arguments:

ùëÉtac : ‚Ñõ[ùíØ ]
ùëÉarg : ùíØ ‚Üí ‚Ñõ[ùíú]
Our main predictor ùëÉ combines ùëÉtac and ùëÉarg as follows:
ùëÉ (ùúé) = ùúÜ(ùúè, ùëé) . ùëÉtac(ùúé)(ùúè ) ‚äó ùëÉarg (ùúè )(ùúé)(ùëé)
where ‚äó is an operator that combines the scores of the
tactic and the argument predictors. We now describe
the three parts of this prediction architecture in turn:
ùëÉtac, ùëÉarg , and ‚äó.

5.1 Predicting Tactics (ùëÉtac)
To predict tactics, Proverbot9001 uses of a set of manu-
ally engineered features to reflect important aspects of
proof prediction: (1) the head of the goal as an integer
(2) the name of the previously run tactic as an integer
(3) a hypothesis that is heuristically chosen (based on
string similarity to goal) as being the most relevant to
the goal (4) the similarity score of this most relevant
hypothesis.

These features are embedded into a continuous vector
of 128 floats using a standard word embedding, and then
fed into a fully connected feed-forward neural network
(3 layers, 128 nodes-wide) with a softmax (normalizing)
layer at the end, to compute a probability distribution
over possible tactic names. This architecture is trained
on 153402 samples with a stochastic gradient descent
optimizer.

The architecture of this model is shown in Figure 6.
Blue boxes represent input; purple boxes represent inter-
mediate encoded values; green boxes represent outputs;
and gray circles represent computations. The NN circle
is the feed-forward Neural Network mentioned above.
The Enc circle is a word embedding module.

5.2 Predicting Tactic Arguments (ùëÉarg )
Once a tactic is predicted, Proverbot9001 next predicts
arguments. Recall that the argument predictor is a func-
tion ùëÉarg : ‚Ñõ[ùíú]. In contrast to previous work, our ar-
gument model is a prediction architecture in its own
right.

Proverbot9001 currently predicts zero or one tactic
arguments; However, since the most often-used multi-
argument Coq tactics can be desugared to sequences of
single argument tactics (for example ‚Äúunfold a, b‚Äù to

Generating Correctness Proofs with Neural Networks

MAPL ‚Äô20, June 15, 2020, London, UK

Figure 6. Proverbot9001‚Äôs model for predicting tactics.
Takes as input three features for each data point: the
previous tactic run, the head token of the goal, and of the
most relevant hypothesis (see Section 5.1). We restrict
the previous tactic feature to the 50 most common tactics,
and head tokens on goal and hypothesis to the 100 most
common head tokens.

‚Äúunfold a. unfold b.‚Äù), this limitation does not signifi-
cantly restrict our expressivity in practice.

Proverbot9001 makes three kinds of predictions for
arguments: goal-token arguments, hypothesis arguments,
lemma arguments:

Goal-token arguments are arguments that are a sin-
gle token in the goal;
is
not (eq x y), we might predict unfold not, where not
refers to the first token in the goal. In the case of tactics
like unfold and destruct, the argument is often (though
not always) a token in the goal.

for instance,

if the goal

Hypothesis arguments are identifiers referring to a hy-
pothesis in context. For instance, if we have a hypothesis
H in context, with type is_path (cons (pair s d) m),
we might predict inversion H, where H refers to the
hypothesis, and inversion breaks it down. In the case
of tactics like inversion and destruct, the argument is
often a hypothesis identifier.

Finally, lemma arguments are identifiers referring to
a previously defined proof. These can be basic facts in
the standard library, like

plus_n_0 : forall n : nat, n = n + 0

or a lemma from the current project, such as the
eval_mulhs described in the overview. In Proverbot9001,
lemmas are considered from a subset of the possible
lemma arguments available in the global context, in or-
der to make training tractable. Proverbot9001 supports
several different modes for determining this subset; by
default we consider lemmas defined previously in the
current file.

The architecture of the scoring functions for these
argument types is shown in Figure 7. One recurrent
neural network (RNN) is used to give scores to each
hypothesis and lemma by processing the type of the
term, and outputting a final score. A different RNN is
then used to process the goal, assigning a score to each
token in processes.

Figure 7. The model for scoring possible arguments.

As before, blue boxes are inputs; purple boxes are
encoded values; green diamonds are outputs, in this case
scores for each individual possible argument; and gray
circles are computational nodes. The GRU nodes are
Gated Recurrent Units [10]. The NN node is a feed-
forward neural network.

For illustration purposes, Figure 7 uses an example
to provide sample values. Each token in the goal is an
input ‚Äì in Figure 7 the goal is ‚Äúnot (eq x y)‚Äù. The tactic
predicted by ùëÉtac is also an input ‚Äì in Figure 7 this tactic
is ‚Äúunfold‚Äù. The hypothesis that is heuristically closest
to the goal (according to our heuristic from Section 5.1)
is also an input, one token at a time being fed to a GRU.
In our example, let‚Äôs assume this closest hypothesis is
‚Äúy > (x+1)‚Äù. The similarity score of this most relevant
hypothesis is an additional input ‚Äì in Figure 7 this score
is 5.2.

There is an additional RNN (the middle row of GRUs
in Figure 7) which encodes the goal as a vector of reals.
The initial state of this RNN is set to some arbitrary
constant, in this case 0.

The initial state of the hypothesis RNN (the third
row of GRUs in Figure 7) is computed using a feed-
forward Neural Network (NN). This feed-forward Neural
Network takes as input the tactic predicted by ùëÉtac, the
goal encoded as a vector of reals, and the similarity score
of the hypothesis.

The architecture in Figure 7 produces one output score
for each token in the goal and one output score for the
hypothesis. The highest scoring element will be chosen
as the argument to the tactic. In Figure 7, the highest
scoring element is the ‚Äúnot‚Äù token, resulting in the proof
command ‚Äúunfold not‚Äù. If the hypothesis score (in our
example this score is 8) would have been the highest
score, then the chosen argument would be the identifier
of that hypothesis in the Coq context. For example, if the
identifier was IHn (as is sometimes the case for inductive
hypotheses), then the resulting proof command would
be ‚Äúunfold IHn‚Äù.

NN‚Äúapply‚ÄùEncodePrevious tactic‚Äúforall‚Äù‚Äúeq‚ÄùGoal headHypothesis headVectors of realsEncDistribution over tacticsEncEncnot(eqxy)y>(x+1)‚Äúunfold‚ÄùTactic namepredicted by PtacGoalHypothesis/Lemma0Constant5.2Hypothesis/Lemma Similarity ScoreNNEncoded Goal608.22.13.09.28134295Hypothesis/Lemma Output ScoreToken Output ScoresGGGGGGGGGGGGGGGGGGGMAPL ‚Äô20, June 15, 2020, London, UK

Alex Sanchez-Stern, Yousef Alhessi, Lawrence Saul, and Sorin Lerner

5.3 Combining Tactic and Argument Scores

(‚äó)

The ‚äó operator attempts to provide a balanced combi-
nation of tactic and argument prediction, taking both
into account even across different tactics. The operator
works as follows. We pick the ùëõ highest-scoring tactics
and for each tactic the ùëö highest-scoring arguments.
We then score each proof command by multiplying the
tactic score and the argument score, without any normal-
ization. Formally, we can implement this approach by
defining ‚äó to be multiplication, and by not normalizing
the probabilities produced by ùëÉarg until all possibilities
are considered together.

Because we don‚Äôt normalize the probabilities of tac-
tics, the potential arguments for a tactic are used in
determining the eligibility of the tactic itself (as long
as that tactic is in the top ùëõ). This forms one of the
most important contributions of our work: the argument
selection is primary, with the tactic prediction mostly
serving to help prune its search space.

5.4 Putting It All Together
The overall architecture that we have described is shown
in Figure 8. The ùëÉtac predictor (whose detailed struc-
ture is shown in Figure 6) computes a distribution over
tactic using three features as input: the previous tactic,
head constructor of goal, and head constructor of the
hypothesis deemed most relevant. Then, for each of the
top tactic predicted by ùëÉtac, the ùëÉarg predictor (whose
detailed structure is shown in Figure 7) is invoked. In ad-
dition to the tactic name, the ùëÉarg predictor takes several
additional inputs: the goal, the hypotheses in context,
and the similarity between each of those hypotheses and
the goal. The ùëÉarg predictor produces scores for each
possible argument (in our case one score for each token
in the goal, and one score the single hypothesis). These
scores are combined with ‚äó to produce an overall scoring
of proof commands.

6 Training
6.1 Training Architecture
Figure 9 shows the training architecture for the tactic
predictor, ùëÉtac (recall that the detailed architecture of
ùëÉtac is shown in Figure 6). The goal of training is to
find weights for the neural network that is found inside
the gray ùëÉtac circle. Proverbot9001 processes all the Coq
theorems in the training set, and steps through the proof
of each of these theorems. Figure 9 shows what happens
at each step in the proof. In particular, at each step in
the proof, Proverbot9001 computes the three features
we are training with, and passes these features to the
current tactic model to get a distribution over tactics.
This distribution over tactics, along with the correct

tactic name (from the actual proof), are passed to a
module that computes changes to the weights based
on the NLLLoss criterion. These changes are batched
together over several steps of the proof, and then applied
to update the tactic model. Running over all the training
data to update the weights is called an epoch, and we
run our training over 20 epochs.

Figure 10 shows the training architecture for the argu-
ment predictor, ùëÉarg (recall that the detailed architecture
of ùëÉarg is shown in Figure 7). The goal of training is
to find weights for the GRU components in ùëÉarg . Here
again, Proverbot9001 processes all the Coq theorems in
the training set, and steps through the proof of each of
these theorems. Figure 10 shows what happens at each
step in the proof. In particular, at each step in the proof,
the current ùëÉtac predictor is run to produce the top pre-
dictions for tactic. These predicted tactic, along with the
correct tactic, are passed to the argument model ùëÉarg .
To make Figure 10 more readable, we do not show the
additional parameters to ùëÉarg that where displayed in
Figure 8, but these parameters are in fact also passed to
ùëÉarg during training. Note that it is very important for
us to inject the tactics predicted by ùëÉtac into the input
of the argument model ùëÉarg , instead of using just the
correct tactic name. This allows the scores produced by
the argument model to be comparable across different
predicted tactics. Once the argument model ùëÉarg com-
putes a score for each possible argument, we combine
these predictions using ‚äó to get a distribution of scores
over tactic/argument pairs. Finally, this distribution,
along with the correct tactic/argument pair is passed to
a module that computes changes to the weights based
on the NLLLoss criterion. In our main CompCert bench-
mark the 153402 tactic samples from the training set
are processed for 20 epochs.

6.2 Learning From Higher-Order Proof

Commands

Proof assistants generally have higher-order proof com-
mands, which are tactics that take other proof commands
as arguments; in Coq, these are called tacticals. One of
the most common examples is the (;) infix operator
which runs the proof command on the right on every
sub-goal produced by the tactic on the left. Another
example is the repeat tactical, which repeats a provided
tactic until it fails.

While higher-order proof commands are extremely
important for human proof engineers, they are harder to
predict automatically because of their generality. While
some previous work [40] attempts to learn directly on
data which uses these higher-order proof commands,
we instead take the approach of desugaring higher-order
proof commands into first-order ones as much as possible;

Generating Correctness Proofs with Neural Networks

MAPL ‚Äô20, June 15, 2020, London, UK

Figure 8. The overall prediction model, combining the tactic prediction and argument prediction models.

desugars the cases that can be sequenced, and the re-
maining commands containing (;) are filtered out of the
training set.

In addition to the (;) tactical, there are other tacticals
in common use in Coq. Some can be desugared into
simpler forms. For example:

‚àô ‚Äúnow <tac>‚Äù becomes ‚Äú<tac>;easy‚Äù.
‚àô ‚Äúrewrite <term> by <tac>‚Äù

‚Äúrewrite <term> ; [ | <tac>]‚Äù

‚àô ‚Äúassert <term> by <tac>‚Äù

‚Äúassert <term> ; [ | <tac>]‚Äù

becomes

becomes

In other cases, like try <tac> or solve <tac>, the
tactical changes the behavior of the proof command in
a way that cannot be desugared; for these we simply
treat the prefixed tactic as a separate, learned tactic.
For example, we would treat try eauto as a new tactic.

7 Prediction-Guided Search
Now that we have explained how we predict a single step
in the proof, we describe how Proverbot9001 uses these
predictions in a proof search.

In general, proof search works by transitioning the
proof assistant into different states by applying proof
commands, and backtracking when a given part of the
search space has either been exhausted, or deemed un-
viable. Exhaustive proof search in proof assistants is
untenable because the number of possible proof com-
mands to apply is large. Instead, we use the predictor
described above to guide the search. Aside from using
these predictions, the algorithm is a straightforward
depth-limited search, with three subtleties.

First. we stop the search when we find a proof goal
that is at least as hard (by a syntactic definition) as a
goal earlier in the history. While in general it is hard
to formally define what makes one proof state harder
than another, there are some obvious cases which we
can detect. A proof state with a superset of the original

Figure 9. The architecture for training the tactic mod-
els.

Figure 10. The architecture for training the argument
models. Note that we inject predicted tactics into the
input of the argument model, instead of just using the
correct tactic, so that argument scores will be compara-
ble.

this makes the data more learnable, without restricting
the set of expressible proofs.

For example, instead of trying to learn and predict
(;) directly, Proverbot9001 has a system which attempts
to desugar (;) into linear sequences of proof commands.
This is not always possible (without using explicit sub-
goal switching commands), due to propagation of exis-
tential variables across proof branches. Proverbot9001

Ptac‚Äúapply‚ÄùPrevtactic‚Äúforall‚Äù‚Äúeq‚ÄùGoal headHypothesis headDistribution over tactics‚Äúunfold‚ÄùTop tactics‚Äúintros‚Äù‚Äúapply‚ÄùArg ModelTactic ModelParg258Parg764Parg139Distribution over tactic/arg pairsArg Scores‚Äúunfold eq‚ÄùFeatures‚Äúapply IHn‚Äù‚Äúintros‚ÄùTop tactic/arg pairsnot (eq x y)y > (x+1)Goal, Hypothesis, Similarity Score5.2Ptac‚Äúapply‚ÄùPrevtactic‚Äúforall‚Äù‚Äúeq‚ÄùGoal headHypothesis headDistribution over tacticsTactic ModelFeatures‚Äúunfold‚ÄùCorrect tacticWeight ChangesEvaluate Criterion & Compute Weight ChangesDistribution over tactics from Ptac‚Äúunfold‚ÄùTop tactics‚Äúintros‚Äù‚Äúapply‚ÄùArgModelParg258Parg764Parg139Distribution over tactic/arg pairsArgScores‚Äúunfold‚ÄùParg397Correct tactic‚Äúunfold eq‚ÄùCorrect tactic & argumentWeight ChangesEvaluate Criterion & Compute Weight ChangesMAPL ‚Äô20, June 15, 2020, London, UK

Alex Sanchez-Stern, Yousef Alhessi, Lawrence Saul, and Sorin Lerner

obligations will be harder to prove, and a proof state
with the same goal, but fewer assumptions, will be harder
to prove.

To formalize this intuition, we define a relation ‚â•
between states such that ùúé1 ‚â• ùúé2 is meant to capture
‚ÄúProof state ùúé1 is at least as hard as proof state ùúé2‚Äù. We
say that ùúé1 ‚â• ùúé2 if and only if for all obligations ùëÇ2 in
ùúé2 there exists an obligation ùëÇ1 in ùúé1 such that ùëÇ1‚â•ùëúùëÇ2.
For obligations ùëÇ1 and ùëÇ2, we say that ùëÇ1‚â•ùëúùëÇ2 if and
only if each hypothesis in ùëÇ1 is also a hypothesis in ùëÇ2,
and the goals of ùëÇ1 and ùëÇ2 are the same.

Since ‚â• is reflexive, this notion allows us to generalize
all the cases above to a single pruning criteria: ‚Äúproof
command prediction produces a proof state which is ‚â•
than a proof state in the history‚Äù.

Second. when backtracking, we do not attempt to
find a different proof for an already proven sub-obligation.
While in general this can lead to missed proofs because of
existential variables (typed holes filled based on context),
this has not been an issue for the kinds of proofs we have
worked with so far.

Third. we had to adapt our notion of search ‚Äúdepth‚Äù
to the structure of Coq proofs (in which a tactic can
produce multiple sub-obligations). A na√Øve tree search
through the Coq proof space will fail to exploit some of
the structure of sub-proofs in Coq.

Consider for example the following two proofs:

1. intros. simpl. eauto.
2. induction n. eauto. simpl.

At first glance, it seems that both of these proofs have
a depth of three. This means that a straightforward
tree search (which is blind to the structure of subproofs)
would not find either of these proofs if the depth limit
were set to two.

However, there is a subtlety in the second proof above
which is important (and yet not visible syntactically). In-
deed, the induction n proof command actually produces
two obligations (‚Äúsub-goals‚Äù in the Coq terminology).
These correspond to the base case and the inductive
case for the induction on n. Then eauto discharges the
first obligation (the base case), and simpl discharges the
second obligation (the inductive case). So in reality, the
second proof above really only has a depth of two, not
three.

Taking this sub-proof structure into account is impor-
tant because it allows Proverbot9001 to discover more
proofs for a fixed depth. In the example above, if the
depth were set to two, and we used a na√Øve search, we
would not find either of the proofs. However, at the same
depth of two, a search which takes the sub-proof struc-
ture into account would be able to find the second proof

(since this second proof would essentially be considered
to have a depth of two, not three).

8 Evaluation
This section shows that Proverbot9001 is able to success-
fully solve many proofs. We also experimentally show
that Proverbot9001 improves significantly on the state-
of-the-art presented in previous work.

First, in Section 8.2, we compare experimentally to
previous work, by running both Proverbot9001 and the
CoqGym [40] project on CompCert, in several config-
urations outlined in the CoqGym paper. Next, in Sec-
tion 8.3, we experiment with using the weights learned
from one project to produce proofs in another. Then,
in Section 8.4, we show the ‚Äúhardness‚Äù of proofs that
Proverbot9001 is generally able to complete, using the
length of the original solution as proxy for proof diffi-
culty. Finally, in Appendix A.1, we measure the predictor
subsystem, without proof search. Additional evaluation
can be found in the appendix.

Experiments were run on two machines. Machine A
is an Intel i7 machine with 4 cores, a NVIDIA Quadro
P4000 8BG 256-bit, and 20 gigabytes of memory. Ma-
chine B is Intel Xeon E5-2686 v4 machine with 8 cores,
a Nvidia Tesla v100 16GB 4096-bit, and 61 gigabytes of
memory. Experiments were run using GNU Parallel [38].
During the development of Proverbot9001, we explored
many alternatives, including n-gram/bag-of-words rep-
resentations of terms, a variety of features, and several
core models including k-nearest neighbors, support vec-
tor machines, and several neural architectures. While we
include here some experiments that explore high-level
design decisions (such as training and testing on the
same projects vs cross project, working with and with-
out solver-based tooling, modifying the search depth and
width, and running with and without pre-processing),
we also note that in the development of a large system
tackling a hard problem, it becomes intractable to eval-
uate against every possible permutation of every design
decision. In this setting, we are still confident in having
demonstrated a system that works for the specific prob-
lem of generating correctness proof with performance
that outperforms the state-of-the-art techniques by many
folds.

8.1 Summary of Results
Proverbot9001, run using CoqHammer [11] and the de-
fault configuration, is able to produce proofs for 28% of
the theorem statements in CompCert. This represents
a 2.4X improvement over the previous state-of-the-art.
Without any external tooling, Proverbot9001 can pro-
duce proofs for 19.36%, an almost 4X improvement over
previous state-of-the-art prediction-based proofs. Our

Generating Correctness Proofs with Neural Networks

MAPL ‚Äô20, June 15, 2020, London, UK

core prediction model is able to reproduce the tactic
name from the solution 32% of the time; and when the
tactic name is correct, our model is able to predict the
solution argument 89% of the time. We also show that
Proverbot9001 can be trained on one project and then
effectively predict on another project.

8.2 Experimental Comparison to Previous

Work

We tested Proverbot9001 end-to-end by training on the
proofs from 162 files from CompCert, and testing on
the proofs from 13 different files. On our default config-
uration, Proverbot9001 solves 19.36% (97/501) of the
proofs in our test set.

In addition to running Proverbot9001 on CompCert,
we ran the CoqGym [40] tool, which represents the state
of the art in this area, on the same dataset in several
configurations.

To account for differences in training dataset, we ran
CoqGym with their original training schema, and also
our training schema, and reported the best of the two
numbers. CoqGym is intended to be combined with a
solver based proof-procedure, CoqHammer [11], which
is run after every proof command invocation. While
our system was not originally designed this way, we
compare both systems using CoqHammer, as well as
both systems without. We also compared our system
to using CoqHammer on the initial goal directly, which
simultaneously invokes Z3 [13], CVC4 [6], Vampire [26],
and E Prover [36], in addition to attempting to solve the
goal using a crush-like tactic [9].

Figure 11 shows the proofs solved by various configu-
rations. The configurations are described in the caption.
For all configurations, we ran Proverbot9001 with a
search depth of 6 and a search width of 3 (see Appen-
dix A.5). Note that in Figure 11 the bars for H, G, and
GH are prior work. The bars P, G+P and GH+PH are
the ones made possible by our work.

When CoqHammer is not used, Proverbot9001 can
complete nearly 4 times the number of proofs that are
completed by CoqGym. In fact, even when CoqGym is
augmented with CoqHammer Proverbot9001 by itself
(without CoqHammer) still completes 39 more proofs,
which is a 67% improvement (and corresponds to about
8% of the test set). When enabling CoqHammer in both
CoqGym and Proverbot9001, we see that CoqGym solves
48 proofs whereas Proverbot9001 solves 138 proofs, which
is a 2.88X improvement over the state of art.

Finally, CoqGym and Proverbot9001 approaches are
complementary; both can complete proofs which the
other cannot. Therefore, one can combine both tools to
produce more solutions than either alone. Combining Co-
qGym and Proverbot9001, without CoqHammer, allows
us to complete 100/501 proofs, a proof success rate of

Figure 11. A comparison of Proverbot9001 and Co-
qGym‚Äôs abilities to complete proofs. H stands for Co-
qHammer by itself, as a single invocation; G stands for
CoqGym by itself; P stands for Proverbot9001 by itself;
G+P stands for the union of proofs done by G or P;
GH stands for CoqGym with CoqHammer; PH stands
for Proverbot9001 with CoqHammer; GH+PH stands for
the union of proofs done by GH or PH.

20%. Combining Proverbot9001 and CoqGym, each with
CoqHammer, allows us to solve 142/501 proofs, a success
rate of 28%. It‚Äôs important to realize that, whereas the
prior state of the art was CoqGym with CoqHammer,
at 48 proofs, by combining CoqGym and Proverbot9001
(both with CoqHammer), we can reach a grand total of
142 proofs, which is a 2.96X improvement over the prior
state of art.

8.3 Cross-Project Predictions
To test Proverbot9001‚Äôs ability to make use of train-
ing across projects, we used the weights learned from
CompCert, and ran Proverbot9001 in its default configu-
ration on three other Coq projects from the Coq Contrib
collection, concat, float, and zfc.

concat is a library of constructive category theory
proofs, which showcases Coq proofs of mathematical
concepts instead of program correctness. The concat
library is made of 514 proofs across 105 files; Prover-
bot9001 was able to successfully produce a proof for 91
(17.7%) of the extracted theorem statements, without
the use of CoqHammer.

float is a formalization of floating point numbers,
made of 742 proofs across 38 files; Proverbot9001 was
able to successfully produce a proof for 100 (13.48%)
proofs.

zfc is a formalization of set theory made of 241 proofs
across 78 files; 41 (17.01%) were successfully completed.
The comparable number for CompCert was 19.36%.

 0 20 40 60 80 100 120 140 160HGPG+PGHPHGH+PH# proofs solved97100138142372348P = Proverbot9001G = CoqGymH = CoqHammer_H = _ with CoqHammerMAPL ‚Äô20, June 15, 2020, London, UK

Alex Sanchez-Stern, Yousef Alhessi, Lawrence Saul, and Sorin Lerner

to complete the proof. Figure 12 shows proofs of length
10 or below, and Figure 13 shows all proofs, binned in
sets of 10.

There are several observations that can be made. First,
most original proofs in our test set are less than 20 steps
long, with a heavy tail of longer proofs. Second, we do
better on shorter proofs. Indeed, 51% (256/501) of the
original proofs in our test set are ten proof commands or
shorter, and of those proofs, we can solve 35% (89/256),
compared to our overall solve rate of 19.36% (97/501).
Third, we are in some cases able to handle proofs whose
original length is longer than 10. Indeed, 7 of the proofs
we solve (out of 79 solved) had an original length longer
than 10. In fact, the longest proof we solve is originally 25
proof commands long; linearized it‚Äôs 256 proof commands
long. Our solution proof is 267 (linear) proof commands
long, comparable to the original proof, with frequent
case splits. The depth limit for individual obligations in
our search was 6 in all of these runs.

9 Related Work
9.1 Program Synthesis
Program Synthesis is the automatic generation of pro-
grams from a high-level specification [18]. This specifica-
tion can come in many forms, the most common being a
logical formula over inputs and outputs, or a set of input-
output examples. Programs generated can be in a variety
of paradigms and languages, often domain-specific. Our
tool, Proverbot9001, is a program synthesis tool that
focuses on synthesis of proof command programs.

Several program synthesis works have used types ex-
tensively to guide search. Some work synthesizes pro-
grams purely from their types [19], while other work
uses both a type and a set of examples to synthesize
programs [15, 33]. In Proverbot9001, the programs be-
ing synthesized use a term type as their specification,
however, the proof command program itself isn‚Äôt typed
using that type, rather it must generate a term of that
type (through search).

Further work in [29] attempts to learn from a set of
patches on GitHub, general rules for inferring patches
to software. This work does not use traditional machine
learning techniques, but nevertheless learns from data,
albeit in a restricted way.

9.2 Machine Learning for Code
Machine learning for modeling code is a well explored
area [2], as an alternative to more structured methods
of modeling code. Several models have been proposed
for learning code, such as AST-like trees [32], long-term
language models [12], and probabilistic grammars [7].
Proverbot9001 does not attempt to be so general, using

Figure 12. A histogram plotting the original proof
lengths in proof commands vs number of proofs of that
length, in three classes, for proofs with length 10 or
less. From bottom to top: proofs solved, proofs unsolved
because of depth limit, and proofs where our search
space was exhausted without finding a solution.

Figure 13. A histogram plotting the original proof
lengths in proof commands vs number of proofs of that
length, in three classes. From bottom to top: proofs
solved, proofs unsolved because of depth limit, and proofs
where our search space was exhausted without finding
a solution. Note that most proofs are between 0 and 10
proof commands long, with a long tail of much longer
proofs.

These results demonstrate not only that Proverbot9001
can operate on proof projects in a variety of domains,
but more importantly that it can effectively transfer
training from one project to another. This would allow
programmers to use Proverbot9001 even in the initial de-
velopment of a project, if it had been previously trained
on other projects.

8.4 Original Proof Length vs Completion Rate
In Figure 12 and Figure 13, we plot a histogram of
the original proof lengths (in proof commands) vs the
number of proofs of that length. We break down the
proofs by (from bottom to top) number we solve, number
we cannot solve but still have unexplored nodes, and
number run out of unexplored nodes before finding a
solution. Note that for the second class (middle bar), it‚Äôs
possible that increasing the search depth would allow us

Generating Correctness Proofs with Neural Networks

MAPL ‚Äô20, June 15, 2020, London, UK

a model of programs that is specific to its domain, al-
lowing us to capture the unique dependencies of proof
command languages. While the model is simple, it is able
to model real proofs better than more general models
in similar domains (see Section 8.2). Machine learning
has been used for various tasks such as code and patch
generation [2, 7, 12], program classification [32], and
learning loop invariants [16].

representations of terms, which is a technique that we
have not yet used, and could adapt if proven successful.
Finally, there is also another approach to proof gen-
eration, which is to generate the term directly using
language translation models [37], instead of using tac-
tics; however this technique has only been applied to
small proofs due to its direct generation of low-level
proof term syntax.

9.3 Machine Learning for Proofs
While machine learning has previously been explored for
various aspects of proof writing, we believe there are still
significant opportunities for improving on the state-of-
the-art, getting closer and closer to making foundational
verification broadly applicable.

More concretely, work on machine learning for proofs
includes: using machine learning to speed up automated
solvers [4], developing data sets [5, 22, 40], doing premise
selection [1, 30], pattern recognition [25], clustering proof
data [24], learning from synthetic data [21], interactively
suggesting tactics [20, 24].

Finally, CoqGym attempts to model proofs with a
fully general proof command and term model expressing
arbitrary AST‚Äôs. We experimentally compare Prover-
bot9001‚Äôs ability to complete proofs to that of CoqGym
in detail in Section 8.2 There are also several important
conceptual differences. First, the argument model in Co-
qGym is not as expressive as the one in Proverbot9001.
CoqGym‚Äôs argument model can predict a hypothesis
name, a number between 1 and 4 (which many tactics
in Coq interpret as referring to binders, for example
induction 2 performs induction on the second quanti-
fied variable), or a random (not predicted using machine
learning) quantified variable in the goal. In contrast,
the argument model in Proverbot9001 can predict any
token in the goal, which subsumes the numbers and the
quantified variables that CoqGym can predict. Most im-
portantly because Proverbot9001‚Äôs model can predict
symbols in the goal, which allows effective unfolding,
for example ‚Äúunfold eq‚Äù. Second, in contrast to Coq-
Gym, Proverbot9001 uses several hand-tuned features
for predicting proof commands. One key example is the
previous tactic, which CoqGym does not even encode
as part of the context. Third, CoqGym‚Äôs treatment of
higher-order proof commands like ‚Äú;‚Äù is not as effective
as Proverbot9001‚Äôs. While neither system can predict
‚Äú;‚Äù, Proverbot9001 learns from ‚Äú;‚Äù by linearizing them,
whereas CoqGym does not.

There is also a recent line of work on doing end-to-
end proofs in Isabelle/HOL and HOL4 [5, 17, 34]. This
work is hard to experimentally compare to ours, since
they use different benchmark sets, proof styles, and
proof languages. Their most recent work [34] uses graph

Acknowledgments
We would like to thank Joseph Redmon for his invaluable
help building the first Proverbot9001 version, Prover-
bot9000.

References
[1] Alexander A. Alemi, Fran√ßois Chollet, Geoffrey Irving, Chris-
tian Szegedy, and Josef Urban. 2016. DeepMath - Deep Se-
quence Models for Premise Selection. CoRR abs/1606.04442
(2016). arXiv:1606.04442 http://arxiv.org/abs/1606.04442
[2] Miltiadis Allamanis, Earl T. Barr, Premkumar T. Devanbu,
and Charles A. Sutton. 2017. A Survey of Machine Learning
for Big Code and Naturalness. CoRR abs/1709.06182 (2017).
arXiv:1709.06182 http://arxiv.org/abs/1709.06182

[3] Andrew W. Appel. 2015. Verification of a Cryptographic
Primitive: SHA-256. ACM Trans. Program. Lang. Syst. 37,
2, Article 7 (April 2015), 31 pages. https://doi.org/10.1145/
2701415

[4] Mislav Balunoviundefined, Pavol Bielik, and Martin Vechev.
2018. Learning to Solve SMT Formulas. In Proceedings of
the 32nd International Conference on Neural Information
Processing Systems (NIPS‚Äô18). Curran Associates Inc., Red
Hook, NY, USA, 10338‚Äì10349.

[5] Kshitij Bansal, Sarah M. Loos, Markus N. Rabe, Chris-
tian Szegedy, and Stewart Wilcox. 2019. HOList: An En-
vironment for Machine Learning of Higher-Order Theorem
Proving (extended version). CoRR abs/1904.03241 (2019).
arXiv:1904.03241 http://arxiv.org/abs/1904.03241

[6] Clark Barrett, Christopher L. Conway, Morgan Deters, Liana
Hadarean, Dejan Jovanoviƒá, Tim King, Andrew Reynolds,
and Cesare Tinelli. 2011. CVC4. In Proceedings of the 23rd
International Conference on Computer Aided Verification
(CAV‚Äô11). Springer-Verlag, Berlin, Heidelberg, 171‚Äì177. http:
//dl.acm.org/citation.cfm?id=2032305.2032319

[7] Pavol Bielik, Veselin Raychev, and Martin Vechev. 2016.
PHOG: Probabilistic Model for Code. In Proceedings of The
33rd International Conference on Machine Learning (Proceed-
ings of Machine Learning Research), Maria Florina Balcan
and Kilian Q. Weinberger (Eds.), Vol. 48. PMLR, New York,
New York, USA, 2933‚Äì2942. http://proceedings.mlr.press/
v48/bielik16.html

[8] Haogang Chen, Tej Chajed, Alex Konradi, Stephanie Wang,
Atalay ƒ∞leri, Adam Chlipala, M. Frans Kaashoek, and Nickolai
Zeldovich. 2017. Verifying a High-performance Crash-safe File
System Using a Tree Specification. In Proceedings of the 26th
Symposium on Operating Systems Principles (SOSP ‚Äô17).
ACM, New York, NY, USA, 270‚Äì286.
https://doi.org/10.
1145/3132747.3132776

[9] Adam Chlipala. 2013. Certified Programming with Dependent
Types: A Pragmatic Introduction to the Coq Proof Assistant.
The MIT Press.

MAPL ‚Äô20, June 15, 2020, London, UK

Alex Sanchez-Stern, Yousef Alhessi, Lawrence Saul, and Sorin Lerner

[10] Kyunghyun Cho, Bart van Merrienboer, √áaglar G√ºl√ßehre,
Fethi Bougares, Holger Schwenk, and Yoshua Bengio. 2014.
Learning Phrase Representations using RNN Encoder-
Decoder
for Statistical Machine Translation.
CoRR
abs/1406.1078 (2014). arXiv:1406.1078 http://arxiv.org/abs/
1406.1078

[11] ≈Åukasz Czajka and Cezary Kaliszyk. 2018. Hammer for Coq:
Automation for Dependent Type Theory. Journal of Au-
tomated Reasoning 61, 1 (01 Jun 2018), 423‚Äì453.
https:
//doi.org/10.1007/s10817-018-9458-4

[12] Hoa Khanh Dam, Truyen Tran, and Trang Pham. 2016. A
deep language model for software code. CoRR abs/1608.02715
(2016). arXiv:1608.02715 http://arxiv.org/abs/1608.02715
[13] Leonardo de Moura and Nikolaj Bj√∏rner. 2008. Z3: An Effi-
cient SMT Solver. In Tools and Algorithms for the Construc-
tion and Analysis of Systems, C. R. Ramakrishnan and Jakob
Rehof (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg,
337‚Äì340.

[14] Jean-Christophe Filli√¢tre, Hugo Herbelin, Bruno Barras,
Bruno Barras, Samuel Boutin, Eduardo Gim√©nez, Samuel
Boutin, G√©rard Huet, C√©sar Mu√±oz, Cristina Cornes, Cristina
Cornes, Judica√´l Courant, Judicael Courant, Chetan Murthy,
Chetan Murthy, Catherine Parent, Catherine Parent, Chris-
tine Paulin-mohring, Christine Paulin-mohring, Amokrane
Saibi, Amokrane Saibi, Benjamin Werner, and Benjamin
Werner. 1997. The Coq Proof Assistant - Reference Manual
Version 6.1. Technical Report.

[15] Jonathan Frankle, Peter-Michael Osera, David Walker, and S
Zdancewic. 2016. Example-directed synthesis: a type-theoretic
interpretation. ACM SIGPLAN Notices 51 (01 2016), 802‚Äì
815. https://doi.org/10.1145/2914770.2837629

[16] Pranav Garg, Daniel Neider, P. Madhusudan, and Dan Roth.
2016. Learning Invariants Using Decision Trees and Impli-
cation Counterexamples. SIGPLAN Not. 51, 1 (Jan. 2016),
499‚Äì512. https://doi.org/10.1145/2914770.2837664

[17] Thibault Gauthier, Cezary Kaliszyk, and Josef Urban. 2017.
TacticToe: Learning to Reason with HOL4 Tactics. In LPAR-
21. 21st International Conference on Logic for Programming,
Artificial Intelligence and Reasoning (EPiC Series in Com-
puting), Thomas Eiter and David Sands (Eds.), Vol. 46. Easy-
Chair, 125‚Äì143. https://doi.org/10.29007/ntlb

[18] Sumit Gulwani. 2010. Dimensions in Program Synthesis. In
PPDP ‚Äô10 Hagenberg, Austria (ppdp ‚Äô10 hagenberg, austria
ed.). https://www.microsoft.com/en-us/research/publication/
dimensions-program-synthesis/

[19] Tihomir Gvero, Viktor Kuncak, Ivan Kuraj, and Ruzica
Piskac. 2013. Complete Completion using Types and Weights.
PLDI 2013 (2013), 12. 27‚Äì38.
http://infoscience.epfl.ch/
record/188990

[20] J√≥nathan Heras and Ekaterina Komendantskaya. 2014.
ACL2(ml): Machine-Learning for ACL2. In Proceedings
Twelfth International Workshop on the ACL2 Theorem Prover
and its Applications, Vienna, Austria, 12-13th July 2014. 61‚Äì
75. https://doi.org/10.4204/EPTCS.152.5

[21] Daniel Huang, Prafulla Dhariwal, Dawn Song, and Ilya
Sutskever. 2018. GamePad: A Learning Environment for Theo-
rem Proving. CoRR abs/1806.00608 (2018). arXiv:1806.00608
http://arxiv.org/abs/1806.00608

[22] Cezary Kaliszyk, Fran√ßois Chollet, and Christian Szegedy.
2017. HolStep: A Machine Learning Dataset for Higher-
order Logic Theorem Proving. CoRR abs/1703.00426 (2017).
arXiv:1703.00426 http://arxiv.org/abs/1703.00426

[23] Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June An-
dronick, David Cock, Philip Derrin, Dhammika Elkaduwe,

Kai Engelhardt, Rafal Kolanski, Michael Norrish, Thomas
seL4:
Sewell, Harvey Tuch, and Simon Winwood. 2009.
Formal Verification of an OS Kernel. In Proceedings of the
ACM SIGOPS 22Nd Symposium on Operating Systems Prin-
ciples (SOSP ‚Äô09). ACM, New York, NY, USA, 207‚Äì220.
https://doi.org/10.1145/1629575.1629596

[24] Ekaterina Komendantskaya, J√≥nathan Heras, and Gudmund
Grov. 2012. Machine Learning in Proof General: Interfacing
Interfaces. Electronic Proceedings in Theoretical Computer
Science 118 (12 2012). https://doi.org/10.4204/EPTCS.118.2
[25] Ekaterina Komendantskaya and Kacper Lichota. 2012. Neural
Networks for Proof-Pattern Recognition, Vol. 7553. 427‚Äì434.
https://doi.org/10.1007/978-3-642-33266-1_53

[26] Laura Kov√°cs and Andrei Voronkov. 2013. First-Order
https:

Theorem Proving and Vampire, Vol. 8044. 1‚Äì35.
//doi.org/10.1007/978-3-642-39799-8_1

[27] Daniel K√§stner, Joerg Barrho, Ulrich W√ºnsche, Marc Schlick-
ling, Bernhard Schommer, Michael Schmidt, Christian Fer-
dinand, Xavier Leroy, and Sandrine Blazy. 2018. CompCert:
Practical Experience on Integrating and Qualifying a Formally
Verified Optimizing Compiler.

[28] Xavier Leroy. 2009. Formal verification of a realistic compiler.
Commun. ACM 52, 7 (2009), 107‚Äì115. http://xavierleroy.org/
publi/compcert-CACM.pdf

[29] Fan Long, Peter Amidon, and Martin Rinard. 2017. Automatic
inference of code transforms for patch generation. 727‚Äì739.
https://doi.org/10.1145/3106237.3106253

[30] Sarah M. Loos, Geoffrey Irving, Christian Szegedy, and Cezary
Kaliszyk. 2017. Deep Network Guided Proof Search. CoRR
abs/1701.06972 (2017). arXiv:1701.06972 http://arxiv.org/
abs/1701.06972

[31] Gregory Malecha, Greg Morrisett, Avraham Shinnar, and
Ryan Wisnesky. 2010. Toward a Verified Relational Database
Management System. In Proceedings of the 37th Annual ACM
SIGPLAN-SIGACT Symposium on Principles of Program-
ming Languages (POPL ‚Äô10). ACM, New York, NY, USA,
237‚Äì248. https://doi.org/10.1145/1706299.1706329

[32] Lili Mou, Ge Li, Zhi Jin, Lu Zhang, and Tao Wang. 2014.
TBCNN: A Tree-Based Convolutional Neural Network for
Programming Language Processing. CoRR abs/1409.5718
(2014). arXiv:1409.5718 http://arxiv.org/abs/1409.5718
[33] Peter-Michael Osera and Steve Zdancewic. 2015. Type-and-
example-directed Program Synthesis. SIGPLAN Not. 50,
6 (June 2015), 619‚Äì630.
https://doi.org/10.1145/2813885.
2738007

[34] Aditya Paliwal, Sarah M. Loos, Markus N. Rabe, Kshitij
Bansal, and Christian Szegedy. 2019. Graph Representa-
tions for Higher-Order Logic and Theorem Proving. CoRR
abs/1905.10006 (2019). arXiv:1905.10006 http://arxiv.org/
abs/1905.10006

[35] Lawrence C. Paulson. 1993. Natural Deduction as Higher-
Order Resolution. CoRR cs.LO/9301104 (1993). http://arxiv.
org/abs/cs.LO/9301104

[36] Stephan Schulz. 2013. System Description: E 1.8. In Proc. of
the 19th LPAR, Stellenbosch (LNCS), Ken McMillan, Aart
Middeldorp, and Andrei Voronkov (Eds.), Vol. 8312. Springer.
[37] Taro Sekiyama, Akifumi Imanishi, and Kohei Suenaga.
2017. Towards Proof Synthesis Guided by Neural Machine
Translation for Intuitionistic Propositional Logic. CoRR
abs/1706.06462 (2017). arXiv:1706.06462 http://arxiv.org/
abs/1706.06462

[38] O. Tange. 2011. GNU Parallel - The Command-Line Power
Tool. ;login: The USENIX Magazine 36, 1 (Feb 2011), 42‚Äì47.
http://www.gnu.org/s/parallel

Generating Correctness Proofs with Neural Networks

MAPL ‚Äô20, June 15, 2020, London, UK

[39] James R. Wilcox, Doug Woos, Pavel Panchekha, Zachary
Tatlock, Xi Wang, Michael D. Ernst, and Thomas Anderson.
2015. Verdi: A Framework for Implementing and Formally
Verifying Distributed Systems. In Proceedings of the 36th
ACM SIGPLAN Conference on Programming Language De-
sign and Implementation (PLDI ‚Äô15). ACM, New York, NY,
USA, 357‚Äì368. https://doi.org/10.1145/2737924.2737958
[40] Kaiyu Yang and Jia Deng. 2019. Learning to Prove Theorems
via Interacting with Proof Assistants. CoRR abs/1905.09381
(2019). arXiv:1905.09381 http://arxiv.org/abs/1905.09381
[41] Xuejun Yang, Yang Chen, Eric Eide, and John Regehr. 2011.
Finding and Understanding Bugs in C Compilers. PLDI
(2011).

MAPL ‚Äô20, June 15, 2020, London, UK

Alex Sanchez-Stern, Yousef Alhessi, Lawrence Saul, and Sorin Lerner

A Appendix: Additional Evaluation
We now explore more detailed measurements about proof
production.

Individual Prediction Accuracy

A.1
We want to measure the effectiveness of the predictor
subsystem that predicts proof command pairs (the ùëÉ
function defined in Section 5). To do this, we broke
the test dataset down into individual (linearized) proof
commands, and ran to just before each proof command
to get its prediction context. Then we fed that context
into our predictor, and compared the result to the proof
command in the original solution. Of all the proof com-
mands in our test dataset, we are able to predict 28.66%
(3784/13203) accurately. This includes the correct tac-
tic and the correct argument. If we only test on the
proof commands which are in Proverbot9001‚Äôs predic-
tion domain, we are able to predict 39.25% (3210/8178)
accurately.

During search, our proof command predictor returns
the top N tactics for various values of N, and all of these
proof commands are tried. Therefore, we also measured
how often the proof command in the original proof is in
the top 3 predictions, and the top 5 predictions. For all
proof commands in the data set, the tactic in the original
proof is in our top 3 predictions 38.93% of the time,
and in our top 5 predictions 42.66% of the time. If we
restrict to proof commands in Proverbot9001‚Äôs prediction
domain, those numbers are 52.17% and 60.39%.

A.2 Argument Accuracy
Our argument prediction model is crucial to the success
of our system, and forms one of the main contributions
of our work. To measure its efficacy at improving search
is hard, because it‚Äôs impossible to separate its success
in progressing a proof from the success of the tactic
predictor. However, we can measure how it contributes
to individual prediction accuracy.

On our test dataset, where we can predict the full
proof command in the original proof correctly 28.66% of
the time, we predict the tactic correctly but the argu-
ment wrong 32.24% of the time. Put another way, when
we successfully predict the tactic, we can predict the
argument successfully with 89% accuracy. If we only test
on proof commands within Proverbot9001‚Äôs prediction
domain, where we correctly predict the entire proof com-
mand 39.25% of the time, we predict the name correctly
41.01% of the time; that is, our argument accuracy is
96% when we get the tactic right. It‚Äôs important to
note, however, that many common tactics don‚Äôt take
any arguments, and thus predicting their arguments is
trivial.

A.3 Completion Rate in Proverbot9001‚Äôs

Prediction Domain

Proverbot9001 has a restricted model of proof commands:
it only captures proof commands with a single argument
that is a hypothesis identifier or a token in the goal. As re-
sult, it makes sense to consider Proverbot9001 within the
context of proofs that were originally solved with these
types of proof commands. We will call proofs that were
originally solved using these types of proof commands
proofs that are in Proverbot9001‚Äôs prediction domain.
There are 79 such proofs in our test dataset (15.77% of
the proofs in the test dataset), and Proverbot9001 was
able to solve 48 of them.

What is interesting is that Proverbot9001 is able to
solve proofs that are not in its prediction domain: these
are proofs that were originally performed with proof
commands that are not in Proverbot9001‚Äôs domain, but
Proverbot9001 found another proof of the theorem that is
in its domain. This happened for 49 proofs (out of a total
of 97 solved proofs). Sometimes this is because Prover-
bot9001 is able to find a simpler proof command which
fills the exact role of a more complex one in the original
proof; for instance, destruct (find_symbol ge id) in
an original proof is replaced by destruct find_symbol
in Proverbot9001‚Äôs solution. Other times it is because
Proverbot9001 finds a proof which takes an entirely differ-
ent path than the original. In fact, 31 of Proverbot9001‚Äôs
97 found solutions are shorter than the original. It‚Äôs
useful to note that while previous work had a more ex-
pressive proof command model, in practice it was unable
to solve as many proofs as Proverbot9001 could in our
more restricted model.

Together, these numbers indicate that the restricted
tactic model used by Proverbot9001 does not inhibit its
ability to solve proofs in practice, even when the original
proof solution used tactics outside of that model.

A.4 Data Transformation
Crucial to Proverbot9001‚Äôs performance is its ability to
learn from data which is not initially in its proof com-
mand model, but can be transformed into data which
is. This includes desugaring tacticals like now, splitting
up multi-argument tactics like unfold a, b into single
argument ones, and rearranging proofs with semicolons
into linear series of proof commands. To evaluate how
much this data transformation contributes to the overall
performance of Proverbot9001, we disabled it, and in-
stead filtered the proof commands in the dataset which
did not fit into our proof command model.

With data transformation disabled, and the default
search width (5) and depth (6), the proof completion
accuracy of Proverbot9001 is 15.57% (78/501 proofs).
Recall that with data transformation enabled as usual,

Generating Correctness Proofs with Neural Networks

MAPL ‚Äô20, June 15, 2020, London, UK

this accuracy is 19.36%. This shows that the end-to-end
performance of Proverbot9001 benefits greatly from the
transformation of input data, although it still outper-
forms prior work (CoqGym) without it.

When we measure the individual prediction accuracy
of our model, trained without data transformation, we
see that its performance significantly decreases (16.32%
instead of 26.77%), demonstrating that the extra data
produced by preprocessing is crucial to training a good
tactic predictor.

A.5 Search Widths and Depths
Our search procedure has two main parameters, a search
width, and a search depth. The search width is how many
predictions are explored at each context. The search
depth is the longest path from the root a single proof
obligation state can have.

To explore the space of possible depths and widths, we
varied the depth and width, on our default configuration
without external tooling. With a search width of 1 (no
search, just running the first prediction), and a depth
of 6, we can solve 5.59% (28/501) of proofs in our test
dataset. With a search width of 2, and a depth of 6, we‚Äôre
able to solve 16.17% (81/501) of proofs, as opposed to a
width of 3 and depth of 6, where we can solve 19.36% of
proofs.

To explore variations in depth, we set the width at 3,
and varied depth. With a depth of 2, we were able to
solve 5.19% (26/501) of the proofs in our test set. By
increasing the depth to 4, we were able to solve 13.97%
(70/501) of the proofs in our test set. At a depth of 6
(our default), that amount goes up to 19.36% (97/501).

