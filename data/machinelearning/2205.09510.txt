Foundations and Trends® in Signal Processing
An Introduction to Quantum
Machine Learning for Engineers

Suggested Citation: Osvaldo Simeone (2022), “An Introduction to Quantum Machine
Learning for Engineers”, Foundations and Trends® in Signal Processing: Vol. xx, No. xx,
pp 1–18. DOI: 10.1561/XXXXXXXXX.

2
2
0
2

n
u
J

1
1

]
h
p
-
t
n
a
u
q
[

4
v
0
1
5
9
0
.
5
0
2
2
:
v
i
X
r
a

This article may be used only for the purpose of research, teaching,
and/or private study. Commercial use or systematic downloading
(by robots or other automatic processes) is prohibited without ex-
plicit Publisher approval.

Boston — Delft

 
 
 
 
 
 
Contents

1 Classical Bit (Cbit) and Quantum Bit (Qubit)

Introduction . . . . . . . . . . . . . . . . . . . . . . . . .
1.1
1.2 Random Classical Bit
. . . . . . . . . . . . . . . . . . . .
1.3 Qubit . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4 Single-Qubit Quantum Gates . . . . . . . . . . . . . . . .
1.5 Amplitude Diagrams . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . .
1.6
Interference
. . . . . . . . . . . . . . . . . . . . . . . . .
1.7 Conclusions
1.8 Recommended Resources . . . . . . . . . . . . . . . . . .
1.9 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . .

2 Classical Bits (Cbits) and Quantum Bits (Qubits)

2.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Multiple Random Classical Bits . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .
2.3 Multiple Qubits
2.4 Quantum Circuits and Local Operations . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . .
2.5 Entanglement
2.6 Multi-Qubit Quantum Gates
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . .
2.7 Creating Entanglement
2.8 Amplitude Diagrams . . . . . . . . . . . . . . . . . . . . .
2.9 Superdense Coding . . . . . . . . . . . . . . . . . . . . .

8
8
8
13
18
29
30
33
33
33

35
35
35
42
46
50
55
64
65
66

2.10 Trading Quantum and Classical Resources . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . .
2.11 Conclusions
2.12 Recommended Resources . . . . . . . . . . . . . . . . . .
2.13 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . .

70
71
72
72

3 Generalizing Quantum Measurements (Part I)

75
75
3.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . .
75
3.2 Measurements in an Arbitrary Orthonormal Basis . . . . .
82
3.3 Partial Measurements . . . . . . . . . . . . . . . . . . . .
89
3.4 Non-Selective Partial Measurements and Decoherence . . .
91
3.5 Density Matrices . . . . . . . . . . . . . . . . . . . . . . .
97
3.6 Partial Trace . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . 101
3.7 Conclusions
3.8 Recommended Resources . . . . . . . . . . . . . . . . . . 102
3.9 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 102

4 Quantum Computing

111
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . 111
4.1
4.2 Gate-Based Model of Quantum Computation . . . . . . . 111
4.3 Computing Binary Functions and Quantum RAM . . . . . 113
4.4 Deutsch’s Problem and Quantum Parallelism . . . . . . . 119
4.5 Phase Kick-Back . . . . . . . . . . . . . . . . . . . . . . . 122
4.6 Validity of Deutsch’s Algorithm . . . . . . . . . . . . . . . 124
4.7 No Cloning Theorem . . . . . . . . . . . . . . . . . . . . 126
. . . . . . . . . . . 128
4.8 Classical Cloning: Basis-Copying Gate
. . . . . . . . . . . . . . . . . . . . . . . . . 129
4.9 Conclusions
4.10 Recommended Resources . . . . . . . . . . . . . . . . . . 130
4.11 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 130

5 Generalizing Quantum Measurements (Part II)

131
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . 131
5.1
. . . . . . . . . . . . . . . . . . 131
5.2 Projective Measurements
. . . . . . . . . . . . . . . . . . . . . . . . . 139
5.3 Observables
. . . . . . . . . . 146
5.4
5.5 Quantum Error Correction . . . . . . . . . . . . . . . . . 149
. . . 155
5.6

Implementing Projective Measurements with Ancillas

Implementing Projective Measurements

5.7 Positive Operator-Valued Measurements . . . . . . . . . . 159
. . . . . . . . . . . . . . . . . . . . . 164
5.8 Quantum Channels
. . . . . . . . . . . . . . . . . . . . . . . . . 168
5.9 Conclusions
5.10 Recommended Resources . . . . . . . . . . . . . . . . . . 169
5.11 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 169

6 Quantum Machine Learning

171
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . 171
6.1
. . . . . . . . . . . 172
6.2 What is Quantum Machine Learning?
6.3 A Taxonomy of Quantum Machine Learning . . . . . . . . 174
6.4 Ansatz and Parametrized Quantum Circuits . . . . . . . . 177
6.5 Cost Functions for Quantum Machine Learning . . . . . . 185
6.6 Variational Quantum Eigensolver . . . . . . . . . . . . . . 192
. . . . . . . 197
6.7 Unsupervised Learning for Generative Models
6.8 Supervised Learning . . . . . . . . . . . . . . . . . . . . . 204
6.9 Beyond Generic Ansatzes . . . . . . . . . . . . . . . . . . 213
6.10 Beyond Angle Encoding . . . . . . . . . . . . . . . . . . . 215
. . . . . . . . . . . . . . . . . . . . . . . . . 217
6.11 Conclusions
6.12 Recommended Resources . . . . . . . . . . . . . . . . . . 218
6.13 Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 218

Acknowledgements

References

223

224

An Introduction to Quantum
Machine Learning for Engineers
Osvaldo Simeone1

1King’s College London

ABSTRACT

In the current noisy intermediate-scale quantum (NISQ)
era, quantum machine learning is emerging as a dominant
paradigm to program gate-based quantum computers. In
quantum machine learning, the gates of a quantum circuit
are parametrized, and the parameters are tuned via clas-
sical optimization based on data and on measurements of
the outputs of the circuit. Parametrized quantum circuits
(PQCs) can eﬃciently address combinatorial optimization
problems, implement probabilistic generative models, and
carry out inference (classiﬁcation and regression). This mono-
graph provides a self-contained introduction to quantum
machine learning for an audience of engineers with a back-
ground in probability and linear algebra. It ﬁrst describes
the necessary background, concepts, and tools necessary to
describe quantum operations and measurements. Then, it
covers parametrized quantum circuits, the variational quan-
tum eigensolver, as well as unsupervised and supervised
quantum machine learning formulations.

Osvaldo Simeone (2022), “An Introduction to Quantum Machine Learning for
Engineers”, Foundations and Trends® in Signal Processing: Vol. xx, No. xx, pp 1–18.
DOI: 10.1561/XXXXXXXXX.
©2022 ...

Preface

Motivation

As many engineers, I have developed an early fascination for quantum
theory – for its history, its counterintuitive predictions, its central role in
the development of many existing technologies (semiconductors, lasers,
MRI, atomic clocks) and, perhaps above all, its promise to unlock future,
revolutionary, paradigms in materials, chemical, industrial, computer,
and communication engineering.

At ﬁrst, the topic is inviting for an engineer with my background on
electrical and information engineering: The mathematical formalism is
familiar, based as it is on linear algebra and probability; and concepts
with wide-ranging and intriguing implications, such as superposition
and entanglement, can be easily described on paper. Spend more time
with it, however, and the ﬁeld reveals its complexity, becoming for many,
the former me included, too abstruse to invite further study. Particu-
larly unfamiliar are ideas and architectures underlying key quantum
algorithms, such as Shor’s factorization method. As if that was not
enough, the impressions that most algorithmic breakthroughs are by
now textbook material, and that all the “action” is currently focused
on scaling hardware implementations, have kept me from engaging with
the state of the art on quantum computing.

This monograph is motivated by a number of recent developments

2

3

that appear to deﬁne a possible new role for researchers with an engineer-
ing proﬁle similar to mine. First, there are now several software libraries
– such as IBM’s Qiskit, Google’s Cirq, and Xanadu’s PennyLane – that
make programming quantum algorithms more accessible, while also
providing cloud-based access to actual quantum computers. Second, a
new framework is emerging for programming quantum algorithms to be
run on current quantum hardware: quantum machine learning.

Quantum Machine Learning

Quantum computing algorithms have been traditionally designed by
hand assuming the availability of fault-tolerant quantum proces-
sors that can reliably support a large number of qubits and quantum
operations, also known as quantum gates. A qubit is the basic unit
of quantum information and computing, playing the role of a bit in
classical computers. In practice, current quantum computers imple-
ment a few tens of qubits, with quantum gates that are inherently
imperfect and noisy. Quantum machine learning refers to an emerg-
ing, alternative design paradigm that is tailored for current noisy
intermediate-scale quantum (NISQ) computers. The approach fol-
lows a two-step methodology akin to classical machine learning. In it,
one ﬁrst ﬁxes a priori a, possibly generic, parametrized architecture
for the quantum gates deﬁning a quantum algorithm, and then uses
classical optimization to tune the parameters of the gates.

In more detail, as sketched in Fig. 1, in quantum machine learning,
the quantum algorithm is deﬁned by a quantum circuit – denoted
as U (θ) in the ﬁgure – whose constituent quantum gates implement
operations that depend on a vector θ of free parameters. Measurements
of the quantum state produced by the quantum circuit produce classical
information that is fed to a classical processor, along with data. The
classical optimizer produces updates to the vector θ with the goal of
minimizing some designer-speciﬁed cost function.

The quantum machine learning architecture of Fig. 1 has a number
of potential advantages over the traditional approach of handcrafting
quantum algorithms assuming fault-tolerant quantum computers:

4

Figure 1: Illustration of the quantum machine learning design methodology: A
parametrized quantum circuit with a pre-speciﬁed architecture is optimized via its
vector of parameters, θ, by a classical optimizer based on data and measurements
of its outputs. As we will see in this monograph, the operation of a parametrized
quantum circuit is deﬁned by a unitary matrix U (θ) dependent on vector θ. The
block marked with a gauge sign represents quantum measurements, which convert
quantum information produced by the quantum circuit into classical information. This
conversion is inherently random, and measurement outputs are typically averaged
before being fed to the classical optimizer.

• By keeping the quantum computer in the loop, the classical opti-
mizer can directly account for the non-idealities and limitations
of quantum operations via measurements of the output of the
quantum computer.

• If the parametrized quantum algorithm is suﬃciently ﬂexible and
the classical optimizer suﬃciently eﬀective, the approach may
automatically design well-performing quantum algorithms that
would have been hard to optimize by hand via traditional formal
methods.

Quantum machine learning, intended as the study of applications
of parametrized quantum circuits, is distinct from the related topic of
quantum-aided classical machine learning. The aim of this older line of
work is to speed up classical machine learning methods by leveraging
traditional quantum computing subroutines. This monograph will focus
solely on quantum machine learning as illustrated in Fig. 1.

Important open research questions in the ﬁeld of quantum machine
learning are discussed at the end of this text. It is my hope that

classical optimizeraverage5

researchers who may not have otherwise contributed to these research
directions would be motivated to do so upon reading these pages.

Goal and Organization

The main goal of this monograph is to present a self-contained introduc-
tion to quantum information processing and quantum machine learning
for a readership of engineers with a background in linear algebra and
probability. My ambition in presenting this text is to oﬀer a resource
that may allow more researchers with no prior exposure to quantum
theory to contribute to the ﬁeld of quantum machine learning with new
ideas and methods.

The monograph is written as a textbook, with no references except
for end-of-chapter sections. References are kept to a minimum, and
are mostly limited to books that the reader may peruse for additional
information on diﬀerent topics introduced in these pages. I have also
included problems at the end of each chapter with the main aims of
reviewing some key ideas described in the text and of inviting the reader
to explore topics beyond this monograph.

It may be worth emphasizing that the text is meant to be read
sequentially, as I have attempted to introduce notations and concepts
progressively from the ﬁrst page to the last page.

The monograph does not include discussions about speciﬁc appli-
cations and use cases. There are several reasons for this. First, many
applications are domain speciﬁc, pertaining ﬁelds like quantum chem-
istry, and are deemed to be outside the scope of this text, which focuses
on concepts and tools. Second, many existing generic tasks and data
sets currently used in the quantum machine learning literature are quite
simplistic, and they arguably yield little insight into the potential of
the technology. The reader is referred to research papers, appearing on
a daily basis on repositories like arXiv, for up-to-date results, including
new benchmarks and experiments.

The rest of the text is organized in the following chapters.
Chapter 1. Classical bit (cbit) and quantum bit (qubit):
This chapter introduces the concept of qubit through an algebraic
generalization of random classical bits (cbits). A qubit can evolve in

6

quantum systems via reversible linear (unitary) transformations – also
known as quantum gates – or via measurements. The mathematical
formalism underlying the description of both quantum gates and mea-
surements is also covered in the chapter. Finally, the chapter illustrates
a key diﬀerence in the behavior of random cbits and qubits, namely the
phenomenon of interference.

Chapter 2. Classical bits (cbits) and quantum bits (qubits):
This chapter extends the concepts introduced in the previous chapter,
including quantum gates and measurements, to systems comprising
multiple qubits. The new phenomenon of entanglement – a form of
correlation between quantum systems with no classical counterpart –
is introduced, and superdense coding is presented as an application of
entanglement.

Chapter 3. Generalizing quantum measurements (Part I):
The third chapter presents two important generalizations of quantum
measurements, namely measurements in an arbitrary basis and non-
selective measurements. Decoherence, density matrices, and partial trace
are also presented as concepts arising naturally from the introduction
non-selective measurements.

Chapter 4. Quantum computing: Chapter 4 presents a brief
introduction to the traditional approach for the design of quantum
algorithms in gate-based quantum computers. This presentation culmi-
nates in the description of Deutsch’s algorithm, the ﬁrst example of a
quantum solution that can provably improve over classical algorithms.
The chapter also describes the no cloning theorem, which sets important
constraints on the design of quantum computing algorithms.

Chapter 5. Generalizing quantum measurements (Part II):
This chapter presents two further extensions of quantum measurements:
projective measurements and positive operator-valued measurements
(POVMs). POVMs represent the most general form of quantum mea-
surement. As an example of the application of projective measurements,
the problem of quantum error correction is brieﬂy introduced; while un-
ambiguous state detection is presented as technique enabled by POVMs.
Observables are covered, and the chapter ends with a description of
quantum channels as non-selective quantum measurements.

Chapter 6. Quantum machine learning: The ﬁnal chapter pro-

7

vides an introduction to quantum machine learning that builds on
the material covered in the previous chapters. After a description of
the taxonomy of quantum machine learning methods, the concepts of
parametrized quantum circuits and ansatz are introduced, along with
the deﬁnition of cost functions used in quantum machine learning. These
are leveraged to describe the variational quantum eigensolver (VQE),
as well as unsupervised and supervised learning strategies for settings
in which data are classical and processing is quantum. An outlook is
also provided pointing to more advanced techniques and directions for
research.

1

Classical Bit (Cbit) and Quantum Bit (Qubit)

1.1 Introduction

This chapter introduces the qubit as the basic unit of quantum infor-
mation and computing. To this end, we start by reviewing classical bits
(cbits) and random cbits. Then, we present the qubit as an algebraic
“extension” of the two-dimensional probability distribution of a random
cbit to a complex, normalized, two-dimensional vector. The chapter will
also present the two main ways in which a qubit can evolve over time:
unitary operations, also known as quantum gates, and measurements.
While quantum gates describe the evolution of a qubit in a closed system,
measurements convert quantum information to classical information by
coupling the qubit with a measurement instrument.

1.2 Random Classical Bit

We start by introducing some basic notation and key ideas used in
quantum theory by considering the reference case of a classical bit.

8

1.2. Random Classical Bit

9

cbit

amplitude vector

0

1

|0i =

|1i =

(cid:21)

(cid:21)

(cid:20) 1
0
(cid:20) 0
1

Table 1.1: A cbit can be represented as a binary digit or as a two-dimensional
one-hot vector, with the latter being described using Dirac’s ket notation.

1.2.1 A Classical Bit as a One-Hot Vector

A classical bit (cbit) is a system that can be in two unambiguously
distinguishable, or orthogonal, levels. Examples include on-oﬀ switches
and up-down magnets. Mathematically, the state of a cbit is represented
by a logical binary digit taking value 0 or 1.

Alternatively, the state of a cbit can be described by a two-dimensional
“one-hot” amplitude vector. As illustrated in Table 1.1, the one-hot
amplitude vector contains a single “1” digit, whose position indicates
whether the cbit takes value 0 or 1. Speciﬁcally, a cbit taking value 0 is
encoded by a one-hot vector with a “1” digit in the ﬁrst position, while
a cbit taking value 1 is encoded by one-hot vector with a “1” digit in
the second position.

1.2.2 Dirac’s Ket and Bra Notations

Dirac’s ket notation is conventionally used in quantum theory to identify
column vectors. Accordingly, a column vector is represented as |ai, where
a is an identiﬁer for the vector. For a single cbit, as illustrated in Table
1.1, the ket vector representing the cbit value 0, which serves as identiﬁer,
is the one-hot amplitude vector

|0i =

" 1
0

#

,

while the ket vector representing the cbit value 1 is

|1i =

" 0
1

#

.

(1.1)

(1.2)

10

Classical Bit (Cbit) and Quantum Bit (Qubit)

Dirac’s bra notation is used to identify row vectors. Given a ket
|ai, the bra ha| is deﬁned as the Hermitian transpose of the ket vector
|ai, i.e.,

ha| = |ai†,

(1.3)

where † represents the Hermitian transpose operation. The Hermitian
transpose is given by the cascade of a transposition operation, denoted
as (·)T , and of an element-wise complex conjugation, denoted as (·)∗,
i.e., (·)† = ((·)T )∗. For example, the bra vector corresponding to the bit
value 1 is

h1| = [ 0 1 ].

(1.4)

We will see later in this chapter that quantum states involve complex
numbers, making it important to use a Hermitian transpose, rather
than a standard transpose, operation to deﬁne the bra in (1.3).

The inner product between two kets |ai and |bi is deﬁned as

|ai†|bi = ha||bi = ha|bi,

(1.5)

where the last expression is known as Dirac’s bra-ket notation for the
inner product. (The pun is intended.) Note that we have the equality

hb|ai = ha|bi∗,

(1.6)

where we recall that (·)∗ represents the complex conjugate operation.
The squared ‘2 norm of a ket |ai is accordingly deﬁned as

|||ai||2
2

= ha|ai.

(1.7)

Note that the subscript in || · ||2 identiﬁes the type of norm. In this
monograph, we will only use the ‘2 norm, and hence we will use the
term norm for the operation || · ||2.

The kets |0i and |1i deﬁne an orthonormal basis for the linear
space of two-dimensional vectors. In fact, the two vectors are orthogonal,
i.e.,

and they have unitary norm, i.e.,

h0|1i = h1|0i = 0,

h0|0i = h1|1i = 1.

(1.8)

(1.9)

1.2. Random Classical Bit

11

Throughout this monograph, for reasons that will be made clear
later in this chapter, we will take all bra and ket vectors (not only
|0i and |1i) to have unitary norm. The assumption of unitary norm
vectors amounts to the condition

|||ai||2
2

= ||ha|||2
2

= ha|ai = 1

(1.10)

for all kets |ai.

1.2.3 A Random Cbit as a Probability Vector

The amplitude, one-hot, vector representation of a cbit is clearly less
eﬃcient than the direct speciﬁcation in terms of a single logical bit. In
fact, the one-hot vector requires two binary digits to describe a single
cbit. Despite this shortcoming, amplitude vectors are routinely used in
machine learning when dealing with discrete random variables.

The probability distribution, or probability mass function,

of a random cbit is given by the two-dimensional vector

p =

"

#

,

p0
p1

(1.11)

where px ≥ 0 represents the probability of the random cbit taking value
x ∈ {0, 1}, and we have the condition

p0 + p1 = 1.

(1.12)

Note that the norm of a probability vector is generally diﬀerent from 1.
Hence, following the convention described in the previous subsection,
the ket notation is not used for vector p.

By the deﬁnition (1.11), the probability of observing value x ∈ {0, 1}

can be computed via the inner product

|xi†p = hx|p = px,

(1.13)

where we recall that |xi is the one-hot amplitude vector representing
cbit value x ∈ {0, 1} (see Table 1.1). Geometrically, the inner product
(1.13) can be interpreted as the projection of the probability vector p
into the direction deﬁned by vector |xi.

12

Classical Bit (Cbit) and Quantum Bit (Qubit)

Being two dimensional, the probability vector (1.11) for a single
random cbit can be written as a linear combination of the orthonormal
basis vectors {|0i, |1i} as

"

p =

#

p0
p1

= p0|0i + p1|1i.

(1.14)

In words, the probability vector (1.11) can be viewed as the “superposi-
tion” of the two orthogonal vectors |0i and |1i, each representing one of
the two possible states of the system. The weights of this superposition
are given by the corresponding probabilities p0 and p1.

1.2.4 Measuring a Random Cbit

A random cbit seems to “contain more information” than a deterministic
one, since its state is deﬁned by the probability vector p. This is in the
sense that, in order to specify the state of a random cbit, one needs to
describe the probability p0 or p1 (since p0 + p1 = 1), while the state of
a deterministic cbit is clearly described by a single binary digit. But
how much information can be actually extracted from the observation
of a deterministic cbit or a random cbit?

Suppose ﬁrst that you are handed a deterministic cbit, e.g., a coin
resting on one of its two faces. Evidently, a single glance at the coin
would reveal its binary value.

Consider now being given a random cbit – say a slot machine with
a single arm producing either digit 0 or 1 with probabilities p0 and p1,
respectively. In order to extract the state of the random cbit, that is, its
probability vector p, a single “glance” is not suﬃcient. Rather, one needs
to carry out multiple measurements of the random cbit, producing a
number of independent realizations of the random cbit, each drawn from
probability distribution p. From the obtained measurement outputs,
one can estimate the probability px, for x ∈ {0, 1}, by evaluating the
fraction of realizations of the random cbit with value x.

In the example of the slot machine, obtaining multiple measurements
entails playing the arm of the slot machine several times. Importantly,
each independent measurement requires that the system be reset to the
original state so as to generate a new realization of the same random

1.3. Qubit

13

cbit. Quantitatively, using the outlined fraction-based estimator, by
Chebyshev’s inequality, one needs O(1/(cid:15)2) independent measurements
of the random cbits in order to produce an estimate with precision
(cid:15) > 0.

1.3 Qubit

In this section, building on the basic background material presented so
far in this chapter, we introduce the notion of a qubit.

1.3.1 A Qubit as a Complex Amplitude Vector

A quantum bit (qubit) is a two-level quantum system, such as the
up-down spin of an electron or the vertical-horizontal polarization of
a photon. In a manner somewhat analogous to a random cbit, whose
state is deﬁned by a probability vector p as in (1.14), the state of a
qubit is described by a two-dimensional amplitude vector

|ψi =

#

"

α0
α1

= α0|0i + α1|1i.

(1.15)

There are two key diﬀerences between the state |ψi in (1.15) of a
quantum qubit and the state p of a random cbit:

• Unlike a probability vector p, the amplitude vector has complex
entries α0 and α1. (Note that complex entries include real-valued
entries as a special case.)

• The qubit state vector (1.15) has the deﬁning property of having

unitary norm, i.e.,

|||ψi||2
2

= hψ|ψi = |α0|2 + |α1|2 = 1.

(1.16)

This condition is diﬀerent from the property (1.12) satisﬁed by
probability vectors, which stipulates that the sum of the entries
of p – and not the norm of the vector – equals 1. We observe that
property (1.16) is consistent with the convention introduced in
the previous section of considering all kets (and bras) to have
unitary norm.

14

Classical Bit (Cbit) and Quantum Bit (Qubit)

Figure 1.1: (left) An illustration of the two-dimensional Hilbert space with the
computational basis {|0i, |1i} and a given qubit state |ψi in (1.15); (right) An
illustration of computational and diagonal bases.

While being distinct from the state of a random cbit, the qubit
state (1.15) recovers as special cases the two possible states, expressed
as one-hot amplitude vectors, of a deterministic cbit. In fact, setting
the amplitudes as α0 = 1 (and hence α1 = 0), or α1 = 1 (and hence
α0 = 0), recovers the deterministic cbit states |0i and |1i, respectively.
Therefore, a qubit that can only assume states |0i and |1i is equivalent
to a deterministic cbit.

By (1.15), we say that the qubit is in a superposition of states
|0i and |1i, with respective complex amplitudes α0 and α1. Mathemat-
ically, this implies that the state of a qubit is a vector that lies in a
two-dimensional complex linear vector space, referred to as the Hilbert
space of dimension two. The states |0i and |1i form the so-called com-
putational basis of the Hilbert space. A geometric interpretation of a
quantum state, simpliﬁed by representing real amplitudes, is provided
by the left part of Fig. 1.1.

Being a two-dimensional vector, the state of the qubit can be equiv-
alently expressed as a superposition of any two orthonormal vectors
forming a basis of the Hilbert space. An important example is given by
the so-called diagonal basis, which consists of the two vectors

and

|+i =

1
√
2

(|0i + |1ii =

#

1
√
2

" 1
1

|−i =

1
√
2

(|0i − |1i) =

1
√
2

" 1
−1

#

.

(1.17)

(1.18)

1.3. Qubit

15

|ψi = α0 |0i + α1 |1i

|xi w.p. |αx|2

x

Figure 1.2: A von Neumann measurement in the computational basis, also known
as a standard measurement, for a single qubit. (The abbreviation “w.p.” stands for
“with probability”.)
It can be directly checked that vectors |+i and |−i are orthogonal and
that they have unitary norm. They are illustrated in the right part of
Fig. 1.1. The qubit state (1.15) can be expressed as a superposition of
diagonal states as

|ψi =

"

#

=

1
√
2

α0
α1

(α0 + α1)|+i +

1
√
2

(α0 − α1)|−i.

(1.19)

√

Therefore, the amplitude of the basis vector |+i is given by the scaled
2(α0 + α1), while the amplitude of the basis vector |−i is given
sum 1/
by the scaled diﬀerence 1/

2(α0 − α1).

√

1.3.2 Measuring a Qubit: von Neumann Measurements

In a manner somewhat similar to a random cbit (see Sec. 1.2.4), the state
of a qubit is only accessible through measurements of the qubit. Note
that we will henceforth refer to a qubit and to its state interchangeably.
A measurement takes as input a qubit in an arbitrary state |ψi, as in
(1.15), and produces a cbit as the measurement’s output, while leaving
the qubit in a generally diﬀerent state from the original state |ψi.

The most basic type of measurement is known as von Neumann
measurement in the computational basis, or standard measure-
ment for short. Given an input qubit state |ψi = α0|0i + α1|1i, a stan-
dard measurement is deﬁned by the following two properties illustrated
in Fig. 1.2:

• Born’s rule: The probability of observing cbit x ∈ {0, 1} is

Pr[measurement output equals x ∈ {0, 1}] = |αx|2;

(1.20)

• “Collapse” of the state: If the measured cbit is x ∈ {0, 1}, the

post-measurement state of the qubit is |xi.

Measurements are typically depicted as shown in Fig. 1.2. Accord-
ingly, a measurement is denoted via a gauge block, with the output

16

Classical Bit (Cbit) and Quantum Bit (Qubit)

cbit x ∈ {0, 1} indicated on top of the block and the post-measurement
state shown as the output to the right of the block.

By the Born rule (1.20), the absolute value squared |αx|2 of the
quantum amplitude αx deﬁnes the probability of a measurement out-
come x ∈ {0, 1}. Geometrically, this probability corresponds to the
magnitude squared of the projection of the input state |ψi into the
computational-basis vector |xi (see Fig. 1.1). Note that the quadratic
dependence of the measurement probabilities on the amplitudes in the
qubit state vector explains the diﬀerence between the conditions (1.12)
and (1.16) satisﬁed by probability vectors and amplitude vectors. One
possible way to think of the absolute value squared of the amplitude
that appears in Born’s rule (1.20) is as a measure of intensity, e.g., of a
photon beam.

The Born rule can be equivalently expressed using the bra-ket
notation by noting that the x-th amplitude of qubit state |ψi can be
obtained as

which implies

αx = |xi†|ψi = hx|ψi,

|αx|2 = |hx|ψi|2.

(1.21)

(1.22)

It is also useful to note that, by (1.22), the probability |αx|2 can be
expressed as

|αx|2 = hx|ψihx|ψi∗ = hx|ψihψ|xi = hx|ρ|xi,

(1.23)

where ρ = |ψihψ| is the so-called density matrix associated with state
|ψi, which will be formally introduced in Chapter 3.

By the “collapse”-of-the-state property, while the input state |ψi is
generally unknown (that is why one measures it), the post-measurement
state is fully determined by the output of the measurement. In fact, the
measurement “collapses” the input qubit state |ψi to the computational-
basis vector |xi corresponding to the measurement’s output cbit x ∈
{0, 1}.

As we have discussed in the previous subsection, a qubit that can
only take states |0i and |1i behaves like a standard deterministic cbit.
As a sanity check, one can directly verify that, by Born’s rule, measuring

1.3. Qubit

17

a qubit in state |xi, for x ∈ {0, 1}, returns output x with probability 1,
while leaving the qubit state unchanged.

To conclude this section, it should be mentioned that the interpreta-
tion of the “collapse”-of-the-state property is much debated in physics
and philosophy (and in movies, where the “many-world” interpretation
provides an easy excuse for a plot twist).

We will see in Chapter 3, and then again in Chapter 5, that there
are diﬀerent types of measurements; until then, we will always assume
standard measurements.

1.3.3 Random Cbit vs. Qubit

By Born’s rule, if the amplitudes {αx}1
x=0
we can write the state (1.15) of a qubit as

are real and non-negative,

|ψi =

" √

p0√
p1

#

,

(1.24)

where px is the probability (1.20) that a measurement of the qubit
returns the cbit x. Accordingly, there may be a temptation to think
of a qubit state as the square root of a probability vector. Even more
treacherously, this perspective may lead one to treat a qubit as merely
being a random cbit deﬁned by a probability vector p = [|α0|2, |α1|2]T .
Accordingly, one would model a qubit in the superposition state (1.15)
as having a true, but unknown, classical state |xi, with x ∈ {0, 1}, which
is only revealed upon measurement. This temptation should be resisted!
By Born’s rule (1.20), the viewpoint described in the previous
paragraph provides the correct description of the output of the standard
measurement of a qubit. However, a qubit in state (1.24) behaves very
diﬀerently from a random cbit state deﬁned by the probability vector
p = [|α0|2, |α1|2]T in terms of how it evolves over time and of how it
interacts with other qubits. Speciﬁcally, as we will detail in Sec. 1.6,
the two amplitudes α0 and α1 deﬁning the superposition state |ψi can
combine over time in ways that produce subsequent measurements that
cannot be described by the evolution of a random cbit. (So, Schrodinger’s
cat is actually neither dead nor alive, but it behaves according to a
superposition of the two states.)

18

Classical Bit (Cbit) and Quantum Bit (Qubit)

1.4 Single-Qubit Quantum Gates

In this section, we describe how the state of a qubit evolves in a closed
quantum system, introducing the key concept of a quantum gate.

1.4.1 Closed Quantum Systems and Unitary Transformations

Consider a closed quantum system consisting of a single qubit that
is not subject to measurement. Note that implementing a measurement
would require the presence of an instrument connecting the qubit to
the outside world of an “observer”. In a closed system, by the laws of
quantum physics, the state of a qubit evolves according to linear and
reversible transformations. Linearity may come as a surprise, as
one may expect that nature could produce more complex behavior, but
it is a model that has stood the test of time through a large number of
experimental validations. Reversibility is a consequence of the principle
that a closed system should conserve information.

To elaborate on this last point, irreversible operations imply a loss of
information, and deleting information requires energy. By Landauer’s
principle, it speciﬁcally requires kBT ln(2) joule per bit, where kB is
the Boltzmann constant and T is the temperature of the heat sink in
kelvins. Therefore, a closed system consisting of a single qubit cannot
delete information, as this would entail the injection of energy from the
outside. It follows that transformations in a closed system should be
reversible. In contrast, measurements correspond to interactions with
external instruments, and are not reversible.

The only non-trivial linear reversible operation mapping a determin-
istic cbit state to a deterministic cbit state is the NOT, or bit ﬂip,
operation. The NOT operation is deﬁned by the logical mapping

0 7→ ¯0 = 1,

(1.25)

and

1 7→ ¯1 = 0,
where the bar notation indicates logical negation. The NOT operation
can be hence summarized as

(1.26)

x 7→ ¯x = x ⊕ 1,

(1.27)

1.4. Single-Qubit Quantum Gates

19

|ψi
input qubit state

U

U |ψi
output qubit state

Figure 1.3: The state of a qubit evolves in a closed system according to the product
of the input state |ψi by a unitary matrix U , also known as a single-qubit quantum
gate.

where ⊕ indicates the XOR operation.

The NOT mapping deﬁned by (1.27) can be expressed in terms of
the one-hot representation of the state of a cbit by introducing the 2 × 2
Pauli X matrix

X =

#

" 0 1
1 0

.

(1.28)

In fact, given the input state |xi of a cbit with x ∈ {0, 1} (see Table
1.1), the state of the cbit at the output of a NOT operation (1.25)-(1.26)
is given by the one-hot amplitude vector

X|xi = |¯xi = |x ⊕ 1i.

(1.29)

The Pauli X matrix (1.28), describing a NOT operation, has the

following property

XX † = X †X = I,

where I denotes the 2 × 2 identity matrix
#

I =

" 1 0
0 1

.

(1.30)

(1.31)

The equalities in (1.30) are the deﬁning properties of the class of unitary
matrices.

More broadly, any reversible linear transformations mapping a qubit
state into a qubit state is described by a 2 × 2 unitary matrix U ; and,
conversely, any unitary matrix U deﬁnes a linear reversible transforma-
tion between quantum states. Generalizing (1.30), a unitary matrix U
satisﬁes the equalities

U U † = U †U = I.

(1.32)

Hence, the inverse of a unitary matrix equals its Hermitian transpose,
i.e., we have U −1 = U †. A unitary matrix maps a qubit state into a
qubit state, since it conserves the norm of the input vector, i.e.,

||U |ψi||2
2

= hψ|U †U |ψi = |||ψi||2
2

= 1,

(1.33)

20

Classical Bit (Cbit) and Quantum Bit (Qubit)

|ψi

X

X |ψi

|ψi

X |ψi

Figure 1.4: Two equivalent representations of a Pauli X, or NOT, gate.

where we have used (1.32).

To summarize, as illustrated in Fig. 1.3, in a closed system, a qubit

in state |ψi evolves to the state

|ψ0i = U |ψi

(1.34)

for some unitary matrix U . This transformation is linear and reversible.
In fact, by (1.32), one can return the qubit to the initial state |ψi by
applying the transformation U † (also unitary by (1.32)), i.e.,

|ψi = U †|ψ0i.

(1.35)

An example of a unitary transformation is given by the NOT, or Pauli
X, matrix (1.28), which is typically depicted in one of the two ways
shown in Fig. 1.4.

1.4.2 Quantum Gates

By the discussion so far in this subsection, any unitary matrix U is
in principle physically realizable as the evolution of a closed quantum
system. A unitary matrix operating on a single qubit is referred to as a
single-qubit quantum gate in the context of quantum computing.
In practice, as illustrated in Fig. 1.5, a transformation U of a qubit
in a quantum computer is typically implemented via a cascade of basic
single-qubit quantum gates selected from a library of transformations
available in the given quantum system. This cascade can be expressed
mathematically as the product

U = UK · UK−1 · · · U1,

(1.36)

where the 2 × 2 unitary matrices Uk with k ∈ {1, 2, ..., K} represent
the operation of basic quantum gates. Note that the product of unitary
matrices is also unitary (as it can be checked by using (1.32)).

1.4. Single-Qubit Quantum Gates

21

name

identity

Pauli X

Pauli Z

operator

I =

X =

#

#

" 1 0
0 1
" 0 1
1 0

Z =

#

" 1

0
0 −1

Pauli Y

Y = iXZ =

#

" 0 −i
0
i

Hadamard

H = 1√
2

#

" 1

1
1 −1

= 1√
2

(X + Z)

Pauli Y -rotation RY (θ) =

" cos(θ/2) − sin(θ/2)
cos(θ/2)

sin(θ/2)

#

Table 1.2: Examples of notable single qubit-quantum gates.

Accordingly, as in Fig. 1.5, the evolution of a qubit in a closed
quantum system can be generally described by a quantum circuit
in which a wire represents a qubit, and multiple quantum gates are
applied in the order from left to right. Note that the order in which the
quantum gates are applied to the input state is the inverse of the order
in which the corresponding matrices appear in the product (1.36) when
read from left to right.

Examples of basic single-qubit quantum gates implemented in stan-
dard quantum computers are given in Table 1.2. These include the four
Pauli matrices, or Pauli operators, namely I (the identity matrix),
X, Y , and Z; the Hadamard gate H; and the Pauli Y -rotation
RY (θ). The Pauli matrices X, Y , and Z are related by the cyclic
product properties XY = iZ, Y Z = iX, and ZX = iY , where i is
the complex unit. They are also anti-commuting in the sense that we
have the products P1P2 = −P2P1 with P1, P2 ∈ {X, Y, Z} and P1 6= P2.
In the next two subsections, we describe three useful characteriza-

22

Classical Bit (Cbit) and Quantum Bit (Qubit)

|ψi

U1

U2

· · ·

UK

UK · · · U2U1 |ψi

Figure 1.5: Example of quantum circuit describing the evolution of the state of a
qubit in a closed system as a cascade of single-qubit quantum gates implementing
unitary matrices U1, U2,..., and UK .
tions of unitary matrices and hence of quantum gates.

1.4.3 Quantum Gates as Change-of-Basis Transformations

Any unitary matrix operating on a qubit can be expressed as

U = |v0ihu0| + |v1ihu1|,

(1.37)

where {|v0i, |v1i} and {|u0i, |u1i} are two orthonormal bases of the
two-dimensional Hilbert space. By (1.37), we can interpret a unitary
operator as mapping each vector |uxi from one orthonormal basis to
a vector |vxi in another orthonormal basis for x ∈ {0, 1}. In fact, by
(1.37), we have the mapping

U |uxi = (|v0ihu0| + |v1ihu1|)|uxi
= |v0ihu0|uxi + |v1ihu1|uxi
= |vxi

(1.38)

for x ∈ {0, 1}. Therefore, a unitary matrix (1.37) applies a change of
basis from basis {|u0i, |u1i} to basis {|v0i, |v1i}. A geometric interpre-
tation is provided in Fig. 1.6.

By linearity, once one speciﬁes the operation of a unitary matrix on
the two vectors of an orthonormal basis {|u0i, |u1i}, as in (1.37), the
output of the matrix-vector multiplication U |ψi is deﬁned for any qubit
state |ψi. In fact, as discussed in Sec. 1.3.1, any qubit state |ψi can be
expressed as the superposition |ψi = α0|u0i + α1|u1i of the two vectors
|u0i and |u1i. Therefore, we have the equality

U |ψi = α0U |u0i + α1U |v1i
= α0|v0i + α1|v1i.

(1.39)

Table 1.3 reports some examples of single-qubit quantum gates

expressed in the form (1.37), which are detailed next.

1.4. Single-Qubit Quantum Gates

23

• Identity gate: The identity “gate” maps any quantum state to
itself. Therefore, the form (1.37) applies with any orthonormal basis
{|uxi = |vxi}1

, i.e., we have

x=0

I = |v0ihv0| + |v1ihv1|.

(1.40)

Condition (1.40) is also known as a resolution of the identity.
• Pauli X, or NOT, gate: The Pauli X, or NOT, gate acts as a bit
ﬂip, mapping state |0i to |1i, and state |1i to |0i. By (1.29), the Pauli
X gate can be also thought of as a shift operator, as it maps each
vector |xi, with x ∈ {0, 1}, to the “shifted” version |x ⊕ 1i with “shift”
given by 1. Given a qubit state in the superposition (1.15), the eﬀect of
the Pauli X gate is to assign amplitude α0 to the basis vector |1i and
the amplitude α1 to the basis vector |0i, i.e.,

X(α0|0i + α1|1i) = α0|1i + α1|0i.

(1.41)

• Pauli Z gate: While the Pauli X operator swaps the amplitudes of
the computational basis vectors, the Pauli Z gate swaps the amplitudes
of the vectors in the diagonal basis {|+i, |−i} – an operation known as
phase ﬂip. The name is a consequence of the fact that the Z operator
ﬂips the phase of the amplitude of the |1i vector for an arbitrary input
state (1.15), in the sense that we have

Z(α0|0i + α1|1i) = α0|0i − α1|1i.

(1.42)

• Hadamard gate: The Hadamard gate transforms the computational
basis into the diagonal basis and back, in the sense we have the equalities

as well as

H|0i = |+i and H|1i = |−i,

H|+i = |0i and H|−i = |1i.

(1.43)

(1.44)

The Hadamard gate can be thought of as performing a two-dimensional
discrete Fourier transform, as well as the corresponding inverse discrete
Fourier transform. In this interpretation, the vector |+i represents
the zero-frequency (i.e., constant) signal, and the vector |−i is the
maximum-frequency signal.

24

Classical Bit (Cbit) and Quantum Bit (Qubit)

Figure 1.6: A geometric illustration of the operation of a unitary matrix as the
change-of-basis transformation (1.37).

name

operator

identity

I =

#

" 1 0
0 1

= |v0ihv0| + |v1ihv1| for any orth. basis {|vxi}1

x=0

Pauli X

Pauli Z

Hadamard

X =

#

" 0 1
1 0

= |0ih1| + |1ih0|

#

= |+ih−| + |−ih+|

Z =

" 1

0
0 −1
#

H = 1√
2

" 1

1
1 −1

= |0ih+| + |1ih−| = |+ih0| + |−ih1|

Table 1.3: Examples of single-qubit quantum gates as change-of-basis transforma-
tions deﬁned by the decomposition (1.37).

1.4. Single-Qubit Quantum Gates

25

1.4.4 Quantum Gates as Transformations with Unitary-Magnitude

Eigenvalues

To introduce an alternative interpretation of quantum gates, we will
need to review ﬁrst the spectral theorem, which applies to normal
matrices. A normal matrix A is a square N × N matrix that satisﬁes
the condition

AA† = A†A.

(1.45)

By the spectral theorem, any normal matrix can be expressed in
terms of its eigendecomposition

A =

N −1
X

x=0

λx|vxihvx|,

(1.46)

where {|vxi}N −1
x=0
of the N -dimensional Hilbert space, and {λx}N −1
x=0
eigenvalues, which are generally complex.

are the eigenvectors, which form an orthonormal basis
are the corresponding

Using the eigendecomposition (1.46), given a normal matrix A and

a scalar function f (·), we deﬁne the matrix function

f (A) =

N −1
X

x=0

f (λx)|vxihvx|.

(1.47)

That is, function f (A) is evaluated by applying the scalar function f (·)
separately to each eigenvalue of matrix A.

A unitary matrix U is a normal matrix, since it satisﬁes the condition
(1.32) and hence also the equality (1.45). Therefore, a 2 × 2 unitary
matrix can be expressed in terms of its eigendecomposition (1.46) with
N = 2 eigenvectors and eigenvalues, i.e., as

U = λ0|v0ihv0| + λ1|v1ihv1|,

(1.48)

x=0

where {|vxi}1
is the orthonormal basis of eigenvectors. Furthermore,
all the eigenvalues of unitary matrices have absolute value equal to
1, i.e., |λx| = 1 for x ∈ {0, 1}. To see this, note that, by (1.48), the
condition (1.32) is equivalent to the equality

|λ0|2|v0ihv0| + |λ1|2|v1ihv1| = I,

(1.49)

26

Classical Bit (Cbit) and Quantum Bit (Qubit)

and we have the resolution-of-identity condition (1.40).

The change-of-basis representation (1.37) describes a unitary matrix
as a map from a state in one basis to a state in another basis. In
contrast, the eigendecomposition (1.48) identiﬁes states – the eigenvec-
tors {|vxi}1
– that are left unchanged by the operator except for a
scaling by a complex number with a unitary absolute value, namely
the eigenvalue λx for state |vxi. This is in the sense that we have the
equalities

x=0

U |vxi = λx|vxi

(1.50)

for x ∈ {0, 1}.

Some examples of single-qubit gates expressed in terms of their
eigendecompositions can be found in Table 1.4, where we have deﬁned
the so-called circular orthonormal basis

| + ii =

| − ii =

1
√
2
1
√
2

(|0i + i|1i)

(|0i − i|1i).

(1.51)

(1.52)

Note that the identity has all eigenvalues equal to 1, while all other
Pauli gates – X, Y , and Z – have one eigenvalue equal to 1 and the
other equal to −1. Given the eigendecompositions in Table 1.4, the
orthonormal bases {|+i, |−i}, {| + ii, | − ii}, and {|0i, |1i} are also
known as X, Y , and Z bases, respectively.

1.4.5 Quantum Gates from Hermitian Generators

As we discuss in this subsection, a unitary matrix – and hence also a
quantum gate – can be expressed as an exponential transformation of a
generator matrix. In order to explain this characterization of a unitary
matrix, we need to introduce the deﬁnition of Hermitian matrices.
A 2 × 2 matrix A is Hermitian if it satisﬁes the property

A† = A.

(1.53)

Since the equality (1.53) implies (1.45), a Hermitian matrix is normal.
Therefore, as a result of the spectral theorem, it has an eigendecom-
position (1.46). Furthermore, it can be shown using (1.53) that all
eigenvalues of a Hermitian matrix are real.

1.4. Single-Qubit Quantum Gates

27

name

operator

identity

I =

#

" 1 0
0 1

= |v0ihv0| + |v1ihv1| for any orth. basis {|vxi}1

x=0

Pauli X

Pauli Z

Pauli Y

X =

#

" 0 1
1 0

Z =

" 1

0
0 −1
#

Y =

" 0 −i
0
i

= |+ih+| − |−ih−|

#

= |0ih0| − |1ih1|

= | + iih+i| − | − iih−i|

Table 1.4: Examples of single-qubit quantum gates expressed in terms of their
eigendecompositions (1.48) with unitary-magnitude eigenvalues.

Any unitary matrix U can be expressed in terms of a Hermitian

matrix G as

U = exp(−iG).
The Hermitian matrix G is known as the generator – or, in physics,
as the Hamiltonian – of the unitary U . Recall that a function of a
normal matrix is deﬁned as in (1.47).

(1.54)

It can be easily checked that a matrix in the form (1.54) is indeed
unitary. In fact, the deﬁning property (1.32) of unitary matrices is
veriﬁed as

U †U = exp(iG†) exp(−iG) = exp(iG† − iG) = I = U U †,

(1.55)

where we have used the property (1.53), i.e., the equality G† = G.

As an example of the characterization (1.54), the Pauli Y -rotation
matrix RY (θ) in Table 1.2 can be expressed as a function of the Pauli
Y matrix as

RY (θ) = exp

−i

(cid:18)

(cid:19)

θ
2 Y

,

(1.56)

so that the generator matrix is given by the Hermitian matrix G =
(θ/2)Y . One can similarly deﬁne the Pauli X-rotation matrix

RX (θ) = exp

(cid:18)

−i

(cid:19)

,

θ
2 X

(1.57)

28

Classical Bit (Cbit) and Quantum Bit (Qubit)

as well as the Pauli Z-rotation matrix
θ
2 Z

RZ(θ) = exp

−i

(cid:18)

(cid:19)

.

(1.58)

Rotation matrices can be interpreted geometrically by introducing the
so-called Bloch sphere (see problems).

1.4.6 Pauli Orthonormal Basis for the Space of Matrices

The Pauli matrices I, X, Y, and Z play a key role in the formalism of
quantum theory. One of their useful properties is that they form a basis
for the space of 2 × 2 (bounded) matrices A with arbitrary complex
entries. This is in the sense that any such matrix A can be written as a
linear combination of the Pauli matrices as

A = a0I + a1X + a2Y + a3Z.

(1.59)

The coeﬃcients of the expansion can be computed using the trace
operator. The trace tr(·) of a square matrix is the sum of elements on the
main diagonal of the matrix (see Sec. 3.6.1 for additional information).
With this deﬁnition, the coeﬃcients in (1.59) are obtained as

a0 =

1
2

tr (A) , a1 =

1
2

tr (AX) , a2=

1
2

tr (AY ), a3=

1
2

tr (AZ).

(1.60)

Note that the operation tr(AB) for two square matrices A and B
corresponds to the inner product aT b between the vectors a and b
obtained by stacking the columns of matrices AT and B.

If A = U is unitary, it can be shown that the vector of coeﬃ-
cients [a0, a1, a2, a3]T in the decomposition (1.59) has unitary norm.
Furthermore, the expansion (1.59) can be specialized as

U = exp(iδ)(cos(φ)I + i sin(φ)(λ1X + λ2Y + λ3Z))

(1.61)

for some angles (δ, φ) and some real numbers λ1, λ2, and λ3. For example,
the Pauli Y -rotation matrix can be expressed in the form (1.59) as
(cid:18) θ
2

RY (θ) = cos

I − i sin

(cid:18) θ
2

(1.62)

Y,

(cid:19)

(cid:19)

with the same form applying also to rotations RX (θ) and RZ(θ) by
replacing matrix Y with X and Z, respectively. Note that the expression

1.5. Amplitude Diagrams

29

(1.62) can be derived from (1.56) via Euler’s formula exp(ix) = cos(x) +
i sin(x).

If A is Hermitian, all coeﬃcients a0,, a1, a2, and a3 in the expansion
(1.59) are real. Therefore, by the characterization (1.54), we can write
an arbitrary unitary matrix as

U = exp(−i(a0I + a1X + a2Y + a3Z)),

(1.63)

for real coeﬃcients a0, a1, a2 and a3. For example, the Pauli Y -rotation
matrix can be expressed in the form (1.63) with a0 = a1 = a3 = 0
and a2 = θ/2; and similar characterizations apply to the Pauli X- and
Z-rotations.

1.5 Amplitude Diagrams

In a quantum circuit diagram, such as that in Fig. 1.5, a qubit is
represented by a wire, and quantum gates are indicated as input-output
blocks operating on the qubit with time ﬂowing from left to right.
Note that the quantum gates are applied in place, in the sense that
the physical quantum qubit is the same throughout the computation,
while its state varies over time. An alternative representation of the
operation of a quantum circuit is provided by an amplitude diagram.
Amplitude diagrams oﬀer a more detailed description of a unitary by
depicting the evolution of the two complex amplitudes deﬁning the
qubit state.

To elaborate, let us ﬁx an orthonormal basis. An amplitude diagram
contains two wires, one for each of the two amplitudes associated to
either basis vector. Adopting the computational basis |0i and |1i, each
wire reports the evolution of the value of one of the two amplitudes α0
and α1 in the qubit state (1.15).

As an example, Fig. 1.7 shows the description of a Pauli X gate via
an amplitude diagram in the computational basis. As clearly illustrated
by the amplitude diagram, the X gate swaps the amplitudes associated
to the two vectors |0i and |1i in the computational basis (see Sec. 1.4.3).
Amplitude diagrams will be used in the next section in order to illustrate
the uniquely quantum phenomenon of interference.

30

Classical Bit (Cbit) and Quantum Bit (Qubit)

α0

α1

X

α1

α0

Figure 1.7: Amplitude diagram describing the operation of a Pauli X gate in the
computational basis.

1.6 Interference

The key diﬀerence between the behavior of a qubit and that of a
random cbit is the phenomenon of interference. As the state of a
qubit evolves over time, the amplitudes α0 and α1 corresponding to the
two computational basis state |0i and |1i can combine and “interfere”
in ways that produce measurement outputs that cannot be described in
terms of the evolution of a random cbit. In particular, as we will discuss
in this section, it is even possible that the two amplitudes cancel each
other out, creating destructive interference.

√

As we detailed in Sec. 1.3.3, if we directly measure a state |ψi in
superposition, it behaves in a manner akin to (the square root of) a
probability vector. As an example, as seen in the top part of Fig. 1.8, if
2(|0i + |1i), we obtain
we directly measure a qubit in state |+i = 1/
√
2)2 = 1/2.
as measurement output 0 or 1 with equal probability (1/
However, as anticipated in Sec. 1.3.3, this cannot be interpreted as
indicating that, unbeknownst to us, prior to the measurement, the qubit
is in either state |0i or state |1i. This situation would describe the
state of a random cbit, for which randomness is of epistemic nature,
that is, related to lack of knowledge on the part of the observer making
a measurement. For a qubit, uncertainty is of an inherently diﬀerent
nature; and, as we will illustrate next with an example, one needs to
describe the state of the qubit as a “real” superposition of both states
|0i and state |1i.

1.6.

Interference

31

x

|+i

|xi
w.p. 0.5

|0i or |1i
w.p. 0.5

H

|+i

H

x

0

|xi
w.p. 0.5

|0i
w.p. 1

Figure 1.8: (top) Measuring directly qubit in the superposition state |+i yields
measurement outputs 0 or 1 with equal probability; (middle) If the input state is
in either state |0i or |1i with equal probability, the measurement output after the
Hadamard gate would be 0 or 1 with equal probability; (bottom) Measuring a qubit
in state |+i after the application of a Hadamard gate yields a measurement output
equal to 1 with probability 1 owing to the phenomenon of interference.

For reference, let us consider ﬁrst the situation in which we model,
incorrectly, the input state as being equal to |0i with probability 1/2 and
|1i with probability 1/2 as shown in the middle part of Fig. 1.8. This
would imply that the qubit is equivalent to a random cbit, taking either
possible state with equal probability. In this case, after the Hadamard
gate in the ﬁgure, by (1.43), the qubit would be in state H|0i = |+i
with probability 1/2, and in state H|1i = |−i with probability 1/2.
Measuring each diagonal state |+i and |−i would produce output 0
or 1 with equal probability. Therefore, by the law of total probability,
the standard measurement in Fig. 1.8 would output 0 with probability
1/2 · 1/2 + 1/2 · 1/2 = 1/2, and 1 with probability 1/2.

Let us now consider the situation in the bottom part of Fig. 1.8 in
which the input state is given by the superposition |+i of states |0i and
|1i. Applying the Hadamard gate to the input superposition state |+i
gives the qubit state

H

(cid:18) 1
√
2

(cid:19)

(|0i + |1i)

=

=

1
√
2

(H|0i + H|1i)

1
2

(|0i + |1i + |0i − |1i) = |0i,

(1.64)

where we have used again (1.43). Therefore, by the Born rule, measuring

32

Classical Bit (Cbit) and Quantum Bit (Qubit)

Figure 1.9: Amplitude diagram illustrating the eﬀect of interference for the quantum
circuit in the bottom part of Fig. 1.8.

the output state produces output 0 with probability 1. The calculation
(1.64) can be also carried out directly in terms of amplitude vectors by
expressing the Hadamard gate as in Table 1.2. With this formalism, the
output state can be computed as

1
√
2

|

" 1

1
1 −1
{z
H

#

}

#

" 1√
2
1√
2
| {z }
|+i

=

,

#

" 1
0
| {z }
|0i

(1.65)

conﬁrming (1.64).

Graphically, the amplitude vector calculation in (1.65) can be repre-
sented using the amplitude diagram shown in Fig. 1.9. The amplitude
diagram highlights the fact that the amplitudes of states |0i and |1i
interfere with each other as the system evolves through the Hadamard
gate, reinforcing the amplitude of state |0i and nulling the amplitude of
state |1i after the second Hadamard gate. Accordingly, constructive
interference occurs for the state |0i while destructive interference
takes place for state |1i.

Overall, having observed the signiﬁcant diﬀerence between the out-
put produced by random cbit state in the middle part of Fig. 1.8 and
the superposition qubit state in the bottom part of the ﬁgure, we can
conclude that a qubit in a superposition state cannot be interpreted as
being in either state – it is, in some precise sense, in both states.

Hdestructive interferenceconstructive interference1212−1101.7. Conclusions

1.7 Conclusions

33

This chapter has introduced the qubit as the basic unit of quantum
information and computing. To this end, we have built on a, rather
limited, analogy with a random cbit. A qubit can evolve in one of two
ways: through multiplication via a unitary transform – i.e., through a
linear reversible norm-preserving transformation – or through a measure-
ment. When directly measured, a qubit can be equivalently described
as being in a state of epistemic uncertainty. Accordingly, each of the
two orthogonal states of the qubit is observed as the post-measurement
state with a probability equal to the absolute value squared of the corre-
sponding amplitude. However, if a qubit ﬁrst evolves through a unitary
transformation and is only then measured, describing the distribution
of the measurement outputs requires modelling the state of the qubit as
a “true” superposition of the two orthogonal states. In the next chapter,
we will extend the formalism and concepts introduced here to the case
of multiple qubits.

1.8 Recommended Resources

The material covered in this chapter is standard, and recommended
references for further reading include [1], which makes particularly clear
the relationship between cbits and qubits (“Qbits”); and [2], which
provides a “ket-free” presentation, highlighting the role of linear algebra
and oﬀering useful discussions via amplitude diagrams. An extensive
and endlessly useful reference is the classical book [3].

1.9 Problems

1. Prove the equalities Y X = −iZ, ZY = −iX, and XZ = −iY .

2. Describe the output of a standard measurement when a qubit in
state |0i is ﬁrst passed through a Pauli Y -rotation RY (θ) as a
function of the angle θ. Explain your results using amplitude-based
diagrams.

34

Classical Bit (Cbit) and Quantum Bit (Qubit)

3. Explain the two-slit experiment (see recommended resources) in

terms of interference.

4. Argue that the global phase of the two-dimensional vector de-
scribing a qubit state is not relevant to describe the outcomes of
measurements of the qubit.

5. Using the Bloch sphere (see recommended references), describe the
Pauli rotations RX (θ), RY (θ), and RZ(θ) geometrically, and argue
that any unitary transformation can be written as the product

exp(iα)RZ(θ1)RX (θ2)RZ(θ3)

(1.66)

for suitable angles α, θ1, θ2, and θ3. Following your argument,
demonstrate that any pair of Pauli rotations can be combined to
produce an arbitrary unitary transformation.

6. Show the following equivalence relations

H

H

X

Z

=

H

=

H

Z

X

H

Y

=

H

−Y

2

Classical Bits (Cbits) and Quantum Bits
(Qubits)

2.1 Introduction

In this chapter, we will describe quantum systems with more than one
qubit, introducing the formalism used to model states, transformations,
and measurements. A key new concept arising from the analysis of
multiple-qubit systems is that of entanglement – a uniquely quantum
form of statistical dependence.

2.2 Multiple Random Classical Bits

As in the previous chapter, we start by discussing a formalism for the
description of multiple random cbits, which will then be used as a
reference point for the deﬁnition of a multi-qubit state.

2.2.1 Classical Bits as Integers and as One-Hot Vectors

To begin, let us consider a system with n = 3 cbits. As illustrated in
Table 2.1, we can represent the state of a three-cbit system in one of
the following ways:

35

36

Classical Bits (Cbits) and Quantum Bits (Qubits)

• as a string of n = 3 bits

x0, x1, x2,

(2.1)

with each k-th bit denoted as xk ∈ {0, 1} for k ∈ {0, 1, 2};

• as the integer x ∈ {0, 1, ..., 7} given as

x = 22x0 + 2x1 + x2,
which converts the bit string (2.1) to one of N = 8 integers by
considering the cbits in the string (2.1) as listed from the most
signiﬁcant to the least signiﬁcant;

(2.2)

• as a one-hot amplitude vector, which is a 3 × 1 vector with
all zero elements except for a “1” digit in the position indexed by
integer x in (2.2) when counting from zero and starting from the
top of the vector.

As discussed in Sec. 1.2.2, in quantum theory, one-hot amplitude
vectors are written using Dirac’s ket notation. Dirac’s notation de-
scribes column vectors with unitary norm. Accordingly, as illustrated
in Table 2.1, we denote the one-hot vector representing bit string (2.1),
or equivalently integer (2.2), as |x0x1x2i, |x0, x1, x2i, or as |xi3. The
subscript in the ket |xi3 indicates the number of cbits, here n = 3. The
subscript is introduced to avoid ambiguities, and it can be omitted
when no confusion can arise. We will see later in the monograph that
the subscript in a ket can also be used also for other purposes.

Generalizing the example of n = 3 qubits in Table 2.1, a string of n
cbits will be denoted throughout the text in one of the following ways:

• as a string of n bits

x0, x1, ..., xn−1,
with each k-th bit denoted as xk ∈ {0, 1} for k ∈ {0, 1, ..., n − 1};

(2.3)

• as the integer x ∈ {0, 1, ..., 2n − 1} given as

x = 2n−1x0 + 2n−2x1 + · · · + xn−1

=

n−1
X

j=0

2n−j−1 · xj,

(2.4)

2.2. Multiple Random Classical Bits

37

integer x cbits

one-hot amplitude vector |xin

0

1

2

3

4

5

6

7

000

001

010

011

100

101

110

111

|0i3 = |000i = [1, 0, 0, 0, 0, 0, 0, 0]T
|1i3 = |001i = [0, 1, 0, 0, 0, 0, 0, 0]T
|2i3 = |010i = [0, 0, 1, 0, 0, 0, 0, 0]T
|3i3 = |011i = [0, 0, 0, 1, 0, 0, 0, 0]T
|4i3 = |100i = [0, 0, 0, 0, 1, 0, 0, 0]T
|5i3 = |101i = [0, 0, 0, 0, 0, 1, 0, 0]T
|6i3 = |110i = [0, 0, 0, 0, 0, 0, 1, 0]T
|7i3 = |111i = [0, 0, 0, 0, 0, 0, 0, 1]T

Table 2.1: List of cbit strings of n = 3 cbits with associated integer representation
and one-hot amplitude vector.

which converts the bit string to one of N = 2n integers in the
set {0, 1, ..., 2n − 1} by considering the cbits in the string (2.3) as
listed from most signiﬁcant to least signiﬁcant reading from left
to right;

• as a one-hot amplitude vector denoted as |x0x1 · · · xn−1i,
|x0, x1, · · · , xn−1i, or |xin, which is an 2n × 1 vector with all
zero elements except for a 1 digit in the position indexed by inte-
ger x in (2.4) when counting from zero and starting from the top
of the vector.

Representing classical information encoded by n cbits requires n
binary physical systems, such as on-oﬀ switches. The one-hot amplitude
representation introduced in this subsection is exponentially less eﬃcient,
since it requires vectors of dimension N = 2n. For example, n = 10
cbits are encoded into one-hot amplitude vectors of size N = 1024; and
n = 300 cbits require amplitude vectors of size N ’ 10100 – which is
larger than the number of atoms in the universe.

38

Classical Bits (Cbits) and Quantum Bits (Qubits)

2.2.2 Random Cbits and Probability Vectors

Despite their ineﬃciency, one-hot vectors are routinely used in machine
learning when dealing with discrete random variables. In fact, the
probability distribution of a random n-cbit string is described by the
2n × 1 probability vector

p =









p0
p1
...
p2n−1









,

(2.5)

with px ≥ 0 being the probability of the cbit string being equal to
x ∈ {0, 1, ..., 2n − 1}. Note again that we refer to a cbit string and to the
corresponding integer representation interchangeably. The probability
vector (2.5) must satisfy the condition

2n−1
X

x=0

px = 1.

(2.6)

2.2.3 From Individual Cbits to Multiple Cbits via the Kronecker

Product

As we know from the previous chapter, the state of a single (determinis-
tic) cbit can be represented by a 2 × 1 one-hot amplitude vector, which
may take values

|0i =

#

" 1
0

or |1i =

" 0
1

#

.

(2.7)

Furthermore, as introduced in the last subsection, a system of n classical
cbits deﬁned by integer x ∈ {0, 1, ..., 2n − 1} is represented by a 2n × 1
one-hot amplitude vector |xin. Can we obtain the one-hot amplitude
vector |xin for the overall system from the one-hot amplitude vectors
|xki, with xk ∈ {0, 1}, for the individual cbits k ∈ {0, 1, ..., n − 1}?

We will see in this subsection that the answer to this question
is aﬃrmative: The state of a classical deterministic system can be
described as the combination of the states of the individual subsystems.

2.2. Multiple Random Classical Bits

39

Furthermore, the mathematical tool that enables this combination is
the Kronecker product.

Given an m × 1 vector

a =

















a1
a2
...
am

(2.8)

and a k ×1 vector b, the Kronecker product a⊗b produces the mk ×1
vector

a ⊗ b =







,







(2.9)





a1b
a2b
...
amb

where the products akb are evaluated element-wise on the entries of
vector b for k ∈ {1, 2, ..., m}.

Using this deﬁnition, the 2n × 1 amplitude vector |xin for a system
of n cbits can be computed from the two-dimensional amplitude vectors
|x0i, |x1i, . . . , |xn−1i of the individual cbits via the n-fold Kronecker
product

|xin = |x0x1...xn−1i = |x0i ⊗ |x1i ⊗ · · · ⊗ |xn−1i.

(2.10)

By (2.10), the notation |x0x1...xn−1i can be interpreted as describing
the Kronecker product of the states indicated within the ket.

To illustrate this operation, let us consider a system with n = 3
cbits with values x0 = 1, x1 = 1, and x2 = 0. The amplitude vector
describing the state of the overall system is given by

|110i = |6i3 =


















.


















0
0
0
0
0
0
1
0

(2.11)

40

Classical Bits (Cbits) and Quantum Bits (Qubits)

This vector can be expressed via the Kronecker product in (2.10) as

"

=

0
1







#

" 0
1

#

" 1
0

⊗

⊗

#








0 · 0
0 · 1
1·0
1·1

#

" 1
0

⊗








=








0
0
0
1

" 1
0

⊗

#

=


















0 · 1
0 · 0
0 · 1
0 · 0
0 · 1
0 · 0
1 · 1
1 · 0


















=


















,


















0
0
0
0
0
0
1
0

(2.12)

where the bold font has been introduced in order to facilitate the inter-
pretation of the operations at hand, and we have used the associative
property of the Kronecker product. The associative property stipulates
that Kronecker products can be grouped in pairs in any arbitrary way
in order to evaluate a sequence of Kronecker products.

2.2.4 From Individual Random Cbits to Multiple Random Cbits?

In this subsection, we address a question analogous to that considered
in the previous subsection moving from deterministic to random cbits.
To formulate the question, for n random cbits, suppose that we know
the 2 × 1 (marginal) probability vectors for all the constituent n cbits.
Can we obtain from these n vectors the 2n × 1 probability vector (2.5)
of the overall system? As we review in this subsection, the answer is
negative, unless the random cbits are statistically independent.

To elaborate, let us consider the case with n = 2 random cbits. The

individual probability vectors for the two cbits can be written as

pA =

"

pA
0
pA
1

#

"
and pB=

#

,

pB
0
pB
1

(2.13)

2.2. Multiple Random Classical Bits

41

where the superscript A and B identiﬁes the two cbits. In (2.13), the
is the marginal probability for the ﬁrst random cbit to take
element pA
x
value x ∈ {0, 1}, and an analogous deﬁnition applies for pB
. If the cbits
x
are statistically independent, we can write the probability vector of
the system of two random cbits as

"

p =

pA
0
pA
1

#

"

⊗

#

=

pB
0
pB
1








pA
0 pB
0
pA
0 pB
1
pA
1 pB
0
1 pB
pA
1








.

(2.14)

This is because the joint probability of independent random variables
is the product of the individual marginal distributions.

For two statistically dependent – or, somewhat less formally,
correlated – random cbits, the probability vector cannot be expressed
in terms of the individual marginal probability vectors, i.e., we have the
inequality

p =















p00
p01
p10
p11








6=

pA
0 pB
0
pA
0 pB
1
pA
1 pB
0
1 pB
pA
1








,

(2.15)

where pxy is the joint probability that the ﬁrst cbit takes value x ∈
{0, 1} and the second cbit takes value y ∈ {0, 1}. Therefore, unless the
random cbits are independent, the probability vectors for the individual
random cbits only provide information about the corresponding marginal
distributions, from which one cannot recover the joint distribution.
Knowing the individual states of random subsystems does not allow
one to reconstruct the state of the overall random system.

2.2.5 Probability Vectors as “Superpositions” of Basis States

As we have seen in Sec. 1.2.3, the probability vector for a single random
cbit can be written as

"

p =

#

p0
p1

= p0|0i + p1|1i,

(2.16)

with p0 + p1 = 1. In words, a probability vector p can be thought of
as a “superposition” of the computational basis vectors |0i and |1i.

42

Classical Bits (Cbits) and Quantum Bits (Qubits)

In this subsection, we generalize this relationship to any number n of
(jointly distributed) random cbits.

To this end, we start by deﬁning the computational basis of the
2n-dimensional linear vector space as the set of 2n one-hot amplitude
vectors

|xi = |x0, x1, · · · , xn−1i
(2.17)
for x ∈ {0, 1, ..., 2n − 1} and xk ∈ {0, 1} with k ∈ {0, 1, ..., n − 1}. Note
that we have dropped the subscript n in (2.10) in order to simplify the
notation. The vectors

{|xi}2n−1
x=0

= {|0i, |1i, ...., |2n−1i}

can be readily proved to be mutually orthogonal, i.e., we have

hx|x0i = 0 if x0 6= x

(2.18)

(2.19)

and to have unitary norm, i.e., hx|xi = 1. Therefore, they form an
orthonormal basis for the 2n-dimensional linear vector space, which is
known as the computational basis.

Therefore, the 2n-dimensional probability vector p for a system of n

cbits, i.e., (2.5), can be written as

p =









p0
p1
...
p2n−1









2n−1
X

=

x=0

px|xi,

(2.20)

with P2n−1
x=0 px = 1. Accordingly, probability vector p is the “super-
position” of the 2n vectors in the computational basis (2.18), with
each vector |xi weighted by the corresponding probability px. It is
worth noting that, vector p, while not generally expressible as a Kro-
necker product of two-dimensional vectors, can always be written as a
linear combination of vectors that admit such decomposition. In fact,
each computational-basis vector |xi in (2.20), by (2.10), is a Kronecker
product of per-cbit states.

2.3 Multiple Qubits

In this section, we describe systems consisting of multiple qubits.

2.3. Multiple Qubits

43

2.3.1 Qubits as Amplitude Vectors

In a manner that is somewhat analogous to the state of a set of n
random cbits, described by the probability vector p in (2.20), the state
of an n-qubit system is speciﬁed by the 2n × 1 vector

|ψi =









α0
α1
...
α2n−1









2n−1
X

=

x=0

αx|xi,

with amplitudes {αx}2n−1
x=0

satisfying the equality

2n−1
X

x=0

|αx|2 = 1.

(2.21)

(2.22)

The quantum state vector |ψi is hence an element of a 2n-dimensional
complex linear vector space space, which is referred to as the 2n-
dimensional Hilbert space. Furthermore, by (2.21), we say that the
state |ψi is a superposition of the N = 2n vectors in the computational
with respective amplitudes {αx}2n−1
basis {|xi}2n−1
x=0
x=0

.

Generalizing the discussion concerning single qubits in Sec. 1.3.1,
unlike the probability vector p, the quantum state (2.21) has complex
entries α0 and α1, and it satisﬁes the deﬁning property of having unitary
norm by (2.22) (which is diﬀerent from (2.6)).

Moreover, while being distinct from the state of n random cbits, the
quantum state (2.21) recovers as special cases the 2n possible states of
n deterministic cbits when expressed as one-hot amplitude vectors. In
fact, setting the amplitudes as αx = 1, and hence α0
= 0 for x0 6= x,
x
yields the deterministic n-cbit state |xi. Therefore, a system of n qubits
that can only assume the states {|xi}2n−1
in the computational basis is
x=0
equivalent to n deterministic cbits.

As an example, for n = 2, we can write the N = 22 = 4-dimensional

44

Classical Bits (Cbits) and Quantum Bits (Qubits)

state vector in the following equivalent ways








|ψi =

= α0

α0
α1
α2
α3





















=

α00
α01
α10
α11









1
0
0
0

+ α1













0
1
0
0








+ α2















0
0
1
0

+ α3















0
0
0
1

= α0|0i + α1|1i + α2|2i + α3|3i
= α00|00i + α01|01i + α10|10i + α11|11i,

(2.23)

where we have indexed the vectors in the computational basis using
either the integer or binary string representations.

As highlighted in (2.23), the amplitudes deﬁning quantum state
(2.21) can be indexed by an integer x ∈ {0, 1, ..., 2n − 1} or, equivalently,
by an n-cbit string. The latter notation formalizes a quantum state
as a tensor. A tensor of order n is a multi-dimensional “table” whose
elements are identiﬁed by an n-dimensional vector, here of binary
numbers. For the quantum state (2.21), the tensor is deﬁned by a table
, where each k-th dimension is indexed by cbit
with entries αx0,x1,...,xn−1
xk ∈ {0, 1}.

The exponential size of the quantum state vector (2.21) makes it
practically impossible, in general, to use a classical computer to simulate
the operation of quantum systems with as low as n = 50 qubits. In fact,
representing a quantum state of 50 qubits requires around 250 (cid:38) 1015
bytes to ﬁt into the main memory, which is hard even for the largest
supercomputers available today (see also Sec. 2.2.1).

Being a 2n-dimensional vector, the quantum state (2.21) can be
expressed as a linear combination of the vectors {|vxi}x∈{0,1,...,2n−1}
forming any orthonormal basis of the 2n-dimensional Hilbert space. As
an important example, for n = 2 qubits, an orthonormal basis for the
22 = 4-dimensional Hilbert space is given by the so-called Bell basis

2.3. Multiple Qubits

consisting of the four Bell states

|Φ+i =

|Ψ+i =

|Φ−i =

|Ψ−i =

1
√
2
1
√
2
1
√
2
1
√
2

(|00i + |11i) =

(|01i + |10i) =

(|00i − |11i) =

(|01i − |10i) =

1
√
2
1
√
2
1
√
2
1
√
2

[1, 0, 0, 1]T

[0, 1, 1, 0]T

[1, 0, 0, −1]T

[0, 1, −1, 0]T .

45

(2.24)

(2.25)

(2.26)

(2.27)

As we will see throughout this text, Bell states play an important role
in quantum computing as building blocks of routines and protocols. It
is useful to know that we can also write the Bell basis in terms of the
diagonal basis (see Sec. 1.3.1) as

|Φ+i =

|Ψ+i =

|Φ−i =

|Ψ−i =

1
√
2
1
√
2
1
√
2
1
√
2

(| + +i + | − −i)

(| + +i − | − −i)

(| − +i + | + −i)

(| − +i − | + −i).

(2.28)

(2.29)

(2.30)

(2.31)

2.3.2 Measuring Qubits: von Neumann Measurements

A von Neumann measurement in the computational basis, or
standard measurement for short, takes as input n qubits in an arbi-
trary state |ψi as in (2.21), and it produces n cbits as the measurement’s
output, while leaving the qubits in a generally diﬀerent state from the
original state |ψi. Speciﬁcally, a standard measurement satisﬁes the
following two properties, which are direct extensions of the properties
reviewed in Sec. 1.3.2 for single-qubit measurements (i.e., for n = 1):

• Born’s rule: The probability of observing the n-cbit string x ∈

{0, 1}n is

Pr[measurement output equals x ∈ {0, 1}n] = |αx|2

= |hx|ψi|2;

(2.32)

46

Classical Bits (Cbits) and Quantum Bits (Qubits)

• “Collapse” of the state: If the measured n-cbit string is x, the

post-measurement state of the qubits is |xi.

Therefore, by (2.32), the probability of measuring a cbit string x
is given by the absolute value squared of the corresponding amplitude
hx|ψi. Moreover, a measurement randomly “collapses” state |ψi, which
is generally in a superposition of computational-basis states, into a
single computational-basis vector |xi. In this regard, one can check that
a system of n qubits that can only take states |xi in the computational
basis behaves like a deterministic cbits. This is in the sense that, by
Born’s rule, measuring a qubit in state |xi, for x ∈ {0, 1, ..., 2n − 1},
returns output x with probability 1, while leaving the qubits’ state
unchanged.

As we will further clarify in the next chapter, a standard mea-
surement on n qubits can be implemented by applying a standard
measurement separately to each individual qubit. This is illustrated
in Fig. 2.1, in which a separate measurement block is applied to each
qubit. Accordingly, each individual cbit xk of a measurement output
x0, x1, ..., xn−1 corresponding to an integer x ∈ {0, 1, ..., 2n − 1} is pro-
duced by measuring the k-th qubit. Furthermore, we will see in the next
chapter that such per-qubit measurements can be carried out in any
order on the qubit, including at the same time, without changing the
distribution of the measurement outputs given by Born’s rule.

2.4 Quantum Circuits and Local Operations

Generalizing the discussion in Sec. 1.4.1, when not measured, a system
of n qubits in state |ψi evolves according to a linear, norm-preserving,
reversible transformation, which is deﬁned by a 2n × 2n unitary matrix
U . Accordingly, in a closed system, a quantum input state |ψi evolves
into an output state |ψ0i = U |ψi. In this section, we ﬁrst introduce the
formalism used to describe and design unitary transformations, namely
quantum circuits. Then, we elaborate on the simplest type of quantum
circuit in which quantum gates are applied in parallel to the qubits.

2.4. Quantum Circuits and Local Operations

47

|x0i

|x1i

x0

x1

...

xn−1

|xn−1i

Figure 2.1: A standard measurement on n qubits can be implemented as n separate
standard measurements on the individual qubits. Each k-th cbit xk of the overall
n-cbit output of the measurement is produced by measuring the k-th qubit.

2.4.1 Quantum Circuits

A unitary matrix satisﬁes the equalities (1.32), i.e., U U † = U †U = I,
where I is a 2n × 2n identity matrix. While in theory every unitary
matrix U is physically realizable, in practice, transformations U are
described and implemented as a cascade of unitary matrices that apply
to small subsets of qubits, typically consisting of only one or two qubits.
This cascade, and with it the overall matrix U , are described by a
quantum circuit.

A quantum circuit contains n wires – one per qubit – and it
describes the sequence of unitary matrices applied to the n qubits
with time ﬂowing from left to right. An example is shown in Fig. 2.2.
Unitary matrices applied to a subset of m qubits are referred to as
m-qubit quantum gates. For the example in Fig. 2.2, single-qubit
gates U1 and U2 are applied to the ﬁrst two qubits; then a two-qubit
gate U3 is applied to the ﬁrst two qubits; and so on. Existing quantum
computers implement a library of single-qubit quantum gates and two-
qubit quantum gates.

The operations speciﬁed by a quantum circuit are applied in place
to the register on n qubits in the order from left to right. Accord-
ingly, quantum gates are applied sequentially to the set of n physical
qubits, causing the state of the n qubits to evolve over time via unitary

48

Classical Bits (Cbits) and Quantum Bits (Qubits)

U1

U2

U3

U5

U6

U7

U4

Figure 2.2: A quantum circuit representing the operation of an 8 × 8 unitary
transformation of n = 3 qubits as a sequence of one- and two-qubit gates (with the
former being deﬁned by 2 × 2 matrices, and the latter by 4 × 4 matrices).

transformations.

It is emphasized that, while a quantum circuit contains n wires, a
full description of the corresponding quantum transformation applied
at each time requires the deﬁnition of a 2n × 2n unitary matrix U .
Formally, quantum circuits can be studied within the framework of
tensor networks (see recommended resources in Sec. 2.12).

2.4.2 Local Operations

We will have more to say about multi-qubit gates in Sec. 2.6. In this
subsection, we consider the simple setting in which the unitary U is
composed of separate single-qubit gates applied in parallel to the n
qubits. We refer to such operations as being local to each qubit.

To start, let us generalize the deﬁnition of the Kronecker product

to matrices. Given an m × k matrix

A =









a12
a11
a22
a21
...
...
am1 am2

· · ·
· · ·

· · ·









a1k
a2k
...
amk

(2.33)

and a l × r matrix B, the Kronecker product produces the ml × kr
matrix



A ⊗ B =









a11B a12B · · ·
a21B a22B · · ·
...
am1B am2B · · ·

...

a1kB
a2kB
...
amkB

,







(2.34)

2.4. Quantum Circuits and Local Operations

49

U A

U B

Figure 2.3: A 4 × 4 unitary matrix obtained as the local application of 2 × 2 unitary
matrices U A and U B to two qubits.

where the product ajkB is applied in an element-wise manner to matrix
B.

Let us consider ﬁrst a two-qubit system, i.e., with n = 2. In it, as
illustrated in Fig. 2.3, the 2 × 2 unitary U A is applied to the ﬁrst qubit,
while the 2 × 2 unitary U B is applied to the second qubit. The overall
4 × 4 unitary U applied to the system of two qubits can be expressed
as the Kronecker product

U = U A ⊗ U B.
In words, the Kronecker product of 2 × 2 unitaries describes a trans-
formation in which the corresponding single-qubit quantum gates are
applied locally to the qubits. A multi-qubit gate that can be described
as the Kronecker product of individual qubit gates is referred to as
implementing local operations on the qubits.

(2.35)

As an example of local operations, the unitary I ⊗ U , with I being
the 2 × 2 identity matrix, corresponds to a transformation in which
no processing is done on the ﬁrst qubit and the single-qubit gate U is
applied to the second qubit.

To understand the eﬀect of the application of local operations, take
the example of an input state |xyi = |xi ⊗ |yi in the computational
basis, where x, y ∈ {0, 1}. The corresponding output state is given by
(U A ⊗ U B)|xyi = (U A ⊗ U B)(|xi ⊗ |yi)

= U A|xi ⊗ U B|yi

(2.36)

for all x, y ∈ {0, 1}. In the ﬁrst line of (2.36), we have used the key
property that the multiplication of two Kronecker products yields the
Kronecker product of the corresponding multiplications. By (2.36), the
output state is obtained by applying the unitaries U A and U B in parallel
to the corresponding qubits’ states.

50

Classical Bits (Cbits) and Quantum Bits (Qubits)

Take now a general two-qubit state (2.21), i.e.,

|ψi = α00|00i + α01|01i + α10|10i + α11|11i.

(2.37)

Note that this state cannot be written, apart from special cases, as the
Kronecker products of individual states for the two qubits. The output
of the circuit in Fig. 2.3 is obtained by applying the equality (2.36) to
each term in the superposition as

U |ψi = α00U |00i + α01U |01i + α10U |10i + α11U |11i

1
X

1
X

=

x=0

y=0

αxy(U A|xi ⊗ U B|yi).

(2.38)

Local operations on n > 2 qubits are naturally deﬁned as the
Kronecker product of 2×2 unitary matrices describing the corresponding
qubit gates applied in parallel to the n qubits.

2.5 Entanglement

The amplitude vector of an n-qubit system has some aspects in com-
mon with probability vectors describing the state of n random cbits –
including its dimension, 2n. However, qubits behave in fundamentally
diﬀerent ways as compared to random cbits in terms of their evolution
and interactions with other systems. Sec. 1.6 introduced the concept
of interference, demonstrating that the behavior exhibited by qubits
cannot be explained by modelling a qubit as a random cbit. In this sec-
tion, we introduce a new distinguishing feature of quantum systems as
compared to classical random systems: entanglement. Entanglement
arises in the presence of multiple qubits, and may be thought of as a
stronger form of statistical dependence that only applies to quantum
systems.

2.5.1 Separable and Entangled States

To start, let us deﬁne a set of n qubits as separable if the qubits’ joint
state |ψi, a 2n-dimensional vector, can be expressed as the Kronecker
product of the individual qubit states. For two arbitrary qubit states,

2.5. Entanglement

51

|ψAi = αA
0 |0i + αB
the second, the general form of a separable state with n = 2 is

1 |1i for the ﬁrst qubit and |ψBi = αB

0 |0i + αA

1 |1i for

|ψAi ⊗ |ψBi =








αA
0 · αB
0
αA
0 · αB
1
1 · αB
αA
0
1 · αB
αA
1








.

(2.39)

The deﬁnition of separable state should call to mind the deﬁnition
of independent random cbits given in (2.14). In fact, the two deﬁni-
tions are formally equivalent if one replaces quantum amplitudes with
probabilities.

In terms of notation, a separable state in the form |ψAi ⊗ |ψBi can

also be written as

|ψA, ψBi = |ψAi ⊗ |ψBi = |ψAi|ψBi,

(2.40)

dropping the Kronecker operation. Note that this notational convention
was already used when writing a vector in the computational basis as
in (2.10). As a related matter of notation, as in (2.10), we will often
drop the comma between the identiﬁers of the states for separate qubits,
that is, we may write |ψA, ψBi as |ψAψBi.

As discussed in Sec. 2.2.4, statistically dependent random cbits are
characterized by probability vectors that cannot be expressed as the
Kronecker product of the (marginal) probability vectors of the individual
random cbits. In a somewhat analogous manner, a set of qubits is said
to be entangled if its state cannot be written as the Kronecker product
of the states of the individual qubits. As for statistical dependence,
there are diﬀerent degrees of entanglement, with some joint states being
more entangled than others.

We will see in the next subsection that the parallel between de-
pendent random cbits and entangled qubits is purely formal, in the
sense that measurement outputs of entangled qubits exhibit statistical
behaviors that cannot be explained by means of standard correlations
of cbits.

Important examples of entangled states for n = 2 qubits are given
by the Bell states described in Sec. 2.3.1. For example, the so-called

52

Classical Bits (Cbits) and Quantum Bits (Qubits)

Bell pair

|Φ+i =

1
√
2

(|00i + |11i) =

1
√
2















1
0
0
1

(2.41)

cannot be written as the Kronecker product of two individual qubit
states. To see this, note that there is no choice for the two individual
qubit states |ψAi and |ψBi, which makes (2.39) equal to the Bell state
(2.41). Bell states are maximally entangled pairs of qubits, in the
sense that any pair of entangled qubits can be obtained from a Bell pair
(or another Bell state) through local operations on the two qubits of
the form (2.35). Appendix A in the next chapter describes methods to
quantify entanglement in pairs of qubits.

When considering n ≥ 3 qubits, entanglement may only involve a
subset of the qubits. For example, three entangled qubits could be only
partially entangled as in a state of the form |Φ+i ⊗ |0i. In it, the
ﬁrst and the second qubits are mutually entangled, forming a Bell pair,
while the third qubit is not entangled with the ﬁrst two qubits. While
not separable across the three qubits, and hence entangled according
to the deﬁnition given here, this state is said to be biseparable. More
discussion on multipartite entanglement can be found in Appendix B
of the next chapter.

A key fact about entanglement is that it does not survive a standard
measurement (of all qubits). This is in the sense that, no matter what the
quantum state is before the measurement, the post-measurement state
is separable, since it is given by one of the vectors in the computational
basis as illustrated in Fig. 2.1.

2.5.2 A First Example of the Non-Classical Behavior of Entangled

Qubits

Consider two qubits in the Bell state |Φ+i. If we directly apply a
standard measurements to the two qubits in the Bell pair, by Born’s
rule, we obtain the output x = 0, i.e., the cbit string 00, with probability
1/2, or x = 3, i.e., the cbit string 11, with the same probability. This
behavior is equivalent to that of a classically correlated pair of random

2.5. Entanglement

53

|00i or |11i w.p. 0.5

H

H

|0i or |1i w.p. 0.5

|0i or |1i w.p. 0.5

(cid:12)
(cid:12)Φ+(cid:11)

H

H

|00i or |11i w.p. 0.5

Figure 2.4: An example used to illustrate the behavior of entangled qubits: (top)
When the input state describes correlated cbits, the outputs of the measurements
are independent random cbits; (bottom) When the input state consists of entangled
qubits, the measurement outputs are correlated cbits.

cbits that is in state |00i or |11i with equal probability, i.e., of random
cbits with joint probability vector p = [1/2, 0, 0, 1/2]T .

Let us now allow the Bell pair to evolve as described in the bottom
part of the quantum circuit in Fig. 2.4. Accordingly, a local Hadamard
gate is applied separately to each qubit, as described in Sec. 2.4, before
a standard measurement is made. We will compare next the behavior
of entangled qubits with that of statistically dependent random cbits.
Assume ﬁrst, incorrectly, that the input state of the two qubits is
state |00i or state |11i with equal probability, hence being equivalent
to two fully correlated random cbits. This is illustrated in the top part
of Fig. 2.4. By the property of the Kronecker product (2.36), under
this assumption, the state of the qubits at the output of the two local
Hadamard gates would be

(H ⊗ H)|00i = (H ⊗ H)(|0i ⊗ |0i) = H|0i ⊗ H|0i

= |+i ⊗ |+i =

1
2

(|00i + |01i + |10i + |11i)

(2.42)

or

(H ⊗ H)|11i = (H ⊗ H)(|1i ⊗ |1i) = H|1i ⊗ H|1i

= |−i ⊗ |−i =

1
2

(|00i − |01i − |10i + |11i)

(2.43)

54

Classical Bits (Cbits) and Quantum Bits (Qubits)

with equal probability, where we have used the property (1.43) of the
Hadamard gate.

From the discussion in the previous paragraph, it follows via the law
of total probability that a standard measurement would yield outputs
00, 01, 10, or 11 with equal probability. Equivalently, the two output
cbits produced by the measurements of the two qubits in Fig. 2.4 would
be independent and would take either value 0 or 1 with probability 1/2.
To sum up, as depicted in the top part of Fig. 2.4, if the state of the
qubits at the input of the circuit was equivalent to that of classical
correlated cbits, the presence of the Hadamard gates would destroy the
statistical dependence between the two cbits, producing independent
cbits at the output of the measurements.

Consider now the actual situation of interest in which the input
quantum state is given by the Bell pair |Φ+i. In this case, the state
produced by the circuit in Fig. 2.4, prior to the measurement, is

(H ⊗ H)|Φ+i =

(H ⊗ H)(|00i + |11i)

1
√
2
1
√

=

2
2
= |Φ+i.

(|00i + |01i + |10i + |11i + |00i − |01i − |10i + |11i)

(2.44)

It follows that the measurement of the two qubits produces the cbit string
00 or 11 with equal probability. Therefore, the local Hadamard gates
leave the state of the system, |Φ+i, unchanged, preserving the correlation
between the two cbits produced by the measurement. (Mathematically,
this happens because the state |Φ+i is an eigenvector of the operator
H ⊗ H.)

This example demonstrates that entangled qubits cannot be treated
as correlated random cbits. In particular, we have concluded that the
qubits in the Bell state |Φ+i cannot be considered as being in either
state |00i or |11i with equal probability. This has intriguing implications
on the nature of reality, as we will further discuss in Sec. 3.3.3.

2.5.3 Entangled States as Superpositions of Separable States

A basic fact about entangled states is that they can be always expressed
as superpositions of multiple separable states. This follows straightfor-

2.6. Multi-Qubit Quantum Gates

55

wardly from the fact that the 2n vectors (2.10) in the computational
basis are separable. Therefore, the superposition (2.21) is indeed a linear
combination of separable states.

More generally, given an orthonormal basis {|vxk i}1

for each
qubit k ∈ {0, 1, ..., n − 1}, an orthonormal basis for the 2n-dimensional
Hilbert space of an n-qubit system can be obtained as the set of all 2n
states of the form

xk=0

{|vx0i ⊗ |vx1i ⊗ · · · ⊗ |vxn−1i}.

(2.45)

It follows that any quantum state for n qubits can be written as the
superposition

|ψi =

1
X

1
X

1
X

· · ·

x0=0

x1=0

xn−1=0

αx0,x1....,xn−1|vx0i⊗|vx1i⊗· · ·⊗|vxn−1i. (2.46)

Even more broadly, we can decompose the set of n qubits into K
k=0 nk = n. Denoting as {|vxk i}2nk −1
subsets, each of nk qubits with PK−1
xk=0
any orthonormal basis for the 2nk -dimensional Hilbert space of the k-th
subset of qubits, an orthonormal basis for the 2n-dimensional Hilbert
space for the n qubits is obtained as the set of all 2n states of the form

{|vx0i ⊗ |vx1i ⊗ · · · ⊗ |vxK−1i}.

(2.47)

Accordingly, we can write the state of the n qubits as the superposition

2n0 −1
X

2n1 −1
X

2nK−1 −1
X

· · ·

|ψi =

x0=0

x1=0

xK−1=0

αx0,x1....,xK−1|vx0i ⊗ |vx1i ⊗ · · · ⊗ |vxK−1i.

(2.48)

2.6 Multi-Qubit Quantum Gates

As explained in Sec. 2.4, systems of n qubits, when not measured,
evolve according to a reversible, norm-preserving, linear transformation
described by a 2n × 2n unitary matrix U . The situation is illustrated in
Fig. 2.5, in which a bundle of n wires is used to indicate the presence
of n wires, one for each qubit.

While in principle all 2n × 2n unitary matrices U are physically
realizable, in practice one is limited to transformations that can be

56

Classical Bits (Cbits) and Quantum Bits (Qubits)

n

U

n

Figure 2.5: An n-qubit system, when not measured, evolves according to a reversible
linear transformation described by a 2n × 2n unitary matrix U .

implemented by a quantum circuit with a, suﬃciently short, sequences
of one- and two-qubit gates. Speciﬁcally, for feasibility, the sequence
should consist of a number of gates that grows polynomially with the
number of qubits, n, and not with the number of amplitudes, 2n. In
this section, generalizing the discussion in Sec. 1.4, we cover several
ways to interpret and construct unitary matrices.

2.6.1 Local Operations and Multi-Qubit Quantum Gates

As introduced in Sec. 2.4, the simplest type of unitary operating on n
qubits is given by the parallel, local, application of single-qubit gates to
each of the n individual qubits. This corresponds to a unitary matrix
U obtained as the Kronecker product

U = U0 ⊗ U1 ⊗ · · · ⊗ Un−1,

(2.49)

where each 2 × 2 unitary Uk, with k ∈ {0, 1, ..., n − 1}, applies to the
corresponding k-th qubit.

A particularly important category of local unitary matrices is given
by strings of n Pauli matrices. Let us write as Ps with s ∈ {0, 1, 2, 3}
a Pauli matrix, where

P0 = I, P1 = X, P2 = Y, and P3 = Z.

(2.50)

Furthermore, let sn = [s0, ..., sn−1] be a vector of integers sk ∈ {0, 1, 2, 3}
with k ∈ {0, 1, ..., n − 1}. A string of n Pauli matrices Psn is given by
the Kronecker product of n Pauli matrices

Psn = Ps0 ⊗ Ps1 ⊗ · · · ⊗ Psn−1,

(2.51)

where each matrix Psk

is one of the Pauli matrices {I, X, Y, Z}.

By (2.51), a string of Pauli matrices Psn corresponds to the parallel
application of single-qubit gates, with gate Psk ∈ {I, X, Y, Z} being
applied to the k-th qubit. Some of the Pauli matrices in (2.51) can be

2.6. Multi-Qubit Quantum Gates

57

selected as the identity matrix I, indicating that non-trivial quantum
gates are applied only to a subset of qubits. The weight of a Pauli
string is the number of Pauli operators in it that are diﬀerent from the
identity I.

As we have seen in Sec. 1.4.6, an arbitrary 2 × 2 matrix can be
expressed as a linear combination of the four Pauli matrices {I, X, Y, Z}.
More generally, an arbitrary 2n × 2n (bounded) matrix A, with arbitrary
complex entries, can be written as a linear combination of a linear
combination of all 4n strings of n Pauli matrices, i.e.,

A = X

asnPsn,

sn∈{0,1,2,3}n

with (generally complex) coeﬃcients asn given as

asn =

1
2n

tr (APsn) .

(2.52)

(2.53)

For Hermitian matrices, the coeﬃcients are real; while for unitary
matrices the vector of coeﬃcients has unitary norm.

By the decomposition (2.52), in a manner that parallels the rela-
tionship between separable and quantum states covered in Sec. 2.5.3,
a unitary matrix operating on n qubits can be expressed as a linear
combination of local operators.

2.6.2 Quantum Gates as Change-of-Basis Transformations

Generalizing the discussion in Sec. 1.4.3, a transformation is unitary if
it can be written in the change-of-basis form

U =

2n−1
X

x=0

|vxihux|,

(2.54)

for two orthonormal bases {|v0i, |v1i, ..., |v2n−1i} and {|u0i, |u1i, ..., |u2n−1i}
of the 2n-dimensional Hilbert space. Accordingly, the transformation
U maps each vector |uxi in the ﬁrst set of 2n orthogonal vectors into
a vector |vxi in the second set of 2n orthogonal vectors. Recall that,
by linearity, specifying how the operator acts on each vector of a basis
of 2n orthogonal vectors as in the decomposition (2.54) is suﬃcient to
describe the output of the operator for any input state.

58

Classical Bits (Cbits) and Quantum Bits (Qubits)

As a useful special case, a transformation that maps vectors in the
computational basis to a permutation of the same set of vectors is
unitary. To deﬁne such a transformation, let π(x) be a permutation of
the integers x ∈ {0, 1, ..., 2n − 1}. Then, the matrix operating as

U |xi = |π(x)i

(2.55)

on the computational basis is unitary.

One way to deﬁne a permutation π(x) is via a cyclic shift of the
n-bit binary strings x, with shift given by some n-cbit string y. This
yields the permutation π(x) = x ⊕ y, where ⊕ represents the element-
wise XOR operation and x and y are interpreted as n-cbit strings. By
(2.55), the resulting unitary matrix operates as

U |xi = |x ⊕ yi

(2.56)

on the vectors of the computational basis. By (1.29), the Pauli X gate
can be interpreted as applying a cyclic shift with y = 1.

2.6.3 Quantum Gates as Transformations with Unitary Magnitude

Eigenvalues

As detailed in Sec. 1.4.4, unitary matrices are normal, and hence they
can be characterized in terms of their eigendecomposition (1.46). Fur-
thermore, all their eigenvalues have unitary magnitude.

For instance, a non-trivial Pauli string (2.51), in which at least one
of the Pauli matrices is diﬀerent from the identity, has an equal number,
2n/2, of eigenvalues equal to 1 and to −1. This follows from the fact
that the set of eigenvalues of a Kronecker product of normal matrices
is given by the set of all products of combinations of eigenvalues of the
constituent matrices.

2.6.4 Two-Qubit Controlled Quantum Gates

A common way to construct two-qubit quantum gates is to use one
qubit as a “switch” controlling whether a given single-qubit gate U is
applied to a second qubit. This important construction is described in
this subsection.

2.6. Multi-Qubit Quantum Gates

59

j

k

U

Figure 2.6: A two-qubit controlled quantum gate, also known as controlled-U gate.
The qubit indexed as j is the controlling qubit and the qubit labelled by k is the
controlled qubit.

Given a single-qubit gate deﬁned by a 2 × 2 unitary matrix U , a
two-qubit controlled quantum gate is described by a 4 × 4 matrix
, in which the ﬁrst index j identiﬁes the controlling qubit, while
CU
jk
the second index k identiﬁes the controlled qubit. The gate CU
is also
jk
referred to as controlled-U gate. The symbol used to represent the
controlled-U gate CU
jk

in a quantum circuit is shown in Fig. 2.6.

To describe the operation of the controlled-U gate, let us ﬁx qubit
j = 0 as the controlling qubit and qubit k = 1 as the controlled qubit
for simplicity of notation. The controlled-U quantum gate CU
, applied
01
to the system of the two qubits, is deﬁned by the unitary matrix

CU
01

= |0ih0| ⊗ I + |1ih1| ⊗ U,

(2.57)

where I is the 2 × 2 identity matrix. One can easily check that this
transformation is indeed unitary, since it satisﬁes the deﬁning condition
(1.32), i.e.,

(CU
01

)†CU
01

= |0ih0| ⊗ I + |1ih1| ⊗ U †U
= |0ih0| ⊗ I + |1ih1| ⊗ I
= (|0ih0| + |1ih1|) ⊗ I = I,

(2.58)

where we have used the resolution-of-identity equality (cf. (1.40))

|0ih0| + |1ih1| = I.

(2.59)

Similarly, we have the equality CU
01

(CU
01
To see what a two-qubit controlled quantum gate does (and to prove
in a diﬀerent way that it is unitary), it is suﬃcient to evaluate the output
of the gate when applied to the four vectors of the computational basis.
As we have seen, this follows by linearity since any two-qubit state

)† = I.

60

Classical Bits (Cbits) and Quantum Bits (Qubits)

(2.21) can be expressed as a linear combination of computational-basis
vectors. We obtain

CU

01|00i = (|0ih0| ⊗ I + |1ih1| ⊗ U )(|0i ⊗ |0i)
= |0ih0|0i ⊗ |0i + |1ih1|0i ⊗ U |0i
= |0i ⊗ |0i = |00i

CU
CU
CU

01|01i = |01i
01|10i = |1i ⊗ U |0i
01|11i = |1i ⊗ U |1i.

(2.60)

In words, when applied to vectors in the computational basis, the
applies the single-qubit gate U to the
controlled quantum gate CU
01
controlled qubit when the controlling qubit is in state |1i, while no
operation is applied to second qubit when the controlling qubit is in state
|0i. The controlling qubit hence acts as a “switch” for the application
of the single-qubit gate U on the controlled qubit.

As an example, assume that the input state of the two qubits is given
by the separable state |ψi = |+i ⊗ |ψi, where |ψi is an arbitrary state
of the controlled qubit. Then, applying the controlled-U gate yields

CU
01

(|+i ⊗ |ψi) =

1
√
2

(|0i ⊗ |ψi + |1i ⊗ U |ψi).

(2.61)

Therefore, when the controlling qubit is in a superposition state, here
state |+i, the computation separates into two superimposed branches.
In one branch, the controlling qubit is in state |0i and hence the con-
trolled qubit is unchanged; while in the other branch the controlling
qubit is in state |1i and hence the controlled qubit undergoes transfor-
mation U . Note also that, while the input state |+i ⊗ |ψi is separable,
the output state (2.61) is generally entangled.
In matrix form, the controlled-U gate CU
01

gate can be written as

CU
01

=








0
0
1 0
0 1
0
0
0 0 U11 U12
0 0 U21 U22








,

(2.62)

where Ulm is the (l, m)-th entry of matrix U .

2.6. Multi-Qubit Quantum Gates

61

X

Figure 2.7: A CNOT gate, or controlled-X gate, represented in one of two equivalent
ways (cf. Fig. 1.4). The representation on the right makes it clear that the CNOT
gate, when applied to the computational-basis vectors, reports the XOR of the two
states on the controlled qubit.

2.6.5 Examples of Two-Qubit Controlled Gates

In this subsection, we elaborate on two examples of two-qubit controlled
gates. A ﬁrst important two-qubit controlled gate is the controlled-X
(CX) gate, also known as controlled-NOT (CNOT) gate, which is
obtained by choosing the single-qubit gate U = X. Given its relevance,
the CNOT gate CX
is commonly denoted as C01, hence removing the
01
speciﬁcation of the single qubit gate X. The CNOT gate is represented
in a quantum circuit in either one of the two ways shown in Fig. 2.7,
mirroring the corresponding representations of the NOT gate in Fig.
1.4.

The representation on the right of Fig. 1.4 helps one remember
that the CNOT gate, when applied to vectors in the computational
basis, reports the XOR of the two pre-gate states on the state of the
controlled qubit. Indeed, applying the CNOT gate to the states in the
computational basis yields the outputs

C01|00i = |0, 0 ⊕ 0i = |00i
C01|01i = |0, 0 ⊕ 1i = |01i
C01|10i = |1, 1 ⊕ 0i = |11i
C01|11i = |1, 1 ⊕ 1i = |10i.

(2.63)

Specializing (2.62), we can also write the CNOT gate as the unitary
matrix



C01 =








1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0

.






(2.64)

As a numerical example, consider the application of the CNOT gate

62

Classical Bits (Cbits) and Quantum Bits (Qubits)

Figure 2.8: A controlled-Z (CZ) gate. The symbol reﬂects the symmetry of the
gate with respect to the two qubits.

to the Bell states |Ψ−i, which yields

C01|Ψ−i =

1
√
2

C01(|01i − |10i) =

1
√
2

(|01i − |11i).

(2.65)

The mapping (2.63) can be also interpreted in terms of the charac-
terization of unitary matrices discussed in Sec. 2.6.2. In fact, by (2.63),
the CNOT gate maps vectors |x, yi in the computational basis to a
permuted version of the same vectors as

C01|x, yi = |x, x ⊕ yi,

(2.66)

with x, y ∈ {0, 1}. The state |x, y ⊕ xi is obtained by “shifting” by x
the state of the second qubit.

A second commonly implemented controlled gate is the controlled-
Z (CZ) gate, which is obtained by setting the single qubit gate as
U = Z. Unlike the CNOT gate, the operation of a CZ gate is symmetric
with respect to the choice of the controlling and controlled qubits, in
the sense that we have the equalities

CZ
01

= CZ
10

=








0
1 0 0
0
0 1 0
0 0 1
0
0 0 0 −1








.

(2.67)

Reﬂecting this symmetry, the symbol used to describe a CZ gate in a
quantum circuit is as in Fig. 2.8. Equivalently, we can describe a CZ
gate via its application to the computational-basis vector as

CZ

10|x, yi = (−1)xy|x, yi

(2.68)

for all x, y ∈ {0, 1}.

2.6. Multi-Qubit Quantum Gates

63

2.6.6 Quantum Gates from Reversible Classical Binary Functions

The characterization (2.63) of the CNOT gate suggests a useful approach
to deﬁne a larger class of unitary transformations as an extension of
classical reversible binary functions. Accordingly, one starts with a
reversible binary mapping to deﬁne the operation on the computational-
basis vectors, and then the unitary is extended by linearity to any
quantum input state.

For example, in the case of the CNOT gate, the classical function is
the reversible implementation of the XOR operation given by (x, y) 7→
(x, x ⊕ y) with x, y ∈ {0, 1}. Note that this function can be readily
inverted, since we have the mapping (x, x ⊕ y) 7→ (x, x ⊕ y ⊕ x) = (x, y).

2.6.7 Quantum Gates from Hermitian Generators

As introduced in Sec. 1.4.5, a unitary matrix U can be expressed in
terms of a Hermitian generator G via (1.54), i.e.,

U = exp(−iG).
Using the decomposition (2.52) for the generator G allows us to write
any 2n × 2n unitary matrix U in terms of Pauli strings as


 ,
−i

U = exp(−iG) = exp

asnPsn

(2.70)

(2.69)

X









sn∈{0,1,2,3}n

where the coeﬃcients asn are real. Furthermore, by Euler’s formula,
if the sum includes a single Pauli string P , i.e., if U = exp(−iaP ) for
some real number a, we can also write

U = exp(−iaP ) = cos (a) I − i sin (a) P.
An example for n = 1 is given by (1.62). We refer to Appendix A in
Chapter 6 for extensions of the characterization (2.70).

(2.71)

2.6.8 Universal Gates

We conclude this section by noting that it can be proved that the set of
gates {CNOT, H, T }, where

T =

" 1

0

0 exp(i π
4

)

#

,

(2.72)

64

Classical Bits (Cbits) and Quantum Bits (Qubits)

is universal, that is, from these gates one can implement any unitary
matrix on any number of qubits.

Interestingly, in stark contrast, quantum circuits consisting only of

the set of gates {CNOT, H, S}, where

#

(2.73)

S =

" 1 0
0 i
√

is the phase gate (also denoted as
Z), can be eﬃciently simulated
on a classical computer. Such circuits implement unitaries that be-
long to the so-called Cliﬀord group, and the result concerning the
feasibility of implementation on classical computers is known as the
Gottesman–Knill theorem.

2.7 Creating Entanglement

In order to create entanglement between two qubits that are initially in
a separable state (i.e., not entangled), it is necessary to apply two-qubit
gates. A standard circuit that can be used to entangle two qubits is
shown in Fig. 2.9. For all separable input states of the form |xyi with
x, y ∈ {0, 1}, the outputs of the circuit are given as

C01(H ⊗ I)|00i =

C01(H ⊗ I)|01i =

C01(H ⊗ I)|10i =

C01(H ⊗ I)|11i =

1
√
2
1
√
2
1
√
2
1
√
2

(|00i + |11i) = |Φ+i

(|01i + |10i) = |Ψ+i

(|00i − |11i) = |Φ−i

(|01i − |10i) = |Ψ−i.

(2.74)

Therefore, the output vectors correspond to entangled pairs of qubits
in the Bell basis. We can more concisely write the output of the circuit
as the state

C01(H ⊗ I)|xyi =

1
√
2

(|0yi + (−1)x|1¯yi)

(2.75)

with ¯y = y ⊕ 1.

2.8. Amplitude Diagrams

65

H

|xi

|yi

X

(|0yi + (−1)x|1¯yi)

1√
2

Figure 2.9: A CNOT-based circuit that produces entangled pairs in the Bell basis
(with x, y ∈ {0, 1}).

|0i

|0i

H

H

(|+i|0i + |−i|1i)

1√
2

Figure 2.10: A CZ-based circuit that produces entangled pairs in the Bell basis
(with x, y ∈ {0, 1}).

One can also create entanglement via the controlled-Z (CZ) gate
using the circuit shown in Fig. 2.10. It can be readily checked that this
circuit yields the entangled state

|ψi =

=

=

1
(|00i + |01i + |10i − |11i)
2
1
√
2
1
√
2

(|+i|0i + |−i|1i),

(|0i|+i + |1i|−i)

(2.76)

which can be converted to the Bell state |Φ+i by applying the Hadamard
gate H to the ﬁrst qubit or to the second qubit.

2.8 Amplitude Diagrams

As introduced in Sec. 1.5, amplitude diagrams provide an alternative
means to visualize and describe the operation of a quantum circuit.
Unlike the standard quantum circuit diagram with one wire per qubit,
an amplitude diagram has one wire per amplitude, and it illustrate the
interaction among the amplitudes as time ﬂows from left to right. As
a result, instead of having n wires like a quantum circuit, an ampli-
tude diagram contains 2n wires. This makes amplitude diagrams only
applicable, in practice, for systems with a small number of qubits.

66

Classical Bits (Cbits) and Quantum Bits (Qubits)

To illustrate the use of amplitude diagrams, consider the entangling
circuit in Fig. 2.9. This corresponds to a 4 × 4 transformation, and
hence it requires four wires, each reporting the amplitude of one of the
states in the computational basis {|00i, |10i, |01i, |11i}. The resulting
amplitude diagram is shown in Fig. 2.11. The operation of the Hamadard
transformation on the ﬁrst qubit is expressed by the matrix

H ⊗ I =








1
√
2

1
1 0
0 1
0
1 0 −1
0 1

0
1
0
0 −1








.

(2.77)

Interesting, while the operation of the transformation H ⊗ I is local,
the transformation applies jointly to all amplitudes, as illustrated by
the amplitude diagram. The following CNOT gate implements multipli-
cation with matrix (2.64), which swaps the last two amplitudes. The
ﬁgure shows the evolution of the amplitudes for the input state |10i,
producing as the output the Bell state |Φ−i. In the ﬁgure, for simplicity,
the amplitudes are not normalized.

2.9 Superdense Coding

Entanglement provides a new resource that can be leveraged to support
communications and computing primitives. In this section, we provide
an example of the role that entanglement can play for communications.
In particular, we will see how the availability of an entangled pair of
qubits, with a qubit held at a transmitter and the other at a receiver,
can increase the communication capacity between the two ends of the
link.

To describe the setting of interest, consider a noiseless quantum
channel whereby Alice can send one qubit (e.g., one photon) to Bob.
With one qubit, it is possible to show that Alice cannot communicate
more than a single cbit of information to Bob. In fact, it is possible
to detect unambiguously only two states of a single qubit via a mea-
surement. This is because one can only deﬁne two mutually orthogonal
states in a two-dimensional space. This limitation remains true if Alice
and Bob share statistically dependent cbits that are independent of

2.9. Superdense Coding

67

0

00

H ⊗ I

0

1

01

10

11

0

1

0

-1

0

-

-

CN OT

1

0

0

-1

Figure 2.11: An amplitude diagram representing the operation of the entangling
circuit in Fig. 2.9. The input state is |10i, producing as the output state the Bell state
|Φ−i. The amplitudes at each step are not normalized for simplicity of visualization.

68

Classical Bits (Cbits) and Quantum Bits (Qubits)

the information cbits. That is, randomizing encoding and decoding
strategies, even in a coordinated fashion based on shared randomness,
is not useful in increasing the capacity between Alice and Bob.

Given this context, we ask the question: What if Alice and Bob
share a pair of entangled qubits? To avoid trivial answers, we speciﬁcally
assume that the qubits are prepared before selecting the information
cbit and are hence independent of the information message.

To elaborate, assume that Alice and Bob share a Bell pair

1
√
2

(|00i + |11i) = |Φ+i,

(2.78)

with the ﬁrst qubit at Alice and the second at Bob. If this pair of
qubits behaved as a pair of conventional cbits, the actual state of the
system would |00i or |11i with equal probability. Accordingly, Alice and
Bob would share one bit of common randomness. As discussed earlier
in this section, common randomness cannot help Alice convey more
information than a single cbit by sending a single qubit. But, as we
have argued in Sec. 2.5.2, entangled qubits do not behave like correlated
random cbits. This reinforces the question at hand: Can we use the
new resource of entanglement to enhance the classical capacity of the
channel between Alice and Bob?

As we will see next, with a shared Bell pair, Alice can communicate
two cbits to Bob with a single qubit. To this end, we follow the steps
illustrated in Fig. 2.12, which are summarized as follows.

• Alice selects at random two cbits of information (x0, x1), with

x0, x1 ∈ {0, 1}.

• Then, Alice encodes this information by applying a one-qubit
gate to its qubit as indicated in Table 2.2. Mathematically, given
two cbits, the transformation applied by Alice is described by the
unitary Zx1X x0.

• After applying this transformation, Alice sends her qubit to Bob.
Then, Bob applies the unitary transformation shown in Fig. 2.12
to both qubits. This transformation comprises the cascade of a
CNOT and of a Hadamard gate to the ﬁrst qubit.

2.9. Superdense Coding

69

message

transformation

00

01

10

11

I =

X =

#

#

" 1 0
0 1
" 0 1
1 0

Z =

ZX =

#

#

" 1

0
0 −1
" 0

1
−1 0

Table 2.2: Mapping between message and transformation applied by Alice to her
qubit in superdense coding.

• Finally, a standard measurement of the two qubits is made at
Bob. The output measurement cbits can be shown to equal the
message (x0, x1) with probability 1.

Let us now verify that indeed the superdense coding protocol illus-
trated in Fig. 2.12, with Alice’s encoding mapping in Table 2.2, allows
Bob to recover Alice’s message with probability 1. To this end, it can be
directly checked that the state of the two qubits before the measurement,
i.e., at step 3 in Fig. 2.12, is given by

|ψ3i = |00i if Alice chooses I
|ψ3i = |01i if Alice chooses X
|ψ3i = |10i if Alice chooses Z
|ψ3i = |11i if Alice chooses ZX.

(2.79)

Therefore, by Born’s rule, measuring the two qubits allows Bob to
recover Alice’s message.

To elaborate further on (2.79), let us consider as an example the case
in which Alice chooses message 01 and hence, by Table 2.2, it applies
the Pauli X gate on her qubit. The two qubits assume the following

70

Classical Bits (Cbits) and Quantum Bits (Qubits)

1

2

3

4

Alice enc

H

(cid:12)
(cid:12)Φ+(cid:11)

X

Figure 2.12: Operations carried out by Alice and Bob in superdense coding.

states at the times numbered in Fig. 2.12:

|ψ1i = (X ⊗ I)|Φ+i =

1
√
2

(|10i + |01i)

|ψ2i = CAB|ψ1i =

1
√
2

(|11i + |01i)

|ψ3i = (H ⊗ I)|ψ2i =

1
2

(|01i − |11i + |01i + |11i) = |01i,

(2.80)

where we have used indices A and B to identify the qubits at Alice and
Bob, respectively.

As we will see in the next chapter, one way to understand why
superdense coding works is to note that the four 4-dimensional states
|ψ1i obtained upon applying one of the four transformations by Alice
are orthogonal, and hence distinguishable at Bob. The “non-classicality”
of this phenomenon is that the four distinguishable states are obtained
by means of a local operations at Alice, who has only access to one
of the two entangled qubits. To explain this perspective, in the next
chapter, we will generalize the type of measurements considered thus
far, which apply separately to each qubit, to joint measurements across
multiple qubits.

2.10 Trading Quantum and Classical Resources

Superdense coding illustrates the general concept that classical and
quantum resources can be traded for one another. In particular, super-
dense coding can be interpreted as revealing the following resource
transfer inequality

1 ebit + 1 qubit ≥ 2 cbits,

(2.81)

2.11. Conclusions

71

where “ebit” indicates a Bell pair of entangled qubits. The inequality
indicates that having the resources on the left-hand side allows one to
realize the resources on the right-hand side. Since one qubit can encode
1 cbit of information, one can also think of this resource inequality as
stating that the initial ebit can be converted into one cbit of potential
information.

Another classical example of how one can trade classical and quan-
tum resources is teleportation. To describe it, consider a classical
channel that Alice can use to share cbits with Bob. In order to commu-
nicate exactly an arbitrary quantum state, Alice would need to transmit
an inﬁnite number of bits to describe a unitary-norm two-dimensional
complex vector. But what if Alice and Bob share an entangled pair
of qubits, which is independent of the qubit to the communicated? It
turns out that in this case it is possible to communicate one qubit in
an arbitrary state by communicating only two cbits from Alice to Bob.
This leads to the resource inequality

1 ebit + 2 cbits ≥ 1 qubits.

(2.82)

2.11 Conclusions

In this chapter, we have introduced the formalism necessary to describe
multi-qubit states. Extending the discussion for single qubits in the
previous chapter, we have reviewed the two ways in which a quantum
system can evolve, namely through a unitary transformation or through
measurements. Unitary transformations are described by quantum cir-
cuits that are implemented via sequences of one- and two-qubit gates,
with controlled gates playing a key role in the latter category. We have
seen how a new phenomenon presents itself in multi-qubit systems: en-
tanglement. Entanglement can be viewed as a strong form of statistical
dependence that has no classical counterpart. Entangled qubits provide
a novel resource that can be used for computation and communications.
The next chapter will cover more implications of entanglement (see Sec.
3.3.3).

72

Classical Bits (Cbits) and Quantum Bits (Qubits)

2.12 Recommended Resources

As for the previous chapter, the reader is referred to [1] and [2] for
clear and intuitive introductions to the topics covered in this chapter.
For a physics-based perspective, useful references include [4], [5]. An
introduction to tensor networks is provided by [6].

2.13 Problems

1. Show that it is possible to convert one Bell basis vector into any
other by means of local unitary transformations applied at any
of the two qubits. For instance, applying local operations on the
ﬁrst system as

(ZzX x ⊗ I)|Φ+i

(2.83)

we have |Ψ+i with z = 0 and x = 1; |Φ−i with z = 1 and x = 0;
and |Ψ−i with z = 1 and x = 1.

2. Show that the following four vectors are orthonormal and that

they have unitary norm:

cos(θ)|00i + sin(θ)|11i
cos(θ)|01i + sin(θ)|10i
sin(θ)|00i − cos(θ)|11i
sin(θ)|01i − cos(θ)|10i.

(2.84)

Therefore, for any θ, these four vectors form an orthonormal basis
of the 4-dimensional Hilbert space.

3. Use the ﬁrst state in the orthonormal basis identiﬁed at the
previous problem as the input for the circuit in the bottom part of
Fig. 2.4. Compute the probability that the two random cbits at the
output of the measurement are equal. Argue that, as θ increases
in the interval [0, π/2], the two input qubits are increasingly
entangled.

4. Prove that for any 2 × 2 operator M , we have the equality (M ⊗
I)||Φ+i = (I ⊗ M T )|Φ+i (this is known as “transpose trick”).

2.13. Problems

73

5. Consider the Bell state |Φ+i and apply the separable transforma-
tion RY (θ0) ⊗ RY (θ1) followed by a measurement. Demonstrate
that the probability that the two cbits produced by the mea-
surement are equal depends on the diﬀerence θ0 − θ1 of the two
rotation angles θ0 and θ1.

6. Describe qudits as an extension of qubits to multi-valued quantum

states (see recommended resources).

7. Prove that superdense coding is private in the sense that an
eavesdropper intercepting the transmitted qubit would not be
able to obtain any information about the two bits encoded by
Alice.

8. For superdense coding, show that the four 4-dimensional states
|ψ1i obtained upon applying the four transformations by Alice
are orthogonal.

9. Describe teleportation (see recommended resources).

10. Prove the equivalence between quantum circuits illustrated in the

ﬁgures below.

Z

X

Z

H

X

X

H

X

X

X

X

X

=

=

=

=

X

X

X

Z

X

74

Classical Bits (Cbits) and Quantum Bits (Qubits)

X

Z

X

=

Z

Z

3

Generalizing Quantum Measurements (Part I)

3.1 Introduction

In this chapter, we generalize quantum measurements in two important
ways:

• We introduce von Neumann measurements in any orthonormal

basis – not limited to the computational basis;

• and we discuss situations in which only a subset of the qubits is

measured.

The ﬁrst generalization will allow us to deﬁne joint measurements across
multiple qubits, which go beyond the separate, per-qubit, measurements
considered thus far. The second will leads us to deﬁne the key concepts
of density state, decoherence, and partial trace.

3.2 Measurements in an Arbitrary Orthonormal Basis

So far, we have considered the most common type of von Neumann mea-
surements, namely measurements in the computational basis {|xi}2n−1
,
x=0
also known as standard measurements. As described in the pre-
vious chapter and illustrated in Fig. 2.1, these amount to separate

75

76

Generalizing Quantum Measurements (Part I)

measurements of each qubit. In this section, we generalize von Neu-
mann measurements by allowing for measurements in an arbitrary
orthonormal basis. As we will see, this generalized class of von Neu-
mann measurements includes also joint measurements across multiple
qubits.

As a point of notation, we will frequently use interchangeably the
integer notation x ∈ {0, 1, ..., 2n − 1} and the n-cbit string notation
x0, x1, ..., xn−1 with xk ∈ {0, 1}, which are mutually related via (2.4).
Speciﬁcally, we write x ∈ {0, 1}n to denote either an integer in the
range {0, 1, ..., 2n − 1} or the corresponding n-cbit string. Given the
one-to-one mapping (2.4), conﬂating the two quantities is well justiﬁed
and notationally convenient.

3.2.1 Reviewing Standard Measurements

For a system of n qubits in pre-measurement state |ψi, by Born’s rule
(2.32), a standard measurement return x ∈ {0, 1}n with probability

|hx|ψi|2,

(3.1)

leaving the system in the post-measurement state equal the computa-
tional basis vector |xi. The probability (3.1) corresponds to the magni-
tude squared of the projection of state |ψi onto the computational-basis
vector |xi. As a result of the measurement, the quantum state |ψi
“collapses” into one of the vectors in the computational basis. Recall
that each vector |xi = |x0, x1, ..., xn−1i in the computational basis corre-
sponds to a separable state in which each qubit k has an individual state
|xki. Therefore, a standard measurement destroys any entanglement
that may exist in the pre-measurement state |ψi.

3.2.2 Deﬁning Measurements in an Arbitrary Orthonormal Basis

To specify the more general form of von Neumann measurement of
interest in this section, we ﬁx a set of 2n orthonormal basis vectors
|v0i, ..., |v2n−1i, each of dimension 2n × 1. Choosing the vectors in the
computational basis, i.e., setting |vxi = |xi for all x ∈ {0, 1}n, recovers
the standard measurement. More generally, the vectors |vxi may be
chosen in an arbitrary way, as long as they form an orthonormal basis.

3.2. Measurements in an Arbitrary Orthonormal Basis

77

x

n

|ψi

n

|vxi w.p. |hvx|ψi|2

Figure 3.1: Illustration of a von Neumann measurement in an arbitrary orthonormal
basis {|vxi}2n−1
x=0 . Note that in this ﬁgure we make an exception to the conventional
used in the rest of the text of using the gauge block to represent a measurement in
the computational basis.

In particularly, they may be separable or entangled. We will see that
separable states describe local, per-qubit, measurements, while entangled
states specify joint measurements across multiple qubits.

Given an input state |ψi, a measurement in the basis {|v0i, ..., |v2n−1i}
is deﬁned by the following two properties, which are illustrated in Fig.
3.1.

• Born’s rule: The probability of observing the n-cbit string x ∈

{0, 1}n is

Pr[measurement output equals x ∈ {0, 1}n] = |hvx|ψi|2;

(3.2)

• “Collapse” of the state: If the measured n-cbit string is x, the

post-measurement state of the qubits is |vxi.

As anticipated, these properties recover the deﬁnition of a standard
measurement given in the previous chapter when we set |vxi = |xi for all
x ∈ {0, 1}n. Note, in particular, that the probability (3.2) corresponds,
geometrically, to the projection of the quantum state |ψi onto the basis
vector |vxi. It is also useful to observe that, unlike the special case of
standard measurements, the post-measurement state |vxi need not be
separable.

To illustrate the impact of the choice of the measurement basis, let
us consider two examples. First, for a single-qubit setting, let us adopt
the diagonal basis {|+i, |−i}. With it, the output of a measurement of
a qubit in state |+i is equal to 0 with probability 1, leaving the state
|+i unchanged. In contrast, a standard measurement of state |+i would
output 0 or 1 with equal probability, “collapsing” the state to either
state |0i or |1i.

As a second example, for n = 2 qubits, one could consider the
measurement of two qubits in the Bell basis {|Φ+i, |Ψ+i, |Φ−i, |Ψ+i}

78

Generalizing Quantum Measurements (Part I)

for the 2n = 22 = 4-dimensional Hilbert space. Note that these vectors
correspond to entangled states. Given an input Bell state |Φ+i, this
measurement produces output 0 with probability 1, leaving the state
unchanged. This is in clear contrast to the case of a standard mea-
surement of state |Φ+i, which would yield outputs 00 or 11 with equal
probability, leaving the qubits in the corresponding separable state |00i
or |11i.

3.2.3

Implementing Measurements in an Arbitrary Orthonormal
Basis

As we discuss in this subsection, a measurement in an arbitrary or-
thonormal basis {|vxi}2n−1
can be equivalently realized via standard
x=0
measurements (in the computational basis) by applying suitable unitary
transformations before and after the measurement as illustrated in Fig.
3.2. While standard measurements are always separable across qubits,
the pre- and post-measurement unitaries are generally not separable. In
particular, measurements deﬁned by orthonormal bases with entangled
state will be seen to require unitary transformations that apply across
multiple qubits.

The unitary transformation to be applied before the measurement
maps each vector |vxi into the computational-basis vector |xi. Intu-
itively, by applying such a change-of-basis mapping, one can use a
standard measurement to measure in the basis {|vxi}2n−1
. Following
x=0
the discussion in Sec. 2.6.2, this transformation is given by the unitary
matrix

2n−1
X

Uvx→x =

|xihvx|.

(3.3)

x=0
The post-measurement transformation is given by the inverse of the
pre-measurement transformation Uvx→x, i.e.,

U −1

vx→x

= U †

vx→x

= Ux→vx

=

2n−1
X

x=0

|vxihx|,

(3.4)

which maps the computational-basis vector |xi into vector |vxi.

To see that the circuit in Fig. 3.2 implements a von Neumann
, let us evaluate the probability of

measurement in basis {|vxi}2n−1
x=0

3.2. Measurements in an Arbitrary Orthonormal Basis

79

n

|ψi

Uvx→x

x

n

Ux→vx

|vxi w.p. |hvx|ψi|2

Figure 3.2: Implementation of a measurement in an arbitrary orthonormal basis
{|vxi}2n−1
x=0 via standard measurements and unitary pre- and post-measurement
transformations. Note that here, and in the rest of the text, the gauge block represents
a standard measurement.

observing outcome x given an input state |ψi. By the Born rule, since the
state entering the standard measurement is Uvx→x|ψi, this probability
is computed as

|hx|Uvx→x|ψi|2 = |(Ux→vx|xi)†|ψi|2 = |hvx|ψi|2,

(3.5)

which coincides with (3.2). Furthermore, given measurement output x,
after the second transformation, the qubits are in state Ux→vx|xi = |vxi.
To illustrate the implementation of the circuit in Fig. 3.2, let us con-
sider the two examples described in the previous subsection. Measuring
a single qubit in the diagonal basis {|+i, |−i} requires implementing the
pre-measurement unitary (3.3) that maps the diagonal basis into the
computational basis. As discussed in Sec. 1.4.3, this can be done via the
Hadamard transform H, which maps state |+i to |0i and state |−i to
|1i. Alternatively, it can also be implemented via the Pauli Y -rotation
RY (π/2), which maps state |−i to |0i and |+i to |1i.

The second example is given by the measurement of n = 2 qubits
in the Bell basis. The Bell basis measurement can be implemented by
means of the general circuit in Fig. 3.2 by employing the transformation
Uvx→x between Bell-basis vectors and computational-basis vectors and
its inverse. The change-of-basis transformation Uvx→x at hand – which
we will denote as UBell→Comp – can be implemented as in Fig. 3.3 via
the cascade of a CNOT gate and a Hadamard gate on the ﬁrst qubit.
In fact, we have the mapping

UBell→Comp|Φ+i = |00i
UBell→Comp|Ψ+i = |01i
UBell→Comp|Φ−i = |10i
UBell→Comp|Ψ−i = |11i,

(3.6)

80

Generalizing Quantum Measurements (Part I)

(|0yi + (−1)x|1¯yi)

1√
2

H

|xi

|yi

X

Figure 3.3: Unitary transformation UBell→Comp between Bell-basis vectors and
computational-basis vectors.

as summarized in Fig. 3.3. The inverse transformation,

UComp→Bell = U †

Bell→Comp,

(3.7)

is implemented by running the circuit in Fig. 3.3 backwards, which
corresponds to the entangling circuit in Fig. 2.9.

The architecture in Fig. 3.2 suggests that the complexity of perform-
ing measurements in arbitrary basis functions depends on the degree to
which the unitary Uvx→x can be eﬃciently described by one or two-qubit
gates. As suggested by the examples above and as can be readily proved,
if all basis vectors |vxi are separable, the change-of-basis transformation
Uvx→x in (3.3) amounts to local operations across the n qubits, and so
does its inverse Ux→vx
. Therefore, in this case, the circuit in Fig. 3.2 can
be realized via the parallel application of single-qubit gates. In contrast,
if the orthonormal bases contain entangled states, implementing the
transformation Uvx→x requires the use of multi-qubit gates.

3.2.4 Revisiting Superdense Coding

As an application of the generalized measurements introduced in this
section, here we revisit the operation of superdense coding, which is
illustrated in Fig. 2.12. As discussed in Sec. 2.9, by applying local
unitaries as in Table 2.2, Alice can ensure that the pair of entangled
qubits – one at Alice, the other at Bob – is in one of the four Bell basis
states. After transferring her bit to Bob, Alice has thus guaranteed that
the four messages consisting of 2 cbits of information are encoded into
orthogonal states of the two qubits, now both at Bob’s side. How can
Bob detect which of the four orthogonal states was produced by Alice’s
encoding operation?

3.2. Measurements in an Arbitrary Orthonormal Basis

81

This can be readily done by implementing a joint measurement in
the Bell basis as described in the previous subsection. For instance, if
Alice encodes message 01, the joint state of the two qubits after Alice’s
encoding operation is |Ψ+i (see Sec. 2.9). Therefore, by the Born rule
(3.2) and given the mapping (3.6), a Bell basis measurement returns
output 01 with probability 1.

Based on this observation, we can now interpret the operation carried
out at Bob after Alice’s encoding in Fig. 2.12 as a measurement in
Bell basis. In fact, the circuit consisting of CNOT gate followed by
the Hadamard gate implements the Bell-basis-to-computational basis
transformation UBell→Comp in Fig. 3.3. Therefore, the ﬁnal measurement
in the computational basis in Fig. 2.12 eﬀectively produces the output
of a joint measurement in the Bell basis.

3.2.5 Computing the Norm of the Inner Product of Two Vectors

As another example of the usefulness of measuring in an arbitrary basis,
consider the seemingly unrelated problem of computing the squared
absolute value of the inner product between two vectors |wi and |ψi
of equal dimension 2n, i.e., |hw|ψi|2. This is known as the ﬁdelity
between states |wi and |ψi. The inner product plays a key role in many
signal processing and machine learning applications, including kernel
methods. An application will be discussed later in this subsection. We
will see next that we can estimate the quantity |hw|ψi|2 by making a
measurement of a state vector |ψi in an orthonormal basis that includes
vector |wi – along with other 2n − 1 arbitrary mutually orthogonal
vectors of unitary norm.

By Born’s rule, for such a measurement, the desired quantity |hw|ψi|2
is the probability of observing the output corresponding to vector |wi.
Using the architecture in Fig. 3.2, this measurement can be implemented
by constructing a unitary Uw that maps the basis at hand to the
computational basis. Without loss of generality, one may assume that
this transformation satisﬁes the equality Uw|wi = |0i, mapping state
|wi into state |0i. This way, the probability of observing output 0 from
a standard measurement of the state Uw|ψi equals |hw|ψi|2. Therefore,
the quantity |hw|ψi|2 can be estimated by repeating the described

82

Generalizing Quantum Measurements (Part I)

measurement multiple times and by evaluating the fraction of measured
outcomes equal to 0.

The circuit outlined in the previous paragraph can be used to design
a stochastic binary “quantum neuron”, in which the state |wi
plays the role of the weight vector. To this end, given an input state |ψi,
we apply the unitary Uw and then make a standard measurement. We
take the output of the neuron to be “active” if the measurement returns
0, and to be “inactive” otherwise. As we have seen, the probability of
the neuron being “active” is |hw|ψi|2, and hence we can think of the
function | · |2 as an activation function for the neuron. Note that with
only n qubits, this type of neuron can operate on vectors of exponentially
large size 2n. Caution should, however, be exercised in interpreting this
conclusion, since preparing state |ψi based on a classical data vector of
size 2n generally entails an exponential complexity in n.

3.3 Partial Measurements

In this section, we study a further extension of quantum measurements
whereby only a subset of qubits are measured (in some orthonormal
basis). We are interested in generalizing the Born rule, identifying the
probability distribution over the measurement outputs; as well as in
describing the post-measurement state of all qubits, both measured and
not measured.

Measurements of a subset of qubits are of interest for the following

reasons, among others:

• Many quantum protocols, such as teleportation, entanglement
swapping, and quantum error correction, rely on measurements of
a subset of qubits to determine subsequent quantum operations
to be applied on the system.

• Open quantum systems interact, and become entangled with,
qubits in the environment – a process that can be modelled as a
partial measurement applied by the environment on the quantum
system.

• Partial measurements can be used to implement projective mea-
surements, which ﬁnd many applications, including quantum error

3.3. Partial Measurements

83

correction (see Sec. 5.2).

In this section, we describe partial measurements, and we also cover
a “‘spooky” implication of the formalism introduced here concerning
the behavior of entangled qubits.

3.3.1

Introducing Partial, Single-Qubit, Measurements

To describe partial measurements, we start by considering a quantum
system of n qubits in which we measure only the ﬁrst qubit. The descrip-
tion provided in this subsection applies directly to the measurement of
any one of the n qubits in the system by properly reordering the opera-
tions involved. We focus ﬁrst on measurements in the computational
basis.

To begin, observe that the state |ψin of the overall system of n

qubits can always be expressed as

|ψin = α0|0i|φ0in−1 + α1|1i|φ1in−1,

(3.8)

where |φ0in−1 and |φ1in−1 are (unitary norm) 2n−1 × 1 state vectors,
and the amplitudes α0 and α1 satisfy the equality |α0|2 + |α1|2 = 1. The
decomposition (3.8) expresses the n-qubit state |ψin as a superposition
of two states in which the ﬁrst qubit is in either state |0i or state |1i.
We will see in the next subsection that the amplitudes can be chosen
without loss of generality as real numbers. Note that, throughout this
section, the subscript on the ket and bra states is used to indicate the
number of qubits.

As a numerical example of the decomposition in (3.8), consider the

state of n = 3 qubits

|ψi3 = i

2 |000i +

12 + 5i
26

|001i −

1
2 |101i +

3
10 |110i −

2i
5 |111i,

(3.9)

84

Generalizing Quantum Measurements (Part I)

|ψin = α0|0i|φ0in−1 + α1|1i|φ1in−1

x

|xi w.p. |αx|2

|φxin−1

Figure 3.4: Illustration of a partial measurement for a system of n = 3 qubits in
which a standard measurement is applied to the ﬁrst qubit.

which can be written in the form (3.8) as

|ψi3 =|0i
1
√
2

=

(cid:18) i
2 |00i +
(cid:18) i
√
2

|0i

12 + 5i
2

(cid:19)

|01i

+ |1i

|00i +

√

2

12 + 5i
26

|01i

(cid:18) 1
2 |01i +
(cid:19)

3
10 |10i −

2i
(cid:19)
5 |11i

|

+

1
√
2

|1i

(cid:18) 1
√
2

{z
|φ0i
3
10

|01i +

}

√

2|10i −

√

2

(cid:19)

2i
5 |11i

.

(3.10)

|

}

{z
|φ1i
In the decomposition (3.8), the vectors |φ0in−1 and |φ1in−1 are not
necessarily orthogonal. This can be readily checked in the example
above. In fact, the two vectors |φ0in−1 and |φ1in−1 can even be equal,
i.e., |φ0in−1 = |φ1in−1 = |φin−1, in which case the ﬁrst qubit is not
entangled with the other n − 1 qubits, since the joint state is separable:

|ψin = (α0|0i + α1|1i) ⊗ |φin−1.

(3.11)

Having introduced the decomposition (3.8), we are now ready to
deﬁne the operation of a single-qubit measurement on the ﬁrst qubit.
As illustrated in Fig. 3.4, a partial measurement in the computational
basis for the ﬁrst qubit of a system in state |ψi is described as follows.

• Generalized Born’s rule: The probability of observing x ∈

{0, 1} is

Pr[measurement output equals x] = |αx|2;

(3.12)

• “Partial collapse” of the state: If the measured cbit is x ∈

{0, 1}, the post-measurement state is |xi|φxin−1.

3.3. Partial Measurements

85

It can be readily seen that a partial measurement coincides with a
standard measurement when n = 1.

After a partial measurement of the ﬁrst qubit, the post-measurement
state |xi|φxin−1 is such that the ﬁrst qubit is not entangled with the
remaining n − 1 qubits, irrespective of whether it was entangled under
the original state |ψin. The unmeasured qubits can instead by in an
entangled state. We may say that the “collapse” of the state is partial,
in the sense that only the state of the ﬁrst qubit reduces to one of the
vectors, |xi, in the computational basis. In contrast, the state of the
remaining qubits, namely |φxin−1, still depends on the amplitudes of
the original state |ψi. Therefore, an observer obtaining measurement
outcome x would only know the state of the ﬁrst qubit, namely |xi, while
specifying the state |φxin−1 of the remaining qubits would generally
require knowledge of the amplitudes of the original state |ψi.

To illustrate the eﬀect of a partial measurement, consider again
the state (3.10). Making a standard measurement on the ﬁrst qubit,
the probability of observing cbit 0 is 1/2, and the corresponding post-
(cid:17). After the measure-
measurement state is |0i
ment, the ﬁrst qubit is no longer entangled with the rest of the system,
but the last two qubits are mutually entangled.

26 |01i

(cid:16) i√
2

|00i +

2 12+5i

√

3.3.2 Deﬁning Partial, Single-Qubit, Measurements

In this subsection, we provide a more formal description of partial
measurements of a single qubit introduced in the previous subsection.
To this end, we start by observing that the decomposition (3.8) can be
constructed as follows:

1. Evaluate the unnormalized states

| ˜φxin−1 = (hx| ⊗ I)|ψin
for x ∈ {0, 1}, where the identity matrix is of dimension 2n−1 ×
2n−1.

(3.13)

2. Set the amplitudes as
q

αx =

h ˜φx|n−1| ˜φxin−1 = ||| ˜φxin−1||2

(3.14)

for x ∈ {0, 1}.

86

Generalizing Quantum Measurements (Part I)

3. Compute the normalized states

|φxin−1 =

1

αx

| ˜φxin−1

(3.15)

for x ∈ {0, 1}.

Note that this construction demonstrates that the amplitudes {αx}1
can be taken without loss of generality to be real and positive.

x=0

As an example, for the state in (3.9), we have the unnormalized

states as

and

| ˜φ0i2 = (h0| ⊗ I)|ψi3 = i

2 |00i +

12 + 5i
2

|01i

(3.16)

| ˜φ1i2 = (h1| ⊗ I)|ψi3 =

1
2 |01i +
from which we can obtain (3.10) by following steps 2 and 3 in the
procedure outlined in the previous paragraph.

3
10 |10i −

2i
5 |11i,

(3.17)

With these deﬁnitions, a partial measurement in the computational
basis for the ﬁrst qubit of a quantum system in state |ψi is described
as follows.

• Generalized Born’s rule: The probability of observing x ∈

{0, 1} is

Pr[measurement output equals x] = (hx| ⊗ I)|ψinhψ|n(|xi ⊗ I);
(3.18)

• “Partial collapse” of the state: If the measured cbit is x ∈

{0, 1}, the post-measurement state is |xi|φxin−1 with

|φxin−1 =

(hx| ⊗ I)|ψin
p(hx| ⊗ I)|ψinhψ|n(|xi ⊗ I)

.

(3.19)

This description coincides with that given in the previous subsection, and
has the advantage of depending directly on the state |ψi. Furthermore,
it is straightforward to extend it to a measurement of the ﬁrst qubit in
any orthonormal basis {|vxi}1
by replacing x with vx in (3.18) and
(3.19). This extension is elaborated on in Sec. 3.3.4.

x=0

3.3. Partial Measurements

87

3.3.3 Spooky Action at a Distance

As an example of the use of partial measurements, let us consider a
situation in which two qubits in the Bell pair |Φ+i = 1/
2(|00i + |11i)
are physically separated by a large distance. Recall that Bell states
describe entangled qubits. The ﬁrst qubit is at an agent, conventionally
called Alice, while the second qubit is at a second agent called Bob.
Alice may be in London, while Bob may be arbitrarily far, say on the
moon. Alice carries out a standard measurement of her qubit, while
Bob does not apply any operation or measurement on his qubit.

√

By the generalized Born rule described in the previous two sub-
sections, Alice will observe measurement outputs 0 or 1 with equal
probability 1/2. Furthermore, the post-measurement state is |x, xi when
the measurement output at Alice is x ∈ {0, 1}. In words, after Alice’s
measurement, the qubits are no longer entangled, and they assume the
same state |xi, where x ∈ {0, 1} is the measurement output. What is
strange about this situation?

As we have discussed in Sec. 2.5.2, prior to Alice’s measurement, the
two qubits are not in either state |00i or state |11i. They must instead be
2(|00i + |11i).
described as being in the superposition state |Φ+i = 1/
Therefore, Alice’s measurement has somehow caused a change in the
joint state of the two qubits, which are no longer in state |Φ+i, but
rather in either state |00i or state |11i depending on the measurement
output. This is surprising because, as mentioned, Bob’s qubit may be
in principle arbitrarily far from Alice’s.

√

Overall, it appears that there has been an instantaneous “action”
from one qubit to the other – a physical impossibility due to limit
imposed by the speed of light. This is what Einstein called “spooky
action at a distance”. But has anything measurable actually been
transferred instantaneously from Alice to Bob?

It is true that Alice, based on her measurement, can predict, with
certainty, the output of a standard measurement of Bob’s qubit carried
out after Alice’s measurement. But from Bob’s perspective nothing has
changed. Since Bob does not know Alice’s measurement, he should view
his qubit as being in either state |0i or |1i, corresponding to the two
possible measurement outputs. Therefore, a measurement of Bob’s qubit

88

Generalizing Quantum Measurements (Part I)

would return 0 or 1 with equal probability, as if Alice had not carried
out her measurement. So, no information has actually been transferred
from Alice to Bob through Alice’s measurement, and there has been no
violation of the speed of light limit.

That said, if we wished to simulate the evolution of the state of
this two-qubit system using a classical distributed system, information
about Alice’s measurement output should indeed reach instantaneously
the classical system at Bob’s end in order to ensure a correct update of
the joint quantum state.

More discussion on entanglement and partial measurements can be
found in Appendix B at the end of this chapter for systems involving
more than two qubits.

3.3.4 Deﬁning Partial, Multi-Qubit, Measurements

In this subsection, we extend the partial measurement formalism intro-
duced in this section to systems of n qubits in which we measure any
subset of n0 ≤ n qubits in any orthonormal basis {|vxin0}2n0
. To this
end, without loss of generality, let us order the qubits so that the ﬁrst
n0 qubits are measured. Then, given an input state |ψi, the generalized
Born rule (3.18) and the post-measurement state (3.19) are directly
extended as follows.

x=0

−1

• Generalized Born’s rule: The probability of observing x ∈

{0, 1}n0 is

Pr[measurement output equals x] = (hvx|n0 ⊗ I)|ψinhψ|n(|vxin0 ⊗ I),

(3.20)

where the identity matrix I is of dimension 2n−n0 × 2n−n0;

• “Partial collapse” of the state: If the measured cbits are given
by string x ∈ {0, 1}n0, the post-measurement state is |vxin0|φxin−n0,
with

|φxin−n0 =

(hvx|n0 ⊗ I)|ψin
p(hvx|n0 ⊗ I)|ψinhψ|n(|vxin0 ⊗ I)

.

(3.21)

3.4. Non-Selective Partial Measurements and Decoherence

89

A

B

trash

Figure 3.5: A non-selective partial measurement on subsystem A.

3.4 Non-Selective Partial Measurements and Decoherence

What happens if, as illustrated in Fig. 3.5, we measure the qubits of one
subsystem, say A, and we “throw away” the result of this measurement?
By “throwing away” we mean that the result of the measurement is not
retained, and hence there is epistemic uncertainty about the outcome
of the measurement and about the corresponding post-measurement
state. Intuitively, discarding the outcome of the measurement introduces
classical randomness in the evolution of the system. We are interested
in describing the state of the remaining subsystem B, so as to be able
to describe how subsystem B may evolve after the measurement of
subsystem A. A measurement of the type illustrated in Fig. 3.5 is
known as a non-selective measurement, and is the subject of this
section.

3.4.1 Deﬁning Non-Selective Partial Measurements

To elaborate, let us consider again the example in Fig. 3.4, in which
the measurement of the ﬁrst qubit is discarded. In this case, the post-
measurement state of the subsystem B consisting of the second set of
n−1 qubits is |φ0in−1 with probability |α0|2 and |φ1in−1 with probability
|α1|2. This is a situation characterized by classical randomness, in that
there is epistemic uncertainty on the state of the n − 1 qubits.

As a result, the state of the subsystem B cannot be described
by using the ket state formulation, since the outlined situation is
not equivalent to having the n − 1 qubits in the superposition state
α0|φ0in−1 + α1|φ1in−1. Instead, we can only say that subsystem B is
in the ensemble state

{(|φ0in−1, |α0|2), (|φ1in−1, |α1|2)},

(3.22)

90

Generalizing Quantum Measurements (Part I)

in which subsystem B is in state |φxin−1 with probability |αx|2. To
describe such quantum states, we will need to introduce a new formalism,
that of density matrices. This is the subject of the next section.

Importantly, the random behavior highlighted in the previous para-
graph only occurs when the n − 1 qubits in subsystem B are entangled
with the ﬁrst qubit being measured in a non-selective manner. To see
this, consider the case in which the two subsystem are not entangled,
and hence the state of the system is given by (3.11). In this case, the
ensemble (3.22) reduces to the coherent state |φin−1.

The deﬁnition of non-selective measurements given in this subsection
can be readily generalized to any partial measurement of n0 qubits as
described in Sec. 3.3.4.

3.4.2 Decoherence

A ket state is said to be coherent, while a process producing an
ensemble state such as (3.22) from a coherent state is said to cause
decoherence. Decoherence entails that the produced quantum state
is characterized by classical randomness, so that there is epistemic
uncertainty regarding the ket state describing the system. The discussion
in the previous subsection has revealed that decoherence occurs when a
non-selective measurement is made on a part of an entangled state.

Non-selective measurements, and hence decoherence, may be in-
tentionally added in a quantum circuit as a resource to implement
probabilistic computing. In this type of situations, the randomization
caused by a measurement can be harnessed to carry out probabilistic
computations.

Decoherence also happens naturally in an open quantum system
in which a subsystem – subsystem B in Fig. 3.5 – gets entangled
with its environment – subsystem A. This is a typical situation in
quantum computers, whose qubits inevitably become entangled with
the environment after some (short) period of time. In this setting, the
environment eﬀectively acts as an observer, whose measurements are not
available to the original subsystem B, e.g., to the quantum computer.

3.5. Density Matrices

91

3.5 Density Matrices

In this section, we introduce density matrices as a means to describe
a “noisy” ket state. This corresponds to the situation outlined in the
previous section in which there is classical uncertainty on the ket state
the system is in. As such, density matrices provide a more general
formalism in which to deﬁne the state of a quantum state as compared
to ket vectors.

3.5.1 Describing Ensemble States as Density Matrices

Consider a general situation in which the state of a quantum system of
n qubits is classically uncertain among M possible states {|φmi}M −1
,
m=0
with each state |φmi having probability pm. The states {|φmi}M −1
need
m=0
not be orthogonal. Note that we will henceforth drop the subscript
indicating the number of qubits from ket and bra vectors. This setting
can be described by the ensemble state

{(|φ0i, p0), (|φ1i, p1), ..., (|φM −1i, pM −1)}.

(3.23)

If we have pm = 1 for some m ∈ {0, 1, ..., M − 1}, we say that we have
a pure, or coherent, state; otherwise we have a mixed state.

The probabilities pm, also known as epistemic probabilities, are
conceptually distinct from the squared absolute values of the amplitudes
that give the measurement outputs’ probabilities for pure quantum
states, as they reﬂect a state of classical uncertainty. This state of
uncertainty may reﬂect ignorance about the way in which the state is
prepared, or about the result of a measurement of another subsystem
as in the situation studied in the previous section.

Suppose that we make a measurement of the system described by
the ensemble state (3.23). For generality, we consider a measurement
in some arbitrary orthonormal basis {|vxi}2n−1
x=0 . Partial measurements
can be also similarly studied. How can we describe the probability
distribution of the output of the measurement?

If the state of the system is |φmi, by Born’s rule, the output of the
measurement is x ∈ {0, 1}n with probability |hvx|φmi|2. Since, under
the ensemble (3.23), the state is given by |φmi with probability pm, by

92

Generalizing Quantum Measurements (Part I)

the law of total probability we have

Pr[measurement output equals x] =

=

M −1
X

m=0
M −1
X

pm|hvx|φmi|2

pmhvx|φmihφm|vxi

m=0



= hvx|

M −1
X





m=0

|

pm|φmihφm|

{z
ρ

}

where

ρ =

M −1
X

m=0

pm|φmihφm|









|vxi,

(3.24)

(3.25)

is known as the density matrix associated with the ensemble state
(3.23).

The derivation (3.24) shows that we can describe the probability
distribution of measurement outcomes on a noisy quantum state as
a function of the density matrix ρ. The density matrix ρ in (3.25)
hence fully represents the state of the system (3.23) as it pertains the
description of measurable outputs.

By the deﬁnition in (3.25), the density matrix satisﬁes two condi-

tions:

• it is positive semideﬁnite, i.e., it is Hermitian and it has non-

negative real eigenvalues;

• and it has unitary trace, i.e.,

tr(ρ) = 1.

(3.26)

To validate the second property, we can compute the trace of the density

3.5. Density Matrices

matrix in (3.24) as

tr(ρ) =

2n−1
X

x=0

hx|ρ|xi =

2n−1
X

hx|

x=0



M −1
X





m=0

|

M −1
X

=

pm

2n−1
X

m=0

x=0

hx|φmihφm|xi =

93



pm|φmihφm|

|xi






}

{z
ρ

M −1
X

m=0

pm = 1,

(3.27)

where the ﬁrst equality follows from the deﬁnition of the trace as the
sum of the elements on the diagonal of a square matrix (see also Sec.
3.6.1).

3.5.2 From Density Matrices to Ensemble States

As discussed in the previous subsection, an ensemble state, in which
there is epistemic uncertainty about the ket state the system is in, can
be described by a density matrix. We now verify that any positive
semideﬁnite matrix ρ with unitary trace is a valid density matrix, in
the sense that it describes an ensemble state.

The key observation is that any positive semideﬁnite 2n × 2n matrix

ρ can be written in terms of its eigendecomposition as

ρ =

2n−1
X

x=0

px|uxihux|,

(3.28)

where {|uxi}2n−1
is the orthonormal basis of eigenvectors, and the
x=0
corresponding eigenvalues {px}2n−1
are non-negative. Furthermore, by
x=0
the unitary trace condition (3.26) one can directly check (see also Sec.
3.6.1) that we have

tr(ρ) =

2n−1
X

px = 1.

(3.29)

x=0
Therefore, comparing (3.28) with (3.25), we conclude that the matrix ρ
describes the ensemble state

{(|u0i, p0), (|u1i, p1), ..., (|u2n−1i, p2n−1)}.

(3.30)

94

Generalizing Quantum Measurements (Part I)

This corresponds to a noisy ket state of the type studied in the previous
subsection, in which the system is in pure state |uxi with probability
px. Note that, if the some of the eigenvalues are repeated (i.e., if they
have multiplicity larger than 1), the decomposition (3.28), and hence
the resulting ensemble (3.30), is not unique.

3.5.3 Density Matrix as a General Description of a Quantum State

Density matrices provide a general description of quantum states that
includes as special cases pure, i.e., ket, states, as well as random and
deterministic cbits. Therefore, one can use a density matrix to specify
an arbitrary classical state involving deterministic or random cbits, as
well as a pure or mixed quantum state. In other words, density matrices
account for epistemic uncertainty, as well as for quantum uncertainty
related to the randomness of quantum measurements.

To elaborate on this point, we ﬁrst observe that a quantum coherent
state, described by a ket |ψi, is described by the rank-1 density matrix

ρ = |ψihψ|.

(3.31)

More general mixed quantum states, accounting for ensembles of pure
states, are described by density matrices with rank larger than 1. An
interesting observation is that multiplying the pure state |ψi by a
complex number of the form exp(iθ) for some angle θ does not change
the corresponding density matrix (3.31). This reﬂects the fact that,
by Born’s rule, the global phase of a state |ψi does not aﬀect the
distribution of the output of measurements of state |ψi.

Second, we note that density matrices can also be used to describe
classical random cbits, and hence also deterministic cbits. In fact, a
random cbit taking value 0 with probability p0 and 1 with probability
p1 = 1−p0 can be described by the ensemble {(|0i, p0), (|1i, p1)}. By the
deﬁnition (3.25), this ensemble state is described by the 2 × 2 diagonal
density matrix

ρ = p0|0ih0| + p1|1ih1| =

"

p0
0

#

.

0
p1

(3.32)

This is a valid density matrix since it is positive semideﬁnite and it
satisﬁes the condition tr(ρ) = p0 + p1 = 1.

3.5. Density Matrices

95

More generally, a random n-cbit string with probability vector

p = [p0, ..., p2n−1]T is described by the diagonal density matrix

ρ =

2n−1
X

x=0

px|xihx| =










p0
0
...
0

0

p1
. . .
· · ·

· · ·
. . .
. . .
0










,

0
...
0
p2n−1

(3.33)

which is positive semideﬁnite and satisﬁes the condition tr(ρ) = P2n−1
1.

x=0 px =

3.5.4 Evolution and Measurement of Density States

We have seen in the previous subsection that a density matrix ρ provides
a general description of quantum states. It is, therefore, important to
extend the deﬁnition of unitary, i.e., closed-system, evolutions and of
measurements from pure to density states.

When not measured, density states undergo unitary evolutions for
the same reasons explained in Sec. 1.4.1. Generalizing the unitary
evolution of a coherent state, given a unitary transformation U and an
input density state ρ, the density matrix obtained at the output of the
transformation is given as

ρ0 = U ρU †.

(3.34)

One can directly check that this reduces to the standard unitary evolu-
tion of coherent states by considering rank-1 matrices.

Let us now turn to measurements. Following (3.24), a von Neum-
mann measurement in the orthonormal basis {|vxi}2n−1
for an n-qubit
x=0
density state ρ operates as illustrated in Fig. 3.6 and detailed as follows.

• Born’s rule: The probability of observing x ∈ {0, 1}n is

Pr[measurement output equals x] = hvx|ρ|vxi;

(3.35)

• “Collapse” of the state: If the measured cbits are given by
string x ∈ {0, 1}n, the post-measurement state is given by the
rank-1 density matrix |vxihvx|.

96

Generalizing Quantum Measurements (Part I)

x

ρ

|vxi w.p. hvx| ρ |vxi

Figure 3.6: Measurement in an arbitrary orthonormal basis {|vxi}2n−1
state ρ.

x=0

for a density

The deﬁnition of measurement can be extended to account for the
partial measurement of n0 qubits as deﬁned in Sec. 3.3. We refer the
reader to Sec. 5.2 for further discussion on this point in the context of
projective measurements.

3.5.5 An Application of Ensemble States: Quantum Encryption

As an application of the formalism of density matrices, consider the
problem of quantum encryption. In it, we have an encoder, which
holds some quantum system in state |ψi, an intended decoder, and,
possibly, an eavesdropper. The eavesdropper may intercept the quantum
system while in transit between encoder and decoder. The goal of
quantum encryption is twofold. First, we would like to encode the
quantum state in such a way that the intended decoder can recover it
exactly, assuming that the state is not intercepted by the eavesdropper.
Second, should the eavesdropper get hold of the quantum system, we
would like the eavesdropper to be unable to obtain useful information
about the state |ψi from it.

In a symmetric-key encryption strategy, encoder and decoder share
a key κ ∈ {0, 1, ..., K − 1}, which is randomly selected from the set of
K possible keys. While encoder and decoder know the selected key κ,
the eavesdropper must model the key as being a uniformly distributed
random variable in the set {0, 1, ..., K − 1}.

The encoder applies a unitary transformation Uκ dependent on the
key κ, which is also known to the decoder, to the “plaintext”, i.e., to
the quantum state |ψi to be encrypted. From the point of view of the
decoder, which knows the key, the resulting state is Uκ|ψi. From it, the
decoder can readily recover |ψi by applying the inverse of the unitary
Uκ.

In contrast, as far as the eavesdropper is concerned, the encrypted

3.6. Partial Trace

97

κ=0 Uκ|ψihψ|U †
κ

system is the mixed state K−1 PK−1
, since the key is not
available at the eavesdropper. Encryption can be considered as eﬀective
if, for any two “plaintexts” |ψi and |ψ0i, the two corresponding encrypted
versions K−1 PK−1
are hard
to distinguish, through measurement, by the eavesdropper (see Sec.
5.7.3 for discussion on quantum state detection).

κ=0 Uκ|ψ0ihψ0|U †
κ

κ=0 Uκ|ψihψ|U †
κ

and K−1 PK−1

3.6 Partial Trace

In Sec. 3.4, we have seen that a non-selective partial measurement leaves
the subsystem that is not measured in an ensemble state when the two
subsystems are entangled. The previous section has then shown how an
ensemble state can be described by a density matrix. In this section, we
describe a useful operation – the partial trace – that allows one to relate
the density state resulting from a non-selective partial measurement to
the pre-measurement state.

3.6.1 Trace as a Linear Operator

Let us start by ﬁrst reviewing the trace operation tr(·) by highlighting
its operation as a linear function of the input matrix. Recall that the
trace returns the sum of the elements on the main diagonal of a square,
N × N , matrix. We are interested in values of N that can be written
as N = 2n for some integer n.

To proceed, we need the simple observation that any N × N square

matrix A can be written as

N −1
X

A =

N −1
X

[A](x,y)|xihy|,

x=0

y=0

(3.36)

where [A](x,y) is the (x, y)-th element of the matrix, while {|xi}N −1
and
x=0
{|yi}N −1
are the computational basis vectors. This follows immediately
x=0
by noting that the outer product |xihy| yields an N × N matrix with
all zero entries except for a 1 in the (x, y)-th position. Furthermore, the
same decomposition – with generally diﬀerent coeﬃcients, say [A0](x,y) –

98

Generalizing Quantum Measurements (Part I)

applies with any choice of the orthonormal basis {|vxi}N −1
x=0

, i.e.,

N −1
X

A =

N −1
X

[A0](x,y)|vxihvy|.

x=0

y=0

(3.37)

The trace is a linear operator, and hence, by the decomposition
(3.37) for an arbitrary square matrix, it can be described by its operation
on an arbitrary outer product |vihu| of two N × 1 vectors |vi and |ui.
With this in mind, we can characterize the trace as the linear operator
that acts on outer products of vectors as

tr(|vihu|) = hv|ui.

(3.38)

In words, the trace “converts” an outer product of vectors into the
corresponding inner product.

Using this characterization, it can be veriﬁed that the trace can be

equivalently written as

tr(ρ) =

2n−1
X

hvx|ρ|vxi

(3.39)

x=0
for any orthonormal basis {|vxi}2n−1
x=0 . In fact, the operation in (3.39)
satisﬁes (3.38).

3.6.2 Partial Trace via Non-Selective Partial Measurements

Let us return to the motivating setting of a non-selective partial mea-
surement by focusing on the system of n cbits in a general pure state
as studied in Sec. 3.3.4. We measure the ﬁrst set of n0 qubits in some
basis {|vxin0}2n0
x=0 . As illustrated in Fig. 3.5, we refer to the measured
subsystem of n0 qubits as A and to the rest of the n − n0 qubits as
subsystem B.

−1

Following the discussion in Sec. 3.3, we can always write the joint

state as (cf. (3.8))

|ψiAB =

2n0
−1
X

x=0

αx|vxiA|φxiB,

(3.40)

where {|φxiB}2n0
are states for subsystem B (generally not orthog-
onal). Note that in (3.40), we have used subscripts to indicate the

x=0

−1

3.6. Partial Trace

99

subsystem corresponding to each state. This is a commonly used ap-
proach.

The density matrix for subsystem B upon a non-selective measure-

ment of subsystem A is given as (3.25), i.e.,

ρB =

2n0
−1
X

x=0

|αx|2|φxiBhφx|B.

(3.41)

Note again the use of the subscript in ρB to emphasize the identity of
the subsystem corresponding to the given quantum state. How can we
express the relationship between the density state ρB and the original
density state ρAB = |ψiABhψ|AB of the overall system?

A convenient way to do this is by means of an operation that
generalizes the trace (3.39): the partial trace. The partial trace of the
density ρAB over subsystem A – i.e., over the system being measured
and discarded – is deﬁned as

ρB = trA(ρAB)
2n0
−1
X

=

(hvx|A ⊗ I)ρAB(|vxiA ⊗ I),

(3.42)

x=0

where I is the 2n−n0 × 2n−n0 identity matrix. Note that the subscript
in trA(·) indicates which system is being “traced over”. The equality
between the partial trace output (3.42) and the density matrix (3.41)
can be directly checked by plugging ρAB = |ψiABhψ|AB with (3.40) into
(3.42).

By comparison with (3.39), the trace corresponds to a partial trace
applied to the entire system, which is obtained for n = n0. Importantly,
the partial trace over a subsystem A of n0 qubits returns a density of
size 2n−n0 × 2n−n0 over n − n0 qubits, while the trace produces a scalar
(i.e., a 1 × 1 matrix). As for the trace, the choice of the orthonormal
basis {|vxiA}2n0
is immaterial in the deﬁnition of the partial trace
(3.42). That is, the output of the partial trace operation is the same
irrespective of the choice of the orthonormal basis for subsystem A.

x=0

−1

Interpreting this last result in terms of partial non-selective mea-
surements, we conclude that the state of subsystem B when subsystem

100

Generalizing Quantum Measurements (Part I)

A

B

trash

Figure 3.7: Since the density state of subsystem B in the situation depicted in
Fig. 3.7 does not depend on the speciﬁc measurement made on subsystem A, one
can illustrate the setting from the perspective of subsystem B as in this ﬁgure by
removing the speciﬁcation of a measurement on subsystem A.

A is measured in a non-selective fashion does not depend on the speciﬁc
basis in which subsystem A is measured. Therefore, from the perspective
of subsystem B, the situation in Fig. 3.5 can be also illustrated as in
Fig. 3.7 by removing the speciﬁcation of a measurement on subsystem
A. The fact that any unterminated wire in a quantum circuit can be
terminated with a measurement is known as the principle of implicit
measurement.

Some further discussion on the implications of entanglement on the

output of non-selective measurements can be found in Appendix B.

3.6.3 Partial Trace as a Linear Operator

Like the trace, the partial trace operation (3.42) is also linear. We will
now generalize the deﬁnition of the trace given in (3.38), which relies
on the linearity of the trace, to the partial trace.

From (3.37), it follows that any matrix square 2n × 2n matrix can

be expressed as a linear combination of matrices for the form

|v, uiABhv0, u0|AB = |viAhv0|A ⊗ |uiBhu0|B,

(3.43)

where |viA and |v0iA states for subsystem A, and |uiB and |u0iB are
states for subsystem B. The partial trace can be hence equivalently
described, generalizing the trace deﬁnition (3.38), as the linear operator
satisfying the equalities

trA(|v, uiABhv0, u0|AB) = trA(|viAhv0|A ⊗ |uiBhu0|B)

= tr(|viAhv0|A) · |uiBhu0|B
= hv|A|v0iA · |uiBhu0|B.

(3.44)

3.7. Conclusions

101

In words, the partial trace “converts” outer products into inner products
only for the system that is being traced over, namely subsystem A.

The equivalent deﬁnitions (3.42) and (3.44) can be directly gener-
alized to the partial measurement of any subset of qubits in a system.
Accordingly, one can straightforwardly extend the partial trace operation
to trace over any subset of qubits.

3.6.4 Partial Trace and Classical Marginalization

The partial trace can be interpreted as a form of “quantum marginal-
ization”. To explain, consider a set of n = 2 random cbits with general
probability vector p = [p00, p01, p10, p11]T . This state can be described
by the density matrix

ρAB =








p00
0
0
0

0
p01
0
0

0
0
p10
0








0
0
0
p11

= p00|00ih00| + p01|01ih01| + p10|10ih10| + p11|11ih11|.

(3.45)

By (3.44), the partial trace over subsystem A, i.e., over the ﬁrst qubit
(encoding the ﬁrst cbit), returns

ρB = trA(ρAB) = p00|0ih0| + p10|0ih0| + p01|1ih1| + p11|1ih1|
#

"

.

(3.46)

=

p00 + p10
0

0
p01 + p11

This is the density matrix to a random cbit with distribution equal to
the marginal distribution of the second cbit. So, as anticipated, the
partial trace generalizes the operation of classical marginalization.

3.7 Conclusions

In this chapter, we have generalized the quantum measurements in
two important directions. First, we have deﬁned measurements in any
orthonormal basis, which encompass joint measurements across multiple
qubits. We have seen that such measurements can be implemented via
standard measurements (in the computational basis) via suitable pre-

102

Generalizing Quantum Measurements (Part I)

and post-measurement unitary operations. Then, we have discussed
situations in which only a subset of qubits is measured, and the output
of the measurement is either retained or discarded. In the latter case,
we have concluded that, if there is entanglement between the qubits
being measured and the rest of the system, the state of the subsystem
that is not subject to measurement must be described by a density
matrix. The density matrix of the remaining subsystem can be related
to the original density matrix via the partial trace operation.

3.8 Recommended Resources

For a basic introduction to partial measurements, the reader is referred to
[1]. Non-selective measurements and quantum noise are clearly presented
in [3], [7], [8]. For discussions on the implementations of measurements
using quantum circuits, a useful reference is [9].

3.9 Problems

1. For a two-qubit system show that measuring qubits sequentially in
the computational basis gives the same distribution of the outputs
as a joint measurement in the computational basis. Generalize to
any number of qubits.

2. Describe mixed states as vectors within the Bloch sphere (see

recommended resources).

3. Describe the von Neumann entropy and show that for entangled
states the entropy of a whole can be smaller than the entropy of
individual subsystems (see Appendix A).

4. Contrast the coherent superpositon

X

x

αx|ψxi

with the non-coherent superposition

X

x

px|ψxihψx|

(3.47)

(3.48)

3.9. Problems

103

by demonstrating quantum circuits in which these two states as
inputs yield diﬀerent measurement probabilities. Argue that for
the former state the relative phases between the component states
|ψxi matter, while this is not the case for the latter.

5. For the circuit below, describe the state of the ﬁrst three qubits
when a measurement on the last qubit is discarded. Note that the
last qubit is initialized in the ground state |0i. Consider ﬁrst the
eight vectors in the computational basis for the ﬁrst three qubits,
and then describe what happens to an arbitrary superposition
state for the ﬁrst three qubits. Relate your conclusions to the
concept of parity (see also Chapter 5).

|0i

X

X

X

trash

Appendix A: Quantifying Bipartite Entanglement

In this appendix, we focus on bipartite pure states |ψiAB of n qubits
that are partitioned into a subsystem A encompassing nA qubits and a
subsystem B including nB = n − nA qubits (see Sec. 3.6.2). We describe
two ways of quantifying entanglement of the two systems, namely the
Schmidt rank and the entropy of entanglement.

Schmidt Decomposition and Schmidt Rank

Any pure state |ψiAB can be expressed as the amplitude vector

|ψiAB =

2nA −1
X

2nB −1
X

x=0

y=0

αx,y|xiA ⊗ |yiB

= h

α0,0

· · · α0,2nB −1

· · · α2nA −1,0

· · · α2nA −1,2nB −1

iT

,
(3.49)

104

Generalizing Quantum Measurements (Part I)

where {|xiA}2nA −1
subsystems A and B. Equivalently, we can write the state as

and {|yiB}2nB −1

are the computational bases for

x=0

x=0

|ψiAB = vec(ΩAB)

(3.50)

in terms of the 2nB × 2nA amplitude matrix









ΩAB =

α0,0
α0,1
...

α1,0
α1,1
...

α0,2nB −1 α1,2nB −1

α2nA −1,0
α2nA −1,1
...

· · ·
· · ·
...
· · · α2nA −1,2nB −1









,

(3.51)

where the operator vec(·) stacks the columns of the argument matrix.
The amplitude matrix (3.51) provides an equivalent characterization of
the state |ψiAB that highlights the assumed partition into the subsys-
tems A and B.

Consider now the singular value decomposition (SVD) of the ampli-

tude matrix

ΩAB =

r−1
X

d=0

λd|udiBhvd|A,

(3.52)

where the sets {|vdiA}r−1
and {|udiB}r−1
comprise the right and left
d=0
d=0
singular vectors, respectively, associated with the r positive singular val-
ues {λd}r−1
are orthonormal,
d=0
and so are the 2nB × 1 vectors {|udiB}r−1
d=0. Furthermore, the number of
positive singular values r satisﬁes the inequality

. Recall that the 2nA ×1 vectors {|vdiA}r−1
d=0

r ≤ min(2nA, 2nB ).

(3.53)

Using the SVD (3.52), we then have

|ψiAB = vec(ΩAB) =

r−1
X

d=0

λd|vdi∗

A ⊗ |udiB,

(3.54)

represents the complex conjugate of vector |vdiA. Note that
where |vdi∗
A
are still orthonormal. The expression (3.54) is
the vectors {|vdi∗
known as the Schmidt decomposition of state |ψiAB as it pertains its
partition into systems A and B, and the Schmidt rank is the number r
of positive singular values.

A}r−1
d=0

3.9. Problems

105

Restating this result, given a state |ψiAB of a system partitioned
into subsystems A and B of nA and nB qubits, respectively, there exist
an orthonormal set of r vectors {|adiA}r−1
of dimension 2nA × 1 and
d=0
an orthonormal set of r vectors {|bdiB}r−1
of dimension 2nB × 1, such
d=0
that the Schmidt decomposition

|ψiAB =

r−1
X

d=0

λd|adiA ⊗ |bdiB

(3.55)

and |bdiB = |udiB in the
holds. Note that we have |adiA = |vdi∗
A
derivation above. Accordingly, any pure state |ψiAB can be expressed
as a linear combination of r ≤ min(2nA, 2nB ) separable states {|adiA ⊗
|bdiB}r−1
satisfying the normalization
d=0
condition

with positive amplitudes {λd}r−1
d=0

r−1
X

d=0

λ2
d

= 1.

(3.56)

An interesting aspect of the Schmidt decomposition is that, if one
of the two systems comprises a small number of qubits, the Schmidt
rank r is accordingly small due to the inequality (3.53). Another useful
property of the Schmidt decomposition has to do with the quantiﬁcation
of entanglement between subsystems A and B. This is the main subject
of this appendix.

The key result in this regard is that the two subsystems A and B
are entangled if and only if the Schmidt rank r of state |ψiAB is larger
than 1. Conversely, if and only if r = 1, by (3.55), the state of the
two subsystems is separable (and is given by |ψiAB = |a0iA ⊗ |b0iB).
Therefore, the Schmidt rank r can be used to assess the degree of
entanglement between the two systems.

The signiﬁcance of the Schmidt rank as a measure of entanglement
can be also understood by studying the setting shown in Sec. 3.6.2 in
which one of the two subsystems is discarded. From (3.55), if we make
a measurement of subsystem A in a non-selective way, we obtain the
density matrix

ρB = trA(|ψiABhψ|AB) =

r−1
X

d=0

λ2
d|bdiBhbd|B,

(3.57)

106

Generalizing Quantum Measurements (Part I)

while measuring subsystem B in a non-selective way yields

ρA = trB(|ψiABhψ|AB) =

r−1
X

d=0

λ2
d|adiAhad|A.

(3.58)

Therefore, the Schmidt rank corresponds to the rank of the density
matrix of one subsystems when the other is discarded. Accordingly, if
the two systems are not entangled, the density matrices describe pure
states, i.e., they have rank r = 1; while entanglement is manifested in
both subsystems having mixed states with rank r > 1.

Entropy of Entanglement

As we have seen in the previous subsection, entanglement between two
subsystems causes non-selective measurements of one subsystem to yield
a (non-trivial) mixed, and hence noisy, state for the other subsystem.
Taking this perspective further, entanglement can be more precisely
quantiﬁed by the degree of classical randomness of the reduced states
(3.57) and (3.58). Accordingly, the more random the reduced states ρA
and ρB are, the more entangled the original pure state |ψiAB can be
said to be.

To quantify the classical randomness associated with a density
state, a standard measure is the von Neumann entropy. Given a
density state ρ with eigendecomposition ρ = Pr−1
x=0 px|uxihux|, the von
Neumann entropy is the classical, Shannon, entropy of the probability
vector [p0, p1, ..., pr−1], i.e.,

H(ρ) = −

r−1
X

px log

2

(px),

(3.59)

x=0
which is measured in bits. For a system of n qubits, the von Neumann
entropy satisﬁes the inequalities

0 ≤ H(ρ) ≤ n.

(3.60)

The lower bound is attained if and only if the state ρ is pure (i.e., with
rank 1); while the upper bound is achieved if and only if the density
state is maximally mixed, i.e., if it corresponds to uniformly distributed
random cbits with density matrix ρ = 2−nI.

3.9. Problems

107

Returning to the density states (3.57) and (3.58), their von Neumann

entropy is equal to

H(ρA) = H(ρB) = −

r−1
X

x=0

λ2
x

log

(λ2
x

).

2

(3.61)

By the discussion in the previous subsection, the von Neumann entropy
of the reduced states is equal to zero if and only if the state |ψiAB is
separable. Furthermore, it is positive if and only if the state |ψiAB is
entangled, and thus the Schmidt rank is larger than 1. Finally, by (3.60),
the maximum value of the von Neumann entropy for the reduced states
is min(nA, nB), which corresponds to a maximally entangled state.
In light of the properties described in the last paragraph, given a
pure bipartite state |ψiAB, the von Neumann entropy of the reduced
states, i.e.,

H(trA(|ψiABhψ|AB)) = H(trB(|ψiABhψ|AB))

(3.62)

is known as the entropy of entanglement of the state |ψiAB. The
entropy of entanglement is zero if and only if the two subsystems A and
B are not entangled, and it reaches the maximum value of min(nA, nB)
when the two subsystems are maximally entangled. For example, any
Bell state can be checked to have the maximum entropy of entanglement
of min(nA, nB) = 1 bit. Therefore, Bell pairs are maximally entangled.
As a ﬁnal note, we observe that, when the two subsystems are
entangled, the von Neumann entropy (3.61) of the individual subsys-
tems is larger than the von Neumann entropy of the overall system
H(|ψiABhψ|AB) = 0 – a phenomenon that has no classical counterpart.
(It would be as if the individual pages of a book contained random gib-
berish, and all the information enclosed in book could only be revealed
by looking at all pages at once.)

Appendix B: On Multipartite Entanglement

In this appendix, we brieﬂy discuss entanglement involving more than
two subsystems. We speciﬁcally elaborate on the case of n = 3 qubits,
each corresponding to a distinct subsystem. As we have seen in Appendix
A, with two subsystems, entanglement can be readily quantiﬁed by the

108

Generalizing Quantum Measurements (Part I)

Schmidt rank or by the entropy of entanglement. As we will discuss
here, multipartite entanglement exhibits a more complex behavior that
is not as easily quantiﬁed. Multipartite entanglement is central to many
quantum computing and communication primitives, such as on-demand
Bell state generation between pairs of nodes.

For n = 3, there are two main types of entanglement, which are

exempliﬁed by the Greenberger–Horne–Zeilinger (GHZ) state

|GHZi =

1
√
2

(|000i + |111i)

(3.63)

and by the W state (named after Wolfgang Dür)

|Wi =

1
√
3

(|001i + |010i + |100i).

(3.64)

√

Note that the GHZ is a natural generalization of the Bell state |Φ+i =
2(|00i + |11i) from n = 2 to n = 3 qubits; while the W state is a
1/
natural generalization of the Bell state |Ψ+i = 1/
2(|01i + |10i) from
n = 2 to n = 3 qubits.

√

The three qubits are entangled under both GHZ and W states, since
the respective state vectors cannot be written as the Kronecker product
of individual qubit states. More precisely, they are fully entangled in
the sense that they are not even biseparable. A biseparable state can
be partitioned into two subsystems such that the Kronecker product of
the individual subsystems’ states gives the overall state of the system.
To elaborate on the diﬀerent behaviors exhibited by systems in the
GHZ and W states, let us consider what happens if we observe one of
the three qubits, say the ﬁrst, and we are interested in the resulting
state of the other two qubits. We speciﬁcally focus on non-selective
measurements as described in Sec. 3.6.2 and also considered in Appendix
A. By the generalized Born rule (3.18)-(3.19), for the GHZ state, a
non-selective measurement of the ﬁrst qubit yields the ensemble state

{(|00i, 1/2), (|11i, 1/2)}

(3.65)

for the last two qubits. This ensemble is described by the density matrix

ρ =

1
2 |00ih00| +

1
2 |11ih11| =

1
2 I.

(3.66)

3.9. Problems

109

We conclude that the two remaining qubits are no longer entangled.
Rather, they behave like classical correlated cbits: With probability 1/2
they take state |00i, and with probability 1/2 their state is |11i. So, in
a manner similar to the Bell states for n = 2 qubits, the measurement
of a single qubit destroys entanglement for the GHZ state.

Let us now consider the W state. In order to apply the generalized

Born rule, we rewrite (3.64) equivalently as

|Wi =

r 2

3 |0i|Ψ+i +

1
√
3

|1i|00i,

(3.67)

√

where |Ψ+i = 1/
2(|01i + |10i).Therefore, following the same steps
used above for the GHZ state, upon measuring the ﬁrst qubit in a
non-selective way, the last two qubits are in the mixed state

ρ =

2
3 |Ψ+ihΨ+| +

1
3 |00ih00|.

(3.68)

It follows that the two qubits are still partially entangled, albeit not
maximally so. In fact, with probability 2/3 they are in the (maximally
entangled) Bell state |Ψ+i, while with probability 1/3 they are in the
separable state |00i.

Overall, the discussion in this appendix suggests that GHZ states
exhibit a larger degree of entanglement, which is, however, completely
lost upon the measurement of any of the three qubits. In contrast, the
“connectivity” among the three qubits under the W state is less strong,
as the measurement of one qubit preserves some degree of entanglement
between the other two qubits. That said, the two types of entanglement
are distinct in the sense that it is not possible to transform either state
into the other via local operations (see also Problem 1 in Chapter 2 for
the case n = 2).

Appendix C: More on Density Matrices and on the Partial Trace

This appendix reports some useful additional facts about density matri-
ces and partial trace.

As we have seen in Sec. 1.4.4, the notation f (ρ) describes the matrix

f (ρ) =

2n−1
X

x=0

f (px)|uxihux|,

(3.69)

110

Generalizing Quantum Measurements (Part I)

where we have used the eigendecomposition (3.28). and this deﬁnition
extends more generally to all normal operators. Using this deﬁnition, a
pure state can be readily seen to satisfy the equality

tr(ρ2) = 1,

while, more generally, we have the inequalities

1/2n ≤ tr(ρ2) ≤ 1.

(3.70)

(3.71)

The quantity tr(ρ2), known as purity, decreases with the “mixedness”
of the state.

Following Sec. 1.4.6, for a single qubit, the density matrix can also

be represented using the Pauli operators as

ρ =

1
2

(I + rxX + ryY + rzZ),

(3.72)

where the coeﬃcients are computed as rx = tr(ρX), ry = tr(ρY ), and
rz = tr(ρZ). Furthermore, the so-called Bloch vector r = [rx, ry, rz]T
can be shown to satisfy the inequality ||r|| ≤ 1 and the two eigenvalues
can be computed as 1/2(1 ± ||r||2).

If we write the joint density matrix of a system of two qubits (n = 2)

in the block form

ρAB =

#

"

P Q
R S

(3.73)

where the size of P is 2 × 2 and the size of S is 2 × 2, respectively, then
we have

and

trA(ρAB) = P + S

trB(ρAB) =

" tr(P )
tr(R)

#

.

tr(Q)
tr(S)

(3.74)

(3.75)

4

Quantum Computing

4.1 Introduction

This chapter provides a brief introduction to the approach tradition-
ally adopted for the design of quantum algorithms based on quantum
circuits. To this end, we ﬁrst review the gate-based model of quantum
computation speciﬁed by a quantum circuit. Then, we describe basic
building blocks of traditional quantum algorithms aimed at computing
binary functions and at implementing a form of quantum memory. This
background material will provide us with the necessary tools to study
Deutsch’s algorithm, the ﬁrst demonstration of the beneﬁts of quan-
tum computation. Finally, we discuss the no cloning theorem, which
imposes fundamental limitations on quantum computing (as well as
quantum communications). Along the way, we will present several key
concepts such as quantum parallelism, basis-copying circuits, and phase
kick-back.

4.2 Gate-Based Model of Quantum Computation

As described in Sec. 2.4, a quantum algorithm is speciﬁed by a quantum
circuit. A quantum circuit, in turn, consists of a sequence of quantum

111

112

Quantum Computing

gates (unitaries) and measurements that are applied in place to a register
of qubits. In a quantum circuit, we have a wire for each qubit, and
double lines represent a wire that carries cbits.

In the example of Fig. 4.1, we have a sequence of quantum gates
Um with m ∈ {1, ..., 7}, acting on one or two qubits. The cbit at the
output of the measurement on the third qubits controls the gate U8
applied to the second qubit. For instance, the gate U8 may be the
identity I if the controlling cbit is equal to 0 and an X gate if the cbit is
equal to 1. It is recalled that measurements are irreversible operations,
and hence the outlined operation is diﬀerent from a controlled gate as
deﬁned in Sec. 2.6.4, which is reversible. That said, it can be proved
that all measurements can be always moved to the end of the circuit by
replacing measurement-controlled gates with controlled gates – this is
the so-called principle of deferred measurement. We will see a use
of measurement-controlled unitaries in the next chapter in the context
of quantum error correction (see Sec. 5.5). Finally, the output of the
computation is given by the result of the measurement of the ﬁrst two
qubits, as further discussed next.

The output of a quantum algorithm can be deﬁned in one of two

ways.

• Probabilistic quantum computing: The quantum algorithm
returns a measurement output obtained from a single run of
the quantum circuit. Due to shot noise, i.e., to the inherent
stochasticity of quantum measurements, the output is generally a
random cbit string. Therefore, this approach implements a form
of probabilistic computing.

• Deterministic quantum computing: The quantum algorithm
returns the average of several measurement outputs that are
obtained from multiple runs of the quantum circuit. This type
of output is typically formulated in terms of expected values of
observables, which will be introduced in the next chapter (see Sec.
5.3).

4.3. Computing Binary Functions and Quantum RAM

113

U1

U2

U3

U5

U6

U7

U4

U8

Figure 4.1: An illustration of the gate-based model of quantum computing.

4.3 Computing Binary Functions and Quantum RAM

Having introduced the general model of gate-based quantum comput-
ing, in this section we describe a useful building blocks for quantum
algorithms: the controlled shift operator. We show how this gate can
be used to evaluate binary functions and to implement a quantum
random-access memory (RAM).

4.3.1 Shift Operators

Given a binary string a = a0, ..., am−1 ∈ {0, 1}m, the shift operator
X ⊗a is a separable quantum gate that applies either the identity gate
I or the Pauli X gate to each k-th qubit, with k ∈ {0, 1, ..., m − 1}.
Speciﬁcally, the Pauli X gate is applied to qubit k if the corresponding
cbit ak equals ak = 1, and no operation is applied to qubit k if ak = 0.
Mathematically, as illustrated in Fig. 4.2, the shift operator X ⊗a with
shift cbit string a can be expressed as the Kronecker product

X ⊗a = X a0 ⊗ X a1 ⊗ · · · ⊗ X am−1.

(4.1)

Note that the shift operator X ⊗a is a Pauli string as deﬁned in Sec.
2.6.1.

As an example, with m = 2 qubits and the shift bit string a = 01,

the shift operator is given as

X ⊗01 = I ⊗ X.

(4.2)

Therefore, the operator X ⊗01 applies a Pauli X gate to the second qubit
only.

114

Quantum Computing

X a0

X a1

...

X am−1

Figure 4.2: The shift operator X ⊗a on m qubits, deﬁned in (4.1) or equivalently in
(4.4), is a Pauli string that applies single-qubit Pauli X gates or the identity I in a
manner controlled by the cbit string a = a0, ..., am−1 ∈ {0, 1}m as in (4.1).

The name “shift” operator arises from the change-of-basis form of
the unitary (4.1). To describe this interpretation, for two binary strings
a = a0, ..., am−1 ∈ {0, 1}m and b = b0, ..., bm−1 ∈ {0, 1}m, we write as
a ⊕ b the m-cbit string obtained as the bit-wise XOR of the two cbit
strings, i.e.,

a ⊕ b = a0 ⊕ b0, ..., am−1 ⊕ bm−1.
Following the characterization of unitary matrices in Sec. 2.6.2, we can
then express the shift operator (4.1) as

(4.3)

X ⊗a =

2m−1
X

y=0

|y ⊕ aihy|.

(4.4)

Accordingly, the shift operator maps each vector |yi in the computational
basis to the “shifted” version |y ⊕ ai. This can be readily veriﬁed by
applying (4.1) to a vector |yi in the computational basis, which yields

X ⊗a|yi = |y ⊕ ai.

(4.5)

As an example, the shift operator (4.2) can be expressed in the

change-of-basis form

X ⊗01 = |01ih00| + |00ih01| + |11ih10| + |10ih11|.

(4.6)

4.3.2 Controlled Shift Operators

Consider now a partition of the set of qubits into two subsystems,
with n qubits in the ﬁrst subsystem and m in the second subsystem.

4.3. Computing Binary Functions and Quantum RAM

115

n

m

|xi

|yi

n

|xi

X ⊗f (x)

m

|y ⊕ f (x)i

Figure 4.3: The controlled shift operator CX ⊗f is a controlled qubit gate in which
the ﬁrst m qubits control the shift operator X ⊗f (x) applied to last n qubits.

In this subsection, we will introduce the controlled shift operator, in
which the ﬁrst set of qubits determines, in a sense to be speciﬁed below,
the shift to be applied to the second set of qubits. We will see in the
following subsections that this operator allows the computation of binary
functions on a quantum computer, as well as the implementation of a
form of quantum memory.

To start, let us study the eﬀect of applying the shift operator X ⊗a to
the second subsystem of m qubits within the larger system encompassing
also the ﬁrst n qubits. This operation amounts to the application of the
unitary I ⊗ X ⊗a, with the identity matrix I being of size 2n × 2n, i.e.,
to the transformation

(I ⊗ X ⊗a)|x, yi = |x, y ⊕ ai,

(4.7)

where {|xi}2n−1
are the computational bases for the
x=0
Hilbert spaces of the two subsystems. In a manner similar to (4.1) and
(4.4), we can write the unitary matrix (4.7) as

and {|yi}2m−1
y=0

I ⊗ X ⊗a =

2n−1
X

2m−1
X

x=0

y=0

|x, y ⊕ aihx, y|,

(4.8)

where I is the 2n × 2n identity matrix.
Consider now a binary function

f (x) = f0(x), ..., fm−1(x) ∈ {0, 1}m

(4.9)

taking as input the n-cbit string x ∈ {0, 1}n and producing as output
the m-cbit string f (x). Given a binary function f (·), the controlled
shift operator is the unitary transformation

CX ⊗f =

2n−1
X

x=0

|xihx| ⊗ (X f0(x) ⊗ · · · ⊗ X fm−1(x)).

(4.10)

116

Quantum Computing

In a manner that directly extends the discussion about two-qubit con-
trolled gates in Sec. 2.6.4, if the ﬁrst subset of qubits is in some state
|xi, the eﬀect of the unitary CX ⊗f is to apply the shift operator X ⊗f (x)
to the second set of qubits. More generally, the unitary operates on 2n
separate computational branches, applying the shift operator X ⊗f (x) on
the computational branch in which the ﬁrst subset of n qubits assumes
state |xi. Note that, unlike the simpler controlled qubit gates studied
in Sec. 2.6.4, here a diﬀerent non-trivial transformation may be applied
on all computational branches.

The unitary CX ⊗f generally depends on all the values of the function
f (·). Furthermore, it recovers the (two-qubit) CNOT gate by setting
m = n = 1 and f (x) = x for x ∈ {0, 1}. As such, unlike the shift
operator X ⊗a, which is separable across the qubits, the controlled shift
applies jointly to all qubits, and can create entanglement (see Sec. 2.7).

Let us now demonstrate an implementation of the controlled shift
operator. For m = n = 2 and given the identity function f (x) = x,
the circuit implementing the unitary CX ⊗f is illustrated in Fig. 4.5.
This implementation follows directly from the characterization in (4.10).
In fact, as shown in the ﬁgure, when applied to vectors |x, yi in the
computational basis, the two CNOT gates compute the XOR between
the states of the ﬁrst qubit and of the third and between the second
and fourth qubits’ states, producing the desired output |x, y ⊕ xi.

4.3.3 Computing a Binary Function

In this subsection, we show how to use the controlled shift operator
CX ⊗f to evaluate the binary function f (·). As anticipated in Sec.
2.6.6, quantum circuits can be used to implement reversible binary
functions when the inputs are restricted to computational-basis vectors.
Accordingly, we will show in this subsection that the controlled shift
operator CX ⊗f implements function f (·) in a reversible manner on the
computational basis.

To this end, we ﬁrst observe, in a manner similar to (4.7), that the
unitary CX ⊗f maps any vector |x, yi in the computational basis to vec-
tor |x, y ⊕ f (x)i, where {|xi}2n−1
are the computational
x=0

and {|yi}2m−1
y=0

4.3. Computing Binary Functions and Quantum RAM

117

n

m

|xi

|yi

CX ⊗f

n

|xi

|xi

m

|y ⊕ f (x)i

|0i

n

m

CX ⊗f

n

|xi

m

|f (x)i

Figure 4.4: (left) Illustration of the operation of the controlled shift operator CX ⊗f
on an arbitrary vector |x, yi in the computational basis; (right) Illustration of the use
of the controlled shift operator to compute function f (x) for some input x ∈ {0, 1}n,
with the input x being encoded in the state of the ﬁrst subsystem of n qubits and
the output f (x) ∈ {0, 1}m being encoded in the state of the second subsystem of m
qubits.

bases for the Hilbert spaces of the two subsystems, that is, we have

CX ⊗f |x, yi = |x, y ⊕ f (x)i.

(4.11)

Accordingly, the controlled shift operator can be expressed in the change-
of-basis form

CX ⊗f =

2n−1
X

2m−1
X

x=0

y=0

|x, y ⊕ f (x)ihx, y|,

(4.12)

as illustrated in Fig. 4.4-(left). Importantly, the mapping (x, y) 7→
(x, y ⊕ f (x)) implemented by the circuit is reversible for any binary
function f (·).

Based on this observation, the controlled shift operator can be used
to compute function f (x) using the approach depicted in Fig. 4.4-(right).
In it, one sets the ﬁrst set of n qubits to state |xi for the given bit
string x of interest. This can be done starting from the ground state
|0i by applying an X gate to all qubits corresponding to values 1 in
the cbit string x. The second set of m qubits is initialized in state |0i.
From (4.11), the output of the controlled shift operator is given by a
separable state in which the ﬁrst set of qubits is in state |xi, while the
second set of qubits is in state |f (x)i. One can then measure the output
qubits, i.e., the second set of qubits, in order to determine the m-cbit
string f (x) with probability 1.

118

Quantum Computing

|xi

|yi

|xi

|y ⊕ xi

X

X

Figure 4.5: An implementation of the controlled shift operator CX ⊗f with m =
n = 2 and f (x) = x.

4.3.4 Quantum Random Access Memory (QRAM)

As another important application of controlled shift operators, in this
subsection we discuss the implementation of a quantum random
access memory (QRAM). To start, we view x ∈ {0, 1, ..., 2n−1} as an
index pointing to an entry f (x) in a data base {f (0), f (1), ...., f (2n −1)}
of m-cbit strings. A classical RAM would return the entry f (x) when
queried at index value x. In contrast, as we will show next, querying
a QRAM with an input in superposition retrieves a superposition of
multiple, possibly all, entries in the data base.

A QRAM is deﬁned by a controlled shift gate CX ⊗f operating
on n + m qubits, with the ﬁrst set of n qubits encoding the query
and the second set of m qubits encoding the output of the QRAM.
Assume that the input state for the ﬁrst n qubits is the superposition
P2n−1
x=0 αx|xi, while the second subset of qubits are in the ground state
|0i. By (4.11), as illustrated in Fig. 4.6, the output state is then given
by the superposition

2n−1
X

x=0

αx |x, f (x)i .

(4.13)

After the application of the QRAM gate, the qubits are in the entangled
state (4.13) that encodes all input and output values corresponding to
non-zero amplitudes αx. As a result, a single query to a QRAM can
potentially encode information about all entries in the data base.

Crucially, while the output state (4.13) depends on all the entries
of the data base, measuring the output qubits would “collapse” the
state to one of the states |x, f (x)i with probability |αx|2. Therefore, a

4.4. Deutsch’s Problem and Quantum Parallelism

119

P2n−1

x=0 αx|xi

|0i

n

m

CX ⊗f

n

m

P2n−1

x=0 αx |x, f (x)i

Figure 4.6: Querying a QRAM CX ⊗f with an input in superposition produces an
entangled state encoding the superposition of all entries in the data base.

measurement would produce the same result as a classical RAM fed
with a random query x with probability |αx|2. We will discuss in the
next section a (more useful!) application of the outlined parallelism of
QRAMs.

4.4 Deutsch’s Problem and Quantum Parallelism

The design of quantum algorithms revolves around the deﬁnition of
mechanisms that leverage the unique quantum properties of superpo-
sition and entanglement. Deutsch’s algorithm, the ﬁrst demonstration
of the possibility of a quantum speed-up, takes advantage of the
property of a QRAM illustrated in Fig. 4.6. This property is an example
of quantum parallelism: With a single application of the controlled
shift operator CX ⊗f , one can compute the superposition state (4.13),
which can encode all the input-output values of function f (·).
To focus on Deutsch’s problem, consider a binary function

f (x) ∈ {0, 1} with x ∈ {0, 1}

(4.14)

taking one bit as input and producing one bit as the output, i.e., having
n = 1 and m = 1. There are only four such binary functions f (·), which
are listed in Table 4.1. Suppose that we only wanted to know whether
f (·) is constant – i.e., if it is one of the functions (f0, f3) – or not – i.e.,
if it is one of the functions (f1, f2). In a classical system, we would need
to query the value of function f (·) at both values of x ∈ {0, 1} to ﬁnd
out. By Deutsch’s algorithm, quantum computing requires only one
application of the function-computing operator Uf , demonstrating a
quantum speed-up. How can this be accomplished?

As discussed in the previous section, with a single use of the con-
trolled shift operator CX f , we can compute the superposition of both

120

Quantum Computing

x = 0

x = 1

f0

f1

f2

f3

0

0

1

1

0

1

0

1

Table 4.1: The four possible binary functions with a single cbit as the input and a
single cbit as the output (m = n = 1). The table lists the outputs as a function of
the input (column value).

input-output values of function f (·). Note that we have dropped the
Kronecker product from the notation CX ⊗f to indicate that we have a
single controlled qubit in this example. Speciﬁcally, this can be done
using the circuit in Fig. 4.7, which specializes the QRAM circuit in Fig.
4.6 for m = 1 and n = 1. Note that the use of the Hadamard gate on the
ﬁrst qubit produces of the equal superposition |+i = 1/
2(|0i + |1i),
corresponding to the case αx = 1/
2 for x = 0, 1 in Fig. 4.6. By the
general result summarized in Fig. 4.6, after the CX f gate in Fig. 4.7,
we have the entangled state

√

√

|ψi = CX f |+, 0i =

1
√
2

1
X

x=0

|x, f (x)i.

(4.15)

While this state encodes all input-output values of the function f (x),
it is not clear how to extract useful information from it. In fact, if we
measure the ﬁrst qubit in the computational basis, by the generalized
Born rule (see Sec. 3.3), we end up with the post-measurement state
|x, f (x)i, where x = 0 or x = 1 with equal probability 1/2. This amounts
to observing the value f (x) of the function at a single, randomly selected,
input x ∈ {0, 1}.

Therefore, we cannot learn anything more than a single value of
function f (x) from a single measurement of the superposition state |ψi.
The hope is that, based on a single, properly designed, measurement of
the superposition state |ψi, we can instead learn something about the
relation among values of f (x) across diﬀerent values of x. Deutsch’s algo-

4.4. Deutsch’s Problem and Quantum Parallelism

121

|0i

|0i

H

CX f

Figure 4.7: An application of the QRAM circuit in Fig. 4.6 for the special case
m = 1 and n = 1. The Hadamard gate puts the ﬁrst qubit in the superposition state
|+i.

|1i

|1i

H

H

CX f

x

H

Figure 4.8: Deutsch’s algorithm.

rithm shows that indeed a single measurement is suﬃcient to determine
whether function f (·) is constant or not.

Deutsch’s algorithm is described by the quantum circuit shown in
Fig. 4.8. In it, we can recognize two elements that we have encountered
before. First, the top Hadamard gate has the same role explained in
the context of Fig. 4.6 of probing the function f (·) via a superposition
(here given by H|1i = |−i = 1/
2(|0i − |1i)). Second, the cascade of
Hadamard gate and measurement applied to the top qubit after the
controlled shift operator implements a measurement in the diagonal
basis {|+i, |−i} (see Sec. 3.2.3).

√

We will demonstrate in Sec. 4.6 that, if f (·) is constant, i.e., if it is
function f0 or f3 in Table 4.1, measuring the ﬁrst qubit as in Fig. 4.8
gives x = 1 with probability 1; while, if f (·) is not constant, i.e., if it
is function f1 or f2, the measurement returns x = 0 with probability
1. Therefore, a single measurement is suﬃcient to settle the question
of whether function f (·) is constant or not. To prove this result, which
demonstrates a quantum speed-up for the problem at hand, we will
introduce the key idea of phase kick-back, and return to Deutsch’s
algorithm in Sec. 4.6.

122

Quantum Computing

4.5 Phase Kick-Back

In this section, we describe the key idea that underlies the design of
Deutsch’s algorithm: phase kick-back. The same principle underpins
also other important quantum algorithms, such as phase estimation.
As we will see in the next section, phase kick-back implies that the
controlled shift operator in Deutsch’s algorithm (see Fig. 4.8) encodes
the value of function f (x) in the relative phase of the ﬁrst qubit (rather
than in the state of the second qubit as in Fig. 4.4). This property will
be the key to proving the validity of Deutsch’s algorithm.

To start, consider a controlled two-qubit gate. As described in Sec.
2.6.4, a controlled-U gate with qubit 0 as the control qubit and qubit 1
as the controlled qubit can be expressed as

CU
01

= |0ih0| ⊗ I + |1ih1| ⊗ U.

(4.16)

When applied on vectors of the computational basis, this operator acts
with gate U on qubit 1 if qubit 0 is in state |0i; otherwise, if qubit 0 is
in state |1i, no change is applied to qubit 1. Note that, as in (4.10), the
deﬁnition of a controlled gate can be generalized to gates that apply a
non-trivial transformations to qubit 1 also in the computational branch
in which qubit 0 is in state |0i. In this section we will focus on controlled
gates of the form (4.16) for simplicity of explanation, and the general
case will be considered in the next section.

The key observation in this section is the following. While it may
seem that the control bit 0 cannot be changed by the application of the
controlled gate (4.16), this is not the case. In fact, the application of
can change the relative phase of the amplitudes
the two-qubit gate CU
01
of the control qubit – a phenomenon known as phase kick-back.

To proceed, deﬁne as |φi an eigenvector of the single-qubit gate U
with eigenvalue exp(iθ). Recall that all eigenvalues of unitary matrices
have unitary magnitude (see Sec. 1.4.4). Consider now the operation of
the controlled-U gate on a separable state |ψ, φi, where the state of the
controlling qubit 0 is a generic superposition |ψi = α0|0i + α1|1i. This
situation is illustrated in Fig. 4.9. Accordingly, we have two branches of
computation – in the ﬁrst the controlling qubit is in state |0i, and in
the second the controlling qubit is in state |1i.

4.5. Phase Kick-Back

123

α|0i + α1|1i

α|0i + α1 exp(iθ)|1i

|φi

U

|φi

Figure 4.9: The phase-kick phenomenon: When the state of the controlled qubit is
an eigenvector |φi of the single-qubit gate U with eigenvalue exp(iθ), the net eﬀect
is that the state of the ﬁrst qubit acquires a relative phase term exp(iθ).

With the mentioned input |ψ, φi = α0|0, φi + α1|1, φi, the state
of the controlled qubit is unchanged in the ﬁrst branch, since the
controlling qubit is in state |0i; and is merely multiplied by the phase
term exp(iθ) in the second branch, in which the controlling qubit is in
state |1i. As summarized in Fig. 4.9 and derived next, this phase term
can be equivalently thought of as being “kicked back” to the ﬁrst qubit,
modifying the relative phase between the complex amplitudes of the
computational basis states |0i and |1i.

To elaborate, let us evaluate the output of the circuit in Fig. 4.9 as

CU
01

(|ψi ⊗ |φi) = (|0ih0| ⊗ I)(|ψi ⊗ |φi) + (|1ih1| ⊗ U )(|ψi ⊗ |φi)

= α0|0i|φi + α1|1i exp(iθ)|φi
= (α0|0i + α1 exp(iθ)|1i)|φi,

(4.17)

where in the ﬁrst line we have used the deﬁnition (4.16) of controlled-U
gate. This calculation conﬁrms that the net eﬀect of the application of
the controlled-U gate is to leave the second qubit in the eigenstate |φi
of the gate U , while changing the relative phase of the amplitudes of
the ﬁrst qubit.

As an example, as depicted in Fig. 4.10, consider the CNOT gate
as the controlled gate. The Pauli X gate has eigenvectors |+i and |−i
with respective eigenvalues 1 and −1. Therefore, the phase kick-back
eﬀect is observed by setting the controlled qubit to state |−i, in which
case the relative phase of the ﬁrst qubit is modiﬁed by π.

We conclude this section by noting that the phase kick-back eﬀect
may also lead to undesired eﬀects in the presence of quantum errors
(see problems).

124

Quantum Computing

α|0i + α1|1i

α|0i − α1|1i

|−i

X

|−i

Figure 4.10: The phase kick-back eﬀect for the CNOT gate.

in |±i basis

|−i

|−i

X f (x)

|−i

Figure 4.11: An equivalent description of the quantum circuit describing the
Deutsch algorithm in Fig. 4.8. Note that the gauge block here is used to implement
a measurement in the diagonal basis.

4.6 Validity of Deutsch’s Algorithm

In this section, we show that Deutsch’s algorithm, which is detailed
in Fig. 4.8, is valid, in the sense that, as explained in Sec. 4.4, it
returns the correct solution to the problem of identifying constant or
non-constant binary functions with probability 1. We will see that this
goal is accomplished by leveraging the phase kick-back eﬀect described
in the previous section to encode the value of the function f (·) in the
relative phase of the ﬁrst qubit in Fig. 4.8.

To start, we recall from Sec. 4.3 that the controlled shift operator
CX f is the controlled qubit gate (4.10), which can be specialized for
m = n = 1 as

CX f = |0ih0| ⊗ X f (0) + |1ih1| ⊗ X f (1).

(4.18)

In words, for input states in the computational basis, the controlled shift
operator applies the unitary X f (x) to the second qubit if the ﬁrst qubit
is in state |xi for x ∈ {0, 1}. Note again that this form of controlled
gate is more general than in (4.16) in that a non-trivial gate is applied
also when the controlling qubit is in state |0i.

Now, recalling that the cascade of the Hadamard and standard
measurement implements a measurement in the diagonal basis (see Sec.
3.2.3), we can represent the quantum circuit describing the Deutsch

4.6. Validity of Deutsch’s Algorithm

125

|−i

X f (x)

(−1)f (x)|−i

Figure 4.12: The state |−i is an eigenvector of the unitary U⊕f (x) = X f (x) with
eigenvalue (−1)f (x).

algorithm in Fig. 4.8 as in Fig. 4.11. In this circuit, we have used a
controlled gate representation for the controlled shift operator CX f in
order to highlight the description (4.18).

The key observation at this point is that the state |−i is an eigen-
vector of the operator X f (x) for both x = 0 and x = 1. In fact, we have
the equalities

X f (x)|−i =

1
√
2

(|f (x)i − |f (x) ⊕ 1i) = (−1)f (x)|−i,

(4.19)

showing that the associated eigenvalue is (−1)f (x) (see Fig. 4.12). It
follows that, due to phase kick-back introduced in the previous section,
after the controlled shift gate and prior to the measurement in the
diagonal basis in the quantum circuit of Fig. 4.11, we have the state

CX f |−, −i =

=

=

=

1
√
2
1
√
2
1
√
2
1
√
2

CX f (|0, −i − |1, −i)

(|0iX f (0)|−i − |1iX f (1)|−i)

((−1)f (0)|0, −i − (−1)f (1)|1, −i)

((−1)f (0)|0i − (−1)f (1)|1i)|−i.

(4.20)

Therefore, the state of the ﬁrst qubit, 1√
2
equal to

((−1)f (0)|0i − (−1)f (1)|1i), is

|−i (or −|−i) if the function is constant

(4.21)

and

|+i (or −|+i) if the function is not constant.

(4.22)

Note that the negative sign does not change the quantum state, since
quantum states are unaﬀected by global phases.

126

Quantum Computing

The upshot of this calculation is that, as anticipated, the controlled
shift operator in Fig. 4.11 encodes the values of the function in the
relative phase of the state of the ﬁrst qubit.

This completes the proof of validity of Deutsch’s algorithm. In fact,
measuring the ﬁrst qubit in the diagonal basis as in Fig. 4.11 returns
1 (corresponding to state |−i) with probability 1 if the function is
constant; and it returns 0 (corresponding to state |+i) with probability
1 if the function is not constant. Note that Deutsch’s algorithm produces
a deterministic output despite requiring a single run of the quantum
circuit.

4.7 No Cloning Theorem

As discussed in Sec. 4.2, for many quantum algorithms, including the
most common quantum machine learning methods to be discussed in
Chapter 6, the output of the algorithm is obtained by averaging the
outputs of measurements across multiple runs of the circuit. One may
wonder why it is indeed necessary to run the entire circuit anew when
the goal is to measure again the same output quantum state produced
by the circuit. Couldn’t we simply run the circuit once, produce the
quantum state, “copy” it to multiple quantum systems so that all sys-
tems are in the same state, and ﬁnally measure separately such systems?
Unfortunately, this procedure is physically impossible to implement – a
result known as the no cloning theorem.

The no cloning theorem says that there is no unitary transfor-
mation that can copy an arbitrary, unknown, state |ψi of n qubits into
another quantum system of n qubits. Such a unitary would operate as
shown in Fig. 4.13. Accordingly, given an arbitrary state |ψi and a set
of n additional qubits – typically referred to as ancillas – initially in
the ground state |0i, the hypothetical cloning circuit would produce the
separable state |ψ, ψi = |ψi ⊗ |ψi. In it, both the original qubit and the
ancillas are in the unknown state |ψi.

The proof of the non-existence of cloning unitaries is straightforward
and follows directly from the linearity of the operator U . To see this,

4.7. No Cloning Theorem

127

|ψi

|0i

U ?

|ψi

|ψi

Figure 4.13: No, there is no unitary U that can implement the cloning operation
in the ﬁgure for any arbitrary quantum state |ψi.

suppose that we could devise a unitary with the properties

and

U |ψ, 0i = |ψ, ψi

U |ψ0, 0i = |ψ0, ψ0i

(4.23)

(4.24)

for two distinct states |ψi and |ψ0i. If we applied such a unitary to the
superposition state α|ψi + β|ψ0i, we would obtain

U ((α|ψi + β|ψ0i) ⊗ |0i) = U (α|ψ, 0i + β|ψ0, 0i)

= α|ψ, ψi + β|ψ0, ψ0i,

(4.25)

which is diﬀerent from the desired state (α|ψi + β|ψ0i) ⊗ (α|ψi + β|ψ0i)
containing a clone of the input superposition state. This yields a con-
tradiction, and hence it concludes the proof.

The constraint on no cloning has several key implications, such as

the following:

• Quantum state accessibility: One can generally only obtain
partial information about a quantum state, since, once the state
is measured, it is no longer accessible;

• Quantum error correction: Standard error correction schemes
such as repetition coding are not directly applicable to ﬁght quan-
tum noise such as decoherence, and novel solutions are required
(see Sec. 5.5);

• No superliminal communications: Should quantum cloning
be allowed, it would be possible to communicate instantaneously
via a variant of superdense coding, violating relativity theory;

128

Quantum Computing

n

n

|xi

|yi

UBC

n

n

|xi

|xi

|x ⊕ yi

|0i

n

n

UBC

n

n

|xi

|xi

Figure 4.14: The input-output operation of a basis-copying circuit

• Quantum crypotography: Unconditionally secure communi-
cation schemes can be designed since an eavesdropper cannot
copy quantum information. Any unauthorized measurement of a
quantum system would modify the state of the system, potentially
revealing the presence of an eavesdropper.

4.8 Classical Cloning: Basis-Copying Gate

As we have seen in the previous section, the no cloning theorem states
that one cannot design a quantum circuit that is able to copy any
arbitrary state. However, this does not rule out the possibility to design
quantum circuits that copy speciﬁc quantum states. A useful and stan-
dard example is a circuit that copies only vectors in the computational
basis. The fact that this type of transformation is feasible should be
clear from the fact that we can, of course, copy classical (deterministic)
cbits. We may hence refer to this transformation as a classical cloning
operator.

The classical cloning operator, or basis-copying unitary, UBC
operates as illustrated in Fig. 4.14. To describe it, let us consider n
qubits of interest, along with n ancilla qubits initially in the ground
state |0i. Given an input state |x, 0i, for any quantum state |xi in the
computational basis, the basis-copying unitary should produce at the
output the state |x, xi as shown in Fig. 4.14-(right).

As can be observed by comparing Fig. 4.14-(left) with Fig. 4.4, the
basis-copying circuit amounts to the controlled shift unitary CX ⊗f with
function f (x) = x being the identity matrix. Therefore, specializing

4.9. Conclusions

129

|xi

|0i

|0i

X

X

|xi

|xi

Figure 4.15: Implementation of the basis-copying unitary UBC with n = 2.

(4.10), we can write the basis-copying unitary as

UBC =

2n−1
X

x=0

|xihx| ⊗ (X x0 ⊗ · · · ⊗ X xn−1).

(4.26)

Moreover, the basis-copying unitary can be implemented using
CNOT gates as illustrated in Fig. 4.5 for n = 2. This circuit is repro-
duced in Fig. 4.15 with the input of the ancillas set to the ground state
|0i to emphasize its operation as a basis-copying circuit. For any number
n of qubits, each of the n top qubits acts as the controlling qubit of
a CNOT gate that controls a distinct ancilla qubit. One can readily
check that this circuit implements the transformation described in Fig.
4.14-(left).

It is important to emphasize that the basis-copying circuit is not
a general cloning circuit – it cannot be by the no cloning theorem. To
see this, consider the situation in Fig. 4.16, in which the n = 2 qubits
are in a general superposition state |ψi = P3
x=0 αx|xi. The output
of the basis cloning circuit is given by the generally entangled state
|ψi = P3
x=0 αx|x, xi, which is diﬀerent from the ideal output |ψi ⊗ |ψi
of a hypothetical cloning circuit.

4.9 Conclusions

In this chapter, we have introduced some key elements of traditional
quantum computing, including the gate-based architecture, phase kick-
back, and the constraints imposed by the no cloning theorem. In the
next chapter, we will broaden the scope of the quantum primitives at
our disposal by further generalizing quantum measurements.

130

Quantum Computing

|ψi = P3

x=0 αx|xi

|0i

|0i

X

X

|ψi = P3

x=0 αx|x, xi

Figure 4.16: The basis-copying unitary is not a general quantum cloning machine.

4.10 Recommended Resources

Recommended references on quantum computing include [2], [3], [9].
Hardware implementation aspects are discussed in [10], [11].

4.11 Problems

1. Provide a quantum circuit that implements a general controlled
shift operator deﬁned by any function f (x) from m to n bits.
[Assume that you have access to a classical data base of 2m binary
strings of n bits deﬁning function f (x).]

2. Describe a situation in which a phase ﬂip occurring on a qubit
causes a phase ﬂip on another qubit when the two qubits interact
via a CNOT gate. Recall that a phase ﬂip error is described by
the application of a Pauli Z operator. [Hint: Use phase kick-back.]

3. Describe the Deutsch-Jozsa algorithm that extends Deutsch algo-
rithm to any n. Describe its operation in terms of phase kick-back
(see recommended resources).

4. Show that, for any function f (x) from an n-cbit string x to a single
cbit (m = 1), the 2n × 2n matrix U deﬁned as U |xi = (−1)f (x)|xi
is unitary. Relate this observation to Deutsch’s algorithm.

5. Show that if cloning was possible, it would also be feasible to

communicate information faster than light.

5

Generalizing Quantum Measurements (Part II)

5.1 Introduction

The most general type of measurement studied so far consist of partial
measurements in which a subset of qubits is measured in an arbitrary ba-
sis (see Sec. 3.3.4). In this chapter, we provide two successive extensions
of such measurements. First, we introduce projective measurements,
and, with it, the important concept of quantum observables. As an
application of projective measurements, we also brieﬂy discuss quantum
error correction. Then, we further extend projective measurements to
positive operator-valued measurements (POVMs), which provide the
most general form of quantum measurements. As an application of
POVMs, we cover the problem of unambiguous state detection. Finally,
the chapter derives quantum channels from non-selective measurements.
Along with POVMs, quantum channels exhaust the set of all possible
operations applicable on a quantum system.

5.2 Projective Measurements

In this section, we introduce projective measurements.

131

132

Generalizing Quantum Measurements (Part II)

5.2.1 Complete vs. Incomplete Measurements

A von Neumann measurement of n qubits in an arbitrary orthonormal
basis {|vxi}2n−1
(see Sec. 3.2) is said to be complete, reﬂecting the fact
x=0
that the post-measurement state is fully described by the measurement
output x ∈ {0, 1, ..., 2n − 1}. Indeed, when the measurement output is x,
the post-measurement state is given by vector |vxi. Note that the post-
measurement state |vxi is known even when, as is usually the case, the
pre-measurement state is not known. In contrast, partial measurements
of a subset of qubits (see Sec. 3.3) are said to be incomplete, since
the post-measurement state is not fully speciﬁed by the measurement
output. Rather, the state of the qubits that are not measured generally
retains its dependence on the pre-measurement state.

As we will introduce in this section, projective measurements provide
a more general framework to deﬁne incomplete measurements. While a
complete measurement necessarily causes a “collapse” of the waveform,
unless the pre-measurement state is one of the vectors in the measure-
ment basis {|vxi}2n−1
, projective measurements allow for “gentler”
x=0
measurements that leave unchanged pre-measurement states belong-
ing to speciﬁc (non-trivial) subspaces. As we will see, this property has
useful practical implications.

5.2.2 Projection Matrices

Projective measurements are deﬁned by projection matrices. A projec-
tion matrix Π is a (square) positive semideﬁnite matrix with eigenval-
ues equal to 0 or 1. Speciﬁcally, an N × N projection matrix Π with
rank r ∈ {1, ..., N } has r eigenvalues equal to 1 and all other, N − r,
eigenvalues equal to 0. Therefore, by the spectral theorem (see Sec.
1.4.4), it can be expressed as

Π =

r−1
X

x=0

|vxihvx|,

(5.1)

where {|vxi}r−1
are the eigenvectors associated with eigenvalue 1. Note
x=0
that the eigendecomposition (5.1) is not unique, in the sense that any
other orthonormal basis of the r-dimensional subspace spanned by
vectors {|vxi}r−1
x=0

can be used in (5.1) in lieu of vectors {|vxi}r−1
x=0

.

5.2. Projective Measurements

133

Geometrically, the operation Π|ai for some N × 1 state vector |ai
corresponds to the orthogonal projection of vector |ai onto the
subspace spanned by the r eigenvectors {|vxi}r−1
of matrix Π that are
x=0
associated with eigenvalues equal to 1. We will refer to this r-dimensional
subspace as the subspace spanned by projection matrix Π. Note
that, by this geometric interpretation, unless all N eigenvalues are equal
to 1, a projection matrix Π is not unitary, since it does not preserve
the norm of an arbitrary input vector.

In the decomposition (5.1) an important role is played by rank-1

projection matrices

vx = |vxihvx|.
(5.2)
Geometrically, the eﬀect of a rank-1 projection matrix vx on an input
vector |ai is to compute the projection vx|ai of the latter in the direction
speciﬁed by vector |vxi.

5.2.3 Reviewing von Neumann Measurements

For reference, we review here von Neumann measurements by highlight-
ing the role of rank-1 projection matrices in the deﬁnition of measure-
ment probabilities and post-measurement states.

As discussed in Sec. 3.5.4, a von Neumann measurement is speciﬁed
by an orthonormal basis {|v0i, |v1i, ..., |vN −1i} of N = 2n vectors, each
of dimension N ×1. According to Born’s rule, the probability of observing
output x ∈ {0, 1, ..., N − 1} is

Pr[measurement output equals x] = hvx|ρ|vxi

= tr(|vxihvx|ρ) = tr(vxρ),

(5.3)

where we have used the deﬁnition (5.2) of rank-1 projection matrices
vx with x ∈ {0, 1, ..., N − 1}. Furthermore, the post-measurement state,
expressed as a density matrix, is

|vxihvx| = vxρvx
hvx|ρ|vxi

,

(5.4)

as it can be proved by noting that we can always write the density
matrix ρ as

ρ =

N −1
X

N −1
X

x=0

x0=0

λx,x0|vxihvx0|,

(5.5)

134

Generalizing Quantum Measurements (Part II)

with λx,x0 = hvx|ρ|vx0i.

From the derivations in the previous paragraph, von Neumann mea-
surements are deﬁned by rank-1 projection matrices vx = |vxihvx| for
x ∈ {0, 1, ..., N − 1}. Importantly, these matrices satisfy the resolution-
of-identity condition

N −1
X

x=0

vx = I,

(5.6)

where I is the N × N identity matrix. To see that the equality (5.6)
holds, it is suﬃcient to note that we have the equality

!

vx

|ψi = |ψi

 N −1
X

x=0

(5.7)

for any input state |ψi, since the latter can always be expressed as the
superposition |ψi = PN −1
x=0 αx|vxi and we have

vx|vx0i = |vxihvx|vx0i,

(5.8)

with hvx|vx0i = 0 for x 6= x0 and hvx|vxi = 1.

5.2.4 Deﬁning Projective Measurements

Generalizing the description given in the previous subsection of von
Neumann measurements, projective measurements are deﬁned as follows.
A projective measurement is speciﬁed by a set of N 0 ≤ N projection
matrices {Πy}N 0−1
, with rank possibly larger than 1 (when N 0 < N ),
y=0
such that the resolution-of-identity condition

N 0−1
X

y=0

Πy = I

(5.9)

equals the entire N -dimensional Hilbert space.

is satisﬁed. Geometrically, condition (5.9) indicates that the subspace
spanned by the union of the eigenvectors of all projection matrices
{Πy}N 0−1
y=0
A projective measurement deﬁned by projection matrices {Πy}N 0−1
y=0
satisfying the resolution-of-identity condition (5.9) operates on an input
quantum state ρ as follows.

5.2. Projective Measurements

135

• Born’s rule: The probability of observing y ∈ {0, 1, ..., N 0 − 1} is

Pr[measurement output equals y] = tr(Πyρ),

(5.10)

which, for a pure state ρ = |ψihψ| simpliﬁes as

Pr[measurement output equals y] = tr(Πyρ) = hψ|Πy|ψi;

(5.11)

• “Incomplete collapse” of the state: The post-measurement

state is

ΠyρΠy
tr(Πyρ) ,

which, for a pure state ρ = |ψihψ| simpliﬁes as

Πy|ψi
hψ|Πy|ψi

.

q

(5.12)

(5.13)

With rank-1 projection matrices, these rules reduce to the von
Neumann measurement reviewed in the previous subsection, which are
complete. More generally, by the post-measurement state (5.13), projec-
tive measurements are incomplete. To see this, assume that projection
matrix Πy has rank larger than 1 and that the input state |ψi is an
unknown coherent state. Then, upon measuring output y, the post-
measurement state (5.13) can be generally only determined as being
any state vector in the subspace spanned by projection matrix Πy.

A related observation concerns the pre-measurement states that
are left unchanged by a projective measurement. A von Neumann
measurement in basis {|v0i, |v1i, ..., |vN −1i} leaves a pre-measurement
state |ψi unchanged if and only if it is one of the vectors |vxi in the
basis, i.e., if |ψi = |vxi for some x ∈ {0, 1, ..., N − 1}. In contrast, a
projective measurement leaves a state |ψi unchanged if it is any vector
in the subspace spanned by one of the projection matrices Πy. This
is because, in this case, the projective measurement returns y with
probability 1, and the post-measurement state (5.13) equals the pre-
measurement state. This property is at the core of the application of
projective measurements for quantum error correction (see Sec. 5.5).

136

Generalizing Quantum Measurements (Part II)

5.2.5 Projective Measurements Generalize von Neumann Measure-

ments and Partial Measurements

As mentioned at the beginning of this chapter, projective measurements
include the most general type of measurement studied prior to this
chapter, i.e., partial measurements in an arbitrary basis, which were
detailed in Sec. 3.3.4.

To see this, consider as in Sec. 3.3.4 systems of n qubits in which
we measure any subset of n0 ≤ n qubits in any orthonormal basis
{|vyi}2n0
. Without loss of generality, we order the qubits so that the
ﬁrst n0 qubits are measured. Now, deﬁne the projection matrices

y=0

−1

Πy = vy ⊗ I,

(5.14)

where vy = |vyihvy| is a rank-1 projection matrix and the identity matrix
is of size 2n−n0 × 2n−n0. It can be now readily checked that, for any
given pre-measurement state |ψi, the generalized Born rule (3.20) and
the post-measurement state (3.21) are obtained from the projective
measurement rules (5.11) and (5.13), respectively.

5.2.6 Local vs. Joint Measurements

As discussed in Sec. 3.2, some measurements, like standard measure-
ments, can be carried out separately on each qubit, while others require
joint measurements across multiple qubits. The formalism of projective
measurements makes it easy to distinguish these two situations.

To elaborate, consider a quantum system in which we identify a
number of subsystems, e.g., the individual qubits. A local measurement
across the subsystems is speciﬁed by projection matrices that can be
expressed as the Kronecker product of individual projection matrices,
one for each of the subsystems.

An example of a local measurement is given by the partial measure-
ments studied in the previous subsection. In fact, the projection matrix
in (5.14) is written as the Kronecker product vy ⊗ I of a projection
matrix, vy, operating on the subsystem being measured and of the
degenerate projection matrix given by the identity matrix I. The latter
indicates that no measurement is carried out on the second subset of
qubits.

5.2. Projective Measurements

137

More generally, when the projection matrices cannot be expressed
in Kronecker product form, the measurement needs to be carried out
jointly across the involved subsystems.

5.2.7 How to Construct a Projective Measurement

deﬁning a projective measurement

The projection matrices {Πy}N 0−1
y=0
can be always obtained from some orthonormal basis {|v0i, |v1i, ..., |vN −1i},
with N = 2n, by: (i) partitioning vectors {|v0i, |v1i, ..., |vN −1i} into N 0
subsets; and (ii) deﬁning Πy as the projection matrix onto the subspace
spanned by the y-th subset of basis vectors.

More formally, in order to deﬁne a projective measurement, let us

ﬁx:

• an orthonormal basis {|v0i, |v1i, ..., |vN −1i};

• and a partition of the index set {0, 1, ..., N − 1} into N 0 disjoint
subsets Xy ⊆ {0, 1, ..., N − 1} with y ∈ {0, 1, ..., N 0 − 1}, such that
their union equals the overall set {0, 1, ..., N − 1}.

Then, each matrix Πy is deﬁned as the projection matrix onto the
subspace spanned by the y-th subset of vectors, i.e.,

Πy = X
x∈Xy
If each set Xy contains a single vector, and hence all projection matrices
have rank 1, this construction recovers the von Neumann measurement
in the orthonormal basis {|v0i, |v1i, ..., |vN −1i}.

|vxihvx|.

(5.15)

5.2.8 An Example: Parity Measurements

To illustrate the operation of a projective measurement, let us consider
n = 2 qubits (i.e., N = 4) and ﬁx the computational basis {|00i,|01i,
|10i, |11i}. A projective measurement with N 0 = 2 possible outcomes
can be deﬁned by partitioning these vectors into even-parity states
{|00i, |11i}, for which the number of ones in the deﬁning cbit string is an
even number; and odd-parity states {|01i, |10i} in which the number
of ones is odd. Note that this corresponds to the subsets X0 = {00, 11}
and X1 = {01, 10}.

138

Generalizing Quantum Measurements (Part II)

Accordingly, the parity projective measurement is deﬁned by

the rank-2 projection matrices

Π0 = |00ih00| + |11ih11|

(5.16)

and

Π1 = |01ih01| + |10ih10|.
Note that this is a joint measurement since the projection matrices
Π0 and Π1 cannot be expressed as the Kronecker products of 2 × 2
projection matrices.

(5.17)

Let us now study the eﬀect of the parity projective measurements

on two qubits in an arbitrary pure state

|ψi = α00|00i + α01|01i + α10|10i + α11|11i.

(5.18)

By the Born rule (5.11), the output of the measurement is y = 0 with
probability

hψ|Π0|ψi = |α00|2 + |α11|2,

and y = 1 with probability

hψ|Π1|ψi = |α01|2 + |α10|2.

Furthermore, the post-measurement state (5.13) is

(5.19)

(5.20)

Π0|ψi
phψ|Π0|ψi

=

1
p|α00|2 + |α11|2

(α00|00i + α11|11i)

(5.21)

when the measurement output is y = 0; while it is

Π1|ψi
phψ|Π1|ψi

=

1
p|α01|2 + |α10|2

(α01|01i + α10|10i)

(5.22)

when the measurement output is y = 1.

Therefore, if the measurement output is y ∈ {0, 1}, the post-
measurement state (5.21) is in the subspace spanned by Πy, i.e., by
the even- or odd-parity computational-basis vectors. Apart from this
information, nothing else can be inferred from the output of the measure-
ment, unless one knows the amplitudes α00, α01, α10, and α11 of the pre-
measurement state. This makes the measurement incomplete. Note the

5.3. Observables

139

diﬀerence with a von Neumann measurement in the computational basis,
in which the post-measurement state is the computational-basis vector
|x0, x1i corresponding to the measurement’s output (x0, x1) ∈ {0, 1}2.
Consider now the situation in which the measured state |ψi is in
the subspace spanned by Π0, and hence it can be written as |ψi =
α00|00i + α11|11i. Since this state is the superposition of even-parity
computational basis vectors, it is also said to have an even parity.
When applied to such an even-parity state, the parity measurement
produces output y = 0 with probability 1, and the post-measurement
state equals the pre-measurement state. Similarly, if the state |ψi has
an odd parity, i.e., if it is given as |ψi = α01|01i + α10|10i, lying in
the subspace spanned by projection matrix Π1, the parity measurement
produces output y = 1 with probability 1, and the post-measurement
state coincides with the pre-measurement state.

We ﬁnally observe that the projection matrices deﬁning the parity
projective measurement can be also written in terms of orthonormal
bases other than the computational basis. This is because the have rank
larger than 1. As a useful example, it can be directly checked that the
projection matrices in (5.38) can be expressed in terms of the Bell basis
(2.24) as

Π0 = |Φ+ihΦ+| + |Φ−ihΦ−|

Π1 = |Ψ+ihΨ+| + |Ψ−ihΨ−|.

(5.23)

(5.24)

and

5.3 Observables

Observables model numerical quantities that can be extracted from
a quantum system through measurements. While the measurements
presented so far always return cbit strings, observables allow the de-
scription of measurements that output real numerical values. In this
section, we deﬁne observables and their expectations; provide examples
of single- and multi-qubit observables; and ﬁnally introduce the concept
of compatible observables.

140

Generalizing Quantum Measurements (Part II)

5.3.1 Deﬁning Observables

An observable O assigns a numerical, real, value oy to each output y
of a projective measurement {Πy}N 0−1
. Therefore, by the Born rule
y=0
(5.10), measuring the observable O returns the numerical value oy with
probability tr(Πyρ) when the input quantum state is ρ. We can express
this deﬁning property as the probability

Pr[measurement of O equals oy] = tr(Πyρ),

(5.25)

for y ∈ {0, 1, ..., N 0 − 1}, which reduces to

Pr[measurement of O equals oy] = hψ|Πy|ψi

(5.26)

for a pure pre-measurement state |ψi.

Note that, when using the formalism of observables in quantum
computing, one is often interested only in the numerical value pro-
duced by the measurement and not in the post-measurement state.
We will take this viewpoint here, although one can readily deﬁne also
the post-measurement state via (5.12) given the underlying projective
measurement {Πy}N 0−1
y=0

The output of the measurement of an observable is a random variable
with distribution (5.25). An important role in many quantum algorithms
is played by the expectation of an observable (see Sec. 4.2). By
(5.25), given an input quantum state ρ, the expectation of observable
O, denoted as hOiρ, can be computed as

.

hOiρ =

N 0−1
X

y=0

oytr(Πyρ) = tr(Oρ),

(5.27)

where we have deﬁned the matrix

N 0−1
X

O =

oyΠy.

(5.28)

y=0
Matrix O is Hermitian (since projection matrices are Hermitian); but
not necessarily positive semideﬁnite, since the values oy can be negative.
Specializing (5.27) to a pure input quantum state |ψi, the expecta-

tion of observable O, denoted as hOi|ψi, can be written as

hOi|ψi = tr(O|ψihψ|) = hψ|O|ψi.

(5.29)

5.3. Observables

141

The results derived in the last two paragraphs highlight the impor-
tant role played by matrix O in the formalism of observables. We now
further elaborate on this point by demonstrating that any Hermitian
matrix O fully describes an observable in terms of both the probabilities
(5.25) of all possible outputs {oy}N 0−1
and of the expectation (5.27).
y=0
Accordingly, we will conclude that an observable O can be speciﬁed by
an Hermitian matrix O, justifying the use of the same notation O for
both concepts.

To proceed, let us ﬁx an arbitrary Hermitian matrix O. By the

spectral theorem, matrix O has eigendecomposition

O =

N −1
X

x=0

λx|vxihvx|,

(5.30)

where the eigenvectors {|v0i, |v1i, ..., |vN −1i} form an orthonormal basis
and the associated eigenvalues {λ0, λ1, ..., λN −1} are real. The eigenvec-
tors {|v0i, |v1i, ..., |vN −1i} deﬁne the eigenbasis of observable O.

To see how to use the eigendecomposition (5.30) to deﬁne an ob-
servable, let us now write as oy, with y ∈ {0, 1, ..., N 0 − 1}, the N 0
distinct eigenvalues. Note that we have the inequality N 0 ≤ N . The
projective measurement associated with observable O is then deﬁned
by the projection matrices

Πy = X

|vxihvx|

(5.31)

x: λx=oy
for y ∈ {0, 1, ..., N 0 − 1}. The sum in (5.31) is over all eigenvectors cor-
responding to the same eigenvalue oy. That is, each matrix Πy projects
onto the subspace spanned by all the eigenvectors with eigenvalues
equal to oy. With this choice, the observable (5.30) can be written as
in (5.28).

The derivation outlined in the previous paragraph shows that, given
a Hermitian matrix O, one can identify the possible numerical outputs
of the observable O as the eigenvalues of matrix O. Furthermore, the
subspaces spanned by the corresponding eigenvectors associated with
each distinct eigenvalue deﬁne the projection matrices of the underlying
projective measurement. With this information, based on Hermitian
matrix O, the observable O is fully speciﬁed in terms of probabilities
(5.25) and expectation (5.27).

142

Generalizing Quantum Measurements (Part II)

5.3.2 Single-Qubit Observables

In this subsection, we study two examples of observables for single qubits
(n = 1). The ﬁrst is the Z observable, whose deﬁning Hermitian matrix
is given by the Pauli Z matrix. For this matrix, the eigendecomposition
(5.30) specializes to

Z = |0ih0| − |1ih1|,
(5.32)
and hence the computational basis is the eigenbasis of the Z observ-
able. By the discussion in the previous subsection, measuring the Z
observable corresponds to a standard von Neumann measurement in
the computational basis, in which the measurement output 0 is asso-
ciated the numerical value o0 = 1 and the measurement output 1 is
associated the numerical value o1 = −1. Accordingly, for any pure state
|ψi = α0|0i + α1|1i, by (5.29), we have the expectation
hZi|ψi = hψ|Z|ψi = (+1)|h0|ψi|2 + (−1)|h1|ψi|2 = |α0|2 − |α1|2. (5.33)
Consider now the X observable. This is also a valid observable
because the Pauli matrix X is Hermitian, and it can be expressed with
its eigendecomposition as

X = |+ih+| − |−ih−|.

(5.34)

This corresponds to a measurement in the diagonal, {|+i, |−i}, basis
– the eigenbasis of observable X – in which the measurement output
0 is associated with numerical value o0 = 1 and the measurement
output 1 is associated with o1 = −1. Moreover, for any pure state
|ψi = α0|0i + α1|1i, we have the expectation

hXi|ψi = hψ|X|ψi = (+1)|h+|ψi|2 + (−1)|h−|ψi|2

= |α0 + α1|2
2

−

|α0 − α1|2
2

.

(5.35)

5.3.3 Local Multi-Qubit Observables

Let us now consider observables on any number n of qubits. We start
by studying the important class of observables deﬁned by Pauli strings.
These provide an important example of local observables, whose numer-
ical outputs can be produced via separate measurements applied on
each qubit.

5.3. Observables

143

Using the notation from Sec. 2.6.1, let us write as Ps with s ∈

{0, 1, 2, 3} a Pauli matrix, with

P0 = I, P1 = X, P2 = Y, and P3 = Z.

(5.36)

Furthermore, let sn = [s0, ..., sn−1] be a vector of integers sk ∈ {0, 1, 2, 3}
with k ∈ {0, 1, ..., n − 1}. A string of n Pauli matrices, Psn, is given
by the Kronecker product of n Pauli matrices

Psn = Ps0 ⊗ Ps2 ⊗ · · · ⊗ Psn−1,

(5.37)

where each matrix Psk
be readily checked that any Pauli string (5.37) is a valid observable.

is one of the Pauli matrices {I, X, Y, Z}. It can

To illustrate the process of measuring local observables such as a
Pauli string, we study the following example. Consider n = 2 qubits
and the observable given by the Pauli string O = Z ⊗ Z. By using the
eigendecomposition (5.32), this observable can be written as

O = (|0ih0| − |1ih1|) ⊗ (|0ih0| − |1ih1|)

= (|00ih00| + |11ih11|
) − (|01ih01| + |10ih10|
}
}

|

|

).

(5.38)

{z
Π1

{z
Π0

The expression (5.38) reveals that the eigendecomposition of the observ-
able O is characterized by two eigenvalues, +1 and −1, each with an
associated subspace of dimension 2. Speciﬁcally, the eigenvalue o0 = 1
is associated with the subspace spanned by the even-parity computa-
tional basis vectors, i.e., by projection matrix Π0; while the eigenvalue
o1 = −1 is associated with the subspace spanned by the odd-parity
computational basis vectors, i.e., by projection matrix Π1.

From the discussion in Sec. 5.3, it follows that a measurement of the
observable O = Z ⊗ Z corresponds to the parity projective measurement
in which the numerical output o0 = 1 is assigned to an even parity
output, and numerical output o1 = −1 is obtained with an odd-parity
output. Therefore, the numerical output equals 1 with probability (5.19),
and it equals −1 with probability (5.20).

While the parity measurement is not local (see Sec. 5.2.8), if one
is only interested in the numerical output of the measurement of the
observable O = Z ⊗ Z (and not also in the post-measurement state), it

144

Generalizing Quantum Measurements (Part II)

is possible to implement the measurement of O separately across the
two qubits. To this end, we measure the Z observable at each of two
qubits, and then multiply the numerical outputs obtained from the two
measurements.

Let us further elaborate on the measurement of observable O = Z⊗Z.
Measuring the Z observable separately at the two qubits amount to a
standard measurement of the two qubits. Therefore, given an input state
(5.18), this measurement yields the cbits (1, 1) with probability |α00|2;
(−1, −1) with probability |α11|2; (1, −1) with probability |α01|2; and
(−1, 1) with probability |α10|2. It follows that the product of the two
observations equals 1 with probability |α00|2 + |α11|2, and it equals −1
with probability |α01|2 + |α10|2, as in the parity projective measurement.
This calculation conﬁrms that the numerical value of observable O =
Z ⊗ Z can be obtained via local measurements of the two qubits in the
Z basis.

5.3.4 Joint Multi-Qubit Observables

Not all observables are local. However, following Sec. 2.6.1, any observ-
able on n qubits, i.e., any Hermitian matrix of dimension N × N with
N = 2n, can be expressed as a linear combination with real coeﬃcients
of n-qubit Pauli strings. Therefore, any observable on n qubits can be
written as

O = X

asnPsn

sn∈{0,1,2,3}n

(5.39)

for some real coeﬃcients {asn}.

This decomposition does not directly provide a way to measure
arbitrary observables via local measurements. However, it suggests an
approach to evaluate expectations of such observables via the separate
measurements of observables of Pauli strings. In fact, by (5.39), the
expectation hOiρ of any observable O can be expressed as the weighted
sum, with weights {asn}, of the expectations hPsniρ of the 4n Pauli
observables as

hOiρ = X

asnhPsniρ.

sn∈{0,1,2,3}n

(5.40)

5.3. Observables

145

5.3.5 Compatible Observables

Suppose that we are interested in measuring multiple observables –
say O1 and O2 – at the same time. Can we do this with a single
measurement? If so, we say that the two observables are compatible.
When two observables are not compatible, measuring one observable
would produce a post-measurement state for which a measurement of
the second observable would no longer have the same distribution as
under the original, pre-measurement, state.

It can be proved that two observables O1 and O2 are compatible

if and only if they share a common eigenbasis. Mathematically, let

O1 =

N −1
X

x=0

λ1,x|vxihvx| and O2 =

N −1
X

λ2,x|vxihvx|

(5.41)

x=0

be two observables. They are compatible since they share the same
eigenbasis {|vxi}N −1
. Note that they have generally diﬀerent eigenvalues.
x=0
Measuring both observables simultaneously is possible by carrying out a
measurement in the eigenbasis {|vxi}N −1
. In particular, when obtaining
x=0
the output x, the numerical output for observable O1 is the eigenvalue
λ1,x, while for observable O2 we have the numerical output λ2,x.

As an alternative, equivalent, characterization, two observables O1
and O2 are compatible if and only if they commute, that is, if and
only if we have the equality

O1O2 = O2O1.
This condition can provide an eﬃcient way to check whether two ob-
servables are compatible.

(5.42)

As a ﬁrst example, single-qubit observables applied to diﬀerent
qubits – e.g., O1 = X ⊗ I and O2 = I ⊗ Z – are compatible, since they
commute – e.g., O1O2 = O2O1 = X ⊗ Z. In fact, they can be measured
via separate measurements on the qubits.

As another example, consider the observables O1 = Z ⊗ I and

O2 = Z ⊗ Z. The two observables commute, i.e.,

(Z ⊗ I)(Z ⊗ Z) = I ⊗ Z = (Z ⊗ Z)(Z ⊗ I),

(5.43)

and hence they are compatible. They can be both measured simultane-
ously via a standard measurement in the computational basis.

146

Generalizing Quantum Measurements (Part II)

In contrast, the observables O1 = Z and O2 = X on a single qubit
are not compatible since they do not commute, given that we have the
equality

XZ = iY = −ZX.
It follows that they cannot be measured simultaneously. Rather, one
needs to prepare the pre-measurement state twice, and implement two
separate measurements for the two observables.

(5.44)

The existence of incompatible observables is at the core of Heisen-
berg uncertainty principle. This fundamental result indicates that,
for a given input quantum state |ψi, the product of the standard de-
viations of the observations of two measurements is lower bounded by
a quantity that depends on the degree to which the two observables
commute.

5.4 Implementing Projective Measurements

As we have seen in Sec. 3.2.3, any complete measurement in an arbitrary
basis {|v0i, |v1i, ..., |vN −1i} can be implemented as illustrated in Fig.
3.2 by means of standard measurements in the computational basis.
This is done by adding pre- and post-processing unitary transformations
Uvx→x = PN −1
that convert the given basis
x=0 |xihvx| and U †
= Ux→vx
into the computational basis {|xi}N −1
and back, respectively. As we
x=0
discuss in this section, a similar approach can be used to implement
more general projective measurements for an important special case.

vx→x

5.4.1 Balanced Projective Measurements

We speciﬁcally focus on projective measurements on n qubits that satisfy
the following two conditions:

• the number of measurement outcomes, and hence the number of
projection matrices, is N 0 = 2n0 for some integer for n0 ≤ n; and

• all the projection matrices Πy, with y ∈ {0, 1, ..., 2n0 − 1}, have

the same rank N/N 0 = 2n−n0 with N = 2n.

We will refer to such projective measurements as being balanced, since
the subspaces corresponding to the projection matrices deﬁning it have

5.4.

Implementing Projective Measurements

147

the same dimension. Balanced measurements include as special cases
the parity measurement introduced in Sec. 5.2.8, as well as standard
partial measurements of n0 qubits (see Sec. 5.2.5).

5.4.2

Implementing Balanced Projective Measurements via Partial
Measurements

In this subsection, we show that a balanced projective measurement can
be carried out via a partial measurement (in the computational basis)
of n0 qubit. As illustrated in Fig. 5.1, this is done by adding suitable
pre- and post-measurement unitaries that perform a speciﬁc change-of-
basis transformation. This transformation, as well as the overall system
depicted in Fig. 5.1, generalize the approach detailed in Fig. 3.2 for the
special case of von Neumann measurements (in which n0 = n).

Following Sec. 5.2.7, any balanced projective measurement can be
expressed in terms of an orthonormal basis {|vx0i}N −1
by partitioning
x0=0
the basis into N 0 = 2n0 subsets, each with N/N 0 = 2n−n0 elements. This
partition can be deﬁned without loss of generality in such a way that
the n-cbit string x0 is expressed as the concatenation of two cbit strings
as x0 = (x, y), where

• the n0-cbit string y indicates the subset to which the vector |vx0i
belongs, i.e., we have x0 ∈ Xy (recall the notation in Sec. 5.2.7);
and

• the (n − n0)-cbit string x identiﬁes the speciﬁc vector |vx0i within

the y-th subset.

With the partition described in the previous paragraph, a balanced

projective measurement is described by projection matrices

Πy =

N/N 0−1
X

x=0

|vx,yihvx,y|

(5.45)

with y ∈ {0, 1, ..., N 0 − 1}.

We now introduce the change-of-basis unitary Uvx,y→x,y that maps
each vector |vx,yi in the orthonormal basis used to describe the projective
measurement to the computational-basis vector |x, yi, i.e.,

Uvx,y→x,y|vx,yi = |x, yi.

(5.46)

148

Generalizing Quantum Measurements (Part II)

n−n0

|ψi

Uvx,y→x,y

n0

U †

vx,y→x,y

y

√

Πy|ψi
hψ|Πy|ψi

Figure 5.1: Architecture implementing a general balanced projective measurement
via a partial measurement of a subset of qubits.

Note that this transformation reduces to the unitary Uvx→x used in Fig.
3.2 for the special case of von Neumann measurements (n0 = n).

With this transformation, the balanced projective measurement
deﬁned by projection matrices (5.45) can be implemented as in Fig.
5.1. In this circuit, the change-of-basis transformation Uvx,y→x,y is ﬁrst
applied to the input state |ψi to be measured. Then, the second set
of n0 qubits is measured using a standard measurement to produce
output y ∈ {0, 1, ..., 2n0 − 1} with the desired probability (5.11). This
can be readily checked by using the generalized Born rule (see problems).
Furthermore, after the second unitary transformation U †
, one
recovers the post-measurement state (5.13).

vx,y→x,y

5.4.3 An Example: Parity Measurements

As an example, in this subsection, we specialize the architecture in Fig.
5.1 to the parity measurement with projection matrices {Π0, Π1} in
(5.16)-(5.17). Note that we have n0 = 1 and that both projection matrices
have rank equal to 2. Therefore, the parity projective measurement is a
balanced projective measurement as deﬁned in this section.

For the parity measurement, the decomposition (5.45) holds with
|v00i = |00i, |v10i = |11i, |v01i = |01i, and |v11i = |10i. Note that in
each vector |vx,yi, the bit y identiﬁes the projector, while the bit x
determines the speciﬁc eigenvector with the y-th subspace. Accordingly,
the transformation Uvx,y→x,y described in the previous subsection maps
states |v00i = |00i and |v10i = |11i to |00i and |10i, respectively; and
states |v01i = |01i and |v11i = |10i to |01i and |11i, respectively.

The transformation Uvx,y→x,y can be readily seen to amount to a sin-

5.5. Quantum Error Correction

149

|ψi

y

X

X

√

Πy|ψi
hψ|Πy|ψi

Figure 5.2: A quantum circuit implementing a parity measurement on two qubits.

gle CNOT gate with the ﬁrst qubit controlling the second. Accordingly,
a parity measurement can be carried out by specializing the architecture
in Fig. 5.1 as depicted in Fig. 5.2.

To verify that the circuit in Fig. 5.2 indeed produces the desired
outcome, consider an arbitrary pure state (5.18) as the input. After the
ﬁrst CNOT in Fig. 5.2, we have

C01|ψi = α00|00i + α01|01i + α10|11i + α11|10i.

(5.47)

Note that for each vector in the computational basis, i.e., every input
vector of the form |x, yi with x, y ∈ {0, 1}, the second qubit now reports
the parity of the corresponding input state. By the generalized Born rule,
measuring the second qubit produces the output y = 0 with probability
|α00|2 + |α11|2, which coincides with (5.19), as desired. Furthermore,
when y = 0, the second CNOT transforms the post-measurement state

1
p|α00|2 + |α11|2

(α00|00i + α11|10i)

(5.48)

into the desired post-measurement state (5.21) for the parity measure-
ment, i.e.,

Π0|ψi
phψ|Π0|ψi

=

1
p|α00|2 + |α11|2

(α00|00i + α11|11i).

(5.49)

A similar calculation applies for the case in which the measurement
output is y = 1, recovering probability (5.20) and post-measurement
state (5.22).

5.5 Quantum Error Correction

As an application of projective measurements, in this section, we brieﬂy
introduce the problem of quantum error correction. To this end, suppose

150

Generalizing Quantum Measurements (Part II)

that we have a noisy quantum “channel”, which may represent, for
instance, a communication link or noisy hardware. We would like to
design an error correction scheme that is able to recover the original
state of a qubit irrespective of the noise on the channel. Classically, the
problem could be solved via redundancy: By copying and transmitting
the information of interest multiple times through the channel, one can
ensure some level of protection against channel errors. However, by the
no cloning theorem, we cannot duplicate an unknown quantum state in
order to increase robustness to noise.

Notwithstanding the outlined limitation imposed by no cloning, is
some form of error correction possible? We will see in this section that
the answer to this question is aﬃrmative, and that quantum error cor-
rection hinges on the implementation of projective measurements. It is
emphasized that quantum error correction is a vast area of research, and
that this section is only meant to illustrate some basic ideas pertaining
the connection with projective measurements.

5.5.1 Bit-Flip Channel

In order to illustrate the process of quantum error correction, we consider
a simple channel characterized by a “bit ﬂip” noise. Given three qubits
with a given input state, the channel may “ﬂip” at most one out of
three qubits. Formally, this means that, if we have three qubits in a
general coherent state

|ψini =

1
X

1
X

1
X

x=0

y=0

z=0

αx,y,z|x, y, zi

(5.50)

5.5. Quantum Error Correction

151

before the application of the channel, the state |ψouti after the applica-
tion of the channel may be

|ψouti = |ψini, or

|ψouti = (X ⊗ I ⊗ I)|ψini =

1
X

1
X

1
X

x=0

y=0

z=0

αx,y,z|¯x, y, zi, or

|ψouti = (I ⊗ X ⊗ I)|ψini =

|ψouti = (I ⊗ I ⊗ X)|ψini =

1
X

1
X

1
X

x=0

y=0

z=0

1
X

1
X

1
X

x=0

y=0

z=0

αx,y,z|x, ¯y, zi, or

αx,y,z|x, y, ¯zi,

(5.51)

where ¯x = 1 ⊕ x, ¯y = 1 ⊕ y, and ¯z = 1 ⊕ z. The ﬁrst state output |ψouti
corresponds to the case in which no bit ﬂip is applied by the channel;
the second to the case in which the ﬁrst qubit is ﬂipped; and so on. Note
that a bit ﬂip corresponds to a Pauli string with a single X operator in
the position corresponding to the qubit aﬀected by the ﬂip.

We refer to Sec. 5.8 for more discussion on quantum channels.

5.5.2 Quantum Coding

Let us assume that we have a qubit with an unknown state |ψi =
α0|0i + α1|1i, which we would like to protect against the bit-ﬂip channel
described in the previous subsection. Speciﬁcally, we would like to
encode this qubit in such a way that errors due to the channel can be
corrected. While duplication (cloning) is not possible, we can use the
“classical cloning”, or basis-copying, circuit introduced in Sec. 4.8. The
corresponding encoding circuit is shown in Fig. 5.3. Importantly, the
resulting encoded, entangled, state

α0|000i + α1|111i

(5.52)

is diﬀerent from a simple replica of the quantum state |ψi, which, by
the no cloning theorem, cannot be realized for any input state |ψi.

With this encoding circuit, the channel at hand can output one of

152

Generalizing Quantum Measurements (Part II)

|ψi = α0 |0i + α1 |1i

|0i

|0i

X

α0 |000i + α1 |111i

X

Figure 5.3: Quantum encoding for a quantum error correction scheme designed to
correct at most one bit ﬂip.

the following states |ψouti

|ψouti = α0|000i + α1|111i
|ψouti = α0|100i + α1|011i
|ψouti = α0|010i + α1|101i
|ψouti = α0|001i + α1|110i

if there is no error

if the ﬁrst qubit is ﬂipped

if the second qubit is ﬂipped

if the last qubit is ﬂipped.

5.5.3 Quantum Decoding via a Projective Measurement

Based on the discussion in the previous subsection, if there is no error,
the state lies in the two-dimensional space spanned by vectors |000i
and |111i. The projection matrix onto this subspace is given as

Π00 = |000ih000| + |111ih111|.

(5.53)

If the ﬁrst qubit is ﬂipped, the state lies instead in the two-dimensional
space spanned by vectors |100i and |011i, whose corresponding projec-
tion matrix is

Π10 = |100ih100| + |011ih011|.
Similarly, if the second qubit is ﬂipped, the state lies in the two-
dimensional space spanned by vectors |010i and |101i with projection
matrix

(5.54)

Π11 = |010ih010| + |101ih101|;
and, if the third qubit is ﬂipped, the state lies in the two-dimensional
space spanned by vectors |001i and |110i with projection matrix

(5.55)

Π01 = |001ih001| + |110ih110|.

(5.56)

5.5. Quantum Error Correction

153

The reason for the speciﬁc choice of the numbering of the projection
matrices given above will be made clear later.

Based on the observations in the previous paragraph, applying
the projective measurement {Π00, Π01, Π10, Π11} to the output of the
quantum channel |ψouti allows one to correct one bit ﬂip error by
applying a NOT gate, i.e., a Pauli X operator, to the ﬁrst, second, or
third qubit depending on the output of the measurement. Speciﬁcally,
if the output of the measurement is y = 00, no operation should be
applied; if it is y = 10, a NOT gate should be applied to the ﬁrst qubit;
and so on.

Crucially, the success of this operation in correcting a bit ﬂip hinges
on the use of a projective measurement. In fact, with a complete measure-
ment, the state of the qubits would “collapse”, destroying the encoded
superposition state α0|000i+α1|111i and hence losing information about
the original qubit state |ψi = α0|0i + α1|1i. In contrast, as we have
seen in Sec. 5.2, the projective measurement leaves unchanged quantum
states that lie within the subspace corresponding to each projection
matrix.

As detailed in this subsection, in order to apply error correction,
one should implement a Pauli X gate depending on the output of the
projective measurement {Π0, Π01, Π10, Π11}. To make this possible, it
is necessary to have both measurement output and post-measurement
state simultaneously encoded in the state of the quantum system. This
way, at the next computation step, the measurement output can be
used to determine the operation to be applied to the post-measurement
state. This is typically done by adding qubits, whose state encodes the
output y of the projective measurement. This will be discussed in the
next section.

5.5.4 Key Principles of Quantum Error Correction

To sum up the discussion so far, it is useful to reiterate and generalize
the principle underlying quantum error correction. Quantum error
correction aims at protecting an unknown state of k qubits – k = 1 in
the example above – by encoding such state into the state of n qubits
– n = 3 in the example. Note that the unknown original state lies in

154

Generalizing Quantum Measurements (Part II)

a Hilbert space of dimension 2k. As a result of encoding, the state of
the encoded qubit hence occupies a 2k-dimensional subspace in the 2n
Hilbert space corresponding to the n encoded qubits.

Encoding is designed in such a way that any possible distinct error
causes the state of the encoded qubits to lie in an orthogonal subspace
of dimension 2k. A projective measurement deﬁned by projectors onto
these orthogonal subspaces can thus distinguish among the diﬀerent
types of errors, while leaving the state within each subspace undisturbed.
If there are m diﬀerent errors – m = 3 in the example – the design
requirement outlined in the previous paragraph calls for a number of
encoded qubits, n, satisfying the condition
2n ≥ 2k(m + 1).
In fact, the Hilbert space of the encoded qubits should include m + 1
orthogonal subspaces, each of dimension 2k, with one subspace cor-
responding to the absence of errors on the channel and the others
accounting for each of the m types of errors.

(5.57)

In the example studied in this section, we have k = 1, n = 3, and
m = 3, which satisfy this condition with equality as 23 = 21(1 + 3) = 8.
When further elaborated on by accounting for all possible error types
on single qubits, the inequality (5.57) yields the so called quantum
Hamming bound.

5.5.5 Quantum Error Detection

As a less powerful alternative to quantum error correction, it is also
possible to design quantum error detection schemes, whereby errors
are only detected and not corrected. With error detection, one can
determine the presence of an error, without necessarily identifying, and
correcting, the speciﬁc error. With reference to the discussion in the
previous subsection, for quantum error detection, there is no need for
the m subspaces corresponding to diﬀerent errors to be orthogonal. In
fact, it is suﬃcient that all types of errors cause the post-channel state
to lie in the same subspace, as long as the latter is orthogonal to that
encompassing the encoded, noiseless, state.

To implement a quantum error detector, one can deﬁne an observable
that assigns the +1 eigenvalue to the “no-error” projection matrix Π0

5.6.

Implementing Projective Measurements with Ancillas

155

describing the subspace spanned by the code, and a −1 eigenvalue to
the subspace Π1 orthogonal to Π0. This way, if a measurement of the
observable returns −1, one can conclude with certainty that an error
has occurred, while, if the output is +1, the state can be concluded to
be unaﬀected by errors.

5.6 Implementing Projective Measurements with Ancillas

As we have discussed in the previous section, for some applications,
including quantum error correction, it is useful to have the output
of the measurement and the post-measurement state simultaneously
encoded in the state of separate quantum subsystems. This requires
adding to the system being measured a set of ancilla qubits, whose
state encodes the measurement output. We will hence refer to such
measurements as measurements with ancillas. In this section, we
describe how to implement measurements with ancillas, starting with the
case of complete measurements, and then generalizing the presentation
to projective measurements.

5.6.1 Complete Measurements with Ancillas

As we demonstrate in this subsection, we can implement a von Neumann
measurement with ancillas in any orthonormal basis {|v0i, |v1i, ..., |vN −1i}
for a system of n qubits (N = 2n) via the circuit shown in Fig. 5.4. The
circuit operates on the n qubits being measured – in an arbitrary state
|ψi – as well as on n ancilla qubits initialized in the ground state |0i.
The circuit in Fig. 5.4 ﬁrst applies the change-of-basis unitary Uvx→x
to the n qubits being measured as in Fig. 3.2. As detailed in Sec. 3.2.3,
this unitary maps each vector |vxi of the basis deﬁning the measurement
to the vector |xi in the computational basis. Unlike the circuit in Fig.
3.2, the ﬁrst set of n qubits are not directly measured. Rather, they are
“copied” via a basis-copying circuit to the second set of n qubits, i.e.,
to the ancilla qubits. The ancilla qubits are measured, and ﬁnally the
inverse change-of-basis transformation Ux→vx
is applied to the ﬁrst n
qubits. We recall from Sec. 4.8 that the basis-copying transformation is

156

Generalizing Quantum Measurements (Part II)

n

n

|ψi

|0i

Uvx→x

Ux→vx

|vxi

UBC

x

|xi

Figure 5.4: von Neumann measurement in an arbitrary orthonormal basis
{|v0i, |v1i, ..., |vN −1i} with ancillas. The ancillas qubits are the second set of n
qubits, which are initialized to the ground state |0i. Unlike the circuit in Fig. 3.2,
this architecture produces both the post-measurement state |vxi for the ﬁrst n qubits
and the output of the measurement, x ∈ {0, 1, ..., 2n − 1}, with the latter encoded in
the post-measurement state |xi of the n ancilla qubits.

deﬁned as

UBC =

N −1
X

N −1
X

x=0

y=0

|x, x ⊕ yihx, y|,

(5.58)

where {|yi}N −1
represents the computational basis for the Hilbert space
y=0
of the ancillas. The unitary UBC has the eﬀect of “cloning” the vectors
in the computational basis from the ﬁrst n qubits to the ancillas.

For an arbitrary pure state |ψi = PN −1
x=0 αx|vxi of the n qubits being
measured, and hence a global state PN −1
x=0 αx|x, 0i after the change-of-
basis transformation Uvx→x, the basis-copying unitary operator yields
the state

UBC(Uvx→x ⊗ I)

N −1
X

x=0

αx|vx, 0i =

N −1
X

x=0

αx|x, xi.

(5.59)

Therefore, by the generalized Born rule, measuring the ancillas yields the
post-measurement state |x, xi with probability |αx|2. Finally, this pro-
duces the state |vx, xi after the inverse change-of-basis transformation
Ux→vx

.

This calculation demonstrates that the architecture in Fig. 5.4 imple-
ments a von Neumann measurement in the basis {|v0i, |v1i, ..., |vN −1i}.
In fact, the circuit in the ﬁgure leaves the ﬁrst subsystem of n qubits
in the post-measurement state |vxi with probability |αx|2 = |hψ|xi|2.
Furthermore, the output of the measurement, x ∈ {0, 1, ..., 2n − 1} is
encoded in the post-measurement state |xi of the n ancilla qubits.

5.6.

Implementing Projective Measurements with Ancillas

157

5.6.2 Projective Measurements with Ancillas

We now generalize the architecture in Fig. 5.4 to the balanced projective
measurements introduced in Sec. 5.4. To proceed, we focus here on the
class of partial measurements of n0 qubits in the computational basis,
since, as seen in Sec. 5.4.2, by adding suitable pre- and post-measurement
transformations, one can implement a general balanced measurement
from such partial measurements. We will provide an example of this
procedure at the end of this subsection.

A partial measurement of n0 qubits in the computational basis can
be implemented via a generalization of the architecture introduced in
the previous subsection whereby only the second set of n0 qubits, whose
state is to be measured, are “copied” via a basis-copying circuit to the
ancillas.

Speciﬁcally, the measurement involves the introduction of n0 ancilla
qubits, which are used to encode the output index y ∈ {0, 1, ..., 2n0 − 1}.
A basis-copying unitary “copies” only the second set of n0 qubits as
controlling qubits onto the n0 ancillas. This amounts to a unitary
transformation that maps each vector |xi ⊗ |yi ⊗ |0i = |x, y, 0i – with
x ∈ {0, 1, ..., 2n−n0 − 1}, y ∈ {0, 1, ..., 2n0 − 1}, and |0i being the initial
ground state of the n0 ancillas – into the state |x, y, yi.

As an example, consider again the parity measurement {Π0, Π1}
introduced in Sec. 5.2.8. Since there are only two values for the mea-
surement (n0 = 1), it is suﬃcient add a single ancilla qubit. As detailed
in Sec. 5.4.3, in order to implement this measurement, one can pre-
and post-process the state to be measured with the change-of-basis
unitaries illustrated in Fig. 5.2. Accordingly, as depicted in Fig. 5.5, the
ﬁrst step is to apply a CNOT gate to the two qubits being measured,
which are initially in state |ψi. Then, one applies a basis-copying circuit
from the second qubit to the ancilla, followed by a measurement of the
ancilla. Note that the basis-copying circuit also amounts to a CNOT
gate. Finally, the initial change-of-basis unitary is inverted with a last
CNOT gate. It can be directly checked that the circuit in Fig. 5.5 indeed
produces the output y and corresponding post-measurement state with
the probability (5.19)-(5.20).

The outlined general approach to implement projective measure-

158

Generalizing Quantum Measurements (Part II)

|ψi

|0i

X

X

√

Πy|ψi
hψ|Πy|ψi

y

X

|yi

Figure 5.5: An ancilla-based implementation of the parity measurement introduced
in Sec. 5.2.8.

|ψi

√

Πy|ψi
hψ|Πy|ψi

|0i

X

X

|yi

y

Figure 5.6: An equivalent implementation of the parity measurement with ancilla.
Unlike the equivalent circuit in Fig. 5.5, here the ancilla qubit – initialized in the
ground state – computes the parity of the two qubits being measured, separately for
each computational basis state, via the two CNOTs.

ments with ancillas may not necessarily provide the most eﬃcient circuit.
For example, for the parity measurement discussed in the last paragraph,
the circuit in Fig. 5.5 can be seen to be equivalent to that in Fig. 5.6,
which requires only two CNOT gates. The operation of the circuit in Fig.
5.6 has the interesting interpretation that the ancilla qubit computes
the parity – separately on each computational basis state – of the two
qubits being measured via the two CNOT gates. In fact, if the two
qubits being measured are in state |x, yi, with x, y ∈ {0, 1}, the state
of the ancilla qubit after the two CNOT gates is |x ⊕ yi.

5.6.3 Application to Quantum Error Correction

Let us now return to the problem of designing a decoding circuit for
the quantum error correction code introduced in Sec. 5.5. As we have
seen in Sec. 5.5.3, the decoder carries out the projective measurement
{Π00, Π01, Π10, Π11} with projection matrices in (5.53)-(5.56). According
to the discussion in this section, this measurement can be implemented

5.7. Positive Operator-Valued Measurements

159

by introducing two ancilla qubits (n0 = 2), since there are four possible
outcomes. The resulting circuit is illustrated in Fig. 5.7, and is detailed
next.

Generalizing the circuit in Fig. 5.6, the decoder takes as input the
post-channel state, and computes the parity – in the computational
basis – of the ﬁrst and second pair of qubits in the post-channel state.
Speciﬁcally, the ﬁrst ancilla qubit measures the parity of the ﬁrst pair,
and the second ancilla qubit of the second pair. The outputs (y0, y1) ∈
{0, 1}2 of the measurement of the ancillas (in the computational basis)
are then used to determine whether an X gate should be applied to the
any of the three input qubits. Since it is used to “diagnose” the type of
error that may have occurred on the encoded qubits, the output of the
measurement of the ancillas is referred to as the error syndrome.

The advantage of introducing the ancillas in the circuit of Fig. 5.7
is that their post-measurement state encodes the transformation to
be applied to the ﬁrst three qubits to ensure error correction. In this
regard, note that the shortcut notation X ab in Fig. 5.7 indicates that
an X gate is applied when a = b = 1, recovering the decoding rule
described in Sec. 5.5. Accordingly, as long as the channel applies at
most one bit ﬂip, the corrected state |ψcorri equals the encoded state
|ψini = α0|000i + α1|111i.

In closing this subsection, we note that it is also possible to im-
plement quantum error correction without an explicit measurement of
the ancillas through the use of three-qubit gates, namely Toﬀoli gates.
Furthermore, when the goal is recovering the original qubit, and not
the encoded state, it is also possible to avoid using ancilla qubits.

5.7 Positive Operator-Valued Measurements

As we have studied in the previous section, general projective mea-
surements can be implemented by adding ancillas in ground state |0i,
applying an entangling operator, namely the basis-copying circuit, and
then measuring the ancillas. In this section, we address the following
question: What if we applied a more general entangling operator, i.e.,
an arbitrary unitary matrix, to the overall system including the ancillas,
and then measured the ancillas (in a selective way)? As we will detail,

160

Generalizing Quantum Measurements (Part II)

X y0 ¯y1

X y0y1

|ψcorri

X ¯y0y1

|ψouti

X

X

|0i

|0i

X

X

y0

y1

Figure 5.7: Decoder for the quantum error correction code described in Sec. 5.5.
The decoder uses the output of the measurement encoded in the state of the two
ancilla qubits (the last two qubits) in order to determine the operation to be applied
on the encoded qubits (the ﬁrst three qubits) at the next computation step.

this leads to the most general form of (selective) measurements, namely
positive operator-valued measurement (POVM).

5.7.1 Deriving POVM Measurements

To derive POVMs, let us consider a system of n qubits with the addition
of n0 ancillas. The ancillas are initially in the ground state |0i. If the
system of n qubit is in state |ψi, the overall system is hence in the state
|0, ψi = |0i ⊗ |ψi. Note that, unlike what we have done in the rest of
this chapter, here we append the ancillas in front of the n-qubit state
in order to simplify the derivations that follow. The setting under study
is illustrated in Fig. 5.8.

Applying a unitary matrix U to the overall system results in the

state

U |0, ψi =









U00
U10
...

U01
U11
...

· · ·
· · ·

U0,N 0−1
U1,N 0−1
...

UN 0−1,0 UN 0−1,1

· · · UN 0−1,N 0−1

























,

|ψi
0
...
0

(5.60)

where the matrices Ukm, with k, m ∈ {0, 1, ..., N 0 − 1}, are of size N × N ,

5.7. Positive Operator-Valued Measurements

161

y

w.p. tr(Myρ)

|0i

ρ

U

Figure 5.8: A POVM describes a situation in which the system of interest interact
through a unitary U with ancilla qubits, initially in the ground state |0i, and then
the ancillas are measured (in a selective manner).

with N = 2n, and we set N 0 = 2n0. It follows that the output of the
unitary operation is

U |0, ψi =









U00|ψi
U10|ψi
...
UN 0−1,0|ψi









N 0−1
X

=

y=0

|yi ⊗ Uy0|ψi.

(5.61)

Furthermore, by the unitarity of matrix U , i.e., by the equality U †U = I,
we have the condition

N 0−1
X

y=0

U †
y0Uy0 = I,

(5.62)

where I is the N × N identity matrix.

Now, if we measure the ancillas in the computational basis, by the

generalized Born rule, we get

Pr[measurement output equals y] = hψ|U †

y0Uy0|ψi

= tr(Myρ),

(5.63)

where we have deﬁned matrix My = U †
ρ = |ψihψ|. Furthermore, the post-measurement (density) state is

y0Uy0 and the density matrix

Uy0ρU †
y0
tr(Myρ) .

(5.64)

5.7.2 Deﬁning a POVM

Generalizing the derivation above, a POVM is deﬁned by a set of N × N
positive semideﬁnite matrices My with y ∈ {0, 1, ..., N 0 − 1}, with N 0

162

Generalizing Quantum Measurements (Part II)

generally diﬀerent from N and possibly larger than N , such that the
following condition – from (5.62) – applies

N 0−1
X

y=0

My = I.

(5.65)

A POVM stipulates that output y is observed with probability

Pr[measurement output equals y] = tr(Myρ).

(5.66)

The post-measurement state is not uniquely speciﬁed by a POVM
. However, by taking the positive semidef-

deﬁned by matrices {My}N 0−1
y=0
inite square root of My, i.e.,

M 1/2
y

=

N −1
X

q

x=0

λx,y|vx,yihvx,y|

(5.67)

where My = PN −1
typically sets the post-measurement state to the density matrix

x=0 λx,y|vx,yihvx,y| is the eigendecomposition of My, one

M 1/2

y ρM 1/2
y
tr(Myρ)

.

(5.68)

POVMs generalize projective measurements, which are obtained by
choosing the positive semideﬁnite matrices My as projection matrices,
i.e., by setting My = Πy (note that we have Π1/2
y = Πy). We observe
that, in a projective measurement, the matrices My = Πy are mutually
orthogonal, in the sense that we have the equalities Π†
Πy0 = ΠyΠy0 = 0,
y
where 0 is an all-zero matrix, for all y0 6= y; and the are idempotent as
they satisfy the condition ΠyΠy = Πy. In contrast, in a more general
POVM, matrices My are only constrained to be positive semideﬁnite
and to satisfy condition (5.65). Therefore, they may not be mutually
orthogonal or individually idempotent.

5.7.3 POVM for Unambigous Quantum State Discrimination

In this subsection, we study an application of POVMs by focusing on
quantum state detection. To this end, assume that, unbeknownst to us,
the state of a quantum system can be either |ψ0i or |ψ1i. If the vectors

5.7. Positive Operator-Valued Measurements

163

|ψ0i and |ψ1i are orthogonal, it is possible to distinguish them exactly
(with probability 1) by using the standard von Neumann measurement
deﬁned by the projection matrices

Π0 = |ψ0ihψ0|
Π1 = |ψ1ihψ1|
Π2 = I − Π0 − Π1.

(5.69)

Note that if the system consists of a single qubit, the third projection
matrix Π2 is not necessary. If the true state is |ψyi, with y ∈ {0, 1},
this measurement indeed returns y with probability tr(Πy|ψyihψy|) = 1.
What if states |ψ0i and |ψ1i are not orthogonal?

In this case, we can design a POVM such that, whenever a decision
is made, the decision is correct; but it is allowed for the measurement
to return a “don’t know” decision. To this end, consider the POVM

M0 = a(I − |ψ1ihψ1|)
M1 = a(I − |ψ0ihψ0|)
M 2 = I − M0 − M1,

(5.70)

where a = (1 + |hψ0|ψ1i|)−1.

By (5.66), if the true state is |ψ0i, the measurement returns y = 0

with probability

tr(M0|ψ0ihψ0|) = ahψ0|(I − |ψ1ihψ1|)|ψ0i

= a · (1 − |hψ0|ψ1i|2) = 1 − |hψ0|ψ1i|;

(5.71)

it returns y = 1 with probability

tr(M1|ψ0ihψ0|) = ahψ0|(I − |ψ0ihψ0|)|ψ0i

= a · (1 − 1) = 0;

and “don’t know”, i.e., y = 2, with probability

tr(M2|ψ0ihψ0|) = |hψ0|ψ1i|.

(5.72)

(5.73)

A similar situation occurs if the true state is |ψ1i.

We conclude that, with the designed POVM, there is no ambiguous
detection, but a “declaration of ignorance” with probability |hψ0|ψ1i|:

164

Generalizing Quantum Measurements (Part II)

The more aligned the two vectors are, the more likely it is that the
detector will not be able to make a deﬁnite decision.

Importantly, in order to obtain unambiguous state discrimination as
described in this section, it is necessary to use a POVM and projective
measurements are not suﬃcient. To see this, consider the special case
of single-qubit states |ψ0i and |ψ1i. A projective measurement in this
setting could only produce one of two outputs, ruling out the possibility
to include a “don’t know” decision.

5.8 Quantum Channels

In the previous section we have introduced POVMs – the most general
form of quantum measurement – by studying the setting in Fig. 5.8. In it,
the quantum system of interest, encompassing n qubits in some state ρ,
interacts with n0 ancilla qubits through a general unitary transformation
U , and then a selective measurement is made on the ancillas. Following
the discussion in Sec. 3.4, the ancilla qubits may model the environment
in which the quantum computer of n qubits operates. In this case, the
unitary U accounts for the unwanted, entangling, interactions with the
environment. Furthermore, the fact that the quantum computer does
not have access to the environment can be accounted for by assuming
that the ancillas, rather than being measured selectively as in Fig. 5.8,
are measured non-selectively as shown in Fig. 5.9.

The setting in Fig. 5.9 – in which the system of interest interacts
with “environment” qubits, initially in the ground state |0i, through a
unitary and then the environment qubits are measured non-selectively
– deﬁnes a quantum channel. Quantum channels are used to model
the impact of noise due to decoherence in quantum computers (see Sec.
3.4). More broadly, as we will further discuss in this section, quantum
channels represent general quantum operations on a quantum state ρ
that do not involve selective measurements.

5.8. Quantum Channels

165

|0i

ρ

U

trash

Figure 5.9: A quantum channel can be described as a setting in which the quantum
system of interest, consisting of n qubits, interacts with n0 ancilla, or “environment”,
qubits via a unitary U . The fact that the system does not have access to the
environment is modelled via a non-selective measurement of the ancillas (i.e., the
output of the measurement is discarded).

5.8.1 Deﬁning Quantum Channels

From Sec. 5.7, we know that the state at the output of the unitary U
in Fig. 5.9 is given by (5.61), which we rewrite here for convenience as

N 0−1
X

y=0

|yi ⊗ Ky|ψi,

(5.74)

where we have N 0 = 2n0 and the N × N matrices Ky satisfy condition
(5.62), i.e.,

N 0−1
X

y=0

K†

yKy = I.

(5.75)

Unlike Sec. 5.7, we now perform a non-selective measurement of the
ancillas. The outcome of this operation on the n qubits of interest can
be formally described by the partial trace operation introduced in Sec.
3.6.

Before applying the partial trace, let us follow an equivalent and
more direct argument by assuming that the ancillas are measured in the
computational basis {|yi}N 0−1
. Recall from Sec. 3.6 that the impact of
y=0
a non-selective measurement on the rest of the system does not depend
on the speciﬁc choice of the orthonormal basis. By the generalized Born
rule, from (5.74), we obtain the post-measurement state Ky|ψi/
py
with probability py = hψ|K†
yKy|ψi for the system of n qubits. It follows
that, from the viewpoint of the system of interest, which does not
have access to the measurement outcome y, the state of the system is

√

166

Generalizing Quantum Measurements (Part II)

described by the density matrix

ρout =

=

2n0
−1
X

y=0
2n0
−1
X

y=0

py

Ky|ψihψ|K†
y
py

KyρK†
y,

(5.76)

with ρ = |ψihψ|.

This result can also be obtained by tracing out the ancillas – denoted
as A – to account for the non-selective measurement of the ancillas in
Fig. 5.9. In fact, using the deﬁnition (3.42) of partial trace, we compute
the output state as

ρout = trA(U (|0ih0| ⊗ ρ)U †)

=

=

2n0
−1
X

(hy| ⊗ I)(U (|0ih0| ⊗ ρ)U †)(|yi ⊗ I)

y=0
2n0
−1
X

y=0

KyρK†
y,

(5.77)

(5.78)

where we have used the equality Ky = Uy0 = (hy| ⊗ I)U , which follows
from (5.61).

To summarize, a quantum channel operating on n qubits is deﬁned
, for some integer r, which satisfy

by a set of 2n × 2n matrices {Ky}r−1
y=0
the property (5.61), restated here as

r−1
X

y=0

K†

yKy = I.

(5.79)

The matrices Ky are known as Kraus matrices. Given an input state
ρ, the output state produced by a quantum channel deﬁned by Kraus
matrices {Ky}r−1
y=0

is given as

ρout =

r−1
X

y=0

KyρK†
y

= N (ρin),

(5.80)

where the notation N (·) is often used to describe the operation of the
channel.

5.8. Quantum Channels

167

By (5.80), one can intuitively think of a quantum channel as a quan-
tum operation that modiﬁes the input density ρ to the (unnormalized)
density KyρK†
with probability py. Therefore, each Kraus matrix Ky
y
can be interpreted as a diﬀerent type of error that the channel causes
on the quantum state ρ. Unless we have r = 1, quantum channels
are generally irreversible, as they describe situations in which the
system gets entangled with the “environment” causing information to
be irretrievably lost.

5.8.2 Quantum Channels as CPTP Operators

An equivalent way to deﬁne a quantum channels ρout = N (ρ) is as
follows. A quantum channel is a mapping ρout = N (ρ) from a density
matrix ρ to a matrix ρout that is linear, completely positive (CP),
and trace preserving (TP). Therefore, quantum channels are also
referred to as CPTP operators. Linearity is evident from the char-
acterization (5.80). The TP property requires that the output state
has unitary trace, i.e., tr(ρout) = 1 – a necessary condition since the
output ρout must be a density matrix. This property can be directly
proved based on the condition (5.79). Finally, the CP condition means
that, when applied on a subset of a larger system, the quantum channel
yields a valid density, and hence a positive semideﬁnite matrix, for the
whole system. This is a necessary condition to guarantee that, if the
channel is applied to only to some qubits of a system, the resulting
output matrix is still a valid density state.

5.8.3 Examples of Quantum Channels

Quantum channels, i.e., CPTP operators, include all quantum operations
that do not involve a selective measurement, including trace and partial
trace. In fact, CPTPs and POVMs – with the latter used to describe
selective measurements – exhaust the set of all possible operations that
can be applied to a quantum system. Examples of quantum channels
include the following.
• Quantum state preparation: This is the process of preparing a
quantum ensemble {px, |vxi}, i.e., a density matrix ρout = P
x px|vxihvx|.

168

Generalizing Quantum Measurements (Part II)

p0I, K1 = √

p1X, K2 = √

px|vxi, yielding the output state ρout = P

It can be described as a quantum channel with input ρ = 1 and Kraus
operators Kx = √
x px|vxihvx|.
• Pauli channels: Pauli channels are single-qubit channels that have
Kraus matrices
K0 = √
for pk ≥ 0 with P3

p2Y, K3 = √
k=0 pk = 1, yielding the output state
ρout = p0ρ + p1XρX + p2Y ρY + p3ZρZ.
Single-qubit channels are practically important since most error models
in quantum computing assume independent errors across qubits. Pauli
channels make particularly clear the interpretation mentioned above of
individual Kraus operators as describing the diﬀerent types of errors
that can occur on a qubit. In particular, in a Pauli channel, the diﬀerent
types of errors correspond to the application of X, Y, or Z operators to
the qubit.

(5.82)

(5.81)

p3Z,

Pauli channels specialize to some important subclasses of channels,
such as the bit-ﬂip channel and the dephasing channel. The bit-ﬂip
channel applies X errors with some probability p, i.e.,

ρout = (1 − p)ρ + pXρX,
where we can assume without loss of generality p ≤ 0.5. (Otherwise, we
can apply an X operator to ρ to guarantee this condition.) In contrast,
dephasing channels apply Z errors with probability p ≤ 0.5, i.e.,

(5.83)

ρout = (1 − p)ρ + pZρZ.

(5.84)

5.9 Conclusions

In this chapter, we have extended the formalism of quantum mea-
surements to projective measurements and to POVMs, with the latter
providing the most general form of quantum measurement. Throughout,
we have emphasized quantum circuits that can implement such measure-
ments via standard measurements in the computational basis. We have
also highlighted two important applications: quantum error correction
for projective measurements and quantum detection for POVMs. Finally,
we have studied a general form of non-selective measurements, leading
to the deﬁnition of quantum channels.

5.10. Recommended Resources

169

5.10 Recommended Resources

Projective measurements and POVMs are well explained in [3], [7].
Quantum error correction is a vast ﬁeld, and the books [1], [3] provide
excellent introductions. Quantum communications and networking are
covered by [7], [12].

5.11 Problems

1. Argue that, in order to implement a “gentle” projective measure-
ment that leaves non-trivial subspaces of pre-measurement states
unchanged, it is necessary to have n ≥ 2 qubits.

2. For an observable O and two states |ψi = P
x

√

px|xi and ρ =

P

x px|xihx|, show the relationship
hOi|ψi = hOiρ + X

√

pxpyhx|O|yi.

(5.85)

Interpret this equality.

x,y:x6=y

3. Consider the observables X ⊗ X, Y ⊗ Y , and Z ⊗ Z, and show
that the numerical outputs of their observations can be obtained
by using either local measurements or joint measurements in the
Bell basis.

4. Derive the projective measurement that has the minimum error
probability for the problem of distinguishing between two density
states ρ0 and ρ1.

5. Describe the measurement-based deﬁnition of the quantum entropy

(see recommended resources).

6. Derive a necessary condition on the numbers k, n, and m of
information qubits, encoded qubits, and types of errors, that is
required for quantum error detection.

7. Describe a circuit that measures the observable X ⊗ X in a system
with two qubits. Consider the implementation involving only the
two qubits, as well as the implementation that includes ancilla
qubits.

170

Generalizing Quantum Measurements (Part II)

8. Describe a quantum error correction code, including encoder and
decoder, for the channel that may ﬂip the phase of at most one
out of three qubits. A phase ﬂip corresponds to the application of
a Pauli Z operator. [Hint: Phase ﬂips correspond to bit ﬂips with
a suitable change of basis.]

9. Prove that the circuit in Fig. 5.1 implements a balanced projective
measurement by calculating the probability of obtaining output
y, as well as the corresponding post-measurement state.

10. Given a state a|00i + b|11i with real numbers a ≥ b > 0 such
that the equality a2 + b2 = 1 holds, show that with probabil-
ity 2b2 the POVM described by positive semideﬁnite matrices
M0 = b2/a2|0ih0| + |1ih1| and M1 = I − M0 produces as post-
measurement state (5.68) a fully entangled state.

11. Show that repeating a projective measurements returns the same
result of the ﬁrst measurement with probability 1 (when condi-
tioned on the output of the ﬁrst measurement), while this is not
the case for more general POVMs.

12. Prove that a quantum channel is trace preserving.

13. Explain the following statement: A noiseless quantum channel is
given by the unitary transformation U = P2n−1
x=0 |xihx|, while a
noiseless classical channel is a noisy quantum channel with Kraus
operators Kx = |xihx| for x ∈ {0, 1, ..., 2n − 1}.

6

Quantum Machine Learning

6.1 Introduction

In this chapter, we introduce the topic of quantum machine learning.
We start by presenting a taxonomy of approaches, and proceed by
reviewing the key concepts of parametrized quantum circuit (PQC) and
ansatz. We then describe the general form of cost functions optimized
in quantum machine learning, which depend on the expected values of
observables. With this background, as a preliminary step, we describe
the variational quantum eigensolver (VQE), which is presented as a tool
to address a speciﬁc class of combinatorial problems. VQEs share with
quantum machine learning techniques the main driving idea of using
classical optimization to minimize the expectation of an observable as
the cost function. We then overview probabilistic and deterministic
machine learning models obtained from PQCs, with applications to
unsupervised generative learning, as well as to supervised learning for
regression and classiﬁcation tasks. We conclude with further discussions
regarding the choice of the PQC and the problem of data encoding onto
quantum states, ending with some considerations on future directions
for research.

171

172

Quantum Machine Learning

6.2 What is Quantum Machine Learning?

Quantum computing algorithms, including the techniques reviewed in
Chapter 4, have been traditionally designed by hand without imposing
restrictions on the number and on the reliability of qubits, quantum
gates, and quantum measurements. In practice, current quantum com-
puters support a few tens of qubits, and projections are that in the near
term the number of qubits will not exceed around 1000. Furthermore,
quantum state preparation, quantum gates, and quantum measurements
in real quantum computers are subject to decoherence and noise (see
Sec. 3.4 and Sec. 5.8). This makes it necessary to implement forms of
quantum error correction in order to emulate the noiseless operation
assumed by formally designed quantum algorithms. And this, in turn,
further increases the number of necessary physical qubits to ensure the
desired level of reliability (see Sec. 5.5).

Against this backdrop, quantum machine learning refers to an
alternative design paradigm, illustrated in Fig. 6.1, based on the in-
tegration of a small-scale quantum circuit with a classical optimizer.
Like classical machine learning, quantum machine learning follows an
inductive methodology based on the following two-step approach:

• Selection of the architecture of a parametric quantum cir-
cuit (PQC), also known as ansatz: The designer ﬁrst selects
the architecture of a PQC by specifying a sequence of parametrized
quantum gates. Parametrized quantum gates may, for instance,
include Pauli rotations whose angles are treated as free parame-
ters that can be optimized. Overall, the operation of the PQC is
deﬁned by a unitary matrix U (θ), which is dependent on a vector
of free parameters θ. The choice of the PQC should be ideally
dictated by knowledge available to the designer about quantum
algorithmic architectures that are well suited for the problem
at hand. The step of selecting a PQC architecture mirrors the
problem of choosing a neural network architecture in classical
machine learning.

• Parametric optimization: The PQC implementing the unitary
U (θ) is connected to a classical optimizer. The optimizer is fed

6.2. What is Quantum Machine Learning?

173

Figure 6.1: A high-level description of the quantum machine learning design
methodology. A parametric quantum circuit (PQC) implementing a unitary matrix
U (θ) is optimized via its vector of parameters, θ, based on measurements of the
output of the PQC.

measurements of the quantum state produced by the PQC, typ-
ically in the form of estimated expectations of observables; and
it produces updates to the parameter vector θ. The updates are
aimed at minimizing some cost function, which may depend also
on training data. This parametric optimization step is common to
the classical machine learning methodology, in which the model
parameters θ are optimized via gradient descent-based methods
by targeting the minimization of the training loss.

As mentioned in the Preface, the quantum machine learning frame-
work depicted in Fig. 6.1 has a number of potential advantages over
the standard approach of handcrafting quantum algorithms assuming
fault-tolerant quantum computers:

• By keeping the quantum computer in the loop, the classical opti-
mizer can directly account for the non-idealities and limitations
of the available quantum resources.

• If the PQC U (θ) is suﬃciently ﬂexible and the classical optimizer
suﬃciently eﬀective, the approach may automatically design well-
performing quantum algorithms that would have been hard to
conceive “by hand” through a formal design methodology.

classical optimizeraverage174

Quantum Machine Learning

data processing

C

data

C

CC

generation Q QC

Q

CQ

QQ

Table 6.1: Taxonomy of machine learning settings as a function of the type of data
and processing (C=classical, Q=quantum).

6.3 A Taxonomy of Quantum Machine Learning

Unlike classical machine learning, in which data and processing are
classical, in quantum machine learning data and/or processing are
quantum. The four possible scenarios are summarized in Table 6.1, and
are reviewed in this section.

The classical data and classical processing (CC) case pre-
scribes the optimization of a standard machine learning model, e.g., of
a neural network, via a classical optimizer. As illustrated in Fig. 6.2,
a classical machine learning model implements a parametrized func-
tion h(x|θ) mapping classical input data x to an output. The classical
optimizer minimizes a cost function dependent on classical data over
vector θ. For example, in supervised learning, classical data consist of
pairs of inputs x and corresponding desired outputs y. Moreover, the
cost function is given by the training loss, which measures how well
the predictions of the outputs produced by function h(x|θ) match the
desired outputs y in the available data.

Currently, the most common quantum machine learning setting is
characterized by classical data and quantum processing (CQ).
Taking the case of supervised learning as an example, as illustrated in
Fig. 6.3, a quantum model is typically deﬁned by a PQC that implements
a unitary transformation U (x, θ). The unitary U (x, θ) depends on both
classical input x and model parameter vector θ. The input to the PQC
is a set of qubits in the ground state |0i, and the output state produced
by the PQC is given by

|ψ(x, θ)i = U (x, θ)|0i.

(6.1)

6.3. A Taxonomy of Quantum Machine Learning

175

Figure 6.2: An illustration of classical machine learning, in which both data and
processing are classical.

The output state (6.1) is also known as quantum embedding of the
classical data x, as it encodes the classical input x into a quantum
state. The measurement output, possibly after averaging, encodes the
model’s prediction of the target variable y. The classical optimizer
minimizes some cost function over the model parameter vector θ, which
measures how well the output of the measurement of the quantum state
(6.1) matches the target y. The cost function is expressed in terms of
the expectation of an observable for the quantum embedding |ψ(x, θ)i.
Estimating the expectation of the given cost-deﬁning observable requires
running the PQC multiple times in order to evaluating an empirical
average.

As illustrated in Fig. 6.4, with quantum data and classical
processing (QC), the learner has access to quantum data. Quantum
data consist of a collection of quantum systems, whose state is described
by a density matrix. Quantum data may be produced by a quantum
sensor and stored in a quantum memory – with both quantum sensing
and quantum storage being two active areas of research. In the QC case,
quantum data are ﬁrst measured, and then the classical measurement
outputs are processed by a classical machine learning model. QC machine
learning may be applied to quantum tomography, which is the problem
of inferring properties of a quantum state based on measurement results.
In the quantum data and quantum processing (QQ) case, as

classical optimizerclassical dataclassical data176

Quantum Machine Learning

Figure 6.3: An illustration of the “CQ” setting of quantum machine learning, in
which data are classical and processing is quantum.

Figure 6.4: An illustration of the “QC” setting of quantum machine learning, in
which data are quantum and processing is classical.

classical optimizeraverageclassical dataclassical dataclassical optimizerclassical dataquantum dataaverage6.4. Ansatz and Parametrized Quantum Circuits

177

Figure 6.5: An illustration of the “QQ” setting of quantum machine learning, in
which data are quantum and processing is quantum.

depicted in Fig. 6.5, quantum data are processed by a PQC. The cost
function is evaluated within the quantum computer by comparing, using
a suitable quantum circuit (see, e.g., Sec. 3.2.5), the output of the PQC
with target quantum data. An instance of QQ machine learning is
given by quantum generative adversarial networks, in which the
quantum loss is computed via a detector that attempts to distinguish
real quantum data from quantum states generated by the PQC. Another
example is provided by quantum variational autoencoders, which
aim at compressing a quantum state into a smaller set of qubits. We refer
to the recommended resources (Sec. 6.12) for pointers to the literature.
In this chapter, we will focus exclusively on the CQ case, which is
better studied and potentially more suitable for near-term engineering
applications. That said, the discussion in the next section regarding
PQCs is also relevant for the QQ solutions.

6.4 Ansatz and Parametrized Quantum Circuits

As discussed in the previous section, at the core of quantum machine
learning methods are PQCs, which are the topic of this section.

A PQC implements a unitary transformation U (θ) whose operation
on n qubits depends on a tunable (classical) parameter vector θ consist-
ing of D real numbers. As seen in the previous section, in the CQ case,

classical optimizeraverageclassical dataquantum dataquantumloss178

Quantum Machine Learning

the unitary may also depend on input data x, and we will discuss this
situation in the context of supervised learning in Sec. 6.8. The unitary
U (θ) is typically speciﬁed as a sequence of one- or two-qubit gates, with
each gate possibly dependent on the parameter θ.

The choice of the PQC architecture as a sequence of speciﬁc gates is
akin to the choice of the model class in classical machine learning, e.g.,
of a neural network architecture. In quantum machine learning, we refer
to the architecture of the PQC as the ansatz. The term comes from the
German word used for “approach” or “attempt”. As for the model class
in machine learning, one should choose the ansatz, if possible, based
on domain knowledge. For instance, in quantum chemistry problems,
there are known algorithmic structures that are known to reﬂect well
the nature of certain phenomena.

In the rest of this section, we review typical ansatzes by proceeding in
order of complexity, and hence also of expressivity, of the resulting PQC.
Speciﬁcally, we ﬁrst review parametrized single-qubit gates and the
mean-ﬁeld ansatz; then we describe the more complex hardware-eﬃcient
ansatz; and ﬁnally we discuss parametrized multi-qubit gates.

6.4.1 Parametrized Single-Qubit Gates

The most common type of parametrized quantum gates is given by
single-qubit Pauli rotation matrices. A Pauli P -rotation matrix
RP (θ), with P ∈ {X, Y, Z}, is a unitary matrix whose generator is given
by θ/2 · P , i.e.,

RP (θ) = exp

(cid:18)

−i

(cid:19)

θ
2 P

= cos

(cid:19)

(cid:18) θ
2

I − i sin

(cid:19)

(cid:18) θ
2

P,

(6.2)

where θ is a real parameter (see Sec. 1.4.5 and Appendix A). The
parameter θ is also known as the rotation angle for the gate RP (θ).
The three Pauli rotations are summarized in Table 6.2.

By (6.2), we have the equalities

RX (−π) = iX,

RY (−π) = iY,

(6.3)

(6.4)

6.4. Ansatz and Parametrized Quantum Circuits

179

Pauli rotation

deﬁnition

RX (θ)

RY (θ)

RZ(θ)

exp (cid:0)−i θ

2 X(cid:1) =

exp (cid:0)−i θ

2 Y (cid:1) =
(cid:20) cos (cid:0) θ
2

exp (cid:0)−i θ

2 Z(cid:1) =

2

(cid:1)

−i sin (cid:0) θ
2
(cid:1)
cos (cid:0) θ
2
(cid:1) − sin (cid:0) θ
(cid:1)
2
(cid:1)
cos (cid:0) θ
(cid:1)
2

(cid:1)

(cid:21)

(cid:21)

(cid:20)

cos (cid:0) θ
(cid:1)
2
−i sin (cid:0) θ
(cid:20) cos (cid:0) θ
2
sin (cid:0) θ
2
(cid:1) − i sin (cid:0) θ

2

0

(cid:1)

0

(cid:21)

cos (cid:0) θ
2

(cid:1) + i sin (cid:0) θ

2

(cid:1)

Table 6.2: Single-quit Pauli rotations are the most commonly used parametrized
gates.

and

RZ(−π) = iZ.

(6.5)

Therefore, apart from a global phase, the Pauli rotations recover as
special cases, i.e., for a speciﬁc choice of the rotation angle θ, the Pauli
gates X, Y , and Z.

A general parametrized single-qubit gate can be expressed,
apart from a global phase, as the following cascade of two types of Pauli
rotations

R(θ1, θ2, θ3) = RP (θ1)RP 0(θ2)RP (θ3),

(6.6)

where P 0 6= P with P, P 0 ∈ {X, Y, Z}. A typical choice is P = Z and
P 0 = Y . The general single-qubit gate (6.6) is speciﬁed by the three
parameters, or rotation angles, θ1, θ2, and θ3.

Single-qubit gates can be applied in parallel to the qubits of a
quantum system. To indicate the qubit k ∈ {0, 1, ..., n − 1} to which
a single-qubit gate is applied, it is common to add subscript k to
the notation for the gate. As an example, the notation Zk describes
a unitary that applies the Pauli Z gate only on the k-th qubit. This
transformation amounts to a Pauli string containing all identity matrices
I, of dimension 2 × 2, except for the position k, where we have the Pauli
operator Z, i.e.,

Zk = I ⊗ · · · ⊗ I
}

|

{z
k−1

⊗Z ⊗ I ⊗ · · · ⊗ I
}

|

{z
n−k

.

(6.7)

180

Quantum Machine Learning

R(θ1

0, θ2

0, θ3
0

R(θ1

1, θ2

1, θ3
1

|0i

R(θ1

2, θ2

2, θ3
2

R(θ1

3, θ2

3, θ3
3

)

)

)

)

Figure 6.6: The mean-ﬁeld ansatz consists of general single-qubit gates applied in
parallel to the n qubits, which are initially in the ground state |0i (n = 4 in the
ﬁgure).

Similarly, we can write

Rk(θ1

k, θ2

k, θ3
k

) = I ⊗ · · · ⊗ I
}

|

{z
k−1

⊗R(θ1

k, θ2

k, θ3
k

) ⊗ I ⊗ · · · ⊗ I
}

|

(6.8)

{z
n−k
k, θ3
k, θ2
k

) applied to

for a general single-qubit gate with parameters (θ1
the kth qubit.

6.4.2 Mean-Field Ansatz

An ansatz U (θ) that uses only single-qubit gates is known as a mean-
ﬁeld ansatz. As illustrated in Fig. 6.6, the mean-ﬁeld ansatz deﬁnes
unitaries of the form

0, θ2

0, θ3
0

) ⊗ · · · ⊗ R(θ1

n−1, θ2

n−1, θ3

n−1

)

U (θ) = R(θ1
n−1
Y

=

Rk(θ1

k, θ2

k, θ3
k

),

(6.9)

k=0

k, θ2

with (θ1
k, θ3
k
the parameter vector θ = [θ1
3n parameters.

) for k ∈ {0, 1, ..., n − 1} being scalar parameters. Overall,
]T contains D =
n−1, θ2

0, ..., θ1

n−1, θ3

0, θ2

0, θ3

n−1

Given the input state |0i, a PQC following the mean-ﬁeld ansatz

outputs the separable state

U (θ)|0i = R(θ1

0, θ2

0, θ3
0

)|0i ⊗ · · · ⊗ R(θ1

n−1, θ2

n−1, θ3

n−1

)|0i,

(6.10)

6.4. Ansatz and Parametrized Quantum Circuits

181

where we have written as |0i both the multi-qubit ground state and the
corresponding single-qubit states with some abuse of notation.

While simple, the mean-ﬁeld ansatz may be suﬃcient for some
applications. This may be the case, for instance, if the desired output
of a computation is a vector in the computational basis. In fact, a PQC
following the mean-ﬁeld ansatz can produce all possible vectors in the
computational basis. This result can be obtained by setting θ1
= 0 and
k
= 0 for all qubits k ∈ {0, 1, ..., n − 1}, and by choosing parameters
θ3
k
= π to encode the two computational-basis
as either θ2
θ2
k
k
vectors.

= 0 or θ2
k

More generally, however, the solution of many practical problems
can beneﬁt from ansatzes that can produce entanglement among the
qubits. This can be done by introducing entangling, multi-qubit, gates
in the PQC, hence moving beyond the mean-ﬁeld ansatz.

6.4.3 Hardware-Eﬃcient Ansatz

Moving one level up along the complexity axis for ansatzes, the hardware-
eﬃcient ansatz includes both parametrized single-qubit gates and a
ﬁxed entangling unitary Uent, which does not depend on the param-
eter vector θ. As detailed below, the entangling unitary Uent typically
consist of CNOT or CZ gates (see Sec. 2.6.4). A ﬁxed entangling unitary
is adopted for simplicity of implementation, since two-qubit gates are
generally hard to implement on quantum computers. This motivation
justiﬁes the name “hardware-eﬃcient” for this ansatz.

Speciﬁcally, as illustrated in Fig. 6.7, the hardware-eﬃcient ansatz
prescribes PQCs that implement a cascade of L layers of unitaries as in

U (θ) = UL(θ) · UL−1(θ) · · · U1(θ),

(6.11)

where each unitary matrix Ul(θ) at the lth layer can be expressed as

Ul(θ) = Uent

(cid:16)

R(θ1

l,0, θ2

l,0, θ3
l,0

) ⊗ · · · ⊗ R(θ1

l,n−1, θ2

l,n−1, θ3

l,n−1

)(cid:17)

, (6.12)

l,k, θ2

l,k, θ3
l,k

) for k ∈ {0, 1, ..., n − 1}. The parameter vector θ
with (θ1
hence includes D = 3nL parameters, with 3n parameters describing
each layer.

182

Quantum Machine Learning

Figure 6.7: The hardware-eﬃcient ansatz consists of L layers, each encompassing
general single-qubit gates applied in parallel to the n qubits and a ﬁxed entangling
circuit Uent. The qubits are initially in the ground state |0i.

By (6.11)-(6.12), a PQC following the hardware-aware ansatz applies,
at each layer l, separate single-qubit gates to all the n qubits, as in
the mean-ﬁeld ansatz, followed by a ﬁxed entangling unitary Uent. The
entangling unitary Uent is typically implemented using linear, circular,
or full entangling circuits:

• Linear entangling circuits implement two-qubit gates between
successive qubits. The example in Fig. 6.8 uses CZ gates, and it
can be expressed as

Uent =

n−2
Y

k=0

CZ

k,k+1,

(6.13)

where CZ

k,k+1

is the CZ gate between qubits k and k + 1.

• Circular entangling circuits add to the architecture of linear
entangling circuit an additional two-quit gate between the ﬁrst
and the last qubit.

• Full entangling circuits implement two-qubit gates between all

pairs of qubits, as illustrated in Fig. 6.9 with CZ gates.

………6.4. Ansatz and Parametrized Quantum Circuits

183

Figure 6.8: A linear entangling circuit Uent for n = 4 qubits implemented via CZ
gates.

Figure 6.9: A full entangling circuit Uent for n = 4 qubits implemented via CZ
gates.

In this regard, we observe that CZ gates have the advantage over CNOT
gates that they can be applied in any order since they commute.

The hardware-eﬃcient ansatz is generic, and it is often deemed to
play a similar role to fully connected classical neural networks in the
design of quantum machine learning. That said, it is important to stress
that a hardware-eﬃcient ansatz does not have analogous properties to
fully connected classical neural networks when it comes to dependence on
model parameters. Notably, in fully connected classical neural networks,
one has signiﬁcant freedom in optimizing the connectivity between
neurons by designing the individual synaptic weights are biases. In
contrast, in the hardware-eﬃcient ansatz, one can control only the
rotations applied to each individual qubit, and dependencies among
qubits are dictated by ﬁxed entangling circuits.

6.4.4 Parametrized Two-Qubit Gates

At a higher level of complexity with respect to the hardware-eﬃcient
ansatz are PQCs that include also parametrized two-qubit gates. In
this subsection, we describe two common types of parametrized two-
qubit gates, namely parametrized controlled gates and two-qubit Pauli

184

Quantum Machine Learning

rotations.
Parametrized two-qubit controlled gates: Using the notation in-
troduced in Sec. 2.6.4, parametrized two-qubit controlled gates are of
the form CU (θ)
, where j is the index of controlling qubit, k is the index
of the controlled qubit, and U (θ) is a parametrized single-qubit gate.
Considering for simplicity of notation qubit 0 as the controlling qubit
and qubit 1 as the controlled qubit, we can write (cf. (2.57))

jk

CU (θ)
01

= |0ih0| ⊗ I + |1ih1| ⊗ U (θ).

(6.14)

Therefore, on the branch of the computation in which the controlling
qubit has state |0i, no operation is applied to controlled qubit; while, on
the branch in which the controlling qubit has state |1i, the parametrized
single-qubit gate U (θ) is applied.

Instances of parametrized two-qubit gates include the parametrized

CNOT gate

CNOTjk(θ) = CRX (θ)
where the controlled single-qubit gate is a Pauli X-rotation RX (θ); and
the parametrized CZ gate

(6.15)

jk

,

CZjk(θ) = CRZ (θ)

jk

,

(6.16)

where the controlled single-qubit gate is a Pauli Z-rotation RZ(θ). Note
that, by (6.3)-(6.5), the parametrized CNOT and CZ gates recover the
standard CNOT and CZ gates by setting θ = −π, apart from a phase
term.
Two-qubit Pauli rotations: For a system with two qubits, a two-qubit
Pauli P Q-rotation is deﬁned as the unitary matrix
(cid:19)

(cid:18)

RP Q(θ) = exp

−i

(P ⊗ Q)

,

(6.17)

θ
2

where P and Q are selected as one of the four Pauli operators {I, X, Y, Z}.
A common example is the Pauli ZZ-rotation gate deﬁned by the
unitary

RZZ(θ) = exp

(cid:18)

−i

θ
2 Z ⊗ Z

(cid:19)

.

(6.18)

Despite the presence of the product P ⊗ Q in (6.17), two-qubit Pauli
rotations are generally not local operators. In this regard, note that

6.5. Cost Functions for Quantum Machine Learning

185

X

RZ(θ)

X

Figure 6.10: An implementation of the Pauli ZZ-rotation gate

we have the equality RZZ(−π) = i(Z ⊗ Z), so that with the special
choice of θ = −π the gate RZZ(−π) consists of two local single-qubit
operations, while this is not the case in general. For any value of θ, the
Pauli ZZ-rotation can be implemented as the cascade of CNOT, Pauli
Z-rotation, and CNOT gate depicted in Fig. 6.10.

6.5 Cost Functions for Quantum Machine Learning

At the core of quantum machine learning methods (with quantum
processing) is the minimization, using a classical optimizer, of a cost
function L(θ) over the vector of PQC parameters θ. As we will see
in this chapter, for the CQ case, the cost function L(θ) is typically a
function of the expected values of observables evaluated under the state
produced by the PQC, as well as (possibly) of classical data. In this
section, we ﬁrst formalize this notion of cost function, and describe
some implications for optimization. Then, we discuss the problem of
estimating the gradient of the cost function L(θ). This problem is central
to many implementations of quantum machine learning techniques in
which the cost function L(θ) is minimized via gradient descent.

6.5.1 Cost Functions via the Expected Values of Observables

Let us denote as |ψ(θ)i the state of the n qubits upon application of
the PQC deﬁned by unitary matrix U (θ). Conventionally, the input of
the PQC is given by the ground state |0i, so that the output state can
be written as

|ψ(θ)i = U (θ)|0i.

(6.19)

More generally, the operation of the PQC may also depend on input
data (see Fig. 6.3), but for the purpose of the discussion in this section
we can ignore this aspect. The cost function L(θ) to be minimized via

186

Quantum Machine Learning

a classical optimizer may depend on a classical data set D, as well as
, i.e.,
on the expected values of a set of NO observables O1, O2, ..., ONO

L(θ) = f (D, {hOji|ψ(θ)i}NO
j=1

),

(6.20)

where f (·) is some function.

To proceed, we recall a few basic facts about observables from Sec.
5.3. An observable is deﬁned by a Hermitian matrix O. Measuring the
observable amounts to implementing a measurement in the eigenbasis
{|vxi}2n−1
of matrix O. Furthermore, each possible measurement out-
x=0
come, indexed by an n-cbit string x ∈ {0, 1}n, produces a real-valued
observation given by the corresponding eigenvalue ox. Let us denote as
p(x|θ) the probability of measuring output x and hence obtaining the
observation ox. By Born’s rule, this probability can be expressed as
p(x|θ) = |hvx|ψ(θ)i|2,
where we recall that hvx|ψ(θ)i is the complex amplitude of the state
|ψ(θ)i associated with the basis vector |vxi. Importantly, the probability
p(x|θ) in (6.21) depends on the parameter vector θ, since it describes
measurements of the quantum state |ψ(θ)i. The outcome x of a measure-
ment is denoted as x ∼ p(x|θ) to indicate that sample x is distributed
according to the distribution p(x|θ).

(6.21)

The expected value hOi|ψ(θ)i of observable O evaluated for the

quantum state |ψ(θ)i is deﬁned as the average
2n−1
X

hOi|ψ(θ)i = hψ(θ)|O|ψ(θ)i =

p(x|θ)ox.

(6.22)

x=0

To emphasize that this expectation is the average of random variable
ox with distribution p(x|θ), we may also use the notation

hOi|ψ(θ)i = hoxip(x|θ),
where the subscript on the right-hand side indicates that the average is
computed with respect to distribution p(x|θ).

(6.23)

To elaborate further on cost functions of the form (6.20), in the rest of
this section we will consider the basic situation in which the cost function
equals the expectation of a single observable O as L(θ) = hOi|ψ(θ)i. The
problem of interest is the minimization

n
L(θ) = hOi|ψ(θ)i = hoxip(x|θ)

o

.

min
θ

(6.24)

6.5. Cost Functions for Quantum Machine Learning

187

6.5.2 Gradient-Based Optimization

Problems of the form (6.24) amount to the minimization of an expec-
tation over the averaging distribution. We will refer to this type of
problems as stochastic optimization. Stochastic optimization is com-
mon in classical machine learning, where it underlies techniques such
as variational inference, Bayesian learning, and generative modelling.
In some of these methods, the distribution p(x|θ) under optimization
is available explicitly and can be diﬀerentiated. In others, the distribu-
tion p(x|θ) is only available implicitly: The model can produce samples
x ∼ p(x|θ), but one does not have direct access to the distribution
p(x|θ) itself.

Quantum machine learning models fall in the latter category. A
PQC produces random samples x distributed according to p(x|θ), by
Born’s rule as in (6.21), but the distribution p(x|θ) is not explicitly
computable.

For both explicit and implicit models, solutions of stochastic prob-
lems (6.21) are often addressed via stochastic gradient descent.
Accordingly, at the current iterate θ for the model parameter vector,
the classical optimizer obtains an estimate ˆ∇L(θ) of the gradient

(cid:21)T

∇L(θ) =

(cid:20) ∂L(θ)
∂θ1
of the cost function L(θ). This estimate is obtained based on a number
NS of samples x ∼ p(x|θ0) for some values θ0 of the model parameter
vector. Therefore, the estimate is subject to shot noise, that is, to the
randomness of the sample generation process.

∂L(θ)
∂θD

(6.25)

· · ·

Following the direction of the stochastic gradient estimate ˆ∇L(θ),

the classical optimizer updates the parameter vector as

θ ← θ − γ ˆ∇L(θ)

(6.26)

for some learning rate γ > 0. Adaptive learning rates can also be readily
implemented. The procedure is repeated for a number of iterations.

In classical machine learning, for explicit models, standard methods
to estimate the gradient of the cost function L(θ) include the REIN-
FORCE algorithm; while certain implicit models can be addressed by

188

Quantum Machine Learning

using the so-called reparametrization trick. We refer the reader to the
recommended resources for details. All of these methods make use of
backpropagation in the typical case where classical models are imple-
mented via neural networks. As we will discuss, none of these approaches
are directly applicable to quantum machine learning.

6.5.3 Numerical Diﬀerentiation

To proceed, let us ﬁrst pursue the natural idea of estimating the gradi-
ent ∇L(θ) via numerical diﬀerentiation. Accordingly, the d-th partial
derivative in the gradient (6.25), for d ∈ {1, ..., D}, is ﬁrst approximated
as

∂L(θ)
∂θd

’

L(θ + (cid:15)ed) − L(θ − (cid:15)ed)
2(cid:15)

,

(6.27)

where (cid:15) > 0 is a small number and ed is a one-hot D-dimensional
vector with a 1 in the d-th position. It can be readily checked that
the error of the approximation (6.27) is of the order O((cid:15)2), and hence
it can be controlled by selecting a suﬃciently small (cid:15). In words, the
approximation (6.27) is obtained by perturbing each parameter θd by
a small number (cid:15) in both positive and negative directions in order to
evaluate the corresponding partial derivative.

The second step is to estimate both terms in the approximation
(6.27) via empirical averages obtained from multiple measurements
of the quantum state |ψ(θ)i produced by the PQC. As illustrated in
Fig. 6.11, for each d-th parameter θd, with d ∈ {1, ..., D}, we run the
quantum circuit 2NS times, where NS is the number of runs, or shots,
used to estimate the expected value of the observable. In particular, NS
measurements are used to estimate the expected value

L(θ + (cid:15)ed) = hOi|ψ(θ+(cid:15)ed)i=U (θ+(cid:15)ed)|0i,

(6.28)

and NS measurements are used to estimate the expected value

L(θ − (cid:15)ed) = hOi|ψ(θ−(cid:15)ed)i=U (θ−(cid:15)ed)|0i.

(6.29)

It follows that a total number of 2DNS measurements are needed to
estimate the gradient vector at any given model parameter vector θ.

6.5. Cost Functions for Quantum Machine Learning

189

Figure 6.11: Numerical diﬀerentiation method to estimate the gradient of the
expectation of an observable (6.24): For each d-th entry ∂L(θ)/∂θd of the gradient,
with d = 1, ..., D, one needs to carry out 2NS separate measurements of the observable.
NS measurements, or shots, are used to estimate the expected value L(θ + (cid:15)ed), and
NS measurements are used to estimate the expected value L(θ − (cid:15)ed).

6.5.4 Parameter Shift Rule

In classical machine learning, with neural networks used as models, the
gradient of the loss function can be computed at once via backpropa-
gation. Backpropagation consists of two runs through the model, once
in the forward direction and once backwards. Backpropagation is hence
signiﬁcantly more eﬃcient than numerical diﬀerentiation, since the latter
requires a number of runs through the model that is proportional to D.
No quantum counterpart of backpropagation exists, since in quantum
machine learning one does not have access to the internal workings of
the model, i.e., the PQC, which is only accessible via measurements.
(That is, unless one relies on a simulation of the quantum computer
on a classical computer, which is only feasible for small values of n.)
Hence, the computation of the gradient is an inherently more complex,
and less scalable, operation than in classical machine learning.

That said, when only, possibly multi-qubit, Pauli rotations are used
as parametric gates in the PQC, a related approach, known as the
parameter shift rule, can be proved to provide the exact gradient as

-average (𝑁𝑆shots)average (𝑁𝑆shots)repeat for d=1,…,Destimate of190

Quantum Machine Learning

the number of shots NS goes to inﬁnity. As we elaborate in this sub-
section, the parameter shift rule does not solve the scalability problem
highlighted above, as it still requires a number of runs through the
model proportional to D. The only advantage as compared to numerical
diﬀerentiation is that the approximate equality in (6.27) can be turned
into an equality without requiring the numerically problematic step of
reducing the value of (cid:15).

To elaborate, assume that each parameter θd contributes to the

PQC through a gate of the form

Ud(θ) = exp

(cid:18)

−i

θd
2 Pd

(cid:19)

,

(6.30)

where the generator Pd is a Pauli string. Note that the gate (6.30) may
apply to an arbitrary number of qubits, and that it encompasses as
special cases the single- and two-qubit Pauli rotation gates discussed
in Sec. 6.4. Therefore, mean-ﬁeld ansatz, hardware-eﬃcient ansatz, as
well as generalizations thereof involving parametrized two-qubit Pauli
rotations satisfy the assumption at hand.

Under this assumption, it can be proved that the partial derivative

can be exactly computed as (see Appendix B)

L (cid:0)θ + π

2 ed

∂L(θ)
∂θd

=

(cid:1) − L (cid:0)θ − π

2 ed

(cid:1)

.

(6.31)

2

Therefore, the use of the “numerical diﬀerentiation-like” expression in
(6.31) does not entail any approximation, unlike (6.27).

As anticipated, and as detailed in Fig. 6.12, the parameter shift
rule still entails the implementation of the same number 2DNS of
measurements. Furthermore, the procedure is equivalent to that depicted
in Fig. 6.11 for numerical diﬀerentiation, with the only caveat that the
shift takes the speciﬁc value π/2 and that the normalization constant
is given by 1/2.

6.5.5 Limitations of Gradient Descent

An important practical problem related to the implementation of the
outlined gradient descent method is that the landscape of the loss
function L(θ) may not be well behaved as the number of qubits n grows

6.5. Cost Functions for Quantum Machine Learning

191

Figure 6.12: Parameter shift rule to estimate the gradient of the expectation
of an observable (6.24): For each d-th entry ∂L(θ)/∂θd of the gradient, with d ∈
{1, ..., D}, one needs to carry out 2NS separate measurements of the observable. NS
measurements, or shots, are used to estimate the expected value L(θ + π/2ed), and
NS measurements are used to estimate the expected value L(θ − π/2ed).

large. Intuitively, this is due to the mismatch between the size of the
parameter vector θ and the exponentially large dimension, 2n, of the
Hilbert space. A particularly important issue concerns the scaling of the
partial derivatives of the cost function L(θ). In particular, it has been
shown that, when the ansatz is suﬃciently rich and the model parameters
are randomly initialized, the partial derivatives tend exponentially to
zero in probability as n grows. This is known as the barren plateaus
problem.

Possible solutions include selecting optimized initializations; imple-
menting ansatzes that are well matched to the problem under study,
e.g., by leveraging symmetries in the underlying distribution or mapping
of interest; and exploring alternatives to gradient descent.

Based on the drawbacks just discussed, alternatives to gradient
descent may also be considered that encompass more advanced forms
of local optimization, e.g., based on second-order information, as well
as global optimization strategies. Global optimization may leverage
surrogate objective functions, which extrapolate the value of the
cost L(θ) across diﬀerent values of θ. One such method is provided by

-average (𝑁𝑆shots)average (𝑁𝑆shots)repeat for d=1,…,Destimate of12192

Quantum Machine Learning

Bayesian optimization, which updates the surrogate sequentially based
on the outcomes of previous measurements.

6.6 Variational Quantum Eigensolver

In this section, we describe a ﬁrst application of the methodology
illustrated in Fig. 6.1. In it, the parameter vector θ of a PQC is designed
via a classical optimizer that is fed measurements of the PQC’s output
state. Speciﬁcally, we introduce the variational quantum eigensolver
(VQE) as a tool to address a class of binary combinatorial optimization
problems via the approach depicted in Fig. 6.1. Broader applications of
VQEs will be also mentioned later in this section.

While VQEs are not data-driven, and hence may not qualify as
“machine learning”, they serve as a useful stepping stone to describe
quantum machine learning applications. In fact, VQEs optimize the
model parameter θ by minimizing the expectation of an observable
under the quantum state produced by the PQC. As anticipated in the
previous section, this approach is common to many quantum machine
learning methods.

6.6.1 Quadratic Unconstrained Binary Optimization

A quadratic unconstrained binary optimization (QUBO) prob-
lem can be formulated as the combinatorial optimization

min
˜x∈{−1,1}n






f (˜x) =

n−1
X

k−1
X

k=0

j=0

ak,j ˜xk ˜xj +

n−1
X

k=0

bk ˜xk






(6.32)

with coeﬃcients {ak,j, bk}. QUBO has a wide range of applications from
ﬁnance and economics to machine learning. The exact solution of a
QUBO generally requires a search over the exponentially large space,
in n, of the binary optimization vector ˜x. We will assume for simplicity
that the problem has a single optimum solution ˜x∗ ∈ {−1, 1}n.

Problem (6.32) can be equivalently formulated as an optimization
over a binary vector x ∈ {0, 1}n. To this end, we can create a one-to-one
mapping between each binary string x ∈ {0, 1}n and the corresponding
signed binary string ˜x ∈ {−1, 1}n by setting ˜xk = −1 for xk = 1 and

6.6. Variational Quantum Eigensolver

193

˜xk = 1 for xk = 0 for k ∈ {0, 1, ..., n − 1}. The resulting mapping
between the two vectors is hence given by the entry-wise equality

˜xk = 1 − 2xk

(6.33)

for k ∈ {0, 1, ..., n − 1}. We will write this assignment for short as
˜x = 1 − 2x, in which the operations are applied element-wise.

6.6.2 QUBO Objective as a Quantum Observable

In order to address the QUBO problem (6.32) with a PQC, we start by
expressing the objective function f (·) in terms of a quantum observable
F on n qubits. As we will see in the next subsections, the main idea
underlying VQEs is to design the PQC to output n qubits in a state
that (approximately) minimizes the expectation of the observable F .
The objective function f (·) can be associated with the following

observable deﬁned on n qubits

F =

n−1
X

k−1
X

k=0

j=0

ak,jZkZj +

n−1
X

k=0

bkZk,

(6.34)

which is also known as the Ising Hamiltonian. We recall from the
previous section that the matrix Zk is deﬁned as in (6.7). The observable
F is the sum of n(n − 1)/2 + n observables, each given by a Pauli string
consisting of Pauli operators {I, Z}. Each individual observable in (6.34)
corresponds to the term in (6.32) obtained by replacing the Pauli string
Zk with the binary variable ˜xk.

The association between objective function f (·) in (6.32) and the

observable F in (6.34) has the following properties:

• Eigenvectors as solutions: The observable F has eigenvectors
given by the vectors {|xi}2n−1
of the computational basis. Each
x=0
eigenvector |xi can be thus associated with a possible solution
˜x = 1 − 2x of the QUBO problem.

• Eigenvalues as objective function values: Each eigenvector
|xi has corresponding eigenvalue f (˜x), with ˜x = 1 − 2x, i.e.,

F |xi = f (˜x)|xi.

(6.35)

194

Quantum Machine Learning

Accordingly, the value f (˜x) of the objective function at any candidate
solution ˜x ∈ {−1, 1}n can be computed by obtaining the eigenvalue of
the observable F corresponding to the eigenvector |xi with ˜x = 1 − 2x.
To prove the key equality (6.35), note that the eigendecomposition

of the Pauli Z operator implies the equalities

ZkZj|xi = ˜xk ˜xj|xi and Zk|xi = ˜xk|xi,
where ˜xk is the kth element of vector ˜x = 1 − 2x. It follows that we
have the equalities

(6.36)

F |xi =

=

n−1
X

k−1
X

k=0

j=0

n−1
X

k−1
X

j=0
k=0
= f (˜x)|xi.

ak,j (ZkZj|xi) +

n−1
X

k=0

bkZk|xi

ak,j ˜xk ˜xj|xi +

n−1
X

k=0

bk ˜xk|xi

(6.37)

6.6.3 QUBO as the Minimization of the Expected Value of an

Observable

Given the equality (6.35), the minimum eigenvalue of the observable F
corresponds to the minimum value f (˜x∗) of the QUBO problem. It is a
well-known result from linear algebra that the minimum eigenvalue of a
Hermitian matrix can be obtained by solving the problem

min
|ψi

hψ|F |ψi

(6.38)

over all possible normalized 2n vectors |ψi. Therefore, the QUBO
problem can be equivalently solved by addressing the minimum-
eigenvalue problem (6.38) in the sense that we have the equalities

min
|ψi

hψ|F |ψi = min

f (˜x) = f (˜x∗).

(6.39)

˜x∈{−1,1}n
Moreover, the optimal solution |ψ∗i of problem (6.38) provides, by
(6.35), the solution of the QUBO problem, since we have the equality
|ψ∗i = |x∗i with ˜x∗ = 1 − 2x∗.

The expression hψ|F |ψi equals the expected value hF i|ψi of the ob-
servable F , and hence the minimum-eigenvalue problem (6.38) amounts

6.6. Variational Quantum Eigensolver

195

Figure 6.13: Illustration of the operation of a VQE. The classical optimizer aims
at addressing the stochastic optimization problem of minimizing the expected value
hF iψ(θ)i = hψ(θ)|F |ψ(θ)i of the observable F .

to searching for the quantum state |ψi that minimizes the expectation
hF i|ψi, i.e.,

min
|ψi

hF i|ψi.

(6.40)

6.6.4 Variational Quantum Eigensolver

The key idea underlying VQEs is to replace the optimization over
state |ψi in (6.40) with an optimization over the parameters θ of the
PQC. Speciﬁcally, as illustrated in Fig. 6.13, the VQE design methodol-
ogy starts oﬀ by assuming a given ansatz for the PQC implementing
a parametrized unitary U (θ). The PQC produces the parametrized
quantum state

|ψ(θ)i = U (θ)|0i.
For any vector θ, the expected value of the observable F is given by
hF i|ψ(θ)i = hψ(θ)|F |ψ(θ)i. The goal of the classical optimizer in Fig.
6.13 is to use estimates of the expected value hF i|ψ(θ)i to address the
problem of minimizing hF i|ψ(θ)i over vector θ, i.e.,

(6.41)

o
n
L(θ) = hF i|ψ(θ)i = hψ(θ)|F |ψ(θ)i = h0|U (θ)†F U (θ)|0i

. (6.42)

min
θ

The solution of the VQE problem (6.42) generally provides an upper
bound on the minimum value of the cost function of the QUBO problem,

averageclassical optimizer196

i.e.,

Quantum Machine Learning

min
θ

L(θ) ≥ min
|ψi

hψ|F |ψi = f (˜x∗),

(6.43)

and the tightness of the bound depends on the ﬂexibility of the ansatz
underlying the PQC U (θ). In fact, if there exists a model parameter
θ∗ such that the PQC produces the optimal state, i.e., such that we
have |ψ(θ∗)i = |x∗i, the solution of the VQE problem coincides with
the optimal solution of the QUBO problem. As we discussed in Sec.
6.4, this is the case even with a simple mean-ﬁeld ansatz involving
only Pauli Y -rotations, since the latter can produce any vector in the
computational basis.

That said, in practice, exact optimization of problem (6.42) is not
possible, and hence one is not guaranteed to recover the optimal solution
of the QUBO problem. Rather, one typically implements stochastic
gradient descent, or variants thereof, as discussed in the previous section.
Having found a model parameter θ that approximately solves prob-
lem (6.42), how can one extract a solution for the original QUBO
problem? If the goal is merely to compute the minimum value f (˜x∗) of
the objective function, an estimate of the optimal objective f (˜x∗) can
be obtained by estimating the expectation hF i|ψ(θ∗)i for the optimized
parameters θ∗. Approximating the solution ˜x∗ is instead possible by
making a single standard measurement of the state |ψ(θ∗)i. In fact, by
Born’s rule, such a measurement returns a vector |xi in the computa-
tional basis, whose corresponding signed vector ˜x = 1 − 2x can be taken
to be an approximation of the optimal solution ˜x∗.

6.6.5 Addressing the VQE Optimization Problem

The VQE problem (6.42) is a stochastic optimization problem in the
form (6.24) with observable given by F . Therefore, classical optimization
can be done via gradient descent by following the perturbation-based
gradient descent approach detailed in the previous section. As mentioned
therein, such methods require estimates of the expected value hF i|ψ(θ)i
for given candidate solutions θ.

By the decomposition of the observable F into Pauli strings, we can

6.7. Unsupervised Learning for Generative Models

197

write this expectation as

hF i|ψ(θ)i =

n−1
X

k−1
X

k=0

j=0

ak,jhZkZji|ψ(θ)i +

n−1
X

k=0

bkhZki|ψ(θ)i.

(6.44)

Following Sec. 5.2, all the n(n − 1)/2 + n expectations in (6.44) can be
approximated via empirical averages obtained from multiple measure-
ments in the computational basis of the n qubits in state |ψ(θ)i. Note,
in fact, that the n(n − 1)/2 + n observables in (6.44) are compatible
(see Sec. 5.3.5).

6.6.6 Other Applications of VQEs

In this section, we have presented VQE as a means to address the QUBO
problem. More generally, following the discussion in Sec. 6.6.3, VQE can
be adopted as a tool to tackle the problem of estimating the minimum
eigenvalue of an observable F . While the observable arising from the
solution of a QUBO is given in terms of Pauli Z operators, one may be
more broadly interested in observables that can be written as arbitrary
linear combinations of Pauli strings. Therefore, the observable F may
include also the X and Y Pauli operators, as well as terms including
more than two Pauli operators. When implementing VQE for this more
general class of observables, it should be kept in mind that it is only
possible to measure simultaneously, on the same qubit, observables
derived from the same Pauli operator (see Sec. 5.3.5). Therefore, a
general observable of this form would requires three separable, i.e.,
qubit by qubit, measurements in the X, Y , and Z bases.

6.7 Unsupervised Learning for Generative Models

As a ﬁrst machine learning application of PQCs, this section studies
the unsupervised learning problem of training probabilistic models
generating random binary strings x ∈ {0, 1}n. We proceed by ﬁrst
describing the operation of such generative models at a high level, and
by then detailing an implementation using PQCs.

198

Quantum Machine Learning

6.7.1 Generative Models

Given a training set D={x1, ..., x|D|} of |D| n-cbit strings (|D| is the
cardinality of set D), we would like to train a probabilistic model that
is able to generate binary strings that are distributed in a manner that
“resembles” the underlying, unknown, distribution of the data.

As an example, one may think of x as a black-and-white image,
ﬂattened into an n dimensional vector, with black and white pixels
identiﬁed by entries of the vector equal to 1 and 0, respectively. The
goal of unsupervised learning in this context is that of training a model
that can produce black-and-white images that are “similar” to those in
the training set D.

In the rest of this subsection, we review the two main phases of
operation of a parametrized generative model. At run time, when the
model is used with a ﬁxed parameter vector θ, the goal is to sample
binary strings x from a desired distribution; while the training phase
aims at optimizing the model parameter vector θ.
Sample generation: Probabilistic generative models produce random-
ized n-cbit strings from some parametric distribution p(x|θ), where θ is
the vector of model parameters. Once trained, that is, once vector θ is
optimized, the model is used to generate one, or more, random strings
x – e.g., images – drawn from distribution p(x|θ).
Training: Training relies on the deﬁnition of a loss function ‘(x|θ),
which describes how suitable the generative model deﬁned by distribu-
tion p(x|θ) is as a mechanism to generate the speciﬁc string x. Loss
functions for probabilistic models are also known as scoring functions.
A scoring function should be a non-increasing function of p(x|θ): A
model p(x|θ) that assigns a low probability to a data point x should be
assigned a larger loss than a model p(x|θ) that assigns a high probability
to a data point x.

The most common scoring function in classical machine learning is

the log-loss

‘(x|θ) = − log p(x|θ),

(6.45)

also known as cross-entropy loss or information theoretic suprise,
which is indeed a decreasing function of p(x|θ). An issue with the log-
loss is that it is not well deﬁned when the probability p(x|θ) is zero. To

6.7. Unsupervised Learning for Generative Models

199

avoid this problem, one can modify the log-loss as

‘(x|θ) = − log max((cid:15), p(x|θ))

(6.46)

for some small (cid:15) > 0. Alternatively, a popular option for quantum
machine learning is the linear loss

‘(x|θ) = 1 − p(x|θ).

(6.47)

Once a loss function is determined, the training loss is deﬁned as

LD(θ) =

1

|D|

X

x∈D

‘(x|θ)

(6.48)

as the empirical average of the loss accrued on the examples in the
training set D. The goal of training is typically deﬁned as the minimiza-
tion of the training loss (6.48) – a problem known as empirical risk
minimization

min
θ

LD(θ).

(6.49)

The training loss (6.48) can be interpreted as a “distance” measure
between the empirical distribution of the training data and the distri-
bution p(x|θ) of the samples produced by the model. This viewpoint
will be further elaborated on in the next subsection.

6.7.2 Quantum Generative Models: Born Machines

A PQC implementing a unitary U (θ) on n qubits can be readily used as
a generative model of randomized n-cbit strings. In this subsection, we
describe this application of PQCs by discussing both sample generation
and training phases.
Sample generation: As illustrated in the top part of Fig. 6.14, in
order to generate a random n-cbit string, the PQC is run once and
a standard measurement is made on the n qubits. The measurement
produces an n-cbit string x ∼ p(x|θ), where the distribution

p(x|θ) = |hx|ψ(θ)i|2,

(6.50)

is obtained from (6.21) by considering the computational basis |vxi = |xi
with x ∈ {0, 1}n. As a result, generative models based on PQCs are
also known as Born machines.

200

Quantum Machine Learning

Figure 6.14: (top) For data generation, a Born machine implements a single run
of the PQC U (θ), producing as output of the measurement a random cbit string
x ∼ p(x|θ). (bottom) For training, a classical optimizer can address the problem of
minimizing the expected value of a training data set-dependent observable FD, or
the minimization of a distance metric between the empirical data distribution and
the distribution p(x|θ) (not shown).

It is worth reiterating that a sample x ∼ p(x|θ) is produced with a
single run of the PQC, hence not requiring multiple runs to average out
the shot noise associated with quantum measurements. In this sense,
shot noise is actually useful for generative models, as it is leveraged
to produce random samples. This is a common feature of probabilistic
models, as we will also see in the next section for supervised learning.

Before turning to the training phase, we brieﬂy describe a useful
perspective on scoring functions dependent on the probability (6.50).
The quantity |hx|ψ(θ)i|2 in (6.50) can be interpreted as the ﬁdelity
between the two states |xi and |ψ(θ)i (see Sec. 3.2.5). The ﬁdelity is an
important metric in quantum theory that measures the degree to which
one state can be “confused” for the other state based on measurement
outputs. In this regard, a loss function deﬁned as a non-increasing
function of the ﬁdelity |hx|ψ(θ)i|2 can be thought of as measuring how

classical dataaveragesample generationtrainingclassical optimizer6.7. Unsupervised Learning for Generative Models

201

well – or, rather, how poorly – the state |ψ(θ)i represents the input
data x encoded in state |xi.
Training via the ERM problem: We now address the ERM problem
(6.49) for the linear loss

‘(x|θ) = 1 − p(x|θ) = 1 − |hx|ψ(θ)i|2.

(6.51)

Following the discussion in Sec. 6.5, a Born machine is an implicit
probability model: It can generate samples x ∼ p(x|θ), but it does not
provide an explicit way to compute the probability p(x|θ). Therefore, the
loss (6.51) cannot be explicitly computed and diﬀerentiated. We show
next how the ERM problem (6.49) can be formulated as a stochastic
problem in the form (6.24).

To this end, we ﬁrst write the probability p(x|θ) as
p(x|θ) = hψ(θ)|Fx|ψ(θ)i = hFxi|ψ(θ)i,

i.e., as the expected value of the observable

It follows that the training loss can be written as

Fx = |xihx|.

(6.52)

(6.53)

1

|D|
*

LD(θ) =

=

X

(1 − hψ(θ)|Fx|ψ(θ)i)

x∈D
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

ψ(θ)

I −

1

|D|

X

x∈D

Fx

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

+

ψ(θ)

= hψ(θ)|FD|ψ(θ)i = hFDi|ψ(θ)i.

(6.54)

Therefore, the training loss can be expressed as the expected value of
the training data set-dependent observable

FD = I −

1

|D|

X

x∈D

Fx.

(6.55)

We hence conclude that the ERM problem (6.49) is indeed in the form
(6.24), and thus it can be addressed using the methods described in Sec.
6.5 as illustrated in the bottom part of Fig. 6.14.

The observable FD can be equivalently written as
2n−1
X

FD =

(1 − pD(x))|xihx|,

x=0

(6.56)

202

where

Quantum Machine Learning

pD(x) =

number of data points equal to x in D
|D|
is the empirical distribution of the training data. Therefore, the observ-
able FD is measured by making a standard measurement of the output
state |ψ(θ)i, and by associating the observed value 1 − pD(x) to each
possible output x ∈ {0, 1}n.

(6.57)

From this observation, we can conclude that, by minimizing the
expected value of the observable FD as in the ERM problem, we seek to
produce a state |ψ(θ)i that is aligned with the states |xi that have the
maximal empirical distribution pD(x). We can think of this objective as
the minimization of a speciﬁc distance measure between the empirical
distribution pD(x) and the model distribution p(x|θ).
Training via the minimization of a distance metric: Given its
focus on capturing the peaks of the empirical distribution pD(x), the
approach described above may fail to capture complex multi-modal
distributions. Note that similar problems arise also when considering
loss functions other than the linear loss studied above. We now review
an alternative approach that aims at addressing such limitations.

This class of methods optimizes alternative distance measures be-
tween the distribution p(x|θ) of the samples produced by the model and
the empirical distribution pD(x) in (6.57). Importantly, one should select
a distance measure that can be estimated based solely on samples from
both distributions, without requiring knowledge of either distribution.
Such methods are known as two-sample estimators.

A key example of such measures is given by integral probability
metrics (IPMs). An IPM between two distributions p(x) and q(x) is
deﬁned by the maximization

IPM(p(x), q(x)) = max
T (·)∈T

{hT (x)ip(x) − hT (x)iq(x)},

(6.58)

where diﬀerent IPMs are obtained by choosing distinct optimization
domains T . In (6.58), we have used the notation introduced in (6.23)
for the expectation of random variables, i.e., hT (x)ip(x) = P
x p(x)T (x).
Intuitively, for a ﬁxed test function T (·), the metric (6.58) measures
how distinguishable the averages of random variables T (x) are when

6.7. Unsupervised Learning for Generative Models

203

evaluated under the two distributions p(x) and q(x). The maximization
in (6.58) selects the test function that yields maximally distinct averages
within the class of functions T .

A notable example of IPMs is given by the Wasserstein distance,
for which the optimization domain T is the set of all functions that are
1-Lipschitz. A function T (·) is 1-Lipschitz if it satisﬁes the inequality
||T (x) − T (x0)|| ≤ ||x − x0|| for all x, x0 in its domain. For diﬀerentiable
functions, this condition is equivalent to the inequality ||∇T (x)|| ≤ 1 on
the gradient. Other important examples are given by the maximum
mean discrepancy and the Stein discrepancies.

When the optimization in (6.58) can be computed explicitly, as for
the maximum mean discrepancy, a two-sample estimate can be directly
obtained by averaging over the two sets of samples. More generally, the
test function T (·) can be parametrized, e.g., using a classical neural
network, and the parameters of the test function optimized to address
problem (6.58) using standard methods from classical machine learning.

Going back to the original problem of training a generative quantum
model, once one has chosen a particular IPM through the selection of
the domain T , the learning process alternates between the following
two steps:

1. Given the current model parameter θ, we generate samples x ∼
p(x|θ) from measurements of the PQC. We then use such sam-
ples, along with data set D, to estimate the distance metric
IPM(p(x|θ), pD(x)). This step requires optimizing over the test
function T (·), which may in turn entail the use of classical opti-
mization tools.

2. Given the test function T (·), the distance metric IPM(p(x|θ), pD(x))
is optimized with respect to the PQC’s parameter vector θ. Since,
for a ﬁxed function T (·), the right-hand side of (6.58) is in the
form of the stochastic optimization problem (6.24), this can be
done using the tools described in Sec. 6.5.

204

Quantum Machine Learning

6.8 Supervised Learning

In this section, we study supervised learning tasks. In such problems,
the training data set D={(x1, y1), ..., (x|D|, y|D|)} contains |D| pairs
(x, y) consisting of classical input x, in the form of a real-valued vector,
and classical target variable y. The target variable y is discrete for
classiﬁcation problems, and a real-valued for regression problems. The
goal is to optimize a predictive model mapping input x to output y
in such a way that the optimized model reﬂects well the underlying,
unknown, data distribution.

In this section, we start by discussing the most common way to
encode the input x into the quantum state produced by the PQC. Then
we cover separately probabilistic and deterministic quantum models
deﬁned from the output of a PQC.

6.8.1 Angle Encoding

A common and eﬃcient way to encode the input x into a quantum
state is via angle encoding. As illustrated in the top part of Fig. 6.15,
angle encoding deﬁnes a unitary transformation U (x, θ) that depends
on the input vector x in a manner similar to the model parameters θ.
The output state of the PQC U (x, θ), i.e.,

|ψ(x, θ)i = U (x, θ)|0i,

(6.59)

is a function of the input x, and is known as the quantum embedding
of the classical input x. The quantum embedding |ψ(x, θ)i “lifts” the
classical input x from the space of M -dimensional real vectors to a
quantum state in the 2n-dimensional Hilbert space. Note that the
embedding can be controlled via the model parameter θ.

Angle encoding adopts a PQC U (x, θ) that alternates between
unitaries dependent on input x and unitaries dependent on the model
parameter vector θ as

U (θ) = WL(θ)VL(x) · WL−1(θ)VL−1(x) · · · W1(θ)V1(x).

(6.60)

Note that, in this architecture, the data x is potentially entered multiple
times, i.e., at each layer l. This process is also known as data re-

6.8. Supervised Learning

205

uploading. Alternatively, one could also enter data x progressively,
with a diﬀerent fragment of vector x encoded at each layer.

The unitaries dependent on x and θ – i.e., Vl(x) and Wl(θ) for
l ∈ {1, ..., L} – consist of a cascade of single-qubit rotations and, possibly
parametrized, entangling gates as discussed in Sec. 6.4. The name “angle
encoding” reﬂects the standard choice of parameterized single- or two-
qubit Pauli rotations for the unitaries Vl(x), so that the entries of vector
x play the role of angles deﬁning such rotations.

The two types of unitaries, Vl(x) and Wl(θ), may follow diﬀerent
ansatzes. The rationale for this diﬀerentiation is that the ansatz selected
for the model parameters-dependent unitaries Wl(θ) should facilitate
training, particularly in light of the practical limitations of gradient-
based optimization discussed in Sec. 6.5. In contrast, the choice of the
ansatz for the input-dependent unitaries Vl(x) is typically dictated by
the expressivity of the resulting PQC as a mapping between input
and output. For instance, in some architectures, one uses single- and
two-qubit rotations to deﬁne the architecture of the unitaries Vl(x),
while ﬁxed entangling gates are used to design the unitaries Wl(θ) as in
the hardware-eﬃcient ansatz. It is also possible to consider unitaries
that directly depend on both x and θ as for a rotation gate of the form
exp(−i(θx/2)P ), where P is a Pauli operator.

In order to encode an input x = [x0, ..., xM −1] containing M real
numbers, angle encoding typically uses at least M qubits. For example,
one could use a simple mean-ﬁeld ansatz for the unitary Vl(x), with

Vl(x) = RP (x0) ⊗ · · · ⊗ RP (xM −1),

(6.61)

where RP (·) is some Pauli rotation. Accordingly, a separate rotation –
each determined by an entry of the vector x – is applied to a distinct
qubit. It is also common to follow local transformations of the form
(6.61) with other local operations

RP (g(x0)) ⊗ · · · ⊗ RP (g(xM −1)),

(6.62)

where g(·) is some non-linear function, i.e., g(x) = x2. As mentioned,
the ansatz for Vl(x) can be made more complex, and expressive, by
adding also two-qubit gates.

206

Quantum Machine Learning

We refer to Sec. 6.10 for a discussion of alternative encoding methods
that diﬀer from angle encoding in terms of number of required qubits
and information processing models.

6.8.2 Probabilistic Models

In this subsection and in the next, we consider probabilistic models
that relate input x and output y through a stochastic mapping. In
a manner that generalizes generative models, the stochastic mapping
between x and y is implicitly described by a conditional distribution
p(y|x, θ). This is in the sense that the model produces a randomized
output y ∼ p(y|x, θ) when fed with input x. We begin in this subsection
by describing the operation of such probabilistic models at a high level,
and details related to the implementation via PQC are provided in the
next subsection.

We speciﬁcally focus on probabilistic models for classiﬁcation, in
which the target variable is a binary string y ∈ {0, 1}m with m ≤ n. This
accounts for settings in which the input x belongs to one of 2m classes,
which are indexed by the binary string y. In practice, the value of m is
typically much smaller than n. For instance, for binary classiﬁcation,
one would have m = 1.

The operation of the system distinguishes between inference and
training phases. In the inference phase, the model parameters θ are
kept ﬁxed, and the model is used to classify a new, test, input x via
the randomized mapping y ∼ p(y|x, θ). In contrast, training aims at
optimizing the model parameter vector θ.
Inference: Inference in probabilistic models amounts to the random
generation of a label y ∼ p(y|x, θ) given the input x to be classiﬁed.
A single sample is suﬃcient to make a point prediction, and multiple
samples can be used if one is also interested in quantifying uncertainty.
A classiﬁer can be deemed to be more uncertain if diﬀerent runs of the
algorithm tend to yield distinct predictions y.
Training: Training of probabilistic models relies on the deﬁnition of
a loss function ‘(x, y|θ) that accounts for the accuracy of the model
p(y|x, θ) when evaluated on an input-output pair (x, y). As for generative
models, the loss function is deﬁned as a non-increasing scoring function

6.8. Supervised Learning

207

of p(y|x, θ): A model p(y|x, θ) that assigns a low probability to the label
y of a data point (x, y) is assigned a larger loss than a model p(y|x, θ)
that assigns a high probability to y. The most common scoring function
in classical machine learning is the log-loss

‘(x, y|θ) = − log p(y|x, θ),

(6.63)

which is also known as cross-entropy loss. In quantum machine learn-
ing, one often adopts the linear loss

‘(x, y|θ) = 1 − p(y|x, θ),

(6.64)

which measures the probability of error for the model when the true
label is y given input x.

The goal of training is typically deﬁned in terms of the empirical

risk minimization problem (6.49) with training loss

LD(θ) =

1

|D|

X

‘(x, y|θ).

(x,y)∈D

(6.65)

6.8.3 Probabilistic Quantum Models

As illustrated in the top part of Fig. 6.15, a probabilistic model for
classiﬁcation can be implemented via a PQC in a manner similar to
a Born machine. In this subsection, we ﬁrst discuss how to carry out
inference via probabilistic quantum models and then we describe the
problem of training such models.
Inference: Consider ﬁrst inference, and hence assume that the model
parameter vector θ is ﬁxed. Given any input x to be classiﬁed, the PQC
U (x, θ) leaves the n qubits in the quantum embedding state |ψ(x, θ)i.
To perform classiﬁcation, we need to extract a binary string y of m
cbits – the label assigned by the model to input x – from this state.
This can be done by implementing a projective measurement with 2m
possible outputs (see Sec. 5.2). For instance, for binary classiﬁcation
(m = 1), one can apply a parity measurement, whereby label y = 0 is
assigned to the subspace of states with even parity, and label y = 1
to the odd-parity subspace. We refer to Sec. 5.2.8 for a description of
parity measurements the case n = 2.

208

Quantum Machine Learning

Figure 6.15: (top) For inference, a probabilistic quantum model implements a single
run of the PQC U (x, θ), which produces a discrete label y via a projective measure-
ment. (b) For training, a classical optimizer applies doubly stochastic gradient descent
based on estimates the gradients of the expected values hψ(x, θ)|I − Πy|ψ(x, θ)i for
all examples (x, y) in a mini-batch.

averageclassical dataclassical datainferencetrainingclassical optimizer6.8. Supervised Learning

209

To formalize the outlined approach, each possible output y ∈ {0, 1}m
is assigned to a projection matrix Πy, deﬁning a projective measurement
{Πy}2m−1
y=0 . As illustrated in the top part of Fig. 6.15, a randomized
label y is produced by the circuit at inference time by making a single
measurement of the quantum embedding |ψ(x, θ)i. This way, the model
leverages shot noise for sampling, and a single run of the algorithm is
suﬃcient for inference. Note that one could also adopt a more general
POVM in lieu of a projective measurement.

By the Born rule (5.11), the outlined quantum probabilistic models
implements a stochastic mapping between x and y that is deﬁned by
the conditional probability

p(y|x, θ) = hψ(x, θ)|Πy|ψ(x, θ)i = hΠyi|ψ(x,θ)i.
As in the case of generative models, by (6.66), the probability p(y|x, θ)
equals the expectation of a data-dependent observable. Speciﬁcally, here
the observable depends on the label y, and is given by the projector Πy.
Recall that projection matrices are Hermitian, and hence they are also
observables.
Training: Adopting the linear loss (6.64), i.e.,

(6.66)

‘(x, y|θ) = 1 − p(y|x, θ) = 1 − hΠyi|ψ(x,θ)i,

(6.67)

the training loss can be written as

LD(θ) =

1

|D|

X

(x,y)∈D

hψ(x, θ)|I − Πy|ψ(x, θ)i,

(6.68)

which is the average of the expected values of observables I − Πy under
the embedding |ψ(x, θ)i across all data points (x, y) ∈ D. It follows
that the ERM problem is again in the form of a stochastic optimization,
with the caveat that the cost function involves multiple observables as
per the general form (6.20).

In practice the ERM problem is addressed via doubly stochastic
gradient descent. Accordingly, one draws a random mini-batch of
examples from the data set, and estimates the gradients of the cor-
responding expected value hψ(x, θ)|I − Πy|ψ(x, θ)i for each example
(x, y) in the mini-batch (see the bottom part of Fig. 6.15). The “dou-
ble” randomness arises from the processes of sampling both data and
measurement outcomes.

210

Quantum Machine Learning

6.8.4 Deterministic Models

In this subsection, we focus on deterministic models for supervised
learning. We consider a general formulation of such models, leaving the
details of a quantum implementation to the next subsection.

A deterministic model implements a parametrized functions h(x|θ)
of the input x. The function h(x|θ) generally returns a continuous-
valued vector. Deterministic models can be used for both regression and
classiﬁcation.
Inference: In the case of regression, the target variable y is generally
a real-valued vector. Therefore, at inference time, given an input x, the
model can directly use the output of function h(x|θ) as the estimate of
target variable y.

In the case of classiﬁcation, the target variable is the discrete-
valued index of the class. To produce an estimate of y, the output of
function h(x|θ) is passed through an activation function to produce
either a hard decision or a probability distribution over the possible
outcome values. As an example, for binary classiﬁcation, the sign of
the scalar-valued function h(x|θ) can be used to obtain a hard decision;
or we can “squash” the output h(x|θ) using, e.g., a sigmoid activation
function σ(·), to produce a probability

Pr[y = 1|x, θ] = σ(h(x|θ)) =

1
1 + exp(−h(x|θ))

(6.69)

as in logistic regression. Similarly, for multi-class classiﬁcation, the
real-valued vector output by function h(x|θ) can be fed to a softmax
activation function. This produces a vector of probabilities on the class
indices.
Training: For training, the standard approach is to tackle the ERM
problem (6.49) with training loss (6.65). For example, for regression
with a scalar target variable y, one can adopt the squared loss

‘(x, y|θ) = (y − h(x|θ))2;

(6.70)

while, for binary classiﬁcation with activation function (6.69), one can
choose the cross-entropy loss

‘(x, y|θ) = −y log σ(h(x|θ)) − (1 − y) log σ(−h(x|θ)).

(6.71)

6.8. Supervised Learning

211

6.8.5 Deterministic Quantum Models

In this subsection, we discuss how PQCs can be used to implement
deterministic models for supervised learning by covering both inference
and training phases.
Inference: As illustrated in the top part of Fig. 6.16, a PQC can be
used to implement a deterministic function hM (x|θ) by measuring the
expected value of an observable M under the quantum embedding
|ψ(x, θ)i. Accordingly, given an input x, the PQC is run multiple times
in order to estimate the expectation

hM (x|θ) = hψ(x, θ)|M |ψ(x, θ)i = hM i|ψ(x,θ)i,

(6.72)

where we have made explicit the dependence of the function hM (x|θ) on
the observable M . The function hM (x|θ) can then be used as described
in the previous subsection to carry out regression and classiﬁcation
decisions. Note that vector-valued functions hM (x|θ) can be similarly
implemented by measuring multiple observables, one for each entry of
the output vector.

Importantly, unlike probabilistic models, deterministic models re-
quire multiple runs of the PQC in order to mitigate the eﬀect of shot
noise in estimating the expectation (6.72) even during inference.

Function hM (x|θ) in (6.72) can be rewritten as

hM (x|θ) = tr(M ρ(x, θ)),

(6.73)

where we have deﬁned the density matrix ρ(x, θ) = |ψ(x, θ)ihψ(x, θ)|.
This expression makes it clear that the function hM (x|θ) is linear in the
embedding density state ρ(x, θ). Therefore, a deterministic quantum
model eﬀectively implements a linear discriminative function in the
space of quantum density embeddings, whose weights are deﬁned by
the choice of the observable M . As such, deterministic quantum models
are akin to classical kernel methods in that they operate over a large
feature space – the Hilbert space of dimension 2n – via linear operations.
Training: Having deﬁned the model output function as in (6.72), the
loss functions can be directly introduced as detailed in the previous
subsection. To elaborate, let us consider the problem of scalar regression

212

Quantum Machine Learning

Figure 6.16: (top) For inference, a deterministic quantum model implements
multiple runs of the PQC U (x, θ) to estimate the expected value of an observable
M (or multiple observables). (bottom) For training, a classical optimizer can apply
gradient descent based on estimates of the expectations of observable M .

averageclassical dataclassical datainferencetrainingclassical optimizeraverage6.9. Beyond Generic Ansatzes

213

with the quadratic loss function (6.70). In this case, we have

‘(x, y|θ) = (y − hM (x|θ))2

= (y − hM i|ψ(x,θ)i)2,

(6.74)

which is a function of the expected value hM i|ψ(x,θ)i of observable M ,
as well as of the target variable y. This is illustrated in the bottom part
of Fig. 6.16.

Given this dependence on the expectation of an observable, the
ERM problem can be addressed by using the optimization methods
discussed in Sec. 6.5. For example, for the quadratic loss (6.74), the
gradient of the loss is given as

∇‘(x, y|θ) = −2(y − hM i|ψ(x,θ)i)∇hM i|ψ(x,θ)i,

(6.75)

where the gradient of the observable can be estimated using the param-
eter shift rule.

6.9 Beyond Generic Ansatzes

In Sec. 6.4, we have discussed generic ansatzes that may be broadly
applied to a variety of problems. In some settings, one can choose
specialized ansatzes that follow a more principled approach that is
tailored to the given problem. In this section, we review two ways to
pursue this approach:

• mimic the operation of classical neural networks, while maintaining
the superposition of the quantum states being processed; and

• relax and parametrize a quantum algorithm designed using a

traditional, formal methodology.

6.9.1 Mimicking Classical Neural Networks

Consider ﬁrst the class of ansatzes that aims at mimicking the way in
which neurons operate in a classical neural network. A classical neuron
produces an output as a function g (P
k wkxk) of a linear combination
P
k wkxk, with weights {wk}, of the scalar inputs {xk} to the neuron.

214

Quantum Machine Learning

Activation functions g(·) include the sigmoid function σ(a) = (1 +
exp(−a))−1 and the rectiﬁed linear unit (ReLU) max(0, ·).

A quantum neuron mimicking the operation of a classical determinis-
tic neuron would produce an output encoding the quantity g (P
k wkxk)
when the inputs are in the computational basis, i.e., classical, while
also being able to operate on superposition states. Implementing such
a neuron is not straightforward due to the linearity of quantum evolu-
tions, and it typically requires the introduction of mechanisms involving
repeated measurements and measurement-controlled operations.

As an alternative, a classical probabilistic neuron produces random-
ized outputs whose probabilities depend on non-linear functions of the
linear combination P
k wkxk. An example is given by a binary neuron
that outputs 1 with probability σ (P
k wkxk), and 0 otherwise. Classical
neurons of this type can be implemented by using measurements as ex-
plained in Sec. 3.2.5. Note that such measurements destroy superposition
and entanglement.

In both cases, multiple neurons can be combined in diﬀerent archi-
tectures, which may involve multiple layers and/or recurrent processing.

6.9.2 Relaxing Handcrafted Quantum Algorithms

An example of the second type of approaches, which relax and parametrize
a handcrafted quantum algorithm, is given by the Quantum Approxi-
mate Optimization Algorithm (QAOA). Speciﬁcally, QAOA provides a
problem-dependent ansatz for the VQE as applied to an Ising Hamil-
tonian (see Sec. 6.6.4). QAOA uses knowledge of the loss function
observable F in (6.34) to deﬁne the ansatz of the quantum circuit U (θ)
producing the state |ψ(θ)i. The ansatz assumed by QAOA consists of
a ﬁrst layer of Hadamard gates, producing the state |+i ⊗ |+i · · · |+i,
followed by multiple layers. Each layer alternates between the unitary
U (F, γ) = exp(−iγF ) dependent on the Ising Hamiltonian F and the
unitary U (B, β) = exp(−iβB), where B = Pn−1
k=0 Xk with Xk being the
Pauli X operator applied to the k-th qubit. Parameters γ and β can
be optimized. The circuit provides an asymptotic approximation of the
so-called quantum adiabatic algorithm as the number of layers goes to
inﬁnity.

6.10. Beyond Angle Encoding

215

6.10 Beyond Angle Encoding

In this chapter we have so far adopted angle encoding as a mechanism
to convert classical information, in the form of a real vector x, into a
quantum state. As we have introduced in Sec. 6.8.1, angle encoding
is an analog strategy in which the M entries of vector x are directly
mapped into the continuous-valued angles of at least M parametrized
quantum gates. In this section, we brieﬂy review two alternative ways
to encode classical information in a quantum state, and we also give an
example of the type of inference methods that may be enabled by such
methods.

6.10.1 Amplitude Encoding

Like angle encoding, amplitude encoding is an analog strategy, which is,
however, exponentially more eﬃcient in terms of the number of required
qubits. Amplitude encoding maps each entry xk of vector x into the
k-th amplitude of a quantum state. Accordingly, the encoded state, or
quantum embedding, for data vector x is

|ψ(x)i =

M −1
X

k=0

f (xk)|ki,

(6.76)

where f (·) is some function that ensures the normalization condition
PM −1
k=0 |f (xk)|2 = 1. This equality may be guaranteed, e.g., by setting
f (xk) = 1/(2n/2) exp(ixk); or by normalizing vector x and then setting
f (x) = ¯x, where ¯x = x/||x||2.

2

Amplitude encoding requires a number of qubits, n, equal to the
(M ) (assuming that
logarithm of the size of the input, i.e., n = log
log
(M ) is an integer). This provides an exponential improvement in
terms of eﬃciency of the input representation with respect to angle
encoding. The computational complexity of amplitude encoding – that
is, the number of quantum operations necessary to produce state (6.76)
– is, however, generally linear in the size M of the input as for angle
encoding.

2

216

Quantum Machine Learning

6.10.2 Basis Encoding

Unlike angle and amplitude encoding, basis encoding is a digital strat-
egy, and it enables the encoding of an entire data set D of data points
x into a single quantum state. As we detail next, the number of qubits
dictates the resolution of the representation of the input x.

Basis encoding ﬁrst converts each data point x in the binary domain,
producing a binary string xb ∈ {0, 1}n. Note that the number of bits n
determines the precision level of the binary representation. Then, the
entire data set D is mapped to the quantum state

|ψ(D)i =

1

Z

X

x∈D

|xbi,

(6.77)

where Z is a suitable constant to ensure a unitary norm. State (6.77)
encodes a superposition of all entries of the data set D.

6.10.3 Non-Parametric Quantum Machine Learning

How can quantum states such as (6.77) be used in machine learning
applications? In this section, we outline an approach for density esti-
mation that is akin to non-parametric methods in classical machine
learning. This is in the sense that the approach makes decisions by
using the entire data set, in the form of state (6.77), without requiring
a training stage.

Given a data set D={x1, ..., x|D|} of |D| samples, density estimation
aims at estimating the probability distribution p(x) underlying the
generation of the data. Consider a new point x∗ at which we would
like to estimate the distribution p(x∗). Intuitively, the probability p(x∗)
should be larger the more “similar” vector x∗ is to the data points in
the training set D. Therefore, one can conceive the use of the inner
product

ˆp(x∗) ∝ |hψ(x∗)|ψ(D)i|2

(6.78)

as a non-parametric (unnormalized) estimate of probability distribution
p(x∗). The estimate ˆp(x∗) can be evaluated as described in Sec. 3.2.5.

6.11. Conclusions

6.11 Conclusions

217

This chapter has provided an introduction to quantum machine learning,
focusing on the most common setting in which data are classical and
processing is quantum. For this “CQ” case, a parametrized quantum
circuit (PQC) is optimized via a classical processor by minimizing
functions of the expected values of some observables, as well as of
(classical) data. Gradient-based optimization for PQCs is signiﬁcantly
less eﬃcient than its counterpart for standard machine learning models.
In fact, estimating the gradient entails a complexity that scales linearly
with the number of model parameters. Furthermore, it requires multiple
runs through the model in order to mitigate shot noise due to the
inherent randomness of quantum measurements.

The ineﬃciency in estimating gradients is one of the many diﬀer-
ences between the ﬁelds of quantum and classical machine learning.
While classical machine learning is typically applied to unstructured,
large data sets with the goal of maximizing accuracy, “CQ” quantum
machine learning is often applied to small, well-structured, data sets,
and quantum advantages are often measured in terms of eﬃciency.
Eﬃciency is evaluated in terms of the number of physical resources
needed to implement a model: number of model parameters, number
of bits/ qubits, training time, inference time, and so on. While it is
possible to prove such advantages for very speciﬁc problems, the cur-
rent practice appears to be that of making limited comparisons via
heuristic arguments and experiments, or by sidestepping the question
of “quantum advantages” altogether.

Rather than focusing on establishing formal advantages, research in
the ﬁeld of quantum machine learning may focus on establishing eﬀective
building blocks for quantum machine learning models; understanding
the relative merits of deterministic and probabilistic models; evaluating
the impact of diﬀerent data encoding techniques; developing eﬀective
software platforms; and investigating at a theoretical level the problem
of generalization for given ansatzes.

218

Quantum Machine Learning

6.12 Recommended Resources

Quantum machine learning is an emerging, very active, ﬁeld of research.
A useful starting point is the book [13], which contains many pointers
to papers published before 2021. Monte Carlo estimates of gradients in
classical machine learning are reviewed in [14], [15]. The barren plateaus
problem is detailed in [16]. An example of QC machine learning is pro-
vided by [17]. Quantum generative adversarial networks are presented in
[18]; while quantum variational autoencoders for quantum compression
are studied in [19]. Hybrid classical-quantum machine learning models
are studied in [20]. For more recent work, the reader is referred to the
online repository arXiv (https://arxiv.org/), in which most up-to-date
pre-prints can be found.

6.13 Problems

1. Write the matrix representation (in the computational basis) of the
(cid:17). Which
three unitaries Z ⊗Z, CZ, and RZZ(θ) = exp (cid:16)
one(s) amount to local operations and why? Obtain eigenvalues
and eigenvectors. Which one(s) are also observables?

2 Z ⊗ Z

−i θ

2. Show that the Pauli ZZ-rotation can be implemented using two

CNOT gates and a Pauli Z-rotation.

3. Prove that using only Pauli Y -rotations allows the mean-ﬁeld
ansatz to produce all possible vectors in the computational basis.

4. Describe the quantum adiabatic theorem and the quantum adia-

batic algorithm (see recommended resources).

5. Derive the parameter shift rule (see Appendix B).

6. Demonstrate some practical examples of applications of quan-
tum machine learning methods. (You can browse arXiv or other
repositories.)

7. Describe an example of a QQ machine learning problem.

6.13. Problems

219

Appendix A: On Unitaries with Pauli Strings as Generators

In this appendix, we derive some useful properties of parametrized
unitaries whose generators are given by Pauli strings. Examples include
single-qubit and two-qubit Pauli rotation gates. Such unitaries can be
written as

U (θ) = exp

(cid:18)

−i

(cid:19)

,

θ
2 P

(6.79)

where P is a Pauli string.

A Pauli string P has two distinct eigenvalues +1 and −1. Therefore,
it can be expressed as P = Π0 − Π1, where Π0 = P
x: λx = 1 vx is
the projection matrix into the subspace spanned by the eigenvectors
|vxi of matrix P that are associated with eigenvalues λx = 1, and
Π1 = P
x: λx = −1 vx is the projection matrix into the subspace spanned
by the eigenvectors |vxi associated with eigenvalues λx = −1. Note that
we have the equality Π0 + Π1 = I, since the set of all eigenvectors span
the entire Hilbert space.

Given the above, and using the deﬁnition (1.47) of a function of a

normal matrix, we obtain the equality

U (θ) =

exp

(cid:18)

−i

2n−1
X

x=0

(cid:19)

vx

θ
2 λx
(cid:19)

= Π0 exp

(cid:18)

−i

= Π0

(cid:18)

cos

(cid:18) θ
2

θ
2
(cid:19)

+ Π1 exp
(cid:18) θ
2

− i sin

(cid:19)

(cid:18)
i

θ
2

(cid:19)(cid:19)

= cos

= cos

(cid:19)

(cid:19)

(cid:18) θ
2
(cid:18) θ
2

(Π0 + Π1) − i sin
(cid:18) θ
2

I − i sin

P.

(cid:19)

(cid:18)

cos

(cid:19)

(cid:18) θ
2

+ i sin

(cid:19)(cid:19)

(cid:18) θ
2

+ Π1
(cid:19)
(cid:18) θ
2

(Π0 − Π1)

Note that if we set θ = ±π/2, we get the equality

(cid:19)

(cid:18)

±

π
2

U

=

1
√
2

(I ∓ iP ) .

(6.80)

(6.81)

220

Quantum Machine Learning

Appendix B: The Parameter Shift Rule

Consider one of the scalar parameters of the parameter vector θ =
[θ1, ..., θD]T , say θd for some d ∈ {1, ..., D}. We are interested in com-
puting the partial derivative ∂hOi|ψ(θ)i/∂θd for the expectation

hOi|ψ(θ)i = hψ(θ)|O|ψ(θ)i = h0|U †(θ)OU (θ)|0i

(6.82)

of some observable O under the output state U (θ)|0i produced by a
PQC. Note that, in some cases, the unitary U (θ) may also be a function
of the input data x, and this can be easily accommodated in the analysis
by considering unitaries of the form U (x, θ). We also observe that loss
functions of the form (6.82) are also relevant for QQ problems, in which
the observable O may depend on the target quantum state.

As discussed in this chapter, in many PQCs of interest, parameter

θd enters as part of the overall unitary in a single gate of the form

Ud(θd) = exp

(cid:18)

−i

θd
2 Gd

(cid:19)

,

(6.83)

where Gd is the generator Hermitian matrix. Examples of gates (6.83)
include the Pauli rotation matrices used in the hardware-eﬃcient ansatz.
If the parameter θd entered multiple gates of the form (6.83), the
corresponding partial derivatives to be calculated in this appendix
would need to be summed.

According to the assumption stated in the previous paragraph, we

can write the overall unitary transformation as

U (θ) = V (θ−d)Ud(θd)W (θ−d)

(6.84)

for some unitaries V (θ−d) and W (θ−d) representing the gates applied
before and after the d-th gate Ud(θd). Unitaries V (θ−d) and W (θ−d)
generally depend on the parameters in vector θ other than the parameter
θd. This dependence is captured by the notation θ−d.
Using (6.84), we write the expected observable as

hOi|ψ(θ)i = hφd|U †
d
where |φdi = W (θ−d)|0i and Rd = V (θ−d)†OV (θ−d). Note that matrix
Rd is Hermitian. This way, we have incorporated gates following and

(θd)RdUd(θd)|φdi,

(6.85)

6.13. Problems

221

preceding the d-th gate in the quantum state |φdi and in the observable
Rd, respectively. The subscript in |φdi and Rd is used to emphasize that
both quantities depend on the index d.

The partial derivative is computed as

∂hOi|ψ(θ)i
∂θd

= ∂hφd|U †

d

(θd)RdUd(θd)|φdi

∂θd

=hφd|U †
d

(θd)Rd∇θdUd(θd)|φdi

+ hφd|∇θdU †

d

(θd)RdUd(θd)|φdi,

(6.86)

where ∇θdUd(θd) represents the matrix of derivatives of the unitary
Ud(θd), and a similar deﬁnition applies to ∇θdU †

(θd). We have

d

(cid:18)

exp

∇θdUd(θd) = ∇θd
1
2 iGd exp

= −

−i

(cid:18)

(cid:19)

θd
2 Gd
θd
2 Gd

−i

(cid:19)

= −

1
2 iGdUd(θd)

and

∇θdU †
We conclude that the following equalities hold

2 GdU †

(θd).

d

d

(θd) = i

Ud(θd) + 2∇θdUd(θd) = Ud(θd) − iGdUd(θd)

√

= (I − iGd)Ud(θd)
=

2Ud(π/2)Ud(θd)
2Ud(θd + π/2),

√

=

(6.87)

(6.88)

(6.89)

where we have used (6.81) for the third equality. Similarly, we have

Ud(θd) − 2∇θdUd(θd) =

√

2Ud(−π/2)Ud(θd) =

√

2Ud(θd − π/2). (6.90)

Finally, we write the partial derivative (6.86) as

∂hOi|ψ(θ)i
∂θd

=

1
4 hφd|(Ud(θd) + 2∇θdUd(θd))†Rd(Ud(θd) + 2∇θdUd(θd))|φdi

1
4 hφd|(Ud(θd) − 2∇θdUd(θd))†Rd(Ud(θd) − 2∇θdUd(θd))|φdi,

−
1
2 hφd|Ud(θd + π/2)†RdUd(θd + π/2)|φdi

=

1
2 hφd|Ud(θd − π/2)†RdUd(θd − π/2)|φdi,

−

(6.91)

222

Quantum Machine Learning

where the ﬁrst equality can be checked by direct comparison with (6.86),
and the second equality follows from (6.89)-(6.90). This concludes the
derivation.

Acknowledgements

I would like to thank Prof. Lajos Hanzo for the inspiration, as well as
Prof. Bipin Rajendran, Dr. Hari Chittoor, Dr. Sharu Jose, and Dr. Ivana
Nikoloska, who have been ideal companions during my ongoing journey
of discovery of the ﬁeld of quantum machine learning. My gratitude
goes also to the other members of my research team at King’s who have
provided useful feedback, comments, and encouragement: Kﬁr Cohen,
Dr. Sangwoo Park, Clement Ruah, and Matteo Zecchin.

223

References

[1] N. D. Mermin, Quantum computer science: an introduction. Cam-

bridge University Press, 2007.

[2] R. J. Lipton and K. W. Regan, Introduction to quantum algorithms

via linear algebra. MIT Press, 2021.

[3] M. A. Nielsen and I. L. Chuang, Quantum computation and

quantum information. Cambridge University Press, 2010.

[4] L. Susskind and A. Friedman, Quantum mechanics: the theoretical

minimum. Basic Books, 2014.

[5] R. Penrose, The road to reality: A complete guide to the laws of

the universe. Random House, 2005.

[6] C. J. Wood, J. D. Biamonte, and D. G. Cory, “Tensor networks
and graphical calculus for open quantum systems,” arXiv preprint
arXiv:1111.6950, 2011.

[7] M. M. Wilde, Quantum information theory. Cambridge University

Press, 2013.

[8] J. Watrous, The theory of quantum information. Cambridge Uni-

versity Press, 2018.

[9] P. Kaye, R. Laﬂamme, and M. Mosca, An introduction to quantum

computing. Oxford Uuniversity Press, 2006.

[10] J. A. Bergou, M. Hillery, and M. Saﬀman, Quantum information

processing. Springer, 2021.

224

References

225

[11] J. D. Hidary and J. D. Hidary, Quantum computing: an applied

approach, vol. 1. Springer, 2019.

[12] P. P. Rohde, The quantum Internet: The second quantum revolu-

tion. Cambridge University Press, 2021.

[13] M. Schuld and F. Petruccione, Machine learning with quantum

computers. Springer, 2021.

[14] S. Mohamed, M. Rosca, M. Figurnov, and A. Mnih, “Monte
Carlo gradient estimation in machine learning,” Journal Machine
Learning Research, vol. 21, no. 132, 2020, pp. 1–62.

[15] O. Simeone, Machine learning for engineers. Cambridge University

Press, 2022.

[16] J. R. McClean, S. Boixo, V. N. Smelyanskiy, R. Babbush, and
H. Neven, “Barren plateaus in quantum neural network training
landscapes,” Nature Communications, vol. 9, no. 1, 2018, pp. 1–6.
[17] A. Youssry, C. Ferrie, and M. Tomamichel, “Eﬃcient online
quantum state estimation using a matrix-exponentiated gradient
method,” New Journal of Physics, vol. 21, no. 3, 2019.

[18] S. Lloyd and C. Weedbrook, “Quantum generative adversarial
learning,” Physical Review Letters, vol. 121, no. 4, 2018.
[19] J. Romero, J. P. Olson, and A. Aspuru-Guzik, “Quantum au-
toencoders for eﬃcient compression of quantum data,” Quantum
Science and Technology, vol. 2, no. 4, 2017.

[20] M. Benedetti, J. Realpe-Gómez, and A. Perdomo-Ortiz, “Quantum-
assisted Helmholtz machines: A quantum–classical deep learning
framework for industrial datasets in near-term devices,” Quantum
Science and Technology, vol. 3, no. 3, 2018, p. 034 007.

