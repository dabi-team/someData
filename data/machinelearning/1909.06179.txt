9
1
0
2

p
e
S
1
1

]
T
E
.
s
c
[

1
v
9
7
1
6
0
.
9
0
9
1
:
v
i
X
r
a

Parallel fault-tolerant programming of an arbitrary feedforward photonic network

Sunil Pai,1, ∗ Ian A. D. Williamson,1 Tyler W. Hughes,2
Momchil Minkov,1 Olav Solgaard,1 Shanhui Fan,1 and David A. B. Miller1
1Department of Electrical Engineering, Stanford University, Stanford, CA 94305, USA
2Department of Applied Physics, Stanford University, Stanford, CA 94305, USA

Reconﬁgurable photonic mesh networks of tunable beamsplitter nodes can linearly transform
N -dimensional vectors representing input modal amplitudes of light for applications such as energy-
eﬃcient machine learning hardware, quantum information processing, and mode demultiplexing.
Such photonic meshes are typically programmed and/or calibrated by tuning or characterizing each
beam splitter one-by-one, which can be time-consuming and can limit scaling to larger meshes. Here
we introduce a graph-topological approach that deﬁnes the general class of feedforward networks
commonly used in such applications and identiﬁes columns of non-interacting nodes that can be
adjusted simultaneously. By virtue of this approach, we can calculate the necessary input vectors
to program entire columns of nodes in parallel by simultaneously nullifying the power in one output
of each node via optoelectronic feedback onto adjustable phase shifters or couplers. This parallel
nulliﬁcation approach is fault-tolerant to fabrication errors, requiring no prior knowledge or calibra-
tion of the node parameters, and can reduce the programming time by a factor of order N to being
proportional to the optical depth (or number of node columns in the device). As a demonstration,
we simulate our programming protocol on a feedforward optical neural network model trained to
classify handwritten digit images from the MNIST dataset with up to 98% validation accuracy.

I.

INTRODUCTION

Feedforward networks of tunable beamsplitters or
“nodes”, typically implemented as meshes of Mach-
Zehnder interferometers (MZIs), can perform linear op-
erations on sets or “vectors” of N optical inputs in N
single-mode waveguides [1–3]. With advances in pho-
tonic integration, these networks have found a wide range
of classical and quantum photonic applications where
the mesh is conﬁgured to implement some speciﬁc lin-
ear transform or matrix. Some applications, like mode
unscrambling in optical communications [4], favor a self-
conﬁguring approach [2, 5] in which the mesh sets it-
self up in real time to implement the matrix that un-
does the mixing. Other applications, including photonic
neural networks [6], universal linear quantum comput-
ing [3], and photon random walks [7], may need to have
the mesh implement some speciﬁc matrix that is calcu-
lated externally. These applications promise fast and
energy-eﬃcient matrix multiplication or analog computa-
tion via the physical process of light propagating through
programmed nodes that can arbitrarily redistribute that
light. For such applications, we will demonstrate how the
nodes in an arbitrary feedforward network (e.g., the sim-
ple grid network of Fig. 1) can be eﬃciently programmed
in a fault-tolerant manner to implement a desired matrix
operator.

Though it is straightforward to calculate phase shifts
and/or beamsplitter split ratios to implement a matrix
in such a mesh, any ﬁxed fabrication of such settings is
challenging for large meshes due to the precise settings
required [8]. For example, these errors limit the classiﬁca-
tion accuracy of optical neural networks [6, 9] and prevent

∗ sunilpai@stanford.edu

scaling up the number of components in quantum linear
optical circuits [3, 8]. We therefore prefer reconﬁgurable
beamsplitter nodes in such networks and corresponding
setup algorithms that can directly program desired ma-
trices.

Such setup algorithms also let us fully calibrate the
nodes; ﬁnding the voltage drive settings for any pro-
grammed node subsequently allows us to interpolate
among those settings to implement desired matrices by
applying appropriate voltages directly. Although each
node can be individually calibrated in some speciﬁc ar-
chitectures [3, 10], this approach is slow for large-scale
meshes and must be repeated if components experience
environmental drift. Here, we show an approach that can
greatly reduce the time required for such setup and/or
calibration processes and also generalizes to any feedfor-
ward mesh (i.e., where light propagates unidirectionally).
By exploiting a graph-topological approach, we identify
which nodes can be programmed simultaneously and pro-
vide the necessary parallelized algorithm to reduce the
setup time by a factor of order N .

One general setup approach that does not require prior
knowledge of each node’s parameters is based on what
could be called “nulliﬁcation.” By speciﬁc choices of N
input modes (amplitude and phase) sent into N input
waveguides, corresponding nodes can be programmed by
nullifying power at one of their outputs by optoelectronic
feedback control [2, 4, 11, 12]. For example, networks
made from one or more diagonal sets of nodes [2] are
programmed using nulliﬁcation. One such diagonal gives
a self-aligning beam coupler [5], and multiple diagonals
can be cascaded to form triangular grid networks (as
in the Reck scheme [1, 2, 4]) that implement arbitrary
N × N unitary matrices. The appropriate input vectors
programming such meshes are then the complex conju-
gates of the rows of the target unitary matrix [2, 4].

 
 
 
 
 
 
More generally, other feedforward networks, such as
rectangular grids (Clements scheme [13]), may not sup-
port self-conﬁguration, so some separate design calcula-
tion must be performed to calculate the desired parame-
ters of each node. Nonetheless, with the knowledge of the
desired node parameters, such networks can be progres-
sively conﬁgured using the reversed local light interfer-
ence method (RELLIM) nulliﬁcation approach proposed
in Ref. 11. A key question is whether we can mini-
mize the total time required to program or calibrate the
network. The self-conﬁguring algorithm for diagonal or
triangular meshes and the RELLIM algorithm as origi-
nally conceived [11] give prescriptions for setting up the
nodes sequentially (i.e., one-at-a-time) and thus require
a number of steps equal to the number of nodes.

In this paper, we propose a graph-topological frame-
work that arranges any given feedforward network into
columns of nodes that can be programmed simultane-
ously, with just one “nulliﬁcation set” input vector for
the entire column, rather than programming one node at
a time with possibly diﬀerent input vectors for each such
node. The resulting “parallel nulliﬁcation” or parallel
RELLIM (“PRELLIM”) protocol uses up to (N/2)-times
fewer calibration steps and input vectors than RELLIM,
where N is the number of input modes to the system.
Our protocol ultimately enables eﬃcient, fault-tolerant,
ﬂexible, and scalable calibration (with time complexity
of the number of columns in the device) of an arbitrary
feedforward photonic mesh architecture. Example such
architectures include triangular [1, 2] and rectangular [13]
grid networks (capable of implementing arbitrary unitary
matrices) and butterﬂy [8, 9] networks (capable of imple-
menting any permutation or DFT unitary matrices).

We outline a typical scenario that beneﬁts from paral-
lel nulliﬁcation in Fig. 1(a), where a model of an optical
network stored in a digital computer (e.g. a CPU-trained
optical neural network) must be programmed into a pho-
tonic circuit. The model consists of the network topology
(node connection patterns) and tunable node parame-
ters used to calculate the nulliﬁcation set vectors for cal-
ibration. The parallel nulliﬁcation procedure shown in
Fig. 1(b), consists of calibrating the mesh one column
at a time using the nulliﬁcation set and tuning all nodes
within each column in parallel until their bottom out-
puts are all nulliﬁed (i.e. transmit zero power). In Fig.
1(c), we show that after parallel nulliﬁcation is applied
to all columns, our device matches the computer model
as accurately as physically possible.

The remainder of this paper is organized as follows.
In Section II, we lay out the foundations of our graph-
topological framework used to formally deﬁne a general
feedforward photonic mesh. In Section III, we propose
our parallel nulliﬁcation protocol and demonstrate how
our protocol can deploy machine learning models on op-
tical neural networks in Section IV. We then more gen-
erally discuss fault-tolerant performance of parallel nul-
liﬁcation in presence of systematic errors in Section V.

2

FIG. 1. (a) Prior to programming the mesh to desired phys-
ical operator (cid:98)U (shown as unprogrammed in red), we have
our corresponding calculated mesh model U (connectivity and
tunable parameters) stored in the computer. (b) From U , we
calculate a set of nulliﬁcation vectors (the nulliﬁcation set),
and then shine in corresponding physical mode vectors from
this set sequentially (Input 1, Input 2 and Input 3). We tune
the beamsplitter parameters of the corresponding column (de-
noted by purple dots) by nullifying power at all sampling pho-
todetectors (denoted by purple crosses) in the column in par-
allel. (c) After this programming, we are guaranteed that our
experimental realization and computer model match up to an
output phase reference, i.e. (cid:98)U ≡ U (denoted as programmed
in green).

II. FEEDFORWARD PHOTONIC NETWORK

In this section, we introduce some required mathemat-
ical and graph-topological terminology and concepts for
feedforward photonic networks. For any such network
with N input and output waveguides, there is a linear de-
vice operator [14, 15] or matrix U relating the input and
output waveguide amplitudes for monochromatic light at
steady state. Because we are considering feedforward
networks, by choice we consider only the forward am-
plitudes in all waveguides. With a set of N amplitudes
in the input waveguides, represented by the input mode
vector vin ∈ CN (the nth element stores the amplitude
and phase of the input mode in waveguide n), and a cor-
responding vector of output mode amplitudes vout, then
vout = U vin as shown in Fig. 1. Since we presume no
backwards waves, U can be considered to be an N × N

transmission matrix. Each individual tunable beamsplit-
ter node (depicted by dots in Fig. 1) can similarly be
described by a 2 × 2 transmission matrix T2 that de-
scribes how the light in its two input waveguide ports is
distributed across its two output ports.

Based on the graph-topological arguments of this sec-
tion, we always arrive at a compact deﬁnition for U in
terms of node columns that can each be programmed in
a single step as suggested by Fig. 1. For example, the
triangular grid mesh [1] can be programmed in 2N steps
(as opposed to the typical N (N −1)/2 steps), the rectan-
gular grid mesh [13] in N steps, and the butterﬂy mesh
[8] in log N steps.

A. Nodes

Each node of the feedforward network is a 2 × 2 tun-
able beamsplitter whose requirement is to be able to ar-
bitrarily redistribute light. This is accomplished by con-
catenating a phase shifter (SP(φ)) to a tunable coupler
(SA(θ)) resulting in the transmission matrix T2:

T2(θ, φ) = SA(θ)SP(φ) ≡ i

(cid:20)eiφ sin θ
2
eiφ cos θ

cos θ
2
2 − sin θ

2

(cid:21)

,

(1)

where θ ∈ [0, π] and φ ∈ [0, 2π). By notation “≡,” we
note that there are many equivalent constructions of T2
provided explicitly in Appendix E, which have math-
ematically diﬀerent, but functionally equivalent, repre-
sentations including tunable directional couplers (TDCs)
and Mach-Zehnder interferometers (MZIs).

Parallel nulliﬁcation is agnostic of the exact modula-
tion schemes for SP and SA, as long as SP corresponds
to a controllable phase diﬀerence between the two input
waveguides (so a diﬀerential phase) and SA covers the
full range of transmissivities (bar state or θ = π to cross
state or θ = 0).

In an N -port device, to represent the eﬀect of one 2×2
element we may embed the 2 × 2 transmission matrix T2
along the diagonal of an otherwise N × N identity ma-
trix. Formally, this would allow the resulting embedded
operation T [m]
N to operate between modes in waveguides
2m − 1 and 2m (a Givens rotation) as follows:













1 · · ·
...
. . .
0 · · ·
0 · · ·
...
0 · · ·

2m − 1 2m

0
...
T11
T21
...
0



0 · · · 0
...
...



T12 · · · 0 2m − 1


T22 · · · 0 2m


...
...
. . .


0 · · · 1

.

(2)

T [m]
N :=

3

FIG. 2. From “left” to “right,” we mathematically propa-
gate a 5-mode vector of amplitudes (time-ordered waveguide
traversal of orange dots) on an arbitrary N = 5 feedforward
mesh (a) over panels (b) - (e) to generate the ﬁnal com-
pact, “layered” conﬁguration of this mesh in panel (f). The
numbers indicate the time step in which the nodes (shaded
by a colored circle) are being traversed (i.e., simultaneously
conﬁgured), and these numbers ultimately correspond to the
columns (or time steps) to which nodes traversed at that step
belong. The rule in the traversal is that two orange dots need
to be at the input of a given node before that node can be
traversed (i.e., the orange dots advance past the node) for
that time step. (Note at the top of column 3 we have two
waveguides crossing; there is no node at this crossing, and
the waveguides cross without any interaction.)

B. Graph-topological framework

We typically make photonic mesh networks in a grid-
like manner [1, 2, 13] for eﬃciency and compactness in
fabrication. This also can allow equal path lengths if
we want to make the interference relatively insensitive to
wavelength changes. Conﬁguring the nodes of the net-
work takes much longer than the time for light to prop-
agate through the network. So, for the purposes of an-
alyzing more general feedforward networks, we can con-
sider monochromatic, continuous-wave light such that ac-
tual optical distances and geometrical arrangements are
unimportant for calibration and programming of the net-
work.

In contrast, the “network topology” (i.e., connectivity
independent of lengths of inter-node links) is important
for deﬁning valid feedforward conﬁgurations and the re-
quired inputs and node sequence by which we can pro-
gressively program or calibrate the network. We could
mathematically view the inter-node links of the network
as made of ﬂexible (and stretchable) ﬁbers between nodes
that can move in space as long as the network topol-
ogy is not changed. As such, we represent the notion of
light moving “forward” or left-to-right (independent of
the physical node locations in space) as moving along a
given ﬁber away from network inputs or node outputs,

which we deﬁne to be on the “left,” and towards net-
work outputs or node inputs, which we deﬁne to be on
the “right.” We will ultimately examine grouping nodes
into “columns” to establish which nodes can be conﬁg-
ured simultaneously or within the same propagation time
step.

In such a graph-topological view, we can propose a
sequential constructive deﬁnition that generates any ar-
bitrary feedforward mesh network. As represented in
the example in Fig. 2(a), we start with N = 5 input
waveguides or ﬁbers on the physical left (though this po-
sitioning is arbitrary). In constructing the network, we
perform node addition by interfering any chosen pair of
waveguides or ﬁbers at the inputs of a node to generate
outputs from that node. We assume light ﬂows forward,
so at any subsequent (further to the right) node addition,
we interfere any two waveguides that exit earlier (further
to the left) nodes. In this way, given a suﬃcient number
of nodes and arbitrary choice of waveguides to couple,
we can generate any feedforward mesh architecture. Fur-
thermore, rather than adding a single node at a time
in our construction, we can add at most M := (cid:98)N/2(cid:99)
nodes at a time (where (cid:98)x(cid:99) represents the largest integer
less than or equal to x) to account for the largest num-
ber of waveguides that can be simultaneously coupled.
The resulting architecture is shown in Fig. 2(f) where
we maintain the feedforward property that propagation
along the N = 5 waveguides always crosses the dotted
vertical lines from left-to-right. This results in what we
will deﬁne as the most “compact” representation, resem-
bling more closely some of the commonly known rectan-
gular and triangular feedforward architectures [1, 13].

It can be helpful to ﬁnd this compact representation of
Fig. 2(f) starting from the more arbitrary layout of Fig.
2(a) using a “topological sort” or homomorphic transfor-
mation. To do this, we propose a time-ordered “traver-
sal” where we hypothetically insert a mode at every input
to the mesh and allow the resulting mode vector math-
ematically to propagate progressively (i.e., to traverse)
through the device. At every step of the traversal, shown
in Fig. 2(a)-(e), we allow the mode vector amplitudes to
pass through and be transformed by the nodes in the
network. Since the transmission matrix for each node in
Eq. 1 interferes two inputs, two modes need to be input
into a node to traverse that node (advance to the outputs
of that node). Via this procedure, we equivalently con-
struct sets of nodes (in circles of the same color of Fig.
2) that all connect only to previous (already traversed)
nodes. We can then “compactify” the network into the
numbered vertical columns as in Fig. 2(f) corresponding
to the time steps (colored and indexed 1 to 4) in which
nodes are traversed. Since the nodes in these columns
are not connected to one another, we are free to conﬁg-
ure these nodes in any order, including conﬁguring them
all simultaneously (i.e., in the same time step) assuming
the preceding nodes are conﬁgured. Using this graph-
topological approach, we can always generate the most
compact device (in terms of number of node columns or

4

“optical depth”) possible for any feedforward architec-
ture by lining up the nodes according to their time step
as in Fig. 2(f).

Such a compactiﬁed version is the network with the
lowest optical depth representation of the mesh, and
nodes in each time step (or column) must be indepen-
dent since there cannot be a valid path between them
without contradicting our traversal algorithm; hence they
can to be tuned in parallel. Our column-wise or timestep
labelling is a speciﬁc case of the well-known Dijkstra’s
algorithm [16] to ﬁnd the maximum longest path (over
all input source nodes) in a directed acyclic graph (feed-
forward mesh) using breadth-ﬁrst (time-order) search to
the mesh.

Each node belongs to exactly one column, but if our
traversal algorithm ﬁnds multiple column assignments for
that node (which would require revisiting that node),
then there would be be a cycle in the graph. Therefore,
by applying this algorithm, we can formally identify cy-
cles in any mesh architecture (as in the lattice meshes
of Refs. 17, 18) that would disqualify such a mesh as
a feedforward architecture. Though those meshes with
cycles have speciﬁc uses, nodes in such meshes must be
tuned individually or using some global optimization ap-
proach [18] and may be susceptible to back-reﬂections
during programming or calibration.

C. Transmission matrix representation

Although our graph-topological construction can gen-
erally be used to deﬁne any feedforward mesh, we need an
equivalent transmission matrix that allows for straight-
forward simulation and calibration of such devices. Once
we have arrived at the compact representation of Fig.
2(f), we can deﬁne each column entirely using the gen-
eral deﬁnition of Eq. 3,
later depicted in Fig. 3(c).
For each added column of nodes, we select the appro-
priate source nodes using the permutation matrix P ((cid:96))
N
and connect them to simultaneously-acting nodes via the
block-diagonal matrix TN (θ(cid:96), φ(cid:96)) (the product of up to
M = (cid:98)N/2(cid:99) nodes given by Eq. 2):

TN (θ(cid:96), φ(cid:96)) :=

M
(cid:89)

m=1

T [m]
N (θm,(cid:96), φm,(cid:96))

N := TN (θ(cid:96), φ(cid:96))P ((cid:96))
U ((cid:96))
N ,

(3)

where phase parameters are θ(cid:96) = (θ1,(cid:96), . . . θm,(cid:96), . . . θM,(cid:96))
and φ(cid:96) = (φ1,(cid:96), . . . φm,(cid:96), . . . φM,(cid:96)). Assuming M(cid:96) ≤ M
nodes in the column, then P ((cid:96))
N is deﬁned such that we
can add synthetic bar state beamsplitter nodes for all
m > M(cid:96), i.e. θm,(cid:96) = φm,(cid:96) = π for any waveguides that
do not interact in that column. While all waveguides in
a column can technically be interfered at nodes for even
N , for odd N there will always be a single remaining
waveguide that is not connected to a node in that column.
However, this ultimately does not change the deﬁnition

in Eq. 3 since we can always choose this to be the N th
waveguide by appropriate choice of P ((cid:96))
N .

To complete meshes for which we desire a fully arbi-
trary unitary transformation, we may need a further set
of phase shifters on the output nodes of the mesh that set
the relative phases of the rows of the implemented ma-
trix (represented by the diagonal unitary matrix ΓN (γ)).
(Such phase shifters can also be at the input if the exter-
nal phase shift of each node is applied after the tunable
coupler, eﬀectively a mirror image of our current deﬁni-
tion.) Furthermore, we include a ﬁnal permutation PN
before or after those ﬁnal phase shifters, allowing us to
arbitrarily rearrange the rows of the matrix at the end.
Performing our transmission matrix construction for
L columns, we arrive at an expression for an arbitrary
feedforward mesh:

UN (θ, φ, γ) := DN

L
(cid:89)

(cid:96)=1

U ((cid:96))
N

DN := ΓN (γ)PN ,

(4)

where the matrices θ := {θm,(cid:96)}, φ := {φm,(cid:96)} and vector
γ := {γn} represent the full set of mesh parameters with
ranges θm,(cid:96) ∈ [0, π] and φm,(cid:96), γn ∈ [0, 2π). Any feedfor-
ward architecture is entirely deﬁned by these permuta-
tion matrices {P ((cid:96))
N } and PN (representing the choices of
waveguides to interfere), which we explicitly deﬁne for
commonly proposed architectures (e.g., triangular, rect-
angular, butterﬂy) in Appendix C, and by the various
phase settings in the nodes and at the output.

III. PARALLEL NULLIFICATION

Now that we have deﬁned a column-wise feedforward
photonic mesh, we present parallel nulliﬁcation as sum-
marized in Fig. 3. The programming algorithm consists
of an oﬀ-chip calculation of a sequence of inputs (or “nul-
liﬁcation set”) as in Fig. 3(a) followed by parallel nulliﬁ-
cation of columns from left-to-right of the mesh network
as in Fig. 3(b).

In a realistic setting, we do not have direct access to
the input of each column, but rather the inputs to the
overall device. We therefore need the overall input vec-
tor assigned to each column (cid:96) that leads to the desired
nulliﬁed output for that column. In both the RELLIM
protocol [11] and our parallel nulliﬁcation approach in-
troduced here, the nulliﬁcation set calculation works due
to the reciprocity of feedforward meshes. In particular,
we calculate a vector of complex amplitudes that would
emerge from shining the desired nulliﬁed output back-
wards to the input from any column (cid:96) through a correctly
programmed mesh. The nulliﬁcation set for RELLIM re-
sults from mathematically propagating light backwards
from the desired output of a single nulliﬁed node [11]. In
contrast, the nulliﬁcation set for parallel nulliﬁcation re-
sults from mathematically propagating light backwards

5

FIG. 3. We present the parallel nulliﬁcation protocol for any
feedforward photonic mesh network, here for an example with
N = 6 waveguides. (a) Nulliﬁcation set generation for column
(cid:96) in a mesh using RELLIM [11]. (b) Parallel nulliﬁcation of
column (cid:96) using nulliﬁcation set vector w(cid:96) assumes columns
1, 2, . . . (cid:96) − 1 have already been programmed. (c) Parallel nul-
liﬁcation at column (cid:96) tunes θ(cid:96), φ(cid:96) in parallel via indepen-
dent optoelectronic feedback optimizations until all bottom
ports are nulliﬁed. (d) Nulliﬁcation requires phase equaliza-
tion (SP ) and split ratio modulation (SA).

from the desired output of an entire column of nulliﬁed
nodes, as in Fig. 3(a).

When it is time to actually program the columns on the
physical mesh, we physically send the phase-conjugate
(i.e., complex conjugate) of this result, which we can now
call the nulliﬁcation set vector w(cid:96), into the mesh inputs
as in RELLIM [11]. As long as all the preceding mesh
columns are set correctly, reciprocity ensures this vec-
tor can be used to correctly program the corresponding
column (cid:96) to the desired mesh settings as shown in Fig.
3(b)-(d) by physically nullifying the appropriate outputs
of that column.

In this section, we ﬁrst formalize the nulliﬁcation set
calculation which is performed separately on a traditional
computer. We then discuss the mathematics and phys-
ical procedures behind parallel nulliﬁcation of each col-
umn and the overall programming algorithm that sets the
physical parameters of the device (which we will refer to
as α, β) to the desired settings (θ, φ respectively).

U(1)6„1ﬃ1·····················U(‘−1)6„‘−1ﬃ‘−1U(‘)6„‘ﬃ‘w∗‘v∗‘o6Nulliﬁcationsetgeneration(oﬀ-chipcalculation)(a)cProgrammedProgrammingUnprogrammedU(1)6„1ﬃ1·····················U(‘−1)6„‘−1ﬃ‘−1U(‘)6„‘ﬃ‘U(‘+1)6??·····················U(L)6??w‘v‘o6Parallelnulliﬁcation(on-chipprogramming)(b)SA(„2;‘)ORSP(ﬃ2;‘)SA(„2;‘)SP(ﬃ2;‘)P(‘)6T6(„‘;ﬃ‘)dv‘u‘o6Nulliﬁedcolumn(c)(d)Nulliﬁedtunablenode.A. Nulliﬁcation set calculation

For parallel nulliﬁcation, there exist many valid cal-
culations of nulliﬁcation sets; we could choose to nullify
either the top or the bottom port at any given node, and
the value of the (non-zero) power at the non-nulliﬁed
port does not matter. For deﬁniteness, we will consider
a simple valid target vector oN = (1, 0, 1, 0, · · · ) or more
formally:

oN :=

M
(cid:88)

m=1

e2m−1,

(5)

where e2m−1 represents the (2m − 1)th standard Eu-
clidean basis vector in CN , or equivalently, unit power
in node output port 2m − 1.

We calculate the nulliﬁcation set vector w(cid:96) for each

column (cid:96) as depicted in Fig. 3(a):

w∗

(cid:96) :=

(cid:96)
(cid:89)

(cid:16)

(cid:96)(cid:48)=1

(cid:17)T

U ((cid:96)(cid:48))

N

oN .

(6)

the

We

can

entire

nulliﬁcation

Since we have already programmed columns 1 → (cid:96) − 1,
sending in w(cid:96) to the device yields correct values for θ(cid:96), φ(cid:96)
after parallel nulliﬁcation of column (cid:96).
compute

set
{w1, w2, . . . wL} oﬀ-chip in O(N · L2) time assum-
ing all θ, φ are known since each w(cid:96) results from reverse
propagating oN through (cid:96) columns. For example, we
can calculate the nulliﬁcation set in O(N 3) time for the
rectangular or triangular grid meshes. Code for calculat-
ing the nulliﬁcation set (Eq. 6) for any feedforward mesh
is provided in our Python software module neurophox
[19], further discussed in Appendix A,1 and nulliﬁcation
set results calculated for rectangular grid networks [13]
are shown in Appendix D.

B. Nulliﬁcation

After calculating our nulliﬁcation set oﬀ-chip, we pro-
gram the physical device. Before programming a given
node m in column (cid:96), the settings αm,(cid:96) and βm,(cid:96) will be
diﬀerent from desired settings θm,(cid:96) and φm,(cid:96) respectively.
Given nulliﬁcation set input w(cid:96) (presuming all preceding
columns of the mesh are already set correctly), nulliﬁca-
tion can be achieved by two independent steps to nullify
the bottom port (port 2m) [2, 5] as proven explicitly in
Appendix B:

1. Sweep βm,(cid:96) (i.e., adjust the relative phase of the
node inputs) until bottom port power is minimized.

2. Sweep αm,(cid:96) (i.e., adjust the node split ratio) until
bottom port is nulliﬁed, as shown in Fig. 3(d).

1 See https://github.com/solgaardlab/neurophox

6

Given the permuted mode pair entering from the previ-
ous column u2m−1,(cid:96), u2m,(cid:96), this straightforward two-step
optimization exactly adjusts settings αm,(cid:96), βm,(cid:96) to be the
desired θm,(cid:96), φm,(cid:96):

αopt

m,(cid:96) = 2 arctan

βopt
m,(cid:96) = −arg

(cid:12)
u2m−1,(cid:96)
(cid:12)
(cid:12)
u2m,(cid:96)
(cid:12)
(cid:18) u2m−1,(cid:96)
u2m,(cid:96)

(cid:19)

(cid:12)
(cid:12)
(cid:12)
(cid:12)

= θm,(cid:96)

= φm,(cid:96).

(7)

Parallel nulliﬁcation of all nodes in column (cid:96) (i.e.
TN (θ(cid:96), φ(cid:96))) can be achieved because, as discussed in Sec-
tion II, the choice of nodes assigned to column (cid:96) ensures
all such optimizations are independent (i.e., do not in-
ﬂuence each other). Nulliﬁcation can be accomplished
physically by sampling and measuring a small fraction
of the power in the bottom output port. Nulliﬁcation is
then achieved through local feedback loops and is accom-
plished once zero power is measured. This nulliﬁcation
procedure has been experimentally demonstrated previ-
ously with noninvasive CLIPP detectors [4, 20, 21] that
are eﬀectively low-loss because they rely on light already
absorbed in background loss processes in the waveguide.

C. Programming algorithm

Algorithm 1 Parallel nulliﬁcation
1: function NullificationVector(θ, φ, (cid:96))
2:
3:

w∗
for (cid:96)(cid:48) ∈ [1, 2, . . . , (cid:96)] do
(cid:16)

(cid:96) ← oN

(cid:17)T

U ((cid:96)−(cid:96)(cid:48))

N

w∗
(cid:96)

4:

(cid:96) ←

w∗
end for
5:
return w(cid:96)
6:
7: end function

8: function ForwardPropagate(w(cid:96), α, β, (cid:96))
9:
10:

v(cid:96) ← w(cid:96)
for (cid:96)(cid:48) ∈ [1, . . . , (cid:96) − 1] do
N v(cid:96)

v(cid:96) ← (cid:98)U ((cid:96)(cid:48))

11:
end for
12:
return v(cid:96)
13:
14: end function

for (cid:96) ∈ [1, 2, . . . , L] do

15: procedure ParallelNullification(θ, φ)
16:
17:
18:
19:
20:

end for
for (cid:96) ∈ [1, 2, . . . , L] do

w(cid:96) ← NullificationVector(θ, φ, (cid:96))

v(cid:96) ← ForwardPropagate(w(cid:96), α, β, (cid:96))
u(cid:96) ← P ((cid:96))
for m ∈ [1, 2, . . . , M(cid:96)] do

N v(cid:96)

21:
22:
23:
24:
25:
26:
27: end procedure

end for

end for

αm,(cid:96) ← θm,(cid:96)
βm,(cid:96) ← φm,(cid:96)

(cid:46) Eq. 6

(cid:46) Eq. 8

(cid:46) Oﬀ-chip

(cid:46) On-chip

(cid:46) In parallel

(cid:46) Eq. 7

The parallel nulliﬁcation programming algorithm pro-
ceeds formally as in Alg.
1, which we simulate in
neurophox [19]. If we are conﬁguring the actual phys-
ical network, the entire ForwardPropagate method is
a physical process in which we generate an actual vector
of optical inputs w(cid:96), and propagate them through the
mesh to physically generate the vector v(cid:96) at the node
outputs in layer (cid:96) − 1, which are permuted by P ((cid:96))
N to
produce the vector we nullify in Eq. 7, u(cid:96). The vector
v(cid:96) is the propagated ﬁelds of our calculated inputs w(cid:96) to
the output of column (cid:96) − 1 as depicted in Fig. 3(b):

v(cid:96) :=

(cid:96)−1
(cid:89)

(cid:96)(cid:48)=1

(cid:98)U ((cid:96)−(cid:96)(cid:48))

N

w(cid:96),

(8)

where we use (cid:98)U ((cid:96))
N to mathematically represent the trans-
mission matrices describing already-programmed physi-
cal columns of nodes (correctly set to column parameters
θ(cid:96), φ(cid:96)). The ﬁnal (parallel) for-loop of Alg. 1 represents a
physical parallel nulliﬁcation of output powers using op-
toelectronic feedback on each column in order from (cid:96) = 1
to L.

The inputs to Alg. 1 are the desired settings for the
feedforward mesh architecture which are used to ﬁrst gen-
erate the nulliﬁcation set {w1, w2, . . . wL}. Algorithm 1
ultimately results in setting the physical mesh parame-
ters α, β to the desired θ, φ, for which a full testing suite
is provided in in neurophox [19]. As shown in Fig. 3(a),
each nulliﬁcation set vector w(cid:96) has the necessary infor-
mation from past columns to tune all devices in column
(cid:96) in parallel. We demonstrate the parallel nulliﬁcation
algorithm from Fig. 3(b) for a rectangular grid mesh
network in Appendix C.

While we have ignored adjusting the ﬁnal output phase
shifts (γ in Sec. II) in Alg. 1, we emphasize that such
phase shifts merely serve to deﬁne an “output phase ref-
erence,” which may be unimportant in some speciﬁc ap-
plications (e.g., in the optical neural network application
we now discuss) but is anyway straightforward to adjust
after parallel nulliﬁcation of all columns.

IV. OPTICAL NEURAL NETWORKS

In this section, we primarily discuss applying paral-
lel nulliﬁcation to programming reconﬁgurable optical
neural networks (ONNs), as shown in Fig. 4. Parallel
nulliﬁcation can be used to diagnose and error-correct
integrated optical neural networks, which are capable
of performing machine learning tasks that transform
optically-encoded data and can be signiﬁcantly more
energy-eﬃcient than their electrical counterparts [6].

For our demonstration, we choose the MNIST clas-
siﬁcation task, a popular standard in machine learning
models consisting of 28 × 28 images of handwritten deci-
mal digits from 0 to 9. Using neurophox [19] and GPU-
accelerated automatic diﬀerentiation in tensorflow [23],

7

(a) MNIST data is preprocessed and fed as input
FIG. 4.
modes into the two-layer reconﬁgurable neural network of Ref.
22, and the light in the network is directed mostly towards
the highlighted port corresponding to the correct label once
trained.
(b) Train and test accuracies for MNIST task for
Adam gradient descent optimization over 200 epochs. (c) Par-
allel nulliﬁcation corrects signiﬁcant drift in phase shifter val-
ues (represented by Gaussian noise with standard deviation
σθ = σφ = 0.05) and improves MNIST test accuracy. The
starting classiﬁcation error of 78% corresponds to the confu-
sion matrix with drift in (e). (d)-(e) MNIST confusion matrix
for a correctly programmed ONN (d) versus with the drift (e),
where colors denote predicted label percentage match to true
(blue) versus incorrect (red) labels.

we train a two-layer ONN (shown in Fig. 4(a)) consist-
ing of two N = 64 rectangular grid meshes followed by
ReLU-like optical nonlinearity or activation layers [22] to
classify each image to the appropriate digit label. Our
training examples consist of low-frequency FFT features
preprocessed from each image that are input into the de-

vice, and our ultimate goal is to direct the light into port
n + 1 labelled by digit n, as demonstrated in Fig. 4(a)
for digit 0. Further details on data preprocessing, model
choice, and neural network robustness and performance
are discussed in Appendix F and in Ref. 22.

Reprogrammable electro-optic nonlinearities [22] (or
generally any ReLU-like optical nonlinearities that can
be tuned to operate in a linear regime) allow multi-layer,
“deep” ONNs to be programmed or calibrated using our
parallel approaches. Crucially, this means that it is pos-
sible to calculate inputs to the entire ONN (rather than
each layer) and sequentially program the columns of all
mesh networks in the overall device to program any de-
sired operator of choice. We now demonstrate the use of
this protocol for correcting signiﬁcant drifts in our spe-
ciﬁc simulated ONN.

The training of the ONN parameters is shown in Fig.
4(b), achieving 98.9% accuracy on training data (60000
training examples) and 97.8% accuracy on hold-out eval-
uation data (10000 testing examples). In our simulated
environment, we use parallel nulliﬁcation to correct phase
drift δθm,(cid:96), δφm,(cid:96) ∼ N (0, σ2) for σ = 0.05 in our MNIST-
trained network as shown in Fig. 4(c). In particular, the
confusion matrix (representing correct predictions on the
diagonal and incorrect predictions oﬀ the diagonal) im-
proves from Fig. 4(e) to Fig. 4(d) using parallel nul-
liﬁcation, improving the test set accuracy from 78% to
97.8%. It is important to note (and this is discussed fur-
ther in Appendix F) that only very minor decrease in
performance is seen for σ ≤ 0.02, which can generally
be thought of as the phase shift tolerance threshold for
nodes in our ONN for the MNIST task.

Parallel nulliﬁcation is therefore a promising option
for realizing machine learning models on reconﬁgurable
devices [6, 24].
Such devices provide strictly more
generality and ﬂexibility over non-reconﬁgurable ONNs
which can only implement one model (speciﬁed pre-
fabrication [9]) and furthermore cannot be dynamically
error-corrected post-fabrication.

V. ERROR CONSIDERATIONS

With our optical neural network example, we have
shown how parallel nulliﬁcation can correct phase drift
and thus improve performance considerably. We fur-
ther discuss the fault tolerance of parallel nulliﬁcation to
sources of systematic error that arise during fabrication
of feedforward mesh networks.

A. Phase errors

The parallel nulliﬁcation step in Eq. 7 is agnostic to
any static phase shifts that may accumulate at each col-
umn due to path length variations, which in other cases
(e.g., non-reconﬁgurable systems) result in phase errors.

8

Speciﬁcally, parallel nulliﬁcation implicitly sets the ref-
erence by which phases in the device are measured [11],
so the nulliﬁcation set calculation of Eq. 6 gives the cor-
rect inputs for parallel nulliﬁcation regardless of how the
node is controlled. A correctly programmed mesh can
be achieved using a TDC- or MZI-based tunable beam-
splitter as depicted in Fig. 3(d) or any of the variations
discussed in Appendix E.

B. Split ratio error

Parallel nulliﬁcation can correct split ratio errors simi-
larly to how phase errors are corrected, but in some cases,
the split ratio range can be limited at each node of the
photonic mesh (e.g., due to imperfect 50/50 beamsplit-
ters in typical MZIs [25]). This limited range problem
can be avoided entirely using TDCs or double-MZIs [25]
rather than single MZIs at each node. As discussed in
Appendix E, we can equivalently consider θ as the “tun-
able coupling constant” for the TDC. A TDC can achieve
perfect operation, or full split ratio range, if the modes
are phase matched over the entire tunable range of θ.
We could ensure this range is achievable by making the
device suitably long such that the full split ratio range is
contained between the minimum and maximum extent of
the tunable coupling constant (i.e., such that θ ∈ [0, π]).

C. Thermal crosstalk

Thermal crosstalk between device elements can oc-
cur whenever there is signiﬁcant heat generated in the
phase-shifting process, such as in thermal phase shifters.
We assume that thermal crosstalk is very small between
columns and only occurs within each column so that cal-
ibrations of past columns are not aﬀected by those of
future columns. As this thermal crosstalk increases, the
parallel nulliﬁcation of each column takes longer because
the optimizations within each column are no longer inde-
pendent of each other (e.g., the settings of node m would
be aﬀected by the settings of nodes m − 1 and m + 1). If
running parallel nulliﬁcation, however, we might still be
able to eﬃciently ﬁnd an optimal setting for the column
as long as this crosstalk is reasonably small. Further-
more, phase shifter technologies that have little to no
crosstalk (such as MEMS phase shifters [26]) would be
faster to program because nulliﬁcations within the col-
umn would be truly independent.
In Appendix E, we
propose node conﬁgurations with at most π phase shifts
(rather than 2π), requiring smaller temperature varia-
tions per waveguide length and limiting thermal crosstalk
compared to conventional designs.

D. Loss

Parallel nulliﬁcation is capable of programming loss-
balanced architectures. A loss-balanced architecture is
achieved if all the waveguide path lengths and bends are
equal (assuming uniform waveguide scattering loss) and
the phase shifters are lossless (i.e., changing a phase shift
does not increase or decrease loss incurred by that phase
shift). If all modes encounter a loss µ(cid:96) at each column
(cid:96), then it is straightforward to show the column can be
programmed to implement µ(cid:96)U ((cid:96))
N using parallel nulliﬁca-
tion. From Eq. 4, the overall network implements µUN ,
where µ is ideally a “global loss” equal to the product of
all column-wise losses, i.e. µ = (cid:81)
(cid:96) µ(cid:96) [24]. Loss-balanced
grid architectures (such as rectangular grid meshes [13])
and other symmetric architectures such as the butterﬂy
(FFT) architecture [8] can be fabricated to ﬁt this cri-
terion. Other architectures (e.g., triangular meshes [2])
can include “dummy” elements to achieve the same bal-
ance. In the case of optical neural networks, some addi-
tional calibration of the nonlinear elements may also be
required in the presence of loss, which may beneﬁt from
reprogrammability of such elements [22].

If the feedforward mesh (or speciﬁcally a column of
the mesh) suﬀers from “loss imbalance,” then diﬀerent
amounts of light are lost from each output as light prop-
agates. In this case, we might need to readjust the nul-
liﬁcation set (e.g., by adjusting the computer model of
the mesh to account for lossy mesh columns) to more
accurately program in the desired operator, which is a
direction that should be further explored.

VI. DISCUSSION AND CONCLUSION

We derive a graph-topological property for any recon-
ﬁgurable feedforward photonic network of tunable beam-
splitter nodes that allows eﬃcient programming (“paral-
lel nulliﬁcation”) of node columns that are not aﬀected by
each other and thus can be tuned simultaneously. With a
model of the device stored in a computer, we ﬁnd a set of
vector inputs to the device (the “nulliﬁcation set”) and
for each column, nullify the bottom power of all tunable
beamsplitters in parallel using the corresponding nulli-
ﬁcation vector. The nulliﬁcation set can be internally
generated given a single-mode input by appending the
optical setup machine of Ref. 11 to the mesh.

Parallel nulliﬁcation can quickly diagnose and error-
correct phase drifts of a reconﬁgurable photonic device,
demonstrated in the context of reconﬁgurable optical
neural networks in Section IV. As nulliﬁcation set in-
puts are sent in order from (cid:96) = 1 to (cid:96) = L, error ap-
pears as non-nulliﬁed power at the bottom output ports
of the problematic column. This error may be corrected
by nullifying these ports so that further debugging of the
photonic circuit can be performed.

9

Our programming algorithm diﬀers from calibration
schemes [3, 6, 7, 10] that fully characterize all tunable
elements (e.g. relating phase shift to voltage via a cubic
model). Such approaches can achieve high ﬁdelities, but
components that experience environmental drift need to
be recalibrated. In contrast, parallel nulliﬁcation is not
tied to any speciﬁc calibration model and should readily
adapt to calibration drift and environmental perturba-
tions.

However, as suggested in the Introduction, it is possi-
ble to apply our graph-topological arguments to “parallel
calibration.” We explicitly provide this parallel calibra-
tion protocol in Appendix G that is similar in principle
to current calibration protocols [3, 6, 7, 10], but with
notable diﬀerences (e.g., increased eﬃciency via paral-
lelization) and simpliﬁcations (e.g., removing the need
to explicitly calibrate “meta-MZI” cells [7]). At a high
level, each node column is calibrated in parallel, assuming
no crosstalk among elements in the column, by simul-
taneously sweeping phase shifter values and measuring
corresponding powers in embedded detectors. Such cal-
ibration can elucidate phase shift-voltage relationships,
which are required for initialization of the network or
in situ backpropagation with respect to the actual node
voltages [27], which can be useful in the context of train-
ing optical neural networks.

Our approach is similar to the RELLIM approach of
Ref. 11, where each input tunes a single node, since it
relies on the reciprocity of linear optical networks. How-
ever, each input in parallel nulliﬁcation tunes an entire
column of nodes simultaneously based on the feedfor-
ward mesh deﬁnition proposed in Eq. 4. Our approach
can be fault-tolerant for feedforward meshes with phase
shift crosstalk (i.e., thermal crosstalk [6]) and beamsplit-
ter fabrication errors. Additionally, parallel nulliﬁcation
is currently the most eﬃcient protocol for programming
or calibrating a feedforward photonic mesh.
In partic-
ular, where L is the number of device columns and N
is the number of input modes, our parallel nulliﬁcation
protocol requires just L input vectors and programming
steps, resulting in up to (N/2)-times speedup over exist-
ing component-wise calibration approaches.

FUNDING INFORMATION

Air Force Oﬃce of Scientiﬁc Research (AFOSR),
speciﬁcally for the Center for Energy-Eﬃcient 3D Neu-
romorphic Nanocomputing (CEE3N2) and a MURI pro-
gram, Grant Nos. FA9550-18-1-0186 and FA9550-17-1-
0002 respectively.

ACKNOWLEDGMENTS

We would like to thank Nathnael Abebe, Ben Bartlett,

and Rebecca L Hwang for useful discussions.

[1] Michael Reck, Anton Zeilinger, Herbert J. Bernstein,
and Philip Bertani, “Experimental realization of any dis-
crete unitary operator,” Physical Review Letters 73, 58–
61 (1994).

[2] David A. B. Miller, “Self-conﬁguring universal

linear
optical component [Invited],” Photonics Research 1, 1
(2013).

[3] Jacques Carolan, Christopher Harrold, Chris Sparrow,
Enrique Mart´ın-L´opez, Nicholas J. Russell, Joshua W.
Silverstone, Peter J. Shadbolt, Nobuyuki Matsuda,
Manabu Oguma, Mikitaka Itoh, Graham D. Marshall,
Mark G. Thompson, Jonathan C.F. Matthews, Toshikazu
and Anthony Laing,
Hashimoto, Jeremy L. O’Brien,
“Universal linear optics,” Science
(2015), 10.1126/sci-
ence.aab3642.

[4] Andrea Annoni, Emanuele Guglielmi, Marco Carminati,
Giorgio Ferrari, Marco Sampietro, David Ab Miller, An-
drea Melloni,
and Francesco Morichetti, “Unscram-
bling light - Automatically undoing strong mixing be-
tween modes,” Light: Science and Applications 6 (2017),
10.1038/lsa.2017.110.

[5] David A. B. Miller, “Self-aligning universal beam cou-

pler,” Optics Express 21, 6360 (2013).

[6] Yichen Shen, Nicholas C. Harris, Scott Skirlo, Mihika
Prabhu, Tom Baehr-Jones, Michael Hochberg, Xin Sun,
Shijie Zhao, Hugo Larochelle, Dirk Englund, and Marin
Soljaˇci´c, “Deep learning with coherent nanophotonic cir-
cuits,” Nature Photonics 11, 441–446 (2017).

[7] Nicholas C. Harris, Gregory R. Steinbrecher, Mihika
Prabhu, Yoav Lahini, Jacob Mower, Darius Bunandar,
Changchen Chen, Franco N.C. Wong, Tom Baehr-Jones,
Michael Hochberg, Seth Lloyd,
and Dirk Englund,
“Quantum transport simulations in a programmable
nanophotonic processor,” Nature Photonics 11, 447–452
(2017).

[8] Fulvio Flamini, Nicol Spagnolo, Niko Viggianiello, An-
drea Crespi, Roberto Osellame,
and Fabio Sciarrino,
“Benchmarking integrated linear-optical architectures for
quantum information processing,” Scientiﬁc Reports 7,
15133 (2017).

[9] Michael Y.-S. Fang, Sasikanth Manipatruni, Casimir
Wierzynski, Amir Khosrowshahi, and Michael R. De-
Weese, “Design of optical neural networks with compo-
nent imprecisions,” Optics Express 27, 14009 (2019).
[10] Jacob Mower, Nicholas C. Harris, Gregory R. Stein-
brecher, Yoav Lahini, and Dirk Englund, “High-ﬁdelity
quantum state evolution in imperfect photonic integrated
circuits,” Physical Review A 92, 032322 (2015).

[11] David A. B. Miller, “Setting up meshes of interferometers
reversed local light interference method,” Optics Express
25, 29233 (2017).

[12] Tyler W. Hughes, R. Joel England, and Shanhui Fan,
“Reconﬁgurable Photonic Circuit for Controlled Power
Delivery to Laser-Driven Accelerators on a Chip,” Phys-
ical Review Applied 11, 064014 (2019).

[13] William R. Clements, Peter C. Humphreys, Benjamin J.
Metcalf, W. Steven Kolthammer, and Ian A. Walmsley,
“An Optimal Design for Universal Multiport Interferom-
eters,” Optica , 1–8 (2016).

[14] David A.B. Miller, “All linear optical devices are mode

converters,” Optics Express 20, 23985 (2012).

10

[15] David A. B. Miller, “Waves, modes, communications and

optics,” arXiv preprint (2019).

[16] E. W. Dijkstra, “A note on two problems in connex-
ion with graphs,” Numerische Mathematik 1, 269–271
(1959).

[17] Daniel P´erez, Ivana Gasulla, Lee Crudgington, David J.
Thomson, Ali Z. Khokhar, Ke Li, Wei Cao, Goran Z.
Mashanovich, and Jos Capmany, “Multipurpose silicon
photonics signal processor core,” Nature Communica-
tions (2017), 10.1038/s41467-017-00714-1.

[18] Daniel P´erez and Jose Capmany, “Scalable analysis for
arbitrary photonic integrated waveguide meshes,” Optica
6, 19 (2019).

[19] Sunil Pai, Ben Bartlett, Olav Solgaard,

and David
A. B. Miller, “Matrix Optimization on Universal Unitary
Photonic Devices,” Physical Review Applied 11, 064044
(2019).

[20] Stefano Grillanda, Marco Carminati,

Francesco
Morichetti, Pietro Ciccarella, Andrea Annoni, Giorgio
Ferrari, Michael Strain, Marc Sorel, Marco Sampietro,
and Andrea Melloni, “Non-invasive monitoring and
control
in silicon photonics using CMOS integrated
electronics,” Optica 1, 129 (2014).

[21] Francesco Morichetti, Stefano Grillanda, Marco Carmi-
nati, Giorgio Ferrari, Marco Sampietro, Michael J.
Strain, Marc Sorel, and Andrea Melloni, “Non-Invasive
On-Chip Light Observation by Contactless Waveguide
Conductivity Monitoring,” IEEE Journal of Selected
Topics in Quantum Electronics 20, 292–301 (2014).
[22] Ian A. D. Williamson, Tyler W. Hughes, Momchil
Minkov, Ben Bartlett, Sunil Pai, and Shanhui Fan, “Re-
programmable Electro-Optic Nonlinear Activation Func-
tions for Optical Neural Networks,” IEEE Journal of Se-
lected Topics in Quantum Electronics 26, 1–12 (2020).

[23] Martin Abadi, Paul Barham, Jianmin Chen, Zhifeng
Chen, Andy Davis, Jeﬀrey Dean, Matthieu Devin, Sanjay
Ghemawat, Geoﬀrey Irving, Michael Isard, Manjunath
Kudlur, Josh Levenberg, Rajat Monga, Sherry Moore,
Derek G. Murray, Benoit Steiner, Paul Tucker, Vijay Va-
sudevan, Pete Warden, Martin Wicke, Yuan Yu, and Xi-
aoqiang Zheng, “TensorFlow: A System for Large-Scale
Machine Learning,” in Operating Systems Design and Im-
plementation (Savannah, GA, 2016) pp. 265–283.

[24] Nicholas C. Harris, Jacques Carolan, Darius Bunandar,
Mihika Prabhu, Michael Hochberg, Tom Baehr-Jones,
Michael L. Fanto, A. Matthew Smith, Christopher C.
Tison, Paul M. Alsing, and Dirk Englund, “Linear pro-
grammable nanophotonic processors,” Optica 5, 1623
(2018).

[25] David A. B. Miller, “Perfect optics with imperfect com-

ponents,” Optica 2, 747 (2015).

[26] Pierre Edinger, Carlos Errando-Herranz, and Kristinn
Gylfason, “Low-loss MEMS phase shifter for large scale
reconﬁgurable silicon photonics,” in The 32nd IEEE In-
ternational Conference on Micro Electro Mechanical Sys-
tems (2019).

[27] Tyler W. Hughes, Momchil Minkov, Yu Shi, and Shan-
hui Fan, “Training of photonic neural networks through
in situ backpropagation and gradient measurement,” Op-
tica 5, 864 (2018).

[28] Daniel Perez,

Ivana Gasulla, Jose Capmany,

and
Richard A. Soref, “Hexagonal waveguide mesh design for
universal multiport interferometers,” in 2016 IEEE Pho-
tonics Conference, IPC 2016 (2017) pp. 285–286.
[29] Nicholas J. Russell, Levon Chakhmakhchyan, Jeremy L.
O’Brien, and Anthony Laing, “Direct dialling of Haar
random unitary matrices,” New Journal of Physics
(2017), 10.1088/1367-2630/aa60ed.

[30] David A.B. Miller, “Phase shifting by mechanical move-

ment,” (2019).

[31] Caterina Taballione, Tom A. W. Wolterink, Jasleen Lu-
gani, Andreas Eckstein, Bryn A. Bell, Robert Grootjans,
Ilka Visscher, Jelmer J. Renema, Dimitri Geskus, Chris
G. H. Roeloﬀzen, Ian A. Walmsley, Pepijn W. H. Pinkse,
and Klaus-J. Boller, “8x8 Programmable Quantum Pho-
tonic Processor based on Silicon Nitride Waveguides,” in
Frontiers in Optics / Laser Science (OSA, Washington,
D.C., 2018) p. JTu3A.58.

Appendix A: Neurophox: open source software

In our simulation framework neurophox, we provide
our general deﬁnition of feedforward mesh architectures
from Eq. 4 and the reconﬁgurable neural network model
of Fig. 4. This is the ﬁrst time to our knowledge that
feedforward meshes have been deﬁned in this way, and
it allows for a greatly simpliﬁed framework for deﬁning
and simulating mesh architectures.
In neurophox, we
provide Python code to calculate the nulliﬁcation set and
simulate parallel nulliﬁcation on a physical chip using
this nulliﬁcation set. We also provide the code to train
fully optical feedforward neural networks on the MNIST
dataset with automatic diﬀerentiation in tensorflow.

Appendix B: Two-step nulliﬁcation

We give an explicit proof of the two-step nulliﬁcation
protocol in Ref. 2 in our context. In our setup for this
proof, we have an input vector u = (u1, u2) to a node T2,
yielding output vector x = (x1, x2), i.e. x = T2(α, β)u
(deﬁned in Eq. 1 of the main text). We would like to
ﬁnd the α = θ, β = φ such that x2 = 0.

In particular, we want to show that minimizing bot-
tom port power (|x2|2) with respect to β gives β = φ
regardless of the value of α. Then, it is clear that if we
sweep α to nullify power, we must have α = θ.

α
α
u1 − sin
u2
2
2
|u1|2 + sin2 α
2

|u2|2

x2 = eiβ cos
|x2|2 = cos2 α
2
α
2

− 2 cos

sin

α
2

βopt := min

β∈[0,2π)

|x2|2 = − arg

|u1||u2|Re(eiarg(u1)e−iarg(u2)eiβ)
(cid:19)

(cid:18) u1
u2

= φ,

(B1)
where we allow any α ∈ [0, π], i.e. cos α
2 ≥ 0. Now
that we have optimized β, we optimize α to completely

2 sin α

nullify |x2|2.

|x2|2 =

(cid:16)

cos

α
2

αopt = 2 arctan

|u1| − sin
(cid:12)
(cid:12)
(cid:12)
(cid:12)

u1
u2

(cid:12)
(cid:12)
(cid:12)
(cid:12)

= θ,

11

(B2)

(cid:17)2 ?= 0

|u2|

α
2

These results match the desired expressions of Eq. 7.

Appendix C: Feedforward mesh examples

FIG. 5. For illustrative purposes, we show example mesh
diagrams for (a) butterﬂy, (b) rectangular, and (c) triangular
meshes. For (b)-(c), we show (top) how the device is modelled
(using the expression of Eq. 4 in the main text) and (bottom)
how it is physically implemented (the “grid” design). In all
mesh diagrams, orange phase shifters represent tunable phase
shifters θ, φ, γ. Gray phase shifters represent bar state MZIs
(θ = φ = π).

We can apply the general deﬁnition of a feedforward
mesh to commonly studied architectures shown in Fig. 5.
Grid architectures include the rectangular or Clements
mesh [13] and the triangular or Reck mesh [1], which
are both universal photonic mesh architectures. For
a rectangular mesh, each of the L = N columns has
M(cid:96) = M − 1 + (cid:96)(mod 2) and P(cid:96) deﬁned as an upward
circular shift for odd (cid:96) and a downward circular shift for
even (cid:96). For a triangular mesh, each of the L = 2N − 3
columns has M(cid:96) = (cid:100) min((cid:96),2N −2−(cid:96))
(cid:101) with the same P(cid:96) as
2
the rectangular mesh. The fact that the triangular mesh
has the same P(cid:96) as the rectangular mesh allows it to be
“embeddable” within a rectangular mesh.

As shown in Fig. 6, a physical rectangular grid mesh
(note the graph-topological transformation from Fig. 5)
can be progressively tuned to implement any unitary ma-
trix by performing parallel nulliﬁcation protocol.

Butterﬂy(FFT)Mesh:UB;8(a)RectangularMesh:UR;6(b)TriangularMesh:UT;6(c)12

interesting structure in the nulliﬁcation vectors for a ran-
dom unitary matrix implemented on a rectangular mesh
device.

For a rectangular mesh, the implementation of these
Haar random unitary matrices (i.e. matrices with
roughly uniform-random magnitude elements) for large
N involves low reﬂectivity in the center of the mesh and
random reﬂectivity on the boundary [19, 29]. For our
choice of normalization basis calculation in Eq. 6, the
nulliﬁcation vectors of a Haar random matrix lie some-
where between those for a mesh of only bar state nodes
(as indicated by the “bar/identity” label) and those of
a mesh of only cross state nodes (as indicated by the
“cross/ﬂip” label) in Fig. 7. As expected, the nulliﬁ-
cation set for the cross/ﬂip mesh has an antisymmetric
conﬁguration versus the more symmetric conﬁguration of
the nulliﬁcation set for the bar/identity mesh in Fig. 7.
We note that the vectors w(cid:96) are not generally mutually
orthogonal, so the nulliﬁcation set also generally do not
form a unitary matrix if arranged side by side.

There is also an information theoretic connotation of
the nulliﬁcation set. The nulliﬁcation set for a mesh with
phase settings that are uniformly set from [0, 2π) (which
leads to the “banded unitary” in Fig. 7(a)) looks more
random (i.e. less structured) than the nulliﬁcation set for
the Haar-random unitary (the truly random unitary in
Fig. 7(a)). This is due to the nonlinear relationship be-
tween the transmission amplitude of the individual nodes
and the ﬁnal output magnitudes of the overall device
[19, 29].

Appendix E: Tunable beamsplitter variations

There are many possible ways of positioning phase
shifters in an MZI that are all ultimately equivalent in
allowing universal unitary meshes and parallel nulliﬁca-
tion. The simplest general statement is that, for a 2 × 2
MZI node, we need two phase shifters, one of which must
be on one waveguide arm inside the MZI to control the
split ratio. The second phase shifter can be on any in-
put or output waveguide [1] or on the other waveguide
arm inside the MZI [2].
If the second phase shifter is
on an input arm of the MZI, then we need additional
phase shifters for the mesh to implement an arbitrary
unitary operator. Though such a design is well-suited
for self-conﬁguration and setting up input vectors into
the device, the protocol for parallel nulliﬁcation may be
less straightforward since such this symmetric conﬁgu-
ration does not have an equivalent form as in Eq. 1.
For simplicity in programming the device, we primarily
concern ourselves with conﬁgurations where the second
phase shifter is on the input waveguide obeying the form
of Eq. 1.

A commonly proposed alternative to the MZI for the
split ratio modulation (SA in Eq. 1 of the main text)
is the tunable directional coupler (TDC), which can
achieve any split ratio by simply tuning the coupling re-

FIG. 6. Parallel nulliﬁcation of Fig. 3 simulated on an N = 5
feedforward rectangular grid mesh in neurophox. The rela-
tive ﬁeld magnitudes are represented by grayscale values, the
θm,(cid:96), φm,(cid:96) phase shifts are green and the γn are gray. At each
step denoted on the left, we tune each column (cid:96) (depicted
in orange) in parallel given input w(cid:96). This is accomplished
progressively (indicated by the black-colored waveguides and
blue crosses) from left to right until the full matrix is tuned.

The butterﬂy architecture is an example of an alter-
native feedforward architecture that can be tuned using
parallel nulliﬁcation. Such architectures are designed to
be compact, robust, and fault-tolerant alternatives to
universal meshes [8, 9]. This means that implement-
ing reconﬁgurable architectures of this form is poten-
tially more scalable (to the feature size or number of
inputs and outputs) and can be useful for machine learn-
ing approaches even though it cannot actually implement
any arbitrary unitary operator. The operations that the
butterﬂy mesh can implement, however, is the discrete
Fourier transform (DFT) operator and (when concate-
nated with its mirror image to form the Benes network)
any permutation operator.

Even meshes that are not explicitly feedforward-only
[17, 28], but are meant for more general-purpose ap-
proaches, can in theory implement the rectangular or
triangular grid architectures. With some additional char-
acterization, it may be possible to program or calibrate
such general architectures in the lab setting using our
method.

Appendix D: Nulliﬁcation set patterns

While the nulliﬁcation set is mostly useful in the pro-
gressive calibration of columned optical meshes, there is

1w12w23w34w45w5Parallelnulliﬁcationdemonstration13

FIG. 7. (a) Magnitudes of the unitary matrix elements for a rectangular mesh for size N = 64 given bar state, cross state,
uniformly random phase (“phase random”), and random unitary (“Haar random”) phase settings. (b) Power magnitudes of
the nulliﬁcation set w(cid:96) for a rectangular mesh for size N = 64 given bar state, cross state, uniformly random phase, and Haar
random phase settings.

that of Ref. 30.

An alternative control scheme for phase shift operator
SP in Eq. 1 of the main text is a “diﬀerential mode”
phase shifter scheme. To make meshes more compact, it
is functionally equivalent to have phase shifters in both
the top and bottom waveguides that can reach a max-
imum of π phase shift. Tuning φ in the range of [0, π)
would then consist of tuning the top phase shifter from
steady state, whereas tuning φ in the range of [π, 2π)
would consist of tuning the bottom phase shifter from
steady state. Of course, the tradeoﬀ of this more com-
pact scheme is increased complexity in the number of
electrical contacts and the logic of the nulliﬁcation pro-
tocol. Independent of any of these control schemes, the
transmission matrix model of Eq. 1 generates the correct
set of nulliﬁcation vectors, so parallel nulliﬁcation works
for any of these schemes.

FIG. 8. Options for tunable beamsplitter T2(θ, φ), where θ
is controlled by the green block and φ is controlled by the
red block. (a) the usual non-compact conﬁguration; (b) the
compact diﬀerential-mode MZI; (c) the compact TDC.

gion of a directional coupler. The transmissivity varies
as t = cos2(κLTDC) with θ = κLTDC and κ the tun-
able coupling constant from coupled mode theory. Phase
matched modes should always allow for the full range of
transmissivities as long as the range of κLTDC is large
enough. One proposal that follows the TDC scheme is

Appendix F: Neural network training

As in Ref. 22, we preprocess each image by applying a
Fourier transform and discrete low-pass ﬁlter, since such
a task is potentially feasible in the optical domain via
Fourier optics. In our low-pass feature selection, we pick
the center 8 × 8 block of pixels since most of the useful
data is within this low-frequency band, giving us a total
of 64 features. Unlike in Ref. 22, we retain some of
the redundant Fourier features in this window since it
slightly boosts neural network performance, and we use
a mean square error loss instead of a categorical cross

016324864Output(m)016324864Input(n)Bar/Identity016324864Output(m)016324864Input(n)Cross/Flip016324864Output(m)016324864Input(n)Phaserandom016324864Output(m)016324864Input(n)HaarrandomUnitarymagnitudes(a)016324864Layer(‘)016324864Input(n)Bar/Identity016324864Layer(‘)016324864Input(n)Cross/Flip016324864Layer(‘)016324864Input(n)Phaserandom016324864Layer(‘)016324864Input(n)HaarrandomNulliﬁcationset(b)LıL2ıMZI+SingleModeﬃ(a)LıLıMZI+DiﬀerentialModeﬃ(b)LıLTDCTDC+DiﬀerentialModeﬃ(c)14

We note that the study in Ref. 9 studies the MNIST
task on larger simulated ONNs and accomplishes a sim-
ilar test accuracy (97.8%). Aside from training signiﬁ-
cantly fewer parameters than in Ref. 9, we use unitary
rather than general linear layers, we use mean square er-
ror rather than categorical cross entropy loss, and our
feature selection is diﬀerent (low-frequency Fourier fea-
tures rather than all raw features).

Appendix G: Parallel calibration

FIG. 10. Parallel calibration of any node column proceeds in
two steps (where all blue arrows in the ﬁgure indicate a mode
with the same amplitude). In (a), we send in the appropriate
input (such that u(cid:96) = (1, 0, 1, 0, . . .)) to calibrate θ(cid:96) regardless
of how φ(cid:96) is calibrated. In (b), we send in the appropriate
input (such that u(cid:96) = (1, 1, 1, 1, . . .)) to calibrate φ(cid:96) given the
setting θ(cid:96) = π/2 (which we know after calibrating θ(cid:96)).

When calibrating a large number of nodes in a feedfor-
ward mesh [3, 7, 31], it is generally convenient to have a
fast method to generate calibration curves for the volt-
age drive of each tunable element in the device. Like
parallel nulliﬁcation, our “parallel calibration” protocol
proceeds from left-to-right and can generate these trans-
mission curves in parallel for all nodes within a given
column.

In some grid meshes, all nodes can be systematically
tuned to cross state (e.g., in the programmable nanopho-
tonic processor (PNP) [7] or self-conﬁguring triangular
grid network [25]).
In such schemes, power maximiza-
tion at the appropriate output detectors can be used to
remove the need for embedded detectors (i.e., use output
detectors for the entire calibration procedure).

Other feedforward schemes, however, require embed-
ding photodetectors for parallel nulliﬁcation, which may
as well be used for parallel calibration. To calibrate θ(cid:96),
we ﬁnd the necessary input vector so that the bottom in-
put port of all nodes in column (cid:96) are nulliﬁed (i.e., input
power of (1, 0) to all nodes in the column) while setting
all previously calibrated layers to bar state. We then

FIG. 9. (a) MNIST training results for N = 36, 64, 144 for
the two-column neural network depicted in Fig. 4(a). Sig-
niﬁcant overﬁtting is observed when N = 144 due to lack
of regularization.
(b) Accuracy robustness analysis for the
ONN for N = 36, 64, 144 for phase errors ranging from σ = 0
to σ = 0.1.

entropy loss due to slight performance improvement in
the former.

Our prediction consists of dropping the ﬁnal 54 outputs
of the second neural network layer (shown by the light
blue arrows in Figure 4 of the main text), and squar-
ing the amplitudes of the remaining 10 outputs (equiva-
lent to taking a power measurement, denoted by the red
photodetector symbols of Figure 4). Given the dth data
sample (xd, yd) (pair of input feature vector and one-hot
label vector), our cost function L is the mean square error

L =

D
(cid:88)

d=1

(cid:13)
(cid:13)
(cid:13)
(cid:13)

f (xd)
(cid:107)f (xd)(cid:107)

− yd

(cid:13)
2
(cid:13)
(cid:13)
(cid:13)

,

(F1)

where f (xd) represents the raw output powers of the neu-
ral network given input xd. In practice, our classiﬁcation
will always correspond to the port in which the highest
output power is measured, ideally guiding input mode
vector xd to the output port corresponding to yd. Our
model achieves a ﬁnal train accuracy of 98.9% and a ﬁnal
test accuracy of 97.8%. Slightly worse training perfor-
mance was found using a categorical cross entropy loss.
Finally, we perform an robustness analysis of imperfec-
tions in neural network performance (as in Ref. 9). We
train the same two-column neural network of Figure 4
for diﬀerent sizes of N = {36, 64, 144}, achieving test ac-
curacies of 96.6%, 97.8%, 98.1% respectively, though per-
formance varies slightly from run to run. The training
curves and robustness analysis for diﬀerent phase errors
(Gaussian phase errors of the form N (0, σ2)) are shown in
Figure 9, where we ﬁnd that phase errors above σ = 0.02
begin to signiﬁcantly aﬀect performance. Of course, once
parallel nulliﬁcation is applied, any such errors can be
corrected regardless of the exact calibration model for the
individual phase shifters. Note that in the case N = 144,
signiﬁcant overﬁtting is present, though adding dropout
(i.e., zeroing-out power in some of the ports) after the
ﬁrst ONN layer might be one method to “regularize” the
physical ONN and therefore reduce this overﬁtting.

0100200Epoch0:850:900:951:00AccuracyMNISTtraining(a)Train,N=144Train,N=64Train,N=36Test,N=144Test,N=64Test,N=360:000:020:040:060:080:10PhaseError(ﬀ„;ﬀﬃ)0:00:20:40:60:81:0AccuracyRobustnessanalysis(b)15

measure resulting output transmissivities as we sweep all
θ(cid:96) simultaneously from the minimum to maximum allow-
able voltage drive settings, as shown in Fig. 10(a). To
calibrate φ(cid:96), we input the uniform power in all mesh in-
puts such that all nodes in column (cid:96) have equal power in
both input ports (i.e., input power of (1, 1) to all nodes in
the column). Assuming we have already calibrated θ(cid:96), we
set all tunable θ(cid:96) = π/2. Now, we can calibrate φ(cid:96) just
as we calibrated θ(cid:96) as shown in Fig. 10(b), similar to a
parallelized version of the meta-MZI scheme [7, 10]. This
calibration approach works for any of the node conﬁgu-
rations in Fig. 8. As outlined in Ref. 7, we can calibrate
the phase given the transmissivity T using the relation
T = sin2(θ(v) + θ0), where θ0 is the reference phase and
θ(v) is the calibration curve given a sweep over all pos-
sible voltage settings for v. Once the sweep is ﬁnished,
we deﬁne our calibration by storing the full phase shift-
voltage lookup table or a cubic model ﬁt to that curve
(3 parameters per tunable element or 6 parameters per
node) [3].

Calibrating θ(cid:96) then φ(cid:96) for each layer of the mesh from
left-to-right results in a fully calibrated device, irrespec-
tive of the feedforward architecture. Once calibrated, any

reachable unitary operator on the device can be imple-
mented by simply ﬂashing desired values based on the
measured transmission curves. Our parallel calibration
procedure would need to be repeated once the nodes in
the device experience fatigue or environmental perturba-
tion, leading to calibration drift. As mentioned in the
main text, this calibration drift might be diagnosed ef-
ﬁciently by sending in nulliﬁcation set input vectors to
identify errors within each column of the feedforward net-
work denoted by unnulliﬁed nodes for the corresponding
column. Our calibration can also be used to initialize
parallel nulliﬁcation or calculate the ﬁnal updates for a
procedure like in situ backpropagation [27]. Our paral-
lel calibration, like parallel nulliﬁcation, generally give
us up to O(N ) speedup and is also generally applica-
ble to any feedforward mesh. It is worth noting also that
our parallel calibration protocol might be transferrable to
existing technologies such as the PNP grid architecture,
with some minor modiﬁcations of the protocol discussed
in the supplementary of Ref. 7. Such grid architectures
are already arranged in node columns and thus can be
calibrated eﬃciently by following the steps of Fig. 10,
potentially without embedded detectors.

