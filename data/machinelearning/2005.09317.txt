0
2
0
2

y
a
M
9
1

]
E
S
.
s
c
[

1
v
7
1
3
9
0
.
5
0
0
2
:
v
i
X
r
a

Combining Dynamic Symbolic Execution,
Machine Learning and Search-Based Testing to
Automatically Generate Test Cases for Classes

Matteo Modonato
Dipartimento di Informatica, Sistemistica e Comunicazione
Universit`a di Milano Bicocca
Milano, Italy
m.modonato1@campus.unimib.it

Abstract

This article discusses a new technique to automatically generate test cases
for object oriented programs. At the state of the art, the problem of
generating adequate sets of complete test cases has not been satisfactorily
solved yet. There are various techniques to automatically generate test
cases (random testing, search-based testing, etc.) but each one has its own
weaknesses. This article proposes an approach that distinctively combines
dynamic symbolic execution, search-based testing and machine learning,
to eﬃciently generate thorough class-level test suites. The preliminary
data obtained carrying out some experiments conﬁrm that we are going
in the right direction.

Keywords:

Automated test generation, Symbolic execution, Dynamic
symbolic execution, Search-based testing, Machine Learning, K-nearest neigh-
bour

1

Introduction

Automatically generating class-level test cases for object oriented programs, e.g.,
programs in Java, requires to identify sequences of method calls that comply
with the legal APIs of the programs under test, and suite to thoroughly exercise
the classes in the programs. Complete test cases shall further include all method
calls needed to properly instantiate and set any relevant non-primitive input
that participates in the test cases. The inputs can be objects of either the same
type as the class under test or types speciﬁed in other classes, including library
classes, or yet structures of multiple interconnected objects of many classes.

At the state of the art, the problem of generating adequate sets of complete
test cases has not been satisfactorily solved yet. On one hand, many existing

1

 
 
 
 
 
 
approaches systematically characterise thorough sets of test-relevant input ob-
jects, based on either functional or structural testing criteria, but provide no
support for generating method sequences to instantiate complete test cases with
these inputs [1–6]. On the other hand, the approaches that succeed in producing
complete test cases may often miss many relevant test objectives that depend
on rare input states or complex input objects [5, 7–11].

Existing test generators build complete test cases based on random testing,
search-based testing and symbolic execution [5, 7–11]. Random testing samples
the possible method sequences and their inputs uniformly, but may miss test
objectives that depend on singular or quasi-singular inputs [8]. Search-based
testing explores the space of the possible test cases with meta-heuristic search
strategies, guided by ﬁtness functions that encode the relevant test objectives,
It can outperform random testing in
e.g., the branches on the code [7, 10].
several cases, but may still miss many relevant test objectives that induce ﬂat
ﬁtness functions and local optima that hamper the convergence of the search
strategies.

Other approaches embrace symbolic execution to precisely characterize the
execution conditions of the program paths that exercise the test objectives, and
then identify complete test cases by satisfying such execution conditions [5,9,11].
While symbolic execution may foster precise deductions on how to reach the test
objectives, it suﬀers more than random and search-based testing in coping with
programs that maintain implicit invariants of the validity of the input objects,
e.g., by controlling the visibility and the accessibility of class variables. The
ignorance of the invariants makes symbolic execution waste most testing budget
in trying to instantiate infeasible execution paths that depend on (unforeseen)
invalid input objects.

This paper introduces Tardis, a unit test generator for Java programs that
distinctively combines dynamic symbolic execution, search-based testing and
machine learning, to eﬃciently generate thorough class-level test suites. The
approach of Tardis consists of (i) exploring the path space of the target pro-
grams with dynamic symbolic execution, (ii) instantiating complete test cases
with a genetic search algorithm guided with ﬁtness functions that represent the
satisﬁability of the symbolic path conditions, and (iii) prioritizes the symbolic
formulas that more likely correspond to feasible program paths based on an
original classiﬁcation algorithm trained on the characteristics of the formulas
for which it ether succeeds or fails overtime.

This paper is organized as follows. Section 2 describes the existing ap-
proaches based on a working example, and highlights their limitations that mo-
tivate our work on Tardis. Section 3 presents the Tardis algorithm. Section 4
explains in further detail the core technical novelty of Tardis, that is, the path
section strategy based on machine learning. Section 5 discusses initial results
on the eﬀectiveness of Tardis. Section 6 provides our conclusions and outlines
our research plans.

2

2 Motivating Example and Related Work

In this section we discuss the current test generation generation approaches
that, to the best of our knowledge, can generate class-level complete test cases
for object oriented programs. We highlight in particular the approaches that
target Java classes.

Listing 1 introduces a sample program that we use in this section to discuss
the strengths and the limitations of the test generation approaches at the state
of the art, and lately in the next section to describe the Tardis algorithm. This
program includes a branch that is diﬃcult to test both with purely dynamic
test generators, like random and search-based test generators [8, 10], and with
the existing test generators based on symbolic execution and dynamic symbolic
execution [5, 9, 11, 12]. The challenging branch is the one that leads to execute
line 32 of method SampleClass.run, where the program returns the string
"Yes". Executing line 32 requires a test case that does not traverse either
line 23 or line 27 while executing through the loops in the program: At line 23
the program assigns k=1, and thus executing this line causes the violation of the
assertion at line 30 and in turn the termination of the program before line 32;
At line 27 the program assigns flag=false, and thus executing this line leads
to skip the execution of line 32.

public class SampleClass {

private final int [] a ;
private final int [] b ;

public SampleProgram (

int a0 , int a1 , int a2 , int a3 , int a4 ,

int b0 , int b1 , int b2 , int b3 , int b4 ,
int b5 , int b6 , int b7 , int b8 , int b9 ) {

a = new int [] { a0 ,
b = new int [] { b0 ,
for ( int i = 0; i < b . length ; i ++) {

a2 ,
b2 ,

a3 ,
b3 ,

a1 ,
b1 ,

a4 };
b4 ,

b5 ,

b6 ,

b7 ,

b8 ,

b9 };

if ( b [ i ] < 0) throw new Runti me Ex ce pt io n () ;

}

}

public String run () {

int k = 0;
boolean flag = true ;
for ( int i = 0; i < A . length ; i ++) {

if ( A [ i ] > i * 1000) {

for ( int j = 0; j < b . length ; j ++) {

if ( b [ j ] < -A [ i ]) { /* This branch is infeasible */

k = 1;

}

}
} else {

flag = false ;

}

}
assert ( k == 0) ;
if ( flag ) {

return " Yes " ;

} else {

return null ;

}

}

}

Listing 1: Code example

3

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

We refer to the sample program of Listing 1 to explain the strengths and
exemplify the limitations of the main approaches that address the generation of
test cases for Java classes at the state of the art, aiming to motivate our work
on Tardis to overcome these limitations. In particular, we discuss approaches
based on random testing (e.g., [8]), search-based testing (e.g., [10]), and both
classic and dynamic symbolic execution (e.g., [5, 9, 11, 12]).

Random Testing Random testing generates test cases by sampling the legal
method sequences and the corresponding input values at random. The tool
Randoop is popular test generator based on random testing that addresses Java
classes [8].

The main advantage of using random testing is that it can readily generate
many complete test cases based on the legal APIs of the program under test.
For instance, for the class SampleClass in Listing 1, which speciﬁes only a
class constructor and the method run, it is straightforward for a tool like Ran-
doop to ﬁnd legal method sequences that consist of calling the class constructor
with random values as inputs, and then executing method run. For example,
Randoop may easily generate a the test case like

SampleClass s = new SampleClass (123 , 456 , ...) ;
s . run () ;

On the other hand, random testing can hardly identify test cases that execute
the parts of the program under test that depend on almost singular inputs or
combinations of inputs. For example, Randoop would hardly generate a test
case that executes the branch at line 32 of our sample program, because, to this
end, it should set the ﬁrst ﬁve inputs of the class constructor to a combination
of values that make the if-statement at line 20 execute only the then-branch,
and the subsequent ten inputs of the class constructor to non-negative values.
In the sample program, the ﬁrst ﬁve inputs of the constructor determine the
values in the array a that the if-statement at line 20 sequentially evaluates at
each pass. The other ten inputs of the constructor must be non-negative values
to avoid the exception at line 12. Thus, assuming for simplicity that Randoop
would randomly pick with equal probability values that do or do not satisfy
the condition of the if-statement, and positive or negative values, respectively,
Randoop has 1/215 probability to pick ten satisfying values in a row, that is,
about 0.003% chances out of a value space of 6415 if the integer data range on
64 bits.

Search-based Testing Search-based testing guides the selection of random
test cases with meta-heuristic algorithms based on ﬁtness functions that cap-
ture the execution conditions of test objectives. Thus, search-based testing can
mitigate the issues of random testing that derive in the ﬁrst place from picking
inputs uniformly without being unaware of the relation between the inputs and
the test objectives, e.g., executing the branches our sample program. The tool
Evosuite is a popular search-based test generator for Java classes [10].

4

Evosuite can be parametrized with several code-based ﬁtness functions, but
we limit our discussion to the speciﬁc ﬁtness functions by which EvoSuite ad-
dresses the branches in the code. In this speciﬁc setting, EvoSuite will consider
a ﬁtness function for each then- and else-branch of each conditional statement
in the program under test, e.g., the then-branch and else-branch of if-statement
at line 20 of our sample program.

The algorithm of EvoSuite proceeds as follow.

It starts with a randomly
generated population of test cases, and scores these test cases according all the
ﬁtness functions. For instance, let us assume that the initial population includes
a test case like

SampleClass s = new SampleClass ( -5 , -5 , -5 , -5 , -5 , 0 , ...\* all zeros *\) ;
s . run () ;

that executes the else-branch of the if-statement at line 20, but does never
execute the then-branch of this if-statement. Thus, Evosuite scores this test
case as optimal with respect to the ﬁtness function of the else-branch, and sub-
optimal for the then-branch. Then, while progressing in the search, EvoSuite
records the test cases that satisfy some target branch for the ﬁrst time, and
restricts its attention to the ﬁtness functions of the yet-unsatisﬁed branches to
produce test suites that execute as many branches as possible. In our example,
Evosuite marks the ﬁtness function of the else-branch as satisﬁed, records the
test case, and proceeds in the optimizing the test cases with respect to the
ﬁtness function of the then-branch. With respect to this latter ﬁtness function,
EvoSuite scores the test case based on the minimal change that is required
to make the condition of the branch evaluate to true. For instance with the
above test case, Evosuite observes that the condition of the branch evaluates
as −5 > 0 (which is false), and thus a change of 6 units of the left operand
in the comparison would suﬃce for the condition to evaluate to true. While
continuing through its (genetic) algorithm, Evosuite will then favour this test
case to survive in the evolving population, until ﬁnding other test cases with
better ﬁtness scores, e.g, a test case that misses the considered true-branch of
5, 4 or less units, until eventually producing a satisfying test case with respect
to this condition.

Unfortunately, despite the speciﬁc focus on program branches may often lead
EvoSuite to outperform random testing in code coverage for many programs,
EvoSuite can hardly cope with the hard branch at line 32 of our sample program.
In fact, the condition of this branch depends on a boolean variable and thus
all test cases that miss this branch have the same ﬁtness score of 1 (since a
change of a single boolean unit would suﬃce to hit the branch) resulting in a
local-optimum of the ﬁtness landscape. Thus, EvoSuite has no guidance for
executing the branch at line 32, and thus it falls back to having exactly the
same low probability of random testing of ﬁnding a satisfying solution for this
branch.

Symbolic Execution Symbolic execution identiﬁes the execution conditions
of the program paths, which it refers to as the path conditions, and generates

5

test cases by solving the path conditions to concrete values. For instance, by
analyzing the program paths that lead to the hard branch at line 32 of our sample
program, we can compute the path condition A (cid:54)= null ∧ A.length > 0 ∧ A[0] >
0∧· · ·∧A[1] > 1000∧· · ·∧A[2] > 2000∧· · ·∧A[3] > 3000∧· · ·∧A[4] > 4000∧. . .,
where the symbol A denotes the input array associated to the class variable
SampleClass.a and the dots mark further conditions that we omitted for the
sake of simplifying the presentation, e.g., the conditions on the items in the array
SampleClass.b. To solve this path condition, we have to assign the ﬁve items
in the array SampleClass.a with increasingly larger positive numbers, which
is the requirement to execute the branch at line 32. The tools JPF [12] and
JBSE [4, 13] are test generators for Java classes based on symbolic execution.

Symbolic execution can outperform the purely dynamic approaches of ran-
dom testing and search-based testing for identifying test cases that execute
speciﬁc program paths, since, as in the above example, it models the execution
conditions of the paths with precise path-condition formulas. However, symbolic
execution suﬀers more than the purely dynamic technique in i) computing test
cases based on legal method sequences, and ii) eﬃciently coping with programs
with many possible execution paths.

We ﬁrst discuss the diﬃculty of symbolic in computing test cases based on
legal method sequences. As we discussed above, by solving a path condition
of the sample program, symbolic execution can compute an assignment of the
array SampleClass.a that allows for executing the hard branch in the program.
However, there is not straightforward way for symbolic execution to understand
which legal sequence of method calls can set these values into an instance of
class SampleClass. Indeed, understanding that the values in the array depend
on the ﬁrst ﬁve parameters of the constructor is not obvious, and the required
method sequences and program APIs can easily be much more complicated in
other programs than in this example.

Traditional symbolic executors, including JPF and JBSE, circumvent this
issue by breaking the restrictions designed in the program APIs, e.g., by aug-
menting the programs under test with setter methods for all class attributes,
or using the Java Reﬂection APIs to access the memory at low level. However,
this is arguably an undesirable solution for many reasons. On one hand it re-
sults in test cases that are not in developer-format and can be diﬃcult for the
developers to understand and maintain. On the other hand, it may result in
illegal test cases and false alarms. For example, with reference to the sample
program, the symbolic executor JBSE can characterize a program path that
violates the assertion at line 30 with a path condition that includes the sub-
formula A[0] > 0 ∧ B[0] < −A[0], then compute a solution in which the ﬁrst
item in array SampleClass.b holds a negative value, and ﬁnally produce a test
case that enforces a negative item in SampleClass.b[0] by relying on the Java
Reﬂection APIs, thus demonstrating the violation of the assertion. Unfortu-
nately this test case is in fact a false alarm, since the legal constructor of the
class, which JBSE is in fact bypassing, does not allow for setting negative values
in the array SampleClass.b.

The other diﬃculty of symbolic execution is to cope with programs with

6

many or inﬁnitely many paths, since analyzing large sets of paths can be ineﬃ-
cient, especially if it is diﬃcult to spot the infeasible paths. For example, in our
sample program, there are only 32 feasible paths that correspond to the combi-
nations of the true and false alternatives of the if-statement at line 20, while the
program scans through the array SampleClass.a. However, since symbolic ex-
ecution is unaware of the invariant, the class constructor maintain on the items
in the array SampleClass.b, which can only hold positive values due to the
exception raised at line 12, the alternatives of the if-statement at line 20 further
combine with the 210 combination of alternatives of the if-statement at line 22
on the items in the two arrays. Thus, for our sample program, a test generator
based on symbolic execution like JBSE would end up with raising many false
alarms, while missing most feasible paths, including the path to execute the
hard branch in the program.

SUSHI is an approach that addresses the limitations of symbolic execution by
computing test cases based on legal method sequences [11]. SUSHI converts the
path conditions computed with JBSE into ﬁtness functions with which SUSHI
can steer EvoSuite to compute test cases that satisfy the path conditions. Thus
SUSHI does not produces false alarms, since EvoSuite does not yield test cases
for the path conditions that cannot be satisﬁed with legal test cases. However,
SUSHI pays high performance penalties with programs with many infeasible
paths, as in the case of our example, since it wastes a lot of time in waiting for
EvoSuite to expire the inconclusive search attempts for the unsatisﬁable path
conditions. SUSHI can be fed with speciﬁcations that encode the properties
of the valid inputs, which help SUSHI to identify the unsatisﬁable path con-
ditions in advance. Unfortunately, requiring the developers to produce these
speciﬁcations questions the actual level of automation of the approach.

Dynamic symbolic execution combines symbolic and concrete execution in
a feedback loop, with the aim of steering symbolic execution to analyze the
path conditions only for the program branches that directly originate from a
concretely executed path. In a nutshell, dynamic symbolic works by iterating
the following feedback loop: It executes a test case, analyzes the path condi-
tion of the corresponding program path, synthesizes the path conditions of the
alternative branches by negating all clauses one-by-one (that is, each new path
condition negates a single clause of the original one), solves those path condi-
tions to obtain new test inputs, and iterates the process based on the generated
test inputs. PEX is a popular test generator that implements dynamic symbolic
execution for programs in C++ [5]. A beneﬁt of dynamic symbolic execution
execution is to abandon as early as possible the analysis of the paths that orig-
inate at branches with unsatisﬁable path conditions. This can mitigate, though
not generally solve, the impact of the infeasible paths on the performance of the
analysis. For example, with reference to our sample program, dynamic symbolic
execution would still try the many infeasible choices related to the if-statement
at line 22, but would not unfold the combinations of sub-paths related to those
infeasible choices.

Several authors propose path selection heuristics to steer dynamic symbolic
execution towards uncovered and relevant branches in the code by discriminating

7

the sub-paths that can statically reach the target branches [14–16]. However the
results are inconclusive in most cases. For our sample program, a path selection
strategy based on targeting the hard branch at line 32 and the uncovered (but
infeasible) branch at line 23 would not bring any particular beneﬁt.

3 Test Generation with Tardis

Tardis combines symbolic execution, machine learning and search-based testing,
to automatically generate test cases that thoroughly exercise Java classes with
legal method sequences:

• Tardis exploits symbolic execution in the embodiment known as dynamic
symbolic execution [17] to precisely identify the execution conditions of
the program paths (i.e., the path conditions), with respect to both the
primitive and the structured inputs of the programs under test [12,18,19].

• Tardis embraces machine learning to deﬁne a path selection heuristic based
on classifying the path conditions that are either likely satisﬁable or likely
unsatisﬁbale, according to the characteristics of both the satisﬁable and
unsatisﬁable path conditions that Tardis learns during the test generation
process.

• Tardis satisﬁes the symbolic conditions selected as above in the fashion
of search-based testing, that is, by incrementally optimising a population
of legal method sequences with respect to ﬁtness functions that suitably
represents the satisfaction of the path conditions [10, 11].

Figure 1: Tardis workﬂow

Figure 1 illustrates the workﬂow of Tardis that consists of iterating through
three main steps: i) dynamic symbolic execution, ii) path selection and iii) test
case generation.

Dynamic Symbolic Execution Step The dynamic symbolic execution step
consists in executing an available test case, computing the path condition of
the program path that the test case executes, and synthesizing alternative path

8

conditions by negating the conjunctive clauses of the path condition obtained
with the test case. The considered test case can be either a test case that is
initially available from external sources (e.g., given to Tardis as input), or a test
case that Tardis itself generated at a previous iteration.

For instance, with reference to the sample program of Listing 1, let us assume
that Tardis executes the dynamic symbolic execution step by based on a test
case like

SampleClass s = new SampleClass (0 , 0 , ... /* all zeros */ ) ;
s . run () ;

Tardis proceeds as follow. First, by executing this test case, Tardis identiﬁes
the program path that iterates 5 times the through the loop at line 19, ex-
ecutes the else-branch at line 27 at all iterations, and terminates by raising
the violation of the assertion at line 30. Then, by analyzing this execution
path, Tardis computes the path condition A (cid:54)= null ∧ A.length > 0 ∧ A[0] ≤
0 ∧ A.length > 1 ∧ A[1] ≤ 1000 ∧ A.length > 2 ∧ A[2] ≤ 2000 ∧ A.length >
3 ∧ A[3] ≤ 3000 ∧ A.length > 4 ∧ A[4] ≤ 4000 ∧ A.length ≤ 5; where the sym-
bol A denotes the input array associated to the class variable SampleClass.a.
Next, by negating each of the eleven clauses of this path condition, Tardis can
synthesize the following alternative path conditions in which we highlighted the
negated clauses:

• A.length ≤ 0

• A.length > 0 ∧ A[0] > 0

• A.length > 0 ∧ A[0] ≤ 0 ∧ A.length ≤ 1

• A.length > 0 ∧ A[0] ≤ 0 ∧ A.length > 1 ∧ A[1] > 1000

• A.length > 0 ∧ A[0] ≤ 0 ∧ A.length > 1 ∧ A[1] ≤ 1000 ∧ A.length ≤ 2

• A.length > 0 ∧ A[0] ≤ 0 ∧ A.length > 1 ∧ A[1] ≤ 1000 ∧ A.length >

2 ∧ A[2] > 2000

• A.length > 0 ∧ A[0] ≤ 0 ∧ A.length > 1 ∧ A[1] ≤ 1000 ∧ A.length >

2 ∧ A[2] ≤ 2000 ∧ A.length ≤ 3

• A.length > 0 ∧ A[0] ≤ 0 ∧ A.length > 1 ∧ A[1] ≤ 1000 ∧ A.length >

2 ∧ A[2] ≤ 2000 ∧ A.length > 3 ∧ A[3] > 3000

• A.length > 0 ∧ A[0] ≤ 0 ∧ A.length > 1 ∧ A[1] ≤ 1000 ∧ A.length >

2 ∧ A[2] ≤ 2000 ∧ A.length > 3 ∧ A[3] ≤ 3000 ∧ A.length ≤ 4

• A.length > 0 ∧ A[0] ≤ 0 ∧ A.length > 1 ∧ A[1] ≤ 1000 ∧ A.length >
2∧A[2] ≤ 2000∧A.length > 3∧A[3] ≤ 3000∧A.length > 4∧A[4] > 4000

• A.length > 0 ∧ A[0] ≤ 0 ∧ A.length > 1 ∧ A[1] ≤ 1000 ∧ A.length >
2 ∧ A[2] ≤ 2000 ∧ A.length > 3 ∧ A[3] ≤ 3000 ∧ A.length > 4 ∧ A[4] ≤
4000 ∧ A.length > 5

9

Tardis feeds these path conditions to its next step, the path selection strategy,
that aims to choose on which path conditions Tardis will allocate test generation
attempts.

Path Selection Step In path selection step Tardis aims to discriminate be-
tween the likely satisﬁable and likely unsatisﬁable path conditions, and prioritize
the test generation attempts with respect to former ones. In fact, during the
test generation process, Tardis will iterate the dynamic symbolic execution step
for all the test cases that it incrementally generates, and will thus keep on
synthesizing increasingly more additional path conditions, possibly including
many unsatisﬁable path conditions that correspond to infeasible paths in the
program under test. For instance, continuing with the above example, the six
path conditions that Tardis synthesized by negating conditions that predicate
on the length of the array a are unsatisﬁable, since the constructor of class
SampleClass maintains the invariant that a always contains exactly ﬁve items.
Namely, these path conditions are the ﬁrst, third, ﬁfth, seventh, ninth and
eleventh in the list outlined above. As we already commented, allocating too
many test generation attempts on unsatisﬁable path conditions may strongly
penalize the overall eﬃciency of the test generator, wasting most computational
time in attempts that cannot converge.

The core of the path selection step of Tardis is a classiﬁcation model based on
machine-learning that assigns selection priorities to the path conditions, aiming
to assign low priority to the path condition that it can predict as likely infea-
sible. Tardis builds and incrementally reﬁnes the classiﬁcation model based on
the evidences in support of either satisﬁable or unsatisﬁable formulas that it
In
collects from the path conditions met during the test generation process.
fact, the path conditions that Tardis computes by analyzing available and gen-
erated test cases contribute supporting evidences of satisﬁable formulas, while
the path conditions on which Tardis allocated unsuccessful test generation at-
tempts contribute supporting evidences of formulas that might be unsatisﬁable.
For instance, by analyzing the initial test case exempliﬁed above, Tardis col-
lects evidence that the formulas that comprise the path condition computed for
the test case are indeed satisﬁable, e.g., the formulas A.length > 0, A[0] ≤ 0,
A.length > 1 and so forth. While, if lately Tardis would fail in the attempt
to generate a test case for the path condition synthesized by negating the third
clause, i.e., the path condition A.length > 0 ∧ A[0] ≤ 0 ∧ A.length ≤ 1, it can
thereon hypothesize that the formula that corresponds to the new clause in this
path condition A.length ≤ 1 might be unsatisﬁable.

Tardis exploits the incrementally collected supporting evidences for engi-
neering a classiﬁer based on the classic KNN (K-nearest neighbours) machine
learning algorithm. The classiﬁer computes the similarity of the formulas in the
not-yet-selected path conditions with respect to the satisﬁable and unsatisﬁable
formulas that Tradis collected as supporting evidences, and classiﬁes the path
conditions according to the type of supporting evidences that are most similar
to them. For instance, after collecting the supporting evidence that the formula

10

A.length < 1 might be unsatisﬁable as described above, Tardis would clas-
sify as likely unsatisﬁable the other path conditions in which the last clause is
A.length < (cid:104)CON ST AN T (cid:105), because these clauses look similar to A.length < 1.
Namely, these are the ﬁrst, ﬁfth, seventh and ninth path condition in the list
outlined above. Based on this classiﬁcation results, Tardis might thus assign
low selection priorities to these unsatisﬁable path conditions. Section 4 dis-
cusses the details on how Tardis collects the supporting evidences by identifying
the sub-formulas that represent independent satisﬁability problems in the path
conditions (a step called path condition slicing in other papers [20, 21]), and
computes the similarity and priority scores.

The priorities that Tradis assigns to the path conditions based on the re-
sults of the KNN-based classiﬁer induce a probabilistic path selection strategy,
in which the path conditions with high priority scores are selected with higher
probability than the path conditions with low priority scores. In this way, Tardis
favours the allocation of testing attempts on the likely satisﬁable path condi-
tions, but acknowledges that the supporting evidences on unsatisﬁable formulas
come with some uncertainty. Indeed, the meta-heuristic search algorithm that
Tardis uses to generate the test cases may not succeed either because the se-
lected path conditions are truly unsatisﬁable or sometimes because it is hard
for the algorithm to solve them, despite they are satisﬁable. The probabilistic
selection leaves open the chance that now and then Tardis may allocate test
generation attempts to low-priority path conditions. If any of these attempts
eventually succeeds, Tardis will update the supporting evidence according to the
corresponding satisﬁability results, and reconsider its classiﬁcations accordingly.

Test Case Generation Step The test case generation step Tardis relies on
the genetic algorithm implemented in the tool Evosuite [10] steered with a ﬁt-
ness function that scores as optimal the test cases that satisfy the target path
conditions, SUSHI [11]. The ﬁtness function has the property of yielding increas-
ing better ﬁtness for the test cases that satisfy increasing amounts of clauses of
those path conditions. In a nutshell, the test generation algorithm starts with a
population of test cases built with legal method sequences selected at random,
iterates with producing oﬀsprings of new the test cases obtained by randomly
mutating and crossing the current test cases in the style of genetic algorithms,
and favors the test cases with greater ﬁtness to survive in the population with
higher probability than the ones with lower ﬁtness. Eventually, the algorithm
either converges to a solution, i.e., a test case with optimal ﬁtness, or gives up
after a given time budget. For instance, it Tardis selected the path condition
A.length > 0 ∧ A[0] > 0, the second in the list outlined above, for a test gen-
eration attempt, it synthesize an evaluator program that computes the ﬁtness
function based on this path condition, and call Evosuite with this evaluator
program as input. As a result, Evosuite may provide a test case like

SampleClass s = new SampleClass (123 , 0 , ... /* all zeros */ ) ;
s . run () ;

that consists of a legal method sequence satisﬁes the path condition.

11

Tardis will provide this test case as output for the users, and will feed this
test case back in its workﬂow to synthesize and select further alternative path
conditions out of it, and generate further test cases that cover other execution
paths of the program.

4 Path Selection

This section presents in detail the path selection strategy of Tardis, which is
the core technical novelty of the approach.

The set of alternative path conditions generated by Tardis can be large, and
thus a path selection problem materializes. Furthermore many alternative path
conditions generated by Tardis could be unsatisﬁable, that is path conditions
for which there is no input that makes executable the associated path and from
which no test case can be generated. The more the path selection strategy
chooses path conditions, and therefore paths, from which it is not possible to
generate new test cases, the more resources are wasted and the process of gen-
erating a test suite will be long. Therefore it is essential to be able to ”avoid”
these unsatisﬁable path conditions, i.e. to analyze them with less probability in
comparison with the satisﬁable ones.

In order to make the path selection technique as eﬃcient as possible and
to direct the tool to the choice of feasible paths, we decided to use a machine
learning model to classify a-priori the satisﬁable path conditions from the un-
satisﬁable ones, that is, predict whether it is possible or not possible to generate
a test case from a particular path condition. In this way, Tardis aims to solve
the problem of waste of resources during the analysis of the unsatisﬁable path
conditions.

Figure 1 shows how Tardis integrates with the classiﬁcation model, designed
to solve the problem. The selection of the alternative path conditions generated
by Tardis to be sent to EvoSuite is made by considering the classiﬁcation (fea-
sible or infeasible) computed by the model (highlighted in red in the ﬁgure) for
each path condition. After the model classiﬁes the alternative path conditions
generated, Tardis more likely chooses those that according to the classiﬁer can
lead to the generation of a test case, in order to pass them to EvoSuite.

Tardis receives feedback directly from the test generation attempts that it
submits to Evosuite at runtime; therefore the classiﬁcation model is designed to
incrementally adapt its predictions as the training set grows over time. This is
because, whenever EvoSuite is able or not to generate a test case from a path
condition, this information is added to the training set to be used to classify
future path conditions. In other words, whenever EvoSuite is able to generate
a test case from a path condition, it is added to the training set with the
”feasible” label. On the other hand, if EvoSuite cannot generate a test case,
the path condition is added to the training set associated with the ”infeasible”
label.

The designed classiﬁcation process can be summarized as follows. We use a
classiﬁcation model (KNN) capable of classifying the path conditions as either

12

Figure 2: Classiﬁcation procedure diagram.

feasible or infeasible. This occurs by evaluating the similarity of the path con-
ditions still to be analyzed with the path conditions already analyzed for which
Tardis knows if they are satisﬁable or unsatisﬁable.

To make the classiﬁcation problem less “noisy”, Tardis preprocess the path
conditions (Slicing) in order to identify the sub-formulas that contribute, inde-
pendently of each other, to the unsatisﬁability of the path conditions.

A hashing-based methodology to represent path conditions has been deﬁned
to foster the eﬃcient calculation of the similarity between the path conditions.

4.1 Path condition Slicing

A preprocessing phase of the data has been deﬁned to help the classiﬁer to better
identify the patterns characterizing the feasibility and the infeasibility. Since
the alternative path conditions generated by Tardis originate from the path
conditions of concrete test cases, it is known that the path condition from which
the alternative one derives is satisﬁable (this is because Tardis uses only path
conditions that have been veriﬁed as satisﬁable as candidates for the generation
of alternative path conditions, i.e. those from which it managed to generate a
test case). Thus, in order to study the unsatisﬁability of a new (alternative)
path condition, we need to focus only the last part of the new path condition,
that is, the part that changed with respect to the satisﬁable path condition,
along with all other parts that predicate on the same variables as the last part.
To do this, a formula manipulation technique called Slicing was used. For-
mula Slicing can be deﬁned as follows: It slices a formula into sub-formulas
that are mutually independent, that is, sub-formulas containing diﬀerent vari-
ables. Slicing splits a formula into a set of independent sub-formulas. Two
formulas are independent if and only if they do not share any variable. The
satisﬁability of a complex formula can be determined from the satisﬁability of
its sub-formulas: if all the independent sub-formulas are satisﬁable, the original
formula is satisﬁable too, otherwise the original formula is unsatisﬁable. Slicing
formulas produces smaller formulas that are easier to handle and more likely to
be equivalent to previously solved formulas.

The alternative path conditions generated by Tardis can be divided into
two parts: a preﬁx and a suﬃx. The suﬃx is the last part of the formula, i.e.

13

the clause that Tardis modiﬁes to generate a new alternative path condition
to analyze. The preﬁx is all that part of the formula that remains unchanged.
This part, since it was previously already analyzed by Tardis, is satisﬁable
by construction (for the reason mentioned above). For this reason, Slicing is
performed only relative to the suﬃx. All conditions of the path condition that
are independent from the suﬃx are satisﬁable by construction.

Figure 3: Example of Slicing applied to the Tardis system.

Tardis implements the slicing of the path conditions by considering two types

of dependencies: variable-based dependency and object-based dependency.

Variable-based dependency Two formulas have a mutual dependency if
they predicate on intersecting sets of variables. In the example shown in ﬁgure
3 the ﬁrst path condition represents a path condition previously analyzed by
Tardis from which the tool generated a test case. The second one is a possible
alternative path condition generated by the tool: the last condition has been
modiﬁed. This will be considered as the suﬃx; all the previous part will be the
preﬁx of the path condition. It is possible to see that in the ﬁnal formula, after
applying Slicing, the condition a > 0 is no longer present because this clause
does not share any variable with the suﬃx. The c > 0 clause is not directly
connected with the suﬃx but is still kept in the formula. This is because it is
indirectly connected by the c + b > 0 clause. The transitivity relationship is
therefore fundamental when the Slicing procedure is applied.

Object-based dependency We also take into consideration the cases where
the relationship between diﬀerent variables that belong to the same object might
depend on implicit invariants maintained by the methods that control the in-
stantiation and the access policy of the objects. Consequently, the dependence
based on the object to which the variables belong was also taken into consid-
eration, in addition to the dependency between clauses based on the direct or
indirect sharing of variables. In the same way as variable-based dependency,
object-based dependency is applied transitively.

Let’s take as an example a simple path condition like {O2.c < 0 ∧ O1.b >
0 ∧ O1.a > 0}. By applying the same procedure as in ﬁgure 3, the formula is
divided into suﬃx (last clause) and preﬁx (remaining clauses). Using transitive

14

variable-based dependency only, the three clauses would be independent; how-
ever using the concept of objects-based dependency too, we can see how the suf-
ﬁx is related to the clause O1.b > 0 because they belong to the same O1 object.
The resulting path condition after the slicing process is {O1.b > 0 ∧ O1.a > 0}.

The Slicing procedure in Tardis is a transitive closure of the dependencies
between the clauses of a formula in relation to the last clause of the formula
itself, where the dependencies are managed according to variables and objects in
a transitive way. The idea is based on the fact that, to establish the satisﬁability
of a formula whose preﬁx is certainly satisﬁable and to which a new part (suﬃx)
is added, the satisﬁability depends only on the clauses of the preﬁx that share,
directly or indirectly, variables or objects with the suﬃx.

4.2 Formulas ﬁngerprints

Since path conditions are conjunction of clauses, the objective of the classiﬁca-
tion model is to recognize the similarity between the path conditions that share
sets of joint clauses. In this way, if the model recognizes that a path condition is
similar as a subset of conjuncts to one that was previously associated with the
infeasible label (the greater the number of clauses they share and the greater
their similarity), then the tool will penalize this path condition, in terms of pri-
orities for the transition to EvoSuite. Vice versa, if the model recognizes that
a path condition is similar as a subset of conjuncts to one that has previously
been associated with the feasible label, it will give higher priority to this one.

To do this, a methodology was deﬁned for the representation of the path
conditions generated by Tardis, so that these could be eﬀectively managed by a
classiﬁcation model. It was used a Bloom Filter structure that allows to repre-
sent the containment of elements between sets in a compact way; in our speciﬁc
case, this property was adapted to represent path conditions as a containment
of sets of clauses.

A Bloom ﬁlter is a space-eﬃcient probabilistic data structure that is used
to test whether an element is a member of a set. False positive matches are
possible, but false negatives are not; in other words, a query returns either
”possibly in set” or ”deﬁnitely not in set.” Elements can be added to the set, but
not removed; the more items added, the larger the probability of false positives.
An empty Bloom ﬁlter is a bit array of m bits, all set to 0. There must also be k
diﬀerent hash functions deﬁned, each of which maps an element, by hashing the
element itself, on one of the m positions of the array. The number k of hashing
functions used is ﬁxed and much smaller than the number of bits m in the array.
To add an element to the structure, we feed it to each of the k hash functions

to get k array positions. Then set the bits at all these positions to 1.

To query for an element (test whether it is in the set), feed it to each of the
k hash functions to get k array positions. If any of the bits at these positions
is 0, the element is deﬁnitely not in the set; if it were, then all the bits would
have been set to 1 when it was inserted. If all are 1, then either the element is

15

in the set, or the bits have by chance been set to 1 during the insertion of other
elements, resulting in a false positive. In this data structure there is no way to
distinguish between the two cases.

Figure 4: The ﬁgure shows an example of the use of a Bloom Filter. The three
elements {x, y, z} are represented in the data structure. The colored arrows
show the bits on which the three elements of the set are mapped (in this case
three hash functions for each element). The element w is not contained within
the set {x, y, z} because one of the three hash functions maps the element on a
bit set to 0.

Since this data structure is able to represent and manage sets of elements, it
was chosen to represent our path conditions produced by Tardis as sets of con-
ditions. Speciﬁcally, each path condition is represented through a Bloom Filter
structure: each condition of the path condition is inserted into the structure by
mapping it to the m bits through k hash functions.

A data structure based on the Bloom Filter, but slightly modiﬁed (Multidi-
mensional Bloom Filter: ﬁgure 5), was developed so that it could better adapt
to the operation of the Tardis tool. Using a classic single-row Bloom Filter
(ﬁgure 4), the problem arises that similar formulas can be mapped to diﬀerent
points in the bit space. This could cause problems to a classiﬁcation model like
our type since it may not always be the same formula, but similar formulas, to
cause unsatisﬁability. The Multidimensional Bloom Filter structure was created
to solve this problem.

This structure works on two dimensions, the X axis and the Y axis. We
get a matrix of size m x n. To understand how it works, the matrix can be
ideally divided into two main areas: the ﬁrst row Y1 (gray in ﬁgure 5), and the
columns below X1, X2, ..., Xm starting from row Y2. Each bit of the ﬁrst row
corresponds to a column of bits below. For example, the column relating to
the bit of the ﬁrst row X1Y1 is the column of bits starting from position X1Y2
and ending at position X1Yn (circled in green in ﬁgure 5). This organization is
applied to all the bits in the array.

This structure was designed to generate a bit organization that could best
characterize the similarity between formulas. This factor is important to solve
our classiﬁcation problem since it may not always be the same formula, but
similar formulas, to cause unsatisﬁability. Speciﬁcally, this organization was
designed to manage two diﬀerent types of path conditions: abstract path con-

16

Figure 5: Multidimensional Bloom Filter structure example.

ditions and concrete path conditions. From a single path condition generated
by Tardis, two path conditions are developed. The ﬁrst is the abstract one in
which, within the clauses that compose it, there are no numeric elements such
as speciﬁc values or indices of the arrays. The second is the concrete one, that
is the original one.

Considering a path condition of this type: {a[0] > 6 & b[2] > 3 & a[5] > 6};
the concrete clauses will be {a[0] > 6}, {b[2] > 3} end {a[5] > 6}; the abstract
clauses will be {a[.] > .}, {b[.] > .} end {a[.] > .}

The Multidimensional Bloom Filter structure is used as follows: the clauses
of the abstract path conditions are mapped, through hash functions, to the ﬁrst
row of the matrix. The clauses of the concrete path conditions are subsequently
mapped on the underlying columns corresponding to the bits set to 1 in the
ﬁrst row. In this way, similar clauses are always mapped in bits positioned in
the same area (same columns) and the problem of sparsity, mentioned above, is
avoided.

In ﬁgure 5 x, y, z represent the abstract clauses of an abstract path condition
({a[.] > .}, {b[.] > .} and {a[.] > .} of the example above). After that the
abstract clauses are mapped on the ﬁrst row through the 3 hash functions,
the corresponding concrete clauses ({a[0] > 6}, {b[2] > 3} end {a[5] > 6} of
the example above) of the concrete path condition are mapped on the columns
corresponding to the bits set to 1 of the ﬁrst row. In this example it is possible

17

to notice how the clauses x and z are similar clauses since they turn on the
same 3 bits of the ﬁrst row; this means that they have the abstract clauses that
coincide. Consequently, the concrete clauses are mapped on the same 3 columns
(pink and blue colored bits). The y clause, on the other hand, is not similar
to the other two because its abstract clause is mapped on diﬀerent bits of the
ﬁrst row. Consequently, the concrete clauses are mapped on the corresponding
columns which, however, are diﬀerent from those of the other two clauses (bits
colored red).

In the example in the ﬁgure, an optimal case is managed, that is a situation
in which each clause of the path condition is mapped on three diﬀerent bits
through the three diﬀerent hash functions. This fact, due to properties intrinsic
to the type of structure, is not always respected; it may happen that diﬀerent
hash functions map diﬀerent clauses on the same bit. Therefore the possibility of
”collisions” between bits is accepted because the elimination of the possibility of
duplication of the outputs is not guaranteed (it is possible that the same output
value is returned from diﬀerent hash functions and diﬀerent input data).

4.3 Satisﬁability predictions

K-Nearest Neighbors was chosen as the classiﬁcation model to be integrated
into Tardis.

The k-nearest neighbors (KNN) is an algorithm used in patterns recognition
to classify objects, it is based on the characteristics of the objects close to the
one considered. The predictions are made for each new instance (x) by looking
for the most similar K instances (the neighbors) in the entire training set and
choosing the output variable through these K instances only. Distance metrics
are used to determine which of the K instances in the training set is more like
a new input.

When KNN is used to solve a classiﬁcation problem, the output is calculated
as the class with the highest frequency from the most similar K instances (the
K neighbors). Basically, each neighbor votes for their own class and the class
with the highest number of votes is taken as a prediction.

The main reason we choose this model is that the Knn has training time
equal to 0 and this guarantees that it does not have to stop the Tardis execution
to retrain the model while the training set gradually grows. This feature is
fundamental since the training set, through which the classiﬁcations are made,
gradually grows while Tardis works.

The distance measurement called Jaccard is used to determine which in-
stances in the training set are the most similar to a new input. This distance
is calculated between two x and y vectors consisting of T RU E, F ALSE or 0, 1
values.
In our case the distance is calculated between two matrices, of size
mXn, generated by the procedure deﬁned in section 4.2; each matrix repre-
sents an alternative path condition generated by Tardis. The Jaccard distance
is a distance used to measure the similarity between two x and y vectors. The
similarity is returned in output as a value between 0, which indicates a non-
similarity between the two vectors, and 1, which means that the two vectors are

18

identical.

For logical vectors x and y, we deﬁne the following:
• a11 = number of times where xi = 1 e yi = 1
• a10 = number of times where xi = 1 e yi = 0
• a01 = number of times where xi = 0 e yi = 1
• a00 = number of times where xi = 0 e yi = 0

where i indicates the position in the vector. Similarity is calculated using the
following formula:

a11
a11 + a10 + a01

(1)

For each of the alternative path conditions generated by Tardis the output

of this classiﬁcation model will be label 0 or 1, where:

• 0 if the BloomFilter structure refers to an unsatisﬁable path condition
(the classiﬁer predicts that the tool will not be able to generate a test case
for that path condition).

• 1 if the BloomFilter structure refers to a satisﬁable path condition (the
classiﬁer predicts that the tool will be able to generate a test case for that
path condition).

The K value (number of neighbors to be considered for classiﬁcation) is set

to 3.

4.4 Path selection strategy

The choice of path conditions to be passed to EvoSuite, considering the classi-
ﬁcation given by the model, is managed in a probabilistic way. The alternative
path conditions which have still to be analyzed are divided according to two
elements: classiﬁcation and voting. Classiﬁcation is the label, 0 or 1, assigned
through the classiﬁcation model to each of the path conditions still to be ana-
lyzed. Voting is a value that measures by which majority the K neighbors voted
for the classiﬁcation (voting can take the value 2 or 3 working with a K equal
to 3).

Path conditions are divided into four sets based on the classiﬁcation ob-
tained via KNN: label1Voting3, label1Voting2, label0Voting2 and label0Voting3.
As mentioned previously, the classiﬁcation model is an incremental model since
the training set grows during tool execution. Whenever EvoSuite is able or not
able to generate a test case from a path condition, this information is added to
the training set to be used to classify future path conditions. For this reason,
the classiﬁcations of the path conditions that still have to be analyzed are recal-
culated several times during the execution of Tardis and may change over time;
consequently, the distribution of path conditions within the four sets changes
over time too.

The system will pick up the path condition from these sets with following

probabilities:

19

1. label=1, voting=3 : 50%

2. label=1, voting=2 : 30%

3. label=0, voting=2 : 15%

4. label=0, voting=3 : 5%

Path conditions that are classiﬁed as feasible through an unanimous vote by

the neighboring k have greater probability of extraction than all the others.

Once the set from which to take the path condition is selected, the cumula-
tive is performed to select the actual path condition to be passed to EvoSuite.
Speciﬁcally, the cumulative is calculated on the values obtained from the aver-
ages of the Jaccard distances of the k neighbors.

The cumulative can be deﬁned in the following way: given a list of values,
each element will become the sum between itself and its previous elements. For
example, if I have a list composed of the values {5, 7, 2, 4} the corresponding
cumulative will be {5, 12, 14, 18}. The goal is to generate a serie of intervals with
the cumulative of the averages of Jaccard distances. For the example above, the
ranges are: [0, 5), [5, 12), [12, 14), [14, 18). By randomly extracting a number
between the minimum and the maximum value of the intervals, this will belong
to one of these. Based on the interval to which the random value belongs, the
corresponding path condition will be extracted to be passed to EvoSuite.

Using the cumulative calculated on the averages of the distances of the se-
lected set, the elements with greater distance, and therefore with greater sim-
ilarity, will be extracted with greater probability because the corresponding
intervals will be wider.

Summarizing, two random extractions are carried out to choice the path
condition to be passed to EvoSuite; the ﬁrst is used to select one of the four
sets from which to extract the path condition (with the probabilities deﬁned
previously); the second random extraction is used to extract the actual path
condition and is carried out using the cumulative average of the Jaccard k
distances.

4.5

Incremental learning algorithm

As already mentioned, the classiﬁcation model integrated in Tardis is incre-
mental and consequently the training set grows over time. For this reason, the
classiﬁcations of the path conditions that still have to be analyzed are recalcu-
lated several times during tool execution. To ensure that this does not aﬀect
performance, a threshold-based cashing mechanism was implemented: the re-
classiﬁcation of the already classiﬁed path conditions, which must be carried out
again since the training set changed, is carried out every time the training set
grows by a certain threshold. Path conditions that have never been classiﬁed
In this way continuous reclassiﬁcation of all path
are classiﬁed immediately.
conditions is avoided.

As far as the mechanism for choosing the set from which to take the path con-
dition concerns, if the set selected through the random extraction is empty, the

20

immediately following non-empty set is chosen. For example, if label1Voting3
is extracted but it is empty, then label1Voting2 is chosen if there is at least
one element inside the latter; If label1Voting2 is also empty, then we pass to
label0Voting2 and so on.

The bloom Filter structure was implemented as a 64 x 16 bit size matrix
that uses 3 hash functions to map each clause. This conﬁguration was used for
the experiments in the chapter 5.

5 Empirical Evaluation

This section reports on a set of initial experiments that evaluate the eﬀective-
ness of Tardis and in particular of the path selection strategy explained in the
previous section.

The evaluation metric used is based on comparing the results of Tardis with
and without our classiﬁcation model, to verify whether the former is more eﬃ-
cient in choosing the feasible paths. Therefore we compare the results of Tardis
in terms of number of feasible paths explored, when the selection strategy is
used, with the case when it is not used. In the second case Tardis uses a queue
based on the FIFO (First In, First Out) principle as a method for selecting the
paths to be analyzed, i.e. it uses FIFO to manage the transition to EvoSuite of
the alternative path conditions generated.

Experimental setting The comparison is based on the sample program dis-
cussed in section 2.

A timeBudgetDuration equal to 30 has been set to carry out this evaluation;
this means that the data obtained and analyzed refer to the ﬁrst 30 minutes
of Tardis execution.
In addition, the numOfThreads parameter has been set
equal to 5; this means that 5 threads can run simultaneously and then analyze
5 path conditions simultaneously. The maximum time that can be dedicated to
analyze a path condition, beyond which it is established that this is satisﬁable, is
a conﬁguration parameter and can vary; during these experiments the parameter
was set at 180 seconds.

Results
Image 6 shows the number of path conditions analyzed when Tardis
uses the classiﬁer (in green) or work without classiﬁer (in red). The displayed
data are the average of the data obtained on several Tardis executions.

Interestingly, the data highlight that the feasible path conditions analyzed
during the Tardis executions with the classiﬁer doubled in comparison to those
analyzed during the execution of the tool without classiﬁer. At the same time,
it is true the number of infeasible path conditions remains high, but this is an
eﬀect of the large amount of alternative infeasible path conditions generated by
the sample program.

By carrying out a thorough analysis of the alternative path conditions pro-
duced by Tardis in the ﬁrst 30 minutes, on average 15 alternative feasible path
conditions are produced. Nevertheless, despite the feasible path conditions are

21

Figure 6: Distribution histogram of the analyzed path conditions.

a small number if compared with the large amount of the infeasible ones, the
main result is that Tardis with classiﬁer is able to choose, in the ﬁrst 30 min-
utes, two thirds of the feasible alternative path conditions produced (∼10 out
of ∼15).

6 Conclusions

At the state of the art, the problem of generating adequate sets of complete test
cases has not been satisfactorily solved yet. This article proposed an approach
that distinctively combines dynamic symbolic execution, search-based testing
and machine learning, to eﬃciently generate thorough class-level test suites.
The approach consists of exploring the path space of the target programs with
dynamic symbolic execution, instantiating complete test cases with a genetic
search algorithm guided with ﬁtness functions that represent the satisﬁability
of the symbolic path conditions, and prioritizes the symbolic formulas that more
likely correspond to feasible program paths based on an original classiﬁcation al-
gorithm trained on the characteristics of the formulas for which it ether succeeds
or fails overtime.

From the experiments carried out on the program explained in section 2,
we can say that this is a successful approach. In particular, the core technical
novelty of this approach, i.e. the path selection strategy based on classiﬁcation
algorithm, is eﬀective as it increases the number of feasible paths of the program
analyzed and consequently it increases the number of test cases produced. In the
future we are planning to carry out further experiments to conﬁrm the results
in a more generalized way by carrying out an extensive experimentation with
real programs.

22

References

[1] J. Edvardsson, “A survey on automatic test data generation,” in Proceed-
ings of the Second Conference on Computer Science and Engineering. EC-
SEL, 1999, pp. 21–28.

[2] B. Korel, “Automated software test data generation,” vol. 16, no. 8, pp.

870–879, 1990.

[3] P. McMinn, “Search-based software test data generation: a survey,” vol. 14,

pp. 105–156, 2004.

[4] P. Braione, G. Denaro, and M. Pezz`e, “Symbolic execution of programs
with heap inputs,” in Proceedings of the European Software Engineering
Conference held jointly with the ACM SIGSOFT International Symposium
on Foundations of Software Engineering, ser. ESEC/FSE ’15, 2015, pp.
602–613.

[5] N. Tillmann and J. de Halleux, “Pex: White box test generation for .NET,”
in Proceedings of the International Conference on Tests and Proofs, ser.
TAP ’08. Springer-Verlag, 2008, pp. 134–153.

[6] C. Boyapati, S. Khurshid, and D. Marinov, “Korat: Automated testing

based on java predicates,” ser. ISSTA ’02, 2002, pp. 123–133.

[7] T. Xie, D. Marinov, W. Schulte, and D. Notkin, “Symstra: a framework
for generating object-oriented unit tests using symbolic execution,” ser.
TACAS ’05. Springer-Verlag, 2005, pp. 365–381.

[8] C. Pacheco, S. K. Lahiri, M. D. Ernst, and T. Ball, “Feedback-directed

random test generation,” ser. ICSE ’07, 2007, pp. 75–84.

[9] S. Thummalapenta, T. Xie, N. Tillmann, J. de Halleux, and Z. Su, “Syn-
thesizing method sequences for high-coverage testing,” in Proceedings of
the 2011 ACM International Conference on Object Oriented Programming
Systems Languages and Applications, ser. OOPSLA ’11. ACM, 2011, pp.
189–206.

[10] G. Fraser and A. Arcuri, “Whole test suite generation,” vol. 39, no. 2, pp.

276–291, 2013.

[11] P. Braione, G. Denaro, A. Mattavelli, and M. Pezz`e, “Combining sym-
bolic execution and search-based testing for programs with complex heap
inputs,” in Proceedings of the 26th International Symposium on Software
Testing and Analysis, ser. ISSTA ’17. ACM, 2017, p. to appear.

[12] S. Anand, C. S. P˘as˘areanu, and W. Visser, “JPF-SE: A symbolic execution
Springer-Verlag, 2007,

extension to Java PathFinder,” ser. TACAS ’07.
pp. 134–138.

23

[13] P. Braione, G. Denaro, and M. Pezz

®, “Enhancing symbolic execution
with built-in term rewriting and constrained lazy initialization,” in Pro-
ceedings of the 9th Joint Meeting of the European Software Engineering
Conference and the ACM SIGSOFT Symposium on the Foundations of
Software Engineering (ESEC/FSE 2013), 2013, pp. 411–421.

√

[14] J. Burnim and K. Sen, “Heuristics for scalable dynamic test generation.”

IEEE Computer Society, 2008, pp. 443–446.

[15] S. Person, G. Yang, N. Rungta, and S. Khurshid, “Directed incremental

symbolic execution,” ser. PLDI ’11, 2011, pp. 504–515.

[16] M. Baluda, G. Denaro, and M. Pezz`e, “Bidirectional symbolic analysis
for eﬀective branch testing,” IEEE Transactions on Software Engineering,
vol. 42, no. 5, pp. 403–426, 2015.

[17] P. Godefroid, N. Klarlund, and K. Sen, “Dart: directed automated random

testing,” ser. PLDI ’05, 2005, pp. 213–223.

[18] S. Khurshid, C. S. Pˇasˇareanu, and W. Visser, “Generalized symbolic exe-
cution for model checking and testing,” in Tools and Algorithms for Con-
struction and Analysis of Systems, ser. LNCS 2619. Springer, 2003.

[19] P. Braione, G. Denaro, and M. Pezz`e, “JBSE: A symbolic executor for
java programs with complex heap inputs,” in Proceedings of the European
Software Engineering Conference held jointly with the ACM SIGSOFT In-
ternational Symposium on Foundations of Software Engineering, ser. ES-
EC/FSE ’16, 2016, pp. 1018–1022.

[20] C. Cadar, D. Dunbar, and D. Engler, “Klee: Unassisted and automatic
generation of high-coverage tests for complex systems programs,” ser. OSDI
’08, 2008, pp. 209–224.

[21] A. Aquino, F. A. Bianchi, M. Chen, G. Denaro, and M. Pezz`e, “Reusing
constraint proofs in program analysis,” in Proceedings of the International
Symposium on Software Testing and Analysis, ser. ISSTA ’15. ACM, 2015,
pp. 305–315.

24

