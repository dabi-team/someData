Satisﬁability and Synthesis Modulo Oracles

Elizabeth Polgreen
University of Edinburgh and UC Berkeley

Andrew Reynolds
University of Iowa

Sanjit A. Seshia
UC Berkeley

1
2
0
2

l
u
J

8
2

]

O
L
.
s
c
[

1
v
7
7
4
3
1
.
7
0
1
2
:
v
i
X
r
a

Abstract—In classic program synthesis algorithms, such as
counterexample-guided inductive synthesis (CEGIS), the algo-
rithms alternate between a synthesis phase and an oracle (veriﬁ-
cation) phase. Many synthesis algorithms use a white-box oracle
based on satisﬁability modulo theory (SMT) solvers to provide
counterexamples. But what if a white-box oracle is either not
available or not easy to work with? We present a framework for
solving a general class of oracle-guided synthesis problems which
we term synthesis modulo oracles. In this setting, oracles may
be black boxes with a query-response interface deﬁned by the
synthesis problem. As a necessary component of this framework,
we also formalize the problem of satisﬁability modulo theories
and oracles, and present an algorithm for solving this problem.
We implement a prototype solver for satisﬁability and synthesis
modulo oracles and demonstrate that, by using oracles that
execute functions not easily modeled in SMT-constraints, such as
recursive functions or oracles that incorporate compilation and
execution of code, SMTO and SyMO are able to solve problems
beyond the abilities of standard SMT and synthesis solvers.

I. INTRODUCTION

A common formulation of program synthesis is to ﬁnd a
program, from a speciﬁed class of programs, that meets some
correctness speciﬁcation [5]. Classically, this is encoded as the
2nd-order logic formula ∃ (cid:126)f ∀(cid:126)x φ, where (cid:126)f is a set of target
functions to be synthesized, (cid:126)x is a set of 0-ary symbols, and φ
is a quantiﬁer-free formula in a logical theory (or combination
of theories) T . A tuple of functions (cid:126)f ∗ satisﬁes the semantic
restrictions if the formula ∀(cid:126)x φ is valid in T when the tuple
is substituted for (cid:126)f in φ. Many problems are speciﬁed in this
form, and the SyGuS-IF format [24] is one way of specifying
such syntax-guided synthesis (SyGuS) problems.

Whilst powerful, this format is restrictive in one key way:
it requires the correctness condition to be speciﬁed as a
satisﬁability modulo theories (SMT) [9] formula in a fully
white-box manner. Put another way, SyGuS problems must
be speciﬁed with static constraints before the solving process
begins. This limits the problems that can be speciﬁed, as
well as the oracles that can be used to guide the search. For
example, if one wants to synthesize (parts of) a protocol whose
correctness needs to be checked by a temporal logic model
checker (e.g. [30]), such a model-checking oracle cannot be
directly invoked within a general-purpose SyGuS solver and
instead requires creating a custom solver.

Similarly, SMT solvers, used widely in veriﬁcation and
synthesis, require their input to be encoded as a logical formula
prior to the initiation of solving. Whilst the language of SMT-
LIB is powerful and expressive, many formulas are challenging
for current SMT solvers to reason about; e.g., as in Figure 1,
ﬁnding a prime factorization of a given number. Here it would

( d e f i n e − fun − r e c i s P r i m e R e c

( ( a I n t )

( b I n t ) ) Bool

( i t e (> b ( d i v a 2 ) )

t r u e

( i t e

( = ( mod a b ) 0 )

f a l s e
( i s P r i m e R e c a ( + b 1 ) ) ) ) )

( d e f i n e − f u n i s P r i m e

( ( a I n t ) ) Bool

( i t e (<= a 1 )

f a l s e
( i s P r i m e R e c a 2 ) ) )

( a s s e r t
( a s s e r t

( and ( i s P r i m e f 1 ) ( i s P r i m e f 2 ) ( i s P r i m e f 3 ) ) )
( = ( * f 1 f 2 f 3 ) 7 6 ) )

Fig. 1: SMT problem fragment: ﬁnd prime factors of 76.
Unsolved by CVC4 v1.9. Solved by SMTO using isPrime
oracle in < 1s

be desirable to abstract this reasoning to an external oracle,
rather than rely on the SMT solver’s ability to reason about
recursive functions.

This motivates our introduction of oracles to synthesis and
SMT solving. Oracles can be black-box implementations that
can be queried based on a pre-deﬁned interface of query and
response types. Examples of oracles could be components of
systems that are too large and complex to analyze (but which
can be executed on inputs) or external veriﬁcation engines
solving veriﬁcation queries beyond SMT solving.

Prior work has set out a theoretical framework expressing
synthesis algorithms as oracle-guided inductive synthesis [21],
where a learner interacts with an oracle via a pre-deﬁned
oracle interface. However, this work does not give a general
algorithmic approach to solve oracle-guided synthesis problems
or demonstrate the framework on practical applications. An
important contribution we make in this work is to give a
uniﬁed algorithmic approach to solving oracle-guided synthesis
problems, termed SyMO. The SyMO approach is based on a
key insight: that query and response types can be associated
with two types of logical formulas: veriﬁcation assumptions
and synthesis constraints. The former provides a way to encode
restrictions on black-box oracle behavior into an SMT formula,
whereas the latter provide a way for oracles to guide the search
of the synthesizer.

In order to explain the use-case for assumptions, let us ﬁrst
introduce oracle function symbols and Satisﬁability Modulo
Theories and Oracles (SMTO). Oracle function symbols are
n-ary symbols whose behavior is associated with some oracle.
Consider a quantiﬁer-free formula ρ which contains an oracle
function symbol θ. SMTO looks for a satisfying assignment

 
 
 
 
 
 
Related work: Almost all synthesis algorithms can be framed
as some form of oracle-guided synthesis. Counterexample-
guided inductive synthesis (CEGIS) is the original synthesis
strategy used for Syntax-Guided Synthesis [29], and uses
a correctness oracle that returns counterexamples. Further
developments in synthesis typically fall
into one of two
categories. The ﬁrst comprises innovative search algorithms
to search the space more efﬁciently; for instance, genetic
algorithms [16], reinforcement learning [28], or partitioning
the search space in creative ways [6]. The second category
comprises extensions to the communication paradigm permitted
between the synthesis and the veriﬁcation phase. For instance,
CEGIS modulo theories [4], CEGIS(T), extends the oracle
interface over standard CEGIS to permit responses in the form
of a restricted set of constraints over constants in the candidate
program, while CVC4’s single-invocation algorithm [27] makes
full use of the white-box nature of the SMT solver oracle.
Other work leverages the ability to classify counterexamples
as positive or negative examples [23]. There are also notable
algorithms in invariant synthesis based on innovative use of
different query types [23], [19]. Our work has one key stand-out
difference over these: in all of these algorithms, the correctness
criteria must be speciﬁed as a logical formula, whereas in
our framework we enable speciﬁcation of the correctness
criteria as a combination of a logical formula and calls to
external oracles which may be opaque to the solver. Synthesis
with distinguishing inputs [20] is an exception to this pattern
and uses a speciﬁc set of three interacting black-box oracles,
to solve the very speciﬁc problem of synthesis of loop-free
programs from components. Our work differs from this and the
previously-mentioned algorithms in that they are customized to
use certain speciﬁc types of oracle queries, whereas, we give
a “meta-solver” allowing any type of oracle query that can be
formulated as either generating a constraint or an assumption
in the form of a logical formula.

The idea of satisﬁability with black-boxes has been tackled
before on work on abstracting functional components as
uninterpreted/partially-interpreted functions (see, e.g., [7], [14],
[13]), which use counterexample-guided abstraction reﬁne-
ment [15]. Here, components of a system are abstracted and
then reﬁned based on whether the abstraction is sufﬁciently
detailed to prove a property. However, to do this, the full
system must be provided as a white-box. The key contribution
our work makes in this area is a framework allowing the use
of black-box components that obey certain query-response
interface constraints, where the reﬁnement is dictated by these
constraints and the black-box oracle interaction.

II. ORACLES

In this section, we introduce basic deﬁnitions and terminol-
ogy for the rest of the paper. We begin with some preliminaries
about SMT and synthesis.

(a) Original image

(b) Target image

Fig. 2: Image manipulation: transformations synthesized by
SyMO in < 1 sec.

to the formula based on initially assuming θ is a universally
quantiﬁed uninterpreted function (i.e., we look for a satisfying
assignment that would work for any possible implementation
of the oracle): ∀θρ. As we make calls to the oracle, we begin to
learn more about its behavior, and we encode this behavior as
assumptions α, such that the formula becomes ∀θα ⇒ ρ. This
is the primary use case for assumptions generated by oracles,
they are used to constrain the behavior of oracle function
symbols. In SyMO, determining the correctness of a candidate
function is an SMTO problem, and assumptions generated by
oracles are used in the SMTO solving process.

As an exemplar of an existing oracle-guided synthesis algo-
rithm that goes beyond the SMT-solver-based counterexample
oracles, consider ICE-learning [19] for invariant synthesis.
ICE-learning uses three oracles: an oracle to provide positive
examples (examples which should be contained within the
invariant); an oracle to provide negative examples (examples
which should not be contained within the invariant); and an
oracle to provide implication examples (an example pair where
if the ﬁrst element is contained within the invariant, both must
be contained). Whilst it is possible to build some of these
oracles using an SMT solver, it is often more effective to
construct these oracles in other ways, for instance, the positive
example oracle can simply execute the loop or system for
which an invariant is being discovered and return the output.
We implement SyMO in a prototype solver Delphi, and
hint at its broad utility by demonstrating several applications
including programming by example, synthesis of controllers
for LTI systems, synthesizing image transformations (e.g.,
Figure 2, and satisﬁability problems that reason about primes
(e.g., Figure 1). The latter use cases illustrate the power of being
able to incorporate oracles into SyMO that are too complex to
be modeled or for SMT solvers to reason about.

To summarize, the main contributions of this paper are:

• A formalization of the problem of satisﬁability and synthesis

modulo oracles (Sec. II);

• A unifying algorithmic approach for solving these problems

(Sec. III and Sec. IV);

• Demonstration of how this approach can capture popular

synthesis strategies from the literature (Sec. V), and

A. Preliminaries and Notation

• A prototype solver Delphi, and an experimental demonstra-
tion of the broad applicability of this framework (Sec. VI).

We use the following basic notations throughout the paper.
If e is an expression and x is free in e, let e·{x → t} be the

2

formula obtained from the formula e by proper substitution of
the variable x by the variable t.

1) Satisﬁability Modulo Theories (SMT): The input to an
SMT problem is a ﬁrst-order logical formula ρ. We use ≈ to
denote the (inﬁx) equality predicate. The task is to determine
whether ρ is T -satisﬁable or T -unsatisﬁable, that is, satisﬁed
by a model which restricts the interpretation of symbols in ρ
based on a background theory T . If ρ is satisﬁable, a solver
will usually return a model of T that makes ρ true, which will
include assignments to all free variables in ρ. We additionally
say that a formula is T -valid if it is satisﬁed by all models of
T .

2) Syntax-Guided Synthesis: In syntax-guided synthesis, we
are given a set of functions (cid:126)f to be synthesized, associated
languages of expressions (cid:126)L = L1, . . . , Lm (typically generated
by grammars), and we seek to solve a formula of the form
∃ (cid:126)f ∈ (cid:126)L∀(cid:126)x φ

where (cid:126)x ≈ x1 . . . xn is a set of 0-ary symbols and φ is a
quantiﬁer-free formula in a background theory T . In some
cases, the languages Li include all well-formed expressions in
T of the same sort as fi, and thus Li can be dropped from
the problem. A tuple of candidate functions (cid:126)f ∗ satisﬁes the
semantic restrictions for functions-to-synthesize (cid:126)f in conjecture
∃ (cid:126)f ∀(cid:126)x φ in background theory T if ∀(cid:126)x φ is valid in T when
(cid:126)f are deﬁned to be terms whose semantics are given by the
functions ( (cid:126)f ∗) [5], [24].

B. Basic Deﬁnitions

We use the term oracle to refer to a (possibly black-box)
component that can be queried in a pre-deﬁned way by the
solver. An oracle interface deﬁnes how an oracle can be queried.
This concept is borrowed from [21]. We extend the deﬁnition
of oracle interfaces to also provide the solver with information
on the meaning of the response, in the form of expressions
that generate assumptions or constraints.

Deﬁnition II.1 (Oracle Interface). An oracle interface I is a
tuple ((cid:126)y, (cid:126)z, αgen, βgen) where:

• (cid:126)y is a list of sorted variables, which we call the query

domain of the oracle interface;

• (cid:126)z is a list of sorted variables, which we call its response

co-domain;

• αgen is a formula whose free variables are a subset of

(cid:126)y, (cid:126)z, which we call its assumption generator; and

• βgen is a formula whose free variables are a subset of

(cid:126)y, (cid:126)z, which we call its constraint generator.

(cid:50)

We assume that all oracle interfaces have an associated
oracle that implements their prescribed interface for values
of the input sort, and generates concrete values as output. In
particular, an oracle for an oracle interface of the above form
accepts a tuple of values with sorts matching (cid:126)y, and returns
a tuple of values with sorts matching (cid:126)z. It is important to
note that the notion of a value is speciﬁc to a sort, which we
intentionally do not specify here. In practice, we assume e.g.

I =


Q

R
αgen

βgen

: (y1 : σ1), . . . , (yj : σj)
1), . . . , (zk : σ(cid:48)
: (z1 : σ(cid:48)
k)
: assumption generator
: constraint generator

Fig. 3: Oracle interface

the standard values for the integer sort; we assume all closed
lambda terms are values for higher-order sorts, and so on.

An oracle interface deﬁnes how assumptions and constraints
can be given to a solver via calls to black-box oracles, as given
by the following deﬁnition.

Deﬁnition II.2 (Assumptions and Constraints Generated by
an Oracle Interface). Assume I is an oracle interface of form
((cid:126)y, (cid:126)z, αgen, βgen). We say formula αgen·{(cid:126)y → (cid:126)c, (cid:126)z → (cid:126)d} is
an assumption generated by I if calling its associated oracle
for input (cid:126)c results in output (cid:126)d. In this case, we also say that
βgen·{(cid:126)y → (cid:126)c, (cid:126)z → (cid:126)d} is a constraint generated by I. (cid:50)

We are now ready to deﬁne the main problems introduced
by this paper. In the following deﬁnition, we distinguish two
kinds of function symbols: oracle function symbols, which
are given special semantics in the following deﬁnition; all
others we call ordinary function symbols. As we describe in
more detail in Section III, oracle function symbols allow us
to incorporate function symbols that correspond directly to
oracles in speciﬁcations and assertions.

Deﬁnition II.3 (Satisﬁability Modulo Theories and Oracles).
A satisﬁability modulo oracles (SMTO) problem is a tuple
( (cid:126)f , (cid:126)θ, ρ, (cid:126)I), where (cid:126)f is a set of ordinary function symbols, (cid:126)θ is
a set of oracle function symbols, ρ is a formula in a background
theory T whose free function symbols are (cid:126)f (cid:93) (cid:126)θ, and (cid:126)I is a
set of oracle interfaces. We say this input is:

• unsatisﬁable if ∃ (cid:126)f .∃(cid:126)θ.A ∧ ρ ∧ B is T -unsatisﬁable,
• satisﬁable if ∃ (cid:126)f .∀(cid:126)θ.A ⇒ (ρ ∧ B) is T -satisﬁable,

where, in each case, A (resp. B) is a conjunction of assumptions
(resp. constraints) generated by (cid:126)I. (cid:50)

According to the above semantics, constraints are simply
formulas that we conjoin together with the input formula.
Assumptions play a different role. In particular, they restrict
the possible interpretations of (cid:126)θ that are relevant. As they
appear in the antecedent in our satisﬁability criteria, values of
(cid:126)θ that do not satisfy our assumptions need not be considered
when determining whether an SMTO input is satisﬁable. As a
consequence of the quantiﬁcation of (cid:126)θ, by convention we will
say a model M for an SMTO problem contains interpretations
for function symbols in (cid:126)f only; the values for (cid:126)θ need not be
given.

It is important to note the role of the quantiﬁcation for
oracle symbols (cid:126)θ in the above deﬁnition. An SMTO problem is
unsatisﬁable if the conjunction of assumptions, input formula,
and constraints are unsatisﬁable when treating (cid:126)θ existentially,
i.e. as uninterpreted functions. Conversely, an SMTO problem

3

is satisﬁable only if there exists a model satisfying (ρ ∧ B) for
all interpretations of (cid:126)θ for which our assumptions A hold.

In the absence of restrictions on oracle interfaces (cid:126)I, an
SMTO problem can be both satisﬁable and unsatisﬁable,
depending on the constraints and assumptions generated. For
instance, when A becomes equivalent to false, the input is
trivially both unsatisﬁable and satisﬁable. However, in practice,
we deﬁne a restricted fragment of SMTO, for which this is
not the case, and we present a dedicated procedure for this
fragment in Section III. To deﬁne this fragment, we introduce
the following deﬁnition.

Deﬁnition II.4 (Oracle Interface Deﬁnes Oracle Function Sym-
bol). An oracle interface J deﬁnes an oracle function symbol
θ if it is of the form ((y1, . . . yj), (z), θ(y1, . . . yj) ≈ z, ∅), and
its associated oracle O is functional. In other words, calling
the oracle interface generates an equality assumption of the
form θ(y1, . . . yj) ≈ z only. (cid:50)

From here on, as a convention, we use J to refer to an
oracle interface that speciﬁcally deﬁnes an oracle function
symbol, and I to refer to a free oracle interface, i.e., an oracle
interface which may not deﬁne an oracle function symbol.

Deﬁnition II.5 (Deﬁnition Fragment of SMTO). An SMTO
problem ( (cid:126)f , (cid:126)θ, ρ, (cid:126)J ) is in Deﬁnitional SMTO if and only if
(cid:126)θ = (θ1, . . . , θn), (cid:126)J = (J1, . . . , Jn), and Ji is an oracle
interface that deﬁnes θi for i = 1, . . . , n. (cid:50)

Note that each oracle function symbol is deﬁned by one and

only one oracle interface.

We are also interested in the problem of synthesis in the
presence of oracle function symbols, which we give in the
following deﬁnition.

Deﬁnition II.6 (Synthesis Modulo Oracles). A synthesis
modulo oracles (SyMO) problem is a tuple ( (cid:126)f , (cid:126)θ, ∀(cid:126)x. φ, (cid:126)I),
where (cid:126)f is a tuple of functions (which we refer to as the
functions to synthesize), (cid:126)θ is a tuple of oracle function symbols,
∀(cid:126)x. φ is a formula is some background theory T where
φ is quantiﬁer-free, and (cid:126)I is a set of oracle interfaces. A
tuple of functions (cid:126)f ∗ is a solution for synthesis conjecture if
((cid:126)x, (cid:126)θ, ¬φ·{ (cid:126)f → (cid:126)f ∗}, (cid:126)I) is unsatisﬁable modulo theories and
oracles. (cid:50)

Although not mentioned in the above deﬁnition, the synthesis
modulo oracles problem may be combined with paradigms for
synthesis that give additional constraints for (cid:126)f that are not
captured by the speciﬁcation, such as syntactic constraints in
syntax-guided synthesis. In Section IV, we present an algorithm
for a restricted form of SyMO problems where the veriﬁcation
of candidate solutions (cid:126)f ∗ reduces to Deﬁnitional SMTO.

III. SATISFIABILITY MODULO THEORIES AND ORACLES

In this section, we describe our approach to solving inputs in
the deﬁnition fragment of SMTO, according to Deﬁnition II.5.
First, we note a subtlety with respect
to satisﬁability of
SMTO problems in the deﬁnition fragment vs. the general
problem. Namely that a problem cannot be both satisﬁable

Fig. 4: Satisﬁability Modulo Oracle Solver

and unsatisﬁable, and once a result is obtained for Deﬁnitional
SMTO, the result will not change regardless of subsequent
calls to the oracles. This is not true for the general SMTO
problem. In particular, note the following scenarios:

a) Conﬂicting Results: Assume that ∃ (cid:126)f .∃(cid:126)θ.Ai ∧ ρ ∧ Bi
is T -unsatisﬁable, where Ai (resp. Bi be the conjunction of
assumptions (resp. constraints) obtained after i calls to the
oracles. In unrestricted SMTO, it is possible that Ai alone
is T -unsatisﬁable, thus ∀(cid:126)θAi ⇒ (ρ ∧ Bi) is T -satisﬁable and
the problem is both satisﬁable and unsatisﬁable. However,
in Deﬁnitional SMTO, it is impossible for Ai alone to be
unsatisﬁable, since all oracle interfaces deﬁning oracle function
symbols, which generate assumptions only of the form θ((cid:126)y) ≈
z and the associated oracles are functional.

b) Non-ﬁxed Results: Assume that ∃ (cid:126)f .∀(cid:126)θ.Ai ⇒ (ρ ∧ Bi)
is T -satisﬁable, where Ai (resp. Bi be the conjunction of
assumptions (resp. constraints) obtained after i calls to the
oracles. Thus, by Deﬁnition II.3, our input is satisﬁable. In
unrestricted SMTO, it is possible for an oracle to later generate
an additional constraint β such that ∀(cid:126)θAi ⇒ (ρ ∧ Bi ∧ β)
is T -unsatisﬁable, thus invalidating our previous result of
“satisﬁable”. However, in Deﬁnitional SMTO, this cannot
occur, since oracles that generate non-trivial constraints are
not permitted. It is trivial that once any SMTO is unsatisﬁable,
it remains unsatisﬁable. Thus the satisﬁability results for
Deﬁnitional SMTO, once obtained, are ﬁxed.

A. Algorithm for Deﬁnitional SMTO

Our algorithm for Deﬁnitional SMTO is illustrated in
Figure 4 and given as Algorithm 1. The algorithm maintains a
dynamic set of assumptions A generated by oracles. In its main
loop, we invoke an off-the-shelf SMT solver (which we denote
SM T ) on the conjunction of ρ and our current assumptions
A. If this returns UNSAT, then we return UNSAT along with
the set of assumptions A we have collected. Otherwise, we
obtain the model M generated by the SMT solver from the
previous call.

The rest of the algorithm (lines 8 to 20) invokes what we
call the oracle consistency checker. Intuitively, this part of
the algorithm checks whether our assumptions A about (cid:126)θ are

4

consistent with the external implementation the oracle function
symbols are associated with.

We use the following notation: we write e[t] to denote an
expression e having a subterm t, and e[s] to denote replacing
that subterm with s. We write t↓ to denote the result of partially
evaluating term t. For example, (θ(1 + 1) + 1)↓ = θ(2) + 1.
In the oracle consistency checker, we ﬁrst construct the
formula µ which replaces in ρ all occurrences of ordinary
function symbols f with their value in the model M , and
partially evaluate the result. Thus, initially, µ is a formula
whose free symbols are (cid:126)θ only. The inner loop (lines 9 to
17) incrementally simpliﬁes this formula by calling external
oracles to evaluate (concrete) applications of functions from
(cid:126)θ. In particular, while µ contains at least one application of a
function from (cid:126)θ, that is, it is of the form µ[θi((cid:126)c)] where (cid:126)c is a
vector of values. We know that such a term exists by induction,
noting that an innermost application of a function from (cid:126)θ must
be applied to values. We replace this term with the output d
obtained from the appropriate oracle. The call to the oracle for
input values (cid:126)c may already exist in A; otherwise, we call the
oracle Ji for this input and add this assumption to A. After
replacing the application with d, we partially evaluate the result
and proceed. In the end, if our formula µ is the formula true,
the consistency check succeeds and we return SAT, along with
the current set of assumptions and the model M . We restrict
the returned model so that it contains only interpretations for
(cid:126)f and not (cid:126)θ, which we denote M | (cid:126)f . This process repeats until
a model is found that is consistent with the oracles, or until
the problem is shown to be unsatisﬁable.

We will now show that this intuitive approach is consistent

with the previously deﬁned semantics for SMTO.

Theorem III.1 (Correctness of SMTO algorithm). Algorithm 1
returns UNSAT (resp. SAT) iff the SMTO problem ( (cid:126)f , (cid:126)θ, ρ, (cid:126)J )
is unsatisﬁable (resp. satisﬁable) according to Deﬁnition II.3.

Proof. UNSAT case: By deﬁnition, an SMTO problem is
unsatisﬁable if ∃ (cid:126)f .∃(cid:126)θ.A ∧ ρ is T -unsatisﬁable, noting that for
the deﬁnitional fragment of SMTO, B is empty. Algorithm 1
returns UNSAT when the underlying SMT solver returns
UNSAT on the formula ρ ∧ A0 for some A0. Since A0 is
generated by oracles (cid:126)J , it follows that our input is unsatisﬁable.
SAT case: By deﬁnition, an SMTO problem is SAT iff
∃ (cid:126)f .∀(cid:126)θ.A ⇒ ρ is T -satisﬁable for some A. Algorithm 1 returns
SAT when ρ∧A0 is SAT with model M for some A0, and when
the oracle consistency check subsequently succeeds. Assume
that the inner loop (lines 9 to 17) for this check ran n times and
that a superset An of A0 is returned as the set of assumptions
on line 19. We claim that M | (cid:126)f is a model for ∀(cid:126)θ.An ⇒
ρ. Let M (cid:48) be an arbitrary extension of M | (cid:126)f that satisﬁes
An. Note that such an extension exists, since by deﬁnition
of Deﬁnitional SMTO, An is a conjunction of equalities over
distinct applications of (cid:126)θ. Let µ0, µ1, . . . , µn be the sequence
of formulas such that µi corresponds to the value of µ after i
iterations of the loop on lines 9 to 17. We show by induction
on i, that M (cid:48) satisﬁes each µi. When i = n, µi is true and
the statement holds trivially. For each 0 ≤ i < n, we have

Algorithm 1: Satisﬁability Modulo Oracles (SMTO)

: ( (cid:126)f , (cid:126)θ, ρ, (cid:126)J )

input
output : UNSAT/SAT + assumptions A + (model M )?

1 Algorithm SMTO
A ← true
2
while true do

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

if SMT(ρ ∧ A)=UNSAT then

return UNSAT, A

else

Let M be model for ρ ∧ A from SM T
Let µ be (ρ·{ (cid:126)f → (cid:126)f M })↓
while µ is of the form µ[θi((cid:126)c)] do

if (θi((cid:126)c) ≈ d) ∈ A for some d then

µ ← µ[d]↓

else

Let d = call oracle(Ji, (cid:126)c)
A ← A ∪ (θi((cid:126)c) ≈ d)
µ ← µ[d]↓

end

end
if µ is true then

return SAT, A, M | (cid:126)f

end

end

end

that µi is the result of replacing an occurrence of θ((cid:126)c) with d
in µi−1 and partially evaluating the result, where θ((cid:126)c) ≈ d ∈
An. Since M (cid:48) satisﬁes θ((cid:126)c) ≈ d ∈ An and by the induction
hypothesis satisﬁes µi, it satisﬁes µi−1 as well. Thus, M (cid:48)
satisﬁes µ0, which is (ρ·{ (cid:126)f → (cid:126)f M })↓. Thus, since M (cid:48) is an
arbitrary extension of M | (cid:126)f satisfying An, we have that M | (cid:126)f
satisﬁes ∀(cid:126)θ.An ⇒ ρ and thus the input is indeed satisﬁable.

Theorem III.2 (Completeness for Decidable T and Finite
Oracle Domains). Let background theory T be decidable, and
let the domain of all oracle function symbols be ﬁnite. In this
case, Algorithm 1 terminates.

Proof sketch: Termination is guaranteed since the algorithm
never repeats the same assignment to oracle inputs, and there-
fore, all input-output pairs for each oracle will be exhausted
eventually. At this point, the oracle function symbols can
be replaced by interpreted functions (lookup tables), and the
formula reduces to one in the (decidable) background theory
T .

Termination is not guaranteed in all background theories
since it may be possible to write formulas where the number
of input valuations to the oracle function symbols that must
be enumerated is inﬁnite. For example, this is possible in the
theory of Linear Integer Arithmetic with an oracle function
symbol with integer arguments.

5

Algorithm 2: Synthesis Modulo Oracles

: ( (cid:126)f , (cid:126)θ, ∀(cid:126)xφ, (cid:126)J (cid:93) (cid:126)I)
input
output : solution (cid:126)f ∗ or no solution

1 A ← true ;
2 S ← true ;
3 while true do

// conjunction of assumptions
// synthesis formula

4

5

6

7

8

9

10

11

12

13

14

15

16

(cid:126)f ∗ ←Synthesize( ∃ (cid:126)f .S) ;
if (cid:126)f ∗ = ∅ then

return no solution;

else

V ← A ∧ ¬φ ;
(r, α, M ) ← SMTO((cid:126)x, (cid:126)θ, V ·{ (cid:126)f → (cid:126)f ∗}, (cid:126)J ) ;
if r=UNSAT then
return (cid:126)f ∗

// veriﬁcation formula

else

β ← call additional oracles((cid:126)I, φ, M ) ;
A ← A ∪ α ;
S ← S ∪ φ·{(cid:126)x → (cid:126)xM } ∪ β;

end

end

17
18 end

IV. SYNTHESIS MODULO ORACLES

A SyMO problem consists of: a tuple of functions to synthe-
size (cid:126)f ; a tuple of oracle function symbols (cid:126)θ; a speciﬁcation in
the form ∀(cid:126)x. φ, where φ is a quantiﬁer-free formula in some
background theory T , and a set of oracle interfaces (cid:126)I (cid:93) (cid:126)J .
We present an algorithm for a fragment of SyMO, where the
veriﬁcation condition reduces to a Deﬁnitional SMTO problem.
To that end, we require that (cid:126)J is a set of oracle interfaces
that deﬁne (cid:126)θ, and (cid:126)I is a set of oracle interfaces that only
generate constraints, i.e., αgen is empty. We will show that
these restrictions permit us to use the algorithm for Deﬁnitional
SMTO to check the correctness of a tuple of candidate functions
in Theorem IV.1.

A. Algorithm for Synthesis with Oracles

We now proceed to describe an algorithm for solving
synthesis problems using oracles, illustrated in Figure 5. Within
each iteration of the main loop, the algorithm is broken
down into two phases: a synthesis phase and an oracle phase.
The former takes as input a synthesis formula S which is
incrementally updated over the course of the algorithm and
returns a (tuple of) candidate solutions (cid:126)f ∗. The latter makes a
call to an underlying SMTO solver for the veriﬁcation formula
V , which is a conjunction of the current set of assumptions
A we have accumulated via calls to oracles, and the negated
conjecture ¬φ. In detail:

• Synthesis Phase: The algorithm ﬁrst determines if there
exists a set of candidate functions (cid:126)f ∗ that satisfy the
current synthesis formula S. If so, the candidate functions
are passed to the oracle phase.

6

Fig. 5: SyMO Algorithm Illustration

• Oracle Phase I: The oracle phase calls the SMTO solver
as described in section III on the following Deﬁnitional
SMTO problem: ((cid:126)x, (cid:126)θ, V ·{ (cid:126)f → (cid:126)f ∗}, (cid:126)J . If the SMTO
then (cid:126)f ∗ is a solution to the
solver returns UNSAT,
synthesis problem. Otherwise, the SMTO solver returns
SAT, along with a set of new assumptions α and a model
M . The assumptions α are appended to the set of overall
assumptions A. Furthermore, an additional the constraint
φ·{(cid:126)x → (cid:126)xM } is added to the current synthesis formula
S. This formula can be seen as a counterexample-guided
reﬁnement, i.e. future candidate solutions must satisfy the
overall speciﬁcation for the values of x in the model M
returned by the SMTO solver.

• Oracle Phase II: As an additional step in the oracle
phase, the solver may call any further oracles (cid:126)I and the
constraints β are passed to the synthesis formula. Note
that the oracles in (cid:126)I generate constraints only and not
assumptions.

Theorem IV.1 (Soundness). If Algorithm 2 returns (cid:126)f ∗, then (cid:126)f ∗
is a valid solution for the SyMO problem ( (cid:126)f , (cid:126)θ, ∀(cid:126)xφ, (cid:126)J (cid:93) (cid:126)I).
Proof. According to Deﬁnition II.6, a solution (cid:126)f ∗ is valid
for our synthesis problem iff ((cid:126)x, (cid:126)θ, ¬φ·{ (cid:126)f → (cid:126)f ∗}, (cid:126)J (cid:93) (cid:126)I) is
unsatisﬁable modulo theories and oracles, i.e. when ∃(cid:126)θA ∧
(¬φ·{ (cid:126)f → (cid:126)f ∗} ∧ B) is T -unsatisﬁable for assumptions A
and constraints B generated by oracle interfaces (cid:126)J (cid:93) (cid:126)I. By
deﬁnition, Algorithm 2 returns a solution if the underlying
SMTO solver ﬁnds that ((cid:126)x, (cid:126)θ, ¬φ·{ (cid:126)f → (cid:126)f ∗}, (cid:126)J ) is unsatisﬁable
modulo theories and oracles, i.e. ∃(cid:126)θA ∧ (¬φ·{ (cid:126)f → (cid:126)f ∗}) is
T -unsatisﬁable, which trivially implies that the above statement
holds. Thus, and since the SMTO solver is correct for UNSAT
responses due to Theorem III.1, any solution returned by Alg. 2
is a valid solution.

Inferring inputs for additional oracles: Although not described
in detail in Algorithm 2, we remark that an implementation
may infer additional calls to oracles based on occurrences of
terms in constraints from (cid:126)I and ground terms in φ under the
current counterexample from M . For example, if f (7) appears
in φ·{(cid:126)x → (cid:126)xM }, and there exists an oracle interface with a
single input z and the generator βgen : f (z) ≈ y, we will
call that oracle with the value 7. In general, inferring such
inputs amounts to matching terms from constraint generators

Query Type

Membership
Input-Output
Negative witness
Positive witness
Implication
Counterexample
Distinguishing-input

Oracle Interface

Constraint generating oracles

Example synthesis algorithms

Imem(y1, y2, y, zb, ∅, zb ⇔ f (y1, y2) = y)
Iio(y1, y2, y, zb, ∅, zb ⇔ f (y1, y2) (cid:54)= y)
Ineg(∅, z1, z2, z, ∅, f (z1, z2) (cid:54)= z)
Ipos(∅, z1, z2, , z, ∅, f (z1, z2) = z)
2, ∅, f (z1, z2) ⇒ f (z(cid:48)

Iimp(f ∗, z1, z2, z(cid:48)

1, z(cid:48)

1, z(cid:48)
2)

Icex(f ∗, (cid:126)z, ∅, φ{(cid:126)x→ (cid:126)z})
Idi(f ∗, z1, z2, z, ∅, f (z1, z2) = z)

Angluin’s L∗ [8]
Classic PBE
ICE-learning [19]
ICE-learning [19]
ICE-learning [19]
Synthesis with validators [23]
Synthesis with distinguishing inputs [20]

Correctness
Correctness with cex

Jcorr(f ∗, zb, θ(f ∗) = zb, ∅)
Jccex(f ∗, zb, (cid:126)z, θ(f ∗) = zb, φ{(cid:126)x→ (cid:126)z})

ICE-learning [19]
classic CEGIS [29]

Constraint and assumption generating oracles

TABLE I: Common oracle interfaces, illustrated for synthesizing a single function which takes a two inputs f (x1, x2). y
indicates query variables, except where they are the candidate function, in which case we use f ∗, and z indicates response
variables, where zb is a Boolean.

to concrete terms from φ·{(cid:126)x → (cid:126)xM }. Our implementation in
Section VI follows this principle.

V. INSTANCES OF SYNTHESIS MODULO ORACLES

A number of different queries are categorized in work by

Jha and Seshia [21]. Brieﬂy, these query types are

• membership queries: the oracle returns true iff a given

input-output pair is permitted by the speciﬁcation

• input-output queries: the oracle returns the correct output

for a given input

• positive/negative witness queries: the oracle returns a

correct/incorrect input-output pair

• implication queries: given a candidate function which the
speciﬁcation demands is inductive, the oracle returns a
counterexample-to-induction [12], [19].

• Counterexample queries: given a candidate function, the
oracle returns an input on which the function behaves
incorrectly if it is able to ﬁnd one

• Correctness queries: the oracle returns true iff the candi-

date is correct

• Correctness with counterexample: the oracle returns true
iff the candidate is correct and a counterexample otherwise
• Distinguishing inputs: given a candidate function, the
oracle checks if there exists another function that behaves
the same on the set of inputs seen so far, but differently
on a new input. If one exists, it returns the new input and
its correct output.

We show the oracle interfaces for each of the classic query
types in Table I. Full details are given in Appendix A. To
give an intuition for how these interfaces are used in a
synthesizer: oracle function symbols, (cid:126)θ are used to encapsulate
correctness criteria (in full or in part) of (cid:126)f , when correctness
depends on external oracles. For instance, we could write
a speciﬁcation that states that θ( (cid:126)f ) should return true, and
assumptions generated by the oracle are used to determine when
that speciﬁcation is satisﬁed. Constraints generated by oracles
associated with (cid:126)I are used to guide the synthesizer. Synthesis
algorithms typically alternate between a synthesis phase, which
solves an approximation of the speciﬁcation, and a veriﬁcation
phase which veriﬁes the solution to the approximation against
the full speciﬁcation. For example, CEGIS [29] uses the

counterexamples to construct this approximation in the form
of constraints specifying the behavior of the function must be
correct on the counterexamples obtained so far.

Thus the synthesis modulo oracles framework we present is
a ﬂexible and general framework for program synthesis. SyMO
can implement any inductive synthesis algorithm, i.e., any
synthesis algorithm where the synthesis phase of the algorithm
iteratively increases the constraints over the synthesis function.
Common synthesis algorithms are composed of combinations
of the queries described in Table I. For instance, CEGIS [29] is
SyMO with a single counterexample-with-correctness interface
Jccex; ICE-learning [19] uses Jcorr, Iimp, Ipos, Ineg. For full
details on these equivalences, see Appendix A.

VI. DELPHI: A SATISFIABILITY AND SYNTHESIS MODULO
ORACLES SOLVER
We implement the algorithms described above in a prototype
solver Delphi1. The solver can use any SMT-lib compliant
SMT solver as the sub-solver in the SMTO algorithm, or
bitblast to MiniSAT version 2.2 [17], and it can use any
SyGuS-IF compliant synthesis solver in the synthesis phase
of the SyMO algorithm, or a symbolic synthesis encoding
based on bitblasting. In the evaluation we report results using
CVC4 [11] v1.9 in the synthesis phase and as the sub-solver
for the SMTO algorithm. The input format accepted by the
solver is an extension of SMT-lib [10] and SyGuS-IF [24].

A. Case Studies

We aim to answer the following research questions: RQ1
– when implementing a logical speciﬁcation as an oracle
executable, what is the overhead added compared to the oracle-
free encoding? RQ2 – can SMTO solve satisﬁability problems
beyond state-of-the-art SMT solvers? RQ3 – can SyMO solve
synthesis problems beyond state-of-the-art SyGuS solvers? To
that end, we evaluate Delphi on the following case studies.

a) Reasoning about primes: We convert a set of 12
educational mathematics problems [22] (Math) that reason
about prime numbers, square numbers, and triangle numbers
into SMT and SMTO problems. We demonstrate that using an
oracle to determine whether a number is a prime, a square or a
triangle number is more efﬁcient than the pure SMT encoding.

1link: https:://github.com/polgreen/delphi

7

(encoding)
Benchmarks (#)
Images(10)
Math(12)
Control-stability(112)
Control-safety(112)
PBE(150)

Delphi
(oracles)
t
#
21.6s
9
<0.5s
9
29.3s
104
59.9s
31
0.5s
148

Delphi
(no oracles)
#
0
1
–
0
150

t
–
<0.2s
–
–
1.6s

CVC4
(no oracles)
#
0
5
16
0
150 <0.2s

t
–
2.2s
19.4s
–

TABLE II: Comparison of Delphi and CVC4. # is the number
of benchmarks solved within the 600s timeout, and t is the
average run-time for solved benchmarks. The ﬁrst column
shows results on SyMO and SMTO problems, the second two
columns show results on the equivalent oracle-free encodings.

SMT solvers to solve problems beyond the state-of-the-art by
delegating challenging reasoning to an external oracle.

c) RQ3: Delphi solves control synthesis problems and
image transformation problems that cannot be easily expressed
as SyGuS and elude CVC4, demonstrating that SyMO can
solve synthesis problems beyond state-of-the-art solvers. When
tackling the image transformation problems, SyMO dynami-
cally generates small numbers of informative constraints, rather
than handling the full image at once.

We also note that in many cases the encodings for SyMO
and SMTO problems are more compact and (we believe) easier
to write in comparison to pure SMT/SyGuS encodings. For
instance, Figure 1 reduces to two assertions and a declaration
of a single oracle function symbol.

Future work: We see a lot of scope for future work
on SyMO. In particular, we plan to embed SMTO solving
into software veriﬁcation tools; allowing the user to replace
functions that are tricky to model with oracle function symbols.
The key algorithmic developments we plan to explore in future
work include developing more sophisticated synthesis strategies
that decide when to call oracles based on the learned utility
and cost of the oracles. An interesting part of future work
will be to explore interfaces to oracles that provide syntactic
constraints, such as those used in [4], [18], which will require
the use of context-sensitive grammars in the synthesis phase.

VII. CONCLUSION

We have presented a unifying framework for synthesis
modulo oracles, identifying two key types of oracle query-
response patterns: those that return constraints that can guide
the synthesis phase and those that assert correctness. We
proposed an algorithm for a meta-solver for solving synthesis
modulo oracles, and, as a necessary part of this framework, we
have formalized the problem of satisﬁability modulo oracles.
Our case studies demonstrate the ﬂexibility of a reasoning
engine that can incorporate oracles based on complex systems,
which enables SMTO and SyMO to tackle problems beyond
the abilities of state-of-the-art SMT and Synthesis solvers, and
allows users to specify complex problems without building
custom reasoning engines.

Fig. 6: Oracle for image transformations

b) Image Processing: Given two images, we encode a
synthesis problem to synthesize a pixel-by-pixel transformation
between the two. Figure 2 shows an example transformation.
The SyMO problem uses an oracle, shown in Figure 6, which
loads two JPEG images of up to 256 × 256 pixels: the original
image, and the target image. Given a candidate transformation
function, it translates the function into C code, executes the
compiled code on the original image and compares the result
with the target image, and returns “true” if the two are identical.
If the transformation is not correct, it selects a range of the
incorrect pixels and returns constraints to the synthesizer that
give the correct input-output behavior on those pixels. The goal
of the synthesis engine is to generalize from few examples to
the full image. The oracle-free encoding consists of an equality
constraint per pixel. This is a simpliﬁcation of the problem
which assumes the image is given as a raw matrix and omits
the JPEG ﬁle format decoder.

c) Digital Controller Synthesis: We encode the task of
synthesizing ﬂoating-point controllers which guarantee bounded
safety and stability of Linear Time Invariant systems [3], using
a range of time discretizations as both a SyMO and an oracle-
free synthesis problem. We use two oracles in the SyMO
problem: a correctness oracle to check the stability of the
system using Eigen [1] (which avoids the need for the solver
to reason about complex non-linear arithmetic). We note that
these benchmarks do not necessarily have solutions for all time
discretizations.

d) Programming by example: We encode PBE [2] bench-
marks as SyMO problems using oracles that demonstrate the
desired behavior of the function to be synthesized. These
examples show that PBE benchmarks have a simple encoding
in our framework.

B. Observations

We report a summary of the results for these case-studies

in Table II and make the following observations:

a) RQ1: The overhead incurred by using oracles is
small: performance on PBE problems encoded with oracles is
similar to PBE problems encoded without oracles, with a small
overhead incurred by calling external binaries. Given this low
overhead, SyMO would be amenable to integration with many
more sophisticated synthesis search approaches [18], [25], [6].
b) RQ2: Delphi solves more educational mathematics
questions than CVC4, demonstrating that SMTO does enable

8

REFERENCES

[1] Eigen, C++ template library for linear algebra: matrices, vectors,
numerical solvers, and related algorithms. https://eigen.tuxfamily.org.
Accessed: 2021-05-19.

[2] Sygus competition. https://sygus.org/. Accessed: 2021-05-19.
[3] Alessandro Abate, Iury Bessa, Lucas C. Cordeiro, Cristina David, Pascal
Kesseli, Daniel Kroening, and Elizabeth Polgreen. Automated formal
synthesis of provably safe digital controllers for continuous plants. Acta
Informatica, 57(1-2):223–244, 2020.

[4] Alessandro Abate, Cristina David, Pascal Kesseli, Daniel Kroening, and
Elizabeth Polgreen. Counterexample guided inductive synthesis modulo
theories. In International Conference on Computer Aided Veriﬁcation,
pages 270–288. Springer, 2018.

[5] Rajeev Alur, Rastislav Bod´ık, Eric Dallal, Dana Fisman, Pranav Garg,
Garvit Juniwal, Hadas Kress-Gazit, P. Madhusudan, Milo M. K. Martin,
Mukund Raghothaman, Shambwaditya Saha, Sanjit A. Seshia, Rishabh
Singh, Armando Solar-Lezama, Emina Torlak, and Abhishek Udupa.
Syntax-guided synthesis. In Dependable Software Systems Engineering,
volume 40 of NATO Science for Peace and Security Series, D: Information
and Communication Security, pages 1–25. IOS Press, 2015.
[6] Rajeev Alur, Arjun Radhakrishna, and Abhishek Udupa.

Scaling
enumerative program synthesis via divide and conquer. In TACAS (1),
volume 10205 of Lecture Notes in Computer Science, pages 319–336,
2017.

[7] Zaher S. Andraus and Karem A. Sakallah. Automatic abstraction and
In Proceedings of the 41th Design
veriﬁcation of Verilog models.
Automation Conference, DAC 2004, San Diego, CA, USA, June 7-11,
2004, pages 218–223. ACM, 2004.

[8] Dana Angluin. Learning regular sets from queries and counterexamples.

Inf. Comput., 75(2):87–106, 1987.

[9] Clark Barrett, Roberto Sebastiani, Sanjit A. Seshia, and Cesare Tinelli.
Satisﬁability modulo theories. In Armin Biere, Hans van Maaren, and
Toby Walsh, editors, Handbook of Satisﬁability, chapter 26, pages 825–
885. IOS Press, 2009.

[10] Clark Barrett, Cesare Tinelli, et al. The SMT-LIB standard: Version 2.0.
[11] Clark W. Barrett, Haniel Barbosa, Martin Brain, Duligur Ibeling, Tim
King, Paul Meng, Aina Niemetz, Andres N¨otzli, Mathias Preiner, Andrew
Reynolds, and Cesare Tinelli. CVC4 at the SMT competition 2018. CoRR,
abs/1806.08775, 2018.

[12] Aaron R. Bradley. SAT-based model checking without unrolling. In
VMCAI, volume 6538 of Lecture Notes in Computer Science, pages
70–87. Springer, 2011.

[13] Bryan A. Brady, Randal E. Bryant, and Sanjit A. Seshia. Learning
In FMCAD, pages 116–124. FMCAD Inc.,

conditional abstractions.
2011.

[14] Bryan A. Brady, Randal E. Bryant, Sanjit A. Seshia, and John W. O’Leary.
ATLAS: automatic term-level abstraction of RTL designs. In Proceedings
of the Eighth ACM/IEEE International Conference on Formal Methods
and Models for Codesign (MEMOCODE), pages 31–40, July 2010.

[15] Edmund M. Clarke, Orna Grumberg, Somesh Jha, Yuan Lu, and Helmut
Veith. Counterexample-guided abstraction reﬁnement. In CAV, volume
1855 of Lecture Notes in Computer Science, pages 154–169. Springer,
2000.

[16] Cristina David, Pascal Kesseli, Daniel Kroening, and Matt Lewis.
Program synthesis for program analysis. ACM Trans. Program. Lang.
Syst., 40(2):5:1–5:45, 2018.

[17] Niklas E´en and Niklas S¨orensson. An extensible SAT-solver. In SAT,
volume 2919 of Lecture Notes in Computer Science, pages 502–518.
Springer, 2003.

[18] Yu Feng, Ruben Martins, Osbert Bastani, and Isil Dillig. Program
synthesis using conﬂict-driven learning. In PLDI, pages 420–435. ACM,
2018.

[19] Pranav Garg, Christof L¨oding, P. Madhusudan, and Daniel Neider. ICE:
A robust framework for learning invariants. In CAV, volume 8559 of
Lecture Notes in Computer Science, pages 69–87. Springer, 2014.
[20] Susmit Jha, Sumit Gulwani, Sanjit A. Seshia, and Ashish Tiwari. Oracle-
guided component-based program synthesis. In International Conference
on Software Engineering (ICSE), pages 215–224. ACM, 2010.

[21] Susmit Jha and Sanjit A. Seshia. A theory of formal synthesis via

inductive learning. Acta Informatica, 54(7):693–726, 2017.

[22] Michael Kent. Gcse maths edexcel higher student book. Harpercollins

Publishers, 2015.

[23] Anders Miltner, Saswat Padhi, Todd D. Millstein, and David Walker.
Data-driven inference of representation invariants. In PLDI, pages 1–15.
ACM, 2020.

[24] Abhishek Udupa Mukund Raghothaman, Andrew Reynolds. The SyGuS
language standard version 2.0. https://sygus.org/language/, 2019.
[25] Andrew Reynolds, Haniel Barbosa, Andres N¨otzli, Clark W. Barrett, and
Cesare Tinelli. cvc4sy: Smart and fast term enumeration for syntax-guided
synthesis. In CAV (2), volume 11562 of Lecture Notes in Computer
Science, pages 74–83. Springer, 2019.

[26] Andrew Reynolds, Jasmin Christian Blanchette, Simon Cruanes, and
Cesare Tinelli. Model ﬁnding for recursive functions in SMT. In IJCAR,
volume 9706 of Lecture Notes in Computer Science, pages 133–151.
Springer, 2016.

[27] Andrew Reynolds, Morgan Deters, Viktor Kuncak, Clark W. Barrett, and
Cesare Tinelli. On counterexample guided quantiﬁer instantiation for
synthesis in CVC4. CoRR, abs/1502.04464, 2015.

[28] Xujie Si, Yuan Yang, Hanjun Dai, Mayur Naik, and Le Song. Learning
a meta-solver for syntax-guided program synthesis. In 7th International
Conference on Learning Representations, ICLR 2019, New Orleans, LA,
USA, May 6-9, 2019. OpenReview.net, 2019.

[29] Armando Solar-Lezama, Liviu Tancau, Rastislav Bod´ık, Sanjit A. Seshia,
and Vijay A. Saraswat. Combinatorial sketching for ﬁnite programs. In
ASPLOS, pages 404–415. ACM, 2006.

[30] Abhishek Udupa, Arun Raghavan, Jyotirmoy V. Deshmukh, Sela Mador-
Haim, Milo M. K. Martin, and Rajeev Alur. TRANSIT: specifying
protocols with concolic snippets. In Hans-Juergen Boehm and Cormac
Flanagan, editors, ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI), pages 287–296. ACM, 2013.

9

iter.
1

2

3

. . .

CEGIS
Xcex = ∅
∃f.∃x.φ
Xcex = c1
. ∃f.∀x ∈ Xcex .φ(x)
Xcex = c1, c2
. ∃f.∀x ∈ Xcex .φ(x)
. . .

SyMO with correctness oracle

∃f.true
β1 = φ(k1/x)
∃f.β1
β2 = φ(k2/x)
∃f.β1 ∧ β2
. . .

TABLE III: Comparison of the synthesis formula at each itera-
tion, showing that, if the same sequence of counterexamples
is obtained, the synthesis formula are equisatisﬁable at each
step, i.e., SyMO reduces to CEGIS.

2) ICE learning: ICE learning [19] is an algorithm for
learning invariants based on using examples, counterexamples
and implications. Recall the classic invariant synthesis problem
is to ﬁnd an invariant inv such that:

∀x, x(cid:48) ∈ X.init(x) =⇒ inv(x)∧
inv(x) ∧ trans(x, x(cid:48)) =⇒ inv(x(cid:48))∧

inv(x(cid:48)) =⇒ φ

where init deﬁnes some initial conditions, trans deﬁnes a
transition relation and φ is some property that should hold.
ICE is an oracle guided synthesis algorithm, where, given
a candidate inv∗, if the candidate is incorrect (i.e., violates
the constraints listed above) the oracle can provide: positive
examples E ⊆ X, which are values for x where inv(x) should
be true; negative examples C ⊆ X, which are values for x
where inv(x) should be false; and implications I ⊆ X × X,
which are values for x and x(cid:48) such that inv(x) ⇒ inv(x(cid:48)). The
learner then ﬁnds a candidate inv, using a symbolic encoding,
such that

(∀x ∈ E.inv(x)) ∧

(∀x ∈ C.¬inv(x)) ∧
(∀(x, x(cid:48)) ∈ I.inv(x) ⇒ inv(x(cid:48))).

The SyMO algorithm described in this work will implement
ICE learning when given a correctly deﬁned set of oracles and
oracle interface and a constraint θcorr(inv) = true. Interfaces
for these oracles, in a system with variables x1 . . . xn, are
shown in Figure 8. Note that implication queries generate
constraints enforcing that if the pre-state of the implication
pair lies in the invariant, so must the post-state, which also
allows the learner to exclude the pre-state in its next round of
synthesis.

3) Synthesis with distinguishing inputs: This algorithm [20],
illustrated in Figure 7, uses several oracles which interact with
each other. The synthesis phase searches for a function that
satisﬁes a list of input-output examples. If one is found, it is
passed to a distinguishing-input oracle, which looks for another,
different, function that behaves the same as the existing function
on the list of input-output examples, but behaves differently
on another distinguishing input.

Fig. 7: Synthesis with distinguishing inputs

A. Instances of Synthesis Modulo Oracles

APPENDIX

The SyMO framework we present is a ﬂexible and general
framework for program synthesis. SyMO can implement any
inductive synthesis algorithm, i.e., any synthesis algorithm
where the synthesis phase of the algorithm iteratively increases
the constraints over the synthesis function. Here we describe
how, by providing speciﬁc oracles the algorithm describes will
implement standard synthesis algorithms such as CEGIS [29],
ICE-learning [19], Synthesis with distinguishing inputs [20]
and CEGIS(T) [4].

1) CounterExample Guided Inductive Synthesis: : Suppose
we are solving a synthesis formula with a single variable x
and a single synthesis function f , where f : σ → σ(cid:48). CEGIS
consists of two phases, a synthesis phase that solves the formula
S = ∃f ∀x ∈ Xcex, φ, where Xcex is a subset of all possible
values of x, and a veriﬁcation phase which solves the formula
V = ∃x¬φ. There are two ways of implementing CEGIS in
our framework. The ﬁrst is simply to pass the full SMT-formula
φ to the algorithm as is, without providing external oracles.
The second method is to replace the speciﬁcation given to the
oracle guided synthesis algorithm with ∃f ∀θ .θ(f ) and use an
external correctness oracle with counterexamples, illustrated
here for a task of synthesizing a function f , and receiving a
candidate synthesis function y : σ → σ(cid:48):

Icorr =


Q

R
αgen

βgen

: (y (σ → σ(cid:48)))
: (z1 σ), (z2 bool)
: θ(y) = z2
: φ(z1/x)

By inspecting the formula solved by the synthesis phase at each
iteration, we can see that, after the ﬁrst iteration, the synthesis
formula are equisatisﬁable if the sequence of counterexamples
obtained is the same for both algorithms.

10

Icorr =

Iimpl =






Q
R
αgen

Q
R

βgen






: (f ∗ (σ1 × . . . × σn → bool))
: (zb bool)
: θcorr(f ∗) = zb

Ineg

=






Q
R
βgen

: (f ∗ (σ1 × . . . × σn → bool))
: (z1 σ1), . . . , (zn σn)
: ¬f (z1, . . . zn)

: (f ∗ (σ1 × . . . × σn → bool))
: (z1 σ1), . . . , (zn σn),
1 σ1), . . . , (z(cid:48)
n σn)
: f (z1, . . . zn) =⇒
1, . . . z(cid:48)

f (z(cid:48)

(z(cid:48)

n)

Ipos =






Q
R
βgen

: (f ∗ (σ1 × . . . × σn → bool))
: (z1 σ1), . . . , (zn σn)
: f (z1, . . . zn)

Fig. 8: Oracle interfaces for ICE learning, synthesizing an invariant f , and receiving a candidate invariant f ∗.

If such a function exists, the distinguishing input is passed
to an input/output oracle, and the input/output pair is passed
to the synthesizer. If a distinguishing input does not exist,
the correctness of the function is checked and the algorithm
terminates (if this function is not correct, then there is no
solution to the synthesis problem).

We can implement this algorithm in SyMO by observing
that the synthesizer needs only to query the correctness oracle
and the distinguishing input oracle, which maintains a list of
inputs it has returned so far and receives a response from
only one oracle, the input/output oracle. The interface for the
distinguishing input-oracle is as follows for a speciﬁcation
synthesizing f , and a candidate synthesis function y : σ1 ×
. . . × σn → σ(cid:48):

IsynthDI =






Q
R
βgen

: (y (σ1 × . . . × σn → σ(cid:48)))
: (z1 σ1), . . . , (zn σn), (zn+1 σ(cid:48))
: f (z1, . . . zn) = zn+1

4) CEGIS(T): This algorithm [4] extends a CEGIS loop to
incorporate a theory solver that, given a candidate solution,
generalizes the candidate to a template solution (removing
any constant
literals in the solution and replacing them
with symbolic values), and searches for solutions within that
template. If a solution is found, the oracle returns that valid
solution. If no such solution exists, a constraint is passed back
that blocks the candidate solution. Our framework can be used
to implement an approximation of CEGIS(T): one in which
the oracle generalizes the candidate and searches for a solution
within that template, but if no solution is found, a single point
counterexample is returned instead of the constraint over the
syntactic space. This highlights a limitation of the framework
we propose: the oracles may only place semantic constraints
over the search space. That is, it may place constraints that
reason about the behavior of the synthesis functions, and not
the syntactic space from which the synthesis functions are to
be constructed. The oracle interface for our modiﬁed CEGIS(T)
is as follows:




: (y (σ1 × . . . × σn → σ(cid:48)))
: (z1 σ1), . . . , (zn σn), (zn+1 b),
(zn+2 (σ1 × . . . × σn → σ(cid:48)))
: zn+1 ? (f = z2) : φ(z1/x1, . . . zn/xn)

Icegist =

βgen

Q
R

11

B. Evaluation Details

In this section, we give more details on the control, mathe-
matics, and image processing case studies. We also provide a
brief practical comparison of invariant synthesis with CEGIS
and with ICE learning.

1) Further details on case studies :

a) Control benchmarks: The control benchmarks [3]
synthesize single- and double-point precision ﬂoating-point
controllers that guarantee stability and bounded safety for Lin-
ear Time Invariant systems. We use a state-space representation,
which is discretized in time with 6 different constant sampling
intervals Ts, generating 6 benchmarks per system:

˙xt+1 = A(cid:126)xt + B(cid:126)ut,
where (cid:126)x ∈ Rn, (cid:126)u ∈ Rp is the input to the system, calculated as
K(cid:126)x where K is the controller to be synthesized, A ∈ Rn×n is
the system matrix, B ∈ Rn×p is the input matrix, and subscript
t indicates the discrete time step.

For stability benchmarks, we aim to ﬁnd a stabilizing
controller, such that absolute values of the (potentially complex)
eigenvalues of the closed-loop matrix A−BK are less than one.
For bounded safety benchmarks, we aim to ﬁnd a controller
that is both stable as before and guarantees the states remain
within a safe region of the state space up to a given number
of time steps.

The SyMO encoding uses an oracle to determine the stability
of the closed-loop matrix. The encoding without oracles
requires the SMT solver to ﬁnd roots of the characteristic
polynomial.

b) Educational mathematics bencharks: These bench-
marks are taken from Edexcel mathematics questions [22].
The questions require the SMT solver to ﬁnd numbers that
are (some combination of) factors, prime-factors, square and
triangle numbers. The encodings without oracles used recursive
functions to determine whether a number is a prime or a triangle
number. We note the oracle used alongside the benchmark
number in Table IV. We enable the techniques described by
Reynolds et. al. [26] when running CVC4 on problems using
recursive functions.

Benchmarks
Inv-det(5)
Inv-det(5)
Inv-all(127)
Inv-all(127)

conﬁg.
CEGIS
ICE
CEGIS
ICE

# solved
5
5
102
86

t
163s
121s
0.8s
2.1s

TABLE VI: Comparison of ICE learning with CEGIS in Delphi.
Inv-det have deterministic transition relations and ICE learning
uses a positive witness oracle that can unroll the transition
relation. In the Inv-all category, all transition relations are
treated as non-deterministic and the positive witness oracle is
SMT-based only. t is the average solving time per benchmark
(excluding timeouts, where the timeout is 600s).

benchmark
1b-square
1d-prime
1f-prime
1h-triangle
1j-square,prime
1l-triangle
1m-triangle
ex7-prime
ex8-prime
ex9-prime
ex10-prime
ex11-prime

Delphi
(oracles)
<0.2s
<0.2s
3.1s
<0.2s
<0.2s
<0.2s
<0.2s
2.3s
–
3.2s
–
<0.2s

Delphi
(no oracles)
<0.2
–
–
–
–
–
–
–
–
–
–
–

CVC4
(no oracles)
–
<0.2s
<0.2s
<0.2s
–
<0.2s
<0.2s
–
–
–
–
–

TABLE IV: Solving times for Delphi and CVC4 on math
examples using oracle and recursive function encodings. “ – ”
indicates the timeout of 600s was exceeded.

c) Image transformations: We run 9 image transfor-
mations on images up to 256x256 pixels. The oracle-free
encodings consist of an equality constraint for each pixel,
and so are more than 50, 000 constraints long. For the oracle-
free encoding we simplify the problem by assuming that the
images are given as a raw matrix, and this encoding, unlike the
oracle-based encoding, does not include the JPEG ﬁle format
decoder. The results are shown in Table V.

Benchmarks
Image invert
Image zombie
Image attenuate
Image crop1
Image crop2
Image crop3
Image brighter
Image darker
Image round
Image blur

Delphi
(oracles)
0.4s
0.4s
0.9s
14s
11.8s
12.0s
35.0s
120.0s
0.2s
–

Delphi
(no oracles)
–
–
–
–
–
–
–
–
–
–

CVC4
(no oracles)
–
–
–
–
–
–
–
–
–
–

TABLE V: Solving time for image transformation examples,
comparing the oracle vs oracle-free encoding. “ – ” indicates
the timeout of 600s was exceeded. The oracle-free encodings
are >50,000 lines long.

2) A practical comparison of CEGIS vs ICE: As an
illustration of SyMO performing ICE-learning, we implement
positive, negative, and implication oracles for a small set of
invariant benchmarks taken from the SyGuS competition [2].
We note that, for positive witness oracles to be notably
informative beyond a pure speciﬁcation, the positive witness
oracle should unroll the transition relation. This is easier with
deterministic transition relations. Table VI shows a comparison
of CEGIS against ICE-learning with positive witness oracles
that unroll the transition relation (in Inv-det). We observe that
using such oracles, ICE-learning can solve these examples
faster and using fewer generated synthesis constraints. Note
that we disable all heuristics for solving invariants for these
examples. We also note that the failure mode of the respective
algorithms differs: CEGIS typically generates increasingly
many constraints, enumerating through constant values; whilst
ICE generates sets of constraints that become tricky to solve and
the synthesis phase absorbs all the solving time. Unsurprisingly,
in the case where invariant heuristics are enabled and the
positive witness oracles are not able to unroll the transition
relation (Inv-all), the speciﬁcally tailored oracles do not provide
a performance gain as they aren’t able to provide information
that isn’t already contained within the speciﬁcation used by
CEGIS.

12

