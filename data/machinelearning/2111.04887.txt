1
2
0
2
c
e
D
4

]

Y
C
.
s
c
[

2
v
7
8
8
4
0
.
1
1
1
2
:
v
i
X
r
a

Programming for All:
Understanding the Nature of Programs

Andrej Brodnik1,2[0000−0001−9773−0664], Andrew
Csizmadia3[0000−0002−9779−055X], Gerald Futschek4[0000−0001−7255−2531], Lidija
Kralj5[0000−0001−5750−6123], Violetta Lonati6[0000−0002−4722−244X], Peter
Micheuz7[0000−0002−4722−244X], and Mattia Monga7[0000−0003−4852−0067]

1 University of Primorska, Koper, Slovenia
2 University of Ljubljana, Slovenia
3 Newman University, Birmingham, United Kingdom
4 TU Wien, Institute of Information Systems Engineering Vienna, Austria
5 Udruga “Suradnici u uˇcenju”, Croatia
6 Universit`a degli Studi di Milano, Milan, Italy

Abstract. Computer programs are part of our daily life, we use them,
we provide them with data, they support our decisions, they help us
remember, they control machines, etc. Programs are made by people,
but in most cases we are not their authors, so we have to decide if we
can trust them. Programs enable computers and computer-controlled
machines to behave in a large variety of ways. They bring the intrinsic
power of computers to life. Programs have a variety of properties that all
citizens must be aware of. Due to the intangible nature of programs, most
of these properties are very unusual, but important to understand the
digital world. In this position paper, we describe the Nature of Programs
in the form of knowledge statements, accompanied by examples from
everyday life to clarify their meaning. Everything is formulated in an
easily understandable manner and avoids obscure technical language.
We suggest that these knowledge statements must be imparted to all
teachers and school students. A great way to learn and experience the
nature of programs is to develop programs yourself.

Keywords: nature of programs · nature of computer science · comput-
ing education

1

Introduction

The expression “Nature of Programs” (NoP) in the title draws inspiration from
“Nature of Science” (NoS) [10], a similar expression born in the ’70s that refers
to the fundamental characteristics of science knowledge and scientiﬁc inquiry, as
derived from how it is produced: a necessary knowledge to make informed deci-
sions with respect to the ever-increasing scientiﬁcally-based personal and societal
issues. NoS is a signiﬁcant component of scientiﬁc literacy and it is argued that
NoS cannot be learned simply by studying science concepts or attending science

 
 
 
 
 
 
labs, but it must be addressed explicitly with active reﬂective practice and dis-
cussions among students in their learning contexts. [7]. This also implies that
teachers should have a “shared accurate view of NoS” and agree that NoS needs
to be taught and assessed explicitly. [10]

Informatics7 diﬀers from the natural science in many aspects (at least because
its objects are artiﬁcial and not natural) and has indeed many peculiarities
that ask for a speciﬁc approach in education. However, despite the numerous
initiatives aiming at popularizing informatics and introducing it in educational
systems, there is no clear agreement of what the “Nature of Computer Science”
is, and the debate on this topic doesn’t seem to attract nowadays much interest
in our community. Some very signiﬁcant contributions on this topic appeared in
the ’80–90s [12,4,15] but they need an actualization, if nothing else because they
refer to a time where digital devices had a much less relevant role in society than
today. A recent review of the positions on this issue can be found in [11].

The centrality of programming in informatics can be found also in most
computing education initiatives, which indeed often include some type of pro-
gramming activity, mainly under the term coding. One can even argue that, for
many teachers, computer science is a just a synonym for coding [14]. Another
fundamental component of computing education revolves around the computa-
tional thinking idea [17]. Even if there is no clear deﬁnition for this expression
either, this idea concerns the ability to address “problems in a way that enables
us to use a computer and other tools to help solve them” [6]. This includes also
the ability to represent, organize, and logically analyze data and to automatize
solutions through algorithmic thinking, all skills that have a fundamental role
also in the process of designing programs.

However, the full understanding of what the NoP is might not be a natural
learning outcome of informatics activities, similarly as it was shown for the
NoS [7]. For instance, practicing coding in a visual programming environment
does not imply that students are able to recognize that the programs they write
have the same nature as the apps they use on their mobile phones. Similarly,
unplugged activities aimed at developing computational thinking skills might be
perceived as disconnected from the use of digital devices in everyday life [13,9].
On the contrary, we claim that understanding the NoP is a critical component
of the computing literacy/culture, and should be one of the main outcome of
computing education, alongside with the development of problem solving and
computational thinking skills. Moreover we think it should be a core part of any
eﬀort to bring digital competences to the masses, like [16,1], and, even more so,
of the initiatives aimed at the inclusion of informatics as a foundational discipline
in schools [2,5].

In Section 2 we discuss the NoP, then in Section A we present a series of
“knowledge statements” that aim at providing a summary about the nature of
programs, and are targeted to the general public, starting with teachers and

7 In this paper we use the terms ‘informatics’ (preferred) and ‘computer science’ as

synonyms.

2

students. Finally, Section 4 concludes the paper with a summary of our position
and hints for future work.

2 Programming, programs, and the Nature of Programs

In fact, the NoP makes them distinct from any other human artifacts. Indeed, one
can recognize three diﬀerent facets of programs. First, they are real entities, in
that they aﬀect our everyday lives in the same way as physical or political reality
does [8]; next, they are concrete artifacts, in that they are written, encoded,
stored on some digital device; ﬁnally, they are abstract entities that manipulate
abstract entities (data and data structures). Thus, understanding NoP includes
grasping the relation between a program and its interpretation by a computing
device, being aware of the the duality of instructions and data, accepting the need
for and the power of extreme precision and unambiguity, and the unavoidable
abstraction involved in computational problems.

Let’s precise better the three facets of programs and why it is important to

grasp them all.

Programs are real entities: this is probably the most obvious aspect that no
one can really ignore. As famously stated by Larry Lessig, nowadays “code is
law”[8], and it is one of the main forces that shapes are daily life. And yet,
programs are designed by some to be used by many. The goals, the values of
the designers are brought into the reality by their translation into algorithms,
programs, systems. Indeed, programs are usually created with the purpose of
helping in the execution of tasks or the solution of problems (more precisely, they
are designed to automatize the execution of tasks or the solution of problems).
This is the prevailing facet of programs from the point of view of their users;
when using an app on a mobile device or using a piece of software on a personal
computer, the users see the program as a useful tool, that has impact on the
reality of their job or personal life. This facet is central when talking about digital
competences[16,1], where the core is indeed in the ability to use programs for
one’s own goals.

Programs are also concrete artifacts, in that they are written, encoded, and
stored; to use them, one has to have access to them. Clearly, the concrete nature
of programs is diﬀerent from the nature of physical artifacts, in that programs
are intangible; for instance it’s in principle very easy to make copies of programs
and modiﬁcations can be also cheap or even unconscious (or malicious): we use
term software for a reason. Thus, programs take up space in the memory of
digital devices, they can be deleted, they can be corrupted, and checking their
integrity requires special cautions, very diﬀerent from those that are necessary
for checking physical integrity. Moreover a program, by its nature, needs an
interpreter to be enacted.

Finally, there is the facet of programs that programmers and computer sci-
entists typically deal with and know the most, but the general public often tend
to ignore: programs are abstract entities. It is indeed very diﬃcult to appreciate
the consequences of this without having any acquaintance with the activities

3

involved in programming. Indeed good programs are able to capture their users
in the abstract world they create, and the relationship with reality becomes hid-
den enough without an explicit eﬀort of trying to understand why something is
designed in a given way. Programs are descriptions that must be expressed using
the formal rigorous language (the programming languages) that the automatic
interpret is able to follow. Moreover they manipulate abstract entities, namely
data and data structures. Even though these abstract entities do model real
entities in general, when modeling them it is necessary to make key choices, sim-
plifying and distorting reality, to make the automatic processing of information
possible or feasible.

The process of creating programs is called programming. Unfortunately, for
many educators and the general public, programming boils down to coding, i.e.,
writing instructions in a programming language. However, programming is a
much more complex and rich process; it consists of designing and developing a
sequence of instructions that a computing device is able to execute, in order to
solve automatically a given problem, or perform a given task. Designing and de-
veloping involve ([3, p. 3]): ‘analysis and understanding of problems, identifying
and evaluating possible solutions, generating algorithms, implementing solutions
in the code of a particular programming language, testing and debugging’.

3 Knowledge statements

To describe NoP in more details, we identify several phases or steps in program
development and its use. Reﬂecting on the development phases of programs and
their use, we created and curated a list of knowledge sentences, which we grouped
into ﬁve knowledge areas:

1. The area Algorithms covers the modeling of real problems as computational
problems, the design and evaluation of their computational solutions, and
related complexity and computability issues.

2. The area Programs are made of instructions concerns the fact that an al-
gorithm needs to be translated into a programming language. The artifact
resulting from this translation is the actual program, which is understood
and can be executed by the automatic interpreter.

3. Relation between data and program area addresses how programs process
abstract data to get output data from input data, the relationship between
data and the information they represent, and ultimately their dual nature
of being program and data at the same time.

4. In Programs are running on computers area, the focus is on the distinction
between software (programs) and hardware (computing devices), and the
role of programs in the use of computing devices.

5. Finally, Program execution area is about the execution of programs on a
computing device and the eﬀects its execution causes, including possibly
malicious eﬀects caused by malware or errors.

4

In the rest of this section we limit ourselves to a sample of statements from
diﬀerent areas, with examples that exemplify them. The full list of all sentences
including sample skills and attitudes is in the appendix.

—

Knowledge area: Algorithms

Knowing that to solve a real-world problem on a computer, it has
to be modeled ﬁrst in the digital world as a computational problem
(computational twin).

Example. To create a method to ﬁnd a path through a hedge maze, it is
advisable to reduce the maze to its essential elements that are important
for ﬁnding a way out. So, the kind of hedge, its height, the length and
form of the paths, etc., are not relevant. Relevant for the model is the
structure of the maze, i.e., which walls are connected to each other and
which part of walls are outside the maze. The computational problem is
to ﬁnd a wall that is outside the maze.

—

Knowledge area: Programs are made of instructions

Knowing that programming languages provide structures that al-
low program instructions to be executed in sequence, repeatedly,
or only when a certain condition is met.

Example. For instance, in a video game a sprite moves around. When it
moves, it ﬁrst makes a step with the left foot (one program instruction)
and then a step with the right foot (the second program instruction). The
double step represents a sequence of two program instructions. Further,
when the sprite has to move for 10 double steps, it can do this with ten
repetitions of the above sequence. Moreover during its move, if the sprite
bumps into a wall, it cannot make a step. To detect the wall, it checks
the wall detect condition.

—

Knowledge area: Relation between data and program

Being aware that the data (e.g. numbers, text, images, sounds)
has to be properly digitized (digitally encoded), so that it can be
processed by a program.

Example: A picture can be digitized as a grid of color dots. Each color
can be modeled as a combination of three basic colors and therefore a
color dot is encoded as a triplet of numbers, indicating the brightness of
the basic colors. The RGB model uses red, green and blue as basic colors.

—

Knowledge area: Programs are running on computers

Knowing that computers consist of hardware and software.

5

Example: We want to play a computer game. In the ﬁrst situation we
have a gaming device which is just a piece of hardware. When we switch
it on, it loads and runs a piece of software like our gaming application
and only then can we play the game. On the other hand in the second
situation we can have a computer game (software) on our memory stick.
Until the memory stick is plugged into the device (piece of hardware), and
the device loads the computer game from the memory stick and runs it,
we can not play the game either. From the above examples we conclude
that we need both hardware and software to play the game.

Computer programs enable computers and computer-driven devices to fulﬁll
a wide range of tasks. But everybody should be aware that also the power of
programs is limited. We mention here as examples two knowledge statements
that are related to the limitation of problem solving by a computer program.
The ﬁrst statement captures the limits of ﬁnding an exact solution to a given
problem.

—

Knowledge area: Algorithms

Knowing that exact solutions to problems may not exist, or may
not be known, or may require too much time to be computed. They
are in practice replaced by approximate solutions (this is most
likely the case with Artiﬁcial Intelligence (AI) applications).

Example 1. Since a navigation system cannot calculate the exact arrival
time in advance, because there are many unknown inﬂuence factors (e.g.,
changing traﬃc conditions, congestion), it estimates the approximate ar-
rival time.
Example 2. Since in some cases it would take too much time for a chess
computer to compute the best move, it makes an estimation of the best
move to make.
Example 3. In AI and machine learning, deep neural network programs
are a frequent approach used for sentiment (emotion) recognition from
images of faces. However, the recognised sentiment is only the best guess
the algorithm can make.

The second statement exempliﬁes limitation related to the fact that programs
are programmed by humans. Everybody should be aware that malfunction of
computer systems can also be provoked by either the misbehaviour or computer
programmer’s mistakes.

—

Knowledge area: Program execution

6

Being aware that program execution can result in a computer sys-
tem malfunction, leaking of information or damage; and this may
be intentional by the design of the programmer (e.g., viruses or
malware) or unintentional as a consequence of programmer’s er-
ror. Be aware that programs have to be updated to protect the
computer system.

Example 1. It happens sometimes to us that our text editing program
used to frequently crash and we lost the result of our work. After the
program upgrade this never happened again.
Example 2. Also it can happen to us that, after opening an email with a
meaningless attachment, we forget about the message. After a while we
get a message from a local pizza store, complaining that we are trying
to break into their system for placing orders. It turned out that the
meaningless attachment was a program speciﬁcally designed to install on
our computer a special program permitting malicious operators to use our
computer in attacking the local pizzeria. Because the program was using
a ﬂaw in the design of the operating system installed on our computer
system, the problems went away after an update of our computer system.

To wrap up, in this section we presented ﬁve knowledge areas crucial to
understanding the Nature of Programs and programming. The areas were illus-
trated with a few knowledge sentences to give the reader an idea about them.
The list of sentences in each area is longer and covers all relevant aspects to
understand the nature of programs.

4 Conclusions

A competent and well-informed citizen of the digital world has to understand
the NoP, which encompasses the many properties of programs everyone has to
be aware of. Therefore, also in the K-12 computing education the understanding
of NoP must be explicitly addressed together with computational thinking and
problem-solving skills.

In order to elicit the NoP and make it accessible to the general public, we
wrote a series of knowledge statements describing the properties of programs.
Reﬂecting the development of programs and their use, we grouped the statements
into ﬁve knowledge areas. To illustrate the statements, in this position paper we
presented a sample of them through real cases.

We claim that in order to understand the NoP, hence perceiving all the facets
that characterize programs, one needs to experience some programming activi-
ties ﬁrst hand. This must include both coding and activities related to the more
abstract aspects as algorithms and data representation, as mentioned in Sec-
tion A. Note however that programming activities alone might not be suﬃcient,
and active reﬂections about the NoP should also be fostered in educational con-
texts. This clearly brings into question the need (1) to ﬁnd the appropriate ways

7

to make students appreciate the NoP, and (2) to properly train teachers so that
they acquire a correct understanding of the NoP themselves.

Fully grasping the NoP is essential for anyone in order to become digitally
conscious, to make sense of the digital world and, ultimately, to act proactively
and creatively in it.

References

1. Carretero, S., Vuorikari, R., Punie, Y.: DigComp 2.1: The Digital Competence
Framework for Citizens with eight proﬁciency levels and examples of use. Joint
Research Centre (European Commission), European Union (2017)

2. CSforALL: Computer science for all, https://www.csforall.org/, last accessed on

July 2021

3. Dagien˙e, V., Hromkovic, J., Lacher, R.: Designing informatics curriculum for k-12
education: From concepts to implementations. Informatics in Education (2021).
https://doi.org/10.15388/infedu.2021.22

4. Denning, P.J., Comer, D.E., Gries, D., Mulder, M.C., Tucker, A., Turner, A.J.,

Young, P.R.: Computing as a discipline. Computer 22(2), 63–70 (1989)

5. Informatics for All coalition: Informatics for all, https://www.informaticsforall.org,

last accessed on July 2021

6. International Society for Technology in Education(ISTE), Computer Science
Teachers Association (CSTA): Operational Deﬁnition of Computational Think-
ing for K12 Education (2011), https://cdn.iste.org/www-root/Computational
Thinking Operational Deﬁnition ISTE.pdf

7. Lederman, N.G.: Nature of science: Past, present, and future. In: Handbook of

research on science education, pp. 845–894. Routledge (2013)

8. Lessig, L.: Code is law. Harvard magazine 1 (2000), https://www.harvardmagazine.

com/2000/01/code-is-law-html

9. Lonati, V., Malchiodi, D., Monga, M., Morpurgo, A.: Is coding the way to
go? In: Brodnik, A., Vahrenhold, J. (eds.) 8th International Conference on In-
formatics in Schools: Situation, Evolution, and Perspective. LNCS, vol. 9378,
pp. 165–174. Springer International Publishing, Switzerland (September 2015).
https://doi.org/10.1007/978-3-319-25396-1 15

10. National Science Teachers Association: Nature of science (Jan 2020), https://www.

nsta.org/nstas-oﬃcial-positions/nature-science

11. Rapaport, W.: Philosophy of Computer Science (2020), https://cse.buﬀalo.edu/

∼rapaport/Papers/phics.pdf

12. Shaw, M.: The nature of computer science. In: The Carnegie-Mellon Curriculum

for Undergraduate Computer Science, pp. 7–12. Springer (1985)

13. Taub, R., Armoni, M., Ben-Ari, M.: CS unplugged and middle-school students’
views, attitudes, and intentions regarding CS. ACM Trans. Comput. Educ. 12(2)
(Apr 2012). https://doi.org/10.1145/2160547.2160551

14. Tissenbaum, M., Ottenbreit-Leftwich, A.: A vision of K-12

computer
education for 2030. Commun. ACM 63(5), 42–44 (Apr 2020).

science
https://doi.org/10.1145/3386910

15. Turkle, S., Papert, S.: Epistemological pluralism: Styles and voices within the com-
puter culture. Signs: Journal of women in culture and society 16(1), 128–157 (1990)
16. Vuorikari, R., Punie, Y., Carretero, S., Van den Brande, L.: DigComp 2.0: The
digital competence framework for citizens. Joint Research Centre (European Com-
mission), European Union (2016)

8

17. Wing, J.M.: Computational thinking. Communications of the ACM 49(3), 33–35

(2006)

A Knowledge areas

Five knowledge areas are:

1. The area Algorithms covers the modeling of real problems as computational
problems, the design and evaluation of their computational solutions, and
related complexity and computability issues.

2. The area Programs are made of instructions concerns the fact that an al-
gorithm needs to be translated into a programming language. The artifact
resulting from this translation is the actual program, which is understood
and can be executed by the automatic interpreter.

3. Relation between data and program area addresses how programs process
abstract data to get output data from input data, the relationship between
data and the information they represent, and ultimately their dual nature
of being program and data at the same time.

4. In Programs are running on computers area, the focus is on the distinction
between software (programs) and hardware (computing devices), and the
role of programs in the use of computing devices.

5. Finally, Program execution area is about the execution of programs on a
computing device and the eﬀects its execution causes, including possibly
malicious eﬀects caused by malware or errors.

In the rest of the section we discuss each of the knowledge areas in detail. For
each area we give a list of knowledge sentences with an additional exaplanation
where necesary. The lists are accompanied with lists of skills and attitudes.

A.1 Algorithms

Knowlede sentences

K1.1: Knowing that to solve a real-world problem on a computer, it has
to be modeled ﬁrst in the digital world as a computational problem
(computational twin).

Explanation: o create a method to ﬁnd a path through a hedge maze, it is
advisable to reduce the maze to its essential elements that are important
for ﬁnding a way out. So, the kind of hedge, its height, the length and
form of the paths, etc. are not relevant. Relevant for the model is the
structure of the maze, i.e. which walls are connected to each other and
which part of walls are outside the maze. The computational problem is
to ﬁnd a wall that is outside the maze.

9

K1.2: Knowing that an algorithm represents a solution to a computa-

tional problem.

Explanation: A well known algorithm to ﬁnd a way through any hedge
maze, that is enter a hedge maze and exit it at the end, is the wall
follower algorithm. If one enters a hedge maze then all the walls that are
connected to each other at the left side of the entrance can be walked
around by simply following the walls on the left side of our walk. As the
wall on the left side of the entrance is an outside wall, and since all walls
are connected, walking around them will deﬁnitely bring us out again.
This simple approach ﬁnds a way through any possible hedge maze, so it
is an algorithmic solution to a computational problem of maze traversal.

K1.3: Knowing that various problem-solving strategies are used to devise

and design algorithms.

Explanation: When we play cards, we want to have them ordered in our
hand. One way to order them is to ﬁrst pick up the smallest card and put
it on the left, then pick up the second smallest and put it next to it and so
on. This is an example of a greedy strategy. The same strategy works for
other completely diﬀerent problems. For example when a cashier wants
to give us back change in as few coins as possible.
Other well known problem-solving strategies are divide-and-conquer,
depth-ﬁrst-search, breadth-ﬁrst-search.

K1.4: Knowing that an algorithm is presented in a form that is language
independent but permits a judgment of its correctness (that it does
what it is supposed to do) and eﬃciency (how eﬃciently it solves the
problem).

Explanation: We have a shuﬄed deck of cards and we wonder if the queen
of spades is in it. We do this by checking each card in the deck in order
until we ﬁnd it or we run out of cards. This algorithm can be presented
e.g. in the form of a ﬂowchart or pseudo-code. These representations
cannot be executed by a computer, but they should be exact enough that
one may judge its correctness and eﬃciency. On one hand we can judge
that the algorithm will always ﬁnd the searched for card as it checks all
cards in the deck. On the other hand, to measure the eﬃciency of the
algorithm, we count the number of cards we check. The number of cards

10

we check depends on how soon we ﬁnd the queen, but we will never
check more cards than there are in the deck. Note that if the deck is not
shuﬄed but already ordered, we can design a more eﬃcient algorithm to
ﬁnd the queen of spades.

K1.5: Knowing that an algorithm requires time and space (hardware re-

sources) to solve a problem depending on the problem’s size.

Explanation: An algorithm that calculates the sum of an arbitrary se-
quence of values may start with the ﬁrst one, then add one value at a
time. The time this algorithm needs depends on the number of values
in the sequence, while the space, that is memory, it needs has to be
suﬃcient to record the sum.

K1.6: Knowing that computational problems:

a: may be solved by diﬀerent algorithms.

Explanation:
If we are looking for the queen of spades in an ordered
deck of cards, we can search for it by inspecting one by one each card in
the deck as explained above. A completely diﬀerent algorithm could ﬁrst
inspect the card in the middle of the deck and if it is smaller than the
queen of spades it proceeds with a search in the upper part of the deck
which is just half of the size of the original deck. Otherwise, the middle
card is smaller than the queen of spades, it proceeds in the lower part
of the deck. The algorithm simply repeatedly applies the same approach
until it ﬁnds the queen or runs out of the deck.

b: exist that cannot be solved in a reasonable time, even for their mod-

est size.

Explanation: A very impressive example is a puzzle like the one shown
in Fig. 1. The player gets the image cut into several pieces, and she must
rebuild these pieces into one image in which all beavers ﬁt. In the above
picture the colour of the beavers (brown, red, blue and green) and the
top and the bottom part of the head must match. The 3x3 puzzle is not
easy to solve for humans, a 5x5 puzzle is practically impossible. To solve
a 7x7 puzzle of this kind is even for the fastest available computers out
of reach, except by chance.

11

Fig. 1. Move pieces to get beavers.

c: exist that cannot be solved in principle, no matter how fast the ma-

chine is or how smart the algorithm designer is.

Explanation: Peter is a teacher of computer science and he wants to
check that the programs submitted by the students are correct. Therefore
he wants to write a program that could check for any other program
whether it is correct or not correct. Unfortunately such a program cannot
be written in principle.
There are other computational problems that are also not solvable in
principle, e.g. automatic checking for any program whether it is harmful
to our computer (malware), ﬁnding all errors in any given computer
program, automatically writing a program for any given computational
problem.

K1.7: Knowing that exact solutions to problems may not exist, or may
not be known, or may require too much time to be computed. They
are in practice replaced by approximate solutions (this is most likely
the case with Artiﬁcial Intelligence (AI) applications).

Explanation: Since a navigation system cannot calculate the exact ar-
rival time in advance, because there are many unknown inﬂuence factors
(e.g. changing traﬃc conditions), it estimates the approximate arrival
time.

12

Since in some cases it would take too much time for a chess computer
to compute the best move, it makes an estimation of the best move to
make.
In AI and machine learning, deep neural network programs are a frequent
approach used for sentiment recognition from images of faces. However,
the recognised sentiment is only the best guess the algorithm can make.

Skills

S1.1: Being able to write down instructions to sort a deck of cards.

S1.2: Given an algorithm that reads up to three numbers, makes diﬀerent
calculations and prints the result at the end, being able to determine
what will be printed when given input numbers are entered.

S1.3: Given a set of algorithm blocks, being able to combine them to solve

a more complex problem.

S1.4: Given an algorithm with a single loop that sometimes runs forever,

being able to describe conditions when this happens.

S1.5: Having two algorithms that ﬁnd a card in a sorted deck of cards,

being able to argue which of them requires more steps.

Attitude

A1.1: Appreciating the beneﬁts of using algorithms in daily life.

A1.2: Valuing positive and negative aspects of decision making algo-

rithms.

A1.3: Developing a critical awareness that algorithms are the humanly

made blueprint of programs.

13

A1.4: Willing to accept an algorithm may not be perfect in solving the

underlying problem.

A1.5: Feeling comfortable with decomposition of tasks.

A.2 Programs are made of instructions

Knowlede sentences

K2.1: Knowing that a computer program is written by humans according

to strict rules in a programming language.

Explanation: When programmers write a program they need to know
and stick to the rules of the programming language they are using. For
instance, to display “Hello, Europe” on the screen, the rules in Python
require us to write:

print("Hello, Europe")

whereas the rules in PHP require us to write:

echo "Hello, Europe";

and the rules in Blockly require to combine the following blocks:

On the contrary, the following writing:

print (\Hello Europe"]

does not respect Python rules, because the parentheses are not properly
matched.
In visual programming environments like Blockly, the shapes of blocks
make the rules of the language visible and prevent the programmer from
breaking the rules: if the combination of two blocks is not allowed, their
shapes prevent them from being connected. For instance we cannot di-
rectly connect the blocks depicting numbers 12 and 33 together. How-
ever, the language rules allow you to combine them, for example using
an operator block:

14

K2.2: Knowing that there are diﬀerent kinds of instructions and that
there are many programming languages each providing a diﬀerent set
of program instructions.

Explanation: There are program instructions that display something on
a screen, read data from a touchscreen, calculate values, store values
in memory, etc. Other speciﬁc instruction can be provided by special-
ized languages: R language provides program instructions to support
statistical analysis of data; PHP provides program instructions to cre-
ate interactive webpages; and Scratch provides program instructions to
display sprites, move them and make them interact with each others, as
in a video game or a movie.

K2.3: Knowing that programming languages provide structures that al-
low program instructions to be executed in sequence, repeatedly, or
only when a certain condition is met.

Explanation: For instance, in a video game a sprite moves around. When
it moves, it ﬁrst makes a step with the left foot (one program instruction)
and then a step with the right foot (the second program instruction). The
double step represents a sequence of two program instructions. Further,
when the sprite has to move for 10 double steps, it can do this with ten
repetitions of the above sequence. Moreover during its move, if the sprite
bumps into a wall, it cannot make a step. To detect the wall, it checks
the wall detect condition.

K2.4: Knowing that a programmer has to be aware of what program in-

structions do, but not necessarily how they do it.

15

Explanation: If a Python programmer wants to print text \Hello Europe"
on the screen, she uses the program instruction print(\Hello Europe").
After this, the programmer needs not to worry about what needs to hap-
pen in order for the text to appear on the screen.

K2.5: Knowing that new instructions can be created from existing in-

structions to perform a speciﬁc task.

Explanation: In Blockly or in many other programming languages, we
can create a new program instruction that draws a square. From now on
we can use the new program instruction as any other program instruction
in our program. A new program instruction created by a programmer is
called diﬀerently in diﬀerent programming languages: function, subrou-
tine, macro, procedure etc.
Most programming languages permit created program instructions to
be packed into libraries which can be shared among programmers and
provide ready-made program instructions.

Skills

S2.1: Being able to make changes in a formal description of a procedure.

Explanation: Being able to modify or complete a simple program written
in a visual programming language.

S2.2: Giving a procedure described in a formal way, being able to recog-

nize which kind of information it processes.

Explanation: Given a simple program written in a known programming
language, being able to identify if it processes numerical data, images,
point coordinates, or something else.

S2.3: Giving a procedure described in a formal way, being able to recog-
nize the ﬂow of information, that is how information is processed.

Explanation: Given a simple program written in a known programming
language and a given input, being able to ﬁnd out what the output will
be.

16

S2.4: Being able to detect possible problems in a formal description of a

procedure.

Explanation: Being able to reproduce the error of a program and perform
simple debugging. Being able to identify and describe the conditions
under which the program written in a known programming language
does not behave as desired.

Attitude

A2.1: Developing the awareness that the responsibility of software fail-

ures should be attributed to the software developers.

A2.2: Not being afraid to try to understand the source code of a program.

A2.3: Discussing and discovering if two diﬀerent sequences of instruc-

tions give the same result.

A2.4: Appreciating the possibility and value of creating new instructions.

Explanation: New instructions can for example be functions.

A2.5: Developing an appreciation for expressing actions and conditions
precisely and unambiguously, even in natural language descriptions.

A.3 Relation between data and program

Knowlede sentences

K3.1: Knowing that programs produce results depending on input data,
and that diﬀerent input data usually yields diﬀerent output data.

Explanation: In a navigation system the input is a destination location
and the output is a route to it. Diﬀerent input destinations yield diﬀerent
output routes.

17

K3.2: Being aware that the data (e.g. numbers, text, images, sounds) has
to be properly digitized (digitally encoded), so that it can be processed
by a program.

Explanation: A picture can be digitized as a grid of color dots. Each color
can be modeled as a combination of three basic colors and therefore a
color dot is encoded as a triplet of numbers, indicating the brightness
of the basic colors. The RGB model uses red, green and blue as basic
colors.

K3.3: Being aware that there is a diﬀerence between data and informa-
tion, in that data has no intrinsic meaning and gives information
only when interpreted by humans in the context of the problem being
solved.

Explanation: Data “42” can be interpreted as a temperature if it occurs
in a sentence like “Today is 42 C degree.” or as an age if it occurs in
a sentence like “I’m 42 years old.”, or as the answer to the Ultimate
Question of Life, The Universe, and Everything, if it is said by Douglas
Adams.

K3.4: Knowing that input data models information that is relevant to
the problem statement, and output data provide information relevant
to its solution.

Explanation: In the context of a translation program, the input word (or
sentence) models the meaning that the word (resp., sentence) has in the
source language, and the output data models the meaning of the word
(resp., sentence) in the destination language.

K3.5: Knowing that a program itself is data.

Explanation: When installing an application, we download data that is
later executedby the machine as a program.

Skills

18

S3.1: Being able to identify input and output data in some simple pro-

grams.

S3.2: Being able to recognize the diﬀerence between “batch” programs in
which the input is given once for all, and then output is produced and
“interactive” programs.

S3.3: Being able to ﬁnd information about digital encoding of speciﬁc

data.

S3.4: Being able to determine the amount of data to be downloaded to

install a program.

Attitude

A3.1: Inclined to critically evaluate the choice of programs by the de-

mand and supply of data.

A3.2: Discussing the beneﬁts of diﬀerent choices for digital encoding of

data.

A3.3: Arguing about the amount of data that has to be downloaded to

install a program by backing up one’s claim with evidence.

A3.4: Appreciating the importance of context that gives meaning to data

and computation.

A.4 Programs are running on computers

Knowlede sentences

K4.1: Being aware that many technological devices contain computers

which control them.

19

Explanation: For example, a greenhouse is digitally controlled by a vari-
ety of programmed devices: A smart temperature sensor runs a program
that checks whether the temperature is above or below the target range
for a particular time of day and then triggers the heating or cooling sys-
tem when needed. Further, a security camera uses a machine learning
algorithm to detect non-plant motion and sends a video sequence to a
computer. Both, the data from the temperature sensor and the video
sequences are stored on a desktop computer which moreover generates a
graph of the temperature. All devices are connected to a (wireless) router
which uses networking software to enable the transmission of data.

K4.2: Knowing that computers consist of hardware and software.

Explanation: We want to play a computer game. In the ﬁrst situation we
have a gaming device which is just a piece of hardware. When we switch
it on, it loads and runs a piece of software like our gaming application
and only then can we play the game.
On the other hand we can have a computer game (software) on our
memory stick. Until the memory stick is plugged into the device (piece
of hardware), and the device loads the computer game from the memory
stick and runs it, we can not play the game either.
From the above examples we conclude that we need both hardware and
software to play the game.

K4.3: Knowing that an operating system is a special type of software that
enables a user to run application software on a computing device.

Explanation: We are using our smart phone to attend a video conference
call using the phone’s camera, speaker and microphone. In the middle
of the video conference call comes a phone call and a phone application
is started which needs to ﬁrst use the speaker to ring and then, if we
decide to take the call, now let the phone application also use the speaker
and the microphone. All the coordination work needed for this is done
unseen for the user by the operating system and the user is barely aware
of it. In this way the operating system permits several applications to
run simultaneously on the device.
An operating system manages input devices such as a keyboard and
mouse, output devices such as monitors, speakers and printers and stor-
age devices such as internal and external memory. Moreover, it also man-
ages network connections. Finally, to interact with the operating system
the user can use either a graphical user interface (GUI) or command line
interface.

20

K4.4: Recognizing that computer systems which have the same or similar
hardware may have diﬀerent operating systems with diﬀerent (graph-
ical) user interfaces installed on them.

Explanation: When we buy a new computer, we can install either Linux
operating system, Windows operating system, FreeBSD operating sys-
tem or some other operating system. This is true even for the Apple
computers and some smartphones. Moreover, when we install the oper-
ating system, we can also use diﬀerent graphical interfaces on the same
operating system, which is most common on the Linux operating system.

Skills

S4.1: Being able to identify which program is responsible for the overload

of a computer system and stop the program.

Explanation: Being able to launch the task manager utility to get infor-
mation about the resources used by programs that are running on your
personal computer.

S4.2: Being able to install, update and uninstall diﬀerent software on a

computer system.

Explanation: Being able to upgrade the version of the operating system
on a Smart TV. Being able to uninstall an app from a smartphone.

S4.3: Being able to recognize the same simple functionality under diﬀer-

ent operating systems.

Explanation: Being able to list the ﬁles in Desktop on iOs and Windows
MS.

Attitude

A4.1: Developing a positive attitude and self-conﬁdence in the use of

programs.

21

A4.2: Being open to new programs, self-conﬁdent in exploring their func-
tionalities, respecting the experiences and opinions of others when
selecting new programs.

A4.3: Evaluating new program tools before using them and conﬁdently

switching to them if favourable assessment.

A4.4: Helping and guiding others in selecting and using new programs.

A.5 Program execution

Knowlede sentences

K5.1: Knowing that a computer is able to automatically interpret and

execute instructions.

Explanation: The program is a sequence of instructions. The instructions
are executed one after the other by the computer. In fact the computer
consists of several parts and one of them is the central processing unit
(CPU) which interprets and executes instructions automatically one at
a time.

K5.2: Knowing that for a program to be executed by a computing device
it may be necessary to translate it from the programming language it
is written in, into a language understood by a computing device, and
this is done by speciﬁc programs.

Explanation: We can run an App that we have downloaded to our mobile
phone, but we can neither inspect its code nor modify it. In order to
modify the App, one needs to have access to its source code. In order
to update an App, its developers modify its source code, then use a
speciﬁc program (compiler) to translate the source code into a language
understood by mobile phones, and ﬁnally release the resulting updated
version of the App.

K5.3: Knowing that execution of programs changes data stored in the

computer system.

22

Explanation: Each time you enter or update your emails through the
software, the program checks for new emails and downloads them if there
are any new ones, resulting in a change in the data stored about emails
on your computer.

K5.4: Being aware that program execution can result in a computer sys-
tem malfunction, leaking of information or damage; and this may be
intentional by the design of the programmer (e.g. viruses or malware)
or unintentional as a consequence of programmer’s error. Be aware
that programs have to be updated to protect the computer system.

Explanation: It happens sometimes to us that our program for text edit-
ing used to crash frequently and we lost the result of our work. After the
program upgrade this never happened again.
Also it can happen to us that after opening an email with a meaningless
attachment and then we forget about the message. After a while we
get a message from a local pizza store, complaining that we are trying
to break into their system for placing orders. It turned out that the
meaningless attachment was a program speciﬁcally designed to install
on our computer a special program permitting malicious operators to
use our computer in attacking the local pizzeria. Because the program
was using a ﬂaw in the design of the operating system, the problems
went away after an update of our computer system.

K5.5: Be aware that during the execution of a program the data is stored
in either a permanent or a volatile way and the one stored in the latter
is lost when the application crashes or the power is cut oﬀ.

Explanation: If your computer suddenly crashes (stops working) while
you are writing a document, for example in a word processor, there is
a chance that the latest changes to your document are lost because it
was not stored permanently. Similarly, your e-mail message could be lost
if the mail program stops working while you are writing it. This could
happen with almost any program or computing device so have in mind
to check that it is automatically stored on the device or in the cloud
frequently enough or you have to store it explicitly yourself.

23

K5.6: Being aware that there are programs (applications) with a graphi-
cal user interface that are used by users to accomplish a certain task,
and other programs without a user interface that are started auto-
matically, and are necessary to make the computer useful (such as
operating systems, system support programs, programs on embedded
systems).

Explanation: The software we use from time to time needs to be updated.
However, we do not know when the update will occur. For this reason, a
special program starts automatically without an explicit user command,
and periodically checks the availability of an update.
While we are browsing the Internet an antivirus program may automat-
ically check for unexpected attempts to access our computer. Similarly,
when we want to communicate on social media platforms, an integrated
grammar checking program may automatically correct our posts. Finally,
when the posting is ready to be published and we press the share but-
ton, we need not to care about all the details involved in transferring
bits on the network appliance, as the operating system automatically ar-
ranges both hardware and software resources to transfer and publish the
content. The operating system, automatic grammar checkers and virus
checkers often work without interacting with the user.

Skills

S5.1: Being able to start execution of a program on a personal computer

or a smartphone.

S5.2: Being able to stop execution of a program on a personal computer

or a smartphone.

Explanation: Especially when the program cannot be controlled within
the user interface provided by the program, e.g. endless loop.

S5.3: Being able to describe how a used piece of software saves user input

to be retrieved in the future.

Explanation: For example, saved automatically/by explicit saving by
user, locally/remotely.

24

S5.4: Being able to describe the context under which an app is malfunc-

tioning.

Attitude

A5.1: Appreciating the beneﬁt of computers automatically interpreting

and executing instructions.

A5.2: Developing a critical attitude to periodically checking for a new

version of the program.

A5.3: Developing cautiousness about downloaded programs.

A5.4: Trying to ﬁnd out why a program is not acting as expected and
persistently trying to ﬁnd a solution, even if attempts were less suc-
cessful.

25

