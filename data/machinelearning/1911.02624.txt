Data Generation for Neural Programming by Example

Judith Clymo∗
University of Leeds
scjc@leeds.ac.uk

Haik Manukian∗ Nathana¨el Fijalkow

University of California
at San Diego
hmanukia@ucsd.edu

CNRS, LaBRI
Alan Turing Institute
nathanael.ﬁjalkow@labri.fr

Adri`a Gasc´on
Google
adriagascon@gmail.com

Brooks Paige
UCL
Alan Turing Institute
bpaige@turing.ac.uk

9
1
0
2

v
o
N
6

]

G
L
.
s
c
[

1
v
4
2
6
2
0
.
1
1
9
1
:
v
i
X
r
a

∗ equal contribution

Abstract

Programming by example is the problem of
synthesizing a program from a small set of
input / output pairs. Recent works applying
machine learning methods to this task show
promise, but are typically reliant on generat-
ing synthetic examples for training. A par-
ticular challenge lies in generating meaning-
ful sets of inputs and outputs, which well-
characterize a given program and accurately
demonstrate its behavior. Where examples
used for testing are generated by the same
method as training data then the perfor-
mance of a model may be partly reliant on
this similarity. In this paper we introduce a
novel approach using an SMT solver to syn-
thesize inputs which cover a diverse set of
behaviors for a given program. We carry out
a case study comparing this method to exist-
ing synthetic data generation procedures in
the literature, and ﬁnd that data generated
using our approach improves both the dis-
criminatory power of example sets and the
ability of trained machine learning models to
generalize to unfamiliar data.

1 Introduction

The machine learning community has become increas-
ingly interested in tackling the problem of program-
ming by example (PBE), where the goal is to ﬁnd a
short computer program which is consistent with a set
of input and output (I/O) pairs. Methods have been
developed that use neural networks either to gener-
ate source code directly (Devlin et al., 2017; Parisotto

Technical report.

et al., 2016; Bunel et al., 2018) or to aid existing search
algorithms (Balog et al., 2017). These papers re-
port impressive empirical performance. However, deep
learning methods are data-hungry, and programming
by example is not a data-rich regime.

Many neural program synthesis methods are developed
targeting domain-speciﬁc languages (DSLs), such as
the FlashFill environment (Gulwani et al., 2012; De-
vlin et al., 2017), a custom list processing language
(Balog et al., 2017; Feng et al., 2018), or the Karel the
Robot environment (Bunel et al., 2018). These lan-
guages do not have a large body of human-generated
code, nor do they have canonical examples of I/O pairs
which correspond to usage in a real-world scenario. As
a result, neural program synthesis has turned to gen-
erating synthetic data, typically by sampling random
programs from some predeﬁned distribution, sampling
random inputs, and then evaluating the programs on
these inputs to obtain I/O pairs.

The synthetic data is typically used as both the train-
ing set for ﬁtting the model, and the testing set for
evaluating the model, which is problematic if there
is a mismatch between these random examples and
potential real-world usage.
In the absence of any
ground truth this problem of over-ﬁtting is often ig-
nored.
In addition, I/O pairs produced by random
generation may not be examples that particularly well-
characterise a given program. This can aﬀect experi-
mental results through program aliasing, where many
diﬀerent possible programs are consistent with the I/O
examples (Bunel et al., 2018).

Nearly all existing approaches are based on an implicit
assumption that programs and I/O examples used for
training should be chosen in a way that is as uniform as
possible over the space, despite the fact that many I/O
examples are uninformative or redundant, as is well
known in the automated software testing community
(see e.g. Godefroid et al. (2005)).

Contributions.
In this paper we consider how to
generate sets of I/O examples for training a neural

 
 
 
 
 
 
Technical report

PBE system. In particular we are concerned with the
generalizability of neural networks trained for PBE on
synthetic data. We present four approaches to data
generation in this context, including a novel constraint
based method. We show how these diﬀerent methods
can be applied in a case study of the DeepCoder DSL
from Balog et al. (2017), an expressive language for
manipulating lists of integers. The DeepCoder DSL
has several features that make it an interesting and
challenging setting for generating synthetic training
data: it is capable of displaying complex behavior in-
cluding branching and looping; the set of valid inputs
for a given program can be diﬃcult to deﬁne and/or
restricted; and the most informative examples are dis-
tributed unevenly throughout the space. We train neu-
ral networks designed for program generation and as-
sisting a program search using examples produced by
the four outlined methods, then use cross-comparison
to quantify the robustness of these networks. We also
evaluate the degree to which diﬀerent synthetic data
sets uniquely characterise a program, important for
addressing the program aliasing problem.

2 Related work

Most approaches to generating I/O examples are based
on random sampling schemes, with either a rejection
step or initial constraints.

Balog et al. (2017) construct a database of programs in
the DeepCoder DSL by enumerating programs up to a
ﬁxed length and pruning those with obvious problems
such as unused intermediate values. They produce I/O
examples for each program by restricting the domain
of inputs to a small, program-dependent subset which
is guaranteed to yield valid outputs and then sampling
uniformly from this set. Feng et al. (2018) targets the
same DSL but example pairs are generated by sam-
pling random inputs and seeing whether they evaluate
to a valid output. If a suﬃcient number of valid pairs
are not found within a ﬁxed amount of time, the pro-
gram is discarded. The paper does not state what
distribution is used to sample inputs. In both of these
papers, this synthetic data is used for both training
the model and for evaluating its performance.

Bunel et al. (2018) considers the Karel the Robot do-
main, and creates a dataset of programs by random
sampling from the production rules of the DSL, prun-
ing out programs which represent the identity func-
tion or contain trivial redundancies. I/O examples are
constructed by sampling and evaluating random input
grids. No mention is made of what sampling distri-
bution is used for either the programs or the input
grids; the synthetic data is used for both training and
testing.

Parisotto et al. (2016) generates synthetic data for the
FlashFill domain (Gulwani et al., 2012) by sampling
random programs up to a maximum of 13 expressions.
The reported performance suggest a very large gap be-
tween the synthetic examples (97% accuracy) and the
real-world data (38% accuracy). Devlin et al. (2017) is
more cautious: performance is evaluated only on the
real-world examples, with synthetic data used only for
training. The training data is produced by simulat-
ing random programs up to a maximum of 10 expres-
sions, and then constructing I/O pairs by sampling
random inputs and testing to see whether executing
the program raises an exception. Neither paper ex-
plicitly speciﬁes any of the sampling distributions.

The papers above all primarily focus on advancing
search algorithms or improving heuristics, with little
attention to data generation; the only exception we are
aware of is Shin et al. (2019), which speciﬁcally pro-
poses a method for improving synthetic example gen-
eration. Their approach requires ﬁrst deﬁning a set of
“salient variables” for the domain: these take the form
of a mapping from a synthetic training example to a
discrete value. They then deﬁne a sampling strategy
for examples which aims to maximize their entropy, by
generating a training dataset which is overall approx-
imately uniform over all the combinations of the dif-
ferent discrete salient variables. Particular attention
is paid to the Karel the Robot domain, and the gen-
eration of synthetic data for the algorithms in Bunel
et al. (2018).

When there are many salient variables the discrete do-
main can be large. However, the number of I/O exam-
ples needed for each program is typically quite small.
In the Karel the Robot domain the input space is not
constrained by the programs so it is natural to enforce
uniformity across salient variables over the whole set
of inputs. Where the program can signiﬁcantly aﬀect
the valid input space the approach is not appropriate.
The contributions we make to this task are comple-
mentary to those of Shin et al. (2019), which in this
domain could still be beneﬁcially applied in selecting
a set of synthetic programs, but would be diﬃcult to
adapt to generating meaningful inputs.

3 ML-aided Programming by

Example

Figure 1 outlines the general approach to programming
by example we take in this paper, providing a frame-
work which can be used to understand methods and
settings employed in recent work. The problem is de-
ﬁned in terms of a concrete DSL that takes as input a
set of examples (x1, y1), . . . , (xk, yk), and synthesizes a
program mapping inputs xi to the corresponding out-

Technical report

DSL-specific
Data Generation G

Synthetic

Training

Dataset

Examples
(x1, y1), . . . , (xk, yk)

Learning

Model M

Ranking
heuristic

Prioritised
Search Tree

constraining the domain of valid inputs. This DSL is
remarkably expressive: it can express non-linear func-
tions via repeated integer multiplication, control ﬂow
(if-then-else statements can be encoded by means of
Filter), and loops over lists (by means of the higher-
order functions). Moreover, the higher-order functions
like Reverse, Sort, ZipWith and Scanl1 allow to
encode surprisingly complex procedures in just a few
lines, such as the four-line example shown in Figure 2.

Figure 1: ML-aided programming by example

4 Data Generation Methods

puts yi. At the core of the approach is a search algo-
rithm that explores the space of all programs up to a
certain predeﬁned length according to a ranking func-
tion. This heuristic ranking function is derived from
the output of an ML model M that inspects the input
(x1, y1), . . . , (xk, yk). Crucial in this approach is the
training dataset of M. This dataset is obtained using
a DSL-speciﬁc generation procedure G that generates
(a) programs and (b) a small set of inputs for those
programs.

Hence, to instantiate a concrete approach to ML-aided
programming by example one needs to deﬁne (i) the
DSL, (ii) the data generation procedure G, and (iii)
the ML model M and corresponding search procedure.
As mentioned above, previous work focuses primarily
on (iii). Here we instead focus on (ii), the training data
generation step, and investigate its eﬀect in concrete
instances of the complete pipeline.

3.1 Domain speciﬁc language

The DeepCoder DSL (Balog et al., 2017), which we
will use as our running example, consists of high-level
functions manipulating list of integers; a program is
a sequence of functions which take as input any of
the inputs or previously computed values. The DSL
contains the ﬁrst-order functions Head, Last, Take,
Drop, Access, Minimum, Maximum, Reverse,
Sort, Sum, and the higher-order functions Map, Fil-
ter, Count, ZipWith, Scanl1. The higher-order
function Map can be combined with (+1), (-1), (*2),
(/2), (*(-1)), (**2), (*3), (/3), (*4), (/4). The
two higher-order functions Filter and Count use
predicates (>0), (<0), (%2==0), (%2==1). Finally,
ZipWith and Scanl1 are paired with (+), (-), (*),
Min, Max. The lists in a program are of a predeﬁned
length (20 in the experiments of Balog et al. (2017))
with values in [−255, 256] ∪ {⊥}, with ⊥ denoting an
undeﬁned value. The semantics of the DSL assume
some form of bound checking, as indexing a list out of
its bounds returns ⊥, and over(under)-ﬂow checking,
as values outside of the range [−255, 256] evaluate to
⊥. As we will see, this impacts data generation by

We propose three new approaches for the data genera-
tion step. The ﬁrst is based on a probabilistic sampling
of the input space, while the other two treat data gen-
eration as a constraint satisfaction problem. We de-
velop a general framework for this approach and show
how additional constraints can be used to impose vari-
ation in the I/O pairs produced.

4.1 Sampling-based approaches

We use the approach from Balog et al. (2017) as a
baseline. Programs are evaluated in reverse to derive
a ‘safe’ range for input values that is guaranteed to
produce outputs in a target range. Values are then
sampled uniformly from the safe input range to create
the input(s), and the output is calculated by evaluat-
ing the program. If the safe range for some input is
empty or a singleton, then the program is discarded.
In reporting results of our experiments, we refer to this
method of data generation as “Restricted Domain”.

The purpose of the reverse propagation of bounds is to
exclude all non-valid inputs from the sampling. How-
ever, some valid inputs are also excluded.
Instead,
inputs can be sampled from an over-approximation of
the set of valid inputs or by using a probability distri-
bution that prioritises parts of the input space where
valid inputs are known to be common. Inputs are then
rejected if they are unsuitable for the program being
considered.

We observe that in the DeepCoder DSL, when the out-
put range is bounded, small input values are compat-
ible with more programs than large values. Sampling
with a bias towards small values means that suitable
inputs are found with high probability for all programs
within a ﬁxed number of attempts n. If suitable in-
puts for a program remain common outside of the safe
range identiﬁed by back propagation of bounds then
the gain from allowing these to be included could be
signiﬁcant.

To produce a sample, we ﬁrst ﬁx a random length of
the input (uniformly at random) and generate a value
r from an exponential distribution i.e. with probabil-

Technical report

a ← [int]
b ← Sort a
c ← Filter (>0) b
d ← Head c
e ← Drop d b

An input-output example:
Input:
[-17, -3, 3, 11, 0, -5, -9, 13, 6, 6, -8, 11]
Output:
[-5, -3, 0, 3, 6, 6, 11, 11, 13]

Figure 2: An example program in the DSL that takes a single integer array as its input.

Program P (X, Y )
Logic L

(cid:86)

i ψi ∧ ρi ∧ φ

Constraint Controller

φ(X, Y ) = encodeL(P )
ψi(X, Y ) = SynConsL(P, {xi, yi}i)
ρi(X, Y ) = SemConsL(P, {xi, yi}i)

L-Solver

(X (cid:55)→ xi, Y (cid:55)→ yi)

Figure 3: Our constraint-solving based approaches are
instances of the above model. A constraint controller
adaptively produces problems for the solver, whose so-
lutions correspond to new input-output pairs to be
added to the training dataset

ity P (r) ∼ Exp(r, λ) = λe−λr. The input values are
selected uniformly at random (with replacement) from
the range [−r, r], then evaluated on the program. If
the output of the program is within the desired range
the pair is accepted, otherwise a new value of r is sam-
pled and the process repeated.

Varying the choice of λ modiﬁes the strength of the
bias, aﬀecting both the number of attempts that must
be allowed and also the similarity of examples gener-
ated. In our case, we chose λ = 0.001 and n = 500.
This method will be referred to as “Non-Uniform Sam-
pling” in the experiments section.

4.2 Constraint-solving based approaches

Sampling methods are not well suited to navigating
valid input spaces that are sparse or irregular, and
in a language capable of displaying complex behavior
the most informative examples may also be rare. A
constraint solver is able to ﬁnd suitable inputs in parts
of the input space that are almost always excluded in
the sampling methods.
In this section we present a
methodology to synthesize a set of examples that relies
on constraint solving.

The general procedure is presented in Figure 3 and
consists of a feedback loop between a constraint con-
troller and a solver. The former adaptively produces
problems for the solver, whose solutions correspond to
new I/O pairs to be added to the training dataset.

The approach is parametrised by a choice of a logic
L, and assumes a solver, denoted L-Solver, that can
decide L, i.e. ﬁnd values for the variables in any for-
mula φ from L for φ to evaluate to true, or report
“unsatisﬁable” if such values don’t exist. We require
encoding and decoding procedures encodeL, decodeL
such that encodeL takes a program P with input vari-
ables X and output variables Y , and produces a for-
mula whose satisfying assignments can be translated
by decode into concrete input-output pairs of the pro-
gram P . For simplicity, we assume that the domain of
the variables in φL and P is the same in Figure 3 and
omit the decoding step.

The simplest data synthesis procedure consists of the
controller simply calling the solver iteratively to collect
a sequence of input output pairs (x1, y1), . . . , (xn, yn)
for P . Note that for DSLs like the one presented above,
a complete decision procedure might be too much to
ask, but for our purposes soundness is suﬃcient. More
concretely, encodeL should be constructed so that, for
each program P in the DSL the following holds:

∀XY : encodeL(P ) ⇒ P (X) = Y

This procedure, as described so far, is not very help-
ful, as nothing prevents the solver from returning the
same pair (x, y) at every iteration. This can be easily
avoided by the controller imposing the additional con-
straint X (cid:54)= xi ∨ Y (cid:54)= yi after every iteration. This is
the most basic form of additional constraint that we
consider. More generally, our approach considers two
additional sets of constraints, which we call syntac-
tic constraints, denoted SynConsL and semantic con-
straints, denoted SemConsL. While both of this con-
straints are conditions on I/O pairs – either for each
line of the program or the whole program – the former
consist of simple equality and inequality checks such
as “input and output should be diﬀerent”. In contrast,
semantic constraints are more powerful – and costly to
enforce – as they enforce predicates on input output
pairs such as “the maximum value of the input should
be smaller than the maximum value of the output”.

The next two concrete approaches to data generation
are instances of the above scheme, and thus correspond
to concrete choices for L, encode, decode, SynConsL,

Technical report

Table 1: Constraints and predicates used in Syntac-
tic and Semantic constraints used in our constraint-
based input generation algorithms. Constraints and
predicates are depicted as conditions on the I/O pairs
(x1, y1), . . . , (x5, y5) generated by the constraint-based
approaches. For programs taking more than one input
all constraints are applied to each of the inputs. xl
i is
the intermediate program output of line l given input
xi.

SynConsL for “Constraint Based” and “Semantic Variation”
c1 := ∀i : xi (cid:54)= yi
Output does not match input.
c2 := ∀i : xi (cid:54)= [ ]
All inputs are not empty.
c3 := ∀i (cid:54)= j : xi (cid:54)= xj
No duplicate inputs in a set.
c4 := ∀i (cid:54)= j : yi (cid:54)= yj
No duplicate outputs in a set.
c5 := ∀i : |xi| > B
Input length larger than random bound B.

Predicates in SemConsL for “Semantic Variation”
p1 := max(yi) > max(yi−1)
p2 := min(yi) < min(yi−1)
p3 := |xi| > C
pl,4 := head(xl
pl,5 := last(xl
pl,6 := |xl
pl,7 := max(xl
pl,8 := min(xl

Increase maximum.
Decrease minimum.
Input length larger than C.
Change in head.
Change in last.
Change in length.
Change in maximum.
Change in minimum.

i) (cid:54)= head(yl−1
i
i) (cid:54)= last(yl−1
)
|

i
i) (cid:54)= max(yl−1
)
i) (cid:54)= min(yl−1
)

i| (cid:54)= |yl−1

)

i

i

i

and SemConsL, and the corresponding variations in the
behavior of the constraint controller. In our implemen-
tation we use Z3 (de Moura and Bjørner, 2008) as a
back-end solver. Z3 implements incremental solving,
which allows to push and pop constraints into an ex-
isting formula while preserving intermediate states, a
crucial aspect of the implementation of a controller.
As per L, we experimented with the theory of non-
linear arithmetic, for which Z3 implements incomplete
procedures, and the theory of bitvectors.

4.2.1 Simple constraint solving

Our third data generation method uses a constraint
solver to produce valid examples with only minimal ex-
tra guidance. Hence, in this case SemConsL(P, S) = ∅.
SynConsL are given in Table 1 by means of a list of con-
straints c1, . . . , c5. At the ith iteration the pair (xi, yi)
is obtained from the solver as a satisfying assignment
of the constraints (cid:86)
i ψi ∧ φ (as shown in Figure 3),
where ψi = (cid:86)5
i=1 ci. This guarantees that synthesized
examples will satisfy these conditions if possible.

4.2.2 Constraint solving to generate varied

examples

Our fourth method is inspired by program veriﬁca-
tion approaches such as predicate abstraction and
CounterExample-Guided Abstraction Reﬁnement loop

(CEGAR) (Clarke et al., 2003). This method uses con-
straints more aggressively, and in particular semantic
constraints, by implementing an adaptive constraint
controller. The syntactic constraints used in this case
are as in the previous method, so we focus on de-
scribing the semantic constraints, and the adaptive
behaviour of the controller.

The controller ﬁrst uses sampling to generate a small
set of examples, and then keeps track of the evaluation
of predicates p1, . . . , p3 for the output of the program
and p4, . . . , p8, for every line of the program (see Ta-
ble 1) for each of the inputs found so far. For example,
for 5-line programs this corresponds to storing a 5 × 5
Boolean matrix M k for each input xk so far. The con-
troller also maintains a record of constraint combina-
tions that result in unsatisﬁable problems so these can
be avoided in subsequent calls. The high-level idea
is as follows: ﬁrstly, by monitoring any bunching of
in previous examples the controller can recognise pro-
grams with valid examples tending to bunch in one
part of the I/O space (in this DSL, bunching is always
towards zero, so monitoring maximum and minimum
is a good proxy) and force the constraint solver to seek
out examples in parts of the space where valid exam-
ples are relatively rare; secondly by monitoring which
of the predeﬁned behaviours p4, . . . , p8 are satisﬁed for
each program line, by each of the inputs xi collected
so far, the controller can detect sets inputs that do
not suﬃciently exercise internal lines of the program,
and hence send a weak signal regarding the presence
of the function at that line to the output. Besides
recording which behaviors are exhibited by each line,
the controller can impose a given behavior by assert-
ing a speciﬁc predicate (or its negation) as part of the
semantic constraints for that iteration. More speciﬁ-
cally, the controller deﬁnes the semantic constraint of
iteration i as SemConsL(X, Y ) := (∀k < i : ∃n, m :
(pn,m(X, Y ) (cid:54)= M k
n,m)), where pn,m is a Boolean for-
mula encoding that the nth line of the program sat-
isﬁes the mth predicate on input X. This constraint
enforces that in any valid assignment X (cid:55)→ xi, Y (cid:55)→ yi
obtained by the solver, input xi will induce a behav-
ior that diﬀers with each combination of behaviors in-
duced by inputs found so far in at least one line of the
program. This makes the intuitive goal of ﬁnding “a
varied set of inputs” precise.

Choosing predicates. The choice of features to
monitor is speciﬁc to the DSL and based on abstrac-
tions of the actions of its constituent functions. In this
DSL we are working with lists of integers deﬁned by
their length, the set of values contained, and the order
in which those values appear. The functions of the
DSL can change all of these features. Our aim is that
if the program is capable of changing the values that

Technical report

Figure 4: Histograms of the input values found in
training sets generated with the four data generation
methods considered. Note the large variation in y-
axes.

appear in the output compared to the input then there
should be an I/O example that demonstrates this, if it
is capable of reordering the elements this should also
be shown, and so on. The maximum, minimum, ﬁrst,
and last elements of a list act as simpliﬁed indicators
for changes in the values and order of the list and are
the same features used in Feng et al. (2018) to assist
the search procedure for this DSL.

We have referred to this data generation method as
“Semantic Variation” in the experiments.

5 Experiments

We consider two choices of ranking heuristics; one ex-
actly following Balog et al. (2017), and the other a nat-
ural extension based on recurrent neural networks, fol-
lowing a sequential generation paradigm (Devlin et al.,
2017; Bunel et al., 2018).

The four synthetic data generation methods discussed
above are compared in each of these settings. In par-
ticular, we investigate how neural networks trained
with data from one method perform at test time on
data generated by another. For a fair comparison of
the data generation methods, we use the same split
of programs into training and testing examples. Fig-
ure 4 shows how input values are distributed in data
generated by each method.

The DeepCoder heuristic. The ranking function
used in Balog et al. (2017) estimates, for each of the
38 functions in the DSL, the conditional probability
that the function ever appears in the program. The

Figure 5: Each network predicts the functions in a
given test set program. We report the fraction of pro-
grams for which all constituent functions are contained
in the top-k predictions. The networks are trained on
one mode of generation and tested on all the others.
Each line represents the performance of a training set,
deﬁned in the legend. From the performance gaps, we
see that the network trained on Semantic Variation
data appears more robust to a change in test data
generation method.

predicted probabilities provide a ranking for a depth-
ﬁrst search.

The recurrent neural network heuristic.
In ad-
dition, we consider an extension to DeepCoder which
is loosely inspired by the recurrent neural network ar-
chitectures used for program generation in other DSLs
(Devlin et al., 2017; Bunel et al., 2018).
Instead of
training the network to output a single set of prob-
abilities, we train a network to output a sequence of
probabilities, conditioned on the current line of the
program.

We do this by modeling the sequence of lines with a
long short-term memory (LSTM) network (Hochreiter
and Schmidhuber, 1997). To ease comparison, we leave
the majority of the network architecture unchanged;
the only modiﬁcation is the penultimate layer is re-
placed by an LSTM. The result is a network which
takes as arguments not just the I/O examples, but also
a target “number of lines”, and then returns estimates
of probabilities that a function occurs on a per-line ba-
sis, rather than program-wide. Complete architectural
details for both networks are in the appendix.

Technical report

Table 2: Total area under top-k curves, across all ap-
proaches to test data generation.

Method
Semantic Variation
Non-uniform Sampling
Constraint Based
Restricted Domain

Total AUC
126.11
123.14
118.24
114.21

Table 3: Errors due to program aliasing. Error cor-
responds to programs which are correct on the test
data, but diﬀer from the original generating program;
the predicted programs tend to be shorter, and often
strictly contained within the target program.

Method
Semantic Variation
Constraint Based
Non-uniform Sampling
Restricted Domain

% Error % Shorter % Contained

4
6
6
15

2
4
5
12

2
3
4
9

5.1 Cross-generalization of diﬀerent methods

The plots in Figure 5 show the proportion of programs
for which every line is included within the top k pre-
If functions ac-
dictions given by a neural network.
tually present in the program are ranked highly by
the network, this will accelerate the runtime of any
corresponding guided search. The baseline is given
by a ﬁxed ordering reﬂecting the relative frequency of
each function in the set of programs used for train-
ing. All networks performed better than the base-
line on all test sets, showing that the network is able
to generalise beyond its training setting. Test data
is always most accurately interpreted by the network
trained on data generated through the same process;
in fact, the four networks performed almost identically
to each other when tested on their own data. How-
ever, the ability of each network to transfer to foreign
data, from a diﬀerent generation process, varied sig-
niﬁcantly. The two sampling methods (Restricted Do-
main, Non-Uniform Sampling) in particular found the
data generated by an SMT solver diﬃcult, while the
loss from the constraint-based methods to the sam-
pling data was smaller, though still marked.

The sum of the area under the curves indicates the
robustness of the networks, with the Semantic Varia-
tion method having the largest area; values shown in
Table 2.

5.2 Program Aliasing

We measure how well the generated example sets char-
acterise their target program by taking a sample of
programs and I/O sets generated by each method, and

searching for programs no longer than the intended
program which matched the given examples.
If an
alternative program of the same length was recorded
across all test sets then this could be due to logical
equivalence, and these examples were excluded.

The Restricted Domain method had the highest rate
of ambiguous example sets with 15% of the sets tested
able to be satisﬁed by an alternative (not equivalent)
program, compared to a 4% error rate on examples
generated by the Semantic Variation method. Some
errors were very subtle, confusing programs that were
logically diﬀerent only on inputs with a speciﬁc form.
Others were due to diﬃculty distinguishing the func-
tions that output integers:
in a set of only ﬁve ex-
amples it is relatively common that the maximum of
every list is also at the same position, for example.

The results are summarised in Table 3 which shows
the percentage of example sets where an alternative
program was found and also indicates whether this
alternative program was strictly shorter and strictly
contained within the target program (i.e. the target
program included some function had no discernible ef-
fect for any of the provided inputs).

5.3 Performance on Independent Test Sets

We sought to test the four networks on data that is
not generated by a machine and created a small hand-
crafted test set of examples on programs of length two
to ﬁve. The performance of the neural networks is
shown in Figure 6, in the right-most plot. The test set
is clearly too small to draw any serious conclusions, but
the good performance of constraint based approaches
is encouraging.

As an alternative to this, we ﬁxed ﬁve inputs and ran
a set of programs on these same ﬁve inputs, keep-
ing those for which the resulting example set could
not be satisﬁed by another program of the same or
smaller length. Because some functions require mainly
small values in the inputs we made one test set by this
method which had almost all input values between −10
and 10, and a second set with many more large values.
This approach ensures the inputs alone are relatively
uninformative, forcing the networks to derive their pre-
dictions from the relationship between the inputs and
outputs. The results of this experiment are also shown
in Figure 6 (left and centre), again giving the propor-
tion of example sets for which the whole program was
contained in the top k predictions.

The networks all performed better than random, show-
ing their predictions are not purely reliant on learning
something about how the examples are generated. We
also observe a diﬀerence in performance depending on
whether the examples contain mostly small or mostly

Technical report

Figure 6: The fraction of programs contained in the top-k predictions of trained networks on hand-crafted
examples. Left and middle ﬁgures show performance on problems sets with ﬁxed inputs with large and small
average values respectively. Right ﬁgure shows performance on a small set of human generated examples.

forward networks. The network considered here pro-
vides an ordering for all lines at the start of the search.
A more advanced approach could update its prediction
for the next line given the evolving state of a partial
program; we leave this to future work as it requires
careful consideration of runtime costs: Repeated re-
evaluation of an RNN inside the inner loop of the
search algorithm could be ineﬃcient relative to sim-
ply running more iterations with a cheaper heuristic,
whereas the per-line ranking used here has identical
search-time cost as the DeepCoder heuristic.

6 Discussion

All the methods of generating data that we have con-
sidered were useful in training the neural network, and
each of the four trained networks displayed the ability
to generalise to unfamiliar testing data. Conversely, all
networks displayed a preference for testing sets gen-
erated in the same way as the data used for train-
ing, demonstrating over-ﬁtting to the data generation
method to some degree.

Constraint solving proved an eﬀective way of discover-
ing examples that were out of reach to sampling meth-
ods, and simple local features were useful in creating
example sets that characterise the target program well
and reduce the occurrence of ambiguous examples. We
also saw that the more informative training data in the
Semantic Variation method increased the resilience of
the neural network against unfamiliar test scenarios.

Acknowledgments

Work started when J. C and H.M were at the The Alan
Turing Institute for the Summer 2018 Internship Pro-
gramme, N. F and A. G. were at the The Alan Turing In-
stitute and Warwick University, and B. P at the The Alan
Turing Institute and UCL. All were supported by The Alan
Turing Institute under the EPSRC grant EP/N510129/1,

Figure 7: First and last line predictive accuracy of the
recurrent architecture on our test set with ﬁxed inputs.

large values.

Separately, we evaluate the performance of the recur-
rent neural network architecture, detailed in the ap-
pendix, over this diﬃcult set of examples. The same
RNN model was trained over sets generated with the
four diﬀerent methods, as for the feed-forward net-
works. We plot the fraction of times the RNN was
correct about the line appearing in the top-k predic-
tions for that line in Figure 7. We see that the last
line is easier to predict than the ﬁrst, for all data gen-
eration methods, matching the intuition that as more
functions are applied to the data, more information is
lost about lines that occurred earlier in the program.
Overall, when compared to baseline, some sets strug-
gle more than others, but much like the feed-forward
case, there is no strategy that has a commanding edge
over the others.

However, in longer programs than considered in this
paper, we imagine that the RNN architecture could
more substantially assist a search than the feed-

Technical report

and the UK Government’s Defence & Security Programme
in support of the Alan Turing Institute.

References

Balog, M., Gaunt, A. L., Brockschmidt, M., Nowozin,
S., and Tarlow, D. (2017). Deepcoder: Learning
to write programs. In International Conference on
Learning Representations.

Bunel, R., Hausknecht, M. J., Devlin, J., Singh, R.,
and Kohli, P. (2018). Leveraging grammar and re-
inforcement learning for neural program synthesis.
CoRR, abs/1805.04276.

Clarke, E. M., Grumberg, O., Jha, S., Lu, Y., and
Veith, H. (2003). Counterexample-guided abstrac-
tion reﬁnement for symbolic model checking. Jour-
nal of the ACM, 50(5):752–794.

de Moura, L. M. and Bjørner, N. (2008). Z3: an
eﬃcient SMT solver.
In International Conference
on Tools and Algorithms for the Construction and
Analysis of Systems, volume 4963 of Lecture Notes
in Computer Science, pages 337–340. Springer.

Devlin, J., Uesato, J., Bhupatiraju, S., Singh, R., Mo-
hamed, A., and Kohli, P. (2017). Robustﬁll: Neural
program learning under noisy i/o. In International
Conference on Machine Learning, pages 990–998.

Feng, Y., Martins, R., Bastani, O., and Dillig, I.
(2018). Program synthesis using conﬂict-driven
learning. In Conference on Programming Language
Design and Implementation, pages 420–435.

Godefroid, P., Klarlund, N., and Sen, K. (2005). Dart:
directed automated random testing. In ACM Sig-
plan Notices, volume 40, pages 213–223. ACM.

Gulwani, S., Harris, W. R., and Singh, R. (2012).
Spreadsheet data manipulation using examples.
Communications of the ACM, 55(8):97–105.

Hochreiter, S. and Schmidhuber, J. (1997). Long
short-term memory. Neural computation, 9(8):1735–
1780.

Parisotto, E., Mohamed, A., Singh, R., Li, L., Zhou,
D., and Kohli, P. (2016). Neuro-symbolic program
synthesis. In International Conference on Learning
Representations.

Shin, R., Kant, N., Gupta, K., Bender, C., Trabucco,
B., Singh, R., and Song, D. (2019).
Synthetic
datasets for neural program synthesis. In Interna-
tional Conference on Learning Representations.

Technical report

ties for each of the 34 functions, but now it is applied
across each line. The embedding layer in this network
is 50-dimensional, and the both the fully connected
layers and the LSTM have 200 hidden units. The re-
sult is a network which takes as arguments not just the
input / output examples, but also a target “number
of lines”, and then returns estimates of probabilities
that a function occurs on a per-line basis, rather than
program-wide.

Inﬂuence of the size of the training set

We investigated the eﬀect of training on 90%, 20%,
10% and 1% of the possible programs. All the experi-
ments here were done on programs of length (cid:96) = 3, us-
ing non-uniform sampling to generate the training and
test sets. Although we decrease the number of total
unique programs in the training sets, the total number
of examples remain ﬁxed for each set at n = 300000.
Although the later sets see less programs, they contain
more examples per program.

We observe in Figure 8 that the performance on top-k
prediction of the test set programs is not very sensitive
to the amount of programs in the test set. In light of
this fact, we choose to train with sets containing 10%
of the possible programs. This is good news, since
in most settings, valid input-output pairs would be
cheaper to generate than valid programs.

Details of Restricted Domain data generation
method

A value range for acceptable outputs is speciﬁed (ini-
tially [−255, 256]), as well as the maximum length of
the output if it is a list (the length is chosen uniformly
at random from one to ten). The program is evaluated
backwards, computing for each intermediate variable
a ‘safe’ range for its value that guarantees to have out-
puts in the target range.

By applying this backward propagation of bounds to
the whole program we ﬁnd a suitable input range. Val-
ues are then sampled uniformly from this range to cre-
ate the input(s), and the output is calculated by eval-
uating the program.
If the resulting valid range for
some input is empty or a singleton, then the program
is discarded.

The short program described in Figure 9 illustrates
the approach and a key limitation of it. The function
ScanL1(*) on list A outputs a list whose value at po-
sition k is the product Πk
i=0A[i]. For lists of length 5
the input range for ScanL1(*) that guarantees out-
puts between −256 and 256 is [−3, 3]. Pushing this
range back through Map(+1) gives a range for b of
[−4, 2], which is unchanged by Filter (%2==1).
In

Figure 8: Here we vary the total number of unique
programs in training sets and compare the resulting
network performance on a ﬁxed, semantically disjoint,
test set. All sets were generated on length (cid:96) = 3 pro-
grams with the non-uniform sampling method.

A Appendix

Speciﬁcs of neural network architectures
considered

The original DeepCoder network, summarized in de-
in the supplemental material of (Balog et al.,
tail
2017), takes as input 5 I/O pairs, padded to a ﬁxed
length. Each integer in the network inputs is sent
through a trainable embedding layer, represented as
20-dimensional real-valued vectors; these embeddings
are then concatenated together and passed through
three fully-connected layers of size 256. This yields
5 representations, one for each of the input/output
pairs input into the network; these are then averaged,
and passed as input into a ﬁnal sigmoidal activation
layer, which outputs the predicted probabilities of the
34 components appearing in the program. Note that
the branching factor for a search tree (e.g. depth-ﬁrst
search) is larger than 34, since the lines which contain
higher-order functions also require selection of one of
the predicate functions; for lines which have two func-
tions, the ranking order is determined by the smaller
probability.

In the recurrent neural network, a long short-term
memory (LSTM) network is added to produce a per-
line heuristic. Most of the architecture is unchanged:
as in the original DeepCoder model, the inputs and
outputs are sent through an embedding layer, con-
catenated, passed through three fully-connected lay-
ers, and then averaged across the ﬁve examples. How-
ever, instead of predicting the probabilities of inclusion
for each function directly, this representation is instead
provided as an input into the LSTM, which outputs a
new representation for each line of the program. As
before, a ﬁnal sigmoidal output layer emits probabili-

Technical report

Example program:
a ← [int]
b ← Filter (%2==1) a
c ← Map (+1) b
d ← ScanL1 (*) c

Example input, and incremental output:
a = [-200, 144, 25, 66, -7, 38, -1, 14, 80, 81, 155]
b = [25, -7, -1, 81, 155]
c = [26, -6, 0, 82, 156]
d = [26, -156, 0, 0, 0]

Figure 9: A program with complex restrictions on inputs that will remain in the target range

Figure 10: Marginal distribution over proposed integer
values in the non-uniform sampling.

fact any even number could be accepted as part of the
input, and if the input contains −1 at some point then
any value appearing subsequently in list can be large.

Non-uniform Sampling

The marginal distribution over sampled integer values
is shown in Figure 10.

A note about empty outputs Some programs in
the DSL output either null or the empty list on a
large number of outputs. While these are informative
to some extent, they dominated the examples gener-
ated for certain programs. The process of propagating
bounds through the program is focussed on the value
ranges and does not naturally exclude empty outputs.
For example, it is not possible to specify a range (other
than one containing only a single element) for inputs
to Filter(%2==0) that guarantees a non-empty out-
put. To ensure that empty outputs could not domi-
nate we included post processing for both sampling
methods which rejects empty outputs until 90% of the
permitted attempts have been made.

Details of Simple Constraint Based Data
Generation

Our training data was made up of 25 sets of 5 exam-
ples for each program. Due to the random choice of
minimum input length there are 6 versions of the ini-

Figure 11: Relative improvement to a search procedure
assisted by neural network predictions. The network
was trained on the Semantic Variation data, we see
how the loss in predictive performance is reﬂected in
increased search eﬀort

tial SMT problem. Subsequent SMT problems depend
on the previous examples produced but because subse-
quent calls to the solver vary only slightly the examples
generated can be very similar. We experimented with
randomly adding weak constraints such as setting the
ﬁrst element of an input to be odd or even or positive
or negative in order to modify the problem slightly for
each call to the solver, however for the experiments re-
ported here the data was produced without any such
random constraints and a few examples are indeed re-
peated across diﬀerent sets.

The Eﬀect of Neural Network Performance on
Search

Since the intention of training the neural network is to
use it to aid a search procedure, we ran a depth ﬁrst
search based on the predictions made by each network.
The cumulative time taken to complete the search by
each network is shown in Figure 11, showing the eﬀect
of reduced prediction accuracy on the time taken to
ﬁnd suitable programs. The network trained on simi-
lar data saved around one quarter of the total search
time across the test set over the worst performing net-
work. This shows how the beneﬁts of machine learning
to programming by example may be overstated when
only evaluated on “friendly” artiﬁcial data.

