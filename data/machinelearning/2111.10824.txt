1
2
0
2

v
o
N
1
2

]

A
M

.
s
c
[

1
v
4
2
8
0
1
.
1
1
1
2
:
v
i
X
r
a

A BLOCKCHAIN-BASED APPROACH FOR COLLABORATIVE
FORMALIZATION OF MATHEMATICS AND PROGRAMS

Jin Xing Lim
Singapore University of Technology and Design
jinxing_lim@mymail.sutd.edu.sg

Barnab√© Monnot
Ethereum Foundation
barnabe.monnot@ethereum.org

Shaowei Lin
shaowei@gmail.com

Georgios Piliouras
Singapore University of Technology and Design
georgios@sutd.edu.sg

ABSTRACT

Formalization of mathematics is the process of digitizing mathematical knowledge, which allows for
formal proof veriÔ¨Åcation as well as efÔ¨Åcient semantic searches. Given the large and ever-increasing
gap between the set of formalized and unformalized mathematical knowledge, there is a clear need
to encourage more computer scientists and mathematicians to solve and formalize mathematical
problems together. With blockchain technology, we are able to decentralize this process, provide
time-stamped veriÔ¨Åcation of authorship and encourage collaboration through implementation of
incentive mechanisms via smart contracts. Currently, the formalization of mathematics is done
through the use of proof assistants, which can be used to verify programs and protocols as well.
Furthermore, with the advancement in artiÔ¨Åcial intelligence (AI), particularly machine learning, we
can apply automated AI reasoning tools in these proof assistants and (at least partially) automate
the process of synthesizing proofs. In our paper, we demonstrate a blockchain-based system for
collaborative formalization of mathematics and programs incorporating both human labour as well as
automated AI tools. We explain how Token-Curated Registries (TCR) and smart contracts are used to
ensure appropriate documents are recorded and encourage collaboration through implementation of
incentive mechanisms respectively. Using an illustrative example, we show how formalized proofs of
different sorting algorithms can be produced collaboratively in our proposed blockchain system.

Keywords blockchain ¬∑ formalized mathematics ¬∑ veriÔ¨Åable programs ¬∑ token-curated registry ¬∑ smart contracts ¬∑
human-AI collaboration

1

Introduction

Formalization of mathematics is the process of digitizing mathematical knowledge into machine code so that proofs can
be formally and automatically checked and recorded within a computer system. This idea was initially proposed in the
QED manifesto [1] during the 1994 CADE conference and it is currently done through the means of proof assistants
such as Isabelle [2], Coq [3] and Lean [4]. Other than verifying mathematical proofs, proof assistants can also be
used to verify programs and protocols [5, 6]. With the rise of artiÔ¨Åcial intelligence, machine learning tools can be
implemented to aid us in automating, and hence, formalizing proofs partially [7]. However, as work in this area is still at
its early stage, it requires a lot of man-hours and collaboration to formalize the ever-growing mathematical knowledge
and programming world. Thus, this raises our driving challenge: to design a system architecture that decentralizes this
process and allows for effective collaboration between multiple intelligent agents towards formalization of mathematics
and programs.

The beneÔ¨Åts of decentralization, time-stamped veriÔ¨Åcation and smart contracts from blockchain provide us with a
platform that allows fast dissemination of problems and results, veriÔ¨Åed authorship and appropriate reward allocation of

 
 
 
 
 
 
A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

partial progresses respectively. Thus, there are various prior works, such as Qeditas [8], Mathcoin [9] and Proofgold1,
that discuss approaches on how computer scientists and mathematicians can share their completed work, and contribute
to the world of formalized mathematics through the use of blockchain. On the other hand, the Polymath project
[10], initiated by Timothy Gowers, is a project where mathematicians collaborate to solve difÔ¨Åcult and important
mathematical problems by sharing their partial results, presented as traditional ‚Äúhandwritten" proofs. However, to our
best knowledge, there is no system currently that combines these two ideas where participants (human or automated AI
tools) can collaborate to solve and formalize common problems.

To this end, we propose a blockchain-based architecture for formalizing mathematics and programs that allows
participants to share, not only completed, but also formalized partial results. Our system architecture can be broken
down into three interconnected layers: data layer (what is recorded?), client layer (what is meaningful?) and incentive
layer (what is rewarded?). We will discuss how Token-Curated Registries (TCR) [11, 12] are used to Ô¨Ålter document
submissions and how smart contracts are essential to implement incentive mechanisms to encourage participants to
come together and tackle common problems. The details and underlying mechanisms for each layer of our system are
described in Section 4. Furthermore, we provide a simple but illustrative algorithmic example in Section 5, where we
present how different sorting algorithms can be formalized2 collaboratively between human and automated AI tools
using our proposed blockchain-based system.

2 Formalized Proofs and Its Current State

Thanks to intuitionistic type theory [13] and the Curry-Howard correspondence [14], mathematical knowledge can be
written as code through the means of proof assistants, such as Isabelle [2], Coq [3] and Lean [4]. Such proofs are said to
be formalized. The main driving mechanism in proof assistants is the use of tactics for users to guide the proof engine
to derive the proofs interactively. The goal of a tactic is to break down complicated theorem statements into multiple
simpler statements that are hopefully easier to complete.

Other than having proofs formally and automatically veriÔ¨Åed by the proof assistants‚Äô proof systems, there are a lot of
efforts to formalize both existing and new mathematical knowledge due to several reasons, including:

VeriÔ¨Åed programs and protocols We can use proof assistants to formally verify programs, e.g., CompCert [15], and
protocols, e.g., CBC Casper protocol [16], as well. Moreover, with the extraction features, such as the one implemented
in Coq [17], one can even state a program speciÔ¨Åcation as a theorem statement and extract its proof as a working
program.

In proof assistants, we can write partial proofs - proofs with gaps, where parts of the proofs can
Proofs with gaps
be left empty for future completion by either the owner or someone else. We shall use the proof of the proposition,
sum_f irst_n, ‚àÄn ‚àà N, (cid:80)n
, as an illustration. The owner of Coq Ô¨Åle shown in Listing 1 created a
partial proof through the use of the induction tactic, and left the proofs of both base and inductive cases empty as
conjectures for future completion.

i=1 k = n(n+1)

2

Conjecture base_case : sum_to 0 = 0*(0+1)/2.

Conjecture ind_case: forall (n:nat), sum_to n = n*(n+1)/2 ‚Üí sum_to (S n) = S n*(S n+1)/2.

Theorem sum_first_n : forall (n:nat), sum_to n = n*(n+1)/2.
Proof. induction n. apply base_case. apply ind_case. trivial. Qed.

Listing 1: Partial proof of sum_Ô¨Årst_n viewed as a Coq Ô¨Åle

Automated AI tools There has been an increasing number of automated tools implemented for proof assistants, such
as Sledgehammer [18] (for Isabelle), TacticToe [19] (for HOL4 [20]), CoqHammer [21] and Tactician [22] (both for
Coq). These tools make use of machine learning methods such as k-NNs, RNNs and neural networks to help with the
proof searches. The goal of most of these tools is to have an automated proof search function that generates a proof
automatically given some theorem statement, and hence, ease the mathematicians‚Äô load in formalizing proofs.

1https://proofgold.org/
2For concreteness, we will be using Coq as our reference proof assistant, however, it can be replaced with any proof assistant

with similar functionality. The Coq codes in Section 5 can be found in https://github.com/jinxinglim/coq-chain.

2

A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

3 Related Works and Gaps

Through the use of blockchain, decentralization enables fast dissemination of information, allowing users to be notiÔ¨Åed
with Ô¨Årst-hand problems and state-of-the-art results. If users were to collaborate to formalize and solve a common
theorem statement, they do not need to worry about the authorship of their partial progresses due to the time-stamped
veriÔ¨Åcation provided by blockchain. Furthermore, with the use of smart contracts, one can trigger incentive mechanisms
to allocate rewards appropriately to encourage users to share their partial results and collaborate to solve a common
problem.

There are several prior projects such as Qeditas [8], Mathcoin [9] and Proofgold tackling the use of blockchain
technology to tie sources of formalized mathematics together in a decentralized way. Nevertheless, there are several
gaps that these projects do not address adequately and which we aim to improve upon:

Filtering submissions Documentation of formalized mathematical objects, i.e., deÔ¨Ånitions, theorem statements and
proofs, are organized in terms of libraries, such as the Mathematical Components library of Coq ssreÔ¨Çect [23] and
the Lean mathematical library, mathlib [24]. To be documented in any of these libraries, experts from the respective
community will determine whether each submitted document fulÔ¨Ålls certain criteria. Yet, in a decentralized system,
there will be no ‚Äúexpert‚Äù to Ô¨Ålter out submissions. Qeditas suggested strategies such as inclusion of ‚Äúsalted‚Äù documents
and having fees proportionate to the size of the submitted documents to deter duplicate submissions. Having said that,
to Ô¨Ålter out novel, non-duplicate and relevant work from the rest, we believe a much stronger mechanism needs to be in
place so that the decentralized library will be streamlined. Our approach featuring a TCR allowing users to accept or
reject a given submission would be particularly useful, but has not been discussed in any of the prior works.

Collaborative work Although there are several useful ideas suggested by these prior projects to incentivize users to
formalize proofs, such as rewarding ownership as intellectual property, bounties and token betting, there has been little
to no mention of the use of smart contracts to implement complex incentive mechanisms to split rewards appropriately
to collaborators. With the right incentive mechanism in place and the ability to leave proofs with gaps as mentioned in
Section 2, we aim to reward contributors for completed as well as partial results. Contributors need not worry about the
authorship of their partial work due to the time-stamped veriÔ¨Åcation provided by blockchain, serving as a motivation for
them to submit partial, incomplete results and formalize proofs collaboratively.

Automated AI tools‚Äô participation None of prior projects mention about the involvement of automated AI tools,
which are discussed in Section 2. Some of these automated tools require high computing power to produce better
automated proof searches. Developers could deploy these tools as nodes in the blockchain environment to look for
conjectures to solve instead of requiring users to have the necessary computing capabilities in order to use them.
Automated tools, such as TacticToe [19] and Tactician [22], show that there is a drift towards implementing incremental
proof construction [25], i.e., suggesting the next best proof step instead of automating the whole proof of a given
theorem statement. These tools could help human provers by suggesting the ‚Äúnext best move" in their proofs, facilitating
collaboration between human and machines. In the future, once these automated tools reach a certain efÔ¨Åciency level,
different tools could even come together through this blockchain environment to generate the proofs, with little to no
human intervention, as an uniÔ¨Åed proof synthesizer.

4 System Architecture

We assume the availability of a public, programmable blockchain, where smart contracts are deployed. We call prover an
account (or address) on the blockchain participating in the protocol. A human or AI participant (prover using automated
AI tool) may operate several prover accounts. For simplicity, we consider the case where one entity corresponds to one
prover only. Our system architecture can be broken down into three interconnected layers: A) the data layer (what is
recorded?), B) the client layer (what is meaningful?) and C) the incentive layer (what is rewarded?). Fig. 1 shows a
Ô¨Çowchart of how a prover‚Äôs contribution gets recorded and eventually rewarded in our blockchain system across these
three layers. The types of smart contracts and the need of bootstrapping our system with some initial library are also
discussed at the end of this section.

4.1 Data layer

The data layer is composed of two elements: a deployed smart contract on the blockchain, registry, and a decentralized
Ô¨Åle storage.

3

A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

Figure 1:
blockchain system across
https://en.wikipedia.org/wiki/InterPlanetary_File_System,
news/token-curated-registries-william-entriken/,
business-model-pay-per-use/

Flowchart of how a prover‚Äôs contribution gets recorded and eventually rewarded in our
IPFS -
https://0xcert.org/
https://reasonstreet.co/

the three layers of our

system architecture.

Images‚Äô
-

right-to-use

TCR
-

sources:

The registry accepts records written by provers. A record contains minimal information to identify a unique contribution.
A contribution consists of a Coq Ô¨Åle kept in the storage, while the record contains as an attribute the address of the
contribution.

We suggest the use of decentralized Ô¨Åle storage such as IPFS [26]. Clients running the IPFS protocol publish content
(such as the Coq .v Ô¨Åles) over the IPFS network. The content is addressed by a unique hash, a random string of
characters, obtained by hashing the Ô¨Åle content. Other IPFS clients interested in the content will request it by its hash
to other peers on the network, until they obtain the Ô¨Åle from a peer who is hosting it. The design pattern of hosting
longer-form content, such as text, code or media over IPFS while referencing the hash in a blockchain transaction has
become commonplace. While not guaranteeing availability (a Ô¨Åle could either be missing or held ofÔ¨Çine), it is sufÔ¨Åcient
for just one party holding the Ô¨Åle to be online for it to be available.

4.2 Client layer

The data layer accepts any record and contribution. However, contributions that contain syntactically incorrect code
must be disregarded by users of the protocol. The data layer cannot run the checks required to decide whether a
contribution is valid or not, as it would have to run the Coq interpreter to Ô¨Ånd out the validity of the code. While this is
theoretically possible in a Turing-complete environment, the cost of such operation would be prohibitively high.

The protocol also needs to deal with the issue of spam and duplicates. Contributions of dubious quality may well be
registered, as well as identical copies of previous statements, copies aggregating multiple previous contributions or
copies with refactored variable names. Heuristics may be developed to ‚ÄúÔ¨Çag‚Äù copies by comparing their Coq types
against previously published contributions, a Ô¨Årst step towards creating a canonical registry.

To increase the importance of novel and useful contributions over duplicates and tautological statements, we add an
incentive for provers in the protocol to vote on the inclusion of newly registered statements into the canonical registry.
This incentive is deployed as a Token-Curated Registry (TCR) [11, 12], a smart contract where provers stake some
amount of tokens (becoming bonded provers) to earn the right of voting in or voting out contributions from the canonical
registry.

4

Incentive layerClient layerData layerHuman proverAI proverORCoq fileStored in IPFS to obtain hash addressContribution registry:Smart contract to record necessary metadataRecorded in blockchainTCR contract:VotingCanonical registryCoq plug-inTrueTrueTrueTrueClientùê∂ùê∂New entry by human proverString diagramof contributionsClient interfaceIncentive contract/s:Smart contract from client ùê∂ùê∂to trigger incentive mechanismonce proof is completedAppropriate token distribution from the incentive mechanism(larger coin ‚áímore tokens in figure)Licensing sublayerClient ùê∂ùê∂/Usercan set the right-to-use: free, restrictedor pay-to-usePartial contributionsA Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

Provers may adopt the role of contributors or curators, the former when they add a record to the registry, the latter when
they vote on the inclusion of a record to the canonical registry. As contributors, provers attach an inclusion stake along
with their record. Any prover may challenge the inclusion of the record to the canonical registry by posting a dispute
stake. As curators, provers are rewarded for voting on the correct outcome, determined by a majority rule, in the event
of a challenge. If the record is voted out, the challenger receives part of the inclusion stake, while the remainder is
divided among voters who rejected the record. If the record is voted in, the dispute stake of the challenger is lost to the
contributor and curators who voted to include the record. Bonded provers may choose to participate in a vote or not.
After some delay period, either the record enters the canonical registry unchallenged, or following a successful vote in
favor of inclusion.

Although ‚Äúcanonical‚Äù appears to refer to a binary property, in effect a quantitative measure of weight distinguishes
one contribution from another, as a varying number of curators engage in the voting process for each incoming record.
Uncontroversial inclusion ought to bring more positive votes from curators, who need not expend a lot of time to
identify novelty or usefulness, as would uncontroversial rejection, e.g., in the case of an invalid Coq code, which is also
trivial to detect assuming provers run a Coq client themselves.

The client layer is responsible for presenting the current state of the canonical registry to the prover, as an interface to the
data layer. Essentially, the client layer could function as a plug-in to popular Coq editors/interpreters, allowing provers
to maintain and track the contributions they are working with, associated with their weights to provide contextual
information on their validity, novelty and usefulness. The client layer additionally runs the Coq engine to decide on the
validity of a contribution, as well as heuristics on the Coq types of the statement to determine their potential novelty.
These checks allow the bonded validators to input their votes to the TCR via the client layer.

The client remains loosely coupled with the data layer. Any interface capable of reading data from the registry, verifying
validity of the contributions and publishing progress to the registry functions as a client, allowing for diversity in
implementations and features. For instance, a protocol for provers to include metadata in their contribution, e.g., as a
header in the Coq Ô¨Åle. Metadata include compatibility with Coq versions, contribution type (theorem, proof, ...), as
well as imports. For imports of previous contributions, the client holds a string diagram (more details and examples
in Section 5) , linking a contribution to its ancestors. This string diagram could provide the structure necessary for
the deÔ¨Ånition of incentives explored in the next section. In a future iteration, it may be possible to compose the TCR
instantiation described above with the contextual information received from the string diagram of proofs, akin to the
citation graph of Ito and Tanaka [27]. Contributions building on previously registered items would then add weight to
their ancestors, indirectly recognising their usefulness and/or novelty.

4.3

Incentive layer

The data layer and the client layer ensure consensus over the canonical registry. Consistent with our modular architecture,
the incentive layer is once again loosely coupled with the previous client layer.

The incentive layer is a set of incentive mechanisms, embodied by smart contracts. Any entity may deploy an incentive
mechanism, either of their own conception or from existing templates.

We start with the simplest possible template, a Ô¨Åxed prize payment for the completion of a single proof. In this scenario,
an entity deploys a smart contract holding the prize, with a single signer (‚Äúowner‚Äù) deciding to offer the prize to
a contribution that formally proves the proposed statement. The mechanism records the identiÔ¨Åer of the winning
contribution and the author of the contribution receives the prize money.

The previous template requires trust assumptions on the signer deciding on the winner. It is easily extended to a
multisignature implementation, where some set of signers must approve the winner before the prize money is unlocked.
Further, it may be extended to the whole set of bonded provers.

More complex incentive systems may be added later on in a compatible manner, as long as they make reference to the
original contribution string diagram. For instance, staking tokens on some branch of partial progress from a statement
could entitle stakers to a share of future rewards obtained should that branch terminate with a proof of the statement,
with the Ô¨Ånal prover earning a larger share in proportion to the amount staked. Via this partial ownership, stakers are
rewarded for detecting promising branches, while provers are induced to progress on these promising branches.

Licensing sublayer

Up to this point, we have addressed how we can implement incentive mechanisms via smart contracts to encourage
provers to collaborate and solve common open conjectures. This leads to the next question: how can we incentivize
users to post new formalized deÔ¨Ånitions, theorems with completed proofs and tactics? To answer this, we will have
a licensing sublayer that allows the author to set the right-to-use for each of his or her formalized object. This idea

5

A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

was introduced in one of the prior works, Qeditas [8], where the right-of-use can be categorized into three types of
uses - free-to-use (free to use without payment), restricted-to-use (unable to use at all) and pay-to-use (pay some x
tokens in order to use). The rights are set to free-to-use by default, and any change to this setting will have to be done
by the author. We include this sublayer within the incentive layer as rewards in terms of payments can be involved to
the authors of completed objects.

Smart Contracts

Several types of smart contracts are available for the users in our blockchain system:

Contribution registry A contract, registry, stores records of contributions, including their necessary metadata
such as IPFS hash address, Coq versions, contribution type (conjecture, theorem, proof, ...), imports and right-to-use.
Examples of how they may look like are shown as ct00Cont, ct01Cont and ct02Cont in Section 5.

Incentive contracts These contracts implement incentive mechanisms to distribute tokens to a prover or a group of
provers based on their contributions and their payout rules. An example is provided as iCont00 in Section 5.

TCR contract A contract deploys TCR voting mechanism to determine the weight supporting inclusion in the
canonical registry of some contribution, detailed in Section 4.2.

Bootstrapping

The registry is easily bootstrapped with the current Coq standard library, providing the foundation for new proofs and
tactics to be added to the registry. In addition, to decentralize further inputs to the TCR voting mechanism, initial
allocation of voting tokens may be done with respect to the amount of work provided on the Coq library itself as well as
contemporary work on proof and tactics.

5 An Illustrative Example

We will assume that the documents in the Coq standard library are already stored in IPFS. For simplicity, we will use
0x0file to represent the hash address of the Coq Ô¨Åle, file.v, in IPFS.

Suppose a prover, client C, starts a new project to Ô¨Ånd proof/s of the speciÔ¨Åcation of a sorting program as a conjecture
through the Coq script, ct00.v, as shown in Listing 2.

Require Export Arith Sorted Permutation List.
Export List.ListNotations.
Open Scope list_scope.

Definition sorted := Sorted le.
Definition permutation := ¬∑Permutation nat.

Conjecture sort_prog :

forall (l:list nat), {l‚Äô: list nat | sorted l‚Äô ‚àß permutation l‚Äô l}.

Listing 2: Coq script of ct00.v

C will upload the Ô¨Åle in IPFS and get its hash address, 0x0ct00, and create a contract, ct00Cont, that records the
conjecture, its necessary metadata and incentive contract, iCont00, as shown in Listing 3. If the proof of sort_prog is
completed by a set of Provers, iCont00 will run the pre-deÔ¨Åned allocation function to measure the weights of the
contributions and allocate the TokenReward appropriately. Otherwise, all the TokenReward will be transferred to the
unique prover.

contract iCont00 {

...
// reward to set of provers , Provers , with reward , TokenReward
reward ( list Provers ) public {

require ( verify ( sort_prog ) == true ) ;
if ( length ( Provers ) == 1) {

transfer ( Provers , TokenReward ) ;

}

6

A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

else {

// weightage of rewards will based on allocation fn
weights = allocation ( sort_prog ) ;
allocate ( Provers , weights , TokenReward ) ;

}

}
...

}

contract ct00Cont is registry {

...
file = " 0 x0ct00 " ;
CoqVer = " 8.12 " ;
filetype = " Conjecture " ;
imports =[ " 0 x0Arith " ," 0 x0Sorted " ," 0 x0Permutation " ," 0 x0List " ];
// Activate Icont00 to set of provers = Provers
iCont00 ( Provers , TokenReward ) ;
...

}

Listing 3: Pseudo-code example of ct00Cont and iCont00

At the client interface, C can do any validity check that cannot be done in the data layer through the Coq plug-in editor
and a string diagram can be presented for C to track any progression of the conjecture, as shown in Fig. 2.

Figure 2: String diagram representing partial proof of sort_prog. Strings (arrows) represent the theorems, solid circles
represent completed subproofs and dotted circles represents incomplete subproofs (proof gaps). The goal is to complete
all paths to the trivial theorem True from the desired theorem sort_prog.

After ct00Cont is posted in the blockchain system, human prover P is the Ô¨Årst one to provide a partial proof of
sort_prog via the Coq script, ct01.v, as shown in Listing 4. He initiates the proof by using induction and leaves both
the base case and inductive case empty. He uploads this Ô¨Åle in IPFS and record a ct01Cont entry as shown in Listing 5.

Require Export ct00.

Conjecture sort_base : {l‚Äô : list nat | sorted l‚Äô ‚àß permutation l‚Äô []}.

Conjecture sort_prog_IH : forall (a : nat) (l x : list nat), sorted x ‚Üí permutation x l

‚Üí {l‚Äô : list nat | sorted l‚Äô ‚àß permutation l‚Äô (a :: l)}.

Lemma sort_prog :

forall (l : list nat), {l‚Äô : list nat | sorted l‚Äô ‚àß permutation l‚Äô l}.

Proof. induction l. apply sort_base. destruct IHl; destruct a0; eapply sort_prog_IH; eassumption. Qed.

Listing 4: Coq script of ct01.v

contract ct01Cont is registry {

...
file = " 0 x0ct01 " ;
CoqVer = " 8.12 " ;
filetype = " PartialProof " ;
imports =[ " 0 x0ct00 " ];
...

}

Listing 5: Pseudo-code example of ct01Cont

7

A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

After which, C and other users will get a notiÔ¨Åcation through the client interface, which shows an update in the string
diagram of Fig. 2, as shown in Fig. 3.

Figure 3: Update in the string diagram shown in Fig. 2 after P uploads ct00.v entry.

At this point, the unsolved conjectures are sort_prog, sort_base and sort_prog_IH. An AI prover, A, using automated
AI tool, say Coqhammer [21], will try to automate the proofs for these three conjectures. Although it only manages
to automate the proof of sort_base, it records its attempts via the Coq script, ct02.v (Listing 6) and a ct02Cont entry
(Listing 7) in the system. The client interface will then update the progress in the string diagram shown in Fig. 3, as
shown in Fig. 4.

Require Import ct01.
From Hammer Require Import Hammer.

Lemma sort_prog : forall (l : list nat), {l‚Äô : list nat | sorted l‚Äô ‚àß permutation l‚Äô l}.
Proof. Fail hammer. Abort.

Lemma sort_base : {l‚Äô : list nat | sorted l‚Äô ‚àß permutation l‚Äô []}.
Proof. hammer. Defined.

Lemma sort_prog_IH : forall (a : nat) (l x : list nat), sorted x ‚Üí permutation x l

‚Üí {l‚Äô : list nat | sorted l‚Äô ‚àß permutation l‚Äô (a :: l)}.

Proof. Fail hammer. Abort.

Listing 6: Coq script of ct02.v

contract ct02Cont is registry {

...
file = " 0 x0ct02 " ;
CoqVer = " 8.12 " ;
filetype = " CompletedProof " ;
imports =[ " 0 x0ct01 " ];
...

}

Listing 7: Pseudo-code example of ct02Cont

Eventually all subproofs will be completed, i.e., no more dotted circles between sort_prog and True, through the
collaboration of contributions from both human provers and automated AI tool/s as shown in Fig. 5. The completed
proof from this network of subproofs is essentially a veriÔ¨Åcation proof of an insertion sort algorithm.

Once this is achieved, the reward function in iCont00 will be triggered to allocate each contribution, seen in Fig.
5, with the appropriate rewards based on the allocation function. It is important to have the right allocation rule
such that it would encourage each prover to share his or her partial result immediately instead of withhold any partial
progress and release only when he or she completes the whole proof. For the existence of such allocation rule, one can
implement, for example, the mechanism discussed by Banerjee et al [28]. Measuring of the weights in any allocation
rule may involve the use of TCR as mentioned in Section 4.

8

A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

Figure 4: Update in the string diagram shown in Fig. 3 after A uploads ct02.v entry. We use green circles to represent
entry from automated AI tools.

Figure 5: Collaboration of contributions from human provers and automated AI tool/s that yields a proof of insertion
sort algorithm.

Besides insertion sort, there are many different sorting algorithms, including merge sort, quick sort, etc. Unlike in
mathematics, where it is sufÔ¨Åcient to have one proof for each theorem, different proofs for a speciÔ¨Åcation of a program
may yield algorithms with different efÔ¨Åciencies. Thus, it is important to implement incentive mechanism/s via smart
contract/s to encourage users to produce different proofs collaboratively as well. For example, C could implement an
incentive mechanism similar to what was studied by Babaioff et al. [29] via a smart contract. That is, C will reward
the Ô¨Årst completed proof with TokenReward, followed by the second completed proof with TokenReward/2, then the
third completed proof with TokenReward/4 and so on. This mechanism of halving the TokenReward for each completed
proof will eventually cost C a maximum of 2√óTokenReward.

As a result, another prover T is motivated to create an alternative proof to sort_prog, which will eventually lead
to a proof of merge sort algorithm. This can be done by Ô¨Årst, creating a new tactic, div_conq_split, which is a
formalization of the divide-and-conquer algorithmic paradigm, in the Coq Ô¨Åle ct04.v (Listing 8). The Ô¨Åle is uploaded in
the IPFS network and records an ct04Cont entry (Listing 9). This entry will state that anyone who wishes to use the
div_conq_split tactic needs to pay a fee of some x token/s. This is done as the tactic can be used to prove any property
of lists other than the sort_prog.

Require Export Arith List.
...
Theorem div_conq_split : forall (P:list A ‚Üí Type),

9

A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

P nil
‚Üí (forall (a:A), P(a:: nil))
‚Üí (forall (ls:list A), P fst(split ls) ‚Üí P snd(split ls) ‚Üí P ls
‚Üí forall (l : list A), P l.

Proof.
...

Listing 8: Snippet of Coq script of ct04.v

contract ct04Cont is registry {

...
file = " 0 x0ct04 " ;
CoqVer = " 8.12 " ;
filetype = " Tactic " ;
imports =[ " 0 x0Arith " ," 0 x0List " ];
right_to_use = pay_to_use ([( " div_conq_split " ,x ) ]) ;
...

}

Listing 9: Pseudo-code example of ct04Cont

After which, T ‚Äôs tactic, div_conq_split, instead of induction as used in ct01.v, can be used to initiate an alternative
proof via ct05.v (Listing 10).

Require Export ct00 ct02 ct04.

Conjecture sort_prog_one : forall a : nat, {l‚Äô : list nat | sorted l‚Äô ‚àß permutation l‚Äô [a]}.

Conjecture sort_prog_split : forall (ls l‚Äô l‚Äô0: list nat), sorted l‚Äô0 ‚Üí permutation l‚Äô0 (fst (split nat ls))

‚Üí sorted l‚Äô ‚Üí permutation l‚Äô (snd (split nat ls)) ‚Üí {l‚Äô1 : list nat | sorted l‚Äô1 ‚àß permutation l‚Äô1 ls}.

Lemma sort_prog : forall (l : list nat),

{l‚Äô : list nat | sorted l‚Äô ‚àß permutation l‚Äô l}.

Proof. div_conq_split. apply sort_base. apply sort_prog_one. intros; destruct H; destruct a;
destruct H0; destruct a; eapply sort_prog_split. exact H. eassumption. exact H0. eassumption. Qed.

Listing 10: Coq script of ct05.v

Once T uploads the contribution of ct05.v to the system, C and the rest of the users will be notiÔ¨Åed of a new string
diagram presentation of the alternative proof as shown in Fig. 6.

Figure 6: New string diagram representation of the alternative proof presented in ct05.v. Note that sort_base is solved
as T imported and used the result from ct02.v.

Suppose the insertion sort‚Äôs proof (Fig. 5) is completed before the merge sort‚Äôs proof. Once the latter proof is completed,
the incentive mechanism will trigger and distribute TokenReward/2 appropriately to all the contributors in Fig. 7 as it is
the second completed proof.

10

A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

Figure 7: Collaboration of contributions from human provers and automated AI tool/s that yields a proof of merge sort
algorithm.

6 Conclusion and Future Directions

In our paper, we propose a blockchain-based approach to allow agents, human provers and automated AI systems, to
formalize mathematics and programs collaboratively through the means of some proof assistants such as Coq. We
broke down our system architecture into three dependent layers. The data, client and incentive layers describe what
information is to be recorded, to be deemed as meaningful and to be rewarded respectively. We differentiate our work
from the prior projects through i) the use of TCR to vote contributions in or out from the canonical registry, ii) smart
contracts to implement incentive mechanisms to encourage both collaboration within the same proof and diversiÔ¨Åcation
of proofs, and iii) inclusion of automated AI tools. Moving forward, there are several directions we are looking to
improve and decide upon before the implementation of our proposal:

6.1 Game theory of incentive mechanisms

The Ô¨Çexibility of implementing complex incentive mechanisms via smart contracts allows us to reward the contributions
within a proof and across different proofs appropriately. Thus, it is important to have the right incentive mechanism/s to
encourage users to not only generate a single proof but also multiple proofs of a common problem collaboratively in a
decentralized manner. Other than the incentive mechanisms mentioned in Section 5 [28, 29], a game theoretical study
on incentive mechanisms would provide us different ways to reward contributors appropriately.

It is natural to model the process of formalizing proofs collaboratively as a cooperative game where the contribution
graph encodes the current state of knowledge and progress across a wide variety of open problems. Thus, it can be
assigned a global value that can be captured natively in the system via publicly trade-able tokens. In any such cooperative
game, the overall system value can be distributed amongst its contributors using, e.g., the Shapley value distribution
rule [30]. The Shapley value distribution rule has a number of well known and desirable axiomatic properties. For
example, it is budget balanced3 meaning that the sum of the agents‚Äô payoffs is equal to the global value of the system.
Moreover, it is the unique distribution rule that is efÔ¨Åcient, symmetric, additive, and assigns zero payoffs to dummy
players. Finally, recent works have pointed out that within the set of budget balanced rules, it is effectively optimal
[31, 32, 33].

6.2 Usage of tokens

There can be two usages of the tokens generated for our blockchain. First, they can be used as a virtual currency purely
to measure the contributions a user has made in the world of formalized mathematics and programs. This is analogous

3Sometimes this property is referred to as efÔ¨Åciency.

11

A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

to the h-index [34] to measure the productivity of a researcher‚Äôs publications. Second, they can be exchanged for
actual currencies, e.g., USD. This approach gamiÔ¨Åes the process of formalization through monetary rewards, and hence,
attracts more users to take part. The decision to use tokens as ‚Äúscores‚Äù or as monetary incentive may depend on the
community participating in our protocol.

Acknowledgments

This research/project is supported in part by the National Research Foundation, Singapore under its AI Singapore
Program (AISG Award No: AISG2-RP-2020-016), NRF 2018 Fellowship NRF-NRFF2018-07, NRF2019-NRF-
ANR095 ALIAS grant, grant PIE-SGP-AI-2018-01, AME Programmatic Fund (Grant No. A20H6b0151) from the
Agency for Science, Technology and Research (A*STAR) and the Ethereum Foundation.

References

[1] Robert Boyer. The qed manifesto. Automated Deduction‚ÄìCADE, 12:238‚Äì251, 1994.
[2] Makarius Wenzel, Lawrence C Paulson, and Tobias Nipkow. The isabelle framework. In International Conference

on Theorem Proving in Higher Order Logics, pages 33‚Äì38. Springer, 2008.

[3] Yves Bertot. A short presentation of coq. In International Conference on Theorem Proving in Higher Order

Logics, pages 12‚Äì16. Springer, 2008.

[4] Leonardo de Moura, Soonho Kong, Jeremy Avigad, Floris Van Doorn, and Jakob von Raumer. The lean theorem
prover (system description). In International Conference on Automated Deduction, pages 378‚Äì388. Springer,
2015.

[5] Jean-Christophe Filli√¢tre. Deductive software veriÔ¨Åcation. International Journal on Software Tools for Technology

Transfer, 13(397), 2011.

[6] Ilya Sergey, James R Wilcox, and Zachary Tatlock. Programming and proving with distributed protocols.

Proceedings of the ACM on Programming Languages, 2(POPL):1‚Äì30, 2017.

[7] Yaqing Jiang, Petros Papapanagiotou, and Jacques Fleuriot. Machine learning for inductive theorem proving. In
International Conference on ArtiÔ¨Åcial Intelligence and Symbolic Computation, pages 87‚Äì103. Springer, 2018.

[8] B White. Qeditas: A formal library as a bitcoin spin-off (2016). URL http://qeditas.org/docs/qeditas.pdf, 2016.
[9] Borching Su. Mathcoin: A blockchain proposal that helps verify mathematical theorems in public. IACR Cryptol.

ePrint Arch., 2018:271, 2018.

[10] Tim Gowers. Is massively collaborative mathematics possible?, Jan 2009.

[11] Mike Goldin.

Token-curated registries 1.0.

https://docs.google.com/document/d/1BWWC_

_-Kmso9b7yCI_R7ysoGFIT9D_sfjH3axQsmB6E/edit, 2017. Accessed: 2021-01-20.

[12] Aditya Asgaonkar and Bhaskar Krishnamachari. Token curated registries-a game theoretic approach. arXiv

preprint arXiv:1809.01756, 2018.

[13] Per Martin-L√∂f and Giovanni Sambin. Intuitionistic type theory, volume 9. Bibliopolis Naples, 1984.
[14] William A Howard. The formulae-as-types notion of construction. To HB Curry: essays on combinatory logic,

lambda calculus and formalism, 44:479‚Äì490, 1980.

[15] Xavier Leroy, Sandrine Blazy, Daniel K√§stner, Bernhard Schommer, Markus Pister, and Christian Ferdinand.
Compcert-a formally veriÔ¨Åed optimizing compiler. In ERTS 2016: Embedded Real Time Software and Systems,
8th European Congress, 2016.

[16] Elaine Li, Traian SerbÀòanutÀòa, Denisa Diaconescu, Vlad ZamÔ¨År, and Grigore Rosu. Formalizing correct-by-
construction casper in coq. In 2020 IEEE International Conference on Blockchain and Cryptocurrency (ICBC),
pages 1‚Äì3. IEEE, 2020.

[17] Jean-Christophe Filli√¢tre and Pierre Letouzey. Functors for proofs and programs. In European Symposium on

Programming, pages 370‚Äì384. Springer, 2004.

[18] Jia Meng, Claire Quigley, and Lawrence C Paulson. Automation for interactive proof: First prototype. Information

and computation, 204(10):1575‚Äì1596, 2006.

[19] Thibault Gauthier, Cezary Kaliszyk, and Josef Urban. Learning to reason with hol4 tactics. arXiv preprint

arXiv:1804.00595, 2018.

12

A Blockchain-Based Approach for Collaborative Formalization of Mathematics and Programs

[20] Konrad Slind and Michael Norrish. A brief overview of hol4. In International Conference on Theorem Proving in

Higher Order Logics, pages 28‚Äì32. Springer, 2008.

[21] ≈Åukasz Czajka and Cezary Kaliszyk. Hammer for coq: Automation for dependent type theory. Journal of

automated reasoning, 61(1-4):423‚Äì453, 2018.

[22] Lasse Blaauwbroek, Josef Urban, and Herman Geuvers. The tactician. In International Conference on Intelligent

Computer Mathematics, pages 271‚Äì277. Springer, 2020.

[23] Georges Gonthier and Assia Mahboubi. An introduction to small scale reÔ¨Çection in coq. Journal of formalized

reasoning, 3(2):95‚Äì152, 2010.

[24] The mathlib Community. The lean mathematical library. In Proceedings of the 9th ACM SIGPLAN International
Conference on CertiÔ¨Åed Programs and Proofs, CPP 2020, page 367‚Äì381, New York, NY, USA, 2020. Association
for Computing Machinery.

[25] Lawrence Charles Paulson. Machine learning and the formalisation of mathematics: Research challenges. Invited

talk at 5th Conference on ArtiÔ¨Åcial Intelligence and Theorem Proving (AITP 2020), 2020.

[26] Juan Benet. Ipfs-content addressed, versioned, p2p Ô¨Åle system. arXiv preprint arXiv:1407.3561, 2014.
[27] Kensuke Ito and Hideyuki Tanaka. Token-curated registry with citation graph. arXiv preprint arXiv:1906.03300,

2019.

[28] Siddhartha Banerjee, Ashish Goel, and Anilesh Kollagunta Krishnaswamy. Re-incentivizing discovery: mecha-
nisms for partial-progress sharing in research. In Proceedings of the Ô¨Åfteenth ACM conference on Economics and
computation, pages 149‚Äì166, 2014.

[29] Moshe Babaioff, Shahar Dobzinski, Sigal Oren, and Aviv Zohar. On bitcoin and red balloons. In Proceedings of

the 13th ACM conference on electronic commerce, pages 56‚Äì73, 2012.

[30] Lloyd S Shapley. A value for n-person games,[in:] kuhn hw and tucker aw. Contributions to the Theory of Games

II, pages 307‚Äì317, 1953.

[31] Shahar Dobzinski, Aranyak Mehta, Tim Roughgarden, and Mukund Sundararajan. Is shapley cost sharing optimal?

Games and Economic Behavior, 108:130‚Äì138, 2018.

[32] Vasilis Gkatzelis, Konstantinos Kollias, and Tim Roughgarden. Optimal cost-sharing in general resource selection

games. Operations Research, 64(6):1230‚Äì1238, 2016.

[33] Matthew Phillips and Jason R Marden. Design tradeoffs in concave cost-sharing games. IEEE Transactions on

Automatic Control, 63(7):2242‚Äì2247, 2017.

[34] Jorge E Hirsch. An index to quantify an individual‚Äôs scientiÔ¨Åc research output. Proceedings of the National

academy of Sciences, 102(46):16569‚Äì16572, 2005.

13

