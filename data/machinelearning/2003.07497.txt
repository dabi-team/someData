Towards High Performance, Portability, and
Productivity: Lightweight Augmented Neural
Networks for Performance Prediction

Ajitesh Srivastava∗§ Naifeng Zhang∗§ Rajgopal Kannan† and Viktor K. Prasanna∗
∗University of Southern California
{ajiteshs,naifengz,prasanna}@usc.edu
†US Army Research Lab-West
rajgopal.kannan.civ@mail.mil

0
2
0
2

g
u
A
0
3

]
F
P
.
s
c
[

2
v
7
9
4
7
0
.
3
0
0
2
:
v
i
X
r
a

Abstract—Writing high-performance code requires signiﬁcant
expertise in the programming language, compiler optimizations,
and hardware knowledge. This often leads to poor productivity
and portability and is inconvenient
for a non-programmer
domain-specialist such as a Physicist. More desirable is a
high-level language where the domain-specialist simply speciﬁes
the workload in terms of high-level operations (e.g., matrix-
multiply(A, B)), and the compiler identiﬁes the best implemen-
tation fully utilizing the heterogeneous platform. For creating a
compiler that supports productivity, portability, and performance
simultaneously, it is crucial to predict the performance of various
available implementations (variants) of the dominant operations
(kernels) contained in the workload on various hardware to
decide (a) which variant should be chosen for each kernel in
the workload, and (b) on which hardware resource the variant
should run. To enable the performance prediction, we propose
lightweight augmented neural networks for arbitrary combina-
tions of kernel-variant-hardware. A key innovation is utilizing the
mathematical complexity of the kernels as a feature to achieve
higher accuracy. These models are compact to reduce training
time and fast inference during compile-time and run-time. Using
models with less than 75 parameters, and only 250 training data
instances, we are able to obtain a low MAPE of 3%, signiﬁcantly
outperforming traditional feed-forward neural networks on 48
kernel-variant-hardware combinations. We further demonstrate
that our variant-selection approach can be used in Halide
implementations to obtain up to 1.7x speedup over Halide’s auto-
scheduler.

Index Terms—Lightweight augmented neural networks, Per-
formance prediction, Productivity, Portability, Compiler, Hetero-
geneous Platforms

I. INTRODUCTION

With various heterogeneous technologies emerging today,
there have been unprecedented opportunities for accelerating
applications. Application-speciﬁc integrated circuits (ASICs)
[1] provide highly specialized implementations but require
expertise in implementation and are specialized for one appli-
cation. On the other hand, CPUs, GPUs, and FPGAs provide
more ﬂexibility and are easier to program, but are much slower
compared to ASICs. Providing the ﬂexibility in applications
and ease of implementation while reaching the speedup offered

§Equal contribution

by ASICs has been the focus of many recent works [2],
[3]. Even writing a CPU/GPU code to get most out of
available hardware requires programming expertise, hardware
knowledge, and time. Further, that optimized code may not
be “portable”, i.e., may not work well on a different platform.
Finally, a domain-specialist such as a physicist is expected
to know the operations involved in their workload, but not
the details of their highly-optimized implementations. This is
important for “productivity”, i.e., implementing the desired
workﬂow with few lines of code, not worrying about the code
optimizations.

With the objective of achieving high performance, porta-
bility, and productivity, we are building a compiler that exe-
cutes a high-level domain-speciﬁc language on heterogeneous
platforms aligned with recent DARPA projects [4]. The user
will write a high-level code that can be broken down in
high-level operations (matrix multiplication, convolution, etc.),
we call kernels. The user only speciﬁes the operation with
the inputs such as matrix-multiply(A, B) without
worrying about the optimized implementation of the actual
multiplication, thus enabling high productivity. It is the com-
piler’s job to automatically identify how to best execute this
code by distributing the kernels among the available hardware
conﬁgurations on the platform.

In order to identify a high performance execution plan, the
compiler should be able to predict the performance of a kernel
on various hardware resources. This enables the following
decisions: (i) Variant-selection: A compiler may have several
variants implementing the kernel on the same hardware in
its library with potentially different performances, e.g., Boost
library vs Eigen library for matrix multiplication. The variation
may also come from setting certain parameters in the imple-
mentation that affect the runtimes, such as compilation ﬂags
and other tunable parameters of the implementation. Given
the input, which variant should be selected? (ii) Mapping
to hardware: The workload is a collection of possibly in-
terdependent kernels. Each kernel can be mapped to various
available hardware resources (CPUs, GPUs, etc.). For each
kernel-hardware pair, there may be a different kernel variant

 
 
 
 
 
 
that is optimal. Having accurate kernel performance models is
crucial for these decisions. We acknowledge that our approach
to designing this compiler is not suited for compiling arbitrary
low-level code as we rely on already available implementations
of certain kernels. However, the kernels chosen in the paper
dominate the runtime of many workﬂows including machine
learning. In fact, our chosen kernels cover >80% of the
workﬂows [5] in the DARPA SDH program [4], [6]. We
emphasize that predicting the execution time is more useful
than simply knowing the better variant or hardware resource
to
for individual kernels. For instance, suppose, we want
execute two matrix multiplications that do not have any data
dependencies on a platform containing a CPU and a GPU. The
ﬁrst one involves matrices of size 100 and the second of size
10000. While the ﬁrst multiplication alone may be faster on
GPU, it should still be scheduled on the CPU so that the GPU
is available for the second which is the larger multiplication.
To enable portability, the compiler must support learning
performance models of execution times T (Ki, Hj) on arbi-
trary platforms, where Ki is an arbitrary kernel implemented
on an arbitrary hardware Hj. We do not assume any access
to hardware proﬁlers or details of the kernel implementation.
The kernel implementations on various hardware are treated
as black-boxes and we can only manipulate the inputs to the
implementations. This makes our approach easily extensible
when a new implementation of a kernel is added to the library.
These performance models can be trained during compiler
installation by generating benchmark datasets for each kernel
(along with its variants) on the available hardware. To make
this feasible, the models must be lightweight so that they
can learn quickly with small training data without overﬁtting.
Once the models are trained, the compiler will be ready for
scheduling kernels at compile-time. The prediction may also
be needed at runtime. The exact input to the kernel may not be
known at compile-time, and therefore, the mapping decisions
(which variant to select and where to run) will have to be
made dynamically at runtime. Making the models compact is
necessary to ensure that they do not constitute a signiﬁcant
portion of the runtime. Here, we build performance models
for four ubiquitous kernels [4]found in common workﬂows
(i) Matrix-Matrix Multiplication, (ii) Matrix-Vector Multipli-
cation, (iii) Matrix Convolution, and (iv) Max-Pooling. We
propose a novel approach called Augmented Neural Network
(NN+C) which is extremely lightweight and utilizes the time
complexity function to perform execution time prediction.
Key Contributions: Our key contributions are as follows.

• We propose novel lightweight neural network models for

kernel performance prediction on CPUs and GPUs.

• We demonstrate that the lightweight models are portable
to more than 48 kernel-variant-hardware combinations.
Results from 48 combinations have been discussed that
include 4 kernels each of which has 2 variants on 3 CPUs
each and 2 variants on 2 GPUs each.

• We demonstrate that our models achieve low MAPE of
3% with a small training set in a short amount of training
time outperforming traditional feed-forward networks for

all 48 kernel-variant-hardware combinations.

• We demonstrate that our performance models can be used
to identify the best implementation of a kernel where
thousands of variants can exist with signiﬁcantly different
runtimes. Speciﬁcally, for Halide [7] implementation of
Blur ﬁlter our approach results in up to 1.7× speed up
over Halide auto-scheduler.

II. RELATED WORK

Most existing works focus on predicting the performance
of the whole speciﬁc workload. Huang et. al. [8] use sparse
polynomial regression to predict the execution time of arbi-
trary programs. In [9], a neural network is used to predict
the execution time of a workload. On the other hand, [10]
proposes feature selection from workloads to identify similar
applications for which the runtimes are known and predicting
the runtime for the given application using mean or linear
regression. These approaches are limited to one or similar
applications and will require retraining for every application,
and thus is not a scalable approach. Further, it is not clear
what type of workloads will result in good predictions and if
a similar approach can be ported to other hardware. Instead,
we perform predictions at coarse-level building blocks of
a program on various hardware. If a compiler can predict
performance at coarse level operations (kernels such as matrix
multiply) on available hardware, it can make mapping deci-
sions accordingly. For this, we consider four kernels that are
dominant in many other workloads. Therefore, instead of being
tied to a particular workﬂow, our approach applies to many,
such as the entire class of deep learning workloads.

Other existing works [11], [12] rely on the instruction set
architecture or hardware-speciﬁc metrics, which can poten-
tially be used to predict kernel (instead of workload) perfor-
mance. However, this would require explicit knowledge of the
hardware and corresponding proﬁlers, and thus will reduce
portability. Our approach enables a black-box treatment of the
kernels and allows prediction without knowing the speciﬁc
architecture or implementation details. Table I summarizes
the works closest to ours. Although we do not compare our
approach against the above-mentioned works quantitatively,
as they are for different objectives, we do show comparison
against their chosen machine learning models (neural net-
works and linear regression) and show that our lightweight
augmented neural networks achieve superior accuracy. Finally,
our work is different from [13] as they focus on performance
prediction of hardware using hardware proﬁling instead of the
performance of dominant operations.

Table I: Distinction from related works

Approach
Workload-speciﬁc [8]–[10]
ISA/Hardware speciﬁc [11], [12]
Our work

Workload Coverage
Low
High
Medium

Portability
N/A
Low/Medium
High

III. PROPOSED APPROACH

Problem Deﬁnition: For each operation on an arbitrary
platform with arbitrary implementations, given corresponding
inputs, ﬁnd a lightweight model that accurately predicts the
execution time using a small amount of training time.

To solve this problem, we propose the Augmented Neural
Network (NN+C). The key idea of NN+C is utilizing known
mathematical function f (K, H) as an extra input
to NN.
For example, in Matrix-Matrix Multiplication, besides using
basic features such as matrix dimensions, matrix density as
inputs, we calculate the number of total operations during
Matrix-Matrix Multiplication. Therefore, f (K, H) = m ×
n × k. f (K, H) for Matrix-Vector Multiplication, Matrix
Convolution, and Max-Pooling is also calculated similarly.
The lightweight aspect enables fast decision making during
compile-time as well as run-time. These augmented neural
networks provide the ﬂexibility to incorporate any tunable
parameter available for the kernel and the hardware.

A. Neural Network Structure

The structure of NN+C is shown in Figure 1. Inputs to the

neural network are

1) known mathematical function f (K, H)
2) kernel parameters Ki, such as input matrix dimension

and matrix density

3) hardware/code-optimization parameters Hj, for exam-
ple, how many threads are used in the multi-threaded
implementation and other controllable features that may
affect the runtime such as compilation ﬂags

Our augmented neural network contains less than two hidden
layers. The output layer has one node, which is the predicted
execution time. The number of nodes in hidden layers varies
given different kernels and different inputs, resulting in differ-
ent models for each kernel. Further, models for a given kernel
differ for CPU and GPU due to different inputs: in CPU we
use multi-threading and take the number of threads as input.
Thus, for example, for four kernels mentioned above and two
hardware conﬁgurations, this results in eight different neural
the structure of the models
network structures. However,
remains the same irrespective of the implementation of the
kernel (e.g., different software libraries), and the type of CPU
or the type of GPU (e.g., Intel or AMD). In this case, only the
weights in the neural network that are learned during training
will change.

B. Model Inputs

a) Matrix-Matrix Multiplication(Am,n × Bn,k):

Inputs
are the dimensions of the matrices m, n, and k, densities of
matrix A (d1 = number of non-zero entries
) and of matrix B (d2),
and the number of threads we utilize during multi-threading
on CPU, Nthd, which is an extra input for operations on CPU
and not present for GPU. We augment the neural network with
c = f (K, H), i.e., roughly the total number of operations in
the kernels. In this case, c = m × n × k.

m×n

Input
layer

f (K, H)

Hidden
layer(s)

Output
layer

K1

Km

H1

Hn

...

...

O1

...

Figure 1: Structure of Augmented Neural Network (NN+C)

b) Matrix-Vector Multiplication (Am,n × Bn,1): Inputs
are m, n, d, c, Nthd as deﬁned above. m and n are dimensions
of matrix A. d is the density of matrix A and the density of
vector B is set as 1. c is the number of operations, c = m × n.
Nthd is the number of threads.

c) Matrix Convolution(Am,n ∗ Br,r): Inputs are m, n, d,
c, Nthd as deﬁned above, and r is the dimension of square
matrix B. d is the density of matrix A and the density of square
matrix B is set as 1. The number of operations is given by
c = (m − r + 1) × (n − r + 1) × r2. Nthd is the number of
threads.

d) Max-Pooling (Am,n ∗ Bs,s): Inputs are m, n, d, c,
Nthd as deﬁned above, and s is the dimension of square matrix
B. d is the density of matrix A and the density of square
matrix B is set as 1. The number of operations is given by
c = (cid:6) n

(cid:7) × s2. Nthd is the number of threads.

(cid:7) × (cid:6) m

s

s

IV. EXPERIMENTS

A. Platforms and Optimizations

To demonstrate portability of our models we conducted our
experiments on ﬁve platforms: Intel(R) Xeon(R) CPU E5-
2650 v2 @ 2.60GHz (Xeon), Intel(R) Core i7-8750H CPU
@ 2.20GHz (I7), Intel(R) Core i5-7360U CPU @ 2.30GHz
(I5), NVIDIA Tesla K40c (Tesla) and NVIDIA Quadro K420
(Quadro).

To perform the kernel operations on CPU, we used the Eigen
library and Boost library in C++. Eigen/Dense, Eigen/Sparse,
uBLAS/matrix, and uBLAS/matrix sparse are used to opti-
mize dense and sparse matrix in each kernel. Multi-threading
was also used in Eigen to vary the number of threads. How-
ever, it is difﬁcult to vary the number of threads without heav-
ily changing the code structure in the Boost library. Owing to
our black-box approach, we used a single thread in the Boost
library. Among our platforms, Xeon has 16 cores, 32 threads;
I7 has 12 cores, 24 threads; and I5 has 2 cores, 4 threads.
For all operations on GPU, we used two implementations
of CUDA to optimize, one through global memory and one
through shared memory. This results in 10 implementations of

each kernel: 2 variants of 3 CPUs and 2 variants on 2 GPUs.
We published our code for reproduciblility1.

B. Datasets

We measured the performance of four kernels on each
platform: Matrix-Matrix Multiplication (MM), Matrix-Vector
Multiplication (MV), Matrix Convolution (MC) and Max-
Pooling (MP). Other kernels such as LU decomposition and
Blur ﬁlter were also evaluated, but their results have been
omitted due to brevity. For each kernel-variant-hardware com-
bination (there are 40 such combinations), we generated 500
instances of data, where 250 instances were used to train
the model and 250 instances to test. Each data instance was
generated randomly with ranges of parameters as described
in Table II. While the experiments may be conducted with
a different set of ranges, we chose these ranges as they are
common sizes for deep learning workﬂows. Since we use
multi-threading on CPU, all operations on CPU take an extra
input Nthd, which is randomly generated between 1 to the
maximum threads supported by the given platforms.

Table II: Parameters for data generation

Matrix-Matrix Multiplication

Matrix-Vector Multiplication

Matrix Convolution

Max-Pooling

2 , 1

d ∈ { 1

2 , 1
2 , 1

1
2log2 m×n }

m, n, k ∈ {1, 2, 3, . . . , 1024}
d1 ∈ {1, 1
1
2log2 m×n }
4 , . . . ,
1
d2 ∈ {1, 1
2log2 n×k }
4 , . . . ,
m, n ∈ {1, 2, 3, . . . , 1024}
4 , 1
8 , . . . ,
r ∈ {3, 5, 7}
m, n ∈ {r, r + 1, r + 2, . . . , 1024}
2 , 1
4 , . . . ,
r ∈ {2, 3, 4, 5}
s ∈ {1, 2}
m, n ∈ {r, r + 1, r + 2, . . . , 1024}
4 , . . . ,

1
2log2 m×n }

1
2log2 m×n }

d ∈ {1, 1

d ∈ {1, 1

2 , 1

C. Models

Our augmented neural networks are built under the Ten-
sorFlow framework. Each model is kept under 75 parameters
to maintain lightweight and a short training time. All models
have 2 dense layers and use ReLU as the activation function.
We use Adam as the optimizer [14], with learning rate varying
between 0.01, 0.0001, and 0.0001. The loss function is chosen
to be mean squared error. Each epoch included training with
a full batch. The number of parameters of each model as well
as its average training time is shown in Table III.

Table III: Number of parameters and average training times

CPU
GPU

MM
64, 19s
41, 19s

MV
50, 18s
73, 6s

MC
73, 6s
50, 8s

MP
73, 6s
73, 7s

1https://github.com/Naifeng/Augmented-Neural-Network

D. Baselines

We compare our method against four baselines: (1) Neural
Network (NN). NN is the same as the implementation of
NN+C except that NN does not take the number of operations
as an extra input. (2) Constant (C). In C, we only take the
number of operations as input and try to predict execution
time using linear regression. (3) Augmented Linear Regression
(LR+C). We take the same inputs as NN+C but use linear
regression in LR+C. (4) Augmented Non-Linear Regression
(NLR+C). In NLR+C we take the same inputs as NN+C
but use the random forest regression [15]. Random forest
based regression has been demonstrated to be competitive in
performance prediction [16], [17].

E. Evaluation Metrics

We used mean absolute percentage error (MAPE) to evalu-
ate the predictions {ˆt1, ˆt1, . . . , ˆtN } obtained by the baselines
and our models w.r.t. the ground truth {t1, t2, . . . , tN }:

M AP E =

100
N

(cid:88)

i

|ti − ˆti|
ti

.

(1)

By the deﬁnition of MAPE, a small misprediction (|ti − ˆti|)
might lead to a exceptionally high MAPE (up to 5000%) if
the true runtime ti is minute. Those extreme MAPE values
skew the average despite most of the predictions being ac-
curate. Thus, we introduced a threshold at the 30% of the
testing data, ranking from the lowest runtime to the highest
runtime. Overall, the average runtime of testing data below the
threshold is 13% of the average runtime of all the testing data,
but these low runtime data instances contribute approximately
80% of the overall MAPE. For example, when analyzing
NN+C performance on MC on GPU, MAPE of the lowest
30% is 128% and the MAPE of the highest 70% is 15%,
whereas the overall MAPE is 49%. Therefore, in reporting
MAPE, we drop 30% of testing data with the lowest runtime
for a more precise assessment of models’ performance.

V. DEMONSTRATION OF VARIANT-SELECTION

As a crucial application of our performance prediction
approach, we demonstrate that it can be used to pick the best
variant for a given kernel, i.e., picking the best available code
among several options. Possible scenarios include choosing
between a CPU and a GPU implementation and identifying
compilation ﬂags that will be best suited for the kernel.
To show the variant selection capability of our approach,
we choose a scenario where the number of variants can be
extremely high. Further, we choose two kernels different than
the four discussed thus far to show the generalizability of our
approach.

We consider the Blur kernel (Blur) and Fast Fourier trans-
form (FFT) kernel
implemented in Halide [7]. A Halide
code decouples the functional program from its execution
“schedule” that determines various aspects of the execution
such as the ordering of the loops, degree of unrolling loops,
and vectorization strategy. The schedule description can be

considered as a combination of shape (feature space) and
parameters. For instance,

extensively to generate a candidate set. The schedule given by
Halide auto-scheduler is {8, 256, 128, 8}.

blur_y.tile(x, y, xi, yi, 128, 256)

deﬁnes two dimensions of the shape and the parameters 128
and 256 determine the tunable parameters along these dimen-
sions. Changing the schedule does not affect the output of the
code, but it may signiﬁcantly affect the runtime. Therefore,
each schedule generates a variant of the same kernel, and our
task is to identify the best variant to use.

A. Model Inputs

We train our compact augmented neural networks with
inputs representing the schedule features. This allows us to
quickly estimate runtimes of the code with various sched-
ule parameters without actually executing the code. Halide
provides an auto-scheduler [18] that attempts to identify the
best schedule itself. We run the auto-scheduler to identify
the shape/feature space and ignore the suggested parameters.
Within this feature space we generate candidate schedules
S = {s1, s2, s3, . . . , sN }, where each si is a vector of param-
eters, and ﬁnd s = arg mini P(si), where P(si) represents the
predicted runtime given by schedule si. For kernels that Halide
auto-scheduler are not applicable to, we identify the feature
space based on the provided manually written implementation.
Input data dimensions n and augmented constant are also
fed into the neural network. We augmented n2 for Blur and
n log2 n for FFT to corresponding variant-selection models
given the complexity of Halide implementation of both kernels
[19].

B. Platforms and Optimizations

We conducted variant-selection experiments on ﬁve plat-
forms: Xeon, I7, I5, Tesla, and Quadro. We used Halide to
implement the kernel operations. More experiment settings of
variant-selection can be found at our published code2.

C. Datasets

We evaluated two kernels: Blur and FFT. The performance
of Blur is measured on ﬁve platforms. Given that there is no
existing GPU schedule of FFT provided by Halide, we only
conducted experiments of FFT on three CPU platforms. To
demonstrate that our models are able to identify the best im-
plementation among numerous existing variants, we generated
thousands of data instances and restricted the training set to
consist of 250 instances to maintain portability.

The following is a piece of code from the implementation
of Halide Blur on CPU. Each of s1, s2, s3 and s4 resides in
a .split() function and serves as a split factor. The inner
loop runs from zero to the split factor and the outer loop
runs from zero to the extent required by the ﬁrst argument
divided by the split factor [7]. Thus, a combination of {s1, s2,
s3, s4} deﬁnes a candidate schedule and different schedules
have signiﬁcantly different runtimes. We varied each parameter

2https://github.com/Naifeng/Variant-Selection

{

}
{

}

Var x = b l u r x . a r g s ( ) [ 0 ] ;
b l u r x

. c o m p u t e a t ( b l u r y , x o )
. s p l i t ( x , x vo , x v i ,
. v e c t o r i z e ( x v i ) ;

s 1 )

Var x = b l u r y . a r g s ( ) [ 0 ] ;
Var y = b l u r y . a r g s ( ) [ 1 ] ;
b l u r y

s 2 )
s 3 )

. c o m p u t e r o o t ( )
. s p l i t ( x , x o , x i ,
. s p l i t ( y , y o , y i ,
. r e o r d e r ( x i , y i , x o , y o )
. s p l i t ( x i , x i v o , x i v i ,
. v e c t o r i z e ( x i v i )
. p a r a l l e l ( y o )
. p a r a l l e l ( x o ) ;

s 4 )

According to Halide implementation rules and current sup-
ports (e.g., Halide only supports limited input dimensions for
FFT), we varied parameters as described in Table IV. For Blur
and FFT on CPU, we generated 1000 data instances for each
input data dimension, resulting in 6000 instances and 4000
instances, respectively. For Blur on GPU, we exhaustively
generated all possible combinations, that is, 1176 instances.

Table IV: Parameters for data generation

Blur (CPU)

Blur (GPU)

FFT (CPU)

n ∈ {210, 211, 212, . . . , 215}
s1, s2 ∈ {2, 4, 8, . . . , 1024}
s3 ∈ {2, 4, 8, . . . , s2}
s4 ∈ {2, 4, 8, . . . , s3}
n ∈ {210, 211, 212, . . . , 215}
s1 ∈ {2, 4, 8, 16}
s2, s3 ∈ {1, 2, 4, . . . , 64}
n ∈ {24, 25, 26, 27}
s1 ∈ {2, 4, 8, . . . , 2n−1}
s2, s3, s4, s5, s6 ∈ {2, 4, 8, . . . , 2n}

D. Models

Augmented neural networks used for variant-selection is
the same as models described in Section IV-C except that all
models used for variant-selection have 3 dense layers. The
number of parameters of each model as well as its average
training time is shown in Table V.

Table V: Number of parameters and average training times

CPU
GPU

Blur
71, 18s
66, 7s

FFT
67, 12s
N/A

E. Baselines

We compare our method against four baselines identical to
baselines described in Section IV-D: (1) NN, (2) C, (3) LR+C,
and (4) NLR+C. In addition, for Blur on CPU, we compare
our variant-selection approach with the Halide auto-scheduler
to show the overall improvement. For Blur on GPU, due to

Figure 2: Performance predictions of four kernels using NN+C

the fact that Halide does not have a stable auto-scheduler to
generate a GPU schedule, we compare our variant-selection
results with the average runtime among the runtime of all
candidate schedules. Similarly, since current Halide auto-
scheduler is not capable of scheduling a complicated pipeline
such as FFT, we compare our results with the average runtime
among the runtime of all candidate schedules for FFT on CPU.

F. Evaluation Metrics

We used MAPE and Spearman’s rank correlation coefﬁ-
cient (ρ) to evaluate the predictions {ˆt1, ˆt1, . . . , ˆtN } obtained
by the baselines and our models w.r.t.
the ground truth
{t1, t2, . . . , tN }. MAPE is deﬁned in Equation (1). ρ is deﬁned
as

ρ = 1 −

6 (cid:80)N
i=1 d2
i
N (N 2 − 1)

(2)

where di = | rank(ti) − rank(ˆti)|. rank(ti) is the rank of
ti among {t1, t2, . . . , tN }, ranking from the lowest value
to the highest value. rank(ˆti) is the rank of ˆti among
{ˆt1, ˆt1, . . . , ˆtN }, ranking from the lowest value to the highest
value. ρ ranges from −1 to 1. ρ of 1 indicates a perfect positive
correlation of two variables’ ranks and ρ of −1 indicates a

perfect negative correlation of two variables’ ranks. The closer
ρ is to zero, the weaker the correlation between the ranks.

A. Kernel Performance Prediction

VI. RESULTS

Figures 2 shows a visualization of using NN+C to predict
kernel performance on two platforms. We choose the results
of I5 and Tesla to represent the results on CPU and GPU,
respectively. We pick matrix dimension as x-axis, plotting
against execution time in seconds to visualize prediction. A
line joining two points in the plot indicates the corresponding
prediction and ground truth. Note that very few points have a
signiﬁcant misprediction. Tables VI, VII, VIII, and IX quantify
these results using MAPE.

For all ﬁve kernels using any implementation, NN+C pro-
duces the lowest MAPE in predictions. Ranking from the
highest accuracy (lowest MAPE) on average to the lowest is
(1) NN+C, (2) NLR+C, (3) NN, (4) LR+C, and (5) C. On
average, NN+C outperforms traditional NN by a margin of
8% and outperforms the second-best approach NLR+C by 5%.
LR+C has a good prediction for kernels on GPU. Performance
of C on all platforms is worst among all kernels expect MV.

Table VI: Prediction MAPE of Matrix-Matrix Multiplication

CPU

GPU

Eigen
I5
I7
Xeon
14% 23% 8%
31% 26%
29%
34% 28%
39%
31% 33%
44%
8%
24%
23%

Boost
I5
I7
Xeon
7% 27% 6%
35% 19%
20%
7%
34%
8%
7%
34%
8%
7%
33%
9%

CUDAGlobal Memory
Quadro
Tesla
5%
7%
13%
23%
9%
9%
8%
8%
10%
10%

CUDAShared Memory
Quadro
Tesla
8%
8%
16%
18%
10%
10%
8%
8%
19%
18%

NN+C
NN
C
LR+C
NLR+C

Table VII: Prediction MAPE of Matrix-Vector Multiplication

CPU

GPU

I5

Xeon

Eigen
I7

Boost
I7

CUDAGlobal Memory
Quadro
Tesla
Xeon
I5
7%
7%
21% 21% 25% 11% 8% 9%
7%
8%
11% 12%
22%
14%
8% 9% 23%
21% 22% 25% 12%
23%
7%
7%
8% 9%
21% 22%
12%
8% 9% 29%
28%
12%
25%
26%

26%
27%

29%

24%

CUDAShared Memory
Quadro
Tesla
6%
7%
7%
9%
10%
11%
6%
7%
22%
21%

Table VIII: Prediction MAPE of Matrix Convolution

CPU

GPU

I5

Eigen
I7

Boost
I7

CUDAGlobal Memory
Quadro
Xeon
Tesla
Xeon
15%
8% 21% 4% 30% 20% 13% 10%
15%
30%
16%
50%
9%
44%
30%
30%
48%
27%
15%
15%
46%
15%
38%
30% 32%
17%
17%
18%

22%
7%
40% 22%
32% 13%
7%
32%

30%
40%
37%
24%

I5

CUDAShared Memory
Quadro
Tesla
19%
17%
19%
22%
42%
42%
30%
29%
21%
21%

Table IX: Prediction MAPE of Max-Pooling

CPU

GPU

I5

Eigen
I7

Boost
I7

CUDAGlobal Memory
Quadro
Xeon
Tesla
Xeon
8%
23% 13% 14% 27% 12% 14% 14%
20%
32%
32%
36%
32%
95%
93%
41%
81%
67%
77%
75%
63%
50%
31%
14%
27% 13%
14%
25%

22%
20%
43%
37%
26%
27%
13% 17%

34%
47%
33%
18%

I5

CUDAShared Memory
Quadro
Tesla
27%
25%
47%
40%
28%
40%
28%
40%
29%
31%

NN+C
NN
C
LR+C
NLR+C

NN+C
NN
C
LR+C
NLR+C

NN+C
NN
C
LR+C
NLR+C

Overall, NN+C predicts more accurately for kernels on GPU
than those on CPU, achieving on average a low MAPE of 12%
and 16%, respectively.

We report the average error in MAPE for the four kernels
and the two hardware classes (CPU, GPU) in Table X. For each
kernel, MAPE was aggregated over all hardware and variants.
For each hardware class, MAPE was aggregate over all the
kernels, variants, and speciﬁc devices. We show the com-
parison of NN+C against traditional NN. NN+C signiﬁcantly
outperforms NN in almost all cases. In fact, for MM, MAPE
for NN+C is less than half of that of NN suggesting that the
traditional neural network is far inferior than our augmented
neural network.

Table X: Aggregated MAPE of NN+C vs. NN

NN+C
NN

MM MV
CPU
MC
11% 12% 16% 18% 16%
23% 14% 22% 32% 24%

MP

GPU
12%
20%

a) Unconstrained Augmented Neural Networks: To en-
able fast inference, our models are kept extremely lightweight
– less than 75 weights. Also, we only generate 500 data
instances for each kernel-variant-hardware combination, out
of which 250 are used to train our models. In order to assess
how much of the performance is compromised due to these
restrictions, we build similar NN+C models with more param-
eters and generate a larger dataset with 5000 data instances
(2500 instances are used to train and 2500 to test). Figure 3
illustrates the comparison between lightweight models and un-
constrained models in terms of error. Overall, MAPE achieved
by lightweight NN+C is 14% and by unconstrained NN+C is
9%. Speciﬁcally, on CPU, using unconstrained NN+C, MM,
MV, MC, and MP have a decrease on average MAPE of 5%,
2%, 8%, and 12%, respectively. On GPU, using unconstrained
NN+C, MM, MV, MC, and MP have a decrease on average
MAPE of 1.5%, 1%, 3%, and 2.5%, respectively. However,
accuracy comes at the cost of increased model size and the

)

%

(

E
P
A
M

25

20

15

10

5

0

Xeon
I7
I5
Tesla
Quadro
MM
MV
MC
MP

0

500

1,000

1,500

2,000

2,500

Preparing Time (s)

Figure 3: Performance comparison between Lightweight Mod-
els and Unconstrained Models

overall time as summarized in Table XI.

Table XI: Preparing time increase and model size increase

CPU
GPU

MM
9.31x, 2.13x
5.08x, 8.80x

MV
2.30x, 2.12x
7.07x, 2.34x

MC
11.59x, 2.21x
4.28x, 2.12x

MP
10.24x, 2.48x
3.35x, 2.62x

The preparing time (training data generation time plus
model training time) on average of lightweight NN+C on CPU
is 104s and that of unconstrained NN+C is 1040s, which is
10x of lightweight NN+C. The preparing time on average of
lightweight NN+C on GPU is 20s and that of unconstrained
NN+C is 97s, 4.85x of lightweight NN+C. In addition to the
preparing time loss, model size is signiﬁcantly reduced. Model
size reduction is most evident in MM on GPU, compared
to unconstrained NN+C, lightweight NN+C model is 8.80x
smaller. The rest of the models are downsized by 2.29x on
average.

If the training and inference time is not constrained, then
one can use our unconstrained (larger and more accurate)
augmented models. However, we envision that lightweight
models may be necessary due to the following reasons: (a)
at compile-time many kernels need to be evaluated: consider
VGG16 inference that requires >1M 2D-Convolutions. At a
given layer, there can be >100K 2D-Convolutions, each of
which may have different execution times not only due to
heterogeneous hardware but also due to different sparsity. This
number of convolutions will multiply with the factor of the
number of parallel image classiﬁcation pipelines. (b) Some
decisions may have to be made at runtime: some kernels
may be only instantiated at runtime, which is the only time
performance prediction inference has to be performed. In such
scenarios, the inference time should be as minimal as possible
to avoid an signiﬁcant impact on the total runtime.

(a) Halide Blur (CPU)

(b) Halide Blur (GPU)

(c) Halide FFT (CPU)

Figure 4: Runtime comparison of variants obtained from
baseline and our approach

B. Variant-Selection

Figure 4 shows the comparison of execution times for
varying input sizes of two kernels. Our predicted best schedule
produces a runtime close to the true best schedule within the
candidate set in all cases. Further, Figure 4(a) shows that
using our predictions, we were able to outperform Halide’s
auto-scheduler, getting up to 1.7× speedup in kernel Blur on
CPU. As for Blur on GPU, we obtained up to 223.5× speedup
compared to a randomly selected schedule on a small input
size (210), see Figure 4(b), and among all input sizes, we
were able to obtain a speedup of at least 1.24×. Shown in
Figure 4(c), we obtained up to 1.5× speedup compared to a
randomly selected schedule of Halide FFT on CPU.

Note that MAPE varies among different train-test splits

Table XII: Prediction MAPE and Spearman’s coefﬁcient

NN+C
NN
C
LR+C
NLR+C

Xeon
50%, 0.91
72%, 0.87
1140%, 0.76
1687%, 0.66
150%, 0.93

CPU
I7
23%, 0.95
25%, 0.94
59%, 0.82
93%, 0.82
39%, 0.94

Halide Blur

I5
28%, 0.97
40%, 0.91
167%, 0.93
411%, 0.84
43%, 0.97

GPU

Tesla
8%, 0.99
12%, 0.98
84%, 0.73
106%, 0.89
10%, 0.99

Quadro
22%, 0.97
29%, 0.94
64%, 0.85
62%, 0.87
23%, 0.97

Xeon
8%, 0.99
11%, 0.98
66%, 0.86
44%, 0.97
3%, 0.99

Halide FFT
CPU
I7
14%, 0.97
19%, 0.95
33%, 0.97
32%, 0.92
11%, 0.97

I5
3%, 1
17%, 0.95
30%, 0.97
26%, 0.90
2%, 1

and training process. The MAPE value shown in Table XII
is the best (lowest) MAPE obtained by our methods and
the baselines on the Halide kernels. The table also shows
the Spearman’s rank correlation coefﬁcient. Since the main
objective is to select the best variant which requires the ability
to correctly rank the variants, this is the primary metric of
comparison. We observe that our approach NN+C obtains the
highest rank correlation in the majority of the cases. NLR+C
has a higher rank correlation for Halide Blur while having
much worse MAPE. On the other hand, for Halide FFT,
NLR+C obtains identical rank coefﬁcients with NN+C and
better MAPEs. However, NLR+C has a much higher inference
time, and therefore likely to hinder the execution of the actual
application if used by the runtime component of a compiler,
as we argued in the end of Section VI-A. Figure 5 shows
the comparison of inference times between our lightweight
NN+C and NLR+C. It is noteworthy that the inference time
of NLR+C is more than 75× of that of our approach.

Figure 5: Inference time comparison of NN+C and NLR+C

VII. CONCLUSION

We have proposed a novel lightweight augmented neural
to predict kernel performance on CPUs
network (NN+C),
and GPUs. Our approach is designed in support of creating
compilers with high productivity, portability, and performance.
To show that our models are portable to different platforms
with different implementations, we have evaluated our model
on several CPUs and GPUs with multiple optimizations,
resulting in a total of 48 kernel-variant-hardware combinations.
Our models signiﬁcantly outperformed the baselines including
standard neural network. We have shown that our approach can
be used to identify the best variants even when the number
of variants is extremely high. We do so by demonstrating a
1.7× speedup over Halide auto-scheduler. In future work, we

will build prediction models for other popular kernels. These
models will be used to perform optimized mapping of kernels
in workﬂows for various heterogeneous platforms.

ACKNOWLEDGEMENT

This work is supported by the Defense Advanced Research
Projects Agency (DARPA) under BAA number HR0011-20-9-
0019 and by the National Science Foundation Award number
1911229. Any opinions, ﬁndings, and conclusions or recom-
mendations expressed in this material are those of the authors
and do not necessarily reﬂect the views of the sponsors.

REFERENCES

[1] M. M. Vai, W. S. Song, and B. M. Tyrrell, “Application-speciﬁc inte-
grated circuits,” in High Performance Embedded Computing Handbook
(D. R. Martinez, R. A. Bond, and M. M. Vai, eds.), ch. 9, pp. 191–215,
A Systems Perspective, 2008.

[2] I. Kuon and J. Rose, Quantifying and Exploring the Gap Between FPGAs
and ASICs. Springer Publishing Company, Incorporated, 1st ed., 2009.
[3] B. Zahiri, “Structured asics: opportunities and challenges,” in Proceed-
ings 21st International Conference on Computer Design, pp. 404–409,
Oct 2003.

[4] “Software deﬁned hardware (sdh).” https://www.darpa.mil/program/

software-deﬁned-hardware.

[5] H. Zhou, A. Srivastava, R. Kannan, and V. Prasanna, “Design and
implementation of knowledge base for runtime management of software
dened hardware,” in 2019 IEEE High Performance Extreme Computing
Conference (HPEC), pp. 1–7, 2019.

[6] “Darpa looks to propel parallelism.” https://www.hpcwire.com/2019/09/

04/darpa-looks-to-propel-parallelism/.

[7] J. Ragan-Kelley, C. Barnes, A. Adams, S. Paris, F. Durand, and S. Ama-
rasinghe, “Halide: a language and compiler for optimizing parallelism,
locality, and recomputation in image processing pipelines,” Acm Sigplan
Notices, vol. 48, no. 6, pp. 519–530, 2013.

[8] L. Huang, J. Jia, B. Yu, B. gon Chun, P. Maniatis, and M. Naik, “Pre-
dicting execution time of computer programs using sparse polynomial
regression,” in Advances in Neural Information Processing Systems 23
(J. D. Lafferty, C. K. I. Williams, J. Shawe-Taylor, R. S. Zemel, and
A. Culotta, eds.), pp. 883–891, Curran Associates, Inc., 2010.

[9] E. Ipek, B. R. De Supinski, M. Schulz, and S. A. McKee, “An approach
to performance prediction for parallel applications,” in European Con-
ference on Parallel Processing, pp. 196–205, Springer, 2005.

[10] W. Smith, I. Foster, and V. Taylor, “Predicting application run times
using historical information,” in Workshop on Job Scheduling Strategies
for Parallel Processing, pp. 122–142, Springer, 1998.

[11] C. Mendis, A. Renda, S. Amarasinghe, and M. Carbin, “Ithemal:
Accurate, portable and fast basic block throughput estimation using deep
neural networks,” arXiv preprint arXiv:1808.07412, 2018.

[12] E. Konstantinidis and Y. Cotronis, “A quantitative rooﬂine model for
gpu kernel performance estimation using micro-benchmarks and hard-
ware metric proﬁling,” Journal of Parallel and Distributed Computing,
vol. 107, pp. 37–56, 2017.

[13] G. Wu, J. L. Greathouse, A. Lyashevsky, N. Jayasena, and D. Chiou,
“Gpgpu performance and power estimation using machine learning,”
in 2015 IEEE 21st International Symposium on High Performance
Computer Architecture (HPCA), pp. 564–576, IEEE, 2015.

[14] D. P. Kingma and J. Ba, “Adam: A method for stochastic optimization,”

arXiv preprint arXiv:1412.6980, 2014.

[15] L. Breiman, “Random forests,” Machine learning, vol. 45, no. 1, pp. 5–

32, 2001.

[16] C. Dahinden and M. Ethz, “An improved random forests approach with
application to the performance prediction challenge datasets,” Hands-on
Pattern Recognition, Challenges in Machine Learning, vol. 1, pp. 223–
230, 2011.

[17] F. Hutter, L. Xu, H. H. Hoos, and K. Leyton-Brown, “Algorithm runtime
prediction: Methods & evaluation,” Artiﬁcial Intelligence, vol. 206,
pp. 79–111, 2014.

[18] R. T. Mullapudi, A. Adams, D. Sharlet, J. Ragan-Kelley, and K. Fa-
tahalian, “Automatically scheduling halide image processing pipelines,”
ACM Transactions on Graphics (TOG), vol. 35, no. 4, pp. 1–11, 2016.
[19] K. Li and P. Hudak, “Memory coherence in shared virtual memory
systems,” ACM Transactions on Computer Systems (TOCS), vol. 7, no. 4,
pp. 321–359, 1989.

