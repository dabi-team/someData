0
2
0
2

l
u
J

6
1

]

G
L
.
s
c
[

1
v
6
0
5
8
0
.
7
0
0
2
:
v
i
X
r
a

SketchGraphs: A Large-Scale Dataset for Modeling
Relational Geometry in Computer-Aided Design

Ari Seff
Princeton University
aseff@princeton.edu

Yaniv Ovadia
Princeton University
yovadia@princeton.edu

Wenda Zhou
Columbia University
wz2335@columbia.edu

Ryan P. Adams
Princeton University
rpa@princeton.edu

Abstract

Parametric computer-aided design (CAD) is the dominant paradigm in mechanical
engineering for physical design. Distinguished by relational geometry, parametric
CAD models begin as two-dimensional sketches consisting of geometric primitives
(e.g., line segments, arcs) and explicit constraints between them (e.g., coincidence,
perpendicularity) that form the basis for three-dimensional construction operations.
Training machine learning models to reason about and synthesize parametric
CAD designs has the potential to reduce design time and enable new design
workﬂows. Additionally, parametric CAD designs can be viewed as instances
of constraint programming and they offer a well-scoped test bed for exploring
ideas in program synthesis and induction. To facilitate this research, we introduce
SketchGraphs, a collection of 15 million sketches extracted from real-world CAD
models coupled with an open-source data processing pipeline. Each sketch is
represented as a geometric constraint graph where edges denote designer-imposed
geometric relationships between primitives, the nodes of the graph. We demonstrate
and establish benchmarks for two use cases of the dataset: generative modeling
of sketches and conditional generation of likely constraints given unconstrained
geometry.

1

Introduction

The modern design paradigm for physical objects typically resembles modular programming, where
simple subcomponents are connected to yield a composed part/assembly with more complex prop-
erties [3]. In parametric computer-aided design (CAD), parts generally begin as a collection of 2D
sketches composed of geometric primitives (line segments, circles, etc.) with associated parameters
(coordinates, radius, etc.). Primitives and parameters interact via imposed constraints (e.g., equality,
symmetry, perpendicularity, coincidence) determining their ﬁnal conﬁguration. Edits made to any
parameter will propagate along these speciﬁed dependencies, updating other properties of the sketch
accordingly. A collection of 3D operations, e.g., extruding a circle into a cylinder, then enable the
creation of solids and surfaces from these 2D sketches.

Training machine learning models to construct and reason about object designs has the potential
to enable new and more efﬁcient design workﬂows. This is an important but challenging domain
that sits at the interface of graphics, relational reasoning, and program synthesis. Recent progress in
probabilistic generative modeling of both continuous (e.g., images and audio [21, 4, 40]) and discrete
(e.g., graphs and source code [43, 24, 33]) domains has demonstrated the potential for both sampling
high-dimensional objects and, in the case of explicit models, estimating their densities/probabilities.

 
 
 
 
 
 
Figure 1: Example sketches from the dataset containing at least six geometric primitives. Dashed lines indicate
construction geometry, which is used as a reference for other primitives but not physically realized.

If adapted to CAD, such models may be incorporated into the design workﬂow by, for example,
suggesting next steps based on partially speciﬁed geometry or offering corrections of implausible
operations. In addition, if provided with visual observations of a part or sketch, a model may be
trained to infer the underlying feature history, allowing for direct modiﬁcation in CAD software.

Beyond the applicability to design itself, reasoning about human-designed structures is fundamental
to artiﬁcial intelligence research. One of the challenges of computer vision, for example, is developing
rich priors of objects in scenes. It is important to construct priors for the kind of “stuff” encountered
in the world, which may exhibit signiﬁcant symmetry and modularity, properties that are difﬁcult
to capture directly. By developing models for the design process and learning to reason about the
creation of objects, it may become possible to identify hierarchical structures, long-range symmetries,
and functional constraints that would be difﬁcult to infer from vision alone. Outside of computer
vision, a long-horizon goal of artiﬁcial intelligence is the task of program induction [25, 18, 7]. In
program induction, the objective is to discover computer programs from examples of their inputs and
outputs. Closely related to this are the ideas of programming by demonstration (e.g., Cypher and
Halbert [6], Menon et al. [31]) and the problem of program synthesis (e.g., Ellis et al. [9], Gulwani
et al. [15]). Part of the challenge of program induction is identifying a rewarding “sweet spot” in the
coupled space of program representation and induction task; it is difﬁcult to move beyond simple
toy problems. We can view the design of physical objects in a parametric CAD system, however,
as an example of constraint programming in which rich geometric structures are speciﬁed by an
implicit program rather than, e.g., imperatively. It is a highly appealing domain for the study of
program induction/synthesis because it is relatively well-scoped and low-order, but clearly requires
the discovery of modularity to be effective. Moreover, progress on CAD program synthesis and
induction leads to useful tools on a relatively short horizon.
We introduce SketchGraphs,1 a dataset of 15 million sketches extracted from parametric CAD models
hosted on Onshape, a cloud-based CAD platform [1]. Each sketch is represented with the ground
truth geometric constraint graph specifying its construction, where edges denote precise relationships
imposed by the designer that the must be preserved between speciﬁc primitives, the nodes of the
graph.

Along with the dataset, we will be releasing an open-source tool suite for data processing, removing
obstacles to model development for other researchers.

Existing CAD datasets of voxel or mesh-based representations of 3D geometry [5, 42] have enabled
work on sampling realistic 3D shapes [41, 29, 34]. Samples from such models, while impressive, are
not modiﬁable in a parametric design setting and therefore are not directly usable in most engineering
workﬂows. The recent ABC dataset [22] extracts parametric CAD models from Onshape’s public
platform, as do we, but is geared towards 3D modeling of curves and surfaces, supporting tasks such

1https://github.com/PrincetonLIPS/SketchGraphs

2

Figure 2: Example sketch (left) and a portion of its geometric constraint graph (right). Constraints are denoted
as edges that either act on a primitive as a whole or some subcomponent of the primitive. Dots represent either a
primitive’s endpoints (left and right dots) or its center point (bottom dot).

as patch segmentation and normal estimation. Explicit modeling of the relational structure exhibited
by parametric CAD sketches, the target of SketchGraphs, is currently underexplored.

The SketchGraphs dataset may be used to train models directly for various target applications aiding
the design workﬂow, including conditional completion (autocompleting partially speciﬁed geometry)
and automatically applying natural constraints reﬂecting likely design intent (autoconstrain). In
addition, by providing a set of rendering functions for sketches, we aim to enable work on CAD
inference from images. Off-the-shelf noisy rendering options allow for sketches to appear hand-drawn.
This setup is similar to that proposed in Ellis et al. [10], where TikZ ﬁgures are rendered with a
hand-drawn appearance to provide training data for a model inferring LaTeX code from images. Here,
our sketches are not synthetically produced but rather extracted from real-world parametric CAD
models. See Section 4 for further details on the target applications supported by SketchGraphs.

This paper makes the following contributions:

• We collect a dataset of 15 million parametric CAD sketches including ground truth geometric

constraint graphs denoting the primitives present and their imposed relationships.

• We develop an open-source pipeline for data processing, conversion, and integration with

deep learning frameworks in Python. These technical contributions include:

– Speciﬁc domain types to enable manipulation of the sketches and their representations

in a structured manner.

– A local renderer to enable visualization of sketches obtained from the dataset or

generated by models.

• We establish baseline models for two initial use cases of the dataset: generative modeling of

sketches and inferring likely constraints conditioned on unconstrained geometry.

2 Related Work

CAD datasets Existing large-scale CAD datasets have tended to focus on 3D shape modeling.
ModelNet [42] and ShapeNet [5], for example, offer voxel and mesh-based representations of 3D
geometry, enabling the generative modeling work of Wu et al. [41], Liu et al. [29], Nash et al.
[34]. Note that these representations do not store the construction route employed by the original
designer of each CAD model. The ABC dataset [22], in contrast to the above, contains parametric
representations of 3D CAD models. Like SketchGraphs, the ABC models are obtained from public
Onshape documents. However, the processing pipeline and benchmarks of the ABC dataset support
3D modeling of curves and surfaces. In contrast, we extract the 2D sketches that form the basis of 3D
CAD models, enabling modeling of the geometric constraints used to ensure design intent.

Sketch datasets The word sketch is a term of art in the context of CAD, referring speciﬁ-
cally to the 2D basis of 3D CAD models, storing both geometric primitives and imposed con-

3

CircleLineArcMidpointLine……PerpendicularTangentLineVerticalArcMirrorAngle=45°LineVerticaldirX: ﬂoat dirY: ﬂoat pntX: ﬂoat pntY: ﬂoat start: ﬂoat end: ﬂoat construct: bool    CoincidentCoincidentCoincidentMidpointCoincidentCoincidentCoincidentstraints. Large-scale datasets related instead to the colloquial usage of this term have been pro-
posed in recent years, speciﬁcally focusing on hand-drawn sketches of general image categories
(cat, bus, etc.). The QuickDraw dataset was constructed in Ha and Eck [16] from the Quick,
Draw! online game [19] to train an RNN to produce vector image sketches as sequences of
pen strokes. Pairings of pixel-based natural images and corresponding vector sketches are col-
lected in the Sketchy dataset [35], intended to train models for sketch-based image retrieval. Like
these datasets based on vector images, our SketchGraphs dataset is also fundamentally focused
on the construction of sketches, not simply their raster appearance. However, here we focus on
the relational geometry underlying parametric CAD sketches, not drawings of general categories.

Graph-structured generative modeling Modern message passing net-
works (e.g., Gilmer et al. [12], Duvenaud et al. [8] extending the earlier
work of Scarselli et al. [36]) have enabled progress in modeling of do-
mains that exhibit relational structure, e.g., molecular chemistry and
social networks. In the context of generative modeling, these networks
are often coupled with node and edge-speciﬁc prediction modules that
incrementally build a graph [24, 28]. We take a similar approach for
two example applications demonstrated in Section 4. Several alternative
architectures have been studied, such as LSTMs on linearized adjacency
matrices [43] or decoding soft adjacency matrices with elements contain-
ing probabilities of edge existence [38]. In general, graph modeling is
subject to signiﬁcant representation ambiguity (up to n! node orderings
for a graph containing n nodes). Recent work leveraging normalizing
ﬂows [27] proposes a permutation-invariant approach for generating node
features. We identify the CAD sketch domain as one which admits a nat-
ural ordering over construction operations for the underlying geometric
constraint graphs, which we describe in Section 3.

Primitive type

%

Line
Circle
Arc
Point
Spline
Ellipse

68.47
9.97
9.45
8.58
2.57
0.08

Constraint type

%

Coincident
Projected
Distance
Horizontal
Mirror
Vertical
Parallel
Length
Perpendicular
Tangent

42.17
9.71
6.72
6.45
5.54
4.78
4.37
3.68
3.24
2.94

Table 1: Frequencies of
the most common primitives
(top) and constraints (bot-
tom).

Geometric program induction Geometric program induction com-
prises a practical subset of problems in program induction where the goal
is to learn to infer a set of instructions to reconstruct input geometry. For example, Ellis et al. [10]
couples a learned shape detector with program search to infer LaTeX code for synthetic images
of TikZ ﬁgures and Sharma et al. [37] trains a reinforcement learning agent to reconstruct simple
3D shapes with constructive solid geometry. We view this as a fundamental area of study in order
to develop machine learning models that can aid in design and engineering. Work on generating
programs interactively, e.g., allowing a model to assess the current program’s output [11], shows
particular promise. Our processing pipeline includes functionality for sketch rendering and querying
a geometric constraint solver to aid research in this direction.

3 The SketchGraphs Dataset

SketchGraphs is aimed towards questions not just concerning the what but in particular the how of
CAD design; that is, not simply what geometry is present but how was it constructed. To this end, we
leverage a data source that provides some insight into the actual operations and commands selected
by the designer at each stage of construction. Whereas generic CAD ﬁle formats are widely available
online, e.g., STEP for 3D models and DXF for 2D drawings, these do not store any information
regarding constraints. In recent years, the cloud-based CAD platform Onshape has amassed a large
collection of publicly available models from which detailed construction histories may be queried.
For each CAD sketch, we extract ground truth construction operations regarding both the geometric
primitives present and constraints applied to them.

3.1 Acquisition

Using Onshape’s API, we gather metadata for all public documents created within a ﬁve-year period
from 2015 to 2020, leading to over two million unique document IDs. Each document may contain
multiple PartStudios, each specifying the design of an individual component of a CAD model. We
download each PartStudio and extract all sketches present, resulting in over 15 million sketches. Note

4

Figure 3: Left: Histogram of sketch sizes as measured by the number of primitives and constraints they
contain. Middle: Number of constraints as a function of number of primitives in the sketch (opacity represents
respectively median, 69th, 84th and 93rd percentile). Right: Average node degree depicted as a function of
sequence position. Note that primitives placed earlier in the sequence tend to serve as common anchors for
subsequent primitives to constrain against.

that the PartStudios also contain non-sketch features, e.g., 3D operations, that we do not store in
our ﬁnal dataset. Here, we focus only on the 2D sketches comprising each part and their underlying
constraint graph representations.

To be included in the dataset, each sketch must contain at least one geometric primitive and one
constraint. The dataset thus ranges from those sketches with larger constraint graphs, which tend to
be more visually interesting, to some very simple sketches, e.g., sketches comprised of a single circle.
See Fig. 3 and Table 1 for an overview of the sketch sizes and other dataset statistics.

3.2 Geometric constraint graphs

Geometric constraint graphs offer a succinct representation of 2D CAD sketches. For each sketch,
we extract a graph G = (V, E) with a set of nodes, V , and a set of edges, E, denoting primitives
and constraints between them, respectively. In general, these are multi-hypergraphs, where multiple
edges are permitted to share the same member nodes and each edge may join one or more nodes.
When a constraint operates on a single primitive, e.g., a scale constraint such as setting the radius of a
circle), we represent the constraint as a loop, an edge connecting the node of interest with itself. In
addition, hyperedges indicate constraints that operate on three or more nodes. For example, a mirror
constraint must specify a third primitive to act as an axis of symmetry.

Primitives and constraints are described not just by their type, but also by parameters dictating their
behavior. For primitives, parameters consist of the coordinates denoting their placement within a
sketch and an isConstruction Boolean indicating if a primitive is to be physically realized (when false)
or serve as a reference for other primitives (when true). Note that the initial values of a primitive’s
coordinates do not necessarily satisfy any of the constraints present; rather, the task of adjusting
primitives’ coordinates is left to a geometric constraint solver included in standard CAD software.

Constraint parameters indicate the primitive(s) acted upon as well as any other numerical or categorical
values necessary to fully specify their behavior. For instance, a distance constraint includes a number
indicating the Euclidean distance that two primitives must satisfy. Further details on primitive and
constraint parameters may be found in the appendix.

Often, constraints are applied to a speciﬁc point on a primitive. For example, two endpoints from
different line segments may be constrained to be a certain distance apart. In order to unambiguously
represent these constraints, we include these sub-primitives as separate nodes in the constraint graph.

Best practice in CAD encourages maintaining fully-constrained sketches, meaning a minimally
sufﬁcient set of constraints removes all degrees of freedom (DOF) from the sketch primitives [3].
This allows for edit propagation and better expression of design intent. Overall, we observe a Pearson
correlation coefﬁcient of 0.598 between the total DOF in each sketch and the total DOF removed by
constraints2 (Fig. 4). Users of SketchGraphs may query for sketches adhering to different thresholds
of constrainedness depending on their application.

2We exclude constraints directly involving a sketch’s axes in this calculation. Unfortunately, one limitation
of our dataset is that these external constraints (constraints involving default geometry not deﬁned by the user)
are not currently retrievable via Onshape’s API. This is consistent, however, with the common assumption that
designs be fully-constrained up to rigid body transformation.

5

Figure 4: Left: Histogram of approximated degrees of freedom (DOF) remaining among sketches in the
SketchGraphs dataset. Right: DOF removed by constraints in a sketch as a function of total DOF from its
primitives before constraints are applied (opacity represents median, 69th, 84th, and 93rd percentiles).

3.3 Construction sequence extraction

For certain problem settings, a sequence representation of the constraint graphs may be desired.
In generative modeling, for example, graph-structured objects are often modeled autoregressively
as sequences of construction steps [24, 43]. In the generic case, a canonical node ordering for
graphs may not be available, leading to ambiguity regarding sequential modeling. Here, however,
we have access to certain information about each sketch’s construction history that leads to natural
sequence-based representations.

In particular, we may access the order in which primitives were added to a sketch by the user,
conveying a ground truth node ordering. Rather than being an arbitrary choice among factorially
many, we observe two trends that support this route: 1) Nodes with greater degree tend to occur
earlier, serving as integral building blocks of the sketch (Fig. 3). 2) Adjacent nodes in the ordering
have a greater probability of being adjacent in the graph than randomly selected nodes (0.70 vs. 0.38,
respectively).

While the ordering of primitives and constraints are both known separately, the relative ordering
(interleaving) of primitives and constraints is not recorded in the Onshape models. We canonicalize
the entire sequence by placing an edge’s insertion step immediately following the insertion of its
member nodes. This emulates the standard design route of constraining primitives as they are added
to a sketch. When there are ties, such as when multiple nodes share more than one edge, or multiple
edges share the most recently added node, we may simply revert to the standalone edge ordering.

An alternative sequence option stems from the setting where unconstrained geometry is imported
into CAD software, for instance from a drawing scan, and the software attempts to apply intended
constraints. In this case, the corresponding sequence places all constraints at the end, after specifying
all primitives. We note that there will likely be additional sequence extraction methods of interest to
users of the dataset. Our pipeline may be easily extended to handle custom conversions.

4 Case Studies of Supported Applications

We identify several target applications for which SketchGraphs data may be used to train and develop
models and describe some initial methods to tackle these applications. In addition to mechanical
design-focused applications, a domain underexplored in the machine learning community, we note
that these problems share properties with similar tasks in program synthesis and induction. We intend
for SketchGraphs to serve as a test bed for these related lines of work and for the models below to
provide baselines for future research.

4.1 Autoconstrain

CAD packages such as Onshape, AutoCAD, and Solidworks typically contain built-in constraint
inferencing. However, these functions are based on manually-deﬁned heuristics, catered towards
interactive sketching (for example placing a coincidence constraint when a user drags a new primitive
from an existing one). A sought-after feature is the ability to upload unconstrained geometry, such as
from a drawing or document scan, and infer the design intent and corresponding set of constraints. By
treating the primitives in the dataset’s sketches as input, the ground truth constraints may serve as a
predictive target. This may be viewed as an instance of program induction in constraint programming.

6

100102030405060Remaining degrees of freedom0.0000.0250.0500.0750.1000.1250.1500.175FrequencyFigure 5: Autoconstraining a sketch. On the left is the original input sketch (only primitives are provided to the
model). Two user modiﬁcations are shown with the blue arrows: dragging the top circle’s upwards (modiﬁcation
A) and both enlarging and dragging it to the right (modiﬁcation B). Our model correctly picks up on a host of
coincident, distance, equality, and other constraints. It fails to infer a 7 mm distance constraint between the top
and bottom of the rectangle, but the circle correctly maintains midpoint alignment with it (modiﬁcation A).

The autoconstrain task, then, is to predict a set of constraints given an input conﬁguration of geometric
primitives. Here, we are particularly interested in predicting the “natural” set of constraint that would
have been input by a human user. However, we note that other target constraint sets may be considered,
by e.g., requiring them to be minimal in some mathematical sense [45, 44, 23]. The autoconstrain
problem can also be viewed as an example of a link prediction task in which the induced relationships
are the constraints; see e.g., Taskar et al. [39], Liben-Nowell and Kleinberg [26], Lü and Zhou [30].

4.1.1 Model

We propose an auto-regressive model based on message passing networks (MPNs) [8, 12] where
information about the input geometric primitives is propagated along a growing set of constraints,
iteratively building a constraint graph. The model is tasked with predicting the sequence of edges
corresponding to the given node sequence, and proceeds in a recurrent fashion by iteratively predicting
the next edge (represented as a pair of the edge partner node and the edge label) for each node (or a
stop token indicating to move to the next node).

At inference time, the model is additionally given a mask indicating (approximately) which constraints
are satisﬁed in the sketch (these may be satisﬁed because they were originally imposed in the dataset,
or they may be a consequence of the original constraints). This ensures that the model only selects
valid constraints and does not deform the sketch under consideration.

4.1.2 Evaluation

We train this model on a subset of SketchGraphs of 2.2 million sketches limited to the most common
types of primitives (Point, Line, Circle, and Arc) and at most 16 primitive primitives per sketch.
We exclude hypergraphs from consideration here and only model two-node and single-node edges.
50K held-out sketches are used for testing. A full description of the model architecture, the training
procedure and the inference procedure is available in the supplementary material.

The autoconstrain model is evaluated by predicting edges on a test dataset. We obtain an average
edge precision of 0.74 and an average edge recall of 0.74. The average F1 score is 0.71. We also
evaluate the test negative log-likelihood at an average of 0.495 bits per edge. For reference, a uniform
choice among valid constraints scores an average entropy of 6.09 bits per edge.

We also demonstrate the inferred constraints qualitatively by editing a test sketch and observing the
resulting solved state Fig. 5.

4.2 Generative modeling

A variety of target tasks may be approached under the broader umbrella of generative modeling.
By learning to predict sequences of sketch construction operations, for example, models may be
employed for conditional completion, interactively suggesting next steps to a CAD user. In addition,

7

OriginalModiﬁcation AModiﬁcation BTrueInferredInferredTrueexplicit generative models, estimating probabilities (or densities) of examples, may be used to assess
the overall plausibility of a sketch via its graph or construction sequence, offering corrections of
dubious operations (similar to “autocorrect”). This also provides a path to a CAD analog of inductive
programming support that has been deployed in Microsoft Excel [14].

Here we develop an initial model and benchmark for unconditional generative modeling. We train a
model on full construction sequences for the sketch graphs, both nodes and edges. While we model
constraint parameters (edge features), we only model the primitive type parameter for the nodes,
leaving the task of determining the ﬁnal conﬁguration of primitive coordinates to a constraint solver.

4.2.1 Model

The model resembles that from the autoconstrain task above, with an additional node-adding module.
When edge sampling for a given node has completed, the model outputs a distribution over possible
primitive types to add to the graph. After a node’s insertion, any sub-primitive nodes associated
with the new node (e.g., endpoints of a line segment) are deterministically added to the graph with
corresponding edges denoting the sub-primitive relationship. Alternatively, a stop token may be
selected that ceases graph construction. See supplementary for further model details.

4.2.2 Evaluation

The evaluation of high-dimensional generative models is an open problem. Here we provide quantita-
tive evaluation consisting of likelihood on the held-out test set and include distributional statistics
in the supplementary. Using the same train-test split as in Section 4.1.2, the average negative log-
likelihood of test examples according to the trained model is 28.2 bits per graph. In comparison, a
standard LZMA compressor, applied to a short canonical representation of the data, yields an average
entropy of 85.6 bits per sketch. Full details of the evaluation are available in the supplementary
material along with some renderings of generated sketches.

4.3 Other potential applications

4.3.1 CAD inference from images

A highly-sought feature for CAD software is the ability to input a noisy observation of an object
(2D drawing, 3D scan, etc.) and infer its design steps, producing a plausible parametric CAD model.
Inferring sketch primitives and constraints, which form the 2D basis of 3D CAD models, is an integral
component of this application. Our pipeline includes rendering functions for producing images of the
sketches, including noisy rendering to simulate a hand-drawn appearance. This allows generating
millions of training pairs of rendered sketches and corresponding geometric constraint graphs.

4.3.2 Learning semantic representations

New models trained on the SketchGraphs data can lead to vectorial latent representations that capture
important semantic content in sketches. Such vector representations have been developed for natural
language processing [2, 32], speech recognition [17], computer vision [20], and computational chem-
istry [13]. These representations have opened up a space of creative new possibilities for downstream
tasks from search to content recommendation. Unsupervised learning on the SketchGraphs data
enables such possibilities for CAD designs.

5 Conclusion and Future Work

This paper has introduced SketchGraphs, a large-scale dataset of parametric CAD sketches and
processing pipeline intended to facilitate research in ML-aided design and broader problems in
relational reasoning and program induction. Each sketch is accompanied by the ground truth
geometric constraint graph denoting its conﬁguration. We demonstrate two use cases of the dataset,
unconditional generative modeling and conditionally inferring constraints given primitives, providing
initial benchmarks for these applications.

While we focus on 2D sketches here, which serve as the anchors for full parametric CAD models,
future work will aim to make the complete set of construction operations accessible to modeling. We

8

will also be providing benchmarks for additional applications supported by the dataset, including
parametric CAD inference from images, a potentially powerful design aid.

Acknowledgments and Disclosure of Funding

We would like to thank Onshape for the CAD sketches and API support. We also thank Alex
Beatson, Daniel Suo, Gregory Gundersen, and members of the Princeton Laboratory for Intelligent
Probabilistic Systems for valuable discussion and feedback. This work was partially funded by NSF
IIS-1421780 and the DataX Program at Princeton University through support from the Schmidt
Futures Foundation. AS was supported by the National Defense Science and Engineering Graduate
Fellowship (NDSEG) Program.

References

[1] Onshape. https://www.onshape.com. Accessed: 2019-08-01.

[2] Yoshua Bengio, Réjean Ducharme, Pascal Vincent, and Christian Jauvin. A neural probabilistic

language model. Journal of Machine Learning Research, 3(Feb):1137–1155, 2003.

[3] Bernhard Bettig and Christoph M Hoffmann. Geometric constraint solving in parametric

Computer-Aided Design. J. Comput. Inf. Sci. Eng., 11(2):021001, June 2011.

[4] Andrew Brock, Jeff Donahue, and Karen Simonyan. Large scale GAN training for high ﬁdelity
natural image synthesis. In International Conference on Learning Representations, 2019.

[5] Angel X. Chang, Thomas Funkhouser, Leonidas Guibas, Pat Hanrahan, Qixing Huang, Zimo
Li, Silvio Savarese, Manolis Savva, Shuran Song, Hao Su, Jianxiong Xiao, Li Yi, and Fisher Yu.
ShapeNet: An Information-Rich 3D Model Repository. Technical Report arXiv:1512.03012
[cs.GR], 2015.

[6] Allen Cypher and Daniel Conrad Halbert. Watch What I Do: Programming by Demonstration.

MIT press, 1993.

[7] Eyal Dechter, Jon Malmaud, Ryan P Adams, and Joshua B Tenenbaum. Bootstrap learning
via modular concept discovery. In Twenty-Third International Joint Conference on Artiﬁcial
Intelligence, 2013.

[8] David K Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Gómez-Bombarelli, Timothy
Hirzel, Alan Aspuru-Guzik, and Ryan P Adams. Convolutional networks on graphs for learning
molecular ﬁngerprints. In Advances in Neural Information Processing Systems, 2015.

[9] Kevin Ellis, Armando Solar-Lezama, and Josh Tenenbaum. Unsupervised learning by program
synthesis. In Advances in Neural Information Processing Systems, pages 973–981, 2015.

[10] Kevin Ellis, Daniel Ritchie, Armando Solar-Lezama, and Josh Tenenbaum. Learning to infer
graphics programs from hand-drawn images. In Advances in Neural Information Processing
Systems 31. 2018.

[11] Kevin Ellis, Maxwell Nye, Yewen Pu, Felix Sosa, Josh Tenenbaum, and Armando Solar-Lezama.
Write, execute, assess: Program synthesis with a repl. In Advances in Neural Information
Processing Systems 32. 2019.

[12] Justin Gilmer, Samuel S. Schoenholz, Patrick F. Riley, Oriol Vinyals, and George E. Dahl.
In International Conference on Machine

Neural message passing for quantum chemistry.
Learning, 2017.

[13] Rafael Gómez-Bombarelli, Jennifer N Wei, David Duvenaud, José Miguel Hernández-Lobato,
Benjamín Sánchez-Lengeling, Dennis Sheberla, Jorge Aguilera-Iparraguirre, Timothy D Hirzel,
Ryan P Adams, and Alán Aspuru-Guzik. Automatic chemical design using a data-driven
continuous representation of molecules. ACS central science, 4(2):268–276, 2018.

9

[14] Sumit Gulwani, José Hernández-Orallo, Emanuel Kitzelmann, Stephen H Muggleton, Ute
Schmid, and Benjamin Zorn. Inductive programming meets the real world. Communications of
the ACM, 58(11):90–99, 2015.

[15] Sumit Gulwani, Oleksandr Polozov, Rishabh Singh, et al. Program synthesis. Foundations and

Trends in Programming Languages, 4(1-2):1–119, 2017.

[16] David Ha and Douglas Eck. A neural representation of sketch drawings. In International

Conference on Learning Representations, 2018.

[17] Mikael Henaff, Kevin Jarrett, Koray Kavukcuoglu, and Yann LeCun. Unsupervised learning of
sparse features for scalable audio classiﬁcation. In ISMIR, volume 11, page 2011, 2011.

[18] Irvin Hwang, Andreas Stuhlmüller, and Noah D Goodman. Inducing probabilistic programs by

Bayesian program merging. arXiv preprint arXiv:1110.5667, 2011.

[19] Jonas Jongejan, Henry Rowley, Takashi Kawashima, Jongmin Kim, and Nick Fox-Gieg. The

Quick, Draw! - A.I. experiment. https://quickdraw.withgoogle.com, 2016.

[20] Koray Kavukcuoglu, Marc’Aurelio Ranzato, Rob Fergus, and Yann LeCun. Learning invariant
features through topographic ﬁlter maps. In 2009 IEEE Conference on Computer Vision and
Pattern Recognition, pages 1605–1612. IEEE, 2009.

[21] Durk P Kingma and Prafulla Dhariwal. Glow: Generative ﬂow with invertible 1x1 convolutions.

In Advances in Neural Information Processing Systems 31. 2018.

[22] Sebastian Koch, Albert Matveev, Zhongshi Jiang, Francis Williams, Alexey Artemov, Evgeny
Burnaev, Marc Alexa, Denis Zorin, and Daniele Panozzo. ABC: A big CAD model dataset
for geometric deep learning. In Proceedings of the IEEE Conference on Computer Vision and
Pattern Recognition, 2019.

[23] Ming Li, Frank C. Langbein, and Ralph R. Martin. Detecting design intent in approximate

CAD models using symmetry. Computer-Aided Design, 42(3):183 – 201, 2010.

[24] Yujia Li, Oriol Vinyals, Chris Dyer, Razvan Pascanu, and Peter Battaglia. Learning deep
generative models of graphs. In International Conference on Machine Learning, 2018.

[25] Percy Liang, Michael I Jordan, and Dan Klein. Learning programs: A hierarchical Bayesian
approach. In Proceedings of the 27th International Conference on Machine Learning, pages
639–646, 2010.

[26] David Liben-Nowell and Jon Kleinberg. The link-prediction problem for social networks.
Journal of the American society for information science and technology, 58(7):1019–1031,
2007.

[27] Jenny Liu, Aviral Kumar, Jimmy Ba, Jamie Kiros, and Kevin Swersky. Graph normalizing

ﬂows. In Advances in Neural Information Processing Systems 32. 2019.

[28] Qi Liu, Miltiadis Allamanis, Marc Brockschmidt, and Alexander Gaunt. Constrained graph
variational autoencoders for molecule design. In Advances in Neural Information Processing
Systems. 2018.

[29] Shikun Liu, Lee Giles, and Alexander Ororbia. Learning a hierarchical latent-variable model of

3d shapes. In 2018 International Conference on 3D Vision (3DV). IEEE, 2018.

[30] Linyuan Lü and Tao Zhou. Link prediction in complex networks: A survey. Physica A:

statistical mechanics and its applications, 390(6):1150–1170, 2011.

[31] Aditya Menon, Omer Tamuz, Sumit Gulwani, Butler Lampson, and Adam Kalai. A machine
learning framework for programming by example. In International Conference on Machine
Learning, pages 187–195, 2013.

[32] Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed repre-
sentations of words and phrases and their compositionality. In Advances in neural information
processing systems, pages 3111–3119, 2013.

10

[33] Vijayaraghavan Murali, Letao Qi, Swarat Chaudhuri, and Chris Jermaine. Neural sketch learning
for conditional program generation. In International Conference on Learning Representations,
2018.

[34] Charlie Nash, Yaroslav Ganin, S. M. Ali Eslami, and Peter W. Battaglia. Polygen: An autore-

gressive generative model of 3d meshes, 2020.

[35] Patsorn Sangkloy, Nathan Burnell, Cusuh Ham, and James Hays. The sketchy database:
Learning to retrieve badly drawn bunnies. ACM Transactions on Graphics (proceedings of
SIGGRAPH), 2016.

[36] Franco Scarselli, Marco Gori, Ah Chung Tsoi, Markus Hagenbuchner, and Gabriele Monfardini.
The graph neural network model. IEEE Transactions on Neural Networks, 20:61–80, 2009.

[37] Gopal Sharma, Rishabh Goyal, Difan Liu, Evangelos Kalogerakis, and Subhransu Maji. Csgnet:
Neural shape parser for constructive solid geometry. In The IEEE Conference on Computer
Vision and Pattern Recognition (CVPR), 2018.

[38] Martin Simonovsky and Nikos Komodakis. GraphVAE: Towards generation of small graphs

using variational autoencoders. In ICAN, 2018.

[39] Ben Taskar, Ming-Fai Wong, Pieter Abbeel, and Daphne Koller. Link prediction in relational

data. In Advances in Neural Information Processing Systems, pages 659–666, 2004.

[40] Aäron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alexander
Graves, Nal Kalchbrenner, Andrew Senior, and Koray Kavukcuoglu. Wavenet: A generative
model for raw audio. In Arxiv, 2016. URL https://arxiv.org/abs/1609.03499.

[41] Jiajun Wu, Chengkai Zhang, Tianfan Xue, William T Freeman, and Joshua B Tenenbaum.
Learning a probabilistic latent space of object shapes via 3d generative-adversarial modeling.
In Advances in Neural Information Processing Systems, 2016.

[42] Z. Wu, S. Song, A. Khosla, F. Yu, L. Zhang, X. Tang, and J. Xiao. 3d shapenets: A deep
representation for volumetric shapes. In Computer Vision and Pattern Recognition, 2015.

[43] Jiaxuan You, Rex Ying, Xiang Ren, William Hamilton, and Jure Leskovec. GraphRNN:
Generating realistic graphs with deep auto-regressive models. In International Conference on
Machine Learning, 2018.

[44] Gui-Fang Zhang. Well-constrained completion for under-constrained geometric constraint
problem based on connectivity analysis of graph. In Proceedings of the 2011 ACM Symposium
on Applied Computing, SAC ’11, page 1094–1099, New York, NY, USA, 2011. Association for
Computing Machinery. ISBN 9781450301138. doi: 10.1145/1982185.1982427.

[45] Gui-Fang Zhang and Xiao-Shan Gao. Well-constrained completion and decomposition for
International Journal of Computational

under-constrained geometric constaint problems.
Geometry & Applications, 16(05n06):461–478, 2006. doi: 10.1142/S0218195906002142.

11

A Primitive Parameters

Primitives are accompanied by both numerical and Boolean parameters specifying their initial
positions within a sketch. For certain primitives, Onshape and other CAD programs employ an
overparameterized description that aids in constraint solving. In our pipeline, the classes representing
each primitive type contain attributes corresponding to Onshape’s parameterization but include
methods for conversion to standard parameterizations.

As mentioned in the main text, all primitives have an isConstruction Boolean parameter indicating if
a primitive is to be physically realized or simply serve as a reference for other primitives. We provide
the remaining parameterization for common primitive types below.

Point (dof: 2)

• x (ﬂoat): x coordinate
• y (ﬂoat): y coordinate

Line (dof: 4)

• dirX (ﬂoat): x component of unit direction vector
• dirY (ﬂoat): y component of unit direction vector
• pntX (ﬂoat): x coordinate of any point on the line
• pntY (ﬂoat): y coordinate of the same point as above
• startParam (ﬂoat): signed distance of starting point relative to (pntX, pntY)
• endParam (ﬂoat): signed distance of ending point relative to (pntX, pntY)

Circle (dof: 3)

• xCenter (ﬂoat): x coordinate of circle center
• yCenter (ﬂoat): y coordinate of circle center
• xDir (ﬂoat): x component of unit direction vector3
• yDir (ﬂoat): y component of unit direction vector
• radius (ﬂoat): radius
• clockwise (bool): orientation of the unit direction vector

Arc (dof: 5)

• xCenter (ﬂoat): x coordinate of corresponding circle’s center
• yCenter (ﬂoat): y coordinate of corresponding circle’s center
• xDir (ﬂoat): x component of unit direction vector
• yDir (ﬂoat): y component of unit direction vector
• radius (ﬂoat): radius of corresponding circle
• clockwise (bool): orientation of the unit direction vector
• startParam (ﬂoat): starting angle relative to unit direction vector
• endParam (ﬂoat): ending angle relative to unit direction vector

Ellipse (dof: 5)

• xCenter (ﬂoat): x coordinate of ellipse’s center
• yCenter (ﬂoat): y coordinate of ellipse’s center
• xDir (ﬂoat): x component of unit direction vector
• yDir (ﬂoat): y component of unit direction vector
• radius (ﬂoat): greater (major) radius
• minorRadius (ﬂoat): smaller radius
• clockwise (bool): orientation of the unit direction vector

3Circles are considered to have an angular direction in order to account for rotation of sketch components

involving circles.

12

B Constraint Parameters

All constraints act on at least one primitive, indicated by the corresponding edge’s member nodes.
A subset of constraints require additional numerical, enumerated, or Boolean parameters to fully
specify their behavior. Here we list the general parameters that may accompany constraints followed
by the schemata for common constraint types. We exclude any external constraints (e.g., constraints
involving projected geometry) and describe only those that act on user-deﬁned geometry within a
sketch. Numerical parameters follow user-speciﬁed units.

Note that constraint parameters are considered internal to Onshape and thus external documentation
is sparse. We determine parameter functionality based on discussions with Onshape developers and
usage of the solver.

B.1 Parameters

• local# (reference): a reference to a primitive. A constraint may have one or more of
these (e.g., local0, local1, ...). The alternative parameter names localFirst and
localSecond are used interchangeably in the data with local0 and local1, respectively.

• length (ﬂoat): quantity for a numerical constraint (e.g., a 3 cm distance)
• angle (ﬂoat): quantity for an angular constraint (e.g., 45 degrees)
• clockwise (bool): orientation of an angular constraint
• aligned (bool): whether the start and end points of primitives in an angular constraint are

aligned in the angle computation

• direction (enum): the measurement type for a distance value (must be on of minimum,

vertical, or horizontal)

• halfSpace# (enum): the relative positioning to be maintained by primitives in distance-

based constraints (must be one of left or right)

B.2 Schemata

Below, we list each parameter schema and the constraints adhering to it. Note that some constraints
can appear with more than one schema. For example, a horizontal constraint may act on a single
primitive (specifying only local0) or two primitives (specifying both local0 and local1). Numer-
ical constraints are listed here with their most frequent schema, although a few other schemas may
appear in the dataset.

(local0)
Horizontal, Vertical

(local0, local1)
Coincident, Horizontal, Vertical, Parallel, Perpendicular, Tangent, Midpoint, Equal, Offset, Concentric

(local0, local1, local2)
Mirror

(local0, length)
Diameter, Radius

(local0, direction, length)
Length

(local0, local1, direction, halfSpace0, halfSpace1, length)
Distance

(local0, local1, aligned, clockwise, angle)
Angle

B.3 Numerical parameter distributions

We examine the values observed for the two constraint parameters specifying a quantity: length and
angle. As described above, the length parameter is used in several numerical constraints.

13

Length

5 mm
1 cm
3 mm
0.5 in
2 mm
1 in
2 cm
4 mm
8 mm
0.25 in

%

3.51
3.35
2.76
2.41
2.30
2.29
2.17
2.03
1.89
1.88

Angle (deg)

%

45
15
60
120
30
135
90
10
20
150

18.02
7.93
6.58
6.58
6.42
5.87
4.00
2.72
2.69
1.50

Table 2: Frequencies of the most common values observed for length (left) and angle (right) parameters. All
values are converted to common units for frequency computation. For length, we display the values in the units
requiring the fewest digits. Note that although the standalone Perpendicular constraint is generally used for
90-degree angles, perpendicularity is sometimes imposed with an angular constraint as seen here.

See Table 2 for the frequencies of the most common parameter values. Unsurprisingly, the most
common angles tend to evenly divide 360 degrees. The most common length parameters tend to
correspond to standard sizes of common parts (e.g., a 5 mm screw). Fig. 6 displays the cumulative
frequency of parameter values when sorted from most to least frequent. The 300 most frequent values
for angle and length account for 95.8% and 82.1% of all occurrences, respectively. angle, as a
scale-invariant parameter, exhibits a bit less diversity than length.

Figure 6: Cumulative frequency of unique parameter values when sorted from most to least frequent.

C Example sketch constructions

Below, we render the construction steps for some of the example sketches in Fig. 1 according to the
user-deﬁned primitive orderings.

14

050100150200250300Parameter value sorted index0.00.20.40.60.81.0Cumulative frequencyanglelengthFigure 7: Construction of a dataset sketch proceeding from top left to bottom right.

Figure 8: Construction of a dataset sketch proceeding from top left to bottom right.

15

Figure 9: Construction of a dataset sketch proceeding from top left to bottom right.

Figure 10: Construction of a dataset sketch proceeding from top left to bottom right.

16

D Autoconstrain Model

D.1 Task description

We train the model to predict the graph edges in sequence following the ground truth ordering
described in Section 3.3. The model is trained in a supervised fashion simultaneously on two related
tasks:

• (partner prediction) Given the nodes in the sketch, and the graph representing the constraints
at the given step of the construction sequence, predict which node should be attached to
the current node in order to create a new constraint (or choose to move to the next node by
predicting a sentinel node to attach).

• (constraint label prediction) Given the above, and the target partner of the current constraint,

predict the type of the current constraint.

D.2 Model description

The model may conceptually be divided into three components: 1) an input representation component,
responsible for embedding the features from the primitives and constraints, 2) a message-passing
component, responsible for transforming these features using the graph structure, and 3) a readout
component, which outputs probabilities for the speciﬁc tasks according to the transformed features.
We describe each one in turn.

Our model is parametrized by a global complexity parameter m (we use m = 384 in the results we
present).

Input representation Constraints are only identiﬁed by their referenced primitives, and their type.
At the current stage, we only embed their type using a m-dimensional embedding layer. Primitives
are a sequence of heterogenous discrete elements, and thus require a little more care. The type of
the primitive (i.e. Point, Line etc.) is embedded similarly using a m-dimensional embedding layer.
However, each primitive type may have a different number of parameters, which must represented
similarly. Continuous parameters are quantized and represented by their quantized value, which is
embedded using a m-dimensional layer. For a given primitive, all its parameters are embedded and
averaged to form a parameter embedding of size m (if a primitive has no parameters, this parameter
embedding is set to zero). The embedding for the primitive is then computed by concatenating the
embedding corresponding to the type, and that of the parameters, and projecting this 2m vector onto
one of size m through a dense layer.

Message passing Prior to message passing, the node embeddings are transformed using 3-layer
recurrent neural network using the GRU architecture (and with the hidden size set to m). The node
embeddings are then recursively transformed using a message passing network, such as at stage s, we
perform the update:

a(s+1)
v

=

(cid:88)

fe(m(s)

u , c(u,v)),

u:(u,v)∈E
= fn(a(s+1)

v

, m(s)

v ),

m(s+1)
v

where here c(u, v) denotes the representation for the constraint computed previously, and m(0)
u is the
representation for the primitive computed previously. We set fe as a linear layer that concatenates
m(s)
u and c(u,v) and set fn to take the functional form of a GRU cell. We use 3 message passing
steps in our presented results.

A global representation for the graph is also computed by computing a weighted of the ﬁnal node
messages, where the weights are computed using a learned function comprised of a sigmoid applied
to a linear layer. This representation is combined with the ﬁnal state of the GRU using a linear layer
again to obtain a ﬁnal global representation for the problem.

Readout The readout for predicting the partner takes as input the ﬁnal node representations for each
node in the graph, the ﬁnal node representation for the current node, and the global representation.

17

These representations are concatenated and fed to a fully-connected two-layer network (with ReLU
non-linearity) which produces a scalar value for each node in the graph. This value is interpreted as
an unnormalized log-probability for the partner selected being the given node, where an implicit 0
value is given to a sentinel node representing a request to move to the next node.

The readout for predicting the label takes as input the ﬁnal node representations for the current node
and the partner node, as well as the global representation. These representations are concatenated and
fed into a three layer fully-connected neural network. The output of that network is interpreted as
unnormalized log-probabilities for predicted edge type.

D.3 Training

The model is trained on a subset of the dataset consisting of about 2.2M sketches, ﬁltered such that
the largest sketch does not exceed 16 primitives. The model is presented with random edges (or “stop”
edges representing a request to move to the next node), selected uniformly among all possible edges
in the sketches (this implies that the sketches are weighted towards longer sketches). We train the
model using the Adam optimizer with a batch size of 8192 and a learning rate of 10−5, where the
learning rate is understood to apply to the loss as expressed as a sum over the batch (rather than an
average). The training is performed over 150 epochs of the data, with the learning rate decaying by a
factor of 10 at epochs 50 and 150. The training is performed on a server equipped with 4 Nvidia Titan
X (Pascal) and dual Intel Xeon E5-2667 v4 (total 32 logical cores) and takes 3 hours and 30 minutes.

D.4 Evaluation

We evaluate the model on a separate held-out set of 50K sketches. During the evaluation stage, invalid
edge predictions are masked from the model. Although the model naturally operates in a factorized
fashion:

P (edge | X) = P (edge type | edge partner, X)P (edge partner | X)

we note that the mask itself does not factorize in the given fashion (as the validity of a partner may
depend on the speciﬁc constraint being considered). We thus reconstruct the full joint distribution on
the edge partner and labels according to the given conditionals, and mask and re-scale the predictions
using the joint distribution directly. As reported in the main text, we obtain an average edge recall of
0.74(±0.00) and an average edge precision of 0.74(±0.00) (where the brackets indicate the standard
error of the estimate).

E Generative Model

E.1 Model description

The generative model shares many similarities with the autoconstrain model described in Ap-
pendix D.2, and thus only major differences are highlighted here.

Input representation The input representation is similar to that of the autoconstrain model, with
the exceptions that primitive parameters are ignored whereas constraint parameters are represented.

Message passing The message passing process is identical to the autoconstrain model, except no
recurrent model is used, and the node embeddings are used directly.

Readout
In addition to the readout networks presented for the autoconstrain model, additional
readout models are present for the primitive prediction task and predicting constraint parameters. The
primitive prediction readout is given the global embedding for the graph, and is tasked to predict the
type of the next primitive to be added to the construction sequence. It is implemented as a 3 layer
fully-connected neural network. The constraint feature readout is given the constraint type, as well as
a representation computed from the representation of the primitives participating in the constraint.
The features are then read-out sequentially using a recurrent neural network.

18

E.2 Training

The model is trained on the same data as the autoconstrain model. Numerical constraint parameters
adhering to the most frequent schemas (Appendix B) are included as targets. The model is trained
using the Adam optimizer, with a batch size of 6144 and a learning rate of 10−5, where the learning
rate is understood to apply to the loss as expressed as a sum over the batch. The training is performed
for 150 epochs of the data, with the learning rate decaying by a factor of 10 at epochs 50 and 150.
The training is performed on a server equipped with 4 Nvidia Titan X (Pascal) and dual Intel Xeon
E5-3667 v4 (total 32 logical cores), although only 3 GPUs were used due to a CPU bottleneck. The
training takes 3 hours and 50 minutes.

E.3 Evaluation

The evaluation is performed on the same testing split as the autoconstrain model.

LZMA comparison To estimate the performance of the LZMA compressor on the data, we
represent the construction sequence as a sequence of integers (representing all labels and features).
Such sequences are then concatenated and compressed using Python’s implementation of LZMA with
preset 9 and LZMA_EXTREME. Let sn denote the compressed size (in bits) of the the ﬁrst n elements of
the dataset, we report an estimate of the average entropy rate by computing (s100000 − s50000)/50000.

Distributional statistics We compare a host of statistics for the ground-truth training dataset to
statistics on 10K generated samples. Fig. 12 depicts sketch-size distributions in terms of primitive and
constraint counts, and Fig. 13 depicts the distribution of degrees of freedom in each set of sketches.
Error bars in these histograms represent 5th and 95th percentiles acquired by resampling the generated
sketches with replacement 2K times. We also compare the distribution of primitive and constraint
types in Fig. 14.

For depictions of generated sketches, see Fig. 11. While this baseline model produces primitive types,
constraint types, and constraint parameters, it is not trained to initialize the primitive coordinates. The
solver determines the ﬁnal conﬁguration starting from a uniform initialization, which limits the visual
diversity of the observed samples. Future work will include modeling the primitive coordinates.

Figure 11: Random samples from the trained generative model containing at least two primitives. A solver is
used to determine the ﬁnal conﬁguration of the sketch after the model samples the geometric constraint graph.
Each primitive is initialized uniformly (e.g., all lines initially lie on the x-axis from 0 to 1) and their coordinates
are updated by the solver. This baseline model, which does not output primitive parameters, is able to capture
some of the patterns observed for small sketches but does not produce many sophisticated sketches.

19

Figure 12: Distributions of sampled and training set sketch sizes. Error bars represent bootstrapped 5th and
95th percentiles.

Figure 13: Degree-of-freedom statistics for sampled and training set sketches. Error bars represent bootstrapped
5th and 95th percentiles.

Figure 14: Average number of primitives and constraints of each type per sketch in training set and sampled
sketches.

20

051015202530Number of primitives0.000.050.100.150.200.25Frequencysamplesdataset01020304050Number of constraints0.000.050.100.15Frequencysamplesdataset020406080100Total DOF0.000.050.100.150.20Frequencysamplesdataset0102030405060DOF removed by constraints0.000.050.100.150.20Frequencysamplesdataset0510152025303540Net DOF0.000.050.100.150.200.25Frequencysamplesdataset0.00.51.01.52.02.53.0linecirclepointarcdatasetsamples012345coincidenthorizontalparallelverticalperpendiculardiametertangentequallengthmidpointdistanceradiusconcentricangledatasetsamples