0
2
0
2

r
p
A
2

]
L
P
.
s
c
[

1
v
2
2
1
1
0
.
4
0
0
2
:
v
i
X
r
a

On the Principles of Differentiable Quantum
Programming Languages∗

Shaopeng Zhu, Shih-Han Hung, Shouvanik Chakrabarti, Xiaodi Wu
University of Maryland, College Park, USA

Abstract

Variational Quantum Circuits (VQCs), or the so-called quan-
tum neural-networks, are predicted to be one of the most im-
portant near-term quantum applications, not only because of
their similar promises as classical neural-networks, but also
because of their feasibility on near-term noisy intermediate-
size quantum (NISQ) machines. The need for gradient in-
formation in the training procedure of VQC applications
has stimulated the development of auto-differentiation tech-
niques for quantum circuits. We propose the first formaliza-
tion of this technique, not only in the context of quantum
circuits but also for imperative quantum programs (e.g., with
controls), inspired by the success of differentiable program-
ming languages in classical machine learning. In particular,
we overcome a few unique difficulties caused by exotic quan-
tum features (such as quantum no-cloning) and provide a
rigorous formulation of differentiation applied to bounded-
loop imperative quantum programs, its code-transformation
rules, as well as a sound logic to reason about their correct-
ness. Moreover, we have implemented our code transforma-
tion in OCaml and demonstrated the resource-efficiency of
our scheme both analytically and empirically. We also con-
duct a case study of training a VQC instance with controls,
which shows the advantage of our scheme over existing
auto-differentiation for quantum circuits without controls.

CCS Concepts: • Theory of computation → Quantum
information theory; Denotational semantics; Operational

∗This work was partially funded by the U.S. Department of Energy, Office
of Science, Office of Advanced Scientific Computing Research, Quantum
Testbed Pathfinder Program under Award Number DE-SC0019040, Quantum
Algorithms Team program, the U.S. Air Force Office of Scientific Research
MURI grant FA9550-16-1-0082, and the U.S. National Science Foundation
grant CCF-1755800, CCF-1816695, and CCF-1942837(CAREER).

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies
are not made or distributed for profit or commercial advantage and that
copies bear this notice and the full citation on the first page. Copyrights
for components of this work owned by others than the author(s) must
be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee. Request permissions from permissions@acm.org.
PLDI ’20, June 15–20, 2020, London, UK
© 2020 Copyright held by the owner/author(s). Publication rights licensed
to ACM.
ACM ISBN 978-1-4503-7613-6/20/06.
https://doi.org/10.1145/3385412.3386011

semantics; • Computing methodologies → Machine learn-
ing.

Keywords: quantum programming languages, differentiable
programming languages, quantum machine learning

ACM Reference Format:
Shaopeng Zhu, Shih-Han Hung, Shouvanik Chakrabarti, Xiaodi
Wu. 2020. On the Principles of Differentiable Quantum Program-
ming Languages. In Proceedings of the 41st ACM SIGPLAN Interna-
tional Conference on Programming Language Design and Implemen-
tation (PLDI ’20), June 15–20, 2020, London, UK. ACM, New York,
NY, USA, 25 pages. https://doi.org/10.1145/3385412.3386011

1 Introduction

Background. Recent years have witnessed the rapid de-
velopment of quantum computing, with practical advances
coming from both research and industry. Quantum program-
ming is one topic that has been actively investigated. Early
work on language design [24, 35, 42, 43, 47] has been fol-
lowed up recently by several implementations of these lan-
guages, including Quipper [26], Scaffold [2], LIQUi|⟩ [52],
Q# [49], and QWIRE [36]. Extensions of program logics have
also been proposed for verification of quantum programs
[4, 10, 11, 19, 29, 30, 55, 57]. See also surveys [20, 46, 56].

With the availability of prototypes of quantum machines,
especially the recent establishment of quantum supremacy [3],
the research of quantum computing has entered a new stage
where near-term Noisy Intermediate-Scale Quantum (NISQ)
computers [40], e.g., the 53-qubit quantum machines from
Google [3] and IBM [22], become the important platform for
demonstrating quantum applications. Variational quantum
circuits (VQCs) [17, 18, 38], or the so-called quantum neural
networks, are predicted to be one of the most important appli-
cations on NISQ machines. It is not only because VQCs bear
a lot of similar promises like classical neural networks as
well as potential quantum speed-ups from the perspective of
machine learning (e.g., see the survey [9]), but also because
VQC is, if not the only, one of the few candidates that can
be implemented on NISQ machines. Because of this, a lot of
study has already been devoted to the design, analysis, and
small-scale implementation of VQCs (e.g., see the survey [7]).
Typical VQC applications replace classical neural net-
works, which are just parameterized classical circuits, by
quantum circuits with classically parameterized unitary gates.
Namely, one will have a "quantum" mapping from input to

 
 
 
 
 
 
PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

output replacing classical mapping in machine learning ap-
plications. An important component of these applications
is a training procedure which optimizes a loss function that
now depends on the read-outs and the parameters of VQCs.
Gradient-based approaches are widely used in the train-
ing procedure. However, computing these gradients of loss
functions from quantum circuits has a similar complexity of
simulating quantum circuits, which is infeasible for classical
computation. Thus, the ability of evaluating these "quantum"
gradients efficiently by quantum computation is critical for
the scalability of VQC applications.

Fortunately, analytical formulas of gradients used in VQCs
have been studied by [18, 21, 32, 44, 45]. In particular, Schuld
et al. [44] proposed the so-called phase-shift rule that uses
two quantum circuits to compute the partial derivative re-
spective to one parameter for quantum circuits. One of the
very successful tools for quantum machine learning, called
PennyLane [8], implemented the phase-shift rule to achieve
auto differentiation (AD) for the read-outs of quantum cir-
cuits. It also integrated automatic differentiation from es-
tablished machine learning libraries such as TensorFlow or
PyTorch for any additional classical calculation in the train-
ing procedure. However, none of these studies was conducted
from the perspective of programming languages and no rig-
orous foundation or principles have been formalized.
Motivations. An important motivation of this paper is to
provide a rigorous formalization of the auto-differentiation
technique applied to quantum circuits. In particular, we
will provide a formal formulation of quantum programs,
their semantics, and the meaning of differentiation of them.
We will also study the code-transformation rules for auto-
differentiation and prove their correctness.

As we will highlight below, research on the formalization
will encounter many new challenges that have not been con-
sidered or addressed by existing results [18, 21, 32, 44, 45].
Consider one of the basic requirements, e.g., compositionality.
As we will show, differentiating the composition of quantum
programs will necessarily involve running multiple quan-
tum programs on copies of initial quantum states. How to
represent the collection of quantum programs succinctly and
also bound the number of required copies is a totally new
question. Among our techniques to address this question,
we also need to change the previously proposed construct,
e.g., the phase-shift rule [44], to something different.

Moreover, we want to go beyond the restriction of quan-
tum circuits. Our inspiration comes from classical machine
learning examples that demonstrate the advantage of neural-
networks with program features (e.g. controls) over the plain
ones (e.g., classical circuits), e.g. [25, 27], which is also the
major motivation of promoting the the paradigm shift from
deep learning toward differentiable programming.

Augmenting VQCs with controls, at least for simple ones,
is not only feasible on NISQ machines, but also a logical

step for the study of their applications in machine learning.
Therefore, we are inspired to investigate the principles of
differentiable quantum imperative languages beyond
circuits. Indeed, we conduct one such case study in Section 8.
Research challenges & Solutions. We will rely on a few
notations that should be self-explanatory. Please refer to a
detailed preliminary on quantum information in Section 2.
Let us start with a simple classical program

MUL ≡ v3 = v1 × v2,

(1.1)

where v3 is the product of v1 and v2. Consider the differenti-
ation with respect to θ , we have

∂
∂θ

(MUL) ≡ v3 = v1 × v2;

(cid:219)v3 = (cid:219)v1 × v2 + v1 × (cid:219)v2,

(1.2)

(1.3)

where MUL keeps track of variables v1, v2, v3 and their deriva-
tives (cid:219)v1, (cid:219)v2, (cid:219)v3 at the same time. One simple yet important ob-
servation is that classical variables v1, v2, v3 are real-valued
and can be naturally differentiated.

Given that quantum states are represented by matrices,
what are the natural quantities to differentiate in the quan-
tum setting? One natural choice from the principles of quan-
tum mechanics is the (classical) read-outs of quantum sys-
tems through measurements, which we formulate as the
observable semantics of quantum programs. This natural
choice also serves the purpose of gradient computation of
loss functions in quantum machine learning, which are typi-
cally defined in terms of these read-outs. We directly model
the parameterization of quantum programs after VQCs, i.e.,
each unitary gate becomes classically parameterized. 1

To model the meaning of one quantum program com-
puting the derivative of another, we define the differential
semantics of programs. There is a subtle quantum-unique
design choice. The observable semantics of any quantum pro-
gram will depend on the observable and its input state. Thus,
any program computing its derivative could potentially de-
pend on these two extra factors. We find out this potential
dependence is undesirable and propose the strongest possi-
ble definition: i.e., one derivative computing program should
work for any pair of observables and input states. We demon-
strate that this strong requirement is not only achievable but
also critical for the composition of auto differentiation.

We are ready to describe the technical challenges for the
compositionality. Consider the following quantum program:

QMUL ≡ U1(θ ); U2(θ ),

(1.4)

which performs U1(θ ) and U2(θ ) gates sequentially. Note that
gate application is matrix multiplication in the quantum set-
ting. Roughly speaking, if the product rule of differentiation

1The above modeling of quantum programs is very different from classical
ones. It is unclear whether any reasonable analogue of classical chain-rule
and forward/backward mode can exist within quantum programs.

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

(as exhibited in (1.3)) remains in the quantum setting, at least
symbolically, then one should expect ∂
∂θ (QMUL) contains
∂
∂θ

(U1(θ )); U2(θ ) and U1(θ );

(U2(θ ))

∂
∂θ

(1.5)

However, we cannot run ∂

two different parts as sub-programs similarly in (1.3).
∂θ (U1(θ )); U2 and U1(θ ); ∂

∂θ (U2(θ ))
together due to the quantum no-cloning theorem [54]. This
is simply because they share the same initial state and we
cannot clone two copies of it. Note that this is not an issue
classically as we can store all vi , (cid:219)vi at the same time as in (1.3).
As a result, quantum differentiation needs to run multiple
(sub-)programs on multiple copies of the initial state.

This change poses a unique challenge for differentiation of
quantum composition: (1) we hope to have a simple scheme
of code transformation, ideally close-to-classical, for intu-
ition and easy implementation of the compiler, whereas it
needs to express correctly the collection of quantum pro-
grams during code transformation; (2) for the purpose of
efficiency, we also want to reasonably bound the number of
required copies of the initial states, which roughly refers to
the number of different quantum programs in the collection.
We develop a few techniques to achieve both goals at the
same time. First, we propose the so-called additive quantum
programs as a succinct intermediate representation for the
collection of programs during the code transformation. Now
the entire differentiation procedure will be divided into two
steps: (1) all code transformations happen on additive pro-
grams and are very similar to classical ones (see Figure 4) ; (2)
the collection of programs can be recovered by a compilation
procedure from any additive program. Additive quantum pro-
grams are equipped with a new sum operation that models
the multiple choices as exhibited in (1.5), which resembles a
similar idea in the differential lambda-calculus [14].

Second, we also design a new rule for ∂

∂θ (U (θ )) which
is slightly different from [18, 21, 32, 44, 45]. The existing
phase-shift rule makes use of two quantum circuits for one
differentiation, which causes a lot of inconvenience in the
formulation and potential trouble for efficiency. Instead, we
use only one extra ancilla as the control qubit to create a su-
perposition of two quantum circuits and effectively achieve
the same differentiation with only one quantum circuit. We
also conduct a careful resource analysis of our differentia-
tion procedure and show the number of required copies of
initial states is reasonable comparing to the classical setting.
The correctness of the code transformation of composition
critically relies on our design choice as well as the strong
definition related to the differential semantics.

With the previous setup, we can naturally build the dif-
ferentiation for quantum controls (i.e., the condition state-
ment). Note that a general solution for classical controls is
unknown [6] due to the non-smoothness of the guard. Simi-
lar to the classical setting [39], we only provide a solution to
deal with bounded loops and leave it open for general ones.

Contributions. We formulate the parameterized quantum
bounded while-programs with classically parameterized uni-
tary gates modelled after VQCs [17, 33, 38] and their realistic
examples on ion-trap machines, e.g. [58], in Section 3.

In Section 4, we illustrate our design of additive quantum
programs. Specifically, we add the syntax P1 +P2 to represent
the either-or choice between P1 and P2 in (1.5). We formu-
late its semantics and compilation rules that map additive
programs into collections of normal ones for our purpose.

In Section 5, we formulate the observable and the differ-
ential semantics of quantum programs and formally define
the meaning of program S ′(θ ) computing the differential
semantics of S(θ ) in the strongest possible sense.

In Section 6, we show that such a strong requirement is in-
deed achievable by demonstrating the code-transformation
rules for the differentiation procedure. Thanks to the use
of additive quantum programs, the code transformation is
much simplified and as intuitive as classical ones. We develop
a logic with the judgement S ′(θ )|S(θ ) stating that S ′(θ ) com-
putes the differential semantics of S(θ ). We prove it sound
and use it to show the correctness of the code transformation.
In Section 7, we conduct a resource analysis to further
justify our design. We show that the occurrence count of
parameters capture the extra resource required in both the
classical auto-differentiation and our scheme. Hence, our re-
source cost is reasonable compared with the classical setting.
Finally, in Section 8, we demonstrate the implementation
of our code transformation in OCaml and apply it to the
training of one VQC instance with controls via classical sim-
ulation. Specifically, this instance shows an advantage of con-
trols in machine learning tasks, which implies the advantage
of our scheme over previous ones that cannot handle controls.
We have also empirically verified the resource-efficiency of
our scheme on representative VQC instances.
Related classical work. There is an extensive study of au-
tomatic differentiation (AD) or differentiable programming
in the classical setting (e.g., see books [12, 28]). The most rele-
vant to us are those studies from the programming language
perspective. AD has traditionally been applied to imperative
programs in both the forward mode, e.g. [31, 53], and the
reverse mode, e.g., [48]. The famous backpropagation algo-
rithm [41] is also a special case of reserve-mode AD used to
compute the gradient of a multi-layer perceptron. AD has
also been recently applied to functional programs [15, 16, 37].
Motivated by the success of deep learning, there is significant
recent interest to develop both the theory and the implemen-
tation of AD techniques. Please refer to the survey [5] and
the keynote talk at POPL’18 [39] and [1] for more details.

2 Quantum Preliminaries

We present basic quantum preliminaries here (a summary of
notation in Table 1). Details are deferred to Appendix A.

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

Table 1. A brief summary of notation used in this paper

Spaces
States

Operations

H , A
(pure states)

L(H ) (Linear operators)
|ψ ⟩, |ϕ⟩;
|0⟩, |1⟩, |+⟩, |−⟩
ρ, σ ; |ψ ⟩⟨ψ |
U , V , σ ;
H, X , Z , X ⊗ X
(superoperators) E, F (general);

(density)
(unitaries)

Measurements M

Observables

O

Programs

(no parameters)
(parameterized)

Semantics

Code Process

Logic
Count

(additive)

(operational)
(denotational)
(observable)
(Transform)
(Compile)
(Judgement)
(Non-Abort)
(Occurrence)

m λm |ϕm⟩⟨ϕm |;

σ (θ )(notable examples)

Φ (quantum channels)
{Mm }m;
{|0⟩⟨0|, |1⟩⟨1|} (example)
(cid:205)
|0⟩⟨0| − |1⟩⟨1| (example)
P, Q
P(θ ), S(θ );
R ′
P(θ ), S(θ ) ;
∂
∂θ (S(θ )) (example)
⟨P, ρ⟩ → ⟨Q, ρ ′⟩ (steps)
[[P]]ρ = ρ ′
[[(O, ρ) → P(θ )]]
∂
∂θ (S(θ )) (example)
Compile(S ′(θ )) (example)
S ′(θ )|S(θ ) (example)
|# ∂
∂θ j
OCj (P(θ )) (example)

(P(θ ))| (example)

2.1 Math Preliminaries

Let n be a natural number. We refer to the complex vector
space Cn as an n-dimensional Hilbert space H . We use |ψ ⟩ to
denote a complex vector in Cn. The Hermitian conjugate of
|ψ ⟩ ∈ Cn is denoted by ⟨ψ |. The inner product of |ψ ⟩ and |ϕ⟩,
defined as the product of ⟨ψ | and |ϕ⟩, is denoted by ⟨ψ |ϕ⟩.
The norm of a vector |ψ ⟩ is denoted by ∥|ψ ⟩∥ = (cid:112)⟨ψ |ψ ⟩.

We define operators as linear maps between Hilbert spaces,
which can be represented by matrices for finite dimensions.
Let A be an operator and its Hermitian conjugate A†. A is
Hermitian if A = A†. The trace of A is the sum of the entries
on the main diagonal, i.e., tr(A) = (cid:205)
i Aii . ⟨ψ |A|ψ ⟩ denotes
the inner product of |ψ ⟩ and A|ψ ⟩. Hermitian operator A is
positive semidefinite if for all vectors |ψ ⟩ ∈ H , ⟨ψ |A|ψ ⟩ ≥ 0.

2.2 Quantum States and Operations

The state space of a qubit is a 2-dimensional Hilbert space.
Two important orthonormal bases of a qubit system are: the
computational basis with |0⟩ = (1, 0)† and |1⟩ = (0, 1)†; the ±
basis, consisting of |+⟩ = 1√
(|0⟩−|1⟩).
2
A pure quantum state is a unit vector |ψ ⟩. A mixed state,
which refers to an ensemble of pure states {(pi , |ψi ⟩)}i (each

(|0⟩+|1⟩) and |−⟩ = 1√
2

with probability pi ), can be represented by a density oper-
ator that is a trace-one positive semidefinite operator ρ =
(cid:205)
i pi |ψi ⟩⟨ψi |; ρ is a partial density operator if tr(ρ) ≤ 1. The
set of partial density operators on H is denoted by D(H ).
Operations on quantum systems can be characterized by
unitary operators. Denoting the set of linear operators on H
as L(H ), an operator U ∈ L(H ) is unitary if U †U = UU † =
I H. A unitary evolves a pure state |ψ ⟩ to U |ψ ⟩ , or a density
operator ρ to U ρU †. Common unitary operators include:
the Hadamard operator H , which transforms between the
computational and the ± basis via H |0⟩ = |+⟩ and H |1⟩ =
|−⟩; the Pauli X operator which performs a bit flip, i.e., X |0⟩ =
|1⟩ and X |1⟩ = |0⟩; Pauli Z which performs a phase flip, i.e.,
Z |0⟩ = |0⟩ and Z |1⟩ = −|1⟩; CNOT gate mapping |00⟩ (cid:55)→
|00⟩, |01⟩ (cid:55)→ |01⟩, |10⟩ (cid:55)→ |11⟩, |11⟩ (cid:55)→ |10⟩. More generally,
evolution of a quantum system can be characterized by an
admissible superoperator E, namely a completely-positive and
trace-non-increasing linear map from D(H ) to D(H ′).

k Ek ρE†

For every superoperator E, there exists a set of Kraus
operators {Ek }k such that E(ρ) = (cid:205)
k for any input
ρ ∈ D(H ). The Kraus form of E is therefore E = (cid:205)
k Ek ◦ E†
k .
The Schrödinger-Heisenberg dual of a superoperator E =
(cid:205)
k , denoted by E∗, is defined as follows: for every
state ρ ∈ D(H ) and any operator A, tr(AE(ρ)) = tr(E∗(A)ρ).
The Kraus form of E∗ is (cid:205)
k E†

k Ek ◦ E†

◦ Ek .

k

2.3 Quantum Measurements

m M †

Quantum measurements extracts classical information out of
quantum systems. A quantum measurement on a system over
Hilbert space H can be described by a set of linear operators
{Mm }m with (cid:205)
mMm = I H (identity matrix on H ). If we
perform a measurement {Mm }m on a state ρ, the outcome m
is observed with probability pm = tr(MmρM †
m) for each m,
and the post-measurement state collapses to MmρM †
m/pm.
3 Parameterized Quantum Bounded

While-Programs

We adopt the bounded-loop variant of the quantum while-
language developed by Ying [56], and augment it by parame-
terizing the unitaries, as this provides sufficient expressibility
for parameterized quantum operations: indeed, abort, skip
and initialization behave independently of parameters, while
“parameterized measurements” can be implemented with a
regular measurement followed by a parameterized unitary.
From here onward, v is a finite set of variables, and θ a

length-k vector of real-valued parameters.

3.1 Syntax

Define Var as the set of quantum variables. We use the sym-
bol q as a metavariable ranging over quantum variables and
define a quantum register q to be a finite set of distinct vari-
ables. For each q ∈ Var, its state space is denoted by Hq.
The quantum register q is associated with the Hilbert space

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

q ∈q Hq. 2 A T -bounded, k-parameterized quantum

Hq = (cid:203)
while-program is generated by the following syntax:
P(θ )

::= abort[q] | skip[q] | q := |0⟩ | q := U (θ )[q] |
case M[q] = m → Pm(θ ) end |

P1(θ ); P2(θ ) |
while(T ) M[q] = 1 do P1(θ ) done,

where

while(1) M[q] = 1 do P1(θ ) done

≡ case M[q] = {0 → skip, 1 → P1(θ ); abort},(3.1)

while(T ≥2) M[q] = 1 do P1(θ ) done

≡ case M[q] = {0 → skip, 1 → P1(θ ); while(T −1)}
Unparameterized programs can be obtained by fixing θ ∗ ∈ Rk
in some P(θ ). We denote the set of variables accessible to
P(θ ) as qVar(P(θ )); the collection of all “T -bounded while-
programs P(θ ) s.t. qVar(P(θ )) = v” as q-while(T )
(θ ), and
v
similarly, the unparameterized one as q-while(T )
v .

Now let us formally define parameteriztion of unitaries:
let θ := (θ1, · · · , θk ) (k ≥ 1). A k-parameterized unitary
U (θ ) is a function Rk → L(H ) s.t. (1) given any θ ∗ ∈ Rk ,
U (θ ∗) is an unitary on H , and (2) the parameterized-matrix
representation of U (θ ) is entry-wise smooth.

A important family is the single-qubit rotations about the

Pauli axis X , Y , Z with angle θ (matrix exponential here):
(cid:18) −iθ
2

, σ ∈ {X , Y , Z } .

Rσ (θ ) := exp

σ

(cid:19)

(3.2)

One can also extend Pauli rotations to multiple qubits. For ex-
ample, consider two-qubit coupling gates {Rσ ⊗σ := exp( −iθ
2 σ ⊗
σ )}σ ∈ {X,Y,Z }, which generate entanglement between two
qubits. Combined with single-qubit rotations, they form a
universal gate set for quantum computation. Another impor-
tant feature of these gates is that they can already be reliably
implemented in such as ion-trap quantum computers [58].
As a result, we will work mostly with these gates in the
rest of this paper. However, note that one can easily add and
study other parameterized gates in our framework as well.
The language constructed above is similar to their classical
counterparts. (0) abort terminates the program, outputting
0 ∈ D(Hq). (1) skip does nothing to states in D(Hq). (2)
q := |0⟩ sets quantum variable q to the basis state |0⟩. The
underlying quantum procedure is to apply super-operators
Ebool
q→0(·))3 to q and identity operations to the
q→0(·) (or Eint
rest of variables. The correlation between q and the rest of
quantum variables could be potentially disturbed. (3) for any
θ ∗ ∈ Rk , q := U (θ ∗)[q] applies the unitary U (θ ∗) to the qubits
in q. (4) Sequencing has the same behavior as its classical

2If type(q) = Bool then Hq = span{ |0⟩, |1⟩ }. If type(q) = Bounded Int
then Hq is with basis { |n ⟩ : n ∈ [−N , N ]} (N ∈ Z+) for some finite N .
We require the Hilbert space to be finite dimensional for implementation.
q→0(ρ) = |0⟩q ⟨0|ρ |0⟩q ⟨0 | + |0⟩q ⟨1|ρ |1⟩q ⟨0| and EB−int
q→0 (ρ) =
3 Ebool
n=−N |0⟩q ⟨n |ρ |n ⟩q ⟨0| (N ∈ Z+).
(cid:205)N

counterpart. (5) for θ ∗ ∈ Rk , case M[q] = m → Pm(θ ∗) end
performs the measurement M = {Mm } on the qubits in q, and
executes program Pm(θ ∗) if the outcome of the measurement
is m. The bar over m → Pm indicates that there may be one
or more repetitions of this expression. (6) while(T ) M[q] =
1 do P1(θ ∗) done performs the measurement M = {M0, M1}
on q, and terminates if the outcome corresponds to M0, or
executes P1(θ ∗) then reiterates (T ≥ 2) / aborts (T = 1)
otherwise. The program iterates at most T times.

We highlight two differences between quantum and clas-
sical while languages: (1) Qubits may only be initialized to
the state |0⟩. There is no quantum analogue for initialization
to any expression (i.e. x := e) due to the no-cloning theorem
of quantum states. Any state |ψ ⟩ ∈ Hq, however, can be
constructed by applying some unitary U to |0⟩. (2) Evaluat-
ing the guard of a case statement or loop, which performs a
measurement, potentially disturbs the state of the system.
3.2 Operational and Denotational Semantics

We present the operational semantics of parameterized pro-
grams in Figure 1a. Transition rules are represented as ⟨P, ρ⟩
→ ⟨P ′, ρ ′⟩, where ⟨P, ρ⟩ and ⟨P ′, ρ ′⟩ are quantum config-
urations.4 In configurations, P (or P ′) could be a quantum
program or the empty program ↓, and ρ and ρ ′ are partial
density operators representing the current state. Intuitively,
in one step, we can evaluate program P on input state ρ to
program P ′ (or ↓) and output state ρ ′. In order to present
the rules in a non-probabilistic manner, the probabilities
associated with each transition are encoded in the output
partial density operator. For each index m of branches in a
loop/control statement, the superoperator Em is defined by
Em(ρ) = MmρM †

m, yielding the post-measurement state.

We present the denotational semantics of parameterized
programs in 1b, defining [[P]] as a superoperator on ρ ∈
Hv [56]. For more details we refer the reader to Ying [55, 56].
We have the following connection between the deno-
tational semantics and operational for parameterized pro-
grams: in short, the meaning of running program P(θ ∗) on
input state ρ and any θ ∗ ∈ Rk is the sum of all possible output
states with multiplicity, weighted by their probabilities.

Proposition 3.1 ([56]). ∀P(θ ) ∈ q-while(T )
v
cific θ ∗ ∈ Rk , ρ ∈ D(H v ),
[[P(θ ∗)]](ρ) = (cid:213)

{|ρ ′ : (P(θ ∗), ρ) →∗ (↓, ρ ′)|}.

(θ ), and any spe-

(3.3)

Here →∗ is the reflexive, transitive closure of → and {| · |}
denotes a multi-set.

We close the section with a notion arising from the fol-
lowing observation: some programs, while syntactically not
“abort[q]”, semantically aborts. Simple examples include U (θ );
abort or a case sentence that has abort on each branch. These

4Recall that, fixing arbitrary θ ∗ ∈ Rk , both semantics reduce to those of
unparameterized programs, so for compactness we write P for P (θ ∗), etc.

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

(Abort) ⟨abort[q], ρ⟩ → ⟨↓, 0⟩

(Skip) ⟨skip[q], ρ⟩ → ⟨↓, ρ⟩

(Sum Components) ⟨P1(θ ∗) + P2(θ ∗), ρ⟩ → ⟨P1(θ ∗), ρ⟩,
⟨P1(θ ∗) + P2(θ ∗), ρ⟩ → ⟨P2(θ ∗), ρ⟩

(Init) ⟨q := |0⟩, ρ⟩ → ⟨↓, ρq
0
(ρ)
(ρ)

(cid:40)Ebool
q→0
EB−int
q→0

where ρq
0

=

⟩

if type(q) = Bool
if type(q) = Bdd Int

Figure 2. additive parameterized quantum bounded while-
programs: operational semantics. We fix θ ∗ ∈ Rk and inherit
all the other rules from parameterized programs in Fig. 1a.

(Unitary) ⟨q := U (θ ∗)[q], ρ⟩ → ⟨↓, U (θ ∗)ρU †(θ ∗)⟩
⟨P1(θ ∗), ρ⟩ → ⟨P ′
⟨P1(θ ∗); P2(θ ∗), ρ⟩ → ⟨P ′

1(θ ∗), ρ ′⟩
1(θ ∗); P2(θ ∗), ρ ′⟩

(Sequence)

(Case m) ⟨case M[q] = m → Pm (θ ∗) end, ρ⟩ →

⟨Pm (θ ∗),Em (ρ)⟩ , ∀ outcome m of M = {Mm }

(While(T ) 0) ⟨while(T ) M[q] = 1 do P1(θ ∗) done, ρ⟩ →

⟨↓, E0(ρ)⟩

(While(T ) 1) ⟨while(T ) M[q] = 1 do P1(θ ∗) done, ρ⟩ →

4 Additive Parameterized Quantum

Bounded While-Programs

We introduce a variant of additive quantum programs as
a succinct way to describe the collection of programs that
are necessary to compute the derivatives. To that end, we
introduce our design of the syntax and the semantics of
additive quantum programs as well as a compilation method
that turns any additive quantum program into a collection of
normal programs for the actual computation of derivatives.

⟨P1(θ ∗); while(T −1),E1(ρ)⟩

4.1 Syntax

(a)

[[abort[q]]]ρ =
[[skip[q]]]ρ =
[[q := |0⟩]]ρ = Ebool
q→0
U (θ ∗)ρU †(θ ∗)

0
ρ

(ρ) or EB−int
q→0

(ρ)

[[case M[q] = m → Pm (θ ∗) end]]ρ = (cid:205)
[[while(T ) M[q] = 1 do P1(θ ∗) done]]ρ = (cid:205)T −1

[[q := U (θ ∗)[q]]]ρ =
[[P1(θ ∗); P2(θ ∗)]]ρ = [[P2(θ ∗)]]([[P1(θ ∗)]]ρ)
m [[Pm (θ ∗)]]Em (ρ)
n=0 E0◦

([[P1(θ ∗)]] ◦ E1)n (ρ)

(b)

Figure 1. Parameterized T -bounded quantum while pro-
grams: (a) operational semantics (b) denotational semantics.

programs essentially don’t contribute to the finite computa-
tion output, as semantically aborted programs always result
in zero output state 0.

We formalize this concept (essential-abortion for unpa-
rameterized programs may be analogously defined) so that
the compilation of our programs could be optimized:

Definition 3.2 (“Essentially Abort”). Let P(θ ) ∈ q-while(T )
v
P(θ ) “ essentially aborts” if one of the following holds:

(θ ).

1. P(θ ) ≡ abort[q];
2. P(θ ) ≡ P1(θ ); P2(θ ), and either P1(θ ) or P2(θ ) essentially

aborts;

3. P ≡ case M[q] = m → Pm(θ ) end, and each Pm(θ )

essentially aborts.

We adopt the convention to use underlines to indicate ad-
ditive programs, such as P(θ ), to distinguish from normal
program P(θ ). The syntax of P(θ ) is given by

P(θ )

::= abort[q] | skip[q] | q := |0⟩ | q := U (θ )[q] |

P1(θ ); P2(θ ) | case M[q] = m → Pm(θ ) end |
while(T ) M[q] = 1 do P1(θ ) done | P1(θ ) + P2(θ ),

where the only new syntax + is the additive choice. Intu-
itively, P1(θ ) + P2(θ ) allows the program to either execute
P1(θ ) or P2(θ ) nondeterminisitcally. The denotational seman-
tics will include all possible execution traces. We assume
+ has lower precedence order than composition, and is left
associative.5 If P(θ ) = P1(θ ) + P2(θ ), then qVar(P(θ )) ≡
qVar(P1(θ )) ∪ qVar(P2(θ )). Denote the collection of all non-
deterministic P(θ ) s.t. qVar(P(θ )) = v as add-q-while(T )
(θ ).
v

4.2 Operational and Denotational Semantics

We exhibit operational semantics in Figure 2 and define a sim-
ilar denotational semantics for any P(θ ∗) ∈ add-q-while(T )
v

(θ ).

Definition 4.1 (Denotational Semantics). Fix θ ∗. ∀ρ ∈ D(H v ),

[[P(θ ∗)]](ρ) ≡ {|ρ ′ : ⟨P(θ ∗), ρ⟩ →∗ ⟨↓, ρ ′⟩|}.

(4.1)

Note that there is no sum in (4.1) compared with (3.3).
This is because we want to capture the behavior of + by stor-
ing all possible execution traces in a multi-set. This resem-
bles the idea of the sum operator in the differential lambda-
calculus [14].

5E.g., X + Y ; Z = X + (Y ; Z ), X + Y + Z := (X + Y ) + Z .

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

4.3 Compilation Rules

We exhibit the compilation rules in Figure 3 as a way to
transform an additive program P(θ ) into a multiset of normal
programs. The compiled set of programs will be later used in
the actual implementation of the differentiation procedure.
Our compilation rule is also well-defined as it is compatible
with the denotational semantics and operational semantics
of P(θ ) in the following sense:
Proposition 4.2. Denoting with (cid:221) the union of multisets,
then for any ρ ∈ D(H v ),

{|ρ ′ : ρ ′ (cid:44) 0, ρ ′ ∈ [[P(θ ∗)]]ρ|} =

(cid:222)

{|ρ ′ (cid:44) 0 : ⟨Q(θ ∗), ρ⟩ →∗ ⟨↓, ρ ′⟩|}.

(4.2)

Q (θ )∈Compile(P (θ ))

Proof. Structural Induction. See Appendix C.1 for details. □

Note that (4.2) removes 0 from the multi-set as we are only
interested in non-trivial final states. Moreover, in Compile(P(θ )),
some programs may essentially abort (Definition 3.2). For
implementation, we are interested in the number of Q(θ ) ∈
Compile(P(θ )) that do not essentially abort:

Definition 4.3. The number of non-aborting programs of
P(θ ), denoted as |#P(θ )|, is defined as
|#P(θ )| = |Compile(P(θ )) \ {|Q(θ ) ∈ Compile(P(θ )) :
Q(θ ) essentially aborts.|}|

where |C | is the cardinality of a multiset C and C0 ∖C1 denotes
the multiset difference of C0 and C1.

We remark that |#P(θ )| could be exponentially large for
general P(θ ), e.g., P(θ ) ≡ (Q1 +R1); ...; (Qn +Rn). However, as
we show in Section 7, for instances of additive programs from
differentiation, this number is well bounded. (i.e., instances
with exponential blow-up are irrelevant in our context.)
Example 4.1 (Generic-Case). Consider the following simple
program with the case statement

P(θ ) ≡ case M[q] = 0 → P1(θ ) + P2(θ ),

1 → P3(θ )

where P1(θ ), P2(θ ), P3(θ ) ∈ q-while(T )
(θ ), none of them essen-
v
tially aborts, and each of P1(θ ), P2(θ ), P3(θ ) contains no control
gates. Then for any ρ ∈ D(H v ), fixing θ ∗ we have

⟨P(θ ∗), ρ⟩

⟨P(θ ∗), ρ⟩

⟨P(θ ∗), ρ⟩

(Case m)

→ ⟨P1(θ ∗) + P2(θ ∗), M0ρM †
0 ⟩
(Sum)
→ ⟨P1(θ ∗), M0ρM †
0 ⟩
⟨↓, [[P1(θ ∗)]](M0ρM †
→∗
(Case m)
→ ⟨P1(θ ∗) + P2(θ ∗), M0ρM †
0 ⟩
(Sum)
0 ⟩→∗⟨↓, [[P2(θ ∗)]](M0ρM †
→ ⟨P2(θ ∗), M0ρM †
→ ⟨P3(θ ∗), M1ρM †
1 ⟩
→∗

⟨↓, [[P3(θ ∗)]](M1ρM †

(Case m)

0 )⟩;

1 )⟩

0 )⟩;

(Atomic)

(Sequence)

(Case m)
(While(T ))
(Sum )

Compile(P(θ )) ≡ {|P(θ )|},
if P(θ ) ≡ abort[v] | skip[v] | q := |0⟩
|v := U (θ )[v].
Compile(P1(θ ); P2(θ )) ≡



Compile(case) ≡ FB(case), described in Fig.3b.
Compile(while(T)) : use (Case m) and (Sequence).
Compile(P1(θ ) + P2(θ )) ≡

{|abort|}, if Compile(P1(θ )) = {|abort|};
{|abort|}, if Compile(P2(θ )) = {|abort|};
{|Q1(θ ); Q2(θ ) : Qb (θ ) ∈ Compile(Pb (θ ))|},
otherwise.

Compile(P1(θ ))(cid:221)Compile(P2(θ )), if ∀b ∈ {1,
2}, Compile(Pb (θ )) (cid:44) {|abort|};
Compile(P1(θ )), if Compile(P2(θ )) = {|abort|},

Compile(P1(θ )) (cid:44) {|abort|};

Compile(P2(θ )), if Compile(P1(θ )) = {|abort|},

Compile(P2(θ )) (cid:44) {|abort|};






{|abort|}, otherwise

(a)

1. ∀m ∈ [0, w], let Cm denote the sub-multiset of Compile(Pm (θ ))
composed of programs that do not essentially abort; without
loss of generality, assume |C0| ≥ |C1| ≥ · · · ≥ |Cw |.

2. If all Cm ’s are empty, return FB(case) ≡ {|abort[v]|}; else, pad

each Cm to size |C0| by adding “abort[v]”.

3. ∀m ∈

[0, w],

index programs in Cm as {|Qm,0(θ ), · · · ,
=

case M[q]

Qm, |C0 |−1(θ )|}. Return FB(case) ≡ {|
m → Qm, j ∗ end |}j ∗ with 0 ≤ j∗ ≤ |C0| − 1.

(b)

Figure 3. nondeterministic programs: (a) compilation rules.
(b) “Fill and Break” (“FB(•)”) procedure for computing
Compile(case). case stands for case M[q] = m → Pm(θ ) end;
while(T) stands for while(T ) M[q] = 1 do P1(θ ) done. Here
(cid:221) denotes union of multisets. One may observe from a rou-
tine structural induction and the definition of “essentially
abort” that: for all P(θ ), either Compile(P(θ )) = {|abort|}, or
Compile(P(θ )) does not contain essentially abort programs.

Hence by Definition 4.1.

[[P(θ ∗)]]ρ = {|[[P1(θ ∗)]](M0ρM †

0 ), [[P2(θ ∗)]](M0ρM †
0 ),
[[P3(θ ∗)]](M1ρM †
1 )|}

We verify computation results from the compilation rules are
consistent with this. Writing “compilation rule” as “CP” for
short, one observes Compile(P1(θ ) + P2(θ )) CP,Sum= {|P1(θ ), P2(θ )|},
while Compile(P3(θ )) = {|P3(θ )|} since we assumed non-
essentially-abortness. Apply our “fill and break” procedure
to obtain C0 = {|P1(θ ), P2(θ )|}, C1 = {|P3(θ ), abort[v]|}.

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

Compile(P(θ )) = (cid:110)

case M[q] = 0 → P1(θ ),
1 → P3(θ ),

|
case M[q] = 0 → P2(θ ),

1 → abort[v]

(cid:111)

|

It’s easy to check that evolving pursuant to the normal pro-
grams operational semantics (Fig 1) agrees with [[P(θ ∗)]]ρ.

5 Observable and Differential Semantics

To capture physically observable quantities from quantum
systems, physicists propose the notation of observable which
is a Hermitian matrix over the same space. Any observ-
able O is a combination of information about quantum mea-
surements and classical values for each measurement out-
come. To see why, let us take its spectral decomposition of
O = (cid:205)
m λm |ψm⟩⟨ψm |. Then {|ψm⟩⟨ψm |}m form a projective
measurement. We can design an experiment to perform this
projective measurement and output λm when the outcome
is m. The expectation of the output is exactly given by

tr(Oρ) = (cid:213)

λmtr(MmρM †

m).

(5.1)

m

The expectation tr(Oρ) represents meaningful classical in-
formation of quantum systems, which is also used in the
loss functions in quantum machine learning applications.
Thus, given any observable O, we will define the observable
semantics of quantum programs as both the mathematical
object to take derivatives from the original programs and
the read-out of the programs that compute these derivatives.
One can repeat the {|ψm⟩⟨ψm |}m measurement and use
the statistical information to recover tr(Oρ). The number of
iterations depends on the additive precision δ and the norm
of O. To simplify our presentation, also to make a precise
resource count as detailed in Section 7, we assume that6

− I H ⊑ O ⊑ I H .

(5.2)

Note that the observable O is different from quantum pred-
icate P (0 ⊑ P ⊑ I ), which is defined [13] as the quantum
analogue of continuous logic with true values in [0, 1]. By
statistically concentration bounds (e.g. the Chernoff bound),
to approximate tr(Oρ) with additive error δ , one needs to
repeat O(1/δ 2) times with O(1/δ 2) copies of initial states.

5.1 Observable Semantics

We define the observable semantics of both normal (denoted
by P(θ ), P ′(θ )) and additive (denoted by S(θ ), S ′(θ )) parame-
terized programs as follows.
Definition 5.1 (Observable Semantics). ∀P(θ ) ∈ q-while(T )
v
any observable O ∈ Ov and input state ρ ∈ D(H v ), the ob-
servable semantics of P, denoted [[(O, ρ) → P(θ )]], is
[[(O, ρ) → P(θ )]](θ ∗) ≡ tr(O[[P(θ ∗)]]ρ), ∀θ ∗ ∈ Rk .

(5.3)
Namely, [[(O, ρ) → P(θ )]] is a function from Rk to R whose
value per point is given by (5.3).

(θ ),

6 ⊑ is defined by A ⊑ B ⇐⇒ B − A positive semidefinite.

Similarly, for any S(θ ) ∈ add-q-while(T )
v

(S(θ )) = {|Pi (θ )|}t
able semantics is given by, ∀θ ∗ ∈ Rk ,

i=1 where Pi (θ ) ∈ q-while(T )

v

(θ ) with Compile
(θ ), its observ-

[[(O, ρ) → S(θ )]](θ ∗) ≡

(cid:213)

i ∈[1,t ]

[[(O, ρ) → Pi (θ )]](θ ∗).

(5.4)

To compute gradients of quantum observables for each
parameter, one needs an ancilla variable as hinted by results
in quantum information theory about gradient calculations
for simple unitaries (e.g., Bergholm et al. [8], Schuld et al.
[44]). To that end, we can easily extend quantum programs
with ancilla variables. For each j ∈ [1, k], the j-th ancilla of
q-while(T )
(θ ) is a quantum variable denoted by Aj,v disjoint
v
from v. We write A instead of Aj,v when j, v are clear from
context. Ancilla A could consist of any number of qubits
while we will mostly use one-qubit A in this paper.

We will only consider programs augmented with one an-
cilla variable Aj at any time. (So let us fix j for the following
discussion). We will then consider programs that operate on
the larger space D(Hv∪{A}) and an additional observable A
to define the observable semantics with ancilla.

Definition 5.2 (Observable Semantics with Ancilla). Given
any P ′(θ ) ∈ q-while(T )
v∪{Aj,v }(θ ), any observable O ∈ Ov , in-
put state ρ ∈ D(H v ), and moreover the observable OA on
ancilla A, the observable semantics with ancilla of P, over-
loading the notation [[(O, ρ) → P ′(θ )]], is

(cid:16) (cid:0)OA ⊗ O (cid:1)[[P ′(θ ∗)]]((|0⟩{A} ⟨0|) ⊗ ρ)

[[((O, OA), ρ) → P ′(θ )]](θ ∗) ≡
, ∀θ ∗ ∈ Rk .

(cid:17)

tr

(5.5)

Again, [[((O, OA), ρ) → P(θ )]] is a function from Rk to R
whose value per point is given by (5.5).
Similarly, for S ′(θ ) ∈ add-q-while(T )

v∪{Aj,v }(θ ) s.t. Compile
v∪{Aj,v }(θ ), its

i (θ ) ∈ q-while(T )

(S ′(θ )) = {|P ′
i (θ )|}t
observable semantics is: ∀θ ∗ ∈ Rk ,

i=1 where P ′

[[((O, OA), ρ) → S ′(θ )]](θ ∗) ≡

(cid:213)

i ∈[1,t ]

[[((O, OA), ρ) → P ′

i (θ )]](θ ∗).

The only difference from the normal observable semantics
lies in (5.5), where we initialize the ancilla with |0⟩, which is
a natural choice and evaluate the observable OA ⊗ O. As we
will see in the technique, the independence between OA and
O in the form of OA ⊗ O will help us obtain the strongest
guarantee of our differentiation procedure.

5.2 Differential Semantics

Given the definition of observable semantics, its differential
semantics can be naturally defined by

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

Definition 5.3 (Differential Semantics). Given additive pro-
gram S(θ ) ∈ add-q-while(T )
(θ ), its j-th differential seman-
v
tics is defined by

∂
∂θj

([[(O, ρ) → S(θ )]]),

(5.6)

which is again a function from Rk to R. Moreover, for any
S ′(θ ) ∈ add-q-while(T )
v∪{A}(θ ) with ancilla A, we say that
“S ′(θ ) computes the j-th differential semantics of S(θ )” if and
only if there exists an observable OA on ancilla A for S ′(θ ) such
that ∀O ∈ Ov , ρ ∈ D(H v ),

[[((O, OA), ρ) → S ′(θ )]] = ∂
∂θj

([[(O, ρ) → S(θ )]]).

(5.7)

We remark that (5.6) is well defined because [[(O, ρ) →
S(θ )]] is a function from Rk to R. It is also a smooth function
because we assume that parameterized unitaries are entry-
wise smooth, and the observable semantics is obtained by
multiplication and addition of such entries. Note also that
there is one specific choice of OA in our current design. We
leave it as a parameter to allow flexibility for future designs.
We also remark that the order of quantifiers in (5.7) is the
strongest that one can hope for. This is because the observ-
able semantics of S(θ ) will depend on O and ρ in general.
Thus, the program to compute its differential semantics could
also depend on O and ρ in general. However, in our defini-
tion, S ′(θ ) is a single fixed program that works for any O
and ρ regardless of the seemingly complicated relationship.
This definition is consistent with the classical case where a
single program can compute the derivatives for any input.
We can achieve the same definition in the quantum setting
and it is critical in the proof of Theorem 6.2 (item (5)).

6 Code Transformations and the

Differentiation Logic

We describe the code transformation rules of the differentia-
tion operator ∂
∂θ (·) in Section 6.1. We also define a logic and
prove its soundness for reasoning about the correctness of
these code transformations, with the following judgement
S ′(θ )|S(θ ),
(6.1)
which states that S ′(θ ) computes the differential semantics of
S(θ ) in the sense of Definition 5.3. We fix θ = θj and hence
A stands for Aj,v and ∂

through this section.7

∂θ for ∂
∂θ j

6.1 Code Transformations

We first define some gates associated with the single-qubit
rotation and the two-qubit coupling gates, which will appear
in the code transformation rules. Let A be a single qubit.

7If A already exists, i.e., S (θ ) ∈ add-q-while(T )
(θ ), we treat v new as
v old ∪ Aold and add Anew. Any observable O on v old becomes OAold
⊗ O
on v new. Both Aold and Anew are initialized to |0⟩ in observable semantics.

v ∪{A}

(Trivial)

(Trivial-U)
(1-qb)
(2-qb)

(Sequence)

(Case)

(while(T ))
(S-C)

∂

∂θ (abort[v]), ∂

∂θ (skip[v]), ∂

∂θ (q := |0⟩) ≡
abort[v ∪ {A}].

∂

∂

∂θ (v := U (θ )[v]) ≡ abort[v ∪ {A}], if θj (cid:60) θ .
∂θ (q1 := Rσ (θ )[q1]) ≡ A, q1 := R ′
σ (θ )[A, q1].
∂θ (q1, q2 := Rσ ⊗σ (θ )[q1, q2]) ≡
∂
A, q1, q2 := R ′
σ ⊗σ (θ )[A, q1, q2].
∂θ (S1(θ ); S2(θ )) ≡ (S1(θ ); ∂
∂

∂θ (S2(θ ))) +
( ∂
∂θ (S1(θ )); S2(θ )).

∂

∂θ (case M[q] = m → Sm(θ ) end) ≡

case M[q] = m → ∂
Use (Case) and (Sequence).
∂θ (S1(θ ) + S2(θ )) ≡ ∂
∂

∂θ (Sm(θ )) end.

∂θ (S1(θ )) + ∂

∂θ (S2(θ )).

Figure 4. Code Transformation Rules. For (1-qb Rotation)
and (2-qb Coupling), (σ ∈ {X , Y , Z }); R ′
σ ⊗σ (θ ) are as
in Definition 6.1. θj (cid:60) θ means “the unitary U (θ ) trivially
uses θj ”: for example in P(θ ) ≡ RX (θ1); RZ (θ2), θ = (θ1, θ2)
and RX (θ1) trivially uses θ2.

σ (θ ), R ′

Definition 6.1.

1. Consider unitary Rσ (θ ) where σ ∈

{X , Y , Z }. We define unitary C_Rσ (θ ) as
C_Rσ (θ ) ≡ |0⟩A⟨0| ⊗ Rσ (θ ) + |1⟩A⟨1| ⊗ Rσ (θ +π ).
σ (θ ) as

We also define a new gadget program R ′
σ (θ )[A, q1] ≡ A := H [A]; A, q1 := C_Rσ (θ )[A, q1];

R ′

(6.2)

(6.3)
2. Substituting σ ⊗σ for σ and q1, q2 for q1 in Eqns (6.2,6.3),

A := H [A].

one defines C_Rσ ⊗σ (θ ), R ′

σ ⊗σ (θ ).

For 1-qubit rotation Rσ (θ ), the “controlled-rotation” gate
C_Rσ (θ ) maps |0, q1⟩ (cid:55)→ |0⟩ ⊗ Rσ (θ ) |q1⟩, and |1, q1⟩ (cid:55)→ |1⟩ ⊗
Rσ (θ +π ) |q1⟩; R ′
σ (θ ) conjugates C_Rσ (θ ) with Hadamard.
Similarly for corresponding two-qubit coupling gates.

We exhibit our code transformation rules in Figure 4. For
Unitary rules we only include 1-qubit rotations and two-
qubit coupling gates, since they form a universal gate set
and are easy to implement on quantum machines. It is also
possible to include more unitary rules (e.g., by following the
calculations in [44]), which we will leave as future directions.

6.2 The differentiation logic and its soundness

We develop the differentiation logic given in Figure 5 to rea-
son about the correctness of code transformations. It suffices
to show that our logic is sound. For ease of notation, in fu-
ture analysis we write ∂
∂θ (P(θ )) when
P(θ ) ∈ q-while(T )
v

∂θ (P(θ )) in place of ∂

(θ ).

Theorem 6.2 (Soundness). Let S(θ ) ∈ add-q-while(T )
v
S ′(θ ) ∈ add-q-while(T )
S ′(θ ) computes the differential semantics of S(θ ).

(θ ),
v∪{A}(θ ). Then, S ′(θ )|S(θ ) implies that

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

(Abort)

∂
∂θ (abort[v])|abort[v]

(Skip)

∂
∂θ (skip[v])|skip[v]

(Initialization)

(Trivial-Unitary)

(Rot-Couple)

(Sequence)

(Case)

(While(T ))

(Sum Component)

∂

∂θ (q := |0⟩)|(q := |0⟩)

∂

θj (cid:60) θ
∂θ (q = U (θ )[v])|q = U (θ )[v]
∂θ (q = Rσ (θ )[v])|(q = Rσ (θ )[v])
∂
∂θ (S0(θ ))|S0(θ )

∂
∂θ (S1(θ ))|S1(θ )

∂

∂
∂θ (S0(θ ); S1(θ ))|(S0(θ ); S1(θ ))
∂θ (Sm(θ ))|Sm(θ )

∀m, ∂

∂

∂θ (case M[q] = m → Sm(θ ) end)|
case M[q] = m → Sm(θ ) end
∂
∂θ (S1(θ ))

(cid:12)
(cid:12)
(cid:12)S1(θ )

∂θ (while(T ) M[q] = 1 do S1(θ ) done)|
∂
while(T ) M[q] = 1 do S1(θ ) done
∂
∂
∂θ (S0(θ ))|S0(θ )
∂θ (S1(θ ))|S1(θ )
∂θ (S0(θ ) + S1(θ ))|(S0(θ ) + S1(θ ))
∂

Figure 5. The differentiation logic. Wherever applicable,
q ∈ v, q ⊆ v, Si (θ ) ∈ add-q-while(T )
(θ ). In (Rot-Couple),
v
σ ∈ {X , Y , Z , X ⊗ X , Y ⊗ Y , Z ⊗ Z }.

Let us highlight the ideas behind the proof of the sound-
ness and all detailed proofs are deferred to Appendix D. First
remember that θ = θj and for all the proofs we can choose
ZA = |0⟩⟨0| − |1⟩⟨1| as the observable on the one-qubit an-
cilla A. Thus, we will omit ZA and overload the notation,
∀P ′(θ ) ∈ q-while(T )

v∪{A}(θ ):

[[(O, ρ) → P ′(θ )]] means [[((O, ZA), ρ) → P ′(θ )]],

(6.4)

to simplify the presentation. We make similar overloading
convention for S ′(θ ) ∈ add-q-while(T )
v∪{A}(θ ). Let us go
through these logic rules one by one.

1. Abort, Skip, Initialization, Trivial-Unitary rules work be-

cause these statements do not depend on θ .

2. Since While(T ) can be deemed as a macro of other state-
ments, the correctness of While(T ) rule follows by unfolding
while(T ) and applying other rules.

3. The Sum Component rule is due to the property of observ-

able semantics ([[·]]) and additive operator (+):

5. The proof of the Sequence rule relies very non-trivially
on our design of the observable semantics with ancilla
(Definition 5.2) and the strong requirement of computing
differential semantics in Definition 5.3. Firstly, note that

[[(O, ρ) →

∂
∂θ

(S0(θ ); S1(θ ))]] = [[(O, ρ) → ∂

+[[(O, ρ) → S0(θ ); ∂

∂θ (S0(θ )); S1(θ )]]
∂θ (S1(θ ))]].

We use the induction hypothesis to reason about each
term above. Consider the case S0(θ ) = S0(θ ) and S1(θ ) =
S1(θ ). Note that S0(θ ), S1(θ ) ∈ q-while(T )
(θ ) and ∂
∂θ (S0(θ )),
v
∂θ (S1(θ )) ∈ add-q-while(T )
∂
v∪{A}(θ ). First, we show

∂
∂θ

[[(O, ρ) → S0(θ );

(S1(θ ))]] = [[(O, [[S0(θ )]](ρ)) →

(S1(θ ))]].
(6.6)
This is because ∂
∂θ (S1(θ )) computes the derivative for any
input state and observable. We simply choose the input
state [[S0(θ )]](ρ) and observable O. Secondly, we show

∂
∂θ

∂
∂θ

∂
∂θ

[[(O, ρ) →

(S0(θ )); S1(θ )]] = [[([[S1(θ )]]∗(O), ρ) →

(S0(θ ))]].
(6.7)
For (6.7), we don’t change the state ρ but change the ob-
servable O by applying the dual super-operator [[S1(θ )]]∗.
Since ∂
∂θ (S0(θ )) computes the derivative for any input state
and any observable, we choose the input state ρ and observ-
able [[S1(θ )]]∗(O). The dual super-operator [[S1(θ )]]∗ has the
property that tr(O[[S1(θ )]](ρ)) = tr([[S1(θ )]]∗(O)ρ), which
corresponds to the Schrodinger picture (evolving states)
and Heisenberg picture (evolving observables) respectively
in quantum mechanics.

6. The proof of the Case rule basically follows from the linear-
ity of the observable semantics and the smooth semantics of
Case. It is interesting to compare with the classical case [6]
where the non-smoothness of the guard causes an issue for
auto differentiation.

Example 6.1 (Simple-Case). Consider the following simple
instantiating of Example 4.1

P(θ ) ≡ case M[q1] = 0 → RX (θ )[q1]; RY (θ )[q1],

1 → RZ (θ )[q1]

∂
∂θ

∂
∂θ
which follows from our definition design.

([[P1 + P2]]) = [[

(P1)]] + [[

∂
∂θ

(P2)]],

(6.5)

Let us apply code transformation and compilation. Let CT, CP
to denote “code transformation” and “compilation”, and “Seq”
and “Rot” denote Sequence and Rotation rules resp.

4. Our Rot-Couple rule is different from the phase-shift rule
in [44] by using only one circuit in derivative computing.
However, the proof of the Rot-Couple rule is largely inspired
by the one of the phase-shift rule.

∂
∂θ

(P(θ )) CT,case=

case M[q1] = 0 → ∂

∂θ (RX (θ )[q1];
RY (θ )[q1]),
∂θ (RZ (θ )[q1])

1 → ∂

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

CT,Seq+Rot=

Compile(•)
(cid:55)−→

(cid:110)

|

case M[q1] = 0 → (R ′

X (θ )[A, q1];
RY (θ )[q1])+
(RX (θ )[q1];
R ′
Z (θ )[A, q1]

Y (θ )[A, q1]),

1 → R ′

case M[q1] = 0 → R ′

X (θ )[A, q1];

RY (θ )[q1],

1 → R ′

Z (θ )[A, q1],

case M[q1] = 0 → RX (θ )[q1];

R ′
1 → abort.

Y (θ )[A, q1],

(cid:111)

|

7 Execution and Resource Analysis

(θ ) and the parameter θ .

In this section we illustrate the execution of the entire differ-
entiation procedure and analyze its resource cost. Consider
any program P(θ ) ∈ q-while(T )
v
Execution. The first step in differentiation is to apply the
code transformation rules (in Section 6) to P(θ ) and obtain
an additive program ∂
∂θ (P(θ )). Then one needs to compile
∂θ (P(θ )) into a multiset {|P ′
∂
i=1 of normal non-aborting
programs P ′
i (θ ). The total count of these programs is given
by m = |# ∂
∂θ (P(θ ))|. Note that the above procedure could be
done at the compilation time.

i (θ )|}m

Given any pair of O and ρ, the real execution to compute
the derivative of [[(O, ρ) → P(θ )]] is to approximate the ob-
servable semantics [[(O, ρ) → ∂
∂θ (P(θ ))]]. By Definition 5.2,
we need to approximate

m
(cid:213)

i=1

tr

(cid:16) (cid:0)ZA ⊗ O(cid:1)[[P ′

i (θ )]]((|0⟩{A} ⟨0|) ⊗ ρ)

(cid:17)

,

(7.1)

where each term is the observable ZA ⊗O on the output state
of P ′
i (θ ) given input state ρ and the ancilla qubit |0⟩.
To approximate the sum in (7.1) to precision δ , one could
first treat the sum divided by m as the observable applied on
the program that starts with a uniformly random choice of i
from 1, · · · , m and then execute P ′
i (θ ). By Chernoff bound,
one only needs to repeat this procedure O(m2/δ 2) times.
Resource count. We are only interested in non-trivial (ex-
tra) resource that is something that you wouldn’t need if you
only run the original program. Ancilla qubits count as the
non-trivial resource. However, for our scheme, the number
of required ancillae is 1 qubit per each parameter.

The more non-trivial resource is the number of the copies
of input state (each copy of the input state is to be pre-
pared from scratch), which is directly related to the number
of repetitions in the procedure, which again connects to
m = |# ∂
∂θ (P(θ ))|. We argue that our code transformation is
efficient so that m is reasonably bounded. To that end, we
show the relation between m and a natural quantity defined
on the original program P(θ ) (i.e., before applying any ∂
∂θ (·)
operator) called the occurrence count of the parameter θ .

Definition 7.1. The “Occurrence Count for θj ” in P(θ ), de-
noted OCj (P(θ )), is defined as follows:

1. If P(θ ) ≡ abort[v]|skip[v]|q := |0⟩ (q ∈ v), then

OCj (P(θ )) = 0;

2. P(θ ) ≡ U (θ ): if U (θ ) trivially uses θj , then OCj (P(θ )) =

0; otherwise OCj (P(θ )) = 1.

3. If P(θ ) ≡ U (θ ) = P1(θ ); P2(θ )) then OCj (P(θ )) = OCj (P1(θ ))

+OCj (P2(θ )).

4. If P(θ ) ≡ case M[q] = m → Pm(θ ) end then OCj (P(θ )) =

5. If P(θ ) ≡ while(T ) M[q] = 1 do P1(θ ) done then OCj (P(θ ))

maxm OCj (Pm(θ )).

= T · OCj (P1(θ )).

Intuition of the “Occurrence Count” definition is clear:
it basically counts the number of non-trivial occurrences
of θj in the program, treating case as if it is determinis-
tic. To see why this is a reasonable quantity, consider the
auto-differentiation in the classical case. For any non-trivial
variable v (i.e., v has some dependence on the parameter
θ ), we will compute both v and ∂
∂θ (v) and store them both
as variables in the new program. Thus, the classical auto-
differentiation essentially needs the number of non-trivial
occurrences more space and related resources. As we argued
in the introduction, we cannot directly mimic the classical
case due to the no-cloning theorem. The extra space require-
ment in the classical setting turns into the requirement on
the extra copies of the input state in the quantum setting.
Indeed, we can bound m by the occurrence count.

Proposition 7.2.

|# ∂
∂θ j

(P(θ ))| ≤ OCj (P(θ )).

Proof. Structural induction. For details, see Appendix E.1.
□

8 Implementation and Case Study

We have built a compiler (written in OCaml) that implements
our code transformation and compilation rules8. We use it
to train one VQC instance with controls and empirically ver-
ify its resource-efficiency on representative VQC instances.
Complete details can be found in Appendix F. Experiments
are performed on a MacBook Pro with a Dual-Core Intel
Core i5 Processor clocked at 2.7 GHz, and 8GB of RAM.

8.1 Training VQC instances with controls

Consider a simple classification problem over 4-bit inputs
z = z1z2z3z4 ∈ {0, 1}4 with true label given by f (z) = ¬(z1 ⊕
z4). We construct two 4-qubit VQCs P1 (no control) and P2
(with control) that consists of a single-qubit Pauli X,Y and Z
rotation gate on each qubit and compare their performance.
For parameters Γ = {γ1, . . . , γ12} define the program
Q(Γ) ≡ RX (γ1)[q1]; RX (γ2)[q2]; RX (γ3)[q3]; RX (γ4)[q4];
RY (γ5)[q1]; RY (γ6)[q2]; RY (γ7)[q3]; RY (γ8)[q4];
RZ (γ9)[q1]; RZ (γ10)[q2]; RZ (γ11)[q3]; RZ (γ12)[q4],

8Codes are availabe at https://github.com/LibertasSpZ/adcompile.

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

where q1, q2, q3, q4 refer to 4 qubit registers. Given parame-
ters Θ = {θ1, . . . , θ12}, Φ = {ϕ1, . . . , ϕ12}, define

P1(Θ, Φ) ≡Q(Θ); Q(Φ).
(8.1)
Similarly, for parameters Θ = {θ1, . . . , θ12},Φ = {ϕ1, . . . , ϕ12},
Ψ = {ψ1, . . . ,ψ12}, define

P2(Θ, Φ, Ψ) ≡ Q(Θ); case M[q1] = 0 → Q(Φ)
1 → Q(Ψ).

(8.2)

Note that P1 and P2 execute the same number of gates for
each run. To use Pi to perform the classification or in the
training, we first initialize q1, q2, q3, q4 to the classical feature
vector z = z1z2z3z4 and then execute Pi . The predicted label
y is given by measuring the 4th qubit q4 in the 0/1 basis.

We conduct a supervised learning by minimizing a loss
function. A natural choice is the average negative log-likelihood
which is commonly used in machine learning to evaluate
classifiers that assign a certain probability to each label since
quantum outcomes are probabilistic. However, this loss func-
tion is not currently supported by Pennylane. Denote the
output of the classifier with input z and parameters θ by
lθ (z). To enable a direct comparison, we will treat lθ (z) as
the average value of the labels from probabilistic quantum
outcomes, and use the squared loss function as follows:

loss = (cid:213)

z ∈ {0,1}4

0.5 ∗ (lθ (z) − f (z))2.

(8.3)

∂α (P1) for α ∈ Θ, Φ (or ∂

Note that loss is a function of θ = (Θ, Φ) (or Θ, Φ.Ψ). More
importantly, for each z, lθ (z) can be represented by the ob-
servable semantics of P1(or P2) with observable |1⟩⟨1|. Thus,
the gradient of loss can be obtained by using the collection
of ∂
∂α (P2) for α ∈ Θ, Φ, Ψ). We classi-
cally simulate the training procedure with gradient descent.
For the training of P1, we use Pennylane for a direct compar-
ison (see Figure 6). After 1000 epochs with some hyperpa-
rameters, the loss for P1 (no control) attains a minimum of
0.5 in less than 100 epochs and subsequently plateaus. The
loss for P2 (with control) continues to decrease and attains
a minimum of 0.016. It demonstrates the advantage of both
controls in quantum machine learning and our scheme to
handle controls, whereas previous schemes (such as Penny-
lane due to its quantum-node design [8]) fail to do so.
8.2 Benchmark testing on representative VQCs

We also test our compiler on important VQC candidates such
as quantum neural-networks (QNN) for solving machine
learning tasks [18], quantum approximate optimization algo-
rithms (QAOA) for solving combinatorial optimization [17],
and variational quantum eigensolver (VQE) for approximat-
ing ground state energies in quantum chemsitry [38], all of
which are promising candidates for actual implementation
on near-term quantum machines. These VQCs typically con-
sists of alternating layers of single-qubit gates and two-qubit
coupling gates, such as the 1-qubit, 2-qubit Pauli rotation
gates considered in our paper, to represent the alternation

Figure 6. Training P1 and P2 to classify inputs according to
the labelling function f (z) = ¬(z1 ⊕ z4).

between local interaction and neighboring interaction in real
quantum physics systems.

We enrich these examples, by adding simple controls (the
if/condition statement) or 2-bounded loops (the bounded-
while statement) and increasing the number of qubits to
18∼40, to make them sufficiently sophisticated but yet realis-
tic for near-term quantum applications. For example, we use
QNNM,i to denote an enriched QNN VQC instance of medium
size and with if controls. The size of QNNM,i can also be di-
rectly illustrated by the number of qubits (#qb’s), the gate
count (#gates), the number of alternating layers (#layers),
and the number of lines to code such instances (#lines). Sim-
ilarly for QNNL,w except that it is an instance of large size
and with while controls.

A selective output performance of our compiler is in Ta-
ble 2, with details in Appendix F. It is easy to see that our
scheme is also empirically resource-efficient as |# ∂
∂θ (·)| is
always reasonably bounded.

∂θ (·)| #gates #lines

P(θ )
OC(·)
QNNM,i
24
QNNM,w
56
QNNL,i
48
QNNL,w
504
VQEM,i
15
VQEM,w
35
VQEL,i
40
VQEL,w
248
QAOAM,i
18
QAOAM,w 42
QAOAL,i
36
QAOAL,w
378
Table 2. Output on selective examples. {M, L} stands for
“medium, large”; {i, w } stands for including “if, while”.

#layers #qb’s
3
5
6
33
3
5
5
17
3
5
6
33

165
231
363
2079
224
224
576
1984
120
168
264
1512

|# ∂
24
24
48
48
15
15
40
40
18
18
36
36

189
121
414
244
241
112
628
368
142
94
315
190

18
18
36
36
12
12
40
40
18
18
36
36

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

References

[1] Martín Abadi and Gordon D. Plotkin. 2019. A Simple Differentiable
Programming Language. Proc. ACM Program. Lang. 4, POPL, Article
38 (Dec. 2019), 28 pages. https://doi.org/10.1145/3371106

[2] Ali Javadi Abhari, Arvin Faruque, Mohammad Javad Dousti, Lukas
Svec, Oana Catu, Amlan Chakrabati, Chen-Fu Chiang, Seth Vander-
wilt, John Black, Fred Chong, Margaret Martonosi, Martin Suchara,
Ken Brown, Massoud Pedram, and Todd Brun. 2012. Scaffold: Quan-
tum Programming Language. Technical Report TR-934-12. Princeton
University.

[3] Frank Arute, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C. Bardin,
Rami Barends, Rupak Biswas, Sergio Boixo, Fernando G. S. L. Bran-
dao, David A. Buell, Brian Burkett, Yu Chen, Zijun Chen, Ben Chiaro,
Roberto Collins, William Courtney, Andrew Dunsworth, Edward Farhi,
Brooks Foxen, Austin Fowler, Craig Gidney, Marissa Giustina, Rob
Graff, Keith Guerin, Steve Habegger, Matthew P. Harrigan, Michael J.
Hartmann, Alan Ho, Markus Hoffmann, Trent Huang, Travis S. Hum-
ble, Sergei V. Isakov, Evan Jeffrey, Zhang Jiang, Dvir Kafri, Kostyan-
tyn Kechedzhi, Julian Kelly, Paul V. Klimov, Sergey Knysh, Alexan-
der Korotkov, Fedor Kostritsa, David Landhuis, Mike Lindmark, Erik
Lucero, Dmitry Lyakh, Salvatore Mandrà, Jarrod R. McClean, Matthew
McEwen, Anthony Megrant, Xiao Mi, Kristel Michielsen, Masoud
Mohseni, Josh Mutus, Ofer Naaman, Matthew Neeley, Charles Neill,
Murphy Yuezhen Niu, Eric Ostby, Andre Petukhov, John C. Platt,
Chris Quintana, Eleanor G. Rieffel, Pedram Roushan, Nicholas C.
Rubin, Daniel Sank, Kevin J. Satzinger, Vadim Smelyanskiy, Kevin J.
Sung, Matthew D. Trevithick, Amit Vainsencher, Benjamin Villalonga,
Theodore White, Z. Jamie Yao, Ping Yeh, Adam Zalcman, Hartmut
Neven, and John M. Martinis. 2019. Quantum supremacy using a
programmable superconducting processor. Nature 574, 7779 (2019),
505–510.

[4] Alexandru Baltag and Sonja Smets. 2011. Quantum Logic as a Dynamic

Logic. Synthese 179, 2 (2011).

[5] Atılım Günes Baydin, Barak A. Pearlmutter, Alexey Andreyevich Radul,
and Jeffrey Mark Siskind. 2017. Automatic Differentiation in Machine
Learning: A Survey. J. Mach. Learn. Res. 18, 1 (Jan. 2017), 5595–5637.
http://dl.acm.org/citation.cfm?id=3122009.3242010

[6] Thomas Beck and Herbert Fischer. 1994. The if-problem in automatic

differentiation. J. Comput. Appl. Math. 50, 1-3 (1994), 119–131.

[7] Marcello Benedetti, Erika Lloyd, and Stefan Sack. 2019. Parameterized
quantum circuits as machine learning models. arXiv e-prints (Jun
2019). arXiv:1906.07682

[8] Ville Bergholm, Josh Izaac, Maria Schuld, Christian Gogolin, and
Nathan Killoran. 2018. PennyLane: Automatic differentiation of hybrid
quantum-classical computations. arXiv:1811.04968 (2018).

[9] Jacob Biamonte, Peter Wittek, Nicola Pancotti, Patrick Rebentrost,
Nathan Wiebe, and Seth Lloyd. 2017. Quantum machine learning.
Nature 549, 7671 (2017), 195.

[10] Olivier Brunet and Philippe Jorrand. 2004. Dynamic Quantum Logic
for Quantum Programs. International Journal of Quantum Information
2, 1 (2004).

[11] Rohit Chadha, Paulo Mateus, and Amílcar Sernadas. 2006. Reasoning
About Imperative Quantum Programs. Electronic Notes in Theoretical
Computer Science 158 (2006).

[12] George Corliss, Christèle Faure, Andreas Griewank, Lauren Hascoët,
and Uwe Naumann (Eds.). 2002. Automatic Differentiation of Algo-
rithms: From Simulation to Optimization. Springer-Verlag New York,
Inc., New York, NY, USA.

[13] Ellie D’Hondt and Prakash Panangaden. 2006. Quantum Weakest
Preconditions. Mathematical Structures in Computer Science 16, 3
(2006).

[14] Thomas Ehrhard and Laurent Regnier. 2003. The differential lambda-

calculus. Theoretical Computer Science 309, 1-3 (2003), 1–41.

[15] Conal M. Elliott. 2009. Beautiful Differentiation. In Proceedings of
the 14th ACM SIGPLAN International Conference on Functional Pro-
gramming (Edinburgh, Scotland) (ICFP ’09). ACM, New York, NY, USA,
191–202. https://doi.org/10.1145/1596550.1596579

[16] Conal M. Elliott. 2018. The Simple Essence of Automatic Differentia-
tion. Proc. ACM Program. Lang. 2, ICFP, Article 70 (July 2018), 29 pages.
https://doi.org/10.1145/3236765

[17] Edward Farhi, Jeffrey Goldstone, and Sam Gutmann. 2014. A Quantum
Approximate Optimization Algorithm. (2014). arXiv:1411.4028
[18] Edward Farhi and Hartmut Neven. 2018. Classification with Quantum
Neural Networks on Near Term Processors. (2018). arXiv:1802.06002
[19] Yuan Feng, Runyao Duan, Zhengfeng Ji, and Mingsheng Ying. 2007.
Proof Rules for the Correctness of Quantum Programs. Theoretical
Computer Science 386, 1-2 (2007).

[20] Simon J. Gay. 2006. Quantum Programming Languages: Survey and
Bibliography. Mathematical Structures in Computer Science 16, 4 (2006).
[21] Gian Giacomo Guerreschi and Mikhail Smelyanskiy. 2017. Practi-
(2017).

cal optimization for hybrid quantum-classical algorithms.
arXiv:1701.01450
[22] Martin Giles. 2019.

IBM’s new 53-qubit quantum com-
https:

puter is the most powerful machine you can use.
//www.technologyreview.com/f/614346/ibms-new-53-qubit-
quantum-computer-is-the-most-powerful-machine-you-can-use/

[23] Pranav Gokhale. 2018. Variational Quantum Eigensolver Demo. ISCA

2018 (2018).

[24] Jonathan Grattage. 2005. A Functional Quantum Programming Lan-
guage. In Proceedings of the 20th Annual IEEE Symposium on Logic in
Computer Science (LICS ?05). IEEE Computer Society, USA, 249?258.
https://doi.org/10.1109/LICS.2005.1

[25] Alex Graves, Greg Wayne, Malcolm Reynolds, Tim Harley, Ivo Dani-
helka, Agnieszka Grabska-Barwińska, Sergio Gómez Colmenarejo, Ed-
ward Grefenstette, Tiago Ramalho, John Agapiou, AdriàPuigdomènech
Badia, Karl Moritz Hermann, Yori Zwols, Georg Ostrovski, Adam
Cain, Helen King, Christopher Summerfield, Phil Blunsom, Koray
Kavukcuoglu, and Demis Hassabis. 2016. Hybrid computing using a
neural network with dynamic external memory. Nature 538 (10 2016),
471.

[26] Alexander S. Green, Peter LeFanu Lumsdaine, Neil J. Ross, Peter
Selinger, and Benoît Valiron. 2013. Quipper: A Scalable Quantum
Programming Language. In Proceedings of the 34th ACM SIGPLAN Con-
ference on Programming Language Design and Implementation (Seattle,
Washington, USA) (PLDI ’13). Association for Computing Machinery,
New York, NY, USA, 333–342. https://doi.org/10.1145/2491956.2462177
[27] Edward Grefenstette, Karl Moritz Hermann, Mustafa Suleyman, and
Phil Blunsom. 2015. Learning to Transduce with Unbounded Memory.
In Proceedings of the 28th International Conference on Neural Informa-
tion Processing Systems - Volume 2 (Montreal, Canada) (NIPS’15). MIT
Press, Cambridge, MA, USA, 1828–1836. http://dl.acm.org/citation.
cfm?id=2969442.2969444

[28] Andreas Griewank. 2000. Evaluating Derivatives: Principles and Tech-
niques of Algorithmic Differentiation. Society for Industrial and Applied
Mathematics, Philadelphia, PA, USA.

[29] Shih-Han Hung, Kesha Hietala, Shaopeng Zhu, Mingsheng Ying,
Michael Hicks, and Xiaodi Wu. 2019. Quantitative Robustness Analy-
sis of Quantum Programs. Proc. ACM Program. Lang. 3, POPL, Article
31 (Jan. 2019), 29 pages. https://doi.org/10.1145/3290344

[30] Yoshihiko Kakutani. 2009. A Logic for Formal Verification of Quantum
Programs. In Proceedings of the 13th Asian Conference on Advances
in Computer Science: Information Security and Privacy (Seoul, Korea)
(ASIAN’09). Springer-Verlag, Berlin, Heidelberg, 79–93. https://doi.
org/10.1007/978-3-642-10622-4_7

[31] Gershon Kedem. 1980. Automatic Differentiation of Computer Pro-
grams. ACM Trans. Math. Softw. 6, 2 (June 1980), 150–165. https:
//doi.org/10.1145/355887.355890

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

[32] Jin-Guo Liu and Lei Wang. 2018. Differentiable learning of quantum
circuit Born machines. Phys. Rev. A 98 (Dec 2018), 062324. Issue 6.
https://doi.org/10.1103/PhysRevA.98.062324

[33] Nikolaj Moll, Panagiotis Barkoutsos, Lev S. Bishop, Jerry M. Chow,
Andrew Cross, Daniel J. Egger, Stefan Filipp, Andreas Fuhrer, Jay M.
Gambetta, Marc Ganzhorn, Abhinav Kandala, Antonio Mezzacapo,
Peter Muller, Walter Riess, Gian Salis, John Smolin, Ivano Tavernelli,
and Kristan Temme. 2018. Quantum optimization using variational
algorithms on near-term quantum devices. Quantum Science and
Technology 3, 3 (2018), 030503. arXiv:arXiv:1710.01022

[34] Michael A. Nielsen and Isaac Chuang. 2000. Quantum Computation

and Quantum Information. Cambridge University Press.

[50] Qingfeng Wang and Tauqir Abdullah. 2018. An Introduction to Quan-

tum Optimization Approximation Algorithm.

[51] John Watrous. 2006.

Introduction to Quantum Computa-
https://cs.uwaterloo.ca/~watrous/LectureNotes/CPSC519.

tion.
Winter2006/all.pdf. Course notes.

[52] Dave Wecker and Krysta Svore. 2014. LIQUi|⟩: A Software Design
Architecture and Domain-Specific Language for Quantum Computing.
CoRR abs/1402.4467 (2014). arXiv:1402.4467

[53] Robert Edwin Wengert. 1964. A Simple Automatic Derivative Eval-
uation Program. Commun. ACM 7, 8 (Aug. 1964), 463–464. https:
//doi.org/10.1145/355586.364791

[54] William K. Wootters and Wojciech H. Zurek. 1982. A single quantum

[35] Bernhard Ömer. 2003. Structured Quantum Programming. Ph.D. Dis-

cannot be cloned. Nature 299, 5886 (1982), 802–803.

[55] Mingsheng Ying. 2011. Floyd–Hoare Logic for Quantum Programs.
ACM Transactions on Programming Languages and Systems 33, 6 (2011).
[56] Mingsheng Ying. 2016. Foundations of Quantum Programming. Morgan

Kaufmann.

[57] Mingsheng Ying, Shenggang Ying, and Xiaodi Wu. 2017. Invariants of
Quantum Programs: Characterisations and Generation. In Proceedings
of the 44th ACM SIGPLAN Symposium on Principles of Programming
Languages (Paris, France) (POPL 2017). Association for Computing
Machinery, New York, NY, USA, 818?832. https://doi.org/10.1145/
3009837.3009840

[58] D. Zhu, N. M. Linke, M. Benedetti, K. A. Landsman, N. H. Nguyen,
C. H. Alderete, A. Perdomo-Ortiz, N. Korda, A. Garfoot, C.
Brecque, L. Egan, O. Perdomo, and C. Monroe. 2019. Training
Science
of quantum circuits on a hybrid quantum computer.
Advances 5, 10 (2019).
https://doi.org/10.1126/sciadv.aaw9918
arXiv:https://advances.sciencemag.org/content/5/10/eaaw9918.full.pdf

sertation. Vienna University of Technology.

[36] Jennifer Paykin, Robert Rand, and Steve Zdancewic. 2017. QWIRE: A
Core Language for Quantum Circuits. In Proceedings of the 44th ACM
SIGPLAN Symposium on Principles of Programming Languages (Paris,
France) (POPL 2017). Association for Computing Machinery, New York,
NY, USA, 846–858. https://doi.org/10.1145/3009837.3009894

[37] Barak A. Pearlmutter and Jeffrey Mark Siskind. 2008. Reverse-mode
AD in a Functional Framework: Lambda the Ultimate Backpropagator.
ACM Trans. Program. Lang. Syst. 30, 2, Article 7 (March 2008), 36 pages.
https://doi.org/10.1145/1330017.1330018

[38] Alberto Peruzzo, Jarrod McClean, Peter Shadbolt, Man-Hong Yung,
Xiao-Qi Zhou, Peter J. Love, Alán Aspuru-Guzik, and Jeremy L. O’brien.
2014. A variational eigenvalue solver on a photonic quantum processor.
Nature Communications 5 (2014), 4213.

[39] Gordon Plotkin. 2018. Some Principles of Differential Programming

Languages. POPL 2018 (2018).

[40] John Preskill. 2018. Quantum computing in the NISQ era and beyond.

Quantum 2 (2018), 79. arXiv:1801.00862

[41] David E. Rumelhart, Geoffrey E. Hinton, and Ronald J. Williams. 1986.
Learning representations by back-propagating errors. Nature 323, 6088
(1986), 533–536.

[42] Amr Sabry. 2003. Modeling Quantum Computing in Haskell. In Pro-
ceedings of the 2003 ACM SIGPLAN Workshop on Haskell (Uppsala,
Sweden) (Haskell ’03). Association for Computing Machinery, New
York, NY, USA, 39 – 49. https://doi.org/10.1145/871895.871900
[43] J. W. Sanders and P. Zuliani. 2000. Quantum Programming. In Pro-
ceedings of the 5th International Conference on Mathematics of Program
Construction (MPC ’00). Springer-Verlag, Berlin, Heidelberg, 80 – 99.
[44] Maria Schuld, Ville Bergholm, Christian Gogolin, Josh Izaac, and
Nathan Killoran. 2019. Evaluating analytic gradients on quantum
hardware. Phys. Rev. A 99 (Mar 2019), 032331.
Issue 3. https:
//doi.org/10.1103/PhysRevA.99.032331

[45] Maria Schuld, Alex Bocharov, Krysta M. Svore, and Nathan Wiebe.
2020. Circuit-centric quantum classifiers. Phys. Rev. A 101 (Mar 2020),
032308. Issue 3. https://doi.org/10.1103/PhysRevA.101.032308
[46] Peter Selinger. 2004. A brief survey of quantum programming lan-
guages. In In Proceedings of the 7th International Symposium on Func-
tional and Logic Programming. Springer, 1–6.

[47] Peter Selinger. 2004. Towards a Quantum Programming Language.

Mathematical Structures in Computer Science 14, 4 (2004).

[48] Bert Speelpenning. 1980. Compiling Fast Partial Derivatives of Func-
tions Given by Algorithms. Ph.D. Dissertation. Champaign, IL, USA.
AAI8017989.

[49] Krysta Svore, Alan Geller, Matthias Troyer, John Azariah, Christopher
Granade, Bettina Heim, Vadym Kliuchnikov, Mariia Mykhailova, An-
dres Paz, and Martin Roetteler. 2018. Q#: Enabling Scalable Quantum
Computing and Development with a High-Level DSL. In Proceedings of
the Real World Domain Specific Languages Workshop 2018 (Vienna, Aus-
tria) (RWDSL2018). Association for Computing Machinery, New York,
NY, USA, Article 7, 10 pages. https://doi.org/10.1145/3183895.3183901

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

A Detailed Quantum Preliminary

This is a more detailed treatment of Section 2. For a further
extended background, we recommend the notes by Watrous
[51] and the textbook by Nielsen and Chuang [34].

A.1 Preliminaries

For any non-negative integer n, an n-dimensional Hilbert
space H is essentially the space Cn of complex vectors. We
use Dirac’s notation, |ψ ⟩, to denote a complex vector in Cn.
The inner product of two vectors |ψ ⟩ and |ϕ⟩ is denoted by
⟨ψ |ϕ⟩, which is the product of the Hermitian conjugate of
|ψ ⟩, denoted by ⟨ψ |, and vector |ϕ⟩. The norm of a vector
|ψ ⟩ is denoted by ∥|ψ ⟩∥ = (cid:112)⟨ψ |ψ ⟩.

We define (linear) operators as linear mappings between
Hilbert spaces. Operators between n-dimensional Hilbert
spaces are represented by n × n matrices. For example, the
identity operator I H can be identified by the identity matrix
on H . The Hermitian conjugate of operator A is denoted
by A†. Operator A is Hermitian if A = A†. The trace of an
operator A is the sum of the entries on the main diagonal, i.e.,
tr(A) = (cid:205)
i Aii . We write ⟨ψ |A|ψ ⟩ to mean the inner product
between |ψ ⟩ and A|ψ ⟩. A Hermitian operator A is positive
semidefinite (resp., positive definite) if for all vectors |ψ ⟩ ∈ H ,
⟨ψ |A|ψ ⟩ ≥ 0 (resp., > 0). This gives rise to the Löwner order
⊑ among operators:

A ⊑ B
B
A

if B − A is positive semidefinite,
if B − A is positive definite.

(cid:60)

A.2 Quantum States

The state space of a quantum system is a Hilbert space. The
state space of a qubit, or quantum bit, is a 2-dimensional
Hilbert space. One important orthonormal basis of a qubit
system is the computational basis with |0⟩ = (1, 0)† and |1⟩ =
(0, 1)†, which encode the classical bits 0 and 1 respectively.
Another important basis, called the ± basis, consists of |+⟩ =
1√
(|0⟩ − |1⟩). The state space of
2
multiple qubits is the tensor product of single qubit state
spaces. For example, classical 00 can be encoded by |0⟩ ⊗ |0⟩
(written |0⟩|0⟩ or even |00⟩ for short) in the Hilbert space
C2 ⊗ C2. An important 2-qubit state is the EPR state |β00⟩ =
(|00⟩ + |11⟩). The Hilbert space for an m-qubit system is
1√
2
(C2)⊗m (cid:27) C2m

(|0⟩ + |1⟩) and |−⟩ = 1√
2

.

A pure quantum state is represented by a unit vector, i.e., a
vector |ψ ⟩ with ∥|ψ ⟩∥ = 1. A mixed state can be represented
by a classical distribution over an ensemble of pure states
{(pi , |ψi ⟩)}i , i.e., the system is in state |ψi ⟩ with probability
pi . One can also use density operators to represent both pure
and mixed quantum states. A density operator ρ for a mixed
state representing the ensemble {(pi , |ψi ⟩)}i is a positive
semidefinite operator ρ = (cid:205)
i pi |ψi ⟩⟨ψi |, where |ψi ⟩⟨ψi | is
the outer-product of |ψi ⟩; in particular, a pure state |ψ ⟩ can
be identified with the density operator ρ = |ψ ⟩⟨ψ |. Note
that tr(ρ) = 1 holds for all density operators. A positive

semidefinite operator ρ on H is said to be a partial density
operator if tr(ρ) ≤ 1. The set of partial density operators is
denoted by D(H ).

A.3 Quantum Operations

Operations on quantum systems can be characterized by
unitary operators. Denoting the set of linear operators on H
as L(H ), an operator U ∈ L(H ) is unitary if its Hermitian
conjugate is its own inverse, i.e., U †U = UU † = I H. For
a pure state |ψ ⟩, a unitary operator describes an evolution
from |ψ ⟩ to U |ψ ⟩. For a density operator ρ, the corresponding
evolution is ρ (cid:55)→ U ρU †. Common unitary operators include

(cid:34)

H =

1√
2
1√
2

(cid:35)

1√
2
−1√
2

, X =

(cid:20) 0
1

(cid:21)

1
0

, Z =

(cid:21)

(cid:20) 1

0
0 −1

, Y = −iXZ

The Hadamard operator H transforms between the com-
putational and the ± basis. For example, H |0⟩ = |+⟩ and
H |1⟩ = |−⟩. The Pauli X operator is a bit flip, i.e., X |0⟩ = |1⟩
and X |1⟩ = |0⟩. The Pauli Z operator is a phase flip, i.e.,
Z |0⟩ = |0⟩ and Z |1⟩ = −|1⟩. Pauli Y maps |0⟩ to i |1⟩ and
|1⟩ to −i |0⟩. The CNOT gate C maps |00⟩ (cid:55)→ |00⟩, |01⟩ (cid:55)→
|01⟩, |10⟩ (cid:55)→ |11⟩, |11⟩ (cid:55)→ |10⟩. One may obtain the EPR state

|β00⟩ via |00⟩

H1
(cid:55)→ 1√
2

(|0⟩ + |1⟩)|0⟩

(|00⟩ + |11⟩).

C1, 2
(cid:55)→ 1√
2

More generally, the evolution of a quantum system can be
characterized by an admissible superoperator E, which is a
completely-positive and trace-non-increasing linear map from
D(H ) to D(H ′) for Hilbert spaces H, H ′. A superopera-
tor is positive if it maps from D(H ) to D(H ′) for Hilbert
spaces H, H ′. A superoperator E is k-positive if for any
k-dimensional Hilbert space A, the superoperator E ⊗ I A
is a positive map on D(H ⊗ A). A superoperator is said
to be completely positive if it is k-positive for any positive
integer k. A superoperator E is trace-non-increasing if for
any initial state ρ ∈ D(H ), the final state E(ρ) ∈ D(H ′)
after applying E satisfies tr(E(ρ)) ≤ tr(ρ).

For every superoperator E : D(H ) → D(H ′), there ex-
ists a set of Kraus operators {Ek }k such that E(ρ) = (cid:205)
k Ek ρE†
k
for any input ρ ∈ D(H ). Note that the set of Kraus operators
is finite if the Hilbert space is finite-dimensional. The Kraus
form of E is written as E = (cid:205)
k . A unitary evolution
can be represented by the superoperator E = U ◦ U †. An
identity operation refers to the superoperator IH = I H ◦ I H.
The Schrödinger-Heisenberg dual of a superoperator E =
(cid:205)
k , denoted by E∗, is defined as follows: for every
state ρ ∈ D(H ) and any operator A, tr(AE(ρ)) = tr(E∗(A)ρ).
The Kraus form of E∗ is (cid:205)
k E†

k Ek ◦ E†

k Ek ◦ E†

◦ Ek .

k

A.4 Quantum Measurements and Observables

The way to extract information about a quantum system is
called a quantum measurement. A quantum measurement on
a system over Hilbert space H can be described by a set of lin-
ear operators {Mm }m with (cid:205)
m M †
mMm = I H. If we perform a

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

measurement {Mm }m on a state ρ, the outcome m is observed
with probability pm = tr(MmρM †
m) for each m. A major dif-
ference between classical and quantum computation is that a
quantum measurement changes the state. In particular, after
a measurement yielding outcome m, the state collapses to
MmρM †
m/pm. For example, a measurement in the computa-
tional basis is described by M = {M0 = |0⟩⟨0|, M1 = |1⟩⟨1|}.
If we perform the computational basis measurement M on
state ρ = |+⟩⟨+|, then with probability 1
2 the outcome is 0
and ρ becomes |0⟩⟨0|. With probability 1
2 the outcome is 1
and ρ becomes |1⟩⟨1|.

B More on the definition of parameterized

quantum programs

B.1 Definition of qVar
Given P(θ ) a T -bounded k-parameterized quantum while-
program, let qVar(P(θ )), read the set of quantum variables
accesible to P, be recursively defined as follows [56]:

1. If P(θ ) ≡ skip[q], abort[q] or U [q], then qVar(P(θ )) =

q.

2. If P(θ ) ≡ q := |0⟩, then qVar(P(θ )) = q.
3. If P(θ ) ≡ P1(θ ); P2(θ ), then qVar(P(θ )) = qVar(P1(θ ))∪
qVar(P2(θ )). When analyzing P1(θ ); P2(θ ), we identify
P1(θ ) with I ⊗ P1(θ ), where I ≡ IqVar(P2(θ ))\qVar(P1(θ )) ◦
IqVar(P2(θ ))\qVar(P1(θ )), the identity operation on the vari-
ables where P1 originally has no access to.

4. If P(θ ) ≡ case M[q] = m → Pm(θ ) end, then qVar(P(θ )) =

m qVar(Pi (θ )). We make the same identification

q ∪ (cid:208)
for Pi (θ )’s as the above.

5. If P(θ ) ≡ while(T ) M[q] = 1 do P1(θ ) done, then
qVar(P(θ )) = q ∪ qVar(P1(θ )). We make the same
identification for P1(θ ) as the above.

One defines qVar(P) for unparameterized P analogously.

C Detailed Proof from Section 4
C.1 Proof of Prop 4.2: Non-deterministic
Compilation Rules Well-Defined

Proof. Structural induction.

1. (Atomic) : as operational semantics of atomic opera-
tions are inherited from parameterized quantum while
programs, they do not induce non-determinism. For
these operations, [[P(θ ∗)]]ρ = {|[[P(θ ∗)]]ρ|} as is the
right hand side.

2. (Sequence) If one of Compile(Pb (θ ∗)) is {abort} the
statement is immediately true, so we assume otherwise
for below.
a. ⊆: Let ρ ′ ∈ {|ρ ′ (cid:44) 0 : ⟨P1(θ ∗); P2(θ ∗), ρ⟩ →∗ ⟨↓
, ρ ′⟩|}. By definition there exists ρ2 (cid:44) 0 s.t. ⟨P1(θ ∗);
P2(θ ∗), ρ⟩ →∗ ⟨P2(θ ∗), ρ2⟩ and ⟨P2(θ ∗), ρ2⟩ →∗ ⟨↓
, ρ ′⟩. By inductive hypothesis, ρ ′ ∈ (cid:221)
{|ρ ′ (cid:44) 0 : ⟨Qj (θ ∗), ρ2⟩ →∗ ⟨↓, ρ ′⟩|}.

Q j (θ )∈Compile(P2(θ ))

Since ⟨P1(θ ∗); P2(θ ∗), ρ⟩ →∗ ⟨P2(θ ∗), ρ2⟩, there must
be some ⟨P3(θ ∗), ρ3⟩ → ⟨↓, ρ2⟩ triggering the last
transition according to our operational semantics.
Inductively apply such an argument, knowing that
all computation paths are finitely long,9 we conclude
that ρ2 ∈ {|ρ ′
2 : ⟨P1(θ ), ρ⟩ →∗ ⟨↓, ρ ′
2⟩|}. By the in-
ductive hypothesis we have ρ2 ∈ (cid:221)
Ri (θ )∈Compile(P1(θ ))
(cid:44) 0 : ⟨Ri (θ ∗), ρ⟩ →∗ ⟨↓, ρ ′
{|ρ ′
2

2⟩|}. Thus

ρ ′

∈

(cid:222)

Ri (θ )∈Compile(P1(θ )),Q j (θ )∈Compile(P2(θ ))
{|ρ ′ (cid:44) 0 : ⟨Ri (θ ∗), ρ⟩ →∗ ⟨↓, ρ2⟩

(cid:219)

⟨Qj (θ ∗), ρ2⟩ →∗ ⟨↓, ρ ′⟩|}

=

(cid:222)

Ri (θ )∈Compile(P1(θ )),Q j (θ )∈Compile(P2(θ ))
{|ρ ′ (cid:44) 0 : ⟨Ri (θ ∗); Qj (θ ∗), ρ⟩ →∗ ⟨↓, ρ ′⟩|}

(C.1)

(C.2)

(C.3)

(C.4)

(C.5)

as desired.

b. ⊇: Let ρ ′ be a member of the multiset in right hand
side (“RHS”) of C.5 for some Ri (θ ) ∈ Compile(P1(θ )),
Qj (θ ) ∈ Compile(P2(θ )). Then by inductive hypoth-
esis, ⟨P2(θ ), [[Ri (θ ∗)]]ρ⟩ →∗ ⟨↓, ρ ′⟩ (ρ ′ (cid:44) 0), and
⟨P1(θ ), ρ⟩ →∗ ⟨↓, [[Ri (θ ∗)]]ρ⟩ ([[Ri (θ ∗)]]ρ (cid:44) 0). One
may start with ⟨P2(θ ∗), [[Ri (θ ∗)]]ρ⟩ →∗ ⟨↓, ρ ′⟩ then
repeatedly apply the Sequential rule in the opera-
tional semantics, tracing back the path ⟨P1(θ ), ρ⟩ →∗
⟨↓, [[Ri (θ ∗)]]ρ⟩, and conclude that ⟨P1(θ ∗); P2(θ ∗), ρ⟩ →∗
⟨↓, ρ ′⟩ (ρ ′ (cid:44) 0).

The above said the two multisets have the same set of
distinct elements, and furthermore each copy of ρ ′ ∈
[[P(θ ∗)]]ρ induces at least (by ⊆, or by the deterministic
nature of Ri (θ ∗); Qj (θ ∗)) as well as at most (by ⊇ ) one
copy of the same element in RHS(C.5). This says the
two multisets are equal.

3. (Case) Applying the operational transition rule for 1
step one may observe that (writing “IH” the inductive
hypothesis)

{|0 (cid:44) ρ ′ ∈ [[case M[q] = m → Pm(θ ) end]]ρ|}
m⟩ → ⟨↓, ρ ′⟩|}

{|ρ ′ (cid:44) 0 : ⟨Pm(θ ∗), MmρM †

= (cid:222)
m∗
I H= (cid:222)
m∗
{|ρ ′ (cid:44) 0 : ⟨[[Qm∗,im∗ (θ ∗)]], Mm∗ ρM †

Qm∗, im∗ (θ )∈Compile(Pm∗ (θ ))

(cid:222)

(C.6)

m∗ ⟩
→∗ ⟨↓, ρ ′⟩|}

(C.7)

9We don’t count “transitions” like ⟨P (θ ∗), ρ ⟩ → ⟨P (θ ∗), ρ ⟩ when analyz-
ing computation paths, as nothing evolves in these “trivial transitions”.

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

On the other hand we have

(cid:222)

Q (θ )∈Compile(case M [q]=m→Pm (θ ) end)
{|ρ ′ (cid:44) 0 : ⟨Q(θ ∗), ρ⟩ →∗ ⟨↓, ρ ′⟩|}

CP,Case=

(cid:222)

Q (θ )∈FB(case M [q]=m→Pm (θ ) end)
{|ρ ′ (cid:44) 0 : ⟨Q(θ ∗), ρ⟩ →∗ ⟨↓, ρ ′⟩|}
(cid:222)

(∗∗)= (cid:222)
m∗
Mm∗ ρM †

Qm∗,im∗ (θ )∈Compile(Pm∗ (θ ))
m∗⟩ →∗ ⟨↓, ρ ′⟩|}

{|ρ ′ (cid:44) 0 : ⟨[[Qm∗,im∗ (θ ∗)]],

(C.8)

m∗⟩.

m∗⟩ for some Qm∗,im∗ (θ ) ∈

as desired. Note that the last step (**) is due to the
behavior of the superoperators in FB(case M[q] =
m → Pm(θ ) end): when evolved by one transition, they
either go to some non-(essentially-aborting)
⟨[[Qm∗,im∗ (θ ∗)]], Mm∗ ρM †
Compile(Pm∗(θ )) for some m∗, or go to ⟨abort, Mm∗ ρM †
Besides, each copy of final state of non-(essentially-
aborting)
⟨[[Qm∗,im∗ (θ ∗)]], Mm∗ ρM †
m∗⟩ appears exactly once in
the multiset, Due to our construction of FB(case M[q] =
m → Pm(θ ) end). On the other hand, computational
paths starting with essentially aborting ⟨Qm∗,im∗ (θ ∗),
Mm∗ ρM †
m∗⟩ always terminate in ⟨↓, 0⟩, therefore not
counted on either side of (∗∗).

4. (While(T )) By definition, While(T ) reduces to (Case)

and (Sequence).

5. (Sum Components) If one of Compile(Pb (θ ∗)) is {abort}
the statement is immediately true, so we assume oth-
erwise for below. Like in the case case, applying the
operational transition rule for 1 step one may observe
that (writing “IH” the inductive hypothesis)

=

I H=

0 (cid:44) ρ ′ ∈ [[P1(θ ∗) + P2(θ ∗)]]ρ
(cid:222)

(C.9)
{|ρ ′ (cid:44) 0 : ⟨Pm(θ ∗), ρ⟩ → ⟨↓, ρ ′⟩|}

m∗=1,2
(cid:222)

{|ρ ′ (cid:44) 0 : ⟨[[Qm∗,im∗ (θ ∗)]], ρ⟩ →∗

m∗=1,2
⟨↓, ρ ′⟩, Qm∗,im∗ (θ ) ∈ Compile(Pm∗(θ ))|}

CP,Sum Component
=

(cid:222)

Q (θ )∈Compile(P1(θ )+P2(θ ))
{|ρ ′ (cid:44) 0 : ⟨Q(θ ∗), ρ⟩ →∗ ⟨↓, ρ ′⟩|},(C.10)

as desired!

□

D Detailed Proofs from Section 6

Throughout, we use LHS, RHS to denote “left hand side”
and “right hand side” resp., and “IH” to denote “Inductive

Hypothesis”. Wherever applicable, we adopt the overloading
convention explained in the main text (See Eqn 6.4).

Before giving proofs, we record the full details for code
transformation rule for while(T ) for your interest. Let us
∂θ (while(T ) M[q] = 1 do S1(θ ) done) ≡ SeqT , with:
denote ∂

Seq(1) ≡ case M[q] = 0 → abort,

(cid:16) ∂
∂θ j

1 →

(cid:16)

(P1(θ )); abort
(cid:17)

P1(θ ); abort

,

(cid:17)+

and Seq(T ≥2) recursively defined as:

Seq(T ≥2) ≡ case M[q] = 0 → abort,

1 →

(cid:16)

(P1(θ )); while(T−1)(cid:17)+

(cid:16) ∂
∂θ j
P1(θ ); Seq(T −1)(cid:17)

Note that Seq(T −1) essentially aborts. Let us now introduce
some helper lemmas for the soundness proof:

D.1 Technical Lemmas
Lemma D.1. U (θ ) ∈ {Rσ (θ ), Rσ ⊗σ (θ )}σ ∈ {X,Y,Z }. Let d
denote the entry-wise derivative of U (θ ). Then,

dθ U (θ )

d
dθ

U (θ )

=

=

D .1=

U (θ + π );

1
2
∂
∂θ

([[(O, ρ) → U (θ )]])

tr(O · U (θ ) · ρ · (

U (θ ))†) +

d
dθ
U (θ ) · ρ · U †(θ ))

d
dθ
(cid:16)
U (θ )ρU †(θ + π ) +

tr(O ·
(cid:18)
O

tr

1
2

U (θ + π )ρU †(θ )

(cid:17) (cid:19)

.

(D.1)

(D.2)

(D.3)

2 I• −i sin( θ

Proof. Let U (θ ) ∈ {Rσ (θ ), Rσ ⊗σ (θ )}σ ∈ {X,Y,Z }. Then U (θ ) =
cos θ
2 )σ , where σ ∈ {X , Y , Z , X ⊗ X , Y ⊗Y , Z ⊗ Z }.
In the cases where σ is 1-qubit gate, I• denotes identity on
that one qubit; likewise for 2-qubit cases. Correctness of Eqns
D.1, D.2 basically follows from straightforward computation.

1. Equation D.1:

(cid:16)

d
dθ
(cid:16)
= 1
2
= 1
2
= 1
2
= 1
2

(cid:16)

(U (θ ))

cos(

(− sin(

θ
2
θ
+ π
2
2
(θ + π )
2
U (θ + π )

cos(

))I• − i cos(

(cid:17)

)σ

θ
2

)I• − i sin(

)I• − i sin(

+ π
θ
)σ
2
2
(θ + π )
2

(cid:17)

(cid:17)

)σ

(D.4)

(D.5)

(D.6)

(D.7)

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

2. Equation D.2:

1. Unfolding definition 5.2,

∂
∂θ
∂
∂θ
∂
∂θ

=

=

=

([[(O, ρ) → U (θ )]])

(tr(OU (θ )ρU †(θ )))

I• − i sin(

θ
2

)σ ) · ρ ·

)σ †)

(cid:17)

)

(tr

(cid:16)
O · (cos

θ
2
θ
I• + i sin(
2

θ
2
tr(cos2(

(cos

(cid:16)

∂
∂θ

θ
2

)Oρ + i cos(

θ
2
)Oσ ρ + sin2(

) sin(

)Oρσ †

θ
2
)σ ρσ †)

(cid:17)

θ
2

) cos(

θ
2

))′Oρ)

θ
2
θ
))′ + (cos(
2

θ
2
))′Oσ ρσ †),

) · (cos(

θ
2
θ
2

)(sin(

) · (sin(

θ
2

))′ sin(

−i sin(

θ
2
= tr(2 cos(

θ
2
+tr(i[cos(

+tr(2 sin(

tr(O · U (θ ) · ρ · (

On the other hand,
d
dθ
U (θ ) · ρ · U †(θ ))

tr(O ·

U (θ ))†) +

d
dθ

= tr

(cid:16)
O · (cos

((cos

θ
2

I• − i sin(

θ
2
)′I• + i(sin(

θ
2
))′σ †)

)σ ) · ρ ·
(cid:17) +

θ
2
)′I• − i(sin(

(cid:16)
O · ((cos

tr

θ
2
I• + i sin(

(cos

θ
2

(cid:17)

)σ †)

θ
2

= tr(2 cos(

) · (cos(

θ
2
+tr(i[cos(

θ
2
θ
2
as desired.

+tr(2 sin(

))′Oρ)

θ
2
θ
))′ + (cos(
2

θ
2
))′Oσ ρσ †),

)(sin(

) · (sin(

θ
2

))′ sin(

(D.8)

(D.9)

(D.10)

(D.11)

(D.12)

)]O(ρσ † − σ ρ))

θ
2

(D.13)

(D.14)

(D.15)

(D.16)

)]O(ρσ † − σ ρ))

θ
2

(D.17)

□

Lemma D.2. Let P(θ ) ∈ q-while(T )
v
q-while(T )
O ∈ Ov ,

v∪{A}(θ ). Then for arbitrary θ ∗ ∈ Rk , ρ ∈ D(H v ),

(θ ), P ′(θ ) ∈

1. [[(O, ρ) → P(θ ∗); P ′(θ ∗)]] = [[(O, [[P(θ ∗)]]ρ) → P ′(θ ∗)]].
2. [[(O, ρ) → P ′(θ ∗); P(θ ∗)]] = [[([[P(θ ∗)]]∗(O), ρ) → P ′(θ ∗)]],

with [[P(θ ∗)]]∗ the dual of [[P(θ ∗)]].

Proof. Observe that both P(θ ∗); P ′(θ ∗) and P ′(θ ∗); P(θ ∗) lives
in q-while(T )
v∪{A}(θ ), so we identify the “smaller” program
P(θ ∗) with IA ⊗ P(θ ∗), where I ≡ IA ◦IA denotes the identity
operation on Ancilla.

=

Fig1b, Seq.=
=

=

[[(O, ρ) → P(θ ∗); P ′(θ ∗)]]
tr((ZA ⊗ O)[[P(θ ∗); P ′(θ ∗)]]((|0⟩A⟨0|) ⊗ ρ))
tr((ZA ⊗ O)[[P ′(θ ∗)]][[IA ⊗ P(θ ∗)]]((|0⟩A⟨0|) ⊗ ρ))
tr((ZA ⊗ O)[[P ′(θ ∗)]]((|0⟩A⟨0|) ⊗ ([[P(θ ∗)]]ρ)))
[[(O, [[P(θ ∗)]]ρ) → P ′(θ ∗)]], as desired.

2. Observe that:

=

Fig1b, Sequence
=

[[(O, ρ) → P ′(θ ∗); P(θ ∗)]]
tr((ZA ⊗ O)[[P ′(θ ∗); P(θ ∗)]] ·
(cid:17)
(cid:16)
(|0⟩A⟨0|) ⊗ ρ)

tr((ZA ⊗ O)[[IA ⊗ P(θ ∗)]][[P ′(θ ∗)]] ·
(cid:16)
(|0⟩A⟨0|) ⊗ ρ)

(cid:17)

ζ ≡[[P ′(θ ∗)]]((|0⟩A ⟨0|)⊗ρ)
=

tr((ZA ⊗ O)[[IA ⊗ P(θ ∗)]]ζ ),

(D.18)

while

[[([[P(θ ∗)]]∗(O), ρ) → P ′(θ ∗)]]

(D.19)

= tr((ZA ⊗ [[P(θ ∗)]]∗(O))[[P ′(θ ∗)]]((|0⟩A⟨0|) ⊗ ρ))
= tr((ZA ⊗ [[P(θ ∗)]]∗(O))ζ ).
Now RHS (EqnD.18) equals RHS(Eqn(D.20)) via dual-
ity, as IA ⊗ P(θ ∗) does nothing on the ancilla, while
[[P(θ ∗)]]∗(O) ∈ Ov and ZA are compatible observables.
□

(D.20)

Compile(Sm(θ ))

Compile(

≡ {|Qm,0(θ ), · · · , Qm,sm (θ )|},
∂
∂θ
≡ {|Pm,0(θ ), · · · , Pm,tm (θ )|}.
(D.22)
Then for arbitrary ρ ∈ D(H v ), O ∈ Ov , we have the following
computational properties regarding the observable semantics:

(Sm(θ )))

(D.21)

[[(O, ρ) →

= [[(O, ρ) →

∂
∂θ
∂
∂θ

(S0(θ ); S1(θ ))]]

(S0(θ )); S1(θ )]]

+[[(O, ρ) → S0(θ );

∂
∂θ

(S1(θ ))]],

(D.23)

(case M[q] = m → Sm(θ ) end)]]

[[(O, ρ) →
(cid:213)

∂
∂θ
[[(O, MmρM †

= (cid:213)
m
where im runs through [0, tm];

im

m) → Pm,im (θ )]],

(D.24)

10As a reminder: we shall frequently refer to Notations in Eqns D.21 and
D.22 for the rest of the section.

))′σ ) · ρ ·

θ
2

Lemma D.3. Let Sm(θ ) ∈ add-q-while(T )
v
where w ≥ 1). Denote:10

(θ ) (∀m ∈ [0, w],

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

(S0(θ ) + S1(θ ))

(cid:17)

]]

[[(O, ρ) →

= [[(O, ρ) →

[[(O, ρ) →

(cid:16) ∂
∂θ
∂
∂θ
∂
∂θ

(S0(θ ))]] +

(S1(θ ))]]

As promised, Eqns D.23 and D.26 immediately follows
from the results above together with the corresponding defi-
nitions. So is Eqn D.27, following the same lines of unfolding
by CP-(ND component) laid out in Eqns D.33∼ D.35 then a di-
rect pattern matching by definition. To obtain D.24, observe
that

(D.25)

(D.26)

[[(O, ρ) →

∂
∂θ

(case M[q] = m → Sm(θ ) end)]]
(cid:213)

(D.36)

[[(O, ρ) → S0(θ ) + S1(θ )]]

= [[(O, ρ) → S0(θ )]] + [[(O, ρ) → S1(θ )]],

(D.27)

and

[[(O, ρ) → case M[q] = m → Sm(θ ) end]]

= (cid:213)
m

(cid:213)

jm ∈[0,sm ]

[[(O, Emρ) → Qm, jm (θ )]]

(D.28)

Proof. We first make some direct application of the code
transformation (hereinafter “CT”, Fig 4) and compilation
(hereinafter “CP”, Fig 3) rules; some results will immediately
follow from these application.

Compile

(S0(θ ); S1(θ ))

(cid:17)

(cid:16) ∂
∂θ

CT,Sequence=

Compile((S0(θ );

∂
∂θ

(S1(θ ))) +

(

∂
∂θ

(S0(θ )); S1(θ )))

CP,Sum Components
=

Compile

(cid:16)
S0(θ );

∂
∂θ

(cid:17)

(S1(θ ))

(D.29)

CP,Sequence=

(cid:222)

Compile

(S0(θ )); S1(θ )

(cid:17)

(cid:16) ∂
∂θ

{|Q0,д(θ ); P1,h(θ )|}д ∈[s0],h ∈[t1](D.30)
(cid:222)

{|P0,i (θ ); Q1, j (θ )|}i ∈[t0], j ∈[s1]; (D.31)

, where [s0], [s1], [t0], [t1] stand for e.g. [0, s0], [0, s1], [0, t0], [0, t1]
respectively; and

Compile

(cid:16) ∂
∂θ

(case M[q] = m → Sm(θ ) end)

(cid:17)

CT,Case=

(cid:16)

Compile

case M[q] = m →

(Sm(θ )) end

(cid:17)

∂
∂θ

CP,Case=

(cid:16)

FB

case M[q] = m →

(Sm(θ )) end

(cid:17)

;

∂
∂θ

also,

Compile

CT,Sum Component
=

Compile

(cid:16) ∂
∂θ
(cid:16) ∂
∂θ

(cid:17)

(D.32)

(S0(θ ) + S1(θ ))
(S0(θ )) + ∂
∂θ

(cid:17)

(S1(θ ))

CP,Sum Component
=

{|P0,0(θ ), · · · , P0,t0 |}
(cid:222)

{|P1,0(θ ), · · · , P1,t1 |}.

(D.33)

(D.34)

(D.35)

(D.37)

(D.38)

(D.39)

(cid:17)

(D.40)

=

=

Q (θ )∈FB(case M [q]= m→ ∂
∂θ

(Sm (θ )) end)

[[(O, ρ) → Q(θ )]]

(cid:213)

Q (θ )∈FB(case M [q]= m→ ∂
(Sm (θ )) end)
∂θ
tr((ZA ⊗ O)[[Q(θ )]](|0⟩A⟨0| ⊗ ρ))

(cid:16)

(cid:213)

A(cid:60)q ⊆v= (cid:213)
m∗
([[Pm∗,im∗ (θ )]]((|0⟩A⟨0|) ⊗ Mm∗ ρM †

(ZA ⊗ O) ·

im∗ ∈[0,tm∗ ]

tr

m∗))

= (cid:213)
m∗

(cid:213)

im∗

[[(O, Mm∗ ρM †

m∗) → Pm∗,im∗ (θ )]] as desired.

A few more words on Eqn D.40. Since A is disjoint from
v ⊇ q, for each Q(θ ) ∈ FB(case M[q] = m → ∂
∂θ (Sm(θ )) end),
evolving one step per the operational semantics will lead
to the configuration ⟨[[Pm∗,im∗ (θ )]], ((|0⟩A⟨0|) ⊗ Mm∗ ρM †
m∗)⟩
for some non-(essentially-aborting) Pm∗,im∗ (θ ). Besides, each
such configuration appears exactly once affording one sum-
mand, due to construction of FB(•). On the other hand, if
Pm∗,im∗ (θ ) essentially aborts, the trace computed as a sum-
mand vanishes, making no contribution to the sum, thereby
maintaining the equation.

Eqn D.28 is proved using the same lines of logic:

=

=

[[(O, ρ) → case M[q] = m → Sm(θ ) end]] (D.41)

(cid:213)

[[(O, ρ) → Q(θ )]]

Q (θ )∈FB(case M [q]= m→Sm (θ ) end)
(cid:213)

Q (θ )∈FB(case M [q]= m→Sm (θ ) end)

tr(O[[Q(θ )]]ρ)

A(cid:60)q ⊆v= (cid:213)
m∗
= (cid:213)
m∗

(cid:213)

jm∗ ∈[0,sm∗ ]
(cid:213)

jm∗ ∈[0,sm∗ ]

as desired.

(D.42)

tr(O[[Qm∗, jm∗ (θ )]]Mm∗ ρM †

m∗)

[[(O, Em∗ ρ) → Qm∗, jm∗ (θ )]]

□

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

Lemma D.4. Keeping the notations in Lemma D.3, we have
∀θ ∗ ∈ Rk , O ∈ Ov , ρ ∈ D(H v ),

(cid:16) ∂
∂θ
= (cid:213)
д ∈[0,s0]
+ (cid:213)
j ∈[0,s1]

(cid:16) ∂
∂θ

([[(O, ρ) → S0(θ ); S1(θ )]])

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

([[(O, [[Q0,д(θ ∗)]]ρ) → S1(θ )]])

(cid:16) ∂
∂θ

([[([[Q1, j (θ ∗)]]∗(O), ρ) → S0(θ )]])

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(D.43)

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(D.44)

Proof. Observe:

LHS(D.43)
(cid:213)

CP,Sequence
=

д ∈[0,s0], j ∈[0,s1]
(cid:16) ∂
∂θ

([[(O, ρ) → Q0,д(θ ); Q1, j (θ )]])

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(∗∗∗),See Below
=

(cid:213)

д ∈[0,s0], j ∈[0,s1]
(cid:16) ∂
∂θ

([[(O, [[Q0,д(θ ∗)]]ρ) → Q1, j (θ )]])

+ (cid:213)

д ∈[0,s0], j ∈[0,s1]

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗
(D.45)

(cid:16) ∂
∂θ

([[([[Q1, j (θ )]]∗(O), ρ) → Q0,д(θ )]])

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗
(D.46)

=

(cid:213)

([[(O, [[Q0,д(θ ∗)]]ρ) → S1(θ )]])

д ∈[0,s0]
(cid:16) ∂
∂θ
+ (cid:213)
j ∈[0,s1]

(cid:17)(cid:12)
(cid:12)
(D.47)
(cid:12)
(cid:12)θ ∗

(cid:16) ∂
∂θ

([[([[Q1, j (θ ∗)]]∗(O), ρ) → S0(θ )]])

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗
(D.48)

Where the last step is direct application of definition of
input-space observable semantics. For the step (***) claiming
RHS(D.45)= RHS(D.45)+ RHS(D.46), observe that it boils
down to the following: for arbitrary (д∗, j∗) ∈ [0, s0] × [0, s1],

(cid:16) ∂
∂θ

([[(O, ρ) → Q0,д∗(θ ); Q1, j ∗(θ )]])

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(D.49)

= (cid:16) ∂
∂θ

([[(O, [[Q0,д∗(θ ∗)]]ρ) → Q1, j ∗(θ )]])

(D.50)

+ (cid:16) ∂
∂θ

([[([[Q1, j ∗(θ )]]∗(O), ρ) → Q0,д∗(θ )]])

(D.51)

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗
(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

We argue the correctness of D.49∼D.51 below. Simplifying no-
tations, write Q0,д∗(θ ), Q1, j ∗(θ ) as Q0(θ ), Q1(θ ) respectively,
then let

Q0(θ ) ≡

Q1(θ ) ≡

(cid:213)

x
(cid:213)

y

Kx (θ ) ◦ K †

x (θ ),

Jy (θ ) ◦ J †

y (θ )

(D.52)

(D.53)

denote the kraus operator decomposition of Q0(θ ), Q1(θ ),
each with finitely many summands.11

Then,

(cid:16) ∂
∂θ
∂
∂θj

=

([[(O, ρ) → Qд(θ ); Qj (θ )]])

tr(O[[Q0(θ ); Q1(θ )]]ρ)

(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(D.56)

(D.57)

=

∂
∂θj

tr(O

(cid:213)

y

Jy (θ )(

(cid:213)

x

Kx (θ )ρK †

x (θ ))J †

(cid:12)
(cid:12)
(cid:12)
y (θ ))
(D.58)
(cid:12)
(cid:12)θ ∗

= (cid:213)
x,y

∂
∂θj

tr(O Jy (θ )Kx (θ )ρK †

x (θ )J †

(cid:12)
(cid:12)
y (θ ))
(cid:12)
(cid:12)θ ∗

(D.59)

(a)= (cid:213)
y

(cid:104)

(tr(O

d
dθj

(cid:213)

Jy (θ )(

x

Kx (θ ∗)ρK †

x (θ ∗))J †

y (θ ∗))

+tr(O Jy (θ ∗)(

(cid:213)

Kx (θ ∗)ρK †

x (θ ∗))

x

d
dθj

J †
y (θ )))

(cid:105)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(cid:104)

+ (cid:213)
y

(tr(O Jy (θ ∗)(

(cid:213)

x

d
dθj

Kx (θ )ρK †

x (θ ∗))J †

y (θ ∗))

11This is doable because for each θ ∗ ∈ Rk we have
Q0(θ ∗) = (cid:213)
Kx (θ ∗) ◦ K †
k =1
Q1(θ ∗) = (cid:213)
q=1

Jy (θ ∗) ◦ J †

y (θ ∗).

x (θ ∗),

(D.54)

(D.55)

Since parameterized unitaries have a parameterized-matrix representa-
tion, the superoperator U(θ ) = U (θ )) ◦ U †(θ ) for any parameterized
unitaries also have a parameterized operator representation. In our pa-
rameterized quantum program syntax only unitaries are parameterized,
thus the kraus operators Kx (θ ), Jy (θ )’s can be chosen uniformly. If one
insists one may perform a standard structural induction to show the ex-
istence of such a parameterized Kraus operator decomposition for any
Q (θ ) ∈ q-while(T )
(θ ). For example, assuming each Sm (θ ) decomposes to
v
(cid:205)tm, jm
(θ ), then case M [q] = m → Sm (θ ) decom-

Ktm, j (θ ) ◦ K †

tm, j

tm, j =tm, 1
poses into

(cid:213)

m

(cid:213)

(
tm, j

Ktm, j (θ ) ◦ K †

tm, j

(θ )) ◦ Em .

As in the unitary case, the linear Kraus operators are entry-wisesmooth,
ensured by the entry-wise smoothness of matrix representations of param-
eterized unitaries.

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

(D.65)

(D.66)

(D.67)

+ tr(O Jy (θ ∗)(

(cid:213)

Kx (θ ∗)ρ

x

d
dθj

x (θ ))J †
K †

y (θ ∗)))

(cid:105)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(b)=

∂
∂θj

(cid:12)
(cid:12)
tr(O[[Q1(θ )]]([[Q0(θ ∗)]]ρ))
(cid:12)
(cid:12)θ ∗

+ ∂
∂θj

(cid:12)
(cid:12)
tr(O[[Q1(θ ∗)]][[Q0(θ )]]ρ)
(cid:12)
(cid:12)θ ∗

(D.60)

(D.61)

S-H Dual=

(cid:16) ∂
∂θj

([[(O, [[Q0(θ ∗)]]ρ) → Q1(θ )]])

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(D.62)

recall from Lemma D.1 that

d
dθ

U (θ )

=

=

D .65=

U (θ + π ); and

1
2
∂
∂θ

([[(O, ρ) → U (θ )]])

tr(O · U (θ ) · ρ · (

U (θ ))†)

d
dθ
U (θ ) · ρ · U †(θ )).

d
dθ
(cid:16)
U (θ )ρU †(θ + π )

+tr(O ·
(cid:18)
O

tr

1
2

+U (θ + π )ρU †(θ )

(cid:17) (cid:19)

+ (cid:16) ∂
∂θj

([[([[Q1(θ ∗)]]∗(O), ρ) → Q0(θ )]])

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(D.63)

Meanwhile,

where d
dθ j

• again denotes the entry-wise derivative, and
(a), (b) is obtained by unfolding the definition of trace, notic-
ing that all entries of parameterized unitaries are smooth.
S-H dual here is short for Schrödinger-Heisenberg dual, as
is everywhere else in this section.

□

D.2 Proof Details of Theorem 6.2: Soundness of

Differentiation Logic

Proof. As stated in the main text, throughout we fix OA ≡ ZA.
Unfolding by definition, it suffices to show

∀O ∈ Ov , ρ ∈ D(H v ), [[((O, ZA), ρ) →
∂
∂θ

([[(O, ρ) → S(θ )]]).

=

∂
∂θ

(S(θ ))]]

(D.64)

Let O ∈ Ov , ρ ∈ D(H v ) be arbitrary. We consider each
rule in Figure 5 possibly used as the final step of the deriva-
tion.

1. (Abort)∼(Trivial Unitary): for S(θ ) ≡ abort[v], skip[v]

or q := |0⟩, [[(O, ρ) → S(θ )]] is a constant, so ∂

∂θ ([[(O, ρ) →
CT,trivialize
≡

∂θ (S(θ ))
∂θ (S(θ ))]] = tr((ZA⊗

S(θ )]]) = 0. On the other hand, ∂
abort[v ∪ {A}], meaning [[(O, ρ) → ∂
O) · 0) = 0.
In Trivial-Unitary, [[(O, ρ) → U (θ )]] doesn’t depend
on θj since θj (cid:60) θ ; hence ∂
([[(O, ρ) → U (θ )]]) = 0,
∂θ j
as faithfully represented by the code transformation
rule.

2. (Unitary): Assume S(θ ) ≡ U (θ ) with U (θ ) ∈ {Rσ (θ ),
Rσ ⊗σ (θ )}σ ∈ {X,Y ,Z }. Let σ range over {σ , σ ⊗σ }σ ∈X,Y,Z
(proof below works for all 6 cases where σ 2 = I•). Let
d
dθ U (θ ) denote the entry-wise derivative of U (θ ), then

CT,1-qb,2-qb=

[[(O, ρ) →

∂
∂θ
tr((ZA ⊗ O)[[R ′
((|0⟩A⟨0|) ⊗ ρ))

(U (θ ))]]

σ (θ )]] ·

Let us unfold the definition of R ′

σ (θ ):

RHS(D.67)
(cid:213)

= 1
2

x,y ∈ {0,1}

((|x⟩A⟨y|) ⊗ ρ))

tr((ZA ⊗ O)[[C_Rσ (θ ); HA]] ·

(cid:18)

(cid:16)

tr

(ZA ⊗ O)[[HA]]

= 1
2
+|0⟩A⟨1| ⊗ U (θ )ρU †(θ + π )
+|1⟩A⟨0| ⊗ U (θ + π )ρU †(θ )

|0⟩A⟨0| ⊗ U (θ )ρU †(θ )

(D.68)

(D.69)

(D.70)

(cid:17) (cid:19)

+|1⟩A⟨1| ⊗ U (θ + π )ρU †(θ + π )
(cid:16) (cid:205)

(cid:18)

tr

(cid:205)

(ZA ⊗ O)
x |x⟩A⟨0| − (cid:205)

x,y |x⟩A⟨y|
2
x |x⟩A⟨1|

= 1
2

(cid:205)

x |0⟩A⟨x | − (cid:205)

x |1⟩A⟨x |

2

2

⊗ U (θ )ρU †(θ )(D.71)

U (θ )ρU †(θ + π )(D.72)

U (θ + π )ρU †(θ )(D.73)

(cid:205)

x |x⟩A⟨x | − (|1⟩A⟨0| + |0⟩A⟨1|)
2

U (θ + π )ρU †(θ + π )

(cid:17) (cid:19)

·

(D.74)

+

+

+

Let’s regroup the terms of D.71 ∼ D.74, bearing in
mind that when observing ZA ⊗ O on the final state,

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

the “off-diagonal” part is killed by ZA.12 Hence,

This equals, by Lem D.3 Eqns D.30,D.31,

RHS(D.71 ∼ D.74)

(cid:32)

tr

(ZA ⊗ O)

(cid:18)(cid:16)

|1⟩A⟨1| + |0⟩A⟨0|

(cid:17)

= 1
4

(cid:16)
U (θ )ρU †(θ ) + U (θ + π )ρU †(θ + π )
(cid:17)

|0⟩A⟨0| − |1⟩A⟨1|

⊗
+(cid:16)

(D.75)

(D.76)

(D.77)

(D.78)

(cid:17)

(cid:16)
U (θ )ρU †(θ + π ) + U (θ + π )ρU †(θ )

⊗

(cid:17) (cid:19)(cid:33)

(D.79)

Lastly, the behavior of ZA ⊗ O ensures

RHS(D.76 ∼ D.79)= 1
2

(cid:18)
O

tr

(cid:16)
U (θ )ρU †(θ +π )+U (θ +π )ρU †(π )

(cid:17) (cid:19)

,

as desired. From this point, we again adopt the nota-
tions from Lemma D.3 Eqns D.21, D.22.

3. (Sum Component)

(cid:16) ∂
∂θ
∂
∂θ
∂
∂θ

[[(O, ρ) →

Lem D .3=

[[(O, ρ) →

(S0(θ ))]]

(S0(θ ) + S1(θ ))

(cid:17)

]]

+[[(O, ρ) →

(S1(θ ))]]

([[(O, ρ) → S0(θ )]]

∂
∂θ
+[[(O, ρ) → S1(θ )]])
∂
∂θ

([[(O, ρ) → S0(θ ) + S1(θ )]]),

IH=

Lem D .3=

as desired.

(D.80)

(D.81)

(D.82)

(D.83)

(D.84)

4. (Sequence) Assume S(θ ) ≡ S0(θ ); S1(θ ); It suffices to

show that ∀θ ∗,

[[(O, ρ) →

∂
∂θ

(S0(θ ∗); S1(θ ∗))]] = (cid:16) ∂
∂θ

([[(O, ρ) → S0(θ ); S1(θ )]])

(D.85)
Let us first manipulate the equation using some com-
putational properties developped from the helper lem-
mas:

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

Lemma D .3,Eqn D .23
=

LHS(D.85)

[[(O, ρ) →

∂
∂θ

(D.86)

(S0(θ ∗)); S1(θ ∗)]]

+[[(O, ρ) → S0(θ ∗);

∂
∂θ

(S1(θ ∗))]]

12 Namely, the trace computation can be decomposed into a finite linear
combination of the form tr((ZA ⊗ O )(|b ⟩A ⟨b′ | ⊗ •)) (b, b′ ∈ {0, 1}), and
this term vanishes whenever b (cid:44) b′.

(cid:213)

[[(O, ρ) → Q0,д(θ ∗); P1,h(θ ∗)]] (D.87)

д ∈[0,s0],h ∈[0,t1]
+ (cid:213)

i ∈[0,t0], j ∈[0,s1]

[[(O, ρ) → P0,i (θ ∗); Q1, j (θ ∗)]](D.88)

Via Lem D.2, this translates to

(cid:213)

[[(O, [[Q0,д(θ ∗)]]ρ) → P1,h(θ ∗)]] (D.89)

д ∈[0,s0],h ∈[0,t1]
+ (cid:213)

i ∈[0,t0], j ∈[0,s1]

[[([[Q1, j (θ ∗)]]∗(O), ρ) → P0,i (θ ∗)]]

[[(O, [[Q0,д(θ ∗)]]ρ) →

∂
∂θ

(S1(θ ∗))]]

(D.90)

[[([[Q1, j (θ ∗)]]∗(O), ρ) →

∂
∂θ

(S0(θ ∗))]],

(D.91)

= (cid:213)
д ∈s0
+ (cid:213)
j ∈s1

where the last step comes from definition of observ-
able semantics with ancilla. Now apply the induc-
tive hypothesis on S1(θ ), a universal statement for all
(ρ ′, O ′) ∈ D(H v )×Ov , to the instances ([[Q0,д(θ ∗)]]ρ, O))
(∀д ∈ [0, s0]), we have the first summand

RHS(D.90)
(cid:16) ∂
∂θ

= (cid:213)
д

([[(O, [[Q0,д(θ ∗)]]ρ) → S1(θ )]])

(cid:17)(cid:12)
(cid:12)
(cid:12)
(cid:12)θ ∗

(D.92)

Likewise, apply the inductive hypothesis on S0(θ ) to
the instances (ρ, [[Q1, j (θ ∗)]]∗O)) (∀j ∈ [0, s1]), we have
the second summand

RHS(D.91)
(cid:16) ∂
∂θ

= (cid:213)
j

([[([[Q1, j (θ ∗)]]∗(O), ρ) → S0(θ )]])

(cid:17)(cid:12)
(cid:12)
(D.93)
(cid:12)
(cid:12)θ ∗

Collecting everything, using again a techical lemma
from above,

RHS(D.90) + RHS(D.91)
RHS(D.92) + RHS(D.93)

RHS(D.85), as desired.

=

Lem D .4=

(D.94)

(D.95)

5. (Case) This follows again from the computational lem-
mas above, and applications of all inductive hypothesis.
For conciseness, let us denote by IH(m) (cid:55)→ (MmρM †
m, O)
the application of the m-th (m ∈ [0, w]) inductive hy-
pothesis to the instance (MmρM †
m, O) ∈ D(H v ) × Ov .
Then,

[[(O, ρ) →

(case M[q] = m → Sm(θ ) end)]]

∂
∂θ
[[(O, MmρM †

m) → Pm,im (θ )]] (D.96)

[[(O, MmρM †

m) →

∂
∂θ

(Sm(θ ))]]

(D.97)

(cid:213)

im ∈[0,tm ]

Lem D .3= (cid:213)
m
= (cid:213)
m

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

Applying the inductive hypothesis IH(m) (cid:55)→ (MmρM †
∀m, we get that the above equals

m, O),

s.t. |# ∂
∂θ j

(Pm∗(θ ))| attains that maximum. Then,

(cid:213)

∂
∂θ

([[(O, (MmρM †

m)⟩) → Sm(θ )]])

(cid:213)

(

(cid:213)

m

jm ∈[0,sm ]

[[(O, Emρ⟩) → Qm, jm (θ )]])

([[(O, ρ) → case M[q] = m → Sm(θ ) end]])

=

Lem D .3=

m
∂
∂θ

∂
∂θ

, as desired.

6. (While(T )) This is verified by successive application of

(Case) rule and (Sequence) rule T times.

□

E Detailed Proofs from Section 7
E.1 Proof for Proposition 7.2: Upper Bound of

Proof.

|# ∂
∂θ j

(P(θ ))|
1. If P(θ ) ≡ abort[v]|skip[v]|q := |0⟩ (q ∈ v), then
OCj (P(θ )) = 0 = |# ∂
(P(θ ))| by definition. Similarly,
∂θ j
if P(θ ) ≡ U (θ ) trivially used θj , no non-aborting pro-
grams exists in Compile( ∂
0; otherwise, |# ∂
∂θ j
both numbers are 1.

∂θ (P(θ ))), yielding |# ∂
∂θ j
(P(θ ))| consists of a single R ′
σ (θ ), so

2. Assume |# ∂
∂θ j

(Pb (θ ))| ≤ OCj (Pb (θ )) for each b ∈ {1, 2}
and P(θ ) ≡ P1(θ ); P2(θ ). Then (denoting as above In-
ductive Hypothesis as “IH”):

(P(θ ))| =

(P(θ ))|

|#

∂
∂θj
(∗)= |#(P1(θ );

∂
∂θj

(P2(θ )))|

+|#(

(P1(θ )); P2(θ ))|

(E.1)

∂
∂θj
∂
∂θj
∂
∂θj

≤ |#(

(P2(θ )))|

+|#(

(P1(θ )))|

IH
≤ OCj (P1(θ )) + OCj (P2(θ ))
= OCj (P(θ )).

(E.2)

(E.3)

(E.4)

where step (∗) is via rules CT,CP-(ND-Component).

3. Assume |# ∂
∂θ j

(Pm(θ ))| ≤ OCj (Pm(θ )) for each m ∈
[0, w] and P(θ ) ≡ case M[q] = m → Pm(θ ) end. Then
by the CT and CP rules of case, ∂
(P(θ )) compiles to
∂θ j
(Pm(θ ))| programs. Assume m∗ ∈ [0, w] is
maxm |# ∂
∂θ j

|#

∂
∂θj

(P(θ ))| = |#

∂
∂θj

(Pm∗(θ ))|

IH
≤ OCm∗(Pm∗(θ ))
≤ max
m
= OCj (P(θ ))

OCm(Pm(θ ))

(E.5)

(E.6)

(E.7)

(E.8)

, as desired.

4. If P(θ ) ≡ while(T ) M[q] = 1 do P1(θ ) done, it suffices
∂θ (P(θ ))| ≤ T · |# ∂
∂θ (P1(θ ))|. This is true for
∂θ (while(1)) essentially aborts. By induction

to show |# ∂
T = 1 as ∂
if this is true for T , then for T + 1 we have

(while(T +1) M[q] = 1 do P1(θ ) done)| (E.9)

(P1(θ ); while(T ) M[q] = 1 do P1(θ ) done)|

|#

|#

∂
∂θ
∂
∂θ
∂
∂θ
∂
+|#
∂θ
(T + 1)|#

|#

(P1(θ ))|

≤

Eqn E .2
≤

≤

(while(T ) M[q] = 1 do P1(θ ) done)|

∂
∂θ

(P1(θ ))|, as desired.

(E.10)

□

F Evaluation Details
F.1 Training VQC instances with controls

For any parameter α, we exhibit the final results of Compile
∂P1(Θ, Φ)
∂α

(
) and Compile(
P2(Θ, Φ, Ψ) defined in the main text:

∂P2(Θ, Φ, Ψ)
∂α

), with P1(Θ, Φ) and

1. If α ∈ Θ: without loss of generality assume α = θ1
(other situations are completely analogous). We de-
note:

Q ′(Θ) ≡ R

′

X (θ1)|A, q1⟩; · · · ; RZ (θ12)|q12⟩

then

Compile(

Compile(

∂P1(Θ, Φ)
∂α
∂P2(Θ, Φ, Ψ)
∂α

) ≡ {| Q ′(Θ); Q(Φ) |},

) ≡ {| Q ′(Θ);

case M[q1] = 0 → Q(Φ)

1 → Q(Ψ) |}.

2. If α ∈ Φ: without loss of generality assume α = ϕ1
(other situations are completely analogous). We de-
note:

Q ′(Φ) ≡ R

′

X (ϕ1)|A, q1⟩; · · · ; RZ (ϕ12)|q12⟩

PLDI ’20, June 15–20, 2020, London, UK

S. Zhu, S. Hung, S. Chakrabarti & X. Wu

) ≡ {| Q(Θ); Q ′(Φ) |},

Compile(

Compile(

∂P1(Θ, Φ)
∂α
∂P2(Θ, Φ, Ψ)
∂α

) ≡ {| Q(Θ);

case M[q1] = 0 → Q ′(Φ)

1 → Q(Ψ) |}.

3. If α ∈ Ψ: without loss of generality assume α = ψ1
(other situations are completely analogous). We de-
note:

Q ′(Ψ) ≡ R

′

X (ψ1)|A, q1⟩; · · · ; RZ (ψ12)|q12⟩

) ≡ {| abort[A, q1, · · · , q12] |},

Compile(

Compile(

∂P1(Θ, Φ)
∂α
∂P2(Θ, Φ, Ψ)
∂α

) ≡ {| Q(Θ);

case M[q1] = 0 → Q(Φ)

1 → Q ′(Ψ) |}.

F.2 Benchmark testing on representative VQCs

In this section we introduce three examples from real-world
quantum machine learning and quantum approximation al-
gorithms, all of which are very promising candidates for
implementation on near-term quantum devices. Without
loss of generality, throughout this section θ denotes θ1.

Our first case, QNN∗, starts from a slightly simplified case
from an actual quantum neural-network that has been im-
plemented on ion-trap quantum machines [58]. QAOA∗ is a
quantum algorithm that produces approximate solutions for
combinatorial optimization problems, which is regarded as
one of the most promising candidates for demonstrating
quantum supremacy [17, 50]. Quantum eigensolvers, crucial
to quantum phase estimation algorithms, usually requires
fully coherent evolution. In [38] Peruzzo et al. introduced an
alternative approach that relaxes the fully coherent evolution
requirement combined with a new approach to state prepa-
ration based on ansä and classical optimization [23, 33, 38],
namely our third example VQE∗. The control flow creating
multi-layer structures for the three families of examples are
very similar, and these algorithms mainly differ from each
other in their basic “rotation-entanglement” blocks. There-
fore I will introduce the basic blocks for all three families,
then use QNN∗ as an example to illustrate how the control
flow (if, bounded while) works.

The basic “rotate-entangle” building block for QNN consists
of a rotation stage and an entanglement stage – we consider
these two stages together a single layer: in the rotation stage,
one performs parameterized Z rotations followed by parame-
terized X rotations and then again parameterized Z rotations
on the first 4 (small scale) or 6 qubits (medium or large scale);
in the entanglement stage, one performs the parameterized
X ⊗ X rotation on all pairs from the first 4 or 6 qubits. See
Figure 7.

Basic block for VQE consists of three stages: the first stage
is parameterized X followed by parameterized Z ; the second

∂θ ()| #gates #lines

4
4
4
4
18
18
36
36
2
2
2
2
12
12
40
40
3
3
3
3
18
18
36
36

24
24
67
66
189
121
414
244
16
16
38
32
241
112
628
368
15
15
41
29
142
94
315
190

|# ∂
1
5
10
10
24
24
48
48
1
2
4
4
15
15
40
40
1
3
6
6
18
18
36
36

20
20
60
60
165
231
363
2079
14
14
28
42
224
224
576
1984
12
12
36
36
120
168
264
1512

#layers #qb’s
1
1
2
3
3
5
6
33
1
1
2
3
3
5
5
17
1
1
2
3
3
5
6
33

OC(·)
P(θ )
QNNS,b
1
QNNS,s
5
QNNS,i
10
QNNS,w
15
QNNM,i
24
QNNM,w
56
QNNL,i
48
QNNL,w
504
VQES,b
1
VQES,s
2
VQES,i
4
VQES,w
6
VQEM,i
15
VQEM,w
35
VQEL,i
40
VQEL,w
248
QAOAS,b
1
QAOAS,s
3
QAOAS,i
6
QAOAS,w
9
QAOAM,i
18
QAOAM,w 42
QAOAL,i
36
QAOAL,w
378
Table 3. Output on Test Examples. Note that: (1) {S, M, L}
stands for “small, medium, large”; {b, s, i, w } stands for “basic,
shared, if, while”; #lines is the number of lines for input
programs. (2) gate count and layer count forT -bounded while
is done by multiplying the corresponding count for loop
body with T . (3) for ∗∗,w we have |# ∂
∂θ (P(θ ))| < OC(P(θ ))
because differentiating the unrolled bounded while generates
essentially aborting programs which are optimized out of
the final multiset.

stage uses H and CNOT to entangle; the third stage performs
parameterized Z , X , Z in that order. Basic block for QAOA, on
the other hand, entangles using H and CNOT in the first
stage, and then performs parameterized X rotations on the
second stage.

The more interesting part lies in building multiple lay-
ers using control flow, which we will explain using QNN∗.
The small scale if-controlled QNN (denoted as QNNS,i ) is two-
layered. Let B denote the basic rotate-entangle block for
QNN explained as above; B ′, B ′′ be two similarly-structured
rotate-entangle blocks using different parameter-qubit com-
binations. QNNS,i performs B as the first layer, then mea-
sures on the first qubit, and performs B ′ or B ′′ as the second
layer dependent on the measurement output. For medium
and large scale if-controlled QNN (i.e. QNNM,i and QNNL,i )

On the Principles of Differentiable Quantum Programming Languages

PLDI ’20, June 15–20, 2020, London, UK

Figure 7. Circuit representation of the basic building block
of QNN. Figure credit: [58]

we have larger rotate-entangle blocks, various parameter-
qubit combinations (hence more of the B ′, B ′′’s involving
different parameter-qubit combinations), and more layers of
measurement-based control.

(Bounded) while-controled QNN works similarly: take QNNS,w
as an example, it performs the rotate-entangle block B as the
first layer, then measure the first qubit; if it outputs 0 we halt;
otherwise we perform some B ′, measure qubit q1 again, halts

if outputs 0, performs B ′ the third time and aborts otherwise
. Note that this is just a verbose way of saying “we wrapped
B ′ with a 2-bounded while-loop”! And similarly, we build
more layers on larger systems (QNNM,w , QNNL,w ) using larger
rotate-entangle blocks and more layers of bounded-while
loops. One should note how bounded while is a succinct way
to represent the circuits: as shown in Table 3, in QNNL,w we
managed to represent 2079 unitary gates in just 244 lines of
code.

We auto-differentiated the three families of quantum pro-
grams using our code transformation (hereinafter “CT”)
and code compilation (hereinafter "CP") rules. As shown
in Table 3, the computation outputs the desired multi-set of
derivative programs, and the number of non-aborting pro-
grams (|# ∂
∂θ (P(θ ))|) agrees with the upper bound described
in Proposition 7.2. It should be noted that Table 3 indicates
our auto-differentiation scheme works well for variously
sized input programs, be the size measured by code length,
gate count, layer count or qubit count, to name a few.

