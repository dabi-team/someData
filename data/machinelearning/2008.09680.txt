0
2
0
2

g
u
A
1
2

]
I

A
.
s
c
[

1
v
0
8
6
9
0
.
8
0
0
2
:
v
i
X
r
a

Transforming Probabilistic Programs for Model Checking

Ryan Bernstein
Columbia University
New York, USA

Matthijs Vákár
Utrecht University
Utrecht, Netherlands

Jeannette Wing
Columbia University
New York, USA

ABSTRACT
Probabilistic programming is perfectly suited to reliable and trans-
parent data science, as it allows the user to specify their models
in a high-level language without worrying about the complexities
of how to fit the models. Static analysis of probabilistic programs
presents even further opportunities for enabling a high-level style
of programming, by automating time-consuming and error-prone
tasks. We apply static analysis to probabilistic programs to automate
large parts of two crucial model checking methods: Prior Predictive
Checks and Simulation-Based Calibration. Our method transforms a
probabilistic program specifying a density function into an efficient
forward-sampling form. To achieve this transformation, we extract
a factor graph from a probabilistic program using static analysis,
generate a set of proposal directed acyclic graphs using a SAT solver,
select a graph which will produce provably correct sampling code,
then generate one or more sampling programs. We allow minimal
user interaction to broaden the scope of application beyond what is
possible with static analysis alone. We present an implementation
targeting the popular Stan probabilistic programming language,
automating large parts of a robust Bayesian workflow for a wide
community of probabilistic programming users.

CCS CONCEPTS
• Mathematics of computing → Bayesian computation; • Com-
puting methodologies → Symbolic and algebraic manipulation;
• Theory of computation → Program analysis.

KEYWORDS
probabilistic programming, static analysis, Bayesian workflow

ACM Reference Format:
Ryan Bernstein, Matthijs Vákár, and Jeannette Wing. 2020. Transforming
Probabilistic Programs for Model Checking. In Proceedings of the 2020 ACM-
IMS Foundations of Data Science Conference (FODS ’20), October 19–20, 2020,
Virtual Event, USA. ACM, New York, NY, USA, 11 pages. https://doi.org/10.
1145/3412815.3416896

1 INTRODUCTION
Probabilistic programming is widely used for data analysis across
many fields, such as astrophysics [12], (seasonal) forecasting [18],
pharmacology [1], and public health [4]. It is rapidly gaining in

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
FODS ’20, October 19–20, 2020, Virtual Event, USA
© 2020 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-8103-1/20/10. . . $15.00
https://doi.org/10.1145/3412815.3416896

popularity1. The key idea is to let the user specify a probabilistic
model as a high-level program, while the compiler solves the diffi-
cult task of generating performant code to fit the model using some
complex inference algorithm. Free from details of the inference
implementation, probabilistic programs are the ideal medium for
data science: replicable, interpretable, and communicable, while
staying on the cutting edge of inferential power.

Representing our data science models as programs also affords
us the opportunity to apply code analysis and transformation tech-
niques from decades of computer science research. In much the
same way that software engineers have tools to check or generate
code, data scientists could have tools to verify or construct their
models. This intersection of static analysis and probabilistic pro-
gramming is a largely unexplored area that could make data science
simultaneously more reliable, efficient and approachable.

In this paper, we apply code analysis and transformation tech-
niques to automate large parts of two model checking techniques:
Prior Predictive Checking (PPC) [7] and Simulation-based Calibra-
tion (SBC) [17]. PPC addresses the question, "Does the model as
we have written it match our actual domain knowledge?"; SBC ad-
dresses the question "Can our inference algorithm fit our specified
model reliably?". Together, these checks make up a vital part of
a robust Bayesian workflow [11], and they are used ubiquitously
within the Bayesian probabilistic modeling community.

PPC and SBC both require random draws from the prior and prior-
predictive distributions. The prior is the distribution over model
parameters prior to the data being considered, while the prior-
predictive is the distribution over the data implied by the prior.

Currently, to apply PPC or SBC, users manually write sam-
pling code which must correspond exactly to the prior and prior-
predictive distributions of their particular model. At best, this pro-
cess is time consuming, requires expertise, and duplicates the in-
formation and maintenance cost of the original program. At worst,
the produced prior-predictive distribution is wrong, causing PPC
and SBC to produce misleading results, which defeats the purpose
of these quality assurance methods.

To mitigate this issue, we present a method to transform a prob-
abilistic program into one which efficiently draws samples from
the prior and prior-predictive distributions of the model specified
by the original program. Our process either produces a guaranteed-
correct and efficient program or, in rare cases, rejects the task as
impossible, all with minimal user involvement. We focus on the
Stan language for our implementation and primary reference point,
as Stan is one of the most widely used probabilistic programming
languages, as measured by package downloads and citations [5].

Central in our approach is a novel translation from a factor graph
– a probabilistic graphical model giving a convenient intermediate

1This can be seen e.g. from download statistics of RStan on CRAN, from the citation
rate of [5], and from the push by companies like Google, Facebook, and Uber to each
develop their own in-house probabilistic programming language.

 
 
 
 
 
 
representation of a probabilistic program – into a directed acyclic
graphical (DAG) model, which admits efficient forward sampling.

This paper makes the following core contributions:

target += normal_lpdf(mu | 0, 1);
target += lognormal_lpdf(sigma | 1, 3);
target += normal_lpdf(x | mu, sigma);

(1) It presents a technique for automatically computing all pos-
sible DAGs which represent the same conditional indepen-
dence information as a given factor graph, together with a
proof of its soundness and completeness.

(2) It shows how to use this technique to derive efficient forward
sampling code from a probabilistic program presented in a
relatively unstructured representation, whenever possible.
(3) It presents an implementation targeting the Stan probabilistic
programming language, automating large parts of a robust
Bayesian workflow for a wide community of probabilistic
programming users.

The source code of our implementation is available online [3].

2 BACKGROUND
2.1 Probabilistic programs
Probabilistic models represent a joint probability distribution over
a set of unobserved parameters and observed data. One representa-
tion of a probabilistic model is as a sequence of parameters drawn
from individual distributions. For example:

µ ∼ Normal(0, 1);

σ ∼ LoдNormal(1, 3);

x ∼ Normal(µ, σ );

This represents a probabilistic model in which µ, σ and x are
drawn from distributions. We can efficiently draw samples of µ, σ
and x with the following process:

(1) draw from a Normal(0, 1) distribution; bind the result to the

variable µ.

(2) draw from LoдNormal(1, 3); bind the result to σ .
(3) draw from Normal(µ, σ ); bind the result to x.

We call this a forward sampling representation of the probabilistic
model: each variable can be drawn individually in sequence.

However, suppose instead that we want to draw µ and σ but
the variable x is observed. We then need to perform probabilistic
inference to determine the posterior distributions for µ and σ given
the observed x, and we should draw µ and σ from this posterior.
Probabilistic programs represent probabilistic models, such as
the example above, in a way that facilitates inference algorithms to
draw from the posterior distributions of the unobserved parameters.
In the Stan probabilistic programming language, models are
represented in terms of the joint density function over all observed
and unobserved variables. This function of the variables, called the
log-probability density function or lpdf, is then typically passed to
a Markov-chain Monte Carlo (MCMC) algorithm which provides
draws from the posterior distribution [9]. We could represent the
example probabilistic model as the following Stan program:

data {

real x;

}
parameters {
real mu;
real sigma;

}
model {

}
This program defines a joint lpdf function of the (observed) data x
and the (unobserved) model parameters mu and sigma. The special
variable target holds the value of the lpdf and is implicitly initial-
ized to 0 and returned at the end of model. Each variable contributes
to target according to its distribution’s density, and the final joint
density is the product (or sum, in log space) of these contributions.
This density representation of the program allows for powerful
posterior inference capabilities, but it is no longer straightforward
to follow the efficient forward-sampling procedure. The challenge
we address in this paper is to allow the user to write their program
once as a density representation, and to transform it automatically
to its corresponding a forward-sampling representation.

2.2 Efficiently sampling from model

parameters

In the modeling process, we sometimes want to sample directly from
our model of the variables, for example to perform PPC and SBC.
A practical barrier to using tools like SBC is the time it takes
to naively sample a large number of parameters from the model,
when it is presented in a density representation. In our example,
the sampling process may be written as:

(mu, sigma, x) ∼ sample(normal_lpdf(mu | 0, 1)

+ lognormal_lpdf(sigma | 1, 3)
+ normal_lpdf(x | mu, sigma));
Here, sample is some sampling algorithm, such as an MCMC method,
which takes an lpdf function of the distribution of the variables
and produces draws. Running this algorithm is not an especially
efficient way to sample. Instead, the following would be ideal:

mu ∼ sample(normal_lpdf(mu | 0, 1));
sigma ∼ sample(lognormal_lpdf(sigma | 1, 3));
x ∼ sample(normal_lpdf(x | mu, sigma));
This sampling method is potentially faster in two ways:

(1) It decomposes the sampling process to draw each variable

individually. This scales and parallelizes easily.

(2) It isolates the distributions of each variable, allowing us to
potentially recognize common distributions with known effi-
cient sampling algorithms, such as the Normal distribution.

This sequential approach, called forward sampling, is often signifi-
cantly faster than sampling from the program as a whole using an
MCMC method, and has better convergence properties [9].

2.3 Translation challenges
Ideally, we would like to translate programs written in a general
lpdf-function form into a form amenable to forward sampling.
There are a number of issues that make this translation challenging:
(1) Programmers are free to write the lpdf function as uncon-
strained code, with intermediate variables and program struc-
tures that muddle the dependencies between the variables.
(2) There may be more than one way to produce a valid transla-
tion. For example, consider the following lpdf function:

parameters {
real x, y;

}
model {

target += f1(x);
target += f2(y);
target += f3(x, y);

}
There are at least two valid interpretations of this lpdf pro-
gram as sequential sampling statements:

x ∼ sample(f1(x))
y ∼ sample(f2(y) + f3(x, y))
and

y ∼ sample(f2(y))
x ∼ sample(f1(x) + f3(x, y))
There is not enough information in the original program
to determine which of these distinct sampling distribution
assignments is correct.

(3) There are some lpdf functions which cannot be decomposed

into a sequence of sampling statements:

parameters {

real x, y, z;

}
model {

target += f1(x, y)
target += f2(x, z)
target += f2(y, z)

}
Which parameter should be drawn first? As every parameter
depends on another, this represents a directed graphical
model with a cycle. Hence, forward sampling is not possible.

2.4 Our approach
We present a process for translating probabilistic programs in lpdf
form into forward-sampling programs. We start by observing that,
at compile-time, the conditional independence structure of an lpdf-
function probabilistic program can be distilled into a factor graph,
which is an undirected graph of factors (such as f1 and f2 in the
examples above) and variables (x, y, and z). Further, we represent
probabilistic models which can be forward sampled by the more
informative abstraction of a directed acyclic graphical model. Using
these abstractions as intermediates between probabilistic programs
and forward-sampling programs, our approach works as follows:
(1) Extract a factor graph from the lpdf-function program by
applying dependency analysis to the program source code.
(2) Perform a graph transformation from the factor graph to a
directed acyclic graph (DAG), when possible. We describe
this process in the methods section.

(3) Produce forward-sampling code for the variables in topolog-

ical order of the DAG.

3 METHODS
In this section, we present our procedure for translating a factor
graph derived from a probabilistic program into to DAG from which
we can efficiently sample. We define the necessary terms below, then

define the two graph abstractions, present a sequence of algorithms,
and prove soundness and completeness properties of the methods.
For an input probabilistic program P, let S(P) be the set of state-
ments in P and let V (P) be the set of identifiers for variables in P.
Intuitively, a factor is a fragment of the program P that directly
contributes to the joint density that P represents. To be precise, a
factor f is a statement s ∈ S(P) along with the set of statements
on which s depends. Let F (P) be the set of all factors in a program,
then f ∈ F (P) ⊆ S(P) × P(S(P)), where P indicates the powerset.
When we write f (v1, v2, . . . ) with v1, v2, · · · ∈ V (P), we inter-
pret f as the function which corresponds to the density contribution
calculated by f , given specified values for vi .

Note that throughout section 3, we will work with pd f functions
rather than loд pd f functions, despite Stan factors being in lpd f
form. We find that it is more intuitive to reason about densities out-
side of loд-space. All of the results in this section can mechanically
be translated to loд-space, if desired.

3.1 Factor Graphs
A factor graph represents a probability distribution as a product
of factors that make up the distribution’s density function. A fac-
tor graph GF ac is an undirected, bipartite graph with two sets of
vertices: the sets of variables V (GF ac ) and factors F (GF ac ). For a
program P, we use V (GF ac ) = V (P) and F (GF ac ) = F (P). The edge
set E(GF ac ) ⊆ V (GF ac ) × F (GF ac ) connects each factor to the vari-
ables that it depends on. Let N ei(GF ac , f ) = {v | (v, f ) ∈ E(GF ac )}
be the set of variables which are f ’s neighbors in GF ac . A factor
graph then defines a joint density function:
pd fGF ac (V (GF ac )) = (cid:214)

f (N ei(GF ac , f ))

f ∈F (GF ac )

3.2 Directed Acyclic Probabilistic Graphical

Models

A directed acyclic probabilistic graphical model (DAG) represents a
joint probability distribution as the product of conditional density
functions which are associated with each variable. A DAG GDAG
consists of sets V (GDAG ) of vertices and E(GDAG ) ⊆ V (GDAG ) ×
V (GDAG ) of directed edges, together with, for each v ∈ V (GDAG ),
a real-valued function Dv . We think of Dv as an (unnormalized)
conditional density for v given its parents in the graph. The graph
then represents a joint density over the variables as:

pd fGDAG (V (GDAG )) = (cid:214)

Dv (v | Par (GDAG , v))

v ∈V (GDAG )
For a program P, we can choose V (GDAG ) = V (P) and E(GDAG ) ⊆
V (GDAG ) × V (GDAG ). Given a function AGDAG
: V (GDAG ) →
P(F (P)) to assign to each variable the factors that make up its
conditional density function, we can define
Dv (v | Par (GDAG , v)) = (cid:214)
f ∈AGDAG
We will refer to variables without any parents in a DAG as
root variables and variables without any children in a DAG as leaf
variables. Let Par (GDAG , v) = {v ′ | (v ′, v) ∈ E(GDAG )} be the set
of parents of v in GDAG .

f (Par (GDAG , v)).

(v)

We call a density Dv (v | v1, . . . , vN ) constant-normalized if its
total mass is constant with respect to the variables being condi-
tioned on:

∀i ∈ [1, . . . , N ],

(cid:16) ∫

∂
∂vi

Dv (v | v1, . . . , vN ) dv

(cid:17) = 0.

Let a DAG be called a constant-normalized DAG if all Dv are
constant-normalized. We note that the typical definition of a DAG
requires that each Dv be a conditional probability distribution, and
so it would trivially fit what we call a constant-normalized DAG.

Sampling from constant-normalized DAGs. We show that
3.2.1
sampling from a constant-normalized DAG G in topological order
is consistent with the joint density of the graph.

Let sample be a procedure for sampling a value from a (not

necessarily normalized) density function pd f :

P(v ← sample(pd f )) ∝ pd f (v)

We define a conditioned DAG G(cid:12)

variable v ∈ V (G) to be a DAG with variables V (G(cid:12)
v, edges E(G(cid:12)
conditional densities Dv ′ |v← ¯v (v ′|Par (v ′)) = Dv ′(v ′|Par (v ′), ¯v).

for some DAG G and root
) = V (G) −
(cid:12)v← ¯v
) = {(v ′, v ′′) | (v ′, v ′′) ∈ E(G), v ′ (cid:44) v}, and

(cid:12)v← ¯v

(cid:12)v← ¯v

Let N = |V (G)| be the number of variables in G, and let v1, . . . , vN
be any topological order of the variables in G, so that v1 is a root
and vN is a leaf. Let Vi represent the set of variables {v1, . . . , vi },
and ¯Vi represent a set of draws { ¯v1, . . . , ¯vi } for these variables.
Then, we iterate the previous construction and write G(cid:12)
= G
(cid:12)
and G(cid:12)
(cid:12)vi ← ¯vi

.
Let PG (v), PG (v1, . . . vN ), and PG (v | . . . ) be marginal, joint and
conditional distributions of the variables under the joint distribution
of G defined by the joint density pd fGDAG (V (G)).

(cid:12)Vi −1← ¯Vi −1

(cid:12)Vi ← ¯Vi

(cid:12)V0← ¯V0

= G(cid:12)

Lemma 1. For any root variable vr in a constant-normalized DAG

G, Dvr (vr ) ∝ PG (vr ).

Proof. Let vℓ be any leaf variable in G such that vℓ (cid:44) vr :

PG (vr ) =

∫

V (G)\vr

pd fGDAG (V (G))

(cid:214)

dv

v ∈V (G)\vr

∫

V (G)\vr

∫

= Dvr (vr )

= Dvr (vr )

v ∈V (G)\vr
(cid:16) ∫

(cid:214)

Dv (v | Par (v))dv

Dvℓ (vℓ | Par (vℓ))dvℓ

(cid:214)

V (G)\vr \vℓ

vℓ
Dv (v | Par (v))dv

v ∈V (G)\vr \vℓ

Dvℓ (vℓ | Par (vℓ))dvℓ

(cid:17)

Dvr (vr )

= (cid:16) ∫
vℓ
∫

(cid:214)

Dv (v | Par (v))dv

V (G)\vr \vℓ
∫

v ∈V (G)\vr \vℓ

(cid:214)

∝ Dvr (vr )

V (G)\vr \vℓ

v ∈V (G)\vr \vℓ

Dv (v | Par (v))dv

= PG\vℓ

(vr ).

Here, the fourth equality follows by constant-normalization.

We then induct with a new vℓ until there are no non-vr leaf
is

variables. At that point we have PG (vr ) ∝ PGvr

(vr ), where Gvr

G without any descendants of vr . Since vr is then both a root and
a leaf variable in Gvr

:

PG (vr ) ∝ PGvr

(vr ) ∝ Dvr (vr )

□

Lemma 2. For topologically ordered variables v1, . . . , vi−1 in a

constant-normalized DAG G,
PG |Vi −1← ¯Vi −1

(vi ) = PG (vi | ¯Vi−1)

Proof.
PG (vi | ¯Vi−1)
∫

=

V (G)\vi \Vi −1

∫

=

V (G)\vi \Vi −1
= PG |Vi −1← ¯Vi −1

(vi )

(cid:214)

Dv (v | Par (v) \ Vi−1, ¯Vi−1)dv

v ∈V (G)\Vi −1
(cid:214)

v ∈V (G)\Vi −1

Dv

(cid:12)
(cid:12)Vi −1← ¯Vi −1

(v | Par (v) \ Vi−1)dv

□

Theorem 3. When each of the variables of G v1, . . . , vN are
(cid:12)
),
(cid:12)Vi −1← ¯Vi −1

drawn in topological order according to ¯vi ← sample(Dvi
the draws ¯VN are distributed according to PG ( ¯VN ).

Proof. We calculate

P( ¯v1 ←sample(Dv1 ), . . . , ¯vN ← sample(DvN ))

= P( ¯v1 ← sample(Dv1 ))·

P( ¯v2 ← sample(Dv2 ) | ¯v1)·

. . .

P( ¯vN ← sample(DvN ) | ¯VN −1).

Since v1 is a root variable in G, by the definition of sample and
Lemma 1, P( ¯v1 ← sample(Dv1 )) ∝ Dv1 ( ¯v1) ∝ PG (v1), so P( ¯v1 ←
sample(Dv1 )) = PG ( ¯v1). By the same reasoning, since each vi is
a root variable in G(cid:12)
)) ∝
(cid:12)
(vi ) =
Dv1
(cid:12)Vi −1← ¯Vi −1
P( ¯v1 ← sample(Dvi

(vi ), so PG |Vi −1← ¯Vi −1
)). Making those substitutions:

(cid:12)Vi −1← ¯Vi −1
( ¯v1) ∝ PG |Vi −1← ¯Vi −1
(cid:12)
(cid:12)Vi −1← ¯Vi −1

, P( ¯vi ← sample(Dvi

(cid:12)
(cid:12)Vi −1← ¯Vi −1

(cid:17)

P( ¯v1 ←sample(Dv1 ), . . . , ¯vN ← sample(DvN ))

= PG ( ¯v1)·
PG |v1= ¯v1
. . .

( ¯v2)·

PG |VN −1← ¯VN −1
Then by Lemma 2, for each i: PG |Vi −1= ¯Vi −1

( ¯vN ).

( ¯vi ) = PG ( ¯vi | ¯Vi−1).

P( ¯v1 ←sample(Dv1 ), . . . , ¯vN ← sample(DvN ))

= PG ( ¯v1)·

PG ( ¯v2| ¯v1)·

. . .
PG ( ¯vN | ¯VN −1)
= PG ( ¯v1, ¯v2, . . . , ¯vN ).

□

Constant-normalization is necessary for Lemma 1. If any Dv is
not constant-normalized, the sampling process may not be consis-
tent with the joint distribution.

We define, in pseudocode, sampleG(G), a procedure which draws
a sample for each variable in a DAG G in topological order. Writing
++ for the sequence concatenation operator,

as a parent. The joint density of the resulting DAG then is

pd fGDAG (V (C(GF ac , s))) = (cid:214)
v
= (cid:214)
v

Dv (v | Par (C(GF ac , s), v))

(cid:214)

f |(v, f )∈s

f (N ei(GF ac , f ))

sampleG(G) = let vr ∈ roots(G), ¯vr ← sample(AG (vr )) in

[ ¯vr ] ++ sampleG(G(cid:12)

(cid:12)vr ← ¯vr

)

We pass sample the set AG (vr ) of assigned factors to allow for
flexibility of implementation. The graph is thus reduced in (any)
topological order, with each variable replaced by a draw from its
marginal distribution.

3.3 A relation between Factor Graphs and

DAGs

Factor graphs and DAGs are both representations of the joint den-
sity of a set of variables. We say that a DAG GDAG is a sound
transformation of a factor graph GF ac if:

(1) V (GDAG ) = V (GF ac )
(2) pd fGDAG (V (GDAG )) = pd fGF ac (V (GF ac ))
Since GDAG is a DAG, it also must be acyclic.
Let the relation σ (GF ac , GDAG ) be true if and only if GDAG is a

sound transformation of GF ac .

3.4 Defining a transformation from Factor

Graphs to DAGs

Our strategy to transform factor graphs into DAGs will be to rein-
terpret each factor as part of the conditional density function of
some variable.

A factor can only be part of the conditional density of a variable
if that factor is a function of that variable, so factors will always be
assigned to variables with which they share an edge in the factor
graph. The assignment of factors to conditional densities can thus
be thought of as selecting a subset of edges from the factor graph,
which we call the edge selection set, s ⊆ E(GF ac ).

To produce a DAG given a factor graph GF ac and an edge selec-
tion set s, we define a function GDAG = C(GF ac , s), which we call
the contraction function. The contraction function produces a DAG
with a vertex for each variable and directed edges built according
to the edge selection set:

V (C(GF ac , s)) =V (GF ac )
E(C(GF ac , s)) =

{(va, vb ) |va, vb ∈ V (GF ac ),

∃f ∈ F (GF ac ), (vb , f ) ∈ s ∧ (va, f ) ∈ E(GF ac )}

AC(GF ac,s)(v) ={ f | (v ′, f ) ∈ s, v ′ = v}

The contraction function contracts all of the edges in the selection
set, adding each variable which contributes to a contracted factor

3.5 Computing sound transformations

between Factor Graphs and DAGs

Our goal is to find the set S∗ of edge selection sets s which produce
a sound and constant-normalized DAG C(GF ac , s). Our strategy
will be as follows:

(1) Identify the set r of recognizable edges. Use heuristics to im-
mediately identify some factors as constant-normalized con-
ditional densities for a neighboring variable, producing the
set of recognizable edges, r . Discussed in section 3.5.1.
(2) Construct the set S of valid edge selection sets. Construct the
set S of edge selection sets s which produce a sound DAG
C(GF ac , s) such that r ⊆ s. We accomplish this by use of a
SAT solver. Discussed in section 3.5.2.

(3) Query the user when necessary. When it is ambiguous whether
a conditional density is constant-normalized, query the user
for an assertion of constant-normalization. Then, filter the
set S down to the subset S∗ of those edge selection sets
consistent with the query results. This is necessary because
we require that the DAG only contains constant-normalized
densities in order to sample from it (section 3.2.1).
Discussed in section 3.5.3.

(4) Generate sampling code. Generate a forward sampling pro-

gram which draws each variable v from its constant-normalized
conditional density function Dv determined by s ∈ S∗. Since
this step is implementation specific, we discuss this in section
4.1 along with our Stan implementation.

Theorem 4. The edge selection sets s in S∗ produce DAGs which

are equal to each other up to proportionality.

Proof. Let s1, s2 ∈ S∗ and v ∈ V .
Since s1 and s2 are both constant-normalized, Dv,C(GF ac,s1)(v)
and Dv,C(GF ac,s2)(v) are both proportional to the marginal dis-
tribution for v according to Theorem 3, and are therefore also
□
proportional to each other.

Due to Theorem 4, any edge selection set s ∈ S∗ will result in

the same sampling distribution.

3.5.1 Recognizing constant-normalized conditional densities. Since
we are unable to classify constant-normalization statically from
source code in general, we use simple pattern heuristics to identify
a conservative subset of cases which we call recognizable edges.
When we recognize an edge (v, f ) of the factor graph, we assert
that f makes up the entire conditional density for v.

In our Stan implementation, we can recognize a factor f as
a constant-normalized conditional density for v if the statement
of f takes the form of target += dist_lpdf(v | ..) or v
∼ dist(..), where dist_lpdf is either one of Stan’s built-in
probability distributions[19] or a user defined distribution (whose
name ends in _lpdf). User-defined function names with this suffix

are considered to be user annotations that assert that the function
implements a constant-normalized distribution.

3.5.2 Computing sound edge selection sets. Our strategy is to lever-
age a SAT solver into producing S, the set of edge selection sets s
such that σ (GF ac , C(GF ac , s)). SAT solvers take as input a proposi-
tional formula2 over a set of atomic propositions, and return the set
of subsets of atomic propositions which satisfy the formula. We will
construct a propositional formula and set of atomic propositions to
encode σ and then translate the set of solutions into the set S.

First, we construct a set of atomic propositions to represent an
edge selection set s and useful properties of s. The set of atomic
propositions Atom(GF ac ) is the union of the following:

(1) An edge (v, f) is selected. Selv,f
included in the selection set.

asserts that the edge (v, f ) is

{Selv, f

| v ∈ V (GF ac ), f ∈ F (GF ac )}

(2) There exists a path between vertices. Pv1→v2 asserts the exis-

tence of a path from v1 to v2 in C(GF ac , s).

{Pv1→v2 | v1, v2 ∈ V (GF ac )}
Let α : P(Atom(GF ac )) → P(E(GF ac )) be a function that recon-
structs an edge selection set from a SAT solution: α(A) = {(v, f ) |
Selv,f ∈ A}.

Next we construct a propositional formula, propGF ac (A), to be
true if and only if σ (GF ac , C(GF ac , α(A))) and r ⊆ α(A). The for-
mula propGF ac

is the conjunction of the following rules:
(1) The resulting DAG is acyclic. C(GF ac , s) does not include any

cycles, so no variable has a path to itself.

∀v ∈ V (GF ac ), ¬Pv→v

(2) All factors are covered. s includes at least one edge that in-

cludes each factor in F (GF ac ).

∀f ∈ F (GF ac ), ∃v ∈ V (GF ac ), Selv, f

(3) Factors are not covered more than once. s does not include
more than one edge that includes each factor in F (GF ac ).
Therefore, selecting one edge with a factor f implies that no
other edges which include f are selected.

∀f ∈ F (GF ac ), v1 ∈ V (GF ac ), v2 ∈ V (GF ac ),

(v1 (cid:44) v2) ∧ Selv1, f

=⇒ ¬Selv2, f

(4) All variables are covered. s includes at least one edge that

includes each variable in V (GF ac ).

∀v ∈ V (GF ac ), ∃f ∈ F (GF ac ), Selv, f

(5) Edges in r are included.

∀(v, f ) ∈ r , Selv, f

(6) Variables covered by r are not included again. Since in a rec-
ognizable edge (v, f ) the factor f is asserted to be the entire
conditional density for v, no other factors will contribute to
v’s conditional density.

(7) Selecting an edge creates edges in the DAG. There will be an
edge from variable v1 to variable v2 in C(GF ac , s) if, for some
factor f , there is an unselected edge (v1, f ) (implying that
v1 contributes to f ) and a selected edge (v2, f ).

∀f ∈ F (GF ac ), v1, v2 ∈ V (GF ac ),
(v1, f ), (v2, f ) ∈ E(GF ac ),

¬Selv1, f ∧ Selv2, f

=⇒ Pv1→v2

(8) Paths between variables compose.

∀v1, v2, v3 ∈ V (GF ac ), Pv1→v2 ∧ Pv2→v3 =⇒ Pv1→v3
We now construct the set S of sound edge selection sets by:
S = {α(A) | A ∈ SAT(propGF ac )}
Theorem 5 (Soundness). For any sound edge selection set s ∈ S,
we have that r ⊆ s and C(GF ac , s) is a sound transformation of GF ac .
, each variable in GF ac will appear

Proof. By rule 4 of propGF ac

in s, and so V (GDAG ) = V (C(GF ac , s)).

By rules 2 and 3 of propGF ac

, each factor will be included in

exactly one edge in s, so the joint density does not change:

pd fGDAG (V (C(GF ac , s))) = (cid:214)

(cid:214)

f (N ei(GF ac , f ))

f |(v, f )∈s

f (N ei(GF ac , f ))

v
= (cid:214)
f

= pd fGF ac (V (GF ac ))

□

Theorem 6 (Completeness). For any edge selection set s such that
C(GF ac , s) is a sound transformation of GF ac and r ⊆ s, propGF ac (s)
is true.

Proof. Suppose that there were some s = α(A) for which G =
C(GF ac , s) is a sound transformation of GF ac , but propGF ac (A) were
false. propGF ac (A) being false implies that s broke at least one
rule:

If s broke rule 1, G would be cyclic and therefore not a DAG.
If s broke rule 2, G would not include some factor in its joint
density function and would not have the same joint density as GF ac ,
and so would not be sound.

If s broke rule 3, G would include some factor in its joint density
function more than once and would not have the same joint density
as GF ac , and so would not be sound.

If s broke rule 4, G would not include some variable in V (GDAG ),

and so would not be sound.
If s broke rule 5, r ⊈ s.
If s broke rule 6, some v covered by r would have another edge,

so the variables covered by r would otherwise assigned.

Rules 7 and 8 enforce the invariant that the P_→_ propositions
reflect the paths in the DAG produced by the Sel variables, and they
cannot in themselves reject any potential s.

Breaking any of these rules results in a contradiction, so no such
□

s exists.

∀(v, f1) ∈ r , f2 ∈ F (GF ac ), f1 (cid:44) f2 =⇒ ¬Selv, f2
2The SAT solver interface we use allows us to input general propositional formulae,
which are then automatically translated to Conjunctive Normal Form.

Consequently, propGF ac (A) ⇔ σ (GDAG , C(GDAG , α(s))) ∧ r ⊆ s.
Therefore, {s(A) | A ∈ SAT(propGF ac )} = {s | σ (GDAG , C(GDAG , s))}
is a sound and complete set of edge selection sets.

3.5.3 Querying the user with ambiguous conditional densities. When
it cannot be gleaned whether a conditional density is constant-
normalized, either from a recognizable edge or from the topology
of the factor graph, then it is necessary to ask the user if they can
assert constant-normalization. This is necessary because it is not
possible to perfectly identify constant-normalization from code,
while we require all densities to be constant-normalized in order to
sample from the DAG (section 3.2.1).

There are alternatives to avoid user queries: (1) Wrap each
constant-normalized conditional density function in a recognizable
user-defined function before the tool is applied. This will disam-
biguate all conditional densities. (2) Fail when conditional densities
cannot be automatically proven constant-normalized. This will limit
the scope of application of the tool.

We describe our strategy for user queries below.
Given the set S of sound edge selection sets and the set r of
recognizable edges, our goal is to filter out edge selection sets
in S which contain conditional density assignments that are not
constant-normalized.

We will query the user with each density assignment, allowing
them to assert or not assert that the presented set of factors is
constant-normalized. We will not need to query assignments which
are included in r since those are already assumed to be constant-
normalized. We will also not need to query any variables which are
root variables in all DAGs arising from S. We can then filter out
edge selection sets with assignments which the user did not assert
are constant-normalized.

We use a query procedure, query, which takes as input a vari-
able v and a set of assigned factors F and returns true if and
only if the user asserts that the assigned density Dv (v | . . . ) =
(cid:206)

f ∈F f (N ei(GF ac , f )) is constant-normalized.
We construct the set of queries Q:

V ′ = V \ {v | (v, f ) ∈ r }
F (v, s) = { f | (v, f ) ∈ s}
Q = {(v, F (v, s)) | v ∈ V ′, s ∈ S }

The set of affirmative queries Q ′ is:

Q ′ = {(v, F ) | (v, F ) ∈ Q query(v, F )}
We can then produce the set of edge selection sets which are

consistent with the affirmative queries, S∗:

S∗ = {s | s ∈ S ∀v ∈ V ′, (v, F (v, s)) ∈ Q ′}
When the set S∗ is empty, we can conclude that no DAG can be
derived from the factor graph with the given constant-normalized
densities.

4 RESULTS
4.1 Stan implementation
We implemented a pipeline that (1) extracts a factor graph from
a Stan program, (2) produces a constant-normalized DAG3 when
possible using a SAT solver and possibly user queries, and then (3)
constructs a forward-sampling program. Parts (1) and (3) are specific

to Stan (but could be implemented for any Stan-like language), while
part (2) could readily be applied to a factor graph from any source4.

4.1.1 Extracting a factor graph from a Stan program. Factor graphs
are derived from Stan programs by a pipeline of static analyses
which we have built into the open-source Stanc3 compiler [16].

Consider a Stan program P with statement set S(P) and a set
of free variables V (P). Let VS (S) be the set of free variables in the
statement S.

We first derive a dependency graph D(P) which is a directed
graph between the statements S(P). The dependency graph has a
directed edge (s1, s2) ∈ E(D(P)) if s1 directly or indirectly influences
the behavior of s2. The dependency graph is built using a reaching
definitions monotone framework analysis on the control flow graph
[13]. As is standard, the resulting static analysis is sound but not
complete. As such it will detect a superset of the true dependencies
present in the program, resulting in a conservative approximation.
From the dependency graph D(P) and a statement S, we construct

a set VD (S) to be the set of free variables that S depends on:
VD (s1) = VS (s1) ∪ {v | (s2, s1) ∈ E(D(P)), v ∈ VS (s2)}
Next, we collect all factors in the program, F (P). Factors are
statements which have a direct effect on the density that the Stan
program represents. These take the form of:

(1) target += .. and x ∼ .. statements, which directly

increment the target value.

(2) Function calls which can affect target. In Stan, only func-

tions which the suffix _lp can affect target.

(3) reject statements. In Stan, when a reject statement is
executed, the current sample point is thrown out, which
implicitly sets the density of the point to zero.

For each statement s of the above form, we decorate s with its
statement dependencies to produce each factor f ∈ F (P):

f = (s, {s ′ | (s ′, s) ∈ E(D(P))})
We can now construct a factor graph GF ac (P):

V (GF ac (P)) = V (P)
F (GF ac (P)) = F (P)
E(GF ac (P)) = {(v, f ) | f ∈ F (P), v ∈ VD (f ))
4.1.2 Producing a constant-normalized DAG. We implement the
algorithm described in section 3.5.2 with a simple Haskell program
using the MiniSat package [3, 14, 15]. The implementation parses
the factor graph produced by the Stanc3 compiler, applies a SAT
solver, and queries the user when the constant-normalization of a
density is ambiguous (section 3.5.3).

If this process returns no solutions, we can conclude that no
sound DAG can be produced from the original factor graph with the
given constant-normalized densities, and our process terminates.

4.1.3 Generating sampling code. Finally, we construct a sampling
program using the DAG G and the program statements which dec-
orate the factors. For a set A of factors, let Stat(A) be the sequence

3Since multiple valid DAGs will have proportional conditional densities (Theorem 4),
it is not necessary to return the whole set.

4The only Stan-specific part of the DAG transformation is the heuristic to recognize
constant-normalized edges; this would need to be adapted in an implementation for
another language.

of statements in P corresponding to the factors and write Slice(A)
for their sequence of statement dependencies in P.

We first define sample(A) which generates the necessary code
for A, the set of factors assigned to the conditional density function.
sample(A) returns a list of statements which either generate sam-
ples with a Stan builtin _rng function and are decorated with an
RNG label, or calculate a density function by affecting Stan’s target
variable and are decorated with a PDF label:

block to draw from the posterior and the generated quantities
block to calculate the rank statistics [20]. The prior predictive sam-
pling code is generated in the same way as section 4.1.5. Because
SBC requires the use of a model block to sample from the poste-
rior, the whole process cannot be fit into one Stan program unless
there are no PDF code segments in the prior predictive sampling
code. Otherwise it will need one Stan program for each PDF-labeled
segment plus one.

sample(A) =

if A is a singleton factor { f } with f of the form:
target += dist_lpdf(mu | ..) or
mu ∼ dist(..)

then

(cid:0)RNG, Slice({ f }) ++ [mu = dist_rng(..)](cid:1)

else

(cid:0)PDF, Slice(A) ++ Stat(A)(cid:1)

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

We can now apply the procedure sampleG defined in section
3.2.1, which applies sample to each variable’s assigned factors in
topological order and returns a sequence of the results. The result
is a sequence of code segments decorated with RNG or PDF.

Synthesizing sampling programs as Stan programs. The way
4.1.4
that we can turn the sequence of code segments into executable
Stan programs depends on the number of segments labeled as PDF.
These statements can only be written in Stan’s model block, while
segments labeled as RNG can only be written in Stan’s transformed
data or generated quantities blocks, which are executed before
and after model, respectively. Since Stan programs only have one
model block, we will need one Stan program for each PDF-labeled
segment.

For example, suppose we have the following sequence of code

segments:

(RNG, S1), (RNG, S2), (PDF, S3), (RNG, S4)
S3 must go in the model block. Since S1 and S2 must go before S3,
they go in the transformed data block. Since S4 must go after S3,
it goes in the generated quantities block.

4.1.5
Synthesizing Stan programs for prior predictive sampling.
Prior predictive sampling is done by sampling from the model
parameters without influence from the data, and then sampling syn-
thetic data from the likelihood, using the model parameter draws.
We generate the sequence Sampr ior of sampling code for the
prior samples by removing each data variable and its neighbors
from the factor graph, and then following our method. We then
generate the sequence Sampr edict ive
of sampling code for the data
variables by removing each model parameter variables from the
factor graph, and then following our method. We then synthesize a
Stan program from Sampr ior ++ Sampr edict ive
4.1.6
Synthesizing Stan programs for Simulation-based Calibration.
Simulation-based Calibration is performed by sampling from the
prior predictive distribution, then sampling from the posterior dis-
tribution given the synthetic data, and finally calculating the rank
statistics of the generating prior samples among the posterior sam-
ples. This procedure can be achieved within Stan by using the model

.

4.2 Stan program example
We will step through two examples of translating Stan programs
into forward sampling form. The first is a simple example where
most edges are recognizable, no user queries are necessary, and
a single-program SBC can be synthesized. The second is a more
complex example where most edges are not recognizable and a user
query is necessary.

4.2.1 Eight schools example. Suppose we have the following Stan
program, which is modified5 from the well-known eight schools
problem [8]:

data {

int<lower=0> J;
real y[J];
real<lower=0> sigma[J];

}
parameters {
real mu;
real theta[J];
real<lower=0> tau;

}
model {

target += - (mu - 1) ^ 2;
target += normal_lpdf(tau | 1, 1);
target += normal_lpdf(theta | mu, tau);
target += normal_lpdf(y | theta, sigma);

}

Our goal will be to produce a new Stan program which draws

from the prior predictive distribution for y [7].

The Stanc3 compiler emits the following factor graph GF ac :

To translate this factor graph to a DAG, our implementation

follows the steps from 3.5.2:

(1) Identify the set of recognizable edges, r . The recognizable set

is r = {(theta, normal_lpdf(theta, mu, tau)),
(tau, normal_lpdf(tau, 1, 1))}.

(2) Construct the set of valid edge selection sets, S. Given the
recognizable edges, the remaining variables to be covered
are mu and tau. Each only has one option, so S = r ∪
{(mu, -(mu - 1)^2)}.

5The non-distribution expression on line 12 was added to make an instructive example,
and the distribution on line 13 was added to give tau an arbitrary prior.

(3) Query the user when necessary. We do not need to query
the user in this case, because all variables either have rec-
ognizable edges (theta and tau) or are root variables in all
DAGs arising from S and are therefore trivially constant-
normalized (mu and tau). Since we are now confident that
each assigned density in S is constant-normalized, we can as-
sert that the element s of S will produce a constant-normalized
DAG GDAG = C(GF ac , s):

(4) Generate sampling code. We first transform and decorate each
factor as in section 4.1.3, producing the sequence SAMpr ior :

(PDF, target += -(mu - 1)^2)
(RNG, tau = normal_rng(1, 1))
(RNG, theta = normal_rng(mu, tau))

To produce PPC code as in section 4.1.5, we repeat the above
process starting with a factor graph that includes the desired data
variables as vertices and holds the other data variables and model
parameter variables constant. We find that this second DAG is built
from one recognizable edge (y, normal_lpdf(y, theta, sigma)).
We can transform and decorate this factor to produce the sequence
SAMpr edict ive

:

(RNG, y = normal_rng(theta, sigma))

We now generate code for SAMpr ior ++ SAMpr edict ive

. Since
there is only one PDF element, we can produce prior predictive
sampling code in a single Stan program:

data {

int<lower=0> J;
real<lower=0> sigma[J];

}
transformed data {

real mu;
real theta[J];
real<lower=0> tau;
real y[J];

}
model {

target += - (mu - 1) ^ 2;

}
generated quantities {

tau = normal_rng(1, 1);
theta = normal_rng(mu, tau);
y = normal_rng(theta, sigma);

}
This was a simple example where we produce a sampling program
automatically.

4.2.2 Query example. Next consider the following Stan program:
data {

real a;

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

}
parameters {
real b;
real c;
real d;
real e;

}
model {

target += normal_lpdf(a | b, 1);
target += normal_lpdf(b | 1, e);
target += -c ^ 2;
target += -d ^ 2;
target += 0.5 * log(d / 2 * pi() * e^3);
target += -d * (e - c)^2 / (2 * c^2 * e);

}

Our goal will be to produce a constant-normalized DAG without
the data variables, which could then produce a sampling program.
Each line from 12 to 16 represents a non-data factor. We will refer to
these factors by line number, e.g., F12 = normal_lpdf(b | 1, e).
The factors F15 and F16 together make up an inverse Gaussian

distribution on e with mean c and shape parameter d.

The Stanc3 compiler emits the following factor graph GF ac (after

renaming):

Again we follow the steps from section 3.5.2:

(1) Identify the set of recognizable edges, r . The recognizable set

is r = {(b, F12)}.

(2) Construct the set of valid edge selection sets, S. Our implemen-
tation finds two valid edge selection sets, one in which F16
is matched with e and one in which it is matched with c. All
other ambiguity is eliminated automatically: for example,
matching F16 or F15 with d would imply a cycle of d and e.
(3) Query the user when necessary. To disambiguate between
the two elements of S, it is necessary to query the user to
determine the true constant-normalized distributions for
either d or e (the distribution for one is sufficient to infer the
other). Out implementation prompts:
Which of the following is a constant-normalized
density for e?

0: None of the below
1: lpdf(e | c, d) =

((PMinus__(d) * ((e - c) ^ 2))

/ ((2 * (c ^ 2)) * e))
+ (0.5 * log((((d / 2) * pi()) * (e ^ 3))))

2: lpdf(e | d) =

(0.5 * log((((d / 2) * pi()) * (e ^ 3))))

Enter a number 0-2:
If the user selects 0, no DAG will be produced; if the user
selects 1, the correct DAG will be produced ((a) below); if
the user selects 2, an alternate DAG will be produced ((b)
below).

also be other applications for the production of DAGs from Stan-
like programs. For example, for directly checking the structure of
the written model. When a Stan user writes a Stan program, they
will sometimes have expectations about the independence structure
in terms of a directed graph, since directed probabilistic graphical
models are common representations in machine learning [10] and
effective at communicating modeling ideas. When this is the case,
we could automatically check the user’s Stan program against their
assumptions by providing a visualization of the DAG, validating the
program against a representation of the DAG, or verifying certain
graphical properties of the program like its hierarchical structure.

(a)

(b)

5 DISCUSSION
One limitation of our approach is that we rely on a SAT solver
to perform the graph transformation between factor graphs and
DAGs. Since the SAT problem is NP-Hard, we cannot provide a
polynomial computational bound on the graph transformation nor
size bound on the number of edge selection sets, so sufficiently
large or pathological programs will not be practical applications of
this approach.

An additional limitation is that we rely on static analysis to derive
the dependency structure of Stan programs. This static analysis has
a number of limitations, all of which can jeopardize the efficiency
but not the correctness of our approach:

6 ACKNOWLEDGMENTS
Matthijs Vákár was funded by the European Union’s Horizon 2020
research and innovation programme under the Marie Skłodowska-
Curie grant agreement No. 895827. Ryan Bernstein and Jeannette
Wing supported by the Columbia University Data Science Insti-
tute. Ryan Bernstein was also supported by the National Science
Foundation under grant number 1730414 and the Office of Naval
Research under award number N00014-19-1-2204, as well as gener-
ous research awards from Facebook through the Probability and
Programming 2020 program and from the Schmidt Foundation.
This work benefited from discussions with Bob Carpenter, Andrew
Gelman, Sean Talts.

• Container types such as arrays are treated as monolithic
variables, which potentially overestimates dependence. This
will be mitigated by further engineering effort on the Stan
compiler, for example by leveraging well-known techniques
like polyhedral dependence analysis [6].

• Control flow and other value-dependent structure cannot be
perfectly predicted due to the halting problem, which can
hide dependence structure.

• There is independence structure inside some Stan math distri-
butions which is not accounted for. For example, a multivari-
ate Gaussian distribution with diagonal covariance matrix
does not introduce dependency between each dimension of
its variate.

Our method sometimes requires user interaction (avoiding user
interaction was discussed in section 3.5.3). Since the user interac-
tion is minimal and avoidable, we consider this a small limitation.
We expect that users will typically find the answer to a query to be
obvious, since the code was likely produced with a probability dis-
tribution in mind for each variable, as in section 4.2.2. If the user is
unsure, they can simply make no claims of constant-normalization
and result will be a loss of efficiency rather than loss of correctness.
Only in cases where the user makes an incorrect assertion will the
correctness of the result be compromised, and that case a hand-built
sampling program would certainly contain the same error.

We do not believe that these limitations will prevent this method
from being applicable in the vast majority of practical cases. We
hope that this tool will fit into the workflow of many Stan users,
allowing them to efficiently automate methods like SBC and PPC
and thereby produce more reliable results.

We also note that although parts of our implementation are
specific to Stan, the idea is applicable more generally to Stan-like
density-based probabilistic programming languages [2]. There may

REFERENCES
[1] Lindsay A Becker, Brenda Huang, Gregor Bieri, Rosanna Ma, David A Knowles,
Paymaan Jafar-Nejad, James Messing, Hong Joo Kim, Armand Soriano, Georg
Auburger, et al. 2017. Therapeutic reduction of ataxin-2 extends lifespan and
reduces pathology in TDP-43 mice. Nature 544, 7650 (2017), 367–371.

[2] Ryan Bernstein. 2019. Static Analysis for Probabilistic Programs. arXiv preprint

arXiv:1909.05076 (2019).

[3] Ryan Bernstein. 2020. rybern/factor-graph-to-dag. https://github.com/rybern/

factor-graph-to-dag

[4] Richard Burnett, Hong Chen, Mieczysław Szyszkowicz, Neal Fann, Bryan Hubbell,
C Arden Pope, Joshua S Apte, Michael Brauer, Aaron Cohen, Scott Weichenthal,
et al. 2018. Global estimates of mortality associated with long-term exposure to
outdoor fine particulate matter. Proceedings of the National Academy of Sciences
115, 38 (2018), 9592–9597.

[5] Bob Carpenter, Andrew Gelman, Matthew D Hoffman, Daniel Lee, Ben Goodrich,
Michael Betancourt, Marcus Brubaker, Jiqiang Guo, Peter Li, and Allen Riddell.
2017. Stan: A probabilistic programming language. Journal of statistical software
76, 1 (2017).

[6] Paul Feautrier. 1992. Some efficient solutions to the affine scheduling problem. I.
One-dimensional time. International journal of parallel programming 21, 5 (1992),
313–347.

[7] Jonah Gabry, Daniel Simpson, Aki Vehtari, Michael Betancourt, and Andrew
Gelman. 2019. Visualization in Bayesian workflow. Journal of the Royal Statistical
Society: Series A (Statistics in Society) 182, 2 (2019), 389–402.

[8] Andrew Gelman, John B Carlin, Hal S Stern, David B Dunson, Aki Vehtari, and

Donald B Rubin. 2013. Bayesian data analysis. CRC press.

[9] Charles J Geyer. 1992. Practical markov chain monte carlo. Statistical science

(1992), 473–483.

[10] Finn V Jensen et al. 1996. An introduction to Bayesian networks. Vol. 210. UCL

press London.

[11] Lauren Kennedy, Daniel Simpson, and Andrew Gelman. 2019. The Experiment
is just as Important as the Likelihood in Understanding the Prior: a Cautionary
Note on Robust Cognitive Modeling. Computational Brain & Behavior 2, 3-4
(2019), 210–217.

[12] Maggie Lieu, Will M Farr, Michael Betancourt, Graham P Smith, Mauro Sereno,
and Ian G McCarthy. 2017. Hierarchical inference of the relationship between
Concentration and Mass in Galaxy Groups and Clusters. Monthly Notices of the
Royal Astronomical Society 468, 4 (2017), 4872–4886.

[13] Flemming Nielson, Hanne R Nielson, and Chris Hankin. 2015. Principles of

program analysis. Springer.

[14] Peter Selinger. 2016. minisat-solver: High-level Haskell bindings for the MiniSat

SAT solver. https://hackage.haskell.org/package/minisat-solver

[15] Niklas Sorensson and Niklas Een. 2005. Minisat v1. 13-a sat solver with conflict-

clause minimization. SAT 2005, 53 (2005), 1–2.

[16] stan dev. 2020. A New Stan-to-C++ Compiler, stanc3. https://github.com/stan-

dev/stanc3

[17] Sean Talts, Michael Betancourt, Daniel Simpson, Aki Vehtari, and Andrew Gel-
man. 2018. Validating Bayesian Inference Algorithms with Simulation-Based
Calibration. arXiv: Methodology (2018).

[18] Sean J Taylor and Benjamin Letham. 2018. Forecasting at scale. The American

Statistician 72, 1 (2018), 37–45.

[19] Stan Development Team. 2020. Stan Functions Reference. https://mc-stan.org/

docs/2_21/functions-reference/

[20] Stan Development Team. 2020. Stan User’s Guide. https://mc-stan.org/docs/2_

23/stan-users-guide/sbc-in-stan.html

