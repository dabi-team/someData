RanStop: A Hardware-assisted Runtime Crypto-Ransomware
Detection Technique

Nitin Pundir
nitin.pundir@u.edu
University of Florida, US

Mark Tehranipoor
tehranipoor@ece.u.edu
University of Florida, US

Fahim Rahman
fahimrahman@ece.u.edu
University of Florida, US

0
2
0
2

v
o
N
4
2

]

R
C
.
s
c
[

1
v
8
4
2
2
1
.
1
1
0
2
:
v
i
X
r
a

ABSTRACT
Among many prevailing malware, crypto-ransomware poses a sig-
nicant threat as it nancially extorts aected users by creating
denial of access via unauthorized encryption of their documents
as well as holding their documents hostage and nancially extort-
ing them. is results in millions of dollars of annual losses of
the infected victims worldwide. Multiple variants of ransomware
are growing in number with capabilities of evasion from many
anti-viruses and soware-only malware detection schemes that
rely on static execution signatures. In this paper, we propose a
hardware-assisted scheme, called RanStop, for early detection of
crypto-ransomware infection in commodity processors. Speci-
cally, RanStop leverages the information of hardware performance
counters (HPCs) embedded in the performance monitoring unit
(PMU) in modern processors to observe micro-architectural event
sets and detects known and unknown crypto-ransomware variants.
In this paper, we train a recurrent neural network-based machine
learning architecture (RNN) using long short-term memory (LSTM)
model for analyzing micro-architectural events in the hardware
domain when executing multiple variants of ransomware as well
as benign programs (goodware). We create timeseries to develop
intrinsic statistical features using the information of related HPCs
and improve the detection accuracy of RanStop and reduce noise by
via LSTM and global average pooling (GAP). As an early detection
scheme, RanStop can accurately and quickly identify ransomware
within 2ms from the start of the program execution by analyzing
HPC information collected for 20 timestamps each 100µs apart.
is detection time is too early for a ransomware to make any
signicant damage, if none. Moreover, validation against benign
programs with behavioral (sub-routine-centric) similarity with that
of a crypto-ransomware shows that RanStop can detect ransomware
with an average of 97% accuracy for y random trials.

KEYWORDS
Ransomware, Hardware Performance Counters (HPC), neural net-
works, LSTM, runtime detection.

ACM Reference format:
Nitin Pundir, Mark Tehranipoor, and Fahim Rahman. 2020. RanStop: A
Hardware-assisted Runtime Crypto-Ransomware Detection Technique. In
Proceedings of arXiv, US, (eprint’2020), 11 pages.
DOI:

eprint’2020, US
2020. .
DOI:

1 INTRODUCTION
Security vulnerabilities in modern computing systems for stand-
alone and networked applications have given rise to numerous cy-
ber aacks and malware that can cause privacy breach and data loss,
compromise critical infrastructures and national security, cause -
nancial damage, and more. McAfee quarterly threat report (Jan-Mar
2017) reveals that 176 new cyber threats are being emerging every
minute [1]. Among such cyber threats and aacks, ransomware has
gained much aention due to its malicious nature and subsequent
exploitation, loss of data, and nancial loss [2–5].

Ransomware, comprising of the words ‘ransom’ and ‘malware’,
is a class of malware which asks for ransom/money from the victim
via anonymous payment mechanisms by holding the system/les as
hostage, in exchange for restoring the hijacked functionality. Since
the majority of the ransomware use cryptographic encryption-
decryption processes and key (password) exchange protocols for
‘locking’ (and later releasing) the data stored in the infected system,
this class is also known as crypto-ransomware (as oppose to the
locker-ransomware that causes a denial-of-service on the system
to restrict operational access by the user) [6, 7]. Although existed
for more than a decade, a massive rise of crypto-ransomware is
observed in the past few years as more devices with inadequate pro-
tection are being connected to the global network and its multiple
variants with stealthy nature are being fast spread out too oen. So
far, the family of crypto-ransomware has caused substantial global
nancial loss and is continuing to cost tens of millions of dollars
in consumer losses annually [3, 6]. e actual cost incurred by the
ransomware is believed to be much higher since numerous inci-
dents remain unreported from the victims. In addition to nancial
loss, crypto-ransomware aacks, especially on business organiza-
tions, law enforcement agencies, and even entertainment groups,
have resulted into loss of critical data, private information, valu-
able documents, work hours, and services [2, 5, 8, 9]. Ransomware
is considered as the main reason of 39% of malware-related data
breaches in 2018, according to Verizon’s annual report [10]. As
such, crypto-ransomware represents a major threat to all classes of
users in the modern world.

In the past few years, researchers have put much emphasis on
detecting and preventing ransomware. e majority of the pro-
posed techniques are based on static soware-centric set-up which
typically utilizes static methods such as signature (template) match-
ing in the program control ow, searching for dominant features
of malicious ransomware-like activities, and monitoring high-level
(soware) execution, API/system calls, or data to detect potentially
anomalous behavior [6, 7, 11, 12]. Unfortunately, such static and
soware-only schemes, including commercial anti-viruses, oen
fail to provide a comprehensive security against ever-growing ran-
somware. Two prime examples of ransomware evading existing

 
 
 
 
 
 
eprint’2020, , US

Nitin Pundir, Mark Tehranipoor, and Fahim Rahman

soware-only mechanisms are – (1) the latest ransomware aacks
on the city of Atlanta’s online systems shuing down the activities
for more than six days [2]; and (2) the WannaCry malware infecting
many business organizations in over 150 dierent countries[3, 5].
In both cases, systems under aack presumably had adequate pro-
tection against potential crypto-ransomware and denial of service
aacks. Soware-only schemes suer from the following intrinsic
limitations:

• ere are numerous dierent ransomware with distinct
and obscure control ow signatures that can evade static
signature-matching anti-malware schemes.

• Soware-based techniques oen require binary signature
for each variant of the ransomware (or, in general, mal-
ware). It imposes huge overhead on the database, i.e., the
size of anti-malware updates, with ever-growing polymor-
phic and metamorphic variants of a class of malware [13].
• Even in the case of a successful detection, several existing
schemes are too late (in time) at detecting a ransomware
such that the victim system and important les (or directo-
ries) may already be maliciously corrupted (encrypted) and
locked, where the possibility of the recovery is extremely
rare.

• e static signature mapping can produce a high rate of
false decisions (false positive/negative) which pose critical
impact on the smooth operation of the system.

erefore, it is apparent that the existing soware-only tech-
niques are not adequate to thwart crypto-ransomware aacks.
To address the existing challenges and limitations, we propose
a hardware-assisted runtime crypto-ransomware detection scheme,
called RanStop, for commodity computing platforms. RanStop lever-
ages existing hardware performance counters (HPCs) in the per-
formance monitoring units (PMUs), commonly available in recent
generation processors [14, 15], for runtime event-monitoring at
the micro-architectural level and utilizes state-of-the-art machine
learning technique to develop an advanced predictive model for an
early and accurate detection of known and unknown variants of
the crypto-ransomware family.

e main motivation behind developing our hardware-assisted
crypto-ransomware detection technique, RanStop, comes from the
fact that HPCs can collect multi-dimensional hardware event-traces
and micro-architectural information during program execution
with zero hardware modication. Although originally designed for
performance monitoring, HPCs (and PMUs) can be intelligently
used for security by analyzing whether a runtime event prole is
malicious in nature. Monitoring the information of hardware micro-
architectural events and developing ML-based machine learning
predictive models provide us advantages over high-level soware
features as follows.

(1) Being an integrated part of the hardware, HPCs operate
transparently to any soware running on the processor and
collect targeted micro-architectural data irrespective to the
program execution mode. erefore, soware-obfuscated
or stealthy ransomware cannot evade them.

(2) It oers multi-dimensional information from a large set of
micro-architectural sources. erefore, acquired informa-
tion can be utilized for multi-modal analysis techniques

Figure 1: Primary workow for RanStop.

such as statistical analysis and machine learning tech-
niques.

(3) Being an integrated part of the hardware, it is able to collect
information signicantly faster (oen in µs ranges) than
any soware-centric trace acquisition approach.

(4) Developed ML model can be retrained with additional
dataset for emerging ransomwares with lile to no mod-
ication in the ML framework. Also, the developed ML
model size is signicantly smaller compared to the static
signature-based database [16].

e nature of cryptro-ransomware family itself shows certain
dependency on various sub-routines (e.g., encryption and data
movement) that can be common in regular benign programs (e.g.,
disk encryption goodwares) and cannot be accurately distinguished
only via static signature analysis or control/data ow graph (CDFG)
[16, 17]. Our proposed RanStop technique can identify intrinsic
dissimilarities between crypto-ransomware and goodware from the
hardware activity signatures. RanStop, as shown in Figure 1, rst
collects runtime micro-architectural event signatures for all HPC
groups for both the ransomware and goodware. Using the collected
hardware information, a machine learning model is then developed
which takes a small runtime data and can detect ransomware with
high accuracy. e contributions of our work are as follows.

DatabaseCreationBenignRansomwareMicro-architectural Event Capture{Capturing Timeseries Data from HPC}Benign(goodware)RansomwareRuntimeMonitoring& TestingMachine Learning-based Predictive Model GenerationMachine Learning Classifier{LSTM, GAP}OfflineTrainingValidation& TestRanStop: A Hardware-assisted Runtime Crypto-Ransomware Detection Technique

eprint’2020, , US

(1) RanStop oers an accurate and noise-free collection of
hardware-domain micro-architectural activities, e.g., branch
prediction success/miss, L2 cache access, etc. for ongoing
program (command) executions for detecting malicious
event traces. is dynamic approach is applicable for both
known and unknown Ransomware with minimal runtime
and zero hardware overhead.

(2) RanStop utilizes the state-of-the-art machine learning (ML)
techniques with intelligent feature selection scheme to
accurately detect ransomware. We carry out extensive
analysis for 80 crypto-ransomware using recurrent neural
network (RNN) architecture using long short-term memory
(LSTM) and global average pooling methods [18, 19]. Our
technique provides 97% prediction accuracy on average for
selected hardware performance groups.

(3) RanStop oers signicantly early-detection for ransomware
by analyzing the micro-architectural data collected for 20
timestamps each 100µs apart from the start of the execution
(2ms in total). is allows to stop the malicious execution
at a very early stage and protects the system and les long
before undergoing signicant, if not none, damage and
data loss.

e rest of the paper is organized as follows: Section 2 highlights
prior work and relevant concepts. Section 3 describes the workow
of our proposed RanStop technique in detail. Section 4 provides the
experimental results and analysis. Finally, we conclude our work
in Section 5.

2 PRELIMINARIES
2.1 Ransomware Detection: Prior Work
e generic characteristic of the crypto-ransomware family is to ma-
liciously search and encrypt users’ les and provide decryption key
only in exchange of a ransom. Very oen crypto-ransomware per-
forms targeted aack on specic extensions, e.g., .doc, .jpg,
.pdf, or the directories that are more probable to contain im-
portant user data, e.g., My Documents folder in Windows OS.
Prevalent locker/crypto-ransomware detection techniques heav-
ily rely on inspecting program execution, monitoring system/API
calls, signature/template matching in program control ow, and
data monitoring for critical le modication. For example, Kharraz
et al.[11, 20] analyzed various ransomware families and showed
that the majority of them implement naive locking or encryption
techniques. erefore, they proposed a scheme called UNVEIL
to detect ransomware infection by using automatically generated
articial user environments where these articial environments
are created for any suspicious activities and constantly monitored.
However, this approach is not suitable for lightweight application
since deployment and monitoring of articial user puts signicant
overhead on execution time and resources without considering ker-
nel applications. Andronio et al. [12] proposed an android-based
locker-ransomware detection scheme, called HelDroid, using com-
mon ransomware characteristics, such as functions to lock screen
for android devices. is approach is very much platform-oriented
and may not be extendable to commodity processing units for accu-
rate detection. Scaife et al. [6] proposed an early-warning scheme
by analyzing variable type changes, similarity measurements, and

entropy of user data. is technique, by nature, requires signicant
data analysis and is not suitable for early detection. Sgandurra et al.
[7] presented a dynamic analysis of ransomware for higher detec-
tion accuracy using signature matching and monitoring dominant
features such as API calls. However, such dominant features can be
hidden via obfuscated sub-routines in the malware. Moussaileb et
al. [17] presented a machine learning-based ransomware detection
technique by monitoring le system traversal using decoy folders,
with the observation that the majority of ransomware start their
encryption process from the root of the hard disk. However, this
technique is prone to high false decision in case any goodware
mimics the ransomware’s traversal behavior or show no traversal
signature at all.

As we see, these techniques utilize soware-centric features to
distinguish ransomware from goodware. In addition to partial cov-
erage, these approaches also suer from dierent challenges, e.g.,
program and memory overhead for creating virtual users and envi-
ronments [11], latency and computational overhead for user storage
data analysis [7, 21], etc. In contrast, our proposed technique solely
relies on hardware-level micro-architectural information that re-
mains unaected in case of program obfuscation, stealthy execution,
and infection strength, and is readily available in modern processors
requiring zero hardware overhead.

2.2 Micro-architectural Event Monitoring for

Malware Detection

Hardware-based micro-architectural event monitoring oers a ne-
grain ltering for individual executions, can collect multi-dimensional
information, and provides a faster data collection with respect to
the soware-only monitoring schemes. For example, one or more
HPCs in the PMU can sample how many times a pre-dened event
(enabled by the associated architecture), such as cache misses, oc-
curs during the program runtime to evaluate the performance of
the system under test. PMUs in ARM and Intel x86 architectures
can be accessed and controlled via lightweight soware modules
such as likwid and perf tools [22, 23].

Although, the primary motivation behind having performance
monitors in hardware was to aid soware developers by providing
real-time feedback to diagnose bugs or identify bolenecks in the
soware for the given the hardware platform, such hardware in-
sights can aid for malware and anomaly detection as well. However,
micro-architectural characteristics of both goodware and malware
programs can be noisy due to the diusion of multiple program
executions within a given time window. erefore, it is extremely
dicult to characterize and distinguish a malicious program just by
simple observation of execution traces. Tang et al. [24] proposed
anomaly-based malware detection using HPC data. Wang et al. [25]
proposed a low-cost validation tool, namely ConFirm, to detect the
malicious modications in the rmware of embedded systems by
creating internal check-points to monitor HPC data. Malone et al.
[26] analyzed static and dynamic program modications to detect
malicious rmware by modeling the architectural characteristics of
benign programs using linear regression. Most of these approaches
considered various classes of malware and rootkits into one class
of malicious program and, therefore, combined generic signature
traces without emphasizing the intrinsic nature (and subsequent

eprint’2020, , US

Nitin Pundir, Mark Tehranipoor, and Fahim Rahman

micro-architectural activities) of the malware itself. As a result,
these techniques require a large amount of data for analysis, pro-
duces relatively large false decisions, and are not suitable for early
detection schemes focusing specic families of malware, such as
crypto-ransomware.

Very recently, Alam et al. [16] presented a scheme, named Rataa,
that leveraged HPC-provided micro-architectural event traces for
runtime detection of ransomware. is technique utilized the fast-
Fourier transform of event traces to identify prominent features for
generating a one-class classier and designed a watchdog program
with LSTM-based autoencoders for anomaly detection in program
execution trace. However, the technique was developed and vali-
dated only for a handful of ransomware variants and do not provide
any scalability information for such.

Our proposed technique, on the other hand, is extensively ana-
lyzed for a large number of ransomware and goodware for dierent
scenario and provides successful detection with low false decisions.
Our technique requires only 2ms of execution traces for correctly
classifying a ransomware versus a goodware.

2.3 Security Enhancement via Advanced
Machine Learning Techniques

One major obstacle for HPC-assisted malware detection is that
the same micro-architectural event can occur in a similar manner
(i.e., frequency count and event prole) during a benign (valid)
operation. erefore, it leads to possible false detection. However,
carefully constructed machine-learning (ML) techniques can learn
and dierentiate such events to identify anomaly with a higher
condence [27]. Two fundamental requirements for deploying
hardware-assisted anti-malware techniques are: (1) selecting high-
delity micro-architectural features and events, and (2) choosing
ecient machine learning techniques for classication.

In this work, we collect micro-architectural event traces from
selected HPCs in a timeseries fashion. We use the recurrent neural
network with long short-term memory (LSTM) architecture [16, 18,
19]. LSTM is widely popular in timeseries analysis, especially in
audio-visual domain, since it helps maintaining a constant error for
recurrent networks and continues to learn over multiple timestamps
in a series fashion. e decisions that the LSTM generates depend
on the current input, previous output, and previous memory of the
LSTM cell iteslf. e LSTM cells are usually outside the general
ow of the recurrent network and can lter the signals they receive
with their own set of weights. Alam et al. [16] used LSTM-based
auto-encoder for anomaly detection in event traces. In contrast,
our work implements a RNN-based binary classier where a LSTM
network is followed by Global Average Pooling (GAP) Layers to
reduce any overing in the model. Details of the adopted ML
architecture is discussed in Section 3.2.

3 RANSTOP: A HARDWARE-ASSISTED
RUNTIME CRYPTO-RANSOMWARE
DETECTOR

In this section, we describe our proposed technique, RanStop, for the
runtime detection of crypto-ransomware via micro-architectural
event monitoring using HPCs. We have built our framework utiliz-
ing the key observations presented in Demme et al. [27]:

Figure 2: HPC data collection scheme for ransomware and
goodware.

(1) e semantics of a program (goodware or ransomware) do
not change signicantly over dierent variants of similar
functionality and class.

(2) While accomplishing a particular task (benign or mali-
cious), there exist subtasks that cannot be radically mod-
ied and should exhibit similar micro-architectural foot-
prints.

is observation exhibits the potential of building a hardware-
assisted crypto-ransomware detector for early recognition by an-
alyzing micro-architectural events at runtime. Even though the
micro-architectural information collected via HPCs are noisy; it
can enable identifying (or, separating, at least) crypto-ransomware
from the benign activities if chosen correctly with proper optimiza-
tion. is is possible because there exists a signicant amount of
similar semantic characteristics among multiple variants of crypto-
ransomware due to the similarity of their aack behavior [17].
HPCs, being oblivious to the undergoing program, are able to col-
lect this multi-dimensional signature that can be put under further
scrutiny via machine learning for ransomware versus goodware
identication.

RanStop: A Hardware-assisted Runtime Crypto-Ransomware Detection Technique

eprint’2020, , US

Figure 3: LSTM-based model generation for crypto-ransomware detection.

Figure 1 shows the high-level workow of our porposed RanStop
technique. It consists of following major steps: (1) program data-
base creation; (2) micro-architectural event monitoring and data
collection in a timeseries fashion; (3) LSTM-based predictive model
generation (training); and, nally, (4) testing, validation, and run-
time detection. We discuss the details of each step in the following
subsections.

3.1 Program Database Creation
e very rst step of RanStop is creating a database of benign
(goodware) programs and publicly available variants of crypto-
ransomware, as shown in Figure 1. is program database is fed
to RanStop framework for subsequent micro-architectural data
collection. e platform, source, and size of the program database
is discussed in details in Sections 4.1-2.

We note that each ransomware executable was manually tested
to make sure it did not throw any runtime error; i.e., the ransome-
ware executables were compatible with the execution environment
and had access to necessary resources similar to any real-life infec-
tion. Similarly, the benign program database were also tested in a
similar fashion so the the acquired HPC dataset were not corrupted
due incompatibility.

One key point for program database creation is that the good-
ware database should contain dierent families of benign programs
with various workload. Especially, one should also consider compu-
tationally intensive programs (e.g., disk encryption programs such
as VeraCrypt [28]) that perform legit but similar operations with
respect to that of a crypto-ransomware. e motivation behind is
to oer similar semantic characteristics to dierent sub-routines
of the crypto-ransomware as well as generic user specic benign
programs. Additionally, the non-encryption benign binaries pro-
vide resemblance to silent crypto-ransomware which does not start
execution at the very rst moment of infection but resort to stealthy
operation in the background to other legit programs.

e idea behind choosing ransomware and goodware with sim-
ilar characteristics is to make sure that the proposed framework
is capable of identifying even the smallest dierences and is not

over/under-ed due to noise [29]. For example, as experimented in
Alam et al. [16], a one-class classier trained with random benign
programs may tend to separate crypto-ransomware more accu-
rately from a text editor program; but may not distinguish from
a disc encryption or le zipping program. erefore, we adopt a
well-balanced database with signicant number and variants of
ransomware and goodware. is well-balanced training scheme
allows to reduce false positive and false negative by the classier.
Note that the RanStop framework is readily scalable to a larger
dataset, as we discuss in Section 4, and it allows the user to re-train
(update) the initial model for ner detection with emerging threats.

3.2 Micro-architectural Event Monitoring and

Data Collection

In this work, we have developed our framework for an experimen-
tal Linux OS setup, whereas a majority of the real-life crypto-
ransomware are designed for Windows OS. erefore, we execute
all programs (both ransomware and goodware) in a Windows OS
virtual machine hosted by the experimental Linux system.
(For detailed conguration of the experimental platform, please
see Section 4.1.) is approach is taken because – (1) it averts the
risk of cryto-ransomware encrypting the collected HPC data which
is stored in a separate administrative-privileged directory; (2) the
Linux system provided inhospitable environment in case any ran-
somware binary manages to escape the Windows VM, so that the
rest of the networked systems (if any) in the experimental setup is
unaected.

e crypto-ransomware and benign programs from the database
are executed in a random fashion to monitor and collect micro-
architectural information from the processor using HPCs. We use
the open-source tool likwid [22] for capturing hardware data
from embedded HPCs. To make sure that the virtual machine oers
the same workload signature with or without infection, we collected
the HPC data in the following fashion, as shown in Figure 2:

• e Windows VM is hosted and run with a complete library

of programs to replicate a real-life workload.

eprint’2020, , US

Nitin Pundir, Mark Tehranipoor, and Fahim Rahman

Table 1: Performance Event Groups and Associated Metrics
for Data Collection via Likwid.

No Group Name

Metrics

• e program under test (ransomware or goodware) is pinned
to run inside the VM with no thread/resource limitations.
• Likwid is used to collect and store timestamp data from all

the CPU cores in the Linux host machine.

• Once the targeted timeseries data is collected (e.g., by com-
pletion of the program or timeout); e VM is destroyed
along with its virtual storage completely wiped to reduce
any residual noise.

• A new VM replaces the old one (e.g., corrupted one, if
infected by ransomware while collecting ransomware data)
with a backup storage image having the same state as prior
to running the program.

• Multiple iterations are performed to collect all possible
micro-architectural events with randomized execution or-
der, so that there exists no systematic data and memory
correlation, irrespective to ransomware or goodware exe-
cution.

e collected micro-architectural events (and respective values)
are then categorized into dierent performance groups on the basis
of event context, such as BRANCH, L2 DATA, ICACHE, etc.,
along with associated event counts and metrics, as shown in Table
1. ese associated events are given input to the next stage LSTM
network for ML-based predictive model building. More details on
these hardware features with appropriate optimizers and event
counts are discussed in Section 3.4 and Section 4.3.

3.3 LSTM-based Predictive Model Generation

(training and validation)

For generating a ML-based predictive model, that will be used for
detecting ransomware via runtime event monitoring, we utilize
LSTM-based recurrent neural network [18, 19] for performing a
timeseries classication of the micro-architectural event signatures.
As shown in Figure 3, the collected hardware event values are pro-
vided as the input features to the LSTM layer of the ML architecture.
e reason for using this specic neural model is already discussed
in Section 2.3. A standard LSTM cell can remember values over
time interval making it best candidate to classifying timeseries data
of micro-architectural events from the process execution.

Aer the LSTM layer, a global average pooling (GPA) layer is used
to reduce the intrinsic training features created by the LSTM layer.
is can signicantly improve the model accuracy and prevent
over-ing of the tensor. For our specic application, it reduces
the spatial dimension of a three dimension model to one dimension
as necessary for the following layer. For example, a tensor of
dimension a × b × c is reduced to dimension of 1 × 1 × d aer the
GAP layer. e produced features at this stage is then fed as input
to the fully connected layer of the neural network architecture for
generating the binary classication model (i.e., goodware versus
ransomware).

1

2

3

4

5

6

7

8

9

BRANCH

CLOCK

CYCLE
ACTIVITY

DATA

FLOPS DP

ICACHE

L2 DATA

L2 CACHE

L3 DATA:

10

L3 CACHE

11

TLB DATA

12

TLB INSTR

13

UOPS

14

UOPS EXEC

Branch rate
Branch misprediction rate
Branch misprediction ratio
Instructions per branch
Uncore Clock [MHz]
Cycles without execution [%]
Cycles with stalls due to L1D [%]
Cycles with stalls due to L2 [%]
Cycles w/o execution due to memory [%]
Load to store ratio
DP MFLOP/s
AVX DP MFLOP/s
Packed MUOPS/s
Scalar MUOPS/s
Vectorization ratio
L1I request rate
L1I miss rate
L1I miss ratio
L1I stall rate
L2D load bandwidth [MBytes/s]
L2D load data volume [GBytes]
L2D evict bandwidth [MBytes/s]
L2D evict data volume [GBytes]
L2 bandwidth [MBytes/s]
L2 data volume [GBytes]
L2 request rate
L2 miss rate
L2 miss ratio
L3 load bandwidth [MBytes/s]
L3 load data volume [GBytes]
L3 evict bandwidth [MBytes/s]
L3 evict data volume [GBytes]
L3 bandwidth [MBytes/s]
L3 data volume [GBytes]
L3 request rate
L3 miss rate
L3 miss ratio
L1 DTLB load misses
L1 DTLB load miss rate
L1 DTLB load miss duration [Cyc]
L1 DTLB store misses
L1 DTLB store miss rate
L1 DTLB store miss duration [Cyc]
L1 ITLB misses
L1 ITLB miss rate
L1 ITLB miss duration [Cyc]
Issued UOPs
Executed UOPs
Retired UOPs
Used cycles ratio [%]
Unused cycles ratio [%]
Avg stall duration [cycles]
Used cycles ratio [%]
Unused cycles ratio [%]
Avg stall duration [cycles]
Used cycles ratio [%]
Unused cycles ratio [%]
Avg stall duration [cycles]

3.4 Model Generation, Validation, and

15

UOPS ISSUE

Detection

e nal steps of the proposed RanStop is to generation of the
predictive model based on the given dataset, and validation and
deployment of the model for runtime detection. It should be noted

16

UOPS RETIRE

RanStop: A Hardware-assisted Runtime Crypto-Ransomware Detection Technique

eprint’2020, , US

that the impacts of dierent optimizers and the micro-architectural
performance groups collected in previous steps are not all same
for detecting potential crypto-ransomware with high accuracy (see
Section 4). Also, since the number of hardware performance coun-
ters are limited on any system, the real time detection program
(watchdog) can only be trained to work for certain performance
groups and may not swap between monitors to monitor dierent
set of data too oen.

4 EXPERIMENTAL RESULTS
4.1 Experimental Platform
e system used as the experimental platform was based on Intel
Xeon CPU-E3-1225 Coffeelake processor with a maximum
operating frequency of 3.30 GHz and 32GB RAM. It was a single
socket quad-core processor with L1, L2, and L3 Cache of 32kB,
256kB, and 8MB, respectively. e operating system was Ubuntu
16.04 LTS and likwid-4.3.2 [22] was used for HPC event
collection.

4.2 Program Database Creation
For this work, we considered 80 crypto-ransomware executables
and 76 benign (goodware) programs all of which had a execution
time of at least 2ms or more. Irrespective to total runtime, we col-
lected data for the rst 2ms only because our primary objective is
an early detection. e crypto-ransomware database was collected
from VirusShare [30] which comprised of Windows executable
(.exe) les. For the benign programs, we used combination of en-
cryption algorithms provided by the OpenSSL [31] and collection
of random C programs from Github [32, 33]. e benign encryp-
tion binaries are used to encrypt a local directory from govdocs1
[34].

4.3 Micro-architectural Event Capture
Figure 4 depicts sample hardware events collected for goodware and
crypto-ransomware for dierent performance group. Here, HPC
information was collected for 20 timestamps, each being 100µs
apart. Our objective was to accurately detect ransomware within
the 2ms execution threshold; and as we will see in Section 4.4, we
were successful to correctly classify ransomware from a goodware
just utilizing hardware information of these 20 timestamps. As one
can see, this detection time is too early for a ransomware to make
any signicant damage, if none.

We also saw that the timeseries data dierences between the
two classes were not necessarily signicantly large to readily dis-
tinguish between ransomware versus goodware. Additionally, the
dierences (or similarities) at some timestamps might have occured
due to system noise and additional runtime overhead. erefore, it
was necessary that the developed detection scheme ccould reduce
any noise and optimized the intrinsic features to accurately identify
ransomware threats.

It should be noted that each performance group can collect 4
or fewer micro-architectural events due to hardware limitations.
Because, for our experimental system, only four general-purpose
HPCs are available in each core when hyperthreading is enabled
[14]. In addition to micro-architectural event count, likwid read-
ily provides scalar information based on dierent performance

Table 2: Accuracy with 70% Training Dataset

BRANCH
CLOCK
CYCLE ACTIVITY
DATA
FLOPS DP
ICACHE
L2 DATA
L2 CACHE
L3 DATA
L3 CACHE
TLB DATA
TLB INSTR
UOPS
UOPS EXEC
UOPS ISSUE
UOPS RETIRE

Adadelta Adamax RMSprop
78.69%
80.74%
80.42%
80.01%
86.90%
89.02%
86.00%
85.50%
82.73%
85.40%
95.32%
48.90%
78.86%
78.00%
78.05%
77.54%

76.73%
76.73%
77.75%
78.56%
88.89%
85.78%
80.04%
82.27%
84.30%
83.27%
95.36%
48.90%
73.53%
76.77%
78.17%
77.96%

77.41%
77.02%
77.32%
79.07%
85.67%
83.54%
82.51%
80.31%
82.85%
84.68%
96.34%
48.90%
75.28%
76.90%
77.46%
78.31%

Table 3: Accuracy with 80% Training Dataset

BRANCH
CLOCK
CYCLE ACTIVITY
DATA
FLOPS DP
ICACHE
L2 DATA
L2 CACHE
L3 DATA
L3 CACHE
TLB DATA
TLB INSTR
UOPS
UOPS EXEC
UOPS ISSUE
UOPS RETIRE

Adadelta Adamax RMSprop
79.37%
86.06%
82.81%
80.24%
87.07%
87.38%
87.63%
86.50%
87.00%
87.38%
95.52%
50.00%
77.68%
77.68%
79.93%
78.81%

77.43%
79.37%
78.11%
77.61%
90.51%
87.38%
81.88%
81.12%
85.82%
85.06%
96.45%
50.00%
73.75%
76.19%
77.49%
76.93%

74.88%
79.50%
77.75%
77.12%
87.00%
83.12%
81.43%
82.49%
82.05%
84.87%
96.57%
50.00%
72.88%
78.75%
76.75%
77.06%

SGD
53.95%
52.37%
54.59%
53.86%
58.75%
55.44%
53.14%
52.63%
51.61%
53.61%
52.80%
48.90%
52.12%
55.01%
54.03%
53.39%

SGD
50.50%
51.87%
53.69%
53.12%
58.94%
51.06%
51.63%
52.68%
52.81%
53.44%
52.37%
50.00%
51.06%
52.12%
53.31%
51.94%

metrics as shown in Table 1. For the ease of analysis, we consider
available pre-processed metric information for feature selection,
training, and testing in the subsequent steps, rather than naively
using raw hardware event counts which are oen noisy and require
data pre-processing such as scaling and alignment [24, 27].

4.4 Performance Analysis of the ML Classier
As discussed in Section 3.2 and Section 4.3, we develop the pre-
dictive ML model by training with timeseries dataset of individ-
ual performance groups and associated metrics (see Table 1) for
given ransomware and goodware database. Note that selecting
such groups and features depend on multiple factors: (1) inher-
ent properties of the ML technique that utilizes such features to
perform binary classication and (2) the program behavior that is
running on the system (performing extensive encryption versus
simple output printing).

At rst, we used Keras python library [35] to implement the
neural network under training. Equal distribution of benign and
ransomware was maintained in the training dataset to prevent

eprint’2020, , US

Nitin Pundir, Mark Tehranipoor, and Fahim Rahman

Figure 4: Distribution of example micro-architectural events among benign and ransomwares for dierent performance
groups. X-axis shows 20 timestamps from the start of the execution, each timestamp are 100µs apart. Y-axis shows respec-
tive micro-architectural event count in the embedded hardware performance counter.

inclination of ML towards a specic dataset. e training was
done on four dierent optimizers belonging to dierent classes,
i.e., SGD, Adamax, Adadelta, and RMSprop, to calibrate
network weights based on error for reducing the validation loss [36].
We used 25% of the training dataset for validation aer each epoch
to eciently calibrate the loss function of the model. Also, to reduce
any bias in the model due to mising, the accuracy analysis was

performed over 50 iterations, where each run contained randomly
shued executables and trained for 1000 epochs.

For an in-depth analysis of the RanStop technique, we analyzed
the accuracy of the predictive model where it was developed using
dierent sizes of training dataset, namely 70% (Table 2), 80% (Table
3), and 90% (Table 4) with previously mentioned optimizers. Here,
each value represents the fraction of the total dataset that was
used for training. e remainders of the dataset, i.e., 30%, 20%,

RanStop: A Hardware-assisted Runtime Crypto-Ransomware Detection Technique

eprint’2020, , US

Table 4: Accuracy with 90% Training Dataset

Table 5: Statistics for Adadelta with 70% training data

BRANCH
CLOCK
CYCLE ACTIVITY
DATA
FLOPS DP
ICACHE
L2 DATA
L2 CACHE
L3 DATA
L3 CACHE
TLB DATA
TLB INSTR
UOPS
UOPS EXEC
UOPS ISSUE
UOPS RETIRE

Adadelta Adamax RMSprop
76.51%
82.50%
78.62%
80.50%
85.99%
85.62%
87.88%
86.50%
83.50%
87.87%
96.52%
50.00%
76.25%
78.74%
78.86%
76.50%

78.12%
77.49%
79.76%
76.25%
90.88%
84.13%
83.75%
82.00%
85.88%
85.88%
98.26%
50.00%
75.37%
78.12%
75.87%
76.87%

76.00%
77.49%
79.24%
76.38%
85.50%
84.75%
81.38%
80.12%
85.00%
87.14%
97.26%
50.00%
72.14%
77.37%
78.37%
78.87%

SGD
51.50%
51.12%
53.37%
53.50%
61.00%
50.75%
50.62%
53.62%
50.88%
52.38%
51.00%
50.00%
51.37%
51.88%
53.25%
51.37%

and 10% for respective cases, were used for testing. For each table,
the detection accuracy (averaged over 50 iterations) is listed with
the HPC groups (row) and optimizers (column). As seen from
Tables 2, 3, and 4, the Adadelta performed the best for all HPC
groups in minimizing the over ing. On the other hand SGD
performed the worst. A detailed scrutiny suggested that the SGD
overed the model due to the lack of data endpoints. e rest three
of the optimizers performed quite similar to each other. On the
other hand, the most prominent micro-architectural event group
was TLB DATA which provided the best detection rate, whereas
TLB INSTR provided the worst outcome. e results show that
even with 70% training dataset, Ranstop was able to achieve as
high as 96% accuracy by correctly identifying benign versus crypto-
ransomware. And the accuracy goes to as high as 97% while the
training dataset contains 90% of the total timeseries data. We also
note that the programs (ransomware/benign) used for testing the
model were not any part of the training dataset, as mentioned
previously. erefore, this supervised classier is fully compatible
for detecting unknown ransomware, i.e., emerging variants with
no (or, very limited, if needed at all) retraining.

False Negative Rate and False Positive Rate are also calculated
using the equation 1. We consider both false negatives and false
positives as major drawbacks for any ransomware (or malware, in
general) detection technique, since false positives, i.e., true benign
programs deemed as ransomware, cause inconvenience and proba-
ble denial of service, whereas false negatives, i.e. true ransomware
detected as benign program, can cause catastrophic damage to the
system.

𝐹 𝑁 𝑅𝑎𝑡𝑒 =

𝐹 𝑁
𝐹 𝑁 + 𝑇 𝑃

, 𝐹 𝑃𝑅𝑎𝑡𝑒 =

𝐹 𝑃
𝐹 𝑃 + 𝑇 𝑁

(1)

Tables 5 and 6 show the results for statistical metrics (True
Positive, True Negative, False Positive, and False Negative) for two
of the best performing optimizers, i.e. Adadelta and RMSprop. e
results are again averaged over 50 iterations for each performance
group to remove any bias or residual count. e results show that
if we remove the outlier case of TLB INSTR, the false negative

BRANCH
CLOCK
CYCLE ACTIVITY
DATA
FLOPS DP
ICACHE
L2 DATA
L2 CACHE
L3 DATA
L3 CACHE
TLB DATA
TLB INSTR
UOPS
UOPS EXEC
UOPS ISSUE
UOPS RETIRE

TP
49.11%
48.09%
50.51%
48.09%
47.49%
48.21%
47.87%
50.09%
48.00%
46.00%
49.57%
0.00%
49.02%
50.89%
49.83%
50.30%

TN
29.57%
32.64%
31.62%
31.91%
39.40%
40.81%
38.13%
35.40%
34.72%
39.40%
45.74%
48.94%
29.83%
27.11%
28.21%
27.23%

FP
19.36%
16.30%
19.45%
17.02%
9.53%
8.13%
10.81%
13.53%
14.21%
9.53%
3.19%
0.00%
19.11%
21.83%
20.72%
21.70%

FN
1.96%
2.98%
0.55%
2.98%
3.57%
2.85%
3.19%
0.98%
3.06%
5.06%
1.49%
51.06%
2.04%
0.17%
1.23%
0.77%

Table 6: Statistics for RMSprop with 70% training data

BRANCH
CLOCK
CYCLE ACTIVITY
DATA
FLOPS DP
ICACHE
L2 DATA
L2 CACHE
L3 DATA
L3 CACHE
TLB DATA
TLB INSTR
UOPS
UOPS EXEC
UOPS ISSUE
UOPS RETIRE

TP
48.77%
49.15%
50.04%
49.62%
48.64%
47.87%
44.81%
48.26%
46.77%
46.77%
50.17%
0.00%
48.38%
49.96%
50.43%
50.04%

TN
27.96%
27.57%
29.36%
28.94%
40.26%
37.91%
35.23%
34.00%
37.53%
36.51%
45.19%
48.94%
25.15%
26.81%
27.74%
27.91%

FP
20.98%
21.36%
21.70%
20.00%
8.68%
11.02%
13.70%
14.94%
11.40%
12.43%
3.74%
0.00%
23.79%
22.13%
21.19%
21.02%

FN
2.30%
1.91%
1.02%
1.45%
2.43%
3.19%
6.26%
2.81%
4.30%
4.30%
0.89%
51.06%
2.68%
1.11%
0.64%
1.02%

(identifying crypto-ransomware as benign) rate is less then 1% for
many of the performance groups. e result also shows the false
positive (identifying benign as ransomware) is lile high that can
be concluded to the fact that many micro-architectural activities
of benign programs may resemble that of a crypto-ransomware.
We expect that the false positive will signicantly reduce with the
increase in the dataset size and diversity as a future work.

In Table 7, we provide a comparative analysis between our pro-
posed RanStop scheme and existing state-of-the-art techniques for
ransomware detection. e table lists dierent detection techniques,
dataset sizes, and performance metric. As it is shown, RanStop has
provided signciantly beer result over a comprehensive database
of ransomware and goodware; and can provide an early detection
with very high accuracy.

5 CONCLUSION
In this paper, we present a hardware-assisted crypto-ransomware
runtime detector, called RanStop. Our proposed technique can de-
tect ransomware with an average of 97% with data collected as

eprint’2020, , US

Nitin Pundir, Mark Tehranipoor, and Fahim Rahman

Table 7: Comparative Analysis of Existing Techniques

Detection Type
Key Features
Ransomware Database Size
Goodware Program Versatility
Signature Collection Time
Average Accuracy

Kharazz
et al. [11]
Static
-
-
Random
-
-

Scaife
et al. [6]
Static
API Calls
-
Random
-
-

Alam
Moussaileb
et al. [17]
et al. [16]
Static + Dynamic Dynamic
graph
∼700
Random
-
in order of 60%

hardware-assisted
<5
Random + Computationally Intensive
In order of seconds
100% (for selective RW)

RanStop

Dynamic
hardware-assisted

80
Random + Computationally Intensive

In order of milliseconds
97%

early as 2ms from the start of execution of a ransomware. Such a
very early detection technique ensures that a system, even if some-
what infected, will suer lile or no damage by crypto-ransomware,
and, therefore, robust against any stealthy ransomware aack. e
LSTM-based ML modeling scheme oers a high accuracy for mul-
tiple optimizers; giving the user complete freedom to choose for
while deploying the model for runtime detection. Although fast and
accurate, our proposed scheme, like many other existing techniques,
suers from additional challenges – especially, (1) Like any other
watchdog program, the runtime detection program itself may be
vulnerable to malicious infections and the obtained hardware data
may get corrupted. Hence, the program must run at the highest
privilege level, be independent of any other program, and have
access to sucient resources (e.g., physical memory). (2) Due to
hardware (physical) limitations, it is not possible to simultaneously
access and monitor all micro-architectural events via available lim-
ited number of HPCs. Moreover, the micro-architectural events
collected by HPCs are historically performance-oriented. erefore;
it does not necessarily provide security-aware micro-architectural
events that may become signicant for the detection of emerging
threats. is will require development and implementation of ad-
ditional HPC-like register for wider event coverage. We leave this
challenges as a future scope to this work.

REFERENCES
[1] McAfee Labs reats Report: April 2017. [Accessed: 14 June 2019]. [Online].

Available: hps://www.mcafee.com/April2017reatsReport

[2] K. Hutcherson. Ransomware reigns supreme in 2018, as phishing aacks
continue to trick employees. [Accessed: 14 June 2019]. [Online]. Available: hps:
//www.cnn.com/2018/03/27/us/atlanta-ransomware-computers/index.html
[3] R. Vamosi. WannaCry ransomware aack takes the world by storm. [Accessed:
14 June 2019]. [Online]. Available: hps://www.synopsys.com/blogs/soware-
security/wannacry-ransomware/

[4] G. O’Gorman and G. McDonald, Ransomware: A growing menace.

Corporation, 2012.

Symantec

[5] A. Liptak. (2017) e WannaCry ransomware aack has spread to 150 countries.
[Accessed: 14 June 2019]. [Online]. Available: hps://www.theverge.com/2017/5/
14/15637888/authorities-wannacry-ransomware-aack-spread-150-countries

[6] N. Scaife, H. Carter, P. Traynor, and K. R. Butler, “Cryptolock (and drop it):
stopping ransomware aacks on user data,” in Distributed Computing Systems
IEEE, 2016, pp. 303–312.
(ICDCS), 2016 IEEE 36th International Conference on.
[7] D. Sgandurra, L. Mu ˜noz-Gonz´alez, R. Mohsen, and E. C. Lupu, “Automated
dynamic analysis of ransomware: Benets, limitations and use for detection,”
arXiv preprint arXiv:1609.03020, 2016.

[8] E. Arnold. Tennessee sheri pays ransom to cybercriminals. [Accessed: 14 June
2019]. [Online]. Available: hp://www.bizjournals.com/memphis/blog/2014/11/
tennessee-sheri-pays-ransom-to-cybercriminals-in.html

[9] Radiohead refuses to pay ransom, releases stolen music for fans. [Accessed: 14
June 2019]. [Online]. Available: hps://www.latimes.com/entertainment/music/
la-et-ms-radiohead-ok-computer-demos-hackers-20190611-story.html

[10] Ransomware reigns

as phishing aacks continue
to trick employees.
[Online]. Avail-
June
able: hps://www.techrepublic.com/article/ransomware-reigns-supreme-in-

supreme in 2018,
14

[Accessed:

2019].

2018-as-phishing-aacks-continue-to-trick-employees/

[11] A. Kharraz, S. Arshad, C. Mulliner, W. K. Robertson, and E. Kirda, “Unveil: A
large-scale, automated approach to detecting ransomware.” in USENIX Security
Symposium, 2016, pp. 757–772.

[12] N. Andronio, S. Zanero, and F. Maggi, “Heldroid: Dissecting and detecting mobile
ransomware,” in International Workshop on Recent Advances in Intrusion Detection.
Springer, 2015, pp. 382–404.

[13] M. A. Bishop, Introduction to computer security. Addison-Wesley Boston, 2005,

vol. 50.
Intel® 64 and IA-32 Architectures Soware Developer’s Manual – Volume 3.
[Accessed: 14 June 2019]. [Online]. Available: hps://soware.intel.com/sites/
default/les/managed/a4/60/325384-sdm-vol-3abcd.pdf

[14]

[15] ARM CortexA9 Technical Reference Manual - Chapter 11 Performance Monitor-
ing Unit. [Accessed: 14 June 2019. [Online]. Available: hp://infocenter.arm.com/
help/index.jsp?topic=/com.arm.doc.ddi0433c/BEHGGDJC.html

[16] M. Alam, S. Bhaacharya, S. Dua, S. Sinha, D. Mukhopadhyay, and A. Chat-
topadhyay, “Rataa: Ransomware analysis using time and frequency informed
autoencoders,” in IEEE International Symposium on Hardware Oriented Security
and Trust (HOST).

IEEE, 2019.

[17] R. Moussaileb, B. Bouget, A. Palisse, H. Le Bouder, N. Cuppens, and J.-L. Lanet,
“Ransomware’s early mitigation mechanisms,” in Proceedings of the 13th Interna-
tional Conference on Availability, Reliability and Security. ACM, 2018, p. 2.
[18] S. Hochreiter and J. Schmidhuber, “Long short-term memory,” Neural computa-

tion, vol. 9, no. 8, pp. 1735–1780, 1997.

[19] F. A. Gers, N. N. Schraudolph, and J. Schmidhuber, “Learning precise timing with
lstm recurrent networks,” Journal of machine learning research, vol. 3, no. Aug,
pp. 115–143, 2002.

[20] A. Kharraz, W. Robertson, D. Balzaroi, L. Bilge, and E. Kirda, “Cuing the
gordian knot: A look under the hood of ransomware aacks,” in International
Conference on Detection of Intrusions and Malware, and Vulnerability Assessment.
Springer, 2015, pp. 3–24.

[21] M. Spisak, “Hardware-assisted rootkits: Abusing performance counters on the

[22]

arm and x86 architectures.” in WOOT, 2016.
likwid: Performance monitoring and benchmarking suite. [Accessed: 10 August
2018]. [Online]. Available: hps://github.com/RRZE-HPC/likwid

[23] Performance analysis tools based on Linux perf events (aka perf) and race.
[Accessed: 14 June 2019]. [Online]. Available: hps://github.com/brendangregg/
perf-tools

[24] A. Tang, S. Sethumadhavan, and S. J. Stolfo, “Unsupervised anomaly-based
malware detection using hardware features,” in International Workshop on Recent
Advances in Intrusion Detection.

Springer, 2014, pp. 109–129.

[25] X. Wang, C. Konstantinou, M. Maniatakos, and R. Karri, “Conrm: Detecting
rmware modications in embedded systems using hardware performance coun-
ters,” in Computer-Aided Design (ICCAD), 2015 IEEE/ACM International Conference
on.

IEEE, 2015, pp. 544–551.

[26] C. Malone, M. Zahran, and R. Karri, “Are hardware performance counters a cost
eective way for integrity checking of programs,” in Proceedings of the sixth ACM
workshop on Scalable trusted computing. ACM, 2011, pp. 71–76.
J. Demme, M. Maycock, J. Schmitz, A. Tang, A. Waksman, S. Sethumadhavan,
and S. Stolfo, “On the feasibility of online malware detection with performance
counters,” in ACM SIGARCH Computer Architecture News, vol. 41, no. 3. ACM,
2013, pp. 559–570.

[27]

[29]

[28] VeraCrypt.

[Accessed:
//www.veracrypt.fr/en/Home.html
I. H. Wien, E. Frank, M. A. Hall, and C. J. Pal, Data Mining: Practical machine
learning tools and techniques. Morgan Kaufmann, 2016.

[Online]. Available:

14 June 2019].

hps:

[30] VirusShare.

[Accessed:

14 June 2019].

[Online]. Available:

hps:

//virusshare.com/

[31] OpenSSL.

[Accessed:

14

June

2019].

[Online]. Available:

hps:

//www.openssl.org/

[32] Awesome C. [Accessed: 14 June 2019]. [Online]. Available: hps://github.com/

kozross/awesome-c

RanStop: A Hardware-assisted Runtime Crypto-Ransomware Detection Technique

eprint’2020, , US

[33] C Code Katas. [Accessed:

14 June 2019]. [Online]. Available:

hps:

//github.com/ankitpokhrel/c-code-katas

[34] Digital corpora/govdocs1. [Accessed: 14 June 2019]. [Online]. Available:

hps://digitalcorpora.org/corpora/les
[35] F. Chollet et al., “Keras,” hps://keras.io, 2015.
[36] Keras Documentation - Usage of Optimizer. [Accessed: 14 June 2019]. [Online].

Available: hps://keras.io/optimizers/

