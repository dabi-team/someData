Smart Predict-and-Optimize for Hard Combinatorial Optimization Problems

Jayanta Mandi,1 Emir Demirovi´c,2 Peter. J Stuckey,2 Tias Guns1
1 Data Analytics Laboratory, Vrije Universiteit Brussel {jayanta.mandi,tias.guns}@vub.be
2 University of Melbourne {emir.demirovic,pstuckey}@unimelb.edu.au

9
1
0
2

v
o
N
2
2

]

G
L
.
s
c
[

1
v
2
9
0
0
1
.
1
1
9
1
:
v
i
X
r
a

Abstract

Combinatorial optimization assumes that all parameters of
the optimization problem, e.g. the weights in the objective
function, are ﬁxed. Often, these weights are mere estimates
and increasingly machine learning techniques are used to for
their estimation. Recently, Smart Predict and Optimize (SPO)
has been proposed for problems with a linear objective func-
tion over the predictions, more speciﬁcally linear program-
ming problems. It takes the regret of the predictions on the
linear problem into account, by repeatedly solving it during
learning. We investigate the use of SPO to solve more realis-
tic discrete optimization problems. The main challenge is the
repeated solving of the optimization problem. To this end, we
investigate ways to relax the problem as well as warm-starting
the learning and the solving. Our results show that even for
discrete problems it often sufﬁces to train by solving the re-
laxation in the SPO loss. Furthermore, this approach outper-
forms the state-of-the-art approach of Wilder, Dilkina, and
Tambe. We experiment with weighted knapsack problems as
well as complex scheduling problems, and show for the ﬁrst
time that a predict-and-optimize approach can successfully be
used on large-scale combinatorial optimization problems.

Introduction
Combinatorial optimization aims to optimize an objective
function over a set of feasible solutions deﬁned on a discrete
space. Numerous real-life decision-making problems can be
formulated as combinatorial optimization problems (Korte
et al. 2012; Trevisan 2011). In the last decade, development
of time-efﬁcient algorithms for combinatorial optimization
problems paved the way for these algorithms to be widely
utilized in industry, including, but not limited to, in re-
source allocation (Angalakudati et al. 2014), efﬁcient energy
scheduling (Ngueveu, Artigues, and Lopez 2016), price op-
timization (Ferreira, Lee, and Simchi-Levi 2015), sales pro-
motion planning (Cohen et al. 2017), etc.

The last decade has, in parallel, witnessed a tremendous
growth in machine learning (ML) methods, which can pro-
duce very accurate predictions by leveraging historical and
contextual data. In real-world applications, not all parame-
ters of an optimization problem are known at the time of

Copyright c(cid:13) 2020, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

execution and predictive ML models can be used for estima-
tion of those parameters from historical data. For instance,
Cohen et al. ﬁrst predicted future demand of products using
an ML model and then use the predicted demand to com-
pute the optimal promotion pricing scheme over the prod-
ucts through non-linear integer programming.

When predictive ML is followed by optimization, it is of-
ten assumed that improvements in the quality of the predic-
tions (with respect to some suitable evaluation metric) will
result in better optimization outcomes. However, ML mod-
els make errors and the impact of prediction errors is not
uniform throughout the underlying solution space, for ex-
ample, overestimating the highest-valued prediction might
not change a maximization problem outcome, while under-
estimating it can. Hence, a better prediction model may not
ensure a better outcome in the optimization stage. In this re-
gard, Ifrim, OSullivan, and Simonis (2012) experienced that
a better predictive model does not always translate to opti-
mized energy-saving schedules.

The alternative is to take the effect of the errors on the
optimization outcome into account during learning. In the
context of linear programming problems, Elmachtoub and
Grigas proposed an approach, called “Smart Predict and Op-
timize” (SPO), for training ML models by minimizing a con-
vex surrogate loss function which considers the outcome of
the optimization stage. Speciﬁcally they consider optimiza-
tion problems where predictions occur as weights that are
linear in the objective.

In this work, we build on that approach and consider dis-
crete combinatorial optimization problems. Indeed, the SPO
loss is valid for any optimization problem with a linear ob-
jective over predictions, where the constraints implicitly de-
ﬁne a convex region. Furthermore, any black box optimiza-
tion method can be used as only its outcome is used to com-
pute the (sub)gradient of the loss.

The main challenge is the computational cost of the re-
peated solving of the optimization problem during training,
namely once for every evaluation of the loss function on an
instance. For NP-hard problems, this may quickly become
infeasible. In order to scale up to large problem instances,
we investigate the importance of ﬁnding the optimal dis-
crete solution for learning, showing that continuous relax-

 
 
 
 
 
 
ations are highly informative for learning. Furthermore, we
investigate how to speed up the learning by transfer learning
from easier-to-learn models as well as method for speed-
ing up the solving by warmstarting from earlier solutions.
Our approach outperforms the state-of-the-art Melding ap-
proach (Wilder, Dilkina, and Tambe 2019) in most cases,
and for the ﬁrst time we are able to show the applicability of
predict-and-optimize on large scale combinatorial instances,
namely from the ICON energy-cost aware scheduling chal-
lenge (Simonis et al. ).

Related Work
Predict-and-optimize problems arise in many applications.
Current practice is to use a two-stage approach where the
ML models are trained independent of the optimization
problem. As a consequence, the ML models do not account
for the optimization tasks (Wang et al. 2006; Mukhopad-
hyay et al. 2017). In recent years there is a growing interest
in decision-focused learning (Elmachtoub and Grigas 2017;
Demirovi´c et al. 2019; Wilder, Dilkina, and Tambe 2019),
that aims to couple ML and decision making.

In the context of portfolio optimization, Bengio (1997)
report a deep learning model fails to improve future proﬁt
when trained with respect to a standard ML loss func-
tion, but a proﬁt-driven loss function turns out to be effec-
tive. Kao, Roy, and Yan (2009) consider an unconstrained
quadratic optimisation problem, where the predicted values
appear linearly with the objective. They train a linear model
with respect to a combination of prediction error and opti-
mization loss. They do not mention how this can be applied
to optimization problems with constraints.

A number of works aim to exploit the fact that the KKT
conditions of a quadratic program (QP) deﬁne a system of
linear equations around the optimal points. For instance,
Donti, Amos, and Kolter (2017) propose a framework which
computes the gradient of the solution of the QP with respect
to the predictions by applying the implicit function theorem
to differentiate through the KKT conditions around the opti-
mal point. Wilder, Dilkina, and Tambe (2019) use the same
approach, and propose its use for linear programs by adding
a small quadratic term to convert it into a concave QP. They
also propose a specialisation of it for submodular functions.
Our work builds on the SPO approach of Elmachtoub and
Grigas (2017), where the authors provide a framework to
train an ML model, which learns with respect to the error
in the optimization problem. This is investigated for linear
optimization problems with a convex feasible region. We
will use the approach for discrete combinatorial problems
with a linear objective. They are computationally expensive
to solve, e.g. often N P-hard. The decision variables and
search space of these problems is discrete, meaning gradi-
ents can not be computed in a straightforward manner. How-
ever, the SPO approach remains applicable as we will see.
(2019)

investigate
the predic-
et
tion+optimisation problem for
the knapsack problem,
and prove that optimizing over predictions are as valid as
stochastic optimisation over learned distributions, in case
the predictions are used as weights in a linear objective.
They further investigate possible learning approaches, and

Demirovi´c

al.

indirect approaches,
classiﬁed them into three groups:
which do not use knowledge of the optimisation problem;
semi-direct approaches, which encode knowledge of the
optimisation problem, such as the importance of ranking
and direct approaches which encode or use the optimisation
problem in the learning in some way (Demirovi´c et al.
2019). Our approach is a direct approach and we examine
how to combine the best of such techniques in order to scale
to large and hard combinatorial problems.

Problem Formulation and Approach

Optimizing a parameterized problem
Traditional optimization algorithms work under the assump-
tion that all the parameters are known precisely. But in a
predict-and-optimize setup we assume some parameters of
the optimization problem are not known.

We formalize a combinatorial optimization problem as

follows :

v∗(θ) ≡ arg min

f (v, θ) s.t. C(v, θ)

(1)

v

where θ deﬁnes the set of parameters (coefﬁcients) of the
optimization problem, v are the decision variables, f (v, θ)
is an objective to be minimized, and C(v, θ) is a (set of)
constraints that determine(s) the feasible region; hence v∗()
is an oracle that returns the optimal solution.

Consider, the 0-1 knapsack, where a set of items, with
their values and wights, are provided. The objective is to se-
lect a subset of items respecting a capacity constraint on the
sum of weights so that the total value of the subset is max-
imized. The parameter set θ of the problem consists of the
value and weight of each item and the total capacity. The de-
cision variable set consists of 0-1 decision variable for each
item, f is a linear sum of the variables and the item values
and C describing the capacity constraint.

We decompose θ = θs ∪ θu where θs are the set of pa-
rameters that are observed (e.g. the weights and capacity of
a knapsack) and θu are the set of unobserved parameters (the
value of the knapsack items).

To predict the unobserved parameters θu, some attributes
correlated with them are observed. We are equipped with
a training dataset D : {(x1, θu1), ..., (xn, θun)} where xi’s
are vectors of attributes correlated to θui. An ML model m is
trained to generate a prediction ˆθu = m(x; ω). The model m
is characterized by a set of learning parameters ω. E.g. in lin-
ear regression the ω encompasses the slope and the intercept
of the regression line. Once the predicted ˆθu are obtained,
θ = θs ∪ ˆθu is used for the optimization problem.

To ease notation, we will write ˆθ = (θs, ˆθu), containing
both the observed parameters and predicted parameters. Re-
call from Equation (1) that v∗(ˆθ) is the optimal solution us-
ing parameters ˆθ. Then, the objective value of this solution
is f (v∗(ˆθ), θ). Whereas if the actual θ is known a priori,
one could obtain the actual optimal solution v∗(θ). The dif-
ference in using the predicted instead of the actual values is
hence measured by

regret(θ, ˆθ) ≡ f (v∗(ˆθ), θ) − f (v∗(θ), θ)

(2)

Ideally the aim of the training should be to generate predic-
tions which minimize this regret on unseen data.

Two Stage Learning

First we formalize a two-stage approach, which is widely
used in industry and where the prediction and the optimiza-
tion are performed in a decoupled manner. First the predic-
tive model is trained with the objective of minimizing the
expected loss for a suitable choice of loss function L(θu, ˆθu)
For regression, if we use squared-error as the loss func-
tion, model parameters ω are estimated by minimizing the
Mean Squared Error (MSE) on the training data:

Figure 1: MSE (left axis) versus Regret (right axis) while training
a knapsack instance; with no correlation and worsening regret.

LM SE =

1
n

n
(cid:88)

i=1

(θui − ˆθui)2
2

(3)

selection. We call this the MSE-r approach. It is more com-
putationally expensive than MSE given that computing re-
gret on the validation data for every epoch requires solving
the optimization problems each time.

Algorithm 1: Stochastic Batch gradient descent for the
two-stage learning for regression tasks (batchsize:N )
and learning rate α
repeat

Sample N training datapoints
for i in 1, ..., N do

predict ˆθui using current ω ∇Li ← (ˆθui − θui)
//gradient of LM SE

end

∇L =

until convergence;

(cid:80)N

i=1 ∇Li
N

ω ← ω − α ∗ ∇L ∗ ∂ ˆθu
∂ω

Training by gradient descent The process of estimating
ω to minimize the loss function is executed through stochas-
tic gradient descent algorithms1,where at each epoch, ω are
updated after calculating the gradient ∇L of the loss func-
tion with respect to the predictions as shown in Algorithm 1.
The advantage of the two-stage approach is that train-
ing by gradient descent is straightforward. In the prediction
stage the objective is to minimize the MSE-loss to gener-
ate accurate predictions without considering their impact on
the ﬁnal solution. Clearly this does not require solving the
optimization problem during training.

Model validation and early stopping with regret
It is
common practice to perform model validation on a sep-
arate validation set while training the model. Early stop-
ping (Bishop 2006) is the practice of choosing the epoch
with the smallest loss on the validation set as the ﬁnal out-
put of the training procedure. The objective is to avoid over-
ﬁtting on training data. The performance on the validation
set is also used to select hyperparameters of the ML mod-
els (Bergstra and Bengio 2012).

Considering the ﬁnal task, in our setup, is minimizing the
regret, we modify the two stage learning by measuring regret
on the validation set for early stopping and hyperparameter

1There are different variations of sgd, for a detailed discussion

refer (Ruder 2016)

Smart Predict then Optimize (SPO)
The major drawback of the two-stage approach is it does not
aim to minimize the regret, but minimizes the error between
θu and ˆθu directly. As Figure 1 shows, minimizing loss be-
tween θu and ˆθu does not necessarily result in minimization
of the regret. Early stopping with regret can avoid worsening
results, but can not improve the learning. The SPO frame-
work proposed by Elmachtoub and Grigas addresses this by
integrating prediction and optimization.

Note, to minimize regret(θ, ˆθ) directly we have to ﬁnd
the gradient of it with respect to ˆθ which requires differenti-
ating the argmin operator v∗(ˆθ) in Eq. 1. This differentiation
may not be feasible as v∗(ˆθ) can be discontinuous in ˆθ and
exponential in size. Consequently we can not train an ML
model to minimize the regret through gradient descent.

The SPO framework integrates the optimization problem
into the loop of gradient descent algorithms in a clever way.
In their work, Elmachtoub and Grigas consider an optimiza-
tion problem with a convex feasible region S and a linear
objective :

v∗(θ) ≡ arg min

θ(cid:62)v

v∈S

(4)

where the cost vector θ is not known beforehand. Following
Eq. (2), the regret for such a problem when using predicted
values ˆθ instead of actual θ is: θ(cid:62)(v∗(ˆθ) − v∗(θ)), which
as discussed is not differentiable. To make it differentiable,
they use a convex surrogate upper bound of the regret func-
tion, which they name the SPO+ loss function LSP O+(θ, ˆθ).
The gradient of LSP O+(θ, ˆθ) may not exist as it also in-
volves the argmin operator. However, they have shown that
v∗(θ) − v∗(2ˆθ − θ) is a subgradient of LSP O+(θ, ˆθ), that is
g(θ, ˆθ) ∈ ∇LSP O+(θ, ˆθ)
g(θ, ˆθ) = v∗(θ) − v∗(2ˆθ − θ),
(5)
The subgadient formulation is the key to bring the opti-
mization problem into the loop of gradient descent as shown
in algorithm 2. The difference between algorithm 1 and algo-
rithm 2 is in their (sub)gradients. In Algorithm 1, the MSE
gradient is the signed difference between the actual values

Algorithm 2: Stochastic Batch gradient descent for the
SPO approach for regression tasks (batchsize:N ) and
learning rate α
repeat

Sample N training datapoints
for i in 1, ..., N do

predict ˆθui using current ω
compute v∗(2ˆθ − θ)
∇Li ← v∗(θ) − v∗(2ˆθ − θ) //sub-gradient

end

(cid:80)N

i=1 ∇Li
∇L =
N
ω ← ω − α ∗ ∇L ∗ ∂ ˆθu
∂ω ;

until convergence;

and predicted ones; in Algorithm 2 the SPO subgradient is
the difference of an optimization solution obtained using the
actual parameter values and another solution obtained using
a convex combination of the predicted values and the true
values.

For the 0-1 knapsack problem, the solution of a knapsack
instance is a 0-1 vector of length equal to the size of the set,
where 1 represents the corresponding item is selected. In this
case, the subgradient is the element-wise difference between
the two solutions and if the solution using the transformed
predicted values is the same as the solution using actual val-
ues, all entries of the subgradient are zero. In essence, the
non-zero entries in the subgradient indicate places where the
two solutions contradict.

Note, to compute the subgradient for this SPO approach,
the optimization problem v∗(2ˆθ − θ) needs to be solved
for each training instance, while v∗(θ) can be precomputed
and cached. Moreover, one training instance typically con-
tains multiple predictions. For example, if we consider a 0-1
knapsack problem with 10 items, then one training instance
always contains 10 value predictions, one for each item.
Furthermore, the dataset may contain thousands of train-
ing instances of 10 values each. Hence, one iteration over
the training data (one epoch) requires solving hundreds of
knapsack problems. As an ML model is trained over sev-
eral epochs, clearly the training process is computationally
expensive.

Combinatorial problems and scaling up

We observe that the SPO approach and its corresponding
loss function places no restriction on the type of oracle v∗()
used. Given that our target task is to minimize the regret of
the combinatorial problem, an oracle that solves the combi-
natorial optimisation problem is the most natural choice. We
call this approach SPO-full.

Weaker oracles Repeatedly solving combinatorial prob-
lems is computationally expensive. Hence for large and hard
problems, it is necessary to look at ways to reduce the solv-
ing time.

As there is no restriction on the oracle used, we con-
sider using weaker oracles during training. NP-hard prob-
lems that have a polynomial (bounded) approximation algo-
rithm could use the approximation algorithm in the loss as a
proxy instead. For example, in case of knapsack, the greedy
algorithm (Dantzig 1957). For mixed integer programming
(MIP) formulations, a natural weaker oracle to use is the
continuous relaxation of the problem. While disregarding
the discrete part, relaxations can often identify what part of
the problem is trivial (variable assignments close to 0 or 1)
from what part is non-trivial. For example for knapsack, the
continuous relaxation leads to very similar solutions com-
pared to the greedy algorithm. Note that we always use the
same oracle for v∗(θ) and v∗(2ˆθ − θ) when computing the
loss. We call the approach of using the continuous relaxation
as oracle v∗() SPO-relax.

In case of weak MIP relaxations, one can also use a cut-
ting plane algorithm in the root node and use the resulting
tighter relaxation thereof (Ferber et al. 2019). Other weaker
oracles could also be used, for example setting a time-limit
on an any-time solver and using the best solution found, or
a node-limit on search algorithms. In case of mixed integer
programming, we can also set a gap tolerance, which means
the solver does not have to prove optimality. We call this
SPO-gap. For stability of the learning, it is recommended
that the solution returned by the oracle does not vary much
when called with (near) identical input.

Apart from changing what is being solved, we also in-
vestigate ways to warmstart the learning, and to warmstart
across solver calls:

Warmstarting the learning We consider warmstarting
the learning by transfer learning (Pratt and Jennings 1996),
that is, to train the model with an easy to compute loss func-
tion, and then continue training it with a more difﬁcult one.
In our case, we can pre-train the model using MSE as loss,
which means the predictions will already be more informed
when we start using an SPO loss afterwards.

More elaborate learning schemes are possible, such as
curriculum learning (Thrun and Pratt 2012; Pratt and Jen-
nings 1996) where we gradually move from easier to harder
to compute loss functions, e.g. by moving from SPO-relax
to SPO-gap for decreasing gaps to SPO-full. As we will see
later, this is not needed for the cases we studied.

Warmstarting the solving When computing the loss, we
must solve both v∗(θ) using the true values θ, and v∗(2ˆθ−θ).
Furthermore, we know that an optimal solution to v∗(θ) is
also a valid (but potentially suboptimal) solution to v∗(2ˆθ −
θ) as only the coefﬁcients of the objective differ. Further-
more, if this is an optimal solution to the latter than we
would achieve 0-regret, hence we can expect the solution
of v∗(θ) to be of decent quality for v∗(2ˆθ − θ) too.

We hence want to aide the solving of v∗(2ˆθ − θ) by
using the optimal solution of v∗(θ). One way to do this
for CP solvers is solution-guided search (Demirov´ıc, Chu,
and Stuckey 2018). For MIP/LP we can use warmstart-

ing (Yildirim and Wright 2002; Zeilinger, Jones, and Morari
2011), that is, to use the previous solution as starting point
for MIP. In case of linear programming (and hence the re-
laxation), we can reuse the basis of the solution.

An alternative is to use the true solution to compute a
bound on the objective function. Indeed, as the solution to
S = v∗(θ) is valid for v∗(2ˆθ − θ) and has an objective value
of f (S, (2ˆθ − θ)). Hence, we can use this as a bound on the
objective and potentially cut away a large part of the search
space.

While the true solutions v∗(θ) can be cached, we must
compute this solution once for each training instance (x, θ)i,
which may already take signiﬁcant time for large problems.
We observe that only the objective changes between calls to
the oracle v∗, and hence any previously computed solution
is also a candidate solution for the other calls. We can hence
use warmstarting for any solver call after the ﬁrst, and from
any previously computed solution so far.

Experimental Evaluation
We consider three types of combinatorial problems: un-
weighted and weighted knapsack and energy-cost aware
scheduling. Below we brieﬂy discuss the problem formula-
tions:

Unweighted/weighted knapsack problem The knapsack
problem can be formalized as argmaxX V (cid:62)X s.t. W (cid:62)X ≤
c. The values V will be predicted from data and weights W
and capacity c are given. In the unweighted knapsack, all
weights W are 1 and the problem is polynomial time solv-
able. Weighted knapsacks are NP-hard and it is known that
the computational difﬁculty increases with the correlation
between weights and values (Pisinger 2005). We generated
mildly correlated knapsacks as follows: for each of the 48
half-hour slots we assign a weight wi by sampling from the
set {3, 5, 7}, then we multiply each proﬁt value vi by its cor-
responding weight and include some randomness by adding
Gaussian noise ξ ∼ N(0, 25) to each vi before multiplying
by weight.

In the unweighted case, we consider 9 different capac-
ity values c, namely from 5 to 45 increasing by 5. For the
weighted knapsack experiment, we consider 7 different ca-
pacity values from 30 to 210 increasing by 30.

a

It

is

aware

scheduling

Energy-cost
resource-
constrained job scheduling problem where the goal
is
to minimize (predicted) energy cost, it is described in the
CSPLib as problem 059 (Simonis et al. ). In summary,
we are given a number of machines and have to schedule
a given number of tasks, where each task has a duration,
an earliest start and a latest end, resource requirement
and a power usage. Each machine has a resource capacity
constraint. We omit startup/shutdown costs. No task is
allowed to stretch over midnight between two days and
cannot be interrupted once started, nor migrate to another
machine. Time is discretized in t timeslots and a schedule
has to be made over all timeslots at once. For each timeslot,
a (predicted) energy cost is given and the objective is to

minimize the total energy cost of running the tasks on the
machines.

We consider two variants of the problem: easy instances
consisting of 30 minute timeslots (e.g. 48 timeslots per day),
and hard instances as used in the ICON energy challenge
consisting of 5 minute timeslots (288 timeslots per day). The
easy instances have 3 machines and respectively 10, 15 and
20 tasks. The hard instances each have 10 machines and 200
tasks.

Data Our data is drawn from the Irish Single Electricity
Market Operator (SEMO) (Ifrim, OSullivan, and Simonis
2012). This dataset consists of historical energy price data
at 30-minute intervals starting from Midnight 1st Novem-
ber, 2011 to 31st December, 2013. Each instance of the data
has calendar attributes; day-ahead estimates of weather char-
acteristics; SEMO day-ahead forecasted energy-load, wind-
energy production and prices; and actual wind-speed, tem-
perature, CO2 intensity and price. Of the actual attributes,
we keep only the actual price, and use it as a target for pre-
diction. For the hard scheduling instances, each 5-minute
timeslots have the same price as the 30-minute timeslot it
belongs to, following the ICON challenge.

Experimental setup For all our experiments, we use a lin-
ear model without any hidden layer as the underlying pre-
dictive model. Note, the SPO approach is a model-free ap-
proach and it is compatible wih any deep neural network; but
earlier work (Ifrim, OSullivan, and Simonis 2012) showed
accuracy in predictions is not effective for the downstream
optimization task. For the experiments, we divide our data
into three sets: training (70%), validation (10%) and test
(20%), and evaluate the performance by measuring regret
on the test set. Training, validation and test data covers 552,
60 and 177 days of energy data respectively.

Our model is trained by batch gradient descent, where
each batch corresponds to one day, that is, 48 consecutive
training instances namely one for each half hour of that day.
This batch together forms one set of parameters of one opti-
misation instance, e.g. knapsack values or schedule costs.
The learning rate and momentum for each model are se-
lected through a grid search based on the regret on the val-
idation dataset. The best combination of parameters is then
used in the experiments shown.

Solving the knapsack instances takes sub-second time per
optimisation instance, solving the easy scheduling problems
takes 0.1 to 2 seconds per optimisation instance and for the
hard scheduling problems solving just the relaxation already
costs 30 to 150 seconds per optimisation instance. For the
latter, this means that merely evaluating regret on the test-set
of 177 optimisation instances takes about 3 hours. With 552
training instances, one epoch of training requires 9 hours.

For all experiments except the hard instances, we repeat it

10 times and report on the mean and standard deviation.

We use the Gurobi optimization-solver for solving the
combinatorial problems, the nn module in Pytorch to imple-
ment the predictive models and the optim module in Pytorch
for training the models with corresponding loss functions.

(a) Unweighted
knapsack(cap:10)

(b) Weighted
Knapsack (cap:60)

(c) EnergySchedule
(1st instance)

Figure 2: Per epoch learning curves of MSE-r, SPO-full and
SPO-relax

(a) Unweighted
knapsack(cap:10)

(b) Weighted
Knapsack(cap:60)

(c) EnergySchedule
(1st instance)

Figure 3: Per second learning curves of MSE-r, SPO-full and
SPO-relax

Experiments were run on Intel(R) Xeon(R) CPU E3-1225
v5 @ 3.30GHz processors with 32GB memory 2.

RQ1: exact versus weaker oracles
The ﬁrst research question is what the loss in accuracy of
solving the full discrete problems (SPO-full) versus solving
only the relaxation (SPO-relax) during training is. Together
with this, we look at what the gain is in terms of reduction-
in-regret over time. We visualise both through the learning
curves as evaluated on the test set. For all methods, we com-
pute the exact regret on the test-set, e.g. by fully solving the
instances with the predictions.

Figure 2 shows the learning curves over epochs, where
one epoch is one iteration over all instances of the train-
ing data, for three problem instances. We also include the
regret of MSE-r as baseline. In all three case we see that
MSE-r is worse, and stagnates or slightly decreases in per-
formance over the epochs. This validates the use of MSE-r
where the best epoch is chosen retrospectively based on a
validation set. It also validates that the SPO-surrogate loss
function captures the essence of the intended loss, namely
regret.

We also see, surprisingly, that SPO-relax achieves very
similar performance to SPO-full on all problem instances in
our experiments. This means that even though SPO can rea-
son over exact discrete solutions, reasoning over these con-
tinuous relaxation solutions is sufﬁcient for the loss function
to guide the learning to where it matters.

The real advantage of SPO-relax over SPO-full is evident
from Figure 3. Here we present the test regret not against

2The code of our experiments is available at https://github.com/

JayMan91/aaai predit then optimize.git

Instance

Baseline MSE-warmstart

Warmstart
from earlier basis

1

2

3

6.5 (1.5) sec

7 (1.5) sec

8 (0.5) sec

6 (1.0) sec

1.5 (0.2) sec

1 (0.2) sec

10 (0.5) sec

12 (1.0) sec

2.5 (0.1) sec

Table 1: Comparison of per epoch average (sd) runtime of
warmstart strategies

the number of epochs but against the model run-time. MSE-
r here includes the time to compute the regret on the vali-
dation set as needed to choose the best epoch. These ﬁgures
show SPO-relax runs, and hence converges, much quicker
in time than SPO. This is thanks to the fact that solving the
continuous relaxation can be done in polynomial time while
the discrete problem is worst-case exponential. SPO-relax is
slower than MSE-r but the difference in quality clearly jus-
tiﬁes it.

In the subsequent experiments, we will use SPO-relax

only.

RQ2 beneﬁts of warmstarting
As baseline we use the standard SPO-relax approach. We
test warmstarting the learning by ﬁrst training the network
with MSE as loss function for 6 epochs, after which we con-
tinue learning with SPO-relax. We indicate this approach by
MSE-warmstart. We summarizes the effect of warmstarting
in Table 1, We observe that warmstarting from MSE results
in a slightly faster start in the initial seconds, but this has no
beneﬁt, nor penalty over the longer run. Warmstarting from
an earlier basis, after the MIP pre-solving, did result in run-
time improvements overall.

We also attempted warmstarting by adding objective cuts,
but this slowed down the solving of the relaxation, often
doubling it, because more iterations were needed.

RQ3: SPO versus QPTL
Next, we compare our approach against the state-of-the-art
QP approach (QPTL) of Wilder, Dilkina, and Tambe (2019)
which proposes to transform the discrete linear integer pro-
gram into a continuous QP by taking the continuous relax-
ation and a squared L2-norm of the decision variables ||x||2
2.
This makes the problem quadratic and twice differentiable
allowing them to use the differntiable QP solver (Donti,
Amos, and Kolter 2017).

Figure 4 shows the average regret on all unweighted and
weighted knapsack instances and easy scheduling instances.
We can see that for unweighted knapsack, SPO-relax al-
most always outperforms the other methods, while QPTL
performs worse than MSE-r. For weighted knapsacks, SPO-
relax is best for all but the lower capacities. For these lower
capacities, QPTL is better though its results worsen for
higher capacities.

The same narrative is reﬂected in Figure 5. In Figure 5c
(weighted knapsack, capacity:60) QPTL converges to a bet-
ter solution than SPO. In all other cases SPO-relax produces

Unweighted

(a)
knapsack

(b) Weighted Knap-
sack

(c) Energy Schedul-
ing

Figure 4: MSE-r, SPO-relax and QPTL, all instances

(a)

(b)

(c)

(d)

(e)

(f)

Figure 5: Learning Curves of SPO-relax vs QPTL
a: Unweighted(cap:10),
Weighted(cap:60),
Scheduling(I), f: Energy Scheduling(II)

d: Weighted(cap:120),

b: Unweighted(cap:20),

c:
e: Energy

better quality of solution and in most cases QPTL converges
slower than SPO-relax. The poor quality of QPTL at higher
capacities may stem from the squared norm which favors
sparse solutions, while at high capacities, most items will be
included and the best solutions are those that identify which
items not to include.

On two energy-scheduling instances SPO-relax performs
better whereas for the other instance, the regrets of SPO-
relax and QPTL are similar. From Figure 5f and 5e, we can
see, again, SPO-relax converges faster than QPTL.

RQ4: Suitability on large, hard optimisation
instances
While SPO-relax performs well across the combinatorial in-
stances used so far, these are still toy-level problems with
relatively few decision variables that can be solved in a few
seconds.

We will use the large-scale optimization instances of the
ICON challenge, for which no exact solutions are known.
Hence, for this experiment we will report the regret when
solving the relaxation of the problem for the test instances,
rather than solving the discrete problem during testing as in
the previous experiments.

We impose a timelimit of 6 hours on the total time budget
that SPO-relax can spend on calling the solver. This includes
the time to compute and cache the ground-truth solution of

MSE-r

Instance
1
2
3
4
5

2 epochs
90,769
128,067
129,761
135,398
122,310

4 epochs
88,952
124,450
128,400
132,366
120,949

6 epochs
86,059
124,280
122,956
132,167
122,116

8 epochs
86,464
123,738
119,000
126,755
123,443

2 hour
72,662
120,800
108,748
109,694
118,946

SPO-relax
4 hour
74,572
110,944
102,203
99,657
116,960

6 hour
79,990
114,800
112,970
97,351
118,460

Table 2: Relaxed regret on hard ICON challenge instances

a training instance, and the timing of solving for each back-
propagation of a training instance. The remaining time spent
on handling the data and backpropagation is negligible in re-
spect to the solving time.

The results are shown in Table 2, for 5 hard scheduling
instances. First, we show the test (relaxed) regret after 2, 4,
6 and 8 MSE-r epochs. The results show that the test regret
slightly decreases over the epochs; thereafter, we observed,
regret tends to increase.

With SPO-relax, in 6 hours, it was possible to train only
on 300 to 450 different instances, which is only 50 to 80%
of the training instances. Table 2 shows even for a limited
solving budget of 6 hour and without MSE-warmstarting, it
already outperforms the MSE learned models.

This shows that even on very large and hard instances that
are computationally expensive to solve, training with SPO-
relax on a limited time-budget is better than training in a
two-stage approach with a non optimisation-directed loss.

Conclusions and future work

Smart “Predict and Optimize” methods have shown to be
able to learn from, and improve task loss. Extending these
techniques to be applicable beyond toy problems, more
speciﬁcally hard combinatorial problems, is essential to the
applicability of this promising idea.

SPO is able to outperform QPTL and lends itself to a wide
applicability as it allows for the use of black-box oracles
in its loss computation. We investigated the use of weaker
oracles and showed that for the problems studied, learning
with SPO loss while solving the relaxation leads to equal
performance as solving the discrete combinatorial problem.
We have shown how this opens the way to solve larger and
more complex combinatorial problems, for which solving
the exact solution may not be possible, let alone to do so
repeatedly.

In case of problems with weaker relaxations, one could
consider adding cutting planes prior to solving (Ferber et al.
2019). Moreover, further improvements could be achieved
by exploiting the fact that all previously computed solutions
are valid candidates. So far we have only used this for warm-
starting the solver.

Our work hence encourages more research into the use
of weak oracles and relaxation methods, especially those
that can beneﬁt from repeated solving. One interesting di-
rection are local search methods and other iterative reﬁne-
ment methods, as they can improve the solutions during the
loss computation. With respect to exact methods, knowledge
compilation methods such as (relaxed) BDDs could offer
both a runtime improvement from faster repeat solving and
employing a relaxation.

Acknowledgments

We would like to thank the anonymous reviewers for the
valuable comments and suggestions. This research is sup-
ported by Data-driven logistics (FWO-S007318N).

References

[Angalakudati et al. 2014] Angalakudati, M.; Balwani, S.;
Calzada, J.; Chatterjee, B.; Perakis, G.; Raad, N.; and
Uichanco, J. 2014. Business analytics for ﬂexible resource
allocation under random emergencies. Management Science
60(6):1552–1573.
[Bengio 1997] Bengio, Y. 1997. Using a ﬁnancial training
International
criterion rather than a prediction criterion.
Journal of Neural Systems 8(04):433–443.
[Bergstra and Bengio 2012] Bergstra, J., and Bengio, Y.
2012. Random search for hyper-parameter optimization.
Journal of Machine Learning Research 13(Feb):281–305.
[Bishop 2006] Bishop, C. M. 2006. Pattern recognition and
machine learning. springer.
[Cohen et al. 2017] Cohen, M. C.; Leung, N.-H. Z.; Pan-
chamgam, K.; Perakis, G.; and Smith, A. 2017. The impact
of linear optimization on promotion planning. Operations
Research 65(2):446–468.
[Dantzig 1957] Dantzig, G. B. 1957. Discrete-variable ex-
tremum problems. Operations Research 5(2):266–288.
[Demirovi´c et al. 2019] Demirovi´c, E.; Stuckey, P. J.; Bailey,
J.; Chan, J.; Leckie, C.; Ramamohanarao, K.; and Guns, T.
2019. An investigation into prediction+optimisation for the
knapsack problem.
In Rousseau, L.-M., and Stergiou, K.,
eds., Integration of Constraint Programming, Artiﬁcial In-
telligence, and Operations Research, 241–257.
[Demirov´ıc, Chu, and Stuckey 2018] Demirov´ıc, E.; Chu,
G.; and Stuckey, P. J. 2018. Solution-based phase saving
In Hooker, J., ed., Pro-
and large neighbourhood search.
ceedings of the 24th International Conference on Principles
and Practice of Constraint Programming, volume 11008 of
LNCS, 99–108.
[Donti, Amos, and Kolter 2017] Donti, P.; Amos, B.; and
Kolter, J. Z. 2017. Task-based end-to-end model learning
in stochastic optimization. In Advances in Neural Informa-
tion Processing Systems, 5484–5494.
[Elmachtoub and Grigas 2017] Elmachtoub, A. N., and Gri-
gas, P. 2017. Smart“ predict, then optimize”. arXiv preprint
arXiv:1710.08005.
[Ferber et al. 2019] Ferber, A.; Wilder, B.; Dilkina, B.; and
Tambe, M. 2019. Mipaal: Mixed integer program as a layer.
In Proceedings IJCAI 2019.
[Ferreira, Lee, and Simchi-Levi 2015] Ferreira, K. J.; Lee,
B. H. A.; and Simchi-Levi, D. 2015. Analytics for an online
retailer: Demand forecasting and price optimization. Manu-
facturing & Service Operations Management 18(1):69–88.
[Ifrim, OSullivan, and Simonis 2012] Ifrim, G.; OSullivan,
B.; and Simonis, H. 2012. Properties of energy-price fore-
casts for scheduling. In International Conference on Prin-
ciples and Practice of Constraint Programming, 957–972.
Springer.
[Kao, Roy, and Yan 2009] Kao, Y.-h.; Roy, B. V.; and Yan,
X. 2009. Directed regression. In Advances in Neural Infor-
mation Processing Systems, 889–897.

2016.

An overview of gra-
arXiv preprint

[Korte et al. 2012] Korte, B.; Vygen, J.; Korte, B.; and Vy-
2012. Combinatorial optimization, volume 2.
gen, J.
Springer.
[Mukhopadhyay et al. 2017] Mukhopadhyay, A.; Vorobey-
chik, Y.; Dubey, A.; and Biswas, G. 2017. Prioritized al-
location of emergency responders based on a continuous-
time incident prediction model. In Proceedings of the 16th
Conference on Autonomous Agents and MultiAgent Systems,
168–177. International Foundation for Autonomous Agents
and Multiagent Systems.
[Ngueveu, Artigues, and Lopez 2016] Ngueveu, S. U.; Ar-
tigues, C.; and Lopez, P. 2016. Scheduling under a non-
reversible energy source: An application of piecewise linear
bounding of non-linear demand/cost functions. Discrete Ap-
plied Mathematics 208:98–113.
2005. Where are the hard
[Pisinger 2005] Pisinger, D.
knapsack problems? Computers & Operations Research
32(9):2271–2284.
[Pratt and Jennings 1996] Pratt, L., and Jennings, B. 1996.
A survey of connectionist network reuse through transfer. In
Learning to learn. Springer. 19–43.
[Ruder 2016] Ruder, S.
dient descent optimization algorithms.
arXiv:1609.04747.
[Simonis et al. ] Simonis, H.; OSullivan, B.; Mehta, D.; Hur-
ley, B.; and Cauwer, M. D. CSPLib problem 059: Energy-
cost aware scheduling.
http://www.csplib.org/Problems/
prob059.
[Thrun and Pratt 2012] Thrun, S., and Pratt, L. 2012. Learn-
ing to learn. Springer Science & Business Media.
[Trevisan 2011] Trevisan, L. 2011. Combinatorial optimiza-
tion: exact and approximate algorithms. Standford Univer-
sity.
[Wang et al. 2006] Wang, H.; Xie, H.; Qiu, L.; Yang, Y. R.;
Zhang, Y.; and Greenberg, A. 2006. Cope: trafﬁc engineer-
ing in dynamic networks. In Sigcomm, volume 6, 194.
[Wilder, Dilkina, and Tambe 2019] Wilder, B.; Dilkina, B.;
and Tambe, M. 2019. Melding the data-decisions pipeline:
Decision-focused learning for combinatorial optimization.
In Proceedings of the AAAI Conference on Artiﬁcial Intel-
ligence, volume 33, 1658–1665.
[Yildirim and Wright 2002] Yildirim, E. A., and Wright, S. J.
2002. Warm-start strategies in interior-point methods
for linear programming. SIAM Journal on Optimization
12(3):782–810.
[Zeilinger, Jones, and Morari 2011] Zeilinger, M. N.; Jones,
C. N.; and Morari, M. 2011. Real-time suboptimal model
predictive control using a combination of explicit mpc and
online optimization. IEEE Transactions on Automatic Con-
trol 56(7):1524–1534.

