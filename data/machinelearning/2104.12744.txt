DABT: A Dependency-aware Bug Triaging Method

Hadi Jahanshahia, Kritika Chhabrab, Mucahit Cevika, Ay¬∏se Ba¬∏sara

aData Science Lab at Ryerson University, Toronto, Canada
bData Science and Analytics, Ryerson University, Toronto, Canada

1
2
0
2

r
p
A
6
2

]
E
S
.
s
c
[

1
v
4
4
7
2
1
.
4
0
1
2
:
v
i
X
r
a

Abstract

In software engineering practice, Ô¨Åxing a bug promptly reduces the associated costs. On

the other hand, the manual bug Ô¨Åxing process can be time-consuming, cumbersome, and

error-prone.

In this work, we introduce a bug triaging method, called Dependency-aware

Bug Triaging (DABT), which leverages natural language processing and integer programming

to assign bugs to appropriate developers. Unlike previous works that mainly focus on one

aspect of the bug reports, DABT considers the textual information, cost associated with

each bug, and dependency among them. Therefore, this comprehensive formulation covers

the most important aspect of the previous works while considering the blocking eÔ¨Äect of the

bugs. We report the performance of the algorithm on three open-source software systems, i.e.,

EclipseJDT, LibreOffice, and Mozilla. Our result shows that DABT is able to reduce

the number of overdue bugs up to 12%. It also decreases the average Ô¨Åxing time of the bugs

by half. Moreover, it reduces the complexity of the bug dependency graph by prioritizing

blocking bugs.

Keywords: bug triage, optimization, bug dependency graph, repository mining, issue

tracking system, software quality

1. Introduction

In software engineering practice, Ô¨Åxing a bug promptly reduces the associated costs [11].

The manual bug Ô¨Åxing process can be time-consuming, cumbersome, and error-prone. There-

fore, many researchers investigate the possibility of automating each component of this pro-

cess. When a bug is reported to an issue tracking system (ITS), triagers start exploring its

validity and, accordingly, decide on how to proceed. If a bug report does not include enough

Email address: hadi.jahanshahi@ryerson.ca (Hadi Jahanshahi)

Preprint submitted to EASE‚Äô21

April 27, 2021

 
 
 
 
 
 
information for reproducibility, or if it is not relevant, it will be Ô¨Çagged as an invalid bug.

However, for valid bugs, triagers may Ô¨Ånd a proper developer to assign the existing bug. In

many open software systems, developers themselves may claim a bug‚Äôs possession and start

working on it. These decisions are mainly made by checking the bug‚Äôs information, e.g., its

title, component, description and severity.

Previous studies mainly concentrate on the importance of textual information in the bug

triaging process [15, 3, 14], . Considering the assignment task as a classical classiÔ¨Åcation

problem, some researchers explored the eÔ¨Äect of considering diÔ¨Äerent bug report features ‚Äì

e.g., title, description, and tag ‚Äì on assigning a proper developer. However, such approaches

fail to address the issue of longer Ô¨Åxing times of some bugs that are blindly assigned. Other

works also considered the combination of bug-Ô¨Åxing time (cost) and selecting the proper

developer (accuracy) [16, 10]. They use a regulatory term/parameter and suggest that their

approach reduces the Ô¨Åxing time without compromising the accuracy. However, the algorithms

still suÔ¨Äer from task concentration, i.e., assigning an unmanageable number of bugs to the

highly expert developers. A recent study by Kashiwa and Ohira [10] proposes setting an

upper limit on the number of tasks that each developer can address given a predeÔ¨Åned period

of time. Their method alleviated the problem of imbalanced bug distribution and reduced the

number of overdue bugs. However, in their objective function, they do not consider the bug

Ô¨Åxing time. Also, their model, similar to previous works, does not consider the signiÔ¨Åcant

eÔ¨Äect of blocking bugs in the prioritization task [1]. We propose a Dependency-aware Bug

Triaging method (DABT) that considers both the bug dependency and the Ô¨Åxing time during

the bug triage process. Accordingly, DABT employs machine learning algorithms and integer

programming to determine the suitable developers given their available time slots and bug

Ô¨Åxing times.

We organized the rest of the paper as follows. Section 2 brieÔ¨Çy discusses the background of

relevant methods used on our proposed bug triage algorithm, which is followed by a motivating

example in Section 3. Section 4 describes the DABT methodology and bug report dataset

used in our work. Section 5 investigates the research questions while taking into account the

importance of the bug dependency. Finally, Section 6 describes the limitations and threats to

validity, and Section 8 concludes the paper.

2

2. Background

In this section, we brieÔ¨Çy discuss the models employed in our proposed approach. Specif-

ically, we adopt Latent Dirichlet allocation (LDA) for topic modeling over bug descriptions

and Integer Programming (IP) for bug triaging. Note that, for the developer assignment task,

we use Support Vector Machines (SVM), whose details were skipped as it is a widely used

model in the domain.

2.1. LDA

LDA Blei et al. [5] is a probability-based topic modeling method. It is an unsupervised

learning approach that can identify the topics in given documents or corpus based on their

word clusters and frequencies. LDA assumes that the document is a mixture of topics, and

each word is attributed to one of the topics. In the process of bug triaging, LDA is typically

used to identify the bug type given a bug report, where the latter refers to documents, and the

former refers to a topic. That is, we extract bug description and summary from a bug report

and create a bag of words (BOW) after removing the stop words. Then, given the BOW of

each document, LDA arbitrarily assigns each word of the report to one of the topics (or bug

category). Next, it iteratively reassigns each word, assuming that other words are accurately

allocated. Accordingly, it computes the two conditional probabilities, the proportion of words

in document d that are assigned to topic t‚Äìi.e., p(topict|documentd)‚Äì and proportion of as-

signments to topic t over all documents that come from this word as p(wordw|topict). The

product of these conditional probabilities gives a probability distribution based on which a

new topic is assigned.

2.2. IP modeling

Integer programming is a mathematical modeling framework for optimization problems

where certain decision variables need to be integer-valued. It has a wide range of applications

in various domains including healthcare, energy and manufacturing [6]. Thanks to major

advances in integer programming solution methodologies and their integration into commercial

and noncommercial solvers, they have become increasingly popular over time. It is particularly

suited for scheduling problems which typically require various integer and binary decisions and

a long list of constraints to be satisÔ¨Åed. For instance, Sung and Lee [17] formulate an IP model

3

for the problem of resource-constrained triage in a mass casualty incident, where the priority

of the patients is identiÔ¨Åed for deploying limited emergency medical service resources so that

the maximum number of patients beneÔ¨Åt from the response eÔ¨Äorts.

IP modeling can be similarly employed for the bug triaging problem, which involves iden-

tifying the priority of the bugs and the most suitable developers to assign those. That is,

through an appropriate mathematical model, various problem constraints (e.g., blocking bugs

and deadlines) can be handled while optimizing over a particular objective, such as maximiz-

ing the match between the bug descriptions and the developers. This way, the bug triaging

can be automated to a certain extent while the overall eÔ¨Éciency of the process is enhanced.

2.3. Overview of the existing methods

In a typical bug tracking system, after a bug is validated, the Ô¨Årst step is to assign it to an

appropriate developer. Accordingly, the bug assignment is usually considered a critical task

which prompted many researchers to work towards its automation. The proposed methods

for this problem can be categorized as content-based recommendation (CBR), cost-aware

bug triaging (CosTriage), and release-aware bug triaging (RABT). We compare our proposed

approach with the representative methods from these categories.

2.3.1. Content-based recommendation

CBR approach aims to assign the most appropriate developer to the incoming bug through

analyzing its content. Anvik et al. [3] used machine learning techniques to build a semi-

automated bug triager. They trained a multi-class classiÔ¨Åer on the bug history by using SVM,

Naive Bayes, and C4.5 trees, where bug title and description were converted into a feature

vector as the input data, and the assigned developers were taken as the labels. The resulting

classiÔ¨Åer then analyzes the textual contents of a given report and estimates each developer‚Äôs

score for the new bug by extracting its feature vector and applying the classiÔ¨Åer. Therefore,

it can recommend suitable developers for any newly-reported bugs. As they reported SVM

to show the best performance, we use it as the classiÔ¨Åer in our study. Nonetheless, some

CBR studies followed the same concepts by training deep learning algorithms [14, 15, 20]. As

these studies revolve around the same idea while reporting modest accuracy improvements,

we consider the most commonly used approach in our analysis.

4

2.3.2. Cost-aware recommendation

CosTriage considers both the accuracy and the cost of an assignment. Park et al. [16]

proposed a bug-triage method combining an existing CBR with a collaborative Ô¨Åltering rec-

ommender (CF). They model the developer proÔ¨Åle that denotes their estimated cost for Ô¨Åxing

a particular bug type. To create these developer proÔ¨Åles, they quantiÔ¨Åed their proÔ¨Åle values

as the average bug Ô¨Åxing time per bug type, where bug types are determined by applying the

LDA to bug summary and description. Next, they estimated the suitability of each developer

using CBR. They trained SVM on the textual information of the bugs and tested it for new

bugs in the system. Finally, by combining the cost and the possibilities predicted by CBR, a

bug is assigned to a developer with the highest score.

2.3.3. Release-aware recommendation

Kashiwa and Ohira [10] proposed the RABT method that primarily focuses on increasing

the number of bugs resolved by the following release. RABT considers the time available

before the next release and simultaneously keeps track of the bug Ô¨Åxing load on a developer.

They formulated bug triage as a multiple knapsack problem to optimize the assignment task.

In the standard knapsack problem, for a given set of items, each with a weight and a value,

the objective is to determine the number of each item to include in a collection (i.e., knapsack)

so that the total weight is less than or equal to a given limit (i.e., knapsack capacity), and the

total value is as large as possible. Similarly, the problem of assigning bugs to the developers

can be considered as a variant of the knapsack problem. That is, RABT pairs the best

possible combination of bugs and developers to maximize the bug-Ô¨Åxing eÔ¨Éciency given a

time limit. They used SVM and LDA to compute the preferences and costs for each bug

and developer, respectively. LDA, similar to CosTriage, categorizes the bug and calculates

the average time taken for each developer to Ô¨Åx bugs in each category. For a new bug, SVM

computes developers‚Äô preferences, whereas LDA calculates their expected Ô¨Åxing time. Then,

RABT determines the available time slot T d

t for developer d based on their bugs at hand and

the project horizon L (predetermined for each developer). Ultimately, bugs are assigned to

the most suitable developers such that their preferences are maximized, while their Ô¨Åxing cost

does not exceed their available time slots.

5

2.3.4. Research gaps

The existing methods discussed above have certain limitations. While CBR [3] is a highly

accurate approach, it is prone to over-specialization, recommending only bugs similar to what

a developer has solved before. Thus, it concentrates the task on some experienced developers

and slowing down the bug Ô¨Åxing process.

In addition, it only considers the accuracy as

the performance metric, ignoring all other parameters such as bug-Ô¨Åxing time, developer‚Äôs

interest, and expertise. The Costriage [16] method addresses the drawbacks of CBR and tries

to optimize both the accuracy and bug Ô¨Åxing cost. It estimates the bug Ô¨Åxing time using

the LDA and overcomes its sparseness through a hybrid approach and collaborative Ô¨Åltering

recommender. It improves the bug Ô¨Åxing time without substantial degradation of accuracy.

However, both methods disregard the number of bugs a developer can Ô¨Åx in a given time

frame. They may assign more bugs to experienced developers than they can address in the

available time. Moreover, they do not consider the number of bugs that a developer can Ô¨Åx

before the next release.

Kashiwa and Ohira [10] focus on increasing the number of Ô¨Åxed bugs before the next

release by setting an upper limit on the available time for each developer. Accordingly,

RABT mitigates the task concentration, assigns a more achievable number of bugs that a

developer can Ô¨Åx in a given time, and reduces the bug Ô¨Åxing time. Also, the order of assigned

bugs impacts the number of bugs Ô¨Åxed by the release. If the model initially triages a time-

consuming bug, it can decrease the number of bugs Ô¨Åxed by the next release. RABT also

prioritizes the developers with fewer tasks as they are available to handle new bugs. However,

it reduces the accuracy of bug assignments. Besides, setting the proper upper limit can be

challenging. If the model wants to focus on the number of bugs Ô¨Åxed before the next release, it

should determine a dynamic threshold on developers‚Äô available times. Practically, by setting

a constant value, the model does not become linked to the release dates.

Another signiÔ¨Åcant consideration ignored by all these models is the bug dependency and the

impact of the blocking bugs. That is, none of these models take into account bug dependency

information during the triage process, which potentially leads to many infeasible tasks imposed

on developers.

6

3. Motivating example

A bug report may visit diÔ¨Äerent stages in its life-cycle. Figure 1 shows the life-cycle of bug

reports in Bugzilla-based projects. When a bug is introduced to a bug tracking system, it is

UNCONFIRMED until a developer veriÔ¨Åes its validity. As soon as it is veriÔ¨Åed, the status

changes to NEW, and after the triaging phase, it is ASSIGNED to a proper developer by a

triager, or a developer claims its possession. Then, the developer starts Ô¨Åxing the bug, and

after it is RESOLVED, they determine its resolution. After setting the solution and ensuring

the proposed solution is suitable, the bug will be VERIFIED and then CLOSED unless the

Ô¨Åx is not satisfactory or the same bug happens in future releases.

In that case, it will be

REOPENed.

Figure 1: The life-cycle of a bug report in Bugzilla [21]

A reported bug possesses diÔ¨Äerent attributes, some of which are Ô¨Ålled at reporting date

while others may be determined later in the Ô¨Åxing phase. Therefore, some features, e.g., bug

dependency, severity, and priority, may change during the bug life-cycle, whereas others, e.g.,

reporter‚Äôs name, title, and description, are constant. Most bug triage studies disregard these

changes and only highlighted static attributes ‚Äì i.e., title and description. As a bug evolves,

other bugs may block or be blocked by the introduced bug. Accordingly, bug prioritization

and triage process should be adjusted to incorporate newly found dependencies. In a typical

7

bug triage task, bugs may be deemed to be independent; however, when a triager considers

inherent bug dependencies, they cannot solve blocked bugs unless the blocking bug is Ô¨Åxed.

Importantly, it is not sensible to spend time Ô¨Åxing bugs that are blocked by others. Hence,

the bug triage process does not take place in a vacuum.

The bug triage can be applied simultaneously with bug prioritization to give a more com-

prehensive picture of the process. Accordingly, we may postpone triaging bugs that are

infeasible to be Ô¨Åxed at this time step. In this study, we add a new dimension to the bug

triage process by considering the bug dependencies.

4. Methods

In this work, we consider three open software systems, namely, EclipseJDT, Mozilla

Firefox, and LibreOffice. We examine bug evolution in software repositories and its

eÔ¨Äect on triaging process. To this end, we extract reported bugs‚Äô information from their Issue

Tracking System, covering a decade from January 2010 to December 2019. In our triaging

process, we consider both textual information of the reported bugs and their dependencies.

We construct a bug dependency graph (BDG), where the reported bugs are its nodes, and

the blocking information, i.e., ‚Äúdepends on‚Äù and ‚Äúblocks‚Äú forms its arcs. A BDG is a directed

acyclic graph (DAG) in which bugs cannot block other bugs while they are simultaneously

blocked by the same bugs in a loop. Bug dependencies are usually identiÔ¨Åed during the Ô¨Åxing

process; hence, we assume the BDG is constantly evolving by the changes in its nodes ‚Äì i.e.,

Ô¨Åxing a bug or introducing a new bug ‚Äì and its arcs ‚Äì i.e., Ô¨Ånding a new dependency or

removing an existing dependency.

We propose Dependency Aware Bug Triaging that assigns the bug to the most appropriate

developer while considering the workload of available developers and the dependency between

the bugs. In particular, we explore the following research questions.

(RQ0): How can DABT prevent task concentration on developers?

(RQ1): How can DABT reduce the Ô¨Åxing time and the overdue bugs at the same

time?

(RQ2): How can DABT help developers to postpone the blocked bugs?

8

4.1. Dependency-aware bug triaging

As we discussed in Section 2.3, the textual information and the Ô¨Åxing time of the bugs

are of importance in bug triaging automation. Studies focusing on CosTriage methods claim

that merely looking for the textual-information may increase the accuracy; however, it leads

to longer Ô¨Åxing times. Therefore, they deÔ¨Åne a control parameter, Œ±, to make a trade-oÔ¨Ä

between accuracy and the Ô¨Åxing cost. However, both CBR and CosTriage approaches ignore

the impact of the imbalanced distribution of the Ô¨Åxing tasks among developers. The release-

aware bug triaging method enriches the triaging process with the predeÔ¨Åned constraint on

developers‚Äô schedules to minimize overdue bugs. On the other hand, none of the previous

methods consider the importance of the BDG while assigning a bug to a developer. If a bug

that is not Ô¨Åxable due to its dependency is triaged, we might waste the valuable time of the

developers.

Our proposed algorithm, DABT, incorporates the main ideas from the previously proposed

approaches and enhances those by explicitly modeling the bug dependency. Its assumptions

can be summarized as follows.

‚Ä¢ We have a Ô¨Åxed number of developers, d ‚àà {1, 2, . . . , D} working on resolving bugs by

taking into account the BDG. We obtain the list of developers using predeÔ¨Åned conditions

on active developers. SpeciÔ¨Åcally, we take D as 28, 86, and 124 for EclipseJDT,

LibreOffice and Mozilla, respectively.

‚Ä¢ In this study, we do not consider the severity and priority of the bugs since previous

works showed that they are unreliable and subjective [9, 1].

‚Ä¢ Bug i has Ô¨Åxing time of cd

i if it is solved by developer d, as demonstrated in Figure 2.

Also, ci indicates the set of cost values of bug i for all active developers. For our analysis

to be consistent and comparable with those of previous studies [10, 16], we estimate the

Ô¨Åxing time in the same manner. We apply LDA topic modeling, use Arun‚Äôs method to

obtain the optimal number of categories, Ô¨Ånd the average Ô¨Åxing time of each developer

given the category, and Ô¨Ånally, estimate the missing values using a collaborative Ô¨Åltering

recommender.

9

b1

[sd

1, cd
1]

b2

[sd

2, cd
2]

b7

[sd

7, cd
7]

b3

[sd

3, cd
3]

b4

[sd

4, cd
4]

b8

[sd

8, cd
8]

b5

[sd

5, cd
5]

b6

[sd

6, cd
6]

b9

[sd

9, cd
9]

Figure 2: A typical BDG

Figure 2 also demonstrates the dependencies among the bugs. For instance, b1 is the

blocking bug for b3 and b4. We cannot Ô¨Åx those two bugs unless their parent nodes

(i.e., blocking bugs) are resolved. Solo bugs are very common in such graphs (e.g., see

b7), which neither block nor are blocked by other bugs. When the number of arcs (i.e.,

dependencies) in the BDG increases, the impact of considering bug dependency in the

bug triage process increases as well.

‚Ä¢ Bug i has a suitability sd

i when assigned to developer d. Also, si denotes the set of

suitability values of bug i for all developers. The notion of suitability implies that,

in the triage process, we should assign the bugs to the most compatible developer.

To calculate the suitability, we train a model on textual information (i.e., title and

description) obtained from the history of resolved bugs. A TF-IDF converts the merged

textual data to numeric values and makes those ready for the classiÔ¨Åer. We adopt an

SVM classiÔ¨Åer that incorporates the output of TF-IDF as the independent features and

the developers‚Äô names as the class labels. We Ô¨Åt the model at the end of the training

phase. Then, it can predict the suitability of the developers given the textual information

of a new bug. We adopt SVM implementation of scikit-learn in Python with a linear

kernel and the regularization parameter, C, set to 1000. These settings are compatible

with previous works. We use default values for other parameters. Figure 3 shows the

process of sd

i estimation.

‚Ä¢ Similar to Kashiwa and Ohira [10], we solve the IP model or other baseline methods at

the end of each testing day. Accordingly, developers are assigned bugs once a day.

10

Figure 3: Suitability estimation [10]

‚Ä¢ A single bug cannot be assigned to more than one developer at the same time.

‚Ä¢ Bug dependency is updated at the moment of Ô¨Ånding a dependency or removing one.

Therefore, its updates are instant and separate from the model and are done by the

simulator.

We next provide our IP model that determines the assignment of the bugs to the developers.

Let xd

i be a binary variable that takes value 1 if bug i is solved by developer d, and 0 otherwise.

In addition, let T d

t denote the time limit of developer d at time t. SpeciÔ¨Åcally, at time step

t, developers‚Äô time limit is updated according to their schedule and previously assigned bugs.

We deÔ¨Åne an identical upper limit L for all developers on their T d

t values. This upper limit

is equivalent to the maximum planning horizon for a project and can change according to the

project size. We set L to the third quartile value of the bug Ô¨Åxing times according to the

previous study [10]. The value of L for EclipseJDT, LibreOffice and Mozilla is 26,

10.5 and 18 days, respectively. Also, we use P (i) to denote the list of parents of bug i. The

11

IP model for bug assignment can then be formulated as follows.

maximize

(cid:88)

(cid:88)

(cid:16)(cid:0)Œ± √ó

subject to

d

i

i ‚â§ xd
xd
p

(cid:88)

i xd
cd

i ‚â§ T d
t

i
(cid:88)

d

xd
i ‚â§ 1

sd
i
max(si)

(cid:1) + (cid:0)(1 ‚àí Œ±) √ó

1/cd
i
1/min(ci)

(cid:1)(cid:17)

xd
i

‚àÄd, ‚àÄi (cid:54)= root, p ‚àà P (i),

‚àÄd,

‚àÄi,

xd
i ‚àà {0, 1} ‚àÄi

(1a)

(1b)

(1c)

(1d)

(1e)

The objective function of the model, (1a), maximizes the suitability of the solved bugs while

reducing the cost (i.e., solving time). The trade-oÔ¨Ä between suitability and estimated Ô¨Åxing

time is determined by Œ±. DiÔ¨Äerent from Kashiwa and Ohira [10]‚Äôs model, we incorporate

the Ô¨Åxing time in the objective function since ignoring the solving time might cause over-

specialization.

It also helps to reduce bug Ô¨Åxing time. Constraints (1b) ensure that the

precedence constraints are imposed, that is, blocking bugs xd

p are solved before the blocked

bug xd

i . Constraints (1c) enforce total time limit requirements. Lastly, constraints (1d)

guarantee that a single bug cannot be assigned to more than one developer simultaneously.

The proposed solution approach incorporates all the previously suggested criteria while

enhancing those by accounting for bug dependency considerations.

In addition, it uses IP

formulation for bug triaging that had been only considered by Kashiwa and Ohira [10]. Note

that their formulations were diÔ¨Äerent than ours in that they disregarded the eÔ¨Äect of the bug

Ô¨Åxing time in their objective function and did not include the dependency constraint.

4.2. Bug triaging mechanism

We design a mechanism to recreate all the past events. Unlike the previous studies that

worked on the static datasets (typically stored in CSV or JSON Ô¨Åles), we reconstruct the

history of events and apply each algorithm in real-time. The online exploration enables us

to examine the outcome of bug assignments given other elements in the system. Therefore,

we build a pipeline of the past events and replace the assignment task with our proposed

algorithm. The Ô¨Çow and time of the bug reports, bug reopening, and bug dependency discovery

remain the same. We adopt the suggested pipeline by [9] to recreate past events.

12

We Ô¨Årst extract bug Ô¨Åxing information from Bugzilla. Then, we revisit past events in the

system during the training time and keep track of the information related to active developers

and feasible bugs. When the training phase is completed, SVM and LDA learn the suitability

and cost list accordingly. Afterwards, we continue recording the incoming bugs and their

possible dependencies during the testing phase. Once in a day, we query the currently feasible

bugs‚Äô information in the system and apply our model to those. The outcome of the model

is a list of developers and assigned bugs. A few bugs may remain unassigned based on the

constraint we have. We call back those bugs in the upcoming days until they meet the criteria.

The steps of the full procedure is provided below.

(Step 0): Setting hyper-parameters: We use the third quartile as the value for upper limit

L. All T d

t are initialized by L and cannot exceed this limit during the process.

Furthermore, SVM and LDA hyperparameters are deÔ¨Åned based on the previous

studies.

(Step 1): Constructing SVM and LDA: To estimate the suitability sd

i and the Ô¨Åxing time

cd
i for developer d and bug i, we train SVM and LDA at the end of the training

phase.

(Step 2): Predicting suitability and costs: At the end of each day, we predict the suitability

and cost of each bug for all feasible, unassigned bugs.

(Step 3): Applying multiple knapsack problem: By solving the IP model, we determine

the bugs and their associated developers. Based on the constraints, the model post-

pones certain bugs while prioritizing others.

(Step 4): Updating T d

t : At the end of each day, we increment T d

t by 1 for developer d while

ensuring it does not exceed L. At the same time, we decrease T d

t of developer d by

sum of their estimated cd

i values for all assigned bugs.

(Step 5): Continuing to the next day (to step 2): Once the assignment at day t Ô¨Ånishes,

we move to the next day and repeat the process from step 2. These steps will continue

until the end of the testing phase.

13

We assume that our method and baselines are implemented once a day. However, the

process is generalizable, and the granularity of the updating time can be modiÔ¨Åed as needed.

4.3. Dataset

We consider three large open-source software (OSS) projects in our analysis. They are

well-established projects with a suÔ¨Écient number of bug reports. These projects were also

adopted in the previous studies [4, 14, 15, 10], making them suitable for comparison. We

collect the raw data from the repository using the Bugzilla REST API 1. It includes general

attributes of the bugs and their metadata change history. Table 1 shows the information of

the extracted datasets. We use bug reports for the past two years as the testing set and the

older ones as the training set.

Table 1: The information of the extracted datasets. The training phase starts from Jan. 1st, 2010 to Dec.
31st, 2017, whereas the testing phase covers Jan. 1st, 2018 to Dec. 31st, 2020.

EclipseJDT

LibreOÔ¨Éce

Training Testing

Total Training Testing

Mozilla
Total Training Testing

Total bugs reported
Total bug dependencies found
Total relevant changes in the bugs‚Äô history
Mean and Median Ô¨Åxing time (days)
Minimum, Maximum Ô¨Åxing time (days)

12,598
2,169
55,109
(39.1, 3)
(1, 1,753)

3,518
970
15,505
(15.7, 1)
(1, 423)

16,116
3,139
70,614
(33.4, 2)
(1, 1,753)

55,554
28,472
267,310
(35.5, 2)
(1, 1,509)

14,582
21,894
94,682
(9.4, 2.)
(1, 428)

70,136
50,366
361,992
(29.3, 2)
(1, 1,509)

90,178
71,549
410,010
(31.3, 5)
(1, 2,610)

22,353
19,223
114,778
(12.6, 4)
(1, 550)

Total

112,531
90,772
524,788
(26.0, 5)
(1, 2,610)

After cleaning

1. Bugs with resolved status
2. Bugs assigned to active developers
3. Bugs with known assignment date
4. Bugs with acceptable Ô¨Åxing time

11,146
5,212
4,193
3,598

2,562
1,483
1,348
1,251

13,708
6,695
5,541
4,849

46,890
6,569
5,655
4,708

11,106
1,890
1,754
1,570

57,996
8,459
7,409
6,278

79,281
15,322
10,004
8,651

18,742
6,403
3,960
3,704

98,023
21,725
13,964
12,355

Similar to previous studies [10, 16], we consider only the bugs that meet four criteria.

‚Ä¢ Not all bugs have Ô¨Åxing time information available. For instance, some bugs are still

open, or in some cases, the exact Ô¨Åxing date is not available in history. Hence, we only

consider the FIXED or CLOSED bugs with suÔ¨Écient information.

‚Ä¢ The assignment date is not available for some bugs, or the assignment time is after their

resolution. We eliminate them as invalid bugs.

‚Ä¢ Some bugs took years to get solved. We remove outlier bugs whose Ô¨Åxing time is greater

than the threshold of Q3 + (1.5 √ó IQR), where Q3 is the third quartile of the Ô¨Åxing

1https://wiki.mozilla.org/Bugzilla:REST API

14

time, and IQR is the interquartile range, i.e.,

IQR = (the third quartile) ‚àí (the Ô¨Årst quartile).

The maximum acceptable Ô¨Åxing times that we found for EclipseJDT, LibreOffice

and Mozilla are 63.5, 24.8 and 42 days, respectively.

‚Ä¢ Similar to previous works, we consider only active developers. We exclude inactive

developers as we do not have suÔ¨Écient information on them. Considering IQR as a

measure of central distribution, we deÔ¨Åne active developers as the ones whose bug Ô¨Åx

number is higher than the IQR of bug Ô¨Åx numbers of each developer.

Table 1 shows the eÔ¨Äect of applying each Ô¨Åltering step on the number of feasible bugs in the

system. We preprocess the textual information through lemmatization, stop words, numbers

and punctuation removal, and lengthy word elimination (i.e., longer than 20 characters).

Finally, we merge titles and descriptions of the bugs and tokenize them.

5. Evaluation

We compare the proposed method, DABT, with four other alternatives, i.e., the actual

bug assignment, CBR using SVM, CosTriage, and RABT. We deÔ¨Åne diÔ¨Äerent metrics for

the comparison as shown in Table 2. As the table indicates, RABT and DABT have few

unassigned bugs at the end of the testing phase due to the constraints they impose. This

number is negligible compared to the total bugs that are addressed. We implemented all the

methods in Python and used Gurobi 9.0 to solve the IP models.

One of the main diÔ¨Äerences between the algorithms is in their use of available developers.

Considering two bigger projects, LibreOffice and Mozilla, we observe that actual assign-

ment, RABT, and DABT use more developers than the other two methods. The similarity

between the manual assignment and RABT/DABT indicates that all consider developers‚Äô

schedules. CBR and CosTriage do not incorporate task concentration in their formulation,

and they are still prone to over-specialization. We explore this fact further by reporting the

average and standard deviation of the number of bugs assigned among developers. Both

RABT and DABT maintain the level of fair bug distribution among developers by calling

15

Table 2: Comparison of diÔ¨Äerent algorithms

Metrics

Actual

CBR CosTriage

RABT

DABT

# of assigned bugs
# of un-assigned bugs
# of assigned developers
Task distribution among developers (¬µ, œÉ)
Mean Fixing days per bug
Percentage of overdue bugs
Percentage of un-Ô¨Åxed bugs
Accuracy of assignments
Infeasible assignment w.r.t. bug dependency
Mean Depth of the BDG
Mean Degree of the BDG

# of assigned bugs
# of un-assigned bugs
# of assigned developers
Task distribution among developers (¬µ, œÉ)
Mean Fixing days per bug
Percentage of overdue bugs
Percentage of un-Ô¨Åxed bugs
Accuracy of assignments
Infeasible assignment w.r.t. bug dependency
Mean Depth of the BDG
Mean Degree of the BDG

# of assigned bugs
# of un-assigned bugs
# of assigned developers
Task distribution among developers (¬µ, œÉ)
Mean Fixing days per bug
Percentage of overdue bugs
Percentage of un-Ô¨Åxed bugs
Accuracy of assignments
Infeasible assignment w.r.t. bug dependency
Mean Depth of the BDG
Mean Degree of the BDG

1,250
0
15
(83.4, 93.7)
6.0
66.0
66.0
97.7
5.4
0.05
0.05

1,569
0
57
(27.5, 68.9)
3.3
35.9
35.9
91.7
0.1
1.41
0.84

3,704
0
137
(27.0, 49.5)
7.0
69.8
69.8
72.7
9.4
0.42
0.27

1,250
0
19
(65.8, 112.0)
7.9
82.2
82.2
95.5
6.0
0.05
0.05

1,569
0
22
(71.3, 224.5)
2.1
77.1
77.1
99.1
0.1
1.41
0.84

3,704
0
74
(50.1, 204.0)
7.2
80.1
80
60.2
9.0
0.44
0.27

1,250
0
19
(65.8, 108.5)
7.5
79.6
79.6
94.0
5.8
0.05
0.05

1,569
0
21
(74.7, 253.2)
1.8
80.8
80.8
99.3
0.1
1.41
0.84

3,704
0
85
(43.6, 187.0)
6.6
77.6
77.6
59.0
8.8
0.43
0.27

1,244
6
28
(44.4, 39.0)
7.0
17.6
18.1
83.4
4.7
0.04
0.04

1,569
0
86
(18.2, 59.3)
2.6
15.6
15.6
94.4
0.1
1.41
0.84

3,704
0
124
(29.9, 39.5)
7.0
25.0
25.0
50.9
6.8
0.39
0.25

1,238
12
27
(45.9, 52.1)
4.4
11.9
12.9
73.2
0.0
0.04
0.04

15,68
1
49
(32.0, 78.7)
1.6
13.2
13.3
92.6
0.0
1.41
0.84

3,687
16
114
(32.3, 59.3)
3.3
12.7
13.2
33.2
0.0
0.39
0.25

T
D
J
e
s
p
i
l
c
E

e
c
Ô¨É
O
e
r
b
L

i

a
l
l
i
z
o
M

more developers. DABT performs slightly worse in terms of distribution compared to RABT;

however, it achieves a comparable result using a smaller number of developers during the

testing phase. It means that it does not call redundant developers to achieve that fair dis-

tribution. We further investigate the eÔ¨Äect of task concentration by looking for top-10 active

developers of each algorithm. Figure 4 shows the number of Ô¨Åxing days for each developer.

As CBR and CosTriage do not consider the bug Ô¨Åxing loads, they even assigned bugs to their

top developer up to 16 times their capacity (see Figure 4c). Although both RABT and DABT

never over-assign bugs during the two-year testing time, DABT signiÔ¨Åcantly decreases the

Ô¨Åxing time for each developer by adding Ô¨Åxing time minimization to its objective function.

Accordingly, our method both meets the schedule criterion and optimizes the Ô¨Åxing time.

16

RQ1- In general, RABT is able to alleviate the task concentration of the developers. Not

only does it decrease the workload of expert developers, but it also reduces the total working

time of developers through Ô¨Åxing time consideration.

(a) EclipseJDT

(b) LibreOffice

Figure 4: The number of Ô¨Åxing days spent by top-10 active developers during the two-year testing phase.

(c) Mozilla

Table 2 shows that the average Ô¨Åxing days of the bugs signiÔ¨Åcantly decreases when us-

ing DABT. It consistently has a lower Ô¨Åxing duration for diÔ¨Äerent projects. It justiÔ¨Åes the

17

           Active Developers050010001500200025003000Fixing DaysActualCBRCosTriageRABTDABT           Developers02004006008001000120014001600Fixing DaysActualCBRCosTriageRABTDABT           Developers020004000600080001000012000Fixing DaysActualCBRCosTriageRABTDABTimportance of the tweak in the objective function of DABT that prioritizes the bugs with

shorter Ô¨Åxing times during bug assignments. Moreover, DABT has the lowest rate of overdue

bugs. When considering accumulated Ô¨Åxing time in the bug triage process, many bugs remain

unresolved due to task concentration on particular developers.

It justiÔ¨Åes the reason why

CBR and CosTriage have a high percentage of overdue bugs and is compatible with Figure 4.

By setting the hyperparameter L, we do not allow the system to assign bugs more than the

developers‚Äô capacity. On the other hand, unlike RABT, we also emphasize the signiÔ¨Åcance of

the bug Ô¨Åxing time, leading to a lower rate of overdue bugs. To further decrease the ratio of

delayed bugs, we recommend triagers setting a dynamic value for L, updated by the remaining

time until the next release.

RQ2- RABT signiÔ¨Åcantly decreases the ratio of overdue bugs by considering an upper limit

on the project horizon. It further improves this ratio by assigning bugs with a shorter Ô¨Åxing

time. Hence, it leads to a smoother bug Ô¨Åxing process and addressing more bugs before the

release date.

Similar to previous works [10, 16], we deÔ¨Åne an accurate assignment as recommending

a bug to a developer who has experience in the same component. Therefore, a proper bug

assignment does not mean assigning to the same developer. According to this deÔ¨Ånition, even

the manual bug assignment case fails to achieve an accuracy of 100% when compared to the

training phase. Some developers attempt to address a bug of a new component for the Ô¨Årst

time. The component might be similar but not the same as the previous ones. Hence, even

the actual assignment achieves an accuracy of 72.7% for Mozilla. It shows that expecting a

high accuracy of the model may cause incorrect assignment based on the ground truth values.

DABT has a lower accuracy for all models compared to its counterparts. There is a trade-oÔ¨Ä

between the accuracy and speed of the bug Ô¨Åxing process. The parameter Œ± in our model

regulates the accuracy of the assignments and speed of the bug Ô¨Åxing. Moreover, we impose

an upper limit on the project time horizon that may reduce the accuracy but leads to fewer

overdue bugs. We further investigate the model sensitivity to its parameter to see how much

of its lower accuracy arises from the regulation parameter.

Figure 5 shows the eÔ¨Äect of changes in Œ± on the accuracy and the percentage of overdue

bugs. As we increase Œ±, the model tends to give a higher weight to the developers‚Äô suitability

18

than the bug Ô¨Åxing cost. Therefore, DABT gets more accurate while disregarding the Ô¨Åxing

time. The developer may decide on how much accuracy they want, and accordingly, they

can set a proper value for Œ±. Similar to the previous studies, we use the Œ± = 0.5 and give

the same weight to the bug Ô¨Åxing time and the accuracy. We believe increasing the accuracy

while ignoring the associated cost may result in over-specialization and task-concentration.

Figure 5 shows that DABT can improve its accuracy by 15% through compromising its ability

to reduce the ratio of overdue bugs.

(a) EclipseJDT

(b) LibreOffice

(c) Mozilla

Figure 5: Sensitivity of the accuracy and the percentage of overdue bugs of DABT to its parameter Œ±.

One of DABT‚Äôs key characteristics is its capability to postpone blocked bugs. Whether

we assign a bug or a developer wants to take possession of a bug from a lengthy list of

open bugs, prioritizing the bugs that block others and increase BDG complexity is prudent.

Therefore, DABT includes a constraint on the infeasible bug assignment with respect to bug

dependency. Consequently, it postpones bugs until their blocking bugs are resolved. Table 2

shows the better performance of DABT in terms of addressing blocked bugs. It also reduces

the complexity of the BDG, i.e., its mean degree and depth. Surprisingly, RABT also shows

similar performance in terms of graph complexity. Figure 6 explores the average degree of the

bugs in the BDG during the two-year testing phase. We note that the mean degree of the

BDG is already low since there are many solo bugs in the BDG. Nonetheless, a small reduction

in these values is a signiÔ¨Åcant result since it can be considered as eliminating few high-degree

bottlenecks in the ITS. Both RABT and DABT keep the degree and the depth of the graph

low, given the fact that all algorithms solve the same list of bugs. For the exceptional case of

LibreOffice, our Ô¨Ånding is consistent with that of Jahanshahi et al. [9] in which they report

a signiÔ¨Åcant rate of found dependencies after 2017. Hence, based on the other two projects,

19

0.20.40.60.81.0alpha0.10.20.30.40.50.60.70.8AccuracyOverdue Percentage0.20.40.60.81.0alpha0.00.20.40.60.8AccuracyOverdue Percentage0.20.40.60.81.0alpha0.10.20.30.40.5AccuracyOverdue Percentagewe conclude that even when addressing the same bugs, the proper timing will reduce both

the complexity of the BDG and the number of overdue bugs. A lower BDG complexity is

beneÔ¨Åcial in the long-run when the rate of incoming bugs is increasing while many bugs are

still blocked by older ones.

RQ3- DABT is able to reduce the complexity of the bug dependency graph through the proper

timing of bug assignment. It will mitigate the risk of having a high number of blocking bugs

in the long-run.

(a) EclipseJDT

(b) LibreOffice

(c) Mozilla

Figure 6: The eÔ¨Äect of diÔ¨Äerent strategies on the degree of the BDG during the testing phase.

6. Threats to validity

In this section, we discuss threats to the validity of our empirical study.

6.1. Construct validity

We estimate the performance of the models using a train-test split. The Ô¨Årst eight years

are adopted as the training set and the last two years as the test. However, the evolving nature

of the bug repository may have an impact on the results. In some cases, developers become

inactive after some time or become more focused on a speciÔ¨Åc project component. Therefore,

the deÔ¨Ånition of the active developer might be required to get updated from time to time.

However, to make our results comparable with those of previous studies, we choose to rely on

its common practice and deÔ¨Ånition. We recommend a rolling approach for the train-test split

to overcome outdated decisions for future research.

Although we study textual information as our independent feature, more external bug

characteristics‚Äìe.g., the number of comments, keywords, and the number of CC‚Äôed developers‚Äì

20

                                                                                              0 H D Q  ' H J U H H  R I  % ' * $ F W X D O & % 5 & R V 7 U L D J H 5 $ % 7 ' $ % 7                                                                                        0 H D Q  ' H J U H H  R I  % ' * $ F W X D O & % 5 & R V 7 U L D J H 5 $ % 7 ' $ % 7                                                                                    0 H D Q  ' H J U H H  R I  % ' * $ F W X D O & % 5 & R V 7 U L D J H 5 $ % 7 ' $ % 7can be added to the prediction models. We plan to expand our independent variables and

include additional external factors in future works.

6.2. Internal validity

The bug information is extracted from the Bugzilla using the REST API. We incorporate

all the bug records between January 2010 and December 2019 to have an updated bug report

information. However, the API is limited for ordinary users, and access to the information of

several bugs is not feasible. Therefore, we extract all bug comments and complete our dataset

using regular expressions. We ensure that our dataset incorporates all publicly available bugs

for the EclipseJDT project.

6.3. External Validity

We consider three well-established projects in Bugzilla. Although it is compatible with

the previous works, our result may not be generalizable to all other open software systems.

However, the selected projects are large, long-lived systems, alleviating the likelihood of bias

in our report. The replication of our study using diverse projects may prove useful. We report

diÔ¨Äerent metrics to cover all advantages and disadvantages of the methods. Also, we use SVM

as the text classiÔ¨Åer following the previous works; however, other classiÔ¨Åers may result in

diÔ¨Äerent classiÔ¨Åcation performances.

7. Related work

Several studies have been conducted to automate the bug triage process and decrease the

cost of manual bug triage. DiÔ¨Äerent techniques have been used to address the problem, e.g.,

text categorization, tossing graph, fuzzy set-based automatic bug triaging, role analysis-based

automatic bug triage, information retrieval, and deep learning techniques.

Automatic bug triage using text classiÔ¨Åcation is proposed by Alenezi et al. [2], Anvik et al.

[3], Xuan et al. [19] wherein they trained diÔ¨Äerent classiÔ¨Åers such as SVM, Naive Bayes, and

C4.5 on the history of bug Ô¨Åxes. Xuan et al. [19] enhanced Naive Bayes classiÔ¨Åer by utilizing

expectation-maximization based on the combination of labeled and unlabeled bug reports.

They trained a classiÔ¨Åer with a fraction of labeled bug reports. Then, they iteratively classiÔ¨Åed

the unlabeled reports and Ô¨Åtted a new classiÔ¨Åer with the labels of all the bug reports. These

21

methods only aim to optimize the accuracy, ignoring many other aspects of the bug triaging

process.

Park et al. [16] proposed a method to optimize not only the accuracy but also the cost.

This method combines the CBR model with a collaborative Ô¨Åltering recommender (CF) model,

enhancing the recommendation quality of either approach alone. Alenezi et al. [2] presented

a text mining approach to reduce the time and cost of bug triaging. They examined the use

of four-term selection methods, namely, log odds ratio, chi-square, term frequency relevance

frequency, and mutual information on the accuracy of bug assignment. They aimed to choose

the most discriminating terms that describe bug reports. They then built the classiÔ¨Åer using

the Naive Bayes classiÔ¨Åer on bug reports. They also incorporated cost to re-balance the load

between developers considering their experience. Kashiwa and Ohira [10] also emphasized the

distribution of the loads among developers. Their method aims to increase the number of bugs

Ô¨Åxed by the next release. They formulated the bug triaging process as a multiple knapsack

problem that maximizes the developers‚Äô preferences given a time limit. Consequently, it

mitigates the task concentration to particular, experienced developers.

Lee and Seo [13] presented a method that addresses the issues related to LDA Ô¨Åxing

time calculation using a multiple LDA-based topic set. Their method improved the existing

models by building two additional topic sets, partial topic set (PTS) and feature topic set

(FTS). They showed that improved LDA has better classiÔ¨Åcation accuracy. Also, Xia et al.

[18] recommended a bug triaging method enhanced by specialized topic modeling, named

multi-feature topic model (MTM), which extends LDA by considering bugs‚Äô components and

products. Their proposed approach, TopicMiner, considers the topic distribution of a new

bug report to make recommendations based on a developer‚Äôs aÔ¨Énity to the topics and the

feature combination. Although these works rely on textual information, they do not consider

developer engagement. Ge et al. [7] proposed a method that overcomes this drawback. They

build a high-quality dataset by combining the feature selection and instance selection and

studied the impact of developer engagement on bug triage. They considered the product

information along with the textual information in the bug report to recommend the best

developer for a new bug report.

Many recent studies investigated automating the bug triage using deep learning techniques.

22

Lee et al. [14] suggested using a Convolutional Neural Network (CNN) and word embedding to

build an automatic bug triage. Mani et al. [15] utilized an attention-based deep bi-directional

RNN model (DBRNN-A) to automate bug triage. Their approach enables the model to

learn the context representation over a long word sequence, as in a bug report. Moreover,

they compared their methods with four diÔ¨Äerent classiÔ¨Åers, multinomial naive Bayes, cosine

similarity-based classiÔ¨Åer, support vector machines, and softmax (regression) based classiÔ¨Åer.

Their results show DBRNN-A, along with the softmax classiÔ¨Åer, outperforms bag-of-words

models. Guo et al. [8] proposed a developer activity-based CNN method for bug triage that

recommends a list of developers. They combined CNN with batch normalization and pooling

to learn from the word vector representation of bug reports generated by Word2vec.

A signiÔ¨Åcant characteristic of bug reports is their dependency. However, its importance is

rarely considered in the bug triage domain. Kumari et al. [12] developed a bug dependency-

based mathematical model to develop software reliability growth models. They interpreted the

bug summary description and comments in terms of entropy that also measures the uncertainty

and irregularity of the bug tracking system. In the bug triaging process, the incoming bugs are

dynamic that makes the bug dependency graph uncertain. To address this issue, Akbarinasaji

et al. [1] constructed a bug dependency graph considering two graph metrics, i.e., depth and

degree. They proposed a Partially Observable Markov Decision Process model for sequential

decision making to prioritize incoming bugs based on the bug Ô¨Åxing history and use Partially

Observable Monte Carlo Planning to identify the best policies for prioritizing the bugs.

DiÔ¨Äerent from the previous studies, RABT formulates a comprehensive model to capture

the most important aspects of bug triage that are speciÔ¨Åed by the domain experts. RABT

uses textual information to estimate the bug Ô¨Åxing time. Also, the information is fed into

a classiÔ¨Åer, SVM, to Ô¨Ånd the appropriate developers. However, instead of simply combining

these values, RABT considers the importance of developers‚Äô available time slots. Given that

constraint, it also postpones the bugs that are blocked by others and cannot be solved at the

moment. Accordingly, it covers the objectives of the previous works subject to their existing

constraints.

23

8. Concluding remarks

In this paper, we proposed a dependency-aware bug triaging method that aims to reduce

bug Ô¨Åxing time and infeasible assignment of blocked bugs while matching the most appropriate

developers. DABT also considers the bug Ô¨Åxing burden of developers in the bug triaging

process and alleviates task concentration on a small portion of developers. Accordingly, it

reduces the number of overdue bugs before the next release.

DABT is enhanced by adding the constraints on the blocked bugs. Although it is pri-

marily a triaging method, it also prioritizes the bugs such that both the complexity of the

bug dependency graph and the total Ô¨Åxing time reduces. Experimenting with three open-

source software systems, DABT demonstrated a robust result in terms of the reduced overdue

bugs, the improved Ô¨Åxing time of the assigned bugs, and the decreased complexity of the bug

dependency graph. The model has lower accuracy compared to the other baselines. How-

ever, through sensitivity analysis, we showed that it achieves higher assignment accuracy for

diÔ¨Äerent hyperparameter settings.

In this work, we assume that each developer can only work on a single bug simultaneously.

It is consistent with previous work; however, this may not be the case in many practical

settings. A relevant venue for future research would be to formulate a model that considers

multiple knapsacks per developer, each of which has a speciÔ¨Åc time limitation and working

capacity on bugs.

9. Supplementary materials

To make the work reproducible, we publicly share our originally extracted dataset of

one-decade bug reports, scripts, and analysis on GitHub.

References

[1] Shirin Akbarinasaji et al. 2018. Partially Observable Markov Decision Process to Prior-

itize software defects. Ph.D. Dissertation. Ryerson University.

[2] Mamdouh Alenezi, Kenneth Magel, and Shadi Banitaan. 2013. EÔ¨Écient Bug Triaging

Using Text Mining. JSW 8, 9 (2013), 2185‚Äì2190.

24

[3] John Anvik, Lyndon Hiew, and Gail C. Murphy. 2006. Who Should Fix This Bug?.

In Proceedings of the 28th International Conference on Software Engineering (Shang-

hai, China) (ICSE ‚Äô06). Association for Computing Machinery, New York, NY, USA,

361‚Äì370.

[4] P. Bhattacharya and I. Neamtiu. 2010. Fine-grained incremental learning and multi-

feature tossing graphs to improve bug triaging. In 2010 IEEE International Conference

on Software Maintenance. Timi oara, Romania, 1‚Äì10.

[5] David M Blei, Andrew Y Ng, and Michael I Jordan. 2003. Latent dirichlet allocation.

the Journal of machine Learning research 3 (2003), 993‚Äì1022.

[6] Der-San Chen, Robert G Batson, and Yu Dang. 2010. Applied integer programming.

Hoboken, NJ (2010).

[7] Xin Ge, Shengjie Zheng, Jiahui Wang, and Hui Li. 2020. High-Dimensional Hybrid Data

Reduction for EÔ¨Äective Bug Triage. Mathematical Problems in Engineering 2020 (2020).

[8] Shikai Guo, Xinyi Zhang, Xi Yang, Rong Chen, Chen Guo, Hui Li, and Tingting Li. 2020.

Developer activity motivated bug triaging: via convolutional neural network. Neural

Processing Letters 51, 3 (2020), 2589‚Äì2606.

[9] Hadi Jahanshahi, Mucahit Cevik, Jos¬¥e Navas-S¬¥u, Ay¬∏se Ba¬∏sar, and Antonio Gonz¬¥alez-

Torres. 2020. Wayback Machine: Capturing the evolutionary behaviour of the bug de-

pendency graph in open-source software systems. arXiv:2011.05382 [cs.SE]

[10] Yutaro Kashiwa and Masao Ohira. 2020. A Release-Aware Bug Triaging Method Con-

sidering Developers‚Äô Bug-Fixing Loads. IEICE TRANSACTIONS on Information and

Systems 103, 2 (2020), 348‚Äì362.

[11] Chandan Kumar and Dilip Kumar Yadav. 2017. Software defects estimation using met-

rics of early phases of software development life cycle. International Journal of System

Assurance Engineering and Management 8, 4 (2017), 2109‚Äì2117.

[12] Madhu Kumari, Ananya Misra, Sanjay Misra, Luis Fernandez Sanz, Robertas Dama-

sevicius, and VB Singh. 2019. Quantitative quality evaluation of software products by

25

considering summary and comments entropy of a reported bug. Entropy 21, 1 (2019),

91.

[13] Dong-Gun Lee and Yeong-Seok Seo. 2020. Improving bug report triage performance using

artiÔ¨Åcial intelligence based document generation model. Human-centric Computing and

Information Sciences 10, 1 (2020), 1‚Äì22.

[14] Sun-Ro Lee, Min-Jae Heo, Chan-Gun Lee, Milhan Kim, and Gaeul Jeong. 2017. Applying

Deep Learning Based Automatic Bug Triager to Industrial Projects. In Proceedings of the

2017 11th Joint Meeting on Foundations of Software Engineering (Paderborn, Germany)

(ESEC/FSE 2017). Association for Computing Machinery, New York, NY, USA, 926‚Äì931.

https://doi.org/10.1145/3106237.3117776

[15] Senthil Mani, Anush Sankaran, and Rahul Aralikatte. 2019. DeepTriage: Exploring

the EÔ¨Äectiveness of Deep Learning for Bug Triaging. In Proceedings of the ACM India

Joint International Conference on Data Science and Management of Data (Kolkata, In-

dia) (CoDS-COMAD ‚Äô19). Association for Computing Machinery, New York, NY, USA,

171‚Äì179. https://doi.org/10.1145/3297001.3297023

[16] Jin-woo Park, Mu-Woong Lee, Jinhan Kim, Seung-won Hwang, and Sunghun Kim. 2011.

CosTriage: A Cost-Aware Triage Algorithm for Bug Reporting Systems. Proceedings of

the AAAI Conference on ArtiÔ¨Åcial Intelligence 25, 1 (Aug. 2011).

[17] Inkyung Sung and Taesik Lee. 2016. Optimal allocation of emergency medical resources in

a mass casualty incident: Patient prioritization by column generation. European Journal

of Operational Research 252, 2 (2016), 623‚Äì634.

[18] Xin Xia, David Lo, Ying Ding, Jafar M Al-Kofahi, Tien N Nguyen, and Xinyu Wang.

2016. Improving automated bug triaging with specialized topic model. IEEE Transactions

on Software Engineering 43, 3 (2016), 272‚Äì297.

[19] Jifeng Xuan, He Jiang, Zhilei Ren, Jun Yan, and Zhongxuan Luo. 2017. Automatic Bug

Triage using Semi-Supervised Text ClassiÔ¨Åcation. arXiv:1704.04769 [cs.SE]

26

[20] S. F. A. Zaidi, F. M. Awan, M. Lee, H. Woo, and C. G. Lee. 2020. Applying Convolutional

Neural Networks With DiÔ¨Äerent Word Representation Techniques to Recommend Bug

Fixers. IEEE Access 8 (2020), 213729‚Äì213747.

https://doi.org/10.1109/ACCESS.

2020.3040065

[21] Jie Zhang, Xiaoyin Wang, Dan Hao, Bing Xie, Lu Zhang, and Hong Mei. 2015. A

survey on bug-report analysis. Science China Information Sciences 58 (02 2015), 1‚Äì24.

https://doi.org/10.1007/s11432-014-5241-2

27

