To appear in IEEE Computer Graphics and Applications.

RNNbow: Visualizing Learning via Backpropagation Gradients in
Recurrent Neural Networks

Dylan Cashman*
Tufts University

Genevieve Patterson†
Microsoft Research

Abigail Mosca‡
Tufts University
Remco Chang||
Tufts University

Nathan Watts§
Tufts University

Shannon Robinson¶
Tufts University

9
1
0
2

l
u
J

9
2

]

G
L
.
s
c
[

1
v
5
4
5
2
1
.
7
0
9
1
:
v
i
X
r
a

ABSTRACT

We present RNNbow, an interactive tool for visualizing the gradient
ﬂow during backpropagation training in recurrent neural networks.
RNNbow is a web application that displays the relative gradient
contributions from Recurrent Neural Network (RNN) cells in a
neighborhood of an element of a sequence. We describe the calcu-
lation of backpropagation through time (BPTT) that keeps track of
itemized gradients, or gradient contributions from one element of
a sequence to previous elements of a sequence. By visualizing the
gradient, as opposed to activations, RNNbow offers insight into how
the network is learning. We use it to explore the learning of an RNN
that is trained to generate code in the C programming language. We
show how it uncovers insights into the vanishing gradient as well as
the evolution of training as the RNN works its way through a corpus.

Index Terms:
I.2.6 [Computing Methodologies]: Artiﬁcial
Intelligence—Learning; G.1.6 [Mathematics of Computing]: Numer-
ical Analysis—Optimization; H.1.2 [Information Systems]: Models
and Principles—User/Machine Systems

1 INTRODUCTION

©2018 IEEE. Personal use of this material is permitted. Permission
from IEEE must be obtained for all other uses, in any current or
future media, including reprinting/republishing this material for ad-
vertising or promotional purposes, creating new collective works, for
resale or redistribution to servers or lists, or reuse of any copyrighted
component of this work in other works.

Artiﬁcal Neural Networks (ANNs) have made revolutionary im-
provements in classiﬁcation in many domains, with particular at-
tention given to their ability to classify images using convolutional
ﬁlters [10]. A commonly-cited issue with all ANNs is that they act
as a black box, with large numbers of hidden layers each individ-
ually learning their own weights resulting in a massive parameter
space. Problems of interpretability are compounded by non-linear
transformations which obfuscate interactions between each layer.
Visualizations of activations within convolutional neural networks
have seen some success in illuminating the inner workings of net-
works to both help understanding and to assist in hyperparameter
settings [19]. However, such activation visualizations are speciﬁc
to the domain of image processing, and primarily offer insight into

*e-mail: dylan.cashman@tufts.edu
†e-mail:gen@microsoft.com
‡e-mail: abigail.mosca@tufts.edu
§e-mail: nathan.watts@tufts.edu
¶e-mail: shannon.robinson@tufts.edu
||e-mail:remco@cs.tufts.edu

how a network is functioning after training. In this work, we present
RNNbow, a tool for providing insight into the training of Recurrent
Neural Networks (RNNs). RNNbow visualizes values calculated
during training in order to show the user if their network is learning
long-term time dependencies over sequences, a necessary feature in
most sequential models. It can be used to uncover problems with
poorly parameterized networks early in training.

A key insight that differentiates this work from other visualiza-
tions for deep learning is that it visualizes the gradients, not the
activations. Activations are the responses of the network during
inference - when fed an input, what neurons are ﬁring? While this is
instructive in comprehending how the network makes decisions, it
offers little insight into how the network learns. Learning in ANNs
is typically accomplished via gradient descent, a method which
minimizes loss over a training set by iteratively updating parameters
in the direction dictated by the gradient of that loss. Thus, to analyze
how the network is learning (or if it is learning at all), we must
inspect the gradients.

Figure 1: RNNbow helps the user see the ﬂow of gradients due to an
individual cell’s loss during training of a Recurrent Neural Network.
Here, we see highlighted in blue the gradient resulting from loss due
to predicting the character “u” when the true character was “-”.

RNNs are a particular class of ANNs that map input sequences to
output sequences. As with all ANNs, their function depends on what
they are fed in as inputs and what they are fed as desired outputs.
They can learn to label each item in a sequence if their training data
includes labels; a good example of this is training an RNN to do
part-of-speech tagging. Alternatively, RNNs can be used to generate
sequences that look like the training data. This is accomplished in a
technique ﬁrst proposed by Elman [3] in which, for a given training
set s1 . . . sn the input sequence is set to s1 . . . sn−1 and the output
sequence is set to s2 . . . sn. In this way, the RNN learns to predict the
succeeding element of a sequence. RNNs are behind some of Deep
Learning’s most astonishing results, including language translation,
generating image captions, and predicting medical outcomes.

RNNs have been called both “unreasonably effective” [7] and
“difﬁcult to train” [15]. One of the major issues with training RNNs
is ensuring that the gradient descent updates propagate far enough

1

 
 
 
 
 
 
To appear in IEEE Computer Graphics and Applications.

back that long-term dependencies can be learned. Consider an RNN
that tried to produce the following sentence.

In order for the RNN to be able to know the gender of the pronoun
his, it must remember the gendered noun man 5 time steps earlier.
Since RNNs learn via gradient descent, the only way to learn time
dependencies of that distance is to have the gradient due to the
loss incurred by an errant prediction propagate back to update the
parameters that controlled how much the model learned at an earlier
step. In other words, if the word his at t = i + 5 is a function of the
word man at t = i, then the gradient at t = i with respect to the loss
at t = i + 5 must be greater than 0.

If an RNN is parameterized poorly, it may fall victim to the well-
studied vanishing gradient problem [15], in which gradient only
ﬂows a few cells back, at which point the network may be no more
capable than using frequency counts over the training set. To try
to address this problem, the user must not only select numerical
parameters like the size of the hidden layer or the number of layers,
but also must choose between different architectures (stacks or grids)
and different RNN cell types such as Long Short-Term Memory
cells (LSTMs) or Gated Recurrent Units (GRUs). The theoretical
distinctions involved in making these choices can be mystifying to
many users of RNNs, and it can be confusing to try to diagnose
learning issues resulting from poor RNN design. Tools are needed
to reveal endemic issues in gradient ﬂow in RNNs so that the user
has early evidence of whether their network architecture is able to
learn or not.

RNNbow is a tool to visualize the gradient ﬂow during training
of an RNN. It provides an overview of the magnitude of the gradient
updates thorughout training, showing the user how quickly a model
is learning, and how the regime of parameter updates changes over
the course of training.
It also allows users to drill down into a
particular batch and view the individual inﬂuence of each of the
RNN’s predictions on on parameter updates in the hidden layer. By
breaking down the gradient update at each cell by each component’s
origin, it makes the vanishing gradient apparent.
It helps users
assess their parameterization of their network during training. It
also provides an illustration of the change in gradient behavior as
a network trains. In the case of the earlier example, RNNbow can
help the user detect if the loss incurred during the update of the word
him is successfully propagated 5 steps back to the word man. At
the time of writing, it is the only neural network visualization that
visualizes gradient ﬂow in RNNs that the authors are aware of.

Further, because RNNbow visualizes the gradient and not the
input space, the use of the tool is agnostic to the domain of the
problem. In contrast to many of the prevalent ANN visualizations
that focus on convolutional neural networks that operate on images
[12, 19], RNNbow could be used to visualize the gradient of any
RNN. In this paper we use a character-level RNN as a demonstration,
but RNNbow could be applied to show learning of other sequential
data, including video frames and words.

For a use case, we repeat a well-known RNN experiment [8]
to learn and generate statements in the C programming language
via a character-level RNN. We present some insights that can be
gleaned via RNNbow. We explain how traditional implementations
of backpropagation can be modiﬁed to collect the itemized gradi-
ents visualized by RNNbow, and discuss complexity implications.
We discuss the advantages of visualizing gradient over activation,
discuss the role of visual analytics in deep learning, and conclude
by considering future work in using RNNbow to compare different
architectures.

2 RELATED WORK

Prior to the recent explosion in big-data neural networks, artiﬁcial
neural networks were generally small enough to allow for overview
visualizations of all nodes and edges in their computation graph.
Early work in visualizing neural network activity focused on “open-
ing the black box” in this complicated computation graph. A good
example can be found in Tzeng and Ma’s work to display three-layer
networks as node-link diagrams, using the size and color of the nodes
and edges to encode activation magnitude and uncertainty [17]. As
the number of layers increases, such visualizations did not scale,
and visualizations began to focus on either aggregate views of ac-
tivations on particular inputs, or by viewing inputs that maximize
activation of particular nodes [19]. Some visualizations of the pop-
ular Convolutional Neural Network take advantage of the visual
form of the input space, integrating images into overviews of the
node activations [12]. Some visualizations treat neural networks like
other similar high-dimensional classiﬁers, visualizing 2-D projec-
tions of their classiﬁcations to provide insight into their decision
boundaries [6].

Because of their sequential nature, RNNs proffer an opportunity
for more concrete temporal visualizations. In an inﬂuential blog post
and accompanying publication [8], Karpathy et al. used a variety of
visualizations that overlayed some representation of node activation
over subsets of the input space to show how different hidden nodes
are responsible for different decision logic. There has also been work
in interpreting the hidden state dynamics of a trained RNN [13, 16].
Their visualizations suggested that activations in the hidden layer
contain information about the length of memory in a model.

Most of the tools listed are used after training to attempt to render
interpretable the state of a trained network at test time. In contrast,
RNNbow is used to visualize how the network has learned. Thus, it
could be useful to view gradients during training, to know whether
hyperparameters need to evolve or if the experiment needs to be
rerun with a different set of hyperparameters. Mid-training visualiza-
tion is one of the features of TensorBoard, a visualization tool built
on top of Google’s TensorFlow [1]. TensorBoard allows users to
write out values calculated during training to a log, and then gener-
ates basic visualizations, such as line graphs and bar charts, of those
values throughout training. A typical use case is to plot the loss of a
network as a function of the number of batches trained to conﬁrm
that the model is improving performance. While it would be possible
to log gradients by patching the backpropagation calculation in a
TensorFlow project, there is minimal support for visualizing those
gradients beyond line graphs and bar charts at the time of writing.
A recent work by Liu et. al. does visualize the training process for
deep generative models [11] by plotting the data ﬂow of activations
through layers accompanied by basic measures of performance such
as accuracy over time.

Our tool is unique in several ways. First, it visualizes gradient
ﬂow as opposed to activations. RNNbow is also used to assess
the learning of a network during training, to determine if a change
in hyperparameters is needed, as opposed to analyzing an ANN’s
response during test time. Lastly, in contrast to the cited RNN
visualizations, RNNbow is agnostic to type of input sequence (text
characters, movie frames, medical records) since it does not use the
input domain as a fundamental part of the visualization.

3 RECURRENT NEURAL NETWORKS

The goal of an RNN is to produce output given sequence input. Their
advantage over other sequential learners such as Markov chains or
Maximum Entropy Classiﬁers is that they are able to learn long-term
dependencies via nonlinear dynamics in their hidden layer. The
basic RNN architecture can be viewed as a graph with cycles, as
seen in Figure 2. At any given point in inference, the input xi and the
previous hidden state hi−1 are used to calculate the new hidden state
hi, which is then used to calculate the emission yi. Mathematically,

2

The   man   bought    a    toy   for   his   dog.i-1    i     i+1   i+2  i+3  i+4  i+5   i+6To appear in IEEE Computer Graphics and Applications.

matrices is calculated and they are then updated via gradient descent.
These gradients are typically calculated using backpropagation, an
efﬁcient algorithm for calculating gradients in computational graphs.
The newly updated weight matrices are used for the next batch. The
batch size, the size of the hidden layer, and certain constants used in
the updating of the weight matrices are all hyperparameters set by
the user.

For example, in our use case described in section 5, we build an
RNN to generate code for the C programming language. Before
training, W , U, and V are initialized randomly. If we used our RNN
with these randomly-initialized weight matrices to generate text, it
would be the same as sampling from a uniform distribution over all
characters, and thus it would not look like code. By feeding our
RNN input data that looks like valid code, we gradually update our
weight matrices so that our RNN generates sequences that better
match not only the distribution of characters in the training set
but the transitions between characters as well. Examples of code
generated by this RNN before and after training can be seen in
Figure 4. For more examples of character level RNNs, including
much more in-depth analysis of the generation of C code, see [8].

Batch 0:
Batch 10000:

0cu

|nv"M$R/mˆu tt+ˆCeU@x>Uh
s ged->bat ag_Me_sertaket())

Figure 4: Text generated by a character level RNN as used in our use
case. The ﬁrst line was generated before any training, and seems like
a random sampling of characters. The second line was generated
after training on 250000 characters of the Linux Kernel, and seems
to have captured some understanding of the syntactic rules of the C
programming language, such as function calls, underscore separators
in function names, and pointer accessing.

Our full training dataset is the Linux kernel, which we split into
batches of 25 characters. This also corresponds to unrolling our
RNN 25 steps. Referring to the equations deﬁned in (1) and (2),
the character input xi could be encoded densely using a mapping
such as ASCII, or it could use one-hot encoding. We use a hidden
layer of 100 nodes, meaning that the weight matrix U transforms our
input xi into a 100-dimensional vector representation of the original
input character. The hidden state vector is also 100 dimensions.
W hi−1 and Uxi are added together and then squashed through the
tanh activation function. That result is then multiplied by the weight
matrix V , which projects back into the character-space encoding,
providing a multinomial distribution over all possible characters.

To train on a given batch, the RNN starts with the ﬁrst character
as input, calculates a hidden state, and outputs a multinomial distri-
bution for what it thinks the next character could be. In RNNbow, we
show the most-likely character from that multinomial distribution,
max(yi), as shown in area 2 of Figure 5. The true label for the ﬁrst
character in the batch is the second character in the batch, since in
this experiment, we want the RNN to predict succeeding characters
based on the current character and its context. We use a softmax
loss, which generates high loss if our RNN suggests there is a low
probability of the true label and a high probability of other labels.
That loss is then used to calculate the gradient update for the weight
matrices. In RNNbow, we only visualize the gradients of W , since
W is what controls the memory of the RNN.

4 RNNBOW

RNNbow is a web application that visualizes the gradients used to
update parameters during training of a recurrent neural network. In
this section, we describe the interface, then we review how the gra-
dient data is harvested during training via backpropagation through
time (BPTT) [4].

Figure 2: A simple one-cell recurrent neural network, seen as a cyclic
computation graph. Trapezoids are linear transformations by a weight
matrix. Rectangles are element-wise scalar functions. The RNN
produces an output yi for every input xi, passing on the calculated
hidden state hi back to itself to use for the next input.

Figure 3: To make calculation over an input sequence well-deﬁned,
the RNN from Fig 2 is unrolled once for each element in the input
sequence. This RNN is unrolled three times to make three cells. It
takes three inputs, and produces three outputs. The weight matrices
U, W , and V are shared in each cell.

this can be described as:

hi = tanh (W hi−1 +Uxi)
yi = σ (V hi)

(1)
(2)

Here, W , U, and V are weight matrices, and σ is the sigmoid
function σ (x) = 1
1−e−x . Both tanh and σ are common activation
functions in the deep learning literature.
Intuitively, the weight
matrices perform a linear transformation on the data, and then the
activation functions squash the values back to an interpretable, nor-
malized range, with tanh bounded by (−1, 1), and σ bounded by
(0, 1). In addition, these activation functions add a nonlinearity into
computation so that the RNN can ﬁt more than polynomial functions.
During training, the training data set is partitioned into regular
batches. An RNN trains on one batch at a time, in sequential order,
by unrolling for a number of steps equal to the size of the batch. A
batch size of 3 is seen in Figure 3; however, a typical batch size might
range from a dozen elements to around a hundred. Within a batch,
the RNN steps through input in order, taking in an input, calculating
a hidden state, emitting an output, and then passing on the hidden
state to be used for the next item in the sequence. The inputs are
any data that can be sequenced (characters, words, frames, etc.), and
the outputs can be classiﬁcations of or regression on those inputs, or
distributions of potential classiﬁcations over the output range. The
outputs are compared to the true labels, and a loss is calculated. The
objective of training is to minimize the loss by choosing the optimal
weight matrices W , U, and V . After total loss has been calculated for
an entire batch, the gradient of the loss with respect to these weight

3

yixihihi-1tanhUWVy1x1h0tanhUWVy2x2h1tanhUWVy3x3h2tanhUWVTo appear in IEEE Computer Graphics and Applications.

Figure 5: The user interface to RNNbow. In (1), the user is shown a bar chart where each bar represents the maximum gradient per batch. By
mousing over different batches, the user can drill down to view gradient data from each batch in the training set. The pink bar seen 3/4 of the way
through (1) indicates the currently selected batch, and some information for that batch is seen printed above (1). In (2), the top row of characters
holds the true labels from the training set, and the bottom row holds the prediction from the RNN at training time. The prediction is colored green if
it is correct, and red if it is incorrect. (3) shows the magnitude of the gradients being used to update the weights at each point in time. Each bar is
decomposed into the different sources of the loss that created that gradient. On mousing over a particular gradient, we see the gradient due to a
single loss highlighted in blue, and projected down to (4) for easy inspection. Different batches can be previewed in (2), (3), and (4) by hovering
over their respective bars in (1), and selected by clicking on those bars.

4.1 Interface

The user interface of RNNbow is a coordinated multiple view imple-
mented in d3.js that provides both an overview of the data as well as
details of particular elements of the training set. The interface can
be seen in Figure 5. It takes in data on gradients recorded during a
pass over a training set. The speciﬁc data-visual mappings and how
such data is generated during training of an RNN model are both
described in section 4.2. RNNbow provides both an overview of gra-
dients across all batches and the ability to drill down and visualize
the gradients from a single batch at a time, so that the gradients at
individual locations in the training set can be seen clearly. Descrip-
tions of the interface below will make repeated use of the numeric
labels from Figure 5.

4.1.1 Area 1: Overview of Max Gradient of All Batches

Area 1 of the interface is a bar chart overview of the maximum
gradient within each batch. Our data comprised of 300 batches
of gradient data during training. Each bar in area 1 represents the
maximum gradient across all time steps within that batch. Because
RNNbow visualizes the maximum gradient in each batch as the
height of a bar in a bar chart, the user is able to easily to navigate
to parts of their training set where the most learning is happening.
While visualizing the mean would also be valid in that it would

show which batches were the most informative, visualizing the max
instead shows which individual elements of the training set are the
most informative.

The user is able to drill down into a particular batch by hovering
over a particular bar, resulting in information about that batch being
visualized in areas 2, 3, and 4. To ﬁx that batch as the selected
batch, the user may click on a bar. The currently selected batch is
signiﬁed as a pink bar in area 4. Some basic information about the
batch being visualized is displayed in text above area 1, including
the batch number, which training cells it corresponded to, and the
maximum gradient in that batch.

4.1.2 Area 2: Prediction and True Labels of a Single Batch

Area 2 provides details on demand for the batch selected in are 1.
In the top row of characters in area 2, we can see the ground truth
labels from the training set per element in the batch. Immediately
underneath those labels, we see our RNN’s prediction for the label
of that element. These predictions are colored according to whether
they are correct (green) or incorrect (red). In this ﬁgure, the training
set batch begins with the ﬁve characters “args; ”, and our RNN
predicts the ﬁve characters “etn
”. Showing the true and predicted
labels helps ground the user in their data.

4

To appear in IEEE Computer Graphics and Applications.

4.1.3 Area 3: Per Batch Gradients

Underneath each label, in area 3, gradients at each time step of the
selected batch of training data are visualized as a stacked bar chart.
The height of each bar represents the magnitude of the gradient used
to update the weights of the RNN at that step in time, relative to the
gradients within that speciﬁc batch. The bars are partitioned accord-
ing to how far in the future that portion of the gradient resulted from.
The lowest, darkest portion of the bar is the gradient due to the loss
of the current point in time (due to the loss of the label immediately
above the bar). Stepping up in the stacked bar, each new partition
is gradient due to the loss accrued due to the succeeding label. In
RNNbow, each vertical bar can show the gradient contribution from
up to 5 time steps in the future. The number of steps was chosen em-
pirically based on this use case; for other datasets, a larger horizon
may be necessary. For more discussion, see section 4.2.2.

4.1.4 Area 4: Gradients Due to Individual Prediction

While seeing the breakdown of the sum of the gradient at each step
may be informative, it is also interesting to see how gradient ﬂows
backwards from a particular time step - this would show how the
network was learning long-term dependencies. By hovering over any
portion of a bar in area 3, we highlight all portions in neighboring
bars due to the same loss. In addition, the particular prediction
and label that are responsible for that loss are highlighted with a
darker gray background, as seen in the gray box behind the two “t”
characters in Figure 5. For the sake of analysis, these portions are
projected down into area 4 to highlight the rate at which the gradient
decays.

As an example, in Figure 5, the cursor is hovering over the bottom
component of the gradient bar below the true label ‘t‘. In area 4, we
can see that the gradient due to this decision propagated back 5 time
steps, albeit diminishing in magnitude. Each blue bar represents the
amount the parameters are being updated at that point in time due to
the prediction made at ‘t‘. The magnitude of these bars is a proxy for
how large the inﬂuence is of a previously predicted character, such
as the white space character instead of an ‘s‘ at the beginning of
‘struct‘, had on the prediction of the character ‘t‘ at the end of ‘struct‘.
The faster this gradient decays, the shorter the time dependency is
that the model is learning. We call this projected bar chart the
gradient horizon, as it aims to show when the gradient contribution
vanishes as it passes back. As the user sweeps the mouse up and
down and across bars, area 4 changes which gradient horizon it
displays, allowing the user to quickly navigate the decomposition of
gradients.

4.2 Generating Gradient Data

Given a loss function, backpropagation passes that loss back to any
parameters involved in the loss’s calculation, via the chain rule. In a
Convolutional Neural Network, where one prediction is made, there
is generally a single loss calculation, which is then passed along via
gradients. In an RNN, there are multiple losses; loss is calculated at
each output yi. Calculating the gradient of W is a difﬁcult task since
each hidden state and each output are compounded functions of W .
To account for the multiple losses, RNNs use a special form of an
algorithm called backpropagation through time (BPTT) [4]. To use
BPTT, RNNs are unrolled - that is, each cycle in the computation
graph is represented as an additional copy of the RNN, to create a
directed acyclic computation graph that backpropagation can then
be used on, as seen in Figure 3.

Backpropagation is designed to be as computationally fast as
possible, making extensive use of dynamic programming to memo-
ize intermediate calculations so that the gradient can be calculated
in a single pass backwards through time. However, fully utilizing
dynamic programming will cause us to lose track of some of the
intra-sequence effects that RNNbow aims to illuminate. Thus, we
remove one level of dynamic programming, trading off increased

computational complexity for the ability to record itemized gradi-
ents. To motivate this, in the following section we fully derive an
expression for the gradient, pointing out what the mapping is be-
tween RNNbow and the terms in that expression. We also show how
our implementation is equivalent to backpropagation.

4.2.1 Derivation of Itemized Gradients
We are concerned with ∂ L
∂W , the rate at which the loss (L) changes
with respect to the weights of the hidden layer (W ). In training, we
use that quantity to update W via gradient descent. Because we
are interested in the gradient contributions from each time step, we
decompose the loss into loss contributed from the prediction made
at each time step. Here, Lt is deﬁned as the loss due to predicting yt ,
and n is the size of the batch.

L =

∂ L
∂W

=

n
∑
t=1
n
∑
t=1

Lt

∂ Lt
∂W

(3)

(4)

For a given time step t = i, we have the following decomposition,

via the chain rule.

∂ Li
∂W

=

=

∂ Li
∂ yi
∂ Li
∂ yi

·

·

∂ yi
∂W
∂ yi
∂ hi

·

∂ hi
∂W

(5)

We can further decompose the rightmost term, ∂ hi

∂W , but we must
be careful: hi is a function of W , but it is also a function of hi−1
which is in turn a function of W , so we must use the product rule.

∂ hi
∂W

= tanh(cid:48)(Uxi +W hi−1)

(cid:20)
hi−1 +W

(cid:21)

∂ hi−1
∂W

(6)

The leftmost term is the derivative of tanh(x), evaluated at Uxi +
W hi−1. Notice that we still must further expand the rightmost term,
just like we had to with ∂ hi
∂W . In the following derivations, the term
tanh(cid:48)(Uxi +W hi−1) is truncated to tanh(cid:48)
i for the sake of readability.

∂ hi
∂W

= tanh(cid:48)
i

(cid:20)
hi−1 +W tanh(cid:48)

i−1

(cid:20)
hi−2 +W

(cid:21)(cid:21)

∂ hi−2
∂W

(7)

∂W , and ∂ hi−3

We would then have to expand ∂ hi−2

∂W , and on until we
end up with the term ∂ h1
∂W which does not expand since h0, our ini-
tialized hidden state, does not depend on W - it is a hyperparameter
set by the user. In this way, the loss due to our prediction at t = i
ends up propagating all the way back through the input sequence to
t = 1.

∂ hi
∂W

= tanh(cid:48)
i

(cid:20)
hi−1 +W tanh(cid:48)

i−1

(cid:20)
hi−2 + . . . +W

(cid:21)(cid:21)

∂ h1
∂W

(8)

If we were to expand out all of the products in (8), we would end
up with summands that were only dependent on values available in
ordered subsets of the sequence.

= tanh(cid:48)

i hi−1 + tanh(cid:48)

i W tanh(cid:48)

i−1 hi−2 + . . .

(9)

∂ hi
∂W

5

To appear in IEEE Computer Graphics and Applications.

Note that calculating the ﬁrst summand only requires knowing
hi−1 and the additional arguments to tanh(cid:48)
i, U, W , and xi. Then,
we can memoize the value of tanh(cid:48)
i, and when calculating the next
summand, we only need that memoized value and U, W , hi−2, and
xi−1. Let M j be the i − jth summand of (9), so Mi = tanh(cid:48)
i hi−1,
Mi−1 = tanh(cid:48)
i−1 hi−2. Note that calculating M j depends only
on the values U, W , x j, h j−1, h j, and M j+1.

i W tanh(cid:48)

∂ hi
∂W

= Mi + Mi−1 + . . . + M1

W tanh(cid:48)

j h j−1

;

0 < j < i

M j =

M j+1
h j
Mi = tanh(cid:48)

i hi−1

(10)

(11)

(12)

Then we can rewrite (5) in a way that clariﬁes our implementation

of its calculation.

∂ Li
∂W

=

i
∑
j=1

∂ Li
∂ yi

·

∂ yi
∂ hi

· M j

(13)

In order to calculate the gradient for the entire batch, we would
need to sum this over each time step, so we substitute (13) into (4).

∂ L
∂W

=

n
∑
t=1

t
∑
j=1

∂ Lt
∂ yt

·

∂ yt
∂ ht

· M j

(14)

In order to use RNNbow, we record the summand of (14) for each
value of (t, j). We call these summands the itemized gradients, as
they are itemized by the time step that was the source of their loss.
To calculate this in O(n2), {M j} can be implemented as a one-
dimensional dynamic programming table that is ﬁlled in from right
to left. Then each can be calculated in a single backward pass of the
batch, from j = t down to j = 1. As an example, suppose that we
were training a character-level RNN, and had a batch to train on that
was the six characters g u i t a r, but our RNN instead predicted
the six characters b a n a n a. To calculate our gradient, we start
at the last character, t = 6, and see that we predicted a instead of
r, and so we incorporate some loss. We record the gradient due
to that prediction at t = 6, and then pass back that loss via M6 to
t = 5, · · · ,t = 1. Once we have calculated all itemized gradients due
to predicting a instead of r at t = 6, we jump to t = 5, calculate the
loss due to predicting n instead of a, and pass a different set of M j
back. This is based on an implementation of BPTT from [2].

The full area of the batch view seen in area 3 of Figure 5 represents
the full value of ∂ L
∂W . The full area of the detailed gradient horizon
seen in area 4 of Figure 5 represents the full value of ∂ Li
∂W described
in (13), and each bar within area 3 corresponds to an individual
summand. A vanishing gradient would correspond to the summands
decreasing as j decreases, which can be seen in Figure 8.

Traditional backpropagation only takes O(n), but it doesn’t ex-
pose the itemized gradients that we need to record for RNNbow. A
further exploration of the relationship between our calculation and
traditional backpropagation is given in the appendix.

4.2.2 Computational Concerns vs. Estimation
In practice, it may be impractical and unadvised to calculate the
itemized gradients throughout all of training. To begin with, this
algorithm generates an immense amount of data, storing O(HNn)
gradients in a single pass over the training set, where H is the number
of nodes in the hidden layer, N is the size of the training set, and n
is the batch size. In our use case, we used small batches and a small
hidden layer (n = 25, H = 100) compared to many networks, and if

6

we had used the entire training set, even using these small settings
for n and H we would have created data that was 2500 times the size
of our training data.

The problem of data size can be ameliorated by only calculating
the itemized gradients periodically - in our use case, we only store
the gradients every 100 batches, reverting to the optimized version
of backpropagation for the other 99% of batches. Lastly, gradients
are averaged between all nodes in the hidden layer, as our goal is
to see the general rate of training, rather than drilling down into
individual hidden nodes. Since this data is used for visualizations,
visualizing data from all nodes would lead to occlusion problems,
and the general trends of gradient can be viewed in the average.

It may also not be necessary to step all the way back through the
batch when calculating itemized gradients. Equation (10) shows that
the gradient due to a particular time step’s loss is decomposable into
a sum of sequence. We can use (11) to analyze the rate of decay of
that sequence.

M j
M j+1

=

h j−1
h j

W tanh(cid:48)
j

(15)

W is generally initialized close to 0, and regularization is used to
keep it having small magnitude during gradient descent. tanh(cid:48) has a
range of (0, 1], and h j−1
should generally be close to one. Thus, the
h j
sequence {M j} should decay as j decrements. Then it would stand
to reason that we might be able to choose a value k such that we only
have to step back k steps to be close enough to the real gradient.

Sk = Mi + Mi−1 + . . . + Mi−k

Sk ≈

∂ hi
∂W

(16)

(17)

In our use case, we empirically chose k = 5 based on manual
inspection of the data. However, it is highly likely that acceptable
k should vary with RNN architecture and cell choice. It might be
possible to ﬁnd a k such that ||Sk − ∂ hi
∂W || < ε globally across a valida-
tion set. Since k is loosely a measure of how far the gradient horizon
is, it would stand to reason that a more sophisticated architecture
would demand a larger k.

5 USE CASE
To demonstrate the use of RNNbow, we trained a character-level
RNN on the Linux Kernel to try to get it to generate code that looks
like the C programming language, replicating an experiment done
in Karpathy et al.’s seminal RNN work [8]. We used batches of 25
characters, and recorded gradients every 100 batches over the ﬁrst
50000 batches of the training data. We use a hidden layer of 100
nodes, but we average the gradients across all nodes. In this section,
we outline several insights that can be found via RNNbow.

5.1 Overview of Gradients Over Time
Figure 5 shows the result of training an RNN using our approach.
Looking at the overview section, seen as area 1 in Figure 5, the ﬁrst
insight is that the magnitude of the gradient starts very small, and
then appears to plateau, albeit with a fair amount of variance. This
suggests that early in training, the weights update slowly - there may
be some burn-in required before the parameters are updating efﬁ-
ciently. The overview also points the user to batches with maximal
gradient. It makes it easy for the user to view the elements of the
training set that the RNN learns the most from.

It can also be instructive to compare the batch visualizations
(area 2 in Figure 5) as they change from early in training to late in
training. Figure 6 shows the gradients of a batch early in training,
and Figure 7 shows the gradients of a batch late in training. At a

To appear in IEEE Computer Graphics and Applications.

Figure 6: The gradients of a batch early in training. Note that the gra-
dients are mostly composed of darker shades of color. This signiﬁes
that the gradient updates are primarily due to local loss, zero, one or
two time steps away.

Figure 7: The gradients of a batch later in training. Here, the gradients
are much more distributed across different shades, suggesting that
longer-term dependencies are being learned.

glance, the darker the batch visualization is, the shorter the gradient
horizon is; a larger portion of the update at each step comes from
local losses. In Figure 6, most of the bars in the visualized batch
are primarily composed of dark green bars. Compare that pattern
to a batch later in training in Figure 7, where the gradient is much
lighter; this corresponds to longer gradient horizons for training in
this batch. Exploring the training patterns over training reveals that
this particular RNN seemed to lengthen its time dependencies as
training went on.

5.2 Vanishing Gradient

A well-known consequence of the activation functions used in RNNs,
tanh and σ , is that they result in a gradient that decreases as it is
passed back in time. For large swaths of the hyperparameter space,
the gradient may decay incredibly fast, restricting any long-term
dependency learning [4, 15].

The primary function of the projection of gradients in the vi-
sualization, area 4 in Figure 5, is to illustrate the rate at which the
gradient decays. By mousing over a gradient bar, the user can see the
rate at which that particular gradient due to a particular character’s
loss vanishes. This can be seen in Figure 8.

5.3 Batches With Maximal Gradient

The overview bar chart in area 1 of the interface shown in Figure 5
can be used to cue the user towards parts of the training set that
the RNN learns the most from. For an example, we clicked on the
rightmost bar of area 1 to change the focus of RNNbow to that
batch, since that bar had the greatest height and thus the greatest
maximal gradient. The stacked bar chart of the maximal gradient in
that batch can be seen in Figure 9. The maximal gradient is due to
predicting the character a instead of predicting the character (, in
spite of the context of being in a for loop. Note that it also assumes
some gradient from incorrectly predicting the subsequent characters
as well. This suggests that our RNN has not learned the iterator

Figure 8: The detailed view of the gradients due to a single character’s
loss. Note that it makes the vanishing gradient effect very apparent.

Figure 9: The maximal gradient in the training set. The RNN assumes
a large gradient when predicting the character a instead of the char-
acter (. This may be due to a large loss being incurred by the model
not learning the iterator grammar of the C programming language.

grammar of the C programming language. It also conﬁrms that our
RNN is learning from actual mistakes and not overﬁtting the training
set. As this maximal gradient comes late in our training set and is on
a legitimate mistake, it cues the user that we have not trained enough
and training must continue.

6 DISCUSSION

6.1 Limitations

RNNbow is not intended to be a tool for power users of RNNs; such
users would be better served with custom visualizations and custom
analytics within their deep learning pipelines. RNNbow is most use-
ful to the non-expert. The current implementation does have some
scaling issues, both in the interface as well as in the implementation
of backpropagation through time, described in section 4.2. However,
it is more likely that a non-expert would use smaller networks that
are executable on a personal computer; that is the scale we aim to
currently support.

7

To appear in IEEE Computer Graphics and Applications.

The design does have some visual layout issues with scale as well.
This interface doesn’t support more than a few hundred batches, al-
though this should be solvable with some aggregation and drilldown.
In practice, RNNs may train over hundreds of thousands of batches.
A heuristic could be used to point the user to particularly interesting
batches within the training data. Similarly, the stacked bar chart
might not scale to batch sizes of 50 or more. In the use case given in
this work, with a batch size of 25 and k = 5, the stacked bar chart was
responsible for visualizing 125 pieces of data. A sophisticated RNN
might have a batch size of 128 and would hopefully have a much
larger memory; more iterations of design are needed to come up
with an appropriate visualization of so many gradients. In addition,
some form of aggregation would need to be deﬁned for the predicted
labels (in this case, characters) in large batch sizes. Perhaps the
largest hurdle to supporting industry scale networks is the number of
layers visualized. RNNbow currently supports a single layer; there
are popular CNNs with more than a hundred layers, and RNNs are
following suit [14]. It’s unclear how the stacked bar chart would
scale to even a dozen layers. It may be that a higher resolution
visualization of gradients between layers is needed.

Prior to the design of the visualization, basic experiments were run
to estimate the gradient horizon throughout the ﬁrst 50000 batches
of training, and it was found that it varied from 2 to 5 characters
before the gradient dropped below a certain ε > 0. Production-level
RNNs, with sophisticated architectures, may need gradient horizons
of tens or even hundreds of time steps. The current algorithm used
may not be scalable to record the gradient that many steps back.
This could be addressed by taking the gradients much less frequently
than every 100 batches.

6.2 Visualizing Gradients

One of the key insights of RNNbow is that it visualizes the gradient,
as opposed to the activation. Gradients are increasingly being ac-
cepted as a more salient representation of the learning surfaces and
thus a more informative value to study than activation and loss [9].
Considering that the gradient is what dictates updates to the model,
i.e. what is learned, its visualization is revealing of the training
process. It is particularly salient in a visualization of RNNs, as the
many-to-many relationship between losses and time steps can be
difﬁcult to intuit about. It proved useful in discovering endemic
properties like vanishing gradients; there may be other endemic
qualities in network training that cannot be noticed in visualizations
of activations.

and ∂ hi

In this work, we focused on the gradient ∂ Li

∂W , in part because this
is a value that is already traditionally calculated during backpropa-
gation, as it represents the quantity by which we update the tunable
parameter W in the RNN. This in turn led to calculating intermediate
gradients including ∂ Li
∂W . There are other gradients, how-
∂ yi
ever, that could have been calculated during training. In particular,
∂ hi
could have revealed interesting interplay between nodes within
∂ h j
the hidden layer and how they kept track of memory. As we seek
to crack open the black box of neural networks, it is important to
remember that each gradient is a different tangent surface to the
manifold on which the full parameter space of the network lies. In
this work, we analyze a very speciﬁc tangent surface with the goal
of understanding time dependencies. In work on visualizing CNNs,
it is very common to consider gradients of the activations as they
correspond to particular outcomes with a goal of determining what
parts of the image are most sensitive to a network’s understanding
of a label. In order to better understand the cross effects between
parameters in a deep network, it may be necessary to explore several
of these gradient surfaces, coupled with a visual analytics system
that guides the user towards logical conclusions, as RNNbow does
for the vanishing gradient. Each gradient surface may change dras-
tically over different architectures and settings of hyperparameters.

Comparing gradient surfaces generated by different networks may
offer more insight into the sensitivity of network behavior to each
hyperparameter.

6.3 Role of Visual Analytics in Deep Learning

It is not unreasonable to ask: is there even a role for Visual Analytics
in Deep Learning? While it is clear that visualization has a role in
helping a user build models that they trust, there are extenuating
circumstances that make it hard to apply the same considerations
to deep learning. A typical Support Vector Machine or Decision
Tree has only a handful of hyperparemeters that need to be set by
the user, and it learns only a dozen or so parameters during training.
In contrast, the famous AlexNet CNN from 2012 [10], a relative
dinosaur in deep learning years, ﬁts 60 million parameters. Users
must choose architectures, cell types, learning rate, ﬁlter size, and
a number of other hyperparameters. While this may sound like
it offers a good opportunity for building an analytics system that
abstracts away these decisions, in practice, it is impractical to infer
these values. Generally, visual analytics systems that collaboratively
build a model with a user do so by engendering an abstraction, or
mental model, of the underlying parameters, and then enable the
user to manipulate those parameters with intuitive interactions. In
many cases, industry-size neural networks simply have too many
underlying parameters, and these parameters tend to interact with
one another in unintuitive ways. Once a user has trained enough to
understand how those parameters work together, they likely have
gained the ability to program their own scripts using one of the many
fully-featured deep learning frameworks, at which point they may
ﬁnd a visual analytics sytem superﬂuous.

Perhaps because most builders of deep learning models were
already able to write their own scripts, the most succesful visual-
izations related to deep learning were not incorporated into visual
analytics systems, but were rather used to try to explain the inner
workings of a deep learning model post-hoc, after it had been built,
in order to gain insight into some of the structures that empirically
were working. This led to static visualizations of cleverly calculated
values, including gradients, typically overlaid on the input domain to
ground the network in the data on which it had been trained. In their
popularity, these visualizations suggested that it could be possible
to apply some interactivity into model building if the right data was
visualized.

The current usage of deep learning in the wild This landscape
leads to very different recommendations for designing tools depend-
ing on the audience of the tool. Our tool is primarily targeted at
nonexperts tuning simple one-layer RNNs, possibly in an educa-
tional setting. For that reason, we favored simple, low-dimensional
visualizations, and used calculated values with a clear, unambiguous
meaning. For an expert, the design decisions are drastically different.
The designer can make an assumption that the user will be directly
interacting with their model through a deep learning scripting frame-
work and that this framework gives them the ability to calculate
their own values of interest. Then these works can focus more on
an overview of many different aspects of the network, almost like
a monitoring system. Good examples of support for industry-scale
model builders can be found in recent works by Google [18] and
Facebook [6]. For a more thorough treatment of the state of visual
analytics in deep learning, we direct the reader to a recent survey [5].

7 FUTURE WORK

The design space of RNNs is rich and constantly evolving, and much
of the progress has the goal of having a longer gradient horizon. As
visualizing this gradient horizon is the key feature of RNNbow, it
should prove invaluable in comparing different approaches. One
direction of RNN research focuses on making more sophisticated
cells in which the calculation of the hidden state and outputs differs
from the vanilla RNN equations, seen in (1) and (2). We would like

8

To appear in IEEE Computer Graphics and Applications.

to adapt RNNbow to visualize the gradient ﬂow of these alternative
cells. It should be illustrative in comparing a vanilla RNN to a
Long Short Term Memory (LSTM). LSTMs have two hidden layers,
one of which is supposed to hold short term memory, and one of
which holds long term memory. It would be interesting to see if
this is supported in visualizations of the gradients of each hidden
layer. Another type of cell called a Gated Recurrent Unit (GRU)
only has one hidden layer, but in practice accomplishes long-term
dependencies similarly to LSTMs. It isn’t particularly clear why this
should be. In both LSTMs and GRUs, the calculations of emissions
require additional computation with each type of cell having several
gates that supposedly lengthen the memory. Perhaps RNNbow
would be able to be extended to reveal the gradient ﬂow within a
cell, not just between cells.

Beyond different cell types, different arrangements of cells have
also proved helpful in practical RNNs. One type of cell architecture
is a bidirectional RNN, in which two recurrent neural networks
are run in parallel for each batch, with one running through the
input sequence from left to right and the other in reverse. Their
outputs are then combined through a learned linear combination.
The bidirectional RNN allows learning former and future context,
and viewing the gradient ﬂow in both directions may aid in the
understanding of its training. More advanced architectures results
from adding layers of RNNs, either to match to multidimensional
sequences, or to use multiple layers to capture different levels of
abstraction in the input sequence as is typical in CNNs. These
architectures are difﬁcult to conceptualize; visualizing the gradient
may help. However, their spatial complexity proves a challenge in
the current layout of RNNbow; some cleverness will be necessary
to determine a layout for such architectures.

In this work, we didn’t consider the separate nodes in the hidden
layer - we just averaged the gradients together. This is in contrast
to many of the works on interpreting ANNs, in particular because
the activation of a single node tends to be a binary decision maker.
Previous work suggests that individual nodes have unique respon-
sibilities; in the same experiment as used in this work, Karpathy et
al. [8] found that a single node was responsible for remembering
the state of generated C code as being in a parenthesis or out of
a parenthesis. However, there is no scalable way to visualize all
hidden nodes in RNNbow; some heuristic will need to be developed
to cue the user to interesting nodes, and some overview of node
performance other than the mean will need to be added.

8 CONCLUSION

We present RNNbow, a web-based visualization tool for analyzing
gradient ﬂow during training of a Recurrent Neural Network. We
demonstrate how it can be used to ﬁnd endemic properties in a
network, and how it can provide insights into the learning process.
We also show that it can be a useful educational tool for illuminating
the vanishing gradient phenomenon. We review how to calculate
the itemized gradients necessary for loading data into RNNbow. We
discuss potential uses of the tool, especially the applications to other
RNN architectures.

ACKNOWLEDGMENTS

This material is partially based on research sponsored by the Air
Force Research Laboratory and DARPA under agreement number
FA8750-17-2-0107. This work is also supported in part by the
National Science Foundation: IIS-1452977 (CAREER).

V. Vanhoucke, V. Vasudevan, F. Vi´egas, O. Vinyals, P. Warden, M. Wat-
tenberg, M. Wicke, Y. Yu, and X. Zheng. TensorFlow: Large-scale
machine learning on heterogeneous systems, 2015. Software available
from tensorﬂow.org.

tutorial,
vanishing

part 3 -
gradients.

[2] D. Britz.

Recurrent neural networks

through

backpropagation
http://www.wildml.com/2015/10/recurrent-neural-
networks-tutorial-part-3-backpropagation-through-
time-and-vanishing-gradients/, 2015. Accessed: 2017-07-15.
[3] J. L. Elman. Finding structure in time. Cognitive science, 14(2):179–

time

and

211, 1990.

[4] S. Hochreiter. The vanishing gradient problem during learning re-
current neural nets and problem solutions. Int. J. Uncertain. Fuzzi-
ness Knowl.-Based Syst., 6(2):107–116, Apr. 1998. doi: 10.1142/
S0218488598000094

[5] F. Hohman, M. Kahng, R. Pienta, and D. H. Chau. Visual analytics
in deep learning: An interrogative survey for the next frontiers. arXiv
preprint arXiv:1801.06889, 2018.

[6] M. Kahng, P. Y. Andrews, A. Kalro, and D. H. P. Chau. Activis:
Visual exploration of industry-scale deep neural network models. IEEE
transactions on visualization and computer graphics, 24(1):88–97,
2018.

[7] A. Karpathy.

The unreasonable effectiveness of recurrent neu-
ral networks. http://karpathy.github.io/2015/05/21/rnn-
effectiveness/, 2015. Accessed: 2017-07-15.

[8] A. Karpathy, J. Johnson, and F. Li. Visualizing and understanding

recurrent networks. CoRR, abs/1506.02078, 2015.

[9] P. W. Koh and P. Liang. Understanding black-box predictions via

inﬂuence functions. arXiv preprint arXiv:1703.04730, 2017.

[10] A. Krizhevsky, I. Sutskever, and G. E. Hinton. Imagenet classiﬁcation
with deep convolutional neural networks. In F. Pereira, C. J. C. Burges,
L. Bottou, and K. Q. Weinberger, eds., Advances in Neural Information
Processing Systems 25, pp. 1097–1105. Curran Associates, Inc., 2012.
[11] M. Liu, J. Shi, K. Cao, J. Zhu, and S. Liu. Analyzing the training pro-
cesses of deep generative models. IEEE Transactions on Visualization
and Computer Graphics, 24(1):77–87, Jan 2018. doi: 10.1109/TVCG.
2017.2744938

[12] M. Liu, J. Shi, Z. Li, C. Li, J. Zhu, and S. Liu. Towards better analysis
of deep convolutional neural networks. CoRR, abs/1604.07043, 2016.
[13] Y. Ming, S. Cao, R. Zhang, Z. Li, Y. Chen, Y. Song, and H. Qu.
Understanding hidden memories of recurrent neural networks. CoRR,
abs/1710.10777, 2017.

[14] R. Pascanu, C¸ . G¨ulc¸ehre, K. Cho, and Y. Bengio. How to construct

deep recurrent neural networks. CoRR, abs/1312.6026, 2013.

[15] R. Pascanu, T. Mikolov, and Y. Bengio. On the difﬁculty of training
recurrent neural networks. In Proceedings of the 30th International
Conference on International Conference on Machine Learning - Volume
28, ICML’13, pp. III–1310–III–1318. JMLR.org, 2013.

[16] H. Strobelt, S. Gehrmann, H. Pﬁster, and A. M. Rush. Lstmvis: A
tool for visual analysis of hidden state dynamics in recurrent neural
networks. IEEE Transactions on Visualization and Computer Graphics,
24(1):667–676, Jan 2018. doi: 10.1109/TVCG.2017.2744158
[17] F.-Y. Tzeng and K.-L. Ma. Opening the black box-data driven visual-
ization of neural networks. In Visualization, 2005. VIS 05. IEEE, pp.
383–390. IEEE, 2005.

[18] K. Wongsuphasawat, D. Smilkov, J. Wexler, J. Wilson, D. Man´e,
D. Fritz, D. Krishnan, F. B. Vi´egas, and M. Wattenberg. Visualizing
dataﬂow graphs of deep learning models in tensorﬂow. IEEE transac-
tions on visualization and computer graphics, 24(1):1–12, 2018.
[19] J. Yosinski, J. Clune, A. M. Nguyen, T. J. Fuchs, and H. Lipson.
Understanding neural networks through deep visualization. CoRR,
abs/1506.06579, 2015.

REFERENCES

[1] M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S.
Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow,
A. Harp, G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kud-
lur, J. Levenberg, D. Man´e, R. Monga, S. Moore, D. Murray, C. Olah,
M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker,

A ITEMIZED GRADIENTS VS. BACKPROPAGATION

The calculation of (14) takes O(n2), where n is the size of the batch.
It is possible to utilize dynamic programming further to speed it up
to O(n); this is used in most implementations of backpropagation.
First, we expand both sums in (14).

9

To appear in IEEE Computer Graphics and Applications.

· [Mn + Mn−1 + · · · + M1]

∂ yn−1
∂ hn−1

· [Mn−1 + · · · + M1]

∂ L
∂W

=

∂ Ln
∂ yn

·

∂ yn
∂ hn
∂ Ln−1
∂ yn−1

·

+

· · ·

+

∂ L1
∂ y1

·

∂ y1
∂ h1

· M1

(18)

Next, we distribute, group the terms by M j, and factor.

∂ L
∂W

=Mn

(cid:19)

∂ yn
∂ hn

·

(cid:18) ∂ Ln
∂ yn
(cid:18) ∂ Ln
∂ yn

+Mn−1

·

∂ yn
∂ hn

+

∂ Ln−1
∂ yn−1

·

∂ yn−1
∂ hn−1

(cid:19)

+ · · ·

+M1

(cid:18) ∂ Ln
∂ yn

·

∂ yn
∂ hn

+ . . . +

(cid:19)

∂ L1
∂ y1

·

∂ y1
∂ h1

(19)

(cid:16) ∂ Ln
∂ yn

Let N j =

+ . . . + ∂ L j
. Then {N j} can be imple-
∂ y j
mented with a dynamic programming table as with {M j}, and we
can calculate the gradient in a single pass.

· ∂ y j
∂ h j

· ∂ yn
∂ hn

(cid:17)

∂ L
∂W

=

n
∑
i=1

MiNi

N j = N j+1 +

∂ L j
∂ y j

·

∂ y j
∂ h j

Ni =

∂ Li
∂ yi

·

∂ yi
∂ hi

(20)

;

0 < j < i

(21)

(22)

In optimized versions of backpropagation through an RNN, we
only make a single pass backwards through time, passing back our
accumulation of the gradients N j, and adding on the gradient of
the current time step. For RNNbow, we can’t use this method,
however, because we lose track of the terms in the expanded product
of (19) when we make use of the dynamic programming table for
{N j}. Thus, we need to use the O(n2) version described by (14),
saving each summand as we accumulate the sum. It is possible
that, depending on the implementation library, keeping track of
the intermediate M j and N j, and then utilizing vector math, as is
commonly used in the python library Numpy, could allow us to use
traditional backpropagation.

10

