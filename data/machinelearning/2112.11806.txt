Machine Learning manuscript No.
(will be inserted by the editor)

Lifting Symmetry Breaking Constraints with Inductive Logic
Programming

Alice Tarzariol · Martin Gebser ·
Konstantin Schekotihin

Received: date / Accepted: date

Abstract Efﬁcient omission of symmetric solution candidates is essential for combinato-
rial problem-solving. Most of the existing approaches are instance-speciﬁc and focus on the
automatic computation of Symmetry Breaking Constraints (SBCs) for each given problem
instance. However, the application of such approaches to large-scale instances or advanced
problem encodings might be problematic since the computed SBCs are propositional and,
therefore, can neither be meaningfully interpreted nor transferred to other instances. As a
result, a time-consuming recomputation of SBCs must be done before every invocation of
a solver. To overcome these limitations, we introduce a new model-oriented approach for
Answer Set Programming that lifts the SBCs of small problem instances into a set of inter-
pretable ﬁrst-order constraints using the Inductive Logic Programming paradigm. Experi-
ments demonstrate the ability of our framework to learn general constraints from instance-
speciﬁc SBCs for a collection of combinatorial problems. The obtained results indicate that
our approach signiﬁcantly outperforms a state-of-the-art instance-speciﬁc method as well as
the direct application of a solver.

Keywords Answer Set Programming · Inductive Logic Programming · Symmetry Breaking
Constraints

1 Introduction

Modern declarative programming paradigms allow for relatively simple modeling of vari-
ous combinatorial problems. Nevertheless, solving these problems might become infeasible

Alice Tarzariol
University of Klagenfurt, Austria
E-mail: alice.tarzariol@aau.at

Martin Gebser
University of Klagenfurt and Graz University of Technology, Austria
E-mail: martin.gebser@aau.at

Konstantin Schekotihin
University of Klagenfurt, Austria
E-mail: konstantin.schekotihin@aau.at

Correspondence to: alice.tarzariol@aau.at

1
2
0
2

c
e
D
3
2

]

O
L
.
s
c
[

2
v
6
0
8
1
1
.
2
1
1
2
:
v
i
X
r
a

 
 
 
 
 
 
2

Alice Tarzariol et al.

when the size of input instances and, correspondingly, the number of possible solution can-
didates start to grow [9]. In many cases, these candidates are symmetric, i.e., one candidate
can easily be obtained from another by renaming constants. In order to deal with large prob-
lem instances, the ability to encode Symmetry Breaking Constraints (SBCs) in a problem
representation becomes an essential skill for programmers. However, the identiﬁcation of
symmetric solutions and the formulation of constraints that remove them is a tedious and
time-consuming task. As a result, various tools emerged that avoid the computation of sym-
metric solutions by, for instance, automatically ﬁnding a set of SBCs using properties of
permutation groups or applying speciﬁc search methods that detect and ignore symmetric
states; see [24; 29; 33] for an overview.

Existing approaches to SBC generation can be classiﬁed into instance-speciﬁc and model-
oriented ones. The former methods identify symmetries for a particular instance at hand by
computing and adding ground SBCs to the problem representation [3; 10; 28]. Unfortu-
nately, computational advantages do not carry forward to large-scale instances or advanced
encodings, where instance-speciﬁc symmetry breaking often requires as much time as it
takes to solve the original problem. Moreover, ground SBCs generated by instance-speciﬁc
approaches are (i) not transferable, since the knowledge obtained is limited to a single in-
stance; (ii) usually hard to interpret and comprehend; (iii) derived from permutation group
generators, whose computation is itself a combinatorial problem; and (iv) often redundant
and might result in a degradation of the solving performance.

In contrast, model-oriented approaches aim to ﬁnd general SBCs that depend less on a
particular instance. The method presented in [8] uses local domain symmetries of a given
ﬁrst-order theory. SBCs are generated by identifying argument positions in atoms of a for-
mula that comprise object variables deﬁned over the same subset of a domain given in the in-
put. As a result, the computation of lexicographical SBCs is very fast. However, the method
considers each ﬁrst-order formula separately and cannot reliably remove symmetric solu-
tions, as it requires the analysis of several formulas at once. The method of [25] computes
SBCs by generating small instances of parametrized constraint programs, and then ﬁnds
candidate symmetries using SAUCY [2; 7] – a graph automorphism detection tool. Next, the
algorithm removes all candidate symmetries that are valid only for some of the generated ex-
amples as well as those that cannot be proven to be parametrized symmetries using heuristic
graph-based techniques. This approach can be seen as a simpliﬁed learning procedure that
utilizes only negative examples represented by the generated SBCs.

In this work, we introduce a novel model-oriented method for Answer Set Programming
(ASP) [23] that aims to generalize the process of discarding redundant solution candidates
for instances of a target domain using Inductive Logic Programming (ILP) [4]. The goal is
to lift the SBCs of small problem instances and to obtain a set of interpretable ﬁrst-order
constraints. Such constraints cut the search space while preserving the satisﬁability of a
problem for the considered instance distribution, which improves the solving performance,
especially in the case of unsatisﬁability. The particular contributions of our work are:

– We suggest several methods to generate a training set comprising positive and negative
examples, allowing an ILP system to learn ﬁrst-order SBCs for the problem at hand.
– We deﬁne the components of an ILP learning task enabling the generation of lexico-

graphical SBCs for ASP.

– We analyze the features and characteristics of the results obtained by our methods, as

well as the effects of language bias decisions on several combinatorial problems.

– We present an approach that iteratively applies our method to revise constraints when

new permutation group generators or more training instances become available.

Lifting Symmetry Breaking Constraints with Inductive Logic Programming

3

– We conduct performance experiments on variants of the pigeon-hole problem as well as
the house-conﬁguration problem [13]. The obtained results show that the SBCs gener-
ated are easy to interpret in most of the cases, and they result in signiﬁcant performance
improvements over a state-of-the-art instance-speciﬁc method as well as an ASP solver
without SBCs.

This work extends the previous conference paper [32] with two additional methods to
obtain the positive and negative examples for an ILP task, i.e., an alternative atom ordering
criterion and a full symmetry breaking approach, along with corresponding experimental
results. Moreover, we provide much more detailed descriptions and analyses of experiments
with the suggested language bias, the previous, and two new learning settings.

The structure of this paper is the following: a brief overview of the preliminaries is given
in Section 2. Section 3 presents our approach, while Section 4 describes its implementation
and speciﬁes the components of an ILP learning task. In Section 5, we investigate obser-
vations from learning experiments conducted with our methods. Section 6 provides and
discusses experimental results on the solving performance obtained for some combinatorial
problems. Lastly, Section 7 concludes the paper and outlines directions for future work.

2 Background

This section introduces some basics and notations for ASP, symmetry breaking, and ILP.

2.1 Answer Set Programming

Answer Set Programming (ASP) [23] is a declarative programming paradigm based on non-
monotonic reasoning and the stable model semantics [15]. Over the past decades, ASP has
attracted considerable interest thanks to its elegant syntax, expressiveness, and efﬁcient sys-
tem implementations, showing promising results in numerous domains like, e.g., industrial,
robotics, and biomedical applications [11; 12]. We will brieﬂy deﬁne the syntax and seman-
tics of ASP, and refer the reader to [14; 23] for more comprehensive introductions.

Syntax. An ASP program P is a set of rules r of the form:

a0 ← a1, . . . , am, not am+1, . . . , not an

where not stands for default negation and ai, for 0 ≤ i ≤ n, are atoms. An atom is an
expression of the form p(t), where p is a predicate, t is a possibly empty vector of terms,
and the predicate ⊥ (with an empty vector of terms) represents the constant false. Each term
t in t is either a variable or a constant, and a literal l is an atom ai (positive) or its negation
not ai (negative). The atom a0 is the head of a rule r, denoted by H(r) = a0, and the body
of r includes the positive or negative, respectively, body atoms B+(r) = {a1, . . . , am} and
(r) = ∅, and a constraint
B
if H(r) = ⊥.

(r) = {am+1, . . . , an}. A rule r is called a fact if B+(r) ∪ B

−

−

4

Alice Tarzariol et al.

Semantics. The semantics of an ASP program P is given in terms of its ground instantiation
Pgrd , replacing each rule r ∈ P with instances obtained by substituting the variables in r by
constants occurring in P . Then, an interpretation I is a set of (true) ground atoms occurring
in Pgrd that does not contain ⊥. An interpretation I satisﬁes a rule r ∈ Pgrd if B+(r) ⊆ I
(r) ∩ I = ∅ imply H(r) ∈ I, and I is a model of P if it satisﬁes all rules r ∈ Pgrd .
and B
A model I of P is stable if it is a subset-minimal model of the reduct {H(r) ← B+(r) |
r ∈ Pgrd , B

(r) ∩ I = ∅}, and we denote the set of all stable models of P by AS (P ).

−

−

2.2 Symmetry Breaking

Most of the modern instance-speciﬁc approaches detect symmetries of a given object by
representing it as an instance of the graph automorphism problem. This problem consists
of ﬁnding all edge-preserving bijective mappings of a graph vertex set to itself. It is an
attractive target of reduction since this problem can be solved efﬁciently for many families
of graphs using methods from the group theory; see [29] for an overview.

A group is an abstract algebraic structure hG, ∗i where G is a non-empty set, closed
under a binary associative operator ∗, such that G contains an identity element, and each
element has a unique inverse. If the operator ∗ is implicit, the group is represented by G.
A subgroup H of a group G is a group such that H ⊆ G. Given a set X = {x1, ..., xn} of
n elements, a permutation of X is a bijection that rearranges its elements. The symmetric
group SX is deﬁned by the set of all the n! possible permutations of X, and its subgroups
are called permutation groups. In cycle notation, we represent a permutation as a product of
disjoint cycles, where each cycle (cid:0)x1 x2 x3 . . . xk(cid:1) means that the element x1 is mapped to
x2, x2 to x3, and so on, until xk is mapped back to x1; the elements mapped to themselves
are not contained in the cycles.

Given a group G and a set X, the group action α : G −→ SX deﬁnes a permutation of
the elements in X for each g ∈ G. Then, each permutation α(g) induces a partition on X,
P α(g)(X), whose cells are called orbits of X under α(g). The cells of the ﬁnest partition
on X that reﬁnes P α(g)(X) for each g ∈ G, P G(X), are the orbits of X under group G.

Example 1 Given a set {a, b, c, d, e} of atoms ordered lexicographically and a permutation
π = (a d e) (b c), let us consider a random interpretation {a, c}, respectively, the integer
00101. To ﬁnd its symmetries with respect to π, we repeatedly apply the permutation to
{a, c} until no new interpretation is obtained, e.g., a 7→ d and c 7→ b yielding {b, d}, then,
d 7→ e and b 7→ c yielding {c, e}, and so on. Thus, we get the orbit {{a, c}, {b, d}, {c, e},
{a, b}, {c, d}, {b, e}}, respectively, {00101, 01010, 10100, 00011, 01100, 10010} with the
integer representation.

Letting G be a permutation group for a set X of ground atoms, the orbits of the set of
interpretations over X under G identify equivalence classes of the truth assignments for X.
When taking truth assignments as binary integers determined by some total order of the
elements in X, the lex-leader scheme consists of specifying a set of Symmetry Breaking
Constraints (SBCs) that may eliminate some interpretations but keep the smallest element
in terms of the associated integer for each orbit. If the SBCs eliminate all symmetric as-
signments and preserve the smallest element of each orbit only, we obtain full symmetry
breaking. However, dealing with up to n! permutations of n variables explicitly would be
an infeasible approach, and a more efﬁcient alternative is to focus on a subset of G to reﬁne
P G(X). If this leads to a partition ﬁner than P G(X), then we get partial symmetry break-
ing. In this case, the SBCs preserve the smallest element as a representative of each orbit

Lifting Symmetry Breaking Constraints with Inductive Logic Programming

5

but also other symmetric interpretations. Considering a set of irredundant generators K of
G is an effective heuristic for partial symmetry breaking since such generators represent G
compactly. A set K ⊂ G of elements in a group hG, ∗i is a set of generators for G if every
element of G can be expressed as a combination of ﬁnitely many elements of K under the
group operation. K is irredundant if no proper subset of it is a set of generators for G.

Example 2 Let us consider the applications of the generator π of the orbit obtained in Ex-
ample 1. For each interpretation in the orbit, we check whether π maps it into a smaller
interpretation according to the integer representation. Thus, the interpretations {c, e} and
{b, e} are eliminated since applying π yields {a, b} or {a, c}, respectively, while the inter-
pretations {a, c}, {b, d}, {a, b}, and {c, d} are preserved. As three symmetric interpretations
are obtained in addition to the smallest interpretation of the orbit, the representative {a, b}
(00011 in the integer representation), SBCs for direct applications of the generator π achieve
partial symmetry breaking only.

grd has the same rules as Pgrd , where P π

Symmetry-Breaking Answer Set Solving (SBASS) [10] detects and eliminates syntactic
symmetries in ASP by adding ground SBCs to an input ground program Pgrd . A symmetry
of Pgrd is given by a permutation π of ground atoms that keeps the program syntactically
unchanged, i.e., P π
grd is the set of rules obtained by
applying π to the head and body literals of rules in Pgrd . In the ﬁrst step, SBASS transforms
Pgrd to a colored graph GPgrd such that permutation groups of GPgrd and their generators
correspond one-to-one to those of Pgrd . In the second step, it uses SAUCY [2; 7] to ﬁnd a set
of group generators for GPgrd . Finally, for each found generator SBASS constructs a set of
SBCs based on the lex-leader scheme and appends them to Pgrd . Given the modiﬁed ground
program, an ASP solver is provided means to avoid symmetric answer sets.

Example 3 To illustrate how SBASS works, let us consider the pigeon-hole problem, which
is about checking whether p pigeons can be placed into h holes such that each hole contains
at most one pigeon. An encoding in ASP of this problem is:

pigeon(X-1) :- pigeon(X), X > 1.
hole(X-1) :- hole(X), X > 1.
{p2h(P,H) : hole(H)} = 1 :- pigeon(P).
:- p2h(P1,H), p2h(P2,H), P1 != P2.

It takes as input the ground facts pigeon(p). and hole(h). For example, solving the
instance with p = 3 and h = 3 leads to six answer sets:

AS 1 = {p2h(1,1), p2h(2,2), p2h(3,3)} = 100010001
AS 2 = {p2h(1,1), p2h(2,3), p2h(3,2)} = 010100001
AS 3 = {p2h(1,2), p2h(2,1), p2h(3,3)} = 100001010
AS 4 = {p2h(1,2), p2h(2,3), p2h(3,1)} = 001100010
AS 5 = {p2h(1,3), p2h(2,1), p2h(3,2)} = 010001100
AS 6 = {p2h(1,3), p2h(2,2), p2h(3,1)} = 001010100

The binary integer given on the right is obtained with the following total order of atoms:

p2h(3,3) > p2h(3,2) > p2h(3,1) >
p2h(2,3) > p2h(2,2) > p2h(2,1) >
p2h(1,3) > p2h(1,2) > p2h(1,1)

Applying SBASS to this pigeon-hole encoding, grounded with the previous input instance,
produces the following set of generators:1

1The generators are translated from SMODELS to symbolic representation, as described in Section 4.

6

Alice Tarzariol et al.

π1 = (cid:0) p2h(3,2) p2h(3,3) (cid:1) (cid:0) p2h(2,2) p2h(2,3) (cid:1) (cid:0) p2h(1,2) p2h(1,3) (cid:1)
π2 = (cid:0) p2h(3,1) p2h(3,3) (cid:1) (cid:0) p2h(2,1) p2h(2,3) (cid:1) (cid:0) p2h(1,1) p2h(1,3) (cid:1)
π3 = (cid:0) p2h(2,3) p2h(3,3) (cid:1) (cid:0) p2h(2,2) p2h(3,2) (cid:1) (cid:0) p2h(2,1) p2h(3,1) (cid:1)
π4 = (cid:0) p2h(1,1) p2h(3,3) (cid:1) (cid:0) p2h(2,1) p2h(2,3) (cid:1) (cid:0) p2h(1,3) p2h(3,1) (cid:1)

(cid:0) p2h(1,2) p2h(3,2) (cid:1)

According to the lex-leader scheme, we should discard all answer sets but AS 6, which is the
only answer set such that applying either generator does not lead to a greater interpretation:

π1(AS 6) = AS 4 → AS 6 ≤ AS 4 since p2h(3,1) = p2h(3,1) and

p2h(2,3) > p2h(2,2)
π2(AS 6) = AS 1 → AS 6 ≤ AS 1 since p2h(3,3) > p2h(3,1)
π3(AS 6) = AS 5 → AS 6 ≤ AS 5 since p2h(3,2) > p2h(3,1)
π4(AS 6) = AS 6 → AS 6 ≤ AS 6

Therefore, with this instance, we obtain full symmetry breaking by applying the lex-leader
scheme for the irredundant generators returned by SBASS. However, symmetric solutions
can be preserved for other inputs. E.g., with p = 3 and h = 4, two answer sets are preserved,
while the generators describe a common cell with all answer sets and a single representative.

2.3 Inductive Logic Programming

Inductive Logic Programming (ILP) [4] is a form of machine learning whose goal is to learn
a logic program that explains a set of observations in the context of some pre-existing knowl-
edge. Since its foundation, the majority of research in the ﬁeld addresses Prolog semantics
[6; 26; 30], even though applications in other logic paradigms appeared in the last years. The
most expressive ILP system for ASP is Inductive Learning of Answer Set Programs (ILASP)
[18; 21], which can be used to solve a variety of ILP tasks.

In ILP, a learning task hP, E, HM i is deﬁned by three elements: a background knowl-
edge P , a set of (positive and negative) examples E, and a hypothesis space HM , which
deﬁnes all the rules that can be learned. The learned hypothesis is a subset of the hypoth-
esis space that satisﬁes a speciﬁed learning setting: for ILASP, the setting is learning from
answer sets [18]. Before deﬁning it, we introduce the terminology used by ILASP authors.
A Partial Interpretation (PI) is a pair of sets of atoms, epi = hT, F i, called inclusions (T )
and exclusions (F ), respectively. Given a (total) interpretation I and a PI epi, we say that
I extends epi if T ⊆ I and F ∩ I = ∅. We can augment epi with an ASP program C to
obtain a Context Dependent Partial Interpretation (CDPI) hepi, Ci. Given a program P , a
CDPI e = hepi, Ci, and an interpretation I, we say that I is an accepting answer set of e
with respect to P if I ∈ AS (P ∪ C) such that I extends epi.

A learning task for ILASP is given by an ASP program P as background knowledge,
−, as positive and negative examples, and the hypothesis
two sets of CDPIs, E+ and E
space HM deﬁned by a language bias M, which limits the potentially learnable rules. The
learned hypothesis H ⊆ HM must respect the following criteria: (i) for each positive exam-
ple e ∈ E+, there is some accepting answer set of e with respect to P ∪ H; and (ii) for any
−, there is no accepting answer set of e with respect to P ∪ H. If
negative example e ∈ E
multiple hypotheses satisfy the conditions, the system returns one of the shortest, i.e., with
the minimum number of literals [18]. In [20], the authors extend the expressiveness of ILASP
by allowing noisy examples. With this setting, if an example e is not covered (i.e., there is
an accepting answer set for e if it is negative, and none, if it is positive), the correspond-
ing weight is counted as a penalty. Therefore, the learning task becomes an optimization

Lifting Symmetry Breaking Constraints with Inductive Logic Programming

7

problem with two goals: minimize the size of H and minimize the total penalties for the
uncovered examples.

Now, we will deﬁne the syntax of ILASP necessary for our work and refer the reader to

the system’s manual [21] for further details. A CDPI is expressed as follows:

#type(ID@W,{Inc},{Exc},{C}).

where type is either pos or neg, ID is a unique identiﬁer for the example, W is a positive
integer representing the example’s weight (if not deﬁned, the weight is inﬁnite), Inc and
Exc are two sets of atoms, and C is an ASP program. The language bias can be speciﬁed
by mode declarations, which deﬁne the predicates that may appear in a rule, their argument
types, and their frequency. Since in our work we aim to learn constraints, we restrict the
search space just to rules r with H(r) = ⊥. Hence, we only need to specify the mode
declarations for the body of a rule, expressed by #modeb(R,P,(E)) where R and E are
optional and P is a ground atom whose arguments are placeholders of type var(t) for some
constant term t. In the learned rules, the placeholders will be replaced by variables of type t.
The optional element R is a positive integer, called recall, which speciﬁes the maximum
number of times that the mode declaration can be used in each rule. Lastly, E is a condition
that further restricts the hypothesis space. We limit our interest to the anti reflexive
option that works with predicates of arity 2. When using it, atoms of the predicate P should
be generated with two distinguished argument values.

Choosing an appropriate language bias is still one of the major challenges for modern
ILP systems. Whenever the bias does not provide enough limitations, the problem becomes
intractable and ILASP might not be able to ﬁnd useful constraints. In contrast, a too strong
bias may exclude solutions from the search space, thus resulting in suboptimal SBCs [5].

3 Approach

We tackle combinatorial problems modeled in ASP such that the instances of a logic pro-
gram P are generated by a discrete and often stationary stochastic process. Such situations
occur, e.g., in industrial settings where the encoding of a manufacturing system is ﬁxed and
production orders vary. In this case, every problem instance can be seen as an outcome of the
process. We assume that any instance (i) speciﬁes the (true) atoms of unary domain pred-
icates p1, . . . , pk in P , where ci is the number of atoms that hold for each pi; and (ii) the
satisﬁability of the instance depends on the number of atoms for each domain predicate, but
not on the values of their terms. Thus, without loss of generality, we consider the terms for
each pi to be consecutive integers from 1 to ci.

Our method exploits instance-speciﬁc SBCs on a representative set of instances and
utilizes them to generate examples for an ILP task. The learning method yields ﬁrst-order
constraints that remove symmetries in the analyzed problem instances as much as possi-
ble while preserving the instances’ satisﬁability. We consider the following two learning
settings:

– enum is a cautious setting that preserves all answer sets that are not ﬁltered out by the

ground SBCs; and

– sat setting aims to learn tighter constraints which, however, preserve at least one answer

set for each instance.

To compute the examples, our approach relies on small satisﬁable instances (i.e., with
a low value for each ci), subdivided into two parts: S and Gen. Each instance g ∈ Gen

8

Alice Tarzariol et al.

Gen

S

Create pos(∅, ∅, g)
∀g ∈ Gen

Create examples
∀i ∈ S

Ex Gen

Ex S

Fig. 1: ILP examples generation.

Algorithm 1: Framework to lift SBCs with ILP
input : P , ABK , HM , Gen, S, m

1 Ex Gen ← ∅;
2 Ex S ← ∅;
3 foreach g ∈ Gen do
4

Ex Gen ← Ex Gen ∪ {pos (∅, ∅, g)};

5 foreach i ∈ S do
6

IG ← Set of irredundant generators for i;
foreach I ∈ AS (P ∪ i ∪ ABK ) do

T ← atoms (IG) ∩ I;
F ← atoms(IG ) \ I;
if lexLead(hT, F i, IG) then

Ex S ← Ex S ∪ {neg(T, F, i)};

else if m = enum then

Ex S ← Ex S ∪ {pos (I, ∅, i)};

else

Ex S ← Ex S ∪ {pos (∅, ∅, i)};

7

8

9

10

11

12

13

14

15

16 C ← Solve hP ∪ ABK , Ex Gen ∪ Ex S, HM i;
17 ABK ← ABK ∪ C;

deﬁnes a positive example with empty inclusions and exclusions, and g as context. These
examples, denoted by Ex Gen , guarantee that the learned constraints generalize for the target
distribution since they force the constraints to preserve some solution for each g ∈ Gen. The
instances i ∈ S are used to obtain positive and negative examples, representing answer sets
of P ∪i to be preserved or ﬁltered out, respectively, by corresponding SBCs. We denote their
union by Ex S in Figure 1, where positive examples represent whole answer sets in the enum
setting, or like instances in Gen, consist of empty inclusions and exclusions along with the
context i in sat.

An ILP task further requires background knowledge and a hypothesis space HM . Both
of them are deﬁned by the user (for a possible instantiation, see Section 4.3). The back-
ground knowledge consists of a logic program P along with an Active Background Knowl-
edge, denoted by ABK in Algorithm 1. We use ABK to simplify the management of aux-
iliary predicate deﬁnitions and constraints learned so far. The hypothesis space contains the
mode declarations, and we assume it to be general enough to entail ground SBCs by learned
ﬁrst-order constraints. The remaining inputs of Algorithm 1 consist of the instances in Gen
and S as well as the learning setting m. For each answer set I of an instance i ∈ S to
be analyzed, the algorithm determines T and F by projecting I to the atoms occurring in
IG, denoted by atoms(IG). Next, in line 10, the predicate lexLead (hT, F i, IG) evaluates
to true if I is dominated, i.e., I can be mapped to a lexicographically smaller, symmetric
answer set by means of some irredundant generator in IG. In this case, the negative exam-

Lifting Symmetry Breaking Constraints with Inductive Logic Programming

9

ABK

P

i

GRINGO

Pgrd

SBASS

Pgrd + SBCs

Permutations

CLASP

Lex-lead

AS (Pgrd )

CLINGO

Ex of i

Example data

Fig. 2: Pipeline to compute examples from an instance i.

ple neg(T, F, i) is added to Ex S in order to eliminate I, while pos(I, ∅, i) or pos(∅, ∅, i) is
taken as the positive example otherwise, depending on whether the enum or sat setting is
selected. Positive examples of the form pos(∅, ∅, g) are also gathered in Ex Gen for instances
g ∈ Gen, and solving the ILP task at line 16 gives new constraints C to extend ABK .

4 Implementation

The implementation of our framework relies on CLINGO (consisting of the grounding and
solving components GRINGO and CLASP), SBASS and ILASP, and is available at [31]. Fig-
ure 2 shows the pipeline to generate the examples for a given instance i ∈ S (the for-loop
at line 5 of Algorithm 1). First, the union of P , i, and ABK is grounded with GRINGO to
get the ground program Pgrd in SMODELS format. Then, the solver CLASP enumerates all
its answer sets, obtaining AS (Pgrd ). Independently, SBASS is run on Pgrd with the option
--show to output a set of irredundant permutation group generators. This set contains the
vertex permutations of GPgrd , expressed in cycle notation. We extract the cycles deﬁned by
vertices representing atoms of Pgrd and transform them from SMODELS format back into
their original symbolic representation (by a predicate and integer terms).

Next, we identify the symmetric answer sets in AS (Pgrd ) by using an ASP encoding
similar to the lex-leader predicate deﬁnition in [29] to evaluate SBCs. To this end, we imple-
ment an ordering criterion to compare atoms according to their signatures. Given two ground
atoms p1(a1, . . . , an) and p2(b1, . . . , bm), the ﬁrst is considered smaller than the second if:
(i) p1 is lexicographically smaller than p2; (ii) p1 = p2 and n < m; or (iii) p1 = p2, n = m,
and there are constants ai < bi such that aj = bj for all 0 < j < i. Our ASP encoding then
checks whether an answer set I ∈ AS (Pgrd ) is undominated by interpretations obtainable
by applying the symbolic representation of some irredundant generator returned by SBASS
to I.

In case I is dominated and thus must be eliminated as a symmetric answer set, we map
it to a negative example with a unique identiﬁer and a weight of 100. Due to the weights,

10

Alice Tarzariol et al.

ILASP returns a set of constraints even if some negative examples are not covered. Moreover,
we use uniform weights so that all negative examples have the same relevance and as many
as possible are to be eliminated. Lastly, answer sets that were not found to be dominated for
any of the generators yield positive examples according to the selected setting – enum or
sat. Such positive examples are unweighted so that the learned hypothesis must cover all of
them.

4.1 Alternative Atom Ordering

Let us consider sets of n lexicographically ordered atoms that only differ in the values of
the last terms in each atom. For two such sets A = {p(−→x1, a1), . . . , p(−→xn, an)} and B =
{p(−→x1, b1), . . . , p(−→xn, bn)} of atoms, where −→xi contains all terms but the last, the lex-leader
scheme starts by checking the atoms with the greatest −→xi vectors until there are two constants
ai 6= bi. Since various conﬁguration problems yield answer sets of this kind, we devised
an alternative atom ordering such that the lex-leader scheme starts from the smallest −→xi
vectors when comparing two answer sets. To this end, an atom p1(a1, . . . , an) is considered
smaller than p2(b1, . . . , bm) if: (i) p1 is lexicographically smaller than p2; (ii) p1 = p2 and
n < m; (iii) p1 = p2, n = m, and there are constants ai > bi such that i < n and aj = bj
for all 0 < j < i; or (iv) p1 = p2, n = m, ai = bi for all 0 < i < n, and an < bn.

This alternative ordering allows for more natural, undominated answer sets, as illustrated

in the following example.

Example 4 Applying the alternative ordering criterion to the same input as described in
Example 3, we get the following total order of atoms:

p2h(1,3) > p2h(1,2) > p2h(1,1) >
p2h(2,3) > p2h(2,2) > p2h(2,1) >
p2h(3,3) > p2h(3,2) > p2h(3,1)

Thus, the integers associated with the answer sets become:

AS 1 = {p2h(1,1), p2h(2,2), p2h(3,3)} = 001010100
AS 2 = {p2h(1,1), p2h(2,3), p2h(3,2)} = 001100010
AS 3 = {p2h(1,2), p2h(2,1), p2h(3,3)} = 010001100
AS 4 = {p2h(1,2), p2h(2,3), p2h(3,1)} = 010100001
AS 5 = {p2h(1,3), p2h(2,1), p2h(3,2)} = 100001010
AS 6 = {p2h(1,3), p2h(2,2), p2h(3,1)} = 100010001

Now the lex-leader scheme discards all but the answer set AS 1, and three permutations map
AS 6 to smaller answer sets:

π1(AS 6) = AS 4 → AS 6 > AS 4 since p2h(1,3) > p2h(1,2)
π2(AS 6) = AS 1 → AS 6 > AS 1 since p2h(1,3) > p2h(1,1)
π3(AS 6) = AS 5 → AS 6 > AS 5 since p2h(1,3) = p2h(1,3) and

p2h(2,2) > p2h(2,1)

π4(AS 6) = AS 6 → AS 6 ≤ AS 6

The answer set AS 1 contains atoms that are preserved by the general ﬁrst-order constraint
:- p2h(P,H), P < H., which removes all other symmetric solutions. Unlike that,
when taking AS 6 as a representative solution, we have to distinguish particular cases for
the assignment of the ﬁrst and the last pigeon, resulting in longer and more speciﬁc con-
straints.

Lifting Symmetry Breaking Constraints with Inductive Logic Programming

11

4.2 Exploiting Generators for Full Symmetry Breaking

When investigating irredundant generators to label an answer set as a positive or negative
example according to the lex-leader scheme, there can be cases where the labeling achieves
partial instead of full symmetry breaking. As illustrated in Example 2, this is because sin-
gle applications of generators yield a subset of the orbit of an interpretation only. Thus,
we implement an alternative setting to label the examples, named fullSBCs, which exploits
generators to explore the whole orbit of symmetric interpretations for every answer set. For
each of the obtained cells, we label the smallest answer set as a positive example and all the
remaining ones as negative. This approach reduces the sensitivity of ILP tasks to particular
irredundant generators returned by SBASS, allowing to achieve full symmetry breaking for
any instance i ∈ S.

We implement this setting by means of the CLINGO API2 to interleave the solving phase,
which returns a candidate answer set, with the analysis of its orbit. Then, before continuing
with the search for the next answer set, we prohibit the explored interpretations by feeding
respective constraints to CLINGO. This setting allows for reducing the number of positive
examples produced, and as we can conﬁgure it to sample a limited subset of all answer sets,
it is also useful for dealing with underconstrained conﬁguration problems that yield plenty
of answer sets even for very small instances.

Example 5 To illustrate the fullSBCs setting, let us reconsider the pigeon-hole problem in-
troduced in Example 3, where the instance with three pigeons and four holes leads to 24
solutions. Running SBASS on this instance yields ﬁve generators, which identify a single
cell since all the answer sets are symmetric. However, we only consider the ﬁrst two genera-
tors in the following, allowing us to demonstrate the fullSBCs approach on an example with
several, i.e., four, cells. The generators we inspect are:

π1 = (cid:0) p2h(3,2) p2h(3,3) (cid:1) (cid:0) p2h(2,2) p2h(2,3) (cid:1) (cid:0) p2h(1,2) p2h(1,3) (cid:1)
π2 = (cid:0) p2h(3,3) p2h(3,4) (cid:1) (cid:0) p2h(2,3) p2h(2,4) (cid:1) (cid:0) p2h(1,3) p2h(1,4) (cid:1)

Let AS 1 = {p2h(1,3), p2h(2,2), p2h(3,4)} be the ﬁrst answer set found.
Then, before searching for other solutions, we repeatedly apply π1 and π2 to AS 1 to ob-
tain the whole orbit of symmetric interpretations. The identiﬁed answer sets are:

AS 1 = {p2h(1,3), p2h(2,2), p2h(3,4)} = 010000101000
π1(AS 1) = AS 2 = {p2h(1,2), p2h(2,3), p2h(3,4)} = 001001001000
π2(AS 1) = AS 3 = {p2h(1,4), p2h(2,2), p2h(3,3)} = 100000100100
π1(AS 2) = AS 1
π2(AS 2) = AS 4 = {p2h(1,2), p2h(2,4), p2h(3,3)} = 001010000100
π1(AS 3) = AS 5 = {p2h(1,4), p2h(2,3), p2h(3,2)} = 100001000010
π2(AS 3) = AS 1
π1(AS 4) = AS 6 = {p2h(1,3), p2h(2,4), p2h(3,2)} = 010010000010
π2(AS 4) = AS 2
π1(AS 5) = AS 3
π2(AS 5) = AS 6
π1(AS 6) = AS 4
π2(AS 6) = AS 5

Once we have computed all answer sets symmetric to AS 1, we produce a positive example
for the smallest answer set encountered, i.e., AS 2, while the other ﬁve answer sets consti-
tute negative examples. Now, we can proceed with the search for the next answer set, e.g.,
AS 7 = {p2h(1,2), p2h(2,1), p2h(3,3)}, and repeat the application of genera-
tors to explore its cell, identifying another ﬁve symmetric solutions of which {p2h(1,3),

2A complete reference documentation can be found at https://potassco.org/clingo/python-api/current/.

12

Alice Tarzariol et al.

Algorithm 2: fullSBCs method to generate Ex S for an instance i
input : P , i, ABK , IG

4

1 cnt ← CLINGO.init(P ∪ i ∪ ABK );
2 while I ← cnt.get new solution() do
min ← atoms (IG) ∩ I;
3
Q ← new queue();
Q.push(min);
seen ← {min};
while T ← Q.pop() do
if T > min then

6

7

5

8

9

10

11

12

13

14

15

16

17

18

Ex S ← Ex S ∪ {neg(T, atoms(IG ) \ T, i)};

else if T < min then

Ex S ← Ex S ∪ {neg(min, atoms(IG ) \ min, i)};
min ← T ;

forall π ∈ IG do

if π(T ) /∈ seen then
Q.push(π(T ));
seen ← seen ∪ {π(T )};

Ex S ← Ex S ∪ {pos (min , atoms(IG ) \ min, i)};
cnt.ignore solutions(seen);

p2h(2,1), p2h(3,2)} is the smallest. This process continues until all 24 answer sets,
partitioned into four cells with a smallest representative for each, are explored.

Algorithm 2 outlines the fullSBCs approach, providing an alternative implementation
of the for-loop at line 7 of Algorithm 1. In the ﬁrst line, we create a search control object,
cnt, using the CLINGO API. This object keeps track of already identiﬁed solutions and pro-
vides the get new solution method, which returns either a new answer set I or false if all
solutions have been exhausted. Similar to the previously presented approaches to example
generation, we project the atoms of I to atoms(IG). The resulting interpretation min rep-
resents the smallest solution encountered so far in the current cell, and the set seen keeps
track of already discovered interpretations belonging to the current cell. Starting with min,
the queue Q collects the interpretations to which all irredundant generators will be applied
to yield new symmetric interpretations. The while-loop at line 7 checks whether there is
an interpretation, T , left to pop. Then, if T is greater than min (according to the applied
atom ordering criterion), it constitutes a negative example, while a smaller T is taken as
new smallest interpretation and the previous min instead becomes a negative example. Only
after the cell has been completely explored, the interpretation min is eventually labeled as
a positive example. Lastly, before querying cnt for the next solution, we eliminate answer
sets subsumed by the explored interpretations in seen from the search space of cnt.

4.3 ILP Learning Task

After considering the example generation, we specify components of the ILP learning task
suitable for the learning of constraints. The idea is to encode the predicates used by lex-
leader symmetry breaking to order atoms and extract the maximal values for domain predi-
cates. Since the mode declarations of ILASP (v4.0.0) do not support arithmetic built-ins such
as <, we provide auxiliary predicates in ABK to simulate them. Presupposing the presence

Lifting Symmetry Breaking Constraints with Inductive Logic Programming

13

of unary domain predicates p1, . . . , pk with integers from 1 to ci for each pi, ABK deﬁnes
the auxiliary predicates maxpi(ci) for each pi and lessThan(t1,t2) for each pair of in-
tegers 1 ≤ t1 < t2 ≤ max{ci | i = 1, . . . , k}. These two predicates, based exclusively
on syntactic properties of a considered problem, are minimal for overcoming limitations
of ILASP to learn lex-leader SBCs. The selection of small yet representative instances for
S and Gen depends on their hardness for learning. Regarding S, we pursued the strategy
to empirically determine instances for which SBASS yields a manageable number of per-
mutation group generators. As mentioned in Section 4.2, the irredundant generators alone
sometimes achieve partial symmetry breaking, and we selected only instances without any
or a small amount of “misclassiﬁed” answer sets. The instances in Gen are usually larger
yet still solvable in a short running time to check that the learned constraints generalize.

The language bias of our learning task includes the mode declarations #modeb(2,
pi(var(ti))) and #modeb(1,maxpi(var(ti))) for each domain predicate pi, in which
var(ti) is a placeholder indicating the domain for which each pi holds. Moreover, for each
(non-auxiliary) predicate P appearing in some of the generators computed for instances in S,
we use #modeb(2,P), where the domains of variables in atoms of P are provided by a vec-
tor of the placeholders in {var(ti) | i = 1, . . . , k}, depending on the role of P in the given
program P . In addition, we include mode declarations #modeb(2,lessThan(var(ti ),
var(tj))) for all i, j = 1, . . . , k, with the option anti reflexive in case i = j.

We decided to distinguish the variables’ types in the mode declarations in order to re-
strict the hypothesis space to rules such that a variable X of type t is included as an argument
only in predicates deﬁned over the same type t. To illustrate how this decision inﬂuences
the search space of an ILP task, let us consider two extensions of the pigeon-hole problem
introduced in Example 3, adding color and owner assignments. The pigeon-hole problem
with colors associates a color with each pigeon and requires pigeons placed into neighbor-
ing holes to be of the same color. The version with colors and owners additionally assigns an
owner to each pigeon and imposes the same constraint as with the colors for owners as well.
For the pigeon-hole problem with colors, by using typed variables in the mode declarations,
ILASP generates a search space of 1837 rules,3 while 9169 rules are obtained without distin-
guishing variables’ types. Regarding the extension to owners, this difference is even larger:
2895 rules using typed variables versus 21406 rules without distinguishing variables’ types.
To compare the learning performance of ILASP, we conducted several experiments on
the pigeon-hole problem with colors and owners for a pool of instances4 and observed that
applying our approach with typed variables in the mode declarations allows for learning
constraints quicker than without distinguishing the types. When using the iterative approach
described in Section 4.4, ILASP took on average less than two minutes to learn the shortest
constraints related to holes, colors, and owners, and always ﬁnished in less than ten minutes.
In opposite, a similar ILP task deﬁned without distinction of variable types took on average
thirty minutes, with cases where no hypothesis was found within an hour.

Reducing the hypothesis space has the potential drawback of learning less efﬁcient rules
since there can be situations where stronger constraints with fewer variables are excluded.
For instance, a constraint like :- pigeon(X), not p2h(X,X). cannot be learned in
the current setting, as the variable X is taken for a pigeon and a hole at the same time. How-
ever, we decided to use the restricted search space for our experiments in Section 6 because
it leads to much better scalability of learning and constraints that still improve the solving

3For all our experiments, we used the default value (3 literals) for the ILASP parameter that deﬁnes the

maximum number of literals that can occur together in the body of each rule of the hypothesis.

4The collected data can be found at [31]. The experiments were run on an Intel® i7-3930K machine

under Linux (Debian GNU/Linux 10), where each run of ILASP4 was limited to 3600 seconds.

14

Alice Tarzariol et al.

performance. In fact, the ability to learn constraints in acceptable time is important for han-
dling application scenarios better than with instance-speciﬁc symmetry breaking methods.

Example 6 To illustrate a feasible outcome of our ILP framework, let us inspect the con-
straints learned for the pigeon-hole problem and its instance with three pigeons and three
holes, as also considered in Example 3. Applying the generators returned by SBASS to the
six answer sets gives one positive and ﬁve negative examples, and the resulting ILP task is
as follows:

%% Input encoding adapted for ILASP
pigeon(X-1) :- pigeon(X), X > 1.
hole(X-1) :- hole(X), X > 1.
0 {p2h(P,H)} 1 :- pigeon(P), hole(H).
:- p2h(P1,H), p2h(P2,H), P1 < P2.
:- p2h(P,H1), p2h(P,H2), H1 < H2.
:- pigeon(P), not p2h(P,_).

%% Active Background Knowledge
lessThan(X,Y) :- pigeon(X), pigeon(Y), X < Y.
lessThan(X,Y) :- hole(X), hole(Y), X < Y.
maxpigeon(X) :- pigeon(X), not pigeon(X+1).
maxhole(X) :- hole(X), not hole(X+1).

%% Negative examples
#neg(id1@100, {p2h(2,3), p2h(1,2), p2h(3,1)},

{p2h(2,1), p2h(1,1), p2h(3,3), p2h(1,3), p2h(3,2), p2h(2,2)},
{pigeon(3). hole(3).}).

#neg(id3@100, {p2h(2,1), p2h(3,2), p2h(1,3)},

{p2h(1,1), p2h(3,3), p2h(3,1), p2h(2,2), p2h(2,3), p2h(1,2)},
{pigeon(3). hole(3).}).

#neg(id4@100, {p2h(2,3), p2h(1,1), p2h(3,2)},

{p2h(2,1), p2h(3,3), p2h(3,1), p2h(1,3), p2h(2,2), p2h(1,2)},
{pigeon(3). hole(3).}).

#neg(id5@100, {p2h(2,1), p2h(3,3), p2h(1,2)},

{p2h(1,1), p2h(3,1), p2h(1,3), p2h(3,2), p2h(2,3), p2h(2,2)},
{pigeon(3). hole(3).}).

#neg(id6@100, {p2h(1,1), p2h(3,3), p2h(2,2)},

{p2h(2,1), p2h(3,1), p2h(1,3), p2h(3,2), p2h(2,3), p2h(1,2)},
{pigeon(3). hole(3).}).

%% Positive example produced with enum setting
#pos(id2, {p2h(3,1), p2h(2,2), p2h(1,3)}, {},

{pigeon(3). hole(3).}).

%% Language bias
#modeb(2,p2h(var(pigeon),var(hole))).
#modeb(2,pigeon(var(pigeon))).
#modeb(2,hole(var(hole))).
#modeb(1,maxhole(var(hole))).
#modeb(1,maxpigeon(var(pigeon))).
#modeb(2,lessThan(var(hole),var(hole)),(anti_reflexive)).
#modeb(2,lessThan(var(pigeon),var(pigeon)),(anti_reflexive)).
#modeb(2,lessThan(var(hole),var(pigeon))).
#modeb(2,lessThan(var(pigeon),var(hole))).

Let us notice that the ASP input encoding in Example 3 has been adapted into an equivalent
one above. Such a modiﬁcation is necessary because the current version of ILASP does not
support rules like {p2h(P,H) : hole(H)} = 1 :- pigeon(P). with the condi-
tional operator “:” in the head. After running ILASP, the learned ﬁrst-order constraints are:

Lifting Symmetry Breaking Constraints with Inductive Logic Programming

15

:- p2h(X,Y), lessThan(Z,Y), maxpigeon(X).

% do not assign the pigeon with the max label to a hole
% other than the first one

:- p2h(X,Y), lessThan(X,Y), lessThan(Y,Z).

% for all but the last hole, do not assign a pigeon with
% a smaller label to the hole

4.4 Iterative Learning

Inspired by the lifelong learning approach [4], we apply our framework incrementally to a
split learning task. This idea is especially useful if the ASP encoding presents several sym-
metries, where some of them are independent of the others. The iterative approach simpliﬁes
the learning task by exploiting the incremental applicability of ILP: ﬁrst, it solves a subtask
to identify a subset of symmetries, and before addressing the remaining ones, we integrate
the constraints just learned into the background knowledge. To this end, we divide the hy-
pothesis space for programs with three or more types of variables in the language bias. Then,
in the ﬁrst step, we provide a set S of instances to address their symmetries involving only
two types of variables and deﬁne the search space with mode declarations restricted to the
two types of variables considered. Next, we solve the ILP subtask and append the learned
constraints to ABK . In the following steps, we repeat the procedure and analyze the same or
different instances in S for symmetries going beyond those already handled by solving ILP
subtasks with the mode declarations progressively extended to further types of variables.

To illustrate a concrete application scenario, reconsider the pigeon-hole problem with
color and owner assignments, introduced in Section 4.3. For this problem, the search space
is split into three incremental parts:

– the ﬁrst is limited to predicates whose atoms exclusively include variables of the types

pigeon and hole,

– the second part extends mode declarations by allowing atoms with variables of the type

color too, and, ﬁnally,

– the third step includes variables of the type owners.

Initially, S contains instances with only one color and owner so that our framework pro-
duces examples entailing symmetries related exclusively to the pigeons’ placement. Next,
we append the learned constraints to ABK and repeat the procedure by redeﬁning S with
instances with one owner but more than one color. Lastly, we analyze instances in S with-
out restrictions on the numbers of colors and owners while considering the whole language
bias. In this way, ILASP can learn new symmetries using predicates that involve more types
of variables, as the language bias is progressively extended until it reaches the whole set of
mode declarations.

By applying the iterative approach, the learning task can be decomposed into smaller
and easier ILP subtasks. For an indication of the practical impact on the size of the search
space(s), we note that ILASP generates 1040 rules for variables of the types pigeon and
hole only, 1837 rules when variables of the type color are added, and 2895 rules with the
full language bias for the pigeon-hole problem with colors and owners. That is, the search
space for the ILP subtask in the last iteration includes the same rules as generated when
addressing the full language bias in a single step, yet the background knowledge may already
be extended by constraints reducing the number of (negative) examples still to investigate.

16

Alice Tarzariol et al.

We assessed the impact of the iterative approach in several experiments4 and observed that
it allows us to learn constraints much quicker than when tackling all symmetries in a single
pass. By splitting the learning task, ILASP took on average less than two minutes to learn
constraints related to pigeons and holes, then colors, and ﬁnally owner assignments. Unlike
that, the ILP task that addresses the full language bias directly took on average more than
thirty minutes to return the shortest hypothesis, where in some cases the search was not
ﬁnished within one hour.

Splitting the learning task has the potential drawback that some of the symmetries can
be lost in the process, as the updated ABK is considered in subsequent calls to SBASS for
identifying remaining symmetries. However, for the combinatorial problems investigated
in our experiments in Section 6, the results showed that even in case we learn constraints
handling a subset of all problem symmetries, the solving performance beneﬁts substantially.

5 Learning Performance

We tested the different settings of our implementation over the two extensions of the pigeon-
hole problem described in Section 4.3. For every setting, we used the same initial set of
instances in Gen, auxiliary constraints in ABK , and mode declarations in the language
bias (split to apply the iterative approach). For keeping the number of instances in Gen
moderate, we hand-picked a few (satisﬁable) instances to start from, applied our iterative
learning approach, and then validated the learned constraints on other satisﬁable instances
as well. The instances for which learned constraints led to unsatisﬁability were then also
added to Gen, and we repeated the learning phase until all instances were found satisﬁable
together with the learned ﬁrst-order SBCs.

In the following, we report representative results and conclusions drawn from the in-

stances and records of learning experiments provided in our repository [31].

5.1 Enum vs Sat Setting

The difference between the enum and sat setting lies in the positive examples generated
for the instances in S: in the ﬁrst setting, we explicitly list all undominated answer sets as
positive examples, while the second produces just a general positive example with empty
inclusions and exclusions. That is, the sat setting abstracts over undominated answer sets,
as they are neither labeled as positive nor negative examples in the ILP task. In this case,
ILASP aims at eliminating as many symmetric answer sets as possible while preserving the
satisﬁability of a given instance. This even means that the preserved answer sets, required in
view of the general positive example, might belong to negative examples but are not covered
by the learned constraints. In this way, we may, in general, learn alternative constraints that
preserve some speciﬁc pattern of solutions appearing in all satisﬁable instances, regardless
of symmetries, while representative solutions can be lost.

For example, in the ﬁrst ILP iteration on the pigeon-hole problem with colors and own-
ers, the instance with three pigeons and four holes (and only one color and owner) gives 24
answer sets, 22 of which are labeled as negative. In the enum setting, ILASP ﬁnds optimal
constraints removing 12 negative examples and thus returns a hypothesis that applied to the
same instance leaves 12 answer sets. In contrast, the sat setting enables learning of stronger
constraints by ILASP, which preserve 2 answer sets only, both labeled as negative examples.

Lifting Symmetry Breaking Constraints with Inductive Logic Programming

17

The complexity of the ILP task depends on the possibility of covering all negative
examples. Since with enum we have tighter conditions on the candidate hypotheses, the
search space is smaller than in the sat setting. Hence, the optimization problem regarding
(weighted) negative examples addressed by ILASP takes in general longer for sat, but only if
many negative examples cannot be covered even under relaxed conditions on the candidate
hypotheses. On the other hand, if the language bias permits many hypotheses covering all
or most of the negative examples, an ILP task is usually quickly solved with the sat setting.
E.g., the instance with three pigeons, four holes, one color and owner took 72.8 seconds
to be solved in the enum (eliminating 12 out of 22 symmetric answer sets) and just 27.7
seconds in the sat setting (eliminating 20 symmetric answer sets and the 2 unlabeled ones).

5.2 Alternative Atom Ordering

When answer sets for the combinatorial problem analyzed have the property described in
Section 4.1, our alternative ordering criterion for the lex-leader scheme may distinguish
the representative and symmetric solutions. Hence, ILP tasks can be solved with shorter
constraints than for the default atom ordering. For instance, the setting illustrated in Exam-
ple 6 yields the representative answer set {p2h(1,1),p2h(2,2),p2h(3,3)} instead
of {p2h(1,3),p2h(2,2),p2h(3,1)}. This allows ILASP to learn the short constraint
:- p2h(X,Y), lessThan(Y,X)., expressing that no pigeon can be placed into a hole
smaller than its label, which leaves just one answer set for instances with an equal number
p = h of pigeons and holes.

Given that the positive examples kept after checking direct applications of the irredun-
dant generators returned by SBASS heavily depend on the computed generators, we found
that often more positive examples are produced than for the default atom ordering. Namely,
the generators preserve more symmetric solutions than the default ordering for the exten-
sions of the pigeon-hole problem to colors as well as colors and owners. This leads to weaker
(although shorter and easier to interpret) constraints, and better-suited ways of aligning gen-
erators with symbolic atom representations would be of interest.

5.3 Exploiting Generators for Full Symmetry Breaking

Section 4.2 describes an alternative implementation for labeling answer sets as positive or
negative examples, called the fullSBCs setting. We can see the effects of always labeling
the answer sets according to full SBCs on the same scenario as discussed in Section 5.1:
instead of 22 negative and 2 positive examples generated with the enum setting, fullSBCs
returns just one positive example, i.e., the representative of the single cell characterized by
the generators of SBASS. As a consequence, instead of 72.8 seconds to return a hypothesis
that produces 12 of the original 24 answer sets, with the ILP task deﬁned based on fullSBCs,
ILASP took 21.4 seconds to ﬁnd a hypothesis that preserves only 4 answer sets.

We note that reducing the number of examples for an ILP task generated by some of
our settings has a limited impact on ILASP, as its latest versions implement mechanisms to
scale with respect to the number of examples [19; 16]. However, for instances with many
answer sets, the fullSBCs approach can be helpful because equivalent answer sets need not
be exhaustively computed by CLINGO.

18

Alice Tarzariol et al.

p50-h49
p50-h50
p100-h99
p100-h100
p200-h199
p200-h200
p300-h299
p300-h300
p400-h399
p400-h400

ENUM

0.092
0.080
0.635
0.707
5.602
5.772
21.606
20.824
50.054
51.144

SAT

ORD

FULL

BASE

SBASS

CLASPπ

0.092
0.080
0.715
0.627
5.861
5.907
21.166
20.629
50.202
50.439

0.084
0.073
0.640
0.574
5.192
6.004
19.162
19.477
46.937
47.718

0.091
0.082
0.715
0.622
5.656
5.627
21.963
20.631
50.482
50.255

TO
0.116
TO
1.047
TO
11.162
TO
38.723
TO
94.253

52.829
53.408
TO
TO
TO
TO
TO
TO
TO
TO

1.900
1.417
–
–
–
–
–
–
–
–

Table 1: Runtime in seconds for pigeon-hole problem.

6 Solving Experiments

To evaluate our approach and the implementation design, we applied it to a series of com-
binatorial search problems. For each considered problem, we compared the running time of
the original encoding, the version extended with our learned constraints, and the instance-
speciﬁc approach of SBASS. The learned constraints depend on the instances used in S and
Gen as well as how we apply the iterative learning approach. In the following, we report
results for the constraints with good performance learned applying the deﬁnitions of Sec-
tion 4.3.5 We ran our tests on an Intel® i7-3930K machine under Linux (Debian GNU/Linux
10), where each run was limited to 900 seconds and 20 GB of memory.

In Table 1 to Table 4, the satisﬁable instances are shown in grey rows, while the white
rows contain unsatisﬁable instances. The column BASE refers to CLINGO (v5.5.0) run on
the original encoding, while ENUM, SAT, ORD, and FULL report results for the original
encoding augmented with ﬁrst-order constraints learned in the enum, sat, and enum with
alternative atom ordering or fullSBCs setting, respectively. The time required by SBASS to
compute ground SBCs is given in the corresponding column, and CLASPπ provides the
solving time obtained with these ground SBCs. Runs that did not ﬁnish within the time limit
of 900 seconds are indicated by TO entries.

We ﬁrst tested the pigeon-hole problem, working without any division and iterative anal-
ysis of the language bias: the four learning settings led to similar performance constraints,
although the ones obtained with the alternative ordering were shorter, as mentioned in Sec-
tion 5.2. The running time comparison in Table 1 shows that all the settings of our approach
bring about a similar speedup for solving satisﬁable as well as unsatisﬁable instances. In
fact, the vast problem symmetries are cut by the learned ﬁrst-order constraints. This is par-
ticularly important in case of unsatisﬁability, where runs on the original encoding without
additional constraints do not ﬁnish within the time limit. While SBASS also manages to han-
dle the two smallest instances, the computation of permutation group generators becomes
too expensive when the instance size grows, in which case we cannot run CLASPπ with
ground SBCs from SBASS.

Next, we tested the pigeon-hole problem adding color and owner assignments. For
the pigeon-hole problem with color assignments, we divided the language bias into two
parts: the ﬁrst limiting to predicates whose atoms exclusively include variables of the types
pigeon and hole, while the second part allows variables to be of the type color too.

5Detailed settings are provided at [31].

Lifting Symmetry Breaking Constraints with Inductive Logic Programming

19

c1-p12-h11
c1-p52-h52
c2-p12-h12
c2-p52-h53
c3-p12-h13
c3-p52-h54
c4-p12-h14
c4-p52-h55
c5-p12-h15
c5-p52-h56

ENUM

1.939
0.147
6.648
0.559
4.457
4.974
4.195
3.131
5.673
18.336

SAT

0.007
0.100
0.009
0.298
0.014
0.545
0.022
0.959
0.035
1.561

ORD

FULL

BASE

SBASS

CLASPπ

0.007
0.101
0.010
0.421
0.052
1.072
3.026
2.033
138.861
581.164

0.006
0.100
0.010
0.293
0.019
0.628
0.075
3.849
0.251
11.704

692.704
0.145
TO
TO
TO
1.674
TO
TO
TO
5.930

0.284
63.455
0.092
93.870
0.228
449.324
0.479
550.065
1.020
TO

0.015
1.083
TO
TO
TO
TO
TO
TO
TO
–

Table 2: Runtime in seconds for pigeon-hole problem with colors.

o1-c3-p12-h13
o1-c3-p52-h54
o2-c3-p12-h13
o2-c3-p52-h54
o3-c1-p12-h13
o3-c1-p52-h54
o4-c4-p12-h14
o4-c4-p52-h55
o5-c5-p12-h15
o5-c5-p52-h56

ENUM

1.505
1.749
1.081
1.017
1.511
1.726
0.894
4.123
0.684
13.984

SAT

0.016
0.554
0.017
0.705
0.016
0.551
0.031
1.819
0.061
3.045

ORD

FULL

BASE

SBASS

CLASPπ

0.051
1.002
0.070
1.561
0.053
0.996
3.162
3.486
97.453
573.523

0.046
0.906
0.045
1.231
0.035
0.903
1.114
3.546
21.272
200.467

TO
1.709
TO
TO
TO
1.698
TO
6.653
TO
11.622

0.204
312.328
0.337
542.377
0.21
313.062
1.102
TO
2.093
TO

TO
TO
TO
TO
TO
TO
TO
-
TO
-

Table 3: Runtime in seconds for pigeon-hole problem with colors and owners.

Likewise, the problem version with owners and colors required a third language bias ex-
tension to variables of the type owner. For both extensions of the pigeon-hole problem,
the ﬁrst-order constraints learned in sat turned out to be stronger than in the other settings.
Nevertheless, all kinds of constraints helped to improve the search for solutions. Table 2 and
Table 3 show similar results: the constraints learned with the sat setting lead to the fastest
running times for both satisﬁable and unsatisﬁable instances. The constraints learned with
enum using the alternative ordering are shorter and easier to read than the other settings, but
sightly less efﬁcient since they break only a subset of all symmetries. In Table 2, the time
took for identifying satisﬁable and unsatisﬁable instances is lower if we use the constraints
learned with fullSBCs than those learned with enum; on the other hand, in Table 3, we ob-
serve the opposite behavior, especially for the last instances: for the pigeon-hole problem
with colors and owners, we could have learned the same constraints in both settings because
to obtain the constraints with enum, we used instances that identify full SBCs. However, we
tested a different set of rules for fullSBCs since they were stricter than enum, concerning
the pigeons’ placement symmetries. Indeed, the ﬁrst unsatisﬁable instance with one color
and owner was solved earlier by the constraint of fullSBCs. Lastly, for small unsatisﬁable
instances, the ground SBCs from SBASS lead to better performance than the constraints
learned with the enum setting. However, as soon as the color (or owner) dimension grows,
the runs of CLASPπ reach the timeout. This behavior is due to the redundancy of the ground
SBCs, which slow down the search instead of facilitating it. For some of the satisﬁable in-
stances, ﬁnding a solution with the constraints learned in enum takes longer than with the
original encoding alone. Nevertheless, the latter also has timeouts that do not occur with our
learned ﬁrst-order constraints.

20

Alice Tarzariol et al.

p2-c6-t13
p2-c80-t160
p3-c6-t13
p3-c80-t160
p4-c6-t13
p4-c80-t160
p5-c6-t13
p5-c80-t160
p4-c7-t15
p15-c15-t30

ENUM

0.337
4.928
0.342
13.682
0.420
27.437
0.418
48.057
13.263
5.655

SAT

ORD

FULL

BASE

SBASS

CLASPπ

0.025
5.001
0.031
14.315
0.035
28.866
0.042
49.382
0.335
6.777

0.097
5.166
0.093
15.174
0.102
28.145
0.101
48.598
1.524
2.700

0.329
5.024
0.424
14.110
0.349
27.299
0.397
49.645
14.229
2.525

219.753
6.583
254.065
20.724
221.784
40.121
236.961
68.167
TO
4.155

0.095
TO
0.242
TO
0.453
TO
0.890
TO
0.729
TO

12.951
–
73.041
–
105.145
–
405.461
–
TO
–

Table 4: Runtime in seconds for house-conﬁguration problem.

To conclude, we applied the different settings of our approach to the house-conﬁguration
problem [13], which consists of assigning t things of p persons to c cabinets, where each
cabinet has a capacity limit of two things that must belong to the same owner. Similarly to
the pigeon-hole problem with color, we divided the language bias into two parts: the ﬁrst
limiting to predicates whose atoms exclusively include variables of the types cabinet
and thing, while the second part allows variables to be of the type person too. The
running times in Table 4 exhibit the same trend as observed on the previous problems that
our ﬁrst-order constraints help the search, especially those learned with the sat setting. For
this problem, the constraints learned with the enum setting, the alternative ordering, and
exploiting the full SBCs show similar performances. In some cases, the original encoding is
quicker to solve satisﬁable instances, although it takes considerably longer for unsatisﬁable
ones. On the other hand, SBASS brings a moderate speedup for unsatisﬁable instances, but
its performance suffers a lot when the problem size grows.

7 Conclusions

This paper introduces methods to lift the SBCs of combinatorial problem encodings in
ASP for a target distribution of instances. Our framework addresses the limitations of com-
mon instance-speciﬁc approaches, like SBASS, since: (i) the knowledge is transferable, as
learned constraints preserve the satisﬁability for the considered instance distribution; (ii) the
ﬁrst-order constraints are easier to interpret than ground SBCs; (iii) the SBCs are com-
puted ofﬂine, allowing for addressing large-scale instances, as shown in our experiments;
and (iv) the learned constraints are non-redundant, avoiding performance degradation due
to an excessive ground representation size. In the current implementation of our approach,
ILASP learns shortest constraints that cover as many examples as possible, while there is no
distinction regarding the solving performance of candidate hypotheses. Despite this, our ex-
periments showed that the learned constraints signiﬁcantly improve the solving performance
on the analyzed problems. Moreover, the two example generation methods suggested in this
work allowed for ILP tasks with (i) fewer positive examples and (ii) shorter learned con-
straints, in comparison to the two methods of our previous paper [32]. These results are due
to the full symmetry breaking when enumerating all answer sets with the fullSBCs approach
or an alternative atom ordering for the lex-leader scheme, respectively.

Nevertheless, there are still some limitations in the usability of our framework, which
partially go back to the components used in our current implementation, i.e., SBASS, CLINGO,

Lifting Symmetry Breaking Constraints with Inductive Logic Programming

21

and ILASP. The SBASS tool does not support ASP programs with weak constraints [1], whose
implementation is out of the scope of this work. However, extensions of instance-speciﬁc
symmetry detection and model-oriented symmetry breaking to optimization problems are
undoubtedly worthwhile. Optimization involves solving unsatisﬁable subproblem(s) attempt-
ing (and failing) to improve an optimal answer set, where symmetry breaking is particularly
crucial for performance. Concerning CLINGO, if a given encoding P leads to large ground in-
stantiations, the addition of learned constraints does not reduce the size. Therefore, it would
be desirable to directly incorporate the information about redundant answer sets into a mod-
iﬁed encoding. For instance, for the pigeon-hole problem, this might prevent our method
from even generating ground atoms representing the placement of a pigeon into some hole
with a greater label. Lastly, ILASP does currently not scale well with respect to the size of
the hypothesis space spanned by the language bias, which is a well-known issue tackled by
next-generation ILP systems under development [17; 22].

At present, the successful application of our framework relies on the following charac-
teristics of a combinatorial problem: (i) we can easily provide simple instances (i.e., the total
number of solutions can be managed by our implementation) that entail the symmetries of
the whole instance distribution; (ii) the object domains can be expressed in terms of unary
predicates that hold for a range of consecutive integers; and (iii) the auxiliary predicate def-
initions suggested for ABK in Section 4.3 enable the learning of constraints that improve
the solving performance. In particular, if it gets difﬁcult to compute solutions for an instance
in S to analyze, the formulation of an ILP task to learn constraints can become prohibitive.
In the future, we aim to investigate whether the learning of SBCs can be readily applied
or further adapted to advanced industrial conﬁguration problems, such as the Partner Units
Problem [9], as well as complex combinatorial problems with speciﬁc instance distributions,
like the labeling of Graceful Graphs [27]. For such application scenarios, the language bias
may be enriched, possibly extending the background knowledge with additional predicates
characterizing the structure of instances. Moreover, for problem instances that yield a vast
number of solutions, we can take advantage of the incremental implementation of the full-
SBCs approach to limit the number of answer sets to consider as examples for an ILP task.
Lastly, we intend to develop automatic mechanisms to select suitable instances for S and
Gen from instance collections, support lifelong learning, and further optimize the ground-
ing and solving efﬁciency of learned constraints.

Acknowledgments. This work was partially funded by KWF project 28472, cms electronics
GmbH, FunderMax GmbH, Hirsch Armb¨ander GmbH, incubed IT GmbH, Inﬁneon Tech-
nologies Austria AG, Isovolta AG, Kostwein Holding GmbH, and Privatstiftung K¨arntner
Sparkasse. We thank the anonymous reviewers for their helpful and constructive comments.

References

[1] Calimeri, F., Faber, W., Gebser, M., Ianni, G., Kaminski, R., Krennwallner, T., Leone, N., Maratea, M.,
Ricca, F., Schaub, T.: ASP-Core-2 input language format. Theory and Practice of Logic Programming
20(2), 294–309 (2019)

[2] Codenotti, P., Katebi, H., Sakallah, K., Markov, I.: Conﬂict analysis and branching heuristics in the
search for graph automorphisms. In: 25th IEEE International Conference on Tools with Artiﬁcial Intel-
ligence, pp. 907–914. IEEE Computer Society (2013)

[3] Cohen, D., Jeavons, P., Jefferson, C., Petrie, K., Smith, B.: Symmetry deﬁnitions for constraint satisfac-

tion problems. Constraints 11(2-3), 115–137 (2006)

[4] Cropper, A., Dumanˇci´c, S., Muggleton, S.: Turning 30: New ideas in inductive logic programming. In:

29th International Joint Conference on Artiﬁcial Intelligence, pp. 4833–4839. ijcai.org (2020)

22

Alice Tarzariol et al.

[5] Cropper, A., Dumanˇci´c, S.: Inductive logic programming at 30: A new introduction (2020). URL

https://arxiv.org/abs/2008.07912

[6] Cropper, A., Muggleton, S.: Metagol (2016). URL https://github.com/metagol/metagol
[7] Darga, P., Katebi, H., Lifﬁton, M., Markov,

I., Sakallah, K.: Saucy (2004).

URL

http://vlsicad.eecs.umich.edu/BK/SAUCY/

[8] Devriendt, J., Bogaerts, B., Bruynooghe, M., Denecker, M.: On local domain symmetry for model

expansion. Theory and Practice of Logic Programming 16(5-6), 636–652 (2016)

[9] Dodaro, C., Gasteiger, P., Leone, N., Musitsch, B., Ricca, F., Schekotihin, K.: Combining answer set
programming and domain heuristics for solving hard industrial problems. Theory and Practice of Logic
Programming 16(5-6), 653–669 (2016)

[10] Drescher, C., Tifrea, O., Walsh, T.: Symmetry-breaking answer set solving. AI Communications 24(2),

177–194 (2011)

[11] Erdem, E., Gelfond, M., Leone, N.: Applications of ASP. AI Magazine 37(3), 53–68 (2016)
[12] Falkner, A., Friedrich, G., Schekotihin, K., Taupe, R., Teppan, E.: Industrial applications of answer set

programming. K¨unstliche Intelligenz 32(2-3), 165–176 (2018)

[13] Friedrich, G., Ryabokon, A., Falkner, A., Haselb¨ock, A., Schenner, G., Schreiner, H.: (Re)conﬁguration
using answer set programming. In: IJCAI 2011 Workshop on Conﬁguration, pp. 17–24. CEUR-WS.org
(2011)

[14] Gebser, M., Kaminski, R., Kaufmann, B., Schaub, T.: Answer Set Solving in Practice. Morgan and

Claypool Publishers (2012)

[15] Gelfond, M., Lifschitz, V.: Classical negation in logic programs and disjunctive databases. New Gener-

ation Computing 9, 365–385 (1991)

[16] Law, M.: Conﬂict-driven inductive logic programming (2021). URL https://arxiv.org/abs/2101.00058
[17] Law, M., Russo, A., Bertino, E., Broda, K., Lobo, J.: FastLAS: Scalable inductive logic programming
incorporating domain-speciﬁc optimisation criteria. In: 34th National Conference on Artiﬁcial Intelli-
gence, pp. 2877–2885. AAAI Press (2020)

[18] Law, M., Russo, A., Broda, K.: Inductive learning of answer set programs. In: 14th European Confer-

ence on Logics in Artiﬁcial Intelligence, pp. 311–325. Springer-Verlag (2014)

[19] Law, M., Russo, A., Broda, K.: Iterative learning of answer set programs from context dependent ex-

amples. Theory and Practice of Logic Programming 16(5-6), 834–848 (2016)

[20] Law, M., Russo, A., Broda, K.: Inductive learning of answer set programs from noisy examples. Ad-

vances in Cognitive Systems 7, 57–76 (2018)

[21] Law, M., Russo, A., Broda, K.: Ilasp (2021). URL http://www.ilasp.com
[22] Law, M., Russo, A., Broda, K., Bertino, E.: Scalable non-observational predicate learning in ASP. In:

30th International Joint Conference on Artiﬁcial Intelligence, pp. 1936–1943. ijcai.org (2021)

[23] Lifschitz, V.: Answer Set Programming. Springer-Verlag (2019)
[24] Margot, F.: Symmetry in integer linear programming. In: 50 Years of Integer Programming 1958–2008,

pp. 647–686. Springer-Verlag (2010)

[25] Mears, C., Garc´ıa de la Banda, M., Wallace, M., Demoen, B.: A novel approach for detecting sym-
metries in CSP models.
In: 5th International Conference on Integration of AI and OR Techniques
in Constraint Programming for Combinatorial Optimization Problems, pp. 158–172. Springer-Verlag
(2008)

[26] Muggleton, S.: Inverse entailment and Progol. New Generation Computing 13(3-4), 245–286 (1995)
[27] Petrie, K., Smith, B.: Symmetry breaking in graceful graphs. In: 9th International Conference on Prin-

ciples and Practice of Constraint Programming, pp. 930–934. Springer-Verlag (2003)

[28] Puget, J.: Automatic detection of variable and value symmetries. In: 11th International Conference on

Principles and Practice of Constraint Programming, pp. 475–489. Springer-Verlag (2005)

[29] Sakallah, K.: Symmetry and satisﬁability. In: Handbook of Satisﬁability, pp. 289–338. IOS Press (2009)
[30] Srinivasan, A.: The Aleph manual (2004). URL https://www.cs.ox.ac.uk/activities/programinduction/Aleph/
[31] Tarzariol, A., Gebser, M., Schekotihin, K.:

ILP symmetry breaking

(2021).

URL

https://github.com/prosysscience/Symmetry Breaking with ILP/tree/extended

[32] Tarzariol, A., Gebser, M., Schekotihin, K.: Lifting symmetry breaking constraints with inductive logic
In: 30th International Joint Conference on Artiﬁcial Intelligence, pp. 2062–2068. ij-

programming.
cai.org (2021)

[33] Walsh, T.: Symmetry breaking constraints: Recent results. In: 26th National Conference on Artiﬁcial

Intelligence, pp. 2192–2198. AAAI Press (2012)

