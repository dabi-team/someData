1
2
0
2

l
u
J

2

]

O
L
.
s
c
[

1
v
5
5
1
1
0
.
7
0
1
2
:
v
i
X
r
a

Higher-order probabilistic adversarial computations:
Categorical semantics and program logics

ALEJANDRO AGUIRRE‚àó, Aarhus University, Denmark
GILLES BARTHE, MPI-SP, Germany and IMDEA Software Institute, Spain
MARCO GABOARDI, Boston University, USA
DEEPAK GARG, Max Planck Institute for Software Systems, Germany
SHIN-YA KATSUMATA, National Institute of Informatics, Japan
TETSUYA SATO, Tokyo Institute of Technology, Japan

Adversarial computations are a widely studied class of computations where resource-bounded probabilistic
adversaries have access to oracles, i.e., probabilistic procedures with private state. These computations arise
routinely in several domains, including security, privacy and machine learning.

In this paper, we develop program logics for reasoning about adversarial computations in a higher-order
setting. Our logics are built on top of a simply typed ùúÜ-calculus extended with a graded monad for prob-
abilities and state. The grading is used to model and restrict the memory footprint and the cost (in terms
of oracle calls) of computations. Under this view, an adversary is a higher-order expression that expects as
arguments the code of its oracles. We develop unary program logics for reasoning about error probabilities
and expected values, and a relational logic for reasoning about coupling-based properties. All logics feature
rules for adversarial computations, and yield guarantees that are valid for all adversaries that satisfy a Ô¨Åxed
resource policy. We prove the soundness of the logics in the category of quasi-Borel spaces, using a general
notion of graded predicate liftings, and we use logical relations over graded predicate liftings to establish the
soundness of proof rules for adversaries. We illustrate the working of our logics with simple but illustrative
examples.

ACM Reference Format:
Alejandro Aguirre, Gilles Barthe, Marco Gaboardi, Deepak Garg, Shin-ya Katsumata, and Tetsuya Sato. 2021.
Higher-order probabilistic adversarial computations: Categorical semantics and program logics. Proc. ACM
Program. Lang. 5, ICFP, Article 93 (August 2021), 43 pages. https://doi.org/10.1145/3473598

93

1 INTRODUCTION

Probabilistic programs occur widely in privacy, security, and other domains where formal guar-
antees are required. These guarantees are often expressed using expectations, e.g, one may want
to prove that the expected value of a randomized algorithm remains close to some deterministic

‚àóThis research was carried out while the Ô¨Årst author was aÔ¨Éliated to the IMDEA Software Institute and Universidad
Polit√©cnica de Madrid

Authors‚Äô addresses: Alejandro Aguirre, Aarhus University, Denmark, alejandro@cs.au.dk; Gilles Barthe, MPI-SP, Germany
, IMDEA Software Institute, Spain, gbarthe@mpi-sp.org; Marco Gaboardi, Boston University, USA, gaboardi@bu.edu;
Deepak Garg, Max Planck Institute for Software Systems, Germany, dg@mpi-sws.org; Shin-ya Katsumata, National Insti-
tute of Informatics, 2-1-2 Hitotsubashi, Chiyoda-ku, Tokyo, 101-8430, Japan, s-katsumata@nii.ac.jp; Tetsuya Sato, Tokyo
Institute of Technology, Japan, tsato@c.titech.ac.jp.

Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for proÔ¨Åt or commercial advantage and that copies bear this notice and
the full citation on the Ô¨Årst page. Copyrights for third-party components of this work must be honored. For all other uses,
contact the owner/author(s).
¬© 2021 Copyright held by the owner/author(s).
2475-1421/2021/8-ART93
https://doi.org/10.1145/3473598

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

 
 
 
 
 
 
93:2

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

function of its input. This can be established by means of expectation-based methods that orig-
inate from the works of Kozen [1985] and of Morgan et al. [1996]. Another class of guarantees
is concerned with proving the probability of events; e.g., one may want to prove that a random-
ized algorithm has a small probability of returning an incorrect answer, or more generally that
there is a small probability that a bad event happens. These kinds of properties are the target of
so-called Boolean-based methods, such as the union bound logic proposed by [Barthe et al. 2016b].
These two approaches are traditionally used to reason about properties concerning a single pro-
gram execution. However, many security and privacy properties are naturally expressed by relat-
ing two program executions; we call such properties relational properties. Relational counterparts
to expectation-based and Boolean-based methods have been proposed, including the relational
expectation-based logic of Barthe et al. [2018], and probabilistic relational Hoare logic [Barthe et al.
2009].

Some of these logics additionally support reasoning about adversarial computations, where resource-

bounded but otherwise unconstrained adversaries interact with oracles, i.e. probabilistic proce-
dures with private state. These logics view adversaries as uninterpreted procedures, and restrict
their power by adding constraints on the memory they can read and write, and on the number of
times they can call other procedures. These constraints are captured by a notion of valid adversary,
and it is reasonably simple to deÔ¨Åne proof rules for valid adversaries. The combination of program
logics and adversary rules yield powerful frameworks that have been used to reason about many
examples, including security of cryptographic constructions [Barthe et al. 2009] and stability of
machine learning algorithms [Barthe et al. 2018].

The aforementioned works are developed on top of a core probabilistic imperative language.
However, it is often desirable to reason about higher-order programs, either because the programs
of interest are written in a higher-order language, or more fundamentally because the programs
manipulate higher-order objects. Unfortunately, program logics for higher-order probabilistic lan-
guages are not as well understood as their counterparts for imperative languages. One potential
reason for this is that denotational semantics of higher-order probabilistic programs have been
lacking. Indeed, a classic result by Aumann et al. [1961] shows that the category of Borel spaces
is not Cartesian closed, and therefore it cannot be used to interpret programs. Fortunately, recent
works propose elegant semantics for higher-order probabilistic programs, such as Probabilistic Co-
herent Spaces (or PCoh) [Danos and Ehrhard 2011] and Quasi-Borel Spaces (or QBS) [Heunen et al.
2017]. These semantics can be used as a basis for developing program logics, as shown for instance
by Sato et al. [2019], who develop unary and relational logics over QBS. However, reasoning in this
system is based on an axiomatization of probabilities, and is intricate. Moreover, this system does
not support reasoning about state and adversarial computations.

Goals and technical outline. In this paper we set out to develop a general framework for designing
program logics that reason about resource-constrained adversarial computations in a higher-order
probabilistic language. The reasoning principles themselves are fairly natural, and have been con-
sidered in the Ô¨Årst-order setting before [Barthe et al. 2009], but generalizing them to the higher-
order requires addressing the following challenges:

‚Ä¢ How can we enforce the restrictions on the adversaries?
‚Ä¢ Can we support relational or expectation-based logics?
‚Ä¢ How can we formalize the reasoning principles into a common set of proof rules? How can

we prove these rules sound?

‚Ä¢ How can we give a denotational model to these logics?

Program properties in an adversarial setting usually make some assumptions about adversaries
by restricting the number of times they can invoke the oracle, and denying them access to the

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:3

private state of the oracle (formally, the oracle is a function with hidden local state, passed as an
argument to the adversary). In the Ô¨Årst-order setting this is usually addressed by restricting the
syntax of adversaries in an ad-hoc manner, but for higher-order programs a more principled ap-
proach would involve using the type system to enforce these restrictions. Another idea would be
to use local state and some sort of separation logic [Tassarotti and Harper 2019], but it is not clear
how such features can be added to denotational models for higher-order probabilistic programs.
The solution we propose here Ô¨Årst involves grading a monad for global state and probabilities by
two parameters Œ£ and ùëò: Œ£ represents the memory footprint of the computation and ùëò represents
the number of oracle calls. Thus, our language has types of the form TŒ£,ùëò (ùúè) to represent compu-
tations with memory footprint Œ£ and at most ùëò oracle calls. Then, we allow quantiÔ¨Åcation over
memory grading, which can be seen as a lightweight form of polymorphism. We then model ad-
versaries as computations of second-order types, e.g. the type ‚àÄùõº.(ùúé ‚Üí Tùõº,1(ùúè)) ‚Üí TŒ£‚à™ùõº,ùëò (ùúè ‚Ä≤)
captures an adversary that has access to an oracle of type ùúé ‚Üí Tùõº,1(ùúè) and that returns values of
type ùúè ‚Ä≤. The grading ensures that the adversary can call the oracle at most ùëò times, and separation
between adversary and oracle memories is enforced by a parametricity property derived from the
quantiÔ¨Åcation in the type: the adversary can only read and write the memory region Œ£; and in
particular, it cannot access the private memory of the oracle (denoted ùõº). To our knowledge, this
is the Ô¨Årst use of this form of parametricity.

On top of this language, we develop a Boolean-based unary logic, an expectation-based unary
logic, and a Boolean-based relational logic. The Ô¨Årst of these logics can be used to reason about
the probability that the output of a program satisÔ¨Åes some assertion. Its judgments are based on
generalized Hoare triples of the form {ùúô } ùë° : TŒ£,ùúñ (ùê¥) {{ùúì }}ùõø , with the meaning that if the initial
state satisÔ¨Åes ùúô, then the Ô¨Ånal state after running ùë° satisÔ¨Åes ùúì with probability at least 1 ‚àí ùõø. The
logic‚Äôs interpretation is based on a graded monad lifting, which maps the postcondition ùúì and the
grading ùõø to an assertion over probability distributions.

Crucially, soundness of this Ô¨Årst logic does not depend on the concrete deÔ¨Ånition of the lifting,
but only on some algebraic properties of the lifting, so the logic can be generalized. We use this
observation to develop a second higher-order program logic for a completely diÔ¨Äerent purpose,
namely, proving properties of expectations, similar to Morgan et al. [1996]. In this logic, assertions
are real-valued functions, as opposed to Boolean-valued assertions of the Ô¨Årst logic. Remarkably,
most of the proof rules of the two logics are the same, thanks to the similar algebraic properties
of the underlying liftings. This shows how, by exploiting similarity in the underlying liftings, we
can get almost similar proof rules to prove completely diÔ¨Äerent properties with diÔ¨Äerent truth
values. We believe that building two diÔ¨Äerently-valued logics (real-valued and Boolean-valued)
from common rules is novel.

Our third logic is a relational logic that can be used to prove properties [Barthe et al. 2016a] of
pairs of higher-order probabilistic programs using couplings. Again, we exploit the structure of
liftings (couplings are particular cases of liftings), this time for relational reasoning.

To each of the three logics we add (structurally very similar) proof rules for reasoning about
adversaries. Adversary rules combine all of the features of our framework, and can be used to
reason about the interaction of an oracle O, whose code we know, with an adversary A of which
we only know the type. Our type system enforces that the adversary can only call the oracle at most
ùëò times and it cannot access the oracle‚Äôs private memory. The adversary rules of all three logics
have similar structure and follow the same underlying pattern: Assuming some invariant about
the oracle‚Äôs private state (which we can discharge in our logics), derive a property of any adversary
that can call the oracle at most ùëò times. For instance, in the Ô¨Årst logic above, the adversary rule
says that if the oracle preserves an invariant ùúô with probability at least 1 ‚àí ùõø, then any adversary
calling the oracle at most ùëò times preserves ùúô with probability at least 1 ‚àí ùëòùõø.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:4

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

Next, we deÔ¨Åne a semantic model for our language and the three logics. Just modeling the lan-
guage with its higher-order nature and probabilities is nontrivial as explained earlier. Concretely,
we model our language in the category QBS of Quasi-Borel spaces. We then interpret monadic
types using the monad T (‚àí) , ùëÄ ‚áí P (‚àí √ó ùëÄ) for some QBS ùëÄ of memories, where P denotes
the monad of probability measures over QBS.

Next, we wish to build a uniform framework to model our three logics, their diÔ¨Äerent notions
of truth-values, diÔ¨Äerent liftings, and both unary and relational reasoning. For this, we build our
theory using the notion of Heyting-valued predicates, which are maps from a set ùëã to a Heyting
algebra Œ©. By instantiating Œ© diÔ¨Äerently, we are able to model our diÔ¨Äerent logics. Further, to inter-
pret logics themselves we employ graded monad liftings [Katsumata 2014], which map a Heyting-
valued predicate over a set ùëã to a Heyting-valued predicate over the set of distributions over ùëã . We
also introduce a novel concept of stateful lifting, which combines graded monad liftings with the
state monad. This gives a categorical semantics of our new Hoare-triple type (c.f. [Nanevski et al.
2008]): ‚Äú{ùúô }ùë° : TŒ£,ùúñ (ùê¥){{ùúì }}ùõø ‚Äù, where ùúô,ùúì are Œ©-valued predicates, ùõø is a grading and the whole
type speciÔ¨Åes properties of probabilities of state transformers. In doing so, we carefully design a
categorical framework that uniÔ¨Åes qualitative and quantitative assertions using Heyting algebras,
and admits interpretations of the triples under a generic graded lifting. Soundness of the diÔ¨Äerent
logics follows uniformly by suitably instantiating the liftings and the Heyting algebras.

The soundness of the adversary rules needs separate proofs, since we must show that the rules
are sound for any term inhabiting the adversary‚Äôs type. This can usually be done with logical
relations, but an approach based on standard logical relations would fail here, since it would not
take into account the latent eÔ¨Äect of the types and their relation to the invariant. Therefore, we
develop a novel logical relation that is parametrized by the invariant we want to preserve, and
graded by the probability of failure.

Contributions. In summary, our contributions are the following:

‚Ä¢ We design a type system for a higher-order probabilistic language to model adversaries and
restrict their capabilities. This is achieved through the use of a monad graded by the mem-
ory footprint and the cost the computations, and exploiting parametricity over the memory
usage. This novel application of parametricity allows us to enforce a separation between the
adversary and the oracle memories in a setting with global state.

‚Ä¢ We design three unary and relational logics to reason about probabilistic programs in this
setting. We go beyond logics in which assertions are Boolean by also presenting a logic
in which assertions are real-valued functions, whose expected value the logic establishes.
Assertions in our logics are also graded, to allow us to reason about the probability of failure,
or the tightness of bounds. The logics are instances of a generic structure ‚Äì both in the proof
rules and the semantics ‚Äì showcasing the common structure behind them.

‚Ä¢ We introduce a notion of stateful lifting, which is used to interpret the triples in our judg-
ments, from which we can construct a categorical model for the rest of the framework. This
model is parametrized by a Heyting algebra of truth values and a graded lifting that inter-
prets assertions. This allows us to have a uniform categorical model which is general enough
for all the logics that we present.

‚Ä¢ We introduce rules to reason about the interaction between adversaries, from which we only
know their type, and oracles. This uses the parametricity above, to show that an invariant is
preserved, and moreover it uses the cost restriction on the adversary to compute the grading
of the interaction. Soundness of these rules follows from a novel logical relation.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:5

2 ILLUSTRATIVE EXAMPLES
We introduce two illustrative examples, which we use to motivate our modeling of adversaries,
and later to showcase the mechanics of our diÔ¨Äerent logics. Our examples are deliberately simple;
further examples are in the conclusion and the appendix.

Pollution attacks against Bloom Ô¨Ålters [Gerbet et al. 2015]. Bloom Filters [Bloom 1970] are prob-
abilistic data structures useful to represent sets eÔ¨Éciently at the cost of a loss in precision. Infor-
mally, a Bloom Filter is a data structure with two procedures: an insertion procedure for adding
a value to the current set, and a membership procedure to query whether a value belongs to the
current set. For simplicity, we assume that values are taken from the set [ùëõ] = {0, . . . , ùëõ ‚àí 1} for
some ùëõ. A Bloom Filter represents subsets of [ùëõ] as an array ùêø of bits of Ô¨Åxed size ùëö. Initially all bits
in ùêø are set to 0. The insertion procedure is parametrized by a hash function ùêª : ( [ùëõ] √ó [‚Ñì]) ‚Üí [ùëö]
sampled uniformly at random, where ‚Ñì is a parameter of the Bloom Filter. The procedure insert(ùë•)
updates to 1 the value of the array at positions ‚Ñé(ùë•, 1), . . . , ‚Ñé(ùë•, ‚Ñì). The procedure member(ùë•) com-
putes ‚Ñé(ùë•, 1), . . . , ‚Ñé(ùë•, ‚Ñì) and returns 1 if all these bits are set to 1, and 0 otherwise. The main
advantage of Bloom Filters is their space-eÔ¨Éciency over other classical data structures for sets.
But this eÔ¨Éciency comes at a price: Bloom Filters may yield false positives: a membership query
may possibly return true for a value that does not belong to the current set due to hash collisions.
Therefore, an adversary may attempt to pollute the Bloom Filter in order to trigger false posi-
tives [Gerbet et al. 2015]. In this paper, we consider a very simple form of pollution attacks, where
an adversary adaptively performs insertion queries with the goal to set to 1 a maximal number of
bits of the Bloom Filter. Since the adversary is probabilistic, we use the expected number of bits
set to 1 as a measure of the adversary‚Äôs success. Assuming that the Bloom Filter is initially empty,
i.e. all bits are set to 0, one can prove that for every adversary A making at most ùëò queries to the
insertion oracle, the expected number of bits set to 1 after the adversary returns is upper bounded
by ùëö ¬∑ (1 ‚àí ((ùëö ‚àí 1)/ùëö)‚Ñì ¬∑ùëò).

We model this example in a simply typed calculus enriched with graded monadic type con-
structors. Concretely, we model adversaries carrying a pollution attack against a Bloom Filter as
computations A of type ‚àÄùõº.( [ùëõ] ‚Üí Tùõº,1(U)) ‚Üí Tùõº ‚à™Œ£,ùëò (U) where U is the unit type and by abuse
of notation we view [ùëõ] as a type. The intended argument of the adversary is the insertion oracle.
The monadic type Tùõº,1(ùúè) should be seen as stateful probabilistic computations that can read and
write to the set of locations ùõº (but not others) and have cost 1. Therefore, the grading ensures
that each oracle call has cost 1, and that the adversary can make at most ùëò calls to the oracle. The
universal quantiÔ¨Åcation on ùõº ensures that the adversary can only read and write locations in Œ£,
and that its eÔ¨Äect on other memory locations like the ùêø[ùëñ]s is only indirect, through calls to its
oracle.

We assume that hash functions are implemented as random oracles, i.e. stateful probabilistic
functions that lazily sample their output when queried with a fresh input. The pseudo-code of the
insertion oracle insert is deferred to Section 4.2. Under this modeling we upper bound the success
of pollution attacks via the judgment:

‚Ä¢ | A : ùúè | ‚Ä¢ | ‚Ä¢ ‚ä¢ {ùëö ¬∑ (1 ‚àí ((ùëö ‚àí 1)/ùëö)‚Ñì ¬∑ùëò)} A insert : TŒ£‚à™{ùëü,ùêø,‚Ñé },ùëò (U)

ùëö‚àí1
ùëñ=0 ùêø[ùëñ]

where ùúè , ‚àÄùõº.( [ùëõ] ‚Üí Tùõº,1(U)) ‚Üí Tùõº ‚à™Œ£,ùëò (U), insert is the insertion oracle, and {ùëü , ùêø, ‚Ñé} are the
memory locations used by the oracle. The adversary, represented by the variable A, is declared in
a special adversary context. The other contexts for grading variables, standard variables and logi-
cal assumptions are empty (the contexts are explained in Sections 3 and 4). The statement on the
right hand side of the turnstile can be seen as a generalized Hoare triple, given by two assertions
(between curly braces) and a program, as in Hoare Type Theory [Nanevski et al. 2008]. We have a

(cid:8)(cid:8)√ç

(cid:9)(cid:9)

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:6

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

generic syntax of judgments and a generic set of generic inference rules, that can later be instan-
tiated to diÔ¨Äerent notions of assertions and diÔ¨Äerent interpretations. For the speciÔ¨Åc instantiation
used here (Section 4.2), the assertions are quantities ‚Äì maps from states to the non-negative reals
‚Äì that are known as the pre-expectation (the one on the left) and the post-expectation (on the
right), respectively. The interpretation of such a statement is that the expected value of the post-
expectation over the output distribution of the program is upper bounded by the pre-expectation.
We note that pollution attacks are a very simple example. More advanced attacks are considered
by Clayton et al. [2019]; Naor and Yogev [2019], who develop an elaborate theory of Bloom Filters
and probabilistic data structures under adversarial environments.

PRF/PRP Switching Lemma. The PRF/PRP Switching Lemma [Impagliazzo and Rudich 1989] is a
classical tool in provable security. Let {0, 1}ùëô denote the set of bitstrings of length ùëô. The lemma
states that the probability of a bounded adversary to distinguish between a pseudo-random func-
tion (PRF) and a pseudo-random permutation (PRP) is upper bounded by ùëò (ùëò + 1)/2ùëô +1 where
ùëò is the maximal number of calls allowed to the adversary. The PRF/PRP Switching Lemma is
a popular benchmark for computer-aided cryptography, so multiple formalizations are available,
e.g. [Barthe et al. 2009].

We model the adversary as a computation of type ‚àÄùõº.({0, 1}ùëô ‚Üí Tùõº,1({0, 1}ùëô )) ‚Üí TŒ£‚à™ùõº,ùëò ({0, 1})
where Œ£ models the private memory of the adversary. Similar to the case of Bloom Ô¨Ålters, we follow
a lazy modeling of PRF and PRP. The pseudo-code of PRF and PRP is given below:

PRF (ùë•1 : {0, 1}ùëô ) , if ùë•1 ‚àâ dom ùêø1 then {ùëß1 = Unif({0, 1}ùëô );
ùêø1 [ùë•1] := ùëß1}; return ùêø1 [ùë•1]
PRP (ùë•2 : {0, 1}ùëô ) , if ùë•2 ‚àâ dom ùêø2 then {ùëß2 = Unif({0, 1}ùëô \ (im ùêø2));ùêø2 [ùë•2] := ùëß2}; return ùêø2 [ùë•2]

We show that for every adversary A with the aforementioned type, the statistical distance between
A PRF and A PRP is upper bounded by ùëò (ùëò + 1)/2ùëô +1 using an approximate relational logic (i.e., a
logic that can prove approximations rather than equalities). We establish the following judgment:

‚Ä¢ | A : ùúè | ‚Ä¢ | ‚Ä¢ ‚ä¢ {s1 = s2} A PRF : TŒ£‚à™{ùêø1 },ùëò ({0, 1}) ‚àº A PRP : TŒ£‚à™{ùêø2 },ùëò ({0, 1}) {{s1 = s2‚àßv1 = v2}}ùëò (ùëò+1)/2ùëô +1
where ùúè , ‚àÄùõº.({0, 1}ùëô ‚Üí Tùõº,1({0, 1}ùëô )) ‚Üí TŒ£‚à™ùõº,ùëò ({0, 1}). This judgment has the following in-
terpretation: if we have two memories s1, s2 that are equal and we run the computation on the
left and the computation on the right with input memories s1 and s2 respectively, then the output
distributions are going to be close, and their statistical distance is upper bounded by ùëò (ùëò + 1)/2ùëô +1.
Although our proof uses an approximate logic, there is an alternative proof that uses an exact
relational logic, and the Union Bound logic. The latter proof uses the so-called up-to-bad technique,
and defaults to the union bound logic to prove that the probability of collisions in a PRF is upper
bounded by ùëò (ùëò + 1)/2ùëô +1. This is captured in the union bound logic by the judgment:

‚Ä¢ | A : ùúè | ‚Ä¢ | ‚Ä¢ ‚ä¢ {|ùëëùëúùëö ùêø1 | = 0}A PRF : TŒ£‚à™{ùêø1 },ùëò ({0, 1}){{|ùëëùëúùëö ùêø1| = |ùëñùëö ùêø1 |}}ùëò (ùëò+1)/2ùëô +1
This speciÔ¨Åcation has the same syntax as the speciÔ¨Åcation of the pollution attacks, but uses dif-
ferent notions of predicates and a diÔ¨Äerent intrepretation (but crucially, the same set of inference
rules). The assertions are Boolean predicates, and the interpretation of this judgment is that if the
initial state satisÔ¨Åes |ùëëùëúùëö ùêø1| = 0, then the Ô¨Ånal state satisÔ¨Åes |ùëëùëúùëö ùêø1| = |ùëñùëö ùêø1| with probability
1 ‚àí ùëò (ùëò+1)
. In other words, the judgment behaves as a Hoare triple that has some probability of
2ùëô +1
failure.

3 LANGUAGE
We consider a core language that models higher-order, stateful, probabilistic computations over
algebraic datatypes.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:7

Syntax. The language combines the usual constructs of ùúÜ-calculus and monadic constructs. Monadic

computations are introduced and composed by unit and let. In addition, we have operations for
sampling from a distribution in a set D of base distributions, and for reading or writing at a lo-
cation in a set Loc of locations. We also consider a primitive skip operation that represents an
empty computation (we could also deÔ¨Åne skip as unit(‚àó), where ‚àó is the sole inhabitant of the
unit type), and a primitive mfold for nesting monadic computations (the reason why we make
mfold monadic will become apparent in the next paragraph, when typing is considered). Finally,
for technical reasons that will become apparent when deÔ¨Åning the logic, we distinguish between
adversarial variables and standard variables. Formally, the terms of the language are given by the
following grammar:

ùë°, ùë¢ ::= ùë• | A | ‚àó | 0 | ùëÜ ùë¢ | ùúÜùë• .ùë¢ | ùë° ùë¢ | hùë°, ùë¢i | if ùë° then ùë¢1 else ùë¢2 | ùúã1 (ùë°) | ùúã2(ùë°) |
read ùëé | ùëé := ùë¢ | skip | unit(ùë°) | let ùë• = ùë° in ùë¢ | mfold ùë° ùë¢1 ùë¢2 | sample(ùúà)

where ùë• ranges over variables, A ranges over adversary variables, ùëé ranges over a set Loc of mem-
ory locations and ùúà ranges over a set D of distribution symbols. We assume that each distribution
has arity ùúèùúà,1 √ó ¬∑ ¬∑ ¬∑ √óùúèùúà, |ùúà | ‚Üí ùúéùúà , that accounts for the parameters of the distribution. The meaning
of the expressions is standard, except for the monadic fold operation for naturals, which sequences
computations in the monadic step, that is:

mfold 0 ùë° ùë¢ = ùë°

mfold (ùëÜ ùëõ) ùë° ùë¢ = let ùë• = (mfold ùëõ ùë° ùë¢) in ùë¢ ùë•

Syntactic sugar. In our examples we use some syntactic sugar to simplify the code. Concretely,
we will write ùë• = ùë°; ùë¢ instead of (ùúÜùë• .ùë¢) ùë°, ùëô := ùë° instead of let _ in ùëô := ùë° (i.e., we do not bind the
returned value) and inc ùëô instead of let ùë¶ = read ùëô in ùëô := ùë¶ + 1, where we assume ùë¶ is a free variable.

EÔ¨Äects. We use a type-and-simple eÔ¨Äect system to model the memory footprint and oracle com-
plexity of computations. We model the memory footprint as (an overapproximation of) the set Œ£
of memory locations read and written by a computation. In addition, our eÔ¨Äect system supports
abstract eÔ¨Äects and eÔ¨Äect polymorphism. These are used essentially to model adversaries. The
grading ùëò tracks how many times an adversary calls its oracles. For simplicity, we use a single
natural number for tracking oracle calls; however, it is possible to track oracle calls more Ô¨Ånely
by having a number per oracle. Semantically, eÔ¨Äects form an ordered commutative monoid: mem-
ory eÔ¨Äects are modeled using (P(Loc ‚à™ R), ‚àÖ, ‚à™, ‚äÜ), where R is a set of memory regions, P is the
powerset operator, and cost is modeled using (N, 0, +, ‚â§).

Types. Our language is essentially simply typed. As base types we consider the unit type U,
booleans B, and natural numbers, which are indexed by either a constant natural number ùêæ or by
inÔ¨Ånity, to indicate an upper bound on the inhabitants of the type. We will simply write N for N[‚àû].
On top of this we consider extended computations, which are given a type TŒ£,ùëò (ùúè). Here, ùúè is the
return type, and Œ£, ùëò is a grading that accounts for the memory eÔ¨Äect and cost of the computation.
We assume all locations in memory contain the same type V. We keep this abstract in the current
presentation, but we will instantiate it to a concrete type (e.g. N, B, . . . ) in the examples. Finally,
we include a type M for memories. These cannot be explicitly manipulated in the language, but
are used in speciÔ¨Åcations, see later in the section.

Formally, the set of types is given by the following syntax:

ùúè, ùúé ::= ùêµ | B | N[ùêæ] | M | U | V | ùúè ‚Üí ùúé | ùúè √ó ùúé | TŒ£,ùëò (ùúè) | ‚àÄùõº.ùúè
where ùêµ ranges over a set of base types, ùêæ ranges over natural numbers and the expression Œ£ is
built from region variables and memory locations. Note that bounded natural types N[ùêæ] are used
to compute the grading of monadic folds.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:8

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

Œû; Œî; Œì ‚ä¢ ‚òÖ: U

Star

Œû; Œî; Œì ‚ä¢ 0 : N[0]

Zero

Œû; Œî; Œì ‚ä¢ ùë° : N[ùêæ]
Œû; Œî; Œì ‚ä¢ ùëÜ ùë° : N[ùêæ + 1]

Succ

Œî; Œì ‚ä¢ ùë° : N[ùêæ]

Œî; Œì ‚ä¢ ùë¢1 : TŒ£,ùëò (ùúè)

Œî; Œì ‚ä¢ ùë¢2 : ùúè ‚Üí TŒ£‚Ä≤,ùëò‚Ä≤ (ùúè)

Œî; Œì ‚ä¢ mfold ùë° ùë¢1 ùë¢2 : TŒ£‚à™Œ£‚Ä≤,ùëò+ùêæ ¬∑ùëò‚Ä≤ (ùúè)

Fold

Œû; Œî; Œì ‚ä¢ ùë° : ùúè
Œû; Œî; Œì ‚ä¢ unit(ùë°) : T‚àÖ,0 (ùúè)
ùëé ‚àà Loc
Œû; Œî; Œì ‚ä¢ read ùëé : T{ùëé },0 (V)
Œû; Œî; Œì ‚ä¢ ùë°ùëñ : ùúèùúà,ùëñ

Unit

Read

Œû; Œî; Œì ‚ä¢ ùë°1 : TŒ£1,ùëò1 (ùúè)

Œû; Œî; Œì, ùë• : ùúè ‚ä¢ ùë°2 : TŒ£2,ùëò2 (ùúé)

Œû; Œî; Œì ‚ä¢ let ùë• = ùë°1 in ùë°2 : TŒ£1‚à™Œ£2‚à™EÔ¨Ä (ùúè),ùëò1+ùëò2 (ùúé)

Bind

Œû; Œî; Œì ‚ä¢ ùë¢ : V
ùëé ‚àà Loc
Œû; Œî; Œì ‚ä¢ ùëé := ùë¢ : T{ùëé },0 (U)

Write

(‚àÄ1 ‚â§ ùëñ ‚â§ |ùúà |)

Sample

Œû; Œî; Œì ‚ä¢ ùë° : ùúè ‚Ä≤

Skip

Œû; Œî; Œì ‚ä¢ skip : T‚àÖ,0 (U)
Œû ‚ä¢ ùúè ‚Ä≤ (cid:22) ùúè

Subtype

Œû; Œî; Œì ‚ä¢ sample(ùúà (ùë°1, . . . , ùë° |ùúà |)) : T‚àÖ,0 (ùúéùúà )

Œû, ùõº; Œî; Œì ‚ä¢ ùë° : ùúè

ùõº ‚àâ ùêπùëâ (Œî; Œì)

Œû; Œî; Œì ‚ä¢ ùë° : ‚àÄùõº.ùúè

ForAll-I

(A : ‚àÄùõº.(ùúé ‚Üí Tùõº,ùëò (ùúè)) ‚Üí Tùõº ‚à™Œ£,ùëò‚Ä≤ (ùúè ‚Ä≤)) ‚àà Œî

Œû; Œî; Œì ‚ä¢ ùë° : ùúè

Œû; Œî; Œì ‚ä¢ ùë° : ‚àÄùõº.ùúè

Œ£ ‚àà P(Loc)

Œû; Œî; Œì ‚ä¢ ùë° : ùúè [Œ£/ùõº]
Œû, ùõº; Œî; Œì ‚ä¢ ùë° : ùúé ‚Üí TŒ£‚Ä≤,ùëò (ùúè)

ForAll-E

Adv

Œû; Œî; Œì ‚ä¢ A ùë° : TŒ£‚à™Œ£‚Ä≤,ùëò‚Ä≤ (ùúè ‚Ä≤)

(A : ‚àÄùõº.(ùúé ‚Üí Tùõº,ùëò (ùúè)) ‚Üí Tùõº ‚à™Œ£,ùëò‚Ä≤ (ùúè ‚Ä≤)) ‚àà Œî

Œû; Œî; Œì ‚ä¢ ùë° : TŒ£1,ùëò1 (ùúè ‚Ä≤)

Œû; Œî\A; ‚Ä¢ ‚ä¢ ùë¢ : ‚àÄùõº.(ùúé ‚Üí Tùõº,ùëò (ùúè)) ‚Üí Tùõº ‚à™Œ£,ùëò‚Ä≤ (ùúè ‚Ä≤)

Œû; Œî\A; Œì ‚ä¢ ùë° [ùë¢/A] : TŒ£1,ùëò1 (ùúè ‚Ä≤)

Fig. 1. Selected typing rules

Adv-Inst

Type system. A typing judgment Œû; Œî; Œì ‚ä¢ ùë° : ùúè is a relation between contexts, terms and types.
Contexts are triples of the form Œû; Œî; Œì, where Œû is a grading context, Œî is an adversary context,
and Œì is a variable context. A grading context Œû is a collection of variables ùõº, ùõΩ, ¬∑ ¬∑ ¬∑ representing
the memory regions manipulated by the computation. The adversary and variable contexts are
functions from a Ô¨Ånite set of variables (adversary and standard, respectively). For a context Œì and
ùëõ distinct variables ùë•ùëñ such that ùë•ùëñ ‚àâ dom Œì, by Œì, ùë•1 : ùúè1, ¬∑ ¬∑ ¬∑ , ùë•ùëõ : ùúèùëõ we mean the context obtained
by extending Œì with ùë•1 : ùúè1 ¬∑ ¬∑ ¬∑ ùë•ùëõ : ùúèùëõ. We use a similar notation for Œî.

Typing rules are presented in Figure 1. Many rules are standard so we focus on the remaining
rules. The read and the write rules assume that locations store values of type V. The eÔ¨Äect of
a read or write is the location itself. The unit and bind rules act on the grading as the unit and
multiplication of the monoid from which the gradings are taken, but the bind rule also adds the
eÔ¨Äect EÔ¨Ä (ùúè) of the type ùúè encapsulated by the monad. This will be important for proving soundness
of the adversary rules, and it is deÔ¨Åned as:

EÔ¨Ä (ùêµ) , ‚àÖ

EÔ¨Ä (ùúè ‚Üí ùúé) , EÔ¨Ä (ùúé)

EÔ¨Ä (TŒ£,ùëò (ùúè)) , Œ£ ‚à™ EÔ¨Ä (ùúè)

EÔ¨Ä (‚àÄùõº.ùúè) = EÔ¨Ä (ùúè [‚àÖ/ùõº])

Monadic fold (for natural numbers) deÔ¨Ånes an iterator. It receives a natural number bounded
by ùêæ, a computation ùë¢1 with cost ùëò for the zero case, and a computation ùë¢2 with cost ùëò for the
successor case. The operational semantics imply that ùë¢2 will be run at most ùêæ times, and ùë¢1 will
be run exactly once, so we can give a bound ùêæ ¬∑ ùëò ‚Ä≤ + ùëò on the total cost. The rules for quantiÔ¨Åer
introduction and elimination are a lightweight version of eÔ¨Äect polymorphism. We can quantify
over any grading in Œû that does not appear free in Œì and Œî, and we can instantiate a quantiÔ¨Åer
to any concrete memory region. Since this does not actually have any computational content, we
choose to not reÔ¨Çect these rules in the term.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:9

The adversary rule allows applying an adversary variable to an expression with matching type.
The instantiation rule for adversary variables substituting an adversary variable by a closed ex-
pression of the same type. This is the only distinction between standard and adversary variables
‚Äì adversary variables represent closed expressions, while standard variables represent arbitrary
expressions. The reason for making this distinction will become clear when we describe logics.

Types are ordered by subtyping ùúè ‚Ä≤ (cid:22) ùúè, which is used in the [Subtype] rule. Subtyping is mostly
standard. On the type TŒ£,ùëò (ùúè), subtyping allows increasing ùëò, Œ£ and weakening ùúè. The rules for
subtyping are presented in Figure 6 in Appendix A.

Expressions about memories. In previous work [Aguirre et al. 2017], the terms appearing in log-
ical assertions and the terms (i.e., the programs) they specify about are derived from the same
grammar. In the current setting, program speciÔ¨Åcations contain distinguished variables represent-
ing the state, because they need to be able to refer explicitly to initial or Ô¨Ånal states and their
contents, but we do not want programs to have this capability. Therefore, terms appearing in log-
ical assertions will be derived from a grammar that extends the grammar of programs:

Àúùë°, Àúùë¢ ::= . . . | Àúùë° [ùëé] | Àúùë° [ùëé ‚Ü¶‚Üí Àúùë¢]

Here, Àúùë° [ùëé] denotes the contents of state Àúùë° at location ùëé, Àúùë° [ùëé ‚Ü¶‚Üí Àúùë¢] denotes the state resulting by re-
placing the contents of location ùëé in Àúùë° by Àúùë¢, and the ellipsis contains all the other term constructors.
Figure 7 in Appendix A presents the (obvious) typing rules for these new constructs.

4 HIGHER-ORDER UNARY LOGICS
In this section, we describe two program logics for our language. Both use the same syntactic proof
rules derived from a common template, but they diÔ¨Äer signiÔ¨Åcantly in their semantics and apply
to very diÔ¨Äerent veriÔ¨Åcation problems. The Ô¨Årst one is a higher-order Union Bound Logic, in the
line of [Barthe et al. 2016b]. This logic allows proving postconditions (for probabilistic computa-
tions) that may not hold with an explicit ‚Äúerror‚Äù probability ùõø. The second one is a higher-order
expectation logic, in the line of [Barthe et al. 2018; Kozen 1985; Morgan et al. 1996]. Instead of
specifying programs with qualitative assertions (that can either be true or false), this logic uses
quantitative assertions ranging over the non-negative reals. The logic can be used to prove bounds
on the expected values of quantitative postconditions. Both logics have adversaries and state.

4.1 Higher-order Union Bound Logic

The syntax of our union bound logic (HO-UBL) is shown below. Propositions ùúô,ùúì are standard
(intuitionistic) HOL formulas over terms. QuantiÔ¨Åers range over these terms. In contrast, assertions
ùëÉ, ùëÑ denote pre- and post-conditions that relate the language‚Äôs expressions and the current heap
state. ùëÖ and ùëì denote atomic propositions and atomic assertions, respectively. hùúôi is an injection
of propositions into assertions. The connectives ‚äì and ‚äî respectively denote conjunction (‚àß) and
disjunction (‚à®) at the level of assertions.1 2 To refer to the state, assertions ùëÉ, ùëÑ may contain a
distinguished variable s, which stands for the current state. Similarly, propositions ùúô,ùúì can contain
a distinguished variable v that stands for (the value of) the term being veriÔ¨Åed.

1There is a reason for using diÔ¨Äerent symbols for these connectives in propositions and assertions: In the expectation logic
(Section 4.2), we want to reuse the same syntax, but give assertions quantitative interpretations while retaining the Boolean
interpretations for propositions. Using diÔ¨Äerent symbols for the connectives prevents confusion there.
2We can add quantiÔ¨Åers ‚àÄ, ‚àÉ to assertions, but we elide them here. Our examples only use Ô¨Ånite quantiÔ¨Åcation in assertions,
which can be encoded using ‚äì and ‚äî.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:10

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

::= ùëÖ(ùë°1, . . . , ùë°ùëõ) | ‚ä§ | ‚ä• | ùúô ‚àß ùúì | ùúô ‚à® ùúì | ùúô ‚áí ùúì | ¬¨ùúô | ‚àÄùë• : ùúé.ùúô | ‚àÉùë• : ùúé.ùúô

ùúô,ùúì
ùëÉ, ùëÑ ::= ùëì ( Àúùë°1, . . . , Àúùë°ùëõ) | ‚ä§ | ‚ä• | hùúôi | ùëÉ ‚äî ùëÑ | ùëÉ ‚äì ùëÑ

Propositions
Assertions
Assumptions Œ®
Judgments

::= ‚Ä¢ | Œ®, ùúì

Œû | Œî | Œì | Œ® ‚ä¢ ùúô
Œû | Œî | Œì | Œ® ‚ä¢ ùëÉ ‚áõ ùëÑ
Œû | Œî | Œì | Œ® ‚ä¢ ùë° : ùúé {ùúô }
Œû | Œî | Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúé){{ùëÑ }}ùõø

The logic has four judgments that rely on four contexts‚ÄîŒû, Œî and Œì that were described earlier‚Äî
and the new context Œ®, which contains logical assumptions (propositions) ranging over the vari-
ables in Œî and Œì. Since most of our rules do not modify or read the contexts and Œû and Œî, we omit
them from most of the discussion below. This simpliÔ¨Åes the judgments, e.g., we write Œì | Œ® ‚ä¢ ùúô
instead of Œû | Œî | Œì | Œ® ‚ä¢ ùúô.

The Ô¨Årst judgment Œì | Œ® ‚ä¢ ùúô is HOL‚Äôs standard entailment judgment. It means that the proposi-
tion ùúì holds for all typed instantiations of the variables in Œì satisfying all propositions in Œ®. The
second judgment Œì | Œ® ‚ä¢ ùëÉ ‚áõ ùëÑ is entailment of assertions; it means that the assertion ùëÉ entails
the assertion ùëÑ for all typed instantiations of Œì satisfying Œ®.

The third judgment Œì | Œ® ‚ä¢ ùë° : ùúé {ùúô } means that for all typed instantiations of Œì satisfying Œ®,
the term ùë° (of type ùúé) satisÔ¨Åes ùúô [ùë°/v]. (Recall that v is a distinguished variable.) In other words,
the judgment speciÔ¨Åes a property ùúô of the term ùë° being veriÔ¨Åed. This judgment‚Äôs proof rules are
directed by the syntax of ùë° and are taken as-is from the prior logic UHOL [Aguirre et al. 2017].
The work on UHOL also shows that these syntax-directed rules are sound and complete relative
to HOL: Œì | Œ® ‚ä¢ ùë° : ùúé {ùúô } iÔ¨Ä Œì | Œ® ‚ä¢ ùúô [ùë°/v]. We reproduce these rules in Appendix B.

The fourth judgment Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúé){{ùëÑ }}ùõø is new to our logic. It speciÔ¨Åes a pre-condition
ùëÉ and a post-condition ùëÑ for a monadic computation ùë° of type TŒ£,ùëò (ùúé). Recall that a monadic com-
putation of this type is stateful and probabilistic ‚Äî it takes a state and produces a distribution on
results of type ùúé and Ô¨Ånal states. The judgment means that, for any instantiation of Œì satisfying
all propositions in Œ®, starting the execution of ùë° in any state ùëö that satisÔ¨Åes ùëÉ [ùëö/s], the Ô¨Ånal state
ùëö‚Ä≤ and result ùë° ‚Ä≤ (of type ùúé) satisfy ùëÑ [ùëö‚Ä≤/s] [ùë° ‚Ä≤/v] with probability at least 1 ‚àí ùõø. Additionally, only
locations in the set Œ£ are modiÔ¨Åed. In other words, the judgment represents a standard Hoare-
triple for stateful computations, but with a small twist: the postcondition may not hold with an
error probability ùõø. The semantics of this judgment is deÔ¨Åned by lifting standard Hoare triples to
distributions (Section 6.5).

Formally, the pre-condition ùëÉ can contain the free variable s : M (where M is the type of memo-
ries), while ùëÑ can contain the variables s : M and v : ùúé. Additionally, both may mention variables
from Œì and the elided context Œî. The restriction that only locations in Œ£ be modiÔ¨Åed during ùë°‚Äôs
reduction is needed for handling adversaries as we explain soon. The judgment also does not make
use of the grade ùëò in the type TŒ£,ùëò (ùúé); this grade is also used for handling adversaries.

Monadic rules. Figure 2 presents the main rules of the fourth judgment. As before, we omit the
contexts Œû and Œî; these transfer unchanged from the conclusion to the premises in all rules. All
our rules are syntax-directed. The rule UNIT-U applies to the term unit(ùë°), which returns the term
ùë° without modifying the state with probability 1. The rule just restates this diÔ¨Äerently. Formally, if
ùë° satisÔ¨Åes ùúô (Ô¨Årst premise), then executing unit(ùë°) from a state satisfying ùëÉ results in a state and
return term that satisfy hùúôi‚äìùëÉ. The probability of this not happening is 0. (The premise Œì, s : M ‚ä¢ ùëÉ
just means that the assertion ùëÉ is a well-formed predicate over the typed variables in Œì, s : M.)

The rule MLET-U for the monadic bind is a generalization of the usual sequencing rule of Hoare
logic. The error probabilities ùõø and ùõø ‚Ä≤ are summed in the conclusion. This is easy to see: From the

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:11

Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø

Œì, ùë• : ùúè | Œ® ‚ä¢ {ùëÑ [ùë•/v]}ùë¢ : TŒ£‚Ä≤,ùëò‚Ä≤ (ùúé){{ùëÖ}}ùõø‚Ä≤

ùë• ‚àâ ùëÖ

Œì | Œ® ‚ä¢ {ùëÉ }let ùë• = ùë° in ùë¢ : TŒ£‚à™Œ£‚Ä≤‚à™EÔ¨Ä (ùúè),ùëò+ùëò‚Ä≤ (ùúé){{ùëÖ}}ùõø+ùõø‚Ä≤

MLET-U

Œì | Œ® ‚ä¢ ùë° : ùúè {ùúô }

Œì, s : M ‚ä¢ ùëÉ

Œì | Œ® ‚ä¢ {ùëÉ }unit(ùë°) : T‚àÖ,0 (ùúè){{hùúôi ‚äì ùëÉ }}0

UNIT-U

Œì | Œ® ‚ä¢ {ùëÉ [s[ùëé]/v]}read ùëé : T{ùëé },0 (V){{ùëÉ }}0

READ-U

Œû; Œì ‚ä¢ ùë° : V
Œì | Œ® ‚ä¢ {ùëÉ [s[ùëé ‚Ü¶‚Üí ùë°]/s]}ùëé := ùë° : T{ùëé },0 (U){{ùëÉ }}0

WRITE-U

Œì ‚ä¢ ùëè : B

Œì | Œ®, ùëè = tt ‚ä¢ {ùëÉ1}ùë°1 : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø

Œì | Œ®, ùëè = Ô¨Ä ‚ä¢ {ùëÉ2}ùë°2 : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø

Œì | Œ® ‚ä¢ {hùëè = tti ‚äì ùëÉ1) ‚äî (hùëè = Ô¨Äi ‚äì ùëÉ2)}if ùëè then ùë°1 else ùë°2 : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø
Œì ‚ä¢ ùëõ : N[ùêæ]

Œì | Œ® ‚àß ùëõ = 0 ‚ä¢ {ùëÉ }ùë°1 : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø

Œì, ùë• : ùúè | Œ® ‚àß ùëõ ‚â† 0 ‚ä¢ {ùëÑ }ùë°2 : TŒ£‚Ä≤,ùëò‚Ä≤ (ùúè){{ùëÑ }}ùõø‚Ä≤

Œì | Œ® ‚ä¢ {ùëÉ }mfold ùëõ ùë°1 (ùúÜùë•.ùë°2) : TŒ£‚à™Œ£‚Ä≤,ùëò+ùêæ ¬∑ùëò‚Ä≤ (ùúè){{ùëÑ }}ùõø+ùêæ ¬∑ùõø‚Ä≤

MCASE-U

MFOLD-U

Fig. 2. Monadic proof rules of our higher-order union bound logic. These rules are reused for the higher-order
expectation logic with a diÔ¨Äerent interpretation of hùúôi, ‚äì, and ‚äî.

Œì | Œ® ‚ä¢ ùëÉ ‚áõ ùëÉ ‚Ä≤

Œì | Œ® ‚ä¢ {ùëÉ ‚Ä≤}ùë° : TŒ£,ùëò (ùúè){{ùëÑ ‚Ä≤}}ùõø‚Ä≤

Œì | Œ® ‚ä¢ ùëÑ ‚Ä≤ ‚áõ ùëÑ

ùõø ‚Ä≤ ‚â§ ùõø

Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø

CONSEQ-U

Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø

Œì | Œ® ‚ä¢ {ùëÉ ‚Ä≤}ùë° : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø

Œì | Œ® ‚ä¢ {ùëÉ ‚äî ùëÉ ‚Ä≤}ùë° : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø

Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø

Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúè){{ùëÑ ‚Ä≤}}ùõø‚Ä≤

Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúè){{ùëÑ ‚äì ùëÑ ‚Ä≤}}ùõø+ùõø‚Ä≤

OR-PRE-U

AND-POST-U

Fig. 3. Selected structural rules of the higher-order union bound logic. These rules are reused for the higher-
order expectation logic with a diÔ¨Äerent interpretation of ‚äì, ‚äî and ‚áõ.

Ô¨Årst premise, with probability at least 1 ‚àí ùõø, the postcondition ùëÑ of ùë° holds and, hence, from the
second premise, with probability at least (1 ‚àí ùõø) ‚àí ùõø ‚Ä≤, the postcondition ùëÖ holds. Hence, the error
probability is at most ùõø + ùõø ‚Ä≤.

The rules READ-U and WRITE-U propagate heap changes backwards, as in standard Hoare
logic. We also have the rule MCASE-U for conditionals of monadic type. Again, this rule follows
the rule for conditionals in Hoare logic. The rule MFOLD-U applies to mfold ùëõ ùë°1 (ùúÜùë• .ùë°2). Here, ùêæ
is a bound on the number of iterations (Ô¨Årst premise). The error probability in the conclusion is
the error probability ùëò ‚Ä≤ of the iteration‚Äôs body scaled by ùêæ.

Structural rules. Figure 3 shows selected structural rules of our logic. The rule of consequence,
CONSEQ-U, allows weakening postconditions and error probabilities, and strengthening precon-
ditions. The rule OR-PRE-U allows case analysis in the precondition. Finally, the rule AND-POST-
U allows splitting a conjunction in the postcondition. Note that in this case, the error probability
ùõø +ùõø ‚Ä≤ is the sum of the error probabilities of the two conjuncts. This sum is a standard union bound
on (error) probabilities, which explains the name of our logic.

Rules for monadic primitives. Additionally, we include rules for monadic primitives that we use
in examples. For instance, the following rule is used for typing the term Unif(ùúé), which samples a

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:12

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

value uniformly from the Ô¨Ånite type ùúé. The sampling does not change the state, so the rule copies
the precondition ùëÉ to the postcondition. The sampled value additionally satisÔ¨Åes any predicate ùúô
of cardinality ùëÅ with probability 1 ‚àí ùëÅ /|ùúé |.

Œì | Œ® ‚ä¢ ùëÉ ‚áõ (|{ùë• ‚àà ùúé | ùë• ‚àà ùúô }| / |ùúé | = ùõø)
Œì | Œ® ‚ä¢ {ùëÉ }Unif (ùúé) : T‚àÖ,0 (ùúé){{ùëÉ ‚àß ùúô }}1‚àíùõø

SAMPLE-UBL

Adversary rule

In security applications, one often wants to prove properties of ‚Äúadversarial‚Äù code, of which very
little is known statically. Typically, one may know or assume that the adversarial code is closed, has
a speciÔ¨Åc simple type and that it has a certain bounded complexity, but not much else. VeriÔ¨Åcation
of such unknown code, unsurprisingly, relies on parametricity properties of the language. To this
end, we need proof rules that internalize parametric reasoning into the logic. Below we show one
such rule, ADV-U, which suÔ¨Éces for our examples. We Ô¨Årst explain the rule informally and then
give more formal details:

(A : ‚àÄùõº.(ùúé ‚Üí Tùõº,1 (ùúè)) ‚Üí TŒ£‚à™ùõº,ùëò (ùúè ‚Ä≤)) ‚àà Œî

Œî | s : M ‚ä¢ ùëÉ

ùëÉ ‚àà Safe(Œ£)

Œî | ùë• : ùúé | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£‚Ä≤,1 (ùúè){{ùëÉ }}ùõø
ùúé, ùúè, ùúè ‚Ä≤ non-monadic types

(ùë• ‚àâ Œ®, ùëÉ)

Œî | ‚Ä¢ | Œ® ‚ä¢ {ùëÉ }A (ùúÜùë•.ùë°) : TŒ£‚à™Œ£‚Ä≤,ùëò (ùúè){{ùëÉ }}ùëò ¬∑ùõø

ADV-U

Informal explanation. Informally, ADV-U says the following. Suppose:

- A is an arbitrary (adversarial) closed second-order program whose side eÔ¨Äects are limited to

the locations in Œ£, and that uses its argument at most ùëò times (Ô¨Årst premise),

- ùúÜùë• .ùë° is an argument for A such that ùë° preserves the assertion ùëÉ on memories, except with

probability ùõø (second premise), and

- ùëÉ does not depend on the values in any locations in Œ£ (premise ùëÉ ‚àà Safe(Œ£), which is deÔ¨Åned

formally later).

Then, A applied to (ùúÜùë• .ùë°) preserves the assertion ùëÉ except with probability ùëò ¬∑ ùõø.

We can easily see why the conclusion holds. First, since ùëÉ depends only on values of locations
outside Œ£, to violate ùëÉ, A must modify locations outside Œ£. Next, the only way A can even hope to
modify variables outside Œ£ is by invoking its argument (ùúÜùë• .ùë°). This is because A‚Äôs own eÔ¨Äects are
limited to Œ£ and it is closed, so it cannot get access to other eÔ¨Äects due to additional substitutions.
Hence, the only way for A to violate ùëÉ is by invoking ùúÜùë• .ùë°. However, ùë° violates ùëÉ with probability
at most ùõø and A cannot apply ùúÜùë• .ùë° more than ùëò times. Hence, by a straightforward union bound,
A‚Äôs chances of violating ùëÉ are bounded by ùëò ¬∑ ùõø, which is exactly the conclusion.

The remarkable aspect of the rule is how little it assumes about the adversarial expression A ‚Äì
just that A is closed, that it uses its argument at most ùëò times and that its side-eÔ¨Äects are limited to
Œ£. The derived conclusion ‚Äì that ùëÉ is preserved except with probability ùëò ¬∑ùõø ‚Äì holds for any closed,
simply typed substitution for the variable A. This is what makes this rule very powerful and useful.
For example, in security applications, A can model an arbitrary, unknown ‚Äúadversary‚Äù of bounded
complexity ùëò that is given a known ‚Äúoracle‚Äù as argument. The rule then proves properties of any
instance of the adversary applied to a given oracle (ùúÜùë• .ùë°), without having to verify the adversary.

Formal notes. The type of A (Ô¨Årst premise) ensures that its argument incurs an eÔ¨Äect of at least
1 unit at each use, and that the total eÔ¨Äect of A is ùëò. Hence, A cannot use its argument more
than ùëò times. Further, the rule insists that A exist in Œî, not Œì. This ensures that A represents a
closed term. Finally, the quantiÔ¨Åcation over the eÔ¨Äect set ùõº ensures that A itself writes only to
the locations in Œ£.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:13

The condition ùëÉ ‚àà Safe(Œ£) is formally deÔ¨Åned as ‚àÄùëö1 ùëö2 : M. (‚àÄùëé ‚àâ Œ£. ùëö1 [ùëé] = ùëö2 [ùëé]) ‚áí
ùëÉ [ùëö1/s] ‚áî ùëÉ [ùëö2/s], and means that ùëÉ is independent of the values in locations in Œ£. The condition
that ùúé, ùúè and ùúè ‚Ä≤ be non-monadic is a technical simpliÔ¨Åcation: the rule is proven sound using a
logical relation, and terms of non-monadic types trivially inhabit the relation. The restriction can
be lifted by imposing additional logical conditions on the argument and result value of ùë°, as well as
requiring that ùëÉ must be also safe for the eÔ¨Äects in ùúè ‚Ä≤. Similarly, the restriction to closed adversaries
can be lifted by requiring that every free variable is instantiated to a term that inhabits the logical
relation.

We chose a particular second-order type for adversaries in this paper, which was the most conve-
nient for our examples. However, the soundness argument can be used to easily derive adversary
rules for diÔ¨Äerent adversaries, e.g. adversaries that accept multiple oracles or third-order adver-
saries, that interact with oracles that receive functions as arguments.

In the examples it is often convenient to use a mild extension of the rule, where the invariant
ùëÉùëñ and the error bound ùõøùëñ depend on some natural number ùëñ and we show that (1) each oracle
call with precondition ùëÉùëñ satisÔ¨Åes the postcondition ùëÉùëñ+1 with error probability ùõøùëñ and (2) every ùëÉùëñ
implies ùëÉùëñ+1, from which we deduce that the adversarial computation satisÔ¨Åes the postcondition
ùëÉùëò with error probability ùõø1 + ¬∑ ¬∑ ¬∑ + ùõøùëò . To avoid cluttering the notation, here and in Section 5 we
present the rules without this indexing.

Example: Probability of collisions
We now exercise our proof system to upper bound the probability of collisions for all adversaries
making at most ùëò queries to a PRF. Recall that our goal is to prove

A : ‚àÄùõº.({0, 1}ùëô ‚ÜíTùõº,1({0, 1}ùëô ))‚ÜíTŒ£‚à™ùõº,ùëò ({0, 1}) ‚ä¢ {ùê∏ùëöùëùùë°ùë¶}A PRF : TŒ£,ùëò ({0, 1}){{Œ¶ùëò }}ùëò (ùëò+1)/2ùëô +1

where Œ¶ùëñ , |ùëëùëúùëö(ùêø)| = |ùëñùëö(ùêø)| ‚àß |ùëëùëúùëö(ùêø)| ‚â§ ùëñ.

Applying the proof rule for adversaries, it suÔ¨Éces to prove that the ùëñ-th call of the oracle pre-
serves the assertion ùëÅùëúùê∂ùëúùëôùëô with error probability at most ùëñ/2ùëô . Here we use the fact that at the
ùëñ-th iteration the domain of ùêø has size at most ùëñ. So we have to prove:
ùë• : {0, 1}ùëô ‚ä¢ {|ùëëùëúùëö (ùêø)| = |ùëñùëö (ùêø)| ‚àß |ùëëùëúùëö (ùêø)| ‚â§ ùëñ}ùëí : Tùõº,1 ({0, 1}ùëô ){{|ùëëùëúùëö (ùêø)| = |ùëñùëö (ùêø)| ‚àß |ùëëùëúùëö (ùêø)| ‚â§ ùëñ + 1}}ùëñ/2ùëô
where ùëí is the body of ùëÉùëÖùêπ . We work our way backwards starting with ùëÉùëñ+1 , {{|ùëëùëúùëö(ùêø)| =
|ùëñùëö(ùêø)| ‚àß |ùëëùëúùëö(ùêø)| ‚â§ ùëñ + 1}}ùëñ/2ùëô from the end of the program and compute the precondition of each
statement. Note that we keep the grading because every precondition is the postcondition of the
previous statement. The last instruction is a return, which we can skip since our assertion does
not mention the return value.

Now we encounter the case split. The else branch is empty, so its precondition is still ùëÉùëñ+1. On
the then branch we start by strengthening the postcondition to {{ùë• ‚àâ ùëëùëúùëö(ùêø) ‚àß ùëÉùëñ+1}}ùëñ/2ùëô . Then we
have the assignment ùêø1 [ùë•1] = ùëß1, whose precondition is

{{ùë•1 ‚àâ ùëëùëúùëö(ùêø) ‚àß |ùëëùëúùëö(ùêø) ‚à™ {ùë•1}| = |ùëñùëö(ùêø) ‚à™ {ùëß1}| ‚àß |ùëëùëúùëö(ùêø) ‚à™ {ùë•1}| ‚â§ ùëñ + 1}}ùëñ/2ùëô

Now we can strengthen this to
{{ùëß1 ‚àâ ùëñùëö(ùêø) ‚àß ùë•1 ‚àâ ùëëùëúùëö(ùêø) ‚àß |ùëëùëúùëö(ùêø) ‚à™ {ùë•1}| = |ùëñùëö(ùêø) ‚à™ {ùëß1}| ‚àß |ùëëùëúùëö(ùêø) ‚à™ {ùë•1}| ‚â§ ùëñ + 1}}ùëñ/2ùëô
which is equivalent to

{{ùëß1 ‚àâ ùëñùëö(ùêø) ‚àß ùë•1 ‚àâ ùëëùëúùëö(ùêø) ‚àß |ùëëùëúùëö(ùêø)| + 1 = |ùëñùëö(ùêø)| + 1 ‚àß |ùëëùëúùëö(ùêø)| + 1 ‚â§ ùëñ + 1}}ùëñ/2ùëô
and by the SAMPLE-UBL rule, we know that the probability of sampling something outside ùëñùëö(ùêø)
is at least 1 ‚àí ùëñ/(2ùëô ), so the precondition of this is

{{ùë•1 ‚àâ ùëëùëúùëö(ùêø) ‚àß |ùëëùëúùëö(ùêø)| + 1 = |ùëñùëö(ùêø)| + 1 ‚àß |ùëëùëúùëö(ùêø)| + 1 ‚â§ ùëñ + 1}}0

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:14

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

This is the precondition of the then branch. By the MCASE-U rule, the precondition of the whole
case construct is

(ùë• ‚àâ ùëëùëúùëö(ùêø) ‚àß (ùë• ‚àâ ùëëùëúùëö(ùêø) ‚àß |ùëëùëúùëö(ùêø)| + 1 = |ùëñùëö(ùêø)| + 1 ‚àß |ùëëùëúùëö(ùêø)| + 1 ‚â§ ùëñ + 1))‚à®
(ùë• ‚àà ùëëùëúùëö(ùêø) ‚àß (|ùëëùëúùëö(ùêø)| = |ùëñùëö(ùêø)| ‚àß |ùëëùëúùëö(ùêø)| ‚â§ ùëñ + 1))

.

(cid:27)(cid:27)0

(cid:26)(cid:26)

By strengthening, we Ô¨Ånally get {{(|ùëëùëúùëö(ùêø)| = |ùëñùëö(ùêø)| ‚àß |ùëëùëúùëö(ùêø)| ‚â§ ùëñ))}}0, which is exactly ùëÉùëñ .

4.2 Higher-order expectation logic
Our second logic (HO-EXP) is a quantitative (non-Boolean) higher-order expectation logic that
proves upper bounds on expected values of functions of program results and Ô¨Ånal memories. The
logic extends expectation calculi [Kaminski et al. 2016; Morgan et al. 1996] to the higher-order
setting.

This logic is syntactically very similar to the higher-order union bound logic of Section 4.1 in the
formulas, the judgments and most of the proof rules, but it is very diÔ¨Äerent in the interpretation
of assertions ùëÉ, ùëÑ. SpeciÔ¨Åcally, assertions in this logic are non-negative real-valued functions of
their free variables (Œî, Œì, v, s). The assertion connectives ‚äì and ‚äî are the pointwise supremum
and inÔ¨Åmum operators on such functions, as deÔ¨Åned below. (Propositions ùúô,ùúì still have Boolean
interpretations, as in the union bound logic.)

To upper bound expected values, the monadic judgment Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúé){{ùëÑ }}ùõø is inter-
preted quantitatively, in terms of expectations.3 SpeciÔ¨Åcally, the inner judgment {ùëÉ }ùë° : TŒ£,ùëò (ùúé){{ùëÑ }}ùõø
means that for every state ùëö : M, if we run ùë° from state ùëö, then the expected value of ùëÑ over all possi-
ble Ô¨Ånal states is upper-bounded by ùëÉ [ùëö/s] +ùõø. That is, E(ùëö‚Ä≤,ùë° ‚Ä≤)‚àºùë° (ùëö) [ùëÑ [ùëö‚Ä≤/s] [ùë° ‚Ä≤/v]] ‚â§ ùëÉ [ùëö/s] +ùõø.
The whole judgment Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúé){{ùëÑ }}ùõø means that this inequality holds for all substi-
tutions for Œì that satisfy Œ®. Again, the formal semantics of this judgment is deÔ¨Åned by a lifting.
Conventionally, ùëÉ and ùëÑ are respectively called the pre-expectation and the post-expectation of
the term ùë°. Informally, the judgment {ùëÉ }ùë° : TŒ£,ùëò (ùúé){{ùëÑ }}ùõø means that the expected value of the
post-expectation is upper-bounded by the pre-expectation plus an error ùõø.

Syntax. The logic reuses the syntax of the union bound logic (Section 4.1), but we extend asser-
tions with some connectives that are speciÔ¨Åc to quantities. These new connectives are shown in
blue-bold font below.

Assertions

ùëÉ, ùëÑ ::= ùëì (ùë°1, . . . , ùë°ùëõ) | ‚ä§ | ‚ä• | hùúôi | ùëÉ ‚äî ùëÑ | ùëÉ ‚äì ùëÑ | [ùúô] | P + Q | k ¬∑ P

Assertions are quantities ranging over [0, ‚àû]. ùëì denotes a function with codomain [0, ‚àû]. Asser-
tion connectives have the following interpretations.

J‚ä§K

, 0
JùëÉ ‚äî ùëÑK , inf {JùëÉK, JùëÑK}
ùúô holds

JhùúôiK

,

0
‚àû ùúô does not hold

JùëÉ + ùëÑK , JùëÉK + JùëÑK

(cid:26)

J‚ä•K

, ‚àû
JùëÉ ‚äì ùëÑK , sup{JùëÉK, JùëÑK}
1 ùúô holds
0 ùúô does not hold

J[ùúô]K

,

Jùëò ¬∑ ùëÉK

(cid:26)
, ùëò ¬∑ JùëÉK

Note that ‚ä• is interpreted as ‚àû, not 0. Similarly, ‚äì corresponds to supremum, not inÔ¨Åmum. This
reversal of the usual order is due to the fact that we want to prove upper bounds. The connective
[ùúô] is also called the Iverson bracket [Iverson 1962].

The judgment Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúé){{ùëÑ }}ùõø is interpreted as explained above. The judgment

Œì | Œ® ‚ä¢ ùëÉ ‚áõ ùëÉ ‚Ä≤ means that ùëÉ ‚â• ùëÉ ‚Ä≤ for all instantiations of Œì that satisfy Œ®.

3As in Section 4.1, the contexts Œû, Œî also exist but are elided from most of the presentation for brevity.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:15

Proof rules. The expectation logic reuses the monadic and structural proof rules of the union
bound logic as is (Figures 2 and 3). However, the rules‚Äô meanings are quantitative and their sound-
ness is completely diÔ¨Äerent. We illustrate the new meanings of some of these rules by explaining
why they are still sound.

In rule UNIT-U, the premise ensures that ùúô holds (for the term ùë°). So, hùúôi equals 0 semantically,
and hùúôi ‚äì ùëÉ is equivalent to ùëÉ. Combined with the fact that unit(ùë°) returns ùë° and does not modify
the memory, both with probability 1, the rule is trivially sound. The rule MLET-U corresponds
to the standard composition of random functions. In the rule MCASE-U, the precondition hùëè =
tti ‚äì ùëÉ1) ‚äî (hùëè = Ô¨Äi ‚äì ùëÉ2) in the conclusion is semantically equal to ùëÉ1 when ùëè = tt and ùëÉ2 when
ùëè = Ô¨Ä. Hence, the conclusion reduces to either the second or the third premise.4

We also have a new structural rule (LIN-EXP) that allows combining two diÔ¨Äerent Hoare triples

for the same program, relying on the linearity of expectations.

Œì | Œ® ‚ä¢ {ùëÉ1}ùë° : TŒ£,ùëò (ùúè){{ùëÑ1}}ùõø1

Œì | Œ® ‚ä¢ {ùëÉ2}ùë° : TŒ£,ùëò (ùúè){{ùëÑ2}}ùõø2

Œì | Œ® ‚ä¢ {ùëÉ1 + ùëÉ2}ùë° : TŒ£,ùëò (ùúè){{ùëÑ1 + ùëÑ2}}ùõø1+ùõø2

LIN-EXP

Rules for monadic primitives. Finally, we include rules for monadic primitives that we use in
examples. For instance, the rule UNIF-EXP below applies to the term Unif(ùêæ), which samples
from the uniform distribution over {0, 1, . . . , ùêæ ‚àí 1}. For ùëà ‚äÜ {0, . . . , ùêæ ‚àí 1}, a value sampled from
this distribution is in ùëà with probability exactly |ùëà |/(ùêæ). Hence, the expected value of [v ‚àà ùëà ] is
exactly |ùëà |/(ùêæ), which is the pre-expectation.

ùëà ‚äÜ {0, . . . , ùêæ ‚àí 1}
Œì | Œ® ‚ä¢ {(|ùëà |/ùêæ) ¬∑ ùëÉ }Unif (ùêæ) : T‚àÖ,0 (N[ùêæ]){{[v ‚àà ùëà ] ¬∑ ùëÉ }}0

UNIF-EXP

Adversary rule. The expectation logic admits the adversary rule ADV-U of the union bound
logic but with a quantitative deÔ¨Ånition of the meta-predicate Safe. Here, ùëÉ ‚àà Safe(Œ£) is deÔ¨Åned as
‚àÄùëö1 ùëö2 : M. (‚àÄùëé ‚àâ Œ£. ùëö1 [ùëé] = ùëö2 [ùëé]) ‚áí ùëÉ [ùëö1/s] = ùëÉ [ùëö2/s]. With this change to the deÔ¨Ånition
of Safe, the rule is sound for expectations.

Example. We consider pollution attacks on Bloom Filters motivated in Section 2. We consider an
arbitrary adversary A with access to the insert oracle of a Bloom Ô¨Ålter. The goal of the adversary
is to set as many bits in the Bloom Ô¨Ålter to 1 as possible using ùëò queries to the oracle. We assume
that the Bloom Ô¨Ålter is initially empty and, for simplicity, that it uses only one hash function, i.e.,
‚Ñì = 1 (our proof easily generalizes to any ‚Ñì). We model the hash function as a random oracle that is
sampled lazily. The Bloom Ô¨Ålter is implemented as a vector of ùëö bits in locations ùêø[0], . . . , ùêø[ùëö ‚àí1].
The inserted elements are from the set [ùëõ] = {0, . . . , ùëõ ‚àí 1}, and ‚Ñé[0] . . . ‚Ñé[ùë† ‚àí 1] are auxiliary
locations that hold integers. Additionally, we assume a location ùëü that holds a counter. This is
a ghost variable to help us in our veriÔ¨Åcation eÔ¨Äort, it is concretely used to make the invariant
depend on the number of previous calls. Initially, each ùêø[ùëñ] is set to 0, each ‚Ñé[ùëñ] is set to ‚àí1 and ùëü
is set to 0. The code of the insert oracle is shown below:

insert(ùë• : [ùëõ]) , let ùëè = read ‚Ñé[ùë•] in

if ùëè ‚â† ‚àí1 then

let ùë¶ = Unif(ùëö) in
‚Ñé[ùë•] := ùë¶; ùêø[ùë¶] := 1; inc ùëü

else inc ùëü

4The precondition hùëè = tti ‚äì ùëÉ1) ‚äî ( hùëè = Ô¨Ä i ‚äì ùëÉ2) is semantically equivalent to ( [ùëè = tt] ¬∑ ùëÉ1) + ( [ùëè = Ô¨Ä ] ¬∑ ùëÉ2). The latter
is a more conventional way of writing the precondition [Morgan et al. 1996], but we prefer the former because it shows
the correspondence to the union bound logic.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:16

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

We want to show that the expected number of bits any adversary can set after making ùëò calls
to the adversary is upper bounded by ùëö(1 ‚àí ((ùëö ‚àí 1)/ùëö)ùëò ). For this, we prove that for any A :
‚àÄùõº.( [ùëõ] ‚Üí Tùõº,1(U)) ‚Üí Tùõº ‚à™Œ£,ùëò (U), we have

where the expectation ùêπ is deÔ¨Åned as

‚ä¢ {ùêπ }A insert : TŒ£‚à™{ùêø,‚Ñé,ùëü },ùëò (ùúè){{ùêπ }}0,

ùêπ =

ùëñ ‚àà[ùëö] s[ùêø[ùëñ]]

( (ùëö ‚àí 1)/ùëö)ùëò‚àís[ùëü ] + ùëö

1 ‚àí ((ùëö ‚àí 1)/ùëö)ùëò‚àís[ùëü ]

.

(cid:17)
The idea behind this choice of ùêπ is that in the initial state where ùëü and all ùêø[ùëñ]s are 0, ùêπ equals the up-
per bound we want (shown above), and after the execution, when s[ùëü ] = ùëò, ùêπ equals
ùëñ ‚àà[ùëö] s[ùêø[ùëñ]],
whose expectation is what we want to upper bound.

(cid:0)√ç

(cid:16)

(cid:1)

By the adversary rule ADV-U rule, we need to show that insert preserves ùêπ , i.e., ‚ä¢ {ùêπ }insert ùë• :
T{ùêø,‚Ñé,ùëü },1(ùúè){{ùêπ }}0. We Ô¨Årst use the rule MLET-U. Since read ‚Ñé[ùë•] trivially preserves ùêπ , we need to
show that the if-then-else preserves ùêπ . We use CONSEQ-U to replace the pre-condition‚Äôs ùêπ with
the equivalent (h(ùëè ‚â† ‚àí1) = tti ‚äì ùêπ ) ‚äî (h(ùëè ‚â† ‚àí1) = Ô¨Äi ‚äì ùêπ ). Using the rule MCASE-U, we then
need to prove that the ‚Äúthen‚Äù and ‚Äúelse‚Äù branches preserve ùêπ .

√ç

The else branch is fairly straightforward. We need to show that

‚ä¢ {ùêπ }let ùëê = read ùëü in ùëü := ùëê + 1 : T{ùêø,‚Ñé,ùëü },1(ùúè){{ùêπ }}0.

Using the rules MLET-U, READ-U and WRITE-U, we get

‚ä¢ {ùêπ [s[ùëü ‚Ü¶‚Üí (s[ùëü ] + 1)]/s]}let ùëê = read ùëü in ùëü := ùëê + 1 : T{ùêø,‚Ñé,ùëü },1(ùúè){{ùêπ }}0.
Hence, by CONSEQ-U, it suÔ¨Éces to show that ùêπ ‚â• ùêπ [s[ùëü ‚Ü¶‚Üí (s[ùëü ] + 1)]/s] = ùêπ [(s[ùëü ] + 1)/s[ùëü ]],
which follows immediately because ùêπ is a decreasing function of s[ùëü ] (this uses the fact that each
s[ùêø[ùëñ]] is either 0 or 1).

On the then branch, we take into account the following property of the uniform distribution:

‚ä¢

((ùëö ‚àí 1)/ùëö)

ùëñ ‚àà[ùëö] s[ùêø[ùëñ]]

+ 1

Unif(ùëö)

1 +

ùëñ ‚àà( [ùëö]\{v})s[ùêø[ùëñ]]

.

(1)

To prove this property, we Ô¨Årst note that the post-expectation is equal to

(cid:8)

(cid:0)√ç

(cid:9)(cid:9)

[v ‚àà {ùëñ | s[ùêø[ùëñ]] = 1}] ¬∑

ùëñ ‚àà[ùëö] s[ùêø[ùëñ]]

1 +

ùëñ ‚àà[ùëö] s[ùêø[ùëñ]]

.

(cid:1)

(cid:9)

(cid:8)(cid:8)
+ [v ‚àà {ùëñ | s[ùêø[ùëñ]] = 0}] ¬∑

√ç

By LIN-EXP and UNIF-EXP, the pre-expectation of this with respect to Unif(ùëö) is

(cid:0)

√ç

(1/ùëö)

ùëñ ‚àà[ùëö] s[ùêø[ùëñ]]

+ (1/ùëö)

ùëö ‚àí

ùëñ ‚àà[ùëö] s[ùêø[ùëñ]]

1 +

ùëñ ‚àà[ùëö] s[ùêø[ùëñ]]

,

(cid:0)√ç
ùëñ ‚àà[ùëö] s[ùêø[ùëñ]]

(cid:1)

which equals the pre-expectation of (1).

(cid:1) (cid:0)√ç

(cid:0)√ç

(cid:1)

(cid:0)

√ç

(cid:1) (cid:0)

√ç

We return to the proof of the then branch and reason backwards from the end of the branch.
After going backwards over ‚Ñé[ùë•] := ùë¶; ùêø[ùë¶] := 1; let ùëê = read ùëü in ùëü := ùëê + 1, our pre-expectation
becomes ùêπ [(s[ùëü ‚Ü¶‚Üí s[ùëü ] + 1] [ùêø[ùë¶] ‚Ü¶‚Üí 1]) /s], which expands to

(cid:1)

(cid:1)

1 +

ùëñ ‚àà( [ùëö]\{ùë¶ }) s[ùêø[ùëñ]]

¬∑ ((ùëö ‚àí 1)/ùëö)ùëò‚àís[ùëü ]‚àí1 + ùëö(1 ‚àí ((ùëö ‚àí 1)/ùëö)ùëò‚àís[ùëü ]‚àí1).

Using (1) and linearity to compute the pre-expectation of the sampling command, which is

√ç

(cid:16)

(cid:17)

(ùëö ‚àí 1)/ùëö ¬∑

ùëñ ‚àà[ùëö] s[ùêø[ùëñ]]

+ 1

¬∑ ((ùëö ‚àí 1)/ùëö)ùëò‚àís[ùëü ]‚àí1 + ùëö(1 ‚àí ((ùëö ‚àí 1)/ùëö)ùëò‚àís[ùëü ]‚àí1),

and by some rearranging of the terms, this is equal to

(cid:0)

(cid:0)√ç

ùëñ ‚àà[ùëö] s[ùêø[ùëñ]]

(cid:1)

(cid:1)
¬∑ ((ùëö ‚àí 1)/ùëö)ùëò‚àís[ùëü ] + ùëö(1 ‚àí ((ùëö ‚àí 1)/ùëö)ùëò‚àís[ùëü ]),

which coincides with ùêπ . This concludes the proof.

(cid:1)

(cid:0)√ç

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:17

5 HIGHER-ORDER PROBABILISTIC RELATIONAL LOGIC
In this section, we present a logic (HO-RPL) to reason about relations between two computations.
The syntax of the logic is shown below, where the propositions, assertions and assumptions have
the same meaning as in Section 4.1. Here we note that, although we keep the abstract syntax of
assertions, in this section we consider only their Boolean interpretation, where the connectives are
replaced by their usual Boolean counterparts and hùúôi is equivalent to ùúô. Researching a quantitative
interpretation, where assertions are interpreted as distances, is an interesting direction for future
work.

::= ùëÖ(ùë°1, . . . , ùë°ùëõ) | ‚ä§ | ‚ä• | ùúô ‚àß ùúì | ùúô ‚à® ùúì | ùúô ‚áí ùúì | ¬¨ùúô | ‚àÄùë• : ùúé.ùúô | ‚àÉùë• : ùúé.ùúô

ùúô,ùúì
ùëÉ, ùëÑ ::= ùëì ( Àúùë°1, . . . , Àúùë°ùëõ) | ‚ä§ | ‚ä• | hùúôi | ùëÉ ‚äî ùëÑ | ùëÉ ‚äì ùëÑ

Propositions
Assertions
Assumptions Œ®
Judgments

::= ‚Ä¢ | Œ®, ùúì

Œû | Œî | Œì | Œ® ‚ä¢ ùúô
Œû | Œî | Œì | Œ® ‚ä¢ ùëÉ ‚áõ ùëÑ
Œì | Œ® ‚ä¢ ùë°1 : ùúé1 ‚àº ùë°2 : ùúé2 {ùúô }
Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£1,ùëò1 (ùúé1) ‚àº ùë°2 : TŒ£2,ùëò2 (ùúé2){{ùëÑ }}ùõø

We have already explained the Ô¨Årst two judgments in previous sections. The third form of judg-
ment Œì | Œ® ‚ä¢ ùë°1 : ùúé1 ‚àº ùë°2 : ùúé2 {ùúô } constitutes the non-monadic fragment of the logic and
comes from RHOL [Aguirre et al. 2017], a logic to prove relational properties of pure higher-order
programs directed by the syntax of the programs. In these judgments, Œì, r1, r2 ‚ä¢ ùúô is a HOL for-
mula depending on two distinguished variables r1, r2 that represent the term on the left of the
judgment and the term on the right, respectively. The interpretation is given by the equivalence
Œì | Œ® ‚ä¢ ùë°1 : ùúé1 ‚àº ùë°2 : ùúé2 {ùúô } ‚áî Œì | Œ® ‚ä¢ ùúô [ùë°1/r1] [ùë°2/r2], which follows from the relative
completeness theorem of RHOL. We present the rules for RHOL in the Appendix.

The fourth kind of judgments is new to our presentation, and is introduced to reason about
monadic computations. These have the syntax Œì | Œ® ‚ä¢ {ùëÉ }ùë°1 : TŒ£,ùëò (ùúé1) ‚àº ùë°2 : TŒ£,ùëò (ùúé2){{ùëÑ }}ùõø
where ùëÉ is a Boolean-valued assertion (called the pre-condition) well-formed in the context Œì, s1 :
ùëÄ, s2 : ùëÄ, and ùëÑ is another Boolean-valued assertion (called the post-condition) well-formed in
the context Œì, s1 : ùëÄ, s2 : ùëÄ, v1 : ùúé1, v2 : ùúé2. Here, the variables s1, s2 refer to (resp. left or right-side)
memories, and v1, v2 refer to (resp. left or right-side) result values. Here ùõø is a quantitative bound
taken in an ordered monoid; in the simplest case, the monoid consists of a single element 0. For
the particular interpretation presented in this section, we take the monoid of non-negative reals
with addition. Following the convention of RHOL, we assume that the free variables of ùë°1 and ùë°2
are disjoint.

The semantics of judgments is based on the notion of statistical distance. For a general ùëÑ, the
meaning of the judgment depends on the lifting deÔ¨Åned in Example 6.6. Here we give an intuition
for the case where ùëÑ is of the form s1 = s2 ‚äì v1 = v2, suÔ¨Écient for our examples. If we can derive
Œì | Œ® ‚ä¢ {ùëÉ }ùë°1 : TŒ£,ùëò (ùúè) ‚àº ùë°2 : TŒ£,ùëò (ùúè){{s1 = s2 ‚äì v1 = v2}}ùõø
then for every instantiation of Œì satisfying Œ®, and every pair of initial memories ùëö1, ùëö2 ‚àà ùëÄ, such
that ùëö1, ùëö2 ‚àà ùëÉ, the statistical distance between the output distributions ùë°1 (ùëö1) and ùë°2 (ùëö2) is at
most ùõø, i.e., for every event ùëÜ the absolute diÔ¨Äerence between the probabilities of ùëÜ in ùë°1(ùëö1) and
ùë°2 (ùëö2) is at most ùõø. In particular, when ùë°2 is a renaming of ùë°1, ùõø = 0, and ùëÉ and ùëÑ deÔ¨Åne partial
equivalences on memories, the judgment enforces a form of generalized non-interference.

Monadic and structural rules. Figure 4 presents selected monadic and structural rules. Follow-
ing a pattern that is standard for relational logics, we have 2-sided rules, such as [UNIT ‚àí R],
[MLET ‚àí R], [READ ‚àí R], [WRITE ‚àí R] and [MCASE ‚àí R], where the two expressions have the

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:18

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

same top-level structure, and 1-sided rules, such as [L ‚àí UNIT ‚àí R] and [L ‚àí MLET ‚àí R], which
exclusively consider the top-level construct of one expression. These generalize their unary coun-
terparts. In particular, the rule [MCASE ‚àí R] has an extra assumption ensuring that the two com-
putations go to the same branch, so we only need to prove a relation between the then branches
and a relation between the else branches. A 1-sided rule without this assumption also exists, al-
lowing to consider the 4 possible pairs of branches, but we do not show it here.

Rules for sampling. Our logic also features rules for reasoning about sampling. In contrast to the
other rules, these are only valid to the particular interpretation based on statistical distance that
we present here. We show one rule below:

ùêµ1 ‚äÜ ùêµ2 Ô¨Ånite
Œì | Œ® ‚ä¢ {ùëÉ }Unif (ùêµ1) : T‚àÖ,0 (ùêµ1) ‚àº Unif (ùêµ2) : T‚àÖ,0 (ùêµ2){{hv1 = v2i ‚äì ùëÉ }} |ùêµ1 |/ |ùêµ2 |

SAMPLE-R

The rule is used to compare uniform samplings from two Ô¨Ånite sets. There exists an alternative
rule where ùõø = 0, at the cost of weakening the postcondition; this rule is shown in the appendix.

Œì | Œ® ‚ä¢ ùë°1 : ùúè1 ‚àº ùë°2 : ùúè2 | ùúô

Œì, s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùëÉ

Œì | Œ® ‚ä¢ {ùëÉ }unit(ùë°1) : T‚àÖ,0 (ùúè1) ‚àº unit(ùë°2) : T‚àÖ,0 (ùúè2){{hùúôi ‚äì ùëÉ)}}0
Œì | Œ® ‚ä¢ {ùëÉ }ùë°1 : TŒ£1,ùëò1 (ùúè1) ‚àº ùë°2 : TŒ£2,ùëò2 (ùúè2){{ùëÑ }}ùõø

UNIT-R

ùë•1, ùë•2 ‚àâ ùëÖ

Œì, ùë•1 : ùúè1, ùë•2 : ùúè2 | Œ® ‚ä¢ {ùëÑ [ùë•1/v1] [ùë•2/v2]}ùë¢1 : TŒ£‚Ä≤
Œì | Œ® ‚ä¢ {ùëÉ }let ùë•1 = ùë°1 in ùë¢1 : TŒ£1‚à™Œ£‚Ä≤

(ùúé1) ‚àº ùë¢2 : TŒ£‚Ä≤
(ùúé1) ‚àº let ùë•2 = ùë°2 in ùë¢2 : TŒ£2‚à™Œ£‚Ä≤

2,ùëò‚Ä≤
2

1,ùëò‚Ä≤
1

1,ùëò1+ùëò‚Ä≤
1

(ùúé2){{ùëÖ}}ùõø‚Ä≤

2,ùëò2+ùëò‚Ä≤
2

(ùúé2){{ùëÖ}}ùõø+ùõø‚Ä≤

MLET-R

Œû; Œì | Œ® ‚ä¢ ùëé1 : Loc{ùúì }

Œû; Œì | Œ® ‚ä¢ ùëé2 : Loc{ùúì }

Œì | Œ® ‚ä¢ {ùëÉ [s1 [ùëé1]/v1] [s2 [ùëé2]/v2]}read ùëé1 : T{ùëé1 },0 (V) ‚àº read ùëé2 : T{ùëé2 },0 (V){{ùëÉ }}0

READ-R

Œû; Œì ‚ä¢ ùëé1 : Loc

Œû; Œì ‚ä¢ ùë°1 : V

Œû; Œì ‚ä¢ ùëé2 : Loc

Œû; Œì ‚ä¢ ùë°2 : V

Œì | Œ® ‚ä¢ {ùëÉ [s1 [ùëé1 ‚Ü¶‚Üí ùë°1]/s1] [s1 [ùëé2 ‚Ü¶‚Üí ùë°2]/s1]}ùëé1 := ùë°1 : T{ùëé1 },0 (U) ‚àº ùëé2 := ùë°2 : T{ùëé2 },0 (U){{ùëÉ }}0
Œì | Œ® ‚àß ùëè1 = tt ‚ä¢ {ùëÉ1}ùë°1 : TŒ£1,ùëò1 (ùúè1) ‚àº ùë°2 : TŒ£2,ùëò2 (ùúè2){{ùëÑ }}ùõø
Œì | Œ® ‚ä¢ ùëè1 : B ‚àº ùëè1 : B {ùëè1 = ùëè2}

Œì | Œ® ‚àß ùëè1 = Ô¨Ä ‚ä¢ {ùëÉ2}ùë¢1 : TŒ£1,ùëò1 (ùúè1) ‚àº ùë¢2 : TŒ£2,ùëò2 (ùúè2){{ùëÑ }}ùõø
ùëÉ , (hùëè1 = tti ‚äì ùëÉ1i) ‚äî (hùëè1 = Ô¨Äi ‚äì ùëÉ2)
Œì | Œ® ‚ä¢ {ùëÉ }if ùëè then ùë°1 else ùë¢1 : TŒ£1,ùëò1 (ùúè1) ‚àº if ùëè then ùë°2 else ùë¢2 : TŒ£2,ùëò2 (ùúè2){{ùëÑ }}ùõø

WRITE-R

MCASE-R

Œì | Œ® ‚ä¢ ùë°1 : ùúè1{ùúô }

Œì, s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùëÉ

Œì | Œ® ‚ä¢ {ùëÉ }unit(ùë°1) : T‚àÖ,0 (ùúè1) ‚àº skip : T‚àÖ,0 (U){{hùúôi ‚äì ùëÉ }}0

L-UNIT-R

Œì | Œ® ‚ä¢ {ùëÉ }ùë°1 : TŒ£1,ùëò1 (ùúè1) ‚àº skip : T‚àÖ,0 (U){{ùëÑ }}ùõø

Œì, ùë•1 : ùúè1, ùë•2 : U | Œ® ‚ä¢ {ùëÑ [ùë•1/v1] [ùë•2/v2]}ùë¢1 : TŒ£‚Ä≤

Œì | Œ® ‚ä¢ {ùëÉ }let ùë•1 = ùë°1 in ùë¢1 : TŒ£1‚à™Œ£‚Ä≤

1,ùëò‚Ä≤
1
1,ùëò1+ùëò‚Ä≤
1

(ùúé1) ‚àº ùë¢2 : TŒ£2,ùëò2 (ùúé2){{ùëÖ}}ùõø
(ùúé1) ‚àº ùë¢2 : TŒ£2,ùëò2 (ùúé2){{ùëÖ}}ùõø+ùõø‚Ä≤

ùë•1, ùë•2 ‚àâ ùëÖ

L-MLET-R

Fig. 4. Relational logic: monadic rules

Adversary rule. The adversary rule for the relational setting is similar in spirit to the adversary
rule for the unary setting. However, some mild adjustments are needed. First, we need to modify
the notion of safety for a region Œ£. In the unary case we only required that writing to Œ£ preserves
the invariant. In the relational case, we also need to require that ùúô is also ‚Äúsafe for reading in Œ£‚Äù,
meaning that an adversary reading from two diÔ¨Äerent memories related by ùúô at the same location
in Œ£ sees the same value. This prevents the two executions from diverging due to a read operation:

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:19

Definition 1. Let ùúô be a predicate and Œ£ ‚äÜ Loc. We say that ùúô ‚àà RSafe(Œ£) iÔ¨Ä

‚àÄùëö1, ùëö2, ‚àÄùëô ‚àà Œ£.‚àÄùë£ ‚àà V.ùúô (ùëö1, ùëö2) ‚áí ùúô (ùëö1 [ùëô ‚Ü¶‚Üí ùë£], ùëö2 [ùëô ‚Ü¶‚Üí ùë£]) ‚àß ùëö1 [ùëô] = ùëö2 [ùëô]

The adversary rule also allows us to show that the outputs must be extensionally equal, which
corresponds to the predicate Eqùúè deÔ¨Åned below. The reason to use this as opposed to equality in
the model is that the logical relation we use in the soundness proof corresponds to extensional
equality for non-monadic types:

Eqùëè (ùë•1, ùë•2) , ùë•1 = ùë•2

Eqùúè1‚Üíùúè2
Eqùúè1√óùúè2
The adversary rule can now be stated below:

(ùë•1, ùë•2) , ‚àÄùë¶1, ùë¶2 ‚àà ùúè1.Eqùúè1
(ùë•1, ùë•2) , Eqùúè1

(ùë¶1, ùë¶2) ‚áí Eqùúè1

(ùë•1 ùë¶1, ùë•2 ùë¶2)
(ùúã2 (ùë•1), ùúã2 (ùë•2))

(ùúã1(ùë•1), ùúã1(ùë•2)) ‚àß Eqùúè2

s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùúô

(A : ‚àÄùõº.(ùúé ‚Üí Tùõº,1 (ùúè)) ‚Üí TŒ£‚à™ùõº,ùëò (ùúè ‚Ä≤)) ‚àà Œî

ùúô ‚àà RSafe(Œ£)

ùë•1 ‚àâ ùêπùëâ (ùë°2), ùë•2 ‚àâ ùêπùëâ (ùë°1)

ùúé, ùúè, ùúè ‚Ä≤ non-monadic types

ùë•1 : ùúé, ùë•2 : ùúé | Eqùúé (ùë•1, ùë•2) ‚ä¢ {ùúô }ùë°1 : TŒ£‚Ä≤,1 (ùúè) ‚àº ùë°2 : TŒ£‚Ä≤,1 (ùúè){{hEqùúè (v1, v2)i ‚äì ùúô }}ùõø
Œî | ¬∑ | ¬∑ ‚ä¢ {ùúô }A (ùúÜùë•1.ùë°1) : TŒ£‚à™Œ£‚Ä≤,ùëò (ùúè ‚Ä≤) ‚àº A (ùúÜùë•2.ùë°2) : TŒ£‚à™Œ£‚Ä≤,ùëò (ùúè ‚Ä≤){{hEqùúè‚Ä≤ (v1, v2)i ‚äì ùúô }}ùëòùõø

ADV-R

Informally, the premises of the rule state:
‚Ä¢ ùúô is a safe for the memory region Œ£;
‚Ä¢ if their inputs are extensionally equal and their initial memories are related by ùúô, then the

oracles produce equal outputs and Ô¨Ånal memories related by ùúô, with error ùõø;

‚Ä¢ A is an arbitrary adversary that only writes to and reads from Œ£ and that can call its argu-

ment up to ùëò times

From them, we conclude that executing the adversary with these oracles and initial memories
related by ùúô should yield equal values and output memories related by ùúô, with error ùëòùõø.

Example: PRF/PRP Switching Lemma

We use our logic to show that the probability that an adversary can distinguish between a PRF and
a PRF on bitstrings of Ô¨Åxed length ùëô is upper bounded by ùëò (ùëò+1)
, where ùëò is the maximal number
2ùëô +1
of queries allowed to the adversary. As before, we consider a mild extension of the logic where
the error bound can depend on the oracle counter. For readability, we will generally omit from our
judgments the eÔ¨Äect, adversary and variable contexts, and drop the cost grading from the monadic
types, and omit all reasoning about the size of the domain of ùêø. Our goal is to show:

‚ä¢ {s1 = s2} A PRF : TŒ£‚à™{ùêø },ùëò ({0, 1}) ‚àº A PRP : TŒ£‚à™{ùêø },ùëò ({0, 1}) {{v1 = v2}}ùëò (ùëò+1)/2ùëô +1

By applying the rule [ADV ‚àí R] on the strengthened judgment, we are left to prove:

ùë•1 = ùë•2 ‚ä¢ {s1 = s2}ùëíPRF : T{ùêø } ({0, 1}) ‚àº ùëíPRP : T{ùêø }({0, 1}){{s1 = s2 ‚äì v1 = v2}}ùëñ/2ùëô
where ùëíPRF and ùëíPRP denote the bodies of the PRF and PRP oracles. We then apply the [MCASE ‚àí R]
rule. In the empty else branch, we need to prove:
ùë•1 = ùë•2 ‚ä¢ {s1 = s2}(read ùêø) [ùë•1] : Tùêø ({0, 1}ùëô ) ‚àº (read ùêø) [ùë•2] : Tùêø ({0, 1}ùëô ){{s1 = s2 ‚äì v1 = v2}}ùëñ/2ùëô
which is a simple application of the [READ ‚àí R] rule. In the then branch, we Ô¨Årst apply the
[WRITE ‚àí R] rule, and then we are left to prove:
‚ä¢ {s1 = s2}Unif (ùëã1) : T({0, 1}ùëô ) ‚àº Unif(ùëã2) : Tùêø,1({0, 1}ùëô ){{s1 [ùë•1 ‚Ü¶‚Üí v1] = s2 [ùë•2 ‚Ü¶‚Üí v2]‚äìv1 = v2}}ùëñ/2ùëô
where ùëã1 , {0, 1}ùëô and ùëã2 , {0, 1}ùëô \ im(v[ùêø]). By the rule of consequence, this follows from

‚ä¢ {s1 = s2}Unif(ùëã1) : T({0, 1}ùëô ) ‚àº Unif(ùëã2) : Tùêø,1 ({0, 1}ùëô ){{s1 = s2 ‚äì v1 = v2}}ùëñ/2ùëô

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:20

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

which we prove using the [SAMPLE ‚àí R] rule.

6 SEMANTICS
Now we present the formal semantics for our system. We begin with some background, and follow
with the semantics of the language and the logics, and their soundness theorems.

6.1 The Category of Quasi-Borel spaces and Probability Monad
We will assume knowledge of some concepts of category theory, such as bi-Cartesian closed cat-
egories (bi-CCC) and strong monads, see e.g. [MacLane 1971] for details. In any biCCC C in this
paper, we Ô¨Åx a terminal object (1, !ùëã ‚àà C(ùëã, 1)), and for each pair ùëã, ùëå ‚àà C of objects, we Ô¨Åx a
binary product (ùëã √ó ùëå , ùúã1, ùúã2, h‚àí, ‚àíi), a binary coproduct (ùëã + ùëå , ùúÑ1, ùúÑ2, [‚àí, ‚àí]) and an exponential
object (ùëã ‚áí ùëå , ev, ùúÜ(‚àí)). We also equip C with the symmetric monoidal structure (1, (√ó), ùëô, ùëü , ùëé, ùë†)
induced by the Ô¨Åxed terminal object and binary products.

We will use the category QBS of quasi-Borel spaces [Heunen et al. 2017; ≈öcibior et al. 2017] for
modeling higher-order probabilistic programs introduced in Section 3. The category QBS is a well-
pointed bi-CCC; in fact it has small products and coproducts. For modeling probabilistic choice,
we employ the strong monad (P, ùúÇ P, ùúá P, ùúÉ P) for probability measures over QBSs [Heunen et al.
2017]. For a set ùê¥ and a QBS ùëã , by (ùê¥ ¬∑ ùëã, {ùúÑùê¥,ùëã
: ùëã ‚Üí ùê¥ ¬∑ ùëã }ùëé ‚ààùê¥, [‚àí]ùëé ‚ààùê¥) we mean the coproduct
of ùê¥-many copies of ùëã .

ùëé

We write | ‚àí | : QBS ‚Üí Set for the forgetful functor extracting the carrier set of QBS. It preserves
Ô¨Ånite (actually small) products. To ease calculation, we assume |1| = 1 and |ùëã √ó ùëå | = |ùëã | √ó |ùëå |
(rather than isomorphic). We also assume that the exponential of QBS is deÔ¨Åned so that |ùëã ‚áí
ùëå | = QBS(ùëã, ùëå ). Finally, we write [0, ‚àû]QBS for the QBS of non-negative extended reals.

6.2 Probabilistic State Monad

Starting from this base, which was already presented in [Heunen et al. 2017] we use the state
monad transformer to construct a strong monad given by a functor.

First, we introduce the QBS for memory states. Fix a QBS ùëâ corresponding to type V. The
QBS for memory states is a product (ùëÄ, {ùúãùëé : ùëÄ ‚Üí ùëâ }ùëé ‚ààLoc) of Loc-many copies of ùëâ . We next
introduce a memory update function. Given a QBS morphism ùëì : ùëã ‚Üí ùëâ computing a value from
an environment, we deÔ¨Åne the memory update ùë¢ùëé (ùëì ) : ùëã √ó ùëÄ ‚Üí ùëÄ (at location ùëé ‚àà Loc) to be
the unique morphism satisfying ùúãùëé ‚ó¶ ùë¢ùëé (ùëì ) = ùëì ‚ó¶ ùúã1 and ùúãùëé‚Ä≤ ‚ó¶ ùë¢ùëé (ùëì ) = ùúãùëé‚Ä≤ ‚ó¶ ùúã2 for any ùëé‚Ä≤ ‚â† ùëé. We
then deÔ¨Åne the probabilistic state monad by PS , ùëÄ ‚áí P (‚àí √ó ùëÄ). The unit ùúÇ P S
: ùëã ‚Üí PSùëã ,
multiplication ùúá P S
ùëã,ùëå : ùëã √ó PS(ùëå ) ‚Üí PS(ùëã √ó ùëå ) of this
monad are deÔ¨Åned as:

: PS(PSùëã ) ‚Üí PSùëã and strength ùúÉ P S

ùëã

ùëã

ùúÇ P S , ùúÜ(ùúÇ P

ùëã √óùëÄ )

ùúá P S , ùëÄ ‚áí (ùúá P ‚ó¶ P (ùëíùë£))

ùúÉ P S
ùëã,ùëå

, ùúÜ(Pùõº ‚àí1 ‚ó¶ ùúÉ P ‚ó¶ (ùëã √ó ev) ‚ó¶ ùõº).

6.3 Semantics of the language
As demonstrated by Moggi, the computational metalanguage (the simply typed lambda calculus
with monadic types) is naturally interpreted in any CCC with a strong monad. The semantics of
the language in Section 3 follows the same pattern. To accommodate probabilities we take the
category QBS with the probabilistic state monad PS.

The semantics of types is deÔ¨Åned as objects in QBS, assuming we have an object Jùëèùëñ K for every
base type ùëèùëñ ‚àà ùêµ. Note that the indices of the monad and the quantiÔ¨Åcation over regions are erased

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:21

JŒì ‚ä¢ unit(ùë°) : TŒ£,ùëò (ùúé)K , ùúÇ P S ‚ó¶ JŒì ‚ä¢ ùë° : ùúéK

JŒì ‚ä¢ let ùë• = ùë° in ùë¢ : TŒ£,ùëò (ùúè)K , JŒì, ùë• : ùúé ‚ä¢ ùë¢ : TŒ£,ùëò (ùúè)K#P S ‚ó¶ ùëöŒì,ùë•:ùúé ‚ó¶ ùúÉ P S ‚ó¶ hùëñùëëJŒìK, JŒì ‚ä¢ ùë° : TŒ£,ùëò (ùúé)Ki

JŒì ‚ä¢ read ùëé : TŒ£,ùëò (V)K , ùúÜ(ùúÇ P ‚ó¶ hùúãùëé, ùëñùëëi ‚ó¶ ùúã2)
JŒì ‚ä¢ ùëé := ùë° : TŒ£,ùëò (U)K , ùúÜ(ùúÇ P ‚ó¶ h!, idi ‚ó¶ ùë¢ùëé (JŒì ‚ä¢ ùë° : VK))

JŒì ‚ä¢ sample(ùúà (ùë°1, . . . , ùë°ùëò )) : TŒ£,ùëò (ùúéùúà )K , ùúÜ(ùúó P ‚ó¶ hJùúàK ‚ó¶ hJŒì ‚ä¢ ùë°1 : ùúèùúà,1K, . . . , JŒì ‚ä¢ ùë°ùëò : ùúèùúà, |ùúà |Ki ‚ó¶ ùúã1, ùúã2i)
JŒì ‚ä¢ mfold ùëõ ùë°1 ùë°2 : TŒ£‚à™Œ£‚Ä≤,ùëò+ùêæ ¬∑ùëò‚Ä≤ (ùúé)K ,

foldùêæ ¬∑1,JTŒ£,ùëò (ùúé)K ‚ó¶ hJŒì ‚ä¢ ùëõ : N[ùêæ]K, JŒì ‚ä¢ ùë°1 : TŒ£,ùëò (ùúé)K, KlJŒìK,JTŒ£‚Ä≤,ùëò‚Ä≤ (ùúé)K ‚ó¶ JŒì ‚ä¢ ùë°2 : ùúé ‚Üí TŒ£‚Ä≤,ùëò‚Ä≤ (ùúé)Ki

Fig. 5. Semantics of the language

at the semantic level (below, for a natural number ùêæ, ¬Øùêæ denotes the set {0, ¬∑ ¬∑ ¬∑ , ùêæ }):
JN[ùêæ]K , ¬Øùêæ ¬∑ 1
Jùúé √ó ùúèK , JùúéK √ó JùúèK

JBK , {‚ä•, ‚ä§} ¬∑ 1
Jùúé ‚Üí ùúèK , JùúéK ‚áí JùúèK

JVK , ùëâ JMK , ùëÄ

JTŒ£,ùëò (ùúé)K , PS(JùúéK)

JUK , 1

J‚àÄùõº.ùúèK , JùúèK

This categorical semantics erases the eÔ¨Äect annotations Œ£, ùëò of the monadic type TŒ£,ùëò (ùúè) and
the universal quantiÔ¨Åcation ‚àÄùõº.ùúè over regions, which only play a role in proving soundness of the
adversary rules. Adversary variables are placeholders for closed terms, and do not play any special
role in the semantics. We therefore give a semantics of the language without contexts Œû and Œî.

We interpret the subtyping relation Œû ‚ä¢ ùúè (cid:22) ùúè ‚Ä≤ as a coercion morphism ùëêùúè,ùúè‚Ä≤ : JùúèK ‚Üí Jùúè ‚Ä≤K. Most
of its deÔ¨Ånition is routine, except for the case of natural number type: for ùêæ ‚â§ ùêæ ‚Ä≤, ùëêN[ùêæ ],N[ùêæ ‚Ä≤ ] is
deÔ¨Åned to be the evident morphism ¬Øùêæ ¬∑ 1 ‚Üí ¬Øùêæ ‚Ä≤ ¬∑ 1.

Semantics of a context Œì is given by the Cartesian product of the interpretation of types in Œì. For
convenience, we Ô¨Åx a product (JŒìK, {ùúã Œì
ùë• : JŒìK ‚Üí JŒì(ùë•)K}ùë• ‚ààdom(Œì) ) for each context Œì. For a context
Œì, ùë•1 : ùúè1, ¬∑ ¬∑ ¬∑ , ùë•ùëõ : ùúèùëõ, by ùëöŒì,ùë•1:ùúè1,¬∑¬∑¬∑ ,ùë•ùëõ:ùúèùëõ : JŒìK√ó (Jùúè1K√ó¬∑ ¬∑ ¬∑√óJùúèùëõK) ‚Üí JŒì, ùë•1 : ùúè1, ¬∑ ¬∑ ¬∑ , ùë•ùëõ : ùúèùëõK we mean
the evident isomorphism in QBS. Also, for a well-typed term Œì ‚ä¢ ùë° : ùúè and ùë• ‚àâ dom Œì, we deÔ¨Åne the
Œì‚ä¢ùë°:ùúè
substitution morphism sub
ùë•

: JŒìK ‚Üí JŒì, ùë• : ùúèK to be the composite ùëöŒì,ùë•:ùúè ‚ó¶ hùëñùëëJŒìK, JŒì ‚ä¢ ùë° : ùúèKi.

Well-typed terms Œì ‚ä¢ ùë° : ùúé are interpreted as a morphism in QBS(JŒìK, JùúéK). The interpretation of
monadic types can be found in Figure 5; the interpretation of the non-monadic fragment is standard
and deferred to Appendix E.1. In the Figure, (‚àí)#P S denotes the Kleisli lifting of PS; Klùëã,ùëå : (ùëã ‚áí
PSùëå ) ‚Üí (PSùëã ‚áí PSùëå ) denotes the internal Kleisli lifting; ùúó P
ùëã,ùëå : P (ùëã ) √ó ùëå ‚Üí P (ùëã √ó ùëå ) is
the co-strength, a transformation analogous to the strength but with swapped arguments; and
foldùêæ ¬∑1,ùëã : ùêæ ¬∑ 1 √ó ùëã √ó (ùëã ‚áí ùëã ) ‚Üí ùëã denotes the iterator over the natural numbers up to ùêæ. We
assume that every distribution ùúà with arity ùúèùúà,1 √ó ¬∑ ¬∑ ¬∑ √ó ùúèùúà, |ùúà | ‚Üí ùúéùúà has an interpretation JùúàK of the
proper type Jùúèùúà,1K √ó ¬∑ ¬∑ ¬∑ √ó Jùúèùúà, |ùúà |K ‚Üí PJùúéùúàK. This semantics is sound in the following sense:

Theorem 6.1. Let Œû | Œî | Œì ‚ä¢ ùë° : ùúé be a well-typed term and ‚àÖ ‚ä¢ ùë°ùëñ : Œî(Aùëñ ) be closed terms given

for each Aùëñ ‚àà dom(Œî). Then JŒì ‚ä¢ ùë° [ùë°ùëñ /Aùëñ ]ùõº ‚ààdom Œî : ùúéK ‚àà QBS(JŒìK, JùúéK).

6.4 Heyting-Valued Predicates over QBSs
Formulas and assertions are interpreted in the same way as predicates over QBSs. Recall that a
complete Heyting algebra is a complete lattice ‚Ñ¶ = (Œ©, ‚äë) (whose meet and join are denoted by ‚äì
and ‚äî respectively) together with a pseudo-complement operator ‚áõ.

Definition 2. Let ‚Ñ¶ = (Œ©, ‚äë) be a complete Heyting algebra. An ‚Ñ¶-valued predicate on a QBS ùëã
, Set(|ùëã |, Œ©) to mean the set of ‚Ñ¶-valued predicates on

is a function of type |ùëã | ‚Üí Œ©. DeÔ¨Åne UP‚Ñ¶
ùëã
ùëã .

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:22

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

By the pointwise order, UP‚Ñ¶

mean the Sierpinski space complete Heyting algebra. For ùë• ‚àà |ùëã | and ùëÉ ‚àà UP2
satisÔ¨Åes ùëÉ, denoted by ùë• |= ùëÉ, if and only if ùëÉ (ùë•) = ‚ä§.

ùëã is again a complete Heyting algebra. We deÔ¨Åne 2 , {‚ä• ‚äë ‚ä§} to
ùëã , we say that ùë•

Every 2-valued predicate can be converted into a ‚Ñ¶-valued predicate. DeÔ¨Åne ùêº : UP2

ùëã ‚Üí UP‚Ñ¶
ùëã
by ùêº (ùëÉ) (ùë•) = ‚ä§‚Ñ¶ if ùëÉ (ùë•) = ‚ä§2 and ùêº (ùëÉ) (ùë•) = ‚ä•‚Ñ¶ if ùëÉ (ùë•) = ‚ä•2. This is a complete Heyting algebra
homomorphism, that is, a function preserving all joins, all meets and pseudo-complements.

We introduce a generalized inverse image operation for ‚Ñ¶-valued predicates. For a QBS-morphism
ùëå by ùëì ‚àóùëÉ = ùëÉ ‚ó¶ |ùëì |. This is also a complete Heyting algebra
ùëã and
ùëã . When ‚Ñ¶ = 2, ùëì : ùëÉ ¬§‚Üí ùëÑ is

ùëì : ùëå ‚Üí ùëã , deÔ¨Åne ùëì ‚àó : UP‚Ñ¶
homomorphism. We also introduce a notation: for a QBS morphism ùëì : ùëã ‚Üí ùëå and ùëÉ ‚àà UP‚Ñ¶
ùëÑ ‚àà UP‚Ñ¶
equivalent to stating that for any ùõæ, ùõæ |= ùëÉ implies |ùëì |(ùõæ) |= ùëÑ.

ùëå , we write ùëì : ùëÉ ¬§‚Üí ùëÑ to mean the inequality ùëÉ ‚äë ùëì ‚àóùëÑ in UP‚Ñ¶

ùëã ‚Üí UP‚Ñ¶

We also deÔ¨Åne the partial application of an ‚Ñ¶-valued predicate with an environment. Let Œì, ùë•1 :

ùúè1, ¬∑ ¬∑ ¬∑ , ùë•ùëõ : ùúèùëõ be a context. For a predicate ùëÉ ‚àà UP‚Ñ¶
we mean the predicate ùëÉùõæ (ùëù) = ùëÉ ‚ó¶ |ùëöŒì,ùë•1:ùúè1,¬∑¬∑¬∑ ,ùë•ùëõ:ùúèùëõ |(ùõæ, ùëù). For ùëÉ ‚àà UP‚Ñ¶
ùëÉ ¬§√ó ùëÑ = ùúã ‚àó

1 ùëÉ ‚äì ùúã ‚àó

2ùëÑ.

JŒì,ùë•1:ùúè1,¬∑¬∑¬∑ ,ùë•ùëõ :ùúèùëõ K andùõæ ‚àà |JŒìK|, by ùëÉùõæ ‚àà UP‚Ñ¶

ùëã and ùëÑ ‚àà UP‚Ñ¶

Jùúè1K√ó¬∑¬∑¬∑√óJùúèùëõ K
ùëå , we deÔ¨Åne

Note that we have chosen predicates to be morphisms in Set, rather than morphisms in QBS.
This allows us to avoid reasoning about measurability when deÔ¨Åning predicates and writing spec-
iÔ¨Åcations, while still having a model that works as intended when the predicates are measurable.

6.5 Strong Graded Liftings of the Probability Measure Monad
We introduce a concept called strong graded lifting of strong monads. The following deÔ¨Ånition is
a specialization of the one in [Katsumata 2014] to ‚Ñ¶-valued predicates.

Definition 3 (Heyting-valued strong graded lifting of strong monad). Let (ùê∏, ‚â§, 0, +)
be a partially ordered monoid. An ‚Ñ¶-valued strong ùê∏-graded lifting of P is a family of functions
¬§Pùëã : ùê∏ ‚Üí (UP‚Ñ¶

Pùëã ), implicitly indexed by ùëã ‚àà QBS, satisfying:

ùëã ‚áí UP‚Ñ¶

ùëí ‚â§ ùëí ‚Ä≤ =‚áí ¬§P(ùëí) (ùëÉ) ‚äë ¬§P(ùëí ‚Ä≤) (ùëÉ)

ùëã : ¬§P(ùëí) ( ¬§P(ùëí ‚Ä≤) (ùëÉ)) ¬§‚Üí ¬§P(ùëí + ùëí ‚Ä≤) (ùëÉ)
ùúá P

ùëã : ùëÉ ¬§‚Üí ¬§P(0) (ùëÉ)
ùúÇ P
ùëã : ùëÉ ¬§√ó ¬§P(ùëí) (ùëÑ) ¬§‚Üí ¬§P(ùëí) (ùëÉ ¬§√ó ùëÑ).
ùúÉ P

The following is an informal explanation of liftings, ignoring for the moment the gradings. The
second and third conditions specify how the unit and multiplication of the lifting interact with the
unit and multiplication of the base monad: for a predicate ùëÉ over ùëã and ùë• ‚àà ùëÉ, then ùúÇ (ùë•) ‚àà ¬§P(0) (ùëÉ),
and if ùë• ‚àà ¬§P(ùëí) ( ¬§P(ùëí ‚Ä≤) (ùëÉ)), then ùúá(ùë•) ‚àà ¬§P(ùëí + ùëí ‚Ä≤) (ùëÑ). The fourth condition speciÔ¨Åes a similar
interaction with the strength. These properties are used in proving the soundness of the rules of
our logics. At the level of liftings, gradings can be seen as some additional speciÔ¨Åcation, or as
adding quantitative information to the speciÔ¨Åcation. For instance, in HO-UBL use the grading on
a lifting to specify the probability with which a computation may fail to satisfy the speciÔ¨Åcation.
This is the intuition behind the Ô¨Årst condition in the deÔ¨Ånition: it allows weakenings of the grading
of a lifted predicate, i.e., if ùëí ‚â§ ùëí ‚Ä≤ then ¬§P(ùëí) (ùëÑ) ‚áí ¬§P(ùëí ‚Ä≤) (ùëÑ). We now present some examples of
liftings that we will use in our soundness proofs:

Example 6.2 (Lifting for union bounds). Inspired from the lifting for the union bound introduced
in [Sato et al. 2019, Section 9.1], we give a 2-valued strong ( [0, ‚àû], ‚â§, +, 0)-graded lifting ¬§P ub of P:

¬§P ub
ùëã (ùõø) (ùëÉ) (ùúà) = ‚ä§ ‚áê‚áí ‚àÄùëì ‚àà QBS(ùëã, {0, 1} ¬∑ 1), ùëÉ ‚äë |ùëì | . Pr
ùë•‚àºùúà

[ùëì (ùë•) = 1] ‚â• 1 ‚àí ùõø.

This can be constructed by the graded ‚ä§‚ä§-lifting [Katsumata 2014]. Morally, we want ¬§P ub
ùëã (ùõø) (ùëÉ) (ùúà)
to hold if the probability of sampling a value from ùúá that satisÔ¨Åes ùëÉ is at least 1 ‚àí ùõø. However, we
cannot compute this probability directly because ùëÉ may not be measurable. Instead, we need to

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:23

quantify over all the measurable ùëì above ùëÉ. We can then show that if ùëÉ is indeed measurable (i.e.
ùëÉ = |ùëÉ0| for some QBS-morphism ùëÉ0), Prùë•‚àºùúà [ùëÉ (ùë•) = 0] ‚â§ ùõø holds for every ùúà ‚àà ¬§P ub(ùõø) (ùëÉ). That is,
for measurable predicates, the lifting behaves as intended.

Example 6.3 (Lifting for expectations). We introduce a ( [0, ‚àû], ‚â•)-valued strong ( [0, ‚àû], ‚â§, +, 0)-
graded lifting ¬§P Exp of P. Note that the predicates take values in the Heyting algebra [0, ‚àû] with
reversed order (i.e. ùë• ‚äë ùë¶ iÔ¨Ä ùë¶ ‚â§ ùë•), which will be used to reason about upper bounds. We deÔ¨Åne:
¬§P exp
ùëã (ùõø) (ùëÉ) (ùúà) = sup{ùëÜùõø+ùõø‚Ä≤ (ùëì ‚ôØùúà) | ùëì : ùëã ‚Üí P [0, ‚àû], sup{ùëÜùõø‚Ä≤ (ùëì (ùëñ)) | ùëÉ (ùëñ)<ùëÜùõø‚Ä≤ (ùëì (ùëñ))}<ùëÜùõø+ùõø‚Ä≤ (ùëì ‚ôØùúà)}

where ùëÜùõø (ùúá) = max(0, Eùëü ‚àºùúá [ùëü ] ‚àí ùõø).

This can be constructed by the graded ‚ä§‚ä§-lifting [Katsumata 2014] since ùõø ‚â§ ùõø ‚Ä≤ =‚áí ùëÜùõø ‚äë ùëÜùõø‚Ä≤.
Intuitively, the lifting ¬§P Exp gives an upper bound of expected value of ùëÉ under a distribution ùúà with
margin of error ùõø. In the general case, where ùëÉ is not measurable, we get instead an upper bound
on the expected value of any ùëì : ùëã ¬§‚Üí[0, ‚àû] measurable in QBS such that |ùëì | ‚â§ ùëÉ (i.e. ùëÉ ‚äë |ùëì |).
That, is we obtain ¬§P Exp

ùëã (ùõø) (ùëÉ) (ùúà) ‚äë Eùë• ‚ààùúà [ùëì (ùë•)] ‚àí ùõø.

6.6 Combining liftings and state transformer monads
The material from the previous section allows us to model predicates over the monad P, but we
need to extend it to model predicates over the probabilistic state monad PS that models computa-
tions in our language. The same approach of Ô¨Ånding a lifting of PS does not work directly because
it would not allow us to include the speciÔ¨Åcation about states. Such a lifting would map a ‚Ñ¶-valued
predicate over ùëã to a 2-valued predicate over PSùëã = ùëÄ ‚áí P (ùëã √ó ùëÄ), but this does not match
the shape of triples in our logics. We actually need to lift a pair of ‚Ñ¶-valued predicates over ùëÄ (the
precondition) and over ùëã √ó ùëÄ (the postcondition) into a 2-valued predicate over PSùëã .

P Sùëã ) by ùëì

ùëã √óùëÄ ‚áí UP2

|= ¬§P ¬§Sùëã (ùëí) (ùëÉ, ùëÑ) ‚áê‚áí ùëì

Therefore, we need to Ô¨Ånd a diÔ¨Äerent construction. Assume there exists a ‚Ñ¶-valued strong (ùê∏, ‚â§
, 0, +)-graded lifting ¬§P of P. For each QBS ùëã , we deÔ¨Åne a function ¬§P ¬§Sùëã (‚àí) (‚àí, ‚àí) : ùê∏ ‚Üí (UP‚Ñ¶
ùëÄ √ó
: ùëÉ ¬§‚Üí ¬§P(ùõø) (ùëÑ). Recall that |PSùëã | =
UP‚Ñ¶
QBS(ùëÄ, P (ùëã √ó ùëÄ)). We call ¬§P ¬§S a stateful lifting. This can be seen as a transformer that takes
a ‚Ñ¶-valued strong ùê∏-graded lifting ¬§P of P and returns a stateful lifting of the probabilistic state
transformer monad PS. In plain words, ¬§P ¬§S maps an ‚Ñ¶-valued precondition ùëÉ ‚àà UP‚Ñ¶
ùëÄ and an ‚Ñ¶-
valued postcondition ùëÑ ‚àà UP‚Ñ¶
ùëã √óùëÄ to the computations in PS(ùëã ) that send initial memories in ùëÉ
to distributions over ùëã √ó ùëÄ satisfying the lifted predicate ¬§P(ùëí) (ùëÑ). In a way, this can be seen as
the set of computations ùëì : TŒ£,ùëí (ùúé) satisfying the generalized Hoare triple {ùëÉ }ùëì : TŒ£,ùëò (ùúé){{ùëÑ }}.

This operator is not an ùê∏‚àígraded lifting, because it does not have the appropriate type. However,

properties of ‚Ñ¶-valued strong ùê∏-graded liftings can be extended to ¬§P ¬§S as stated below:

Lemma 1. Let ¬§P be an ‚Ñ¶-valued strong (ùê∏, ‚â§, 1, ¬∑)-graded lifting of P. Let ùëì ‚àà QBS(ùëã √ó ùëÄ, P (ùëå √ó

ùëã √óùëÄ and ùëÜ ‚àà UP‚Ñ¶

ùëå √óùëÄ be predicates. The following holds:

ùëÄ)), and ùëÉ ‚àà UP2

ùëÄ , ùëÖ ‚àà UP‚Ñ¶

ùëã , ùëÑ ‚àà UP‚Ñ¶
: ùëÉ ¬§‚Üí ¬§P ¬§Sùëã (0) (ùëÑ, ùêºùëÉ ¬§√ó ùëÑ)

ùúÇ P S
ùëã
ùëì : ùëÖ ¬§‚Üí ¬§P(ùëí) (ùëÜ) =‚áí (ùúÜ(ùëì ))#P S : ¬§P ¬§Sùëã (ùëí ‚Ä≤) (ùëÑ, ùëÖ) ¬§‚Üí ¬§P ¬§Sùëå (ùëí ‚Ä≤ + ùëí) (ùëÑ, ùëÜ)
ùëã,ùëå : ùëÉ ¬§√ó ¬§P ¬§Sùëå (ùëí) (ùëÑ, ùëÖ) ¬§‚Üí ¬§P ¬§Sùëã √óùëå (ùëí) (ùëÑ, ùúã ‚àó
ùúÉ P S

1 ùêºùëÉ ‚äì ùëÖ)

These consequences can be explained informally by using the language of Hoare logic:
‚Ä¢ The Ô¨Årst consequence states that if ùë• ‚àà ùúô, then {ùëÑ } ùúÇ (ùë•) {{ùúô ‚äì ùëÑ }}0 is a valid generalized

Hoare triple for any ùëÑ.

‚Ä¢ The second consequence gives us a way to sequence computations as in Hoare logic. It states
that if ùëì satisÔ¨Åes {ùëÑ (ùë•, ‚àí)} ùëì (ùë•) {{ùëÖ}}ùëí for every argument ùë•, and ùë° satisÔ¨Åes {ùëÉ } ùë° {{ùëÑ }}ùëí‚Ä≤,

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:24

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

then {ùëÉ } let ùë• = ùë° in ùëì {{ùëÖ}}ùëí+ùëí‚Ä≤ is a valid generalized Hoare triple. Here ùëÑ (ùë•, ‚àí) is the set of
memories ùëö such that (ùë•, ùëö) ‚àà ùëÑ.

‚Ä¢ The third consequence states that if ùë• ‚àà ùúô and we have ùë° such that {ùëÉ } ùë° {{ùëÑ }}ùëí then

{ùëÉ } ùúÉ (ùë•, ùë°) {{ùúô ‚äì ùëÑ }}ùëí is a valid generalized Hoare triple.

6.7 Soundness of the unary logics

We interpret formulas, assertions and entailment relations in the logic by complete Heyting alge-
bras over QBSs. We Ô¨Årst develop the semantics of HOL judgements of the form ‚Ä¢ | ‚Ä¢ | Œì | Œ® ‚ä¢ ùúô,
which is simply denoted by Œì | Œ® ‚ä¢ ùúô. We then interpret an open judgement ùêΩ = Œû | Œî | Œì | Œ® ‚ä¢ ùúô
as the conjunction of all closed instantiations ‚Ä¢ | ‚Ä¢ | Œì‚Ä≤ ‚ä¢ Œ®‚Ä≤ ‚ä¢ Œ¶‚Ä≤ of ùêΩ . Here, each ùõº ‚àà Œû is instan-
ciated with some subset of Loc, and A ‚àà Œî is instanciated with a closed term of type Œî(A). The
semantics of open judgements of UHOL and HO-UBL are similarly deÔ¨Åned. This interpretation is
well-behaved with respect to substitution. In particular, the substitution ùúô [ùë°/ùë•] of ùë• by a term ùë° of
Œì‚ä¢ùë°:ùúè
appropriate type can be interpreted by the inverse image JŒì ‚ä¢ ùúô [ùë°/ùë•]K = (sub
)‚àóJŒì, ùë• : ùúè ‚ä¢ ùúôK.
ùë•
The soundness results of Aguirre et al. [2017] for the base logics HOL and UHOL can be recovered
in this setting, but we defer it to the appendix.

We interpret HO-UBL using the lifting ¬§P ub ¬§S of the probabilistic state monad constructed from

the lifting for the union bound logic ¬§P ub as in Example 6.2. The soundness result is stated as:

Proposition 6.4. Let Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø be a derivable HO-UBL judgment without the

adversary rule. Then, for any ùõæ ‚àà |JŒìK|, ùõæ |= JŒì ‚ä¢

Œ®K implies

JŒì ‚ä¢ ùë° : TŒ£,ùëò (ùúè)K(ùõæ) |= ¬§P ub ¬§S(ùõø) (JŒì, s : M ‚ä¢ ùëÉKùõæ , JŒì, v : ùúè, s : M ‚ä¢ ùëÑKùõæ ).
√ì

Analogously, we interpret HO-EXP using the lifting ¬§P exp ¬§S of the probabilistic state monad con-
structed from the lifting for expectations bound logic ¬§P exp as in Example 6.3. Most of the proof
of the previous result can be reused, and only the rules for sampling and linearity need separate
proofs. The soundness result is stated as:

Proposition 6.5. Let Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø be a derivable HO-UBL judgment without the

adversary rule. Then, for any ùõæ ‚àà |JŒìK|, ùõæ |= JŒì ‚ä¢

Œ®K implies

JŒì ‚ä¢ ùë° : TŒ£,ùëò (ùúè)K(ùõæ) |= ¬§P exp ¬§S(ùõø) (JŒì, s : M ‚ä¢ ùëÉKùõæ , JŒì, v : ùúè, s : M ‚ä¢ ùëÑKùõæ ).
√ì

6.8 Semantics for the relational logics
Let ‚Ñ¶ = (Œ©, ‚äë) be a complete Heyting algebra. To interpret relational logics, we Ô¨Årst deÔ¨Åne the
concept of ‚Ñ¶-valued binary relation between two QBSs ùëã, ùëå . They are simply ‚Ñ¶-valued predicates
over product QBS ùëã √ó ùëå . We thus deÔ¨Åne BR‚Ñ¶
ùëã,ùëå
ùëã,ùëå
and (ùë•, ùë¶) ‚àà |ùëã √ó ùëå | = |ùëã | √ó |ùëå |, we say that (ùë•, ùë¶) satisÔ¨Åes ùëÉ (denoted by (ùë•, ùë¶) |= ùëÉ) if ùëÉ (ùë•, ùë¶) = ‚ä§.
We routinely extend the development in the previous section to ‚Ñ¶-valued binary relations. For
: ùëã ‚Ä≤ ‚Üí ùëå ‚Ä≤, we deÔ¨Åne the pullback operation (ùëì , ùëì ‚Ä≤)‚àó :

ùëã √óùëå . For 2-valued binary relation ùëÉ ‚àà BR2

QBS-morphisms ùëì
ùëã ‚Ä≤,ùëå ‚Ä≤ ‚Üí BR‚Ñ¶
BR‚Ñ¶
We introduce the concept of Heyting-algebra valued strong graded relational lifting.

ùëã,ùëå to be (ùëì √ó ùëì ‚Ä≤)‚àó. We write (ùëì , ùëì ‚Ä≤) : ùëÉ ¬§‚Üí ùëÑ to mean ùëÉ ‚äë (ùëì , ùëì ‚Ä≤)‚àóùëÑ.

: ùëã ‚Üí ùëå and ùëì ‚Ä≤

, UP‚Ñ¶

Definition 4. Let (ùê∏, ‚â§, 0, +) be a partially ordered monoid. An ‚Ñ¶-valued strong ùê∏-graded re-
Pùëã,Pùëå ), implicitly

lational lifting of P is a family of functions ¬§Pùëã,ùëå (‚àí) (‚àí) : ùê∏ ‚Üí (BR‚Ñ¶
indexed by ùëã, ùëå ‚àà QBS, satisfying:

ùëã,ùëå ‚áí BR‚Ñ¶

ùëí ‚â§ ùëí ‚Ä≤ =‚áí ¬§P(ùëí) (ùëÉ) ‚äë ¬§P(ùëí ‚Ä≤) (ùëÉ)
ùëã , ùúá P

ùëå ) : ¬§P(ùëí) ( ¬§P(ùëí ‚Ä≤) (ùëÉ)) ¬§‚Üí ¬§P(ùëí + ùëí ‚Ä≤) (ùëÉ)

(ùúá P

(ùúÇ P
(ùúÉ P

ùëã , ùúÇ P
ùëã , ùúÉ P

ùëå ) : ùëÉ ¬§‚Üí ¬§P(0) (ùëÉ)
ùëå ) : ùëÉ ¬§√ó ¬§P(ùëí) (ùëÑ) ¬§‚Üí ¬§P(ùëí) (ùëÉ ¬§√ó ùëÑ).

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:25

Example 6.6 (Relational lifting for diÔ¨Äerential privacy). Inspired from [Sato 2016], we construct a
2-valued strong graded relational lifting for diÔ¨Äerential privacy by a graded analogue of the coden-
sity lifting [Katsumata et al. 2018]. The grading monoid is the product partially ordered monoid
( [0, ‚àû], ‚â§, 0, +)2.

¬§P dp
ùëã,ùëå (ùúñ, ùõø) (ùëÉ) (ùúà1, ùúà2) = ‚ä§ ‚áê‚áí ‚àÄ(ùëì , ùëî) : ùëÉ ¬§‚ÜíùëÜ (ùúñ ‚Ä≤, ùõø ‚Ä≤) . (ùëì ‚ôØùúà1, ùëî‚ôØùúà2) |= ùëÜ (ùúñ + ùúñ ‚Ä≤, ùõø + ùõø ‚Ä≤)
where (ùúà1, ùúà2) |= ùëÜ (ùúñ, ùõø) ‚áê‚áí Pr
ùëè‚àºùúà1

[ùëè = 0] ‚â§ ùëíùúñ Pr
ùëè‚àºùúà2

[ùëè = 0] + ùõø.

Any morphism ùúíùëÜ : ùëã ‚Üí {0, 1} in QBS standing for the ‚Äúmeasurable‚Äù subset ùëÜ of ùëã , we have
¬§P dp
ùëã,ùëã (ùúñ, ùõø) (Eqùëã ) (ùúá1, ùúá2) = ‚ä§ =‚áí Prùë•‚àºùúá1 [ùë• ‚àà ùëÜ] ‚â§ ùëíùúñ Prùë•‚àºùúá2 [ùë• ‚àà ùëÜ] + ùõø since ùëÜ (0, 0) |= ( ùúíùëÜ , ùúíùëÜ ). A
strong ( [0, ‚àû], ‚â§, 0, +)-graded lifting describing ùúñ-diÔ¨Äerential privacy can be given by ¬§P dp
ùëã,ùëå (ùúñ, 0).
We next introduce the stateful relational lifting, based on a ‚Ñ¶-valued (ùê∏, ‚â§, +, 0)-graded rela-
P Sùëã,P Sùëå )

tional lifting ¬§P of P. It is a function ¬§P ¬§Sùëã,ùëå (‚àí) (‚àí, ‚àí) : ùê∏ ‚Üí (BR‚Ñ¶
deÔ¨Åned for each ùëã, ùëå ‚àà QBS by:

ùëã √óùëÄ,ùëå √óùëÄ ‚áí BR2

ùëã,ùëå √ó BR‚Ñ¶

(ùëì , ùëì ‚Ä≤) |= ¬§P ¬§Sùëã,ùëå (ùëí) (ùëÉ, ùëÑ) ‚áê‚áí (ùëì , ùëì ‚Ä≤) : ùëÉ ¬§‚Üí ¬§P(ùëí) (ùëÑ).

Lemma 1 can then be generalized accordingly. We omit the details.

6.9 Soundness of the relational logics

The semantics of the relational logics are a generalization of the semantics of the unary logics.
We defer soundness of RHOL to the appendix. We interpret the monadic rules in the category of
relations over QBS, with the 2-valued strong [0, ‚àû]2-graded relational lifting ¬§P dp, which induces
¬§P dp ¬§S as in the previous section. The soundness result is stated below. Its proof is by induction on
the derivation and is largely independent of the choice of a speciÔ¨Åc lifting:

Proposition 6.7. Let Œì | Œ® ‚ä¢ {ùëÉ }ùë°1 : TŒ£,ùëò (ùúè1) ‚àº ùë°1 : TŒ£,ùëò (ùúè2){{ùëÑ }}ùõø be a derivable HO-PRL

judgment without the [ADV ‚àí R] rule. Then for any ùõæ ‚àà |JŒìK|, ùõæ |= JŒì ‚ä¢

Œ®K implies
(JŒì ‚ä¢ ùë°1 : TŒ£,ùëò (ùúè1)K(ùõæ), JŒì ‚ä¢ ùë°2 : TŒ£,ùëò (ùúè2)K(ùõæ)) |= ¬§P ¬§S (0, ùõø) (JùëÉKùõæ , JùëÑKùõæ ),
where JùëÉKùõæ , JŒì, s1 : M, s2 : M ‚ä¢ ùëÉKùõæ and ùëÑùõæ , JŒì, s1 : M, v1 : ùúé, s2 : M, v2 : ùúé ‚ä¢ ùëÑKùõæ .

√ì

6.10 Soundness of the adversary rules
To prove soundness of the adversary rules we will use the technique of logical relations. Logical
predicates and relations [Plotkin 1973] are a technique used in programming language theory
to prove properties such as strong normalization or contextual equivalence. The idea of logical
relations (or predicates) is that they allow us to prove that all inhabitants of a certain type ùúè satisfy
a particular property L (ùúè) that is deÔ¨Åned inductively on the structure of types, rather than terms.
For instance, in the unary case, we deÔ¨Åne a logical predicate Lùúô,ùõø (¬∑) indexed by an assertion ùúô
over memories and a real ùõø ‚â• 0. For every type ùúé, Lùúô,ùõø (ùúé) corresponds to a set of closed terms. We
defer the details of this deÔ¨Ånition to the appendix, here it suÔ¨Éces to know that Lùúô,ùõø (TŒ£,ùëò (ùúè)) is the
set of computations that preserve the invariant ùúô with error probability ùëò ¬∑ùõø and that return a result
in Lùúô,ùõø (ùúè) (i.e., they satisfy the triple {ùúô } _ {{ùúô ‚àßv ‚àà Lùúô,ùõø (ùúè)}}ùëò ¬∑ùõø ), and as usual, if ùë° ‚àà Lùúô,ùõø (ùúé ‚Üí ùúè)
and ùë¢ ‚àà Lùúô,ùõø (ùúé) then ùë° ùë¢ ‚àà Lùúô,ùõø (ùúè). Then we prove a Basic Lemma: any closed term ùë° of type
ùúè inhabits the predicate Lùúô,ùõø (ùúè) if ùúô ‚àà Safe(EÔ¨Ä (ùúè)). This has a rather natural interpretation: if ùúô
does not depend on any location in EÔ¨Ä (ùúè), then it must be preserved after running ùë°.

The adversary rule [ADV ‚àí U] can then be proven sound from the Basic Lemma. By inspecting
its premises, we know that A inhabits the logical relation LùëÉ,ùõø (‚àÄùõº.(ùúé ‚Üí Tùõº,1(ùúè)) ‚Üí TŒ£‚à™ùõº,ùëò (ùúè ‚Ä≤)),
because ùëÉ ‚àà Safe(Œ£). We also have that ùúÜùë• .ùë° inhabits the logical relation LùëÉ,ùõø (ùúé ‚Üí TŒ£‚Ä≤,1 (ùúè)),

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:26

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

because we have a derivation of this fact (note that the Basic Lemma cannot be applied, because ùëÉ
may not be safe for Œ£‚Ä≤). Then, we can conclude that running A with ùúÜùë• .ùë° as argument inhabits the
logical relation LùëÉ,ùõø (TŒ£‚à™ùõº,ùëò (ùúè ‚Ä≤)), and therefore must preserve ùëÉ. The techniques then generalize
to the relational case, where we deÔ¨Åne a logical relation for every type, and then we prove a Basic
Lemma for it. Soundness of [ADV ‚àí R] is a consequence of this Lemma.

Proposition 6.8. The [ADV ‚àí U] and [ADV ‚àí R] rules are sound.

7 RELATED WORK

Reasoning about adversaries. Garg et al. [2010]; Jia et al. [2015] develop Ô¨Årst- and higher-order pro-
gram logics to reason about safety properties of Ô¨Årst-order concurrent and stateful programs in-
teracting with adversaries. Both provide rules to reason about adversaries, morally similar to ours.
Our context of adversary variables representing closed programs traces lineage to a similar idea
based on comonads in Jia et al. [2015]. Devriese et al. [2016] develop semantic principles to reason
about adversaries, cast in terms of parametricity properties of side-eÔ¨Äects, an idea they call ‚ÄúeÔ¨Äect
parametricity‚Äù. They use these principles to verify code that uses object capabilities. No syntactic
proof rules are developed. These works cover only the boolean, deterministic, unary setting.

Closer to our work, Barthe et al. [2009] deÔ¨Åne a probabilistic relational Hoare logic (pRHL) for
reasoning about the security of cryptographic constructions. Their logic applies to a probabilis-
tic imperative language with adversarial calls and features a proof rule for adversaries. Our rule
for the relational, non-quantitative setting closely matches their rule. Barbosa et al. [2021] formal-
ize a resource-aware module system used in EasyCrypt to reason about adversaries. There are
commonalities between their approach and ours: they view an adversary as a functor, whereas
we view an adversary as an expression of second-order type. However, the technicalities are very
diÔ¨Äerent, since they build their system on top of an imperative language. A further diÔ¨Äerence
is that they account for the computational cost of adversaries, which we left aside in this work.
Other similar approaches for reasoning about adversaries include Computational Indistinguisha-
bility Logic [Barthe et al. 2010], and state-separating proofs [Brzuska et al. 2018]. However, these
approaches are developed in an abstract mathematical setting, not in the context of a programming
language.

Barthe et al. [2016a] deÔ¨Åne an adversary rule for reasoning about diÔ¨Äerential privacy in a quan-
titative variant of pRHL; their rule uses bounds on the number of oracle queries to derive privacy
bounds of adversarial computations from privacy bounds of oracles. Barthe et al. [2016b] deÔ¨Åne a
Union Bound logic to reason about accuracy of adversarial computations for a similar language.
However, their proof rule is restricted to adversaries without oracles. We are not aware of any
prior work on adversarial computations in the quantitative setting.

Program logics for probabilistic computations. We relate our program logics to existing approaches
for reasoning about probabilistic computations. For brevity, we only discuss approaches not dis-
cussed before. Kozen [1985] introduces expectation-based reasoning for a core probabilistic pro-
gramming language. Morgan et al. [1996] deÔ¨Åne a weakest pre-expectation calculus. Aguirre et al.
[2021] develop a variant of the calculus for relational properties. Kaminski et al. [2016] show how
similar ideas can be used for reasoning about expected cost. All these works share the setting of
a probabilistic imperative language. Aguirre and Katsumata [2020] show that expectation-based
reasoning remains sound in a higher-order setting, but their semantics is based on set theory, not
Quasi-Borel spaces, so they cannot model continuous distributions. They also do not provide proof
systems.

There exist adaptations of (approximate) probabilistic relational Hoare logic in the higher-order
setting, starting from [Barthe et al. 2014a]. However, these adaptations have a set-theoretical or

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:27

topos of trees semantics and only support distributions over discrete base types. Sato et al. [2019]
introduce an expressive logic for a language similar to ours but without state and adversary. Their
model is also based on QBS. Tassarotti and Harper [2019] develop a logic to prove relational prop-
erties of higher-order programs that combine probabilities and non-determinism. They do not
support all the kinds of reasoning we do, and the relations they can prove are between a program
and an speciÔ¨Åcation, rather than between two programs. Maillard et al. [2020] deÔ¨Åne a framework,
embedded in a relational dependent type theory, for deÔ¨Åning and reasoning about program logics
for general monadic eÔ¨Äects. While their work is based on Dijkstra monads, ours is more closely
related to Hoare monads [Nanevski et al. 2013, 2008]. Our work extends Hoare monads to support
Heyting-valued predicates, probabilistic programs, grading and adversarial reasoning.

Program equivalence. There is a very large body of methods for proving program equivalence,
and in particular contextual equivalence, in higher-order languages with state, probabilities, and
eÔ¨Äects; see e.g. [Benton et al. 2014; Bizjak and Birkedal 2015; Crubill√© and Lago 2015; Jung et al.
2015; Matache and Staton 2019; Pitts and Stark 1998]. Many of these methods have been applied
to reason about security and privacy, using the natural view of adversaries as contexts. These meth-
ods are not comparable with ours: our relational logic can prove a richer set of speciÔ¨Åcations (for
instance, the postcondition needs not be an equivalence relation). However, they cannot establish
some basic equivalences, e.g. swapping of two sampling instructions, due to the speciÔ¨Åc way the
logic constructs couplings. We also conjecture that our logics are easier to extend to richer settings,
such as multi-stage and multi-adversary security notions (see e.g. [Ristenpart et al. 2011]). Finally,
these methods cannot be used to reason about unary properties.

8 CONCLUDING REMARKS

We conclude the paper with a discussion of additional examples that can be handled by the three
logics we have presented (and by small extensions to the logics), and a discussion of how we can
extend our framework with unbounded recursion.

Other examples. HO-UBL can verify the accuracy of diÔ¨Äerentially private mechanisms such as
the Sparse Vector algorithm [Dwork and Roth 2014], since accuracy can be formulated as the prob-
ability that the noisy answer is close to the actual answer. We have already worked out this example
but, for reasons of space, we defer it to the appendix.

The bounded leakage model is a model of leakage-resilient cryptography in which the adver-
sary is given access to a leakage oracle which takes as input a function with a small codomain and
returns the output of this function applied to the secret state. A (partially formalized) proof of secu-
rity of a pseudo-random generator in the bounded leakage model is given in [Barthe et al. 2014b].
HO-PRL can be used to verify this proof, using either a Ô¨Årst- or a higher-order representation of
leakage.

Other examples can be veriÔ¨Åed with extensions to our logics that can also be proved sound
in our framework. For instance, we can support a slightly diÔ¨Äerent relational logic in which the
Hoare quadruple is indexed by a pair (ùúñ, ùõø), and interpreted using the lifting from Example 6.6.
With this logic, we can study diÔ¨Äerential privacy of mechanisms such as the exponential mecha-
nism on non-numerical queries [Dwork and Roth 2014], which uses a scoring function that assigns
positive values to all possible input/output pairs. Prior work [Barthe et al. 2012], has veriÔ¨Åed this
mechanism using a Ô¨Årst-order representation of scoring. However, we can verify a higher-order
representation of this mechanism, where the scoring function is passed as an argument to the
mechanism.

We can also use HO-EXP to verify examples based on the weakest pre-expectation calculus [Morgan et al.

1996]. One caveat is that many of these examples use arbitrary while loops, which our language

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:28

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

does not currently support. This extension would require extending the model as discussed at the
end of this section. Other examples, e.g., stability of machine learning algorithms, would require
developing a logic for relational pre-expectations. Yet others, e.g. cryptography, would require en-
riching our logics with additional proof principles that embed notions of cryptographic reductions.
In the long run, it would be interesting to support these formalisms with an implementation to
mechanize examples.

Unbounded recursion. Our language provides bounded recursion via the monadic fold. An inter-
esting follow-up would be to extend our language with unbounded monadic recursion. For this,
we would also need to change the semantic model. One possibility is to use the recently proposed
category ùúîQBS [V√°k√°r et al. 2019] to interpret types.

ACKNOWLEDGMENTS

S.K. was supported by ERATO HASUO Metamathematics for Systems Design Project (No. JPM-
JER1603), Japan Science and Technology Agency. T.S. was supported by JSPS KAKENHI Grant
Number 20K19775, Japan. M.G. was supported by NSF awards CCF-2040222 and CCF-1718220.

REFERENCES
Alejandro Aguirre, Gilles Barthe, Marco Gaboardi, Deepak Garg, and Pierre-Yves Strub. 2017. A relational logic for higher-

order programs. PACMPL 1, ICFP (2017), 21:1‚Äì21:29. https://doi.org/10.1145/3110265

Alejandro Aguirre, Gilles Barthe, Justin Hsu, Benjamin Lucien Kaminski, Joost-Pieter Katoen, and Christoph Matheja. 2021.
A Pre-Expectation Calculus for Probabilistic Sensitivity. Proc. ACM Program. Lang. 5, POPL, Article 52 (Jan. 2021),
28 pages. https://doi.org/10.1145/3434333

Alejandro Aguirre and Shin-ya Katsumata. 2020. Weakest preconditions in Ô¨Åbrations. (2020). Accepted at MFPS‚Äô20.
Robert J Aumann et al. 1961. Borel structures for function spaces. Illinois Journal of Mathematics 5, 4 (1961), 614‚Äì630.
Manuel Barbosa, Gilles Barthe, Benjamin Gr√©goire, Adrien Koutsos, and Pierre-Yves Strub. 2021. Mechanized Proofs of
Adversarial Complexity and Application to Universal Composability. Cryptology ePrint Archive, Report 2021/156.
https://eprint.iacr.org/2021/156.

Gilles Barthe, Marion Daubignard, Bruce M. Kapron, and Yassine Lakhnech. 2010. Computational indistinguishabil-
ity logic. In Proceedings of the 17th ACM Conference on Computer and Communications Security, CCS 2010, Chicago,
Illinois, USA, October 4-8, 2010, Ehab Al-Shaer, Angelos D. Keromytis, and Vitaly Shmatikov (Eds.). ACM, 375‚Äì386.
https://doi.org/10.1145/1866307.1866350

Gilles Barthe, Thomas Espitau, Benjamin Gr√©goire, Justin Hsu, and Pierre-Yves Strub. 2018. Proving expected sensitivity

of probabilistic programs. Proc. ACM Program. Lang. 2, POPL (2018), 57:1‚Äì57:29. https://doi.org/10.1145/3158145

Gilles Barthe, No√©mie Fong, Marco Gaboardi, Benjamin Gr√©goire, Justin Hsu, and Pierre-Yves Strub. 2016a. Advanced Prob-
abilistic Couplings for DiÔ¨Äerential Privacy. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Com-
munications Security, Vienna, Austria, October 24-28, 2016, Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel,
Andrew C. Myers, and Shai Halevi (Eds.). ACM, 55‚Äì67.

Gilles Barthe, C√©dric Fournet, Benjamin Gr√©goire, Pierre-Yves Strub, Nikhil Swamy, and Santiago Zanella B√©guelin. 2014a.
Probabilistic relational veriÔ¨Åcation for cryptographic implementations. In POPL 2014, Suresh Jagannathan and Peter
Sewell (Eds.).

Gilles Barthe, Marco Gaboardi, Benjamin Gr√©goire, Justin Hsu, and Pierre-Yves Strub. 2016b. A Program Logic for Union
Bounds. In 43rd International Colloquium on Automata, Languages, and Programming, ICALP 2016, July 11-15, 2016, Rome,
Italy (LIPIcs, Vol. 55), Ioannis Chatzigiannakis, Michael Mitzenmacher, Yuval Rabani, and Davide Sangiorgi (Eds.). Schloss
Dagstuhl - Leibniz-Zentrum fuer Informatik, 107:1‚Äì107:15. https://doi.org/10.4230/LIPIcs.ICALP.2016.107

Gilles Barthe, Benjamin Gr√©goire, and Santiago Zanella B√©guelin. 2009. Formal certiÔ¨Åcation of code-based cryptographic

proofs. In POPL 2009, Savannah, GA, USA, January 21-23, 2009. https://doi.org/10.1145/1480881.1480894

Gilles Barthe, Boris K√∂pf, Laurent Mauborgne, and Mart√≠n Ochoa. 2014b. Leakage Resilience against Concurrent Cache

Attacks. In Proc. 3rd Conference on Principles of Security and Trust (POST ‚Äô14). Springer.
Gilles Barthe, Boris K√∂pf, Federico Olmedo, and Santiago Zanella B√©guelin. 2012.

reasoning for diÔ¨Äerential privacy.
https://doi.org/10.1145/2103656.2103670

In POPL 2012, Philadelphia, Pennsylvania, USA,

Probabilistic relational
January 22-28, 2012.

Nick Benton, Martin Hofmann, and Vivek Nigam. 2014. Abstract eÔ¨Äects and proof-relevant logical relations. In The 41st An-
nual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ‚Äô14, San Diego, CA, USA, January

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:29

20-21, 2014, Suresh Jagannathan and Peter Sewell (Eds.). ACM, 619‚Äì632. https://doi.org/10.1145/2535838.2535869
Ales Bizjak and Lars Birkedal. 2015. Step-Indexed Logical Relations for Probability. In FoSSaCS 2015, London, UK, April

11-18, 2015. Proceedings.

Burton H. Bloom. 1970. Space/Time Trade-oÔ¨Äs in Hash Coding with Allowable Errors. Commun. ACM 13, 7 (1970), 422‚Äì426.

https://doi.org/10.1145/362686.362692

Chris Brzuska, Antoine Delignat-Lavaud, C√©dric Fournet, Konrad Kohbrok, and Markulf Kohlweiss. 2018. State Separation
for Code-Based Game-Playing Proofs. In Advances in Cryptology - ASIACRYPT 2018 - 24th International Conference on the
Theory and Application of Cryptology and Information Security, Brisbane, QLD, Australia, December 2-6, 2018, Proceedings,
Part III (Lecture Notes in Computer Science, Vol. 11274), Thomas Peyrin and Steven D. Galbraith (Eds.). Springer, 222‚Äì249.
https://doi.org/10.1007/978-3-030-03332-3_9

David Clayton, Christopher Patton, and Thomas Shrimpton. 2019. Probabilistic Data Structures in Adversarial Environ-
ments. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, CCS 2019, London,
UK, November 11-15, 2019, Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz (Eds.). ACM, 1317‚Äì
1334. https://doi.org/10.1145/3319535.3354235

Rapha√´lle Crubill√© and Ugo Dal Lago. 2015. Metric Reasoning about ùúÜ-Terms: The AÔ¨Éne Case. In 30th Annual ACM/IEEE
Symposium on Logic in Computer Science, LICS 2015, Kyoto, Japan, July 6-10, 2015. IEEE Computer Society, 633‚Äì644.
https://doi.org/10.1109/LICS.2015.64

Vincent Danos and Thomas Ehrhard. 2011. Probabilistic coherence spaces as a model of higher-order probabilistic compu-

tation. Inf. Comput. 209, 6 (2011), 966‚Äì991. https://doi.org/10.1016/j.ic.2011.02.001

Dominique Devriese, Lars Birkedal, and Frank Piessens. 2016. Reasoning about Object Capabilities with Logical Relations

and EÔ¨Äect Parametricity. In IEEE European Symposium on Security and Privacy (EuroS&P). 147‚Äì162.

Cynthia Dwork and Aaron Roth. 2014. The Algorithmic Foundations of DiÔ¨Äerential Privacy. Foundations and Trends in

Theoretical Computer Science 9, 3‚Äì4 (2014), 211‚Äì407. http://dx.doi.org/10.1561/0400000042

Deepak Garg, Jason Franklin, Dilsun Kirli Kaynar, and Anupam Datta. 2010. Compositional System Security with Interface-

ConÔ¨Åned Adversaries. Electr. Notes Theor. Comput. Sci. 265 (2010), 49‚Äì71.

Thomas Gerbet, Amrit Kumar, and C√©dric Lauradoux. 2015. The Power of Evil Choices in Bloom Filters. In 45th Annual
IEEE/IFIP International Conference on Dependable Systems and Networks, DSN 2015, Rio de Janeiro, Brazil, June 22-25, 2015.
IEEE Computer Society, 101‚Äì112. https://doi.org/10.1109/DSN.2015.21

Chris Heunen, Ohad Kammar, Sam Staton, and Hongseok Yang. 2017. A convenient category for higher-order probability
theory. In 32nd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2017, Reykjavik, Iceland, June 20-23,
2017. IEEE Computer Society, 1‚Äì12. https://doi.org/10.1109/LICS.2017.8005137

R. Impagliazzo and S. Rudich. 1989. Limits on the provable consequences of one-way permutations. In 21st Annual ACM

Symposium on Theory of Computing, 1989. ACM, New York, 44‚Äì61.

Kenneth E. Iverson. 1962. A Programming Language. John Wiley & Sons, Inc., USA.
Limin Jia, Shayak Sen, Deepak Garg, and Anupam Datta. 2015. A Logic of Programs with Interface-ConÔ¨Åned Code. In IEEE

28th Computer Security Foundations Symposium (CSF). 512‚Äì525.

Ralf Jung, David Swasey, Filip Sieczkowski, Kasper Svendsen, Aaron Turon, Lars Birkedal, and Derek Dreyer. 2015. Iris:
Monoids and Invariants as an Orthogonal Basis for Concurrent Reasoning. In Proceedings of the 42nd Annual ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2015, Mumbai, India, January 15-17, 2015,
Sriram K. Rajamani and David Walker (Eds.). ACM, 637‚Äì650. https://doi.org/10.1145/2676726.2676980

Benjamin Lucien Kaminski,

est Precondition Reasoning
https://doi.org/10.1007/978-3-662-49498-1_15

Joost-Pieter Katoen, Christoph Matheja, and Federico Olmedo. 2016.
9632.

of Probabilistic Programs, Vol.

for Expected Run-Times

Weak-
364‚Äì389.

Shin-ya Katsumata. 2014. Parametric EÔ¨Äect Monads and Semantics of EÔ¨Äect Systems. In Proceedings of the 41st ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (San Diego, California, USA) (POPL ‚Äô14). Associ-
ation for Computing Machinery, New York, NY, USA, 633‚Äì645. https://doi.org/10.1145/2535838.2535846

Shin-ya Katsumata, Tetsuya Sato, and Tarmo Uustalu. 2018. Codensity Lifting of Monads and its Dual. Log. Methods

Comput. Sci. 14, 4 (2018). https://doi.org/10.23638/LMCS-14(4:6)2018

Dexter Kozen. 1985. A Probabilistic PDL. 30, 2 (1985), 162‚Äì178.
Saunders MacLane. 1971. Categories for the Working Mathematician. Springer-Verlag, New York. Graduate Texts in

Mathematics, Vol. 5.

Kenji Maillard, Catalin Hritcu, Exequiel Rivas, and Antoine Van Muylder. 2020. The next 700 relational program logics.

Proc. ACM Program. Lang. 4, POPL (2020), 4:1‚Äì4:33.

Cristina Matache and Sam Staton. 2019. A Sound and Complete Logic for Algebraic EÔ¨Äects. In Foundations of Soft-
ware Science and Computation Structures - 22nd International Conference, FOSSACS 2019, Held as Part of the European
Joint Conferences on Theory and Practice of Software, ETAPS 2019, Prague, Czech Republic, April 6-11, 2019, Proceed-
ings (Lecture Notes in Computer Science, Vol. 11425), Mikolaj Bojanczyk and Alex Simpson (Eds.). Springer, 382‚Äì399.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:30

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

https://doi.org/10.1007/978-3-030-17127-8_22

Carroll Morgan, Annabelle McIver, and Karen Seidel. 1996. Probabilistic Predicate Transformers. 18, 3 (1996), 325‚Äì353.
Aleksandar Nanevski, Anindya Banerjee, and Deepak Garg. 2013.

Dependent Type Theory for VeriÔ¨Åcation
ACM Trans. Program. Lang. Syst. 35, 2 (2013), 6:1‚Äì6:41.

of Information Flow and Access Control Policies.
https://doi.org/10.1145/2491522.2491523

Aleksandar Nanevski, J. Gregory Morrisett, and Lars Birkedal. 2008. Hoare type theory, polymorphism and separation. J.

Funct. Program. 18, 5-6 (2008), 865‚Äì911. https://doi.org/10.1017/S0956796808006953

Moni Naor and Eylon Yogev. 2019. Bloom Filters in Adversarial Environments. ACM Trans. Algorithms 15, 3 (2019), 35:1‚Äì

35:30. https://doi.org/10.1145/3306193

Andrew Pitts and Ian Stark. 1998. Operational Reasoning for Functions with Local State.

In Higher Order Operational
Techniques in Semantics, Andrew Gordon and Andrew Pitts (Eds.). Publications of the Newton Institute, Cambridge
University Press, 227‚Äì273. http://www.inf.ed.ac.uk/~stark/operÔ¨Ç.html

Gordon Plotkin. 1973. Lambda-deÔ¨Ånability and logical relations.
Thomas Ristenpart, Hovav Shacham, and Thomas Shrimpton. 2011. Careful with Composition: Limitations of the IndiÔ¨Äeren-
tiability Framework. In Advances in Cryptology - EUROCRYPT 2011 - 30th Annual International Conference on the Theory
and Applications of Cryptographic Techniques, Tallinn, Estonia, May 15-19, 2011. Proceedings (Lecture Notes in Computer
Science, Vol. 6632), Kenneth G. Paterson (Ed.). Springer, 487‚Äì506. https://doi.org/10.1007/978-3-642-20465-4_27

Tetsuya Sato. 2016. Approximate Relational Hoare Logic for Continuous Random Samplings. In The Thirty-second Confer-
ence on the Mathematical Foundations of Programming Semantics, MFPS 2016, Carnegie Mellon University, Pittsburgh, PA,
USA, May 23-26, 2016 (Electronic Notes in Theoretical Computer Science, Vol. 325), Lars Birkedal (Ed.). Elsevier, 277‚Äì298.
https://doi.org/10.1016/j.entcs.2016.09.043

Tetsuya Sato, Alejandro Aguirre, Gilles Barthe, Marco Gaboardi, Deepak Garg, and Justin Hsu. 2019. Formal veriÔ¨Åcation of
higher-order probabilistic programs: reasoning about approximation, convergence, Bayesian inference, and optimiza-
tion. PACMPL 3, POPL (2019), 38:1‚Äì38:30. https://dl.acm.org/citation.cfm?id=3290351

Adam ≈öcibior, Ohad Kammar, Matthijs V√°k√°r, Sam Staton, Hongseok Yang, Yufei Cai, Klaus Ostermann, Sean K. Moss,
Chris Heunen, and Zoubin Ghahramani. 2017. Denotational Validation of Higher-order Bayesian Inference. Proc. ACM
Program. Lang. 2, POPL, Article 60 (Dec. 2017), 29 pages. https://doi.org/10.1145/3158148

Joseph Tassarotti and Robert Harper. 2019. A Separation Logic for Concurrent Randomized Programs. Proc. ACM Program.

Lang. 3, POPL, Article 64 (Jan. 2019), 30 pages. https://doi.org/10.1145/3290377

Matthijs V√°k√°r, Ohad Kammar, and Sam Staton. 2019. A domain theory for statistical probabilistic programming. PACMPL

3, POPL (2019), 36:1‚Äì36:29. https://dl.acm.org/citation.cfm?id=3290349

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:31

A SUBTYPING AND ADDITIONAL TYPING RULES
We present here the subtyping rules (Figure 6) and the typing rules for expressions about memories
(Figure 7).

Œû ‚ä¢ ùúè (cid:22) ùúè ‚Ä≤

Œû ‚ä¢ ùúè ‚Ä≤ (cid:22) ùúè ‚Ä≤‚Ä≤

Œû ‚ä¢ ùêµ (cid:22) ùêµ

Œû ‚ä¢ ùúè (cid:22) ùúè ‚Ä≤

Œû ‚ä¢ ùúè (cid:22) ùúè ‚Ä≤‚Ä≤
Œû ‚ä¢ ùúé (cid:22) ùúé ‚Ä≤

Œû ‚ä¢ ùúè √ó ùúé (cid:22) ùúè ‚Ä≤ √ó ùúé ‚Ä≤

ùêæ ‚â§ ùêæ ‚Ä≤
Œû ‚ä¢ N[ùêæ] (cid:22) N[ùêæ ‚Ä≤]

Œû ‚ä¢ ùúè ‚Ä≤ (cid:22) ùúè

Œû ‚ä¢ ùúé (cid:22) ùúé ‚Ä≤

Œû ‚ä¢ ùúè ‚áí ùúé (cid:22) ùúè ‚Ä≤ ‚áí ùúé ‚Ä≤

Œû ‚ä¢ Œ£ ‚äÜ Œ£‚Ä≤

Œû ‚ä¢ ùúè (cid:22) ùúè ‚Ä≤
ùëò ‚â§ ùëò ‚Ä≤
Œû ‚ä¢ TŒ£,ùëò (ùúè) (cid:22) TŒ£‚Ä≤,ùëò‚Ä≤ (ùúè ‚Ä≤)
Œû ‚ä¢ ùúè (cid:22) ùúè ‚Ä≤
Œû ‚ä¢ ‚àÄùõº.ùúè (cid:22) ‚àÄùõº.ùúè ‚Ä≤

Fig. 6. Subtyping rules. Here, Œû ‚ä¢ Œ£ ‚äÜ Œ£‚Ä≤ for Œû = ùõº1, . . . , ùõºùëõ if for every Œ£1, . . . , Œ£ùëõ ‚äÜ Loc we have
Œ£[Œ£1/ùõº1] . . . [Œ£ùëõ/ùõºùëõ] ‚äÜ Œ£‚Ä≤ [Œ£1/ùõº1] . . . [Œ£ùëõ/ùõºùëõ].

Œì ‚ä¢ Àúùë° : M

ùëé ‚àà Loc

Œì ‚ä¢ Àúùë° : M

Œì ‚ä¢ Àúùë° [ùëé] : V

Œì ‚ä¢ Àúùë¢ : V
Œì ‚ä¢ Àúùë° [ùëé ‚Ü¶‚Üí Àúùë¢] : M

ùëé ‚àà Loc

Fig. 7. Typing rules for memory access

B ADDITIONAL PROOF RULES

We Ô¨Årst present the standard well-formed rules for HOL assertions in Figure 8. The extended
Hoare triples and quadruples from our logics can be internalized into HOL. To this end, we add
a predicate former Hùúé,ùõø (ùëÉ, ùë°, ùëÑ) that internalizes the monadic judgments into. This predicates are
well-formed when ùëÉ is a well-formed assertion (which may contain a variable for the state s : M),
ùëÑ is a well-formed assertion (which may contain variables for the state s : M, and the result v : ùúé)
and ‚ä¢ ùë° : TŒ£,ùëò (ùúé). The interpretation is equivalent to the corresponding monadic judgment. We add
rules to switch between systems in Figure 9.

We also introduce a relational analog of this predicate, via a predicate former Hùúé,ùúè,ùëòùõø (ùëÉ, ùë°1, ùë°2, ùëÑ).

Morally, this is valid whenever

ùëÖ ‚äÜ ùë°1 : ùúè1 √ó ¬∑ ¬∑ ¬∑ √ó ùë°ùëò : ùúèùëò

Œì ‚ä¢ ùë°1 : ùúè1 . . . Œì ‚ä¢ ùë°ùëò : ùúèùëò

Œì ‚ä¢ ùúô1

Œì ‚ä¢ ùúô2

Œì ‚ä¢ ùúô1

Œì ‚ä¢ ùúô2

Œì ‚ä¢ ùëÖ(ùë°1, . . . , ùë°ùëò )

Œì ‚ä¢ ùúô1 ‚àß ùúô2

Œì ‚ä¢ ùúô1 ‚áí ùúô2

Œì, ùë• : ùúè ‚ä¢ ùúô
Œì ‚ä¢ ‚àÄùë•.ùúô

Œì, ùë• : ùúè ‚ä¢ ùúô
Œì ‚ä¢ ‚àÉùë•.ùúô

Fig. 8. Selected well-formedness rules of HOL

C PROOFS OF SOUNDNESS OF THE ADVERSARY RULES
C.1 Soundness of the [ADV ‚àí U] rule
To prove soundness of the adversary rules we will use logical relations. Logical predicates and
relations [Plotkin 1973] are a technique used in programming language theory to prove properties
such as strong normalization or contextual equivalence. The idea of logical relations (or predicates)

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:32

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

Œì | Œ® ‚ä¢ ùúô [ùë°/r]
Œì, s : ùëÄ ‚ä¢ ùëÉ
Œì | Œ® ‚ä¢ Hùúé,0 (ùúô, unit(ùë°), ùëÉ ‚àß ùúô)

Hùêº

Œì | Œ® ‚ä¢ Hùúé,ùõø (ùëÉ, ùë°, ùëÑ)

Œì, ùë• : ùúé | Œ® ‚ä¢ Hùúè,ùõø‚Ä≤ (ùëÑ [ùë•/v], ùë¢, ùëÖ)

Œì | Œ® ‚ä¢ Hùúè,ùõø+ùõø‚Ä≤ (ùëÉ, let ùë• = ùë° in ùë¢, ùëÑ)

Hùê∏

Fig. 9. HOL rules for internalized triples

Œì | Œ® ‚ä¢ ùúô1

Œì | Œ® ‚ä¢ ùúô2

Œì | Œ®, ùúô ‚ä¢ ùúô Ax

Œì | Œ® ‚ä¢ ùúô1 ‚àß ùúô2

Œì | Œ® ‚ä¢ ùúô1 ‚àß ùúô2
Œì | Œ® ‚ä¢ ùúô1
Œì | Œ® ‚ä¢ ùúô1 ‚áí ùúô2

‚àßùê∏

Œì | Œ®, ùúô1 ‚ä¢ ùúô2
Œì | Œ® ‚ä¢ ùúô1 ‚áí ùúô2
Œì | Œ® ‚ä¢ ùúô1

‚àßùêº

‚áíùêº

‚áíùê∏

Œì | Œ® ‚ä¢ ùúô2

Fig. 10. Selected HOL rules

Œì ‚ä¢ ùë• : ùúé

Œì | Œ® ‚ä¢ ùúô [ùë•/r]

Œì | Œ® ‚ä¢ ùë• : ùúé{ùúô }

U-VAR

Œì, ùë• : ùúè | Œ®, ùúô ‚Ä≤ ‚ä¢ ùë° : ùúé{ùúô }
Œì | Œ® ‚ä¢ ùúÜùë• : ùúè.ùë° : ùúè ‚Üí ùúé{‚àÄùë•.ùúô ‚Ä≤ ‚áí ùúô [r ùë•/r]}

U-ABS

Œì | Œ® ‚ä¢ ùë° : ùúè ‚Üí ùúé{‚àÄùë•.ùúô ‚Ä≤ [ùë•/r] ‚áí ùúô [r ùë•/r]}
Œì | Œ® ‚ä¢ ùë° ùë¢ : ùúé{ùúô [ùë¢/ùë•]}

Œì | Œ® ‚ä¢ ùë¢ : ùúè {ùúô ‚Ä≤}

U-APP

Œì | Œ® ‚ä¢ ùë° : ùúé{ùúô ‚Ä≤}

Œì | Œ® ‚ä¢ ùúô ‚Ä≤ [ùë°/r] ‚áí ùúô [ùë°/r]

Œì | Œ® ‚ä¢ ùë° : ùúé{ùúô }

Œì | Œ® ‚ä¢ ùë° : ùúé{ùëè ‚áí ùúô }

Œì | Œ® ‚ä¢ ùë¢ : ùúé{¬¨ùëè ‚áí ùúô }

Œì | Œ® ‚ä¢ if ùëè then ùë° else ùë¢ : ùúé{ùúô }

U-SUB

U-CASE

Fig. 11. Selected UHOL rules

is that they allow us to prove that all inhabitants of a certain type satisfy a particular property that
is deÔ¨Åned inductively on the structure of types, rather than terms.

We now deÔ¨Åne an indexed logical predicate Lùúô,ùõø mapping types to predicates (more concretely,
it maps a type ùúè to a set of closed terms of type ùúè). The logical predicate is indexed by an invariant
ùúô, which is a predicate over memories and a real ùõø ‚àà [0, 1] and it is deÔ¨Åned as follows:

Lùúô,ùõø (ùêµ) , {ùëè : ùêµ}

Lùúô,ùõø (ùúé ‚Üí ùúè) ,

{ùë° : ùúé ‚Üí ùúè | ‚àÄùë• : ùúé.ùë• ‚àà Lùúô,ùõø (ùúé) ‚áí (ùë° ùë•) ‚àà Lùúô,ùõø (ùúè)}
{ùë° : ùúé ‚Üí ùúè | ‚àÄùë• : ùúé.(ùë° ùë•) ‚àà Lùúô,ùõø (ùúè)}

if EÔ¨Ä (ùúé) ‚äÜ EÔ¨Ä (ùúè)
otherwise

(

Lùúô,ùõø (ùúé √ó ùúè) , {ùë° : ùúé √ó ùúè | ùúã1 (ùë°) ‚àà Lùúô,ùõø (ùúé) ‚àß ùúã2 (ùë°) ‚àà Lùúô,ùõø (ùúè)}

Lùúô,ùõø (TŒ£,ùëò (ùúé)) , {ùë° : TŒ£,ùëò (ùúé) | Hùúé,ùëòùõø (ùúô, ùë°, v ‚àà Lùúô,ùõø (ùúé) ‚àß ùúô)}

Lùúô,ùõø (‚àÄùõº.ùúè) , {ùë° : ‚àÄùõº.ùúè | ‚àÄŒ£.ùë° ‚àà Lùúô,ùõø (ùúè [Œ£/ùõº])}

The deÔ¨Ånition of the logical predicate involves two subtleties. First note that there are two
diÔ¨Äerent deÔ¨Ånitions of the logical predicate for arrow types, depending on whether the eÔ¨Äect of

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:33

Œì, ùë•1 : ùúè1, ùë•2 : ùúè2 | Œ®, ùúô ‚Ä≤ ‚ä¢ ùë°1 : ùúé1 ‚àº ùë°2 : ùúé2 {ùúô }
Œì | Œ® ‚ä¢ ùúÜùë•1 : ùúè1.ùë°1 : ùúè1 ‚Üí ùúé1 ‚àº ùúÜùë•2 : ùúè2.ùë°2 : ùúè2 ‚Üí ùúé2 {‚àÄùë•1, ùë•2.ùúô ‚Ä≤ ‚áí ùúô [r1 ùë•1/r1] [r2 ùë•2/r2]}
Œì | Œ® ‚ä¢ ùë°1 : ùúè1 ‚Üí ùúé1 ‚àº ùë°2 : ùúè2 ‚Üí ùúé2 {‚àÄùë•1, ùë•2.ùúô ‚Ä≤ [ùë•1/r1] [ùë•2/r2] ‚áí ùúô [r1 ùë•1/r1] [r2 ùë•2/r2]}
Œì | Œ® ‚ä¢ ùë¢1 : ùúè1 ‚àº ùë¢2 : ùúè2 {ùúô ‚Ä≤}
Œì | Œ® ‚ä¢ ùë°1ùë¢1 : ùúé1 ‚àº ùë°2ùë¢2 : ùúé2 {ùúô [ùë¢1/ùë•1] [ùë¢2/ùë•2]}

ABS

APP

Œì ‚ä¢ ùë•1 : ùúé1

Œì ‚ä¢ ùë•2 : ùúé2

Œì | Œ® ‚ä¢ ùúô [ùë•1/r1] [ùë•2/r2]

Œì | Œ® ‚ä¢ ùë•1 : ùúé1 ‚àº ùë•2 : ùúé2 {ùúô }
Œì, ùë•1 : ùúè1 | Œ®, ùúô ‚Ä≤ ‚ä¢ ùë°1 : ùúé1 ‚àº ùë°2 : ùúé2 {ùúô }
Œì | Œ® ‚ä¢ ùúÜùë•1 : ùúè1.ùë°1 : ùúè1 ‚Üí ùúé1 ‚àº ùë°2 : ùúé2 {‚àÄùë•1.ùúô ‚Ä≤ ‚áí ùúô [r1 ùë•1/r1]}

VAR

ABS-L

Œì | Œ® ‚ä¢ ùë°1 : ùúè1 ‚Üí ùúé1 ‚àº ùë¢2 : ùúé2 {‚àÄùë•1.ùúô ‚Ä≤ [ùë•1/r1] ‚áí ùúô [r1 ùë•1/r1]}
Œì | Œ® ‚ä¢ ùë°1ùë¢1 : ùúé1 ‚àº ùë¢2 : ùúé2 {ùúô [ùë¢1/ùë•1]}

Œì | Œ® ‚ä¢ ùë¢1 : ùúé1{ùúô ‚Ä≤}

APP-L

ùúô [ùë•1/r1] ‚àà Œ®

r2 ‚àâ ùêπùëâ (ùúô)

Œì ‚ä¢ ùë°2 : ùúé2

Œì | Œ® ‚ä¢ ùë•1 : ùúé1 ‚àº ùë°2 : ùúé2 {ùúô }

VAR-L

Fig. 12. Selected RHOL rules

the argument is contained in the eÔ¨Äect of the result. The idea is that if it is not, then the argument
is ignored, so we do not need to require that it satisÔ¨Åes the logical predicate. Otherwise, we get
the usual deÔ¨Ånition: a function satisÔ¨Åes the logical predicate for ùúé ‚Üí ùúè if arguments that satisfy
the predicate for ùúé get mapped to results satisfying the predicate the predicate for ùúè. The second
subtlety is that the deÔ¨Ånition ignores the Ô¨Årst grading of the monad. A diÔ¨Äerent deÔ¨Ånition, without
indexing the predicate by ùúô and deÔ¨Åning instead:

Lùõø (TŒ£,ùëò (ùúé)) , {ùë° : TŒ£,ùëò (ùúé) | ‚àÄùúô ‚àà Safe(Œ£).Hùúé,ùëòùõø (ùúô, ùë°, v ‚àà Lùúô,ùõø (ùúé) ‚àß ùúô)}

would impose overly strong conditions on monadic types that appear in argument position.
Namely, it would force us to prove that they preserve all the invariants that are safe for a given
region Œ£, but we only know that the oracle preserves a particular invariant ùúô. Note however that
the grading ùëò is used to scale the grading of the lifting. The grading Œ£ of the monad is used in the
premise of the Basic Lemma, which we now state, using the notion of safety that we deÔ¨Åned in
Section 4.1.

Lemma 2 (Basic lemma). Let ¬§P be as above, and assume that for every ùúà ‚àà Œî, sample(ùúàùúé ) ‚àà
¬§P0(Lùúô,ùõø (ùúé)). Let ‚ä¢ ùë° : ùúé be a closed term, and s : ùëÄ ‚ä¢ ùúô such that ùúô ‚àà Safe(EÔ¨Ä (ùúé)). Then, for all
ùõø ‚â• 0, ùë° ‚àà Lùúô,ùõø (ùúé).

Proof. We actually prove a generalization of the Basic Lemma, which makes the cases of ab-
straction and application easier to handle. We omit the adversary context from the proof, but note
that this extends easily since they must be replaced by closed terms of the appropriate type.

Lemma 3. Let Œû; Œì, Œì‚Ä≤ ‚ä¢ ùë° : ùúé be a well-typed term and ùúô a predicate over memories such that
ùúô ‚àà Safe(EÔ¨Ä (ùúé) \ Œû). Assume further that for every (ùë• : ùúè) ‚àà Œì‚Ä≤, EÔ¨Ä (ùúè) * EÔ¨Ä (ùúé) and that Œû ‚ä¢ ùúâ is
an instantiation of the context Œû. Let also Œìùúâ ‚ä¢ ùõæ, Œì‚Ä≤ùúâ ‚ä¢ ùõæ ‚Ä≤ be instantiations of the typing contexts. If
ùõæ is such that ùõæ (ùë•ùëñ) ‚àà Pùúô,ùõø (ùúéùëñ) for every (ùë•ùëñ : ùúéùëñ ) ‚àà Œì, then ùë°ùõæùõæ ‚Ä≤ ‚àà Pùúô,ùõø (ùúéùúâ).

This can be proven by induction on the typing derivation. We show a few cases, omitting the Œû

context when irrelevant.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:34

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

‚Ä¢ Variable. We have Œì, Œì‚Ä≤ ‚ä¢ ùë• : ùúé, and by assumption, ùë• cannot be in Œì‚Ä≤. Therefore, also by

assumption, Jùë•ùõæK ‚àà Lùúô,ùõø (ùúé).

‚Ä¢ Abstraction. Assume ùúô ‚àà Safe(EÔ¨Ä (ùúé ‚Üí ùúè)). If EÔ¨Ä (ùúé) ‚äÜ EÔ¨Ä (ùúè), then also ùúô ‚àà Safe(EÔ¨Ä (ùúé)).

We apply I.H., and we have that

ùë°ùõæ [ùë• ‚Ü¶‚Üí ùë¢]ùõæ ‚Ä≤ ‚àà Lùúô,ùõø (ùúè)
for all ùë¢ ‚àà Lùúô,ùõø (ùúé). Therefore, (ùúÜùë• .ùë°)ùõæùõæ ‚Ä≤ ‚àà Lùúô,ùõø (ùúé, ùúè).
If EÔ¨Ä (ùúé) * EÔ¨Ä (ùúè), then by I.H., for all ùë¢ : ùúé, ùë°ùõæ (ùõæ ‚Ä≤[ùë• ‚Ü¶‚Üí ùë¢]) ‚àà Lùúô,ùõø (ùúè). Therefore, (ùúÜùë• .ùë°)ùõæùõæ ‚Ä≤ ‚àà
Lùúô,ùõø (ùúé, ùúè) too.

‚Ä¢ Application. By I.H., ùë°ùõæùõæ ‚Ä≤ ‚àà Lùúô,ùõø (ùúé ‚Üí ùúè). If EÔ¨Ä (ùúé) ‚äÜ EÔ¨Ä (ùúè), then by I.H. we also have
ùë¢ùõæùõæ ‚Ä≤ ‚àà Lùúô,ùõø (ùúé), and therefore by deÔ¨Ånition (ùë° ùë¢)ùõæùõæ ‚Ä≤ ‚àà Lùúô,ùõø (ùúé). Otherwise, by deÔ¨Ånition of
the logical predicate we have again (ùë° ùë¢)ùõæùõæ ‚Ä≤ ‚àà Lùúô,ùõø (ùúé).

‚Ä¢ Unit. WLOG we can assume that Œì‚Ä≤ = ‚àÖ. We have that ùúô ‚àà safe(EÔ¨Ä (TŒ£(ùúé))), so also ùúô ‚àà

safe(EÔ¨Ä (ùúé))). By I.H., ùë°ùõæ ‚àà Lùúô,ùõø (ùúé). By the properties of ¬§P :

(unit(ùë°))ùõæ ‚àà Hùúé,0 (ùúô, ‚àí, v ‚àà Lùúô,ùõø (ùúé) ‚àß ùúô)

‚Ä¢ Bind. WLOG we can assume that Œì‚Ä≤ = ‚àÖ. Our premises are Œì ‚ä¢ ùë° : TŒ£ (ùúè) and Œì, ùë• : ùúè ‚ä¢
ùë¢ : TŒ£‚Ä≤ (ùúé), and by assumption, Œ¶ ‚àà Safe(Œ£ ‚à™ Œ£‚Ä≤ ‚à™ EÔ¨Ä (ùúè) ‚à™ EÔ¨Ä (ùúé)). Therefore, Œ¶ ‚àà Safe(Œ£ ‚à™
EÔ¨Ä (ùúè)) and Œ¶ ‚àà Safe(Œ£‚Ä≤ ‚à™ EÔ¨Ä (ùúé)). So we can apply I.H. to both premises. For the Ô¨Årst one,
we have that

and for the second one, we have that for all ùëí ‚àà Lùúô,ùõø (ùúé),

ùë°ùõæ ‚àà Hùúé,ùëòùõø (ùúô, ‚àí, v ‚àà Lùúô,ùõø (ùúé) ‚àß ùúô)

ùë¢ùõæ [ùë• ‚Ü¶‚Üí ùëí] ‚àà Hùúè,ùëò‚Ä≤ùõø (ùúô, ‚àí, v ‚àà Lùúô,ùõø (ùúè) ‚àß ùúô)

By properties of the lifting, we get

(let ùë• = ùë° in ùë¢)ùõæ ‚àà Hùúè,(ùëò+ùëò‚Ä≤)ùõø (ùúô, ‚àí, v ‚àà Lùúô,ùõø (ùúè) ‚àß ùúô)

‚Ä¢ Forall introduction. By assumption, Œû, ùõº; Œì ‚ä¢ ùë° : ùúè, and ùúô ‚àà Safe(EÔ¨Ä (‚àÄùõº.ùúè) \ Œû), so ùúô ‚àà
Safe(EÔ¨Ä (ùúè) \ (Œû ‚à™ ùõº)). For all Œû ‚ä¢ ùúâ and Œ£, by I.H., ùë°ùõæ ‚àà Lùúô,ùõø (ùúèùúâ [ùõº ‚Ü¶‚Üí Œ£]), and therefore
(Œõùõº.ùë°)ùõæ ‚àà Lùúô,ùõø (‚àÄùõº.ùúè).

‚Ä¢ Forall elimination. By assumption, Œû; Œì ‚ä¢ ùë° : ‚àÄùõº.ùúè and ùúô ‚àà Safe(EÔ¨Ä (ùúè [Œ£/ùõº]) \ Œû). Recall that
EÔ¨Ä (‚àÄùõº.ùúè) = EÔ¨Ä (ùúè [‚àÖ/ùõº]). Since EÔ¨Ä (ùúè [‚àÖ/ùõº]) ‚äÜ EÔ¨Ä (ùúè [Œ£/ùõº])\Œû, then also ùúô ‚àà Safe(EÔ¨Ä (‚àÄùõº.ùúè)\
Œû) (in other words, if the eÔ¨Äect is smaller, then the predicate is still safe). Therefore, we can
apply I.H., and we get that for Œû ‚ä¢ ùúâ ùë°ùõæ ‚àà Lùúô,ùõø (‚àÄùõº.ùúèùúâ). From this, we can conclude that
ùë° [Œ£]ùõæ ‚àà Lùúô,ùõø (ùúè [Œ£/ùõº]ùúâ).

And from this, we can conclude:

Corollary 1. The [ADV ‚àí U] rule is sound.

Proof. By the premise on A, safety of ùúô and the Basic Lemma, we can prove that

On the other hand, by the assumption on the oracle we have that:

A ‚àà Lùúô,ùõø (‚àÄùõº.(ùúé ‚Üí Tùõº,1(ùúè)) ‚Üí TŒ£‚à™ùõº,ùëò (ùúè ‚Ä≤))

From this, we can derive:

ùúÜùë• .ùë° ‚àà Lùúô,ùõø (ùúé ‚Üí TŒ£‚Ä≤,1 (ùúè))

A [Œ£‚Ä≤] (ùúÜùë• .ùë°) ‚àà Lùúô,ùõø (TŒ£‚à™Œ£‚Ä≤,ùëò (ùúè ‚Ä≤))

and the conclusion follows directly.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

(cid:3)

(cid:3)

Higher-order probabilistic adversarial computations

93:35

Soundness of the [ADV ‚àí R] rule
We generalize the logical predicates to the relational case. For an invariant s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùúô and
ùõø ‚àà [0, ‚àû] we deÔ¨Åne a logical relation, i.e., a map from a type ùúé to pairs of closed terms of type ùúé
as follows:

Rùúô,ùõø (ùêµ) , {ùëè1, ùëè2 : ùêµ | ùëè1 = ùëè2}

Rùúô,ùõø (ùúé ‚Üí ùúè) ,

Rùúô,ùõø (ùúé √ó ùúè) ,

‚àÄùë¢1, ùë¢2 : ùúé.(ùë¢1, ùë¢2) ‚àà Rùúô,ùõø (ùúé)
‚áí (ùë°1 ùë¢1, ùë°2 ùë¢2) ‚àà Rùúô,ùõø (ùúè)

ùë°1, ùë°2 : ùúé ‚Üí ùúè
(cid:12)
(
(cid:12)
(cid:12)
{ùë°1, ùë°2 : ùúé ‚Üí ùúè | ‚àÄùë¢1, ùë¢2 : ùúé.(ùë°1 ùë¢1, ùë°2 ùë¢2) ‚àà Rùúô,ùõø (ùúè)}
(cid:12)
(cid:12)
(ùúã1 (ùë°1), ùúã1 (ùë°2)) ‚àà Rùúô,ùõø (ùúé)
‚àß (ùúã2(ùë°1), ùúã2(ùë°2)) ‚àà Rùúô,ùõø (ùúè)

Ô£±Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥
ùë°1, ùë°2 : ùúé √ó ùúè
Ô£≥
(cid:26)

)

(cid:27)

Rùúô,ùõø (TŒ£,ùëò (ùúé)) , {ùë°1, ùë°2 : TŒ£,ùëò (ùúé) | Hùúé,ùëòùõø (ùúô, ùë°1, ùë°2, (v1, v2) ‚àà Rùúô,ùõø (ùúé) ‚àß ùúô)}

Rùúô,ùõø (‚àÄùõº.ùúè) , {ùë°1, ùë°2 : ‚àÄùõº.ùúè | ‚àÄŒ£.(ùë°1 [Œ£], ùë°2 [Œ£]) ‚àà Rùúô,ùõø (ùúè [Œ£/ùõº])}

(cid:12)
(cid:12)
(cid:12)
(cid:12)

if EÔ¨Ä (ùúé) ‚äÜ EÔ¨Ä (ùúè)

otherwise

The deÔ¨Ånition is analogous to the unary case. Note that the relation at the base types changes, we
now require equality to ensure that the computations have the same control Ô¨Çow. We state now
the Basic Lemma:

Lemma 4 (Basic lemma). Let ¬•P be as above, and assume that for every ùúà ‚àà D, (sample(ùúà), sample(ùúà)) ‚àà
(0,0) (Rùúô,ùõø (ùêµ)). Let ‚ä¢ ùë° : ùúé be a closed term and s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùúô such that ùúô ‚àà RSafe(EÔ¨Ä (ùúé)). Then,

¬•P dp
for all ùúñ, ùõø ‚â• 0, (ùë°, ùë°) ‚àà Rùúô,ùõø (ùúé)

Proof. The proof is very similar to the unary case, by Ô¨Årst stating a generalization and then
(cid:3)

proving it by induction on the typing judgment.

By instantiating the Basic Lemma at the type of adversaries, we get the following:

Corollary 2. The [ADV ‚àí R] rule is sound.

D ADDITIONAL EXAMPLES

D.1 Example: Accuracy for diÔ¨Äerentially private mechanisms
DiÔ¨Äerential privacy [Dwork and Roth 2014] is a family of techniques focused on preventing queries
from databases from revealing private data about the entries in the database. Concretely, we want
to have plausible deniability that a concrete entry is in the database. This is usually achieved by
making the queries through a mechanism, an algorithm that adds randomness to the output of
the queries before releasing them. Privacy comes with the tradeoÔ¨Ä of accuracy; the randomness
that diÔ¨Äerentially private mechanisms add means that the result of the query cannot be exact.
Nonetheless, we can often give bounds about how large the error can be.

In this example we will verify an accuracy bound for a diÔ¨Äerentially private mechanism known
as Sparse Vector (SV) algorithm. This algorithm is used to make ùëò numerical queries (i.e., queries
whose output is a number) to a database, and answering for how many of them the result is above
some threshold ùëá . It can also be modelled in an online manner [Barthe et al. 2016b], in which an
adversary makes the queries one by one and observes the result (whether it is above or below the
threshold) before deciding which query to make next.

As in many diÔ¨Äerentially private mechanisms, the randomness in the SV algorithm comes from

a Laplace distribution, which has the following rule:

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:36

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

Œì | Œ® ‚ä¢ ùë° : R

Œì | Œ® ‚ä¢ {ùëÉ }Lapùúñ (ùë°) : T‚àÖ,0 (R){{ùëÉ ‚àß |v ‚àí ùë° | ‚â§

LAP-UBL

1
ùúñ

log

1
ùõø

}}ùõø

What this rule is saying is: (1) sampling does not change the state, and (2) with probability 1 ‚àíùõø,

the value sampled from Lapùúñ (ùë°) will be within an interval of radius
words, it tells us how accurate it is to replace ùë° by Lapùúñ (ùë°).

1
ùúñ

1
ùõø

log

centered at ùë°. In other

We model the SV algorithm by having an oracle that provides access to the database. The codes

of the oracle and the main algorithm are given below:

O(ùëû : R ‚Üí R) :
ùë• = evalQ (ùëû);
let ùë¶ = Lapùúñ/4(ùë•) in
let ùë° ‚Ä≤ = read ùë° in
ùëß = if ùë¶ ‚â• ùë° ‚Ä≤ then tt else Ô¨Ä;
ùëé[ùëü ] := ùëß;
ùëè [ùëü ] := ùë•;
inc ùëü ;
unit(ùëß);

mainSV(ùëá : R) :

let ùë• = Lapùúñ/2(ùëá ) in
ùë° := ùë•;
ùëü := 0;
A(O);

The oracle runs the query ùëû, adds Laplace noise to its result, checks whether it is above the
threshold ùë°, and returns its result to the adversary. For the veriÔ¨Åcation process, we add some ghost
variables: ùëü records the round number, ùëè is an array containing the noiseless result of the queries,
and ùëé records whether the noisy queries are above the threshold.

In the main procedure, we simply initialize the ùë° variable by adding noise to the threshold ùëá , set
the auxiliary variables to 0 and then instantiate the adversary with the oracle O. We want to show
the following accuracy bound

‚ä¢ {‚ä§}mainSV(ùëá ) : T{ùëé,ùëè,ùëü,ùë° },1(R){{‚àÄùëñ ‚â§ ùëò.Œ¶(ùëñ)}}ùõΩ

where Œ¶ is deÔ¨Åned as:

Œ¶(ùëñ) , (s[ùëé[ùëñ]] = tt ‚áí s[ùëè [ùëñ]] ‚â• ùëá ‚àí

6
ùúñ

log

ùëò + 1
ùõΩ

) ‚àß (s[ùëé[ùëñ]] = Ô¨Ä ‚áí s[ùëè [ùëñ]] ‚â§ ùëá +

6
ùúñ

log

ùëò + 1
ùõΩ

)

For this, we will use the adversary rule, with the invariant:

Œ¶‚Ä≤( ùëó ) = |ùëá ‚àí s[ùë°] | ‚â§

2
ùúñ

log

ùëò + 1
ùõΩ

‚àß ‚àÄùëñ ‚â§ ùëó .Œ¶(ùëñ)

The Ô¨Årst part of the invariant states how close the noisy threshold is to the original threshold ùëá ,
while the second part states an accuracy bound on the Ô¨Årst ùëó queries. The key part of the proof is
showing that O preserves the invariant for any query, that is:

‚ä¢ {Œ¶‚Ä≤(ùëü )}O(ùëû){{Œ¶‚Ä≤(ùëü )}}ùõΩ/(ùëò+1)

We will ellaborate further on this part of the proof. We go backwards from the end of the procedure,
and we will use the notation ‚åäO(ùëû)‚åãùëõ to denote the program formed by the Ô¨Årst ùëõ instructions of
O(ùëû). Since the last instruction is ùëü := ùëü + 1, we can apply the [WRITE] rule, and we need to show

‚ä¢ {Œ¶‚Ä≤(ùëü )}‚åäO(ùëû)‚åã5{{|ùëá ‚àí s[ùë°] | ‚â§

2
ùúñ

log

ùëò + 1
ùõΩ

‚àß ‚àÄùëñ ‚â§ ùëü + 1.Œ¶(ùëñ)}}ùõΩ/(ùëò+1)

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:37

Since our precondition contains already ‚àÄùëñ ‚â§ ùëü .Œ¶(ùëñ) and ùë° does not change, the only interesting
part is proving Œ¶(ùëü + 1) (the other cases can be proven by using [AND ‚àí POST ‚àí U]). By applying
[WRITE] again and then [CASE], it is suÔ¨Écient to show:

‚ä¢ {Œ¶‚Ä≤(ùëü )}‚åäO(ùëû)‚åã2{{(v ‚â• s[ùë°] ‚àß ùë• ‚â• ùëá ‚àí

6
ùúñ

log

ùëò + 1
ùõΩ

) ‚à® (v < s[ùë°] ‚àß ùë• ‚â§ ùëá +

6
ùúñ

log

ùëò + 1
ùõΩ

)}}ùõΩ/(ùëò+1)

Now we can apply the [LAP ‚àí UBL] rule setting ùõø to ùõΩ/(ùëò + 1). By computation, we can see that

and

|v ‚àí ùë• | ‚â§

|v ‚àí ùë• | ‚â§

4
ùúñ

4
ùúñ

log

ùëò + 1
ùõΩ

log

ùëò + 1
ùõΩ

and this completes the proof.

‚àß v ‚â• s[ùë°] ‚àß |ùëá ‚àí s[ùë°] | ‚â§

‚àß v < s[ùë°] ‚àß |ùëá ‚àí s[ùë°] | ‚â§

2
ùúñ

2
ùúñ

log

ùëò + 1
ùõΩ

‚áí ùë• ‚â• ùëá ‚àí

log

ùëò + 1
ùõΩ

‚áí ùë• ‚â§ ùëá +

6
ùúñ

6
ùúñ

log

ùëò + 1
ùõΩ

log

ùëò + 1
ùõΩ

E QUASI-BOREL SPACES

Quasi-borel spaces are deÔ¨Åned as follows:

Definition 5. A quasi-Borel space is a pair (ùëã, ùëÄùëã ) of a set ùëã and a set ùëÄùëã ‚äÜ R ‚Üí ùëã satisfying

the following closure properties:

(1) If ùõº : R ‚Üí ùëã is constant, then ùõº ‚àà ùëÄùëã .
(2) If ùõº ‚àà ùëÄùëã and ùëì : R ‚Üí R is (Borel) measurable, then ùõº ‚ó¶ ùëì ‚àà ùëÄùëã .
(3) If ùëÜ : R ‚Üí N (Borel) measurable and {ùõºùëñ }ùëñ ‚ààN ‚äÜ ùëÄùëã then ùúÜùëü .ùõºùëÜ (ùëü ) (ùëü ) ‚àà ùëÄùëã .

A morphism between quasi-Borel spaces (ùëã, ùëÄùëã ) and (ùëå , ùëÄùëå ) is a function ùëì : ùëã ‚Üí ùëå such that for
every ùõº ‚àà ùëÄùëã , ùëì ‚ó¶ ùõº ‚àà ùëÄùëå . Quasi-Borel spaces and morphisms between them form a category QBS.

Lemma 5. For each standard Borel space ùê¥, (ùê¥, Meas(R, ùê¥)) is a QBS.

There is a strong monad for probabilistic choices. We Ô¨Årst deÔ¨Åne the concept of probability

measures on QBSs.

Definition 6. Let (ùëã, ùëÄùëã ) be a quasi-Borel space. A (probability) measure over (ùëã, ùëÄùëã ) is a
tuple (ùê¥, Œ£ùê¥, ùõº, ùúá) where (ùê¥, Œ£ùê¥) is a standard Borel space, ùõº ‚àà QBS(ùëç, ùëã ) is a morphism and ùúá
is a (probability) measure over (ùê¥, Œ£ùê¥). We can deÔ¨Åne an equivalence relation between (probability)
measures when they deÔ¨Åne the same integration operator:

(ùê¥, Œ£ùê¥, ùõº, ùúá) ‚â° (ùê¥‚Ä≤, ùõº ‚Ä≤, ùúá‚Ä≤) ‚áê‚áí ‚àÄùëì ‚àà QBS(ùëã, R),

(ùëì ‚ó¶ ùõº)ùëëùúá =

‚à´ùê¥
Definition 7. The probability monad on QBS is deÔ¨Åned by

(ùëì ‚ó¶ ùõº ‚Ä≤)ùëëùúá‚Ä≤

‚à´ùê¥‚Ä≤

P (ùëã ) , {(ùê¥, ùõº, ùúá) probability measure over ùëã }/‚â°
ùëÄP (ùëã ) , {ùúÜùëü .[ùê∑ùëü , ùõº (ùëü , ‚àí), ùúáùëü ] | ùúá ùúé-Ô¨Ånite, ùê∑ ‚äÜ R √ó ùê¥ measurable, ùõº ‚àà QBS(ùê∑, ùëã )}

where ùê∑ùëü = {ùúî | (ùëü , ùúî) ‚àà ùê∑ }. The unit and Kleisli lifting are also deÔ¨Åned by
ùúÇùëã (ùë•) , ({‚àó}, ùúÜùë¶.ùë•, ùõø) where
ùëì # (ùê¥, ùõº, ùúá) , [ùê∑, ùõΩ, (ùúá ‚äó ùúá‚Ä≤)|ùê∑ ] where

ùõø ({‚àó}) = 1.

(ùëì ‚àà QBS(ùëã, P (ùëå )))

where ùëì (ùõº (ùëü )) = [ùê∑ùëü , ùõΩ (ùëü , ‚àí), ùúá‚Ä≤], and ‚äó computes the product measure.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:38

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

E.1 The Interpretation of Non-Monadic Part of the Language
First some preparations. We write ùëëùê¥,ùëã : (ùê¥ ¬∑ 1) √ó ùëã ‚Üí ùê¥ ¬∑ ùëã for the canonical isomorphism. This
exists because QBS is a bi-CCC. Let zero0 , ùúÑ0,1
]ùëñ ‚ààùêæ : ùêæ ¬∑ 1 ‚Üí
0
(ùêæ + 1) ¬∑ 1. The interpretation of the non-monadic part of the language is given as follows. Note
that this is an induction on the derivation of Œì ‚ä¢ ùë° : ùúè; the last rule is the case of the subtyping rule.

: 1 ‚Üí 0 ¬∑ 1 and succùêæ , [ùúÑùêæ+1,1

ùëñ+1

Œì
JŒì ‚ä¢ ùë• : ùúèK , ùúã
ùë•
JŒì ‚ä¢ ‚òÖ: UK , !JŒìK

JŒì ‚ä¢ 0 : N[0]K , zero0 ‚ó¶ !JŒìK

(ùë• ‚àà dom(Œì))

JŒì ‚ä¢ ùëÜ ùë° : N[ùêæ + 1]K , succùêæ ‚ó¶ JŒì ‚ä¢ ùë° : N[ùêæ]K
JŒì ‚ä¢ ùúÜùë• .ùë° : ùúé ‚Üí ùúèK , ùúÜ(JŒì, ùë• : ùúé ‚ä¢ ùë° : ùúèK ‚ó¶ ùëöŒì,ùë•:ùúè )

JŒì ‚ä¢ ùë° ùë¢ : ùúèK , ev ‚ó¶ hJŒì ‚ä¢ ùë° : ùúé ‚Üí ùúèK, JŒì ‚ä¢ ùë¢ : ùúèKi

JŒì ‚ä¢ hùë°, ùë¢i : ùúè √ó ùúéK , hJŒì ‚ä¢ ùë° : ùúèK, JŒì ‚ä¢ ùë¢ : ùúéKi

JŒì ‚ä¢ if ùëè then ùë°1 else ùë°2 : ùúèK , [JŒì ‚ä¢ ùë°1 : ùúèK, JŒì ‚ä¢ ùë°2 : ùúèK] ‚ó¶ ùëëJŒìK,1 ‚ó¶ hJŒì ‚ä¢ ùëè : BK, ùëñùëëJŒìKi

JŒì ‚ä¢ ùúãùëñ (ùë°) : ùúèùëñ K , ùúãùëñ ‚ó¶ JŒì ‚ä¢ ùë° : ùúè1 √ó ùúè2K
JŒì ‚ä¢ ùë° : ‚àÄùõº.ùúèK = JŒì ‚ä¢ ùë° : ùúèK
JŒì ‚ä¢ ùë° : ùúè [Œ£/ùõº]K = JŒì ‚ä¢ ùë° : ‚àÄùõº.ùúèK

(ùëñ = 1, 2)

JŒì ‚ä¢ ùë° : ùúèK = ùëêùúè‚Ä≤,ùúè ‚ó¶ JŒì ‚ä¢ ùë° : ùúè ‚Ä≤K

(ùúè ‚Ä≤ (cid:22) ùúè)

The rules Adv and Adv-Inst are not interpreted, as adversaries will be instantiated by closed terms.

E.2 Logic

Semantics of the logic is deÔ¨Åned inductively by:

JŒì ‚ä¢ ‚ä§K , ‚ä§
JŒì ‚ä¢ ‚ä•K , ‚ä•

JŒì ‚ä¢ ùëÉ (ùë°1, . . . , ùë°ùëò )K , (JŒì ‚ä¢ ùë°1 : ùúé1K √ó ¬∑ ¬∑ ¬∑ √ó JŒì ‚ä¢ ùë°ùëò : ùúéùëòK)‚àóJùëÉK

JŒì ‚ä¢ ùúô ‚àß ùúì K , JŒì ‚ä¢ ùúôK ‚äì JŒì ‚ä¢ ùúì K
JŒì ‚ä¢ ùúô ‚à® ùúì K , JŒì ‚ä¢ ùúôK ‚äî JŒì ‚ä¢ ùúì K
JŒì ‚ä¢ ùúô ‚áí ùúì K , JŒì ‚ä¢ ùúôK ‚áõ JŒì ‚ä¢ ùúì K

JŒì ‚ä¢ ‚àÄ(ùë• : ùúé).ùúôK , ‚àÄJŒìK,JùúéK (ùëö‚àó

Œì,ùë•:ùúé JŒì, ùë• : ùúé ‚ä¢ ùúôK)

where the interpretation JùëÉK for each base predicate ùëÉ : ùúé1 √ó ¬∑ ¬∑ ¬∑ √ó ùúéùëò is a chosen element in
UP2

Jùúé1√ó¬∑¬∑¬∑√óùúéùëò K.

E.3 Graded Lifting for Union Bound in Example 6.2
We show that ¬§P ub is indeeed a 2-valued strong ( [0, ‚àû], ‚â§, +, 0)-graded lifting ¬§P ub of P.

(1) We show ùëÉ (ùë¶) = ‚ä§ =‚áí ¬§P ub

ùëã (0) (ùëÉ) (ùúÇ P

ùëã (ùë¶)) = ‚ä§. For all ùëì ‚àà QBS(ùëã, ùê∑ {0, 1}) such that

ùëÉ ‚äë |ùëì |, we have ùëì (ùë¶) = 1, hence Prùë•‚àºùúÇP (ùë¶) [ùëì (ùë•) = 1] = 1.

(2) Let Œû ‚àà PPùëã . We show ¬§P ub

Pùëã (ùõø1) ( ¬§P ub

ùëã (ùõø2) (ùëÉ)) (Œû) = ‚ä§ =‚áí ¬§P ub

ùëã (ùõø1 + ùõø2) (ùëÉ) (ùúá P (Œû)) = ‚ä§.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:39

For all ùëì ‚àà QBS(ùëã, ùê∑ {0, 1}) such that ùëÉ ‚äë |ùëì |, We have ¬§P ub

ùëã (ùõø2) (ùëÉ) ‚äë ¬§P ub

ùëã (ùõø2) (|ùëì |).

‚ä§ = ¬§P ub
‚äë ¬§P ub
= ¬§P ub

ùëã (ùõø2) (ùëÉ)) (Œû)
ùëã (ùõø2) (|ùëì |)) (Œû)

Pùëã (ùõø1) ( ¬§P ub
Pùëã (ùõø1) ( ¬§P ub
Pùëã (ùõø1) (ùúÜùúà . Pr
ùë•‚àºùúà
= ‚àÄùëî ‚àà QBS(P (ùëã ), ùê∑ {0, 1}), (ùúÜùúà . Pr
ùë•‚àºùúà

[ùëì (ùë•) = 1] ‚â• 1 ‚àí ùõø2) (Œû)

[ùëì (ùë•) = 1] ‚â• 1 ‚àí ùõø2) ‚äë |ùëì | . Pr
ùúà‚àºŒû

[ùëî(ùúà) = 1] ‚â• 1 ‚àí ùõø1

= Pr
ùúà‚àºŒû

[ Pr
ùë•‚àºùúà

[ùëì (ùë•) = 1] ‚â• 1 ‚àí ùõø2] ‚â• 1 ‚àí ùõø1

{ Markov‚Äôs inequality (it holds for probability measures on quasi-Borel spaces). }

Eùúà‚àºŒû [Prùë•‚àºùúà [ùëì (ùë•) = 1]] ‚â• (1 ‚àí ùõø1) (1 ‚àí ùõø2)
1 ‚â• 1 ‚àí ùõø1

‚äë

(

ùõø1 < 1 ‚àß ùõø2 < 1
otherwise

[ùëì (ùë•) = 1]] ‚â• 1 ‚àí ùõø1 ‚àí ùõø2

‚äë Eùúà‚àºŒû[ Pr
ùë•‚àºùúà
[ùëì (ùë•) = 1] ‚â• 1 ‚àí ùõø1 ‚àí ùõø2.

=

Pr
ùëã (Œû)
ùë•‚àºùúá P

(3) Let ùë• ‚àà ùëã and ùúá ‚àà Pùëå . If ùëÉ (ùë•) = ‚ä§ and ¬§P ub
have ‚àÄùëì ‚àà QBS(ùëå , ùê∑ {0, 1}), ùëÑ ‚äë |ùëì | . Prùë•‚àºùúà [ùëì (ùë•) = 1] ‚â• 1 ‚àí ùõø

ùëå (ùõø) (ùëÑ) (ùúá) = ‚ä§ then ¬§P ub

ùëå (ùõø) (ùëÉ ¬§√óùëÑ) (ùúÉ P (ùë•, ùúá)). We

Here, for any ùëî ‚àà QBS(ùëã √ó ùëå , ùê∑ {0, 1}) such that ùëÉ ¬§√óùëÑ ‚äë |ùëî|, ùëî(ùë•, ‚àí) : ùëå ‚Üí ùê∑ {0, 1} satisfy

ùëÑ ‚äë ùëî(ùë•, ‚àí). This is a speciÔ¨Åc property of the case of Œ© = 2.

Hence,

‚ä§ = ¬§P ub

ùëå (ùõø) (ùëÑ) (ùúá)

= ‚àÄùëì ‚àà QBS(ùëå , ùê∑ {0, 1}), ùëÑ ‚äë |ùëì | . Pr
ùë•‚àºùúá

[ùëì (ùë•) = 1] ‚â• 1 ‚àí ùõø

‚äë ‚àÄùëî ‚àà QBS(ùëã √ó ùëå , ùê∑ {0, 1}), ùëÉ ¬§√óùëÑ ‚äë |ùëî| . Pr
ùë¶‚Ä≤‚àºùúá

[ùëî(ùë•, ùë¶‚Ä≤) = 1] ‚â• 1 ‚àí ùõø

{Fubini theorem (coherence property of strength ùúÉ P)}

= ‚àÄùëî ‚àà QBS(ùëã √ó ùëå , ùê∑ {0, 1}), ùëÉ ¬§√óùëÑ ‚äë |ùëî| .

Pr
(ùë• ‚Ä≤,ùë¶‚Ä≤)‚àº(ùúÉ P (ùë•,ùúá)

[ùëî(ùë•, ùë¶) = 1] ‚â• 1 ‚àí ùõø

= ¬§P ub

ùëå (ùõø) (ùëÉ ¬§√óùëÑ) (ùúÉ P (ùë•, ùúá))
(4) It is obvious that ùõø ‚â§ ùõø ‚Ä≤ =‚áí ¬§P ub

ùëã (ùõø) (ùëÉ) (ùúà) ‚äë ¬§P ub

ùëã (ùõø ‚Ä≤) (ùëÉ) (ùúà) holds by deÔ¨Ånition of ¬§P ub.

E.4 Graded Lifting for DiÔ¨Äerential privacy in Example 6.6
We show that ¬§P dp is a 2-valued strong ( [0, ‚àû], +, 0, ‚â§)2-graded relational lifting of P.

(1) Assume (ùë•, ùë¶) |= ùëÉ. For all (ùëì , ùëî) : ùëÉ ¬§‚ÜíùëÜ (ùúñ ‚Ä≤, ùõø ‚Ä≤), we have

(ùëì ‚ôØùúÇ P

ùëã (ùë•), ùëî‚ôØùúÇ P

ùëå (ùë¶)) = (ùëì (ùë•), ùëî(ùë¶)) |= ùëÜ (ùúñ ‚Ä≤, ùõø ‚Ä≤).

This implies that ¬§P dp

ùëã,ùëå (0, 0) (ùëÉ) (ùúÇ P

ùëã (ùë•), ùúÇ P

ùëå (ùë•)) holds.
ùëã,ùëå (ùúñ, ùõø) (ùëÉ), (ùëì , ùëî) : ùëÉ ¬§‚Üí ¬§P dp

(2) Consider (ùúà1, ùúà2) |= ¬§P dp

ùëã ‚Ä≤,ùëå ‚Ä≤ (ùúñ ‚Ä≤, ùõø ‚Ä≤) (ùëÑ) and (ùëò, ùëô) : ùëÑ ¬§‚ÜíùëÜ (ùúñ ‚Ä≤‚Ä≤, ùõø ‚Ä≤‚Ä≤). Then,
(ùëò‚ôØ ùëì (ùë•), ùëô ‚ôØùëî(ùë¶)) |= ùëÜ (ùúñ ‚Ä≤+ùúñ ‚Ä≤‚Ä≤, ùõø ‚Ä≤+ùõø ‚Ä≤‚Ä≤) holds for all (ùë•, ùë¶) |= ùëÉ. Hence, (ùëò‚ôØ ùëì , ùëô ‚ôØùëî) : ùëÉ ¬§‚ÜíùëÜ (ùúñ ‚Ä≤+ùúñ ‚Ä≤‚Ä≤, ùõø ‚Ä≤+ùõø ‚Ä≤‚Ä≤).
Hence, (ùëò‚ôØ ùëì ‚ôØ, ùëô ‚ôØùëî‚ôØ) : ¬§P dp
ùëã,ùëå (ùúñ, ùõø) (ùëÉ) ¬§‚ÜíùëÜ (ùúñ + ùúñ ‚Ä≤ + ùúñ ‚Ä≤‚Ä≤, ùõø + ùõø ‚Ä≤ + ùõø ‚Ä≤‚Ä≤). Hence (ùëò‚ôØ ùëì ‚ôØùúà1, ùëô ‚ôØùëî‚ôØùúà2) |= ùëÜ (ùúñ + ùúñ ‚Ä≤ +
ùúñ ‚Ä≤‚Ä≤, ùõø + ùõø ‚Ä≤ + ùõø ‚Ä≤‚Ä≤). Since (ùëò, ùëô) is arbitrary, we obtain (ùëì ‚ôØùúà1, ùëî‚ôØùúà2) |= ¬§P dp
ùëã ‚Ä≤,ùëå ‚Ä≤ (ùúñ ‚Ä≤ + ùúñ ‚Ä≤‚Ä≤, ùõø ‚Ä≤ + ùõø ‚Ä≤‚Ä≤) (ùëÑ). Since
(ùúà1, ùúà2) is arbitrary we conclude (ùëì ‚ôØ, ùëî‚ôØ) : ¬§P dp

ùëã ‚Ä≤,ùëå ‚Ä≤ (ùúñ ‚Ä≤ + ùúñ ‚Ä≤‚Ä≤, ùõø ‚Ä≤ + ùõø ‚Ä≤‚Ä≤) (ùëÑ).

ùëã,ùëå (ùúñ, ùõø) (ùëÉ) ¬§‚Üí ¬§P dp

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:40

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

We have (idPùëã , idPùëå ) : ¬§P dp
Pùëã , id‚ôØ

ùëå ) = (id‚ôØ

ùëã,ùëå (ùúñ ‚Ä≤, ùõø ‚Ä≤) (ùëÉ) ¬§‚Üí ¬§P dp
ùëã,ùëå (ùúñ, ùõø) ( ¬§P dp
Pùëå ) : ¬§P dp

ùëã,ùëå (ùúñ ‚Ä≤, ùõø ‚Ä≤) (ùëÉ). Then we have
ùëã,ùëå (ùúñ ‚Ä≤, ùõø ‚Ä≤) (ùëÉ)) ¬§‚Üí ¬§P dp

ùëã , ùúá P

(ùúá P

ùëã,ùëå (ùúñ ‚Ä≤ + ùúñ ‚Ä≤‚Ä≤, ùõø ‚Ä≤ + ùõø ‚Ä≤‚Ä≤) (ùëÉ).

(3) Consider (ùë•, ùë¶) |= ùëÉ and (ùúà1, ùúà2) |= ¬§P dp
ùëã ‚Ä≤,ùëå ‚Ä≤ (ùúñ, ùõø) (ùëÑ).
For all (ùëì , ùëî) : ùëÉ ¬§√óùëÑ ¬§‚ÜíùëÜ (ùúñ ‚Ä≤, ùõø ‚Ä≤), we have (ùëì (ùë•, ‚àí), ùëî(ùë¶, ‚àí)) : ùëÑ ¬§‚ÜíùëÜ (ùúñ ‚Ä≤, ùõø ‚Ä≤), (it is speciÔ¨Åc in the case

of Œ© = 2).
Then,

Since ùëì (ùë•, ‚àí)‚ôØ (ùúà1) = ùëì ‚ôØùúÉ P

(ùëì (ùë•, ‚àí)‚ôØ (ùúà1), ùëî(ùë¶, ‚àí)‚ôØ (ùúà2)) |= ùëÜ (ùúñ + ùúñ ‚Ä≤, ùõø + ùõø ‚Ä≤).
ùëã,ùëã ‚Ä≤ (ùë•, ùúà1) and ùëî(ùë¶, ‚àí)‚ôØ (ùúà2) = ùëî‚ôØùúÉ P
ùëã,ùëã ‚Ä≤ (ùë•, ùúà1), ùúÉ P
(ùúÉ P

ùëå,ùëå ‚Ä≤ (ùë•, ùúà2)) |= ¬§P dp

ùëå,ùëå ‚Ä≤ (ùë•, ùúà2) , we have

ùëã √óùëã ‚Ä≤,ùëå √óùëå ‚Ä≤ (ùúñ, ùõø) (ùëÉ ¬§√óùëÑ).
ùëã,ùëå (ùúñ, ùõø) (ùëÉ) (ùúà1, ùúà2) ‚äë ¬§P dp

(4) It is obvious that if ùúñ ‚â§ ùúñ ‚Ä≤ and ùõø ‚â§ ùõø ‚Ä≤ then ¬§P dp

ùëã,ùëå (ùúñ ‚Ä≤, ùõø ‚Ä≤) (ùëÉ) (ùúà1, ùúà2).

F PROOFS OF SECTION 6
We begin by formally stating the soundness of HOL:

Theorem F.1 (Soundness of HOL). Let Œì | Œ® ‚ä¢ ùúô be a derivable HOL judgment. Then it is valid,

i.e. JŒì ‚ä¢

Œ®K ‚äë JŒì ‚ä¢ ùúôK holds in UP2

JŒìK.

Proof. The proof is done by the induction on the derivation tree of Œì | Œ® ‚ä¢ ùúô. It is almost

√ì

obvious. We see the rules Ax, ‚áíùê∏ and ‚áíùêº .

(Ax) A judgment of the form Œì | Œ®, ùúô ‚ä¢ ùúô is always valid:

([Œì ‚ä¢

(Œ®, ùúô)]) = ([Œì ‚ä¢ (

Œ®) ‚àß ùúô]) = ([Œì ‚ä¢

Œ®]) ‚à© ([Œì ‚ä¢ ùúô]) ‚äÜ ([Œì ‚ä¢ ùúô]).

(‚áíùêº ) Suppose that the judgment Œì | Œ®, ùúô1 ‚ä¢ ùúô2 is derivable. By induction hypoithesis, it is valid.

√õ

√õ

√õ
Then we have ([Œì ‚ä¢

Œ®]) ‚à© ([Œì ‚ä¢ ùúô1]) ‚äÜ ([Œì ‚ä¢ ùúô2]). This implies

([Œì ‚ä¢
√ì

Œ®]) ‚äÜ (|JŒìK| \ ([Œì ‚ä¢ ùúô1])) ‚à™ ([Œì ‚ä¢ ùúô2]) = ([Œì ‚ä¢ ùúô1 ‚áí ùúô2]).

(‚áíùê∏) Suppose that the judgments Œì | Œ® ‚ä¢ ùúô1 ‚áí ùúô2 and Œì | Œ® ‚ä¢ ùúô1 are derivable. By induction
Œ®]) ‚äÜ ([Œì ‚ä¢ ùúô1 ‚áí ùúô2]) = |JŒìK| \ ([Œì ‚ä¢ ùúô1]) ‚à™ ([Œì ‚ä¢ ùúô2])

√õ

hypoithesis, they are valid. We have ([Œì ‚ä¢
and ([Œì ‚ä¢

Œ®]) ‚äÜ ([Œì ‚ä¢ ùúô1]). We have
([Œì ‚ä¢

√ì

√ì

Œ®]) ‚äÜ (|JŒìK| \ ([Œì ‚ä¢ ùúô1]) ‚à™ ([Œì ‚ä¢ ùúô2])) ‚à© ([Œì ‚ä¢ ùúô1]) ‚äÜ ([Œì ‚ä¢ ùúô2]).

√õ

(cid:3)

A judgment in UHOL can be seen a pair of a typing judgment and a logical judgment that
contains an extra distinguished variable r referring to the typed term. With this in mind, we show:
Theorem F.2 (Soundness of UHOL). Let Œì | Œ® ‚ä¢ ùë° : ùúé {ùúô } be a derivable UHOL judgment. Then,
Œ®K implies JŒì ‚ä¢ ùë° : ùúéK(ùõæ) |= JŒì, r : ùúé ‚ä¢ ùúôKùõæ .

for any ùõæ ‚àà |JŒìK|, ùõæ |= JŒì ‚ä¢

Now we prove soundness of HO-UBL. We recall here the statement:
Proposition. Let Œì | Œ® ‚ä¢ {ùëÉ }ùë° : TŒ£,ùëò (ùúè){{ùëÑ }}ùõø be a derivable HO-UBL judgment without the

√ì

adversary rule. Then, for any ùõæ ‚àà |JŒìK|, ùõæ |= JŒì ‚ä¢

Œ®K implies

JŒì ‚ä¢ ùë° : TŒ£,ùëò (ùúè)K(ùõæ) |= ¬§P ub ¬§S(ùõø) (JŒì, s : M ‚ä¢ ùëÉKùõæ , JŒì, v : ùúè, s : M ‚ä¢ ùëÑKùõæ ).
√ì
Proof of Proposition 6.4. In this proof we simply write ¬§P ¬§S for ¬§P ub ¬§S. The proof is by induction

on the derivation. We show the more interesting cases:

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:41

‚Ä¢ Unit. By soundness of non-monadic HO-UBL, we have that

ùõæ |= JŒì ‚ä¢

Œ®K ‚áí JŒì ‚ä¢ ùë° : ùúèK(ùõæ) |= JŒì, r : ùúé ‚ä¢ ùúôKùõæ

Now consider an arbitrary Œì, s : M ‚ä¢ ùëÉ. By deÔ¨Ånition, JŒì ‚ä¢ unit(ùë°) : TŒ£,ùëò (ùúé)K(ùõæ) = ùúÇ P S ‚ó¶JŒì ‚ä¢
ùë° : ùúéK(ùõæ). By Lemma 1 we conclude that

√õ

ùúÇ P S ‚ó¶ JŒì ‚ä¢ ùë° : ùúéK(ùõæ) |= ¬§P ¬§SJùúéK(0) (JŒì, s : M ‚ä¢ ùëÉKùõæ , ùêº JŒì ‚ä¢ ùúôK ¬§√ó JŒì, s : M ‚ä¢ ùëÉKùõæ )

‚Ä¢ Bind. By I.H. we have that, for all ùõæ |= JŒì ‚ä¢ Œ®K

JŒì ‚ä¢ ùë° : TŒ£,ùëò (ùúè)K(ùõæ) ‚àà ¬§P ¬§S(ùõø) (JŒì, s : M ‚ä¢ ùëÉKùõæ , JŒì, s : M, v : ùúè ‚ä¢ ùëÑKùõæ )

and for all ùëí ‚àà |JùúèK|, (ùõæ, ùëí) |= JŒì, ùë• : ùúè ‚ä¢ Œ®K, so

JŒì, ùë• : ùúè ‚ä¢ ùë¢ : TŒ£,ùëò (ùúé)K(ùõæ,ùëí) |= ¬§P ¬§S(ùõø ‚Ä≤) (JŒì, ùë• : ùúè, ùë° : M ‚ä¢ ùëÑK(ùõæ,ùëí), JŒì, ùë• : ùúè, s : M, v : ùúé ‚ä¢ ùëÖK(ùõæ,ùëí) )

Since ùë• ‚àâ ùêπùëâ (ùëÖ), then also
JŒì, ùë• : ùúè ‚ä¢ ùë¢ : TŒ£,ùëò (ùúé)K(ùõæ, ùëí) |= ¬§P ¬§S(ùõø ‚Ä≤) (JŒì, ùë• : ùúè, ùë° : M ‚ä¢ ùëÑK(ùõæ,ùëí), JŒì, s : M, v : ùúé ‚ä¢ ùëÖKùõæ )
Note that ùúÜ‚àí1(JŒì, ùë• : ùúè ‚ä¢ ùë¢ : TŒ£,ùëò (ùúé)K(ùõæ)) is a morphism ùúè √ó M ‚Üí P (ùúé √ó M) and that we can
derive
ùúÜ‚àí1(JŒì, ùë• : ùúè ‚ä¢ ùë¢ : TŒ£,ùëò (ùúé)K(ùõæ)) : JŒì, ùë• : ùúè, ùë° : M ‚ä¢ ùëÑKùõæ ¬§‚Üí ¬§P(ùõø ‚Ä≤) (JŒì, s : M, v : ùúé ‚ä¢ ùëÖKùõæ )

By Lemma 1,

(JŒì, ùë• : ùúè ‚ä¢ ùë¢ : TŒ£,ùëò (ùúé)K(ùõæ))# : ¬§P ¬§S(ùõø) (JŒì, s : M ‚ä¢ ùëÉKùõæ , JŒì, s : M, v : ùúè ‚ä¢ ùëÑKùõæ ) ¬§‚Üí
¬§P ¬§S(ùõø + ùõø ‚Ä≤) (JŒì, s : M ‚ä¢ ùëÉKùõæ , JŒì, s : M, v : ùúé ‚ä¢ ùëÖKùõæ )

We know that Bind can be equivalently deÔ¨Åned as:

JŒì ‚ä¢ let ùë• = ùë° in ùë¢ : TŒ£,ùëò (ùúé)K , JŒì, ùë• : ùúé ‚ä¢ ùë¢ : TŒ£,ùëò (ùúé)K# ‚ó¶ ùúÉ ‚ó¶ hùëñùëëŒì, JŒì ‚ä¢ ùë° : TŒ£,ùëò (ùúè)Ki

so we conclude.

‚Ä¢ Read. Recall that JŒì ‚ä¢ read ùëé : TŒ£,ùëò (V)K , ùúÜ(ùúÇ P ‚ó¶hùúãùëé, ùëñùëëi ‚ó¶ùúã2), so JŒì ‚ä¢ read ùëé : TŒ£,ùëò (V)K(ùõæ) ,
ùúÇ P ‚ó¶ hùúãùëé, ùëñùëëi. Consider an arbitrary Œì, v : V, s : M ‚ä¢ ùëÉ. By deÔ¨Ånition of M, we can see
ùëÉ [s[ùëé]/v] as a predicate over JŒìK √ó ùëÄ, and by the semantics of substitution,

hùúãùëé, ùëñùëëi : JŒì, s : M ‚ä¢ ùëÉ [s[ùëé]/v]Kùõæ ¬§‚Üí JŒì, v : V, s : M ‚ä¢ ùëÉKùõæ

By the properties of ¬§P and ùúÇ P, we conclude.

‚Ä¢ Write. Recall that JŒì ‚ä¢ ùëé := ùë° : TŒ£,ùëò (U)K , ùúÜ(ùúÇ P ‚ó¶ h!, ùëñùëëi ‚ó¶ùë¢ùëé (JŒì ‚ä¢ ùë° : VK)). As in the previous

case, we use the semantics of substitution to show:

h!, ùëñùëëi ‚ó¶ ùë¢ùëé (JŒì ‚ä¢ ùë° : VK) (ùõæ, ‚àí) : JŒì, s : M ‚ä¢ ùëÉ [s[ùëé ‚Ü¶‚Üí ùë°]/s]Kùõæ ¬§‚Üí JŒì, v : U, s : M ‚ä¢ ùëÉKùõæ

‚Ä¢ Monadic Case. By I.H., Let ùõæ ‚àà |JŒìK| such that ùõæ |= JŒì ‚ä¢

Œ®K. This, together with the

induction hypothesis on each branch entails

JŒì ‚ä¢ ùë°1 : TŒ£,ùëò (ùúè)K(ùõæ) |= ¬§P ¬§S(ùõø) (JŒì, s : M ‚ä¢ hùëè = tti ‚äì ùëÉ1Kùõæ , JŒì, s : M, v : ùúè ‚ä¢ ùëÑKùõæ )

√ì

JŒì ‚ä¢ ùë°2 : TŒ£,ùëò (ùúè)K(ùõæ) |= ¬§P ¬§S(ùõø) (JŒì, s : M ‚ä¢ hùëè = Ô¨Äi ‚äì ùëÉ2Kùõæ , JŒì, s : M, v : ùúè ‚ä¢ ùëÑKùõæ )

Here we used the fact that ùõæ |= Œ® ‚àß Œ¶ =‚áí ùëÉùõæ ‚â§ ùëÑùõæ implies ùõæ |= Œ® =‚áí (ùúã ‚àó
Then from the standard reasoning on conditional expression we conclude

1 ùêº Œ¶ ‚äì ùëÉùõæ ) ‚â§ ùëÑùõæ .

JŒì ‚ä¢ if ùëè then ùë°1 else ùë°2K(ùõæ) |= ¬§P ¬§S(ùõø) (JŒì, s : M ‚ä¢ (hùëè = tti‚äìùëÉ1)‚äî(hùëè = Ô¨Äi‚äìùëÉ2)Kùõæ , JŒì, s : M, v : ùúè ‚ä¢ ùëÑKùõæ )

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:42

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

‚Ä¢ Uniform sampling. Here we use the concrete deÔ¨Ånition of ¬§P. JŒì ‚ä¢ Unif(ùúé) : TŒ£,ùëò (ùúé)K =
ùúÜ.ùúÉ ‚ó¶ hUnif (JùúéK), ùëñùëëi. By deÔ¨Ånition of the uniform distribution, if {ùë• ‚àà ùúé |ùë• ‚àà ùúô }/|ùúé | = ùõø,
then Prùë•‚àºUnif (JùúéK) [ùë• ‚àà ùúô] = ùõø, so Unif(JùúéK) ‚àà ¬§P ub() (1 ‚àí ùõø) (ùúô), and therefore,

JŒì ‚ä¢ Unif(ùúé) : TŒ£,ùëò (ùúé)K : JŒì, s : M ‚ä¢ ùëÉK
¬§‚Üí ¬§P ub(1 ‚àí ùõø) (Jùë• : ùúé ‚ä¢ ùúôK) ¬§√ó JŒì, s : M ‚ä¢ ùëÉK
¬§‚Üí ¬§P ub(1 ‚àí ùõø) (JŒì, ùë• : ùúé, s : M ‚ä¢ ùúô ‚àß ùëÉK).

(cid:3)

A judgment in RHOL can be seen as a triple formed by two typing judgments and a logical

judgment with two extra distinguished variables.

Theorem F.3 (Soundness of RHOL). Let Œì | Œ® ‚ä¢ ùë°1 : ùúé1 ‚àº ùë°2 : ùúé2 {ùúô } be a derivable UHOL
Œ®K implies

judgment. Then, for any ùõæ ‚àà |JŒìK|, ùõæ |= JŒì ‚ä¢

(JŒì ‚ä¢ ùë°1 : ùúé1K(ùõæ), JŒì ‚ä¢ ùë°2 : ùúé2K(ùõæ)) |= JŒì, r1 : ùúé1, r2 : ùúé2 ‚ä¢ ùúôKùõæ .

√ì

We now prove soundness of the relational logic. We Ô¨Årst recall the statement:

Proposition. Let Œì | Œ® ‚ä¢ {ùëÉ }ùë°1 : TŒ£,ùëò (ùúè1) ‚àº ùë°1 : TŒ£,ùëò (ùúè2){{ùëÑ }}ùõø be a derivable HO-PRL judgment

without the [ADV ‚àí R] rule. Then for any ùõæ ‚àà |JŒìK|, ùõæ |= JŒì ‚ä¢

Œ®K implies

(JŒì ‚ä¢ ùë°1 : TŒ£,ùëò (ùúè1)K(ùõæ), JŒì ‚ä¢ ùë°2 : TŒ£,ùëò (ùúè2)K(ùõæ)) |= ¬§P ¬§S (0, ùõø) (JùëÉKùõæ , JùëÑKùõæ ),
where JùëÉKùõæ , JŒì, s1 : M, s2 : M ‚ä¢ ùëÉKùõæ and ùëÑùõæ , JŒì, s1 : M, v1 : ùúé, s2 : M, v2 : ùúé ‚ä¢ ùëÑKùõæ .

√ì

Proof of Proposition 6.7. To simplify the proof, we will use set theory notation, i.e. instead
of ùõæ ‚àà QBS(1, JŒìK) and hùõæ ‚àó, ùëñùëëiJŒì, s : ùëÄ ‚ä¢ ùëÉK, we write ùõæ ‚àà JŒìK and JŒì, s : ùëÄ ‚ä¢ ùëÉK(ùõæ). We also use
the shorthand ¬•Tùúé1,ùúé2,(ùúñ,ùõø) , ¬•S( ¬•P dp)ùúé1,ùúé2,(ùúñ,ùõø) , and omit ùúé1, ùúé2 when they are clear from the context.
We only show a few interesting cases:

‚Ä¢ [UNIT ‚àí L]. By soundness of UHOL,

hùëñùëëJŒìK, JŒì ‚ä¢ ùë° : ùúè1Ki : JŒì ‚ä¢

Œ®K ‚Üí JŒì, r : ùúè1 ‚ä¢ ùúôK

Œ®K, JŒì ‚ä¢ ùë° : ùúè1K(ùõæ) ‚àà JŒì, r : ùúè1 ‚ä¢ ùúôK(ùõæ). Consider an arbitrary predicate

√õ

so for all ùõæ ‚àà JŒì ‚ä¢
Œì, s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùëÉ. By deÔ¨Ånition,

√ì

JŒì ‚ä¢ unit(ùë°) : Tùúè1K(ùõæ) = ùúÇ T (JŒì ‚ä¢ ùë° : ùúè1K(ùõæ))

and

JŒì ‚ä¢ skip : T UK(ùõæ) = ùúÇ (‚àó)
Where ‚àó is the only element of the singleton set. By Lemma ?? we can conclude that

(ùúÇ T (JŒì ‚ä¢ ùë° : ùúè1K(ùõæ)), ùúÇ T (‚àó)) ‚àà
¬•Tùúè1,U,(0,0) (JŒì, s1 : ùëÄ, s2 ‚ä¢ ùëÉK(ùõæ), JŒì ‚ä¢ ùúôK(ùõæ) ¬•√ó JŒì, s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùëÉK(ùõæ))
‚Ä¢ [BIND]. By applying I.H. to the Ô¨Årst premise we have that, for all ùõæ ‚àà JŒì ‚ä¢ Œ®K

(JŒì ‚ä¢ ùë°1 : Tùúè1K(ùõæ), JŒì ‚ä¢ ùë°2 : T ùúè2K(ùõæ)) ‚àà
¬•T(ùúñ,ùõø) (JŒì, s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùëÉK(ùõæ), JŒì, s1 : ùëÄ, v1 : ùúè1, s2 : ùëÄ, v2 : ùúè2 ‚ä¢ ùëÑK(ùõæ))

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:43

and for all ùëí1 : ùúè2, ùëí2 : ùúè2, we have (ùõæ, ùëí1, ùëí2) ‚àà JŒì, ùë•1 : ùúè1, ùë•2 : ùúè2 ‚ä¢ Œ®K, so by applying I.H. to
the second premise,

(JŒì, ùë•1 : ùúè1, ùë•2 : ùúè2, ‚ä¢ ùë¢1 : T ùúé1K(ùõæ, ùëí1, ùëí2), JŒì, ùë•1 : ùúè1, ùë•2 : ùúè2 ‚ä¢ ùë¢2 : T ùúé2K(ùõæ, ùëí1, ùëí2)) ‚àà
¬•T(ùúñ‚Ä≤,ùõø‚Ä≤) (JŒì, ùë•1 : ùúè1, ùë•2 : ùúè2, s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùëÑK(ùõæ, ùëí1, ùëí2),

JŒì, ùë•1 : ùúè1, ùë•2 : ùúè2, s1 : ùëÄ, v1 : ùúé1, s2 : ùëÄ, v2 : ùúé2 ‚ä¢ ùëÖK(ùõæ, ùëí1, ùëí2))

Since ùë•1, ùë•2 ‚àâ ùêπùëâ (ùëÖ), then also

(JŒì, ùë•1 : ùúè1, ùë•2 : ùúè2, ‚ä¢ ùë¢1 : T ùúé1K(ùõæ, ùëí1, ùëí2), JŒì, ùë•1 : ùúè1, ùë•2 : ùúè2 ‚ä¢ ùë¢2 : T ùúé2K(ùõæ, ùëí1, ùëí2)) ‚àà
¬•T(ùúñ‚Ä≤,ùõø‚Ä≤) (JŒì, ùë•1 : ùúè1, ùë•2 : ùúè2, s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùëÑK(ùõæ, ùëí1, ùëí2),

JŒì, s1 : ùëÄ, v1 : ùúé1, s2 : ùëÄ, v2 : ùúé2 ‚ä¢ ùëÖK(ùõæ))

Also, since ùë•1 ‚àâ ùêπùëâ (ùë¢2) and ùë•2 ‚àâ ùêπùëâ (ùë¢1), we have morphisms

ùúÜ‚àí1(JŒì, ùë•1 : ùúè1 ‚ä¢ ùë¢1 : T ùúé1K(ùõæ)) : ùúè1 √ó ùëÄ ‚Üí P (ùúé1 √ó ùëÄ)

and

so,

ùúÜ‚àí1(JŒì, ùë•2 : ùúè2 ‚ä¢ ùë¢2 : T ùúé2K(ùõæ)) : ùúè2 √ó ùëÄ ‚Üí P (ùúé2 √ó ùëÄ)

(ùúÜ‚àí1(JŒì, ùë•1 : ùúè1 ‚ä¢ ùë¢1 : T ùúé1K(ùõæ)), ùúÜ‚àí1(JŒì, ùë•2 : ùúè2 ‚ä¢ ùë¢2 : T ùúé2K(ùõæ))) :

JŒì, ùë•1 : ùúè1, s1 : ùëÄ, ùë•2 : ùúè2, s1 : ùëÄ ‚ä¢ ùëÑK(ùõæ) ‚Üí

¬•P dp
(ùúñ‚Ä≤,ùõø‚Ä≤) (JŒì, s1 : ùëÄ, v1 : ùúé1, s2 : ùëÄ, v1 : ùúé2 ‚ä¢ ùëÖK(ùõæ))

By the relational analogue of Lemma 1, we get

((JŒì, ùë•1 : ùúè1 ‚ä¢ ùë¢1 : T ùúé1K(ùõæ))#, (JŒì, ùë•2 : ùúè2 ‚ä¢ ùë¢2 : T ùúé2K(ùõæ))#) :
¬•T(ùúñ,ùõø) (JŒì, s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùëÉK(ùõæ), JŒì, s1 : ùëÄ, v1 : ùúè1, s2 : ùëÄ, v2 : ùúè2 ‚ä¢ ùëÑK(ùõæ)) ‚Üí
¬•T(ùúñ+ùúñ‚Ä≤,ùõø+ùõø‚Ä≤) (JŒì, s1 : ùëÄ, s2 : ùëÄ ‚ä¢ ùëÉK(ùõæ), JŒì, s1 : ùëÄ, v1 : ùúé1, s2 : ùëÄ, v2 : ùúé2 ‚ä¢ ùëÖ(ùõæ)K)

and from this we can conclude.

(cid:3)

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

