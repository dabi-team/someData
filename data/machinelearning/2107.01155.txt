1
2
0
2

l
u
J

2

]

O
L
.
s
c
[

1
v
5
5
1
1
0
.
7
0
1
2
:
v
i
X
r
a

Higher-order probabilistic adversarial computations:
Categorical semantics and program logics

ALEJANDRO AGUIRREâˆ—, Aarhus University, Denmark
GILLES BARTHE, MPI-SP, Germany and IMDEA Software Institute, Spain
MARCO GABOARDI, Boston University, USA
DEEPAK GARG, Max Planck Institute for Software Systems, Germany
SHIN-YA KATSUMATA, National Institute of Informatics, Japan
TETSUYA SATO, Tokyo Institute of Technology, Japan

Adversarial computations are a widely studied class of computations where resource-bounded probabilistic
adversaries have access to oracles, i.e., probabilistic procedures with private state. These computations arise
routinely in several domains, including security, privacy and machine learning.

In this paper, we develop program logics for reasoning about adversarial computations in a higher-order
setting. Our logics are built on top of a simply typed ğœ†-calculus extended with a graded monad for prob-
abilities and state. The grading is used to model and restrict the memory footprint and the cost (in terms
of oracle calls) of computations. Under this view, an adversary is a higher-order expression that expects as
arguments the code of its oracles. We develop unary program logics for reasoning about error probabilities
and expected values, and a relational logic for reasoning about coupling-based properties. All logics feature
rules for adversarial computations, and yield guarantees that are valid for all adversaries that satisfy a ï¬xed
resource policy. We prove the soundness of the logics in the category of quasi-Borel spaces, using a general
notion of graded predicate liftings, and we use logical relations over graded predicate liftings to establish the
soundness of proof rules for adversaries. We illustrate the working of our logics with simple but illustrative
examples.

ACM Reference Format:
Alejandro Aguirre, Gilles Barthe, Marco Gaboardi, Deepak Garg, Shin-ya Katsumata, and Tetsuya Sato. 2021.
Higher-order probabilistic adversarial computations: Categorical semantics and program logics. Proc. ACM
Program. Lang. 5, ICFP, Article 93 (August 2021), 43 pages. https://doi.org/10.1145/3473598

93

1 INTRODUCTION

Probabilistic programs occur widely in privacy, security, and other domains where formal guar-
antees are required. These guarantees are often expressed using expectations, e.g, one may want
to prove that the expected value of a randomized algorithm remains close to some deterministic

âˆ—This research was carried out while the ï¬rst author was aï¬ƒliated to the IMDEA Software Institute and Universidad
PolitÃ©cnica de Madrid

Authorsâ€™ addresses: Alejandro Aguirre, Aarhus University, Denmark, alejandro@cs.au.dk; Gilles Barthe, MPI-SP, Germany
, IMDEA Software Institute, Spain, gbarthe@mpi-sp.org; Marco Gaboardi, Boston University, USA, gaboardi@bu.edu;
Deepak Garg, Max Planck Institute for Software Systems, Germany, dg@mpi-sws.org; Shin-ya Katsumata, National Insti-
tute of Informatics, 2-1-2 Hitotsubashi, Chiyoda-ku, Tokyo, 101-8430, Japan, s-katsumata@nii.ac.jp; Tetsuya Sato, Tokyo
Institute of Technology, Japan, tsato@c.titech.ac.jp.

Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for proï¬t or commercial advantage and that copies bear this notice and
the full citation on the ï¬rst page. Copyrights for third-party components of this work must be honored. For all other uses,
contact the owner/author(s).
Â© 2021 Copyright held by the owner/author(s).
2475-1421/2021/8-ART93
https://doi.org/10.1145/3473598

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

 
 
 
 
 
 
93:2

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

function of its input. This can be established by means of expectation-based methods that orig-
inate from the works of Kozen [1985] and of Morgan et al. [1996]. Another class of guarantees
is concerned with proving the probability of events; e.g., one may want to prove that a random-
ized algorithm has a small probability of returning an incorrect answer, or more generally that
there is a small probability that a bad event happens. These kinds of properties are the target of
so-called Boolean-based methods, such as the union bound logic proposed by [Barthe et al. 2016b].
These two approaches are traditionally used to reason about properties concerning a single pro-
gram execution. However, many security and privacy properties are naturally expressed by relat-
ing two program executions; we call such properties relational properties. Relational counterparts
to expectation-based and Boolean-based methods have been proposed, including the relational
expectation-based logic of Barthe et al. [2018], and probabilistic relational Hoare logic [Barthe et al.
2009].

Some of these logics additionally support reasoning about adversarial computations, where resource-

bounded but otherwise unconstrained adversaries interact with oracles, i.e. probabilistic proce-
dures with private state. These logics view adversaries as uninterpreted procedures, and restrict
their power by adding constraints on the memory they can read and write, and on the number of
times they can call other procedures. These constraints are captured by a notion of valid adversary,
and it is reasonably simple to deï¬ne proof rules for valid adversaries. The combination of program
logics and adversary rules yield powerful frameworks that have been used to reason about many
examples, including security of cryptographic constructions [Barthe et al. 2009] and stability of
machine learning algorithms [Barthe et al. 2018].

The aforementioned works are developed on top of a core probabilistic imperative language.
However, it is often desirable to reason about higher-order programs, either because the programs
of interest are written in a higher-order language, or more fundamentally because the programs
manipulate higher-order objects. Unfortunately, program logics for higher-order probabilistic lan-
guages are not as well understood as their counterparts for imperative languages. One potential
reason for this is that denotational semantics of higher-order probabilistic programs have been
lacking. Indeed, a classic result by Aumann et al. [1961] shows that the category of Borel spaces
is not Cartesian closed, and therefore it cannot be used to interpret programs. Fortunately, recent
works propose elegant semantics for higher-order probabilistic programs, such as Probabilistic Co-
herent Spaces (or PCoh) [Danos and Ehrhard 2011] and Quasi-Borel Spaces (or QBS) [Heunen et al.
2017]. These semantics can be used as a basis for developing program logics, as shown for instance
by Sato et al. [2019], who develop unary and relational logics over QBS. However, reasoning in this
system is based on an axiomatization of probabilities, and is intricate. Moreover, this system does
not support reasoning about state and adversarial computations.

Goals and technical outline. In this paper we set out to develop a general framework for designing
program logics that reason about resource-constrained adversarial computations in a higher-order
probabilistic language. The reasoning principles themselves are fairly natural, and have been con-
sidered in the ï¬rst-order setting before [Barthe et al. 2009], but generalizing them to the higher-
order requires addressing the following challenges:

â€¢ How can we enforce the restrictions on the adversaries?
â€¢ Can we support relational or expectation-based logics?
â€¢ How can we formalize the reasoning principles into a common set of proof rules? How can

we prove these rules sound?

â€¢ How can we give a denotational model to these logics?

Program properties in an adversarial setting usually make some assumptions about adversaries
by restricting the number of times they can invoke the oracle, and denying them access to the

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:3

private state of the oracle (formally, the oracle is a function with hidden local state, passed as an
argument to the adversary). In the ï¬rst-order setting this is usually addressed by restricting the
syntax of adversaries in an ad-hoc manner, but for higher-order programs a more principled ap-
proach would involve using the type system to enforce these restrictions. Another idea would be
to use local state and some sort of separation logic [Tassarotti and Harper 2019], but it is not clear
how such features can be added to denotational models for higher-order probabilistic programs.
The solution we propose here ï¬rst involves grading a monad for global state and probabilities by
two parameters Î£ and ğ‘˜: Î£ represents the memory footprint of the computation and ğ‘˜ represents
the number of oracle calls. Thus, our language has types of the form TÎ£,ğ‘˜ (ğœ) to represent compu-
tations with memory footprint Î£ and at most ğ‘˜ oracle calls. Then, we allow quantiï¬cation over
memory grading, which can be seen as a lightweight form of polymorphism. We then model ad-
versaries as computations of second-order types, e.g. the type âˆ€ğ›¼.(ğœ â†’ Tğ›¼,1(ğœ)) â†’ TÎ£âˆªğ›¼,ğ‘˜ (ğœ â€²)
captures an adversary that has access to an oracle of type ğœ â†’ Tğ›¼,1(ğœ) and that returns values of
type ğœ â€². The grading ensures that the adversary can call the oracle at most ğ‘˜ times, and separation
between adversary and oracle memories is enforced by a parametricity property derived from the
quantiï¬cation in the type: the adversary can only read and write the memory region Î£; and in
particular, it cannot access the private memory of the oracle (denoted ğ›¼). To our knowledge, this
is the ï¬rst use of this form of parametricity.

On top of this language, we develop a Boolean-based unary logic, an expectation-based unary
logic, and a Boolean-based relational logic. The ï¬rst of these logics can be used to reason about
the probability that the output of a program satisï¬es some assertion. Its judgments are based on
generalized Hoare triples of the form {ğœ™ } ğ‘¡ : TÎ£,ğœ– (ğ´) {{ğœ“ }}ğ›¿ , with the meaning that if the initial
state satisï¬es ğœ™, then the ï¬nal state after running ğ‘¡ satisï¬es ğœ“ with probability at least 1 âˆ’ ğ›¿. The
logicâ€™s interpretation is based on a graded monad lifting, which maps the postcondition ğœ“ and the
grading ğ›¿ to an assertion over probability distributions.

Crucially, soundness of this ï¬rst logic does not depend on the concrete deï¬nition of the lifting,
but only on some algebraic properties of the lifting, so the logic can be generalized. We use this
observation to develop a second higher-order program logic for a completely diï¬€erent purpose,
namely, proving properties of expectations, similar to Morgan et al. [1996]. In this logic, assertions
are real-valued functions, as opposed to Boolean-valued assertions of the ï¬rst logic. Remarkably,
most of the proof rules of the two logics are the same, thanks to the similar algebraic properties
of the underlying liftings. This shows how, by exploiting similarity in the underlying liftings, we
can get almost similar proof rules to prove completely diï¬€erent properties with diï¬€erent truth
values. We believe that building two diï¬€erently-valued logics (real-valued and Boolean-valued)
from common rules is novel.

Our third logic is a relational logic that can be used to prove properties [Barthe et al. 2016a] of
pairs of higher-order probabilistic programs using couplings. Again, we exploit the structure of
liftings (couplings are particular cases of liftings), this time for relational reasoning.

To each of the three logics we add (structurally very similar) proof rules for reasoning about
adversaries. Adversary rules combine all of the features of our framework, and can be used to
reason about the interaction of an oracle O, whose code we know, with an adversary A of which
we only know the type. Our type system enforces that the adversary can only call the oracle at most
ğ‘˜ times and it cannot access the oracleâ€™s private memory. The adversary rules of all three logics
have similar structure and follow the same underlying pattern: Assuming some invariant about
the oracleâ€™s private state (which we can discharge in our logics), derive a property of any adversary
that can call the oracle at most ğ‘˜ times. For instance, in the ï¬rst logic above, the adversary rule
says that if the oracle preserves an invariant ğœ™ with probability at least 1 âˆ’ ğ›¿, then any adversary
calling the oracle at most ğ‘˜ times preserves ğœ™ with probability at least 1 âˆ’ ğ‘˜ğ›¿.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:4

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

Next, we deï¬ne a semantic model for our language and the three logics. Just modeling the lan-
guage with its higher-order nature and probabilities is nontrivial as explained earlier. Concretely,
we model our language in the category QBS of Quasi-Borel spaces. We then interpret monadic
types using the monad T (âˆ’) , ğ‘€ â‡’ P (âˆ’ Ã— ğ‘€) for some QBS ğ‘€ of memories, where P denotes
the monad of probability measures over QBS.

Next, we wish to build a uniform framework to model our three logics, their diï¬€erent notions
of truth-values, diï¬€erent liftings, and both unary and relational reasoning. For this, we build our
theory using the notion of Heyting-valued predicates, which are maps from a set ğ‘‹ to a Heyting
algebra Î©. By instantiating Î© diï¬€erently, we are able to model our diï¬€erent logics. Further, to inter-
pret logics themselves we employ graded monad liftings [Katsumata 2014], which map a Heyting-
valued predicate over a set ğ‘‹ to a Heyting-valued predicate over the set of distributions over ğ‘‹ . We
also introduce a novel concept of stateful lifting, which combines graded monad liftings with the
state monad. This gives a categorical semantics of our new Hoare-triple type (c.f. [Nanevski et al.
2008]): â€œ{ğœ™ }ğ‘¡ : TÎ£,ğœ– (ğ´){{ğœ“ }}ğ›¿ â€, where ğœ™,ğœ“ are Î©-valued predicates, ğ›¿ is a grading and the whole
type speciï¬es properties of probabilities of state transformers. In doing so, we carefully design a
categorical framework that uniï¬es qualitative and quantitative assertions using Heyting algebras,
and admits interpretations of the triples under a generic graded lifting. Soundness of the diï¬€erent
logics follows uniformly by suitably instantiating the liftings and the Heyting algebras.

The soundness of the adversary rules needs separate proofs, since we must show that the rules
are sound for any term inhabiting the adversaryâ€™s type. This can usually be done with logical
relations, but an approach based on standard logical relations would fail here, since it would not
take into account the latent eï¬€ect of the types and their relation to the invariant. Therefore, we
develop a novel logical relation that is parametrized by the invariant we want to preserve, and
graded by the probability of failure.

Contributions. In summary, our contributions are the following:

â€¢ We design a type system for a higher-order probabilistic language to model adversaries and
restrict their capabilities. This is achieved through the use of a monad graded by the mem-
ory footprint and the cost the computations, and exploiting parametricity over the memory
usage. This novel application of parametricity allows us to enforce a separation between the
adversary and the oracle memories in a setting with global state.

â€¢ We design three unary and relational logics to reason about probabilistic programs in this
setting. We go beyond logics in which assertions are Boolean by also presenting a logic
in which assertions are real-valued functions, whose expected value the logic establishes.
Assertions in our logics are also graded, to allow us to reason about the probability of failure,
or the tightness of bounds. The logics are instances of a generic structure â€“ both in the proof
rules and the semantics â€“ showcasing the common structure behind them.

â€¢ We introduce a notion of stateful lifting, which is used to interpret the triples in our judg-
ments, from which we can construct a categorical model for the rest of the framework. This
model is parametrized by a Heyting algebra of truth values and a graded lifting that inter-
prets assertions. This allows us to have a uniform categorical model which is general enough
for all the logics that we present.

â€¢ We introduce rules to reason about the interaction between adversaries, from which we only
know their type, and oracles. This uses the parametricity above, to show that an invariant is
preserved, and moreover it uses the cost restriction on the adversary to compute the grading
of the interaction. Soundness of these rules follows from a novel logical relation.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:5

2 ILLUSTRATIVE EXAMPLES
We introduce two illustrative examples, which we use to motivate our modeling of adversaries,
and later to showcase the mechanics of our diï¬€erent logics. Our examples are deliberately simple;
further examples are in the conclusion and the appendix.

Pollution attacks against Bloom ï¬lters [Gerbet et al. 2015]. Bloom Filters [Bloom 1970] are prob-
abilistic data structures useful to represent sets eï¬ƒciently at the cost of a loss in precision. Infor-
mally, a Bloom Filter is a data structure with two procedures: an insertion procedure for adding
a value to the current set, and a membership procedure to query whether a value belongs to the
current set. For simplicity, we assume that values are taken from the set [ğ‘›] = {0, . . . , ğ‘› âˆ’ 1} for
some ğ‘›. A Bloom Filter represents subsets of [ğ‘›] as an array ğ¿ of bits of ï¬xed size ğ‘š. Initially all bits
in ğ¿ are set to 0. The insertion procedure is parametrized by a hash function ğ» : ( [ğ‘›] Ã— [â„“]) â†’ [ğ‘š]
sampled uniformly at random, where â„“ is a parameter of the Bloom Filter. The procedure insert(ğ‘¥)
updates to 1 the value of the array at positions â„(ğ‘¥, 1), . . . , â„(ğ‘¥, â„“). The procedure member(ğ‘¥) com-
putes â„(ğ‘¥, 1), . . . , â„(ğ‘¥, â„“) and returns 1 if all these bits are set to 1, and 0 otherwise. The main
advantage of Bloom Filters is their space-eï¬ƒciency over other classical data structures for sets.
But this eï¬ƒciency comes at a price: Bloom Filters may yield false positives: a membership query
may possibly return true for a value that does not belong to the current set due to hash collisions.
Therefore, an adversary may attempt to pollute the Bloom Filter in order to trigger false posi-
tives [Gerbet et al. 2015]. In this paper, we consider a very simple form of pollution attacks, where
an adversary adaptively performs insertion queries with the goal to set to 1 a maximal number of
bits of the Bloom Filter. Since the adversary is probabilistic, we use the expected number of bits
set to 1 as a measure of the adversaryâ€™s success. Assuming that the Bloom Filter is initially empty,
i.e. all bits are set to 0, one can prove that for every adversary A making at most ğ‘˜ queries to the
insertion oracle, the expected number of bits set to 1 after the adversary returns is upper bounded
by ğ‘š Â· (1 âˆ’ ((ğ‘š âˆ’ 1)/ğ‘š)â„“ Â·ğ‘˜).

We model this example in a simply typed calculus enriched with graded monadic type con-
structors. Concretely, we model adversaries carrying a pollution attack against a Bloom Filter as
computations A of type âˆ€ğ›¼.( [ğ‘›] â†’ Tğ›¼,1(U)) â†’ Tğ›¼ âˆªÎ£,ğ‘˜ (U) where U is the unit type and by abuse
of notation we view [ğ‘›] as a type. The intended argument of the adversary is the insertion oracle.
The monadic type Tğ›¼,1(ğœ) should be seen as stateful probabilistic computations that can read and
write to the set of locations ğ›¼ (but not others) and have cost 1. Therefore, the grading ensures
that each oracle call has cost 1, and that the adversary can make at most ğ‘˜ calls to the oracle. The
universal quantiï¬cation on ğ›¼ ensures that the adversary can only read and write locations in Î£,
and that its eï¬€ect on other memory locations like the ğ¿[ğ‘–]s is only indirect, through calls to its
oracle.

We assume that hash functions are implemented as random oracles, i.e. stateful probabilistic
functions that lazily sample their output when queried with a fresh input. The pseudo-code of the
insertion oracle insert is deferred to Section 4.2. Under this modeling we upper bound the success
of pollution attacks via the judgment:

â€¢ | A : ğœ | â€¢ | â€¢ âŠ¢ {ğ‘š Â· (1 âˆ’ ((ğ‘š âˆ’ 1)/ğ‘š)â„“ Â·ğ‘˜)} A insert : TÎ£âˆª{ğ‘Ÿ,ğ¿,â„ },ğ‘˜ (U)

ğ‘šâˆ’1
ğ‘–=0 ğ¿[ğ‘–]

where ğœ , âˆ€ğ›¼.( [ğ‘›] â†’ Tğ›¼,1(U)) â†’ Tğ›¼ âˆªÎ£,ğ‘˜ (U), insert is the insertion oracle, and {ğ‘Ÿ , ğ¿, â„} are the
memory locations used by the oracle. The adversary, represented by the variable A, is declared in
a special adversary context. The other contexts for grading variables, standard variables and logi-
cal assumptions are empty (the contexts are explained in Sections 3 and 4). The statement on the
right hand side of the turnstile can be seen as a generalized Hoare triple, given by two assertions
(between curly braces) and a program, as in Hoare Type Theory [Nanevski et al. 2008]. We have a

(cid:8)(cid:8)Ã

(cid:9)(cid:9)

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:6

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

generic syntax of judgments and a generic set of generic inference rules, that can later be instan-
tiated to diï¬€erent notions of assertions and diï¬€erent interpretations. For the speciï¬c instantiation
used here (Section 4.2), the assertions are quantities â€“ maps from states to the non-negative reals
â€“ that are known as the pre-expectation (the one on the left) and the post-expectation (on the
right), respectively. The interpretation of such a statement is that the expected value of the post-
expectation over the output distribution of the program is upper bounded by the pre-expectation.
We note that pollution attacks are a very simple example. More advanced attacks are considered
by Clayton et al. [2019]; Naor and Yogev [2019], who develop an elaborate theory of Bloom Filters
and probabilistic data structures under adversarial environments.

PRF/PRP Switching Lemma. The PRF/PRP Switching Lemma [Impagliazzo and Rudich 1989] is a
classical tool in provable security. Let {0, 1}ğ‘™ denote the set of bitstrings of length ğ‘™. The lemma
states that the probability of a bounded adversary to distinguish between a pseudo-random func-
tion (PRF) and a pseudo-random permutation (PRP) is upper bounded by ğ‘˜ (ğ‘˜ + 1)/2ğ‘™ +1 where
ğ‘˜ is the maximal number of calls allowed to the adversary. The PRF/PRP Switching Lemma is
a popular benchmark for computer-aided cryptography, so multiple formalizations are available,
e.g. [Barthe et al. 2009].

We model the adversary as a computation of type âˆ€ğ›¼.({0, 1}ğ‘™ â†’ Tğ›¼,1({0, 1}ğ‘™ )) â†’ TÎ£âˆªğ›¼,ğ‘˜ ({0, 1})
where Î£ models the private memory of the adversary. Similar to the case of Bloom ï¬lters, we follow
a lazy modeling of PRF and PRP. The pseudo-code of PRF and PRP is given below:

PRF (ğ‘¥1 : {0, 1}ğ‘™ ) , if ğ‘¥1 âˆ‰ dom ğ¿1 then {ğ‘§1 = Unif({0, 1}ğ‘™ );
ğ¿1 [ğ‘¥1] := ğ‘§1}; return ğ¿1 [ğ‘¥1]
PRP (ğ‘¥2 : {0, 1}ğ‘™ ) , if ğ‘¥2 âˆ‰ dom ğ¿2 then {ğ‘§2 = Unif({0, 1}ğ‘™ \ (im ğ¿2));ğ¿2 [ğ‘¥2] := ğ‘§2}; return ğ¿2 [ğ‘¥2]

We show that for every adversary A with the aforementioned type, the statistical distance between
A PRF and A PRP is upper bounded by ğ‘˜ (ğ‘˜ + 1)/2ğ‘™ +1 using an approximate relational logic (i.e., a
logic that can prove approximations rather than equalities). We establish the following judgment:

â€¢ | A : ğœ | â€¢ | â€¢ âŠ¢ {s1 = s2} A PRF : TÎ£âˆª{ğ¿1 },ğ‘˜ ({0, 1}) âˆ¼ A PRP : TÎ£âˆª{ğ¿2 },ğ‘˜ ({0, 1}) {{s1 = s2âˆ§v1 = v2}}ğ‘˜ (ğ‘˜+1)/2ğ‘™ +1
where ğœ , âˆ€ğ›¼.({0, 1}ğ‘™ â†’ Tğ›¼,1({0, 1}ğ‘™ )) â†’ TÎ£âˆªğ›¼,ğ‘˜ ({0, 1}). This judgment has the following in-
terpretation: if we have two memories s1, s2 that are equal and we run the computation on the
left and the computation on the right with input memories s1 and s2 respectively, then the output
distributions are going to be close, and their statistical distance is upper bounded by ğ‘˜ (ğ‘˜ + 1)/2ğ‘™ +1.
Although our proof uses an approximate logic, there is an alternative proof that uses an exact
relational logic, and the Union Bound logic. The latter proof uses the so-called up-to-bad technique,
and defaults to the union bound logic to prove that the probability of collisions in a PRF is upper
bounded by ğ‘˜ (ğ‘˜ + 1)/2ğ‘™ +1. This is captured in the union bound logic by the judgment:

â€¢ | A : ğœ | â€¢ | â€¢ âŠ¢ {|ğ‘‘ğ‘œğ‘š ğ¿1 | = 0}A PRF : TÎ£âˆª{ğ¿1 },ğ‘˜ ({0, 1}){{|ğ‘‘ğ‘œğ‘š ğ¿1| = |ğ‘–ğ‘š ğ¿1 |}}ğ‘˜ (ğ‘˜+1)/2ğ‘™ +1
This speciï¬cation has the same syntax as the speciï¬cation of the pollution attacks, but uses dif-
ferent notions of predicates and a diï¬€erent intrepretation (but crucially, the same set of inference
rules). The assertions are Boolean predicates, and the interpretation of this judgment is that if the
initial state satisï¬es |ğ‘‘ğ‘œğ‘š ğ¿1| = 0, then the ï¬nal state satisï¬es |ğ‘‘ğ‘œğ‘š ğ¿1| = |ğ‘–ğ‘š ğ¿1| with probability
1 âˆ’ ğ‘˜ (ğ‘˜+1)
. In other words, the judgment behaves as a Hoare triple that has some probability of
2ğ‘™ +1
failure.

3 LANGUAGE
We consider a core language that models higher-order, stateful, probabilistic computations over
algebraic datatypes.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:7

Syntax. The language combines the usual constructs of ğœ†-calculus and monadic constructs. Monadic

computations are introduced and composed by unit and let. In addition, we have operations for
sampling from a distribution in a set D of base distributions, and for reading or writing at a lo-
cation in a set Loc of locations. We also consider a primitive skip operation that represents an
empty computation (we could also deï¬ne skip as unit(âˆ—), where âˆ— is the sole inhabitant of the
unit type), and a primitive mfold for nesting monadic computations (the reason why we make
mfold monadic will become apparent in the next paragraph, when typing is considered). Finally,
for technical reasons that will become apparent when deï¬ning the logic, we distinguish between
adversarial variables and standard variables. Formally, the terms of the language are given by the
following grammar:

ğ‘¡, ğ‘¢ ::= ğ‘¥ | A | âˆ— | 0 | ğ‘† ğ‘¢ | ğœ†ğ‘¥ .ğ‘¢ | ğ‘¡ ğ‘¢ | hğ‘¡, ğ‘¢i | if ğ‘¡ then ğ‘¢1 else ğ‘¢2 | ğœ‹1 (ğ‘¡) | ğœ‹2(ğ‘¡) |
read ğ‘ | ğ‘ := ğ‘¢ | skip | unit(ğ‘¡) | let ğ‘¥ = ğ‘¡ in ğ‘¢ | mfold ğ‘¡ ğ‘¢1 ğ‘¢2 | sample(ğœˆ)

where ğ‘¥ ranges over variables, A ranges over adversary variables, ğ‘ ranges over a set Loc of mem-
ory locations and ğœˆ ranges over a set D of distribution symbols. We assume that each distribution
has arity ğœğœˆ,1 Ã— Â· Â· Â· Ã—ğœğœˆ, |ğœˆ | â†’ ğœğœˆ , that accounts for the parameters of the distribution. The meaning
of the expressions is standard, except for the monadic fold operation for naturals, which sequences
computations in the monadic step, that is:

mfold 0 ğ‘¡ ğ‘¢ = ğ‘¡

mfold (ğ‘† ğ‘›) ğ‘¡ ğ‘¢ = let ğ‘¥ = (mfold ğ‘› ğ‘¡ ğ‘¢) in ğ‘¢ ğ‘¥

Syntactic sugar. In our examples we use some syntactic sugar to simplify the code. Concretely,
we will write ğ‘¥ = ğ‘¡; ğ‘¢ instead of (ğœ†ğ‘¥ .ğ‘¢) ğ‘¡, ğ‘™ := ğ‘¡ instead of let _ in ğ‘™ := ğ‘¡ (i.e., we do not bind the
returned value) and inc ğ‘™ instead of let ğ‘¦ = read ğ‘™ in ğ‘™ := ğ‘¦ + 1, where we assume ğ‘¦ is a free variable.

Eï¬€ects. We use a type-and-simple eï¬€ect system to model the memory footprint and oracle com-
plexity of computations. We model the memory footprint as (an overapproximation of) the set Î£
of memory locations read and written by a computation. In addition, our eï¬€ect system supports
abstract eï¬€ects and eï¬€ect polymorphism. These are used essentially to model adversaries. The
grading ğ‘˜ tracks how many times an adversary calls its oracles. For simplicity, we use a single
natural number for tracking oracle calls; however, it is possible to track oracle calls more ï¬nely
by having a number per oracle. Semantically, eï¬€ects form an ordered commutative monoid: mem-
ory eï¬€ects are modeled using (P(Loc âˆª R), âˆ…, âˆª, âŠ†), where R is a set of memory regions, P is the
powerset operator, and cost is modeled using (N, 0, +, â‰¤).

Types. Our language is essentially simply typed. As base types we consider the unit type U,
booleans B, and natural numbers, which are indexed by either a constant natural number ğ¾ or by
inï¬nity, to indicate an upper bound on the inhabitants of the type. We will simply write N for N[âˆ].
On top of this we consider extended computations, which are given a type TÎ£,ğ‘˜ (ğœ). Here, ğœ is the
return type, and Î£, ğ‘˜ is a grading that accounts for the memory eï¬€ect and cost of the computation.
We assume all locations in memory contain the same type V. We keep this abstract in the current
presentation, but we will instantiate it to a concrete type (e.g. N, B, . . . ) in the examples. Finally,
we include a type M for memories. These cannot be explicitly manipulated in the language, but
are used in speciï¬cations, see later in the section.

Formally, the set of types is given by the following syntax:

ğœ, ğœ ::= ğµ | B | N[ğ¾] | M | U | V | ğœ â†’ ğœ | ğœ Ã— ğœ | TÎ£,ğ‘˜ (ğœ) | âˆ€ğ›¼.ğœ
where ğµ ranges over a set of base types, ğ¾ ranges over natural numbers and the expression Î£ is
built from region variables and memory locations. Note that bounded natural types N[ğ¾] are used
to compute the grading of monadic folds.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:8

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

Î; Î”; Î“ âŠ¢ â˜…: U

Star

Î; Î”; Î“ âŠ¢ 0 : N[0]

Zero

Î; Î”; Î“ âŠ¢ ğ‘¡ : N[ğ¾]
Î; Î”; Î“ âŠ¢ ğ‘† ğ‘¡ : N[ğ¾ + 1]

Succ

Î”; Î“ âŠ¢ ğ‘¡ : N[ğ¾]

Î”; Î“ âŠ¢ ğ‘¢1 : TÎ£,ğ‘˜ (ğœ)

Î”; Î“ âŠ¢ ğ‘¢2 : ğœ â†’ TÎ£â€²,ğ‘˜â€² (ğœ)

Î”; Î“ âŠ¢ mfold ğ‘¡ ğ‘¢1 ğ‘¢2 : TÎ£âˆªÎ£â€²,ğ‘˜+ğ¾ Â·ğ‘˜â€² (ğœ)

Fold

Î; Î”; Î“ âŠ¢ ğ‘¡ : ğœ
Î; Î”; Î“ âŠ¢ unit(ğ‘¡) : Tâˆ…,0 (ğœ)
ğ‘ âˆˆ Loc
Î; Î”; Î“ âŠ¢ read ğ‘ : T{ğ‘ },0 (V)
Î; Î”; Î“ âŠ¢ ğ‘¡ğ‘– : ğœğœˆ,ğ‘–

Unit

Read

Î; Î”; Î“ âŠ¢ ğ‘¡1 : TÎ£1,ğ‘˜1 (ğœ)

Î; Î”; Î“, ğ‘¥ : ğœ âŠ¢ ğ‘¡2 : TÎ£2,ğ‘˜2 (ğœ)

Î; Î”; Î“ âŠ¢ let ğ‘¥ = ğ‘¡1 in ğ‘¡2 : TÎ£1âˆªÎ£2âˆªEï¬€ (ğœ),ğ‘˜1+ğ‘˜2 (ğœ)

Bind

Î; Î”; Î“ âŠ¢ ğ‘¢ : V
ğ‘ âˆˆ Loc
Î; Î”; Î“ âŠ¢ ğ‘ := ğ‘¢ : T{ğ‘ },0 (U)

Write

(âˆ€1 â‰¤ ğ‘– â‰¤ |ğœˆ |)

Sample

Î; Î”; Î“ âŠ¢ ğ‘¡ : ğœ â€²

Skip

Î; Î”; Î“ âŠ¢ skip : Tâˆ…,0 (U)
Î âŠ¢ ğœ â€² (cid:22) ğœ

Subtype

Î; Î”; Î“ âŠ¢ sample(ğœˆ (ğ‘¡1, . . . , ğ‘¡ |ğœˆ |)) : Tâˆ…,0 (ğœğœˆ )

Î, ğ›¼; Î”; Î“ âŠ¢ ğ‘¡ : ğœ

ğ›¼ âˆ‰ ğ¹ğ‘‰ (Î”; Î“)

Î; Î”; Î“ âŠ¢ ğ‘¡ : âˆ€ğ›¼.ğœ

ForAll-I

(A : âˆ€ğ›¼.(ğœ â†’ Tğ›¼,ğ‘˜ (ğœ)) â†’ Tğ›¼ âˆªÎ£,ğ‘˜â€² (ğœ â€²)) âˆˆ Î”

Î; Î”; Î“ âŠ¢ ğ‘¡ : ğœ

Î; Î”; Î“ âŠ¢ ğ‘¡ : âˆ€ğ›¼.ğœ

Î£ âˆˆ P(Loc)

Î; Î”; Î“ âŠ¢ ğ‘¡ : ğœ [Î£/ğ›¼]
Î, ğ›¼; Î”; Î“ âŠ¢ ğ‘¡ : ğœ â†’ TÎ£â€²,ğ‘˜ (ğœ)

ForAll-E

Adv

Î; Î”; Î“ âŠ¢ A ğ‘¡ : TÎ£âˆªÎ£â€²,ğ‘˜â€² (ğœ â€²)

(A : âˆ€ğ›¼.(ğœ â†’ Tğ›¼,ğ‘˜ (ğœ)) â†’ Tğ›¼ âˆªÎ£,ğ‘˜â€² (ğœ â€²)) âˆˆ Î”

Î; Î”; Î“ âŠ¢ ğ‘¡ : TÎ£1,ğ‘˜1 (ğœ â€²)

Î; Î”\A; â€¢ âŠ¢ ğ‘¢ : âˆ€ğ›¼.(ğœ â†’ Tğ›¼,ğ‘˜ (ğœ)) â†’ Tğ›¼ âˆªÎ£,ğ‘˜â€² (ğœ â€²)

Î; Î”\A; Î“ âŠ¢ ğ‘¡ [ğ‘¢/A] : TÎ£1,ğ‘˜1 (ğœ â€²)

Fig. 1. Selected typing rules

Adv-Inst

Type system. A typing judgment Î; Î”; Î“ âŠ¢ ğ‘¡ : ğœ is a relation between contexts, terms and types.
Contexts are triples of the form Î; Î”; Î“, where Î is a grading context, Î” is an adversary context,
and Î“ is a variable context. A grading context Î is a collection of variables ğ›¼, ğ›½, Â· Â· Â· representing
the memory regions manipulated by the computation. The adversary and variable contexts are
functions from a ï¬nite set of variables (adversary and standard, respectively). For a context Î“ and
ğ‘› distinct variables ğ‘¥ğ‘– such that ğ‘¥ğ‘– âˆ‰ dom Î“, by Î“, ğ‘¥1 : ğœ1, Â· Â· Â· , ğ‘¥ğ‘› : ğœğ‘› we mean the context obtained
by extending Î“ with ğ‘¥1 : ğœ1 Â· Â· Â· ğ‘¥ğ‘› : ğœğ‘›. We use a similar notation for Î”.

Typing rules are presented in Figure 1. Many rules are standard so we focus on the remaining
rules. The read and the write rules assume that locations store values of type V. The eï¬€ect of
a read or write is the location itself. The unit and bind rules act on the grading as the unit and
multiplication of the monoid from which the gradings are taken, but the bind rule also adds the
eï¬€ect Eï¬€ (ğœ) of the type ğœ encapsulated by the monad. This will be important for proving soundness
of the adversary rules, and it is deï¬ned as:

Eï¬€ (ğµ) , âˆ…

Eï¬€ (ğœ â†’ ğœ) , Eï¬€ (ğœ)

Eï¬€ (TÎ£,ğ‘˜ (ğœ)) , Î£ âˆª Eï¬€ (ğœ)

Eï¬€ (âˆ€ğ›¼.ğœ) = Eï¬€ (ğœ [âˆ…/ğ›¼])

Monadic fold (for natural numbers) deï¬nes an iterator. It receives a natural number bounded
by ğ¾, a computation ğ‘¢1 with cost ğ‘˜ for the zero case, and a computation ğ‘¢2 with cost ğ‘˜ for the
successor case. The operational semantics imply that ğ‘¢2 will be run at most ğ¾ times, and ğ‘¢1 will
be run exactly once, so we can give a bound ğ¾ Â· ğ‘˜ â€² + ğ‘˜ on the total cost. The rules for quantiï¬er
introduction and elimination are a lightweight version of eï¬€ect polymorphism. We can quantify
over any grading in Î that does not appear free in Î“ and Î”, and we can instantiate a quantiï¬er
to any concrete memory region. Since this does not actually have any computational content, we
choose to not reï¬‚ect these rules in the term.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:9

The adversary rule allows applying an adversary variable to an expression with matching type.
The instantiation rule for adversary variables substituting an adversary variable by a closed ex-
pression of the same type. This is the only distinction between standard and adversary variables
â€“ adversary variables represent closed expressions, while standard variables represent arbitrary
expressions. The reason for making this distinction will become clear when we describe logics.

Types are ordered by subtyping ğœ â€² (cid:22) ğœ, which is used in the [Subtype] rule. Subtyping is mostly
standard. On the type TÎ£,ğ‘˜ (ğœ), subtyping allows increasing ğ‘˜, Î£ and weakening ğœ. The rules for
subtyping are presented in Figure 6 in Appendix A.

Expressions about memories. In previous work [Aguirre et al. 2017], the terms appearing in log-
ical assertions and the terms (i.e., the programs) they specify about are derived from the same
grammar. In the current setting, program speciï¬cations contain distinguished variables represent-
ing the state, because they need to be able to refer explicitly to initial or ï¬nal states and their
contents, but we do not want programs to have this capability. Therefore, terms appearing in log-
ical assertions will be derived from a grammar that extends the grammar of programs:

Ëœğ‘¡, Ëœğ‘¢ ::= . . . | Ëœğ‘¡ [ğ‘] | Ëœğ‘¡ [ğ‘ â†¦â†’ Ëœğ‘¢]

Here, Ëœğ‘¡ [ğ‘] denotes the contents of state Ëœğ‘¡ at location ğ‘, Ëœğ‘¡ [ğ‘ â†¦â†’ Ëœğ‘¢] denotes the state resulting by re-
placing the contents of location ğ‘ in Ëœğ‘¡ by Ëœğ‘¢, and the ellipsis contains all the other term constructors.
Figure 7 in Appendix A presents the (obvious) typing rules for these new constructs.

4 HIGHER-ORDER UNARY LOGICS
In this section, we describe two program logics for our language. Both use the same syntactic proof
rules derived from a common template, but they diï¬€er signiï¬cantly in their semantics and apply
to very diï¬€erent veriï¬cation problems. The ï¬rst one is a higher-order Union Bound Logic, in the
line of [Barthe et al. 2016b]. This logic allows proving postconditions (for probabilistic computa-
tions) that may not hold with an explicit â€œerrorâ€ probability ğ›¿. The second one is a higher-order
expectation logic, in the line of [Barthe et al. 2018; Kozen 1985; Morgan et al. 1996]. Instead of
specifying programs with qualitative assertions (that can either be true or false), this logic uses
quantitative assertions ranging over the non-negative reals. The logic can be used to prove bounds
on the expected values of quantitative postconditions. Both logics have adversaries and state.

4.1 Higher-order Union Bound Logic

The syntax of our union bound logic (HO-UBL) is shown below. Propositions ğœ™,ğœ“ are standard
(intuitionistic) HOL formulas over terms. Quantiï¬ers range over these terms. In contrast, assertions
ğ‘ƒ, ğ‘„ denote pre- and post-conditions that relate the languageâ€™s expressions and the current heap
state. ğ‘… and ğ‘“ denote atomic propositions and atomic assertions, respectively. hğœ™i is an injection
of propositions into assertions. The connectives âŠ“ and âŠ” respectively denote conjunction (âˆ§) and
disjunction (âˆ¨) at the level of assertions.1 2 To refer to the state, assertions ğ‘ƒ, ğ‘„ may contain a
distinguished variable s, which stands for the current state. Similarly, propositions ğœ™,ğœ“ can contain
a distinguished variable v that stands for (the value of) the term being veriï¬ed.

1There is a reason for using diï¬€erent symbols for these connectives in propositions and assertions: In the expectation logic
(Section 4.2), we want to reuse the same syntax, but give assertions quantitative interpretations while retaining the Boolean
interpretations for propositions. Using diï¬€erent symbols for the connectives prevents confusion there.
2We can add quantiï¬ers âˆ€, âˆƒ to assertions, but we elide them here. Our examples only use ï¬nite quantiï¬cation in assertions,
which can be encoded using âŠ“ and âŠ”.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:10

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

::= ğ‘…(ğ‘¡1, . . . , ğ‘¡ğ‘›) | âŠ¤ | âŠ¥ | ğœ™ âˆ§ ğœ“ | ğœ™ âˆ¨ ğœ“ | ğœ™ â‡’ ğœ“ | Â¬ğœ™ | âˆ€ğ‘¥ : ğœ.ğœ™ | âˆƒğ‘¥ : ğœ.ğœ™

ğœ™,ğœ“
ğ‘ƒ, ğ‘„ ::= ğ‘“ ( Ëœğ‘¡1, . . . , Ëœğ‘¡ğ‘›) | âŠ¤ | âŠ¥ | hğœ™i | ğ‘ƒ âŠ” ğ‘„ | ğ‘ƒ âŠ“ ğ‘„

Propositions
Assertions
Assumptions Î¨
Judgments

::= â€¢ | Î¨, ğœ“

Î | Î” | Î“ | Î¨ âŠ¢ ğœ™
Î | Î” | Î“ | Î¨ âŠ¢ ğ‘ƒ â‡› ğ‘„
Î | Î” | Î“ | Î¨ âŠ¢ ğ‘¡ : ğœ {ğœ™ }
Î | Î” | Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿

The logic has four judgments that rely on four contextsâ€”Î, Î” and Î“ that were described earlierâ€”
and the new context Î¨, which contains logical assumptions (propositions) ranging over the vari-
ables in Î” and Î“. Since most of our rules do not modify or read the contexts and Î and Î”, we omit
them from most of the discussion below. This simpliï¬es the judgments, e.g., we write Î“ | Î¨ âŠ¢ ğœ™
instead of Î | Î” | Î“ | Î¨ âŠ¢ ğœ™.

The ï¬rst judgment Î“ | Î¨ âŠ¢ ğœ™ is HOLâ€™s standard entailment judgment. It means that the proposi-
tion ğœ“ holds for all typed instantiations of the variables in Î“ satisfying all propositions in Î¨. The
second judgment Î“ | Î¨ âŠ¢ ğ‘ƒ â‡› ğ‘„ is entailment of assertions; it means that the assertion ğ‘ƒ entails
the assertion ğ‘„ for all typed instantiations of Î“ satisfying Î¨.

The third judgment Î“ | Î¨ âŠ¢ ğ‘¡ : ğœ {ğœ™ } means that for all typed instantiations of Î“ satisfying Î¨,
the term ğ‘¡ (of type ğœ) satisï¬es ğœ™ [ğ‘¡/v]. (Recall that v is a distinguished variable.) In other words,
the judgment speciï¬es a property ğœ™ of the term ğ‘¡ being veriï¬ed. This judgmentâ€™s proof rules are
directed by the syntax of ğ‘¡ and are taken as-is from the prior logic UHOL [Aguirre et al. 2017].
The work on UHOL also shows that these syntax-directed rules are sound and complete relative
to HOL: Î“ | Î¨ âŠ¢ ğ‘¡ : ğœ {ğœ™ } iï¬€ Î“ | Î¨ âŠ¢ ğœ™ [ğ‘¡/v]. We reproduce these rules in Appendix B.

The fourth judgment Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿ is new to our logic. It speciï¬es a pre-condition
ğ‘ƒ and a post-condition ğ‘„ for a monadic computation ğ‘¡ of type TÎ£,ğ‘˜ (ğœ). Recall that a monadic com-
putation of this type is stateful and probabilistic â€” it takes a state and produces a distribution on
results of type ğœ and ï¬nal states. The judgment means that, for any instantiation of Î“ satisfying
all propositions in Î¨, starting the execution of ğ‘¡ in any state ğ‘š that satisï¬es ğ‘ƒ [ğ‘š/s], the ï¬nal state
ğ‘šâ€² and result ğ‘¡ â€² (of type ğœ) satisfy ğ‘„ [ğ‘šâ€²/s] [ğ‘¡ â€²/v] with probability at least 1 âˆ’ ğ›¿. Additionally, only
locations in the set Î£ are modiï¬ed. In other words, the judgment represents a standard Hoare-
triple for stateful computations, but with a small twist: the postcondition may not hold with an
error probability ğ›¿. The semantics of this judgment is deï¬ned by lifting standard Hoare triples to
distributions (Section 6.5).

Formally, the pre-condition ğ‘ƒ can contain the free variable s : M (where M is the type of memo-
ries), while ğ‘„ can contain the variables s : M and v : ğœ. Additionally, both may mention variables
from Î“ and the elided context Î”. The restriction that only locations in Î£ be modiï¬ed during ğ‘¡â€™s
reduction is needed for handling adversaries as we explain soon. The judgment also does not make
use of the grade ğ‘˜ in the type TÎ£,ğ‘˜ (ğœ); this grade is also used for handling adversaries.

Monadic rules. Figure 2 presents the main rules of the fourth judgment. As before, we omit the
contexts Î and Î”; these transfer unchanged from the conclusion to the premises in all rules. All
our rules are syntax-directed. The rule UNIT-U applies to the term unit(ğ‘¡), which returns the term
ğ‘¡ without modifying the state with probability 1. The rule just restates this diï¬€erently. Formally, if
ğ‘¡ satisï¬es ğœ™ (ï¬rst premise), then executing unit(ğ‘¡) from a state satisfying ğ‘ƒ results in a state and
return term that satisfy hğœ™iâŠ“ğ‘ƒ. The probability of this not happening is 0. (The premise Î“, s : M âŠ¢ ğ‘ƒ
just means that the assertion ğ‘ƒ is a well-formed predicate over the typed variables in Î“, s : M.)

The rule MLET-U for the monadic bind is a generalization of the usual sequencing rule of Hoare
logic. The error probabilities ğ›¿ and ğ›¿ â€² are summed in the conclusion. This is easy to see: From the

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:11

Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿

Î“, ğ‘¥ : ğœ | Î¨ âŠ¢ {ğ‘„ [ğ‘¥/v]}ğ‘¢ : TÎ£â€²,ğ‘˜â€² (ğœ){{ğ‘…}}ğ›¿â€²

ğ‘¥ âˆ‰ ğ‘…

Î“ | Î¨ âŠ¢ {ğ‘ƒ }let ğ‘¥ = ğ‘¡ in ğ‘¢ : TÎ£âˆªÎ£â€²âˆªEï¬€ (ğœ),ğ‘˜+ğ‘˜â€² (ğœ){{ğ‘…}}ğ›¿+ğ›¿â€²

MLET-U

Î“ | Î¨ âŠ¢ ğ‘¡ : ğœ {ğœ™ }

Î“, s : M âŠ¢ ğ‘ƒ

Î“ | Î¨ âŠ¢ {ğ‘ƒ }unit(ğ‘¡) : Tâˆ…,0 (ğœ){{hğœ™i âŠ“ ğ‘ƒ }}0

UNIT-U

Î“ | Î¨ âŠ¢ {ğ‘ƒ [s[ğ‘]/v]}read ğ‘ : T{ğ‘ },0 (V){{ğ‘ƒ }}0

READ-U

Î; Î“ âŠ¢ ğ‘¡ : V
Î“ | Î¨ âŠ¢ {ğ‘ƒ [s[ğ‘ â†¦â†’ ğ‘¡]/s]}ğ‘ := ğ‘¡ : T{ğ‘ },0 (U){{ğ‘ƒ }}0

WRITE-U

Î“ âŠ¢ ğ‘ : B

Î“ | Î¨, ğ‘ = tt âŠ¢ {ğ‘ƒ1}ğ‘¡1 : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿

Î“ | Î¨, ğ‘ = ï¬€ âŠ¢ {ğ‘ƒ2}ğ‘¡2 : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿

Î“ | Î¨ âŠ¢ {hğ‘ = tti âŠ“ ğ‘ƒ1) âŠ” (hğ‘ = ï¬€i âŠ“ ğ‘ƒ2)}if ğ‘ then ğ‘¡1 else ğ‘¡2 : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿
Î“ âŠ¢ ğ‘› : N[ğ¾]

Î“ | Î¨ âˆ§ ğ‘› = 0 âŠ¢ {ğ‘ƒ }ğ‘¡1 : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿

Î“, ğ‘¥ : ğœ | Î¨ âˆ§ ğ‘› â‰  0 âŠ¢ {ğ‘„ }ğ‘¡2 : TÎ£â€²,ğ‘˜â€² (ğœ){{ğ‘„ }}ğ›¿â€²

Î“ | Î¨ âŠ¢ {ğ‘ƒ }mfold ğ‘› ğ‘¡1 (ğœ†ğ‘¥.ğ‘¡2) : TÎ£âˆªÎ£â€²,ğ‘˜+ğ¾ Â·ğ‘˜â€² (ğœ){{ğ‘„ }}ğ›¿+ğ¾ Â·ğ›¿â€²

MCASE-U

MFOLD-U

Fig. 2. Monadic proof rules of our higher-order union bound logic. These rules are reused for the higher-order
expectation logic with a diï¬€erent interpretation of hğœ™i, âŠ“, and âŠ”.

Î“ | Î¨ âŠ¢ ğ‘ƒ â‡› ğ‘ƒ â€²

Î“ | Î¨ âŠ¢ {ğ‘ƒ â€²}ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ â€²}}ğ›¿â€²

Î“ | Î¨ âŠ¢ ğ‘„ â€² â‡› ğ‘„

ğ›¿ â€² â‰¤ ğ›¿

Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿

CONSEQ-U

Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿

Î“ | Î¨ âŠ¢ {ğ‘ƒ â€²}ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿

Î“ | Î¨ âŠ¢ {ğ‘ƒ âŠ” ğ‘ƒ â€²}ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿

Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿

Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ â€²}}ğ›¿â€²

Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ âŠ“ ğ‘„ â€²}}ğ›¿+ğ›¿â€²

OR-PRE-U

AND-POST-U

Fig. 3. Selected structural rules of the higher-order union bound logic. These rules are reused for the higher-
order expectation logic with a diï¬€erent interpretation of âŠ“, âŠ” and â‡›.

ï¬rst premise, with probability at least 1 âˆ’ ğ›¿, the postcondition ğ‘„ of ğ‘¡ holds and, hence, from the
second premise, with probability at least (1 âˆ’ ğ›¿) âˆ’ ğ›¿ â€², the postcondition ğ‘… holds. Hence, the error
probability is at most ğ›¿ + ğ›¿ â€².

The rules READ-U and WRITE-U propagate heap changes backwards, as in standard Hoare
logic. We also have the rule MCASE-U for conditionals of monadic type. Again, this rule follows
the rule for conditionals in Hoare logic. The rule MFOLD-U applies to mfold ğ‘› ğ‘¡1 (ğœ†ğ‘¥ .ğ‘¡2). Here, ğ¾
is a bound on the number of iterations (ï¬rst premise). The error probability in the conclusion is
the error probability ğ‘˜ â€² of the iterationâ€™s body scaled by ğ¾.

Structural rules. Figure 3 shows selected structural rules of our logic. The rule of consequence,
CONSEQ-U, allows weakening postconditions and error probabilities, and strengthening precon-
ditions. The rule OR-PRE-U allows case analysis in the precondition. Finally, the rule AND-POST-
U allows splitting a conjunction in the postcondition. Note that in this case, the error probability
ğ›¿ +ğ›¿ â€² is the sum of the error probabilities of the two conjuncts. This sum is a standard union bound
on (error) probabilities, which explains the name of our logic.

Rules for monadic primitives. Additionally, we include rules for monadic primitives that we use
in examples. For instance, the following rule is used for typing the term Unif(ğœ), which samples a

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:12

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

value uniformly from the ï¬nite type ğœ. The sampling does not change the state, so the rule copies
the precondition ğ‘ƒ to the postcondition. The sampled value additionally satisï¬es any predicate ğœ™
of cardinality ğ‘ with probability 1 âˆ’ ğ‘ /|ğœ |.

Î“ | Î¨ âŠ¢ ğ‘ƒ â‡› (|{ğ‘¥ âˆˆ ğœ | ğ‘¥ âˆˆ ğœ™ }| / |ğœ | = ğ›¿)
Î“ | Î¨ âŠ¢ {ğ‘ƒ }Unif (ğœ) : Tâˆ…,0 (ğœ){{ğ‘ƒ âˆ§ ğœ™ }}1âˆ’ğ›¿

SAMPLE-UBL

Adversary rule

In security applications, one often wants to prove properties of â€œadversarialâ€ code, of which very
little is known statically. Typically, one may know or assume that the adversarial code is closed, has
a speciï¬c simple type and that it has a certain bounded complexity, but not much else. Veriï¬cation
of such unknown code, unsurprisingly, relies on parametricity properties of the language. To this
end, we need proof rules that internalize parametric reasoning into the logic. Below we show one
such rule, ADV-U, which suï¬ƒces for our examples. We ï¬rst explain the rule informally and then
give more formal details:

(A : âˆ€ğ›¼.(ğœ â†’ Tğ›¼,1 (ğœ)) â†’ TÎ£âˆªğ›¼,ğ‘˜ (ğœ â€²)) âˆˆ Î”

Î” | s : M âŠ¢ ğ‘ƒ

ğ‘ƒ âˆˆ Safe(Î£)

Î” | ğ‘¥ : ğœ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£â€²,1 (ğœ){{ğ‘ƒ }}ğ›¿
ğœ, ğœ, ğœ â€² non-monadic types

(ğ‘¥ âˆ‰ Î¨, ğ‘ƒ)

Î” | â€¢ | Î¨ âŠ¢ {ğ‘ƒ }A (ğœ†ğ‘¥.ğ‘¡) : TÎ£âˆªÎ£â€²,ğ‘˜ (ğœ){{ğ‘ƒ }}ğ‘˜ Â·ğ›¿

ADV-U

Informal explanation. Informally, ADV-U says the following. Suppose:

- A is an arbitrary (adversarial) closed second-order program whose side eï¬€ects are limited to

the locations in Î£, and that uses its argument at most ğ‘˜ times (ï¬rst premise),

- ğœ†ğ‘¥ .ğ‘¡ is an argument for A such that ğ‘¡ preserves the assertion ğ‘ƒ on memories, except with

probability ğ›¿ (second premise), and

- ğ‘ƒ does not depend on the values in any locations in Î£ (premise ğ‘ƒ âˆˆ Safe(Î£), which is deï¬ned

formally later).

Then, A applied to (ğœ†ğ‘¥ .ğ‘¡) preserves the assertion ğ‘ƒ except with probability ğ‘˜ Â· ğ›¿.

We can easily see why the conclusion holds. First, since ğ‘ƒ depends only on values of locations
outside Î£, to violate ğ‘ƒ, A must modify locations outside Î£. Next, the only way A can even hope to
modify variables outside Î£ is by invoking its argument (ğœ†ğ‘¥ .ğ‘¡). This is because Aâ€™s own eï¬€ects are
limited to Î£ and it is closed, so it cannot get access to other eï¬€ects due to additional substitutions.
Hence, the only way for A to violate ğ‘ƒ is by invoking ğœ†ğ‘¥ .ğ‘¡. However, ğ‘¡ violates ğ‘ƒ with probability
at most ğ›¿ and A cannot apply ğœ†ğ‘¥ .ğ‘¡ more than ğ‘˜ times. Hence, by a straightforward union bound,
Aâ€™s chances of violating ğ‘ƒ are bounded by ğ‘˜ Â· ğ›¿, which is exactly the conclusion.

The remarkable aspect of the rule is how little it assumes about the adversarial expression A â€“
just that A is closed, that it uses its argument at most ğ‘˜ times and that its side-eï¬€ects are limited to
Î£. The derived conclusion â€“ that ğ‘ƒ is preserved except with probability ğ‘˜ Â·ğ›¿ â€“ holds for any closed,
simply typed substitution for the variable A. This is what makes this rule very powerful and useful.
For example, in security applications, A can model an arbitrary, unknown â€œadversaryâ€ of bounded
complexity ğ‘˜ that is given a known â€œoracleâ€ as argument. The rule then proves properties of any
instance of the adversary applied to a given oracle (ğœ†ğ‘¥ .ğ‘¡), without having to verify the adversary.

Formal notes. The type of A (ï¬rst premise) ensures that its argument incurs an eï¬€ect of at least
1 unit at each use, and that the total eï¬€ect of A is ğ‘˜. Hence, A cannot use its argument more
than ğ‘˜ times. Further, the rule insists that A exist in Î”, not Î“. This ensures that A represents a
closed term. Finally, the quantiï¬cation over the eï¬€ect set ğ›¼ ensures that A itself writes only to
the locations in Î£.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:13

The condition ğ‘ƒ âˆˆ Safe(Î£) is formally deï¬ned as âˆ€ğ‘š1 ğ‘š2 : M. (âˆ€ğ‘ âˆ‰ Î£. ğ‘š1 [ğ‘] = ğ‘š2 [ğ‘]) â‡’
ğ‘ƒ [ğ‘š1/s] â‡” ğ‘ƒ [ğ‘š2/s], and means that ğ‘ƒ is independent of the values in locations in Î£. The condition
that ğœ, ğœ and ğœ â€² be non-monadic is a technical simpliï¬cation: the rule is proven sound using a
logical relation, and terms of non-monadic types trivially inhabit the relation. The restriction can
be lifted by imposing additional logical conditions on the argument and result value of ğ‘¡, as well as
requiring that ğ‘ƒ must be also safe for the eï¬€ects in ğœ â€². Similarly, the restriction to closed adversaries
can be lifted by requiring that every free variable is instantiated to a term that inhabits the logical
relation.

We chose a particular second-order type for adversaries in this paper, which was the most conve-
nient for our examples. However, the soundness argument can be used to easily derive adversary
rules for diï¬€erent adversaries, e.g. adversaries that accept multiple oracles or third-order adver-
saries, that interact with oracles that receive functions as arguments.

In the examples it is often convenient to use a mild extension of the rule, where the invariant
ğ‘ƒğ‘– and the error bound ğ›¿ğ‘– depend on some natural number ğ‘– and we show that (1) each oracle
call with precondition ğ‘ƒğ‘– satisï¬es the postcondition ğ‘ƒğ‘–+1 with error probability ğ›¿ğ‘– and (2) every ğ‘ƒğ‘–
implies ğ‘ƒğ‘–+1, from which we deduce that the adversarial computation satisï¬es the postcondition
ğ‘ƒğ‘˜ with error probability ğ›¿1 + Â· Â· Â· + ğ›¿ğ‘˜ . To avoid cluttering the notation, here and in Section 5 we
present the rules without this indexing.

Example: Probability of collisions
We now exercise our proof system to upper bound the probability of collisions for all adversaries
making at most ğ‘˜ queries to a PRF. Recall that our goal is to prove

A : âˆ€ğ›¼.({0, 1}ğ‘™ â†’Tğ›¼,1({0, 1}ğ‘™ ))â†’TÎ£âˆªğ›¼,ğ‘˜ ({0, 1}) âŠ¢ {ğ¸ğ‘šğ‘ğ‘¡ğ‘¦}A PRF : TÎ£,ğ‘˜ ({0, 1}){{Î¦ğ‘˜ }}ğ‘˜ (ğ‘˜+1)/2ğ‘™ +1

where Î¦ğ‘– , |ğ‘‘ğ‘œğ‘š(ğ¿)| = |ğ‘–ğ‘š(ğ¿)| âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿)| â‰¤ ğ‘–.

Applying the proof rule for adversaries, it suï¬ƒces to prove that the ğ‘–-th call of the oracle pre-
serves the assertion ğ‘ğ‘œğ¶ğ‘œğ‘™ğ‘™ with error probability at most ğ‘–/2ğ‘™ . Here we use the fact that at the
ğ‘–-th iteration the domain of ğ¿ has size at most ğ‘–. So we have to prove:
ğ‘¥ : {0, 1}ğ‘™ âŠ¢ {|ğ‘‘ğ‘œğ‘š (ğ¿)| = |ğ‘–ğ‘š (ğ¿)| âˆ§ |ğ‘‘ğ‘œğ‘š (ğ¿)| â‰¤ ğ‘–}ğ‘’ : Tğ›¼,1 ({0, 1}ğ‘™ ){{|ğ‘‘ğ‘œğ‘š (ğ¿)| = |ğ‘–ğ‘š (ğ¿)| âˆ§ |ğ‘‘ğ‘œğ‘š (ğ¿)| â‰¤ ğ‘– + 1}}ğ‘–/2ğ‘™
where ğ‘’ is the body of ğ‘ƒğ‘…ğ¹ . We work our way backwards starting with ğ‘ƒğ‘–+1 , {{|ğ‘‘ğ‘œğ‘š(ğ¿)| =
|ğ‘–ğ‘š(ğ¿)| âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿)| â‰¤ ğ‘– + 1}}ğ‘–/2ğ‘™ from the end of the program and compute the precondition of each
statement. Note that we keep the grading because every precondition is the postcondition of the
previous statement. The last instruction is a return, which we can skip since our assertion does
not mention the return value.

Now we encounter the case split. The else branch is empty, so its precondition is still ğ‘ƒğ‘–+1. On
the then branch we start by strengthening the postcondition to {{ğ‘¥ âˆ‰ ğ‘‘ğ‘œğ‘š(ğ¿) âˆ§ ğ‘ƒğ‘–+1}}ğ‘–/2ğ‘™ . Then we
have the assignment ğ¿1 [ğ‘¥1] = ğ‘§1, whose precondition is

{{ğ‘¥1 âˆ‰ ğ‘‘ğ‘œğ‘š(ğ¿) âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿) âˆª {ğ‘¥1}| = |ğ‘–ğ‘š(ğ¿) âˆª {ğ‘§1}| âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿) âˆª {ğ‘¥1}| â‰¤ ğ‘– + 1}}ğ‘–/2ğ‘™

Now we can strengthen this to
{{ğ‘§1 âˆ‰ ğ‘–ğ‘š(ğ¿) âˆ§ ğ‘¥1 âˆ‰ ğ‘‘ğ‘œğ‘š(ğ¿) âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿) âˆª {ğ‘¥1}| = |ğ‘–ğ‘š(ğ¿) âˆª {ğ‘§1}| âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿) âˆª {ğ‘¥1}| â‰¤ ğ‘– + 1}}ğ‘–/2ğ‘™
which is equivalent to

{{ğ‘§1 âˆ‰ ğ‘–ğ‘š(ğ¿) âˆ§ ğ‘¥1 âˆ‰ ğ‘‘ğ‘œğ‘š(ğ¿) âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿)| + 1 = |ğ‘–ğ‘š(ğ¿)| + 1 âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿)| + 1 â‰¤ ğ‘– + 1}}ğ‘–/2ğ‘™
and by the SAMPLE-UBL rule, we know that the probability of sampling something outside ğ‘–ğ‘š(ğ¿)
is at least 1 âˆ’ ğ‘–/(2ğ‘™ ), so the precondition of this is

{{ğ‘¥1 âˆ‰ ğ‘‘ğ‘œğ‘š(ğ¿) âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿)| + 1 = |ğ‘–ğ‘š(ğ¿)| + 1 âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿)| + 1 â‰¤ ğ‘– + 1}}0

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:14

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

This is the precondition of the then branch. By the MCASE-U rule, the precondition of the whole
case construct is

(ğ‘¥ âˆ‰ ğ‘‘ğ‘œğ‘š(ğ¿) âˆ§ (ğ‘¥ âˆ‰ ğ‘‘ğ‘œğ‘š(ğ¿) âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿)| + 1 = |ğ‘–ğ‘š(ğ¿)| + 1 âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿)| + 1 â‰¤ ğ‘– + 1))âˆ¨
(ğ‘¥ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¿) âˆ§ (|ğ‘‘ğ‘œğ‘š(ğ¿)| = |ğ‘–ğ‘š(ğ¿)| âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿)| â‰¤ ğ‘– + 1))

.

(cid:27)(cid:27)0

(cid:26)(cid:26)

By strengthening, we ï¬nally get {{(|ğ‘‘ğ‘œğ‘š(ğ¿)| = |ğ‘–ğ‘š(ğ¿)| âˆ§ |ğ‘‘ğ‘œğ‘š(ğ¿)| â‰¤ ğ‘–))}}0, which is exactly ğ‘ƒğ‘– .

4.2 Higher-order expectation logic
Our second logic (HO-EXP) is a quantitative (non-Boolean) higher-order expectation logic that
proves upper bounds on expected values of functions of program results and ï¬nal memories. The
logic extends expectation calculi [Kaminski et al. 2016; Morgan et al. 1996] to the higher-order
setting.

This logic is syntactically very similar to the higher-order union bound logic of Section 4.1 in the
formulas, the judgments and most of the proof rules, but it is very diï¬€erent in the interpretation
of assertions ğ‘ƒ, ğ‘„. Speciï¬cally, assertions in this logic are non-negative real-valued functions of
their free variables (Î”, Î“, v, s). The assertion connectives âŠ“ and âŠ” are the pointwise supremum
and inï¬mum operators on such functions, as deï¬ned below. (Propositions ğœ™,ğœ“ still have Boolean
interpretations, as in the union bound logic.)

To upper bound expected values, the monadic judgment Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿ is inter-
preted quantitatively, in terms of expectations.3 Speciï¬cally, the inner judgment {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿
means that for every state ğ‘š : M, if we run ğ‘¡ from state ğ‘š, then the expected value of ğ‘„ over all possi-
ble ï¬nal states is upper-bounded by ğ‘ƒ [ğ‘š/s] +ğ›¿. That is, E(ğ‘šâ€²,ğ‘¡ â€²)âˆ¼ğ‘¡ (ğ‘š) [ğ‘„ [ğ‘šâ€²/s] [ğ‘¡ â€²/v]] â‰¤ ğ‘ƒ [ğ‘š/s] +ğ›¿.
The whole judgment Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿ means that this inequality holds for all substi-
tutions for Î“ that satisfy Î¨. Again, the formal semantics of this judgment is deï¬ned by a lifting.
Conventionally, ğ‘ƒ and ğ‘„ are respectively called the pre-expectation and the post-expectation of
the term ğ‘¡. Informally, the judgment {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿ means that the expected value of the
post-expectation is upper-bounded by the pre-expectation plus an error ğ›¿.

Syntax. The logic reuses the syntax of the union bound logic (Section 4.1), but we extend asser-
tions with some connectives that are speciï¬c to quantities. These new connectives are shown in
blue-bold font below.

Assertions

ğ‘ƒ, ğ‘„ ::= ğ‘“ (ğ‘¡1, . . . , ğ‘¡ğ‘›) | âŠ¤ | âŠ¥ | hğœ™i | ğ‘ƒ âŠ” ğ‘„ | ğ‘ƒ âŠ“ ğ‘„ | [ğœ™] | P + Q | k Â· P

Assertions are quantities ranging over [0, âˆ]. ğ‘“ denotes a function with codomain [0, âˆ]. Asser-
tion connectives have the following interpretations.

JâŠ¤K

, 0
Jğ‘ƒ âŠ” ğ‘„K , inf {Jğ‘ƒK, Jğ‘„K}
ğœ™ holds

Jhğœ™iK

,

0
âˆ ğœ™ does not hold

Jğ‘ƒ + ğ‘„K , Jğ‘ƒK + Jğ‘„K

(cid:26)

JâŠ¥K

, âˆ
Jğ‘ƒ âŠ“ ğ‘„K , sup{Jğ‘ƒK, Jğ‘„K}
1 ğœ™ holds
0 ğœ™ does not hold

J[ğœ™]K

,

Jğ‘˜ Â· ğ‘ƒK

(cid:26)
, ğ‘˜ Â· Jğ‘ƒK

Note that âŠ¥ is interpreted as âˆ, not 0. Similarly, âŠ“ corresponds to supremum, not inï¬mum. This
reversal of the usual order is due to the fact that we want to prove upper bounds. The connective
[ğœ™] is also called the Iverson bracket [Iverson 1962].

The judgment Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿ is interpreted as explained above. The judgment

Î“ | Î¨ âŠ¢ ğ‘ƒ â‡› ğ‘ƒ â€² means that ğ‘ƒ â‰¥ ğ‘ƒ â€² for all instantiations of Î“ that satisfy Î¨.

3As in Section 4.1, the contexts Î, Î” also exist but are elided from most of the presentation for brevity.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:15

Proof rules. The expectation logic reuses the monadic and structural proof rules of the union
bound logic as is (Figures 2 and 3). However, the rulesâ€™ meanings are quantitative and their sound-
ness is completely diï¬€erent. We illustrate the new meanings of some of these rules by explaining
why they are still sound.

In rule UNIT-U, the premise ensures that ğœ™ holds (for the term ğ‘¡). So, hğœ™i equals 0 semantically,
and hğœ™i âŠ“ ğ‘ƒ is equivalent to ğ‘ƒ. Combined with the fact that unit(ğ‘¡) returns ğ‘¡ and does not modify
the memory, both with probability 1, the rule is trivially sound. The rule MLET-U corresponds
to the standard composition of random functions. In the rule MCASE-U, the precondition hğ‘ =
tti âŠ“ ğ‘ƒ1) âŠ” (hğ‘ = ï¬€i âŠ“ ğ‘ƒ2) in the conclusion is semantically equal to ğ‘ƒ1 when ğ‘ = tt and ğ‘ƒ2 when
ğ‘ = ï¬€. Hence, the conclusion reduces to either the second or the third premise.4

We also have a new structural rule (LIN-EXP) that allows combining two diï¬€erent Hoare triples

for the same program, relying on the linearity of expectations.

Î“ | Î¨ âŠ¢ {ğ‘ƒ1}ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„1}}ğ›¿1

Î“ | Î¨ âŠ¢ {ğ‘ƒ2}ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„2}}ğ›¿2

Î“ | Î¨ âŠ¢ {ğ‘ƒ1 + ğ‘ƒ2}ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„1 + ğ‘„2}}ğ›¿1+ğ›¿2

LIN-EXP

Rules for monadic primitives. Finally, we include rules for monadic primitives that we use in
examples. For instance, the rule UNIF-EXP below applies to the term Unif(ğ¾), which samples
from the uniform distribution over {0, 1, . . . , ğ¾ âˆ’ 1}. For ğ‘ˆ âŠ† {0, . . . , ğ¾ âˆ’ 1}, a value sampled from
this distribution is in ğ‘ˆ with probability exactly |ğ‘ˆ |/(ğ¾). Hence, the expected value of [v âˆˆ ğ‘ˆ ] is
exactly |ğ‘ˆ |/(ğ¾), which is the pre-expectation.

ğ‘ˆ âŠ† {0, . . . , ğ¾ âˆ’ 1}
Î“ | Î¨ âŠ¢ {(|ğ‘ˆ |/ğ¾) Â· ğ‘ƒ }Unif (ğ¾) : Tâˆ…,0 (N[ğ¾]){{[v âˆˆ ğ‘ˆ ] Â· ğ‘ƒ }}0

UNIF-EXP

Adversary rule. The expectation logic admits the adversary rule ADV-U of the union bound
logic but with a quantitative deï¬nition of the meta-predicate Safe. Here, ğ‘ƒ âˆˆ Safe(Î£) is deï¬ned as
âˆ€ğ‘š1 ğ‘š2 : M. (âˆ€ğ‘ âˆ‰ Î£. ğ‘š1 [ğ‘] = ğ‘š2 [ğ‘]) â‡’ ğ‘ƒ [ğ‘š1/s] = ğ‘ƒ [ğ‘š2/s]. With this change to the deï¬nition
of Safe, the rule is sound for expectations.

Example. We consider pollution attacks on Bloom Filters motivated in Section 2. We consider an
arbitrary adversary A with access to the insert oracle of a Bloom ï¬lter. The goal of the adversary
is to set as many bits in the Bloom ï¬lter to 1 as possible using ğ‘˜ queries to the oracle. We assume
that the Bloom ï¬lter is initially empty and, for simplicity, that it uses only one hash function, i.e.,
â„“ = 1 (our proof easily generalizes to any â„“). We model the hash function as a random oracle that is
sampled lazily. The Bloom ï¬lter is implemented as a vector of ğ‘š bits in locations ğ¿[0], . . . , ğ¿[ğ‘š âˆ’1].
The inserted elements are from the set [ğ‘›] = {0, . . . , ğ‘› âˆ’ 1}, and â„[0] . . . â„[ğ‘  âˆ’ 1] are auxiliary
locations that hold integers. Additionally, we assume a location ğ‘Ÿ that holds a counter. This is
a ghost variable to help us in our veriï¬cation eï¬€ort, it is concretely used to make the invariant
depend on the number of previous calls. Initially, each ğ¿[ğ‘–] is set to 0, each â„[ğ‘–] is set to âˆ’1 and ğ‘Ÿ
is set to 0. The code of the insert oracle is shown below:

insert(ğ‘¥ : [ğ‘›]) , let ğ‘ = read â„[ğ‘¥] in

if ğ‘ â‰  âˆ’1 then

let ğ‘¦ = Unif(ğ‘š) in
â„[ğ‘¥] := ğ‘¦; ğ¿[ğ‘¦] := 1; inc ğ‘Ÿ

else inc ğ‘Ÿ

4The precondition hğ‘ = tti âŠ“ ğ‘ƒ1) âŠ” ( hğ‘ = ï¬€ i âŠ“ ğ‘ƒ2) is semantically equivalent to ( [ğ‘ = tt] Â· ğ‘ƒ1) + ( [ğ‘ = ï¬€ ] Â· ğ‘ƒ2). The latter
is a more conventional way of writing the precondition [Morgan et al. 1996], but we prefer the former because it shows
the correspondence to the union bound logic.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:16

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

We want to show that the expected number of bits any adversary can set after making ğ‘˜ calls
to the adversary is upper bounded by ğ‘š(1 âˆ’ ((ğ‘š âˆ’ 1)/ğ‘š)ğ‘˜ ). For this, we prove that for any A :
âˆ€ğ›¼.( [ğ‘›] â†’ Tğ›¼,1(U)) â†’ Tğ›¼ âˆªÎ£,ğ‘˜ (U), we have

where the expectation ğ¹ is deï¬ned as

âŠ¢ {ğ¹ }A insert : TÎ£âˆª{ğ¿,â„,ğ‘Ÿ },ğ‘˜ (ğœ){{ğ¹ }}0,

ğ¹ =

ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]]

( (ğ‘š âˆ’ 1)/ğ‘š)ğ‘˜âˆ’s[ğ‘Ÿ ] + ğ‘š

1 âˆ’ ((ğ‘š âˆ’ 1)/ğ‘š)ğ‘˜âˆ’s[ğ‘Ÿ ]

.

(cid:17)
The idea behind this choice of ğ¹ is that in the initial state where ğ‘Ÿ and all ğ¿[ğ‘–]s are 0, ğ¹ equals the up-
per bound we want (shown above), and after the execution, when s[ğ‘Ÿ ] = ğ‘˜, ğ¹ equals
ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]],
whose expectation is what we want to upper bound.

(cid:0)Ã

(cid:16)

(cid:1)

By the adversary rule ADV-U rule, we need to show that insert preserves ğ¹ , i.e., âŠ¢ {ğ¹ }insert ğ‘¥ :
T{ğ¿,â„,ğ‘Ÿ },1(ğœ){{ğ¹ }}0. We ï¬rst use the rule MLET-U. Since read â„[ğ‘¥] trivially preserves ğ¹ , we need to
show that the if-then-else preserves ğ¹ . We use CONSEQ-U to replace the pre-conditionâ€™s ğ¹ with
the equivalent (h(ğ‘ â‰  âˆ’1) = tti âŠ“ ğ¹ ) âŠ” (h(ğ‘ â‰  âˆ’1) = ï¬€i âŠ“ ğ¹ ). Using the rule MCASE-U, we then
need to prove that the â€œthenâ€ and â€œelseâ€ branches preserve ğ¹ .

Ã

The else branch is fairly straightforward. We need to show that

âŠ¢ {ğ¹ }let ğ‘ = read ğ‘Ÿ in ğ‘Ÿ := ğ‘ + 1 : T{ğ¿,â„,ğ‘Ÿ },1(ğœ){{ğ¹ }}0.

Using the rules MLET-U, READ-U and WRITE-U, we get

âŠ¢ {ğ¹ [s[ğ‘Ÿ â†¦â†’ (s[ğ‘Ÿ ] + 1)]/s]}let ğ‘ = read ğ‘Ÿ in ğ‘Ÿ := ğ‘ + 1 : T{ğ¿,â„,ğ‘Ÿ },1(ğœ){{ğ¹ }}0.
Hence, by CONSEQ-U, it suï¬ƒces to show that ğ¹ â‰¥ ğ¹ [s[ğ‘Ÿ â†¦â†’ (s[ğ‘Ÿ ] + 1)]/s] = ğ¹ [(s[ğ‘Ÿ ] + 1)/s[ğ‘Ÿ ]],
which follows immediately because ğ¹ is a decreasing function of s[ğ‘Ÿ ] (this uses the fact that each
s[ğ¿[ğ‘–]] is either 0 or 1).

On the then branch, we take into account the following property of the uniform distribution:

âŠ¢

((ğ‘š âˆ’ 1)/ğ‘š)

ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]]

+ 1

Unif(ğ‘š)

1 +

ğ‘– âˆˆ( [ğ‘š]\{v})s[ğ¿[ğ‘–]]

.

(1)

To prove this property, we ï¬rst note that the post-expectation is equal to

(cid:8)

(cid:0)Ã

(cid:9)(cid:9)

[v âˆˆ {ğ‘– | s[ğ¿[ğ‘–]] = 1}] Â·

ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]]

1 +

ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]]

.

(cid:1)

(cid:9)

(cid:8)(cid:8)
+ [v âˆˆ {ğ‘– | s[ğ¿[ğ‘–]] = 0}] Â·

Ã

By LIN-EXP and UNIF-EXP, the pre-expectation of this with respect to Unif(ğ‘š) is

(cid:0)

Ã

(1/ğ‘š)

ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]]

+ (1/ğ‘š)

ğ‘š âˆ’

ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]]

1 +

ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]]

,

(cid:0)Ã
ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]]

(cid:1)

which equals the pre-expectation of (1).

(cid:1) (cid:0)Ã

(cid:0)Ã

(cid:1)

(cid:0)

Ã

(cid:1) (cid:0)

Ã

We return to the proof of the then branch and reason backwards from the end of the branch.
After going backwards over â„[ğ‘¥] := ğ‘¦; ğ¿[ğ‘¦] := 1; let ğ‘ = read ğ‘Ÿ in ğ‘Ÿ := ğ‘ + 1, our pre-expectation
becomes ğ¹ [(s[ğ‘Ÿ â†¦â†’ s[ğ‘Ÿ ] + 1] [ğ¿[ğ‘¦] â†¦â†’ 1]) /s], which expands to

(cid:1)

(cid:1)

1 +

ğ‘– âˆˆ( [ğ‘š]\{ğ‘¦ }) s[ğ¿[ğ‘–]]

Â· ((ğ‘š âˆ’ 1)/ğ‘š)ğ‘˜âˆ’s[ğ‘Ÿ ]âˆ’1 + ğ‘š(1 âˆ’ ((ğ‘š âˆ’ 1)/ğ‘š)ğ‘˜âˆ’s[ğ‘Ÿ ]âˆ’1).

Using (1) and linearity to compute the pre-expectation of the sampling command, which is

Ã

(cid:16)

(cid:17)

(ğ‘š âˆ’ 1)/ğ‘š Â·

ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]]

+ 1

Â· ((ğ‘š âˆ’ 1)/ğ‘š)ğ‘˜âˆ’s[ğ‘Ÿ ]âˆ’1 + ğ‘š(1 âˆ’ ((ğ‘š âˆ’ 1)/ğ‘š)ğ‘˜âˆ’s[ğ‘Ÿ ]âˆ’1),

and by some rearranging of the terms, this is equal to

(cid:0)

(cid:0)Ã

ğ‘– âˆˆ[ğ‘š] s[ğ¿[ğ‘–]]

(cid:1)

(cid:1)
Â· ((ğ‘š âˆ’ 1)/ğ‘š)ğ‘˜âˆ’s[ğ‘Ÿ ] + ğ‘š(1 âˆ’ ((ğ‘š âˆ’ 1)/ğ‘š)ğ‘˜âˆ’s[ğ‘Ÿ ]),

which coincides with ğ¹ . This concludes the proof.

(cid:1)

(cid:0)Ã

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:17

5 HIGHER-ORDER PROBABILISTIC RELATIONAL LOGIC
In this section, we present a logic (HO-RPL) to reason about relations between two computations.
The syntax of the logic is shown below, where the propositions, assertions and assumptions have
the same meaning as in Section 4.1. Here we note that, although we keep the abstract syntax of
assertions, in this section we consider only their Boolean interpretation, where the connectives are
replaced by their usual Boolean counterparts and hğœ™i is equivalent to ğœ™. Researching a quantitative
interpretation, where assertions are interpreted as distances, is an interesting direction for future
work.

::= ğ‘…(ğ‘¡1, . . . , ğ‘¡ğ‘›) | âŠ¤ | âŠ¥ | ğœ™ âˆ§ ğœ“ | ğœ™ âˆ¨ ğœ“ | ğœ™ â‡’ ğœ“ | Â¬ğœ™ | âˆ€ğ‘¥ : ğœ.ğœ™ | âˆƒğ‘¥ : ğœ.ğœ™

ğœ™,ğœ“
ğ‘ƒ, ğ‘„ ::= ğ‘“ ( Ëœğ‘¡1, . . . , Ëœğ‘¡ğ‘›) | âŠ¤ | âŠ¥ | hğœ™i | ğ‘ƒ âŠ” ğ‘„ | ğ‘ƒ âŠ“ ğ‘„

Propositions
Assertions
Assumptions Î¨
Judgments

::= â€¢ | Î¨, ğœ“

Î | Î” | Î“ | Î¨ âŠ¢ ğœ™
Î | Î” | Î“ | Î¨ âŠ¢ ğ‘ƒ â‡› ğ‘„
Î“ | Î¨ âŠ¢ ğ‘¡1 : ğœ1 âˆ¼ ğ‘¡2 : ğœ2 {ğœ™ }
Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£1,ğ‘˜1 (ğœ1) âˆ¼ ğ‘¡2 : TÎ£2,ğ‘˜2 (ğœ2){{ğ‘„ }}ğ›¿

We have already explained the ï¬rst two judgments in previous sections. The third form of judg-
ment Î“ | Î¨ âŠ¢ ğ‘¡1 : ğœ1 âˆ¼ ğ‘¡2 : ğœ2 {ğœ™ } constitutes the non-monadic fragment of the logic and
comes from RHOL [Aguirre et al. 2017], a logic to prove relational properties of pure higher-order
programs directed by the syntax of the programs. In these judgments, Î“, r1, r2 âŠ¢ ğœ™ is a HOL for-
mula depending on two distinguished variables r1, r2 that represent the term on the left of the
judgment and the term on the right, respectively. The interpretation is given by the equivalence
Î“ | Î¨ âŠ¢ ğ‘¡1 : ğœ1 âˆ¼ ğ‘¡2 : ğœ2 {ğœ™ } â‡” Î“ | Î¨ âŠ¢ ğœ™ [ğ‘¡1/r1] [ğ‘¡2/r2], which follows from the relative
completeness theorem of RHOL. We present the rules for RHOL in the Appendix.

The fourth kind of judgments is new to our presentation, and is introduced to reason about
monadic computations. These have the syntax Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡1 : TÎ£,ğ‘˜ (ğœ1) âˆ¼ ğ‘¡2 : TÎ£,ğ‘˜ (ğœ2){{ğ‘„ }}ğ›¿
where ğ‘ƒ is a Boolean-valued assertion (called the pre-condition) well-formed in the context Î“, s1 :
ğ‘€, s2 : ğ‘€, and ğ‘„ is another Boolean-valued assertion (called the post-condition) well-formed in
the context Î“, s1 : ğ‘€, s2 : ğ‘€, v1 : ğœ1, v2 : ğœ2. Here, the variables s1, s2 refer to (resp. left or right-side)
memories, and v1, v2 refer to (resp. left or right-side) result values. Here ğ›¿ is a quantitative bound
taken in an ordered monoid; in the simplest case, the monoid consists of a single element 0. For
the particular interpretation presented in this section, we take the monoid of non-negative reals
with addition. Following the convention of RHOL, we assume that the free variables of ğ‘¡1 and ğ‘¡2
are disjoint.

The semantics of judgments is based on the notion of statistical distance. For a general ğ‘„, the
meaning of the judgment depends on the lifting deï¬ned in Example 6.6. Here we give an intuition
for the case where ğ‘„ is of the form s1 = s2 âŠ“ v1 = v2, suï¬ƒcient for our examples. If we can derive
Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡1 : TÎ£,ğ‘˜ (ğœ) âˆ¼ ğ‘¡2 : TÎ£,ğ‘˜ (ğœ){{s1 = s2 âŠ“ v1 = v2}}ğ›¿
then for every instantiation of Î“ satisfying Î¨, and every pair of initial memories ğ‘š1, ğ‘š2 âˆˆ ğ‘€, such
that ğ‘š1, ğ‘š2 âˆˆ ğ‘ƒ, the statistical distance between the output distributions ğ‘¡1 (ğ‘š1) and ğ‘¡2 (ğ‘š2) is at
most ğ›¿, i.e., for every event ğ‘† the absolute diï¬€erence between the probabilities of ğ‘† in ğ‘¡1(ğ‘š1) and
ğ‘¡2 (ğ‘š2) is at most ğ›¿. In particular, when ğ‘¡2 is a renaming of ğ‘¡1, ğ›¿ = 0, and ğ‘ƒ and ğ‘„ deï¬ne partial
equivalences on memories, the judgment enforces a form of generalized non-interference.

Monadic and structural rules. Figure 4 presents selected monadic and structural rules. Follow-
ing a pattern that is standard for relational logics, we have 2-sided rules, such as [UNIT âˆ’ R],
[MLET âˆ’ R], [READ âˆ’ R], [WRITE âˆ’ R] and [MCASE âˆ’ R], where the two expressions have the

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:18

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

same top-level structure, and 1-sided rules, such as [L âˆ’ UNIT âˆ’ R] and [L âˆ’ MLET âˆ’ R], which
exclusively consider the top-level construct of one expression. These generalize their unary coun-
terparts. In particular, the rule [MCASE âˆ’ R] has an extra assumption ensuring that the two com-
putations go to the same branch, so we only need to prove a relation between the then branches
and a relation between the else branches. A 1-sided rule without this assumption also exists, al-
lowing to consider the 4 possible pairs of branches, but we do not show it here.

Rules for sampling. Our logic also features rules for reasoning about sampling. In contrast to the
other rules, these are only valid to the particular interpretation based on statistical distance that
we present here. We show one rule below:

ğµ1 âŠ† ğµ2 ï¬nite
Î“ | Î¨ âŠ¢ {ğ‘ƒ }Unif (ğµ1) : Tâˆ…,0 (ğµ1) âˆ¼ Unif (ğµ2) : Tâˆ…,0 (ğµ2){{hv1 = v2i âŠ“ ğ‘ƒ }} |ğµ1 |/ |ğµ2 |

SAMPLE-R

The rule is used to compare uniform samplings from two ï¬nite sets. There exists an alternative
rule where ğ›¿ = 0, at the cost of weakening the postcondition; this rule is shown in the appendix.

Î“ | Î¨ âŠ¢ ğ‘¡1 : ğœ1 âˆ¼ ğ‘¡2 : ğœ2 | ğœ™

Î“, s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğ‘ƒ

Î“ | Î¨ âŠ¢ {ğ‘ƒ }unit(ğ‘¡1) : Tâˆ…,0 (ğœ1) âˆ¼ unit(ğ‘¡2) : Tâˆ…,0 (ğœ2){{hğœ™i âŠ“ ğ‘ƒ)}}0
Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡1 : TÎ£1,ğ‘˜1 (ğœ1) âˆ¼ ğ‘¡2 : TÎ£2,ğ‘˜2 (ğœ2){{ğ‘„ }}ğ›¿

UNIT-R

ğ‘¥1, ğ‘¥2 âˆ‰ ğ‘…

Î“, ğ‘¥1 : ğœ1, ğ‘¥2 : ğœ2 | Î¨ âŠ¢ {ğ‘„ [ğ‘¥1/v1] [ğ‘¥2/v2]}ğ‘¢1 : TÎ£â€²
Î“ | Î¨ âŠ¢ {ğ‘ƒ }let ğ‘¥1 = ğ‘¡1 in ğ‘¢1 : TÎ£1âˆªÎ£â€²

(ğœ1) âˆ¼ ğ‘¢2 : TÎ£â€²
(ğœ1) âˆ¼ let ğ‘¥2 = ğ‘¡2 in ğ‘¢2 : TÎ£2âˆªÎ£â€²

2,ğ‘˜â€²
2

1,ğ‘˜â€²
1

1,ğ‘˜1+ğ‘˜â€²
1

(ğœ2){{ğ‘…}}ğ›¿â€²

2,ğ‘˜2+ğ‘˜â€²
2

(ğœ2){{ğ‘…}}ğ›¿+ğ›¿â€²

MLET-R

Î; Î“ | Î¨ âŠ¢ ğ‘1 : Loc{ğœ“ }

Î; Î“ | Î¨ âŠ¢ ğ‘2 : Loc{ğœ“ }

Î“ | Î¨ âŠ¢ {ğ‘ƒ [s1 [ğ‘1]/v1] [s2 [ğ‘2]/v2]}read ğ‘1 : T{ğ‘1 },0 (V) âˆ¼ read ğ‘2 : T{ğ‘2 },0 (V){{ğ‘ƒ }}0

READ-R

Î; Î“ âŠ¢ ğ‘1 : Loc

Î; Î“ âŠ¢ ğ‘¡1 : V

Î; Î“ âŠ¢ ğ‘2 : Loc

Î; Î“ âŠ¢ ğ‘¡2 : V

Î“ | Î¨ âŠ¢ {ğ‘ƒ [s1 [ğ‘1 â†¦â†’ ğ‘¡1]/s1] [s1 [ğ‘2 â†¦â†’ ğ‘¡2]/s1]}ğ‘1 := ğ‘¡1 : T{ğ‘1 },0 (U) âˆ¼ ğ‘2 := ğ‘¡2 : T{ğ‘2 },0 (U){{ğ‘ƒ }}0
Î“ | Î¨ âˆ§ ğ‘1 = tt âŠ¢ {ğ‘ƒ1}ğ‘¡1 : TÎ£1,ğ‘˜1 (ğœ1) âˆ¼ ğ‘¡2 : TÎ£2,ğ‘˜2 (ğœ2){{ğ‘„ }}ğ›¿
Î“ | Î¨ âŠ¢ ğ‘1 : B âˆ¼ ğ‘1 : B {ğ‘1 = ğ‘2}

Î“ | Î¨ âˆ§ ğ‘1 = ï¬€ âŠ¢ {ğ‘ƒ2}ğ‘¢1 : TÎ£1,ğ‘˜1 (ğœ1) âˆ¼ ğ‘¢2 : TÎ£2,ğ‘˜2 (ğœ2){{ğ‘„ }}ğ›¿
ğ‘ƒ , (hğ‘1 = tti âŠ“ ğ‘ƒ1i) âŠ” (hğ‘1 = ï¬€i âŠ“ ğ‘ƒ2)
Î“ | Î¨ âŠ¢ {ğ‘ƒ }if ğ‘ then ğ‘¡1 else ğ‘¢1 : TÎ£1,ğ‘˜1 (ğœ1) âˆ¼ if ğ‘ then ğ‘¡2 else ğ‘¢2 : TÎ£2,ğ‘˜2 (ğœ2){{ğ‘„ }}ğ›¿

WRITE-R

MCASE-R

Î“ | Î¨ âŠ¢ ğ‘¡1 : ğœ1{ğœ™ }

Î“, s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğ‘ƒ

Î“ | Î¨ âŠ¢ {ğ‘ƒ }unit(ğ‘¡1) : Tâˆ…,0 (ğœ1) âˆ¼ skip : Tâˆ…,0 (U){{hğœ™i âŠ“ ğ‘ƒ }}0

L-UNIT-R

Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡1 : TÎ£1,ğ‘˜1 (ğœ1) âˆ¼ skip : Tâˆ…,0 (U){{ğ‘„ }}ğ›¿

Î“, ğ‘¥1 : ğœ1, ğ‘¥2 : U | Î¨ âŠ¢ {ğ‘„ [ğ‘¥1/v1] [ğ‘¥2/v2]}ğ‘¢1 : TÎ£â€²

Î“ | Î¨ âŠ¢ {ğ‘ƒ }let ğ‘¥1 = ğ‘¡1 in ğ‘¢1 : TÎ£1âˆªÎ£â€²

1,ğ‘˜â€²
1
1,ğ‘˜1+ğ‘˜â€²
1

(ğœ1) âˆ¼ ğ‘¢2 : TÎ£2,ğ‘˜2 (ğœ2){{ğ‘…}}ğ›¿
(ğœ1) âˆ¼ ğ‘¢2 : TÎ£2,ğ‘˜2 (ğœ2){{ğ‘…}}ğ›¿+ğ›¿â€²

ğ‘¥1, ğ‘¥2 âˆ‰ ğ‘…

L-MLET-R

Fig. 4. Relational logic: monadic rules

Adversary rule. The adversary rule for the relational setting is similar in spirit to the adversary
rule for the unary setting. However, some mild adjustments are needed. First, we need to modify
the notion of safety for a region Î£. In the unary case we only required that writing to Î£ preserves
the invariant. In the relational case, we also need to require that ğœ™ is also â€œsafe for reading in Î£â€,
meaning that an adversary reading from two diï¬€erent memories related by ğœ™ at the same location
in Î£ sees the same value. This prevents the two executions from diverging due to a read operation:

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:19

Definition 1. Let ğœ™ be a predicate and Î£ âŠ† Loc. We say that ğœ™ âˆˆ RSafe(Î£) iï¬€

âˆ€ğ‘š1, ğ‘š2, âˆ€ğ‘™ âˆˆ Î£.âˆ€ğ‘£ âˆˆ V.ğœ™ (ğ‘š1, ğ‘š2) â‡’ ğœ™ (ğ‘š1 [ğ‘™ â†¦â†’ ğ‘£], ğ‘š2 [ğ‘™ â†¦â†’ ğ‘£]) âˆ§ ğ‘š1 [ğ‘™] = ğ‘š2 [ğ‘™]

The adversary rule also allows us to show that the outputs must be extensionally equal, which
corresponds to the predicate Eqğœ deï¬ned below. The reason to use this as opposed to equality in
the model is that the logical relation we use in the soundness proof corresponds to extensional
equality for non-monadic types:

Eqğ‘ (ğ‘¥1, ğ‘¥2) , ğ‘¥1 = ğ‘¥2

Eqğœ1â†’ğœ2
Eqğœ1Ã—ğœ2
The adversary rule can now be stated below:

(ğ‘¥1, ğ‘¥2) , âˆ€ğ‘¦1, ğ‘¦2 âˆˆ ğœ1.Eqğœ1
(ğ‘¥1, ğ‘¥2) , Eqğœ1

(ğ‘¦1, ğ‘¦2) â‡’ Eqğœ1

(ğ‘¥1 ğ‘¦1, ğ‘¥2 ğ‘¦2)
(ğœ‹2 (ğ‘¥1), ğœ‹2 (ğ‘¥2))

(ğœ‹1(ğ‘¥1), ğœ‹1(ğ‘¥2)) âˆ§ Eqğœ2

s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğœ™

(A : âˆ€ğ›¼.(ğœ â†’ Tğ›¼,1 (ğœ)) â†’ TÎ£âˆªğ›¼,ğ‘˜ (ğœ â€²)) âˆˆ Î”

ğœ™ âˆˆ RSafe(Î£)

ğ‘¥1 âˆ‰ ğ¹ğ‘‰ (ğ‘¡2), ğ‘¥2 âˆ‰ ğ¹ğ‘‰ (ğ‘¡1)

ğœ, ğœ, ğœ â€² non-monadic types

ğ‘¥1 : ğœ, ğ‘¥2 : ğœ | Eqğœ (ğ‘¥1, ğ‘¥2) âŠ¢ {ğœ™ }ğ‘¡1 : TÎ£â€²,1 (ğœ) âˆ¼ ğ‘¡2 : TÎ£â€²,1 (ğœ){{hEqğœ (v1, v2)i âŠ“ ğœ™ }}ğ›¿
Î” | Â· | Â· âŠ¢ {ğœ™ }A (ğœ†ğ‘¥1.ğ‘¡1) : TÎ£âˆªÎ£â€²,ğ‘˜ (ğœ â€²) âˆ¼ A (ğœ†ğ‘¥2.ğ‘¡2) : TÎ£âˆªÎ£â€²,ğ‘˜ (ğœ â€²){{hEqğœâ€² (v1, v2)i âŠ“ ğœ™ }}ğ‘˜ğ›¿

ADV-R

Informally, the premises of the rule state:
â€¢ ğœ™ is a safe for the memory region Î£;
â€¢ if their inputs are extensionally equal and their initial memories are related by ğœ™, then the

oracles produce equal outputs and ï¬nal memories related by ğœ™, with error ğ›¿;

â€¢ A is an arbitrary adversary that only writes to and reads from Î£ and that can call its argu-

ment up to ğ‘˜ times

From them, we conclude that executing the adversary with these oracles and initial memories
related by ğœ™ should yield equal values and output memories related by ğœ™, with error ğ‘˜ğ›¿.

Example: PRF/PRP Switching Lemma

We use our logic to show that the probability that an adversary can distinguish between a PRF and
a PRF on bitstrings of ï¬xed length ğ‘™ is upper bounded by ğ‘˜ (ğ‘˜+1)
, where ğ‘˜ is the maximal number
2ğ‘™ +1
of queries allowed to the adversary. As before, we consider a mild extension of the logic where
the error bound can depend on the oracle counter. For readability, we will generally omit from our
judgments the eï¬€ect, adversary and variable contexts, and drop the cost grading from the monadic
types, and omit all reasoning about the size of the domain of ğ¿. Our goal is to show:

âŠ¢ {s1 = s2} A PRF : TÎ£âˆª{ğ¿ },ğ‘˜ ({0, 1}) âˆ¼ A PRP : TÎ£âˆª{ğ¿ },ğ‘˜ ({0, 1}) {{v1 = v2}}ğ‘˜ (ğ‘˜+1)/2ğ‘™ +1

By applying the rule [ADV âˆ’ R] on the strengthened judgment, we are left to prove:

ğ‘¥1 = ğ‘¥2 âŠ¢ {s1 = s2}ğ‘’PRF : T{ğ¿ } ({0, 1}) âˆ¼ ğ‘’PRP : T{ğ¿ }({0, 1}){{s1 = s2 âŠ“ v1 = v2}}ğ‘–/2ğ‘™
where ğ‘’PRF and ğ‘’PRP denote the bodies of the PRF and PRP oracles. We then apply the [MCASE âˆ’ R]
rule. In the empty else branch, we need to prove:
ğ‘¥1 = ğ‘¥2 âŠ¢ {s1 = s2}(read ğ¿) [ğ‘¥1] : Tğ¿ ({0, 1}ğ‘™ ) âˆ¼ (read ğ¿) [ğ‘¥2] : Tğ¿ ({0, 1}ğ‘™ ){{s1 = s2 âŠ“ v1 = v2}}ğ‘–/2ğ‘™
which is a simple application of the [READ âˆ’ R] rule. In the then branch, we ï¬rst apply the
[WRITE âˆ’ R] rule, and then we are left to prove:
âŠ¢ {s1 = s2}Unif (ğ‘‹1) : T({0, 1}ğ‘™ ) âˆ¼ Unif(ğ‘‹2) : Tğ¿,1({0, 1}ğ‘™ ){{s1 [ğ‘¥1 â†¦â†’ v1] = s2 [ğ‘¥2 â†¦â†’ v2]âŠ“v1 = v2}}ğ‘–/2ğ‘™
where ğ‘‹1 , {0, 1}ğ‘™ and ğ‘‹2 , {0, 1}ğ‘™ \ im(v[ğ¿]). By the rule of consequence, this follows from

âŠ¢ {s1 = s2}Unif(ğ‘‹1) : T({0, 1}ğ‘™ ) âˆ¼ Unif(ğ‘‹2) : Tğ¿,1 ({0, 1}ğ‘™ ){{s1 = s2 âŠ“ v1 = v2}}ğ‘–/2ğ‘™

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:20

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

which we prove using the [SAMPLE âˆ’ R] rule.

6 SEMANTICS
Now we present the formal semantics for our system. We begin with some background, and follow
with the semantics of the language and the logics, and their soundness theorems.

6.1 The Category of Quasi-Borel spaces and Probability Monad
We will assume knowledge of some concepts of category theory, such as bi-Cartesian closed cat-
egories (bi-CCC) and strong monads, see e.g. [MacLane 1971] for details. In any biCCC C in this
paper, we ï¬x a terminal object (1, !ğ‘‹ âˆˆ C(ğ‘‹, 1)), and for each pair ğ‘‹, ğ‘Œ âˆˆ C of objects, we ï¬x a
binary product (ğ‘‹ Ã— ğ‘Œ , ğœ‹1, ğœ‹2, hâˆ’, âˆ’i), a binary coproduct (ğ‘‹ + ğ‘Œ , ğœ„1, ğœ„2, [âˆ’, âˆ’]) and an exponential
object (ğ‘‹ â‡’ ğ‘Œ , ev, ğœ†(âˆ’)). We also equip C with the symmetric monoidal structure (1, (Ã—), ğ‘™, ğ‘Ÿ , ğ‘, ğ‘ )
induced by the ï¬xed terminal object and binary products.

We will use the category QBS of quasi-Borel spaces [Heunen et al. 2017; Åšcibior et al. 2017] for
modeling higher-order probabilistic programs introduced in Section 3. The category QBS is a well-
pointed bi-CCC; in fact it has small products and coproducts. For modeling probabilistic choice,
we employ the strong monad (P, ğœ‚ P, ğœ‡ P, ğœƒ P) for probability measures over QBSs [Heunen et al.
2017]. For a set ğ´ and a QBS ğ‘‹ , by (ğ´ Â· ğ‘‹, {ğœ„ğ´,ğ‘‹
: ğ‘‹ â†’ ğ´ Â· ğ‘‹ }ğ‘ âˆˆğ´, [âˆ’]ğ‘ âˆˆğ´) we mean the coproduct
of ğ´-many copies of ğ‘‹ .

ğ‘

We write | âˆ’ | : QBS â†’ Set for the forgetful functor extracting the carrier set of QBS. It preserves
ï¬nite (actually small) products. To ease calculation, we assume |1| = 1 and |ğ‘‹ Ã— ğ‘Œ | = |ğ‘‹ | Ã— |ğ‘Œ |
(rather than isomorphic). We also assume that the exponential of QBS is deï¬ned so that |ğ‘‹ â‡’
ğ‘Œ | = QBS(ğ‘‹, ğ‘Œ ). Finally, we write [0, âˆ]QBS for the QBS of non-negative extended reals.

6.2 Probabilistic State Monad

Starting from this base, which was already presented in [Heunen et al. 2017] we use the state
monad transformer to construct a strong monad given by a functor.

First, we introduce the QBS for memory states. Fix a QBS ğ‘‰ corresponding to type V. The
QBS for memory states is a product (ğ‘€, {ğœ‹ğ‘ : ğ‘€ â†’ ğ‘‰ }ğ‘ âˆˆLoc) of Loc-many copies of ğ‘‰ . We next
introduce a memory update function. Given a QBS morphism ğ‘“ : ğ‘‹ â†’ ğ‘‰ computing a value from
an environment, we deï¬ne the memory update ğ‘¢ğ‘ (ğ‘“ ) : ğ‘‹ Ã— ğ‘€ â†’ ğ‘€ (at location ğ‘ âˆˆ Loc) to be
the unique morphism satisfying ğœ‹ğ‘ â—¦ ğ‘¢ğ‘ (ğ‘“ ) = ğ‘“ â—¦ ğœ‹1 and ğœ‹ğ‘â€² â—¦ ğ‘¢ğ‘ (ğ‘“ ) = ğœ‹ğ‘â€² â—¦ ğœ‹2 for any ğ‘â€² â‰  ğ‘. We
then deï¬ne the probabilistic state monad by PS , ğ‘€ â‡’ P (âˆ’ Ã— ğ‘€). The unit ğœ‚ P S
: ğ‘‹ â†’ PSğ‘‹ ,
multiplication ğœ‡ P S
ğ‘‹,ğ‘Œ : ğ‘‹ Ã— PS(ğ‘Œ ) â†’ PS(ğ‘‹ Ã— ğ‘Œ ) of this
monad are deï¬ned as:

: PS(PSğ‘‹ ) â†’ PSğ‘‹ and strength ğœƒ P S

ğ‘‹

ğ‘‹

ğœ‚ P S , ğœ†(ğœ‚ P

ğ‘‹ Ã—ğ‘€ )

ğœ‡ P S , ğ‘€ â‡’ (ğœ‡ P â—¦ P (ğ‘’ğ‘£))

ğœƒ P S
ğ‘‹,ğ‘Œ

, ğœ†(Pğ›¼ âˆ’1 â—¦ ğœƒ P â—¦ (ğ‘‹ Ã— ev) â—¦ ğ›¼).

6.3 Semantics of the language
As demonstrated by Moggi, the computational metalanguage (the simply typed lambda calculus
with monadic types) is naturally interpreted in any CCC with a strong monad. The semantics of
the language in Section 3 follows the same pattern. To accommodate probabilities we take the
category QBS with the probabilistic state monad PS.

The semantics of types is deï¬ned as objects in QBS, assuming we have an object Jğ‘ğ‘– K for every
base type ğ‘ğ‘– âˆˆ ğµ. Note that the indices of the monad and the quantiï¬cation over regions are erased

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:21

JÎ“ âŠ¢ unit(ğ‘¡) : TÎ£,ğ‘˜ (ğœ)K , ğœ‚ P S â—¦ JÎ“ âŠ¢ ğ‘¡ : ğœK

JÎ“ âŠ¢ let ğ‘¥ = ğ‘¡ in ğ‘¢ : TÎ£,ğ‘˜ (ğœ)K , JÎ“, ğ‘¥ : ğœ âŠ¢ ğ‘¢ : TÎ£,ğ‘˜ (ğœ)K#P S â—¦ ğ‘šÎ“,ğ‘¥:ğœ â—¦ ğœƒ P S â—¦ hğ‘–ğ‘‘JÎ“K, JÎ“ âŠ¢ ğ‘¡ : TÎ£,ğ‘˜ (ğœ)Ki

JÎ“ âŠ¢ read ğ‘ : TÎ£,ğ‘˜ (V)K , ğœ†(ğœ‚ P â—¦ hğœ‹ğ‘, ğ‘–ğ‘‘i â—¦ ğœ‹2)
JÎ“ âŠ¢ ğ‘ := ğ‘¡ : TÎ£,ğ‘˜ (U)K , ğœ†(ğœ‚ P â—¦ h!, idi â—¦ ğ‘¢ğ‘ (JÎ“ âŠ¢ ğ‘¡ : VK))

JÎ“ âŠ¢ sample(ğœˆ (ğ‘¡1, . . . , ğ‘¡ğ‘˜ )) : TÎ£,ğ‘˜ (ğœğœˆ )K , ğœ†(ğœ— P â—¦ hJğœˆK â—¦ hJÎ“ âŠ¢ ğ‘¡1 : ğœğœˆ,1K, . . . , JÎ“ âŠ¢ ğ‘¡ğ‘˜ : ğœğœˆ, |ğœˆ |Ki â—¦ ğœ‹1, ğœ‹2i)
JÎ“ âŠ¢ mfold ğ‘› ğ‘¡1 ğ‘¡2 : TÎ£âˆªÎ£â€²,ğ‘˜+ğ¾ Â·ğ‘˜â€² (ğœ)K ,

foldğ¾ Â·1,JTÎ£,ğ‘˜ (ğœ)K â—¦ hJÎ“ âŠ¢ ğ‘› : N[ğ¾]K, JÎ“ âŠ¢ ğ‘¡1 : TÎ£,ğ‘˜ (ğœ)K, KlJÎ“K,JTÎ£â€²,ğ‘˜â€² (ğœ)K â—¦ JÎ“ âŠ¢ ğ‘¡2 : ğœ â†’ TÎ£â€²,ğ‘˜â€² (ğœ)Ki

Fig. 5. Semantics of the language

at the semantic level (below, for a natural number ğ¾, Â¯ğ¾ denotes the set {0, Â· Â· Â· , ğ¾ }):
JN[ğ¾]K , Â¯ğ¾ Â· 1
Jğœ Ã— ğœK , JğœK Ã— JğœK

JBK , {âŠ¥, âŠ¤} Â· 1
Jğœ â†’ ğœK , JğœK â‡’ JğœK

JVK , ğ‘‰ JMK , ğ‘€

JTÎ£,ğ‘˜ (ğœ)K , PS(JğœK)

JUK , 1

Jâˆ€ğ›¼.ğœK , JğœK

This categorical semantics erases the eï¬€ect annotations Î£, ğ‘˜ of the monadic type TÎ£,ğ‘˜ (ğœ) and
the universal quantiï¬cation âˆ€ğ›¼.ğœ over regions, which only play a role in proving soundness of the
adversary rules. Adversary variables are placeholders for closed terms, and do not play any special
role in the semantics. We therefore give a semantics of the language without contexts Î and Î”.

We interpret the subtyping relation Î âŠ¢ ğœ (cid:22) ğœ â€² as a coercion morphism ğ‘ğœ,ğœâ€² : JğœK â†’ Jğœ â€²K. Most
of its deï¬nition is routine, except for the case of natural number type: for ğ¾ â‰¤ ğ¾ â€², ğ‘N[ğ¾ ],N[ğ¾ â€² ] is
deï¬ned to be the evident morphism Â¯ğ¾ Â· 1 â†’ Â¯ğ¾ â€² Â· 1.

Semantics of a context Î“ is given by the Cartesian product of the interpretation of types in Î“. For
convenience, we ï¬x a product (JÎ“K, {ğœ‹ Î“
ğ‘¥ : JÎ“K â†’ JÎ“(ğ‘¥)K}ğ‘¥ âˆˆdom(Î“) ) for each context Î“. For a context
Î“, ğ‘¥1 : ğœ1, Â· Â· Â· , ğ‘¥ğ‘› : ğœğ‘›, by ğ‘šÎ“,ğ‘¥1:ğœ1,Â·Â·Â· ,ğ‘¥ğ‘›:ğœğ‘› : JÎ“KÃ— (Jğœ1KÃ—Â· Â· Â·Ã—Jğœğ‘›K) â†’ JÎ“, ğ‘¥1 : ğœ1, Â· Â· Â· , ğ‘¥ğ‘› : ğœğ‘›K we mean
the evident isomorphism in QBS. Also, for a well-typed term Î“ âŠ¢ ğ‘¡ : ğœ and ğ‘¥ âˆ‰ dom Î“, we deï¬ne the
Î“âŠ¢ğ‘¡:ğœ
substitution morphism sub
ğ‘¥

: JÎ“K â†’ JÎ“, ğ‘¥ : ğœK to be the composite ğ‘šÎ“,ğ‘¥:ğœ â—¦ hğ‘–ğ‘‘JÎ“K, JÎ“ âŠ¢ ğ‘¡ : ğœKi.

Well-typed terms Î“ âŠ¢ ğ‘¡ : ğœ are interpreted as a morphism in QBS(JÎ“K, JğœK). The interpretation of
monadic types can be found in Figure 5; the interpretation of the non-monadic fragment is standard
and deferred to Appendix E.1. In the Figure, (âˆ’)#P S denotes the Kleisli lifting of PS; Klğ‘‹,ğ‘Œ : (ğ‘‹ â‡’
PSğ‘Œ ) â†’ (PSğ‘‹ â‡’ PSğ‘Œ ) denotes the internal Kleisli lifting; ğœ— P
ğ‘‹,ğ‘Œ : P (ğ‘‹ ) Ã— ğ‘Œ â†’ P (ğ‘‹ Ã— ğ‘Œ ) is
the co-strength, a transformation analogous to the strength but with swapped arguments; and
foldğ¾ Â·1,ğ‘‹ : ğ¾ Â· 1 Ã— ğ‘‹ Ã— (ğ‘‹ â‡’ ğ‘‹ ) â†’ ğ‘‹ denotes the iterator over the natural numbers up to ğ¾. We
assume that every distribution ğœˆ with arity ğœğœˆ,1 Ã— Â· Â· Â· Ã— ğœğœˆ, |ğœˆ | â†’ ğœğœˆ has an interpretation JğœˆK of the
proper type Jğœğœˆ,1K Ã— Â· Â· Â· Ã— Jğœğœˆ, |ğœˆ |K â†’ PJğœğœˆK. This semantics is sound in the following sense:

Theorem 6.1. Let Î | Î” | Î“ âŠ¢ ğ‘¡ : ğœ be a well-typed term and âˆ… âŠ¢ ğ‘¡ğ‘– : Î”(Ağ‘– ) be closed terms given

for each Ağ‘– âˆˆ dom(Î”). Then JÎ“ âŠ¢ ğ‘¡ [ğ‘¡ğ‘– /Ağ‘– ]ğ›¼ âˆˆdom Î” : ğœK âˆˆ QBS(JÎ“K, JğœK).

6.4 Heyting-Valued Predicates over QBSs
Formulas and assertions are interpreted in the same way as predicates over QBSs. Recall that a
complete Heyting algebra is a complete lattice â„¦ = (Î©, âŠ‘) (whose meet and join are denoted by âŠ“
and âŠ” respectively) together with a pseudo-complement operator â‡›.

Definition 2. Let â„¦ = (Î©, âŠ‘) be a complete Heyting algebra. An â„¦-valued predicate on a QBS ğ‘‹
, Set(|ğ‘‹ |, Î©) to mean the set of â„¦-valued predicates on

is a function of type |ğ‘‹ | â†’ Î©. Deï¬ne UPâ„¦
ğ‘‹
ğ‘‹ .

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:22

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

By the pointwise order, UPâ„¦

mean the Sierpinski space complete Heyting algebra. For ğ‘¥ âˆˆ |ğ‘‹ | and ğ‘ƒ âˆˆ UP2
satisï¬es ğ‘ƒ, denoted by ğ‘¥ |= ğ‘ƒ, if and only if ğ‘ƒ (ğ‘¥) = âŠ¤.

ğ‘‹ is again a complete Heyting algebra. We deï¬ne 2 , {âŠ¥ âŠ‘ âŠ¤} to
ğ‘‹ , we say that ğ‘¥

Every 2-valued predicate can be converted into a â„¦-valued predicate. Deï¬ne ğ¼ : UP2

ğ‘‹ â†’ UPâ„¦
ğ‘‹
by ğ¼ (ğ‘ƒ) (ğ‘¥) = âŠ¤â„¦ if ğ‘ƒ (ğ‘¥) = âŠ¤2 and ğ¼ (ğ‘ƒ) (ğ‘¥) = âŠ¥â„¦ if ğ‘ƒ (ğ‘¥) = âŠ¥2. This is a complete Heyting algebra
homomorphism, that is, a function preserving all joins, all meets and pseudo-complements.

We introduce a generalized inverse image operation for â„¦-valued predicates. For a QBS-morphism
ğ‘Œ by ğ‘“ âˆ—ğ‘ƒ = ğ‘ƒ â—¦ |ğ‘“ |. This is also a complete Heyting algebra
ğ‘‹ and
ğ‘‹ . When â„¦ = 2, ğ‘“ : ğ‘ƒ Â¤â†’ ğ‘„ is

ğ‘“ : ğ‘Œ â†’ ğ‘‹ , deï¬ne ğ‘“ âˆ— : UPâ„¦
homomorphism. We also introduce a notation: for a QBS morphism ğ‘“ : ğ‘‹ â†’ ğ‘Œ and ğ‘ƒ âˆˆ UPâ„¦
ğ‘„ âˆˆ UPâ„¦
equivalent to stating that for any ğ›¾, ğ›¾ |= ğ‘ƒ implies |ğ‘“ |(ğ›¾) |= ğ‘„.

ğ‘Œ , we write ğ‘“ : ğ‘ƒ Â¤â†’ ğ‘„ to mean the inequality ğ‘ƒ âŠ‘ ğ‘“ âˆ—ğ‘„ in UPâ„¦

ğ‘‹ â†’ UPâ„¦

We also deï¬ne the partial application of an â„¦-valued predicate with an environment. Let Î“, ğ‘¥1 :

ğœ1, Â· Â· Â· , ğ‘¥ğ‘› : ğœğ‘› be a context. For a predicate ğ‘ƒ âˆˆ UPâ„¦
we mean the predicate ğ‘ƒğ›¾ (ğ‘) = ğ‘ƒ â—¦ |ğ‘šÎ“,ğ‘¥1:ğœ1,Â·Â·Â· ,ğ‘¥ğ‘›:ğœğ‘› |(ğ›¾, ğ‘). For ğ‘ƒ âˆˆ UPâ„¦
ğ‘ƒ Â¤Ã— ğ‘„ = ğœ‹ âˆ—

1 ğ‘ƒ âŠ“ ğœ‹ âˆ—

2ğ‘„.

JÎ“,ğ‘¥1:ğœ1,Â·Â·Â· ,ğ‘¥ğ‘› :ğœğ‘› K andğ›¾ âˆˆ |JÎ“K|, by ğ‘ƒğ›¾ âˆˆ UPâ„¦

ğ‘‹ and ğ‘„ âˆˆ UPâ„¦

Jğœ1KÃ—Â·Â·Â·Ã—Jğœğ‘› K
ğ‘Œ , we deï¬ne

Note that we have chosen predicates to be morphisms in Set, rather than morphisms in QBS.
This allows us to avoid reasoning about measurability when deï¬ning predicates and writing spec-
iï¬cations, while still having a model that works as intended when the predicates are measurable.

6.5 Strong Graded Liftings of the Probability Measure Monad
We introduce a concept called strong graded lifting of strong monads. The following deï¬nition is
a specialization of the one in [Katsumata 2014] to â„¦-valued predicates.

Definition 3 (Heyting-valued strong graded lifting of strong monad). Let (ğ¸, â‰¤, 0, +)
be a partially ordered monoid. An â„¦-valued strong ğ¸-graded lifting of P is a family of functions
Â¤Pğ‘‹ : ğ¸ â†’ (UPâ„¦

Pğ‘‹ ), implicitly indexed by ğ‘‹ âˆˆ QBS, satisfying:

ğ‘‹ â‡’ UPâ„¦

ğ‘’ â‰¤ ğ‘’ â€² =â‡’ Â¤P(ğ‘’) (ğ‘ƒ) âŠ‘ Â¤P(ğ‘’ â€²) (ğ‘ƒ)

ğ‘‹ : Â¤P(ğ‘’) ( Â¤P(ğ‘’ â€²) (ğ‘ƒ)) Â¤â†’ Â¤P(ğ‘’ + ğ‘’ â€²) (ğ‘ƒ)
ğœ‡ P

ğ‘‹ : ğ‘ƒ Â¤â†’ Â¤P(0) (ğ‘ƒ)
ğœ‚ P
ğ‘‹ : ğ‘ƒ Â¤Ã— Â¤P(ğ‘’) (ğ‘„) Â¤â†’ Â¤P(ğ‘’) (ğ‘ƒ Â¤Ã— ğ‘„).
ğœƒ P

The following is an informal explanation of liftings, ignoring for the moment the gradings. The
second and third conditions specify how the unit and multiplication of the lifting interact with the
unit and multiplication of the base monad: for a predicate ğ‘ƒ over ğ‘‹ and ğ‘¥ âˆˆ ğ‘ƒ, then ğœ‚ (ğ‘¥) âˆˆ Â¤P(0) (ğ‘ƒ),
and if ğ‘¥ âˆˆ Â¤P(ğ‘’) ( Â¤P(ğ‘’ â€²) (ğ‘ƒ)), then ğœ‡(ğ‘¥) âˆˆ Â¤P(ğ‘’ + ğ‘’ â€²) (ğ‘„). The fourth condition speciï¬es a similar
interaction with the strength. These properties are used in proving the soundness of the rules of
our logics. At the level of liftings, gradings can be seen as some additional speciï¬cation, or as
adding quantitative information to the speciï¬cation. For instance, in HO-UBL use the grading on
a lifting to specify the probability with which a computation may fail to satisfy the speciï¬cation.
This is the intuition behind the ï¬rst condition in the deï¬nition: it allows weakenings of the grading
of a lifted predicate, i.e., if ğ‘’ â‰¤ ğ‘’ â€² then Â¤P(ğ‘’) (ğ‘„) â‡’ Â¤P(ğ‘’ â€²) (ğ‘„). We now present some examples of
liftings that we will use in our soundness proofs:

Example 6.2 (Lifting for union bounds). Inspired from the lifting for the union bound introduced
in [Sato et al. 2019, Section 9.1], we give a 2-valued strong ( [0, âˆ], â‰¤, +, 0)-graded lifting Â¤P ub of P:

Â¤P ub
ğ‘‹ (ğ›¿) (ğ‘ƒ) (ğœˆ) = âŠ¤ â‡â‡’ âˆ€ğ‘“ âˆˆ QBS(ğ‘‹, {0, 1} Â· 1), ğ‘ƒ âŠ‘ |ğ‘“ | . Pr
ğ‘¥âˆ¼ğœˆ

[ğ‘“ (ğ‘¥) = 1] â‰¥ 1 âˆ’ ğ›¿.

This can be constructed by the graded âŠ¤âŠ¤-lifting [Katsumata 2014]. Morally, we want Â¤P ub
ğ‘‹ (ğ›¿) (ğ‘ƒ) (ğœˆ)
to hold if the probability of sampling a value from ğœ‡ that satisï¬es ğ‘ƒ is at least 1 âˆ’ ğ›¿. However, we
cannot compute this probability directly because ğ‘ƒ may not be measurable. Instead, we need to

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:23

quantify over all the measurable ğ‘“ above ğ‘ƒ. We can then show that if ğ‘ƒ is indeed measurable (i.e.
ğ‘ƒ = |ğ‘ƒ0| for some QBS-morphism ğ‘ƒ0), Prğ‘¥âˆ¼ğœˆ [ğ‘ƒ (ğ‘¥) = 0] â‰¤ ğ›¿ holds for every ğœˆ âˆˆ Â¤P ub(ğ›¿) (ğ‘ƒ). That is,
for measurable predicates, the lifting behaves as intended.

Example 6.3 (Lifting for expectations). We introduce a ( [0, âˆ], â‰¥)-valued strong ( [0, âˆ], â‰¤, +, 0)-
graded lifting Â¤P Exp of P. Note that the predicates take values in the Heyting algebra [0, âˆ] with
reversed order (i.e. ğ‘¥ âŠ‘ ğ‘¦ iï¬€ ğ‘¦ â‰¤ ğ‘¥), which will be used to reason about upper bounds. We deï¬ne:
Â¤P exp
ğ‘‹ (ğ›¿) (ğ‘ƒ) (ğœˆ) = sup{ğ‘†ğ›¿+ğ›¿â€² (ğ‘“ â™¯ğœˆ) | ğ‘“ : ğ‘‹ â†’ P [0, âˆ], sup{ğ‘†ğ›¿â€² (ğ‘“ (ğ‘–)) | ğ‘ƒ (ğ‘–)<ğ‘†ğ›¿â€² (ğ‘“ (ğ‘–))}<ğ‘†ğ›¿+ğ›¿â€² (ğ‘“ â™¯ğœˆ)}

where ğ‘†ğ›¿ (ğœ‡) = max(0, Eğ‘Ÿ âˆ¼ğœ‡ [ğ‘Ÿ ] âˆ’ ğ›¿).

This can be constructed by the graded âŠ¤âŠ¤-lifting [Katsumata 2014] since ğ›¿ â‰¤ ğ›¿ â€² =â‡’ ğ‘†ğ›¿ âŠ‘ ğ‘†ğ›¿â€².
Intuitively, the lifting Â¤P Exp gives an upper bound of expected value of ğ‘ƒ under a distribution ğœˆ with
margin of error ğ›¿. In the general case, where ğ‘ƒ is not measurable, we get instead an upper bound
on the expected value of any ğ‘“ : ğ‘‹ Â¤â†’[0, âˆ] measurable in QBS such that |ğ‘“ | â‰¤ ğ‘ƒ (i.e. ğ‘ƒ âŠ‘ |ğ‘“ |).
That, is we obtain Â¤P Exp

ğ‘‹ (ğ›¿) (ğ‘ƒ) (ğœˆ) âŠ‘ Eğ‘¥ âˆˆğœˆ [ğ‘“ (ğ‘¥)] âˆ’ ğ›¿.

6.6 Combining liftings and state transformer monads
The material from the previous section allows us to model predicates over the monad P, but we
need to extend it to model predicates over the probabilistic state monad PS that models computa-
tions in our language. The same approach of ï¬nding a lifting of PS does not work directly because
it would not allow us to include the speciï¬cation about states. Such a lifting would map a â„¦-valued
predicate over ğ‘‹ to a 2-valued predicate over PSğ‘‹ = ğ‘€ â‡’ P (ğ‘‹ Ã— ğ‘€), but this does not match
the shape of triples in our logics. We actually need to lift a pair of â„¦-valued predicates over ğ‘€ (the
precondition) and over ğ‘‹ Ã— ğ‘€ (the postcondition) into a 2-valued predicate over PSğ‘‹ .

P Sğ‘‹ ) by ğ‘“

ğ‘‹ Ã—ğ‘€ â‡’ UP2

|= Â¤P Â¤Sğ‘‹ (ğ‘’) (ğ‘ƒ, ğ‘„) â‡â‡’ ğ‘“

Therefore, we need to ï¬nd a diï¬€erent construction. Assume there exists a â„¦-valued strong (ğ¸, â‰¤
, 0, +)-graded lifting Â¤P of P. For each QBS ğ‘‹ , we deï¬ne a function Â¤P Â¤Sğ‘‹ (âˆ’) (âˆ’, âˆ’) : ğ¸ â†’ (UPâ„¦
ğ‘€ Ã—
: ğ‘ƒ Â¤â†’ Â¤P(ğ›¿) (ğ‘„). Recall that |PSğ‘‹ | =
UPâ„¦
QBS(ğ‘€, P (ğ‘‹ Ã— ğ‘€)). We call Â¤P Â¤S a stateful lifting. This can be seen as a transformer that takes
a â„¦-valued strong ğ¸-graded lifting Â¤P of P and returns a stateful lifting of the probabilistic state
transformer monad PS. In plain words, Â¤P Â¤S maps an â„¦-valued precondition ğ‘ƒ âˆˆ UPâ„¦
ğ‘€ and an â„¦-
valued postcondition ğ‘„ âˆˆ UPâ„¦
ğ‘‹ Ã—ğ‘€ to the computations in PS(ğ‘‹ ) that send initial memories in ğ‘ƒ
to distributions over ğ‘‹ Ã— ğ‘€ satisfying the lifted predicate Â¤P(ğ‘’) (ğ‘„). In a way, this can be seen as
the set of computations ğ‘“ : TÎ£,ğ‘’ (ğœ) satisfying the generalized Hoare triple {ğ‘ƒ }ğ‘“ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}.

This operator is not an ğ¸âˆ’graded lifting, because it does not have the appropriate type. However,

properties of â„¦-valued strong ğ¸-graded liftings can be extended to Â¤P Â¤S as stated below:

Lemma 1. Let Â¤P be an â„¦-valued strong (ğ¸, â‰¤, 1, Â·)-graded lifting of P. Let ğ‘“ âˆˆ QBS(ğ‘‹ Ã— ğ‘€, P (ğ‘Œ Ã—

ğ‘‹ Ã—ğ‘€ and ğ‘† âˆˆ UPâ„¦

ğ‘Œ Ã—ğ‘€ be predicates. The following holds:

ğ‘€)), and ğ‘ƒ âˆˆ UP2

ğ‘€ , ğ‘… âˆˆ UPâ„¦

ğ‘‹ , ğ‘„ âˆˆ UPâ„¦
: ğ‘ƒ Â¤â†’ Â¤P Â¤Sğ‘‹ (0) (ğ‘„, ğ¼ğ‘ƒ Â¤Ã— ğ‘„)

ğœ‚ P S
ğ‘‹
ğ‘“ : ğ‘… Â¤â†’ Â¤P(ğ‘’) (ğ‘†) =â‡’ (ğœ†(ğ‘“ ))#P S : Â¤P Â¤Sğ‘‹ (ğ‘’ â€²) (ğ‘„, ğ‘…) Â¤â†’ Â¤P Â¤Sğ‘Œ (ğ‘’ â€² + ğ‘’) (ğ‘„, ğ‘†)
ğ‘‹,ğ‘Œ : ğ‘ƒ Â¤Ã— Â¤P Â¤Sğ‘Œ (ğ‘’) (ğ‘„, ğ‘…) Â¤â†’ Â¤P Â¤Sğ‘‹ Ã—ğ‘Œ (ğ‘’) (ğ‘„, ğœ‹ âˆ—
ğœƒ P S

1 ğ¼ğ‘ƒ âŠ“ ğ‘…)

These consequences can be explained informally by using the language of Hoare logic:
â€¢ The ï¬rst consequence states that if ğ‘¥ âˆˆ ğœ™, then {ğ‘„ } ğœ‚ (ğ‘¥) {{ğœ™ âŠ“ ğ‘„ }}0 is a valid generalized

Hoare triple for any ğ‘„.

â€¢ The second consequence gives us a way to sequence computations as in Hoare logic. It states
that if ğ‘“ satisï¬es {ğ‘„ (ğ‘¥, âˆ’)} ğ‘“ (ğ‘¥) {{ğ‘…}}ğ‘’ for every argument ğ‘¥, and ğ‘¡ satisï¬es {ğ‘ƒ } ğ‘¡ {{ğ‘„ }}ğ‘’â€²,

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:24

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

then {ğ‘ƒ } let ğ‘¥ = ğ‘¡ in ğ‘“ {{ğ‘…}}ğ‘’+ğ‘’â€² is a valid generalized Hoare triple. Here ğ‘„ (ğ‘¥, âˆ’) is the set of
memories ğ‘š such that (ğ‘¥, ğ‘š) âˆˆ ğ‘„.

â€¢ The third consequence states that if ğ‘¥ âˆˆ ğœ™ and we have ğ‘¡ such that {ğ‘ƒ } ğ‘¡ {{ğ‘„ }}ğ‘’ then

{ğ‘ƒ } ğœƒ (ğ‘¥, ğ‘¡) {{ğœ™ âŠ“ ğ‘„ }}ğ‘’ is a valid generalized Hoare triple.

6.7 Soundness of the unary logics

We interpret formulas, assertions and entailment relations in the logic by complete Heyting alge-
bras over QBSs. We ï¬rst develop the semantics of HOL judgements of the form â€¢ | â€¢ | Î“ | Î¨ âŠ¢ ğœ™,
which is simply denoted by Î“ | Î¨ âŠ¢ ğœ™. We then interpret an open judgement ğ½ = Î | Î” | Î“ | Î¨ âŠ¢ ğœ™
as the conjunction of all closed instantiations â€¢ | â€¢ | Î“â€² âŠ¢ Î¨â€² âŠ¢ Î¦â€² of ğ½ . Here, each ğ›¼ âˆˆ Î is instan-
ciated with some subset of Loc, and A âˆˆ Î” is instanciated with a closed term of type Î”(A). The
semantics of open judgements of UHOL and HO-UBL are similarly deï¬ned. This interpretation is
well-behaved with respect to substitution. In particular, the substitution ğœ™ [ğ‘¡/ğ‘¥] of ğ‘¥ by a term ğ‘¡ of
Î“âŠ¢ğ‘¡:ğœ
appropriate type can be interpreted by the inverse image JÎ“ âŠ¢ ğœ™ [ğ‘¡/ğ‘¥]K = (sub
)âˆ—JÎ“, ğ‘¥ : ğœ âŠ¢ ğœ™K.
ğ‘¥
The soundness results of Aguirre et al. [2017] for the base logics HOL and UHOL can be recovered
in this setting, but we defer it to the appendix.

We interpret HO-UBL using the lifting Â¤P ub Â¤S of the probabilistic state monad constructed from

the lifting for the union bound logic Â¤P ub as in Example 6.2. The soundness result is stated as:

Proposition 6.4. Let Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿ be a derivable HO-UBL judgment without the

adversary rule. Then, for any ğ›¾ âˆˆ |JÎ“K|, ğ›¾ |= JÎ“ âŠ¢

Î¨K implies

JÎ“ âŠ¢ ğ‘¡ : TÎ£,ğ‘˜ (ğœ)K(ğ›¾) |= Â¤P ub Â¤S(ğ›¿) (JÎ“, s : M âŠ¢ ğ‘ƒKğ›¾ , JÎ“, v : ğœ, s : M âŠ¢ ğ‘„Kğ›¾ ).
Ã“

Analogously, we interpret HO-EXP using the lifting Â¤P exp Â¤S of the probabilistic state monad con-
structed from the lifting for expectations bound logic Â¤P exp as in Example 6.3. Most of the proof
of the previous result can be reused, and only the rules for sampling and linearity need separate
proofs. The soundness result is stated as:

Proposition 6.5. Let Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿ be a derivable HO-UBL judgment without the

adversary rule. Then, for any ğ›¾ âˆˆ |JÎ“K|, ğ›¾ |= JÎ“ âŠ¢

Î¨K implies

JÎ“ âŠ¢ ğ‘¡ : TÎ£,ğ‘˜ (ğœ)K(ğ›¾) |= Â¤P exp Â¤S(ğ›¿) (JÎ“, s : M âŠ¢ ğ‘ƒKğ›¾ , JÎ“, v : ğœ, s : M âŠ¢ ğ‘„Kğ›¾ ).
Ã“

6.8 Semantics for the relational logics
Let â„¦ = (Î©, âŠ‘) be a complete Heyting algebra. To interpret relational logics, we ï¬rst deï¬ne the
concept of â„¦-valued binary relation between two QBSs ğ‘‹, ğ‘Œ . They are simply â„¦-valued predicates
over product QBS ğ‘‹ Ã— ğ‘Œ . We thus deï¬ne BRâ„¦
ğ‘‹,ğ‘Œ
ğ‘‹,ğ‘Œ
and (ğ‘¥, ğ‘¦) âˆˆ |ğ‘‹ Ã— ğ‘Œ | = |ğ‘‹ | Ã— |ğ‘Œ |, we say that (ğ‘¥, ğ‘¦) satisï¬es ğ‘ƒ (denoted by (ğ‘¥, ğ‘¦) |= ğ‘ƒ) if ğ‘ƒ (ğ‘¥, ğ‘¦) = âŠ¤.
We routinely extend the development in the previous section to â„¦-valued binary relations. For
: ğ‘‹ â€² â†’ ğ‘Œ â€², we deï¬ne the pullback operation (ğ‘“ , ğ‘“ â€²)âˆ— :

ğ‘‹ Ã—ğ‘Œ . For 2-valued binary relation ğ‘ƒ âˆˆ BR2

QBS-morphisms ğ‘“
ğ‘‹ â€²,ğ‘Œ â€² â†’ BRâ„¦
BRâ„¦
We introduce the concept of Heyting-algebra valued strong graded relational lifting.

ğ‘‹,ğ‘Œ to be (ğ‘“ Ã— ğ‘“ â€²)âˆ—. We write (ğ‘“ , ğ‘“ â€²) : ğ‘ƒ Â¤â†’ ğ‘„ to mean ğ‘ƒ âŠ‘ (ğ‘“ , ğ‘“ â€²)âˆ—ğ‘„.

: ğ‘‹ â†’ ğ‘Œ and ğ‘“ â€²

, UPâ„¦

Definition 4. Let (ğ¸, â‰¤, 0, +) be a partially ordered monoid. An â„¦-valued strong ğ¸-graded re-
Pğ‘‹,Pğ‘Œ ), implicitly

lational lifting of P is a family of functions Â¤Pğ‘‹,ğ‘Œ (âˆ’) (âˆ’) : ğ¸ â†’ (BRâ„¦
indexed by ğ‘‹, ğ‘Œ âˆˆ QBS, satisfying:

ğ‘‹,ğ‘Œ â‡’ BRâ„¦

ğ‘’ â‰¤ ğ‘’ â€² =â‡’ Â¤P(ğ‘’) (ğ‘ƒ) âŠ‘ Â¤P(ğ‘’ â€²) (ğ‘ƒ)
ğ‘‹ , ğœ‡ P

ğ‘Œ ) : Â¤P(ğ‘’) ( Â¤P(ğ‘’ â€²) (ğ‘ƒ)) Â¤â†’ Â¤P(ğ‘’ + ğ‘’ â€²) (ğ‘ƒ)

(ğœ‡ P

(ğœ‚ P
(ğœƒ P

ğ‘‹ , ğœ‚ P
ğ‘‹ , ğœƒ P

ğ‘Œ ) : ğ‘ƒ Â¤â†’ Â¤P(0) (ğ‘ƒ)
ğ‘Œ ) : ğ‘ƒ Â¤Ã— Â¤P(ğ‘’) (ğ‘„) Â¤â†’ Â¤P(ğ‘’) (ğ‘ƒ Â¤Ã— ğ‘„).

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:25

Example 6.6 (Relational lifting for diï¬€erential privacy). Inspired from [Sato 2016], we construct a
2-valued strong graded relational lifting for diï¬€erential privacy by a graded analogue of the coden-
sity lifting [Katsumata et al. 2018]. The grading monoid is the product partially ordered monoid
( [0, âˆ], â‰¤, 0, +)2.

Â¤P dp
ğ‘‹,ğ‘Œ (ğœ–, ğ›¿) (ğ‘ƒ) (ğœˆ1, ğœˆ2) = âŠ¤ â‡â‡’ âˆ€(ğ‘“ , ğ‘”) : ğ‘ƒ Â¤â†’ğ‘† (ğœ– â€², ğ›¿ â€²) . (ğ‘“ â™¯ğœˆ1, ğ‘”â™¯ğœˆ2) |= ğ‘† (ğœ– + ğœ– â€², ğ›¿ + ğ›¿ â€²)
where (ğœˆ1, ğœˆ2) |= ğ‘† (ğœ–, ğ›¿) â‡â‡’ Pr
ğ‘âˆ¼ğœˆ1

[ğ‘ = 0] â‰¤ ğ‘’ğœ– Pr
ğ‘âˆ¼ğœˆ2

[ğ‘ = 0] + ğ›¿.

Any morphism ğœ’ğ‘† : ğ‘‹ â†’ {0, 1} in QBS standing for the â€œmeasurableâ€ subset ğ‘† of ğ‘‹ , we have
Â¤P dp
ğ‘‹,ğ‘‹ (ğœ–, ğ›¿) (Eqğ‘‹ ) (ğœ‡1, ğœ‡2) = âŠ¤ =â‡’ Prğ‘¥âˆ¼ğœ‡1 [ğ‘¥ âˆˆ ğ‘†] â‰¤ ğ‘’ğœ– Prğ‘¥âˆ¼ğœ‡2 [ğ‘¥ âˆˆ ğ‘†] + ğ›¿ since ğ‘† (0, 0) |= ( ğœ’ğ‘† , ğœ’ğ‘† ). A
strong ( [0, âˆ], â‰¤, 0, +)-graded lifting describing ğœ–-diï¬€erential privacy can be given by Â¤P dp
ğ‘‹,ğ‘Œ (ğœ–, 0).
We next introduce the stateful relational lifting, based on a â„¦-valued (ğ¸, â‰¤, +, 0)-graded rela-
P Sğ‘‹,P Sğ‘Œ )

tional lifting Â¤P of P. It is a function Â¤P Â¤Sğ‘‹,ğ‘Œ (âˆ’) (âˆ’, âˆ’) : ğ¸ â†’ (BRâ„¦
deï¬ned for each ğ‘‹, ğ‘Œ âˆˆ QBS by:

ğ‘‹ Ã—ğ‘€,ğ‘Œ Ã—ğ‘€ â‡’ BR2

ğ‘‹,ğ‘Œ Ã— BRâ„¦

(ğ‘“ , ğ‘“ â€²) |= Â¤P Â¤Sğ‘‹,ğ‘Œ (ğ‘’) (ğ‘ƒ, ğ‘„) â‡â‡’ (ğ‘“ , ğ‘“ â€²) : ğ‘ƒ Â¤â†’ Â¤P(ğ‘’) (ğ‘„).

Lemma 1 can then be generalized accordingly. We omit the details.

6.9 Soundness of the relational logics

The semantics of the relational logics are a generalization of the semantics of the unary logics.
We defer soundness of RHOL to the appendix. We interpret the monadic rules in the category of
relations over QBS, with the 2-valued strong [0, âˆ]2-graded relational lifting Â¤P dp, which induces
Â¤P dp Â¤S as in the previous section. The soundness result is stated below. Its proof is by induction on
the derivation and is largely independent of the choice of a speciï¬c lifting:

Proposition 6.7. Let Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡1 : TÎ£,ğ‘˜ (ğœ1) âˆ¼ ğ‘¡1 : TÎ£,ğ‘˜ (ğœ2){{ğ‘„ }}ğ›¿ be a derivable HO-PRL

judgment without the [ADV âˆ’ R] rule. Then for any ğ›¾ âˆˆ |JÎ“K|, ğ›¾ |= JÎ“ âŠ¢

Î¨K implies
(JÎ“ âŠ¢ ğ‘¡1 : TÎ£,ğ‘˜ (ğœ1)K(ğ›¾), JÎ“ âŠ¢ ğ‘¡2 : TÎ£,ğ‘˜ (ğœ2)K(ğ›¾)) |= Â¤P Â¤S (0, ğ›¿) (Jğ‘ƒKğ›¾ , Jğ‘„Kğ›¾ ),
where Jğ‘ƒKğ›¾ , JÎ“, s1 : M, s2 : M âŠ¢ ğ‘ƒKğ›¾ and ğ‘„ğ›¾ , JÎ“, s1 : M, v1 : ğœ, s2 : M, v2 : ğœ âŠ¢ ğ‘„Kğ›¾ .

Ã“

6.10 Soundness of the adversary rules
To prove soundness of the adversary rules we will use the technique of logical relations. Logical
predicates and relations [Plotkin 1973] are a technique used in programming language theory
to prove properties such as strong normalization or contextual equivalence. The idea of logical
relations (or predicates) is that they allow us to prove that all inhabitants of a certain type ğœ satisfy
a particular property L (ğœ) that is deï¬ned inductively on the structure of types, rather than terms.
For instance, in the unary case, we deï¬ne a logical predicate Lğœ™,ğ›¿ (Â·) indexed by an assertion ğœ™
over memories and a real ğ›¿ â‰¥ 0. For every type ğœ, Lğœ™,ğ›¿ (ğœ) corresponds to a set of closed terms. We
defer the details of this deï¬nition to the appendix, here it suï¬ƒces to know that Lğœ™,ğ›¿ (TÎ£,ğ‘˜ (ğœ)) is the
set of computations that preserve the invariant ğœ™ with error probability ğ‘˜ Â·ğ›¿ and that return a result
in Lğœ™,ğ›¿ (ğœ) (i.e., they satisfy the triple {ğœ™ } _ {{ğœ™ âˆ§v âˆˆ Lğœ™,ğ›¿ (ğœ)}}ğ‘˜ Â·ğ›¿ ), and as usual, if ğ‘¡ âˆˆ Lğœ™,ğ›¿ (ğœ â†’ ğœ)
and ğ‘¢ âˆˆ Lğœ™,ğ›¿ (ğœ) then ğ‘¡ ğ‘¢ âˆˆ Lğœ™,ğ›¿ (ğœ). Then we prove a Basic Lemma: any closed term ğ‘¡ of type
ğœ inhabits the predicate Lğœ™,ğ›¿ (ğœ) if ğœ™ âˆˆ Safe(Eï¬€ (ğœ)). This has a rather natural interpretation: if ğœ™
does not depend on any location in Eï¬€ (ğœ), then it must be preserved after running ğ‘¡.

The adversary rule [ADV âˆ’ U] can then be proven sound from the Basic Lemma. By inspecting
its premises, we know that A inhabits the logical relation Lğ‘ƒ,ğ›¿ (âˆ€ğ›¼.(ğœ â†’ Tğ›¼,1(ğœ)) â†’ TÎ£âˆªğ›¼,ğ‘˜ (ğœ â€²)),
because ğ‘ƒ âˆˆ Safe(Î£). We also have that ğœ†ğ‘¥ .ğ‘¡ inhabits the logical relation Lğ‘ƒ,ğ›¿ (ğœ â†’ TÎ£â€²,1 (ğœ)),

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:26

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

because we have a derivation of this fact (note that the Basic Lemma cannot be applied, because ğ‘ƒ
may not be safe for Î£â€²). Then, we can conclude that running A with ğœ†ğ‘¥ .ğ‘¡ as argument inhabits the
logical relation Lğ‘ƒ,ğ›¿ (TÎ£âˆªğ›¼,ğ‘˜ (ğœ â€²)), and therefore must preserve ğ‘ƒ. The techniques then generalize
to the relational case, where we deï¬ne a logical relation for every type, and then we prove a Basic
Lemma for it. Soundness of [ADV âˆ’ R] is a consequence of this Lemma.

Proposition 6.8. The [ADV âˆ’ U] and [ADV âˆ’ R] rules are sound.

7 RELATED WORK

Reasoning about adversaries. Garg et al. [2010]; Jia et al. [2015] develop ï¬rst- and higher-order pro-
gram logics to reason about safety properties of ï¬rst-order concurrent and stateful programs in-
teracting with adversaries. Both provide rules to reason about adversaries, morally similar to ours.
Our context of adversary variables representing closed programs traces lineage to a similar idea
based on comonads in Jia et al. [2015]. Devriese et al. [2016] develop semantic principles to reason
about adversaries, cast in terms of parametricity properties of side-eï¬€ects, an idea they call â€œeï¬€ect
parametricityâ€. They use these principles to verify code that uses object capabilities. No syntactic
proof rules are developed. These works cover only the boolean, deterministic, unary setting.

Closer to our work, Barthe et al. [2009] deï¬ne a probabilistic relational Hoare logic (pRHL) for
reasoning about the security of cryptographic constructions. Their logic applies to a probabilis-
tic imperative language with adversarial calls and features a proof rule for adversaries. Our rule
for the relational, non-quantitative setting closely matches their rule. Barbosa et al. [2021] formal-
ize a resource-aware module system used in EasyCrypt to reason about adversaries. There are
commonalities between their approach and ours: they view an adversary as a functor, whereas
we view an adversary as an expression of second-order type. However, the technicalities are very
diï¬€erent, since they build their system on top of an imperative language. A further diï¬€erence
is that they account for the computational cost of adversaries, which we left aside in this work.
Other similar approaches for reasoning about adversaries include Computational Indistinguisha-
bility Logic [Barthe et al. 2010], and state-separating proofs [Brzuska et al. 2018]. However, these
approaches are developed in an abstract mathematical setting, not in the context of a programming
language.

Barthe et al. [2016a] deï¬ne an adversary rule for reasoning about diï¬€erential privacy in a quan-
titative variant of pRHL; their rule uses bounds on the number of oracle queries to derive privacy
bounds of adversarial computations from privacy bounds of oracles. Barthe et al. [2016b] deï¬ne a
Union Bound logic to reason about accuracy of adversarial computations for a similar language.
However, their proof rule is restricted to adversaries without oracles. We are not aware of any
prior work on adversarial computations in the quantitative setting.

Program logics for probabilistic computations. We relate our program logics to existing approaches
for reasoning about probabilistic computations. For brevity, we only discuss approaches not dis-
cussed before. Kozen [1985] introduces expectation-based reasoning for a core probabilistic pro-
gramming language. Morgan et al. [1996] deï¬ne a weakest pre-expectation calculus. Aguirre et al.
[2021] develop a variant of the calculus for relational properties. Kaminski et al. [2016] show how
similar ideas can be used for reasoning about expected cost. All these works share the setting of
a probabilistic imperative language. Aguirre and Katsumata [2020] show that expectation-based
reasoning remains sound in a higher-order setting, but their semantics is based on set theory, not
Quasi-Borel spaces, so they cannot model continuous distributions. They also do not provide proof
systems.

There exist adaptations of (approximate) probabilistic relational Hoare logic in the higher-order
setting, starting from [Barthe et al. 2014a]. However, these adaptations have a set-theoretical or

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:27

topos of trees semantics and only support distributions over discrete base types. Sato et al. [2019]
introduce an expressive logic for a language similar to ours but without state and adversary. Their
model is also based on QBS. Tassarotti and Harper [2019] develop a logic to prove relational prop-
erties of higher-order programs that combine probabilities and non-determinism. They do not
support all the kinds of reasoning we do, and the relations they can prove are between a program
and an speciï¬cation, rather than between two programs. Maillard et al. [2020] deï¬ne a framework,
embedded in a relational dependent type theory, for deï¬ning and reasoning about program logics
for general monadic eï¬€ects. While their work is based on Dijkstra monads, ours is more closely
related to Hoare monads [Nanevski et al. 2013, 2008]. Our work extends Hoare monads to support
Heyting-valued predicates, probabilistic programs, grading and adversarial reasoning.

Program equivalence. There is a very large body of methods for proving program equivalence,
and in particular contextual equivalence, in higher-order languages with state, probabilities, and
eï¬€ects; see e.g. [Benton et al. 2014; Bizjak and Birkedal 2015; CrubillÃ© and Lago 2015; Jung et al.
2015; Matache and Staton 2019; Pitts and Stark 1998]. Many of these methods have been applied
to reason about security and privacy, using the natural view of adversaries as contexts. These meth-
ods are not comparable with ours: our relational logic can prove a richer set of speciï¬cations (for
instance, the postcondition needs not be an equivalence relation). However, they cannot establish
some basic equivalences, e.g. swapping of two sampling instructions, due to the speciï¬c way the
logic constructs couplings. We also conjecture that our logics are easier to extend to richer settings,
such as multi-stage and multi-adversary security notions (see e.g. [Ristenpart et al. 2011]). Finally,
these methods cannot be used to reason about unary properties.

8 CONCLUDING REMARKS

We conclude the paper with a discussion of additional examples that can be handled by the three
logics we have presented (and by small extensions to the logics), and a discussion of how we can
extend our framework with unbounded recursion.

Other examples. HO-UBL can verify the accuracy of diï¬€erentially private mechanisms such as
the Sparse Vector algorithm [Dwork and Roth 2014], since accuracy can be formulated as the prob-
ability that the noisy answer is close to the actual answer. We have already worked out this example
but, for reasons of space, we defer it to the appendix.

The bounded leakage model is a model of leakage-resilient cryptography in which the adver-
sary is given access to a leakage oracle which takes as input a function with a small codomain and
returns the output of this function applied to the secret state. A (partially formalized) proof of secu-
rity of a pseudo-random generator in the bounded leakage model is given in [Barthe et al. 2014b].
HO-PRL can be used to verify this proof, using either a ï¬rst- or a higher-order representation of
leakage.

Other examples can be veriï¬ed with extensions to our logics that can also be proved sound
in our framework. For instance, we can support a slightly diï¬€erent relational logic in which the
Hoare quadruple is indexed by a pair (ğœ–, ğ›¿), and interpreted using the lifting from Example 6.6.
With this logic, we can study diï¬€erential privacy of mechanisms such as the exponential mecha-
nism on non-numerical queries [Dwork and Roth 2014], which uses a scoring function that assigns
positive values to all possible input/output pairs. Prior work [Barthe et al. 2012], has veriï¬ed this
mechanism using a ï¬rst-order representation of scoring. However, we can verify a higher-order
representation of this mechanism, where the scoring function is passed as an argument to the
mechanism.

We can also use HO-EXP to verify examples based on the weakest pre-expectation calculus [Morgan et al.

1996]. One caveat is that many of these examples use arbitrary while loops, which our language

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:28

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

does not currently support. This extension would require extending the model as discussed at the
end of this section. Other examples, e.g., stability of machine learning algorithms, would require
developing a logic for relational pre-expectations. Yet others, e.g. cryptography, would require en-
riching our logics with additional proof principles that embed notions of cryptographic reductions.
In the long run, it would be interesting to support these formalisms with an implementation to
mechanize examples.

Unbounded recursion. Our language provides bounded recursion via the monadic fold. An inter-
esting follow-up would be to extend our language with unbounded monadic recursion. For this,
we would also need to change the semantic model. One possibility is to use the recently proposed
category ğœ”QBS [VÃ¡kÃ¡r et al. 2019] to interpret types.

ACKNOWLEDGMENTS

S.K. was supported by ERATO HASUO Metamathematics for Systems Design Project (No. JPM-
JER1603), Japan Science and Technology Agency. T.S. was supported by JSPS KAKENHI Grant
Number 20K19775, Japan. M.G. was supported by NSF awards CCF-2040222 and CCF-1718220.

REFERENCES
Alejandro Aguirre, Gilles Barthe, Marco Gaboardi, Deepak Garg, and Pierre-Yves Strub. 2017. A relational logic for higher-

order programs. PACMPL 1, ICFP (2017), 21:1â€“21:29. https://doi.org/10.1145/3110265

Alejandro Aguirre, Gilles Barthe, Justin Hsu, Benjamin Lucien Kaminski, Joost-Pieter Katoen, and Christoph Matheja. 2021.
A Pre-Expectation Calculus for Probabilistic Sensitivity. Proc. ACM Program. Lang. 5, POPL, Article 52 (Jan. 2021),
28 pages. https://doi.org/10.1145/3434333

Alejandro Aguirre and Shin-ya Katsumata. 2020. Weakest preconditions in ï¬brations. (2020). Accepted at MFPSâ€™20.
Robert J Aumann et al. 1961. Borel structures for function spaces. Illinois Journal of Mathematics 5, 4 (1961), 614â€“630.
Manuel Barbosa, Gilles Barthe, Benjamin GrÃ©goire, Adrien Koutsos, and Pierre-Yves Strub. 2021. Mechanized Proofs of
Adversarial Complexity and Application to Universal Composability. Cryptology ePrint Archive, Report 2021/156.
https://eprint.iacr.org/2021/156.

Gilles Barthe, Marion Daubignard, Bruce M. Kapron, and Yassine Lakhnech. 2010. Computational indistinguishabil-
ity logic. In Proceedings of the 17th ACM Conference on Computer and Communications Security, CCS 2010, Chicago,
Illinois, USA, October 4-8, 2010, Ehab Al-Shaer, Angelos D. Keromytis, and Vitaly Shmatikov (Eds.). ACM, 375â€“386.
https://doi.org/10.1145/1866307.1866350

Gilles Barthe, Thomas Espitau, Benjamin GrÃ©goire, Justin Hsu, and Pierre-Yves Strub. 2018. Proving expected sensitivity

of probabilistic programs. Proc. ACM Program. Lang. 2, POPL (2018), 57:1â€“57:29. https://doi.org/10.1145/3158145

Gilles Barthe, NoÃ©mie Fong, Marco Gaboardi, Benjamin GrÃ©goire, Justin Hsu, and Pierre-Yves Strub. 2016a. Advanced Prob-
abilistic Couplings for Diï¬€erential Privacy. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Com-
munications Security, Vienna, Austria, October 24-28, 2016, Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel,
Andrew C. Myers, and Shai Halevi (Eds.). ACM, 55â€“67.

Gilles Barthe, CÃ©dric Fournet, Benjamin GrÃ©goire, Pierre-Yves Strub, Nikhil Swamy, and Santiago Zanella BÃ©guelin. 2014a.
Probabilistic relational veriï¬cation for cryptographic implementations. In POPL 2014, Suresh Jagannathan and Peter
Sewell (Eds.).

Gilles Barthe, Marco Gaboardi, Benjamin GrÃ©goire, Justin Hsu, and Pierre-Yves Strub. 2016b. A Program Logic for Union
Bounds. In 43rd International Colloquium on Automata, Languages, and Programming, ICALP 2016, July 11-15, 2016, Rome,
Italy (LIPIcs, Vol. 55), Ioannis Chatzigiannakis, Michael Mitzenmacher, Yuval Rabani, and Davide Sangiorgi (Eds.). Schloss
Dagstuhl - Leibniz-Zentrum fuer Informatik, 107:1â€“107:15. https://doi.org/10.4230/LIPIcs.ICALP.2016.107

Gilles Barthe, Benjamin GrÃ©goire, and Santiago Zanella BÃ©guelin. 2009. Formal certiï¬cation of code-based cryptographic

proofs. In POPL 2009, Savannah, GA, USA, January 21-23, 2009. https://doi.org/10.1145/1480881.1480894

Gilles Barthe, Boris KÃ¶pf, Laurent Mauborgne, and MartÃ­n Ochoa. 2014b. Leakage Resilience against Concurrent Cache

Attacks. In Proc. 3rd Conference on Principles of Security and Trust (POST â€™14). Springer.
Gilles Barthe, Boris KÃ¶pf, Federico Olmedo, and Santiago Zanella BÃ©guelin. 2012.

reasoning for diï¬€erential privacy.
https://doi.org/10.1145/2103656.2103670

In POPL 2012, Philadelphia, Pennsylvania, USA,

Probabilistic relational
January 22-28, 2012.

Nick Benton, Martin Hofmann, and Vivek Nigam. 2014. Abstract eï¬€ects and proof-relevant logical relations. In The 41st An-
nual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL â€™14, San Diego, CA, USA, January

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:29

20-21, 2014, Suresh Jagannathan and Peter Sewell (Eds.). ACM, 619â€“632. https://doi.org/10.1145/2535838.2535869
Ales Bizjak and Lars Birkedal. 2015. Step-Indexed Logical Relations for Probability. In FoSSaCS 2015, London, UK, April

11-18, 2015. Proceedings.

Burton H. Bloom. 1970. Space/Time Trade-oï¬€s in Hash Coding with Allowable Errors. Commun. ACM 13, 7 (1970), 422â€“426.

https://doi.org/10.1145/362686.362692

Chris Brzuska, Antoine Delignat-Lavaud, CÃ©dric Fournet, Konrad Kohbrok, and Markulf Kohlweiss. 2018. State Separation
for Code-Based Game-Playing Proofs. In Advances in Cryptology - ASIACRYPT 2018 - 24th International Conference on the
Theory and Application of Cryptology and Information Security, Brisbane, QLD, Australia, December 2-6, 2018, Proceedings,
Part III (Lecture Notes in Computer Science, Vol. 11274), Thomas Peyrin and Steven D. Galbraith (Eds.). Springer, 222â€“249.
https://doi.org/10.1007/978-3-030-03332-3_9

David Clayton, Christopher Patton, and Thomas Shrimpton. 2019. Probabilistic Data Structures in Adversarial Environ-
ments. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, CCS 2019, London,
UK, November 11-15, 2019, Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz (Eds.). ACM, 1317â€“
1334. https://doi.org/10.1145/3319535.3354235

RaphaÃ«lle CrubillÃ© and Ugo Dal Lago. 2015. Metric Reasoning about ğœ†-Terms: The Aï¬ƒne Case. In 30th Annual ACM/IEEE
Symposium on Logic in Computer Science, LICS 2015, Kyoto, Japan, July 6-10, 2015. IEEE Computer Society, 633â€“644.
https://doi.org/10.1109/LICS.2015.64

Vincent Danos and Thomas Ehrhard. 2011. Probabilistic coherence spaces as a model of higher-order probabilistic compu-

tation. Inf. Comput. 209, 6 (2011), 966â€“991. https://doi.org/10.1016/j.ic.2011.02.001

Dominique Devriese, Lars Birkedal, and Frank Piessens. 2016. Reasoning about Object Capabilities with Logical Relations

and Eï¬€ect Parametricity. In IEEE European Symposium on Security and Privacy (EuroS&P). 147â€“162.

Cynthia Dwork and Aaron Roth. 2014. The Algorithmic Foundations of Diï¬€erential Privacy. Foundations and Trends in

Theoretical Computer Science 9, 3â€“4 (2014), 211â€“407. http://dx.doi.org/10.1561/0400000042

Deepak Garg, Jason Franklin, Dilsun Kirli Kaynar, and Anupam Datta. 2010. Compositional System Security with Interface-

Conï¬ned Adversaries. Electr. Notes Theor. Comput. Sci. 265 (2010), 49â€“71.

Thomas Gerbet, Amrit Kumar, and CÃ©dric Lauradoux. 2015. The Power of Evil Choices in Bloom Filters. In 45th Annual
IEEE/IFIP International Conference on Dependable Systems and Networks, DSN 2015, Rio de Janeiro, Brazil, June 22-25, 2015.
IEEE Computer Society, 101â€“112. https://doi.org/10.1109/DSN.2015.21

Chris Heunen, Ohad Kammar, Sam Staton, and Hongseok Yang. 2017. A convenient category for higher-order probability
theory. In 32nd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2017, Reykjavik, Iceland, June 20-23,
2017. IEEE Computer Society, 1â€“12. https://doi.org/10.1109/LICS.2017.8005137

R. Impagliazzo and S. Rudich. 1989. Limits on the provable consequences of one-way permutations. In 21st Annual ACM

Symposium on Theory of Computing, 1989. ACM, New York, 44â€“61.

Kenneth E. Iverson. 1962. A Programming Language. John Wiley & Sons, Inc., USA.
Limin Jia, Shayak Sen, Deepak Garg, and Anupam Datta. 2015. A Logic of Programs with Interface-Conï¬ned Code. In IEEE

28th Computer Security Foundations Symposium (CSF). 512â€“525.

Ralf Jung, David Swasey, Filip Sieczkowski, Kasper Svendsen, Aaron Turon, Lars Birkedal, and Derek Dreyer. 2015. Iris:
Monoids and Invariants as an Orthogonal Basis for Concurrent Reasoning. In Proceedings of the 42nd Annual ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2015, Mumbai, India, January 15-17, 2015,
Sriram K. Rajamani and David Walker (Eds.). ACM, 637â€“650. https://doi.org/10.1145/2676726.2676980

Benjamin Lucien Kaminski,

est Precondition Reasoning
https://doi.org/10.1007/978-3-662-49498-1_15

Joost-Pieter Katoen, Christoph Matheja, and Federico Olmedo. 2016.
9632.

of Probabilistic Programs, Vol.

for Expected Run-Times

Weak-
364â€“389.

Shin-ya Katsumata. 2014. Parametric Eï¬€ect Monads and Semantics of Eï¬€ect Systems. In Proceedings of the 41st ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (San Diego, California, USA) (POPL â€™14). Associ-
ation for Computing Machinery, New York, NY, USA, 633â€“645. https://doi.org/10.1145/2535838.2535846

Shin-ya Katsumata, Tetsuya Sato, and Tarmo Uustalu. 2018. Codensity Lifting of Monads and its Dual. Log. Methods

Comput. Sci. 14, 4 (2018). https://doi.org/10.23638/LMCS-14(4:6)2018

Dexter Kozen. 1985. A Probabilistic PDL. 30, 2 (1985), 162â€“178.
Saunders MacLane. 1971. Categories for the Working Mathematician. Springer-Verlag, New York. Graduate Texts in

Mathematics, Vol. 5.

Kenji Maillard, Catalin Hritcu, Exequiel Rivas, and Antoine Van Muylder. 2020. The next 700 relational program logics.

Proc. ACM Program. Lang. 4, POPL (2020), 4:1â€“4:33.

Cristina Matache and Sam Staton. 2019. A Sound and Complete Logic for Algebraic Eï¬€ects. In Foundations of Soft-
ware Science and Computation Structures - 22nd International Conference, FOSSACS 2019, Held as Part of the European
Joint Conferences on Theory and Practice of Software, ETAPS 2019, Prague, Czech Republic, April 6-11, 2019, Proceed-
ings (Lecture Notes in Computer Science, Vol. 11425), Mikolaj Bojanczyk and Alex Simpson (Eds.). Springer, 382â€“399.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:30

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

https://doi.org/10.1007/978-3-030-17127-8_22

Carroll Morgan, Annabelle McIver, and Karen Seidel. 1996. Probabilistic Predicate Transformers. 18, 3 (1996), 325â€“353.
Aleksandar Nanevski, Anindya Banerjee, and Deepak Garg. 2013.

Dependent Type Theory for Veriï¬cation
ACM Trans. Program. Lang. Syst. 35, 2 (2013), 6:1â€“6:41.

of Information Flow and Access Control Policies.
https://doi.org/10.1145/2491522.2491523

Aleksandar Nanevski, J. Gregory Morrisett, and Lars Birkedal. 2008. Hoare type theory, polymorphism and separation. J.

Funct. Program. 18, 5-6 (2008), 865â€“911. https://doi.org/10.1017/S0956796808006953

Moni Naor and Eylon Yogev. 2019. Bloom Filters in Adversarial Environments. ACM Trans. Algorithms 15, 3 (2019), 35:1â€“

35:30. https://doi.org/10.1145/3306193

Andrew Pitts and Ian Stark. 1998. Operational Reasoning for Functions with Local State.

In Higher Order Operational
Techniques in Semantics, Andrew Gordon and Andrew Pitts (Eds.). Publications of the Newton Institute, Cambridge
University Press, 227â€“273. http://www.inf.ed.ac.uk/~stark/operï¬‚.html

Gordon Plotkin. 1973. Lambda-deï¬nability and logical relations.
Thomas Ristenpart, Hovav Shacham, and Thomas Shrimpton. 2011. Careful with Composition: Limitations of the Indiï¬€eren-
tiability Framework. In Advances in Cryptology - EUROCRYPT 2011 - 30th Annual International Conference on the Theory
and Applications of Cryptographic Techniques, Tallinn, Estonia, May 15-19, 2011. Proceedings (Lecture Notes in Computer
Science, Vol. 6632), Kenneth G. Paterson (Ed.). Springer, 487â€“506. https://doi.org/10.1007/978-3-642-20465-4_27

Tetsuya Sato. 2016. Approximate Relational Hoare Logic for Continuous Random Samplings. In The Thirty-second Confer-
ence on the Mathematical Foundations of Programming Semantics, MFPS 2016, Carnegie Mellon University, Pittsburgh, PA,
USA, May 23-26, 2016 (Electronic Notes in Theoretical Computer Science, Vol. 325), Lars Birkedal (Ed.). Elsevier, 277â€“298.
https://doi.org/10.1016/j.entcs.2016.09.043

Tetsuya Sato, Alejandro Aguirre, Gilles Barthe, Marco Gaboardi, Deepak Garg, and Justin Hsu. 2019. Formal veriï¬cation of
higher-order probabilistic programs: reasoning about approximation, convergence, Bayesian inference, and optimiza-
tion. PACMPL 3, POPL (2019), 38:1â€“38:30. https://dl.acm.org/citation.cfm?id=3290351

Adam Åšcibior, Ohad Kammar, Matthijs VÃ¡kÃ¡r, Sam Staton, Hongseok Yang, Yufei Cai, Klaus Ostermann, Sean K. Moss,
Chris Heunen, and Zoubin Ghahramani. 2017. Denotational Validation of Higher-order Bayesian Inference. Proc. ACM
Program. Lang. 2, POPL, Article 60 (Dec. 2017), 29 pages. https://doi.org/10.1145/3158148

Joseph Tassarotti and Robert Harper. 2019. A Separation Logic for Concurrent Randomized Programs. Proc. ACM Program.

Lang. 3, POPL, Article 64 (Jan. 2019), 30 pages. https://doi.org/10.1145/3290377

Matthijs VÃ¡kÃ¡r, Ohad Kammar, and Sam Staton. 2019. A domain theory for statistical probabilistic programming. PACMPL

3, POPL (2019), 36:1â€“36:29. https://dl.acm.org/citation.cfm?id=3290349

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:31

A SUBTYPING AND ADDITIONAL TYPING RULES
We present here the subtyping rules (Figure 6) and the typing rules for expressions about memories
(Figure 7).

Î âŠ¢ ğœ (cid:22) ğœ â€²

Î âŠ¢ ğœ â€² (cid:22) ğœ â€²â€²

Î âŠ¢ ğµ (cid:22) ğµ

Î âŠ¢ ğœ (cid:22) ğœ â€²

Î âŠ¢ ğœ (cid:22) ğœ â€²â€²
Î âŠ¢ ğœ (cid:22) ğœ â€²

Î âŠ¢ ğœ Ã— ğœ (cid:22) ğœ â€² Ã— ğœ â€²

ğ¾ â‰¤ ğ¾ â€²
Î âŠ¢ N[ğ¾] (cid:22) N[ğ¾ â€²]

Î âŠ¢ ğœ â€² (cid:22) ğœ

Î âŠ¢ ğœ (cid:22) ğœ â€²

Î âŠ¢ ğœ â‡’ ğœ (cid:22) ğœ â€² â‡’ ğœ â€²

Î âŠ¢ Î£ âŠ† Î£â€²

Î âŠ¢ ğœ (cid:22) ğœ â€²
ğ‘˜ â‰¤ ğ‘˜ â€²
Î âŠ¢ TÎ£,ğ‘˜ (ğœ) (cid:22) TÎ£â€²,ğ‘˜â€² (ğœ â€²)
Î âŠ¢ ğœ (cid:22) ğœ â€²
Î âŠ¢ âˆ€ğ›¼.ğœ (cid:22) âˆ€ğ›¼.ğœ â€²

Fig. 6. Subtyping rules. Here, Î âŠ¢ Î£ âŠ† Î£â€² for Î = ğ›¼1, . . . , ğ›¼ğ‘› if for every Î£1, . . . , Î£ğ‘› âŠ† Loc we have
Î£[Î£1/ğ›¼1] . . . [Î£ğ‘›/ğ›¼ğ‘›] âŠ† Î£â€² [Î£1/ğ›¼1] . . . [Î£ğ‘›/ğ›¼ğ‘›].

Î“ âŠ¢ Ëœğ‘¡ : M

ğ‘ âˆˆ Loc

Î“ âŠ¢ Ëœğ‘¡ : M

Î“ âŠ¢ Ëœğ‘¡ [ğ‘] : V

Î“ âŠ¢ Ëœğ‘¢ : V
Î“ âŠ¢ Ëœğ‘¡ [ğ‘ â†¦â†’ Ëœğ‘¢] : M

ğ‘ âˆˆ Loc

Fig. 7. Typing rules for memory access

B ADDITIONAL PROOF RULES

We ï¬rst present the standard well-formed rules for HOL assertions in Figure 8. The extended
Hoare triples and quadruples from our logics can be internalized into HOL. To this end, we add
a predicate former Hğœ,ğ›¿ (ğ‘ƒ, ğ‘¡, ğ‘„) that internalizes the monadic judgments into. This predicates are
well-formed when ğ‘ƒ is a well-formed assertion (which may contain a variable for the state s : M),
ğ‘„ is a well-formed assertion (which may contain variables for the state s : M, and the result v : ğœ)
and âŠ¢ ğ‘¡ : TÎ£,ğ‘˜ (ğœ). The interpretation is equivalent to the corresponding monadic judgment. We add
rules to switch between systems in Figure 9.

We also introduce a relational analog of this predicate, via a predicate former Hğœ,ğœ,ğ‘˜ğ›¿ (ğ‘ƒ, ğ‘¡1, ğ‘¡2, ğ‘„).

Morally, this is valid whenever

ğ‘… âŠ† ğ‘¡1 : ğœ1 Ã— Â· Â· Â· Ã— ğ‘¡ğ‘˜ : ğœğ‘˜

Î“ âŠ¢ ğ‘¡1 : ğœ1 . . . Î“ âŠ¢ ğ‘¡ğ‘˜ : ğœğ‘˜

Î“ âŠ¢ ğœ™1

Î“ âŠ¢ ğœ™2

Î“ âŠ¢ ğœ™1

Î“ âŠ¢ ğœ™2

Î“ âŠ¢ ğ‘…(ğ‘¡1, . . . , ğ‘¡ğ‘˜ )

Î“ âŠ¢ ğœ™1 âˆ§ ğœ™2

Î“ âŠ¢ ğœ™1 â‡’ ğœ™2

Î“, ğ‘¥ : ğœ âŠ¢ ğœ™
Î“ âŠ¢ âˆ€ğ‘¥.ğœ™

Î“, ğ‘¥ : ğœ âŠ¢ ğœ™
Î“ âŠ¢ âˆƒğ‘¥.ğœ™

Fig. 8. Selected well-formedness rules of HOL

C PROOFS OF SOUNDNESS OF THE ADVERSARY RULES
C.1 Soundness of the [ADV âˆ’ U] rule
To prove soundness of the adversary rules we will use logical relations. Logical predicates and
relations [Plotkin 1973] are a technique used in programming language theory to prove properties
such as strong normalization or contextual equivalence. The idea of logical relations (or predicates)

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:32

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

Î“ | Î¨ âŠ¢ ğœ™ [ğ‘¡/r]
Î“, s : ğ‘€ âŠ¢ ğ‘ƒ
Î“ | Î¨ âŠ¢ Hğœ,0 (ğœ™, unit(ğ‘¡), ğ‘ƒ âˆ§ ğœ™)

Hğ¼

Î“ | Î¨ âŠ¢ Hğœ,ğ›¿ (ğ‘ƒ, ğ‘¡, ğ‘„)

Î“, ğ‘¥ : ğœ | Î¨ âŠ¢ Hğœ,ğ›¿â€² (ğ‘„ [ğ‘¥/v], ğ‘¢, ğ‘…)

Î“ | Î¨ âŠ¢ Hğœ,ğ›¿+ğ›¿â€² (ğ‘ƒ, let ğ‘¥ = ğ‘¡ in ğ‘¢, ğ‘„)

Hğ¸

Fig. 9. HOL rules for internalized triples

Î“ | Î¨ âŠ¢ ğœ™1

Î“ | Î¨ âŠ¢ ğœ™2

Î“ | Î¨, ğœ™ âŠ¢ ğœ™ Ax

Î“ | Î¨ âŠ¢ ğœ™1 âˆ§ ğœ™2

Î“ | Î¨ âŠ¢ ğœ™1 âˆ§ ğœ™2
Î“ | Î¨ âŠ¢ ğœ™1
Î“ | Î¨ âŠ¢ ğœ™1 â‡’ ğœ™2

âˆ§ğ¸

Î“ | Î¨, ğœ™1 âŠ¢ ğœ™2
Î“ | Î¨ âŠ¢ ğœ™1 â‡’ ğœ™2
Î“ | Î¨ âŠ¢ ğœ™1

âˆ§ğ¼

â‡’ğ¼

â‡’ğ¸

Î“ | Î¨ âŠ¢ ğœ™2

Fig. 10. Selected HOL rules

Î“ âŠ¢ ğ‘¥ : ğœ

Î“ | Î¨ âŠ¢ ğœ™ [ğ‘¥/r]

Î“ | Î¨ âŠ¢ ğ‘¥ : ğœ{ğœ™ }

U-VAR

Î“, ğ‘¥ : ğœ | Î¨, ğœ™ â€² âŠ¢ ğ‘¡ : ğœ{ğœ™ }
Î“ | Î¨ âŠ¢ ğœ†ğ‘¥ : ğœ.ğ‘¡ : ğœ â†’ ğœ{âˆ€ğ‘¥.ğœ™ â€² â‡’ ğœ™ [r ğ‘¥/r]}

U-ABS

Î“ | Î¨ âŠ¢ ğ‘¡ : ğœ â†’ ğœ{âˆ€ğ‘¥.ğœ™ â€² [ğ‘¥/r] â‡’ ğœ™ [r ğ‘¥/r]}
Î“ | Î¨ âŠ¢ ğ‘¡ ğ‘¢ : ğœ{ğœ™ [ğ‘¢/ğ‘¥]}

Î“ | Î¨ âŠ¢ ğ‘¢ : ğœ {ğœ™ â€²}

U-APP

Î“ | Î¨ âŠ¢ ğ‘¡ : ğœ{ğœ™ â€²}

Î“ | Î¨ âŠ¢ ğœ™ â€² [ğ‘¡/r] â‡’ ğœ™ [ğ‘¡/r]

Î“ | Î¨ âŠ¢ ğ‘¡ : ğœ{ğœ™ }

Î“ | Î¨ âŠ¢ ğ‘¡ : ğœ{ğ‘ â‡’ ğœ™ }

Î“ | Î¨ âŠ¢ ğ‘¢ : ğœ{Â¬ğ‘ â‡’ ğœ™ }

Î“ | Î¨ âŠ¢ if ğ‘ then ğ‘¡ else ğ‘¢ : ğœ{ğœ™ }

U-SUB

U-CASE

Fig. 11. Selected UHOL rules

is that they allow us to prove that all inhabitants of a certain type satisfy a particular property that
is deï¬ned inductively on the structure of types, rather than terms.

We now deï¬ne an indexed logical predicate Lğœ™,ğ›¿ mapping types to predicates (more concretely,
it maps a type ğœ to a set of closed terms of type ğœ). The logical predicate is indexed by an invariant
ğœ™, which is a predicate over memories and a real ğ›¿ âˆˆ [0, 1] and it is deï¬ned as follows:

Lğœ™,ğ›¿ (ğµ) , {ğ‘ : ğµ}

Lğœ™,ğ›¿ (ğœ â†’ ğœ) ,

{ğ‘¡ : ğœ â†’ ğœ | âˆ€ğ‘¥ : ğœ.ğ‘¥ âˆˆ Lğœ™,ğ›¿ (ğœ) â‡’ (ğ‘¡ ğ‘¥) âˆˆ Lğœ™,ğ›¿ (ğœ)}
{ğ‘¡ : ğœ â†’ ğœ | âˆ€ğ‘¥ : ğœ.(ğ‘¡ ğ‘¥) âˆˆ Lğœ™,ğ›¿ (ğœ)}

if Eï¬€ (ğœ) âŠ† Eï¬€ (ğœ)
otherwise

(

Lğœ™,ğ›¿ (ğœ Ã— ğœ) , {ğ‘¡ : ğœ Ã— ğœ | ğœ‹1 (ğ‘¡) âˆˆ Lğœ™,ğ›¿ (ğœ) âˆ§ ğœ‹2 (ğ‘¡) âˆˆ Lğœ™,ğ›¿ (ğœ)}

Lğœ™,ğ›¿ (TÎ£,ğ‘˜ (ğœ)) , {ğ‘¡ : TÎ£,ğ‘˜ (ğœ) | Hğœ,ğ‘˜ğ›¿ (ğœ™, ğ‘¡, v âˆˆ Lğœ™,ğ›¿ (ğœ) âˆ§ ğœ™)}

Lğœ™,ğ›¿ (âˆ€ğ›¼.ğœ) , {ğ‘¡ : âˆ€ğ›¼.ğœ | âˆ€Î£.ğ‘¡ âˆˆ Lğœ™,ğ›¿ (ğœ [Î£/ğ›¼])}

The deï¬nition of the logical predicate involves two subtleties. First note that there are two
diï¬€erent deï¬nitions of the logical predicate for arrow types, depending on whether the eï¬€ect of

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:33

Î“, ğ‘¥1 : ğœ1, ğ‘¥2 : ğœ2 | Î¨, ğœ™ â€² âŠ¢ ğ‘¡1 : ğœ1 âˆ¼ ğ‘¡2 : ğœ2 {ğœ™ }
Î“ | Î¨ âŠ¢ ğœ†ğ‘¥1 : ğœ1.ğ‘¡1 : ğœ1 â†’ ğœ1 âˆ¼ ğœ†ğ‘¥2 : ğœ2.ğ‘¡2 : ğœ2 â†’ ğœ2 {âˆ€ğ‘¥1, ğ‘¥2.ğœ™ â€² â‡’ ğœ™ [r1 ğ‘¥1/r1] [r2 ğ‘¥2/r2]}
Î“ | Î¨ âŠ¢ ğ‘¡1 : ğœ1 â†’ ğœ1 âˆ¼ ğ‘¡2 : ğœ2 â†’ ğœ2 {âˆ€ğ‘¥1, ğ‘¥2.ğœ™ â€² [ğ‘¥1/r1] [ğ‘¥2/r2] â‡’ ğœ™ [r1 ğ‘¥1/r1] [r2 ğ‘¥2/r2]}
Î“ | Î¨ âŠ¢ ğ‘¢1 : ğœ1 âˆ¼ ğ‘¢2 : ğœ2 {ğœ™ â€²}
Î“ | Î¨ âŠ¢ ğ‘¡1ğ‘¢1 : ğœ1 âˆ¼ ğ‘¡2ğ‘¢2 : ğœ2 {ğœ™ [ğ‘¢1/ğ‘¥1] [ğ‘¢2/ğ‘¥2]}

ABS

APP

Î“ âŠ¢ ğ‘¥1 : ğœ1

Î“ âŠ¢ ğ‘¥2 : ğœ2

Î“ | Î¨ âŠ¢ ğœ™ [ğ‘¥1/r1] [ğ‘¥2/r2]

Î“ | Î¨ âŠ¢ ğ‘¥1 : ğœ1 âˆ¼ ğ‘¥2 : ğœ2 {ğœ™ }
Î“, ğ‘¥1 : ğœ1 | Î¨, ğœ™ â€² âŠ¢ ğ‘¡1 : ğœ1 âˆ¼ ğ‘¡2 : ğœ2 {ğœ™ }
Î“ | Î¨ âŠ¢ ğœ†ğ‘¥1 : ğœ1.ğ‘¡1 : ğœ1 â†’ ğœ1 âˆ¼ ğ‘¡2 : ğœ2 {âˆ€ğ‘¥1.ğœ™ â€² â‡’ ğœ™ [r1 ğ‘¥1/r1]}

VAR

ABS-L

Î“ | Î¨ âŠ¢ ğ‘¡1 : ğœ1 â†’ ğœ1 âˆ¼ ğ‘¢2 : ğœ2 {âˆ€ğ‘¥1.ğœ™ â€² [ğ‘¥1/r1] â‡’ ğœ™ [r1 ğ‘¥1/r1]}
Î“ | Î¨ âŠ¢ ğ‘¡1ğ‘¢1 : ğœ1 âˆ¼ ğ‘¢2 : ğœ2 {ğœ™ [ğ‘¢1/ğ‘¥1]}

Î“ | Î¨ âŠ¢ ğ‘¢1 : ğœ1{ğœ™ â€²}

APP-L

ğœ™ [ğ‘¥1/r1] âˆˆ Î¨

r2 âˆ‰ ğ¹ğ‘‰ (ğœ™)

Î“ âŠ¢ ğ‘¡2 : ğœ2

Î“ | Î¨ âŠ¢ ğ‘¥1 : ğœ1 âˆ¼ ğ‘¡2 : ğœ2 {ğœ™ }

VAR-L

Fig. 12. Selected RHOL rules

the argument is contained in the eï¬€ect of the result. The idea is that if it is not, then the argument
is ignored, so we do not need to require that it satisï¬es the logical predicate. Otherwise, we get
the usual deï¬nition: a function satisï¬es the logical predicate for ğœ â†’ ğœ if arguments that satisfy
the predicate for ğœ get mapped to results satisfying the predicate the predicate for ğœ. The second
subtlety is that the deï¬nition ignores the ï¬rst grading of the monad. A diï¬€erent deï¬nition, without
indexing the predicate by ğœ™ and deï¬ning instead:

Lğ›¿ (TÎ£,ğ‘˜ (ğœ)) , {ğ‘¡ : TÎ£,ğ‘˜ (ğœ) | âˆ€ğœ™ âˆˆ Safe(Î£).Hğœ,ğ‘˜ğ›¿ (ğœ™, ğ‘¡, v âˆˆ Lğœ™,ğ›¿ (ğœ) âˆ§ ğœ™)}

would impose overly strong conditions on monadic types that appear in argument position.
Namely, it would force us to prove that they preserve all the invariants that are safe for a given
region Î£, but we only know that the oracle preserves a particular invariant ğœ™. Note however that
the grading ğ‘˜ is used to scale the grading of the lifting. The grading Î£ of the monad is used in the
premise of the Basic Lemma, which we now state, using the notion of safety that we deï¬ned in
Section 4.1.

Lemma 2 (Basic lemma). Let Â¤P be as above, and assume that for every ğœˆ âˆˆ Î”, sample(ğœˆğœ ) âˆˆ
Â¤P0(Lğœ™,ğ›¿ (ğœ)). Let âŠ¢ ğ‘¡ : ğœ be a closed term, and s : ğ‘€ âŠ¢ ğœ™ such that ğœ™ âˆˆ Safe(Eï¬€ (ğœ)). Then, for all
ğ›¿ â‰¥ 0, ğ‘¡ âˆˆ Lğœ™,ğ›¿ (ğœ).

Proof. We actually prove a generalization of the Basic Lemma, which makes the cases of ab-
straction and application easier to handle. We omit the adversary context from the proof, but note
that this extends easily since they must be replaced by closed terms of the appropriate type.

Lemma 3. Let Î; Î“, Î“â€² âŠ¢ ğ‘¡ : ğœ be a well-typed term and ğœ™ a predicate over memories such that
ğœ™ âˆˆ Safe(Eï¬€ (ğœ) \ Î). Assume further that for every (ğ‘¥ : ğœ) âˆˆ Î“â€², Eï¬€ (ğœ) * Eï¬€ (ğœ) and that Î âŠ¢ ğœ‰ is
an instantiation of the context Î. Let also Î“ğœ‰ âŠ¢ ğ›¾, Î“â€²ğœ‰ âŠ¢ ğ›¾ â€² be instantiations of the typing contexts. If
ğ›¾ is such that ğ›¾ (ğ‘¥ğ‘–) âˆˆ Pğœ™,ğ›¿ (ğœğ‘–) for every (ğ‘¥ğ‘– : ğœğ‘– ) âˆˆ Î“, then ğ‘¡ğ›¾ğ›¾ â€² âˆˆ Pğœ™,ğ›¿ (ğœğœ‰).

This can be proven by induction on the typing derivation. We show a few cases, omitting the Î

context when irrelevant.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:34

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

â€¢ Variable. We have Î“, Î“â€² âŠ¢ ğ‘¥ : ğœ, and by assumption, ğ‘¥ cannot be in Î“â€². Therefore, also by

assumption, Jğ‘¥ğ›¾K âˆˆ Lğœ™,ğ›¿ (ğœ).

â€¢ Abstraction. Assume ğœ™ âˆˆ Safe(Eï¬€ (ğœ â†’ ğœ)). If Eï¬€ (ğœ) âŠ† Eï¬€ (ğœ), then also ğœ™ âˆˆ Safe(Eï¬€ (ğœ)).

We apply I.H., and we have that

ğ‘¡ğ›¾ [ğ‘¥ â†¦â†’ ğ‘¢]ğ›¾ â€² âˆˆ Lğœ™,ğ›¿ (ğœ)
for all ğ‘¢ âˆˆ Lğœ™,ğ›¿ (ğœ). Therefore, (ğœ†ğ‘¥ .ğ‘¡)ğ›¾ğ›¾ â€² âˆˆ Lğœ™,ğ›¿ (ğœ, ğœ).
If Eï¬€ (ğœ) * Eï¬€ (ğœ), then by I.H., for all ğ‘¢ : ğœ, ğ‘¡ğ›¾ (ğ›¾ â€²[ğ‘¥ â†¦â†’ ğ‘¢]) âˆˆ Lğœ™,ğ›¿ (ğœ). Therefore, (ğœ†ğ‘¥ .ğ‘¡)ğ›¾ğ›¾ â€² âˆˆ
Lğœ™,ğ›¿ (ğœ, ğœ) too.

â€¢ Application. By I.H., ğ‘¡ğ›¾ğ›¾ â€² âˆˆ Lğœ™,ğ›¿ (ğœ â†’ ğœ). If Eï¬€ (ğœ) âŠ† Eï¬€ (ğœ), then by I.H. we also have
ğ‘¢ğ›¾ğ›¾ â€² âˆˆ Lğœ™,ğ›¿ (ğœ), and therefore by deï¬nition (ğ‘¡ ğ‘¢)ğ›¾ğ›¾ â€² âˆˆ Lğœ™,ğ›¿ (ğœ). Otherwise, by deï¬nition of
the logical predicate we have again (ğ‘¡ ğ‘¢)ğ›¾ğ›¾ â€² âˆˆ Lğœ™,ğ›¿ (ğœ).

â€¢ Unit. WLOG we can assume that Î“â€² = âˆ…. We have that ğœ™ âˆˆ safe(Eï¬€ (TÎ£(ğœ))), so also ğœ™ âˆˆ

safe(Eï¬€ (ğœ))). By I.H., ğ‘¡ğ›¾ âˆˆ Lğœ™,ğ›¿ (ğœ). By the properties of Â¤P :

(unit(ğ‘¡))ğ›¾ âˆˆ Hğœ,0 (ğœ™, âˆ’, v âˆˆ Lğœ™,ğ›¿ (ğœ) âˆ§ ğœ™)

â€¢ Bind. WLOG we can assume that Î“â€² = âˆ…. Our premises are Î“ âŠ¢ ğ‘¡ : TÎ£ (ğœ) and Î“, ğ‘¥ : ğœ âŠ¢
ğ‘¢ : TÎ£â€² (ğœ), and by assumption, Î¦ âˆˆ Safe(Î£ âˆª Î£â€² âˆª Eï¬€ (ğœ) âˆª Eï¬€ (ğœ)). Therefore, Î¦ âˆˆ Safe(Î£ âˆª
Eï¬€ (ğœ)) and Î¦ âˆˆ Safe(Î£â€² âˆª Eï¬€ (ğœ)). So we can apply I.H. to both premises. For the ï¬rst one,
we have that

and for the second one, we have that for all ğ‘’ âˆˆ Lğœ™,ğ›¿ (ğœ),

ğ‘¡ğ›¾ âˆˆ Hğœ,ğ‘˜ğ›¿ (ğœ™, âˆ’, v âˆˆ Lğœ™,ğ›¿ (ğœ) âˆ§ ğœ™)

ğ‘¢ğ›¾ [ğ‘¥ â†¦â†’ ğ‘’] âˆˆ Hğœ,ğ‘˜â€²ğ›¿ (ğœ™, âˆ’, v âˆˆ Lğœ™,ğ›¿ (ğœ) âˆ§ ğœ™)

By properties of the lifting, we get

(let ğ‘¥ = ğ‘¡ in ğ‘¢)ğ›¾ âˆˆ Hğœ,(ğ‘˜+ğ‘˜â€²)ğ›¿ (ğœ™, âˆ’, v âˆˆ Lğœ™,ğ›¿ (ğœ) âˆ§ ğœ™)

â€¢ Forall introduction. By assumption, Î, ğ›¼; Î“ âŠ¢ ğ‘¡ : ğœ, and ğœ™ âˆˆ Safe(Eï¬€ (âˆ€ğ›¼.ğœ) \ Î), so ğœ™ âˆˆ
Safe(Eï¬€ (ğœ) \ (Î âˆª ğ›¼)). For all Î âŠ¢ ğœ‰ and Î£, by I.H., ğ‘¡ğ›¾ âˆˆ Lğœ™,ğ›¿ (ğœğœ‰ [ğ›¼ â†¦â†’ Î£]), and therefore
(Î›ğ›¼.ğ‘¡)ğ›¾ âˆˆ Lğœ™,ğ›¿ (âˆ€ğ›¼.ğœ).

â€¢ Forall elimination. By assumption, Î; Î“ âŠ¢ ğ‘¡ : âˆ€ğ›¼.ğœ and ğœ™ âˆˆ Safe(Eï¬€ (ğœ [Î£/ğ›¼]) \ Î). Recall that
Eï¬€ (âˆ€ğ›¼.ğœ) = Eï¬€ (ğœ [âˆ…/ğ›¼]). Since Eï¬€ (ğœ [âˆ…/ğ›¼]) âŠ† Eï¬€ (ğœ [Î£/ğ›¼])\Î, then also ğœ™ âˆˆ Safe(Eï¬€ (âˆ€ğ›¼.ğœ)\
Î) (in other words, if the eï¬€ect is smaller, then the predicate is still safe). Therefore, we can
apply I.H., and we get that for Î âŠ¢ ğœ‰ ğ‘¡ğ›¾ âˆˆ Lğœ™,ğ›¿ (âˆ€ğ›¼.ğœğœ‰). From this, we can conclude that
ğ‘¡ [Î£]ğ›¾ âˆˆ Lğœ™,ğ›¿ (ğœ [Î£/ğ›¼]ğœ‰).

And from this, we can conclude:

Corollary 1. The [ADV âˆ’ U] rule is sound.

Proof. By the premise on A, safety of ğœ™ and the Basic Lemma, we can prove that

On the other hand, by the assumption on the oracle we have that:

A âˆˆ Lğœ™,ğ›¿ (âˆ€ğ›¼.(ğœ â†’ Tğ›¼,1(ğœ)) â†’ TÎ£âˆªğ›¼,ğ‘˜ (ğœ â€²))

From this, we can derive:

ğœ†ğ‘¥ .ğ‘¡ âˆˆ Lğœ™,ğ›¿ (ğœ â†’ TÎ£â€²,1 (ğœ))

A [Î£â€²] (ğœ†ğ‘¥ .ğ‘¡) âˆˆ Lğœ™,ğ›¿ (TÎ£âˆªÎ£â€²,ğ‘˜ (ğœ â€²))

and the conclusion follows directly.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

(cid:3)

(cid:3)

Higher-order probabilistic adversarial computations

93:35

Soundness of the [ADV âˆ’ R] rule
We generalize the logical predicates to the relational case. For an invariant s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğœ™ and
ğ›¿ âˆˆ [0, âˆ] we deï¬ne a logical relation, i.e., a map from a type ğœ to pairs of closed terms of type ğœ
as follows:

Rğœ™,ğ›¿ (ğµ) , {ğ‘1, ğ‘2 : ğµ | ğ‘1 = ğ‘2}

Rğœ™,ğ›¿ (ğœ â†’ ğœ) ,

Rğœ™,ğ›¿ (ğœ Ã— ğœ) ,

âˆ€ğ‘¢1, ğ‘¢2 : ğœ.(ğ‘¢1, ğ‘¢2) âˆˆ Rğœ™,ğ›¿ (ğœ)
â‡’ (ğ‘¡1 ğ‘¢1, ğ‘¡2 ğ‘¢2) âˆˆ Rğœ™,ğ›¿ (ğœ)

ğ‘¡1, ğ‘¡2 : ğœ â†’ ğœ
(cid:12)
(
(cid:12)
(cid:12)
{ğ‘¡1, ğ‘¡2 : ğœ â†’ ğœ | âˆ€ğ‘¢1, ğ‘¢2 : ğœ.(ğ‘¡1 ğ‘¢1, ğ‘¡2 ğ‘¢2) âˆˆ Rğœ™,ğ›¿ (ğœ)}
(cid:12)
(cid:12)
(ğœ‹1 (ğ‘¡1), ğœ‹1 (ğ‘¡2)) âˆˆ Rğœ™,ğ›¿ (ğœ)
âˆ§ (ğœ‹2(ğ‘¡1), ğœ‹2(ğ‘¡2)) âˆˆ Rğœ™,ğ›¿ (ğœ)

ï£±ï£´ï£´ï£´ï£²
ï£´ï£´ï£´
ğ‘¡1, ğ‘¡2 : ğœ Ã— ğœ
ï£³
(cid:26)

)

(cid:27)

Rğœ™,ğ›¿ (TÎ£,ğ‘˜ (ğœ)) , {ğ‘¡1, ğ‘¡2 : TÎ£,ğ‘˜ (ğœ) | Hğœ,ğ‘˜ğ›¿ (ğœ™, ğ‘¡1, ğ‘¡2, (v1, v2) âˆˆ Rğœ™,ğ›¿ (ğœ) âˆ§ ğœ™)}

Rğœ™,ğ›¿ (âˆ€ğ›¼.ğœ) , {ğ‘¡1, ğ‘¡2 : âˆ€ğ›¼.ğœ | âˆ€Î£.(ğ‘¡1 [Î£], ğ‘¡2 [Î£]) âˆˆ Rğœ™,ğ›¿ (ğœ [Î£/ğ›¼])}

(cid:12)
(cid:12)
(cid:12)
(cid:12)

if Eï¬€ (ğœ) âŠ† Eï¬€ (ğœ)

otherwise

The deï¬nition is analogous to the unary case. Note that the relation at the base types changes, we
now require equality to ensure that the computations have the same control ï¬‚ow. We state now
the Basic Lemma:

Lemma 4 (Basic lemma). Let Â¥P be as above, and assume that for every ğœˆ âˆˆ D, (sample(ğœˆ), sample(ğœˆ)) âˆˆ
(0,0) (Rğœ™,ğ›¿ (ğµ)). Let âŠ¢ ğ‘¡ : ğœ be a closed term and s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğœ™ such that ğœ™ âˆˆ RSafe(Eï¬€ (ğœ)). Then,

Â¥P dp
for all ğœ–, ğ›¿ â‰¥ 0, (ğ‘¡, ğ‘¡) âˆˆ Rğœ™,ğ›¿ (ğœ)

Proof. The proof is very similar to the unary case, by ï¬rst stating a generalization and then
(cid:3)

proving it by induction on the typing judgment.

By instantiating the Basic Lemma at the type of adversaries, we get the following:

Corollary 2. The [ADV âˆ’ R] rule is sound.

D ADDITIONAL EXAMPLES

D.1 Example: Accuracy for diï¬€erentially private mechanisms
Diï¬€erential privacy [Dwork and Roth 2014] is a family of techniques focused on preventing queries
from databases from revealing private data about the entries in the database. Concretely, we want
to have plausible deniability that a concrete entry is in the database. This is usually achieved by
making the queries through a mechanism, an algorithm that adds randomness to the output of
the queries before releasing them. Privacy comes with the tradeoï¬€ of accuracy; the randomness
that diï¬€erentially private mechanisms add means that the result of the query cannot be exact.
Nonetheless, we can often give bounds about how large the error can be.

In this example we will verify an accuracy bound for a diï¬€erentially private mechanism known
as Sparse Vector (SV) algorithm. This algorithm is used to make ğ‘˜ numerical queries (i.e., queries
whose output is a number) to a database, and answering for how many of them the result is above
some threshold ğ‘‡ . It can also be modelled in an online manner [Barthe et al. 2016b], in which an
adversary makes the queries one by one and observes the result (whether it is above or below the
threshold) before deciding which query to make next.

As in many diï¬€erentially private mechanisms, the randomness in the SV algorithm comes from

a Laplace distribution, which has the following rule:

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:36

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

Î“ | Î¨ âŠ¢ ğ‘¡ : R

Î“ | Î¨ âŠ¢ {ğ‘ƒ }Lapğœ– (ğ‘¡) : Tâˆ…,0 (R){{ğ‘ƒ âˆ§ |v âˆ’ ğ‘¡ | â‰¤

LAP-UBL

1
ğœ–

log

1
ğ›¿

}}ğ›¿

What this rule is saying is: (1) sampling does not change the state, and (2) with probability 1 âˆ’ğ›¿,

the value sampled from Lapğœ– (ğ‘¡) will be within an interval of radius
words, it tells us how accurate it is to replace ğ‘¡ by Lapğœ– (ğ‘¡).

1
ğœ–

1
ğ›¿

log

centered at ğ‘¡. In other

We model the SV algorithm by having an oracle that provides access to the database. The codes

of the oracle and the main algorithm are given below:

O(ğ‘ : R â†’ R) :
ğ‘¥ = evalQ (ğ‘);
let ğ‘¦ = Lapğœ–/4(ğ‘¥) in
let ğ‘¡ â€² = read ğ‘¡ in
ğ‘§ = if ğ‘¦ â‰¥ ğ‘¡ â€² then tt else ï¬€;
ğ‘[ğ‘Ÿ ] := ğ‘§;
ğ‘ [ğ‘Ÿ ] := ğ‘¥;
inc ğ‘Ÿ ;
unit(ğ‘§);

mainSV(ğ‘‡ : R) :

let ğ‘¥ = Lapğœ–/2(ğ‘‡ ) in
ğ‘¡ := ğ‘¥;
ğ‘Ÿ := 0;
A(O);

The oracle runs the query ğ‘, adds Laplace noise to its result, checks whether it is above the
threshold ğ‘¡, and returns its result to the adversary. For the veriï¬cation process, we add some ghost
variables: ğ‘Ÿ records the round number, ğ‘ is an array containing the noiseless result of the queries,
and ğ‘ records whether the noisy queries are above the threshold.

In the main procedure, we simply initialize the ğ‘¡ variable by adding noise to the threshold ğ‘‡ , set
the auxiliary variables to 0 and then instantiate the adversary with the oracle O. We want to show
the following accuracy bound

âŠ¢ {âŠ¤}mainSV(ğ‘‡ ) : T{ğ‘,ğ‘,ğ‘Ÿ,ğ‘¡ },1(R){{âˆ€ğ‘– â‰¤ ğ‘˜.Î¦(ğ‘–)}}ğ›½

where Î¦ is deï¬ned as:

Î¦(ğ‘–) , (s[ğ‘[ğ‘–]] = tt â‡’ s[ğ‘ [ğ‘–]] â‰¥ ğ‘‡ âˆ’

6
ğœ–

log

ğ‘˜ + 1
ğ›½

) âˆ§ (s[ğ‘[ğ‘–]] = ï¬€ â‡’ s[ğ‘ [ğ‘–]] â‰¤ ğ‘‡ +

6
ğœ–

log

ğ‘˜ + 1
ğ›½

)

For this, we will use the adversary rule, with the invariant:

Î¦â€²( ğ‘— ) = |ğ‘‡ âˆ’ s[ğ‘¡] | â‰¤

2
ğœ–

log

ğ‘˜ + 1
ğ›½

âˆ§ âˆ€ğ‘– â‰¤ ğ‘— .Î¦(ğ‘–)

The ï¬rst part of the invariant states how close the noisy threshold is to the original threshold ğ‘‡ ,
while the second part states an accuracy bound on the ï¬rst ğ‘— queries. The key part of the proof is
showing that O preserves the invariant for any query, that is:

âŠ¢ {Î¦â€²(ğ‘Ÿ )}O(ğ‘){{Î¦â€²(ğ‘Ÿ )}}ğ›½/(ğ‘˜+1)

We will ellaborate further on this part of the proof. We go backwards from the end of the procedure,
and we will use the notation âŒŠO(ğ‘)âŒ‹ğ‘› to denote the program formed by the ï¬rst ğ‘› instructions of
O(ğ‘). Since the last instruction is ğ‘Ÿ := ğ‘Ÿ + 1, we can apply the [WRITE] rule, and we need to show

âŠ¢ {Î¦â€²(ğ‘Ÿ )}âŒŠO(ğ‘)âŒ‹5{{|ğ‘‡ âˆ’ s[ğ‘¡] | â‰¤

2
ğœ–

log

ğ‘˜ + 1
ğ›½

âˆ§ âˆ€ğ‘– â‰¤ ğ‘Ÿ + 1.Î¦(ğ‘–)}}ğ›½/(ğ‘˜+1)

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:37

Since our precondition contains already âˆ€ğ‘– â‰¤ ğ‘Ÿ .Î¦(ğ‘–) and ğ‘¡ does not change, the only interesting
part is proving Î¦(ğ‘Ÿ + 1) (the other cases can be proven by using [AND âˆ’ POST âˆ’ U]). By applying
[WRITE] again and then [CASE], it is suï¬ƒcient to show:

âŠ¢ {Î¦â€²(ğ‘Ÿ )}âŒŠO(ğ‘)âŒ‹2{{(v â‰¥ s[ğ‘¡] âˆ§ ğ‘¥ â‰¥ ğ‘‡ âˆ’

6
ğœ–

log

ğ‘˜ + 1
ğ›½

) âˆ¨ (v < s[ğ‘¡] âˆ§ ğ‘¥ â‰¤ ğ‘‡ +

6
ğœ–

log

ğ‘˜ + 1
ğ›½

)}}ğ›½/(ğ‘˜+1)

Now we can apply the [LAP âˆ’ UBL] rule setting ğ›¿ to ğ›½/(ğ‘˜ + 1). By computation, we can see that

and

|v âˆ’ ğ‘¥ | â‰¤

|v âˆ’ ğ‘¥ | â‰¤

4
ğœ–

4
ğœ–

log

ğ‘˜ + 1
ğ›½

log

ğ‘˜ + 1
ğ›½

and this completes the proof.

âˆ§ v â‰¥ s[ğ‘¡] âˆ§ |ğ‘‡ âˆ’ s[ğ‘¡] | â‰¤

âˆ§ v < s[ğ‘¡] âˆ§ |ğ‘‡ âˆ’ s[ğ‘¡] | â‰¤

2
ğœ–

2
ğœ–

log

ğ‘˜ + 1
ğ›½

â‡’ ğ‘¥ â‰¥ ğ‘‡ âˆ’

log

ğ‘˜ + 1
ğ›½

â‡’ ğ‘¥ â‰¤ ğ‘‡ +

6
ğœ–

6
ğœ–

log

ğ‘˜ + 1
ğ›½

log

ğ‘˜ + 1
ğ›½

E QUASI-BOREL SPACES

Quasi-borel spaces are deï¬ned as follows:

Definition 5. A quasi-Borel space is a pair (ğ‘‹, ğ‘€ğ‘‹ ) of a set ğ‘‹ and a set ğ‘€ğ‘‹ âŠ† R â†’ ğ‘‹ satisfying

the following closure properties:

(1) If ğ›¼ : R â†’ ğ‘‹ is constant, then ğ›¼ âˆˆ ğ‘€ğ‘‹ .
(2) If ğ›¼ âˆˆ ğ‘€ğ‘‹ and ğ‘“ : R â†’ R is (Borel) measurable, then ğ›¼ â—¦ ğ‘“ âˆˆ ğ‘€ğ‘‹ .
(3) If ğ‘† : R â†’ N (Borel) measurable and {ğ›¼ğ‘– }ğ‘– âˆˆN âŠ† ğ‘€ğ‘‹ then ğœ†ğ‘Ÿ .ğ›¼ğ‘† (ğ‘Ÿ ) (ğ‘Ÿ ) âˆˆ ğ‘€ğ‘‹ .

A morphism between quasi-Borel spaces (ğ‘‹, ğ‘€ğ‘‹ ) and (ğ‘Œ , ğ‘€ğ‘Œ ) is a function ğ‘“ : ğ‘‹ â†’ ğ‘Œ such that for
every ğ›¼ âˆˆ ğ‘€ğ‘‹ , ğ‘“ â—¦ ğ›¼ âˆˆ ğ‘€ğ‘Œ . Quasi-Borel spaces and morphisms between them form a category QBS.

Lemma 5. For each standard Borel space ğ´, (ğ´, Meas(R, ğ´)) is a QBS.

There is a strong monad for probabilistic choices. We ï¬rst deï¬ne the concept of probability

measures on QBSs.

Definition 6. Let (ğ‘‹, ğ‘€ğ‘‹ ) be a quasi-Borel space. A (probability) measure over (ğ‘‹, ğ‘€ğ‘‹ ) is a
tuple (ğ´, Î£ğ´, ğ›¼, ğœ‡) where (ğ´, Î£ğ´) is a standard Borel space, ğ›¼ âˆˆ QBS(ğ‘, ğ‘‹ ) is a morphism and ğœ‡
is a (probability) measure over (ğ´, Î£ğ´). We can deï¬ne an equivalence relation between (probability)
measures when they deï¬ne the same integration operator:

(ğ´, Î£ğ´, ğ›¼, ğœ‡) â‰¡ (ğ´â€², ğ›¼ â€², ğœ‡â€²) â‡â‡’ âˆ€ğ‘“ âˆˆ QBS(ğ‘‹, R),

(ğ‘“ â—¦ ğ›¼)ğ‘‘ğœ‡ =

âˆ«ğ´
Definition 7. The probability monad on QBS is deï¬ned by

(ğ‘“ â—¦ ğ›¼ â€²)ğ‘‘ğœ‡â€²

âˆ«ğ´â€²

P (ğ‘‹ ) , {(ğ´, ğ›¼, ğœ‡) probability measure over ğ‘‹ }/â‰¡
ğ‘€P (ğ‘‹ ) , {ğœ†ğ‘Ÿ .[ğ·ğ‘Ÿ , ğ›¼ (ğ‘Ÿ , âˆ’), ğœ‡ğ‘Ÿ ] | ğœ‡ ğœ-ï¬nite, ğ· âŠ† R Ã— ğ´ measurable, ğ›¼ âˆˆ QBS(ğ·, ğ‘‹ )}

where ğ·ğ‘Ÿ = {ğœ” | (ğ‘Ÿ , ğœ”) âˆˆ ğ· }. The unit and Kleisli lifting are also deï¬ned by
ğœ‚ğ‘‹ (ğ‘¥) , ({âˆ—}, ğœ†ğ‘¦.ğ‘¥, ğ›¿) where
ğ‘“ # (ğ´, ğ›¼, ğœ‡) , [ğ·, ğ›½, (ğœ‡ âŠ— ğœ‡â€²)|ğ· ] where

ğ›¿ ({âˆ—}) = 1.

(ğ‘“ âˆˆ QBS(ğ‘‹, P (ğ‘Œ )))

where ğ‘“ (ğ›¼ (ğ‘Ÿ )) = [ğ·ğ‘Ÿ , ğ›½ (ğ‘Ÿ , âˆ’), ğœ‡â€²], and âŠ— computes the product measure.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:38

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

E.1 The Interpretation of Non-Monadic Part of the Language
First some preparations. We write ğ‘‘ğ´,ğ‘‹ : (ğ´ Â· 1) Ã— ğ‘‹ â†’ ğ´ Â· ğ‘‹ for the canonical isomorphism. This
exists because QBS is a bi-CCC. Let zero0 , ğœ„0,1
]ğ‘– âˆˆğ¾ : ğ¾ Â· 1 â†’
0
(ğ¾ + 1) Â· 1. The interpretation of the non-monadic part of the language is given as follows. Note
that this is an induction on the derivation of Î“ âŠ¢ ğ‘¡ : ğœ; the last rule is the case of the subtyping rule.

: 1 â†’ 0 Â· 1 and succğ¾ , [ğœ„ğ¾+1,1

ğ‘–+1

Î“
JÎ“ âŠ¢ ğ‘¥ : ğœK , ğœ‹
ğ‘¥
JÎ“ âŠ¢ â˜…: UK , !JÎ“K

JÎ“ âŠ¢ 0 : N[0]K , zero0 â—¦ !JÎ“K

(ğ‘¥ âˆˆ dom(Î“))

JÎ“ âŠ¢ ğ‘† ğ‘¡ : N[ğ¾ + 1]K , succğ¾ â—¦ JÎ“ âŠ¢ ğ‘¡ : N[ğ¾]K
JÎ“ âŠ¢ ğœ†ğ‘¥ .ğ‘¡ : ğœ â†’ ğœK , ğœ†(JÎ“, ğ‘¥ : ğœ âŠ¢ ğ‘¡ : ğœK â—¦ ğ‘šÎ“,ğ‘¥:ğœ )

JÎ“ âŠ¢ ğ‘¡ ğ‘¢ : ğœK , ev â—¦ hJÎ“ âŠ¢ ğ‘¡ : ğœ â†’ ğœK, JÎ“ âŠ¢ ğ‘¢ : ğœKi

JÎ“ âŠ¢ hğ‘¡, ğ‘¢i : ğœ Ã— ğœK , hJÎ“ âŠ¢ ğ‘¡ : ğœK, JÎ“ âŠ¢ ğ‘¢ : ğœKi

JÎ“ âŠ¢ if ğ‘ then ğ‘¡1 else ğ‘¡2 : ğœK , [JÎ“ âŠ¢ ğ‘¡1 : ğœK, JÎ“ âŠ¢ ğ‘¡2 : ğœK] â—¦ ğ‘‘JÎ“K,1 â—¦ hJÎ“ âŠ¢ ğ‘ : BK, ğ‘–ğ‘‘JÎ“Ki

JÎ“ âŠ¢ ğœ‹ğ‘– (ğ‘¡) : ğœğ‘– K , ğœ‹ğ‘– â—¦ JÎ“ âŠ¢ ğ‘¡ : ğœ1 Ã— ğœ2K
JÎ“ âŠ¢ ğ‘¡ : âˆ€ğ›¼.ğœK = JÎ“ âŠ¢ ğ‘¡ : ğœK
JÎ“ âŠ¢ ğ‘¡ : ğœ [Î£/ğ›¼]K = JÎ“ âŠ¢ ğ‘¡ : âˆ€ğ›¼.ğœK

(ğ‘– = 1, 2)

JÎ“ âŠ¢ ğ‘¡ : ğœK = ğ‘ğœâ€²,ğœ â—¦ JÎ“ âŠ¢ ğ‘¡ : ğœ â€²K

(ğœ â€² (cid:22) ğœ)

The rules Adv and Adv-Inst are not interpreted, as adversaries will be instantiated by closed terms.

E.2 Logic

Semantics of the logic is deï¬ned inductively by:

JÎ“ âŠ¢ âŠ¤K , âŠ¤
JÎ“ âŠ¢ âŠ¥K , âŠ¥

JÎ“ âŠ¢ ğ‘ƒ (ğ‘¡1, . . . , ğ‘¡ğ‘˜ )K , (JÎ“ âŠ¢ ğ‘¡1 : ğœ1K Ã— Â· Â· Â· Ã— JÎ“ âŠ¢ ğ‘¡ğ‘˜ : ğœğ‘˜K)âˆ—Jğ‘ƒK

JÎ“ âŠ¢ ğœ™ âˆ§ ğœ“ K , JÎ“ âŠ¢ ğœ™K âŠ“ JÎ“ âŠ¢ ğœ“ K
JÎ“ âŠ¢ ğœ™ âˆ¨ ğœ“ K , JÎ“ âŠ¢ ğœ™K âŠ” JÎ“ âŠ¢ ğœ“ K
JÎ“ âŠ¢ ğœ™ â‡’ ğœ“ K , JÎ“ âŠ¢ ğœ™K â‡› JÎ“ âŠ¢ ğœ“ K

JÎ“ âŠ¢ âˆ€(ğ‘¥ : ğœ).ğœ™K , âˆ€JÎ“K,JğœK (ğ‘šâˆ—

Î“,ğ‘¥:ğœ JÎ“, ğ‘¥ : ğœ âŠ¢ ğœ™K)

where the interpretation Jğ‘ƒK for each base predicate ğ‘ƒ : ğœ1 Ã— Â· Â· Â· Ã— ğœğ‘˜ is a chosen element in
UP2

Jğœ1Ã—Â·Â·Â·Ã—ğœğ‘˜ K.

E.3 Graded Lifting for Union Bound in Example 6.2
We show that Â¤P ub is indeeed a 2-valued strong ( [0, âˆ], â‰¤, +, 0)-graded lifting Â¤P ub of P.

(1) We show ğ‘ƒ (ğ‘¦) = âŠ¤ =â‡’ Â¤P ub

ğ‘‹ (0) (ğ‘ƒ) (ğœ‚ P

ğ‘‹ (ğ‘¦)) = âŠ¤. For all ğ‘“ âˆˆ QBS(ğ‘‹, ğ· {0, 1}) such that

ğ‘ƒ âŠ‘ |ğ‘“ |, we have ğ‘“ (ğ‘¦) = 1, hence Prğ‘¥âˆ¼ğœ‚P (ğ‘¦) [ğ‘“ (ğ‘¥) = 1] = 1.

(2) Let Î âˆˆ PPğ‘‹ . We show Â¤P ub

Pğ‘‹ (ğ›¿1) ( Â¤P ub

ğ‘‹ (ğ›¿2) (ğ‘ƒ)) (Î) = âŠ¤ =â‡’ Â¤P ub

ğ‘‹ (ğ›¿1 + ğ›¿2) (ğ‘ƒ) (ğœ‡ P (Î)) = âŠ¤.

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:39

For all ğ‘“ âˆˆ QBS(ğ‘‹, ğ· {0, 1}) such that ğ‘ƒ âŠ‘ |ğ‘“ |, We have Â¤P ub

ğ‘‹ (ğ›¿2) (ğ‘ƒ) âŠ‘ Â¤P ub

ğ‘‹ (ğ›¿2) (|ğ‘“ |).

âŠ¤ = Â¤P ub
âŠ‘ Â¤P ub
= Â¤P ub

ğ‘‹ (ğ›¿2) (ğ‘ƒ)) (Î)
ğ‘‹ (ğ›¿2) (|ğ‘“ |)) (Î)

Pğ‘‹ (ğ›¿1) ( Â¤P ub
Pğ‘‹ (ğ›¿1) ( Â¤P ub
Pğ‘‹ (ğ›¿1) (ğœ†ğœˆ . Pr
ğ‘¥âˆ¼ğœˆ
= âˆ€ğ‘” âˆˆ QBS(P (ğ‘‹ ), ğ· {0, 1}), (ğœ†ğœˆ . Pr
ğ‘¥âˆ¼ğœˆ

[ğ‘“ (ğ‘¥) = 1] â‰¥ 1 âˆ’ ğ›¿2) (Î)

[ğ‘“ (ğ‘¥) = 1] â‰¥ 1 âˆ’ ğ›¿2) âŠ‘ |ğ‘“ | . Pr
ğœˆâˆ¼Î

[ğ‘”(ğœˆ) = 1] â‰¥ 1 âˆ’ ğ›¿1

= Pr
ğœˆâˆ¼Î

[ Pr
ğ‘¥âˆ¼ğœˆ

[ğ‘“ (ğ‘¥) = 1] â‰¥ 1 âˆ’ ğ›¿2] â‰¥ 1 âˆ’ ğ›¿1

{ Markovâ€™s inequality (it holds for probability measures on quasi-Borel spaces). }

Eğœˆâˆ¼Î [Prğ‘¥âˆ¼ğœˆ [ğ‘“ (ğ‘¥) = 1]] â‰¥ (1 âˆ’ ğ›¿1) (1 âˆ’ ğ›¿2)
1 â‰¥ 1 âˆ’ ğ›¿1

âŠ‘

(

ğ›¿1 < 1 âˆ§ ğ›¿2 < 1
otherwise

[ğ‘“ (ğ‘¥) = 1]] â‰¥ 1 âˆ’ ğ›¿1 âˆ’ ğ›¿2

âŠ‘ Eğœˆâˆ¼Î[ Pr
ğ‘¥âˆ¼ğœˆ
[ğ‘“ (ğ‘¥) = 1] â‰¥ 1 âˆ’ ğ›¿1 âˆ’ ğ›¿2.

=

Pr
ğ‘‹ (Î)
ğ‘¥âˆ¼ğœ‡ P

(3) Let ğ‘¥ âˆˆ ğ‘‹ and ğœ‡ âˆˆ Pğ‘Œ . If ğ‘ƒ (ğ‘¥) = âŠ¤ and Â¤P ub
have âˆ€ğ‘“ âˆˆ QBS(ğ‘Œ , ğ· {0, 1}), ğ‘„ âŠ‘ |ğ‘“ | . Prğ‘¥âˆ¼ğœˆ [ğ‘“ (ğ‘¥) = 1] â‰¥ 1 âˆ’ ğ›¿

ğ‘Œ (ğ›¿) (ğ‘„) (ğœ‡) = âŠ¤ then Â¤P ub

ğ‘Œ (ğ›¿) (ğ‘ƒ Â¤Ã—ğ‘„) (ğœƒ P (ğ‘¥, ğœ‡)). We

Here, for any ğ‘” âˆˆ QBS(ğ‘‹ Ã— ğ‘Œ , ğ· {0, 1}) such that ğ‘ƒ Â¤Ã—ğ‘„ âŠ‘ |ğ‘”|, ğ‘”(ğ‘¥, âˆ’) : ğ‘Œ â†’ ğ· {0, 1} satisfy

ğ‘„ âŠ‘ ğ‘”(ğ‘¥, âˆ’). This is a speciï¬c property of the case of Î© = 2.

Hence,

âŠ¤ = Â¤P ub

ğ‘Œ (ğ›¿) (ğ‘„) (ğœ‡)

= âˆ€ğ‘“ âˆˆ QBS(ğ‘Œ , ğ· {0, 1}), ğ‘„ âŠ‘ |ğ‘“ | . Pr
ğ‘¥âˆ¼ğœ‡

[ğ‘“ (ğ‘¥) = 1] â‰¥ 1 âˆ’ ğ›¿

âŠ‘ âˆ€ğ‘” âˆˆ QBS(ğ‘‹ Ã— ğ‘Œ , ğ· {0, 1}), ğ‘ƒ Â¤Ã—ğ‘„ âŠ‘ |ğ‘”| . Pr
ğ‘¦â€²âˆ¼ğœ‡

[ğ‘”(ğ‘¥, ğ‘¦â€²) = 1] â‰¥ 1 âˆ’ ğ›¿

{Fubini theorem (coherence property of strength ğœƒ P)}

= âˆ€ğ‘” âˆˆ QBS(ğ‘‹ Ã— ğ‘Œ , ğ· {0, 1}), ğ‘ƒ Â¤Ã—ğ‘„ âŠ‘ |ğ‘”| .

Pr
(ğ‘¥ â€²,ğ‘¦â€²)âˆ¼(ğœƒ P (ğ‘¥,ğœ‡)

[ğ‘”(ğ‘¥, ğ‘¦) = 1] â‰¥ 1 âˆ’ ğ›¿

= Â¤P ub

ğ‘Œ (ğ›¿) (ğ‘ƒ Â¤Ã—ğ‘„) (ğœƒ P (ğ‘¥, ğœ‡))
(4) It is obvious that ğ›¿ â‰¤ ğ›¿ â€² =â‡’ Â¤P ub

ğ‘‹ (ğ›¿) (ğ‘ƒ) (ğœˆ) âŠ‘ Â¤P ub

ğ‘‹ (ğ›¿ â€²) (ğ‘ƒ) (ğœˆ) holds by deï¬nition of Â¤P ub.

E.4 Graded Lifting for Diï¬€erential privacy in Example 6.6
We show that Â¤P dp is a 2-valued strong ( [0, âˆ], +, 0, â‰¤)2-graded relational lifting of P.

(1) Assume (ğ‘¥, ğ‘¦) |= ğ‘ƒ. For all (ğ‘“ , ğ‘”) : ğ‘ƒ Â¤â†’ğ‘† (ğœ– â€², ğ›¿ â€²), we have

(ğ‘“ â™¯ğœ‚ P

ğ‘‹ (ğ‘¥), ğ‘”â™¯ğœ‚ P

ğ‘Œ (ğ‘¦)) = (ğ‘“ (ğ‘¥), ğ‘”(ğ‘¦)) |= ğ‘† (ğœ– â€², ğ›¿ â€²).

This implies that Â¤P dp

ğ‘‹,ğ‘Œ (0, 0) (ğ‘ƒ) (ğœ‚ P

ğ‘‹ (ğ‘¥), ğœ‚ P

ğ‘Œ (ğ‘¥)) holds.
ğ‘‹,ğ‘Œ (ğœ–, ğ›¿) (ğ‘ƒ), (ğ‘“ , ğ‘”) : ğ‘ƒ Â¤â†’ Â¤P dp

(2) Consider (ğœˆ1, ğœˆ2) |= Â¤P dp

ğ‘‹ â€²,ğ‘Œ â€² (ğœ– â€², ğ›¿ â€²) (ğ‘„) and (ğ‘˜, ğ‘™) : ğ‘„ Â¤â†’ğ‘† (ğœ– â€²â€², ğ›¿ â€²â€²). Then,
(ğ‘˜â™¯ ğ‘“ (ğ‘¥), ğ‘™ â™¯ğ‘”(ğ‘¦)) |= ğ‘† (ğœ– â€²+ğœ– â€²â€², ğ›¿ â€²+ğ›¿ â€²â€²) holds for all (ğ‘¥, ğ‘¦) |= ğ‘ƒ. Hence, (ğ‘˜â™¯ ğ‘“ , ğ‘™ â™¯ğ‘”) : ğ‘ƒ Â¤â†’ğ‘† (ğœ– â€²+ğœ– â€²â€², ğ›¿ â€²+ğ›¿ â€²â€²).
Hence, (ğ‘˜â™¯ ğ‘“ â™¯, ğ‘™ â™¯ğ‘”â™¯) : Â¤P dp
ğ‘‹,ğ‘Œ (ğœ–, ğ›¿) (ğ‘ƒ) Â¤â†’ğ‘† (ğœ– + ğœ– â€² + ğœ– â€²â€², ğ›¿ + ğ›¿ â€² + ğ›¿ â€²â€²). Hence (ğ‘˜â™¯ ğ‘“ â™¯ğœˆ1, ğ‘™ â™¯ğ‘”â™¯ğœˆ2) |= ğ‘† (ğœ– + ğœ– â€² +
ğœ– â€²â€², ğ›¿ + ğ›¿ â€² + ğ›¿ â€²â€²). Since (ğ‘˜, ğ‘™) is arbitrary, we obtain (ğ‘“ â™¯ğœˆ1, ğ‘”â™¯ğœˆ2) |= Â¤P dp
ğ‘‹ â€²,ğ‘Œ â€² (ğœ– â€² + ğœ– â€²â€², ğ›¿ â€² + ğ›¿ â€²â€²) (ğ‘„). Since
(ğœˆ1, ğœˆ2) is arbitrary we conclude (ğ‘“ â™¯, ğ‘”â™¯) : Â¤P dp

ğ‘‹ â€²,ğ‘Œ â€² (ğœ– â€² + ğœ– â€²â€², ğ›¿ â€² + ğ›¿ â€²â€²) (ğ‘„).

ğ‘‹,ğ‘Œ (ğœ–, ğ›¿) (ğ‘ƒ) Â¤â†’ Â¤P dp

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:40

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

We have (idPğ‘‹ , idPğ‘Œ ) : Â¤P dp
Pğ‘‹ , idâ™¯

ğ‘Œ ) = (idâ™¯

ğ‘‹,ğ‘Œ (ğœ– â€², ğ›¿ â€²) (ğ‘ƒ) Â¤â†’ Â¤P dp
ğ‘‹,ğ‘Œ (ğœ–, ğ›¿) ( Â¤P dp
Pğ‘Œ ) : Â¤P dp

ğ‘‹,ğ‘Œ (ğœ– â€², ğ›¿ â€²) (ğ‘ƒ). Then we have
ğ‘‹,ğ‘Œ (ğœ– â€², ğ›¿ â€²) (ğ‘ƒ)) Â¤â†’ Â¤P dp

ğ‘‹ , ğœ‡ P

(ğœ‡ P

ğ‘‹,ğ‘Œ (ğœ– â€² + ğœ– â€²â€², ğ›¿ â€² + ğ›¿ â€²â€²) (ğ‘ƒ).

(3) Consider (ğ‘¥, ğ‘¦) |= ğ‘ƒ and (ğœˆ1, ğœˆ2) |= Â¤P dp
ğ‘‹ â€²,ğ‘Œ â€² (ğœ–, ğ›¿) (ğ‘„).
For all (ğ‘“ , ğ‘”) : ğ‘ƒ Â¤Ã—ğ‘„ Â¤â†’ğ‘† (ğœ– â€², ğ›¿ â€²), we have (ğ‘“ (ğ‘¥, âˆ’), ğ‘”(ğ‘¦, âˆ’)) : ğ‘„ Â¤â†’ğ‘† (ğœ– â€², ğ›¿ â€²), (it is speciï¬c in the case

of Î© = 2).
Then,

Since ğ‘“ (ğ‘¥, âˆ’)â™¯ (ğœˆ1) = ğ‘“ â™¯ğœƒ P

(ğ‘“ (ğ‘¥, âˆ’)â™¯ (ğœˆ1), ğ‘”(ğ‘¦, âˆ’)â™¯ (ğœˆ2)) |= ğ‘† (ğœ– + ğœ– â€², ğ›¿ + ğ›¿ â€²).
ğ‘‹,ğ‘‹ â€² (ğ‘¥, ğœˆ1) and ğ‘”(ğ‘¦, âˆ’)â™¯ (ğœˆ2) = ğ‘”â™¯ğœƒ P
ğ‘‹,ğ‘‹ â€² (ğ‘¥, ğœˆ1), ğœƒ P
(ğœƒ P

ğ‘Œ,ğ‘Œ â€² (ğ‘¥, ğœˆ2)) |= Â¤P dp

ğ‘Œ,ğ‘Œ â€² (ğ‘¥, ğœˆ2) , we have

ğ‘‹ Ã—ğ‘‹ â€²,ğ‘Œ Ã—ğ‘Œ â€² (ğœ–, ğ›¿) (ğ‘ƒ Â¤Ã—ğ‘„).
ğ‘‹,ğ‘Œ (ğœ–, ğ›¿) (ğ‘ƒ) (ğœˆ1, ğœˆ2) âŠ‘ Â¤P dp

(4) It is obvious that if ğœ– â‰¤ ğœ– â€² and ğ›¿ â‰¤ ğ›¿ â€² then Â¤P dp

ğ‘‹,ğ‘Œ (ğœ– â€², ğ›¿ â€²) (ğ‘ƒ) (ğœˆ1, ğœˆ2).

F PROOFS OF SECTION 6
We begin by formally stating the soundness of HOL:

Theorem F.1 (Soundness of HOL). Let Î“ | Î¨ âŠ¢ ğœ™ be a derivable HOL judgment. Then it is valid,

i.e. JÎ“ âŠ¢

Î¨K âŠ‘ JÎ“ âŠ¢ ğœ™K holds in UP2

JÎ“K.

Proof. The proof is done by the induction on the derivation tree of Î“ | Î¨ âŠ¢ ğœ™. It is almost

Ã“

obvious. We see the rules Ax, â‡’ğ¸ and â‡’ğ¼ .

(Ax) A judgment of the form Î“ | Î¨, ğœ™ âŠ¢ ğœ™ is always valid:

([Î“ âŠ¢

(Î¨, ğœ™)]) = ([Î“ âŠ¢ (

Î¨) âˆ§ ğœ™]) = ([Î“ âŠ¢

Î¨]) âˆ© ([Î“ âŠ¢ ğœ™]) âŠ† ([Î“ âŠ¢ ğœ™]).

(â‡’ğ¼ ) Suppose that the judgment Î“ | Î¨, ğœ™1 âŠ¢ ğœ™2 is derivable. By induction hypoithesis, it is valid.

Ã›

Ã›

Ã›
Then we have ([Î“ âŠ¢

Î¨]) âˆ© ([Î“ âŠ¢ ğœ™1]) âŠ† ([Î“ âŠ¢ ğœ™2]). This implies

([Î“ âŠ¢
Ã“

Î¨]) âŠ† (|JÎ“K| \ ([Î“ âŠ¢ ğœ™1])) âˆª ([Î“ âŠ¢ ğœ™2]) = ([Î“ âŠ¢ ğœ™1 â‡’ ğœ™2]).

(â‡’ğ¸) Suppose that the judgments Î“ | Î¨ âŠ¢ ğœ™1 â‡’ ğœ™2 and Î“ | Î¨ âŠ¢ ğœ™1 are derivable. By induction
Î¨]) âŠ† ([Î“ âŠ¢ ğœ™1 â‡’ ğœ™2]) = |JÎ“K| \ ([Î“ âŠ¢ ğœ™1]) âˆª ([Î“ âŠ¢ ğœ™2])

Ã›

hypoithesis, they are valid. We have ([Î“ âŠ¢
and ([Î“ âŠ¢

Î¨]) âŠ† ([Î“ âŠ¢ ğœ™1]). We have
([Î“ âŠ¢

Ã“

Ã“

Î¨]) âŠ† (|JÎ“K| \ ([Î“ âŠ¢ ğœ™1]) âˆª ([Î“ âŠ¢ ğœ™2])) âˆ© ([Î“ âŠ¢ ğœ™1]) âŠ† ([Î“ âŠ¢ ğœ™2]).

Ã›

(cid:3)

A judgment in UHOL can be seen a pair of a typing judgment and a logical judgment that
contains an extra distinguished variable r referring to the typed term. With this in mind, we show:
Theorem F.2 (Soundness of UHOL). Let Î“ | Î¨ âŠ¢ ğ‘¡ : ğœ {ğœ™ } be a derivable UHOL judgment. Then,
Î¨K implies JÎ“ âŠ¢ ğ‘¡ : ğœK(ğ›¾) |= JÎ“, r : ğœ âŠ¢ ğœ™Kğ›¾ .

for any ğ›¾ âˆˆ |JÎ“K|, ğ›¾ |= JÎ“ âŠ¢

Now we prove soundness of HO-UBL. We recall here the statement:
Proposition. Let Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡ : TÎ£,ğ‘˜ (ğœ){{ğ‘„ }}ğ›¿ be a derivable HO-UBL judgment without the

Ã“

adversary rule. Then, for any ğ›¾ âˆˆ |JÎ“K|, ğ›¾ |= JÎ“ âŠ¢

Î¨K implies

JÎ“ âŠ¢ ğ‘¡ : TÎ£,ğ‘˜ (ğœ)K(ğ›¾) |= Â¤P ub Â¤S(ğ›¿) (JÎ“, s : M âŠ¢ ğ‘ƒKğ›¾ , JÎ“, v : ğœ, s : M âŠ¢ ğ‘„Kğ›¾ ).
Ã“
Proof of Proposition 6.4. In this proof we simply write Â¤P Â¤S for Â¤P ub Â¤S. The proof is by induction

on the derivation. We show the more interesting cases:

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:41

â€¢ Unit. By soundness of non-monadic HO-UBL, we have that

ğ›¾ |= JÎ“ âŠ¢

Î¨K â‡’ JÎ“ âŠ¢ ğ‘¡ : ğœK(ğ›¾) |= JÎ“, r : ğœ âŠ¢ ğœ™Kğ›¾

Now consider an arbitrary Î“, s : M âŠ¢ ğ‘ƒ. By deï¬nition, JÎ“ âŠ¢ unit(ğ‘¡) : TÎ£,ğ‘˜ (ğœ)K(ğ›¾) = ğœ‚ P S â—¦JÎ“ âŠ¢
ğ‘¡ : ğœK(ğ›¾). By Lemma 1 we conclude that

Ã›

ğœ‚ P S â—¦ JÎ“ âŠ¢ ğ‘¡ : ğœK(ğ›¾) |= Â¤P Â¤SJğœK(0) (JÎ“, s : M âŠ¢ ğ‘ƒKğ›¾ , ğ¼ JÎ“ âŠ¢ ğœ™K Â¤Ã— JÎ“, s : M âŠ¢ ğ‘ƒKğ›¾ )

â€¢ Bind. By I.H. we have that, for all ğ›¾ |= JÎ“ âŠ¢ Î¨K

JÎ“ âŠ¢ ğ‘¡ : TÎ£,ğ‘˜ (ğœ)K(ğ›¾) âˆˆ Â¤P Â¤S(ğ›¿) (JÎ“, s : M âŠ¢ ğ‘ƒKğ›¾ , JÎ“, s : M, v : ğœ âŠ¢ ğ‘„Kğ›¾ )

and for all ğ‘’ âˆˆ |JğœK|, (ğ›¾, ğ‘’) |= JÎ“, ğ‘¥ : ğœ âŠ¢ Î¨K, so

JÎ“, ğ‘¥ : ğœ âŠ¢ ğ‘¢ : TÎ£,ğ‘˜ (ğœ)K(ğ›¾,ğ‘’) |= Â¤P Â¤S(ğ›¿ â€²) (JÎ“, ğ‘¥ : ğœ, ğ‘¡ : M âŠ¢ ğ‘„K(ğ›¾,ğ‘’), JÎ“, ğ‘¥ : ğœ, s : M, v : ğœ âŠ¢ ğ‘…K(ğ›¾,ğ‘’) )

Since ğ‘¥ âˆ‰ ğ¹ğ‘‰ (ğ‘…), then also
JÎ“, ğ‘¥ : ğœ âŠ¢ ğ‘¢ : TÎ£,ğ‘˜ (ğœ)K(ğ›¾, ğ‘’) |= Â¤P Â¤S(ğ›¿ â€²) (JÎ“, ğ‘¥ : ğœ, ğ‘¡ : M âŠ¢ ğ‘„K(ğ›¾,ğ‘’), JÎ“, s : M, v : ğœ âŠ¢ ğ‘…Kğ›¾ )
Note that ğœ†âˆ’1(JÎ“, ğ‘¥ : ğœ âŠ¢ ğ‘¢ : TÎ£,ğ‘˜ (ğœ)K(ğ›¾)) is a morphism ğœ Ã— M â†’ P (ğœ Ã— M) and that we can
derive
ğœ†âˆ’1(JÎ“, ğ‘¥ : ğœ âŠ¢ ğ‘¢ : TÎ£,ğ‘˜ (ğœ)K(ğ›¾)) : JÎ“, ğ‘¥ : ğœ, ğ‘¡ : M âŠ¢ ğ‘„Kğ›¾ Â¤â†’ Â¤P(ğ›¿ â€²) (JÎ“, s : M, v : ğœ âŠ¢ ğ‘…Kğ›¾ )

By Lemma 1,

(JÎ“, ğ‘¥ : ğœ âŠ¢ ğ‘¢ : TÎ£,ğ‘˜ (ğœ)K(ğ›¾))# : Â¤P Â¤S(ğ›¿) (JÎ“, s : M âŠ¢ ğ‘ƒKğ›¾ , JÎ“, s : M, v : ğœ âŠ¢ ğ‘„Kğ›¾ ) Â¤â†’
Â¤P Â¤S(ğ›¿ + ğ›¿ â€²) (JÎ“, s : M âŠ¢ ğ‘ƒKğ›¾ , JÎ“, s : M, v : ğœ âŠ¢ ğ‘…Kğ›¾ )

We know that Bind can be equivalently deï¬ned as:

JÎ“ âŠ¢ let ğ‘¥ = ğ‘¡ in ğ‘¢ : TÎ£,ğ‘˜ (ğœ)K , JÎ“, ğ‘¥ : ğœ âŠ¢ ğ‘¢ : TÎ£,ğ‘˜ (ğœ)K# â—¦ ğœƒ â—¦ hğ‘–ğ‘‘Î“, JÎ“ âŠ¢ ğ‘¡ : TÎ£,ğ‘˜ (ğœ)Ki

so we conclude.

â€¢ Read. Recall that JÎ“ âŠ¢ read ğ‘ : TÎ£,ğ‘˜ (V)K , ğœ†(ğœ‚ P â—¦hğœ‹ğ‘, ğ‘–ğ‘‘i â—¦ğœ‹2), so JÎ“ âŠ¢ read ğ‘ : TÎ£,ğ‘˜ (V)K(ğ›¾) ,
ğœ‚ P â—¦ hğœ‹ğ‘, ğ‘–ğ‘‘i. Consider an arbitrary Î“, v : V, s : M âŠ¢ ğ‘ƒ. By deï¬nition of M, we can see
ğ‘ƒ [s[ğ‘]/v] as a predicate over JÎ“K Ã— ğ‘€, and by the semantics of substitution,

hğœ‹ğ‘, ğ‘–ğ‘‘i : JÎ“, s : M âŠ¢ ğ‘ƒ [s[ğ‘]/v]Kğ›¾ Â¤â†’ JÎ“, v : V, s : M âŠ¢ ğ‘ƒKğ›¾

By the properties of Â¤P and ğœ‚ P, we conclude.

â€¢ Write. Recall that JÎ“ âŠ¢ ğ‘ := ğ‘¡ : TÎ£,ğ‘˜ (U)K , ğœ†(ğœ‚ P â—¦ h!, ğ‘–ğ‘‘i â—¦ğ‘¢ğ‘ (JÎ“ âŠ¢ ğ‘¡ : VK)). As in the previous

case, we use the semantics of substitution to show:

h!, ğ‘–ğ‘‘i â—¦ ğ‘¢ğ‘ (JÎ“ âŠ¢ ğ‘¡ : VK) (ğ›¾, âˆ’) : JÎ“, s : M âŠ¢ ğ‘ƒ [s[ğ‘ â†¦â†’ ğ‘¡]/s]Kğ›¾ Â¤â†’ JÎ“, v : U, s : M âŠ¢ ğ‘ƒKğ›¾

â€¢ Monadic Case. By I.H., Let ğ›¾ âˆˆ |JÎ“K| such that ğ›¾ |= JÎ“ âŠ¢

Î¨K. This, together with the

induction hypothesis on each branch entails

JÎ“ âŠ¢ ğ‘¡1 : TÎ£,ğ‘˜ (ğœ)K(ğ›¾) |= Â¤P Â¤S(ğ›¿) (JÎ“, s : M âŠ¢ hğ‘ = tti âŠ“ ğ‘ƒ1Kğ›¾ , JÎ“, s : M, v : ğœ âŠ¢ ğ‘„Kğ›¾ )

Ã“

JÎ“ âŠ¢ ğ‘¡2 : TÎ£,ğ‘˜ (ğœ)K(ğ›¾) |= Â¤P Â¤S(ğ›¿) (JÎ“, s : M âŠ¢ hğ‘ = ï¬€i âŠ“ ğ‘ƒ2Kğ›¾ , JÎ“, s : M, v : ğœ âŠ¢ ğ‘„Kğ›¾ )

Here we used the fact that ğ›¾ |= Î¨ âˆ§ Î¦ =â‡’ ğ‘ƒğ›¾ â‰¤ ğ‘„ğ›¾ implies ğ›¾ |= Î¨ =â‡’ (ğœ‹ âˆ—
Then from the standard reasoning on conditional expression we conclude

1 ğ¼ Î¦ âŠ“ ğ‘ƒğ›¾ ) â‰¤ ğ‘„ğ›¾ .

JÎ“ âŠ¢ if ğ‘ then ğ‘¡1 else ğ‘¡2K(ğ›¾) |= Â¤P Â¤S(ğ›¿) (JÎ“, s : M âŠ¢ (hğ‘ = ttiâŠ“ğ‘ƒ1)âŠ”(hğ‘ = ï¬€iâŠ“ğ‘ƒ2)Kğ›¾ , JÎ“, s : M, v : ğœ âŠ¢ ğ‘„Kğ›¾ )

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

93:42

A. Aguirre, G. Barthe, M. Gaboardi, D. Garg, S. Katsumata, and T. Sato

â€¢ Uniform sampling. Here we use the concrete deï¬nition of Â¤P. JÎ“ âŠ¢ Unif(ğœ) : TÎ£,ğ‘˜ (ğœ)K =
ğœ†.ğœƒ â—¦ hUnif (JğœK), ğ‘–ğ‘‘i. By deï¬nition of the uniform distribution, if {ğ‘¥ âˆˆ ğœ |ğ‘¥ âˆˆ ğœ™ }/|ğœ | = ğ›¿,
then Prğ‘¥âˆ¼Unif (JğœK) [ğ‘¥ âˆˆ ğœ™] = ğ›¿, so Unif(JğœK) âˆˆ Â¤P ub() (1 âˆ’ ğ›¿) (ğœ™), and therefore,

JÎ“ âŠ¢ Unif(ğœ) : TÎ£,ğ‘˜ (ğœ)K : JÎ“, s : M âŠ¢ ğ‘ƒK
Â¤â†’ Â¤P ub(1 âˆ’ ğ›¿) (Jğ‘¥ : ğœ âŠ¢ ğœ™K) Â¤Ã— JÎ“, s : M âŠ¢ ğ‘ƒK
Â¤â†’ Â¤P ub(1 âˆ’ ğ›¿) (JÎ“, ğ‘¥ : ğœ, s : M âŠ¢ ğœ™ âˆ§ ğ‘ƒK).

(cid:3)

A judgment in RHOL can be seen as a triple formed by two typing judgments and a logical

judgment with two extra distinguished variables.

Theorem F.3 (Soundness of RHOL). Let Î“ | Î¨ âŠ¢ ğ‘¡1 : ğœ1 âˆ¼ ğ‘¡2 : ğœ2 {ğœ™ } be a derivable UHOL
Î¨K implies

judgment. Then, for any ğ›¾ âˆˆ |JÎ“K|, ğ›¾ |= JÎ“ âŠ¢

(JÎ“ âŠ¢ ğ‘¡1 : ğœ1K(ğ›¾), JÎ“ âŠ¢ ğ‘¡2 : ğœ2K(ğ›¾)) |= JÎ“, r1 : ğœ1, r2 : ğœ2 âŠ¢ ğœ™Kğ›¾ .

Ã“

We now prove soundness of the relational logic. We ï¬rst recall the statement:

Proposition. Let Î“ | Î¨ âŠ¢ {ğ‘ƒ }ğ‘¡1 : TÎ£,ğ‘˜ (ğœ1) âˆ¼ ğ‘¡1 : TÎ£,ğ‘˜ (ğœ2){{ğ‘„ }}ğ›¿ be a derivable HO-PRL judgment

without the [ADV âˆ’ R] rule. Then for any ğ›¾ âˆˆ |JÎ“K|, ğ›¾ |= JÎ“ âŠ¢

Î¨K implies

(JÎ“ âŠ¢ ğ‘¡1 : TÎ£,ğ‘˜ (ğœ1)K(ğ›¾), JÎ“ âŠ¢ ğ‘¡2 : TÎ£,ğ‘˜ (ğœ2)K(ğ›¾)) |= Â¤P Â¤S (0, ğ›¿) (Jğ‘ƒKğ›¾ , Jğ‘„Kğ›¾ ),
where Jğ‘ƒKğ›¾ , JÎ“, s1 : M, s2 : M âŠ¢ ğ‘ƒKğ›¾ and ğ‘„ğ›¾ , JÎ“, s1 : M, v1 : ğœ, s2 : M, v2 : ğœ âŠ¢ ğ‘„Kğ›¾ .

Ã“

Proof of Proposition 6.7. To simplify the proof, we will use set theory notation, i.e. instead
of ğ›¾ âˆˆ QBS(1, JÎ“K) and hğ›¾ âˆ—, ğ‘–ğ‘‘iJÎ“, s : ğ‘€ âŠ¢ ğ‘ƒK, we write ğ›¾ âˆˆ JÎ“K and JÎ“, s : ğ‘€ âŠ¢ ğ‘ƒK(ğ›¾). We also use
the shorthand Â¥Tğœ1,ğœ2,(ğœ–,ğ›¿) , Â¥S( Â¥P dp)ğœ1,ğœ2,(ğœ–,ğ›¿) , and omit ğœ1, ğœ2 when they are clear from the context.
We only show a few interesting cases:

â€¢ [UNIT âˆ’ L]. By soundness of UHOL,

hğ‘–ğ‘‘JÎ“K, JÎ“ âŠ¢ ğ‘¡ : ğœ1Ki : JÎ“ âŠ¢

Î¨K â†’ JÎ“, r : ğœ1 âŠ¢ ğœ™K

Î¨K, JÎ“ âŠ¢ ğ‘¡ : ğœ1K(ğ›¾) âˆˆ JÎ“, r : ğœ1 âŠ¢ ğœ™K(ğ›¾). Consider an arbitrary predicate

Ã›

so for all ğ›¾ âˆˆ JÎ“ âŠ¢
Î“, s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğ‘ƒ. By deï¬nition,

Ã“

JÎ“ âŠ¢ unit(ğ‘¡) : Tğœ1K(ğ›¾) = ğœ‚ T (JÎ“ âŠ¢ ğ‘¡ : ğœ1K(ğ›¾))

and

JÎ“ âŠ¢ skip : T UK(ğ›¾) = ğœ‚ (âˆ—)
Where âˆ— is the only element of the singleton set. By Lemma ?? we can conclude that

(ğœ‚ T (JÎ“ âŠ¢ ğ‘¡ : ğœ1K(ğ›¾)), ğœ‚ T (âˆ—)) âˆˆ
Â¥Tğœ1,U,(0,0) (JÎ“, s1 : ğ‘€, s2 âŠ¢ ğ‘ƒK(ğ›¾), JÎ“ âŠ¢ ğœ™K(ğ›¾) Â¥Ã— JÎ“, s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğ‘ƒK(ğ›¾))
â€¢ [BIND]. By applying I.H. to the ï¬rst premise we have that, for all ğ›¾ âˆˆ JÎ“ âŠ¢ Î¨K

(JÎ“ âŠ¢ ğ‘¡1 : Tğœ1K(ğ›¾), JÎ“ âŠ¢ ğ‘¡2 : T ğœ2K(ğ›¾)) âˆˆ
Â¥T(ğœ–,ğ›¿) (JÎ“, s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğ‘ƒK(ğ›¾), JÎ“, s1 : ğ‘€, v1 : ğœ1, s2 : ğ‘€, v2 : ğœ2 âŠ¢ ğ‘„K(ğ›¾))

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

Higher-order probabilistic adversarial computations

93:43

and for all ğ‘’1 : ğœ2, ğ‘’2 : ğœ2, we have (ğ›¾, ğ‘’1, ğ‘’2) âˆˆ JÎ“, ğ‘¥1 : ğœ1, ğ‘¥2 : ğœ2 âŠ¢ Î¨K, so by applying I.H. to
the second premise,

(JÎ“, ğ‘¥1 : ğœ1, ğ‘¥2 : ğœ2, âŠ¢ ğ‘¢1 : T ğœ1K(ğ›¾, ğ‘’1, ğ‘’2), JÎ“, ğ‘¥1 : ğœ1, ğ‘¥2 : ğœ2 âŠ¢ ğ‘¢2 : T ğœ2K(ğ›¾, ğ‘’1, ğ‘’2)) âˆˆ
Â¥T(ğœ–â€²,ğ›¿â€²) (JÎ“, ğ‘¥1 : ğœ1, ğ‘¥2 : ğœ2, s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğ‘„K(ğ›¾, ğ‘’1, ğ‘’2),

JÎ“, ğ‘¥1 : ğœ1, ğ‘¥2 : ğœ2, s1 : ğ‘€, v1 : ğœ1, s2 : ğ‘€, v2 : ğœ2 âŠ¢ ğ‘…K(ğ›¾, ğ‘’1, ğ‘’2))

Since ğ‘¥1, ğ‘¥2 âˆ‰ ğ¹ğ‘‰ (ğ‘…), then also

(JÎ“, ğ‘¥1 : ğœ1, ğ‘¥2 : ğœ2, âŠ¢ ğ‘¢1 : T ğœ1K(ğ›¾, ğ‘’1, ğ‘’2), JÎ“, ğ‘¥1 : ğœ1, ğ‘¥2 : ğœ2 âŠ¢ ğ‘¢2 : T ğœ2K(ğ›¾, ğ‘’1, ğ‘’2)) âˆˆ
Â¥T(ğœ–â€²,ğ›¿â€²) (JÎ“, ğ‘¥1 : ğœ1, ğ‘¥2 : ğœ2, s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğ‘„K(ğ›¾, ğ‘’1, ğ‘’2),

JÎ“, s1 : ğ‘€, v1 : ğœ1, s2 : ğ‘€, v2 : ğœ2 âŠ¢ ğ‘…K(ğ›¾))

Also, since ğ‘¥1 âˆ‰ ğ¹ğ‘‰ (ğ‘¢2) and ğ‘¥2 âˆ‰ ğ¹ğ‘‰ (ğ‘¢1), we have morphisms

ğœ†âˆ’1(JÎ“, ğ‘¥1 : ğœ1 âŠ¢ ğ‘¢1 : T ğœ1K(ğ›¾)) : ğœ1 Ã— ğ‘€ â†’ P (ğœ1 Ã— ğ‘€)

and

so,

ğœ†âˆ’1(JÎ“, ğ‘¥2 : ğœ2 âŠ¢ ğ‘¢2 : T ğœ2K(ğ›¾)) : ğœ2 Ã— ğ‘€ â†’ P (ğœ2 Ã— ğ‘€)

(ğœ†âˆ’1(JÎ“, ğ‘¥1 : ğœ1 âŠ¢ ğ‘¢1 : T ğœ1K(ğ›¾)), ğœ†âˆ’1(JÎ“, ğ‘¥2 : ğœ2 âŠ¢ ğ‘¢2 : T ğœ2K(ğ›¾))) :

JÎ“, ğ‘¥1 : ğœ1, s1 : ğ‘€, ğ‘¥2 : ğœ2, s1 : ğ‘€ âŠ¢ ğ‘„K(ğ›¾) â†’

Â¥P dp
(ğœ–â€²,ğ›¿â€²) (JÎ“, s1 : ğ‘€, v1 : ğœ1, s2 : ğ‘€, v1 : ğœ2 âŠ¢ ğ‘…K(ğ›¾))

By the relational analogue of Lemma 1, we get

((JÎ“, ğ‘¥1 : ğœ1 âŠ¢ ğ‘¢1 : T ğœ1K(ğ›¾))#, (JÎ“, ğ‘¥2 : ğœ2 âŠ¢ ğ‘¢2 : T ğœ2K(ğ›¾))#) :
Â¥T(ğœ–,ğ›¿) (JÎ“, s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğ‘ƒK(ğ›¾), JÎ“, s1 : ğ‘€, v1 : ğœ1, s2 : ğ‘€, v2 : ğœ2 âŠ¢ ğ‘„K(ğ›¾)) â†’
Â¥T(ğœ–+ğœ–â€²,ğ›¿+ğ›¿â€²) (JÎ“, s1 : ğ‘€, s2 : ğ‘€ âŠ¢ ğ‘ƒK(ğ›¾), JÎ“, s1 : ğ‘€, v1 : ğœ1, s2 : ğ‘€, v2 : ğœ2 âŠ¢ ğ‘…(ğ›¾)K)

and from this we can conclude.

(cid:3)

Proc. ACM Program. Lang., Vol. 5, No. ICFP, Article 93. Publication date: August 2021.

