0
2
0
2

r
p
A
2
2

]
I

A
.
s
c
[

4
v
2
0
0
1
1
.
2
0
0
2
:
v
i
X
r
a

Turning 30: New Ideas in Inductive Logic Programming

Andrew Cropper1 , Sebastijan Dumanˇci´c2, and Stephen H. Muggleton3
1University of Oxford
2KU Leuven
3Imperial College London
andrew.cropper@cs.ox.ac.uk, sebastijan.dumancic@cs.kuleuven.be,
stephen.muggleton@imperial.ac.uk

Abstract

Common criticisms of state-of-the-art machine
learning include poor generalisation, a lack of in-
terpretability, and a need for large amounts of
training data. We survey recent work in induc-
tive logic programming (ILP), a form of machine
learning that induces logic programs from data,
which has shown promise at addressing these lim-
itations. We focus on new methods for learn-
ing recursive programs that generalise from few
examples, a shift from using hand-crafted back-
ground knowledge to learning background knowl-
edge, and the use of different technologies, no-
tably answer set programming and neural net-
works. As ILP approaches 30, we also discuss di-
rections for future research.

1 Introduction

Common criticisms of state-of-the-art machine learning
interpretability,
include poor generalisation, a lack of
and a need for large numbers of
training examples
[Marcus, 2018; Chollet, 2019; Bengio et al., 2019]. In this
paper, we survey recent work in inductive logic program-
ming (ILP) [Muggleton, 1991], a form of machine learning
that induces logic programs from data, which has shown
promise at addressing these limitations.

Compared to most machine learning approaches, ILP
ILP systems can learn us-
has several advantages.
ing background knowledge (BK) (relational
theories),
such as using a theory of light to understand images
[Muggleton et al., 2018b]. Because of the expressivity of
logic programs, ILP systems can learn complex relational
theories, such as cellular automata [Inoue et al., 2014],
event calculus theories [Katzouris et al., 2016], and Petri
nets [Bain and Srinivasan, 2018].
Because hypotheses
are logic programs, they can be read by humans, cru-
cial for explainable AI and ultra-strong machine learn-
ing [Michie, 1988]. Due to the strong inductive bias
imposed by the BK, ILP systems can generalise from
small numbers of examples, often a single example
[Lin et al., 2014]. Finally, because of their symbolic nature,
ILP systems naturally support lifelong and transfer learning

[Cropper, 2020], which is considered essential for human-
like AI [Lake et al., 2016].

Old ILP

New ILP

Limited

Recursion
Predicate invention No
Hypotheses
Optimality
Technology

Yes
Yes
First-order Higher-order, ASP
Yes
No
Prolog, ASP, NNs
Prolog

Table 1: A simpliﬁed comparison between old and new ILP sys-
tems.

[Cropper and Muggleton, 2016],

Some of these advantages come from recent develop-
ments, which we survey in this paper. To aid the reader,
we coarsely compare old and new ILP systems. We use
FOIL [Quinlan, 1990], Progol [Muggleton, 1995], TILDE
[Blockeel and Raedt, 1998], and Aleph [Srinivasan, 2001]
as representative old systems and ILASP [Law et al., 2014],
∂ ILP
and
Metagol
[Evans and Grefenstette, 2018] as
representative new
systems. This comparison, shown in Table 1, is, of course,
vastly over simpliﬁed, and there are many exceptions to
the comparison. We discuss each development (each row
in the table) in turn. We discuss new methods for learning
recursive logic programs, which allows for more generali-
sation from fewer examples (Section 2); a shift from using
hand-crafted BK to learning BK, namely through predicate
invention and transfer learning, which has been shown to
improve predictive accuracies and reduce learning times
(Section 3);
learning programs of various expressivity,
notably Datalog and answer set programs (Section 4); new
methods for learning optimal programs, such as efﬁcient
time complexity programs (Section 5); and recent work
that uses different underlying technologies to perform the
learning, notably to leverage recent improvements with
ASP/SMT solvers and neural networks (Section 6). Finally,
as ILP approaches 30, we conclude by proposing directions
for future research.

1.1 What is ILP?
Given positive and negative examples and BK, the goal of
an ILP system is to induce (learn) a hypothesis (a logic pro-
gram) which, with the BK, entails as many positive and

 
 
 
 
 
 
as few negative examples as possible [Muggleton, 1991].
Whereas most machine learning approaches represent data
as vectors, ILP represents data (examples, BK, and hypothe-
ses) as logic programs.

Example 1. To illustrate ILP, suppose you want to learn
a string transformation program from the following exam-
ples.

Input

Output

machine
learning
algorithm

e
g
m

By contrast,

Most forms of machine learning would represent these
in ILP, we would
examples as vectors.
such as
these examples as logical atoms,
represent
f([m,a,c,h,i,n,e], e), where f is the target predicate
that we want to learn (i.e. the relation to generalise). BK
(features) is likewise represented as a logical theory (a logic
program). For instance, for the string transformation prob-
lem, we could provide BK that contains logical deﬁnitions
for string operations, such as empty(A), which holds when
the list A is empty, head(A,B), which holds when B is the
head of the list A, and tail(A,B), which holds when B is
the tail of the list A. Given the aforementioned examples
and BK, an ILP system could induce the hypothesis (a logic
program) shown in Figure 1.

f(A,B):-tail(A,C),empty(C),head(A,B).
f(A,B):-tail(A,C),f(C,B).

Figure 1: A hypothesis (logic program) for the string transfor-
mation problem in Example 1. Each line of the program is a
logical clause (or rule). The ﬁrst rule says that the relation
f(A,B) holds when the three literals tail(A,C), empty(C), and
head(A,B) hold, i.e. B is the last element of A when the tail of A is
empty and B is the head of A. The second rule is recursive and says
that the relation f(A,B) holds when the two literals tail(A,C)
and f(C,B) hold, i.e. f(A,B) holds when the same relation holds
for the tail of A.

2 Recursion
A recursive logic program is one where the same predicate
appears in the head and body of a rule. Learning recursive
programs has long been considered a difﬁcult problem for
ILP [Muggleton et al., 2012]. To illustrate the importance
of recursion, consider the string transformation problem in
Example 1. With recursion, an ILP system can learn the
compact program shown in Figure 1. Because of the sym-
bolic representation and the recursive nature, the program
generalises to lists of arbitrary size and to lists that contain
arbitrary elements (e.g integers, characters, etc). Without
recursion, an ILP system would need to learn a separate
clause to ﬁnd the last element for each list of length n, such
as:

f(A,B):-tail(A,C),empty(C),head(A,B).
f(A,B):-tail(A,C),tail(C,D),empty(D),head(C,B).
f(A,B):-tail(A,C),tail(C,D),tail(D,E),empty(E),head(E,B).

In other words, without recursion, it is often difﬁcult for
an ILP system to generalise from small numbers of exam-
ples [Cropper et al., 2015].

Older ILP systems struggle to learn recursive programs,
especially from small numbers of training examples. A
common limitation with existing approaches is that they
rely on bottom clause construction [Muggleton, 1995]. In
this approach, for each example, an ILP system creates the
most speciﬁc clause that entails the example, and then tries
to generalise the clause to entail other examples. How-
ever, this sequential covering approach requires examples
of both the base and inductive cases, and in that order.

Interest in recursion resurged with the introduction of
meta-interpretive learning (MIL) [Muggleton et al., 2014;
Muggleton et al., 2015; Cropper et al., 2019] and the MIL
system Metagol [Cropper and Muggleton, 2016]. The key
idea of MIL is to use metarules, or program templates, to
restrict the form of inducible programs, and thus the hy-
pothesis space1. A metarule is a higher-order clause. For
instance, the chain metarule is P(A, B) ← Q(A, C), R(C, B),
where the letters P, Q, and R denote higher-order vari-
ables and A, B and C denote ﬁrst-order variables. The
goal of a MIL system, such as Metagol, is to ﬁnd substi-
tutions for the higher-order variables. For instance, the
chain metarule allows Metagol to induce programs such as
f(A,B):-tail(A,C),head(C,B)2. Metagol induces recur-
sive programs using recursive metarules, such as the tail
recursion metarule P(A,B) ← Q(A,C), P(C,B).

Following MIL, many ILP systems can learn recursive
programs [Law et al., 2014; Evans and Grefenstette, 2018;
Kaminski et al., 2019]. With recursion, ILP systems can
now generalise from small numbers of examples, often
a single example [Lin et al., 2014; Cropper, 2019]. The
ability to learn recursive programs has opened up ILP
to new application areas, including learning string trans-
formations programs [Lin et al., 2014], robot strategies
[Cropper and Muggleton, 2015], and answer set grammars
[Law et al., 2019].

3 Learning Background Knowledge

A key characteristic of ILP is the use of BK as a form of in-
ductive bias. BK is similar to features used in most forms of
machine learning. However, whereas features are vectors,
BK usually contains facts and rules (extensional and inten-
sional deﬁnitions) in the form of a logic program. For in-
stance, when learning string transformation programs, we
may want to supply helper background relations, such as

1 The

to restrict

[Wang et al., 2014;

idea of using metarules

the hy-
space has been widely adopted by many ap-
pothesis
Albarghouthi et al., 2017;
proaches
Evans and Grefenstette, 2018;
Rocktäschel and Riedel, 2017;
Si et al., 2018;
Si et al., 2019;
Bain and Srinivasan, 2018;
Kaminski et al., 2019]. However, despite their now widespread
use, there is little work determining which metarules to use
for a given learning task ([Cropper and Tourret, 2019] is an
exception), which future work must address.

2Metagol can induce longer clauses though predicate inven-

tion, which is described in Section 3.1.

head/23 and tail/2. For other domains, we may want to
supply more complex BK, such as a theory of light to un-
derstand images [Muggleton et al., 2018b] or higher-order
operations, such as map/3, filter/3, and fold/4, to solve
programming puzzles [Cropper et al., 2019].

As with choosing appropriate features, choosing appro-
ILP
priate BK is crucial for good learning performance.
has traditionally relied on hand-crafted BK, often designed
by domain experts,
feature engineering. This ap-
proach is clearly limited because obtaining suitable BK
can be difﬁcult and expensive.
the over re-
liance on hand-crafted BK is a common criticism of ILP
[Evans and Grefenstette, 2018].

Indeed,

i.e.

Two recent avenues of research attempt to overcome this
limitation. The ﬁrst idea is to enable an ILP system to auto-
matically invent new predicate symbols. The second idea is
to perform lifelong and transfer learning to discover knowl-
edge that can be reused to help learn other programs. We
discuss these ideas in turn.

3.1 Predicate Invention

Rather than expecting a user to provide all the necessary
BK, the goal of predicate invention is for an ILP system to
automatically invent new auxiliary predicate symbols. This
idea is similar to when humans create new functions when
manually writing programs, as to reduce code duplication
or to improve readability.

in

have

been

support

previous

resulting

in
popular

Whilst predicate invention has attracted interest since
ILP [Muggleton and Buntine, 1988],
the beginnings of
unsuccess-
attempts
most
in-
no
ful
[Quinlan, 1990;
systems
vention
Blockeel and Raedt, 1998;
Muggleton, 1995;
Srinivasan, 2001].
A key limitation of early ILP sys-
tems is that the search is complex and under-speciﬁed
in various ways. For instance, it was unclear how many
arguments an invented predicate should have, and how
the arguments should be ordered.

predicate

ILP

for

As with recursion, interest in predicate invention has
resurged with the introduction of MIL. MIL avoids the is-
sues of older ILP systems by using metarules to deﬁne the
hypothesis space and in turn reduce the complexity of in-
venting a new predicate symbol. As mentioned, a metarule
is a higher-order clause. For instance, the chain metarule
(P(A, B) ← Q(A, C), R(C, B)) allows Metagol to induce pro-
grams such as f(A,B):- tail(A,C),tail(C,D), which
would drop the ﬁrst two elements from a list. To induce
longer clauses, such as to drop ﬁrst three elements from
a list, Metagol can use the same metarule but can invent
a new predicate symbol and then chain their application,
such as to induce the program:

f(A,B):-tail(A,C),inv1(C,B).
inv1(A,B):-tail(A,C),tail(C,B).

To learn this program, Metagol invents the predicate
symbol inv1 and induces a deﬁnition for it using the chain

3Notation for a predicate symbol head with two arguments.

metarule. Metagol uses this new predicate symbol in the
deﬁnition for the target predicate f.

Predicate invention allows Metagol (and other ILP sys-
tems) to learn programs by expanding their BK. A major
side-effect of this metarule and predicate invention driven
approach is that problems are forced to be decomposed
into smaller problems, where the decomposed solutions
can be reused. For instance, suppose you wanted to learn
a program that drops the ﬁrst four elements of a list, then
Metagol could learn the following program, where the in-
vented predicate symbol inv1 is used twice:

f(A,B):-inv1(A,C),inv1(C,B).
inv1(A,B):-tail(A,C),tail(C,B).

Predicate invention has been shown to help reduce
target programs, which in turns reduces
the size of
sample complexity and improves predictive accuracy
[Cropper, 2019; Cropper et al., 2019]. Following Metagol,
other newer ILP systems support predicate invention
[Evans and Grefenstette, 2018; Kaminski et al., 2019], of-
ten using a metarule guided approach. Such systems all
have the general principle of introducing new predicate
symbols when their current BK is insufﬁcient to learn a hy-
pothesis.

For

In contrast

to aforementioned approaches, a dif-
idea is to invent new predicates to improve
ferent
instance, CUR2LED
knowledge representation.
[Dumanˇci´c and Blockeel, 2017] learns new predicates by
clustering constants and relations in the provided BK, turn-
ing each identiﬁed cluster into a new BK predicate. The key
insight of CUR2LED is not to use a single similarity mea-
sure, but rather a set of various similarities. This choice is
motivated by the fact that different similarities are useful
for different tasks, but in the unsupervised setting the task
itself is not known in advance. CUR2LED would therefore
invent predicates by producing different clusterings accord-
ing to the features of the objects, community structure and
so on.

ALPs [Dumanˇci´c et al., 2019] perform predicate inven-
tion inspired by a (neural) auto-encoding principle: they
learn an encoding logic program that maps the provided
data to a new, compressive latent representation (deﬁned
in terms of the invented predicates), and a decoding logic
program that can reconstruct the provided data from its la-
tent representation. Both approaches have demonstrated
an improved performance on supervised tasks, even though
the predicate invention step is task-agnostic.

3.2 Lifelong Learning
An advantage of a symbolic representation is that learned
knowledge can be remembered, i.e. explicitly stored in the
BK. Therefore, the second line of research that tries to ad-
dress the limitations of hand-crafted BK tries to leverage
transfer learning. The general idea is to reuse knowledge
gained from solving one problem to help solve a different
problem.

One notable application of transfer learning is the
MetagolDF system [Lin et al., 2014] which, given a set of
tasks, uses Metagol to try to learn a solution for each task

using at most 1 clause. If Metagol ﬁnds a solution for any
task, it adds the solution to the BK and removes the task
from set. It then tries to ﬁnd solutions for the rest of the
tasks, but can now (1) use an additional clause, and (2)
reuse solutions from solved tasks. This process repeats un-
til MetagolDF solves all the tasks, or reaches a maximum
In other words, MetagolDF automatically
program size.
identiﬁes easier problems, learn programs for them, and
then reuses the solutions to help learn programs for more
difﬁcult problems. One of the key ideas of Metabias is to
not only save the induced target relation to the BK, but
to also add its constituent parts discovered through predi-
cate invention. The authors experimentally show that their
multi-task approach performs substantially better than a
single-task approach because learned programs are fre-
quently reused. Moreover, they show that this approach
leads to a hierarchy of BK composed of reusable programs,
where each builds on simpler programs, which can be seen
as deep inductive logic programming.

MetagolDF saves all

learned programs (including in-
vented predicates) to the BK, which can be problematic
because too much irrelevant BK is detrimental to learn-
To address this problem, Forgetgol
ing performance.
[Cropper, 2020] introduces the idea of forgetting.
In this
approach, Forgetgol continually grows and shrinks its hy-
pothesis space by adding and removing learned programs
to and from its BK. The authors show that forgetting can
reduce both the size of the hypothesis space and the sam-
ple complexity of an ILP learner when learning from many
tasks, which shows potential for ILP to be useful in a life-
long or continual learning setting, which is considered cru-
cial for AI [Lake et al., 2016].

The aforementioned MetagolDF and Forgetgol ap-
proaches assume a corpus of user-supplied tasks to train
from. This assumption is unrealistic in many situations.
To overcome this limitation, Playgol [Cropper, 2019] ﬁrst
plays by randomly sampling its own tasks to solve, and tries
to solve them, adding any solutions to the BK, which can
be seen as a form of self-supervised learning. After play-
ing Playgol tries to solve the user-supplied tasks by reusing
solutions learned whilst playing. The goal of Playgol is sim-
ilar to all the approaches discussed in this section: to auto-
matically discover reusable general programs as to improve
learning performance, but does so with fewer labelled ex-
amples.

4 Expressiveness

ILP systems have traditionally induced Prolog programs. A
recent development has been to use alternative hypothesis
representations.

4.1 Datalog

the program.
Second, a Datalog query is guaranteed
to terminate, though this guarantee is at the expense
of not being a Turing-complete language, which Prolog
is. Due to the aforementioned beneﬁts, several works
[Albarghouthi et al., 2017; Evans and Grefenstette, 2018;
Si et al., 2018; Raghothaman et al., 2020] induce Datalog
programs. The general motivation for reducing the expres-
sivity of the representation language from Prolog to Data-
log is to allow the problem to be encoded as a satisﬁability
problem, particularly to leverage recent developments in
SAT and SMT. We discuss the advantages of this approach
more in Section 6.1.

4.2 Answer Set Programming

ASP is a logic programming paradigm. Like Datalog, ASP is
a truly declarative language. Compared to Datalog, ASP is
more expressive, allowing, for instance, disjunction in the
head of a clause, hard and weak constraints, and support
for default inference and default assumptions. A key differ-
ence between ASP and Prolog is semantics. A deﬁnite logic
program (a Prolog program) has only one model (the least
Herbrand model). By contrast, an ASP program can have
one, many, or even no models (answer sets). Due to its non-
monotonicity, ASP are particularly attractive for expressing
common-sense reasoning [Law et al., 2018a].

Approaches to learning ASP programs can mostly be di-
vided into two categories: brave learners, which aim to
learn a program such that at least one answer set cov-
ers the examples, and cautious learners, which aim to
ﬁnd a program which covers the examples in all answer
sets. ILASP (Inductive Learning of Answer Set Programs)
[Law et al., 2014] is a collection of ILP systems that learn
ASP programs. ILASP is notable because it supports both
brave and cautious learning, which are both needed to
learn some ASP programs [Law et al., 2018a]. Moreover,
ILASP differs from most Prolog-based ILP systems because
it learns unstratiﬁed ASP programs, including programs
with normal rules, choice rules, and both hard and weak
constraints, which classical ILP systems cannot. Learning
ASP programs allows for ILP to be used for new problems,
such as inducing answer set grammars [Law et al., 2019].

4.3 Higher-Order Programs

Imagine learning a droplasts program, which removes the
last element of each sublist in a list, e.g. [alice,bob,carol]
7→ [alic,bo,caro]. Given suitable input data, Metagol can
learn this ﬁrst-order recursive program:

f(A,B):-empty(A),empty(B).
f(A,B):-head(A,C),tail(A,D),head(B,E),
tail(B,F),f1(C,E),f(D,F).

f1(A,B):-reverse(A,C),tail(C,D),reverse(D,B).

Datalog is a syntactical subset of Prolog which disallows
complex terms as arguments of predicates and imposes re-
strictions on the use of negation (and negation with re-
cursion). These restrictions make Datalog attractive for
two reasons.
First, Datalog is a truly declarative lan-
guage, whereas in Prolog reordering clauses can change

Although semantically correct,

the program is ver-
bose.
To learn more compact programs, Metagolho
[Cropper et al., 2019] extends Metagol to support learning
higher-order programs, where predicate symbols can be
used as terms. For instance, for the same droplasts prob-
lem, Metagolho learns the higher-order program:

f(A,B):-map(A,B,f1).
f1(A,B):-reverse(A,C),tail(C,D),reverse(D,B).

To learn this program, Metagolho invents the predicate
symbol f1, which is used twice in the program: once as
term in the map(A,B,f1) literal and once as a predicate
symbol in the f1(A,B) literal. Compared to the ﬁrst-order
program, this higher-order program is smaller because it
uses map/3 to abstract away the manipulation of the list
and to avoid the need to learn an explicitly recursive pro-
gram (recursion is implicit in map/3). By reducing the
size of the target program by learning higher-order pro-
grams, Metagolho has been shown to reduce sample com-
plexity and learning times, and improve predictive accu-
racies [Cropper et al., 2019]. This example illustrates the
value of higher-order abstractions and inventions, which
allow ILP systems to learn more complex programs using
fewer examples with less search.

5 Optimal Programs
In ILP there are often multiple (sometimes inﬁnite) hy-
potheses that explain the data. Deciding which hypothe-
sis to choose has long been a difﬁcult problem. Older ILP
systems were not guaranteed to induce optimal programs,
where optimal typically means with respect to the size of
the induced program, or the coverage of examples.

A key reason for this limitation was that most search tech-
niques learned a single clause at a time, leading to the con-
struction of sub-programs which were sub-optimal in terms
of program size and coverage. For instance, programs in-
duced by Aleph offer no guarantee of optimality with re-
spect to the program size and coverage.

Newer ILP systems try to address this limitation. As with
the ability to learn recursive programs, the main develop-
ment is to take a global view of the induction task. In other
words, rather than induce a single clause at a time from a
subset of the examples, the idea is to induce a whole pro-
gram. For instance, ILASP is given as input a hypothesis
space with a set of candidate clauses. The ILASP task is to
ﬁnd a minimal subset of clauses that covers as many pos-
itive and as few negative examples as possible. To do so,
ILASP uses ASP’s optimisation abilities to provably learn
the program with the fewest literals. Likewise, Metagol
and HEXMIL are guaranteed to induce programs with the
fewest clauses.

An advantage of learning optimal programs is learning
performance. The idea is that the smallest program should
provide better generalisations. When Law et al. (2018b)
compared ILASP (which is guaranteed to learn optimal pro-
grams) to Inspire [Kazmi et al., 2017] (which is not guaran-
teed to learn optimal programs), ILASP achieved a higher
F1 score (both systems were given identical hypothesis
spaces and optimisation criteria).

In addition to performance advantages,

the abil-
ity to learn optimal programs opens up ILP to new
problems.
logic pro-
grams has long been considered a difﬁcult problem in
ILP [Muggleton and Raedt, 1994; Muggleton et al., 2012],
mainly because there is no declarative difference between

learning efﬁcient

For instance,

an efﬁcient program, such as mergesort, and an inefﬁ-
cient program, such as bubble sort. To address this issue,
Metaopt [Cropper and Muggleton, 2019] extends Metagol
to support learning efﬁcient programs. Metaopt maintains
a cost during the hypothesis search and uses this cost to
prune the hypothesis space. To learn minimal time com-
plexity logic programs, Metaopt minimises the number of
resolution steps. For instance, imagine trying to learn a
ﬁnd duplicate program, which ﬁnds any duplicate element
in a list e.g. [p,r,o,g,r,a,m] 7→ r, and [i,n,d,u,c,t,i,o,n] 7→ i.
Given suitable input data, Metagol can induce the recursive
program:

f(A,B):-head(A,B),tail(A,C),element(C,B).
f(A,B):-tail(A,C),f(C,B).

This program goes through the elements of the list check-
ing whether the same element exists in the rest of the list.
Given the same input, Metaopt induces the recursive pro-
gram:

f(A,B):-mergesort(A,C),f1(C,B).
f1(A,B):-head(A,B),tail(A,C),head(C,B).
f1(A,B):-tail(A,C),f1(C,B).

This program ﬁrst sorts the input list and then goes
though the list to check whether for duplicate adjacent ele-
ments. Although larger, both in terms of clauses and lit-
erals, the program learned by Metaopt is more efﬁcient
O(log n) than the program learned by Metagol O(n2). The
main implication of this work is that Metaopt can learn ef-
ﬁcient robot strategies, efﬁcient time complexity logic pro-
grams, and even efﬁcient string transformation programs.
Following this idea, FastLAS [Law et al., 2020] is an ASP-
based ILP system that takes as input a custom scoring func-
tion and computes an optimal solution with respect to the
given scoring function. The authors show that this ap-
proach allows a user to optimise domain-speciﬁc perfor-
mance metrics on real-world datasets, such as access con-
trol policies.

6 Different Technologies
Older ILP systems mostly use Prolog for reasoning. Recent
work considers using different technologies.

have

been

recent

programs

tremendous

[Ray, 2009;

6.1 Constraint Satisfaction and Satisﬁability
advances
There
in SAT and SMT solvers.
To leverage these ad-
vances, much recent work uses ASP to induce
Athakravi et al., 2013;
logic
Law et al., 2014;
Muggleton et al., 2014;
Katzouris et al., 2015;
Katzouris et al., 2016;
Kaminski et al., 2019]. The main motivations are to lever-
age (1) the language beneﬁts of ASP (Section 4.2), and
(2) the efﬁciency and optimisation techniques of modern
ASP solvers, such as CLASP [Gebser et al., 2012], which
supports conﬂict propagation and learning. With similar
[Albarghouthi et al., 2017;
motivations,
Si et al., 2018;
synthesise
Datalog program by encoding the ILP task into a SMT
problem.

Raghothaman et al., 2020]

several works

These approaches have been shown able to reduce learn-
ing times compared to standard Prolog-based approaches.
However, some unresolved issues remain. A key issue
is that most approaches encode an ILP problem as a sin-
gle (often very large) satisﬁability problem. These ap-
proaches therefore often struggle to scale to very large prob-
lems [Cropper et al., 2019]. Although preliminary work at-
tempts to tackle this issue [Law et al., 2020], work is still
needed for these approaches to scale to large problems.

Noisy BK Lifelong learning is seen as key to AI, and recent
work in ILP has shown promise in this direction (Section
3.2). However, unresolved issues remain. One key issue is
the underlying uncertainty associated with adding learned
programs to the BK. By the nature of induction, such pro-
grams are expected to be noisy, yet they are the building
blocks for further inductive inference. Building noisy pro-
grams on top of other noisy programs could lead to even-
tual incoherence of the learned program.

6.2 Neural Networks

With the recent rise of deep learning and neural networks,
several approaches have explored using gradient-based
methods to learn logic programs. These approaches all re-
place absolute logical reasoning with a relaxed version that
yields continuous values reﬂecting the conﬁdence of the
conclusion. Although this approach limits the expressiv-
ity of hypotheses, it potentially allows for gradient-based
methods to be used to learn from large datasets.

The research has primarily developed in three direc-
The ﬁrst concerns imitating logical reasoning
tions.
with tensor calculus [Yang et al., 2017; Dong et al., 2019].
These approaches represent predicates as binary tensors
over the domain of constants and perform reasoning by
chains of tensor products imitating as clause. The second
concerns the relaxation of the subset selection problem
[Evans and Grefenstette, 2018; Si et al., 2019] in which
the task of a neural network is to select a subset of clauses
from a space of pre-deﬁned clauses. The third, neural theo-
rem provers [Rocktäschel and Riedel, 2017] turn the learn-
ing problem towards learning to perform soft uniﬁcation,
which uniﬁes not only the matching symbols but also simi-
lar ones, from a ﬁxed set of proofs.

The major challenge of neural approaches is the inabil-
ity to generalise beyond training data and data efﬁciency.
The majority of these approaches embed logical symbols,
i.e.
they replace symbols with vectors, and therefore a
learned model is unable to work with unseen constants.
Moreover, neural methods often require millions of exam-
ples [Dong et al., 2019] to learn concepts that symbolic ILP
is able to learn from just a few.

7 Limitations and Future Work

The recent advances surveyed in this paper have opened
new problems for future work to address.

Relevance New methods for predicate invention (Section
3.1) and transfer learning (Section 3.2) have improved the
abilities of ILP systems to learn large programs. Moreover,
these techniques raise the potential for ILP to be used in
lifelong learning settings. However, inventing and acquir-
ing new BK could lead to a problem of too much BK, which
can overwhelm an ILP system [Cropper, 2020]. On this is-
sue, a key under-explored topic is that of relevancy. Given
a new induction problem with large amounts of BK, how
does an ILP system decide which BK is relevant? Without
efﬁcient methods of relevance identiﬁcation, it is unclear
how efﬁcient lifelong learning can be achieved.

Probabilistic ILP A principled way to handle noise
is to unify logical and probabilistic reasoning, which
is the focus of statistical relational artiﬁcial intelligence
(StarAI) [Raedt et al., 2016]. While StarAI is a grow-
ing ﬁeld,
inducing probabilistic logic programs has re-
ceived little attention, with few notable exceptions
[Bellodi and Riguzzi, 2015; Raedt et al., 2015], as infer-
ence remains the main challenge. Addressing this issue, i.e.
unifying probabiliy and logic in an inductive setting, would
be a major achievement [Marcus, 2018] and the ILP devel-
opments outlined in this paper will be a crucial element of
the progress.

Explainability Explainability is one of the claimed ad-
vantages of a symbolic representation.
Recent work
[Muggleton et al., 2018a] evaluates the comprehensibility
of ILP hypotheses using Michie’s (1988) framework of ultra-
strong machine learning, where a learned hypothesis is ex-
pected to not only be accurate but to also demonstrably im-
prove the performance of a human being provided with the
learned hypothesis. The paper empirically demonstrates
improved human understanding directly through learned
hypotheses. However, more work is required to better un-
derstand the conditions under which this can be achieved.

Summary As ILP approaches 30, we think that the recent
advances surveyed in this paper puts ILP in a prime position
to have a signiﬁcant impact on AI over the next decade,
especially to address the key limitations of state-of-the-art
machine learning.

References
[Albarghouthi et al., 2017] Aws Albarghouthi, Paraschos Koutris,
Mayur Naik, and Calvin Smith. Constraint-based synthesis of
Datalog programs. In CP, 2017.

[Athakravi et al., 2013] Duangtida Athakravi, Domenico Corapi,
Krysia Broda, and Alessandra Russo. Learning through hypoth-
esis reﬁnement using answer set programming. In ILP, 2013.

[Bain and Srinivasan, 2018] Michael Bain and Ashwin Srini-
vasan.
Identiﬁcation of biological transition systems us-
ing meta-interpreted logic programs. Machine Learning,
107(7):1171–1206, 2018.

[Bellodi and Riguzzi, 2015] Elena Bellodi and Fabrizio Riguzzi.
Structure learning of probabilistic logic programs by searching
the clause space. TPLP, 15(2):169–212, 2015.

[Bengio et al., 2019] Yoshua Bengio, Tristan Deleu, Nasim Ra-
haman, Nan Rosemary Ke, Sébastien Lachapelle, Olexa Bila-
niuk, Anirudh Goyal, and Christopher J. Pal. A meta-transfer
objective for learning to disentangle causal mechanisms. CoRR,
abs/1901.10912, 2019.

[Blockeel and Raedt, 1998] Hendrik Blockeel and Luc De Raedt.
Top-down induction of ﬁrst-order logical decision trees. Artif.
Intell., 101(1-2):285–297, 1998.

[Chollet, 2019] François Chollet. On the measure of intelligence.

CoRR, abs/1911.01547, 2019.

[Cropper and Muggleton, 2015] Andrew

Stephen H. Muggleton.
strategies involving composable objects. In IJCAI, 2015.

and
Learning efﬁcient logical robot

Cropper

[Cropper and Muggleton, 2016] Andrew

Stephen H. Muggleton.

and
https://github.com/metagol/metagol, 2016.

Metagol

Cropper
system.

[Cropper and Muggleton, 2019] Andrew

Stephen H. Muggleton.
Machine Learning, 108(7):1063–1083, 2019.

and
Learning efﬁcient logic programs.

Cropper

[Cropper and Tourret, 2019] Andrew Cropper and Sophie Tour-
ret. Logical reduction of metarules. Machine Learning, Nov
2019.

[Cropper et al., 2015] Andrew Cropper, Alireza Tamaddoni-
Nezhad, and Stephen H. Muggleton. Meta-interpretive
learning of data transformation programs. In ILP, 2015.
[Cropper et al., 2019] Andrew Cropper, Rolf Morel, and Stephen
Muggleton. Learning higher-order logic programs. Machine
Learning, Dec 2019.

[Cropper, 2019] Andrew Cropper. Playgol: Learning programs

through play. In IJCAI, 2019.

[Cropper, 2020] Andrew Cropper. Forgetting to learn logic pro-

grams. In AAAI, 2020.

[Dong et al., 2019] Honghua Dong, Jiayuan Mao, Tian Lin,
Chong Wang, Lihong Li, and Denny Zhou. Neural logic ma-
chines. In ICLR, 2019.

[Dumanˇci´c and Blockeel, 2017] Sebastijan Dumanˇci´c and Hen-
drik Blockeel. Clustering-based relational unsupervised repre-
sentation learning with an explicit distributed representation.
In IJCAI, 2017.

[Dumanˇci´c et al., 2019] Sebastijan Dumanˇci´c,

Tias Guns,
Wannes Meert, and Hendrik Blockeel.
Learning relational
representations with auto-encoding logic programs. In IJCAI,
2019.

[Evans and Grefenstette, 2018] Richard Evans

and Edward
Grefenstette. Learning explanatory rules from noisy data. J.
Artif. Intell. Res., 61:1–64, 2018.

[Gebser et al., 2012] Martin Gebser, Benjamin Kaufmann, and
Torsten Schaub. Conﬂict-driven answer set solving: From the-
ory to practice. Artif. Intell., 187:52–89, 2012.

[Inoue et al., 2014] Katsumi Inoue, Tony Ribeiro, and Chiaki
Sakama. Learning from interpretation transition. Machine
Learning, 94(1):51–79, 2014.

[Kaminski et al., 2019] Tobias Kaminski, Thomas Eiter, and Kat-
sumi Inoue. Meta-interpretive learning using HEX-programs.
In IJCAI, 2019.

[Katzouris et al., 2015] Nikos Katzouris, Alexander Artikis, and
Georgios Paliouras. Incremental learning of event deﬁnitions
with inductive logic programming. Machine Learning, 100(2-
3):555–585, 2015.

[Katzouris et al., 2016] Nikos Katzouris, Alexander Artikis, and
Georgios Paliouras. Online learning of event deﬁnitions. TPLP,
16(5-6):817–833, 2016.

[Kazmi et al., 2017] Mishal Kazmi, Peter Schüller, and Yücel Say-
gin.
Improving scalability of inductive logic programming
via pruning and best-effort optimisation. Expert Syst. Appl.,
87:291–303, 2017.

[Lake et al., 2016] Brenden M. Lake, Tomer D. Ullman, Joshua B.
Tenenbaum, and Samuel J. Gershman. Building machines that
learn and think like people. CoRR, abs/1604.00289, 2016.
[Law et al., 2014] Mark Law, Alessandra Russo, and Krysia
Broda. Inductive learning of answer set programs. In JELIA,
2014.

[Law et al., 2018a] Mark Law, Alessandra Russo, and Krysia
Broda. The complexity and generality of learning answer set
programs. Artif. Intell., 259:110–146, 2018.

[Law et al., 2018b] Mark Law, Alessandra Russo, and Krysia
Broda. Inductive learning of answer set programs from noisy
examples. CoRR, abs/1808.08441, 2018.

[Law et al., 2019] Mark Law, Alessandra Russo, Elisa Bertino,
Krysia Broda, and Jorge Lobo. Representing and learning
grammars in answer set programming. In AAAI, 2019.

[Law et al., 2020] Mark Law, Alessandra Russo, Elisa Bertino,
Krysia Broda, and Jorge Lobo. Fastlas: scalable inductive logic
programming incorporating domain-speciﬁc optimisation cri-
teria. In AAAI, 2020.

[Lin et al., 2014] Dianhuan Lin, Eyal Dechter, Kevin Ellis,
Joshua B. Tenenbaum, and Stephen Muggleton. Bias reformu-
lation for one-shot function induction. In ECAI, 2014.

[Marcus, 2018] Gary Marcus. Deep learning: A critical appraisal.

CoRR, abs/1801.00631, 2018.

[Michie, 1988] Donald Michie. Machine learning in the next ﬁve

years. In EWSL, 1988.

[Muggleton and Buntine, 1988] Stephen Muggleton and Wray L.
Buntine. Machine invention of ﬁrst order predicates by invert-
ing resolution. In ICML, pages 339–352, 1988.

[Muggleton and Raedt, 1994] Stephen Muggleton and Luc De
Inductive logic programming: Theory and methods.

Raedt.
J. Log. Program., 19/20:629–679, 1994.

[Muggleton et al., 2012] Stephen Muggleton, Luc De Raedt,
David Poole, Ivan Bratko, Peter A. Flach, Katsumi Inoue, and
Ashwin Srinivasan. ILP turns 20 - biography and future chal-
lenges. Machine Learning, 86(1):3–23, 2012.

[Muggleton et al., 2014] Stephen H. Muggleton, Dianhuan Lin,
Niels Pahlavi, and Alireza Tamaddoni-Nezhad.
Meta-
interpretive learning: application to grammatical inference.
Machine Learning, 94(1):25–49, 2014.

[Muggleton et al., 2015] Stephen H. Muggleton, Dianhuan Lin,
and Alireza Tamaddoni-Nezhad. Meta-interpretive learning
of higher-order dyadic Datalog: predicate invention revisited.
Machine Learning, 100(1):49–73, 2015.

[Muggleton et al., 2018a] S.H. Muggleton, U. Schmid, C. Zeller,
A. Tamaddoni-Nezhad, and T. Besold. Ultra-strong machine
learning - comprehensibility of programs learned with ILP. Ma-
chine Learning, 107:1119–1140, 2018.

[Muggleton et al., 2018b] Stephen Muggleton, Wang-Zhou Dai,
Claude Sammut, Alireza Tamaddoni-Nezhad, Jing Wen, and
Zhi-Hua Zhou. Meta-interpretive learning from noisy images.
Machine Learning, 107(7):1097–1118, 2018.

[Muggleton, 1991] Stephen Muggleton. Inductive logic program-

ming. New Generation Comput., 8(4):295–318, 1991.

[Muggleton, 1995] Stephen Muggleton. Inverse entailment and
progol. New Generation Comput., 13(3&4):245–286, 1995.
[Quinlan, 1990] J. Ross Quinlan. Learning logical deﬁnitions

from relations. Machine Learning, 5:239–266, 1990.

[Raedt et al., 2015] Luc De Raedt, Anton Dries,
Ingo Thon,
Guy Van den Broeck, and Mathias Verbeke.
Inducing proba-
bilistic relational rules from probabilistic examples. In IJCAI,
2015.

[Raedt et al., 2016] Luc De Raedt, Kristian Kersting, Sriraam
Natarajan, and David Poole. Statistical Relational Artiﬁcial In-
telligence: Logic, Probability, and Computation. Synthesis Lec-
tures on Artiﬁcial Intelligence and Machine Learning. Morgan
& Claypool Publishers, 2016.

[Raghothaman et al., 2020] Mukund Raghothaman, Jonathan
Mendelson, David Zhao, Mayur Naik, and Bernhard Scholz.
Provenance-guided synthesis of Datalog programs. PACMPL,
2020.

[Ray, 2009] Oliver Ray.

Nonmonotonic abductive inductive

learning. J. Applied Logic, 7(3):329–340, 2009.

[Rocktäschel and Riedel, 2017] Tim Rocktäschel and Sebastian
Riedel. End-to-end differentiable proving. In NIPS, 2017.
[Si et al., 2018] Xujie Si, Woosuk Lee, Richard Zhang, Aws Al-
Syntax-
In ESEC/SIGSOFT.

barghouthi, Paraschos Koutris, and Mayur Naik.
guided synthesis of Datalog programs.
ACM, 2018.

[Si et al., 2019] Xujie Si, Mukund Raghothaman, Kihong Heo,
and Mayur Naik. Synthesizing Datalog programs using numer-
ical relaxation. In IJCAI, 2019.

[Srinivasan, 2001] A. Srinivasan. The ALEPH manual. Machine
Learning at the Computing Laboratory, Oxford University, 2001.
[Wang et al., 2014] William Yang Wang, Kathryn Mazaitis, and
William W. Cohen. Structure learning via parameter learning.
In CIKM, 2014.

[Yang et al., 2017] Fan Yang, Zhilin Yang, and William W Cohen.
Differentiable learning of logical rules for knowledge base rea-
soning. In NIPS 2017, 2017.

