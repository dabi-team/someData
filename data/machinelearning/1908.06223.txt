1

9
1
0
2

g
u
A
0
2

]

G
L
.
s
c
[

2
v
3
2
2
6
0
.
8
0
9
1
:
v
i
X
r
a

A Symbolic Neural Network Representation and its
Application to Understanding, Verifying, and Patching
Networks

MATTHEW SOTOUDEH, University of California, Davis, United States of America
ADITYA V. THAKUR, University of California, Davis, United States of America

Analysis and manipulation of trained neural networks is a challenging and important problem. We propose a
symbolic representation for piecewise-linear neural networks and discuss its efficient computation. With this
representation, one can translate the problem of analyzing a complex neural network into that of analyzing a
finite set of affine functions. We demonstrate the use of this representation for three applications. First, we
apply the symbolic representation to computing weakest preconditions on network inputs, which we use to
exactly visualize the advisories made by a network meant to operate an aircraft collision avoidance system.
Second, we use the symbolic representation to compute strongest postconditions on the network outputs,
which we use to perform bounded model checking on standard neural network controllers. Finally, we show
how the symbolic representation can be combined with a new form of neural network to perform patching;
i.e., correct user-specified behavior of the network.

1 INTRODUCTION

1.1 Introduction to Neural Networks
The past decade has seen the rise of deep neural networks (DNNs) [Goodfellow et al. 2016] to
solve a variety of problems, including image recognition [Krizhevsky et al. 2017; Szegedy et al.
2016], natural-language processing [Devlin et al. 2018], and autonomous vehicle control [Julian
et al. 2018]. Typically, DNNs are trained using large data sets, validated on a test set, and then
deployed. As they permeate more and more systems, there is growing need for tools to more deeply
analyze and modify such networks once they have been trained. This paper presents techniques
for understanding, verifying, and patching (correcting) trained neural networks. These various
applications rely on a new symbolic representation of neural networks introduced in this paper.
In this work, we focus on the major class of piecewise-linear neural networks, which can be
decomposed into a set of affine functions (Definition 1). For example, the function max(x, 0) is
piecewise-linear; when x ≤ 0 it takes the affine form x (cid:55)→ 0, and when x > 0 it takes the affine form
x (cid:55)→ x. Although this may seem like a restrictive definition, we will show in Section 3 that neural
networks using the most common building blocks (like 2DConvolution, ReLU, and MaxPool
layers) are in fact piecewise-linear. Notably, this work deals with trained networks (we assume that
the training has been already been completed), and makes no restriction on the training process.

1.2 Contributions

In Section 3, we propose a symbolic
A symbolic representation for deep neural networks.
representation for neural networks which expresses a complex, highly-non-linear neural network
in terms of a set of affine functions, each of which fully captures the behavior of the network for
a particular subspace of the input domain. We refer to this subspace as the restriction domain
of interest, and consider in this work two-dimensional restriction domains of interest, which we

Authors’ addresses: Matthew Sotoudeh, Computer Science, University of California, Davis, Davis, California, 95616, United
States of America, masotoudeh@ucdavis.edu; Aditya V. Thakur, Computer Science, University of California, Davis, Davis,
California, 95616, United States of America, avthakur@ucdavis.edu.

2018. 2475-1421/2018/1-ART1 $15.00
https://doi.org/

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

 
 
 
 
 
 
1:2

Matthew Sotoudeh and Aditya V. Thakur

show in Section 8 leads to many important applications. Fundamentally, this representation allows
us to translate questions about the highly-non-linear neural network into a series of questions
about finitely-many affine functions, which are one of the best-studied class of functions in modern
mathematics. As we will see, this symbolic representation enables understanding, verifying, and
patching trained neural networks.

In Section 5, we show how
Understanding network behavior using weakest precondition.
the symbolic representation can be used to compute weakest preconditions on neural networks;
i.e., all points in the input space which are mapped to a particular subset of the output space by
the network. We show that prior work can be adapted to compute preconditions, but they are
not guaranteed to produce the weakest precondition (i.e., they produce a subset of the points).
This weakest-precondition primitive allows us to understand the behavior of a neural network by
exactly visualizing decision boundaries. In particular, we apply this technique to the aircraft collision
avoidance system ACAS Xu [Julian et al. 2018], comparing the use of the proposed symbolic
representation to prior work based on an (over-approximating) abstraction of the network function.
In Section 8.1 we use the preconditions to plot network decision boundaries, and compare against
the preconditions found using a representation from prior work. We find that the representations
in prior work are not precise enough to compute particularly useful preconditions, whereas the
representation used in this work can find weakest preconditions in a matter of seconds.

In Section 6,
Bounded model checking of safety properties using strongest postcondition.
we show how the symbolic representation can be adapted to compute strongest post-conditions on
the network output, i.e. all outputs reachable by the network from a set of inputs.

In Section 8.2, we use this to perform bounded model checking [Biere et al. 2009] on three
reinforcement learning controller models, comparing against the state-of-the-art neural network
SMT solver ReluPlex [Katz et al. 2017]. We find that the ability to directly handle disjunctions as
well as re-use information across multiple verification steps allows the proposed technique to verify
significantly more steps in the same time limit (including finding a counter-example to the safety
specification for one of the models).

In Section 7, we consider the problem of patching a neural
Patching deep neural networks.
network: changing a small number of weights in the network to precisely manipulate the network
decision boundaries (eg. to fix erroneous or undesired behavior). Three features in particular make
this a challenging problem:

(1) Neural networks are usually high-dimensional and highly non-linear, pushing the bounds of

traditional SMT solvers such as Z3 [de Moura and Bjørner 2008].

(2) The behavior we would like to patch occurs over entire polytopes (containing infinitely many
points) in the input region, making it difficult to apply gradient-descent-based methods which
assume a finite set of training points.

(3) One may not have the original training or test data for a network (eg. due to user privacy
concerns), making it difficult to ensure that applying a patch to fix one set of erroneous
behavior does not result in corrupting the behavior for another set of inputs.

We discuss prior work that relies on over-approximations and/or differentiable relaxations, but
find them sub-optimal for this particular problem. We then define a new class of neural networks
termed Masking Networks (Section 7.2), and show how standard networks can be transformed into
equivalent Masking Networks. Finally, we show how our symbolic representation can be used
on such networks to lower the problem of patching on polytopes to that of patching on a finite set
of vertices, intuitively similar to how the simplex algorithm lowers optimization over a polytope
to optimization over a finite set of vertices. These changes allow us to rephrase the problem of
patching as solving a finite MAX SMT problem. We discuss a number of approaches to this problem,

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:3

including using the Z3 theorem prover [de Moura and Bjørner 2008], which we find to be too slow
for our purposes. We then discuss an algorithm that can exactly and efficiently solve such problems
when only a single weight is changed. Finally, we greedily apply that solver to find better solutions
by changing multiple weights.

In Section 8.3 we test this network patching technique on an aircraft collision-avoidance network
with three patch specifications. We show quantitatively and qualitatively that patching is effective
even with relatively few iterations. We also find that patches made to one restriction domain of
interest can have beneficial effects on others (i.e., patches generalize).

Section 2 presents an overview of the symbolic representation and its applications, while Section 9

describes related work and Section 10 summarizes the main results of this paper.

2 OVERVIEW

2.1 Deep Neural Networks and Piecewise-Linear Functions
Deep neural networks [Goodfellow et al. 2016] generally consist of multiple layers (which are
themselves vector-valued functions) applied sequentially to an input vector. Thus, a DNN can be
thought of as a function f = fn ◦ fn−1 ◦ · · · ◦ f1, where fi is function representing the ith layer.
Four layer types are particularly common in feed-forward neural networks:

(1) FullyConnected layers correspond to arbitrary affine maps, where the particular map is

determined by the weight matrix of the layer.

(2) 2DConvolution layers correspond to a restricted subset of affine maps particularly well-

suited to image recognition and parameterized by a filter tensor.

(3) ReLU layers effectively enforce a lower-bound on the value of each coefficient in the output
vector. If the output of the previous layer was x, then ReLU(x)i = 0 when xi ≤ 0 and xi
when xi > 0 (where ReLU(x)i is the ith component of the layer’s output vector). For example,
ReLU((10, −2)) = (10, 0).

(4) MaxPool layers condense their input vectors by taking only the maximum value in each of

a number of coefficient groups.

(5) BatchNorm layers normalize each component given a fixed mean and variance.

Of particular importance to our paper, all of these layers are examples of piecewise-linear functions:

Definition 1. A function f : A → B is referred to as a piecewise-linear function if its input domain
A can be partitioned by a finite set of (possibly unbounded) convex polytopes {P1, P2, . . . , Pn } such
that, within any partition Pi ⊆ A, there exists an affine map Fi : Pi → B satisfying f (x) = Fix for
any x ∈ Pi .

In other words, each layer function can be broken up into finitely many affine functions, with
one of those functions being applied depending on the location in the input space of x. For example,
the ReLU function, when restricted to any one orthant (i.e., where the signs of all input coefficients
are constant), corresponds to a single affine map that zeros out entries with a non-positive sign.
Because (1) there are finitely many orthants that together partition the input space, (2) each orthant
can be expressed as a convex polytope, and (3) within each orthant ReLU(x) is affine, we can say
that ReLU is a piecewise-linear function.

2.2 Restriction Domains of Interest
One particular insight which we will utilize throughout the paper is that, when analyzing networks,
one is usually only interested in a particular domain of interest. For example, suppose a network
f : R2 → R1 predicts the probability of acquiring cancer in the next five years, taking as input a
vector with two components, x = (x1, x2), with x1 being the age of the patient and x2 being the

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:4

Matthew Sotoudeh and Aditya V. Thakur

A

X

B

f : A → B

f↾X

: X → B

f↾X (x)

Fig. 1. An illustration of restriction domain of interest. The function f has a three-dimensional domain and
f↾X is f restricted to a particular two-dimensional restriction domain of interest X .

percent of their immediate family that has died of cancer. Then, although f is theoretically able to
make predictions about, say, 1, 000-year-old individuals with 110% of their immediate family having
died of cancer, such scenarios are in practice impossible. Furthermore, in particular scenarios, we
may be concerned with an even smaller subspace of the input domain, for example if we only want
to understand how the network classifies children under the age of 10.

We call such restricted subsets of the input domain the restriction domain of interest for the
particular analysis being performed, usually denoted by X , and to indicate that we only intend
to consider the behavior over the restriction domain of interest, we will often write f↾X (read “f
restricted to the restriction domain of interest X ”). This is illustrated in Figure 1, where a function
with a three-dimensional domain is restricted to a particular two-dimensional restriction domain
of interest. In Section 4.3 we will focus on two-dimensional restriction domains of interest, which
we will show can help significantly improve the efficiency of our analysis.

Definition 2. A function f : A → B restricted to a particular restriction domain of interest X ⊆ A,

denoted f↾X , is a new function f↾X : X → B such that f↾X (x) = f (x) for any x ∈ X .

2.3 A Symbolic Representation for Deep Neural Networks
In this work, we develop a symbolic representation for a deep neural network f = fn ◦ fn−1 ◦ · · · ◦ f1,
denoted (cid:98)f , that enables precise and efficient analyses of f . The symbolic representation partitions
the input domain of f such that, within each partition, the output of f (x) is affine with respect to
x. That is, (cid:98)f = {(P1, F1), (P2, F2), . . . , (Pn, Fn)}, where the set {P1, P2, . . . , Pn } partitions the domain
of f and each Fi is an affine map that exactly matches the output of f on any points in Pi . The
existence of such a partitioning is guaranteed for most common neural networks by Theorem 7
and the fact that compositions of piecewise-linear functions are themselves piecewise-linear.

Our key insight is that the symbolic representation (cid:98)f allows us to translate problems related to a
single highly-non-linear network f into a series of problems dealing with finitely-many affine functions.
The efficiency of this symbolic representation can be further improved by noting that we are usually
only concerned about f↾X for some restriction domain of interest X (Definition 2). Thus, instead of
computing the full (cid:98)f , we only need to compute (cid:99)f↾X . In this paper, we consider two-dimensional
restriction domains of interest X .

Consider the following neural network N1 defined as:

f (x) =

(cid:20)−2
1

1
1
2 −1

(cid:21)

1
2

ReLU

−1


1


0


0.5



(cid:169)
(cid:173)
(cid:173)
(cid:173)
(cid:171)

0.25
0.5
1
0.5

1


1


0


2



+

x1


x2


x3










1




−1




−1




−5





(cid:170)
(cid:174)
(cid:174)
(cid:174)
(cid:172)

+

(cid:21)

(cid:20)1
0

(1)

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:5

(a) Linear partitions in (cid:100)f↾X for the network

(b) Classification regions of the network

Fig. 2. Symbolic representation of neural network N1 defined by function f in Equation 1

This network N1 transforms points in a three-dimensional space (coordinates x1, x2, x3) to points
in a two-dimensional space (coordinates y1, y2). The output of this network may be interpreted,
perhaps, to be a prediction as to whether a particular insect can survive in a certain spot. We define
two classification regions, the first is H = {y | y2 > y2}, which we may interpret as the network
predicting a spot is “habitable,” while the second is U = {y | y1 > y2}, which we might interpret as
the network predicting a spot as “uninhabitable.” Note that, in general, classification regions need
not span the entire output space—for example, in this scenario, we do not define the classification
of the network when y1 = y2. Such a network might have been trained using gradient descent
and a set of labeled training points collected by surveying a number of points in the (“real-world”)
space of interest.

Suppose we are interested in how the network N1 behaves on a particular plot of land at sea-level,
X = ConvexHull({(0, 0, 0), (0, 3, 0), (3, 0, 0), (3, 3, 0)}), where ConvexHull(S) is the smallest convex
set that contains the set of points S. We can compute (cid:99)f↾X for the f in Equation 1, which is visualized
= Fi can be
in Figure 2a. Each colored region in Figure 2a shows a partitions Pi of X such that f↾Pi
written as an affine map. The particular (cid:99)f↾X = {(P1, F1), (P2, F2), . . . , (P6, F6)} is listed below:

(cid:26)(cid:18)

(cid:100)f↾X =

ConvexHull({(0.5, 1, 0), (1, 0, 0), (1.25, 1, 0)}), x (cid:55)→

(cid:20)3
0
1 1.25

(cid:21)

−1
3

x +

ConvexHull({(0, 2, 0), (0, 3, 0), (0.5, 1, 0), (1.25, 1, 0), (1.75, 3, 0)}), x (cid:55)→

(cid:21)

−1
3

x +

(cid:21) (cid:19)

(cid:20)−3
0

,

(cid:18)

(cid:18)

(cid:18)

(cid:18)

(cid:18)

ConvexHull({(0, 1, 0), (0, 2, 0), (0.5, 1, 0)}), x (cid:55)→

ConvexHull({(0, 0, 0), (0, 1, 0), (0.5, 1, 0), (1, 0, 0)}), x (cid:55)→

ConvexHull({(1, 0, 0), (1.25, 1, 0), (3, 0, 0), (3, 1, 0)}), x (cid:55)→

ConvexHull({(1.25, 1, 0), (1.75, 3, 0), (3, 1, 0), (3, 3, 0)}), x (cid:55)→

,

(cid:21) (cid:19)

(cid:20)−2
−1
(cid:20)3
1
1 0.25
(cid:21) (cid:19)

,

(cid:20)−2
2
(cid:21)

(cid:20) 2
−1 −0.75

(cid:21)

x +

0.5 −2
1
(cid:20) 2 −0.5 −2
−1 0.25
1
(cid:20)1 0.5 1
2
1
2
(cid:20)1 1.5 1
2
0
2

(cid:21)

x +

(cid:21) (cid:19)

,

(cid:20)−1
1
(cid:21) (cid:19)

,

x +

(cid:20) 0
−2

(cid:21)

x +

(cid:21) (cid:19)(cid:27)

(cid:20)−1
−1

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

0.00.51.01.52.02.53.00.00.51.01.52.02.53.00.00.51.01.52.02.53.00.00.51.01.52.02.53.01:6

Matthew Sotoudeh and Aditya V. Thakur

2.4 Understanding Network Behavior using Weakest Precondition
A first natural question to ask about a neural network is what inputs result in a particular set of
outputs?Answering such questions corresponds to computing the weakest precondition, i.e. all points
in X that are mapped to Y by f↾X : WPre(f↾X , Y ) = {x ∈ X | f (x) ∈ Y }. Section 5.3 shows how (cid:99)f↾X
can be used to efficiently compute this set, which may in general be non-convex.

For example, in our running scenario, we may wish to ask: which areas does the network N1 predict
will be habitable? The polytope H = {y | y2 > y1} denotes the set of output points that are habitable,
similarly U for uninhabitable points. Using (cid:99)f↾X (Figure 2a), we can compute WPre(f↾X , H ) and
WPre(f↾X , U ), which represent the set of all habitable and uninhabitable points in X , respectively.
Figure 2b plots these precondition sets on a two-dimensional axis with each set assigned a different
color. Thus, we can precisely and exactly visualize the decision boundaries of a deep neural network
using WPre(f↾X , Y ).

Effectively, within each linear partition in Figure 2b (delineated with white borders), the network’s
output is affine, and thus the decision boundary is linear — notice that the decision boundary is
a single straight line in any given linear partition in Figure 2b, even though the overall decision
boundaries have “corners.” This allows us to quickly and precisely determine decision boundaries
within each linear partition using standard linear algebra techniques (Section 5.3). An evaluation of
WPre(f↾X , Y ) on a large network is presented in Section 8.1, where we produce figures like Figure 3a
that show how the advisory made by an aircraft collision-avoidance network depends on the location
of an intruder.

2.5 Bounded Model Checking of Safety Properties using Strongest Postcondition
Consider another neural network, which controls a motor attached to an inverted pendulum which
is in turn described by its current position θ and angular velocity ω. The network takes θ and ω as
inputs, and produces as output the angular acceleration to apply to the pendulum by the motor.
The network is trained to keep the pendulum inverted, but it has not been formally verified that
the network correctly accomplishes this goal for all valid starting conditions.

In Section 6, we address the problem of bounded model checking for such control networks.
In particular, we show how the symbolic representation enables us to compute the strongest
postcondition, i.e. the set of all possible outputs given that the input is in a particular region:
SPost(f , X ) = { f (x) | x ∈ X }. Consequently, we show how to verify the following claim for the
inverted pendulum controller: Starting from any valid initial condition and applying the network
controller to the system for K time-steps, there is no timestep for which the pendulum becomes non-
inverted (i.e., dips below the horizontal).

In Section 8.2, we evaluate our approach against one using ReluPlex [Katz et al. 2017] on the
pendulum model and two other standard neural network controller models from Zhu et al. [2019].

2.6 Patching Deep Neural Networks
Finally, we introduce the problem of patching a neural network. Patching a network N entails
fixing the behavior of N in a particular region R of the input space by modifying the weights of N .
For example, in Figure 3a, we see a visualization of the actions suggested by an aircraft collision
avoidance system when an intruder is at different places relative to the ownship. For the most part,
the network’s outputs seem reasonable; when the intruder is reasonably far away, it reports that
the plane is “clear of conflict” (blue), when the intruder is nearby but on the left of the plane it
instructs to make a “hard right” (dark purple), etc. However, we can also see that there are a number
of regions in the input space where the network seems to make unsafe suggestions, eg. when the
intruder is behind-and-to-the-left of the plane, we see a “band” of light orange that indicates the

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:7

(a) Network visualization.

Legend:

Clear-of-Conflict, Weak Right,

(b) Patched network visualization
(plane icons removed to better show
decision boundaries).

Strong Right,

Strong Left, Weak Left.

Fig. 3. Visualizing preconditions for and patching an aircraft collision avoidance network.

network has instructed a “weak left turn,” which would actually turn the ownship towards the
intruder. We may want to patch this behavior, i.e. modify the weights of the network such that
the network instead instructs “weak right,” which would turn the plane away from the intruder. A
patch specification describes which regions of the input space we want to change the classification
over and which we want the classification to stay the same.

With this patch specification in hand, we can formulate the problem as a MAX-SMT instance
that can, in theory, be solved with an SMT solver such as Z3 [de Moura and Bjørner 2008]. However,
the inherently non-linear and high-dimensional nature of our networks makes this infeasible. To
remedy this, we transform the network into an equivalent Masking Network, described in Section 7.2.
Then, we show in Theorem 14 how to use (cid:98)f to translate this patch specification into a set of (finitely
many) key points in the input space, for which patching on the key points is equivalent to patching
on the regions. This allows us to lower the problem of patching on infinite regions to patching on
finitely-many points, similar to how the simplex algorithm lowers optimization on polytopes to
optimization on vertices. If we utilize these key points and restrict the number of weights we change
at any one iteration, we show how to translate the previously-non-linear MAX-SMT instance into a
linear one. Finally, we discuss a greedy MAX-SMT solver that can quickly find updates to individual
weights that will maximize the number of key points with the correct classification. The result of
this process is shown in Figure 3b, where after changing only five weights the offending region has
been removed.

In Section 8.3, we perform this process for the ACAS Xu network for a variety of different patch
specifications, finding that it is able to effectively patch network behavior and that behavior patched
in one region of the input space generalizes well to other regions.

3 A SYMBOLIC REPRESENTATION FOR DEEP NEURAL NETWORKS
In this section, we will introduce our symbolic function representation and discuss a number of
immediate theoretical results relating to its definition.

In all below discussion, we will use the term “polytope” or “(bounded) polytope” to refer to the
convex hull of finitely many points while we will use “(potentially unbounded) polytope” to refer
to the intersection of finitely many half-spaces.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:8

Matthew Sotoudeh and Aditya V. Thakur

Given a function f : A → B where A ⊆ Ra, B ⊆ Rb , we represent our symbolic representation (cid:98)f

as a set (cid:98)f = {(P1, F1), (P2, F2), . . . , (Pn, Fn)}, where:

(1) The set {P1, P2, . . . , Pn } should have each Pi ⊆ A and, further, should partition A (the domain

of f ), except possibly for overlapping boundaries.

(2) Given any such (Pi , Fi ) pair, with Fi : Pi → B, the following holds: ∀x ∈ Pi : f (x) = Fi (x).
These two requirements describe a symbolic representation of f by breaking its input into regions

Pi where the behavior of f is captured by a (possibly simpler) function Fi .

However, as described, there is no reason to believe that the constituent Fi s will be more analysis-
friendly than the original function f ; indeed, (cid:98)f = {(A, f )} meets the constraints listed above but
clearly gives us no additional insight into f .

To remedy this, we further restrict our description to a form which noticeably improves our

ability to analyze f :

(3) Each Pi is a convex polytope.
(4) Each Fi : Pi → B is affine.
Indeed, the first condition ensures that the partitioning is efficiently representable and manipu-
latable, while the second condition ensures that we can use standard linear algebra techniques and
algorithms to perform the desired analysis within any given partition.

Definition 3. Given a function f : A → B where A ⊆ Ra and B ⊆ Rb , we define the symbolic

representation of f , written (cid:98)f , to be a set of tuples (cid:98)f = {(P1, F1), . . . , (Pn, Fn)}, such that:

(1) The set {P1, P2, . . . , Pn } partitions the domain of f , except possibly for overlapping bound-

aries.

(2) Given any such (Pi , Fi ) pair, the following holds: ∀x ∈ Pi : f (x) = Fi (x).
(3) Each Pi is a convex polytope.
(4) Each Fi : Pi → B is affine.

As discussed in Section 2.2, we can often improve the efficiency of the symbolic representation
by only computing it over the restricted domain X , which we call the symbolic representation of
f restricted to X and write (cid:99)f↾X . Notably, Definition 3 still holds; we have simply explicitly stated
that the domain A is the set we have defined as X . Thus, in definitions we will usually only use the
explicit syntax (cid:99)f↾X when we wish to place restrictions on the possible values of the domain X (for
example, to state that an algorithm only works when the domain is bounded).

Finally, we define another primitive, denoted by the operator ⊗ and sometimes referred to as
Extend, such that Extend(h, (cid:98)д) = h ⊗ (cid:98)д = (cid:154)h ◦ д. This is the primitive which we will implement
in our algorithms, as it enables easy composition across multiple layers in a neural network. For
example, suppose one wishes to compute (cid:99)f↾X where f = fn ◦ fn−1 ◦ · · · ◦ f1, and has access to
algorithms for computing Extend(fi , ·) for each composed function fi .

Then, we can initially define the identity map I : x (cid:55)→ x, which is affine across its entire input
space, so we always have (cid:99)I↾X = {(X , I )} Then, by the definition of Extend(f1, ·), we can compute:
f1 ⊗ (cid:99)I↾X = (cid:156)(f1 ◦ I )↾X
(The final equality holds as, by the definition of the identity map I ,
д ◦ I = д holds for any function д.)

= (cid:100)f1↾X

We can then iteratively apply this procedure to inductively compute (cid:156)(fi ◦ fi−1 ◦ · · · f1)↾X

from

(cid:156)(fi−1 ◦ · · · f1)↾X
(cid:156)(fn ◦ fn−1 ◦ · · · ◦ f1)↾X

= (cid:99)f↾X .

like so: fi ⊗ (cid:156)(fi−1 ◦ · · · ◦ f1)↾X

= (cid:156)(fi ◦ fi−1 ◦ · · · ◦ f1)↾X

until we have computed

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:9

A number of properties follow immediately from these definitions, which we summarize here and
prove in full in Appendices A—F. First, we find a number of negative results, describing functions
(or classes of functions) for which (cid:98)f and (cid:99)f↾X cannot be computed.

Theorem 4. There exists a continuous, fully-differentiable function f such that (cid:98)f does not exist.

Theorem 5. There exists a continuous, fully-differentiable function f such that (cid:99)f↾X does not exist

for any non-singleton and non-empty choice of X .

Both of these theorems can be understood by considering the function f (x) = x 2. The key
insight is that f behaves non-linearly on its entire input domain; there are no two x1 < x2 such that
f (x + x ′) = f (x) + f (x ′) and f (cx) = c f (x) for all x1 ≤ x, x ′ ≤ x2. However, as the next theorem
shows, sometimes restricting the function to a particular input domain can make the symbolic
representation computable.

Theorem 6. There exists a continuous, fully-differentiable function f and a non-singleton, non-

empty polytope X such that (cid:98)f does not exist but (cid:99)f↾X does.

An example for this theorem can be seen in the function f (x1, x2) = sin2 x1 + cos2 x2, which in
general behaves non-linearly, but when restricted to input points where x1 = x2, it satisfies the
affine relation f (x1, x2) = 1. A similar example is the function f (x1, x2) = (x1 + x2)(x1 − x2), which
is non-linear except when x1 − x2 equals a constant.

Next, we have a number of positive results, showing that ⊗ both exists and is computable for

functions that are commonly composed to create neural networks.

Theorem 7. For any piecewise-linear function f , f ⊗ (cid:98)д is computable for any

(cid:98)д.

Corollary 1. FullyConnected ⊗ (cid:98)д is computable for any
(cid:98)д.
(cid:98)д.
Corollary 2. 2DConvolution ⊗ (cid:98)д is computable for any
Corollary 3. BatchNorm ⊗ (cid:98)д is computable for any
Corollary 4. ReLU ⊗ (cid:98)д is computable for any
(cid:98)д.
Corollary 5. MaxPool ⊗ (cid:98)д is computable for any
Corollary 6. f ⊗ (cid:98)д is computable for any
FullyConnected, 2DConvolution, BatchNorm, ReLU, and MaxPool layers.

(cid:98)д.

(cid:98)д.

(cid:98)д and neural network f consisting of sequentially-applied

4 ALGORITHMS FOR COMPUTING (cid:99)f↾X
In this section, we discuss algorithms for computing (cid:99)f↾X for piecewise-linear functions (see Defini-
tion 1). Recall the primitive Extend, where Extend(h, (cid:98)д) = h ⊗ (cid:98)д = (cid:154)h ◦ д. We showed in Section 3
that, as long as you can compute Extend for each layer type in a network, you can compute (cid:98)f
for the entire network. Thus, we focus in this section on algorithms for computing Extend for
common neural network layers.

In Section 4.1 we define a number of standard functions that we will use in the algorithms.
In Section 4.2, we describe the rectified linear unit, a common piecewise-linear function used in
deep neural networks. In Section 4.3, we present an efficient algorithm for the case when the
restriction domain of interest is two-dimensional. In Section 4.4 we generalize the ReLU algorithm
to arbitrary piecewise-linear functions with two-dimensional restriction domain of interest. Finally,
in Section 4.5, we discuss the benefits of the polytope representation used by our algorithm.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:10

Matthew Sotoudeh and Aditya V. Thakur

4.1 Definitions and Common Functions
Here we define a number of functions which we will use in our algorithms:

(1) Given a (bounded) polytope X , Vert(X ) returns a list of its vertices in counter-clockwise

order, repeating the initial vertex at the end.

(2) Given a set of points, ConvexHull(X ) computes their convex hull (i.e., smallest bounded

polytope containing all points in X ).

(3) Given a scalar value x, Sign(x) computes the sign of that value (i.e., −1 if x < 0, +1 if x > 0,

and 0 if x = 0).

(4) Given a polytope X which must lie in a single orthant, OrthantSign(X ) computes the

per-coefficient sign corresponding to that orthant.
For example, if X = ConvexHull({(1, −1), (2, −3), (4, −2)}), then OrthantSign(X ) = (1, −1).
(5) Given a polytope X and affine map A, A#(X ) represents the polytope formed by applying A

to every point in X .

4.2 A case study in PWL Functions: The Rectified Linear Unit
The Rectified Linear Unit function, ReLU, is one of the standard neural network non-linearities
used today. Recall from Section 2.1 that it can be defined as a piecewise-linear function taking in
vector x = (x1, x2, . . . , xn) and computing ReLU(x) = (ReLU(x)1, . . . , ReLU(x)n) where:

ReLU(x)i =

(cid:40)0
xi
Geometrically, the ReLU function can be thought of as projecting points onto the faces of the
positive orthant by zeroing-out negative coefficients. Notably, if a set of points all lie in the same
orthant (i.e., all have the same sign), then applying ReLU to all of them corresponds to applying a
single affine projection to all of them (namely, the identity map with non-positive entries on the
diagonal zeroed out). Thus, intuitively the computation can be broken down into multiple affine
projections, one for the portion of the polytope in each orthant.

xi ≤ 0
xi > 0

4.3 Input-Aware, Rectified Linear Units in Two Dimensions
(cid:98)д involves only bounded,
We now present an efficient algorithm for computing ReLU ⊗ (cid:98)д when
two-dimensional polytopes. This algorithm strives to display both efficient best- and worst-case
execution time. The key insight is that, when a polytope is all in a single orthant, the application of
ReLU is an affine function. We read each polytope as a counter-clockwise set of vertices, following
around the edges between vertices until the edge of the polytope intersects an orthant boundary.
At that point, we split the polytope in two, such that each half lies on only one side of the orthant
boundary. Repeating this process recursively ensures that the resulting polytopes lie on only one
side of all orthant boundaries, i.e. each lies completely in a single orthant.

Notably, in the best-case scenario where each partition is in a single orthant, the algorithm
never calls SplitPlane() at all — it simply iterates over all of the n input partitions, checks their v
vertices, and appends to the resulting set (for a best-case complexity of O(nv)). In the worst case, it
splits each polytope in the queue on each face, resulting in exponential time complexity. In practice,
however, we find that this algorithm is very efficient and can be applied to real-world networks
effectively (see Section 8).

The proofs of the following theorems can be found in Appendices G—H:

Theorem 8. Algorithm 1 correctly splits a 2D polytope ConvexHull(V ) by the hyperplane xd = 0.

Theorem 9. Algorithm 2 correctly computes (cid:156)ReLU ◦ д↾X

.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:11

Algorithm 1: SplitPlane(V , F , i, j, d)
Input: V , the vertices of the polytope in the input space of д. F , the affine map that corresponds to д

within ConvexHull(V ). i is the index of the last vertex lying on the same side of the orthant face
as V1. j is the index of the last vertex lying on the opposite side of the orthant face as V1. d is the
index of the orthant face, i.e. the face is xd

= 0.
Output: {P1, P2}, two sets of vertices whose convex hulls form a partitioning of V such that each lies on

F (Vi )d
F (Vi +1)d −F (Vi )d
F (Vj )d
F (Vj+1)d −F (Vj )d

only one side of the xd

= 0 hyperplane.

1 pi ← Vi −

(Vi+1 − Vi )

(Vj+1 − Vj )

2 pj ← Vj −
3 A ← {pi , pj } ∪ {v ∈ V | Sign(vd ) = Sign(Vi d )}
4 B ← {pi , pj } ∪ {v ∈ V | Sign(vd ) = Sign(Vj d )}
5 return {A, B}

Algorithm 2: ReLU ⊗ (cid:98)д for two-dimensional
Input: (cid:98)д = {(P1, F1), . . . , (Pn, Fn )}.
Output: (cid:156)ReLU ◦ д↾X

(cid:98)д partitions.

1 W ← ConstructQueue((cid:100)д↾X )
2 Y ← ∅
3 while W not empty do
4

P, F ← Pop(W )
V ← Vert(P)
K ← {k | ∃i, j : Sign(F (Vi )k ) > 0 ∧ Sign(F (Vj )k ) < 0}
if K = ∅ then

Y ← Y ∪ {(P, ReLU[OrthantSign(F
continue

#(P))] ◦ F )}

k ← any element from K
i ← arg max
j ← arg max
for V ′ ∈ SplitPlane(V , F , i, j, d) do

i {Sign(F (Vi )d ) = Sign(F (V1)d )}
j {Sign(F (Vj )d ) (cid:44) Sign(F (Vi )d )}

W ← Push(W , (ConvexHull(V ′), F ))

5

6

7

8

9

10

11

12

13

14

15 return Y

4.4 Arbitrary Piecewise-Linear Function in Two Dimensions
We can generalize Algorithm 2 to arbitrary piecewise-linear functions f . We let the domain of f be
partitioned by a finite number of polytopes stored in H-representation (i.e., as a conjunction of
half-spaces). We then take the set of all hyperplanes defining the partitioning polytopes, defined
by affine maps {A1, A2, . . . , Am }. The insight is now essentially the same: subdividing the input
polytope such that each sub-divided polytope lies entirely on one side of each hyperplane Ai ensures
that it lies entirely within a particular linear region of f . Effectively, the only difference between
these algorithms and those specialized to ReLU is that we replace the particular affine map vd (i.e.,
projection onto the d dimension) with ones specified by the function f from the set of Ai s.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:12

Matthew Sotoudeh and Aditya V. Thakur

4.5 Representing Polytopes
Finally, we close this section with a discussion of implementation concerns when representing
the convex polytopes that make up the partitioning of (cid:99)f↾X . In standard computational geometry,
bounded polytopes can be represented in two equivalent forms:

(1) The half-space or H-representation, which encodes the polytope as an intersection of finitely-
many half-spaces. (Each half-space being defined as one side of a hyperplane, which can in
turn be defined by an affine map Ax ≤ 0.)

(2) The vertex or V-representation, which encodes the polytope as a set of finitely many points;
the polytope is then taken to be the convex hull of the points (i.e., smallest convex shape
containing all of the points.)

However, choosing a particular representation can make certain problems significantly easier or
more challenging. Finding the intersection of two polytopes in an H-representation, for example,
can be done in linear time by simply concatenating their representative half-spaces, but the same is
not possible in V-representation.

In our algorithms, there are two main operations we need to do with polytopes in our algorithms:
splitting a polytope with a hyperplane and applying an affine map to all points in the polytope.
In general, the first is more efficient in an H-representation, while the latter is more efficient in
a V-representation. However, when restricted to two-dimensional polygons, the former is also
efficient in a V-representation, as demonstrated by Algorithm 1, helping to motivate our use of the
V-representation in our algorithms.

Furthermore, the representations differ as to their resiliency to floating-point operations. In
particular, H-representations for polytopes in Rn are notoriously difficult to achieve high-precision
with, as the error introduced from using floating point numbers gets arbitrarily large as one goes
in a particular direction along any hyperplane face. Ideally, we would like the hyperplane to be
most accurate in the region of the polytope itself, which corresponds to choosing the magnitude
of the norm vector correctly. Unfortunately, to our knowledge, there is no efficient algorithm
for computing the ideal floating point H-representation of a polytope, although libraries such
as APRON [Jeannet and Miné 2009] are able to provide reasonable results for low-dimensional
spaces. However, as neural networks utilize extremely high-dimensional spaces (i.e., thousands of
dimensions) and we wish to iteratively apply our analysis, we find that errors from using floating-
point H-representations can quickly multiply and compound to become infeasible. By contrast,
floating-point inaccuracies in a V-representation are directly interpretable as slightly misplacing
the vertices of the polytope; no “localization” process is necessary to penalize inaccuracies close to
the polytope more than those far away from it.

Another difference is in the space complexity of the representation. In general, H-representations
can be more space-efficient for common shapes than V-representations, however, when the polytope
lies in a low-dimensional subspace of a larger space, the V-representation is usually significantly
more efficient.

Thus, V-representations are a good choice for low-dimensionality polytopes embedded in
high-dimensional space, which is exactly what we need for analyzing neural networks with two-
dimensional restriction domains of interest. This is why we designed our algorithms to rely on
Vert(X ), so that they could be directly computed on a V-representation.

5 UNDERSTANDING NETWORK BEHAVIOR USING WEAKEST PRECONDITION
In this section, we investigate one of the most immediate questions one might ask when analyzing
a neural network: what inputs lead to a particular set of outputs?

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:13

5.1 The Pre(f↾X , Y ) Primitive
5.1.1 Preconditions. This problem is formalized by the notion of preconditions; subsets of the input
space which, when f is applied, map to a particular set of outputs. We now introduce a primitive
that describes the notion of such preconditions for a neural network f : A → B and output polytope
Y ⊆ B: Pre(f↾X , Y ) ⊆ {x ∈ X | f (x) ∈ Y }. Pre(f↾X , Y ) always satisfies the following properties:

(1) Pre(f↾X , Y ) ⊆ X
(2) For any x ∈ Pre(f↾X , Y ), f (x) ∈ Y holds.

5.1.2 Weakest Precondition. The definition of Pre(f↾X , Y ) only requires an under approximation;
there may be points x ∈ X such that f (x) ∈ Y , even if x (cid:60) Pre(f↾X , Y ). This leads to the fact that ∅,
which we refer to as the strongest precondition, always satisfies Pre(f↾X , Y ) = ∅. However, such
a solution is not particularly useful, and instead we would like to find the weakest precondition
WPre(f↾X , Y ) = {x ∈ X | f (x) ∈ Y }.

For arbitrary functions and regions, WPre(f↾X , Y ) may not be convex or even representable as
a union of convex shapes. However, we will show by construction in Section 5.3 that, when (cid:99)f↾X
exists and Y is a convex polytope, WPre(f↾X , Y ) can be represented precisely as a union of finitely
many convex polytopes.

5.2 DPPre: Computing Preconditions with DeepPoly
We first investigate one way in which a solution to Pre(f↾X , Y ) can be found using prior work
in abstract interpretation. DeepPoly [Singh et al. 2019] is an abstract representation of the neural
network f↾X included as part of the ERAN abstract interpretation package [ERA 2019]. Namely,
for any network f restricted to restriction domain of interest X (i.e., f↾X ) and any particular
output dimension i, DeepPoly can produce lower- and upper-bound affine maps Al
such
i
that, for all x ∈ X : Al
i x. Thus, as long as the set Y is convex, it follows that
ix ≤ fi ↾X (x) ≤ Au
i x ∈ Y } is a valid Pre(f↾X , Y ). This set can be computed explicitly from Al
{x ∈ X | Al
ix ∈ Y ∧ Au
i
using a variety of linear algebra techniques, and a geometric interpretation of this process
and Au
i
is discussed below.

and Au
i

One can think of the DeepPoly representation as defining two polytopes, each one a two-
vocabulary polytope in a space consisting of both input and output dimensions of the network. The
first polytope defines the lower bounds on the network output: Dl = {(x, y) | x ∈ X ∧ y = Al (x)}
and the second defines the upper bounds on the network output: Du = {(x, y) | x ∈ X ∧y = Au (x)},
where Al (x) = (Al
n(x)), i.e. lower bounds for all output dimensions (and similar for
Au (x)). Computing Pre(f↾X , Y ) can now be seen as a three step process:

1(x), . . . , Al

(1) Compute the intersection of Dl with Y and project onto only the input x dimensions, resulting
in a new polytope Pl . Pl contains only input points for which we can guarantee the image
under f is lower-bounded by some value within Y .

(2) Compute the intersection of Du with Y and project onto only the input x dimensions, resulting
in a new polytope Pu . Pu contains only input points for which we can guarantee the image
under f is upper-bounded by some value within Y .

(3) Compute the intersection of Pl and Pu , representing inputs which have lower and upper

bounds in Y , thus (by convexity) the actual output must lie in Y .

We refer to this approach as DPPre or DPPre[1]. Notably, this intersection-projection construc-
tion implies that Pre(f↾X , Y ) found using DPPre can only represent convex shapes, thus it in general
cannot find WPre(f↾X , Y ) which may be non-convex. This is usually fine for local-behavior verifi-
cation problems where the network acts mostly convex, but is in practice unsuited for computing
precise Pre(f↾X , Y ) sets when WPre(f↾X , Y ) is highly non-convex. In practice, the precision of

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:14

Matthew Sotoudeh and Aditya V. Thakur

Pre(f↾X , Y ) computed with DeepPoly can be improved by pre-partitioning the input space X into
smaller regions and passing each region to the analyzer separately. We notate this approach as
DPPre[k], defined by:

Definition 10. Suppose X is a bounded restriction domain of interest spanned by d basis vectors.
Then DPPre[k](f↾X , Y ) is the application of the DPPre process after evenly splitting X in each of
the d basis directions into k equal partitions.

DPPre[k](f↾X , Y )

def=

k
(cid:216)

k
(cid:216)

i1=1

i2=1

· · ·

k
(cid:216)

id =1

DPPre[1](f↾P ar t (X,k,i1,i2, ...,id ), Y )

Where Part(X , k, i1, · · · , id ) is the (i1, · · · , id )th partition of X when X is split by k equal partitions
along each basis. For example, if X = {(x, y) | 0 ≤ x ≤ 1 ∧ 0 ≤ y ≤ 1} and we use the standard
basis {(1, 0), (0, 1)}, then Part(X , 4, 1, 1) = {(x, y) | 0 ≤ x ≤ 1

4 ∧ 0 ≤ y ≤ 1

4 }.

As we will see in Section 8.1, even when using k as large as 100 (i.e., 10, 000 partitions for a
two-dimensional region) the precision is still lacking. Furthermore, performance suffers as the
number of DPPre[1] calls grows according to kd .

5.3 Computing Weakest Preconditions with (cid:99)f↾X
The exact WPre(f↾X , Y ) can be computed given (cid:99)f↾X = {(P1, F1), . . . , (Pn, Fn)}. Effectively, within
each (Pi , Fi ) and for all x ∈ Pi and output dimension j, we have: f↾X (x)j = (Fix)j , which is similar
to the form returned by DeepPoly except the bounds are exact — there is no over-approximation at
all. Then, we can intersect the corresponding polytopes to compute WPre(Fi ↾Pi , Y ) on each (Pi , Fi )
pair; the union of all such regions is then WPre(f↾X , Y ).

5.4 Visualizing Decision Boundaries with Pre(f↾X , Y )
Many neural networks are classifiers, meaning they take some input and produce one of a small
(finite) set of outputs. An example of such a network is the ACAS Xu aircraft avoidance network [Ju-
lian et al. 2018], which has five inputs describing the position and velocity of an “ownship” and
“intruder,” transformed through five “hidden layers” with 50 dimensions each, then produces five
real-valued outputs y1, . . . , y5. The network’s output space is to be interpreted as having five classi-
fication regions, partitioning the output space depending on which output dimension is maximal.1
For example, the network may be said to advise a “strong right” turn when f (x) ∈ R5, with R5 (“the
fifth classification region”) defined as R5 = {y | y5 > y1 ∧ · · · ∧ y5 > y4}.

Suppose we want to visualize the policy learned by the network. We could fix all inputs (eg.
the velocity and heading) other than the position of the attacking ship, resulting in a restriction
domain of interest denoted X . Then, we could compute WPre(f↾X , R5) to get the set of all such
input positions for which the network advises to make a “strong right,” and use standard computer
graphics tools to plot these points on a graph in a particular color (say, orange). We may then
repeat the process, until we have plotted WPre(f↾X , R1) through WPre(f↾X , R5) on the same plot
in separate colors. The process is shown in Section 8.1, and the resulting plot can provide precise
and immediate insight into the behavior of an ownship controlled by the network.

1The original ACAS Xu networks take the minimal output dimension; this can be shown equivalent by inverting the weights
and biases of the final layer.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:15

6 BOUNDED MODEL CHECKING OF SAFETY PROPERTIES USING STRONGEST

POSTCONDITION

We saw in the preceding section how (cid:99)f↾X can be used to compute the weakest precondition of a
network’s input given conditions on the output, then described how that primitive could be applied
to visualizing decision boundaries of a neural network. In this section, we consider a complementary
primitive called the strongest postcondition, and show how it can be used to perform bounded model
checking [Biere et al. 2009] of neural-network based controllers.

6.1 The Post(f , X ) Primitive
We define Post(f , X ) to be a set containing all output points that can be mapped to under f given
some input in X . Formally, for a neural network f : A → B and input polytope X ⊆ A, we have
{ f (x) | x ∈ X } ⊆ Post(f , X ) ⊆ B. Post(f , X ) always satisfies the following properties:

(1) Post(f , X ) ⊆ B
(2) For any x ∈ X , f (x) ∈ Post(f , X ).

Strongest Postcondition. Notably, this definition only requires an over approximation; there
6.1.1
may be points y ∈ Post(f , X ) such that there is not any x ∈ X satisfying f (x) = y. This leads to
the fact that B (the range of f ), which we refer to as the weakest postcondition, always satisfies
Post(f , X ) = B. However, such a solution is not particularly useful, and instead in general we would
like to find the strongest postcondition, denoted SPost(f , X ), which exactly satisfies SPost(f , X ) =
{ f (x) | x ∈ X }.

For arbitrary functions and regions, SPost(f , X ) may not be convex or even representable as a
union of convex shapes. However, we will show by construction in Section 6.2 that, when (cid:99)f↾X
exists and X is a convex polytope, SPost(f , X ) can be represented precisely as a union of finitely
many convex polytopes.

(Pi, Fi )∈(cid:100)f↾X

6.2 Computing SPost(f , X ) with (cid:99)f↾X
Suppose we wish to compute SPost(f , X ), and know that (cid:99)f↾X = {(P1, F1), . . . , (Pn, Fn)}. We first
note that SPost(f , X ) = (cid:208)
SPost(Fi , Pi ). The first equality
holds because the Pi s partition X and the second equality holds because, given any x ∈ Pi ,
f (x) = Fi (x).

SPost(f , Pi ) = (cid:208)

Thus, it suffices to compute SPost(F , P) for a polytope P and affine function F . We note that,
in computational geometry field, this corresponds to transforming polytope P under affine map
F , which in turn can be shown to correspond to transforming the vertices of P and then taking
the convex hull of the resulting vertices (due to the convexity of P and F ). In other words, we
have SPost(F , P) = {F (x) | x ∈ P } = ConvexHull({F (v) | v ∈ Vert(P)}), giving us, in total
SPost(f , X ) = (cid:208)

ConvexHull({Fi (v) | v ∈ Vert(Pi )}).

(Pi, Fi )∈(cid:100)f↾X

(Pi, Fi )∈(cid:100)f↾X

6.3 Inverted Pendulum Model
In this section, we will consider a model taken from Zhu et al. [2019], which describes an inverted
pendulum with a motor at the base which can apply angular acceleration to the pendulum. The
motor is controlled by a neural network, which has been trained to keep the pendulum upright.
The network takes as input two variables representing the state of the system, namely the current
position of the pendulum and the current angular velocity. It then produces one output, namely
the angular acceleration it wishes to apply. We call this network an actor and denote it f . Notably,
we replaced tanh non-linearities with their piecewise-linear counterpart the hard tanh д(x) =
min(max(x, −1), 1) [Collobert 2004].

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:16

Matthew Sotoudeh and Aditya V. Thakur

In the model used for training and verifying the network, the effect of applying a particular
acceleration a at time t to state xt to form new state xt +1 is modeled with an affine function that
takes as input the previous state xt and the action a and produces a new state xt +1. We call this
function an environment model and denote it E.

We can compose E with f to produce a new “transition function” T (xt ) = E(xt , f (xt )) = xt +1,
which accepts as input a state xt and produces as output the corresponding state of the system after
applying the acceleration prescribed by the network for one timestep. Because f is piecewise-linear
and E is affine, it follows that T itself is piecewise-linear. With this notation, we are now ready to
describe a correctness specification for the network.

Definition 11. Given a function f : A → B, we define a correctness specification C to be a set of

tuples {(X1, Y1), . . . , (Xn, Yn)} where each Xi ⊆ A and each Yi ⊆ B.

We say f meets specification C if, for all (Xi , Yi ) pairs and all x ∈ Xi , f (x) ∈ Yi is satisfied.
In contrast, we say f violates specification C if there exists some (Xi , Yi ) pair and some x ∈ Xi

such that f (x) (cid:60) Yi .

In the pendulum example, we will consider three sets of states:
(1) The set of initial states SI = {(ν, ω) | −0.35 ≤ ν ≤ 0.35 ∧ −0.35 ≤ ω ≤ 0.35} is the set of

states the pendulum can be in before applying the network.

(2) The set of safe states SS = {(ν, ω) | −0.5 ≤ ν ≤ 0.5 ∧ −0.5 ≤ ω ≤ 0.5} is the set of states for
which we say the network has succeeded, namely when the pendulum is upright and not
moving at an unsafe speed.

(3) The set of unsafe states SU = {(ν, ω) | (ν, ω) (cid:60) SS } is the set of states for which we say the
network has failed, namely when the pendulum dips below the horizontal or moves at an
unsafe speed.

We would now like to solve the following bounded model checking problem: Is there any initial
state such that, after applying the neural controller for K time steps, the pendulum has ever reached
an unsafe state? This corresponds to verifying the specification:

(cid:8)(SI , SS ), (SPost(T , SI ), SS ), (SPost(T , SI )2, SS ), . . . , (SPost(T , SI )K −1, SS )(cid:9)
(2)
where SPost(T , SI )n indicates the repeated application of SPost(T , ·); for instance, SPost(T , SI )2 =
SPost(T , SPost(T , SI )).

6.4 Bounded Model Checking with DeepPoly
One could attempt to use DeepPoly [Singh et al. 2019] here as well, however, as DeepPoly uses
an over-approximation for Post(f , x), we would expect to run into many false-positives (where
DeepPoly reports that the specification cannot be verified, but is unable to state whether that is
due to imprecision in the abstraction used or because the specification is violated).

6.5 Bounded Model Checking with ReluPlex
Another approach we could take is to use the DNN-oriented SMT solver ReluPlex [Katz et al. 2017].
Because T is piecewise-linear, ReluPlex can handle queries such as: ∃x ∈ SI
: T (x) ∈ SU (with
the caveat that, as SU is non-convex, it will have to be partitioned into convex polytopes before
ReluPlex can be queried). Notably, however, ReluPlex does not support universal quantifiers on
iterated applications of T , i.e. there is no meaningful way of encoding ∀k ∈ {1, 2, . . . , K } : ∃x ∈
: T k (x) ∈ SU }, where T k (x) is the repeated application of T to x k times, which is the actual
SI
query we wish to run. Instead, we need to query ReluPlex separately for each timestep, forcing it to
repeat work done on verifying properties of the behavior of the network on earlier timesteps at
each new timestep.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:17

ReLU
network f

Patch
specification
(Definition 12)

Masking
network fM
(Section 7.2)

Patching using
MAX SMT
(Section 7.1)

Patched
masking
network

Patch point
construction
using (cid:100)f↾X
(Section 7.3)

Patch points

Fig. 4. Patching deep neural networks

6.6 Bounded Model Checking with (cid:99)f↾X and SPost(f , X )
Alternatively, one can perform the bounded model checking iteratively using SPost(T , X ), computed
as discussed in Section 6.2. This works as follows:

Initially, we compute SPost(T , SI ) and check if SPost(T , SI ) ∩ SU = ∅. If the intersection is not
empty, then by definition there must be some state in SI that transitions to an unsafe state (in SU )
after applying the network for one timestep and we can report that the model has violated the
specification. Next, we can use the computed SPost(T , SI ) and compute SPost(T , SPost(T , SI )) =
SPost(T , SI )2, which we can then check to see if any intersection with SU is found. We can repeat
this iteratively, effectively “growing” the “reachable set” of our model at each step. If, upon reaching
SPost(T , SI )K , no intersection with SU has ever been identified, we may safely say that the model
satisfies the specification in Equation 2. Importantly, we can iteratively reuse the computation of
SPost(T , SI )j for computing SPost(T , SI )j+1, as opposed to the SMT-solver approach which does
not share information between verification of different step lengths.

There are multiple further optimizations that can be performed in this approach. For example, (cid:100)f↾SS
can be computed and stored once ahead-of-time, so SPost(T , SI )j can be immediately computed
without having to repetitively re-compute our symbolic representation of f . Furthermore, if
something in one step has already been included in the post-set of a previous step, it can be safely
ignored when propagating to the next step. For an extreme example, if SPost(T , SI ) ⊆ SI (and
SI ∩ SU = ∅) we could immediately verify the network for all K timesteps (in fact, all timesteps in
general) because it satisfies the inductive invariant SPost(T , SI )j ⊆ SI ∧ SI ∩ SU = ∅ for all j.

7 PATCHING DEEP NEURAL NETWORKS
In this section, we introduce and formalize the problem of network patching, then show how our
symbolic representation of a DNN can lead to a solution to the network patching problem (Figure 4).
As a running example, consider the expository neural network defined by function f below:

(cid:21)

(cid:21)

f (x) =

(cid:20)1
1
1
0 −1 −1

−1


1


0


This network is visualized in Figure 5a, with classification regions R1 = {y1 ≥ y2} and R2 =
{y2 ≥ y1}. Now, suppose for expository purposes that we want this network’s decision boundaries
to look like that of Figure 5c, and suppose one wanted to “patch” the network, i.e. make small
modifications to its weights, such that this is accomplished. Before approaching this problem, we
must formalize a representation of the desired network behavior:

−0.5


0


0



ReLU (cid:169)
(cid:173)
(cid:171)

(cid:20)x1
x2

(cid:20)0
1

1
0
1















(cid:170)
(cid:174)
(cid:172)

(3)

+

+

(cid:21)

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:18

Matthew Sotoudeh and Aditya V. Thakur

(a) The network’s linear partitions
and decision boundaries before
patching.

(b) The partitions used in the patch
specification.

(c) The patched network’s linear
partitions and decision bound-
aries.

Fig. 5. Networking patching on DNN f in Equation 3

Definition 12. Given a neural network f : A → B, a patch specification is a finite set of pairs of

convex polytopes T = {(X0, Y0), . . . , (Xn, Yn)} where each Xi ∈ A and Yi ∈ B.

We can then formalize the concept of a network patch like so:

Definition 13. Given a neural network f (x; θ ) parameterized by weights θ and a patch specifica-
tion T = {(X0, Y0), . . . , (Xn, Yn)}, we define a patch to f satisfying T to be a change δ to the weights
θ such that, for all x ∈ Xi , f (x; θ + δ ) satisfies f (x; θ + δ ) ∈ Yi .

In our running example, we have specified four polytopes in Figure 5b, which can be used to
build the patch specification: {(P1, R2), (P2, R1), (P3, R1), (P4, R1)}. Note that the polytopes in patch
specifications are usually infinite, meaning the quantifications in Definition 13 are over infinite sets.
One approach would be to treat this as a normal network training problem, which we can try to
find a solution using gradient descent [Patterson and Gibson 2017]. However, because gradient
descent works over finitely-many individual points, even if the training loss goes to 0 it is not
guaranteed that the actual constraints (which quantify over infinite sets of points) are all met. This
issue could be addressed using (cid:99)f↾X to implement a train-verify loop, where we train with gradient
descent, then use Pre(f↾X , Y ) to find points that do not satisfy the patch set, which can then be
placed back into the training set for the next iteration of gradient descent. However, this iterative
process is unfortunately inefficient and in general not guaranteed to terminate. In the proceeding
sections, we will address these issues by formulating the patching problem as a MAX-SMT instance.

7.1 Deep Neural Network Patching as a Non-Linear MAX SMT
The problem of finding such a patch can be seen as an instance of the more general MAX SMT
problem, which looks to find values satisfying as many given logical formulas as possible. We
recall from Definition 13 that we wish to find a δ satisfying: ∀(Xi , Yi ) ∈ T : ∀x ∈ Xi
: f (x; θ +
δ ) ∈ Yi , which can be directly translated to the MAX-SMT instance defined by the conjunction
(cid:211)
∀x ∈ Xi : f (x; θ + δ ) ∈ Yi (note that x ∈ Xi and y ∈ Yi can be encoded in any theory
supporting rational linear inequalities).

(Xi,Yi )∈T

Although in theory this problem can be exactly solved by any modern SMT solver (such as
Z3 [de Moura and Bjørner 2008]), the extreme non-linearity involved makes it infeasible in prac-
tice. To make it feasible, we would like the problem to be highly linear, eg. encodable as an LP.
Unfortunately, there are numerous reasons why this is not possible with the above formulation:
(1) The constraints require that the theory solver can encode the network f , which is usually
highly-non-linear (eg. ReLU layers introduce exponentially many possible branches).

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

3210123321012332101233210123P1P2P3P432101233210123A Symbolic Neural Network Representation and Applications

1:19

(2) It solves for δ while simultaneously quantifying over the infinite x ∈ Xi , resulting in signifi-

cant non-linearity in the problem itself.

(3) If δ can change multiple weights over multiple layers or nodes, the interaction between all
weight changes results in a high-order polynomial problem instead of a linear one (because
the linear layers are applied sequentially, eg. y = w2(w1x + b1) + b2).

To address the first two of these problems, we will introduce in Section 7.2 a new neural network
architecture termed Masking Networks. Our core result, Theorem 14, will show that Masking
Networks have desirable properties which allow us to (1) replace the highly-non-linear f with an
affine map in each conjunct and (2) lower the problem of patching on the infinitely-many x ∈ Xi
with patching on finitely-many key points. To address the final issue, in Section 7.4 we will limit
the set of weights that can be patched at the same time to ensure that the resulting problem is still
linear. Finally, in Section 7.5 we will show that extending this restriction to only changing a single
weight at a time (referred to as “weight-wise patching”) results in an algorithm efficient enough for
use on real-world networks.

7.2 Masking Networks
Our central result in Theorem 14 relies on a new type of neural network, which we propose here
and term a Masking Network. Masking Networks strictly generalizes the concept of a feed-forward
network with ReLU activations and are loosely inspired by the work of Fiat et al. [2019]. We note
that the ideas in this section can be further extended to networks with arbitrary piecewise linear
activation functions (eg. MaxPool) but we focus here on ReLU for ease of exposition. The essential
insight is to fully separate the activation pattern of the network (which defines the partitioning of
(cid:98)f ) from the result of network (which defines the affine maps of (cid:98)f ).

We first review the architecture of standard feed-forward neural networks, described in Section 2.
The entire network function f is decomposed into a series of sequentially-applied layers, which
we denote L1, L2, . . . , Ln. Given a particular input vector to the network, each layer is said to have
an associated output vector. Namely, if x is the input vector, then the output vector of layer i is
Li (· · · L1(x)). Recall from Section 2.1 that, in a standard feed-forward ReLU network, the layers
alternate between FullyConnected or 2DConvolution layers (which correspond to affine maps)
and piecewise-linear ReLU layers, which are defined component-wise by:

ReLU(x)i =

(cid:40)0
xi

xi ≤ 0
xi > 0

Meaning that the ith component of the output vector is 0 when the ith component of the input
vector is non-positive, and left unchanged otherwise. An equivalent logical definition would be
(xi > 0 ∧ ReLU(x)i = xi ) ∨ (xi ≤ 0 ∧ ReLU(x)i = 0).
In a Masking Network, four changes are made:

1 , . . . , xv
d

(1) The inputs and outputs to each layer are vectors of 2-tuples ((x a

)). In some
scenarios it will be convenient to refer to the vector consisting of just the first-values,
noted x a = (x a
) and called the “activation vector.” Correspondingly, we will notate
xv = (xv

) and name this the “values vector.”

2 ), . . . , (x a

1 , . . . , x a
d

d , xv

1 , xv

(2) The input vector x = (x1, . . . , xk ) to the entire network is converted to an input vector where
the activation and values vectors are equal, i.e. ((x1, x1), (x2, x2), . . . , (xk , xk )) or, equivalently,
x a = xv = x.

(3) The output of the network is taken to be only the values vector xv outputted by the last layer.
(4) ReLU layers are replaced by Masked ReLU (MReLU) layers, defined below.

d

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:20

Matthew Sotoudeh and Aditya V. Thakur

In a masking network, FullyConnected or 2DConvolution layers are associated with two
parameters each, θ a and θ v . Given an input with activation vectors x a and value vectors xv to
a FullyConnected or 2DConvolution layer, θ a and θ v are applied to the x a and xv vectors
independently as follows:

FullyConnecteda(x a, xv ; θ a, θ v )

Given an input vector-of-tuples ((x a
tuple to be:

FullyConnectedv (x a, xv ; θ a, θ v )
d , xv

1 ), . . . , (x a

1 , xv

d

def= FullyConnected(x a; θ a)
def= FullyConnected(xv ; θ v )
)) to a MReLU layer, we define its ith output

d )(cid:1)(cid:1)
The following properties follow directly from these definitions and are integral to understanding

MReLU (cid:0)(cid:0)(x a

1 ), . . . , (x a

d , xv

1 , xv

=

i

(cid:40)

(0, 0)
i , xv
(x a
i )

i ≤ 0
x a
i > 0
x a

Masking ReLU networks:

(1) A masking network is piecewise-linear, and thus (cid:99)f↾X can be computed for any bounded

polytope X by Theorem 7.

(2) If x a = xv , then MReLU(x a, xv ) = (ReLU(xv ), ReLU(xv )).
(3) If x a = xv and θ a = θ v , then FullyConnectedθ a,θ v (x a, xv ) = (FullyConnectedθ v (xv ),

FullyConnectedθ v (xv )) and similarly for 2DConvolution.

(4) The value of the activation vectors (x a) only ever depends on the values of prior activation
vectors and activation parameters (θ a), never prior value vectors (xv ) or value parameters
(θ v ).

(5) The non-linear behavior of the values vectors (xv ) is entirely controlled by the activation
vectors (x a). For example, if all activation vectors x a are strictly positive, then the entire
masking network is affine (regardless of the values of the value vectors).

The first property allows us to use the symbolic representation (cid:98)f of the masking network. The next
two properties show that we can always encode any feed-forward ReLU network as a Masking
ReLU network by setting θ a = θ v = θ for corresponding affine layers (i.e., masking networks are
strictly more expressive than feed-forward ReLU networks). The final two properties ensure that:

(1) The partitioning of (cid:98)f is determined entirely by the activation parameters θ a.
(2) The affine maps of (cid:98)f are determined entirely by the value parameters θ v .
Intuitively, now, we can think of changes to the activation parameters θ a as moving the positions
of the partitions in (cid:98)f (i.e., changing the position of the polytopes in Figure 2a and changing the
position of the white lines in Figure 2b and Figure 5a). Moreover, changes to the value parameters
θ v corresponds to changing the classification within each partition (i.e., changing the position of
the decision boundary within each white-line delineated region in Figure 2b and Figure 5a without
changing the position of the white lines themselves).

7.3 Patching Deep Neural Networks on Infinite Inputs
The previous observations lead to the following theorem:

Theorem 14. Given a masking network f (x; θ a, θ v ) parameterized by activation parameters θ a
and value parameters θ v , an input polytope X , output polytope Y , and (cid:99)f↾X = {(P1, F1), . . . , (Pn, Fn)},
then:

A values-patched network f (x; θ a, θ v + δ ), modifying only θ v , satisfies the property ∀x ∈ X :
: ∀v ∈ Vert(Pi ) :

f (x; θ a, θ v + δ ) ∈ Y if and only if it satisfies the property ∀(Pi , Fi ) ∈ (cid:156)f (x; θ a, θ v )↾X
Fi (v; θ v + δ ) ∈ Y .

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:21

The above theorem, proved in Appendix I, allows us to translate the problem of patching over
an infinite set of points to that of patching on finitely-many vertex points, as long as we keep
the activation parameters θ a constant. We will use this fact in Section 7.4 to phrase the patching
problem as an instance of the linear MAX-SMT problem.

Finally, it is important to note that for any linear partition (Pi , Fi ) in the unpatched (cid:156)f (x; θ a, θ v )↾X
we can compute Fi (x; θ v + δ ) for any δ , i.e. the affine map corresponding to the values-patched
network f (x; θ a, θ v + δ ) over input region Pi . The existence of such a map follows from the
is identical to that of (cid:156)f (x; θ a, θ v + δ )↾X
observation that the linear partitioning of (cid:156)f (x; θ a, θ v )↾X
because only the value parameters are modified (so linear partitions of the unpatched network
are still linear partitions of the patched network.) The exact method of computing Fi (x; θ v + δ ) is
unimportant to this discussion, however for expository purposes we provide an example for the
map corresponding to partition P4 in Figure 5b:

F (x ∈ P4; θ + δ ) =

(cid:21)

(cid:18) (cid:20)1 1

1
0 −1 −1

3

+ δ

0 0 0
(cid:19) 

0 1 0


0 0 1










−1 1




1 0




0 1





(cid:169)
(cid:169)
(cid:173)
(cid:173)
(cid:171)
(cid:171)

+ δ

1(cid:170)
(cid:174)
(cid:172)

(cid:21)

(cid:20)x1
x2








+ (cid:169)
(cid:173)
(cid:171)

−0.5
0
0








+ δ

2(cid:170)
(cid:170)
(cid:174)
(cid:174)
(cid:172)
(cid:172)

+

(cid:21)

(cid:18) (cid:20)0
1

(cid:19)

4

+ δ

7.4 Network Patching as a Linear MAX SMT
In this section, we will show how Masking Networks can be used to address the issues identified
in Section 7.1 and finally translate the highly-non-linear MAX SMT formulation of the patching
problem into a linear one. To do this, we will restrict ourselves to only patching the θ v value-
parameters, and furthermore only patch the parameters for a single node at a time.

First, we translate the given ReLU network into an equivalent Masking Network (which can
always be done as Masking Networks are strictly more powerful than sequential feed-forward
networks). We can then address the problem (1) from Section 7.1, i.e. the non-linearity of f , by
restricting ourselves to only patching the value parameters θ v . The value parameters do not impact
the partitioning of (cid:98)f (only the affine maps). Thus, this restriction allows us to break the non-linear
MAX SMT query into a series of MAX SMT queries, one for each linear region, and within each the
function is linear with respect to the input (see the discussion about Fi (x; θ v + δ ) in Section 7.3).
To address problem (2) from Section 7.1, i.e. quantifying over the infinitely many x ∈ Xi while
solving for δ , we use the result in Theorem 14 to quantify over the finitely-many vertices of each Xi
intersected with the linear region instead of over the infinitely-many points in each Xi . Theorem 14
ensures that the two are equivalent.

To address the final issue from Section 7.1, i.e. the non-linear interaction when changing multiple
weights in a network, we can limit δ to only modify the weights corresponding to a single node in
the network, which will prevent such non-linearity arising from sequential layers. Once all three
of these changes are made, the corresponding satisfiability problem can be encoded as an LP and
more general solvers like Z3 can find solutions to the maximization problem in some cases.

The corresponding satisfiability problem looks like:

(cid:219)

(cid:219)

(cid:219)

Fj (v; θ + δ ) ∈ Yi

(Xi,Yi )∈T

(Pj, Fj )∈(cid:155)fM ↾Xi

v ∈Vert(Pj )

(4)

Where fM (·; θ, θ ) is the Masking Network equivalent to f , Fj (v; θ +δ ) is the affine map corresponding
to fM (·; θ, θ + δ ) over linear partition Pj , and δ changes the weights of at most a single node.

Notably, this involves finitely many conjunctions and Fj (v; θ + δ ) can be written as an affine
function of δ when v and θ are fixed. For example, consider again the expository network visualized
in Figure 5 and the key point (3, 0.5) lying in polytope P4. Now, if we only patch the second of the
three nodes in the first affine layer, then δ has only three non-zero value (one for each of the 3 inputs

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:22

Matthew Sotoudeh and Aditya V. Thakur

to that node along with its bias) which we can write δ1, δ2, δ3. We can then write F1(v; θ, θ + δ ) as:

F (x ∈ P4; θ + δ ) =

=

(cid:20)1
1
1
0 −1 −1

0
(cid:21) 

0


0


(cid:20) 3δ1 + 0.5δ2 + δ3
−3δ1 − 0.5δ2 − δ3

0
1
0
(cid:21)

+

−1
1 + δ1
0

0




0
(cid:169)


(cid:173)


1


(cid:171)


(cid:20) 3.5
−2.5

(cid:21)

1
δ2
1








(cid:21)

(cid:20) 3
0.5

+

+

(cid:21)

(cid:20)0
1

−0.5




δ3




0





(cid:170)
(cid:174)
(cid:172)

=

(cid:20) 3
1
0.5
−3 −0.5 −1







which is clearly affine in the δ1, δ2, δ3 potentially-non-zero components of δ . The exact derivation
of the above matrices is not entirely important; instead, we wish to highlight that this formulation
can translate the corresponding satisfiability problem into a linear one.

(cid:20) 3.5
−2.5

δ1
(cid:21) 

δ2


δ3



+

(cid:21)

7.5 Weight-Wise Network Patching as an Interval MAX SMT
This linear formulation is still prohibitively expensive in most real-world scenarios, due primarily
to the large number of “key points” necessary (often well over 30, 000). The last optimization
we make to the process is to limit δ to changing only a single weight, which we refer to as
“weight-wise patching.” Now, for any given weight in θ , Equation 4 corresponds to a conjunction
of linear inequalities in one variable. Thus, each of the conjuncts corresponds to an interval on the
corresponding patch δ in which that constraint is met. We refer to the set of all such intervals for
the kth weight as Ik . Finding the optimal patch for that weight now corresponds to finding an
interval M = [Ml , Mu ] that maximizes the number of intervals in Ik that contain it. This can be
done in linear time using a “linear sweep” algorithm once the intervals are sorted. We can repeat
this process for every weight in a particular layer (or the entire network if desired), picking the
weight and update which will satisfy the maximum number of constraints. Finally, we can greedily
apply this algorithm to update multiple weights, at each step making the optimal change to a single
weight in the network. Thus, this greedy algorithm is guaranteed to both monotonically increase
the number of constraints met as well as terminate in a finite number of steps.

7.6 Efficiency of Patched Masking Networks
We close this section with a discussion of the inference-time efficiency of Masking Networks, in
the process identifying another major benefit to weight-wise patching. On first glance, masking
networks appear to double the amount of computation necessary to perform inference, and indeed,
when there is no relation between the activation and value parameters (θ a and θ v ) this is the case.
However, this is not necessarily the case when the parameterizations share many weight values. As
an extreme example, we have already noted that when θ a = θ v , the network exactly corresponds
to a normal ReLU network. As a slightly more complex example, if only a single weight in the last
affine layer before a ReLU layer is changed, then the value of the corresponding node’s output
activation and value vector coefficients differ by a constant difference in the weights multiplied by
the corresponding input coefficient, incurring a cost of only one multiply-accumulate operation.
In that way, if only a small number of weights differ between the values and activation network,
the output of the masking network can be computed by keeping only “diffs” of the values of the
nodes during inference. In Section 8.3, on two of our patch specifications we patched the last affine
layer before the last ReLU layer (so at most one multiply-accumulate operation of overhead) and in
another one we patched the very last affine layer, which is not followed by a ReLU layer, so there
was no overhead at all.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:23

(a) Weakest precondition for
Strong Right using (cid:100)f↾X

(b) Precondition for Strong Right
using DPPre[k = 25]

(c) Precondition for Strong Right
using DPPre[k = 100]

(d) Decision boundaries com-
puted using (cid:100)f↾X

(e) Decision boundaries com-
puted using DPPre[k = 25]

(f) Decision boundaries com-
puted using DPPre[k = 100]

Legend:

Clear-of-Conflict, Weak Right,

Strong Right,

Strong Left, Weak Left.

Fig. 6. Visualization of decision boundaries for the ACAS Xu network.

8 EXPERIMENTAL EVALUATIONS
In this section, we apply the techniques discussed in this paper to a number of interesting problems,
comparing to prior work where applicable.

Tests were carried out on a dedicated Amazon EC2 c5.metal instance, using Benchexec [Beyer

2016] to limit the number of CPU cores to 16 and RAM to 16GB. Our code is available at
https://github.com/95616ARG/SyReNN.

8.1 Understanding Network Behavior using Weakest Precondition
For this application, we wanted to investigate the following two research questions:

(1) Can we efficiently visualize the decision boundaries of an ACAS Xu aircraft-avoidance

network using (cid:99)f↾X ?

(2) How does prior work (DPPre[k] using DeepPoly [Singh et al. 2019]) compare, both in effi-

ciency and precision, when used to compute Pre(f↾X , Y )?

To investigate these concerns, we wrote programs to compute WPre(f↾X , Y ) and Pre(f↾X , Y )
for arbitrary polytopes X and Y using (cid:99)f↾X (Section 5.3) and DPPre (Section 5.2), respectively. Then,
for each of the possible advisories produced by the network, we plotted the precondition set in a
human-visualizable form, with the results shown in Figure 6. Notably, the precision when using
DPPre[k] increases when the input domain is pre-partitioned (i.e., k > 1), with the analysis being

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:24

Matthew Sotoudeh and Aditya V. Thakur

Table 1. Performance of (cid:100)f↾X and DPPre when used to compute weakest precondition and precondition for
the ACAS Xu network [Julian et al. 2018]. (cid:100)f↾X size is the number of partitions in the symbolic representation.
k is the number of splits used for DPPre; the number of partitions used is then k
. Each scenario represents a
different two-dimensional slice of the input space; within each slice, the heading of the intruder relative to
the ownship along with the speed of each involved plane is fixed.

2

Scenario

(cid:100)f↾X size (cid:100)f↾X time (secs)
10.9
33200
Head-On, Slow
10.2
30769
Head-On, Fast
12.5
Perpendicular, Slow 37251
11.4
33931
Perpendicular, Fast
12.1
36743
Opposite, Slow
13.0
Opposite, Fast
38965
11.9
-Perpendicular, Slow 36037
10.9
33208
-Perpendicular, Fast

DPPre time (secs)

k = 25

k = 55

k = 100

9.1
8.2
9.2
8.2
9.8
9.5
9.5
8.3

43.2
39.0
42.9
39.2
46.7
45.2
45.0
39.5

141.3
128.0
141.7
127.5
152.5
147.3
146.4
130.2

performed on each partition independently. Thus, we have shown a progression of plots from the
DPPre[k] approach, each one using progressively more partitions k for DPPre[k] (all converging to
the weakest precondition found using (cid:99)f↾X ). Note that, as we used a two-dimensional input region,
DPPre[k] uses k 2 separate partitions and calls to DPPre[1].

The imprecision from using DeepPoly in DPPre (see Figure 6) is to be expected, as its symbolic
representation was designed to efficiently answer decision (yes/no) queries about relatively small
regions of a high-dimensional input space. By contrast, in this experiment we are stretching the
DeepPoly representation beyond that goal by extracting preconditions over large regions of a
low-dimensional input space.

Table 1 shows the time taken by each analysis. Note that the time taken does not include plotting
time; only the time necessary to compute the precondition sets. As we increase the number of
partitions (equal to k 2) used by DPPre, the precision goes up (as shown in Figures 6b-6c) but so
does the time taken for analysis. We find that, except for very small k where the precondition
set is nearly-empty, the DPPre analysis is slower than that using (cid:99)f↾X (which provides the exact
WPre(f↾X , Y )).

Both of these results match our expectations; (cid:99)f↾X is well-suited for immediately determining
WPre(f↾X , Y ), while attempting to use the DeepPoly representation (which is optimized for the
decision procedure case) is advisable only when precision is not particularly important.

8.2 Bounded Model Checking of Safety Properties using Strongest Postcondition
For this application, we wanted to investigate the following two research questions:

(1) Can we use (cid:99)f↾X to efficiently perform bounded model checking on a neural-network con-

troller?

(2) How efficient is prior work (ReluPlex [Katz et al. 2017]) at performing bounded model

checking on a neural-network controller?

To answer these questions, we chose a subset of neural-network controller models from [Zhu
et al. 2019] that have two-dimensional states and affine state-transition functions. We utilized
the initial, safe, and unsafe sets from that work. As an initial optimization, we removed from the
initial set any states which could be guaranteed (based only on the environment dynamics and

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:25

2,000
1,500
1,000
500
0

)
s
(

e
m
T

i

3,000
2,000
1,000
0

3,000
2,000
1,000
0

0

40

20
Steps

0

20

10
Steps

0

10

5
Steps

(a) Pendulum

(b) Quadcopter

(c) Satelite

Fig. 7. Performance of bounded model checking (BMC) for three neural-network controllers using (cid:100)f↾X (blue
line) and ReluPlex (red line). The x-axis is the number of steps used in BMC, y-axis is the time taken in
seconds. A timeout of 1 hour was used. For the Pendulum model, the (cid:100)f↾X approach stopped after finding a
counter-example on the 51st step (after approximately 30 minutes).

Table 2. Maximum number of steps verified by (cid:100)f↾X and ReluPlex approaches for BMC before timeout. Timeout
was set to 1 hour. “*” indicates a counter example was found after that many steps.

Model

Pendulum
Quadcopter
Satelite

(cid:100)f↾X Steps ReluPlex Steps
2
51*
6
25
4
13

maximum/minimum output bounds on the network controller) to map into the initial set after one
timestep. This resulted in a disjunctive initial state.

We then performed bounded model checking of the models using ReluPlex [Katz et al. 2017]
and (cid:99)f↾X as described in Section 6. Figure 7 shows the time taken to perform the analysis for each
network up to a given timestep of the model, while Table 2 summarizes these results.

As we can see, bounded model checking with (cid:99)f↾X can be significantly more efficient than
using ReluPlex. This is primarily because the approach using (cid:99)f↾X directly computes the strongest
postcondition on network output after each step, which can then be re-used efficiently in the
strongest-postcondition computation for the next timestep. By contrast, re-use between timestep
computations for ReluPlex is not possible, meaning verifying each progressive timestep becomes
progressively more challenging.

8.3 Patching Deep Neural Networks
For this application, we wanted to understand the following three research questions:

(1) Can an ACAS Xu network be patched to correct a number of undesired behaviors?
(2) How well do patches on a single two-dimensional subsets of the input space generalize to

(i.e. fix the same behavior on) other subsets of the input space?

(3) How well does the greedy MAX-SMT solver described in 7.1 work, both in terms of efficiency

and optimization?

To answer the first two questions, we took the ACAS Xu network visualized in Figure 6 and
attempted to patch three suspicious behaviors of the network using the approach described in Sec-
tion 7. The “Pockets” patch specification (Figure 9) attempts to get rid of the “pockets” of strong

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:26

Matthew Sotoudeh and Aditya V. Thakur

100

99.8
99.6
99.4

t
e
M

s
t
n
i
a
r
t
s
n
o
C
%

0

2

4
Iteration

100
99.9
99.8
99.7
99.6

0

2

4
Iteration

96
94
92
90
88

0

2

4
Iteration

(a) “Pockets” Specification

(b) “Bands” Specification

(c) “Symmetry” specification.

Fig. 8. Weights changed vs. percent of constraints met. The blue line shows the percent of constraints met on
the input slice that the patch targeted, while the red line shows the percent of constraints met on a slice at
higher velocity.

Table 3. Summarizes the percent of constraints met and time taken per iteration for patching three specifica-
tions. “Patched Slice” is the input domain of interest that the patch spec applies to, while “Other Slice” shows
how patching one slice can generalize to patches for another.

Constraints Met

Patched Slice

Other Slice

Time Per Iteration

Patch

Initial

Final

Initial

Final Mean

Std. Dev.

Pockets
Bands
Symmetry

99.6%
99.6%
88.5%

99.994% 99.3%
99.7%
99.98%
88.9%
97.0%

99.7% 23.6
99.8% 15.9
95.6% 4.7

15.2
2.3
0.1

left/strong right in regions that are otherwise weak left/weak right. The “Bands” specification
(Figure 10) attempts to get rid of the weak-left region behind and to the left of the ownship (at the
origin). The “Symmetry” specification (Figure 11) attempts to lower the decision boundary between
strong left/strong right to be symmetrical.

After patching, we plotted the patched network in the same two-dimensional region it was
originally plotted (and then patched) over, as well as another two-dimensional region formed by
increasing the velocities of the ownship and attacking ship by 50 kilometers per hour (to evaluate
generalization to input regions not explicitly patched). The before and after plots are presented
in Figure 9, Figure 10, and Figure 11.

To answer the third question quantitatively, we timed the performance on the three evaluations
shown above and present it in Table 3 along with the percent of constraints met at each step
in Figure 8.

We find that our proposed approach works very well; by changing only five weights, we were
able to near-perfectly apply most of the patches (eg. notice the disappearance of the “offending”
regions between Figure 9a and Figure 9c). Furthermore, for the most part, the patches appear to
generalize to regions not explicitly considered in the patching process (eg. notice the disappearance
of the out-of-place “strong left” region between Figure 9d and Figure 9e after changing only a single
weight). The efficacy of the greedy MAX-SMT solver is further exemplified by the quantitative
results in Table 3 and Figure 8, which shows that it is very effective at quickly meeting a large
fraction of the desired constraints. However, patching was not, in general, a “silver bullet,” and
sometimes undesired changes were introduced (cf. Figure 11f, which has introduced a small “strong

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:27

(a) Before patching.

(b) After one iteration (weight
change).

(c) After five iterations (weight
changes).

(d) Before patching (generaliza-
tion region).

Legend:

Clear-of-Conflict, Weak Right,

Strong Right,

(e) Generalization after one it-
eration (weight change) on the
patch region.

(f) Generalization after five iter-
ations (weight change) on the
patch region.
Strong Left, Weak Left.

Fig. 9. Network patching for the “Pockets” spec (Removing the “pockets” of strong-left and strong-right).

right” region into what was otherwise “weak left” on the generalized region). Avoiding such issues
is an interesting direction for future work, but for the most part, we believe the results shown here
to be extremely promising for the application of network patching in practice.

9 RELATED WORK
This section describes prior work relevant to each of the contributions of this paper (Section 1.2).
A symbolic representation of deep neural networks Xiang et al. [2017] solve the problem of
exactly computing the reach set of a neural network given an arbitrary convex input polytope.
However, the authors use an algorithm that relies on explicitly enumerating all exponentially-
many (2n) possible signs at each ReLU layer. By contrast, our algorithm adapts to the actual input
polytopes, efficiently restricting its consideration to activations that are actually possible.

Thrun [1994] presents an early approach for extraction of if-then-else rules from artificial neural
networks. Bastani et al. [2018] learn decision tree policies guided by a DNN policy that was learned
via reinforcement learning. This decision tree could be seen as a particular form of symbolic
representation of the underlying DNN.
Understanding network behavior using weakest precondition. Because DNNs are difficult to
meaningfully interpret, researchers have tried to understand the behavior of such networks. For
instance, networks have been shown to be vulnerable to adversarial examples—inputs perturbed in a

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:28

Matthew Sotoudeh and Aditya V. Thakur

(a) Before patching.

(b) After one iteration (weight
change).

(c) After five iterations (weight
changes).

(d) Before patching (generaliza-
tion region).

Legend:

Clear-of-Conflict, Weak Right,

Strong Right,

(e) Generalization after one it-
eration (weight change) on the
patch region.

(f) Generalization after five iter-
ations (weight change) on the
patch region.
Strong Left, Weak Left.

Fig. 10. Network patching for the “Bands” spec (Removing the band of weak-left behind the origin).

way imperceptible to humans but which are misclassified by the network [Carlini and Wagner 2018;
Goodfellow et al. 2015; Moosavi-Dezfooli et al. 2016; Szegedy et al. 2014]–and fooling examples—
inputs that are completely unrecognizable by humans but recognized by DNNs [Nguyen et al. 2015].
Breutel et al. [2003] presents an iterative refinement algorithm that computes an overapproximation
of the weakest precondition as a polytope where the required output is also a polytope.

Bounded model checking of safety properties using strongest postcondition. Scheibler et al.
[2015] verify the safety of a machine-learning controller with BMC using the SMT-solver iSAT3,
but support small unrolling depths and basic safety properties. Zhu et al. [2019] use a synthesis
procedure to generate a safe deterministic program that can enforce safety conditions by monitoring
the deployed DNN and preventing potentially unsafe actions. The presence of adversarial and
fooling inputs for DNNs as well as applications of DNNs in safety-critical systems has led to efforts
to verify and certify DNNs [Anderson et al. 2019; Bastani et al. 2016; Bunel et al. 2018; Ehlers 2017;
Gehr et al. 2018; Huang et al. 2017; Katz et al. 2017; Singh et al. 2019; Weng et al. 2018]. Approximate
reachability analysis for neural networks safely overapproximates the set of possible outputs [Dutta
et al. 2018; Gehr et al. 2018; Wang et al. 2018; Weng et al. 2018; Xiang et al. 2018, 2017].

Patching deep neural networks. Prior work focuses on enforcing constraints on the network
during training. DiffAI [Mirman et al. 2018] is an approach to train neural networks that are

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:29

(a) Before patching.

(b) After one iteration (weight
change).

(c) After five iterations (weight
changes).

(d) Before patching (generaliza-
tion region).

Legend:

Clear-of-Conflict, Weak Right,

Strong Right,

(e) Generalization after one it-
eration (weight change) on the
patch region.

(f) Generalization after five iter-
ations (weight change) on the
patch region.
Strong Left, Weak Left.

Fig. 11. Network patching for the “Symmetry” spec (Lowering the main decision boundary between strong-left
and strong-right to become symmetrical).

certifiably robust to adversarial perturbations. DL2 [Fischer et al. 2019] allows for training and
querying neural networks with logical constraints.

10 CONCLUSION
We proposed a symbolic neural network representation, denoted (cid:98)f , which decomposes a piecewise-
linear neural network into its constituent affine maps. We applied this symbolic representation to
three problems relating to trained neural networks. First, we showed how the representation can
be used to compute weakest preconditions, which allow one to exactly visualize network decision
boundaries. Next, we demonstrated the symbolic representation’s use for computing strongest
postconditions, allowing us to perform iterative bounded model checking. Finally, we introduced
the problem of patching neural networks, which can be interpreted as explicitly correcting their
decision boundaries. We presented an efficient and effective approach to patching neural networks,
relying on a new neural network architecture, the symbolic representation, and a dedicated MAX
SMT solver.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:30

Matthew Sotoudeh and Aditya V. Thakur

ACKNOWLEDGMENTS
We thank Nina Amenta, Yong Jae Lee, Mukund Sundararajan, and Cindy Rubio-Gonzalez for their
feedback and suggestions on this work, along with Amazon Web Services Cloud credits for research.

REFERENCES
2019. ETH Robustness Analyzer for Neural Networks (ERAN). https://github.com/eth-sri/eran. Accessed: 2019-05-01.
Greg Anderson, Shankara Pailoor, Isil Dillig, and Swarat Chaudhuri. 2019. Optimization and Abstraction: A Synergistic

Approach for Analyzing Neural Network Robustness. CoRR abs/1904.09959 (2019).

Osbert Bastani, Yani Ioannou, Leonidas Lampropoulos, Dimitrios Vytiniotis, Aditya V. Nori, and Antonio Criminisi. 2016.

Measuring Neural Net Robustness with Constraints. In Advances in Neural Information Processing Systems.

Osbert Bastani, Yewen Pu, and Armando Solar-Lezama. 2018. Verifiable Reinforcement Learning via Policy Extraction. In
Advances in Neural Information Processing Systems 31: Annual Conference on Neural Information Processing Systems 2018,
NeurIPS 2018, 3-8 December 2018, Montréal, Canada. 2499–2509.

Dirk Beyer. 2016. Reliable and reproducible competition results with benchexec and witnesses (report on SV-COMP 2016). In
International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS). Springer, 887–904.
Armin Biere, Alessandro Cimatti, Edmund M Clarke, Ofer Strichman, and Yunshan Zhu. 2009. Bounded Model Checking.

Handbook of satisfiability 185, 99 (2009), 457–481.

Stephan Breutel, Frédéric Maire, and Ross Hayward. 2003. Extracting Interface Assertions from Neural Networks in
Polyhedral Format. In ESANN 2003, 11th European Symposium on Artificial Neural Networks, Bruges, Belgium, April 23-25,
2003, Proceedings. 463–468.

Rudy R. Bunel, Ilker Turkaslan, Philip H. S. Torr, Pushmeet Kohli, and Pawan Kumar Mudigonda. 2018. A Unified View of
Piecewise Linear Neural Network Verification. In Advances in Neural Information Processing Systems 31: Annual Conference
on Neural Information Processing Systems 2018, NeurIPS 2018, 3-8 December 2018, Montréal, Canada. 4795–4804.

Nicholas Carlini and David Wagner. 2018. Audio adversarial examples: Targeted attacks on speech-to-text. In 2018 IEEE

Security and Privacy Workshops (SPW). IEEE, 1–7.

Ronan Collobert. 2004. Large scale machine learning. Ph.D. Dissertation. Université de Paris VI.
L. de Moura and N. Bjørner. 2008. Z3: An Efficient SMT Solver. In International Conference on Tools and Algorithms for the

Construction and Analysis of Systems (TACAS).

Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. BERT: Pre-training of Deep Bidirectional

Transformers for Language Understanding. CoRR abs/1810.04805 (2018).

Souradeep Dutta, Susmit Jha, Sriram Sankaranarayanan, and Ashish Tiwari. 2018. Output range analysis for deep feedforward

neural networks. In NASA Formal Methods Symposium. Springer, 121–138.

Ruediger Ehlers. 2017. Formal verification of piece-wise linear feed-forward neural networks. In International Symposium

on Automated Technology for Verification and Analysis (ATVA).

Jonathan Fiat, Eran Malach, and Shai Shalev-Shwartz. 2019. Decoupling Gating from Linearity. arXiv preprint arXiv:1906.05032

(2019).

Marc Fischer, Mislav Balunovic, Dana Drachsler-Cohen, Timon Gehr, Ce Zhang, and Martin Vechev. 2019. DL2: Training

and Querying Neural Networks with Logic. In International Conference on Machine Learning.

Timon Gehr, Matthew Mirman, Dana Drachsler-Cohen, Petar Tsankov, Swarat Chaudhuri, and Martin T. Vechev. 2018.
AI2: Safety and Robustness Certification of Neural Networks with Abstract Interpretation. In 2018 IEEE Symposium on
Security and Privacy, SP 2018, Proceedings, 21-23 May 2018, San Francisco, California, USA.

Ian Goodfellow, Yoshua Bengio, and Aaron Courville. 2016. Deep Learning. MIT Press. http://www.deeplearningbook.org.
Ian J. Goodfellow, Jonathon Shlens, and Christian Szegedy. 2015. Explaining and Harnessing Adversarial Examples. In

International Conference on Learning Representations, ICLR.

Xiaowei Huang, Marta Kwiatkowska, Sen Wang, and Min Wu. 2017. Safety verification of deep neural networks. In

International Conference on Computer Aided Verification (CAV).

Bertrand Jeannet and Antoine Miné. 2009. Apron: A library of numerical abstract domains for static analysis. In International

Conference on Computer Aided Verification (CAV). Springer, 661–667.

Kyle D Julian, Mykel J Kochenderfer, and Michael P Owen. 2018. Deep neural network compression for aircraft collision

avoidance systems. Journal of Guidance, Control, and Dynamics 42, 3 (2018), 598–608.

Guy Katz, Clark Barrett, David L Dill, Kyle Julian, and Mykel J Kochenderfer. 2017. Reluplex: An efficient SMT solver for

verifying deep neural networks. In International Conference on Computer Aided Verification (CAV).

Alex Krizhevsky, Ilya Sutskever, and Geoffrey E. Hinton. 2017. ImageNet classification with deep convolutional neural

networks. Commun. ACM 60, 6 (2017), 84–90.

Matthew Mirman, Timon Gehr, and Martin Vechev. 2018. Differentiable abstract interpretation for provably robust neural

networks. In International Conference on Machine Learning ICML.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:31

Seyed-Mohsen Moosavi-Dezfooli, Alhussein Fawzi, and Pascal Frossard. 2016. DeepFool: A Simple and Accurate Method to
Fool Deep Neural Networks. In 2016 IEEE Conference on Computer Vision and Pattern Recognition, CVPR 2016, Las Vegas,
NV, USA, June 27-30, 2016. 2574–2582.

Anh Mai Nguyen, Jason Yosinski, and Jeff Clune. 2015. Deep neural networks are easily fooled: High confidence predictions
for unrecognizable images. In IEEE Conference on Computer Vision and Pattern Recognition, (CVPR) 2015, Boston, MA, USA,
June 7-12, 2015. 427–436.

Josh Patterson and Adam Gibson. 2017. Deep learning: A practitioner’s approach. " O’Reilly Media, Inc.".
Karsten Scheibler, Leonore Winterer, Ralf Wimmer, and Bernd Becker. 2015. Towards Verification of Artificial Neural
Networks. In Methoden und Beschreibungssprachen zur Modellierung und Verifikation von Schaltungen und Systemen,
MBMV 2015, Chemnitz, Germany, March 3-4, 2015. 30–40.

Gagandeep Singh, Timon Gehr, Markus Püschel, and Martin T. Vechev. 2019. An abstract domain for certifying neural

networks. PACMPL 3, POPL (2019), 41:1–41:30.

Christian Szegedy, Vincent Vanhoucke, Sergey Ioffe, Jon Shlens, and Zbigniew Wojna. 2016. Rethinking the inception
architecture for computer vision. In Proceedings of the IEEE conference on computer vision and pattern recognition (CVPR).
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian J. Goodfellow, and Rob Fergus. 2014.

Intriguing properties of neural networks. In International Conference on Learning Representations, ICLR.

Sebastian Thrun. 1994. Extracting Rules from Artifical Neural Networks with Distributed Representations. In Advances in

Neural Information Processing Systems 7, [NIPS Conference, Denver, Colorado, USA, 1994]. 505–512.

Shiqi Wang, Kexin Pei, Justin Whitehouse, Junfeng Yang, and Suman Jana. 2018. Formal Security Analysis of Neural
Networks using Symbolic Intervals. In 27th USENIX Security Symposium, USENIX Security 2018, Baltimore, MD, USA,
August 15-17, 2018. 1599–1614.

Tsui-Wei Weng, Huan Zhang, Hongge Chen, Zhao Song, Cho-Jui Hsieh, Luca Daniel, Duane S. Boning, and Inderjit S.
Dhillon. 2018. Towards Fast Computation of Certified Robustness for ReLU Networks. In International Conference on
Machine Learning, (ICML).

Weiming Xiang, Hoang-Dung Tran, Joel A. Rosenfeld, and Taylor T. Johnson. 2018. Reachable Set Estimation and Safety
Verification for Piecewise Linear Systems with Neural Network Controllers. In 2018 Annual American Control Conference,
(ACC).

Weiming Xiang, Hoang-Dung Tran, and Taylor T Johnson. 2017. Reachable set computation and safety verification for

neural networks with ReLU activations. arXiv preprint arXiv:1712.08163 (2017).

He Zhu, Zikang Xiong, Stephen Magill, and Suresh Jagannathan. 2019. An inductive synthesis framework for verifiable
reinforcement learning. In Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and
Implementation, PLDI 2019, Phoenix, AZ, USA, June 22-26, 2019. 686–701.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:32

A THEOREM 4

Matthew Sotoudeh and Aditya V. Thakur

Theorem 4. There exists a continuous, fully-differentiable function f such that (cid:98)f does not exist.
Proof. One such function is f (x) = x 2, which is clearly differentiable everywhere with d
dx f =

2x.

Suppose there existed some (cid:98)f = {(P1, F1), (P2, F2), . . . , (Pn, Fn)}. Then, as the domain of f is
infinite (R) and is partitioned with finitely many polytopes, at least one Pi must have infinitely
many (and thus more than one) distinct points.

Now, consider any two points x1 (cid:44) x2 ∈ Pi . Then we have:
x1 + x2
2

(cid:16) x1 + x2
2

(cid:17) 2

= Fix1 + Fix2
2
x 2
1 + x 2
2
2
2
1 + 2x

=

2
2

=⇒

=⇒

= Fi
x 2
1 + 2x1x2 + x 2
2
4
1 + 2x1x2 + x 2
x 2
2
4
2
1 + 2x1x2 + x
2
1 + x
2
1 − 2x1x2 + x

=⇒ x
=⇒ 2x1x2 = x
=⇒ 0 = x
=⇒ 0 = (x1 − x2)2
=⇒ x1 = x2

2
2 = 2x
2
2

2
2

Which contradicts our assumption that x1 (cid:44) x2.

B THEOREM 5

(5)

□

Theorem 5. There exists a continuous, fully-differentiable function f such that (cid:99)f↾X does not exist

for any non-singleton and non-empty choice of X .

Proof. We observe that the argument from Theorem 4 holds here as well; if X is a non-singleton,
non-empty polytope, then it contains infinitely many points and so any finite partitioning of it
will have at least one partition containing more than one distinct point. From there, the proof is
□
identical.

C THEOREM 6

Theorem 6. There exists a continuous, fully-differentiable function f and a non-singleton, non-

empty polytope X such that (cid:98)f does not exist but (cid:99)f↾X does.

Proof. Consider the function f (x1, x2) = x 2

1 − x 2

2 = (x1 + x2)(x1 − x2) and the bounded polytope

X defined by {x | 0 ≤ x1 ≤ 1 ∧ x1 − x2 = 1}.

We first show that (cid:98)f does not exist. Suppose (cid:98)f = {(P1, F1), . . . , (Pn, Fn)} exists. Then, it holds

that:

(cid:99)f↾Z = {(P1 ∩ Z , F1), . . . , (Pn ∩ Z , Fn)}
Also exists, where Z is the convex polytope defined by x2 = 0. However, f↾Z = f (x1, 0) = x 2
this implies that (cid:156)(x (cid:55)→ x 2) exists, contradicting the proof of non-existence given in Theorem 4.

1, so

Finally, we show that (cid:99)f↾X does exist, where X = {x | x1 ≤ 1 ∧ x1 − x2 = 1. In that case,
all x values satisfy x1 − x2 = 1, so f (x) = (x1 + x2)(x1 − x2) = x1 + x2, which is affine. Thus
□
(cid:99)f↾X = {(X , x (cid:55)→ x1 + x2)} is a valid solution.

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:33

D THEOREM 7

Theorem 7. For any piecewise-linear function f , f ⊗ (cid:98)д is computable for any
Proof. Let our piecewise-linear function have linear regions {R1, . . . , Rk } with associated affine

(cid:98)д.

maps {M1, . . . , Mk }.

(cid:98)д = {(P1, F1), . . . , (Pm, Fm)}.

Let
We note that, because the Pi s partition the domain of д, it suffices to show the construction on
any of the (Pi , Fi ) pairs individually; the union of the results for each (Pi , Fi ) pairs will form f ⊗ (cid:98)д.

Now, consider any (Pi , Fi ) pair in

(cid:98)д. We compute the post-set of Pi under Fi :

Yi = {Fix | x ∈ Pi }
Which is a convex polytope, the vertices of which can be computed by applying Fi to each of the

finitely-many vertices of Pi (this a well-known fact in convex geometry).

Next, we compute Y j
i

= Yi ∩ Rj , where Rj again is the jth linear region of f associated with map
Bj . This again is computable, as there are finitely many such Rj s and the intersection of two convex
polytopes can be computed by conjunction of their half-space faces.

We have now partitioned Yi according to the linear regions of f , all that remains is to find a

corresponding partitioning of Pi such that each partition P j
i

maps to Y j
i

under Fi .

For each vertex vl of Y j
i

, we then compute cl , a convex combination of the vertices of Yi that
forms vl , i.e. Vert(Yi ) · cl = vl . Notably, to deal with non-invertible Fi maps, when multiple Y j
share
i
the same vertex vl , we must pick the same combination cl (which can be accomplished via a memo
dictionary of previously found (vl , cl ) pairs). Furthermore, when vl is also a vertex of Yi , we must
use the corresponding vertex from Pi .

Now, for each of the (vl , cl ) pairs, we compute pl = Vert(Pi )cl . We note that, because Fi is affine:

Fi (pl ) = Fi (Vert(Pi )cl ) = Vert(Yi )cl = vl
We note now that the pl s partition Pi because the vl s partition Yi and we mapped each vl back

uniquely to a pl (mapping vertices to vertices where applicable). We now define:

P j
i
Finally, we claim that:

= {pl

| the corresponding vl is a vertex of Y j
i }

(cid:154)f ◦ д = {(P

1
i , M1 ◦ Ai ), (P
This follows as all points in Pi are first mapped to Fix ∈ Y j
i

2
i , M2 ◦ Ai ), . . . , (P k

mapped to Bj (Aix) = (BjAi )x by the application of f .

i , Mk ◦ Ai ) | 1 ≤ i ≤ m}

by д then each point Fix in Y j
i

is
□

E COROLLARIES 1—5
These follow as all of the described functions are well-known to be piecewise-linear.

F COROLLARY 6
Corollary 6. f ⊗ (cid:98)д is computable for any
FullyConnected, 2DConvolution, BatchNorm, ReLU, and MaxPool layers.

(cid:98)д and neural network f consisting of sequentially-applied

Proof. Let the layers be l1, l2, . . . , ln such that f = ln ◦ ln−1 ◦ · · · ◦ l1.
Now, we have:

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

1:34

Matthew Sotoudeh and Aditya V. Thakur

ln ⊗ · · · ⊗ l2 ⊗ l1 ⊗ (cid:98)д = ln ⊗ · · · ⊗ l2 ⊗ (cid:155)(l1 ◦ д)
= ln ⊗ · · · ⊗ (cid:156)(l2 ◦ l1 ◦ д)

...

= (cid:156)(ln ◦ · · · ◦ l1 ◦ д)
= (cid:155)(f ◦ д)
= f ⊗ (cid:98)д
Thus, f ⊗ (cid:98)д is computable by repeated application of li ⊗ · for descending i > 0, and li ⊗ · was
□

shown computable in Corollaries 1—5.

G THEOREM 8

Theorem 8. Algorithm 1 correctly splits a 2D polytope ConvexHull(V ) by the hyperplane xd = 0.
Proof. It is well-known in computational geometry that the vertices of the intersection of a
polytope with a hyperplane is the intersection of its edges with the plane. The algorithm computes
the ratio along each edge that the intersection is reached using standard linear algebra, i.e.:

(Q + α(R − Q))d = 0
=⇒ Qd + α(Rd − Qd ) = 0

=⇒ α = −

Qd
Rd − Qd

Because F is affine, the ratio holds when taking the preimage as well (which is what is returned). □

H THEOREM 9

Theorem 9. Algorithm 2 correctly computes (cid:156)ReLU ◦ д↾X
Proof. It suffices to show that the algorithm correctly partitions each input polytope P such
that the signs within a partition are constant. Notably, because of convexity, it suffices to show that
the signs of the vertices of each partition are constant.

.

We maintain two invariants every time we process some P, F pair from the queue. The first is
that the corresponding polytope will only be added to Y if the signs of all vertices are constant
(or zero). The second is that at each step, we partition the polytope into two new ones (using
SplitPlane) such that fewer sign switches happen in each than the original polytope. This follows
from the correctness of the SplitPlane algorithm.

The first invariant ensures that, if it halts, the algorithm is correct. The second ensures that it
□

will halt, as there are only finitely many dimensions to consider.

I THEOREM 14

Theorem 14. Given a masking network f (x; θ a, θ v ) parameterized by activation parameters θ a
and value parameters θ v , an input polytope X , output polytope Y , and (cid:99)f↾X = {(P1, F1), . . . , (Pn, Fn)},
then:

A values-patched network f (x; θ a, θ v + δ ), modifying only θ v , satisfies the property ∀x ∈ X :
: ∀v ∈ Vert(Pi ) :

f (x; θ a, θ v + δ ) ∈ Y if and only if it satisfies the property ∀(Pi , Fi ) ∈ (cid:156)f (x; θ a, θ v )↾X
Fi (v; θ v + δ ) ∈ Y .

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

A Symbolic Neural Network Representation and Applications

1:35

Proof. This follows as the function within each partition is affine, and thus convex. If all of the
vertices fall inside of Y , then by definition of convexity all of the interior points must as well (and
□
vice-versa).

Proc. ACM Program. Lang., Vol. 1, No. CONF, Article 1. Publication date: January 2018.

