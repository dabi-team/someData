9
1
0
2

g
u
A
4
1

]

R
C
.
s
c
[

1
v
2
1
0
5
0
.
8
0
9
1
:
v
i
X
r
a

Side-Channel Aware Fuzzing

Philip Sperl and Konstantin B¨ottinger

Fraunhofer Institute for Applied and Integrated Security
philip.sperl@aisec.fraunhofer.de
konstantin.boettinger@aisec.fraunhofer.de

Abstract. Software testing is becoming a critical part of the devel-
opment cycle of embedded devices, enabling vulnerability detection. A
well-studied approach of software testing is fuzz-testing (fuzzing), dur-
ing which mutated input is sent to an input-processing software while
its behavior is monitored. The goal is to identify faulty states in the
program, triggered by malformed inputs. Even though this technique is
widely performed, fuzzing cannot be applied to embedded devices to its
full extent. Due to the lack of adequately powerful I/O capabilities or an
operating system the feedback needed for fuzzing cannot be acquired.
In this paper we present and evaluate a new approach to extract feed-
back for fuzzing on embedded devices using information the power con-
sumption leaks. Side-channel aware fuzzing is a threefold process that is
initiated by sending an input to a target device and measuring its power
consumption. First, we extract features from the power traces of the tar-
get device using machine learning algorithms. Subsequently, we use the
features to reconstruct the code structure of the analyzed ﬁrmware. In
the ﬁnal step we calculate a score for the input, which is proportional to
the code coverage.
We carry out our proof of concept by fuzzing synthetic software and a
light-weight AES implementation running on an ARM Cortex-M4 mi-
crocontroller. Our results show that the power side-channel carries infor-
mation relevant for fuzzing.

Keywords: Embedded systems security · Side-channel analysis · Fuzzing

1

Introduction

Embedded systems are nowadays used in a wide range of domains and appli-
cations. The employed devices are often connected to information exchanging
networks like the Internet of Things (IoT). As the number of connected devices
is continuously growing, the security of the employed software is gaining impact
on our daily life.

Vulnerabilities in embedded devices can be classiﬁed by their cause of occur-
rence, e.g., programming errors, web-based vulnerabilities, weak access control
or authentication, and improper use of cryptography [20]. In the following we
will focus on the security threats emerging from programming errors. Such errors
often lead to memory corruptions like buﬀer overﬂows, which attackers make use

 
 
 
 
 
 
2

P. Sperl, K. B¨ottinger

of in targeted exploits. To prevent or ﬁnd errors leading to such vulnerabilities,
several measures exist. For instance, source code analysis during the development
of the system, or subsequent reverse engineering. Both techniques require either
the source code or at least deep understanding of the system. Furthermore, both
approaches cannot be automated or executed large-scale, which increases cost,
either during the development or security evaluation phase.

From the realm of general purpose computers and software testing, the ap-
proach of fuzz-testing (fuzzing) is widely accepted and even executed during
commercial software development [11]. During fuzzing, automatically generated
input is sent to the input-processing software under test (SUT) while its behav-
ior is examined. Diﬀerent instrumentation techniques and mechanisms provided
by the operating system (OS) allow evaluation of the impact of the input, lead-
ing to an eﬀective and automated vulnerability detection tool. Because of the
I/O-limitations, restricted computing power, and missing OS, embedded systems
lack the possibility of returning enough information required during fuzzing [18].
This restrains fuzzing on embedded devices to a black-box manner.

To circumvent this problem, we present a novel and unexplored technique us-
ing the power side-channel of embedded devices as source of feedback for fuzzing.
We show that the process of sending an input vector to the device, measuring
the power consumption, and extracting information from the power traces en-
ables us to deduce the control ﬂow graph (CFG) of the software. Subsequently,
we present a method of using this representation of the control ﬂow to evaluate
the impact of the input on the behavior of the device in terms of code coverage.
We show that this approach is a signiﬁcant step towards white-box fuzzing on
embedded devices.

In summary, we make the following contributions:

– We present the novel idea of extracting feedback from the power side-channel

to enhance fuzzing of embedded devices.

– In the proof of concept we successfully fuzz synthetic software and a light-
weight advanced encryption standard (AES) [19] implementation and eval-
uate our results.

– Finally, we provide a base line for future work on side-channel-based feature

extraction.

The rest of this paper is organized as follows. In Section 2 we review related
work and summarize latest ﬁndings in embedded device fuzzing. We present our
concept of extracting feedback from the power side-channel to enable white-box
fuzzing of embedded devices in Section 3. In Section 4 we present our proof-of-
concept and evaluation results. We conclude the paper in Section 5.

2 Related Work

We divide this section into four parts. First we show challenges in embedded de-
vice fuzzing before we introduce state-of-the-art techniques. Subsequently we
present latest ﬁndings in side-channel based reverse engineering. Finally, we

Side-Channel Aware Fuzzing

3

present the ﬁrst contributions using side-channel information to assess the pro-
gram ﬂow of embedded devices.

Muench et al. [18] split the challenges encountered when fuzzing embedded
devices into three categories. We adopt this categorization for devices without
an OS and explain it in the following.

Fault Detection: Faults during program execution often lead to program
crashes, which need to be detected during fuzzing. For fuzzing on a PC, the
OS oﬀers mechanisms for detecting crashes, e.g., a segmentation fault commu-
nicated to the fuzzing tool by console output. Even though some embedded
processors contain Memory Management Units (MMU), the lack of an OS hin-
ders the possibility to communicate faults to the outer world. Hence, possible
program crashes or subsequent reboot sequences may remain undetected.

Performance, Throughput, and Scalability: Proﬁting from the multitasking
capabilities of OS-based systems, multiple instances of the SUT can run si-
multaneously, increasing the fuzzing throughput. Transferring this knowledge
to embedded systems suﬀers limitations, because of the missing OS or single-
core architecture of the devices. A solution is the application of multiple devices
executing the same ﬁrmware, which may be limited due to ﬁnancial restrictions.
Instrumentation: Both, compile-time and run-time approaches suﬀer in feasi-
bility due to the restrictions in embedded systems. Recompiling binaries, like on
PCs, is not possible if the source code is not available. Besides the diﬃcult task of
binary rewriting, run-time instrumentation techniques as well as virtualization
are not applicable due to the missing OS.

Because of the diﬃculties presented above, research concerning fuzzing of
OS-free embedded devices exclusively deals with a black-box approach. Even
though we present a white-box solution, some ﬁndings in black-box fuzzing are
worth mentioning. Koscher et al. [13] and Lee et al. [14] carry out fuzzing of
CAN packets. Alimi et al.[1] made use of black-box fuzzing when looking for
vulnerabilities in applets on smart cards. Muench et al.[18] try to improve fuzzing
by partial and full emulation of embedded devices. Zaddach et al. [26] propose a
related approach and improve the emulation-based testing process by forwarding
memory accesses on the emulated target to the physical device.

Symbolic execution poses an alternative approach. Davidson et al. [6] show
the possibility to ﬁnd bugs in ﬁrmware using a speciﬁcation of the memory
layout of the target device, the source code, and their KLEE-based [3] symbolic
execution engine. With this setup the authors are able to perform fuzzing of the
target device. Further improvements to this approach were shown by Corteggiani
et al. [5], in which access to the source code is required as well.

Ever since the introduction of the Diﬀerential Power Analysis by Kocher et al.
[12] numerous publications picked up the concept of analyzing information leaked
over the power or electromagnetic (EM) side-channel of embedded devices. As we
link the concepts of side-channel analysis and fuzzing, we proﬁt from research
in the ﬁeld of side-channel based reverse engineering. Strobel et al. [24] show
an eﬀective way to reconstruct the assembly code executed by CPUs using EM
emanations. By decapsulating the attacked chip and using eight measurement

4

P. Sperl, K. B¨ottinger

probes, the authors achieve an instruction recognition rate of 87.69% targeting
real code. Msgna et al. [17] use a k-nearest neighbors (kNN ) classiﬁcation for
reverse engineering. The authors exploit the fact that the power consumption
of digital circuits depends on the processed data and executed instructions [15].
Targeting test code the authors achieve an instruction recognition rate of 100%.
The ﬁrst method using side-channel information to gain insights into the
executed code paths of an embedded device is presented by Callan et al. [4]. In the
training phase the authors measure the EM emanations of a target device while it
executes instrumented code. During the proﬁling phase EM traces are measured
while the device executes the original source code. The authors compare both
sets of EM traces to identify the currently executed program path. If further
reﬁned, this approach poses a possible source of information to fuzz ﬁrmware
for which the source code is available. Nonetheless, the authors do not evaluate
the scenario in which the source code is not available. Similarly, Han et al. [9]
use the EM emanations of embedded controllers to identify the current control
ﬂow. The authors are able to detect malicious executions with high conﬁdence.
Van Aubel et al. [25] use EM traces and methods from the classical side-channel
analysis to build an intrusion detection tool for industrial control systems.

3 Elements of Side-Channel Aware Fuzzing

In this section we present our main contribution, a novel technique for extracting
feedback from an embedded device using the power side-channel to make white-
box fuzzing possible. In particular, we calculate scores for the inputs proportional
to the provoked code coverage. The calculation of the scores is inspired by the
procedure implemented in the widely used and accepted American Fuzzy Lop
(AFL) fuzzing tool. By instrumenting the code, AFL counts the basic block
transitions during the processing of each input. The number of newly executed
basic block transitions is then directly used as score for the inputs, see [27]. In
subsequent fuzzing runs, AFL mutates inputs with the highest scores and feeds
them back to the SUT. The goal is to accumulate a series of inputs for which
a code coverage of 100% is reached. In this paper we neglect the prioritization
and mutation of the inputs and solely provide code coverage scores. The scores
can then be fed to a tool like AFL, to perform the remaining actions required
for a closed fuzzing loop.

We carry out the illustration of our concept in a bottom-up manner. First, we
explain all underlying building blocks, before we present the complete concept
as well as the overall schematic of the side-channel aware fuzzing loop. In Figure
1 we show the setup and required equipment. During the feedback-driven loop,
we use an oscilloscope to measure the power consumption of the target device
and send the power traces to the evaluation computer. Using this PC we process
the traces and conduct the side-channel analysis (SCA) consisting of three steps.
First, we identify the individual basic blocks of the software. In the second step
we characterize the found basic blocks and the transition sequence. Finally, we
calculate code coverage scores for each input.

Side-Channel Aware Fuzzing

5

Fig. 1: Side-channel driven fuzzing feedback loop.

Throughout the discussion of the SCA building blocks we assume that for
each input sent to the device, its power consumption is measured. The lengths
of the power traces cover the exact time the device requires to process the cur-
rently evaluated input. For the sake of simplicity, we examine one input and
its corresponding trace in the following. In a real world application and during
our proof of concept, we perform the analysis for each input sent to the target
device.

3.1 Feature Extraction Using the Power Side-Channel

A power trace is an array of n quantized measurement points of the physical
power consumption of the target device. The number of points depends on the
measurement period and the sampling rate of the used oscilloscope. Even though
side-channel aware fuzzing is based on power traces, we convey our concept
without illustration of actual power measurements. We decided to do so in order
to provide a general introduction of our approach, which can be transferred
to a wide range of devices. The central goal of our concept is to estimate the
code coverage triggered during the processing of the current input. A widely
used metric to express code coverage is the number of basic block transitions.
In this paper we make use of this idea, therefore we deﬁne basic blocks and the
separation of such in the following.

Basic blocks are lines of code which are executed without interruption of a
branch instruction [10]. Hence, if the execution of a basic block begins, it will be
executed completely before another basic block is triggered. Branch instructions
at the end of each basic block coordinate the transitions.

This observation builds the core of our concept. If we detect the moment in
which a target device executes a branch instruction, we ﬁnd the borders between
the basic blocks. As a consequence, we focus on this class of instructions and

   Information Extraction,   Side-Channel AnalysisPCMeasurementInput TracesOscilloscopeEvaluationInput MutationTarget DeviceScores6

P. Sperl, K. B¨ottinger

present a method to detect branch instructions using the collected power traces.
Subsequently we provide methods to characterize the basic blocks, so that we
can estimate the number of individual basic block transitions per input.

Branch Detection The power consumption of digital circuits consists of four
components. Each sample of a power trace is determined by the executed instruc-
tion, processed data, electronic noise characteristics of the device, and a constant
component. To detect branches we exploit the operation-dependent component
of the power consumption.

We interpret the branch detection as a binary classiﬁcation problem, since
all remaining instructions executed by the device are not of interest. During
initialization we split the examined power trace into k windows. Note that the
beginning of each window matches the beginning of a potential branch instruc-
tion. Moreover, the windows and the branch instructions share the same length.
After this initialization, we carry out the binary classiﬁcation, which we execute
k times per trace. In this classiﬁcation procedure a predictor decides which win-
dow shows a branch instruction. Machine learning algorithms with a previous
training phase can build the basis for the predictor. If the prediction indicates
that the currently analyzed window shows a branch, we add the location to the
result list Blocations.

To create train data on which the machine learning algorithm can be trained,
we need an identical and programmable target device. We let this training device
execute branch instructions with various oﬀsets and distances, while we measure
its power consumption. During the supervised training, we use the labeled power
traces to create the branch detection model.

Branch Distance Classiﬁcation A feature providing evidence whether a tran-
sition was already executed before is the distance between a found basic block
and its predecessor. Here, we deﬁne this distance as the number of instructions
which the device under test (DUT) skips due to the branch instruction.

In order to estimate the number of skipped instructions we exploit the data-
dependent component of power traces and the following insight. Branch instruc-
tions contain labels to which they should jump. The CPU calculates the distance
between the current location and the label and adds it to the program counter.
Since this process is data-dependent, the power side-channel leaks information
about this distance.

We again use a supervised machine learning algorithm to estimate the dis-
tances of the found branches. In the training phase our train device performs
branches with known distances while we measure its power consumption. We use
the resulting labeled data to train the algorithm and create the branch distance
model.

In the branch distance classiﬁcation we ﬁrst cut the traces, such that we
only evaluate samples measured during the execution of branch instructions. We
apply our previously created model and store the classiﬁcation output in the
result list Bdistances.

Side-Channel Aware Fuzzing

7

As an alternative to the branch distance classiﬁcation which might not be
successful for every branch or device, we present an additional approach to dis-
tinguish the basic blocks in the following.

Basic Block Fingerprinting To distinguish basic blocks we assign side-channel
based ﬁngerprints to each. For this purpose we use the slices of the power traces
between the previously found branch instructions. These parts represent the
power consumption during the execution of basic blocks. Hence, we conduct an
initialization phase in which we cut the traces accordingly. In the ﬁrst step of
our algorithm we extract four features from each analyzed power trace window.
Subsequently we use the features to ﬁngerprint the basic blocks. We present the
extracted features and illustrate the purpose of each in terms of contributed
information.

Basic blocks often diﬀer in their required execution time. Evaluating this
feature allows an easy-to-implement distinction. Therefore, the ﬁrst metric we
consider is the length Plength of the individual slices.

For the calculation of the second feature Ppeaks, the algorithm evaluates
the number of peaks for each trace segment. For the majority of embedded
devices, the power traces consist of periodically occurring peaks. Internal clocks
which may have the frequency of the system clock or other clocks like the ﬂash
clock have the major impact on the number of peaks. Additional peaks can
occur in the power traces due to complex instructions. The additionally required
computational power increases the power consumption resulting in spikes in the
traces. Thus, the number of peaks in the trace windows shows the approximate
duration and indicate the complexity of the executed instructions.

The third metric is the mean Pmean, of the windows, which is the mean power

consumption during the basic block execution.

The last metric we calculate is the skewness, Pskewness. Translated to the
power consumption, this metric enables the following distinction of cases. As-
sume two basic blocks A and B sharing the same number of instructions, with
identical mean power consumption. Basic block A consists of instructions with
evenly distributed computational cost and resulting power consumption. In con-
trast to that, basic block B contains one signiﬁcantly more complex instruction
than the instructions found in A. Furthermore, the remaining instructions in B
are less complex than the ones found in A, resulting in a the same mean power
consumption. By analyzing the skewness of the power traces, we are able to
distinguish basic blocks A and B.

In the ﬁnal step of the basic block ﬁngerprinting, we superpose the four ex-
tracted features to create the ﬁngerprints. We present two approaches to achieve
this superposition.

In our ﬁrst approach we take all four values of the currently analyzed basic
block and store them in a four-dimensional vector. We call this method separated.
This approach is easy to implement, however, in subsequent calculations the
dimension of the feature vector can lead to increased execution times compared
to a scalar value representing the ﬁngerprint.

8

P. Sperl, K. B¨ottinger

Therefore, in the second approach, which we call summed, we adopt this idea
and sum up the four previously calculated values. Alternatively, a hash function
can be applied to generate a ﬁngerprint. This approach is very eﬀective if the
underlying values already lead to a strong distinction between the basic blocks.
For both approaches we store the ﬁngerprints of the basic blocks in the result
table Bprints.

3.2 Control Flow Reconstruction

In this section we use our knowledge of the basic block transitions to reconstruct
the program ﬂow of the analyzed ﬁrmware. We present two algorithms for this
purpose. Both use the previously found branch locations. The ﬁrst algorithm uses
the branch distances, while the second one uses the basic block ﬁngerprints to
further characterize the transitions. For both approaches we give an exemplary
control ﬂow in Figure 2 to visualize the concepts of the reconstruction. Each
control ﬂow represents the processing of one input by the target device.

(a) CFG-RI.

(b) CFG-RII.

Fig. 2: Illustration of the two control ﬂow reconstruction algorithms and the
required information.

Furthermore, we introduce the following notation. Bx indicates the branch
location with the index x. The corresponding distance of the branch to its succes-
sor is dx. The length of the executed basic block with index i is li. The ﬁngerprint
for the basic block A is FA.

Lines of CodeCode Executed,triggered by Input 0B0B1B2B3l0l2l1l3d0d1d2Lines of CodeCode Executed,triggered by Input 0B0B1B2B3FAFBFCFDSide-Channel Aware Fuzzing

9

We store the results of the control ﬂow reconstruction in the table TCFG.
Table 1 shows the results according to the examples from Figure 2. The left
column holds the branch IDs for all inputs, while the columns to the right hold
the results of the control ﬂow reconstruction. In the following we convey both
algorithms and explain the results from Table 1.

CFG Reconstruction I (CFG-RI) In this CFG reconstruction algorithm we
use our knowledge of the branch locations Blocations and their corresponding dis-
tances Bdistances. For each branch we calculate a two-dimensional vector which
characterizes the subsequent basic block and store it in TCFG. Thereby we suf-
ﬁciently describe the control ﬂow of the tested software in order to evaluate the
sequence of performed basic block transitions. In the following we describe the
creation of the vectors using Figure 2 a).

We build the vector [Boﬀset, Clength] by stacking two characteristic values for
each basic block. Boﬀset indicates the oﬀset of the branch location in the code,
expressed in number of instructions executed or skipped until the branch itself
is executed. In Figure 2 a), for branch B0 this value is l0. For branch B1 this
value depends on the following intermediate results. Until B1 is executed, the
two basic blocks with the lengths l0 and l1 are executed. In addition to that,
we estimate the distance of branch B0 to be d0. Hence, with the sum of the
discovered distances (l0 + l1 + d0) we express the oﬀset for branch B1. The
second result value Clength is the length of the code after each branch, li. For
the branches B0 and B1 these values are l1 and l2, respectively.

With the location of a speciﬁc branch with respect to the previously executed
code and the length of the following basic block, we suﬃciently describe the
control ﬂow of the code to evaluate if we triggered a new basic block transition.

CFG Reconstruction II (CFG-RII) In this approach we use the unique
ﬁngerprints Bprints. Each ﬁngerprint describes one basic block, which enables us
to distinguish them. Hence, we directly store the ﬁngerprints in the result table
next to the according branch ID. Note that we assume the code started without
an initial branch. Therefore the ﬁrst ﬁngerprint is stored without an associated
branch ID. With this result table we provide the sequence of transitions and
fully reconstruct the program ﬂow on the basic block level.

Theoretical Comparison Both algorithms reconstruct the analyzed software
to such an extent, that we are able to calculate scores for each input representing
the number of newly triggered basic block transitions. The two approaches dif-
fer in the used side-channel information. Hence, each algorithm has advantages
depending on the attacked device and measurement quality. In the following we
give a recommendation on when to use either of the algorithms.

CFG-RI can lead to an accurate reconstruction of the examined code. The
drawback of this approach is the additional training phase we need to perform
prior to the branch distance classiﬁcation. This leads to a more time and mem-
ory consuming process before the actual fuzzing. In order to classify the branch

10

P. Sperl, K. B¨ottinger

Table 1: Result table TCF G showing the results for both control ﬂow reconstruc-
tion algorithms.

Branch ID Results CFG-RI
-
0
1
...
...

[Bof f set,start, Clength,start]
[Bof f set,0, Clength,0]
[Bof f set,1, Clength,1]
...
. . .

Results CFG-RII
Bprints,start
Bprints,0
Bprints,1
...
. . .

distances, the corresponding machine learning model has to be loaded in the
evaluation computer in addition to the model for the branch detection and the
analyzed power traces. Moreover, the measurement quality and target device
properties highly inﬂuence the accuracy during the estimation of the branch dis-
tances. Diﬀerent test devices and measurement equipment may lead to poor re-
sults preventing a correct estimation. Additionally, we emphasize the fault prop-
agation concerning this algorithm. If one branch distance is classiﬁed wrongly,
the remaining code reconstruction process results in a ﬂawed CFG.

In CFG-RII the results during the ﬁngerprint calculations do not depend on
the quality of the measurement setup and the attacked device as it is the case
during the branch distance classiﬁcation. Furthermore, a potential error does not
corrupt all following results. As drawback, regardless of the complexity of the
ﬁngerprints, the probability of collisions is not fully ruled out. A collision occurs
if for two or more diﬀerent basic blocks the same ﬁngerprint is generated. The
consequence of such an error would be in the worst case, that one yet unknown
basic block transition would not be detected as such. The resulting score of the
analyzed input would be smaller than the actual score.

We sum up the ﬁndings of the comparison as follows. With algorithm CFG-
RI we can precisely reconstruct the structure of the tested ﬁrmware. Because of
the error propagation property, we exclusively recommend using it if a strong
recognition rate during the branch distance classiﬁcation is reached. In contrast
to that, we present CFG-RII as an easy to implement and intuitive backup
strategy. We will present a quantitative comparison of both algorithms in Section
4.

3.3 Score Calculation

In the ﬁnal step of our approach we calculate the score which is the number
of newly triggered basic block transitions per input. The list Ω, that is empty
at the beginning of the fuzzing process, holds all known basic block transitions.
For the score calculation we use the result table we gained during the control
ﬂow reconstruction. We analyze the neighboring pairs of basic blocks and their
corresponding representation, realized either with the ﬁngerprints or the branch
distances. If the currently analyzed pair is already stored in Ω, we will not

Side-Channel Aware Fuzzing

11

increase the score. In contrast to that, if the pair is not in Ω, we add it to the
list and increase the score for the corresponding input by 1. With this procedure
we adopt the concept of estimating the code coverage in terms of basic block
transitions, similar to the AFL fuzzing tool.

3.4 Error Prevention and Trace Preprocessing

To prevent errors, we aim to increase the signal-to-noise-ratio (SNR) of the mea-
sured power consumption. Since the electronic noise follows a normal distribution
[15], a widely performed approach is to increase the number of measurements
showing the same operations and form superposed traces. We adopt this con-
cept and present three diﬀerent approaches to achieve this. For all approaches,
we send the same input to the device multiple times and capture the power
traces. Note that the traces need to be aligned correctly in order to allow valid
calculations. For this purpose we use a precise trigger, which depends on the
system clock of the DUT to start the measurement.

In the ﬁrst approach, for every sample point in the power traces, we calculate
the average to form a mean trace. Alternatively, we continuously average over
the measured samples and assign higher weights to later recorded traces. We
call this approach sweep. Using either of the superposed traces we carry out all
calculations as explained in Section 3 resulting in one score per input.

Alternatively, in the second approach we execute the feature extraction and
score calculation for every trace showing the same operations separately. After
a following majority vote we accept the most probable results.

In addition, a hybrid version poses a third alternative. Here we calculate

multiple scores for the same input using either mean or sweep traces.

3.5 Overall Side-Channel Driven Fuzzing Algorithm

Above we described all building blocks of our approach. In this section we link
them and present an overview. Assume we sent multiple inputs to the DUT while
we recorded the power consumption during the processing of each input.

In the ﬁrst step, we load a batch of power traces and calculate the pair-
wise mean-squared-error (MSE) among them. With this measure we perform a
ﬁrst reﬁnement prior to the actual SCA calculations to exclude multiple traces
showing the same sequence of instructions. If for a pair of traces, the MSE is
below a certain threshold, we can assume the same sequence of operations and
hence basic blocks were triggered. We exclude such traces and increase the over-
all fuzzing throughput. Note that we need to analyze the noise properties of the
tested DUT to deﬁne the MSE threshold.

For the remaining traces, we calculate the scores using our previously intro-
duced algorithms. To complete the fuzzing loop, we suggest using a state-of-the-
art fuzzing tool like AFL or SAGE [8]. The analyst can feed the calculated scores
to a tool, which prioritizes the inputs and further mutates promising examples.
Figure 3 shows the overall setup. The diﬀerent loops indicate operations which
we execute in parallel to further increase the throughput of the framework.

12

P. Sperl, K. B¨ottinger

Fig. 3: Overview of the building blocks of side-channel aware fuzzing.

4 Experiments and Evaluation

The lack of a base line to which diﬀerent fuzzing techniques can be compared to
is a known problem in software testing picked up by Dolan-Gavitt et. al [7]. The
authors present a system, which injects bugs into C code. This modiﬁed code
enables the comparison of various testing tools.

Regarding embedded device fuzzing, we face a similar but more fundamental
challenge. Prior to evaluating the actual fuzzing success, we need to assess the un-
derlying feedback itself. Therefore, we present a test environment, which allows
the calculation of theoretical scores. Furthermore, we introduce three evaluation
metrics to assess the quality of the calculated scores. This framework forms a
possible base line for future work on feedback extraction, aiming to enhance
embedded device fuzzing.

Additionally we show implementation details essential for our proof of con-
cept and information about the achieved results, gained during fuzzing of syn-
thetic software and a light-weight AES implementation. Finally we discuss the

MeasurementPairwise MSEFeature ExtractionCFG ReconstructionScore CalculationSTARTReturn ResultsMultiple Measurements RunsFeature Extraction for all available TracesControll Flow Reconstruction for all available SCA-ResultsScore Calculation for all available CFG-ResultsFeedback-Driven LoopSide-Channel Aware Fuzzing

13

(a) No preprocessing.

(b) Mean calculation with 10 traces.

(c) Continuous averaging with 10
traces.

(d) Mean calculation and
continuous averaging, both with 10
traces.

Fig. 4: Four power traces measured during the execution of the same instructions,
showing the impact of diﬀerent preprocessing techniques.

transferability of side-channel aware fuzzing to a broader range of embedded
devices.

4.1 Evaluation Code

During the proof of concept the analyzed target device executes a test software,
which allows the calculation of theoretical code coverage scores for the inputs.
The test software takes 16 bytes as input so that 16 binary decision stages are
passed throughout the processing. We test ﬁve versions of the software, which
diﬀer in the decision probability at the binary decision stages. Each version covers
48 basic blocks and 60 possible basic block transitions. The evaluation code
hence provides 300 diﬀerent basic block transitions, our implementation of side-
channel aware fuzzing needs to detect. The distances of the branches between the
basic blocks range from 10 to 150 skipped instructions. For the individual basic
blocks we chose a randomized implementation such that they diﬀer in length,
instruction types, used operands, and complexity. Since embedded devices often
operate in sensing-actuating loops, some basic blocks in real-world code may

14

P. Sperl, K. B¨ottinger

only contain a small and simple sequence of instructions. Therefore, to emulate
this case the shortest basic blocks contain 10 instructions, whereas we use 110
instructions to form the longest blocks. A further motivation to include short
basic blocks is to show the suﬃcient detail among the power traces which we are
able to exploit. If we are able to separate even small basic blocks, our concept
does not lack applicability regarding real software.

4.2 Benchmark Metrics

We consider three metrics as measures for the performance of our concept. To
allow the following evaluation we interpret multiple scores as arrays or result-
traces, respectively. This holds true for the calculated as well as for the the-
oretical scores. We evaluate the MSE and correlation coeﬃcient between the
result-traces. In addition we calculate the number of crucial errors. Such errors
occur if for a certain input which triggers the execution of at least one new basic
block transition, a score of 0 is returned. In this case the according input would
be discarded and not be considered for further mutations. This error type leads
to a major decrease in the fuzzing success.

4.3 Implementation Decisions - Classiﬁcation Approach

The main decision during the implementation is the choice of a machine learning-
based classiﬁer for the branch detection and branch distance classiﬁcation. To
perform a comparison of diﬀerent classiﬁcation algorithms we record 50 000
traces for the two classes (branch vs. no branch) and use them to train the ma-
chine learning models. We compare eight diﬀerent machine learning algorithms
to detect branches. To view the performance of each algorithm, we calculate
Matthew(cid:48)s correlation coeﬃcient (MCC) [16], which is well suited for the evalu-
ation of binary classiﬁcations of imbalanced data sets [21].

We achieve best results using a kNN classiﬁcation with k = 3 and an MCC
of 0.93. This result corresponds to the latest ﬁndings in related work, see Section
2. Therefore, we apply this approach during the proof of concept in which we
were able to reach an MCC of 0.78 for the branch detection.

4.4 Test Scenario and Power Traces

In this section we outline important facts about our proof of concept. We show
power traces to illustrate the actual application of the algorithms from Section 3.
We particularly focus on the branch detection and branch distance classiﬁcation.
During the evaluation phase, our test software (see Section 4.1) runs on an
STM32F417 [23] microcontroller. This reduced instruction set computer (RISC)
based controller uses the ARM Cortex-M4 [2] processor. We set the clock fre-
quency of the DUT to 84MHz. The DUT processes a batch of 100 random inputs
while we measure its power consumption using a shunt resistor of 47Ω. From
the Nyquist-Shannon sampling theorem [22] we know that the sampling rate

Side-Channel Aware Fuzzing

15

needs to be at least twice as high as the frequency of the measured signal to
prevent a loss of information. Hence, we set the sampling rate of our LeCroy
WavePro 760Zi-A oscilloscope to 5GS/s. After all steps of side-channel aware
fuzzing our implementation returns a result-trace containing 100 scores. Each
score corresponds to one input sent to the DUT. Figure 4 shows four power
traces we measured with a diﬀerential probe. The individual traces diﬀer in the
applied preprocessing technique and give the reader an intuition about the form
of the analyzed data.

Figure 5 shows a power trace during the branch detection. For a simple il-
lustration, we chose to implement one branch instruction in the code executed
by the DUT. In the ﬁrst step we slice the power trace into equally sized win-
dows, using a peak detection. Each peak, marked with a red cross is a potential
beginning of a branch instruction. The windows have the length of one branch
instruction, which we characterized in the training phase. After the binary classi-
ﬁcation on each window, only one peak is detected as the beginning of a branch,
marked with a black circle.

Fig. 5: Power trace during the branch detection, consisting of a peak detection
and binary classiﬁcations.

Figure 6 shows two power traces during the branch distance classiﬁcation.
The traces show the power consumption of the target device during the execution
of two branches with diﬀerent distances. We can clearly distinguish the power
traces and hence the distances of the branches. Note that both traces still show
a large similarity, such that we are able to detect both branches.

4.5 Results

We sum up the results of our proof of concept in Table 2. The result values show
the eﬀects of the diﬀerent preprocessing techniques, the two CFG reconstruc-
tion approaches, and impacts of a majority vote in the feature extraction. We
emphasize that preprocessing is a necessary step as we achieved better results
compared to an analysis using unprocessed traces. The various CFG reconstruc-
tion algorithms perform comparably, this allows a selection depending on the

16

P. Sperl, K. B¨ottinger

Fig. 6: Two power traces during the execution of two branches with diﬀerent
distances.

analyzed device and measurement quality. Regarding our test environment, no
majority vote in the feature extraction reaches superior results compared to a
majority vote-based approach.

With our results we can report that the power side-channel of embedded
devices carries information relevant for fuzzing. We are able to calculate result
traces, which strongly correlate with the actual result values. The maximum
correlation coeﬃcient is 0.95. Furthermore, our framework makes on average
0.69 crucial errors per 100 inputs.

Table 2: Results during the proof of concept. The target devices executes syn-
thetic code and handles 100 random inputs.

Preprocessing,
number of
used traces

CFG Reconstruction
majority (white) vs.
non-majority vote (gray)

Performance Metrics

mean

sweep CFG-RI

Mean Squared Error

Correlation Coeﬃcient

Number of Crucial Errors

1
10
1
10
1
10
1
10
1
10
1
10

1
1
10
10
1
1
10
10
1
1
10
10

CFG-RII
(summed)

CFG-RII
(separate)
6.16 3.21 6.73 4.13 5.96 5.23
4.11 2.81 4.63 3.80 7.38 5.20
4.66 3.33 6.05 4.65 4.49 3.37
4.77 3.54 4.75 4.33 5.58 4.08
0.85 0.93 0.91 0.94 0.86 0.91
0.91 0.93 0.94 0.95 0.84 0.92
0.90 0.92 0.94 0.94 0.91 0.94
0.89 0.92 0.95 0.95 0.90 0.93
0.5
0.5
0.4
1.2

0.9 0.4
0.5 0.6
0.8 0.5
1.3 1.1

0.7
1.2
0.6
1.2

0.4
0.3
0.6
0.5

0.6
0.8
0.7
0.3

Side-Channel Aware Fuzzing

17

4.6 Fuzzing an AES Implementation

In order to provide ﬁrst test results on real-world code we implemented AES
on our DUT for data encryption. The AES algorithm does not perform input-
dependent branches. Hence, we can easily compare our calculated scores to the
actual number of basic block transitions in our AES implementation. Further-
more, AES is commonly performed by embedded devices, resulting in realistic
power traces. For our tests we encrypted randomly chosen plaintexts using one
random key. During each encryption run, we let our implementation of side-
channel aware fuzzing estimate the number of basic block transitions, which
have been triggered at least once. Hence, we calculate the scores for each en-
cryption and plaintext. Our AES implementation triggers 41 unique basic block
transitions during its ten rounds of encryption. We identiﬁed this number dur-
ing a static code analysis of the compiled binary. Over 100 encryption runs, our
framework detects 38 transitions on average. This shows the applicability of our
concept, regarding code commonly found on embedded devices. In future work
we will extend our tests to a broader range of software including more complex
examples containing input-dependent branches.

4.7 Transferability and Generalization

We carried out the description of the concept in a generic way. The motivation to
do so is to give software engineers and testers the opportunity to adopt the con-
cept, but implement it in a way ﬁtting to their needs, attacked device, and mea-
surement environment. These factors inﬂuence the quality of the power traces
and hence the quality of the results. During the evaluation of diﬀerent aspects
of the concept and its implementation we payed attention to the transferability
of side-channel aware fuzzing. Even though we fuzzed solely one speciﬁc DUT, a
broader range of embedded devices can be analyzed with our concept. As can be
seen in Section 2, considerable success has been achieved in side-channel based
reverse engineering. In related work a signiﬁcant part of the instruction sequence
executed by diﬀerent RISC-based target devices was successfully reconstructed.
With this state-of-the art research and the fact, that our concept is based on a
successful branch detection we suﬀer no limitations regarding transferability to
other RISC-based target devices. In future work we will further investigate this
assumption.

Furthermore we plan to target the challenge of detecting faults in embedded
devices during fuzzing. Such faults often trigger a reboot of the device which
is a known sequence of actions resulting in characteristic power traces. In an
additional preprocessing step prior to the SCA calculations a machine learning
based classiﬁer could detect reboot sequences. This information could then be
sent to the fuzzing tool.

5 Conclusion

In this paper we combine the two yet unlinked but well studied research ﬁelds
of fuzzing and side-channel analysis to enable white-box fuzzing of software on

18

P. Sperl, K. B¨ottinger

embedded devices. With the results we gained from our proof of concept we show
that the power side-channel provides suﬃcient information for a feedback-driven
fuzzing loop.

Side-channel aware fuzzing is a threefold concept in which we ultimately
assign scores to fuzzing inputs. The scores are proportional to the code coverage
during the processing of the individual inputs. We use the number of basic block
transitions to assess the code coverage and calculate the scores. In the machine
learning based feature extraction approach we analyze the power consumption
of the targeted embedded device. With the extracted features we discover the
time when the device executes branch instructions which are the borders between
basic blocks. Furthermore, we reconstruct the jump distances of the branches. In
addition to that, we calculate ﬁngerprints of the trace segments showing the basic
blocks. We secondly conduct a control ﬂow reconstruction using the extracted
features. By evaluating either the branch distances or ﬁngerprints of the trace
parts between the branches, we are able to determine if we triggered a new basic
block transition. In the ﬁnal score calculation, we use the control ﬂow of the
software to calculate the score of the inputs sent to the target device.

We carried out the proof of concept on a state-of-the-art ARM Cortex-M4
microcontroller. The structure of our synthetic test code allows calculation of the
code coverage triggered by an input so that future work may employ it as a base
line. Using this test code and an implementation of our concept, we are able
to see a strong correlation between our calculated scores and the theoretical
scores. The maximal correlation coeﬃcient we achieved is 0.95. Additionally
we correctly estimated the number of basic block transitions in a light-weight
AES implementation using our framework. This states a signiﬁcant step towards
white-box fuzzing for vulnerability detection on embedded devices.

References

1. Alimi, V., Vernois, S., Rosenberger, C.: Analysis of Embedded Applications By
Evolutionary Fuzzing. In: 2014 International Conference on High Performance
Computing Simulation (HPCS). pp. 551–557 (July 2014)

2. Arm Holdings: Cortex-M4 Technical Reference Manual. http://infocenter.arm.

com/help/topic/com.arm.doc.ddi0439b/DDI0439B cortex m4 r0p0 trm.pdf

3. Cadar, C., Dunbar, D., Engler, D.: Klee: Unassisted and automatic generation
of high-coverage tests for complex systems programs. In: Proceedings of the 8th
USENIX Conference on Operating Systems Design and Implementation. pp. 209–
224. OSDI’08, USENIX Association, Berkeley, CA, USA (2008), http://dl.acm.
org/citation.cfm?id=1855741.1855756

4. Callan, R., Behrang, F., Zajic, A., Prvulovic, M., Orso, A.: Zero-overhead Pro-
ﬁling via EM Emanations. In: Proceedings of the 25th International Symposium
on Software Testing and Analysis. pp. 401–412. ISSTA 2016, ACM, New York,
NY, USA (2016). https://doi.org/10.1145/2931037.2931065, http://doi.acm.org/
10.1145/2931037.2931065

5. Corteggiani, N., Camurati, G., Francillon, A.: Inception: System-wide security test-
ing of real-world embedded systems software. In: 27th USENIX Security Sym-
posium (USENIX Security 18). pp. 309–326. USENIX Association, Baltimore,

Side-Channel Aware Fuzzing

19

MD (2018), https://www.usenix.org/conference/usenixsecurity18/presentation/
corteggiani

6. Davidson, D., Moench, B., Ristenpart, T., Jha, S.: FIE on ﬁrmware: Finding vulner-
abilities in embedded systems using symbolic execution. In: Presented as part of the
22nd USENIX Security Symposium (USENIX Security 13). pp. 463–478. USENIX,
Washington, D.C. (2013), https://www.usenix.org/conference/usenixsecurity13/
technical-sessions/paper/davidson

7. Dolan-Gavitt, B., Hulin, P., Kirda, E., Leek, T., Mambretti, A., Robertson, W.K.,
Ulrich, F., Whelan, R.: Lava: Large-scale automated vulnerability addition. In:
IEEE Symposium on Security and Privacy. pp. 110–121. IEEE Computer Society
(2016)

8. Godefroid, P., Levin, M.Y., Molnar, D.: Automated Whitebox Fuzz Testing. In:
Network and Distributed System Security (NDSS) Symposium. NDSS 08 (2008)
9. Han, Y., Etigowni, S., Liu, H., Zonouz, S., Petropulu, A.: Watch me, but don’t
touch me! contactless control ﬂow monitoring via electromagnetic emanations. In:
Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communi-
cations Security. pp. 1095–1108. ACM (2017)

10. Hennessy, J.L., Patterson, D.A.: Computer Architecture, Fifth Edition: A Quan-
titative Approach. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA,
5th edn. (2011)

11. Howard, M., Lipner, S.: The Security Development Lifecycle. Microsoft Press, Red-

mond, WA, USA (2006)

12. Kocher, P.C., Jaﬀe, J., Jun, B.: Diﬀerential Power Analysis. In: Proceedings of the
19th Annual International Cryptology Conference on Advances in Cryptology. pp.
388–397. CRYPTO ’99, Springer-Verlag, Berlin, Heidelberg (1999)

13. Koscher, K., Czeskis, A., Roesner, F., Patel, S., Kohno, T., Checkoway, S., McCoy,
D., Kantor, B., Anderson, D., Shacham, H., Savage, S.: Experimental Security
Analysis of a Modern Automobile. In: Proceedings of the 2010 IEEE Symposium
on Security and Privacy. pp. 447–462. SP ’10, IEEE Computer Society, Washington,
DC, USA (2010). https://doi.org/10.1109/SP.2010.34

14. Lee, H., Choi, K., Chung, K., Kim, J., Yim, K.: Fuzzing CAN Packets into Auto-
mobiles. In: 2015 IEEE 29th International Conference on Advanced Information
Networking and Applications. pp. 817–821 (March 2015)

15. Mangard, S., Oswald, E., Popp, T.: Power Analysis Attacks: Revealing the Se-
crets of Smart Cards (Advances in Information Security). Springer-Verlag, Berlin,
Heidelberg (2007)

16. Matthews, B.: Comparison of the predicted and observed secondary structure of
T4 phage lysozyme. Biochimica et Biophysica Acta (BBA) - Protein Structure
405(2), 442 – 451 (1975)

17. Msgna, M., Markantonakis, K., Mayes, K.: Precise instruction-level side channel
proﬁling of embedded processors. In: Huang, X., Zhou, J. (eds.) Information Se-
curity Practice and Experience. pp. 129–143. Springer International Publishing,
Cham (2014)

18. Muench, M., Stijohann, J., Kargl, F., Francillon, A., Balzarotti, D.: What You
Corrupt Is Not What You Crash: Challenges in Fuzzing Embedded Devices. In:
Network and Distributed System Security (NDSS) Symposium. NDSS 18 (February
2018)

19. National Institute of Standards and Technology: Advanced encryption standard.

NIST FIPS PUB 197 (2001)

20

P. Sperl, K. B¨ottinger

20. Papp, D., Ma, Z., Buttyan, L.: Embedded systems security: Threats, vulnerabili-
ties, and attack taxonomy. In: 2015 13th Annual Conference on Privacy, Security
and Trust (PST). pp. 145–152 (July 2015)

21. Powers, D.: Evaluation: From Precision, Recall and F-Factor to ROC, Informed-

ness, Markedness & Correlation (2011)

22. Shannon, C.E.: Communication in the presence of noise. Proceedings of the IRE

37(1), 10–21 (Jan 1949)

23. STMicroelectronics: STM32F417xx Datasheet. https://www.st.com/resource/en/

datasheet/dm00035129.pdf

24. Strobel, D., Bache, F., Oswald, D., Schellenberg, F., Paar, C.: SCANDALee: A side-
ChANnel-based DisAssembLer using local electromagnetic emanations. In: 2015
Design, Automation Test in Europe Conference Exhibition (DATE). pp. 139–144
(March 2015)

25. Van Aubel, P., Papagiannopoulos, K., Chmielewski, (cid:32)L., Doerr, C.: Side-channel
based intrusion detection for industrial control systems. In: D’Agostino, G., Scala,
A. (eds.) Critical Information Infrastructures Security. pp. 207–224. Springer In-
ternational Publishing, Cham (2018)

26. Zaddach, J., Bruno, L., Francillon, A., Balzarotti, D.: AVATAR: A frame-
work to support dynamic security analysis of embedded systems’ ﬁrmwares.
In: NDSS 2014, Network and Distributed System Security Symposium, 23-
26 February 2014, San Diego, USA. San Diego, UNITED STATES (02
2014). https://doi.org/http://dx/doi.org/10.14722/ndss.2014.23229, http://www.
eurecom.fr/publication/4158

27. Zalewski, M.: American Fuzzy Lop. http://lcamtuf.coredump.cx/aﬂ/

