0
2
0
2

b
e
F
8
1

]
I

A
.
s
c
[

3
v
1
8
4
2
0
.
0
1
9
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2020

LEARN TO EXPLAIN EFFICIENTLY VIA NEURAL LOGIC
INDUCTIVE LEARNING

Yuan Yang & Le Song
Georgia Institute of Technology
yyang754@gatech.edu, lsong@cc.gatech.edu

ABSTRACT

The capability of making interpretable and self-explanatory decisions is essential
for developing responsible machine learning systems. In this work, we study the
learning to explain problem in the scope of inductive logic programming (ILP).
We propose Neural Logic Inductive Learning (NLIL), an efﬁcient differentiable
ILP framework that learns ﬁrst-order logic rules that can explain the patterns in the
data. In experiments, compared with the state-of-the-art methods, we ﬁnd NLIL
can search for rules that are x10 times longer while remaining x3 times faster. We
also show that NLIL can scale to large image datasets, i.e. Visual Genome, with
1M entities.

1

INTRODUCTION

Figure 1: A scene-graph can describe the relations of objects in an image. The NLIL can utilize this
graph and explain the presence of objects Car and Person by learning the ﬁrst-order logic rules
that characterize the common sub-patterns in the graph. The explanation is globally consistent and
can be interpreted as commonsense knowledge.

The recent years have witnessed the growing success of deep learning models in a wide range of
applications. However, these models are also criticized for the lack of interpretability in its behav-
ior and decision making process (Lipton, 2016; Mittelstadt et al., 2019), and for being data-hungry.
The ability to explain its decision is essential for developing a responsible and robust decision sys-
tem (Guidotti et al., 2019). On the other hand, logic programming methods, in the form of ﬁrst-order
logic (FOL), are capable of discovering and representing knowledge in explicit symbolic structure
that can be understood and examined by human (Evans & Grefenstette, 2018).

In this paper, we investigate the learning to explain problem in the scope of inductive logic pro-
gramming (ILP) which seeks to learn ﬁrst-order logic rules that explain the data. Traditional ILP
methods (Gal´arraga et al., 2015) rely on hard matching and discrete logic for rule search which is
not tolerant for ambiguous and noisy data (Evans & Grefenstette, 2018). A number of works are
proposed for developing differentiable ILP models that combine the strength of neural and logic-
based computation (Evans & Grefenstette, 2018; Campero et al., 2018; Rockt¨aschel & Riedel, 2017;
Payani & Fekri, 2019; Dong et al., 2019). Methods such as ∂ILP (Evans & Grefenstette, 2018) are
referred to as forward-chaining methods. It constructs rules using a set of pre-deﬁned templates and

1

Car(              ) ←Of(              ,              ) ∧Window(              ) ∧Person(            ) ←Car(              ) ∧Inside(            ,              ) ∧Of(          ,              ) ∧Wheel(          )On(             ,           ) ∧Clothing(            ) “An object that has wheels and windows is a car”“An object that is inside the car with clothing is a person”CarWheelWindowClothingPersonWheelToyGroundCarWheelWindowClothingPersonWheelToyGroundOnOnOfOfOfInsideInside 
 
 
 
 
 
Published as a conference paper at ICLR 2020

evaluates them by applying the rule on background data multiple times to deduce new facts that lie
in the held-out set (related works available at Appendix A). However, general ILP problem involves
several steps that are NP-hard: (i) the rule search space grows exponentially in the length of the rule;
(ii) assigning the logic variables to be shared by predicates grows exponentially in the number of ar-
guments, which we refer as variable binding problem; (iii) the number of rule instantiations needed
for formula evaluation grows exponentially in the size of data. To alleviate these complexities, most
works have limited the search length to within 3 and resort to template-based variable assignments,
limiting the expressiveness of the learned rules (detailed discussion available at Appendix B). Still,
most of the works are limited in small scale problems with less than 10 relations and 1K entities.

On the other hand, multi-hop reasoning methods (Guu et al., 2015; Lao & Cohen, 2010; Lin et al.,
2015; Gardner & Mitchell, 2015; Das et al., 2016) are proposed for the knowledge base (KB) com-
pletion task. Methods such as NeuralLP (Yang et al., 2017) can answer the KB queries by searching
for a relational path that leads from the subject to the object. These methods can be interpreted in the
ILP domain where the learned relational path is equivalent to a chain-like ﬁrst-order rule. Compared
to the template-based counterparts, methods such as NeuralLP is highly efﬁcient in variable binding
and rule evaluation. However, they are limited in two aspects: (i) the chain-like rules represent a
subset of the Horn clauses, and are limited in expressing complex rules such as those shown in Fig-
ure 1; (ii) the relational path is generated while conditioning on the speciﬁc query, meaning that the
learned rule is only valid for the current query. This makes it difﬁcult to learn rules that are globally
consistent in the KB, which is an important aspect of a good explanation.

In this work, we propose Neural Logic Inductive Learning (NLIL), a differentiable ILP method
that extends the multi-hop reasoning framework for general ILP problem. NLIL is highly efﬁcient
and expressive. We propose a divide-and-conquer strategy and decompose the search space into
3 subspaces in a hierarchy, where each of them can be searched efﬁciently using attentions. This
enables us to search for x10 times longer rules while remaining x3 times faster than the state-of-the-
art methods. We maintain the global consistency of rules by splitting the training into rule generation
and rule evaluation phase, where the former is only conditioned on the predicate type that is shared
globally.

And more importantly, we show that a scalable ILP method is widely applicable for model expla-
nations in supervised learning scenario. We apply NLIL on Visual Genome (Krishna et al., 2016)
dataset for learning explanations for 150 object classes over 1M entities. We demonstrate that the
learned rules, while maintaining the interpretability, have comparable predictive power as densely
supervised models, and generalize well with less than 1% of the data.

2 PRELIMINARIES

Supervised learning typically involves learning classiﬁers that map an object from its input space
to a score between 0 and 1. How can one explain the outcome of a classiﬁer? Recent works on
interpretability focus on generating heatmaps or attention that self-explains a classiﬁer (Ribeiro
et al., 2016; Chen et al., 2018; Olah et al., 2018). We argue that a more effective and human-
intelligent explanation is through the description of the connection with other classiﬁers.

For example, consider an object detector with classiﬁers Person(X), Car(X), Clothing(X)
and Inside(X, X (cid:48)) that detects if certain region contains a person, a car, a clothing or is inside
another region, respectively. To explain why a person is present, one can leverage its connection
with other attributes, such as “X is a person if it’s inside a car and wearing clothing”, as shown
in Figure 1. This intuition draws a close connection to a longstanding problem of ﬁrst-order logic
literature, i.e. Inductive Logic Programming (ILP).

2.1

INDUCTIVE LOGIC PROGRAMMING

A typical ﬁrst-order logic system consists of 3 components: entity, predicate and formula. En-
tities are objects x ∈ X . For example, for a given image, a certain region is an entity x, and the
set of all possible regions is X . Predicates are functions that map entities to 0 or 1, for example
Person : x (cid:55)→ {0, 1}, x ∈ X . Classiﬁers can be seen as soft predicates. Predicates can take
multiple arguments, e.g. Inside is a predicate with 2 inputs. The number of arguments is re-
ferred to as the arity. Atom is a predicate symbol applied to a logic variable, e.g. Person(X) and
Inside(X, X (cid:48)). A logic variable such as X can be instantiated into any object in X .

2

Published as a conference paper at ICLR 2020

A ﬁrst-order logic (FOL) formula is a combination of atoms using logical operations {∧, ∨, ¬}
which correspond to logic and, or and not respectively. Given a set of predicates P =
{P1, ..., PK}, we deﬁne the explanation of a predicate Pk as a ﬁrst-order logic entailment

∀X, X (cid:48) ∃Y1, Y2... Pk(X, X (cid:48)) ← A(X, X (cid:48), Y1, Y2...),
(1)
where Pk(X, X (cid:48)) is the head of the entailment, and it will become Pk(X) if it is a unary predicate.
A is deﬁned as the rule body and is a general formula, e.g. conjunction normal form (CNF), that is
made of atoms with predicate symbols from P and logic variables that are either head variables X,
X (cid:48) or one of the body variables Y = {Y1, Y2, ...}.

By using the logic variables, the explanation becomes transferrable as it represents the “lifted”
knowledge that does not depend on the speciﬁc data. It can be easily interpreted. For example,

Person(X) ← Inside(X, Y1) ∧ Car(Y1) ∧ On(Y2, X) ∧ Clothing(Y2)

(2)

represents the knowledge that “if an object is inside the car with clothing on it, then it’s a person”.
To evaluate a formula on the actual data, one grounds the formula by instantiating all the variables
into objects. For example, in Figure 1, Eq.(2) is applied to the speciﬁc regions of an image.
Given a relational knowledge base (KB) that consists of a set of facts {(cid:104)xi, Pi, x(cid:48)
i=1 where Pi ∈ P
and xi, x(cid:48)
i ∈ X . The task of learning FOL rules in the form of Eq.(1) that entail target predicate
P ∗ ∈ P is called inductive logic programming. For simplicity, we consider unary and binary
predicates for the following contents, but this deﬁnition can be extended to predicates with higher
arity as well.

i(cid:105)}N

2.2 MUTLI-HOP REASONING

The ILP problem is closely related to the multi-hop reasoning task on the knowledge graph (Guu
et al., 2015; Lao & Cohen, 2010; Lin et al., 2015; Gardner & Mitchell, 2015; Das et al., 2016).
Similar to ILP, the task operates on a KB that consists of a set of predicates P. Here the facts are
stored with respect to the predicate Pk which is represented as a binary matrix Mk in {0, 1}|X |×|X |.
This is an adjacency matrix, meaning that (cid:104)xi, Pk, xj(cid:105) is in the KB if and only if the (i, j) entry of
Mk is 1.
Given a query q = (cid:104)x, P ∗, x(cid:48)(cid:105). The task is to ﬁnd a relational path x P (1)
−−−→ x(cid:48), such that
the two query entities are connected. Formally, let vx be the one-hot encoding of object x with
dimension of |X |. Then, the (t)th hop of the reasoning along the path is represented as

−−−→ ... P (T )

v(0) = vx,

v(t) = M(t)v(t−1),

where M(t) is the adjacency matrix of the predicate used in (t)th hop. The v(t) is the path features
vector, where the jth element v(t)
counts the number of unique paths from x to xj (Guu et al., 2015).
j
After T steps of reasoning, the score of the query is computed as

score(x, x(cid:48)) = v(cid:62)
x(cid:48)

T
(cid:89)

t=1

M(t) · vx.

(3)

For each q, the goal is to (i) ﬁnd an appropriate T and (ii) for each t ∈ [1, 2, ..., T ], ﬁnd the appro-
priate M(t) to multiply, such that Eq.(3) is maximized. These two discrete picks can be relaxed as
learning the weighted sum of scores from all possible paths, and weighted sum of matrices at each
step. Let

κ(sψ, Sϕ) ≡

T
(cid:88)

t(cid:48)=1



s(t(cid:48))

ψ



t(cid:48)
(cid:89)

K
(cid:88)

t=1

k=1



s(t)
ϕ,k Mk



(4)

be the soft path selection function parameterized by (i) the path attention vector sψ =
ψ , ..., s(T )
[s(1)
ψ ](cid:62) that softly picks the best path with length between 1 to T that answers the query, and
(ii) the operator attention vectors Sϕ = [s(1)
ϕ , ..., s(T )
ϕ softly picks the M(t) at (t)th
step. Here we omit the dependence on Mk for notation clarity. These two attentions are generated
with a model

ϕ ](cid:62), where s(t)

sψ, Sϕ = T(x; w)

(5)

3

Published as a conference paper at ICLR 2020

with learnable parameters w. For methods such as (Guu et al., 2015; Lao & Cohen, 2010), T(x; w)
is a random walk sampler which generates one-hot vectors that simulate the random walk on the
graph starting from x. And in NeuralLP (Yang et al., 2017), T(x; w) is an RNN controller that
generates a sequence of normalized attention vectors with vx as the initial input. Therefore, the
objective is deﬁned as

arg max
w

(cid:88)

q

v(cid:62)

x(cid:48)κ(sψ, Sϕ)vx,

(6)

Learning the relational path in the multi-hop reasoning can be interpreted as solving an ILP problem
with chain-like FOL rules (Yang et al., 2017)

P ∗(X, X (cid:48)) ← P (1)(X, Y1) ∧ P (2)(Y1, Y2) ∧ ... ∧ P (T )(Yn−1, X (cid:48)).

Compared to the template-based ILP methods such as ∂ILP, this class of methods is efﬁcient in rule
exploration and evaluation. However, (P1) generating explanations for supervised models puts a
high demand on the rule expressiveness. The chain-like rule space is limited in its expressive power
because it represents a constrained subspace of the Horn clauses rule space. For example, Eq.(2)
is a Horn clause and is not chain-like. And the ability to efﬁciently search beyond the chain-like
rule space is still lacking in these methods. On the other hand, (P2) the attention generator T(x; w)
is dependent on x, the subject of a speciﬁc query q, meaning that the explanation generated for
target P ∗ can vary from query to query. This makes it difﬁcult to learn FOL rules that are globally
consistent in the KB.

3 NEURAL LOGIC INDUCTIVE LEARNING

In this section, we show the connection between the multi-hop reasoning methods with the general
logic entailment deﬁned in Eq.(1). Then we propose a hierarchical rule space to solve (P1), i.e. we
extend the chain-like space for efﬁcient learning of more expressive rules.

3.1 THE OPERATOR VIEW

In Eq.(1), variables that only appear in the body are under existential quantiﬁer. We can turn Eq.(1)
into Skolem normal form by replacing all variables under existential quantiﬁer with functions with
respect to X and X (cid:48),

∀X, X (cid:48)∃ϕ1, ϕ2, ... P ∗(X, X (cid:48)) ← A(X, X (cid:48), ϕ1(X), ϕ1(X (cid:48)), ϕ2(X), ...).

(7)

If the functions are known, Eq.(7) will be much easier to evaluate than Eq.(1). Because grounding
this formula only requires to instantiate the head variables, and the rest of the body variables are
then determined by the deterministic functions.

Functions in Eq.(7) can be arbitrary. But what are the functions that one can utilize? We propose to
adopt the notions in section 2.2 and treat each predicate as an operator, such that we have a subspace
of the functions Φ = {ϕ1, ..., ϕK}, where

(cid:26)ϕk() = Mk 1

ϕk(vx) = Mkvx

if k ∈ U,
if k ∈ B,

where U and B are the sets of unary and binary predicates respectively. The operator of the unary
predicate takes no input and is parameterized with a diagonal matrix. Intuitively, given a subject
entity x, ϕk returns the set embedding (Guu et al., 2015) that represents the object entities that,
together with the subject, satisfy the predicate Pk. For example, let vx be the one-hot encoding of
an object in the image, then ϕInside(vx) returns the objects that spatially contain the input box. For
unary predicate such as Car(X), its operator ϕCar() = Mcar1 takes no input and returns the set of
all objects labelled as car.

Since we only use Φ, a subspace of the functions, the existential variables that can be represented
by the operator calls, denoted as ˆY, also form the subset ˆY ⊆ Y. This is slightly constrained
from Eq.(1). For example, in Person(X) ← Car(Y ), Y can not be interpreted as the operator call
from X. However, we argue that such rules are generally trivial. For example, it’s not likely to infer
“an image contains a person” by simply checking if “there is any car in the image”.

4

Published as a conference paper at ICLR 2020

Therefore, any FOL formula that complies with Eq.(7) can now be converted into the operator form
and vice versa. For example, Eq.(2) can be written as

Person(X) ← Car(ϕInside(X)) ∧ On(ϕClothing(), X),
(8)
where the variable Y1 and Y2 are eliminated. Note that this conversion is not unique. For example,
Car(ϕInside(X)) can be also written as Inside(X, ϕCar()). The variable binding problem now
becomes equivalent to the path-ﬁnding problem in section 2.2, where one searches for the appropri-
ate chain of operator calls that can represent the variable in ˆY.

3.2 PRIMITIVE STATEMENTS

As discussed above, the Eq.(3) is equivalent to a
chain-like rule. We want to extend this notion and
be able to represent more expressive rules. To do
this, we introduce the notion of primitive statement
ψ. Note that an atom is deﬁned as a predicate sym-
bol applied to speciﬁc logic variables. Similarly, we
deﬁne a predicate symbol applied to the head vari-
ables or those in ˆY as a primitive statement. For
example, in Eq.(8), ψ1 = Car(ϕInside(X)) and
ψ2 = On(ϕClothing(), X) are two primitive state-
ments.

i.e. ψ : R|X | × R|X |

Figure 2: Factor graphs of example chain-
tree-like and conjunctions of rules.
like,
Each rule type is the subset of the latter.
Succ stands for successor.
(cid:40)

Similar to an atom, each primitive statement is a
mapping from the input space to a scalar conﬁ-
(cid:55)→ s ∈
dence score,
[0, 1]. Formally, for a unary primitive statement
Pk(ϕ(T (cid:48)) · ... · ϕ(1)(x(cid:48))) and a binary one Pk(ϕ(T ) ·
... · ϕ(1)(x), ϕ(T (cid:48)) · ... · ϕ(1)(x(cid:48))), their mappings are
deﬁned as
t(cid:48)=1 M(t(cid:48))vx(cid:48)))
t=1 M(t)vx)(cid:62)((cid:81)T (cid:48)
where σ(·) is the sigmoid function. Note that we give unary ψ a dummy input x for notation
convenience. For example, in

σ((Mk 1)(cid:62)((cid:81)T (cid:48)
(cid:81)T
σ((Mk

t(cid:48)=1 M(t(cid:48))vx(cid:48)))

if k ∈ U,
if k ∈ B,

ψk(x, x(cid:48)) =

(9)

Ear(X) ← Eye(Y1) ∧ Of(Y1, Y2) ∧ Of(X, Y2),

the body is a single statement ψ = Of(ϕEye(), ϕOf(X)).
Its value is computed as
ψOf(ϕEye(), ϕOf(vx(cid:48))) = σ((MOfMEye1)(cid:62)(MOfvx(cid:48))). Compared to Eq.(3), Eq.(9) replaces the
target vx(cid:48) into another relational path. This makes it possible to represent “correlations” between
two variables, and the path that starts from the unary operator, e.g. ϕEye(). To see this, one can view
a FOL rule as a factor graph with logic variables as the nodes and predicates as the potentials (Cohen
et al., 2017). And running the operator call is essentially conducting the belief propagation over the
graph in a ﬁxed direction. As shown in Figure 2, primitive statement is capable of representing the
tree-like factor graphs, which signiﬁcantly improves the expressive power of the learned rules.

Similarly, Eq.(9) can be relaxed into weighted sums. In Eq.(6), all relational paths are summed
with a single path attention vector sψ. We extend this notion by assigning separate vectors for each
ψ ∈ RK×T be the path attention matrices for the ﬁrst and
argument of the statement ψ. Let Sψ, S(cid:48)
second argument of all statements in Ψ, i.e. sψ,k and s(cid:48)
ψ,k are the path attention vectors of the ﬁrst
and second argument of the kth statement. Then we have
(cid:16)

ψk(x, x(cid:48)) =




σ

σ



(cid:17)
(Mk 1)(cid:62)(κ(s(cid:48)
ψ,k, Sϕ) vx(cid:48))
(Mk κ(sψ,k, Sϕ) vx)(cid:62)(κ(s(cid:48)

(cid:16)

if k ∈ U,

(cid:17)

if k ∈ B.

ψ,k, Sϕ) vx(cid:48))

(10)

3.3 LOGIC COMBINATION SPACE

By introducing the primitive statements, we are now one step away from representing the running
example rule Eq.(8), which is the logic conjunction of two statements ψ1 and ψ2. Speciﬁcally,

5

Person(X) ←Car(Y1) ∧Inside(X, Y1) ∧On(Y2, X) ∧Clothing(Y2)XCarY1Y2InsideOnClothingEven(X) ←Even(Y1) ∧Succ (Y1, Y2) ∧Succ(Y2, X)XEvenY1SuccY2SuccEar(X) ←Eye(Y1) ∧Of(Y1, Y2) ∧Of(X, Y2)XEyeY1Y2OfOfXChain-likeTree-likeConjunctions𝝋𝝍𝒇Published as a conference paper at ICLR 2020

Figure 3: A hierarchical rule space where the operator calls, statement evaluations and logic com-
binations are all relaxed into the weight sums with respect to attentions Sϕ, Sψ, S(cid:48)
f and so.
W/sum denotes the weighted sum, Matmul denotes the matrix product, Neg denotes soft logic not,
and XEnt denotes the cross-entropy loss.

ψ, Sf , S(cid:48)

we want to further extend the rule search space by exploring the logic combinations of primitive
statements, via {∧, ∨, ¬}, as shown in Figure 2. To do this, we utilize the soft logic not and soft
logic and operations

¬p = 1 − p,

p ∧ q = p ∗ q,

where p, q ∈ [0, 1]. Here we do not include the logic ∨ operation because it can be implicitly
represented as p ∨ q = ¬(¬p ∧ ¬q). Let Ψ = {ψk(x, x(cid:48))}K
k=1 be the set of primitive statements with
all possible predicate symbols. We deﬁne the formula set at lth level as

F0 = Ψ,
ˆFl−1 = Fl−1 ∪ {1 − f (x, x(cid:48)) : f ∈ Fl−1},
i ∈ ˆFl−1}C
Fl = {fi(x, x(cid:48)) ∗ f (cid:48)

i (x, x(cid:48)) : fi, f (cid:48)

i=1,

(11)

where each element in the formula set {f : f ∈ Fl} is called a formula such that f : R|X | × R|X | (cid:55)→
s ∈ [0, 1].
Intuitively, we deﬁne the logic combination space in a similar way as that in path-
ﬁnding: the initial formula set contains only primitive statements Ψ, because they are formulas by
themselves. For the l − 1th formula set Fl−1, we concatenate it with its logic negation, which yields
ˆFl−1. Then each formula in the next level is the logic and of two formulas from ˆFl−1. Enumerating
all possible combinations at each level is expensive, so we set up a memory limitation C to indicate
the maximum number of combinations each level can keep track of1. In other words, each level Fl
is to search for C logic and combinations on formulas from the previous level ˆFl−1, such that the
cth formula at the lth level flc is

flc(x, x(cid:48)) = fl−1,i(x, x(cid:48)) ∗ f (cid:48)

l−1,i(x, x(cid:48)),
As an example, for Ψ = {ψ1, ψ2} and C = 2, one possible level sequence is F0 = {ψ1, ψ2},
F1 = {ψ1 ∗ ψ2, (1 − ψ2) ∗ ψ1}, F2 = {(ψ1 ∗ ψ2) ∗ ((1 − ψ2) ∗ ψ1), ...} and etc. To collect the
rules from all levels, the ﬁnal level L is the union of previous sets, i.e. FL = F0 ∪ ... ∪ FL−1.
Note that Eq.(11) does not explicitly forbid trivial rules such as ψ1 ∗ (1 − ψ1) that is always true
regardless of the input. This is alleviated by introducing nonexistent queries during the training
(detailed discussion at section 5).

fl−1,i, f (cid:48)

l−1,i ∈ ˆFl−1.

(12)

Again, the rule selection can be parameterized into the weighted-sum form with respect to the at-
f ∈ RL−1×C×2C, such that flc is the
tentions. We deﬁne the formula attention tensors as Sf , S(cid:48)
product of two summations over the previous outputs weighted by attention vectors sf,lc and s(cid:48)
respectively2. Formally, we have

f,lc

f,lcfl−1(x, x(cid:48)) ∗ s(cid:48)(cid:62)
where fl−1(x, x(cid:48)) ∈ R2C is the stacked outputs of all formulas f ∈ ˆFl−1 with arguments (cid:104)x, x(cid:48)(cid:105).
Finally, we want to select the best explanation and compute the score for each query. Let so be the

f,lcfl−1(x, x(cid:48)),

flc(x, x(cid:48)) = s(cid:62)

(13)

1C can vary from level to level, and we keep it the same for notation simplicity
2Formula set at (0)th level ˆF0 actually contains 2K formulas. Here we assume C = K for notation

simplicity.

6

XEnt𝑴𝟏𝑴𝟐𝑴𝑲IterateW/sum𝑴(𝟏)𝑴(𝟐)𝑴(𝑻)MatmulMatmul…MatmulIterateW/sum𝝍𝟏𝝍𝟐𝝍𝑲Eq.(10)෠ℱ𝟎NegConcatIterateW/sum*ℱ𝟏ℱ𝑳−𝟏W/sumℱ𝑳𝒗𝒙𝒗𝒙′𝒚Sample……Iterate…Iterate𝑺𝝋𝑺𝝍𝑺𝝍′𝑺𝒇𝑺𝒇′𝒔𝒐𝒔𝝋(𝒕)𝒔𝝍,𝒌𝒔𝝍,𝒌′𝒔𝒇,𝒍𝒄𝒔𝒇,𝒍𝒄′…𝒍=𝟏𝒍=𝑳−𝟏Published as a conference paper at ICLR 2020

Figure 4: The hierarchical Transformer networks for attention generation without conditioning on
the query.

attention vector over FL, so the output score is deﬁned as

An overview of the relaxed hierarchical rule space is illustrated in Figure 3.

score(x, x(cid:48)) = s(cid:62)

o fL(x, x(cid:48)).

(14)

4 HIERARCHICAL TRANSFORMER NETWORKS FOR RULE GENERATION

We have deﬁned a hierarchical rule space as shown in Figure 3, where the discrete selections on the
operators, statements and logic combinations are all relaxed into the weight sums with respect to
a series of attention parameters Sϕ, Sψ, S(cid:48)
f and so. In this section, we solve (P2), i.e. we
propose a differentiable model that generates these attentions without conditioning on the speciﬁc
query.

ψ, Sf , S(cid:48)

The goal of NLIL is to generate data-independent FOL rules. In other words, for each target pred-
icate P ∗, its rule set FL and the ﬁnal output rule should remain unchanged for all the queries
q = (cid:104)x, P ∗, x(cid:48)(cid:105) (which is different from that in Eq.(5)). To do this, we deﬁne the learnable em-
beddings of all predicates as H = [h1, .., hK](cid:62) ∈ RK×d, and the embeddings for the “dummy”
arguments X and X (cid:48) as eX , eX (cid:48) ∈ Rd. We deﬁne the attention generation model as
ψ, Sf , S(cid:48)
where h∗ is the embedding of P ∗, such that attentions only vary with respect to P ∗.

f , so = T(eX , h∗, eX (cid:48); w),

Sϕ, Sψ, S(cid:48)

(15)

As shown in Figure 4, we propose a stack of three Transformer (Vaswani et al., 2017) networks
for attention generator T. Each module is designed to mimic the actual evaluation that could hap-
pen during the operator call, primitive statement evaluation and formula computation respectively
with neural networks and “dummy” embeddings. And the attention matrices generated during this
simulated evaluation process are kept for evaluating Eq.(14). A MultiHeadAttn is a standard Trans-
former module such that MultiHeadAttn : Qq×d × Vv×d (cid:55)→ Oq×d × Sq×v, where d is the latent
dimension and q, v are the query and value dimensions respectively. It takes the query Q and input
value V (which will be internally transformed into keys and values), and returns the output value O
and attention matrix S. Intuitively, S encodes the “compatibility” between query and the value, and
O represents the “outcome” of a query given its compatibility with the input.
Operator search: For target predicate P ∗, we alter the embedding matrix H with

ˆhk = FeedForward(Concat(hk, h∗)),

ˆH = [ˆh1, ..., ˆhK](cid:62),

such that the rule generation is predicate-speciﬁc. Let q(t)
embedding. The operator transformer module is parameterized as

ϕ be the learnable tth step operator query

ˆV(0)
ˆV(t)

ϕ = [eX , eX (cid:48)](cid:62),
ϕ , ˆS(t)

ϕ = MultiHeadAttn( ˆQϕ, ˆV(t−1)

ϕ

ˆQϕ = ˆH + eϕ,
ϕ , s(t)
v(t)

ϕ = MultiHeadAttn(q(t)

ϕ , ˆV(t)

ϕ ).

),

Here, ˆV(0)
ϕ is the dummy input embedding representing the starting points of the paths. eϕ is a
learnable operator encoding such that ˆQϕ represents the embeddings of all operators Φ. Therefore,

7

TransformerConcat&feedforwardXL-1Transformer+XTTransformer+Concat&feedforwardexex'…eφ෡𝑸𝝋෩𝑽𝝍෡𝑽𝒇,𝒍−𝟏Transformer෡𝑽𝝋(𝒕)𝒒𝝋(𝒕)𝒔𝝋(𝒕)𝒗𝝋(𝒕)𝒆𝝍𝒆𝝍′X2IterateConcat𝒆+𝒆¬Iterate+X2𝑸𝝍𝑽𝝋𝑺𝝍…𝑸𝒇,𝒍𝑺𝒇,𝒍෩𝑽𝒇.𝒍෡𝑯෡𝑯𝒒𝝋(𝒕)෡𝑺𝝋(𝒕)෡𝑽𝝋(𝒕−𝟏)෡𝑽𝝋(𝒕)𝑸𝒇,𝒍ConcatTransformer𝒒𝒐𝑽𝒐𝒗𝒐𝒔𝒐𝒒𝒐𝑺𝝋𝑺𝝍𝑺𝝍′𝑺𝒇𝑺𝒇′𝒔𝒐ConcatPublished as a conference paper at ICLR 2020

Table 1: MRR, Hits@10 and time (mins) of KB comple-
tion tasks.

Table 2: Statistics of benchmark KBs
and Visual Genome scene-graphs.

Model

FB15K-237

WN18

KB

# facts

# entities

# predicates

MRR Hits@10 Time MRR Hits@10 Time

NeuralLP
TransE
RotatE

NLIL

0.24
0.28
0.34

0.25

36.2
44.5
52.6

32.4

250
35
342

82

0.94
0.57
0.94

0.95

94.5
93.3
95.5

94.6

54
53
254

12

ES-10
ES-50
ES-1K 1.5K

17
77

10
50
1K

WN18
106K
FB15K 272K
VG

40K
15K
1.9M 1.4M

3
3
3

18
237
2100

we consider that ˆV(t)
the outputs with another MultiHeadAttn with respect to a single query q(t)
the operator path attention vector s(t)

ϕ encodes the outputs of the operator calls of K predicates. And we aggregate
ϕ , which in turn yields

ϕ and aggregated output v(t)
ϕ .
ϕ , ..., v(T )

ϕ ](cid:62) be the output embedding of T paths. The

Primitive statement search: Let Vϕ = [v(1)
path attention is generated as

Qψ = ˆH + eψ, Q(cid:48)
˜V(cid:48)

ψ = ˆH + e(cid:48)
ψ,
ψ = MultiHeadAttn(Q(cid:48)
ψ, Vϕ),

ψ, S(cid:48)

˜Vψ, Sψ = MultiHeadAttn(Qψ, Vϕ),
Vψ = FeedForward(Concat( ˜Vψ, ˜V(cid:48)

ψ)).

Here, eψ and e(cid:48)
ψ are the ﬁrst and second argument encodings, such that Qψ and Q(cid:48)
ψ encode the
arguments of each statement in Ψ. The compatibility between paths and the arguments are computed
with two MultiHeadAttns. Finally, a FeedForward is used to aggregate the selections. Its output
Vψ ∈ RK×d represents the results of all statement evaluations in Ψ.
Formula search: Let Qf,l, Q(cid:48)
of formulas at lth level, and let Vf,0 = Vψ. The formula attention is generated as

f,l ∈ RC×d be the learnable queries of the ﬁrst and second argument

ˆVf,l−1 = [Vf,l−1 + e+, Vf,l−1 + e¬],
˜V(cid:48)
f,l = MultiHeadAttn(Q(cid:48)

f,l, ˆVf,l−1), Vf,l = FeedForward(Concat( ˜Vf,l, ˜V(cid:48)

˜Vf,l, Sf,l = MultiHeadAttn(Qf,l, ˆVf,l−1),
f,l)).

f,l, S(cid:48)

Here, e+, e¬ are the learnable embeddings, such that ˆVf,l−1 represents the positive and negative
states of the formulas at l − 1th level. Similar to the statement search, the compatibility between the
logic and arguments and the previous formulas are computed with two MultiHeadAttns. And the
embeddings of formulas at lth level Vf,l are aggregated by a FeedForward. Finally, let qo be the
learnable ﬁnal output query and let Vo = [Vf,0, ..., Vf,L−1]. The output attention is computed as

vo, so = MultiHeadAttn(qo, Vo).

5 STOCHASTIC TRAINING AND RULE VISUALIZATIONS

The training of NLIL consists of two phases: rule generation and rule evaluation. During gen-
f and so for all P ∗s. For the
eration, we run Eq.(15) to obtain the attentions Sϕ, Sψ, S(cid:48)
ψ, Sf , S(cid:48)
evaluation phase, we sample a mini-batch of queries {(cid:104)x, P ∗, x(cid:48), y(cid:105)i}b
i=1, and evaluate the formulas
using Eq.(14). Here, y is the query label indicating if the triplet exists in the KB or not. We sample
nonexistent queries to prevent the model from learning trivial rules that always output 1. In the
experiments, these negative queries are sampled uniformly from the target query matrix M ∗ where
the entry is 0. Then the objective becomes

arg min
w

1
b

b
(cid:88)

i

CrossEntropy(yi, s(cid:62)

o fL(x, x(cid:48))).

Since the attentions are generated from Eq.(15) differentiably, the loss is back-propagated through
the attentions into the Transformer networks for end-to-end training.

5.1 EXTRACTING EXPLICIT RULES

During training, the results from operator calls and logic combinations are averaged via attentions.
For validation and testing, we evaluate the model with the explicit FOL rules extracted from the

8

Published as a conference paper at ICLR 2020

Model

ES-10 ES-50 ES-1K

∂ILP
NeuralLP

5.6
0.1

240
0.1

NLIL

<0.1

<0.1

-
0.2

0.1

(a)

Figure 5: (a) Time (mins) for solving Even-and-Successor tasks.
(-) indicates method runs out
of time limit; (b) Running time for different rule lengths; (c) R@1 for object classiﬁcation with
different training set size.

(b)

(c)

attentions. To do this, one can view an attention vector as a categorical distribution. For example,
s(t)
ϕ is such a distribution over random variables k ∈ [1, K]. And the weighted sum is the expectation
over Mk. Therefore, one can extract the explicit rules by sampling from the distributions (Kool et al.,
2018; Yang et al., 2017).

However, since we are interested in the best rules and the attentions usually become highly concen-
trated on one entity after convergence. We replace the sampling with the arg max, where we get the
one-hot encoding of the entity with the largest probability mass.

6 EXPERIMENTS
We ﬁrst evaluate NLIL on classical ILP benchmarks and compare it with 4 state-of-the-art KB
completion methods in terms of their accuracy and efﬁciency. Then we show NLIL is capable of
learning FOL explanations for object classiﬁers on a large image dataset when scene-graphs are
present. Though each scene-graph corresponds to a small KB, the total amount of the graphs makes
it infeasible for all classical ILP methods. We show that NLIL can overcome it via efﬁcient stochastic
training. Our implementation is available at https://github.com/gblackout/NLIL.

6.1 CLASSICAL ILP BENCHMARKS

We evaluate NLIL together with two state-of-the-art differentiable ILP methods,
i.e. Neu-
ralLP (Yang et al., 2017) and ∂ILP (Evans & Grefenstette, 2018), and two structure embedding
methods, TransE (Bordes et al., 2013) and RotatE (Sun et al., 2019). Detailed experiments setup is
available at Appendix C.

Benchmark datasets: (i) Even-and-Successor (ES) benchmark is introduced in (Evans & Grefen-
stette, 2018), which involves two unary predicates Even(X), Zero(X) and one binary predicate
Succ(X, Y ). The goal is to learn FOL rules over a set of integers. The benchmark is evaluated
with 10, 50 and 1K consecutive integers starting at 0; (ii) FB15K-237 is a subset of the Freebase
knowledge base (Toutanova & Chen, 2015) containing general knowledge facts; (iii) WN18 (Bordes
et al., 2013) is the subset of WordNet containing relations between words. Statistics of datasets are
provided in Table 2.

Knowledge base completion: All models are evaluated on the KB completion task. The benchmark
datasets are split into train/valid/test sets. The model is tasked to predict the probability of a fact
triplet (query) being present in the KB. We use Mean Reciprocal Ranks (MRR) and Hits@10 for
evaluation metrics (see Appendix C for details).

Results on Even-and-Successor benchmark are shown in Table 5a. Since the benchmark is noise-
free, we only show the wall clock time for completely solving the task. As we have previously
mentioned, the forward-chaining method, i.e. ∂ILP scales exponentially in the number of facts and
quickly becomes infeasible for 1K entities. Thus, we skip its evaluation for other benchmarks.

Results on FB15K-237 and WN18 are shown in Table. 1. Compared to NeuralLP, NLIL yields
slightly higher scores. This is due to the benchmarks favor symmetric/asymmetric relations or com-
positions of a few relations (Sun et al., 2019), such that most valuable rules will already lie within
the chain-like search space of NeuralLP. Thus the improvements gained from a larger search space
with NLIL are limited. On the other hand, with the Transformer block and smaller model created

9

LengthTime Per Epochs / Mins010020030024681020NeuralLPNLILData Portion / %R@10.070.090.20.30.40.50.010.1110100MLP+RCNNFreqNLILPublished as a conference paper at ICLR 2020

for each target predicate, NLIL can achieve a similar score at least 3 times faster. Compared to the
structure embedding methods, NLIL is signiﬁcantly outperformed by the current state-of-the-art,
i.e. RotatE, on FB15K. This is expected because NLIL searches over the symbolic space that is
highly constrained. However, the learned rules are still reasonably predictive, as its performance is
comparable to that of TransE.

Scalability for long rules: we demonstrate that NLIL can explore longer rules efﬁciently. We
compare the wall clock time of NeuralLP and NLIL for performing one epoch of training against
different maximum rule lengths. As shown in Figure 5b, NeuralLP searches over a chain-like rule
space thus scales linearly with the length, while NLIL searches over a hierarchical space thus grows
in log scale. The search time for length 32 in NLIL is similar to that for length 3 in NerualLP.

6.2

ILP ON VISUAL GENOME DATASET

The ability to perform ILP efﬁciently extends the applications of NLIL to beyond canonical KB
completion. For example in visual object detection and relation learning, supervised models can
learn to generate a scene-graph (As shown in Figure 1) for each image. It consists of nodes each
labeled as an object class. And each pair of objects are connected with one type of relation. The
scene-graph can then be represented as a relational KB where one can perform ILP. Learning the
FOL rules on such an output of a supervised model is beneﬁcial. As it provides an alternative way of
interpreting model behaviors in terms of its relations with other classiﬁers that are consistent across
the dataset.

To show this, we conduct experiments on Visual Genome dataset (Krishna et al., 2016). The original
dataset is highly noisy (Zellers et al., 2018), so we use a pre-processed version available as the GQA
dataset (Hudson & Manning, 2019). The scene-graphs are converted to a collection KBs, and its
statistics are shown in Table 2. We ﬁlter out the predicates with less than 1500 occurrences. The
processed KBs contain 213 predicates. Then we perform ILP on learning the explanations for the
top 150 objects in the dataset.

Table 3: R@1 and R@5 for
150 objects classiﬁcation on
VG.

Model

Visual Genome

R@1

R@5

MLP+RCNN 0.53
0.40
Freq

NLIL

0.51

0.81
0.44

0.52

Quantitatively, we evaluate the learned rules on predicting the ob-
ject class labels on a held-out set in terms of their R@1 and R@5.
As none of the ILP works scale to this benchmark, we compare
NLIL with two supervised baselines: (i) MLP-RCNN: a MLP clas-
siﬁer with RCNN features of the object (available in GQA dataset)
as input; and (ii) Freq: a frequency-based baseline that predicts
object label by looking at the mostly occurred object class in the re-
lation that contains the target. This method is nontrivial. As noted
in (Zellers et al., 2018), a large number of triples in Visual Genome
are highly predictive by knowing only the relation type and either
one of the objects or subjects.

Explaining objects with rules: Results are shown in Table 3. We see that the supervised method
achieves the best scores, as it relies on highly informative visual features. On the other hand, NLIL
achieves a comparable score on R@1 solely relying on KBs with sparse binary labels. We note that
NLIL outperforms Freq signiﬁcantly. This means the FOL rules learned by NLIL are beyond the
superﬁcial correlations exhibited by the dataset. We verify this ﬁnding by showing the rules for top
objects in Table 4.

Induction for few-shot learning: Logic inductive learning is data-efﬁcient and the learned rules are
highly transferrable. To see this, we vary the size of the training set and compare the R@1 scores
for 3 methods. As shown in Figure 5c, the NLIL maintains a similar R@1 score with less than 1%
of the training set.

7 CONCLUSION

In this work, we propose Neural Logic Inductive Learning, a differentiable ILP framework that
learns explanatory rules from data. We demonstrate that NLIL can scale to very large datasets while
being able to search over complex and expressive rules. More importantly, we show that a scalable
ILP method is effective in explaining decisions of supervised models, which provides an alternative
perspective for inspecting the decision process of machine learning systems.

10

Published as a conference paper at ICLR 2020

ACKNOWLEDGMENTS

This project is partially supported by DARPA ASED program under FA8650-18-2-7882. We thank
Ramesh Arvind3 and Hoon Na4 for implementing the MLP baseline.

REFERENCES

Ivana Balaˇzevi´c, Carl Allen, and Timothy M Hospedales. Tucker: Tensor factorization for knowl-

edge graph completion. arXiv preprint arXiv:1901.09590, 2019.

Antoine Bordes, Nicolas Usunier, Alberto Garcia-Duran, Jason Weston, and Oksana Yakhnenko.
Translating embeddings for modeling multi-relational data. In Advances in neural information
processing systems, pp. 2787–2795, 2013.

Andres Campero, Aldo Pareja, Tim Klinger, Josh Tenenbaum, and Sebastian Riedel. Logical rule
induction and theory learning using neural theorem proving. arXiv preprint arXiv:1809.02193,
2018.

Xinlei Chen, Li-Jia Li, Li Fei-Fei, and Abhinav Gupta. Iterative visual reasoning beyond convolu-
tions. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp.
7239–7248, 2018.

William W Cohen, Fan Yang, and Kathryn Rivard Mazaitis. TensorLog: Deep learning meets

probabilistic DBs. July 2017.

Rajarshi Das, Arvind Neelakantan, David Belanger, and Andrew McCallum. Chains of rea-
arXiv preprint

soning over entities, relations, and text using recurrent neural networks.
arXiv:1607.01426, 2016.

Rajarshi Das, Shehzaad Dhuliawala, Manzil Zaheer, Luke Vilnis, Ishan Durugkar, Akshay Krishna-
murthy, Alex Smola, and Andrew McCallum. Go for a walk and arrive at the answer: Reasoning
over paths in knowledge bases using reinforcement learning. arXiv preprint arXiv:1711.05851,
2017.

Honghua Dong, Jiayuan Mao, Tian Lin, Chong Wang, Lihong Li, and Denny Zhou. Neural logic
machines. In International Conference on Learning Representations, 2019. URL https://
openreview.net/forum?id=B1xY-hRctX.

Richard Evans and Edward Grefenstette. Learning explanatory rules from noisy data. Journal of

Artiﬁcial Intelligence Research, 61:1–64, 2018.

Luis Gal´arraga, Christina Teﬂioudi, Katja Hose, and Fabian M Suchanek. Fast rule mining in onto-
logical knowledge bases with amie+. The VLDB JournalThe International Journal on Very Large
Data Bases, 24(6):707–730, 2015.

Matt Gardner and Tom Mitchell. Efﬁcient and expressive knowledge base completion using sub-
graph feature extraction. In Proceedings of the 2015 Conference on Empirical Methods in Natural
Language Processing, pp. 1488–1498, 2015.

Riccardo Guidotti, Anna Monreale, Salvatore Ruggieri, Franco Turini, Fosca Giannotti, and Dino
Pedreschi. A survey of methods for explaining black box models. ACM computing surveys
(CSUR), 51(5):93, 2019.

Kelvin Guu, John Miller, and Percy Liang. Traversing knowledge graphs in vector space. arXiv

preprint arXiv:1506.01094, 2015.

Vinh Thinh Ho, Daria Stepanova, Mohamed H Gad-Elrab, Evgeny Kharlamov, and Gerhard
Weikum. Rule learning from knowledge graphs guided by embedding models. In International
Semantic Web Conference, pp. 72–90. Springer, 2018.

3ramesharvind@gatech.edu
4hna30@gatech.edu

11

Published as a conference paper at ICLR 2020

Drew A Hudson and Christopher D Manning. Gqa: A new dataset for real-world visual reasoning
In Proceedings of the IEEE Conference on Computer

and compositional question answering.
Vision and Pattern Recognition, pp. 6700–6709, 2019.

Wouter Kool, Herke van Hoof, and Max Welling. Attention, learn to solve routing problems! arXiv

preprint arXiv:1803.08475, 2018.

Ranjay Krishna, Yuke Zhu, Oliver Groth, Justin Johnson, Kenji Hata, Joshua Kravitz, Stephanie
Chen, Yannis Kalantidis, Li-Jia Li, David A Shamma, Michael Bernstein, and Li Fei-Fei. Visual
genome: Connecting language and vision using crowdsourced dense image annotations. 2016.
URL https://arxiv.org/abs/1602.07332.

Ni Lao and William W Cohen. Relational retrieval using a combination of path-constrained random

walks. Machine learning, 81(1):53–67, 2010.

Nada Lavrac and Saso Dzeroski. Inductive logic programming. In WLP, pp. 146–160. Springer,

1994.

Yankai Lin, Zhiyuan Liu, Huanbo Luan, Maosong Sun, Siwei Rao, and Song Liu. Modeling relation
paths for representation learning of knowledge bases. arXiv preprint arXiv:1506.00379, 2015.

Zachary C Lipton. The mythos of model interpretability. arXiv preprint arXiv:1606.03490, 2016.

Pasquale Minervini, Matko Bosnjak, Tim Rockt¨aschel, and Sebastian Riedel. Towards neural theo-

rem proving at scale. arXiv preprint arXiv:1807.08204, 2018.

Brent Mittelstadt, Chris Russell, and Sandra Wachter. Explaining explanations in ai. In Proceedings

of the conference on fairness, accountability, and transparency, pp. 279–288. ACM, 2019.

Chris Olah, Arvind Satyanarayan, Ian Johnson, Shan Carter, Ludwig Schubert, Katherine Ye, and

Alexander Mordvintsev. The building blocks of interpretability. Distill, 3(3):e10, 2018.

Pouya Ghiasnezhad Omran, Kewen Wang, and Zhe Wang. Scalable rule learning via learning rep-

resentation. In IJCAI, pp. 2149–2155, 2018.

Ali Payani and Faramarz Fekri. Inductive logic programming via differentiable deep neural logic

networks. arXiv preprint arXiv:1906.03523, 2019.

Marco Tulio Ribeiro, Sameer Singh, and Carlos Guestrin. Why should i trust you?: Explaining the
predictions of any classiﬁer. In Proceedings of the 22nd ACM SIGKDD international conference
on knowledge discovery and data mining, pp. 1135–1144. ACM, 2016.

Tim Rockt¨aschel and Sebastian Riedel. End-to-end differentiable proving. In Advances in Neural

Information Processing Systems, pp. 3788–3800, 2017.

Richard Socher, Danqi Chen, Christopher D Manning, and Andrew Ng. Reasoning with neural
tensor networks for knowledge base completion. In Advances in neural information processing
systems, pp. 926–934, 2013.

Zhiqing Sun, Zhi-Hong Deng, Jian-Yun Nie, and Jian Tang. Rotate: Knowledge graph embedding

by relational rotation in complex space. arXiv preprint arXiv:1902.10197, 2019.

Kristina Toutanova and Danqi Chen. Observed versus latent features for knowledge base and text
inference. In Proceedings of the 3rd Workshop on Continuous Vector Space Models and their
Compositionality, pp. 57–66, 2015.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,
In Advances in Neural Infor-

Łukasz Kaiser, and Illia Polosukhin. Attention is all you need.
mation Processing Systems, pp. 5998–6008, 2017.

Fan Yang, Zhilin Yang, and William W Cohen. Differentiable learning of logical rules for knowledge
base reasoning. In Advances in Neural Information Processing Systems, pp. 2319–2328, 2017.

Rowan Zellers, Mark Yatskar, Sam Thomson, and Yejin Choi. Neural motifs: Scene graph parsing
In Proceedings of the IEEE Conference on Computer Vision and Pattern

with global context.
Recognition, pp. 5831–5840, 2018.

12

Published as a conference paper at ICLR 2020

A RELATED WORK

Inductive Logic Programming (ILP) is the task that seeks to summarize the underlying patterns
shared in the data and express it as a set of logic programs (or rule/formulae) (Lavrac & Dzeroski,
1994). Traditional ILP methods such as AMIE+ (Gal´arraga et al., 2015) and RLvLR (Omran et al.,
2018) relies on explicit search-based method for rule mining with various pruning techniques. These
works can scale up to very large knowledge bases. However, the algorithm complexity grows expo-
nentially in the size of the variables and predicates involved. The acquired rules are often restricted
to Horn clauses with a maximum length of less than 3, limiting the expressiveness of the rules.
On the other hand, compared to the differentiable approach, traditional methods make use of hard
matching and discrete logic for rule search, which lacks the tolerance for ambiguous and noisy data.

The state-of-the-art differentiable forward-chaining methods focus on rule learning on predeﬁned
templates (Evans & Grefenstette, 2018; Campero et al., 2018; Ho et al., 2018), typically in the form
of a Horn clause with one head predicate and two body predicates with chain-like variables, i.e.

P ∗(X, X (cid:48)) ← P1(X, Y ) ∧ P2(Y, X (cid:48)).

To evaluate the rules, one starts with a background set of facts and repeatedly apply rules for every
possible triple until no new facts can be deduced. Then the deduced facts are compared with a held-
out ground-truth set. Rules that are learned in this approach are in ﬁrst-order, i.e. data-independent
and can be readily interpreted. However, the deducing phase can quickly become infeasible with a
larger background set. Although ∂ILP (Evans & Grefenstette, 2018) has proposed to alleviate by
performing only a ﬁxed number of steps, works of this type could generally scale to KBs with less
than 1K facts and 100 entities. On the other hand, differentiable backward-chaining methods such
as NTP (Rockt¨aschel & Riedel, 2017) are more efﬁcient in rule evaluation. In (Minervini et al.,
2018), NTP 2.0 can scale to larges KBs such as WordNet. However, FOL rules are searched with
templates, so the expressiveness is still limited.

Another differentiable ILP method, i.e. Neural Logic Machine (NLM), is proposed in (Dong et al.,
2019), which learns to represent logic predicates with tensorized operations. NLM is capable of both
deductive and inductive learning on predicates with unknown arity. However, as a forward-chaining
method, it also suffers from the scalability issue as ∂ILP. It involves a permutation operation over
the tensors when performing logic deductions, making it difﬁcult to scale to real-world KBs. On the
other hand, the inductive rules learned by NLM are encoded by the network parameters implicitly,
so it does not support representing the rules with explicit predicate and logic variable symbols.

Multi-hop reasoning: Multi-hop reasoning methods (Guu et al., 2015; Lao & Cohen, 2010; Lin
et al., 2015; Gardner & Mitchell, 2015; Das et al., 2016; Yang et al., 2017) such as NeuralLP (Yang
et al., 2017) construct rule on-the-ﬂy when given a speciﬁc query. It adopts a ﬂexible ILP setting:
instead of pre-deﬁning templates, it assumes a chain-like Horn clause can be constructed to answer
the query

P ∗(X, X (cid:48)) ← P (1)(X, Y1) ∧ P (2)(Y1, Y2) ∧ ... ∧ P (T )(Yn−1, X (cid:48)).

And each step of the reasoning in the chain can be efﬁciently represented by matrix multiplication.
The resulting algorithm is highly scalable compared to the forward-chaining counter-parts and can
learn rules on large datasets such as FreeBase. However, this approach reasons over a single chain-
like path, and the path is sampled by performing random walks that are independent on the task
context (Das et al., 2017), limiting the rule expressiveness. On the other hand, the FOL rule is gen-
erated while conditioning on the speciﬁc query, making it difﬁcult to extract rules that are globally
consistent.

Link prediction with relational embeddings: Besides multi-hop reasoning methods, a number of
works are proposed for KB completion using learnable embeddings for KB relations. For example,
In (Bordes et al., 2013; Sun et al., 2019; Balaˇzevi´c et al., 2019) it learns to map KB relations into
vector space and predict links with scoring functions. NTN (Socher et al., 2013), on the other
hand, parameterizes each relation into a neural network. In this approach, embeddings are used
for predicting links directly, thus its prediction cannot be interpreted as explicit FOL rules. This is
different from that in NLIL, where predicate embeddings are used for generating data-independent
rules.

13

Published as a conference paper at ICLR 2020

Table 4: Example rules learned by NLIL

Person(X) ← (Shirt(Y1) ∧ Wearing(X, Y1)) ∨ (Pants(Y2) ∧ Wearing(X, Y2))∨

(Street(Y3) ∧ WalkingOn(X, Y3))

Tree(X) ← (Leaf(Y1) ∧ At(Y1, X)) ∨ (SideWalk(Y2) ∧ Near(Y2, X))
Shirt(X) ← (Person(Y1) ∧ Wearing(Y1, X)) ∨ (Child(Y2) ∧ Wearing(Y2, X))
Sky(X) ← (Clouds(Y1) ∧ in(Y1, X)) ∨ (Airplane(Y2) ∧ Below(X, Y2))
Head(X) ← Helmet(Y1) ∧ Above(Y1, X)
Head(X) ← Wearing(Y1, Y2) ∧ SittingOn(X, Y1) ∧ Hat(Y2)
Sign(X) ← (Number(Y1) ∧ On(Y1, X)) ∨ (Post(Y2) ∧ On(Y2, X))∨

(Letter(Y3) ∧ In(Y3, X))

Sign(X) ← StreetLight(Y1) ∧ On(Y1, Y2) ∧ On(X, Y2)
Ground(X) ← (Dog(Y1) ∧ On(Y1, X)) ∨ (Grass(Y2) ∧ CoveredBy(X, Y2))
Car(X) ← Wheel(Y1) ∧ Of(Y1, X) ∧ Window(Y2) ∧ Of(Y2, X)
Sidewalk(X) ← Person(Y1) ∧ WalkingOn(Y1, X) ∧ Street(Y2) ∧ Near(X, Y2)
Car(X) ← Wheel(Y1) ∧ Of(Y1, X) ∧ Window(Y2) ∧ Of(Y2, X)
Ear(X) ← Eye(Y1) ∧ Of(Y1, Y2) ∧ Of(X, Y2)
Chair(X) ← Arm(Y1) ∧ In(Y1, X) ∧ Person(Y2) ∧ SittingOn(Y2, X)

B CHALLENGES IN ILP

Standard ILP approaches are difﬁcult and involve several procedures that have been proved to be
NP-hard. The complexity comes from 3 levels: ﬁrst, the search space for a formula is vast. The
body of the entailment can be arbitrarily long and the same predicate can appear multiple times with
different variables, for example, the Inside predicate in Eq.(2) appears twice. Most ILP works
constrain the logic entailment to be Horn clause, i.e. the body of the entailment is a ﬂat conjunction
over literals, and the length limited within 3 for large datasets.

Second, constructing formulas also involves assigning logic variables that are shared across different
predicates, which we refer to as variable binding. For example, in Eq.(2), to express that a person is
inside the car, we use X and Y to represent the region of a person and that of a car, and the same two
variables are used in Inside to express their relations. Different bindings lead to different mean-
ings. For a formula with n arguments (Eq.(2) has 7), there are O(nn) possible assignments. Existing
ILP works either resort to constructing formula from pre-deﬁned templates (Evans & Grefenstette,
2018; Campero et al., 2018) or from chain-like variable reference (Yang et al., 2017), limiting the
expressiveness of the learned rules.

Finally, evaluating a formula candidate is expensive. A FOL rule is data-independent. To evaluate
it, one needs to replace the variables with actual entities and compute its value. This is referred
to as grounding or instantiation. Each variable used in a formula can be grounded independently,
meaning a formula with n variables can be instantiated into O(C n) grounded formulas, where C is
the number of total entities. For example, Eq.(2) contains 3 logic variables: X, Y and Z. To evaluate
this formula, one needs to instantiate these variables into C 3 possible combinations, and check if the
rule holds or not in each case. However in many domains, such as object detection, such grounding
space is vast (e.g. all possible bounding boxes of an image) making the full evaluation infeasible.
Many forward-chaining methods such as ∂ILP (Evans & Grefenstette, 2018) scales exponentially in
the size of the grounding space, thus are limited to small scale datasets with less than 10 predicates
and 1K entities.

C EXPERIMENTS

Baselines: For NeuralLP, we use the ofﬁcial implementation at here. For ∂ILP, we use the third-
party implementation at here. For TransE, we use the implementation at here. For RotatE, we use
the ofﬁcial implementation at here.

14

Published as a conference paper at ICLR 2020

Table 5: Example low-accuracy rules learned by NLIL.

Bush(X) ← ¬Tree(X)
Bus(X) ← ¬(Shirt(Y1) ∧ Wearing(Y1, X))
Backpack(X) ← Person(Y1) ∧ With(Y1, X)
Flowers(X) ← Pot(Y1) ∧ With(X, Y1)
Dirt(X) ← Ground(Y1) ∧ Near(Y1, X)

Model setting: For NLIL, we create separate Transformer blocks for each target predicate. All
experiments are conducted on a machine with i7-8700K, 32G RAM and one GTX1080ti. We use
the embedding size d = 32. We use 3 layers of multi-head attentions for each Transformer network.
The number of attention heads are set to number of heads = 4 for encoder, and the ﬁrst two layers
of the decoder. The last layer of the decoder has one attention head to produce the ﬁnal attention
required for rule evaluation.

For KB completion task, we set the number of operator calls T = 2 and formula combinations
L = 0, as most of the relations in those benchmarks can be recovered by symmetric/asymmetric
relations or compositions of a few relations (Sun et al., 2019). Thus complex formulas are not
preferred. For FB15K-237, binary predicates are grouped hierarchically into domains. To avoid
unnecessary search overhead, we use the most frequent 20 predicates that share the same root domain
(e.g. “award”, “location”) with the head predicate for rule body construction, which is a similar
treatment as in (Yang et al., 2017). For VG dataset, we set T = 3, L = 2 and C = 4.

Evaluation metrics: Following the conventions in (Yang et al., 2017; Bordes et al., 2013) we use
Mean Reciprocal Ranks (MRR) and Hits@10 for evaluation metrics. For each query (cid:104)x, Pk, x(cid:48)(cid:105),
the model generates a ranking list over all possible groundings of predicate Pk, with other ground-
truth triplets ﬁltered out. Then MRR is the average of the reciprocal rank of the queries in their
corresponding lists, and Hits@10 is the percentage of queries that are ranked within the top 10 in
the list.

15

