0
2
0
2

b
e
F
8
1

]
I

A
.
s
c
[

3
v
1
8
4
2
0
.
0
1
9
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2020

LEARN TO EXPLAIN EFFICIENTLY VIA NEURAL LOGIC
INDUCTIVE LEARNING

Yuan Yang & Le Song
Georgia Institute of Technology
yyang754@gatech.edu, lsong@cc.gatech.edu

ABSTRACT

The capability of making interpretable and self-explanatory decisions is essential
for developing responsible machine learning systems. In this work, we study the
learning to explain problem in the scope of inductive logic programming (ILP).
We propose Neural Logic Inductive Learning (NLIL), an efï¬cient differentiable
ILP framework that learns ï¬rst-order logic rules that can explain the patterns in the
data. In experiments, compared with the state-of-the-art methods, we ï¬nd NLIL
can search for rules that are x10 times longer while remaining x3 times faster. We
also show that NLIL can scale to large image datasets, i.e. Visual Genome, with
1M entities.

1

INTRODUCTION

Figure 1: A scene-graph can describe the relations of objects in an image. The NLIL can utilize this
graph and explain the presence of objects Car and Person by learning the ï¬rst-order logic rules
that characterize the common sub-patterns in the graph. The explanation is globally consistent and
can be interpreted as commonsense knowledge.

The recent years have witnessed the growing success of deep learning models in a wide range of
applications. However, these models are also criticized for the lack of interpretability in its behav-
ior and decision making process (Lipton, 2016; Mittelstadt et al., 2019), and for being data-hungry.
The ability to explain its decision is essential for developing a responsible and robust decision sys-
tem (Guidotti et al., 2019). On the other hand, logic programming methods, in the form of ï¬rst-order
logic (FOL), are capable of discovering and representing knowledge in explicit symbolic structure
that can be understood and examined by human (Evans & Grefenstette, 2018).

In this paper, we investigate the learning to explain problem in the scope of inductive logic pro-
gramming (ILP) which seeks to learn ï¬rst-order logic rules that explain the data. Traditional ILP
methods (GalÂ´arraga et al., 2015) rely on hard matching and discrete logic for rule search which is
not tolerant for ambiguous and noisy data (Evans & Grefenstette, 2018). A number of works are
proposed for developing differentiable ILP models that combine the strength of neural and logic-
based computation (Evans & Grefenstette, 2018; Campero et al., 2018; RocktÂ¨aschel & Riedel, 2017;
Payani & Fekri, 2019; Dong et al., 2019). Methods such as âˆ‚ILP (Evans & Grefenstette, 2018) are
referred to as forward-chaining methods. It constructs rules using a set of pre-deï¬ned templates and

1

Car(              ) â†Of(              ,              ) âˆ§Window(              ) âˆ§Person(            ) â†Car(              ) âˆ§Inside(            ,              ) âˆ§Of(          ,              ) âˆ§Wheel(          )On(             ,           ) âˆ§Clothing(            ) â€œAn object that has wheels and windows is a carâ€â€œAn object that is inside the car with clothing is a personâ€CarWheelWindowClothingPersonWheelToyGroundCarWheelWindowClothingPersonWheelToyGroundOnOnOfOfOfInsideInside 
 
 
 
 
 
Published as a conference paper at ICLR 2020

evaluates them by applying the rule on background data multiple times to deduce new facts that lie
in the held-out set (related works available at Appendix A). However, general ILP problem involves
several steps that are NP-hard: (i) the rule search space grows exponentially in the length of the rule;
(ii) assigning the logic variables to be shared by predicates grows exponentially in the number of ar-
guments, which we refer as variable binding problem; (iii) the number of rule instantiations needed
for formula evaluation grows exponentially in the size of data. To alleviate these complexities, most
works have limited the search length to within 3 and resort to template-based variable assignments,
limiting the expressiveness of the learned rules (detailed discussion available at Appendix B). Still,
most of the works are limited in small scale problems with less than 10 relations and 1K entities.

On the other hand, multi-hop reasoning methods (Guu et al., 2015; Lao & Cohen, 2010; Lin et al.,
2015; Gardner & Mitchell, 2015; Das et al., 2016) are proposed for the knowledge base (KB) com-
pletion task. Methods such as NeuralLP (Yang et al., 2017) can answer the KB queries by searching
for a relational path that leads from the subject to the object. These methods can be interpreted in the
ILP domain where the learned relational path is equivalent to a chain-like ï¬rst-order rule. Compared
to the template-based counterparts, methods such as NeuralLP is highly efï¬cient in variable binding
and rule evaluation. However, they are limited in two aspects: (i) the chain-like rules represent a
subset of the Horn clauses, and are limited in expressing complex rules such as those shown in Fig-
ure 1; (ii) the relational path is generated while conditioning on the speciï¬c query, meaning that the
learned rule is only valid for the current query. This makes it difï¬cult to learn rules that are globally
consistent in the KB, which is an important aspect of a good explanation.

In this work, we propose Neural Logic Inductive Learning (NLIL), a differentiable ILP method
that extends the multi-hop reasoning framework for general ILP problem. NLIL is highly efï¬cient
and expressive. We propose a divide-and-conquer strategy and decompose the search space into
3 subspaces in a hierarchy, where each of them can be searched efï¬ciently using attentions. This
enables us to search for x10 times longer rules while remaining x3 times faster than the state-of-the-
art methods. We maintain the global consistency of rules by splitting the training into rule generation
and rule evaluation phase, where the former is only conditioned on the predicate type that is shared
globally.

And more importantly, we show that a scalable ILP method is widely applicable for model expla-
nations in supervised learning scenario. We apply NLIL on Visual Genome (Krishna et al., 2016)
dataset for learning explanations for 150 object classes over 1M entities. We demonstrate that the
learned rules, while maintaining the interpretability, have comparable predictive power as densely
supervised models, and generalize well with less than 1% of the data.

2 PRELIMINARIES

Supervised learning typically involves learning classiï¬ers that map an object from its input space
to a score between 0 and 1. How can one explain the outcome of a classiï¬er? Recent works on
interpretability focus on generating heatmaps or attention that self-explains a classiï¬er (Ribeiro
et al., 2016; Chen et al., 2018; Olah et al., 2018). We argue that a more effective and human-
intelligent explanation is through the description of the connection with other classiï¬ers.

For example, consider an object detector with classiï¬ers Person(X), Car(X), Clothing(X)
and Inside(X, X (cid:48)) that detects if certain region contains a person, a car, a clothing or is inside
another region, respectively. To explain why a person is present, one can leverage its connection
with other attributes, such as â€œX is a person if itâ€™s inside a car and wearing clothingâ€, as shown
in Figure 1. This intuition draws a close connection to a longstanding problem of ï¬rst-order logic
literature, i.e. Inductive Logic Programming (ILP).

2.1

INDUCTIVE LOGIC PROGRAMMING

A typical ï¬rst-order logic system consists of 3 components: entity, predicate and formula. En-
tities are objects x âˆˆ X . For example, for a given image, a certain region is an entity x, and the
set of all possible regions is X . Predicates are functions that map entities to 0 or 1, for example
Person : x (cid:55)â†’ {0, 1}, x âˆˆ X . Classiï¬ers can be seen as soft predicates. Predicates can take
multiple arguments, e.g. Inside is a predicate with 2 inputs. The number of arguments is re-
ferred to as the arity. Atom is a predicate symbol applied to a logic variable, e.g. Person(X) and
Inside(X, X (cid:48)). A logic variable such as X can be instantiated into any object in X .

2

Published as a conference paper at ICLR 2020

A ï¬rst-order logic (FOL) formula is a combination of atoms using logical operations {âˆ§, âˆ¨, Â¬}
which correspond to logic and, or and not respectively. Given a set of predicates P =
{P1, ..., PK}, we deï¬ne the explanation of a predicate Pk as a ï¬rst-order logic entailment

âˆ€X, X (cid:48) âˆƒY1, Y2... Pk(X, X (cid:48)) â† A(X, X (cid:48), Y1, Y2...),
(1)
where Pk(X, X (cid:48)) is the head of the entailment, and it will become Pk(X) if it is a unary predicate.
A is deï¬ned as the rule body and is a general formula, e.g. conjunction normal form (CNF), that is
made of atoms with predicate symbols from P and logic variables that are either head variables X,
X (cid:48) or one of the body variables Y = {Y1, Y2, ...}.

By using the logic variables, the explanation becomes transferrable as it represents the â€œliftedâ€
knowledge that does not depend on the speciï¬c data. It can be easily interpreted. For example,

Person(X) â† Inside(X, Y1) âˆ§ Car(Y1) âˆ§ On(Y2, X) âˆ§ Clothing(Y2)

(2)

represents the knowledge that â€œif an object is inside the car with clothing on it, then itâ€™s a personâ€.
To evaluate a formula on the actual data, one grounds the formula by instantiating all the variables
into objects. For example, in Figure 1, Eq.(2) is applied to the speciï¬c regions of an image.
Given a relational knowledge base (KB) that consists of a set of facts {(cid:104)xi, Pi, x(cid:48)
i=1 where Pi âˆˆ P
and xi, x(cid:48)
i âˆˆ X . The task of learning FOL rules in the form of Eq.(1) that entail target predicate
P âˆ— âˆˆ P is called inductive logic programming. For simplicity, we consider unary and binary
predicates for the following contents, but this deï¬nition can be extended to predicates with higher
arity as well.

i(cid:105)}N

2.2 MUTLI-HOP REASONING

The ILP problem is closely related to the multi-hop reasoning task on the knowledge graph (Guu
et al., 2015; Lao & Cohen, 2010; Lin et al., 2015; Gardner & Mitchell, 2015; Das et al., 2016).
Similar to ILP, the task operates on a KB that consists of a set of predicates P. Here the facts are
stored with respect to the predicate Pk which is represented as a binary matrix Mk in {0, 1}|X |Ã—|X |.
This is an adjacency matrix, meaning that (cid:104)xi, Pk, xj(cid:105) is in the KB if and only if the (i, j) entry of
Mk is 1.
Given a query q = (cid:104)x, P âˆ—, x(cid:48)(cid:105). The task is to ï¬nd a relational path x P (1)
âˆ’âˆ’âˆ’â†’ x(cid:48), such that
the two query entities are connected. Formally, let vx be the one-hot encoding of object x with
dimension of |X |. Then, the (t)th hop of the reasoning along the path is represented as

âˆ’âˆ’âˆ’â†’ ... P (T )

v(0) = vx,

v(t) = M(t)v(tâˆ’1),

where M(t) is the adjacency matrix of the predicate used in (t)th hop. The v(t) is the path features
vector, where the jth element v(t)
counts the number of unique paths from x to xj (Guu et al., 2015).
j
After T steps of reasoning, the score of the query is computed as

score(x, x(cid:48)) = v(cid:62)
x(cid:48)

T
(cid:89)

t=1

M(t) Â· vx.

(3)

For each q, the goal is to (i) ï¬nd an appropriate T and (ii) for each t âˆˆ [1, 2, ..., T ], ï¬nd the appro-
priate M(t) to multiply, such that Eq.(3) is maximized. These two discrete picks can be relaxed as
learning the weighted sum of scores from all possible paths, and weighted sum of matrices at each
step. Let

Îº(sÏˆ, SÏ•) â‰¡

T
(cid:88)

t(cid:48)=1

ï£«

s(t(cid:48))

Ïˆ

ï£­

t(cid:48)
(cid:89)

K
(cid:88)

t=1

k=1

ï£¶

s(t)
Ï•,k Mk

ï£¸

(4)

be the soft path selection function parameterized by (i) the path attention vector sÏˆ =
Ïˆ , ..., s(T )
[s(1)
Ïˆ ](cid:62) that softly picks the best path with length between 1 to T that answers the query, and
(ii) the operator attention vectors SÏ• = [s(1)
Ï• , ..., s(T )
Ï• softly picks the M(t) at (t)th
step. Here we omit the dependence on Mk for notation clarity. These two attentions are generated
with a model

Ï• ](cid:62), where s(t)

sÏˆ, SÏ• = T(x; w)

(5)

3

Published as a conference paper at ICLR 2020

with learnable parameters w. For methods such as (Guu et al., 2015; Lao & Cohen, 2010), T(x; w)
is a random walk sampler which generates one-hot vectors that simulate the random walk on the
graph starting from x. And in NeuralLP (Yang et al., 2017), T(x; w) is an RNN controller that
generates a sequence of normalized attention vectors with vx as the initial input. Therefore, the
objective is deï¬ned as

arg max
w

(cid:88)

q

v(cid:62)

x(cid:48)Îº(sÏˆ, SÏ•)vx,

(6)

Learning the relational path in the multi-hop reasoning can be interpreted as solving an ILP problem
with chain-like FOL rules (Yang et al., 2017)

P âˆ—(X, X (cid:48)) â† P (1)(X, Y1) âˆ§ P (2)(Y1, Y2) âˆ§ ... âˆ§ P (T )(Ynâˆ’1, X (cid:48)).

Compared to the template-based ILP methods such as âˆ‚ILP, this class of methods is efï¬cient in rule
exploration and evaluation. However, (P1) generating explanations for supervised models puts a
high demand on the rule expressiveness. The chain-like rule space is limited in its expressive power
because it represents a constrained subspace of the Horn clauses rule space. For example, Eq.(2)
is a Horn clause and is not chain-like. And the ability to efï¬ciently search beyond the chain-like
rule space is still lacking in these methods. On the other hand, (P2) the attention generator T(x; w)
is dependent on x, the subject of a speciï¬c query q, meaning that the explanation generated for
target P âˆ— can vary from query to query. This makes it difï¬cult to learn FOL rules that are globally
consistent in the KB.

3 NEURAL LOGIC INDUCTIVE LEARNING

In this section, we show the connection between the multi-hop reasoning methods with the general
logic entailment deï¬ned in Eq.(1). Then we propose a hierarchical rule space to solve (P1), i.e. we
extend the chain-like space for efï¬cient learning of more expressive rules.

3.1 THE OPERATOR VIEW

In Eq.(1), variables that only appear in the body are under existential quantiï¬er. We can turn Eq.(1)
into Skolem normal form by replacing all variables under existential quantiï¬er with functions with
respect to X and X (cid:48),

âˆ€X, X (cid:48)âˆƒÏ•1, Ï•2, ... P âˆ—(X, X (cid:48)) â† A(X, X (cid:48), Ï•1(X), Ï•1(X (cid:48)), Ï•2(X), ...).

(7)

If the functions are known, Eq.(7) will be much easier to evaluate than Eq.(1). Because grounding
this formula only requires to instantiate the head variables, and the rest of the body variables are
then determined by the deterministic functions.

Functions in Eq.(7) can be arbitrary. But what are the functions that one can utilize? We propose to
adopt the notions in section 2.2 and treat each predicate as an operator, such that we have a subspace
of the functions Î¦ = {Ï•1, ..., Ï•K}, where

(cid:26)Ï•k() = Mk 1

Ï•k(vx) = Mkvx

if k âˆˆ U,
if k âˆˆ B,

where U and B are the sets of unary and binary predicates respectively. The operator of the unary
predicate takes no input and is parameterized with a diagonal matrix. Intuitively, given a subject
entity x, Ï•k returns the set embedding (Guu et al., 2015) that represents the object entities that,
together with the subject, satisfy the predicate Pk. For example, let vx be the one-hot encoding of
an object in the image, then Ï•Inside(vx) returns the objects that spatially contain the input box. For
unary predicate such as Car(X), its operator Ï•Car() = Mcar1 takes no input and returns the set of
all objects labelled as car.

Since we only use Î¦, a subspace of the functions, the existential variables that can be represented
by the operator calls, denoted as Ë†Y, also form the subset Ë†Y âŠ† Y. This is slightly constrained
from Eq.(1). For example, in Person(X) â† Car(Y ), Y can not be interpreted as the operator call
from X. However, we argue that such rules are generally trivial. For example, itâ€™s not likely to infer
â€œan image contains a personâ€ by simply checking if â€œthere is any car in the imageâ€.

4

Published as a conference paper at ICLR 2020

Therefore, any FOL formula that complies with Eq.(7) can now be converted into the operator form
and vice versa. For example, Eq.(2) can be written as

Person(X) â† Car(Ï•Inside(X)) âˆ§ On(Ï•Clothing(), X),
(8)
where the variable Y1 and Y2 are eliminated. Note that this conversion is not unique. For example,
Car(Ï•Inside(X)) can be also written as Inside(X, Ï•Car()). The variable binding problem now
becomes equivalent to the path-ï¬nding problem in section 2.2, where one searches for the appropri-
ate chain of operator calls that can represent the variable in Ë†Y.

3.2 PRIMITIVE STATEMENTS

As discussed above, the Eq.(3) is equivalent to a
chain-like rule. We want to extend this notion and
be able to represent more expressive rules. To do
this, we introduce the notion of primitive statement
Ïˆ. Note that an atom is deï¬ned as a predicate sym-
bol applied to speciï¬c logic variables. Similarly, we
deï¬ne a predicate symbol applied to the head vari-
ables or those in Ë†Y as a primitive statement. For
example, in Eq.(8), Ïˆ1 = Car(Ï•Inside(X)) and
Ïˆ2 = On(Ï•Clothing(), X) are two primitive state-
ments.

i.e. Ïˆ : R|X | Ã— R|X |

Figure 2: Factor graphs of example chain-
tree-like and conjunctions of rules.
like,
Each rule type is the subset of the latter.
Succ stands for successor.
(cid:40)

Similar to an atom, each primitive statement is a
mapping from the input space to a scalar conï¬-
(cid:55)â†’ s âˆˆ
dence score,
[0, 1]. Formally, for a unary primitive statement
Pk(Ï•(T (cid:48)) Â· ... Â· Ï•(1)(x(cid:48))) and a binary one Pk(Ï•(T ) Â·
... Â· Ï•(1)(x), Ï•(T (cid:48)) Â· ... Â· Ï•(1)(x(cid:48))), their mappings are
deï¬ned as
t(cid:48)=1 M(t(cid:48))vx(cid:48)))
t=1 M(t)vx)(cid:62)((cid:81)T (cid:48)
where Ïƒ(Â·) is the sigmoid function. Note that we give unary Ïˆ a dummy input x for notation
convenience. For example, in

Ïƒ((Mk 1)(cid:62)((cid:81)T (cid:48)
(cid:81)T
Ïƒ((Mk

t(cid:48)=1 M(t(cid:48))vx(cid:48)))

if k âˆˆ U,
if k âˆˆ B,

Ïˆk(x, x(cid:48)) =

(9)

Ear(X) â† Eye(Y1) âˆ§ Of(Y1, Y2) âˆ§ Of(X, Y2),

the body is a single statement Ïˆ = Of(Ï•Eye(), Ï•Of(X)).
Its value is computed as
ÏˆOf(Ï•Eye(), Ï•Of(vx(cid:48))) = Ïƒ((MOfMEye1)(cid:62)(MOfvx(cid:48))). Compared to Eq.(3), Eq.(9) replaces the
target vx(cid:48) into another relational path. This makes it possible to represent â€œcorrelationsâ€ between
two variables, and the path that starts from the unary operator, e.g. Ï•Eye(). To see this, one can view
a FOL rule as a factor graph with logic variables as the nodes and predicates as the potentials (Cohen
et al., 2017). And running the operator call is essentially conducting the belief propagation over the
graph in a ï¬xed direction. As shown in Figure 2, primitive statement is capable of representing the
tree-like factor graphs, which signiï¬cantly improves the expressive power of the learned rules.

Similarly, Eq.(9) can be relaxed into weighted sums. In Eq.(6), all relational paths are summed
with a single path attention vector sÏˆ. We extend this notion by assigning separate vectors for each
Ïˆ âˆˆ RKÃ—T be the path attention matrices for the ï¬rst and
argument of the statement Ïˆ. Let SÏˆ, S(cid:48)
second argument of all statements in Î¨, i.e. sÏˆ,k and s(cid:48)
Ïˆ,k are the path attention vectors of the ï¬rst
and second argument of the kth statement. Then we have
(cid:16)

Ïˆk(x, x(cid:48)) =

ï£±
ï£²

Ïƒ

Ïƒ

ï£³

(cid:17)
(Mk 1)(cid:62)(Îº(s(cid:48)
Ïˆ,k, SÏ•) vx(cid:48))
(Mk Îº(sÏˆ,k, SÏ•) vx)(cid:62)(Îº(s(cid:48)

(cid:16)

if k âˆˆ U,

(cid:17)

if k âˆˆ B.

Ïˆ,k, SÏ•) vx(cid:48))

(10)

3.3 LOGIC COMBINATION SPACE

By introducing the primitive statements, we are now one step away from representing the running
example rule Eq.(8), which is the logic conjunction of two statements Ïˆ1 and Ïˆ2. Speciï¬cally,

5

Person(X) â†Car(Y1) âˆ§Inside(X, Y1) âˆ§On(Y2, X) âˆ§Clothing(Y2)XCarY1Y2InsideOnClothingEven(X) â†Even(Y1) âˆ§Succ (Y1, Y2) âˆ§Succ(Y2, X)XEvenY1SuccY2SuccEar(X) â†Eye(Y1) âˆ§Of(Y1, Y2) âˆ§Of(X, Y2)XEyeY1Y2OfOfXChain-likeTree-likeConjunctionsğ‹ğğ’‡Published as a conference paper at ICLR 2020

Figure 3: A hierarchical rule space where the operator calls, statement evaluations and logic com-
binations are all relaxed into the weight sums with respect to attentions SÏ•, SÏˆ, S(cid:48)
f and so.
W/sum denotes the weighted sum, Matmul denotes the matrix product, Neg denotes soft logic not,
and XEnt denotes the cross-entropy loss.

Ïˆ, Sf , S(cid:48)

we want to further extend the rule search space by exploring the logic combinations of primitive
statements, via {âˆ§, âˆ¨, Â¬}, as shown in Figure 2. To do this, we utilize the soft logic not and soft
logic and operations

Â¬p = 1 âˆ’ p,

p âˆ§ q = p âˆ— q,

where p, q âˆˆ [0, 1]. Here we do not include the logic âˆ¨ operation because it can be implicitly
represented as p âˆ¨ q = Â¬(Â¬p âˆ§ Â¬q). Let Î¨ = {Ïˆk(x, x(cid:48))}K
k=1 be the set of primitive statements with
all possible predicate symbols. We deï¬ne the formula set at lth level as

F0 = Î¨,
Ë†Flâˆ’1 = Flâˆ’1 âˆª {1 âˆ’ f (x, x(cid:48)) : f âˆˆ Flâˆ’1},
i âˆˆ Ë†Flâˆ’1}C
Fl = {fi(x, x(cid:48)) âˆ— f (cid:48)

i (x, x(cid:48)) : fi, f (cid:48)

i=1,

(11)

where each element in the formula set {f : f âˆˆ Fl} is called a formula such that f : R|X | Ã— R|X | (cid:55)â†’
s âˆˆ [0, 1].
Intuitively, we deï¬ne the logic combination space in a similar way as that in path-
ï¬nding: the initial formula set contains only primitive statements Î¨, because they are formulas by
themselves. For the l âˆ’ 1th formula set Flâˆ’1, we concatenate it with its logic negation, which yields
Ë†Flâˆ’1. Then each formula in the next level is the logic and of two formulas from Ë†Flâˆ’1. Enumerating
all possible combinations at each level is expensive, so we set up a memory limitation C to indicate
the maximum number of combinations each level can keep track of1. In other words, each level Fl
is to search for C logic and combinations on formulas from the previous level Ë†Flâˆ’1, such that the
cth formula at the lth level flc is

flc(x, x(cid:48)) = flâˆ’1,i(x, x(cid:48)) âˆ— f (cid:48)

lâˆ’1,i(x, x(cid:48)),
As an example, for Î¨ = {Ïˆ1, Ïˆ2} and C = 2, one possible level sequence is F0 = {Ïˆ1, Ïˆ2},
F1 = {Ïˆ1 âˆ— Ïˆ2, (1 âˆ’ Ïˆ2) âˆ— Ïˆ1}, F2 = {(Ïˆ1 âˆ— Ïˆ2) âˆ— ((1 âˆ’ Ïˆ2) âˆ— Ïˆ1), ...} and etc. To collect the
rules from all levels, the ï¬nal level L is the union of previous sets, i.e. FL = F0 âˆª ... âˆª FLâˆ’1.
Note that Eq.(11) does not explicitly forbid trivial rules such as Ïˆ1 âˆ— (1 âˆ’ Ïˆ1) that is always true
regardless of the input. This is alleviated by introducing nonexistent queries during the training
(detailed discussion at section 5).

flâˆ’1,i, f (cid:48)

lâˆ’1,i âˆˆ Ë†Flâˆ’1.

(12)

Again, the rule selection can be parameterized into the weighted-sum form with respect to the at-
f âˆˆ RLâˆ’1Ã—CÃ—2C, such that flc is the
tentions. We deï¬ne the formula attention tensors as Sf , S(cid:48)
product of two summations over the previous outputs weighted by attention vectors sf,lc and s(cid:48)
respectively2. Formally, we have

f,lc

f,lcflâˆ’1(x, x(cid:48)) âˆ— s(cid:48)(cid:62)
where flâˆ’1(x, x(cid:48)) âˆˆ R2C is the stacked outputs of all formulas f âˆˆ Ë†Flâˆ’1 with arguments (cid:104)x, x(cid:48)(cid:105).
Finally, we want to select the best explanation and compute the score for each query. Let so be the

f,lcflâˆ’1(x, x(cid:48)),

flc(x, x(cid:48)) = s(cid:62)

(13)

1C can vary from level to level, and we keep it the same for notation simplicity
2Formula set at (0)th level Ë†F0 actually contains 2K formulas. Here we assume C = K for notation

simplicity.

6

XEntğ‘´ğŸğ‘´ğŸğ‘´ğ‘²IterateW/sumğ‘´(ğŸ)ğ‘´(ğŸ)ğ‘´(ğ‘»)MatmulMatmulâ€¦MatmulIterateW/sumğğŸğğŸğğ‘²Eq.(10)à· â„±ğŸNegConcatIterateW/sum*â„±ğŸâ„±ğ‘³âˆ’ğŸW/sumâ„±ğ‘³ğ’—ğ’™ğ’—ğ’™â€²ğ’šSampleâ€¦â€¦Iterateâ€¦Iterateğ‘ºğ‹ğ‘ºğğ‘ºğâ€²ğ‘ºğ’‡ğ‘ºğ’‡â€²ğ’”ğ’ğ’”ğ‹(ğ’•)ğ’”ğ,ğ’Œğ’”ğ,ğ’Œâ€²ğ’”ğ’‡,ğ’ğ’„ğ’”ğ’‡,ğ’ğ’„â€²â€¦ğ’=ğŸğ’=ğ‘³âˆ’ğŸPublished as a conference paper at ICLR 2020

Figure 4: The hierarchical Transformer networks for attention generation without conditioning on
the query.

attention vector over FL, so the output score is deï¬ned as

An overview of the relaxed hierarchical rule space is illustrated in Figure 3.

score(x, x(cid:48)) = s(cid:62)

o fL(x, x(cid:48)).

(14)

4 HIERARCHICAL TRANSFORMER NETWORKS FOR RULE GENERATION

We have deï¬ned a hierarchical rule space as shown in Figure 3, where the discrete selections on the
operators, statements and logic combinations are all relaxed into the weight sums with respect to
a series of attention parameters SÏ•, SÏˆ, S(cid:48)
f and so. In this section, we solve (P2), i.e. we
propose a differentiable model that generates these attentions without conditioning on the speciï¬c
query.

Ïˆ, Sf , S(cid:48)

The goal of NLIL is to generate data-independent FOL rules. In other words, for each target pred-
icate P âˆ—, its rule set FL and the ï¬nal output rule should remain unchanged for all the queries
q = (cid:104)x, P âˆ—, x(cid:48)(cid:105) (which is different from that in Eq.(5)). To do this, we deï¬ne the learnable em-
beddings of all predicates as H = [h1, .., hK](cid:62) âˆˆ RKÃ—d, and the embeddings for the â€œdummyâ€
arguments X and X (cid:48) as eX , eX (cid:48) âˆˆ Rd. We deï¬ne the attention generation model as
Ïˆ, Sf , S(cid:48)
where hâˆ— is the embedding of P âˆ—, such that attentions only vary with respect to P âˆ—.

f , so = T(eX , hâˆ—, eX (cid:48); w),

SÏ•, SÏˆ, S(cid:48)

(15)

As shown in Figure 4, we propose a stack of three Transformer (Vaswani et al., 2017) networks
for attention generator T. Each module is designed to mimic the actual evaluation that could hap-
pen during the operator call, primitive statement evaluation and formula computation respectively
with neural networks and â€œdummyâ€ embeddings. And the attention matrices generated during this
simulated evaluation process are kept for evaluating Eq.(14). A MultiHeadAttn is a standard Trans-
former module such that MultiHeadAttn : QqÃ—d Ã— VvÃ—d (cid:55)â†’ OqÃ—d Ã— SqÃ—v, where d is the latent
dimension and q, v are the query and value dimensions respectively. It takes the query Q and input
value V (which will be internally transformed into keys and values), and returns the output value O
and attention matrix S. Intuitively, S encodes the â€œcompatibilityâ€ between query and the value, and
O represents the â€œoutcomeâ€ of a query given its compatibility with the input.
Operator search: For target predicate P âˆ—, we alter the embedding matrix H with

Ë†hk = FeedForward(Concat(hk, hâˆ—)),

Ë†H = [Ë†h1, ..., Ë†hK](cid:62),

such that the rule generation is predicate-speciï¬c. Let q(t)
embedding. The operator transformer module is parameterized as

Ï• be the learnable tth step operator query

Ë†V(0)
Ë†V(t)

Ï• = [eX , eX (cid:48)](cid:62),
Ï• , Ë†S(t)

Ï• = MultiHeadAttn( Ë†QÏ•, Ë†V(tâˆ’1)

Ï•

Ë†QÏ• = Ë†H + eÏ•,
Ï• , s(t)
v(t)

Ï• = MultiHeadAttn(q(t)

Ï• , Ë†V(t)

Ï• ).

),

Here, Ë†V(0)
Ï• is the dummy input embedding representing the starting points of the paths. eÏ• is a
learnable operator encoding such that Ë†QÏ• represents the embeddings of all operators Î¦. Therefore,

7

TransformerConcat&feedforwardXL-1Transformer+XTTransformer+Concat&feedforwardexex'â€¦eÏ†à·¡ğ‘¸ğ‹à·©ğ‘½ğà·¡ğ‘½ğ’‡,ğ’âˆ’ğŸTransformerà·¡ğ‘½ğ‹(ğ’•)ğ’’ğ‹(ğ’•)ğ’”ğ‹(ğ’•)ğ’—ğ‹(ğ’•)ğ’†ğğ’†ğâ€²X2IterateConcatğ’†+ğ’†Â¬Iterate+X2ğ‘¸ğğ‘½ğ‹ğ‘ºğâ€¦ğ‘¸ğ’‡,ğ’ğ‘ºğ’‡,ğ’à·©ğ‘½ğ’‡.ğ’à·¡ğ‘¯à·¡ğ‘¯ğ’’ğ‹(ğ’•)à·¡ğ‘ºğ‹(ğ’•)à·¡ğ‘½ğ‹(ğ’•âˆ’ğŸ)à·¡ğ‘½ğ‹(ğ’•)ğ‘¸ğ’‡,ğ’ConcatTransformerğ’’ğ’ğ‘½ğ’ğ’—ğ’ğ’”ğ’ğ’’ğ’ğ‘ºğ‹ğ‘ºğğ‘ºğâ€²ğ‘ºğ’‡ğ‘ºğ’‡â€²ğ’”ğ’ConcatPublished as a conference paper at ICLR 2020

Table 1: MRR, Hits@10 and time (mins) of KB comple-
tion tasks.

Table 2: Statistics of benchmark KBs
and Visual Genome scene-graphs.

Model

FB15K-237

WN18

KB

# facts

# entities

# predicates

MRR Hits@10 Time MRR Hits@10 Time

NeuralLP
TransE
RotatE

NLIL

0.24
0.28
0.34

0.25

36.2
44.5
52.6

32.4

250
35
342

82

0.94
0.57
0.94

0.95

94.5
93.3
95.5

94.6

54
53
254

12

ES-10
ES-50
ES-1K 1.5K

17
77

10
50
1K

WN18
106K
FB15K 272K
VG

40K
15K
1.9M 1.4M

3
3
3

18
237
2100

we consider that Ë†V(t)
the outputs with another MultiHeadAttn with respect to a single query q(t)
the operator path attention vector s(t)

Ï• encodes the outputs of the operator calls of K predicates. And we aggregate
Ï• , which in turn yields

Ï• and aggregated output v(t)
Ï• .
Ï• , ..., v(T )

Ï• ](cid:62) be the output embedding of T paths. The

Primitive statement search: Let VÏ• = [v(1)
path attention is generated as

QÏˆ = Ë†H + eÏˆ, Q(cid:48)
ËœV(cid:48)

Ïˆ = Ë†H + e(cid:48)
Ïˆ,
Ïˆ = MultiHeadAttn(Q(cid:48)
Ïˆ, VÏ•),

Ïˆ, S(cid:48)

ËœVÏˆ, SÏˆ = MultiHeadAttn(QÏˆ, VÏ•),
VÏˆ = FeedForward(Concat( ËœVÏˆ, ËœV(cid:48)

Ïˆ)).

Here, eÏˆ and e(cid:48)
Ïˆ are the ï¬rst and second argument encodings, such that QÏˆ and Q(cid:48)
Ïˆ encode the
arguments of each statement in Î¨. The compatibility between paths and the arguments are computed
with two MultiHeadAttns. Finally, a FeedForward is used to aggregate the selections. Its output
VÏˆ âˆˆ RKÃ—d represents the results of all statement evaluations in Î¨.
Formula search: Let Qf,l, Q(cid:48)
of formulas at lth level, and let Vf,0 = VÏˆ. The formula attention is generated as

f,l âˆˆ RCÃ—d be the learnable queries of the ï¬rst and second argument

Ë†Vf,lâˆ’1 = [Vf,lâˆ’1 + e+, Vf,lâˆ’1 + eÂ¬],
ËœV(cid:48)
f,l = MultiHeadAttn(Q(cid:48)

f,l, Ë†Vf,lâˆ’1), Vf,l = FeedForward(Concat( ËœVf,l, ËœV(cid:48)

ËœVf,l, Sf,l = MultiHeadAttn(Qf,l, Ë†Vf,lâˆ’1),
f,l)).

f,l, S(cid:48)

Here, e+, eÂ¬ are the learnable embeddings, such that Ë†Vf,lâˆ’1 represents the positive and negative
states of the formulas at l âˆ’ 1th level. Similar to the statement search, the compatibility between the
logic and arguments and the previous formulas are computed with two MultiHeadAttns. And the
embeddings of formulas at lth level Vf,l are aggregated by a FeedForward. Finally, let qo be the
learnable ï¬nal output query and let Vo = [Vf,0, ..., Vf,Lâˆ’1]. The output attention is computed as

vo, so = MultiHeadAttn(qo, Vo).

5 STOCHASTIC TRAINING AND RULE VISUALIZATIONS

The training of NLIL consists of two phases: rule generation and rule evaluation. During gen-
f and so for all P âˆ—s. For the
eration, we run Eq.(15) to obtain the attentions SÏ•, SÏˆ, S(cid:48)
Ïˆ, Sf , S(cid:48)
evaluation phase, we sample a mini-batch of queries {(cid:104)x, P âˆ—, x(cid:48), y(cid:105)i}b
i=1, and evaluate the formulas
using Eq.(14). Here, y is the query label indicating if the triplet exists in the KB or not. We sample
nonexistent queries to prevent the model from learning trivial rules that always output 1. In the
experiments, these negative queries are sampled uniformly from the target query matrix M âˆ— where
the entry is 0. Then the objective becomes

arg min
w

1
b

b
(cid:88)

i

CrossEntropy(yi, s(cid:62)

o fL(x, x(cid:48))).

Since the attentions are generated from Eq.(15) differentiably, the loss is back-propagated through
the attentions into the Transformer networks for end-to-end training.

5.1 EXTRACTING EXPLICIT RULES

During training, the results from operator calls and logic combinations are averaged via attentions.
For validation and testing, we evaluate the model with the explicit FOL rules extracted from the

8

Published as a conference paper at ICLR 2020

Model

ES-10 ES-50 ES-1K

âˆ‚ILP
NeuralLP

5.6
0.1

240
0.1

NLIL

<0.1

<0.1

-
0.2

0.1

(a)

Figure 5: (a) Time (mins) for solving Even-and-Successor tasks.
(-) indicates method runs out
of time limit; (b) Running time for different rule lengths; (c) R@1 for object classiï¬cation with
different training set size.

(b)

(c)

attentions. To do this, one can view an attention vector as a categorical distribution. For example,
s(t)
Ï• is such a distribution over random variables k âˆˆ [1, K]. And the weighted sum is the expectation
over Mk. Therefore, one can extract the explicit rules by sampling from the distributions (Kool et al.,
2018; Yang et al., 2017).

However, since we are interested in the best rules and the attentions usually become highly concen-
trated on one entity after convergence. We replace the sampling with the arg max, where we get the
one-hot encoding of the entity with the largest probability mass.

6 EXPERIMENTS
We ï¬rst evaluate NLIL on classical ILP benchmarks and compare it with 4 state-of-the-art KB
completion methods in terms of their accuracy and efï¬ciency. Then we show NLIL is capable of
learning FOL explanations for object classiï¬ers on a large image dataset when scene-graphs are
present. Though each scene-graph corresponds to a small KB, the total amount of the graphs makes
it infeasible for all classical ILP methods. We show that NLIL can overcome it via efï¬cient stochastic
training. Our implementation is available at https://github.com/gblackout/NLIL.

6.1 CLASSICAL ILP BENCHMARKS

We evaluate NLIL together with two state-of-the-art differentiable ILP methods,
i.e. Neu-
ralLP (Yang et al., 2017) and âˆ‚ILP (Evans & Grefenstette, 2018), and two structure embedding
methods, TransE (Bordes et al., 2013) and RotatE (Sun et al., 2019). Detailed experiments setup is
available at Appendix C.

Benchmark datasets: (i) Even-and-Successor (ES) benchmark is introduced in (Evans & Grefen-
stette, 2018), which involves two unary predicates Even(X), Zero(X) and one binary predicate
Succ(X, Y ). The goal is to learn FOL rules over a set of integers. The benchmark is evaluated
with 10, 50 and 1K consecutive integers starting at 0; (ii) FB15K-237 is a subset of the Freebase
knowledge base (Toutanova & Chen, 2015) containing general knowledge facts; (iii) WN18 (Bordes
et al., 2013) is the subset of WordNet containing relations between words. Statistics of datasets are
provided in Table 2.

Knowledge base completion: All models are evaluated on the KB completion task. The benchmark
datasets are split into train/valid/test sets. The model is tasked to predict the probability of a fact
triplet (query) being present in the KB. We use Mean Reciprocal Ranks (MRR) and Hits@10 for
evaluation metrics (see Appendix C for details).

Results on Even-and-Successor benchmark are shown in Table 5a. Since the benchmark is noise-
free, we only show the wall clock time for completely solving the task. As we have previously
mentioned, the forward-chaining method, i.e. âˆ‚ILP scales exponentially in the number of facts and
quickly becomes infeasible for 1K entities. Thus, we skip its evaluation for other benchmarks.

Results on FB15K-237 and WN18 are shown in Table. 1. Compared to NeuralLP, NLIL yields
slightly higher scores. This is due to the benchmarks favor symmetric/asymmetric relations or com-
positions of a few relations (Sun et al., 2019), such that most valuable rules will already lie within
the chain-like search space of NeuralLP. Thus the improvements gained from a larger search space
with NLIL are limited. On the other hand, with the Transformer block and smaller model created

9

LengthTime Per Epochs / Mins010020030024681020NeuralLPNLILData Portion / %R@10.070.090.20.30.40.50.010.1110100MLP+RCNNFreqNLILPublished as a conference paper at ICLR 2020

for each target predicate, NLIL can achieve a similar score at least 3 times faster. Compared to the
structure embedding methods, NLIL is signiï¬cantly outperformed by the current state-of-the-art,
i.e. RotatE, on FB15K. This is expected because NLIL searches over the symbolic space that is
highly constrained. However, the learned rules are still reasonably predictive, as its performance is
comparable to that of TransE.

Scalability for long rules: we demonstrate that NLIL can explore longer rules efï¬ciently. We
compare the wall clock time of NeuralLP and NLIL for performing one epoch of training against
different maximum rule lengths. As shown in Figure 5b, NeuralLP searches over a chain-like rule
space thus scales linearly with the length, while NLIL searches over a hierarchical space thus grows
in log scale. The search time for length 32 in NLIL is similar to that for length 3 in NerualLP.

6.2

ILP ON VISUAL GENOME DATASET

The ability to perform ILP efï¬ciently extends the applications of NLIL to beyond canonical KB
completion. For example in visual object detection and relation learning, supervised models can
learn to generate a scene-graph (As shown in Figure 1) for each image. It consists of nodes each
labeled as an object class. And each pair of objects are connected with one type of relation. The
scene-graph can then be represented as a relational KB where one can perform ILP. Learning the
FOL rules on such an output of a supervised model is beneï¬cial. As it provides an alternative way of
interpreting model behaviors in terms of its relations with other classiï¬ers that are consistent across
the dataset.

To show this, we conduct experiments on Visual Genome dataset (Krishna et al., 2016). The original
dataset is highly noisy (Zellers et al., 2018), so we use a pre-processed version available as the GQA
dataset (Hudson & Manning, 2019). The scene-graphs are converted to a collection KBs, and its
statistics are shown in Table 2. We ï¬lter out the predicates with less than 1500 occurrences. The
processed KBs contain 213 predicates. Then we perform ILP on learning the explanations for the
top 150 objects in the dataset.

Table 3: R@1 and R@5 for
150 objects classiï¬cation on
VG.

Model

Visual Genome

R@1

R@5

MLP+RCNN 0.53
0.40
Freq

NLIL

0.51

0.81
0.44

0.52

Quantitatively, we evaluate the learned rules on predicting the ob-
ject class labels on a held-out set in terms of their R@1 and R@5.
As none of the ILP works scale to this benchmark, we compare
NLIL with two supervised baselines: (i) MLP-RCNN: a MLP clas-
siï¬er with RCNN features of the object (available in GQA dataset)
as input; and (ii) Freq: a frequency-based baseline that predicts
object label by looking at the mostly occurred object class in the re-
lation that contains the target. This method is nontrivial. As noted
in (Zellers et al., 2018), a large number of triples in Visual Genome
are highly predictive by knowing only the relation type and either
one of the objects or subjects.

Explaining objects with rules: Results are shown in Table 3. We see that the supervised method
achieves the best scores, as it relies on highly informative visual features. On the other hand, NLIL
achieves a comparable score on R@1 solely relying on KBs with sparse binary labels. We note that
NLIL outperforms Freq signiï¬cantly. This means the FOL rules learned by NLIL are beyond the
superï¬cial correlations exhibited by the dataset. We verify this ï¬nding by showing the rules for top
objects in Table 4.

Induction for few-shot learning: Logic inductive learning is data-efï¬cient and the learned rules are
highly transferrable. To see this, we vary the size of the training set and compare the R@1 scores
for 3 methods. As shown in Figure 5c, the NLIL maintains a similar R@1 score with less than 1%
of the training set.

7 CONCLUSION

In this work, we propose Neural Logic Inductive Learning, a differentiable ILP framework that
learns explanatory rules from data. We demonstrate that NLIL can scale to very large datasets while
being able to search over complex and expressive rules. More importantly, we show that a scalable
ILP method is effective in explaining decisions of supervised models, which provides an alternative
perspective for inspecting the decision process of machine learning systems.

10

Published as a conference paper at ICLR 2020

ACKNOWLEDGMENTS

This project is partially supported by DARPA ASED program under FA8650-18-2-7882. We thank
Ramesh Arvind3 and Hoon Na4 for implementing the MLP baseline.

REFERENCES

Ivana BalaË‡zeviÂ´c, Carl Allen, and Timothy M Hospedales. Tucker: Tensor factorization for knowl-

edge graph completion. arXiv preprint arXiv:1901.09590, 2019.

Antoine Bordes, Nicolas Usunier, Alberto Garcia-Duran, Jason Weston, and Oksana Yakhnenko.
Translating embeddings for modeling multi-relational data. In Advances in neural information
processing systems, pp. 2787â€“2795, 2013.

Andres Campero, Aldo Pareja, Tim Klinger, Josh Tenenbaum, and Sebastian Riedel. Logical rule
induction and theory learning using neural theorem proving. arXiv preprint arXiv:1809.02193,
2018.

Xinlei Chen, Li-Jia Li, Li Fei-Fei, and Abhinav Gupta. Iterative visual reasoning beyond convolu-
tions. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp.
7239â€“7248, 2018.

William W Cohen, Fan Yang, and Kathryn Rivard Mazaitis. TensorLog: Deep learning meets

probabilistic DBs. July 2017.

Rajarshi Das, Arvind Neelakantan, David Belanger, and Andrew McCallum. Chains of rea-
arXiv preprint

soning over entities, relations, and text using recurrent neural networks.
arXiv:1607.01426, 2016.

Rajarshi Das, Shehzaad Dhuliawala, Manzil Zaheer, Luke Vilnis, Ishan Durugkar, Akshay Krishna-
murthy, Alex Smola, and Andrew McCallum. Go for a walk and arrive at the answer: Reasoning
over paths in knowledge bases using reinforcement learning. arXiv preprint arXiv:1711.05851,
2017.

Honghua Dong, Jiayuan Mao, Tian Lin, Chong Wang, Lihong Li, and Denny Zhou. Neural logic
machines. In International Conference on Learning Representations, 2019. URL https://
openreview.net/forum?id=B1xY-hRctX.

Richard Evans and Edward Grefenstette. Learning explanatory rules from noisy data. Journal of

Artiï¬cial Intelligence Research, 61:1â€“64, 2018.

Luis GalÂ´arraga, Christina Teï¬‚ioudi, Katja Hose, and Fabian M Suchanek. Fast rule mining in onto-
logical knowledge bases with amie+. The VLDB JournalThe International Journal on Very Large
Data Bases, 24(6):707â€“730, 2015.

Matt Gardner and Tom Mitchell. Efï¬cient and expressive knowledge base completion using sub-
graph feature extraction. In Proceedings of the 2015 Conference on Empirical Methods in Natural
Language Processing, pp. 1488â€“1498, 2015.

Riccardo Guidotti, Anna Monreale, Salvatore Ruggieri, Franco Turini, Fosca Giannotti, and Dino
Pedreschi. A survey of methods for explaining black box models. ACM computing surveys
(CSUR), 51(5):93, 2019.

Kelvin Guu, John Miller, and Percy Liang. Traversing knowledge graphs in vector space. arXiv

preprint arXiv:1506.01094, 2015.

Vinh Thinh Ho, Daria Stepanova, Mohamed H Gad-Elrab, Evgeny Kharlamov, and Gerhard
Weikum. Rule learning from knowledge graphs guided by embedding models. In International
Semantic Web Conference, pp. 72â€“90. Springer, 2018.

3ramesharvind@gatech.edu
4hna30@gatech.edu

11

Published as a conference paper at ICLR 2020

Drew A Hudson and Christopher D Manning. Gqa: A new dataset for real-world visual reasoning
In Proceedings of the IEEE Conference on Computer

and compositional question answering.
Vision and Pattern Recognition, pp. 6700â€“6709, 2019.

Wouter Kool, Herke van Hoof, and Max Welling. Attention, learn to solve routing problems! arXiv

preprint arXiv:1803.08475, 2018.

Ranjay Krishna, Yuke Zhu, Oliver Groth, Justin Johnson, Kenji Hata, Joshua Kravitz, Stephanie
Chen, Yannis Kalantidis, Li-Jia Li, David A Shamma, Michael Bernstein, and Li Fei-Fei. Visual
genome: Connecting language and vision using crowdsourced dense image annotations. 2016.
URL https://arxiv.org/abs/1602.07332.

Ni Lao and William W Cohen. Relational retrieval using a combination of path-constrained random

walks. Machine learning, 81(1):53â€“67, 2010.

Nada Lavrac and Saso Dzeroski. Inductive logic programming. In WLP, pp. 146â€“160. Springer,

1994.

Yankai Lin, Zhiyuan Liu, Huanbo Luan, Maosong Sun, Siwei Rao, and Song Liu. Modeling relation
paths for representation learning of knowledge bases. arXiv preprint arXiv:1506.00379, 2015.

Zachary C Lipton. The mythos of model interpretability. arXiv preprint arXiv:1606.03490, 2016.

Pasquale Minervini, Matko Bosnjak, Tim RocktÂ¨aschel, and Sebastian Riedel. Towards neural theo-

rem proving at scale. arXiv preprint arXiv:1807.08204, 2018.

Brent Mittelstadt, Chris Russell, and Sandra Wachter. Explaining explanations in ai. In Proceedings

of the conference on fairness, accountability, and transparency, pp. 279â€“288. ACM, 2019.

Chris Olah, Arvind Satyanarayan, Ian Johnson, Shan Carter, Ludwig Schubert, Katherine Ye, and

Alexander Mordvintsev. The building blocks of interpretability. Distill, 3(3):e10, 2018.

Pouya Ghiasnezhad Omran, Kewen Wang, and Zhe Wang. Scalable rule learning via learning rep-

resentation. In IJCAI, pp. 2149â€“2155, 2018.

Ali Payani and Faramarz Fekri. Inductive logic programming via differentiable deep neural logic

networks. arXiv preprint arXiv:1906.03523, 2019.

Marco Tulio Ribeiro, Sameer Singh, and Carlos Guestrin. Why should i trust you?: Explaining the
predictions of any classiï¬er. In Proceedings of the 22nd ACM SIGKDD international conference
on knowledge discovery and data mining, pp. 1135â€“1144. ACM, 2016.

Tim RocktÂ¨aschel and Sebastian Riedel. End-to-end differentiable proving. In Advances in Neural

Information Processing Systems, pp. 3788â€“3800, 2017.

Richard Socher, Danqi Chen, Christopher D Manning, and Andrew Ng. Reasoning with neural
tensor networks for knowledge base completion. In Advances in neural information processing
systems, pp. 926â€“934, 2013.

Zhiqing Sun, Zhi-Hong Deng, Jian-Yun Nie, and Jian Tang. Rotate: Knowledge graph embedding

by relational rotation in complex space. arXiv preprint arXiv:1902.10197, 2019.

Kristina Toutanova and Danqi Chen. Observed versus latent features for knowledge base and text
inference. In Proceedings of the 3rd Workshop on Continuous Vector Space Models and their
Compositionality, pp. 57â€“66, 2015.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,
In Advances in Neural Infor-

Åukasz Kaiser, and Illia Polosukhin. Attention is all you need.
mation Processing Systems, pp. 5998â€“6008, 2017.

Fan Yang, Zhilin Yang, and William W Cohen. Differentiable learning of logical rules for knowledge
base reasoning. In Advances in Neural Information Processing Systems, pp. 2319â€“2328, 2017.

Rowan Zellers, Mark Yatskar, Sam Thomson, and Yejin Choi. Neural motifs: Scene graph parsing
In Proceedings of the IEEE Conference on Computer Vision and Pattern

with global context.
Recognition, pp. 5831â€“5840, 2018.

12

Published as a conference paper at ICLR 2020

A RELATED WORK

Inductive Logic Programming (ILP) is the task that seeks to summarize the underlying patterns
shared in the data and express it as a set of logic programs (or rule/formulae) (Lavrac & Dzeroski,
1994). Traditional ILP methods such as AMIE+ (GalÂ´arraga et al., 2015) and RLvLR (Omran et al.,
2018) relies on explicit search-based method for rule mining with various pruning techniques. These
works can scale up to very large knowledge bases. However, the algorithm complexity grows expo-
nentially in the size of the variables and predicates involved. The acquired rules are often restricted
to Horn clauses with a maximum length of less than 3, limiting the expressiveness of the rules.
On the other hand, compared to the differentiable approach, traditional methods make use of hard
matching and discrete logic for rule search, which lacks the tolerance for ambiguous and noisy data.

The state-of-the-art differentiable forward-chaining methods focus on rule learning on predeï¬ned
templates (Evans & Grefenstette, 2018; Campero et al., 2018; Ho et al., 2018), typically in the form
of a Horn clause with one head predicate and two body predicates with chain-like variables, i.e.

P âˆ—(X, X (cid:48)) â† P1(X, Y ) âˆ§ P2(Y, X (cid:48)).

To evaluate the rules, one starts with a background set of facts and repeatedly apply rules for every
possible triple until no new facts can be deduced. Then the deduced facts are compared with a held-
out ground-truth set. Rules that are learned in this approach are in ï¬rst-order, i.e. data-independent
and can be readily interpreted. However, the deducing phase can quickly become infeasible with a
larger background set. Although âˆ‚ILP (Evans & Grefenstette, 2018) has proposed to alleviate by
performing only a ï¬xed number of steps, works of this type could generally scale to KBs with less
than 1K facts and 100 entities. On the other hand, differentiable backward-chaining methods such
as NTP (RocktÂ¨aschel & Riedel, 2017) are more efï¬cient in rule evaluation. In (Minervini et al.,
2018), NTP 2.0 can scale to larges KBs such as WordNet. However, FOL rules are searched with
templates, so the expressiveness is still limited.

Another differentiable ILP method, i.e. Neural Logic Machine (NLM), is proposed in (Dong et al.,
2019), which learns to represent logic predicates with tensorized operations. NLM is capable of both
deductive and inductive learning on predicates with unknown arity. However, as a forward-chaining
method, it also suffers from the scalability issue as âˆ‚ILP. It involves a permutation operation over
the tensors when performing logic deductions, making it difï¬cult to scale to real-world KBs. On the
other hand, the inductive rules learned by NLM are encoded by the network parameters implicitly,
so it does not support representing the rules with explicit predicate and logic variable symbols.

Multi-hop reasoning: Multi-hop reasoning methods (Guu et al., 2015; Lao & Cohen, 2010; Lin
et al., 2015; Gardner & Mitchell, 2015; Das et al., 2016; Yang et al., 2017) such as NeuralLP (Yang
et al., 2017) construct rule on-the-ï¬‚y when given a speciï¬c query. It adopts a ï¬‚exible ILP setting:
instead of pre-deï¬ning templates, it assumes a chain-like Horn clause can be constructed to answer
the query

P âˆ—(X, X (cid:48)) â† P (1)(X, Y1) âˆ§ P (2)(Y1, Y2) âˆ§ ... âˆ§ P (T )(Ynâˆ’1, X (cid:48)).

And each step of the reasoning in the chain can be efï¬ciently represented by matrix multiplication.
The resulting algorithm is highly scalable compared to the forward-chaining counter-parts and can
learn rules on large datasets such as FreeBase. However, this approach reasons over a single chain-
like path, and the path is sampled by performing random walks that are independent on the task
context (Das et al., 2017), limiting the rule expressiveness. On the other hand, the FOL rule is gen-
erated while conditioning on the speciï¬c query, making it difï¬cult to extract rules that are globally
consistent.

Link prediction with relational embeddings: Besides multi-hop reasoning methods, a number of
works are proposed for KB completion using learnable embeddings for KB relations. For example,
In (Bordes et al., 2013; Sun et al., 2019; BalaË‡zeviÂ´c et al., 2019) it learns to map KB relations into
vector space and predict links with scoring functions. NTN (Socher et al., 2013), on the other
hand, parameterizes each relation into a neural network. In this approach, embeddings are used
for predicting links directly, thus its prediction cannot be interpreted as explicit FOL rules. This is
different from that in NLIL, where predicate embeddings are used for generating data-independent
rules.

13

Published as a conference paper at ICLR 2020

Table 4: Example rules learned by NLIL

Person(X) â† (Shirt(Y1) âˆ§ Wearing(X, Y1)) âˆ¨ (Pants(Y2) âˆ§ Wearing(X, Y2))âˆ¨

(Street(Y3) âˆ§ WalkingOn(X, Y3))

Tree(X) â† (Leaf(Y1) âˆ§ At(Y1, X)) âˆ¨ (SideWalk(Y2) âˆ§ Near(Y2, X))
Shirt(X) â† (Person(Y1) âˆ§ Wearing(Y1, X)) âˆ¨ (Child(Y2) âˆ§ Wearing(Y2, X))
Sky(X) â† (Clouds(Y1) âˆ§ in(Y1, X)) âˆ¨ (Airplane(Y2) âˆ§ Below(X, Y2))
Head(X) â† Helmet(Y1) âˆ§ Above(Y1, X)
Head(X) â† Wearing(Y1, Y2) âˆ§ SittingOn(X, Y1) âˆ§ Hat(Y2)
Sign(X) â† (Number(Y1) âˆ§ On(Y1, X)) âˆ¨ (Post(Y2) âˆ§ On(Y2, X))âˆ¨

(Letter(Y3) âˆ§ In(Y3, X))

Sign(X) â† StreetLight(Y1) âˆ§ On(Y1, Y2) âˆ§ On(X, Y2)
Ground(X) â† (Dog(Y1) âˆ§ On(Y1, X)) âˆ¨ (Grass(Y2) âˆ§ CoveredBy(X, Y2))
Car(X) â† Wheel(Y1) âˆ§ Of(Y1, X) âˆ§ Window(Y2) âˆ§ Of(Y2, X)
Sidewalk(X) â† Person(Y1) âˆ§ WalkingOn(Y1, X) âˆ§ Street(Y2) âˆ§ Near(X, Y2)
Car(X) â† Wheel(Y1) âˆ§ Of(Y1, X) âˆ§ Window(Y2) âˆ§ Of(Y2, X)
Ear(X) â† Eye(Y1) âˆ§ Of(Y1, Y2) âˆ§ Of(X, Y2)
Chair(X) â† Arm(Y1) âˆ§ In(Y1, X) âˆ§ Person(Y2) âˆ§ SittingOn(Y2, X)

B CHALLENGES IN ILP

Standard ILP approaches are difï¬cult and involve several procedures that have been proved to be
NP-hard. The complexity comes from 3 levels: ï¬rst, the search space for a formula is vast. The
body of the entailment can be arbitrarily long and the same predicate can appear multiple times with
different variables, for example, the Inside predicate in Eq.(2) appears twice. Most ILP works
constrain the logic entailment to be Horn clause, i.e. the body of the entailment is a ï¬‚at conjunction
over literals, and the length limited within 3 for large datasets.

Second, constructing formulas also involves assigning logic variables that are shared across different
predicates, which we refer to as variable binding. For example, in Eq.(2), to express that a person is
inside the car, we use X and Y to represent the region of a person and that of a car, and the same two
variables are used in Inside to express their relations. Different bindings lead to different mean-
ings. For a formula with n arguments (Eq.(2) has 7), there are O(nn) possible assignments. Existing
ILP works either resort to constructing formula from pre-deï¬ned templates (Evans & Grefenstette,
2018; Campero et al., 2018) or from chain-like variable reference (Yang et al., 2017), limiting the
expressiveness of the learned rules.

Finally, evaluating a formula candidate is expensive. A FOL rule is data-independent. To evaluate
it, one needs to replace the variables with actual entities and compute its value. This is referred
to as grounding or instantiation. Each variable used in a formula can be grounded independently,
meaning a formula with n variables can be instantiated into O(C n) grounded formulas, where C is
the number of total entities. For example, Eq.(2) contains 3 logic variables: X, Y and Z. To evaluate
this formula, one needs to instantiate these variables into C 3 possible combinations, and check if the
rule holds or not in each case. However in many domains, such as object detection, such grounding
space is vast (e.g. all possible bounding boxes of an image) making the full evaluation infeasible.
Many forward-chaining methods such as âˆ‚ILP (Evans & Grefenstette, 2018) scales exponentially in
the size of the grounding space, thus are limited to small scale datasets with less than 10 predicates
and 1K entities.

C EXPERIMENTS

Baselines: For NeuralLP, we use the ofï¬cial implementation at here. For âˆ‚ILP, we use the third-
party implementation at here. For TransE, we use the implementation at here. For RotatE, we use
the ofï¬cial implementation at here.

14

Published as a conference paper at ICLR 2020

Table 5: Example low-accuracy rules learned by NLIL.

Bush(X) â† Â¬Tree(X)
Bus(X) â† Â¬(Shirt(Y1) âˆ§ Wearing(Y1, X))
Backpack(X) â† Person(Y1) âˆ§ With(Y1, X)
Flowers(X) â† Pot(Y1) âˆ§ With(X, Y1)
Dirt(X) â† Ground(Y1) âˆ§ Near(Y1, X)

Model setting: For NLIL, we create separate Transformer blocks for each target predicate. All
experiments are conducted on a machine with i7-8700K, 32G RAM and one GTX1080ti. We use
the embedding size d = 32. We use 3 layers of multi-head attentions for each Transformer network.
The number of attention heads are set to number of heads = 4 for encoder, and the ï¬rst two layers
of the decoder. The last layer of the decoder has one attention head to produce the ï¬nal attention
required for rule evaluation.

For KB completion task, we set the number of operator calls T = 2 and formula combinations
L = 0, as most of the relations in those benchmarks can be recovered by symmetric/asymmetric
relations or compositions of a few relations (Sun et al., 2019). Thus complex formulas are not
preferred. For FB15K-237, binary predicates are grouped hierarchically into domains. To avoid
unnecessary search overhead, we use the most frequent 20 predicates that share the same root domain
(e.g. â€œawardâ€, â€œlocationâ€) with the head predicate for rule body construction, which is a similar
treatment as in (Yang et al., 2017). For VG dataset, we set T = 3, L = 2 and C = 4.

Evaluation metrics: Following the conventions in (Yang et al., 2017; Bordes et al., 2013) we use
Mean Reciprocal Ranks (MRR) and Hits@10 for evaluation metrics. For each query (cid:104)x, Pk, x(cid:48)(cid:105),
the model generates a ranking list over all possible groundings of predicate Pk, with other ground-
truth triplets ï¬ltered out. Then MRR is the average of the reciprocal rank of the queries in their
corresponding lists, and Hits@10 is the percentage of queries that are ranked within the top 10 in
the list.

15

