1
2
0
2

n
u
J

5
1

]

G
L
.
s
c
[

1
v
4
6
0
8
0
.
6
0
1
2
:
v
i
X
r
a

Generating Contrastive Explanations for Inductive
Logic Programming Based on a Near Miss Approach(cid:63)

Johannes Rabold1[0000−0003−0656−5881], Michael Siebers1[0000−0003−1891−3572], and Ute
Schmid1[0000−0002−1301−0326]

1Cognitive Systems, University of Bamberg
{johannes.rabold,michael.siebers,ute.schmid}@uni-bamberg.de

Abstract. In recent research, human-understandable explanations of machine
learning models have received a lot of attention. Often explanations are given
in form of model simpliﬁcations or visualizations. However, as shown in cog-
nitive science as well as in early AI research, concept understanding can also
be improved by the alignment of a given instance for a concept with a similar
counterexample. Contrasting a given instance with a structurally similar example
which does not belong to the concept highlights what characteristics are nec-
essary for concept membership. Such near misses have been proposed by Win-
ston (1970) as efﬁcient guidance for learning in relational domains. We introduce
an explanation generation algorithm for relational concepts learned with Induc-
tive Logic Programming (GENME). The algorithm identiﬁes near miss examples
from a given set of instances and ranks these examples by their degree of close-
ness to a speciﬁc positive instance. A modiﬁed rule which covers the near miss
but not the original instance is given as an explanation. We illustrate GENME
with the well known family domain consisting of kinship relations, the visual
relational Winston arches domain and a real-world domain dealing with ﬁle man-
agement. We also present a psychological experiment comparing human prefer-
ences of rule-based, example-based, and near miss explanations in the family and
the arches domains.

Keywords: Explainable AI · Relational Concepts · Contrastive Explanations ·
Inductive Logic Programming · Near Miss Examples

1

Introduction

Explaining classiﬁer decisions has gained much attention in current research. If expla-
nations are intended for the end-user, their main function is to make the human com-
prehend how the system reached a decision (Miller 2019). In the last years a variety
of approaches to explainability has been proposed (Adadi and Berrada 2018; Molnar
2019): Explanations can be local – focusing on the current class decision – or global
– covering the learned model (Ribeiro et al. 2016; Adadi and Berrada 2018). A major

(cid:63) Part of the work reported in this paper is funded by the Deutsche Forschungsgemeinschaft
(DFG, German Research Foundation), project 427404493 (Dare2Del). The authors declare
that there is no conﬂict of interest. Data, material, and code used for this work can be obtained
by writing the authors an e-mail. All authors contributed equally to this work.

 
 
 
 
 
 
2

J. Rabold et al.

branch of research addresses explanations by visualizations for end-to-end image clas-
siﬁcation (Samek et al. 2017; Ribeiro et al. 2016). Alternatively, explanations can be
in form of symbolic rules (Lakkaraju et al. 2016; Muggleton et al. 2018) or in natural
language (Stickel 1991; Ehsan et al. 2018; Siebers and Schmid 2019). A third approach
to explanations is to offer prototypical examples to illustrate a model (Bien et al. 2011;
Gurumoorthy et al.). Finally, counterexamples can be used as counterfactuals or con-
trastive explanations. Counterfactuals typically are minimal changes in feature values
which would have resulted in a different decision, such as: You were denied a loan be-
cause your annual income was £30,000. If your income had been £45,000, you would
have been offered a loan. (Wachter et al. 2017). In philosophy, counterfactuals have
been characterized by the concept of a ‘closest possible world’, that is, the smallest
change required to obtain a different (and more desirable) outcome (Pollock 1976).
Contrastive explanations have been proposed mainly for image classiﬁcation. For in-
stance, the contrastive explanation method CEM (Dhurandhar et al. 2018) highlights
what is minimally but critically absent in an image in order to belong to a given class.
The MMD-critic (Kim et al. 2016) can identify nearest prototypes and nearest miss in-
stances in image data such as handwritten digits and in Imagenet datasets. Furthermore,
an algorithm ProtoDash has been proposed to identify prototypes and criticisms for ar-
bitrary symmetric positive deﬁnite kernels which has been applied to both tabular as
well as image data.

An approach related to counterexamples has been proposed in early AI research
by Winston in the context of learning relational concepts such as arch (Winston 1970).
He demonstrated that presenting near miss examples where only a small number of
relational aspects is missing to make an object a member of a class result in a speed up
for learning. Similarly, in cognitive science research, it has been shown that alignment
of structured representations helps humans to understand and explain concepts (Gentner
and Markman 1994). Gentner and Markman found that it is easier for humans to ﬁnd
the differences between pairs of similar items than to ﬁnd the differences between pairs
of dissimilar items. For example, it is easier to explain the concept of a light bulb by
contrasting it with a candle than with a cat (Gentner and Markman 1994).

Induction of relational concepts has been investigated in Inductive Logic Program-
ming (ILP) (Muggleton and De Raedt 1994), statistical relational learning (Koller et al.
2007), and recently also in the context of deep learning with approaches such as RelNN
(Kazemi and Poole 2018) and Differentiable Neural Computers (DNCs) (Graves et al.
2016). DNCs have been demonstrated to be able to learn symbolic relational concepts
such as family relations or travel routes in the London underground system. These do-
mains are typical examples for domains where ILP approaches have been demonstrated
to be highly successful (Muggleton et al. 2018). For DNCs, questions and answers
are represented as Prolog clauses. However, in contrast to ILP, the learned models are
black-box. For the family domain as well as for an isomorphic ﬁctitious chemistry do-
main it has been shown, that rules learned with ILP fulﬁll Donald Michie’s criterion of
ultra-strong machine learning (Muggleton et al. 2018). Ultra-strong machine learning
according to Michie requires a machine learning approach to teach the learned model
to a human, whose performance is consequently increased to a level beyond that of the
human studying the training data alone. In Muggleton et al. (2018) this characteristics

Contrastive Explanations for Inductive Logic Programming

3

Fig. 1: An example family tree. Rectangles denote male persons, ellipses denote female persons,
and solid arrows denote the parent relation. The bold solid arrows indicate a trace for a positive
example. Non-solid arrows indicate near miss explanations.

has been related to the comprehensibility of learned rules or explanations: Comprehen-
sibility has been deﬁned such that a human who is presented with this information is
able to classify new instances of the given domain correctly.

For ILP as well as for other relational learners such as DNCs, verbal explanations
can be helpful to make a system decision transparent and comprehensible. For example,
it can be explained why grandfather(ian, kate) holds by presenting the relations on
the path from ian to kate in the family tree given in Figure 1: Ian is a grandfather of
Kate because Ian is male and Ian is the father of Tom and Tom is the father of Kate. Al-
ternatively, it might be helpful for understanding the concept grandfather to present
a contrastive example in form of a near miss explanation. For instance, Jodie is NOT
the grandfather of Kate because she is NOT male or Mat is NOT the grandfather of Ian
because he is in a child-of-child relation to Ian and NOT in a parent-of-parent relation.
The ﬁrst near miss corresponds to the concept of a grandmother, emphasizing the im-
portance of the attribute male for grandfather. The second near miss corresponds
to the concept of a grandson, emphasizing the importance of the relation parent. To
our knowledge, generating such near miss examples to explain learned relational con-
cepts has not been investigated yet – neither in the context of ILP nor for other machine
learning approaches.

In the following, we discuss the function of near miss examples. Afterwards, we
present an algorithmic approach to generate near miss examples in the context of ILP
and demonstrate the approach for a generic family domain, a visual domain and a real
world domain dealing with ﬁle management (Siebers and Schmid 2019). Finally, we
present an empirical evaluation with human participants where we compare human pref-
erences of different types of explanations for the family and the arch domain, namely

4

J. Rabold et al.

Fig. 2: Duality of learning and explaining

rule-based global explanations, example-based explanations, as well as near miss and
far miss contrastive explanations.

2 The Function of Near Miss Examples

Near miss examples have been introduced by Winston as a human-like strategy to ma-
chine learning (Winston 1970): A near miss example for a concept is an example which
does not belong to the concept but has a strong overlap to positive examples. Such near
miss examples are helpful to guide the model construction of a machine learning algo-
rithm (Telle et al. 2019). Winston illustrated learning with near misses in the context of
relational visual domains. Concepts are represented as compounds of primitive blocks
such as cubes. For instance, positive examples for arches must consist of at least two
objects playing the role of supporters (pillars) and another object on top of them (roof).
Negative examples for an arch might be a tower of several cubes – a far miss – or two
pillars with no space between them covered by a roof – a near miss.

In the context of machine learning of relational concepts such as Winston’s arches,
molecules (King et al. 1996), or Turing-complete languages (Telle et al. 2019), carefully
constructed near misses given as negative examples can speed up learning considerably
(see Figure 2.a). In this case, the machine learning expert plays a role similar to that
of a school teacher who identiﬁes helpful examples (Schmid et al. 2003). We propose
that what is effective for learning is also effective for explaining a learned model (see
Figure 2.b): for some concept that an AI system has learned, it can explain its model by

Contrastive Explanations for Inductive Logic Programming

5

constructing a near miss example. While machine learning typically is unidirectional
– the human provides the training examples and the system generalizes a model – ex-
planations can support interactive machine learning scenarios based on a bidirectional
partnership between human and AI system (Nguyen et al. 2018).

While there are some considerations about what constitutes helpful examples in ed-
ucational psychology (Gentner et al. 2003) and the insights given in Winston’s seminar
work (Winston 1970), there exist no general principles to construct helpful near miss
explanations. We base our algorithm presented in the next section on some general ob-
servations which we will illustrate with the family domain example of Figure 1.

3 Near Miss Explanations

In the following, we will introduce the GENME algorithm for generating near miss
explanations. Our approach extends the comprehensible machine learning approach
ILP (Muggleton et al. 2018) with a contrastive explanation component. First, we will
introduce the basic notation and basic concepts of ILP. The concept of a near miss
explanation is introduced formally and the generation algorithm is presented.

3.1 Notation

We introduce basic notation for ﬁrst-order logic theories based on the clause form un-
derlying the logic programming language Prolog (Sterling and Shapiro 1994). Follow-
ing Prolog’s notational conventions, variables, constants and predicate symbols are rep-
resented as strings of letters, numbers, and underscores where variables must start with
an upper case letter and constants and predicate symbols with a lower case letter. The
arity of a predicate symbol is the number of arguments it takes. A predicate is called
attribute if it has arity one and relation otherwise.

Every variable as well as every constant is a term. We call constants ground terms.
A predicate symbol of arity n followed by a bracketed n-tuple of terms is called
atom, or positive literal. Function sym(A) returns the predicate symbol of atom A. The
negation of an atom is called negative literal. The negation symbol is ¬. A literal is
ground if all terms in its n-tuple are ground.

A clause is an implication where the antecedent is a set of literals and the consequent
is an atom. We write the implication reversed, as H ← {L1, . . . , Lm}. The consequent of
a clause C is called its head, head(C). Its antecedent is called the body of the clause,
body(C). For convenience, we may omit the braces surrounding the body. If the body
of clause C is the empty set, H ← {}, we call C a fact, omit the antecedents, and simply
write H. A clause is called ground when all its literals are ground. A set of clauses is
called a (clausal) theory.

A substitution is a mapping from variables to terms. We denote a substitution θ by
{x1 (cid:55)→ t1, . . . , xk (cid:55)→ tk} where x1, . . . , xk are variables and t1, . . . ,tk are terms. A substi-
tution is applied to a term by simultaneously replacing all xi in the term by the corre-
sponding ti’s. A substitution is applied to a literal by applying it to all terms in the literal.
A substitution is applied to a clause by applying it to all literals in the clause. We denote
the application of the substitution θ to a term, literal, or clause X by Xθ . If a literal or

6

J. Rabold et al.

Background Knowledge:

parent(jodie, becky)
parent(jodie, tom)
parent(ian, becky)

female(jodie)
female(lynn)
female(becky)
female(charlie) parent(ian, tom)
female(alison) parent(alan, charlie)
female(kate)
male(ian)
male(alan)
male(alan)
male(tom)
male(mat)

parent(alan, alison)
parent(lynn, charlie)
parent(lynn, alison)
parent(tom, mat)
parent(tom, kate)
parent(charlie, mat)
parent(charlie, kate)

Selection of positive examples:
grandfather(ian, kate)
grandfather(alan, mat)
Selection of negative examples:
grandfather(alan, tom)
grandfather(jodie, mat)

Fig. 3: Background knowledge for the family domain together with a selection of positive and
negative examples for the grandfather concept.

a set of literals K is true given a clausal theory T , we say that T models K, or T |= K.
Theory T models an atom A if there exists a clause C ∈ T and a substitution θ such
that A = head(Cθ ) and T |= body(Cθ ). Using negation by failure, a clausal theory T
models a negative literal ¬A if T does not model A, T (cid:54)|= A. A theory T models a set of
literals {L1, . . . , Ln} if there is a substitution θ such that T models Liθ for 1 ≤ i ≤ n. By
deﬁnition, the empty set {} is modeled by any theory.

3.2 Basic Concepts of ILP

ILP is a sub-ﬁeld of symbolic machine learning which deals with learning clausal the-
ories from examples (Muggleton and De Raedt 1994). Such clausal theories allow to
represent relational concepts where either the target deﬁnes a relation (i.e. has more
than one argument) or the target is deﬁned over relational structures such as Winston’s
arches. For instance, a theory for grandfather can be learned from positive exam-
ples, such as grandfather(ian, kate), and negative examples, such as
grandfather(alan,tom) (see Figure 3). Positive and negative examples for the tar-
get concept are represented as ground atoms. Additionally, a background knowledge
theory is provided. In the family domain, the facts parent(tom, kate) and male(ian)
can be part of the background knowledge. The learned theory together with the back-
ground knowledge theory must model all positive examples and no negative examples.
Assume the learned theory for grandfather consisting of a single clause,

grandfather(A, B) ←male(A),

parent(A,C),
parent(C, B).

(1)

Contrastive Explanations for Inductive Logic Programming

7

In general, a learned theory can include several clauses characterizing the target con-
cept. For example, the target concept grandparent can be described by a set of
clauses taking into account the genders of the respective parents. It can also be the case
that target clauses are not exclusive. That is, a positive example P might follow from
multiple clauses.

With the learned theory, new instances given as ground atoms can be classiﬁed. For

example, grandfather(alan, kate) will be classiﬁed as positive;
grandfather(becky,tom) will be classiﬁed as negative.

3.3 Near Miss Examples and Explanations

Such positive classiﬁed instances are modeled by the learned theory as introduced
in Subsection 3.1. As mentioned above, theory T consists of predeﬁned background
clauses and clauses learned for the target concept. For example, the grandfather
relation holds for ian and kate given the theory in Equation 1 together with background
knowledge about parent relations and the gender of persons in a given family domain
as the one shown in Figure 3. An explanation for this fact has to make explicit how this
can be derived from the theory. The reason why grandfather(ian, kate) holds is that
ian is male and ian is a parent of tom and tom is a parent of kate. In general, we call an
explanation for a positive example local explanation:

Deﬁnition 1 (Local Explanation). A local explanation for a positive example P is a
ground clause Cθ where C ∈ T such that P = head(Cθ ) and T |= body(Cθ ).

To emphasize which information is crucial for making someone a grandfather of
someone else, a near miss explanation might be helpful. As argued in Section 2, a
near miss example is not a positive instance for the target concept, but illustrates a
semantically similar concept. For example given the positive example
grandfather(ian, kate), possible near miss examples could be the female parent of
a parent (that is the grandmother) of kate or a male child of a child (that is a grandson)
of ian. Formally, we deﬁne near miss explanations and near miss examples:

Deﬁnition 2 (Near Miss Explanation). Given a local explanation Cθ and a mini-
mally changed clause C(cid:48) with substitution θ , we call C(cid:48)θ (cid:48) a near miss explanation and
∆ head(C(cid:48)θ (cid:48)) a near miss example if T |= body(C(cid:48)θ (cid:48)), T (cid:54)|= head(C(cid:48)θ (cid:48)). ∆ is marking
literals as near miss examples.

What constitutes a minimal changed clause is domain dependent. In general, we
understand changing a clause as replacing literals in its body by different literals. The
most basic change is replacing a single literal by its negation. For example, the at-
tribute male could be changed to ¬male; the relation parent could be changed to
¬parent. In a geometric domain, an attribute large could be changed to ¬large;
a relation above could be changed to ¬above. However, such negations are too un-
speciﬁc for many domains. In a more ﬁne-grained geometry domain, ¬large could
mean small or medium. Therefore, we propose that it is helpful to deﬁne pairs of
semantically opposing predicate symbols, for example inverses, in T when modeling a

8

J. Rabold et al.

particular domain. In natural language semantics, such relational opposites are one of
the basic relations between lexical units (Palmer 1981).

In the family domain, the pairs male/female and parent/child are semantic

opponents. To explain grandfather(ian, kate), the near miss example
∆ grandfather( jodie, kate) (which is actually the grandmother) can be derived by
replacing male(A) with female(A) in Equation 1. An alternative near miss can be de-
rived by inverting the parent relation to child. Because grandfather relies on
the transitive sequence of two parent relations, both occurrences should be replaced,
resulting in ∆ grandfather(mat, ian) (which should actually read grandson(mat, ian)).
Depending on the domain, a minimal change of a clause C might therefore consist
of either replacing a single literal or multiple literals. Which literals may be replaced
may also depend on the semantic opponents involved. Thus, we introduce domain de-
pendent rewriting ﬁlters Vp(cid:55)→q to formalize this connection. Vp(cid:55)→q(B) extracts all valid
literal sets from clause body B, such that the predicate symbol p may be replaced by
predicate symbol q in those literal sets. For example, Vmale(cid:55)→female applied to the body
of Equation 1 yields (cid:8){male(A)}(cid:9) and Vparent(cid:55)→child applied to the body of Equa-
tion 1 yields
(cid:8){parent(A,C), parent(C, B)}(cid:9). That is, either male may be replaced (by female)
or both parent’s (by child). These rewriting ﬁlters can be selected by the respective
user of the algorithm.

As the head of a clause is never changed, head(C) = head(C(cid:48)), θ (cid:48) must be dif-
ferent from θ for each near miss explanation C(cid:48)θ (cid:48) w.r.t. local explanation Cθ . Other-
wise, the near miss example would be identical to the positive example, head(C(cid:48)θ (cid:48)) =
head(Cθ ) = P, which is by deﬁnition not a near miss example (T |= P). Based on this
change we deﬁne the degree of a near miss explanation:

Deﬁnition 3 (Degree of Near Miss Explanation). Given a near miss explanation C(cid:48)θ (cid:48)
w.r.t. local explanation Cθ , the degree n of the near miss explanation is the number of
changed replacements, n = |θ \ θ (cid:48)|.

In our approach, we derive near miss examples rather than counterfactuals. That
is, near misses must be deﬁned over constants in the background knowledge. It is not
possible to invent new constants. Thus, we can deﬁne possible near miss examples, that
is near miss candidates:

Deﬁnition 4 (Near miss candidate). A near miss candidate for a positive example P is
a ground atom N which has the same predicate symbol as P, sym(N) = sym(P), but is
not modeled by the theory T , T (cid:54)|= N.

3.4 Algorithm

To generate near miss explanations we introduce GENME (Algorithm 1). Given a pos-
itive example P represented as a ground atom, a domain theory T given as a set of
clauses modeling the target concept together with clauses that describe the application
domain, and a set of rewriting ﬁlters O, GENME returns a set of sets of near miss ex-
amples (Ed). Each element of (E ) contains near miss explanations of a given degree d,
inducing a partial ordering over counterexamples in relation to instance P.

Contrastive Explanations for Inductive Logic Programming

9

Algorithm 1 GENME: The Near Miss Explanation Generation Algorithm

for all Vp(cid:55)→q ∈ O do

for all L ∈ Vp(cid:55)→q(body(C)) do

d ← 0
E (cid:48) ← {}
while E (cid:48) = {} and d < |θ | do

C(cid:48) ← (cid:0) head(C) ← (body(C) \ L ∪ rename(L , p, q)) (cid:1)
for all N ∈ N do

Require: Positive Example P, Theory T , Set of rewriting ﬁlters O
1: Initialize family of result sets (Ei) to empty sets
2: N ← {N | sym(N) = sym(P), T (cid:54)|= N}
3: for all C ∈ T and local explanations Cθ for P do
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20: end for
21: return (Ei)

d ← d + 1
for all θ (cid:48) such that |θ \ θ (cid:48)| = d do

end for
end while
Ed ← Ed ∪ E (cid:48)

end for

end for

end for

E (cid:48) ← E (cid:48) ∪ {C(cid:48)θ (cid:48) | T |= body(C(cid:48)θ (cid:48)) and head(C(cid:48)θ (cid:48)) = N}

To generate all near miss examples for the given positive example, GENME ﬁrst
generates the set of all near miss candidates and then iterates over all local explanations.
To make sure that our algorithm terminates, we only allow near miss candidates that are
ground with constants already present in the domain. For each local explanation, we
iterate over all valid literal sets (line 4 and 5) to generate a minimally changed clause
C(cid:48) by renaming predicate symbol p to o (line 6 applying Algorithm 2).

For each such minimally changed clause C(cid:48), GENME iterates over all near miss can-
didates (line 7) and all possible substitutions θ (cid:48) in increasing distance from θ (lines 10–
12). If there are substitutions θ (cid:48) such that head(C(cid:48)θ (cid:48)) equals the near miss candidate and
the theory models body(C(cid:48)θ (cid:48)) for a given distance (line 13) we add all near miss expla-
nations for this distance to Ed (lines 13 and 16). As soon as one near miss explanation
E (cid:48) for the given d is found, we continue with the next near miss candidate N ∈ N .

3.5 Termination, Time Complexity and Implementation Details

The four nested for all loops in GENME (starting in lines 3, 4, 5 and 7) all iterate over
ﬁnite sets and therefore are guaranteed to terminate. The while loop (starting in line 10)
with the included for all loop is eventually terminated when we reach a degree that
coincides with the magnitude of the substitution |θ |.

GENME is correct in the sense that it does not output explanations that are positive
examples for the given theory. This is achieved by only considering rule heads that are
not modeled by the theory. Also the algorithm is guaranteed to ﬁnd the miss explana-

10

J. Rabold et al.

if L = p(a1, . . . , an) then

Algorithm 2 rename: Replace predicate symbol in a set of literals by opponent
Require: Set of literals L , Predicate symbols p, o
1: L (cid:48) ← {}
2: for all L ∈ L do
3:
4:
5:
6:
end if
7:
8: end for
9: return L (cid:48)

L (cid:48) ← L (cid:48) ∪ {o(a1, . . . , an)}
else if L = ¬p(a1, . . . , an) then
L (cid:48) ← L (cid:48) ∪ {¬o(a1, . . . , an)}

tions with lowest degree d for a given minimally changed clause C(cid:48) since we iteratively
increment d and exit the search as soon as we ﬁnd a miss explanation for C(cid:48).

In its given explicit, non-optimized realization, Algorithm 1 has a time complexity
dependent on the number of constants C in the background theory. The number of
C ∈ T and the number of Vp(cid:55)→q ∈ O has a linear impact on runtime. The upper bound
for the number of N is given by the magnitude of the Cartesian product C n where n
denotes the arity of the target literal. The upper bound is reached when no grounding
for the target literal is modeled by theory T .

The algorithm iterates over N ∈ N and tests if a substitution θ (cid:48) can be found for
the minimally changed clause C(cid:48) such that T |= body(C(cid:48)θ (cid:48)) and head(C(cid:48)θ (cid:48)) = N. The
algorithm ﬁrst tries to ﬁnd a near miss explanation by testing a θ (cid:48) where only one
substitution rule is different from the original θ (d = 1). If no near miss explanation
is found, the degree d is gradually incremented until a near miss explanation is found
or d reaches |θ |. For a given d the number of possible combinations of substitution
rules to change in θ is given by (cid:0)|θ |
(cid:1). For each rule the number of new terms to use
d
as substitute is given by C − 1. The number of possible θ (cid:48) for a given d is therefore
(cid:1) · (|C | − 1)d. For the family domain the numbers would be |θ | = 3 and
given by (cid:0)|θ |
d
(cid:1) · (|C | − 1)d = 999
|C | = 10. The respective runs for all d’s would add up to ∑3
altered substitutions that would have to be checked.

(cid:0)|θ |
d

d=1

The inefﬁciency of the algorithm is mainly due to its unsophisticated ﬁltering strat-
egy. For an implementation, this can be realized more efﬁciently by realizing the fol-
lowing considerations: Since we are only interested in misses, we can constrain the
substitutions for variables occurring in the head of C(cid:48) to the ones dictated by the cur-
rent N ∈ N . When we also check the equality of head(C(cid:48)θ (cid:48)) and N before we check
T |= body(C(cid:48)θ (cid:48)) we can safely continue with the next θ (cid:48). Additionally the user can be
featured with the possibility to label particular constants in the local explanation as im-
mutable. This way the labeled constants will not be part of the search for alternative
substitutions θ (cid:48) which can improve overall efﬁciency. An efﬁciency boost can also be
reached by choosing rewriting ﬁlters that make sense in the chosen domain and that are
also occurring in T .

Contrastive Explanations for Inductive Logic Programming

11

Table 1: Number of found near miss explanations by degree in the family domain. N denotes
the set of all near miss candidates, Ed the set of near miss explanations of degree d, gf the
grandfather relation, and dt the daughter relation. x ↔ y denotes the use of Vx(cid:55)→y or
Vy(cid:55)→x, respectively.

gf(ian, kate) dt(becky, jodie)

|N | = 96

|N | = 92

male ↔ female
|E1|
|E2|
|E3|
parent ↔ child
|E1|
|E2|
|E3|

1
2
1

0
2
2

1
3
0

0
6
0

4 Application to Example Domains

In the following subsections we show that GENME generates plausible near miss ex-
planations. We present the results of applying the algorithm to different domains: a
generic family domain constituted by abstract family relations such as grandfather, a
relational visual domain of blocksworld arches, and a real world domain dealing with
ﬁle management.

4.1 Family Domain

The family domain models parent-child relations between persons. This domain is rep-
resented by attributes male and female, and relations parent and child. In Fig-
ure 3 the background clauses of the theory (excluding the child relation, which is the
inverse of parent) are stated. Additionally, the theory contains the two clauses from
Equations 1 and 2.

daughter(A, B) ← female(A), child(A, B)

(2)

Given this domain, we use GENME to explain the positive examples

P1 = grandfather(ian, kate) and P2 = daughter(becky, jodie). We provide four
rewriting ﬁlters: Vmale(cid:55)→female, Vfemale(cid:55)→male, Vparent(cid:55)→child, and
Vchild(cid:55)→parent, where the ﬁrst two ﬁlters allow changing a single occurrence of the
predicate and the second ones require changing all occurrences.

Out of the 96 candidates for P1, GENME identiﬁes 8 as near miss examples (8.3 %,

see Table 1). The near miss explanation with the lowest degree of 1 is
grandfather( jodie, kate) ← female( jodie), parent( jodie,tom),
parent(tom, kate). Indeed, this is intuitively a very close near miss example (the
grandmother of kate). Also for P2, GENME ﬁnds an intuitively very close near miss
explanation ( jodie’s son) as solitary near miss explanation with lowest degree,

12

J. Rabold et al.

Background Knowledge:

contains(struct5, a2)
contains(struct5, b)
contains(struct5, c)

contains(struct4, a1)
contains(struct4, b)
contains(struct4, c)

contains(struct1, a1)
contains(struct1, b)
contains(struct1, c)
supports(b, a1, struct1) supports(b, a1, struct4)
supports(c, a1, struct1) supports(c, a1, struct4)
not meets(b, c, struct1) meets(b, c, struct4)
contains(struct2, a1)
contains(struct2, b)
contains(struct2, c)
supports(b, a1, struct2) supports(a2, b, struct5)
supports(c, a1, struct2) supports(a2, c, struct5)
not meets(b, c, struct2) not meets(b, c, struct5)
contains(struct3, a1)
contains(struct3, b)
contains(struct3, c)
supports(b, a1, struct3) supports(b, a2, struct6)
supports(c, a1, struct3) supports(c, a2, struct6
not meets(b, c, struct3) meets(b, c, struct6)
supported by(X, Y, A) ← ¬supports(Y, X, A)

contains(struct6, a2)
contains(struct6, b)
contains(struct6, c)

Fig. 4: Background knowledge for the Winston arches domain.

daughter(tom, jodie) ← male(tom), child(tom, jodie). In total, GENME identi-
ﬁes 10 out of 92 candidates for P2 as near miss examples (10.9 %).

For both minimal near miss examples, male was replaced by female or vice
versa. Also for the inverse relations of parent or child, plausible near misses were
found: for instance, that mat is the grandson of ian and jodie is the mother of becky.
Both near miss examples have degree 2, illustrating that they are not as near as the near
miss examples given above.

4.2 The Winston Arches

The Winston arches visual domain models structural relations of building blocks. The
domain features relations contains (a structure contains a block), supports (a
block supports another block), (not )meets (two blocks do (not) meet horizontally)
and is a (a block has a certain shape; the shape can either be wedge or brick).
Figure 4 states the background clauses for the domain. Figure 5 additionally visualized
the positive and negative examples for the concept arch. We further assume the learned
concept for arch in Equation 3.

arch(A) ←contains(A, X), contains(A,Y ), contains(A, Z),

is a(X, wedge), is a(Y, brick), is a(Z, brick),
supports(Y, X, A), supports(Z, X, A),
not meets(Y, Z, A)

(3)

Contrastive Explanations for Inductive Logic Programming

13

Fig. 5: The positive and negative example structures for the Winston arches domain.

When using GENME with this domain we introduced a small change for handling
constants that are contained in the theory (e.g. wedge, brick in Equation 3). In order to
ﬁnd alternative substitutions θ (cid:48) for this constants, we changed them to unique variables
before we applied GENME.

With the positive example arch(struct1) and the rewriting ﬁlters
Vsupports(cid:55)→supported by, Vsupported by(cid:55)→supports, Vmeets(cid:55)→not meets, and
Vnot meets(cid:55)→meets that change all occurrences, GENME yields the following near miss
explanation with degree d = 1:

arch(struct4) ←contains(struct4, a1), contains(struct4, b), contains(struct4, c),

is a(a1, wedge), is a(b, brick), is a(c, brick),
supports(b, a1, struct4), supports(c, a1, struct4),
meets(b, c, struct4)

∆ arch(struct4) is in fact a plausible near miss example since the only feature
that has changed is the closure of the passage between the pillars. The wedge roof is a
feature from the positive example that also holds for the miss.

Other explanations are found for d = 3:

arch(struct6) ←contains(struct6, a2), contains(struct6, b), contains(struct6, c),

is a(a2, brick), is a(b, brick), is a(c, brick),
supports(b, a2, struct6), supports(c, a2, struct6),
meets(b, c, struct6)

14

J. Rabold et al.

Table 2: Number of found near miss explanations by degree in the Winston arches domain. N
denotes the set of all near miss candidates, Ed the set of near miss explanations of degree d. x ↔ y
denotes the use of Vx(cid:55)→y or Vy(cid:55)→x, respectively.

arch(struct1)
|N | = 3

meets ↔ not meets
|E1|
|E2|
|E3|
supports ↔ supported by
|E1|
|E2|
|E3|

1
0
1

0
0
1

arch(struct5) ←contains(struct5, a2), contains(struct5, b), contains(struct5, c),

is a(a2, brick), is a(b, brick), is a(c, brick),
supported by(b, a2, struct5), supported by(c, a2, struct5),
not meets(b, c, struct5)

The former explanation features the far miss example ∆ arch(struct6) where not
only the two pillars meet, but also the roof got a new shape. The latter explanation
deals with the fact that ∆ arch(struct5) turns around the supports relation between
pillars and roof. Both miss examples are farther away from the used positive example
and might not be that helpful in explaining what an arch is.

Table 2 shows the number of near misses GENME found for the different rewriting

ﬁlters.

4.3 File Management

The purpose of the ﬁle management domain is to identify irrelevant ﬁles, that is ﬁles
that may be deleted by the user (see (Siebers and Schmid 2019)). For this, a ﬁle system
with related ﬁles and folders is modeled. The domain is represented by relations such
as
creation time, file size, file name, and media type. Figure 6 shows an
excerpt of the background clauses of the theory for a randomly generated ﬁle system.
Additionally, the theory contains clauses for several auxiliary relations, such as older,
larger, and in same folder. To facilitate matters, we assume that the learned
irrelevancy concept is formalized in a single clause (see Equation 4).

irrelevant(F) ←in same folder(F, G),

media type(M, F),
media type(M, G),
older(F, G)

(4)

Contrastive Explanations for Inductive Logic Programming

15

Background Knowledge:

file(file10)
file name(’1fTmw4WN.PNG’, file10)
media type(png, file10)
file size(6902, file10)
creation time(’1984-12-18’, file10)

file(file11)
file name(’Sv4Xy5n6.PNG’, file11)
media type(png, file11)
file size(12287, file11)
creation time(’1996-12-20’, file11)
Selection of positive examples:
irrelevant(file10)
irrelevant(file11)
Selection of negative examples:
irrelevant(file121)
irrelevant(file168)

Fig. 6: Excerpt of background knowledge for the ﬁle management domain together with a selec-
tion of positive and negative examples for the irrelevant concept.

Table 3: Number of found near miss explanations by degree in the ﬁle management domain. N
denotes the set of all near miss candidates, Ed the set of near miss explanations of degree d and
irr the irrelevant concept. x ↔ y denotes the use of Vx(cid:55)→y or Vy(cid:55)→x, respectively.

irr( f ile10) irr( f ile112)
|N | = 80

|N | = 80

older ↔ newer
|E1|
|E2|
|E3|

1
19
48

1
8
59

We use GENME to explain two arbitrary positive examples,

irrelevant( f ile10) and irrelevant( f ile112). As for the family domain, we
provide rewriting ﬁlters Volder(cid:55)→newer and Vnewer(cid:55)→older where both allow changing
a single literal.

As shown in Table 3, GENME identiﬁes 68 near miss candidates as near miss exam-
ples for both examples (85.0 %). Nevertheless, a single near miss example is identiﬁed
as nearest example (degree 1) for each example. Both are ﬁles of the same media type
in the same folder which are newer than the ﬁle from the example.

5 Empirical Study of Human Preferences of Explanation Types

To investigate whether near miss explanations are considered useful by humans, we
conducted an empirical study on preferences of explanation modalities for the abstract
relational family domain and the visual relational arches domain. For both domains, a

16

J. Rabold et al.

cover story has been given and participants had to evaluate the helpfulness of explana-
tions given this setting which is described in the following subsections.
Overall, four different types of explanations have been considered:

– General rule (R): a global explanation of the concept a speciﬁc instance belongs

to,

– Example (E): an example-based explanation in form of a speciﬁc instance belong-

ing to the concept,

– Near Miss (N): a contrastive example which has a high degree of structural simi-

larity to the speciﬁc instance under consideration,

– Far Miss (F): a negative example for the considered concept which has a low

degree of structural similarity to the speciﬁc instance under consideration.

All explanations were presented in form of natural language sentences. Such natural
language explanations can be generated from ILP learned rules in a straight-forwards
manner (Siebers and Schmid 2019).

These four types of explanations address different information needs (Miller 2019):
To understand the general concept, a global rule can be assumed to be especially help-
ful. However, it might be the case that the helpfulness is different for abstract in contrast
to visual domains. In the second case, a visual prototype might be more effective (Gu-
rumoorthy et al.). In cognitive psychology, visual prototypes have been shown to be an
effective means of concept representation for basic categories (Rosch 1979). For simple
domains, an arbitrary instance might convey information similar to a prototype. For in-
stance, in medical text books, example images are given to illustrate what a speciﬁc skin
disease looks like. A near miss example should be especially helpful to highlight what
(missing) information would be necessary to make an object belong to a class (Gen-
tner and Markman 1994). This is often helpful, if feature values or relations are hard to
grasp. For instance, mushroom pickers use images to distinguish an edible mushroom
from the visually most similar toadstool. Arbitrary negative examples, especially far
misses can be assumed to be less helpful to understand a concept or why a speciﬁc in-
stance belongs to a concept. This type of explanation has been introduced as a baseline.
We assume that combining different types of explanations can be more effective than
each of these explanations alone. Especially, a combination of a global rule with a near
miss might be most efﬁcient to explain relational concepts.

Given the cover story, the helpfulness of the different types of explanations has
been assessed with a complete pairwise comparisons (Thurstone 1927). In a ﬁrst part of
the study, all pairings of the four explanation types have been presented in a arbitrary
sequence and participants had to evaluate which they found more helpful as an expla-
nation given the cover story. In a second part of the study, pairs of pairs of explanations
have been presented. In a ﬁnal part, the helpfulness of the four explanation types for
different information needs as been assessed explicitly. Participant rated how helpful an
explanation is to understand

– the general concept,
– a particular example instance for the concept,
– what is not in the concept (exclusion).

Contrastive Explanations for Inductive Logic Programming

17

on a scale from 1 to 5 with labels not at all to absolutely.

The study was conducted as an online experiment with 73 participants (42 females,
31 males) with average age 35.72 (min 18, max 64). 43 participants were employed,
27 where students, 2 were self-employed and 1 person was retired. About 50% of the
participants received ﬁrst the family domain followed by the arches domain and the
other half of participants started with the arches followed by the family domain.

Although this is an exploratory study, given the considerations above, we can for-
mulate the following hypotheses: (1) Near miss examples should be preferred over far
miss examples in the pairwise comparisons; (2) Near miss examples should be rated
as the most helpful to understand the boundaries of a given concept; (3) For the visual
domain example-based visual explanations should be preferred over abstract (verbal)
rule-based explanations.

5.1 Results for the Family Domain

The family domain (see Sections 3.2 and 4.1) has been presented with the family tree
of Kate as given in Figure 1 with regular arrows and a legend that does not highlight
miss examples. Participants were asked to imagine a conversation with their friend Kate
who is originating from a native American tribe. She is curious about the different
deﬁnitions of family relations in western culture, since she is not familiar with them
and the deﬁnitions that she grew up with are very different from the participant’s. In
particular, she wants to understand the grandfather relation between Kate and Ian.

The participants were then asked to give their preference on explanations in the

pattern outlined above:

– (R) A grandfather is a male parent of one of your parents.
– (E) One of your parents, Tom, has a male parent called Ian. Ian is your grandfather.
– (N) Jodie, the female parent of your parent Tom is NOT your grandfather; it is your

grandmother.

– (F) Mat, the male child of Tom, who is the child of Ian is NOT the grandfather of

Ian; it is his grandson.

For the six simple explanation pairings we observed the following frequency rank-
ing (rounded relative frequencies in brackets): R (0.43) > E (0.37) > N (0.17) > F
(0.03). The rule for the relational concept was preferred over all other explanation
modalities followed by an example and a miss with lowest degree. We see that for
an abstract relational domain, a rule describing the concepts seems to be more helpful
than stating an example. Nevertheless when having the choice between a miss example
closer to the chosen example or a miss example further away, the participants preferred
the former one conﬁrming the hypothesis that the choice of miss examples is important.
For the second set of 15 the pairwise comparison of pairings of the base explanations
we observed the frequency ranking RE (0.32) > RN (0.21) > EN (0.19) > EF (0.13)
> RF (0.13) > NF (0.02). The rule-example pairing is favored over all other pairings
followed by the rule-low degree miss explanation pairing. Again, a preference for the
rule shows in this abstract domain.

18

J. Rabold et al.

Table 4: Results of the questions on which explanations fulﬁlled which purpose in the family
domain. For each purpose (rows) the mean rating value over all participants is given for each
explanation. Bold numbers highlight the highest value for each purpose.

(R)ule (E)xample (N)ear Miss (F)ar Miss

general
4.97
example 4.14
exclusion 2.95

4.52
4.70
2.62

2.93
2.49
4.30

2.19
2.37
3.67

Table 4 shows the results of the questions on purpose of explanations. The near miss
explanation, although preferred over the far miss explanation, is rather unsuited to un-
derstand the general concept of this abstract relational domain as well as understanding
why a particular example belongs to the concept. For the purpose of understanding the
boundaries of the concept however, the near miss explanation performs best compared
to all other explanations. We therefore postulate that a near miss explanation can help
humans to avoid false positives when making decisions.

5.2 Results for the Arches Domain

The Winston arches domain has been introduced as shown in Figure 5 without the
object labels and with a focus on the arch labeled struct1. Participants were asked
to imagine playing with building blocks with their ﬁve year old son. They want to
show him some new structure called arch given the examples and counterexamples in
Figure 5.

The explanations for the arch domain are:

– (R) An arch consists of two rectangle blocks that do not touch. They support a

triangle block.

– (E) We showed the structure labeled struct1 as a positive example.
– (N) We showed the structure labeled struct4 as a near miss.
– (F) We showed the structure labeled struct6 as a far miss.

The ﬁrst set of six questions yields the frequency ranking E (0.45) > R (0.30) >
N (0.18) > F (0.08). For this visual domain it comes with no surprise that examples
seem to be more helpful for explaining the concept. Also, the near miss explanation is
preferred over the far miss explanation.

The 15 pairing-decisions yield the ranking EN (0.27) > RE (0.25) > EF (0.21) >
RN (0.14) > RF (0.08) > NF (0.04). This time the explanation pair example-near miss
is a clear favorite. It seems that humans ﬁnd stating an example along with a near miss
more helpful for explaining concepts in a visual domain than to only state a positive
example along with the rule that describe the concept. Also, a rule in combination with
a near miss seems to be more helpful than a rule with a miss further away.

Table 5 states the results for the questions on purpose for the arches domain. As
expected, the statement of an example seems to help humans better in understanding
the visual concept than stating a general rule. Surprisingly the rule was better suited to

Contrastive Explanations for Inductive Logic Programming

19

Table 5: Results of the questions on which explanations fulﬁlled which purpose in the arches
domain. For each purpose (rows) the mean rating value over all participants is given for each
explanation. Bold numbers highlight the highest value for each purpose.

(R)ule (E)xample (N)ear Miss (F)ar Miss

general
4.45
example 4.56
exclusion 3.25

4.70
4.27
2.73

2.70
2.74
3.95

2.36
2.38
3.82

understand why a particular example belongs to the concept. Both near and far miss
were better suited to understand what is not in the concept and therefore can be used to
sharpen the boundaries of the given concept.

5.3 Discussion of Empirical Results

Given the presented results, the hypothesis that near miss examples should be preferred
over far miss examples in the pairwise comparisons has been conﬁrmed with one excep-
tion: For the arches domain the combination of example and far miss is rated as being
more helpful as the combination of rule and near miss explanation. In accordance with
the observation that examples are especially helpful as explanations in visual domains,
a positive example together with a negative example for the concept of an arch is an
effective means to indicate what aspects are necessary for a structure to belong to the
concept.

Our hypothesis that near miss examples should be rated as the most helpful to un-
derstand the boundaries of a given concept has been conﬁrmed for the family as well
as for the arches domain. In the arches domain the difference between the helpfulness
ratings of near vs. far miss explanations are not very pronounced while for the family
domain near miss explanations have been rated as much more helpful than far misses.
This ﬁnding might be due to the rather simple category structure of the arches domain
where arbitrary negative examples might be suitable to highlight the relevance of what
is missing to belong to the concept.

The third hypothesis has been conﬁrmed for the helpfulness ratings for the visual
domain. The example has been rated as more helpful as the rule to explain the general
concept. Furthermore the example has been preferred over the rule in the complete
pairwise comparison and the combination of example and near miss example has been
preferred most often.

6 Conclusions and Further Work

We introduced near miss explanations for relational concepts learned with ILP. The
GENME algorithm has been presented which generates contrastive examples with dif-
ferent degrees of nearness to a speciﬁc positive instance for a given concept. The ex-
planations facilitate identifying crucial aspects of the concept. The current version of
GENME relies on checking all candidate examples which is not feasible for domains

20

J. Rabold et al.

with a large number of constants. There, it might be necessary to restrict candidates to
candidates already close to the positive example. One way to achieve this might be con-
sidering similarities within the graph spanned by the constants and predicate relations
in the domain.

In an empirical study we could demonstrate that human rate near miss examples
as helpful, especially in combination with a global rules-based explanation and that
humans evaluate near misses as especially helpful to understand the crucial aspects for
instances which make them belong to a speciﬁc concept.

At the beginning, focus of research on explainable AI (XAI) has been on visual
highlighting of relevant information for blackbox classiﬁers which is mostly of interest
for the model developers (Samek et al. 2019). Recently, there is a growing interest of
explanations for domain experts and end-users (Arrieta et al. 2020; Schmid to appear).
For these groups, it is of special importance that explanations are easily comprehensible
and effectively bring across the most helpful information for a given task. Therefore,
the next challenge of XAI systems will be to consider explanations of different modality
and provide strategies to select the probably most helpful explanation for a given context
Williams and Lombrozo (2010). As cognitive science research suggests (Gentner and
Markman 1994), near miss explanations can play an important role to highlight what
aspects are necessary for an instance to belong to a given class.

Acknowledgements

We thank Sebastian Seufert and Klaus Stein for support with the generation of the of
the domains and for helpful discussions of the near miss algorithm.

Bibliography

A. Adadi and M. Berrada. Peeking inside the black-box: A survey on explainable

artiﬁcial intelligence (XAI). IEEE Access, 6:52138–52160, 2018.

A. B. Arrieta, N. D´ıaz-Rodr´ıguez, J. Del Ser, A. Bennetot, S. Tabik, A. Barbado,
S. Garc´ıa, S. Gil-L´opez, D. Molina, R. Benjamins, et al. Explainable artiﬁcial intelli-
gence (xai): Concepts, taxonomies, opportunities and challenges toward responsible
ai. Information Fusion, 58:82–115, 2020.

J. Bien, R. Tibshirani, et al. Prototype selection for interpretable classiﬁcation. The

Annals of Applied Statistics, 5(4):2403–2424, 2011.

A. Dhurandhar, P.-Y. Chen, R. Luss, C.-C. Tu, P. Ting, K. Shanmugam, and P. Das.
Explanations based on the missing: Towards contrastive explanations with pertinent
negatives. In Advances in Neural Information Processing Systems, pages 592–603,
2018.

U. Ehsan, B. Harrison, L. Chan, and M. O. Riedl. Rationalization: A neural machine
In Proceedings
translation approach to generating natural language explanations.
of the 2018 AAAI/ACM Conference on AI, Ethics, and Society, pages 81–87. ACM,
2018.

D. Gentner and A. B. Markman. Structural alignment in comparison: No difference

without similarity. Psychological science, 5(3):152–158, 1994.

D. Gentner, J. Loewenstein, and L. Thompson. Learning and transfer: A general role

for analogical encoding. Journal of Educational Psychology, 95(2):393, 2003.

A. Graves, G. Wayne, M. Reynolds, T. Harley, I. Danihelka, A. Grabska-Barwi´nska,
S. G. Colmenarejo, E. Grefenstette, T. Ramalho, J. Agapiou, et al. Hybrid computing
using a neural network with dynamic external memory. Nature, 538(7626):471, 2016.
K. S. Gurumoorthy, A. Dhurandhar, G. Cecchi, and C. Aggarwal. Efﬁcient data rep-
resentation by selecting prototypes with importance weights. In IEEE International
Conference on Data Mining (ICDM 2019).

S. M. Kazemi and D. Poole. RelNN: A deep neural model for relational learning. In

Thirty-Second AAAI Conference on Artiﬁcial Intelligence, 2018.

B. Kim, O. Koyejo, R. Khanna, et al. Examples are not enough, learn to criticize!
Criticism for interpretability. In Advances in Neural Information Processing Systems
29: Annual Conference on Neural Information Processing Systems (NeurIPS 2016),
Barcelona, Spain, pages 2280–2288, 2016.

R. D. King, S. H. Muggleton, A. Srinivasan, and M. Sternberg. Structure-activity re-
lationships derived by machine learning: The use of atoms and their bond connec-
tivities to predict mutagenicity by inductive logic programming. Proceedings of the
National Academy of Sciences, 93(1):438–442, 1996.

D. Koller, N. Friedman, S. Dˇzeroski, C. Sutton, A. McCallum, A. Pfeffer, P. Abbeel,
Introduction to statistical relational

M.-F. Wong, D. Heckerman, C. Meek, et al.
learning. MIT press, 2007.

H. Lakkaraju, S. H. Bach, and J. Leskovec. Interpretable decision sets: A joint frame-
work for description and prediction. In Proceedings of the 22nd ACM SIGKDD Inter-

22

J. Rabold et al.

national Conference on Knowledge Discovery and Data Mining, pages 1675–1684.
ACM, 2016.

T. Miller. Explanation in artiﬁcial intelligence: Insights from the social sciences. Artiﬁ-
cial Intelligence, 267:1–38, 2019. https://doi.org/10.1016/j.artint.2018.07.007. URL
https://doi.org/10.1016/j.artint.2018.07.007.

C. Molnar. Interpretable Machine Learning. Lulu.com, 2019.
S. Muggleton and L. De Raedt. Inductive logic programming: Theory and methods.
Journal of Logic Programming, Special Issue on 10 Years of Logic Programming,
19-20:629–679, 1994.

S. H. Muggleton, U. Schmid, C. Zeller, A. Tamaddoni-Nezhad, and T. Besold. Ultra-
strong machine learning: comprehensibility of programs learned with ILP. Machine
Learning, 107:1119–1140, 2018.

A. T. Nguyen, A. Kharosekar, S. Krishnan, S. Krishnan, E. Tate, B. C. Wallace, and
M. Lease. Believe it or not: Designing a human-AI partnership for mixed-initiative
fact-checking. In The 31st Annual ACM Symposium on User Interface Software and
Technology, pages 189–199. ACM, 2018.
F. R. Palmer. Semantics: A new outline, 1981.
J. L. Pollock. The ‘possible worlds’ analysis of counterfactuals. Philosophical Studies,

29(6):469–476, 1976.

M. T. Ribeiro, S. Singh, and C. Guestrin. Why should I trust you?: Explaining the
predictions of any classiﬁer. In Proceedings of the 22nd ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining, pages 1135–1144. ACM,
2016.

E. Rosch. Principles of categorization. In E. Rosch and B. B. Lloyd, editors, Cognition

and Categorization, pages 27–48. L. Erlbaum, Hillsdale, NJ, 1979.

W. Samek, T. Wiegand, and K.-R. M¨uller. Explainable artiﬁcial intelligence: Un-
arXiv preprint

derstanding, visualizing and interpreting deep learning models.
arXiv:1708.08296, 2017.

W. Samek, G. Montavon, A. Vedaldi, L. K. Hansen, and K.-R. M¨uller. Explainable
AI: interpreting, explaining and visualizing deep learning, volume 11700. Springer
Nature, 2019.

U. Schmid.

Interactive learning with mutual explanations in relational domains.

In
S. H. Muggleton and N. Charter, editors, Human-like Machine Intelligence. Oxford
University Press, to appear.

U. Schmid, J. Wirth, and K. Polkehn. A closer look at structural similarity in analogical

transfer. Cognitive Science Quarterly, 3(1):57–89, 2003.

M. Siebers and U. Schmid.

Please delete that! why should I? – Explain-
KI, 33(1):35–44,
https://doi.org/10.1007/s13218-018-0565-5. URL https://doi.org/10.1007/

ing learned irrelevance classiﬁcations of digital objects.
2019.
s13218-018-0565-5.

L. Sterling and E. Y. Shapiro. The art of Prolog: advanced programming techniques.

MIT press, 1994.

M. E. Stickel. A prolog-like inference system for computing minimum-cost abductive
explanations in natural-language interpretation. Annals of Mathematics and Artiﬁcial
Intelligence, 4(1-2):89–105, 1991.

Contrastive Explanations for Inductive Logic Programming

23

J. A. Telle, J. Hern´andez-Orallo, and C. Ferri. The teaching size: Computable teachers
and learners for universal languages. Machine Learning, 108(8-9):1653–1675, 2019.
L. L. Thurstone. A law of comparative judgment. Psychological Review, 34(4):273,

1927.

S. Wachter, B. Mittelstadt, and C. Russell. Counterfactual explanations without open-
ing the black box: automated decisions and the GDPR. Harvard Journal of Law &
Technology, 31(2):2018, 2017.

J. J. Williams and T. Lombrozo. The role of explanation in discovery and generalization:

Evidence from category learning. Cognitive science, 34(5):776–806, 2010.

P. H. Winston. Learning structural descriptions from examples. Technical Report

MIT/LCS/TR-76, MIT, 1970.

