0
2
0
2

p
e
S
3

]
E
S
.
s
c
[

1
v
9
9
3
1
0
.
9
0
0
2
:
v
i
X
r
a

To appear in IEEE Transactions on Visualization and Computer Graphics.

P6: A Declarative Language for Integrating Machine Learning
in Visual Analytics

Jianping Kelvin Li and Kwan-Liu Ma

Abstract—We present P6, a declarative language for building high performance visual analytics systems through its support for
specifying and integrating machine learning and interactive visualization methods. As data analysis methods based on machine
learning and artiﬁcial intelligence continue to advance, a visual analytics solution can leverage these methods for better exploiting large
and complex data. However, integrating machine learning methods with interactive visual analysis is challenging. Existing declarative
programming libraries and toolkits for visualization lack support for coupling machine learning methods. By providing a declarative
language for visual analytics, P6 can empower more developers to create visual analytics applications that combine machine learning
and visualization methods for data analysis and problem solving. Through a variety of example applications, we demonstrate P6’s
capabilities and show the beneﬁts of using declarative speciﬁcations to build visual analytics systems. We also identify and discuss the
research opportunities and challenges for declarative visual analytics.

Index Terms—visual analytics, interactive visualization, machine learning, toolkits, declarative speciﬁcation

1 INTRODUCTION

Visual analytics systems combine interactive visualizations with data
analysis and machine learning methods for empowering people to ana-
lyze, explore, and understand large data [9]. To build a visual analytics
system, developers often need to use multiple programming libraries
and toolkits to develop different visualization and analytics components,
as well as to make them interoperable for supporting interactive visual
analysis. Programming with various libraries and toolkits often involves
different computing languages and environments. For instance, a web-
based visual analytics application can employ JavaScript for interactive
visualizations and Python for machine learning, which need to commu-
nicate in a server-client architecture or cloud computing infrastructure.
In general, building visual analytics systems requires developers to
have not only knowledge in both visualization and machine learning
but also skills for full-stack system development.

Most existing visualization toolkits [4, 44, 45, 53] with declarative
grammars can be used for expressive and rapid speciﬁcations of the
visualization components. However, these declarative toolkits do not
support advanced analytics or machine learning methods. Due to the
lack of a common and uniﬁed method for integrating interactive visual-
izations with machine learning, a declarative programming approach
for visual analytics is missing. With high diversity and complexity in
system development, building visual analytics systems is difﬁcult and
demands signiﬁcant engineering efforts. In addition, the increasing
sizes and complexity in datasets impose more challenges to visual ana-
lytics system developments. Many visual analytics applications need
to process and visualize massive amounts of data, requiring both the
visualization and analytics components to be high performance and
scalable. New toolkits are needed to support building visual analytics
systems.

[28], a declarative visualization toolkit

In our prior work, we developed P4 (Portable Parallel Processing
Pipeline)
for building
GPU-accelerated visualization systems. We have also extended P4 to
develop P5 [29] for supporting parallel progressive visualization. In
this paper, we present P6, a programming toolkit using a declarative
language to build visual analytics systems that can leverage the power

• Jianping Kelvin Li is with University of California at Davis. E-mail:

kelli@ucdavis.edu.

• Kwan-Liu Ma is with University of California at Davis. E-mail:

ma@cs.ucdavis.edu.

Manuscript received xx xxx. 201x; accepted xx xxx. 201x. Date of Publication
xx xxx. 201x; date of current version xx xxx. 201x. For information on
obtaining reprints of this article, please send e-mail to: reprints@ieee.org.
Digital Object Identiﬁer: xx.xxxx/TVCG.201x.xxxxxxx

of machine learning. The design of P6 is motivated by three major
design goals.

Interactive Machine Learning and Visualization. Machine learning
methods are commonly used in visual analytics for facilitating auto-
mated analysis [12, 42]. Interactive visualizations are used in comple-
ment to support human-computer interaction (HCI) and visual analysis.
P6 aims to provide support for implementing both machine learning
and visualization methods, as well as integrating these methods in in-
teractive visual interfaces. The parameters for both machine learning
and visualization methods should also be easily conﬁgured and reﬁned.
Interactive and Scalable systems. Visual analytics demand high per-
formance systems for processing and visualizing large datasets [42, 48,
55]. Visual analytics systems should leverage parallel processors and
distributed computing to facilitate effective HCI and visual analysis
processes. To ensure interactive performance and scalability, appli-
cations created by P6 should be incorporated with high performance
computing techniques for building efﬁcient visual analytics systems.
Declarative Visual Analytics. Declarative grammars prove to be use-
ful for creating interactive visualization applications [44, 45]. Declar-
ative visualization grammars can be extended to support designs and
implementations of visual analytics systems. Researchers and devel-
opers should be allowed to expressively and rapidly specify and reﬁne
design speciﬁcations as transiting from system design and implemen-
tation to deployment. We amid to develop a declarative programming
toolkit for streamlining developments of visual analytics systems.

By addressing the challenges to achieve these goals, we contribute a
declarative language for rapidly specifying the design of visual analytics
systems that integrate machine learning and visualization methods for
interactive visual analysis. For high performance, P6 leverages GPU
computing to accelerate visualization renderings and allows machine
learning computations to be ofﬂoaded to distributed computing systems.
We also contribute a framework that efﬁciently integrates machine
learning methods with interactive visualizations. P6 makes it easy
for researchers and developers to build visual analytics systems and
applications. The current implementation of P6 supports common
machine learning methods, including clustering, dimension reduction,
regression, classiﬁcation, and time-series analysis. We demonstrate the
usefulness of P6 with several case studies and show the beneﬁts of using
a declarative language for designing visual analytics applications.

2 RELATED WORK

Our work is related to design models, system frameworks, and pro-
gramming toolkits for visual analytics.

1

 
 
 
 
 
 
2.1 Visual Analytics Systems

Researchers have developed many models and frameworks for design-
ing visual analytics systems. HCI Models for sense making [38], devel-
oping insights [24], and knowledge generation [43] are useful for high-
level system design considerations. Visualization models and frame-
works [8, 35, 47] are helpful for designing and crafting visual represen-
tations. In addition, interaction models and taxonomies [20, 27, 37, 56]
provide guidance for supporting interactive visualizations and design-
ing visual interfaces. While these models and frameworks are certainly
of great value for providing different levels of design considerations,
effective toolkits for implementing visual analytics systems are lacking.
P6 is designed for allowing developers to easily follow the guidelines
in these models and frameworks to build visual analytics solutions.
By using a well-designed declarative language, P6 provides a uniﬁed
and expressive way to specify components and operations in a visual
analytics system for streamlining the process of system development.
Machine learning algorithms can be leveraged for effective data anal-
ysis, and thus have increasing usages in visual analytics systems [22,42].
The most common machine learning algorithms used with visual ana-
lytics are: dimension reduction, clustering, classiﬁcation, and regres-
sion [12, 25]. Visual analytics systems that employ these methods
typically provide interactive visual interfaces for selecting algorithms,
controlling the parameters of algorithms, deﬁning the measures for
the computations, or deﬁning the analytical expectations [12]. To sup-
port effective incorporation of machine learning into visual analytics
systems, P6 provides many common machine learning algorithms and
allows them to be easily integrated with visualization and interaction
methods.

Besides system functionalities, performance and scalability are also
important to visual analytics [15, 30]. To support interactive perfor-
mance and scalability, researchers have developed methods for exploit-
ing GPU computing to accelerate data processing and visualization
rendering [16, 31, 40]. Some researchers also leveraged distributed
computing to improve system scalability and interactivity [7, 23]. For
visual analytics applications with large datasets, high-performance com-
puting techniques, such as GPU computing and distributed computing,
are required for executing analytics and visualization algorithms [9].
However, leveraging both GPU computing and distributed computing
for visual analytics systems is difﬁcult. Most systems that employ these
techniques are typically implement for speciﬁc algorithms or analysis
tasks using ad-hoc approaches.

In our prior work, we developed P4 to allow declarative visualization
grammar to be used with GPU computing via WebGL. The design of
P4 is based on the InfoVis Pipeline model [8], in which it performs data
transformation, visual mapping, and view transformation to generate
visualizations. Based on the declarative speciﬁcation, P4 automatically
creates efﬁcient WebGL programs at runtime to facilitate interactive
visualizations. To allow declarative speciﬁcation of visual analytics
processes, P6 uses P4 for GPU-accelerated visualization and extends the
declarative grammar to support advanced data analytics with integration
of machine learning methods. P6 also allows data analytics operations
to be ofﬂoaded to a computing cluster for distributed computing.

Researchers have also developed declarative languages for machine
learning [3, 18], which can be used with distributed computing sys-
tems, such as MapReduce [11] and Spark [57], to execute machine
learning algorithms. However, these declarative languages are rather
low-level, as their design goal is to express custom machine learning
algorithms using statistical functions and linear algebra primitives. Be-
sides declarative languages, many programming libraries in Python
provide off-the-shelf functions for applying machine learning algo-
rithms to analyze data, such as Scikit-Learn [36], Statsmodel [46], and
Spark MLlib [33]. In addition, many numerical computing frameworks,
such as Numpy [52] and Pandas [32], can be used for preprocessing
and wrangling data, which is useful for managing the input and output
to/from Python based machine learning libraries. These frameworks
and libraries have made Python popular for machine learning and data
science. However, support for interactive visualization is lacking. Due
to the fact that most interactive visualization libraries are based on
JavaScript and usable machine learning libraries are based on Python,
the most conventional approach to build visual analytics systems is to
use both JavaScript and Python. This requires systems to incorporate
inter-communication protocols between the two computing environ-
ments, such as HTTP or WebSocket over a server-client architecture.
Several Python libraries embed a JavaScript visualization library to
provide a wrapper API for creating interactive visualizations in Python
without writing JavaScript codes. These libraries also implement in-
ternal mechanisms for communicating between Python and JavaScript.
For example, Dash [2] offers interactive chart templates in Python that
use D3 for rendering the charts, and Altair [51] leverages Vega-Lite to
provide a Python API for declarative visualization speciﬁcation. These
libraries allow Python programs to use JavaScript libraries for visualiza-
tions and machine learning libraries in Python for data analysis. These
libraries are also widely used in data science and computational note-
books [26, 39, 41], which recently become a popular medium for data
science. However, this approach cannot be used for building web-based
applications. In addition, these libraries lack support for processing and
visualizing large data, and their internal mechanisms for transferring
data are difﬁcult to be modiﬁed or replaced.

P6 uses a different approach as it is designed for building visual
analytics systems that can be deployed on the web and other platforms.
P6 uses Python based libraries for supporting data analytics operations,
which the functions for different machine learning algorithms can be
used in P6’s declarative language. P6 provides a JavaScript API for web-
based applications, and it supports a JSON ﬁle format for embedding
in other languages or generating speciﬁcations from other systems.
Developers and programmers do not need to write Python codes when
using P6 for building visual analytics systems, nor implementing the
server-client components and communication mechanisms. At runtime,
the declarative speciﬁcations of machine learning and visualization
methods are converted to programs for running on P6’s system with an
efﬁcient mechanism to manage data transfers, inter-communications,
and execution ﬂow. This mechanism also effectively supports the
use GPU computing to accelerate visualization operations and ofﬂoad
machine learning computations to a computing cluster.

2.2 Programming Toolkits for Visual Analytics

3 DECLARATIVE VISUAL ANALYTICS

Declarative visualization grammars based on Wilkinson’s Grammar
of Graphics [54] allow programmers to focus on the design of the
visualization without worrying about the computation details of ren-
dering [19]. Popular visualization libraries and toolkits, such as gg-
plot2 [53] and D3 [4], typically provide declarative grammars for spec-
ifying visual encoding to create visualizations. In addition to visual
encoding, Vega [45] and Vega-Lite [44] provide declarative interaction
grammars for authoring interactive visualizations. Since the web has
become the most popular and convenient platform for deploying ap-
plications, most of these libraries and toolkits are based on JavaScript.
These JavaScript libraries typically have functionalities for simple data
transformations (e.g., ﬁltering and aggregation), but they do not pro-
vide advanced statistical or machine learning methods for data analysis,
nor provide support for integrating machine learning methods with
interactive visualizations.

The core of P6 is a declarative language for specifying and integrating
machine learning and interactive visualizations. This declarative lan-
guage allows P6 to incorporate a reactive workﬂow for implementing
interactive visual interfaces. In addition, P6 uses a uniﬁed data structure
to effectively leverage GPU computing for accelerating visualizations
and supports ofﬂoading machine learning computations to distributed
systems.

3.1 System Framework

The design of P6 is based on a conceptual framework (Fig. 1) that is
simpliﬁed from the knowledge generation model for visual analytics
by Sacha et al. [43]. In this conceptual framework, the Knowledge
Discovery and Data Mining (KDD) Process model [13] is used as the
reference for declarative speciﬁcation of advanced data analysis and
machine learning methods, which includes selection, preprocessing,

2

To appear in IEEE Transactions on Visualization and Computer Graphics.

For a data source, a selection can be speciﬁed for selecting data columns
by data attribute names or sampling data by specifying the number
of data items or rows. The preprocessing operation can be used for
cleaning the data (e.g., dropping null values) and performing numerical
or one-hot encoding for categorical data. The transform operation can
be used for aggregating, ﬁltering, and sorting based on speciﬁc data
ﬁelds.

The example in Fig. 2A shows a declarative pipeline speciﬁcation for
analyzing a dataset containing information about newborn babies and
their parents. In this pipeline, the input data is loaded from a CSV ﬁle,
and two machine learning methods, K-Means Clustering and Principal
Component Analysis (PCA), are used to analyze the data. Two views
are speciﬁed for containing the visualizations. In the ﬁrst view, the
PCA result is shown in a scatter plot, where the color of the dots are
based on the K-Means result. In the second view, a data transformation
is performed to group the data points based on the K-Means result and
visualize a bar chart with each bar representing a group. In addition,
user interactions can be added to the visualization, as shown in Fig. 2C.
With the P6 declarative language, the components of a visual an-
alytics pipeline can be speciﬁed in any order. Multiple analysis, vi-
sualization, and interaction methods can be iteratively added to the
pipeline. P6 determines the execution order based on the dependencies
in the operations. This allows P6 to support the nonlinear and iterative
development process of visual analytics applications.

3.2.1 Data Analysis with Machine Learning

P6 currently supports common machine learning methods for clustering,
dimension reduction, regression, and time-series analysis. An analysis
operation can be speciﬁed as follow:

analysis := {features, scaling, algorithm, [parameters]}

The speciﬁcation begins with deﬁning a new name for the result to be
computed using the chosen machine learning algorithm. The features
option is used for selecting which data attributes to use as the input to
the machine learning algorithm. The scaling option is for scaling the
input features using common methods such as normalization, scaling
In addition, a set of
to unit variance, or scaling to a given range.
parameters can be deﬁned for the chosen algorithm. Fig. 3 shows
another example, in which Agglomerative Clustering is used instead
of K-Means. With Agglomerative Clustering, the number of clusters
does not need to be speciﬁed, because the algorithm determines the
number of clusters based on the distance threshold parameter. The
analysis result of the machine learning technique can be easily used in
visualizations.

In addition to the off-the-shelf machine learning algorithms, models
for classiﬁcation and regression can be trained and deﬁned for predictive
data analysis. A classiﬁcation or regression model can be deﬁned as
follows:

model := {module, method, training-data, target, features, [parame-
ters]}

The module and method specify the system or library function for
building the model. The training-data speciﬁes data for training the
model based on the target, features, and a set of parameters. Fig. 4
provides example speciﬁcations of two regression models based on the
linear regression and random forest methods. The models are trained to
predict the baby birth weights (target) based on the speciﬁed features.
If no features were provided, all the data dimensions and columns
in the training-data are used. To use the trained model in analyses
and visualizations, simply deﬁne a new output name in the analyses
speciﬁcation, and point it to the name of the model. This allows the
model to be used for processing the input data and saving the result
using the output name, as highlighted in purple color in Fig. 4. The
result can be used for visualization by mapping it to a visual channel
in the same way as using data attributes and analysis results. The
training of the model can be done ofﬂine, in which the visual analytics
applications can use the trained model for predictions and analyses
without requiring users to wait.

Fig. 1. The design of the P6 declarative language is based on a concep-
tual framework that consists of the KDD Process model for data analysis
and the InfoVis Pipeline model for visualization.

and transformation of the input data. For visualization, P6 uses P4
to perform the operations in the InfoVis Pipeline model [8], which
can visualize both the data and analysis results. For interactive visual
analysis, user interactions can be added to control both the machine
learning and visualization methods.

To support interactive performance and provide scalability for visual
analytics, P6 employs distributed computing to parallelize data pro-
cessing and machine learning methods. Fig. 2 shows P6’s server-client
architecture, in which the frontend client is for generating visualizations
and the backend server is for processing data and analytics. At runtime,
the P6 compiler converts user-deﬁned speciﬁcations to function calls
that execute in both the client and server. With P6, programmers do
not need to worry about implementing visual analytics operations for
server-client communications. P6 automatically synthesizes requisite
data ﬂow and event logic across the client and server to effectively exe-
cute the operations in the declarative speciﬁcations. For visualization
operations, P6 leverages P4 to create efﬁcient GPU programs based on
the declarative speciﬁcations. For the analyses speciﬁcations, the oper-
ations are converted to API calls to the backend server and retrieve the
results to the frontend. To apply machine learning algorithms on large
datasets, P6 can parallelize and distribute computations on a computer
cluster.

3.2 A Declarative Language for Visual Analytics
The P6 declarative language can be used to rapidly specify data analysis,
visualization, and interaction methods. Common machine learning
methods are supported for data analysis, in which the analysis results
can be easily used with interactive visualizations, The basic unit of
speciﬁcation for P6 is a pipeline. Formally, a pipeline is composed of a
set of speciﬁcations:

pipeline := {data, analyses, view-layout, visualizations, interactions}

The data speciﬁcation identiﬁes a data source for input, which can be
a CSV ﬁle in a local computer or remote server. A set of analyses
can be speciﬁed to be performed on the input data. The view-layout
speciﬁes how to arrange the views that contain the visualizations, which
speciﬁes the encoding for mapping the analyses results and/or the input
data to visual channels. The interactions speciﬁes the interactions to
be enabled on the visualized items, which can be zoom, pan, click,
and hover. In addition, annotations can be speciﬁed to add markers,
such as trend lines and labels, on the views. P6 provides a JavaScript
API for using its declarative language for building web-based visual
analytics applications. Speciﬁcations using the JSON format or ﬁle is
also supported.

The speciﬁcation of the input data to a pipeline follows the KDD
Process model which supports three data processing operations and has
the following syntax:

data := {source, selection, preprocessing, transform}

3

DataRaw DataVisualizationAnalysisResultTabularDataVisual StructureViewsData TransformationVisual MappingView TransformationSelectionPreprocessingData MiningKDD ProcessInfoVis Pipeline(P4)Preprocessed DataPatternsUser InteractionTargeted DataTransformedDataTransformationInfoVis Pipeline(P4)Fig. 2. Declarative speciﬁcation (A) of a visual analytics process that applies K-Means and PCA to analyze a dataset. The declarative speciﬁcation is
processed by P6’s runtime (B). Interaction speciﬁcation (C) can also be added to provide interactive visualizations for analyzing the K-Means and
PCA results, as shown in the scatter plots and bar charts (D).

Fig. 3. Declarative speciﬁcation for using agglomerative clustering with
data transformations and a multi-view layout. The clustering result is
aggregated and ﬁltered to show patterns and trends in a stack of two line
charts.

3.2.2 Integration of Machine Learning and Visualizations

For visualization, the loaded datasets and the analysis results can be
used together to generate multiple linked and interactive views using
the layout deﬁned in the view-layout speciﬁcation. The speciﬁcation of
the visualization in each view can be deﬁned as follows:

view := {transform, mark-type, [encodings]}

Each visualization is speciﬁed by the view index. A set of transforms
can be applied on the loaded data or results from the analyses, includ-
ing match for ﬁltering, derive for calculating new attributes or metrics,
and aggregate for grouping or binning. The mark-type speciﬁes the
primitive geometric object for visually representing the data items. The
properties of these geometric objects are based on a set of encodings
that maps the attributes of the data items to visual channels, including
position (x, y), size, width, height, color, and opacity. In addition to
deﬁning individual visualizations with view indexes, faceted views in
rows or columns can be speciﬁed using the $rows and $cols operator,
respectively. The $select operator can be used to specify the variables
for each of the views in rows or columns. As highlighted in purple in
Fig. 3, the clustering result can be paired with different data attributes
to explore trends and patterns in multiple views arranged in a column
layout. For appending multiple visualization items on the same view,
the visualization speciﬁcation for each view can be an array of spec-
iﬁcations, instead of a single one, as the example shown in Fig. 4.

Fig. 4. Declarative speciﬁcation for training a linear regression model
and a random forest model for predicting the baby weight based on the
parent information (A). The trained models can be used for specifying
analysis and visualization operations in P6 pipelines(B). For visual analy-
sis, additional aggregation can be performed on the prediction results to
show trends and patterns (C).

3.2.3 Tuning Parameters and Visualizing Model Attributes

For creating and training models for predictive analysis, P6 provides
grid search to ﬁnd the best parameter set for classiﬁcation and regres-
sion models. As shown in Fig. 4A, grid search is used to ﬁnd the
best parameter set from the param grid ﬁeld using the r2 score metric.
Other metrics for scoring can be used, such as accuracy and F1 score. In
addition, P6 allows trained models to be saved as ﬁles. At runtime, P6
pipelines can load saved models from ﬁles for predictive analysis tasks.
When using a trained model in visual analysis tasks, the attributes or
metadata of the model can be used for creating visualizations to show
the important aspects of a dataset. Many regression and classiﬁcation
models provide information about the importance of each feature after
training. Fig. 5 shows an example of using the coefﬁcients provided

4

P6let app = p6(config).data({url: 'data/US-Birth.csv'}) .analyze({   clusters: {     algorithm: 'KMeans', n_clusters: 4   },   PC: {     algorithm: 'PCA', n_components: 2   } }) .view({   c1: {width: 360, height: 360},   c2: {width: 360, height: 360, offset: [360, 0]} }) .visualize({   c1: {     mark: 'circle',     x: 'PC1', y: 'PC0',     color: 'clusters',     size: 5, opacity: 0.25   },   c2: {     mark: 'bar',     transform: {       aggregate: {         $group: 'clusters',         $collect: { count: {$count: '*'} }       }     },     y: 'clusters',width: 'count',     color: 'clusters'   } })P6 ClientCompilerP4P6 ServerAnalysis APIData FlowControllerGPUData Transfer...Computing Clusterapp.interact({   event: 'click',   from: 'c2',   response: {     c1: { unselected: {color: 'gray'} },     c2: { unselected: {opacity: 0.25} }   } })ABCDEclustersclusters app.analyze({   clusters: {     algorithm: 'AgglomerativeClustering',     distance_threshold: 2000,     n_clusters: null,     linkage: 'ward'   } }) .visualize({   $rows: {     $select: ['MotherAge', 'FatherAge'],     $transform: {       $aggregate: {         $group: ['$select', 'clusters'],         $collect: {           AvgBabyWeight: {$avg: 'BabyWeight'}         },       },       match: {         $select: [18, 40],         AvgBabyWeight: [6, 9]       },     },     mark: 'spline',     x: '$select', y: 'AvgBabyWeight',     color: 'clusters', size: 2   } }).execute()app.data({url: '/data/Pregnancies.csv'}) .analyze({   Predicted_Weight: '$BabyWeightRegressor1', }) .visualize({   c1: [     {       mark: 'circle', color: 'steelblue',       x: 'MotherWeight', y: 'Predicted_Weight',       size: 8, opacity: 'auto',     },     {       $transform: {         $aggregate: {           $bin: 'MotherWeight',           $collect: {Predicted_Weight: '$avg'}         }       },       mark: 'spline', color: 'red',       x: 'MotherWeight', y: 'Predicted_Weight',       size: 3, opacity: 1     }   ] })RandomForestRegressorLinearRegression app.train({   $BabyWeightRegressor1: {     module: 'linear_model',     method: 'LinearRegression',     data: './Babies.csv', target: 'BabyWeight',         features: [       'MotherWeight','MotherHeight',       'MotherAge', 'MotherRace', ...     ]   } }) app.gridSearch({   $BabyWeightRegressor2: {     module: 'ensemble',     method: 'RandomForestRegressor',     data: './Babies.csv', target: 'BabyWeight'     parameters: {       param_grid: {  max_depth: [2, 3, 4, 5, 6],  n_estimators: [10, 20, 30, 40]       },scoring: 'r2'     }   } })ABCTo appear in IEEE Transactions on Visualization and Computer Graphics.

learning algorithms are the same in the Python libraries and declarative
speciﬁcations. For example, specifying the n clusters for a clustering
algorithm in the declarative speciﬁcation directly passes the same pa-
rameter name to Scikit-Learn at the server-side. At the frontend, P4
is used for GPU-accelerated visualizations, and we use the JavaScript
Proxy API for implementing the reactive workﬂow module to track
changes in the data, analytics, and visualization speciﬁcations, as well
as to trigger the corresponding computations in both the server and
client to update all the views. To leverage distributed computing for
accelerating machine learning algorithms, P6 uses Dask [1], a Python
based distributed computing library, to allow the computations of Scikit-
Learn functions to be ofﬂoaded to a speciﬁed computing cluster.

3.3.1 Input and Output

Visual analytics systems often need to load data from different sources
and mediums. P6 provides support for loading data in JSON or CSV
formats from the server, client (e.g., web browser), and remote loca-
tions (e.g., external servers or web services). For remote locations,
P6 can fetch the data to the server. For loading data from the client
side, P6 sends the data to the server side for executing the speciﬁed
machine learning algorithms and passes the results back to client side
for visualization. For JavaScript applications, the analysis results can
be exported as JSON for use in other web-based libraries. In addition,
the exportAsJson function can be used to export the result to the JSON
format for each operation in the pipeline. Multiple P6 pipelines with
different data inputs can be speciﬁed, and the results of one pipeline can
be used in the other pipeline for additional analyses and visualizations.

3.3.2 Data Flow

To ensure high performance, we have developed an effective data ﬂow
mechanism for managing and transferring data among the P6 client,
server, and computing cluster. To efﬁciently manage and transfer data,
we extend the Pandas DataFrame to implement the P6 DataFrame as
a uniﬁed data structure for data transfer. The P6 DataFrame can be
transferred or streamed as binary data between the client and server
without the need for data rearrangement (i.e., converting to JSON for
transferring). In addition, the P6 DataFrame can be effectively con-
verted to the P6 GPU DataFrame for storing the analysis results in GPU
memory, which allows us to use the same data model for using WebGL
to perform data transformation and visualization operations. The dia-
gram in Fig. 6 (right) shows the data ﬂow that uses the P6 DataFrame.
Based on the data deﬁnition in the declarative speciﬁcation, the data
management module loads the data from the input source to create an
initial DataFrame and send it to the analytics module. The analytics
module performs the speciﬁed machine learning algorithms and ap-
pends the result as additional columns to the same DataFrame. Based
on the visualization speciﬁcation, the visualization module retrieves
the required columns in the DataFrame from the analytics module to
create a GPU DataFrame for GPU-based parallel visualizations. With
P6’s system framework and data ﬂow mechanism, we can effectively
create visual analytics operations at runtime based on the declarative
speciﬁcations. The operations can be efﬁciently run on the backend
server and computing clustering for machine learning computations as
well as leverage WebGL for visualizing massive amounts of data items.

3.4 Extensions

P6 is designed to be ﬂexible and extensible. Both the analysis and
visualization functionalities can be extended. For visualization, cus-
tom chart templates can be added as plugins to P6 for creating custom
plots. P6 provides an extension API for specifying visualization plugins.
The plugins can be used seamlessly with P6’s declarative visualization
grammar, including the GPU-based data transformations for processing
the data before rendering the visualizations. P6 can export the results
of GPU-based transformations to JSON formats that can be used by
other JavaScript visualization libraries. Fig. 7 provides an example of
using the P6 extension API for adding a plugin function that uses D3 to
implement an area chart. The data and view setting are passed as inputs
to the function. The plugin can be used in P6’s declarative visualization
grammar by specifying the mark-type to be ’area’ as deﬁned by the

Fig. 5. P6 allows using the attributes of the trained models for visual-
ization. In this example, the coefﬁcients of a linear regression model
are used to visualize how the predictions vary with the top three most
important features.

by the linear regression model for visualizing three bar charts which
show how the predicted values vary across the top three most important
features. In this case, the top three features for the predicted baby
weights based on the linear regression model are mother race, mother
weight gained, and baby gender. To create visualizations that show the
predicted baby weights over these three features, the $select operator
can be used to get the top three coefﬁcients from the linear regression
model, as shown in the highlighted codes (purple) in Fig. 5.

3.2.4 Reactive Programming Model

In visual analytics applications, users often need to modify or reﬁne
the parameters of the machine learning and visualization methods
through a visual interface or by interacting with the visualizations. For
implementing such user interactions, reactive programming techniques
can be adopted to automatically update the analysis and visualization
results when any parameters were changed. Reactive programming and
workﬂows have been proven to be useful for information visualization
systems [14,15,44]. P6 combines reactive programming and declarative
speciﬁcations for implementing user interface components in visual
analytics applications. For machine learning and visualization methods
deﬁned in the declarative speciﬁcations, properties and parameters of
these methods can be modiﬁed in the program, which automatically
trigger updates to the corresponding operations speciﬁed in the same
pipeline. As the example shown in Fig. 6, changes to the clustering
methods or the method parameters automatically updates the associated
visualizations with the clustering results. This is particularly useful for
implementing user interfaces to be used in visual analytics applications.
As visual analytics applications often need multiple data analysis and
visualization methods, the declarative speciﬁcation often has many
operations deﬁned. Using the reactive programming capability in P6,
the control logic associated with the user interfaces do not need to
modify the reference of the declarative speciﬁcation, as it can directly
link to the parameter of the operations. More details and examples are
provided in our case studies.

3.3 Implementation Details

As P6 uses a server-client architecture, the backend server is imple-
mented using Python, and the frontend client is implemented using
JavaScript and WebGL. The diagram in Fig. 6 shows the system model
of P6. The data management and the analytics module in the backend
are built on top of the Python libraries, Pandas and Scikit-Learn [36].
Pandas is mainly used for loading, preprocessing, and managing data
at the server side, and Scikit-Learn is used for the machine learning
methods. The names of the functions and parameters for the machine

5

 app   .data({url: 'data/Pregnancy.csv'})   .analyze({     PredictedWeight: '$BabyWeightRegressor',   })   .visualize({     $rows: {       $select: {         model: '$BabyWeightRegressor',         attribute: 'coef_',         sort: 'desc',         limit: 3       },       $transform: {         $aggregate: {           $group: '$select',           $collect: {             PredictedWeight: {$avg: 'PredictedWeight'   }           }         }       },       mark: 'bar',       x: '$select',       height: 'PredictedWeight',       color: 'steelblue'     }   })   .execute()Fig. 6. P6’s reactive programming model for automatically updating all visualization views when the parameters were changed in the analysis
and visualization methods. In P6’s system architecture, a reactive workﬂow module is responsible to capturing the changes and notiﬁes the data
management, analytics, and visualization modules to execute the corresponding operations. A uniﬁed data structure is used for transferring data
from the data management module to the analytics module, and sending the analysis result to the visualization module, where the result can be
efﬁciently stored in GPU memory for processing and rendering.

(B), analysts can select the data attributes and sampling size of the
loaded dataset. Optionally, a clustering method can be selected with
custom parameters for analyzing the data along with the dimension
reduction methods. Two drop down menus are provided for selecting
two different dimension reduction methods for projecting the dataset on
the scatter plots. The parallel coordinates plot at the bottom shows all
the selected data attributes with each line representing a data item. The
speciﬁed reactive workﬂow (C) automatically updates the scatter plots
when the selections in the drop down menus are changed. Similarly,
new selections of the data attributes immediately update the projection
results and the parallel coordinates plot. At last, the speciﬁcation of the
brushing-and-linking interaction (D) allows users to ﬁlter data items
in the plots and see the correlations between the two projections. The
interaction on the parallel coordinates plot can be used for selecting
the data items based on the original data attributes, allowing better
interpretation of the dimension reduction results. The data process-
ing and rendering operations associated with the speciﬁed interactions
are accelerated via GPU computing in P6. This allows the system to
support interactive visual analysis of large amounts of visualized data
items.

This application demonstrates that P6 can make the implementation
of visual analytics interfaces easy and fast. The support for reactive
workﬂow is particularly useful to implement UI widgets for changing
the parameters of analysis and visualization methods. Programmers can
use only one line of code for modifying the analysis or visualization
properties in the event handler or callback function for the UI widget.
While this application is designed for trying and comparing different
dimension reduction methods for exploratory data analysis, we can
easily modify it to support comparing models for classiﬁcation or
regression in a similar fashion.

4.2 COVID-19 Global Cases

Visual analytics can allow storytelling and explanatory analysis to better
communicate information and knowledge. In this case, we use the
data source provided by Johns Hopkins University Center for Systems
Science and Engineering for tracking the global numbers of conﬁrmed
COVID-19 cases [10]. To analyze the spread of the virus over time,
we use change point detection [50] for ﬁnding the time points where
the spread rate of COVID-19 have big changes. The Python Ruptures
library [49] is used as a plugin in P6 for change point detection.

The declarative speciﬁcation for using change point detection to
analyze the COVID-19 dataset is shown in Fig. 9A. As presented in

Fig. 7. An example of using P6’s visualization extension API to support
area charts for using in declarative speciﬁcations.

condition property in P6’s extension API. To provide better functionali-
ties for interactive visualizations beyond the capabilities in P4, we have
added support for common charts used for information visualization.
For data analysis, P6 mainly uses Scikit-Learn to support machine
learning methods. Other data analytics and machine learning libraries
that are based on Python and Numpy can also be added as plugins to
P6’s server backend. However, distributed and parallel computing is
not supported for executing the plugins for data analysis, but P6 can
still effectively send the analysis results to the visualization frontend
using P6 DataFrame, which can efﬁciently utilizes the GPU for data
transformations and visualizations.

4 EXAMPLE APPLICATIONS AND CASE STUDIES

In this section, we present example applications and case studies to
demonstrate the capabilities and usefulness of P6 for developing visual
analytics systems.

4.1 User Interface for Exploratory Visual Analysis

In this case study, we evaluate P6’s usefulness for creating visual in-
terfaces for exploratory visual analysis (EVA). An interactive visual
interface is the core component of a visual analytics system. To explore
a dataset, analysts typically need to use multiple machine learning
algorithms as well as compare different analysis methods. We have
developed a visual analytics application using P6 for allowing analysts
to explore data using multiple dimension reduction methods with inter-
active visualizations. Fig. 8 shows the visual interface and dashboard
of the application. A set of initial analysis results and visualization
views are displayed based on the speciﬁcations in (A). Here we show
the same dataset that we used in Sect. 3, but the application can be
used with any multidimensional tabular datasets. In the visual interface

6

VisualizationAnalyticsData ManagementP6 DataFrameReactive WorkflowP6 GPU DataFrameX0….X1X2XnPC0PC1visualize({  ...  x: 'PC0'  y: 'PC1',  color: 'X1'})X1PC0PC1PC: {technique: 'PCA', n_components: 2}GPU Memoryapp.analyses.clusters.n_clusters = 3app.analyses.PC.algorithm = 'Isomap'JavaScript Python  p6.extend({    type: 'visualization', name: 'AreaChart',    condition: {mark: 'area'} ,    function: (data, view) => {      d3.select(...).append(...)      ….    }  })To appear in IEEE Transactions on Visualization and Computer Graphics.

Fig. 8. A visual analytics application for exploratory data analysis developed using P6’s declarative language (A). The dashboard with the speciﬁed
visualizations and visual interface is shown in (B). A reactive programming approach (C) is used to allow the visual interface to automatically update
the analysis results and visualizations. The speciﬁcation of interactions (D) allows users directly select data on the visualizations to better interpret
and understand analysis results based on machine learning.

views in columns. The declarative speciﬁcations of the two pipelines
in Fig. 9 generates the visualizations in Fig. 10. From the line chart
and the choropleth maps, we can see that China has about 30,000
COVID-19 cases on February 6, and the number of cases for all other
countries is small. On March 22, the numbers of COVID-19 cases have
increased globally, where the countries in Europe and North America
have the highest number of new cases. On April 1, the number of new
cases in China is small, and the numbers of cases in the United States,
Spain, and Italy have surpassed China. On April 16, the growth rate of
COVID-19 cases has been slowed for countries in Europe, while the
growth rate for the United States remains about the same.

This application demonstrates that P6 can be useful for leveraging
machine learning and visual analytics for storytelling and generating
explanatory visualizations.

4.3 Visual Analytics for High-Performance Computing

Developing visual analytics systems often requires domain-speciﬁc
knowledge and collaboration with domain experts. We have used P6
to build a visual analytics system for assisting high-performance com-
puting (HPC) researchers to analyze the performance and temporal
behaviors of HPC applications. HPC performance analysis typically
requires exploration of multivariate time-series data for gaining insights
to remove bottlenecks and improve application performance. Various
performance metrics (e.g. CPU and memory usage) at different levels
of granularity (e.g., thread or compute node) are logged in the multivari-
ate time-series data. Prior works for analyzing HPC time-series [17,34]
have shown that identifying the groups of compute nodes with different
patterns and behaviors helps understanding and resolving performance
issues. By collaborating with HPC researchers, we designed visual
analytics interfaces for supporting performance analysis of HPC appli-
cations. Fig. 11 shows a visual analytics interface for analyzing an HPC
application running on a distributed system. For parallel and distributed
computing, this HPC application is executed with 16 processing entities
(PE) running across the compute nodes, and each PE has 16 kernel
processing (KP) running on different threads within a compute node.
Our visual interface allows selections of clustering methods for an-
alyzing the application performance and behaviors at the KP or PE
level. The selected clustering method uses the average or accumulated
values of each performance metric for each entity (KP or PE) to identify
the groups with different behaviors. To allow users to easily see and
select the entities, PCA is used to project the entities on the scatter
plot. The clustering result is used for color encoding in the line charts.

Fig. 9. (A) Data aggregation and change point detection are used to
analyze the time-series data and generate the timeline chart. (B) The
result of a P6 pipeline can be exported as JSON for annotation and used
in another pipeline for generated visualizations.

Sect. 3.3.1, the data input for a pipeline can be fetched from a remote
server, and data preprocessing can be executed on the fetched data using
P6’s declarative grammars for data transformations. To apply change
point detection, we ﬁrst aggregate the preprocessed time series to obtain
the total global number of COVID-19 infections over time, and we use
the aggregated time series as the input to the change point detection
algorithm. The change point detection result is exported as JSON and
used to annotate the change points on the line chart and visualize the
geographical heatmaps for each point. Fig. 9 shows the declarative
speciﬁcation for these operations. As described in Sect. 3.3.1, the
data analysis results can be exported as JSON and used as the input in
another pipeline. To store the result in the P6 DataFrame, the change
point detection algorithm marks a data item to be 1 if associated with a
change point and otherwise 0. Therefore, we need to ﬁlter the result
based on the ’ChangePoints’ column in the result for annotation on the
line chart and generation of the choropleth maps. The choropleth map
visualizations use the $cols operator to specify the layout of multiple

7

app.analyze({ ProjLeft:  {   algorithm: 'SpectralEmbedding',   n_components: 2, }, ProjRight:  {   algorithm: 'PCA',   n_components: 2, }, Clusters: {   algorithm: 'KMeans',   n_clusters: 3, }}).visualize({ ChartLeft: {   mark: 'circle', size: 10,   x: 'ProjLeft0', y: 'ProjLeft1',   color: 'Clusters',  opacity: 0.5 }, ChartRight: {   mark: 'circle', size: 10,   x: 'ProjRight0', y: 'ProjRight1',   color: 'Clusters', opacity: 0.5 }, ChartBottom: {   mark: 'line',   y: app.data.columns.slice(0,7),   color: 'Clusters',   opacity: 0.25, }})app.interact({  event: 'brush',  from: [    'ChartLeft',    'ChartRight',    'ChartBottom'   ],   response: {     ChartLeft: {       unselected: {color: 'gray'}     },     ChartRight: {       unselected: {color: 'gray'}     },     ChartBottom: {       unselected: {opacity: 0}     }   }})dropDownMenuL.on('change', evt => { app.analyses.ProjLeft   .features = dropDownMenuL.value})dropDownMenuR.on('change', evt => { app.analyses.ProjRight   .features = dropDownMenuR.value})app.vis.ChartBottom  .y = selectedDataAttributesABCDlet app = p6(config1).data({ url: 'https://raw.githubuserco/CSSE...', type: 'CSV', preprocess: {...}}).analyze({  World: {   $transform: {     $aggregate: {       $group: '*',       $collect: { includes: '*', metric: '$sum'}     }   }  },  ChangePoints: {   algorithm: 'CPD',   attribute: 'World',   n: 4, method: 'Window', width: 5  }}).visualize({  lineChart: {   $transform: {     $match: {country: {$in: topCountries}}   },   mark: 'spline', size: 2,   color: 'country', opacity: 1,   x: 'date',   y: {column: 'confirmed', exponent: 0.5} }}).execute()let results = app.result('json')let changePoints = results .filter(d => d.ChangePoints !== 0) .map(d => new Date(d.date))app.visualize({  $annotate: {   id: 'lineChart', mark: 'rule',   size: 1, color: 'red', x: changePoints  }})let geoMaps = p6(config2) .data({..., preprocess: {...}) .visualize({   $cols: {     $select: changePoints,     $transform: {       $match: {         date: '$select'       },     },     mark: 'map',     join: {       field: 'country',       type: 'name'     },     colorMap: 'interpolateReds',     color: 'confirmed'   } }) .execute()ABFig. 10. The timeline of the COVID-19 pandemic. Countries with high numbers of conﬁrmed COVID-19 infections are selected to show in the line chart.
The choropleth maps are generated based on the result of change point detection algorithm for providing snapshots about the spread of COVID-19
in different regions of the world.By using machine learning methods for change point detection and integrating with multi-view visualizations, P6 can
be used to effectively generate explanatory visualizations to show the different stages of the COVID-19 pandemic.

at each iteration. By trying the prototype system for providing feedback
at each iteration, the domain experts can also slightly modify the declar-
ative speciﬁcations to try different design variations or parameters for
analysis and visualizations. This allows the domain experts to provide
more feedback that is useful for improving the system design.

5 DISCUSSION

The examples and case studies demonstrate the capabilities and advan-
tages of P6 for rapidly specifying and integrating machine learning and
visualization methods. Here, we discuss P6’s current limitations and
possible future work.

5.1 Development and Debugging

With declarative speciﬁcation for visual analytics, P6 can be beneﬁcial
to different types of application developers. Application developers
having a clear design speciﬁcation can use the P6 declarative language
to implement a visual analytics pipeline by completing one stage (data,
analyses, view-layout, visualizations, or interactions) at a time. The
declarative speciﬁcation for each stage can be verbose for complex
designs, so completing the pipeline stage by stage is a better approach.
For visual analytics researchers to develop prototype systems, P6 can
be used to ﬁrst implement a simple pipeline with all the stages speciﬁed.
The speciﬁcations for each stage can then be iteratively reﬁned or
extended as they explore and evaluate different design variations.

A drawback of using declarative languages is that debugging be-
comes more difﬁcult as internal structures and executions are not ex-
posed to programmers. In P6, visual analytics operations are executed
across a server-client architecture. To help programmers identify errors
easier, P6 automatically collects errors in both the backend server and
frontend client programs as any errors arise. P6 also traces errors and
indicates which stage and operation in the pipelines are linked to the
root causes. In addition, the intermediate result for each operation in
the pipeline can be exported as JSON (described in Sect. 3.3.1) for in-
spection. These functionalities can help the debugging processing, but
debugging visual analytics applications with many interactions remains
nontrivial. While the beneﬁts of declarative languages outweighted its
drawback in debugging, it is worthwhile developing advanced tools to
better support debugging and development. For example, Hoffswell et
al. [21] have developed a visual debugging tool for interactive data vi-
sualization. Their approach can be adopted and extended for debugging
declarative speciﬁcations of visual analytics pipelines.

Fig. 11. A visual analytics application developed by P6 for analyzing
HPC time-series data. Clustering methods are applied to analyze the
computing entities of an HPC application, in which the results are used
for color encoding in the line charts to analyze the performance and
temporal behaviors of each entity.

Each line chart shows a performance metric for all the entities. We can
see that the HPC applications have three groups of entities with very
different performance and temporal behaviors, and the line charts show
the correlation between the two performance metrics. The declarative
speciﬁcation for this visual interface is similar to the examples in Fig. 2
and Fig. 3. The extra speciﬁcation needed is the data transformations
for preprocessing the time-series data to obtain the aggregated values
for each entity, in which the result is used as the input to the clustering
algorithm. To allow users to select different levels of granularity and
clustering methods, we use the reactive programming capabilities in
P6 for implementing the UI widgets in a similar approach described in
Fig. 6 with speciﬁcation similar to Fig. 8C.

Based on our experience, we found that collaborating with domain
experts to develop visual analytics systems can be beneﬁted from using
a declarative language. Domain-speciﬁc datasets typically need prepro-
cessing before using as inputs to the analysis and visualization methods.
By specifying the data preprocessing operations using declarative gram-
mars, the domain experts can effectively review the preprocessing
operations. As the design and development of visual analytics systems
is often an iterative process, declarative speciﬁcations can allow domain
experts to understand what changes and improvements have been made

8

WorldUSASpainItalyChinaIranSouth KoreaCOVID-19 Confirmed CasesTo appear in IEEE Transactions on Visualization and Computer Graphics.

5.2 Complex Visual Analytics Processes

5.4 Toward Visual Analytics as Services

P6’s declarative language is designed to be simple and intuitive for
implementing visual analytics applications. As P6 supports many
common machine learning and visualization methods, P6 is particularly
useful for building interactive systems for common visual analysis
tasks. For data analysis or visualization methods that are not supported
in P6, P6’s plugin and extension interface described in Sect. 3.4 can be
used to add custom operations. In addition, multiple P6 pipelines can
be used together to support more complex visual analysis processes, as
demonstrated in Sect. 4.2.

For interactive visualizations, P6 currently supports common inter-
action methods, such as click, hover, brush, zoom, and pan. In the
P6 declarative language, the interaction speciﬁcation can only ﬁlter
data at the visualization level. As to declarative interaction design for
modifying data inputs and parameters of the data analysis methods
and machine learning models, the support in P6 is limited. For such
analysis-level interactions, the reactive programming functionality de-
scribed in Sect. 3.2.4 can be leveraged as a workaround. However, a
declarative programming approach is desired. In future work, we can
extend the P6 declarative language for specifying both visualization-
level and analysis-level interactions as well as distinguishing between
them.

Our work is only an initial step toward declarative visual analytics.
P6’s simplicity and advantage for implementing visual analytics ap-
plications should allow easy adoption by application developers and
visual analytics practitioners. In future work, we plan to collect user
feedback to evaluate our design and improve our toolkit.

5.3 Functionalities and Scalability

Our approach of using a declarative language for integrating interac-
tive visualization and machine learning can be applied to different
architectures. Although the use of P4 and a Python backend provides
high performance for visualization and high functionalities for machine
learning, systems can use different combinations of libraries and toolk-
its. For example, we can replace the Python backend and Dask with
Spark MLlib, which might provide better performance and scalability
for machine learning computations. Using declarative speciﬁcations
without worrying about how to execute program operations with a
server-client or distributed computing architecture allows more people
to develop usable visual analytics systems. However, the performance
and scalability depends on the machine learning algorithms, so the
system response time can have high variation for different algorithms.
Many machine learning algorithms have high computational com-
plexity, which become slow when executing on large datasets. Progres-
sive visual analytics provides an effective way for interactive analysis
of big data. By delivering incremental results to maintain an accept-
able level of responsiveness, progressive visual analytics systems allow
users to interact with the intermediate results and steer the analysis
process. A challenging and promising direction for future research
is to integrate machine learning with progressive visual analytics for
interactive analysis of big data. While not all machine learning methods
can generate meaningful incremental or partial results, researchers in
visual analytics and machine learning should collaborate to adapt more
methods to support progressive data analysis. For machine learning
methods that can produce meaningful incremental results, declarative
grammars can be designed for specifying how to use these methods
for progressive and interactive visual analysis. In P5 [29], we have
developed a declarative language for progressive visualization, but it
lacks support for using machine learning methods for advanced data
analysis. A declarative language for integrating incremental machine
learning methods with progressive visual analytics can provide great
value to researchers and developers. System development can be ben-
eﬁted by providing rapid speciﬁcations for how to execute machine
learning methods progressively, visualize the incremental results, adjust
parameters in both the machine learning methods, and steer the visual
analysis process.

When using the P6 declarative language for building a visual analytics
system, programmers do not need to deal with the complexity of setting
up the backend server or remote computing services. This approach
can be extended to support visual analytics as services that leverage
cloud computing for performing data processing and machine learning
computations. The operations in the declarative speciﬁcations are ex-
ecuted at runtime using cloud computing services. Cloud computing
can dynamically allocate computing instances based on the declarative
speciﬁcations, providing better scalability and availability for hosting
visual analytics applications. We can extend the declarative language
for requesting cloud computing resources based on the data size and
computational complexity. The request can be speciﬁed using the re-
sponse time requirements for visual analysis tasks based on appropriate
human computer interaction models [5, 6] and recent user study [30].
Providing visual analytics as services can make building scalable sys-
tems easier and allow better utilization of computing resources.

6 CONCLUSION

We introduce P6, a toolkit providing a declarative language for build-
ing visual analytics systems that richly integrate machine learning
and interactive visualizations. The examples given in this paper have
demonstrated the advantage of P6 for creating visual analytics applica-
tions. With declarative speciﬁcation for visual analytics, it is possible
for non-experts to develop advanced data analysis and communication
solutions that combine the strengths of human and artiﬁcial intelligence.
We have also identiﬁed and discussed future research opportunities
based on our work for improving and extending declarative visual ana-
lytics to contribute more successful designs of visual analytics systems.
The source code, documentations, and examples of P6 can be found at
https://github.com/jpkli/p6.

ACKNOWLEDGMENTS

This research is sponsored in part by the U.S. National Science Founda-
tion through grant IIS-1741536 and IIS-1528203, and also by the U.S.
Department of Energy through grant DE-SC0014917.

REFERENCES

[1] Dask: Scalable analytics in python. No JavaScript required. https:

//dask.org/. Accessed:2020-4-15.

[2] Plotly. Build beautiful, web-based analytic apps. No JavaScript required.

https://plotly.com/dash/. Accessed:2020-4-15.

[3] M. Boehm, M. W. Dusenberry, D. Eriksson, A. V. Evﬁmievski, F. M.
Manshadi, N. Pansare, B. Reinwald, F. R. Reiss, P. Sen, A. C. Surve, et al.
Systemml: Declarative machine learning on spark. Proceedings of the
VLDB Endowment, 9(13):1425–1436, 2016.

[4] M. Bostock, V. Ogievetsky, and J. Heer. D3: Data-Driven Documents.
IEEE Transactions on Visualization and Computer Graphics, 17(12):2301–
2309, 2011.

[5] M. Card. Readings in information visualization: using vision to think.

Morgan Kaufmann, 1999.

[6] S. K. Card, A. Newell, and T. P. Moran. The psychology of human-

computer interaction. 1983.

[7] S.-M. Chan, L. Xiao, J. Gerth, and P. Hanrahan. Maintaining interactivity
while exploring massive time series. In 2008 IEEE Symposium on Visual
Analytics Science and Technology, pp. 59–66. IEEE, 2008.

[8] E. H.-h. Chi and J. T. Riedl. An operator interaction framework for
visualization systems. In Information Visualization, 1998. Proceedings.
IEEE Symposium on, pp. 63–70. IEEE, 1998.

[9] K. A. Cook and J. J. Thomas. Illuminating the path: The research and de-
velopment agenda for visual analytics. Technical report, Paciﬁc Northwest
National Laboratory (PNNL), Richland, WA (US), 2005.

[10] J. H. CSSE.

2019 Novel Coronavirus COVID-19 (2019-nCoV)
Data Repository. https://github.com/CSSEGISandData/COVID-19.
Accessed:2020-4-28.

[11] J. Dean and S. Ghemawat. Mapreduce: Simpliﬁed data processing on

large clusters. 2004.

[12] A. Endert, W. Ribarsky, C. Turkay, B. W. Wong, I. Nabney, I. D. Blanco,
and F. Rossi. The state of the art in integrating machine learning into

9

visual analytics. In Computer Graphics Forum, vol. 36, pp. 458–486.
Wiley Online Library, 2017.

[13] U. Fayyad, G. Piatetsky-Shapiro, and P. Smyth. From data mining to
knowledge discovery in databases. AI Magazine, 17(3):37–37, 1996.
[14] J.-D. Fekete. Visual analytics infrastructures: From data management to

exploration. Computer, 46(7):22–29, 2013.

[15] J.-D. Fekete et al. Software and hardware infrastructures for visual analyt-

ics. 2013.

[16] J.-D. Fekete and C. Plaisant. Interactive information visualization of a mil-
lion items. In IEEE Symposium on Information Visualization (INFOVIS),
pp. 117–124. IEEE, 2002.

[17] T. Fujiwara, J. K. Li, M. Mubarak, C. Ross, C. D. Carothers, R. B. Ross,
and K.-L. Ma. A visual analytics system for optimizing the performance
of large-scale networks in supercomputing systems. Visual Informatics,
2(1):98–110, 2018.

[18] A. Ghoting, R. Krishnamurthy, E. Pednault, B. Reinwald, V. Sindhwani,
S. Tatikonda, Y. Tian, and S. Vaithyanathan. Systemml: Declarative ma-
chine learning on mapreduce. In 2011 IEEE 27th International Conference
on Data Engineering, pp. 231–242. IEEE, 2011.

[19] J. Heer and M. Bostock. Declarative language design for interactive
visualization. IEEE Transactions on Visualization and Computer Graphics,
16(6):1149–1156, 2010.

[20] J. Heer and B. Shneiderman. Interactive dynamics for visual analysis.

Queue, 10(2):30, 2012.

[21] J. Hoffswell, A. Satyanarayan, and J. Heer. Visual debugging techniques
for reactive data visualization. In Computer Graphics Forum, vol. 35, pp.
271–280. Wiley Online Library, 2016.

[22] L. Jiang, S. Liu, and C. Chen. Recent research advances on interactive
machine learning. Journal of Visualization, 22(2):401–417, 2019.
[23] J. Jo, W. Kim, S. Yoo, B. Kim, and J. Seo. Swifttuna: Responsive and
incremental visual exploration of large-scale multidimensional data. In
2017 IEEE Paciﬁc Visualization Symposium (PaciﬁcVis), pp. 131–140.
IEEE, 2017.

12:2825–2830, 2011.

[37] W. A. Pike, J. Stasko, R. Chang, and T. A. O’Connell. The science of

interaction. Information Visualization, 8(4):263–274, 2009.

[38] P. Pirolli and S. Card. The sensemaking process and leverage points
for analyst technology as identiﬁed through cognitive task analysis. In
Proceedings of international conference on intelligence analysis, vol. 5,
pp. 2–4, 2005.

[39] R. R¨adle, M. Nouwens, K. Antonsen, J. R. Eagan, and C. N. Klokmose.
Codestrates: Literate computing with webstrates. In Proceedings of the
30th Annual ACM Symposium on User Interface Software and Technology,
pp. 715–725, 2017.

[40] D. Ren, B. Lee, and T. H¨ollerer. Stardust: Accessible and transparent gpu
support for information visualization rendering. In Computer Graphics
Forum, vol. 36, pp. 179–188. Wiley Online Library, 2017.

[41] A. Rule, A. Tabard, and J. D. Hollan. Exploration and explanation in
computational notebooks. In Proceedings of the 2018 CHI Conference on
Human Factors in Computing Systems, pp. 1–12, 2018.

[42] D. Sacha, M. Sedlmair, L. Zhang, J. A. Lee, D. Weiskopf, S. North,
and D. Keim. Human-centered machine learning through interactive
visualization. ESANN, 2016.

[43] D. Sacha, A. Stoffel, F. Stoffel, B. C. Kwon, G. Ellis, and D. A. Keim.
Knowledge generation model for visual analytics. IEEE Transactions on
Visualization and Computer Graphics, 20(12):1604–1613, 2014.

[44] A. Satyanarayan, D. Moritz, K. Wongsuphasawat, and J. Heer. Vega-lite:
A grammar of interactive graphics. IEEE Transactions on Visualization
and Computer Graphics, 23(1):341–350, 2017.

[45] A. Satyanarayan, R. Russell, J. Hoffswell, and J. Heer. Reactive vega: A
streaming dataﬂow architecture for declarative interactive visualization.
IEEE Transactions on Visualization and Computer Graphics, 22(1):659–
668, 2016.

[46] S. Seabold and J. Perktold. Statsmodels: Econometric and statistical
In Proceedings of the 9th Python in Science

modeling with python.
Conference, vol. 57, p. 61. Scipy, 2010.

[24] D. A. Keim, F. Mansmann, and J. Thomas. Visual analytics: how much
visualization and how much analytics? ACM SIGKDD Explorations
Newsletter, 11(2):5–8, 2010.

[47] B. Shneiderman. The eyes have it: A task by data type taxonomy for
information visualizations. In Proceedings 1996 IEEE symposium on
visual languages, pp. 336–343. IEEE, 1996.

[48] C. A. Steed, K. J. Evans, J. F. Harney, B. C. Jewell, G. Shipman, B. E.
Smith, P. E. Thornton, and D. N. Williams. Web-based visual analytics
for extreme scale climate science. In 2014 IEEE International Conference
on Big Data (Big Data), pp. 383–392. IEEE, 2014.

[49] C. Truong, L. Oudre, and N. Vayatis. ruptures: change point detection in

python. arXiv preprint arXiv:1801.00826, 2018.

[50] C. Truong, L. Oudre, and N. Vayatis. Selective review of ofﬂine change

point detection methods. Signal Processing, 167:107299, 2020.

[51] J. VanderPlas, B. Granger, J. Heer, D. Moritz, K. Wongsuphasawat,
A. Satyanarayan, E. Lees, I. Timofeev, B. Welsh, and S. Sievert. Al-
tair: Interactive statistical visualizations for python. Journal of open
source software, 3(32):1057, 2018.

[52] S. v. d. Walt, S. C. Colbert, and G. Varoquaux. The numpy array: a
structure for efﬁcient numerical computation. Computing in Science &
Engineering, 13(2):22–30, 2011.

[53] H. Wickham. ggplot2: elegant graphics for data analysis. Springer, 2016.
[54] L. Wilkinson. The Grammar of Graphics. Springer-Verlag, Inc., 1999.
[55] P. C. Wong, H.-W. Shen, C. R. Johnson, C. Chen, and R. B. Ross. The top
10 challenges in extreme-scale visual analytics. IEEE computer graphics
and applications, 32(4):63–67, 2012.

[56] J. S. Yi, Y. ah Kang, J. T. Stasko, and J. A. Jacko. Toward a deeper
understanding of the role of interaction in information visualization. IEEE
Transactions on Visualization and Computer Graphics, 13(6):1224–1231,
2007.

[57] M. Zaharia, M. Chowdhury, T. Das, A. Dave, J. Ma, M. McCauley, M. J.
Franklin, S. Shenker, and I. Stoica. Resilient distributed datasets: A
fault-tolerant abstraction for in-memory cluster computing. In Proceed-
ings of the 9th USENIX Conference on Networked Systems Design and
Implementation, NSDI12, p. 2. USENIX Association, USA, 2012.

[25] D. A. Keim, T. Munzner, F. Rossi, and M. Verleysen. Bridging information
visualization with machine learning (dagstuhl seminar 15101). In Dagstuhl
Reports, vol. 5. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2015.
[26] T. Kluyver, B. Ragan-Kelley, F. P´erez, B. E. Granger, M. Bussonnier,
J. Frederic, K. Kelley, J. B. Hamrick, J. Grout, S. Corlay, et al. Jupyter
notebooks-a publishing format for reproducible computational workﬂows.
In ELPUB, pp. 87–90, 2016.

[27] H. Lam. A framework of interaction costs in information visualization.
IEEE Transactions on Visualization and Computer Graphics, 14(6):1149–
1156, 2008.

[28] J. K. Li and K. Ma. P4: Portable parallel processing pipelines for interac-
tive information visualization. IEEE Transactions on Visualization and
Computer Graphics, 26(3):1548–1561, 2020.

[29] J. K. Li and K. Ma. P5: Portable progressive parallel processing pipelines
IEEE Transactions on

for interactive data analysis and visualization.
Visualization and Computer Graphics, 26(1):1151–1160, 2020.

[30] Z. Liu and J. Heer. The effects of interactive latency on exploratory visual
analysis. IEEE Transactions on Visualization and Computer Graphics,
20(12):2122–2131, 2014.

[31] Z. Liu, B. Jiang, and J. Heer. immens: Real-time visual querying of big
data. In Computer Graphics Forum, vol. 32, pp. 421–430. Wiley Online
Library, 2013.

[32] W. McKinney. Python for data analysis: Data wrangling with Pandas,

NumPy, and IPython. ” O’Reilly Media, Inc.”, 2012.

[33] X. Meng, J. Bradley, B. Yavuz, E. Sparks, S. Venkataraman, D. Liu,
J. Freeman, D. Tsai, M. Amde, S. Owen, et al. Mllib: Machine learning in
apache spark. The Journal of Machine Learning Research, 17(1):1235–
1241, 2016.

[34] C. Muelder, B. Zhu, W. Chen, H. Zhang, and K.-L. Ma. Visual analysis of
cloud computing performance using behavioral lines. IEEE Transactions
on Visualization and Computer Graphics, 22(6):1694–1704, 2016.
[35] T. Munzner. A nested model for visualization design and validation. IEEE
Transactions on Visualization and Computer Graphics, 15(6):921–928,
2009.

[36] F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel,
M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, et al. Scikit-learn:
Machine learning in python. the Journal of machine Learning research,

10

