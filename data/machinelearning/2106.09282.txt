1
2
0
2

n
u
J

7
1

]

G
L
.
s
c
[

1
v
2
8
2
9
0
.
6
0
1
2
:
v
i
X
r
a

Smart Contract Vulnerability Detection: From Pure Neural Network to
Interpretable Graph Feature and Expert Pattern Fusion

Zhenguang Liu1∗ , Peng Qian1∗ , Xiang Wang2 , Lei Zhu3 , Qinming He1 and Shouling Ji1†
1Zhejiang University
2National University of Singapore
3Shandong Normal University
{liuzhenguang2008, messi.qp711, xiangwang1223, leizhu0608}@gmail.com, {hqm, sji}@zju.edu.cn

Abstract

Smart contracts hold digital coins worth billions of
dollars, their security issues have drawn extensive
attention in the past years. Towards smart con-
tract vulnerability detection, conventional methods
heavily rely on ﬁxed expert rules, leading to low
accuracy and poor scalability. Recent deep learn-
ing approaches alleviate this issue but fail to en-
code useful expert knowledge. In this paper, we ex-
plore combining deep learning with expert patterns
in an explainable fashion. Speciﬁcally, we develop
automatic tools to extract expert patterns from the
source code. We then cast the code into a semantic
graph to extract deep graph features. Thereafter, the
global graph feature and local expert patterns are
fused to cooperate and approach the ﬁnal predic-
tion, while yielding their interpretable weights. Ex-
periments are conducted on all available smart con-
tracts with source code in two platforms, Ethereum
and VNT Chain. Empirically, our system signif-
icantly outperforms state-of-the-art methods. Our
code is released.

1 Introduction
Blockchain has attracted extensive attention in the past few
years. The worldwide miners (bookkeeping nodes) obey a
consensus protocol to maintain a secure and shared transac-
tion ledger, which is termed a blockchain [Hewa et al., 2020].
In the blockchain network, the consensus protocol enforces
the transactions immutable once recorded in the distributedly
copied ledger, endowing the blockchain with tamper-resistant
and decentralization nature.

Smart contracts are programs running on top of a
blockchain system [Wang et al., 2019; Luu et al., 2016]. A
smart contract can be specially designed by developers to im-
plement arbitrary rules for managing digital assets. Attribut-
ing to the immutable nature of blockchain, a smart contract
cannot be updated once deployed. Thus, the deﬁned rules of
a smart contract are formulated as program code and are au-
tomatically executed, which is impartial for all parties that in-
teract with the contract. Smart contracts make the automatic

execution of contract terms possible, facilitating complex de-
centralized applications (DApps) [Ding et al., 2019].

So far, millions of smart contracts have been deployed
on various blockchain platforms, controlling digital currency
worth more than 10 billion dollars. Holding so much wealth,
however, makes smart contracts attractive enough to mali-
cious attackers. In 2016, attackers exploited the reentrancy
vulnerability of The DAO contract‡ to steal Ether (i.e., Cryp-
tocurrency of Ethereum) worth 60 million dollars. This case
is not isolated and several security vulnerabilities of smart
contracts are disclosed every year [Lorenz et al., 2018].

The main issues that may easily lead to smart contract vul-
nerabilities are twofold. First, the programming languages
and tools are still new and crude, which leaves plenty of
rooms for misunderstandings in the built-in functions and
tools [Luu et al., 2016]. Second, due to the immutable na-
ture of smart contracts, developers are required to anticipate
all possible states (e.g., stack status) and environments that
the code may encounter in the future, which is obviously dif-
ﬁcult.

Existing methods on smart contract vulnerability detection
can be roughly cast into two categories. The ﬁrst line of work
[Luu et al., 2016; Tsankov et al., 2018; Jiang et al., 2018]
utilized classical static analysis and dynamic execution tech-
niques to identify vulnerabilities. Unfortunately, they funda-
mentally rely on several ﬁxed expert rules, while the man-
ually deﬁned patterns bear the inherent risk of being error-
prone and some complex patterns are non-trivial to be cov-
ered. Meanwhile, crafty attackers may easily bypass the ﬁxed
patterns using small tricks. Another line of work [Tann et al.,
2018; Zhuang et al., 2020] explored using deep learning mod-
els to deal with complex contract data, having achieved much
improved accuracy. Due to the black-box nature, however,
they fail to encode useful expert knowledge and mostly have
poor interpretability. This motivates us to consider whether
we could combine neural networks with classical expert pat-
terns, where neural networks contribute their ability to handle
the complex code semantic graph while expert patterns con-
tribute precise and valuable local information. More impor-
tantly, we seek an explainable solution which could tell the
weights of different features.

*The ﬁrst two authors have equal contribution.
†Corresponding author.

‡The DAO contract,

2016.

http://etherscan.io/address/

0xbb9bc244d798123fde783fcc1c72d3bb8c189413

 
 
 
 
 
 
Figure 1: The overall architecture of our proposed method. (a) The local expert pattern extraction tool for extracting vulnerability-speciﬁc
expert patterns. (b) The graph construction and normalization module for transforming the code into a global semantic graph. (c) The attentive
multi-encoder network, which combines expert patterns and the graph feature for vulnerability detection and outputting explainable weights.

Our method.
In this paper, we propose a new system be-
yond pure neural networks that can automatically detect vul-
nerabilities and incorporate expert patterns into networks in
In particular, (1) we develop auto-
an explainable fashion.
matic tools to extract vulnerability-speciﬁc expert patterns.
(2) Then, we exploit a graph structure to frame the rich
control-ﬂow and data-ﬂow semantics of the function code.
Upon the graph, a graph neural network is employed to ex-
tract the deep graph feature. (3) Finally, we propose an atten-
tive multi-encoder network to interpretably fuse the global
graph feature and local expert patterns. Extensive experi-
ments are conducted on all the 40k contracts in two bench-
mark datasets, demonstrating signiﬁcant improvements over
state-of-the-art: accuracy from 84% to 90%, 83% to 87%,
75% to 80% on three types of vulnerabilities respectively.
More importantly, our model is able to explain its label pre-
diction, give warnings of high weighted local patterns, and
provide a grand picture of the signiﬁcance of different fea-
tures.

Contributions. The key contributions of this work are: 1)
We investigate combining vulnerability-speciﬁc expert pat-
terns with neural networks in an explainable way. To the best
of our knowledge, we are the ﬁrst to prob the combination in-
terpretably. 2) In the method, we present a simple but effec-
tive multi-encoder network for feature fusion. 3) Our method
sets the new state-of-the-art and provides novel insights. To
facilitate future research, our implementations are released
at https://github.com/Messi-Q/AMEVulDetector. We would
like to point out that different from [Liu et al., 2021], this
work focuses mainly on the explainability of the expert pat-
tern and deep graph feature combination, and offers a grand
picture on the importance of different features.

2 Problem
Given the source code of a smart contract, we seek to de-
velop a fully automatic approach that can detect vulnerability
at ﬁne-grained function level and is interpretable.
In other
words, presented with a smart contract function f , we are to
predict its label ˆl and output the associated weights {wi}n
i=1
simultaneously, where ˆl = 1 represents f has a vulnerability
of a certain type and ˆl = 0 denotes f is safe. Weight wi ex-
plains the importance of the ith feature in predicting the label.
In this work, we concentrate on three common vulnerabilities:
(1) Reentrancy is a well-known vulnerability that has
brought about the notorious DAO attack. When a smart

transf er
−−−−−−→ C

contract function f1 transfers money to a recipient contract
C, the fallback function f2 of C will be automatically trig-
gered. Function f2 may invoke f1 for conducting an in-
valid second-time money transfer. Since the current exe-
cution of f1 waits for the ﬁrst-time transfer to ﬁnish, the
balance of C is not reduced yet, f1 thus may wrongly be-
lieve that C still has enough balance and transfers money
to C again. More speciﬁcally, the expected execution trace
trigger
−−−−→ f2 → end, whereas the actual
is f1
transf er
trigger
trace is f1
−−−−−−→
−−−−→ f2
trigger
C
−−−−→ f2 → end. Exploiting the reentrancy vulner-
ability, an attacker may succeed in obtaining 20 Ether al-
though his/her balance is 10 Ether. Note that attackers can
steal more money by invoking f1 more than one time, which
transf er
invoke−−−−→
−−−−−−→ C
can be exempliﬁed as f1
trigger
invoke−−−−→ f1
−−−−→
f1
f2 → end.

trigger
−−−−→ f2
transf er
−−−−−−→ C

transf er
−−−−−−→ C

transf er
−−−−−−→ C

trigger
−−−−→ f2

invoke−−−−→ f1

(2) Block timestamp dependence happens when a function
uses block timestamp as a condition to perform critical op-
erations, e.g., using block.timestamp of a future block as the
source to generate random numbers so as to determine the
winner of a game. The miner who mines the block has the
freedom to set the timestamp of the block as long as it is
within a short time interval [Jiang et al., 2018]. Thus, miners
may manipulate block timestamp to gain illegal beneﬁts.

(3) Inﬁnite loop is conventionally considered as a loop bug
which unintentionally iterates forever, e.g., a for loop with no
exit condition. Distinct from conventional programs, users
have to pay a fee for executing each line of smart contract
code. The fee is approximately proportional to how much
code needs to run. For a function with inﬁnite loop, its exe-
cution will run out of gas and be aborted. In such a case, the
execution consumes a lot of gas but all the gas is consumed
in vain since the execution is unable to change any state.

3 Method
The overview of the proposed system is illustrated in Fig. 1,
which consists of three components: 1) a local expert pattern
extraction tool, which extracts expert patterns of a speciﬁc
vulnerability from the function code; 2) a graph construc-
tion and normalization module, which transforms the func-
tion code into a code semantic graph; and 3) an attentive
multi-encoder network that combines local expert patterns
and the global graph feature for vulnerability detection and

(b) Global graph construction and normalization Smart contract functionWiy(c) Attentive multi-encoder network^(a) Local pattern extraction0.270.230.260.24P1P2P3G= 1Detection resultCross attentionlayersC2C3C2function withdraw(uint sum) {   if (Balance[msg.sender] < sum) {      throw;   }   require(msg.sender.call.value(sum)());   Balance[msg.sender] -= sum;}Core NodeNormal NodeControl Flow EdgeData Flow EdgeFallback Edgee8CiNiN1e3e9e4e1e2e7e5e11e10e6e8e9e1e2e3e4e6e7e5e10e11p2p1P2P3P1NFC1C3C1p1p3''g'Self attentionlayer'gp3p2Self attentionlayerSelf attentionlayerSelf attentionlayeroutputs explainable weights. In what follows, we introduce
the three components one by one.

3.1 Local Expert Pattern Extraction
Following [Liu et al., 2021], we design corresponding expert
patterns for three types of vulnerabilities respectively. Then,
we implement a fully automatic tool to extract expert patterns
from the function code. Speciﬁcally, the patterns for different
vulnerabilities are deﬁned as:

Reentrancy. Technically, the reentrancy vulnerability oc-
curs when a call.value invocation (i.e., a built-in money trans-
fer function) can call back to itself through a chain of calls.
That is, call.value is successfully re-entered to perform unex-
pected repeat money transfers. For the reentrancy vulnerabil-
ity, we design three local patterns. (1) enoughBalance con-
cerns whether there is a check on the sufﬁciency of the user
balance before transferring to a user. (2) callValueInvoca-
tion models whether there exists an invocation to call.value
in the function. (3) balanceDeduction checks whether the
user balance is deducted after money transfer, which consid-
ers the fact that the money stealing can be avoided if the user
balance is deducted each time before money transfer.

Block timestamp dependence. Generally, the timestamp
dependency vulnerability exists when a smart contract is con-
ventionally considered as using block.timestamp as part of the
conditions to perform critical operations [Jiang et al., 2018].
We design three local patterns for the timestamp dependence
(1) timestampInvocation models whether
vulnerability.
there exists an invocation to opcode block.timestamp in the
function. (2) timestampAssign checks whether the value of
block.timestamp is assigned to other variables or passed to
a function as a parameter, namely whether block.timestamp
(3) timestampContaminate veriﬁes if
is actually used.
block.timestamp may contaminate the triggering condition of
a critical operation (e.g., money transfer).

Inﬁnite loop. Speciﬁcally, we deﬁne three local patterns for
the inﬁnite loop vulnerability as follows. (1) loopStatement
checks whether the function exists a loop statement such as
for and while. (2) loopCondition validates whether the exit
condition can be reached. For example, for a while loop, its
exit condition i < 9 cannot be reached if i is never updated
in the loop. (3) selfInvocation concerns whether the function
invokes itself and the self-invocation is not in an if statement.
This considers the fact that if the self-invocation statement
is not in an if statement, the self-invocation loop will never
terminate.

Implementations. Our open-sourced tool to extract the de-
signed local expert patterns is released on Github. These
patterns are consistent with those in our previous work [Liu
et al., 2021]. As introduced in [Liu et al., 2021], the pat-
tern extraction tool scans the source code of a function sev-
eral times. Particularly, simple patterns such as callValueIn-
vocation and timestampInvocation can be directly extracted
by keyword matching. Patterns such as enoughBalance, bal-
anceDeduction, loopStatement, timestampAssign, loopCon-
dition, and selfInvocation are obtained by syntactic and se-
mantic analysis. Complex pattern timestampContaminate is

Vulnerabilities

Reentrancy

Timestamp dependence

Inﬁnite loop

Core Nodes
call.value invocation
a function that contains call.value
the variable: correspond to user balance
block.timestamp invocation
block.number invocation
a variable: affect critical operation
for
while
self-call function

Table 1: Core nodes are modeled for the three types of vulnerabili-
ties. Differences with [Zhuang et al., 2020] are highlighted in bold.

Semantic Edge
assert{ X }
require{X}
if{X}
if{...} else {X}
if{...} revert
if{...} throw
if{...} then {X}
while{X} do{...}
for{X} do{...}
natural sequential relationships
assign{X}
access{X}
from call.value node to fallback function
from fallback node to function under test

Type

Control-ﬂow edges

Data-ﬂow edges

Fallback edges

Table 2: Key semantic edges, which fall into three categories.

extracted by taint analysis, where we follow the traces of the
data ﬂow and ﬂag all the variables that may be affected along
the traces.

3.2 Graph Construction and Normalization
One may directly use combinations of aforementioned pat-
terns to predict whether the function has a certain vulnera-
bility. However, these ﬁxed patterns are shown to have difﬁ-
culties in handling relatively complex attacks and are trivial
to be bypassed by adversaries [Qian et al., 2020]. Therefore,
we further propose to model the control ﬂow and data ﬂow of
the entire source code into a semantic graph, and adopt graph
neural networks to handle it. Thereafter, the extracted global
graph feature and the local expert patterns could supplement
each other towards a more precise and explainable label pre-
diction.

Graph construction. Different program elements in a
function are not of equal importance in detecting vulnera-
bilities. Therefore, we extract two categories of nodes, i.e.,
core nodes and normal nodes. (1) Core nodes symbolize key
invocations and variables in the function code, which are crit-
ical for detecting a speciﬁc vulnerability. For instance, for
reentrancy vulnerability, (i) an invocation to call.value, (ii)
an invocation to a money transfer function that contains a
call.value invocation, and (iii) the variable that corresponds
to user balance, are treated as core nodes. We summarize
the core nodes for detecting the three vulnerabilities in Ta-

Figure 2: The attentive multi-encoder network, consisting of a self-attention mechanism and a cross-attention mechanism. It combines local
pattern features and the global graph feature for vulnerability detection, and outputs interpretable weights for all features.

(2) Invocations and variables that are not extracted
ble 1.
as core nodes are modeled as normal nodes, which play an
auxiliary role in detecting vulnerabilities. We also construct
an extra fallback node to stimulate the fallback function of a
virtual attack contract. The fallback node can interact with
the function under test and is considered as a normal node.
It is worth mentioning that distinct from prior works such as
[Zhuang et al., 2020], which merely model key invocations as
core nodes, we propose to further extract key variables as core
nodes, given that they are undoubtedly important in detecting
vulnerabilities. To characterize rich connections between dif-
ferent nodes, we construct three categories of semantic edges,
namely control ﬂow, data ﬂow, and fallback edges. Each edge
describes a path that might be traversed through by the func-
tion under test, and the temporal number of the edge is set
according to its sequential order in the function code. We
summarized key semantic edges in Table 2.

Graph normalization.
It is worth mentioning that differ-
ent functions corresponding to distinct code semantic graphs,
bringing difﬁculties in training a graph neural network. More-
over, current graph neural networks are inherently ﬂat when
propagating information, ignoring that different nodes are not
of equal importance. Therefore, we propose to normalize the
graph following that of [Zhuang et al., 2020] to remove all
normal nodes and merge their features to the nearest core
nodes. A simpliﬁed example for graph construction and nor-
malization is given in Fig. 1(b).

3.3 Attentive Multi-Encoder Network
For the extracted local expert patterns, we adopt the multiple
MLPs (multilayer perceptrons) to encode them into feature
vectors. For the normalized global code semantic graph, we
utilize a temporal-message-propagation (TMP) graph neural
network to transform it into a deep graph feature. Then, the
expert pattern features and the graph feature are fused using
an attentive multi-encoder network to give the overall label
prediction ˆy, which is illustrated in Fig. 2.

Local pattern feature extraction. Each expert pattern for-
mulates an elementary factor closely related to a speciﬁc vul-
nerability. We utilize a one-hot vector to represent each pat-
tern, and append a digit 0/1 to indicate whether the function
under test has this pattern. The vectors for all patterns related
to a speciﬁc vulnerability are fed into multiple MLPs, each

takes care of one pattern. The outputs of the MLPs are con-
catenated and passed into a feed-forward network to compute
the label prediction of the function. This network is trained
so that each MLP learns to extract the feature p ∈ Rd of a
pattern.

Global graph feature extraction. To extract the graph fea-
ture from the normalized code semantic graph, we use a
graph neural network that consists of a message propagation
phase and an aggregation phase [Zhuang et al., 2020].
In
the message propagation phase, the network passes informa-
tion along the edges successively by following their sequen-
tial orders in the code, while the aggregation phase outputs
the global graph feature g ∈ Rd by aggregating the ﬁnal
states and original states of all nodes. Following [Zhuang
et al., 2020], at each time step j, message ﬂows through the
jth edge ej and updates the hidden state of the end node of
ej by absorbing information from edge ej and the start node
of ej. After successively traversing all edges, we extract the
graph feature by aggregating the hidden states of all nodes.
The original hidden state h0
i of
each node are informative in the vulnerability detection task.
Therefore, we can obtain the ﬁnal global graph feature g by:

i and the ﬁnal hidden state hT

hi = h0

i ⊕ hT
i

Gatei = σ(M1(relu(b1 + M2hi)) + b2)
Outputi = σ(M3(relu(b3 + M4hi)) + b4)
(Gatei (cid:12) Outputi)(cid:1)

g = F C(cid:0) (cid:88)N

i=1

(1)
(2)
(3)

(4)

where ⊕ and (cid:12) denote concatenation and element-wise prod-
uct. Matrix Mj and bias vector bj are network parameters, N
is the number of nodes, σ is the softmax activation layer, and
F C is a fully connected layer. Motivated readers may also
refer to [Zhuang et al., 2020] for more details of the message
propagation and aggregation phases.

Fusion network. As shown in Fig. 2, the extracted lo-
cal pattern features {pi}k
i=1 and the global graph feature g
go through a self-attention mechanism and a cross-attention
mechanism to output the label prediction ˆy and the associated
weights {wi}n
i=1 for all features. Since the local expert pat-
tern features and the global graph feature are heterogeneous,
the self-attention mechanism learns to preliminarily balance
different features by computing the coefﬁcients for all fea-

EncoderGy^p1P1MLPg'TMPSelf attention'MLP{V, E}layerSelf attentionlayerSelf attentionlayerPkSelf Attention MechanismFeature ExtractionEncoderP1EncoderPkMLPCross Attention Mechanism~~~wg0.270.240.23wp1wpkSigmoidOutputsweights computationVpkp1pk'ggp1pktures. The cross-attention mechanism then fuses different fea-
tures to predict the label.

Self attention mechanism. Formally, the processes of the
self attention for pi and g are given by:

cg = F C(g),

cpi = F C(pi),

(cid:48)

(cid:48)

g

pi

= cg (cid:12) g

= cpi (cid:12) pi

(5)

(6)

where cg and cpi are coefﬁcient vectors, (cid:12) denotes the
element-wise product, g
denote the updated features.

and pi

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

and {pi

i=1 into ˜g and {˜pi}k
}k

Cross attention mechanism. After the self attention, we
}k
can obtain new features g
i=1. Next, we con-
sider combining them to detect vulnerabilities. As shown
(cid:48)
in Fig. 2, each feature goes through an encoder, mapping g
and {pi
i=1, respectively. Then, all the
mapped features are concatenated and fed into an MLP, gen-
erating a ﬁnal semantic vector v. The label ˆy is then conve-
niently computed by ˆy = round(sigmoid(v)). Technically,
we believe that the attention weights could highlight the fea-
ture importance. The inner product between each feature and
v, therefore, is employed to compute the interpretable weights
for the global graph feature g and each local expert pattern
feature pi.

wg =

wpi =

exp(˜g · v)

exp(˜g · v) + (cid:80)k

i=1 exp(˜pi · v)

exp(˜pi · v)

exp(˜g · v) + (cid:80)k

i=1 exp(˜pi · v)

(7)

(8)

where wg denotes the weight of g, wpi is the weight of pi,
and · represents inner product.

4 Experiments
In this section, we empirically evaluate our proposed method
on two benchmark datasets, namely Ethereum smart contract
dataset (ESC) and VNT Chain smart contract dataset (VSC).
We seek to answer the following research questions:

• RQ1: Can the proposed method effectively detect the three
types of vulnerabilities? How is its performance against
state-of-the-art tools and neural network-based methods?
• RQ2: Is the method able to provide interpretability in vul-
nerability detection? Can we obtain new insights from it?
• RQ3: How do the different components affect the perfor-

mance of the proposed approach?

Next, we ﬁrst present the experimental settings, followed by
answering the above research questions one by one.

4.1 Experimental Settings
Datasets.
(1) ESC dataset contains 307,396 functions from
40,932 Ethereum smart contracts. In the dataset, 5,013 func-
tions contain at least one invocation to call.value, making
them potentially affected by reentrancy vulnerability. 4,833
functions have the block.timestamp statement that may cause
(2) VSC dataset con-
timestamp dependence vulnerability.
sists of 13,761 functions from 4,170 VNT Chain smart con-
tracts. Around 2,925 functions have loop statements.

Implementation details. All experiments are conducted on
a computer equipped with an Intel Core i7 CPU at 3.7GHz, a
GPU at 1080Ti, and 32GB Memory. The expert pattern ex-
traction tool and the graph construction tool are implemented
with Python, while the neural networks are implemented with
TensorFlow. Following prior works, we randomly select 80%
of the functions as the training set and the other 20% as the
test set for each dataset. The encoders in Fig. 2 are imple-
mented using three fully connected layers. The hidden state
sizes of the self attention and encoder layers are 200 and 100,
respectively.

4.2 Performance Comparison (RQ1)
In this section, we compare our proposed approach against
state-of-the-art
tools and available neural network-based
methods. Following existing work [Zhuang et al., 2020],
we conduct experiments for the reentrancy and timestamp
dependence vulnerability on ESC, and evaluate the inﬁnite
loop vulnerability on VSC. Metrics accuracy, recall, preci-
sion, and F1-score are all engaged in the comparisons.

Comparison with Conventional Detection Tools
We ﬁrst compare our method AME with existing smart
contract vulnerability detection tools including Smartcheck
[Tikhomirov et al., 2018], Oyente [Luu et al., 2016], Mythril
[Mueller, 2017], Securify [Tsankov et al., 2018], and Slither
[Feist et al., 2019]. Quantitative results are summarized in
Table 3.

As shown in the left of Table 3, we observe that: 1) con-
ventional tools have not yet achieved a satisfactory accuracy
on the reentrancy vulnerability detection. In particular, state-
of-the-art tools Securify and Slither only achieve 71.89% and
77.12% accuracies. 2) Our method signiﬁcantly outperforms
the existing tools in reentrancy vulnerability detection. More
speciﬁcally, AME achieves a 90.19% accuracy, gaining a
13.07% accuracy improvement over the state-of-the-art tool.
Empirical evidences clearly reveal the effectiveness of our
method.

Next, we evaluate all the methods on timestamp depen-
dence vulnerability. The comparison results are shown in
the middle of Table 3. State-of-the-art tool Slither obtains
a 74.20% accuracy, which is quite low. This may stem from
the fact that most conventional tools handle the timestamp de-
pendence vulnerability by blindly checking whether there is
a block.timestamp statement in the function, while ignoring
whether the timestamp can truly affect a critical operation.
Further, it is worth pointing out that AME keeps delivering
the best performance in terms of all the four metrics. Signiﬁ-
cantly, AME gains a 12.32% accuracy improvement over the
state-of-the-art tool.

We further evaluate our method on the inﬁnite loop vulner-
ability. Speciﬁcally, we compare our methods against exist-
ing inﬁnite loop detection methods including Jolt [Carbin et
al., 2011], SMT [Kling et al., 2012], PDA [Ibing and Mai,
2015], and Looper [Burnim et al., 2009]. Quantitative results
are illustrated in the right of Table 3. We observe that AME
consistently outperforms other methods by a large margin.

By looking into the implementations of classical tools, we
found that: 1) they heavily rely on a few ﬁxed expert rules to

Methods

Smartcheck
Oyente
Mythril
Securify
Slither
Vanilla-RNN
LSTM
GRU
GCN
DR-GCN
TMP
AME

Reentrancy

Acc(%) Recall(%)
52.97
61.62
60.54
71.89
77.12
49.64
53.68
54.54
77.85
81.47
84.48
90.19

32.08
54.71
71.69
56.60
74.28
58.78
67.82
71.30
78.79
80.89
82.63
89.69

Precision(%)
25.00
38.16
39.58
50.85
68.42
49.82
51.65
53.10
70.02
72.36
74.06
86.25

F1(%) Acc(%) Recall(%)
28.10
44.96
51.02
53.57
71.23
50.71
58.64
60.87
74.15
76.39
78.11
87.94

Timestamp dependence
Precision(%)
39.16
45.16
50.00
–
67.25
51.91
50.32
49.41
68.35
71.29
75.05
82.07

44.32
59.45
61.08
–
74.20
49.77
50.79
52.06
74.21
78.68
83.45
86.52

37.25
38.44
41.72
–
72.38
44.59
59.23
59.91
75.97
78.91
83.82
86.23

Methods

Jolt
PDA
SMT
Looper
–

F1(%)
38.18
41.53
45.49
–
69.72
45.62 Vanilla-RNN
54.41
54.15
71.96
74.91
79.19
84.10

LSTM
GRU
GCN
DR-GCN
TMP
AME

Inﬁnite Loop

Acc(%) Recall(%)
42.88
46.44
54.04
59.56
–
49.57
51.28
51.70
64.01
68.34
74.61
80.32

23.11
21.73
39.23
47.21
–
47.86
57.26
50.42
63.04
67.82
74.32
79.08

Precision(%)
38.23
42.96
55.69
62.72
–
42.10
44.07
45.00
59.96
64.89
73.89
78.69

F1(%)
28.81
28.26
45.98
53.87
–
44.79
49.80
47.55
61.46
66.32
74.10
78.88

Table 3: Performance comparison. A total of sixteen methods are investigated in the comparisons. ‘–’ denotes not applicable.

(a) Reentrancy

(b) Timestamp

Figure 3: Weight statistics of different features. Left: ratio of having
a weight higher than σ. Right: ratio of having the maximum weight.

detect vulnerabilities, e.g., Smartcheck checks whether there
exists an invocation to call.value to detect reentrancy, and 2)
the rich code semantic information and key variables in the
code are not well characterized in the methods. In this re-
spect, our work has an edge in explicitly modeling key vari-
ables and abling to handle complex semantics.

(c) Inﬁnite loop

Comparison with Deep Learning Methods

Figure 4: Mean and deviation of the weights of different features.

We also compare our method with available deep learning-
based methods, namely Vanilla-RNN, LSTM, GRU, GCN,
DR-GCN, and TMP [Zhuang et al., 2020]. For a feasible
comparison, Vanilla-RNN, LSTM, and GRU are fed with the
function code sequence vectors, while GCN, DR-GCN and
TMP are presented with the graph feature vectors.

We illustrate the performance of different methods in Ta-
ble 3. Results show that sequential models Vanilla-RNN,
LSTM, and GRU have a relatively poor performance, while
graph neural network models GCN, DR-GCN, and TMP sig-
niﬁcantly outperform them. This reconﬁrms that blindly treat
the source code as a sequence is not suitable for vulner-
ability detection, while characterizing the code as a graph
and employing graph neural networks is effective. Notably,
AME consistently outperforms GCN, DR-GCN, and TMP by
a large margin across three vulnerabilities. The empirical ev-
idences reveal that encoding expert patterns in networks in-
deed contributes to a signiﬁcant performance gain.

4.3

Interpretability Evaluation (RQ2)

We now study the interpretability of the proposed AME net-
work, and present novel insights on weight distributions of
different features in vulnerability detection. We also present
a case study to facilitate understanding.

As presented in subsection 3.1, we deﬁned three lo-
cal patterns for each vulnerability. We denote the three
vulnerability-speciﬁc patterns as Loc-pattern1, Loc-pattern2,
and Loc-pattern3, respectively. For example, Loc-pattern1
is enoughBalance for reentrancy vulnerability and is times-
tampInvocation for timestamp dependence vulnerability. The
three patterns and the global graph feature are used to predict
whether the function has the speciﬁc vulnerability.

Interestingly, to ﬁgure out which features contribute the
most to the detection of a speciﬁc vulnerability, we record the
number that a feature possesses a weight (obtained by Eq. 7 or
Eq. 8) greater than a preset threshold σ = 0.25 over all tested

ReentrancyTimestamp dependenceInfinite loop020406080100(%)Loc-pattern1Loc-pattern2Loc-pattern3Global graphReentrancyTimestamp dependenceInfinite loop020406080100(%)Loc-pattern1Loc-pattern2Loc-pattern3Global graphGlobal graphLoc-pattern1Loc-pattern2Loc-pattern30510152025303540(%)Global graphLoc-pattern1Loc-pattern2Loc-pattern30510152025303540(%)Global graphLoc-pattern1Loc-pattern2Loc-pattern30510152025303540(%)Figure 5: Case study on the interpretability of our method.

functions. The statistics are visualized in the left of Fig. 3.
We observe that the global graph feature usually possesses
a high weight, revealing its leading role in the label predic-
tion. Moreover, in reentrancy vulnerability detection, Loc-
pattern2 (callValueInvocation) and Loc-pattern3 (balanceDe-
duction) rank second and third in the possibility of having a
high weight, while Loc-pattern2 (timestampAssign) and Loc-
pattern3 (timestampContaminate) often have high weights in
timestamp dependence detection. It is worth pointing out that
once a function is predicted to have a speciﬁc vulnerability by
our method, besides telling the user how signiﬁcant (weight)
each feature contributes to the prediction, we can also warn
him/her of the expert patterns that get high weights to help
ﬁnd bugs. The statistics over a large number of functions also
allow developers build a grand picture of the whole system.

We also compute the number that a feature has the max-
imum weight among all features over all tested functions.
The visualized results are demonstrated in the right of Fig. 3.
From the histogram, we notice that the global graph feature
obtains the maximum weight most times for the three vul-
nerabilities. For each feature, we also illustrate the mean and
standard deviation of its weight in Fig. 4. We see that each lo-
cal expert pattern possesses a considerable weight, but the av-
erage attention weight of the global graph feature is the high-
est. This may come from the fact that the global graph con-
veys the control- and data- dependencies of a speciﬁc vulner-
ability and contains richer global semantic information than
local expert patterns.

Case study. We further present a case study in Fig. 5, where
the withdraw function is a real-world smart contract func-
tion that has a reentrancy vulnerability. We analyzed the
code to detect whether it has the three vulnerabilities. The
left of Fig. 5 illustrates the global graph and the three local
patterns of reentrancy. The right of Fig. 5 shows the inter-
pretable weights of the graph feature and each local pattern
feature. For example, the method detects the function has
the reentrancy vulnerability. To make the detection decision,
the weight of the global graph feature is 0.27, the weights of
Loc-pattern1 (enoughBalance), Loc-pattern2 (callValueInvo-
cation), and Loc-pattern3 (balanceDeduction) are 0.23, 0.26,

(a) Removing graph feature

(b) Removing patterns

Figure 6: Effect of removing modules on three vulnerabilities.

and 0.24, respectively. Thus, our system is able to clearly
explain the reasons behind the predictions.

4.4 Effects of Removing Expert Patterns and

Graph Feature (RQ3)

By default, we combine the graph feature with expert pat-
terns for vulnerability detection. We are interested in explor-
ing the effect of removing them respectively. To this aim, we
ﬁrst remove the code semantic graph construction module,
and only use the expert pattern features as the inputs. We de-
note this variant as AME-RG (RG represents removing graph
feature). We also try removing the expert pattern extraction
module and using the graph feature only, which is denoted as
AME-RP (RP represents removing patterns, which is almost
identical to the TMP). Fig. 6 demonstrates the comparison re-
sults on three vulnerabilities, where the solid curves demon-
strate the accuracy of AME over different epochs, and the
dashed curves show its variants. Different colors represent
different vulnerabilities. Clearly, the performance of AME is
consistently better compared to its variants across all epochs,
revealing that combining local expert patterns with global
graph features is necessary and important to improve the de-
tection performance. Moreover, removing the neural network
extracted graph feature exhibits a higher performance drop
than removing the expert patterns.

     dlCase study: reentrancy1234567function withdraw(uint sum) public{    if (Balance[msg.sender] < sum) {      throw;    }    require(msg.sender.call.value(sum)());    Balance[msg.sender] -= sum; }enoughBalancecallvalueInvocbalanceDeductionGlobal graphLocal patterns forreentrancy123123C2C1NFC3e8N1e3e9e4e1e2e7e5e11e10e6050100Epoch0.40.60.81.0AccuracyAME (Reetrancy)AME-RG (Reetrancy)AME (Timestamp)AME-RG (Timestamp)AME (Infinite loop)AME-RG (Infinite loop)050100Epoch0.40.60.81.0AccuracyAME (Reetrancy)AME-RP (Reetrancy)AME (Timestamp)AME-RP (Timestamp)AME (Infinite loop)AME-RP (Infinite loop)5 Related Work
Early work on smart contract vulnerability detection veri-
ﬁes smart contracts by employing formal methods [Bhar-
gavan et al., 2016; Hirai, 2017; Grishchenko et al., 2018].
For example, [Bhargavan et al., 2016] introduces a frame-
work, translating Solidity code and the EVM (Ethereum Vir-
tual Machine) bytecode into the input of an existing veriﬁ-
[Hirai, 2017] proposes a formal model for
cation system.
EVM (Ethereum Virtual Machine) and reasons smart con-
tracts using the Isabelle/HOL tool. Another stream of work
relies on symbolic analysis and dynamic execution. Oyente
performs symbolic execution on contract functions and ﬂags
bugs based on simple patterns. Zeus [Kalra et al., 2018] lever-
ages abstract interpretation and symbolic model checking.
[Tsankov et al., 2018] introduces compliance (negative) and
[Jiang
violation (positive) patterns to ﬁlter false warnings.
et al., 2018] presents ContractFuzzer to identify vulnerabili-
ties by fuzzing and runtime behavior monitoring during ex-
ecution. Sereum [Rodler et al., 2019] uses taint analysis to
monitor runtime data ﬂows during smart contract execution
for vulnerability detection. Recently, a few attempts have
[Qian et
been made to study using deep neural networks.
al., 2020] constructs the sequential contract snippet and feeds
them into the BLSTM-ATT model. [Zhuang et al., 2020] pro-
poses to convert the source code of contract into the contract
graph and constructs graph neural networks as the detection
model. [Wang et al., 2020] proposes extracting bigram fea-
[Liu et al.,
tures from operation codes of smart contracts.
2021] proposes to combine expert rules with neural networks
for improving the detection accuracy. However, [Liu et al.,
2021] suffers from poor explainability and fail to investigate
the signiﬁcance of different features.

6 Conclusion
In this paper, we explore combining deep learning with clas-
sical expert patterns in an explainable way for smart contract
vulnerability detection. This system consists of both neural
networks and automatic expert pattern extraction tools. Inter-
estingly, the model is able to obtain explainable ﬁne-grained
details and a grand picture of the weight distributions. Ex-
tensive experiments show that our method signiﬁcantly out-
performs state-of-the-art approaches. We believe our work is
an important step towards explainable and accurate contract
vulnerability detection.

Acknowledgements
This paper is supported by the Natural Science Foundation
of Zhejiang Province, China (No. LQ19F020001), the Na-
tional Natural Science Foundation of China (No. 61902348),
and the Key R&D Program of Zhejiang Province (No.
2021C01104).

References
[Bhargavan et al., 2016] Karthikeyan Bhargavan, Antoine
Delignat-Lavaud, C´edric Fournet, Anitha Gollamudi,
Georges Gonthier, Nadim Kobeissi, Natalia Kulatova,
Aseem Rastogi, Thomas Sibut-Pinote, Nikhil Swamy,

et al. Formal veriﬁcation of smart contracts: Short paper.
In Proceedings of the 2016 ACM Workshop on Program-
ming Languages and Analysis for Security, pages 91–96,
2016.

[Burnim et al., 2009] Jacob Burnim, Nicholas Jalbert, Chris-
tos Stergiou, and Koushik Sen. Looper: Lightweight de-
In Proceedings of
tection of inﬁnite loops at runtime.
the International Conference on Automated Software En-
gineering, pages 161–169. IEEE Computer Society, 2009.

[Carbin et al., 2011] Michael Carbin,

Sasa Misailovic,
Michael Kling, and Martin C Rinard. Detecting and es-
caping inﬁnite loops with jolt. In European Conference on
Object-Oriented Programming, pages 609–633. Springer,
2011.

[Ding et al., 2019] Yi Ding, Jun Jin, Jinglun Zhang, Zhongyi
Wu, and Kai Hu. Sc-rbac: A smart contract based rbac
model for dapps. In International Conference on Human
Centered Computing, pages 75–85. Springer, 2019.

[Feist et al., 2019] Josselin Feist, Gustavo Grieco, and Alex
Groce. Slither: a static analysis framework for smart con-
tracts. In 2019 IEEE/ACM 2nd International Workshop on
Emerging Trends in Software Engineering for Blockchain
(WETSEB), pages 8–15. IEEE, 2019.

[Grishchenko et al., 2018] Ilya Grishchenko, Matteo Maffei,
and Clara Schneidewind. A semantic framework for the
In Inter-
security analysis of ethereum smart contracts.
national Conference on Principles of Security and Trust,
pages 243–269, 2018.

[Hewa et al., 2020] Tharaka Hewa, Mika Ylianttila, and
Madhusanka Liyanage.
Survey on blockchain based
smart contracts: Applications, opportunities and chal-
lenges. Journal of Network and Computer Applications,
page 102857, 2020.

[Hirai, 2017] Yoichi Hirai. Deﬁning the ethereum virtual
machine for interactive theorem provers. In International
Conference on Financial Cryptography and Data Security,
pages 520–535, 2017.

[Ibing and Mai, 2015] Andreas Ibing and Alexandra Mai. A
ﬁxed-point algorithm for automated static detection of inﬁ-
nite loops. In International Symposium on High Assurance
Systems Engineering, pages 44–51. IEEE, 2015.

[Jiang et al., 2018] Bo Jiang, Ye Liu, and WK Chan. Con-
tractfuzzer: Fuzzing smart contracts for vulnerability de-
tection. In ASE, pages 259–269. IEEE, 2018.

[Kalra et al., 2018] Sukrit Kalra,

Seep Goel, Mohan
Dhawan, and Subodh Sharma. Zeus: Analyzing safety of
smart contracts. In NDSS, 2018.
[Kling et al., 2012] Michael Kling,

Sasa Misailovic,
Michael Carbin, and Martin Rinard. Bolt: on-demand in-
ﬁnite loop escape in unmodiﬁed binaries. ACM SIGPLAN
Notices, 47(10):431–450, 2012.

[Liu et al., 2021] Zhenguang Liu, Peng Qian, Xiaoyang
Wang, Yuan Zhuang, Lin Qiu, and Xun Wang. Combining
graph neural networks with expert knowledge for smart

contract vulnerability detection. Transactions on Knowl-
edge and Data Engineering, page Accepted, 2021.

[Lorenz et al., 2018] Breidenbach Lorenz, Daian Phil, Juels
Ari, and Sirer Emin. An in-depth look at the parity
multisig bug. https://hackingdistributed.com/2017/07/22/
deep-dive-parity-bug/, 2018. Accessed: 2021-01-10.
[Luu et al., 2016] Loi Luu, Duc-Hiep Chu, Hrishi Olickel,
Prateek Saxena, and Aquinas Hobor. Making smart con-
tracts smarter. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security,
pages 254–269, 2016.

[Mueller, 2017] Bernhard Mueller. A framework for bug
hunting on the ethereum blockchain. https://github.com/
ConsenSys/mythril, 2017. Accessed: 2021-01-10.

[Qian et al., 2020] P. Qian, Z. Liu, Q. He, R. Zimmermann,
and X. Wang. Towards automated reentrancy detection for
smart contracts based on sequential models. IEEE Access,
8:19685–19695, 2020.

[Rodler et al., 2019] Michael Rodler, Wenting Li, Ghas-
san O. Karame, and Lucas Davi. Sereum: Protecting ex-
isting smart contracts against re-entrancy attacks. In Pro-
ceedings of the NDSS, 2019.

[Tann et al., 2018] Wesley Joon-Wie Tann, Xing Jie Han,
Sourav Sen Gupta, and Yew-Soon Ong. Towards safer
smart contracts: A sequence learning approach to detect-
ing vulnerabilities. CoRR, 2018.

[Tikhomirov et al., 2018] Sergei Tikhomirov,

Ekaterina
Ivan Ivanitskiy, Ramil Takhaviev,
Voskresenskaya,
Evgeny Marchenko,
and Yaroslav Alexandrov.
Smartcheck: Static analysis of ethereum smart con-
tracts. In International Workshop on Emerging Trends in
Software Engineering for Blockchain, pages 9–16. IEEE,
2018.

[Tsankov et al., 2018] Petar Tsankov, Andrei Dan, Dana
Drachsler-Cohen, Arthur Gervais, Florian Buenzli, and
Martin Vechev. Securify: Practical security analysis of
smart contracts. In Proceedings of the 2018 ACM SIGSAC
Conference on Computer and Communications Security,
pages 67–82, 2018.

[Wang et al., 2019] Shuai Wang, Liwei Ouyang, Yong Yuan,
Xiaochun Ni, Xuan Han, and Fei-Yue Wang. Blockchain-
enabled smart contracts: architecture, applications, and fu-
ture trends. IEEE Transactions on Systems, Man, and Cy-
bernetics: Systems, 49(11):2266–2277, 2019.

[Wang et al., 2020] Wei Wang, Jingjing Song, Guangquan
Xu, Yidong Li, Hao Wang, and Chunhua Su. Con-
tractward: Automated vulnerability detection models for
ethereum smart contracts. IEEE Transactions on Network
Science and Engineering, 2020.

[Zhuang et al., 2020] Yuan Zhuang, Zhenguang Liu, Peng
Qian, Qi Liu, Xiang Wang, and Qinming He. Smart con-
tract vulnerability detection using graph neural network.
In IJCAI, pages 3283–3290, 2020.

