Exploiting Ergonomic Priors in Human-to-Robot Task Transfer

Jeevan Manavalan1∗, Prabhakar Ray & Matthew Howard

0
2
0
2

r
a

M
1

]

O
R
.
s
c
[

1
v
4
4
5
0
0
.
3
0
0
2
:
v
i
X
r
a

Abstract— In recent years, there has been a booming shift in
the development of versatile, autonomous robots by introducing
means to intuitively teach robots task-oriented behaviour by
demonstration. In this paper, a method based on programming
by demonstration is proposed to learn null space policies from
constrained motion data. The main advantage to using this is
generalisation of a task by retargeting a systems redundancy
as well as the capability to fully replace an entire system
with another of varying link number and lengths while still
accurately repeating a task subject to the same constraints. The
effectiveness of the method has been demonstrated in a 3-link
simulation and a real world experiment using a human subject
as the demonstrator and is veriﬁed through task reproduction
on a 7DoF physical robot. In simulation, the method works
accurately with even as little as ﬁve data points producing
errors less than 10−14. The approach is shown to outperform
the current state-of-the-art approach in a simulated 3DoF robot
manipulator control problem where motions are reproduced
using learnt constraints. Retargeting of a systems null space
component is also demonstrated in a task where controlling how
redundancy is resolved allows for obstacle avoidance. Finally,
the approach is veriﬁed in a real world experiment using
demonstrations from a human subject where the learnt task
space trajectory is transferred onto a 7DoF physical robot of
a different embodiment.

I. INTRODUCTION

there has been a booming shift

In recent years,
in the
development of versatile, autonomous robots capable of
performing increasingly complex tasks. Such robots are
expected to enhance the capabilities of ordinary people to
introduce automation into their lives by means of intuitively
teaching robots task-oriented behaviour by demonstration
[1], [2].

When humans perform task-oriented movement, it is often
the case that there is a high level of redundancy, with the
number of degrees of freedom (DoF) available to execute
the task usually much higher than those required [3]. For
instance, in the task of opening a drawer (see Fig. 1), the
primary objective is to manipulate the drawer from the closed
to the open position, however, there is redundancy in the
several possible ways this can be achieved. For example,
a human performing this task can adopt different elbow
postures, such as ﬂaring it out at various degrees, while
still managing to move the drawer (Fig. 1(a)). Having this
ﬂexibility is beneﬁcial as it not only allows for multiple ways
of achieving the task, but can also enhance efﬁciency or
robustness, thereby enhancing overall performance.

Humans tend to take advantage of this ﬂexibility in pre-
dictable, stereotypical ways, commonly, seeking to minimise
discomfort or energy expenditure [4], [5]. For instance, in
human drawer opening, despite the variety of postures that
can be taken, it is typical to keep ones wrist straight, to avoid
uncomfortable joint ﬂexion, and ones elbow down, to avoid
working unnecessarily against gravity. Indeed, such features

1Jeevan Manavalan, Prabhakar Ray and Matthew J. Howard are with the
Centre for Robotics Research, Department of Engineering, King’s College
London, London, UK. jeevan.manavalan@kcl.ac.uk

(a)

(b)

Fig. 1: (a) Redundancy in elbow postures when opening
a drawer. In absence of other constraints, humans tend to
avoid using non-ergonomic postures (shown in blue). (b) A
comfortable pose for a human is different to one maximises
manipulability in a robot with different joint limits.

are codiﬁed in human ergonomics literature, to the point that
they shape work environments and policy on safe working
practice [6], [7], [8].

Similarly, a multi-DoF robotic system imitating the human
can adopt different joint conﬁgurations that are consistent
with maintaining the end-effector on the drawer handle,
including those that closely match the human’s posture.
Therefore, the simplest way to have a robot learn is to
match it to the human’s posture as closely as possible when
executing the task. However, such an approach neglects the
differences in embodiment between human and robot that
may lead to sub-optimal performance of the robot [9], [10].
For instance, maintaining a posture in which ones wrist
joint is kept straight (Fig. 1(b)), while comfortable for the
human, may represent a singular posture for the robot that
can lead to dangerous unstable movements. Moreover, for
a robot with geared, non-backdriveable joints, it may cost
little energy to maintain the elbow in a ﬂared posture,
whereas moving the arm to a more human-like, elbow-
down posture may actually expend energy unnecessarily.
Such cases suggest a more nuanced approach to human-
to-robot behaviour transfer is required, that takes explicit
account of the stereotypical features of human movement,
and the desirability, or otherwise, to reproduce them in a
robotic imitator.
To this end,

this paper investigates how stereotypical
features of demonstrators’ posture control can be used to
decompose observed behaviour into task-oriented and re-
dundant components of motion. Speciﬁcally, it presents a
new method for programming by demonstration whereby
explicit use of the underlying null space control policy—
as determined by the stereotypical or ergonomic features—
is used to learn the task and null spaces involved in the
behaviour and their underlying constraints [11], [12]. The
latter allows the original behaviour to be retargeted to an
imitator robot that has a different kinematic embodiment, by
optimising movement according to the robot’s own structure
without causing any interference with the task goal [13].
Numerical and physical evaluations are reported in which

 
 
 
 
 
 
the proposed approach is applied to learn constraints in a
toy experiment where performance on varying data lengths
and noise are evaluated, a simulated 3DoF experiment where
the approach is compared to the state-of-the-art approach, a
demonstration on the beneﬁts of retargeting the system to
resolve redundancy for obstacle avoidance, task reproduction
from a demonstrator system to an imitator of a different
embodiment and ﬁnally a real world experiment where
demonstrations from a human are used to learn and reproduce
the task space motions with a Sawyer, a 7DoF physical robot.
The results indicate that learning in this way outperforms
several state-of-the-art methods [14], [15], [16], [17] in its
ability to accurately learn the decomposition from relatively
little data where in a comparative study the constraint is
learnt from one trajectory of length 2 s (100 data points),
with minimal assumptions made on the form of the data.

II. BACKGROUND & RELATED WORK

A. Stereotypical Movement

In the natural motion of people, it can generally be assumed
that the observed movement will be optimised for efﬁciency
according to their embodiment. In the context of humans
teaching robots task-oriented movements, this means that
postures adopted by a person in the course of a demonstration
are likely to not only meet the requirements of the task, but
also show stereotypical traits that reﬂect the demonstrator’s
embodiment. For instance, human demonstrators will typi-
cally adopt postures that avoid working against gravity, or
limb ﬂexion or extension away from the resting posture of
the limb. The study of postural preferences and stereotypical
movement features in humans has long been studied in the
ﬁeld of human movement science and, is particularly well
documented in the domain of human ergonomics [6], [7].

Note that, these stereotypical features are secondary to
the task—that is, they will tend to be promoted to seek
comfort and minimise fatigue in movement—but are subject
to any applicable task constraints. This means that they
can be inhibited if the task demands it. For example, in
drawer opening,
the default rest posture of the shoulder
is not maintained: since the hand must be lifted to the
drawer handle for the task. Furthermore, if maintaining the
elbow-down posture during opening conﬂicts with the task
(e.g., would result in a collision with a obstacle), then task
space extends to the elbow elevation and overrides the default
behaviour.

This ﬂexibility is a hallmark of human behaviour that
is not currently captured by existing imitation learning
approaches and poses an ongoing challenge. Traditional
imitation learning approaches tend to treat behaviours as
monolithic control policies, and so do not lend themselves
well to task-priorised behaviours [18], [1], [19].

B. Task Prioritised Behaviour

To better capture this task-prioritised view of behaviour,
several studies have recently focused on modelling demon-
strations hierarchically, whereby movement is decomposed
into the task space—the DoF required for the primary task—
and a null space (i.e., the remaining DoF). This draws on
several well-established hierarchical control schemes, such
as Liegeois’ redundant kinemetic control scheme [20], or
Khatib’s Operational Space Formulation [21].

In this view, actions u ∈ RQ are assumed to take the form

u(x) = A†(x)b(x)
(cid:125)
(cid:124)

(cid:123)(cid:122)
v

+ N(x)π(x)
(cid:123)(cid:122)
(cid:125)
w

(cid:124)

(1)

where x ∈ RP represents state (usually represented either in
end-effector or joint space) and A(x) ∈ RS×Q is a matrix
describing a system of S-dimensional constraints

A(x)u(x) = b(x)

and

N(x) := I − A(x)†A(x) ∈ RQ×Q

(2)

(3)

is the null space projection matrix that projects the policy
π(x) onto the null space of A. Here, I ∈ RQ×Q denotes
the identity matrix and A† = A(cid:62)(AA(cid:62))−1 is the Moore-
Penrose pseudo-inverse of A.

In this view, b(x) ∈ RS represents the task space
policy describing the primary task to be accomplished, and
the lumped term v = A†(x)b(x) represents that policy
projected into the conﬁguration space. π(x) represents the
null space policy, that encapsulates any actions in the conﬁg-
uration space secondary to the task. Note that, it is typically
the case that b is unknown (since this is the task that should
be learnt by demonstration), and A (and therefore N) is also
not explicitly known (since this describes the space in which
the unknown task is deﬁned).

The key insight of this paper is that

in many cases,
prior knowledge of π may be assumed, since it commonly
represents the stereotypical features of secondary movements.
Furthermore, as shown in §III, knowledge of π enables
efﬁcient estimation of the other quantities in (1) (v and N)
that can in turn be used to separate out the task-oriented
part of the demonstrations, and thereby replace the secondary
components with a control policy tailored to the imitator’s
embodiment.

C. Learning the Decomposition
Several prior studies have examined the possibility of robot
learning by demonstration using the representation (1)-(3),
and in particular the possibility of learning v or A under the
assumption that only x and u are observable. However, as
noted in §II-A, in many cases such an assumption is overly
stringent and can result in degraded estimation performance.
Depending on the assumptions made on its representation
(see §III-C), one of several learning methods can be used to
estimate A [14], [15], [17]. However, all of these methods,
rely on the ability to separate the lumped task space term v
(or, equivalently, the null space term w) from the demonstra-
tions, and learning performance is highly dependant on the
quality of the separation. These studies rely on the same
approach, ﬁrst proposed by Towell et al. [12], that uses
variations in the task space policy b and consistency in the
null space policy π to form an estimate of the separation.
This has several limitations in practice.

First, for the separation to work, it can be difﬁcult to
ensure that the data is ‘rich’ enough in terms of the variations
seen in the task space policy b. Second, if working with
data which contains different several distinct task-spaces, it
is important to separate the data into subgroups and learn
within each subset individually. However, this diminishes the
learning quality as it tends to make less data available within
each subgroup. These requirements can hamper the methods’

efﬁcacy as increasingly complex systems and constraints are
considered. The approach proposed here does not have such
prerequisites—instead, it exploits prior knowledge of the
control policy π, a component that can often be estimated
through an understanding of stereotypical behaviour or con-
sideration of human ergonomics.

III. METHOD
In this section, a new method is deﬁned for estimating the
null space projection matrix N in redundant systems where
some prior knowledge of the redundancy resolution strategy
is assumed available.

A. Data
The proposed method works on data given as N pairs of ob-
served states xn and actions un collected from task-oriented
movement demonstrations. It is assumed that (i) observations
are in the form presented in (1), (ii) A, N and b are not
explicitly known for any given observation and (iii) π is
known (or a good estimate is available).

As noted in §II, assumption (iii) is reasonable depending
on several factors, including the task at hand and the environ-
ment. In most circumstances, healthy human demonstrators
will tend to perform tasks in a way that promotes comfort. In
the experiments reported here, this tendency is captured by
assuming that the secondary control policy is a point attractor

π(x) = β(x∗ − x)

(4)

where β is a gain matrix and the point of attraction x∗ is a
posture that scores highly according to standard ergonomic
assessment procedures such as Rapid Upper Limb Assess-
ment [8]. While many ergonomic measures are applicable
depending on the experiment, RULA is selected as it is quick
and simple to classify static postures, focuses on the upper
body which is in line with the drawer handling experiments,
and provides a constant
joint posture range for optimal
scoring [22], [23].

B. Learning the Null Space Projection Matrix
The proposed method works by exploiting the orthogonality
between the task and null space parts in (1). Speciﬁcally,
noting that v(cid:62)w = w(cid:62)v = 0, (1) can be written

w(cid:62)u = w(cid:62)v + w(cid:62)w = w(cid:62)w

yielding the identity

w(cid:62)(u − w) = 0.

(5)

(6)

An estimate of N, and therefore the null space component
w, can be formed by choosing ˜w = ˜Nπ consistent with this
identity by minimising1

E[ ˜N] =

N
(cid:88)

n=1

||π(cid:62)
n

˜Nn(un − πn)||.

(7)

This minimisation problem can be solved using various
nonlinear optimisation tools, in this case Matlab’s fmincon
is used with the interior-point algorithm, which is a nonlinear
optimisation solver for constrained multivariable functions.

1For brevity, here, and throughout the paper, the notation an is used to
denote the quantity a evaluated on the nth sample. For example, if a is a
vector quantity computed from the state x, then an = a(xn).

C. Representation of the Constraints
In order to efﬁciently learn ˜N, a suitable representation
needs to be selected. The approach chosen here follows that
ﬁrst proposed by Lin et al. [11], [17] that represents ˜N in
terms of an underlying constraint matrix ˜A according to (3).
This has been shown to be effective both for unstructured
problems (i.e., where the form of the constraint matrix A is
completely unknown) and for situations where some features
(i.e., candidate rows) of A are available.

1) Unit Vector Representation of A: Following [17], if
the form of A is completely unknown, it can be represented
using a (potentially, state-dependent) set of S orthonormal
vectors

2 · · · α(cid:62)
S

1 α(cid:62)
where αs = (as,1, as,2, ..., as,Q) corresponds to the sth
constraint in the observations. The latter can be constructed
iteratively by selecting vectors orthonormal to one another
where the sth vector has the form

(8)

˜A = (cid:2)α(cid:62)

(cid:3)(cid:62)

as,1 = cos θ1
as,2 = sin θ1 cos θ2
as,3 = sin θ1 sin θ2 cos θ3

...

as,Q−1 =

as,Q =

Q−2
(cid:89)

q=1

Q−1
(cid:89)

q=1

sin θq cos θQ−1

sin θq.

(9)

The resultant matrix is represented by a total of P = S(2Q−
S − 1)/2 parameters θ = (θ1, θ2, · · · , θP )(cid:62).

2) Representation of A with Candidate Rows: In the case
that prior information about the form constraint matrix is
available, this can be incorporated into the estimate using
the approach ﬁrst proposed by [11]. Here, a suitable repre-
sentation of the constraint matrix is
˜A = ˜ΛΦ
(10)
where ˜Λ ∈ RS×P is a selection matrix (to be estimated
during learning) and Φ ∈ RP×Q is a (possibly, state-
dependent) feature matrix. The rows of the latter can take
generic forms such as a series of polynomials, or can
contain candidate constraints if there is prior knowledge of
those potentially affecting the system. For instance, one may
choose Φ = J(x), the Jacobian of the manipulator, so that
˜A = ˜ΛJ(x) encodes constraints on the motion of speciﬁc
degrees of freedom in the end-effector space.

D. Estimating the Components of the Behaviour
Once ˜N is estimated, the decomposition of the behaviour into
task-oriented and null space parts is straightforward. The null
space space component is given as
˜w = ˜Nπ

(11)

and the task space part is computed as

˜v = u − ˜w.
(12)
Note that, given the estimate ˜A, ˜N can be computed using
(3), and an estimate of the task space policy ˜b can be
obtained using (2).

E. Substituting the Non-task oriented Behaviour
As noted in §I, in many cases the redundancy resolution
strategy seen in demonstrators’ task-oriented behaviour may
be ill-suited to the robot imitator. The proposed method
provides a simple means of retargeting the behaviour to
the robotic system, while maintaining the task-oriented parts.
Speciﬁcally, this is achieved by replacing the controls (1)
with

u = ˜A† ˜b + ˜Nψ

(13)

where ψ is a (possibly, state-dependent) redundancy resolu-
tion policy for the robot. For instance, ψ could be chosen
so as to avoid robot-speciﬁc joint limits or singularities [13].
Alternatively, if the task space trajectory is predictable, ˜µ
can be used in combination with global optimisation in the
null space [24].

IV. EVALUATION

In this section,
the proposed approach is ﬁrst examined
through a toy experiment, then a more complex 3-link planar
system, before evaluating its performance in the context of
programming by demonstration with a human demonstrator
and a 7DoF physical robot.2

A. Toy Problem

The aim of the ﬁrst evaluation is to test the robustness of the
proposed method using data from a simple, two-dimensional
system with a one-dimensional task space. The set up (based
on [11]) is as follows.

Constrained motion data is gathered from a two-
dimensional system with a one-dimensional constraint A =
α ∈ R1×2. Movement in the task space is deﬁned by the
constraint matrix and occurs in the direction of the unit
vector ˆα = (cos θ, sin θ). This direction is selected from
a uniform-random distribution θ ∼ U [0◦, 180◦] at the start
of each trial. The task space policy is a linear point attractor
b(x)i = r∗ − r, i ∈ {1}, where r is the position in the task
space and r∗ is the target point. To simulate varying tasks,
the task space targets are selected randomly r∗ ∼ U [−2, 2]
for each trial.

In the below, learning performance is reported for three

different secondary control policies π, namely,

1) A linear policy: π(x) = −L¯x where ¯x := (x(cid:62), 1)(cid:62))

and L = ((2, 4, 0)(cid:62), (1, 3, −1)(cid:62))(cid:62)).

2) A limit cycle:

˙ρ = ρ(ρ0 − ρ2) with radius ρ0 =
0.75 m, angular velocity φ = 1 rad/s, where ρ and
φ are the polar representation of the state, i.e., x =
(ρ cos φ, ρ sin φ)(cid:62).

3) A non-linear (sinusoidal) policy:

π = (cos z1 cos z2, − sin z1 sin z2)(cid:62) where z1 = πx1
and z2 = π(x2 + 1

2 ).

The training data consists of 150 data points, drawn uni-
form randomly across the space (x)i ∼ U [−1, 1], i ∈ {1, 2}.
For testing, a further 150 data points are used, generated
through the same procedure as above. The constraint is learnt
by ﬁnding a θ which minimises (7). In each trial performance
is measured using two metrics. First, the normalised mean

2The data

supporting this
at
London

College

Kings
made available on acceptance]. Further
the data
research.data@kcl.ac.uk.

and conditions of

research are openly available

from
http://doi.org/[link to be
about
found by emailing

information

can be

access

TABLE I: Test data NMSE in ˜w (mean±s.d.)×10−15 and
E ˜N (mean±s.d.)×10−8 over 50 trials for different π.
E ˜w
1.2147 ± 2.6458
0.5462 ± 0.7043
0.3020 ± 0.5741

E ˜N
0.4263 ± 1.3396
1.1616 ± 1.1682
1.6685 ± 1.9316

π
Linear
Limit-cycle
Sinusoidal

squared error (NMSE) in the estimated null space component
is evaluated3

E ˜w =

1
N

N
(cid:88)

n=1

||(wn − ˜wn) (cid:11) σu||2.

(14)

where σu ∈ RQ is a vector containing the element-wise
standard deviation of the observations u. Note that, as wn =
Nnπn and ˜wn = ˜Nnπn, this measure is equal to the
normalised projected policy error [17].

Second, the normalised error measure (7) is evaluated

E ˜N =

1
N ||σu||2

N
(cid:88)

n=1

||π(cid:62)
n

˜Nn(un − πn)||.

(15)

It indicates the performance of the minimisation function
using only known information from given data and is there-
fore applicable for practical application. 4 The experiment is
repeated 50 times.

The NMSE in ˜w and E ˜N are presented in Table I. As can
be seen, ˜N is successfully estimated with errors in ˜w less
than 10−14 and ˜N with less than 10−7 for all of the policies
considered. These low errors shows that the constraint matrix
can be estimated with very high precision if knowledge of
π is available. The overall performance of ˜w is seen to
be very roughly around twice as accurate as E ˜N, which
shows that the task and null space components can generally
be reproduced with greater accuracy than indicated by just
evaluating E ˜N.

To further characterise the performance of the proposed
approach, the experiment is repeated with (i) data sets of
varying sizes (5 < N < 250), (ii) varying levels of noise in
the training data un represented as N (0, (cid:15)σ2
u) additive white
Gaussian noise where 0 < (cid:15) < 0.14 and (iii) varying levels
of noise in the estimated πn where 0 < (cid:15) < 0.15 for 50
trials using the limit cycle policy. The latter case simulates
error in the assumed π and thereby allows evaluation of the
proposed approach in face of an inaccurate estimate of the
true underlying redundancy resolution strategy. The results
are plotted in Fig. 2.

As shown in Fig. 2(a), the NMSE in ˜w is less than 10−14
for both mean and standard deviation with as few as ﬁve
data points. As the number of data points increases, so does
the accuracy for minimising ˜w where the performance of
the method seems to plateau after around 25 data points.
This shows that the approach can learn constraints with as
few as ﬁve data points and for optimal performance with at
least around 25 data points. Fig. 2(b) shows errors of less
10−7 for both mean and standard deviation in ˜N. It follows

3The notation C = A (cid:11) B denotes Hadamard (element-wise) division

of A by B, i.e., (C)ij = (A)ij /(B)ij .

4To evaluate the ﬁtness of ˜v, noting that v + w = ˜v + ˜w can be written
as v − ˜v = −w + ˜w returns the identity v − ˜v = −(w − ˜w), where the
error in both components are opposites. Thus, results for the ﬁtness of ˜w
can also be considered the same for ˜v and therefore ˜v is omitted.

(a)
Fig. 2: NMSE in ˜w and E ˜N (mean±s.d. over 50 trials) for (a) increasing number of data points for E ˜w, (b) increasing
number of data point for E ˜N, (c) increasing noise levels in u and (d) increasing noise levels in π. Mean results are plotted
as thick lines and their respective standard deviation are the shaded areas of a similar lighter tone.

(d)

(b)

(c)

a similar trend to the previous evaluation with respect to
accurate learning with as few as ﬁve data points and optimal
performance after at least around 25 data points. It can also
be observed that the learning performance is very roughly
half compared to E ˜w which was also observed in Table I.
Looking at Fig. 2(c), there is a clear trend with a degrading
mean accuracy and greater standard deviation as the noise
in u increases. The mean error in ˜w stays below 0.1 when
(cid:15) <= 0.14 and for mean error in ˜N when (cid:15) <= 0.13. It can
also been seen that the error in ˜N is greater compared to ˜w
in most cases which is in agreement with prior experiments.
Looking at Fig. 2(d), the accuracy decreases, with greater
standard deviation, as the error in the assumed π increases.
The mean error in ˜w stays below 0.1 when (cid:15) < 0.05, however
when (cid:15) <= 0.1 only 2 mean values are shown to produce
an error above 0.1. The mean E ˜N stays below 0.1 when
(cid:15) <= 0.08 and only has a single instance where the mean
value is above 0.1 where (cid:15) <= 0.1. Comparing E ˜w and
E ˜N, while both have similar mean performance, the standard
deviation of E ˜N is noticeably smaller. This is expected, as
E ˜N relies on knowledge of the noisy estimate of π to obtain
˜N, whereas E ˜w compares this to the true π to present the
error within the estimated null space component.

B. Simulated Three Link Planar Arm
The aim of the next evaluation is to test the performance of
the proposed method on a more complex system with non-
linear constraints which simulates a real world system more
accurately. The set up is as follows.

Constrained motion data is gathered from a kinematic
simulation of a three-link planar robot with uniform links
of length 10 cm. The state and action space refer to the joint
angle position and velocities, respectively, i.e., x := q ∈ R3
and u := ˙q ∈ R3. The task space is described by the
coordinates r = (rx, ry, rθ)(cid:62) referring to the end-effector
positions and orientation, respectively. The simulation runs
at a rate of 50 Hz.

Joint space motion of the system is recorded as it performs
tasks under different constraints in the end-effector space.
Speciﬁcally, a task constraint at state x is described through

A(x) = ΛJ(x)
(16)
where J ∈ R3×3 is the manipulator Jacobian, and Λ ∈
R3×3 is a diagonal selection matrix, with elements λ =
(λx, λy, λθ)(cid:62) along the diagonal, indicating which coordi-
nates should be included in (λi = 1) or excluded from
(λi = 0) the task space. In the results reported below, the
following six selection matrices are considered: (i) Λx where
λ = (1, 0, 0)(cid:62), (ii) Λy where λ = (0, 1, 0)(cid:62), (iii) Λθ where

TABLE II: Mean ±s.d. E ˜w and E ˜N on testing data for
different null space policies over 50 trials. The ﬁgures for E ˜w
are (mean±s.d.)×10−11 and for E ˜N are (mean±s.d.)×10−7.

π
Λx
Λy
Λθ
Λx,y
Λx,θ
Λy,θ

E ˜w
0.0741 ± 0.0291
12.1467 ± 18.6578
0.1496 ± 0.3732
5.6114 ± 10.3401
0.0139 ± 0.0320
0.0476 ± 0.1357

E ˜N
1.1527 ± 2.3654
11.1195 ± 9.1619
0.2445 ± 0.1700
5.1969 ± 6.5849
0.8522 ± 1.0982
0.6719 ± 0.6424

λ = (0, 0, 1)(cid:62), (iv) Λx,y where λ = (1, 1, 0)(cid:62), (v) Λx,θ
where λ = (1, 0, 1)(cid:62), and (vi) Λx,θ where λ = (0, 1, 1)(cid:62).
To simulate demonstrations of reaching behaviour,
the
robot end-effector starts from a point chosen uniform-
randomly q1 ∼ U [0◦, 10◦], q2 ∼ U [90◦, 100◦], q3 ∼
U [0◦, 10◦] to a task space target r∗ following a linear point
attractor policy

b(x) = r∗ − r

(17)

where r∗ is drawn uniformly from r∗
U [0, 2], r∗
a simple point attractor of the form

y ∼
θ ∼ U [0◦, 180◦]. As the secondary control policy

x ∼ U [−1, 1], r∗

π(x) = β(x∗ − x)
(18)
is used, where x∗ is arbitrarily chosen as x1 = 10◦, x2 =
−10◦, x3 = 10◦ and β = 1. For each of the cases (i)–(vi)
above, 100 trajectories are generated each containing 50 data
points, with 50% of the samples provided for learning and
the remainder reserved as unseen testing data. Finally, this
whole experiment is repeated 50 times.

The NMSE in ˜w and E ˜N on the testing data are presented
in Table II. As shown, the constraints are successfully learnt
with E ˜w less than 10−9 and E ˜N less than 10−5 in all cases.
The E ˜w is roughly half of the E ˜N which is in agreement
with previous experiments. Overall, the constraint matrix
can be accurately estimated using data from the observed
demonstrations and knowledge of the control policy, without
having to explicitly know how the constraints affect the
system’s motions.

To further evaluate the performance of the proposed
method, it is compared to the current state-of-the-art. As
discussed in §II-C, while there are many applicable methods
to learn the constraint matrix with acceptable performance
including [11], they all rely on the method proposed in [12]
for separation of the observed actions. Following [12], Fig. 3
shows an example of using a learnt constraint to generate
a new trajectory. In this experiment, the new trajectory is

reproduced using ˜A which is learnt from a separate training
data set, u, x and π, where the latter three are given. Firstly,
training data consists of one trajectory of length 2 s (100 data
points) with a random constraint in x, y. Using the state-
of-the-art approach in [12], u is separated into the task and
null space components. Now that the null space component is
learnt, it is used with u, x and the approach in [11] to obtain
˜A. On the other hand, the novel approach uses u, x and π to
directly obtain ˜A. Now that both approaches have resulted in
a learnt constraint, a ground-truth test trajectory is produced
subject to the same true constraints in x, y of the training
data. Its start pose is q1 = 90◦, q2 = 45◦, q3 = −20◦ and
the x, y position of the end-effector moves towards the target
point (15, 10)(cid:62) which reaches convergence in 4 seconds. To
compare the novel and literature approach, both use x of this
ground-truth data to start at the same position. Both produce
˜v with their respectively learnt ˜A and use this with u to
estimate ˜b following (2). The literature approach already has
˜w which was obtained using [12]. The novel approach uses
(3) to obtain ˜N and uses the known π to produce ˜w. Both
approaches use this information to iteratively reproduce the
ground-truth data and similarly run for 4 seconds which is
shown in Fig. 3(a) and Fig. 3(b). This experiment is repeated
for a constraint in θ shown in Fig. 3(c) and Fig. 3(d).

As can be seen in Fig. 3(a) and Fig. 3(b), the proposed
approach is shown alongside the true policy as well as the
current state-of-the-art [12] for comparison. The new method
follows the true joint trajectories accurately. The state-of-
the-art approach on the other hand takes a different route
in both the end effector trajectory as well as joint space
leading to a different target. In Fig. 3(c) and Fig. 3(d), the
task space target is set as the orientation of the end-effector
which moves towards the target angle of 45◦. The novel
approach accurately reproduces the movements under this
1DoF constraint unlike the state-of-the-art method in [12]
and [11].

As mentioned in §III-E, the proposed approach allows
retargeting of task-oriented behaviour by substituting the
demonstrator’s redundancy resolution strategy with one
better-suited to the robot. More concretely, consider the
scenario where it is desired to reproduce a demonstrated
reaching movement (i) with a robot with identical embod-
iment to the demonstrator, but is located right next to an
obstacle (such that there is the risk of collision, see Fig. 4(a)),
and (ii) with a robot that has a different kinematic structure
to the demonstrator (here, different numbers and lengths
of links). In the following, the feasibility of retargeting to
these scenarios is assessed. As the reaching movement to be
reproduced, a typical trajectory is taken from the training
data (given in the absence of any obstacles) described
above. Speciﬁcally, the example chosen uses Λ = Λx,y,
w derived from the policy (18), r∗ = (−9.12, 3.89)(cid:62) and
q = (8.67◦, 94.18◦, −2.32◦)(cid:62). This movement is retargeted
by using the learnt ˜A to derive ˜b, and then applying (13)
with a replacement null space control policy.

located next

In the case of the robot

to an obstacle,
retargeting simply consists of selecting an appropriate null-
space control policy ψ. Here, ψ(x) = βr(x∗
r − x) is
used, where βr = 5 and x∗
r = (−320◦, 100◦, 50◦)(cid:62). The
resultant movements with and without retargeting are shown
in Fig. 4(a) (blue and red ﬁgures, respectively). As can be
seen, were the arm to directly imitate the demonstration (red

(a)

(b)

(d)

(c)
Fig. 3: Reproducing the ground-truth movement (dotted-
black) in both learnt task and null space using the pro-
posed method (solid-red) and the state-of-the-art method
[12] (dashed-blue) to learn the null space component and
constraint A to obtain b [11]. (a) Arm visualisation for
example task under constraint space r = (x, y), (b) Joint
in task space
angle positions during example movement
r = (x, y), (c) Arm visualisation for example task under
constraint space r = θ and (d) Joint angle positions during
example movement in task space r = θ.

(b)

(a)
Fig. 4: Retargeting behaviour with an imitator robot (a) with
the same embodiment as the demonstrator but located near
to an obstacle, and (b) with a different kinematic structure.
The demonstrated movement is illustrated in red, while that
of the imitators is in blue. The yellow region indicates an
obstacle.

ﬁgure) a collision would occur (second and third links over-
lap with the yellow region). This could not only jeopardise
the success of the task but also potentially cause damage
to the system. In contrast, starting at the same start point,
the retargeted controller (blue ﬁgure) successfully completes
the task (converges to the same target point in end-effector
space), however, by resolving its redundancy differently it
avoids the collision.

In the case of the robot with the different kinematic
structure, retargeting is achieved as follows. As noted above,
the constraint
in this system is represented in the form
(10) where the feature matrix is selected as the Jacobian
of the demonstrator’s embodiment (i.e., Φ = J) and the
selection matrix ˜Λ is learnt. Since the rows of Φ represent
meaningful quantities (here, the relationship between the
joint space and the end-effector position and orientation) a

Fig. 5: Sample ﬂow of obtaining natural demonstration data from user. Video of the subject is recorded during the action of
repeatedly opening and closing drawers of various heights to different lengths. After collection, the video feed is overlaid
with a skeleton using Openpose [25] to obtain the positions of body parts such that joint angles and trajectories can be
extracted into Matlab. The shoulder, elbow and wrist joint angles are used to learn the constraints contained within the set
of demonstrations.

†Ar)ψ.

u = A†
r

correspondence is drawn between these and the equivalent
quantities for the new arm (e.g., if the ﬁrst row of J relates
to the Jacobian for the rx coordinate, the corresponding row
of the Jacobian Jr for the imitator is selected), and Ar
is constructed accordingly. Substituting into (13) gives the
controller

˜b + (I − Ar
is taken to be a
the imitator robot
In this evaluation,
7-DoF arm with link lengths 10, 5, 5, 5, 5, 5 and
10 cm, and ψ == βr(x∗
r − x), where βr = 1
r = (−10◦, −10◦, −10◦, −10◦, −10◦, −10◦, −10◦)(cid:62).
and x∗
the initial end-
The start posture is chosen such that
effector position matches
the demonstration
(i.e., q = (0◦, 90◦, −90◦, 85◦, 90◦, −1◦, −81.5◦)(cid:62)). The
resultant movement is shown in Fig. 4(b). As can be seen,
despite the signiﬁcant difference in embodiment, the task-
oriented part of the movement is effectively reproduced,
while the imitator-speciﬁc null space controller appropriately
handles the added redundancy.

that of

(19)

C. Real World Human Arm
The aim of this ﬁnal experiment is to test the performance
of the proposed approach in the real world using data from
a human demonstrator. The set up is as follows.

The task chosen for this experiment is to teach a robotic
system the skill of opening and closing a three-tiered set of
drawers (see Fig. 5). To collect data, the demonstrator stands
in front of the drawers at approximately an arm’s length
distance. The starting state of each drawer is randomised
(varying from anywhere between fully closed to completely
open). Starting with the top drawer it is moved a random
distance in the opening or closing direction. This is repeated
for each of the drawers producing a total three trajectories
which are used for learning a model. A side view of this is
recorded from a single 12MP phone camera (with a sensor of
1.4µm pixels and aperture of f/1.7) placed roughly 1 m away
from the demonstrator. The video data is then post-processed
to overlay a skeleton using Openpose [25] to estimate the
joint lengths and extract the joint angles and velocities during
movement. Constrained motion data of movement in the
sagittal plane is gathered from three joints of the demonstra-
tor’s arm, by observing ﬂexion and extension of the shoulder,
elbow and wrist (as well as abduction and adduction of the
wrist depending on the forearms pronation/supination. This
yields an average of 11 frames per trajectory which translates
into 11 data points.

Now that the data is collected, to set it up for learning,
the joint angles of the demonstrator are treated as the
state x := q ∈ R3 and the joint velocities as the action
u := ˙q ∈ R3. The task space is described by the end-
effector coordinates r = (rx, ry, rθ)(cid:62) referring to the hand
position and orientation, respectively. The task constraints
are described in the form (16), where J ∈ R3×3 is the
manipulator Jacobian of the demonstrator. To construct the
Jacobian which simulates the demonstrator as a system, the
link lengths are calculated from the skeleton in Openpose for
each frame. As these can vary from frame to frame depending
on obscurities in the demonstrators pose and imprecision of
Openpose, the mean of the joint lengths at every frame for the
3 trajectories are used. Moreover, when translating recorded
movements from pixels to the x and y axis in Matlab, joint
lengths are extremely large where the upper arm measures at
around 30 meters. Therefore the scale of these joint lengths
are proportionally reduced to around 10cm by dividing each
by 300. Λ ∈ R3×3 is the selection matrix specifying the
coordinates to be constrained. In this experiment, Λx,y repre-
sents the ground truth, since the end-effector (demonstrator’s
hand) must be maintained at the height y of the drawer
handle (y changes in each demonstration depending on the
which drawer is being manipulated), and x is the task space
in which opening or closing action occurs. It is assumed
that the control policy in w is resolved by the subject with
joint pose
comfort
in mind and moves towards a target
following (18) with x∗ = (−90◦, 90◦, 0◦)(cid:62). This posture
is chosen as it lies in the middle of each joints optimal
range following RULA, resulting in a high score according to
RULA’s standard ergonomic assessment procedure [8] (see
§II).

Since the human demonstrations are modelled as a system
with its respective Jacobian matrix, u, x and π, it can be
evaluated like any other robotic system presented so far [26],
[27]. The experiment is repeated 45 times yielding a total of
135 trajectories (45 repetitions for each of the 3 drawers).
This is done to verify that the performance of learning the
constraints is consistent.

The true decomposition of the behaviour, (i.e., v and
w) are not known, however they can be estimated using
Λx,y. The initial aspect that can be evaluated is the E ˜w,
however the variance in u is quite small and thus E[ ˜N]
from (7) is reported which is 6.3329 ± 5.7832(mean±s.d.).
the correct constraints are
Looking at
consistently learnt using the novel approach. To demonstrate

the learnt Λ,

REFERENCES

[1] B. D. Argall, S. Chernova, M. Veloso, and B. Browning, “A survey
learning from demonstration,” Robotics and Autonomous

of robot
Systems, vol. 57, no. 5, pp. 469–483, 2009.

[2] A. Sena and M.H., “Quantifying teaching behaviour in robot learning

from demonstration,” Int. J. Robotics Res., 2020.

[3] H. Cruse and M. Brwer, “The human arm as a redundant manipulator:
The control of path and joint angles,” Biological cybernetics, vol. 57,
pp. 137–44, 02 1987.

[4] R. Ranganathan, A. Adewuyi, and F. A. Mussa-Ivaldi, “Learning to be
lazy: Exploiting redundancy in a novel task to minimize movement-
related effort,” Journal of Neuroscience, vol. 33, no. 7, pp. 2754–2760,
2013.

[5] J. Soechting, C. Buneo, U. Herrmann, and M. Flanders, “Moving
effortlessly in three dimensions: does donders’ law apply to arm
movement?” Journal of Neuroscience, vol. 15, no. 9, pp. 6271–6280,
1995.

[6] A. Shafti, A. Ataka, B. U. Lazpita, A. Shiva, H. A. Wurdemann, and
K. Althoefer, “Real-time robot-assisted ergonomics,” in ICRA, 2019.
[7] M. Robertson, B. Amick, K. DeRango, T. Rooney, L. Bazzani,
R. Harrist, and A. Moore, “The effects of an ofﬁce ergonomics
training and chair intervention on worker knowledge, behavior and
musculoskeletal risk,” Applied ergonomics, vol. 40, pp. 124–35, 04
2008.

[8] M. Middlesworth, “A step-by-step guide to the rula assessment tool,”
2019. [Online]. Available: https://ergo-plus.com/rula-assessment-tool-
guide/

[9] Y. Zhao, A. Sena, F. Wu, and M. Howard, “A framework for teaching
impedance behaviours by combining human and robot best practice,”
in 2018 IEEE/RSJ International Conference on Intelligent Robots and
Systems (IROS).
IEEE, 10 2018, pp. 3010–3015.

[10] M. Howard, D. Braun, and S. Vijayakumar, “Transferring human
impedance behavior to heterogeneous variable impedance actuators,”
IEEE Transactions on Robotics, vol. 29, no. 4, pp. 847–862, 2013.

[11] H. C. Lin, P. Ray, and M. Howard, “Learning task constraints in

operational space formulation,” in ICRA, 2017, pp. 309–315.

[12] C. Towell, M. Howard, and S. Vijayakumar, “Learning nullspace

policies,” in IROS, 2010, pp. 241–248.

[13] J. Manavalan and M. Howard, “Learning singularity avoidance,” in
IEEE/RSJ International Conference on Intelligent Robots and Systems,
2019.

[14] L. Armesto, J. Bosga, V. Ivan, and S. Vijayakumar, “Efﬁcient learning
of constraints and generic null space policies,” in ICRA, 2017, pp.
1520–1526.

[15] H. C. Lin, S. Rathod, and M. Howard, “Learning state dependent

constraints,” in IEEE T-Ro, 2016.

[16] J. Manavalan and M. Howard, “Learning null space projections fast,”

in ESANN, 2017.

[17] H.-C. Lin, M. Howard, and S. Vijayakumar, “Learning null space

projections,” in ICRA, 2015, pp. 2613–2619.

[18] A. Hussein, M. Gaber, E. Elyan, and C. Jayne, “Imitation learning:
A survey of learning methods,” ACM Computing Surveys, vol. 50, 04
2017.

[19] S. Schaal, A. Ijspeert, and A. Billard, “Computational approaches to
motor learning by imitation.” Philos Trans R Soc Lond B Biol Sci, vol.
358, no. 1431, pp. 537–547, March 2003.

[20] A. Li´egeois, “Automatic supervisory control of the conﬁguration and
behavior of multibody mechanisms,” IEEE Transactions on Systems,
Man, and Cybernetics, vol. 7, pp. 868–871, 1977.

[21] O. Khatib, “A uniﬁed approach for motion and force control of robot
manipulators: the operational space formulation,” IEEE Journal of
Robotics and Automation, vol. RA-3, no. 1, pp. 43–53, December
1987.

[22] L. Mcatamney and E. Nigel Corlett, “Rula: A survey method for the in-
vestigation of work-related upper limb disorders,” Applied ergonomics,
vol. 24, pp. 91–9, 05 1993.

[23] L. McAtamney and E. N. Corlett, “Rula: a survey method for the inves-
tigation of work-related upper limb disorders,” Applied Ergonomics,
vol. 24, no. 2, pp. 91 – 99, 1993.

[24] Y. Nakamura, Advanced Robotics: Redundancy and Optimization.

Addison-Wesley Publishing Company, 1991.

[25] Z. Cao, G. Hidalgo, T. Simon, S.-E. Wei, and Y. Sheikh, “OpenPose:
realtime multi-person 2D pose estimation using Part Afﬁnity Fields,”
in arXiv preprint arXiv:1812.08008, 2018.

[26] B. Lee, “A mouse with two optical sensors that eliminates coordinate
disturbance during skilled strokes,” Human-Computer Interaction,
vol. 30, 03 2014.

[27] A. Gams and J. Lenarcic, “Humanoid arm kinematic modeling and
trajectory generation,” in IEEE/RAS-EMBS International Conference
on Biomedical Robotics and Biomechatronics, 2006, pp. 301 – 305.

trajectory is

the learnt constraint

Fig. 6: 3DoF Human to 7DoF Sawyer Robot task transfer
is used to produce ˜b and the
this,
task-oriented trajectory is reproduced on the Sawyer, a
7DoF revolute physical robotic system with a maximum
reach of 1260mm and precision of ±0.1mm. A closing
of a drawer
selected from the human
demonstration data. J ∈ R3×7 is the manipulator Jacobian
where a correspondence is drawn between these and the
human arms decomposed Jacobian. The start pose is q =
(−3.89◦, 42.82◦, 25.48◦, −76.96◦, −8.23◦, 32.82◦, 88.93◦)(cid:62).
ψ == βr(x∗
r − x), where βr = 1 and x∗
r =
(−70.29◦, −32.47◦, −15.92◦, 53.24◦, −32.55◦, −17.48◦,
− 68.23◦)(cid:62). The resulting trajectory is presented in Fig. 6.
As shown, the Sawyer is able to reproduce the task space
component of closing the drawer using its own embodiment
and a different π to resolve redundancy subject to the same
task constraints.

V. CONCLUSION
In this paper, a method based on programming by demon-
stration is proposed to learn null space policies from con-
strained motion data. The main advantage to using this is
the retargeting of not only the systems redundancy resolution
but also the entire system itself with another of a different
embodiment which can repeat a task accurately while being
subject to the same constraints. On a lesser note, this pro-
posed approach can be used to learn directly from observed
actions without the need to decompose motion data into a
task and null space component.

The effectiveness of the method has been demonstrated in
a simulated toy experiment, a 3-link simulation and a real
world experiment using data collected from a human demon-
strator which is validated through task-oriented reproduction
on a 7DoF physical robot. All experiments are in agreement
that the constraints can be learnt from demonstration. In
addition, the evaluations show that the method can (i) learn
with very little data (E ˜w below 10−14 with just ﬁve data
points) and (ii) handle noise (E ˜w below 10−1 with nor-
malised additive white gaussian noise below 0.15). In a com-
parative experiment, the approach is shown to outperform the
current state-of-the-art approach in a simulated 3DoF robot
manipulator control problem where motions are reproduced
using the learnt constraints. It is also used to demonstrate
retargeting of a systems null space component to resolve
redundancy such that an obstacle can be avoided. Moreover,
retargeting through the learnt constraints from the simulated
3DoF demonstrator to a 7DoF robot imitator of different
embodiment is shown. Finally, the approach is veriﬁed in a
real world experiment where demonstrations from a human
subject are used to consistently learn the constraint matrix,
which allows for accurate decomposition of the demonstrated
task space and task-oriented reproduction on the Sawyer, a
7DoF physical robot with a different embodiment.

Future work looks at conducting a study with na¨ıve sub-
jects and a more in-depth look at estimating control policies
to resolve redundancy.

