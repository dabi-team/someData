1
2
0
2

t
c
O
6

]
h
p
-
t
n
a
u
q
[

2
v
8
4
4
8
0
.
1
0
1
2
:
v
i
X
r
a

Noisy intermediate-scale quantum (NISQ) algorithms

Kishor Bharti,1, ∗ Alba Cervera-Lierta,2, 3, ∗ Thi Ha Kyaw,2, 3, ∗ Tobias Haug,4 Sumner Alperin-Lea,3 Abhinav
Anand,3 Matthias Degroote,2, 3, 5 Hermanni Heimonen,1 Jakob S. Kottmann,2, 3 Tim Menke,6, 7, 8 Wai-Keong
Mok,1 Sukin Sim,9 Leong-Chuan Kwek,1, 10, 11, † and Alán Aspuru-Guzik2, 3, 12, 13, ‡
1Centre for Quantum Technologies, National University of Singapore 117543, Singapore
2Department of Computer Science, University of Toronto, Toronto, Ontario M5S 2E4, Canada
3Chemical Physics Theory Group, Department of Chemistry, University of Toronto, Toronto, Ontario M5G 1Z8, Canada
4QOLS, Blackett Laboratory, Imperial College London SW7 2AZ, UK
5current address: Boehringer Ingelheim, Amsterdam, Netherlands
6Department of Physics, Harvard University, Cambridge, MA 02138, USA
7Research Laboratory of Electronics, Massachusetts Institute of Technology, Cambridge, MA 02139, USA
8Department of Physics, Massachusetts Institute of Technology, Cambridge, MA 02139, USA
9Department of Chemistry and Chemical Biology, Harvard University, Cambridge, MA 02138, USA
10MajuLab, CNRS-UNS-NUS-NTU International Joint Research Unit UMI 3654, Singapore
11National Institute of Education and Institute of Advanced Studies, Nanyang Technological University 637616, Singapore
12Vector Institute for Artiﬁcial Intelligence, Toronto, Ontario M5S 1M1, Canada
13Canadian Institute for Advanced Research, Toronto, Ontario M5G 1Z8, Canada

(Dated: October 7, 2021)

A universal fault-tolerant quantum computer that can solve eﬃciently problems such as
integer factorization and unstructured database search requires millions of qubits with
low error rates and long coherence times. While the experimental advancement towards
realizing such devices will potentially take decades of research, noisy intermediate-scale
quantum (NISQ) computers already exist. These computers are composed of hundreds
of noisy qubits, i.e. qubits that are not error-corrected, and therefore perform imperfect
operations in a limited coherence time. In the search for quantum advantage with these
devices, algorithms have been proposed for applications in various disciplines spanning
physics, machine learning, quantum chemistry and combinatorial optimization. The goal
of such algorithms is to leverage the limited available resources to perform classically
challenging tasks.
In this review, we provide a thorough summary of NISQ compu-
tational paradigms and algorithms. We discuss the key structure of these algorithms,
their limitations, and advantages. We additionally provide a comprehensive overview
of various benchmarking and software tools useful for programming and testing NISQ
devices.

CONTENTS

I. Introduction

A. Computational complexity theory in a nutshell
B. Experimental progress
C. NISQ and near-term
D. Scope of the review

II. Building blocks of variational quantum algorithms

A. Objective function

1. Pauli strings
2. Fidelity
3. Other objective functions

B. Parameterized quantum circuits

1. Problem-inspired ansätze
2. Hardware-eﬃcient ansätze

C. Measurement
D. Parameter optimization

1. Gradient-based approaches
2. Gradient-free approaches

2
3
3
5
5

6
6
6
7
8
8
9
11
12
14
14
16

∗ These authors contributed equally to this work.

kishor.bharti1@gmail.com
thihakyaw.phy@gmail.com

† cqtklc@gmail.com
‡ alan@aspuru.com

a.cervera.lierta@gmail.com

3. Resource-aware optimizers

III. Other NISQ approaches
A. Quantum annealing
B. Gaussian boson sampling

1. The protocol
2. Applications

C. Analog quantum simulation
1. Implementations
2. Programmable quantum simulators
D. Digital-analog quantum simulation and

computation

E. Iterative quantum assisted eigensolver

IV. Theoretical challenges

A. Barren plateaus
B. Expressibility of variational ansätze
C. Reachability
D. Theoretical guarantees of the QAOA algorithm

V. Programming and Maximizing NISQ utility
A. Quantum error mitigation (QEM)
1. Zero-noise extrapolation
2. Probabilistic error cancellation
3. Other QEM strategies

B. Circuit compilation

1. Native and universal gate sets
2. Circuit decompositions
3. The qubit mapping problem

16

17
17
19
19
20
20
21
21

21
22

23
23
24
25
25

26
26
26
28
29
31
31
32
32

 
 
 
 
 
 
4. Resource-aware circuit design

C. Quantum software tools

VI. Applications

A. Many-body physics and chemistry

1. Qubit encodings
2. Constructing electronic Hamiltonians
3. Variational quantum eigensolver
4. Variational quantum eigensolver for excited

states

5. Hamiltonian simulation
6. Quantum information scrambling and

thermalization

7. Simulating open quantum systems
8. Nonequilibrium steady state
9. Gibbs state preparation

10. Simulation of topological phases and phase

transitions

11. Many-body ground state preparation
12. Quantum autoencoder
13. Quantum computer-aided design

B. Machine learning

1. Supervised learning
2. Unsupervised learning
3. Reinforcement learning
C. Combinatorial optimization

1. Max-Cut
2. Other combinatorial optimization problems

D. Numerical solvers

1. Variational quantum factoring
2. Singular value decomposition
3. Linear system problem
4. Non-linear diﬀerential equations

E. Other applications

1. Quantum foundations
2. Quantum optimal control
3. Quantum metrology
4. Fidelity estimation
5. Quantum error correction
6. Nuclear physics
7. Entanglement properties

VII. Benchmarking

A. Randomized benchmarking
B. Quantum volume
C. Cross-entropy benchmarking
D. Application benchmarks

VIII. Outlook

A. NISQ goals
B. Long-term goal: fault-tolerant quantum computing

Acknowledgements

References

Appendices

A. NISQ algorithms and tools tables

A. Tables of applications
B. Table of software packages
C. Table of external libraries

B. Classical optimization strategies

A. Gradient-based approaches
B. Gradient-free approaches
C. Resource-aware optimizers

C. NISQ Applications for Finance
A. Portfolio optimization
B. Fraud detection

D. Unitary t-design

I. INTRODUCTION

2

90

Quantum computing originated in the eighties when
physicists started to speculate about computational mod-
els that integrate the laws of quantum mechanics (Kaiser,
2011). Starting with the pioneering works of Benioﬀ and
Deutsch, which involved the study of quantum Turing
machines and the notion of universal quantum computa-
tion (Benioﬀ, 1980; Deutsch, 1985), the ﬁeld continued to
develop towards its natural application: the simulation of
quantum systems (Feynman, 1982; Lloyd, 1996; Manin,
1980). Arguably, the drive for quantum computing took
oﬀ in 1994 when Peter Shor provided an eﬃcient quantum
algorithm for ﬁnding prime factors of composite integers,
rendering most classical cryptographic protocols unsafe
(Shor, 1994). Since then, the study of quantum algo-
rithms has matured as a sub-ﬁeld of quantum computing
with applications in search and optimization, machine
learning, simulation of quantum systems and cryptogra-
phy (Montanaro, 2016).

In the last forty years, many scientiﬁc disciplines
have converged towards the study and development of
quantum algorithms and their experimental realization.
Quantum computers are, from the computational com-
plexity perspective, fundamentally diﬀerent tools avail-
able to computationally intensive ﬁelds. The implemen-
tation of quantum algorithms requires that the minimal
quantum information units, qubits, are as reliable as clas-
sical bits. Qubits need to be protected from environmen-
tal noise that induces decoherence but, at the same time,
their states have to be controlled by external agents.
This control includes the interaction that generates en-
tanglement between qubits and the measurement opera-
tion that extracts the output of the quantum computa-
tion. It is technically possible to tame the eﬀect of noise
without compromising the quantum information process
by developing quantum error correction (QEC) protocols
(Lidar and Brun, 2013; Shor, 1995; Terhal, 2015). Un-
fortunately, the overhead of QEC in terms of the number
of qubits is, at the present day, still far from current
experimental capabilities. To achieve the goal of fault-
tolerant quantum computation, the challenge is to scale
up the number of qubits with suﬃciently high qubit qual-
ity and ﬁdelity in operations such as quantum gate im-
plementation and measurement (Aharonov and Ben-Or,
2008; Kitaev, 2003; Knill et al., 1998). As the system size
grows, it becomes highly challenging to contain the er-
rors associated with cross-talk and measurements below
the required error-correction threshold.

Most of the originally proposed quantum algorithms
require millions of physical qubits to incorporate these
QEC techniques successfully, realizing the daunting goal
of building a fault-tolerant quantum computer may take

33
34

35
35
36
37
38

39
41

42
42
43
44

44
45
45
46
46
47
49
51
52
52
53
54
54
54
55
56
56
56
57
57
57
57
58
58

58
59
60
61
61

62
63
63

64

64

80

80
80
83
84

84
84
86
88

89
89
90

decades. Existing quantum devices contain on the or-
der of 100 phyisical qubits. They are sometimes de-
noted as “Noisy Intermediate-Scale Quantum (NISQ)”
devices (Preskill, 2018), meaning their qubits and quan-
tum operations are not QEC and, therefore, imperfect.
One of the goals in the NISQ era is to extract the maxi-
mum quantum computational power from current devices
while developing techniques that may also be suited for
the long-term goal of the fault-tolerant quantum compu-
tation (Terhal, 2015).

A. Computational complexity theory in a nutshell

The deﬁnition of a new computational paradigm opens
the window to tackle those problems that are ineﬃcient
with the existing ones. New computational complexity
classes have been recognized through the study of quan-
tum computing, and proposed algorithms and goals have
to be developed within well-known mathematical bound-
aries.

In this review, we will often use some computational
complexity-theoretic ideas to establish the domain and
eﬃciency of the quantum algorithms covered. For this
reason, we provide in this subsection a brief synopsis for
a general audience and refer to (Arora and Barak, 2009)
for a more comprehensive treatment.

Complexity classes are groupings of problems by hard-
ness, namely the scaling of the cost of solving the problem
with respect to some resource, as a function of the “size”
of an instance of the problem. The most well-known ones
being described informally here. i) P: problems that can
be solved in time polynomial with respect to input size
by a deterministic classical computer.
ii) NP: a prob-
lem is said to be in NP, if the problem of verifying the
correctness of a proposed solution lies in P, irrespective
of the diﬃculty of obtaining a correct solution. iii) PH:
stands for Polynomial Hierarchy. This class is a general-
ization of NP in the sense that it contains all the problems
which one gets if one starts with a problem in the class
NP and adds additional layers of complexity using quan-
tiﬁers, i.e. there exists (∃) and for all (∀). As we add
more quantiﬁers to a problem, it becomes more complex
and is placed higher up in the polynomial hierarchy. Let
us denote the classes in PH by Σi such that PH = ∪iΣi.
We have Σ1 = NP. The class Σi in PH can be interpreted
in the context of two-player games where problems corre-
spond to asking whether there exists a winning strategy
rounds for the player 1 in a game. Here, one can
in i
2
interpret the quantiﬁers by asking whether there exists
a move k1, such that no matter what move k2 is played,
rounds such that
there exists a move k3, and so on for i
2
player 1 wins the two-player game. With increasing i,
one would expect the problem to become more complex
and hence Σi ⊆ Σi+1.
iv) BPP: stands for Bounded-
error Probabilistic Polynomial-time. A problem is said

3

to be in BPP, if it can be solved in time polynomial in
the input size by a probabilistic classical computer. v)
BQP: stands for Bounded-error Quantum Polynomial-
time. Such problems can be solved in time polynomial
in the input size by a quantum computer. vi) PSPACE:
stands for Polynomial Space. The problems in PSPACE
can be solved in space polynomial in the input size by a
deterministic classical computer. Each class in PH is con-
tained in PSPACE. However, it is not known whether PH
is equal to PSPACE. vii) EXPTIME: stands for Expo-
nential Time. The problems in EXPTIME can be solved
in time exponential in the input size by a determinis-
tic classical computer. viii) QMA: stands for Quantum
Merlin Arthur and is the quantum analog of the complex-
ity class NP. A problem is said to be in QMA, if given a
“yes" as an answer, the solution can be veriﬁed in time
polynomial (in the input size) by a quantum computer.
Widely believed containment relations for some of the
complexity classes are shown in a schematic way in Fig. 1.
To understand the internal structure of complexity
classes, the idea of “reductions” can be quite useful. One
says that problem A is reducible to problem B if a
method for solving B implies a method for solving A;
one denotes the same by A ≤ B. It is a common practice
to assume the reductions as polynomial-time reductions.
Intuitively, it could be thought as solving B is at least as
diﬃcult as solving A. Given a class C, a problem X is
said to be C-hard if every problem in class C reduces to
X. We say a problem X to be C-complete if X is C-hard
and also a member of C. The C-complete problems could
be understood as capturing the diﬃculty of class C, since
any algorithm which solves one C-complete problem can
be used to solve any problem in C.

A canonical example of a problem in the class BQP is
integer factorization, which can be solved in polynomial
time by a quantum computer using Shor’s factoring al-
gorithm (Shor, 1994). However, no classical polynomial-
time algorithm is known for the aforementioned problem.
Thus, the integer factorization problem is in BQP, but
not believed to be in P (Arora and Barak, 2009). While
analyzing the performance of algorithms, it is prudent to
perform complexity-theoretic sanity checks. For exam-
ple, though quantum computers are believed to be pow-
erful, they are not widely expected to be able to solve
NP-Complete problems, such as the travelling-salesman
problem, in polynomial time. The quantum algorithms,
however, could provide a speedup with respect to classi-
cal algorithms for NP-Complete problems.

B. Experimental progress

Here we present a somewhat biased and not exhausted
summary of very recent quantum experiments.
Inter-
ested readers should consult (Acín et al., 2018) and ref-
erences therein for more information about various quan-

4

Two recent experimental ventures exhibit this focus. In
2019, the Google AI Quantum team implemented an ex-
periment with the 53-qubit Sycamore chip (Arute et al.,
2019) in which single-qubit gate ﬁdelities of 99.85% and
two-qubit gate ﬁdelities of 99.64% were attained on aver-
age. Quantum advantage was demonstrated against the
best current classical computers in the task of sampling
the output of a pseudo-random quantum circuit.

An additional quantum advantage experiment was
carried out by Jian-Wei Pan’s group using a Jiuzhang
photonic quantum device performing Gaussian boson
sampling (GBS) with 50 indistinguishable single-mode
squeezed states (Zhong et al., 2020). Here, quantum ad-
vantage was seen in sampling time complexity of a Toron-
tonian of a matrix (Quesada et al., 2018), which scales
exponentially with the photon clicks output. The Toron-
tonian is a matrix function that determines the probabil-
ity distribution of measurement outcomes, much like the
permanent and Hafnian in other boson sampling models.
Intuitively speaking, while the total number of perfect
matchings in a bipartite graph is given by the permanent,
the Hafnian corresponds to the total number of perfect
matchings in an arbitrarily given graph. Moreover, while
the Hafnian is used in experiments counting the number
of photons in each mode, the Torontonian corresponds
to the case where one detects whether there are photons
in each mode (see Sec. III.B for more details about GBS
and the related terms).

There are several quantum computing platforms that
researchers are actively developing at present in order to
achieve scalable and practical universal quantum com-
puters. By “universal”, it is meant that such a quan-
tum computer can perform native gate operations that
allow it to easily and accurately approximate any uni-
tary gate (see Sec. V.B for more details). Two of the
most promising platforms, superconducting circuits and
quantum optics, have already been mentioned; In ad-
dition to these, trapped-ion devices are also leading
candidates. For instance, major achievements are re-
cent high-ﬁdelity entangling gates reported by the Ox-
ford group (Hughes et al., 2020), all-to-all connectivity
achieved by IonQ (Nam et al., 2020), and transport and
reordering capabilities in 2D trap array by the Boulder
group (Wan et al., 2020). In the last example, besides
facilitating eﬃcient transport of ions and quantum infor-
mation exchange, the 2D architecture can be viewed to-
wards attaining much more sophisticated quantum error
correction code or surface code (Lidar and Brun, 2013),
the smallest of it has been realized in superconducting
qubit setup (Córcoles et al., 2015).

Scientists and engineers are also developing hybrid
quantum computing platforms trying to achieve similar
feats described above. These devices might not necessar-
ily possess universal quantum gate sets, as many are built
to solve speciﬁc problems. Notably, coherent Ising ma-
chines (Inagaki et al., 2016; Marandi et al., 2014; McMa-

Figure 1 An illustrative picture of some relevant complex-
ity classes together with a problem examples. For the chess
example, the word “restricted” refers to a polynomial upper
bound on the number of moves. The containment relations
are suggestive. Some of them have not been mathematically
proven, being a well-known open problem whether P is equal
to NP.

tum computing architectures.

Experimental progress in quantum computation can
be measured by diﬀerent ﬁgures of merit. The number of
physical qubits available must exceed a certain threshold
to solve problems beyond the capabilities of a classical
computer. However, there exist several classical tech-
niques capable of eﬃciently simulating certain quantum
many-body systems. The success of some of these tech-
niques, such as Tensor Networks (Orús, 2014; Verstraete
et al., 2008), rely on the eﬃcient representation of states
that are not highly entangled (Vidal, 2003, 2004). With
the advent of universal quantum computers, one would
expect to be able to generate and manipulate these highly
entangled quantum states.

Hence, one imminent and practical direction towards
demonstrating quantum advantage over classical ma-
chines consist of focusing on a region of the Hilbert space
whose states can not be represented eﬃciently with clas-
sical methods. Alternatively, one might tackle certain
computational tasks which are believed to be intractable
with any classical computer, as the ones belonging to
only quantum complexity classes.

EXPTIME: classically solvable in exponential timeUnrestricted chess on an nxn boardPSPACE: classically solvable in polynomial spaceRestricted chess on an nxn boardQMA: quantumly verifiable in polynomial timeQMA-Complete: hardest problems in QMAQuantum Hamiltonian ground state problemNP-Complete: hardest problems in NPTraveling salesman problemNP: classically verifiable in polynomial timeP: classically solvable in polynomial timeTesting whether a number is primeBQP: quantumly solvable in polynomial timeInteger factorizationhon et al., 2016; Utsunomiya et al., 2011; Wang et al.,
2013) based on mutually coupled optical parametric os-
cillators are promising and have shown success in solving
instances of hard combinatorial optimization problems.
Recently, it has been shown that the eﬃciency of these
machines can be improved with error detection and cor-
rection feedback mechanisms (Kako et al., 2020). The
reader is advised to refer to the recent review article (Ya-
mamoto et al., 2020) for an in-depth discussion about
coherent Ising machines. Quantum annealing (Finnila
et al., 1994; Kadowaki and Nishimori, 1998) has been an-
other prominent approach towards quantum advantage in
the NISQ era (Bouland et al., 2020; Hauke et al., 2020;
Perdomo-Ortiz et al., 2018). Refer to Sec. III.A for more
details about quantum annealing.

Lastly, unlike the past decades of academic research in
lab-based quantum technologies, we are witnessing the
emergence of cloud quantum computers with which any-
one with internet access can now control and manipulate
delicate qubits and perform quantum computations on
the ﬂy. Presently, IBM Quantum is leading the eﬀort
followed by Rigetti Computing and Xanadu Quantum
Cloud.

C. NISQ and near-term

The experimental state-of-the-art and the demand for
QEC have encouraged the development of innovative al-
gorithms capable of reaching the long-expected quantum
advantage. This goal can be deﬁned as a purpose-speciﬁc
computation that involves a quantum device and that can
not be performed classically with a reasonable amount of
time and energy resources. The term near-term quantum
computation has been coined to cluster all these quan-
tum algorithms specially developed to be run on current
quantum computing hardware or those which could be
developed in the next few years,. It is important to note
that NISQ is a hardware-focused deﬁnition, and does not
necessarily imply a temporal connotation. NISQ devices
can implement the model of quantum circuits, in which
all gates adhere to the topology of a speciﬁed graph G,
the nodes of which correspond to qubits. The gates typ-
ically operate on one or two qubits. Because each gate
operation involves a certain amount of noise, NISQ al-
gorithms are naturally limited to shallow depths (Barak
and Marwaha, 2021). Near-term algorithms, however,
refers to those algorithms designed for quantum devices
available in the next few years and carries no explicit ref-
erence to the absence of QEC. The phrase “near-term”
is subjective since diﬀerent researchers may have other
thoughts on how many years can be considered “near-
term”. Predicting experimental progress is always chal-
lenging, and such predictions are inﬂuenced by human
bias. Algorithms developed for near-term hardware may
be unfeasible if hardware advancement does not match

the algorithm’s experimental requirements.

5

D. Scope of the review

This review aims to accomplish three main objectives.
The ﬁrst is to provide a proper compilation of the avail-
able algorithms suited for the NISQ era and which can
deliver results in the near-term. We present a summary
of the crucial tools and techniques that have been pro-
posed and harnessed to design such algorithms. The sec-
ond objective is to discuss the implications of these algo-
rithms in various applications such as quantum machine
learning (QML), quantum chemistry, and combinatorial
optimization. Finally, the third objective is to give some
perspectives on potential future developments given the
recent quantum hardware progress.

Most of the current NISQ algorithms rely on har-
nessing the power of quantum computers in a hybrid
quantum-classical arrangement. Such algorithms dele-
gate the classically diﬃcult part of some computation to
the quantum computer and perform the other on some
suﬃciently powerful classical device. These algorithms
update variationally the variables of a parametrized
quantum circuit and hence are referred to as Variational
Quantum Algorithms (VQA) (Cao et al., 2019; Cerezo
et al., 2020b; Endo et al., 2020a; McArdle et al., 2020).
The ﬁrst proposals of VQA were the Variational Quan-
tum Eigensolver (VQE) (McClean et al., 2016; Peruzzo
et al., 2014; Wecker et al., 2015), originally proposed to
solve quantum chemistry problems, and the Quantum
Approximate Optimization Algorithm (QAOA) (Farhi
et al., 2014), proposed to solve combinatorial optimiza-
tion problems. These two algorithms may be thought of
as the parents of the whole VQA family. While NISQ de-
vices can arguably achieve quantum advantage for sam-
pling problems, the corresponding question for the opti-
mization problems remains unanswered (Barak and Mar-
waha, 2021; Barak et al., 2015). It is important to men-
tion that, as of now, there is no provable quantum advan-
tage for VQA with NISQ devices (Barak and Marwaha,
2021). We cover the main VQA blocks in Sec. II.

Other quantum computing paradigms propose diﬀer-
ent kinds of algorithms. They are inspired and hybridized
with analog approaches.These include quantum anneal-
ing, digital-analog quantum computation, Gaussian Bo-
son Sampling and analog quantum computation. We
present their fundamental properties in Sec. III.

In Sec. V, we examine the theoretical and experimen-
tal challenges faced by NISQ algorithms and the methods
developed to best exploit them. We include the theoret-
ical guarantees that some of these algorithms lay on as
well as techniques to mitigate the errors coming from the
use of noisy quantum devices. We also cover the pos-
sible trainability challenges that VQA have and how to
map theoretical NISQ circuits to real hardware. Section

VI presents the large variety of applications that NISQ
algorithms introduce. Techniques to benchmark, com-
pare and quantify current quantum devices performance
are presented in Sec. VII. Like any other computational
paradigm, quantum computing requires a language to es-
tablish human-machine communication. We explain dif-
ferent levels of quantum programming and provide a list
of open-source quantum software tools in Sec. V.C. Fi-
nally, we conclude this review in Sec. VIII by highlighting
the increasing community involvement in this ﬁeld and
by presenting the NISQ, near-term and long-term goals
of quantum computational research.

II. BUILDING BLOCKS OF VARIATIONAL QUANTUM
ALGORITHMS

A VQA comprises several modular components that
can be readily combined, extended and improved with de-
velopments in quantum hardware and algorithms. Chief
among these are the objective function, the cost function
to be variationally minimized; the parameterized quan-
tum circuit (PQC), those unitaries whose parameters are
manipulated in the minimization of objective; the mea-
surement scheme, which extracts the expectation values
needed to evaluate the objective; and the classical op-
timizer, the method used to obtain the optimal circuit
parameters that minimize the objective. In the following
subsections, we will deﬁne each of these pieces, presented
diagrammatically in Fig. 2.

A. Objective function

The Hamiltonian is a quantum operator that encodes
information about a given physical system, such as a
molecule or a spin chain.
Its expectation value yields
the energy of a quantum state, which is often used as the
minimization target of a VQA, i.e. obtaining the Hamil-
tonian ground state. Other problems not related to real
physical systems can also be encoded into a Hamiltonian
form, thereby opening a path to solve them on a quantum
computer. Hamiltonian operators are not all that can be
measured on quantum devices; in general, any expecta-
tion value of a function written in an operational form
(i.e. decomposed or encoded into a quantum operator)
can be also be evaluated on a quantum computer. After
the Hamiltonian or operator of a problem has been de-
termined, it must be decomposed into a set of particular
operators that can be measured with a quantum proces-
sor. Such a decomposition, which is further discussed
in Sec. II.A.1, is an important step of many quantum
algorithms in general and of VQA in particular.

Within a VQA, one has access to measurements on
qubits whose outcome probabilities are determined by
the prepared quantum state. Let us consider only mea-

6

surements on individual qubits in the standard computa-
tional basis and denote the probability to measure qubit
q in state ∣0⟩ by pq
, where the qubit label q will be omit-
0
ted whenever possible. The central element of a VQA
is a parametrized cost or objective function O subject to
a classical optimization algorithm, minθ O (θ, {p0 (θ)}).
The objective function O and the measurement outcomes
of one or many quantum circuit evaluations depend
p0
on the set of parameters θ.

In practice it is often inconvenient to work with the
probabilities of the measurement outcomes directly when
evaluating the objective function. Higher level formula-
tions employ expectation value of the Hamiltonian H of
the form

⟨H⟩U (θ)

≡ ⟨0∣ U † (θ) HU (θ) ∣0⟩ ,

(1)

describing measurements on the quantum state generated
by the unitary U (θ), instead of using the probabilities
for the individual qubit measurements directly. Arbitrary
observables can be decomposed into basic measurements
of the so-called Paulis strings, which can be evaluated
in the computational basis, as explained below and in
Sec. II.C. Restricting ourselves to expectation values in-
stead of pure measurement probabilities, the objective
function becomes

(2)

}) .

min
θ

O (θ, {⟨H⟩U (θ)
This formulation often allows for more compact deﬁni-
tions of the objective function. For the original VQE (Pe-
ruzzo et al., 2014) and QAOA (Farhi et al., 2014) it can,
for example, be described as a single expectation value
minθ⟨H⟩U (θ)

where the diﬀerences solely appear in the speciﬁc form

,

and construction of the qubit Hamiltonian.

The choice of the objective function is crucial in a VQA
to achieve the desired convergence. Vanishing gradient
issues during the optimization, known as barren plateaus,
are dependent on the cost function used (Cerezo et al.,
2021) (see Sec. IV.A for details).

1. Pauli strings

To extract the expectation value of the problem Hamil-
tonian, it is suﬃcient to express it as a linear combi-
nation of primitive tensor products of Pauli matrices
ˆσx, ˆσy, ˆσz. We refer to these tensor products as Pauli
strings ˆP = ⊗n
j=1 ˆσ, where n is the number of qubits,
ˆσ ∈ { ˆI, ˆσx, ˆσy, ˆσz} and ˆI the identity operator. Then, the
Hamiltonian can be decomposed as

H =

M
∑
k=1
where ck is a complex coeﬃcient of the k-th Pauli string
and the number of Pauli strings M in the expansion de-
pends on the operator at hand. An expectation value

ck ˆPk,

(3)

7

Figure 2 Diagrammatic representation of a Variational Quantum Algorithm (VQA). A VQA workﬂow can be divided into four
main components: a) the objective function O that encodes the problem to be solved; b) the parameterized quantum circuit
(PQC) U , which variables θ are tuned to minimize the objective; c) the measurement scheme, which performs the basis changes
and measurements needed to compute expectation values that are used to evaluate the objective; and d) the classical optimizer
that minimizes the objective. The PQC can be deﬁned heuristically, following hardware-inspired ansätze, or designed from the
knowledge about the problem Hamiltonian H. Inputs of a VQA are the circuit ansatz U (θ) and the initial parameter values
θ0. Outputs include optimized parameter values θ∗and the minimum of the objective.

in the sense of Eq. (1) then naturally decomposes into a
set of expectation values, each deﬁned by a single Pauli
string

⟨H⟩U =

M
∑
k=1

ck⟨ ˆPk⟩U .

(4)

Examples of Hamiltonian objectives include molecules
(by means of some fermionic transformation to Pauli
strings, as detailed in Sec. VI.A), condensed matter mod-
els written in terms of spin chains, or optimization prob-
lems encoded into a Hamiltonian form (see Sec. VI.C).

2. Fidelity

Instead of optimizing in respect to the expectation
value of an operator, several VQAs require a subrou-
tine to optimize the state obtained from the PQC U (θ),
in respect to a speciﬁc target state ∣Ψ⟩. A com-
∣Ψ⟩U (θ)
monly used cost function is the ﬁdelity between the PQC
and the target state

F (Ψ, ΨU (θ)

) ≡ ∣⟨Ψ∣ΨU (θ)

⟩∣2,

(5)

which is equivalent to the expectation value over the pro-
jector ˆΠΨ = ∣Ψ⟩ ⟨Ψ∣. The state preparation objective is

then the minimization of the inﬁdelity 1 − F (Ψ, ΨU (θ)
or just the negative ﬁdelity

)

max
θ

F (Ψ, ΨU (θ)

) = min

θ

(−⟨ ˆΠΨ⟩U (θ)

) .

(6)

ΨU (θ)

If we know the eﬃcient circuit UΨ that prepares the tar-
get state ∣Ψ⟩, we can compute the ﬁdelity with the in-
version test by preparing the quantum state U †
⟩
Ψ∣ΨU (θ)
and measuring the projector into the zero state ˆΠ0 =
∣0⟩⊗n⟨0∣⊗n with the ﬁdelity given by F (Ψ, ΨU (θ)
) =
⟨ ˆΠ0⟩U †
If one wants to
(Havlíček et al., 2019).
avoid optimizing in respect to a projector onto a sin-
gle state, one can instead use a local observable that
also becomes maximal for the target state, namely ˆO =
N ∑N
is the identity matrix for
1
all qubits except k and ∣0k⟩ is the zero state for qubit
k (Barison et al., 2021; Cerezo et al., 2021). Alterna-
tively, one can use randomized measurements to measure
the ﬁdelity Tr(ρ1ρ2) of two density matrices ρ1, ρ2 (El-
ben et al., 2020, 2019; van Enk and Beenakker, 2012).
First, one selects m unitaries {Vk}k, which are chosen as
tensor product of Haar random unitaries over the local
d-dimensional subspace. These unitaries are applied on
each quantum state ρi = VkρV †
and ρi is sampled in the
k
computational basis. Then, one estimates the probabil-

k=1 ∣0k⟩ ⟨0k∣ ⊗ I¯k

, where I¯k

d Classical optimizationQuantum-classical loopc Basischangeb Parametrized quantum circuitOutputdistanceInputa Objective functionity P (i)
(s) of measuring the computational basis state s
Vk
for each quantum state ρi and unitary Vk. The ﬁdelity is
given by

Tr[ρ1ρ2] =

dN
m

m
∑
k=1

∑
s,s′

(−d)−D[s,s′

] P (1)
Vk

(s)P (2)
Vk

(s′).

(7)

where D[s, s′] is the Hamming distance between sam-
pled computational basis states s and s′. The number
of measurements scales exponentially with the number
of qubits, however the scaling is far better compared to
state tomography.
Importance sampling has been pro-
posed to substantially reduce the number of samples nec-
essary (Rath et al., 2021).

Objective formulations over ﬁdelities are prominent
within state preparation algorithms in quantum op-
tics (Kottmann et al., 2020; Krenn et al., 2020a,b), ex-
cited state algorithms (Kottmann et al., 2021b; Lee et al.,
2018) and QML (Benedetti et al., 2019a; Cheng et al.,
2018; Huang et al., 2021; Pérez-Salinas et al., 2020a) (see
also Sec. VI.B for more references and details). In these
cases, the ﬁdelities are often deﬁned in respect to com-
putational basis states ei, such that Fei = ∣⟨Ψ (θ) ∣ei⟩∣2.

3. Other objective functions

Hamiltonian expectation values are not the only objec-
tive functions that are used in VQAs. Any cost function
that is written in an operational form can constitute a
good choice. One such example is the conditional value-
at-risk (CVaR). Given the set of energy basis measure-
ments {E1, . . . EM } arranged in a non-decreasing order,
instead of using the expectation value from Eq. (1) as
the objective function, it was proposed to use (Barkout-
sos et al., 2020)

CVaR(α) =

1
⌈αM ⌉

⌈αM ⌉
∑
k=1

Ek ,

(8)

which measures the expectation value of the α-tail of the
energy distribution. Here, α ∈ (0, 1] is the conﬁdence
level. The CVaR(α) can be thought of as a generalization
of the sample mean (α = 1) and the sample minimum
(α → 0).

Another proposal (Li et al., 2020) is to use the Gibbs

objective function

G = − ln⟨e−ηH ⟩,

(9)

which is the cumulant generating function of the energy.
The variable η > 0 is a hyperparameter to be tuned. For
small η, the Gibbs objective function reduces to the mean
energy in Eq. (1). Since both the CVaR and the Gibbs
objective function can be reduced to the mean energy for
suitable limits of the hyperparameters (α → 1 and η → 0
respectively), their performances are guaranteed to be at

8

least as good as using the mean energy ⟨H⟩. Empirically,
by tuning the hyperparameters, both measures have been
shown to outperform ⟨H⟩ for certain combinatorial op-
timization problems (Barkoutsos et al., 2020; Li et al.,
2020).

B. Parameterized quantum circuits

Following the objective function, the next essential
constituent of a VQA is the quantum circuit that pre-
pares the state that best meets the objective. It is gener-
ated by means of a unitary operation that depends on a
series of parameters, the PQC. In this subsection, we de-
scribe how this quantum circuit is deﬁned and designed.
We deﬁne the state after application of the PQC as

∣Ψ (θ)⟩ = U (θ) ∣Ψ0⟩ ,

(10)

where θ are the variational parameters and ∣Ψ0⟩ is some
initial state. Typically, ∣Ψ0⟩ is a product state with all
∣00⋯0⟩ = ∣0⟩⊗n, where n is
qubits in the ∣0⟩ state, i.e.
the number of qubits. In some VQAs, it is convenient to
prepare that state in a particular form before applying
the PQC. The state preparation operation would then
depend on some other unitary operation P that may de-
pend on variational parameters φ, ∣Ψ0⟩ = P (φ) ∣0⟩⊗n.

One example are the quantum feature maps deﬁned in

Sec. VI.B.1 that encode the data into the PQC.

Any known property about the ﬁnal state can also be
used to obtain the initial guess. For instance, if we ex-
pect that the ﬁnal state solution will contain all elements
of the computational basis, or if we want to exploit a
superposition state to seed the optimization, an initial
state choice may be P ∣0⟩⊗n = H ⊗n
∣0⟩⊗n, where Hd is the
Hadamard gate. Applied to all qubits, Hd generates the
even superposition of all basis states, i. e.

d

∣D⟩ = H ⊗n

d

∣0⟩⊗n =

1
√
n

n
∑
i=1

∣ei⟩,

(11)

where ∣ei⟩ are the computational basis states.

In quantum chemistry algorithms, the initial state usu-
ally corresponds to the Hartree-Fock approximation (see
Sec. VI.A for details). The choice of a good initial state
will allow the VQA to start the search in a region of the
parameter space that is closer to the optimum, helping
the algorithm converge towards the solution.

The choice of the ansatz U greatly aﬀects the perfor-
mance of a VQA. From the perspective of the problem,
the ansatz inﬂuences both the convergence speed and the
closeness of the ﬁnal state to a state that optimally solves
the problem. On the other hand, the quantum hardware
on which the VQA is executed has to be taken into ac-
count: Deeper circuits are more susceptible to errors,
and some ansatz gates are costly to construct from na-
tive gates. Accordingly, most of the ansätze developed

to date are classiﬁed either as more problem-inspired or
more hardware eﬃcient, depending on their structure and
application.

1. Problem-inspired ansätze

An arbitrary unitary operation can be generated by an
Hermitian operator ˆg which, physically speaking, deﬁnes
an evolution in terms of the t parameter,

G(t) = e−iˆgt.

(12)

As an example, the generator ˆg can be a Pauli matrix
ˆσi and thus, G(t) becomes a single-qubit rotation of the
form

Rk (θ) = e−i θ

2 ˆσk = cos(θ/2)I − i sin(θ/2)ˆσk,

(13)

with t = θ and ˆg = 1
tor.

2 ˆσk, corresponding to the spin opera-

From a more abstract viewpoint, those evaluations can
always be described as time evolution of the correspond-
ing quantum state, so that the generator ˆg is often just
referred to as a Hamiltonian. Note, however, that this
Hamiltonian does not necessarily need to be the oper-
ator that describes the energy of the system of interest.
In general, such generators can be decomposed into Pauli
strings in the form of Eq. (3).

Within so-called problem-inspired approaches, evolu-
tions in the form of Eq. (12), with generators derived
from properties of the system of interest are used to con-
struct the parametrized quantum circuits. The unitary
coupled-cluster approach (see below), mostly applied for
quantum chemistry problems, is one prominent exam-
ple. The generators then are elementary fermionic exci-
tations, as shown in Eq. (17).

The Suzuki-Trotter (ST) expansion or decomposition
(Suzuki, 1976) is a general method to approximate a gen-
eral, hard to implement unitary in the form of Eq. (12)
as a function of the t parameter. This can be done by
decomposing ˆg into a sum of non-commuting operators
{ˆok}k, with ˆg = ∑k ck ˆok and some coeﬃcients ck. The
operators ˆok are chosen such that the evolution unitary
e−iˆokt can be easily implemented, for example as Pauli
strings ˆPk. The full evolution over t can now be decom-
posed into integer m equal-sized steps as

e−iˆgt = lim
m→∞

(∏
k

m

e−i ck ˆok t

m )

.

(14)

For practical purposes, the time evolution can be ap-
proximated by a ﬁnite number m. When Pauli strings
are used, this provides a systematic method to decom-
pose an arbitrary unitary, generated by ˆg, into a prod-
ˆPk t
uct of multi-qubit rotations e−i ck
m , that can themselves
be decomposed into primitive one and two qubit gates.

9

t

Above, we have used the second order ST decomposition
to approximate the true unitary at each time step t. The
error incurred from the approximation can be bounded
by ∣∣Uˆg(∆t) − U ST
k=1 ∣∣[[Hk, H>k], Hk]] +
, where H>k = ∑β>k Hβ and Hk =
[[H>k, Hk], H>k]]∣∣∆3
ck ˆok (Poulin et al., 2014).

ˆg (∆t)∣∣ ≤ ∑m

Knowledge about the physics of the particular Hamil-
tonian to be trotterized can reduce substantially the num-
ber of gates needed to implement this method. For in-
stance, in (Kivlichan et al., 2018), it is shown that by
using fermionic swap gates, it is possible to implement
a Trotter step for electronic structure Hamiltonians us-
ing ﬁrst-neighbour connectivity circuits with N 2/2 two-
qubit gates width and N depth, where N is the number
of spin orbitals. They also show that implementing ar-
bitrary Slater determinants can be done eﬃciently with
N /2 gates of circuit depth.

Unitary Coupled Cluster. Historically, problem-inspired
ansätze were proposed and implemented ﬁrst. They arose
from the quantum chemistry-speciﬁc observation that
the unitary coupled cluster (UCC) ansatz (Taube and
Bartlett, 2006), which adds quantum correlations to the
Hartree-Fock approximation, is ineﬃcient to represent
on a classical computer (Yung et al., 2014). Leveraging
quantum resources, the UCC ansatz was instead realized
as a PQC on a photonic processor (Peruzzo et al., 2014).
It is constructed from the parametrized cluster operator
T (θ) and acts on the Hartree-Fock ground state ∣ΨHF⟩
as

∣Ψ(θ)⟩ = eT (θ)−T (θ)

†

∣ΨHF⟩ .

(15)

The cluster operator is given by T (θ) = T1(θ)+T2(θ)+⋯
with

θj
i ˆa†

j ˆai

T1(θ) = ∑
i∈occ
j∈virt
T2(θ) = ∑

i1,i2∈occ
j1,j2∈virt

θj1,j2
i1,i2

ˆa†
j2

ˆai2 ˆa†
j1

ˆai1 ,

(16)

and higher-order terms following accordingly (O’Malley
et al., 2016). The operator ˆak is the annihilation operator
of the k-th Hartree-Fock orbital, and the sets occ and
virt refer to the occupied and unoccupied Hartree-Fock
orbitals.

Due to their decreasing importance, the series is usu-
ally truncated after the second or third term. The ansatz
is termed UCCSD or UCCSDT, respectively, referring
to the inclusion of single, double, and triple excitations
from the Hartree-Fock ground state. The k-UpCCGSD
approach restricts the double excitations to pairwise ex-
citations but allows k layers of the approach (Lee et al.,
2018). After mapping to Pauli strings as described in
Sec. II.A.1, the ansatz is converted to a PQC usually via
the Trotter expansion in Eq. (14).

In its original form, the UCC ansatz faces several draw-
backs in its application to larger chemistry problems as
well as to other applications. For strongly correlated sys-
tems, the widely proposed UCCSD ansatz is expected to
have insuﬃcient overlap with the true ground state and
results typically in large circuit depths (Grimsley et al.,
2019b; Lee et al., 2018). Consequently, improvements
and alternative ansätze are proposed to mitigate these
challenges.

We restrict our discussion here to provide a short
overview of alternative ansatz developments. For more
details about the UCC ansatz, see Sec. VI.A.

Factorized Unitary Coupled-Cluster and Adaptive Ap-
proaches. The non commuting nature of the fermionic
excitation generators, given by the cluster opera-
tors Eq. (17) leads to diﬃculties in decomposing the
canonical UCC ansatz Eq. (15) into primitive one- and
two-qubit untiaries. First approaches employed the Trot-
ter decomposition Eq. (14) using a single step (McClean
et al., 2016; Romero et al., 2018). The accuracy of the so
obtained factorized ansatz depends however on the order
of the primitive fermionic excitations (Grimsley et al.,
2019a; Izmaylov et al., 2020).

Alternative approaches propose to use factorized uni-
taries, constructed from primitive fermionic excitations,
directly (Evangelista et al., 2019; Izmaylov et al., 2020).
Adaptive approaches, are a special case of a factorized
ansatz, where the unitary is iteratively grown by subse-
quently screening and adding primitive unitary operators
from a predeﬁned operator pool. The types of operator
pools can be divided into two classes: Adapt-VQE (Grim-
sley et al., 2019b), that constructs the operator pool
from primitive fermionic excitations, and Qubit-Coupled-
Cluster (Ryabinkin et al., 2018b) that uses Pauli Strings.
In both original works, the screening process is based on
energy gradients with respect to the prospective operator
candidate. Since this operator is the trailing part of the
circuit, the gradient can be evaluated through the com-
mutator of the Hamiltonian with the generator of that
operator. In contrast to commutator based gradient eval-
uation, direct diﬀerentiation, as proposed in (Kottmann
et al., 2021c) allows gradient evaluations with similar cost
as the original objective and generalizes the approach by
allowing screening and insertion of operators at arbitrary
positions in the circuit. This is, for example, necessary
for excited state objectives as discussed in Sec. VI.A.4.

include

Extended

approaches

iterative meth-
ods
(Ryabinkin et al., 2020), operator pool con-
struction from involutory linear combination of Pauli
strings (Lang et al., 2020), Pauli string pools from
decomposed fermionic pools (Tang et al., 2019), mutual
information based operator pool reduction (Zhang et al.,
2021c), measurement reduction schemes based on the
density matrix reconstruction (Liu et al., 2020a), and

10

external perturbative corrections (Ryabinkin et al.,
2021).

Variational Hamiltonian Ansatz. Motivated by adiabatic
state preparation, the Variational Hamiltonian Ansatz
(VHA) was developed to reduce the number of param-
eters and accelerate the convergence (McClean et al.,
2016; Wecker et al., 2015). Instead of the Hartree-Fock
operators, the terms of the fermionic Hamiltonian itself
are used to construct the PQC. For this purpose, the
fermionic Hamiltonian H is written as a sum of M terms
ˆhi. Which parts of the Hamiltonian are grouped
H = ∑i
into each term ˆhi depends on the problem and there is
a degree of freedom in the design of the algorithm. The
PQC is then chosen as

(17)

UVHA =

e(iθiˆhi),

M
∏
i=1
with the operators in the product ordered by decreasing
i. The unitary corresponds to n short time evolutions un-
der diﬀerent parts of the Hamiltonian, where the terms ˆhi
of the Hamiltonian can be repeated multiple times. The
initial state is chosen so that it is easy to prepare yet it
is related to the Hamiltonian, for example the eigenstate
of the diagonal part of H. The Fermi-Hubbard model
with its few and simple interaction terms is proposed as
the most promising near-term application of the method.
However, it is also shown that the VHA can outperform
speciﬁc forms of the UCCSD ansatz for strongly corre-
lated model systems in quantum chemistry. In Sec. VI.A
we discuss some VQE-inspired algorithms that also use
adiabatic evolution to improve the performance of the
algorithm.

Quantum Approximate Optimization Algorithm. One of
the canonical NISQ era algorithms, designed to pro-
vide approximate solutions to combinatorial optimization
is the Quantum Approximate Optimization
problems,
Algorithm (QAOA) (Farhi et al., 2014). While QAOA
can be thought of as a special case of VQA, it has been
studied in depth over the years both empirically and the-
oretically, and it deserves special attention.

The cost function C of a QAOA is designed to encode a
combinatorial problem by means of bit strings that form
the computational basis. With the computational basis
vectors ∣ei⟩, one can deﬁne the problem Hamiltonian HP
as (see Sec. VI.C.1 for an example)

HP ≡

n
∑
i=1

C(ei)∣ei⟩⟨ei∣,

and the mixing Hamiltonian HM as

HM ≡

n
∑
i=1

ˆσi
x.

(18)

(19)

The initial state in the QAOA algorithm is conventionally
chosen to be the uniform superposition state ∣D⟩ from
Eq. (11). The ﬁnal quantum state is given by alternately
applying HP and HM on the initial state p-times,

∣Ψ(γ, β)⟩ ≡ e−iβpHM e−iγpHP ⋯e−iβ1HM e−iγ1HP ∣D⟩, (20)

with γ ≡ (γ1, γ2, ⋯, γp) and β ≡ (β1, β2, ⋯, βp). A quan-
tum computer is used to evaluate the objective function

C(γ, β) ≡ ⟨Ψ(γ, β)∣ HP (γ, β) ∣Ψ(γ, β)⟩ ,

(21)

and a classical optimizer is used to update the 2p an-
gles γ and β until C is maximized, i.e. C(γ∗, β∗) ≡
maxγ,β C(γ, β). Here, p is often referred to as the QAOA
level or depth. Since the maximization at level p − 1
is a constrained version of the maximization at level p,
the performance of the algorithm improves monotonically
with p in the absence of experimental noise and inﬁdeli-
ties.

In adiabatic quantum computing (see Sec. III.A), we
start from the ground state of HM and slowly move to-
wards the ground state of HP by slowly changing the
Hamiltonian. In QAOA, instead, we alternate between
HM and HP . One can think of QAOA as a Trotterized
version of quantum annealing. Indeed, the adiabatic evo-
lution as used in quantum annealing can be recovered in
the limit of p → ∞.

For a combinatorial optimization problem with hard
constraints to be satisﬁed, penalties in the cost function
can be added. This might not be an eﬃcient strategy in
practice as it is still possible to obtain solutions which
violate some of the hard constraints. A variation of the
QAOA to deal with these constraints was also discussed
in the Sec. VII from the original proposal (Farhi et al.,
2014). Building on previous work in quantum anneal-
ing (Hen and Sarandy, 2016; Hen and Spedalieri, 2016),
it was proposed to encode the hard constraints directly in
the mixing Hamiltonian (Hadﬁeld et al., 2017). This ap-
proach yields the main advantage of restricting the state
evolution to the feasible subspace where no hard con-
straints are violated, which consequently speeds up the
classical optimization routine to ﬁnd the optimal angles.
This framework was later generalized as the Quantum Al-
ternating Operator Ansatz to consider phase-separation
and mixing unitary operators (UP (γ) and UM (β) respec-
tively) which need not originate from the time-evolution
of a Hamiltonian (Hadﬁeld et al., 2019). The operators
e−iβHM and e−iγHP from Eq. (20) are replaced by UM (β)
and UP (γ) respectively.
It is worth noting that both
the Quantum Approximate Optimization Algorithm and
the Quantum Alternating Operator Ansatz are abbrevi-
ated “QAOA” in the literature. In this case, we suggest
“QuAltOA” as an acronym for the Quantum Alternat-
ing Operator Ansatz to distinguish the same from the
Quantum Approximate Optimization Algorithm.

11

Figure 3 Example problem-inspired and hardware-eﬃcient
ansätze. (a) Circuit of the Unitary Coupled Cluster ansatz
with a detailed view of a fermionic excitation as discussed
in (Yordanov et al., 2020). (b) Hardware-eﬃcient ansatz tai-
lored to a processor that is optimized for single-qubit x- and
z-rotations and nearest-neighbor two-qubit CNOT gates.

The use of QAOA for combinatorial optimization is
presented in Sec. VI.C. Some theoretical guarantees of
this ansatz are introduced in Sec. IV.D.

2. Hardware-eﬃcient ansätze

Thus far, we have described circuit ansätze constructed
from the underlying physics of the problem to be solved.
Although it has been shown computationally that such
ansätze can ensure fast convergence to a satisfying so-
lution state, they can be challenging to realize experi-
mentally. Quantum computing devices possess a series
of experimental limitations that include, among others,
a particular qubit connectivity, a restricted gate set, and
limited gate ﬁdelities and coherence times. Therefore, ex-
isting quantum hardware is not suited to implement the
deep and highly connected circuits required for the UCC
and similar ansätze for applications beyond basic demon-
strations such as the H2 molecule (Moll et al., 2018).

A class of hardware-eﬃcient ansätze has been pro-
posed to accommodate device constraints (Kandala et al.,
2017). The common trait of these circuits is the use of
a limited set of quantum gates as well as a particular
qubit connection topology. The gate set usually consists
of a two-qubit entangling gate and up to three single-
qubit gates. The circuit is then constructed from blocks

a Problem-inspired ansatzb Hardware-efficient ansatzof single-qubit gates and entangling gates, which are ap-
plied to multiple or all qubits in parallel. Each of these
blocks is usually called layer, and the ansatz circuit gen-
erally has multiple such layers.

The quantum circuit of a hardware-eﬃcient ansatz

with L layers is usually given by

U (θ) =

L
∏
k=1

Uk (θk) Wk,

(22)

where θ = (θ1, , ⋯, θL) are the variational parameters,
Uk (θk) = exp (−iθkVk) is a unitary derived from a Her-
mitian operator Vk, and Wk represents non-parametrized
quantum gates. Typically, the Vk operators are single-
qubit rotation gates, i.e. Vk are Pauli strings acting lo-
cally on each qubit. In those cases, Uk becomes a product
of combinations of single-qubit rotational gates, each one
deﬁned as in Eq. (13). Wk is an entangling unitary con-
structed from gates that are native to the architecture at
hand, for example CNOT or CZ gates for superconduct-
ing qubits or XX gates for trapped ions (Krantz et al.,
2019; Wright et al., 2019). Following this approach, the
so-called Alternating Layered Ansatz is a particular case
of these Hardware-eﬃcient ansätze which consists of lay-
ers of single qubit rotations, and blocks of entangling
gates that entangle only a local set of qubits and are
shifted every alternating layer.

The choice of these gates, their connectivity, and their
ordering inﬂuences the portion of the Hilbert space that
the ansatz covers and how fast it converges for a spe-
ciﬁc problem. Some of the most relevant properties of
hardware-eﬃcient ansätze, namely expressibility, entan-
gling capability and number of parameters and layers
needed are studied in Refs. (Bravo-Prieto et al., 2020b;
Nakaji and Yamamoto, 2020a; Sim et al., 2019; Woitzik
et al., 2020) and further discussed in Sec. IV.B.

Instead of making a choice between the problem-
inspired and hardware-eﬃcient modalities, some PQC de-
signers have chosen an intermediate path. One example
is the use of an exchange-type gate, which can be im-
plemented natively in transmons, to construct a PQC
that respects the symmetry of the variational problem
(Ganzhorn et al., 2019; Sagastizabal et al., 2019b). Such
an ansatz leads to particularly small parameter counts
for quantum chemistry problems such as the H2 and LiH
molecules (Gard et al., 2020). Another intermediate ap-
proach, termed QOCA for its inspiration from quantum
optimal control, is to add symmetry-breaking unitaries,
akin to a hardware-eﬃcient ansatz, into the conventional
VHA circuit (Choquette et al., 2020). This modiﬁcation
enables excursions of the variational state into previously
restricted sections of the Hilbert space, which is shown
to yield shortcuts in solving fermionic problems.

C. Measurement

12

.

To gain information about the quantum state that has
been prepared on the quantum hardware, one needs to
estimate the expectation value of the objective function
⟨ ˆO⟩Uθ

The most direct approach to estimate expectation val-
ues is to apply a unitary transformation on the quan-
tum state to the diagonal basis of the observable ˆO and
obtaining the probability of measuring speciﬁc compu-
tational states corresponding to an eigenvalue of ˆO. In
other words, to determine whether a measured qubit is
in the ∣0⟩ or ∣1⟩ state. For experimental details on this
task we refer to existing reviews, such as for supercon-
ducting qubits (Krantz et al., 2019) or ion traps (Häﬀner
et al., 2008). However, on NISQ devices, the tranforma-
tion to the diagonal basis mentioned before can be an
overly costly one. As a NISQ friendly alternative, most
observables of interest can be eﬃciently parameterized in
terms of Pauli strings, as shown above, and transformed
into their diagonal basis by simple single-qubit rotations,
as shown below.

Measurement of Pauli strings. The expectation value of
the ˆσz operator on a particular qubit can be measured by
reading out the probabilities of the computational basis
state {∣0⟩ , ∣1⟩} as

⟨ψ∣ˆσz∣ψ⟩ ≡ ⟨ˆσz⟩ = ∣α∣2 − ∣β∣2,

(23)

where ∣α∣2 is the probability to measure the qubit in state
∣0⟩, ∣β∣2 is the probability to measure the qubit in state
∣1⟩ and ∣ψ⟩ = α ∣0⟩ + β ∣1⟩. Measurements deﬁned by ˆσx
and ˆσy can be deﬁned similarly by transforming them
into the ˆσz basis ﬁrst. The transformation is given by
primitive single-qubit gates

y (π/2) ˆσzRy (π/2) = Hd ˆσzHd,
x (π/2) ˆσzRx (π/2) = SHd ˆσzHdS†,

(24)

(25)

ˆσx = R†
ˆσy = R†
√

√

ˆσz and Hd = (ˆσx + ˆσz)/

2 is the Hadamard
where S =
gate. Then, to measure ˆσx on a quantum state ∣ψ⟩, we
rotate ˆσx into the z-axis by applying Hd and measure in
logical ˆσz basis, i.e.

⟨ˆσx⟩ ≡ ⟨ψ∣ ˆσx ∣ψ⟩ = ⟨ψ∣ Hd ˆσzHd ∣ψ⟩ = αβ∗ + α∗β.

(26)

The same applies for ⟨ˆσy⟩. Arbitrary Pauli strings ˆP ,
with primitive Pauli operations ˆσf (k)
∈ {σx, σy, σz} on
qubits k ∈ K, can then be measured by the same proce-
dure on each individual qubit as

⟨ ˆP ⟩U = ⟨ ∏
k∈K

σz(k)⟩ ˜U U

(27)

at qubit k.

where ˜U is a product of single qubit rotations according
to Eq. (24) and Eq. (25) depending on the Pauli opera-
tions ˆσf (k)

So far we discussed expectation values of a physical
observable ⟨ ˆO⟩, which is the mean value averaged over
an inﬁnite number of measurements.
In practice, one
can sample only a ﬁnite number of single-shot measure-
ments Ns of the quantum state and thus can estimate the
expectation values within some ﬁnite error. For a Pauli
string ˆP , the number of measurement samples Ns needed
to estimate the expectation value ⟨ ˆP ⟩U with an additive
error of at most (cid:15) with a failure probability of at most δ
is bounded by Hoeﬀding’s inequality (Huang et al., 2019)

Ns ≥

2
(cid:15)2

log (

2
δ

) .

(28)

√

In particular, the error (cid:15) decreases with the inverse
Ns.
square-root of the number of measurements (cid:15) ∝ 1/
For many problems, such as quantum chemistry-
related tasks, the number of terms in the cost Hamil-
tonian to be estimated can become very large. A naive
way of measuring each Pauli string separately may incur
a prohibitively large number of measurements. Recently,
several more eﬃcient approaches have been proposed (see
(Bonet-Monroig et al., 2020) for an overview). The com-
mon idea is to group diﬀerent Pauli strings that can be
measured simultaneously such that a minimal number of
measurements needs to be performed.

Pauli strings that commute qubit-wise, i.e. the Pauli
operators on each qubit commute, can be measured at the
same time (Kandala et al., 2017; McClean et al., 2016).
The problem of ﬁnding the minimal number of groups can
be mapped to the minimum clique cover problem, which
is NP-hard in general, but good heuristics exist (Vertelet-
skyi et al., 2020). One can collect mutually commut-
ing operators and transform them into a shared eigen-
basis, which adds an additional unitary transformation
to the measurement scheme (Crawford et al., 2019b,b;
Gokhale et al., 2019; Yen et al., 2020). Combinations of
single qubit and Bell measurements have been proposed
as well (Hamamura and Imamichi, 2020).

Alternatively, one can use a method called unitary par-
titioning to linearly combine diﬀerent operators into a
unitary, and use the so-called Hadamard test (see be-
low) to evaluate it (Izmaylov et al., 2019a; Zhao et al.,
2020a). In (Izmaylov et al., 2019b), the observables can
be decomposed into the so-called mean-ﬁeld Hamiltoni-
ans, which can be measured more eﬃciently if one mea-
sures one qubit after the other, and uses information from
previous measurement outcomes.

For speciﬁc problems such as chemistry and condensed
matter systems, it is possible to use the structure of the
problem to reduce the number of measurements (Cade
et al., 2020; Cai, 2020b; Gokhale and Chong, 2019; Hug-
gins et al., 2019). In particular, in (Cai, 2020b), where a
Fermi-Hubbard model is studied using VQE, the num-

13

ber of measurements is reduced by considering multi-
ple orderings of the qubit operators when applying the
Jordan-Wigner transformation. In the context of quan-
tum chemistry, the up-to-date largest reduction could be
achieved by the Cartan subalgebra approach of (Yen and
Izmaylov, 2020). Other approaches use classical shad-
ows (Hadﬁeld et al., 2020), a classical approximation of
the quantum state of interest, or neural network estima-
tors (Torlai et al., 2020) to decrease the number of mea-
surements. All those kind of optimizations require an
understanding of the underlying problem and are usually
not applicable for every use of the VQE.

Measurement of overlaps. Several VQA require the mea-
surement of an overlap of a quantum state ∣ψ⟩ with uni-
tary U in the form of ⟨ψ∣ U ∣ψ⟩. This overlap is in general
not an observable and has both real and imaginary parts.
The Hadamard test can evaluate such a quantity on the
quantum computer using a single extra qubit (Miquel
et al., 2002). The idea is to apply a controlled U oper-
ation, with control on that qubit, and target U on the
quantum state. Then, one can measure from the this
single qubit state both real and imaginary part of the
overlap. A downside of this method is the requirement
to be able to implement a controlled unitary, which may
require too many resources on current quantum proces-
sors. Alternative methods to measure the overlap with-
out the use of control unitaries have been proposed (Mi-
tarai and Fujii, 2019). One idea is to decompose U into
a sum of Pauli strings, and then to measure the expec-
tation value of each Pauli string individually. Another
approach is possible if U can be rewritten into a prod-
uct of unitaries Uq that act locally on only a few qubits.
Then, one can ﬁnd via classical means the diagonaliza-
q DVq, with diagonal matrix D and Vq being
tion of Uq = V †
a unitary. The overlap can be found by applying the Vq
unitaries on the state ∣ψ⟩, measure the outcomes in the
computational basis and do post-processing of the results
with the classically calculated eigenvalues of D.

Classical shadows. This is a powerful technique to accu-
rately predict M expectation values Tr( ˆOiρ), 1 ≤ i ≤ M
of an unknown quantum state ρ (Huang et al., 2020c).
The method is based on and inspired from shadow to-
mography (Aaronson, 2019). First, a random unitary
U is applied on the state ρ → U ρU † and then all the
qubits are measured in the computational basis. This
step is repeated with several random unitaries U . Com-
mon choices for U are unitaries which can be eﬃciently
computed on a classical computer such as random n-
qubit Cliﬀord circuits or tensor products of single qubit
rotations. By post-processing the measurement results,
one can gather a classical shadow, which is a classical
representation of the quantum state ρ.

There exists performance guarantees that classical
shadows with size of order log M suﬃce to predict M
expectation values simultaneously. For investigations in-
volving classical shadow tomography protocols in the
presence of noise, refer to (Chen et al., 2020b; Koh and
Grewal, 2020). Experimental realizations have been per-
formed recently as well (Struchalin et al., 2021; Zhang
et al., 2021b).

D. Parameter optimization

In principle, the PQC parameter optimization to min-
imize the objective is not diﬀerent from any multivariate
optimization procedure and standard classical methods
can be applied (Lavrijsen et al., 2020). However, in the
NISQ era, the coherence time is short, which means that
high-depth analytical gradient circuits cannot be imple-
mented.
In addition, one of the biggest challenges in
parameter optimization is the large number of measure-
ments required for estimating the mean value of an ob-
servable to a high precision. Due to this high sampling
rate, the measurement process can become a signiﬁcant
bottleneck in the overall algorithm runtime. Thus, an
eﬀective optimizer for PQCs should try to minimize the
number of measurements or function evaluations. As a
last criterion, the optimizer should be resilient to noisy
data coming from current devices and precision on expec-
tation values that is limited by the number of shots in
the measurement. These three requirements imply that
certain existing algorithms are better suited for PQC op-
timization and are more commonly used, and that new
algorithms are being developed speciﬁcally for PQC op-
timization. Some intuitive concepts of the mechanisms
behind optimisation of quantum problems have been in-
vestigated in (McClean et al., 2020b). Recently, (Bittel
and Kliesch, 2021) have shown that the classical opti-
mization corresponding to VQAs is a NP-hard problem.
In this section, we ﬁrst review two classes of opti-
mization, gradient-based and gradient-free. We also con-
sider resource-aware optimization methods and strategies
that additionally minimize quantities associated with the
quantum cost of optimization. While we reserve more
detailed descriptions to the respective references and the
Supplementary Material, we highlight the main features
and advantages for each optimization strategy.

1. Gradient-based approaches

A common approach to optimise an objective function
f (θ) is via its gradient, i.e.
the change of the func-
tion with respect to a variation of its M parameters
θ = (θ1, ⋯, θM ). The gradient indicates the direction in
which the objective function shows the greatest change.
This is a local optimization strategy as one uses informa-

14

tion starting from some initial parameter value θ(0) and
iteratively updates θ(t) over multiple discrete steps t. A
common update rule for each θi is

θ(t+1)
i

= θ(t)

i − η ∂if (θ) ,

(29)

or θ(t+1) = θ(t) − η ∇f (θ), where η is a small parameter
called learning rate and

∂i ≡

∂
∂θi

, ∇ = (∂1, ⋯, ∂M )

(30)

is the partial derivative with respect to the parameter
θi and the gradient vector, respectively, using Einstein
notation.

There are various ways of estimating the gradient on a
quantum computer (Romero et al., 2018). The most rele-
vant of them are detailed in the Supplementary Material
and summarized in the following paragraphs.

Finite diﬀerence. One can compute the gradients using
ﬁnite diﬀerences, i.e. ∂if (θ) ≈ (f (θ+(cid:15)ei)−f (θ−(cid:15)ei))/2(cid:15),
where (cid:15) is a small number and ei is the unit vector with
1 as its i-th element and 0 otherwise. As the objective
function f (θ) is obtained with limited accuracy, a good
estimation of the gradient requires smaller (cid:15), i.e. more
samples taken from the quantum hardware.

shift

rule. This

strategy was proposed
Parameter
in (Romero et al., 2018) and developed in (Mitarai et al.,
2018; Schuld et al., 2019). This method computes the
gradients exact and (cid:15) can be large (commonly (cid:15) = π/2).
This method assumes that the unitary to be optimized
can be written as U (θ) = V G(θi)W , where G = e−iθig is
the unitary aﬀected by the parameter θi, g is the gener-
ator of G and V, W are unitaries independent of θi. If
g has a spectrum of two eigenvalues ±λ only, the gradi-
ent can be calculated by measuring the observable at two
shifted parameter values as follows:

(31)

∂i⟨f (θ)⟩ = λ (⟨f (θ+)⟩ − ⟨f (θ−)⟩) ,
where θ± = θ ± (π/4λ)ei. This rule can be generalised
to the case where the generator g does not satisfy the
eigenspectrum condition (see Supplementary Material for
details). It can also be adapted to calculate analytical
gradients for fermionic generators of Unitary Coupled-
Cluster operators (Kottmann et al., 2021b) and higher
order derivatives (Mari et al., 2020).

It is a quasi-Newton method that eﬃciently
L-BFGS.
approximates the “inverse Hessian” using a limited his-
tory of positions and gradients (Fletcher, 2000; Liu and
Nocedal, 1989). While eﬀective in simulations, recent
studies observed BFGS methods do not perform well in

experimental demonstrations of VQA due to the level of
noise in the cost function and gradient estimates (Lavri-
jsen et al., 2020). Two heuristics were proposed to ﬁnd
quasioptimal parameters for QAOA using BFGS (Zhou
et al., 2020a), INTERP and FOURIER explained in
the supplementary material. Eﬃcient initialization of
parameters has also been reported using the Trotterized
quantum annealing (TQA) protocol (Sack and Serbyn,
2021). These heuristic strategies can be easily extended
to gradient-free optimization methods such as Nelder-
Mead.

Quantum natural gradient. The update rule of standard
gradient descent assumes that the parameter space is a
ﬂat Euclidean space. However, in general this is not the
case, which can severely hamper the eﬃciency of gra-
dient descent methods.
In classical machine learning,
the natural gradient was proposed that adapts the up-
date rule to the non-Euclidean metric of the parameter
space (Amari, 1998). Its extension, the quantum natural
gradient (QNG) deﬁnes the following update rule (Stokes
et al., 2020):

θ(t+1)
i

= θ(t)

i − η F −1(θ)∂if (θ) ,

(32)

where F(θ) is the Fubini-Study metric tensor or quan-
tum Fisher information metric given by

Fij = Re(⟨∂iψ(θ)∣∂jψ(θ)⟩−⟨∂iψ(θ)∣ψ(θ)⟩ ⟨ψ(θ)∣∂jψ(θ)⟩) .

(33)
Superior performance of the QNG compared to other
gradient methods has been reported (Stokes et al., 2020;
Yamamoto, 2019) and it has been shown that it can avoid
becoming stuck in local minima (Wierichs et al., 2020).
It can be generalized to noisy quantum circuits (Koczor
and Benjamin, 2019). The QNG can be combined with
adaptive learning rates η(θt
i) that change for every step
of gradient descent to speed up training. For hardware
eﬃcient PQCs, one can calculate adaptive learning rates
using the quantum Fisher information metric (Haug and
Kim, 2021b). While the full Fubini-Study metric tensor is
diﬃcult to estimate on quantum hardware, diagonal and
block-diagonal approximations can be eﬃciently evalu-
ated (Stokes et al., 2020) and improved classical tech-
niques to calculate the full tensor exist (Jones, 2020). A
special type of PQC, the natural PQC, has a euclidean
quantum geometry such that the gradient is equivalent
to the QNG close to a particular set of parameters (Haug
and Kim, 2021a).

Instead of using the
Quantum imaginary time evolution.
standard gradient descent for optimization, a varia-
tional imaginary time evolution method was proposed
in (McArdle et al., 2019a) to govern the evolution of

15

parameters. They focused on many-body systems de-
scribed by a k-local Hamiltonian and considered a PQC
that encodes the state ∣ψ(τ )⟩ as a parameterized trial
state ∣ψ(θ(τ ))⟩. The evolution of θ(τ ) with respect to
all the parameters can then be obtained by solving a
diﬀerential equation (see Supplementary for details). It
was later shown in (Stokes et al., 2020) that this method
is analogous to the gradient descent via the QNG when
considering inﬁnitesimal small step sizes.

Hessian-aided gradient descent. A recent work (Huembeli
and Dauphin, 2021) proposed computing the Hessian and
its eigenvalues to help analyze the cost function land-
scapes of QML algorithms. Tracking the numbers of
positive, negative, and zero eigenvalues provides insight
whether the optimizer is heading towards a stationary
point. The Hessian can be computed by doubly applying
the parameter shift rule as shown in (Mitarai and Fu-
jii, 2019) and reproduced in the supplementary material.
While a deeper analysis is necessary to compare their
performance, both QNG and Hessian-based methods try
to accelerate optimization by leveraging local curvature
information.

Quantum Analytic Descent. A method consisting of us-
ing a classical model of the local energy landscape to
estimate the gradients is proposed in (Koczor and Ben-
jamin, 2020). In this hybrid approach, a quantum device
is used to construct an approximate ansatz landscape
and the optimization towards the minima of the corre-
sponding approximate surfaces can be carried out eﬃ-
ciently on a classical computer. Using this approximate
ansatz landscape, the full energy surface, gradient vec-
tor and metric tensor can be expressed in term of the
ansatz parameters. The analytic descent has been shown
to achieve faster convergence as compared to the QNG.

Stochastic gradient descent. A major drawback of
gradient-based methods is the high number of measure-
ments. The stochastic gradient descent (SGD) algorithm
addresses this issue by replacing the normal parameter
update rule with a modiﬁed version

θ(t+1) = θ(t) − α g(θ(t)),

(34)

where α is the learning rate and g is an unbiased esti-
mator of the gradient of the cost function. As an es-
timator, one can take the measurement of the gradient
with a ﬁnite number of shots (Harrow and Napp, 2019).
This technique can be combined with sampling of the
parameter-shift rule terms (Sweke et al., 2020) or by ex-
tending it to doubly stochastic gradient. For the latter,
the ﬁnite measurements are performed for only a sub-
set of the expectation values of the Hamiltonian terms.

This sampling can be performed in the extreme situation
where only one Pauli-term is evaluated at a single point
in the quadrature. This is a very powerful method that
reduces the number of measurements drastically (Anand
et al., 2020b). This method can be extended beyond cir-
cuits that allow the parameter-shift rule by expressing
the gradient as an integral (Banchi and Crooks, 2020).
To accelerate the convergence of SGD for VQA, diﬀer-
ent strategies are proposed (Lyu et al., 2020) and brieﬂy
explained in the Supplementary.

2. Gradient-free approaches

In this section, we discuss optimization methods for
VQA that do not rely on gradients measured on the quan-
tum computer.

strategies
algorithms. Evolutionary
Evolutionary
(Rechenberg, 1978; Schwefel, 1977) are black-box
optimization tools for high dimensional problems that
use a search distribution, from which they sample data,
to estimate the gradient of the expected ﬁtness to update
the parameters in the direction of steepest ascent. More
recently, natural evolutionary strategies (NES) (Wierstra
et al., 2014) have demonstrated considerable progress in
solving these high dimensional optimization problems.
They use natural gradient estimates for parameter
updates instead of the standard gradients. They have
been adapted for optimization of VQA (Anand et al.,
2020a; Zhao et al., 2020b) and have been shown to
have similar performance as the state-of-the-art gradient
based method.
In (Anand et al., 2020a) it is shown
that NES, along with techniques like Fitness shaping,
local natural coordinates, adaptive sampling and batch
optimization, can be used for optimization of deep
quantum circuits.

Reinforcement learning. Several authors have used rein-
forcement learning (RL) to optimize the QAOA param-
eters (Garcia-Saez and Riu, 2019; Khairy et al., 2019;
Wauters et al., 2020b; Yao et al., 2020a,b). This frame-
work consists of a decision-making agent with policy
πθ(a∣s) parameterized by θ, which is a mapping from
the state space s ∈ {S} to an action space a ∈ {A}. In re-
sponse to the action, the environment provides the agent
with a reward r from the set of rewards {R}. The goal of
RL is to ﬁnd a policy which maximizes the expected total
discounted reward. For more details, refer to Sec. VI.B.3.
In the context of QAOA, for example, {S} can be the set
of QAOA parameters (γ, β) used, a can be the value of
γ and β for the next iteration, and the reward can be the
ﬁnite diﬀerence in the QAOA objective function between
two consecutive iterations. The policy can be parameter-

16

ized by a deep neural network with the weights θ. The
policy parameters θ can be optimized using a variety of
algorithms such as Monte-Carlo methods (Hammersley,
2013; Sutton and Barto, 2018), Q-Learning (Watkins and
Dayan, 1992) and policy gradient methods (Sutton and
Barto, 2018).

In machine learning, the
Sequential minimal optimization.
sequential minimal optimization (SMO) method (Platt,
in optimizing the high-
1998) has proven successful
dimensional parameter landscape of support vector ma-
chines. The method breaks the optimization into smaller
components for which the solution can be found analyti-
cally. This method has been applied to variational circuit
optimization (Nakanishi et al., 2020), circuit optimiza-
tion with classical acceleration (Parrish et al., 2019b) and
circuit optimization and learning with Rotosolve and Ro-
tosolect (Ostaszewski et al., 2019).

Surrogate model-based optimization. When function eval-
uations are costly, it pays oﬀ to not only use the current
function value to inform a next parameter value, but to
use all previous evaluations to extract information about
the search space. The function values in memory are
used to build a surrogate model, an auxiliary function
that represents the full expensive cost function based on
the current information. All optimization happens on
the surrogate cost landscape, so no explicit derivatives of
the cost function are needed. Through the use of a ﬁt-
ted cost function, these methods are also expected to be
more resilient to noise. Several classical surrogate models
have been included in the scikit-quant package (Lavri-
jsen and the scikit-quant contributors, 2020; Lavrijsen
In the Bound optimization by quadratic
et al., 2020).
approximation (BOBYQA) algorithm (Powell, 2009), a
local quadratic model is formulated from the previous
function values. It is then minimized in the trust region
to obtain a new parameter value. When the evaluation at
this new parameter value does not result in a lower func-
tion value, the trust region is altered and the quadratic
model is optimized in this new parameter space. It was
shown that this method works well when the PQC is ini-
tialized close to the optimal parameters but has more
problems with shallow optimization landscapes and gets
stuck in local minima (Lavrijsen et al., 2020). The stable
noisy optimization by branch and ﬁt (SnobFit) (Huyer
and Neumaier, 2008) algorithm uses a branching algo-
rithm to explore new areas in parameter space.

3. Resource-aware optimizers

Optimization methods and strategies adopted for early
demonstrations of VQA are largely general-purpose and

black-box with minimal emphasis on reducing the quan-
tum resources used in the optimization. Therefore, they
are more costly and prone to errors than their classi-
cal counterparts. Optimizers developed in more recent
years are tailored to additionally minimize quantities as-
sociated with the quantum cost of the optimization, e.g.
number of measurements or real hardware properties.
Additionally, one can use circuit compilation methods
as the ones described in Sec. V.B.

ROSALIN. While VQA leverage low-depth circuits to
execute on near-term quantum processors, a signiﬁcant
challenge in implementing these algorithms is the pro-
hibitive number of measurements, or shots, required to
estimate each expectation value that is used to com-
pute the objective. To address the challenge, (Arra-
smith et al., 2020b) developed a shot-frugal optimizer
called ROSALIN (Random Operator Sampling for Adap-
tive Learning with Individual Number of shots) that ef-
fectively distributes fractions of a predeﬁned number of
shots to estimate each term of the Hamiltonian as well
as each partial derivative. Given the expectation value
of the Hamiltonian decomposed into the hi terms as in
Eq. (3),

the authors note several strategies for allocating shots
for estimating each term ⟨hi⟩. While a naive strategy
would allocate equal numbers of shots per term, the
authors observed lower variance in the energies using
weighted approaches in which the number of shots al-
located to the i-th term bi is proportional to the corre-
sponding Hamiltonian coeﬃcient ci.

In experimental realizations of VQA, the opti-
SPSA.
In (Kan-
mizer is often hindered by statistical noise.
dala et al., 2017) this issue is circumvented by apply-
ing the simultaneous perturbation stochastic approxima-
tion (SPSA) algorithm (Spall, 1992), in which the algo-
rithm hyperparameters are determined by experimental
data on the level of statistical noise. Compared to the
ﬁnite-diﬀerence gradient approximation, which requires
O(p) function evaluations for p parameters, SPSA re-
quires only two evaluations, as explained in the supple-
mentary. The convergence of SPSA with various types of
PQCs has been studied (Woitzik et al., 2020).

III. OTHER NISQ APPROACHES

We proceed to review some of the notable NISQ algo-
rithms, besides VQA. These algorithms do not require
tuning the parameters of a PQC in an adaptive feedback
manner and often exploit analog or hybrid paradigms
that constitute alternatives to the digital quantum com-
putation.

17

A. Quantum annealing

Quantum annealing (QA) (Finnila et al., 1994; Kad-
owaki and Nishimori, 1998) derives its inspiration from
simulated annealing (SA), a classical global optimiza-
tion technique, usually employed to solve combinatorial
optimization problems. SA can be valuable in discov-
ering global optima in situations involving many local
optima. The word “annealing” comes from metallurgy,
which represents heating and slow cooling. In SA, one
identiﬁes the objective function with the energy of a
statistical-mechanical system. The system is assigned
an artiﬁcially-induced control parameter, called temper-
ature. Like annealing, SA starts with some high temper-
ature T , and then the value of T is brought down follow-
ing some temperature variation function called “anneal-
ing schedule” such that the ﬁnal temperature is T = 0.
The algorithm chooses a candidate state close to the cur-
rent state randomly.
If it improves the solution, it is
always accepted with probability 1. If it does not, then
the acceptance is determined based on a temperature-
dependent probability function. The idea of tolerating
worse solutions can be considered as a virtue of the al-
In SA, the probability that a bad solution is
gorithm.
accepted is slowly decreased as the solution space is ex-
plored. This relates to the notion of “slow cooling” in
annealing.

In QA, one utilises quantum-mechanical ﬂuctuations,
like quantum tunnelling, to explore the solution space.
This is analogous to the idea of using thermal ﬂuctuations
in SA to explore the solution space. In QA, artiﬁcial de-
grees of freedom of quantum nature via non-commutative
operators are introduced, which induces quantum ﬂuctu-
ations. The strength of these quantum ﬂuctuations is
controlled using an annealing schedule (similar to SA,
where we decrease the temperature). The physical idea
behind annealing schedule in QA is to move the sys-
tem from some initial Hamiltonian ground state to the
ground state of the problem Hamiltonian. The concept
of QA is related to the notion of quantum adiabatic evo-
lution, which is being used for adiabatic quantum com-
putation (Albash and Lidar, 2018; Farhi et al., 2000).

We proceed to a formal discussion now. Adiabatic
quantum computation is model of computation based on
quantum mechanical processes operating under adiabatic
conditions (Albash and Lidar, 2018; Farhi et al., 2000).
Before understanding adiabatic quantum computation,
one needs to grasp the concept of k-local Hamiltonian.

Deﬁnition 1 k-local Hamiltonian: A k-local Hamil-
ˆhi
tonian is a Hermitian matrix of the form H = ∑r
where each term is a Hermitian operator acting non-
trivially on at-most k qudits, i.e., ˆhi = h ⊗ I where h is
a Hamiltonian acting on at-most k neighbouring qudits
and I is the identity operator.

i=1

Let us consider a time-dependent hamiltonian H(s),

for s ≡ t
∈ [0, 1] and a quantum system initialized in
T
the ground state of H(0). We assume that H(s) varies
smoothly as a function of s and H(s) has a unique
ground state for s ∈ [0, 1]. A quantum state initialized in
∣ψ(t = 0)⟩ evolves according to the following Schrödinger
equation (setting ̵h = 1),

i

d
dt

∣ψ(t)⟩ = H(t) ∣ψ(t)⟩ .

(35)

The above equation can be further, equivalently, written
as

i

d
ds

∣ψ(s)⟩ = T H(s) ∣ψ(s)⟩ .

(36)

Assuming ∣ψ(0)⟩ is a ground state of H(0), then in the
limit T → ∞, ∣ψ(t)⟩ is a ground state of H(1) obtained
via evolution Eq. (35). Such an evolution will be, hence-
forth, referred as adiabatic evolution according to H for
time T .

Now we proceed to deﬁne adiabatic quantum compu-

tation.

quantum computation
Deﬁnition 2 Adiabatic
(adapted from (Aharonov et al., 2008)): An
adiabatic quantum computation is speciﬁed by two k-local
Hamiltonians H0 and H1 acting on n qudits and a map
s(t) ∶ [0, T ] —→ [0, 1]. The input of the computation
is the ground state of H0, which is unique and is a
product state. The desired output is given by a quantum
state which is (cid:15)−close in l2-norm to the ground state of
H1. Furthermore, T is the smallest time such that the
adiabatic evolution generated via H(s) = (1 − s)H0 + sH1
for time T yields the desired output. The running time
of the algorithm is given by T.maxs ∥H(s)∥ , where ∥.∥
denotes the spectral norm.

QA relaxes the strict requirement of adiabatic evolu-
tion, thus allowing diabatic transitions due to the ﬁnite
temperature of the system, from fast changes of Hamil-
tonian parameters, and the interaction with the noisy
environment (Hauke et al., 2020). Because of diabatic
transitions, QA is prone to getting trapped in excited
states.

QA has been investigated for problems in diverse ar-
eas including machine learning (Benedetti et al., 2016,
2017, 2018; Li et al., 2018; O’Gorman et al., 2015), pro-
tein folding (Babbush et al., 2012; Babej et al., 2018;
Perdomo et al., 2008; Perdomo-Ortiz et al., 2012), fault
diagnosis (Perdomo-Ortiz et al., 2019, 2015), compres-
sive sensing (Ayanzadeh et al., 2019), ﬁnance (Bouland
et al., 2020; Cohen et al., 2020; Marzec, 2016; Orus et al.,
2019; Rosenberg et al., 2016; Venturelli and Kondratyev,
2019), fermionic simulation (Babbush et al., 2014) and
high energy physics (Das et al., 2019; Mott et al., 2017).
The protein folding problem entails calculating a pro-
tein’s lowest free-energy structure given its amino-acid

18

sequence. The goal is to solve the protein folding prob-
lem by mapping it to a Hamiltonian and then using QA to
identify low-energy conformations of the protein model.
In (Perdomo-Ortiz et al., 2012), authors use ﬁve and eight
qubits for the four-amino-acid sequence to encode and
solve the protein folding problem for a short tetrapep-
tide and hexapeptide chain. QA has been one of the
prominent approaches in the NISQ era in the search for
quantum advantage (Bouland et al., 2020; Hauke et al.,
2020; Perdomo-Ortiz et al., 2018).

A major experimental implementation of QA is the D-
Wave machine. It attempts to solve problems in a par-
ticular form called Quadratic Unconstrained Binary Op-
timization (QUBO) (Lucas, 2014). Optimization prob-
lems can be cast as a polynomial unconstrained binary
optimization (PUBO) expressed in the form of a k-local
interaction with k ≥ 3 over binary variables xi ∈ {0, 1}
(Hauke et al., 2020; Perdomo-Ortiz et al., 2019). QUBO
is a special case of PUBO with k = 2. For a vector of n
binary variables x ∈ {0, 1}n and problem speciﬁed values
of Q ∈ Rn×n and c ∈ Rn, QUBO is deﬁned as

arg min xT Qx + cT x.

(37)

Using the map xi → 1−σi
, one can convert the problem
in expression 37 to ground state ﬁnding problem of the
following diagonal n-qubit Ising Hamiltonian (up to a
constant),

2

z

HQUBO = − ∑
i,j

Ji,j ˆσi

z ˆσj

z − ∑
i

hi ˆσi
z,

(38)

where ˆJi,j = − Qi,j
4

and hi = −ci+∑j Qi,j
Starting with the ground state of the base Hamilto-
, solving the QUBO problem on a quan-
nian H0 = − ∑i ˆσi
x
tum annealer corresponds to implementing the annealing
schedule A(t) and B(t) for the Hamiltonian

2

.

H(t) = A(t)H0 + B(t)HQUBO.

(39)

Here, A(0) = B(T ) = 1 and A(T ) = B(0) = 0, where T is
computation time. Because annealing does not necessar-
ily satisfy the constraints of adiabatic evolution, one can
end up in excited states as mentioned earlier. However,
one can run the annealing schedule multiple times and
take the best answer i.e, the one corresponding to low-
est energy. The qubits in an annealer are not necessarily
all-to-all connected, necessitating additional engineering
restrictions, such as the minor embedding problem (Choi,
2008, 2011; Klymko et al., 2014).

The potential of QA has been studied extensively
(Brady and van Dam, 2016; Denchev et al., 2016; Farhi
et al., 2002; Hastings, 2020; Hauke et al., 2020). The per-
formance of D-Wave annealers have also been explored
comprehensively (Albash et al., 2015; Cohen et al., 2020;
Shin et al., 2014). In particular, an extensive study com-
paring the performance of quantum annealing with other

quantum-inspired and classical optimization state-of-the-
art strategies, and in the context of a real- world ap-
plication, can be found in (Perdomo-Ortiz et al., 2019).
For the details of QA, refer to (Hauke et al., 2020) and
the references therein. A review on Adiabatic Quantum
Computation is presented in (Albash and Lidar, 2018).
Refer to Sec. VI.B and Appendix Sec. C for the discus-
sions regarding applications of QA in machine learning
and ﬁnance respectively.

B. Gaussian boson sampling

Figure 4 Gaussian boson sampling circuit for a photonic
setup. The qumodes are prepared in gaussian states from
the vacuum by squeezing operations S(zi), followed by an in-
terferometer consisting of phaseshifters R(θ) = eiθj and beam-
splitters BS. At the end, photon number resolving measure-
ments are made in each mode.

Boson sampling was ﬁrst proposed as a candidate for
quantum computational supremacy by (Aaronson and
Arkhipov, 2011). The scenario consists of having n
photons that enter an optical circuit consisting of m
modes. This state is then acted upon by a series of
phase-shifters and beam-splitters. A phase-shifter adds
a phase R(θ) = eiθj with some angle θj to the amplitude
in mode j, and acts as the identity in the other m − 1
modes. A beam-splitter acts on two modes with a rota-

tion (

cos φ − sin φ
sin φ cos φ

) for some angle φ and as the identity

in the other m−2 modes. Finally, a measurement is made
where the number of photons in each mode is found. An
optical circuit with these elements is shown in Figure 4.
Each of these measurement outcomes represent a sam-
ple from the the symmetric wavefunction that bosonic
systems have. Aaronson and Arkhipov found that the
existence of an eﬃcient classical algorithm for sampling
from the distribution implies the existence of a classically
eﬃcient algorithm for the calculation of the permanent
of a related matrix. Such an algorithm would imply the
collapse of the polynomial hierarchy (see I.A) to the third
order, which is believed to be unlikely (Arora and Barak,
2009). Consequently, such an algorithm is unlikely to
exist.

Gaussian boson sampling (GBS) is a variant of bo-
son sampling, where instead of photon states as inputs
into the optical circuit, Gaussian states are used as in-
puts (Hamilton et al., 2017). Gaussian states are those

19

whose Wigner quasi-probability distributions W (q, p)
have Gaussian shape. A good introduction to the theory
can be found in (Seraﬁni, 2017). They have the advan-
tage that they can be created deterministically (Hamilton
et al., 2017; Kruse et al., 2019). They also provide ad-
ditional degrees of freedom in comparison to boson sam-
pling. Where boson sampling is equivalent to sampling
from the permanent of a matrix, GBS is computation-
ally equivalent to sampling from the Hafnian function of
a matrix. Given a graph G with adjacency matrix E, the
Hafnian of E is the number of perfect matchings of the
graph G. A matching of a graph G is a subset of edges
M such that no two edges in M have a vertex in com-
mon. A matching M is perfect if every vertex is incident
to exactly one edge in M. While the Permanent gives
the number of perfect matchings for a bipartite graph;
the Hafnian gives perfect matching for any graph. Thus,
the Hafnian can be thought of as a generalization of the
Permanent. Using the adjacency matrix E, the relation
between the Hafnian and the Permanent is given by

Haf (

0 E
ET 0

) = Per(E).

(40)

The hardness of simulating a noisy version of GBS has
been studied (Qi et al., 2020) and GBS has recently be-
come the second platform to show quantum computa-
tional supremacy (Zhong et al., 2020), and the latest ex-
perimental venture towards dynamically programmable
GBS nanophotonic chip was carried out by (Arrazola
et al., 2021).

1. The protocol

In GBS we consider m quantum modes (qumodes), rep-
resented by harmonic oscillators with canonically conju-
gate variables q and p. Gaussian states of the qumodes
are those represented by a Wigner-function W (q, p) that
has a Gaussian form. These states can be eﬃciently rep-
(q + ip) and
resented by the complex amplitude α = 1
√
2̵h
a covariance matrix Σ ∈ C2m×2m. A general pure Gaus-
sian state can be generated from a vacuum with three
steps:
i) Single mode squeezing; ii) multi-mode linear
In
interferometry; and iii) single-mode displacements.
the GBS protocol the state is then measured in the Fock-
basis, performed in practice using photon number resolv-
ing detectors. The optical circuit in Figure 4 shows how
the system is initialized in the vacuum state, followed
by single- and multi-mode squeezing operators S(zi) and
S(zi, zj), respectively, and an interferometer with phase-
shifters R(θj) and beamsplitters BS. At the end of the
protocol, the photon number in each mode is measured.
For a Gaussian state with zero mean (of the Wigner-
function), the probability of detecting si photons in the
i-th qumode is given by: (Hamilton et al., 2017; Kruse

BSBSBSBSBSBSBSBSet al., 2019)

P (s1, s2...sm) =

1
det(Q)

√

Haf(As)
s1!s2!⋯sm!

(41)

where all the matrices are deﬁned in terms of the covari-
ance matrix Σ:

Q = Σ + 1/2
A = X(1 − Q−1)

X = [

0 1
]
1 0

The As matrix is a matrix created from A such that if
si = 0, we delete the rows and colums i and i + m of the
matrix, and if si ≠ 0, we repeat the rows and columns si
times.

This means that by manipulating the covariance ma-
trix Σ, we control the matrix from which we sample the
Hafnian. For a pure Gaussian state, it can be shown that
the A matrix is symmetric (Bromley et al., 2020).

A simpler form of the experiment where instead of
counting the number of photons in each mode, we only
detect if there are photons or not in each mode, can be
used to sample from the so-called Torontonian function
of a matrix (Quesada et al., 2018). If the probability of
observing more than one photon per output mode stays
low enough, this model has been shown to stay classically
intractable to simulate. A more general experiment in-
stead, where the mean of the Gaussian states is non-zero,
can be used to sample from the loop Hafnian (Björklund
et al., 2019).

2. Applications

A number of algorithms for applications of GBS have
been investigated, and are reviewed by (Bromley et al.,
2020). Here we only brieﬂy summarise that work. Typ-
ically GBS algorithms are based on heuristics, and GBS
devices are often used to provide a seed for starting points
of classical algorithms. GBS can also be viewed as di-
rectly giving access to a statistical distribution, such as
in the case of point processes (Jahangiri et al., 2020b).

Problems in chemistry have been tackled using GBS.
Vibrational spectra of molecules have been computed us-
ing GBS by mapping the phononic modes of the molecule
to the qumodes of the GBS device (Huh et al., 2015),
and by extension electron-transfer reactions have been
studied (Jahangiri et al., 2020a). The technique of sam-
pling high-weight cliques has also been applied to predict
molecular docking conﬁgurations (Banchi et al., 2020a).
The largest number of GBS algorithms are for graph
problems, since the adjacency matrix of a graph is a nat-
ural ﬁt as the symmetric A matrix. The Hafnian function
computes the number of perfect matchings of a graph, so

20

the samples from the GBS device are with high likelihood
from sub-graphs with high density. This is how GBS is
used to identify dense subgraphs (Arrazola and Bromley,
2018), and to get good initial guesses for classical search
algorithms to compute the max-clique of a graph (Banchi
et al., 2020a).

GBS can also be used to build succinct feature vec-
tors, or “ﬁngerprints”, of larger graphs via coarse-graining
techniques. These feature vectors can then be used as in-
puts to statistical methods or machine learning to classify
graphs. One such problem is to measure the similarity
between graphs (Schuld et al., 2020b), which has appli-
cations in tasks such as checking ﬁngerprint comparison
or detecting mutations of molecules.

GBS can also be used as a type of importance sam-
pling device to speed up algorithms requiring random-
ness. This is how stochastic search algorithms have been
sped up by sampling from a GBS device encoding the
graph to be searched, instead of sampling uniformly (Ar-
razola et al., 2018).

Recently variational methods have been used within
the GBS framework (Banchi et al., 2020b) and applied to
stochastic optimization and unsupervised learning. The
method is based on varying the squeezing and interfer-
ometer parameters in the device and updating based on
the measurement outcomes.

C. Analog quantum simulation

Simulating a quantum system is a hard problem for
classical computers as the Hilbert space increases ex-
ponentially with the size of the system. As a solution
to this long-standing problem, Feynman suggested the
ground breaking idea to harness that physical systems
given us by nature are quantum-mechanical. He pro-
posed to use quantum systems that are well-controlled
in the lab to simulate other quantum systems of inter-
est (Feynman, 1982). This concept has spurred the ﬁeld
of analog quantum simulation (Georgescu et al., 2014;
Trabesinger, 2012).

The core idea diﬀers from digital quantum simula-
tion (Lloyd, 1996). Digital quantum simulators decom-
pose the quantum dynamics to be simulated into a cir-
cuit of discrete gate operations that are implemented on
a quantum processor. The quantum processor is a well
controlled quantum system, that is engineered to be able
to eﬃciently apply a set of speciﬁc quantum gates that
are universal, i.e. a sequential application of those gates
can realize arbitrary unitaries (see Sec. V.B.1).

With this universal approach, a wide range of quantum
problems can be simulated to a desired accuracy with a
polynomially increase in quantum resources only (Lloyd,
1996). However, current quantum processors have only
limited coherence time and lack the capability to correct
errors that inevitably appear during the computation,

severely limiting the range of dynamics that can be sim-
ulated. In contrast, the idea of analog quantum simula-
tors is to map the problem Hamiltonian to be simulated
ˆHsys to the Hamiltonian of the quantum simulator ˆHsim,
which can be controlled to some degree, ˆHsys ↔ ˆHsim.
One then runs the quantum simulator, and maps the re-
sults back to the problem.

The range of problems that can eﬃciently mapped to
the simulator is limited, however as one uses the native
quantum dynamics of the simulator, the accessible sys-
tem size, coherence length and errors is often more favor-
able compared to current digital quantum simulators.

1. Implementations

A wide-range of implementations in various controlled
quantum systems has been achieved, ranging from solid
state superconducting circuits (Houck et al., 2012), quan-
tum dot arrays (Hensgens et al., 2017), nitrogen-vacancy
centers (Yao et al., 2012), atomic and molecular physics
based platforms such as trapped ions (Blatt and Roos,
2012),
interacting photons (Chang et al., 2014; Hart-
mann, 2016), Rydberg atoms (Adams et al., 2019), and
cold atoms (Amico et al., 2021; Bloch et al., 2012; Gross
and Bloch, 2017).

Concepts of analog quantum simulation have been used
within VQA as well, such as problem inspired ansätze
(see Sec. II.B.1) or protocols inspired by quantum con-
trol (Meitei et al., 2020; Yang et al., 2017). Experimen-
tal results for a quantum many-body problem beyond
current classical computational capabilities have been re-
ported for 2-D systems (Choi et al., 2016).

2. Programmable quantum simulators

An analogue quantum system, such as a superconduct-
ing circuit, can be adapted to simulate arbitrary dynam-
ics (Bastidas et al., 2020). The idea is to drive the param-
eters of the Hamiltonian H(t) that describes the analog
quantum simulator in time t. This can be done by ad-
justing the physical parameters of the quantum simulator
in time. The driving protocol is engineered via machine
learning methods (Haug et al., 2021b) such that the ef-
fective dynamics of the driven system over a time T cor-
responds to the evolution of a problem Hamiltonian one
wants to simulate. The eﬀective dynamics that is gener-
ated can realize long-range interactions as well as com-
plicated many-body terms, which are natively not sup-
ported by the quantum simulator and are often hard to
simulate on digital quantum simulators. By periodically
driving the analog quantum simulator with the aforemen-
tioned driving protocol, various problem Hamiltonians
can be simulated (Oka and Kitamura, 2019). One can
realize complicated many-body dynamics or chemistry

21

problems , as well as solve combinatorial tasks such as
SAT-3. Trapped ion based analog quantum simulators
have been recently used for the implementation of quan-
tum approximate optimization algorithm (Pagano et al.,
2020).

Highly controllable analog quantum simulators have
also been proposed for engineering quantum chemistry
Hamiltonians by combining diﬀerent cold atom species
embedded within cavity modes, which mediate long-
range interactions required to simulate Coulomb repul-
sion. Optical ﬁelds can be used to modify the poten-
tial and interaction parameters in order to simulate large
scale chemistry problems (Argüello-Luengo et al., 2019)
as well as quantum spin model with tunable interactions
for system sizes ranging from 64 to 256 qubits (Ebadi
et al., 2020). For ion traps, a programmable quantum
simulator can be designed by light ﬁelds, that are ap-
plied to manipulate the internal degrees of freedom as
well as the interaction between diﬀerent ions. This al-
lows one to simulate various types of spin Hamiltonians
with a high degree of control over the parameters (Mon-
roe et al., 2019).

D. Digital-analog quantum simulation and computation

As opposed to analog simulators that are limited by
the Hamiltonians they can simulate (Goldman and Dal-
ibard, 2014; Kyriienko and Sørensen, 2018), digital quan-
tum simulators can simulate any system’s Hamiltonian,
but with sometimes costly quantum resources. To beneﬁt
from a combination of the two approaches, the digital-
analog method to quantum computation (Dodd et al.,
2002; Parra-Rodriguez et al., 2020) and simulation (Mez-
zacapo et al., 2014; Yung et al., 2014) has been proposed.
These schemes combine the application of digital single-
qubit gates with the underlying analog Hamiltonian of
the quantum processor. This approach allows for uni-
versal simulation of quantum dynamics while replacing
two qubit gates for an analog Hamiltonian and has been
argued to be more resilient against certain types of noise
than digital quantum computing (García-Molina et al.,
2021; Martin et al., 2020; Parra-Rodriguez et al., 2020).
Digital-analog quantum simulation has been proposed
to simulate the Rabi model (Mezzacapo et al., 2014),
Dicke model (Lamata, 2017; Mezzacapo et al., 2014),
and fermionic systems (Céleri et al., 2021; García-Álvarez
et al., 2015). Digital-analog quantum simulation has
been reviewed in (Lamata et al., 2018b), whereas digital-
analog quantum computing is more recent. The imple-
mentation of digital-analog quantum computing has been
proposed for superconducting platforms (Gonzalez-Raya
et al., 2021; Yu et al., 2021). So far the computing frame-
work has been used to simulate Ising models (Parra-
Rodriguez et al., 2020), where the analog blocks can be
used to enhance the eﬀective connectivity of the qubits to

simulate graphs that have a diﬀerent connectivity from
the native connectivity of the quantum device (Galicia
et al., 2020). The analog blocks have also been applied
to reduce the operation count required to perform the
quantum Fourier transform (Martin et al., 2020).

The digital-analog approach has also been combined
with VQA (see Sec. II) resulting in a digital-analog
QAOA algorithm, where the two-qubit gates have been
replaced by analog blocks (Headley et al., 2020). This
also has two versions: i) where a layer of entangling gates
is replaced by an analog block; and ii) where a continu-
ous analog block is applied continuously with single-qubit
operations overlayed.

E. Iterative quantum assisted eigensolver

Almost all of the VQAs update a PQC’s parameters in
a feedback loop. However, there exist alternative algo-
rithms that can circumvent this approach with the ansatz
given by (Bharti and Haug, 2020a; Huang et al., 2019;
McClean et al., 2017)

(42)

∣φ (α(t), θ)⟩ =

αi(t)∣ψi (θi)⟩,

m−1
∑
i=0
where αi ∈ C and θi ∈ Rki for non-negative integers ki.
This ansatz is a linear combination of quantum states,
where the αi parameters are stored on a classical device.
In the special case m = 1 it corresponds to the usual PQC,
whereas for m > 1 this ansatz subsumes it. This ansatz
has been used for ﬁnding the ground state of Hamilto-
nians (Bharti, 2020; Bharti and Haug, 2020a), excited
state (Huggins et al., 2020; Parrish et al., 2019a; Parrish
and McMahon, 2019; Stair et al., 2020) the simulation of
quantum dynamics (Bharti and Haug, 2020b; Haug and
Bharti, 2020), error mitigation (McClean et al., 2017),
nonlinear dynamics (Bharti and Haug, 2020b; Haug and
Bharti, 2020), linear systems (Huang et al., 2019) and
semideﬁnite programming (Bharti et al., 2021).
If one
keeps the parameters of the PQC θi ﬁxed and only varies
the αi, the algorithm can be considered a borderline
non-VQA algorithm. Update of θi parameters has been
shown to cause trainability issues in VQA (see Sec. IV.A)
and thus by ﬁxing θi one can by construction circumvent
these issues. We present here the iterative quantum as-
sisted eigensolver algorithm (IQAE) as an illustration,
and in the applications subsection the quantum assisted
simulator for closed systems (see Sec. VI.A.5), open sys-
tems (see Sec. VI.A.7) and Gibbs state preparation (see
Sec. VI.A.9).

The IQAE algorithm provides an approximation to the
ground state of a Hamiltonian H. Without loss of gen-
erality, the N -qubit Hamiltonian H is assumed to be a
linear combination of unitaries

H =

m
∑
i=1

βiUi .

(43)

22

Here, βi ∈ C and Ui ∈ SU (2N ) for i ∈ {1, 2, ⋯, m} . The
unitaries Ui act on at most O (poly (log N )) qubits. This
condition can be relaxed if the unitaries Pauli strings (see
Sec. II.A.1). The ansatz state is taken as linear combina-
tion of “cumulative K-moment states” CSK, which is gen-
erated using some eﬃciently preparable quantum states
and the unitaries deﬁning the Hamiltonian in Eq. (43).
For pedagogical reasons, we present the deﬁnition of K-
moment states and cumulative K-moment states.

Deﬁnition 3 (adapted from (Bharti and Haug, 2020a))
For a given positive integer K, a set of unitaries U ≡
{Uj}m
j=1 and a quantum state ∣ψ⟩, K-moment states is
the set of quantum states of the form {UjK ⋯Uj2 Uj1∣ψ⟩}j
for Ujl ∈ U. Let us denote the aforementioned set by SK.
We deﬁne the singleton set {∣ψ⟩} as the 0-moment state
(denoted by S0). Finally, we deﬁne the cumulative K-
moment states CSK as CSK ≡ ∪K
As instructive example, note that the set of 1-moment
states is {Uj∣ψ⟩}m
make
j=1
up the Hamiltonian H. The set of cumulative 1-moment
states is CS1 = {∣ψ⟩} ∪ {Uj∣ψ⟩}m
j=1 , and the set of cumu-
lative K-moment states is CSK = {∣ψ⟩} ∪ {Uj1 ∣ψ⟩}m
j1=1 ∪
⋅ ⋅ ⋅ ∪ {UjK . . . Uj1 ∣ψ⟩}r
the ansatz

, where the unitaries {Uj}m
j=1

=
∑∣χj ⟩∈CSK αj∣χj⟩. The ground state problem reduces to
the following optimization program

is given by ∣ξ (α)⟩(K)

j1=1,...,jK =1
is

i=0Si.

Now,

.

α†D(K)α

min
α

subject to α†E (K)α = 1 .

(44)

nm = ∑i βi⟨χn∣Ui∣χm⟩ and E (K)

Here, the overlap matrices D(K) and E (K) are given by
D(K)
nm = ⟨χn∣χm⟩. These
overlap matrices can be computed on a quantum com-
puter without the requirement of any complicated mea-
surement involving multi-qubit controlled unitaries. For
example, for a Hamiltonian composed of Pauli strings,
the product of Pauli strings is a Pauli string up to a
phase factor ±1 or ±ι. Thus, the overlap matrices are
simply expectation values ⟨ψ∣ ˆP ∣ψ⟩ of some Pauli string
ˆP , which can be easily measured (see Sec. II.C).

The optimization program 44 is a quadratically con-
strained quadratic program (QCQP) with single equality
constraint. The Algorithms proceeds in three serial and
disjoint steps.

1. Select ansatz, which can be done on paper

2. Estimate overlap matrices on quantum computer,
which can be done eﬃciently in a parallel fashion.

3. Post-processing on a classical computer to solve the
QCQP based on the overlap matrices from step 2.

As a major speedup compared to standard VQA, there
is no feedback loop between classical and quantum com-
puter such that the calculations can be easily parallelized.

The ansatz can be improved by changing K to K + 1.
The ansatz construction is systematic and there is no
trainability issue such as the barren plateau problem (see
Sec. IV.A). For the QCQP, there exist conditions which
tell whether a local minima is a global minima as a stop-
ping criteria for the classical solver. Moreover, the La-
grangian relaxation of the program 44 is a semideﬁnite
program and eﬃciently solvable.

IV. THEORETICAL CHALLENGES

A. Barren plateaus

It was recently shown that the expectation value of
the gradient of the objective function corresponding to
randomly initialized PQCs (RPQC) decays exponentially
to zero as a function of the number of qubits (McClean
et al., 2018). The mathematical basis of this result hinges
on the fact that the PQC from Eq. (22) becomes a unitary
2-design as the circuit depth increases polynomially with
the circuit width i.e, the number of qubits. The notion of
unitary 2-design has been used extensively in the recent
proofs of barren plateau in RPQCs, which necessitates a
small discussion about their mathematical structure.

Using the notion of 2-design, the appearance of bar-
ren plateaus in the training landscape has been estab-
lished for various kind of ansätze. Barren Plateaus can
be thought of as a consequence of the exponentially large
dimension of the Hilbert space when the number of qubits
increases and the fact that the variational circuit unitary,
when the parameters are initialized at random, is a 2-
design. Consequently, the strategies proposed to tackle
this problem focus on reducing the space dimension of
this unitary or breaking the randomness properties re-
lated to the 2-designs. Another way to think of the origin
of the barren plateau issue could be the problem-agnostic
nature of the ansatz, faced with exponentially large pa-
rameter space. Thus, one could attempt to devise ansätze
as well as the optimization methodology in a problem-
aware manner by using physically-inspired or problem-
speciﬁc ansätze as the ones presented in Sec. II.B or those
proposed in Sec. III.E.

Besides the exponential parameter space that induced
barren plateaus, other physical phenomena can also gen-
erate them.
In particular, the noise and decoherence
present in the quantum computing experiments also
generates this problem in VQAs (Wang et al., 2020b).
Entanglement-induced barren plateaus have also been re-
ported recently (Marrero et al., 2020).

While certain ansätze can be assumed or proven to
form (approximate) 2-designs, such proofs are challeng-
ing for the general ones. To numerically verify the pres-
ence of barren plateaus, past studies often considered
computing the gradients and variances of a local ob-
servable using a particular ansatz over increasing system

23

sizes (McClean et al., 2018; Skolik et al., 2020).

Another attempt to avoid a barren plateau is to initial-
ize the variational circuit with a particular state choice.
Intuitively, the algorithm will start in a particular re-
gion of the Hilbert space allowing the optimization sub-
routine to potentially ﬁnd the minima in a closer re-
gion. This strategy include all physically inspired meth-
ods mentioned in Sec. II.B. The use of clever encod-
ings for the algorithm parameters can also be understood
as a initialization strategy (Cervera-Lierta et al., 2021a)
(see Sec. VI.B). Classical algorithms such as neural net-
works can also be used to learn the proper circuit encod-
ings (Verdon et al., 2019a).

A good choice for the initial state is often not enough to
reduce the size of the Hilbert space. Although expressive
circuit ansätze are usually a requirement for the success
of a VQA (see Sec. IV.B for more details), it can expand
the parameter space that the optimizer has to explore.
Several works propose circuit structures that reduce that
space by introducing correlations between the variational
parameters of the circuit (Volkoﬀ and Coles, 2021), block-
wise initialization of those parameters (Grant et al., 2019)
or exploring particular ansatz structures (Sharma et al.,
2020).

The mentioned works require a circuit design that is
not necessarily hardware eﬃcient. Other ideas focus on
the classical parts of the VQA instead of the quantum
circuit designs. One example is using local instead of
global cost functions for the optimization. It has been
shown (Cerezo et al., 2021) that barren plateaus also
emerge in shallow depth circuits, and that the use of
local cost functions reduces the exponential decay ten-
dency to a polynomial one. The optimization strategy
may also reduce the eﬀect of the vanishing gradients,
for instance by training the circuit layer by layer (Lyu
et al., 2020; Skolik et al., 2020) or by measuring low depth
gradients (Harrow and Napp, 2019). Certain variational
quantum algorithms for quantum simulation can be free
of barren plateaus when at every training step the state
to be learned is close to the state of the circuit (Haug
and Kim, 2021b).

Barren plateaus are a roadblock in the trainability
and hence any PQC ansatz which suﬀers from this phe-
nomena will fail to properly train the parameters in its
search for the near-optimal (or optimal) performance. As
shown in Ref. (Arrasmith et al., 2020a), even the family
of gradient-free approaches which perform local search,
therefore mimicking gradient-based optimization, seem
to face similar challenges. However, one can circumvent
this issue by using hybrid quantum states of the form
of equation Eq. (42) or hybrid density matrices as in-
troduced in Ref. (Haug and Bharti, 2020). The idea is
to write the overall ansatz as a classical combination of
quantum states i.e, ∣φ (α(t), θ)⟩ = ∑m−1
i=0 αi(t)∣ψi (θi)⟩.
Tuning the θi can often lead to barren plateaus. One can
avoid such issues by ﬁxing θi by harnessing the structure

of the problem to ﬁnd the basis states of the ansatz, i.e,
{∣ψi (θi)⟩} (see Sec. III.E for more details). Interestingly,
quantum convolutional neural networks also do not ex-
hibit barren plateaus (Pesah et al., 2020).

B. Expressibility of variational ansätze

A cornerstone in the success of VQA is choosing the
proper ansatz for the problem. In addition to trainabil-
ity, i.e. how well the ansatz can be optimized, another
major quality is expressibility. This concerns whether a
given PQC is able to generate a rich class of quantum
states. The number of PQC layers, parameters or entan-
gling gates required to achieve a given accuracy is also
linked to the expressibility of the circuit.

Expressibility. Sampling states from a PQC ∣ψθ⟩ for ran-
domly chosen θ generates a distribution of states. Ex-
pressibility is deﬁned as the deviation of this distribution
from the Haar measure, which samples uniformly from
the full Hilbert space

θ

Haar

A(t) = ∣∣ ∫

(∣ψ⟩ ⟨ψ∣)⊗tdψ − ∫

(∣ψθ⟩ (⟨ψθ∣)⊗tdψθ∣∣2

is more expressive, with A(t)

HS ,
(45)
dψ denotes the integration over a state ∣ψ⟩
where ∫Haar
distributed according to the Haar measure and ∣∣A∣∣2
HS =
Tr(A†A) the Hilbert-Schmidt norm. An ansatz circuit
U with small A(t)
U = 0 cor-
U
responding to being maximally expressive, as it gener-
ates quantum states with a distribution closer to the
Haar measure. The PQC samples uniformly from the
full Hilbert space and thus is able to approximate any
possible state. This is especially important in the case
where one wants to train the PQC to represent a partic-
ular quantum state while having little prior information
about the state. A highly expressive PQC is more likely
to be able to represent the target state.

Entangling capability. This measure denotes the power
of a PQC to create entangled states and can be used as
another quantiﬁer of the expressiveness of an ansatz. In
(Sim et al., 2019) the Meyer-Wallach Q measure (Meyer
and Wallach, 2002) has been proposed to estimate the
number and types of entangled states a particular PQC
can generate. One deﬁnes a linear mapping ιj(e)
that acts on the computational basis ιj(b) ∣b1⋯bn⟩ =
δbbj ∣b1⋯˜bj⋯bn⟩, where bj ∈ {0, 1} and ˜bj denotes absence
of the j-th qubit. The entanglement measure Q is then
deﬁned as

Q(∣ψ⟩) ≡

4
n

n
∑
j=1

D(ιj(0) ∣ψ⟩ , ιj(1) ∣ψ⟩ ),

(46)

24

where D is the generalized distance deﬁned by the coef-
ﬁcients of two states ∣u⟩ = ∑ ui ∣ei⟩ and ∣v⟩ = ∑ vi ∣ei⟩,

D(∣u⟩ , ∣v⟩) =

1
2

∑
i,j

∣uivj − ujvi∣2.

(47)

It can be rewritten as the average of the purity of each
qubit (Brennen, 2003)

Q(∣ψ⟩) = 2(1 −

1
n

n
∑
k=1

Tr[ρ2

k]) ,

(48)

where ρk is the density matrix of the k-th qubit. Thus,
Q(∣ψ⟩) is an entangling monotone (Scott, 2004) and can
be interpreted as the average of the entanglement of each
qubit with the rest of the system.

Only if the state is a product state we ﬁnd Q = 0,
whereas Q = 1 is reached for certain entangled states
such as the GHZ state. The entangling capability of a
PQC is then deﬁned as the average Q of states randomly
sampled from the circuit.

Ent =

1
∣S∣

∑
θi∈S

Q( ∣ψθi⟩ ),

(49)

where S = {θi}i is the set of sampled circuit parameters.

Parameter dimension The parameter dimension DC is
the number of independent parameters of the quantum
state that is generated by the PQC (Haug et al., 2021a).
From this measure, one can calculate the redundancy
the fraction of parameters that can be
of a PQC, i.e.
removed without loss of expressive power. A further
local measure of expressibility is the eﬀective quantum
dimension GC(θ), which can be used to calculate the
expressive power of initialization strategies for the PQC.
Under a small variation of the PQC parameter θ, it mea-
sures how many independent directions in the parameter
space exist for the quantum state. Both measures
can be calculated as the number of non-zero eigenval-
ues of the Fubini-Study metric tensor deﬁned in Eq. (33).

√

In (Haug et al., 2021a; Nakaji and Yamamoto, 2020a;
Sim et al., 2019), a wide class of circuits have been in-
vestigated with the aforementioned expressibility mea-
sures. It has been found that certain types of ansätze are
more expressive, e.g. layered PQCs consisting of CNOT
or
iSWAP gates are more expressive than CZ. There
is a trade-oﬀ between an ansatz being expressive and
trainable. Making an ansatz more expressive most likely
will result in reducing the gradient of the objective func-
tion. In (Holmes et al., 2021), the authors suggest several
strategies for reducing expressibility and improving train-
ability, including correlating parameters or restricting ro-
tation angles of parameterized gates. Interpolating the
PQC parameters between ﬁxed and random angles has

been proposed as another method (Haug et al., 2021a).
Expressibility of PQCs have been further explored us-
ing classical Fisher information (Abbas et al., 2021) and
memory capacity (Wright and McMahon, 2019).

It has been shown that alternating layered ansatz (see
Sec. II.B.2) is both relatively expressive as well as does
not exhibit barren plateaus in certain regimes (Nakaji
and Yamamoto, 2020a). In VQE algorithms, there is a
trade-oﬀ between the number of layers in this ansatz and
the correlation length of critical Hamiltonians. However,
in the critical phase, the number of layers must exceed
a certain threshold dictated by the system size to show
an exponential improvement. The circuit depth unravels
an eﬀective correlation length that can be used as an
estimation of the number of free parameters in the ansatz
(Bravo-Prieto et al., 2020b).

C. Reachability

Reachability discusses the question whether a given
PQC ∣Ψ(θ)⟩ with parameters θ is capable of representing
a quantum state that minimizes some objective function.
This can be quantiﬁed by the reachability deﬁcit over
ﬁnding the minimum of an objective function ˆO (Akshay
et al., 2020a) as

fR = minψ∈H ⟨ψ∣ O ∣ψ⟩ − minθ ⟨Ψ(θ)∣ O ∣Ψ(θ)⟩ ,

(50)

where the ﬁrst term on the right side is the minimum
over all states ∣ψ⟩ of the Hilbert space, whereas the sec-
ond term is the minimum over all states that can be rep-
resented by the PQC. The reachability deﬁcit is equal or
greater than zero fR ≥ 0, with fR = 0 when the PQC can
generate a state ∣Ψ(θ∗)⟩, where θ∗ are the parameters
that minimizes the objective function.

Reachability has been studied in-depth for QAOA.
Although QAOA has been shown to exhibit quantum
computational universality (Lloyd, 2018; Morales et al.,
2019), which implies that any unitary operator is reach-
able under the QAOA ansatz, this statement does not
hold true for ﬁnite ﬁxed depths p. In fact, it was shown
that QAOA exhibits reachability deﬁcits for the MAX-2-
SAT and MAX-3-SAT problems, where the optimal value
of the objective function cannot be found using a ﬁxed
circuit depth p beyond a critical clause density (deﬁned
as the ratio between the number of clauses and the num-
ber of variables in the problem) (Akshay et al., 2020a). In
other words, for problems with a certain clause density,
there is a critical depth p∗ for which the optimal solution
can only be found (up to a threshold) if p ≥ p∗. As p∗
grows with the clause density, this limits the performance
of QAOA for problem instances with high clause density.
Similar reachability deﬁcits have also been found in the
variational Grover search problem (Akshay et al., 2020a).
Moreover, by re-analyzing the experimental data from
Google’s Sycamore quantum processor on the application

25

of QAOA to various graph optimization problems (Har-
rigan et al., 2021), authors from (Akshay et al., 2020b)
also discovered reachability deﬁcits in this case, where the
graph density (deﬁned as the ratio between the number
of graph edges to the number of graph nodes) replaces
the clause density as the order parameter.

Note that the reachability deﬁcits are distinct from the
barren plateau problem, where the gradients of the ob-
jective function concentrate to zero for many choices of
initial variational parameters, thus slowing down the op-
timization process. On the other hand, the reachability
deﬁcit for p < p∗ is independent of the initial parameters.

D. Theoretical guarantees of the QAOA algorithm

The QAOA has several key analytical results which
have contributed to its considerable interest in recent
years. The quantum advantage of QAOA algorithm has
been studied in (Farhi and Harrow, 2016), where they
showed that the eﬃcient sampling of the output dis-
tribution of QAOA, even for the lowest depth case of
p = 1, implies the collapse of the polynomial hierarchy
(see Sec. I.A ). Following the conjecture from complexity
theory that the polynomial hierarchy does not collapse,
this result propels QAOA as a possible candidate for es-
tablishing some quantum advantage.
In particular, it
has been shown that for p = 1, 420 qubits would suﬃce
to demonstrate quantum advantage (Dalzell et al., 2020).
The power of QAOA compared to classical algorithms
is an ongoing topic of research. For speciﬁc instances
of the Max-Cut problem, QAOA for p = 1 was shown
to perform equally well or worse than classical algo-
rithms (Bravyi et al., 2019; Hastings, 2019). For more
discussion on QAOA for Max-Cut, refer to Sec. VI.C.1.
For QAOA of depth p, the measurement outcomes of
a qubit depend on the p-neighbourhood of that qubit.
Thus if p is too small, it does not ‘see’ the whole graph
(Farhi et al., 2020a,b). For large p, the QAOA algorithms
can ‘see’ the whole graph with no known indications re-
garding the performance limitations.

For the case where the problem Hamiltonian HP takes

the form

HP = ∑
i

ωA ˆσ2i

z + ωB ˆσ2i+1

z

+ γAB ˆσ2i

z ˆσ2i+1
z

+ γBA ˆσ2i+1

z

ˆσ2i+2
z

,

(51)
where ωA(B)
are the coeﬃcients for the even (odd) sites
and γAB(BA)
are the interaction strength between ﬁrst
(second) neighbour spins. Taking HM as deﬁned in
Eq. (19) for a 1D lattice, Ref.
(Lloyd, 2018) showed
that QAOA can be used to implement universal quan-
tum computation. This result was proven and general-
ized in a later work (Morales et al., 2019) to include a
larger class of problem and mixing Hamiltonians that can
provide computational universality for QAOA.

By connecting VQA with optimal control theory, Pon-
tryagin’s minimum principle of optimal control is used to
show that the bang-bang protocol (in which the evolution
switches abruptly between two Hamiltonians) is optimal
for a ﬁxed total time T (Yang et al., 2017). Since QAOA
can be regarded as a bang-bang ansatz by switching be-
tween unitary evolution under HP and HM respectively,
this suggests the optimality of QAOA as a VQA. How-
ever, recent works have challenged this claim. By general-
izing the argument in Ref. (Yang et al., 2017), it has been
shown that the optimal protocol actually possesses the
‘bang-anneal-bang’ structure (Brady et al., 2020). Such
protocols begin and end with a bang, with regions of
smoothly varying control function (akin to quantum an-
It was also shown that when the
nealing) in between.
total time T is large, bang-bang QAOA suﬀers from the
proliferation of local minima in the control parameters,
rendering it diﬃcult to ﬁnd optimal (or near-optimal)
QAOA parameters.

V. PROGRAMMING AND MAXIMIZING NISQ UTILITY

Current NISQ devices have a limited number of qubits
(∼ 50 − 100) available.
In addition, due to their noisy
nature and short coherence time, one can only perform
a restricted number of gate operations.
In order to
make maximal use of the currently available quantum
resources, there are two approaches from the operational
point-of-view: the bottom-up and the top-down. The
bottom-up approach refers to the scenario where one has
full control over the design of any quantum computing
platform to keep pushing the performance quality such
as gate ﬁdelity and coherence time for a given hardware
design constraints. The top-down approach means im-
plies that one does not get involved in hardware design
and simply makes use of what has already been made
or fabricated in the experimental labs. In this section,
we focus on the latter approach, i.e. extending or maxi-
mizing the utility of current and near-term quantum de-
vices from an algorithmical perspective. Finally, we also
present a summary of software tools to control, program
and maximize the utility of NISQ algorithms.

A. Quantum error mitigation (QEM)

Sensitivity to errors and noise are the two most promi-
nent roadblocks towards scalable universal quantum com-
puters. Fault-tolerant quantum computing can be at-
tained by encoding non-Abelian anyons in topological
materials (Kitaev, 2003) or applying quantum error cor-
rection codes (Raussendorf and Harrington, 2007). While
the former is still in its infancy, the latter mandates
physical resources exceeding our current experimental
In the NISQ era of running hybrid quan-
capabilities.

26

tum/classical algorithms, it is desirable to use all the
restricted and available qubits as logical qubits without
applying QEC techniques. As we discuss throughout this
review article, the hybrid quantum/classical algorithms
rely on computing the expectation value of some physical
observables using quantum processors. Quantum error
mitigation (QEM) techniques discussed in this subsection
need no extra qubit and can suppress errors in ﬁnding ex-
pectation values with simple classical post-processing and
diﬀerent runs of quantum circuits. To be precise, with
QEM, we are not interested to recover the ideal quantum
output state ˆρ(0), but to estimate the ideal observables
ˆA expectation value: E[µ(0)] = ⟨ ˆA(0)⟩ = Tr(ˆρ(0) ˆA) (Kan-
dala et al., 2019; Li and Benjamin, 2017; Temme et al.,
2017), sometimes surpassing the break-even point, where
the eﬀective gates are superior to their physical building
blocks, at an aﬀordable cost with respect to near-term
quantum hardware (Zhang et al., 2020b). Here, µ is the
outcome of a measurement and we use superscript (0) to
denote an ideal noise-free realization of a state, operation
or observable quantity. Recently, it was also shown how
to achieve stochastic error mitigation for a continuous
time evolution (Sun et al., 2020a). For a comprehensive
treatment on quantum error mitigation, refer to (Endo
et al., 2020a).

1. Zero-noise extrapolation

(Li and Benjamin, 2017), and (Temme et al., 2017)
independently and concurrently proposed the Richard-
son extrapolation QEM, namely zero-noise extrapolation
(ZNE), where a quantum program is to operate at var-
ious eﬀective noise levels of a quantum processor. It is
then extrapolated to an estimated value at a noiseless
level.

Formally, a quantum circuit/system in the presence
of noise can be modelled as an open quantum sys-
tem (Breuer et al., 2002) using the Gorini-Kossakowski-
Sudarshan-Lindblad equation or in short the Lindblad
master equation (setting ̵h = 1):

ˆρ(t) = −i [ ˆK (t) , ˆρ (t)] + ˆˆL [ˆρ (t)] ,

(52)

d
dt

{ ˆOk ˆO†

where ˆK(t) acts as time-dependent driving Hamiltonian,
and ˆˆL[.] = ∑k Γk( ˆOk[.] ˆO†
k, [.]}) is a superop-
k − 1
2
erator. The above equation in general describes Marko-
vian dynamics for Γk ≥ 0. Whenever loss rate Γk become
negative (Fleming and Hu, 2012; Rivas et al., 2010), the
above equation would also describe non-Markovian dy-
namics (Bastidas et al., 2018; Kyaw et al., 2020a; Tan
et al., 2010). To ensure the complete positivity, we re-
quire ∫
0 Γ(t′)dt′ > 0, ∀t. In general, Γk are ﬁxed by the
nature of the noise experienced by a quantum system.
Mathematically, one can parametrize Γk with a dimen-
sionless scalar λ, i.e., Γk → λΓk. When λ = 0, there is no

t

noise and the second term (loss term) in Eq. (52) is zero,
resulting in pure unitary dynamics. When λ = 1, the ac-
tual quantum device loss rate is matched. In summary,
ZNE involves two steps.

1. Noise-scaling: we make a number of measurements

E[µ(λj )] for λ ≥ 1.

2. Extrapolation: we estimate E[µ(0)] from the pre-

vious step.

can be accomplished in three ways. Firstly,
Noise-scaling
in Ref.
(Temme et al., 2017) it was proposed to use
a time-scaling approach by taking λ > 1, which means
that the time-dependent driving Hamiltonian ˆK(t) is
ˆK(t/λ). This approach is only pos-
now rescaled by 1
λ
sible if the user has full control over back-end quantum
processor. Control pulses for each quantum gate have
to be recalibrated and be applied for longer duration.
Secondly, one can apply a technique called circuit fold-
ing (Giurgica-Tiron et al., 2020). Suppose that a quan-
tum circuit is composed of d unitary layers such that
U = Ld⋯L2L1 where d refers to the circuit depth and
each Lj either represents a single layer of gate opera-
tions or just a single quantum gate. The circuit folding
is then achieved by

U → U (U †U )n,

(53)

where n is some positive integer. Since U †U is an iden-
tity, this action has no eﬀect on an ideal circuit. However,
in noisy circuit, U is imperfect and the above 1 + 2n cir-
cuit operations would increase the noise level. Thirdly,
instead of entire circuit folding, one can also use gate
folding technique (Giurgica-Tiron et al., 2020):

Lj → Lj(L†

jLj)n.

(54)

The second and third techniques do not require users to
have full control of quantum computer back-end and thus
we expect to be of greater use in software level control of
quantum circuits.

Extrapolation step of the ZNE method can be consid-
ered as a regression problem if we choose to consider
a generic model for calculating the expectation value
Emodel[µ(λ;Υ)], where the meaning of model would be-
come clear shortly and Υ corresponds to the model pa-
rameters. We note that the expectation value E is
a real number that can only be obtained in the inﬁ-
nite measurement limit. With limited number of mea-
surement samples N , statistical estimation is ˆE[µ(λ)] =
E[µ(λ)] + ˆδ 1, where ˆδ is a random variable with zero

1 The hat notation used is in accordance with statistics notation

and should not be confused with a quantum operator.

27

0/N . Here, σ2
0

mean and variance σ2 = E(ˆδ2) = σ2
is
the single-shot variance. Given a set of m scaling pa-
rameters λ = {λ1, λ2, ⋯, λm} with λj ≥ 1, and the corre-
sponding measurement outcomes µ = {µ1, µ2, ⋯, µm}, the
ZNE is nothing but to build a good estimator ˆE[µ(0)] for
E[µ(0)] such that its bias E( ˆE[µ(0)] − E[µ(0)]), and its
variance E( ˆE[µ(0)]2) − E( ˆE[µ(0)])2 are both reasonably
small. Onwards, let us adopt a simpliﬁed notation of
E[µ(λ)] = E(λ). Now let us mention brieﬂy the statis-
tical models. The expectation value E(λ) cannot be of
any arbitrary function, which would make ZNE impos-
sible to extrapolate back to E(0). Depending on some
underlying noise model assumption, one can apply vari-
ous statistical models.

The polynomial extrapolation is based on the polynomial
model of degree d such that

E(d)

(55)

poly(λ) = c0 + c1λ + ⋯ + cdλd,
where cj are d + 1 unknown real parameters. This ex-
trapolation is justiﬁed in weak noise limit and we need
the number of data points m to be equal or larger than
d+1. Consequently, we can obtain two other variants: the
linear extrapolation (d = 1) and the Richardson extrapo-
lation (d = m−1) (Temme et al., 2017). By construction,
the error with respect to the true expectation value is
O(m) when we have large sample size N → ∞. By using
the interpolating Lagrange polynomial, the estimator is
explicitly given by:

,

(56)

µk ∏
i≠k

λi
λi − λk

ˆERich(0) = ˆc0 =

m
∑
k=1
with the assumption that all λj are diﬀerent. One impor-
tant observation is that the Richardson model based ZNE
is dictated by a statistical uncertainty which is exponen-
tially scaling with the number of data points. There are
also other statistical models such as poly-exponential ex-
trapolation (Giurgica-Tiron et al., 2020) and exponential
extrapolation (Endo et al., 2018). Various exponential
extrapolation methods have been proposed and investi-
gated in (Cai, 2020a) and applied to depolarizing noise
in (Vovrosh et al., 2021).
In fact, (Cai, 2020a) shows
that the ZNE, quasi-probability and stabiliser-based ap-
proach can be combined by exploiting novel aspects of
the individual technique.

The ZNE scheme suﬀers from a few limitations. The
scheme works by extrapolation, and hence it is challeng-
ing to obtain result guarantees in general. The number
of measurement shots required to obtain the mitigated
expectation value can be relatively high compared to the
unmitigated case as seen above. More importantly, the
fundamental drawback of both ZNE and probabilistic er-
ror cancellation (PEC) (Temme et al., 2017), or quasi-
probability method (which is discussed next) is that one

needs to know the precise physical noise model in ad-
vance, which in itself is a diﬃcult problem. Experimen-
talists in the lab will have imperfect knowledge about
the real noise, which will typically diﬀer from the canon-
ical ones. We will also discuss a more practical approach
based on gate set tomography proposed in Ref. (Endo
et al., 2018), which does not require explicit knowledge of
the noise model and mitigates any localized Markovian
errors, so that the error in the ﬁnal output is only due to
unbiased statistical ﬂuctuation.

2. Probabilistic error cancellation

28

them), the real numbers ql, which represent quasiproba-
bilities, can be eﬃciently derived. Here, each L(l)
repre-
tot
sents the total sequence of noisy gates in the lth circuit.
Monte Carlo sampling could be used to compute ⟨ ˆA(0)⟩
by randomly choosing the lth circuit with the probability
pl = ∣ql∣/C, where C = ∑l ∣ql∣. Lastly, the computed result
is given by the expected value of eﬀective measurement
outcomes ⟨A(0)⟩ = CE[µeﬀ], where the eﬀective outcome
is µeﬀ = sgn(ql)µ(l) if the lth circuit is chosen and µ(l) is
the outcome from the lth circuit.

As a consequence, the mean value of the PEC outcome
centers around the ideal one with larger variance due to
C (see Fig. 5 right corner).

Let us familiarize ourselves with the notations used in
quantum tomography (Greenbaum, 2015; Merkel et al.,
2013), which we adopt here. A quantum state is repre-
sented by a density matrix ˆρ, and a physical observable
is denoted by a Hermitian ˆA operator. An operation is
a map on the states space such that one can use the
Kraus representation to denote it as: ˆˆL[ˆρ] = ∑j
ˆKj ˆρ ˆK †
j .
We note that this equivalence with Eq. (52) is only valid
when we have Markovian dynamics. Here, ˆKj are Kraus
operators.
In terms of the Pauli transfer matrix rep-
resentation, ˆρ in Eq. (52) can be written as a column
vector (Navarrete-Benlloch, 2015), denoted as ∣ρ⟫. Sim-
ilarly, the Lindblad superoperator ˆˆL can be recast as
a square matrix,
i.e., using the Pauli transfer matrix
representation, since it is a linear map. For simplicity
and without loss of generality, we may absorb the uni-
tary dynamics (the ﬁrst term in Eq. (52)) into ˆˆL on-
wards. A physical observable ˆA is now written as a
row vector ⟪A∣. Consequently, the expectation value is
⟨ ˆA⟩ = Tr[ ˆAˆρ] = ⟪A∣ρ⟫. Likewise, the expectation of ˆA
after the state ˆρ passing through a series of linear maps
is read as: Tr[ ˆA

ˆˆLN ○ ⋯ ○ ˆˆL1(ˆρ)] = ⟪A∣LN ⋯L1∣ρ⟫.

The central theme of probabilistic error cancellation
(PEC) or quasiprobability decomposition introduced by
the IBM team in Ref. (Temme et al., 2017) is that one
can estimate the expectation value of an observable by
sampling from a set of erroneous circuits, labelled by L(l)
tot
for l = 1, 2, ⋯, such that

⟨ ˆA(0)⟩ = ∑
l

ql⟪A(l)∣L(l)

tot∣ρ(l)⟫.

(57)

The expectation of an observable is going to be far-oﬀ
(without QEM) from the ideal value due to the pres-
ence of noise2. Given speciﬁc error models (assuming
experimentalist has full and correct knowledge about

2 The superscript (0) to denote the ideal noise-free realisation of

a state, operation or observable quantity.

The above PEC method relies on the correct knowl-
edge of error model L(l)
as is apparent from Eq. (57).
tot
To enable practical implementations, (Endo et al., 2018)
proposes to combine linearly independent basis set oper-
ations and gate set tomography to fully remove impact of
localized Markovian errors by systematically measuring
the eﬀect of errors to design eﬃcient QEM circuits. The
set of operations including measurement and single-qubit
Cliﬀord gates is universal in computing expected values
of observables. For the single-qubit case, any operation
L which is a 4 × 4 real matrix in the Pauli transfer matrix
representation, can be expressed as a linear combination
of 16 basic operations, i.e., L = ∑16
, which are
composed of {π, H, S, Rx, Ry} gates (Endo et al., 2018).
Similarly, the same decomposition can be applied to the
two-qubit case. See Fig. 5 for example decompositions.

i=1 qiB(0)

i

A way to systematically measure errors is through gate
set tomography (GST), with which one can even mitigate
state preparation and measurement errors. In short, the
purpose of GST is to measure noisy individual quantum
circuit performance a priori. For a single-qubit gate, one
prepares initial states ∣0⟩ , ∣1⟩ , ∣+x⟩, and ∣+y⟩, where ∣+x⟩
and ∣+y⟩ are the eigenstates of Pauli operators ˆσx and
ˆσy with +1 eigenvalue, respectively. For noisy devices,
these four states are denoted as ¯ρ1, ¯ρ2, ¯ρ3 and ¯ρ4, ac-
cordingly. We also use ¯L (superoperator) to denote a
noisy/imperfect gate to be measured. Since what we care
about are expectation value of physical observables, for
single-qubit case, we have observables ˆI, ˆσx, ˆσy, ˆσz, de-
noted as ¯A1, ¯A2, ¯A3, ¯A4. The mean value of observables,
the 4×4 matrix ˜A, is nothing but ˜Aj,k = Tr[ ¯Aj ¯L¯ρk]. Sim-
ilarly, we can also construct the 4 × 4 matrix g without
applying any gate to the initial states as gj,k = Tr[ ¯Aj ¯ρk].
This is repeated for each qubit and each single-qubit gate.
Statistical estimation of the initial states ¯ρk and the ob-
servables ¯Aj are then given by

∣ˆρk⟫ = T●,k,
⟪ ˆAj∣ = (gT −1)j,●,
where we note that the hat symbol represents the statis-
tical estimate and T●,k(Tj,●) denotes the kth column (jth
row) of the matrix T , where T is an invertible 4×4 matrix

(59)

(58)

29

Figure 5 Quantum computing of the expected value of an observable using gate set tomography-based PEC. Quasiprobability
decomposition of initial state preparation, examplary single- and two-qubit processes are computed. Implementing the resulting
decomposition is done using the Monte Carlo approach. With QEM, the probability distribution of expected value of the physical
observable is now centered around an ideal value with larger variance as compared to the one without QEM. Inspired by (Zhang
et al., 2020b).

with the following relationship ˆL = T g−1 ˜LT −1. The same
procedure applies for the two-qubit case with the only
diﬀerence being that there are total of 16 initial states:
to be measured.
¯ρk1 ⊗ ¯ρk2
Similarly, we have g = g1 ⊗ g2 and T = T1 ⊗ T2. We have
to implement two-qubit gate GST for each qubit pair in-
volved in a quantum program run.

and 16 observables: ¯Aj1 ⊗ ¯Aj2

Quasiprobability decomposition is

then computed
based on GST results above. From GST, we have esti-
mation of initial states ∣ˆρk⟫, observables to be measured
⟪ ˆAj∣, and gates ˆL. Let’s denote L(0) as the Pauli transfer
matrix of the ideal gate with no error. The main idea of
decomposition comes from a very simple idea that a noisy
gate operation comes from an ideal operation followed by
a noise operation, i.e., L = N L(0). Hence, the inverse of
the noise is given by N −1 = L(0) ˆL−1 = ∑i qL,i ˆBi. And,
by applying the inverse of the noise after the operation,
we can obtain the operation without error: L(0) = N −1L.
Notice that the matrices in the above equation are ob-
tained from the ﬁrst GST step. The remaining task is
to determine quasiprobabilities qL,i for each qubit and
gate involved by solving the above equation. We note
that instead of quasiprobabilistic decomposition of quan-
tum gates, one could in principle use randomized compil-
ing technique proposed in Ref. (Wallman and Emerson,
2016).

GST-based PEC experiments have recently been done
in trapped-ion systems (Zhang et al., 2020b) and super-

conducting circuits (Song et al., 2019). Lastly, a similar
strategy was recently applied to mitigating errors in mea-
surement readout (Kwon and Bae, 2020).

3. Other QEM strategies

We have seen that the quantum error mitigation tech-
niques discussed so far do not require any ancilla or extra
qubits with the caveat that one needs to perform more
measurements. At the same time, one is only interested
in information about the expectation value. Along this
line of thought, there exist several proposals, which we
will outline below. However, some of the methods might
require ancilla qubits.

Subspace expansion method (Barron et al., 2020; Colless
et al., 2018; McArdle et al., 2019c; McClean et al., 2020c,
2017; Sagastizabal et al., 2019a) are designed to mitigate
errors in the VQE routine, where we often tend to ﬁnd
an approximate ground state ∣ψa⟩ of a system Hamilto-
nian H. However, such state may diﬀer from the true
ground state ∣ψg⟩ due to noisy processes.
In general,
we do not know which error occurred to the state. The
subspace expansion method works by resolving the ac-
tion of H on the linear combination of quantum states
ansatz Eq. (42). The subspace is spanned by a set of

ProbabilityExpectationvalueideal valuewith error mitigationno error mitigationQuasi-probability decompositionoperators ˆOi, i.e., {∣ ˆOiψa⟩}. Now, one proceeds to evalu-
ate Hij = ⟨ψa∣ ˆOiH ˆOj ∣ψa⟩, and Sij = ⟨ψa∣ ˆOi ˆOj ∣ψa⟩. The
latter is needed since the subspace states are in general
not orthogonal to each other. By solving the general-
ized eigenvalue problem HC = SCE, with eigenvectors
C and diagonal matrix of eigenvalues E, we can obtain
the Hamiltonian spectra including the excited states (see
Sec. VI.A.4).

This method requires an appropriate choice of sub-
space operators to mitigate errors due to external noise.
In general, without knowing the noise models of quan-
tum device, it would require an exponential number of
expansion operators to obtain the optimal groundstate.

Stabilizer based approach (Bonet-Monroig et al., 2018;
Cai, 2021; McArdle et al., 2019c; Sagastizabal et al.,
2019a) relies on the information associated with con-
served quantities such as spin and particle number con-
If any change in such quantities is de-
serving ansatz.
tected, one can pinpoint an error in the circuit, which is
akin to stabilizer measurement in quantum error correc-
tion schemes. We can implement the stabilizer measure-
ments by adding ancilla qubits to the qubit registers or
taking additional measurements and post-processing.

Individual error reduction method was proposed in Ref.
(Otten and Gray, 2019). As we have seen earlier, Marko-
vian noise can be modelled using the Lindblad master
= ˆˆL(ˆρ) = ∑i Li(ˆρ),
equation, Eq. (52), where we have d ˆρ
dt
where each Li denotes a noise channel present. Here,
we have absorbed the unitary component into ˆˆL. It was
shown that

˜ρ(T ) = ˆρ(T ) −

(ˆρ(T ) − ˆρj(T )) ,

m
∑
j=1
= ˆρ(0)(T ) + O(τ 2).

1
gj

(60)

(61)

Notational explanations are as follows. ˆρ(T ) is the den-
sity matrix after applying quantum gates with the pres-
ence of all associated noise channels at the ﬁnal evolution
time T . In contrast, ˆρj(T ) is the state under the inﬂuence
of all the noise channels but one less Lj according to the
ratio gj. Notice that if gj = 1, we have fully removal of the
entire channel Lj. ˆρ(0)(T ) is the ideal output state with-
out any error, while τ is the evolution time for each noise
process after the gate application. We note that the ﬁrst-
order error O(τ ) is removed. As usual, what we want to
obtain is ⟨ ˆA⟩ = Tr[ˆρ(0)(T ) ˆA] for a physical observable ˆA.
We can arrive at it by using Eq. (60). Though its result
is neat and beautiful, this method assumes a perfect re-
moval of individual noise channel. Hence, it is relatively
unrealistic on current quantum hardware as compared to
other strategies.

30

con-
Dynamic error suppression/robust control techniques
cern suppression of experimental gate errors at the pulse
control level, which can be passive as well as active one.
Pulse shaping technique is a strategy for passive can-
cellation of system-bath interaction. Traditionally, this
method stands on the shoulder of a mean to obtain high-
ﬁdelity quantum gate in nonlinear qubits such as trans-
mons, commonly known as derivative removal of adia-
batic gate (DRAG) scheme (De, 2015; Gambetta et al.,
2011; Motzoi et al., 2009). On the other hand, dynami-
cal decoupling (DD) (Santos and Viola, 2005; Viola and
Knill, 2005; Viola et al., 1999) is a very well-known and
widely used quantum control technique in the litera-
ture, which is designed to suppress decoherence via fancy
pulses to the system so that it cancels the system-bath in-
teraction to a given order in time-dependent perturbation
theory (Lidar, 2014) in an active manner. Recently, DD
experiments were performed on the 16-qubit IBMQX5,
5-qubit IBMQX4, and the 19-qubit Rigetti Acorn chips
(Pokharel et al., 2018), where the gain in substantial gate
ﬁdelity relative to unprotected, free evolution of individ-
ual transmon qubits was demonstrated. One may com-
bine DD and pulse shaping technique to obtain dynami-
cally corrected gates (Edmunds et al., 2020; Khodjasteh
and Viola, 2009) composing of shaped pulses which ac-
tively drive state evolution within a Hilbert space in order
to cancel certain system-bath couplings. With the avail-
ability of Qiskit Pulse (Alexander et al., 2020) that allows
users to control backend pulse shapes and sequences of a
quantum processor on the ﬂy, a recent study (Carvalho
et al., 2020), based on the Qiskit Pulse and robust con-
trol techniques, demonstrates enhancement up to: ∼ 10×
single-qubit gate coherent-error reduction; ∼ 5× average
coherent-error reduction; ∼ 10× increase in calibration
window to one week of valid pulse calibration; ∼ 12× re-
duction gate-error variability across qubits and over time;
and up to ∼ 9× reduction in single-qubit gate error (in-
cluding crosstalk). The improvements rendered by (Car-
valho et al., 2020) have implications on the performance
of multiqubit gates in trapped ions (Milne et al., 2020).
In light of these recent developments, together with
IBM Qiskit Pulse (Alexander et al., 2020), we envisage
a possibility to realize/encode holonomic quantum gates
(Zanardi and Rasetti, 1999; Zhang et al., 2015) which
are robust against parameter ﬂuctuations and attain even
better gate ﬁdelity and performance.

2020)
Lanczos-inspired approach (Suchsland et al.,
the expectation value of a physical ob-
estimates
servable Tr[ˆρ(0) ˆA]
a
of
constructing
by
basis
spanned by
order-m Krylov subspace K(m)
the
{∣Ψ⟩ , H ∣Ψ⟩ , H 2 ∣Ψ⟩ , ..., H m ∣Ψ⟩}.
A way to look at
this is to systematically construct the objective function
to be minimised. For the order-m, the objective function

is

1. Native and universal gate sets

31

EL,k,n,m = min
a∈Rm

¿
`
`(cid:192) ⟨Ψ∣ H k(∑m−1
k
⟨Ψ∣ (∑m−1

i=0 aiH i)n ∣Ψ⟩
i=0 aiH i)n ∣Ψ⟩

.

(62)

Due to the Krylov expansion, this technique can reduce
the impact of diﬀerent sources of noise with cost of an in-
crease in the number of measurements to be performed,
without additional experimental overhead. Calculating
dynamic quantities such as Hamiltonian moments (Val-
lury et al., 2020) and quantum power method based on
higher-order Suzuki-Trotter expansion (Seki and Yunoki,
2021) on near-term quantum computers are two recent
examples that fall under the same approach here.

employ machine
Learning-based and AI-inspired methods
learning techniques such as regression for error mitiga-
tion. The process consists of training diﬀerent candi-
date circuit variants with non-Cliﬀord gates substituted
with gates with eﬃcient classical simulability (Czarnik
et al., 2020; Strikis et al., 2020). A recent approach
suggests merging zero noise extrapolation with learning-
based methods for near-Cliﬀord circuits (Lowe et al.,
2020). There are also genetic algorithms to mitigate er-
rors in quantum simulations (Las Heras et al., 2016a;
Spagnolo et al., 2017).

B. Circuit compilation

As it will be discussed in Sec. V.C, a quantum com-
puter is composed of its hardware (quantum) and soft-
ware (classical). The software translates a quantum al-
gorithm into a set of instructions that implement the de-
sired quantum operations and read out the qubit states.
This process can be understood as quantum compilation
(Chong et al., 2017), but the term is not limited to this
particular application. When mapping a quantum circuit
to a speciﬁc device architecture, one needs to consider the
available quantum gates, the qubit connectivity that al-
lows two-qubit gates implementation, and experimental
limitations such as decoherence time, which imposes a
certain maximum circuit depth in terms of the number
of gates. For these reasons, it has become indispens-
able to develop tools that allow for circuit simpliﬁcations
and eﬃcient mappings of the general algorithm to spe-
ciﬁc hardware. These tools are also known as quantum
compilers since they translate the theoretical circuit to
the realistic simulator or device. In the following lines,
we describe some of these tools. Many of them are suited
both for NISQ and fault-tolerant quantum computation.

The available gates that can be implemented exper-
imentally on a particular hardware platform are some-
times referred to as the native gate set. With a uni-
versal gate set G ∈ SU (d) (also called instruction gate
set), any unitary operation can be constructed eﬃciently.
More formally, the Solovay-Kitaev theorem (Dawson and
Nielsen, 2006) states that given this universal set G, any
unitary operation U ∈ SU (d) can be approximated with
(cid:15) accuracy with a ﬁnite sequence S of gates from G. This
sequence scales logarithmically as O(logc(1/(cid:15))), where c
is a constant that depends on the theorem proof. For
d = 2n this theorem guarantees that qubit quantum cir-
cuits can be decomposed using a ﬁnite gate sequence.
Although this is one of the most important theorems in
quantum computation, it is an existence theorem, i.e. it
does not provide the decomposition that it predicts. It
also requires that the gate set contains the inverse of all
gates. Further developments presented in (Bouland and
Ozols, 2018) tried to remove this assumption.

The Cliﬀord group is an important object in quan-
tum information science because of its applications in
quantum error correction, randomized benchmarking and
investigations for quantum advantage. The generalized
Pauli operators in prime dimension p are given by

T(a,b)

=

ab

2 Z aX b

⎧⎪⎪
ω−
⎨
⎪⎪⎩
ιabZ aX b

(a, b) ∈ Zp × Zp, p ≠ 2
(a, b) ∈ Z2 × Z2, p = 2

(63)

where ω = exp ( 2πi
) and Zp denotes an integer modulo
p
p. The Z and X operators are deﬁned via their action
on computational basis states {∣k⟩}k
, with X ∣k⟩ = ∣k + 1
mod p⟩, and Z∣k⟩ = ωk∣k⟩. The unitaries which map the
set of generalized Pauli operators to themselves up to a
phase are called Cliﬀord unitaries. Let us denote the set
of p dimensional Cliﬀord unitaries by Cp. Mathematically
speaking,

U ∈ Cp ⇐⇒ ∃φ ∶ U T(a1,b1)U † = exp (iφ) T(a2,b2)

(64)

and T(a2,b2)

where T(a1,b1)
are generalized Pauli opera-
tors. The set of Cliﬀord unitaries Cp forms a group, called
the Cliﬀord group. In this review, we focus on p = 2, i.e.
the qubit Cliﬀord group.

There are inﬁnitely many universal gate sets, but the
Cliﬀord group’s gates H, S and CN OT , together with
the T gate, compose the most commonly used set. The
Cliﬀord group alone can be simulated eﬃciently as stated
by the Gottesman–Knill theorem (Aaronson and Gottes-
man, 2004). The theorem states that no quantum advan-
tage can be found without the use of the T gate. For this
reason, many algorithms try to simplify and reduce quan-
tum circuits to the minimal number of T gates, giving
an estimation of the classical eﬃciency of that particular
circuit (Amy et al., 2013; Amy and Mosca, 2019; Gosset

et al., 2013; Heyfron and Campbell, 2018; Kissinger and
van de Wetering, 2019).

Besides these minimal reduction algorithms, other ba-
sic decompositions are useful. Even if only a native gate
set is available experimentally, other basic gates can be
constructed and used in algorithms. As an example, S
and T gates are particular cases of the single-qubit ro-
tational gate Rz, and the H gate can be obtained from
Ry and Rx gates as H = Ry(−π/2)Rx(π). Any single-
qubit gate can be decomposed into the gate sequence
U (θ, φ, λ) = Rz(φ)Ry(θ)Rz(λ). This motivates using
single-qubit rotational gates and at least one entangling
gate (e.g. CN OT or CZ gate) as native gate sets. Any
two-qubit gate can be obtained from this minimal set
by using circuit decompositions (Barenco et al., 1995;
Blaauboer and De Visser, 2008; de Guise et al., 2018;
Peterson et al., 2020; Watts et al., 2013). The particu-
lar choice of the entangling gate can be motivated from
the experimental platform. Depending on the technology
used to construct the quantum device, a natural 2-qubit
gate implementation can be more suited. Some exam-
ples are the use of CZ gates in tunable superconduct-
ing circuits (Krantz et al., 2019), cross-resonance gates
in ﬁxed frequency superconducting qubits (Kjaergaard
et al., 2020; Krantz et al., 2019), or the XX gates in
trapped ions (Häﬀner et al., 2008). More expressive gate
sets with continuous gate parameters or long-range inter-
actions can be achieved by further control over the hard-
ware parameters in time (Bastidas et al., 2020; Foxen
et al., 2020; Krinner et al., 2020; Lacroix et al., 2020).
The complexity of the circuit decomposition into CNOT
and Rz gates is analyzed in (Amy et al., 2018).

2. Circuit decompositions

Once the native gate set is ﬁxed, the next step con-
sists of decomposing the theoretical unitary circuit into
this basic set. A raw translation of all single and two-
qubit gates into the native set might imply a large cir-
cuit depth, reducing the eﬀectiveness of that decomposi-
tion. Moreover, ﬁnding the decomposition of gates acting
on more than one qubit might prove challenging in gen-
eral. Besides common circuit decompositions mentioned
before, one may need mathematical tools to understand
and derive general circuit reductions to particular smaller
pieces.

One of these mathematical tools is the so-called ZX-
Calculus. It is a graphical language that maps quantum
circuits to particular graph representations and derives a
set of rules to manipulate these graphs. Its application
range goes from measurement-based quantum computa-
tion to quantum error correction. For a complete review
about ZX-calculus and its variety of applications, see Ref.
(van de Wetering, 2020). For the purpose of this review,
we are interested in the quantum circuit simpliﬁcation

32

applications (de Beaudrap et al., 2019; Cowtan et al.,
2019b; Duncan et al., 2020; Hanks et al., 2020; Kissinger
and van de Wetering, 2020b).

Other approaches use well-known artiﬁcial intelligence
algorithms to ﬁnd optimal circuit decompositions, for in-
stance, the use of reinforcement learning (Pirhooshyaran
and Terlaky, 2020; Zhang et al., 2020c). Evolutionary
algorithms such as genetic algorithms have been widely
studied (Bang and Yoo, 2014; Lamata et al., 2018a;
Las Heras et al., 2016b; Li et al., 2017b; Massey et al.,
2004; Massey et al., 2006; Potoček et al., 2018; Spag-
nolo et al., 2017; Williams and Gray, 1999).
In these
approaches, multiple random circuits composed by the
native gate set are generated and evolved later on. The
evolution strategy includes the deﬁnition of possible mu-
tations such as introducing a new gate on a particular
qubit, the swap between circuit gates or the deletion of
a particular gate. Then, a multi-objective loss function
is used to estimate the success of each circuit family un-
til a given convergence criterion, after which the circuit
with the best performance is selected. These works have
to be added to those focusing ﬁnding the optimal PQC
for a given VQA, as discussed in Sec. II.B. A VQA for
circuit compilation using a genetic algorithm as optimiza-
tion subroutine is presented in Ref. (Khatri et al., 2019),
called Quantum Assisted Quantum Compiler.

3. The qubit mapping problem

After decomposing and simplifying the quantum cir-
cuit into the native gates, a hardware-speciﬁc task re-
mains: mapping the resultant circuit to the particular
qubit connectivity or topology, a task also known as the
qubit routing problem.
In general, due to experimental
limitations, not all qubits are connected, which means
that two-qubit operations are not always possible. A
naive approach to circumvent this limitation consist of
swapping each qubit state with its neighbour (by using
SW AP gates) until we ﬁnd a connected pair, perform the
desired two-qubit operation and swap back the states of
the qubits involved, returning to the original state with
the intended two-qubit gate applied to it. This translates
into a signiﬁcant growth of the circuit depth for circuit
topologies with a sparse qubit connection graph.

Some NISQ algorithms presented in this review may
include the qubits’ connectivity by means of the loss
function or the available rules used to decompose the
unitaries. However, quantum compilation is a hardware-
speciﬁc transformation; it might be more useful to ap-
ply this step independently of the quantum circuit and
depending on the chip architecture. Unfortunately, the
qubit mapping problem is NP-complete (Botea et al.,
2018). Several heuristic approaches based on dynamic
programming and depth partitioning have been explored
(Cowtan et al., 2019a; Li et al., 2019; Siraichi et al.,

2018; Zulehner et al., 2017, 2018; Zulehner and Wille,
2019) as well as using reinforcement learning (Pozzi et al.,
2020). Exact methodologies based on reasoning engines
such as Boolean satisﬁability solvers have also been pro-
posed (Tan and Cong, 2020; Wille et al., 2019). The
so-called LHZ architecture is an approach that solves the
connectivity issue at the cost of increasing the number
of qubits (Lechner, 2020). The same framework can be
applied to a quantum annealing system as well (Lechner
et al., 2015). Encoding this problem into a QUBO (see
Sec. III.A) to solve it using classical simulated anneal-
ing has also been proposed in Ref. (Dury and Di Mat-
teo, 2020). Approaches for circuit compilation based on
commutation algebra of quantum gates have been been
suggested in (Itoko et al., 2020, 2019).

There can be many possible qubit mappings of a given
algorithm into a particular device if not all qubits are
required. In those cases, one can put some extra eﬀort
to ﬁnd the best performing qubits in terms of error rates
and coherence times (Nishio et al., 2020; Niu et al., 2020).
In that direction, ﬁnding the mapping with the lowest
circuit depth may prove valuable to reduce the errors
due to decoherence (Zhang et al., 2020a).

Finally, the use of circuit synthesis with connectivity
constraints have also been proposed. Some of these works
are based on Gaussian elimination processes where you
take the matrix representation of the circuit transforma-
tion and manipulate it to extract the basic transforma-
tions (in particular, the CNOT gates that respect the
connectivity) (Kissinger and de Griend, 2019; Nash et al.,
2020).
In (Gheorghiu et al., 2020), the strategy con-
sist on slicing the circuit into smaller parts that can be
adapted and transformed to ﬁt into the particular topol-
ogy. One can also adapt this problem to the syndrome
decoding problem (de Brugière et al., 2020). Reference
(de Griend and Duncan, 2020) solves the qubit routing
for phase polynomial circuits, i.e. circuits that only con-
tain CNOTs and Rz gates.

4. Resource-aware circuit design

As described in Sec. II.B, there are diﬀerent strategies
to design a circuit ansatz. Unfortunately, many of them
require circuit depths, qubit connectivity and a number
of parameters beyond the capabilities of current quantum
hardware. In the following paragraphs, we discuss strate-
gies to design and adapt PQC and VQA to the devices
characteristics.

ADAPT-VQE. Early VQA employed a ﬁxed ansatz
tuned using a classi-
design with its parameters
cal optimizer.
The Adaptive Derivative-Assembled
Pseudo-Trotter ansatz Variational Quantum Eigensolver
(ADAPT-VQE) was introduced as a more scalable and

33

eﬃcient way to simultaneously design and optimize a pa-
rameterized ansatz (Grimsley et al., 2019b). At each it-
eration, ADAPT-VQE constructs an ansatz by adding
an operator corresponding to the largest gradient from a
carefully designed operator pool. That is, given an oper-
ator ˆτi from the operator pool, the gradient of the energy
with respect to the corresponding parameter θi is deﬁned
as

∂iE = ⟨ψ∣ [H, ˆτi] ∣ψ⟩ ,

(65)

where ∣ψ⟩ is the ansatz at the current iteration to be
updated. After computing the gradient components and
choosing the operator corresponding to the largest gra-
dient, the gate operation implementing ˆτi is added to
the ansatz with its parameter value initialized at 0. The
ansatz is then optimized before adding the next operator.
The ADAPT-VQE algorithm terminates when the norm
of the gradient vector falls below a predeﬁned threshold.
In the case of fermionic ADAPT-VQE, the operator
pool consists of fermionic operators that are transformed
into quantum gate operations through, e.g., the Jordan-
Wigner mapping. A more hardware-eﬃcient variant of
the ADAPT-VQE algorithm is the qubit ADAPT-VQE,
in which the pool consists of gate operators acting di-
rectly on qubits (Tang et al., 2019). Both versions of
ADAPT-VQEs were able to to generate optimized cir-
cuits with reduced depths and CNOT counts compared
to previous ansatz construction and optimization meth-
ods.

information-assisted
MI-ADAPT-VQE. The mutual
by
introduced
ADAPT-VQE (MI-ADAPT-VQE),
(Zhang et al., 2021c),
leverages the density matrix
renormalization group (DMRG) (Hallberg, 2006; White,
1992) method to accelerate the circuit constructions for
the ADAPT-VQE routine. Instead of gradients, it uses
the mutual information to guide circuit constructions.
At the beginning of the algorithm, the pair-wise quan-
tum mutual information is approximated using DMRG,
which is then applied to construct a reduced pool of
entangling gates.
In each iteration of the method,
new circuits are generated in which quantum gates are
mainly distributed among pairs of qubits corresponding
to large mutual
information. This avoids allocating
quantum resources on pairs of qubits that are less
important to entangle. Numerical experiments suggest
that the number of new circuits needed in each step of
the adaptive construction can be signiﬁcantly reduced
using MI-ADAPT-VQE, saving both time and quantum
resources. The number of trial circuits in certain cases
can be reduced to about 5% for H2 and 10% for H2O
as compared to ADAPT-VQE, using an operation pool
based on the qubit coupled-cluster method (Ryabinkin
et al., 2020).

MoG-VQE. To reduce two-qubit gate counts for near-
term experiments, the multiobjective genetic variational
quantum eigensolver (MoG-VQE) optimizes for both the
energy and the number of CNOTs in the quantum cir-
cuit (Chivilikhin et al., 2020). The MoG-VQE algorithm
combines two evolutionary strategies: i) NSGA-II (Deb
et al., 2000), a multiobjective genetic algorithm, to pro-
pose a circuit structure to minimize both the energy and
CNOT count, and ii) CMA-ES (Hansen et al., 2003) to
tune parameters and evaluate optimized energies for the
qubit topologies suggested by the NSGA-II algorithm.
MoG-VQE initializes a diverse population by sampling a
checkerboard pattern of two-qubit circuit blocks. To vary
the populations over diﬀerent generations, the three pos-
sible mutation operators are: i) inserting a two-qubit cir-
cuit block in a random position; ii) removing a two-qubit
circuit block in a random position; and iii) adding or re-
moving 10 circuit blocks to help escape from local min-
ima. The authors note that iii) is selected with a lower
probability than mutation operators i) and ii). Parents
are selected using the tournament selection method. For
each circuit topology, the corresponding energy is eval-
uated using the CMA-ES optimizer. These steps re-
peat until some termination criteria are satisﬁed. Us-
ing MoG-VQE, the authors reported signiﬁcant reduc-
tions in the CNOT counts compared to those of other
hardware-eﬃcient circuits when estimating ground state
energies of several molecules. For example, for a 12-qubit
LiH Hamiltonian, MoG-VQE generated a circuit corre-
sponding to estimating the ground state energy to within
chemical precision using only 12 (non-nearest-neighbor)
CNOTs.

PECT. An alternative approach for adaptively con-
structing and optimizing an ansatz was introduced by the
Parameter-eﬃcient circuit training (PECT) scheme (Sim
et al., 2020). PECT enables optimizations of predeﬁned
ansätze, such as unitary coupled-cluster or the low-depth
circuit ansatz (LDCA) (Dallaire-Demers et al., 2019),
by dynamically pruning and adding back parameterized
gates during an optimization. After selecting an ansatz
U , a subset of gate operations from A is chosen while
other parameterized gate operations are tuned to iden-
tity operations. This results in an ansatz substructure
A′ with reduced circuit depth and gate count. Parame-
ters of A′ are then optimized, following what the authors
call a “local optimization” step. After local optimization,
to reﬁne or reparameterize the ansatz substructure, pa-
rameters with small magnitudes are pruned or removed.
A heuristic growth rule is used to grow back the same
number of parameters that was pruned. Steps of local
optimization and ansatz reparameterization are repeated
until termination criteria are met. Because PECT opti-
mizes parameter subsets at any iteration, circuits that are
executed on the quantum computer have reduced depths

34

and CNOT counts compared to the original ansatz. Us-
ing PECT, the authors were able to optimize 12-qubit
LDCA circuits, naively equipped with hundreds to low
thousands of parameters, to estimate ground state ener-
gies of LiH and H2O. Previous optimizations of LDCA
were limited to 8 qubits.

C. Quantum software tools

A quantum computer is a hybrid device composed of
quantum hardware and classical software that controls
it by sending a list of instructions and processing the
results of the computation. This hybrid nature is ac-
centuated in the NISQ era, as explained in the current
review. Thus, the classical subroutines are part of the
core in state-of-the-art NISQ algorithms and a language
to communicate with the quantum device is a bare ne-
cessity. On top of that, almost all progress in quantum
algorithms is tested in quantum simulators making them
essential to perform proof-of-concept simulations, before
or until the algorithm is applicable on real devices.

Figure 6 represents diagrammatically the typical work-
ﬂow of a NISQ algorithm. The individual parts of the
problem, such as the objective function to optimize, the
quantum circuit design or the initialization parameters,
are translated into quantum circuits by a classical pre-
computation step. The syntax of this language includes
the quantum gates, qubit initialization, objective func-
tion deﬁnition, etc. The theoretical circuit is then com-
piled to fulﬁll experimental limitations such as qubit con-
nectivity, native quantum gate set or circuit depth. To
accomplish this task, compilers that allow for circuit sim-
pliﬁcation (see Sec. V.B), or noise models (for simulation
purposes) might be useful. After this pre-processing step,
the algorithm is ready to enter into the quantum-classical
loop. The quantum circuit can be run in a quantum sim-
ulator or real hardware. In the latter case, an assembly
language (Cross et al., 2017; Khammassi et al., 2018; Kil-
loran et al., 2019; Smith et al., 2016) will translate the
quantum circuit into a set of instructions for the device.
After the qubits are measured, the result can be post-
processed and techniques such as error mitigation might
be used. Either the algorithm ﬁnishes or the result is
sent to the classical optimizer that computes the next
loop variables (e.g. for VQA).

We deﬁne a quantum software library as a library or
a set of libraries written in a classical programming lan-
guage (e.g. python or C++) that allows writing a quan-
tum program.
In some cases, these libraries are open-
source and can be used directly on real hardware or on
a quantum simulator. The proliferation of all these li-
braries, simulators and devices has also created a neces-
sity for some multi-platform languages. These are those
that can use multiple quantum software libraries as a
backend, reducing the programming eﬀorts substantially

35

Figure 6 Schematic representation of a standard NISQ programming workﬂow (color online). Green circular boxes represent
the libraries and languages used for designing, optimizing and running a quantum algorithm in a real quantum device or in a
simulator. External libraries can be used to deﬁne the problem or to improve the performance of the algorithm by simplifying
the circuit or using error-mitigation techniques. An assembly language will be needed to translate the theoretical algorithm to
a set of physical operations on the quantum hardware. Classical post-processing is necessary to manipulate the result of the
computation and to either obtain the ﬁnal result or send the provisional one to a classical optimizer (VQA).

by unifying the language syntax. Some of these packages
include built-in sub-libraries suited for particular applica-
tions, from chemistry to QML, or particular well-known
algorithms such as VQE or QAOA.

We provide a list of some open-source libraries suited
for NISQ computation in Tab. VII from App. A. This list
represents just a snapshot of the state-of-the-art of the
quantum software ecosystem as new tools are being de-
veloped and some projects are being abandoned. An up-
dated list of quantum software resources can be found in
Ref. (QOSF, 2020; Quantum Computing Reports, 2020)
and a detailed comparison analysis between some of these
languages and libraries in Ref.
(Garhwal et al., 2019;
Gay, 2006; Heim et al., 2020; Nguyen et al., 2020). Due
to the broad applications of NISQ algorithms, speciﬁc
libraries used in other ﬁelds beyond quantum computa-
tion can also be required, e.g. quantum chemistry and
machine learning libraries or external compilers and sim-
ulators. These libraries are used for other applications
besides purely quantum computation, so we consider and
list them as external libraries in Tab. VIII from App. A,
although most of them integrated in the quantum soft-
ware libraries.

VI. APPLICATIONS

A. Many-body physics and chemistry

Understanding the static and dynamic properties of
quantum mechanical systems is a core challenge at the

heart of many ﬁelds such as chemistry and physics. Clas-
sical numerical methods often struggle in solving these
problems, due to the exponential increase of resources
needed with growing number of particles to simulate.
Owing to their quantum mechanical nature, quantum
computers oﬀer a way to simulate even large-scale many-
body systems (von Burg et al., 2020; Feynman, 1982).
The initial application for chemistry was to obtain molec-
ular energies via quantum phase estimation on a quan-
tum computer (Aspuru-Guzik et al., 2005). Besides the
molecular energy, properties that can be extracted from a
successfully prepared ground state, such as energy deriva-
tives with respect to the nuclear framework, are of sim-
ilar interest
(Kassal and Aspuru-Guzik, 2009; O’Brien
et al., 2019). Fault tolerant quantum algorithms have
the potential to become killer applications in the compu-
tational discovery of chemical reaction mechanisms (Rei-
her et al., 2017) and NISQ algorithms could play a major
role in their realization. Here we review various NISQ
algorithms that have been proposed to tackle quantum
chemistry and many-body physics related problems. We
start by introducing concepts on mapping physical prob-
lems onto the quantum computer. Then, we introduce
algorithms for common challenges, such as ﬁnding the
static as well as dynamic properties of quantum systems
in various settings. All NISQ algorithms discussed in this
section are listed in Table I.

Libraries forchemistry, ML, etc.Problem definition:cost function, circuitansatz, initializationQuantumlanguageQuantumcircuitQuantumcompilerQuantumsimulatorSettings for compiler,error mitigation, noise modelAssemblylanguageQuantumdeviceOptimizerQuantuminstructionsClassicalpostprocessingOptimizationlibrariesResult1. Qubit encodings

In general, any physical system can be written in terms
of a Hamiltonian which is the sum of its kinetic and po-
tential energy. In quantum theory, each physical system
is associated with a language of operators and an alge-
bra establishing such language. Depending on the system
constituents, there are three types of particles (opera-
tors) in Nature: fermions, bosons and anyons. The ﬁrst
two are elementary particles obeying Fermi-Dirac (FD)
and Bose-Einstein (BE) statistics, respectively. The lat-
ter being quasiparticles obeying continuous or anyonic
statistics, and existing only in two-dimensional conﬁne-
ment. Quantum computers (QC) operate in a language
of qubits (a distinguishable set of spin-1/2 particles).
Hence, the quantum simulation of a physical system
refers to performing a one-to-one mapping from the sys-
tem operator to the QC language, preserving the underly-
ing statistics. For a recent review on hardware-dependent
mappings of spin Hamiltonians into their corresponding
quantum circuit, refer to (Tacchino et al., 2020b).

In the standard model of quantum computation, a two-
level system or spin-1/2 particle is denoted by its spin
orientation ∣↑⟩ = ∣0⟩ = (1, 0)T and ∣↓⟩ = ∣1⟩ = (0, 1)T .
An N -qubit system is then constructed from the stan-
dard Pauli matrices ˆσi
, where the superscript i
y, ˆσi
z
refers to the ith local qubit site. These operators sat-
isfy the commutation relations of an ⊕N
i=1 su(2)i algebra
, where (cid:15)µνλ is the totally anti-
[ˆσl
symmetric Levi-Civita symbol with µ, ν, λ ∈ {x, y, z}.

ν ] = 2iδlm(cid:15)µνλ ˆσl
λ

µ, ˆσm

x, ˆσi

Hence,

In the second quantized notation, N
Fermions.
fermions are denoted by fermionic operators ˆf †
i ( ˆfi), the
creation (annihilation) operators of a fermion in the
ith mode/site (i = 1, ⋯, N ). The fermionic operators
obey Pauli’s exclusion principle and the anti-symmetric
nature of the fermion wave function.
the
fermionic algebra is deﬁned by the anti-commutators
i , ˆfj} = δij. There are a number of
{ ˆfi, ˆfj} = 0, { ˆf †
well-known mappings that allow the description of a
fermionic system by the standard model of QC. They are
the Jordan-Wigner transformation (Jordan and Wigner,
1928), Bravyi-Kitaev transformation (Bravyi and Ki-
taev, 2002) and Ball-Verstraete-Cirac transformation
(Ball, 2005; Verstraete and Cirac, 2005). In (Steudtner
and Wehner, 2019), the two-dimensional topology of
most proposed qubit architectures is taken explicitly into
account and compared to some of the aforementioned
one-dimensional mappings. More advanced mappings,
using the interaction graph of the Hamiltonian (Setia
et al., 2019; Setia and Whitﬁeld, 2018) or customized
quasi-local and local encodings (Chien and Whitﬁeld,
2020; Derby and Klassen, 2020; Jiang et al., 2020;
Havlíček et al., 2017) have been introduced as well.
Other approaches try to lower the qubit requirements of

36

the mapped fermionic operators by taking inspiration
from classical error correction codes and the internal
symmetries of the system (Bravyi et al., 2017; Steudtner
and Wehner, 2018), other examples are mappings based
on point-group symmetries of molecular Hamiltoni-
ans (Setia et al., 2020). Recently, mappings of SU(N )
fermions to qubits have been proposed (Consiglio et al.,
2021).

In the following, we will brieﬂy outline the oldest and
the Jordan-Wigner transfor-
most intuitive mapping:
mation.
In this mapping, the qubit states are equiv-
alent to the second-quantized occupation number vec-
tors, and fermionic creation and annihilation operators
are transformed to qubit raising and lowering operators
ˆσj
y)/2 combined with strings of ˆσz operators
±
that ensure the correct anti-commutation properties:

x ± iˆσj

= (ˆσj

ˆfj → (

j−1
∏
l=1

−ˆσl

z) ˆσj
−,

f †
j → (

j−1
∏
l=1

−ˆσl

z) ˆσj
+.

(66)

j , ˆfj sat-
In this new transformation, one can verify that ˆf †
isfy the above anticommutation relations, while ˆσj
satisfy
µ
the commutation relations showed above. The reader is
referred to the literature (Aspuru-Guzik et al., 2005; See-
ley et al., 2012; Somma et al., 2003; Tranter et al., 2018,
2015) and the respective original references for details
and comparisons regarding the other transformations.

ˆ˜bj] = 0, [ˆ˜bi,

Bosons. Bosonic operators satisfy the commutation re-
lations [ˆ˜bi,
ˆ˜b†
j] = δij in an inﬁnite-dimensional
Hilbert space. At ﬁrst, it seems it is impossible to simu-
late bosonic systems due to the nature of inﬁnite dimen-
sions. However, sometimes we are interested in studying
some ﬁnite modes of excitations above the ground state.
Hence, the use of the entire inﬁnite dimensional Hilbert
space is unnecessary. In a ﬁnite dimensional basis, the
bosons ˆb†
i , ˆbi obey the following commutation relations
(Batista and Ortiz, 2004)

[ˆbi, ˆbj] = 0, [ˆbi, ˆb†

j] = δij [1 −

Nb + 1
Nb!

(ˆb†

i )Nb (ˆbi)Nb ] , (67)

with ˆb†
ˆbi ∣ni⟩ = ni ∣ni⟩ with ni = 0, ⋯, Nb, where Nb is
i
the maximum truncated excitation number, correspond-
ing to the ith bosonic site/mode. A direct consequence
is one can then write down the creation and annihilation
operators as

ˆb†
i =

√

Nb−1
∑
n=0

n + 1∣n + 1⟩⟨n∣,

(68)

and ˆbi is complex conjugate of ˆb†
. There are inﬁnite
i
means to translate such truncated operators into the
QC language, the so-called Pauli words. A Commonly

used one is known as standard binary or compact en-
coding (McArdle et al., 2019b; Sawaya and Huh, 2019;
Sawaya et al., 2020; Somma et al., 2003; Veis et al., 2016),
where {α, β ∈ W} in ∣α⟩⟨β∣ are now written in terms of
binary strings. Using the following identities:
∣0⟩⟨1∣ ≡
ˆσ−; ∣1⟩⟨0∣ ≡ ˆσ+; ∣0⟩⟨0∣ ≡ (I + ˆσz)/2; ∣1⟩⟨1∣ ≡ (I − ˆσz)/2, Pauli
words translation can be accomplished. Recently, de-
tailed studies on various encodings (binary, Gray, Unary,
block Unary), have been studied and Gray code in par-
ticular is found to be resource eﬃcient (in terms of num-
ber of qubits and two-qubit entangling gates) in simulat-
ing some speciﬁc bosonic and spin Hamiltonians (Sawaya
et al., 2020).

As seen above, we can now proceed to simu-
Anyons.
late more general particle statistics, in particular, hard-
core anyons. With “hard-core”, we refer to the Pauli’s
exclusion principle where only zero or one particle can
occupy a single mode. The anyonic operators ˆai, ˆa†
i
obey the commutation relations [ˆai, ˆaj]θ = [ˆa†
j]θ = 0,
[ˆai, ˆa†
j]−θ = δij(1 − (e−iθ+1)ˆnj) and [ˆni, ˆa†
, where
j ˆaj, [ ˆA, ˆB]θ = ˆA ˆB − eiθ ˆB ˆA, with (i ≤ j) and
ˆnj = ˆa†
0 ≤ θ < 2π. Speciﬁcally, θ = π mod(2π) gives rise to
canonical fermions, and θ = 0 mod(2π) would recover
hard-core bosons. By simply applying the following iso-
morphic mapping between algebras (Somma et al., 2003):

i , ˆa†
j] = δij ˆa†

j

ˆa†
j = ∏
i<j

(

(

ˆaj = ∏
i<j

e−iθ + 1
2

+

e−iθ − 1
2

z) ˆσj
ˆσi
+,

eiθ + 1
2

+

eiθ − 1
2

z) ˆσj
ˆσi
−,

ˆnj =

1 + ˆσj
z
2

, (69)

we would obtain Pauli words for the QC. The above map-
ping would also ensure the anyonic algebra shown above.

2. Constructing electronic Hamiltonians

The electronic structure problem is one of the most
prominent task within VQA (see for example the reviews
(Cao et al., 2019; McArdle et al., 2020)) and was the
pioneering task for the variational quantum eigensolver
(McClean et al., 2016; Peruzzo et al., 2014). In this sec-
tion, we will illustrate how the original continuous many-
electron problem can be discretized to a second-quantized
formulation that can itself be encoded into qubits by the
techniques introduced in the beginning of Sec. VI.A. This
encoded qubit systems deﬁne then the central problem of
the VQAs further described in Sec. VI.A.3.

The electronic structure problem aims to approximate

eigenfunctions of an electronic Hamiltonians

He = Te + Vee + Vext,
describing a system of Ne electrons through their accu-
, the electronic
mulated kinetic energies Te = − 1

2 ∑Ne

k=1 ∆rk

(70)

37

Coulomb repulsion Vee = ∑k≠l Vee (rk − rl) = ∑k≠l
,
1
∣rk−rl∣
and an external potential Vext = ∑Ne
k=1 Vext (rk) that is
usually given by the accumulated Coulomb potential of
nuclear point charges. If the external potential is not ex-
plicitly spin dependent, the electronic Hamiltonian only
acts on the spatial coordinates rk ∈ R3 of the elec-
trons and, to ensure proper electronic wave functions, the
fermionic anti-symmetry is achieved via restrictions in
the Hilbert-space. We refer to (Herbst, 2018; Kottmann,
2018; Rohwedder, 2010) and the textbook (Yserentant,
2010) for the direct construction and discretization of
this continous Hilbert spaces.

A more compact, but formally equivalent, deﬁnition is
oﬀered through second quantization by introducing the
abstract anti-commuting ﬁeld operators ˆψ† (x) and ˆψ (x)
that create and annihilate electrons at spin-coordinate
} (Jordan and Klein, 1927; Jørgensen, 2012;
xk ∈ R3 × {± 1
2
Surján, 2012). The electronic Hamiltonian can then be
written as

He = ∫ d x ˆψ† (x) (T (x) + Vext (x)) ˆψ (x)

(71)

+ ∫ d x d y ˆψ† (x) ˆψ† (y) Vee (x − y) ˆψ (y) ˆψ (x)

where the potential operators still only act on the spa-
tial part of the spin components. Although direct ap-
proaches on real-space grids are possible (Kivlichan et al.,
2017; Kottmann, 2018; Kottmann and Bischoﬀ, 2017; Ku-
nitsa and Hirata, 2020) the majority of VQA employs
a ﬁxed set of three dimensional functions (so-called or-
bitals) to capture the spatial part of the electronic Hilbert
space. The orbitals are usually determined by solving a
mean-ﬁeld problem (Hartree–Fock) within a set of glob-
ally deﬁned atomic orbitals. Alternatives to the stan-
dard representation are, for example, direct determina-
tion of system adapted orbitals (Kottmann et al., 2021c),
compactiﬁcation of basis sets through intrinsic atomic or-
bitals (Barison et al., 2020) and optimized virtual orbitals
represented by plane-waves (Bylaska et al., 2020).

For the formal description of the discretized second-
quantized electronic Hamiltonian, the origin of the or-
bitals is not important as long as they form an orthonor-
mal set of H 1 (R3) functions. Using such a set of spatial
orbitals we can formally expand the ﬁeld operators in the
corresponding spin-orbitals

ˆψ† (x) = ∑
k

k (x) f †
φ∗
k,

ˆψ (x) = ∑
k

φk (x) fk,

(72)

where f †
and fk are fermionic creation and annihila-
k
tion operators obeying the anticommutation relations
shown in the previous subsection. Using the expansion
from Eq. (71) leads to the common discretized second-
quantized Hamiltonian,

He = ∑
kl

hklf †

kfl + ∑
klmn

gklmnf †

kf †

l fnfm,

(73)

with the molecular integrals (Fermann and Valeev, 2020)

hkl = ∫ φ∗

k (x) (T (x) + Vext (x)) φl (x) d x,

(74)

gklmn ∫ φ∗

k (x) φ∗

l (y) Vee (x − y) φ∗

m (x) φ∗

n (y) d x d y.

Note that the indices of the two body integrals are de-
noted in the standard Dirac notation gklmn ≡ ⟨kl∣ Vee ∣mn⟩
but other notations,
such as Mulliken (km∣lm) =
⟨kl∣ Vee ∣mn⟩ are sometimes used. Generally speaking,
an arbitrary set of spatial orbitals, that can in principle
be any set of orthonormal H 1 (R3) functions, deﬁnes a
discretized second-quantized Hamiltonian as in Eq. (73)
over the corresponding molecular integrals Eq. (74). This
discretized Hamiltonian can then be encoded into a qubit
Hamiltonian by corresponding fermion to qubit mappings
discussed in Sec. VI.A.

3. Variational quantum eigensolver

Estimating the ground state and its energy of Hamil-
tonians is an important problem in physics, which has
numerous applications ranging from solid-state physics
to combinatorial optimization (see Sec. VI.C). While this
problem is in general QMA-hard and even quantum com-
puters are not expected to be able to eﬃciently solve it in
general (Kempe et al., 2006), there is hope that approxi-
mate solutions of the ground state could be found faster
and for larger system sizes compared to what is possible
with classical computers.

To this end, VQE (McClean et al., 2016; Peruzzo et al.,
2014) has been proposed, to ﬁnd the ground state of a
Hamiltonian H in a manner that is suited for NISQ de-
vices (Wecker et al., 2015). Following the concept intro-
duced in Sec. II.A and Sec. II.B, a parameterized circuit
U (θ) is minimized with respect to the objective function,
which in general is the expectation value of the energy of
the Hamiltonian from Eq. (1).

The approximated ground state is given by the quan-
tum state ∣ψmin⟩ = U (θmin) ∣0⟩ which minimizes the en-
ergy minθ⟨Hθ⟩ ≥ Eg upper bounded by the true ground
state energy Eg as guaranteed by the Rayleigh-Ritz vari-
ational principle (Gould, 2012). VQE has been inten-
sively studied in both theory and experiments, and vari-
ous adaptions and extensions have been proposed, which
we discuss in the following paragraphs.

38

Accelerated VQE. A key computational eﬀort in VQE
lies in estimating the cost function, which is achieved by
repeatedly running the circuit and taking measurements
of the Pauli strings (see Sec. II.C). For a given desired
additive error bounded by (cid:15), it takes O(1/(cid:15)2) number of
samples. This can be improved by using the Quantum
Phase estimation algorithm to estimate the expectation
value, which takes only O(log(1/(cid:15))) samples, however at
the cost of additional computation which may be hard in
the NISQ era. To leverage a trade-oﬀ between the ad-
vantages and disadvantages of both methods, an acceler-
ated versions of VQE that interpolates between regular
measurements and quantum phase estimation has been
proposed (Wang et al., 2019).

In (Ferguson et al., 2020), the
Measurement-based VQE.
authors present two strategies to implement the VQE al-
gorithm on a measurement-based quantum computer, an
alternative quantum computing paradigm that uses en-
tanglement as a resource and achieves the the desired
computation by performing particular sets of local mea-
surements (see (Briegel et al., 2009) for a review). They
propose a way to generate the needed variational state
families using measurements on a highly entangled state
and provide an equivalence between the measurement-
and gate-based schemes.

Reusing qubits in VQE. A recent proposal suggested a
VQE method that relies on fewer qubits by re-using some
of them (Liu et al., 2019). The core idea is to represent
a virtual N qubit state by R + V < N physical qubits,
where R qubits have to be reusable qubits, e.g. they can
be measured and re-initialized during the circuit runtime.
These intermittent measurements are possible on current
ion trap hardware (Pino et al., 2020). The R + V qubits
are entangled by a PQC, then R qubits are measured and
the outcome is recorded. The R qubits are re-initialized
to the ∣0⟩⊗R state, and again entangled with the V other
qubits by another PQC. This procedure is repeated un-
til in total N qubits have been measured. The concept
and expressiveness of this type of ansatz is the same as
Tensor networks methods such as MPS, which have been
highly useful for the classical calculation of many-body
problems, and open up a way to perform quantum com-
puting of many qubits on devices with limited number of
qubits.

Self-veriﬁcation. Whether the variational quantum sim-
ulator has converged to an actual eigenstate of the Hamil-
tonian, can be checked directly on the quantum proces-
sor by verifying that the variance of the energy var =
⟨(H − ⟨H⟩)2⟩ is zero. This has been demonstrated for
solving a many-body Hamiltonian on 8 qubits on a ion-
trap (Kokail et al., 2019) (see also Sec. VI.E.6).

Adiabatically assisted VQE. The ground state of more
challenging Hamiltonians can be diﬃcult to ﬁnd for stan-
dard VQE due to convergence to local minima instead of
the global minima of the energy. To alleviate this, quan-
tum annealing (see Sec. III.A) can be used to adiabat-
ically assist the optimisation procedure, as proposed in

the adiabatically assisted VQE (Garcia-Saez and Latorre,
2018). This approach uses an objective function O(s) =
⟨0∣ U †(θ)H(s)U (θ) ∣0⟩, where H(s) = (1 − s)H0 + sH1.
Here, H0 is a Hamiltonian with easily preparable ground-
state and the goal is to ﬁnd the ground state of a Hamil-
tonian H1. In this algorithm, VQE is run for multiple
discrete steps sn. One starts with s0 = 0 and ﬁnds the
minimal parameters θ∗
of the objective function O(s0).
0
Then, θ∗
is used as initial guess for VQE for the next in-
0
creasing step s1 = s0 + ∆s with objective function O(s1).
This procedure is repeated until s = 1 is reached. This ap-
proach eases the optimization task, as the initial Hamilto-
nian H0 is a simple Hamiltonian with a ground state that
can be easily found via optimization. For small steps ∆s,
the ground state of the Hamiltonian H(s) and H(s+∆s)
will not diﬀer too much, making the optimization task at
every step less challenging compared to directly solving
for H(1). Previous works (McClean et al., 2016) also sug-
gest to use adiabatically prepared states as initial states
of a VQE algorithm (see Sec. II.B).

4. Variational quantum eigensolver for excited states

The methods of VQE have been extended to obtain the
excited states of a given Hamiltonian. Finding excited
states or the spectrum of a Hamiltonian is an important
problem in quantum chemistry and many-body physics.
Various proposals have been put forward.

Folded spectrum method. A straightforward way of cal-
culating excited states is the folded spectrum method
proposed by (Peruzzo et al., 2014). To ﬁnd an excited
state of a Hamiltonian H with approximate energy λ,
the above deﬁned VQE method is here applied to the
objective function C(θ) = ⟨(H − λ)2⟩U(θ)
. VQE will tar-
get the eigenstate with an energy that is closest to λ.
This method requires an approximate knowledge of the
energy of the excited state that one wants to ﬁnd, as well
as estimating ⟨H 2⟩, which may require a excessively large
number of measurements to be performed.

An extension of this method can also be used to ﬁnd
states that are constrained to a speciﬁc value of the
conserved quantity of the problem, such as total parti-
cle number or magnetization (Ryabinkin et al., 2018a).
Here, one deﬁnes the objective function C(θ) = ⟨H⟩
+
−si)2, where Si is the operator correspond-
∑i µi(⟨Si⟩
ing to the conserved quantity, and si is the target value
of that quantity. Note, that this does not restrict the
target space to be an eigenstate of Si.

U (θ)

U (θ)

Excited states can be
Orthogonally constrained VQE.
found by constraining the VQE objective function such
that it penalizes the ground state (Higgott et al., 2019).

39

θ⟨H⟩

First, one ﬁnds an approximation to the ground state
of Hamiltonian H via VQE with θ0 = arg min
U (θ)
and approximated ground state ∣ψ(θ0)⟩ = U(θ0) ∣0⟩.
Then, one uses this information to formally project out
the approximate ground state to ﬁnd the next high-
est excited state. One deﬁnes the Hamiltonian H1 =
H + a ∣ψ(θ0)⟩ ⟨ψ(θ0)∣, with some suﬃciently large pos-
itive parameter a. The ground state of H1 then corre-
sponds to the ﬁrst excited state of H and can be found
with a VQE. This procedure can be repeated to ﬁnd
higher excited states up to any order by sequentially ac-
cumulating the projector terms of all states found. The
Hamiltonian for the k-th excited state is then given by
Hk = H +∑k−1
ai ∣ψ(θi)⟩ ⟨ψ(θi)∣. Combined with the uni-
tary coupled cluster ansatz, the orthogonally constrained
VQE can ﬁnd excited states of small molecules (Higgott
et al., 2019; Lee et al., 2018). It was further extended for
adaptive circuit construction (Kottmann et al., 2021b)
and imaginary time evolution (Jones et al., 2019b).

i

The projector term requires calculating the overlap
∣⟨ψ(θ)∣ψ(θ0)⟩∣, which can be achieved for example by
the SWAP test, by applying the inverse of the circuit
that generated the ground state ∣ ⟨0∣ U †(θ)U (θ0) ∣0⟩ ∣2, or
randomized measurements (Elben et al., 2020). An al-
ternative approach that relies on a discriminator circuit
that is trained in parallel to distinguish between the ex-
cited state to be learned and previously found lower-lying
states has been proposed (Tilly et al., 2020) and demon-
strated on a small model system. Scalable proposals still
remain an open research question. Since the projector
term does not require the overlap itself, but the absolute
square of it, it can be computed with the help of Eq. (5)
by computing the ﬁdelity of the current trial state with
the previously found states (Kottmann et al., 2021c; Lee
et al., 2018).

The subspace expansion method
Subspace expansion.
was introduced in Sec. V.A.3 for error mitigation. This
method can be also used to ﬁnd excited states (McClean
et al., 2017) and it was demonstrated for a small molecule
in (Colless et al., 2018). After ﬁnding the ground state of
a Hamiltonian H with VQE, one follows the steps that
were detailed in Sec. V.A.3. One expands the prepared
quantum state with diﬀerent appropriate operators that
match the low-energy excitations of H and generates a
set of states that span the low-energy subspace. Then,
overlaps between the states are measured, which are then
used to solve a generalized eigenvalue problem on a clas-
sical computer. The eigenvalues and eigenstates give the
excited states of the Hamiltonian. For quantum chem-
istry problems, the subspace expansion method was also
proposed for including dynamical correlations to ground
states over external corrections (Takeshita et al., 2020),
in the spirit of classical quantum chemistry methods, like
for example CAS-CI (Roos et al., 1980).

As alternative approach, the expansion in the subspace
can also be accomplished by real-time evolving a refer-
ence state, and picking states at diﬀerent evolution times
as basis for expansion (Stair et al., 2020). This is moti-
vated by the fact that the time evolution can be seen as
an approximate Krylov expansion of the quantum state.
Then, one proceeds to solve the generalized eigenvalue
problem to ﬁnd eigenstates and eigenvalues of the Hamil-
tonian.

Multistate contracted VQE. This algorithm combines the
non-weighted SSVQE with the subspace expansion to
ﬁnd the ground state and excited states (Parrish et al.,
2019a). First, one runs the non-weighted SSVQE routine
to ﬁnd the unitary U (θ∗) to ﬁnd k states that span the
subspace of the k smallest eigenvalues ∣ψ′
j⟩ = U (θ∗) ∣ϕj⟩.
Then, to ﬁnd the correct eigenstates, one runs the sub-
space expansion and measures the overlap matrix Hij =
j⟩, and diagonalizes it to ﬁnd estimates of the k
⟨ψ′
lowest eigenergies and eigenstates.

i∣ H ∣ψ′

40

Subspace-search VQE/State-averaged VQE. The core idea
of a subspace-search VQE (SSVQE) (Nakanishi et al.,
2019) or state-averaged VQE (SAVQE) (Arimitsu et al.,
2021; Yalouz et al., 2021) is to minimize the energy of a
PQC U (θ) over a set of orthogonal quantum states. The
goal is to ﬁnd the k-th eigenstates with lowest eigenen-
ergy of a Hamiltonian H. In the weighted SSVQE the
cost function is

L(θ) =

k
∑
j=1

wj ⟨ϕj∣ U †(θ)HU (θ) ∣ϕj⟩ ,

(75)

j=0

where {∣ϕj⟩}k
is a set of k easily preparable mutu-
ally orthogonal quantum states (with ⟨ϕi∣ϕj⟩ = δi,j)
and {wj}j are positive real numbers with wi > wj for
θL(θ) to its global
i < j. Minimizing θ∗ = arg min
minimum gives us the ground state and excited states
∣ψj⟩ = U (θ) ∣ϕj⟩, where j = 1 is the ground state and
j > 1 the excited states sorted in ascending order. This
algorithm gives all k eigenstates in a single optimization
routine. Note however that the more states to be op-
timized, the more complex the optimization landscape
and the eﬀort to minimize becomes. An alternative for-
mulation of the algorithm to ﬁnd speciﬁcally the k-th
lowest eigenstate is the unweighted SSVQE. Here, one
minimizes L1(θ) = ∑k
j=1 ⟨ϕj∣ U †(θ)HU (θ) ∣ϕj⟩. How-
ever, due to the absence of weights, the found states
j⟩ = U (θ∗) ∣ϕj⟩ for minimal θ∗ are not proper eigen-
∣ψ′
states of H, but are superposition states that span the
subspace of the k lowest energies. As ﬁnal step to ﬁnd the
k-th eigenstate, one ﬁxes θ = θ∗ to its minimized value,
and then maximizes φ∗ = maxφL2(φ), with L2(φ) =
∑k
j=1 ⟨ϕj∣ V †(φ)U †(θ∗)HU (θ∗)V (φ) ∣ϕj⟩ and V (φ) be-
ing a unitary that acts only on the Hilbert space of the
k lowest eigenstates. Then, for the maximized φ∗, the k-
th lowest eigenstate is given by ∣ψk⟩ = U (θ∗)V (φ∗) ∣ϕk⟩.
Besides general applications that involve excited states,
state-averaged orbital-optimized VQEs (SA-OO-VQE)
were proposed to treat chemical systems that require a
“democratic description of multiple states” as for example
necessary in the vicinity of conical intersections (Yalouz
et al., 2021). Here, “democratic description” corresponds
to treating degenerate or quasi-degenerate states at the
same footing.

Fourier transform of evolution. Recent experiments have
determined the spectra of molecular and many-body
Hamiltonians using superconducting processors (Aleiner
et al., 2020; Quantum et al., 2020; Roushan et al., 2017).
A particular method to determine the eigenergies of
Hamiltonians via Fourier transforming the dynamics of
observables has been applied in (Aleiner et al., 2020;
Roushan et al., 2017). The idea is to prepare a Fock state
that has overlap with the eigenstates whose eigenvalues
one wants to calculate. The Fock state is then evolved in
time with the Hamiltonian and speciﬁc observables are
measured over a range of time. The Fourier transform
of the time evolution of the observables can be used to
deduce the eigenenergies of the Hamiltonian.

Witness-assisted variational eigenspectra solver (WAVES).
WAVES core idea is to use a single reference qubit as an
eigenstate witness to variationally ﬁnd the ground state
and excited states (Santagati et al., 2018). A variational
ansatz applied to a reference state is chosen. Then, the
time evolution operator U (t) = exp(−iHt) is evolved on
the ansatz state as a control unitary CU (t), with the
control being the single qubit in a superposition state.
Then, full tomography is performed on the single qubit
to read out its von-Neumann entropy. If the variational
state is an eigenstate of the Hamiltonian H, then the en-
tropy is zero. Further, the energy of the state can be
estimated from the state of the qubit as well. The ansatz
is variationally updated using the information from the
qubit in a iterative fashion until the ground state is found.
Excited states can be found by applying an appropriate
excitation operator on the found ground state, and then
variationally minimizing the von-Neumann entropy of the
qubit. As last step, the authors suggest to use the iter-
ative phase estimation algorithm to further improve the
accuracy of the excited state as well determine its eigen-
value. This method requires to implement a controlled
time evolution operator, similar to non-variational pro-
posals (Jensen et al., 2020), which are considered to be
challenging for larger systems on NISQ devices.

5. Hamiltonian simulation

A major application for quantum computers is the sim-
ulation of the dynamics of Hamiltonians for problems
such as many-body physics and chemistry. One stan-
dard approach for quantum simulation of Hamiltonians
is based on the Trotter-Suzuki expansion from Eq. (14),
where the evolving unitary is split up into small discrete
timesteps of eﬃciently implementable unitaries, which
can be run on the quantum computer. Naturally, the
depth of the quantum circuit increases polynomially with
the desired time to be evolved and target accuracy, which
may not be feasible on NISQ devices without access to
error correction. The relevant algorithms are reviewed
in the following. We remark that some necessary tools
to simulate many-body interaction Hamiltonian (Bravyi
et al., 2008; Menke et al., 2019) have also been proposed.

VQA have been pro-
Variational quantum simulator.
posed to solve dynamical problems in the NISQ era (Li
and Benjamin, 2017). The core idea is to iteratively
update an eﬃciently implementable variational quantum
state ∣ψ(θ)⟩ with a new set of parameters θ → θ′ such
that it minimizes the error between the actual time evolu-
tion exp(−iHδt) ∣ψ(θ)⟩ for a timestep δt and the updated
variational state ∣ψ(θ′)⟩. The rules to update the param-
eters θ to solve the Schrödinger equation id/dt ∣ψ(t)⟩ =
H ∣ψ(t)⟩ can be found by the variational McLachlan’s
principle δ∣∣(d/dt + iH) ∣ψ(θ)⟩ ∣∣ = 0 with ∣∣ ∣ψ⟩ ∣∣ =
⟨ψ∣ψ⟩
and demanding that θ remains real-valued. One ﬁnds a
set of linear equations of motion A ˙θ = C with

√

(76)

Ai,j = Re(∂θi ⟨ψ(θ)∣ ∂θj ∣ψ(θ)⟩),
Ci = Im(∂θi ⟨ψ(θ)∣ H ∣ψ(θ)⟩) .
At a given step of the iteration, one needs to measure
the elements of A and C using the Hadamard test or
methods from (Mitarai and Fujii, 2019) (see Sec. II.C),
and then update θ with the solution of the linear equa-
tion of motion by a small timestep δt. The solver can
be combined with adaptive strategies to reduce the com-
plexity of the Ansatz circuit (Yao et al., 2020c; Zhang
et al., 2020d).

VQS has been applied on the IBM quantum processor
to simulate energy transfer in molecules (Lee et al., 2021)
as well as to simulate a time-dependent Hamiltonian (Lau
et al., 2021a). A straightforward extension of the vari-
ational quantum simulator can be applied to solve the
Schrödinger equation in imaginary time (McArdle et al.,
2019a), for time-dependent problems (Yuan et al., 2019)
or for general linear diﬀerential equations (Endo et al.,
2020c; Kubo et al., 2020).
Its implementation to open
quantum systems (Endo et al., 2020c; Yuan et al., 2019)is
discussed in Sec. VI.A.7. Using the hardware-eﬃcient
structure of the PQC, it is possible to reduce the cost of
measuring the A and C matrices (Benedetti et al., 2020).

41

Alternatively, the projected - Variational Quantum Dy-
namics method (p-VQD) has been proposed to bypass
the measurement of aforementioned matrices (Barison
et al., 2021; Otten et al., 2019). Here, one variation-
ally maximizes the ﬁdelity between the PQC ∣ψ(θ)⟩ and
the Trotter evolved state exp(−iHδt) ∣ψ(θ′)⟩. The opti-
mized PQC yields the state evolved by a time δt. This
algorithm is then repeated to gain evolution for longer
times. By appropriately choosing the evolution time δt,
barren plateaus can be avoided (Haug and Kim, 2021b).

The subspace
Subspace variational quantum simulator.
variational quantum simulator (SVQS) (Heya et al.,
2019) builds upon the idea of the SSVQE (Nakanishi
et al., 2019) introduced earlier in Sec. VI.A.4. The core
idea is to rotate the initial state to be evolved onto the
low-energy subspace found by the weighted SSVQE, then
evolve it in time within the subspace, and then apply
the reverse mapping. First, run the weighted SSVQE by
preparing k initial states {∣ϕj⟩ = σx
which are or-
thogonal with each other (⟨ϕi∣ϕj⟩ = δi,j) and lie in the
computational subspace, as well as a PQC U (θ). Now
as in the weighted SSVQE minimize Eq. (75).

k
j ∣0⟩}
j=0

Then, prepare an initial state ∣ψin⟩ to be evolved,
which is encoded into the computational subspace by ap-
plying the Hermitian conjugate of the obtained circuit
U †(θ). Here, the evolution of the state in time is per-
formed by applying single-qubit rotations on each qubit
T (t) = ⊗j RZ(−Ejt), where {Ej}j are the eigenenergies
of the eigenstates {∣Ej⟩}j obtained by SSVQE earlier.
Finally, the state T (t)U †(θ) ∣ψin⟩ in the computational
subspace is reverse mapped by applying U (θ), giving the
evolved state

∣ψ(t)⟩ = U (θ)T (t)U †(θ) ∣ψin⟩ .

(77)

This method has the key advantage that since the evo-
lution is directly implemented as simple rotations in the
computational subspace, the circuit depth is independent
of the evolution time to be simulated. However, the ini-
tial SSVQE optimization can be diﬃcult, especially when
one considers many eigenstates k.

Similar to the idea of the
Variational fast forwarding.
SVQS, variational fast forwarding (VFF) relies on the
idea of evolving a quantum state in time exp(−iHt)
within a diagonal subspace, such that an enhanced evo-
lution time can be achieved (Cirstoiu et al., 2020). First,
a circuit that implements a small timestep of the desired
evolution is implemented as V (δt) = exp(−iHδt). Then,
an approximate diagonal factorization of V (δt) is trained
for a particularly structured variational circuit

U (θ, γ, δt) = W (θ)D(γ, δt)W †(θ) .

(78)

Here, D(γ, δt) is composed of commuting unitaries and
chosen to parameterize the eigenvalues of unitary V (δt),
whereas W (θ) represents its eigenvectors. Then, the evo-
lution to an arbitrary time T = N δt, where N is some
integer, is found by fast forwarding with U (θ, γ, N δt) =
W (θ)DN (γ, δt)W †(θ). For the training of the varia-
tional Ansatz, the ﬁdelity between V (δt) and U (θ, γ, δt)
is maximized by a quantum-classical feedback loop with
a cost function that uses the local Hilbert-Schmidt
test (Khatri et al., 2019). As alternative approach, it
was proposed to diagonalize the Hamiltonian H instead
of the unitary V (δt), and fast forward via U (θ, γ, T ) =
(Commeau et al., 2020).
W (θ) exp(−iD(γ)T )W †(θ)
Fast-forwarding can also be performed without requiring
to train via a feedback loop using the linear combination
of states approach (Eq. (42)) (Lim et al., 2021).

The VQS algorithm em-
Quantum Assisted Simulator.
ploys a classical-quantum feedback loop to update the
parameters of the PQC. Until the classical processor
has calculated its output, the classical-quantum feedback
loop delays any use of the quantum device, slowing the
algorithm on current cloud computing framework. The
VQS algorithm, as well as its VQE based variant, i.e.
SVQS share similarities and most of the concerns faced
by VQE, such as the barren plateau issue (see Sec. IV.A).
Further, the VQS algorithm requires controlled-unitaries,
which make it diﬃcult to realize for current-term de-
vices. To tackle the issues faced by VQS, the quantum
assisted simulator (QAS) was suggested recently (Bharti
and Haug, 2020b). The QAS algorithm does not need
any classical-quantum feedback loop, can be parallelized,
evades the barren plateau problem by construction, sup-
plies a systematic approach to constructing the ansatz
and does not require any complicated unitaries.

The QAS algorithm shares its approach with IQAE
(see Sec. III.E). The ansatz is given as a linear com-
bination of states ∣φ (α(t))⟩ = ∑∣ψi⟩∈CSK αi(t)∣ψi⟩ (see
Eq. (42)), with classical coeﬃcients α(t) for ansatz state
∣ψi⟩, which can be systematicly constructed (see Deﬁni-
tion 3). The Hamiltonian H is given as a linear combi-
nation of unitaries (see Eq. (43)). The QAS algorithm
employs Dirac-Frenkel principle to obtain the following
classical evolution equation for α(t)

E

∂α(t)
∂t

= −ιDα(t).

(79)

42

on truncated Taylor series was proposed recently (Lau
et al., 2021b). The classical post-processing in the afore-
mentioned algorithm corresponds to a QCQP.

6. Quantum information scrambling and thermalization

Quantum information scrambling is a quantum phe-
nomena occurring when initially local states become in-
creasingly non-local with the time-evolution of the sys-
tem. It can be analyzed by computing the so-called out-
of-time-ordered correlation function (OTOC) and has
strong implications in thermalization in closed quantum
systems dynamics. Recent experiments have been carried
out to study this phenomena in a few qubits trapped-
ion devices and simulators (Joshi et al., 2020; Landsman
et al., 2019), and in a 53 superconducting qubit proces-
sor (Mi et al., 2021). The algorithms proposed are based
on the well-known teleportation algorithm and use sin-
gle and two-qubit gates to reproduce the the scrambling
process.

In the context of VQAs, a variation of the VQE al-
gorithm has been proposed to obtain the thermal evo-
lution of quantum systems (Verdon et al., 2019b). The
authors present the Quantum Hamiltonian-Based Mod-
els (QHBM), an extension of the VQA’s PQC to mixed
states instead of pure states. Within this approach, the
QHBM are classically trained to learn a mixed state dis-
tribution as a function of the optimization parameters.
A direct application of such a model is the Variational
Quantum Thermalizer (VQT), an algorithm which goal
is to prepare a ﬁxed-temperature thermal state of a given
Hamiltonian.

The limitations of using variational QML algorithms
to learn a scrambling unitary have also been studied in
(Holmes et al., 2020), where it is found trainability issues
related with barren plateaus (see Sec. IV.A).

7. Simulating open quantum systems

In the following, we deal with the physics of open quan-
tum systems (Huh et al., 2014) which are well-described
by the Lindblad master equation from Eq. (52). By sam-
pling from a mixture of pure state trajectories evolved
by a non-Hermitian Hamiltonian and random quantum
jumps, one recovers the Lindblad dynamics.

Here, Ei,j = ⟨ψi∣ψj⟩ and Di,j = ∑k βk⟨ψi∣Uk∣ψj⟩ are over-
lap matrices that can be eﬃciently measured on a quan-
tum computer, i.e. for H given as combination of Pauli
strings, the overlaps are measurement of Pauli strings.

Recently, QAS was run on the IBM quantum computer
and showed superior performance compared to Trotter
and VQS for a time-dependent Hamiltonian (Lau et al.,
2021a). A novel Hamiltonian simulation algorithm based

Trotter simulation of open systems. NISQ quantum hard-
ware can be used to directly simulate the dynamics
of small-scale open systems by using ancillas combined
with measurements in the spirit of the quantum jump
method (Hu et al., 2020; Koppenhöfer et al., 2020). Here,
the unitary part of the dynamics is implemented via a
Suzuki-Trotter decomposition (see Sec. II.B). The non-
unitary part of the dynamics that encodes the interaction

with the external degrees of freedom is simulated by en-
tangling the circuit with ancillas and subsequently mea-
suring them. For every time step of the dynamics a new
set of ancilla qubits has to be provided. Current quan-
tum computers based on superconducting circuits do not
allow one to measure and re-use qubits, thus requiring a
linear increase in the number qubits with every timestep.
Further, in general the circuit depth scales polynomially
with simulation time.

In Ref. (Endo
Generalized variational quantum simulator.
et al., 2020c) the VQS algorithm is extended to sim-
ulate the method of quantum jumps in a variational
setting. They implemented the algorithm for 2D Ising
Hamiltonians for 6 qubits and observed a dissipation in-
duced phase transition.
In another work (Yuan et al.,
2019), VQS is extended to mixed states and simulate the
Lindblad dynamics fully without the need of stochastic
sampling. The idea is to write the density matrix as
ρ = ρ (θ (t)) and simulate the evolution of ρ via evolution
of the parameters θ(t). One can re-express Eq. (52) as
dt ρ = ∑i giSiρT †
, where Si and Ti are unitaries and gi
d
are coeﬃcients. Using Dirac and Frenkel equation, the
evolution of parameters is given by

i

Mi,j

˙θj = Vi,

∑
j

Mi,j = Tr [(∂iρ (θ(t)))† ∂jρ (θ(t))]
⎤
⎥
⎥
⎥
⎦

⎡
⎢
(∂iρ (θ(t)))† ∑
⎢
⎢
⎣
j

gjSjρT †
j

Vi = Tr

.

(80)

(81)

(82)

This method can also be extended to deep quantum neu-
ral network type Ansatzes (Liu et al., 2020b).

These algorithms, however, suﬀer from the canonical
drawbacks of the VQS algorithm, such as the require-
ment of feedback loop, trainability issues and necessity
of controlled unitaries.

Recently, the
Generalized quantum assisted simulators.
generalized quantum assisted simulator (GQAS) (Haug
and Bharti, 2020) was proposed as extension of the
quantum assisted simulator to tackle above issues (see
Sec. VI.A.5).
Instead of using a density matrix, the
GQAS algorithm introduced the concept of “hybrid den-
sity matrix”

ˆρ = ∑
k,l

βk,l∣ψk⟩⟨ψl∣

(83)

for βk,l ∈ C and ∣ψl⟩ are chosen from the set of cumu-
lative K moment states (see Deﬁnition 3). A classical
device stores the coeﬃcients β and the quantum states
correspond to some quantum register. A hybrid den-
sity matrix is a valid density matrix, if Tr (ˆρ) = 1 and

43

ˆρ ≽ 0. Note that the normalization condition is fulﬁlled
when Tr (ˆρ) = Tr (βE) = 1, where Ek,l = ⟨ψk∣ψl⟩. Using
Dirac-Frenkel principle, the simulation of open system
dynamics for the hybrid density matrix is given by

E

d
dt

β(t)E = −ι(Dβ(t)E − Eβ(t)D)+

K
∑
n=1

γn(Rnβ(t)R†

n −

1
2

Fnβ(t)E −

1
2

Eβ(t)Fn),

(84)

k,l = ⟨ψk∣Ln∣ψl⟩ and F n

where Dk,l = ⟨ψk∣H∣ψl⟩, Rn
k,l =
nLn∣ψl⟩. For a given choice of ansatz, the quantum
⟨ψk∣L†
computers only have to compute the overlap matrices
as measurements of Pauli strings. Then, the classical
computer uses this information to simulate the dynamics.
There is no quantum-classical feedback loop, which on
the currently available quantum computers can speed up
computations substantially.

8. Nonequilibrium steady state

Unlike the previous Sec. VI.A.7, we concern the physics
of open quantum system that is out-of-equilibrium in na-
ture, which is common in designing devices for molecular-
scale electronics (Xiang et al., 2016), excitonic trans-
port (Kyaw et al., 2017) as well as quantum thermody-
namics (Vinjanampathy and Anders, 2016). By “out-of-
equilibrium”, we mean that a quantum system and bath/s
are constantly driven by external forces such as voltage
diﬀerences, during which the composite particles of the
system and bath are also interacting each other.

that

Notice

the method used in the previous
Sec. VI.A.7 would also lead to extremely high dimen-
sional matrices in the Lindblad like master equation ap-
proach dˆρ/dt = ˆˆLˆρ (see Sec. V.A.1, Eq. (52)), and it
deems impossible to capture all the degrees-of-freedom
involved. However, one may relax some of the constraints
involved in the problem setup, say time-independent dis-
sipation and non-interaction among particles with small
system size. The steady state density matrix of a quan-
tum system ˆρSS at the limit t → ∞ is then given by
solving

ˆˆL ∣ˆρSS⟩ = 0,
or equivalently ˆˆL† ˆˆL ∣ˆρSS⟩ = 0. A recent study (Yoshioka
et al., 2020) has shown that with ancilla qubits, the above
non-Hermitian superoperator ˆˆL can be simulated. The
main idea is to map the density matrix of N qubits onto
a vector of twice the number of qubits 2N

(85)

ˆρ = ∑
ij

ρij ∣i⟩ ⟨j∣ → ∣ˆρ⟩ = ∑
ij

ρij
C

∣i⟩P ∣j⟩A ,

(86)

√

a digital
where C =
quantum computer and the variational approach

∑ij ∣ρij∣2.

By using

one iteratively minimize the expectation value of
a parameterized density matrix ∣ρθ⟩ = U (θ) with
minθ ⟨0∣⊗2N U †(θ) ˆˆL† ˆˆLU (θ) ∣0⟩⊗2N . A drawback of this
approach is that measuring expectation values from the
parameterized density matrix directly is diﬃcult and thus
requires an additional transformation.

function (NEGF)

Beyond the Lindblad master equation, to capture
and describe truly “out-of-equilibrium” processes, the
nonequilibrium Green’s
formalism
(Dalla Torre et al., 2013; Sieberer et al., 2016; Stefanucci
and Van Leeuwen, 2013) is commonly used. These exist-
ing Green’s function techniques are very complicated to
be solved. Many assumptions need to be made in order to
have some closed form and do some calculations. In par-
ticular, it requires that the interaction among particles
are weak such that one does not need to ﬁnd higher-order
Feynman diagrams in ﬁnding the self-energy functional.
Since some of the existing quantum algorithms provide
promising speedup over classical ones, one may wonder
to use quantum algorithms to solve the NEGF, with a
strategy of leaving classically hard computational tasks
to the quantum processor and feeding its output back to
classical computer, which could be done in a variational
fashion. There exists a number of proposals (Endo et al.,
2020b; Jaderberg et al., 2020; Kreula et al., 2016) in the
literature that undertake such hybrid quantum-classical
approach. However, these methods assume no interaction
among composite particles. In generic open quantum sys-
tem in which many-body eﬀects cannot be neglected, one
would like to go beyond those assumptions. It is yet to see
any quantum advantage of those near-term quantum al-
gorithms over existing methods (Fitzpatrick et al., 2017;
Härtle et al., 2008; Li et al., 2016) for solving nonequilib-
rium steady state solution of an extremely complex physi-
cal setup such as vibrationally-coupled electron transport
with multiple electronic levels (Härtle et al., 2008).

9. Gibbs state preparation

Finding the ground state of quantum Hamiltonians is
known to be QMA-hard. Under reasonable assumptions,
preparing Gibbs state corresponding to arbitrarily small
temperatures is as challenging as the Hamiltonian ground
state problem. Gibbs state preparation has applications
in many areas including quantum annealing, quantum
SDP solvers, Boltzmann training and simulation of equi-
librium physics. For a Hamiltonian H, the Gibbs state
at temperature T (with kB = 1) is given by

ρ(T ) =

exp (− H
)
T
Tr (exp (− H
T

.

))

(87)

Some of the approaches to prepare Gibbs state are men-
tioned in the following

44

1. Starting with d-dimensional maximally mixed state
, under imaginary time evolution for time τ, one
Id
d
gets Gibbs state corresponding to temperature T =
1
2τ

(Verstraete et al., 2004).

2. One can start with maximally entangled state ∣ξ⟩d =
∑j ∣j, j⟩AB of a system combined of two equally
1
√
d
sized subsystems A and B, and evolve it under
imaginary time evolution using Hamiltonian H ⊗ I.
After tracing out system B, the state of system A
at time τ is given by Gibbs state corresponding to
temperature T = 1
2τ .

3. The Gibbs state of a system is the density matrix
which corresponds to minimum of its free energy.
Thus, one can variationally tune the parameters of
a parametrized density matrix such that it leads to
minimization of free energy.

Recently, a few NISQ algorithms for Gibbs state prepara-
tion have been proposed, which apply the aforementioned
ideas. In (Yuan et al., 2019), authors used VQS based
imaginary time evolution to prepare Gibbs state follow-
ing the second approach. The ﬁrst approach does not
work in VQS based imaginary time evolution. In another
work (Chowdhury et al., 2020), the third approach was
used to prepare Gibbs states. The aforementioned works
require complicated controlled unitaries and classical-
In (Haug and Bharti, 2020),
quantum feedback loop.
QAS based imaginary time evolution (see Sec. VI.A.5)
was suggested to prepare the Gibbs state with either
ﬁrst and second approach. The QAS approach does not
require any classical quantum feedback loop or compli-
cated controlled unitaries. Using random circuits as ini-
tial state, (Richter and Pal, 2020) suggested an approach
based on imaginary time evolution prepare Gibbs state.

10. Simulation of topological phases and phase transitions

NISQ devices can be used to study the ground states
of quantum Hamiltonians for understanding topologi-
cal phases and phase transitions. An important exam-
ple is the one-dimensional cluster Ising Hamiltonian, de-
scribing a symmetry-protected topological phase of mat-
ter. The ground state of this Hamiltonian is the one-
dimensional cluster state, which can be created by ap-
plying Hadamard gates to all qubits, followed by control-
Z gates on each pair of neighboring qubits. State to-
mography and symmetry arguments were used to study
the entanglement measures of this state and to high-
light its topological nature (Azses et al., 2020; Choo
et al., 2018). A modiﬁed algorithm was implemented
to simulate an enlarged family of Hamiltonians and
study the quantum phase transition between a topolog-
ical and a topologically-trivial phases of matter (Smith
et al., 2019a). NISQ devices were also used to simulate

the dynamics of fundamental models of quantum mag-
netism (Bassman et al., 2020; Smith et al., 2019b) and
topological phases in one and two dimensions (Mei et al.,
2020).

11. Many-body ground state preparation

The preparation of non-trivial many-body quantum
states is crucial for many applications in quantum metrol-
ogy and quantum information processing (Kyaw et al.,
2014b). QAOA has been used as a resource-eﬃcient
scheme for many-body quantum state preparation.
In
this context, the state ∣ψ⟩ for a system with linear di-
mension L (e.g. L can refer to the number of spins in a
1D spin chain) is non-trivial if there is no local unitary
circuit U with depth O(1) which can generate ∣ψ⟩ from
a product state ∣φ⟩:
∣ψ⟩ = U ∣φ⟩ (Ho and Hsieh, 2019).
The Greenberger-Horne-Zeilinger (GHZ) state, which is
an essential resource in several quantum metrology pro-
posals (Dür et al., 2014; Tóth and Apellaniz, 2014), is
an example of a non-trivial quantum state due to its
highly-entangled nature, and is the ground state of the
1D Ising Hamiltonian with periodic boundary conditions,
i.e. HP = − ∑L

Using QAOA, it has been shown that the GHZ state
can be prepared eﬃciently with perfect ﬁdelity using p =
L/2, where p is the QAOA depth (Ho and Hsieh, 2019).
The authors conjectured that the ground state of the 1D
transverse-ﬁeld Ising model

i=1 ˆσi

z ˆσi+1
z

with L even and periodic boundary conditions, can
be prepared perfectly at any point in the phase diagram
using QAOA with p = L/2. The ground state of the
antiferromagnetic Heisenberg model with open boundary
i=1 ˆσi ⋅ ˆσi+1,
conditions HP = ∑L−1
where ˆσi ≡ (ˆσi
y, ˆσi
x, ˆσi

z), has also been prepared with
near perfect ﬁdelity using QAOA. Using a long-range 1D
Ising Hamiltonian HP = − ∑i<j Jij ˆσz

where Jij = J0/∣i − j∣α, QAOA can achieve the ultrafast
preparation of a GHZ state with a circuit depth of O(1)
(for α = 0) (Ho et al., 2019). This result was generalized
by (Wauters et al., 2020a), which showed that QAOA
can prepare the ground states of the fully-connected fer-
romagnetic q-spin model (note that q is used here instead
of the conventional p in order to avoid confusion with the
QAOA depth p)

i ˆσj
z

,

H = −

1
N q−1

(

N
∑
i=1

q
ˆσi
z)

− h(

N
∑
i=1

ˆσi
x)

(88)

with resources scaling polynomially with the number of
spins N . Since the system can encounter a ﬁrst-order
phase transition where the spectral gap becomes very
small, QAOA greatly outperforms quantum annealing in
this instance since an exponentially long annealing time
is needed.

45

12. Quantum autoencoder

The quantum autoencoder (Romero et al., 2017)
(QAE) is a VQA for the compression of data on a quan-
tum computer. It ﬁnds a new data state representation
which requires fewer qubits than the data was originally
deﬁned upon. This new encoding is said to be a represen-
tation in the latent space. The process of transforming
the data into the latent space is referred to as encoding,
and the converse, transformation of states in the latent
space back onto the original, is known as decoding.

Training a QAE requires the minimization of an objec-
tive deﬁned over several related quantum states. For a
set of n-qubit states {∣ψ⟩i}, the goal of the QAE is to ﬁnd
a unitary circuit E(θ) which accomplishes the following
transformation

E ∶ Hn → Hk ⊗ Hn−k∣E ∣ψ⟩i = ∣φ⟩i ⊗ ∣0⟩⊗(n−k) ,

(89)

where k is the dimension of the latent space. Thus,
the application of a perfectly trained autoencoder to any
state of the relevant set yields a product state that con-
sists of the transformed state on k qubits with a (n − k)-
qubit “trash” state. In principle, the trash state could be
any state, but the all-zero state is chosen for simplicity.
The loss function of the QAE may be deﬁned in several
ways. It is a ﬁdelity loss function (see Sec. II.A), in which
minimization is performed by increasing the overlap be-
tween a (partial) measurement of the state resulting from
the application of the encoder and a known state. The
most practical deﬁnition for training the autoencoder,
called “trash training”, uses as its objective the overlap
between the “trash” qubits and the ∣0⟩⊗(n−k) state. For-
mulated in the density matrix picture, the objective of
minimization is

O = −Tr(I ⊗k ⊗ ∣0⟩⟨0∣⊗(n−k)ρi),

(90)

where ρi = ∑i pi∣ψi⟩⟨ψi∣ with, in general, all states in the
set equally weighted.

The QAE can be trained by training only the encoding
circuit, due to the unitarity of the encoder; the decoding
operation is achieved by the complex conjugate of the
encoder circuit.
Improvements in the encoding results
translates to improvements in the decoder, a boon not
possessed by classical autoencoders.

After the successful training of a QAE, the encoder
and decoder circuits may be used for data transformation
in further algorithms, action upon the data in the latent
space, in which the data is represented more densely, may
prove powerful in further applications.

A data re-uploading strategy to construct a QAE en-
coder is presented in (Bravo-Prieto, 2020), where the so-
called enhanced feature quantum autoencoder (EF-QAE)
is trained to compress the ground state of the 1-D Ising
model as a function of the external ﬁeld and samples of

handwritten digits. The QAE has also been deployed ex-
perimentally in the compression of qutrits on a photonic
device (Pepper et al., 2019). Small states have been ex-
perimentally compressed losslessly on photonic devices
by (Huang et al., 2020a). (Bondarenko and Feldmann,
2020) designed a QAE capable of denoising entangled
quantum states, such as GHZ or W states, subject to
spin ﬂip errors and random unitary noise.

13. Quantum computer-aided design

Two recent proposals focus the computing power of
NISQ devices back on the processors themselves: Tech-
niques were developed to simulate quantum hardware
on a quantum computer (Kottmann et al., 2020; Kyaw
et al., 2020b). They establish the paradigm of “quan-
tum computer-aided design”, indicating that classically
intractable simulations of quantum hardware properties
can be performed on a quantum computer, thereby im-
proving the prediction of device performance and reduc-
ing experimental testing cycles.

In the ﬁrst approach, optical path modes are mapped
to sets of qubits, and quantum optical elements are
mapped to digital quantum circuits that act on the qubits
(Kottmann et al., 2020). Photonic setups can then be
ﬂexibly simulated. The framework is used to simulate
both a Boson sampling experiment and the optimization
of a setup to prepare a high-dimensional multipartite en-
tangled state.

The second proposal introduces quantum simulation
techniques for superconducting circuit hardware (Kyaw
et al., 2020b). A circuit module consisting of coupled
transmon qubits is designed. The corresponding super-
conducting circuit Hamiltonian, which is written in a
basis of multi-level operators, is eﬃciently mapped to
a set of data qubits (Sawaya et al., 2020). Simulations
of a multi-level extension to the VQE algorithm (Hig-
gott et al., 2019) are used to determine the spectrum
of the superconducting circuit. The resulting states and
eigenenergies are directly related to experimentally rele-
vant device characteristics and can be used to seed sim-
ulations of time dynamics.

Device and setup design is a key challenge in improving
and scaling quantum systems. Therefore, digital quan-
tum simulation of quantum processors will be a relevant
application for NISQ quantum computers as classical re-
sources become too small to capture the relevant Hilbert
space of the hardware.

B. Machine learning

The goal of machine learning is to facilitate a computer
to act without being explicitly programmed to. As per
Tom Mitchell (Mitchell, 1997), given some class of tasks

46

T and performance metric P, a computer program is said
to learn from experience E if

P(T ) ∝ E,

(91)

i.e. its performance measured by P for task T increases
with E.

Depending on the kind of experience E permitted to
have during the learning process, the machine learning
algorithms are classiﬁed into three categories:

1. Supervised learning. Given a function y = f (x), the
goal is to learn f so that it returns the label y for
the unlabelled data x. A canonical example would
be pictures of cats and monkeys, with the task to
recognize the correct animal. Given training exam-
ples from the joint distribution P (Y, X), the task
of supervised learning is to infer the probability of a
label y given example data, x, i.e., P (Y = y∣X = x).

2. Unsupervised learning. The data is provided with-
out any label. The task is to recognize an under-
lying pattern in this data. Given access to several
examples x ∈ X the algorithm goal is to learn the
probability distribution P (X) or some important
properties of the aforementioned distribution.

3. Reinforcement learning. In this case, neither data
nor label is provided. The machine has to generate
data and improve the aforementioned data genera-
tion process via optimizing a given reward function.
This is similar to how a human child learns to walk.
If it fails, the output acts as a negative reward.

Machine learning has uncovered applications in physics
such as Monte Carlo Simulation (Huang and Wang, 2017;
Liu et al., 2017), many-body physics (Carleo and Troyer,
2017), phase transition (Wang, 2016), quantum founda-
tions (Bharti et al., 2019a), and state tomography (Torlai
et al., 2018).

For a meticulous review on machine learning for
physics, refer to (Bharti et al., 2020; Carleo et al., 2019;
Dunjko and Briegel, 2018).

Most of the success in machine learning come from the
use of artiﬁcial neural networks, structures capable of
learning sophisticated distributions and that encompass
multiple features that can be ﬁne-tuned depending on
the problem to tackle. In that direction, there are sev-
eral proposals to deﬁne a model for quantum neural net-
works with diﬀerent kind of activation functions (Schuld
et al., 2014; Torrontegui and García-Ripoll, 2019; Wan
et al., 2017). For implementations of artiﬁcial neuron
and artiﬁcial neural network on the NISQ hardware, re-
fer to (Tacchino et al., 2020a, 2019).

The merger of quantum theory and machine learning
has recently led birth to a new discipline, known as quan-
tum machine learning (QML). Both algorithms that deal
classically with data from a quantum origin and quantum

algorithms that process quantum and classical data are
usually known as QML applications. However, in this re-
view, we will focus only on those algorithms that process
data quantum-mechanically, in particular, those that use
quantum algorithms that can be run in NISQ comput-
ers. For QML review that mainly focus on fault-tolerant
quantum algorithms check (Biamonte et al., 2017). For
a survey of quantum computational learning theory, re-
fer to (Arunachalam and de Wolf, 2017). An analysis of
QML from a classical ML perspective can be found at
(Ciliberto et al., 2018; Dunjko and Briegel, 2018), and
for near-term devices in (Benedetti et al., 2019b; Li and
Deng, 2021; Perdomo-Ortiz et al., 2018).

It might be surprising that a linear theory as quan-
tum physics can generate the non-linearities that a ma-
chine learning model needs. However, the linearity
of quantum mechanics comes from the dynamical part
(quantum states evolution) and one can encounter mul-
tiple sources of non-linearities arising from measurement,
post-selection or coupling the system with environment.
Quantum operations in the Hilbert space can also encode
non-linear behaviour, as it will be shown with Kernel
methods.

In the following subsections, we will present the quan-
tum mechanical analogs of the three machine learning
categories deﬁned above. The algorithms discussed will
be listed in Table II.

1. Supervised learning

The two prominent methods to perform a supervised
learning classiﬁcation task using a NISQ computer are
quantum Kernel estimation (Havlíček et al., 2019; Huang
et al., 2021; Kusumoto et al., 2019; Schuld and Killoran,
2019) and Variational Quantum Classiﬁer (VQC) (Farhi
and Neven, 2018; Mitarai et al., 2018).

Classical Kernel methods include well-known machine
learning algorithms such as Support Vector Machines
(SVM) (Cortes and Vapnik, 1995), Principal Component
Analysis (PCA) or Gaussian Processes, among others.
The rich theoretical structure of Kernel methods can be
expanded to the quantum world by deﬁning and working
in the Hilbert space with the quantum equivalent of fea-
ture vectors (Schuld and Killoran, 2019). To that aim,
one needs to modify and adapt the well-known theorems
to work in a quantum feature space. For more details
about classical Kernel methods we refer to (Hofmann
et al., 2008). A review on Kernel methods in the context
of QML can be found in (Mengoni and Di Pierro, 2019).
In the following lines, we will directly describe the quan-
tum versions of them. The basics of supervise learning
with quantum computers are presented in (Schuld and
Petruccione, 2018).

Given an input set X and quantum Hilbert space H,
data x ∈ X is encoded into a quantum state (quantum

47

feature vector ) ∣Φ(x)⟩ by means of the quantum feature
map, i.e. Φ ∶ X → H. The inner product of two quantum
feature vectors deﬁnes a kernel

κ (xi, xj) ≡ ⟨Φ (xi) ∣Φ (xj)⟩

,

H

(92)

for xi, xj ∈ X . In comparison with classical kernels, the
inner product is deﬁned in a Hilbert space by replacing
the standard deﬁnition ⟨⋅, ⋅⟩ by the Dirac brackets ⟨⋅∣⋅⟩.
For a map Φ, the reproducing kernel Hilbert space takes
the form

H

Rφ = {f ∶ X → C∣ f (x) = ⟨w∣Φ(x)⟩

, ∀x ∈ X , ∣w⟩ ∈ H} .
(93)
The orthogonality of ∣w⟩ w.r.t. ∣Φ(x)⟩ deﬁnes a decision
boundary, i.e. depending on the sign of the inner prod-
uct, x lies in one side of the hyperplane. The function
f is thus a linear function in H. The representer theo-
rem (Schölkopf et al., 2001) states that this function can
be approximated by the linear function f ⋆ by using the
kernel deﬁned above, i.e.

f ⋆(x) =

D
∑
i=1

αiκ (x, xi)

(94)

for an input dataset D. Using Eq. (94), one can solve a
convex optimization problem to get the coeﬃcients αi.
The analysis so far entails the connection between linear
models in reproducing kernel Hilbert space with kernel-
ized models in the input space.

One can use a quantum computer to calculate the in-
ner product of feature mapped quantum states to obtain
the kernel κ. This kernel can be fed to a classical de-
vice, which can use Eq. (94) to obtain the coeﬃcients αi,
for instance, by maximizing a cost function of the form
(Havlíček et al., 2019)

C(α) =

αi −

D
∑
i=1

1
2

D
∑
i,j

yiyjαiαjκ (xi, xj) ,

(95)

i=1 αiyi = 0.

where yi are the labels of the training points and con-
strained to ∑D
Ideas based on connections
between kernel methods and quantum circuit based ma-
chine learning has been used to justify that the models
for QML can be framed as kernel methods (Schuld, 2021).
For some of the other relevant works on quantum kernel
methods, refer to (Blank et al., 2020b; Park et al., 2020).
A high-dimensional data classiﬁcation experiment with
quantum kernel methods was carried out recently (Pe-
ters et al., 2021). The encoding of data into quantum
circuits is characterized by the quantum Fisher informa-
tion metric (Haug et al., 2021c). For hardware eﬃcient
PQCs, the kernel can be related to radial basis func-
tion kernels (Haug and Kim, 2021b; Haug et al., 2021c).
Measuring the quantum kernel using the SWAP or in-
version test scales as D2. Using randomized measure-
ments (Elben et al., 2020), the kernel can be computed

in a time that scales linearly with the dataset size D,
which allows for processing large datasets with quantum
computers (Haug et al., 2021c).

preparation circuit E that encodes the data points,

∣Φ(x)⟩ = E(x, φ)∣0⟩.

48

(98)

Also,

a Gaussian Boson Sampling device

(see
Sec. III.B) can be used for computing kernel functions
(Schuld et al., 2020b).

Another approach is to use a variational circuit U (θ)
and directly perform the classiﬁcation task in the repro-
ducing kernel Hilbert space, without using Eq. (94). This
approach is sometimes referred as a variational quan-
tum classiﬁcation. Data is also embedded into the state
∣Φ(x)⟩ and then processed with a PQC U (θ). The resul-
tant state becomes

∣Ψ(x, θ)⟩ = U (θ)∣Φ(x)⟩,

(96)

which parameters are estimated by training it to match
the target states ∣yi⟩ that represent the yi labels of the
training points, i.e. by minimizing the inﬁdelity

C(θ) =

D
∑
i=1

(1 − ∣⟨yi∣Ψ(xi, θ)⟩∣2) .

(97)

Both methods require a way to encode the data into a
quantum state. There are several strategies to deﬁne the
quantum feature map. It is a key step in the success of
the classiﬁcation task, as the needed non-linearities must
come from it. Furthermore, to eventually obtain any
quantum advantage, one should search from the set of
classically intractable feature maps. One of the ﬁrst pro-
posed approaches was the amplitude encoding (Schuld
et al., 2016) also required in other quantum algorithms
(Harrow et al., 2009). This approach encodes the classi-
cal data points into the amplitudes of a quantum state,
∣Φ(x)⟩ = ∑i xi∣ei⟩, where ∣ei⟩ are the basis states.
i.e.
However, this raw encoding requires i) knowing which
gates can be used to perform this operation for general
data points and ii) having an eﬃcient way to extract and
process these amplitudes. Although the ﬁrst point can
eventually be overcome by using similar approaches as
the ones used to deﬁne a PQC, the second one requires
tools as QRAM (Giovannetti et al., 2008), experimen-
tally challenging for the NISQ era. The studies towards
QRAM in (Park et al., 2019a) proposed an approach to
update classical data consisting of M entries of n bits
each using O(n) qubits and O(M n) steps. A forking-
based sampling scheme was suggested in (Park et al.,
2019b) to reduce the resource requirements for state
preparation for tasks involving repeated state prepara-
tion and sampling. At the moment of writing, building
a QRAM remains challenging and further investigations
are required.

In general, the encoding strategies used in state-of-the-
art algorithms consist on introducing the classical data
points into the parameters of the quantum circuit gates.
As brieﬂy mentioned in Sec. II.B, one designs a state

The use of φ parameters is optional and they can be
subject to the optimization subroutine too.

Typically, the encoding gate is designed using the same
structure of a layer-wise PQC from Eq. (22). Data points
are introduced in layers of single-qubit rotational gates
R, as deﬁned in Eq. (13), followed by an entangling gate
unitary W , e.g.

(

(99)

LE
∏
k=1

E(x) =

Rk(xi)) Wk,

n
⊗
i=1
with LE being the total number of encoding layers. Then,
the whole Variational Quantum Classiﬁer (VQC) is com-
posed by this encoding circuit and the processing one to
be optimized, i.e. UV QC(θ, x) = E(x)U (θ).

Alternatively, some works propose to remove the dis-
tinction between the encoding E and processing U cir-
cuits and introduce the data values along the circuit
(Lloyd et al., 2020; Nghiem et al., 2020; Pérez-Salinas
et al., 2020a; Schuld et al., 2020c; Vidal and Theis,
2019). This strategy, sometimes called input-redundancy
or data-reuploading, introduce the data in all circuit lay-
ers, e.g.

(

L
∏
k=1

UV QC(θ, x) =

Rk(xi, θ)) Wk,

n
⊗
i=1
where L is now the total number of circuit layers. This
strategy has proved the universality when applied to one
qubit (Pérez-Salinas et al., 2020a) and can reconstruct
the coeﬃcients of the Fourier series (Schuld et al., 2020c;
Vidal and Theis, 2019).

(100)

The inclusion of encoding strategies and, in particular,
the data re-uploading, can help well-known VQA such as
the VQE. In general, one of the ﬁnal goals of a VQE can
be the identiﬁcation of interesting points on a potential
energy surface generated by a parametrized Hamiltonian.
Often, one is interested in the ground state energy as a
function of some Hamiltonian parameter λ, e.g. the in-
teratomic distance, but other properties, like the energy
gap between ground state and ﬁrst excited state can be
interesting as well. (Kyaw et al., 2020b) To do so, one
often needs to scan discretely over λ for some particu-
lar interval and run a VQE to obtain the ground state
energy on each of these points. This becomes an extra
computational cost, especially if we are interested only
in a particular region of this ground state proﬁle, e.g.
to extract the λmin whose ground state has minimal en-
ergy. In that direction, some proposals suggest to encode
the parameters of the Hamiltonian into the PQC and
learn the energy proﬁles (Mitarai et al., 2019). In par-
ticular, the Meta-VQE algorithm (Cervera-Lierta et al.,
2021a) proposes to encode the λ into the PQC gates to-
gether with the optimization parameters. Then optimize

i=1⟨H⟩U (θ,λi)

an objective function that corresponds with the sum of
expectation values for some M training λ parameters,
i.e. ⟨ ˆO⟩= ∑M
. Once the circuit has been opti-
mized, one can run it again with the new λi to directly
extract an estimation of the ground state, without having
to optimize the full circuit again. An extension of this
approach is the optimized Meta-VQE (opt-meta-VQE ),
which consist of using the optimized parameters from
the Meta-VQE as starting points of a standard VQE.
This tries to avoid vanishing gradients issues (discussed
in Sec. IV.A) by starting in a particular region of the
parameter space instead of random initialization.

Some VQC also need an extra piece, the deﬁnition of
the target state ∣yi⟩ to construct the objective function
to be optimized using the ﬁdelity with respect to these
states. The goal of the quantum circuit is to divide and
push the quantum states that encode the data points into
two or more regions of the Hilbert space. To that aim, the
parameters of the circuit are trained to match every en-
coded state into a particular representative of one of these
regions. Therefore, the more separated these regions are,
the lesser misclassiﬁed points are expected. As discussed
in Sec. II.C, qubits measurement implies a certain com-
putational cost. For that reason, many proposals suggest
to use the state of only one qubit to train the whole cir-
cuit (Farhi and Neven, 2018; Schuld et al., 2020a). The
cost function estimation reduces to measuring the prob-
ability distribution of one qubit. Other works use a more
sophisticated deﬁnition of these target states by select-
ing the most orthogonal states of the qubits space (Lloyd
et al., 2020; Pérez-Salinas et al., 2020a). This strategy
is inspired from optimal state discrimination (Helstrom,
1969).

Using the nonlinear character of quantum mechanical
processes as “reservoir”, the notion of quantum reser-
voir computing has been suggested. The reservoir is
a highly nonlinear system whose parameters are arbi-
trary but ﬁxed. One can perform reservoir computing
by employing a basic training algorithm such as linear
regression at the readout stage. Since the reservoir pa-
rameters are ﬁxed, only training of the readout stage
parameters is required. The aforementioned idea helps
utilize the high nonlinearities of the reservoir without
the high computational cost of training. The concept of
employing quantum systems as quantum reservoirs was
ﬁrst introduced in (Fujii and Nakajima, 2017; Nakajima
et al., 2019). Quantum reservoir computing has been
proposed for many experimental platforms such as Gaus-
sian states in the optical set-up (Nokkala et al., 2020),
two-dimensional fermionic lattices (Ghosh et al., 2019)
and nuclear spins (Negoro et al., 2018). Quantum gate
based implementation of quantum reservoir computing
for NISQ devices has also been discussed (Chen et al.,
2020a). A Gaussian Boson Sampler (see Sec. III.B) can
also be used for quantum reservoir computing as sug-
gested in (Wright and McMahon, 2019) to perform ma-

49

chine learning tasks such as classiﬁcation. NISQ devices
have also been used for regression (Mitarai et al., 2018).
Distance-based classiﬁer using quantum interference cir-
cuits has been proposed in (Schuld et al., 2017).

Quantum annealing has been also applied to super-
vised learning to predict biological data (Li et al., 2018).
Here, the quantum annealer is used to train the parame-
ters of the classiﬁcation model, which is done by mapping
the problem of ﬁnding the optimal parameters to a min-
imization of a QUBO.

2. Unsupervised learning

The use of quantum devices to speed up diﬀerent unsu-
pervised learning tasks has been investigated thoroughly,
leading to diﬀerent algorithms for generative modelling
(Benedetti et al., 2019a, 2016, 2017), clustering (Otter-
bach et al., 2017), among others (Lloyd et al., 2013). An
analysis of quantum speedup in unsupervised learning for
Fault-Tolerance algorithms is presented in (Aïmeur et al.,
2013). The task of learning probabilistic generative mod-
els in particular has been of interest to the QML commu-
nity, because of the potential advantage quantum com-
puters may exhibit over their classical counterparts in
the near future (Perdomo-Ortiz et al., 2018). For the ad-
vantages rendered by quantum correlations such as con-
textuality and Bell non-locality for generative modelling,
refer to (Gao et al., 2021).

Generative Modelling involves learning the underlying
probability distribution from a ﬁnite set of samples from
a data set, and generating new samples from the distribu-
tion. There have been several proposals for using param-
eterized quantum circuits as models for generative learn-
ing (Amin et al., 2018; Benedetti et al., 2019a, 2018), in-
cluding quantum Boltzmann machines, quantum circuit
Born machines, quantum assisted Helmholtz machines,
quantum generative adversarial networks, amongst oth-
ers (Amin et al., 2018; Benedetti et al., 2019a,b, 2018).
We discuss some of these proposals in detail hereafter.

The quantum Boltz-
Quantum Boltzmann Machines.
mann machine (Amin et al., 2018) (QBM) extends the
classical Boltzmann machine (Ackley et al., 1985), a neu-
ral architecture capable of several tasks including gener-
ative modeling of data. Such models take their name
from their physical inspiration, namely, the Boltzmann
distribution over the Ising model in the classical case,
and the Boltzmann distribution over the transverse-ﬁeld
Ising model, for the quantum case. Such a network con-
sists of a mixture of visible and hidden vertices, connected
by weighted edges. The visible vertices function as both
input and outputs to the network, whilst the hidden ver-
tices add extra degrees of freedom to the network.

The QBM can be modeled with the Hamiltonian

in NISQ devices based on the eigenstate thermalization
hypothesis has been proposed.

50

H = −

N
∑
a

(ba ˆσa

z + Γa ˆσa

x) − ∑
a,b

ωab ˆσa

z ˆσb
z,

(101)

where ba, Γa, and ωab are the parameters to be ﬁne-
tuned to generate the training data. Deﬁning the den-
sity matrix ρ = e−H
with Z the usual partition function,
Z
Z = Tr (e−H ), the marginal probability that the visible
variables are in some state v is given by Pv = Tr (Λvρ),
with Λv = (⊗ν
) ⊗ Ih, a projector onto the sub-
space spanned by the visible variables tensor the identity
acting on the hidden variables. The objective of training
the QBM, then, is to get the family of probability dis-
tributions Pv to match the family inherent to the data,
, for arbitrary v. This is achieved by minimizing
P data
v
the negative log-likelihood measure shown below

1+vν ˆσν
2

z

L = − ∑
v

P data
v

log

TrΛve−H
Tre−H

.

(102)

The gradients of L with respect to the Hamiltonian pa-
rameters are diﬃcult to calculate by sampling the Boltz-
mann machine, both classically and in the quantum vari-
ant. Methodologies of approximating these gradients are
necessary to advance the deployment of QBM’s.

The QBM may be trained both to be a generator,
or a discriminator, with respect to the distribution it
is trained to mimic. Consider the joint distribution of
input and output variables x and y respectively. In the
discriminative case, the objective is to minimize nega-
tive log-likelihood with respect to Py∣x, For generative
learning, the goal is to learn the joint distribution Px,y
directly.

The implementation of the QBM designed by (Amin
et al., 2018) found that a ten qubit QBM with only visi-
ble vertices is able to learn a mixture of randomly gener-
ated Bernoulli distributions more eﬀectively than a clas-
sical Boltzmann machine, and performed better in gen-
erative applications. (Kieferová and Wiebe, 2017) found
that a QBM outperformed classical Boltzmann machines
in generative training to reproduce small Haar-random
states. Extensions to the QBM, such as the Variational
Quantum Boltzmann Machine (VQBM) (Zoufal et al.,
2020), have improved upon trainability. Using ideas sim-
ilar to (Zoufal et al., 2020), VQBM were also proposed
in (Shingu et al., 2020). In addition to its generative ca-
pacities, QBMs have shown potential in reinforcement
learning (Crawford et al., 2019a), in which they have
been shown to achieve better ﬁdelity to data distributions
than do restricted Boltzmann machines or deep Boltz-
mann machines (classical boltzman machines with layers
of hidden vertices) of similar sizes. To suit NISQ de-
vices, (Verdon et al., 2017) suggested that QBM can be
approximated using QAOA as a subroutine in (Anschuetz
and Cao, 2019), an eﬃcient method for training QBMs

Parametrized quan-
Quantum Circuit Born Machines.
tum circuits can function as generative models to sam-
ple from probability distribution. The Quantum Circuit
Born Machine (QCBM) (Benedetti et al., 2019a) outputs
bitstrings x sampled from measurements in the com-
putational basis of a quantum circuit U (θ), with the
probability of each bit string given by the Born rule
pθ(x) ∼ ∣ ⟨x∣ U (θ) ∣0⟩ ∣2. The goal is that the distribu-
tion of the QCBM matches the one from a given target
distribution.

QCBMs can prepare classical probability distributions
as well as entangled quantum states by training them to
match the probability distribution corresponding to the
desired quantum state (Benedetti et al., 2019a). In (Liu
and Wang, 2018), training of QCBMs using the gradients
of the parameterized quantum circuit was proposed using
the maximum mean discrepancy loss, which calculates
the diﬀerence of the sampled output from the quantum
circuit and the desired distribution in a kernel feature
space.

QCBMs are well suited to be run on current NISQ
hardware and can serve as benchmarks (Hamilton et al.,
2019; Leyton-Ortega et al., 2019; Zhu et al., 2019)
and have been applied to tasks such as generating im-
ages (Rudolph et al., 2020) or ﬁnancial data (Alcazar
et al., 2020; Coyle et al., 2020a). It has been shown that
QCBMs can potentially outperform classical computers
as they are able to sample from probability distributions
that are diﬃcult for classical computers (Coyle et al.,
2020b; Du et al., 2020).

Generative
Quantum Generative Adversarial Networks.
adversarial learning (Goodfellow et al., 2014) has been
one of the most recent breakthrough in machine learn-
ing, and have become very powerful tool in the machine
learning community, for image and video generation, and
materials discovery. The GAN consists of two networks,
a generator, FG(z; θg) and a discriminator, FD(x; θd) -
with parameters θg and θd respectively, playing an ad-
versarial game, which can be summarized as follows:

min
max
θg
θd
+Ez∼pz(z)

(Ex∼pdata(x)

[log(FD(x)]

(103)

[log(1 − FD(FG(z)))]

where pz(z) is a ﬁxed prior distribution, pdata(x) is the
target distribution, x is the data sampled from pdata(x),
and z is the noise sampled from pz(z). The training of
GAN is carried iteratively, until the generator produces
a distribution indistinguishable from the target distribu-
tion.

A quantum version of generative adversarial networks
(GANs) was proposed theoretically in Refs. (Dallaire-
Demers and Killoran, 2018; Lloyd and Weedbrook, 2018)
and further developed for near term quantum devices in
Refs. (Romero and Aspuru-Guzik, 2019; Situ et al., 2020;
Zeng et al., 2019), where parameterized quantum circuits
are used for adversarial learning instead of classical neu-
ral networks.

The diﬀerent adaptions of quantum GANs can be di-
vided into diﬀerent categories, based on the data and
networks used being classical and quantum (Romero and
Aspuru-Guzik, 2019). There have been diﬀerent stud-
ies with hybrid models of GANs using both classical and
quantum data, and it has been shown that the train-
ing of these networks are robust to moderate level of
noise (Anand et al., 2020b).

The training of quantum GANs has been demon-
strated experimentally on various quantum processing
units, for a variety of tasks including, quantum state esti-
mation (Hu et al., 2019), image generation (Huang et al.,
2020b,d), generating continuous distributions (Anand
et al., 2020b), learning distribution (Zoufal et al., 2019),
among others (Nakaji and Yamamoto, 2020b).

3. Reinforcement learning

The general framework of reinforcement learning (RL)
involves an agent interacting with an environment at-
tempting to maximize an underlying reward function.

The mathematics of RL can be captured using Markov
decision process (MDP) (Sutton and Barto, 2018). An
MDP is a 4-tuple (S, A, R, P ) , where S is the set of all
possible valid states; A is the set of all possible actions; R
is the reward function, i.e. a map R ∶ S×A×S → R; and P
is the transition probability, i.e. a map P ∶ S ×A → [0, 1].
Speciﬁcally, the transition probability P (˜s∣s, a) repre-
sents the probability of transition to state ˜s given the
present state is s and the action a has been taken.
The term “Markov” in MDP means that transitions are
memory-less and depend only on the current state and ac-
tion. The agents in reinforcement learning learn via trial
and error. For a successful training, a proper balance be-
tween exploration of unknown strategies and exploitation
of prior experience is required.

The training happens via agent-environment interac-
tion. At the beginning of time step t, the environment
state is st. From the set A, the agent selects an action at.
The transition probability dictates the next state of the
environment st+1 and the agent gets reward rt+1 based
on the reward function R. The agent-environment inter-
action yields a series of states and actions of the form
τ = (s1, a1, s2, a2, ⋯, sH , aH ) . The aforementioned series
is called a trajectory and the number of interactions (H)
in an episode is called horizon. Suppose the probabil-
ity of a trajectory is P (τ ) and the corresponding cumu-

51

lative reward is Rtot (τ ) . Then, the expected reward is
∑τ P (τ ) Rtot (τ ) .

By harnessing quantum mechanical phenomena such
as superposition and entanglement, one can expect to
achieve speedups in the reinforcement learning tasks
(Dong et al., 2008; Dunjko et al., 2016, 2017; Paparo
et al., 2014). The aforementioned intuition has led to
recent works towards quantum reinforcement learning
(Cornelissen, 2018; Dunjko et al., 2017)

j

j

A}

E}

We discuss the essence of quantum reinforcement lern-
ing by providing a brief synopsis of quantum agent envi-
ronment (AE) paradigm. For details, refer to (Dunjko
et al., 2017). In the AE paradigm, agent and environment
are modelled via sequences of unitary maps {E j
and
{E j
respectively. The agent and environment have ac-
cess to memory registers belonging to Hilbert spaces HA
and HE. The communication register between the agent
and the environment belongs to Hilbert space HC. The
agent maps {E j
act on HA ⊗ HC and the environment
A}
j
maps {E j
act on HE ⊗ HC. The agent and environ-
ment interact with each other by applying their maps
sequentially. The set of actions and states correspond to
orthonormal set of vectors {∣a⟩∣a ∈ A} and {∣s⟩∣s ∈ S} re-
spectively. The Hilbert space corresponding to the com-
munication register is given by HC = span (∣y⟩∣y ∈ S ∪ A) .
The classical AE paradigm corresponds to the case where
the agent and environment maps are classical.

E}
j

Quantum reinforcement learning has been studied for
algorithm such as SARSA, and Q Learning (Jerbi et al.,
2019), which are some of the elementary reinforcement
learning algorithms (Sutton and Barto, 2018).

In the set-up of variational quantum circuits, rein-
forcement learning has been explored for small input
sizes (Chen et al., 2020). This work revealed a possi-
bility of quadratic advantage in parameter space com-
plexity. Using better encoding schemes, (Lockwood and
Si, 2020b) showed the case of reinforcement learning with
variational quantum circuits for larger input sizes. In a
follow-up work, (Lockwood and Si, 2020a) demonstrated
the possibility of dealing with the relatively complicated
example of playing Atari games.

Reinforcement learning with quantum annealers has
In
also been investigated by (Crawford et al., 2016).
their framework, they explore reinforcement learning
with quantum Boltzmann machines. A detailed study
of basic reinforcement learning protocols with supercon-
ducting circuits is provided in (Lamata, 2017). Some ex-
citing proposals of reinforcement learning with trapped
ions and superconducting circuits have also been pro-
posed recently (Cárdenas-López et al., 2018). For quan-
tum eigensolvers, reinforcement learning study has been
carried out recently (Albarrán-Arriagada et al., 2020).
Reinforcement learning with optical set-up has been dis-
cussed in (Yu et al., 2019).

C. Combinatorial optimization

1. Max-Cut

52

Given a ﬁnite set of objects, say S, combinatorial op-
timization deals with ﬁnding an optimal object from the
set S. It is a sub-discipline of mathematical optimiza-
tion theory, with applications in diverse ﬁelds such as
artiﬁcial intelligence, logistics, supply chain and theoret-
ical computer science. Some typical examples of com-
binatorial optimization problems are the traveling sales-
man problem (Lenstra and Kan, 1975), job-shop schedul-
ing (Manne, 1960), max-cut (Festa et al., 2002) and
Boolean satisﬁability (Tovey, 1984).

To understand combinatorial optimization, let us con-
sider the canonical problem of Boolean satisﬁability.
Boolean variables admit two truth values, TRUE and
FALSE. These can be combined together using operators
AND or conjunction (denoted by ∧), NOT or negation
(denoted by ¬), and OR or disjunction (denoted by ∨).
These combinations are called Boolean expressions.

A Boolean expression is said to be satisﬁable if it can be
TRUE for appropriate assignment of logical values to its
constituent Boolean variables. Given a Boolean expres-
sion E, the Boolean satisﬁability problem (SAT) consist
of checking if E is satisﬁable. The well-known Cook-
Levin theorem showed that SAT is NP-complete (Arora
and Barak, 2009).

Every combinatorial optimization problem can be ex-
pressed as m clauses over n Boolean variables. A Boolean
variable is known as positive literal, while its negation is
known as a negative literal. A disjunction of literals is
known as clause or constraint. For every constraint Cα
for α ∈ {1, 2, ⋯, m} and every string z ∈ {0, 1}n , let deﬁne

Cα(z) =

⎧⎪⎪
1
⎨
⎪⎪⎩
0

if z satisﬁes Cα(z)
if z does not satisfy

.

The goal of a combinatorial optimization problem,
framed as such, is to ﬁnd a string which maximizes the
following objective function,

C(z) =

m
∑
α=1

Cα (z) ,

(104)

which counts the number of satisﬁed constraints.

Approximate optimization algorithms such as QAOA
seeks to ﬁnd a solution z (usually a bit-string) with a de-
sired approximation ratio r∗ ≤ C(z)/Cmax, where Cmax
is the maximum value of C(z). Using C(z) and compu-
tational basis vectors ∣ei⟩ ∈ C2n for i = 1, . . . , 2n, one can
construct the problem Hamiltonian as the one in Eq. (18),
and thus mapping the combinatorial optimization prob-
lem to a Hamiltonian ground state problem.

The list of the NISQ algorithms for combinatorial op-
timization discussed in the following lines are listed in
Table III.

Max-Cut is an important combinatorial optimization
problem with applications in diverse ﬁelds such as theo-
retical physics and circuit design. In theoretical physics,
the Max-Cut problem is equivalent to ﬁnding the ground
state and its energy of a spin glass Hamiltonian. Given
a graph G = (V, E) with a vertex set V and edge set E,
a cut is a partition of the elements of V into two disjoint
subsets. Given a weight function w ∶ E → R+ such that
the edge (i, j) ∈ E has weight Eij, the Max Cut problem
consist of ﬁnding a cut K ∪ ¯K = V that maximizes

∑
¯K,(i,j)∈E

wij.

i∈K,j∈

(105)

For every vertex vi ∈ V , let us associate a variable xi
which takes values ±1. Given an arbitrary cut K ∪ ¯K = V ,
let us deﬁne xi = 1 if vi ∈ K and −1 otherwise. Then, the
Max-Cut problem is equivalent to the following quadratic
program,

max ∑

wij

(vi,vj )∈E

(1 − xixj)
2

,

(106)

subject to xi ∈ {−1, +1} ∀vi ∈ V .

Considering n vertices as n qubits in the computational
basis, we can classify qubits by assigning quantum states
∣0⟩ or ∣1⟩. For the classical objective function in the opti-
mization program from Eq. (106), we can use the follow-
ing Hamiltonian as the problem Hamiltonian,

HP = ∑

(i,j)∈E

1
2

(I − ˆσi

z ⊗ ˆσj

z) ≡ ∑

Cij.

(107)

(i,j)∈E

It has been shown that it is NP-hard to achieve an
approximation ratio of r∗ ≥ 16/17 ≈ 0.9412 for Max-Cut
on all graphs (Håstad, 2001). For the QAOA with p = 1,
it has been shown that for a general graph,

⟨Cij⟩ =

+

(sin 4β sin γ)(cosdi γ + cosdj γ)

1
4

−

(sin2 β cosdi+dj −2λij γ)(1 − cosλij 2γ),

(108)

1
2
1
4

where di+1 and dj+1 denote the degrees of vertices i and j
respectively, and λij is the number of triangles containing
the edge (i, j) in the graph (Wang et al., 2018b). Here,
γ and β refer to the QAOA parameters from Eq. (20).
Analytical results for general Ising optimization problems
with p = 1 have also been found (Ozaeta et al., 2020).

In the case of unweighted 3-regular (u3R) graphs, the
above result gives the approximation ratio of 0.692, which
is consistent with the pioneering result by Farhi, Gold-
stone and Gutman (Farhi et al., 2014). In comparison,
the best classical algorithms to date give the approxima-
tion ratio of r∗ ≈ 0.8786 for general graphs (Goemans
and Williamson, 1995), and r∗ ≈ 0.9326 for u3R graphs

(Halperin et al., 2004) using semideﬁnite programming.
While QAOA for p = 1 does not outperform its classi-
cal counterparts for the Max-Cut problem, QAOA has
been found to surpass the Goemans-Williamson bound
for larger values of p (Crooks, 2018).

QAOA has also been applied to the clustering problem
(from unsupervised learning) by mapping it to Max-Cut
problem (Otterbach et al., 2017). Remarkably, it was
shown that by ﬁxing the QAOA parameters and select-
ing the typical problem instances from a reasonable dis-
tribution, the objective function value concentrates, i.e.
the objective function value is almost independent on the
instance (Brandao et al., 2018). This implies that the pa-
rameters optimized for one instance can be used for other
typical instances, which would drastically reduce the op-
timization cost. Similar concentration behavior was also
reported for the Sherrington-Kirkpatrick model in the in-
ﬁnite size limit (n → ∞) (Farhi et al., 2019).

(i,j)

zσj

z = sign(Mnm)σn
z

Recently, a non-local version of QAOA called recursive
QAOA (RQAOA) was proposed (Bravyi et al., 2019). It
consist of running a QAOA as a subroutine on a speciﬁc
problem with N qubits and measuring the expectation
values of the correlations between the all qubit pairs (i, j)
z⟩. Then, one picks out the pair of qubits
with Mij = ⟨σi
(n, m) that have maximal absolute value of correlation
n, m = arg max
∣Mij∣. For Mnm > 0, the selected qubit
pair (n, m) are positively correlated and very likely to be
in the same state, whereas for Mnm < 0 they are anti-
correlated and likely to be in opposite state. Now, this
correlation is ﬁxed as a constraint on the problem by
ﬁxing the state of the qubit σm
. With
this constraint, one of the two qubits can be removed as
its state is completely determined by the other, reducing
the total qubit number by one. Now, the above proce-
dure is repeated for the now reduced problem of size N −1
qubits, i.e. one runs the QAOA subroutine, measures the
correlations and ﬁxes the qubit pairs with maximal cor-
relation. The RQAOA algorithm is run recursively until
the size of the problem is reduced to a small number of
qubits such that it can be solved easily classically. When
RQAOA is run with the QAOA subroutine of depth p = 1,
it can eﬃciently simulated on a classical computer, which
can serve as an important benchmark with classical al-
gorithms (Bravyi et al., 2019). Numerical experiments
with higher p suggest similar or better performance on
combinatorial problems compared to other classical algo-
rithms (Bravyi et al., 2020b; Egger et al., 2020b).

Finally, QAOA with depth p = 1 has been investigated
in comparison with quantum annealing (Streif and Leib,
2020). QAOA is connected to quantum annealing in
the sense that in the limit of inﬁnite depth p, QAOA
is equivalent to quantum annealing (refer to Sec. II.B.1
for QAOA, as well as Sec. III.A for quantum annealing).
However, QAOA can outperform quantum annealing on
speciﬁc problems even at depth p = 1.
In fact, QAOA
can solve speciﬁc problems perfectly for p = 1, arriving at

53

the correct solution with unit probability, whereas quan-
tum annealing struggles here to ﬁnd the solution (Streif
and Leib, 2020). This shows that QAOA is strictly more
powerful than quantum annealing.

2. Other combinatorial optimization problems

While the usage of QAOA on Max-Cut has been stud-
ied extensively, QAOA has also applications in other
important combinatorial optimization problems such as
Max-k Vertex Cover, which seeks to ﬁnd the set of k
vertices on a graph that maximizes the number of edges
incident on the vertices (Cook et al., 2019); Exact-cover
problem (given a set X and several subsets Si, ﬁnd the
combination of subsets which contains all elements just
once) with applications to the tail-assignment problem
(Bengtsson et al., 2020; Vikstål et al., 2020);
lattice
protein folding (Fingerhuth et al., 2018; Robert et al.,
2021); knapsack problem as applied to battery revenue
optimization (de la Grand’rive and Hullo, 2019); multi-
coloring graph problems (Oh et al., 2019); maximum
independent set problems (Choi et al., 2020; Saleem,
2020) with applications to scheduling; and the vehicle
routing problem (Utkarsh et al., 2020). An adiabati-
cally assisted approach was suggested in (Garcia-Saez
and Latorre, 2018) to tackle combinatorial optimization
problems.
Investigations involving variational Grover
search could be helpful to solve combinatorial optimiza-
tion problems (Morales et al., 2018; Zhang et al., 2021a).
Gaussian Boson Sampling (see Sec. III.B) has been used
to assist in a wide variety of combinatorial optimization
problems (Arrazola et al., 2018; Bromley et al., 2020),
most prominently to solve Max-Clique (Arrazola and
Bromley, 2018; Banchi et al., 2020b). This has appli-
cations in predicting molecular docking conﬁgurations
(Banchi et al., 2020a), computing vibrational spectra of
molecules (Huh et al., 2015), and electron-transfer reac-
tions (Jahangiri et al., 2020a). Using NISQ devices, an
approach was suggested in (Metwalli et al., 2020) for the
triangle ﬁnding problem and its k-clique generalization.

Quantum Annealing, which has been the inspiration of
QAOA, is a prominent platform that has been applied to
various combinatorial optimization problems and its ap-
plications, such as protein folding (Perdomo-Ortiz et al.,
2012), reviewed in (Hauke et al., 2020). As gate-based
devices mature, it will open the possibility for experi-
mental benchmarking of QAOA against state-of-the- art
solvers for suitable real-world applications, as performed
in (Perdomo-Ortiz et al., 2019) in the context of quan-
tum annealing machines and including proposals beyond
the capabilities of current D-wave devices.

D. Numerical solvers

We proceed to discuss NISQ algorithms used to solve
numerical problems such as factoring, singular value de-
composition, linear equations and non-linear diﬀerential
equations, all of them listed in Table IV.

1. Variational quantum factoring

The factoring problem accepts a composite positive in-
teger N as input and returns its prime factors as output.
There is no known eﬃcient classical algorithm for prime
factorization and the hardness of factoring is used to pro-
vide the security in the RSA public-key cryptosystems.
The famous Shor’s factoring algorithm is a polynomial
time quantum algorithm for the factoring problem (Shor,
1999) (implying prime factorization is in BQP) and hence
has been extensively investigated by quantum computing
researchers (for details refer to (Anschuetz et al., 2019)
and references therein). The resource estimates for im-
plementing the Shor’s algorithm is, however, way beyond
the capabilities of the NISQ era. A detailed analysis has
shown that factoring a 2048-bit RSA number would ne-
cessitate a quantum processor with 105 logical qubits and
circuit depth on the order of 109 to run for roughly 10
days (Jones et al., 2012; Van Meter et al., 2010). On
a photonic architecture, using 1.9 billion photonic mod-
ules, factoring a 1024-bit RSA number is expected to tale
around 2.3 years (Devitt et al., 2013). To tackle the fac-
toring problem in the near-term quantum devices, it is
imperative to develop NISQ-era compatible alternatives
to Shor’s factoring algorithm.

The factoring problem can be mapped to the ground
state problem of an Ising Hamiltonian (Burges, 2002;
Dattani and Bryans, 2014). To understand the afore-
said mapping, let us consider the factoring of m = p × q.
Suppose the binary representations of m, p and q are
m = ∑nm−1
k=0 2iqk.
Here, mk ∈ {0, 1}is the kth bit of m and the total number
of bits for m has been denoted by nm. Similar notation
has been employed for p and q. Since m = p × q, it induces
nc = np + nq − 1 constraints on the individual bits of m, p
and q,

k=0 2ipk and q = ∑nq−1

k=0 2imk, p = ∑np−1

i
∑
j=0

qipi−j +

i
∑
j=0

zj,i − mi −

nc
∑
j=1

2jzi,i+j = 0 ,

(109)

for i ∈ [0, nc) and the carry bit from position i to posi-
tion j has been represented by zi,j. The constraint i in
Eq. (109) induces clause Ci ≡ ∑i
j=0 zj,i − mi −
∑nc
j=1 2jzi,i+j over Z such that factoring can be modelled
as assignment of binary variables {mi} , {pi} and {qi}
which solves ∑nc−1

j=0 qipi−j + ∑i

One can map the binary variables to quantum ob-
servables to quantize the clause Ci to ˆCi using the

i=0 C 2

i = 0.

54

(1 − σz

b,k) and obtain the Hamiltonian
mapping bk → 1
2
2, which we refer as factoring Hamilto-
ˆCi
HP = ∑nc−1
i=0
nian. Note that the factoring Hamiltonian is a 4-local
Ising Hamiltonian.

By using the aforementioned ideas, one can use NISQ
algorithms for the ground state problem to tackle the
factoring problem (see Sec. VI.A.3 and Sec. VI.C). In
Ref. (Anschuetz et al., 2019), authors employ QAOA to
ﬁnd the ground state of the factoring Hamiltonian and
refer to their Algorithm as variational quantum factor-
ing (VQF) algorithm. Numerical simulations were pro-
vided for numbers as high as 291311. For a recent exper-
imental realization and detailed analysis of VQF, refer to
(Karamlou et al., 2020).

2. Singular value decomposition

+

Given a matrix M ∈ Cm×n, the Singular Value De-
composition (SVD) provides a factorization of the form
M = U ΣV †, where U ∈ Cm×m is a unitary matrix,
is a rectangular diagonal matrix with non-
Σ ∈ Rm×n
negative real diagonal entries and V ∈ Cn×n is a unitary
matrix. The diagonal entries of Σ are called the singular
values of matrix M. The columns of the unitary matri-
ces U and V are called left-singular and right-singular
vectors of M. Using Dirac notation, one can write

M =

r
∑
j=1

dj∣uj⟩⟨vj∣.

(110)

where dj, ∣uj⟩, ∣vj⟩ are singular values, left-singular vec-
tors and right-singular vectors. The rank of matrix M is
r and is equal to the number of non-zero singular values.
SVD ﬁnds applications in calculating pseudoinverse
(Gregorcic, 2001), solving homogeneous linear equations
(Klema and Laub, 1980), signal processing (Vandewalle
and De Moor, 1991) and recommendation systems (Ko-
ren et al., 2009). Moreover, the notion of Schmidt decom-
position which is used to study entanglement of bipartite
quantum states, is related to SVD.

In the quantum information context, the SVD can be
used to compute the Schmidt decomposition of bipartite
quantum states. For a quantum state ∣ψ⟩ ∈ HA ⊗ HB, the
Schmidt decomposition is given by

∣ψ⟩ = ∑
i

di∣ui⟩∣vi⟩,

(111)

where di are non-negative real numbers such that ∑i d2
i =
1. Moreover, {∣ui⟩}i
correspond to orthonor-
and {∣vi⟩}i
mal basis sets for HA and HB respectively. The number
of non-zero di, say χ, is called the Schmidt rank of the
quantum state ∣ψ⟩ and is used to quantify the bipartite
entanglement. To calculate the Schmidt decomposition,
one can write the bipartite quantum state as a matrix

∣ψ⟩ = ∑i,j Aij∣i⟩∣j⟩,where ∣i⟩ and ∣j⟩ are the computa-
tional basis states of each qubit, and perform SVD of
the matrix A.

Ref. (Bravo-Prieto et al., 2020a) provide a NISQ al-
gorithm to perform SVD of pure bipartite states. Start-
ing with two unitary circuits, which act on diﬀerent bi-
partitions of the system, the authors variationally deter-
mine the singular values and singular vectors by training
the circuits on exact coincidence of outputs. The cen-
tral ideas of their method is to variationally ﬁnd circuits
that provides the following transformation of the initial
quantum state ∣ψ⟩AB with Schmidt rank χ,

(112)

UA ⊗ VB∣ψ⟩AB =

λieiγi∣ei⟩A∣ei⟩B,

χ
∑
i=1
where UA∣vi⟩A = eiαi∣ei⟩A, VB∣vi⟩B = eiβi∣ei⟩B such that
αi = βi + γi ∈ [0, 2π) and {∣ek⟩A,B}k
are the compuational
basis states in HA,B. Using their algorithm, authors also
suggest the possibility to implement SWAP gate between
parties A and B without the requirement of any gate
connecting the two subsystems.

Using variational principles for singular values and Ky
Fan theorem (Fan, 1951), (Wang et al., 2020c) provide
an alternative NISQ algorithm for SVD. The authors pro-
vide proof of principle application of their algorithm in
image compression of handwritten digits. They also dis-
cuss the applications of their algorithm in recommenda-
tion systems and polar decomposition.

3. Linear system problem

Systems of linear equations play a crucial role in var-
ious areas of science, engineering and ﬁnance. Given a
matrix A ∈ CN ×M and b ∈ CN , the task of the linear
system problem (LSP) consists of ﬁnding x ∈ CM such
that

Ax = b .

(113)

Depending on the dimensions M and N , the LSP takes
various forms. If M = N and A is invertible, x = A−1b is
unique. If M ≠ N, the LSP can be under-determined or
over-determined. For the sake of simplicity, it is natural
to assume the matrix A to be square i.e. M = N. If the
matrix A has at most s non-zero elements per row or
column, the LSP is called s-sparse.

The quantum version of the LSP, known as the quan-
tum linear system problem (QLSP), assumes A to be
N × N Hermitian matrix and b to be a unit vector, i.e.
it can be represented as a quantum state ∣b⟩ = ∑N
i=1 bi∣ei⟩.
The QLSP problem thus is formulated as

A ∣x⟩ = ∣b⟩ → ∣x⟩ = A†∣b⟩.

(114)

The ﬁrst quantum algorithm proposed for solving the
QLSP was the famous Harrow-Hassidim-Lloyd (HHL) al-
gorithm (Harrow et al., 2009). Apart from the size of the

55

matrix A, i.e. N , and its sparsity s, two other dominant
factors determining the running time of a LSP or QLSP
algorithm are the condition number (κ) of the matrix A
and the additive error ((cid:15)) corresponding to the solution.
The condition number of a matrix A is given by ratio of
maximal and minimal singular values of A. The best clas-
sical algorithm for LSP is the conjugate gradient method
)) . On the other
with runtime complexity O (N sκ log ( 1
(cid:15)
hand, the HHL algorithm for QLSP, as originally pro-
posed, has runtime complexity O (log (N ) s2 κ2
) . Fur-
(cid:15)
ther works on the HHL algorithm has improved κ scal-
ing to linear (Ambainis, 2012) and error dependence to
Implementation of
poly (log ( 1
(cid:15)
HHL algorithm, however, requires the fault-tolerant ar-
chitecture and hence its guarantees can not be leveraged
on the NISQ architecture. The largest QLSP solved on
a gate based quantum computer corresponds to its im-
plementation on an nuclear magnetic resonance (NMR)
processor for N = 8 (Wen et al., 2019).

)) (Childs et al., 2017).

Recently, a few VQA based implementations of the
QLSP were proposed (Bravo-Prieto et al., 2019; Huang
et al., 2019; Xu et al., 2019b). Given a QLSP with in-
put A and ∣b⟩, the idea is to ﬁnd the ground state of the
following Hamiltonian,

H(u) = A(u)P ⊥

+,bA(u),

where A(u) and P ⊥
+,b

are deﬁned as

A(u) ≡ (1 − u) σz ⊗ I + u σx ⊗ A,
+,b = I − ∣+, b⟩⟨b, +∣.
P ⊥

(115)

(116)

(117)

Both A and ∣b⟩ are assumed to be constructed eﬃciently
with a quantum circuit, i.e. A = ∑KA
k=1 βkUk and ∣b⟩ =
Ub∣0⟩, with KA = O (poly (log N )). The phase in βk can
be absorbed in Uk and hence one can assume βk > 0.

∣+⟩∣x⋆⟩ = ∣+⟩ A−1

The Hamiltonian in Eq. (115) for u = 1, has a unique
, with zero ground
ground state,
state energy. After removing the ancilla, the ground state
can be seen to be proportional to A−1∣b⟩. Thus, one can
deﬁne the following loss function,

∥A−1∣b⟩∥2

∣b⟩

LH (∣x⟩) = ⟨+, x∣H(1)∣+, x⟩.

(118)

Without the ancilla, the above loss function can be writ-
ten as LH (∣x⟩) = ⟨x∣A2∣x⟩ − ⟨x∣A∣b⟩⟨b∣A∣x⟩.

In (Huang et al., 2019), authors analyze the optimiza-
tion landscape for VQA based optimization for the loss
function of Eq. (118) and show the presence of bar-
ren plateaus which persist independent of the archi-
tecture of the quantum circuit for generating ∣x (θ)⟩.
Even techniques based on adiabatic morphing (Garcia-
Saez and Latorre, 2018) fail to evade the eﬀect of the
barren plateaus. To circumvent the barren plateau
problem,
(Huang et al., 2019) proposed a classical-
quantum hybrid state (see also Sec. III.E and Eq. (42))

x = ∑r
for
i=1 αi∣ψi (θi)⟩, where αi ∈ C and θi ∈ Rki
i ∈ {1, 2, ⋯, r} . Note that θi are the usual variational pa-
rameters and αi are the combination parameters. These
parameters are stored on a classical device and the state
x is not explicitly created on a quantum processor. More-
over, x may not be normalized. To solve the QLSP, one
minimizes the following loss function,
LR (x) = ∥Ax − ∣b⟩∥2
2 = x†A†Ax − 2Re {⟨b∣Ax} + 1. (119)
Since optimization with respect to θi suﬀers from the
barren plateau problem, one can ﬁx and subsequently
drops the variational parameter θi.

The optimization landscape is convex in α =
(α1, α2, ⋯, αr) . Starting from ∣ψ1⟩ = ∣b⟩, other quantum
states can be generated using the Ansatz tree approach
in (Huang et al., 2019).
It was proved that ﬁnding
the combination parameters of ∣ψ1⟩, ∣ψ2⟩, ⋯, ∣ψr⟩ to mini-
mize LR (∑r
i=1 αi∣ψi⟩) is BQP complete. Moreover, using
) measurements, one can ﬁnd (cid:15)-suboptimal so-
O (K 2
A
lution. With this approach, linear systems as high as
2300 × 2300 can be solved by considering cases which are
also classically tractable.

r2
(cid:15)

4. Non-linear diﬀerential equations

Nonlinear diﬀerential equations (NLDE) are a system
of diﬀerential equations (DE) that cannot be expressed
as a linear system. The numerical approaches to tackle
DE can be local or global. Local methods employ nu-
merical diﬀerentiation techniques (Butcher, 1987) such
as the Runge-Kutta or discretization of the space of vari-
ables. Global methods, on the other hand, represent the
solution via a suitable basis set, and the goal remains
to ﬁnd optimal coeﬃcients (Gottlieb and Orszag, 1977).
In many cases, as the number of variables or nonlinear-
ity in the diﬀerential equations increase, ﬁnding solutions
becomes challenging. To achieve higher accuracy, local
methods require a ﬁne grid, which renders high compu-
tational cost. In the case of global methods, high accu-
racy necessitates a large number of elements in the basis
set, leading to more extensive resource requirements. To
tackle resource challenges, quantum algorithms are pro-
posed.

Linear DE can be re-expressed as a system of linear
equations using the ﬁnite diﬀerence method, and one can
employ NISQ linear system algorithms to tackle the prob-
lem (see Sec. VI.D.3). For a recent theoretical proposal
with experimental work on linear diﬀerential equations,
refer to (Xin et al., 2020). However NLDE defy this
approach for large nonlinearities.

A canonical example of a NLDE appearing in quan-
tum theory is the 1-D nonlinear Schrödinger equation
d2
dx2 + V (x) + g ∣f (x)∣2] f (x) = Ef (x). Here, E de-
[− 1
2
notes energy, g quantiﬁes nonlinearity, and V is the ex-
ternal potential. Recently, NISQ algorithms for NLDE

56

have been proposed. Ref. (Lubasch et al., 2020) use an-
cillary quantum registers and controlled-multiqubit op-
erations to implement nonlinearities to simulate the non-
linear Schrodinger equation. Ref. (Haug and Bharti,
2020) propose the nonlinear quantum assisted simulator
(NLQAS) to tackle NLDE without any controlled uni-
taries. Using NLQAS, they simulate this equation for 8
qubit system. NLDE have also been studied in (Gaitan,
2020) for ﬂuid dynamics problems. Using diﬀerentiable
quantum circuits, (Kyriienko et al., 2020) have also pro-
posed an interesting approach to solving NLDE via global
methods.

E. Other applications

In this subsection, we cover other applications for
which NISQ algorithms can provide promising improve-
ments. They are listed in Table VI.

1. Quantum foundations

One of the ﬁrst experiments in digital quantum com-
puters were the Bell nonlocality tests known as Bell in-
equalities (Brunner et al., 2014). Those experiments
computed a type of Bell inequalities known as Mermin in-
equalities in up to ﬁve superconducting quantum qubits.
The experiment consisted in preparing the GHZ state
(Greenberger et al., 1990), measure it in a particular ba-
sis state and obtain the expectation value of the Mermin
operator (Alsina and Latorre, 2016). These nonlocality
tests can be extended to higher dimensions by control-
ling quantum levels beyond the ∣0⟩ and ∣1⟩. As example,
(Cervera-Lierta et al., 2021b) experimentally generate a
qutrit GHZ state using a programmable device controlled
with Qiskit Pulse software (Alexander et al., 2020), the
ﬁrst step towards performing a GHZ test.

In the context of VQA, the non-classicality in VQEs is
examined using contextuality, which is a nonclassical fea-
ture of quantum theory (Amaral and Cunha, 2018). Us-
ing the notion of “strong contextuality”, (Kirby and Love,
2019) categorized VQE experiments into two categories:
contextual and non-contextual. Such foundational works
could be utilized to comprehend the possible sources of
quantum advantage in NISQ algorithms. Using novel
concepts from this ﬁeld, contextual subspace VQE (CS-
VQE) was recently proposed (Kirby et al., 2020).

In another work, the variational consistent history
(VCH) algorithm was suggested to investigate founda-
tional questions (Arrasmith et al., 2019). The consis-
tent history approach has been used to examine topics
from quantum cosmology and quantum-classical transi-
tion. In the VCH algorithm, the quantum computer is
used to compute the “decoherence functional”, which is
challenging to calculate classically. The classical com-

puter is employed to tune the history parameter so that
the consistency is improved.

2. Quantum optimal control

Quantum optimal control is a topic of paramount im-
portance in the pursuit to harness the potential of Near-
Term quantum devices. For a given quantum control
system and a cost function that measures the quality of
control, it aims to ﬁnd a control that can achieve optimal
performance.

Some recent works have investigated quantum optimal
control in the NISQ framework. Recent detailed perspec-
tive in this direction can be found in Ref. (Magann et al.,
2021). Ref. (Li et al., 2017a) provides a hybrid quantum-
classical approach to quantum optimal control. To rem-
edy some of the diﬃculties of classical approaches to op-
timal control related to scaling of resources, (Dive et al.,
2018) proposed another NISQ framework. Experimental
demonstration of quantum control for a 12-qubit system
has also been carried on (Lu et al., 2017). The aforemen-
tioned approaches, however, restrict their target states to
be sparse matrices. For dense target states, (Policharla
and Vinjanampathy, 2020) recently proposed a NISQ
algorithm. Along with their algorithm, they also sug-
gested a few algorithmic primitives to calculate overlap of
quantum states and transition matrix elements. Hybrid
quantum-classical algorithm have also been implemneted
for computing quantum optimal control pulses, in partic-
ular for controlling molecular systems (Castaldo et al.,
2020; Magann et al., 2020).

3. Quantum metrology

Quantum metrology harnesses non-classical features
of quantum theory for parameter estimation tasks. A
canonical example could be estimating the parameter φ
of a unitary map under the action of Hamiltonian ˆH,
given by ˆρ (φ) = e−i ˆHφ ˆρ0e+i ˆHφwhere the density matrix
ˆρ0 refers to the initial state of the system. The goal is
to estimate φ via measurements on ˆρ(φ). The quantum
Cramér-Rao bound provides a lower bound to the achiev-
able precision,

(∆φ)2 ≥

1
nFQ (ˆρ (φ))

.

(120)

Here, n represents number of samples, FQ (ˆρ (φ)) is quan-
tum Fisher information and (∆φ)2 is the variance in the
estimation of φ. In most of the experiments, the param-
eter of interest is either temperature or magnetic ﬁeld.

Notice that the precision of the estimation procedure
increases as the quantum Fisher information increases.
Using it as a cost function, a few works have recently
explored quantum metrology to prepare a better probe

57

state in a VQA set-up (Beckey et al., 2020; Kaubruegger
et al., 2019; Koczor et al., 2020; Ma et al., 2020). In ad-
dition, (Meyer et al., 2020) provided a toolbox for multi-
parameter estimation and (Haug and Kim, 2021a) the
natural PQC with the lowest possible quantum Cramér-
Rao bound for a general class of circuits.

4. Fidelity estimation

In Sec. II.A, we discussed how to use the ﬁdelity as
an objective function, a quantity which is useful to train
some VQA algorithms.
In addition, estimating the ﬁ-
delity of a quantum state with respect to another state
has a general interest in the context of quantum comput-
ing. For this reason, algorithms that can estimate this
property may become useful in the NISQ era.

Given the density matrices of two quantum states ρ1

and ρ2, their ﬁdelity is given by
√√

F (ρ1, ρ2) = (Tr

√

2

.

ρ1)

ρ1ρ2

(121)

Due to the large dimensionality of the Hilbert spaces,
computing ﬁdelity can be challenging.

Recently, variational quantum ﬁdelity estimation
(VQFE) algorithm was proposed to tackle slightly modi-
ﬁed version of the ﬁdelity estimation task which works ef-
ﬁciently when ρ1 has low-rank. Ref. (Cerezo et al., 2020a)
provide lower and upper bounds on F (ρ1, ρ2) via VQFE.
The algorithm calculate ﬁdelity between ρn
, which is a
1
truncated version of ρ1 obtained by projecting ρ1 to sub-
space spanned by n largest eigenvalue eigenvectors of ρ1.
The bounds improve monotonically with n and is exact
for n = rank (ρ1) . The VQFE algorithm proceeds in three
steps: i) a variational diagonalization of ρ1; ii) the ma-
trix elements of ρ2 are computed in the eigenbasis of ρ1;
and iii) using the matrix elements from ii), the ﬁdelity
is estimated.

5. Quantum error correction

The leading error correction schemes carry high re-
source overheads, which renders them impractical for
near-term devices (Fowler et al., 2012; Johnson et al.,
2017). Moreover, many of the schemes mandate knowl-
edge of the underlying noise model (Fletcher et al., 2008;
Kosut and Lidar, 2009; Kosut et al., 2008). For an en-
coding process E, decoding process D and noise model
N , the quality of a quantum error correction scheme can
be characterized by how close D◦N ◦E is close to identity.
The range of E is called code space C.

In (Johnson et al., 2017), a variational error-correcting
scheme i.e, quantum variational error corrector (QVEC-
TOR) was proposed by deﬁning an objective function
over the code space C. The authors employ two trainable

parametric quantum circuits V (p) and W (q) for encod-
ing and decoding respectively, with tunable parameter
vectors p and q. For a given encoding-decoding pair,
characterized by (p, q) , the authors calculate a quantity
called “average code ﬁdelity” with respect to Haar dis-
tribution of states over the code space C. The algorithm
is model-free, i.e. no assumption of the noise model is
involved. The goal of the QVECTOR algorithm is to
maximize average code ﬁdelity in a variational set-up.

In the context of VQA, error correction has also been
explored in (Xu et al., 2019b) where the target logi-
cal states are encoded as ground state of appropriate
Hamiltonian. (Xu et al., 2019b) employ imaginary time
evolution to ﬁnd the ground state. The authors imple-
ment there scheme for ﬁve and seven qubit codes. For a
brief discussion on error correction and quantum fault-
tolerance, refer to Sec. VIII.B.

6. Nuclear physics

The Standard Model of particle physics is the theory
that describes the nature of the electromagnetic and nu-
clear interactions. Its current formulation consist of de-
scribing the forces as quantum ﬁelds, i.e. by using quan-
tum ﬁeld theory (QFT) formalism. Perturbative calcu-
lations of QFT provide with the dynamics of the physi-
cal processes at a given energy scale. However, in some
cases as in quantum chromodynamics (QCD), perturba-
tion theory can not be applied because the impossibility
of observe a free quark or gluon (the fundamental par-
ticles aﬀected by QCD interaction) due to conﬁnement.
For this reason, QCD calculations are obtained by means
of numerical methods such as Monte Carlo simulations
in a discretized version of QFT on a lattice structure
(LQFT). The high computational cost of LQFT has mo-
tivated the study of using quantum computation or sim-
ulation to obtain the desired QCD predictions (Joó et al.,
2019).

The Schwinger model describes the dynamics of the
quantum electromagnetic (QED) interaction in one spa-
tial and temporal dimensions. It is used as a toy model to
study QCD since it shows fermion conﬁnement but it is
simple enough to be solved analytically. The ﬁrst exper-
imental quantum simulations of this model were carried
out in trapped ions (Hauke et al., 2013) and later on
a superconducting circuit quantum computer (Martinez
et al., 2016). A ﬁrst proposal to use a quantum-classical
algorithm to simulate this model was presented in (Klco
et al., 2018), where the quantum computer simulates the
dynamics of the symmetry sectors suggested by a clas-
sical computation. In Ref. (Kokail et al., 2019) a VQS
is used in an analog setup to reduce the number of vari-
ational parameters and thus, reduce the computational
cost of the algorithm. Their proposal is experimentally
implemented in a trapped-ion analog simulator. A sig-

58

niﬁcant reduction of the computational cost of LQFT is
proposed in (Avkhadiev et al., 2020) by using a VQA ap-
proach to compute the optimized interpolating operators
(approximators of the quantum state wavefunction).

Adaptations of the UCC quantum chemistry ansatz,
introduced in Sec. II.B.1, to study quantum-variationally
QCD are presented in (Dumitrescu et al., 2018; Liu and
Xin, 2020), and for the study neutrino-nucleus scattering
in (Roggero et al., 2020). A 10-qubit VQC is used in (Wu
et al., 2020) to study Higgs boson decays and production
processes and in (Chen et al., 2020c) a QCNN model is
proposed to study basic high-energy processes. Recently,
a PQC is used to learn the parton distribution function
of protons (Pérez-Salinas et al., 2020b).

7. Entanglement properties

Entanglement is a resource for numerous quantum
information tasks. A bipartite quantum state ρAB ∈
HA ⊗ HB is called separable if it admits the form ρAB =
, where pi are non-negative and ∑i pi = 1.
∑i piρA
If a state is not separable, then it is called entangled.
The problem of detecting whether a state is separable or
entangled is known as the separability problem and has
been shown to be NP-hard (Gurvits, 2003).

i ⊗ ρB
i

As mentioned in Sec. VI.D.2, computing the Schmidt
rank of ρAB gives a measure of the bipartite entangle-
ment. Thus, those algorithms that tackle the SVD prob-
lem can also be used to extract entanglement proper-
ties (Bravo-Prieto et al., 2020a). In (Wang et al., 2020a),
authors propose a NISQ algorithm for the separability
problem by providing a variational approach to employ
the positive map criterion. This criterion establishes that
the quantum state ρAB is separable if and only if for ar-
bitrary quantum system R and arbitrary positive map
NB→R from B to R, we have NB→R (ρAB) ≥ 0. The au-
thors start with a positive map and decompose it into
a linear combination of NISQ implementable operations.
These operations are executed on the target state, and
the minimal eigenvalue of the ﬁnal state is variationally
estimated. The target state is deemed entangled if the
optimized minimal eigenvalue is negative.

Exploring a similar strategy as the one presented in
(Bravo-Prieto et al., 2020a), (Pérez-Salinas et al., 2020c)
propose a VQA to compute the tangle, a measure of
tripartite-entanglement.

VQA have also been employed for extracting the entan-
glement spectrum of quantum systems in (Cerezo et al.,
2020b; LaRose et al., 2019).

VII. BENCHMARKING

One of the central questions at the intersection of soft-
ware and hardware for NISQ devices is evaluating de-

vices’ performance and capabilities. This is where bench-
marking concepts come in, to provide various metrics
that attempt to measure diﬀerent machines’ capabilities
and compare them across time and other devices. A
benchmarking protocol can be characterized by its in-
herent assumptions, resource costs and the information
gain. The goal is to build benchmarking protocols that
make minimal and practical assumptions, have low re-
source costs, and have high information-gain.

Benchmarking protocols have been developed for NISQ
as well as fault-tolerant devices. For a pedagogical
summary, refer to (Eisert et al., 2019).
In this re-
view, we focus on quantum benchmarking protocols for
NISQ devices. Some of the leading NISQ benchmark-
ing schemes are randomized benchmarking, quantum vol-
ume, cross-entropy benchmarking and application-based
benchmarks.

A. Randomized benchmarking

The most straightforward way of comparing devices is
by simply counting qubits. To really compare diﬀerent
qubits, we must also have a sense of how many opera-
tions we can do with them before the noise arising from
errors drowns out the signal. Randomized benchmarking
(RB) is a convenient method for ﬁnding average error
rates for quantum operations, in particular for single and
two-qubit gates (Magesan et al., 2011, 2012). RB is ro-
bust against state preparation and measurement (SPAM)
errors and, unlike tomography, admits an eﬃcient and
practical implementation.

RB involves the following assumptions:

i) for every
gate, the incurred noise is independent of other Cliﬀord
gates; ii) the involved unitaries should constitute a 2-
design (see Sec. IV.A) and should not be universal. In
other words, no T gate is allowed; iii) during the exper-
iment, there is no drifting in the noise processes; and iv)
one can describe noise processes using completely posi-
tive trace-preserving (CPTP) maps.

A RB protocol starts by sampling a sequence of m
Cliﬀord gates (see Sec. V.B.1). The sequence is applied
to the initial state, followed by its inverse. Finally a
two-outcome POVM measurement is done to calculate
the ﬁdelity between initial state and the output state,
followed by classical post-processing. The RB protocol
discretizes time so that it is measured in the number of
gates and it then averages over many sequences of each
length m. More formally, a 4-step RB protocol consist of
1. Generate Km sequences of m quantum operations
with i ∈ [1, m] and j ∈ [1, Km], where i in-
Cij
dexes over the sequence of operations, and j over
the statistical samples. These operations are ran-
domly chosen from the Cliﬀord group, and a m + 1-
th operation is chosen that cancels the ﬁrst m op-
erations such that the net operation is the identity.

59

The operations can be chosen from the 2-,4- or 2n-
dimensional Cliﬀord groups, depending on whether
we are benchmarking single-, two- or n-qubit op-
erations (McKay et al., 2019). These operations
come with some error, which is modeled with lin-
ear operators Λij ,j, so that the full sequence of m
operations is given by

SKm = ◯m+1

j=1 (Λij ,j ○ Cij )

(122)

Here, ○ denotes composition and ◯ represents com-
position of the terms deﬁned with index j.

2. For each sequence we ﬁnd the ﬁdelity with the ini-
tial state by measuring Tr[EψSKm(ρ(ψ))], where
ρ(ψ) is the initial state (with preparation errors)
and Eψ is a POVM measurement operator cor-
responding to the measurement including noise.
Without noise, this would be the projector Eψ =
∣ψ⟩⟨ψ∣.

3. Average over the Km statistical samples to ﬁnd
the sequence ﬁdelity F (m, ψ) = Tr[EψSm(ρ(ψ))]
where Sm is the mean over the operations SKm

.

4. Fit the data with the function

Ff it(m, ψ) = A0pm + B0,

(123)

where we have assumed the errors are independent
of gate and time. This is not a fundamental as-
sumption, but can be relaxed (Magesan et al., 2011,
2012). The average gate error is here given by
(cid:15)RB = 1 − p − (1 − p)/2n, and the constants A0 and
B0 absorb the SPAM errors.

The operations Cij

are chosen from the Cliﬀord group,
because these are relatively easy to perform on quantum
hardware, and because the ﬁnal m + 1-th operation that
undoes the sequence can easily be pre-computed on a
classical computer. Averaging over the Cliﬀord group (or
any other ﬁnite group) also has the property that even
though the real noise-channel would be more complicated
than the purely depolarizing one, the average over the
group will still give rise to an exponential decay.

These gate errors extracted from randomized bench-
marking can be used to compare the quality of quantum
gates, and to estimate that an algorithm of depth ∼ 1/(cid:15)RB
gates can be run on the device before only statistical noise
is output. The intuition behind the RB protocol is that a
(purely) depolarizing channel will cause exponential de-
cay of an excited state over time.

Simultaneous randomized benchmarking (SRB) has
been proposed to acquire information about crosstalk
and undesired coupling between the neighbouring
qubits (Gambetta et al., 2012). RB has also been
extended for gatesets that do not form a Cliﬀord
group (Brown and Eastin, 2018; Carignan-Dugas et al.,

2015; Cross et al., 2016; França and Hashagen, 2018;
Gambetta et al., 2012; Harper and Flammia, 2017;
Hashagen et al., 2018). In such cases, the expression for
Ff it(m, ψ) does not follow equation Eq. (123) (Helsen
et al., 2019). Employing concepts from representation
theory, an extension of RB has been proposed to extract
the ﬁdelity for a broad category of gatesets, including T-
gate (Helsen et al., 2019). A practically scalable protocol
called cycle benchmarking was developed lately to char-
acterize local and global errors for multi-qubit quantum
computers (Erhard et al., 2019).

B. Quantum volume

To further reﬁne the concept of the computational
power of a quantum computer from just qubit count
and gate-errors, the IBM Quantum team introduced the
“quantum volume” (Cross et al., 2019; Moll et al., 2018).
It is one of the widely accepted metrics for benchmarking
NISQ-era quantum computers. As mentioned earlier, one
can not rank quantum computers based on the number of
qubits alone. Quantum volume gives a rough estimate of
the number of eﬀective qubits a quantum computer has
based on their performance on the “heavy output gener-
ation problem”. The heavy output generation problem
is related to the random circuit sampling task used in
Google’s quantum supremacy experiment. Quantum vol-
ume treats the depth and width of a quantum circuit at
the equal footing. Hence, its estimation depends on the
largest square-sized circuit, which can successfully imple-
ment the heavy output generation problem. The quan-
tum computer’s performance also depends on its software
stack, for example, compiler, and thus quantum volume
can increase with the improvements in the software stack.
The quantum volume benchmark can be thought anal-
ogous to the classical LINPACK benchmark (Dongarra,
1987). Like the LINPACK benchmark, it is architecture-
agnostic and provides a single real number metric based
on the quantum computer’s performance for a model
problem, i.e., heavy output generation problem.

More formally, quantum volume can be deﬁned in the
following terms. Given an n qubit quantum computer
with the largest achievable model circuit depth d(m) for
model circuit width m ∈ {1, 2, ⋯, n} such that the proba-
bility of observing a heavy output for a random selection
of model circuit is strictly greater than 2/3, the quantum
volume VQ is deﬁned as (Cross et al., 2019)

60

The model circuit with depth d and width m for esti-
mating quantum volume is given by d-layered sequence
U = U (d)U (d−1)⋯U (1) where layer t consists of random
permutations πt ∈ Sm applied to qubit labels, followed by
the tensor product of Haar-random two-qubit unitaries
from SU (4). If the model circuit width m is odd, one of
the qubits is left idle in every layer. See Figure 7 for a
pictorial description.

Figure 7 Model circuit for the quantum volume benchmark.
Each layer consists of random permutations of qubit labels,
followed by application of two-qubit haar-random unitaries.
Inspired by (Cross et al., 2019).

the

Given a model circuit U with width m, the ideal out-
put distribution over bit strings x ∈ {0, 1}m is given
byPU (x) = ∣⟨x∣U ∣0⟩∣2.

set Pis given by pmed

One can arrange the probabilities for various bitstrings
in ascending order in a set P = {p0 ≤ p ≤ ⋯ ≤ p2m−1} .
The median of
=
p2m−1 +p2m−1−1
. The Heavy outputs are deﬁned as HU =
2
{x ∈ {0, 1}m ∣pU (x) > pmed} . The goal of the heavy out-
put problem is to sample a set of strings such that at least
2/3 are heavy output. For an ideal quantum circuit, the
expected heavy output probability asymoptotically tends
to ∼ 0.85. For a completely depolarized device, it is ∼ 0.5.
On the target system, one implements ˜U by using
a circuit compiler with native gate set such that 1 −
Favg (U, ˜U ) ≤ (cid:15) ≤ 1 for some approximation error (cid:15), where
Favg is average gate ﬁdelity, as deﬁned in Ref. (Horodecki
et al., 1999). The role of circuit compiler is crucial in the
aforementioned step. Suppose the observed distribution
for the implemented circuit ˜U of the model circuit U is
gu(x). The probability of sampling heavy output is given
by

hU = ∑
x∈HU

qU (x) .

(125)

log2 VQ = argmax

m

min (m, d(m)) .

(124)

For a randomly selected circuit of depth d, the probability
of sampling a heavy output is given by

Intuitively speaking, quantum volume estimates the
largest square random quantum circuit which the quan-
tum computer can successfully implement the so-called
heavy output generation problem. To conclude the dis-
cussion, it remains to describe the “model circuit” and
the “heavy output generation problem”.

hd = ∫

U

hU dU.

(126)

The term d(m) in Eq. (124) is equal to the largest depth
d for model circuit of width m ∈ {1, 2, ⋯, n} such that
hd > 2
3 .

Layer 1Layer 2Layer dIt, hence,

The quantum volume benchmark requires simulation
of the model circuit’s heavy output generation problem
is not a scalable
on a classical computer.
method as the quantum volume increases. Moreover,
the special treatment for square circuits is not entirely
justiﬁed. Investigations are needed to devise other inter-
esting benchmarks. A benchmark for rectangular circuits
has also been proposed in the literature (Blume-Kohout
and Young, 2020).

At the time of writing, Honeywell’s system model
H1 has achieved log2 VQ = 9 (Honeywell, 2021), and
IBM quantum device named “IBM Montreal” has demon-
strated log2 VQ = 6 (IBM, 2020).

C. Cross-entropy benchmarking

The linear cross-entropy benchmarking is a statistical
test used by Google in their quantum supremacy experi-
ment (Arute et al., 2019; Neill et al., 2018). It measures
how often high-probability bitstrings are sampled in an
experimental scenario. Suppose we perform a sampling
task and obtain bitstrings {xj}j
via measurement on a
given m-qubit circuit CE. The linear cross-entropy bench-
marking ﬁdelity is given by

FXEB = 2m ⟨P (xj)⟩j − 1.

(127)

is over the experimentally observed
Here, the average ⟨.⟩j
bitstrings {xj}j
and P (xj) denotes the probability of ob-
serving bitstring xj for the ideal circuit version of CE. In
other words, P (xj) denotes the ideal probability of the
generated sample xj. Since one can not have an ideal cir-
cuit in practice, P (xj) are calculated using a classical
computer simulation of the ideal circuit. FXEB com-
pares how often a bitstring xj is observed experimentally
with its classically simulated ideal probability. For the
ideal case, FXEB approaches unity for a large number of
qubits. On the other hand, it is equal to zero for uniform
distribution. As the circuit’s nose grows, FXEB decreases
and approaches zero. Since the probabilities P (xj) are
calculated via classical simulation; it renders the compu-
tation of FXEB intractable in the supremacy regime. The
classical hardness of spooﬁng linear cross-entropy bench-
marking was studied by Aaranson and Gunn (Aaronson
and Gunn, 2019), where they suggested the absence of
any eﬃcient classical algorithm for the aforementioned
task.

D. Application benchmarks

While hardware benchmarks,

such as randomized
benchmarking or quantum volume, provide valuable in-
sight into the performance of quantum devices, they may
not well represent or predict the performance of VQAs

61

which employ structured circuits. Application bench-
marks were developed to complement hardware bench-
marks and provide a more complete picture of both
the performance and (near-term) utility of quantum de-
vices. These benchmarks consist executing experimen-
tal demonstrations of VQA instances that can be com-
pared to classically computed exact results. Examples
of application benchmarks can be found in Refs. (Arute
et al., 2020; Benedetti et al., 2019a; Dallaire-Demers and
Killoran, 2018; Karamlou et al., 2020).
In particular,
(Arute et al., 2020) demonstrated VQE experiments for
hydrogen chain binding energy and diazene isomeriza-
tion mechanism with PQC sizes as big as 12 qubits and
72 two-qubit gates.

As a speciﬁc example of an application benchmark,
quantum circuits that diagonalize spin Hamiltonians
have been proposed in recent years (Cervera-Lierta, 2018;
Schmoll and Orús, 2017; Verstraete et al., 2009). By
comparing the results obtained from the quantum device
with the analytical solution, one can discern the perfor-
mance of the computation for a speciﬁc purpose experi-
ment. Small experiments have shown that gate ﬁdelities
and decoherence times alone do not provide a complete
picture of the noise model (Cervera-Lierta, 2018).

In that direction, authors of (Dallaire-Demers et al.,
2020) proposed a ﬁgure-of-merit called the eﬀective
fermionic length to quantify the performance of a NISQ
device in which the application-at-hand is estimating the
energy density of the one-dimensional Fermi-Hubbard
model over increasing chain lengths. Theoretically, as
the chain length increases, the energy density should ap-
In practice, the NISQ
proach the inﬁnite chain limit.
device will accrue some level of noise and decoherence,
which will cause the computed energy density to diverge
past some chain length. The maximum chain length af-
ter which noise and decoherence start degrading the al-
gorithm performance reveals the “limit” of the quantum
device in carrying out related algorithms. Ref. (Dallaire-
Demers et al., 2020) abstracts this idea to redeﬁne an
application benchmark as a way to systematically test
the limits of a quantum processor using exactly solvable
VQA instances that can also be scaled to larger system
sizes (e.g chain length in Ref. (Dallaire-Demers et al.,
2020) or number of preprocessing steps in Ref. (Karam-
lou et al., 2020)).

Generative models such as the QCBM (see Sec. VI.B.2)
can serve as benchmarks for NISQ devices (Hamilton
et al., 2019; Leyton-Ortega et al., 2019; Zhu et al., 2019).
Here, the measurement output of hardware eﬃcient vari-
ational ansäte are used to represent diﬀerent types of
distributions and study the eﬀect of noise and hardware
limitations on the result.

In addition to VQAs, one can analyze more funda-
mental benchmarks, such as the ability of NISQ devices
to violate local-realism by means of Mermin inequalities
(Alsina and Latorre, 2016) or the entanglement power

of the devices by trying to construct maximal entangled
states (Cervera-Lierta et al., 2019; Wang et al., 2018a).

VIII. OUTLOOK

In the last decade, quantum computing has expe-
rienced notable progress in applications, experimental
demonstrations, and theoretical results. The number of
papers in quantum computation, particularly in NISQ
applications, is growing almost exponentially. Several
reasons explain this community drive, one of those being
tremendous improvements in quantum hardware. Quan-
tum computing is a relatively young ﬁeld in science and,
as such, there is plenty of room for pioneering research
and discoveries. This fact, together with the theoret-
ical, practical, and experimental challenges (several of
them covered in this review), has strengthened the mo-
tivation for an open-source strategy in the ﬁeld. Nowa-
days, many universities and research centers subscribe
to an open-access policy that pushes towards the free
and open-source publication of all computational tools,
data, and programs used in their research. These policies
have proved valuable for rapid scientiﬁc development as
well as for democratizing community knowledge. This
way of thinking has percolated through academia walls
and it has been introduced into several private compa-
nies, not just for its advantage, but also because it fa-
cilitates the continuous healthy ﬂow of quantum com-
puting researchers to themselves (and, in some cases, re-
sulting in foundation of startups). Consequently, there
is a rich open quantum computing ecosystem composed
of universities, institutes, big corporations, startups, and
uncountable individual enthusiasts. Another product of
the symbiosis between academia and the private sector
is cloud quantum computing. Companies are oﬀering ac-
cess to their hardware remotely, in some cases at zero-
cost for their small prototypes and simulators. On the
one hand, scientists and quantum computing enthusiasts
around the world have the opportunity to experience real
quantum devices from their homes. On the other hand,
this increases the chances of ﬁnding real-world applica-
tions in quantum computation and solving the current
challenges of this ﬁeld. The proliferation of open-source
quantum computing languages, simulators, and tools (de-
tailed in Sec. V.C) have burgeoned many user communi-
ties. Various international initiatives have been set up
to attract quantum computing talent, and the private
sector’s involvement is ramping up. Several non-proﬁt
initiatives are also encouraging the use and development
of these tools (QOSF, 2020; Unitary Fund, 2020).

Experimental realizations of quantum computation, al-
though in the early stages, have interested many com-
munities in this quantum information subﬁeld. Healthy
competition has also arisen between the classical and
quantum computing branches. Classical computational

62

scientists have put their eﬀorts into moving the quantum
advantage frontier further, raising the bar to claim that a
quantum algorithm shows a signiﬁcant speed-up. Along
that direction, an oﬀ-shoot is an eﬀort in dequantization,
ﬁrst exhibited in the case of recommendation-systems,
to devise quantum-inspired classical algorithms that are
nearly as fast as their quantum counterparts (Tang,
2019). Such attempts have eliminated examples of speed-
up for some problems in linear algebra. So far, de-
quantized machine learning algorithms have been devel-
oped for recommendation systems (Tang, 2019), princi-
pal component analysis and supervised clustering (Tang,
2018), stochastic regression (Gilyén et al., 2018) and low-
rank linear systems (Arrazola et al., 2019; Chia et al.,
2018).

Since NISQ devices are inherently noisy, analysis sim-
ilar to (Napp et al., 2019; Zhou et al., 2020b; Zlokapa
et al., 2020) will be required to ﬁnd out how much noise
a NISQ algorithm can endure until its classical simula-
tion becomes eﬃcient. This is crucial in order to under-
stand the boundary where quantum computers provide
an advantage.
Investigating the potential of NISQ al-
gorithms using ideas from quantum foundations such as
contextuality and entanglement are helpful in that re-
spect (Bharti et al., 2020; Deutsch, 2020). More theo-
retical results as the ones presented in (Biamonte, 2019;
Bouland et al., 2021; Bravyi et al., 2020a, 2021; Farhi and
Harrow, 2016; Lloyd, 2018; Movassagh, 2019) may also
prove valuable. It is also imperative to develop strategies
that help us bypass complicated measurements involv-
ing controlled multi-qubit unitaries (Mitarai and Fujii,
2019). For machine learning tasks, ideas similar to (Har-
row, 2020) would be valuable.

Another fascinating frontier that needs to be inves-
tigated in the next few years, we believe, is quantum
and classical certiﬁcation schemes for quantum devices
and quantum computation (Eisert et al., 2020). The in-
tractability of quantum computation by classical devices
poses the challenge to verify the correct functioning of
the quantum devices as well as the correctness of the ﬁ-
nal output (Eisert et al., 2020). The existence of multiple
quantum computing platforms requires new methodolo-
gies and ﬁgures of merit to benchmark and compare these
devices. Other works are being proposed in that direc-
tion (Kottmann et al., 2020; Kyaw et al., 2020b), as well
as the development of benchmarking measures discussed
in Sec. VII. Ideas from complexity theory (Mahadev,
2018; Metger and Vidick, 2020) and quantum founda-
tions (Bharti et al., 2019b,c) could be valuable in this
direction.

At the moment of documenting this review, there is no
known demonstration of industrially relevant quantum
advantage. Quantum computing is still in its early days,
and so far a useful quantum computer is missing. The
potential of NISQ devices is not fully understood, and a
lot of rigorous research is required to release the power of

the early quantum computers. However, a number of ex-
periments overcoming classical computational resources
have been performed and many theoretical and practi-
cal tools are being used and developed, as explained in
Sec. V.

A. NISQ goals

We expect experimental pursuit in the NISQ era would
focus on the design of quantum hardware with a larger
number of qubits, and gates with lower error rates capa-
ble of executing deeper circuits. Along the way, one of
the goals is to demonstrate quantum advantage for prac-
If the NISQ paradigm is not powerful
tical use cases.
enough to exhibit any quantum advantage, theoretical
pursuits would be required to understand its limitations.
The prime direction of the NISQ and near-term era is
to engineer the best possible solution with the limited
quantum resources available. The tools and techniques
invented during this period could be valuable in the fault-
tolerant era as well.

To conduct a successful demonstration of quantum ad-
vantage, the right blend of the following three crucial
components is required:

1. Hardware development: The design of quantum
lesser error rates,
computers with more qubits,
longer coherence times, and more connectivity be-
tween the qubits will be one of the top priorities
in the NISQ era. Intensive research in new qubits
developments, quantum optimal control and mate-
rial discovery will be indispensable for both univer-
sal programmable quantum computers or special-
purpose ones. A way to scale up the number of
qubits present in a quantum platform is to design
a novel qubit which has built-in autonomous quan-
tum error correction down to the hardware level
(Chamberland et al., 2020a; Paz and Zurek, 1998)
or protected novel qubit (Douçot and Ioﬀe, 2012;
Kyaw, 2019; Nataf and Ciuti, 2011) which is robust
against speciﬁc noises in the hardware. As a quan-
tum processor size grows, there is a tremendous
need to store quantum information during quan-
tum information processing (Kyaw et al., 2014a,
2015a,b). Even miniaturizing microwave circula-
tor onto the superconducting chip (Chapman et al.,
2017; Mahoney et al., 2017) can be seen as a mean
to scale up the quantum platform although it has
nothing to do with novel qubit design.

2. Algorithm design: To harness the potential of noisy
but powerful quantum devices, we expect break-
throughs on the algorithm frontier. Algorithms
with realistic assumptions, as the ones mentioned
in Sec. V.B, regarding device capabilities will be

63

favored. To lessen the eﬀect of noise, progress to-
wards the design of error mitigation algorithms is
expected. Eﬀorts have to be made to develop algo-
rithms that harness the problem’s structure in the
best possible manner and map it to the given hard-
ware in eﬃcient ways, such as in Sec. III.D. VQA
with better expressibility and trainability will also
be helpful.

3. Application problem: We have discussed the exist-
ing applications of NISQ devices in many areas in
Sec. VI. Collaborations between experts with do-
main knowledge from these ﬁelds and quantum al-
gorithm researchers will be required more and more
to develop the ﬁeld and integrate quantum com-
putation into industrial workﬂows. New collabo-
rations might reveal diﬃcult problems for classical
computers that are well suited for NISQ devices. It
is not clear yet which applications will be the ﬁrst
ones to witness quantum advantage, though there
is plenty of speculation and opinions.

B. Long-term goal: fault-tolerant quantum computing

Noise is regarded as one of the most prominent threats
to a quantum computer’s practical realization. In 1995,
Peter Shor established that by encoding quantum infor-
mation redundantly using extra qubits, one could circum-
vent the eﬀect of noise (Shor, 1995). The quantum infor-
mation is spread over multiple physical qubits to generate
a logical qubit (Calderbank and Shor, 1996; Gottesman,
1997; Knill and Laﬂamme, 1997; Shor, 1995). Most of the
transformative algorithms such as Shor’s factoring algo-
rithm, Grover search algorithm, and HHL require error-
corrected qubits for their execution. Soon after Shor’s
error-correcting code, many others were developed. Some
of the famous error-correcting codes are stabilizer and
topological error-correcting codes (Fowler et al., 2012;
Terhal, 2015). While the stabilizer code utilizes extra
qubits to protect the logical qubit, topological codes em-
ploy a set of qubits positioned on a surface, such as a
torus, in a lattice structure.

Over the years, quantum error correction has evolved
as a subﬁeld of quantum computation and has trans-
formed from a theoretical pursuit to a practical possi-
bility. The process of detecting and correcting errors can
be, itself, prone to noise. Thus error correction alone
does not guarantee the prospect of storing or processing
quantum information for an arbitrarily long period. The
aforesaid issue can be tackled by utilizing the Quantum
Fault-Tolerant threshold theorem. Informally speaking, it
is possible to execute arbitrarily large quantum compu-
tation by arbitrarily suppressing the quantum error rate,
given the noise in the individual quantum gates are below
a certain threshold (Aharonov and Ben-Or, 2008). If one

wants to simulate an ideal circuit of size N , the size of the
noisy quantum circuit for fault-tolerant quantum compu-
tation scales O (N (log N )c), for some constant c, given
the noisy circuit is subjected to stochastic noise strength
p < pc for some noise threshold pc (Terhal, 2015). This
theorem rises some practically relevant questions such as
i) How high is pc; ii) what is the value of the constant c;
and iii) what is the value of the multiplicative constant
in O (.). These questions determine the practicality of
any fault-tolerant quantum computation scheme (Terhal,
2015).

Looking forward,

lowering the noise level will be a
critical challenge. Though the problem is demanding,
signiﬁcant progress has been made recently at the algo-
rithmic as well as hardware frontier (Campagne-Ibarcq
et al., 2020; Lidar and Brun, 2013; Noh and Cham-
berland, 2020; Terhal, 2015). Quantum error-correcting
codes amenable to architectures with limited qubit con-
nectivity have also been proposed (Chamberland et al.,
2020b). As we transition towards fault-tolerant quantum
computing, partial quantum error correction demonstra-
tions such as exponential suppression of bit or phase er-
rors (Google, 2021) and approximate quantum error cor-
rection schemes (Faist et al., 2020; Leung et al., 1997)
become highly relevant. Recently, Monroe and Brown’s
groups have conﬁrmed the ﬁrst-ever fault-tolerant oper-
ation on a logical qubit (Egan et al., 2020).

We are at an exciting juncture in the history of com-
puting. Completely new kinds of computers that were
once only ﬁgments of imagination are rapidly becoming
a reality. The NISQ era oﬀers fantastic opportunities to
current and future researchers to explore the theoretical
limits of these devices and discover practical and exciting
applications in the near-term. Theoretical investigations
and experimental challenges will help us to comprehend
quantum devices power and build better algorithms. The
success of the ﬁeld lies in the hands of the researchers and
practitioners of the area, so we encourage everyone with
interest to join the eﬀort.

ACKNOWLEDGEMENTS

A.A.-G. acknowledges the generous support from
Google, Inc.
in the form of a Google Focused Award.
This work was supported by the U.S. Department of
Energy under Award No. DESC0019374 and the U.S.
Oﬃce of Naval Research (ONS506661). A.A.-G. also
acknowledges support from the Canada Industrial Re-
search Chairs Program and the Canada 150 Research
Chairs Program. T.H. is supported by a Samsung GRC
project and the UK Hub in Quantum Computing and
Simulation, part of the UK National Quantum Tech-
nologies Programme with funding from UKRI EPSRC

64

grant EP/T001062/1. L.-C.K and K.B acknowledge the
ﬁnancial support from the National Research Foundation
and the Ministry of Education, Singapore. We thank
Michael Biercuk, Naresh Boddu, Zhenyu Cai, Sam Gut-
mann, Edward Farhi, Rahul Jain, Dax Koh, Alejandro
Perdomo-Ortiz and Mark Steudtner for interesting dis-
cussions, feedback and comments.

REFERENCES

Aaronson, S. (2019), SIAM Journal on Computing 49 (5),

STOC18.

Aaronson, S., and A. Arkhipov (2011), Proceedings of the
forty-third annual ACM symposium on Theory of comput-
ing , 333.

Aaronson, S., and D. Gottesman (2004), Phys. Rev. A 70,

052328.

Aaronson, S., and S. Gunn (2019), arXiv:1910.12085 .
Abadi, M., P. Barham, J. Chen, Z. Chen, A. Davis, J. Dean,
M. Devin, S. Ghemawat, G. Irving, M. Isard, et al. (2016),
12th {USENIX} symposium on operating systems design
and implementation ({OSDI} 16) , 265.

Abbas, A., D. Sutter, C. Zoufal, A. Lucchi, A. Figalli, and
S. Woerner (2021), Nature Computational Science 1 (6),
403.

Acín, A., I. Bloch, H. Buhrman, T. Calarco, C. Eichler, J. Eis-
ert, D. Esteve, N. Gisin, S. J. Glaser, F. Jelezko, et al.
(2018), New J. Phys. 20 (8), 080201.

Ackley, D. H., G. E. Hinton, and T. J. Sejnowski (1985),

Cogn. Sci. 9 (1), 147 .

Adams, C. S., J. D. Pritchard, and J. P. Shaﬀer (2019), J.

Phys. B 53 (1), 012002.

Aharonov, D., and M. Ben-Or (2008), SIAM J. Comput. .
Aharonov, D., W. Van Dam, J. Kempe, Z. Landau, S. Lloyd,

and O. Regev (2008), SIAM review 50 (4), 755.

Aïmeur, E., G. Brassard, and S. Gambs (2013), Mach. Learn.

90 (2), 261.

Akshay, V., H. Philathong, M. E. S. Morales,

and J. D.

Biamonte (2020a), Phys. Rev. Lett. 124, 090504.

Akshay, V., H. Philathong, I. Zacharov, and J. Biamonte

(2020b), arXiv:2007.09148 .

Albarrán-Arriagada, F., J. Retamal, E. Solano,

and
L. Lamata (2020), Mach. Learn.: Sci. Technol. 1 (1),
015002.

Albash, T., and D. A. Lidar (2018), Rev. Mod. Phys. 90 (1),

015002.

Albash, T., T. F. Rønnow, M. Troyer,

and D. A. Lidar
(2015), The Eur. Phys. J. Spec. Top. Journal Special Topics
224 (1), 111.

Alcazar, J., V. Leyton-Ortega, and A. Perdomo-Ortiz (2020),

Mach. Learn.: Sci. Technol. .

Alcazar, J., and A. Perdomo-Ortiz (2021), arXiv:2101.06250

.

Aleiner, I., F. Arute, K. Arya, J. Atalaya, R. Babbush, J. C.
Bardin, R. Barends, A. Bengtsson, S. Boixo, A. Bourassa,
et al. (2020), arXiv:2012.00921 .

Alexander, T., N. Kanazawa, D. J. Egger, L. Capelluto, C. J.
Wood, A. Javadi-Abhari, and D. C. McKay (2020), Quan-
tum Sci. Technol. 5 (4), 044006.

Alsina, D., and J. I. Latorre (2016), Phys. Rev. A 94 (1),

012314.

Altman, E. R. (2019), arXiv:1910.03033 .

65

Amaral, B., and M. T. Cunha (2018), On graph approaches to
contextuality and their role in quantum theory (Springer).

Amari, S.-I. (1998), Neural computation 10 (2), 251.
Ambainis, A. (2012), “Variable time amplitude ampliﬁca-
tion and quantum algorithms for linear algebra problems,”
https://t.ly/30Uz.

Amico, L., M. Boshier, G. Birkl, A. Minguzzi, C. Miniatura,
L.-C. Kwek, D. Aghamalyan, V. Ahuﬁnger, D. Anderson,
N. Andrei, et al. (2021), AVS Quantum Science 3 (3),
039201.

Amin, M. H., E. Andriyash, J. Rolfe, B. Kulchytskyy,
and R. Melko (2018), Phys. Rev. X 8 (2), 10.1103/phys-
revx.8.021050.

Amy, M., P. Azimzadeh, and M. Mosca (2018), Quantum

Science and Technology 4 (1), 015002.

Amy, M., and V. Gheorghiu (2020), Quantum Sci. Technol. .
Amy, M., D. Maslov, M. Mosca, and M. Roetteler (2013),
IEEE Transactions on Computer-Aided Design of Inte-
grated Circuits and Systems 32 (6), 818.

Amy, M., and M. Mosca (2019), IEEE Transactions on In-

formation Theory 65 (8), 4771.

Avkhadiev, A., P. Shanahan, and R. Young (2020), Phys.

Rev. Lett. 124 (8), 080501.

Ayanzadeh, R., S. Mousavi, M. Halem, and T. Finin (2019),

arXiv:1901.00088 .

Azses, D., R. Haenel, Y. Naveh, R. Raussendorf, E. Sela, and
E. G. Dalla Torre (2020), Phys. Rev. Lett. 125, 120502.
Babbush, R., P. J. Love, and A. Aspuru-Guzik (2014), Sci.

Rep. 4 (1), 6603.

Babbush, R., A. Perdomo-Ortiz, B. O’Gorman, W. Macready,
and A. Aspuru-Guzik (2012), Adv. Chem. Phys 155,
https://doi.org/10.1002/9781118755815.ch05.

Babej, T., M. Fingerhuth, et al. (2018), arXiv:1811.00713 .
Ball, R. (2005), Phys. Rev. Lett. 95 (17), 176407.
Banchi, L., and G. E. Crooks (2020), arXiv:2005.10299 .
Banchi, L., M. Fingerhuth, T. Babej, C. Ing,
Arrazola (2020a), Sci. Adv. 6 (23), eaax1950.

and J. M.

Banchi, L., N. Quesada,

and J. M. Arrazola (2020b),

arXiv:2004.04770 .

Bang, J., and S. Yoo (2014), J. Korean Phys. Soc 65 (12),

2001.
Barak, B.,

and K. Marwaha (2021), arXiv preprint

Anand, A., M. Degroote,

and A. Aspuru-Guzik (2020a),

arXiv:2106.05900.

arXiv:2012.00101 .

Anand, A., J. Romero, M. Degroote, and A. Aspuru-Guzik

(2020b), arXiv:2006.01976 .

Anderson, D. G. (1965), J. ACM 12 (4), 547.
Anschuetz, E., J. Olson, A. Aspuru-Guzik,

and Y. Cao
(2019), International Workshop on Quantum Technology
and Optimization Problems , 74.

Anschuetz, E. R., and Y. Cao (2019), arXiv:1903.01359 .
Argüello-Luengo, J., A. González-Tudela, T. Shi, P. Zoller,

Barak, B., A. Moitra, R. O’Donnell, P. Raghavendra,
O. Regev, D. Steurer, L. Trevisan, A. Vijayaragha-
van, D. Witmer,
and J. Wright (2015), arXiv preprint
arXiv:1505.03424.

Barenco, A., C. H. Bennett, R. Cleve, D. P. DiVincenzo,
N. Margolus, P. Shor, T. Sleator, J. A. Smolin, and H. We-
infurter (1995), Phys. Rev. A 52, 3457.

Barison, S., D. E. Galli,

and M. Motta (2020),

arXiv:2011.08137 .

and J. I. Cirac (2019), Nature 574 (7777), 215.

Barison, S., F. Vicentini, and G. Carleo (2021), Quantum 5,

Arimitsu, K., Y. O. Nakagawa, S. Koh, W. Mizukami,
Q. Gao, and T. Kobayashi (2021), “Analytic energy gradi-
ent for state-averaged orbital-optimized variational quan-
tum eigensolvers and its application to a photochemical
reaction,” arXiv:2107.12705 [physics.chem-ph].

Arora, S., and B. Barak (2009), Computational complexity:

a modern approach (Cambridge University Press).

Arrasmith, A., M. Cerezo, P. Czarnik, L. Cincio, and P. J.

Coles (2020a), arXiv:2011.12245 .

Arrasmith, A., L. Cincio, R. D. Somma, and P. J. Coles

(2020b), arXiv:2004.06252 .

512.

Barkoutsos, P. K., G. Nannicini, A. Robert, I. Tavernelli, and

S. Woerner (2020), Quantum 4, 256.

Barron, G. S., B. T. Gard, O. J. Altman, N. J. Mayhall,
E. Barnes, and S. E. Economou (2020), arXiv:2003.00171
.

Bassman, L., K. Liu, A. Krishnamoorthy, T. Linker, Y. Geng,
D. Shebib, S. Fukushima, F. Shimojo, R. K. Kalia,
A. Nakano, and P. Vashishta (2020), Phys. Rev. B 101,
184305.

Bastidas, V., T. Haug, C. Gravel, L.-C. Kwek, W. Munro,

Arrasmith, A., L. Cincio, A. T. Sornborger, W. H. Zurek,

and K. Nemoto (2020), arXiv:2009.00823 .

and P. J. Coles (2019), Nat. commun. 10 (1), 1.

Arrazola, J., V. Bergholm, K. Brádler, T. Bromley,
M. Collins, I. Dhand, A. Fumagalli, T. Gerrits, A. Goussev,
L. Helt, et al. (2021), Nature 591 (7848), 54.

Arrazola, J. M., and T. R. Bromley (2018), Phys. Rev. Lett.

Bastidas, V. M., T. H. Kyaw, J. Tangpanitanon, G. Romero,
L.-C. Kwek, and D. G. Angelakis (2018), New J. Phys.
20 (9), 093004.

Batista, C. D., and G. Ortiz (2004), Adv. Phys. 53 (1), 1.
de Beaudrap, N., X. Bian,

and Q. Wang (2019),

121 (3), 030503.

arXiv:1911.09039 .

Arrazola, J. M., T. R. Bromley, and P. Rebentrost (2018),

Beckey, J. L., M. Cerezo, A. Sone, and P. J. Coles (2020),

Phys. Rev. A 98 (1), 012322.

arXiv:2010.10488 .

Arrazola, J. M., A. Delgado, B. R. Bardhan, and S. Lloyd

Benedetti, M., M. Fiorentini, and M. Lubasch (2020), arXiv

(2019), arXiv:1905.10415 .

preprint arXiv:2009.12361.

Arunachalam, S., and R. de Wolf (2017), arXiv:1701.06806 .
Arute, F., K. Arya, R. Babbush, D. Bacon, J. C. Bardin,
R. Barends, R. Biswas, S. Boixo, F. G. Brandao, D. A.
Buell, et al. (2019), Nature 574 (7779), 505.

Arute, F., K. Arya, R. Babbush, D. Bacon, J. C. Bardin,
R. Barends, S. Boixo, M. Broughton, B. B. Buckley, D. A.
Buell, et al. (2020), Science 369 (6507), 1084.

Benedetti, M., D. Garcia-Pintos, O. Perdomo, V. Leyton-
and A. Perdomo-Ortiz (2019a), npj

Ortega, Y. Nam,
Quantum Inf. 5 (1), 1.

Benedetti, M., E. Lloyd, S. Sack, and M. Fiorentini (2019b),

Quantum Sci. Technol. 4 (4), 043001.

Benedetti, M., J. Realpe-Gómez, R. Biswas, and A. Perdomo-

Ortiz (2016), Phys. Rev. A 94 (2), 022308.

Aspuru-Guzik, A., A. D. Dutoi, P. J. Love, and M. Head-

Benedetti, M., J. Realpe-Gómez, R. Biswas, and A. Perdomo-

Gordon (2005), Science 309 (5741), 1704.

Ortiz (2017), Phys. Rev. X 7 (4), 041052.

66

Benedetti, M., J. Realpe-Gómez,

and A. Perdomo-Ortiz

(2018), Quantum Sci. Technol. 3 (3), 034007.

Bravo-Prieto, C. (2020), arXiv:2010.06599 .
Bravo-Prieto, C., D. García-Martín,

and J. I. Latorre

Bengtsson, A., P. Vikstål, C. Warren, M. Svensson, X. Gu,
A. F. Kockum, P. Krantz, C. Križan, D. Shiri, I.-M. Svens-
son, G. Tancredi, G. Johansson, P. Delsing, G. Ferrini, and
J. Bylander (2020), Phys. Rev. Appl. 14, 034010.

Benioﬀ, P. (1980), J. Stat. Phys. 22 (5), 563.
Bergholm, V., J. Izaac, M. Schuld, C. Gogolin, M. S. Alam,
S. Ahmed, J. M. Arrazola, C. Blank, A. Delgado, S. Ja-
hangiri, et al. (2018), arXiv:1811.04968 .

Bharti, K. (2020), arXiv:2009.11001 .
Bharti, K., and T. Haug (2020a), arXiv:2010.05638 .
Bharti, K., and T. Haug (2020b), arXiv:2011.06911 .
Bharti, K., T. Haug, V. Vedral, and L.-C. Kwek (2019a),

arXiv:1912.10783 .

(2020a), Phys. Rev. A 101 (6), 062310.

Bravo-Prieto, C., R. LaRose, M. Cerezo, Y. Subasi, L. Cincio,

and P. J. Coles (2019), arXiv:1909.05820 .

Bravo-Prieto, C., J. Lumbreras-Zarapico, L. Tagliacozzo, and

J. I. Latorre (2020b), Quantum 4, 272.

Bravyi, S., D. P. DiVincenzo, D. Loss, and B. M. Terhal

(2008), Phys. Rev. Lett. 101 (7), 070503.

Bravyi, S., J. M. Gambetta, A. Mezzacapo, and K. Temme
(2017), “Tapering oﬀ qubits to simulate fermionic hamilto-
nians,” arXiv:1701.08213 [quant-ph].

Bravyi, S., D. Gosset, R. Koenig,
(2020a), Nat. Phys. 16 (10), 1040.

and M. Tomamichel

Bravyi, S., D. Gosset, and R. Movassagh (2021), Nat. Phys.

Bharti, K., T. Haug, V. Vedral, and L.-C. Kwek (2020), AVS

https://doi.org/10.1038/s41567-020-01109-8.

Quantum Sci. 2, 034101.

Bravyi, S., A. Kliesch, R. Koenig,

and E. Tang (2019),

Bharti, K., T. Haug, V. Vedral,

and L.-C. Kwek (2021),

arXiv:1910.08980 .

arXiv:2106.03891 .

Bravyi, S., A. Kliesch, R. Koenig,

and E. Tang (2020b),

Bharti, K., M. Ray, A. Varvitsiotis, A. Cabello, and L.-C.

arXiv:2011.13420 .

Kwek (2019b), arXiv:1911.09448 .

Bravyi, S. B., and A. Y. Kitaev (2002), Ann. Phys. 298 (1),

Bharti, K., M. Ray, A. Varvitsiotis, N. A. Warsi, A. Cabello,
and L.-C. Kwek (2019c), Phys. Rev. Lett. 122, 250403.

Biamonte, J. (2019), arXiv:1903.04500 .
Biamonte, J., P. Wittek, N. Pancotti, P. Rebentrost,
N. Wiebe, and S. Lloyd (2017), Nature 549 (7671), 195.

210.

Brennen, G. K. (2003), arXiv preprint quant-ph/0305094 .
Breuer, H.-P., F. Petruccione, et al. (2002), The theory of open
quantum systems (Oxford University Press on Demand).
Briegel, H. J., D. E. Browne, W. Dür, R. Raussendorf, and

and M. Vechev (2020),

M. Van den Nest (2009), Nat. Phys. 5 (1), 19.

Bichsel, B., M. Baader, T. Gehr,
Proceedings PLDI 2020 , 286.

Bittel, L.,
120502.

and M. Kliesch (2021), Phys. Rev. Lett. 127,

Björklund, A., B. Gupt, and N. Quesada (2019), ACM J.

Exp. Algorithmics 24.

Blaauboer, M., and R. De Visser (2008), J. Phys. A Math.

Theor. 41 (39), 395307.

Bromley, T. R., J. M. Arrazola, S. Jahangiri, J. Izaac, N. Que-
sada, A. D. Gran, M. Schuld, J. Swinarton, Z. Zabaneh,
and N. Killoran (2020), Quantum Sci. Technol. 5 (3),
034010.

Broughton, M., G. Verdon, T. McCourt, A. J. Martinez, J. H.
Yoo, S. V. Isakov, P. Massey, M. Y. Niu, R. Halavati, E. Pe-
ters, et al. (2020), arXiv:2003.02989 .

Blank, C., D. K. Park, and F. Petruccione (2020a), arXiv

Brown, W. G., and B. Eastin (2018), Phys. Rev. A 97 (6),

preprint arXiv:2008.06443 .

062323.

Blank, C., D. K. Park, J.-K. K. Rhee, and F. Petruccione

(2020b), npj Quantum Information 6 (1), 1.

Blatt, R., and C. F. Roos (2012), Nat. Phys. 8 (4), 277.
Bloch, I., J. Dalibard, and S. Nascimbene (2012), Nat. Phys.

8 (4), 267.

Blume-Kohout, R., and K. C. Young (2020), Quantum 4,

362.

Bondarenko, D., and P. Feldmann (2020), Phys. Rev. Lett.

124, 130502.

Bonet-Monroig, X., R. Babbush, and T. E. O’Brien (2020),

Phys. Rev. X 10 (3), 031064.

Bonet-Monroig, X., R. Sagastizabal, M. Singh,
T. O’Brien (2018), Phys. Rev. A 98 (6), 062339.

and

Botea, A., A. Kishimoto, and R. Marinescu (2018), SOCS.
Bouland, A., W. van Dam, H. Joorati, I. Kerenidis,

and

A. Prakash (2020), arXiv:2011.06492 .

de Brugière, T. G., M. Baboulin, B. Valiron, S. Martiel, and
C. Allouche (2020), International Conference on Reversible
Computation , 189.

Brunner, N., D. Cavalcanti, S. Pironio, V. Scarani,

and

S. Wehner (2014), Rev. Mod. Phys. 86, 419.

von Burg, V., G. H. Low, T. Häner, D. S. Steiger, M. Rei-
her, M. Roetteler, and M. Troyer (2020), arXiv preprint
arXiv:2007.14460 .

Burges, C. J. (2002), Microsoft Research 10.1.1.67.7626.
Butcher, J. C. (1987), The numerical analysis of ordinary dif-
ferential equations: Runge-Kutta and general linear meth-
ods (Wiley-Interscience).

Bylaska, E. J., D. Song, N. P. Bauman, K. Kowalski,
D. Claudino, and T. S. Humble (2020), arXiv:2009.00080
.

Cade, C., L. Mineh, A. Montanaro, and S. Stanisic (2020),

Bouland, A., B. Feﬀerman, Z. Landau, and Y. Liu (2021),

Phys. Rev. B 102 (23), 235122.

arXiv:2102.01738 .

Bouland, A., and M. Ozols (2018), 13th Conference on the
Theory of Quantum Computation, Communication and
Cryptography (TQC 2018) Leibniz International Proceed-
ings in Informatics (LIPIcs), 111, 6:1.

Brady, L. T., C. L. Baldwin, A. Bapat, Y. Kharkov, and

A. V. Gorshkov (2020), arXiv:2003.08952 .

Brady, L. T., and W. van Dam (2016), Phys. Rev. A 94 (3),

032309.

Brandao, F. G. S. L., M. Broughton, E. Farhi, S. Gutmann,

and H. Neven (2018), arXiv:1812.04170 .

Cai, Z. (2020a), arXiv preprint arXiv:2007.01265 .
Cai, Z. (2020b), Phys. Rev. Appl. 14 (1), 014059.
Cai, Z. (2021), arXiv:2101.03151 .
Calderbank, A. R., and P. W. Shor (1996), Phys. Rev. A

54 (2), 1098.

Campagne-Ibarcq, P., A. Eickbusch, S. Touzard, E. Zalys-
Geller, N. E. Frattini, V. V. Sivak, P. Reinhold, S. Puri,
S. Shankar, R. J. Schoelkopf, et al. (2020), Nature
584 (7821), 368.

Cao, Y., J. Romero, J. P. Olson, M. Degroote, P. D. Johnson,
M. Kieferová, I. D. Kivlichan, T. Menke, B. Peropadre,

67

N. P. Sawaya, et al. (2019), Chem. Rev. 119 (19), 10856.

Chong, F. T., D. Franklin, and M. Martonosi (2017), Nature

Cárdenas-López, F. A., L. Lamata, J. C. Retamal,

and

549 (7671), 180.

E. Solano (2018), PloS one 13 (7), e0200455.

Choo, K., C. W. von Keyserlingk, N. Regnault, and T. Neu-

Carignan-Dugas, A., J. J. Wallman, and J. Emerson (2015),

pert (2018), Phys. Rev. Lett. 121, 086808.

Phys. Rev. A 92 (6), 060302.

Carleo, G., I. Cirac, K. Cranmer, L. Daudet, M. Schuld,
N. Tishby, L. Vogt-Maranto, and L. Zdeborová (2019),
Rev. Mod. Phys. 91 (4), 045002.

Carleo, G., and M. Troyer (2017), Science 355 (6325), 602.
Carvalho, A. R., H. Ball, M. J. Biercuk, M. R. Hush, and

F. Thomsen (2020), arXiv:2010.08057 .

Choquette, A., A. Di Paolo, P. K. Barkoutsos, D. Sénéchal,
I. Tavernelli, and A. Blais (2020), arXiv:2008.01098 .

Chowdhury, A. N., G. H. Low,

and N. Wiebe (2020),

arXiv:2002.00055 .

Ciliberto, C., M. Herbster, A. D. Ialongo, M. Pontil, A. Roc-
chetto, S. Severini, and L. Wossnig (2018), Proc. Math.
Phys. Eng. Sci. 474 (2209), 20170551.

Castaldo, D., M. Rosa, and S. Corni (2020), arXiv preprint

Cirstoiu, C., Z. Holmes, J. Iosue, L. Cincio, P. J. Coles, and

arXiv:2007.00368 .

Céleri, L. C., D. Huerga, F. Albarrán-Arriagada, E. Solano,
and M. Sanz (2021), arXiv preprint arXiv:2103.15689.
Cerezo, M., A. Poremba, L. Cincio, and P. J. Coles (2020a),

Quantum 4, 248.

Cerezo, M., K. Sharma, A. Arrasmith,

and P. J. Coles

(2020b), arXiv:2004.01372 .

A. Sornborger (2020), npj Quantum Inf. 6 (1), 1.
and C. Alexander

J., A. Khan,

Cohen,

(2020),

arXiv:2007.01430 .

Colless, J. I., V. V. Ramasesh, D. Dahlen, M. S. Blok,
M. Kimchi-Schwartz, J. McClean, J. Carter, W. De Jong,
and I. Siddiqi (2018), Phys. Rev. X 8 (1), 011021.

Commeau, B., M. Cerezo, Z. Holmes, L. Cincio, P. J. Coles,

Cerezo, M., A. Sone, T. Volkoﬀ, L. Cincio, and P. J. Coles

and A. Sornborger (2020), arXiv:2009.02559 .

(2021), Nature communications 12 (1), 1.
Cervera-Lierta, A. (2018), Quantum 2, 114.
Cervera-Lierta, A., J. S. Kottmann, and A. Aspuru-Guzik

(2021a), PRX Quantum 2, 020329.

Consiglio, M., W. J. Chetcuti, C. Bravo-Prieto, S. Ramos-
Calderer, A. Minguzzi, J. I. Latorre, L. Amico, and T. J.
Apollaro (2021), arXiv:2106.15552 .

Cook,

J., S. Eidenbenz,

and A. Bärtschi

(2019),

Cervera-Lierta, A., M. Krenn, A. Aspuru-Guzik,

and

arXiv:1910.13483 .

A. Galda (2021b), arXiv:2104.05627 .

Cervera-Lierta, A., J. I. Latorre, and D. Goyeneche (2019),

Phys. Rev. A 100, 022342.

Chamberland, C., K. Noh, P. Arrangoiz-Arriola, E. T. Camp-
bell, C. T. Hann, J. Iverson, H. Putterman, T. C. Bo-
hdanowicz, S. T. Flammia, A. Keller, et al. (2020a),
arXiv:2012.04108 .

Chamberland, C., G. Zhu, T. J. Yoder, J. B. Hertzberg, and
A. W. Cross (2020b), Physical Review X 10 (1), 011022.

Córcoles, A. D., E. Magesan, S. J. Srinivasan, A. W. Cross,
M. Steﬀen, J. M. Gambetta, and J. M. Chow (2015), Nat.
commun. 6 (1), 1.

Cornelissen, A. (2018), Master thesis (TU Delft) .
Cortes, C., and V. Vapnik (1995), Mach. Learn. 20 (3), 273.
Cowtan, A., S. Dilkes, R. Duncan, A. Krajenbrink, W. Sim-

mons, and S. Sivarajah (2019a), arXiv:1902.08091 .
Cowtan, A., S. Dilkes, R. Duncan, W. Simmons,

and

S. Sivarajah (2019b), arXiv:1906.01734 .

Chang, D. E., V. Vuletić,

and M. D. Lukin (2014), Nat.

Coyle, B., M. Henderson, J. C. J. Le, N. Kumar, M. Paini,

Photon. 8 (9), 685.

Chapman, B. J., E. I. Rosenthal, J. Kerckhoﬀ, B. A. Moores,
L. R. Vale, J. Mates, G. C. Hilton, K. Lalumiere, A. Blais,
and K. Lehnert (2017), Phys. Rev. X 7 (4), 041043.

and E. Kasheﬁ (2020a), Quantum Sci. Technol. .

Coyle, B., D. Mills, V. Danos, and E. Kasheﬁ (2020b), npj

Quantum Inf. 6 (1), 1.

Crawford, D., A. Levit, N. Ghadermarzy, J. S. Oberoi, and

Chen, J., H.

I. Nurdin,

and N. Yamamoto (2020a),

P. Ronagh (2016), arXiv:1612.05695 .

arXiv:2001.09498 .

Crawford, D., A. Levit, N. Ghadermarzy, J. S. Oberoi, and

Chen, S., W. Yu, P. Zeng, and S. T. Flammia (2020b), arXiv

P. Ronagh (2019a), arXiv:1612.05695 .

preprint arXiv:2011.09636 .

Crawford, O., B. van Straaten, D. Wang, T. Parks, E. Camp-

Chen, S. Y.-C., T.-C. Wei, C. Zhang, H. Yu, and S. Yoo

bell, and S. Brierley (2019b), arXiv:1908.06942 .

(2020c), arXiv:2012.12177 .

Chen, S. Y. C., C. H. H. Yang, J. Qi, P. Y. Chen, X. Ma, and

H. S. Goan (2020), IEEE Access 8, 141007.

Cheng, S., J. Chen, and L. Wang (2018), Entropy 20 (8),

Crooks, G. E. (2018), arXiv:1811.08419 .
Cross, A. W., L. S. Bishop, S. Sheldon, P. D. Nation, and
J. M. Gambetta (2019), Phys. Rev. A 100 (3), 032328.
Cross, A. W., L. S. Bishop, J. A. Smolin, and J. M. Gambetta

583.

(2017), arXiv:1707.03429 .

Chia, N.-H., H.-H. Lin,

and C. Wang

(2018),

Cross, A. W., E. Magesan, L. S. Bishop, J. A. Smolin, and

arXiv:1811.04852 .

J. M. Gambetta (2016), npj Quantum Inf. 2 (1), 1.

Chien, R. W., and J. D. Whitﬁeld (2020), arXiv:2009.11860

Czarnik, P., A. Arrasmith, P. J. Coles, and L. Cincio (2020),

.

arXiv preprint arXiv:2005.10189 .

Childs, A. M., R. Kothari, and R. D. Somma (2017), SIAM

Dalla Torre, E. G., S. Diehl, M. D. Lukin, S. Sachdev, and

J. Comput. 46 (6), 1920.

Chivilikhin, D., A. Samarin, V. Ulyantsev, I. Iorsh, A. R.
Oganov, and O. Kyriienko (2020), arXiv:2007.04424 .
Choi, J., S. Oh, and J. Kim (2020), arXiv:2004.11229 .
Choi, J.-y., S. Hild, J. Zeiher, P. Schauß, A. Rubio-Abadal,
T. Yefsah, V. Khemani, D. A. Huse, I. Bloch, and C. Gross
(2016), Science 352 (6293), 1547.

Choi, V. (2008), Quantum Inf. Process. 7 (5), 193.
Choi, V. (2011), Quantum Inf. Process. 10 (3), 343.

P. Strack (2013), Phys. Rev. A 87 (2), 023831.

Dallaire-Demers, P.-L., and N. Killoran (2018), Phys. Rev.

A 98 (1), 012324.

Dallaire-Demers, P.-L., J. Romero, L. Veis, S. Sim,

and
A. Aspuru-Guzik (2019), Quantum Sci. Technol. 4 (4),
045005.

Dallaire-Demers, P.-L., M. Stęchły, J. F. Gonthier, N. T.
Bashige, J. Romero, and Y. Cao (2020), arXiv:2003.01862
.

68

Dalzell, A. M., A. W. Harrow, D. E. Koh, and R. L. La Placa

Egger, D. J., J. Marecek,

and S. Woerner (2020b),

(2020), Quantum 4, 264.

arXiv:2009.10095 .

Das, S., A. J. Wildridge, S. B. Vaidya, and A. Jung (2019),

arXiv:1903.08879 .

Dattani, N. S., and N. Bryans (2014), arXiv:1411.6758 .
Dawson, C. M., and M. A. Nielsen (2006), Quantum Info.

Comput. 6 (1), 81–95.

De, A. (2015), arXiv:1509.07905 .
Deb, K., S. Agrawal, A. Pratab, and T. Meyarivan (2000),
Proc. of the Parallel Problem Solving from Nature {VI}
Conference , 849.

Denchev, V. S., S. Boixo, S. V. Isakov, N. Ding, R. Babbush,
V. Smelyanskiy, J. Martinis, and H. Neven (2016), Phys.
Rev. X 6 (3), 031015.

Eisert, J., D. Hangleiter, N. Walk, I. Roth, D. Markham,
and E. Kasheﬁ (2019),

R. Parekh, U. Chabaud,
arXiv:1910.06343 .

Eisert, J., D. Hangleiter, N. Walk, I. Roth, D. Markham,
R. Parekh, U. Chabaud, and E. Kasheﬁ (2020), Nat. Rev.
Phys. 2 (7), 382.

Elben, A., B. Vermersch, R. van Bijnen, C. Kokail, T. Bry-
dges, C. Maier, M. K. Joshi, R. Blatt, C. F. Roos, and
P. Zoller (2020), Phys. Rev. Lett. 124 (1), 010504.

Elben, A., B. Vermersch, C. F. Roos, and P. Zoller (2019),

Physical Review A 99 (5), 052323.

Endo, S., S. C. Benjamin, and Y. Li (2018), Phys. Rev. X

Derby, C., and J. Klassen (2020), “A compact fermion to

8 (3), 031027.

qubit mapping,” arXiv:2003.06939 [quant-ph].

Endo, S., Z. Cai, S. C. Benjamin,

and X. Yuan (2020a),

Deutsch, D. (1985), Proc. Math. Phys. Sci. 400 (1818), 97.
Deutsch, I. H. (2020), PRX Quantum 1 (2), 020101.
Devitt, S. J., A. M. Stephens, W. J. Munro, and K. Nemoto

arXiv:2011.01382 .

Endo, S., I. Kurata, and Y. O. Nakagawa (2020b), Phys. Rev.

Res. 2 (3), 033281.

(2013), Nat. commun. 4 (1), 1.

Endo, S., J. Sun, Y. Li, S. C. Benjamin, and X. Yuan (2020c),

Dive, B., A. Pitchford, F. Mintert, and D. Burgarth (2018),

Phys. Rev. Lett. 125, 010501.

Quantum 2, 80.

van Enk, S. J., and C. W. J. Beenakker (2012), Phys. Rev.

Dodd, J. L., M. A. Nielsen, M. J. Bremner, and R. T. Thew

Lett. 108, 110503.

(2002), Phys. Rev. A 65, 040301.

Dong, D., C. Chen, H. Li,

and T.-J. Tarn (2008), IEEE
Transactions on Systems, Man, and Cybernetics, Part B
(Cybernetics) 38 (5), 1207.

Entropica Labs, (2019), “Entropicaqaoa,” .
Erhard, A., J. J. Wallman, L. Postler, M. Meth, R. Stricker,
E. A. Martinez, P. Schindler, T. Monz, J. Emerson, and
R. Blatt (2019), Nat. commun. 10 (1), 1.

Dongarra, J. J. (1987), International Conference on Super-

Evangelista, F. A., G. K.-L. Chan, and G. E. Scuseria (2019),

computing (Springer).

Douçot, B., and L. Ioﬀe (2012), Rep. Prog. Phys. 75 (7),

072001.

Du, Y., M.-H. Hsieh, T. Liu, and D. Tao (2020), Phys. Rev.

Res. 2 (3), 033125.

Dumitrescu, E. F., A. J. McCaskey, G. Hagen, G. R. Jansen,
T. D. Morris, T. Papenbrock, R. C. Pooser, D. J. Dean,
and P. Lougovski (2018), Phys. Rev. Lett. 120 (21), 210501.
Duncan, R., A. Kissinger, S. Perdrix, and J. Van De Wetering

J. Chem. Phys. 151 (24), 244112.

Faist, P., S. Nezami, V. V. Albert, G. Salton, F. Pastawski,
and J. Preskill (2020), Physical Review X

P. Hayden,
10 (4), 041018.

Fan, K. (1951), Proc. Natl. Acad. Sci. U. S. A. 37 (11), 760.
and S. Gutmann (2020a),
Farhi, E., D. Gamarnik,

arXiv:2004.09002 .

Farhi, E., D. Gamarnik,

and S. Gutmann (2020b),

arXiv:2005.08747 .

(2020), Quantum 4, 279.

Farhi, E.,

J. Goldstone,

and S. Gutmann (2002),

Dunjko, V., and H. J. Briegel (2018), Rep. Prog. Phys. 81 (7),

arXiv:0201031 .

074001.

Farhi, E.,

J. Goldstone,

and S. Gutmann (2014),

Dunjko, V., J. M. Taylor, and H. J. Briegel (2016), Phys.

arXiv:1411.4028 .

Rev. Lett. 117 (13), 130501.

Farhi, E., J. Goldstone, S. Gutmann, and M. Sipser (2000),

Dunjko, V., J. M. Taylor, and H. J. Briegel (2017), 2017
IEEE International Conference on Systems, Man, and Cy-
bernetics (SMC) , 282.

Dür, W., M. Skotiniotis, F. Fröwis, and B. Kraus (2014),

Phys. Rev. Lett. 112, 080801.

Dury, B., and O. Di Matteo (2020), arXiv:2009.00140 .
Ebadi, S., T. T. Wang, H. Levine, A. Keesling, G. Semeghini,
A. Omran, D. Bluvstein, R. Samajdar, H. Pichler, W. W.
Ho, et al. (2020), arXiv:2012.12281 .

arXiv:0001106 .

Farhi, E., J. Goldstone, S. Gutmann, and L. Zhou (2019),

arXiv:1910.08187 .

Farhi, E., and A. W. Harrow (2016), arXiv:1602.07674 .
Farhi, E., and H. Neven (2018), arXiv:1802.06002 .
Ferguson, R. R., L. Dellantonio, K. Jansen, A. A. Balushi,
W. Dür, and C. A. Muschik (2020), arXiv:2010.13940 .
Fermann, J. T., and E. F. Valeev (2020), arXiv:2007.12057 .
Festa, P., P. M. Pardalos, M. G. Resende, and C. C. Ribeiro

Edmunds, C., C. Hempel, R. Harris, V. Frey, T. Stace, and

(2002), Optim. Methods Softw. 17 (6), 1033.

M. Biercuk (2020), Phys. Rev. Res. 2 (1), 013156.

Efthymiou, S., S. Ramos-Calderer, C. Bravo-Prieto, A. Pérez-
Salinas, D. García-Martín, A. Garcia-Saez, J. I. Latorre,
and S. Carrazza (2020), arXiv:2009.01845 .

Egan, L., D. M. Debroy, C. Noel, A. Risinger, D. Zhu,
D. Biswas, M. Newman, M. Li, K. R. Brown, M. Cetina,
et al. (2020), arXiv:2009.11482 .

Egger, D. J., C. Gambella, J. Marecek, S. McFaddin,
M. Mevissen, R. Raymond, A. Simonetto, S. Woerner, and
E. Yndurain (2020a), IEEE Transactions on Quantum En-
gineering 10.1109/TQE.2020.3030314.

Feynman, R. P. (1982), Int. J. Theor. Phys. 21, 467.
Fingerhuth, M., T. Babej,

and C.

Ing

(2018),

arXiv:1810.13411 .

Finnila, A. B., M. Gomez, C. Sebenik, C. Stenson, and J. D.

Doll (1994), Chem. Phys. Lett. 219 (5-6), 343.

Fishman, M., S. R. White, and E. M. Stoudenmire (2020),

arXiv:2007.14822 .

Fitzpatrick, M., N. M. Sundaresan, A. C. Li, J. Koch, and

A. A. Houck (2017), Phys. Rev. X 7 (1), 011016.

Fleming, C., and B. Hu (2012), Ann. Phys. 327 (4), 1238.
Fletcher, A. S., P. W. Shor, and M. Z. Win (2008), IEEE

Transactions on Information Theory 54 (12), 5705.

69

Fletcher, R. (2000), Mathematics of Computation (John Wi-

ley & Sons, Ltd, Chichester, West Sussex England).

Fowler, A. G., M. Mariantoni, J. M. Martinis, and A. N.

Cleland (2012), Phys. Rev. A 86 (3), 032324.

Foxen, B., C. Neill, A. Dunsworth, P. Roushan, B. Chiaro,
A. Megrant, J. Kelly, Z. Chen, K. Satzinger, R. Barends,
et al. (2020), Phys. Rev. Lett. 125 (12), 120504.

França, D. S., and A. Hashagen (2018), J. Phys. A Math.

Gonzalez-Raya, T., R. Asensio-Perea, A. Martin, L. C. Céleri,
M. Sanz, P. Lougovski, and E. F. Dumitrescu (2021), PRX
Quantum 2 (2), 020328.

Goodfellow, I., J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-
Farley, S. Ozair, A. Courville, and Y. Bengio (2014), Adv.
Neural Inform. Process. Syst. , 2672.

Google, Q. A. (2021), Nature 595 (7867), 383.
Gosset, D., V. Kliuchnikov, M. Mosca, and V. Russo (2013),

Theor. 51 (39), 395302.

arXiv:1308.4134 .

Fujii, K., and K. Nakajima (2017), Phys. Rev. Appl. 8 (2),

024030.

Gaitan, F. (2020), npj Quantum Inf. 6 (1), 1.
Galicia, A., B. Ramon, E. Solano, and M. Sanz (2020), Phys.

Rev. Res. 2 (3), 033103.

Gambetta, J. M., A. D. Córcoles, S. T. Merkel, B. R. Johnson,
J. A. Smolin, J. M. Chow, C. A. Ryan, C. Rigetti, S. Po-
letto, T. A. Ohki, et al. (2012), Phys. Rev. Lett. 109 (24),
240504.

Gottesman, D. (1997), arXiv:9705052 .
Gottlieb, D., and S. A. Orszag (1977), Numerical analysis of

spectral methods: theory and applications (SIAM).

Gould, S. H. (2012), Variational methods for eigenvalue prob-
lems: an introduction to the methods of Rayleigh, Ritz, We-
instein, and Aronszajn (Courier Corporation).

de

la Grand’rive, P. D.,

and J.-F. Hullo (2019),

arXiv:1908.02210 .

Grant, E., L. Wossnig, M. Ostaszewski, and M. Benedetti

Gambetta, J. M., F. Motzoi, S. Merkel, and F. K. Wilhelm

(2019), Quantum 3, 214.

(2011), Phys. Rev. A 83 (1), 012308.

Ganzhorn, M., D. Egger, P. Barkoutsos, P. Ollitrault, G. Salis,
N. Moll, M. Roth, A. Fuhrer, P. Mueller, S. Woerner,
I. Tavernelli, and S. Filipp (2019), Phys. Rev. Appl. 11 (4),
044092.

Gao, X., E. R. Anschuetz, S.-T. Wang, J. I. Cirac, and M. D.

Lukin (2021), arXiv preprint arXiv:2101.08354 .
García-Álvarez, L., J. Casanova, A. Mezzacapo,

I. L.
Egusquiza, L. Lamata, G. Romero, and E. Solano (2015),
Phys. Rev. Lett. 114, 070502.

Gray, J. (2018), J. Open Source Softw. 3 (29), 819.
Greenbaum, D. (2015), arXiv:1509.02921 .
Greenberger, D. M., M. A. Horne, A. Shimony,
A. Zeilinger (1990), Am. J. Phys. 58 (12), 1131.

and

Gregorcic, G. (2001), matrix 2 (1), 2.
de Griend, A. M.-v., and R. Duncan (2020), arXiv:2004.06052

.

Grimsley, H. R., D. Claudino, S. E. Economou, E. Barnes,
and N. J. Mayhall (2019a), J. Chem. Theory Comput. .
Grimsley, H. R., S. E. Economou, E. Barnes, and N. J. May-

García-Molina, P., A. Martin, and M. Sanz (2021), arXiv

hall (2019b), Nat. commun. 10 (1), 1.

preprint arXiv:2107.12969.

Garcia-Saez, A., and J. Latorre (2018), arXiv:1806.02287 .
Garcia-Saez, A., and J. Riu (2019), arXiv:1911.09682 .
Gard, B. T., L. Zhu, G. S. Barron, N. J. Mayhall, S. E.
Economou, and E. Barnes (2020), npj Quantum Inf. 6 (1),
1.

Gross, C., and I. Bloch (2017), Science 357 (6355), 995.
Guerreschi, G. G., J. Hogaboam, F. Baruﬀa,

and N. P.

Sawaya (2020), Quantum Sci. Technol. 5 (3), 034007.

de Guise, H., O. Di Matteo, and L. L. Sánchez-Soto (2018),

Phys. Rev. A 97, 022328.

Gurvits, L. (2003), Proceedings of the thirty-ﬁfth annual

Garhwal, S., M. Ghorani, and A. Ahmad (2019), Arch. Com-

ACM symposium on Theory of computing , 10.

putat. Methods Eng. , 1.

Hadﬁeld, C., S. Bravyi, R. Raymond,

and A. Mezzacapo

Gay, S. J. (2006), Math. Struct. Comp. Sci. 16 (4), 581.
Georgescu, I. M., S. Ashhab, and F. Nori (2014), Rev. Mod.

Phys. 86 (1), 153.

Gheorghiu, V., S. M. Li, M. Mosca, and P. Mukhopadhyay

(2020), arXiv:2011.12191 .

Ghosh, S., A. Opala, M. Matuszewski, T. Paterek, and T. C.

Liew (2019), npj Quantum Inf. 5 (1), 1.

Gilyén, A., S. Lloyd, and E. Tang (2018), arXiv:1811.04909 .
Giovannetti, V., S. Lloyd, and L. Maccone (2008), Phys. Rev.

(2020), arXiv:2006.15788 .

Hadﬁeld, S., Z. Wang, B. O’Gorman, E. G. Rieﬀel, D. Ven-
and R. Biswas (2019), Algorithms 12 (2),

turelli,
10.3390/a12020034.

Hadﬁeld, S., Z. Wang, E. G. Rieﬀel, B. O’Gorman, D. Ven-
turelli, and R. Biswas (2017), Proceedings of the Second
International Workshop on Post Moores Era Supercomput-
ing , 15–21.

Häﬀner, H., C. F. Roos, and R. Blatt (2008), Phys. Rep.

Lett. 100, 160501.

469 (4), 155.

Giurgica-Tiron, T., Y. Hindy, R. LaRose, A. Mari, and W. J.

Zeng (2020), arXiv:2005.10921 .

Hallberg, K. A. (2006), Adv. Phys. 55 (5-6), 477.
Halperin, E., D. Livnat, and U. Zwick (2004), J. Algorithms

Goemans, M. X.,

and D. P. Williamson (1995), J. ACM

53 (2), 169 .

42 (6), 1115–1145.

Hamamura, I., and T. Imamichi (2020), npj Quantum Inf.

Gokhale, P., O. Angiuli, Y. Ding, K. Gui, T. Tomesh,
and F. T. Chong (2019),

M. Suchara, M. Martonosi,
arXiv:1907.13623 .

Gokhale, P., and F. T. Chong (2019), arXiv:1908.11857 .
Goldman, N., and J. Dalibard (2014), Phys. Rev. X 4 (3),

031027.

Gomes, N., A. Mukherjee, F. Zhang, T. Iadecola, C.-Z. Wang,
K.-M. Ho, P. P. Orth, and Y.-X. Yao (2021), “Adaptive
variational quantum imaginary time evolution approach
for quantum chemistry calculations,” arXiv:2102.01544
[physics.chem-ph].

6 (1), 1.

Hamilton, C. S., R. Kruse, L. Sansoni, S. Barkhofen, C. Sil-
berhorn, and I. Jex (2017), Phys. Rev. Lett. 119 (17),
170501.

Hamilton, K. E., E. F. Dumitrescu, and R. C. Pooser (2019),

Phys. Rev. A 99 (6), 062323.

Hammersley, J. (2013), Monte carlo methods (Springer Sci-

ence & Business Media).

Hanks, M., M. P. Estarellas, W. J. Munro, and K. Nemoto

(2020), Phys. Rev. X 10, 041030.

Hansen, N., S. D. Müller, and P. Koumoutsakos (2003), Evol.

Comput. 11 (1), 1.

Harper, R., and S. T. Flammia (2017), Quantum Sci. Tech-

Hofmann, T., B. Schölkopf, and A. J. Smola (2008), Ann.

nol. 2 (1), 015008.

Stat. , 1171.

70

Harrigan, M. P., K. J. Sung, M. Neeley, K. J. Satzinger,
F. Arute, K. Arya, J. Atalaya, J. C. Bardin, R. Barends,
S. Boixo, et al. (2021), Nature Physics 17 (3), 332.
Harrow, A., and J. Napp (2019), arXiv:1901.05374 .
Harrow, A. W. (2020), arXiv preprint arXiv:2004.00026 .
Harrow, A. W., A. Hassidim, and S. Lloyd (2009), Phys. Rev.

Lett. 103 (15), 150502.

Härtle, R., C. Benesch, and M. Thoss (2008), Phys. Rev. B

77 (20), 205314.

Holmes, Z., A. Arrasmith, B. Yan, P. J. Coles, A. Albrecht,

and A. T. Sornborger (2020), arXiv:2009.14808 .

Holmes, Z., K. Sharma, M. Cerezo, and P. J. Coles (2021),

arXiv:2101.02138 .
(2021),

Honeywell,

“Honeywell

sets

another

record
https:

quantum

computing

for
//www.honeywell.com/us/en/news/2021/07/
honeywell-sets-another-record-for-quantum-computing-performance,
(Accessed on 09/02/2021).

performance,”

Hartmann, M. J. (2016), J. Opt. 18 (10), 104005.
Hashagen, A., S. Flammia, D. Gross, and J. Wallman (2018),

Horodecki, M., P. Horodecki, and R. Horodecki (1999), Phys.

Rev. A 60 (3), 1888.

Quantum 2, 85.

Houck, A. A., H. E. Türeci, and J. Koch (2012), Nat. Phys.

Hastings, M. B. (2019), arXiv:1905.07047 .
Hastings, M. B. (2020), arXiv:2005.03791 .
Haug, T., and K. Bharti (2020), arXiv:2011.14737 .
Haug, T., K. Bharti, and M. Kim (2021a), arXiv preprint

arXiv:2102.01659 .

Haug, T., R. Dumke, L.-C. Kwek, C. Miniatura, and L. Am-

ico (2021b), Phys. Rev. Research 3, 013034.

Haug, T., and M. S. Kim (2021a), arXiv:2107.14063 .
Haug, T., and M. S. Kim (2021b), arXiv:2104.14543 .
Haug, T., C. N. Self,

and M. S. Kim (2021c),

arXiv:2108.01039 .

Hauke, P., H. G. Katzgraber, W. Lechner, H. Nishimori, and
W. D. Oliver (2020), Rep. Prog. Phys. 83 (5), 054401.
Hauke, P., D. Marcos, M. Dalmonte, and P. Zoller (2013),

Phys. Rev. X 3, 041018.

Havlíček, V., A. D. Córcoles, K. Temme, A. W. Harrow,
A. Kandala, J. M. Chow, and J. M. Gambetta (2019),
Nature 567 (7747), 209.

8 (4), 292.

Håstad, J. (2001), J. ACM 48 (4), 798–859.
Hu, L., S.-H. Wu, W. Cai, Y. Ma, X. Mu, Y. Xu, H. Wang,
Y. Song, D.-L. Deng, C.-L. Zou, et al. (2019), Sci. Adv.
5 (1), eaav2761.

Hu, Z., R. Xia, and S. Kais (2020), Sci. Rep. 10 (1), 1.
Huang, C.-J., H. Ma, Q. Yin, J.-F. Tang, D. Dong, C. Chen,
G.-Y. Xiang, C.-F. Li, and G.-C. Guo (2020a), Phys. Rev.
A 102, 032412.

Huang, H.-L., Y. Du, M. Gong, Y. Zhao, Y. Wu,
C. Wang, S. Li, F. Liang, J. Lin, Y. Xu, et al. (2020b),
arXiv:2010.06201 .

Huang, H.-Y., K. Bharti,

and P. Rebentrost (2019),

arXiv:1909.07344 .

Huang, H.-Y., M. Broughton, M. Mohseni, R. Babbush,
S. Boixo, H. Neven, and J. R. McClean (2021), Nature
communications 12 (1), 1.

Huang, H.-Y., R. Kueng, and J. Preskill (2020c), Nat. Phys.

Headley, D., T. Müller, A. Martin, E. Solano, M. Sanz, and

16, 1050.

F. K. Wilhelm (2020), arXiv:2002.12215 .

Heim, B., M. Soeken, S. Marshall, C. Granade, M. Roetteler,
A. Geller, M. Troyer, and K. Svore (2020), Nat. Rev. Phys.
, 1.

Helsen, J., X. Xue, L. M. Vandersypen,

and S. Wehner

Huang, K., Z.-A. Wang, C. Song, K. Xu, H. Li, Z. Wang,
Q. Guo, Z. Song, Z.-B. Liu, D. Zheng, et al. (2020d),
arXiv:2009.12827 .

Huang, L., and L. Wang (2017), Phys. Rev. B 95 (3), 035105.
Huembeli, P., and A. Dauphin (2021), Quantum Science and

(2019), npj Quantum Inf. 5 (1), 1.

Technology 6 (2), 025011.

Helstrom, C. W. (1969), J. Stat. Phys. 1 (2), 231.
Hen, I., and M. S. Sarandy (2016), Phys. Rev. A 93, 062312.
Hen, I., and F. M. Spedalieri (2016), Phys. Rev. Appl. 5,

034007.

Hensgens, T., T. Fujita, L. Janssen, X. Li, C. Van Diepen,
C. Reichl, W. Wegscheider, S. D. Sarma, and L. M. Van-
dersypen (2017), Nature 548 (7665), 70.

Herbst, M. F. (2018), Development of a modular quantum-
chemistry framework for the investigation of novel basis
functions, Ph.D. thesis (Ruprecht-Karls-Universität Hei-
delberg).

Huggins, W. J., J. Lee, U. Baek, B. O’Gorman, and K. B.

Whaley (2020), New J. Phys. 22, 073009.

Huggins, W. J., J. McClean, N. Rubin, Z. Jiang, N. Wiebe,
K. B. Whaley, and R. Babbush (2019), arXiv:1907.13117 .
Hughes, A., V. Schäfer, K. Thirumalai, D. Nadlinger,
S. Woodrow, D. Lucas, and C. Ballance (2020), Phys. Rev.
Lett. 125 (8), 080504.

Huh, J., G. G. Guerreschi, B. Peropadre, J. R. McClean, and

A. Aspuru-Guzik (2015), Nat. Photonics 9 (9), 615.

Huh, J., S. Mostame, T. Fujita, M.-H. Yung, and A. Aspuru-

Guzik (2014), New J. Phys. 16 (12), 123008.

Herr, D., B. Obert,

and M. Rosenkranz (2020), arXiv

Huyer, W., and A. Neumaier (2008), ACM Transactions on

preprint arXiv:2010.10492 .

Heya, K., K. M. Nakanishi, K. Mitarai, and K. Fujii (2019),

arXiv:1904.08566 .

Heyfron, L. E., and E. T. Campbell (2018), Quantum Science

and Technology 4 (1), 015004.

Mathematical Software 35 (2), 1.

IBM, (2020), “IBM delivers its highest quantum volume to
date, expanding the computational power of its ibm cloud-
accessible quantum computers,” https://t.ly/hoPX, [Ac-
cessed: 25-October-2020].

Higgott, O., D. Wang, and S. Brierley (2019), Quantum 3,

IBMQ, (2019), “Qiskit: An open-source framework for quan-

156.

Ho, W. W., and T. H. Hsieh (2019), SciPost Phys. 6, 29.
Ho, W. W., C. Jonay, and T. H. Hsieh (2019), Phys. Rev. A

99, 052332.

tum computing,” 10.5281/zenodo.2562110.

Inagaki, T., Y. Haribara, K. Igarashi, T. Sonobe, S. Tamate,
T. Honjo, A. Marandi, P. L. McMahon, T. Umeki, K. En-
butsu, et al. (2016), Science 354 (6312), 603.

Hodson, M., B. Ruck, H. Ong, D. Garvin, and S. Dulman

Itoko, T., R. Raymond, T. Imamichi, and A. Matsuo (2020),

(2019), arXiv:1911.05296 .

Integration 70, 43.

Itoko, T., R. Raymond, T. Imamichi, A. Matsuo, and A. W.
Cross (2019), Proceedings of the 24th Asia and South Pa-
ciﬁc Design Automation Conference , 191.

Izmaylov, A. F., M. Díaz-Tinoco, and R. A. Lang (2020),

Phys. Chem. Chem. Phys. 22, 12980.

Izmaylov, A. F., T.-C. Yen, R. A. Lang, and V. Verteletskyi

(2019a), J. Chem. Theory Comput. 16 (1), 190.

Izmaylov, A. F., T.-C. Yen, and I. G. Ryabinkin (2019b),

Chem. Sci. 10 (13), 3746.

Karamlou, A. H., W. A. Simon, A. Katabarwa, T. L. Scholten,
B. Peropadre, and Y. Cao (2020), arXiv:2012.07825 .

71

Kassal,

I.,

Journal
of Chemical Physics
https://doi.org/10.1063/1.3266959.

and A. Aspuru-Guzik
131

(2009), The
224102,

(22),

Kaubruegger, R., P. Silvi, C. Kokail, R. van Bijnen, A. M.
Rey, J. Ye, A. M. Kaufman, and P. Zoller (2019), Phys.
Rev. Lett. 123 (26), 260505.

Kempe, J., A. Kitaev, and O. Regev (2006), SIAM J. Com-

Jaderberg, B., A. Agarwal, K. Leonhardt, M. Kiﬀner, and

put. 35 (5), 1070.

D. Jaksch (2020), Quantum Sci. Technol. 5, 034015.

Khairy, S., R. Shaydulin, L. Cincio, Y. Alexeev, and P. Bal-

Jahangiri, S., J. M. Arrazola,

and A. Delgado (2020a),

arXiv:2012.09231 .

Jahangiri, S., J. M. Arrazola, N. Quesada, and N. Killoran

(2020b), Phys. Rev. E 101, 022134.

JavadiAbhari, A., S. Patil, D. Kudrow, J. Heckey, A. Lvov,
F. T. Chong, and M. Martonosi (2014), Proceedings of the
11th ACM Conference on Computing Frontiers , 1.

Jensen, P. W. K., L. B. Kristensen, J. S. Kottmann, and
A. Aspuru-Guzik (2020), Quantum Sci. Technol. 6 (1),
015004.

aprakash (2019), arXiv:1911.04574 .
Khammassi, N., G. G. Guerreschi,

Hogaboam, C. G. Almudever,
arXiv:1805.09607 .

I. Ashraf, J. W.
and K. Bertels (2018),

Khatri, S., R. LaRose, A. Poremba, L. Cincio, A. T. Sorn-

borger, and P. J. Coles (2019), Quantum 3, 140.

Khodjasteh, K.,

and L. Viola (2009), Phys. Rev. Lett.

102 (8), 080501.

Kieferová, M.,

and N. Wiebe (2017), Phys. Rev. A 96,

062327.

Jerbi, S., L. M. Trenkwalder, H. P. Nautrup, H. J. Briegel,

Killoran, N., J. Izaac, N. Quesada, V. Bergholm, M. Amy,

and V. Dunjko (2019), arXiv:1910.12760 .

and C. Weedbrook (2019), Quantum 3, 129.

Jiang, Z., A. Kalev, W. Mruczkiewicz, and H. Neven (2020),

Kirby, W. M.,

and P. J. Love (2019), Phys. Rev. Lett.

Quantum 4, 276.

123 (20), 200501.

Johansson, J., P. Nation, and F. Nori (2012), Comput. Phys.

Kirby, W. M., A. Tranter,

and P. J. Love (2020),

Commun. 183 (8), 1760 .

arXiv:2011.10027 .

Johnson, P. D., J. Romero, J. Olson, Y. Cao, and A. Aspuru-

Kissinger, A.,

and A. M.-v. de Griend (2019),

Guzik (2017), arXiv:1711.02249 .

arXiv:1904.00633 .

Jones, N. C., R. Van Meter, A. G. Fowler, P. L. McMahon,
J. Kim, T. D. Ladd, and Y. Yamamoto (2012), Phys. Rev.
X 2 (3), 031007.

Jones, T. (2020), arXiv:2011.02991 .
Jones, T., and S. C. Benjamin (2020), Quantum Sci. Technol.

Kissinger, A.,

and J.

van de Wetering

(2019),

arXiv:1903.10477 .

Kissinger, A., and J. van de Wetering (2020a), Proceedings

QPL 2019 318, 229.

Kissinger, A., and J. van de Wetering (2020b), Phys. Rev. A

5, 034012.

102, 022406.

Jones, T., A. Brown, I. Bush, and S. C. Benjamin (2019a),

Sci. Rep. 9, 10736.

Jones, T., S. Endo, S. McArdle, X. Yuan, and S. C. Benjamin

(2019b), Phys. Rev. A 99 (6), 062304.

Joó, B., C. Jung, N. H. Christ, W. Detmold, R. G. Ed-
wards, M. Savage, and P. Shanahan (2019), Eur. Phys.
J. A 55 (11), 199.

Jordan, P., and O. Klein (1927), Z. Phys. 45 (11-12), 751.
Jordan, P., and E. P. Wigner (1928), Z. Phys. 47 (631), 14.
Jørgensen, P. (2012), Second quantization-based methods in

quantum chemistry (Elsevier).

Joshi, M. K., A. Elben, B. Vermersch, T. Brydges, C. Maier,
P. Zoller, R. Blatt, and C. F. Roos (2020), Phys. Rev. Lett.
124, 240505.

Jouzdani, P., and S. Bringuier (2020), arXiv:2008.11347 .
Kadowaki, T., and H. Nishimori (1998), Phys. Rev. E 58 (5),

5355.

Kaiser, D. (2011), How the hippies saved physics: science,
counterculture, and the quantum revival (WW Norton &
Company).

Kako, S., T. Leleu, Y. Inui, F. Khoyratee, S. Reifenstein, and
Y. Yamamoto (2020), Adv. Quantum Technol. , 2000045.
Kandala, A., A. Mezzacapo, K. Temme, M. Takita, M. Brink,
and J. M. Gambetta (2017), Nature

J. M. Chow,
549 (7671), 242.

Kitaev, A. Y. (2003), Ann. Phys. 303 (1), 2.
Kivlichan,

I. D., J. McClean, N. Wiebe, C. Gidney,
A. Aspuru-Guzik, G. K.-L. Chan, and R. Babbush (2018),
Phys. Rev. Lett. 120, 110501.

Kivlichan, I. D., N. Wiebe, R. Babbush, and A. Aspuru-
Guzik (2017), J. Phys. A Math. Theor. 50 (30), 305301.
Kjaergaard, M., M. E. Schwartz, J. Braumüller, P. Krantz,
J. I.-J. Wang, S. Gustavsson, and W. D. Oliver (2020),
Annu. Rev. Condens. Matter Phys. 11, 369.

Klco, N., E. F. Dumitrescu, A. J. McCaskey, T. D. Morris,
R. C. Pooser, M. Sanz, E. Solano, P. Lougovski, and M. J.
Savage (2018), Phys. Rev. A 98, 032331.

Klema, V., and A. Laub (1980), IEEE Transactions on au-

tomatic control 25 (2), 164.

Klymko, C., B. D. Sullivan, and T. S. Humble (2014), Quan-

tum Inf. Process. 13 (3), 709.

Knill, E., and R. Laﬂamme (1997), Phys. Rev. A 55 (2), 900.
Knill, E., R. Laﬂamme, and W. H. Zurek (1998), Science

279 (5349), 342.

Koczor, B., and S. C. Benjamin (2019), arXiv:1912.08660 .
Koczor, B., and S. C. Benjamin (2020), arXiv:2008.13774 .
Koczor, B., S. Endo, T. Jones, Y. Matsuzaki,
Benjamin (2020), New J. Phys. 22, 083038.

and S. C.

Koh, D. E.,

and S. Grewal

(2020), arXiv preprint

arXiv:2011.11580 .

Kandala, A., K. Temme, A. D. Córcoles, A. Mezzacapo, J. M.
Chow, and J. M. Gambetta (2019), Nature 567 (7749),
491.

Kokail, C., C. Maier, R. van Bijnen, T. Brydges, M. K. Joshi,
P. Jurcevic, C. A. Muschik, P. Silvi, R. Blatt, C. F. Roos,
et al. (2019), Nature 569 (7756), 355.

72

Koppenhöfer, M., C. Bruder, and A. Roulet (2020), Phys.

Kyriienko, O., A. E. Paine,

and V. E. Elfving (2020),

Rev. Res. 2 (2), 023026.

arXiv:2011.10395 .

Koren, Y., R. Bell, and C. Volinsky (2009), Computer 42 (8),

Kyriienko, O., and A. S. Sørensen (2018), Phys. Rev. Appl.

30.

9 (6), 064029.

Kosut, R. L., and D. A. Lidar (2009), Quantum Inf. Process.

Kübler, J. M., A. Arrasmith, L. Cincio,

and P. J. Coles

8 (5), 443.

Kosut, R. L., A. Shabani, and D. A. Lidar (2008), Phys. Rev.

Lett. 100 (2), 020502.

Kottmann, J. S. (2018), Coupled-Cluster in Real Space, Ph.D.
thesis (Humboldt-Universität zu Berlin, Mathematisch-
Naturwissenschaftliche Fakultät).

Kottmann, J. S., S. Alperin-Lea, T. Tamayo-Mendoza,
A. Cervera-Lierta, C. Lavigne, T.-C. Yen, V. Verteletskyi,
P. Schleich, A. Anand, M. Degroote, S. Chaney, M. Kesibi,
N. G. Curnow, B. Solo, G. Tsilimigkounakis, C. Zendejas-
Morales, A. F. Izmaylov, and A. Aspuru-Guzik (2021a),
Quantum Science and Technology 6 (2), 024009.

Kottmann, J. S., A. Anand, and A. Aspuru-Guzik (2021b),

Chem. Sci. 12, 3497.

(2020), Quantum 4, 10.22331/q-2020-05-11-263.

Lacroix, N., C. Hellings, C. K. Andersen, A. Di Paolo,
A. Remm, S. Lazar, S. Krinner, G. J. Norris, M. Gabureac,
J. Heinsoo, et al. (2020), PRX Quantum 1 (2), 110304.

Lamata, L. (2017), Sci. Rep. 7 (1), 1.
Lamata, L., U. Alvarez-Rodriguez, J. D. Martín-Guerrero,
M. Sanz, and E. Solano (2018a), Quantum Sci. Technol.
4 (1), 014007.

Lamata, L., A. Parra-Rodriguez, M. Sanz, and E. Solano

(2018b), Adv. Phys.: X 3 (1), 1457981.

Landsman, K. A., C. Figgatt, T. Schuster, N. M. Linke,
B. Yoshida, N. Y. Yao, and C. Monroe (2019), Nature
567 (7746), 61.

Lang, R. A., I. G. Ryabinkin, and A. F. Izmaylov (2020),

Kottmann, J. S., and F. A. Bischoﬀ (2017), J. Chem. Theory

arXiv:2002.05701 .

Comput. 13 (12), 5945.

LaRose, R., A. Mari, P. J. Karalekas, N. Shammah, and

Kottmann, J. S., M. Krenn, T. H. Kyaw, S. Alperin-Lea, and

W. J. Zeng (2020), arXiv:2009.04417 .

A. Aspuru-Guzik (2020), arXiv:2006.03075 .

LaRose, R., A. Tikku, É. O’Neel-Judy, L. Cincio, and P. J.

Kottmann, J. S., P. Schleich, T. Tamayo-Mendoza,

and
A. Aspuru-Guzik (2021c), J. Phys. Chem. Lett. 12 (1), 663.
Krantz, P., M. Kjaergaard, F. Yan, T. P. Orlando, S. Gus-
tavsson, and W. D. Oliver (2019), Applied Physics Reviews
6 (2), 021318.

Coles (2019), npj Quantum Inf. 5 (1), 1.

Las Heras, U., U. Alvarez-Rodriguez, E. Solano, and M. Sanz

(2016a), Phys. Rev. Lett. 116 (23), 230504.

Las Heras, U., U. Alvarez-Rodriguez, E. Solano, and M. Sanz

(2016b), Phys. Rev. Lett. 116, 230504.

Krenn, M., M. Erhard, and A. Zeilinger (2020a), Nat Rev

Lau, J. W. Z., K. Bharti, T. Haug, and L. C. Kwek (2021a),

Phys 2, 649–661.

arXiv:2101.07677 .

Krenn, M., J. Kottmann, N. Tischler, and A. Aspuru-Guzik

Lau, J. W. Z., T. Haug, L. C. Kwek, and K. Bharti (2021b),

(2020b), arXiv:2005.06443 .

arXiv preprint arXiv:2103.05500 .

Kreula, J., S. R. Clark, and D. Jaksch (2016), Sci. Rep. 6,

Lavrijsen, W.,

and the scikit-quant contributors (2020),
https://github.com/scikit-quant/

32940.

Krinner, S., P. Kurpiers, B. Royer, P. Magnard, I. Tsitsilin,
J.-C. Besse, A. Remm, A. Blais, and A. Wallraﬀ (2020),
Phys. Rev. Appl. 14 (4), 044039.

Kruse, R., C. S. Hamilton, L. Sansoni, S. Barkhofen, C. Sil-
berhorn, and I. Jex (2019), Phys. Rev. A 100 (3), 032326.
and S. Nagayama

Kubo, K., Y. O. Nakagawa, S. Endo,

“scikit-quant,”
scikit-quant.

Lavrijsen, W., A. Tudor, J. Müller, C. Iancu, and W. de Jong

(2020), arXiv:2004.03004 .

Lechner, W. (2020), IEEE Transactions on Quantum Engi-

neering 1, 1.

Lechner, W., P. Hauke, and P. Zoller (2015), Sci. Adv. 1 (9),

(2020), arXiv:2012.04429 .

e1500838.

Kunitsa, A. A., and S. Hirata (2020), Phys. Rev. E 101,

Lee, C.-K., J. W. Z. Lau, L. Shi, and L. C. Kwek (2021),

013311.

arXiv:2101.06879 .

Kusumoto, T., K. Mitarai, K. Fujii, M. Kitagawa, and M. Ne-

Lee, J., W. J. Huggins, M. Head-Gordon, and K. B. Whaley

goro (2019), arXiv:1911.12021 .

(2018), J. Chem. Theory Comput. 15 (1), 311.

Kwon, H.,

and J. Bae (2020), IEEE Trans. Comput.

Lenstra, J. K., and A. R. Kan (1975), Journal of the Opera-

10.1109/TC.2020.3009664.

tional Research Society 26 (4), 717.

Kyaw, T., S. Felicetti, G. Romero, E. Solano, and L. C. Kwek

Leung, D. W., M. A. Nielsen, I. L. Chuang, and Y. Yamamoto

(2014a), Proc. SPIE. XII 9225, 92250B.

(1997), Physical Review A 56 (4), 2567.

Kyaw, T. H. (2019), Towards a Scalable Quantum Computing
Platform in the Ultrastrong Coupling Regime (Springer).
Kyaw, T. H., S. Allende, L.-C. Kwek, and G. Romero (2017),

Quantum Sci. Technol. 2 (2), 025007.

Kyaw, T. H., V. M. Bastidas, J. Tangpanitanon, G. Romero,
and L.-C. Kwek (2020a), Phys. Rev. A 101 (1), 012111.
Kyaw, T. H., S. Felicetti, G. Romero, E. Solano, and L.-C.

Kwek (2015a), Sci. Rep. 5, 8621.

Kyaw, T. H., D. A. Herrera-Marti, E. Solano, G. Romero,
and L.-C. Kwek (2015b), Phys. Rev. B 91 (6), 064503.
Kyaw, T. H., Y. Li, and L.-C. Kwek (2014b), Phys. Rev.

Lett. 113 (18), 180501.

Kyaw, T. H., T. Menke, S. Sim, N. P. Sawaya, W. D.
Oliver, G. G. Guerreschi, and A. Aspuru-Guzik (2020b),
arXiv:2006.03070 .

Leyton-Ortega, V., A. Perdomo-Ortiz,

and O. Perdomo

(2019), arXiv:1901.08047 .

Li, A. C., F. Petruccione, and J. Koch (2016), Phys. Rev. X

6 (2), 021037.
Li, G., Y. Ding,

and Y. Xie (2019), Proceedings of the
Twenty-Fourth International Conference on Architectural
Support for Programming Languages and Operating Sys-
tems , 1001.

Li, J., X. Yang, X. Peng, and C.-P. Sun (2017a), Phys. Rev.

Lett. 118 (15), 150503.

Li, L., M. Fan, M. Coram, P. Riley,
(2020), Phys. Rev. Res. 2, 023074.

and S. Leichenauer

Li, R., U. Alvarez-Rodriguez, L. Lamata,

and E. Solano

(2017b), Quantum Meas. Quantum Metrol. 4 (1), 1.

Rev. Res. 1 (2), 023025.
Liu, Z., L.-M. Duan,

arXiv:2008.05488 .

73

Li, R. Y., R. Di Felice, R. Rohs, and D. A. Lidar (2018), npj

Quantum inf. 4 (1), 1.

Li, W., and D.-L. Deng (2021), arXiv:2108.13421 .
Li, Y.,

and S. C. Benjamin (2017), Phys. Rev. X 7 (2),

Manne, A. S. (1960), Oper. Res. 8 (2), 219.
Marandi, A., Z. Wang, K. Takata, R. L. Byer, and Y. Ya-

mamoto (2014), Nat. Photonics 8 (12), 937.

Mari, A., T. R. Bromley,

and N. Killoran (2020),

021050.

arXiv:2008.06517 .

Lidar, D. A. (2014), Adv. Chem. Phys 154, 295.
Lidar, D. A., and T. A. Brun (2013), Quantum error correc-

Markowitz, H. (1952), The Journal of Finance 7 (1), 77.
Marrero, C. O., M. Kieferová,

and N. Wiebe (2020),

tion (Cambridge university press).

aarXiv:2010.15968 .

Lim, K. H., T. Haug, L. C. Kwek, and K. Bharti (2021),

Martin, A., L. Lamata, E. Solano, and M. Sanz (2020), Phys.

arXiv:2104.01931 .

Rev. Res. 2 (1), 013012.

Liu, D. C., and J. Nocedal (1989), Math. Program. 45 (1-3),

503.

Liu, J., Z. Li, and J. Yang (2020a), arXiv:2012.07047 .
Liu, J., Y. Qi, Z. Y. Meng, and L. Fu (2017), Phys. Rev. B

95, 041101.

Martinez, E. A., C. A. Muschik, P. Schindler, D. Nigg, A. Er-
hard, M. Heyl, P. Hauke, M. Dalmonte, T. Monz, P. Zoller,
et al. (2016), Nature 534 (7608), 516.

Marzec, M. (2016), Handbook of High-Frequency Trading and

Modeling in Finance , 73.

Liu, J., and Y. Xin (2020), J. High Energ. Phys. 2020, 11.
Liu, J.-G., and L. Wang (2018), Phys. Rev. A 98 (6), 062324.
Liu, J.-G., Y.-H. Zhang, Y. Wan, and L. Wang (2019), Phys.

Massey, P., J. A. Clark, and S. Stepney (2004), Genetic and

Evolutionary Computation Conference , 569.

Massey, P., J. A. Clark, and S. Stepney (2006), Evol. Com-

and D.-L. Deng

(2020b),

McArdle, S., S. Endo, A. Aspuru-Guzik, S. C. Benjamin, and

put. 14 (1), 21.

Lloyd, S. (1996), Science 273, 1073.
Lloyd, S. (2018), arXiv:1812.11075 .
Lloyd, S., M. Mohseni,

and P. Rebentrost

arXiv:1307.0411 .

X. Yuan (2020), Rev. Mod. Phys. 92 (1), 015003.

McArdle, S., T. Jones, S. Endo, Y. Li, S. C. Benjamin, and

X. Yuan (2019a), npj Quantum Inf. 5 (1), 1.

(2013),

McArdle, S., A. Mayorov, X. Shan, S. Benjamin, and X. Yuan

(2019b), Chem. Sci. 10 (22), 5725.

Lloyd, S., M. Schuld, A. Ijaz, J. Izaac, and N. Killoran (2020),

McArdle, S., X. Yuan, and S. Benjamin (2019c), Phys. Rev.

arXiv:2001.03622 .

Lett. 122 (18), 180501.

Lloyd, S.,

and C. Weedbrook (2018), Phys. Rev. Lett.

121 (4), 040502.

Lockwood, O., and M. Si (2020a), NeurIPS .
Lockwood, O., and M. Si (2020b), Proceedings of the AAAI
Conference on Artiﬁcial Intelligence and Interactive Digital
Entertainment 16 (1), 245.

McCaskey, A. J., D. I. Lyakh, E. F. Dumitrescu, S. S. Powers,
and T. S. Humble (2020), Quantum Sci. Technol. 5 (2),
024002.

McClean, J., N. Rubin, K. Sung, I. D. Kivlichan, X. Bonet-
Monroig, Y. Cao, C. Dai, E. S. Fried, C. Gidney, B. Gimby,
et al. (2020a), Quantum Sci. Technol. .

Lowe, A., M. H. Gordon, P. Czarnik, A. Arrasmith, P. J.

McClean, J. R., S. Boixo, V. N. Smelyanskiy, R. Babbush,

Coles, and L. Cincio (2020), arXiv:2011.01157 .

and H. Neven (2018), Nat. Commun. 9 (1), 1.

Lu, D., K. Li, J. Li, H. Katiyar, A. J. Park, G. Feng, T. Xin,
H. Li, G. Long, A. Brodutch, et al. (2017), npj Quantum
Inf. 3 (1), 1.

McClean, J. R., M. P. Harrigan, M. Mohseni, N. C. Rubin,
Z. Jiang, S. Boixo, V. N. Smelyanskiy, R. Babbush, and
H. Neven (2020b), arXiv:2008.08615 .

Lubasch, M., J. Joo, P. Moinier, M. Kiﬀner, and D. Jaksch

McClean, J. R., Z. Jiang, N. C. Rubin, R. Babbush, and

(2020), Phys. Rev. A 101 (1), 010301.

Lucas, A. (2014), Front. Phys. 2, 5.
Luo, X.-Z., J.-G. Liu, P. Zhang, and L. Wang (2020), Quan-

tum 4, 341.

H. Neven (2020c), Nat. Commun. 11 (1), 636.

McClean, J. R., M. E. Kimchi-Schwartz, J. Carter, and W. A.

de Jong (2017), Phys. Rev. A 95 (4), 042308.

McClean, J. R., J. Romero, R. Babbush, and A. Aspuru-

Lykov, D. (2020), “Q-Tensor,” https://github.com/danlkv/

Guzik (2016), New J. Phys. 18 (2), 023023.

qtensor.

Lyu, C., V. Montenegro, and A. Bayat (2020), Quantum 4,

324.

Ma, Z., P. Gokhale, T.-X. Zheng, S. Zhou, X. Yu, L. Jiang,
P. Maurer, and F. T. Chong (2020), arXiv:2010.08702 .
Magann, A. B., C. Arenz, M. D. Grace, T.-S. Ho, R. L. Kosut,
J. R. McClean, H. A. Rabitz, and M. Sarovar (2021), Phys.
Rev. X Quantum 2, 010101.

Magann, A. B., M. D. Grace, H. A. Rabitz, and M. Sarovar

(2020), arXiv preprint arXiv:2002.12497 .

Magesan, E., J. M. Gambetta, and J. Emerson (2011), Phys.

Rev. Lett. 106 (18), 180504.

McKay, D. C., S. Sheldon, J. A. Smolin, J. M. Chow, and
J. M. Gambetta (2019), Phys. Rev. Lett. 122, 200502.
McMahon, P. L., A. Marandi, Y. Haribara, R. Hamerly,
C. Langrock, S. Tamate, T. Inagaki, H. Takesue, S. Ut-
sunomiya, K. Aihara, et al. (2016), Science 354 (6312),
614.

Mei, F., Q. Guo, Y.-F. Yu, L. Xiao, S.-L. Zhu, and S. Jia

(2020), Phys. Rev. Lett. 125, 160503.

Meitei, O. R., B. T. Gard, G. S. Barron, D. P. Pappas,
S. E. Economou, E. Barnes, and N. J. Mayhall (2020),
arXiv:2008.04302 .

Mengoni, R., and A. Di Pierro (2019), Quantum Mach. Intell.

Magesan, E., J. M. Gambetta, and J. Emerson (2012), Phys.

1, 65.

Rev. A 85, 042311.

Mahadev, U. (2018), 2018 IEEE 59th Annual Symposium on

Foundations of Computer Science (FOCS) , 259.

Mahoney, A., J. Colless, S. Pauka, J. Hornibrook, J. Watson,
G. Gardner, M. Manfra, A. Doherty, and D. Reilly (2017),
Phys. Rev. X 7 (1), 011007.

Manin, Y. (1980), Sovetskoye Radio, Moscow 128.

Menke, T., F. Häse, S. Gustavsson, A. J. Kerman, W. D.
Oliver, and A. Aspuru-Guzik (2019), arXiv:1912.03322 .
Merkel, S. T., J. M. Gambetta, J. A. Smolin, S. Poletto,
A. D. Córcoles, B. R. Johnson, C. A. Ryan, and M. Steﬀen
(2013), Phys. Rev. A 87 (6), 062119.

Metger, T., and T. Vidick (2020), arXiv:2001.09161 .

74

Neill, C., P. Roushan, K. Kechedzhi, S. Boixo, S. V. Isakov,
V. Smelyanskiy, A. Megrant, B. Chiaro, A. Dunsworth,
K. Arya, et al. (2018), Science 360 (6385), 195.

Nghiem, N. A., S. Y.-C. Chen,

and T.-C. Wei (2020),

Metwalli, S. A., F. L. Gall, and R. Van Meter (2020), arXiv

preprint arXiv:2008.12525 .

Meyer, D. A., and N. R. Wallach (2002), Journal of Mathe-

matical Physics 43 (9), 4273.
Meyer, J. J., J. Borregaard,

arXiv:2006.06303 .

and J. Eisert

(2020),

arXiv:2010.13186 .

Nguyen, T., A. Santana, T. Kharazi, D. Claudino, H. Finkel,

Mezzacapo, A., U. Las Heras, J. Pedernales, L. DiCarlo,

and A. McCaskey (2020), arXiv:2010.03935 .

E. Solano, and L. Lamata (2014), Sci. Rep. 4 (1), 1.

Nishio, S., Y. Pan, T. Satoh, H. Amano, and R. V. Meter

Mi, X., P. Roushan, C. Quintana, S. Mandra, J. Marshall,
C. Neill, F. Arute, K. Arya, J. Atalaya, R. Babbush, et al.
(2021), arXiv:2101.08870 .

Milne, A. R., C. L. Edmunds, C. Hempel, F. Roy, S. Mavadia,
and M. J. Biercuk (2020), Phys. Rev. Applied 13, 024022.
Miquel, C., J. P. Paz, M. Saraceno, E. Knill, R. Laﬂamme,

(2020), ACM J. Emerg. Tech. Com. 16 (3), 1.

Niu, S., A. Suau, G. Staﬀelbach, and A. Todri-Sanial (2020),

IEEE Transactions on Quantum Engineering 1, 1.

Noh, K., and C. Chamberland (2020), Phys. Rev. A 101 (1),

012316.

Nokkala, J., R. Martínez-Peña, G. L. Giorgi, V. Parigi, M. C.

and C. Negrevergne (2002), Nature 418 (6893), 59.

Soriano, and R. Zambrini (2020), arXiv:2006.04821 .

Mitarai, K.,
013006.

and K. Fujii (2019), Phys. Rev. Res. 1 (1),

Oh, Y.-H., H. Mohammadbagherpoor, P. Dreher, A. Singh,

X. Yu, and A. J. Rindos (2019), arXiv:1911.00595 .

Mitarai, K., M. Negoro, M. Kitagawa, and K. Fujii (2018),

Oka, T., and S. Kitamura (2019), Annual Review of Con-

Phys. Rev. A 98 (3), 032309.

densed Matter Physics 10, 387.

Mitarai, K., T. Yan, and K. Fujii (2019), Phys. Rev. Appl.

11, 044087.

Mitchell, T. M. (1997), Machine learning (McGraw Hill).
Moll, N., P. Barkoutsos, L. S. Bishop, J. M. Chow, A. Cross,
D. J. Egger, S. Filipp, A. Fuhrer, J. M. Gambetta,
M. Ganzhorn, et al. (2018), Quantum Sci. Technol. 3 (3),
030503.

Ollitrault, P. J., A. Kandala, C.-F. Chen, P. K. Barkoutsos,
A. Mezzacapo, M. Pistoia, S. Sheldon, S. Woerner, J. M.
Gambetta, and I. Tavernelli (2020), Phys. Rev. Res. 2,
043140.

Orús, R. (2014), Ann. Phys. 349, 117.
Orus, R., S. Mugel, and E. Lizaso (2019), Reviews in Physics

4, 100028.

Möller, M., and M. Schalkers (2020), International Confer-

Ostaszewski, M., E. Grant,

and M. Benedetti (2019),

ence on Computational Science , 451.

arXiv:1905.09692 .

Monroe, C., W. Campbell, L.-M. Duan, Z.-X. Gong, A. Gor-
shkov, P. Hess, R. Islam, K. Kim, N. Linke, G. Pagano,
et al. (2019), arXiv:1912.07845 .

Montanaro, A. (2016), npj Quantum Inf. 2 (1), 1.
Morales, M. E. S., J. Biamonte, and Z. Zimborás (2019),

arXiv:1909.03123 .

Otten, M., C. L. Cortes,

and S. K. Gray (2019), arXiv

preprint arXiv:1910.06284.

Otten, M., and S. K. Gray (2019), npj Quantum Inf. 5, 11.
Otterbach, J. S., R. Manenti, N. Alidoust, A. Bestwick,
M. Block, B. Bloom, S. Caldwell, N. Didier, E. S. Fried,
S. Hong, et al. (2017), arXiv:1712.05771 .

Morales, M. E. S., T. Tlyachev, and J. Biamonte (2018),

Ozaeta, A., W. van Dam,

and P. L. McMahon (2020),

Phys. Rev. A 98, 062333.

arXiv:2012.03421 .

Mott, A., J. Job, J.-R. Vlimant, D. Lidar, and M. Spiropulu

(2017), Nature 550 (7676), 375.

Motta, M., C. Sun, A. T. Tan, M. J. O’Rourke, E. Ye, A. J.
Minnich, F. G. Brandão, and G. K.-L. Chan (2020), Nat.
Phys. 16 (2), 205.

Motzoi, F., J. M. Gambetta, P. Rebentrost, and F. K. Wil-

helm (2009), Phys. Rev. Lett. 103 (11), 110501.

Movassagh, R. (2019), arXiv:1909.06210 .
Nakaji, K., and N. Yamamoto (2020a), arXiv:2005.12537 .
Nakaji, K., and N. Yamamoto (2020b), arXiv:2010.13727 .
Nakajima, K., K. Fujii, M. Negoro, K. Mitarai, and M. Kita-

gawa (2019), Phys. Rev. Appl. 11 (3), 034021.

Nakanishi, K. M., K. Fujii, and S. Todo (2020), Phys. Rev.

Res. 2 (4), 043158.

Nakanishi, K. M., K. Mitarai, and K. Fujii (2019), Phys. Rev.

Res. 1 (3), 033062.

Nam, Y., J.-S. Chen, N. C. Pisenti, K. Wright, C. Delaney,
D. Maslov, K. R. Brown, S. Allen, J. M. Amini, J. Apisdorf,
et al. (2020), npj Quantum Inf. 6 (1), 1.

Napp, J., R. L. La Placa, A. M. Dalzell, F. G. Brandao, and

A. W. Harrow (2019), arXiv:2001.00021 .

Nash, B., V. Gheorghiu, and M. Mosca (2020), Quantum

Science and Technology 5 (2), 025010.

Nataf, P., and C. Ciuti (2011), Phys. Rev. Lett. 107 (19),

190402.

Navarrete-Benlloch, C. (2015), arXiv:1504.05266 .
Negoro, M., K. Mitarai, K. Fujii, K. Nakajima, and M. Kita-

gawa (2018), arXiv:1806.10910 .

O’Brien, T. E., B. Senjean, R. Sagastizabal, X. Bonet-
Monroig, A. Dutkiewicz, F. Buda, L. DiCarlo, and L. Viss-
cher (2019), npj Quantum Information 5 (1), 1.

O’Gorman, B., R. Babbush, A. Perdomo-Ortiz, A. Aspuru-
Guzik, and V. Smelyanskiy (2015), Eur. Phys. J. Spec.
Top. 224 (1), 163.

O’Malley, P. J., R. Babbush, I. D. Kivlichan, J. Romero, J. R.
McClean, R. Barends, J. Kelly, P. Roushan, A. Tranter,
N. Ding, et al. (2016), Phys. Rev. X 6 (3), 031007.

Pagano, G., A. Bapat, P. Becker, K. S. Collins, A. De,
P. W. Hess, H. B. Kaplan, A. Kyprianidis, W. L. Tan,
C. Baldwin, L. T. Brady, A. Deshpande, F. Liu, S. Jor-
dan, A. V. Gorshkov, and C. Monroe (2020), Proceed-
ings of the National Academy of Sciences 117 (41), 25396,
https://www.pnas.org/content/117/41/25396.full.pdf.
Paparo, G. D., V. Dunjko, A. Makmal, M. A. Martin-Delgado,

and H. J. Briegel (2014), Phys. Rev. X 4 (3), 031002.

Park, D. K., C. Blank, and F. Petruccione (2020), Physics

Letters A 384 (21), 126422.
Park, D. K., F. Petruccione,
Scientiﬁc reports 9 (1), 1.

and J.-K. K. Rhee (2019a),

Park, D. K., I. Sinayskiy, M. Fingerhuth, F. Petruccione, and
J.-K. K. Rhee (2019b), New Journal of Physics 21 (8),
083024.

Parra-Rodriguez, A., P. Lougovski, L. Lamata, E. Solano,

and M. Sanz (2020), Phys. Rev. A 101 (2), 022305.

Parrish, R. M., E. G. Hohenstein, P. L. McMahon, and T. J.

Martínez (2019a), Phys. Rev. Lett. 122 (23), 230401.

Parrish, R. M., J. T. Iosue, A. Ozaeta, and P. L. McMahon

QCA lab, (2020), “QX Simulator,” https://github.com/

(2019b), arXiv:1904.03206 .

QE-Lab/qx-simulator.

Parrish, R. M., and P. L. McMahon (2019), arXiv:1909.08925

Qi, H., D. J. Brod, N. Quesada, and R. García-Patrón (2020),

.

Paz, J. P., and W. H. Zurek (1998), Proc. Math. Phys. Eng.

Sci. 454 (1969), 355.

Pepper, A., N. Tischler, and G. J. Pryde (2019), Phys. Rev.

Physical review letters 124 (10), 100502.

QOSF, (2020), “Open-Source Quantum Software Projects,”
https://github.com/qosf/awesome-quantum-software.
QOSF, (2020), “Quantum open source foundation,” https:

Lett. 122, 060501.

//qosf.org/.

Perdomo, A., C. Truncik, I. Tubert-Brohman, G. Rose, and
A. Aspuru-Guzik (2008), Phys. Rev. A 78 (1), 012320.

Quantastica, (2020a),

“Q-Convert,” https://github.com/

quantastica/qconvert-js.

Perdomo-Ortiz, A., M. Benedetti, J. Realpe-Gómez,

and

Quantastica, (2020b), “Quantum circuit simulator,” https:

75

R. Biswas (2018), Quantum Sci. Technol. 3 (3), 030502.
Perdomo-Ortiz, A., N. Dickson, M. Drew-Brook, G. Rose,

and A. Aspuru-Guzik (2012), Sci. Rep. 2, 571.

Perdomo-Ortiz, A., A. Feldman, A. Ozaeta, S. V. Isakov,
Z. Zhu, B. O’Gorman, H. G. Katzgraber, A. Diedrich,
H. Neven, J. de Kleer, et al. (2019), Phys. Rev. Appl.
12 (1), 014004.
Perdomo-Ortiz, A.,

S. Narasimhan,
J. Fluegemann,
R. Biswas, and V. N. Smelyanskiy (2015), Eur. Phys. J.
Spec. Top. 224 (1), 131.

Pérez-Salinas, A., A. Cervera-Lierta, E. Gil-Fuster, and J. I.

//github.com/quantastica/quantum-circuit.

Quantastica, (2020c), “Quantum programming language con-
verter,” https://github.com/quantastica/qconvert.
Quantum, G. A., et al. (2020), Science 369 (6507), 1084.
Quantum, M.

(2020),

“Microsoft quantum documenta-
[Ac-

tion,” https://docs.microsoft.com/en-us/quantum/,
cessed: 22-December-2020].

Quantum AI team and collab., (2020), “Cirq,” .
Quantum Computing Reports, (2020), “Quantum computing
reports,” https://quantumcomputingreport.com/tools/.
Quesada, N., J. M. Arrazola, and N. Killoran (2018), Phys.

Latorre (2020a), Quantum 4, 226.

Rev. A 98, 062322.

Pérez-Salinas, A., J. Cruz-Martinez, A. A. Alhajri,

and

S. Carrazza (2020b), arXiv preprint arXiv:2011.13934 .
Pérez-Salinas, A., D. García-Martín, C. Bravo-Prieto, and

J. I. Latorre (2020c), Entropy 22 (4), 436.

Peruzzo, A., J. McClean, P. Shadbolt, M.-H. Yung, X.-Q.
and J. L. O’brien

Zhou, P. J. Love, A. Aspuru-Guzik,
(2014), Nat. Commun. 5, 4213.

Pesah, A., M. Cerezo, S. Wang, T. Volkoﬀ, A. T. Sornborger,
and P. J. Coles (2020), arXiv preprint arXiv:2011.02966 .
Peters, E., J. Caldeira, A. Ho, S. Leichenauer, M. Mohseni,
H. Neven, P. Spentzouris, D. Strain, and G. N. Perdue
(2021), arXiv:2101.09581 .

Peterson, E. C., G. E. Crooks, and R. S. Smith (2020), Quan-

tum 4, 247.

Pino, J. M., J. M. Dreiling, C. Figgatt, J. P. Gaebler, S. A.
Moses, C. Baldwin, M. Foss-Feig, D. Hayes, K. Mayer,
C. Ryan-Anderson, et al. (2020), arXiv:2003.01293 .

Ramos-Calderer, S., A. Pérez-Salinas, D. García-Martín,
C. Bravo-Prieto, J. Cortada, J. Planagumà, and J. I. La-
torre (2019), arXiv:1912.01618 .

Rath, A., R. van Bijnen, A. Elben, P. Zoller, and B. Verm-

ersch (2021), arXiv:2102.13524 .

Raussendorf, R., and J. Harrington (2007), Phys. Rev. Lett.

98 (19), 190504.

Rebentrost, P.,

and S. Lloyd (2018), arXiv preprint

arXiv:1811.03975 .

Rechenberg, I. (1978), in Simulationsmethoden in der Medizin

und Biologie (Springer) pp. 83–114.

Reiher, M., N. Wiebe, K. M. Svore, D. Wecker,
the Na-
7555,

and M. Troyer
tional Academy
https://www.pnas.org/content/114/29/7555.full.pdf.

(2017), Proceedings
114
Sciences
of

of
(29),

Richter,

J.,
arXiv:2012.02795 .

and A. Pal

(2020),

arXiv preprint

Pirhooshyaran, M., and T. Terlaky (2020), arXiv:2012.04046

Rivas, Á., S. F. Huelga, and M. B. Plenio (2010), Phys. Rev.

.

Platt, J. (1998), “Sequential minimal optimization: A fast
algorithm for training support vector machines,” https:
//t.ly/hoPX, [Accessed: 16-Januaray-2021].

Pokharel, B., N. Anand, B. Fortman, and D. A. Lidar (2018),

Phys. Rev. Lett. 121 (22), 220502.

Policharla, G.-V.,

and S. Vinjanampathy

(2020),

arXiv:2011.13777 .

Potoček, V., A. P. Reynolds, A. Fedrizzi, and D. W. Corne

(2018), arXiv:1812.04458 .

Lett. 105 (5), 050403.

Robert, A., P. K. Barkoutsos, S. Woerner, and I. Tavernelli

(2021), npj Quantum Inf. 7 (1), 1.

Roggero, A., A. C. Li, J. Carlson, R. Gupta,
Perdue (2020), Phys. Rev. D 101 (7), 074038.

and G. N.

Rohwedder, T. (2010), An analysis for some methods and
algorithms of quantum chemistry, Doctoral thesis (Tech-
nische Universität Berlin, Fakultät II - Mathematik und
Naturwissenschaften, Berlin).

Romero, J., and A. Aspuru-Guzik (2019), arXiv:1901.00848

Poulin, D., M. B. Hastings, D. Wecker, N. Wiebe, A. C. Do-

.

herty, and M. Troyer (2014), arXiv:1406.4920 .

Powell, M. J. (2009), Cambridge NA Report NA2009/06, Uni-

versity of Cambridge, Cambridge , 26.

Romero, J., R. Babbush, J. R. McClean, C. Hempel, P. J.
Love, and A. Aspuru-Guzik (2018), Quantum Sci. Technol.
4 (1), 014008.

Pozzi, M. G., S. J. Herbert, A. Sengupta, and R. D. Mullins

Romero, J., J. P. Olson, and A. Aspuru-Guzik (2017), Quan-

(2020), arXiv:2007.15957 .

Preskill, J. (2018), Quantum 2, 79.
Pulay, P. (1980), Chem. Phys. Lett. 73 (2), 393.
Q-Ctrl, (2020), “Q-ctrl open controls,” .
QCA lab, (2020), “Delft quantum & classical simulator,”

https://github.com/QE-Lab/dqcsim.

QCA Lab, (2020), “OpenQL,” https://github.com/QE-Lab/

OpenQL.

tum Sci. Technol. 2 (4), 045001.

Roos, B. O., P. R. Taylor, and P. E. Sigbahn (1980), Chemical

Physics 48 (2), 157 .

Rosenberg, G., P. Haghnegahdar, P. Goddard, P. Carr,
K. Wu, and M. L. De Prado (2016), IEEE Journal of Se-
lected Topics in Signal Processing 10 (6), 1053.

Roushan, P., C. Neill, J. Tangpanitanon, V. Bastidas,
A. Megrant, R. Barends, Y. Chen, Z. Chen, B. Chiaro,

76

A. Dunsworth, et al. (2017), Science 358 (6367), 1175.
Rudolph, M. S., N. T. Bashige, A. Katabarwa, S. Johr, B. Per-
opadre, and A. Perdomo-Ortiz (2020), arXiv:2012.03924 .
Ryabinkin, I. G., S. N. Genin, and A. F. Izmaylov (2018a),

Seki, K., and S. Yunoki (2021), PRX Quantum 2 (1), 010333.
Seraﬁni, A. (2017), Quantum continuous variables: a primer

of theoretical methods (CRC press).
Setia, K., S. Bravyi, A. Mezzacapo,

and J. D. Whitﬁeld

J. Chem. Theory Comput. 15 (1), 249.

(2019), Phys. Rev. Research 1, 033033.

Ryabinkin, I. G., A. F. Izmaylov, and S. N. Genin (2021),

Quantum Sci. Technol. .

Ryabinkin, I. G., R. A. Lang, S. N. Genin, and A. F. Izmaylov

(2020), J. Chem. Theory Comput. 16 (2), 1055.

Setia, K., R. Chen, J. E. Rice, A. Mezzacapo, M. Pistoia,
and J. D. Whitﬁeld (2020), Journal of Chemical Theory
and Computation 16 (10), 6091, pMID: 32833450.

Setia, K.,

and J. D. Whitﬁeld (2018), J. Chem. Phys.

Ryabinkin, I. G., T.-C. Yen, S. N. Genin, and A. F. Izmaylov

148 (16), 164104.

(2018b), J. Chem. Theory Comput. 14 (12), 6317.
Sack, S. H., and M. Serbyn (2021), arXiv:2101.05742 .
Sagastizabal, R., X. Bonet-Monroig, M. Singh, M. A. Rol,
C. Bultink, X. Fu, C. Price, V. Ostroukh, N. Muthusubra-
manian, A. Bruno, et al. (2019a), Phys. Rev. A 100 (1),
010302.

Sagastizabal, R., X. Bonet-Monroig, M. Singh, M. A. Rol,
C. C. Bultink, X. Fu, C. H. Price, V. P. Ostroukh,
N. Muthusubramanian, A. Bruno, M. Beekman, N. Haider,
T. E. O’Brien,
and L. DiCarlo (2019b), Phys. Rev. A
100 (1), 010302.

Saleem, Z. H. (2020), Int. J. Quantum Inf. 18 (04), 2050011.
Santagati, R., J. Wang, A. A. Gentile, S. Paesani, N. Wiebe,
J. R. McClean, S. Morley-Short, P. J. Shadbolt, D. Bon-
neau, J. W. Silverstone, et al. (2018), Sci. Adv. 4 (1),
eaap9646.

Sharma, K., M. Cerezo, L. Cincio, and P. J. Coles (2020),

arXiv:2005.12458 .

Shin, S. W., G. Smith, J. A. Smolin, and U. Vazirani (2014),

arXiv:1401.7087 .

Shingu, Y., Y. Seki, S. Watabe, S. Endo, Y. Matsuzaki,
S. Kawabata, T. Nikuni, and H. Hakoshima (2020), arXiv
preprint arXiv:2007.00876 .

Shor, P. W. (1994), Proceedings 35th annual symposium on

foundations of computer science , 124.

Shor, P. W. (1995), Phys. Rev. A 52 (4), R2493.
Shor, P. W. (1999), SIAM review 41 (2), 303.
Sieberer, L. M., M. Buchhold, and S. Diehl (2016), Rep. Prog.

Phys. 79 (9), 096001.

Sim, S., P. D. Johnson, and A. Aspuru-Guzik (2019), Adv.

Quantum Technol. 2 (12), 1900070.

Sim, S., J. Romero, J. F. Gonthier, and A. A. Kunitsa (2020),

Santos, L. F., and L. Viola (2005), Phys. Rev. A 72 (6),

arXiv:2010.00629 .

062303.

Satoh, T., Y. Ohkura, and R. Van Meter (2020), IEEE Trans-

actions on Quantum Engineering 1, 1.

Sawaya, N. P.,

and J. Huh (2019), J. Phys. Chem. Lett.

10 (13), 3586.

Sawaya, N. P., T. Menke, T. H. Kyaw, S. Johri, A. Aspuru-
Guzik, and G. G. Guerreschi (2020), npj Quantum Inf.
6 (1), 1.

Schmoll, P., and R. Orús (2017), Phys. Rev. B 95, 045112.
Schölkopf, B., R. Herbrich, and A. J. Smola (2001), Compu-

Siraichi, M. Y., V. F. d. Santos, S. Collange, and F. M. Q.
Pereira (2018), Proceedings of the 2018 International Sym-
posium on Code Generation and Optimization CGO 2018,
113–125.

Situ, H., Z. He, Y. Wang, L. Li, and S. Zheng (2020), Inf.

Sci. .

Skolik, A., J. R. McClean, M. Mohseni, P. van der Smagt,

and M. Leib (2020), arXiv:2006.14904 .

Smith, A., B. Jobst, A. G. Green, and F. Pollmann (2019a),

arXiv preprint arXiv:1910.05351 .

tational Learning Theory , 416.

Smith, A., M. Kim, F. Pollmann, and J. Knolle (2019b), npj

Schuld, M. (2021), arXiv preprint arXiv:2101.11020 .
Schuld, M., V. Bergholm, C. Gogolin, J. Izaac, and N. Kil-

loran (2019), Phys. Rev. A 99 (3), 032331.

Schuld, M., A. Bocharov, K. M. Svore, and N. Wiebe (2020a),

Phys. Rev. A 101 (3), 032308.

Quantum Inf. 5 (1), 1.

Smith, D. G., L. A. Burns, A. C. Simmonett, R. M. Par-
rish, M. C. Schieber, R. Galvelis, P. Kraus, H. Kruse,
R. Di Remigio, A. Alenaizan, et al. (2020a), J. Chem. Phys.
152 (18), 184108.

Schuld, M., K. Brádler, R. Israel, D. Su,

and B. Gupt

Smith, R. S., M. J. Curtis,

and W. J. Zeng (2016),

(2020b), Phys. Rev. A 101, 032314.

arXiv:1608.03355 .

Schuld, M., M. Fingerhuth, and F. Petruccione (2017), Eur.

Smith, R. S., E. C. Peterson, M. G. Skilbeck, and E. J. Davis

Phys. Lett. 119 (6), 60002.

(2020b), Quantum Sci. Technol. 5 (4), 044001.

Schuld, M., and N. Killoran (2019), Phys. Rev. Lett. 122 (4),

Somma, R., G. Ortiz, E. Knill, and J. Gubernatis (2003),

040504.

arXiv:quant-ph/0304063 .

Schuld, M., and F. Petruccione (2018), Supervised learning

Song, C., J. Cui, H. Wang, J. Hao, H. Feng, and Y. Li (2019),

with quantum computers (Springer).

Sci. Adv. 5 (9), eaaw5686.

and J. J. Meyer

(2020c),

37 (3), 332.

Schuld, M., I. Sinayskiy, and F. Petruccione (2014), Quantum

Inf. Process. 13 (11), 2567.

Schuld, M., I. Sinayskiy, and F. Petruccione (2016), Phys.

Rev. A 94 (2), 022342.
Schuld, M., R. Sweke,

arXiv:2008.08605 .

Schwefel, H.-P.

(1977), Numerische Optimierung

von
Computer-Modellen mittels der Evolutionsstrategie: mit
einer vergleichenden Einführung in die Hill-Climbing-und
Zufallsstrategie, Vol. 1 (Springer).

Scott, A. J. (2004), Physical Review A 69 (5), 052330.
Seeley, J. T., M. J. Richard, and P. J. Love (2012), J. Chem.

Phys. 137 (22), 224109.

Spagnolo, N., E. Maiorino, C. Vitelli, M. Bentivegna,
A. Crespi, R. Ramponi, P. Mataloni, R. Osellame, and
F. Sciarrino (2017), Sci. Rep. 7 (1), 1.

Spall, J. C. (1992), IEEE Transactions on Automatic Control

Stair, N. H., and F. A. Evangelista (2021), “Simulating many-
body systems with a projective quantum eigensolver,”
arXiv:2102.00345 [quant-ph].

Stair, N. H., R. Huang, and F. A. Evangelista (2020), J.

Chem. Theory Comput. 16 (4), 2236.

Stefanucci, G., and R. Van Leeuwen (2013), Nonequilibrium
many-body theory of quantum systems: a modern introduc-
tion (Cambridge University Press).

77

Steiger, D. S., T. Häner, and M. Troyer (2018), Quantum 2,

Temme, K., S. Bravyi, and J. M. Gambetta (2017), Phys.

49.

Steudtner, M., and S. Wehner (2018), New Journal of Physics

20 (6), 063010.

Rev. Lett. 119 (18), 180509.

Terhal, B. M. (2015), Rev. Mod. Phys. 87 (2), 307.
Tilly, J., G. Jones, H. Chen, L. Wossnig, and E. Grant (2020),

Steudtner, M.,

and S. Wehner (2019), Phys. Rev. A 99,

Phys. Rev. A 102, 062425.

022308.

Torlai, G., G. Mazzola, G. Carleo, and A. Mezzacapo (2020),

Stokes, J., J. Izaac, N. Killoran, and G. Carleo (2020), Quan-

Phys. Rev. Research 2, 022060.

tum 4, 269.

Torlai, G., G. Mazzola, J. Carrasquilla, M. Troyer, R. Melko,

Strano, D.,

and the Qrack contributors (2020), “Qrack,”

and G. Carleo (2018), Nat. Phys. 14 (5), 447.

https://github.com/vm6502q/qrack.

Torrontegui, E., and J. J. García-Ripoll (2019), Eur. Phys.

Streif, M., and M. Leib (2020), Phys. Rev. A 102, 042416.
Strikis, A., D. Qin, Y. Chen, S. C. Benjamin, and Y. Li

Lett. 125 (3), 30004.

Tóth, G., and I. Apellaniz (2014), J. Phys. A Math. Theor.

(2020), arXiv preprint arXiv:2005.07601 .

47 (42), 424006.

Struchalin, G., Y. A. Zagorovskii, E. Kovlakov, S. Straupe,

and S. Kulik (2021), PRX Quantum 2 (1), 010307.

Suchsland, P., F. Tacchino, M. H. Fischer, T. Neupert, P. K.
Barkoutsos, and I. Tavernelli (2020), arXiv:2008.10914 .
Sun, J., X. Yuan, T. Tsunoda, V. Vedral, S. C. Bejamin, and

S. Endo (2020a), arXiv:2001.04891 .

Sun, Q., T. C. Berkelbach, N. S. Blunt, G. H. Booth, S. Guo,
Z. Li, J. Liu, J. D. McClain, E. R. Sayfutyarova, S. Sharma,
S. Wouters, and G. K.-L. Chan (2018), Wiley Interdiscip.
Rev. Comput. Mol. Sci. 8 (1), e1340.

Sun, Q., X. Zhang, S. Banerjee, P. Bao, M. Barbry, N. S.
Blunt, N. A. Bogdanov, G. H. Booth, J. Chen, Z.-H. Cui,
J. J. Eriksen, and et. al. (2020b), J. Chem. Phys. 153 (2),
024109.

Sun, S.-N., M. Motta, R. N. Tazhigulov, A. T. K. Tan, G. K.-
L. Chan, and A. J. Minnich (2020c), arXiv:2009.03542 .
Sung, K. J., J. Yao, M. P. Harrigan, N. C. Rubin, Z. Jiang,
L. Lin, R. Babbush, and J. R. McClean (2020), Quantum
Sci. Technol. 5 (4), 044008.

Surján, P. R. (2012), Second quantized approach to quantum
chemistry: an elementary introduction (Springer Science &
Business Media).

Sutton, R. S., and A. G. Barto (2018), Reinforcement learn-

ing: An introduction (MIT press).

Suzuki, M. (1976), Commun. Math. Phys. 51 (2), 183.
Suzuki, Y., Y. Kawase, Y. Masumura, Y. Hiraga, M. Nakadai,
J. Chen, K. M. Nakanishi, K. Mitarai, R. Imai, S. Tamiya,
et al. (2020), arXiv:2011.13524 .

Sweke, R., F. Wilde, J. J. Meyer, M. Schuld, P. K. Fährmann,
B. Meynard-Piganeau, and J. Eisert (2020), Quantum 4,
314.

Tacchino, F., P. Barkoutsos, C. Macchiavello, I. Tavernelli,
D. Gerace, and D. Bajoni (2020a), Quantum Science and
Technology 5 (4), 044010.

Tacchino, F., A. Chiesa, S. Carretta, and D. Gerace (2020b),

Advanced Quantum Technologies 3 (3), 1900052.

Tovey, C. A. (1984), Discret. Appl. Math. 8 (1), 85.
Trabesinger, A. (2012), Nat. Phys. 8 (4), 263.
Tranter, A., P. J. Love, F. Mintert, and P. V. Coveney (2018),

J. Chem. Theory Comput. 14 (11), 5617.

Tranter, A., S. Soﬁa, J. Seeley, M. Kaicher, J. McClean,
R. Babbush, P. V. Coveney, F. Mintert, F. Wilhelm, and
P. J. Love (2015), Int. J. Quantum Chem. 115 (19), 1431.
Unitary Fund, (2020), “Unitary fund: Because evolution is

unitary.” https://unitary.fund/.

Utkarsh„ B. K. Behera,

and P. K. Panigrahi (2020),

arXiv:2002.01351 .

Utsunomiya, S., K. Takata, and Y. Yamamoto (2011), Opt.

Express 19 (19), 18091.

Valiev, M., E. J. Bylaska, N. Govind, K. Kowalski, T. P.
Straatsma, H. J. Van Dam, D. Wang, J. Nieplocha,
E. Apra, T. L. Windus, et al. (2010), Comput. Phys. Com-
mun. 181 (9), 1477.

Vallury, H. J., M. A. Jones, C. D. Hill, and L. C. Hollenberg

(2020), Quantum 4, 373.

Van Meter, R., T. D. Ladd, A. G. Fowler, and Y. Yamamoto

(2010), Int. J. Quantum Inf. 8 (01n02), 295.

Vandewalle, J., and B. De Moor (1991), Numerical Linear
Algebra, Digital Signal Processing and Parallel Algorithms
(Springer).

Havlíček, V. c. v., M. Troyer, and J. D. Whitﬁeld (2017),

Phys. Rev. A 95, 032332.

Veis, L., J. Višňák, H. Nishizawa, H. Nakai, and J. Pittner

(2016), Int. J. Quantum Chem. 116 (18), 1328.

Venturelli, D., and A. Kondratyev (2019), Quantum Mach.

Intell. 1, 17.

Verdon, G., M. Broughton,

and J. Biamonte (2017),

arXiv:1712.05304 .

Verdon, G., M. Broughton, J. R. McClean, K. J. Sung,
R. Babbush, Z. Jiang, H. Neven, and M. Mohseni (2019a),
arXiv:1907.05415 .

Verdon, G., J. Marks, S. Nanda, S. Leichenauer,

and

Tacchino, F., C. Macchiavello, D. Gerace, and D. Bajoni

J. Hidary (2019b), arXiv:1910.02071 .

(2019), npj Quantum Information 5 (1), 1.

Verstraete, F., and J. I. Cirac (2005), J. Stat. Mech. Theory

Takeshita, T., N. C. Rubin, Z. Jiang, E. Lee, R. Babbush,
and J. R. McClean (2020), Phys. Rev. X 10 (1), 011004.

Tan, B., and J. Cong (2020), IEEE/ACM ICCAD , 1.
Tan, J., T. H. Kyaw, and Y. Yeo (2010), Phys. Rev. A 81 (6),

062119.

Tang, E. (2018), arXiv:1811.00414 .
Tang, E. (2019), Proceedings of the 51st Annual ACM

Exp. 2005 (09), P09012.

Verstraete, F., J. I. Cirac, and J. I. Latorre (2009), Phys.

Rev. A 79, 032316.

Verstraete, F., J. J. Garcia-Ripoll, and J. I. Cirac (2004),

Phys. Rev. Lett. 93 (20), 207204.

Verstraete, F., V. Murg, and J. I. Cirac (2008), Adv. Phys.

57 (2), 143.

SIGACT Symposium on Theory of Computing , 217.

Verteletskyi, V., T.-C. Yen, and A. F. Izmaylov (2020), J.

Tang, H. L., E. Barnes, H. R. Grimsley, N. J. Mayhall, and

Chem. Phys. 152 (12), 124114.

S. E. Economou (2019), arXiv:1911.10205 .

Taube, A. G., and R. J. Bartlett (2006), Int. J. Quantum

Chem. 106 (15), 3393.

Vidal, G. (2003), Phys. Rev. Lett. 91, 147902.
Vidal, G. (2004), Phys. Rev. Lett. 93, 040502.
Vidal, J. G., and D. O. Theis (2019), arXiv:1901.11434 .

78

Vikstål, P., M. Grönkvist, M. Svensson, M. Andersson, G. Jo-
and G. Ferrini (2020), Phys. Rev. Appl. 14,

hansson,
034009.

Vinjanampathy, S., and J. Anders (2016), Contemp. Phys.

57 (4), 545.

Viola, L.,
060502.

and E. Knill (2005), Phys. Rev. Lett. 94 (6),

Viola, L., E. Knill, and S. Lloyd (1999), Phys. Rev. Lett.

82 (12), 2417.

Volkoﬀ, T., and P. J. Coles (2021), Quantum Science and

Technology 6 (2), 025008.

Woitzik, A. J. C., P. K. Barkoutsos, F. Wudarski, A. Buch-
leitner, and I. Tavernelli (2020), Phys. Rev. A 102 (4),
042402.

Wright, K., K. Beck, S. Debnath, J. Amini, Y. Nam, N. Grze-
siak, J.-S. Chen, N. Pisenti, M. Chmielewski, C. Collins,
et al. (2019), Nat. commun. 10 (1), 1.

Wright, L. G., and P. L. McMahon (2019), arXiv:1908.01364.
Wu, S. L., J. Chan, W. Guan, S. Sun, A. Wang, C. Zhou,
M. Livny, F. Carminati, A. Di Meglio, A. C. Li, et al.
(2020), arXiv:2012.11560 .

Xiang, D., X. Wang, C. Jia, T. Lee, and X. Guo (2016),

Vovrosh, J., K. E. Khosla, S. Greenaway, C. Self, M. Kim,

Chem. Rev. 116 (7), 4318.

and J. Knolle (2021), arXiv:2101.01690 .

Wallman, J. J., and J. Emerson (2016), Phys. Rev. A 94 (5),

052325.

Xin, T., S. Wei, J. Cui, J. Xiao, I. n. Arrazola, L. Lamata,
X. Kong, D. Lu, E. Solano, and G. Long (2020), Phys.
Rev. A 101, 032307.

Wan, K. H., O. Dahlsten, H. Kristjánsson, R. Gardner, and

Xu, X., S. C. Benjamin,

and X. Yuan (2019a),

M. Kim (2017), npj Quantum Inf. 3 (1), 1.

arXiv:1911.05759 .

Wan, Y., R. Jördens, S. D. Erickson, J. J. Wu, R. Bowler,
T. R. Tan, P.-Y. Hou, D. J. Wineland, A. C. Wilson,
and D. Leibfried (2020), Adv. Quantum Technol. 3 (11),
2000028.

Wang, D., O. Higgott, and S. Brierley (2019), Phys. Rev.

Lett. 122 (14), 140504.

Wang, K., Z. Song, X. Zhao, Z. Wang, and X. Wang (2020a),

arXiv:2012.14311 .

Wang, L. (2016), Phys. Rev. B 94, 195105.
Wang, S., E. Fontana, M. Cerezo, K. Sharma, A. Sone, L. Cin-

cio, and P. J. Coles (2020b), arXiv:2007.14384 .

Wang, X., Z. Song, and Y. Wang (2020c), arXiv:2006.02336

.

Wang, Y., Y. Li, Z.-q. Yin, and B. Zeng (2018a), npj Quan-

tum Inf. 4 (1), 1.

Xu, X., J. Sun, S. Endo, Y. Li, S. C. Benjamin, and X. Yuan

(2019b), arXiv:1909.03898 .

Yalouz, S., B. Senjean, J. Günther, F. Buda, T. E. O’Brien,
and L. Visscher (2021), Quantum Science and Technology
6 (2), 024004.

Yamamoto, N. (2019), arXiv:1909.05074 .
Yamamoto, Y., T. Leleu, S. Ganguli, and H. Mabuchi (2020),

Appl. Phys. Lett. 117, 160501.

Yang, Z.-C., A. Rahmani, A. Shabani, H. Neven, and C. Cha-

mon (2017), Phys. Rev. X 7, 021027.

Yao, J., M. Bukov, and L. Lin (2020a), Proceedings of The
First Mathematical and Scientiﬁc Machine Learning Con-
ference Proceedings of Machine Learning Research, 107,
605.

Yao, J., P. Köttering, H. Gundlach, L. Lin, and M. Bukov

Wang, Z., S. Hadﬁeld, Z. Jiang, and E. G. Rieﬀel (2018b),

(2020b), arXiv:2012.06701 .

Phys. Rev. A 97, 022304.

Wang, Z., A. Marandi, K. Wen, R. L. Byer,

and Y. Ya-

mamoto (2013), Phys. Rev. A 88 (6), 063853.

Watkins, C. J., and P. Dayan (1992), Machine learning 8 (3-

4), 279.

Watts, P., M. O’Connor, and J. Vala (2013), Entropy 15 (6),

1963.

Yao, N. Y., L. Jiang, A. V. Gorshkov, P. C. Maurer,
G. Giedke, J. I. Cirac, and M. D. Lukin (2012), Nat. Com-
mun. 3 (1), 1.

Yao, Y.-X., N. Gomes, F. Zhang, T. Iadecola, C.-Z. Wang,
K.-M. Ho, and P. P. Orth (2020c), arXiv:2011.00622 .
Yen, T.-C., and A. F. Izmaylov (2020), arXiv:2007.01234 .
Yen, T.-C., V. Verteletskyi, and A. F. Izmaylov (2020), J.

Wauters, M. M., G. B. Mbeng, and G. E. Santoro (2020a),

Chem. Theory Comput. 16 (4), 2400.

arXiv:2003.07419 .

Yordanov, Y. S., D. R. Arvidsson-Shukur, and C. H. Barnes

Wauters, M. M., E. Panizon, G. B. Mbeng, and G. E. Santoro

(2020), Phys. Rev. A 102 (6), 062612.

(2020b), Phys. Rev. Res. 2, 033446.

Yoshioka, N., Y. O. Nakagawa, K. Mitarai,

and K. Fujii

Wecker, D., M. B. Hastings, and M. Troyer (2015), Phys.

(2020), Phys. Rev. Res. 2 (4), 043289.

Rev. A 92 (4), 042303.

Wei, S., H. Li, and G. Long (2020), Research 2020.
Wen, J., X. Kong, S. Wei, B. Wang, T. Xin, and G. Long

(2019), Phys. Rev. A 99 (1), 012320.

van de Wetering, J. (2020), arXiv:2012.13966 .
White, S. R. (1992), Phys. Rev. Lett. 69, 2863.
Wierichs, D., C. Gogolin,

and M. Kastoryano (2020),

arXiv:2004.14666 .

Wierstra, D., T. Schaul, T. Glasmachers, Y. Sun, J. Pe-
and J. Schmidhuber (2014), The J. Mach. Learn.

ters,
Res. 15 (1), 949.

Wille, R., L. Burgholzer, and A. Zulehner (2019), 2019 56th
ACM/IEEE Design Automation Conference (DAC) , 1.

Wille, R., S. Hillmich,

and L. Burgholzer (2020), 2020
IEEE/ACM International Conference On Computer Aided
Design (ICCAD) , 1.

Yserentant, H. (2010), Regularity and Approximability of Elec-
tronic Wave Functions, Lecture Notes in Mathematics
(Springer Berlin Heidelberg).

Yu, J., J. Retamal, M. Sanz, E. Solano, and F. Albarrán-

Arriagada (2021), arXiv preprint arXiv:2103.15696.

Yu, S., F. Albarrán-Arriagada, J. C. Retamal, Y.-T. Wang,
W. Liu, Z.-J. Ke, Y. Meng, Z.-P. Li, J.-S. Tang, E. Solano,
et al. (2019), Adv. Quantum Technol. 2 (7-8), 1800074.

Yuan, X., S. Endo, Q. Zhao, Y. Li,

and S. C. Benjamin

(2019), Quantum 3, 191.

Yung, M.-H., J. Casanova, A. Mezzacapo, J. McClean,
L. Lamata, A. Aspuru-Guzik, and E. Solano (2014), Sci.
Rep. 4 (1), 3589.

Zanardi, P., and M. Rasetti (1999), Phys. Lett. A 264, 94.
Zeng, J., Y. Wu, J.-G. Liu, L. Wang, and J. Hu (2019), Phys.

Rev. A 99 (5), 052306.

Williams, C. P., and A. G. Gray (1999), Quantum Computing

Zhang, C., Y. Chen, Y. Jin, W. Ahn, Y. Zhang, and E. Z.

and Quantum Communications , 113.

Zhang (2020a), arXiv:2009.02346 .

79

Zhang, J., T. H. Kyaw, D. Tong, E. Sjöqvist, and L.-C. Kwek

(2015), Sci. Rep. 5, 18414.

Zhang, K., P. Rao, K. Yu, H. Lim, and V. Korepin (2021a),

arXiv preprint arXiv:2102.01783 .

Zhang, S., Y. Lu, K. Zhang, W. Chen, Y. Li, J.-N. Zhang,

and K. Kim (2020b), Nat. Commun. 11, 587.

Zhang, T., J. Sun, X.-X. Fang, X. Zhang, X. Yuan, and H. Lu

(2021b), arXiv:2106.10190 .

Zhang, Y.-H., P.-L. Zheng, Y. Zhang,
(2020c), Phys. Rev. Lett. 125, 170501.

and D.-L. Deng

Zhang, Z.-J., T. H. Kyaw, J. Kottmann, M. Degroote, and

A. Aspuru-Guzik (2021c), arXiv:2008.07553 .

Zhang, Z.-J., J. Sun, X. Yuan, and M.-H. Yung (2020d),

arXiv:2011.05283 .

Zhao, A., A. Tranter, W. M. Kirby, S. F. Ung, A. Miyake,
and P. J. Love (2020a), Phys. Rev. A 101 (6), 062322.
Zhao, T., G. Carleo, J. Stokes, and S. Veerapaneni (2020b),

Mach. Learn.: Sci. Technol. 2 (2), 02LT01.

Zhong, H.-S., H. Wang, Y.-H. Deng, M.-C. Chen, L.-C. Peng,
Y.-H. Luo, J. Qin, D. Wu, X. Ding, Y. Hu, et al. (2020),
Science 370 (6523), 1460.

Zhou, L., S.-T. Wang, S. Choi, H. Pichler, and M. D. Lukin

(2020a), Phys. Rev. X 10, 021067.

Zhou, Y., E. M. Stoudenmire,

and X. Waintal (2020b),

arXiv:2002.07730 .

Zhu, D., N. M. Linke, M. Benedetti, K. A. Landsman, N. H.
Nguyen, C. H. Alderete, A. Perdomo-Ortiz, N. Korda,
A. Garfoot, C. Brecque, et al. (2019), Sci. Adv. 5 (10),
eaaw9918.

Zlokapa, A., S. Boixo, and D. Lidar (2020), arXiv:2005.02464

.

Zoufal, C., A. Lucchi, and S. Woerner (2019), npj Quantum

Inf. 5 (1), 1.

Zoufal, C., A. Lucchi,

and S. Woerner

(2020),

arXiv:2006.06004 .

Zulehner, A., S. Gasser, and R. Wille (2017), International

conference on reversible computation , 185.

Zulehner, A., A. Paler, and R. Wille (2018), IEEE Trans-
actions on Computer-Aided Design of Integrated Circuits
and Systems 38 (7), 1226.

Zulehner, A., and R. Wille (2019), Proceedings of the 24th
Asia and South Paciﬁc Design Automation Conference ,
185.

80

Appendices

A. NISQ ALGORITHMS AND TOOLS TABLES

A. Tables of applications

Algorithm/Application

Proposed implementations

Variational quantum eigensolver (VQE) and related solvers

VQE

Adaptive VQE
IQAE
Krylov approaches

Imaginary time evolution
Full quantum eigensolver (FQE)

Folded spectrum
Orthogonally constrained VQE
Subspace expansion and
linear-response based
Subspace-search VQE
Multistate contracted VQE
Fourier transform of evolutions
WAVES
Adiabatically-Assisted
Projected VQE

Variational quantum simulator (VQS)
Subspace VQS
projected-Variational Quantum
Dynamics (p-VQD)
Variational fast forwarding
Quantum assisted simulator

(McClean et al., 2016; Peruzzo et al., 2014; Wecker et al., 2015)
(Gomes et al., 2021; Grimsley et al., 2019b; Kottmann et al., 2021b;
Ryabinkin et al., 2018b; Sim et al., 2020; Stair and Evangelista, 2021; Tang
et al., 2019; Zhang et al., 2021c)
(Bharti, 2020; Bharti and Haug, 2020a)
(Huggins et al., 2020; Jouzdani and Bringuier, 2020; Stair et al., 2020)
(Bharti and Haug, 2020b; McArdle et al., 2019a; Motta et al., 2020; Sun
et al., 2020c)
(Wei et al., 2020)

VQE for excited states

(Peruzzo et al., 2014; Ryabinkin et al., 2018a)
(Higgott et al., 2019; Kottmann et al., 2021b; Lee et al., 2018)

(McClean et al., 2017; Ollitrault et al., 2020; Takeshita et al., 2020)
(Nakanishi et al., 2019)
(Parrish et al., 2019a)
(Aleiner et al., 2020; Roushan et al., 2017)
(Santagati et al., 2018)
(Garcia-Saez and Latorre, 2018; McClean et al., 2016)
(Stair and Evangelista, 2021)

Hamiltonian simulation

(Benedetti et al., 2020; Endo et al., 2020c; Kubo et al., 2020; Li and
Benjamin, 2017; McArdle et al., 2019a; Yuan et al., 2019)
(Heya et al., 2019)

(Barison et al., 2021; Otten et al., 2019)
(Cirstoiu et al., 2020; Commeau et al., 2020)
(Bharti and Haug, 2020b)

Scrambling
Thermal state

Generalized VQS
Generalized quantum assisted
simulator
Trotter simulation

Non-equilibrium steady state
Gibbs-state
Many-body ground state

Quantum autoencoder

Quantum information scrambling and thermalization

(Holmes et al., 2020; Joshi et al., 2020; Landsman et al., 2019; Mi et al.,
2021)
(Verdon et al., 2019b)

Open quantum systems

(Endo et al., 2020c; Liu et al., 2020b; Yuan et al., 2019)

(Haug and Bharti, 2020)
(Hu et al., 2020; Koppenhöfer et al., 2020)

State preparation

(Yoshioka et al., 2020)(Endo et al., 2020b; Jaderberg et al., 2020; Kreula
et al., 2016)
(Chowdhury et al., 2020; Endo et al., 2020c; Haug and Bharti, 2020)
(Ho and Hsieh, 2019; Ho et al., 2019; Wauters et al., 2020a)

Quantum autoencoder

(Bondarenko and Feldmann, 2020; Bravo-Prieto, 2020; Huang et al., 2020a,b;
Pepper et al., 2019; Romero et al., 2017)

Quantum computer-aided design

Optical setups
Superconducting circuits

(Kottmann et al., 2020)
(Kyaw et al., 2020b)

Table I NISQ algorithms for Many-body physics and chemistry applications from Sec. VI.A.

81

Algorithm/Application

Proposed implementations

Supervised learning

Quantum kernel methods

Variational quantum classiﬁers (VQC)
Encoding strategies in VQA

Quantum reservoir computing
Supervised QUBO classiﬁer

Quantum Boltzmann machines
(QBM)
Energy-based models (e.g., RBMs)

Quantum circuit Born machines
(QCBM)
Quantum generative adversarial
networks (QGAN)

Reinforcement learning

(Havlíček et al., 2019; Kusumoto et al., 2019; Peters et al., 2021; Schuld
et al., 2020b; Schuld and Killoran, 2019)
(Farhi and Neven, 2018; Lloyd et al., 2020; Mitarai et al., 2018; Pérez-Salinas
et al., 2020a; Schuld et al., 2020a,c; Vidal and Theis, 2019)
(Cervera-Lierta et al., 2021a; Mitarai et al., 2019)
(Chien and Whitﬁeld, 2020; Fujii and Nakajima, 2017; Ghosh et al., 2019;
Mitarai et al., 2018; Nakajima et al., 2019; Negoro et al., 2018; Nokkala
et al., 2020)
(Li et al., 2018)

Unsupervised learning

(Amin et al., 2018; Kieferová and Wiebe, 2017; Zoufal et al., 2020)
(Benedetti et al., 2016, 2017, 2018)
(Alcazar et al., 2020; Benedetti et al., 2019a; Coyle et al., 2020a; Hamilton
et al., 2019; Leyton-Ortega et al., 2019; Liu and Wang, 2018; Rudolph et al.,
2020; Zhu et al., 2019)
(Dallaire-Demers and Killoran, 2018; Hu et al., 2019; Lloyd and Weedbrook,
2018; Romero and Aspuru-Guzik, 2019; Situ et al., 2020; Zeng et al., 2019)

Reinforcement learning

(Albarrán-Arriagada et al., 2020; Cárdenas-López et al., 2018; Chen et al.,
2020; Crawford et al., 2016; Jerbi et al., 2019; Lamata, 2017; Lockwood and
Si, 2020a,b; Yu et al., 2019)

Table II NISQ algorithms for machine learning applications from Sec. VI.B.

Algorithm/Application

Max cut
Max clique
Triangle ﬁnding
Maximum independent set
Max hafnian
Vertex cover
Exact cover
Knapsack
Graph multi-coloring
Fault diagnosis
Bayesian networks

Protein folding

Proposed implementations
(Bravyi et al., 2019; Farhi et al., 2014; Hastings, 2019; Headley et al., 2020;
Otterbach et al., 2017; Satoh et al., 2020)
(Arrazola and Bromley, 2018; Banchi et al., 2020a)
(Metwalli et al., 2020)
(Choi et al., 2020; Saleem, 2020; Utkarsh et al., 2020)
(Arrazola et al., 2018)
(Cook et al., 2019)
(Bengtsson et al., 2020; Garcia-Saez and Latorre, 2018; Vikstål et al., 2020)
(de la Grand’rive and Hullo, 2019)
(Oh et al., 2019)
(Perdomo-Ortiz et al., 2019, 2015)
(O’Gorman et al., 2015)
(Babbush et al., 2014; Babej et al., 2018; Benedetti et al., 2016; Fingerhuth
et al., 2018; Perdomo et al., 2008; Perdomo-Ortiz et al., 2012; Robert et al.,
2021)

Table III NISQ algorithms for combinatorial optimization from Sec. VI.C.

Algorithm/Application
Factoring
SVD
Linear systems

Non-linear diﬀerential equations
Semideﬁnite programming

Proposed implementations
(Anschuetz et al., 2019; Karamlou et al., 2020)
(Bravo-Prieto et al., 2020a; Wang et al., 2020c)
(Bravo-Prieto et al., 2019; Huang et al., 2019; Xu et al., 2019b)
(Gaitan, 2020; Haug and Bharti, 2020; Kyriienko et al., 2020; Lubasch et al.,
2020)
(Bharti et al., 2021)

Table IV NISQ algorithms for numerical solvers applications from Sec. VI.D.

Algorithm/Application

Portfolio optimization
Fraud detection
Option pricing

Proposed implementations
(Alcazar and Perdomo-Ortiz, 2021; Bouland et al., 2020; Cohen et al., 2020;
Egger et al., 2020a; Marzec, 2016; Rosenberg et al., 2016; Venturelli and
Kondratyev, 2019)
(Egger et al., 2020a,b; Zoufal et al., 2020)
(Kubo et al., 2020)

Table V NISQ algorithms for ﬁnance applications from Sec. C

82

Algorithm/Application

Proposed implementations
Quantum foundations

Bell inequalities
Contextuality
Variational consistent history (VCH)

(Alsina and Latorre, 2016)
(Kirby and Love, 2019; Kirby et al., 2020)
(Arrasmith et al., 2019)

Quantum optimal control

Quantum metrology

Quantum optimal control

(Dive et al., 2018; Li et al., 2017a; Lu et al., 2017; Magann et al., 2021;
Policharla and Vinjanampathy, 2020)
Quantum metrology

(Beckey et al., 2020; Kaubruegger et al., 2019; Koczor et al., 2020; Ma et al.,
2020; Meyer et al., 2020)

Fidelity estimation

(Cerezo et al., 2020a)

Fidelity estimation

Quantum error correction (QEC)

Quantum variational error corrector
(QVECTOR)
Variational circuit compiler for QEC (Xu et al., 2019a)

(Johnson et al., 2017)

Schwinger model

High-energy processes

Schmidt decomposition
Multipartite entanglement
Entanglement spectrum

Nuclear physics

(Avkhadiev et al., 2020; Hauke et al., 2013; Klco et al., 2018; Kokail et al.,
2019; Martinez et al., 2016)
(Chen et al., 2020c; Dumitrescu et al., 2018; Liu and Xin, 2020;
Pérez-Salinas et al., 2020b; Roggero et al., 2020; Wu et al., 2020)

Entanglement properties

(Bravo-Prieto et al., 2019; Wang et al., 2020a)
(Pérez-Salinas et al., 2020c)
(Cerezo et al., 2020b; LaRose et al., 2019)

Table VI NISQ algorithm for other applications listed in Sec. VI.E.

B. Table of software packages

Name

Language Hardware Multi-platform

Cirq (Quantum AI team and collab., 2020)

DQCSim (QCA lab, 2020)
IQS (Guerreschi et al., 2020)
∣Lib⟩(Möller and Schalkers, 2020)
Pennylane (Bergholm et al., 2018)

python
python, C++,
Rust
C++
python, C++
python

ProjectQ (Steiger et al., 2018)

python

pyquil/Forest (Smith et al., 2016)

QDK (Quantum, 2020)

Qibo (Efthymiou et al., 2020)

Qiskit (IBMQ, 2019)

python, Lisp
python, C#,
Q#

python

python

QTensor (Lykov, 2020)
QuEST (Jones and Benjamin, 2020; Jones
et al., 2019a)

python, C++
C++,
Mathematica

Quimb (Gray, 2018)

python

Qulacs (Suzuki et al., 2020)
StrawberryFields (Killoran et al., 2019)

python, C++
python

Tequila (Kottmann et al., 2021a)

python

XACC (McCaskey et al., 2020)
Yao (Luo et al., 2020)

python, C++
Julia

Yes

No
No
Yes**
Yes**

Yes**

Yes

Yes**

Yes*

Yes

No

No

No

No
Yes*

Yes**

Yes**
No

No

No
No
Yes
Yes

Yes

No

No

Yes

No

No

Yes

No

No
No

Yes

Yes
No

83

Built-in applications
Chemistry, ML, Noise
characterization, Optimization

–
QAOA
–
ML, Optimization
Fermionic simulation,
Optimization
VQE, QAOA, Noise
characterization, Optimization

Chemistry, Optimization
VQE, QAOA, Adiabatic
evolution, Optimization
Chemistry, ML, Optimization,
Finance, Noise characterization
Tensor-Network simulator,
quantum circuit simulator,
QAOA

–
Tensor-Network simulator,
quantum circuit simulator
Simulator, noise
characterization
GBS
Chemistry, ML, Noise
characterization, Optimization
Optimization, VQE, QAOA,
RBM and other algorithms
–

Table VII List of open-source quantum software libraries. These packages are designed using common computing languages
such as python, C++ or Julia. Some of them can be used in real quantum hardware, either because the developers are also
building these devices or because the package include other quantum libraries. Some of them can translate their code to other
quantum libraries or simulators. *Hardware not publicly available yet. **Not on own hardware but can be run in a hardware
backend.

C. Table of external libraries

Name

OpenFermion (McClean et al., 2020a)
psi4 (Smith et al., 2020a)
PySCF (Sun et al., 2018, 2020b)
NWChem (Valiev et al., 2010)
EntropicaQAOA (Entropica Labs, 2019)
TensorFlowQ (Broughton et al., 2020)
TensorFlow (Abadi et al., 2016)
Mitiq (LaRose et al., 2020)
pyzx (Kissinger and van de Wetering, 2020a)
quilc (Smith et al., 2020b)
Q-Convert (Quantastica, 2020a,c)
iTensor (Fishman et al., 2020)
OpenQL (QCA Lab, 2020)
JKQ (Wille et al., 2020)
ScaﬀCC (JavadiAbhari et al., 2014)
staq (Amy and Gheorghiu, 2020)
Silq (Bichsel et al., 2020)
QX simulator (QCA lab, 2020)
QRACK (Strano and the Qrack contributors, 2020)
quantum-circuit (Quantastica, 2020b)
QuTip (Johansson et al., 2012)
Q-Ctrl (Q-Ctrl, 2020)

84

Language
python
python
python
Fortran 77, C
python
python
python
python
python
quil
JavaScript, python
Julia,C++
python, C++
C++
Scaﬀold
C++
D
python, C++
C++
JavaScript
python
python

Application
Chemistry
Chemistry
Chemistry
Chemistry
QAOA
QML
ML
Error Mitigation
Compiler
Compiler
quantum language converter
Tensor Networks
Compiler
Simulator and Compiler
Compiler
Compiler
Compiler
Simulator
Simulator
Simulator
Quantum Info. SDK
Quantum Control

Table VIII External open-source libraries useful for the NISQ era. These libraries have applications in chemistry, machine
learning, circuit compilation and quantum control. Some of them are integrated in the quantum software libraries listed in
Table VII.

B. CLASSICAL OPTIMIZATION STRATEGIES

In this section, we detail the algorithms and strategies
used to optimize the parameters of the PQC. For com-
pleteness, we reproduce part of the text shown in the
main article and add the corresponding details on the
methods.

A. Gradient-based approaches

Finite diﬀerence. This method approximates the gradi-
ent of a function f (θ) as follows:

∂if (θ) ≈

f (θ + (cid:15)ei) − f (θ − (cid:15)ei)
2(cid:15)

,

(128)

where (cid:15) is a small number and ei is the unit vector with
1 as its i-th element and 0 otherwise. The smaller (cid:15),
the closer the right-hand side of above formula is to the
true value of the gradient. However, for small (cid:15) the dif-
ference of the numerator becomes small as well. As the
objective function is an expectation value sampled from
the quantum device and it is only estimated with limited
accuracy, smaller (cid:15) require more samples taken from the
quantum hardware to achieve a good estimation of the
gradient.

Parameter-shift rule. The analytical gradient can be cal-
culated on quantum hardware using the parameter-shift
rule, which was originally proposed in (Romero et al.,
2018) and developed in (Mitarai et al., 2018; Schuld et al.,
2019). A key advantage is that the gradient is exact even
if the diﬀerence parameter (cid:15) is chosen to be a large num-
ber (commonly (cid:15) = π/2), avoiding the issues of the ﬁnite
diﬀerence method. We assume that the unitary to be
optimized can be written as U (θ) = V G(θi)W , where
G = e−iθig is the unitary aﬀected by the parameter θi, g
is the generator of G and V, W are unitaries independent
of θi. If g has a spectrum of two eigenvalues ±λ only, the
gradient can be calculated by measuring the observable
at two shifted parameter values as follows:

∂i⟨f (θ)⟩ = λ (⟨f (θ+)⟩ − ⟨f (θ−)⟩) ,

(129)

where θ± = θ ± (π/4λ)ei.

This rule can be generalised to the case where the gen-
erator g does not satisfy the eigenspectrum condition
by decomposing the unitary into commuting terms as
G = G1G2..Gn = e−iθi(g1+g2+..+gn), where the generator
gm of Gm = e−iθigm satisﬁes that condition. We can then
use the parameter-shift rule on each Gm and calculate the
analytical gradient using the product rule. This has been

further developed for calculating analytical gradients for
fermionic generators of Unitary Coupled-Cluster opera-
tors (Kottmann et al., 2021b) and higher order deriva-
tives (Mari et al., 2020).

One can also use an auxiliary qubit and controlled uni-
taries to evaluate the gradient of multi-qubit unitaries
where the parameter-shift rule does not apply. This was
originally proposed in the context of unitary coupled-
cluster (Romero et al., 2018) and later generalized for ar-
bitrary gradients (Schuld et al., 2019; Yuan et al., 2019).
A further alternative is the stochastic parameter-shift
rule (Banchi and Crooks, 2020), which relies on stochas-
tically sampling scaled evolutions of the generator.

It is a quasi-Newton method that eﬃciently
L-BFGS.
approximates the “inverse Hessian" using a limited his-
tory of positions and gradients (Liu and Nocedal, 1989).
“Inverse Hessian” refers to the inverse of the Hessian ma-
trix, where Hessian is a square matrix of second-order
partial derivatives of the loss function. The inverse Hes-
sian is employed to adjust gradient updates to the current
loss landscape. L-BFGS is a memory-eﬃcient variant of
the BFGS method, which stores dense approximations
of the inverse Hessian (Fletcher, 2000). While eﬀective
in simulations, recent studies observed BFGS methods
do not perform well in experimental demonstrations of
VQA due to the level of noise in the cost function and
gradient estimates (Lavrijsen et al., 2020).

Two heuristics were proposed to ﬁnd quasioptimal pa-
rameters for QAOA using BFGS (Zhou et al., 2020a):
i) INTERP, where the optimized parameters at QAOA
level p are linearly interpolated and used as initial param-
eters for the level p + 1 optimization; and ii) FOURIER,
where instead of optimizing the 2p QAOA parameters
γ and β in Eq. (20), one can instead optimize 2q new
parameters u ≡ (u1, u2, . . . uq) and v ≡ (v1, v2, . . . vq) de-
ﬁned via the discrete sine and cosine transformations

γi(βi) =

q
∑
j=1

uj(vj) sin(cos) [(i −

1
2

) (j −

1
2

)

π
p

] .

(130)

Similarly to INTERP, the optimal parameters found at
level p are used to initialize the parameters for level p + 1.
Eﬃcient initialization of parameters has also been re-
ported using the Trotterized quantum annealing (TQA)
protocol (Sack and Serbyn, 2021). Note that these heuris-
tic strategies can be easily extended to gradient-free op-
timization methods such as Nelder-Mead.

Quantum natural gradient. The update rule of standard
gradient descent Eq. (29) has the implicit assumption
that the underlying parameter space is a ﬂat Euclidean
space. However, in general this is not the case, which can
severely hamper the eﬃciency of gradient descent meth-
ods. In classical machine learning, the natural gradient

85

was proposed that adapts the update rule to the non-
Euclidean metric of the parameter space (Amari, 1998).
As an extension to the realm of parameterized quantum
circuits, the quantum natural gradient (QNG) has been
proposed (Stokes et al., 2020). The update rule for this
method is

θ(t+1)
i

= θ(t)

i − η F −1(θ)∂if (θ) ,

(131)

where F(θ) is the Fubini-Study metric tensor or quan-
tum Fisher information metric given by

Fij = Re(⟨∂iψ(θ)∣∂jψ(θ)⟩−⟨∂iψ(θ)∣ψ(θ)⟩ ⟨ψ(θ)∣∂jψ(θ)⟩) .

(132)
Superior performance of the QNG compared to other gra-
dient methods has been reported (Stokes et al., 2020; Ya-
mamoto, 2019) and it has been shown that it can avoid
becoming stuck in local minima (Wierichs et al., 2020).
It can be generalized to noisy quantum circuits (Koczor
and Benjamin, 2019). The QNG can be combined with
adaptive learning rates η(θt
that change for every step
i
of gradient descent to speed up training. For hardware
eﬃcient PQCs, one can calculate adaptive learning rates
using the quantum Fisher information metric (Haug and
Kim, 2021b). While the full Fubini-Study metric tensor is
diﬃcult to estimate on quantum hardware, diagonal and
block-diagonal approximations can be eﬃciently evalu-
ated (Stokes et al., 2020) and improved classical tech-
niques to calculate the full tensor exist (Jones, 2020). A
special type of PQC, the natural PQC, has a euclidean
quantum geometry such that the gradient is equivalent
to the QNG close to a particular set of parameters (Haug
and Kim, 2021a).

Instead of using the
Quantum imaginary time evolution.
standard gradient descent for optimization, a varia-
tional imaginary time evolution method was proposed
in (McArdle et al., 2019a) to govern the evolution of
parameters. They focused on many-body systems de-
scribed by a k-local Hamiltonian and considered a PQC
that encodes the state ∣ψ(τ )⟩ as a parameterized trial
state ∣ψ(θ(τ ))⟩. The evolution of θ(τ ) with respect to
all the parameters can then be obtained by solving the
following diﬀerential equation

Aij∂τ θj(τ ) = Ci,

∑
j

(133)

with Aij = Re (⟨∂iψ(θ(τ ))∣∂jψ(θ(τ ))⟩) and Ci =
Re (− ∑α cα ⟨∂iψ(θ(τ ))∣ hα ∣ψ(θ(τ ))⟩), where hα and cα
are the Hamiltonian terms and coeﬃcients. It was later
shown in (Stokes et al., 2020) that the matrix Aij is re-
lated to the Fubini-Study metric tensor from Eq. (132),
and the imaginary time evolution is analogous to the gra-
dient descent via the QNG when considering inﬁnitesimal
small step sizes.

Hessian-aided gradient descent. A recent work (Huembeli
and Dauphin, 2021) proposed computing the Hessian and
its eigenvalues to help analyze the cost function land-
scapes of quantum machine learning algorithms. Track-
ing the numbers of positive, negative, and zero eigenval-
ues provides insight whether the optimizer is heading to-
wards a stationary point. The Hessian can be computed
by doubly applying the parameter shift rule as (Mitarai
and Fujii, 2019)

∂i∂jf (θ) =

1
2

(⟨f (θ¬(i,j), θi + α, θj + α)⟩ + ⟨f (θ¬(i,j), θi − α, θj − α)⟩

− ⟨f (θ¬(i,j), θi − α, θj + α)⟩ − ⟨f (θ¬(i,j), θi + α, θj − α)⟩),

(134)

where the shift parameter α = π
for gates generated
4λ
by operators with eigenvalues ±λ. Other parameters,
i.e. parameters not at the i-th and j-th indices, denoted
, are ﬁxed. To improve optimization, they pro-
θ¬(i,j)
pose setting the learning rate to the inverse of the largest
eigenvalue of the Hessian. Numerical simulations of the
Hessian-based method and QNG both showed improve-
ment over standard gradient descent in the ability to es-
cape ﬂat regions of the parameter landscape, with the
former requiring fewer training epochs than QNG. While
a deeper analysis is necessary to more closely compare
the performance, both QNG and Hessian-based methods
accelerate optimization by leveraging local curvature in-
formation.

Quantum Analytic Descent. A method consisting of us-
ing a classical model of the local energy landscape to
estimate the gradients is proposed in (Koczor and Ben-
jamin, 2020). In this hybrid approach, a quantum device
is used to construct an approximate ansatz landscape
and the optimization towards the minima of the corre-
sponding approximate surfaces can be carried out eﬃ-
ciently on a classical computer. The method considers
the ansatz circuit as a product of m unitary operations
as U (θ) = Um(θm)⋯U1(θ1) which, without loss of gener-
ality, can be approximated around a reference point θ0
as:

U (θ) = A(θ)U (A) +

+ Ck(θ)U (C)

k

]

[Bk(θ)U (B)

v
∑
k=1
[Dkl(θ)U (D)

k

kl

+

v
∑
l>k

] + O(sin3 δ),

(135)

86

approximate ansatz landscape, the full energy surface,
gradient vector and metric tensor can be expressed in
term of the ansatz parameters. The analytic descent has
been shown to achieve faster convergence as compared to
the QNG (Koczor and Benjamin, 2020).

Stochastic gradient descent. A major drawback of
gradient-based methods is the high number of measure-
ments. The stochastic gradient descent (SGD) algorithm
addresses this issue by replacing the normal parameter
update rule with a modiﬁed version

θ(t+1) = θ(t) − α g(θ(t)),

(136)

where α is the learning rate and g is an unbiased estima-
tor of the gradient of the cost function. There are many
choices for this estimator, for instance a measurement of
the gradient with a ﬁnite number of shots (Harrow and
Napp, 2019). It was also shown that it is not necessary to
include all Pauli terms in the evaluation of the cost func-
tion; sampling from a subset still results in well-behaved
gradient estimator. On top of that, it is possible to go
even further by combining this technique with sampling
of the parameter-shift rule terms (Sweke et al., 2020).

In the doubly stochastic gradient, ﬁnite measurements
are performed for only a subset of the expectation values
of the Hamiltonian terms. This sampling can be per-
formed in the extreme situation where only one Pauli-
term is evaluated at a single point in the quadrature.
This is a very powerful method that reduces the number
of measurements drastically (Anand et al., 2020b).

This method can be extended beyond circuits that al-
low the parameter-shift rule by expressing the gradient
as an integral (Banchi and Crooks, 2020). The integral
can be seen as an inﬁnite sum of terms that can be sam-
pled. To accelerate the convergence of SGD for VQA, two
optimization strategies are proposed (Lyu et al., 2020):
i) Qubit-recursive, where the optimization is ﬁrst per-
formed for a smaller quantum system and is then used
as initial parameter guess for a larger quantum system;
and ii) Layer-recursive, which is similar to a greedy ap-
proach, where the parameters are sequentially updated
layer-by-layer in the quantum circuit.

B. Gradient-free approaches

In this section, we discuss optimization methods for
VQA that do not rely on gradients measured on the quan-
tum computer.

where A, Bk, Ck, Dkl : Rv → R are products of sim-
ple univariate trigonometric functions, U (A), U (B)
, U (C)
,
k
U (D)
are discrete mappings of the gates and δ is the ab-
kl
solute largest entry of the parameter vector. Using this

k

strategies
algorithms. Evolutionary
Evolutionary
(Rechenberg, 1978; Schwefel, 1977) are black-box
optimization tools for high dimensional problems that
use a search distribution, from which they sample data,

to estimate the gradient of the expected ﬁtness to update
the parameters in the direction of steepest ascent. More
recently, natural evolutionary strategies (NES) (Wierstra
et al., 2014) have demonstrated considerable progress in
solving these high dimensional optimization problems.
They use natural gradient estimates for parameter
updates instead of the standard gradients. They have
been adapted for optimization of VQA (Anand et al.,
2020a; Zhao et al., 2020b) and have been shown to
have similar performance as the state-of-the-art gradient
based method.

The search gradients used in NES can be estimated as

∇J(θ) ≈

1
k

k
∑
n=1

f (zn)∇ log π(zn∣θ),

(137)

where J(θ) = Eθ[f (z)] is the expected ﬁtness, π(z∣θ) is
the density of the search distribution with parameter θ,
f (z) is the ﬁtness for the corresponding sample z drawn
from the search distribution and k is the diﬀerent number
of samples drawn from the distribution. The (classical)
Fisher matrix FC for the natural gradient can be esti-
mated as

FC ≈

1
k

k
∑
n=1

∇ log π(zn∣θ)∇ log π(zn∣θ)T

(138)

and the parameter update can then be carried out as
C ∇J(θ). In (Anand et al., 2020a) it is shown
θ = θ + η ⋅ F −1
that NES, along with techniques like Fitness shaping,
local natural coordinates, adaptive sampling and batch
optimization, can be used for optimization of deep quan-
tum circuits.

Reinforcement learning. Several authors have used rein-
forcement learning (RL) to optimize the QAOA parame-
ters (Khairy et al., 2019; Wauters et al., 2020b; Yao et al.,
2020a,b). This framework consists of a decision-making
agent with policy πθ(a∣s) parameterized by θ, which is a
mapping from the state space s ∈ {S} to an action space
a ∈ {A}. In response to the action, the environment pro-
vides the agent with a reward r from the set of rewards
{R}. The goal of RL is to ﬁnd a policy which maxi-
mizes the expected total discounted reward. For more
details, refer to Sec. VI.B.3. In the context of QAOA,
for example, {S} can be the set of QAOA parameters
(γ, β) used, a can be the value of γ and β for the next
iteration, and the reward can be the ﬁnite diﬀerence in
the QAOA objective function between two consecutive
iterations. The policy can be parameterized by a deep
neural network with the weights θ. The policy param-
eters θ can be optimized using a variety of algorithms
such as Monte-Carlo methods (Hammersley, 2013; Sut-
ton and Barto, 2018), Q-Learning (Watkins and Dayan,
1992) and policy gradient methods (Sutton and Barto,
2018).

87

In machine learning, the
Sequential minimal optimization.
sequential minimal optimization (SMO) method (Platt,
in optimizing the high-
1998) has proven successful
dimensional parameter landscape of support vector ma-
chines. The method breaks the optimization into smaller
components for which the solution can be found analyti-
cally. This method has been applied to variational circuit
optimization (Nakanishi et al., 2020), circuit optimiza-
tion with classical acceleration (Parrish et al., 2019b) and
circuit optimization and learning with Rotosolve and Ro-
tosolect (Ostaszewski et al., 2019). Although these algo-
rithms heavily rely on the parameter-shift rule, they can
be considered gradient-free methods. They exploit the
sinusoidal nature of the expectation value of a speciﬁc
operator ˆO when all but one parameters in the varia-
tional circuit are ﬁxed:

⟨ ˆO⟩ (θ) = A sin (θ + B) + C,

(139)

where A, B and C are parameters that can be found an-
alytically. This means that only three well-chosen circuit
evaluations are needed to exactly determine these coef-
ﬁcients and the optimal value θ∗ of the parameter θ for
this operator is given by

⎡
⎢
⎢
2⟨ ˆO⟩ (ϕ) − ⟨ ˆO⟩ (ϕ +
θ∗ = −arctan2
⎢
⎢
⎣

) − ⟨ ˆO⟩ (ϕ −

π
2

⟨ ˆO⟩ (ϕ +

π
2

) − ⟨ ˆO⟩ (ϕ −

π
2

)

+ 2πk − ϕ −

π
2

,

⎤
⎥
⎥
⎥
⎥
⎦

π
2

) ,

(140)

where arctan2 is the 2-argument arctangent and for any
integer k and angle ϕ. The most straightforward choice is
to set ϕ = 0 and choose k such that θ∗ ∈ (−π, π]. The algo-
rithm proceeds by looping over all the variational param-
eters until convergence. The method can be generalized
to optimize more than one parameter at a time (Nakan-
ishi et al., 2020; Parrish et al., 2019b) but no general
analytical expression can be found here. One has to re-
sort to numerical methods to ﬁnd the solutions for the
free parameters.

SMO oﬀers a versatile starting point that can be com-
bined with more advanced search acceleration algorithms
like Anderson acceleration (Anderson, 1965) or direct in-
version of the iterative subspace (DIIS) (Pulay, 1980).
The same tools have also been used to optimize categor-
ical variables like rotation axes in the Rotoselect algo-
rithm (Ostaszewski et al., 2019). While cost eﬃcient, se-
quential parameter optimization only takes into account
local information (albeit exactly), which often causes the
optimization to get stuck in local minima (Koczor and
Benjamin, 2020). One has to balance the speed of a local
method like SMO with the global approximate informa-
tion of methods like the quantum analytic descent for
speciﬁc problems.

Surrogate model-based optimization. When function eval-
uations are costly, it pays oﬀ to not only use the current
function value to inform a next parameter value, but to
use all previous evaluations to extract information about
the search space. The function values in memory are
used to build a surrogate model, an auxiliary function
that represents the full expensive cost function based on
the current information. The surrogate model of the cost
function can be evaluated cheaply and many of these eval-
uations can be used to inform the next parameter value
at which to compute the cost function. The new evalu-
ation of the true objective function is added to the set
of function values and the surrogate model is iteratively
reﬁned until convergence. All optimization happens on
the surrogate cost landscape, so no explicit derivatives
of the cost function are needed. Through the use of a
ﬁtted cost function, these methods are also expected to
be more resilient to noise.

Several classical surrogate models have been included
in the scikit-quant package (Lavrijsen and the scikit-
quant contributors, 2020; Lavrijsen et al., 2020).
In
the Bound optimization by quadratic approximation
(BOBYQA) algorithm (Powell, 2009), a local quadratic
model is formulated from the previous function values.
It is then minimized in the trust region to obtain a new
parameter value. When the evaluation at this new pa-
rameter value does not result in a lower function value,
the trust region is altered and the quadratic model is
optimized in this new parameter space.
It was shown
that this method works well when the PQC is initialized
close to the optimal parameters but has more problems
with shallow optimization landscapes and gets stuck in
local minima (Lavrijsen et al., 2020). The stable noisy
optimization by branch and ﬁt (SnobFit) (Huyer and
Neumaier, 2008) algorithm uses a branching algorithm
In these ar-
to explore new areas in parameter space.
eas it proposes several evaluation points and from the
function values it ﬁts a quadratic model. The algorithm
combines this local search with an explorative generation
of points in new areas of the parameter space. SnobFit
performs well when tight bounds on the parameters are
available (Lavrijsen et al., 2020). This can be achieved by
combining the method with other optimizers that limit
the size of the parameter space.

In (Sung et al., 2020), a trust region with a least-
squares ﬁt to a quadratic function is used. They ﬁnd
that the minimum of the quadratic function often lies
outside of the trust region, which causes the algorithms
to constantly readjust it. Instead of using standard trust
region optimization, they use either standard gradient
descent or policy gradient descent optimization on the
quadratic function to deﬁne a search direction in the pa-
rameter space. Both the model gradient descent (MGD)
as the model policy gradient (MPG) have a hyperparam-
eter that gradually shrinks the set of points used for the
ﬁt around the current minimum as the optimization pro-

88

gresses. The authors show that their algorithms are well
suited for realistic conditions on near-term hardware. In
particular, they study the ability of the algorithm to take
into account a cloud access situation where circuits need
to be uploaded in batches with a certain latency. The
MPG outperforms MGD in the case of gate errors due to
the ability to handle a large level of uncertaintity while
learning its policy (Sung et al., 2020).

C. Resource-aware optimizers

Optimization methods and strategies adopted for early
demonstrations of VQA are largely general-purpose and
black-box with minimal emphasis on reducing the quan-
tum resources used in the optimization. Therefore, they
are more costly and prone to errors than their classi-
cal counterparts. Optimizers developed in more recent
years are tailored to additionally minimize quantities as-
sociated with the quantum cost of the optimization, e.g.
number of measurements or real hardware properties.
Additionally, one can use circuit compilation methods
as the ones described in Sec. V.B.

ROSALIN. While VQA leverage low-depth circuits to
execute on near-term quantum processors, a signiﬁcant
challenge in implementing these algorithms is the pro-
hibitive number of measurements, or shots, required to
estimate each expectation value that is used to com-
pute the objective. To address the challenge, (Arra-
smith et al., 2020b) developed a shot-frugal optimizer
called ROSALIN (Random Operator Sampling for Adap-
tive Learning with Individual Number of shots) that ef-
fectively distributes fractions of a predeﬁned number of
shots to estimate each term of the Hamiltonian as well
as each partial derivative. Given the expectation value
of the Hamiltonian decomposed into the hi terms as in
Eq. (3), the authors note several strategies for allocat-
ing shots for estimating each term ⟨hi⟩. While a naive
strategy would allocate equal numbers of shots per term,
the authors observed lower variance in the energies us-
ing weighted approaches in which the number of shots
allocated to the i-th term bi is proportional to the corre-
sponding Hamiltonian coeﬃcient ci. For instance, in the
∣ci∣
weighted deterministic sampling method, bi = btot
∑i ∣ci∣
where btot is the total number of shots. In the weighted
random sampling method, bi is drawn from a multino-
mial distribution with the probability of measuring the
i-th term weighted by ∣ci∣, i.e. pi = ∣ci∣
∑i ∣ci∣

In addition, ROSALIN employs iCANS (individual
Coupled Adaptive Number of Shots), an optimizer that
allocates shots for partial derivatives, as a subroutine
(Kübler et al., 2020). As a brief overview, the iCANs
algorithm allocates measurements for each partial deriva-
tive such that the expected gain per shot is maximized.

.

This gain depends on quantities such as the learning rate,
the Lipschitz constant of the cost function, and estimates
of gradient components and their variances. Through
VQE optimizations, ROSALIN was shown to outperform
other optimizers such as iCANS and Adam especially in
the presence of noise.

In experimental realizations of VQA, the opti-
SPSA.
mizer is often hindered by statistical noise.
In (Kan-
dala et al., 2017) this issue is circumvented by apply-
ing the simultaneous perturbation stochastic approxima-
tion (SPSA) algorithm (Spall, 1992), in which the algo-
rithm hyperparameters are determined by experimental
data on the level of statistical noise. Compared to the
ﬁnite-diﬀerence gradient approximation, which requires
O(p) function evaluations for p parameters, SPSA re-
quires only two evaluations. That is, for a small positive
bk, the gradient at k-th iteration is approximated as

gk(θk) =

⟨ψ(θ+

k)∣ H ∣ψ(θ+

k)⟩ − ⟨ψ(θ−
2bk ∆k

k)∣ H ∣ψ(θ−

k)⟩

, (141)

where ∆k is a random perturbation vector and θ±
k =
θk ± bk∆k. After computing the gradient estimate, the
next parameter settings are updated with learning rate
ak. In general, bk and ak decrease over iterations, e.g.
for some ﬁxed γ and α. The
bk = b
kγ
values of b and a are carefully estimated to be robust
against statistical noise based on samples of energy diﬀer-
ences ∣ ⟨ψ(θ+
k)⟩ ∣. The con-
k)⟩ − ⟨ψ(θ−
vergence of SPSA with various types of PQCs has been
studied (Woitzik et al., 2020).

and ak = a
kα

k)∣ H ∣ψ(θ+

k)∣ H ∣ψ(θ−

C. NISQ APPLICATIONS FOR FINANCE

The subject of ﬁnance deals with money and invest-
ments. The three typical subdivisions of this ﬁeld are;
personal ﬁnance, corporate ﬁnance and public ﬁnance.
Due to its practical relevance, comprehensive and rig-
orous investigations have been carried out to compre-
hend ﬁnance using techniques from mathematics. Some
of the typical applications from ﬁnance which could po-
tentially beneﬁt from quantum technologies are portfolio
optimization, modelling ﬁnancial markets via diﬀerential
equations and predicting market trends. In the following
lines, we present one possible approach to classify math-
ematical problems in ﬁnance (Egger et al., 2020a).

Optimization based. Many of the ﬁnance problems in-
volve decision-making subject to certain constraints and
consequently fall in the optimization framework. Some of
the typical examples of optimization problems in ﬁnance
are portfolio optimization, portfolio diversiﬁcation and

89

auctions. Concepts from convex optimization and com-
binatorial optimization turn out to be appropriate for the
aforementioned class of problems. A considerable num-
ber of optimization centric problems can be converted
to QUBO (see Eq. (37) in section Sec. III.A). Quantum
algorithms for linear systems, convex optimization and
QUBO have been employed with the hope for a possi-
ble advantage. In particular, the problems which can be
reduced to QUBO have been investigated extensively us-
ing quantum annealing, VQE and QAOA (Bouland et al.,
2020; Hodson et al., 2019).

The simulation problems in ﬁnance
Simulation based.
deal with simulating potential outcomes, typical exam-
ples being simulating the inﬂuence of volatility on risk
or estimating asset values for pricing. Monte-Carlo sim-
ulations and algorithms for stochastic processes are par-
ticularly beneﬁcial for such tasks. Consequently, quan-
tum Monte-Carlo algorithms and quantum algorithms
for modelling stochastic processes have been investigated
in the context of ﬁnance (Blank et al., 2020a; Bouland
et al., 2020; Egger et al., 2020a; Kubo et al., 2020; Ramos-
Calderer et al., 2019).

Some of the standard ma-
Machine learning based.
chine learning based problems in ﬁnance require predict-
ing a future event based on historical data, pattern and
anomaly detection, and classiﬁcation of the end result in
categories. Sample problems are fraud detection, algo-
rithmic trading, risk assessment and credit scoring. One
can potentially hope to apply QML algorithms as the
ones presented in Sec. VI.B for such tasks.

The complete coverage of quantum ﬁnance is out-
side the scope of this review. We direct the reader to
(Bouland et al., 2020; Egger et al., 2020a; Orus et al.,
2019) for a comprehensive treatment. We proceed to
discuss portfolio optimization and fraud detection; two
canonical examples from ﬁnance. The algorithms that
appear in this subsection are listed in Table V.

A. Portfolio optimization

The mathematical notion of portfolio optimization,
was ﬁrst proposed in (Markowitz, 1952). Given some
capital and set of m assets, the goal is to ﬁnd the best
investment strategies under a set of constraints. Some
of the typical constraints could be non-negativity of the
investment or limit on total budget B. The objective
function could be variance of the whole portfolio or over-
all risk. Let us represent the overall portfolio allocation
by x ∈ Rm, where xk denotes the investment in the k-th
asset. Suppose the return at time step t is c(t) ∈ Rm with
expected return µ ∈ Rmand covariance matrix Σ ∈ Rm×m

given by

µ(T ) =

Σ(T ) =

1
T

∑
t∈[T ]
1
T − 1

∑
t∈[T ]

c(t),

(142)

(c(t) − µ) (c(t) − µ)T .

(143)

With some additional equality constraints captured by
A ∈ Rm×m and b ∈ Rm, such as the total budget constraint
∑ xi = B, the portfolio optimization task corresponds to
the following program,

xT Σx , s.t cT x = µ , AT x = b.

(144)

min
x∈Rm

We can introduce Lagrange multipliers η and θ for the
equality constraints, and get the following Lagrangian
corresponding to the aforementioned program,

L (x, η, θ) =

1
2

xT Σx + η (cT x − µ) + θ (AT x − b) .

(145)

The solution to the portfolio optimization Eq. (144) re-
duces to solving the following linear system,

⎡
⎢
⎢
⎢
⎢
⎢
⎣

0 0 cT
0 0 AT
c A Σ

⎤
⎥
⎥
⎥
⎥
⎥
⎦

⎡
⎢
⎢
⎢
⎢
⎢
⎣

η
θ
x

⎤
⎥
⎥
⎥
⎥
⎥
⎦

=

⎡
⎢
⎢
⎢
⎢
⎢
⎣

µ
b
0

⎤
⎥
⎥
⎥
⎥
⎥
⎦

(146)

In (Rebentrost and Lloyd, 2018) the HHL algorithm
was proposed to implement the above approach with a
quantum computer. One can use near-term linear system
solvers for portfolio optimization tasks given assumptions
about hardware capabilities and input model are satis-
ﬁed (Huang et al., 2019). A modiﬁed version of the pro-
gram from Eq. (144) was recently tackled using VQE and
QAOA (Egger et al., 2020a). Speciﬁcally, the following
optimization program was attempted,

min
x∈{0,1}

m

qxT Σx − µT x , s.t. 1T x = B.

(147)

Here, the portfolio vector x ∈ {0, 1}m is a vector of binary
variables where xi = 1 means the ith asset was selected.
xi = 0 means otherwise. Similar to the previous case, µ
and Σ denote expected return and covariance matrix re-
spectively. The total budget has been denoted by B and
q > 0 captures the risk appetite of the decision maker.
It is assumed that all assets have same price and total
budget has to be spent. By adding the constraint as a
penalty term (1T x − B)
, the authors convert optimiza-
tion program Eq. (147) to a QUBO problem, which fur-
ther reduces to an appropriate Hamiltonian ground state
problem. They employ both VQE and QAOA hereafter.
They also study portfolio diversiﬁcation, by again con-
verting the same to QUBO (Egger et al., 2020a). Since
problems which can be converted in QUBO can be a
good ﬁt for annealing based optimization, quantum an-
nealing has been extensively applied for portfolio opti-
mization (Cohen et al., 2020; Marzec, 2016; Rosenberg

2

90

et al., 2016; Venturelli and Kondratyev, 2019). For de-
tails, refer to (Bouland et al., 2020; Orus et al., 2019).
In (Alcazar and Perdomo-Ortiz, 2021), a quantum opti-
mization strategy exploiting generative machine learning
models to bypass the need for constructing QUBO or
PUBO cost functions has been proposed. Besides acting
as a black-box solver (i.e., an optimizer which is agnostic
to the details of the cost function), it was shown that this
quantum portfolio optimization strategy scales to indus-
trial data sets such as the entire S&P 500 by leveraging
quantum-inspired models based on tensor networks, in-
stead of using hardware models.

B. Fraud detection

Machine learning can be utilised to detect ﬁnancial
frauds. A typical example could be somebody’s credit
card getting blocked because higher than usual transac-
tion was under process. Based on the historical data,
often a fraudulent transaction can be caught. There are,
however, false positives also. A typical example of false
positive is somebody’s credit card transaction getting de-
clined when trying it at a new store. Based on synthetic
credit card transaction data in Ref. (Altman, 2019), vari-
ational quantum classiﬁcation was performed in Ref. (Eg-
ger et al., 2020a). The example problem in Ref. (Egger
et al., 2020a) contains dataset with 100 purchase trans-
action records with each transaction k marked fraudulent
(yk = −1) or not fraudulent (yk = 1). The k-th transac-
tion input vector xk contains information about trans-
action amount, time, method and location. Variational
quantum classiﬁcation was used to predict the right la-
bel. A similar analysis using variational QBM was car-
ried on in Ref. (Zoufal et al., 2020). NISQ algorithms
for anomaly detection, such as (Herr et al., 2020), could
also be used for detecting ﬁnancial frauds.

D. UNITARY T-DESIGN

The primary objective of unitary t-designs is to sub-
stitute with a ﬁnite sum the integration over the space
of unitaries. The aforementioned approach provides an
accessible way to ﬁnd the average of functions over uni-
taries and then prove intriguing theorems about them.
The set of unitaries U(d) forms a topologically compact
and connected group. Furthermore, they correspond to
the set of norm-preserving matrices in Cd. We can deﬁne a
unique translation-invariant measure, the Haar measure,
on U(d) which can be employed to calculate expectation
values of functions of unitaries,

⟨f ⟩ = ∫

U(d)

f (U ) dU.

(148)

We present the aforementioned statement in a relatively
formal manner.

Deﬁnition 4 Let U be a group of n × n unitaries. A
probability measure µ on U is called Haar measure on U
if for any subset S ⊆ U and for any ﬁxed K ∈ U, we have

µ (KS) = µ (SK) = µ (S)

(149)

where KS ≡ {KU ∶ U ∈ S}and SK ≡ {U K ∶ U ∈ S} . The
property in Eq. (149) is called translation invariance.

Because of translation invariance,

if U1 is a Haar-
distributed random unitary matrix, then so are U U1 and
U1U for a ﬁxed unitary matrix U. To present the concept
of unitary designs, we need to ﬁrst discuss the notions of
homogeneous polynomials (Hom(a, b)) and weight func-
tions, deﬁned in the context of unitary matrices. Any
polynomial of degree a in the entries of U ∈ U(d) and
b in U † is called a homogeneous polynomial Hom(a, b).
Some of the examples of homogeneous polynomials are
U †V †U V ∈ Hom(2, 2) and V U †V U ∈ Hom(3, 1). A
for all
weight function on a set S, w ∶ S → (0, 1],
U ∈ S satsﬁes the following two properties: (i) w(U ) ≥
0 and (ii) ∑U ∈S w(U ) = 1. Having discussed the concepts

91

of homogeneous polynomials and weight function, we
proceed to deﬁne the notion of unitary t-designs.

Deﬁnition 5 Unitary t-design: Given a ﬁnite set S ⊂
U(d) and a weight function w ∶ S → (0, 1], the tuple
(S, w) is called a unitary t-design if for all f ∈ Hom(t, t)

∑
U ∈S

w(U )f (U ) = ∫

U(d)

f (U ) dU.

(150)

We will refer to unitary t-design as t-design henceforth.
Note that to verify if a tuple (S, w) forms a t-design, we
need to check the condition from Eq. (150) for every func-
tion f in Hom(t, t). For many cases, such an approach
might be impractical and hence it requires more tractable
condition, such as the one from the following Lemma.

Lemma 6 Given a ﬁnite set S ⊂ U(d) and a weight func-
tion w ∶ S → (0, 1], the tuple(S, w) forms a t-design if and
only if ∑U ∈S w(U )U ⊗t ⊗ (U †)⊗t
dU.

U ⊗t ⊗ (U †)⊗t

= ∫U (d)

