Deep Molecular Programming:
A Natural Implementation of Binary-Weight ReLU Neural Networks

Marko Vasic 1 Cameron Chalk 1 Sarfraz Khurshid 1 David Soloveichik 1

0
2
0
2

n
u
J

0
3

]
E
N
.
s
c
[

3
v
0
2
7
3
1
.
3
0
0
2
:
v
i
X
r
a

Abstract

Embedding computation in molecular contexts
incompatible with traditional electronics is ex-
pected to have wide ranging impact in synthetic
biology, medicine, nanofabrication and other
ﬁelds. A key remaining challenge lies in de-
veloping programming paradigms for molecular
computation that are well-aligned with the un-
derlying chemical hardware and do not attempt
to shoehorn ill-ﬁtting electronics paradigms. We
discover a surprisingly tight connection between
a popular class of neural networks (binary-
weight ReLU aka BinaryConnect) and a class
of coupled chemical reactions that are absolutely
robust to reaction rates. The robustness of rate-
independent chemical computation makes it a
promising target for bioengineering implemen-
tation. We show how a BinaryConnect neu-
ral network trained in silico using well-founded
deep learning optimization techniques, can be
compiled to an equivalent chemical reaction net-
work, providing a novel molecular programming
paradigm. We illustrate such translation on the
paradigmatic IRIS and MNIST datasets. Toward
intended applications of chemical computation,
we further use our method to generate a chemical
reaction network that can discriminate between
different virus types based on gene expression
levels. Our work sets the stage for rich knowl-
edge transfer between neural network and molec-
ular programming communities.

1. Introduction

Although molecular computation cannot compete with
electronics based on speed, the goal is to enable compu-
tation in contexts where traditional electronics cannot go.

1The University of Texas at Austin, USA. Correspondence to:

Marko Vasic <vasic@utexas.edu>.

Proceedings of the 37 th International Conference on Machine
Learning, Vienna, Austria, PMLR 119, 2020. Copyright 2020 by
the author(s).

Chemical control modules compatible with the chemical
environments within natural or synthetic cells, bioreactors,
and in-the-ﬁeld diagnostics, are all envisioned applications
for such technology. Such computation could, for example,
recognize disease state based on chemical inputs and actu-
ate drug delivery to the affected cell. The extensive infor-
mation processing that occurs in natural cellular regulatory
networks underlying all complex life, is a strong proof-of-
principle that chemical computation is possible and useful.

Networks of coupled chemical reactions (chemical reaction
networks, CRNs) are known to be Turing universal (Fages
et al., 2017; Soloveichik et al., 2008), but the resulting sys-
tematic ways of programming their behavior can result in
extremely large reaction networks and exceedingly inefﬁ-
cient computation. Reasoning in chemical reaction space
is difﬁcult: even a very small CRN can be hard to ana-
lyze. Thus, there were many previous attempts to build
intuitive, yet more efﬁcient programming approaches for
CRNs. For example, (Senum & Riedel, 2011) describe
a number of computational modules including arithmetic
modules and control ﬂow. Another example is CRN++ (Va-
sic et al., 2018), an imperative programming language that
compiles to CRNs. Here, we present a different program-
ming paradigm, one that allows translation of neural net-
works into chemical reactions. In a similar way that writ-
ing an image classiﬁer in an imperative language is pro-
hibitively complex, writing a classiﬁer in a molecular pro-
gramming language such as CRN++ is practically impossi-
ble. However, the technique of programming using neural
networks opens doors for such applications in the molecu-
lar programming community.

We focus on a class of neural networks called binary-
weight ReLU neural networks. These networks have bina-
rized weights {+1, −1}, and were originally popularized
due to their computational efﬁciency in electronics hard-
ware (Courbariaux et al., 2015). We show that binary-
weight ReLU networks have a tight correspondence to a
class of rate-independent CRNs (Chen et al., 2014a;b). In
rate-independent CRNs, computation arises solely from the
stoichiometric exchange of reactants for products and the
equilibrium is independent of reaction rates. The absolute
robustness to reaction rates makes rate-independent CRNs

 
 
 
 
 
 
Deep Molecular Programming: A Natural Implementation of Binary-Weight ReLU Neural Networks

a promising implementation target for bioengineering.

We ﬁrst demonstrate our approach by training classiﬁers
on the widely used machine learning datasets IRIS and
MNIST. A promising envisioned application of molecu-
lar computation lies in medical diagnostics and so called
“smart drugs” which activate in response to speciﬁc molec-
ular cues. Thus, we next train a classiﬁer to differentiate
between four viral infections using chemical information
as input (gene expression levels). In all cases, we translate
neural networks into CRNs, and simulate CRN behavior in
a chemical kinetics simulation framework. The chemical
reaction networks exhibit the same output as their corre-
sponding neural networks.

Section 2 ﬁrst reviews CRNs, and how we can view
their behavior as computation, then reviews binary-weight
ReLU networks and the BinaryConnect (Courbariaux et al.,
2015) method for training them. In Section 3, we ﬁrst in-
troduce a simple set of chemical reactions which compute
the ReLU function, then describe our general technique to
compile binary-weight ReLU networks into CRNs which
compute the same output. We also describe an optimization
procedure which reduces the number of chemical reactions
required to implement the neural network. In Section 4, we
give simulation results on our chemical classiﬁers for IRIS,
MNIST, and viral infection classiﬁcation, and verify that
their outputs match the neural networks they implement.

2. Background

In this section we provide a brief description of chemical
reaction networks and BinaryConnect neural networks.

2.1. Chemical Reaction Networks

Chemical reaction networks (CRNs) formally model the
time evolution of concentrations of chemical species in a
solution undergoing chemical change. CRNs are typically
used to understand naturally occurring chemistry and ab-
stract the behavior of existing biological regulatory net-
works. The CRN formalism thus provides a standardized
way to specify the interaction rules that we expect inter-
acting chemicals to obey in order to perform computa-
tion. Closely related models from distributed computing
include population protocols (Angluin et al., 2006), Petri
nets (Petri, 1966), and vector addition systems (Karp &
Miller, 1969).

A CRN is formally a set of chemical species (typically
written with capital letters) and a set of reactions between
them. A state of the CRN is an assignment of a nonnegative
real value to each species, representing the species’ con-
centrations (quantity per unit volume). As the state varies
over time, we denote by a(t) the concentration of species
A at time t. Each reaction is composed of two multisets

over the species, the reactants and products, which spec-
ify the stoichiometry (the relative quantities of the involved
species). For example, species A and B might react to pro-
duce species C, which we write as the reaction

A + B −→ C.

Each reaction has an associated rate constant which affects
the dynamics of state change of the system. Under typical
mass-action kinetics, the instantaneous rate of a reaction
is the product of the rate constant and the concentrations
of the reactants (i.e., k · a(t) · b(t) for the reaction above).1
The behavior of the whole system is then described by a set
of ordinary differential equations (ODEs) generated based
on the reactions. For example, if the reaction above is the
only one producing C, the kinetics of C is governed by
dc(t)/dt = k · a(t) · b(t).

To deﬁne CRN computation, some chemical species are
considered input species, and some others, disjoint from the
ﬁrst, are considered output species. The initial concentra-
tions of the input species are the input to the computation.
The system asymptotically converges to a state where the
concentrations of the output species are equal to the desired
output values.

Many CRN computations work under strong assumptions
about the rates of the reactions, but engineering reactions
with precise rates is difﬁcult, and small changes in the en-
vironment can further disturb these rates. Instead, compu-
tation can be achieved by stoichiometry alone (Chen et al.,
2014a;b), which forms the basis of the computation con-
sidered in this paper. The essential example is the reac-
tion we have already seen: A + B −→ C. The concen-
tration of C as time approaches inﬁnity is the min of the
initial concentrations of A and B, since the reaction can
occur only as long as both A and B are present. This
fact holds for any (nonzero) reaction rate. Thus we say
this CRN rate-independently computes the min function:
c = min(a(0), b(0)).

A programmable chemical process called DNA strand
displacement can in principle (and, to some extent, ex-
perimentally (Chen et al., 2013; Srinivas et al., 2017))
implement arbitrary, rationally designed CRNs (Solove-
ichik et al., 2010). Watson-Crick base pairing enables
programmability, since interactions are mediated by nu-
cleotide sequence complementarity.
In the basic DNA
strand displacement reaction, an “output” strand is initially
bound to a complementary strand. A single-stranded “in-

1Although the details of CRN kinetics is not essential for un-
derstanding the results in this paper, the numerical simulations are
done using continuous mass-action kinetics. In other models of
chemical kinetics the amounts of species are represented by non-
negative integer molecular counts and the system corresponds to
a continuous time Markov chain. Our results apply to this setting
as well, as long as real-valued signals are properly discretized.

Deep Molecular Programming: A Natural Implementation of Binary-Weight ReLU Neural Networks

put” binds to the double-stranded complex, displacing the
“output” strand. Extended designs based on this elemen-
tary reaction allow enzyme-free synthetic DNA systems to
behave as arbitrary CRNs.2

Rate-independent computation aligns well with the design
of DNA strand displacement systems. The stoichiometry
of a strand displacement reaction is engineered by setting
regions on two or more strands to be complementary or
In contrast, setting precise reaction rates re-
orthogonal.
quires designing speciﬁc sequences that achieve desired
hybridization free energies. Hybridization rates are highly
dependent on the temperature and on the chemical com-
position of the solution. Further, for a particular chemical
implementation, there is some maximum rate possible, so
requiring some reactions to be fast and others slow neces-
sarily requires slowing the entire system down.

Although concentrations of species are nonnegative, to im-
itate the computation done by a neural network we need
to store and process negative values. To do so, we repre-
sent negative values by the dual-rail convention: a value x
is represented not by the concentration of one species X,
but by the difference in concentration between two species
X + and X − (Chen et al., 2014b). More precisely, at time
t, x(t) = x+(t) − x−(t). Note that values have multiple
representations: x = 3 can be represented as either x+ = 3
and x− = 0 or x+ = 4 and x− = 1. Although the value is
the same, the choice of representation affects convergence
time. (Convergence time is an important question for future
work as mentioned in Section 6.)

2.2. Binary-Weight ReLU (BinaryConnect)

In recent years we have seen a growing interest in building
specialized deep learning hardware to enable new and more
complex deep learning applications as well as deploying
deep learning systems on low-power devices (Chen et al.,
2014c; Dean et al., 2012; Kim et al., 2009). One direction
of work tries to tackle this problem by designing more com-
putationally efﬁcient neural networks (Courbariaux et al.,
2015; Hubara et al., 2016; Li et al., 2016; Simons & Lee,
2019). One of the initial works in this area introduces Bi-
naryConnect networks (Courbariaux et al., 2015) which re-
strict the weights of neural networks to values ±1. This re-
striction on the weight values enables replacement of most
of the multiply units by simple accumulators which leads to
a drastic reduction of computational expenses, considering

2No reaction is truly irreversible; that is to say, if A + B −→
C, then C −→ A + B with some non-zero rate. However, nature
provides many examples of reactions which are effectively irre-
versible due to a large change in free energy between reactions
and products. Reactions implemented by DNA strand displace-
ment are thermodynamically driven by the formation of additional
nucleotide base pairs, which provide enough free energy for the
reaction to behave effectively irreversibly.

that the multipliers are the most space and power hungry
components of specialized deep learning hardware. More-
over, in spite of severe restriction on the weight values, Bi-
naryConnect still achieves near state-of-the-art results on
standard machine learning datasets.

BinaryConnect networks are trained similarly to tradi-
tional neural networks through a repeated sequence of: (a)
forward-propagation pass computing the output of a net-
work given an input; (b) backward-propagation pass com-
puting error terms (derivatives of the cost function in re-
spect to weights and bias terms); and (c) parameter updates
(updating weight and bias terms based on the error terms).
BinaryConnect maintains real-valued weights throughout
training, but discretizes them to 1 or −1 (if positive or
negative, respectively) during the forward and backward-
propagation passes. The parameter update is then per-
formed on the real-valued weights. The ﬁnal binary-weight
neural network is generated by discretizing the resulting
real-valued weights at the end of training. (Other variations
of BinaryConnect training, such as stochastic discretiza-
tion, are described in the original paper.)

3. Technique

First we describe the technique for compiling binary-
weight ReLU networks to CRNs. Then we show how to
optimize the CRNs to reduce the total number of reactions.
Ultimately, there will be one reaction per ReLU node.

3.1. ReLU Chemical Reaction Network

We propose the following CRN to compute the ReLU func-
tion:

X + −−→ M + Y +

M + X − −−→ Y −

(1)

(2)

In order to understand why the above reactions compute
ReLU, suppose we start with x+(0) amount of X + and
x−(0) amount of X − and no other species. These concen-
trations represent the input value x(0) = x+(0) − x−(0)
in dual-rail form. Although the two reactions will be hap-
pening in parallel, the ﬁrst reaction converges to produc-
ing x+(0) amount of M and Y +. Therefore, the sec-
ond reaction converges to producing min(x+(0), x−(0))
of Y −. This implies that the system converges to the dual-
rail value of the output y = y+(t) − y−(t) = x+(0) −
min(x+(0), x−(0)) = (x+(0) − x−(0)) − min(x+(0) −
x−(0), x−(0) − x−(0)) = x − min(x, 0) = max(x, 0).
Note that this CRN is rate-independent because the com-
putation will be correct no matter what the rates of the in-
dividual reactions are.

Since the output species Y + and Y − are not consumed
in the above CRN, they can be used as input species for

Deep Molecular Programming: A Natural Implementation of Binary-Weight ReLU Neural Networks

1 we include a reaction with a positive input species as a re-
actant and positive output species as a product, as that has
the effect of addition to the product species’ value. For a
weight with value −1 we include a reaction with a positive
input species as a reactant and negative output species as a
product, as that has the effect of subtraction from the prod-
uct species’ value. To maintain the dual-rail convention we
also include a reaction which contains all the same species
with signs ﬂipped. Next, to implement the ReLU activation
function we use the module discussed above (reactions 1–
2), with the appropriate renaming of species:

I +
1,1 −−→ M1,1 + H +
1,1
M1,1 + I −
1,1 −−→ H −
1,1

I +
1,2 −−→ M1,2 + H +
1,2
1,2 −−→ H −
M1,2 + I −
1,2

I +
1,3 −−→ M1,3 + H +
1,3
1,3 −−→ H −
M1,3 + I −
1,3

(7)

(8)

(9)

(10)

(11)

(12)

Each intermediate species Il,i of the hidden layer l is a part
of a separate ReLU module producing output species Hl,i.
Finally, to multiply by the weight vector w2 we use the
following reactions (similar to the multiplication by W1):

H +
H −
H +
H −
H +
H −

1,1 −−→ Y +
1,1 −−→ Y −
1,2 −−→ Y +
1,2 −−→ Y −
1,3 −−→ Y −
1,3 −−→ Y +

(13)

(14)

(15)

(16)

(17)

(18)

The Y species are the output species, and the value y =
y+(t) − y−(t) approaches ReLU (x(cid:62) · W1) · w2 as t goes
to inﬁnity.

Figure 1. Binary-weight neural network.

any composed downstream computation without interfer-
ing with the computation of ReLU. Reactions 1–2 form the
simplest CRN computing ReLU in the sense that there is no
composable CRN with fewer than 2 reactions and 5 species
computing this function (Vasic et al., 2019).3

3.2. Compiling Binary-Weight ReLU Networks

Figure 1 shows an example binary-weight ReLU network.
This network consists of an input layer, a single hidden
layer with the ReLU activation function, and an output
layer without an activation function. Let us initially ignore
the bias terms. Then the output of the network is deﬁned
by y = ReLU (x(cid:62) · W1) · w2, where x ∈ R2 is an input
vector, W1 ∈ {−1, 1}2×3 is a weight matrix into the hid-
den layer, w2 ∈ {−1, 1}3 is a weight vector into the output
layer, and y ∈ R is the output. The Figure 1 neural network
weight values are:
(cid:20) 1
1
1
−1 −1 −1

, w2 = (cid:2)1

1 −1(cid:3)(cid:62)

W1 =

(cid:21)

We now convert this binary-weight ReLU network into a
CRN. Initially, for each input xi in the input vector, species
X +
i (0) = xi.
We multiply the input vector by the weights W1 by the
following reactions:

i will be present such that x+

i and X −

i (0)−x−

X +
X −
X +
X −

1 −−→ I +
1 −−→ I −
2 −−→ I −
2 −−→ I +

1,1 + I +
1,1 + I −
1,1 + I −
1,1 + I +

1,2 + I +
1,3
1,2 + I −
1,3
1,2 + I −
1,3
1,2 + I +
1,3

(3)

(4)

(5)

(6)

The complete equation of the neural network with bias
(cid:62)) · w2 + b2. To
terms is: y = ReLU (x(cid:62) · W1 + b1
encode bias terms b1, it is enough to set initial concen-
trations of the hidden layer I1,i species accordingly (e.g.,
i+
11(0) − i−
11(0) should be equal to the ﬁrst component of
vector b1); similarly for b2 and Y species.

Species Il,i represents the ith intermediate (before applying
nonlinearity) species of the layer l. For a weight with value

3There is a simpler, non-composable ReLU computing CRN:
X + −→ Y +, Y + + X − −→ W . (W is an inert waste species.)
It cannot be combined with another CRN which uses species Y +
as an input, as Y + may be consumed by the downstream CRN
before it is annihilated by the second reaction. Composability is a
well-understood feature in rate-independent CRNs (Chalk et al.,
2018; Severson et al., 2019).

We summarize the compilation procedure in Algorithm 1.
The input of the algorithm is a binary-weight ReLU net-
work (nn), and the output is its CRN equivalent. We iter-
ate through all the layers of nn starting from the ﬁrst hid-
den layer and including the output layer (layer number 1 is
the input layer). If a layer does not contain the nonlinear
activation (ReLU) we include reactions directly producing
the layer output species (named H), otherwise intermediate

W1X1X2H1H2H3Yw21-11-11-111-1Deep Molecular Programming: A Natural Implementation of Binary-Weight ReLU Neural Networks

Algorithm 1 NNCompile(±1-weight neural network: nn)

if l == 1 else H +

l−1,i}

pSign = ‘ + ’ if W [i, j] == 1 else ‘ − ’
rxn.products.add(pN amepSign

)

l,j

end for
crn.add(rxn)
crn.add(rxn.reverseSigns())

pN ame = ‘H’ if a.linear() else ‘I’
for i = 1 to W.dimsX do
rxn = newReaction()
rxn.reactants = {X +
i
for j = 1 to W.dimsY do

1: crn = newCRN ()
2: for l = 2 to nn.numLayers() do
layer = nn.getLayer(l)
3:
4: W, b, a = layer.params()
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27: end for
28: return crn

end for
for j = 1 to W.dimsY do

crn.add(I +
crn.add(Ml,j + I −

end if
if a.nonlinear() then

l,j −→ Ml,j + H +
l,j)
l,j −→ H −
l,j)

crn.setConc(pN ame−

crn.setConc(pN ame+

end if
end for

if b[j] > 0 then

l,j, b[j])

else

l,j, −b[j])

species are produced ﬁrst (named I); the name of the ap-
propriate product species is stored in pN ame (line 5). We
iterate through the rows of the weight matrix (W ), creating
one reaction per row, where the reactant is H +
l−1,i (ith unit
of the previous layer), or X +
in the case where the previous
i
layer is the input layer (line 8). To construct the products
of the reaction, we iterate through all of the columns of W ,
adding pN ame species with positive sign when the weight
is +1 or negative sign when the weight is −1 (lines 10–11).
For a valid dual-rail computation, we include such a con-
structed reaction to the CRN (line 13), as well as the same
reaction with the signs of all the species ﬂipped (line 14).
Next, we set the initial concentrations of pN ame species to
correspond to the bias terms. If a bias term is positive, we
set the positive species to b[j], otherwise we set the negative
species to −b[j] (lines 17–21). Finally, if the layer contains
a ReLU activation, we include the ReLU CRN taking as
inputs layer intermediate (I) species and producing layer
output (H) species. Note that unlike in the previous exam-
ple, the network output species will be denoted by HN,j
(where N is the number of layers in the network).

To compute with the CRN, we provide input x by setting
the initial concentrations of the input species X as follows.
If a component xi of the input vector is non-negative, then
the concentration of the positive input species X +
is set
i
to xi; otherwise the concentration of the negative input

species X −
is set to −xi. Note that in chemistry, reactions
i
occur in parallel, so layers begin their computation before
the previous ones complete, unlike typical neural network
architectures.

3.3. Optimization: Reducing the Compiled CRN

We ﬁnd that unimolecular reactions, such as the ﬁrst reac-
tions of ReLU modules, can be eliminated from the CRN
by altering the bimolecular reactions and the initial concen-
trations of the CRN species, a process which we describe
next. Unimolecular reactions are those with exactly one
reactant like A −→ B + C. Whenever A is produced in
another reaction, we can replace it with B + C. For exam-
ple, if there is another reaction X −→ A + B, we replace
the reaction with X −→ 2B + C. Further, we adjust the
initial concentrations of the product species (B and C) by
increasing them by the initial concentrations of the reactant
(A). Importantly, this transformation works only if A is not
a reactant in any other reaction; for example, if there were
another reaction like X + A −→ Y , it is not clear what to
replace instances of A with, and indeed it is not possible to
remove the unimolecular reaction in that case. Luckily, our
construction has the property that any species occurs as a
reactant in at most one reaction.

We will now illustrate the aforementioned elimination pro-
cedure on the neural network CRN presented in Sec-
tion 3.2, characterized by reactions 3–18. We start by re-
moving the downstream-most unimolecular reactions (re-
actions 13–18), although the order does not matter. Remov-
ing these reactions and adjusting the products accordingly
results in the following CRN:

1,2 + I +
1,3
1,2 + I −
1,3
1,2 + I −
1,3
1,2 + I +
1,3

1,1 + I +
1,1 + I −
1,1 + I −
1,1 + I +

1 −−→ I +
X +
1 −−→ I −
X −
2 −−→ I −
X +
X −
2 −−→ I +
I +
1,1 −−→ M1,1 + Y +
M1,1 + I −
1,1 −−→ Y −
I +
1,2 −−→ M1,2 + Y +
M1,2 + I −
1,2 −−→ Y −
I +
1,3 −−→ M1,3 + Y −
M1,3 + I −
1,3 −−→ Y +

(19)

(20)

(21)

(22)

(23)

(24)

(25)

(26)

(27)

(28)

Note that the initial concentrations of Y species are un-
affected as species H1,i are initially set to 0. Next, we
remove the now downstream-most unimolecular reactions
(reactions 23,25,27) and obtain the following CRN:

X +

1 −−→ M1,1 + M1,2 + M1,3 + 2Y + + Y −

X −

1 −−→ I −

1,1 + I −

1,2 + I −
1,3

(29)

(30)

Deep Molecular Programming: A Natural Implementation of Binary-Weight ReLU Neural Networks

(31)

(32)

(33)

(34)

X +

2 −−→ I −

1,1 + I −

1,2 + I −
1,3

X −

2 −−→ M1,1 + M1,2 + M1,3 + 2Y + + Y −
M1,1 + I −
M1,2 + I −
M1,3 + I −

1,1 −−→ Y −
1,2 −−→ Y −
1,3 −−→ Y +

(35)
The initial concentrations of M1,1, M1,2, M1,3, Y + and
Y − are also affected:

1,2(0)

m1,i(0) += i+
y+(0) += i+
y−(0) += i−

1,i(0), ∀i ∈ {1, 2, 3}
1,1(0) + i+
1,3(0)
The only remaining unimolecular reactions are those
whose reactants are input species (X). We do not apply the
above elimination procedure to these unimolecular reac-
tions because doing so would remove the input species en-
tirely. Then giving the input to the CRN would require set-
ting the initial concentrations of a number of other species,
complicating the input representation.

Note that the CRN can be further simpliﬁed while preserv-
ing dual-rail values. Reactions 29 and 32 can be reduced
to:

X +
X −

1 −−→ M1,1 + M1,2 + M1,3 + Y +
2 −−→ M1,1 + M1,2 + M1,3 + Y +
Further, the initial concentrations of Y + and Y − can be
reduced by the same amount to make the smaller one zero.

(37)

(36)

In general, the CRN resulting from the optimization proce-
dure has the following properties. There are no unimolecu-
lar reactions besides the input layer, for which there are two
reactions per input. There is one bimolecular reaction per
ReLU node of the original network. There are no other re-
actions. Optimization of some adversarial ReLU networks
results in reactions with a number of products exponential
in the depth of the network. Understanding the scaling of
the number of products is an important avenue for future
work to ensure feasible CRNs.

Algorithm 2 summarizes the reduction procedure. The al-
gorithm ﬁrst collects a list of all unimolecular reactions
(line 1). Then, for each unimolecular reaction (R −→
(cid:80)
i Pi) the following steps are done: (a) if reactant R is
an input species the following steps are skipped and the
next reaction is processed (line 4); (b) for every reaction in
the CRN producing R, the list of products is altered by re-
moving the product R and adding products Pi (lines 6–11);
(c) the initial concentrations of species Pi are increased
by the amount of the initial concentration of R (line 13);
and (d) the unimolecular reaction is removed from the
CRN (line 15). After these steps we perform the follow-
ing behavior-preserving transformations that further sim-
plify the CRN. For each dual-rail value represented by S+

Algorithm 2 reduce(CRN: crn)

crn.addConc(Pi, r(0))

if rxni.containsP roduct(R) then

rxni.removeP roduct(R)
rxni.addP roducts(uniRxn.products)

end if
end for
for all Pi ∈ uniRxn.products do

R = uniRxn.getF irstReactant()
if crn.inputSpecies(R) then continue
r(0) = crn.getConc(R)
for all rxni ∈ crn.reactions do

1: uniRxns = crn.getU nimolecularReactions()
2: for all uniRxn ∈ uniRxns do
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16: end for
17: for all S+, S− ∈ crn.getDualRailP airs() do
18:
19:
20:
21:
22:
23:
24: m = min(crn.getConc(S+), crn.getConc(S−))
25:
26:
27: end for

while S+, S− ∈ rxni.products do
rxn.removeP roduct(S+)
rxn.removeP roduct(S−)

crn.addConc(S+, −m)
crn.addConc(S−, −m)

end for
crn.remove(uniRxn)

for all rxni ∈ crn.reactions do

end while

end for

and S− species we: (i) for every reaction whose products
multiset contain both S+ and S−, remove both species as
long as both are present (lines 18–23); (ii) reduce the ini-
tial concentrations of S+ and S− by the minimum of their
values (lines 24–26).

4. Experiments

In this section we describe computational experiments
showcasing compilation from neural networks to CRNs.
We train BinaryConnect networks on IRIS (Anderson,
1936; Fisher, 1936), MNIST (LeCun et al., 1998), and
virus infection datasets (GSE73072). We then translate
trained neural networks to CRNs following our compila-
tion technique (Section 3), and simulate the reactions’ be-
havior using an ODE simulator (CRNSimulator). The sim-
ulator models CRNs with real-valued concentrations in the
standard mass-action model of chemical kinetics, where the
rate of a reaction is directly proportional to the concentra-
tions of the reactants. Our main goal is to show the equiva-
lence of the trained neural network and the compiled CRN,
and not to improve accuracy of machine learning models,
which is orthogonal to our work.

4.1. Datasets

IRIS. The IRIS dataset consists of 150 examples of 3
classes of ﬂowers (Setosa, Versicolor or Virginica), and

Deep Molecular Programming: A Natural Implementation of Binary-Weight ReLU Neural Networks

4 features per example (sepal length and width, and petal
length and width). Considering the small dataset size and
that our goal is to show the equivalence of the neural net-
work and the translated CRN, we use the whole dataset for
both training and evaluation.

MNIST. The MNIST dataset consists of labeled handwrit-
ten digits, where features are image pixels, and labels are
digits (0 to 9). We split the original MNIST training set
consisting of 60, 000 images into 50, 000 for the training
set, and 10, 000 for the validation set. We use the original
test set consisting of 10, 000 images. In preprocessing, we
center the images (as is done in the BinaryConnect work),
and additionally we scale them from 28 × 28 to 14 × 14.

Virus Infection. For the virus infection classiﬁer, we used
data from NCBI GSE73072 (GSE73072). The dataset con-
tains microarray data capturing gene expression proﬁles of
humans, with the goal of studying four viral infections:
H1N1, H3N2, RSV, and HRV (labels). There are 148 pa-
tients in the dataset, each with about 20 separate proﬁles
taken at different times during their infection period, for a
total of 2, 886 samples. The dataset contains information
about which patient was infected and during which point
of time. We ﬁlter the samples leaving only those that cor-
respond to an active infection, and thus make the data suit-
able for classiﬁcation of the four viruses. Finally, we have
a total of 698 examples, split into 558 for training, 34 for
validation, and 104 for testing. Each sample measures ex-
pression of 12, 023 different genes (features); we use the
10 most relevant genes as features which are selected using
GEO2R tool (GEO2R) from the NCBI GEO.

4.2. Results

IRIS. We train a neural network with a single hidden layer
consisting of 8 units, 4 input units (capturing the features
of IRIS ﬂowers), and 3 output units where the unit with the
highest value determines the output class. Given that our
primary goal is to show the equivalence of a neural net-
work and the compiled CRN, and since the dataset size is
quite small (150 examples), we train and evaluate on the
whole IRIS dataset. We achieve accuracy of 94% (141 out
of 150 examples correctly classiﬁed) with a trained Bina-
ryConnect neural network. The equivalent CRN consists
of 40 chemical reactions (unoptimized compilation), and
16 chemical reactions (optimized compilation). We simu-
late both versions of the CRN and conﬁrm that their outputs
(labels) match the neural network in all 150 examples. Fig-
ure 2 shows the simulation results of the IRIS CRNs on an
example input, which is classiﬁed with label 0 (since the y0
output is largest). In both CRNs, the ﬁnal simulation val-
ues of y0, y1 and y2 match the output units values of the
neural network (approaching up to 4 decimal places in the
time of simulation). Thus not only does the CRN have the

same classiﬁcation output, but also the numerical values of
the individual dual-rail outputs match the output units of
the neural network. In regard to the dynamics of CRN con-
vergence, the reduced CRN converges signiﬁcantly faster.

MNIST. We train a binary-weight neural network with 2
hidden layers and 512 units per each hidden layer, where
hyperparameter values are obtained via a random search.
We downscale MNIST images from original 28 × 28 res-
olution to 14 × 14; thus the neural network has 142 input
units (one per pixel). We use 10 output units (for digits 0
to 9), and train the neural network to maximize the output
unit corresponding to the correct digit. Our trained model
achieves accuracy of 97.76% on the test set. Note that we
did not focus on achieving high accuracy; BinaryConnect
in the original paper achieves accuracy of over 98%, but
uses larger networks (3 hidden layers with 1024 units each).
We translate the network to an equivalent CRN consist-
ing of 4488 chemical reactions (unoptimized compilation),
and 1024 chemical reactions (optimized compilation). The
CRN consists of 2 · 142 input species (two species per in-
put unit encoding positive and negative parts), and simi-
larly 2 · 10 output species. We simulate the CRN on 100
randomly chosen examples from the test set, and conﬁrm
that the output matches that of the neural network in all of
the cases. Figure 3 shows simulation results on an example
input image (unoptimized CRN). In regard to the dynamics
of convergence, note the complex non-monotonic behavior
resulting from the mass-action kinetics.

Virus Infection. We train a neural network with 1 hid-
den layer with 32 units, 10 input units capturing expression
of different genes, and 4 output units classifying between
virus infections. We achieve test set accuracy of 95.20%.
The equivalent CRN consists of 148 chemical reactions
(unoptimized compilation), and 32 chemical reactions (op-
timized compilation). We simulate the CRN on 100 ran-
domly chosen examples from the test set and conﬁrm that
the output matches that of the neural network in all cases.
Figure 4 shows simulation of the unoptimized CRN on an
example that is misclassiﬁed.

The performed experiments empirically conﬁrm the sound-
ness of our compilation technique.

4.3. Training Speciﬁcs

We use the published implementation of BinaryConnect
networks (Courbariaux et al., 2015), and follow the train-
ing procedure outlined in Section 2.2. We do not use Batch
Normalization (Ioffe & Szegedy, 2015) because it would
incur multiplication and division operations at the infer-
ence stage (training stage is not a problem) that would be
hard to efﬁciently implement in CRNs. Instead, we rely on
Dropout (Srivastava et al., 2014) (stochastically dropping
out units in a neural network during training) as a regular-

Deep Molecular Programming: A Natural Implementation of Binary-Weight ReLU Neural Networks

(a) IRIS CRN Simulation.

(b) IRIS Reduced CRN Simulation.

Figure 2. Simulation of IRIS CRN (left) and IRIS CRN in reduced form (right) on the same example. Plots show concentrations of the
output species over time, i.e., the difference between positive and negative output species (yi(t) = y+
i (t)). Networks classify
given input with label 0. The reduced CRN converges signiﬁcantly faster. Note that the initial concentrations of output species change
after optimization based on the biases in the ReLU network, as described in Section 3.3.

i (t) − y−

(a) Input image.

(b) CRN simulation results.

Figure 3. Simulation of the MNIST CRN (part b) on an input image (part a). The image is encoded via the input species concentrations:
e.g., value 0.54 of the 65th pixel (4th row, 9th column) is represented via initial concentrations of x+
65 species. Simulation shows
concentrations of the output species over time, i.e., the difference between positive and negative output species (yi = y+
i ). The
CRN classiﬁes the input image as a number 4 (as y4 has the highest value).

65 and x−

i − y−

dataset for 200 epochs, and return the model that achieved
the best validation set accuracy. We use an exponentially
decaying learning rate.

The rate constants of all reactions are set to 1, and all chem-
ical simulations are performed for 50 arbitrary time units in
the CRNSimulator package (CRNSimulator).

5. Related Work

It has long been observed that biological regulatory net-
works arguably behave in manner analogous to neural net-
works. For example, both phosphorylation protein-protein
interactions (Bray, 1995; Hellingwerf et al., 1995) and tran-
scriptional networks (Buchler et al., 2003) can be viewed as
performing neural network computation.

The challenge of implementing neural networks in chem-
ical reaction networks also has a long history. For ex-
ample, Hjelmfelt et al (Hjelmfelt et al., 1991) propose a
binary-valued chemical neuron, whose switch-like behav-
ior relies on competition between excitation and inhibition.

Figure 4. Simulation of Virus Infection CRN on an example (mis-
classiﬁed example). Example is classiﬁed as HRV virus, while the
true label is H1N1.

ization technique. In all our experiments we use the square
hinge loss (as in BinaryConnect) with ADAM optimizer.

We train on MNIST dataset for 250 epochs, measuring the
validation accuracy at each epoch, and returning the model
that achieves the best validation accuracy during training.
We train on IRIS dataset for 10, 000 epochs, and return the
best performing epoch. We train on the Virus Infection

y0(setosa)y1(versicolor)y2(virginica)5101520time-10-505valuey0(setosa)y1(versicolor)y2(virginica)5101520time-10-505valuey0y1y2y3y4y5y6y7y8y91020304050time-1000-500500valuey0(H1N1)y1(H3N2)y2(HRV)y3(RSV)1020304050time-12-10-8-6-4-22valueDeep Molecular Programming: A Natural Implementation of Binary-Weight ReLU Neural Networks

Recently, Moorman et al (Moorman et al., 2019) proposed
an implementation of ReLU units based on a fast bimolec-
ular sequestration reaction which competes with unimolec-
ular production and degradation reactions. In contrast to
the prior work, our implementation relies solely on the sto-
ichiometric exchange of reactants for products, and is thus
completely independent of the reaction rates. Our CRN
is also more compact, using only a single bimolecular re-
action per neuron, with two species per every connection
(without any additional species for the neuron itself). Fi-
nally, in contrast to the prior schemes, our CRN converges
to a static rather than a dynamic equilibrium, which means
that all reactions cease ﬁring. This implies that our imple-
mentation does not waste energy to maintain state.

We use neural networks as a way to program chemistry.
The programming is done ofﬂine in the sense that neu-
ral networks are trained in silico. However, there is a
body of work on creating chemical systems that are ca-
pable of learning in chemistry (Blount et al., 2017; Chi-
ang et al., 2015). Although these constructions are much
more complex than ours, and arguably difﬁcult to realize,
they demonstrate the proof-of-principle that chemical in-
teractions such as those within a single cell are capable of
brain-like behavior.

Besides the above-mentioned theoretical work on chemical
neural networks, wet-lab demonstration of synthetic chem-
ical neural computation argues that the theory is not vapid
and that neural networks could be realized in chemistry.
A chemical linear classiﬁer reading gene expression lev-
els could perform basic disease diagnostics (Lopez et al.,
2018). Larger systems based on rate-dependent strand dis-
placement cascades were used to implement Hopﬁeld as-
sociative memory (Qian et al., 2011), and winner-take-all
units to classify MNIST digits (Cherry & Qian, 2018).

6. Conclusion

We demonstrate how BinaryConnect (weight ±1) neural
networks could be implemented in chemistry using rate-
independent chemical reaction networks. As proof of prin-
ciple, we demonstrate our scheme with numerical simula-
tions of resulting CRNs classifying the MNIST and IRIS
datasets. We further simulate a CRN constructed from a
ReLU network trained to classify a virus gene expression
dataset. Since this network relies on chemically available
information for input, this example argues for the poten-
tial biological and medical utility of programming chemi-
cal computation via a translation from neural networks.

Performing the simulations with rate constants on the or-
der of magnitude of those reported for DNA strand dis-
placement (103 to 104 M/s) (Srinivas et al., 2017) results
in roughly the conversion factor of 1 time unit = 100 to

1000 seconds of real time (assuming 10−6 M concentra-
tions). Although molecular systems may be orders of mag-
nitude slower than electronics, the time scales are compat-
ible with the intended applications such as interfacing with
biological regulatory networks or disease marker detection.
As a point of comparison, other implementations of chem-
ical neural networks also take hours to complete (Cherry &
Qian, 2018).

The convergence time of the CRNs described here scales
in a complicated way with many variables, from the depth
of the implemented neural network to the choice of rep-
resenting input values in dual-rail representation (an input
x = 3 can be represented for example as x+ = 3 and
x− = 0, or as x+ = 4 and x− = 1). Thus an important
area of future research is the formal proof of convergence
properties of the system. Empirically, we observed that de-
pending on the network architecture, the 90%-completion
time may increase sublinearly, linearly, or superlinearly (in
some contrived examples) with the number of layers.

Note that the concentrations of the positive (S+) and neg-
ative (S−) dual-rail species can become very large, despite
the value they represent remaining small. This can occur
in special cases of the networks we construct. This is un-
desired generally; in synthetic implementations, reactions
can use additional “fuel” species in addition to the species
designed in the formal CRN, so higher concentrations re-
quire more of such species. However, there is an easy ﬁx to
this problem: inclusion of the reaction S+ + S− −→ W ,
where W is some inert waste species. This cancellation re-
action leaves the signal value unchanged and reduces the
concentrations of the two species.

Although in principle arbitrary CRNs can be implemented
using DNA strand displacement reactions, current lab-
oratory demonstrations have been limited to small sys-
tems (Srinivas et al., 2017), and many challenges remain in
constructing large CRNs in the laboratory. Rate indepen-
dent CRNs offer an attractive implementation target due to
their absolute robustness to reaction rates.

Our construction is surprisingly compact in the sense that
we use exactly one reaction per ReLU node. This compact-
ness argues that neural networks may be a ﬁtting paradigm
for programming chemical computation. This invites the
exchange of knowledge between the molecular program-
ming and deep learning communities.

Acknowledgements

We thank the anonymous reviewers for constructive com-
ments and suggestions. This work was funded by NSF
grants CCF-1718903 to SK and CCF-1901025 to DS.

Deep Molecular Programming: A Natural Implementation of Binary-Weight ReLU Neural Networks

References

Anderson, E. The species problem in iris. Annals of the

Missouri Botanical Garden, 1936.

Angluin, D., Aspnes, J., Diamadi, Z., Fischer, M. J., and
Peralta, R. Computation in networks of passively mobile
ﬁnite-state sensors. Distributed computing, 18(4):235–
253, 2006.

Blount, D., Banda, P., Teuscher, C., and Stefanovic, D.
Feedforward chemical neural network: An in silico
chemical system that learns xor. Artiﬁcial life, 23(3):
295–317, 2017.

Bray, D. Protein molecules as computational elements in

living cells. Nature, 376(6538):307–312, 1995.

Buchler, N. E., Gerland, U., and Hwa, T. On schemes
of combinatorial transcription logic. Proceedings of
the National Academy of Sciences, 100(9):5136–5141,
2003.

Chalk, C., Kornerup, N., Reeves, W., and Soloveichik,
D. Composable rate-independent computation in con-
tinuous chemical reaction networks. In Ceska, M. and
Safr´anek, D. (eds.), Computational Methods in Systems
Biology - 16th International Conference, CMSB 2018,
Brno, Czech Republic, September 12-14, 2018, Pro-
ceedings, volume 11095 of Lecture Notes in Computer
Science, pp. 256–273. Springer, 2018. doi: 10.1007/
978-3-319-99429-1\ 15. URL https://doi.org/
10.1007/978-3-319-99429-1_15.

Chen, H.-L., Doty, D., and Soloveichik, D. Deterministic
function computation with chemical reaction networks.
Natural Computing, 13(4):517–534, 2014a.

Chen, H.-L., Doty, D., and Soloveichik, D.

Rate-
independent computation in continuous chemical reac-
tion networks. In Proceedings of the 5th conference on
Innovations in theoretical computer science, pp. 313–
326, 2014b.

Chen, T., Du, Z., Sun, N., Wang, J., Wu, C., Chen,
Y., and Temam, O. Diannao: A small-footprint high-
throughput accelerator for ubiquitous machine-learning.
ACM SIGARCH Computer Architecture News, 42(1):
269–284, 2014c.

Chiang, H.-J. K., Jiang, J.-H. R., and Fages, F. Recon-
ﬁgurable neuromorphic computation in biochemical sys-
tems. In 2015 37th Annual International Conference of
the IEEE Engineering in Medicine and Biology Society
(EMBC), pp. 937–940. IEEE, 2015.

Courbariaux, M., Bengio, Y., and David, J.-P. Binarycon-
nect: Training deep neural networks with binary weights
during propagations. In Advances in neural information
processing systems, pp. 3123–3131, 2015.

Mathematica package

CRNSimulator.
ing with
tions.
˜soloveichik/crnsimulator.html.

for work-
reac-
http://users.ece.utexas.edu/

networks

chemical

coupled

of

Dean, J., Corrado, G., Monga, R., Chen, K., Devin, M.,
Mao, M., Ranzato, M., Senior, A., Tucker, P., Yang,
K., et al. Large scale distributed deep networks.
In
Advances in neural information processing systems, pp.
1223–1231, 2012.

Fages, F., Le Guludec, G., Bournez, O., and Pouly, A.
Strong Turing completeness of continuous chemical re-
action networks and compilation of mixed analog-digital
programs. In International conference on computational
methods in systems biology, pp. 108–127. Springer,
2017.

Fisher, R. A. The use of multiple measurements in taxo-

nomic problems. Annals of eugenics, 1936.

GEO2R.

Identifying Differentially Expressed Genes.

https://www.ncbi.nlm.nih.gov/geo/
geo2r/.

GSE73072.

Host gene expression signatures of
H1N1, H3N2, HRV, RSV virus infection in adults.
https://www.ncbi.nlm.nih.gov/geo/
query/acc.cgi?acc=GSE73072.

Hellingwerf, K. J., Postma, P. W., Tommassen, J., and
transduction in bacteria:
Westerhoff, H. V.
Signal
phospho-neural network(s) in Escherichia coli? FEMS
microbiology reviews, 16(4):309–321, 1995.

Hjelmfelt, A., Weinberger, E. D., and Ross, J. Chemi-
cal implementation of neural networks and Turing ma-
chines. Proceedings of the National Academy of Sci-
ences, 88(24):10983–10987, 1991.

Chen, Y.-J., Dalchau, N., Srinivas, N., Phillips, A.,
Cardelli, L., Soloveichik, D., and Seelig, G.
Pro-
grammable chemical controllers made from DNA. Na-
ture nanotechnology, 8(10):755, 2013.

Hubara, I., Courbariaux, M., Soudry, D., El-Yaniv, R., and
Bengio, Y. Binarized neural networks. In Advances in
neural information processing systems, pp. 4107–4115,
2016.

Cherry, K. M. and Qian, L. Scaling up molecular pattern
recognition with DNA-based winner-take-all neural net-
works. Nature, 559(7714):370–376, 2018.

Ioffe, S. and Szegedy, C. Batch normalization: Accelerat-
ing deep network training by reducing internal covariate
shift. arXiv preprint arXiv:1502.03167, 2015.

Deep Molecular Programming: A Natural Implementation of Binary-Weight ReLU Neural Networks

Karp, R. M. and Miller, R. E. Parallel program schemata.
Journal of Computer and system Sciences, 3(2):147–
195, 1969.

Kim, S. K., McAfee, L. C., McMahon, P. L., and Olukotun,
K. A highly scalable restricted boltzmann machine fpga
In 2009 International Conference on
implementation.
Field Programmable Logic and Applications, pp. 367–
372. IEEE, 2009.

LeCun, Y., Bottou, L., Bengio, Y., Haffner, P., et al.
Gradient-based learning applied to document recogni-
tion. Proceedings of the IEEE, 1998.

Li, F., Zhang, B., and Liu, B. Ternary weight networks.

arXiv preprint arXiv:1605.04711, 2016.

Lopez, R., Wang, R., and Seelig, G. A molecular multi-
gene classiﬁer for disease diagnostics. Nature chemistry,
10(7):746–754, 2018.

Moorman, A., Samaniego, C. C., Maley, C., and Weiss, R.
A dynamical biomolecular neural network. In 58th IEEE
Conference on Decision and Control. IEEE, 2019.

Petri, C. A. Communication with automata. 1966.

Qian, L., Winfree, E., and Bruck, J. Neural network com-
putation with DNA strand displacement cascades. Na-
ture, 475(7356):368–372, 2011.

Senum, P. and Riedel, M. Rate-independent constructs for
chemical computation. In Biocomputing 2011, pp. 326–
337. World Scientiﬁc, 2011.

Severson, E. E., Haley, D., and Doty, D. Composable
computation in discrete chemical reaction networks. In

Proceedings of the 2019 ACM Symposium on Princi-
ples of Distributed Computing, PODC 19, pp. 1423,
New York, NY, USA, 2019. Association for Comput-
ing Machinery.
ISBN 9781450362177. doi: 10.1145/
3293611.3331615. URL https://doi.org/10.
1145/3293611.3331615.

Simons, T. and Lee, D.-J. A review of binarized neural

networks. Electronics, 8(6):661, 2019.

Soloveichik, D., Cook, M., Winfree, E., and Bruck, J.
Computation with ﬁnite stochastic chemical reaction
networks. Natural Computing, 7(4):615–633, 2008.

Soloveichik, D., Seelig, G., and Winfree, E. DNA as a
universal substrate for chemical kinetics. Proceedings of
the National Academy of Sciences, 107(12):5393–5398,
2010.

Srinivas, N., Parkin, J., Seelig, G., Winfree, E., and Solove-
ichik, D. Enzyme-free nucleic acid dynamical systems.
Science, 358(6369):eaal2052, 2017.

Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I.,
and Salakhutdinov, R. Dropout: a simple way to prevent
neural networks from overﬁtting. The journal of machine
learning research, 2014.

Vasic, M., Soloveichik, D., and Khurshid, S. CRN++:
molecular programming language. In International Con-
ference on DNA Computing and Molecular Program-
ming, pp. 1–18, 2018.

Vasic, M., Soloveichik, D., and Khurshid, S. CRNs ex-
posed: Systematic exploration of chemical reaction net-
works. arXiv preprint arXiv:1912.06197, 2019.

