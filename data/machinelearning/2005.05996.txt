Towards Memory Safe Python Enclave for Security Sensitive
Computation

Huibo Wang, Mingshen Sun, Qian Feng, Pei Wang, Tongxin Li, Yu Ding
Baidu Security, USA

0
2
0
2

y
a
M
2
1

]

R
C
.
s
c
[

1
v
6
9
9
5
0
.
5
0
0
2
:
v
i
X
r
a

ABSTRACT
Intel SGX Guard eXtensions (SGX), a hardware-supported trusted
execution environment (TEE), is designed to protect security-
sensitive applications. However, since enclave applications are
developed with memory unsafe languages such as C/C++, tradi-
tional memory corruption is not eliminated in SGX. Rust-SGX is the
first toolkit providing enclave developers with a memory-language.
However, Rust is considered a Systems language and has become
the right choice for concurrent applications and web browsers.
Many application domains such as Big Data, Machine Learning,
Robotics, Computer Vision are more commonly developed in
Python programming language. Therefore, Python application
developers cannot benefit from secure enclaves like Intel SGX and
Rust-SGX. To fill this gap, we propose Python-SGX, which is a
memory-safe SGX SDK providing enclave developers a memory-
safe Python development environment. The key idea is to enable
a memory-safe Python language in SGX by solving the following
key challenges: (1) defining a memory-safe Python interpreter (2)
replacing unsafe elements of Python interpreter with safe ones,
(3) achieving comparable performance to non-enclave Python
applications, and (4) not introducing any unsafe new code or
libraries into SGX. We propose to build Python-SGX with PyPy, a
Python interpreter written by RPython, which is a subset of Python,
and tame unsafe parts in PyPy by formal verification, security
hardening, and memory safe language. We have implemented
Python-SGX and tested it with a series of benchmarks programs.
Our evaluation results show that Python-SGX does not cause
significant overhead.

1 INTRODUCTION
In current systems, there is a large attack surface, including OS,
VMM (Virtual Machine Manager), and other running applications.
This makes it nearly impossible to inspect code for exploitable
bugs. Intel introduced Software Guard eXtensions (SGX) in 2013 to
provide applications the capability to defend their secrets through
the use of enclaves. An SGX enclave is a protected environment
consisting of only application code and data which is protected
from malware in OS, VMM, BIOS, drivers, and other applications.
SGX code and data are always encrypted to and from CPU chip
to memory. The SGX enclave programming model is based on
a new set of CPU-privileged instructions that provides isolation
from outside agents and other enclaves. SGX also offers a software
attestation scheme which allows remote agents a method to
authenticate the software running inside an enclave.

SGX was initially designed to protect small segments of an
application that dealt with sensitive data (e.g., credit card numbers,
signing keys), and also able to provide code secrecy [8]. The critical
point is that the SGX-developed application itself still must be
proven memory safe and free from vulnerabilities. Nonetheless,

there would be huge benefits if legacy applications could be adapted
to execute within SGX enclaves. Software developed in memory-
unsafe languages such as C/C++ would be complicated to verify
formally. The same traditional memory corruption vulnerabilities
that exist running under OS control can also occur within the
enclave. Even programming languages that are touted as memory
safe (e.g., Python, Java, Go, Rust) either interface with unsafe
libraries or have some features which can be exploited. There are
several studies that have illustrated that memory hijacking attacks
can still occur in SGX. [9, 17, 25].

There has been many defense mechanisms proposed to defeat
memory corruption attacks, such as Stack Canaries [11], Data
Execution Prevention (DEP) [29], Address Space Layout Random-
ization (ASLR) [16], Control Flow Integrity (CFI) [4], so on and so
forth. However, they all are imperfect for various reasons, such
as the performance cost outweighing the potential protection,
incompatibility with legacy systems, relying on changes in the
compiler toolchain, or requiring the access of program source-code.
It is thus imperative to look for other alternatives to secure SGX
enclave programs. By using memory-safe languages to develop
enclave programs instead of these defense mechanisms is a better
solution.

There is a current work Rust-SGX [12, 31, 32], which solved
this problem by providing Rust memory-safe languages for enclave
developers. However, Rust is still relatively new and not widely
adopted. Rust has recently been chosen for security-sensitive web
browsers. Python ranks as one of the top three most popular
languages across all existing code repositories and is gaining by
the most significant percentage each year. The application domain
areas (Big Data, Machine Learning, Robotics, Computer Vision,
Automation Testing) are heavily dependent on Python program-
ming language. These application domains will never benefit from
secure enclaves of SGX with only Rust-SGX alternative. Porting
Python interpreter to SGX is not enough by using frameworks in
the previous work [28, 30]. Python applications would still suffer
memory corruptions since the interpreter and augmented runtime
are all written in C/C++ code and thus contaminating the Python
program’s memory safety.

To fill this gap, we propose Python-SGX, a memory-safe Python
SGX SDK based on PyPy, a Python interpreter written in RPython, a
subset of Python language. By taming all of the unsafe parts in PyPy
using security hardening, formal verification, and memory-safe
languages, Python-SGX provides a memory-safe Python interpreter
- MesaPy. Since PyPy is dependent on the C standard library, and
SGX has a minimal set of libraries, the previous method added a
shim layer or utilized Library OS. However, by adding this layer, the
extra C/C++ unsafe code was introduced. Python-SGX avoids this
by properly customizing MesaPy. Therefore, Python-SGX provides
a memory-safe development environment.

 
 
 
 
 
 
We have implemented Python-SGX and executed several bench-
mark programs for performance analysis. Our evaluation results
show that Python-SGX only imposes modest overhead compared
to running in native Linux. Python-SGX has been released as an
open-source project in Nov, 2018.1.

In summary, our contributions are:

• We present MesaPy, a memory-safe Python interpreter,
based on PyPy by using formal verification, type system
enhancement, and memory safe programming language to
tame the unsafe parts in PyPy.

• We propose Python-SGX based on MesaPy, a practical
approach to providing a memory-safe Python development
environment for developers.

• We have implemented MesaPy, Python-SGX, and evaluated
them with several benchmark programs. Our evaluation
results show that Python-SGX provides a prototype of the
Python enclave programming model and meanwhile does
not impose any significant performance overhead.

2 BACKGROUND
2.1 Memory Safety
Computer programs consist of two main elements: execution
control and memory data access. Memory data access can have
either spatial and temporal problems. Spatial errors are when you
can read or write to memory areas that should not be valid, which
includes buffer overflows, double frees, and dangling pointers.
Temporal errors are the result of memory access that should not
be valid because of timing issues such as dereferencing pointer
after free, uninitialized memory access. The whole idea of memory
safety is to provide a secure execution environment void the types
of spatial and temporal issues just presented.

2.2 Intel SGX
The main reason for Intel to introduce SGX is to provide applications
the ability to execute code in a secure enclave and protect secrets
with their own execution environment [3, 18]. As such, SGX
provides software developers direct control over their application’s
security without relying on any underlying system software such
as the OS or hypervisor. This significantly reduces the trusted
computing base (TCB) to the smallest possible footprint (only the
code executed inside the enclave), and prevents various software
attacks even when the OS, BIOS, or hypervisor are compromised.
The main reason for Intel to introduce SGX is to provide applications
the ability to execute code in a secure enclave and protect secrets
with their own execution environment [3, 18]. As such, SGX
provides software developers direct control over their application’s
security without relying on any underlying system software such
as the OS or hypervisor. This significantly reduces the trusted
computing base (TCB) to the smallest possible footprint (only the
code executed inside the enclave) and prevents various software
attacks even when the OS, BIOS, or hypervisor are compromised.

1The source code of Python-SGX has been released on GitHub at https://github.com/
mesalock-linux/mesapy.

2

2.3 PyPy
PyPy is an alternative implementation of the Python programming
language, which often executes faster than the standard implemen-
tation of Python, CPython. PyPy uses just-in-time (JIT) compilation
to translate Python code into machine-native assembly language
while CPython is strictly an interpreter. PyPy uses optimization
techniques found in other just-in-time compilers for dynamic
languages. It analyzes running Python programs to determine the
type of information of objects as they are created and used in
programs, then uses that type of information as a guide to speed
things up.

"Pure" Python applications which do not interface with C
libraries or extensions execute most efficiently with PyPy. This
is due to the overhead incurred by how PyPy must emulate
CPythonâĂŹs native binary interfaces. Longer-running programs
benefit most from PyPy optimizations. The longer the program
runs, the more run-time type information PyPy can gather, and the
more optimizations it can make. Python used for system command
scripting purposes will not benefit from the efficiency standpoint.
PyPy is interesting architecturally because it is the product of a
technique called meta-tracing, which transforms an interpreter into
a tracing JIT compiler. Since interpreters are usually easier to write
than compilers but run slower, this technique can make it easier
to produce efficient implementations of programming languages.
PyPy’s meta-tracing toolchain is called RPython. PyPy compiles
Python code, but it is not a compiler for Python code. Because of the
way PyPy performs its optimizations and the inherent dynamism
of Python, there is no way to emit the JIT-generated byte code as a
standalone binary and re-use it.

RPython is a Python-like language; specifically it is a restricted
subset of the Python language. The restriction provides the power of
type inference of the RPython program so that it could be translated
into another language. The mechanism to achieve this byte code
translation is through an associated toolchain provided by PyPy
project along with an interpreter written in the C programming
language. This code is then compiled into machine code, and the
byte code runs on the compiled interpreter.

3 OVERVIEW
3.1 Objectives, Threat Model and Scope
The critical objective of Python-SGX is to provide a secure SGX
enclave environment for Python software development free of
memory-corruption vulnerabilities. Python-SGX should provide
to the most extent possible the same capabilities and rich library
support that is found in the native Linux environment. Applications
should not have to undergo a significant rewrite to execute in
Python-SGX. Moreover, finally, the design and implementation of
Python-SGX should not impose significant performance overhead.
Python-SGX, like Intel SGX, only protects code and data running
from within the enclave itself. The CPU processor protects code
running in the enclave from being "spied on" by other code,
including OS processes, BIOS, hypervisor, or other applications.
The enclave contents are unable to be read by any code outside the
enclave, other than in encrypted format. This SGX model works
securely and correctly as long as there are no memory safety issues
(buffer overflow, use after free, invalid pointer). SGX programs are

at risk of the same control flow hijacking as traditional applications
when these memory safety rules are violated. Making matters more
complicated, an SGX application is normally implemented with a
trusted component running inside the enclave and an untrusted
component running outside as an application software process.
Since data and control must be passed back and forth between
bridge functions (ECALL and OCALL), this opens another window
of opportunities for attack. Python-SGX aims to defeat memory
corruptions that exploit the insecure memory operations inside
enclave programs. Side-channel attacks are orthogonal to the
memory safety problem, so they are not in scope. Python-SGX
will only focus on enabling application layer memory safety in SGX
enclaves.

3.2 Challenge and Threat
In the previous work related to SGX memory safety, Rust-SGX
focused on solving the unsafe interface between Rust and C
languages. Python-SGX focuses on solving the memory safety of
scripting language itself, in particular, its interpreter. Although
Python is a type-safe scripting language, Python has to depend on
an interpreter to execute. Python applications would still suffer
memory corruption since the interpreter is not safe. The most
popular Python interpreter is CPython, which is written in C,
which is an unsafe language. Therefore, the first challenge is how
to make Python’s interpreter memory safe. One method will be
using formal verification tool to find and correct any potential
memory corruptions in CPython; the other one will be rewriting
CPython with memory-safe language. For the first one, CPython
has 300k lines of C code, which will be a near-impossible task
to accomplish. The second one comes to our solution. There is
a Python interpreter, PyPy, which is written in RPython, which
is a subset of Python. However, in PyPy, there are three unsafe
parts, all related to RPython: type system, Translator/JIT backend,
and external libraries. PyPy structural components are illustrated
in Figure 1. Therefore, the challenge finally comes to how to secure
these unsafe parts in PyPy interpreter. Python-SGX addresses this
issue by using security hardening, formal verification, and memory
safe programming language to eliminate the unsafe parts in the
interpreter. The new memory-safe PyPy is called MesaPy, which
can also be used in Linux environments.

The second challenge is the same one faced by Rust-SGX. Python-
SGX is built on top of standard C library, not Intel SGX SDK.
Since Python interpreter depends on the standard C library, it is
impractical to have every component inside the SGX enclave to be
memory safe. Therefore, Python-SGX will need to be re-designed
to build on top of Intel SGX SDK.

Since PyPy depends on C standard library, and SGX can only
utilize a subset of this library interface (I/O is forbidden, no
system calls, etc.), PyPy can not be executed in SGX.The previous
method was to add a shim layer or use Library OS. However, by
adding this layer, the extra C/C++ unsafe code was introduced.
Therefore, properly porting Python interpreter in Intel SGX without
introducing any extra memory unsafe parts comes to another
key challenge. Python-SGX addresses this issue by analyzing the
mismatch between interpreter and SGX limited programming envi-
ronment. This includes avoiding any extra C/C++ layer, following

Figure 1: PyPy Structure.

Figure 2: Overview of MesaPy.

the SGX requirement, and modifying the interpreter, so it works
correctly under SGX limited functionality.

4 DESIGN AND IMPLEMENTATION
PyPy, a Python interpreter written primarily in RPython §2.3, has
built-in memory safety and speed efficiency as a result of its JIT
compiler feature. However, there are still three unsafe parts which
are: (1) RPython Type System, (2) RPython’s Translator/JIT backend,
and (3) RPython’s external libraries. In the following sections, we
introduce solutions to ensure safety in these three areas shown in
Figure 2 and securely porting of MesaPy in SGX.

4.1 Unsafe RPython Type System - Security

Hardening

For complete memory safety, both spatial (out of bound) and
temporal (use-after-free) errors must be prevented without false
negatives. Type-safe languages usually enforce both spatial and
temporal safety by checking object bounds at array accesses and
using automatic garbage collection.

RPython utilizes garbage collection to prevent temporal safety.
However, by auditing RPython implementation in PyPy, we found
that RPython has a potential risk since it does not check the
boundaries of list and arrays, which will break spatial safety. We
need to generate exceptions for unsafe functions operating outside
the legal boundaries of the list and arrays. By performing security
hardening on RPython’s type system, we improve RPython’s spatial
safety.

4.2 Unsafe RPython’s Translator/JIT backend
There are approximately 1000 lines of runtime C code in RPython’s
Translator/JIT backend, which contain potential memory bugs.

3

Python Interpreter/JITPython ModulesPython LibrariesRPython LibrariesRPython Type/Translator/JITPyPyunsafesafePython Interpreter/JITPython ModulesPython LibrariesRPython Libraries (Memory Safe Language)RPython Type (Security Hardening)Translator/JIT (Formal Verified)MesaPysafeThese few lines of C code are difficult to eliminate since they are
often referenced. Although testing can be very effective at finding
bugs, it cannot uncover all issues because exhaustively enumerating
all program inputs is not possible. Therefore, formal verification is
a complementary approach that can be effectively used to prove
the absence of bugs in addition to finding them. Since this C code
is isolated, its logic is not complicated and it is a critical piece, we
can deploy formal verification methods to guarantee four memory
issues cannot occur: (1) buffer overflow, (2) buffer over-read, (3)
null pointer dereference, and (4) memory leak.

Two approaches are used for formal verification. The first
one is the Abstract Interpretation (AI) based verification. Ab-
stract Interpretation is a framework of program analysis based
on approximating a possibly infinite set of states into a single
abstract state. This leads to a computable set of states representing
safe approximations of the behavior of the program. The second
approach is using Software Model Checking (SMC). SMC is a
method that verifies the correct functioning of a system design
model typically represented by finite state machines (FSM). SMC
uses efficient algorithms to verify that execution behavior adheres
to formal specification and creating counterexamples for any
violations. SMC is more robust with more complex control-driven
programs with a large number of finite states. AI is more robust
with data-dependent programs since it performs more exhaustive
verification of abstract value space.

In practice, we deployed tools that cover both approaches in order
for cross-validation. We utilize two state-of-the-art verification tools
– SeaHORN [13] and SMACK [23] to reach a high degree of certainty
that memory safety issues are eliminated. Seahorn and SMACK both
encompass aspects of SMC and AI. Seahorn employs several SMC-
based model checking engines (PDR/IC3, SPACER, and GPDR) as
well as AI-based analyzer IKOS for checking program invariants.
SMACK is well known for SMC bounded verification, but it can
also serve AI verification in programs adequately annotated with
loop invariants and procedure pre- and post-conditions. Both tools
use LLVM intermediate representation (IR) as the front end. C/C++
code is translated to LLVM IR bitcode first and then processed by
the middle-end process. Seahorn takes LLVM IR bitcode and emits
Contrained Horn Clauses (CHC) for the back-end process. SMACK
converts LLVM IR bitcode to Boogie IVL, which is an expressive
mathematical language based on memory map regions instead of
dynamic memory. Finally, both tools have back-end verification
engines to fulfill program validation.

The four aspects (buffer overflow, buffer over-read, null pointer
dereference, and memory leak) are the verification target scopes.
We applied both tools on the RPython backend C programs. To
evaluate the verification result, we manually checked each of the
alarms reported by both tools. By looking into the intermediate
results, mapping the semantics to the source code manually, we
can prove the results of back-end verification engines.

By formal verification, we found several cases could be potential
vulnerabilities. Here, we list two cases to show the verification
results.

In Figure 3, there could be a potential Integer Overflow at line
10 since K could be any value, including these greater than 32. In
such a case, x will be overflowed.

1
2
3
4
5
6
7
8
9
10
11
12
13

1
2
3
4
5
6
7
8
9
10

11
12
13
14

1
2
3
4
5
6
7
8

9
10

11
12

4

static Bigint *
Balloc ( int k)
{

int x;
Bigint * rv ;
unsigned int len ;
if (0 <= k <= Kmax && ( rv = freelist [k ]) )

freelist [k ] = rv -> next ;

else {

x = 1 << k;

// ---> potential integer overflow

....... code omit

}

}

Figure 3: vulnerability in dtoa.c

static Bigint *
Balloc ( int k)
{

int x;
Bigint * rv ;
unsigned int len ;
if (0 <= k <= Kmax && ( rv = freelist [k ]) )

freelist [k ] = rv -> next ;

else {

if (k >32 || k <0) return NULL ; // ---> prevent

integer overflow

x = 1 << k;

....... code omit
}

}

Figure 4: Protection in dtoa.c

RPY_EXTERN
long * pypy_jit_codemap_del ( unsigned long addr ,
unsigned int size )

{

}

unsigned long search_key = addr + size - 1;
long * result ;
skipnode_t * node ;
node = skiplist_search (& jit_codemap_head , search_key )

;

pypy_codemap_invalid_set (1) ;
skiplist_remove (& jit_codemap_head , node -> key ) ;

//

--> invalid memory access

....... code omit

Figure 5: vulnerability in codemap.c

In Figure 5, A potential invalid memory access could happen at
line 10. Since skiplist-search could return NULL, node could be
NULL, thus node->key will cause a crash.

We fixed all tool detected potential memory corruptions man-
ually one by one and then iteratively revalidated all code updates
against the verification tools until no potential risks existed. The
correction of potential corruptions in Figure 3 and Figure 5 are
shown in Figure 4 and Figure 6.

1
2
3
4
5
6
7
8

9
10
11
12
13
14

RPY_EXTERN
long * pypy_jit_codemap_del ( unsigned long addr ,
unsigned int size )

{

}

unsigned long search_key = addr + size - 1;
long * result ;
skipnode_t * node ;
node = skiplist_search (& jit_codemap_head , search_key )

;

if (! node || ! node -> key || node -> key < addr )
return NULL ; // --> check if node is null ptr
pypy_codemap_invalid_set (1) ;
skiplist_remove (& jit_codemap_head , node -> key );
....... code omit

Figure 6: protection in codemap.c

4.3 Unsafe RPython external libraries
In RPython, there are external libraries written in C/C++, such as
zlib, openssl, expat, etc. These external libraries written in C/C++
can have potential memory issues. Since it is hard to audit the
libraries depending on the size of libraries, how can memory safety
be guaranteed? There are two solutions for these unsafe external
libraries; one is to use memory safe programming languages to
rewrite them, the other one is to use formal verification to verify
the correctness. However, external libraries are often not scalable
and have a large amount of complicated code and dependencies. It
is impractical to use formal verification to achieve memory safety.
For unsafe external libraries, using memory safe programming
language to rewrite them is a better approach. In practice, We
replaced zlib with miniz-oxide, which a minizlib was written by
Rust.

4.4 Porting PyPy into SGX
SGX reduces the size of the required Trusted Computing Base
(TCB) significantly. However, this restrictive system model also
limits SGX programs’ capability of acquiring computation resources
from the outside untrusted environment, including hardware and
software interrupts. These features are disabled in SGX enclaves,
and their associated services from the OS, I/O subsystem, and
memory mapping are unavailable.

Since SGX has limited library support, the key challenge is
having PyPy run correctly inside SGX with the minimal TCB while
not introducing unsafe code in SGX. The SGX security guide must
be followed during the development of new libraries.

PyPy interpreter has RFFI parts which contain system calls and
I/O related operations. This introduces environment variables, disk
files, dynamic load, etc. which are not supported by SGX. The
challenge becomes how to fix these I/O and system call-related
requirements.

Previous works have focused on building a bridge for the
limitations. However, it increases the TCB and also adds an extra
layer inside SGX, which is written in C/C++ language introducing
more potential memory corruption.

Instead, the PyPy interpreter has been modified directly for
Python-SGX without adding an unsafe C/C++ code. Also, we
performed analysis for all I/O and system call functions used by

5

PyPy, so that they could either be eliminated or replaced with
equivalent safe implementation. For instance, there is a requirement
to read files from disk in PyPy for booting. As an alternative, we
can have these files prepared inside SGX for reading. Since PyPy
interpreter no longer requires a dynamic loading feature inside
SGX, we can disable this function and replace it with static loading.
By searching through RPython FFI, we remove all of the I/O and
system calls that are not allowed.

In order to provide more details on this practice, let us examine
pypy-setup-home function which implements PyPy interpreter
setup and performs lib-python and lib-pypy initialization. Dur-
ing this process, these libraries need to read files from disk, which
is outside of SGX. In order to remove potential risk from reading
files from an unsafe source, we can hardcode these two libraries
inside SGX. Moreover, since PyPy is also supported by libc, which
contains unsafe code, all libc functionality will be replaced with
sgx tlibc.

As another example, garbage collection initialization needs to
read system information about the total memory size. This part is
redesigned so that there is no need to read from the file system
by defining the size accurately. Further analysis is performed for
unnecessary code, which may contain unsafe actions reducing the
threat surface area. PyPy interpreter then becomes self-contained
in SGX and isolated from potential risks.

5 EVALUATION
In this section, we provide a performance evaluation of Python-SGX.
Two areas are identified as the criteria for performance evaluation:
(1) MesaPy versus PyPy (both running in Linux), and (2) porting
overhead (MesaPy in Linux versus MesaPy in Python-SGX). Note,
we do not compare a Python program with a C/C++ program since
the comparison is inappropriate. That would necessarily be the
comparison compiled versus interpreted code. Since we have not
developed any SGX-specific APIs written in Python yet, we will
also not have micro-benchmarks to evaluate that part yet. The
source code of all of our benchmarks is released at Github at https:
//github.com/mesalock-linux/mesapy-benchmarks.

Our performance experiments were executed on a 16.04.1-
Ubuntu system comprised of a 6-core Intel Core i7-8086K CPU
running at 4.00GHz, with 32 GB memory, and 1Gbit/s Ethernet
Connection I219-LM. We installed the latest Intel SDK, SGX
driver(version 2.5).

5.1 MesaPy benchmarks
Our benchmarks in this part aim to evaluate the overhead of
MesaPy compared to native PyPy. Particularly, we set up two sets
of evaluation environments: (1) PyPy with Linux, 2) MesaPy with
Linux. We have 19 PyPy [2] and game-related programming [1]
benchmarks that are selected and modified for execution. The
evaluation result for these benchmarks is presented in Figure 7. We
can see that all 16 programs running in MesaPy have the overhead
ranging from 1% to 12% greater than native PyPy. The reason that
native PyPy has better performance than MesaPy is due to the list
and array index check in MesaPy. There are three benchmarks, and
running on MesaPy are slightly faster than native PyPy. The reason
is mainly from noise.

5.2 Porting overhead
Our benchmarks in this part aim to evaluate the overhead of porting
MesaPy in Python-SGX compared to native MesaPy in Linux. We set
up two sets of evaluation environments: 1) running with MesaPy in
Linux, 2) running under Python-SGX. We measured the execution
time by utilizing the operating system clock running outside of the
enclave. In particular, we first start the clock outside an enclave,
execute ECALL, which will call a Python function inside the enclave,
and then stop the clock to calculate the total execution time.

We have eight benchmarks that are supported by MesaPy under
both Linux and SGX execution environments. Note that due to
the limitation of SGX memory, we run performance testing with
tree depth as 18 in binary-tree, and have 10 as input for testing
fasta, and execute pidigits with input as 1. The results are shown
in Figure 8. The benchmarks reporting performance overhead
is between 36% to 150% higher for MesaPy under Python-SGX
compared to MesaPy under Linux. The overhead is introduced by
SGX and MesaPy porting.

6 DISCUSSION
6.1 Limitation of current work.
In the current version, Python-SGX only supports basic computa-
tion and some builtin modules. Support for multi-threading and
full standard library is still under development.

6.2 The future work.
There is work remaining to perfect Python-SGX, including porting
more Python libraries into Python-SGX and replacing remaining
external C libraries. Furthermore, we still need to verify more
components using current state-of-the-art verification tools. To
have Python-SGX adopted by a larger developer community, we
will be implementing additional useful libraries and SGX specific
features for real-world use cases.

The audit of translation from RPython to C will be included in

the next scope.

7 RELATED WORK
There exist many defense-related works regarding memory safety.
G-Free is a work defeating return-oriented programming through
gadget-less binaries [22]. Hypersafe is a lightweight approach to
provide lifetime hypervisor control-flow integrity [33]. Pointguard
TM is protecting pointers from buffer overflow vulnerabilities [10].
CCured is doing type-safe retrofitting of legacy code [21]. [24]
presents a Practical Dynamic Buffer Overflow Detector. Baggy
Bounds Checking [7] is an Efficient and Backwards-Compatible
Defense against Out-of-Bounds Errors. [34] is protecting C pro-
grams from attacks via invalid pointer dereferences. [15] presents
backward-compatible bounds checking for arrays and pointers in
C programs. Cling [5] is using a Memory Allocator to Mitigate
Dangling Pointers. CETS [20] presents compiler enforced temporal
safety for C. [6] is preventing memory error exploits with WIT.
Body Armor for Binaries [26] is preventing Buffer Overflows With-
out Recompilation. Stackguard [11] presents automatic adaptive
detection and prevention of buffer-overflow attacks.

Since the root cause of all vulnerabilities is memory corruption,
every exploit starts by triggering a memory error. Enforcing
memory safety eliminates all memory corruption exploits. While
achieving memory safety, both spatial and temporal errors must
be prevented without false negatives. Type-safe languages enforce
both spatial and temporal safety by checking object bounds at array
accesses and using automatic garbage collection. We can transform
existing unsafe code to enforce similar policies by embedding low-
level reference monitors. This instrumentation can appear within
the source code itself, intermediate representation, or at the binary
level. We should solve this problem for both spatial and temporal
safety [27].

Spatial safety with pointer bounds. Enforcing spatial safety is
to keep track of pointer bounds. CCured [21] provides an extension
of the C type system with explicit types for pointers into arrays with
dynamic typing. Cyclone [14] use "fat pointers". However, these
systems need source code annotations so that it is not practical
for large codebases. Also, any pointer representation changes the
memory layout and breaks binary compatibility. SoftBound [19]
addresses the compatibility problem of pointer representation by
separating metadata from the pointer.

8 CONCLUSION
In summary, we have presented Python-SGX, a framework based
on a safely ported PyPy interpreter to SGX providing enclave
developers a memory-safe Python development environment. We
show that with Python-SGX, enclave developers can perform
sensitive security computations without significant overhead.

In order to be more practical, we plan to bring in additional
Python libraries and SGX-specific features for real-world use cases.
We also plan to review the translation audit from RPython to C for
increased memory safety evaluation.

REFERENCES
[1] “game

benchmark,”
benchmarksgame/faster/python.html.

https://benchmarksgame-team.pages.debian.net/

[2] “Pypy benchmarks,” https://bitbucket.org/pypy/benchmarks/src.
[3] “Intel software guard extensions programming reference,” https://software.intel.

com/sites/default/files/managed/48/88/329298-002.pdf, Oct. 2014.

[4] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-flow integrity
principles, implementations, and applications,” ACM Trans. Inf. Syst. Secur.,
vol. 13, no. 1, pp. 4:1–4:40, Nov. 2009. [Online]. Available: http://doi.acm.org/10.
1145/1609956.1609960

[5] P. Akritidis, “Cling: A memory allocator to mitigate dangling pointers.” in USENIX

Security Symposium, 2010, pp. 177–192.

[6] P. Akritidis, C. Cadar, C. Raiciu, M. Costa, and M. Castro, “Preventing memory
error exploits with wit,” in Security and Privacy, 2008. SP 2008. IEEE Symposium
on.

IEEE, 2008, pp. 263–277.

[7] P. Akritidis, M. Costa, M. Castro, and S. Hand, “Baggy bounds checking: An
efficient and backwards-compatible defense against out-of-bounds errors.” in
USENIX Security Symposium, 2009, pp. 51–66.

[8] E. Bauman, H. Wang, M. Zhang, and Z. Lin, “Sgxelide: enabling enclave code
secrecy via self-modification,” in Proceedings of the 2018 International Symposium
on Code Generation and Optimization, 2018, pp. 75–86.

[9] A. Biondo, M. Conti, L. Davi, T. Frassetto, and A.-R. Sadeghi, “The guard’s
dilemma: Efficient code-reuse attacks against intel sgx,” in Proceedings of
the 27th USENIX Conference on Security Symposium, ser. SEC’18. Berkeley,
CA, USA: USENIX Association, 2018, pp. 1213–1227. [Online]. Available:
http://dl.acm.org/citation.cfm?id=3277203.3277294

[10] C. Cowan, S. Beattie, J. Johansen, and P. Wagle, “Pointguard tm: protecting
pointers from buffer overflow vulnerabilities,” in Proceedings of the 12th conference
on USENIX Security Symposium, vol. 12, 2003, pp. 91–104.

[11] C. Cowan, C. Pu, D. Maier, H. Hintony, J. Walpole, P. Bakke, S. Beattie,
A. Grier, P. Wagle, and Q. Zhang, “Stackguard: Automatic adaptive detection

6

PyPy

MesaPy

130

120

110

100

)

%

(
d
a
e
h
r
e
v
O
d
e
z
i
l
a
m
r
o
N

a r y -tr e

b i n

e s

h

c
c r y

o s
a
p t o

p

_

a

y

e s
e lt a
d

e

n

b l u
f a

h

c

u

k

n

f a s t a

b

fi

o

fl

a t
g

c

n

e

b

h

c

h

e

2

n

b

_

m
x i o
js o

n

c

a

e

m

e l b r o t
o r - c
e t e

d

o

h

n
m

n t e s t

o

b

n

y

q

d

n

n s

e

e

u

p i d i g it s
s c
s p

h
e

u lz e
c tr a l- n

o r m

o

t e lc

Figure 7: Percentage overhead of running Python benchmarks in MesaPy normalized against PyPy native execution.

)

%

(
d
a
e
h
r
e
v
O
d
e
z
i
l
a
m
r
o
N

300

200

100

0

MesaPy in Linux

Python-SGX

e s

a r y -tr e

b i n

y

d

o

b

n

f a s t a

h

c

u

k

n

n

f a

p i d i g it s

e

b l u

e lt a

d

b

fi

n s

e

e

u

q

n

Figure 8: Percentage overhead of running Python benchmarks in Python-SGX normalized against MesaPy in Linux.

and prevention of buffer-overflow attacks,” in Proceedings of
the 7th
Conference on USENIX Security Symposium - Volume 7, ser. SSYM’98.
Berkeley, CA, USA: USENIX Association, 1998, pp. 5–5. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1267549.1267554

[12] Y. Ding, R. Duan, L. Li, Y. Cheng, Y. Zhang, T. Chen, T. Wei, and H. Wang, “Poster:
Rust sgx sdk: towards memory safety in intel sgx enclave,” in Proceedings of the
2017 ACM SIGSAC Conference on Computer and Communications Security, 2017,
pp. 2491–2493.

[13] A. Gurfinkel, T. Kahsai, A. Komuravelli, and J. A. Navas, “The seahorn verification

framework,” 2015.

[14] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and Y. Wang, “Cyclone:
A safe dialect of c.” in USENIX Annual Technical Conference, General Track, 2002,
pp. 275–288.

[15] R. W. Jones and P. H. Kelly, “Backwards-compatible bounds checking for arrays
and pointers in c programs,” in Proceedings of the 3rd International Workshop on
Automatic Debugging; 1997 (AADEBUG-97), no. 001. Citeseer, 1997, pp. 13–26.
[16] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning, “Address space layout
permutation (aslp): Towards fine-grained randomization of commodity software,”
in Proceedings of the 22Nd Annual Computer Security Applications Conference, ser.
ACSAC ’06. Washington, DC, USA: IEEE Computer Society, 2006, pp. 339–348.
[Online]. Available: https://doi.org/10.1109/ACSAC.2006.9

[17] J. Lee, J. Jang, Y. Jang, N. Kwak, Y. Choi, C. Choi, T. Kim, M. Peinado, and
B. B. Kang, “Hacking in darkness: Return-oriented programming against secure
enclaves,” in Proceedings of the 26th USENIX Conference on Security Symposium,
ser. SEC’17. Berkeley, CA, USA: USENIX Association, 2017, pp. 523–539.
[Online]. Available: http://dl.acm.org/citation.cfm?id=3241189.3241231

[18] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shafi, V. Shanbhogue,
and U. R. Savagaonkar, “Innovative instructions and software model for
isolated execution,” in Proceedings of the 2Nd International Workshop on
Hardware and Architectural Support for Security and Privacy, ser. HASP
’13. New York, NY, USA: ACM, 2013, pp. 10:1–10:1. [Online]. Available:
http://doi.acm.org/10.1145/2487726.2488368

[19] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, “Softbound: Highly
compatible and complete spatial memory safety for c,” ACM Sigplan Notices,
vol. 44, no. 6, pp. 245–258, 2009.

[20] ——, “Cets: compiler enforced temporal safety for c,” in ACM Sigplan Notices,

vol. 45, no. 8. ACM, 2010, pp. 31–40.

[21] G. C. Necula, J. Condit, M. Harren, S. McPeak, and W. Weimer, “Ccured:
legacy software,” ACM Trans. Program. Lang.

Type-safe retrofitting of

Syst., vol. 27, no. 3, pp. 477–526, May 2005. [Online]. Available: http:
//doi.acm.org/10.1145/1065887.1065892

[22] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and E. Kirda, “G-free: defeating
return-oriented programming through gadget-less binaries,” in Proceedings of the
26th Annual Computer Security Applications Conference. ACM, 2010, pp. 49–58.
[23] Z. Rakamarić and M. Emmi, “SMACK: Decoupling source language details from
verifier implementations,” in Proceedings of the 26th International Conference
on Computer Aided Verification (CAV), ser. Lecture Notes in Computer Science,
A. Biere and R. Bloem, Eds., vol. 8559.

Springer, 2014, pp. 106–113.

[24] O. Ruwase and M. S. Lam, “A practical dynamic buffer overflow detector.” in

NDSS, vol. 2004, 2004, pp. 159–169.

[25] H. Shacham, “The geometry of innocent flesh on the bone: Return-into-
libc without
the 14th
ACM Conference on Computer and Communications Security, ser. CCS
’07. New York, NY, USA: ACM, 2007, pp. 552–561. [Online]. Available:
http://doi.acm.org/10.1145/1315245.1315313

function calls (on the x86),” in Proceedings of

[26] A. Slowinska, T. Stancescu, and H. Bos, “Body armor for binaries: Preventing
buffer overflows without recompilation.” in USENIX Annual Technical Conference,
2012, pp. 125–137.

[27] L. Szekeres, M. Payer, T. Wei, and D. Song, “Sok: Eternal war in memory,” in

Security and Privacy (SP), 2013 IEEE Symposium on.

IEEE, 2013, pp. 48–62.

[28] C.-C. Tsai, D. E. Porter, and M. Vij, “Graphene-sgx: A practical

library
os for unmodified applications on sgx,” in Proceedings of the 2017 USENIX
Conference on Usenix Annual Technical Conference, ser. USENIX ATC ’17.
Berkeley, CA, USA: USENIX Association, 2017, pp. 645–658. [Online]. Available:
http://dl.acm.org/citation.cfm?id=3154690.3154752

[29] A. van de Ven and I. Molnar, “Exec shield,” Retrieved March, vol. 1, p. 2017, 2004.
[30] H. Wang, E. Bauman, V. Karande, Z. Lin, Y. Cheng, and Y. Zhang, “Running
language interpreters inside sgx: A lightweight, legacy-compatible script code
hardening approach,” in Proceedings of the 2019 ACM Asia Conference on Computer
and Communications Security, 2019, pp. 114–121.

[31] H. Wang, P. Wang, Y. Ding, M. Sun, Y. Jing, R. Duan, L. Li, Y. Zhang, T. Wei, and
Z. Lin, “Towards memory safe enclave programming with rust-sgx,” in Proceedings
of the 2019 ACM SIGSAC Conference on Computer and Communications Security,
2019, pp. 2333–2350.

[32] P. Wang, Y. Ding, M. Sun, H. Wang, T. Li, R. Zhou, Z. Chen, and Y. Jing, “Building
and maintaining a third-party library supply chain for productive and secure sgx
enclave development,” 2020.

7

[33] Z. Wang and X. Jiang, “Hypersafe: A lightweight approach to provide lifetime
hypervisor control-flow integrity,” in Security and Privacy (SP), 2010 IEEE
Symposium on.

IEEE, 2010, pp. 380–395.

[34] S. H. Yong and S. Horwitz, “Protecting c programs from attacks via invalid pointer
dereferences,” in ACM SIGSOFT Software Engineering Notes, vol. 28, no. 5. ACM,
2003, pp. 307–316.

8

