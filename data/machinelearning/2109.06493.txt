Formal methods for quantum algorithms: A Survey

Christophe Chareton4, S´ebastien Bardin4, Dongho Lee2,4, Benoit Valiron2,
Renaud Vilmart3, and Zhaowei Xu1,5

1Universit´e Paris-Saclay, CNRS, ENS Paris-Saclay, Laboratoire M´ethodes
Formelles, 91190, Gif-sur-Yvette, France
2Universit´e Paris-Saclay, Inria, CentraleSup´elec, CNRS, ENS Paris-Saclay,
Laboratoire M´ethodes Formelles, 91190, Gif-sur-Yvette, France
3Universit´e Paris-Saclay, Inria, CNRS, ENS Paris-Saclay, Laboratoire M´ethodes
Formelles, 91190, Gif-sur-Yvette, France
4Universit´e Paris-Saclay, CEA, LIST, Palaiseau, France
5University of Tartu, Estonia

Abstract

While recent progress in quantum hardware open the door for signiﬁcant speedup in cryptog-
raphy as well as additional key areas (biology, chemistry, optimization, machine learning, etc),
quantum algorithms are still hard to implement right, and the validation of such quantum pro-
grams is a challenge. Moreover, importing the testing and debugging practices at use in classical
programming is extremely difﬁcult in the quantum case, due to the destructive aspect of quantum
measurement. As an alternative strategy, formal methods are prone to play a decisive role in the
emerging ﬁeld of quantum software. Recent works initiate solutions for problems occurring at
every stage of the development process: high-level program design, implementation, compila-
tion, etc. We review the induced challenges for an efﬁcient use of formal methods in quantum
computing and the current most promising research directions.

2
2
0
2

r
p
A
8

]
L
P
.
s
c
[

2
v
3
9
4
6
0
.
9
0
1
2
:
v
i
X
r
a

1

 
 
 
 
 
 
Formal methods for quantum algorithms

Page 2

Contents

1 Introduction

2 General Background in Quantum Computing

Separable and Entangled States

2.1 Hybrid Computational Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.1 Hybrid Circuit Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.2 Quantum Data Registers . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.3
. . . . . . . . . . . . . . . . . . . . . . .
2.1.4 Quantum Circuits . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.5 Quantum Matrix Semantics and density operators . . . . . . . . . . . . . .
2.1.6 Other Models for Quantum Computations . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.1 Quantum Algorithms and Complexity . . . . . . . . . . . . . . . . . . . .
2.2.2 Quantum Algorithm Design . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Challenges for Quantum Computation . . . . . . . . . . . . . . . . . . . . . . . .
2.3.1 Destructive Measurement and Non-Determinism . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3.2 Quantum Noise .
. . .
. . . . . . . . . . . . . .
2.3.3 Efﬁcient Compilation on Constrained Hardware

2.2 Algorithms

.

.

.

.

.

.

.

3 General Background on Formal Methods

Introduction .
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1
3.2 Principles .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 The Formal Method Zoo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.

.
.

.
.

.
.

.
.

.
.

4 Overview of Formal Methods in Quantum Computing

4.1 The Need for Formal Methods in Quantum Computing . . . . . . . . . . . . . . .
4.2 Typology of Properties to Verify . . . . . . . . . . . . . . . . . . . . . . . . . . .
Functional Speciﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.1
. . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.2 Complexity speciﬁcations
4.2.3
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.4 Circuit Equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Structural Constraints

5 Low-Level Veriﬁcation: Compilation and Equivalence

5.1 ZX-Calculus and Quantomatic/PyZX . . . . . . . . . . . . . . . . . . . . . . . . .
5.1.1
Semantical Model
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1.2 Veriﬁed Properties
.
5.1.3 Algorithms and Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 Path-Sum circuit Equivalence Veriﬁcation . . . . . . . . . . . . . . . . . . . . . .
Semantical Model
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Path-Sums Reduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Quantum abstract interpretation . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.4 Toward Integrated Veriﬁed Optimization: VOQC . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . .
5.5 Formally veriﬁed quantum compilation in an imperative setting: CertiQ . . . . . .

5.2.1
5.2.2
5.2.3 Veriﬁed Properties

5.4.1 Architecture .
5.4.2 Optimization Procedure

.

.

.

.

5

6
7
7
7
9
9
10
13
13
13
14
16
16
16
17

17
17
18
18

19
20
20
20
21
21
22

23
23
23
25
28
28
28
29
30
30
31
31
32
33

Formal methods for quantum algorithms

Page 3

6 Formal Quantum Programming Languages

6.1 Quantum Programming Languages Design . . . . . . . . . . . . . . . . . . . . . .
6.1.1
Structure of Quantum Algorithms . . . . . . . . . . . . . . . . . . . . . .
6.1.2 Requirements for Quantum Programming Languages . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . .
6.1.3 Review of the Existing Approaches
6.2 Formalizing the Operational Semantics . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . .
6.2.1 Quantum Lambda-Calculi
6.2.2 Monadic Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.3.1 Quantum Data and Type Linearity . . . . . . . . . . . . . . . . . . . . . .
6.3.2 Example: Quantum Teleportation . . . . . . . . . . . . . . . . . . . . . .
6.3.3 Extending the Type System to Support Circuits . . . . . . . . . . . . . . .
6.3.4 Dependent types and Proofs of Programs
. . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
6.3.5 Discussion .

6.3 Type Systems .

. .

.

.

.

.

.

7 High and Mid-Level Veriﬁcation: Algorithms and Programs
.

7.1 Quantum Hoare Logic

. . .
.

7.2 QBRICKS .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.1.1 Quantum Programming Language: Quantum WHILE-Programs
. . . . . .
7.1.2 Quantum States, Operations and Predicates . . . . . . . . . . . . . . . . .
7.1.3 Quantum Program Veriﬁcation . . . . . . . . . . . . . . . . . . . . . . . .
Implementations and Extensions . . . . . . . . . . . . . . . . . . . . . . .
7.1.4
. . . . . . . . . . . . . . . . . . . . . . . .
7.1.5 Other Quantum Hoare Logics
Quantum Hoare Logic with ghost variables. . . . . . . . . . . . . . . . . .
Quantum Hoare Logic with classical variables.
. . . . . . . . . . . . . . .
Robustness analysis
. . . . . . . . . . . . . . . . . . . . . . . .
. .
Quantum separation logic
. . . . . . . . . . . . . . . . . . . . . . . . .
Quantum relational Hoare logic . . . . . . . . . . . . . . . . . . . . . . .
Quantum Hoare type theory . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . .
Quantum dynamic logic.
. . . . . . . . . . . . . . . . . . . . . . . . .
.
.
. . .
7.2.1 Writing Quantum Circuits Functions in QBRICKS: QBRICKS-DSL .
Parametrized Path-Sums . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.2.2
From Quantum Circuits to Path-Sums . . . . . . . . . . . . . . . . . . . .
7.2.3
Probabilistic Reasoning . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.2.4
7.2.5 Veriﬁed Properties
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.2.6 Deduction and Proof Support . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . .
7.2.7
Implementation and Case Studies
.
. . . . . . . . . . . . . . . . . . . . . . . . .
.
7.3.1
Programming Language . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.3.2 Matrix Semantics and Speciﬁcations . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . .
7.3.3
. . . .
. . . . . . .
7.3.4 Comparison Between QBRICKS and SQIR . . . .
7.4 Conclusion about Formal Veriﬁcation of Quantum Programs . . . . . . . . . . . .

Implementation and Case Studies

7.3 SQIR .

. .
. . .

. . . . .

. . .

. . .

.

.

.

.

.

.

.

.

.

.

.

.

.

.

33
33
33
35
35
37
37
38
40
40
41
42
43
44

44
44
45
46
46
48
48
49
49
49
49
50
50
50
51
51
52
53
53
53
54
54
55
55
56
56
56
57

Formal methods for quantum algorithms

Page 4

8 Discussion and Bibliographical Notes

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.1 Deductive Veriﬁcation .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
8.2 Model Checking .
8.3 Type Checking .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
8.4 Runtime assertion Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.5 Veriﬁcation of Quantum Communication Protocols . . . . . . . . . . . . . . . . .

.
.

.
.

.
.

9 Conclusion

9.1 Summary .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.2 Main Current Challenges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.

.

.

.

.

.

.

58
58
58
58
59
60

60
60
61

Formal methods for quantum algorithms

Page 5

1 Introduction

Cryptography and quantum information. Quantum computing dates back to 1982, when
Richard Feynman raised the idea [69] of simulating quantum mechanics phenomena by storing in-
formation in particles and controlling them according to the laws of quantum mechanics. In the brief
history of quantum computing, the description in 1994 by Peter Shor of an algorithm [174], perform-
ing the decomposition of prime integers in polynomial time on the size of the input, plays a major
role. Indeed, it was the ﬁrst-ever described quantum algorithm with a practical utility–breaking the
RSA public key cryptosystems in a tractable manner.

In an asymmetric cryptosystem such as RSA, information is encrypted via a key that is a so-
lution for a given mathematical function–the decomposition of a given integer into prime factors
for the case of RSA. The security of such a protocol is based on the fundamental assumption that
no potential eavesdropper has the means to compute this solution efﬁciently. Shor’s algorithm is
based on (1) a reduction of the prime factor decomposition problem into the order-ﬁnding prob-
lem and (2) an adequate use of quantum parallelism to perform modular exponentiation of integers
over many different inputs in a single row, enabling a polynomial resolution of the order-ﬁnding.
Thus, the computation time for performing the prime decomposition is reduced from exponential to
polynomial, and therefore breaks RSA’s fundamental assumption. Shor’s original article [174] also
presents a variation of the order-ﬁnding resolution algorithm, solving the discrete logarithm problem
with similar performances. Doing so, it brings a procedure for breaking elliptic curve cryptosystems.
Symmetric-key cryptosystems are also challenged by quantum computing [163]. As an exam-
ple, Simon’s quantum algorithm [176] brings an exponential speedup for computing the period of a
function (given the promise that this period indeed exists). Several applications in public-key cryp-
tosystems were described, providing exponential gain in, e.g., distinguishing a three-round Feistel
construction [118, 163], key recovering in the Evan Mansour encryption scheme [119] and attacking
the CBC-MAC message authentication scheme [163].

Finally, Grover search quantum algorithm [84] brings a quadratic speedup in the search for a
distinguished element in unstructured databases. Hence, while in this case the complexity gain is
less decisive than for the procedures introduced above, its potential for cryptography is signiﬁcant
as it weakens any symmetric-key encryption system.

Thus, quantum computing challenges current cryptographic uses and practices. Shor’s algorithm
opened a research program for cryptographic solutions resisting the power of quantum computation,
called post-quantum cryptography [39].

Interestingly the induced challenge also received answers from quantum information theory it-
self. Indeed, one of the major distinctive features of quantum information is that it cannot be read
without being affected. This entails that an eavesdropper trying to access a quantum information
exchange cannot help betraying her attempt. Based on this feature, one can encode a cryptographic
key in a quantum message and, in case of eavesdropping, detect it a posteriori, renounce this par-
ticular key and try another sending. The study of Quantum key distribution protocols is an active
research area [164, 22, 128, 134].

Quantum computing and quantum software. These cryptographic aspects are one of many ap-
plications studied in the young research ﬁeld of quantum computing. Others are, e.g., machine
learning [26, 166, 133], optimization [64], solving linear systems [87], etc. In all these domains
there are quantum algorithms beating the best known classical algorithms by quadratic or even ex-
ponential factors, complexity-wise.

These algorithms are based on laws and phenomena speciﬁc to quantum mechanics (such as
quantum superposition, entanglement, unitary operations). Therefore, implementing them requires

Formal methods for quantum algorithms

Page 6

a framework consisting of both a dedicated hardware (quantum computers) and a dedicated software
(quantum programming languages and compilation toolchains).

In the last 20 years, several such languages have been proposed, such as QISKIT [153],
Liqui|(cid:105) [193], Q# [181], Quipper [83], PROJECTQ [180], etc. Still, the ﬁeld is in its infancy, and
many questions still need to be answered before we can reach the level of maturity observed for
classic programming languages. Standing questions include, for example, introducing a founda-
tional computing model and semantics for quantum programming languages, adequate program-
ming abstractions and type systems, or the ability to interact with severely constrained hardware in
an efﬁcient way (optimizing compilers).

Veriﬁcation of quantum programs. While testing and debugging are the common veriﬁcation
practice in classical programming, they become extremely complicated in the quantum case. Indeed,
debugging and assertion checking are a priori very complicated due to the destructive aspects of
quantum measurement (see Section 2.3.1 below). Moreover, the probabilistic nature of quantum
algorithms seriously impedes system-level quantum testing. Finally, classical emulation of quantum
algorithms is (strongly believed to be) intractable.

On the other hand, nothing prevents a priori the formal veriﬁcation [44] of quantum programs,
i.e. proving by (more or less) automated reasoning methods that a given quantum program behaves
as expected for any input, or at least that it is free from certain classes of bugs.

Interestingly, while formal methods were ﬁrst developed for the classical case where they are
still used with parsimony–mainly for safety-critical domains–as testing remains the main valida-
tion methods, their application to quantum computing could become more mainstream, due to the
inherent difﬁculties of testing quantum programs.

Goal of this survey This survey introduces both the requirements and challenges for formal meth-
ods in quantum programs speciﬁcation and veriﬁcation, and the existing propositions to overcome
these challenges.

The ﬁrst sections give the general background. In Section 2 we introduce the main concepts
at stake with quantum computing and quantum algorithms. We provide a state of the art introduc-
tion for formal methods, given in Section 3. The speciﬁc requirements for formal reasoning in the
quantum case are then developed in Section 4. Then we come to concrete quantum programming
and formal veriﬁcation material. In Section 5 we introduce several existing solutions for the formal
veriﬁcation of quantum compilation and the equivalence of quantum program runs. Generating such
runs requires speciﬁc programming languages. The formal interpretation of quantum languages is
introduced in Section 6. Then in Section 7 we present the main existing solutions for formally ver-
iﬁed quantum programming languages. In Section 8 we introduce references for further usage of
formal methods linked with quantum information, and we conclude this survey with a discussion in
Section 9.

2 General Background in Quantum Computing

By many aspects, quantum computing constitutes a new paradigm. Making great use of quantum
superposition and quantum entanglement, it requires to deﬁne proper versions for such fundamental
concepts as data structures at stake in computation, or the elementary logical operations at use. We
introduce the well-known hybrid quantum computation model in Section 2.1.

Formal methods for quantum algorithms

Page 7

Quantum computers are not intended to, and will not, replace classical ones. One should better
see the opening of a new ﬁeld, with possibilities to solve new problems. Section 2.2 presents these
new problems and introduces quantum algorithms design.

As a new software technology, quantum computing comes with speciﬁc challenges and difﬁcul-
ties. These speciﬁcities are closely related to the particular needs for formal reasoning in quantum
computing. They are introduced in Section 2.3.

2.1 Hybrid Computational Model

Let us ﬁrst introduce the main concepts at stake in quantum programming. They concern the ar-
chitecture of quantum computers, the structure of quantum information and quantum programs, and
their formal interpretation.

2.1.1 Hybrid Circuit Model

The vast majority of quantum algorithms are described within the context of the quantum co-
processor model [113], i.e. an hybrid model where a classical computer controls a quantum co-
processor holding a quantum memory, as shown in Figure 1. In particular, the classical computer
performs control operations (if . . . else statements, loops, etc). The co-processor can apply a ﬁxed set
of elementary operations (buffered as quantum circuits) to update and query (measure) the quantum
memory. Importantly, while measurement allows retrieving classical (probabilistic) information
from the quantum memory, it also modiﬁes it (destructive effect).

Instructions

Classical
controller

Quantum
memory

Feedback

Figure 1: Scheme of the hybrid model

Major quantum programming languages such as Quipper [83], Liqui|(cid:105)[193], Q# [181], PRO-
JECTQ [180], SILQ [27], and the rich ecosystem of existing quantum programming frameworks
[154] follow this hybrid model.

2.1.2 Quantum Data Registers

The following paragraphs introduce several deﬁnitions and notations for quantum data registers. In
particular, we follow the standard Dirac notation. For more details about this content, we refer the
reader to the standard literature [140].

Kets and basis-kets. While in classical computing the state of a bit is one between two possible
states (0 or 1), in quantum computing the state of a quantum bit (or qubit) is described by amplitudes
over the two elementary values 0 and 1 (denoted |0(cid:105) and |1(cid:105)), i.e. linear combinations of vectors
α0|0(cid:105) + α1|1(cid:105) where α0 and α1 are any complex values satisfying |α0|2 + |α1|2 = 1. In a sense,
amplitudes are generalization of probabilities.

Formal methods for quantum algorithms

Page 8

More generally, quantum states are deﬁned in complex ﬁnite-dimensional Hilbert spaces1: the
state of a qubit register of n qubits (called a ket of length n–dimension 2n) is a column vector with
2n rows, formed as a superposition of the 2n elementary basis vectors of length n (the “basis kets”),
i.e. a ket is any linear combination of the form

|u(cid:105)n =

2n−1
∑
k=0

αk|k(cid:105)n

(1)

such that ∑2n−1

k=0 |αk|2 = 1.

Bit-vectors and basis kets. Depending on the context, it may be more convenient to index the
terms in the sum above with bit vectors instead of integers. We call bit vector of length n any
sequence x0x1 . . . xn−1 of elements in {0, 1}. Along this survey, we assume the implicit casting of
these values to/from booleans (with the least signiﬁcant bit on the right). For any positive n, we
denote the set of bit vectors of size n by BVn. We also surcharge notation | j(cid:105)n shown above with bit
vector inputs. Formally, for any bitvector (cid:126)x of length n, |(cid:126)x(cid:105)n = | ∑n−1
i=0 xi ∗ 2n−i−1(cid:105)n. Hence, one can
write state |u(cid:105)n from (1) as

|u(cid:105)n = ∑
(cid:126)x∈BVn

α∑n−1

i=0 xi·2n−i−1)|(cid:126)x(cid:105)n

It may also be convenient to represent basis kets through their index’s binary writing. For example,
the two qubits kets basis is equivalently given as {|0(cid:105)2, |1(cid:105)2, |2(cid:105)2, |3(cid:105)2} or as {|00(cid:105), |01(cid:105), |10(cid:105), |11(cid:105)}.
We omit the length index n from notation |u(cid:105)n when it is either obvious from the context or
irrelevant. We also adopt the implicit convention of writing basis kets with either integer indexes
k, i, j or bit-vector (cid:126)x and general kets with indexes u, v, w. Hence, in the following |u(cid:105), |v(cid:105), |i(cid:105) and |(cid:126)x(cid:105)
all designate kets, the last two having the additional characteristics of being basis kets.

When considering two registers of respective size m and n, the state of the compound system
lives in the Kronecker product2 –or tensor product–of the original state spaces: a general state is
then of the form

∑
(cid:126)x∈BVm,(cid:126)y∈BVn

α(cid:126)x,(cid:126)y|(cid:126)x(cid:105)m ⊗ |(cid:126)y(cid:105)n.

In particular, the state of a qubit register of n qubits lives in the tensor product of n state-spaces of
one single qubit.

Adjointness.
In the following we also use the adjoint transformation for matrices. The adjoint of
matrix M with r rows and c columns is the matrix M†, with c rows and r columns and such that for
3, cell M†( j, k) holds the conjugate value M(k, j)∗ of M(k, j) (for any
any indexes j, k ∈
complex number c, its conjugate c∗ is the complex number with the same real part and the opposite
imaginary part as c). The adjoint of a ket |u(cid:105)n is called a bra. It is a row vector with 2n columns
denoted (cid:104)u|n–or simply (cid:104)u|–and with indices the conjugates of those of |u(cid:105)n. This bra-ket notation
is particularly convenient for representing operations over vectors. Given a ket |u(cid:105) and a bra (cid:104)v|,

×
(cid:74)
(cid:74)

0, c

0, r

(cid:74)

(cid:74)

1In the ﬁnite-dimensional case, Hilbert spaces are vector spaces equipped with an inner (scalar) product.
2Given two matrices A (with r rows and c columns) and B,
a11B

their Kronecker product

acB

. . .



is the matrix A ⊗ B =

.

.

.

ar1B

.

.
.
. . .

.

.

.

arcB

. This operation is central in quantum information representation. It enjoys a number of useful al-





gebraic properties such as associativity, bilinearity or the equality (A ⊗ B) · (C ⊗ D) = (A ·C) ⊗ (B · D), where · denotes matrix
multiplication.

3where, for any two integers i, j with i < j,

i, j
(cid:74)

(cid:74)

denote the induced interval, that is the set of integers k such that i ≤ k < j.

Formal methods for quantum algorithms

Page 9

|u(cid:105)(cid:104)v| denotes their Kronecker product –or outer product. Furthermore, if |u(cid:105) and (cid:104)v| have the same
length, then (cid:104)v|u(cid:105) denotes their scalar product–also called inner product. In particular, in the case of
basis states |i(cid:105) and (cid:104) j|, (cid:104)i| j(cid:105) = 1 if i = j and 0 otherwise and |i(cid:105)(cid:104) j| is the square matrix of width 2n
with null coefﬁcient everywhere except for cell (i, j) with coefﬁcient 1. If i = j, then |i(cid:105)(cid:104) j| operates
as the projector upon |i(cid:105).

Quantum measurement and Born rule. The probabilistic law for measurement of kets is given
by the so-called Born rule: for any k ∈
, measuring state |u(cid:105)n from Equation 1 results in k
with probability |αk|2. The measurement is destructive: if the result were k, the state of the register
is now |k(cid:105)n (with amplitude 1).

0, 2n

(cid:74)

(cid:74)

2.1.3 Separable and Entangled States

From Section 2.1.2, a quantum state vector of length n is a superposition of basis elements with
coefﬁcients whose squared moduli sum to one. Then, tensoring n quantum states |u j(cid:105)1 of length 1
results in a state |u(cid:105)n = (cid:78)
|u j(cid:105)1 of length n. One can decompose back |u(cid:105)n into the family
{|u j(cid:105)} j∈
: we say that |u(cid:105)n is a separable state. Note that the structure of quantum information
(cid:74)
introduced above contains states missing the property of being separable. As an example, the state

0,n
j∈
(cid:74)
(cid:74)

0,n
(cid:74)

|β00(cid:105) =

1
√
2

(|00(cid:105) + |11(cid:105))

cannot be written as a tensor product of two single-qubit states. This phenomenon is called entan-
glement, and |β00(cid:105) is an entangled state. It induces that one can store more quantum information in
n qubits altogether than separately.

Example 2.1 (Bell states). State |β00(cid:105)is a construction of particular interest in quantum mechanics
and quantum computing. In their famous 1935 article [62], Einstein, Podolsky and Rosen argued
for the incompleteness of quantum mechanics, based on considerations upon |β00(cid:105). In 1964 [21],
J.S. Bell proposed an experiment to test the argument. It was based on statistics over experiments
on the four following states:

|β00(cid:105) = 1√
2
|β10(cid:105) = 1√
2

(|00(cid:105)2 + |11(cid:105)2)
(|00(cid:105)2 − |11(cid:105)2)

|β01(cid:105) = 1√
2
|β11(cid:105) = 1√
2

(|01(cid:105)2 + |10(cid:105)2)
(|01(cid:105)2 − |10(cid:105)2)

These four states are now known as the Bell states (notation β stands for the initial B) and are used
in many quantum protocols, such as teleportation or superdense coding (see Section 5.1). We use
them and their generation as a running example in the rest of this survey.

2.1.4 Quantum Circuits

Three kinds of operations may be applied to quantum memory, exempliﬁed in Figure 2 with the
circuit generating and measuring Bell states:

• the initialization phase allocates and initializes quantum registers (arrays of qubits) from clas-
, indexed by value iw. It
sical data. In Figure 2 it is represented on the two ﬁrst qubit wires as
creates a quantum register in one of the basis states (that is, in the case of a two-qubit register,
in one of the four basis states |00(cid:105), |01(cid:105), |10(cid:105), |11(cid:105)),

Formal methods for quantum algorithms

Page 10

• the actual quantum computing part consists in transforming an initialized state. This is per-
formed by applying a sequence of proper quantum operations, structured in a so-called quan-
tum circuit. In Figure 2 this part is identiﬁed with a dashed box (itself sequenced with dotted
boxes a. and b.),

• the extraction of useful information from a quantum computation is performed through the
measurement operation, by which one probabilistically gets classical data from the quantum
memory register. Measurement is represented, on each qubit it is applied to, as (cid:95)/ .

• In generalized circuits, not all wires in a register need to be initialized and measured. Hence
in Figure 2 the transformations are performed over the two ﬁrst wires of a wider register, and
the additional wires are left untouched.

i1

i2

.
.
.

H

•

⊕

a.

b.

(cid:95)/

(cid:95)/

.
.
.

Figure 2: Generalized circuit to create and measure Bell states

Note that we reserve the term circuit for the pure quantum part (the dashed box in Figure 2).
We call generalized circuit a process made of a circuit together with, possibly, initialization and
measurements.

Quantum circuits are built by combining, either in sequence or in parallel, a given set of ele-
mentary operations called quantum gates. In addition to sequence and parallelism, derived circuit
combinators (controls, reversion, ancillas, etc) are often used in quantum circuit design (See Fig-
ure 9 in Section 6.1.1 for details). The circuit part of Figure 2 uses two different quantum gates,
drawn in dotted boxes:

• the Hadamard gate H (a.), which induces a state superposition on a given qubit,

• the control not gate, often written CNOT (b.) and represented as

•
⊕ .

It is a binary gate,

ﬂipping the target qubit (in wire 2 in our case) when the control qubit (wire 1) has value 1.

2.1.5 Quantum Matrix Semantics and density operators

The transformation operated by a quantum circuit on a quantum register is commonly interpreted as
a matrix. In this setting, the parallel combination of circuits is interpreted by the Kronecker product
and the sequential combination by the matrix multiplication.

Formal methods for quantum algorithms

Page 11

Quantum circuits. Quantum circuits happen to operate as unitary operators (preserving the inner
product between vectors). A set of elementary gates is (pseudo-) universal if, by a combination
of parallel and sequential composition, one can synthesize (or approximate) all unitary operations.
Examples for elementary gates are given in Table 1, with their matrix semantics interpretation. Apart
from the already encountered gates H and CNOT, it features two additional families of gates, Ph(θ )
and RZ(θ ), where θ is an angle inducing a so-called phase factor eiθ . Ph(θ ) operates a simple
scalar multiplication by a phase factor, while RZ(θ ) operates as a rotation. Table 1 is given with
indexes ranging over any angle θ , making the set of gates universal. Usually, we restrict it to angles
of measure π
2n , with n ranging over integers. This restriction makes the resulting set of gates pseudo-
universal.

Table 1: Elementary gates and their matrix semantics

H

(cid:19)

(cid:18)1

1
1 −1

1√
2

CNOT
0
0
0
1
0
0
1
0







0
0
1
0







1
0
0
0

Ph(θ )

RZ(θ )

(cid:18)eiθ
0

(cid:19) (cid:18)e−iθ
0

0
eiθ

(cid:19)

0
eiθ

Example 2.2 (Semantics for the Bell generating circuit). Let us look at Figure 2 again. First,
an Hadamard gate is applied to the ﬁrst wire and nothing happens to the second wire (it stays
untouched, which is represented by the identity matrix). The matrix for the ﬁrst column–the dotted
box indexed with a.–of Figure 2 is
(cid:18)1

(cid:19)

(cid:19)

1
√
2

1
1 −1

(cid:18)1
0

⊗

(cid:19)
0
1

=

1
√
2

(cid:18) 1 0 1
0
0 1 0
1
1 0 −1 0
0 1 0 −1

Then gate CNOT is applied, with matrix

(cid:18) 1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0

(cid:19)

and the sequential combination of the two sub-

circuits translates, in the matrix semantics, as their usual product (mind the reverse ordering, wrt
the ﬁgure):

Mat(Bell-circuit) =

(cid:19)

(cid:18) 1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0

·

1
√
2

(cid:18) 1 0 1
0
0 1 0
1
1 0 −1 0
0 1 0 −1

(cid:19)

=

1
√
2

(cid:18) 1 0 1
0
0 1 0
1
0 1 0 −1
1 0 −1 0

(cid:19)

(cid:1), |1(cid:105) as(cid:0) 0
1

In the matrix formalism, we interpret |0(cid:105) as the column
Application to input initialized kets.
vector (cid:0) 1
(cid:1) and the concatenation |i j(cid:105), where i and j both are sequences of 0 or 1, as
0
the Kronecker product |i(cid:105) ⊗ | j(cid:105). For example, the two qubits basis kets |00(cid:105), |01(cid:105), |10(cid:105), |11(cid:105) are
represented, respectively, as

(cid:18) 0
0
1
0
The transformation performed by a quantum circuit C upon a quantum state |ψ(cid:105) is interpreted as the
matrix product Mat(C) · |ψ(cid:105) of the matrix for this circuit by the column vector for this quantum
state. By notation abuse, we also simply write it C|ψ(cid:105).

(cid:18) 0
0
0
1

(cid:18) 0
1
0
0

(cid:18) 1
0
0
0

and

(cid:19)

(cid:19)

(cid:19)

(cid:19)

,

,

.

Example 2.3. One can now directly verify that the Bell generating circuit from Figure 2 generates
the Bell states from Example 2.1: for any a, b ∈ {0, 1},

Bell-circuit · |ab(cid:105) = |βab(cid:105)

Formal methods for quantum algorithms

Page 12

Measurement. Last, measurement is performed over an orthonormal basis of the Hilbert space.
For sake of simplicity, we only consider the case of measurements in the computational basis. Hence,
measuring a quantum register results in a basis state, with probabilities following the Born rule
introduced in Section 2.1.2: measuring any state |u(cid:105)n results in basis state |k(cid:105)n with probability
(written proba measure(|u(cid:105)n, |k(cid:105)n)) | αk |2, where αk is the amplitude of |k(cid:105)n in |u(cid:105)n. Applying this
rule to the Bell state, one easily state that for any a, b, i, j ∈ {0, 1},

proba measure(|βab(cid:105), |i j(cid:105)) =

1
2

(if b = 0 then i ⊕ j else 1 − (i ⊕ j))

where ⊕ denotes addition modulo 2. Note, from Example 2.1, that index a in notation |βab(cid:105) only
accounts for a −1 factor in the second term of the state superposition. Hence, since measurement is
ruled by the Born rule and since this rule ignores negation (see Section 2.1.2), then index a does not
appear in the expression of proba measure(|βab(cid:105), |i j(cid:105)).

Discussion over the matrix semantics. Matrix semantics is the usual standard formalism for
quantum computing (see [140] for example). Still, the size of matrices grows exponentially with
the width (number of qubits) of circuits, so it is often cumbersome when addressing circuits from
non-trivial algorithm instances. Furthermore, algorithms usually manipulate parametrized families
of circuits. The resulting parametrized families of matrices may not be conveniently writable.

Hence, a more compact interpretation for quantum circuits may be helpful.

In particular,
path-sum semantics [5, 4] directly interprets quantum circuits by the input/output function they
induce over kets–corresponding, in matrix terms, for any circuit C of width n, to the function
|u(cid:105)n (cid:55)→ Mat(C) · |u(cid:105)n. To do so, it exhibits a generic form for quantum registers description, which
is generated by a restricted number of parameters and composes nicely with sequence and parallel
compositions. Path-sum semantics plays a growing role in formal speciﬁcation and veriﬁcation. It
is introduced with further details in Section 5.2.

Density operators.
In the preceding paragraph, we introduced measurement as a non-deter-
ministic operation over quantum states. Another strategy consists in dealing with a notion of states
featuring this non-determinism. A mixed state (as opposed to a pure state) is a probability distribu-
tion over several states. Alternatively, it can be seen as an incomplete description of a state, featuring
the incomplete knowledge one may have about it. Then, measurement can be characterized as a sim-
ple transition between mixed states.

In quantum processes, this view is formalized by density operators, that extends matrices for-
malism with the characterization of probabilistic states. For sake of brevity, in this paragraph we
give only a short introduction to the density operator formalism. Our aim here is only to provide the
required deﬁnitions and notations for this review. For further detail about density operators and for
the related soundness proofs, we refer the interested reader either to [168] or [139] (Section 2.4).

Basically, the density operator for a pure state |x(cid:105) is the reﬂexive outer product |x(cid:105)(cid:104)x|. Given a set
S of indices and a distribution of states {|xk(cid:105)}k∈S, each occurring with probability pk, we represent
the overall mixed state as the density operator

ρ := ∑
k∈S

pk|xk(cid:105)(cid:104)xk|

By linearity, the result of applying a unitary U to |x(cid:105)(cid:104)x| is given by the product U|x(cid:105)(cid:104)x|U †. A
measurement of a quantum register q of size n may be described by the collection of possible pro-
jectors it realizes, that is the set M = {Mk := |k(cid:105)n (cid:104)k|n}k∈
. In the density operators formalism,
0,2n−1
(cid:74)
(cid:74)

Formal methods for quantum algorithms

Page 13

MkρM†
k .

the action of M over a state ρ may result in any state MkρM†
k , with probability tr(MkM†
k ρ), where
M( j, j)
the trace tr(M) of a square matrix M with n rows and columns is deﬁned as the sum ∑ j∈
0,n
(cid:74)
(cid:74)
of its diagonal cell values. Then, the overall action of a measurement M over a density operator ρ
results in ρ (cid:48) = ∑k∈
0,2n−1
(cid:74)
(cid:74)

Now, measurement description generalizes to the case of partial measurements, where only a
sub-register is measured. Let us consider the case of a quantum register q of size n = n1 + n2. We
write q1 and q2 for the concatenated sub-registers and H, H1, H2 for the respectively induced Hilbert
spaces. To simplify the notations we consider the case of measuring the ﬁrst n qubits. For any
density operator ρ, if it is separable as ρ = |x1(cid:105)n1 (cid:104)y1|n1 ⊗ |x2(cid:105)n2 (cid:104)y2|n2, then the partial trace of
ρ over H2 is deﬁned as tr2(ρ) = (cid:104)y1|x1(cid:105)|x2(cid:105)(cid:104)y2| and the deﬁnition generalizes by linearity to any
density operator ρ. Then, tr2(ρ) equivalently represents the result of:

• (1) measuring register q2 from the mixed state ρ and (2) forgetting the measured qubits while

conserving memory of the unmeasured subregister q1 state;

• or just forgetting about (discarding) register q2 in the description of ρ. Then, tr2(ρ) is the
description of the sub-system held by q1. We call tr2(ρ) a partial density operator on H1.

2.1.6 Other Models for Quantum Computations

Many alternatives are currently explored for physical implementations of quantum computing ma-
chines and worth mentioning. Some of them (such as Measurement Based Quantum Compu-
ting [157, 32], topological quantum computations [76], linear optical networks [1], adiabatic quan-
tum computing [65], etc.) differing on rather fundamental aspects (like, e.g., the elementary op-
erations constituting computations). Nevertheless, currently, formal methods developments mainly
address the standard circuit model introduced above.

The ZX-Calculus [47] also provides an alternative graphical formalism to reason about quantum
processes. Basically, in this setting, quantum operations are represented by diagrams and their
composition through sequence or parallelism corresponds to graphical compositions in the calculus.
This language comes with a series of enabled transformations over graphs, preserving computational
equivalence. ZX-Calculus is presented in Section 5.1.

2.2 Algorithms

As previously introduced, quantum computers are meant to perform calculations that classical com-
puters are a priori not able to perform in a reasonable time. We give the formal complexity theory
characterization for this point in Section 2.2.1, then Section 2.2.2 discusses the usual conventions
for quantum algorithms descriptions.

2.2.1 Quantum Algorithms and Complexity

It is commonly assumed that formal problems are tractable by a computer if there exists an algorithm
to solve this problem in time (measured by the number of elementary operations it requires) that is
bounded by a polynomial over the size of the input parameters. Formal problems satisfying this
criterion for classical computers form a complexity class usually referred to as P. It is schematically
represented in Figure 3.

As introduced in Section 2.1.2, extracting useful information from a quantum register requires
a measurement, ruled by the Born law. Therefore, a quantum computation is an alternation of non-
deterministic (measurement) and deterministic (circuit unitary application, classical post-treatment,

Formal methods for quantum algorithms

Page 14

etc) operations. Since such computations are probabilistic, the tractability criterion from above needs
to be slightly adapted. Instead of considering problems for which a polynomial algorithm brings a
solution with certainty, we consider those for which a polynomial algorithm brings a solution with
an error probability of at most 1
3 . The corresponding class of problems for quantum computers is
called bounded error quantum polynomial time (BQP).

In addition to P and BQP, Figure 3 represents the non-deterministic polynomial time class NP. It
gathers formal problems P for which there is an algorithm that, given a candidate solution, checks
whether this candidate is an actual solution for P in polynomial time. It is trivial that P is included
in NP and it is also proved that P ⊆ BQP. There are good reasons to believe that these inclusions
are strict. Nevertheless, strictness is not formally proved and there are a variety of problems that
belong to NP without a known tractable resolution algorithm.

NP

BQP

P

Figure 3: Complexity classes P, NP, BQP

Hence, quantum algorithm performance is not to be evaluated against the best possible perfor-
mance of any classical computation (which depends on whether BQP = P) but, more pragmatically,
against the best classical known equivalent.

Then, quantum computing is relevant for problems that are polynomially solvable by a quantum
computer (with a given probability of success) but intractable by a classical one. They appear in the
gray zone in Figure 3. The question whether the dark gray part (BQP\ NP) is empty or not depends
on whether BQP ⊆ NP, which is unknown, but several BQP-complete problems have been described
through the literature [200]. These are neither easily computable nor veriﬁable with known classical
means, but may be computed with quantum means: since quantum computers output a right solution
for them with probability > 2
3 , after several runs one can select the best represented output as the
sought solution.

Let us stress that the correspondence between polynomial solvability and tractability is not strict.
For a problem, not belonging to a polynomial class bounds the size of input parameters concretely
tractable by a computer, but does not absolutely forbid computation for any instance of it. Hence, for
some problems, the quantum advantage does not consist in providing a polynomial resolution, but
in reducing computation time to extend the set of tractable inputs. A typical example is the Grover
search algorithm [84], searching for a distinguished element in an unstructured data set, providing a
quadratic acceleration against classical procedures.

2.2.2 Quantum Algorithm Design

Before introducing the challenges at stake with implementations of quantum algorithms and their
formal solutions, we make a few observations on the usual format used to describe quantum algori-
thms, based on an example: Figure 4 reproduces the core quantum part for Shor’s algorithm [140,
p. 232]– certainly the most emblematic of all quantum algorithms.

Formal methods for quantum algorithms

Page 15

The following observations generally hold for other quantum algorithms in the literature. We

give them together with illustrations (within parenthesis) from the example of Figure 4.

1. The algorithm is structured in two main parts: a speciﬁcation preamble and a Procedure de-
scription. The preamble indicates the minimal speciﬁcation an implementation should satisfy.
Note that it ﬁgures as an actual part of the algorithm itself. It contains three types of entries:

• a description of the Inputs, giving a signature for the parameters (a black-box circuit U,
integers x, N, L and two quantum registers of sizes t and L) and some preconditions for
these elements (e.g. x co-prime to L, L being N bits long, etc);

• a description of the Outputs of the algorithm. It contains, again, a signature (an integer)
and a success condition for these Outputs (to be equal to the sought modular order);

• a Runtime speciﬁcation, containing: (1) a probability of success for each run of the
Procedure (O(1)), (2) resources speciﬁcations. In the example, the latter consists in
bounding the number of required elementary operations. Further metrics are also often
used (the maximal width of required quantum circuits–the number of qubits a circuits
requires, the maximal depth of a circuit–the maximal number of operations performed
on a given qubit, etc).

2. The Procedure itself consists of a sequence of declared operations, interspersed with formal
descriptions of the state of the system along with the performance of these operations. (in
Figure 4 these elements are given in parallel, declarations of operations constitute the right-
hand side and intermediate formal assertions are on the left-hand side). These assertions serve
as speciﬁcations for the declared operations. For instance, operation “create superposition”
has precondition the formal expression of Line 1, left (framed in blue) and postcondition the
one of Line 2, left (framed in red). They serve as arguments to convince the reader that the
algorithm Outputs conditions are met at the end of the Procedure (notice that the ultimate
such postcondition–the measured state being r– corresponds to the success condition for the
overall algorithm). But we can also interpret them as contracts for the programmer, commit-
ting her to implement each function in any way provided that whenever its inputs satisfy the
preconditions, then its outputs satisfy the postconditions.

3. The algorithm description is parametric, and so should be any program implementing it.
Hence, the quantum programming paradigm is higher-order: a quantum program is a function
from (classical data) input parameters to quantum circuits. Then, each instance of a quantum
circuit behaves as a function from its (quantum data) inputs to its (quantum data) outputs.

Most of the current quantum programs [153, 83, 193, 181, 180, 27, 41] proceed as implementa-
tions for functions such as those declared in Figure 4 (right part of the Procedure part), providing
no guarantee over the algorithm speciﬁcations, be it about their functional behavior or their resource
speciﬁcations.

Based on the preceding comments, the purpose of formal veriﬁcation can be summarized as

completing algorithm implementations with their proved speciﬁcations. In other words:

Formal veriﬁcation in quantum programming aims at providing solutions to furnish, in addition to
quantum programs, evidence that these programs meet their speciﬁcations, in terms of both success
probability and resource usage.

Formal methods for quantum algorithms

Page 16

Inputs: (1) A black-box Ux,N which performs the transformation
| j(cid:105)|k(cid:105) → | j(cid:105)|x jk mod N(cid:105), for x co-prime to the L−bit number N,
(2) t = 2L + 1 + (cid:6)log(2 + 1
(3) L qubits initialized to the state |1(cid:105).
Outputs: The least integer r > 0 such that xr = 1 (mod N).
Runtime: O(L3) operations. Succeeds with probability O(1).

2ε )(cid:7) qubits initialized to |0(cid:105), and

Procedure:

1.

|0(cid:105)|u(cid:105)

2. →

3. →

1
√
2t

1
√
2t

2t −1
∑
j=0
2t −1
∑
j=0

initial state

| j(cid:105)|1(cid:105)

create superposition

| j(cid:105)|x jmod N(cid:105)

apply Ux,N

≈

1
√
r2t

r−1
∑
s=0

2t −1
∑
j=0

e2πis j/r| j(cid:105)|us(cid:105)

r−1
∑
s=0

4. →

1
√
r
5. → (cid:93)|s/r(cid:105)
6. → r

(cid:93)|s/r(cid:105)|us(cid:105)

apply inverse Fourier transform to the ﬁrst register

measure ﬁrst register

apply continued fraction algorithm

Figure 4: Bird-eye view of the circuit for Shor’s factoring algorithm [174] (as presented in [140,
p. 232])

2.3 Challenges for Quantum Computation

Let us now introduce some particularities of quantum programming with regards to classical com-
puting. They raise design challenges that are particular to this programming paradigm.

2.3.1 Destructive Measurement and Non-Determinism

One of the main particularities of quantum programming is that the output produced by the quantum
memory device follows the probabilistic Born rule (see Section 2.1.2). So, in the general case, the
result of quantum computation is non-deterministic.

Furthermore, a computation in the model from Figure 1 contains both probabilistic quantum
computations and classical control structures, performed by the classical controller. Hence, control
itself may depend on the probabilistic data received from the quantum device and the execution ﬂow
itself is probabilistic.

2.3.2 Quantum Noise

Another particularity comes from the difﬁculty to maintain big quantum systems in a given state and
to control the evolution of this state through time. Along with a quantum computation, uncontrolled
modiﬁcations (bit or phase ﬂip, amplitude damping, etc.) of the quantum state may occur.

Formal methods for quantum algorithms

Page 17

To overcome this phenomenon, one solution consists in integrating error correction mechanisms
into the compilation. Error correction design is an active research ﬁelds [40, 129, 81, 75]. Many
propositions have been developed. They mainly consist in designing redundant quantum circuits
(one logical qubit is implemented by many different physical qubits). Then the main challenge is to
design a solution for testing the reliability along with a computation without losing the state of the
register due to destructive measurement.

Since error correction requires bigger quantum registers (due to redundancy), its possible imple-

mentation is conditioned by the design, elaboration and availability of large quantum processors.

An alternative strategy is to not correct quantum errors, but design computations to limit their
effect. John Preskill introduced the notion of Noisy-Intermediate Scale Quantum (NISQ) technolo-
gies [152]. The formal analysis of error propagation requires the identiﬁcation of possible errors
together with rules specifying how their probability of occurrences propagates along with quantum
circuits [97, 155].

2.3.3 Efﬁcient Compilation on Constrained Hardware

Languages such as Liqui|(cid:105), Q#, Quipper, etc. enable the description and building of quantum circuits
for so-called logical qubits. In practice, realizing a quantum circuit on an actual quantum machine
(physical qubits) requires several compilation passes, in addition to the error correction mentioned
in the preceding paragraph. Among others:

• the physical realization should respect the physical constraints of its target architecture, which
concerns, e.g. connectivity of qubits or register size limits. Considering this point requires
qubit reordering intermediary operations and an adequate mapping between theoretical and
physical qubits;

• the set of possible quantum operations over physical qubits may not correspond to the set of
elementary gates from the logical circuit description, which would require an adequate gate
synthesis and circuit rewriting;

• last but not least, physical realization of an algorithm should be as resource frugal as possible,

requiring the development of circuit optimization techniques.

Each of these steps consists of low-level operations over circuits. They must all preserve func-
tional equivalence while reaching their proper purpose. For these low-level developing layers, one
requires tools and languages formalizing functionally equivalent circuit transformation operations.
ZX-Calculus [47] (Section 5.1) is particularly well-ﬁtted for such design, other propositions include
the proof of path-sum semantics equivalence [5, 4] (Section 5.2) and formally veriﬁed circuit opti-
mization [91] (Section 5.4).

3 General Background on Formal Methods

We now present a brief overview of formal methods. While the domain is old and has led to rich
literature, we try to highlight the underlying main principles and to quickly describe the most popular
classes of techniques so far.

3.1

Introduction

Formal methods and formal veriﬁcation [44] denote a wide range of techniques aiming at proving the
correctness of a a system with a mathematical guarantee—reasoning over all possible inputs and

Formal methods for quantum algorithms

Page 18

paths of the system, with methods drawn from logic, automated reasoning and program analysis.
The last two decades have seen an extraordinary blooming of the ﬁeld, with signiﬁcant case studies
ranging from pure mathematics [80] to complete software architectures [112, 124] and industrial
systems [20, 107]. In addition to offering an alternative to testing, formal veriﬁcation has in principle
the decisive additional advantages to both enable parametric proof certiﬁcates and offer once-for-all
absolute guarantees for the correctness of programs.

3.2 Principles

Formal methods’ main principles were laid mostly in the 1970s. Pioneers include Floyd [74], Hoare
[94], Dijkstra [59], Cousot [49] and Clark [42]. While there is a wide diversity of approaches in the
ﬁeld, any formal method builds upon the following three key ingredients:

• a formal semantics M representing the possible behaviors of a system or program–M is typi-
cally equipped with an operational semantics and behaviors are often represented as a set of
traces L(M);

• a formal speciﬁcation ϕ of the acceptable or correct behaviors–ϕ is typically a logical formula

or an automaton representing a set of traces Lϕ ;

• a (semi-)decision procedure verifying that possible behaviors are indeed correct, denoted M |=

ϕ–typically a semi-algorithm to check whether L(M) ⊆ Lϕ holds or not.

Regarding the complexity of realistic systems and programs, the veriﬁcation problem is usually
undecidable, hence the impossibility to have a fully automated and perfectly precise decision pro-
cedure for it. The different formal method communities bring different responses to get around this
fundamental limitation, yielding different trade-offs in the design space, favoring either restriction
of the classes of systems under analysis, restrictions of the classes of properties, human guidance or
one-sided answer (over-approximations or under-approximations).

Overall, after two decades of maturation, formal methods have made enough progress to be

successfully applied to (mostly safety-critical) software [89, 191, 12, 31, 50, 116, 107].

3.3 The Formal Method Zoo

We present now in more detail the main classes of formal methods. While recent techniques tend to
blur the lines and combine aspects from several main approaches, this classiﬁcation is still useful to
understand the trade-off at stake in the ﬁeld.

• Type checking and uniﬁcation: at the crossroad of programming language design and for-
mal methods, type systems [150] allow forbidding by design certain classes of errors or bad
code patterns (such as trying to add together a number and a boolean in Java or, in a quan-
tum setting, trying to apply a unitary operation over a classical data register). Traditionally,
type systems focus on simple “well-formedness” properties (good typing), but they scale very
well (modular reasoning) and require only a little manual annotation effort (type inference).
While ﬁrst type systems were based on basic uniﬁcation [93, 136], advanced type systems
with dependent types or ﬂow-sensitivity come closer and closer to full-ﬂedged veriﬁcation
techniques;

• Model checking and its many variants: while initially focused on ﬁnite-state systems [42]
(typically, idealized protocols or hardware models) and complex temporal properties–with

Formal methods for quantum algorithms

Page 19

essentially graph-based and automata-based decision procedures, model checking [43] has
notably evolved along the year to cope with inﬁnite-state systems, either through speciﬁc
decidable classes (e.g., Petri Nets or Timed Automata) or through abstractions. The cur-
rent approaches to software model checking include notably symbolic bounded veriﬁcation
[116, 35] for bug ﬁnding and counter-example guided abstraction reﬁnement [89] for bug
ﬁnding and proof of invariants (but it may loop forever). Usually, model checking relies on
speciﬁcations expressed in a variant of modal logic such as temporal logic [42, 151], dynamic
logic [86, 122, 72] or mu-calculus [114, 167];

• Abstract Interpretation: Generally speaking, Abstract Interpretation [49] is a general theory
of abstraction for ﬁxpoint computations. Abstract Interpretation-based static analysis [161]
builds over Abstract Interpretation to effectively compute sound (i.e. overapproximated) ab-
stractions of all reachable states of a program. Hence, these techniques are well suited for
proving invariants. More precisely, Abstract Interpretation provides a systematic recipe to
design sound abstract computation over sets of program states, by connecting the concrete
domain (e.g., sets of states) to a given abstract domain (e.g., interval constraints) through a
Galois Connexion between an abstraction and a concretization functions. In practice, Abstract
Interpretation comes down to computing the ﬁxpoint over the abstract domain, ensuring ter-
mination but losing precision. Different abstract domains provide different trade-offs between
cost and precision. Historically speaking, the approach targets full automation and implicit
properties (e.g., runtime error);

• Deductive veriﬁcation and ﬁrst-order reasoning: Deductive program veriﬁcation [17, 71, 94,
182] is probably the oldest formal method technique, dating back to 1969 [94] and the devel-
opment of Hoare logic. In this approach, programs are annotated with logical assertions, such
as pre- and postconditions for operations or loop invariants, then so-called proof obligations
are automatically generated (e.g., by the weakest precondition algorithm) in such a way that
proving (a.k.a. discharging) them ensures that the logical assertions hold along any execution
of the program. These proof obligations are commonly expressed in ﬁrst-order or separation
logic [158] and proven by the help of proof assistants [145, 141] or automatic solvers lying
on Satisﬁability Modulo Theory [18] or Automated Theorem Proving [73];

• Interactive proof and second-order reasoning: some techniques completely drop the hope for
automation in favor of expressivity, relying on 2nd order or even higher-order speciﬁcation and
proofs languages–typically in Coq [145] or ISABELLE/HOL [141]. Once programmed and
proved in the language, a certiﬁed functional program can then often be extracted. This family
of approaches is very versatile and almost any problem or speciﬁcation can be encoded, yet it
requires lots of manual effort, both for the speciﬁcation and the proofs– higher-order proofs
can be automatically checked but not found. Still, the technique has been for example used
for certiﬁed compilers or operating systems [124, 112].

4 Overview of Formal Methods in Quantum Computing

As presented in Section 3, formal methods for proving properties of classical algorithms, programs
and systems are well-developed and versatile.
In this section, we present the needs for formal
methods in the realm of quantum computation, while the later sections are devoted to answering
them.

Formal methods for quantum algorithms

Page 20

4.1 The Need for Formal Methods in Quantum Computing

As introduced in Section 2, the data structures at stake in quantum computing make the computations
hard to represent for developers. Intermediary formal languages are of great help for understanding
what quantum programs do and describing their functional behavior.

Furthermore, as introduced in Section 1, directly importing the testing and debugging practices
at use in classical programming is extremely difﬁcult in the quantum case4, due to the destructive
aspect of quantum measurement. Moreover, the probabilistic nature of quantum algorithms seriously
impedes system-level quantum testing. As a consequence, test-based programming strategies do not
seem adequate in the quantum case and quantum computing needs alternative debugging strategies
and methodologies.

So far, existing quantum processors were small enough that their behavior could be entirely sim-
ulated on a classical device. Hence, a short-term solution for overcoming the debugging challenge
relied on classical simulations of quantum programs. Since quantum computer prototypes are now
reaching the size limit over which this simulation will not be possible anymore (among others, [9] is
often referred to as the milestone for this context change, referred to as quantum supremacy), more
robust solutions must be developed.

On the other hand, nothing prevents a priori the formal veriﬁcation of quantum programs. In
addition to constituting alternative debugging strategies, formal methods have several additional
decisive advantages. In particular:

• They enable parametrized reasoning and certiﬁcation in the higher-order quantum program-
ming context introduced in Section 2.2.2: formal certiﬁcation of a parametrized program holds
for any circuit generated by this program, whatever the value of its parameters. In contrast,
testing certiﬁcation holds for the particular values of these parameters that are used in a test.
Formal certiﬁcation is not limited by the size of the parameters;

• It provides once for all an absolute, mathematically proven, certiﬁcation of a program’s spe-
ciﬁcations, whereas testing furnishes at best only statistical arguments based on bounded-size
input samples.

4.2 Typology of Properties to Verify

In this section we detail the different properties one has to mind for developing correct quantum
programs. The goal of formal certiﬁcation is to provide solutions for their veriﬁcation.

4.2.1 Functional Speciﬁcations

A major challenge is to give assurance on the input/output relationship computed by a given pro-
gram, that is verifying whether a given program implements an intended function f . Functional
speciﬁcations are two-layered :

High-level speciﬁcations. We give a circuit an overall speciﬁcation independent from the concrete
implementation. It is made of a success condition and a minimum probability, for any run of this
circuit, to result in an output satisfying the success condition.

In the hybrid model, circuits are run on a quantum co-processor but controlled by a classical
computer, performing control operations (such as if and while instructions, simple sequence, etc).
As a simple example, an algorithm such as the one from Figure 4 outputs a success with probability

4It requires major adaptations and redeﬁnitions, see Section 8.4 for details.

Formal methods for quantum algorithms

Page 21

p. It can be included in a control structure including k iterations of it. This higher-level procedure
has probability [1 − (1 − p)k] to output a success at least once, which can be made arbitrarily close
to 1.

More generally, a high-level quantum veriﬁcation framework [131, 194] considers an algori-
thm as a controlled sequence of quantum functions. There, one considers quantum operations as
primitives and composes them together via controlled sequence operations. These operations are
interpreted as functions in the semantical formalism. For example, [168, 131, 194] formalize quan-
tum programs in the density operators formalism. This view is introduced in detail in Section 7.1
together with the Quantum Hoare Logic (QHL) [131, 194].

Intermediate speciﬁcations.
In the Procedure section from Figure 4, each mid-level step of the
algorithm is given a formal speciﬁcation, that is a description of the state of the system. These
intermediate speciﬁcations are deterministic and concern quantum data.

In a lower-level veriﬁcation approach view, instead of inputting quantum operations as primitive
functions, one builds quantum circuit implementations of these operations, by adequately combining
quantum gates. Such a framework [91, 156, 38] relies on a circuit description language such as
Quipper or QWIRE. Then, an adequate semantics characterization for the built circuits enables to
reason about the quantum data received as inputs and delivered as outputs. A certiﬁcation solution
for quantum circuits enables us to reason compositionally about their semantics. This programming
view is explored in Sections 7.2 and7.3.

4.2.2 Complexity speciﬁcations

The major reason for developing quantum computers and quantum algorithms is to lower compu-
ting complexity speciﬁcations, w.r.t. classical computing solutions (see Section 2.2.1 for precisions).
Therefore, the relevance of a quantum implementation relies on the fact it satisﬁes low complexity
speciﬁcations. As introduced in Section 2.2.2, they may be formulated through different metrics,
such as the width and/or depth of quantum circuits, their number of elementary gates or more com-
plex metrics such as quantum volume [125].

The complexity speciﬁcation is also crucial for another reason: remind from Section 2.3.2 that
quantum computation is subject to noise: the bigger a quantum circuit is, the most prone to error
it is. Functional speciﬁcations introduced so far reason about the theoretical output of quantum
computations, in the absence of errors. The risk of error in a circuit is closely related to the structural
characteristics of this circuit, among which are the different measures of complexity. Therefore, the
information provided by these measures is also crucial to appreciate the functional trustfulness of an
implementation.

4.2.3 Structural Constraints

Quantum circuit design must also consider various structural constraints that discriminate through
several criteria:

1. They can be either relative to a target architecture or absolute (induced by quantum physics
laws). The ﬁrst category comprises, for example, the number of available qubits in a proces-
sor, the connectivity between physical qubits, the set of available elementary gates, etc. The
second category mainly deals with aspects induced by quantum Calculus unitarity (no cloning
theorem, ancilla management, quantum control, etc.);

Formal methods for quantum algorithms

Page 22

2. Now, depending on the programming language at stake, absolute structural constraints may
either be taken into charge by the language design or left to the user’s responsibility. For
example, the no-cloning rule is derived from the unitarity of quantum processes. It forbids
using the same quantum data register twice:

• in languages where quantum data registers are full right objects (eg: Quipper, QWIRE,
etc), caring for the respect of no-cloning is left to the user. In this case, formal veriﬁ-
cation may help her to do so. Solutions like ProtoQuipper [162] or QWIRE [148, 156]
tackle this problem through linear type systems (see Section 6.3);

• another possibility is to reduce the expressivity of the language (eg: QFC/QPL [168],
SQIR [91], QBRICKS [38]), to prevent any possible violation of no-cloning. In SQIR
or QBRICKS, quantum data registers are addressed via integer indexes, but the quantum
data they hold are not directly accessible from the programming language itself. These
data concern the semantics of the language and they are formalized only in the speciﬁca-
tion language. Hence, the respecting conditions for the no-cloning theorem are reduced
to simple indexing rules for quantum circuits.

3. Last, structural program constraints can be either syntactic or semantic. The ﬁrst category
: do not
contains, for example, all constraints that are linked with qubit identiﬁcation (eg.
control an operation by the value of a qubit it is acting on). The most representative example
for semantic constraints concerns a particular aspect of quantum computing that we do not
detail in this survey: the management of ancilla qubits. Ancilla qubits provide additional
memory for some sections of quantum circuits, the content of which is then discharged at
some stage of the computation. Discharging a part of a register is possible (without affecting
the rest of the memory) only if there is no interaction between the memory to discharge and
the rest of the memory (See [140] for further details). Hence, ancilla management is possible
modulo some non-entanglement speciﬁcations, regarding the semantics of quantum circuits.

4.2.4 Circuit Equivalence

Compilation of quantum programs contains many circuit rewriting operations (see Section 2.3.3).
They concern the implementation of logical qubits in a physical framework and require certiﬁcation
for functional behavior preservation. Concretely, given a logical circuit C, compiling C traces as a
chain of circuits, starting from C and each obtained from the precedent by applying a circuit rewriting
operation. Each such rewriting must preserve the input/output relation, to ensure that, provided C ﬁts
its functional speciﬁcations, then so does the ﬁnal physical qubits circuit. In Section 5 we present
two tools enabling the veriﬁcation of circuit equivalence: the ZX-Calculus (Section 5.1) and the
path-sum equivalence veriﬁcation (Section 5.2).

Further formal comparisons between quantum processes. Different notions of equivalence be-
tween quantum processes are also at stake with further uses of quantum information, such as com-
munication protocols. Recent developments [185, 19] generalize the equivalence speciﬁcation to
further comparison predicates between quantum processes. Since they are not designed for the for-
malization of algorithms, which is the scope of the present survey, we do not detail these propositions
in the present survey.

Formal methods for quantum algorithms

Page 23

5 Low-Level Veriﬁcation: Compilation and Equivalence

Realizing logical circuits into physical devices (circuit compilation) requires to deal with severe
constraints: the number of available qubits, their connectivity, the set of elementary operations, the
instability of quantum information–requiring the insertion of error correction mechanisms, etc. As
mentioned in Section 4.2.4, the underlying circuit transformations must preserve functional equiva-
lence with the initial circuit representation, all along the compilation process. In the present section
we introduce formal tools for checking such equivalences and certifying compilation correctness.

5.1 ZX-Calculus and Quantomatic/PyZX

ZX-Calculus [46] is a powerful graphical language for representing and manipulating quantum in-
formation. This language historically stems from category theory applied to quantum mechanics,
through the program Categorical Quantum Mechanics initiated by Samson Abramsky and Bob Co-
ecke [2].

For our purposes, it is interesting to see ZX-diagrams as a lax version of quantum circuits. This
laxness on the one hand implies that not all ZX-diagrams are implementable with physical qubits,
but on the other hand, it allows formalism to get powerful results on the underlying equational theory
(rewriting rules, pseudo-normal forms).

The level of abstraction provided by the language allows the user to reason about quantum pro-
grams or protocols while signiﬁcantly alleviating the ”bureaucracy checks” typically coming with
circuit-level reasoning, in particular, checking sub-circuit equivalence in the presence of ancillas. It
also allows unifying different models of quantum computation (circuits, measurement-based quan-
tum computing, lattice surgery, etc.), as well as to provide optimization strategies for these models.
Last but not least, it can be used to formally (yet, graphically) verify properties on protocols or
programs–all that based on simple graph-based manipulations.

5.1.1 Semantical Model

The ZX-diagrams are generated from a set of primitives:

(cid:40)

,

,

,

,

n...
...
m

α

,

n...
...
m

α

,

(cid:41)

n,m∈N
α∈R

which can be composed either:

• sequentially:

• or in parallel:

...
D1
...
D2
...

...
D1
...

...
D2
...

where D1 and D2 are both ZX-diagrams (themselves composed of the above primitives). We denote
by ZX the set of ZX-diagrams. In these, information ﬂows from top to bottom, which is in contrast
with quantum circuits where it ﬂows from left to right. This is only a matter of convention, as string
diagrams, on which the ZX-Calculus formalism relies upon, are oriented vertically.

Formal methods for quantum algorithms

Page 24

These diagrams are used to represent linear maps, thanks to the so-called standard interpretation

of ZX-diagrams as complex number matrices

: ZX → M (C)5. It is inductively deﬁned as:

(cid:117)

(cid:119)
(cid:119)
(cid:118)

...
D1
...
D2
...

(cid:125)

(cid:127)
(cid:127)
(cid:126)

(cid:116)

=

...
D2
...

(cid:124)

(cid:116)

◦

...
D1
...

.
(cid:75)

(cid:74)

(cid:124)

(cid:116)

...
D1
...

...
D2
...

(cid:124)

(cid:116)

=

...
D1
...

(cid:124)

(cid:116)

⊗

(cid:124)

...
D2
...

(cid:114) (cid:122) = idC2 = |0(cid:105)(cid:104)0| + |1(cid:105)(cid:104)1|

(cid:114)

(cid:121) = (cid:113)

† = |00(cid:105) + |11(cid:105)
(cid:121)

= |0m(cid:105)(cid:104)0n| + eiα |1m(cid:105)(cid:104)1n|

(cid:116)

(cid:113)
n...
...
m

α

(cid:124)

(cid:116)

(cid:124)

α

n...
...
m

(cid:122) = ∑

| ji(cid:105)(cid:104)i j|

i, j∈{0,1}
(cid:114) (cid:122) = |+(cid:105)(cid:104)0| + |−(cid:105)(cid:104)1|

= |+m(cid:105)(cid:104)+n| + eiα |−m(cid:105)(cid:104)−n|

where |+(cid:105) := |0(cid:105)+|1(cid:105)√
For example, idC2 = |0(cid:105)(cid:104)0| + |1(cid:105)(cid:104)1| = ( 1 0 ) ⊗ (cid:0) 1

and |−(cid:105) := |0(cid:105)−|1(cid:105)√

2

2

and |u(cid:105)(cid:104)v| is the ket bra outer product from Section 2.1.2.

(cid:1) + ( 0 1 ) ⊗ (cid:0) 0
1

(cid:1) = (cid:0) 1 0
0 0

(cid:1) + (cid:0) 0 0
0 1

(cid:1) = (cid:0) 1 0
0 1

(cid:1).

0

Notice that the green (light) and red (dark) nodes only differ from the basis in which they are
deﬁned (as (|+(cid:105), |−(cid:105)) deﬁnes an orthonormal basis of C2) and that they can have an arbitrary number
of inputs and outputs. It often happens that a green or red node has a parameter of value 0. In this
represents exactly the Hadamard
case, by convention, this angle 0 is omitted. Finally, notice that
gate of quantum circuits. This is not a coincidence, as ZX-diagrams can be seen as a generalization
of quantum circuits. In particular, we can map any quantum circuit to a ZX-diagram that represents
exactly the same quantum operator:

Ph(θ ) (cid:55)→

π

2θ

RZ(θ ) (cid:55)→ 4θ

π

-2θ

H (cid:55)→

CNOT (cid:55)→

and that preserves sequential and parallel compositions. The elementary gates given above are the
ones detailed in Table 1.

We can actually map any generalized quantum circuit (i.e. circuit including measure) into a

ZX-diagram. Indeed, initializations of qubits are easy to represent: |0(cid:105) (cid:55)→

, and there exists an

extension of the ZX-Calculus [48, 36] that allows the language to represent measurements. In this
extension, we represent the environment as
, which becomes an additional generator of the dia-
grams (we denote by ZX this updated set of ZX-diagrams). This generator can also be understood
as discarding a qubit. However, contrary to classical data, this action affects the rest of the system.
forces us to change the codomain of the standard interpretation, but we will not give
Introducing
the details here. Simply keep in mind that the measurement in the computational basis (|0(cid:105), |1(cid:105)) is

represented by

.

In this way, we can (fairly) easily represent any generalized quantum circuit as a ZX-diagram.
But we can actually represent more, and this is an active ﬁeld of research to try and characterize
diagrams that can be put in circuit form (we talk about “extracting a circuit”). First was introduced
the notion of causal ﬂow [52] which was then extended to that of “gﬂow” (for generalized ﬂow)
[33]. Some other variations exist [11].

5To be more precise, the standard interpretation associates to any ZX-diagram in ZX[n, m] (i.e. with n inputs and m

outputs) a complex matrix of dimension 2m × 2n i.e. in M2m×2n (C).

Formal methods for quantum algorithms

Page 25

Quantum circuits, however, are not the only computational model one might want ZX-diagrams
to compile to. Indeed, it so happens that the primitives of the ZX-Calculus quite naturally match
those of lattice surgery [55], a scheme for error correction [75, 95]. In particular, ZX-diagrams
implementing a (physical) lattice surgery procedure features a special notion of ﬂow, the PF ﬂow
(for Pauli fusion ﬂow) [54].

5.1.2 Veriﬁed Properties

The strength of ZX-Calculus comes from its powerful equational theory. This equational theory al-
lows to deﬁne equivalence classes of ZX-diagrams and to conveniently decide whether two different
diagrams represent the same quantum operator.

This question can be asked for quantum circuits as well, as two different circuits may represent
the same operator (e.g. H2 = Id). Some such equational theories exist for quantum circuits [169,
6], but none, as of today, for a universal fragment of quantum mechanics (notice that in [179]
a completeness theorem is given for the interaction between measurements and pure parts of the
circuit, but crucially one for the pure part itself is not provided but only assumed).

The main difference between the two formalisms is that the equational theory of the ZX-Calculus
allows for a powerful result in this language, aggregated under the paradigm “only connectivity
matters”. This result states that we can treat any ZX-diagram as an undirected open graph, where
the Hadamard box and the green and red nodes are considered as vertices. In particular, any (open)
graph isomorphism is an allowed transformation.

π
2

Example 5.1.

=

π
2 because the two diagrams can be obtained from one another

by simply “moving their nodes around” (while keeping inputs and outputs ﬁxed).

This result also allows us to unambiguously represent a horizontal wire. For instance:

:=

=

.

This “meta”-rule, that all isomorphisms of open graphs are allowed, constitutes the backbone of
the ZX-Calculus.
In what follows, different sets of axioms, that satisfy different needs, will be
presented, but this meta-rule will always be there implicitly.

When two diagrams D1 and D2 are proven to be equal using the equational theory T , we write
T (cid:96) D1 = D2. The axiomatization zx for the ZX-Calculus can be found in Figure 5, and it was
recently proven to be complete for the standard interpretation

[189]:

.
(cid:75)

(cid:74)

Theorem 1. ZX/zx is complete with respect to

∀D1, D2 ∈ ZX,

D1
(cid:74)

⇐⇒ zx (cid:96) D1 = D2

(cid:74)
Here ZX/zx represents the quotient of ZX by the equational theory zx. The completeness property
is fundamental. It allows us to reason on quantum processes through diagrammatic transformations
rather than by matrix computations. In particular, it tells us that whenever two diagrams represent
the same quantum operator, they can be turned into one another using only the rules of zx.

(cid:75)

(cid:75)

It is customary in quantum computing to work with particular (restricted) sets of gates. For a lot
of such restrictions, there exist complete axiomatizations [85, 101, 102, 100, 103, 104]. The ZX-

:

.
(cid:75)
(cid:74)
D2

=

Formal methods for quantum algorithms

Page 26

...

...

α

...

...

β

...

...

...

α+β

=
(S)

=
(CP)

=
(Ig)

=
(Ir)

=
(B)

π

4 =
(E)
- π
4

α1

α2

α3

=
(EU)

β1

β2

β3

π

γ

π
2

=
(HD)

- π
2

π
2

...

...

α

...

...

α

=
(H)

(cid:123)

x− := x+ − α3
2 cos x−
2 sin x−

(cid:125)(cid:124)

(cid:122)
x+ := α1+α3
2
z := cos α2
z(cid:48) := cos α2
β1 = arg z + arg z
β2 = 2 arg (cid:0)i + (cid:12)
(cid:12) z
z(cid:48)
β3 = arg z − arg z(cid:48)
γ = x+ − arg(z) + α2−β2

2 cos x+ + i sin α2
2 sin x+ − i sin α2
(cid:12)
(cid:1)
(cid:12)

2

Figure 5: The equational theory zx6. All rules – provably – hold in their upside-down and color-
swapped (between green and red) versions.

Calculus with measurements has a similar completeness result for ZX /zx [36] with an updated
set of rules zx which we will not give here for conciseness purposes.

Some properties of quantum protocols or algorithms can then be veriﬁed by diagram transfor-
mations. To give the reader the ﬂavor of such veriﬁcations, we detail the example of superdense
coding.

Example 5.2 (Superdense Coding). The idea of the superdense coding protocol is to transmit two
classical bits using a single qubit. This is not possible in general, but it is when the two parties
initially share an entangled pair of qubits. The protocol goes as follows:

• Alice and Bob initially share the (previously deﬁned) EPR pair β00 = |00(cid:105)+|11(cid:105)√

, and Alice

2

moreover has two bits she wants to send to Bob

• Alice applies σX =

bit is 1

(cid:18)0
1

(cid:19)
1
0

• Alice sends her qubit to Bob

to her qubit if her ﬁrst bit is 1, then σZ =

(cid:19)

(cid:18)1

0
0 −1

if her second

• Bob applies a CNOT between his qubit and the one he received from Alice, then a H gate on

his qubit, and ﬁnally measures his two qubits

6The way we denote the equations relates to their names in broader literature if such exists, and more informal names if
not. (S) is the spider rule, (Ig) and (Ir) are the green and red identity rules, (E) is the empty diagram rule, (CP) the copy rule,
(B) the bialgebra rule, (EU) the Euler angles rule, (HD) the Hadamard decomposition and (H) the Hadamard colour change
rule.

Formal methods for quantum algorithms

Page 27

This protocol can be represented with a ZX-diagram as follows.

classical data

Alice

Bob

EPR pair

application of σX

application of σZ

CNOTand H

measurements

It is then possible to verify that Bob eventually does get (copies of) Alice’s bits, using the equational
theory (although the whole derivation is not given here):

Alice

Bob

Alice

Bob

Alice

Bob

=

=

We can hence see that data is transmitted from Alice to Bob, without any loss. Interestingly, this pro-
tocol can be extended for secure communication between the two parties [192]. The larger protocol
uses instances of the smaller one to also check whether an eavesdropper has tried intercepting or
copying data.

If Bob is aware that the data he received was compromised, he can abort everything by simply

discarding his qubits, so that the eavesdropper (Eve) gets absolutely no information:

Eve

Alice

Bob

Eve

Alice

Bob

U

=

U

where U denotes an unknown operator applied by Eve to the qubit she intercepted. Notice here how
no information can pass from Alice to Eve. No information is retrieved by the latter.

A plethora of quantum protocols have been veriﬁed with ZX-Calculus in a similar manner [92].
was not introduced in the lan-
Note however that the theory is ever evolving, and in particular,
guage at that time, so the author had to use a trick to make up for the absence of measurement
(namely case-based reasoning).

Formal methods for quantum algorithms

Page 28

5.1.3 Algorithms and Tools

It is possible to manipulate ZX-diagrams in a computer-veriﬁed way. For instance, Quantomatic
[110] allows the users to deﬁne at the same time diagrams in graphical form and equational theories.
It is also possible to work with user-deﬁned nodes in the diagram so that even though
is not
part of the “vanilla” ZX-Calculus, it can be deﬁned as a new node. It is then possible in the tool
to manipulate diagrams in a way that satisﬁes the equational theory, and even to deﬁne rewriting
strategies that can be then applied in an automated way.

The veriﬁcation of protocols and programs using the ZX-Calculus relies on diagrammatic equiv-
alence. This problem, in general, is at least QMA-complete, [29, 98] (the quantum counterpart of
NP-completeness). This problem is linked to the one of simpliﬁcation/optimization, which asks
how a quantum operator can be simpliﬁed, given a particular metric (e.g. the number of non-
Clifford gates). Indeed, for instance if D1 and D2 are two diagrams representing the same unitary
(i.e.

2 ◦ D1 should ideally get us to the identity.

D1

=

D2
(cid:74)

), then simplifying D†
(cid:75)

(cid:75)

(cid:74)
In the case of the Clifford fragment (obtained when the angles in

α

and

α

are restricted

n...
...
m

n...
...
m

to multiples of π
2 ), there exists a strategy that reduces the diagram in (pseudo-)normal form [10].
When this algorithm terminates, the resulting diagram is of size O(n2) where n is the number of
inputs and outputs in the diagram. The algorithm is polynomial in the overall size of the diagram it
is applied on.

Turning an arbitrary diagram into a normal form can be done in principle [103], however, the
complexity of this algorithm is EXPSPACE for universal fragments. So this approach is obviously
not preferred in general. However, one can use the ideas of the algorithm for the Clifford fragment as
a starting point to get a rewriting strategy for the general case. Applications to quantum circuits and
improvements on this strategy can be found in the literature [109, 53, 60, 11], and implementations
in the PyZX tool [108]. This tool can in particular be used to tackle circuit equivalence veriﬁcation,
using a different but related approach to that of Section 5.2 below. The formalism used later is
that of path-sums, where morphisms were showed in [123, 190] to be essentially equivalent to ZX-
diagrams, allowing us to apply strategies for path-sums to the ZX-Calculus and vice-versa. Next
Section is devoted to we introducing the path-sum formalism and its use for circuits veriﬁcation.

5.2 Path-Sum circuit Equivalence Veriﬁcation

Path-sums are a recent alternative direction for verifying the equivalence between quantum circuits
[4, 5]. In this section we brieﬂy present it, together with the main veriﬁcation related achievements.
Note that a generalization of path-sum semantics is introduced in Section 7.2, for parametrized
families of circuits. For sake of readability, conciseness and coherence with this further content, in
the coming paragraphs we slightly simplify path-sums related notations. We refer the reader to the
original deﬁnitions [4, 5] for the full formalism and underlying mathematical structures.

5.2.1 Semantical Model

The standard semantics for quantum circuits is the matrix formalism, introduced in Section 2.1.5. It
associates to each quantum circuit C a matrix Mat(C) and it interprets the behavior of this circuit as
a function |x(cid:105) → Mat(C) · |x(cid:105) from kets to kets, where · stands for the usual matrix product.

Notice that this standard semantics builds on an intermediary object– the matrix–to derive and
interprets the functional behavior of circuits. And it does so by use of a higher-order function–
the matrix product. Contrarily, path-sums are a straight construction of the input/output function

Formal methods for quantum algorithms

Page 29

performed by circuits, enabling compositional reasoning.

Concretely, a path-sum PS(x) is a quantum register state (a ket), parametrized by an input basis

ket |x(cid:105) and deﬁned as the sum of kets

PS(x) ::=

1
√
2

n

2n−1
∑
k=0

2·π·i·Pk(x)
2m

e

|φk(x)(cid:105)

(2)

where the Pk(x) are called phase polynomials while the |φk(x)(cid:105) are basis-kets. This representation is
closed under functional composition and Kronecker product. For instance, if

n ∑2n−1
C : |x(cid:105) (cid:55)→ PS(x) = 1√
k=0 e
2
n(cid:48) ∑2n(cid:48)

C(cid:48) : |y(cid:105) (cid:55)→ PS(cid:48)(y) = 1
√
2

−1
k=0 e

2·π·i·Pk(x)
2m

|φk(x)(cid:105),
k(y)

|φ (cid:48)

k(y)(cid:105),

2·π·i·P(cid:48)
2m(cid:48)

then their parallel combination parallel(C,C(cid:48)) sends |x(cid:105) ⊗ |y(cid:105) to:

1
√
n+n(cid:48)
2

−1

2n+n(cid:48)
∑
j=0

e

(cid:18)
2m(cid:48)

2·π·i

·Pj/2n (x)+2m·P(cid:48)
2m+m(cid:48)

(cid:19)
j%2n (y)

|φ j/2n(x)(cid:105) ⊗ |φ (cid:48)

j%2n(y)(cid:105)

The sequential combination of quantum circuits C and C(cid:48) receives a similar compositional deﬁnition,
parametrized by path-sums components for circuits C and C(cid:48).

5.2.2 Path-Sums Reduction

While path-sums compose nicely, a given linear map (eg. the input/output function for a quantum
circuit) does not have a unique representative path-sum. Hence, given two different path-sum, how
to decide whether they both encode the behavior of a given circuit? To tackle this problem, an
equivalence relation is deﬁned with a few, simple rules that can be oriented. As an example, the HH
rule enables to simplify a path-sum expression over the reduction from a sequence of two consecutive
Hadamard gates to the identity–see Figure 6. All these rules transform a path-sum into an equivalent
one, with a lower number of path variables (parameter n in the notation of Equation 2).

PS(x) = 1
n+1 ∑2
√
2
PS(x) = 1
√
2

n+1 ∑2n

k=0 e

j=0 ∑2n

k=0 e

2 ·π·i( 1
1

2 j(ki+Qk(x))+Pk(x))|φk(x)(cid:105)

1

2 ·π·i(P[i:=Qk(x)]k(x))|φ [i := Qk(x)]k(x)(cid:105)

HH

Figure 6: The HH path-sum transformation rule

We refer the desirous reader to [5, 4] for an exhaustive exposition of the corresponding proof
system. It was proved strongly normalizing, meaning that every sequence of reduction rules applica-
tion terminates with an irreducible path-sum. Furthermore, ﬁnding and applying such a normalizing
sequence is feasible in time polynomial in the width of the circuit at stake, which makes the overall
reduction procedure tractable.

Formal methods for quantum algorithms

Page 30

5.2.3 Veriﬁed Properties

Hence, path-sums provide a human-readable formalism for the interpretation of quantum circuits
as ket data functions. Furthermore, it is given a polynomial normalization procedure, based on
a restricted set of rewriting rules. The method was probed against both circuit equivalence and
functional speciﬁcations veriﬁcation. More precisely:

Translation validation consists, for a given quantum algorithm, in (1) computing the path-sums
for both a non-optimized and an optimized circuit realization and (2) using the normalization
procedure for the automatic checking of their equivalence. It was performed on various quan-
tum routine instances (Grover, modular adder, Galois ﬁeld multiplication, etc) of various size
(up to several dozens of qubits). Interestingly, the methods proved as efﬁcient for identifying
non-equivalence (over erroneous instances) as for checking equivalence.

Quantum algorithms veriﬁcation consists in verifying whether a given circuit instance respects
its functional description. It was performed for instances of similar case studies as for the
translation validation (QFT, Hidden Shift [187]), with up to a hundred qubits.

As conclusion, the path-sum formalism provides a fully automatized procedure for verifying the
equivalence between two circuits. Hence, given two quantum circuits, the latter being a supposed
optimized version of the former, path-sums treatment enables us to verify that they implement the
same quantum function. Since path-sums perform internal complexity reduction, an open direction
is a search for efﬁcient heuristics extracting an optimized quantum circuit from reduced path-sums.
As mentioned in Section 5.1, this problem is closely linked to the reduction of ZX-Calculus dia-
grams. So, in its general form, it faces the same complexity limitations. The search for efﬁcient
reduction procedure applying to identiﬁed useful fragments could then both beneﬁt from and feed
advances in the ZX setting.

In its present state of development, using path-sums for quantum algorithm veriﬁcation is re-
stricted to compilation time, when program parameters are instantiated. Furthermore, a new run of
the path-sum reduction is required at each new call of a given quantum function. In Section 7.2 we
introduce the QBRICKS language, whose semantics is based on a parametrized extension of path-
sums. It enables the veriﬁcation, once for all, of parametrized programs, holding for any possible
future parameter instances–yet at the price of full automation as the manipulation of parametrized
path-sums requires ﬁrst-order logic reasoning.

5.3 Quantum abstract interpretation

The techniques presented so far target an exhaustive functional description of a quantum circuit.
Because of the intrinsic complexity of quantum computing, their use is limited, in particular by the
size of circuits. As illustrated in the benchmarks summed up in Section 5.2.3, path-sums reduction
enabled, for instance, the veriﬁcation of quantum circuits up to a hundred of qubits.

To push the boundary, a possible strategy comes from Abstract Interpretation (see Section 3.3).
There, one does not target an exhaustive description of the functional behavior of a circuit, but an
over-approximation of it. Such a framework relies on:

• the identiﬁcation of a conveniently structured set of properties of interest (the abstract do-

main);

• sound abstraction and concretization to/from this abstract domain;

• reasoning tools for the abstract domain.

Formal methods for quantum algorithms

Page 31

In [149], the author introduces such an abstract interpretation of quantum states based on their
entanglement structure. The technique enables to identify mutually separable sub-registers. It is
useful, for example, for uncomputation, qubit discarding or identifying a convenient decomposition
for further analysis of a state.

A more recent development on abstract interpretation applied to quantum process is [199], in
which the authors deﬁne abstract domains made of tuples of partial projections over quantum sub-
registers. Intuitively, the idea is to overcome the exponential complexity of quantum states by de-
composing them into sub-spaces. Interestingly, the method was implemented and evaluation results
are provided. In particular, thus abstraction enabled to characterize the invariant in the main loop
structuring the Grover search algorithm and to prove it for instances of width up to 300 qubits.

5.4 Toward Integrated Veriﬁed Optimization: VOQC

A noticeable effort for an integrated veriﬁed quantum optimization was recently led through the
development of a Veriﬁed Optimizer for Quantum Circuits (VOQC–pronounced ‘vox’) [91]. As
main aspects, in comparison to ZX- and path-sum calculus, VOQC:

• is integrated into a core programming environment and applies on circuits issued from para-

metrized programs;

• not only validates the equivalence between an input quantum circuit and a candidate opti-
mized version of it, but also provides the formally veriﬁed optimization procedure, directly
generating this optimized version.

source
SQIR
circuit

VOQC
optimizers
circuit mapper

target
SQIR
circuit

source
OPENQASM
circuit

target
OPENQASM
circuit

Figure 7: A simpliﬁed view of VOQC architecture

5.4.1 Architecture

In Figure 7 we give a simpliﬁed view of VOQC architecture: it relies on an Intermediate Represen-
tation Language named SQIR. Since it may also be used as a veriﬁed programming environment,
SQIR is introduced and developed per se in a dedicated section below (Section 7.3). In the present
context, we can think of it as a core language generating parametrized quantum circuits. Then, for
any instance of the parameters, VOQC extracts the corresponding sequence of operations, applies
an optimization procedure upon this sequence of operations and extracts back an optimized proved
equivalent SQIR quantum circuit. Furthermore,

Formal methods for quantum algorithms

Page 32

• in addition to optimization, VOQC also contains some circuit mapping functionalities. They
perform further circuit transformation so that the output circuits ﬁt to speciﬁc quantum ar-
chitecture qubit connectivity constraints. This functionality is a preliminary address to the
problem raised as ﬁrst bullet in Section 2.3.3,

• VOQC environment also provides both ways compilations between SQIR and the standard
assembly language OPENQASM [51]. Hence, it opens the way for a modular easy inte-
gration in any standard programming environment, in particular QISKIT [153], which uses
OPENQASM as assembly language.

5.4.2 Optimization Procedure

VOQC optimization process provides two functionalities, one is deterministic (optimization by
propagation and cancellation) and the other one requires a replacing circuit input.

Optimization by propagation and cancellation is based on local circuit rewriting schemes and
self composition properties of elementary gates, borrowed from [138] (eg., sequences of an even
number of either H, CNOT or X gate annihilate as the identity, successive occurrences of Rz gates
melt by summing their angle parameters, etc). Hence, the procedure consists of two successive
steps:

• propagate: for any elementary gate, it

– considers several identiﬁed patterns enabling gate commutations,

– ﬁnds all occurrences of these patterns,

– and performs the related commutation, pushing any occurrence of this elementary gate

to the end of the computation,

• cancellation then consists in deleting the resulting repetitive occurrences of the elementary

gate at stake.

Optimization by circuit replacement
consists in substituting a part of a quantum circuit (a sub-
circuit) by another one that is proven to be functionally equivalent. In this case, the equivalence
proof is led by help of the path-sums semantics (see Section 5.2). Hence, in its most general form,
the process requires an external equivalence proof oracle. Nevertheless, VOQC provides some in-
stances of such proved equivalence patterns (eg, rotation merging), whose application is automatic.

Performance and Achievements. VOQC performance has been evaluated against several stan-
dard quantum computation routines, and compared with several existing optimizers [7, 153, 138,
178, 108]. Note that in VOQC, since optimization is performed as a succession of rewriting opera-
tions, the formal veriﬁcation consists in assessing the equivalence between the input and the output
of the optimization, it does not address the optimization performance. Still, on reported experiments,
VOQC performance competes with other existing non-veriﬁed optimizers, both regarding compu-
tation time and circuit complexity reduction–precise performance comparison tables appear in [91].
Thus, in the current state of the art, the beneﬁts of formally veriﬁed circuit optimization comes for
free.

Formal methods for quantum algorithms

Page 33

5.5 Formally veriﬁed quantum compilation in an imperative setting: CertiQ

CertiQ [173] is another noticeable effort for veriﬁed compilation. Interestingly, it applies to QISKIT
language, which is certainly the most widely used quantum compiler. CertiQ proceeds similarly as
VOQC, by applying successive optimization passes, each consisting in applying local circuit equiv-
alence transformations over quantum circuits. CertiQ has been evaluated against the very compila-
tion environment provided by IBM QISKIT framework. And veriﬁed optimization went through 26
out of the 30 compilation passes the framework offered at writing time. Hence, the current limita-
tions of formally veriﬁed compilation is mainly inherited from the state of the art in (non veriﬁed)
quantum compilation.

The application to QISKIT also inevitably brings an additional drawback: while CertiQ can bring
insurance that compilation respects the functional equivalence between an input and an output quan-
tum circuits, the initial circuit building brick still lacks formal veriﬁcation. Indeed, the environment
is not provided formal means to assess that the input circuit meets a given functional speciﬁcation.
An open work direction then is to develop formal circuit building veriﬁcation methods similar as
SQIR or QBRICKS but applying to (mostly imperative) widely used development environments such
as QISKIT, so as to complete the veriﬁed development chain.

6 Formal Quantum Programming Languages

For reasoning on a concrete runs of quantum algorithms solving a speciﬁc problem instances, the
notion of quantum circuit is natural. Yet, a quantum circuit is only a by-product of a speciﬁc run of
a quantum algorithm, holding only for a speciﬁc instantiation of the algorithm parameters.

Hence, a quantum algorithm is not reducible to a quantum circuit. To run quantum algorithms
and reason about them, one needs quantum programming languages (QPL): this is the topic of the
current section.

6.1 Quantum Programming Languages Design

In Section 5, circuits were merely seen as sequences of elementary gates. However, in most quantum
algorithms circuits follow a more complex structure: they are built compositionally from smaller
sub-circuits and circuits combinators. Circuits are usually static objects, buffered until completion
before being ﬂushed to the quantum co-processor. Still, in some algorithms, they are dynamically
generated: the tail of the circuit depends on the result of former measurements.

In this section, we discuss the high-level structure of quantum algorithms, the requirements for

a quantum programming language, and review some of the existing proposals.

6.1.1 Structure of Quantum Algorithms

The usual model for quantum computation was depicted in Figure 1: a classical computer controls a
quantum co-processor, whose role is to hold a quantum memory. A programmatic interface for inter-
acting with the co-processor is provided to the programmer sitting in front of the classical computer.
The interface gives methods to send instructions to the quantum memory to allocate and initialize
new quantum registers, apply unitary gates on qubits, and eventually perform measurements. Even
though the set of instructions is commonly represented as a circuit, it is merely the result of a trace
of classical execution of a classical program on the classical computer.

Figure 8 presents two standard workﬂows with a quantum co-processor. In Figure 8a, the classi-
cal execution inputs some (classical) parameters, performs some pre-processing, generates a circuit,

Formal methods for quantum algorithms

Page 34

(a) Static scheme

Figure 8: Workﬂows for quantum algorithm

(b) Dynamic scheme

sends the circuit to the coprocessor, collects the result of the measurement, and ﬁnally performs
some post-processing to decide whether an output can be produced or if one needs to start over.
Shor’s factoring algorithm [175] or Grover’s algorithm [84] fall into this scheme: the circuit is used
as a fancy probabilistic oracle. Most of the recent variational algorithms [135] also fall into this
scheme, with the subtlety that the circuit might be updated at each step. The other, less standard
workﬂow is presented in Figure 8b. In this scheme, the circuit is built “on the ﬂy”, and measure-
ments might be performed on a sub-part of the memory along the course of execution of the circuit.
The latter part of the circuit might then depends on the result of classical processing in the middle
of the computation.

Understanding a quantum circuit as a by-product of the execution of a classical program shines a
fresh view on quantum algorithms: it cannot be identiﬁed with a quantum circuit. Instead, in general,
at the very least a quantum algorithm describes a family of quantum circuits. Indeed, consider the
setting of Figure 8a. The algorithm is fed with some parameters and then builds a circuit:
the
circuit will depend on the shape of the parameters. If for instance, we were using Shor’s factoring
algorithm, we would not build the same circuit for factoring 15 or 114,908,028,227. The bottom
line is that a quantum programming language should be able to describe parametrized families of
circuits.

The circuits described by quantum algorithms are potentially very large–a concrete instance of
the HHL algorithm [87] for solving linear systems of equations has been shown [165] to count as
much as ∼ 1040 elementary gates, if not optimized. Unlike the circuit-construction schemes hinted
at in Section 5, this circuit is not uniquely given as a list of elementary gates: it is built from sub-
circuits –possibly described as a list of elementary gates but not only–and from high-level circuit
combinators. These combinators build a circuit by (classically) processing a possibly large sub-
circuit. Some standard such combinators are shown in Figure 9 (where we represent inverse with
reﬂected letters). There is a distinction to be made between the combinator, applied on a sub-circuit,
and its semantics, which is an action on each elementary gate. Combinators are abstractions that
can be composed to build larger combinators, such as the one presented in Figure 10, built from
inversion, controlling and sequential composition.

GenerateRunandgetresultofmeasurementPost-processStartoverprobabilisticallyOutputParametersmeasureheadofcircuitonepossibletailanothertailprob.processinggenerate&runFormal methods for quantum algorithms

Page 35

Figure 9: Standard Circuit Combinators

Figure 10: Example of a derived circuit combinator

6.1.2 Requirements for Quantum Programming Languages

Any scalable quantum programming language should therefore allow the following operations
within a common framework.

• Manipulation of quantum registers and quantum circuits as ﬁrst-class objects. The program-
mer should both be able to refer to “wires” in a natural manner and handle circuits as inde-
pendent objects.

• Description of parametric families of quantum circuits, both in a procedural manner as a
sequence of operations–gates or subcircuits–and in an applicative manner, using circuit com-
binators;

• Classical processing. In our experience [83], quantum algorithms mostly consists of classi-
cal processing–processing the parameters, building the circuits, processing the result of the
measurement.

This broad description of course calls for reﬁnements. For instance some of the classical processing
might be performed on the quantum co-processor–typically the simple classical controls involved in
quantum error correction. The level of classical processing performed on the classical computer and
performed on the quantum co-processor is dependent on the physical implementation. Even though
some recent proposals such as Quingo [183] discuss the design of quantum programming languages
aware of the two levels of classical processing–in and out of the co-processor, this is still a work in
progress.

6.1.3 Review of the Existing Approaches

Most of the current existing quantum programming languages follow the requirements discussed in
Section 6.1.2. In this section, we review some typical approaches followed both in academic and

ABCOriginalcircuitABCABCABCIteration,i.e.sequentialcompositionABCControlCBAInverseABCABCVerticalcompositionAAA−1BBFormal methods for quantum algorithms

Page 36

industrial settings. This review is by no means meant to be exhaustive: its only purpose is to discuss
the possible strategies for the design of QPLs.

When designing a realistic programming language from scratch, the main problem is access to
existing libraries and tools. In the context of quantum computation, one would need for instance to
access the ﬁle system, make use of speciﬁc libraries such as Lapack or BLAS, etc. One can also
rely on the well-maintained and optimized compiler or interpreter of the host language. To quickly
come up with a scalable language, the easiest strategy consists in embedding the target language in a
host language. Indeed, a quantum programming language can be seen as a domain-speciﬁc language
(DSL), and it can be built over a regular language.

Even though the advantages of working inside a host language are clear, there are two main
drawbacks, The ﬁrst one is the potential rigidity of the host language: there might be constructs
natural to the DSL that are hardly realizable inside the host language. The second drawback has to
do with the compilation toolchain: the shallow embedding of the DSL makes it impossible to access
its abstract syntax tree, rendering speciﬁc manipulation thereof impossible.

Embedded QPLs. The ﬁrst scalable embedded proposal is Quipper [83, 82]. Embedded in
Haskell, it capitalizes on monads to model the interaction with the quantum co-processor. Quipper’s
monadic semantics is meant to be easily abstracted and reasoned over:
it is the subject of Sec-
tion 6.2.2. Since Quipper, there has been a steady stream of embedded quantum programming
languages, often dedicated to a speciﬁc quantum co-processor or attached to a speciﬁc vendor, and
mostly in Python: QISKIT [153] and PROJECTQ [180] for IBMQ, CirQ [41] for Google, Strawberry
Fields [106] for Xanadu, AQASM for Atos, etc. From a language-design point of view, most of
these approaches heavily rely on Python objects to represent circuits and operations: the focus is on
usability and versatility rather than safety and well-foundedness.

Standalone QPLs. On the other side of the spectrum, some quantum programming languages
have been designed as standalone languages, with their own parser and abstract syntax tree. Maybe
the ﬁrst proposed scalable language was ¨Omer’s QCL [142].
¨Omer experimented several features
such as circuit-as-function, automatic inversion and oracle generation. However, due to its non-
modular approach, the language did not have successors.

Liqui|(cid:105) [193] and its sequel Q# [181] developed by Microsoft are good examples of an attempt
at building a standalone language while keeping a tight link with an existing programming envi-
ronment, as Liqui|(cid:105)and Q# are tightly linked with the F# framework (itself embedded in the whole
.NET framework), making it possible to easily “reuse” library functions from within a Q# piece of
code. On the other hand, Q# has its own syntax and type system, to capture run-time errors speciﬁc
to quantum computation.

ScaffCC [99] is another example of a standalone QPL. Even though the language is rather low-
level its compiler has been heavily optimized and experimented over, and it serves as a support for a
long stream of research on quantum compiler optimizations.

The last noteworthy language to cite in the series is SILQ [27], as it serves as a good interface
with the next paragraph: aimed at capturing most of the best practices in terms of soundness and
safety, it is nonetheless targeted toward usability.

Formal QPLs. The last line of works on QPLs we would like to mention here is formal languages
aimed at exploring and understanding the design principles and the semantics of quantum algori-
thms. We shall be brief as this is the topic of the remainder of this survey. The initial line of work

Formal methods for quantum algorithms

Page 37

was initiated by Selinger [168] with the study of a small ﬂow-chart language with primitive con-
structs to interact with the quantum co-processor: qubit initialization, elementary gate application
and measurement. This language was later extended to a simple Lambda-Calculus with similar
primitive quantum features [170, 172]. Even though the language is not aimed at full-scale quantum
algorithms, it is nonetheless enough to serve as a testbed for experimenting type systems and many
operational [170, 57, 120] and denotational [143, 171, 58, 88] semantics.

The study of formal QPLs took a turn toward circuit-description languages `a la Quipper with
the development of scalable quantum languages. One of the ﬁrst proposals of formalization is
QWIRE [148], embedded in the proof assistant Coq. QWIRE uses Coq expressive system to en-
code the sophisticated typing rules of QWIRE. In a sense, Coq type system is expressive enough to
use Coq as a host language and still be able to manipulate the abstract syntax tree of a program. The
main design choice for QWIRE is to separate pure quantum computation with its constraints such as
no-cloning, from classical computation.

Albeit disconnected from Coq, the formalization of Quipper has followed a similar root. This
development is based on the formal language ProtoQuipper [162], which extracts the critical fea-
tures out of Quipper: the creation and manipulation of circuits using a minimal Lambda-Calculus.
The language is equipped with a linear type system and a simple operational semantics based on
circuit construction. The simple core proposed by ProtoQuipper has stirred a line of research on
the topic, including the formalization of inductive datatypes, recursion and dependent types in this
context [160, 159, 130, 77].

The last class of formal programming language we want to mention focuses on the speciﬁcation
and veriﬁcation of high-level properties of programs, and are solely based on circuit manipulation:
unlike QWIRE or Quipper, qubits are not ﬁrst-class objects and circuits are simple “bricks” to be
horizontally or vertically stacked. In this class of languages, one can mention qPCF [144], mainly
a theoretical exploration of dependent type systems in this setting, and QBRICKS, presented in Sec-
tion 7.2.

6.2 Formalizing the Operational Semantics

In order to reason on quantum programming languages, one needs to have a formal understanding
of their operational semantics.

6.2.1 Quantum Lambda-Calculi

The Lambda-Calculus [16] is a formal language encapsulating the main property of higher-order
functional languages: functions are ﬁrst-class citizens that can be passed as arguments to other
functions. Lambda-Calculus features many extensions to model and reason about side-effects such
as probabilistic or non-deterministic behaviors, shared memory, read/write, etc.

One of the ﬁrst formal proposals of a quantum, functional language has precisely been a quan-
tum extension of Lambda-Calculus [170]. On top of the regular Lambda-Calculus constructs, the
quantum Lambda-Calculus features constants to name the operations of qubit initialization, unitary
maps and measurements. A minimal system consists of the following terms:

M, N ::= x | λ x.M | M N |

tt | ff | if M then N1 else N2 |
qinit | U | meas.

Terms are represented with M and N, while variables x range over an enumerable set of identi-
it stands for a function of argument x and of body M.
ﬁers. The term λ x.M is an abstraction:

Formal methods for quantum algorithms

Page 38

The application of a function M to an argument N is represented with M N. To this core Lambda-
Calculus, we can add constructs to deal with booleans: tt and ff are the boolean constant values,
while if M then N1 else N2 is the usual test. Finally, qinit stands for qubit initialization, meas for
measurement and U ranges over a set of unitary operations. These three constants are functions: for
instance, qinit tt corresponds to |1(cid:105) and qinit ff to |0(cid:105), while meas applied to a qubit stands for
the measurement of this qubit. A fair coin can then be represented by the term

meas (H (qinit tt)),

(3)

where H stands for the Hadamard gate.

The question is now: how do we formalize the evaluation of a piece of code? In the regular

Lambda-Calculus, evaluation is performed with substitution as follows:

(λ x.M) N → M[x := N]

where M[x := N] stands for M where all free occurrences of x –i.e., those corresponding to the
argument of the function–have been replaced by N. Even though we can still require such a rule in
the context of the quantum Lambda-Calculus, this does not say how to deal with the term qinit tt.
In order to give an operational semantics to the Lambda-Calculus, a naive idea could be to add
yet another construction: a set of constants c|φ (cid:105), once for every possible qubit state |φ (cid:105). If–as shown
by van Tonder [188]– this can somehow be made to work, a more natural presentation consists in
mimicking the behavior of a quantum co-processor, in the style of Knill’s QRAM model [113]: we
deﬁne an abstract machine (|φ (cid:105)n, L, M) consisting of a ﬁnite memory state |φ (cid:105)n of n qubits, a term
M with n free variables x1, . . . , xn, and a linking function L, bijection between {x1, . . . , xn} and the
qubit indices {1, . . . , n}. Variables of M captured by L are essentially pointers to qubits standing in
the quantum memory. The fair coin of Eq. (3) then evaluates as follows.

(|(cid:105)0, {}, meas (H (qinit tt)))

→ (|1(cid:105)1, {x (cid:55)→ 1}, meas (H x))
→ ( 1√
2

(|0(cid:105)1 − |1(cid:105)1), {x (cid:55)→ 1}, meas x)

(cid:26) (|0(cid:105)1, {}, ff) with prob. 0.5
(|1(cid:105)1, {}, tt) with prob. 0.5.

→

In this evaluation, most of quantum computation has been exempliﬁed: initialization of qubits, uni-
tary operations and measurements. Handling the latter in particular requires a probabilistic evalua-
tion, and this requires some care–we invite the interested reader to consult for example Selinger &
Valiron [170] for details.

6.2.2 Monadic Semantics

The operational semantics of the quantum Lambda-Calculus is very limited. Indeed, as discussed
in Section 6.1, quantum algorithms do not in general send operations one by one to the quantum
co-processor: instead, a quantum program must build circuits (or pieces thereof) before sending
them to the co-processor as batch jobs. The quantum Lambda-Calculus does not allow to build
circuits: operations can only be sent one at a time. In particular, there is no possibility to create,
manipulate and process circuits: circuit generation in the quantum Lambda-Calculus is a side-effect
that is external to the language. One cannot interfere with it, and embedding the quantum Lambda-
Calculus as it stands inside a host language, as suggested in Section 6.1.3, would not help.

The solution devised by Quipper consists in relying on a special language feature from Haskell
called monad. A monad is a type operator encapsulating a side effect. Consider for instance a

Formal methods for quantum algorithms

Page 39

probabilistic side effect. There are therefore two classes of terms: terms without side-effect, with
types e.g. Bool, or Int, and terms with side-effect, with types e.g. P(Bool) or P(Int) standing
for “term evaluating to a boolean/integer, possibly with a probabilistic effect”. The operator P(-)
captures the probabilistic side effect.

A monad comes with two standard maps. In the case of P we would have:

return :: A -> P(A)
bind :: P(A) -> (A -> P(B)) -> P(B)

The return operation says that an effect-free term can be considered as having an effect–in the
case of the probabilistic effect, it just means “with probability 1”. The bind operation7 says how to
compose effectful operations: given a function inputting A and returning an object of type B with a
probabilistic side-effect, how to apply this function to a term of type A also having a probabilistic
effect? We surely get something of type P(B), but the way to construct it is described by bind. A
few equations have to be satisﬁed by return and bind for them to describe a monad. For instance,
bind return is the identity on P(A). There can of course be more operations: for instance, we can
add to the signature of P an operator coin of type () -> P(Bool)8.

A nice property of monads is that effectful operations can be written with syntactic sugar in an

imperative style:

do

x <- coin ()
if x then return 0 else return 1

is a term of type P(Int) equals to

bind (coin ()) (λ x.if x then return 0 else return 1)

once the syntactic sugar has been removed.

Following this approach, quantum computation can be understood as side-effect: it combines
both (1) Read/Write effect, since gates are sent to the coprocessor, and results of measurements are
received; (2) Probabilistic effects, since measurement is a probabilistic operation. The ﬁrst attempt
at formalizing this monad is Green’s quantum IO monad [3]: it has then been further developed in
Quipper [83].

Internally, circuits in Quipper are represented using a simple inductive datatype akin to a list of
gates9. The interaction with the quantum-coprocessor is modeled using a speciﬁc I/O monad Circ.
This monad encapsulates the construction of circuits featuring wires holding qubits but also wires
holding bits —results of measurements. A bit is however uniquely useable “inside” the monad:
to use it in Haskell —in an if-then-else construct for instance— we need to “lift” it into a regular
Boolean. The signature of the monad in particular includes

qinit :: Bool -> Circ(Qubit)
measure :: Qubit -> Circ(Bit)
hadamard :: Qubit -> Circ(Qubit)

A fair coin can be implemented as a circuit returning a bit, of type () -> Circ Bit.

7In Haskell, this map is denoted with >>=. For the sake of legibility, here we denote it with bind.
8In Haskell, the unit type is denoted with ().
9Technically a tree structure, as measurements entails branching.

Formal methods for quantum algorithms

Page 40

bitcoin () = do

q <- qinit True
q’ <- hadamard q
r <- measure q’
return r

The function bitcoin will merely generate a computation —producing a circuit— waiting to be
executed. To implement the toss-coin of Section 6.2.2, we then need to “run” the circuit for lifting
the bit into a Boolean. Provided that we have a function

run :: Circ Bit -> P Bool

one can then implement coin () as run (bitcoin ()).

Thanks to the monadic encapsulation, circuits can be manipulated within Haskell. For instance,

inversion and control can be coded in Haskell as circuit combinators with the following types.

inverse :: (a -> Circ b) -> (b -> Circ a)
control :: (a -> Circ b) -> ((a,Qubit) -> Circ (b,Qubit))

The compositionality of the monadic semantics also makes it possible to automatically construct
oracles out of classical speciﬁcation [83, 186].

Compared with the quantum λ -Calculus discussed in Section 6.2.1, where the program can only
send gates one by one to the co-processor, Quipper gives to the programmer the ability to manipu-
late circuits. Although both the quantum λ -Calculus and Quipper represent quantum computations
mathematically, Quipper provides a richer model, better-suited for program speciﬁcation and veriﬁ-
cation than the plain λ -Calculus.

6.3 Type Systems

In Section 6.2, we discussed how to model the operational behavior of a quantum program. We have
however not mentioned yet the run-time errors inherent to quantum computation. In the classical
world, type systems are a standard strategy to catch run-time errors at compile-time. Several run-
time errors speciﬁc to quantum computation can also be caught with a type system, with a few
speciﬁcities that we discuss in this section.

6.3.1 Quantum Data and Type Linearity

The main problem with quantum information is that it is non-duplicable (a.k.a. non clonable, see
Section 4.2.3).
In terms of quantum programming language, this means that a program cannot
duplicate a quantum bit: if U is a unitary map acting on two qubits, the function λ x.U(x ⊗ x) trying
to feed U with two copies of its argument makes no sense. Similarly, it is not possible to control a
gate acting on a qubit with the same qubit. The Quipper code of Figure 11 is, therefore, buggy.

Type systems, in a broad sense, provide a predicate that says that a well-typed program does not
have a certain class of bugs: in the case of quantum programming languages, a large class of bugs
comes from duplicating non-duplicable objects. This calls for a linear type system, enforcing at least
the non-duplication of qubits. This has been taken into account in recent scalable implementations
such as Silq [27].

On the theoretical side, type systems for quantum Lambda-Calculi and ProtoQuipper [162]–the
formalization of Quipper–are typically based on linear logic. Originally designed by Girard [79] (as
a continuation of [121]), linear logic assumes that formulas are linear–i.e. non-duplicable and non-
erasable–by default, and the logic comes equipped with a logic constructor “!” to annotate duplicable

Formal methods for quantum algorithms

Page 41

exp :: Circ Qubit
exp = do

q1 <- qinit True
q2 <- qinit True
r <- qnot q1 ‘controlled‘ q1
return r

Figure 11: An example of a buggy Quipper program

and erasable formulas. Linear logic also proposes a special pairing constructor ⊗ replacing the usual
product and compatible with both the linearity constructs and the (linear) implication (cid:40).

A core type system for a quantum Lambda-Calculus with pairing therefore consists of the fol-

lowing grammar:

A, B ::= qubit | bool | A (cid:40) B | A ⊗ B | !A.
Type A (cid:40) B represents the type of (linear) functions, using their argument only once. Type A ⊗ B
represents the pair of a term of type A and a term of type B. Type !A stands for a duplicable term of
type A. We give a few examples as follows.

• The identity function λ x.x is of type A (cid:40) A, but also of type !(A (cid:40) A) as it is duplicable

(since it does not contain any non-duplicable object);

• If the pairing construct is represented with (cid:104)−, −(cid:105), the function λ x.(cid:104)x, x(cid:105) is of type !A (cid:40)

(!A⊗!A): it asks for a duplicable argument;

• The operator qinit is of type !(bool (cid:40) qubit): it is duplicable but it does not generate a

duplicable qubit;

• The operator meas can however be typed with !(qubit (cid:40) !bool) as a boolean should be

duplicable;

• Provided that U is a unitary acting on two qubits, one can type it in a functional manner with
qubit ⊗ qubit (cid:40) qubit ⊗ qubit: it inputs two (non-duplicable) qubits and outputs the (still
non-duplicable) modiﬁed qubits;

• In particular, provided that we assume implicit dereliction, casting duplicable elements of type
!A to A, the term λ x.U(cid:104)x, x(cid:105) can only be typed with !qubit (cid:40) qubit ⊗ qubit: its argument
has to be duplicable. The fact that this program can never be actually used on a concrete qubit
is a property of the type system (intuitively, qinit only generates non-duplicable qubits).

6.3.2 Example: Quantum Teleportation

Mixing quantum computation and higher-order objects can yield non-trivial objects. The scheme of
teleportation is given in Figure 12. It consists of three steps: (A) creation of a Bell state, (B) measure
in the Bell basis to retrieve two booleans and (C) application of a gate Ub1b2 dependent on the result
of the measure. The state of the top wire is then “teleported” to the bottom wire. It is possible to
understand the pieces of the quantum teleportation protocol as three (duplicable) functions:

(A)
(B)
(C)

!(() (cid:40) qubit ⊗ qubit)
!(qubit (cid:40) (qubit (cid:40) bool ⊗ bool))
!(qubit (cid:40) (bool ⊗ bool (cid:40) qubit))

Formal methods for quantum algorithms

Page 42

Figure 12: Teleportation algorithm

The parts (B) and (C) are duplicable functions producing two non-duplicable functions of type
qubit (cid:40) bool ⊗ bool and bool ⊗ bool (cid:40) qubit. The teleportation algorithm then feeds the two
qubits emitted by (A) to (B) and (C); this gives a general type

!(() (cid:40) (qubit (cid:40) bool ⊗ bool) ⊗ (bool ⊗ bool (cid:40) qubit))

for the protocol. It can be used several times (as it is duplicable). Each time it is run, it generates
a pair of non-duplicable functions (cid:104) f , g(cid:105), and the speciﬁcation of the protocol states that these two
functions are inverse one of the other.

These two functions f and g of the pair are non-duplicable. Indeed, each of them holds a (non-
duplicable) qubit coming from (A). Moreover, in a sense, these functions are entangled, since the
Bell state from (A) is entangled.

6.3.3 Extending the Type System to Support Circuits

Let us assume that the type system of the quantum Lambda-Calculus is extended with lists: [A]
stands for lists of elements of type A (see e.g. [170] to see how to do this). A function [qubit] (cid:40)
[qubit] inputs a list of qubits. It can apply unitary gates to these qubit arguments: It can in fact
describe different circuits, depending on the size of the list. Such a function , therefore, describes
a family of circuits. The quantum Lambda-Calculus is not expressive enough to extract one circuit
out of this family of circuits and operate on it (e.g. by inversing or controlling it).

The ProtoQuipper language [162] and its successors [160, 159, 77, 130] are formalized frag-
ments of the programming language Quipper. They enforce structural properties of quantum pro-
grams using the linear type system of the quantum Lambda-Calculus, yet extending it to support
circuit manipulation. ProtoQuipper comes with a new type construct Circ(A, B): the type of circuits
from A to B, and two functions:

• box sends A (cid:40) B to Circ(A, B). It takes a function A (cid:40) B, partially evaluates it, and stores

the emitted circuit in an object of type Circ(A, B).

• unbox sends Circ(A, B) to A (cid:40) B. It takes a circuit from A to B and reads it as a function of

input A and output B.

The behavior of box and unbox is speciﬁed by the operational semantic of the language [162].

One of the subtleties is the fact that box turns a function–possibly representing a family of
many circuits–to one circuit. In the case of a function of type [qubit] (cid:40) [qubit], this corresponds

|0(cid:105)|0(cid:105)|φ(cid:105)|φ(cid:105)HHUb1b2b1b2(A)(B)(C)Formal methods for quantum algorithms

Page 43

to choosing one size of list and building the circuit for this input size. Whenever the type system
supports inductive types such as lists, the operator box then also takes a shape as a second argument,
for deciding on the shape of the circuit to build. In recent works [77], ProtoQuipper’s type system
has been extended to very expressive dependent types, in order to characterize with a very ﬁne-grain
the shape structure of a family of circuits.

For instance, suppose that the program P sends [qubit] to [qubit]. It corresponds to a family of
circuits, but if we pick a choice of input size n, the type gives no information on the output shape of
the circuit–that is, the number of output wires. Maybe P duplicates each input wire? With dependent
types, we can for instance index list-types with size and type P with

∀n.[qubit]n (cid:40) [qubit]2n.

This type tells us that P corresponds to a family of circuits of even output wires. This makes it
possible to catch errors when using circuit combinators: for instance, the inverse operator can be
typed with

∀n m.Circ([qubit]m, [qubit]n) (cid:40) Circ([qubit]n, [qubit]m)

The inverse of P then becomes a function of type

∀n.[qubit]2n (cid:40) [qubit]n.

In particular, this function can only be applied to lists of even sizes. This run-time error cannot be
checked without shape information.

Although such a type system becomes very expressive, in general, it fails to feature a type

inference algorithm, as this would require to be able to solve arbitrary arithmetic equations.

6.3.4 Dependent types and Proofs of Programs

To build a dependently typed language, an alternative approach is to embed it inside an existing
host language with this feature: QWIRE [148, 147] follows this route and relies on the language
and proof-assistant Coq [25]. While Quipper uses Haskell’s monads to encode circuits, QWIRE
capitalizes on Coq’s inductive types within the formalism of the Calculus of Inductive Constructions
(CiC) [146], the logical framework of Coq.

In Haskell, inductive types are limited in expressivity: without dependent types, it is not possible
to impose constraints on the content of a datastructure. As circuits in Quipper are internally made
of elements of an inductive type, it makes it impossible to forbid ill-deﬁned constructions such as
re-using an erased wire, or using twice a wire on a controlled-not, as shown in Fig. 11.

QWIRE can instead rely on dependent, inductive types to enforce such constraints on circuit
constructions: instead of simply considering circuits as lists of gates, a circuit in QWIRE consists
in a list of gates together with proofs that the gates are added in a sensible way —in other words,
the constructors of the inductive type of circuits in QWIRE corresponds to a set of typing rules for
writing valid circuits.

Interestingly enough, QWIRE does not have to rely on “!” type constructor to distinguish be-
tween duplicable and non-duplicable data. The idea is that instead of working in a linear-logic based
type-system, QWIRE considers an equivalent linear-non-linear model [23]. In this paradigm, there
are two intertwined languages:

• A linear language aimed at qubit manipulation and gate application: a program in this lan-
guage is a circuit. The linearity of the type system enforces the necessary constraints so that
e.g. Fig. 11 is indeed invalid;

Formal methods for quantum algorithms

Page 44

• A high-level, regular language–typically a lambda-calculus, with a regular type system. This
language represents the “usual” programming paradigm where classical, conventional com-
putation happens;

• Then there are two operations, akin to box and unbox, to move from the linear language to

the classical language.

In the context of QWIRE, the classical, regular language is Coq and the linear language is en-
coded using the inductive type of circuits. As Coq features dependent types, QWIRE can then be
regarded as a dependently-typed quantum programming language. However, due to the sophisticated
type system, QWIRE does not feature a type inference algorithm.

6.3.5 Discussion

Type systems for quantum programming languages provide very efﬁcient ways to encode and–
whenever featuring a type inference algorithm–automatically verify some important properties of
programs, and in particular to rule out at compile-time large classes of run-time errors speciﬁc to
quantum computation. In particular, type systems have been used to characterize and enforce

• structure of parametric families of circuits;

• linearity of non-duplicable elements;

• control and inversion of only purely quantum circuits.

However, to be able to go further and characterize functional correctness with respect to speciﬁca-
tion, or validate the number of gates of a circuit, or catch subtle bugs involving concatenation of
inverted circuits, one needs to move away from the simple linear type systems of quantum lambda-
calculi and shift towards sophisticated dependent types, such as the extension ProtoQuipper-D [77]
of ProtoQuipper, or the approach of QWIRE. The gain in expressiveness is then at the expense of
automation [177, 148].

The quest for a ﬁner trade-off, permitting automation while capturing some of what is currently

only available with dependent type system is an active research area in the community.

7 High and Mid-Level Veriﬁcation: Algorithms and Programs

Most quantum programming languages (QISKIT [153] Quipper [83], Liqui|(cid:105) [193], Q# [181], PRO-
JECTQ [180], SILQ [27], etc) embed features for quantum circuit manipulations within a standard
classical programming language. Such circuit-building quantum languages is the current consensus
for high-level executable quantum programming languages. A current major challenge is to link this
language design paradigm with formally veriﬁed programming. In the present section, we introduce
the main existing propositions in that direction.

7.1 Quantum Hoare Logic

Quantum Hoare logic (QHL) [37, 66, 105, 194, 185, 184, 19] is a general framework for reasoning
about the classical control instructions over unitary operations in quantum algorithms. Referring
again to Figure 1, the focus is on the interaction between the classical computer and the quantum
co-processor, instead of the circuit analysis as in Section 5, or the gate to gate circuit building

Formal methods for quantum algorithms

Page 45

functions as in Sections 7.2 and 7.3. Therefore, we consider it as a high-level description of quantum
algorithms.

It is based on the assertion method of Floyd and Hoare [74, 94]–attach each program point with
an assertion and whenever the data ﬂow reaches a program point the attached assertion should be
satisﬁed–which was originated with Alan Turing [8]. Hoare’s approach enables (interactive) theorem
proving for high-level algorithmic description veriﬁcation that proceeds at the same abstraction level
as the language itself. This makes veriﬁcation more human-friendly than lower-level (machine-
friendly) veriﬁcation.

7.1.1 Quantum Programming Language: Quantum WHILE-Programs

The guideline for the hybrid model introduced in Section 2.1.1 is summed up by the slogan “quan-
tum data and classical control” [168]: quantum data can be superposed and entangled, they are
manipulated by basic quantum operations–unitary evolution and measurement, but the high-level
control is still classical (e.g. branch, loops, etc).

In light of this slogan, QHL introduces a minimal programming language for describing quantum
algorithms [195]. We follow [194] for the introduction of QHL technical environment. Let q (resp.
¯q) be a quantum variable (resp. a list of quantum variables); let U be a unitary operator acting on
the qubits ¯q and let M (cid:44) {Mm}m with ∑m M†
mMm = I be a measurement on the qubits ¯q, each Mm
corresponding to a measurement result m (see Section 2.1.5). As a special case, let M(cid:48) (cid:44) {M0, M1}
with M†

1 M1 = I. Then quantum WHILE-programs are generated by the following syntax.

0 M0 + M†

S (cid:44) skip

No operation
q := |0(cid:105)
|
Initialization
¯q ∗= U
|
Unitary operation
S1; S2
|
Sequential composition
if (cid:3)m · M[ ¯q] = m → Sm ﬁ Probabilistic branching
|
| while M(cid:48)[ ¯q] = 1 do S0 od Probabilistic while loop

The intended semantics of language constructs above is similar to that of their classical counterparts.
To illustrate the quantum features contained in these constructs, we make the following comments:

(i) in the initialization, the choice of a ﬁxed state |0(cid:105) is without loss of generality, since any known

quantum state can be prepared by applying a unitary operator to |0(cid:105);

(ii) according to Born rule, measurement results follow a probabilistic law. Since they lie on mea-
surement result observations, branching (resp. while loops) is therefore probabilistic. It cre-
(cid:0)resp. {skip, S0}(cid:1), chosen according to outcomes of the mea-
ates different branches {Sm}m
surement M (resp. M(cid:48)) on the qubits ¯q.

We refer the reader to [194] for a detailed exposition of the syntax above.

Example 7.1 (Preparation of the Bell state |β00(cid:105)). Let p and q be quantum variables, each denoting
one qubit. Then the following program initiates them to |0(cid:105) and implements the circuit from Figure 2,
preparing state |β00(cid:105)from Example 2.1.:

β00 (cid:44) p := |0(cid:105); q := |0(cid:105); p ∗= H; (p, q) ∗= CNOT

Note that the quantum programming language deﬁned above is in the spirit of the hybrid circuit
model presented in Section 2.
Indeed, the basic sequence of quantum operations (initialization,
unitary operation, and measurement) are meant to be interpreted as a generalized quantum circuit
to be executed on a quantum co-processor; and post-measurement branchings (in, e.g., probabilistic
branching and while loop) are meant to be controlled by a classical computer.

Formal methods for quantum algorithms

Page 46

7.1.2 Quantum States, Operations and Predicates

Measuring a quantum state transforms it, following the Born rule (see Section 2.1.2). The resulting
probability distribution over quantum states is formalized as a mixed state (as opposed to pure states,
see Section 2.1.5). For example, a measurement on any pure quantum state |+(cid:105) (cid:44) 1√
(|0(cid:105) + |1(cid:105)) or
2
2 , |1(cid:105)(cid:1)(cid:9), with states |0(cid:105) and |1(cid:105)
|−(cid:105) (cid:44) 1√
2
occurring with an equal probability of 1
2 (notice that this observation makes both states |+(cid:105) |−(cid:105)
impossible to distinguish by simple measurement).

(|0(cid:105) − |1(cid:105)) will result in the mixed state E = (cid:8)(cid:0) 1

2 , |0(cid:105)(cid:1), (cid:0) 1

In this way, the representation of the ﬁnal state of applying a series of measurements to a quantum
state could expand exponentially. To address this issue, a square-matrix representation of quantum
states, i.e. partial density operator, is adopted instead. For example, pure quantum state |+(cid:105) is
represented as |+(cid:105) (cid:104)+|, and mixed quantum state E as 1
2 |1(cid:105) (cid:104)1|. See Section 2.1.5 for a
brief introduction to partial density operators, and [168, 195, 139] for further details.

2 |0(cid:105) (cid:104)0| + 1

If we see the matrix representation of a quantum state (partial density operator) as a linear op-
erator, then a quantum operation– initialization, unitary evolution and measurement–can be thought
of as a super operator, i.e. a function from linear operators to linear operators. What’s interesting
is that every quantum WHILE-program deﬁned above can be interpreted as a quantum operation,
and partial density operators are closed under quantum operations. This justiﬁes the success of
representing quantum states as partial density operators and deﬁning the denotational semantics of
quantum programs as quantum operations [168, 195].

Following [56], a quantum predicate on vector space H is deﬁned as a Hermitian operator M be-
tween the zero operator 0H (representing the contradiction) and the identity operator IH (representing
the tautology). Instead of the usual binary satisfaction judgment, QHL evaluates the satisfaction of
a predicate by a state as a real value between 0 (false) and 1 (true). It is deﬁned as the trace tr(Mρ)
of the product Mρ. Intuitively, it represents the expectation for the truth value of M in the mixed
state ρ (which is, again, a probability distribution over pure states).

Then, the intuition of implication between predicates is also probabilistic. It is ﬁlled by the
L¨owner order M (cid:118) N, relating operators M and N, if and only if, for any state ρ, the expectation truth
value of N in ρ is more or equal to that of M in ρ. This condition is formalized as tr(Mρ) ≤ tr(Nρ)
for all states ρ (See, e.g., [194, Lemma 2.1]).

Adopting such quantum predicates as assertions, among many others (e.g., interpreted as phys-
ical observables), provides simple expression means for many properties of quantum effects. For
example, quantum predicate |+(cid:105) (cid:104)+| expresses that a state ρ is in the equal superposition |+(cid:105) with
probability tr(|+(cid:105) (cid:104)+|ρ); quantum predicate |β00(cid:105) (cid:104)β00| expresses that a state ρ is in the maximal
entanglement |β00(cid:105) with probability tr(|β00(cid:105) (cid:104)β00|ρ), etc.

7.1.3 Quantum Program Veriﬁcation

For now, a quantum (partial) correctness formula can be the Hoare’s triple {P} S {Q}, where S
is a quantum WHILE-program, and P, Q are quantum predicates. To deﬁne the partial-correctness
denote the semantic function of S (Note
semantics of quantum Hoare’s triples, in the sequel, let
(ρ) the output of S on
S
that
(cid:74)
the input ρ.

is a quantum operation deﬁned by induction on S, cf. [195]), and

S
(cid:74)

S

(cid:74)

(cid:75)

(cid:75)

(cid:75)

Deﬁnition 7.1 (Semantics of partial correctness, cf. [194]). Let P, Q be quantum predicates and S
a quantum WHILE-program. We say that S is (partially) correct w.r.t. precondition P and postcon-
dition Q, written |= {P} S {Q}, if

∀ρ,

tr(Pρ) ≤ tr(cid:0)Q

S

(ρ)(cid:1) + (cid:2)tr(ρ) − tr(cid:0)
(cid:74)
(cid:75)

S

(ρ)(cid:1)(cid:3).
(cid:75)

(cid:74)

(4)

Formal methods for quantum algorithms

Page 47

Note that Inequality (4) can be seen as a probabilistic version of the following statement: if
state ρ satisﬁes predicate P, then, executing program S on input ρ, either S fails to terminate or the
resulting state

(ρ) satisﬁes predicate Q.

S

(cid:74)

(cid:75)

Table 2: Proof system for partial correctness.

(Skip Axiom)

{P} skip {P}

(Init Axiom)

{∑i|i(cid:105)q (cid:104)0|P|0(cid:105)q (cid:104)i|} q := |0(cid:105) {P}

(Unit Axiom)

{U †PU} ¯q ∗= U {P}

(Comp Rule)

{P} S1 {Q}

{Q} S2 {R}

{P} S1;S2 {R}

(If Rule)

{Pm} Sm {Q} for all m

{∑m M†

mPmMm} if (cid:3)m·M[ ¯q]=m→Sm ﬁ {Q}

(Par Loop Rule)

{P} S0 {M†

0 QM0+M†

1 PM1}

{M†

0 QM0+M†

1 PM1} while M(cid:48)[ ¯q]=1 do S0 od {Q}

(Order Rule)

P(cid:118)P(cid:48)

{P(cid:48)} S {Q(cid:48)} Q(cid:48)(cid:118)Q
{P} S {Q}

The axiom system for proving partial correctness of quantum WHILE-programs is composed
of axioms and inference rules manipulating quantum Hoare’s triples [194]. It is shown in Table 2
(cid:0)where {|i(cid:105)}q is the computational basis for quantum variable q(cid:1). Remark that each of these rules
and axioms follows the assertion method. Here we only show how to derive the most complex rule
(Par Loop Rule). The derivation of other proof rules can be done similarly.

Intuition of (Par Loop Rule). To derive (Par Loop Rule), by assertion method, we attach each
program point, say l1, l2, l3, of a WHILE-statement with an assertion, say R, P, Q, respectively:

{l1 : R} while M(cid:48)[ ¯q] = 1 do {l2 : P} S od {l3 : Q}

Fix the input ρ at the program point l1 satisfying the assertion R. By semantics of a WHILE
1 of the input will go to the loop body through the
0 will leave the while

loop, after the measurement M(cid:48), one part M1ρM†
program point l2 where the assertion P will be satisﬁed; the other part M0ρM†
loop through the program point l3 in which the assertion Q will be satisﬁed. Hence:

tr(Rρ) ≤ tr(cid:0)Q(M0ρM†

0 )(cid:1) + tr(cid:0)P(M1ρM†

1 )(cid:1)

Due to the arbitrariness of ρ, by properties of the trace function and L¨owner order, we have that
R (cid:118) M†
1 PM1 and lifting the above reasoning
process into an inference rule, (Par Loop Rule) follows.

1 PM1. Then, by weakening R to M†

0 QM0 + M†

0 QM0 + M†

The following example illustrates how to derive a partially correct quantum Hoare triple using

the axioms and inference rules presented above.

Example 7.2 (Speciﬁcation and correctness proof for the |β00(cid:105) state construction program). Recall
from Example 7.1 the deﬁnition of quantum program β00:

β00 (cid:44) p := |0(cid:105); q := |0(cid:105); p ∗= H; (p, q) ∗= CNOT

Formal methods for quantum algorithms

Page 48

To show (partial) correctness of this program, it sufﬁces to prove

{Ip ⊗ Iq} β00 {|β00(cid:105)p,q (cid:104)β00|}

(5)

This can be done as follows. By sake of space we need to decompose the derivation tree. We ﬁrst
derive speciﬁcations for the initialization instructions:

Init Axiom
{Ip ⊗ Iq} p := |0(cid:105) {|0(cid:105)p (cid:104)0| ⊗ Iq}

{|0(cid:105)p (cid:104)0| ⊗ Iq} q := |0(cid:105) {|0(cid:105)p (cid:104)0| ⊗ |0(cid:105)q (cid:104)0|}

{Ip ⊗ Iq} p := |0(cid:105); q := |0(cid:105) {|0(cid:105)p (cid:104)0| ⊗ |0(cid:105)q (cid:104)0|}

(i)

Init Axiom

Comp Rule

Then come the unitary application instructions. We set the following abbreviations for Hoare

triples:
(ii)
(iii)
They are instances of axioms and we can combine them:

:= {|0(cid:105)p (cid:104)0| ⊗ |0(cid:105)q (cid:104)0|} p ∗= H {|+(cid:105)p (cid:104)+| ⊗ |0(cid:105)q (cid:104)0|}
:= {|+(cid:105)p (cid:104)+| ⊗ |0(cid:105)q (cid:104)0|} (p, q) ∗= CNOT {|β00(cid:105)p,q (cid:104)β00|}

Init Axiom

(ii)

(iii)

Init Axiom

{|0(cid:105)p (cid:104)0| ⊗ |0(cid:105)q (cid:104)0|} p ∗= H; (p, q) ∗= CNOT {|β00(cid:105)p,q (cid:104)β00|}

(iv)

Comp Rule

Finally, the two preceding proof tree branch together via the sequential composition rule, which

achieves the derivation:

(i)

(iv)

{Ip ⊗ Iq} β00 {|β00(cid:105)p,q (cid:104)β00|}

Comp Rule

7.1.4 Implementations and Extensions

Several works have taken advantage of extended Quantum Hoare Logic, e.g. algorithmic analysis
of termination problem [127] or characterization and generation of loop invariants (cid:0)i.e. M†
0 QM0 +
1 PM1 in (Par Loop Rule)(cid:1) [198].
M†
The practical illustration of QHL can be found in Liu et al. paper

[132], containing an im-
plementation in ISABELLE/HOL together with a formalization of Grover [84] and Quantum Phase
Estimation (QPE [111]) algorithms. Nevertheless in these examples, the central veriﬁcation part is
assumed through Python libraries uses.

More recent work [131] includes full proof for a parametrized version of Grover’s search algo-

rithm. It constitutes an illustration of QHL use on a non-trivial example.

7.1.5 Other Quantum Hoare Logics

In addition to the framework introduced above, applying Hoare Logic methods to quantum processes
brought several additional developments, focusing on different aspects of quantum computations.
We introduce a few of these QHL related framework in the following paragraphs.

Formal methods for quantum algorithms

Page 49

Quantum Hoare Logic with ghost variables. One of the principal shortcuts of [194] comes from
the limitations of the speciﬁcation language. In [184], the author in particular targets the possibility
to characterize probabilistic distributions of values. His proposition introduces ghost variables in the
speciﬁcations language: a ghost variable does not occur in the program but only in its speciﬁcations.
In [184], a ghost variable is interpreted under an implicit existential quantiﬁcation. Ghost variables
enable, in particular, to explicitly refer to discarded, measured or overwritten qubits. In addition to
probability distribution deﬁnitions, it brings several features to the expressive power of the speciﬁ-
cations language, such as separability–unentanglement–of variables or the fact, for a given variable,
to hold for a classical data value.

Quantum Hoare Logic with classical variables. With similar concern, [67] extends QHL speci-
ﬁcations with classical variables. In the speciﬁcation and veriﬁcation of algorithms of practical use,
holding classical information is indeed crucial. It enables, for example, describing and specifying
an algorithm holding classical parameters or a hybrid program intertwining classical and quantum
instructions (see Section2.1.1).

Hence, the semantics relies on so-called cq-states (classical/quantum states) made of both:

• a classical variable assignment for the interpretation of classical variables;

• a density operator interpreting quantum variables.

This extension of the semantics induces an extension of the proof system, which is proved sound
and complete–with respect to partial correctness. Interestingly, the paper presents detailed speciﬁed
case studies, including Grover’s and Shor’s algorithms.

Robustness analysis
is another important line of work, initiated in [97] as a continuation of QHL.
The different solutions presented so far rely on the implicit assumption that quantum gates are ap-
plied deterministically as indicated by their matrix semantics. Still, as stated in Section 2.3.2, this
noise-free modeling is not perfectly accurate in the NISQ era.

A more realistic description of the behavior of a gate would consider several different possible
behaviors, weighed with their respective probabilities of occurrence: the intended one, expected by
the semantics, and one or several additional erroneous behaviors10.

Interestingly, in this setting, the application of a quantum gate is formally represented as a prob-
ability distribution over unitaries. Hence, a non-deterministic gate application naturally formalizes
in the formalism of super operators acting over density operators.

Then, a metrics is deﬁned for measuring the difference between the behavior of a quantum
system under a given error scheme (for each gate application, the mention of a possible erroneous
behavior together with its probability of occurrence) and its intended behavior. It is called the trace
distance and serves as an evaluation for the robustness of the implementation.

Among other case studies, the method is illustrated by evaluating a minimal quantum error

correcting scheme.

Quantum separation logic
[201] aims at simplifying quantum programs speciﬁcations. The
leading observation is that, while quantum programs often manipulate big quantum circuits, with
matrix semantics growing exponentially over their width, many quantum algorithms proceed via

10Strictly speaking, the language in 2.3.2 is limited to considering up to one possible error per gate application. But this is
without lost of generality since more sophisticated scenarios can be encoded through, eg., the replacement of gate application
intervals by potentially erroneous identity transformations.

Formal methods for quantum algorithms

Page 50

sequences of local manipulations over quantum sub-registers. The authors exhibit the examples
of Quantum Machine Learning [26] and Variational Quantum Algorithms (VQA [135]), which are
among the most promising classes of algorithms in the NISQ era (see Section 2.3.2).

To efﬁciently reason about state evolution in such implementations, a Quantum Separation Logic
is proposed, together with a dedicated proof system. This logic allows the expression of local ma-
nipulation on separated quantum registers while maintaining the state of the rest of the register.
The approach is probed with case studies from both quantum programming analysis (VQA) and
communication protocols security checks (one-time pad and secret sharing).

Quantum relational Hoare logic
[185, 19] allows to reason about how the outputs of two quan-
tum programs relate to each other given a relation between their inputs, which can be used to analyze
security of post-quantum cryptography and quantum protocols.

Quantum Hoare type theory [177] is inspired by classical Hoare type theory and extends the
Quantum IO Monad [3] by indexing it with pre- and postconditions that serve as program speciﬁ-
cations, which has the potential to be a uniﬁed system for programming, specifying, and reasoning
about quantum programs.

Quantum dynamic logic. We end up this section by mentioning a line of work that is not a strict
extension or application of Hoare Logic [94], but shares similar concerns and related solutions. Just
as QHL and its extensions, dynamic logic formalizes the evolution of a state along the execution of
a process acting over it.

Dynamic logic inherits from the modal logic apparatus where, in addition to propositional logic
connectives, modalities (cid:3) and ♦ are intriduced. Intuitively, given a formula φ , (cid:3)φ means that ϕ is
necessarily true and ♦ϕ means that ϕ is possibly true. The standard semantics, based on Kripke
models [115], helps catching this intuition. A Kripke model K is made of a set of states S holding,
each, a valuation P : S → {true, false} for a set of propositional variables P. And the modality is
interpreted through an accessibility relation R ⊆ S × S For example, given a propositional variable
p, (cid:3)p (resp. ♦p) is true in state s, written K , s |= (cid:3)p iff p (resp. K , s |= ♦p) is true if p is true in
every (resp. at least one) state s(cid:48) such that (s, s(cid:48)) ∈ R.

In dynamic logic, several modalities coexist, formalizing a set of actions. Hence, given an action
a, f ormula[a]ϕ is true iff ϕ is always true after performing action a. Actions can combine together,
for example [a; a(cid:48)]ϕ means that ϕ is always true after the successive performance of actions a and
a(cid:48).

In their Logic of Quantum Programs (LQP [14, 15]), Baltag and Smets designed a quantum
version of dynamic logic. Here, states correspond to one-dimensional subspaces of a Hilbert space
for a quantum register. Actions are of two kinds: a test encodes a measurement through the set of
projection transitions corresponding to the different possible outcomes (for example, given formu-
las ϕ and ψ, ϕ?ψ is satisﬁed in the state of evaluation if and only if any state satisfying ϕ after
measurement–any successful test for ϕ–also satisﬁes ψ), and proper actions deterministically en-
code unitary state transformations). In [14], the framework is illustrated by a correction proof for
the teleportation and quantum secret sharing protocols. Baltag and Smets link their work to similar
quantum logics as in [34].

Note that to treat measurement, LQP formalizes informations about the set of states that are pos-
sibly reachable, but the language does not hold any notion of probability. This shortcut is overcome
in [13], where the authors introduce a probabilistic test modality characterizing, for any formula ϕ
and rational x ∈ [0, 1[, that a test for ϕ has probability at least x to succeed from the evaluation state.

Formal methods for quantum algorithms

Page 51

In [13], the authors also provide a decidability proof for their setting and illustrate its expressive
power by formally specifying the Grover’s search algorithm and a leader election protocol. Further
work in the community has used this probabilistic logic setting for the veriﬁcation of the BB84
Quantum Key Distribution algorithm [24].

7.2 QBRICKS

QBRICKS [38] is a recently proposed circuit description language together with a deductive veri-
ﬁcation framework. It enables automated proof support for program speciﬁcations, reducing the
required human effort for the development of veriﬁed programs.

QBRICKS object language (QBRICKS-DSL) consists in a minimal functional language with
features for the design of circuit families. Similarly to the formal contract style of algorithm de-
scriptions (see Section 2.2.2), QBRICKS functions are written with explicit pre-and postconditions,
specifying their complexity and the parametrized input-output quantum data registers function they
implement. These speciﬁcations are written in a dedicated formal language, called QBRICKS-SPEC.
To support proofs, QBRICKS is given a Hoare style derivation rules system including rules for
each parametrized circuit constructor. These rules are enriched with equational theories enabling, in
particular, reasoning about measurement and probabilities.

QBRICKS is a domain-speciﬁc language, embedded in the Why3 [70] deductive veriﬁcation
framework : programs are written in ML language and annotated with speciﬁcations in QBRICKS-
DSL (pre- and postconditions, loop invariants, calls for lemmas, etc). Compiling a QBRICKS pro-
gram interprets these speciﬁcations as proof obligations. Then, a dedicated interface enables to di-
rectly access these proof obligations and either send them to a set of automatic SMT-solvers (CVC4,
Alt-Ergo, Z3, etc.), or enter some interactive proof transformation commands (additional calls for
lemmas or hypotheses, term substitutions, etc.) or even to proof assistants (Coq, ISABELLE/HOL).

7.2.1 Writing Quantum Circuits Functions in QBRICKS: QBRICKS-DSL

QBRICKS-DSL makes use of a regular inductive datatype for circuits, where the data constructors
are elementary gates, sequential and parallel composition, and ancilla creation. In particular, unlike
in e.g. Quipper or QWIRE, a quantum circuit in QBRICKS is not a function acting on qubits: it is a
simple, static object. Nonetheless, for the sake of implementing quantum circuits from the literature,
this does not restrict expressiveness as they are usually precisely represented as sequences of blocks.
The core of QBRICKS-DSL is presented in Figure 13. It is a small ﬁrst-order functional, call-
by-value language. To the elementary gates presented in Section 2.1.5, QBRICKS adds the qubit
swapping gate SWAP and the identity ID. The constructors for high-level circuit operations are se-
quential composition SEQ, parallel composition PAR and ancilla creation/termination ANC.

Expression

Data Constructor

Function

e

c

f

Declaration d

::= x | c | f (e1, . . . , en) | let (cid:104)x1, . . . , xn(cid:105) = e in e(cid:48) |

if e1 then e2 else e3 | iter f e1 e2

::= n | tt | ff | (cid:104)e1, . . . , en(cid:105) | CNOT | SWAP | ID | H | Ph(e) | Rz(e) |

ANC(e) | SEQ(e1, e2) | PAR(e1, e2)

::= fd | fc
::= let fd(x1, . . . , xn) = e

Figure 13: The syntax for QBRICKS-DSL

Formal methods for quantum algorithms

Page 52

The term constructs are limited to function calls, let-style composition, test with the ternary
construct if-then-else and simple iteration: iter f n a stands for f ( f (· · · f (a) · · · )), a succession
of n calls to f .

Even though the language does not feature measurement, it is nonetheless possible to reason
on probabilistic outputs of circuits, if we were to measure its output. This is expressed in a regu-
lar theory of real and complex numbers in the speciﬁcation language (see Section 7.2.4 below for
details).

7.2.2 Parametrized Path-Sums

To interpret circuit description functions, QBRICKS uses parametrized path-sums (pps), that is an
extension of path-sums [5] (Section 5.2 ).

In QBRICKS setting, a path-sum P is an object from an opaque type with four parameters, pre-
two integer constants pps width(P)
sented in Table 3 with their types and identiﬁer shortcuts:
(the width of the target circuit) and pps range(P) (the range, meaning that the output sum of kets
has a term for each bit vector (cid:126)y of length pps range(P)–written (cid:126)y ∈ BVp r(P)) and two functions
pps angle(P) and pps ket(P) : for any input bit vector (cid:126)x of length pps width(p) (standing for
a basis ket input to the target circuit) and for any index bit vector (cid:126)y of length pps range(p), func-
tions pps angle(P) and pps ket(P) respectively deﬁne a real scalar and a bit vector of length
pps width(p) (standing for a basis ket output to the target circuit)11.

Table 3: Pps accessors and types

Identiﬁer
pps width
pps range
pps angle
pps ket

Type
int
int
bit vector → bit vector → real
bit vector → bit vector → bit vector

Id-abbreviation
p w
p r
p a
p k

Then for any bit vector −→x of size p w(P), the expression

Ps(h, |−→x (cid:105)) =

√

1

2p r(P) ∑

−→y ∈BVp r(P)

e2·πi.p a(P)(−→x ,−→y )|p k(P)(−→x , −→y )(cid:105)p w(P)

(6)

combines these different element together to deﬁne a linear application for quantum state vectors.
Function Ps is extended by linearity to any ket |u(cid:105) of length p w(p)12.

A path-sum P is said to correctly interpret a given circuit C (written (C (cid:46) P)) if and only if C has
width n = pps width(P) and for any bit vector(cid:126)x of length n, Mat(C) · |(cid:126)x(cid:105) = Ps(P, |(cid:126)x(cid:105)). The relation
( (cid:46) ) enjoys nice composition properties along QBRICKS-DSL circuit constructors (see [38] ).

QBRICKS-SPEC generalizes path-sums by introducing Parametrized path-sums (pps). A pps is
a function that inputs a set of parameters and outputs a path-sum. Then, it can be seen as a family
of path-sums (one for each possible value of its parameters) describing the effects of the different
members in a family of quantum circuits. Hence, it is well-ﬁtted for the speciﬁcation of parametrized
algorithms such as Shor order ﬁnding (Shor-OF see Figure 4).

11In the rest of this section, type bit vector corresponds to bit vectors (cid:126)x. They are encoded in an abstract type that
provides a positive integer length((cid:126)x) (the length of the vector) and a value function get bv((cid:126)x) : int → int. For any
integer i, we commonly abbreviate get bv((cid:126)x)i as (cid:126)xi; if i ∈
(that is, if i is actually in the range of the bit
vector) then it is such that 0 ≤(cid:126)xi < 2.

0, length((cid:126)x)
(cid:74)
(cid:74)

12That is, to any linear combination of basis kets |(cid:126)x(cid:105) of length p w(p).

Formal methods for quantum algorithms

Page 53

The main strength of pps semantics, with regards to formal veriﬁcation, is that each of the path-
sum parametrized accessors (see Table 3) combines compositionally along with circuit constructors.
Hence, it enables reasoning about parametrized quantum circuits and their semantics without
manipulating sum terms or other higher-order objects. Thanks to this tool, the automatic generation
of proof obligations for QBRICKS speciﬁcations results in only ﬁrst-order formulas, enabling a high
level of automation when sent to SMT-solvers.

7.2.3 From Quantum Circuits to Path-Sums

The speciﬁcation language for QBRICKS is a ﬁrst-order predicate language, equipped with various
equational theories. For any quantum circuit family C, QBRICKS-DSL enables to identify a pps
circ to pps(C). Each of its parametrized accessors is deﬁned inductively upon the structure of C
and it is proved that (C (cid:46) circ to pps(C)), for any instance of circuit. These accessors are listed
and given abbreviations in Table 4.

Table 4: Function circ to pps and accessors

Accessor
pps width(circ to pps(C))
pps range(circ to pps(C))
pps angle(circ to pps(C))
pps ket(circ to pps(C))

Abbreviation
C width(C)
C range(C)
C angle(C, −, −)
C ket(C, −, −)

7.2.4 Probabilistic Reasoning

QBRICKS-DSL does not contain any constructor for the measurement of quantum registers. Never-
theless, QBRICKS-SPEC provides reasoning tools about it. In particular, function

proba measure : circ × ket × int → real

inputs a circuit C, a quantum data register |v(cid:105)n and an index j ∈
. It outputs the probability,
for one measuring the quantum register resulting from applying circuit C to |v(cid:105), to get the bit vector
representing integer j as a result. Function proba measure is deﬁned, for any input ket |u(cid:105) of
length pps width(C), by application of the Born rule (see Section 2.1.2), as

(cid:74)

(cid:74)

0, 2n

proba measure(C, |i(cid:105)n, j) = |(cid:0)Ps(circ to pps, |i(cid:105)n)(cid:0) j)|2.

QBRICKS-SPEC also provides similar reasoning ghost functions for discussing the effect of par-

tial measurement over quantum sub-registers.

7.2.5 Veriﬁed Properties

The QBRICKS framework aims at providing tools for writing and verifying the standard format of
quantum algorithm speciﬁcations as they appear in algorithms (see, e.g., Figure 4): to perform a
given computation task with a given amount of resources. Hence, as illustrated above, QBRICKS-
SPEC is designed for the formalization of both:

• parametrized input/output relations for families of circuits. For a family of circuits, they
typically consist in characterizing their parametrized output ket vector. Thanks to function

Formal methods for quantum algorithms

Page 54

proba measure, QBRICKS enables to identify the probability to get a given result after mea-
surement and derivated probability reasoning (such as bounding the parametrized probability
of success of a computation, wrt a pre-deﬁned success condition). Proof support for these
speciﬁcations is processed through the pps formalism,

• complexity speciﬁcations: QBRICKS enables to specify the parametrized width, number of

required ancilla qubits and number of elementary gates of a circuit family.

Example 7.3 (Pps speciﬁcations for the Bell generating circuit). For example, a speciﬁcation for
the Bell generating circuit can be written using accessors of pps circ to pps (Bell-circuit), as
below

Γ, −→x , −→y : bit vector, j : int (cid:96)

{ bv length((cid:126)x) = 2 ∧ bv length((cid:126)y) = 1 ∧ j ∈

(cid:74)
−−−−−−−−−−→
C width(result) = 2 ∧ C ket(result, −→x , −→y ) =
x(0) · (1 − x(1)) ∧
C range(result) = 1 ∧ C angle(result−→x , −→y ) = x(0) ∗ y(0)
∧
width(result) = 2 ∧ size(result) = 2 ∧ ancillas(result) = 0

Bell-circuit











}

0, 2
(cid:74)

This Hoare style notation, {Pre}p{Post} states that whenever Pre is satisﬁed, then running p
ensures that Post is satisﬁed. Formula Post uses result as a variable standing for program p. The
speciﬁcation uses free–ghost–bit vectors variables (cid:126)x and (cid:126)y and integer variable j. It requires (cid:126)x and (cid:126)y
to have respective lengths 2 and 1 and j to be in
0, 2
. Given these preconditions, the speciﬁcations
ensures that the angle C angle outputs −→x 0 ∗ −→y 0 for inputs (cid:126)x and (cid:126)y and the ket function C ket
(cid:74)
(cid:74)
outputs −→x 0 · (1 − −→x 1) for inputs (cid:126)x,(cid:126)y and j. Then, one easily veriﬁes that, applying equation 6 on
−−→
a · b of length 2 results in the corresponding output |βab(cid:105), formally:
each bit-vector
Ps(cid:0)circ to pps(Bell-circuit), |ab(cid:105)(cid:1) = Mat(Bell-circuit) · |ab(cid:105))

So the postcondition, by use of C width, C range, C angle and C ket, enables a complete char-
acterization of the input/output function performed by the Bell circuit. In addition, the speciﬁcation
brings some complexity related postcondition: the circuit has width 2 and size 2 (i.e., length of the
required quantum register and number of performed elementary operations), and does not use any
additional ancilla qubit.

7.2.6 Deduction and Proof Support

Proof support in QBRICKS strongly relies on the compositional structure of quantum circuits, en-
abling compositional reasoning on both pps and complexity features. As an example, in Figure 14
we give some of the rules used for the characterization of circuits size. Gates ID and SWAP are con-
sidered as free, so they count for null. The other elementary gates have size 1, both sequence and
parallel compositions sum the size of their components and ancilla creation/termination does not
affect circuit size.

Similar deduction rules are deﬁned for circuit width, number of ancilla qubits and pps accessors.

We do not introduce them here for sake of concision but we refer the desirous reader to [38].

7.2.7 Implementation and Case Studies

QBRICKS enabled to implement, specify and formalize parametrized versions for Quantum Fourier
Transform, Grover search algorithm, QPE, Shor order ﬁnding, etc. The main speciﬁcity of these
QBRICKS implementations is to hold a high level of proof support automation. This is largely due
to the reduction of proof obligations to ﬁrst-order logic predicates by use of pps characterizations.

Formal methods for quantum algorithms

Page 55

C ∈ {ID,SWAP}
width(C) = 0

(Id-SWAP-size)

C ∈ {H, Ph(n), Rz(n)}
size(C) = 1

(H-Ph-Rz-size)

Γ (cid:96) size(C1) = n1

Γ (cid:96) size(C2) = n2
Γ (cid:96) size(SEQ(C1,C2)) = n1 + n2

Γ (cid:96) width(C1) = width(C2)
(seq-size)

Γ (cid:96) size(C1) = n1

Γ (cid:96) size(C2) = n2 (par-size)

Γ (cid:96) size(PAR(C1,C2)) = n1 + n2

Γ (cid:96) size(C) = n
Γ (cid:96) size(ANC(C)) = n

(anc-size)

Figure 14: Deduction rules for QBRICKS: size (number of gates)

7.3 SQIR

The SQIR language [91, 90] is the representation language used by the VOQC optimizer (see Sec-
tion 5.4). On its own, it also constitutes a solution for formally proved correct quantum programs.
It is developed concurrently with QBRICKS and holds similar concerns: basically, to reduce the ex-
pressivity of programming languages such as Quipper and QWIRE so as to (1) still enable the whole
implementation of emblematic algorithms (2) enable formal proof of speciﬁcations.

The development of SQIR followed that of QWIRE (see Section 6.1.3) when the authors observed
the difﬁculty to hold formal veriﬁcation, mainly linked to the management of memory wires. Hence
SQIR and QWIRE have overlapping author and developer ship, they are both deeply embedded in the
Coq proof assistant and they share the same mathematical libraries for, e.g., matrices and complex
numbers. Schematically, compared to QWIRE, SQIR has a reduced expressivity (disabling, eg., the
identiﬁcation of qubit held values), making tractable the formal veriﬁcation of functional program
properties.

7.3.1 Programming Language

Just as QBRICKS, the programming part of SQIR is reduced to the minimum enabling implemen-
tation of main quantum programming features. It is two-layered: the unitary part corresponds to
the design of unitary circuits and a generalized circuit layer adds branching measurement and ket
initialization.

In SQIR, quantum circuits have type N → Set, with a positive integer parameter corresponding to
their width. Quantum memory wires are identiﬁed by integer indexes, bounded by a global register
size parameter d. Then, the type for unitary operators in SQIR (ucom) features the application of a
circuit to a quantum register with d wires. It is deﬁned inductively as follows.

Inductive ucom (U: N → Set) (d: N) :
| useq : ucom U d → ucom U d → ucom U d
| uapp1 : U 1 → N → ucom U d
| uapp2 : U 2 → N → N → ucom U d
| uapp3 : U 3 → N → N → N → ucom U d

Set :=

Formal methods for quantum algorithms

Page 56

This deﬁnition holds two kinds of operations:

• the sequential composition, useq, which inputs two circuits and outputs their sequential com-

position,

• the application of an elementary gates to (a) given wire(s), depending on the width of this
gate. There are three different versions of this operations, for gates of width 1, 2 or 3, named
respectively uapp1, uapp2 and uapp3. As an example, uapp1 inputs a gate U of width 1 and
a parameter i. It outputs the result of applying U on wire i in a register of size d13.

Then, SQIR provides a generalized circuit building layer, enabling the sequential composition of
unitary commands, their initialization and branching measurement. Again, a circuit is an object com
of type N → Set applied on a register of speciﬁed size d. It is deﬁned, inductively, as follows.

ucom U d → com U d → ucom U d

Inductive com (U: N → Set) (d: N) :
| uc :
| skip : com U d
| meas : N → com U d → com U d → com U d
com U d → com U d → com U d
| seq :

Set :=

A generalized circuit is built as either the lifting uc of a circuit into a generalized circuit, the
empty skip operation, the branching measurement meas (with inputs a wire identiﬁer for a qubit
to measure and two generalized circuits to execute, depending on the measurement result) and the
sequence seq of two different generalized circuits.

7.3.2 Matrix Semantics and Speciﬁcations

The semantics for SQIR programs is based on the standard matrix apparatus. For the unitary frag-
ment, it uses the matrix semantics presented in Section 2.1.5. It is extended for generalized circuits
by density operators semantics, similarly as in Section 7.1.

In its present state of development, SQIR enables to specify functional properties, describing the

input-output relation, similarly to the one for QBRICKS introduced in Section 7.2.5

7.3.3 Implementation and Case Studies

SQIR is implemented as an embedded DSL into the Coq proof assistant. It was illustrated with
speciﬁed and proved parametrized implementations of Simon’s algorithm, QPE and Grover’s Search
Algorithm.

7.3.4 Comparison Between QBRICKS and SQIR

QBRICKS and SQIR are being developed concurrently, with very similar objectives. In particular
they both trade-off between offering user-friendly programming features and reducing the language
expressivity to the minimal, to enable functional formal veriﬁcation. The solutions they provide
share many common points. We discuss their main design differences.

• SQIR elementary operations consist in applying quantum gates on given wires of a quantum
register, whereas QBRICKS proceeds by assembling quantum gates together into a quantum

13Note that, for this construction to make sense, the parameter i should not be greater than d. This condition is encoded

by the semantics of SQIR.

Formal methods for quantum algorithms

Page 57

circuit, just as bricks of a wall. Both views are inter-simulable: QBRICKS provides a macro
place with integer parameters specifying the wire identiﬁer a given sub-circuit should be
applied to and the size of the overall circuit (corresponding to the size of the available quantum
register). This macro is built by the parallel combination of its sub-circuit arguments with the
appropriate number of occurrences of ID gate. It is of similar use as SQIR function uapp. On
the other hand, QBRICKS gates assemblage is trivially simulable through SQIR uapp;

• On the other hand, SQIR provides a generalized circuit building layer, including measurement
and classical control. Nevertheless, this upper layer is formalized through density operators,
which are cumbersome objects for formal reasoning. So far, this part of the language only
received illustrations with toy examples, such as superdense coding or quantum teleporta-
tion. In more involved implementations (such as QPE or Grover), SQIR authors followed a
speciﬁcation and proof strategy similar to that of QBRICKS: by reasoning on the quantum
data outputs of circuits, specifying over the probability distribution of result if a measurement
were performed. Hence, designing a generalized circuit building language semantics probed
against actual implementations of real usage algorithms is still an open challenge;

• As introduced in Section 4.2.2, complexity properties of circuits constitute a fundamental
aspect of quantum certiﬁcation, decisive with regards to both the physical reliability of a
computation and the quantum advantage it may provide. In the present state of development,
SQIR does not offer a solution for this type of speciﬁcations. Still, this could be merely
implemented in SQIR as additional functionality.

7.4 Conclusion about Formal Veriﬁcation of Quantum Programs

In Table 5 we sum up the main concrete case study realizations of formally veriﬁed quantum al-
gorithms: instances of Grover algorithm from QBRICKS, SQIR and QHL, Deutsch-Jozsa and QPE
instances from QBRICKS and SQIR, and Shor-OF implementation from QBRICKS. For each of these
implementations, we give the length of the code (column LoC) and a measure of the human proof
effort required for the speciﬁcation proofs. It was obtained by adding the length of the program
speciﬁcations (Spec stands for the number of lines of speciﬁcations and intermediary lemmas) and
the number of proof commands that were required to prove these speciﬁcations (column Cmd).

Table 5: Compared implementations of formally veriﬁed quantum algorithms

QBRICKS[38]

SQIR [90, 91]

QHL[131]

DJ
Grover
QPE
Shor-OF

LoC
11
39
23
132

Spec+Cmd
85
279
246
1212

LoC
10
15
40

Spec+Cmd
261
926
812

LoC

Spec+Cmd

90

2975

To the best of our knowledge Table 5 is comprehensive regarding parametrized formally proved
quantum algorithm 14. Let us stress out how young the ﬁeld is (in complement to the reduced

14An additional formalization of Deutsch Jozsa algorithm is presented by Bordg et al. [30]. We do not include it in Table 5
since it is not generated by a programming language but directly led as an algebraic proof. The total length of the proof is over
1 700 lines. Additionally, the online SQIR repository contains a Shor algorithm folder, but to the best of our knowledge, it was
never explicitly presented nor described. It seems, by the way, hardly comparable with the QBRICKS implementation since it
focuses on different aspects by bringing additional classical post-processing functions but lacking the oracle implementation.

Formal methods for quantum algorithms

Page 58

number of concrete realizations, note that none of them is dated earlier than 2019). Nevertheless, it
has already brought promising results.

One of the main challenges for formal veriﬁcation is to reduce the human proof effort that is
required for the certiﬁcation of programs. As Table 5 shows, comparing this effort to the length of
effective programs, QBRICKS offers a quite stable ratio (cid:39) 10. In a quite regular way, SQIR adds
a (cid:39) 3.5 factor to this ratio and QHL, for the case of Grover algorithm, requires (cid:39) 10 times more
human effort 15

8 Discussion and Bibliographical Notes

We end up this survey by providing some additional references for usage of formal methods in
quantum information and quantum computing.

8.1 Deductive Veriﬁcation

Deductive veriﬁcation appears to be the most promising direction for the development of formal
methods in quantum computing. In particular, it is particularly adequate for the formal veriﬁcation
of functional speciﬁcations, which is crucial for quantum programming and prone to play, there, a
role similar to that of testing and debugging in classical computing (see Section 4.1). It is worth
noting that, currently, all existing formally veriﬁed quantum algorithms descriptions [131] or imple-
mentations [38, 91] are based either on deductive veriﬁcation or interactive proofs.

8.2 Model Checking

Attempts for functional veriﬁcation of quantum algorithm with model checking techniques were
also led before these developments [78, 197, 196]. They enabled to verify toy examples of quantum
processes in a completely automated way. Nevertheless, this direction is limited by its high scale
sensitivity, which is speciﬁcally problematic for quantum programs, since they are designed to tackle
large problems instances.

8.3 Type Checking

Apart from functional speciﬁcation, specialized type systems for quantum programming languages
also facilitate programming and debugging. In Section 4.1 we introduced the veriﬁcation of struc-
tural constraints and the non-duplicability of quantum information. Type checking may also have
further use in quantum computing.

Recently, the SILQ language was proposed. It is based on a linear type system which, upon other
features, enables to verify, for any quantum circuit, whether it can be uncomputed, a computation
feature required at many stages of quantum implementations. Based on this type system, SILQ
enables to automatically generate the uncomputation steps of circuits. This partial automation of
the development lowers the expertise requirements for developers and the length of programs with
regards to languages such as Q# or Quipper.

15Note that the QHL implementation of Grover algorithm concerns a restricted case, with regards to the two others ﬁguring
in Table 5. Furthermore, it does not contain the gate-to-gate circuit building but uses large circuit portions as primitives
instead. Therefore, factor (cid:39) 10 is actually an underestimation.

Formal methods for quantum algorithms

Page 59

8.4 Runtime assertion Checking

First, recall from Section 1 that proving quantum programs is mainly meant to replace the standard
classical debugging method of testing and assertion checking. Apart from the development of formal
proofs as an alternative, efforts are led to adapt this classical strategy to the quantum case. There,
we still decorate programs with formal speciﬁcations (called assertions in this context) describing
the evolution of the system state through an execution. But instead of mathematical proofs, these
assertions are probed by statistical testing over program fragments. The challenges faced by such
methods are mainly twofold:

Destructive measurement : memory reading destructs the superposition of a quantum state, there-
fore one cannot continue the execution after checking. Hence, assertion checking can be
applied only to fragments of an execution.

Non-determinism : what we aim to check is a superposition of states, which induces a probabil-
ity distribution of outcomes when a measurement is performed. Then, checking an assertion
requires a number of testing runs large enough to build up a representative statistical distribu-
tion.

To overcome these difﬁculties, a ﬁrst strategy is to reduce the speciﬁcations so as to express only
properties that may be handled by assertion checking. Huang and Martonosi propose a “runtime-
monitoring like” veriﬁcation method for quantum circuits [96]. The annotation language is reduced
so as to specify, for a quantum register, to be either in a classical state, in a superposition or entan-
gled, without any concern about further description of the state.

More recently, Li et al. [126] developed an assertion-checking based method for the veriﬁcation
of ﬁne quantum registers states properties, including functional descriptions of circuit behaviors.
This method is based on:

• an assertion language, based on QHL projections (see Section 7.1), enabling functional spe-

ciﬁcations about computations at stake;

• the use and formalization of gentle measurements: quantum registers are not measured in the
usual computation basis, but in a basis containing an output that is very close to the expected
state;

• an appropriate formalization of the notion of distance between quantum states, enabling veri-
ﬁcation in terms of conﬁdence interval between the current state of the system and its expected
value.

Hence, gentle measurement enables to test executions over full functional state speciﬁcations. In
addition to bringing expressivity to the speciﬁcations, it lowers the undesired effects of destructive
measurements: since a gentle measurement operator contains an eigenstate that is an approximation
of the expected quantum state, in most cases the measurement effect on the system state can be
considered negligible and the execution can be pursued. Furthermore, the test result probability
distribution is centered on a speciﬁc value. Therefore, a much-reduced set of runs bring valuable
statistical conclusions.

However, veriﬁcation following this strategy only holds for a particular instance of a circuit, in-
stead of a family of quantum circuits with unassigned parameters as in propositions from Section 7.
Furthermore, in the general case, gentle measurements are implemented by applying (1) a unitary U
uncomputing the system state into a ket of the computational basis (2) a measurement in the com-
putational basis (3) unitary U †, to recover the initial state. Then, assertion checking inputs unitaries

Formal methods for quantum algorithms

Page 60

U and U † that are themselves prone to error. More precisely, to test against the exact expected
value of the state, operator U † should be equivalent to the computation under test. Practically, gentle
measurements approximate the state under test. This enables a simpliﬁcation of the measurement
operator, at the cost of the robustness of the procedure.

8.5 Veriﬁcation of Quantum Communication Protocols

Another challenge for formal methods is the veriﬁcation of quantum information processes concerns
quantum protocols.

Quantum key distribution protocols [164, 22, 128, 134] enable secured information exchanges
between two parties. These protocols exploit the fact that, due to the destructive measurement,
physics laws prevent almost any 16 possibility for a potential eavesdropping in the exchange of
quantum information. In particular, several formally veriﬁed implementations of the BB84 quantum
key distribution protocol [22] have been proposed in the literature, based either on process calcu-
lus [137, 117], formalization in Coq [28] or model checking [63, 68].

Bordg et al. [30] propose a formalization of quantum information in the ISABELLE/HOL proof
assistant. They illustrate their methods through the cases of quantum teleportation and the quantum
prisoner dilemma. This work also contains a formally veriﬁed implementation of the Deutsch-Jozsa
algorithm in ISABELLE/HOL.

In a more fundamental prospect, Echenim et al. [61] provide an ISABELLE/HOL proof for the
CHSH inequalities [45]. These are probability distributions about crossed measurement results of
quantum observables. They provide a proof for the Bell theorem [21], inducing that no classical
theory could account for the entanglement phenomenon (hence that quantum physics cannot be
reduced to local classical theories).

9 Conclusion

9.1 Summary

Throughout this survey, we introduced the context, the main challenges and the most promising
results in formally veriﬁed quantum programmatic. The current state of affairs in this emerging
domain can be summed up as follows:

• Quantum computing is an emerging domain, with huge potential application ﬁelds and
promises. Progresses in the development of concrete machines are reaching the practical
relevance landmark: prototypes are getting powerful enough to overpass classical comput-
ers. Consequently, quantum software development is becoming a crucial industrial short-term
need;

• Quantum software deals with an entirely new programming paradigm. Upon its main par-
ticularities are the dual nature of information (either classical or quantum), the destructive
measurement and irreducibly probabilistic computations;

• These speciﬁcities make programming particularly non-intuitive and prone to error. Further-
more, they make it very hard to directly import usual debugging methods from the classical

16These protocols are based on the fact that, in the general case, a potential eavesdropper destructs a quantum message he
attempts to intercept, so that the parties can detect the attempt. Nevertheless, it is based on probabilities and there is always
a chance for an eavesdropper to perform only conservative measurements. The corresponding probability is bounded by rn,
with r ∈]0, 1[ and n the length of the sent message.

Formal methods for quantum algorithms

Page 61

practice (based on test and assertion checking). The technique presented in Section 8.4 might
bring some hope, but this is still so far at a very preliminary stage;

• Formal methods appear as the privileged alternative for debugging strategies. Apart from
providing solutions to the destructive measurement challenge, they have additional decisive
advantages: mainly, they provide absolute guarantee of the correction of programs, and they
hold for any instance of programs they verify;

• During the last ten years (the genesis of formal quantum programming), this new ﬁeld has
shown promising results in the different stages of software development: high-level program
designs, circuit building languages, veriﬁcation, compilation, optimization, etc.

9.2 Main Current Challenges

Although encouraging, these early successes draw the road map for rising the ﬁeld from academic
proof of concepts to practically usable programming solutions. We present the main coming chal-
lenges for this development in three categories: providing relevant integrated development solutions
for the NISQ era, offering practical wide spreadable user experience and developing a full-ﬂedged
formally veriﬁed quantum compilation toolchain.

Provide relevant integrated development solutions for the NISQ era. So far, quantum for-
mal veriﬁcation mainly proved its relevance by offering solutions for the unitary core of quantum
computations. As a matter of fact, illustrations and concrete implementations using these tech-
niques primarily treated historical emblematic algorithms such as Shor [174], QPE [111] or Grover
search [84]. The classical treatment in these algorithms can be completely decoupled from their
quantum core.

However, the ﬁrst generation of quantum computing machine (the NISQ era, see Section 2.3.2)
hints towards a radically distinct mode of operation. NISQ machines will have limited, noisy re-
sources. A major consequence is that these quantum processors are too small to support the error
correction mechanisms required for Shor’s and Grover’s algorithms. Such NISQ processors aim
instead at different kinds of algorithms: hybrid algorithms such as variational algorithms [135]. Hy-
brid algorithms tightly mix quantum and classical data treatments: one cannot decouple the quantum
part of the algorithm from its classical part.

Adapting the quantum formal methods to the NISQ setting to support hybrid quantum/classical

computation is a challenge and an active current research avenue.

Offer practical wide spreadable user experience: formalism, language design, automation.
In the present state of development, programming languages enabling formal veriﬁcation usually
sacriﬁce their expressivity to formal reasoning. In particular, all the solutions that have been probed
against actual parametric quantum algorithms fail to satisfy essential elements of the requirements
listed in Section 6.1.2 for scalable quantum programming languages: in addition to classical pro-
cessing mentioned above, they cannot manipulate quantum registers and wire references. Veriﬁed
programming should address these limitations.

Another issue, while concerning any method of quantum programming, is especially critical in
the case of formally veriﬁed programming. It concerns the level of qualiﬁcations required from
developers. The interpretation of quantum computations indeed requires unusual and non-intuitive
mathematical formalism (including Kronecker products, complex phase amplitudes, probabilistic
reasoning, etc). While the need for qualiﬁed programmers is prone to grow rapidly in the coming

Formal methods for quantum algorithms

Page 62

years, integrating formal veriﬁcation should come with the development of user-friendly speciﬁca-
tion languages and highly automated mathematical reasoning engines.

Formally veriﬁed quantum compilation toolchain.
In addition to the preceding considerations,
in its early academic ages, quantum formal veriﬁcation focused on idealized representations of quan-
tum circuits, directly extracted from algorithm descriptions. As introduced in Section 2.3.2, these
logical qubits are merely abstract models for actual computations to be run. A major addition that
is left for future works in quantum formal veriﬁcation is error correction, with formal veriﬁcation
that the state of the system preserves the functional correctness of computations (assuming a given
error model, and possibly with probabilistic speciﬁcations). Presented in Section 5.4, VOQC is a
ﬁrst step towards this goal.

Another future direction concerns integration in a widespread classical development environ-
ment. Recall from Section 6.1.3 that many widespread quantum programming languages beneﬁt
from embeddings in usual programming languages–such as Python. Today most formal veriﬁcation
solutions are embedded in a more academic functional development environment (such as Haskell,
Ocaml, proof assistants or deductive veriﬁcation environments). Interfaces should be developed to
integrate formally veriﬁed quantum computations into comprehensive projects.

At the other extremity of the development stack, formal veriﬁcation should accompany the im-
plementation of compiled programs on concrete machines. This induces veriﬁed solutions for the
qubit mapping problem and gate simulation (see Section 2.3.3), depending on the particular target
material and its proper constraints.

Acknowledgments

This work was supported in part by the French National Research Agency (ANR) under the research
project SoftQPRO ANR-17-CE25-0009-02, by the DGE of the French Ministry of Industry under
the research project PIA-GDN/QuantEx P163746-484124, by the STIC-AmSud project Qapla’ 21-
SITC-10 and by the Carnot project Qstack. We thank the anonymous reviewers for helpful comments
on earlier drafts of the manuscript.

References

[1] Scott Aaronson and Alex Arkhipov. The computational complexity of linear optics. In Pro-
ceedings of the forty-third annual ACM symposium on Theory of computing, pages 333–342,
2011.

[2] Samson Abramsky and Bob Coecke. Categorical quantum mechanics. In Handbook of Quan-

tum Logic and Quantum Structures, pages 261–323. Elsevier, 2009.

[3] Thorsten Altenkirch and Alexander S Green. The quantum IO monad. Semantic Techniques

in Quantum Computation, pages 173–205, 2010.

[4] Matthew Amy. Formal Methods in Quantum Circuit Design. PhD thesis, University of Wa-

terloo, Ontario, Canada, 2019.

[5] Matthew Amy. Towards large-scale functional veriﬁcation of universal quantum circuits. In
Peter Selinger and Giulio Chiribella, editors, Proceedings 15th International Conference on

Formal methods for quantum algorithms

Page 63

Quantum Physics and Logic, QPL 2018, volume 287 of Electronic Proceedings in Theoretical
Computer Science, pages 1–21, Halifax, Canada, 2019. EPTCS.

[6] Matthew Amy, Jianxin Chen, and Neil J. Ross. A ﬁnite presentation of CNOT-dihedral opera-
tors. In Bob Coecke and Aleks Kissinger, editors, Proceedings 14th International Conference
on Quantum Physics and Logic, Nijmegen, The Netherlands, 3-7 July 2017, volume 266 of
Electronic Proceedings in Theoretical Computer Science, pages 84–97, 2018.

[7] Matthew Amy, Dmitri Maslov, and Michele Mosca. Polynomial-time T-depth optimization of
Clifford+T circuits via matroid partitioning. IEEE Transactions on Computer-Aided Design
of Integrated Circuits and Systems, 33(10):1476–1489, 2014.

[8] Krzysztof R. Apt and Ernst-R¨udiger Olderog. Fifty years of Hoare’s logic. Formal Aspects

Comput., 31(6):751–807, 2019.

[9] Frank Arute, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C. Bardin, Rami Barends,
Rupak Biswas, Sergio Boixo, Fernando G. S. L. Brandao, David A. Buell, et al. Quantum
supremacy using a programmable superconducting processor. Nature, 574(7779):505–510,
2019.

[10] Miriam Backens. The ZX-calculus is complete for stabilizer quantum mechanics. In New

Journal of Physics, volume 16, page 093021. IOP Publishing, Sep 2014.

[11] Miriam Backens, Hector Miller-Bakewell, Giovanni de Felice, Leo Lobski, and John van de

Wetering. There and back again: A circuit extraction tale. Quantum, 5:421, 2021.

[12] Thomas Ball, Byron Cook, Vladimir Levin, and Sriram K. Rajamani. Slam and static driver
In Integrated Formal

veriﬁer : Technology transfer of formal methods inside microsoft.
Methods, 4th International Conference, IFM 2004. Springer, 2004.

[13] Alexandru Baltag, Jort Bergfeld, Kohei Kishida, Joshua Sack, Sonja Smets, and Shengyang
Zhong. Plqp & company: decidable logics for quantum algorithms. International Journal of
Theoretical Physics, 53(10):3628–3647, 2014.

[14] Alexandru Baltag and Sonja Smets. LQP: the dynamic logic of quantum information. Ma-

thematical Structures in Computer Science, 16(3):491–525, 2006.

[15] Alexandru Baltag and Sonja Smets. The logic of quantum programs. CoRR, abs/2109.06792,

2021.

[16] Henk P. Barendregt. The Lambda-Calculus, its Syntax and Semantics, volume 103 of Studies

in Logic and the Foundation of Mathematics. North Holland, second edition, 1984.

[17] Mike Barnett, Manuel F¨ahndrich, K. Rustan M. Leino, Peter M¨uller, Wolfram Schulte, and
the SPEC# experience. Commun. ACM,

Herman Venter. Speciﬁcation and veriﬁcation:
54(6):81–91, 2011.

[18] Clark Barrett and Cesare Tinelli. Satisﬁability modulo theories.

In Handbook of model

checking, pages 305–343. Springer, 2018.

[19] Gilles Barthe, Justin Hsu, Mingsheng Ying, Nengkun Yu, and Li Zhou. Relational proofs for

quantum programs. Proc. ACM Program. Lang., 4(POPL):21:1–21:29, 2020.

Formal methods for quantum algorithms

Page 64

[20] Patrick Behm, Paul Benoit, Alain Faivre, and Jean-Marc Meynadier. M´et´eor: A successful
In In Proceedings of the World Congress on Formal

application of B in a large project.
Methods in the Development of Computing Systems (FM’99). Springer, 1999.

[21] John S Bell. On the Einstein Podolsky Rosen paradox. Physics Physique Fizika, 1(3):195–

200, 1964.

[22] C. H. Bennett and G. Brassard. Quantum cryptography: Public key distribution and coin
tossing. In Proceedings of IEEE International Conference on Computers, Systems and Signal
Processing, pages 175–179, Bengalore, India, 1984.

[23] Nick Benton. A mixed linear and non-linear logic: Proofs, terms and models (extended
abstract). In Leszek Pacholski and Jerzy Tiuryn, editors, Computer Science Logic, Eighth
International Workshop, CSL’94, Selected Papers, volume 933 of Lecture Notes in Computer
Science, pages 121–135, 1994.

[24] Jort Martinus Bergfeld and Joshua Sack. Deriving the correctness of quantum protocols in
the probabilistic logic for quantum programs. Soft Comput., 21(6):1421–1441, 2017.

[25] Yves Bertot and Pierre Cast´eran.

Interactive theorem proving and program development:
Coq’Art: the calculus of inductive constructions. Springer Science & Business Media, 2013.

[26] Jacob Biamonte, Peter Wittek, Nicola Pancotti, Patrick Rebentrost, Nathan Wiebe, and Seth

Lloyd. Quantum machine learning. Nature, 549(7671):195, 2017.

[27] Benjamin Bichsel, Maximilian Baader, Timon Gehr, and Martin T. Vechev. Silq: a high-level
quantum language with safe uncomputation and intuitive semantics. In Alastair F. Donaldson
and Emina Torlak, editors, Proceedings of the 41st ACM SIGPLAN International Conference
on Programming Language Design and Implementation, PLDI 2020, London, UK, June 15-
20, 2020, pages 286–300. ACM, 2020.

[28] Jaap Boender, Florian Kamm¨uller, and Rajagopal Nagarajan. Formalization of quantum pro-
tocols using Coq. In Chris Heunen, Peter Selinger, and Jamie Vicary, editors, Proceedings of
the 12th International Workshop on Quantum Physics and Logic (QPL 2015), volume 195 of
Electronic Proceedings in Theoretical Computer Science, pages 71–83, Oxford, UK, 2015.
EPTCS.

[29] Adam D Bookatz. QMA-complete problems. Quantum Information & Computation,

14(5&6):361–383, 2014.

[30] Anthony Bordg, Hanna Lachnitt, and Yijun He. Certiﬁed quantum computation in Is-

abelle/HOL. Journal of Automated Reasoning, 65(5):691–709, 2021.

[31] E. Bounimova, P. Godefroid, , and D. Molnar. Billions and billions of constraints : Whitebox
fuzz testing in production. In 35th International Conference on Software Engineering (ICSE),
pages 122–131. IEEE/ACM, 2013.

[32] Hans J. Briegel, Dan E. Browne, Wolfgang D¨ur, Robert Raußendorf, and Maarten Van den
Nest. Measurement-based quantum computation. Nature Physics, 5(1):19–26, January 2009.

[33] Daniel E Browne, Elham Kasheﬁ, Mehdi Mhalla, and Simon Perdrix. Generalized ﬂow
and determinism in measurement-based quantum computation. New Journal of Physics,
9(8):250–250, aug 2007.

Formal methods for quantum algorithms

Page 65

[34] Olivier Brunet and Philippe Jorrand. Dynamic quantum logic for quantum programs. Inter-

national Journal of Quantum Information, 2(01):45–54, 2004.

[35] Cristian Cadar and Koushik Sen. Symbolic execution for software testing: three decades later.

Commun. ACM, 56(2):82–90, 2013.

[36] Titouan Carette, Emmanuel Jeandel, Simon Perdrix, and Renaud Vilmart. Completeness
of Graphical Languages for Mixed States Quantum Mechanics.
In Christel Baier, Ioannis
Chatzigiannakis, Paola Flocchini, and Stefano Leonardi, editors, 46th International Collo-
quium on Automata, Languages, and Programming (ICALP 2019), volume 132 of Leibniz
International Proceedings in Informatics (LIPIcs), pages 108:1–108:15, Dagstuhl, Germany,
2019. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik.

[37] Rohit Chadha, Paulo Mateus, and Am´ılcar Sernadas. Reasoning about imperative quantum

programs. Electronic Notes in Theoretical Computer Science, 158:19–39, 2006.

[38] Christophe Chareton, S´ebastien Bardin, Franc¸ois Bobot, Valentin Perrelle, and Benoˆıt Val-
iron. An automated deductive veriﬁcation framework for circuit-building quantum programs.
In Nobuko Yoshida, editor, Programming Languages and Systems - 30th European Sympo-
sium on Programming, ESOP 2021, Luxembourg City, Luxembourg, March 27 - April 1, 2021,
Proceedings, volume 12648 of Lecture Notes in Computer Science, pages 148–177. Springer,
2021.

[39] Lily Chen, Lily Chen, Stephen Jordan, Yi-Kai Liu, Dustin Moody, Rene Peralta, Ray Perlner,
and Daniel Smith-Tone. Report on post-quantum cryptography, volume 12. US Department
of Commerce, National Institute of Standards and Technology, 2016.

[40] John Chiaverini, Dietrich Leibfried, Tobias Schaetz, Murray D Barrett, RB Blakestad, J Brit-
ton, Wayne M Itano, Juergen D Jost, Emanuel Knill, Christopher Langer, et al. Realization
of quantum error correction. Nature, 432(7017):602–605, 2004.

[41] Cirq Developers. Cirq, July 2018. See full list of authors on Github: https://github.

com/quantumlib/Cirq/graphs/contributors.

[42] Edmund M. Clarke and E. Allen Emerson. Design and synthesis of synchronization skeletons
using branching-time temporal logic. In Logics of Programs, Workshop, LNCS 131, pages
52–71. Springer, 1981.

[43] Edmund M. Clarke, Thomas A. Henzinger, Helmut Veith, and Roderick Bloem. Handbook

of Model Checking. Springer, 2018.

[44] Edmund M. Clarke and Jeannette M. Wing. Formal methods: State of the art and future

directions. ACM Computing Surveys (CSUR), 28(4):626–643, 1996.

[45] John F Clauser, Michael A Horne, Abner Shimony, and Richard A Holt. Proposed experiment

to test local hidden-variable theories. Physical review letters, 23(15):880, 1969.

[46] Bob Coecke and Ross Duncan. Interacting quantum observables: Categorical algebra and

diagrammatics. New Journal of Physics, 13(4):043016, Apr 2011.

[47] Bob Coecke and Aleks Kissinger. Picturing quantum processes. Cambridge University Press,

Cambridge, United Kingdom, 2017.

Formal methods for quantum algorithms

Page 66

[48] Bob Coecke and Simon Perdrix. Environment and classical channels in categorical quantum

mechanics. Log. Methods Comput. Sci., 8(4), 2010.

[49] Patrick Cousot and Radhia Cousot. Abstract interpretation : A uniﬁed lattice model for static
analysis of programs by construction or approximation of ﬁxpoints. In Proceedings of the
Fourth ACM Symposium on Principles of Programming Languages (POPL), pages 238–252.
ACM, 1977.

[50] Patrick Cousot, Radhia Cousot, Jerˆome Feret, Laurent Mauborgne, Antoine Min´e, David
Monniaux, and Xavier Rival. The ASTR ´EE analyzer. In European Symposium on Program-
ming Languages and Systems, ESOP 2005. Springer, 2005.

[51] Andrew W. Cross, Lev S. Bishop, John A. Smolin, and Jay M. Gambetta. Open quantum

assembly language, 2017.

[52] Vincent Danos and Elham Kasheﬁ. Determinism in the one-way model. Phys. Rev. A,

74:052310, Nov 2006.

[53] Niel de Beaudrap, Xiaoning Bian, and Quanlong Wang. Fast and effective techniques for T-
count reduction via spider nest identities. In Steven T. Flammia, editor, 15th Conference on
the Theory of Quantum Computation, Communication and Cryptography, TQC 2020, June 9-
12, 2020, Riga, Latvia, volume 158 of LIPIcs, pages 11:1–11:23. Schloss Dagstuhl - Leibniz-
Zentrum f¨ur Informatik, 2020.

[54] Niel de Beaudrap, Ross Duncan, Dominic Horsman, and Simon Perdrix. Pauli fusion: a
computational model to realise quantum transformations from ZX terms. In QPL’19 : In-
ternational Conference on Quantum Physics and Logic, Los Angeles, United States, June
2019.

[55] Niel de Beaudrap and Dominic Horsman. The ZX calculus is a language for surface code

lattice surgery. Quantum, 4:218, January 2020.

[56] Ellie D’Hondt and Prakash Panangaden. Quantum weakest preconditions. Mathematical

Structures in Computer Science, 16(3):429–451, 2006.

[57] Alejandro D´ıaz-Caro. A lambda calculus for density matrices with classical and probabilistic
controls. In Bor-Yuh Evan Chang, editor, Proceedings of the 15th Asian Symposium on Pro-
gramming Languages and Systems (APLAS’17), volume 10695 of Lecture Notes in Computer
Science, pages 448–467, Suzhou, China, 2017. Springer.

[58] Alejandro D´ıaz-Caro and Octavio Malherbe. A concrete categorical semantics of lambda-
S. In Beniamino Accattoli and Carlos Olarte, editors, Proceedings of the 13th Workshop on
Logical and Semantic Frameworks with Applications, LSFA 2018, Fortaleza, Brazil, Septem-
ber 26-28, 2018, volume 344 of Electronic Notes in Theoretical Computer Science, pages
83–100. Elsevier, 2019.

[59] Edsger W. Dijkstra. A Discipline of Programming. Prentice-Hall, 1976.

[60] Ross Duncan, Aleks Kissinger, Simon Perdrix, and John van de Wetering. Graph-theoretic

simpliﬁcation of quantum circuits with the ZX-calculus. Quantum, 4:279, 2020.

[61] Mnacho Echenim. Quantum projective measurements and the CHSH inequality. Arch. Formal

Proofs, 2021, 2021.

Formal methods for quantum algorithms

Page 67

[62] Albert Einstein, Boris Podolsky, and Nathan Rosen. Can quantum-mechanical description of

physical reality be considered complete? Physical review, 47(10):777, 1935.

[63] Mohamed Elboukhari, Mostafa Azizi, and Abdelmalek Azizi. Veriﬁcation of quantum cry-
ptography protocols by model checking. Int. J. Network Security & Appl, 2(4):43–53, 2010.

[64] Edward Farhi, Jeffrey Goldstone, and Sam Gutmann. A quantum approximate optimization

algorithm. Technical Report MIT-CTP/4610, MIT, 2014.

[65] Edward Farhi, Jeffrey Goldstone, Sam Gutmann, Joshua Lapan, Andrew Lundgren, and
Daniel Preda. A quantum adiabatic evolution algorithm applied to random instances of an
np-complete problem. Science, 292(5516):472–475, 2001.

[66] Yuan Feng, Runyao Duan, Zhengfeng Ji, and Mingsheng Ying. Proof rules for the correctness

of quantum programs. Theoretical Computer Science, 386(1-2):151–166, 2007.

[67] Yuan Feng and Mingsheng Ying. Quantum hoare logic with classical variables. CoRR,

abs/2008.06812, 2020.

[68] Ver´onica Fern´andez, Mar´ıa-Jos´e Garc´ıa-Mart´ınez, Luis Hern´andez-Encinas, and Agust´ın
Mart´ın. Formal veriﬁcation of the security of a free-space quantum key distribution sys-
tem. In Proc. World Congr. Comput. Sci. Comput. Eng. Appl. Comput.(WORLDCOMP) Int.
Conf. Security Manag.(SAM), 2011.

[69] Richard P. Feynman. Simulating physics with computers. International Journal of Theoreti-

cal Physics, 21(6–7):467–488, 1982.

[70] Jean-Christophe Filliˆatre and Andrei Paskevich. Why3 - where programs meet provers. In
Matthias Felleisen and Philippa Gardner, editors, Proceedings of the 22nd European Sympo-
sium on Programming Languages and Systems (ESOP 2013), Held as Part of the European
Joint Conferences on Theory and Practice of Software (ETAPS 2013), volume 7792 of Lecture
Notes in Computer Science, pages 125–128, Rome, Italy, 2013. Springer.

[71] Jean-Christophe Filliˆatre. Deductive software veriﬁcation. STTT, 13(5):397–403, 2011.

[72] Michael J Fischer and Richard E Ladner. Propositional dynamic logic of regular programs.

Journal of computer and system sciences, 18(2):194–211, 1979.

[73] Melvin Fitting. First-order logic and automated theorem proving. Springer Science & Busi-

ness Media, 2012.

[74] R. W. Floyd. Assigning meanings to programs. In Mathematical Aspects of Computer Sci-
ence, Proceedings of Symposia in Applied Mathematics, pages 19–32. American Mathemati-
cal Society, 1967.

[75] Austin G. Fowler, Matteo Mariantoni, John M. Martinis, and Andrew N. Cleland. Surface
codes: Towards practical large-scale quantum computation. Phys. Rev. A, 86:032324, Sep
2012.

[76] Michael Freedman, Alexei Kitaev, Michael Larsen, and Zhenghan Wang. Topological quan-
tum computation. Bulletin of the American Mathematical Society, 40(1):31–38, 2003.

Formal methods for quantum algorithms

Page 68

[77] Peng Fu, Kohei Kishida, and Peter Selinger. Linear dependent type theory for quantum
programming languages. In Proceedings of the 35th Annual ACM/IEEE Symposium on Logic
in Computer Science, pages 440–453, 2020.

[78] Simon J. Gay, Rajagopal Nagarajan, and Nikolaos Papanikolaou. QMC: a model checker for
quantum systems. In Aarti Gupta and Sharad Malik, editors, Proceeding of the 20th Inter-
national Conference on Computer Aided Veriﬁcation (CAV 2008), volume 5123 of Lecture
Notes in Computer Science, pages 543–547, Princeton, NJ, USA, 2008. Springer.

[79] Jean-Yves Girard. Linear logic. Theoretical Computer Science, 50(1):1–101, 1987.

[80] Georges Gonthier. Formal proof – the four-color theorem. Notices of the AMS, 55(11):1382–

1393, 2008.

[81] Daniel Gottesman. Stabilizer codes and quantum error correction. PhD thesis, Caltech, 1997.

[82] Alexander S. Green, Peter LeFanu Lumsdaine, Neil J. Ross, Peter Selinger, and Benoˆıt Val-
iron. An introduction to quantum programming in Quipper.
In Gerhard W. Dueck and
D. Michael Miller, editors, Proceedings of the 5th International Conference on Reversible
Computation (RC’13), volume 7948 of Lecture Notes in Computer Science, pages 110–124,
Victoria, BC, Canada, 2013. Springer.

[83] Alexander S. Green, Peter LeFanu Lumsdaine, Neil J. Ross, Peter Selinger, and Benoˆıt Val-
iron. Quipper: A scalable quantum programming language.
In Hans-Juergen Boehm and
Cormac Flanagan, editors, Proceedings of the ACM SIGPLAN Conference on Programming
Language Design and Implementation, (PLDI’13), pages 333–342, Seattle, WA, USA, 2013.
ACM.

[84] Lov K. Grover. A fast quantum mechanical algorithm for database search. In Gary L. Miller,
editor, Proceedings of the Twenty-Eighth Annual ACM Symposium on the Theory of Compu-
ting (STOC), pages 212–219, Philadelphia, Pennsylvania, USA, 1996. ACM.

[85] Amar Hadzihasanovic, Kang Feng Ng, and Quanlong Wang. Two complete axiomatisations
of pure-state qubit quantum computing. In Proceedings of the 33rd Annual ACM/IEEE Sym-
posium on Logic in Computer Science, LICS ’18, pages 502–511, New York, NY, USA, 2018.
ACM.

[86] David Harel, Dexter Kozen, and Jerzy Tiuryn. Dynamic logic. In Handbook of philosophical

logic, pages 99–217. Springer, 2001.

[87] Aram W. Harrow, Avinatan Hassidim, and Seth Lloyd. Quantum algorithm for linear systems

of equations. Physical Review Letters, 103:150502, Oct 2009.

[88] Ichiro Hasuo and Naohiko Hoshino. Semantics of higher-order quantum computation via

geometry of interaction. Annals of Pure and Applied Logic, 168(2):404 – 469, 2017.

[89] Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar, and Gr´egoire Sutre. Software veriﬁ-
cation with Blast. In Proceedings of the 10th International Conference on Model Checking
Software, SPIN’03. Springer, 2003.

[90] Kesha Hietala, Robert Rand, Shih-Han Hung, Liyi Li, and Michael Hicks. Proving quantum
programs correct. In Liron Cohen and Cezary Kaliszyk, editors, 12th International Confer-
ence on Interactive Theorem Proving, ITP 2021, June 29 to July 1, 2021, Rome, Italy (Virtual
Conference), volume 193 of LIPIcs, pages 21:1–21:19, 2021.

Formal methods for quantum algorithms

Page 69

[91] Kesha Hietala, Robert Rand, Shih-Han Hung, Xiaodi Wu, and Michael Hicks. A veriﬁed

optimizer for quantum circuits. Proc. ACM Program. Lang., 5(POPL):1–29, 2021.

[92] Anne Hillebrand. Quantum protocols involving multiparticle entanglement and their repre-

sentations. Master’s thesis, University of Oxford, 2011.

[93] R. Hindley. The principal type-scheme of an object in combinatory logic. Transactions of the

American Mathematical Society, 146:29–60, 1969.

[94] C. A. R. Hoare. An axiomatic basis for computer programming. Commun. ACM, 12(10):576–

580, 1969.

[95] Clare Horsman, Austin G. Fowler, Simon Devitt, and Rodney Van Meter. Surface code
quantum computing by lattice surgery. New Journal of Physics, 14(12):123011, December
2012.

[96] Yipeng Huang and Margaret Martonosi. Statistical assertions for validating patterns and
ﬁnding bugs in quantum programs. In Srilatha Bobbie Manne, Hillery C. Hunter, and Erik R.
Altman, editors, Proceedings of the 46th International Symposium on Computer Architecture
(ISCA 2019), pages 541–553, Phoenix, AZ, USA, 2019. ACM.

[97] Shih-Han Hung, Kesha Hietala, Shaopeng Zhu, Mingsheng Ying, Michael Hicks, and Xiaodi
Wu. Quantitative robustness analysis of quantum programs. Proceedings of the ACM on
Programming Languages, 3(POPL):1–29, 2019.

[98] Dominik Janzing, Pawel Wocjan, and Thomas Beth. “non-identity-check” is QMA-complete.

International Journal of Quantum Information, 03(03):463–473, 2005.

[99] Ali JavadiAbhari, Shruti Patil, Daniel Kudrow, Jeff Heckey, Alexey Lvov, Frederic T. Chong,
and Margaret Martonosi. ScaffCC: Scalable compilation and analysis of quantum programs.
Parallel Computing, 45:2–17, 2015.

[100] Emmanuel Jeandel. The rational fragment of the ZX-calculus, 2018.

[101] Emmanuel Jeandel, Simon Perdrix, and Renaud Vilmart. A complete axiomatisation of
In Proceedings of the 33rd Annual
the ZX-calculus for Clifford+T quantum mechanics.
ACM/IEEE Symposium on Logic in Computer Science, LICS ’18, pages 559–568, New York,
NY, USA, 2018. ACM.

[102] Emmanuel Jeandel, Simon Perdrix, and Renaud Vilmart. Diagrammatic reasoning beyond
Clifford+T quantum mechanics. In Proceedings of the 33rd Annual ACM/IEEE Symposium
on Logic in Computer Science, LICS ’18, pages 569–578, New York, NY, USA, 2018. ACM.

[103] Emmanuel Jeandel, Simon Perdrix, and Renaud Vilmart. A generic normal form for ZX-
diagrams and application to the rational angle completeness. In 2019 34th Annual ACM/IEEE
Symposium on Logic in Computer Science (LICS), pages 1–10, 2019.

[104] Emmanuel Jeandel, Simon Perdrix, and Renaud Vilmart. Completeness of the ZX-calculus.

Logical Methods in Computer Science, 16(2), 2020.

[105] Yoshihiko Kakutani. A logic for formal veriﬁcation of quantum programs. In Annual Asian

Computing Science Conference, pages 79–93. Springer, 2009.

Formal methods for quantum algorithms

Page 70

[106] Nathan Killoran, Josh Izaac, Nicol´as Quesada, Ville Bergholm, Matthew Amy, and Chris-
tian Weedbrook. Strawberry Fields: A software platform for photonic quantum computing.
Quantum, 3:129, 2019.

[107] Florent Kirchner, Nikolai Kosmatov, Virgile Prevosto, Julien Signoles, and Boris Yakobow-
ski. Frama-C : A software analysis perspective. Formal Asp. Comput., 27(3):573–609, 2015.

[108] Aleks Kissinger and John van de Wetering. PyZX: Large scale automated diagrammatic rea-
soning. Electronic Proceedings in Theoretical Computer Science, 318:229–241, May 2020.

[109] Aleks Kissinger and John van de Wetering. Reducing the number of non-clifford gates in

quantum circuits. Phys. Rev. A, 102:022406, Aug 2020.

[110] Aleks Kissinger and Vladimir Zamdzhiev. Quantomatic: A proof assistant for diagrammatic
reasoning. In Amy P. Felty and Aart Middeldorp, editors, Proceedings for the 25th Inter-
national Conference on Automated Deduction (CADE-25), volume 9195 of Lecture Notes in
Computer Science, pages 326–336, Berlin, Germany, 2015. Springer.

[111] A Yu Kitaev. Quantum measurements and the abelian stabilizer problem. Available online as

arXiv:quant-ph/9511026, 1995.

[112] Erwin Klein, June Andronick, Kevin Elphinstone, Gernot Heiser, David Cock, Philip Derrin,
Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski, Michael Norrish, Thomas Sewell,
Harvey Tuch, and Simon Winwood. seL4: formal veriﬁcation of an operating-system kernel.
Commun. ACM, 53(6):107–115, 2010.

[113] Emmanuel Knill. Conventions for quantum pseudocode. Technical Report LA-UR-96-2724,

Los Alamos National Laboratory, June 1996.

[114] Dexter Kozen. Results on the propositional µ-calculus. Theoretical computer science,

27(3):333–354, 1983.

[115] Saul A. Kripke. Semantical considerations on modal logic. Acta Philosophica Fennica,

16:83–94, 1963.

[116] Daniel Kroening and Michael Tautschnig. Cbmc - c bounded model checker. In Tools and
Algorithms for the Construction and Analysis of Systems - 20th International Conference,
TACAS 2014, pages 389–391. Springer, 2014.

[117] Takahiro Kubota, Yoshihiko Kakutani, Go Kato, Yasuhito Kawano, and Hideki Sakurada.
Semi-automated veriﬁcation of security proofs of quantum cryptographic protocols. Journal
of Symbolic Computation, 73:192–220, 2016.

[118] Hidenori Kuwakado and Masakatu Morii. Quantum distinguisher between the 3-round Feistel
cipher and the random permutation. In 2010 IEEE International Symposium on Information
Theory, pages 2682–2685. IEEE, 2010.

[119] Hidenori Kuwakado and Masakatu Morii. Security on the quantum-type Even-Mansour ci-
pher. In 2012 International Symposium on Information Theory and its Applications, pages
312–316. IEEE, 2012.

Formal methods for quantum algorithms

Page 71

[120] Ugo Dal Lago, Claudia Faggian, Benoˆıt Valiron, and Akira Yoshimizu. The geometry of
In Giuseppe Castagna and An-
parallelism: classical, probabilistic, and quantum effects.
drew D. Gordon, editors, Proceedings of the 44th ACM SIGPLAN Symposium on Principles
of Programming Languages (POPL’17), pages 833–845, Paris, France, 2017. ACM.

[121] Joachim Lambek. The mathematics of sentence structure. The American Mathematical

Monthly, 65(3):154–170, 1958.

[122] Martin Lange. Model checking propositional dynamic logic with all extras. Journal of Ap-

plied Logic, 4(1):39–49, 2006.

[123] Louis Lemonnier, John van de Wetering, and Aleks Kissinger. Hypergraph simpliﬁcation:
Linking the path-sum approach to the ZH-calculus. arXiv preprint arXiv:2003.13564, 2020.

[124] Xavier Leroy. Formal veriﬁcation of a realistic compiler. Commun. ACM, 52(7):107–115,

2009.

[125] Jerzy Lewandowski. Volume and quantizations. Classical and Quantum Gravity, 14(1):71,

1997.

[126] Gushu Li, Li Zhou, Nengkun Yu, Yufei Ding, Mingsheng Ying, and Yuan Xie. Projection-
based runtime assertions for testing and debugging quantum programs. Proceedings of the
ACM on Programming Languages, 4(OOPSLA):1–29, 2020.

[127] Yangjia Li and Mingsheng Ying. Algorithmic analysis of termination problems for quantum
programs. Proceedings of the ACM on Programming Languages, 2(POPL):1–29, 2017.

[128] Sheng-Kai Liao, Wen-Qi Cai, Wei-Yue Liu, Liang Zhang, Yang Li, Ji-Gang Ren, Juan Yin,
Qi Shen, Yuan Cao, Zheng-Ping Li, et al. Satellite-to-ground quantum key distribution. Na-
ture, 549(7670):43–47, 2017.

[129] Daniel A Lidar and Todd A Brun. Quantum Error Correction. Cambridge University Press,

2013.

[130] Bert Lindenhovius, Michael Mislove, and Vladimir Zamdzhiev. Enriching a linear/non-linear
lambda calculus: A programming language for string diagrams. In Proceedings of the 33rd
Annual ACM/IEEE Symposium on Logic in Computer Science, pages 659–668, 2018.

[131] Junyi Liu, Bohua Zhan, Shuling Wang, Shenggang Ying, Tao Liu, Yangjia Li, Mingsheng
Ying, and Naijun Zhan. Formal veriﬁcation of quantum algorithms using quantum Hoare
logic. In Isil Dillig and Serdar Tasiran, editors, Computer Aided Veriﬁcation, pages 187–207,
Cham, 2019. Springer International Publishing.

[132] Tao Liu, Yangjia Li, Shuling Wang, Mingsheng Ying, and Naijun Zhan. A theorem prover
for quantum Hoare logic and its applications. Available as arXiv:1601.03835, 2016.

[133] Seth Lloyd, Masoud Mohseni, and Patrick Rebentrost. Quantum algorithms for supervised

and unsupervised machine learning. arXiv preprint arXiv:1307.0411, 2013.

[134] Hoi-Kwong Lo, Xiongfeng Ma, and Kai Chen. Decoy state quantum key distribution. Physi-

cal review letters, 94(23):230504, 2005.

Formal methods for quantum algorithms

Page 72

[135] Jarrod R McClean, Jonathan Romero, Ryan Babbush, and Al´an Aspuru-Guzik. The theory
of variational hybrid quantum-classical algorithms. New Journal of Physics, 18(2):023023,
2016.

[136] Robin Milner. A theory of type polymorphism in programming. Journal of Computer and

System Sciences, 17(3):348–375, 1978.

[137] Rajagopal Nagarajan and Simon Gay. Formal veriﬁcation of quantum protocols. Available

online as arXiv:quant-ph/0203086, 2002.

[138] Yunseong Nam, Neil J Ross, Yuan Su, Andrew M Childs, and Dmitri Maslov. Automated op-
timization of large quantum circuits with continuous parameters. npj Quantum Information,
4(1):1–12, 2018.

[139] Michael A. Nielsen and Isaac Chuang. Quantum computation and quantum information.

Cambridge University Press, Cambridge, United Kingdom, 2002.

[140] Michael A. Nielsen and Isaac L. Chuang. Quantum Computation and Quantum Information

(10th Anniversary edition). Cambridge University Press, 2016.

[141] Tobias Nipkow, Lawrence C. Paulson, and Markus Wenzel. Isabelle/HOL: a proof assistant

for higher-order logic. Springer, 2002.

[142] Berhnard ¨Omer. Structured Quantum Programming. PhD thesis, TU Wien, 2003.

[143] Michele Pagani, Peter Selinger, and Benoˆıt Valiron. Applying quantitative semantics to
higher-order quantum computing. In Proceedings of the 41st ACM SIGPLAN-SIGACT Sym-
posium on Principles of Programming Languages, POPL ’14, page 647–658, New York, NY,
USA, 2014. Association for Computing Machinery.

[144] Luca Paolini and Margherita Zorzi. qPCF: A language for quantum circuit computations. In
T. V. Gopal, Gerhard J¨ager, and Silvia Steila, editors, Proceedings of the 14th Annual Con-
ference on Theory and Applications of Models of Computation (TAMC’17), volume 10185 of
Lecture Notes in Computer Science, pages 455–469, Bern, Switzerland, 2017.

[145] Christine Paulin-Mohring. Introduction to the calculus of inductive constructions. In volume

55 of Studies in Logic (Mathematical logic and foundations). College Publications, 2015.

[146] Christine Paulin-Mohring.

In
Bruno Woltzenlogel Paleo and David Delahaye, editors, All about Proofs, Proofs for All,
volume 55 of Studies in Logic (Mathematical logic and foundations). College Publications,
2015.

Introduction to the calculus of inductive constructions.

[147] Jennifer Paykin. Linear/non-Linear Types For Embedded Domain-Speciﬁc Languages. PhD

thesis, University of Pennsylvania, 2018.

[148] Jennifer Paykin, Robert Rand, and Steve Zdancewic. QWIRE: a core language for quantum
circuits. In Giuseppe Castagna and Andrew D. Gordon, editors, Proceedings of the 44th ACM
SIGPLAN Symposium on Principles of Programming Languages (POPL’17), pages 846–858,
Paris, France, 2017. ACM.

[149] Simon Perdrix. Quantum entanglement analysis based on abstract interpretation. In Interna-

tional Static Analysis Symposium, pages 270–282. Springer, 2008.

Formal methods for quantum algorithms

Page 73

[150] Benjamin C. Pierce. Types and Programming Languages. MIT Press, 2002.

[151] Amir Pnueli. The temporal logic of programs. In 18th Annual Symposium on Foundations of

Computer Science (sfcs 1977), pages 46–57. ieee, 1977.

[152] John Preskill. Quantum computing in the NISQ era and beyond. Quantum, 2:79, 2018.

[153] Qiskit Community. Qiskit: An open-source framework for quantum computing, March 2017.
The ofﬁcial way to cite Qiskit is using the bibentry at https://github.com/Qiskit/
qiskit/blob/master/Qiskit.bib.

[154] Quantum Computing Report. List of tools. Available online17, 2019.

[155] Robert Rand, Kesha Hietala, and Michael Hicks. Formal veriﬁcation vs. quantum uncertainty.
In 3rd Summit on Advances in Programming Languages (SNAPL 2019). Schloss Dagstuhl-
Leibniz-Zentrum fuer Informatik, 2019.

[156] Robert Rand, Jennifer Paykin, and Steve Zdancewic. QWIRE practice: Formal veriﬁcation of
quantum circuits in Coq. In Bob Coecke and Aleks Kissinger, editors, Proceedings 14th Inter-
national Conference on Quantum Physics and Logic (QPL 2017), volume 266 of Electronic
Proceedings in Theoretical Computer Science, pages 119–132, Nijmegen, The Netherlands,
2017. EPTCS.

[157] Robert Raussendorf, Daniel E Browne, and Hans J Briegel. Measurement-based quantum

computation on cluster states. Physical review A, 68(2):022312, 2003.

[158] John C Reynolds. Separation logic: A logic for shared mutable data structures. In Proceedings
17th Annual IEEE Symposium on Logic in Computer Science, pages 55–74. IEEE, 2002.

[159] Francisco Rios. On a Categorically Sound Quantum Programming Language for Circuit
Description. PhD thesis, Dalhousie University, Halifax, Nova Scotia, Canada, August 2021.

[160] Francisco Rios and Peter Selinger. A categorical model for a quantum circuit description
language. In Bob Coecke and Aleks Kissinger, editors, Proceedings 14th International Con-
ference on Quantum Physics and Logic (QPL 2017), volume 266 of Electronic Proceedings
in Theoretical Computer Science, pages 164–178, Nijmegen, The Netherlands, 2018.

[161] Xavier Rival and Kwangkeun Yi. Introduction to Static Analysis: An Abstract Interpretation

Perspective. The MIT Press, 2020.

[162] Neil J. Ross. Algebraic and Logical Methods in Quantum Computation. PhD thesis, Dal-

housie University, 2015. Available as arxiv:1510.02198.

[163] Thomas Santoli and Christian Schaffner. Using Simon’s algorithm to attack symmetric-key

cryptographic primitives. Quantum Inf. Comput., 17(1&2):65–78, 2017.

[164] Valerio Scarani, Helle Bechmann-Pasquinucci, Nicolas J Cerf, Miloslav Duˇsek, Norbert
L¨utkenhaus, and Momtchil Peev. The security of practical quantum key distribution. Re-
views of modern physics, 81(3):1301, 2009.

17https://quantumcomputingreport.com/resources/tools/

Formal methods for quantum algorithms

Page 74

[165] Artur Scherer, Benoˆıt Valiron, Siun-Chuon Mau, Scott Alexander, Eric Van den Berg, and
Thomas E Chapuran. Concrete resource analysis of the quantum linear-system algorithm used
to compute the electromagnetic scattering cross section of a 2d target. Quantum Information
Processing, 16(3):60, 2017.

[166] Maria Schuld. Supervised Learning with Quantum Computers. Springer, 2018.

[167] Dana Scott and Jacobus Willem de Bakker. A theory of programs. Unpublished manuscript,

IBM, Vienna, 1969.

[168] Peter Selinger. Towards a quantum programming language. Mathematical Structures in

Computer Science, 14(4):527–586, 2004.

[169] Peter Selinger. Generators and relations for n-qubit Clifford operators. Logical Methods in

Computer Science, 11(2), Jun 2015.

[170] Peter Selinger and Benoˆıt Valiron. A lambda calculus for quantum computation with classical
control. In Paweł Urzyczyn, editor, Typed Lambda Calculi and Applications, pages 354–368,
Berlin, Heidelberg, 2005. Springer Berlin Heidelberg.

[171] Peter Selinger and Benoˆıt Valiron. A linear-non-linear model for a computational call-by-
value lambda calculus (extended abstract). In Roberto M. Amadio, editor, Proceedings of
the 11th International Conference on Foundations of Software Science and Computational
Structures (FOSSACS’08), volume 4962 of Lecture Notes in Computer Science, pages 81–96,
Budapest, Hungary, 2008. Springer.

[172] Peter Selinger and Benoˆıt Valiron. Quantum Lambda Calculus.

In Simon J. Gay and Ian
Mackie, editors, Semantic Techniques in Quantum Computation, pages 135–172. Cambridge
University Press, Cambridge, November 2009.

[173] Yunong Shi, Runzhou Tao, Xupeng Li, Ali Javadi-Abhari, Andrew W Cross, Frederic T
Chong, and Ronghui Gu. Certiq: A mostly-automated veriﬁcation of a realistic quantum
compiler. arXiv preprint arXiv:1908.08963, 2019.

[174] Peter W. Shor. Algorithms for quantum computation: Discrete log and factoring. In Proceed-
ings of the 35th Annual Symposium on Foundations of Computer Science (FOCS’94), pages
124–134, Santa Fe, New Mexico, US., 1994. IEEE, IEEE Computer Society Press.

[175] Peter W Shor. Scheme for reducing decoherence in quantum computer memory. Physical

review A, 52(4):R2493, 1995.

[176] Daniel R Simon. On the power of quantum computation. SIAM journal on computing,

26(5):1474–1483, 1997.

[177] Kartik Singhal and John Reppy. Quantum hoare type theory: Extended abstract. In Benoˆıt
Valiron, Shane Mansﬁeld, Pablo Arrighi, and Prakash Panangaden, editors, Proceedings 17th
International Conference on Quantum Physics and Logic, QPL 2020, Paris, France, June 2 -
6, 2020, volume 340 of EPTCS, pages 291–302, 2020.

[178] Seyon Sivarajah, Silas Dilkes, Alexander Cowtan, Will Simmons, Alec Edgington, and Ross
Duncan. t|ket(cid:105): a retargetable compiler for NISQ devices. Quantum Science and Technology,
6(1):014003, 2020.

Formal methods for quantum algorithms

Page 75

[179] Sam Staton. Algebraic effects, linearity, and quantum programming languages. SIGPLAN

Not., 50(1):395–406, January 2015.

[180] Damian S Steiger, Thomas H¨aner, and Matthias Troyer. ProjectQ: an open source software

framework for quantum computing. Quantum, 2(49):10–22331, 2018.

[181] Krysta M Svore, Alan Geller, Matthias Troyer, John Azariah, Christopher Granade, Bet-
tina Heim, Vadym Kliuchnikov, Mariia Mykhailova, Andres Paz, and Martin Roetteler. Q#:
Enabling scalable quantum computing and development with a high-level domain-speciﬁc
language. Available online as arXiv:1803.00652, 2018.

[182] Nikhil Swamy, C˘at˘alin Hrit¸cu, Chantal Keller, Aseem Rastogi, Antoine Delignat-Lavaud, Si-
mon Forest, Karthikeyan Bhargavan, C´edric Fournet, Pierre-Yves Strub, Markulf Kohlweiss,
et al. Dependent types and multi-monadic effects in f. In Proceedings of the 43rd annual
ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 256–
270, 2016.

[183] Quingo Development Team. Quingo: A programming framework for heterogeneous
quantum-classical computing with NISQ features. Draft available as arXiv:2009.01686.,
2020.

[184] Dominique Unruh. Quantum Hoare logic with ghost variables.

In 2019 34th Annual

ACM/IEEE Symposium on Logic in Computer Science (LICS), pages 1–13. IEEE, 2019.

[185] Dominique Unruh.

Quantum relational Hoare logic.

Proc. ACM Program. Lang.,

3(POPL):33:1–33:31, 2019.

[186] Benoˆıt Valiron. Generating reversible circuits from higher-order functional programs.

In
Simon J. Devitt and Ivan Lanese, editors, Reversible Computation - 8th International Confer-
ence, RC 2016, Bologna, Italy, July 7-8, 2016, Proceedings, volume 9720 of Lecture Notes in
Computer Science, pages 289–306. Springer, 2016.

[187] Wim Van Dam, Sean Hallgren, and Lawrence Ip. Quantum algorithms for some hidden shift

problems. SIAM Journal on Computing, 36(3):763–778, 2006.

[188] Andr´e van Tonder. A lambda calculus for quantum computation. SIAM Journal on Compu-

ting, 33(5):1109–1135, 2004.

[189] Renaud Vilmart. A near-minimal axiomatisation of ZX-calculus for pure qubit quantum me-
chanics. In 2019 34th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS),
pages 1–10, June 2019.

[190] Renaud Vilmart. The structure of sum-over-paths, its consequences, and completeness for

Clifford, 2020. Available online as arXiv:2003.05678.

[191] Willem Visser, Corina S. Pasareanu, and Sarfraz Khurshid. Test input generation with Java
PathFinder. In 2004 ACM SIGSOFT International Symposium on Software Testing and Anal-
ysis, ISSTA ’04. ACM, 2004.

[192] Chuan Wang, Fu-Guo Deng, Yan-Song Li, Xiao-Shu Liu, and Gui Lu Long. Quantum se-
cure direct communication with high-dimension quantum superdense coding. Phys. Rev. A,
71:044305, Apr 2005.

Formal methods for quantum algorithms

Page 76

[193] Dave Wecker and Krysta M Svore. LIQUi|(cid:105): A software design architecture and domain-

speciﬁc language for quantum computing. Available online as arXiv:1402.4467, 2014.

[194] Mingsheng Ying. Floyd-Hoare logic for quantum programs. ACM Transactions on Program-

ming Languages and Systems (TOPLAS), 33(6):19:1–19:49, 2011.

[195] Mingsheng Ying. Foundations of Quantum Programming. Morgan Kaufmann, 2016.

[196] Mingsheng Ying and Yuan Feng. Model Checking Quantum Systems: Principles and Algori-

thms. Cambridge University Press, 2021.

[197] Mingsheng Ying, Yangjia Li, Nengkun Yu, and Yuan Feng. Model-checking linear-time
properties of quantum systems. ACM Transactions on Computational Logic, 15(3):22:1–
22:31, 2014.

[198] Mingsheng Ying, Shenggang Ying, and Xiaodi Wu. Invariants of quantum programs: char-
In Giuseppe Castagna and Andrew D. Gordon, editors, Pro-
acterisations and generation.
ceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages,
POPL 2017, Paris, France, January 18-20, 2017, pages 818–832. ACM, 2017.

[199] Nengkun Yu and Jens Palsberg. Quantum abstract interpretation. In Proceedings of the 42nd
ACM SIGPLAN International Conference on Programming Language Design and Implemen-
tation, pages 542–558, 2021.

[200] Shengyu Zhang. BQP-complete problems.

In Grzegorz Rozenberg, Thomas B¨ack, and

Joost N. Kok, editors, Handbook of Natural Computing, pages 1545–1571. Springer, 2012.

[201] Li Zhou, Gilles Barthe, Justin Hsu, Mingsheng Ying, and Nengkun Yu. A quantum inter-
pretation of bunched logic for quantum separation logic. In 2021 36th Annual ACM/IEEE
Symposium on Logic in Computer Science (LICS), pages 1–14. IEEE, 2021.

