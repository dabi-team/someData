0
2
0
2

t
c
O
5
1

]
L
P
.
s
c
[

1
v
1
5
0
8
0
.
0
1
0
2
:
v
i
X
r
a

Program Equivalence for Assisted Grading of Functional
Programs (Extended Version)

JOSHUA CLUNE, Carnegie Mellon University, United States of America
VIJAY RAMAMURTHY, Carnegie Mellon University, United States of America
RUBEN MARTINS, Carnegie Mellon University, United States of America
UMUT A. ACAR, Carnegie Mellon University, United States of America

In courses that involve programming assignments, giving meaningful feedback to students is an important
challenge. Human beings can give useful feedback by manually grading the programs but this is a time-
consuming, labor intensive, and usually boring process. Automatic graders can be fast and scale well but they
usually provide poor feedback. Although there has been research on improving automatic graders, research
on scaling and improving human grading is limited.

We propose to scale human grading by augmenting the manual grading process with an equivalence
algorithm that can identify the equivalences between student submissions. This enables human graders
to give targeted feedback for multiple student submissions at once. Our technique is conservative in two
aspects. First, it identifies equivalence between submissions that are algorithmically similar, e.g., it cannot
identify the equivalence between quicksort and mergesort. Second, it uses formal methods instead of clustering
algorithms from the machine learning literature. This allows us to prove a soundness result that guarantees
that submissions will never be clustered together in error. Despite only reporting equivalence when there
is algorithmic similarity and the ability to formally prove equivalence, we show that our technique can
significantly reduce grading time for thousands of programming submissions from an introductory functional
programming course.

Additional Key Words and Phrases: Program Equivalence, Assisted Grading, Formal Methods, Functional
Programming

1 INTRODUCTION
There have been many efforts to develop techniques for automated reasoning of programming
assignments at scale. This has lead to the rise of automatic graders, programs that take in a set
of student submissions and output grades or feedback for those submissions without requiring
any human input. While recent years have yielded substantial improvements in automatic grading
techniques [Gulwani et al. 2018; Kaleeswaran et al. 2016; Liu et al. 2019; Perry et al. 2019; Singh
et al. 2013; Wang et al. 2018], automatic graders are still more limited in the feedback they can
provide than human graders.

This creates a trade-off between scale and quality. For small courses, it makes sense to utilize
human graders in order to provide the best feedback possible. For Massive Open Online Courses,
human involvement in grading all submissions is often logistically impossible, so it makes sense
to use automatic graders. But neither option is ideal for large, in-person, introductory functional
courses. When introductory functional courses use automatic graders, it hurts the students because
they receive less targeted feedback, and it can hurt the teaching staff to lose a valuable avenue for
addressing uncommon misunderstandings. But when introductory functional courses use human
graders, it creates a large burden on the teaching staff, and it may require capping the size of the
class, hurting students by limiting their opportunity to take the class.

Authors’ addresses: Joshua Clune, Carnegie Mellon University, United States of America, josh.seth.clune@gmail.com; Vijay
Ramamurthy, Carnegie Mellon University, United States of America, vrama628@gmail.com; Ruben Martins, Carnegie
Mellon University, United States of America, rubenm@andrew.cmu.edu; Umut A. Acar, Carnegie Mellon University, United
States of America, umut@cs.cmu.edu.

2020.

 
 
 
 
 
 
2

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

To provide an option that eases the cost of human grading without sacrificing feedback quality,
we propose a method of enabling human graders to give targeted feedback to multiple students
at once. Our approach takes a pair of expressions submitted by students and deconstructs them
simultaneously to build up a formula that is valid only if the expressions are equivalent. This pairwise
equivalence test is used to cluster student submissions into buckets for which all submissions can be
graded and given feedback simultaneously. Our approach recognizes expressions as equivalent by
finding equivalences in each expression’s subexpressions. To do this, it uses a variety of inference
rules to simultaneously deconstruct the expressions down to their atomic subexpressions. It then
outputs formulas that are valid only if the atomic subexpressions are equivalent. Finally, our
inference rules recursively use the formulas of these subexpressions as subformulas to build up a
larger formula that indicates the equivalence of the overall expression. This final formula’s validity
can be checked by an SMT Solver to determine whether the two expressions are equivalent.

A central benefit of our approach is that when two expressions are recognized as equivalent,
this fact does not merely reflect that the two expressions produce the same outputs on shared
inputs. In input/output grading, the correctness of code is determined entirely by whether a student
submission produces correct outputs when given a large and diverse set of inputs. But in our
approach, all equivalences arise from similarities in subexpressions, so equivalences found by our
technique are discoverable only due to underlying algorithmic similarities. This enables instructors
to give feedback based not only on whether a problem was solved correctly, but based on the
algorithmic decisions that were involved in the student’s solution.

Three primary factors that impact the grading and feedback of student programs are correctness,
algorithmic approach, and style. While our approach is meant to enable providing better feedback
concerning algorithmic approach, as opposed to simply providing feedback concerning correctness
as in input/output grading, evaluating style is outside of the scope of our technique. For that reason,
we believe that our approach is best utilized in conjunction with the methods courses already use to
evaluate style. For courses already doing automatic grading, this should not be an issue because if
they are already doing automatic grading, they are already automatically doing style checking, and
can, therefore, use that in conjunction with our approach to provide all of the same style feedback
the course already provided, but additionally provide human feedback for algorithmic content.

For courses already doing fully human grading, even if it is still necessary to grade each as-
signment individually to address style concerns, we believe our approach can make it possible to
better allocate human resources for the grading process. A grader focusing entirely on one or two
large buckets can be more efficient by not being forced to figure out which common approach is
being taken by every individual submission. This can help the grader more quickly move on from
understanding the student’s solution to addressing any style concerns, and it also helps ensure
fairer grading in guaranteeing that the same grader will grade all similar submissions. A grader
focusing entirely on grading submissions that were clustered with few if any other programs can
anticipate ahead of time that their grading will likely require providing more frequent and/or
detailed comments. This can enable course staffs to give more submissions to graders of large
buckets, easing the burden of singleton/small bucket graders.

The differences between our approach and other state-of-the-art automatic graders and clustering
techniques [Gulwani et al. 2018; Perry et al. 2019; Wang et al. 2018] stem from differences in
motivation. Since each bucket generated by our approach is meant to be graded by a human, it is
more important for our technique to distinguish nonequivalent submissions than to ensure that all
equivalent submissions are placed in the same bucket. Ensuring that all equivalent submissions are
placed in the same bucket reduces time spent grading equivalent programs, enabling instructors to
spend more time giving detailed feedback. This is an important goal, but it is of lower priority than
preserving the accuracy of human feedback because it does not matter how detailed feedback is if

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

3

it does not apply to the student to whom it is given. To secure the accuracy of human feedback
while using our approach, we guarantee the correctness of our technique’s recognized equivalences
by proving a soundness theorem that states that if our technique recognizes two expressions as
equivalent, they necessarily exhibit identical behavior.

In summary, the contributions of our paper are as follows:

• We define an effective and efficient technique for identifying equivalences between purely
functional programs. The technique’s design ensures that only algorithmically similar pro-
grams will be recognized as equivalent.

• We prove the soundness of this technique, showing that if our approach identifies an equiva-
lence between two expressions, then the two expressions must exhibit identical behavior.
• We implement our approach in a tool called zeus and demonstrate its effectiveness in assisting
the grading of more than 4,000 student submissions from a functional programming course
taught at the college level in Standard ML.

2 MOTIVATING EXAMPLES
Our approach is meant to cluster expressions that are algorithmically similar, but potentially
syntactically different. In this section, we show two examples of similar implementations of the
same function that are successfully identified by our tool as equivalent, and describe one example
in which two solutions to a task are not recognized as equivalent due to algorithmic dissimilarities.

fun add_opt x y =
case (x , y) of

( SOME m , SOME n) =>

SOME (m + n)
| ( NONE , _) => NONE
| (_ , NONE ) => NONE

fun bind a f =
case a of

SOME b => f b

| NONE => NONE

val return = SOME

fun add_opt x y =
bind x ( fn m =>
bind y ( fn n =>

return (m + n)

))

Fig. 1. Two implementations of adding two optional numbers

Figure 1 contains two functions that take in two int options as input, and adds the ints
in the options if possible, returning NONE otherwise. The right expression’s conditional logic is
modeled after Haskell-style monads, interacting with the higher order bind function to case on x
first, and then potentially y depending on the value of x, whereas the left expression cases on x
and y simultaneously. Still, our approach is able to fully encode both expressions’ conditional logic
structures and produce a valid formula. A demonstration of how our approach specifically encodes
these conditional logic structures is included in Section 5.

Figure 2 contains two functions that implement mergesort. The left implementation uses a style
that emphasizes pattern matching on input arguments while the right implementation uses a style
that emphasizes nesting binding structures. Despite their syntactic differences, both functions
implement the same underlying algorithm. Therefore, our approach recognizes them as equivalent.
Our approach is not intended to cluster programs just by correctness, or final input/output
behavior, but by structure. This enables our approach to distinguish between correct submissions
that use different algorithms. For instance, one of the benchmarks we use in Section 7 to evaluate

4

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

fun split [] = ([] , [])

| split [x] = ([ x], [])
| split (x :: y :: L) =

let

val (A , B) = split L

in

(x ::A , y :: B)

end

fun merge ([] , L) = L
| merge (L , []) = L
| merge (x :: xs , y :: ys ) =

fun split [] = ([] , [])

| split (x :: xs ) =
case xs of

[] => ([ x], [])

| (y :: ys ) =>

let

val (A , B) = split ys

in

(x ::A , y :: B)

end

fun merge (l1 , l2 ) =

if x < y
then x :: merge (xs , y :: ys )
else y :: merge (x :: xs , ys )

case l1 of
[] => l2
| x :: xs =>

fun msort [] = []

| msort [x] = [x]
| msort L =

let

val (A , B) = split L

in

merge ( msort A , msort B)

end

case l2 of
[] => l1
| y :: ys =>
if x < y
then x :: merge (xs , l2 )
else y :: merge (l1 , ys )

fun msort [] = []

| msort [x] = [x]
| msort L =

let

val (A , B) = split L

in

merge ( msort A , msort B)

end

Fig. 2. Two implementations of mergesort

our tool is a task called slowDoop. The goal of this task is to take in an arbitrary list 𝐿 and return
a list in which all elements in 𝐿 appear exactly once. Consider a similar task in which the goal
is the same but has the added stipulation that the final list must be sorted. A reasonable O(𝑛2)
solution to this task would be to iterate over 𝐿, only keeping elements that do not appear later in
the list, and then sort the result. But a better O(𝑛log𝑛) solution would be to first sort 𝐿, and then
iterate over the resulting list once to remove duplicate elements. While correct implementations of
these algorithms are identical from an input/output perspective, our approach would cluster them
separately, and we believe that they merit different feedback.

3 LAMBDAPIX
Our approach operates over a language which we call LambdaPix. LambdaPix is designed to be a
target for transpilation from functional programming languages such as Standard ML, OCaml, or
Haskell. Our techniques apply to purely functional programs only and do not allow for state (e.g.,
references) but are otherwise unrestricted and make no further assumptions about the programs.
In this section, we present the syntax and semantics for LambdaPix.

We give the syntax for LambdaPix in Figure 3. Arbitrary labeled product types are supported as
labeled records. For sum types and recursive types, LambdaPix is defined over an arbitrary fixed

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

5

𝑏𝑎𝑠𝑒 𝑡𝑦𝑝𝑒𝑠
𝑡𝑦𝑝𝑒𝑠

𝑖𝑛 𝑗𝑒𝑐𝑡𝑖𝑜𝑛 𝑙𝑎𝑏𝑒𝑙𝑠
𝑝𝑎𝑡𝑡𝑒𝑟𝑛𝑠

𝑏
𝜏

𝑖
𝑝

𝑝𝑟𝑖𝑚𝑖𝑡𝑖𝑣𝑒 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑠
𝑒𝑥𝑝𝑟𝑒𝑠𝑠𝑖𝑜𝑛𝑠

𝑜
𝑒

. . .

::= 𝑖𝑛𝑡 | 𝑏𝑜𝑜𝑙𝑒𝑎𝑛
::= 𝑏
𝛿
|
{ℓ1 : 𝜏1, . . . , ℓ𝑛 : 𝜏𝑛 }
|
𝜏1 → 𝜏2
|
::= label1 | label2 |
::= _
𝑥
|
{ℓ1 = 𝑝1, . . . , ℓ𝑛 = 𝑝𝑛 }
|
𝑥 as 𝑝
|
𝑐
|
𝑖 · 𝑝
|
𝑖
|
::= + | − | ∗ | < | > | ≤ | ≥
::= 𝑐
𝑥
|
{ℓ1 = 𝑒1, . . . , ℓ𝑛 = 𝑒𝑛 }
|
𝑒 · ℓ𝑖
|
𝑖 · 𝑒
|
𝑖
|
case 𝑒 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }
|
𝜆𝑥 .𝑒
|
𝑒1 𝑒2
|
fix 𝑥 is 𝑒
|
𝑜
|

𝑏𝑎𝑠𝑒 𝑡𝑦𝑝𝑒
𝑑𝑎𝑡𝑎 𝑡𝑦𝑝𝑒
𝑝𝑟𝑜𝑑𝑢𝑐𝑡 𝑡𝑦𝑝𝑒
𝑓 𝑢𝑛𝑐𝑡𝑖𝑜𝑛 𝑡𝑦𝑝𝑒

𝑤𝑖𝑙𝑑𝑐𝑎𝑟𝑑 𝑝𝑎𝑡𝑡𝑒𝑟𝑛
𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒 𝑝𝑎𝑡𝑡𝑒𝑟𝑛
𝑟𝑒𝑐𝑜𝑟𝑑 𝑝𝑎𝑡𝑡𝑒𝑟𝑛
𝑎𝑙𝑖𝑎𝑠 𝑝𝑎𝑡𝑡𝑒𝑟𝑛
𝑐𝑜𝑛𝑠𝑡𝑎𝑛𝑡 𝑝𝑎𝑡𝑡𝑒𝑟𝑛
𝑖𝑛 𝑗𝑒𝑐𝑡𝑖𝑜𝑛 𝑝𝑎𝑡𝑡𝑒𝑟𝑛 (𝑤𝑖𝑡ℎ 𝑎𝑟𝑔𝑢𝑚𝑒𝑛𝑡)
𝑖𝑛 𝑗𝑒𝑐𝑡𝑖𝑜𝑛 𝑝𝑎𝑡𝑡𝑒𝑟𝑛 (𝑤𝑖𝑡ℎ𝑜𝑢𝑡 𝑎𝑟𝑔𝑢𝑚𝑒𝑛𝑡)

𝑐𝑜𝑛𝑠𝑡𝑎𝑛𝑡
𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒
𝑟𝑒𝑐𝑜𝑟𝑑
𝑝𝑟𝑜 𝑗𝑒𝑐𝑡𝑖𝑜𝑛
𝑖𝑛 𝑗𝑒𝑐𝑡𝑖𝑜𝑛 (𝑤𝑖𝑡ℎ 𝑎𝑟𝑔𝑢𝑚𝑒𝑛𝑡)
𝑖𝑛 𝑗𝑒𝑐𝑡𝑖𝑜𝑛 (𝑤𝑖𝑡ℎ𝑜𝑢𝑡 𝑎𝑟𝑔𝑢𝑚𝑒𝑛𝑡)
𝑐𝑎𝑠𝑒 𝑎𝑛𝑎𝑙𝑦𝑠𝑖𝑠
𝑎𝑏𝑠𝑡𝑟𝑎𝑐𝑡𝑖𝑜𝑛
𝑎𝑝𝑝𝑙𝑖𝑐𝑎𝑡𝑖𝑜𝑛
𝑓 𝑖𝑥𝑒𝑑 𝑝𝑜𝑖𝑛𝑡
𝑝𝑟𝑖𝑚𝑖𝑡𝑖𝑣𝑒 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛

Fig. 3. The syntax of LambdaPix

set of algebraic data types, with associated injection labels. We use meta-variables 𝑥, 𝑦, and 𝑧 (and
variants) to range over an unspecified set of variables.

3.1 Static Semantics
We assume an arbitrary fixed set of disjoint algebraic data types with unique associated injection
labels (by unique, it is meant that there are no shared injection labels between distinct data types).
In particular, we assume a fixed set of judgments of the form 𝑖 : 𝜏 ↩→ 𝛿 for injection labels that take
in an argument of type 𝜏 to produce an expression of data type 𝛿, and a fixed set of judgments of
the form 𝑖 : 𝛿 for injection labels of data type 𝛿 that do not take in an argument. We take 𝑖 : 𝜏 ↩→ 𝛿
to mean that the type 𝛿 has a label 𝑖 which accepts an argument of type 𝜏, and we take 𝑖 : 𝛿 to
mean that the type 𝛿 has a label 𝑖 that does not accept an argument. Note that by allowing 𝜏 to
contain instances of 𝛿, this data type system affords LamdbaPix a form of inductive types.

_ :: 𝜏 ⊣ PatTy1

𝑥 :: 𝜏 ⊣ 𝑥 : 𝜏 PatTy2

. . .
{𝑙1 = 𝑝1, . . . , 𝑙𝑛 = 𝑝𝑛 } :: {ℓ1 : 𝜏1, . . . , ℓ𝑛 : 𝜏𝑛 } ⊣ Γ1 . . . Γ𝑛

𝑝1 :: 𝜏1 ⊣ Γ1

𝑝𝑛 :: 𝜏𝑛 ⊣ Γ𝑛

PatTy3

𝑝 :: 𝜏 ⊣ Γ

𝑥 as 𝑝 :: 𝜏 ⊣ Γ, 𝑥 : 𝜏 PatTy4

𝑐 :: 𝑏 ⊣

PatTy5

𝑖 : 𝛿
𝑖 :: 𝛿 ⊣

PatTy6

𝑖 : 𝜏 ↩→ 𝛿

𝑝 :: 𝜏 ⊣ Γ

𝑖 · 𝑝 :: 𝛿 ⊣ Γ

PatTy7

Fig. 4. Pattern typing in LambdaPix

6

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

Figure 4 defines an auxiliary judgment used in the typechecking of case expressions. This pattern
typing judgment 𝑝 :: 𝜏 ⊣ Γ defines that expressions of type 𝜏 can be matched against the pattern 𝑝,
and that doing so produces new variable bindings whose types are captured in Γ.

Γ ⊢ 𝑐 : 𝑏 Ty1

Γ, 𝑥 : 𝜏 ⊢ 𝑥 : 𝜏 Ty2

Γ ⊢ 𝑒1 : 𝜏1

. . .
Γ ⊢ {ℓ1 = 𝑒1, . . . , ℓ𝑛 = 𝑒𝑛 } : {ℓ1 : 𝜏1, . . . , ℓ𝑛 : 𝜏𝑛 }

Γ ⊢ 𝑒𝑛 : 𝜏𝑛

Ty3

Γ ⊢ 𝑒 : {. . . , ℓ𝑖 : 𝜏𝑖, . . .}
Γ ⊢ 𝑒 · ℓ𝑖 : 𝜏𝑖

Ty4

𝑖 : 𝛿
Γ ⊢ 𝑖 : 𝛿 Ty5

𝑖 : 𝜏 ↩→ 𝛿

Γ ⊢ 𝑒 : 𝜏

Γ ⊢ 𝑖 · 𝑒 : 𝛿

Ty6

Γ ⊢ 𝑒 : 𝜏

𝑝1 :: 𝜏 ⊣ Γ1

Γ, Γ1 ⊢ 𝑒1 : 𝜏 ′

. . .

𝑝𝑛 :: 𝜏 ⊣ Γ𝑛

Γ, Γ𝑛 ⊢ 𝑒𝑛 : 𝜏 ′

Γ ⊢ case 𝑒 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } : 𝜏 ′

Ty7

Γ, 𝑥 : 𝜏1 ⊢ 𝑒 : 𝜏2
Γ ⊢ 𝜆𝑥 .𝑒 : 𝜏1 → 𝜏2

Ty8

Γ ⊢ 𝑒1 : 𝜏1 → 𝜏2

Γ ⊢ 𝑒2 : 𝜏1

Γ ⊢ 𝑒1 𝑒2 : 𝜏2

Ty9

Γ, 𝑥 : 𝜏 ⊢ 𝑒 : 𝜏
Γ ⊢ fix 𝑥 is 𝑒 : 𝜏 Ty10

Γ, 𝑜 : 𝜏1 → 𝜏2 ⊢ 𝑜 : 𝜏1 → 𝜏2

Ty11

Fig. 5. Expression typing in LambdaPix

Figure 5 defines typing for expressions in LambdaPix.

Definition 3.1 (Well-formed). A LambdaPix expression 𝑒 is well-formed if there exists a type 𝜏
such that Γinitial ⊢ 𝑒 : 𝜏, where Γinitial only contains the typing judgments for primitive operations.

Not captured in the type system of LambdaPix are the following two restrictions:

• No variable may appear more than once in a pattern.
• The patterns of a case expression must be exhaustive.

3.2 Dynamic Semantics
Here we define how LambdaPix expressions evaluate. We define evaluation as a small-step dynamic
semantics where the judgment 𝑒 ↦→ 𝑒 ′ means that 𝑒 steps to 𝑒 ′ and the judgment 𝑒 val means that 𝑒
is a value and doesn’t step any further. LambdaPix enjoys progress and preservation.

Definition 3.2 (Progress and Preservation). For any typing context Γ and expression 𝑒 such that

Γ ⊢ 𝑒 : 𝜏 it is either the case that 𝑒 val or there exists an 𝑒 ′ such that Γ ⊢ 𝑒 ′ : 𝜏 and 𝑒 ↦→ 𝑒 ′.

LambdaPix also enjoys the finality of values: it is never the case that both 𝑒 ↦→ 𝑒 ′ and 𝑒 val.

(cid:12)

To define evaluation we first define two helper judgments to deal with pattern matching (Figure
6). The judgment 𝑣
𝑝 ⊣ 𝐵 means the value 𝑣 matches to the pattern 𝑝 producing 𝐵, where 𝐵 is a
set of bindings of the form 𝑣 ′/𝑥 that indicate the value 𝑣 ′ is bound to the variable 𝑥. The judgment
𝑝 means the expression 𝑣 does not match to the pattern 𝑝. It is assumed as a precondition to
𝑣 \
(cid:12)
these judgements that 𝑣 val, ⊢ 𝑣 : 𝜏, and 𝑝 :: 𝜏. Pattern matching in LambdaPix enjoys the property
that for any 𝑣 and 𝑝 satisfying the above preconditions it is either the case that there exist bindings
𝑝. It is never simultaneously the case that 𝑣
𝐵 such that 𝑣
In Figure 7 we use these helper judgments to define the evaluation judgments. In Dyn17, 𝑒 ′ is
meant to be understood as a hard-coded value dependent on the primitive operation 𝑜. We use
these judgments to define what it means for an expression to evaluate to a value. We use 𝑒
⇒ 𝑣 to
denote that expression 𝑒 evaluates to value 𝑣. In rules BigDyn1 and BigDyn2, big-step dynamics
are defined as the transitive closure of the small-step dynamics.

𝑝 ⊣ 𝐵 and 𝑣 \
(cid:12)

𝑝 ⊣ 𝐵, or 𝑣 \
(cid:12)

𝑝.

(cid:12)

(cid:12)

(cid:90)
Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

7

Match1

𝑣

𝑥 ⊣ 𝑣/𝑥

Match2

_ ⊣

𝑣

(cid:12)

(cid:12)
𝑣1

𝑝1 ⊣ 𝐵1

. . .

(cid:12)
𝑝𝑛 ⊣ 𝐵𝑛
{ℓ1 = 𝑝1, . . . , ℓ𝑛 = 𝑝𝑛 } ⊣ 𝐵1 . . . 𝐵𝑛

𝑣𝑛

(cid:12)

{ℓ1 = 𝑣1, . . . , ℓ𝑛 = 𝑣𝑛 }

(cid:12)

(cid:12)

𝑐1 = 𝑐2
𝑐2 ⊣
𝑐1

Match3

𝑐1 ≠ 𝑐2
𝑐2
𝑐1 \
(cid:12)

Match4

Match5

𝑣𝑖 \
(cid:12)
{ℓ1 = 𝑣1, . . . , ℓ𝑛 = 𝑣𝑛 } \
(cid:12)

𝑝𝑖
{ℓ1 = 𝑝1, . . . , ℓ𝑛 = 𝑝𝑛 }

Match6

𝑝 ⊣ 𝐵
𝑣
𝑥 as 𝑝 ⊣ 𝐵, 𝑣/𝑥

(cid:12)

Match7

𝑣

(cid:12)

𝑣 \
𝑝
(cid:12)
𝑥 as 𝑝

𝑣 \
(cid:12)
𝑖1 ≠ 𝑖2

𝑖1 · 𝑣 \
(cid:12)

𝑖2 · 𝑝

Match8

Match12

Match9

𝑝
𝑖 · 𝑝

Match13

𝑖

𝑖 ⊣

(cid:12)

𝑣 \
(cid:12)
𝑖 · 𝑣 \
(cid:12)

𝑖1 ≠ 𝑖2
𝑖2
𝑖1 \
(cid:12)

Match10

𝑝 ⊣ 𝐵
𝑖 · 𝑝 ⊣ 𝐵

𝑣
𝑖 · 𝑣

(cid:12)
(cid:12)

Match11

Match14

𝑖1 · 𝑣 \
(cid:12)

𝑖2

𝑖2 · 𝑝

𝑖1 \
(cid:12)

Match15

Fig. 6. Pattern matching in LambdaPix

Dyn1

𝑐 val

𝑒1 val

𝑒2 val

. . .
{. . . , ℓ𝑖 = 𝑒𝑖, . . .} ↦→ {. . . , ℓ𝑖 = 𝑒 ′

𝑒𝑖−1 val

𝑒𝑖 ↦→ 𝑒 ′
𝑖
𝑖 , . . .}

Dyn2

𝑒1 val

. . .
{ℓ1 = 𝑒1, . . . , ℓ𝑛 = 𝑒𝑛 } val

𝑒𝑛 val

Dyn3

𝑒 ↦→ 𝑒 ′
𝑒 · ℓ𝑖 ↦→ 𝑒 ′ · ℓ𝑖

Dyn4

{. . . , ℓ𝑖 = 𝑒𝑖, . . .} val
{. . . , ℓ𝑖 = 𝑒𝑖, . . .} · ℓ𝑖 ↦→ 𝑒𝑖

Dyn5

𝑒 ↦→ 𝑒 ′

𝑖 · 𝑒 ↦→ 𝑖 · 𝑒 ′ Dyn6

𝑒 val
𝑖 · 𝑒 val

Dyn7

Dyn8

𝑖 val

𝑒 ↦→ 𝑒 ′
case 𝑒 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } ↦→ case 𝑒 ′ {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }

Dyn9

𝑒 val

𝑝1

. . .

𝑒 \
(cid:12)

𝑒 \
(cid:12)

case 𝑒 {. . . | 𝑝𝑖 .𝑒𝑖 | . . .} ↦→ [𝐵]𝑒𝑖

(cid:12)

𝑝𝑖−1

𝑒

𝑝𝑖 ⊣ 𝐵

Dyn10

𝜆𝑥 .𝑒 val

Dyn11

𝑒1 ↦→ 𝑒 ′
1
𝑒1 𝑒2 ↦→ 𝑒 ′
1

𝑒2

Dyn12

𝑒2 ↦→ 𝑒 ′
𝑒1 val
2
𝑒1 𝑒2 ↦→ 𝑒1 𝑒 ′
2

Dyn13

𝑒2 val

(𝜆𝑥 .𝑒) 𝑒2 ↦→ [𝑒2/𝑥]𝑒 Dyn14

fix 𝑥 is 𝑒 ↦→ [fix 𝑥 is 𝑒/𝑥]𝑒 Dyn15

Dyn16

𝑜 val

𝑒 val

𝑜 𝑒 ↦→ 𝑒 ′ Dyn17

𝑣 val
⇒ 𝑣 BigDyn1
𝑣

𝑒 ↦→ 𝑒 ′
𝑒

𝑒 ′
⇒ 𝑣

⇒ 𝑣

BigDyn2

Fig. 7. Dynamic semantics of LambdaPix

4 SOUND EQUIVALENCE INFERENCES
Our approach takes as input two LambdaPix expressions of the same type and outputs a logic
formula which is valid only if the two expressions are equivalent. We construct this logic formula
by constructing a proof tree of sound equivalence inferences.

4.1 Logic Formulas
Figure 8 defines the form of the formulas generated by our approach. The leaves of these formulas
are equalities between base terms 𝑡, defined in Figure 9. These base terms encode three things:
LambdaPix values, patterns, and the application of a primitive operation and a value. Encoding all
of these things as terms allows a term equivalence to state that either two values are the same, that

(cid:90)
(cid:90)
(cid:90)
8

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

𝜎

::=

𝑡1 ≡ 𝑡2
𝜎1 ∧ 𝜎2
𝜎1 ∨ 𝜎2
𝜎1 ⇒ 𝜎2
¬𝜎

𝑡𝑒𝑟𝑚 𝑒𝑞𝑢𝑖𝑣𝑎𝑙𝑒𝑛𝑐𝑒
𝑐𝑜𝑛 𝑗𝑢𝑛𝑐𝑡𝑖𝑜𝑛
𝑑𝑖𝑠 𝑗𝑢𝑛𝑐𝑡𝑖𝑜𝑛
𝑖𝑚𝑝𝑙𝑖𝑐𝑎𝑡𝑖𝑜𝑛
𝑛𝑒𝑔𝑎𝑡𝑖𝑜𝑛

Fig. 8. Logic Formulas

𝑐 Term

Term1

𝑥 Term

Term2

𝑡1 Term 𝑡2 Term . . .

𝑡𝑛 Term

{ℓ1 = 𝑡1, . . . , ℓ𝑛 = 𝑡𝑛 } Term

Term3

𝑡 Term
𝑡 · ℓ𝑖 Term

Term4

𝑡 Term
𝑖 · 𝑡 Term

Term5

𝑖 Term

Term6

Term7

_ Term

𝑡 Term
𝑥 as 𝑡 Term

Term8

𝑜 Term

Term9

𝑡 Term
𝑜 𝑡 Term

Term10

Fig. 9. Term Judgment

a value matches with a pattern, or that a primitive operation application yields a value that is equal
to another value or matches with a pattern.

The inclusion of primitive operation applications as base terms is somewhat strange since they
are not values in the actual dynamics of LambdaPix, but this inclusion enables the resulting formula
to include all of the information pertaining to the theory from which the primitive operation
originates. For instance, since the theory of quantifier-free linear integer arithmetic knows that
addition is commutative, this inclusion makes it possible for the expressions 𝜆𝑥 .𝜆𝑦.(𝑥 + 𝑦) and
𝜆𝑥 .𝜆𝑦.(𝑦 + 𝑥) to be recognized as equivalent.

Except when a variable, primitive operation, as pattern, or wildcard pattern is included in one
of the terms, term equivalence is identical to syntactic equality. When a primitive operation is
included in a term, the specific primitive operation is used to determine how to understand the
term equivalence (e.g. 1 + 2 ≡ 3 is a valid term equivalence using the primitive operation "+"). When
an as pattern is included in a term equivalence: 𝑥 as 𝑒1 ≡ 𝑒2, the term equivalence is the same
as 𝑥 ≡ 𝑒1 ∧ 𝑒1 ≡ 𝑒2. When a wildcard pattern is included in a term equivalence: _ ≡ 𝑒, the term
equivalence can simply be interpreted as "true".

When one or more free variables are included in a formula, they must be resolved to determine
the formula’s truth. Throughout our approach, contexts are used to keep track of the types of all
of a formula’s free variables. Expressions can be substituted for variables of the same type in a
formula to resolve it (e.g. [3/𝑥] (𝑥 ≡ 1 ∧ 𝑥 ≡ 2) yields 3 ≡ 1 ∧ 3 ≡ 2). A formula is valid if it is true
under all possible substitutions of its variables. To denote this, we define a new form of judgment:

Definition 4.1 (

val
∀ Γ.𝑗). If Γ = (cid:174)𝑥 : (cid:174)𝜏, then the judgement

val
∀ Γ.𝑗 holds if for all (cid:174)𝑣 where 𝑣𝑖 : 𝜏𝑖 and
𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣, it is the case that [(cid:174)𝑣/(cid:174)𝑥] 𝑗 holds. Implicitly, although the types of primitive
operations are included in Γinitial, and therefore Γ, we omit typings of the form 𝑜 : 𝜏1 → 𝜏2 from
(cid:174)𝑥 : (cid:174)𝜏 so that we do not range over all possible meanings for LambdaPix’s primitive operations.
Then if Γ is a typing context with a mapping for every free variable in a formula 𝜎, the validity of
𝜎 is denoted

val
∀ Γ.𝜎.

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

9

The validity of formulas will be what determines whether our approach recognizes two Lamb-
daPix expressions as equivalent. Our approach takes as input two LambdaPix expressions and
uses them to output a logic formula. In Section 6, we show that if the output formula is valid by
Definition 4.1, then the two expressions are necessarily equivalent. To define our approach’s method
of constructing the logic formula from the original LambdaPix expressions in Section 4.4, we begin
by first defining a few helper judgments pertaining to weak head reduction and freshening.

4.2 Weak Head Reduction 𝑒 ↓ 𝑒 ′
We do not have the option of fully evaluating the expressions during execution, as expressions may
contain free variables in redex positions. For this reason we use weak head reduction at each step;
this eliminates head-position redexes until free variables get in the way. The result is a weak head
normal form expression.

𝑒 (cid:123) 𝑒 ′

𝑒 ′ ↓ 𝑒 ′′

𝑒 ↓ 𝑒 ′′

BigWhnf1

𝑒 ̸(cid:123)
𝑒 ↓ 𝑒 BigWhnf2

𝑒1 (cid:123) 𝑒 ′
1
𝑒1 𝑒2 (cid:123) 𝑒 ′
1

𝑒2

Whnf1

(𝜆𝑥 .𝑒1)𝑒2 (cid:123) [𝑒2/𝑥]𝑒1

Whnf2

𝑒 (cid:123) 𝑒 ′
𝑒 · ℓ𝑖 (cid:123) 𝑒 ′ · ℓ𝑖

Whnf3

{. . . , ℓ𝑖 = 𝑒, . . .} · ℓ𝑖 (cid:123) 𝑒 Whnf4

Fig. 10. Weak Head Reduction

4.3 Freshening
It is sometimes useful to generate fresh variables (globally unique variables) to avoid variable
capture. As single variables are not the only form of binding sites in LamdbaPix, we generalize this
notion to patterns. When freshen 𝑝.𝑒 ↩→ 𝑝 ′.𝑒 ′, 𝑝 ′.𝑒 ′ is the same as 𝑝.𝑒 except all variables bound by
𝑝 are alpha-varied to fresh variables. The definition of the freshen judgment is given in Figure 11.

freshen _.𝑒 ↩→ _.𝑒 Freshen1

𝑦 fresh

freshen 𝑥 .𝑒 ↩→ 𝑦.[𝑦/𝑥]𝑒 Freshen2

freshen 𝑝1.𝑒 ↩→ 𝑝 ′
1

.𝑒1

freshen 𝑝2.𝑒1 ↩→ 𝑝 ′
2

.𝑒2

. . .

freshen {ℓ1 = 𝑝1, . . . , ℓ𝑛 = 𝑝𝑛 }.𝑒 ↩→ {ℓ1 = 𝑝 ′
1

freshen 𝑝𝑛.𝑒𝑛−1 ↩→ 𝑝 ′
, . . . , ℓ𝑛 = 𝑝 ′

𝑛 }.𝑒𝑛

𝑛.𝑒𝑛

Freshen3

𝑦 fresh freshen 𝑝.𝑒 ↩→ 𝑝 ′.𝑒 ′

freshen 𝑥 as 𝑝.𝑒 ↩→ 𝑦 as 𝑝 ′.[𝑦/𝑥]𝑒 ′ Freshen4

freshen 𝑐.𝑒 ↩→ 𝑐.𝑒 Freshen5

freshen 𝑖.𝑒 ↩→ 𝑖.𝑒 Freshen6

freshen 𝑝.𝑒 ↩→ 𝑝 ′.𝑒 ′

freshen 𝑖 · 𝑝.𝑒 ↩→ 𝑖 · 𝑝 ′.𝑒 ′ Freshen7

Fig. 11. Freshening

In addition to creating fresh variables to avoid variable capture, our approach sometimes generates
fresh variables in order to couple the binding sites between two expressions being considered.
For instance, if our approach knows that the same expression 𝑒 is being matched to variable 𝑥 in
one expression and variable 𝑦 in another expression, it is useful to equate these bindings so that

10

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

EB(_.𝑒1, _.𝑒2) ↩→ (_.𝑒1, _.𝑒2)

EB1

𝑦 fresh
EB(_.𝑒1, 𝑥 .𝑒2) ↩→ (𝑦.𝑒1, 𝑦.[𝑦/𝑥]𝑒2)

EB2

𝑦 fresh
EB(𝑥 .𝑒1, _.𝑒2) ↩→ (𝑦.[𝑦/𝑥]𝑒1, 𝑦.𝑒2)

EB3

𝑦 fresh
EB(𝑥 .𝑒1, 𝑥 ′.𝑒2) ↩→ (𝑦.[𝑦/𝑥]𝑒1, 𝑦.[𝑦/𝑥 ′]𝑒2)

EB4

𝑦 fresh EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝 ′.𝑒 ′
1
EB(𝑥 as 𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑦 as 𝑝 ′.[𝑦/𝑥]𝑒 ′
1
𝑦 fresh EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝 ′.𝑒 ′
1

EB(𝑝1.𝑒1, 𝑥 as 𝑝2.𝑒2) ↩→ (𝑦 as 𝑝 ′.𝑒 ′
1

, 𝑝 ′.𝑒 ′
2)
, 𝑦 as 𝑝 ′.[𝑦/𝑥]𝑒 ′
2)

, 𝑝 ′.𝑒 ′
2)
, 𝑦 as 𝑝 ′.𝑒 ′
2)

EB5

EB6

EB(𝑝1.𝑒1, 𝑝 ′
1

. . . EB(𝑝𝑛.𝑒𝑛−1
.𝑒2) ↩→ (𝑝 ′′
, 𝑝 ′′
.𝑒1
.𝑒1
2)
1
1
1
..ℓ𝑛 = 𝑝 ′
EB({ℓ1 = 𝑝1..ℓ𝑛 = 𝑝𝑛 }.𝑒1, {ℓ1 = 𝑝 ′
𝑛 }.𝑒2) ↩→ ({ℓ1 = 𝑝 ′′
1
1

1

𝑛.𝑒𝑛−1
, 𝑝 ′
2
..ℓ𝑛 = 𝑝 ′′

) ↩→ (𝑝 ′′
𝑛 }.𝑒𝑛
1

𝑛 .𝑒𝑛
1
, {ℓ1 = 𝑝 ′′
1

, 𝑝 ′′

𝑛 .𝑒𝑛
2 )
..ℓ𝑛 = 𝑝 ′′

𝑛 }.𝑒𝑛
2 )

EB7

EB(𝑐.𝑒1, 𝑐.𝑒2) ↩→ (𝑐.𝑒1, 𝑐.𝑒2)

EB8

EB(𝑖.𝑒1, 𝑖.𝑒2) ↩→ (𝑖.𝑒1, 𝑖.𝑒2)

EB9

EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝 ′.𝑒 ′
1
EB(𝑖 · 𝑝1.𝑒1, 𝑖 · 𝑝2.𝑒2) ↩→ (𝑖 · 𝑝 ′.𝑒 ′
1

, 𝑝 ′.𝑒 ′
2)
, 𝑖 · 𝑝 ′.𝑒 ′
2)

EB10

Fig. 12. Equate Bindings Judgment

as our approach proceeds, it is able to know that 𝑥 in the first expression is the same as 𝑦 in the
second expression. The judgment EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝.𝑒 ′
2) defined in Figure 12 does exactly
1
that, taking in two bindings and returning freshened versions of those bindings that use the same
variables so long as the two bindings 𝑝1.𝑒1 and 𝑝2.𝑒2 can be alpha-varied to use a shared pattern 𝑝.

, 𝑝.𝑒 ′

FT({𝑝1.𝑒1 | ·}, {𝑝2.𝑒2 | ·})

EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝.𝑒 ′
1

, 𝑝.𝑒 ′
2)
FT({𝑝1.𝑒1 | 𝑟𝑒𝑠𝑡1}, {𝑝2.𝑒2 | 𝑟𝑒𝑠𝑡2})

∀𝑖 ∈ [𝑛] (freshen 𝑝𝑖 .𝑒𝑖 ↩→ 𝑝 ′′

FT1

2 | ·})

EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝.𝑒 ′
, 𝑝.𝑒 ′
2)
1
1↩−→ ({𝑝.𝑒 ′
1 | ·}, {𝑝.𝑒 ′
𝑛
↩−→ (𝑟𝑒𝑠𝑡 ′
, 𝑟𝑒𝑠𝑡 ′
2)
1
1}, {𝑝.𝑒 ′
2 | 𝑟𝑒𝑠𝑡 ′
𝑖 .𝑒 ′
.𝑒 ′′′
𝑖

FT(𝑟𝑒𝑠𝑡1, 𝑟𝑒𝑠𝑡2)
𝑛+1
↩−−−→ ({𝑝.𝑒 ′

1 | 𝑟𝑒𝑠𝑡 ′
𝑖 ) ∀𝑖 ∈ [𝑚] (freshen 𝑝 ′
.𝑒 ′′
1 | . . . | 𝑝 ′′

0↩−→ ({𝑝 ′′
1

𝑛 }, {𝑝 ′′′
1

𝑖 ↩→ 𝑝 ′′′
𝑖

𝑖 .𝑒 ′′

𝑛 .𝑒 ′′

.𝑒 ′′′
1

𝑚 .𝑒 ′

𝑚 })

FT({𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }, {𝑝 ′
1

.𝑒 ′
1 | . . . | 𝑝 ′

FT2

2})

)

| . . . | 𝑝 ′′′

𝑚 .𝑒 ′′′

𝑚 })

FT3

Fig. 13. Freshen Together Judgment

The benefit of the equate bindings judgment specifically comes into play when comparing case
expressions. If two case expressions are casing on the same 𝑒, and they have identical or near
identical binding structures, then it is sometimes useful to freshen the case expressions together, so
that as our approach proceeds to consider all of the possible outcomes of the case expressions, it
is able to know that the same 𝑒 was bound in the same way in both expressions. The judgment
𝑠
↩−→ ({𝑝 ′′
FT({𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }, {𝑝 ′
𝑛 })
1
1

1 | . . . | 𝑝 ′′
.𝑒 ′′

1 | . . . | 𝑝 ′
.𝑒 ′

𝑛 }, {𝑝 ′′′
1

| . . . | 𝑝 ′′′

𝑛 .𝑒 ′′′

𝑛 .𝑒 ′′

.𝑒 ′′′
1

𝑚.𝑒 ′

𝑚 })

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

11

defined in Figure 13 takes in two lists of bindings from case expressions, and equates the first 𝑠
bindings, independently freshening the rest. The judgment is defined so that once a pair of bindings
cannot be equated, all subsequent bindings are freshened independently. This is done to ensure that
no bindings are unsoundly equated. The rules listed in Figure 13 are listed in order of precedence
(i.e. if it is possible to apply FT2 or FT3, it will apply FT2).

𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′

4.4 Formula Generation Γ ⊢ 𝑒1
The judgment that connects the validity of logic formulas with the equivalence of LambdaPix
𝜎
expressions is Γ ⊢ 𝑒1
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′. The judgment that defines how our approach generates said
logic formulas is Γ ⊢ 𝑒1

𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′, the only free variables appearing in 𝑒1 and 𝑒2
are in Γ, so Γ ⊢ 𝑒1 : 𝜏 and Γ ⊢ 𝑒2 : 𝜏. However, 𝜎 can contain more free variables than just those in
Γ. The purpose of Γ′ is to describe the rest of the variables in 𝜎. Γ and Γ′ are disjoint and between
them account for all variables which may appear in 𝜎.

𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′.
𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ or Γ ⊢ 𝑒1

When Γ ⊢ 𝑒1

𝑒1 ↓ 𝑒 ′
1

𝑒2 ↓ 𝑒 ′
2
Γ ⊢ 𝑒1

𝜎
←→ 𝑒 ′

Γ ⊢ 𝑒 ′
1
𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′

2 : 𝜏 ⊣ Γ′;

IsoExp

Fig. 14. IsoExp Rule

The judgment Γ ⊢ 𝑒1

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ is defined by Figure 14 and is mutually recursive with

Γ ⊢ 𝑒1

𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′. We use it to define what it means for two expressions to be isomorphic.
Definition 4.2 (Isomorphic). We call two expressions 𝑒1 and 𝑒2 where Γinitial ⊢ 𝑒1 : 𝜏 and Γinitial ⊢
val
∀ Γ′.𝜎.

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ and

𝑒2 : 𝜏 isomorphic if Γinitial ⊢ 𝑒1

The purpose of the distinction between the two judgments is to allow our approach to perform
𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′ assumes as a
weak head reduction exactly when needed. The judgment Γ ⊢ 𝑒1
precondition that 𝑒1 and 𝑒2 are in weak head normal form, and is defined by Figures 15, 16, and 17.
Each rule in Figure 15 is written to address a particular syntactic form that 𝑒1 and 𝑒2 might
take. Since each rule targets a particular syntactic form, the premises of each rule are motivated
Isolambda has the premises 𝑥 fresh and Γ, 𝑥 : 𝜏 ⊢
by the semantics of that form. For example,
𝜎
⇐⇒ [𝑥/𝑥2]𝑒2 : 𝜏 ′ ⊣ Γ′. The former premise simply declares 𝑥 as a previously unused
[𝑥/𝑥1]𝑒1
variable, and the latter premise states that if any value 𝑥 of type 𝜏 (the input type to both expressions)
is substituted for 𝑥1 in the left expression and 𝑥2 in the right expression, then the two expressions
will be equivalent if 𝜎 is valid. This reflects the fact that two functions are equivalent if and only if
their outputs are equivalent for all valid inputs.

Although the soundness of these rules is guaranteed, their completeness is not. For instance,
𝜎
←→ 𝑒2 : {. . . , ℓ𝑖 : 𝜏𝑖, . . .} ⊣ Γ′. If this premise holds, then the
Isoprojection has the premise Γ ⊢ 𝑒1
𝜎
←→ 𝑒2 · ℓ𝑖 : 𝜏𝑖 ⊣ Γ′ necessarily follows, as if two records are equivalent,
conclusion that Γ ⊢ 𝑒1 · ℓ𝑖
then each of the records’ respective entries must also be equivalent. But it is not the case that in
order for two projections to be equivalent, they must project from equivalent records.

Each rule in Figure 16 addresses the case in which at least one of the expressions being compared
is an application. When the two expressions being compared are both applications of equivalent

12

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

Γ ⊢ 𝑒1 : 𝜏

Γ ⊢ 𝑒2 : 𝜏

𝑒1 Term 𝑒2 Term

Γ ⊢ 𝑒1

𝑒1≡𝑒2←−−−→ 𝑒2 : 𝜏 ⊣ ·

Isoatomic

Γ ⊢ 𝑒1

Γ ⊢ {ℓ1 = 𝑒1, . . . , ℓ𝑛 = 𝑒𝑛 }

𝜎1⇐⇒ 𝑒 ′
1 : 𝜏1 ⊣ Γ′
1
𝜎1∧...∧𝜎𝑛
←−−−−−−−→ {ℓ1 = 𝑒 ′
1

. . .

Γ ⊢ 𝑒𝑛

𝜎𝑛
⇐=⇒ 𝑒 ′

𝑛 : 𝜏𝑛 ⊣ Γ′
𝑛

, . . . , ℓ𝑛 = 𝑒 ′

𝑛 } : {ℓ1 : 𝜏1, . . . , ℓ𝑛 : 𝜏𝑛 } ⊣ Γ′
1

, . . . , Γ′
𝑛

Isorecord

Γ ⊢ 𝑒1

𝜎
←→ 𝑒2 : {. . . , ℓ𝑖 : 𝜏𝑖, . . .} ⊣ Γ′
𝜎
←→ 𝑒2 · ℓ𝑖 : 𝜏𝑖 ⊣ Γ′

Γ ⊢ 𝑒1 · ℓ𝑖

Isoprojection

𝑖 : 𝜏 ↩→ 𝛿

Γ ⊢ 𝑖 · 𝑒1

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′

Γ ⊢ 𝑒1
𝜎
←→ 𝑖 · 𝑒2 : 𝛿 ⊣ Γ′

Isoinjection

𝑥 fresh Γ, 𝑥 : 𝜏 ⊢ [𝑥/𝑥1]𝑒1

𝜎
⇐⇒ [𝑥/𝑥2]𝑒2 : 𝜏 ′ ⊣ Γ′

Γ ⊢ 𝜆𝑥1.𝑒1

𝜎
←→ 𝜆𝑥2.𝑒2 : 𝜏 → 𝜏 ′ ⊣ 𝑥 : 𝜏, Γ′

Isolambda

𝑥 fresh Γ, 𝑥 : 𝜏 ⊢ [𝑥/𝑥1]𝑒1
Γ ⊢ fix 𝑥1 is 𝑒1

𝜎
⇐⇒ [𝑥/𝑥2]𝑒2 : 𝜏 ⊣ Γ′
𝜎
←→ fix 𝑥2 is 𝑒2 : 𝜏 ⊣ 𝑥 : 𝜏, Γ′

Isofix

Fig. 15. Formula Generation Rules

arguments onto equivalent functions, Isoapplication1 can be used to infer equivalence of the resulting
applications. For situations in which an application is being compared to another syntactic form, or
two applications that cannot be recognized as equivalent via Isoapplication1 are being compared, the
remaining rules take an application and replace it with a shared fresh variable in both expressions.
For example, if the expressions 𝑓 (𝑥) and 𝑓 (𝑥 + 0) are being compared, Isoapplication1 is sufficient to
find equivalence because 𝑓 can be found equivalent to 𝑓 and 𝑥 can be found equivalent to 𝑥 + 0 via
Isoatomic . But if 𝑓 (𝑥) and 𝑓 (𝑥) + 0 are being compared, Isoapplication1 alone would be insufficient,
as the outermost function of the first expression is 𝑓 and the outermost function of the second
expression is +. For this situation, Isoapplication2 is needed to replace 𝑓 (𝑥) with the fresh variable 𝑦,
yielding the expressions 𝑦 and 𝑦 + 0, which can be immediately found equivalent via Isoatomic .

The current formula generation application rules have multiple limitations. First, the rules
only allow applications to be replaced with shared fresh variables when the application being
replaced is at the outermost level of one of the expressions. This has the consequence that although
𝑓 (𝑥) + 𝑓 (𝑥) and 2 ∗ 𝑓 (𝑥) are obviously equivalent, and the substitution of 𝑓 (𝑥) for a shared fresh
variable 𝑦 would enable Isoatomic to prove that fact, our current rules do not support this inference.
Second, Isoapplication6 and Isoapplication7 require substituting an entire fixed point application in
an expression, so unless if the two expressions being compared have essentially identical fixed
points included, these rules will be ineffective. Still, despite these limitations, the current formula
generation application rules are sufficient for their most common purpose of working with Isofix to
ensure that recursive function calls are recognized as equivalent when given equivalent arguments.
Each rule in Figure 17 addresses the situation in which at least one of the expressions being
compared is a case analysis. These rules can be grouped into two broad approaches. For situations
in which only one of the expressions being compared is a case analysis, or both expressions are
case analyses but the expressions being cased on are not equivalent, Isocasel and Isocase2 are used
to unpack one case analysis at a time. If case 𝑒 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } is being compared to 𝑒 ′, then
the formula generated by these rules states that if 𝑒 can be pattern matched with 𝑝𝑖 and no prior
patterns, 𝑒𝑖 needs to be equivalent to 𝑒 ′ in order for the two overall expressions to be equivalent.

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

13

Γ ⊢ 𝑒1

𝜎
←→ 𝑒2 : 𝜏 → 𝜏 ′ ⊣ Γ′

Γ ⊢ 𝑒1 𝑒 ′
1

𝜎∧𝜎′
←−−−→ 𝑒2 𝑒 ′

2 : 𝜏 ⊣ Γ′′

𝜎′
⇐⇒ 𝑒 ′

Γ ⊢ 𝑒 ′
1
2 : 𝜏 ′ ⊣ Γ′, Γ′′

Isoapplication1

Isoapplication2

Isoapplication3

Isoapplication4

Isoapplication5

𝑦 fresh Γ, 𝑦 : 𝜏 ⊢ 𝑦
Γ ⊢ 𝑥 𝑒1

𝜎
←→ [𝑦/(𝑥 𝑒1)]𝑒2 : 𝜏 ⊣ Γ′
𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′
𝜎
←→ 𝑦 : 𝜏 ⊣ Γ′

𝑦 fresh Γ, 𝑦 : 𝜏 ⊢ [𝑦/(𝑥 𝑒2)]𝑒1
Γ ⊢ 𝑒1

𝜎
←→ 𝑥 𝑒2 : 𝜏 ⊣ Γ′

𝑦 fresh Γ, 𝑦 : 𝜏 ⊢ 𝑦
Γ ⊢ 𝑜 𝑒1

𝜎
←→ [𝑦/(𝑜 𝑒1)]𝑒2 : 𝜏 ⊣ Γ′
𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′
𝜎
←→ 𝑦 : 𝜏 ⊣ Γ′

𝜎
←→ 𝑜 𝑒2 : 𝜏 ⊣ Γ′

𝑦 fresh Γ, 𝑦 : 𝜏 ⊢ [𝑦/(𝑜 𝑒2)]𝑒1
Γ ⊢ 𝑒1
𝜎
←→ [𝑦/((fix 𝑥1 is 𝑒1) 𝑒2)]𝑒 : 𝜏 ⊣ Γ′
𝜎
←→ 𝑒 : 𝜏 ⊣ Γ′

Γ ⊢ (fix 𝑥1 is 𝑒1) 𝑒2

𝑦 fresh Γ, 𝑦 : 𝜏 ⊢ 𝑦

𝑦 fresh Γ, 𝑦 : 𝜏 ⊢ [𝑦/((fix 𝑥1 is 𝑒1) 𝑒2)]𝑒

𝜎
←→ 𝑦 : 𝜏 ⊣ Γ′

Γ ⊢ 𝑒

𝜎
←→ (fix 𝑥1 is 𝑒1) 𝑒2 : 𝜏 ⊣ Γ′

Isoapplication6

Isoapplication7

Fig. 16. Formula Generation Application Rules

Isocase3 ,

For situations in which the two expressions being compared are case analyses that are casing
Isocase4 , and Isocase5 are used to deconstruct both case
on equivalent expressions,
expressions simultaneously. To do this, Isocase3 is always used first to ensure that the expressions
being cased on are equivalent. If the expressions being cased on are not equivalent, then 𝜎 in the
formula generated by Isocase3 will not be valid, and so the output formula 𝜎 ∧ 𝜎 ′ will not be valid
as a result. If the expressions being cased on are equivalent, then Isocase4 and Isocase5 can be used
to generate 𝜎 ′. This approach is needed in addition to Isocasel and Isocase2 because Isocasel and
Isocase2 require that the expression being cased on is a base term.

All rules in Figure 15 are deterministic in the sense that for all possible expressions, at most
one rule is applicable. However, the rules in Figures 16 and 17 are non-deterministic. If two case
expressions or two applications are being compared, there may be multiple applicable rules. For
instance, if case 1 {1.2|_.3} is being compared to case 2 {_.2}, then Isocasel , Isocase2 , and Isocase3
are all applicable. Our approach handles this by considering all formulas that can be generated
by applying any applicable rule and outputs the disjunction of all generated formulas. We will
later show that applying any applicable rule in such a situation is sound and that therefore, taking
the disjunction of all generated formulas is also sound. The only exception to this is that Isocase3
cannot be applied multiple times in a row because it is never useful to do so and allowing this
would cause an infinite loop.

14

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

𝑒 Term ∀𝑖 ∈ [𝑛]

(cid:16)

freshen 𝑝𝑖 .𝑒𝑖 ↩→ 𝑝 ′

𝑖 .𝑒 ′
𝑖

𝑖 :: 𝜏 ′ ⊣ Γ𝑖
𝑝 ′

Γ, Γ𝑖 ⊢ 𝑒 ′
𝑖

𝜎𝑖
⇐⇒ 𝑒 ′ : 𝜏 ⊣ Γ′
𝑖

(cid:17)

Γ ⊢ case 𝑒 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }

∧𝑖∈ [𝑛] ( (∧𝑗 ∈ [𝑖−1] (𝑒 (cid:46)𝑝′
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→ 𝑒 ′ : 𝜏 ⊣ ∀𝑖 ∈ [𝑛] Γ𝑖, Γ′
𝑖

𝑗 ))∧𝑒≡𝑝′

𝑖 )⇒𝜎𝑖

𝑒 Term ∀𝑖 ∈ [𝑛]

(cid:16)

freshen 𝑝𝑖 .𝑒𝑖 ↩→ 𝑝 ′

𝑖 .𝑒 ′
𝑖

𝑖 :: 𝜏 ′ ⊣ Γ𝑖
𝑝 ′

Γ, Γ𝑖 ⊢ 𝑒 ′
𝑖

𝜎𝑖
⇐⇒ 𝑒 ′ : 𝜏 ⊣ Γ′
𝑖

(cid:17)

Γ ⊢ 𝑒 ′

∧𝑖∈ [𝑛] ( (∧𝑗 ∈ [𝑖−1] (𝑒 (cid:46)𝑝′
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→ case 𝑒 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } : 𝜏 ⊣ ∀𝑖 ∈ [𝑛] Γ𝑖, Γ′
𝑖

𝑗 ))∧𝑒≡𝑝′

𝑖 )⇒𝜎𝑖

Γ ⊢ 𝑒

𝜎
←→ 𝑒 ′ : 𝜏 ′ ⊣ Γ′

𝑥 fresh Γ, 𝑥 : 𝜏 ′ ⊢ case 𝑥 {. . .}

𝜎′
←→ case 𝑥 {. . .′} : 𝜏 ⊣ Γ′′

Γ ⊢ case 𝑒 {. . .}

𝜎∧𝜎′
←−−−→ case 𝑒 ′ {. . .′} : 𝜏 ⊣ Γ′, 𝑥 : 𝜏 ′, Γ′′

Isocasel

Isocase2

Isocase3

FT({𝑀 }, {𝑀 ′})

∀𝑖 ∈ [𝑠 ] (𝑝𝑖 :: 𝜏 ′ ⊣ Γ𝑖
Γ, Γ𝑗 ⊢ 𝑒 𝑗

𝑠
1 | . . . | 𝑝 ′
.𝑒 ′
↩−→ ({𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }, {𝑝 ′
1
𝜎𝑖
𝑖 ⊣ Γ′
⇐⇒ 𝑒 ′
𝑖 )
.𝑒 ′
1 | . . . | 𝑝 ′
Ψ
←→ case 𝑥 {𝑀 ′} : 𝜏 ⊣ ∀𝑖 ∈ [𝑛] Γ𝑖, Γ′
𝑖

Γ, Γ𝑖 ⊢ 𝑒𝑖
𝜎 𝑗
⇐=⇒ case 𝑥 {𝑝 ′
1

Γ ⊢ case 𝑥 {𝑀 }

∀𝑗 ∈ [𝑠+1,𝑛] (𝑝 𝑗 :: 𝜏 ′ ⊣ Γ𝑗

𝑚 .𝑒 ′

𝑚 })

𝑚 .𝑒 ′

𝑚 } : 𝜏 ⊣ Γ′
𝑗 )

FT({𝑀 ′}, {𝑀 })

𝑠
↩−→ ({𝑝 ′
1
∀𝑖 ∈ [𝑠 ] (𝑝𝑖 :: 𝜏 ′ ⊣ Γ𝑖

1 | . . . | 𝑝 ′
.𝑒 ′

∀𝑗 ∈ [𝑠+1,𝑛] (𝑝 𝑗 :: 𝜏 ′ ⊣ Γ𝑗

Γ, Γ𝑗 ⊢ case 𝑥 {𝑝 ′
1

𝑚 .𝑒 ′
𝜎𝑖
⇐⇒ 𝑒 ′
Γ, Γ𝑖 ⊢ 𝑒𝑖
.𝑒 ′
1 | . . . | 𝑝 ′

𝑚 }, {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 })
𝑖 ⊣ Γ′
𝑖 )
𝑚 .𝑒 ′
𝑚 }

𝜎 𝑗
⇐=⇒ 𝑒 𝑗 : 𝜏 ⊣ Γ′
𝑗 )

Γ ⊢ case 𝑥 {𝑀 ′}

Ψ
←→ case 𝑥 {𝑀 } : 𝜏 ⊣ ∀𝑖 ∈ [𝑛] Γ𝑖, Γ′
𝑖

Ψ := (∧𝑖 ∈ [𝑠 ]𝜎𝑖 ) ∧ (∧𝑗 ∈ [𝑠+1,𝑛] ((∧𝑘 ∈ [ 𝑗−1] (𝑥 (cid:46) 𝑝𝑘 )) ∧ 𝑥 ≡ 𝑝 𝑗 ) ⇒ 𝜎 𝑗 )

Fig. 17. Formula Generation Case Rules

Isocase4

Isocase5

In instances where there is no applicable rule, such as if 𝑖1 𝑒1 is compared with 𝑖2 𝑒2 where 𝑖1 ≠ 𝑖2
and either 𝑒1 or 𝑒2 cannot be encoded into a term, our approach simply outputs the formula 𝜎=False,
which is always sound.

4.5 Limitations and Further Extensions
The current set of rules is comprehensive and covers a wide range of operators that are often found
in many functional programming assignments. However, there are limitations to the current set of
rules, some of which have already been noted. The current main limitations include:

• Our current handling of projections in Isoprojection requires that in order for two projections

to be recognized as equivalent, they must project from equivalent records.

• Our current handling of recursive function calls occurs entirely through the interplay between
Isofix and the formula generation application rules. Because of how these rules are currently
defined, recursive functions can only be recognized as equivalent if in all situations they
recurse on equivalent arguments or do not recurse at all.

• The approach taken by the formula generation application rules is limited in that applications
can only be replaced with shared fresh variables when the application being replaced is at
the outermost level of one of the expressions being compared.

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

15

• Isoapplication6 and Isoapplication7 both require substituting a variable for an entire fixed point
application, which will only be useful if the two expressions being compared have essentially
identical fixed points included.

• Since Isocasel and Isocase2

require that the expression being cased on is a base term,
the current set of rules cannot identify equivalence between a case analysis in which the
expression being cased on isn’t a base term and any other syntactic form.

• The current definition of LambdaPix does not allow for state, and so our approach cannot

identify the equivalence of any programs that use state.

Compared to other potential extensions that could be implemented to address an aforementioned
limitation, extending LambdaPix to support state would likely require a significant number of
changes to our approach. However, this could be potentially achieved by handling sequential
state-altering declaration similar to how we handle local declaration. Currently, we handle local
declaration by encoding the declaration into the SMT formula in the same way that we would
encode a single pattern case expression (i.e. let val x = 𝑒1 in 𝑒2 end becomes case 𝑒1 {𝑥 .𝑒2}
at the transpilation to LambdaPix stage). It would not be possible to do the same procedure for
sequential declaration since the scoping would have to be global. However, we believe that it may
be feasible to treat reference declaration/assignment similar to variable declaration/initialization
and reference update similar to variable shadowing with modified scoping.

One advantage of the structure of our approach is that extending our system to address some
of the previously listed limitations is straightforward. As soon as a new rule that addresses one
of the system’s current limitations is found to be sound, it can be simply tacked on to the current
system without needing to modify any preexisting rules. This also applies to extensions of the
underlying language LambdaPix itself. Adding new base types to LambdaPix such as strings or
reals requires no modification of the current rules whatsoever, and adding additional syntactic
expression forms requires only the addition of rules for comparing the new form against itself and
arbitrary expressions. Even though it is easy to extend the LambdaPix language and add additional
rules, the current version is already rich enough to capture common behavior in programming
assignments of introductory courses.

5 OPERATION
To provide a better understanding of our approach, we step through our approach’s operation on a
pair of simple Standard ML expressions provided above. As we step through this example, we will
refer to the inference rules from the previous section to illustrate how they are applied.

fun add_opt x y =
case (x , y) of

( SOME m , SOME n) =>

SOME (m + n)
| ( NONE , _) => NONE
| (_ , NONE ) => NONE

fun bind a f =
case a of

SOME b => f b

| NONE => NONE

val return = SOME

fun add_opt x y =
bind x ( fn m =>
bind y ( fn n =>

return (m + n)

))

First, we transpile both expressions to LambdaPix. This is shown above. Since much of the proof
derivation which drives our approach is free of branching, through most of this section we will

16

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

view our approach as transforming the above expressions through the application of rules, rather
than building up a proof tree.

𝜆x.𝜆y.

case (x ,y) of
{ ( SOME ·m , SOME ·n). SOME ·(m+n)
| ( NONE ,_). NONE
| (_ , NONE ). NONE }

𝜆x.𝜆y.

(𝜆a.𝜆f.

case a of
{ SOME ·b.f b
| NONE . NONE }

) x (𝜆m.
(𝜆a.𝜆f.

case a of
{ SOME ·b.f b
| NONE . NONE }

) y (𝜆n.

(𝜆e. SOME ·e) (m+n)

))

The entry point to our approach is the Γ ⊢ 𝑒1

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ judgement, defined by the
rule IsoExp. By this rule, we reduce both expressions to weak head normal form then apply the
𝜎
Γ ⊢ 𝑒1
←→ 𝑒2 : 𝜏 ⊣ Γ′ judgement to them. However, since the expressions in consideration
are abstractions, the expressions are already in weak head normal form, so no transformation is
necessary to apply this rule.

case (x ,y ) of
{ ( SOME ·m , SOME ·n). SOME ·(m+n)
| ( NONE ,_). NONE
| (_ , NONE ). NONE }

(𝜆a.𝜆f.

case a of
{ SOME ·b.f b
| NONE . NONE }

) x (𝜆m.
(𝜆a.𝜆f.

case a of
{ SOME ·b.f b
| NONE . NONE }

) y (𝜆n.

(𝜆e. SOME ·e) (m+n)

))

Next, since both expressions are lambda expressions with two curried arguments, we proceed
with two applications of the rule Isolambda . This requires us to create two new fresh variables
and substitute them for the first two function arguments in both expressions. For simplicity, we
will simply call the first fresh variable x and the second fresh variable y even though these names
conflict with the original variable names. The key difference between before and after this process
is that before this process, the two functions had the same variable names x and y by coincidence,
whereas after this process, the two functions use the same fresh variables x and y by design. These
applications of Isolambda yield the above expressions.

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

17

case (x ,y ) of
{ ( SOME ·m , SOME ·n). SOME ·(m+n)
| ( NONE ,_). NONE
| (_ , NONE ). NONE }

case x of
{ SOME ·b.
(𝜆m.

(𝜆a.𝜆f.

case a of
{ SOME ·b.f b
| NONE . NONE }

) y (𝜆n .(𝜆e. SOME ·e) (m+n))

) b

| NONE . NONE }

Since the premise of Isolambda invokes the ⇔ judgement, IsoExp requires that we reduce both
expressions to weak head normal form. The left expression is already in weak head normal form, so
no transformation is necessary, but the right expression must undergo two beta reductions before
it is in weak head normal form. The result of these beta reductions is above.

Since both expressions are case expressions, our approach has multiple options for how to
proceed. Formally, our approach pursues all of these options, generating separate formulas for each
option, and finally outputting a disjunction of all of the generated formulas. This ensures that if
any option can generate a valid formula, then the final result will be the disjunction of the valid
formula with several other formulas, which altogether is valid. In this case, attempting to proceed
with Isocase3 will not yield a valid formula because the two expressions are casing on different
things, but applying either Isocasel or Isocase2 can yield a valid formula. For this demonstration,
we step through the derivation that results from applying Isocasel and call the formulas generated
by applying Isocase2 or Isocase3 𝜎Isocase2 and 𝜎Isocase3 respectively.

As there are three branches in the left case expression, our approach’s proof tree now splits into
three branches. For this demonstration, we just step through the first of these branches, as the
other two branches work similarly. We call the formulas generated by the other two branches of
the proof tree 𝜎branch 2 and 𝜎branch 3.

SOME ·( m1 + n1 )

case x of
{ SOME ·b.
(𝜆m.

(𝜆a.𝜆f.

case a of
{ SOME ·b.f b
| NONE . NONE }

) y (𝜆n .(𝜆e. SOME ·e) (m+n))

) b

| NONE . NONE }

We "freshen" the branch selected to avoid variable capture. In this situation we will freshen the
first branch of the left case expression by replacing m and n with m1 and n1, respectively. From this
branch we will generate a formula of the form

((x,y) ≡ (SOME·m1,SOME·n1)) ⇒ . . .

where the ellipses is what we are going to fill in as we complete this branch of the proof tree.

Since the left expression has been simplified to a base term, our approach proceeds to work
on the right expression. Our approach applies Isocase2 twice (using beta reduction to reduce the
expression to weak head normal form as appropriate), and finishes each branch of the proof tree by
using Isoatomic to compare base terms.

18

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

Putting everything together, the final formula is:

(𝜎branch 1 ∧ 𝜎branch 2 ∧ 𝜎branch 3) ∨ 𝜎Isocase2 ∨ 𝜎Isocase3

where 𝜎branch 1 is

((x,y) ≡ (SOME·m1,SOME·n1)) ⇒

((x ≡ SOME·b1) ⇒

(y ≡ SOME·b2) ⇒ (SOME·(m1+n1) ≡ SOME·(b1+b2))∧
(y (cid:46) SOME·b2 ∧ y ≡ NONE) ⇒ (SOME·(m1+n1) ≡ NONE)

)∧
((x (cid:46) SOME·b1 ∧ x ≡ NONE) ⇒

(y ≡ SOME·b2) ⇒ (SOME·(m1+n1) ≡ NONE)∧
(y (cid:46) SOME·b2 ∧ y ≡ NONE) ⇒ (SOME·(m1+n1) ≡ NONE)

)

and 𝜎branch 2 and 𝜎branch 3 are similar.

Since the two original expressions were equivalent, this formula is valid. The validity of this

formula can be verified either by hand or by an SMT Solver.

6 SOUNDNESS
We prove the soundness of our approach: if our approach takes in two expressions and outputs a
valid formula, then the two expressions must be equivalent.

6.1 Extensional Equivalence
To prove the soundness of our approach, we must first define what it means for two expressions to be
equivalent. For this, we introduce extensional equivalence, a widely accepted notion of equivalence.
Extensional equivalence is the same as contextual equivalence, and so two extensionally equivalent
expressions are indistinguishable in terms of behavior. This implies that extensional equivalence
is closed under evaluation. Extensional equivalence is also an equivalence relation, so we may
assume that it is reflexive, symmetric, and transitive. LambdaPix enjoys referential transparency,
meaning that extensional equivalence of LambdaPix expressions is closed under replacement of
subexpressions with extensionally equivalent subexpressions.

We use 𝑒1 (cid:27) 𝑒2 : 𝜏 to denote that expressions 𝑒1 and 𝑒2 are extensionally equivalent and both

have the type 𝜏.

𝑒1

Definition 6.1 (Extensional Equivalence). We define that 𝑒1 (cid:27) 𝑒2 : 𝜏 if Γinitial ⊢ 𝑒1 : 𝜏, Γinitial ⊢ 𝑒2 : 𝜏,
⇒ 𝑣1, 𝑒2
(1) Rule EQ1: In the case that 𝜏 = 𝜏1 → 𝜏2, for all expressions 𝑣 such that Γinitial ⊢ 𝑣 : 𝜏1,

⇒ 𝑣2, and

𝑣1 𝑣 (cid:27) 𝑣2 𝑣 : 𝜏2.

(2) Rule EQ2: In the case that 𝜏 is not an arrow type, for all patterns 𝑝 such that 𝑝 :: 𝜏, either
𝑝.

𝑝 ⊣ 𝐵 and 𝑣2

𝑣1

𝑝 ⊣ 𝐵 or 𝑣1 \
(cid:12)

𝑝 and 𝑣2 \
(cid:12)

(cid:12)

(cid:12)

Unlike our approach, extensional equivalence inducts over the types of the expressions rather
than their syntax, and is defined only over closed expressions. As we are only concerned with
proving our approach sound over valuable expressions, we leave extensional equivalence undefined
for divergent expressions.

This is an atypical formalization of extensional equivalence; it is typically defined in terms of
the elimination forms of each type connective. However, since pattern matching in LambdaPix

(cid:90)
(cid:90)
Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

19

subsumes the elimination of all connectives other than arrows, we simply define equivalence at all
non-arrow types in terms of pattern matching.

The soundness theorem for our approach connects our technique’s definition of isomorphic with

this definition of extensional equivalence. It is as follows:

Theorem 6.2 (Soundness). For any expressions 𝑒1 and 𝑒2, if Γinitial ⊢ 𝑒1

then 𝑒1 (cid:27) 𝑒2 : 𝜏.

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ and

val
∀ Γ′.𝜎,

6.2 Proof Sketch
𝜎
𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ judgement is defined simultaneously with the Γ ⊢ 𝑒1
As the Γ ⊢ 𝑒1
judgement, we prove the theorem by simultaneous induction on both of these judgements. We also
val
∀ Γ.𝑗 judgement to strengthen the inductive hypotheses to account for variables. Recall
use the
val
that if Γ = (cid:174)𝑥 : (cid:174)𝜏, then the judgement
∀ Γ.𝑗 holds if for all (cid:174)𝑣 where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣, it is
the case that [(cid:174)𝑣/(cid:174)𝑥] 𝑗 holds (implicitly, we omit any primitive operations from the context Γ = (cid:174)𝑥 : (cid:174)𝜏
as to not range over all possible meanings for LambdaPix’s primitive operations). The theorem we
wish to show by induction is then:
𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ then

then 𝑒1 (cid:27) 𝑒2 : 𝜏

• If Γ ⊢ 𝑒1

(cid:18)val
∀ Γ′.𝜎

val
∀ Γ.

if

(cid:19)

(cid:18)

(cid:19)

.

• If Γ ⊢ 𝑒1

𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′ then

val
∀ Γ.

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then 𝑒1 (cid:27) 𝑒2 : 𝜏

(cid:19)

.

We first verify that the above statements imply the soundness theorem. Indeed, when Γinitial ⊢
. Since Γinitial contains only primitive
𝑒1

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ we have

then 𝑒1 (cid:27) 𝑒2 : 𝜏

(cid:18)val
∀ Γ′.𝜎

val
∀ Γinitial

if

(cid:18)

(cid:19)

(cid:19)

.

operations, which are omitted from the

variables, so we have that if
allows us to conclude that 𝑒1 (cid:27) 𝑒2 : 𝜏.

val
∀ Γ.𝑗 judgment, the outer quantifier quantifies over no
val
∀ Γ′.𝜎

then 𝑒1 (cid:27) 𝑒2 : 𝜏. This together with the assumption that

(cid:19)

(cid:18)val
∀ Γ′.𝜎

The full proof of each rule’s soundness has 18 cases and uses 14 lemmas and can be found in A.

Two cases are included below as examples:

Isorecord : Let Γ = (cid:174)𝑥 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖
[(cid:174)𝑣/(cid:174)𝑥]

.𝜎1 ∧ . . . 𝜎𝑛

,...,Γ′
𝑛

(cid:19)

(cid:18)val
∀ Γ′
1

. It must be shown that [(cid:174)𝑣/(cid:174)𝑥] ({ℓ1 = 𝑒1, . . . , ℓ𝑛 = 𝑒𝑛 } (cid:27) {ℓ1 = 𝑒 ′
1

: 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume
, . . . , ℓ𝑛 =

𝑒 ′
𝑛 }).

Lemma 6.3. If 𝑒1 (cid:27) 𝑒2 : 𝜏, 𝑒1

⇒ 𝑣2, then for all patterns 𝑝 where 𝑝 :: 𝜏 ⊣ Γ, it is the
𝑝. Proof: by induction on 𝑒1 (cid:27) 𝑒2 : 𝜏. If
case that either 𝑣1
𝑝 ⊣ 𝐵 or 𝑣1 \
(cid:12)
𝜏 = 𝜏1 → 𝜏2 then by inversion of 𝑝 :: 𝜏 ⊣ Γ, 𝑝 must either be a wildcard or a variable. Then by Match1
𝑝 ⊣ 𝐵. If 𝜏 isn’t an arrow type, then we conclude by EQ2.
and Match2, we have that 𝑣1

𝑝 and 𝑣2 \
(cid:12)

⇒ 𝑣1, and 𝑒2

𝑝 ⊣ 𝐵 and 𝑣2

𝑝 ⊣ 𝐵 and 𝑣2

(cid:12)

(cid:12)

(cid:12)

(cid:12)

By conjunction and that all the Γ′

.𝜎𝑖 . Then by the
inductive hypotheses, we have that [(cid:174)𝑣/(cid:174)𝑥] (𝑒𝑖 (cid:27) 𝑒 ′
𝑖 : 𝜏𝑖 ). Since we are only concerned with proving
our approach sound over valuable expressions, without loss of generality, we can assume that
[(cid:174)𝑣/(cid:174)𝑥]𝑒𝑖
𝑖 . By Lemma 6.3, we have that for all 𝑝𝑖
⇒ 𝑣𝑖 and [(cid:174)𝑣/(cid:174)𝑥]𝑒 ′
𝑖
where 𝑝𝑖 :: 𝜏𝑖 ⊣ Γ𝑖 , either 𝑣𝑖

𝑖 are disjoint, we have that for all 𝑖 ∈ [𝑛],

𝑝𝑖 and 𝑣 ′

𝑖 for some values 𝑣𝑖 and 𝑣 ′
𝑝𝑖 ⊣ 𝐵𝑖 or 𝑣𝑖 \
𝑝𝑖 ⊣ 𝐵𝑖 and 𝑣 ′
𝑖
(cid:12)

⇒ 𝑣 ′

𝑖 \
(cid:12)

𝑝𝑖 .

(cid:12)

(cid:12)

val
∀ Γ′
𝑖

(cid:90)
(cid:90)
(cid:90)
(cid:90)
20

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

To appeal to EQ2, let 𝑝 be an arbitrary pattern such that 𝑝 :: {ℓ1 : 𝜏1, . . . , ℓ𝑛 : 𝜏𝑛 } ⊣ Γ′. We proceed

by cases:

• In the case that for all 𝑖 ∈ [𝑛] 𝑣𝑖

𝑝𝑖 ⊣ 𝐵𝑖 and 𝑣 ′
𝑖

𝑝𝑖 ⊣ 𝐵𝑖 , by Match5 we have {ℓ1 =

𝑣1, . . . , ℓ𝑛 = 𝑣𝑛 }

𝑝 ⊣ 𝐵1 . . . 𝐵𝑛 and {ℓ1 = 𝑣 ′
1

(cid:12)

• In the case that there is some 𝑖 ∈ [𝑛] where 𝑣𝑖 \
(cid:12)
𝑝.
𝑝 and {ℓ1 = 𝑣 ′
1

(cid:12)
𝑣1, . . . , ℓ𝑛 = 𝑣𝑛 } \
, . . . , ℓ𝑛 = 𝑣 ′
(cid:12)
Since in all cases either {ℓ1 = 𝑣1, . . . , ℓ𝑛 = 𝑣𝑛 }
, . . . , ℓ𝑛 = 𝑣 ′
{ℓ1 = 𝑣1, . . . , ℓ𝑛 = 𝑣𝑛 } \
(cid:12)

𝑝 and {ℓ1 = 𝑣 ′
1
[(cid:174)𝑣/(cid:174)𝑥] ({ℓ1 = 𝑒1, . . . , ℓ𝑛 = 𝑒𝑛 } (cid:27) {ℓ1 = 𝑒 ′
1

𝑛 } \
(cid:12)
𝑝 ⊣ 𝐵 and {ℓ1 = 𝑣 ′
1
(cid:12)
𝑝, by EQ2, we may conclude
𝑛 } \
(cid:12)
, . . . , ℓ𝑛 = 𝑒 ′

𝑛 })

, . . . , ℓ𝑛 = 𝑣 ′

𝑛 }

(cid:12)
, . . . , ℓ𝑛 = 𝑣 ′
𝑛 }
(cid:12)
𝑝𝑖 and 𝑣 ′

𝑝 ⊣ 𝐵1 . . . 𝐵𝑛.
𝑖 \
(cid:12)

𝑝𝑖 , by Match6 we have {ℓ1 =

𝑝 ⊣ 𝐵 or

(cid:12)

Isoapplication2 : Let Γ = (cid:174)𝑧 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume
[(cid:174)𝑣/(cid:174)𝑧]

. It must be shown that [(cid:174)𝑣/(cid:174)𝑧] (𝑥 𝑒1 (cid:27) 𝑒2).

(cid:18)val
∀ Γ′.𝜎

(cid:19)

By the inductive hypothesis we have
(cid:18)val
∀ Γ′.𝜎

val
∀ Γ,𝑦:𝜏 .

if

(cid:18)

(cid:19)

then 𝑦 (cid:27) [𝑦/(𝑥 𝑒1)]𝑒2 : 𝜏

(cid:19)

Since we are only concerned with proving our approach sound over valuable expressions, without
⇒ 𝑤 for some value 𝑤 such that Γ ⊢ 𝑤 : 𝜏 and 𝑤 val.

loss of generality, we can assume that 𝑥 𝑒1
Since 𝑦 is fresh, the inductive hypothesis written above implies

if [𝑤/𝑦] [(cid:174)𝑣/(cid:174)𝑧]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then [𝑤/𝑦] [(cid:174)𝑣/(cid:174)𝑧] (𝑦 (cid:27) [𝑦/(𝑥 𝑒1)]𝑒2 : 𝜏)

By assumption, we already have [𝑤/𝑦] [(cid:174)𝑣/(cid:174)𝑧]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

. Therefore we have

which is equivalent to

[𝑤/𝑦] [(cid:174)𝑣/(cid:174)𝑧] (𝑦 (cid:27) [𝑦/(𝑥 𝑒1)]𝑒2 : 𝜏)

[(cid:174)𝑣/(cid:174)𝑧] (𝑤 (cid:27) [𝑤/(𝑥 𝑒1)]𝑒2 : 𝜏)

Since 𝑥 𝑒1

⇒ 𝑤, the two are extensionally equivalent. By the referential transparency of Lamb-

daPix, the above expression is equivalent to

which is simply

[(cid:174)𝑣/(cid:174)𝑧] (𝑥 𝑒1 (cid:27) [(𝑥 𝑒1)/(𝑥 𝑒1)]𝑒2 : 𝜏)

[(cid:174)𝑣/(cid:174)𝑧] (𝑥 𝑒1 (cid:27) 𝑒2 : 𝜏)

7 EXPERIMENTAL RESULTS
We implemented our approach in a tool called zeus to serve as a grading assistant by clustering
equivalent programs into equivalence classes. The goal of our evaluation is to answer the following:
Q1. Can zeus automatically identify equivalent programs in programming assignments for

introductory functional programming courses?
Q2. How many equivalence classes are found by zeus?
Q3. What is the runtime performance of zeus?

(cid:90)
(cid:90)
Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

21

7.1 Implementation
zeus is implemented in Standard ML and is publicly available as open-source at https://github.com/
CMU-TOP/zeus. zeus takes as input a set of homework assignments from an introductory functional
programming course at the college level taught in Standard ML. Each submission is transpiled
from Standard ML into LambdaPix, and then zeus is run pairwise on the transpiled expressions
and outputs a logical formula. If this formula is valid, then both expressions are algorithmically
similar and guaranteed to be equivalent, so they are placed into the same equivalence class. As
an optimization, since extensional equivalence is transitive, if zeus verifies that two programs 𝑝1
and 𝑝2 are (not) equivalent, and that 𝑝1 is also (not) equivalent to 𝑝3, then zeus does not check
that 𝑝2 is equivalent to 𝑝3. This optimization significantly reduces the number of comparisons that
otherwise would be quadratic in the number of assignments.

In the definition of LambdaPix, we assumed an arbitrary fixed set of disjoint algebraic datatypes
with unique associated injection labels. This is unrealistic for an implementation since Standard ML
includes datatype declarations. Our transpilation from Standard ML to LambdaPix instead scrapes
all datatype declarations from the original Standard ML submission and uses those datatypes and
their constructors as LambdaPix’s set of datatypes and injection labels.

To determine the validity of the formulas generated by zeus, we use the SMT solver Z3 [de Moura
and Bjørner 2008] using the theory of quantifier-free linear integer arithmetic and the theory of
datatypes. From the theory of quantifier-free linear integer arithmetic, we use the built-in functions
“+”, “−”, “∗”, “≤”, “<”, “≥”, and “>”, corresponding to the primitive operations of LambdaPix. We
use the theory of datatypes to represent base terms of all types aside from ints and booleans.

Although we only use these two theories in zeus, nothing restricts a different implementation
from using additional theories. For instance, another implementation could leverage the theory of
strings by adding strings as a base type in LambdaPix and adding the SMT solver’s built-in string
functions to LambdaPix’s set of primitive operations.

7.2 Benchmarks
To evaluate zeus, we used more than 4,000 student submissions from an introductory functional
programming course. The number of submissions varies between 318 and 351 per assignment.
Table 1 describes the twelve assignments that were used in our evaluation. These assignments show
a large diversity of programs that includes different datatypes and the use of pattern matching and
are a good test suite to test the applicability of zeus as a grading assistant. Figure 18 shows some of
the datatype declarations that are assumed by the homework assignments presented in Table 1.

datatype 'a tree = Empty | Node of 'a tree * 'a * 'a tree
datatype 'a shrub = Leaf of 'a | Branch of 'a shrub * 'a shrub
datatype prop = Const of bool | Var of string | Not of prop

| And of prop * prop | Or of prop * prop

Fig. 18. Datatype declarations assumed by homework assignments

7.3 Clustering of equivalent programs
Tables 2 and 3 analyze the equivalent classes detected by zeus. In particular, for each task, Table 2
shows the number of submissions (#), the number of equivalent classes (ECs), the number of
equivalence classes that contain 90% and 75% of the submissions (90th and 75th Percentile ECs,
respectively), the number of equivalent classes containing more than 1 submission (Non-singleton

22

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

Table 1. Description of homework assignments used in our evaluation

Function
concat

Signature
int list list → int list

prefixSum

int list → int list

countNonZero

int tree → int

quicksort

slowDoop

differentiate

integrate

treefoldr

treeReduce

findN

sat

(’a * ’a → order) * ’a list
→ ’a list
(’a * ’a → order) * ’a list
→ ’a list
(int → real) → (int →
real)
(int → real) → real →
(int → real)

(’a * ’b → ’b) → ’b → ’a
tree → ’b
(’a * ’a → ’a) → ’a → ’a
tree → ’a

(’a → bool) → (’a * ’a →
bool) → ’a shrub → int
→ (’a list → ’b) → (unit
→ ’b) → ’b

prop → ((string * bool)
list → ’a) → (unit → ’a)
→ ’a

findPartition

’a list → (’a list → bool)
→ (’a list → bool) →
bool

Description
concat takes a list of int lists and returns their con-
catenation without using the built-in “@” function
prefixSum replaces each i-th element in an int list
with the sum of the list’s first 𝑖 + 1 elements
countNonZero takes an int tree T and returns the
number of nonzero nodes in T
quicksort implements the quicksort algorithm

slowDoop takes a comparison function and uses
it to remove all duplicates in a list
differentiate differentiates a polynomial that is
represented with the type int → real
integrate takes a polynomial p and a real c and
returns the antiderivative of p with constant of
integration c
(treefoldr g init T) returns (foldr g init L) where L
is the inorder traversal of T
treeReduce is the same as treefoldr except that it
must have 𝑂 (𝑙𝑜𝑔 𝑛) span assuming g is associative
and init is an identity for g
(findN p eq T n s k) returns s [x1, . . . , xn] where
[x1, . . . , xn] are the leftmost values for T such that
for all 𝑖 from 1 to 𝑛, p xi returns true and the xi’s
are eq-distinct. (findN p eq T n s k) returns k() if
no such [x1, . . . , xn] exist
sat takes in a proposition, a success function s
from a list assigning booleans to free variables to
’a, and a failure function from unit to ’a. If the
proposition is satisfiable by an assignment of free
variables A, then sat returns s(A). Otherwise, it
returns k()
(findParition A pL pR) returns true if there exist
an L and R such that (L, R) is a partition of A where
pL accepts L and pR accepts R. (findPartition A pL
pR) returns false otherwise

ECs), and the percentage of submissions found equivalent to at least one other submissions (% in
Non-singleton ECs). Table 3 shows the number of correct and incorrect student submissions, the
number of equivalence classes containing only correct or incorrect submissions, and the number of
equivalence classes containing multiple correct or incorrect submissions. There were no equivalence
classes that contained both correct and incorrect submissions.

A common trend among all tasks was that a significant majority of student submissions were
placed into a relatively small number of large equivalence classes, with the remaining submissions
widely dispersed among many small equivalence classes, frequently of size 1. For instance, for
the task concat, zeus detected 40 equivalent classes. However, only 10 of those classes contain

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

23

Table 2. Analysis of the number of equivalent classes (ECs)

#

ECs

treefoldr
integrate
slowDoop
countNonZero
concat
treeReduce
prefixSum
differentiate
quicksort
findN
findPartition
sat

332
323
347
351
351
332
351
316
347
330
331
318

22
34
30
29
40
57
68
65
73
73
83
104

90th
Percentile
ECs
3
4
6
8
8
24
33
34
39
40
50
73

75th
Percentile
ECs
1
1
2
4
2
8
7
3
9
7
12
25

Non-
singleton
ECs
9
5
12
13
10
20
23
6
18
18
22
14

% in Non-
singleton
ECs
96
91
95
95
91
89
87
81
84
83
82
72

Table 3. Analysis of correctness of student submissions

Correct
Submissions

Correct
ECs

treefoldr
integrate
slowDoop
countNonZero
concat
treeReduce
prefixSum
differentiate
quicksort
findN
findPartition
sat

302
307
346
346
336
188
347
308
328
296
291
273

12
23
29
26
30
18
64
59
56
48
59
72

Non-
singleton
Correct
ECs
4
3
12
12
9
8
23
5
16
14
13
11

Incorrect
Submissions

Incorrect
ECs

30
16
1
5
15
144
4
8
19
34
40
45

10
11
1
3
10
39
4
6
17
25
24
32

Non-
singleton
Incorrect
ECs
5
2
0
1
1
12
0
1
2
4
9
3

more than one submission, and 8 equivalence classes contain more than 90% of the submissions. In
almost all tasks, the largest equivalence classes consisted of various distinct but correct solutions to
the problem. The one exception to this trend was that in the task treeReduce, a significant number
of students mistook associativity for commutativity or otherwise assumed that the function passed
into treeReduce was necessarily commutative. This common misunderstanding resulted in a large
number of incorrect submissions for treeReduce, but because the misunderstanding was common,
zeus was still able to place the majority of incorrect submissions into a small number of large
equivalence classes. In all tasks, at least 72% of submissions were identified as equivalent to at least
one other submission. These results support the hypothesis that zeus can be used as a grading

24

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

Table 4. Runtime analysis

#

Total Time (s)

treefoldr
integrate
slowDoop
countNonZero
concat
treeReduce
prefixSum
differentiate
quicksort
findN
findPartition
sat

332
323
347
351
351
332
351
316
347
330
331
318

33.701
45.833
57.564
72.268
76.110
146.830
205.695
140.797
210.554
202.577
284.502
486.218

Number of
Comparisons
694
991
1,201
1,578
1,614
3,089
4,112
3,025
4,303
3,660
4,807
6,532

Average Time (s)

0.049
0.046
0.048
0.046
0.047
0.048
0.050
0.047
0.049
0.055
0.059
0.074

assistant to reduce the workload of instructors in reviewing equivalent code, thus freeing their
time to provide more detailed feedback.

7.4 Runtime performance
Table 4 shows the time needed by zeus to cluster all assignments for a given task when running on
a common Mac laptop with a 1.6GHz processor and 4 GB of RAM. Specifically, for each task, it
shows the number of submissions, the total time to cluster submissions in seconds, the number of
pairwise comparisons performed during clustering, and the average time for a single comparison
in seconds. The average time to compare two individual submissions is small and it ranges from
0.046 seconds to 0.074 seconds. When performing the clustering of a given assignment, we can
observe that the number of comparisons is much less than quadratic and that the total time varies
between 1 and 8 minutes. This shows that zeus is efficient in practice and can be used in real-time
to help instructors grade assignments.

7.5 Discussion
We manually inspected the cases where zeus did not put two programs in the same equivalence
class. The most common reasons for this were the following:

• The two programs are not equivalent: since these programs correspond to actual student
submissions, not all of the programs are correct. When an incorrect implementation produces
the wrong output on any number of inputs, our algorithm appropriately puts it in a different
equivalence class from the correct submissions. Additionally, for the sat task, the correct
behavior of this function when an input proposition is satisfiable by multiple assignments is
not fully defined. If multiple assignments A satisfy the proposition, there are no rules about
which A to use when returning s(A). So for this task, two correct submissions could produce
different outputs.

• The two programs use different recursive helper functions: we found cases where equivalence
classes were distinguished by the structure of the helper functions students created. Since our
current inference rules do not consider these cases, zeus fails to recognize that two programs
are equivalent if they use recursive helper functions with different input structures.

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

25

• The two recursive programs use different base cases: our algorithm’s treatment of fixed points
causes it to never peer into a recursive call. Our algorithm’s treatment of case expressions
causes it to only recognize two expressions as equivalent if they handle all inputs in basically
the same way. Together, these have the implication that when one expression treats a certain
input as a base case while the other expression treats it as a recursive case, then the algorithm
will be unable to recognize the expressions as equivalent.

• One of the programs uses built-in Standard ML functions: seven out of the twelve tasks involve
list manipulation operations. For instance, the top five tasks with the largest number of
equivalence classes (sat, findPartition, findN, quicksort, and prefixSum) correspond to tasks
that involve list manipulation. Many of the submissions for these tasks use built-in Standard
ML functions for list reversal or list concatenation. We did not use a theory of list structures
in our SMT Solver, so we were only able to recognize two expressions as equivalent if they
used these built-in functions on the same input inputs and order or if they did not use these
built-in functions at all.

We note that even with the current limitations, zeus already shows that it can efficiently cluster
the majority of the submissions into a few equivalence classes. Also, zeus could be extended by
adding additional inference rules or support for additional SMT theories that would allow the
identification of equivalent programs that are currently missed by zeus.

8 RELATED WORK
Proving that two problems are equivalent is a well-studied topic and has many applications ranging
from hardware equivalence [Berman and Trevillyan 1989], compiler optimizations [Zuck et al. 2002],
to program equivalence [Godlin and Strichman 2009]. However, the use of program equivalence
for grading programming assignments is scarce [Kaleeswaran et al. 2016]. In this section, we cover
related work from program equivalence and automatic grading that is closer to our approach.

8.1 Program Equivalence

Program Verification. The problem of program equivalence can be reduced to a verification
problem by showing that both programs satisfy the same specification. For instance, model-checking
techniques [Clarke et al. 2004, 2001] can be used to show that two C programs satisfy the same
specification. This specification can be written to ensure that for the same input, the programs are
equivalent if they always produce the same output. Fedyukovich et al. [Fedyukovich et al. 2016]
present techniques for proving that two similar programs have the same property rather than being
equivalent. Their approach requires formally verifying one of the programs and using this proof to
check the validity of the property in the other program by establishing a coupling between the two
programs. A similar approach can also be done for functional programs. For instance, one could
write a formal specification of the functionality of a program in Why3ML [Bobot et al. 2015]. We
tried this approach by writing a formal specification for programming assignments for the function
concat, however, the Why3 framework [Bobot et al. 2015] was not able to prove that the program
satisfied the specification. In general, proving the program equivalence concerning a specification
is a more challenging task than the one we address in this paper since we can take advantage of
program structure to prove that they are equivalent.

Regression Verification. In regression verification [Felsing et al. 2014; Godlin and Strichman 2009],
the goal is to prove that two versions of a program are equivalent. One approach is to transform
loops in programs to recursive procedures and to match the recursive calls in both programs and
abstract them via uninterpreted functions [Godlin and Strichman 2009]. Other approaches use
invariant inference techniques to prove the equivalence of programs with loops [Felsing et al. 2014].

26

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

By using these techniques, one can encode the two versions of the program into Horn clauses and
use constraint solvers to automatically find certain kinds of invariants. Alternatively, one can also
use symbolic execution and static analysis to generate summaries of program behaviors that capture
the modifications between the programs. These summaries can be encoded into logical formulas
and their equivalence can be checked using SMT solvers [Backes et al. 2013]. Our approaches
also consider that student submissions are similar but they are not different versions of the same
program. Even though we do not use any invariant generation techniques, this is orthogonal to our
approach and could increase the number of equivalent classes detected for recursive programs.

Contextual Equivalence. There is a broad set of work that targets contextual equivalence for
functional programs. Approaches based on step-indexed logical relations [Ahmed et al. 2009; Ahmed
2006; Dreyer et al. 2009] or on bisimulations [Hur et al. 2012; Koutavas and Wand 2006; Sumii and
Pierce 2005] have been used to prove context equivalence of functional programs with different
fragments of ML that often include finite datatypes and integer references. While these approaches
are more theoretical and focus on functional programs with state, we do not support state but can
handle pattern matching which is crucial for a practical tool to cluster programming assignments
of introductory functional courses. The closest approach to ours is the one recently presented by
Jaber [Jaber 2020]. Jaber presents techniques for checking the equivalence of OCaml programs with
state. His approach focuses in particular on contextual equivalence and developing a framework in
which references can be properly accounted for. Our approach neglects references, as we require
programs to be purely functional, but includes a more comprehensive treatment of datatypes. We
attempted to compare our zeus’s performance against Jaber’s SyTeCi prototype, but unfortunately,
all of our benchmarks included datatypes that were not supported by the available prototype.

8.2 Automatic grading

Clustering similar assignments. To help instructors to grade programming assignments, several
automatic techniques have been proposed to cluster similar assignments into buckets with the
purpose of giving automatic feedback [Gulwani et al. 2018; Kaleeswaran et al. 2016; Pu et al. 2016;
Wang et al. 2018]. Our approach differs from these since our goal is not to replace the instructor or
to fully automate the grading but rather to use zeus as a grading assistant with formal guarantees.
CLARA [Gulwani et al. 2018] cluster correct programs and selects a canonical program from
each cluster to be considered as the reference solution. In this approach, a pair of programs 𝑝1 and
𝑝2 are said to be dynamic equivalent if they have the same control-flow and if related variables
in 𝑝1 and 𝑝2 always have the same values, in the same order, during the program execution on
the same inputs. In contrast, our approach has a stronger notion of equivalence since we do not
depend on dynamic program analysis. CodeAssist [Kaleeswaran et al. 2016] clusters submissions
for dynamic programming assignments by their solution strategy. They consider a small set of
features and if two programs share these features then they are put in the same cluster. Other
clustering approaches are based on deep learning techniques [Pu et al. 2016] and also provide no
formal guarantees about the quality of the clustering. SemCluster [Perry et al. 2019] improves
upon other clustering techniques by considering semantic program features. They use control flow
features and data flow features to represent each program and merge this information to create a
program feature vector. K-means clustering is used to cluster all programs based on the program
feature vectors. Even though there are no formal guarantees for the equivalence of programs in
each cluster, experimental results [Perry et al. 2019] show that the number of clusters found by
SemCluster is much smaller than competitive approaches.

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

27

Automatic repair. AutoGrader [Singh et al. 2013] takes as input a reference solution and an error
model that consists of potential corrections and uses constraint solving techniques to find a mini-
mum number of corrections that can be used to repair the incorrect student solution. Sarfgen [Wang
et al. 2018] uses a three-stage algorithm based on search, align, and repair. It starts by searching for
a small number of correct programs that can be used to repair the incorrect submission and have
the same control-flow structure. Next, they compute a syntactic distance between those programs
using an embedding of ASTs into numerical vectors. These programs are then aligned and the
differences between aligned statements can suggest corrections that can be repaired automatically.
Automatic repair is better suited for Massive Open Online Courses where a fully automated
method is needed, while our approach is better suited for large, in-person courses, where the
feedback of instructors can be more beneficial. The feedback returned by automatic repair tools is
limited to changes in the code, while our approach is meant to assist instructors to provide more
detailed feedback for students. Each equivalent class will have specific comments that are more
helpful to the student than a repaired version of their submission. Moreover, while our approach can
be used for both correct and incorrect submissions, automatic repair is only useful to fix incorrect
submissions and cannot give any feedback for different implementations of correct submissions.
Formal guarantees. Liu et al. [Liu et al. 2019] proposes to automatically determine the correctness
of an assignment against a reference solution. Instead of using test cases, they use symbolic
execution to search for semantically different execution paths between a student’s submission and
the reference solution. If such paths exist, then the submission is considered incorrect and feedback
can be provided by using counterexamples based on path deviations. Our approach is not based on
symbolic execution but instead uses inference rules to derive a formula for which both student
submissions are equivalent if and only if they have the same structure and the observable behavior.
CodeAssist [Kaleeswaran et al. 2016] checks equivalence of a candidate submission from a cluster
with a correct solution of that cluster that has been previously validated by an instructor. They
exploit the fact of just handling dynamic programming assignments to establish a correspondence
between variables and control locations of the two programs. Using this correspondence, they can
encode the problem into SMT and prove program equivalence. Our approach is more general since
our inference rules simulate relationships between expressions of the two programs and can be
applied to several problem domains and not just dynamic programming assignments.

9 CONCLUSION
We present techniques for checking for equivalence between purely functional programs. Guided
by inference rules that inform needed equivalences between two programs’ subexpressions, our
approach simultaneously deconstructs the expressions being compared to build up a formula that
is valid only if the expressions are equivalent. We prove the soundness of our approach: if our
approach takes in two expressions of the same type and outputs a valid formula, then the two
expressions are equivalent. We implement our approach and show that it can assist grading by
clustering over 4,000 real student code submissions from an introductory functional programming
class taught at the undergraduate level.

A APPENDIX
Here we include the full proof that our approach is sound. This proof makes use of a few lemmas:
𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′, then Γ and Γ′ are disjoint. Proof : by
Lemma 1: if Γ ⊢ 𝑒1
𝜎
induction on Γ ⊢ 𝑒1
←→ 𝑒2 : 𝜏 ⊣ Γ′
Lemma 2: WHNF reduction preserves equivalence:
if 𝑒 ′
1

2, then 𝑒1 (cid:27) 𝑒2. Proof : By induction on 𝑒 (cid:123) 𝑒 ′ and appealing to the

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ or Γ ⊢ 𝑒1
𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ and Γ ⊢ 𝑒1

1, and 𝑒2 ↓ 𝑒 ′

2, 𝑒1 ↓ 𝑒 ′

(cid:27) 𝑒 ′

28

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:27) 𝑒 ′

2, 𝑒1 (cid:123) 𝑒 ′

𝑝 ⊣ 𝐵 and 𝑣2

⇒ 𝑣1, and 𝑒2

1, and 𝑒1 (cid:123) 𝑒 ′

𝑝 and 𝑣2 \
(cid:12)

𝑝 ⊣ 𝐵, and freshen 𝑝.𝑒 ↩→ 𝑝 ′.𝑒 ′, then 𝑣

2 then 𝑒1 (cid:27) 𝑒2. The rest goes through by

dynamics, we have that if 𝑒 ′
1
induction on 𝑒 ↓ 𝑒 ′.
Lemma 3: If 𝑒1 ≡ 𝑒2, 𝑒1 Term, 𝑒2 Term, and 𝑒1 and 𝑒2 are both closed expressions (as opposed to
patterns or open terms), then 𝑒1 (cid:27) 𝑒2. Proof : By induction on 𝑒 Term and from the definition of ≡
given in section 4.1.
Lemma 4: If 𝑒1 (cid:27) 𝑒2 : 𝜏, 𝑒1
⇒ 𝑣2, then for all patterns 𝑝 where 𝑝 :: 𝜏 ⊣ Γ, it is the
𝑝. Proof : by induction on 𝑒1 (cid:27) 𝑒2 : 𝜏.
𝑝 ⊣ 𝐵 or 𝑣1 \
case that either 𝑣1
(cid:12)
(cid:12)
If 𝜏 = 𝜏1 → 𝜏2 then by inversion of 𝑝 :: 𝜏 ⊣ Γ, 𝑝 must either be a wildcard or a variable. Then by
Match1 and Match2, we have that 𝑣1
𝑝 ⊣ 𝐵. If 𝜏 is not an arrow type, then we
𝑝 ⊣ 𝐵 and 𝑣2
conclude by EQ2.
val
Lemma 5: If Γ ⊢ 𝑒 : 𝜏, 𝑒 Term, and 𝑒 is in weak head normal form, then
∀ Γ.(𝑒 val or 𝑒 = 𝑜 𝑒 ′) for
some primitive operation 𝑜 and expression 𝑒 ′. Proof : by induction on 𝑒 Term and appealing to the
dynamics.
Lemma 6: If Γ ⊢ 𝑣 : 𝜏, 𝑝 :: 𝜏 ⊣ Γ′, Γ, Γ′ ⊢ 𝑒 : 𝜏 ′, 𝑣
and [𝐵]𝑒 = [𝐵 ′]𝑒 ′. Proof : by induction on freshen 𝑝.𝑒 ↩→ 𝑝 ′.𝑒 ′.
𝑝 ⊣ 𝐵 then 𝑣 ≡ [𝐵]𝑝. Proof : by induction on 𝑣
Lemma 7: If 𝑣
𝑝 then 𝑣 (cid:46) 𝑝. Proof : by induction on 𝑣 \
≡. Lemma 8: If 𝑣 \
(cid:12)
(cid:12)
Lemma 9: If Γ ⊢ 𝑣 : 𝜏, 𝑝1 :: 𝜏 ⊣ Γ′, Γ, Γ′ ⊢ 𝑒 : 𝜏 ′, and EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝 ′.𝑒 ′
1
𝑝1 and 𝑣 \
𝑝 ′ ⊣ 𝐵 ′ and [𝐵]𝑒 = [𝐵 ′]𝑒 ′) or (𝑣 \
(𝑣
(cid:12)
(cid:12)
EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝 ′.𝑒 ′
𝑝.
𝑝 ⊣ 𝐵 and 𝑣 \
1
(cid:12)
Lemma 10: If Γ ⊢ 𝑣 : 𝜏, 𝑝2 :: 𝜏 ⊣ Γ′, Γ, Γ′ ⊢ 𝑒 : 𝜏 ′, and EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝 ′.𝑒 ′
1
𝑝2 and 𝑣 \
(𝑣
𝑝 ′ ⊣ 𝐵 ′ and [𝐵]𝑒 = [𝐵 ′]𝑒 ′) or (𝑣 \
(cid:12)
(cid:12)
EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝 ′.𝑒 ′
𝑝.
𝑝 ⊣ 𝐵 and 𝑣 \
, 𝑝 ′.𝑒 ′
1
𝑠
(cid:12)
Lemma 11: If Γ ⊢ 𝑣 : 𝜏 and FT({𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }, {. . .})
↩−→ ({𝑝 ′
1 | . . . | 𝑝 ′
.𝑒 ′
1
for all 𝑖 ∈ [𝑛], either (𝑣
𝑖 ]) or (𝑣 \
𝑝𝑖 ⊣ 𝐵, 𝑣
(cid:12)
induction on FT and appealing to Lemma 9.
𝑠
Lemma 12: If Γ ⊢ 𝑣 : 𝜏 and FT({. . .}, {𝑝1.𝑒1 | . . . | 𝑝𝑚.𝑒𝑚 })
↩−→ ({. . .′}, {𝑝 ′
1 | . . . | 𝑝 ′
.𝑒 ′
1
for all 𝑗 ∈ [𝑚], either (𝑣
𝑝 𝑗 and 𝑣 \
𝑗 ]) or (𝑣 \
(cid:12)
(cid:12)
by induction on FT and appealing to Lemma 10.
𝑠
Lemma 13: If Γ ⊢ 𝑣 : 𝜏 and FT({𝑀 }, {𝑀 ′})
↩−→ ({𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }, {𝑝 ′
𝑚.𝑒 ′
1 | . . . | 𝑝 ′
.𝑒 ′
𝑚 }) then
1
case 𝑣 {𝑀 } (cid:27) case 𝑣 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } and case 𝑣 {𝑀 ′} (cid:27) case 𝑣 {𝑝 ′
𝑛 }. Proof : by
𝑛.𝑒 ′
1 | . . . | 𝑝 ′
.𝑒 ′
1
Lemmas 11 and 12 and appealing to Dyn10.
Lemma 14: If FT({𝑀 }, {𝑀 ′})
𝑝𝑖 = 𝑝 ′
𝑝 ′ in both of the new bindings.

𝑚.𝑒 ′
𝑖 . Proof : By induction on FT and the fact that EB(𝑝1.𝑒1, 𝑝2.𝑒2) ↩→ (𝑝 ′.𝑒 ′
1

(cid:12)
𝑖 ⊣ 𝐵 ′ and [𝐵] [𝑒𝑖 ] = 𝐵 ′[𝑒 ′
𝑝 ′

𝑝 and from the definition of ≡.
, 𝑝 ′.𝑒 ′

2) then
𝑝 ′). Proof : by induction on

2) then
𝑝 ′). Proof : by induction on

𝑚 }), then for all 𝑖 ≤ 𝑠,
2) uses the same

𝑠
↩−→ ({𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }, {𝑝 ′
1

𝑝 ⊣ 𝐵 and from the definition of

𝑛 }, {. . .′}) then
𝑖 ). Proof : by
𝑝 ′

𝑗 ⊣ 𝐵 ′ and [𝐵] [𝑒 𝑗 ] = 𝐵 ′[𝑒 ′
𝑝 ′

𝑚.𝑒 ′
𝑝𝑖 and 𝑣 \
(cid:12)

𝑚.𝑒 ′
𝑚 }) then
𝑗 ). Proof :
𝑝 ′

2) and appealing to 𝑣

2) and appealing to 𝑣

1 | . . . | 𝑝 ′
.𝑒 ′

𝑝2 ⊣ 𝐵, 𝑣

𝑝1 ⊣ 𝐵, 𝑣

𝑝 𝑗 ⊣ 𝐵, 𝑣

𝑝 ′ ⊣ 𝐵 ′

, 𝑝 ′.𝑒 ′

, 𝑝 ′.𝑒 ′

, 𝑝 ′.𝑒 ′

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

Using these lemmas, we proceed to prove the soundness of each rule. We use the following inductive
hypothesis:

• If Γ ⊢ 𝑒1

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ then

val
∀ Γ.

• If Γ ⊢ 𝑒1

𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′ then

val
∀ Γ.

(cid:18)

if

if

(cid:18)

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then 𝑒1 (cid:27) 𝑒2 : 𝜏

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then 𝑒1 (cid:27) 𝑒2 : 𝜏

(cid:19)

.

.

(cid:19)

In cases where the exact type of the expressions are obvious or irrelevant, we use the shorthand
𝑒 (cid:27) 𝑒 ′ to mean that 𝑒 (cid:27) 𝑒 ′ : 𝜏 for some type 𝜏.

(cid:90)
(cid:90)
Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

29

• IsoExp: Let Γ = (cid:174)𝑥 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume

[(cid:174)𝑣/(cid:174)𝑥]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

. It must be shown that [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 (cid:27) 𝑒2).
(cid:18)val
∀ Γ′.𝜎

val
∀ Γ.

(cid:18)

if

By the inductive hypothesis, we have that

[(cid:174)𝑣/(cid:174)𝑥]

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then 𝑒 ′
1

(cid:27) 𝑒 ′
2

(cid:19)

then 𝑒 ′
1

(cid:27) 𝑒 ′
2

, and therefore

(cid:19)

(cid:19)

equivalently,

if [(cid:174)𝑣/(cid:174)𝑥]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then [(cid:174)𝑣/(cid:174)𝑥] (𝑒 ′
1

(cid:27) 𝑒 ′
2)

(cid:18)val
As we have [(cid:174)𝑣/(cid:174)𝑥]
∀ Γ′.𝜎
this implies that [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 (cid:27) 𝑒2) as desired.

(cid:19)

by assumption, we may conclude [(cid:174)𝑣/(cid:174)𝑥] (𝑒 ′
1

(cid:27) 𝑒 ′

2). By Lemma 2,

(cid:18)val
∀ ·.𝑒1 ≡ 𝑒2

(cid:19)

• Isoatomic : Let Γ = (cid:174)𝑥 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume

[(cid:174)𝑣/(cid:174)𝑥]
As [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 ≡ 𝑒2), 𝑒1 Term, and 𝑒2 Term, we have [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 (cid:27) 𝑒2) by Lemma 3.

, or equivalently [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 ≡ 𝑒2). It must be shown that [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 (cid:27) 𝑒2).

• Isorecord : Let Γ = (cid:174)𝑥 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume
. It must be shown that [(cid:174)𝑣/(cid:174)𝑥] ({ℓ1 = 𝑒1, . . . , ℓ𝑛 = 𝑒𝑛 } (cid:27) {ℓ1 =

.𝜎1 ∧ . . . 𝜎𝑛

[(cid:174)𝑣/(cid:174)𝑥]

,...,Γ′
𝑛

(cid:19)

(cid:18)val
∀ Γ′
1

𝑛 }).

, . . . , ℓ𝑛 = 𝑒 ′

𝑒 ′
1
By conjunction and that all the Γ′
.𝜎𝑖 . Then
by the inductive hypotheses, we have that [(cid:174)𝑣/(cid:174)𝑥] (𝑒𝑖 (cid:27) 𝑒 ′
𝑖 : 𝜏𝑖 ). Since we are only concerned
with proving our approach sound over valuable expressions, without loss of generality, we
can assume that [(cid:174)𝑣/(cid:174)𝑥]𝑒𝑖
𝑖 . By Lemma 4
we have that for all 𝑝𝑖 where 𝑝𝑖 :: 𝜏𝑖 ⊣ Γ𝑖 , either 𝑣𝑖
𝑝𝑖 .
𝑝𝑖 and 𝑣 ′
𝑖 \
(cid:12)

𝑖 for some values 𝑣𝑖 and 𝑣 ′
𝑝𝑖 ⊣ 𝐵𝑖 or 𝑣𝑖 \
𝑝𝑖 ⊣ 𝐵𝑖 and 𝑣 ′
𝑖
(cid:12)

𝑖 are disjoint, we have that for all 𝑖 ∈ [𝑛],

⇒ 𝑣𝑖 and [(cid:174)𝑣/(cid:174)𝑥]𝑒 ′
𝑖

val
∀ Γ′
𝑖

⇒ 𝑣 ′

(cid:12)

(cid:12)

To appeal to EQ2, let 𝑝 be an arbitrary pattern such that 𝑝 :: {ℓ1 : 𝜏1, . . . , ℓ𝑛 : 𝜏𝑛 } ⊣ Γ′. We
proceed by cases:
– In the case that for all 𝑖 ∈ [𝑛] 𝑣𝑖

𝑝𝑖 ⊣ 𝐵𝑖 and 𝑣 ′
𝑖

𝑣1, . . . , ℓ𝑛 = 𝑣𝑛 }

𝑝 ⊣ 𝐵1 . . . 𝐵𝑛 and {ℓ1 = 𝑣 ′
1

(cid:12)

(cid:12)

– In the case that there is some 𝑖 ∈ [𝑛] where 𝑣𝑖 \
𝑖 \
(cid:12)
(cid:12)
𝑛 } \
(cid:12)
𝑝 ⊣ 𝐵 and {ℓ1 = 𝑣 ′
𝑛 }
1
(cid:12)
𝑝, by EQ2, we may conclude
𝑛 } \
(cid:12)
𝑛 })

{ℓ1 = 𝑣1, . . . , ℓ𝑛 = 𝑣𝑛 } \
(cid:12)
Since in all cases either {ℓ1 = 𝑣1, . . . , ℓ𝑛 = 𝑣𝑛 }
𝑝 and {ℓ1 = 𝑣 ′
{ℓ1 = 𝑣1, . . . , ℓ𝑛 = 𝑣𝑛 } \
1
(cid:12)
[(cid:174)𝑣/(cid:174)𝑥] ({ℓ1 = 𝑒1, . . . , ℓ𝑛 = 𝑒𝑛 } (cid:27) {ℓ1 = 𝑒 ′
1

𝑝 and {ℓ1 = 𝑣 ′
1

(cid:12)
, . . . , ℓ𝑛 = 𝑣 ′

, . . . , ℓ𝑛 = 𝑒 ′

, . . . , ℓ𝑛 = 𝑣 ′

, . . . , ℓ𝑛 = 𝑣 ′

𝑝𝑖 ⊣ 𝐵𝑖 , by Match5 we have {ℓ1 =
(cid:12)
, . . . , ℓ𝑛 = 𝑣 ′
𝑛 }
(cid:12)
𝑝𝑖 and 𝑣 ′
𝑝.

𝑝𝑖 , by Match6 we have

𝑝 ⊣ 𝐵1 . . . 𝐵𝑛.

𝑝 ⊣ 𝐵 or

• Isoprojection : Let Γ = (cid:174)𝑥 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume

[(cid:174)𝑣/(cid:174)𝑥]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

. It must be shown that [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 · ℓ𝑖 (cid:27) 𝑒2 · ℓ𝑖 ).

By the inductive hypothesis, we have

val
∀ Γ.

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

(cid:19)

then 𝑒1 (cid:27) 𝑒2

, and therefore

[(cid:174)𝑣/(cid:174)𝑥]

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

(cid:19)

then 𝑒1 (cid:27) 𝑒2

(cid:90)
(cid:90)
30

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

equivalently,

if [(cid:174)𝑣/(cid:174)𝑥]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 (cid:27) 𝑒2)

As we have [(cid:174)𝑣/(cid:174)𝑥]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

by assumption, we may conclude

[(cid:174)𝑣/(cid:174)𝑥] (𝑒1 (cid:27) 𝑒2)

As extensional equivalence is the same as contextual equivalence, from this we may conclude

• Isoinjection : For the same reasons as in the proof for Isoprojection , we have that [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 (cid:27) 𝑒2).
As extensional equivalence is the same as contextual equivalence, we may then conclude

[(cid:174)𝑣/(cid:174)𝑥] (𝑒1 · ℓ𝑖 (cid:27) 𝑒2 · ℓ𝑖 )

[(cid:174)𝑣/(cid:174)𝑥] (𝑖 · 𝑒1 (cid:27) 𝑖 · 𝑒2)

• Isolambda : Let Γ = (cid:174)𝑦 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume

(cid:18)val
∀ 𝑥:𝜏,Γ′.𝜎

(cid:19)

. It must be shown that [(cid:174)𝑣/(cid:174)𝑦] (𝜆𝑥1.𝑒1 (cid:27) 𝜆𝑥2.𝑒2).

[(cid:174)𝑣/(cid:174)𝑦]
To appeal to EQ1, take arbitrary 𝑤 such that Γ ⊢ 𝑤 : 𝜏 and 𝑤 val. By the inductive hypothesis,
we have

val
∀ Γ,𝑥:𝜏 .

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then [𝑥/𝑥1]𝑒1 (cid:27) [𝑥/𝑥2]𝑒2 : 𝜏 ′

(cid:19)

and therefore, since 𝑥 is fresh,

if [𝑤/𝑥] [(cid:174)𝑣/(cid:174)𝑦]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then [𝑤/𝑥] [(cid:174)𝑣/(cid:174)𝑦] ([𝑥/𝑥1]𝑒1 (cid:27) [𝑥/𝑥2]𝑒2 : 𝜏 ′)

By assumption, we already have [𝑤/𝑥] [(cid:174)𝑣/(cid:174)𝑦]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

. Therefore we have

[𝑤/𝑥] [(cid:174)𝑣/(cid:174)𝑦] ([𝑥/𝑥1]𝑒1 (cid:27) [𝑥/𝑥2]𝑒2 : 𝜏 ′)

By Dyn14, we have

[(cid:174)𝑣/(cid:174)𝑦] (𝜆𝑥1.𝑒1) 𝑤 ↦→ [(cid:174)𝑣/(cid:174)𝑦] [𝑤/𝑥1]𝑒1 = [(cid:174)𝑣/(cid:174)𝑦] [𝑤/𝑥] [𝑥/𝑥1]𝑒1

and

[(cid:174)𝑣/(cid:174)𝑦] (𝜆𝑥2.𝑒2) 𝑤 ↦→ [(cid:174)𝑣/(cid:174)𝑦] [𝑤/𝑥2]𝑒2 = [(cid:174)𝑣/(cid:174)𝑦] [𝑤/𝑥] [𝑥/𝑥2]𝑒2

Since [𝑤/𝑥] [(cid:174)𝑣/(cid:174)𝑦] ([𝑥/𝑥1]𝑒1 (cid:27) [𝑥/𝑥2]𝑒2 : 𝜏 ′) and 𝑥 is fresh, we have that [(cid:174)𝑣/(cid:174)𝑦] (𝜆𝑥1.𝑒1 (cid:27)
𝜆𝑥2.𝑒2) by EQ1.

• Isofix : Let Γ = (cid:174)𝑦 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖

: 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume

(cid:18)val
∀ 𝑥:𝜏,Γ′.𝜎

(cid:19)

. It must be shown that [(cid:174)𝑣/(cid:174)𝑦] (fix 𝑥1 is 𝑒1 (cid:27) fix 𝑥2 is 𝑒2).
[(cid:174)𝑣/(cid:174)𝑦]
Note that as long as 𝑥 is fresh, [(cid:174)𝑣/(cid:174)𝑦] (fix 𝑥1 is 𝑒1 (cid:27) fix 𝑥 is [𝑥/𝑥1]𝑒1) and [(cid:174)𝑣/(cid:174)𝑦] (fix 𝑥2 is 𝑒2 (cid:27)
fix 𝑥 is [𝑥/𝑥2]𝑒2) by alpha equivalence. Since we have as a premise for Isofix that 𝑥 fresh,
to show [(cid:174)𝑣/(cid:174)𝑦] (fix 𝑥1 is 𝑒1 (cid:27) fix 𝑥2 is 𝑒2), it suffices to show [(cid:174)𝑣/(cid:174)𝑦] (fix 𝑥 is [𝑥/𝑥1]𝑒1 (cid:27)
fix 𝑥 is [𝑥/𝑥2]𝑒2). By the inductive hypothesis, we have
(cid:18)val
∀ Γ′.𝜎

then [𝑥/𝑥1]𝑒1 (cid:27) [𝑥/𝑥2]𝑒2 : 𝜏 ′

val
∀ Γ,𝑥:𝜏 .

if

(cid:19)

(cid:18)

(cid:19)

This implies that:

val
∀ 𝑥:𝜏 .[(cid:174)𝑣/(cid:174)𝑦]

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then [𝑥/𝑥1]𝑒1 (cid:27) [𝑥/𝑥2]𝑒2 : 𝜏 ′

(cid:19)

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

31

which can be rearranged to:

if [(cid:174)𝑣/(cid:174)𝑦]

(cid:18)val
∀ 𝑥:𝜏,Γ′.𝜎

(cid:19)

then [(cid:174)𝑣/(cid:174)𝑦]

(cid:18)val
∀ 𝑥:𝜏 ([𝑥/𝑥1]𝑒1 (cid:27) [𝑥/𝑥2]𝑒2 : 𝜏 ′)

(cid:19)

By assumption, we have that [(cid:174)𝑣/(cid:174)𝑦]

(cid:18)val
∀ 𝑥:𝜏,Γ′.𝜎

(cid:19)

, so this implies

[(cid:174)𝑣/(cid:174)𝑦]

(cid:18)val
∀ 𝑥:𝜏 ([𝑥/𝑥1]𝑒1 (cid:27) [𝑥/𝑥2]𝑒2 : 𝜏 ′)

(cid:19)

Since LambdaPix enjoys referential transparency, we can therefore substitute [𝑥/𝑥1]𝑒1 for
[𝑥/𝑥2]𝑒2 in [(cid:174)𝑣/(cid:174)𝑦]fix 𝑥 is [𝑥/𝑥1]𝑒1 to get [(cid:174)𝑣/(cid:174)𝑦] (fix 𝑥 is [𝑥/𝑥1]𝑒1 (cid:27) fix 𝑥 is [𝑥/𝑥2]𝑒2). As
[(cid:174)𝑣/(cid:174)𝑦] (fix 𝑥 is [𝑥/𝑥1]𝑒1 (cid:27) fix 𝑥1 is 𝑒1) and [(cid:174)𝑣/(cid:174)𝑦] (fix 𝑥 is [𝑥/𝑥2]𝑒2 (cid:27) fix 𝑥2 is 𝑒2), this
implies [(cid:174)𝑣/(cid:174)𝑦] (fix 𝑥1 is 𝑒1 (cid:27) fix 𝑥2 is 𝑒2) as desired.

• Isoapplication1 : Let Γ = (cid:174)𝑥 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume

[(cid:174)𝑣/(cid:174)𝑥]

(cid:18)val
∀ Γ′,Γ′′.𝜎 ∧ 𝜎 ′

(cid:19)

. It must be shown that [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 𝑒 ′
1

(cid:27) 𝑒2 𝑒 ′

2).

By the inductive hypothesis we have

val
∀ Γ.

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then 𝑒1 (cid:27) 𝑒2 : 𝜏 → 𝜏 ′

(cid:19)

and therefore

if [(cid:174)𝑣/(cid:174)𝑥]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then [(cid:174)𝑣/(cid:174)𝑥] (𝑒1 (cid:27) 𝑒2 : 𝜏 → 𝜏 ′)

As 𝜎 does not contain any variables in Γ′′, by assumption and conjunction we already have
[(cid:174)𝑣/(cid:174)𝑥]

therefore we may conclude

(cid:18)val
∀ Γ′.𝜎

(cid:19)

Similarly, by the inductive hypothesis we have

[(cid:174)𝑣/(cid:174)𝑥] (𝑒1 (cid:27) 𝑒2 : 𝜏 → 𝜏 ′)

val
∀ Γ.

(cid:18)

if

(cid:18)val
∀ Γ′′.𝜎 ′

(cid:19)

then 𝑒 ′
1

(cid:27) 𝑒 ′

2 : 𝜏

(cid:19)

and therefore

if [(cid:174)𝑣/(cid:174)𝑥]

(cid:18)val
∀ Γ′′.𝜎 ′

(cid:19)

then [(cid:174)𝑣/(cid:174)𝑥] (𝑒 ′
1

(cid:27) 𝑒 ′

2 : 𝜏)

As 𝜎 ′ does not contain any variables in Γ′, by assumption and conjunction we already have
[(cid:174)𝑣/(cid:174)𝑥]

therefore we may conclude

(cid:18)val
∀ Γ′′.𝜎 ′

(cid:19)

2 : 𝜏)
Since [(cid:174)𝑣/(cid:174)𝑥]𝑒1 (cid:27) [(cid:174)𝑣/(cid:174)𝑥]𝑒2 : 𝜏 → 𝜏 ′, by EQ1 we have

[(cid:174)𝑣/(cid:174)𝑥] (𝑒 ′
1

(cid:27) 𝑒 ′

[(cid:174)𝑣/(cid:174)𝑥] (𝑒1 𝑒 ′

1) (cid:27) [(cid:174)𝑣/(cid:174)𝑥] (𝑒2 𝑒 ′

1) : 𝜏 ′

Since [(cid:174)𝑣/(cid:174)𝑥] (𝑒 ′
1

(cid:27) 𝑒 ′

2 : 𝜏), by referential transparency we then have

[(cid:174)𝑣/(cid:174)𝑥] (𝑒1 𝑒 ′

1) (cid:27) [(cid:174)𝑣/(cid:174)𝑥] (𝑒2 𝑒 ′

2) : 𝜏 ′

32

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

• Isoapplication2 : Let Γ = (cid:174)𝑧 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume

(cid:19)

(cid:18)val
∀ Γ′.𝜎

[(cid:174)𝑣/(cid:174)𝑧]

. It must be shown that [(cid:174)𝑣/(cid:174)𝑧] (𝑥 𝑒1 (cid:27) 𝑒2).

By the inductive hypothesis we have

val
∀ Γ,𝑦:𝜏 .

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then 𝑦 (cid:27) [𝑦/(𝑥 𝑒1)]𝑒2 : 𝜏

(cid:19)

Since we are only concerned with proving our approach sound over valuable expressions,
⇒ 𝑤 for some value 𝑤 such that Γ ⊢ 𝑤 : 𝜏
without loss of generality, we can assume that 𝑥 𝑒1
and 𝑤 val. Since 𝑦 is fresh, the inductive hypothesis written above implies

if [𝑤/𝑦] [(cid:174)𝑣/(cid:174)𝑧]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then [𝑤/𝑦] [(cid:174)𝑣/(cid:174)𝑧] (𝑦 (cid:27) [𝑦/(𝑥 𝑒1)]𝑒2 : 𝜏)

By assumption, we already have [𝑤/𝑦] [(cid:174)𝑣/(cid:174)𝑧]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

. Therefore we have

which is equivalent to

[𝑤/𝑦] [(cid:174)𝑣/(cid:174)𝑧] (𝑦 (cid:27) [𝑦/(𝑥 𝑒1)]𝑒2 : 𝜏)

[(cid:174)𝑣/(cid:174)𝑧] (𝑤 (cid:27) [𝑤/(𝑥 𝑒1)]𝑒2 : 𝜏)

Since 𝑥 𝑒1
LambdaPix, the above expression is equivalent to

⇒ 𝑤, the two are extensionally equivalent. By the referential transparency of

which is simply

[(cid:174)𝑣/(cid:174)𝑧] (𝑥 𝑒1 (cid:27) [(𝑥 𝑒1)/(𝑥 𝑒1)]𝑒2 : 𝜏)

[(cid:174)𝑣/(cid:174)𝑧] (𝑥 𝑒1 (cid:27) 𝑒2 : 𝜏)

• Isoapplication3 : By symmetry and Isoapplication2 .
• Isoapplication4 : The proof for this is the same as in Isoapplication2 with 𝑥 substituted for 𝑜 (the

fact that 𝑥 is a variable is never used in the proof of Isoapplication2 ).

• Isoapplication5 : By symmetry and Isoapplication4 .
• Isoapplication6 : The proof for this is the same as in Isoapplication2 with 𝑥 substituted for
fix 𝑥1 is 𝑒1, 𝑒1 substituted for 𝑒2, and 𝑒2 substituted for 𝑒 (the fact that 𝑥 is a variable is never
used in the proof of Isoapplication2 ).

• Isoapplication7 : By symmetry and Isoapplication6 .
• Isocasel : Let Γ = (cid:174)𝑥 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume

val
∀ Γ1,Γ′

1

,...,Γ𝑛,Γ′
𝑛

𝑖 ) ⇒ 𝜎𝑖 .

𝑗 )) ∧ 𝑒 ≡ 𝑝 ′

. ∧𝑖 ∈ [𝑛] ((∧𝑗 ∈ [𝑖−1] (𝑒 (cid:46) 𝑝 ′

[(cid:174)𝑣/(cid:174)𝑥]
It must be shown that [(cid:174)𝑣/(cid:174)𝑥] (case 𝑒 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } (cid:27) 𝑒 ′ : 𝜏).
By inversion of the statics we have that Γ ⊢ 𝑒 : 𝜏 ′. By assumption we have that 𝑒 Term
and 𝑒 is in weak head normal form. Therefore by Lemma 5 we have that either [(cid:174)𝑣/(cid:174)𝑥]𝑒 val
or [(cid:174)𝑣/(cid:174)𝑥]𝑒 = 𝑜 𝑒 ′ for some primitive operation 𝑜 and expression 𝑒 ′. In the former case, let
𝑤 = [(cid:174)𝑣/(cid:174)𝑥]𝑒. Since we are only concerned with proving our approach sound over valuable
expressions, in the latter case we can state without loss of generality that 𝑜 𝑒 ′
⇒ 𝑤 for some
value 𝑤.
Since case expressions are enforced to be exhaustive, there must be some 𝑝𝑖 such that
𝑤
By our assumption and the semantics of conjunction we have that

𝑝𝑖 ⊣ 𝐵 and for all 𝑗 < 𝑖, 𝑤 \
(cid:12)

𝑝 𝑗 . By Lemma 6 let 𝑤

𝑖 ⊣ 𝐵 ′.
𝑝 ′

(cid:12)

(cid:12)

[(cid:174)𝑣/(cid:174)𝑥]

val
∀ Γ1,Γ′

1

,...,Γ𝑛,Γ′
𝑛

.((∧𝑗 ∈ [𝑖−1] (𝑒 (cid:46) 𝑝 ′

𝑗 )) ∧ 𝑒 ≡ 𝑝 ′

𝑖 ) ⇒ 𝜎𝑖

(cid:90)
(cid:90)
(cid:90)
Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

33

Since Γ is disjoint with all other listed contexts, this is equivalent to:

val
∀ Γ1,Γ′
,...,Γ𝑛,Γ′
𝑛
𝑖 and each 𝑝 ′

1

Since 𝑝 ′

.((∧𝑗 ∈ [𝑖−1] [(cid:174)𝑣/(cid:174)𝑥] (𝑒 (cid:46) 𝑝 ′

𝑗 )) ∧ [(cid:174)𝑣/(cid:174)𝑥] (𝑒 ≡ 𝑝 ′

𝑖 )) ⇒ [(cid:174)𝑣/(cid:174)𝑥]𝜎𝑖

𝑗 only contains variables in Γ𝑖 or Γ𝑗 (and therefore none of (cid:174)𝑥), we have:

val
∀ Γ1,Γ′

.((∧𝑗 ∈ [𝑖−1] [(cid:174)𝑣/(cid:174)𝑥]𝑒 (cid:46) 𝑝 ′
From our definition of 𝑤, this is equivalent to:

,...,Γ𝑛,Γ′
𝑛

1

𝑗 ) ∧ [(cid:174)𝑣/(cid:174)𝑥]𝑒 ≡ 𝑝 ′

𝑖 ) ⇒ [(cid:174)𝑣/(cid:174)𝑥]𝜎𝑖

val
∀ Γ1,Γ′

1

,...,Γ𝑛,Γ′
𝑛

.((∧𝑗 ∈ [𝑖−1]𝑤 (cid:46) 𝑝 ′

𝑗 ) ∧ 𝑤 ≡ 𝑝 ′

𝑖 ) ⇒ [(cid:174)𝑣/(cid:174)𝑥]𝜎𝑖

We may partially invoke this result with 𝐵 ′ which gives us:

val
∀ Γ1,Γ′

[𝐵 ′]

𝑖 ) ⇒ [(cid:174)𝑣/(cid:174)𝑥]𝜎𝑖
Since the list of contexts is pairwise disjoint and since neither 𝑤 nor 𝑝 ′
any variables in Γ𝑖 , we can rearrange this to get:

.((∧𝑗 ∈ [𝑖−1]𝑤 (cid:46) 𝑝 ′

𝑗 ) ∧ 𝑤 ≡ 𝑝 ′

,...,Γ𝑛,Γ′
𝑛

1

𝑗 for any 𝑗 < 𝑖 contain

val
∀ Γ1,Γ′

,...,Γ𝑛,Γ′
𝑛
By Lemma 7, 𝑤 ≡ [𝐵 ′]𝑝 ′
so this is equivalent to:

1

.((∧𝑗 ∈ [𝑖−1]𝑤 (cid:46) 𝑝 ′
𝑖 is true, and by 𝑖 − 1 applications of Lemma 8, ∧𝑗 ∈ [𝑖−1]𝑤 (cid:46) 𝑝 ′

𝑖 ) ⇒ [𝐵 ′] [(cid:174)𝑣/(cid:174)𝑥]𝜎𝑖

𝑗 ) ∧ 𝑤 ≡ [𝐵 ′]𝑝 ′

𝑗 is true,

val
∀ Γ1,Γ′

,...,Γ𝑛,Γ′
𝑛
𝜎𝑖 only contains variables from Γ, Γ𝑖 , and Γ′
Γ𝑖 , and Γ′
simplify and rearrange the above to:

1

𝑖 . Therefore, [𝐵 ′] [(cid:174)𝑣/(cid:174)𝑥]𝜎𝑖 only contains variables from Γ′

.[𝐵 ′] [(cid:174)𝑣/(cid:174)𝑥]𝜎𝑖
𝑖 . Therefore, [(cid:174)𝑣/(cid:174)𝑥]𝜎𝑖 only contains variables from
𝑖 . Because of this, we can

[𝐵 ′] [(cid:174)𝑣/(cid:174)𝑥]

val
∀ Γ′
𝑖

.𝜎𝑖

This allows us to invoke the inductive hypothesis to get [𝐵 ′] [(cid:174)𝑣/(cid:174)𝑥]𝑒 ′
Since the variables in 𝐵 ′ don’t appear in 𝑒 ′, this is equivalent to: [𝐵 ′] [(cid:174)𝑣/(cid:174)𝑥]𝑒 ′
By Lemma 6, this is equivalent to: [𝐵] [(cid:174)𝑣/(cid:174)𝑥]𝑒𝑖 (cid:27) [(cid:174)𝑣/(cid:174)𝑥]𝑒 ′ : 𝜏.
By Dyn10, [(cid:174)𝑣/(cid:174)𝑥] (case 𝑒 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }) ↦→ [𝐵] [(cid:174)𝑣/(cid:174)𝑥]𝑒𝑖 .
Therefore, since extensional equivalence is closed under evaluation:

𝑖 (cid:27) [𝐵 ′] [(cid:174)𝑣/(cid:174)𝑥]𝑒 ′ : 𝜏.

𝑖 (cid:27) [(cid:174)𝑣/(cid:174)𝑥]𝑒 ′ : 𝜏.

[(cid:174)𝑣/(cid:174)𝑥] (case 𝑒 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } (cid:27) 𝑒 ′ : 𝜏)

• Isocase2: By symmetry and Isocasel.
• Isocase3 Let Γ = (cid:174)𝑦 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume

[(cid:174)𝑣/(cid:174)𝑦]

(cid:18)val
∀ Γ′,𝑥:𝜏 ′,Γ′′.𝜎 ∧ 𝜎 ′

(cid:19)

. It must be shown that [(cid:174)𝑣/(cid:174)𝑦] (case 𝑒 {. . .} (cid:27) case 𝑒 ′ {. . .}).

By the inductive hypothesis we have

val
∀ Γ.

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

(cid:19)

then 𝑒 (cid:27) 𝑒 ′

and therefore

(cid:18)

if [(cid:174)𝑣/(cid:174)𝑦]

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then [(cid:174)𝑣/(cid:174)𝑦] (𝑒 (cid:27) 𝑒 ′)

(cid:19)

Since [(cid:174)𝑣/(cid:174)𝑦]𝜎 only contains variables in Γ′, by assumption and conjunction we already have
[(cid:174)𝑣/(cid:174)𝑦]

. Therefore we may conclude [(cid:174)𝑣/(cid:174)𝑦] (𝑒 (cid:27) 𝑒 ′).

(cid:18)val
∀ Γ′.𝜎

(cid:19)

34

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

Since we are only concerned with proving our approach sound over valuable expressions,
⇒ 𝑤 for some value 𝑤 such that
without loss of generality, we can assume that [(cid:174)𝑣/(cid:174)𝑦]𝑒
Γ ⊢ 𝑤 : 𝜏 ′ and 𝑤 val. By the inductive hypothesis we have

val
∀ Γ,𝑥:𝜏 ′.

(cid:18)

if

(cid:18)val
∀ Γ′′.𝜎 ′

(cid:19)

then case 𝑥 {. . .} (cid:27) case 𝑥 {. . .′}

(cid:19)

and therefore, since 𝑥 is fresh,
(cid:18)

val
∀ 𝑥:𝜏 ′.

if [(cid:174)𝑣/(cid:174)𝑦]

(cid:18)val
∀ Γ′′.𝜎 ′

(cid:19)

then [(cid:174)𝑣/(cid:174)𝑦] (case 𝑥 {. . .} (cid:27) case 𝑥 {. . .′})

(cid:19)

Invoking this with 𝑤, we have

if [𝑤/𝑥] [(cid:174)𝑣/(cid:174)𝑦]

(cid:18)val
∀ Γ′′.𝜎 ′

(cid:19)

then [(cid:174)𝑣/(cid:174)𝑦] (case 𝑤 {. . .} (cid:27) case 𝑤 {. . .′})

By assumption and conjunction we already have [𝑤/𝑥] [(cid:174)𝑣/(cid:174)𝑦]

(cid:18)val
∀ Γ′′.𝜎 ′

(cid:19)

. Therefore we may

conclude

[(cid:174)𝑣/(cid:174)𝑦] (case 𝑤 {. . .} (cid:27) case 𝑤 {. . .′})

Since [(cid:174)𝑣/(cid:174)𝑦]𝑒 (cid:27) 𝑤 and [(cid:174)𝑣/(cid:174)𝑦]𝑒 (cid:27) [(cid:174)𝑣/(cid:174)𝑦]𝑒 ′, we have [(cid:174)𝑣/(cid:174)𝑦]𝑒 ′ (cid:27) 𝑤 by transitivity. Then, by
referential transparency and the above equivalence, we have:
[(cid:174)𝑣/(cid:174)𝑦] (case 𝑒 {. . .} (cid:27) case 𝑒 ′ {. . .′})

• Isocase4 : Let Γ = (cid:174)𝑦 : (cid:174)𝜏 and let (cid:174)𝑣 be arbitrary where 𝑣𝑖 : 𝜏𝑖 and 𝑣𝑖 val for all 𝑣𝑖 ∈ (cid:174)𝑣. Assume

val
∀ Γ1,Γ′

1

...Γ𝑛,Γ′
𝑛

.Ψ. It must be shown that [(cid:174)𝑣/(cid:174)𝑦] (case 𝑥 {𝑀 } (cid:27) case 𝑥 {𝑀 ′} : 𝜏).

[(cid:174)𝑣/(cid:174)𝑦]
Since extensional equivalence is defined only over closed expressions, without loss of gen-
erality, we can assume that [(cid:174)𝑣/(cid:174)𝑦] includes some binding for 𝑥 [𝑣/𝑥]. By partial application,
[(cid:174)𝑣/(cid:174)𝑦] (case 𝑥 {𝑀 } (cid:27) case 𝑥 {𝑀 ′} : 𝜏) is equivalent to [(cid:174)𝑣/(cid:174)𝑦] (case 𝑣 {𝑀 } (cid:27) case 𝑣 {𝑀 ′} : 𝜏).
By Lemma 13, [(cid:174)𝑣/(cid:174)𝑦] (case 𝑣 {𝑀 } (cid:27) case 𝑣 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 }) and [(cid:174)𝑣/(cid:174)𝑦] (case 𝑣 {𝑀 ′} (cid:27)
𝑚 }). So to show [(cid:174)𝑣/(cid:174)𝑦] (case 𝑣 {𝑀 } (cid:27) case 𝑣 {𝑀 ′} : 𝜏), it suffices to
case 𝑣 {𝑝 ′
1
show [(cid:174)𝑣/(cid:174)𝑦] (case 𝑣 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } (cid:27) case 𝑣 {𝑝 ′
1 | . . . | 𝑝 ′
.𝑒 ′
1
Since case expressions are enforced to be exhaustive, there must be some 𝑝𝑖 and 𝑝 ′
𝑣

𝑝 𝑗 . Since 𝑖 ≤ 𝑠 or 𝑖 > 𝑠, we must consider both cases.

.𝑒 ′
1 | . . . | 𝑝 ′

𝑗 such that

𝑚 } : 𝜏).

𝑚.𝑒 ′

𝑚.𝑒 ′

𝑝𝑖 ⊣ 𝐵 and for all 𝑗 < 𝑖, 𝑣 \
(cid:12)

(cid:12)

We first consider the case where 𝑖 ≤ 𝑠.
By our assumption that [(cid:174)𝑣/(cid:174)𝑦]Ψ is valid and the semantics of conjunction, we have that

[(cid:174)𝑣/(cid:174)𝑦]

val
∀ Γ1,Γ′

1

...Γ𝑛,Γ′
𝑛

.(∧𝑖 ∈ [𝑠 ]𝜎𝑖 )

so in particular, at the 𝑖 such that 𝑣

𝑝𝑖 ⊣ 𝐵, we have

(cid:12)

[(cid:174)𝑣/(cid:174)𝑦]

val
∀ Γ1,Γ′

1

...Γ𝑛,Γ′
𝑛

.𝜎𝑖

Since 𝜎𝑖 only contains variables from Γ, Γ𝑖, and Γ′

𝑖 , this is equivalent to [(cid:174)𝑣/(cid:174)𝑦]

val
∀ Γ𝑖,Γ′

𝑖

.𝜎𝑖 . Then,

by our inductive hypothesis, [(cid:174)𝑣/(cid:174)𝑦]
𝑝𝑖 ⊣ 𝐵, 𝑣
𝑖 ≤ 𝑠, by Lemma 14, 𝑣
Dyn10, [(cid:174)𝑣/(cid:174)𝑦] (case 𝑣 {𝑝1.𝑒1 |
. . .
𝑚 }) ↦→ [(cid:174)𝑣/(cid:174)𝑦] [𝐵]𝑒 ′
𝑚.𝑒 ′
𝑝 ′

𝑖 ). This implies [(cid:174)𝑣/(cid:174)𝑦] [𝐵] (𝑒𝑖 (cid:27) 𝑒 ′
𝑖 ). Since
𝑝 ′
𝑝 𝑗 and 𝑣 \
𝑗 . So by
(cid:12)
| 𝑝𝑛.𝑒𝑛 }) ↦→ [(cid:174)𝑣/(cid:174)𝑦] [𝐵]𝑒𝑖 and [(cid:174)𝑣/(cid:174)𝑦] (case 𝑣 {𝑝 ′
. . .
.𝑒 ′
|
1 |
1
𝑖 . Since extensional equivalence is closed under evaluation, this implies

𝑖 ⊣ 𝐵, and for all 𝑗 < 𝑖, 𝑣 \
𝑝 ′
(cid:12)

(cid:12)

(cid:12)

val
∀ Γ𝑖 .(𝑒𝑖 (cid:27) 𝑒 ′

(cid:90)
Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

35

[(cid:174)𝑣/(cid:174)𝑦] (case 𝑣 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } (cid:27) case 𝑣 {𝑝 ′
1

1 | . . . | 𝑝 ′
.𝑒 ′

𝑚.𝑒 ′

𝑚 } : 𝜏) as desired.

This leaves the case where 𝑖 > 𝑠. By our assumption that [(cid:174)𝑣/(cid:174)𝑦]Ψ is valid and the semantics of
val
.(∧𝑗 ∈ [𝑠+1,𝑛] ((∧𝑘 ∈ [ 𝑗−1] (𝑥 (cid:46) 𝑝𝑘 )) ∧ 𝑥 ≡ 𝑝 𝑗 ) ⇒ 𝜎 𝑗 ),
conjunction, we have that [(cid:174)𝑣/(cid:174)𝑦]
∀ Γ1,Γ′
𝑝𝑖 ⊣ 𝐵, we have:
so in particular, when 𝑗 = 𝑖 such that 𝑣

...Γ𝑛,Γ′
𝑛

1

.((∧𝑘 ∈ [𝑖−1] (𝑥 (cid:46) 𝑝𝑘 )) ∧ 𝑥 ≡ 𝑝𝑖 ) ⇒ 𝜎𝑖
Since Γ is disjoint with all other listed contexts, this is equivalent to:

[(cid:174)𝑣/(cid:174)𝑦]

...Γ𝑛,Γ′
𝑛

1

val
∀ Γ1,Γ′

(cid:12)

val
∀ Γ1,Γ′

1

...Γ𝑛,Γ′
𝑛

.((∧𝑘 ∈ [𝑖−1] [(cid:174)𝑣/(cid:174)𝑦] (𝑥 (cid:46) 𝑝𝑘 )) ∧ [(cid:174)𝑣/(cid:174)𝑦] (𝑥 ≡ 𝑝𝑖 )) ⇒ [(cid:174)𝑣/(cid:174)𝑦]𝜎𝑖

Since 𝑝𝑖 and 𝑝𝑘 only contain variables in Γ𝑖 and Γ𝑘 (and therefore, none of (cid:174)𝑦), we have:

val
∀ Γ1,Γ′

1

...Γ𝑛,Γ′
𝑛

.((∧𝑘 ∈ [𝑖−1] [(cid:174)𝑣/(cid:174)𝑦]𝑥 (cid:46) 𝑝𝑘 ) ∧ [(cid:174)𝑣/(cid:174)𝑦]𝑥 ≡ 𝑝𝑖 ) ⇒ [(cid:174)𝑣/(cid:174)𝑦]𝜎𝑖

Recalling that [𝑣/𝑥] is included in [(cid:174)𝑣/(cid:174)𝑦], this is equivalent to:

We may partially invoke this result with 𝐵 which gives us:

...Γ𝑛,Γ′
𝑛

.((∧𝑘 ∈ [𝑖−1]𝑣 (cid:46) 𝑝𝑘 ) ∧ 𝑣 ≡ 𝑝𝑖 ) ⇒ [(cid:174)𝑣/(cid:174)𝑦]𝜎𝑖

val
∀ Γ1,Γ′

1

[𝐵]

val
∀ Γ1,Γ′

1

...Γ𝑛,Γ′
𝑛

.((∧𝑘 ∈ [𝑖−1]𝑣 (cid:46) 𝑝𝑘 ) ∧ 𝑣 ≡ 𝑝𝑖 ) ⇒ [(cid:174)𝑣/(cid:174)𝑦]𝜎𝑖

Since the list of contexts is pairwise disjoint and since neither 𝑣 nor 𝑝𝑘 for any 𝑘 < 𝑖 contain
any variables in Γ𝑖 , we can rearrange this to get:

val
∀ Γ1,Γ′

1

...Γ𝑛,Γ′
𝑛

.((∧𝑘 ∈ [𝑖−1]𝑣 (cid:46) 𝑝𝑘 ) ∧ 𝑣 ≡ [𝐵]𝑝𝑖 ) ⇒ [𝐵] [(cid:174)𝑣/(cid:174)𝑦]𝜎𝑖

By Lemma 7 𝑣 ≡ [𝐵]𝑝𝑖 is true and by 𝑖 − 1 applications of Lemma 8 ∧𝑘 ∈ [𝑖−1]𝑣 (cid:46) 𝑝𝑘 is true, so
this is equivalent to:

val
∀ Γ1,Γ′

...Γ𝑛,Γ′
𝑛
𝜎 only contains variables from Γ, Γ𝑖, and Γ′
Γ𝑖 and Γ′
simplify and rearrange the above to:

1

𝑖 . Therefore, [𝐵] [(cid:174)𝑣/(cid:174)𝑦]𝜎𝑖 only contains variables from Γ′

.[𝐵] [(cid:174)𝑣/(cid:174)𝑦]𝜎𝑖
𝑖 . Therefore, [(cid:174)𝑣/(cid:174)𝑦]𝜎𝑖 only contains variables from
𝑖 . Because of this, we can

This allows us to invoke the inductive hypothesis to get

[𝐵] [(cid:174)𝑣/(cid:174)𝑦]

val
∀ Γ′
𝑖

.𝜎𝑖

[𝐵] [(cid:174)𝑣/(cid:174)𝑦]𝑒𝑖 (cid:27) [𝐵] [(cid:174)𝑣/(cid:174)𝑦]case 𝑥 {𝑝 ′
1

1 | . . . | 𝑝 ′
.𝑒 ′

𝑚.𝑒 ′

𝑚 } : 𝜏

Since the variables in 𝐵 don’t appear in case 𝑥 {𝑀 ′}, and since [𝑣/𝑥] is included in [(cid:174)𝑣/(cid:174)𝑦],
this is equivalent to

[𝐵] [(cid:174)𝑣/(cid:174)𝑦]𝑒𝑖 (cid:27) [(cid:174)𝑣/(cid:174)𝑦]case 𝑣 {𝑝 ′
1

1 | . . . | 𝑝 ′
.𝑒 ′

𝑚.𝑒 ′

𝑚 } : 𝜏

By Dyn10, case 𝑣 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } ↦→ [𝐵] [(cid:174)𝑣/(cid:174)𝑦]𝑒𝑖 .
Therefore, since extensional equivalence is closed under evaluation:

[(cid:174)𝑣/(cid:174)𝑥] (case 𝑣 {𝑝1.𝑒1 | . . . | 𝑝𝑛.𝑒𝑛 } (cid:27) case 𝑣 {𝑝 ′
1

1 | . . . | 𝑝 ′
.𝑒 ′

𝑚.𝑒 ′

𝑚 } : 𝜏)

36

Joshua Clune, Vijay Ramamurthy, Ruben Martins, and Umut A. Acar

So regardless of whether 𝑖 ≤ 𝑠 or 𝑖 > 𝑠, we have [(cid:174)𝑣/(cid:174)𝑥] (case 𝑣 {𝑝1.𝑒1 |
case 𝑣 {𝑝 ′
1

𝑚 } : 𝜏) as desired

1 | . . . | 𝑝 ′
.𝑒 ′
• Isocase5 : By symmetry and Isocase4 .

𝑚.𝑒 ′

. . .

| 𝑝𝑛.𝑒𝑛 } (cid:27)

We have verified the soundness of each rule. Therefore, by induction:
val
∀ Γ.

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ then

then 𝑒1 (cid:27) 𝑒2 : 𝜏

• If Γ ⊢ 𝑒1

(cid:18)val
∀ Γ′.𝜎

if

(cid:18)

(cid:19)

(cid:19)

.

• If Γ ⊢ 𝑒1

𝜎
←→ 𝑒2 : 𝜏 ⊣ Γ′ then

val
∀ Γ.

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then 𝑒1 (cid:27) 𝑒2 : 𝜏

(cid:19)

.

The above statements imply the soundness theorem. When Γinitial ⊢ 𝑒1

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ we have
. Since Γinitial contains only primitive operations, which are

(cid:19)

val
∀ Γinitial

.

(cid:18)

if

(cid:19)

(cid:18)val
∀ Γ′.𝜎

then 𝑒1 (cid:27) 𝑒2 : 𝜏

omitted from the
(cid:19)

(cid:18)val
∀ Γ′.𝜎

val
∀ Γ.𝑗 judgment, the outer quantifier quantifies over no variables, so we have that
val
∀ Γ′.𝜎 allows us to conclude that

then 𝑒1 (cid:27) 𝑒2 : 𝜏. This together with the assumption that

if

𝑒1 (cid:27) 𝑒2 : 𝜏. So for all expressions 𝑒1 and 𝑒2, if Γinitial ⊢ 𝑒1

𝜎
⇐⇒ 𝑒2 : 𝜏 ⊣ Γ′ and

val
∀ Γ′.𝜎, then 𝑒1 (cid:27) 𝑒2 : 𝜏.

ACKNOWLEDGMENTS
This work was partially funded by National Science Foundation (Grants CCF-1901381, CCF-1762363,
and CCF-1629444).

REFERENCES
Amal Ahmed, Derek Dreyer, and Andreas Rossberg. 2009. State-dependent representation independence. In Proc. Symposium

on Principles of Programming Languages. ACM, 340–353. https://doi.org/10.1145/1480881.1480925

Amal J. Ahmed. 2006. Step-Indexed Syntactic Logical Relations for Recursive and Quantified Types. In Proc. European

Symposium on Programming. Springer, 69–83. https://doi.org/10.1007/11693024_6

John D. Backes, Suzette Person, Neha Rungta, and Oksana Tkachuk. 2013. Regression Verification Using Impact Summaries.
In Proc. International Symposium Model Checking Software. Springer, 99–116. https://doi.org/10.1007/978-3-642-39176-7_7
C Leonard Berman and Louise H Trevillyan. 1989. Functional comparison of logic designs for VLSI circuits. In Proc.

International Conference on Computer-Aided Design. IEEE, 456–459. https://doi.org/10.1109/ICCAD.1989.76990

François Bobot, Jean-Christophe Filliâtre, Claude Marché, and Andrei Paskevich. 2015. Let’s verify this with Why3. Int. J.

Softw. Tools Technol. Transf. 17, 6 (2015), 709–727. https://doi.org/10.1007/s10009-014-0314-5

Edmund Clarke, Daniel Kroening, and Flavio Lerda. 2004. A tool for checking ANSI-C programs. In Proc. International
Conference on Tools and Algorithms for the Construction and Analysis of Systems. Springer, 168–176. https://doi.org/10.
1007/978-3-540-24730-2_15

Edmund M. Clarke, Armin Biere, Richard Raimi, and Yunshan Zhu. 2001. Bounded Model Checking Using Satisfiability

Solving. Formal Methods Syst. Des. 19, 1 (2001), 7–34. https://doi.org/10.1023/A:1011276507260

Leonardo Mendonça de Moura and Nikolaj Bjørner. 2008. Z3: An Efficient SMT Solver. In Proc. International Conference on
Tools and Algorithms for the Construction and Analysis of Systems. Springer, 337–340. https://doi.org/10.1007/978-3-540-
78800-3_24

Derek Dreyer, Amal Ahmed, and Lars Birkedal. 2009. Logical Step-Indexed Logical Relations. In Proc. Annual Symposium on

Logic in Computer Science. IEEE Computer Society, 71–80. https://doi.org/10.1109/LICS.2009.34

Grigory Fedyukovich, Arie Gurfinkel, and Natasha Sharygina. 2016. Property Directed Equivalence via Abstract Simulation.
In Proc. International Conference Computer-Aided Verification. Springer, 433–453. https://doi.org/10.1007/978-3-319-
41540-6_24

Dennis Felsing, Sarah Grebing, Vladimir Klebanov, Philipp Rümmer, and Mattias Ulbrich. 2014. Automating regression
verification. In Proc. International Conference on Automated Software Engineering. ACM, 349–360. https://doi.org/10.
1145/2642937.2642987

Benny Godlin and Ofer Strichman. 2009. Regression verification. In Proc. Design Automation Conference. ACM, 466–471.

https://doi.org/10.1145/1629911.1630034

Program Equivalence for Assisted Grading of Functional Programs (Extended Version)

37

Sumit Gulwani, Ivan Radicek, and Florian Zuleger. 2018. Automated clustering and program repair for introductory
programming assignments. In Proc. ACM SIGPLAN Conference on Programming Language Design and Implementation.
ACM, 465–480. https://doi.org/10.1145/3192366.3192387

Chung-Kil Hur, Derek Dreyer, Georg Neis, and Viktor Vafeiadis. 2012. The marriage of bisimulations and Kripke logical
relations. In Proc. Symposium on Principles of Programming Languages. ACM, 59–72. https://doi.org/10.1145/2103656.
2103666

Guilhem Jaber. 2020. SyTeCi: automating contextual equivalence for higher-order programs with references. PACMPL 4,

POPL (2020), 59:1–59:28. https://doi.org/10.1145/3371127

Shalini Kaleeswaran, Anirudh Santhiar, Aditya Kanade, and Sumit Gulwani. 2016. Semi-supervised verified feedback
generation. In Proc. International Symposium on Foundations of Software Engineering. ACM, 739–750. https://doi.org/10.
1145/2950290.2950363

Vasileios Koutavas and Mitchell Wand. 2006. Small bisimulations for reasoning about higher-order imperative programs. In
Proc. Symposium on Principles of Programming Languages. ACM, 141–152. https://doi.org/10.1145/1111037.1111050
Xiao Liu, Shuai Wang, Pei Wang, and Dinghao Wu. 2019. Automatic grading of programming assignments: an approach
based on formal semantics. In Proc. International Conference on Software Engineering: Software Engineering Education and
Training. IEEE / ACM, 126–137. https://doi.org/10.1109/ICSE-SEET.2019.00022

David Mitchel Perry, Dohyeong Kim, Roopsha Samanta, and Xiangyu Zhang. 2019. SemCluster: clustering of imperative
programming assignments based on quantitative semantic features. In Proc. ACM SIGPLAN Conference on Programming
Language Design and Implementation. 860–873. https://doi.org/10.1145/3314221.3314629

Yewen Pu, Karthik Narasimhan, Armando Solar-Lezama, and Regina Barzilay. 2016. sk_p: a neural program corrector for
MOOCs. In Proc. International Conference on Systems, Programming, Languages and Applications: Software for Humanity.
ACM, 39–40. https://doi.org/10.1145/2984043.2989222

Rishabh Singh, Sumit Gulwani, and Armando Solar-Lezama. 2013. Automated feedback generation for introductory
programming assignments. In Proc. ACM SIGPLAN Conference on Programming Language Design and Implementation.
ACM, 15–26. https://doi.org/10.1145/2491956.2462195

Eijiro Sumii and Benjamin C. Pierce. 2005. A bisimulation for type abstraction and recursion. In Proc. Symposium on

Principles of Programming Languages. ACM, 63–74. https://doi.org/10.1145/1040305.1040311

Ke Wang, Rishabh Singh, and Zhendong Su. 2018. Search, align, and repair: data-driven feedback generation for introductory
programming exercises. In Proc. ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM,
481–495. https://doi.org/10.1145/3192366.3192384

Lenore Zuck, Amir Pnueli, Yi Fang, and Benjamin Goldberg. 2002. VOC: A translation validator for optimizing compilers.

Electronic notes in theoretical computer science 65, 2 (2002), 2–18. https://doi.org/10.1016/S1571-0661(04)80393-1

