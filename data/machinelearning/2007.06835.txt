0
2
0
2

l
u
J

4
1

]

G
L
.
s
c
[

1
v
5
3
8
6
0
.
7
0
0
2
:
v
i
X
r
a

Programming by Rewards
Synthesizing programs using black-box rewards

NAGARAJAN NATARAJAN, Microsoft Research, IN
AJAYKRISHNA KARTHIKEYAN, Microsoft Research, IN
PRATEEK JAIN, Microsoft Research, IN
IVAN RADIČEK, Microsoft, Austria
SRIRAM RAJAMANI, Microsoft Research, IN
SUMIT GULWANI, Microsoft, USA
JOHANNES GEHRKE, Microsoft Research, USA

We formalize and study “programming by rewards” (PBR), a new approach for specifying and synthesizing
subroutines for optimizing some quantitative metric such as performance, resource utilization, or correctness
over a benchmark. A PBR specification consists of (1) input features x, and (2) a reward function r , modeled
as a black-box component (which we can only run), that assigns a reward for each execution. The goal of
the synthesizer is to synthesize a decision function f which transforms the features to a decision value for
the black-box component so as to maximize the expected reward E[r ◦ f (x)] for executing decisions f (x) for
various values of x.

We consider a space of decision functions in a DSL of loop-free if-then-else programs, which can branch
on linear functions of the input features in a tree-structure and compute a linear function of the inputs
in the leaves of the tree. We find that this DSL captures decision functions that are manually written in
practice by programmers. Our technical contribution is the use of continuous-optimization techniques to
perform synthesis of such decision functions as if-then-else programs. We also show that the framework is
theoretically-founded —in cases when the rewards satisfy nice properties, the synthesized code is optimal in a
precise sense.

PBR hits a sweet-spot between program synthesis techniques that require the entire system r ◦ f as a white-
box, and reinforcement learning (RL) techniques that treat the entire system r ◦ f as a black-box. PBR takes a
middle path treating f as a white-box, thereby exploiting the structure of f to get better accuracy and faster
convergence, and treating r as a black-box, thereby scaling to large real-world systems. Our algorithms are
provably more accurate and sample efficient than existing synthesis-based and reinforcement learning-based
techniques under certain assumptions.

We have leveraged PBR to synthesize non-trivial decision functions related to search and ranking heuristics
in the PROSE codebase (an industrial strength program synthesis framework) and achieve competitive results to
manually written procedures over multiple man years of tuning. We present empirical evaluation against other
baseline techniques over real-world case studies (including PROSE) as well on simple synthetic benchmarks.

Additional Key Words and Phrases: AI driven software engineering, sketching, online learning

1 INTRODUCTION
Consider the following scenario, which routinely arises while writing software. A developer wants
to write a sub-routine to decide how to set some threshold parameter, such as timeout value, before
executing a software component (say a database system or a networking system). First, they may
not apriori know what the threshold needs to be for a particular input — because fundamentally
there may not be any "right" threshold for a given input, but it may depend on the myriad program
variables in complex ways that eventually affects the execution of the software. Suppose the
developer makes a decision to set the threshold to some value τ . After the component finishes
Authors’ addresses: Nagarajan Natarajan, Microsoft Research, IN, nagarajn@microsoft.com; Ajaykrishna Karthikeyan,
Microsoft Research, IN, t-ajka@microsoft.com; Prateek Jain, Microsoft Research, IN, prajain@microsoft.com; Ivan Radiček,
Microsoft, Austria, ivradice@microsoft.com; Sriram Rajamani, Microsoft Research, IN, sriram@microsoft.com; Sumit
Gulwani, Microsoft, USA, sumitg@microsoft.com; Johannes Gehrke, Microsoft Research, USA, johannes@microsoft.com.

 
 
 
 
 
 
2

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

executing, the developer may be able to measure some non-functional metric such as latency or
throughput or resource utilization to get feedback on whether the threshold τ was a "good" or "bad"
choice. Such feedback can be given as a "reward" (using the terminology of reinforcement learning)
to improve future choices for the threshold τ .

The performance and functionality of large scale software is dependent on many such thresholds,
which we call as decision values or more succinctly, decisions. Typically, decisions are tuned to
suitable values depending on the variables that represent the state of the program (such as size
of internal queues) as well as the state of the environment (such as number of requests received
per second), and the number of such dependencies can be very large, or "high-dimensional", to use
terminology of machine learning. Often, such decisions are set in the code, using custom logic,
as shown in the example code in Figure 1. We call functions with such custom logic as decision
functions. Decision functions also generalize configuration files (see Figure 1 (left)), which is often
part of large code-bases. Each line in the configuration file can be thought of as trivial decision
functions that return constant values as decisions.

We propose a new framework, Programming by Rewards, abbreviated as PBR, for automatically

synthesizing and tuning decision functions in standard settings. A PBR specification consists of

(1) The input features x, with their data types, and the decision type. For example, in Figure 1,
for the decision function ScoreLinesMap the input features are selection and lines, both
having type double, and the decision type is also double, which is the return type of the
method.

(2) A reward function r , modeled as a black-box component, that consumes the output of the
decision function, executes an arbitrarily complicated software module, and assigns a reward
value for the execution of the black-box software module with the provided decision value.
For example, in Figure 1, the black-box is the PROSE engine [PROSE 2015] which takes the
return values of ScoreLinesMap and other such decision functions as decision values, and
executes a complicated program synthesis engine, and assigns a reward like total execution
time or accuracy of the synthesized program. Other examples of black-box engines could be
communications software such as Skype or Zoom, or database engines such as SQLServer,
where the reward value can be proportional to latency seen by the end-user or a combination
of total execution time.

The framework relies on suitable programmer-defined rewards that indicate how well the decision
value returned by the decision function eventually affects the success of the overarching software
itself, represented by the the reward function r . We formalize the problem of synthesizing decision
functions given only execution (or invocation) access to the reward function r . Furthermore, in
practice, due to changes in the environment (such as load on the system), two invocations of the
black-box with the same decision value can result in different reward values. Hence, r need not be
deterministic. We optimize the expected value of the reward (see Definition 3 in Section 2), while
allowing for randomness inside the reward function.

Prior work in this area follows one of the three approaches:

(1) In the rule-based approach, which is widely used by practitioners, the programmer writes
decision functions using custom code, which has domain-specific logic to compute decision
values in terms of input features. For example, the decision function ScoreLinesMap shown
in Figure 1 uses three manually chosen parameter values minscore,alpha and beta, to
compute one decision value as a function of the input features sel and lines, which is
returned by the function. The programmer can tweak the custom code based on a few
observed rewards, but in general, setting a larger number of parameters manually can lead
to significantly sub-optimal rewards. Further, the decision function ScoreLinesMap and the

Programming by Rewards

3

parameter values do not adapt automatically as the environment of the software changes,
which is undesirable.

(2) In the sketch-based synthesis approach, the idea is to specify the decision function as
a template with “holes”. For example, in the decision function ScoreLinesMap shown in
Figure 1, the programmer can leave the values of the parameters minScore, alpha and beta
as holes and leave it to the synthesis engine to synthesize values for these holes such that a
quantitative specification that optimizes the reward value is satisfied. Though Sketching has
been primarily used with correctness specifications (which are Boolean) [Bodik and Solar-
Lezama 2006], prior work has explored sketching to optimize quantitative specifications such
as reward values [Chaudhuri et al. 2014]. In this setting, the entire software r ◦ f is required
to be white-box for program synthesis to work, which makes the approach challenging to
scale.

(3) In the reinforcement learning approach, the decision function is learned automatically
using an ML formulation, which is trained from traces of executions of the code so as to
optimize the expected value of the rewards [Agarwal et al. 2016; Sutton and Barto 2011].
This approach has attracted much attention recently due to increasing popularity of machine
learning. In this setting, the entire software r ◦ f is treated as a black-box, and the algorithms to
learn f need a large number of samples to learn when the number of features and parameters
are large.

PBR hits a sweet-spot between program synthesis and reinforcement learning approaches men-
tioned above. PBR takes a middle path, treating the decision code f as a white-box, thereby
exploiting the structure of f to get better accuracy and faster convergence, and treating r as a
black-box, thereby scaling to real-world systems. We consider a space of decision functions in a
DSL of loop-free if-then-else programs, which can branch on the input features in a tree-structure
and compute a linear function of the inputs in the leaves of the tree. We find that this DSL captures
decision functions that are manually written in practice by programmers.

Our methods work in both the offline and online settings. In the offline setting we have access to
all the executions and reward values apriori. In the online setting, a reward is assigned online in
response to a decision value, and PBR uses the reward to improve the decision function. In practical
large-scale systems, online setting is more practical and general, so we mostly focus on this setting
from algorithm development viewpoint. Our most substantial case study (Section 5.2) is also in
the context of black-box reward functions in an online setting. However, we also compare with
baselines (especially based on sketch-based synthesis methods) having offline access all the data,
and having white-box access to the reward functions (Section 5.3).

Our key technical contribution is the use of continuous-optimization techniques, specifically
gradient descent, to perform synthesis of decision functions such as if-then-else programs, with
small update and sample complexity, i.e., the execution time as well as the number of black-box
reward executions required by our techniques are relatively small. However, there are several
challenges in applying gradient descent techniques in PBR setting. First, we only have restricted
access to the reward function r so computing gradient itself is challenging. Furthermore, the
general decision tree functions are non-smooth, piece-wise linear functions which are challenging
to capture with continuous optimization methods.

In this work, we make two-fold contributions on this front. First, we build upon well-established
approach in the optimization literature, that gradient based methods allow inexact, noisy but
unbiased gradient estimates, which can be obtained by invoking reward function r on random
perturbation of decision values. However, such methods can lead to large sample complexity (i.e.
number of executions of r ) if we have a large number of parameters. If the decision function is

4

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

a linear function or if it is an if-then-else program with small number of decision values, then
we can provide significantly more efficient gradient estimation methods. Formally, let d be the
number of parameters in the system, and let m be the number of decisions made in the system. Our
core result is that we can automatically synthesize decision functions if they are loop-free and use
linear operators. Specifically, even though there may be many parameters in the system (d ≫ m),
we design ML algorithms with complexity proportional to m rather than d. Since m is typically
much smaller than d, our approach has significant advantages over existing approaches, whose
complexity scales with d. As an example, the decision function ScoreLinesMap (in Figure 1) is a
linear model with m = 1 and d = 3. The decision function IsLikelyDataRatio (in Figure 1) can
be encoded as a decision tree model with (on the order of) 10 parameters representing the weights
and predicates in a shallow tree. In this case, we have a decision tree with d ∼ 10 and m = 1. In
this work, we propose novel ML algorithms whose complexity depends on m rather than d for
linear models and decision trees. Furthermore, for certain cases, we provide rigorous bounds on
the efficiency of the proposed methods.

Second, we show how decision trees can be modeled using a continuous shallow network model
under structural constraints, which enables usage of standard gradient descent type of methods for
learning the parameters of decision trees with only black-box reward r (see Section 4.3).

Finally, we conduct extensive experiments to validate that our PBR based methods can indeed
be used to efficiently synthesize programs in real-world codebases using only black-box reward
function (Section 5.2). In particular, for PROSE [PROSE 2015], which is a complicated system with
nearly 70 ranking related heuristics fine-tuned over several years, our method can synthesize all
the heuristics while achieving competitive accuracy to hand-tuned systems, after training for a
few days and after only about 250 calls to the reward function; in PROSE each reward function
call requires synthesizing programs for about 740 benchmarks and then computing their accuracy,
thus highlighting the need to optimize sample complexity of PBR methods. Furthermore, we show
that standard reinforcement style learning methods when used in completely black-box manner
indeed suffer from poorer sample complexity in such problems (Section 5.4). Finally, we observe
that even when we provide existing sketch based methods–either using CEGIS (Counterexample
Based Inductive Synthesis) on top of SAT [Bodik and Solar-Lezama 2006] or numerical methods
[Chaudhuri et al. 2014]–with whitebox access to the entire reward function and also provide apriori
access to all the execution traces (i.e. offline data), their computational and sample complexity is
significantly higher than our techniques (Section 5.3).

In summary, the paper makes the following contributions:

(1) We observe Imp (Definition 1) to be rich language that accurately models typical decision

functions in practice and also identify some important sub-classes of Imp.

(2) We formalize Programming by Rewards (PBR) with Imp DSL and also present an equivalent

formalism as that of learning decision trees with black-box rewards.

(3) We present novel algorithms for learning decision tree as well as linear models with rewards

and provide rigorous guarantees for the latter.

(4) We present strong empirical validation of our approach on an industrial strength codebase,

demonstrating both sample and computational efficiency.

Paper Organization: Section 2 formally specifies the PBR problem, provides the DSL that we
consider and motivates it using existing work and inspection of a few real-world codebases. Then
in Section 3, we provide overview of how we set up the problem as a decision-tree learning problem
and set up the key metrics to be considered while designing the algorithms. In Section 4 we provide
specific PBR algorithms for three different DSLs and in certain cases, provide rigorous guarantees. In
Section 5 we provide empirical evaluation of our method and compare it against relevant sketching

Programming by Rewards

5

[Resource1]
RefreshInterval=00:01:00
PriorityHighUnderloaded=97
PriorityHighOverloaded=98
PriorityLowUnderloaded=88
PriorityLowOverloaded=90
...
[Resource2]
RefreshInterval=00:01:00
PriorityHighUnderloaded=80
PriorityHighOverloaded=90
...

double ScoreLinesMap(double sel, double lines) {

double minScore = 100.0;
double alpha = 1.0; double beta = 1.0;
return alpha * sel + beta * lines + minScore * 20;

}
bool IsLikelyDataRatio(int dataCount, int totalCount) {

if (totalCount < 10) return dataCount >= 6;
if (totalCount < 20) return dataCount >= 15;
if (totalCount < 50) return dataCount >= 30;
return dataCount / (double) totalCount >= 0.6;

}

Fig. 1. (left) A configuration file is a common coding pattern for hard-coding constants/settings in software,
and (right) Implementations of a rule for scoring programs, and a control logic for determining the value of a
boolean state variable; both part of the widely-deployed program synthesis SDK, PROSE [PROSE 2015].

and reinforcement learning based baselines. In Section 6, we survey related work, and finally
conclude with Section 7.

2 PROBLEM FORMULATION
This section formally introduces Programming by Rewards (PBR) problem for synthesizing decision
functions. We start by motivating and defining the class of decision functions considered in this work.
We set up the PBR problem with an example, and discuss how it relates to the standard sketch-based
synthesis problem. Next, we give an equivalent formulation of the problem using decision trees. This
lets us formulate the problem as a learning problem which can leverage continuous-optimization
based techniques and provide significantly more efficient algorithms.

2.1 Decision functions in real-world software
We motivate our approach by showing various examples of decision functions that are currently
written manually by programmers. We performed extensive studies of such decision functions in
two domains:

• Efficient search. There are many problem domains where we need to search through the
space of solutions in a combinatorial space. This includes SAT and SMT solvers, as well as
program verification and synthesis engines. Software written for such domains often involve
several heuristic decisions made in the code. Figure 2 shows a snippet of a hybrid branching
heuristic implemented in the MapleGlucose SAT solver [Liang et al. 2016]. We notice the
rather obscure choice of constants and thresholds in the conditionals as part of the heuristic.
• Ranking heuristics. Program synthesis and in particular programming-by-example engines,
e.g., PROSE (which has found adoption in multiple mass-market products), need to deal with
ambiguity in the user’s intent expressed using a few input-output examples. This is done by
carefully implementing ranking heuristics to select an intended program from among the
many that satisfy the few input-output examples provided by the user. A significant fraction
of developer time is spent on hand-crafting these heuristics for each new domain where
PROSE is applied. Each new domain is characterized by a different DSL, and the nature of
the DSL and the programs we seek determines which production rules we want to favor,
which is in turn determined by the decision functions. We study decision functions from
PROSE, which is an industrial strength program synthesis system. The example decision
functions in Figure 1 is from real-world ingestion software built on top of PROSE. The function

6

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

bool Solver::search(int nof_conflicts)
{

...
for (;;) {

...

if (S > 0.06 )

S -= 0.000001 ;

if(conflicts % 5000 == 0 && var_decay < 0.95 )

var_decay += 0.01 ;

...

}

}

Fig. 2. Code snippet from MapleGlucose SAT solver [Liang et al. 2016] that implements a hybrid LRB-VSIDS
branching heuristic in the search procedure.

implements a heuristic for deciding header to data ratio in the input file; the examples in
Figures 6 and 15 are ranking heuristics for example-based string transformations widely used
inside a mass-market spreadsheet product. We observe that these decision functions either
involve simple (linear) operations on the input variables, or compute decisions based simple
branching decisions on the input variables.

• Real-time services. Large-scale services for workload management and scheduling, cloud
database management servers (AzureSQL), etc. often have configuration settings and param-
eters to ensure optimal performance of the service in terms of latency, efficiency and cost.
Often, these settings are defined in one-size-fits-all manner relying on wisdom-of-the-crowd
or other heuristics. Figure 1 (left) shows the configuration snippet from a real-time scheduling
service that is part of a mass-market commercial software system. These are the simplest
type of decision functions, i.e. constants that one need to set optimally in a dynamic fashion
to account for the continuously-changing system.

We observe that the decision function instances cited above, and more generally arising in these
software domains, have the following characteristics:

(1) Operations are restricted to linear combinations of program variables; however, the pa-
rameters in the operation can be real numbers (expressed using floating point or decimal
notation).

(2) There are nested if-then-else conditions, but the conditions are also expressible by linear

combinations of input variables.

(3) There are no loops.

This observation lets us define the following language that contains commonly-arising decision
functions. Variants of this language have been used in program synthesis and in sketching [Bornholt
et al. 2016; Chaudhuri et al. 2014].

2.2 A DSL for decision functions
Definition 1 (Language Imp). We consider the language Imp of programs with imperative updates
and if-then-else statements without loops. Programs in Imp operate over real valued variables; in
particular, Imp allows linear transformations over the input variables x ∈ R in both conditionals as
well as assignments to local variables o ∈ R. The function returns a tuple of local variables as decision

Programming by Rewards

values.

7

P

S

::= S; return (o1, o2, . . . , om)
::= o = E
(cid:12)
(cid:12) if (E > 0) then S1 else S2
(cid:12)
(cid:12) S1; S2

::= W1 · x1 + W2 · x2 + · · · + Wp · xp + Wp+1

E
W ::= K (cid:12)

(cid:12) ??

where K is a numerical constant in R, and "??" denotes a hole.

Given the definition above, we can define decision functions formally as programs in Imp that
take p program variables as input and return m decision values as output. It is easy to see that
the functions in Figure 1 are in Imp, with p = 2 and m = 1. Furthermore, we observe that in some
of the real-world settings, the decision functions that programmers write (including some of the
aforementioned examples) do not require the full expressiveness of Imp, but can be even more
concisely specified (as presented below) — this facilitates provably-efficient algorithms in such
settings (Section 4).

Definition 2 (Languages Linear and Const).
1. Linear ⊂ Imp consists of linear functions with no if-then-else branches; e.g. Figure 1 (right),
Figures 6 and 15.
2. Const ⊂ Linear consists of constants, the most basic form of decisions, W1 = W2 = . . . = Wp = 0
in Linear; e.g. Figure 1 (left).

2.3 PBR formulation
Let f ∈ Imp denote a decision function. In our PBR setup, the decision given by f is fed into a
black-box program (software) in some arbitrary language L (typically much more complex than
Imp); we have no knowledge of L. Let us denote by r , a reward metric that quantifies some aspect
of executing the software using the decisions given by f . The reward may be assigned a value,
which depends not only on correctness of the execution but also on nonfunctional aspects such
as performance, latency, throughput of resource utilization. Formally, r : f (cid:55)→ R. The following
example illustrates this set up.

Example 1. Consider the program shown in Figure 3. Here, we show how to use the PBR system to
automatically learn a decision function in place of the manually written function IsLikelyDataRatio
from Figure 1. The decision function learned by the PBR system is identified by a unique identifier
PBRID_IsLikelyDataRatio for the function in the PBR.DecisionFunction method. For each file,
the function determines if we need to invoke an expensive pre-processing method before parsing the
file. A reward metric for the execution, which could potentially have multiple invocations of many
decision functions, is assigned using the PBR.AssignReward method.

In this example, we have a single instance of a decision function invoked multiple times, once for
each file. The reward takes into account both the effectiveness of processing, which is the number of files
processed successfully, and the efficiency of processing as measured by the time taken for processing all
the files. Ideally, we want to balance the goals of successfully processing the files with spending less
time on pre-processing. The goal of the PBR system is to learn a decision function which maximizes the
expected reward.

With this notation, we formally state the Programming By Rewards (PBR) problem.

8

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

int ParseAndProcessFile(string fileName)
{

string contents = read(fileName);
int[2] counts = getCounts(contents);
if (PBR.DecisionFunction(PBRID_IsLikelyDataRatio, count[0], count[1]))

preProcess(fileName);

parseFile(FileName);
return (processFile(fileName));

}
void main()
{

double successes = 0.0;
StopWatch sw = new StopWatch();
sw.Start();
foreach (string fileName in Config.Benchmarks):

successes += ParseAndProcessFile(fileName) > 0 ? 1: 0;

sw.Stop();
double reward = (success/Config.Benchmarks.Length) - (sw.ElapsedMilliseconds/1000);
PBR.AssignReward(reward);

}

Fig. 3. A C# program that uses the PBR system to automatically learn a decision function in the place of the
manually written function IsLikelyDataRatio from Figure 1.
Definition 3 (Programming By Rewards (PBR)). Given a specification consisting of:

(1) The input variables x ∈ Rp to the decision function f : Rp → Rm, with their data types, and

the decision type,

(2) Query-access to a black-box reward function r : Rm → R, which assigns a reward value for the

execution of the software with the provided decision values of f ,

the goal of PBR is to synthesize an optimal f ∈ Imp such that:
E[r (f )],

f ∈ arg max
f ∈Imp

where E denotes the expectation with respect to the randomness in r .

That is, the programmer provides input variables and reward function r , and expects a PBR
system to synthesize the program from the Implanguage (or a subset of Impdiscussed in next section).
Note that, our methods allow programmers to provide a sketch of the program from Imp, and in
general, that would lead to more efficiency. But as not providing any sketch is the extreme version
of this problem, we focus on it from our algorithmic development point of view, and leave further
experiments on completing partial sketches via rewards for future work.

We remark that the black-box reward functions r can be expensive to execute (or even disruptive,
in settings where the learning needs to happen in an online fashion in real-world deployments).
Hence, the complexity of any algorithm to the PBR problem needs to be stated in terms of the total
number of queries made to the reward function to learn a "sufficiently good" solution—we refer to
this as the sample complexity.

The PBR problem can, in principle, be phrased as a program synthesis problem with the language
Imp being used to specify a sketch representing the space of programs we need to search for
synthesizing decision functions. However, such an approach runs into many difficulties. The
parameters we want to determine range over real values, which do not work well with enumerative
search or symbolic methods using SMT solvers. Further, the outputs of decision functions routinely

Programming by Rewards

9

feed into modules with millions of lines of code. The reward function r can be quantitative and
the reward values can arrive much later in execution after many large modules are executed with
the decision values. Consequently, if we want to model PBR using sketching, the whole program
(which includes methods such as preProcess and parseFile in the example above) need to be
modeled as a white-box. Moreover, it is unclear as to how concepts such as execution time can be
modeled using sketching.

Aforementioned aspects distinguish our problem formulation from the standard sketch-based
synthesis formulations. In particular, sketching techniques that take in boolean [Bodik and Solar-
Lezama 2006] or quantitative specification [Chaudhuri et al. 2014], require complete knowledge of
the program that contains the holes, and white-box access to some functional form of the reward
function (which also needs to satisfy some constraints, and can not be arbitrary). Consequently,
many practical instances of PBR can not be posed as sketches.

3 EQUIVALENCE TO DECISION TREE LEARNING
We observe that the IMP programs are a form of decision trees with linear comparisons in nodes
and linear computations in leaves. Below, we establish the PBR learning problem as that of learning
optimal decision trees in presence of a black-box reward function, and then describe algorithms for
the latter. This allows us to make use of an elegant notation for describing our algorithms as well
as makes our algorithms relevant to a broader community.

For ease of exposition, we will consider m = 1 case below (i.e. the decision function returns only

one value); it is straight-forward to extend to the general setting.

Definition 4 (Decision Trees). A binary decision tree of height h represents a piece-wise linear
function fT (x; W, Θ) : Rp → R parameterized by (a) weights W = {wi j ∈ Rp, bi j ∈ R}, with
wi j at (i, j)th node (jth node at depth i) computing decisions of the form ⟨wi j , x⟩ + bi j > 0, and
(b) Θ = {θj ∈ Rp }, with parameters θj ∈ Rp that encode a linear model at each leaf node. The
computational semantics of the function fT is as follows: An input x ∈ Rp traverses a unique root-to-
leaf path in the tree, based on the results of the binary decisions at each height, with the convention
that the left branch is taken if the decision at the node is satisfied, or the right branch otherwise. The
output of the decision tree is θ∗ · x, where ∗ is the leaf node reached by x and · denotes the dot product.
Remark 1. The standard "regression tree" (decision tree for real-valued predictions) of height h is a
piece-wise constant function, i.e., fT realizes at most 2h unique values (one per leaf node). We consider
a more general and expressive tree, that represents a piece-wise linear function, as defined above.

Remark 2. The above definition of decision tree can be extended to the general m setting, by allowing
the leaf node parameters to be θj ∈ Rm×p ; W remains the same as above.

Figure 4 illustrates such a decision tree of height 3 computing a decision function. We note the
computational semantics of a decision tree is identical to that of if-then-else programs in Imp. Below,
we make this observation precise.

Lemma 1. For every program f ∈ Imp defined over p variables, there is a decision tree fT , as given in
Definition 4 that behaves identical to f on every input x ∈ Rp . In other words, for every f ∈ Imp, there
is fT such that f = fT .

In the worst case, a sequence of h conditionals in Imp can result in a complete tree of depth h
and size 2h. However, in practice, we find that our algorithms tend to learn sparse (i.e. with many
empty nodes that can be pruned) trees. Also, the sample complexity of our algorithms depend only
on m and not on the size of the tree. For these reasons, we do not worry about the exponential
blow-up, which can happen in the worst case when representing Imp programs as decision trees.

10

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

double throttle(double latency, double

load, double min)

{

}

double rate = 1.0;
if (latency < 5) return load;
if (load > 100)
rate = 0.5;

if (load * rate < min) return min;
return load * rate;

Fig. 4. (left) Example decision function in Imp, and (right) its equivalent binary decision tree with linear
models in the leaf nodes.

The converse of the above lemma also holds, which means we can convert any fT into an

appropriate Imp program.

Lemma 2. For every tree fT , there is f ∈ Imp that computes the same function as fT . Synthesizing
the program f given fT can be done in time proportional to the total number of nodes (which is at
most 2h+1 for a tree of height h) in the tree corresponding to fT .

3.1 Learning overview
In light of the equivalence between trees and Imp, we can pose the reward-guided synthesis problem
in Definition 3 as one of learning optimal decision trees, i.e. learning a tree fT that maximizes the
expected reward E[r (fT )].
Definition 5 (PBR via Tree Learning). Given a specification consisting of:

(1) The input features x(t ), 1 ≤ t ≤ T to the decision tree model fT ,
(2) Query-access to reward function r , which returns a scalar reward value r (fT (x(t ))) for decision

values fT (x(t )),

the goal of PBR can be re-stated as learning optimal decision tree model fT parameters, i.e.,

W∗, Θ∗ ∈ arg max
W,Θ

E

(cid:20) 1

T

(cid:213)

t

r (fT (x(t ); W, Θ))

(cid:21)

,

where E denotes the expectation with respect to any randomness in r and features x(t ). Note that once
we have the optimal tree model, we can synthesize the corresponding program in Imp by Lemma 2.

Following the machine learning convention, the observed variable values x ∈ Rp are referred to

as "features" or "context".

The above given reformulation casts the PBR problem as that of learning parameters of the
decision tree with a black box access to the reward function r . Note that as defined, formulation
covers a wide range of settings, e.g., offline setting where all input features x(t ) are available apriori,
or synthesis setting where we can design synthetic features x(t ) learn a decision tree. However, in
this work, we mainly focus on the more general and practical setting of online learning that we
describe below.

For ease, we will drop the subscript in decision tree fT and refer to the tree model by f , which
also stands for the Imp program it represents. We parameterize the model f by a vector w ∈ Rd ,
where d is the total number of parameters, and we write f (x; w) for x ∈ Rp . For example, in case
of decision tree model in Definition 4, w is simply the parameters W, Θ vectorized, and d here is
the total number of parameters in W and Θ. Note that d ≫ p in general; in case of tree of height h,

Programming by Rewards

11

d can be as large as (p + 1) · 2h+1, corresponding to p linear weights and a bias at each node in the
tree including the leaf nodes (Definition 4).

The learning problem proceeds in rounds, and in each round we observe features x(t ) and are
required to output decision values a(t ) = f (x; w) which is then consumed by a black-box to output
the reward value r (t )(w). The weights w can then be modified based on the latest reward value. In
this setting, the learning algorithm for PBR is an instantiation of Algorithm 1.

Now the goal of this learning problem is to learn a model parameterized by w so that the total
rewards are maximized. However, as w themselves are updated after each round, we use the
standard regret notion to study different algorithms. Regret of an algorithm is the loss in reward
when compared to the best solution “hindsight”, i.e., maxw
t =1 r (t )(w). Hence, the goal is to
minimize the regret of the algorithm defined as:

(cid:205)T

RT := max

a

1

T

T
(cid:213)

t =1

r (a) −

1

T

(cid:20) T

(cid:213)

E

r (a(t ))

(cid:21)

,

t =1

(1)

where the expectation E[.] is with respect to any randomness in the algorithm and in the reward
r . Note that the notion of regret is general, and supports offline setting where all x(t )’s are given
apriori and the goal is to find w that maximizes the cumulative reward function. Ideally, the regret
for an algorithm should decrease significantly with larger T , i.e., as we observe more rounds and
samples, the reward of the algorithm should be similar to the reward of an optimal model. The rate
of decrease of regret determines the sample complexity of the method, as introduced in Section 2.
Besides sample complexity, another important metric for a learning/synthesis algorithm that
proceeds in rounds to update the weights is that of update complexity, which denotes the time
complexity of the UpdateModel step of the algorithm. This determines the efficiency of learning
and in turn synthesis. The time complexity of synthesis is proportional to the sum of update
complexity and the expected time required to query the reward function once.

In practice, sample complexity is a more critical metric as each call of the reward function requires
running the entire system which can be quite expensive. In next section, we present algorithms
that are efficient in terms of the sample complexity and update complexity if the reward function
satisfies certain assumptions.

Algorithm 1 Learning in PBR

1: procedure LearnInRounds
2:
3:
4:

Initialize the model parameters w(0) ∈ Rd , choose δ > 0, and learning rate η
for t = 0, 1, 2, . . . do

Observe features (i.e. variable arguments) x(t ) := [x1, x2, . . . , xp ]
Compute decisions a(t ) := f (cid:0)x(t ); w(t )(cid:1)
Query reward r (t ) := r (a(t ))
Update w(t +1) = UpdateModel(x(t ), r (t ), δ, η)

5:

6:

7:

4 LEARNING ALGORITHMS
In this section, we present learning algorithms for the three types of decision functions introduced
in Section 2: constants, linear models and decision trees corresponding to languages Const, Lin-
ear and Imp respectively. That is, we instantiate Algorithm 1 for PBR when restricted to the above
mentioned languages and also in certain cases, present regret bounds.
Notation. In the following, bold small letters u, a, etc denote vectors. The subscript ui denotes the

12

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

Fig. 5. The black-box reward r modeled as r (a) where a = f (x; w) ∈ Rm but w ∈ Rd ; in practice, d ≫ m.
entry at the ith index of vector u. The norm of a vector is defined as ∥u∥2 =
cases, the dimensionality of the vector will be clear from the context.

(cid:113)(cid:205)

i u2

. In all the

i

4.1 Intuition behind the Algorithms
The key challenge with the problem is black-box access to the reward function, which disallows
standard white-box optimization methods like gradient-descent. However, over the years, opti-
mization literature has shown that for maximizing a given reward function, we do not require the
exact gradient. Instead, as long as we can compute an unbiased estimate of the gradient, we can still
allow strong optimization methods. Several existing methods show that we can estimate unbiased
gradient of a function by only black-box queries of the function at random points [Flaxman et al.
2005; Ghadimi and Lan 2013; Shamir 2017].

Our key insight is that we can produce more accurate estimates of the gradients by exploiting
the structure of the sketch, i.e. of the function to be learned. Recall that, we get reward r (a) for
action/decision-values a ∈ Rm, where a = f (x; w) for some sketch function f (like linear function
or decision-tree function) parameterized by weights w of dimension d and the input features x are
of dimension p. Now, if we use standard gradient estimates w.r.t. w then the error depends on the
dimensionality d of w due to random perturbation in each coordinate.

However, as the black-box acts only on m-dimensional decision values a, we can use chain-rule
and the fact that we know sketch function f completely to produce a significantly more accurate
estimate of the gradient that is dependent only on dimensionality of m of decision-values. In
several real-world codebases we observe that m ≪ d, and hence this technique is significantly
more accurate.

If the decision function is a tree, then there are additional challenges due to non-smooth and
piece-wise linear nature of such functions. We propose a differentiable and shallow neural network
model, and show that under some structural constraints, it implicitly represents decision trees.
Then, we learn the parameters of the shallow neural network using gradient descent, with the
perturbation trick. We also show that the framework is theoretically-founded —in cases when the
rewards satisfy nice properties, the parameters learnt, and in turn the synthesized code, is optimal
in a precise sense.

4.2 Learning constants (f ∈ Const)
We first consider synthesis with Const language, which reduces to learning a set of constants,
without any features. That is, in this case, the decision values given by the synthesized program (a)
are just the model parameters, i.e., a = w, and hence m = d. See Figure 1 (left) for an example of
such a sketch.

For Const language the problem reduces to the standard online learning with bandit feedback
problem, which can be solved using a randomized gradient descent algorithm proposed by [Flaxman
et al. 2005] (see Algorithm 2). Note that line 3 of the algorithm first estimates the gradient at a(t )
by using random perturbation u and then performs standard gradient ascent (because we are

Programming by Rewards

13

maximizing reward) over a using the estimated gradient. Also, while Algorithm 2 mostly follows
template of Algorithm 1, there is a minor difference which is that the reward function is not queried
at the predicted decision value a(t ), instead it is queried at a perturbation of a(t ).

Algorithm 2 Learning constants

1: procedure UpdateConstantModel (Input: x(t ), η, δ )
2:

Sample u uniformly from {u | ∥u∥2 = 1}
a(t +1) = a(t ) + η 1

δ r (a(t ) + δ u)u

3:

Note that in this language, there is no input context/features x, hence p = 0. Also, the number of
decision values is same as the number of parameters d. It is easy to see that the update complexity
of the method is only O(d). Below we formally state the sample complexity as well under certain
assumptions that we define first.

Definition 6 (Concavity). The reward function r is said to be concave if, for all a, a′ ∈ Rm and
λ ∈ [0, 1],

r (cid:0)λa + (1 − λ)a′(cid:1) ≥ λr (a) + (1 − λ)r (a′) .

Definition 7 (Lipschitz-continuity). The reward function r is said to be L-Lipschitz continuous if for
all a, a′ ∈ Rm,

|r (a) − r (a′)| ≤ L∥a − a′∥2 .

Theorem 1 ([Flaxman et al. 2005]). Assume the reward function r is concave (Definition 6) and
Lipschitz continuous (Definition 7). At the end of T rounds, Algorithm 2 satisfies:

where C > 0 is a global constant.

RT ≤ C ·

m
T 1/4 ,

That is, to ensure RT ≤ ϵ, the sample complexity of the algorithm is O(m4/ϵ 4). The above bound
can be further improved in settings (e.g. offline) where it is possible to obtain reward r (a) at two
different a values. In that case, the gradient estimator in Step 4 of Algorithm 2 can be replaced with:

a(t +1) = a(t ) + η
And the bound can be improved [Shamir 2017] as stated below.

(r (a(t ) + δ u) − r (a(t ) − δ u))u.

δ

1

(2)

Theorem 2 ([Shamir 2017]). Assume the reward function r is concave (Definition 6) and Lipschitz con-
tinuous (Definition 7). At the end of T rounds, Algorithm 2, with the “two-point” gradient estimator (2)
in Step 4, satisfies:

where C > 0 is a global constant.

RT ≤ C ·

m
T 1/2 ,

That is, in the offline setting, the rate of convergence wrt T improves significantly which is critical
for deployment of such solutions as the reward computation in general is expensive. Furthermore,
note that both the regret bounds suffer from a linear dependence on the number of constants to
learn (d = m) which is tight as the method is required to explore r (a) in all the m coordinates
to accurately estimate the gradient. So, if in the extreme case, if every parameter to tune in the

14

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

system is treated as individual constants, irrespective of the decision outcome’s structure, then
m = d which is expensive; typically number of outcomes m is an order of magnitude smaller than
the number of parameters d. The next two sub-sections discuss how one can exploit additional
structure in certain templates, when applicable, to reduce the dependence on d.

4.3 Learning linear models (f ∈ Linear)
Now let us consider the problem of synthesizing programs from the Linearlanguage, where the
decisions a are fixed to be a linear function of some observed features x. That is, a = f (x; w) where
f is a fixed linear function and x are the observed features/context. Note that unlike in Section 4.2
where a were fixed to be constant despite changing context of the system (x), in this case, we allow
a to change as a linear function of the features x.

Following the online setting described in Section 2, we observe features x(t ) ∈ Rp in the t-th
round and provide decision values a(t ) ∈ Rm given by a(t ) = w(t )x(t ) where w(t ) ∈ Rm×p . The
black-box system B then provides reward r (t )(a(t )) for the predicted a(t ), and the parameters w are
then updated based on the reward. Thus the regret is defined for this problem as:

RT := max
w

1

T

T
(cid:213)

t =1

r (cid:0)f (x; w)(cid:1) −

1

T

(cid:20) T

(cid:213)

E

t =1

r (cid:0)f (x; w(t ))(cid:1)

(cid:21)

.

(3)

Note that in this case, the number of parameters d = m × p which can be very large as in typical
systems, we would require several features to capture the context of the system. This is illustrated
(cid:101)r (w(t )) =
in Figure 5. If we treat w as constants to be learned and apply Algorithm 2 with rewards
r (w(t )x(t )), the regret for such a method would scale as d/T 1/4 = m · p/T 1/4. On the other hand, m
which is the total number of decisions a to be estimated tends to be significantly smaller (typically
<∼ 10). So the question is if we can devise an algorithm that scales better with d when m ≪ d.

Algorithm 3 Learning linear models

1: procedure UpdateLinearModel (Input: x(t ), η, δ )
2:
3:
4:

Define a(t ) := w(t )x(t ) ∈ Rm, where x(t ) ∈ Rp and w(t ) ∈ Rm×p
Sample u ∈ Rm uniformly from {u | ∥u∥2 = 1}
w(t +1) = w(t ) + η m

δ r (a(t ) + δu)u · (x(t ))T

We exploit the linear structure of the template to significantly reduce the regret and hence the
number of samples required to obtain good estimate of a. We make the following simple observation:
∇wr (x(t )w) = x(t )(∇ar (a))T where a := wx(t ) and (b)T is the transpose of b. Hence, the gradient
wrt w has a special form that requires estimating only a m dimensional vector ∇ar (a) instead of a
m × p-dimensional matrix. This leads to significantly cheaper gradient estimation step, implying
a tighter regret bound and sample complexity that we discuss below. Also, note that the update
complexity of the method is O(mp), which is optimal.

Our novel algorithm for updating w is given in Algorithm 3 and the regret of the algorithm is

given by:

Theorem 3. Let r be concave and Lipschitz continuous. Then the regret defined in Equation 3 for
Algorithm 3 can be bounded as:

RT = max
w

1

T

T
(cid:213)

t =1

r (cid:0)wx(t )(cid:1) −

1

T

(cid:20) T

(cid:213)

E

t =1

r (cid:0)w(t )x(t )(cid:1)

(cid:21)

≤ O

(cid:18) m
T 1/4 ·

(cid:113)max
t

(cid:19)

.

∥x(t )∥2

Programming by Rewards

15

The above regret bound implies sample complexity bound of O(m/ϵ 4) to ensure regret of ϵ. The
proof of the theorem relies on Lemma 3.1 of [Flaxman et al. 2005]; but the key observation we make
is that the norm of the noise in the gradient in Step 5 of Algorithm 3 is bounded by O(m) rather than
O(d), if we appropriately choose δ and η at line 4. See Appendix B for details. Note that the above
regret bound is dependent only on m and is completely independent of d given m. Dependence on
d (through p) can creep through ∥x(t ) ∥2 but several practical problems tend to have small ∥x(t )∥2
and in general such a bound is considered to be “dimension independent”. In contrast, the regret of
Algorithm 2 is bound to suffer a linear dependence on d = mp. This implies significantly smaller
regret for Algorithm 3 for m ≪ d which is a typical case in practical applications. Finally, similar to
the previous section, in the offline deployment setting with two-point feedback, the regret bound
decreases at T −1/2 rate.

4.4 Learning tree models (f ∈ Imp)
In this section, we discuss our method for synthesizing a program from the general Imp language.
As discussed in Section 2, the problem is equivalent to that of learning a general decision tree
with rewards, which is a challenging problem and has been relatively unexplored in both machine
learning and programming languages literature.

Recall that the decisions a are fixed to be a function f of the context (x ∈ Rp ), where f is a tree

structured function, i.e., a = f (x; w) with f being a decision tree parameterized by w.

As in Algorithm 1, the learner would observe x(t ) in the t-th round, propose w(t ) to predict
decisions a(t ), receive reward r (a(t )) and the goal is to optimize the reward. If we ignore the tree
structure of a and treat w as the parameters to be learned using constant template and apply
Algorithm 2, it would lead to poor regret and hence many rounds for learning a good solution (as
discussed in linear templates). The reason is that the size of w typically increases exponentially
with the height of the tree, which implies that the regret bound of Section 4.2 would also increase
exponentially with the height of the tree.

Instead, we use the following observation, that we exploited in the previous section as well (for

simplicity we provide this observation when a ∈ R is a scalar):

∇wr (f (x(t ); w(t ))) = r ′(a(t ))∇w f (x(t ); w(t )),
where ∇wr (f (x(t ); w(t ))) is the derivative of r (·) wrt w, evaluated at w(t ). Now, r ′(a) is the first
derivative of r evaluated at a(t ) = f (x(t ); w(t )) and ∇w f (·) is the derivative of f (·) wrt w.

Note that we do not know function r and can only receive feedback r (a(t )), so r ′ would be
computed using the standard perturbation based technique (see Algorithm 2). However, as we
know function f , we can evaluate ∇w f (·) accurately assuming f represents a differentiable tree
function. Together, this can significantly reduce the number of prediction-reward feedback loops
for learning the template, even though the number of parameters w can be very large — as r ′ is a
one-dimensional quantity (and in general m dimensional where a ∈ Rm) and only very few random
perturbations are required for its accurate estimation. The key challenge here is that the algorithm
requires computing gradient of f (·) wrt w which in general is a challenging task due to the discrete
structure of trees. In this work, we develop a novel differentiable model for trees.

4.4.1 Decision Trees as Shallow Nets. The core idea of our approach and the motivation are
as follows. Learning decision tree models is intractable in general, and is hard even for well-
behaved known reward functions, because: (a) it is highly non-smooth and (b) the function class is
piecewise-constant (or piecewise-linear). Existing approaches typically try to solve the problem
greedily [Carreira-Perpinán and Tavallali 2018] or try to come up with a smooth relaxation or
upper bound of the loss function [Norouzi et al. 2015]. A major shortcoming of these techniques is

16

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

that they are tied to a specific loss (reward) function or type of decisions made and therefore do
not extend to more general settings.

Our non-greedy approach uses a differentiable and shallow neural network model for learning
decision trees and works with any general loss/reward function. Moreover, we can formally show
that the neural network architecture under some structural constraints is equivalent for decision
trees, thus allowing gradient based training methods for learning tree parameters. We refer to this
model as EntropyNet, denoted by fNet. The details of this approach are given in Appendix A.

Algorithm 4 Learning trees in PBR

1: procedure LearnInRounds (Input: h)
2:
3:
4:
5:

Initialize EntropyNet fNet parameters (vectorized)
Choose δ > 0, and learning rate η
for t = 0, 1, 2, . . . do

Observe features x(t ) := [x1, x2, . . . , xp ]
Define a(t ) := fNet(x(t ), w(t )) ∈ R, where x(t ) ∈ Rp are input features
Sample u ∈ R uniformly from {−1, 1}
(cid:101)w(t ) + η
Update

δ r (a(t ) + δu)u · ∇

(cid:101)w fNet(x(t ), (cid:101)w(t ))

(cid:101)w(t +1) =

6:
7:

8:

9:

(cid:101)w(0) ∈ Rd for the given height h

return Tree model (Definition 4) W, Θ = InferTree((cid:101)w, h) (Algorithm 5 in Appendix B)

Algorithm. We provide the pseudo-code for learning trees, for the case when a ∈ R, in Algo-
rithm 4 (which also subsumes the basic skeleton in Algorithm 1) but it can be easily extended to
the general decision functions in Imp (that return m values instead of 1). Note that the algorithm
learns parameters for the equivalent function fNet and eventually returns the intended decision tree
function (which can be easily inferred given fNet via InferTree procedure stated in the Appendix B).
While intuitively exploiting the tree structure should lead to significantly smaller regret bound, it
is difficult to provide a rigorous analysis of the same. Due to tree structure f (·) being a non-convex
function, the standard online learning techniques [Flaxman et al. 2005] do not apply in this case.
While certain novel techniques like [Agarwal et al. 2019] have been designed for non-convex
optimization, we leave further investigation into the regret bound and hence the sample complexity
of this method for future work.

4.5 PBR usage in practice
Here we briefly discuss how our PBR method can be applied in real-world codebases. At a high level,
the programmer must first decide the set of decision values that are critical to the performance of the
system, and also figure out the context/features important for setting the decision values. Then, the
programmer sets up a reward function based on critical metrics that needs to be optimized. Finally,
the programmer can either specify the language (Const, Linear, Imp) from which a program should
be synthesized. Our tool takes care of storing the feature values and the corresponding reward
functions, and learning the appropriate decision function. See Appendix D for more details about
the front-end that enables using our PBR method easier for developers. Note that our exposition
focus only on setting where programmer does not provide any partial sketch; further empirical
validation of our methods in partial sketching settings is left for future work.

While our sample complexity bounds hold only for Lipschitz continuous and concave functions,
in practice the functions might have discontinuities. However, we observe empirically that our
method is indeed able to learn effective function/sketch parameters. We attribute this to the fact
that in practice, the reward function would have a few points of discontinuities [Chaudhuri et al.
2012], thus the sample complexity is small in large portions of the parameter space. Furthermore,

Programming by Rewards

17

perhaps the first order or second order optima (instead of global optima) are also reasonably good
solutions, which can be ensured by techniques similar to our method [Agarwal et al. 2019]. We
leave rigorous analysis of practical reward functions and our methods in those settings to future
work.

5 IMPLEMENTATION AND EVALUATION
In this section, we discuss implementation and present empirical evaluation of our algorithms.
Our algorithms for the PBR framework operate in both online and offline settings requiring only
black-box access to the reward function, and the key benefit of our algorithms is in settings where
the structure of the decision function/sketch (linear or tree) can be exploited. We design evaluation
studies that bring out some of these aspects and merits under different settings. In particular, we
seek answers to the following questions.

(1) In practice, how well do our algorithms help learn decision functions in codebases with complex
reward functions? In this study, we apply our algorithms to synthesize search and rank-
ing heuristics in the widely-used [PROSE 2015] codebase for synthesizing data formatting
programs in the FlashFill DSL.

(2) How do our (black-box) PBR algorithms compare with white-box synthesis techniques? As it is
difficult to construct strong real-world examples of white-box reward functions, we consider
somewhat artificial programs proposed by prior work [Chaudhuri et al. 2014], where the
entire system, including reward function, is available as a white-box, and the reward function
can be invoked as many times as desired. In this artificial setting, we compare our approach
with Sketch [Bodik and Solar-Lezama 2006], which uses SAT solvers to synthesize integer
valued parameters, and Fermat [Chaudhuri et al. 2014], which synthesizes continuous valued
parameters using numerical methods.

(3) Does exploiting structure in the decision functions really help? Here, we want to compare our
algorithms that exploit the decision function structure presented in Section 4 against treating
the synthesis as a sketch with missing numerical parameters, which can be addressed using
black-box reinforcement learning style methods.

Evaluation settings and baselines. We work with both online (where we need to take decisions
at every round) and offline settings, and black-box rewards. We evaluate and compare PBR algo-
rithms with different baselines, each applicable only to certain settings unlike our algorithms (and
therefore selectively used for comparison in the aforementioned three studies as applicable): (1)
general-purpose (evolutionary) optimization algorithms in the popular open-source Nevergrad plat-
form [Rapin and Teytaud 2018], which is also applicable to black-box, offline and continuous
parameter settings; and (2) the multi-arm bandit formulation [Bietti et al. 2018] that is currently
used in the popular DecisionService [Agarwal et al. 2016], an enterprise-scale reinforcement learn-
ing framework, that works in black-box and online learning settings, but is restricted to discrete
parameters/decisions (such as recommending ads or news articles to users); and (3) the Sketch syn-
thesis tool [Bodik and Solar-Lezama 2006] which is applicable to white-box and offline settings, and
can synthesize integer-valued parameters; and (4) the Fermat tool [Chaudhuri et al. 2014], which
is also applicable to white-box, offline settings, and can synthesize continuous-valued parameters.

5.1 Implementation
We have implemented the PBR framework (PBR.DecisionFunction and PBR.AssignReward API
introduced in Section 2), and the learning algorithms presented in Section 4 as a utility library (with
support for C# and Python languages) for software developers. Our implementation also provides
flexibility and customization capabilities to the developer in terms of explicitly providing domain

18

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

public double RegexPair(double bias_RegexPair, double score_RegexPair_r, double

score_RegexPair_r2) {
return -0.205 *bias_RegexPair +
1 *score_RegexPair_r + 1 *score_RegexPair_r2;

}

Fig. 6. The RegexPair heuristic in PROSE [Natarajan et al. 2019; PROSE 2015] with parameters of interest
highlighted.

knowledge (for example, the developer can suggest one of Imp, Const or Linear to synthesize
an appropriate decision function) and ability to inspect and debug the synthesized code for the
decision function (instead of working with the tree or linear model as a black-box). Details of the
API are given in Appendix D. All experiments are conducted on a standard desktop machine with
16GB RAM, 2GHz processor and 4 cores.

5.2 How well do our algorithms help learn decision functions in real codebases with

complex reward functions?

PROSE [PROSE 2015] is a well-known framework for programming by examples (PBE). It has been
instrumental in developing software for many practical applications around data ingestion [Iyer
et al. 2019; Raza and Gulwani 2018], formatting, spreadsheet processing [Gulwani 2011], web
extraction, program repair and transformation [Le et al. 2017; Rolim et al. 2017], and more. PROSE
provides a meta-framework [Polozov and Gulwani 2015] for (a) defining a domain-specific language
(DSL) for programs of interest, (b) synthesizing programs from a given input-output specification
in a divide-and-conquer fashion, (c) pruning the search space, and (d) ranking the (sub)programs to
narrow down to one or a few programs intended by the user. Often, software applications built
over the PROSE engine require coming up with their own DSL (e.g. spreadsheet processing vs web
extraction) and ranking function.

Several critical decision making points exist in the resulting software; in particular, developers
write several complex heuristics for determining how to score different operators in the DSL
and ranking the sub-programs that these operators compose, and in turn, for choosing the “best
programs” capturing the user intent with very few input-output examples. There is a growing line
of research in the intersection of programming languages and AI [Gulwani and Jain 2017]. In this
study, we consider the popular spreadsheet processing application DSL [Gulwani 2011] that has
been commercially deployed [PCWorld 2012]. The corresponding ranker (available here [PROSE
2015], details are provided in [Natarajan et al. 2019]) has several heuristic rules, each implemented
as a function involving multiple hard-coded constants and features. For instance, the RegexPair
rule shown in Figure 6 has three hard-coded constants.

We consider the problem of learning these typically hand-tuned parameters to improve the
performance of PROSE as measured on a set of curated benchmark tasks [Natarajan et al. 2019].
Here, the reward function is defined as the fraction of tasks for which the software synthesizes a
correct program for. This reward function is highly discontinuous and complicated, and computing
the function involves running the entire software with complex recursive algorithms interleaving
synthesis and ranking. But, we know that the constants in the ranking functions (e.g., Figure 6)
heavily influence the performance of PROSE on most of the tasks, and thus, the reward. Note that
evaluating the reward function is expensive in terms of time — a single evaluation takes nearly
10 minutes. So we evaluate algorithms based on the number of reward computations (sample
complexity) as well as the time taken to converge to a good solution (i.e. one that achieves good
performance on the benchmark).

Programming by Rewards

19

Recall that due to black-box nature of the reward function, existing sketch methods that require
whitebox access do not apply [Bodik and Solar-Lezama 2006; Chaudhuri et al. 2014]. Instead, we
compare our method against a multi-arm bandit method (UCB, as implemented in the open-source
framework SMPyBandits [Besson 2018])– a popular reinforcement learning style method. However,
UCB requires discretization of the real-valued parameters into a small number of actions, which
means that the number of actions grows exponentially with the number of parameters and can be
tricky when tuning parameter values of high precision. In this case, we discretize each parameter
value into 9 bins around 0 (which is a good initial solution). This implies that just for one of the
heuristics (RegexPair mentioned above), the total number of actions (from which UCB chooses
one set of decision-value/action) turn out to be 729. So, to ensure applicability of the UCB method,
we initially focus only on learning one heuristic function in PROSE codebase.

Figure 7 (a) shows the comparison of PBR and UCB algorithms for learning the three parameters
associated with the RegexPair function (Figure 6). We observe that (a) PBR quickly ramps up the
reward in about 50 queries (in about 6 hours), whereas the UCB algorithm spends a lot of time
and queries performing “explore-exploit” of multiple independent actions, without gaining enough
confidence on any particular action. Even if we reduce the action space of UCB to 125 actions (i.e.
discretize each parameter into 5 bins instead of 9), the performance of UCB is still significantly
worse than PBR as observed from Figure 16 (in Appendix C). The observations are similar in Figure
7 (b) that shows a comparison for synthesizing the FormatDateTimeRange function (Figure 15 in
Appendix C) which has a larger number of parameters to learn.

An important aspect of evaluation of parameter learning is how often the software or the system
that is tuned is exposed to “bad” rewards. We find that PBR spends much smaller fraction of time
with low rewards as against UCB (Figures 17 and 18 in Appendix C).

Deployment. Next, we deployed our PBR framework to jointly learn the parameters (d = 490)
for all the ranking heuristics/decisions (m = 70) in the PROSE codebase for spreadsheet processing
DSL. At convergence (after nearly 100 hours, 250 queries), we observed that the parameters learnt
by PBR improved the correctness of the system by nearly 8% compared to the state-of-the-art
results [Natarajan et al. 2019] on the benchmark consisting of 740 tasks. In particular, with the
learnt parameters, PROSE system achieved an accuracy of 668/740 compared to 606/740 obtained
by [Natarajan et al. 2019], and 703/740 obtained by domain experts over multiple years by hand-
tuning heuristics in the PROSE codebase today. A key factor for success of PBR here is that it
optimizes for the metric of interest directly, in contrast to the ML approach in [Natarajan et al.
2019]. Finally, note that we couldn’t apply UCB method for learning all the 70 decision functions as
it requires discretization of the entire decision-value space which leads to exponential blow-up.

5.3 How do our algorithms compare with white-box synthesis techniques?
Here we compare PBR to program synthesis techniques such as Sketch [Bodik and Solar-Lezama
2006], which synthesizes parameter values for integer holes using CEGIS techniques implemented on
top of SAT/SMT solvers, and Fermat [Chaudhuri et al. 2014], which synthesizes continuous-valued
parameters using numerical methods. We also compare with a optimization algorithm implemented
in the open-source Nevergrad platform [Rapin and Teytaud 2018]. Specifically, we use TBPSA, an
evolutionary algorithm that can perform well in continuous, stochastic settings [T. Cazenave 2019].
While our methods allow for realstic settings of online and blackbox rewards, but to ensure fair
comparison against existing methods, we restrict this set of experiment to restricted and artificial
contexts where we have white-box access to the entire system, including the reward function, and
the reward function can be invoked as many times as desired.

20

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

(a)

(b)

Fig. 7. (Smoothed) Reward over time wrt number of calls to reward oracle to learn different functions in
PROSE. For the multi-arm bandit formulation (UCB), we discretize each parameter before execution. (a):
Learning RegexPair with 3 parameters (Figure 6). For UCB, we discretize each parameter into 9 values
resulting in 9 ∗ 9 ∗ 9 = 729 actions. The sample complexity of UCB is quite high and the solution it obtains is
relatively poor even after nearly 1 day. (b) Learning FormatDateTimeRange with 10 parameters (Figure 15 in
Appendix C). For UCB, we discretize each parameter into 5 values resulting in 510 ∼ 9 million actions.

First, we generate problems of the following type, where the goal is to learn a Linear decision

function f (·; w), with integral w ∈ Zd , such that the following expected reward is maximized:

E[r (cid:0)w · x(cid:1)],

max
w∈Zd

(4)

where the expectation is with respect to randomness in the features x and the reward r (.) is set to
be negative of loss ℓ (minimizing the loss is equivalent to maximizing the reward), defined below:

ℓsq(y) := (cid:0)y − y∗(cid:1) 2

, or ℓabs(y) := (cid:12)

(cid:12)y − y∗(cid:12)
(cid:12).

(5)

The values y∗ are chosen to be such that y∗ = w∗ · x for some fixed w∗ ∈ [0, 1, 2, . . . , 10]d which
is the optimal solution to the problem (4). We assume a uniform distribution over n features x to
compute the expectation in (4). We fix n = 2d in all cases (which is sufficient for learning).

The Sketch implementation is given in Figure 19 (Appendix C.2). For PBR, we use Algorithm 3

(fixing δ = 0.5 and η = 2 × 10−3) meant for Linear decision functions.
Remark 3. We restrict the search space for Sketch further by ensuring that w∗ values are non-negative
(requirement of the tool), small and bounded; we explicitly add these bound constraints in the Sketch
problem specification. See the assertion in Figure 19. Furthermore, in all the experiments, we work
with 4-bit integers for holes, which we know is sufficient, using the flag bnd-cbits in the Sketch tool.
Using larger-sized integers will only increase the computation time.

We create multiple problem sets varying number of parameters d in Equation (4). To account for
randomness in algorithms as well as in problem sets themselves, we repeat each experiment 10
times and report (a) accuracy, i.e. how often does the method solve the problem (4) exactly, and (b)
mean and standard deviation of time taken to solve. Results are presented in Table 1, for the two
loss functions given in (5). It is clear that the search algorithm of sketching takes prohibitively long
time, and fails to solve the problem even for small values of d within the budget of 1 hour (and in
many cases, we find that the tool prematurely fails well before the timeout despite multiple restarts
with random seeds). In case of squared loss ℓsq, sketching totally fails because it involves using

Programming by Rewards

21

Table 1. Comparison of techniques on parameter learning problem in Equation (4), for the two losses defined
in Equation (5), for increasing number of parameters (holes) d. The implementation of Sketch is given in
Figure 19. For each d, we create 10 problem sets and report the mean and the standard deviation of the time
taken (in seconds) to solve the problems. The number of cases successfully solved out of 10 is indicated in
parentheses. Timeout is set to 1 hour.

d

2
4
6
8

Sketch
0.49 ± 0.04 (10)
9.65 ± 7.72 (10)
582.1 ± 425.0 (5)
- (0)

ℓabs
PBR (Alg. 3)
0.04 ± 0.01 (10)
0.04 ± 0.01 (10)
0.07 ± 0.03 (10)
0.06 ± 0.02 (10)

Nevergrad
298.66 ± 555.73 (5)
- (0)
- (0)
- (0)

Sketch
70.8 ± 73.95 (10)
- (0)
- (0)
- (0)

ℓsq

PBR (Alg. 3)
0.01 ± 0.00 (10)
0.01 ± 0.00 (10)
0.01 ± 0.00 (10)
0.02 ± 0.01 (10)

Nevergrad
0.41 ± 0.15 (3)
- (0)
- (0)
- (0)

(a) Squared loss ℓsq

(b) Abs. deviation loss ℓabs

Fig. 8. Expected reward (in problem (4)) vs. number of queries to reward r for loss functions in Equation (5).
multiplication circuits in the back-end SAT problem. Our algorithm solves every problem instance
(as guaranteed by Theorem 3). Even the general-purpose, continuous, black-box optimization
algorithm of Nevergrad fails to compute the exact solution in most of the cases within 1 hour. The
progress of Nevergrad and PBR algorithms against # reward queries is shown in Figure 8.

We tried to relax the sketch specification to not require exact solution to problem (4) but

approximate to a small additive error; however, the sketch tool still fails (See Appendix C.2).

Next, we compare PBR with the Fermat tool [Chaudhuri et al. 2014] for numerical parameter
synthesis with quantitative as well as boolean specification, on the synthesis benchmarks studied
in [Chaudhuri et al. 2014]. In particular, their technique has white-box access to the cost function
that is part of the sketch. The input to Fermat is (1) a sketch implementing a cost function that
returns a real value, with some holes for constants (that need to be learned) and probabilistic
assertions, and (2) a distribution of the input values. The goal is to learn values for the constants
minimizing: (a) the probability that the assertions fail, and (b) the expected value of the function
(which computes some notion of error).

Figure 9 shows example of such a function sketch; the Thermostat function takes two probabilis-
tic inputs (lin and ltarget), has three holes at lines 2-4 (??(c1, c2) denotes a hole with additional
insight that the parameter is likely to lie in the interval [c1, c2] [Chaudhuri et al. 2014]), contains
four assertions at lines 6, 7 and 16, and returns a double value representing the error. Given the
distribution of the input variables, the goal is to find the values for the three constants, such that
probability for assertions failing and the expected error are minimized.

22

1
2
3
4
5
6
7
8
9
10
11
12
13
14

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

double Thermostat(double lin, double ltarget) {

double h = ??(0, 10); double tOn = ltarget + ??(-10,0);
double tOff = ltarget + ??(0, 10); bool isOn = false; double K = 0.1;
assert(tOn < tOff; 0.9); assert(h > 0; 0.9); assert(h < 20; 0.9);
for (int i=0; i<40; i = i + 1) {

if (isOn) {

curL = curL + (h - K * (curL - lin)); if (curL > tOff) isOn = false;

} else {

curL = curL - K * (curL - lin); if (curL < tOn) isOn = true;

}
assert(curL < 120; 0.9);

}
return abs(curL - ltarget);

}

Fig. 9. Thermostat sketch.

Table 2. Comparison of PBR with Fermat on two synthesis tasks from [Chaudhuri et al. 2014].

Benchmark

Time (minutes)

# iterations

Error

Thermostat
Aircraft

Fermat
119.29 ± 98.07
333.57 ± 4.53

PBR (Alg. 2)
5.15 ± 3.62
6.66 ± 1.98

Fermat
2999.43 ± 91.93
4232.59 ± 313.65

PBR (Alg. 2)
781.11 ± 546.42
994.50 ± 273.29

Fermat
4.61 ± 2.32
18.09 ± 2.89

PBR (Alg. 2)
2.74 ± 0.71
25.22 ± 1.56

Setting up the problem in PBR. We model this setting in PBR, using Algorithm 2, as follows.
We generate n = 10, 000 inputs for the cost function by sampling the input distribution. We define
the loss as the squared error (the value returned by the sketch cost function) plus a very high
additive cost for any assertion violation (we use 1000), and set the reward r to negative of this loss.
We consider Algorithm 2 converged when there is no improvement in the reward for 100 iterations.
Following the experiment in Chaudhuri et al. [2014], we run both Fermat and PBR 80 times per
problem, varying the initial random seed where the search starts.

Results. We compare the tools on two problems from Chaudhuri et al. [2014]: Thermostat (in
Figure 9) and Aircraft (details in Appendix C.3). We look at the time taken and the number of
reward queries required for the algorithms to converge to some good solution, the mean error over
all 80 runs (the error of a run is expected error over all inputs). The results are given in Table 2.
We observe that Fermat (a) takes much longer time to converge than PBR, and (b) uses many
more reward queries to converge. Our algorithm outperforms Fermat in the Thermostat sketch
in terms of the quality of the constants learnt, but is worse in the Aircraft sketch. On the other
hand, Fermat requires white-box access to the code, and its applicability is very limited.

5.4 Does exploiting structure in the decision functions really help?
We now present examples to show that our algorithms can indeed exploit structure in decision
functions, in order to learn a good solution to the synthesis problem with small number of queries
to the reward function r , even though the number of parameters d may be very large. For the
case of Linear decision functions, Theorem 3 provides a theoretical guarantee for how exploiting
the linear structure helps in terms of sample complexity. On the contrary, for decision trees
(i.e. general Imp decisions), such a rigorous analysis is difficult. To this end, we consider three
different Imp decision function instances, and empirically evaluate the tree learning Algorithm 4
against posing the tree learning problems as sketches, treating every numerical parameter in the
tree as a hole, and applying the Algorithm 2 that disregards any structure.

Programming by Rewards

23

Fig. 10. Reward vs number of queries to reward r for learning two different tree decision functions using
Algorithm 4 and Algorithm 2. (a): (Xor in Figure 21) The learnt decision function is given in Figure 23 (Appendix
C); (b): (Slates in Figure 22) The learnt decision function is given in Figure 24 (Appendix C).

First, we consider an Imp decision function that has the Xor structure, modeled on two features
distributed as given in Figure 21 (in Appendix C). Next, we consider a more complex hypothetical
tuning problem Slates, where we wish to learn a piece-wise constant threshold function based on
the values of two observed features, that decides what the threshold for the input should be (these
type of heuristics are common in systems). In the setup, we have 6 different possible thresholds
that depend on the features as shown in Figure 22 in Appendix C. In both the cases, the reward is
negative of squared loss ℓsq defined in Equation (5) between the actual and predicted value. Figure
10 compares the performance of learning constants directly vs. exploiting the tree structure to
learn the decisions. In both cases, we observe that indeed exploiting structure helps converge to a
significantly better solution using much fewer reward queries. The height of the tree learnt in Xor
is 2, hence we learn d = 13 parameters using both algorithms. For Slates we learn a tree of height
3, where d = 29. However, in both problems, the sample complexity of Algorithm 4 is proportional
to m = 1 since only one decision is made.

Next, we consider the Parrot synthesis benchmark studied by Bornholt et al. [2016]; Es-
maeilzadeh et al. [2012], where the goal is to learn a piece-wise polynomial approximation for the
complex function in Figure 11a (which is more efficient to execute than the trigonometric functions).
Here, we compute 16 features {x i · y j } for 0 ≤ i, j ≤ 3 based on the input x and y to the function
that needs to be approximated. The feature distribution is uniform over 100 pairs (xi , yi ) sampled
from the range [−1, 1] × [−1, 1]. We then learn a decision tree of height h = 4 using the same ℓsq loss
as in the above instances. We also learn the d tree parameters treating them as constants, where
d = (2h+1 − 1) ∗ 16 = 496. Figure 11b shows expected reward against the number of queries for the
two algorithms. Again, we observe that exploiting structure results in the algorithm converging
to much better rewards quicker. Additionally, we observe 33% and 212% median percent (relative)
approximation error, for Algorithm 4 and Algorithm 2, respectively.

6 RELATED WORK
A/B and Multiworld Testing. A/B testing methodology is commonly used in many disciplines
and domains (medicine, especially) for understanding the effects of treatments in a controlled
setting. It has been increasingly adopted in understanding the effects of parameters in systems and
software [Johari et al. 2017; Kohavi and Longbotham 2017]. Performing randomized experiments
on real systems, gathering data from control and treatment groups, analyzing how the parameters
affect the metrics of interest, and making decisions can be disruptive, laborious, and prohibitively

24

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

float inversek2j(float x,float y) {

float th2 = acos(((x*x) + (y*y) - 0.5) /

0.5);
return asin((y*(0.5 + 0.5*cos(th2)) -

0.5*x*sin(th2)) /

(x*x + y*y));

}

(a)

(b)

Fig. 11. (a) The function to approximate from the Parrot benchmark. (b) The rewards obtained for learning
the function approximations using tree model (Alg. 4) and constants (Alg. 2).

expensive in terms of time (especially when the number of parameters is large and continuous-
valued). Multiworld testing (MWT) significantly improves upon A/B testing methodology by reusing
data and context collected from a deployed system to estimate the outcome of many A/B tests
without running separate tests for each; however, it still does not scale well with respect to number
of parameters. The state-of-the-art MWT framework known as DecisionService [Agarwal et al.
2016], and is primarily intended for making a single categorical decision (such as recommending ads
or news articles to users), using contextual bandit algorithms [Bietti et al. 2018]. As we demonstrated
in Section 5.2, the multi-arm bandit algorithms scale poorly when the multi-dimensional action
space is discretized. There is recent work on extending the techniques to continuous-valued
parameters [Krishnamurthy et al. 2019] and multiple parameters. However, these algorithms are
yet to be incorporated into tools for efficient parameter tuning.

Reinforcement Learning (RL) is a popular and widely-used approach [Sutton and Barto 2011]
for online learning of actions/decisions in order to maximize some long-term reward. SmartChoices
by Google [Carbune et al. 2019] is a recent example of an RL-based framework, which is primarily
intended for tuning parameters in software. Similar to PBR, their interface is developer-friendly
and intuitive. Since they rely on standard RL techniques and complex neural network models,
the sample complexity and reward computations required are generally high and the framework
forgoes interpretability which is a key differentiating aspect in our work. Another recent line of RL
research involves learning interpretable policies (as programs) [Verma et al. 2019, 2018] that exploit
gradient-based techniques for finding a policy that optimizes some expected reward function and
combinatorial search techniques for inferring the program corresponding to the policy.

Configuration Optimization in Software. An important line of related work in empirical
software engineering involves automatic parameter tuning and large-scale configuration opti-
mization [Bao et al. 2019; Guo et al. 2018; Kaltenecker et al. 2019; Sayyad et al. 2013; Siegmund
et al. 2015]. Our work chiefly differs from a majority of approaches in this line of work in that (a)
we focus on synthesizing interpretable code for computing decisions, via learning parameters, in
software, and (b) our algorithms work with arbitrary and complex reward functions in practice.
In contrast, for example, Siegmund et al. [2015] is much more restrictive in applicability — they
assume a certain functional form of cost function/rewards, whereas our PBR framework supports
non-functional developer-defined rewards. Pure ML based techniques such as [Bao et al. 2019] use
rather complex neural network models to determine optimal parameters/decisions given certain
workload to the system; whereas we focus on synthesizing interpretable decisions (i.e. how the

Programming by Rewards

25

decision is made given the workload) by observing and exploiting the structure in heuristics written
by programmers.

Program Synthesis, Sketching. Automatic synthesis of interpretable programs from speci-
fication, such as input-output examples [Gulwani 2011; Gulwani and Jain 2017; Gulwani et al.
2019; Padhi et al. 2017; Polozov and Gulwani 2015], or sketches (partial programs) [Bornholt
et al. 2016; Chaudhuri et al. 2014; Solar-Lezama et al. 2006] is a flourishing line of research. Data
extraction/formatting applications significantly benefit from these techniques [Iyer et al. 2019].
Of particular relevance is the work by Chaudhuri et al. [2014] and by [Bornholt et al. 2016] that
involves optimizing quantitative specification (reward/cost function) besides satisfying boolean
specification. However, unlike PBR, these approaches need white-box access to reward function
and are often limited in the type of reward functions they can handle (as discussed in Section 5.3).
In particular, the synthesis framework of [Bornholt et al. 2016] needs defining careful metasketch
specification (with additional information about the cost function like the gradient) for efficient
synthesis, otherwise it reduces to the standard sketching problem.

Differentiable programming is a related field in that it studies programs that are end-to-end
differentiable, and therefore can be optimized via automatic differentiation techniques. An example
of such a class of differentiable programs are the neural networks and several tools exist to learn
these models (e.g. TensorFlow [Abadi et al. 2015]). However, these models are not interpretable and
require a lot of training data. Developing general purpose differentiable languages, and techniques
to train such models with smaller amounts of training data are open areas of research.

7 CONCLUSION AND FUTURE WORK
We formalized a novel problem – Programming By Rewards (PBR) – where the goal is to synthesize
decision functions from an imperative language that optimize programmer-specified reward metrics.
Our technical contribution is the use of continuous optimization methods to perform this synthesis
with low sample complexity and low update complexity. Section 5.2 showed that the approach is
able to efficiently synthesize decision functions in the PROSE code base (an industrial-strength
program synthesis engine) with only ≈ 250 reward function calls and is competitive with respect to
hand-tuned heuristics developed over many man-years, and outperforms prior approaches designed
specifically to tune these heuristics.

We see several directions for future work. First, our current implementation of PBR accepts
user guidance at a very coarse granularity –the user can say that the function is a constant, linear
function or decision tree. While this has been sufficient for the case studies we have done so far,
we believe that we can further improve the sample complexity if the user can give us a sketch of
the tree they expect to synthesize and initial values of parameters they expect. We plan to pursue
this direction both in terms of theoretical guarantees as well as empirically, with case studies. Next,
while Theorem 3 gives a precise bound for Algorithm 3 in the context of learning linear functions,
a corresponding bound for learning trees is still open. Finally, as stated in Section 4.5, while PBR
works well in practice for the case studies we have tried, even when the reward functions are not
continuous, we would like to understand the nature of reward functions that arise in practice and
characterize formally the assumptions under which PBR is guaranteed to work.

26

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

REFERENCES
Martín Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S. Corrado, Andy Davis,
Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Ian Goodfellow, Andrew Harp, Geoffrey Irving, Michael Isard, Yangqing
Jia, Rafal Jozefowicz, Lukasz Kaiser, Manjunath Kudlur, Josh Levenberg, Dandelion Mané, Rajat Monga, Sherry Moore,
Derek Murray, Chris Olah, Mike Schuster, Jonathon Shlens, Benoit Steiner, Ilya Sutskever, Kunal Talwar, Paul Tucker,
Vincent Vanhoucke, Vijay Vasudevan, Fernanda Viégas, Oriol Vinyals, Pete Warden, Martin Wattenberg, Martin Wicke,
Yuan Yu, and Xiaoqiang Zheng. 2015. TensorFlow: Large-Scale Machine Learning on Heterogeneous Systems. https:
//www.tensorflow.org/

Alekh Agarwal, Sarah Bird, Markus Cozowicz, Luong Hoang, John Langford, Stephen Lee, Jiaji Li, Dan Melamed, Gal Oshri,

Oswaldo Ribas, et al. 2016. A multiworld testing decision service. arXiv preprint arXiv:1606.03966 7 (2016).

Naman Agarwal, Alon Gonen, and Elad Hazan. 2019. Learning in Non-convex Games with an Optimization Oracle. In

Conference on Learning Theory. 18–29.

Liang Bao, Xin Liu, Fangzheng Wang, and Baoyin Fang. 2019. ACTGAN: automatic configuration tuning for software
systems with generative adversarial networks. In 2019 34th IEEE/ACM International Conference on Automated Software
Engineering (ASE). IEEE, 465–476.

Lilian Besson. 2018. SMPyBandits: an Open-Source Research Framework for Single and Multi-Players Multi-Arms Bandits
(MAB) Algorithms in Python. Online at: github.com/SMPyBandits/SMPyBandits. https://github.com/SMPyBandits/
SMPyBandits/ Code at https://github.com/SMPyBandits/SMPyBandits/, documentation at https://smpybandits.github.io/.
Alberto Bietti, Alekh Agarwal, and John Langford. 2018. A contextual bandit bake-off. arXiv preprint arXiv:1802.04064

(2018).

Ras Bodik and Armando Solar-Lezama. 2006. SKETCH synthesis tool (commitid: 26040ed). (2006). https://bitbucket.org/

gatoatigrado/sketch-frontend/wiki/Home

James Bornholt, Emina Torlak, Dan Grossman, and Luis Ceze. 2016. Optimizing synthesis with metasketches. In Proceedings

of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. 775–788.

Victor Carbune, Thierry Coppey, Alexander Daryin, Thomas Deselaers, Nikhil Sarda, and Jay Yagnik. 2019. SmartChoices:

Hybridizing Programming and Machine Learning. ICML Workshop RL4RealLife (2019).

Miguel A Carreira-Perpinán and Pooya Tavallali. 2018. Alternating optimization of decision trees, with application to

learning sparse oblique trees. In Advances in Neural Information Processing Systems. 1211–1221.

Swarat Chaudhuri, Martin Clochard, and Armando Solar-Lezama. 2014. Bridging boolean and quantitative synthesis using
smoothed proof search. In Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages. 207–220.

Swarat Chaudhuri, Sumit Gulwani, and Roberto Lublinerman. 2012. Continuity and robustness of programs. Commun.

ACM 55, 8 (2012), 107–115.

H. Esmaeilzadeh, A. Sampson, L. Ceze, and D. Burger. 2012. Neural Acceleration for General-Purpose Approximate Programs.

In 2012 45th Annual IEEE/ACM International Symposium on Microarchitecture. 449–460.

Abraham D Flaxman, Adam Tauman Kalai, and H Brendan McMahan. 2005. Online convex optimization in the bandit
setting: gradient descent without a gradient. In Proceedings of the sixteenth annual ACM-SIAM Symposium on Discrete
Algorithms. 385–394.

Saeed Ghadimi and Guanghui Lan. 2013. Stochastic first-and zeroth-order methods for nonconvex stochastic programming.

SIAM Journal on Optimization 23, 4 (2013), 2341–2368.

Sumit Gulwani. 2011. Automating string processing in spreadsheets using input-output examples. In ACM SIGPLAN Notices,

Vol. 46. ACM, 317–330.

Sumit Gulwani and Prateek Jain. 2017. Programming by Examples: PL meets ML. In Asian Symposium on Programming

Languages and Systems. Springer, 3–20.

Sumit Gulwani, Kunal Pathak, Arjun Radhakrishna, Ashish Tiwari, and Abhishek Udupa. 2019. Quantitative Programming

by Examples. arXiv preprint arXiv:1909.05964 (2019).

Jianmei Guo, Dingyu Yang, Norbert Siegmund, Sven Apel, Atrisha Sarkar, Pavel Valov, Krzysztof Czarnecki, Andrzej
Wasowski, and Huiqun Yu. 2018. Data-efficient performance learning for configurable systems. Empirical Software
Engineering 23, 3 (2018), 1826–1867.

Arun Iyer, Manohar Jonnalagedda, Suresh Parthasarathy, Arjun Radhakrishna, and Sriram K Rajamani. 2019. Synthesis and
machine learning for heterogeneous extraction. In Proceedings of the 40th ACM SIGPLAN Conference on Programming
Language Design and Implementation. 301–315.

Ramesh Johari, Pete Koomen, Leonid Pekelis, and David Walsh. 2017. Peeking at a/b tests: Why it matters, and what to
do about it. In Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining.
1517–1525.

Christian Kaltenecker, Alexander Grebhahn, Norbert Siegmund, Jianmei Guo, and Sven Apel. 2019. Distance-based sampling
of software configuration spaces. In 2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE). IEEE,

Programming by Rewards

1084–1094.

27

Ron Kohavi and Roger Longbotham. 2017. Online Controlled Experiments and A/B Testing. Encyclopedia of machine

learning and data mining 7, 8 (2017), 922–929.

Akshay Krishnamurthy, John Langford, Aleksandrs Slivkins, and Chicheng Zhang. 2019. Contextual bandits with continuous

actions: Smoothing, zooming, and adapting. In Conference on Learning Theory. 2025–2027.

Xuan-Bach D Le, Duc-Hiep Chu, David Lo, Claire Le Goues, and Willem Visser. 2017. S3: syntax-and semantic-guided
repair synthesis via programming by examples. In Proceedings of the 2017 11th Joint Meeting on Foundations of Software
Engineering. ACM, 593–604.

Jia Hui Liang, Vijay Ganesh, Krzysztof Czarnecki, and Pascal Poupart. 2016. MapleGlucose and MapleCMS. SAT COMPETI-

TION 2016 (2016), 50.

Nagarajan Natarajan, Danny Simmons, Naren Datha, Prateek Jain, and Sumit Gulwani. 2019. Learning Natural Programs
from a Few Examples in Real-Time. In Proceedings of Machine Learning Research (Proceedings of Machine Learning
Research), Kamalika Chaudhuri and Masashi Sugiyama (Eds.), Vol. 89. PMLR, 1714–1722. http://proceedings.mlr.press/
v89/natarajan19a.html

Mohammad Norouzi, Maxwell Collins, Matthew A Johnson, David J Fleet, and Pushmeet Kohli. 2015. Efficient non-greedy

optimization of decision trees. In Advances in Neural Information Processing Systems. 1729–1737.

Saswat Padhi, Prateek Jain, Daniel Perelman, Oleksandr Polozov, Sumit Gulwani, and Todd Millstein. 2017. FlashProfile:

Interactive Synthesis of Syntactic Profiles. arXiv preprint arXiv:1709.05725 (2017).

PCWorld. 2012. Microsoft Office 2013 Preview: Hands On. https://www.pcworld.com/article/259260/microsoft_office_

2013_customer_preview_first_impressions.html

Oleksandr Polozov and Sumit Gulwani. 2015. Flashmeta: A framework for inductive program synthesis. ACM SIGPLAN

Notices 50, 10 (2015), 107–126.

PROSE. 2015. Program synthesis from input-output examples (PROSE). Microsoft SDK (2015). https://microsoft.github.io/

prose

J. Rapin and O. Teytaud. 2018. Nevergrad - A gradient-free optimization platform. https://GitHub.com/FacebookResearch/

Nevergrad.

Mohammad Raza and Sumit Gulwani. 2018. Disjunctive Program Synthesis: a Robust Approach to Programming by Example.

Appearing in AAAI (2018).

Reudismam Rolim, Gustavo Soares, Loris D’Antoni, Oleksandr Polozov, Sumit Gulwani, Rohit Gheyi, Ryo Suzuki, and Björn
Hartmann. 2017. Learning syntactic program transformations from examples. In Proceedings of the 39th International
Conference on Software Engineering. IEEE Press, 404–415.

Abdel Salam Sayyad, Joseph Ingram, Tim Menzies, and Hany Ammar. 2013. Scalable product line configuration: A straw to
break the camel’s back. In 2013 28th IEEE/ACM International Conference on Automated Software Engineering (ASE). IEEE,
465–474.

Ishwar Krishnan Sethi. 1990. Entropy nets: from decision trees to neural networks. Proc. IEEE 78, 10 (1990), 1605–1613.
Ohad Shamir. 2017. An optimal algorithm for bandit and zero-order convex optimization with two-point feedback. The

Journal of Machine Learning Research 18, 1 (2017), 1703–1713.

Norbert Siegmund, Alexander Grebhahn, Sven Apel, and Christian Kästner. 2015. Performance-influence models for highly
configurable systems. In Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering. 284–294.
Armando Solar-Lezama, Liviu Tancau, Rastislav Bodik, Sanjit Seshia, and Vijay Saraswat. 2006. Combinatorial sketching for
finite programs. In Proceedings of the 12th international conference on Architectural support for programming languages
and operating systems. 404–415.

Richard S Sutton and Andrew G Barto. 2011. Reinforcement learning: An introduction. (2011).
J. Rapin O. Teytaud T. Cazenave, M. Oquab. 2019. Parallel Noisy Optimization in Front of Simulators: Optimism, Pessimism,
Repetitions Population Control. In proceedings of CEC 2019 workshops. https://www.lamsade.dauphine.fr/~cazenave/
papers/games_cec.pdf

Abhinav Verma, Hoang Le, Yisong Yue, and Swarat Chaudhuri. 2019. Imitation-projected programmatic reinforcement

learning. In Advances in Neural Information Processing Systems. 15752–15763.

Abhinav Verma, Vijayaraghavan Murali, Rishabh Singh, Pushmeet Kohli, and Swarat Chaudhuri. 2018. Programmatically

Interpretable Reinforcement Learning. In International Conference on Machine Learning. 5045–5054.

Martin Zinkevich. 2003. Online convex programming and generalized infinitesimal gradient ascent. In Proceedings of the

20th international conference on machine learning (icml-03). 928–936.

28

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

A APPENDIX TO SECTION 4: LEARNING DECISION TREES
In this section, we will give the neural network architecture and observe that, under some structural
constraints, it implicitly represents decision trees. This equivalence forms the basis of implementing
Algorithm 4 efficiently in practice, which will be discussed subsequently.

Given a decision tree f (.; W, Θ) of height h, we want to be able to capture the sequence of binary
tests performed at the nodes of the tree along a root-to-leaf path. It is challenging and non-trivial
to formulate the navigation function that encodes sequential decision making. A simple and key
observation is that we can encode the tree paths via a three-layer neural network, which is referred
to as EntropyNet (the term was coined in [Sethi 1990]), in a way that the network computes the
same function as the decision tree f .

Figure 12 gives an illustration of EntropyNet. Informally, the first layer of the neural network
encodes all the decisions (binary tests) made in the tree; thus it has a total of 2h − 1 neurons (=
number of internal nodes of a complete binary tree of height h). The second layer encodes the And
of the decisions capturing the root-to-leaf paths; it has two neurons per leaf, where one neuron
is to encode the path and the other neuron is to encode the linear model θ in the leaf node. The
final layer encodes the output of the tree. The activation functions of the neurons are chosen
suitably so that there is a one-to-one mapping between root-to-leaf paths and the set of neurons
that fire in the network for any given input example (see highlighted path and neurons in Figure 12).
We give this construction precisely in Definition 8. In the following, we give the construction
of EntropyNet precisely. Assume without loss of generality that the tree is a complete binary tree
(otherwise, we can extend the tree with ⟨0, x⟩ ≥ 0 nodes, and appropriately shift the leaves down
to make it a complete binary tree).

Definition 8 (EntropyNet). Let 1ℓ denote the path indicator function for a decision tree of height
h defined as 1ℓ(i, j) = 1 if (i, j)th node lies in the path leading from the root to the ℓth leaf node, for
ℓ = {0, 1, . . . , 2h − 1}. For each non-root (i, j)th node in the tree, define дi j = +1 if the node is the left
child of its parent node, дi j = −1 otherwise. The EntropyNet architecture takes as input x ∈ Rp and
comprises:
(1) The “predicate layer” with 2h − 1 neurons corresponding to the internal nodes of the tree. Let
(cid:101)w(1)
i j ∈ Rp denote the weights of the (i, j)th neuron in this layer corresponding to the (i, j)th internal
node. Set the activation function as:

z(1)
i j

= sign((cid:101)w(1)

i j

· x + bi j ) .

Let z(1) ∈ {+1, −1}2h −1 denote the vector-valued output from this layer.
(2) The “leaf layer” has two parallel sets of neurons, each with 2h neurons corresponding to the leaves
of the tree:

(a) for the first set, let

∈ R2h −1 denote the weights of the kth neuron in this set (corresponding

(cid:101)w(2,1)

k

to the kth leaf node). For i = {0, 1, . . . , h − 1}, j ∈ {0, 1, . . . , 2i − 1}, set:
дi+1, j′ . 1k (i + 1, j ′),

(2i + j − 1) = (cid:213)

(cid:101)w(2,1)

k

j′ ∈ {0,1, ...,2i +1−1}

and set the activation function of the neuron to:

z(2,1)
k
for some ϵ > 0. Let z(2,1) ∈ R2h
+ denote the vector-valued output from this layer.
∈ Rp denote the weights of the kth neuron in this set (corresponding
to the kth leaf node), where each neuron is connected to the p input variables. Set the activation

= max((cid:101)wk · z(1) − h + ϵ, 0),

(cid:101)w(2,2)

(6)

(b) for the second set, let

k

Programming by Rewards

29

Fig. 12. On the left is a decision tree of height 2. On the right is the equivalent EntropyNet with activation
functions and weights as per the description in Definition 8. The path highlighted on the tree traversed by a
given input example x has a one-to-one correspondence to a set of neurons that fire in the EntropyNet.

function as:

z(2,2)
k
Let z(2,2) ∈ R2h −1 denote the vector-valued output from this layer.

(cid:101)w(2,2)

· x + b ′

k .

=

k

(3) The output layer has one neuron whose output is set to the following non-linear activation:

z(3) =

1

ϵ

(z(2,1) · z(2,2)) ∈ R.

Next, we formally show that the EntropyNet architecture encodes the decision tree computation

exactly.

Lemma 3 (Every Decision Tree is an EntropyNet). For any given decision tree fT (.; W, Θ) (in
Definition 4), there is an EntropyNet architecture described in Definition 8 with a particular choice
of model parameters, say (cid:101)W, that computes the same function as the tree. Let fNet(.; (cid:101)W) denote the
function computed by the EntropyNet. We have,

fT (x; W, Θ) = fNet(x; (cid:101)W), ∀x ∈ Rp .
Not only is every decision tree encoded by some EntropyNet, but the vice versa also holds.
Thus, the class of entropy nets and the class of decision trees (and therefore Imp, from Lemmas 1
and 2) are identical.

Lemma 4 (Every EntropyNet is a Decision Tree). For every neural network with 3 layers, with
constraints on the weights and activations as described in Definition 8, there is a corresponding decision
tree which represents the same function.

A.1 Updating fNet model
Computing the gradient in the update Step 5 of Algorithm 4, with fNet in lieu of f given the
equivalence above, and ensuring that the updates maintain a valid decision tree, is still challenging
for the following reasons.

30

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

(1) The activation function in the first (predicate) layer given in Definition 8 (1) is the sign
function, which is discontinuous and non-differentiable. We need a relaxation of the activation
function to allow learning.

(2) The structural constraints on the weights of the leaf neurons given in Definition 8 (2) impose
that the weights be integral, and in particular, {1, −1}-valued (see Figure 12). This is an
inviolable constraint, to ensure that the root-to-leaf paths are preserved in the learned neural
network model.

(3) Finally, we need only one of the leaf neurons to fire in the leaf layer – this is ensured in
Definition 8 (3), by the activation that thresholds the output at h. This essentially implements
the AND of the predicates, which theoretically holds only when we use sign function in the
predicate layer. Thus this requirement is at odds with any relaxation that we might want to
use to mitigate the first challenge.
We address these challenges as follows:

(I) First, we relax the sign function using a scaled sigmoid function as the activation function for
the predicate layer. In particular, for appropriately chosen s > 0, we define:

σs (a) :=

1
1 + exp(−s . a)

, and

z(1)
i j

= 2σs (⟨(cid:101)w(1)

i j , x⟩ + bi j ) − 1.

(7)

Note that for sufficiently large s, the above activation behaves like the sign function. In practice,
selecting s can be tricky. If we choose s very large, then it will be hard for the optimization to
proceed and it will likely get stuck in a poor solution. On the other hand, using a small s will lead
to violation of constraints as discussed in challenge (3) above.

Even though the optimization tends to converge to a good (cid:101)W with a small s (when the model is
effectively a neural network), the resulting decision tree model W, Θ after conversion can be quite
poor. On the other hand, we also observe that it is important for s to be not too large (when the
model is effectively a decision tree), otherwise the optimization cannot proceed. This motivates us to
devise a careful scheduling of choices of s from smaller values to larger values, letting the activation
function approach the sign function, moving gradually from the space of neural networks to
decision trees in the process.

(II) Second, we satisfy the integral constraints on the weights of the leaf neurons by simply
anchoring the weights during training. Note that the number of non-zero weights in the second
layer of EntropyNet is only h .2h, as against standard dense neural network which has O(22h)
connections.

(III) The above two ideas by themselves still do not guarantee convergence of the optimization
to a good decision tree solution. In fact, the third challenge remains unaddressed. In particular,
when we start with a small s in the sigmoid activation in the beginning of the training, there is
no guarantee that any ReLU activated neuron in the third layer, given in Eqn. (6), will fire at all, if
we set ϵ to be very small. On the other hand, if we set ϵ to be large, many neurons will fire, thus
violating the basic property of a decision tree (each example traverses a unique root-to-leaf path).
Therefore, we follow the opposite schedule for ϵ; we start with a large ϵ ensuring that gradient
information propagates through these neurons, and gradually decrease ϵ.

B PROOFS

B.1 Proof of Lemma 1
: Rp → Rm shown below in Figure 13,
Consider the parse tree of a given decision function f
denoted by P, where each internal node in the tree corresponds to a non-terminal of type E

Programming by Rewards

31

(expression) or S (statement), and leaf nodes correspond to real numbers (i.e. choices for W in the
expansion of E). We start by constructing an equivalent parse tree P ′ for f , by transforming P in
way that ensures that the computational semantics of the program is preserved.

Fig. 13. Parse tree for a decision function in Imp with p = 1 (the blue terminal nodes correspond to choices
for W1 and W2). The non-terminal C is a short-hand for the conditional E > 0.

The key transformation, called Expand, is as follows. For any internal node S such that both of
its children are of type S (call them S1 and S2) (Figure 13 has one instance of this), let PS2 denote
the sub-tree of P rooted at S2. Now, consider every root-to-leaf path in PS1 starting from S1 to the
last internal node of type S. say S ′, along the path. We attach PS2 as the second child of S ′ (note
that S ′ has only child, because it is the last internal node). We now apply Expand to every such
internal node S such that both of its children are of type S. The resulting transformed parse tree P ′
after applying Expand to the example in Figure 13 is shown in Figure 14.

Observe that P ′ and P are equivalent, i.e. a) every assignment statement of type oj = E for some
1 ≤ j ≤ m executed in P, along any execution path of f , is also executed in P ′, b) the order of the
assignments is also identical (attaching as the right child in the above transform ensures this).

With this, we will now give a straight-forward construction of decision tree fT : Rp → Rm
(Definition 4) that computes the given decision function f . The root of the decision tree of fT
corresponds to the first non-terminal S in the parse-tree P ′ (note that any program in Imp has at
least one non-terminal S in its parse tree). For this single-node tree fT (as yet), initialize parameters
Θ = {θj } = ∅. Now consider the sub-tree rooted at this S in P ′ referred to as P ′
. Note that there is
S
no node in P ′ both of whose children of type S. That leaves us with the following cases:

(1) if the children node of S in P ′
S

correspond to if (C) then S1 else S2 then set the parameters
w ∈ Rp+1 of the current root node of fT to the corresponding terminals in the conditional
expression C. Then:
a) create a left child to the current root in fT , copy {θj } of the current root node, make this
the current root, and repeat step (1) with S = S1.
b) create a right child to the current root in fT , copy {θj } of the current root node, make this
the current root, and repeat step (1) with S = S2.

(2) if the first (or only) child node of S corresponds to assignment oj = E, then set θj ∈ Rp+1 of

the current root node to the corresponding terminals in the expression E.

(3) if the other child node of S exists and is of type S (call it S ′), then go to step (1) with S = S ′.
The height of the resulting tree fT , say h, is proportional to the number of S nodes in P ′ that
expand to a conditional statement (note that the height of the tree grows only in step (1) above).
The size of fT is exponential in h.

32

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

Fig. 14. Applying Expand transform to the parse tree in Figure 13.

B.2 Proof of Lemma 2
This direction is straight-forward. We can synthesize the desired f ∈ Imp by doing a pre-order
traversal of fT . When we visit a leaf node, all the assignment statements of the form oj = E for
1 ≤ j ≤ m will be synthesized corresponding to {θj } parameters of the node.

B.3 Proof of Theorem 1
We refer the reader to the proof of Theorem 3.3 of Flaxman et al. [2005]. Note that n in their notation
is the same as T in ours.

B.4 Proof of Theorem 2
We appeal to the result in Corollary 2 of Shamir [2017], that uses the two-point gradient estimator
given in (2), and matches the setting in our algorithm.

B.5 Proof of Theorem 3
We start by recalling a key lemma of [Flaxman et al. 2005] that uses the online gradient descent
analysis by [Zinkevich 2003] with unbiased random gradient estimates. We restate the result below
for clarity, for the case when the reward is concave (the original result is stated for loss being
convex). Let Bd (R) denote ball of radius R in Rd , and ΠS (w) = arg minw′ ∈S ∥w − w′∥.
Lemma 5 (Lemma 3.1, [Flaxman et al. 2005]). Let S ⊂ Bd (R) ⊂ Rd be a convex set, c1, c2, . . . , cT :
S (cid:55)→ R be a sequence of concave, differentiable functions. Let w(1), w(2), . . . , w(T ) ∈ S be a sequence
of predictions defined as w(1) = 0 and w(t +1) = ΠS (w(t ) − ηh(t )), where η > 0, and h(1), h(2), . . . , h(T )
are random variables such that E[h(t )(cid:12)
(cid:12)w(t )] = ct (w(t )), and ∥h(t )∥2 ≤ G, for some G > 0 then, for
η = R
√
G

, the expected regret incurred by above prediction sequence is:

T

max
w∈S

T
(cid:213)

t =1

ct (w) − E

(cid:20) T

(cid:213)

t =1

ct (w(t ))

(cid:21)

√

T .

≤ RG

We need the following assumptions:

(1) reward function r is bounded, i.e. r : Rm (cid:55)→ [−C, C], for some numerical constant C.
(2) r is concave in w ∈ Rm×p (note that r (a) = r (wx), where w ∈ Rm×p and x ∈ Rp ).
(3) maxt ∥x(t )∥2 ≤ D.

In the following, we will use the short-cut a = f (x; w) = wx and a(t ) = f (x(t ); w(t )) = w(t )x(t ).

Programming by Rewards

33

Also, in Algorithm 3, we work with parameters w ∈ W = Bd (mW ), for some, possibly large

number, W .

Let U denote the uniform distribution and Sm(1) denote the sphere in Rm of radius 1. Now, define
(cid:2)r (a +δ u)(cid:3), for any a ∈ Rm. Then applying the above
ˆr : Rm (cid:55)→ [−C, C] such that ˆr (a) = Eu∼U(Sm (1))
(cid:0)r (a(t ))u(cid:1)(x(t ))T,
Lemma 5 in the setting of Algorithm 3, on the concave function ˆr , with h(t ) = m
δ
and u ∼ U(Sm(1)) (note that this implies E[h(t )(cid:12)
(cid:2)r (a(t ) + δ u)(cid:3), which can be seen
from Lemma 2.1 of [Flaxman et al. 2005]), we get:

(cid:12)w(t )] = ∇wEu

max
w∈W

T
(cid:213)

t =1

ˆr (a) − E

(cid:20) T

(cid:213)

(cid:21)

≤

ˆr (a(t ))

t =1

√
T

,

m2W DC
δ

(8)

as ˆr (·) is concave (in argument w ∈ Rm×p ) due to the assumption (ii) above, and in this case
and hence we need to choose

(cid:0)r (a(t ))u(cid:1)(x(t ))T∥ ≤ mDC
δ

, so G = mDC

δ

R ≤ W , and ∥h(t )∥ = ∥ m
δ
η = W δ
√
DC

T

.

Further since r (·) is assumed to be L-Lipschitz continuous (Definition 7), it follows from (8) that,

maxw∈W (cid:205)T

t =1

(cid:0)r (a) − δL(cid:1) − E

(cid:20)

(cid:205)T

t =1

(cid:0)r (a(t )) + δL(cid:1)

(cid:21)

≤ m2W DC

δ

√

T

,

=⇒

maxw∈W (cid:205)T

t =1 r (a) − E

(cid:20)

(cid:205)T

t =1 r (a(t ))

(cid:21)

≤ m2W DC

δ

√

T

+ 2δLT

We want to minimize the RHS above with respect to δ , which can be achieved by setting δ =

(cid:17) 1/2

m

(cid:16) W DC
√
2L
T

. This finally gives:

RT = max
w∈W

1

T

T
(cid:213)

t =1

r (a) −

1

T

(cid:20) T

(cid:213)

E

(cid:21)

≤

2m

r (a(t ))

t =1

√

2W LDC
T 1/4

,

which concludes the proof.

B.6 Proof of Lemma 3
In the EntropyNet architecture described in Definition 8, consider the path function 1ℓ and дi j
corresponding to the given decision tree. For i ∈ {0, 1, . . . , h − 1}, j ∈ {0, 1, . . . , 2i − 1}, set the
predicate layer weights (Definition 8 (1)) as follows.

(cid:101)w(1)

i j

= wi j ,

where wi j are the weights of the internal nodes of the given tree. In the activation function, choose
bi j to be the corresponding biases of the nodes ∀i, j. Set the weights of the second set of neurons in
the leaf layer (2) to the linear models in the tree:
(cid:101)w(2,2)

= θj ,

j

where θk ∈ Rp are the linear model coefficients in the kth leaf node; in the activation function,
to be the bias in the corresponding linear model. By construction, the resulting fNet
choose b ′
k
computes the given tree function fT , i.e. the weights chosen for the EntropyNet in the middle
layer (Definition 8 (2 (a))) and the activation function ensure that for a path from root to some leaf
node j, the one and only neuron that is activated (i.e. outputs ϵ) in the leaf layer is the jth neuron
(all other neurons output 0). The proof is complete.

34

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

double FormatDateTimeRange(double base_SeparatorIsCommonDateTimeSeparator, ...) {

return -0.25 *base_SeparatorIsCommonDateTimeSeparator +
0.07 *base_SeparatorIsOnlySymbolsAndPunctuation +
-0.52 *base_SeparatorIsOnlyWhitespace +
-0.12 *base_SeparatorIsWrappedByWhitespace +
0.06 *bias_FormatDateTimeRange +
1 *score_FormatDateTimeRange_dtRoundingSpec +
1 *score_FormatDateTimeRange_dtRoundingSpec2 +
1 *score_FormatDateTimeRange_inputDateTime +
1 *score_FormatDateTimeRange_outputDtFormat +
1 *score_FormatDateTimeRange_s;

}

Fig. 15. The FormatDateTimeRange heuristic in PROSE [Natarajan et al. 2019; PROSE 2015] with parameters
of interest highlighted.
B.7 Proof of Lemma 4
This holds by arguments similar to the proof of Lemma 3. The tree parameters corresponding to a
given fNet (and h and ϵ in Definition 8) are precisely given in the following Algorithm 5. Note here
w(p) denotes pth entry in the vector w.

Algorithm 5 Inferring decision tree from EntropyNet

function InferTree( (cid:101)W, h, ϵ)

for i ∈ {0, 1, . . . , h − 1} do // predicates at internal nodes W

for j ∈ {0, 1, . . . , 2i − 1} do

i j (0), (cid:101)w(1)
wi j = [(cid:101)w(1)
(cid:101)w(1)
bi j =
i j (p)

i j (1), . . . , (cid:101)w(1)

i j (p − 1)]

for j ∈ {0, 1, . . . , 2h − 1} do // linear models at the leaves Θ
(k), for k ∈ {0, 1, . . . , p}

(bias of the activation function, Definition 8 (2 b))

(cid:101)w(2,2)

j

θj (k) =
θj (p) = b ′
j

return W = {wi j , bi j }, Θ = {θj }

1:

2:

3:

4:

5:

6:

7:

8:

C APPENDIX TO SECTION 5

C.1 PROSE details and additional results (for Section 5.2)
Here, we include additional results for the PROSE case study presented in the main text, Section 5.2,
in Figures 16, 17 and 18. Figure 15 shows the FormatDateTimeRange heuristic that is part of
PROSE [Natarajan et al. 2019; PROSE 2015], with parameters of interest highlighted.

C.2 Sketch details (for Section 5.3)
Example code for Sketch specification given as input to the tool [Bodik and Solar-Lezama 2006] is
shown in Figure 19. We vary n, d, features, w_opt values in this code to produce the results
presented in Section 5.3.

Relaxing Sketch specification. We know that there is a solution to problem (4) that achieves
the objective value of 0. But, in some cases, it is still useful to fill the holes with values that yield a

Programming by Rewards

35

Fig. 16. For the same setting as Figure 7, rewards obtained by PBR and UCB for tuning RegexPair with 3
parameters (Figure 6); for the UCB algorithm, 3 parameters are discretized into 5 ∗ 5 ∗ 5 = 125 actions.

Fig. 17. Distribution of rewards received by PBR and UCB when tuning RegexPair parameters (Figure 6),
corresponding to the result in Figure 7 (a).

small enough objective value “close to” the optimal — i.e. fill the holes w so that L(w) ≤ L(w∗)+ϵ = ϵ,
where L(w) := E[r (cid:0)w · x(cid:1)]. Thus we could relax the sketch specification, i.e. last line 5 of Figure 19,
to assert (w[0] <= 10) & (w[1] <= 10) & (losses <= epsilon). As we increase ϵ away
from 0, the search problem becomes easier, and therefore one expects to find some feasible solution,
though it need not be optimal. Unfortunately, this intuition doesn’t hold for sketching — in some
cases, it makes the computation even longer, because it takes more bits to encode the slackness

36

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

Fig. 18. Distribution of rewards received by PBR and UCB when tuning FormatDateTimeRange (Figure 15)
parameters, corresponding to the result shown in Figure 7 (b).

constraint and ends up increasing the problem complexity. On the other hand, the algorithms used
by PBR can yield a solution, close to the optimal, that improves with the time budget.

C.3 Fermat sketch (for Section 5.3)
In Section 5.3 (Figure 9) we have given the Thermostat sketch; Figure 20 shows the Aircraft sketch,
the other function sketch discussed in Section 5.3. Both of the sketches originate from Chaudhuri
et al. [2014], where they are also explained in more detail.

C.4 Decision tree problems Xor and Slates (for Section 5.4)
The Xor problem instance discussed in the main paper is presented in Figure 21. Slates is a more
complex hypothetical tuning problem, where we wish to learn a piece-wise constant threshold
function based on the values of 2 features, to decide what the threshold for the input should be
(these type of heuristics are common in systems); here, we have 6 different possible thresholds that
depend on the 2 features as shown in Figure 22. The decision functions learnt by our Algorithm 4
for the Xor and the Slates problem instances are given in Figures 23 and 24.

D APPENDIX: PBR SPECIFICATION API
Here we give the details of the API we have built for developers to use PBR and our algorithms.
1. Creation. The Create API creates an instance of the synthesis/parameter learning problem for
PBR. This API allows several optional arguments that essentially helps the programmer encode
domain knowledge for the problem:
(a) the name of the decision function to learn,
(b) optional features, which the programmer uses to model the decision as a function of the context,
(c) the model type (“template”) for computing decisions, as a function of feature values and parameter
values (we currently support constant or linear model or decision tree as discussed in the main
paper),
(d) optional initial values for the parameters, set to 0 by default

Programming by Rewards

37

int sqloss (int score1, int score2) {

return (score1 - score2) * (score1 - score2);

}

int absloss (int score1, int score2) {

return score1 > score2 ? score1 - score2:

score2 - score1;

}

harness void paramSketch () {

int n = 2;
int d = 2;
int[n][d] features = {{-2,3}, {-3,-1}};
int[d] w_opt = {1,2};
int[d] w;
int losses = 0;
int[n] y;
for (int i=0; i < n; i++) {

y[i] = 0;
for (int j=0; j < d; j++) {

y[i] += w_opt[j] * features[i][j];

}

}
w[0] = ??;
w[1] = ??;
for (int i=0; i < n; i++) {

int score = 0;
for (int j=0; j < d; j++) {

score += w[j] * features[i][j];

}
losses += absloss(score, y[i]);

}
minimize (losses);
assert (w[0] <= 10) & (w[1] <= 10) & (losses == 0);

}

Fig. 19. Example implementation of a sketch problem given to the Sketch tool [Bodik and Solar-Lezama
2006] discussed in Section 5.3. Here, number of examples n = 2 and number of holes to fill is d = 2. The values
for features are random integers sampled from the range [-10,10], and those for w_opt are random integers
sampled from the range [0,10].

(e) optional constraints on the parameters to be tuned; the API supports range constraints (min and
max), and type constraints (e.g., isInt is True if the parameters takes only integral values).

Constraints(double min, double max, bool isInt)
int Create(string param,
double initValue = 0,
Dictionary<string, Constraints> constraints = null,
string[] features = null,

38

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

double Aircraft(double v1, double v2) {

. . .
double criticalDist = ??(6, 9);
double safetyDist = 3.0;
double delay = ??(10, 15);
double delay2 = ??(9, 14);
assert(delay > 0.0; θ );
assert(delay2 > 0.0; θ );
assert(criticalDist > safetyDisty; θ );
assert(criticalDist < 10; θ );
for (int i=0; i<50; i=i+1) {
if (stage == CRUISE) {

move_straight(x1, y1, x2, y2, v1, v2);
if (δ (x1, y1, x2, y2) < criticalDist) {

stage = LEFT;
assert(!haveLooped; θ );
steps = 0;

}

}
if (stage == LEFT) {

move_left(x1, y1, x2, y2, v1, v2);
steps = steps + 1;
if (delay - steps < 0) {
stage = STRAIGHT;
steps = 0;

}

}
if (stage == STRAIGHT) {

move_straight(x1, y1, x2, y2, v1, v2);
steps = steps + 1;
if (delay - steps < 0) {

stage = RIGHT;
steps = 0;

}

}
if (stage == RIGHT) {

move_right(x1, y1, x2, y2, v1, v2);
steps = steps + 1;
if (delay - steps < 0) {
stage = CRUISE;
haveLooped = true;

}

}
assert(δ (x1, y1, x2, y2) < safetyDist; θ );

}
return 2 * delay + delay2;

}

Fig. 20. Aircraft sketch [Chaudhuri et al. 2014].

enum template)

Programming by Rewards

39

Fig. 21. (Xor problem) Expected values as a function of the two features x and y is given by the XOR function,
that can be modeled by a tree of height 2. Best viewed in color.

Fig. 22. (Slates problem) Expected values (thresholds) as a function of the two features x and y is given by a
piece-wise constant function, that can be modeled by a tree of height 3. Best viewed in color.

double XOR(double x1, double x2)
{

if (x2 <= -0.02)

if (x1 >= 0.04)
return 0;

else return 1;

else

if (x1 <= (-0.01 * x2 - 0.03))

return 0.03;

else return 0.98;

}

Fig. 23. The tree heuristic learnt by PBR for the Xor problem in Figure 21.

40

Nagarajan Natarajan, Ajaykrishna Karthikeyan, Prateek Jain, Ivan Radiček, Sriram Rajamani, Sumit Gulwani,
and Johannes Gehrke

double ThresholdMap(double x, double y) {

if (x >= -0.01*y)
if (x >= 0.25)

if (x >= 0.41) return 0.5;
else return 0.1;

else

return 0.81;

else

if (y >= -0.01*x - 0.41)

if (y >= 0.01*x + 0.43) return 0.3;
else return 0;

else

if (0.94*x >= 0.34*y + 2.58) return 0.47;
else return 1;

}

Fig. 24. The tree heuristic learnt by PBR for deciding the threshold parameter described in Figure 22.

2. Connection. The Create API sets up a data store instance in the back-end for tuning the
specified parameters, initializes the necessary background services to maintain/update this store.
A unique identifier to this store instance is returned by the call to Create. The next step is to
connect the client to this instance. The Connect API connects a parameter learning instance to a
PBR object.

void Connect (int problemId)

Note that if a store already exists (for the parameter(s) of interest), then the client can directly
connect to the instance by referencing the unique identifier to the instance, because store instances
are persistent. This also enables multiple clients (distributed spatially and/or temporally) to query
the latest decisions for as well as give feedback to the same learning problem. The creation of a
store instance can also be performed through a separate GUI or a plugin.

3. Prediction. This interface encapsulates PBR.DecisionFunction introduced in Example 1. With
the Predict interface, the programmer can query the decision outcome using the learnt model. It
takes the feature values as input from the context and returns the decision outcome:

(int, double) Predict (Dictionary<string, double> features)
Internally, it works by (1) retrieving the current version of the learnt model and parameters as
an expression tree, (2) converting the expression tree into a lambda expression, and (3) running the
lambda expression using the given feature values as arguments. The lambda expression is cached
in the client as as to perform further predictions without needing to contact the server. If the model
is refreshed, then the cache is cleared in the client, and the subsequent call to Predict retrieves the
updated expression from the model and recomputes the corresponding lambda expression. Note
that Predict returns a pair of values – a unique identifier which identifies the particular invocation
of Predict, and the predicted decision value.

If the client wishes to retrieve the expression tree to inspect the learnt model, it can use the

GetExprTree API:

Expression<TDelegate> GetExprTree (Dictionary<string, double> features)

4. Reward. This is the PBR.AssignReward interface introduced in Example 1, which allows the
client to specify a reward and also associate it with a particular invocation of Predict (the default
is the last invocation, as in Figure 3).

Programming by Rewards

41

void AssignReward(int invocationId, double reward)

We note that a decision is associated with many parameters (from a linear model or decision tree)
and the reward specified is associated with all of these parameter choices (see Figure 5). This
aspect of PBR distinguishes it from other solutions like Decision Service [Agarwal et al. 2016] and
SmartChoices [Carbune et al. 2019]; they rely on providing explicit reward for each parameter
and decision value, whereas we do not require that disambiguation — our problem formulation
and learning enables working with a single reward (i.e. value of the key system level metric) for a
decision (and can be generalized to set of decisions as well), and in turn tuning several parameters
together.
5. Refresh. The Refresh API learns an updated model based on the data collected in the store
instance, using the algorithms presented in Section 4: void Refresh()

The client can choose to perform either online learning or offline learning by how frequently it
calls Refresh. Calling Refresh say once a day, results in offline learning, and calling it every few
minutes results in online learning. As a side-effect, Refresh clears the client side cache used by
Predict, as discussed above.

