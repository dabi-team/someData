Fast and Complete: Enabling Complete Neural Network Veri-
ﬁcation with Rapid and Massively Parallel Incomplete Veriﬁers

Kaidi Xu*,1

Huan Zhang*,2

Shiqi Wang3

Yihan Wang2

Suman Jana3

Xue Lin1
1Northeastern University 2UCLA 3Columbia University

Cho-Jui Hsieh2

1
2
0
2

r
a

M
6
1

]
I

A
.
s
c
[

2
v
4
2
8
3
1
.
1
1
0
2
:
v
i
X
r
a

xu.kaid@northeastern.edu, huan@huan-zhang.com, tcwangshiqi@cs.columbia.edu,
wangyihan617@gmail.com, suman@cs.columbia.edu, xue.lin@northeastern.edu,
chohsieh@cs.ucla.edu

ABSTRACT
Formal veriﬁcation of neural networks (NNs) is a challenging and important prob-
lem. Existing efﬁcient complete solvers typically require the branch-and-bound
(BaB) process, which splits the problem domain into sub-domains and solves each
sub-domain using faster but weaker incomplete veriﬁers, such as Linear Program-
ming (LP) on linearly relaxed sub-domains. In this paper, we propose to use the
backward mode linear relaxation based perturbation analysis (LiRPA) to replace
LP during the BaB process, which can be efﬁciently implemented on the typi-
cal machine learning accelerators such as GPUs and TPUs. However, unlike LP,
LiRPA when applied naively can produce much weaker bounds and even cannot
check certain conﬂicts of sub-domains during splitting, making the entire proce-
dure incomplete after BaB. To address these challenges, we apply a fast gradient
based bound tightening procedure combined with batch splits and the design of
minimal usage of LP bound procedure, enabling us to effectively use LiRPA on
the accelerator hardware for the challenging complete NN veriﬁcation problem
and signiﬁcantly outperform LP-based approaches. On a single GPU, we demon-
strate an order of magnitude speedup compared to existing LP-based approaches.

1

INTRODUCTION

Although neural networks (NNs) have achieved great success on various complicated tasks, they
remain susceptible to adversarial examples (Szegedy et al., 2013): imperceptible perturbations of
test samples might unexpectedly change the NN predictions. Therefore, it is crucial to conduct
formal veriﬁcation for NNs such that they can be adopted in safety or security-critical settings.

Formally, the neural network veriﬁcation problem can be cast into the following decision problem:

Given a neural network f (·), an input domain C, and a property P. ∀x ∈ C, does f (x) satisfy P?

The property P is typically a set of desirable outputs of the NN conditioned on the inputs. Typically,
consider a binary classiﬁer f (x) and a positive example x0 (f (x0) ≥ 0), we can set P to be non-
negative numbers R+ and x is bounded within an l∞ norm ball C = {x|(cid:107)x − x0(cid:107)∞ ≤ (cid:15)}. The
success of veriﬁcation guarantees that the label of x0 cannot ﬂip for any perturbed inputs within C.

In this paper we study the complete veriﬁcation setting, where given sufﬁcient time, the veriﬁer
should give a deﬁnite “yes/no” answer for a property under veriﬁcation. In the above setting, it
must solve the non-convex optimization problem minx∈C f (x) to a global minimum. Complete NN
veriﬁcation is generally a challenging NP-Hard problem (Katz et al., 2017) which usually requires
expensive formal veriﬁcation methods such as SMT (Katz et al., 2017) or MILP solvers (Tjeng
et al., 2019b). On the other hand, incomplete solvers such as convex relaxations of NNs (Salman
et al., 2019) can only provide a sound analysis, i.e., they can only approximate the lower bound of
minx∈C f (x) as f and verify the property when f ≥ 0. No conclusion can be drawn when f < 0.
Recently, a Branch and Bound (BaB) style framework (Bunel et al., 2018; 2020b) has been adopted
for efﬁcient complete veriﬁcation. BaB solves the optimization problem minx∈C f (x) to a global

* Equal Contribution.

1

 
 
 
 
 
 
minimum by branching into multiple sub-domains recursively and bounding the solution for each
sub-domain using incomplete veriﬁers. BaB typically uses a Linear Programming (LP) bounding
procedure as an incomplete veriﬁer to provide feasibility checking and relatively tight bounds for
each sub-domain. However, the relatively high solving cost of LPs and incapability of paralleliza-
tion (especially on massively parallel hardware accelerators like GPUs or TPUs) greatly limit the
performance and scalability of the existing complete BaB based veriﬁers.

In this paper, we aim to use fast and typically weak incomplete veriﬁers for complete veriﬁcation.
Speciﬁcally, we focus on a class of incomplete veriﬁers using efﬁcient bound propagation oper-
ations, referred to as linear relaxation based perturbation analysis (LiRPA) algorithms (Xu et al.,
2020). Representative algorithms in this class include convex outer adversarial polytope (Wong
& Kolter, 2018), CROWN (Zhang et al., 2018) and DeepPoly (Singh et al., 2019b). LiRPA algo-
rithms exhibit high parallelism as the bound propagation process is similar to forward or backward
propagation of NNs, which can fully exploit machine learning accelerators (e.g., GPUs and TPUs).

Although LiRPA bounds are very efﬁcient for incomplete veriﬁcation, especially in training certiﬁed
adversarial defenses (Wong et al., 2018; Mirman et al., 2018; Wang et al., 2018a; Zhang et al., 2020),
they are generally considered too loose to be useful compared to LPs in the complete veriﬁcation
settings with BaB. As we will demonstrate later, using LiRPA bounds naively in BaB cannot even
guarantee the completeness when splitting ReLU nodes, and thus we need additional measures to
make them useful for complete veriﬁcation. In fact, LiRPA methods have been used to get upper and
lower bounds for each ReLU neuron in constructing tighter LPs (Bunel et al., 2018; Lu & Kumar,
2020). It was also used in (Wang et al., 2018c) for verifying small-scale problems with relatively low
dimensional input domains using input splits, but splitting the input space can be quite ineffective
(Bunel et al., 2018) and is unable to scale to high dimensional input case like CIFAR-10. Except
one concurrent work (Bunel et al., 2020a), most complete veriﬁers are based on relatively expensive
solvers like LP and cannot fully take beneﬁt from massively parallel hardware (e.g., GPUs) to obtain
tight bounds for accelerating large-scale complete veriﬁcation problems. Our main contributions are:

• We show that LiRPA bounds, when improved with fast gradient optimizers, can potentially out-
perform bounds obtained by LP veriﬁers. This is because LiRPA allows joint optimization of both
intermediate layer bounds of ReLU neurons (which determine the tightness of relaxation) and output
bounds, while LP can only optimize output bounds with ﬁxed relaxations on ReLU neurons.
• We show that BaB purely using LiRPA bounds is insufﬁcient for complete veriﬁcation due to the
lack of feasibility checking for ReLU node splits. To address this issue, we design our algorithm to
only invoke LP when absolutely necessary and exploits hardware parallelism when possible.
• To fully exploit the hardware parallelism on the machine learning accelerators, we use a batch
splitting approach that splits on multiple neurons simultaneously, further improving our efﬁciency.
• On a few standard and representative benchmarks, our proposed NN veriﬁcation framework
can outperform previous baselines signiﬁcantly, with a speedup of around 30X compared to basic
BaB+LP baselines, and up to 3X compared to recent state-of-the-art complete veriﬁers.

2 BACKGROUND

2.1 Formal deﬁnition of Neural network (NN) veriﬁcation

Notations of NN. For illustration, we deﬁne an L-layer feedforward NN f : R|x| → R with L
weights W(i) (i ∈ {1, · · · , L}) recursively as h(i)(x) = W(i)g(i−1)(x), hidden layer g(i)(x) =
ReLU(h(i)(x)), input layer g(0)(x) = x, and ﬁnal output f (x) = h(L)(x). For simplicity we ignore
biases. We sometimes omit x and use h(i)
to represent the pre-activation of the j-th ReLU neuron
j
in i-th layer for x ∈ C, and we use g(i)
to represent the post-activation value. We focus on verifying
j
ReLU based NNs, but our method is generalizable to other activation functions supported by LiRPA.

NN Veriﬁcation Problem. Given an input x, its bounded input domain C, and a feedforward NN
f (·), the aim of formal veriﬁcation is to prove or disprove certain properties P of NN outputs. Since
most properties studied in previous works can be expressed as a Boolean expression over a linear
equation of network output, where the linear property can be merged into the last layer weights of a
NN, the ultimate goal of complete veriﬁcation reduces to prove or disprove:

∀x ∈ C, f (x) ≥ 0

(1)

2

One way to prove Eq. 1 is to solve minx∈C f (x). Due to the non-convexity of NNs, ﬁnding the
exact minimum of f (x) over x ∈ C is challenging as the optimization process is generally NP-
complete (Katz et al., 2017). However, in practice, a sound approximation of the lower bound for
f (x), denoted as f , can be more easily obtained and is sufﬁcient to verify the property. Thus, a good
veriﬁcation strategy to get a tight approximation f can save signiﬁcant time cost. Note that f must
be sound, i.e., ∀x ∈ C, f ≤ f (x), proving f ≥ 0 is sufﬁcient to prove the property f (x) ≥ 0.

2.2 The Branch and Bound (BaB) framework for Neural Network Veriﬁcation

(cid:17)

(cid:16)

h(k)
j ≥ 0

Branch and Bound (BaB), an effective strategy in solving traditional combinatorial optimization
problems, has been customized and widely adopted for NN veriﬁcation (Bunel et al., 2018; 2020b).
Speciﬁcally, BaB based veriﬁcation framework is a recursive process, consisting of two main steps:
branching and bounding. For branching, BaB based methods will divide the bounded input domain
C into sub-domains {Ci|C = (cid:83)
i Ci}, each deﬁned as a new independent veriﬁcation problem. For
j = ReLU(h(k)
instance, it can split a ReLU unit g(k)
) to be negative and positive cases as C0 =
(cid:17)
h(k)
for a ReLU-based network; for each sub-domain Ci,
C ∩
j < 0
BaB based methods perform bounding to obtain a relaxed but sound lower bound f
. A tightened
global lower bound over C can then be obtained by taking the minimum values of the sub-domain
lower bounds from all the sub-domains: f = mini f
. Branching and bounding will be performed
recursively to tighten the approximated global lower bound over C until either (1) the global lower
bound f becomes larger than 0 and prove the property or (2) a violation (e.g., adversarial example)
is located in a sub-domain to disprove the property. Essentially, we build a search tree where each
leaf is a sub-domain, and the property P can be proven only when it is valid on all leaves.

and C1 = C ∩

(cid:16)

Ci

Ci

j

Soundness of BaB We say the veriﬁcation process is sound if we can always trust the “yes” (P
is veriﬁed) answer given by the veriﬁer.
It is straightforward to see that the whole BaB based
veriﬁcation process is sound as long as the bounding method used for each sub-domain Ci is sound.

Completeness of BaB The completeness of the BaB-based NN veriﬁcation process, which was
usually assumed true in some previous works (Bunel et al., 2020b; 2018), in fact, is not always
true even if all possible sub-domains are considered with a sound bounding method. Additional
requirements for the bounding method are required - we point out that a key factor for completeness
involves feasibility checking in the bounding method which we will discuss in Section 3.2.

Branching in BaB Since branching step determines the shape of the search tree, the main chal-
lenge is to efﬁciently choose a good leaf to split, which can signiﬁcantly reduce the total number of
branches and running time. In this work we focus on branching on activation (ReLU) nodes. BaBSR
(Bunel et al., 2018) includes a simple branching heuristic which assigns each ReLU node a score to
estimate the improvement for tightening f by splitting it, and splits the node with the highest score.

Bounding with Linear Programming (LP) A typical bounding method used in BaB based veri-
ﬁcation is the Linear Programming bounding procedure (sometimes simply referred to as “LP” or
“LP veriﬁer” in our paper). Speciﬁcally, we transform the original veriﬁcation problem into a linear
programming problem by relaxing every activation unit as a convex (linear) domain (Ehlers, 2017)
with a linear solver given domain Ci. For instance, as shown in
and then get the lower bound f
Figure 1a, g(i)
j ≥ h(i)
j ;

j ) can be linearly relaxed with the following 3 constraints: (1) g(i)

Ci

(h(i)

(2)g(i)

(i)
u
j ≥ 0; (3) g(i)
j
(i)
(i)
j −l
j
each activation node h(i)
j are required in the LP construction given Ci. They are typically computed
by the existing cheap bounding methods like LiRPA variants (Wong & Kolter, 2018) with low cost.
The tighter the intermediate bounds (l(i)

j ). Note that the lower bound l(i)

j ) are, the tighter f approximated by LP is.

and upper bound u(i)
j

j , u(i)

j − l(i)

for

u

j

j = ReLU(h(i)
j ≤

2.3 Linear Relaxation based Perturbation Analysis (LiRPA)

Bound propagation in LiRPA We used Linear Relaxation based Perturbation Analysis (LiRPA)1
as bound procedure in BaB to get linear upper and lower bounds of NN output w.r.t input x ∈ C:

Ax + b ≤ f (x) ≤ Ax + b,

x ∈ C

(2)

1We only use the backward mode LiRPA bounds (e.g., CROWN and DeepPoly) in this paper.

3

Figure 1: Relaxations of a ReLU: (a) “triangle” relaxation in LP; (b)(c) No relaxation when u(i)
inactive) or l(i)

j ≥ 0 (always active); (d) linear relaxation in LiRPA when l(i)

j < 0, u(i)

j > 0 (unstable).

j ≤ 0 (always

A lower bound f can then be simply obtained by taking the lower bound of the linear equation
Ax + b w.r.t input x ∈ C, which can be obtained via H¨older’s inequality when C is a (cid:96)p norm ball.

To get the coefﬁcients A, A, b, b, LiRPA propagates bounds of f (x) as a linear function to the
output of each layer, in a backward manner. At the output layer h(L)(x) we simply have:
Ih(L)(x) ≤ f (x) ≤ Ih(L)(x),

(3)
Then, the next step is to backward propagate the identity linear relationship through a linear layer
h(L)(x) = W(L)g(L−1)(x) to get the linear bounds of f (x) w.r.t g(L−1):

x ∈ C

x ∈ C

W(L)g(L−1)(x) ≤ f (x) ≤ W(L)g(L−1)(x),

(4)
To get the linear relationship of h(L−1) w.r.t f (x), we need to backward propagate through ReLU
layer g(L−1)(x) = ReLU(h(L−1)(x)). Since it is nonlinear, we perform linear relaxations. For
illustration, considering the j-th ReLU neuron at i-th layer, g(i)
j (x)), we can
(i)
linearly upper and lower bound it by a(i)
j ≤ g(i)
j , where
(i)
j , a(i)
j , b(i)
a(i)
j , b
j are:

j = 0, b(i)
j = a(i)
a(i)

j = 1, b(i)
a(i)
j = a(i)

j = α(i)
j , a(i)
a(i)
j =

u(i)
j ≤ 0 (always inactive for x ∈ C)
l(i)
j ≥ 0
j < 0, u(i)
l(i)

j (x) = ReLU(h(i)
j (x) ≤ a(i)

(i)
j = 0
(i)
j = 0
, b(i)

j > 0 (unstable for x ∈ C)

(always active for x ∈ C)

j = b
j = b
u

j (x) + b(i)

j (x) + b

(i)
j = −

j = 0, b

j h(i)

j h(i)

(5)

u

(i)
(i)
j l
j
(i)
(i)
j −l
j

u

(i)
j
(i)
(i)
j −l
j

u

j ≤ h(i)

j (x) ≤ u(i)

j are intermediate pre-activation bounds for x ∈ C, and α(i)

Here l(i)
is an arbitrary
value between 0 and 1. The pre-activation bounds l(i)
j (x)
as the output neuron with LiRPA. Figure 1(b,c,d) illustrate the relaxation for each state of ReLU
neuron. With these linear relaxations, we can get the linear equation of h(L−1) w.r.t output f (x):

j can be computed by treating h(i)

j and u(i)

j

h(L−1)(x) + b(L) ≤ f (x) ≤ W(L)D

(L−1)
α

W(L)D(L−1)
(cid:40)

α
a(L)
j
a(L)
j

h(L−1)(x) + b
(cid:40)

(L)

,
b(L)
j
(L)
b
j

x ∈ C
, W(L)
, W(L)

D(L)

α,(j,j) =

j ≥ 0
j < 0
, D

, b(L) = b(cid:48)(L)(cid:62)W(L), where b(cid:48)(L)

, W(L)
, W(L)
The diagonal matrices D(L−1)
and biases reﬂects the linear relaxations and also considers
the signs in W(L) to maintain the lower and upper bounds. The deﬁnitions for j-th diagonal element
(L)
D
α,(j,j) and bias b
swapped.
Importantly, D(L−1)
j ∈ [0, 1] which do not affect correctness of the bounds.
We can continue backward propagating these bounds layer by layer (e.g., g(L−2)(x), h(L−2)(x),
etc) until reaching g(0)(x) = x, getting the eventual linear equations of f (x) in terms of input x:

are similar, with the conditions for checking the signs of W(L)

has free variables α(i)

j ≥ 0
j < 0

(L−1)
α

j =

(L)

α

α

j

(6)

L(x, α) ≤ f (x) ≤ U(x, α),

∀x ∈ C, where

L(x, α) = W(L)D(L−1)

α

· · · D(1)

α W(1)x + b, U(x, α) = W(L)D

(L−1)
α

· · · D

(1)
α W(1)x + b

Here α denotes α(i)
for all unstable ReLU neurons in NN. The obtained bounds (L(x, α), U(x, α))
j
of f (x) are linear functions in terms of x. Beyond the simple feedforward NN presented here, LiRPA
can support more complicated NN architectures like DenseNet and Transformers by computing L
and U automatically and efﬁciently on general computational graphs (Xu et al., 2020).

(7)

Soundness of LiRPA The above backward bound propagation process guarantees that L(x, α) and
U(x, α) soundly bound f (x) for all x ∈ C. Detailed proofs can be found in (Zhang et al., 2018;
Singh et al., 2019b) for feedforward NNs and (Xu et al., 2020) for general networks.

4

l(i)ju(i)jx(i)jh(i)jl(i)ju(i)jh(i)jl(i)ju(i)jh(i)jl(i)ju(i)jh(i)jl(i)ju(i)jh(i)j(a)(b)(c)(d)Figure 2: Illustration of our optimized LiRPA bounds and the BaB process. Given a two-layer neural network,
we aim to verify output f (x) ≥ 0. Optimized LiRPA chooses optimized slopes for ReLU lower bounds,
allowing tightening the intermediate layer bounds l(i)
and also the output layer lower bound f . BaB
j
splits two unstable neurons h(2)

to improve f and verify all sub-domains (f ≥ 0 for all cases).

and u(i)
j

and h(2)

1
3 PROPOSED ALGORITHM

2

Overview In this section, we will ﬁrst introduce our proposed efﬁcient optimization of LiRPA
bounds on GPUs that can allow us to achieve tight approximation on par with LP or even tighter for
some cases but in a much faster manner. In Fig. 2, we provide a two-layer NN example to illustrate
how our optimized LiRPA can improve the performance of BaB veriﬁcation. In Section 3.2, we
then show that feasibility checking is important to guarantee the completeness of BaB, and BaB
using LiRPA without feasibility checking will end up to be incomplete. To ensure completeness,
we design our algorithm with minimal usage of LP for checking feasibility of splits. Finally, we
propose a batch split design by solving a batch of sub-domains in a massively parallel manner on
GPUs to fully leverage the beneﬁts of cheap and parallelizable LiRPA. We further improve BaBSR
in a parallel fashion for branching and we summarize the detailed proposed algorithm in Section 3.4.

3.1 Optimized LiRPA for Complete Veriﬁcation

Concrete outer bounds with optimizable parameters We propose to use LiRPA as the bounding
step in BaB. A pair of sound and concrete lower bound and upper bound (f , f ) to f (x) can be
obtained according to Eq. 7 given ﬁxed α = α0:

f (α0) = min
x∈C

L(x, α0),

f (α0) = max
x∈C

U(x, α0)

(8)

Because L, U are linear functions w.r.t x when α0 is ﬁxed, it is easy to solve Eq. 8 using H¨older’s
inequality when C is a (cid:96)p norm ball (Xu et al., 2020). In incomplete veriﬁcation settings, α can be
set via certain heuristics (Zhang et al., 2018). Salman et al. (2019) showed that, the variable α is
equivalent to dual variables in the LP relaxed veriﬁcation problem (Wong & Kolter, 2018). Thus, an
optimal selection of α given the same pre-activation bounds l(i)
j can in fact, lead to the the
same optimal solution for f and f as in LP.

j and u(i)

Previous complete veriﬁers typically use LiRPA variants to obtain intermediate layer bounds to
construct an LP problem (Bunel et al. (2018); Lu & Kumar (2020)) and solve the LP to obtain
bounds at output layer. The main reason for using LP is that it typically produces much tighter
bounds than LiRPA when α is not optimized. We use optimized LiRPA, which is fast, accelerator-
friendly, and can produce tighter bounds, well outperforming LP for complete veriﬁcation:

f = min

L(x, α),

f = max

min
x∈C

max
x∈C

U(x, α), α(i)

j ∈ [0, 1]

α

α
The inner minimization or maximization has closed form solutions (Xu et al., 2020) based on
H¨older’s inequality, so we only need to optimize on α. Since we use a differentiable framework (Xu
et al., 2020) to compute the LiRPA bound functions L and U, the gradients ∂L
∂α can be
obtained easily. Optimization over α can be done via projected gradient descent (each coordinate of
α is constrained in [0, 1]). Since the gradient computation and optimization are done on GPUs, the
bounding process is still very fast and can be one or two magnitudes faster than solving an LP.

∂α and ∂U

(9)

Optimized LiRPA bounds can be tighter than LP Solving Eq. 9 using gradient descent cannot
guarantee to converge to the global optima, so it seems the bounds must be looser than LP. Counter-
intuitively, by optimizing α, we can potentially obtain tighter bounds than LP. When a “triangle”

5

𝑥1𝑥2ΣΣΣAlways Active:𝒍𝑗(𝑖)≥0AlwaysInactive: 𝒖𝑗(𝑖)≤0Linear relaxed Unstable neuron:𝒍𝑗(𝑖)<0, 𝒖𝑗(𝑖)>0ΣΣΣ𝑓(𝑥)ℎ1(1)ℎ2(1)ℎ3(1)𝑥1𝑥2ΣΣΣΣΣΣ𝑓(𝑥)Unoptimized LiRPA: lower bound 𝑓=−1.94Optimized LiRPA: lower bound 𝑓=−0.83Prove: 𝑓𝑥≥0,∀𝑥∈𝒞ℎ1(2)ℎ2(2)ℎ3(2)ℎ1(1)ℎ2(1)ℎ3(1)ℎ1(2)ℎ2(2)ℎ3(2)Split ℎ2(2)Pick ℎ1(2)Splitℎ1(2)Pick ℎ2(2)𝑓=−0.15𝑓=0.17✓𝑓=0.25✓𝑓=0.31✓ReLULower bound by Optimized LiRPAExample: Optimized LiRPA for ℎ1(2)tigher 𝑙1(2)and 𝑢1(2)make tighter relaxationExample: BaBto find tighter lower bound𝑙1(2)𝑢1(2)𝑙1(2)𝑢1(2)j , u(i)

relaxation is constructed for LP, intermediate pre-activation bounds l(i)
j must be ﬁxed for the
j-th ReLU in layer i. During the LP optimization process, only the output bounds are optimized;
intermediate bounds stay unchanged. However, in the LiRPA formulation, L(x, α) and U(x, α) are
complex functions of α: since intermediate bounds are also computed by LiRPA, they depend on all
α(i(cid:48))
j(cid:48) (0 < i(cid:48) < i) in previous layers. Thus, the gradients ∂L
∂α can tighten output layer bounds
f and f indirectly by tightening intermediate layer bounds, forming a tighter convex relaxation for
the next iteration. An LP solver cannot achieve this because adding l(i)
as optimization
j
variables makes the problem non-linear. This is the key to our success of applying LiRPA based
bounds for the complete veriﬁcation setting, where tighter bounds are essential.

∂α and ∂U

and u(i)
j

In Figure 3, we illustrate our optimized LiRPA bounds and
the LP solution. Initially, we use LiRPA with α set via a fast
and u(i)
heuristic to compute intermediate layer bounds l(i)
j ,
j
and then use them to build a relaxed LP problem. The solution
to this initial LP problem (red line) is much tighter than the
LiRPA solution with the heuristically set α (the left-most point
of the blue line). Then, we optimize α with gradient decent,
and LiRPA quickly outperforms this initial LP solution due to
optimized tighter intermediate layer bounds. We can create a
new LP with optimized intermediate bounds (light blue line),
producing a slightly tighter bound than LiRPA with optimized
α. The LP bounds in most existing complete veriﬁers all use
intermediate layer bounds obtained from unoptimized LiRPA bounds or even weaker methods like
interval arithmetic, ending up to the solution close to or lower than the red line in Figure 3. In-
stead, our optimized LiRPA bounds can produce tight bounds, and also exploit parallel acceleration
from machine learning accelerators, leading to huge improvements in veriﬁcation time compared to
existing baselines.

Figure 3: Optimized LiRPA bound (0
to 200 iterations) vs LP bounds.

j ≥ 0 and h(i)

ReLU Split Constraints In the BaB process, when a ReLU h(i)
is split into two sub-domains
j
(h(i)
j < 0 in bounding step. It tighten the
LiRPA bounds by forcing the split ReLU linear, reducing relaxation errors. However, when splits
are added, LiRPA and LP are not equivalent even under ﬁxed l(i)
and optimal α. After splits,
LiRPA cannot check certain constraints where LP is capable to, as we will discuss in the next section.

j < 0), we simply set l(i)

j ≥ 0 and u(i)

j , u(i)

j

3.2 Completeness with Minimal Usage of LP Bounding Procedure

Even though our optimized LiRPA can bring us huge speed improvement over LP for BaB based
veriﬁcation, we observe that it may end up to be incomplete due to the lack of feasibility checking: it
cannot detect some conﬂicting settings of ReLU splits. We state such an observation in Theorem 3.1:

Theorem 3.1 (Incompleteness without feasibility checking) When using LiRPA variants de-
scribed in Section 2.3 as the bounding procedure, BaB based veriﬁcation is incomplete.

< 0) ∩ (h(i2)
j2

We prove the theorem by giving a counter-example in Appendix A.1 where all ReLU neurons are
split and thus LiRPA runs on a linear network for each sub-domain. As a result, LiRPA can still
be indecisive for the veriﬁcation problem. The main reason is that LiRPA variants will lose the
feasibility information encoded by the sub-domain constraints. For illustration, consider a sub-
domain Ci = C ∩ (h(i1)
(x) = 0 (inactive ReLU, a zero
j1
function) and g(i2)
these bounds to get the approximated lower bound f
< 0) ∩ (h(i2)
(h(i1)
j2
j1
h(i2)
cannot be ≥ 0). On the contrary, LP can fully preserve such feasibility information due to the
j2
linear solver involved and detect the infeasible sub-domains. Then, in Theorem 3.2 we show that the
minimal usage of feasibility checking with LP can guarantee the completeness of BaB with LiRPA.

j1
(x) (active ReLU, an identity function) respectively and propagate
. However, the split feasibility constraint

≥ 0) is ignored, so two conﬂict splits may be conducted (e.g., when h(i1)
j1

≥ 0), LiRPA will force g(i1)

(x) = h(i2)
j2

< 0,

Ci

j2

6

050100150200iteration12108642lower boundLP initial boundoptimized LiRPA boundLP optimized boundAlgorithm 1 Parallel BaB with optimized LiRPA bounding (we highlight the differences between
our algorithm and regular BaB (Bunel et al., 2018) in blue. Comments are in brown.)

(cid:46) P is the set of all unveriﬁed sub-domains

1: Inputs: f , C, n (batch size), η (threshold to switch to LP)
2: (f , f ) ← optimized LiRPA(f, [C])
3: P ← (cid:2)(f , f , C)(cid:3)
4: while f < 0 and f ≥ 0 do
5:
6:

(C1, . . . , Cn) ← batch pick out(P, n)
(cid:2)Cl
1, Cu
(cid:104)
f

(cid:3) ← batch split(C1, . . . , Cn) (cid:46) Each Ci splits into two sub-domains Cl
n, Cu
, . . . , f
n

(cid:46) Pick sub-domains to split and removed them from P
i and Cu
i
(cid:3))
(cid:46)

← optimized LiRPA(f, (cid:2)Cl

1 , . . . , Cl
, f
, f Cl

n, Cu
n
, f Cu

1 , . . . , Cl

1, Cu

, f Cu

, f Cl

, f

(cid:105)

Cl
1

Cu
1

1

1

Cu
n
Compute lower and upper bounds using LiRPA for each sub-domain on GPUs in a batch
, Cl

P ← P (cid:83) Domain Filter

[f
Filter out veriﬁed sub-domains, insert the left domains back to P

1 ], . . . , [f

, f Cu

n], [f

, f C1

1], [f

, f Cl

, Cu

, Cl

Cu
1

Cl
n

Cl
n

Cl
1

Cu
n

(cid:16)

n

n

n

1

1

(cid:17)

, Cu
n]

, f Cu

n

(cid:46)

(cid:46) To ease notation, Ci here indicates both Cu

i and Cl
i

, Ci) ∈ P}, i = 1, . . . , n
, Ci) ∈ P}, i = 1, . . . , n

| (f
Ci
| (f Ci

f ← min{f
Ci
f ← min{f Ci
if length(P) > η then
, f Cu
, f Cl

, f

f

(cid:104)

, . . . , f

1

Cl
1

Cu
1
P ← P (cid:83) Domain Filter

1

Cl
n
(cid:16)

[f

, f Cl

n

, f

, f Cu

n

,

Cu
n

(cid:105)

← compute bound LP(f, (cid:2)Cl

(cid:46) Fall back to LP for completeness
(cid:3))
1, Cu
n, Cu
n
(cid:17)

1 , . . . , Cl

, f C1

n

Cl
n

, Cl

n], [f

, f Cu

n

, Cu
n]

Cu
n

, f Cl

1

Cl
1

, Cl

1], [f

, f Cu

1

Cu
1

, Cu

1 ], . . . , [f

7:

8:

9:

10:
11:

12:

13:

14: Outputs: f , f

Theorem 3.2 (Minimal feasibility checking for completeness) When using LiRPA variants de-
scribed in Section 2.3 as the bounding procedure, BaB based veriﬁcation is complete if all infeasible
leaf sub-domains (i.e., sub-domains cannot be further split) are detected by linear programming.

We prove the theorem in Appendix A.2, where we show that by checking the feasibility of splits
with LP, we can eliminate the cases where incompatible splits are chosen in the LiRPA BaB process.
Since LP is slow while LiRPA is highly efﬁcient, we propose to only use LP when the LiRPA based
bounding process is stuck, either (1) when partitioning and bounding new sub-domains with LiRPA
cannot further improve the bounds, or (2) when all unstable neurons have been split. In this way, the
infeasible sub-domains can be eventually detected by occasional usage of LP while the advantage of
massive parallel LiRPA on GPUs is fully enjoyed. We will describe our full algorithm in Sec. 3.4.

3.3 Batch Splits
SOTA BaB methods (Bunel et al., 2020b; Lu & Kumar, 2020) only split one sub-domain during
each branching step. Since we use cheap and GPU-friendly LiRPA bounds, we can select a batch of
sub-domains to split and propagate their LiRPA bounds in a batch. Such a batch splitting design can
greatly improve hardware efﬁciency on GPUs. Given a batch size n that allows us to fully use the
GPU memory available, we can obtain n bounds simultaneously. It grows the search tree on a single
leaf by a depth of log2 n, or split n/2 leaf nodes at the same time, accelerating by up to n times.

3.4 Our Complete Veriﬁcation Framework
Our LiRPA based complete veriﬁcation framework is presented in Alg. 1. The algorithm takes a
target NN function f and a domain C as inputs. We run optimized LiRPA to get initial bounds
(f , f ) for x ∈ C (Line 2). Then we utilize the power of GPUs to split in parallel and maintain
a global set P storing all the sub-domains which cannot be veriﬁed with optimized LiRPA (Line
5-10). Speciﬁcally, batch pick out improves BaBSR (Bunel et al., 2018) in a parallel manner to
select n sub-domains in P and determine the corresponding ReLU neuron to split for each of them. If
the length of P is less than n, then we reduce n to the length of P. batch split splits each selected
Ci to two sub-domains Cl
i by forcing the selected unstable ReLU neuron to be positive and
negative, respectively. optimize LiRPA runs optimized LiRPA in parallel as a batch and returns
the lower and upper bounds for n selected sub-domains simultaneously. Domain Filter ﬁlters out
≥ 0) and we insert the remaining ones to P. The loop breaks
veriﬁed sub-domains (proved with f

i and Cu

Ci

if the property is proved (f ≥ 0) or a counter-example is found in any sub-domain (f < 0).

To avoid excessive splits, we set the maximum length of the sub-domains to η (Line 12). Once the
length of P reaches this threshold, compute bound LP will be called. It solves these η sub-domains
by LP (one by one in a loop, or in parallel if using multiple CPUs is allowed) with optimized LiRPA

7

computed intermediate layer bounds. If a sub-domain Ci ∈ P (which previously cannot be veriﬁed
by LiRPA) is proved or detected to be infeasible by LP, as an effective heuristic, we will backtrack
and prioritize to check its parent node with LP. If the parent sub-domain is also proved or infeasible,
we can prune all its child nodes to greatly reduce the size of the search tree.

Completeness of our framework Our algorithm is complete, because we follow Theorem 3.2 and
check feasibility of all split sub-domains that have deep BaB search tree depth (length of P reaches
threshold η), forming a superset of the worst case where all ReLU neurons are split.

4 EXPERIMENTS

In this section, we compare our veriﬁer against the state-of-the-art ones to illustrate the effectiveness
of our proposed framework. Overall, our veriﬁer is about 10X, 4X and 20X faster than the best
LP-based veriﬁer (Lu & Kumar, 2020) on the Base, Wide and Deep models, respectively.

Setup We follow the most challenging experimental setup used in the state-of-the-art veriﬁers
GNN-ONLINE (Lu & Kumar, 2020) and BABSR (Bunel et al., 2020b). Speciﬁcally, we evalu-
ate on CIFAR10 dataset on three NNs: Base, Wide and Deep. The dataset is categorized into
three difﬁculty levels: Easy, Medium, and Hard, which is generated according to the performance
of BaBSR. The veriﬁcation task is deﬁned as given a l∞ norm perturbation less than (cid:15), the clas-
siﬁer will not predict a speciﬁc (predeﬁned) wrong label for each image x (see Appendix B).
We set batch size n = 400, 200, 200 for Base, Wide and Deep model respectively and threshold
η = 12000. More details on experimental setup are provided in Appendix B. Our code is available
at https://github.com/kaidixu/LiRPA Verify.

Comparisons against state-of-the-art veriﬁers We include ﬁve different methods for comparison:
(1) BABSR (Bunel et al., 2020b), a BaB and LP based veriﬁer using a simple ReLU split heuristic;
(2) MIPPLANET (Ehlers, 2017), a customized MIP solver for NN veriﬁcation where unstable ReLU
neurons are randomly selected for split; (3) GNN (Lu & Kumar, 2020) and (4) GNN-ONLINE (Lu
& Kumar, 2020) are BaB and LP based veriﬁers using a learned graph neural network (GNN) to
guide the ReLU split. (5) BDD+ BABSR (Bunel et al., 2020a) is a very recently proposed veriﬁca-
tion framework based on Lagrangian decomposition which also supports GPU acceleration without
solving LPs. All methods use 1 CPU with 1 GPU. The timeout threshold is 3,600 seconds.

For the Base model in different difﬁculty levels, Easy, Medium and Hard, Table 1 shows that we are
around 5 ∼ 40X faster than baseline BaBSR and around 2 ∼ 20X faster than GNN split baselines.
The accumulative solved properties with increasing runtime are shown in Figure 4. In all our exper-
iments, we use the basic heuristic in BaBSR for branching and do not use GNNs, so our speedup
comes purely from the faster LiRPA based bounding procedure. We are also competitive against
Lagrangian decomposition on GPUs.
Table 1: Performance of various methods on different models. We compare each method’s avg. solving time,
the avg. number of branches required, and the percentage of timed out (TO) properties.

Base - Easy

Base - Medium

Base - Hard

Wide

Deep

Method

time(s)

branches %TO time(s)

branches %TO time(s)

branches %TO time(s)

branches %TO time(s)

branches %TO

BABSR
MIPPLANET
GNN
GNN-ONLINE
BDD+ BABSR
OURS

522.5
1462.2
312.9
207.43
15.68
11.86

585
-
301
269
1371
2589

0.0
16.5
0.0
0.0
0.0
0.0

1335.4
1912.2
624.1
638.15
51.88
42.04

1471
-
635
546
6482
9233

0.0
43.5
0.9
0.4
0.4
0.0

2875.2
2172.2
1468.7
1255.4
627.96
633.85

1843
-
931
968
91880
96755

35.2
46.2
15.6
15.6
13.4
13.0

3325.7
3088.4
1791.5
1642.0
510.55
375.23

455
-
375
389
45855
53481

50.3
79.4
19.0
19.0
11.4
8.5

2855.2
2842.5
1870.6
1845.7
230.06
81.55

365
-
198
196
6721
1439

54.0
73.6
18.4
18.4
4.4
1.6

Figure 4: Cactus plots for our method and other baselines in Base (Easy, Medium and Hard ), Wide and Deep
models. We plot the percentage of solved properties with growing running time.

(a) Base-Easy

(b) Base-Medium (c) Base-Hard

(d) Wide

(e) Deep

Performance on Larger Models In Table 1, we show that our veriﬁer is more scalable on larger
(wider or deeper) NNs compared to other state-of-the-art veriﬁers. Our method enjoys efﬁcient GPU
acceleration particularly on Deep model and can achieve 30X speedup compared to BABSR, and we

8

100101102103Running time (in s)020406080100% of properties verifiedBaBSRMIPplanetGNNGNN-OnlineProx. BaBSROurs100101102103Running time (in s)020406080100100101102103Running time (in s)020406080100100101102103Running time (in s)020406080100100101102103Running time (in s)020406080100are also signiﬁcantly faster than Lagrangian decomposition based GPU veriﬁer (BDD+ BABSR).
When compared to the state-of-the-art LP based BaB, GNN-ONLINE, our method can save 20X
running time on Deep model. In Appendix C, we analyze the effectiveness of optimized LiRPA and
batch splits separately, and ﬁnd that optimized LiRPA is crucial for NN veriﬁcation. Performance
comparisons of our proposed framework on CPU cores without GPU acceleration are included in
Appendix D.

5 RELATED WORK

Complete veriﬁers Early complete veriﬁers rely on satisﬁability modulo theory (SMT) (Katz et al.,
2017; Huang et al., 2017; Ehlers, 2017) and mixed integer linear programming (MILP) (Tjeng et al.,
2019a; Dutta et al., 2018), and they typically do not scale well. Higher order logic provers such
as proof assistant (Bentkamp et al., 2018) can also be potentially used for NN veriﬁcation, but
their scalability to the NN setting has not been demonstrated. Recently, Bunel et al. (2018) uniﬁed
many approaches used in various complete veriﬁers into a BaB framework. An LP based bounding
procedure is used in most of the existing BaB framework (Bunel et al., 2018; Wang et al., 2018c;
Royo et al., 2019; Lu & Kumar, 2020). For branching, two categories of branching strategies were
proposed: (1) input node branching (Wang et al., 2018c; Bunel et al., 2020b; Royo et al., 2019;
Anderson et al., 2019) where input features are divided into sub-domains, and (2) activation node
(especially, ReLU) branching (Katz et al., 2017; Bunel et al., 2018; Wang et al., 2018b; Ehlers, 2017;
Lu & Kumar, 2020) where hidden layer activations are split into sub-domains. Bunel et al. (2018)
found that input node branching cost is exponential to input dimension. Thus, many state-of-the-art
veriﬁers use activation node branching instead, focusing on heuristics to select good nodes to split.
BaBSR (Bunel et al., 2018) prioritizes ReLUs for splitting based on their pre-activation bounds; Lu
& Kumar (2020) used a graph neural network (GNN) to learn good splitting heuristics. Our work
focuses on improving bounding and can use better branching heuristics to achieve further speedup.

(1)
Two mostly relevant concurrent works using GPUs for accelerating NN veriﬁcation are:
GPUPoly (M¨uller et al., 2020), an extension of DeepPoly on CUDA, is still an incomplete veriﬁer.
Also, it is implemented in CUDA C++, requiring manual effort for customization and gradient com-
putation, so it is not easy to get the gradients for optimizing bounds as we have done in Section 3.1.
(2) Lagrangian Decomposition (Bunel et al., 2020a) is a GPU-accelerated BaB based complete ver-
iﬁer that iteratively tightens the bounds based on a Lagrangian decomposition optimization formu-
lation and does not reply on LP. However, it solves a much more complicated optimization problem
than LiRPA, and typically requires hundreds of iterations to converge for a single sub-domain.

Incomplete veriﬁers Many incomplete veriﬁcation methods rely on convex relaxations of NN,
replacing nonlinear activations like ReLUs with linear constraints (Wong & Kolter, 2018; Wang
et al., 2018b; Zhang et al., 2018; Weng et al., 2018; Gehr et al., 2018; Singh et al., 2018a;b; 2019b;a)
or semideﬁnite constraints (Raghunathan et al., 2018; Dvijotham et al., 2020; Dathathri et al., 2020).
Tightening the relaxation for incomplete veriﬁcation was discussed in (Dvijotham et al., 2018; Singh
et al., 2019a; Lyu et al., 2019; Tjandraatmadja et al., 2020). Typically, tight relaxations require
more computation and memory in general. We refer the readers to (Salman et al., 2019) for a
comprehensive survey. Recently, Xu et al. (2020) categorized the family of linear relaxation based
incomplete veriﬁers into LiRPA framework, allowing efﬁcient implementation on machine learning
accelerators. Our work uses LiRPA as the bounding procedure for complete veriﬁcation and exploits
its computational efﬁciency to accelerate, and our main contribution is to show that we can use fast
but weak incomplete veriﬁers as the main driver for complete veriﬁcation when strategically applied.

6 CONCLUSION

We use a LiRPA based incomplete NN veriﬁer to accelerate the bounding procedure in branch and
bound (BaB) for complete NN veriﬁcation on massively parallel accelerators. We use a fast gradient
based procedure to tighten LiRPA bounds. We study the completeness of BaB with LiRPA, and
show up to 5X speedup compared to state-of-the-art veriﬁers across multiple models and properties.

ACKNOWLEDGMENTS

This work is supported by NSF grant CNS18-01426; an ARL Young Investigator (YIP) award; an
NSF CAREER award; a Google Faculty Fellowship; a Capital One Research Grant; and a J.P. Mor-

9

gan Faculty Award; Air Force Research Laboratory under FA8750-18-2-0058; NSF IIS-1901527,
NSF IIS-2008173 and NSF CAREER-2048280.

REFERENCES

Greg Anderson, Shankara Pailoor, Isil Dillig, and Swarat Chaudhuri. Optimization and abstraction:
In Proceedings of the 40th
A synergistic approach for analyzing neural network robustness.
ACM SIGPLAN Conference on Programming Language Design and Implementation, pp. 731–
744, 2019.

Alexander Bentkamp, Jasmin Christian Blanchette, Simon Cruanes, and Uwe Waldmann. Super-
In International Joint Conference on Automated

position for lambda-free higher-order logic.
Reasoning, pp. 28–46. Springer, 2018.

Rudy Bunel, Alessandro De Palma, Alban Desmaison, Krishnamurthy Dvijotham, Pushmeet Kohli,
Philip H. S. Torr, and M. Pawan Kumar. Lagrangian decomposition for neural network veriﬁca-
tion. Conference on Uncertainty in Artiﬁcial Intelligence (UAI) 2020, 2020a.

Rudy Bunel, Jingyue Lu, Ilker Turkaslan, P Kohli, P Torr, and P Mudigonda. Branch and bound for
piecewise linear neural network veriﬁcation. Journal of Machine Learning Research, 21(2020),
2020b.

Rudy R Bunel, Ilker Turkaslan, Philip Torr, Pushmeet Kohli, and Pawan K Mudigonda. A uniﬁed
view of piecewise linear neural network veriﬁcation. In Advances in Neural Information Process-
ing Systems, pp. 4790–4799, 2018.

Sumanth Dathathri, Krishnamurthy Dvijotham, Alexey Kurakin, Aditi Raghunathan, Jonathan Ue-
sato, Rudy R Bunel, Shreya Shankar, Jacob Steinhardt, Ian Goodfellow, Percy S Liang, et al.
Enabling certiﬁcation of veriﬁcation-agnostic networks via memory-efﬁcient semideﬁnite pro-
gramming. Advances in Neural Information Processing Systems, 33, 2020.

Souradeep Dutta, Susmit Jha, Sriram Sankaranarayanan, and Ashish Tiwari. Output range analy-
sis for deep feedforward neural networks. In NASA Formal Methods Symposium, pp. 121–138.
Springer, 2018.

Krishnamurthy Dvijotham, Sven Gowal, Robert Stanforth, Relja Arandjelovic, Brendan
O’Donoghue, Jonathan Uesato, and Pushmeet Kohli. Training veriﬁed learners with learned ver-
iﬁers. arXiv preprint arXiv:1805.10265, 2018.

Krishnamurthy Dj Dvijotham, Robert Stanforth, Sven Gowal, Chongli Qin, Soham De, and Push-
meet Kohli. Efﬁcient neural network veriﬁcation with exactness characterization. In Uncertainty
in Artiﬁcial Intelligence, pp. 497–507. PMLR, 2020.

Ruediger Ehlers. Formal veriﬁcation of piece-wise linear feed-forward neural networks. In Interna-
tional Symposium on Automated Technology for Veriﬁcation and Analysis, pp. 269–286. Springer,
2017.

Timon Gehr, Matthew Mirman, Dana Drachsler-Cohen, Petar Tsankov, Swarat Chaudhuri, and Mar-
tin Vechev. Ai2: Safety and robustness certiﬁcation of neural networks with abstract interpreta-
tion. In 2018 IEEE Symposium on Security and Privacy (SP), pp. 3–18. IEEE, 2018.

Xiaowei Huang, Marta Kwiatkowska, Sen Wang, and Min Wu. Safety veriﬁcation of deep neural
networks. In International Conference on Computer Aided Veriﬁcation, pp. 3–29. Springer, 2017.

Guy Katz, Clark Barrett, David L Dill, Kyle Julian, and Mykel J Kochenderfer. Reluplex: An
efﬁcient smt solver for verifying deep neural networks. In International Conference on Computer
Aided Veriﬁcation, pp. 97–117. Springer, 2017.

Jingyue Lu and M Pawan Kumar. Neural network branching for neural network veriﬁcation. Inter-

national Conference on Learning Representation (ICLR), 2020.

Zhaoyang Lyu, Ching-Yun Ko, Zhifeng Kong, Ngai Wong, Dahua Lin, and Luca Daniel. Fastened
crown: Tightened neural network robustness certiﬁcates. arXiv preprint arXiv:1912.00574, 2019.

10

Matthew Mirman, Timon Gehr, and Martin Vechev. Differentiable abstract interpretation for prov-
ably robust neural networks. In International Conference on Machine Learning, pp. 3575–3583,
2018.

Christoph M¨uller, Gagandeep Singh, Markus P¨uschel, and Martin Vechev. Neural network robust-

ness veriﬁcation on gpus. arXiv preprint arXiv:2007.10868, 2020.

Aditi Raghunathan, Jacob Steinhardt, and Percy S Liang. Semideﬁnite relaxations for certifying
robustness to adversarial examples. In Advances in Neural Information Processing Systems, pp.
10877–10887, 2018.

Vicenc Rubies Royo, Roberto Calandra, Dusan M Stipanovic, and Claire Tomlin. Fast neural net-

work veriﬁcation via shadow prices. arXiv preprint arXiv:1902.07247, 2019.

Hadi Salman, Greg Yang, Huan Zhang, Cho-Jui Hsieh, and Pengchuan Zhang. A convex relaxation
In Advances in Neural Information

barrier to tight robustness veriﬁcation of neural networks.
Processing Systems 32, pp. 9832–9842, 2019.

Gagandeep Singh, Timon Gehr, Matthew Mirman, Markus P¨uschel, and Martin Vechev. Fast and
In Advances in Neural Information Processing Systems, pp.

effective robustness certiﬁcation.
10825–10836, 2018a.

Gagandeep Singh, Timon Gehr, Markus P¨uschel, and Martin Vechev. Boosting robustness certiﬁca-

tion of neural networks. In International Conference on Learning Representations, 2018b.

Gagandeep Singh, Rupanshu Ganvir, Markus P¨uschel, and Martin Vechev. Beyond the single neuron
convex barrier for neural network certiﬁcation. In Advances in Neural Information Processing
Systems, pp. 15072–15083, 2019a.

Gagandeep Singh, Timon Gehr, Markus P¨uschel, and Martin Vechev. An abstract domain for cer-
tifying neural networks. Proceedings of the ACM on Programming Languages, 3(POPL):41,
2019b.

Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow,

and Rob Fergus. Intriguing properties of neural networks. In ICLR, 2013.

Christian Tjandraatmadja, Ross Anderson, Joey Huchette, Will Ma, Krunal Patel, and Juan Pablo
Vielma. The convex relaxation barrier, revisited: Tightened single-neuron relaxations for neural
network veriﬁcation. arXiv preprint arXiv:2006.14076, 2020.

Vincent Tjeng, Kai Xiao, and Russ Tedrake. Evaluating robustness of neural networks with mixed

integer programming. ICLR, 2019a.

Vincent Tjeng, Kai Y. Xiao, and Russ Tedrake. Evaluating robustness of neural networks with mixed
integer programming. In 7th International Conference on Learning Representations, ICLR 2019,
New Orleans, LA, USA, May 6-9, 2019. OpenReview.net, 2019b. URL https://openreview.net/
forum?id=HyGIdiRqtm.

Shiqi Wang, Yizheng Chen, Ahmed Abdou, and Suman Jana. Mixtrain: Scalable training of formally

robust neural networks. arXiv preprint arXiv:1811.02625, 2018a.

Shiqi Wang, Kexin Pei, Justin Whitehouse, Junfeng Yang, and Suman Jana. Efﬁcient formal safety
analysis of neural networks. In Advances in Neural Information Processing Systems, pp. 6367–
6377, 2018b.

Shiqi Wang, Kexin Pei, Justin Whitehouse, Junfeng Yang, and Suman Jana. Formal security analysis
of neural networks using symbolic intervals. In 27th {USENIX} Security Symposium ({USENIX}
Security 18), pp. 1599–1614, 2018c.

Tsui-Wei Weng, Huan Zhang, Hongge Chen, Zhao Song, Cho-Jui Hsieh, Luca Daniel, Duane Bon-
ing, and Inderjit Dhillon. Towards fast computation of certiﬁed robustness for relu networks. In
International Conference on Machine Learning, pp. 5273–5282, 2018.

11

Eric Wong and Zico Kolter. Provable defenses against adversarial examples via the convex outer
adversarial polytope. In International Conference on Machine Learning, pp. 5283–5292, 2018.

Eric Wong, Frank Schmidt, Jan Hendrik Metzen, and J Zico Kolter. Scaling provable adversarial

defenses. In NIPS, 2018.

Kaidi Xu, Zhouxing Shi, Huan Zhang, Yihan Wang, Kai-Wei Chang, Minlie Huang, Bhavya
Kailkhura, Xue Lin, and Cho-Jui Hsieh. Automatic perturbation analysis for scalable certiﬁed
robustness and beyond. Advances in Neural Information Processing Systems, 33, 2020.

Huan Zhang, Tsui-Wei Weng, Pin-Yu Chen, Cho-Jui Hsieh, and Luca Daniel. Efﬁcient neural net-
work robustness certiﬁcation with general activation functions. In Advances in neural information
processing systems, pp. 4939–4948, 2018.

Huan Zhang, Hongge Chen, Chaowei Xiao, Bo Li, Duane Boning, and Cho-Jui Hsieh. Towards
stable and efﬁcient training of veriﬁably robust neural networks. In International Conference on
Learning Representations, 2020.

12

A PROOFS

A.1 Proof of Theorem 3.1

1 = h(2)

1 ) and g(2)

1 = ReLU(h(2)

2 = ReLU(h(2)

We prove Theorem 3.1 by providing a simple counterexample, and we illustrate the necessity of
feasibility checking for the completeness of BaB based veriﬁcation. Consider an NN with only two
ReLU units g(2)
2 ) where they share the same one dimension
input h(2)
2 = x. The ﬁnal output function of NN is deﬁned as f = g(2)
2 . As a
veriﬁcation problem, we want to verify the property f ≥ 0 where x = [−1, 1]. Since hidden nodes
h1 and h2 are exactly the same, the ground-truth output range is f ∗(x) ∈ [0, 0]. A complete BaB
based veriﬁer is expected to obtain that optimal bound and prove the property after splitting h1 and
h2 together while BaB with only LiPRA cannot guarantee that completeness. Speciﬁcally, BaB with
only LiRPA will split the original domain x ∈ [−1, 1] into four sub-domains and approximate the
bound with LiRPA respectively:

1 − g(2)

(1) (feasible) sub-domain x ∈ [−1, 1], h(2)

(2) (feasible) sub-domain x ∈ [−1, 1], h(2)

2 < 0 with output f = [0, 0] − [0, 0] ∈ [0, 0]

2 ≥ 0 with output f = [x, x] − [x, x] ∈ [0, 0]

(3) (infeasible) sub-domain x ∈ [−1, 1], h(2)

(4) (infeasible) sub-domain x ∈ [−1, 1], h(2)

1 ≥ 0, h(2)
1 < 0, h(2)
1 < 0, h(2)
1 ≥ 0, h(2)
2 < 0 with output f = [x, x] − [0, 0] ∈ [−1, 1]
Only the ﬁrst two split sub-domains are feasible and therefore the ground-truth lower bound 0 can be
obtained by taking the minimum of the estimated bounds from sub-domains (1) and (2). However,
pure LiRPA is not able to tell the infeasibility of sub-domains (3) and (4) and thus BaB with pure
LiRPA will report the minimum −1 got from all these four sub-domains as the global lower bound
for the original input domain, ending up not being able to verify the property, i.e., incomplete.

2 ≥ 0 with output f = [0, 0] − [x, x] ∈ [−1, 1]

A.2 Proof of Theorem 3.2

We prove Theorem 3.2 by considering the worst case where all unstable ReLU neurons are split.

Given a neural network function f with input domain C, assume there are N unstable ReLU neurons
{gi = ReLU(hi)|i = 1, · · · , N } in total. In the worst case, we have 2N leaf sub-domains S =
{Ci|i = 1, · · · , 2N }, where each Ci corresponds to one assignment of unstable ReLU neuron splits.
For example, we can have

C1 = C ∩ (h1 ≥ 0) ∩ (h2 ≥ 0) ∩ · · · ∩ (hN ≥ 0)
C2 = C ∩ (h1 < 0) ∩ (h2 ≥ 0) ∩ · · · ∩ (hN ≥ 0)
C3 = C ∩ (h1 ≥ 0) ∩ (h2 < 0) ∩ · · · ∩ (hN ≥ 0)
C4 = C ∩ (h1 < 0) ∩ (h2 < 0) ∩ · · · ∩ (hN ≥ 0)

· · ·

Note that by deﬁnition the original input domain C = ∪C(cid:48)∈S C(cid:48); in other words, all the 2N split
sub-domains combined will be the same as the original input domain.

Not all of the sub-domains are actually feasible, due to the consistency requirements between neu-
rons. For example, in our proof in Section A.1, h(2)
cannot be both ≥ 0 or both < 0.
1
We can divide the sub-domains S into two mutually exclusive sub-sets, S feas for all the feasible
sub-domains, and S infeas for all the infeasible sub-domains. We have C = ∪C(cid:48)∈S feasC(cid:48) since these
infeasible sub-domains are empty sets.

and h(2)
2

We ﬁrst show that linear programming (LP) can be used to effectively detect these infeasible sub-
domains. For some C(cid:48) ∈ S infeas, because all the ReLU neurons are ﬁxed to be positive or negative,
no relaxation is needed and the network is essentially linear; thus, the input value of every hidden
neuron hi can be written as a linear equation w.r.t. input x. We add all the Boolean predicates on hi
to a LP problem as linear constraints w.r.t x. If this LP is feasible, then we can ﬁnd some input x0
that assigns compatible values to all hi; otherwise, the LP is infeasible.

Due to the lack of feasibility checking in LiRPA, the computed global lower (or upper) bounds
from LiRPA is f
. With feasibility

= minC(cid:48)∈S f

minC(cid:48)∈S feas f

(cid:16)

(cid:17)

C(cid:48), minC(cid:48)∈S infeas f

C(cid:48)

C(cid:48) = min

LiRPA

13

checking from LP, we can remove all infeasible sub-domains from this min such that they do not
contribute to the global lower bound: f = minC(cid:48)∈S feas f

C(cid:48).

To prove the whole BaB veriﬁcation is complete, it is sufﬁcient to prove this lower bound f is the
exact minimum of f bounded in C. Since any sub-domain C(cid:48) ∈ S feas is a leaf sub-domain with
no unstable ReLU neurons, the neural network bounded within C(cid:48) is a linear function. LiRPA can
give an exact minimum of f within sub-domain C(cid:48) . Since C = ∪C(cid:48)∈S feasC(cid:48) (in other words, S feas
covers all the feasible sub-domains within C), the minimal value for all of them f = minC(cid:48)∈S feas f
C(cid:48)
forms the exact minimum of f within the input domain C. Thus, BaB with LiRPA based bounding
procedure is complete when feasibility checking is applied.

B EXPERIMENTAL SETUP

We use the same set of models and benchmark examples used in the state-of-the-art veriﬁers GNN-
ONLINE (Lu & Kumar, 2020) and BABSR (Bunel et al., 2020b). Speciﬁcally, we evaluate on the
most challenging CIFAR-10 dataset with the same standard robustly trained convolutional neural
networks: Base, Wide, and Deep. These model structures are also used in (Lu & Kumar, 2020;
Bunel et al., 2020a). The Base model contains 2 convolution layers with 8 and 16 ﬁlters as well
as two linear layers with 100 and 10 hidden units, respectively. In total, the Base model has 3,172
ReLU activation units. The Wide model contains 2 convolution layers with 16 and 32 ﬁlters and
two linear layers with 100 and 10 hidden units, respectively, which contains 6,244 ReLU activation
units in total. The Deep model contains 4 convolution layers and all of them have 8 ﬁlters and
two linear layers with 100 and 10 hidden units, respectively, with 3,756 ReLU activation units
in total. The source code of BABSR, MIPPLANET, GNN and GNN-ONLINE are available at
https://github.com/oval-group/GNN branching. The source code of BDD+ BABSR is available at
https://github.com/verivital/vnn-comp by replacing the dataset to the same one we used here.

Given an correctly classiﬁed image x with label yc, and another wrong label yc(cid:48) (cid:54)= yc (pre-deﬁned
in this benchmark) and (cid:15), the veriﬁer needs to prove:

(e(c) − e(c(cid:48)))T f (x(cid:48)) > 0

(10)
where f (·) is the logit-layer output of a multi-class classiﬁer, e(c) and e(c(cid:48)) are one-hot encoding
vectors for labels yc and yc(cid:48). We want to verify that for a given (cid:15), the trained classiﬁer will not
predict wrong label yc(cid:48) for image x. All properties including x, (cid:15), and c(cid:48) are provided by (Lu &
Kumar, 2020). Speciﬁcally, they categorize veriﬁcation properties solved by BABSR within 800s
as easy, between 800s and 2400s as medium and more than 2400s as hard.

(cid:107)x − x(cid:48)(cid:107)∞ ≤ (cid:15)

s.t ∀x(cid:48)

Our experiments are conducted on one Intel I7-7700K CPU and one Nvidia GTX 1080 Ti GPU. The
parallel batch size n is set to 400, 200 and 200 for base, wide and deep model respectively and the
η is set to 12,000 due to GPU memory constraint. To make a fair comparison, we use one CPU core
for all methods. Also, we use one GPU for GNN, GNN-ONLINE, BDD+ BABSR and our method.
When optimizing the LiRPA bounds, we apply 100 steps gradient decent for obtaining the initial f
(Line 2 in Algorithm 1). After that, we use 10 steps gradient decent (Line 7) and early stop once
f > 0 or f has no improvement.

C ABLATION STUDY

Our efﬁcient framework leverages two powerful components: (1) optimized LiRPA bounds and
(2) batch splits on GPUs. In this section, we conduct breakdown experiments to show how each
individual technique can help with complete veriﬁcation. As we can see in Table 2, using batched
split with unoptimized LiRPA is not very successful and cannot beat BABSR. We observe that,
without optimized LiRPA, the bounds are very loose and cannot quickly improve the global lower
bound. In contrast, using optimized LiRPA bounds without batch splits (splitting a single node at
a time and running a batch size of 1 on GPU) can still signiﬁcantly speed up complete veriﬁcation,
around 2 ∼ 10X compared to BABSR. Finally, combining batch splits and optimized LiRPA allows
us to gain up to 44X speedup compared to BABSR.

D COMPLETE VERIFICATION WITH LiRPA ON CPU VS GPU

For a fair comparison, we only use one CPU core and one GPU (the same as GNN and GNN-
ONLINE) in our experimental results in Section 4. In this section, we investigate the performance of

14

Table 2: Ablation study for different components of our algorithm. The speedup rate is computed based on
running time of BABSR baseline: speedup = Time of BaBSR/Time of our method.

Method

time(s)

speedup

time(s)

speedup

time(s)

speedup

time(s)

speedup

time(s)

speedup

Easy

Medium

Hard

Wide

Deep

BABSR baseline
Batch Splits (unoptimized LiRPA)
Optimized LiRPA (no batch splits)
Optimized LiRPA & Batch Splits

522.48
587.10
94.08
11.86

–
0.89
5.58
44.05

1335.40
1470.02
361.53
42.04

–
0.91
3.70
31.80

2875.16
3013.57
1384.22
633.85

–
0.95
2.07
4.53

3325.65
3457.30
736.56
375.23

–
0.96
4.51
8.86

2855.19
2998.50
287.33
81.55

–
0.95
9.94
35.01

our algorithm for the cases where one or multiple CPU cores are available without GPU accelera-
tion. Note that existing baselines such as BABSR and MIPPLANET can only effectively utilize one
CPU core subject to the Gurobi solver. GNN and GNN-ONLINE can utilize one GPU to run the
GNN during branching while the rest of the veriﬁcation processes all perform on one CPU core. In
contrast, our method is much more ﬂexible, and we are not limited by the number of CPU cores or
GPUs. When running on multi-core CPUs, LiRPA can be automatically accelerated by the underly-
ing linear algebra library (e.g., Intel MKL or OpenBLAS) since the main computation of LiRPA is
just matrix multiplications.

In Figure 5, we show the performance of our algorithm on a single CPU core and multiple CPU
cores (in blue), and compare it to our main results with one CPU core plus one GPU (in red). As
we can see, the running time decreases when the number of CPU cores increases, but the speedup
is not linear due to the limitation of the underlying linear algebra library and hardware. There is
a big gap between the running time on 8 CPU cores and the time on one CPU core + one GPU,
and the performance gap is more obvious on Wide and Deep models. Thus, the speedup of LiRPA
computation on GPUs is signiﬁcant. However, surprisingly, even when using only one CPU core,
we are still signiﬁcantly faster than baseline BABSR and also get very competitive performance
when compared to GNN-ONLINE which needs one GPU additionally. This shows the efﬁciency of
LiRPA based veriﬁcation algorithms.

Base Model (easy instances)
(BABSR: 522.48s)

Wide Model
(BABSR: 3325.65s)

Deep Model
(BABSR: 2855.19s)

Figure 5: Running time of our method on the Base, Wide, and Deep networks when using 1, 2, 4
and 8 CPU cores without a GPU (blue), and our method using 1 CPU core + 1 GPU (red) and a
strong baseline method, GNN-ONLINE (green). We report the baseline BABSR veriﬁcation time in
captions because they are out of range on the ﬁgures.

15

1248number of CPU core255075100125150175200time(s)n CPU core(s)One CPU core + one GPUGNN Online1248number of CPU core4006008001000120014001600time(s)n CPU core(s)One CPU core + one GPUGNN Online1248number of CPU core02505007501000125015001750time(s)n CPU core(s)One CPU core + one GPUGNN Online