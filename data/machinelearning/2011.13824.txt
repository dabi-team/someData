Fast and Complete: Enabling Complete Neural Network Veri-
ï¬cation with Rapid and Massively Parallel Incomplete Veriï¬ers

Kaidi Xu*,1

Huan Zhang*,2

Shiqi Wang3

Yihan Wang2

Suman Jana3

Xue Lin1
1Northeastern University 2UCLA 3Columbia University

Cho-Jui Hsieh2

1
2
0
2

r
a

M
6
1

]
I

A
.
s
c
[

2
v
4
2
8
3
1
.
1
1
0
2
:
v
i
X
r
a

xu.kaid@northeastern.edu, huan@huan-zhang.com, tcwangshiqi@cs.columbia.edu,
wangyihan617@gmail.com, suman@cs.columbia.edu, xue.lin@northeastern.edu,
chohsieh@cs.ucla.edu

ABSTRACT
Formal veriï¬cation of neural networks (NNs) is a challenging and important prob-
lem. Existing efï¬cient complete solvers typically require the branch-and-bound
(BaB) process, which splits the problem domain into sub-domains and solves each
sub-domain using faster but weaker incomplete veriï¬ers, such as Linear Program-
ming (LP) on linearly relaxed sub-domains. In this paper, we propose to use the
backward mode linear relaxation based perturbation analysis (LiRPA) to replace
LP during the BaB process, which can be efï¬ciently implemented on the typi-
cal machine learning accelerators such as GPUs and TPUs. However, unlike LP,
LiRPA when applied naively can produce much weaker bounds and even cannot
check certain conï¬‚icts of sub-domains during splitting, making the entire proce-
dure incomplete after BaB. To address these challenges, we apply a fast gradient
based bound tightening procedure combined with batch splits and the design of
minimal usage of LP bound procedure, enabling us to effectively use LiRPA on
the accelerator hardware for the challenging complete NN veriï¬cation problem
and signiï¬cantly outperform LP-based approaches. On a single GPU, we demon-
strate an order of magnitude speedup compared to existing LP-based approaches.

1

INTRODUCTION

Although neural networks (NNs) have achieved great success on various complicated tasks, they
remain susceptible to adversarial examples (Szegedy et al., 2013): imperceptible perturbations of
test samples might unexpectedly change the NN predictions. Therefore, it is crucial to conduct
formal veriï¬cation for NNs such that they can be adopted in safety or security-critical settings.

Formally, the neural network veriï¬cation problem can be cast into the following decision problem:

Given a neural network f (Â·), an input domain C, and a property P. âˆ€x âˆˆ C, does f (x) satisfy P?

The property P is typically a set of desirable outputs of the NN conditioned on the inputs. Typically,
consider a binary classiï¬er f (x) and a positive example x0 (f (x0) â‰¥ 0), we can set P to be non-
negative numbers R+ and x is bounded within an lâˆ norm ball C = {x|(cid:107)x âˆ’ x0(cid:107)âˆ â‰¤ (cid:15)}. The
success of veriï¬cation guarantees that the label of x0 cannot ï¬‚ip for any perturbed inputs within C.

In this paper we study the complete veriï¬cation setting, where given sufï¬cient time, the veriï¬er
should give a deï¬nite â€œyes/noâ€ answer for a property under veriï¬cation. In the above setting, it
must solve the non-convex optimization problem minxâˆˆC f (x) to a global minimum. Complete NN
veriï¬cation is generally a challenging NP-Hard problem (Katz et al., 2017) which usually requires
expensive formal veriï¬cation methods such as SMT (Katz et al., 2017) or MILP solvers (Tjeng
et al., 2019b). On the other hand, incomplete solvers such as convex relaxations of NNs (Salman
et al., 2019) can only provide a sound analysis, i.e., they can only approximate the lower bound of
minxâˆˆC f (x) as f and verify the property when f â‰¥ 0. No conclusion can be drawn when f < 0.
Recently, a Branch and Bound (BaB) style framework (Bunel et al., 2018; 2020b) has been adopted
for efï¬cient complete veriï¬cation. BaB solves the optimization problem minxâˆˆC f (x) to a global

* Equal Contribution.

1

 
 
 
 
 
 
minimum by branching into multiple sub-domains recursively and bounding the solution for each
sub-domain using incomplete veriï¬ers. BaB typically uses a Linear Programming (LP) bounding
procedure as an incomplete veriï¬er to provide feasibility checking and relatively tight bounds for
each sub-domain. However, the relatively high solving cost of LPs and incapability of paralleliza-
tion (especially on massively parallel hardware accelerators like GPUs or TPUs) greatly limit the
performance and scalability of the existing complete BaB based veriï¬ers.

In this paper, we aim to use fast and typically weak incomplete veriï¬ers for complete veriï¬cation.
Speciï¬cally, we focus on a class of incomplete veriï¬ers using efï¬cient bound propagation oper-
ations, referred to as linear relaxation based perturbation analysis (LiRPA) algorithms (Xu et al.,
2020). Representative algorithms in this class include convex outer adversarial polytope (Wong
& Kolter, 2018), CROWN (Zhang et al., 2018) and DeepPoly (Singh et al., 2019b). LiRPA algo-
rithms exhibit high parallelism as the bound propagation process is similar to forward or backward
propagation of NNs, which can fully exploit machine learning accelerators (e.g., GPUs and TPUs).

Although LiRPA bounds are very efï¬cient for incomplete veriï¬cation, especially in training certiï¬ed
adversarial defenses (Wong et al., 2018; Mirman et al., 2018; Wang et al., 2018a; Zhang et al., 2020),
they are generally considered too loose to be useful compared to LPs in the complete veriï¬cation
settings with BaB. As we will demonstrate later, using LiRPA bounds naively in BaB cannot even
guarantee the completeness when splitting ReLU nodes, and thus we need additional measures to
make them useful for complete veriï¬cation. In fact, LiRPA methods have been used to get upper and
lower bounds for each ReLU neuron in constructing tighter LPs (Bunel et al., 2018; Lu & Kumar,
2020). It was also used in (Wang et al., 2018c) for verifying small-scale problems with relatively low
dimensional input domains using input splits, but splitting the input space can be quite ineffective
(Bunel et al., 2018) and is unable to scale to high dimensional input case like CIFAR-10. Except
one concurrent work (Bunel et al., 2020a), most complete veriï¬ers are based on relatively expensive
solvers like LP and cannot fully take beneï¬t from massively parallel hardware (e.g., GPUs) to obtain
tight bounds for accelerating large-scale complete veriï¬cation problems. Our main contributions are:

â€¢ We show that LiRPA bounds, when improved with fast gradient optimizers, can potentially out-
perform bounds obtained by LP veriï¬ers. This is because LiRPA allows joint optimization of both
intermediate layer bounds of ReLU neurons (which determine the tightness of relaxation) and output
bounds, while LP can only optimize output bounds with ï¬xed relaxations on ReLU neurons.
â€¢ We show that BaB purely using LiRPA bounds is insufï¬cient for complete veriï¬cation due to the
lack of feasibility checking for ReLU node splits. To address this issue, we design our algorithm to
only invoke LP when absolutely necessary and exploits hardware parallelism when possible.
â€¢ To fully exploit the hardware parallelism on the machine learning accelerators, we use a batch
splitting approach that splits on multiple neurons simultaneously, further improving our efï¬ciency.
â€¢ On a few standard and representative benchmarks, our proposed NN veriï¬cation framework
can outperform previous baselines signiï¬cantly, with a speedup of around 30X compared to basic
BaB+LP baselines, and up to 3X compared to recent state-of-the-art complete veriï¬ers.

2 BACKGROUND

2.1 Formal deï¬nition of Neural network (NN) veriï¬cation

Notations of NN. For illustration, we deï¬ne an L-layer feedforward NN f : R|x| â†’ R with L
weights W(i) (i âˆˆ {1, Â· Â· Â· , L}) recursively as h(i)(x) = W(i)g(iâˆ’1)(x), hidden layer g(i)(x) =
ReLU(h(i)(x)), input layer g(0)(x) = x, and ï¬nal output f (x) = h(L)(x). For simplicity we ignore
biases. We sometimes omit x and use h(i)
to represent the pre-activation of the j-th ReLU neuron
j
in i-th layer for x âˆˆ C, and we use g(i)
to represent the post-activation value. We focus on verifying
j
ReLU based NNs, but our method is generalizable to other activation functions supported by LiRPA.

NN Veriï¬cation Problem. Given an input x, its bounded input domain C, and a feedforward NN
f (Â·), the aim of formal veriï¬cation is to prove or disprove certain properties P of NN outputs. Since
most properties studied in previous works can be expressed as a Boolean expression over a linear
equation of network output, where the linear property can be merged into the last layer weights of a
NN, the ultimate goal of complete veriï¬cation reduces to prove or disprove:

âˆ€x âˆˆ C, f (x) â‰¥ 0

(1)

2

One way to prove Eq. 1 is to solve minxâˆˆC f (x). Due to the non-convexity of NNs, ï¬nding the
exact minimum of f (x) over x âˆˆ C is challenging as the optimization process is generally NP-
complete (Katz et al., 2017). However, in practice, a sound approximation of the lower bound for
f (x), denoted as f , can be more easily obtained and is sufï¬cient to verify the property. Thus, a good
veriï¬cation strategy to get a tight approximation f can save signiï¬cant time cost. Note that f must
be sound, i.e., âˆ€x âˆˆ C, f â‰¤ f (x), proving f â‰¥ 0 is sufï¬cient to prove the property f (x) â‰¥ 0.

2.2 The Branch and Bound (BaB) framework for Neural Network Veriï¬cation

(cid:17)

(cid:16)

h(k)
j â‰¥ 0

Branch and Bound (BaB), an effective strategy in solving traditional combinatorial optimization
problems, has been customized and widely adopted for NN veriï¬cation (Bunel et al., 2018; 2020b).
Speciï¬cally, BaB based veriï¬cation framework is a recursive process, consisting of two main steps:
branching and bounding. For branching, BaB based methods will divide the bounded input domain
C into sub-domains {Ci|C = (cid:83)
i Ci}, each deï¬ned as a new independent veriï¬cation problem. For
j = ReLU(h(k)
instance, it can split a ReLU unit g(k)
) to be negative and positive cases as C0 =
(cid:17)
h(k)
for a ReLU-based network; for each sub-domain Ci,
C âˆ©
j < 0
BaB based methods perform bounding to obtain a relaxed but sound lower bound f
. A tightened
global lower bound over C can then be obtained by taking the minimum values of the sub-domain
lower bounds from all the sub-domains: f = mini f
. Branching and bounding will be performed
recursively to tighten the approximated global lower bound over C until either (1) the global lower
bound f becomes larger than 0 and prove the property or (2) a violation (e.g., adversarial example)
is located in a sub-domain to disprove the property. Essentially, we build a search tree where each
leaf is a sub-domain, and the property P can be proven only when it is valid on all leaves.

and C1 = C âˆ©

(cid:16)

Ci

Ci

j

Soundness of BaB We say the veriï¬cation process is sound if we can always trust the â€œyesâ€ (P
is veriï¬ed) answer given by the veriï¬er.
It is straightforward to see that the whole BaB based
veriï¬cation process is sound as long as the bounding method used for each sub-domain Ci is sound.

Completeness of BaB The completeness of the BaB-based NN veriï¬cation process, which was
usually assumed true in some previous works (Bunel et al., 2020b; 2018), in fact, is not always
true even if all possible sub-domains are considered with a sound bounding method. Additional
requirements for the bounding method are required - we point out that a key factor for completeness
involves feasibility checking in the bounding method which we will discuss in Section 3.2.

Branching in BaB Since branching step determines the shape of the search tree, the main chal-
lenge is to efï¬ciently choose a good leaf to split, which can signiï¬cantly reduce the total number of
branches and running time. In this work we focus on branching on activation (ReLU) nodes. BaBSR
(Bunel et al., 2018) includes a simple branching heuristic which assigns each ReLU node a score to
estimate the improvement for tightening f by splitting it, and splits the node with the highest score.

Bounding with Linear Programming (LP) A typical bounding method used in BaB based veri-
ï¬cation is the Linear Programming bounding procedure (sometimes simply referred to as â€œLPâ€ or
â€œLP veriï¬erâ€ in our paper). Speciï¬cally, we transform the original veriï¬cation problem into a linear
programming problem by relaxing every activation unit as a convex (linear) domain (Ehlers, 2017)
with a linear solver given domain Ci. For instance, as shown in
and then get the lower bound f
Figure 1a, g(i)
j â‰¥ h(i)
j ;

j ) can be linearly relaxed with the following 3 constraints: (1) g(i)

Ci

(h(i)

(2)g(i)

(i)
u
j â‰¥ 0; (3) g(i)
j
(i)
(i)
j âˆ’l
j
each activation node h(i)
j are required in the LP construction given Ci. They are typically computed
by the existing cheap bounding methods like LiRPA variants (Wong & Kolter, 2018) with low cost.
The tighter the intermediate bounds (l(i)

j ). Note that the lower bound l(i)

j ) are, the tighter f approximated by LP is.

and upper bound u(i)
j

j , u(i)

j âˆ’ l(i)

for

u

j

j = ReLU(h(i)
j â‰¤

2.3 Linear Relaxation based Perturbation Analysis (LiRPA)

Bound propagation in LiRPA We used Linear Relaxation based Perturbation Analysis (LiRPA)1
as bound procedure in BaB to get linear upper and lower bounds of NN output w.r.t input x âˆˆ C:

Ax + b â‰¤ f (x) â‰¤ Ax + b,

x âˆˆ C

(2)

1We only use the backward mode LiRPA bounds (e.g., CROWN and DeepPoly) in this paper.

3

Figure 1: Relaxations of a ReLU: (a) â€œtriangleâ€ relaxation in LP; (b)(c) No relaxation when u(i)
inactive) or l(i)

j â‰¥ 0 (always active); (d) linear relaxation in LiRPA when l(i)

j < 0, u(i)

j > 0 (unstable).

j â‰¤ 0 (always

A lower bound f can then be simply obtained by taking the lower bound of the linear equation
Ax + b w.r.t input x âˆˆ C, which can be obtained via HÂ¨olderâ€™s inequality when C is a (cid:96)p norm ball.

To get the coefï¬cients A, A, b, b, LiRPA propagates bounds of f (x) as a linear function to the
output of each layer, in a backward manner. At the output layer h(L)(x) we simply have:
Ih(L)(x) â‰¤ f (x) â‰¤ Ih(L)(x),

(3)
Then, the next step is to backward propagate the identity linear relationship through a linear layer
h(L)(x) = W(L)g(Lâˆ’1)(x) to get the linear bounds of f (x) w.r.t g(Lâˆ’1):

x âˆˆ C

x âˆˆ C

W(L)g(Lâˆ’1)(x) â‰¤ f (x) â‰¤ W(L)g(Lâˆ’1)(x),

(4)
To get the linear relationship of h(Lâˆ’1) w.r.t f (x), we need to backward propagate through ReLU
layer g(Lâˆ’1)(x) = ReLU(h(Lâˆ’1)(x)). Since it is nonlinear, we perform linear relaxations. For
illustration, considering the j-th ReLU neuron at i-th layer, g(i)
j (x)), we can
(i)
linearly upper and lower bound it by a(i)
j â‰¤ g(i)
j , where
(i)
j , a(i)
j , b(i)
a(i)
j , b
j are:
ï£±
j = 0, b(i)
j = a(i)
a(i)
ï£´ï£´ï£´ï£²
j = 1, b(i)
a(i)
j = a(i)
ï£´ï£´ï£´ï£³
j = Î±(i)
j , a(i)
a(i)
j =

u(i)
j â‰¤ 0 (always inactive for x âˆˆ C)
l(i)
j â‰¥ 0
j < 0, u(i)
l(i)

j (x) = ReLU(h(i)
j (x) â‰¤ a(i)

(i)
j = 0
(i)
j = 0
, b(i)

j > 0 (unstable for x âˆˆ C)

(always active for x âˆˆ C)

j = b
j = b
u

j (x) + b(i)

j (x) + b

(i)
j = âˆ’

j = 0, b

j h(i)

j h(i)

(5)

u

(i)
(i)
j l
j
(i)
(i)
j âˆ’l
j

u

(i)
j
(i)
(i)
j âˆ’l
j

u

j â‰¤ h(i)

j (x) â‰¤ u(i)

j are intermediate pre-activation bounds for x âˆˆ C, and Î±(i)

Here l(i)
is an arbitrary
value between 0 and 1. The pre-activation bounds l(i)
j (x)
as the output neuron with LiRPA. Figure 1(b,c,d) illustrate the relaxation for each state of ReLU
neuron. With these linear relaxations, we can get the linear equation of h(Lâˆ’1) w.r.t output f (x):

j can be computed by treating h(i)

j and u(i)

j

h(Lâˆ’1)(x) + b(L) â‰¤ f (x) â‰¤ W(L)D

(Lâˆ’1)
Î±

W(L)D(Lâˆ’1)
(cid:40)

Î±
a(L)
j
a(L)
j

h(Lâˆ’1)(x) + b
(cid:40)

(L)

,
b(L)
j
(L)
b
j

x âˆˆ C
, W(L)
, W(L)

D(L)

Î±,(j,j) =

j â‰¥ 0
j < 0
, D

, b(L) = b(cid:48)(L)(cid:62)W(L), where b(cid:48)(L)

, W(L)
, W(L)
The diagonal matrices D(Lâˆ’1)
and biases reï¬‚ects the linear relaxations and also considers
the signs in W(L) to maintain the lower and upper bounds. The deï¬nitions for j-th diagonal element
(L)
D
Î±,(j,j) and bias b
swapped.
Importantly, D(Lâˆ’1)
j âˆˆ [0, 1] which do not affect correctness of the bounds.
We can continue backward propagating these bounds layer by layer (e.g., g(Lâˆ’2)(x), h(Lâˆ’2)(x),
etc) until reaching g(0)(x) = x, getting the eventual linear equations of f (x) in terms of input x:

are similar, with the conditions for checking the signs of W(L)

has free variables Î±(i)

j â‰¥ 0
j < 0

(Lâˆ’1)
Î±

j =

(L)

Î±

Î±

j

(6)

L(x, Î±) â‰¤ f (x) â‰¤ U(x, Î±),

âˆ€x âˆˆ C, where

L(x, Î±) = W(L)D(Lâˆ’1)

Î±

Â· Â· Â· D(1)

Î± W(1)x + b, U(x, Î±) = W(L)D

(Lâˆ’1)
Î±

Â· Â· Â· D

(1)
Î± W(1)x + b

Here Î± denotes Î±(i)
for all unstable ReLU neurons in NN. The obtained bounds (L(x, Î±), U(x, Î±))
j
of f (x) are linear functions in terms of x. Beyond the simple feedforward NN presented here, LiRPA
can support more complicated NN architectures like DenseNet and Transformers by computing L
and U automatically and efï¬ciently on general computational graphs (Xu et al., 2020).

(7)

Soundness of LiRPA The above backward bound propagation process guarantees that L(x, Î±) and
U(x, Î±) soundly bound f (x) for all x âˆˆ C. Detailed proofs can be found in (Zhang et al., 2018;
Singh et al., 2019b) for feedforward NNs and (Xu et al., 2020) for general networks.

4

l(i)ju(i)jx(i)jh(i)jl(i)ju(i)jh(i)jl(i)ju(i)jh(i)jl(i)ju(i)jh(i)jl(i)ju(i)jh(i)j(a)(b)(c)(d)Figure 2: Illustration of our optimized LiRPA bounds and the BaB process. Given a two-layer neural network,
we aim to verify output f (x) â‰¥ 0. Optimized LiRPA chooses optimized slopes for ReLU lower bounds,
allowing tightening the intermediate layer bounds l(i)
and also the output layer lower bound f . BaB
j
splits two unstable neurons h(2)

to improve f and verify all sub-domains (f â‰¥ 0 for all cases).

and u(i)
j

and h(2)

1
3 PROPOSED ALGORITHM

2

Overview In this section, we will ï¬rst introduce our proposed efï¬cient optimization of LiRPA
bounds on GPUs that can allow us to achieve tight approximation on par with LP or even tighter for
some cases but in a much faster manner. In Fig. 2, we provide a two-layer NN example to illustrate
how our optimized LiRPA can improve the performance of BaB veriï¬cation. In Section 3.2, we
then show that feasibility checking is important to guarantee the completeness of BaB, and BaB
using LiRPA without feasibility checking will end up to be incomplete. To ensure completeness,
we design our algorithm with minimal usage of LP for checking feasibility of splits. Finally, we
propose a batch split design by solving a batch of sub-domains in a massively parallel manner on
GPUs to fully leverage the beneï¬ts of cheap and parallelizable LiRPA. We further improve BaBSR
in a parallel fashion for branching and we summarize the detailed proposed algorithm in Section 3.4.

3.1 Optimized LiRPA for Complete Veriï¬cation

Concrete outer bounds with optimizable parameters We propose to use LiRPA as the bounding
step in BaB. A pair of sound and concrete lower bound and upper bound (f , f ) to f (x) can be
obtained according to Eq. 7 given ï¬xed Î± = Î±0:

f (Î±0) = min
xâˆˆC

L(x, Î±0),

f (Î±0) = max
xâˆˆC

U(x, Î±0)

(8)

Because L, U are linear functions w.r.t x when Î±0 is ï¬xed, it is easy to solve Eq. 8 using HÂ¨olderâ€™s
inequality when C is a (cid:96)p norm ball (Xu et al., 2020). In incomplete veriï¬cation settings, Î± can be
set via certain heuristics (Zhang et al., 2018). Salman et al. (2019) showed that, the variable Î± is
equivalent to dual variables in the LP relaxed veriï¬cation problem (Wong & Kolter, 2018). Thus, an
optimal selection of Î± given the same pre-activation bounds l(i)
j can in fact, lead to the the
same optimal solution for f and f as in LP.

j and u(i)

Previous complete veriï¬ers typically use LiRPA variants to obtain intermediate layer bounds to
construct an LP problem (Bunel et al. (2018); Lu & Kumar (2020)) and solve the LP to obtain
bounds at output layer. The main reason for using LP is that it typically produces much tighter
bounds than LiRPA when Î± is not optimized. We use optimized LiRPA, which is fast, accelerator-
friendly, and can produce tighter bounds, well outperforming LP for complete veriï¬cation:

f = min

L(x, Î±),

f = max

min
xâˆˆC

max
xâˆˆC

U(x, Î±), Î±(i)

j âˆˆ [0, 1]

Î±

Î±
The inner minimization or maximization has closed form solutions (Xu et al., 2020) based on
HÂ¨olderâ€™s inequality, so we only need to optimize on Î±. Since we use a differentiable framework (Xu
et al., 2020) to compute the LiRPA bound functions L and U, the gradients âˆ‚L
âˆ‚Î± can be
obtained easily. Optimization over Î± can be done via projected gradient descent (each coordinate of
Î± is constrained in [0, 1]). Since the gradient computation and optimization are done on GPUs, the
bounding process is still very fast and can be one or two magnitudes faster than solving an LP.

âˆ‚Î± and âˆ‚U

(9)

Optimized LiRPA bounds can be tighter than LP Solving Eq. 9 using gradient descent cannot
guarantee to converge to the global optima, so it seems the bounds must be looser than LP. Counter-
intuitively, by optimizing Î±, we can potentially obtain tighter bounds than LP. When a â€œtriangleâ€

5

ğ‘¥1ğ‘¥2Î£Î£Î£Always Active:ğ’ğ‘—(ğ‘–)â‰¥0AlwaysInactive: ğ’–ğ‘—(ğ‘–)â‰¤0Linear relaxed Unstable neuron:ğ’ğ‘—(ğ‘–)<0, ğ’–ğ‘—(ğ‘–)>0Î£Î£Î£ğ‘“(ğ‘¥)â„1(1)â„2(1)â„3(1)ğ‘¥1ğ‘¥2Î£Î£Î£Î£Î£Î£ğ‘“(ğ‘¥)Unoptimized LiRPA: lower bound ğ‘“=âˆ’1.94Optimized LiRPA: lower bound ğ‘“=âˆ’0.83Prove: ğ‘“ğ‘¥â‰¥0,âˆ€ğ‘¥âˆˆğ’â„1(2)â„2(2)â„3(2)â„1(1)â„2(1)â„3(1)â„1(2)â„2(2)â„3(2)Split â„2(2)Pick â„1(2)Splitâ„1(2)Pick â„2(2)ğ‘“=âˆ’0.15ğ‘“=0.17âœ“ğ‘“=0.25âœ“ğ‘“=0.31âœ“ReLULower bound by Optimized LiRPAExample: Optimized LiRPA for â„1(2)tigher ğ‘™1(2)and ğ‘¢1(2)make tighter relaxationExample: BaBto find tighter lower boundğ‘™1(2)ğ‘¢1(2)ğ‘™1(2)ğ‘¢1(2)j , u(i)

relaxation is constructed for LP, intermediate pre-activation bounds l(i)
j must be ï¬xed for the
j-th ReLU in layer i. During the LP optimization process, only the output bounds are optimized;
intermediate bounds stay unchanged. However, in the LiRPA formulation, L(x, Î±) and U(x, Î±) are
complex functions of Î±: since intermediate bounds are also computed by LiRPA, they depend on all
Î±(i(cid:48))
j(cid:48) (0 < i(cid:48) < i) in previous layers. Thus, the gradients âˆ‚L
âˆ‚Î± can tighten output layer bounds
f and f indirectly by tightening intermediate layer bounds, forming a tighter convex relaxation for
the next iteration. An LP solver cannot achieve this because adding l(i)
as optimization
j
variables makes the problem non-linear. This is the key to our success of applying LiRPA based
bounds for the complete veriï¬cation setting, where tighter bounds are essential.

âˆ‚Î± and âˆ‚U

and u(i)
j

In Figure 3, we illustrate our optimized LiRPA bounds and
the LP solution. Initially, we use LiRPA with Î± set via a fast
and u(i)
heuristic to compute intermediate layer bounds l(i)
j ,
j
and then use them to build a relaxed LP problem. The solution
to this initial LP problem (red line) is much tighter than the
LiRPA solution with the heuristically set Î± (the left-most point
of the blue line). Then, we optimize Î± with gradient decent,
and LiRPA quickly outperforms this initial LP solution due to
optimized tighter intermediate layer bounds. We can create a
new LP with optimized intermediate bounds (light blue line),
producing a slightly tighter bound than LiRPA with optimized
Î±. The LP bounds in most existing complete veriï¬ers all use
intermediate layer bounds obtained from unoptimized LiRPA bounds or even weaker methods like
interval arithmetic, ending up to the solution close to or lower than the red line in Figure 3. In-
stead, our optimized LiRPA bounds can produce tight bounds, and also exploit parallel acceleration
from machine learning accelerators, leading to huge improvements in veriï¬cation time compared to
existing baselines.

Figure 3: Optimized LiRPA bound (0
to 200 iterations) vs LP bounds.

j â‰¥ 0 and h(i)

ReLU Split Constraints In the BaB process, when a ReLU h(i)
is split into two sub-domains
j
(h(i)
j < 0 in bounding step. It tighten the
LiRPA bounds by forcing the split ReLU linear, reducing relaxation errors. However, when splits
are added, LiRPA and LP are not equivalent even under ï¬xed l(i)
and optimal Î±. After splits,
LiRPA cannot check certain constraints where LP is capable to, as we will discuss in the next section.

j < 0), we simply set l(i)

j â‰¥ 0 and u(i)

j , u(i)

j

3.2 Completeness with Minimal Usage of LP Bounding Procedure

Even though our optimized LiRPA can bring us huge speed improvement over LP for BaB based
veriï¬cation, we observe that it may end up to be incomplete due to the lack of feasibility checking: it
cannot detect some conï¬‚icting settings of ReLU splits. We state such an observation in Theorem 3.1:

Theorem 3.1 (Incompleteness without feasibility checking) When using LiRPA variants de-
scribed in Section 2.3 as the bounding procedure, BaB based veriï¬cation is incomplete.

< 0) âˆ© (h(i2)
j2

We prove the theorem by giving a counter-example in Appendix A.1 where all ReLU neurons are
split and thus LiRPA runs on a linear network for each sub-domain. As a result, LiRPA can still
be indecisive for the veriï¬cation problem. The main reason is that LiRPA variants will lose the
feasibility information encoded by the sub-domain constraints. For illustration, consider a sub-
domain Ci = C âˆ© (h(i1)
(x) = 0 (inactive ReLU, a zero
j1
function) and g(i2)
these bounds to get the approximated lower bound f
< 0) âˆ© (h(i2)
(h(i1)
j2
j1
h(i2)
cannot be â‰¥ 0). On the contrary, LP can fully preserve such feasibility information due to the
j2
linear solver involved and detect the infeasible sub-domains. Then, in Theorem 3.2 we show that the
minimal usage of feasibility checking with LP can guarantee the completeness of BaB with LiRPA.

j1
(x) (active ReLU, an identity function) respectively and propagate
. However, the split feasibility constraint

â‰¥ 0) is ignored, so two conï¬‚ict splits may be conducted (e.g., when h(i1)
j1

â‰¥ 0), LiRPA will force g(i1)

(x) = h(i2)
j2

< 0,

Ci

j2

6

050100150200iteration12108642lower boundLP initial boundoptimized LiRPA boundLP optimized boundAlgorithm 1 Parallel BaB with optimized LiRPA bounding (we highlight the differences between
our algorithm and regular BaB (Bunel et al., 2018) in blue. Comments are in brown.)

(cid:46) P is the set of all unveriï¬ed sub-domains

1: Inputs: f , C, n (batch size), Î· (threshold to switch to LP)
2: (f , f ) â† optimized LiRPA(f, [C])
3: P â† (cid:2)(f , f , C)(cid:3)
4: while f < 0 and f â‰¥ 0 do
5:
6:

(C1, . . . , Cn) â† batch pick out(P, n)
(cid:2)Cl
1, Cu
(cid:104)
f

(cid:3) â† batch split(C1, . . . , Cn) (cid:46) Each Ci splits into two sub-domains Cl
n, Cu
, . . . , f
n

(cid:46) Pick sub-domains to split and removed them from P
i and Cu
i
(cid:3))
(cid:46)

â† optimized LiRPA(f, (cid:2)Cl

1 , . . . , Cl
, f
, f Cl

n, Cu
n
, f Cu

1 , . . . , Cl

1, Cu

, f Cu

, f Cl

, f

(cid:105)

Cl
1

Cu
1

1

1

Cu
n
Compute lower and upper bounds using LiRPA for each sub-domain on GPUs in a batch
, Cl

P â† P (cid:83) Domain Filter

[f
Filter out veriï¬ed sub-domains, insert the left domains back to P

1 ], . . . , [f

, f Cu

n], [f

, f C1

1], [f

, f Cl

, Cu

, Cl

Cu
1

Cl
n

Cl
n

Cl
1

Cu
n

(cid:16)

n

n

n

1

1

(cid:17)

, Cu
n]

, f Cu

n

(cid:46)

(cid:46) To ease notation, Ci here indicates both Cu

i and Cl
i

, Ci) âˆˆ P}, i = 1, . . . , n
, Ci) âˆˆ P}, i = 1, . . . , n

| (f
Ci
| (f Ci

f â† min{f
Ci
f â† min{f Ci
if length(P) > Î· then
, f Cu
, f Cl

, f

f

(cid:104)

, . . . , f

1

Cl
1

Cu
1
P â† P (cid:83) Domain Filter

1

Cl
n
(cid:16)

[f

, f Cl

n

, f

, f Cu

n

,

Cu
n

(cid:105)

â† compute bound LP(f, (cid:2)Cl

(cid:46) Fall back to LP for completeness
(cid:3))
1, Cu
n, Cu
n
(cid:17)

1 , . . . , Cl

, f C1

n

Cl
n

, Cl

n], [f

, f Cu

n

, Cu
n]

Cu
n

, f Cl

1

Cl
1

, Cl

1], [f

, f Cu

1

Cu
1

, Cu

1 ], . . . , [f

7:

8:

9:

10:
11:

12:

13:

14: Outputs: f , f

Theorem 3.2 (Minimal feasibility checking for completeness) When using LiRPA variants de-
scribed in Section 2.3 as the bounding procedure, BaB based veriï¬cation is complete if all infeasible
leaf sub-domains (i.e., sub-domains cannot be further split) are detected by linear programming.

We prove the theorem in Appendix A.2, where we show that by checking the feasibility of splits
with LP, we can eliminate the cases where incompatible splits are chosen in the LiRPA BaB process.
Since LP is slow while LiRPA is highly efï¬cient, we propose to only use LP when the LiRPA based
bounding process is stuck, either (1) when partitioning and bounding new sub-domains with LiRPA
cannot further improve the bounds, or (2) when all unstable neurons have been split. In this way, the
infeasible sub-domains can be eventually detected by occasional usage of LP while the advantage of
massive parallel LiRPA on GPUs is fully enjoyed. We will describe our full algorithm in Sec. 3.4.

3.3 Batch Splits
SOTA BaB methods (Bunel et al., 2020b; Lu & Kumar, 2020) only split one sub-domain during
each branching step. Since we use cheap and GPU-friendly LiRPA bounds, we can select a batch of
sub-domains to split and propagate their LiRPA bounds in a batch. Such a batch splitting design can
greatly improve hardware efï¬ciency on GPUs. Given a batch size n that allows us to fully use the
GPU memory available, we can obtain n bounds simultaneously. It grows the search tree on a single
leaf by a depth of log2 n, or split n/2 leaf nodes at the same time, accelerating by up to n times.

3.4 Our Complete Veriï¬cation Framework
Our LiRPA based complete veriï¬cation framework is presented in Alg. 1. The algorithm takes a
target NN function f and a domain C as inputs. We run optimized LiRPA to get initial bounds
(f , f ) for x âˆˆ C (Line 2). Then we utilize the power of GPUs to split in parallel and maintain
a global set P storing all the sub-domains which cannot be veriï¬ed with optimized LiRPA (Line
5-10). Speciï¬cally, batch pick out improves BaBSR (Bunel et al., 2018) in a parallel manner to
select n sub-domains in P and determine the corresponding ReLU neuron to split for each of them. If
the length of P is less than n, then we reduce n to the length of P. batch split splits each selected
Ci to two sub-domains Cl
i by forcing the selected unstable ReLU neuron to be positive and
negative, respectively. optimize LiRPA runs optimized LiRPA in parallel as a batch and returns
the lower and upper bounds for n selected sub-domains simultaneously. Domain Filter ï¬lters out
â‰¥ 0) and we insert the remaining ones to P. The loop breaks
veriï¬ed sub-domains (proved with f

i and Cu

Ci

if the property is proved (f â‰¥ 0) or a counter-example is found in any sub-domain (f < 0).

To avoid excessive splits, we set the maximum length of the sub-domains to Î· (Line 12). Once the
length of P reaches this threshold, compute bound LP will be called. It solves these Î· sub-domains
by LP (one by one in a loop, or in parallel if using multiple CPUs is allowed) with optimized LiRPA

7

computed intermediate layer bounds. If a sub-domain Ci âˆˆ P (which previously cannot be veriï¬ed
by LiRPA) is proved or detected to be infeasible by LP, as an effective heuristic, we will backtrack
and prioritize to check its parent node with LP. If the parent sub-domain is also proved or infeasible,
we can prune all its child nodes to greatly reduce the size of the search tree.

Completeness of our framework Our algorithm is complete, because we follow Theorem 3.2 and
check feasibility of all split sub-domains that have deep BaB search tree depth (length of P reaches
threshold Î·), forming a superset of the worst case where all ReLU neurons are split.

4 EXPERIMENTS

In this section, we compare our veriï¬er against the state-of-the-art ones to illustrate the effectiveness
of our proposed framework. Overall, our veriï¬er is about 10X, 4X and 20X faster than the best
LP-based veriï¬er (Lu & Kumar, 2020) on the Base, Wide and Deep models, respectively.

Setup We follow the most challenging experimental setup used in the state-of-the-art veriï¬ers
GNN-ONLINE (Lu & Kumar, 2020) and BABSR (Bunel et al., 2020b). Speciï¬cally, we evalu-
ate on CIFAR10 dataset on three NNs: Base, Wide and Deep. The dataset is categorized into
three difï¬culty levels: Easy, Medium, and Hard, which is generated according to the performance
of BaBSR. The veriï¬cation task is deï¬ned as given a lâˆ norm perturbation less than (cid:15), the clas-
siï¬er will not predict a speciï¬c (predeï¬ned) wrong label for each image x (see Appendix B).
We set batch size n = 400, 200, 200 for Base, Wide and Deep model respectively and threshold
Î· = 12000. More details on experimental setup are provided in Appendix B. Our code is available
at https://github.com/kaidixu/LiRPA Verify.

Comparisons against state-of-the-art veriï¬ers We include ï¬ve different methods for comparison:
(1) BABSR (Bunel et al., 2020b), a BaB and LP based veriï¬er using a simple ReLU split heuristic;
(2) MIPPLANET (Ehlers, 2017), a customized MIP solver for NN veriï¬cation where unstable ReLU
neurons are randomly selected for split; (3) GNN (Lu & Kumar, 2020) and (4) GNN-ONLINE (Lu
& Kumar, 2020) are BaB and LP based veriï¬ers using a learned graph neural network (GNN) to
guide the ReLU split. (5) BDD+ BABSR (Bunel et al., 2020a) is a very recently proposed veriï¬ca-
tion framework based on Lagrangian decomposition which also supports GPU acceleration without
solving LPs. All methods use 1 CPU with 1 GPU. The timeout threshold is 3,600 seconds.

For the Base model in different difï¬culty levels, Easy, Medium and Hard, Table 1 shows that we are
around 5 âˆ¼ 40X faster than baseline BaBSR and around 2 âˆ¼ 20X faster than GNN split baselines.
The accumulative solved properties with increasing runtime are shown in Figure 4. In all our exper-
iments, we use the basic heuristic in BaBSR for branching and do not use GNNs, so our speedup
comes purely from the faster LiRPA based bounding procedure. We are also competitive against
Lagrangian decomposition on GPUs.
Table 1: Performance of various methods on different models. We compare each methodâ€™s avg. solving time,
the avg. number of branches required, and the percentage of timed out (TO) properties.

Base - Easy

Base - Medium

Base - Hard

Wide

Deep

Method

time(s)

branches %TO time(s)

branches %TO time(s)

branches %TO time(s)

branches %TO time(s)

branches %TO

BABSR
MIPPLANET
GNN
GNN-ONLINE
BDD+ BABSR
OURS

522.5
1462.2
312.9
207.43
15.68
11.86

585
-
301
269
1371
2589

0.0
16.5
0.0
0.0
0.0
0.0

1335.4
1912.2
624.1
638.15
51.88
42.04

1471
-
635
546
6482
9233

0.0
43.5
0.9
0.4
0.4
0.0

2875.2
2172.2
1468.7
1255.4
627.96
633.85

1843
-
931
968
91880
96755

35.2
46.2
15.6
15.6
13.4
13.0

3325.7
3088.4
1791.5
1642.0
510.55
375.23

455
-
375
389
45855
53481

50.3
79.4
19.0
19.0
11.4
8.5

2855.2
2842.5
1870.6
1845.7
230.06
81.55

365
-
198
196
6721
1439

54.0
73.6
18.4
18.4
4.4
1.6

Figure 4: Cactus plots for our method and other baselines in Base (Easy, Medium and Hard ), Wide and Deep
models. We plot the percentage of solved properties with growing running time.

(a) Base-Easy

(b) Base-Medium (c) Base-Hard

(d) Wide

(e) Deep

Performance on Larger Models In Table 1, we show that our veriï¬er is more scalable on larger
(wider or deeper) NNs compared to other state-of-the-art veriï¬ers. Our method enjoys efï¬cient GPU
acceleration particularly on Deep model and can achieve 30X speedup compared to BABSR, and we

8

100101102103Running time (in s)020406080100% of properties verifiedBaBSRMIPplanetGNNGNN-OnlineProx. BaBSROurs100101102103Running time (in s)020406080100100101102103Running time (in s)020406080100100101102103Running time (in s)020406080100100101102103Running time (in s)020406080100are also signiï¬cantly faster than Lagrangian decomposition based GPU veriï¬er (BDD+ BABSR).
When compared to the state-of-the-art LP based BaB, GNN-ONLINE, our method can save 20X
running time on Deep model. In Appendix C, we analyze the effectiveness of optimized LiRPA and
batch splits separately, and ï¬nd that optimized LiRPA is crucial for NN veriï¬cation. Performance
comparisons of our proposed framework on CPU cores without GPU acceleration are included in
Appendix D.

5 RELATED WORK

Complete veriï¬ers Early complete veriï¬ers rely on satisï¬ability modulo theory (SMT) (Katz et al.,
2017; Huang et al., 2017; Ehlers, 2017) and mixed integer linear programming (MILP) (Tjeng et al.,
2019a; Dutta et al., 2018), and they typically do not scale well. Higher order logic provers such
as proof assistant (Bentkamp et al., 2018) can also be potentially used for NN veriï¬cation, but
their scalability to the NN setting has not been demonstrated. Recently, Bunel et al. (2018) uniï¬ed
many approaches used in various complete veriï¬ers into a BaB framework. An LP based bounding
procedure is used in most of the existing BaB framework (Bunel et al., 2018; Wang et al., 2018c;
Royo et al., 2019; Lu & Kumar, 2020). For branching, two categories of branching strategies were
proposed: (1) input node branching (Wang et al., 2018c; Bunel et al., 2020b; Royo et al., 2019;
Anderson et al., 2019) where input features are divided into sub-domains, and (2) activation node
(especially, ReLU) branching (Katz et al., 2017; Bunel et al., 2018; Wang et al., 2018b; Ehlers, 2017;
Lu & Kumar, 2020) where hidden layer activations are split into sub-domains. Bunel et al. (2018)
found that input node branching cost is exponential to input dimension. Thus, many state-of-the-art
veriï¬ers use activation node branching instead, focusing on heuristics to select good nodes to split.
BaBSR (Bunel et al., 2018) prioritizes ReLUs for splitting based on their pre-activation bounds; Lu
& Kumar (2020) used a graph neural network (GNN) to learn good splitting heuristics. Our work
focuses on improving bounding and can use better branching heuristics to achieve further speedup.

(1)
Two mostly relevant concurrent works using GPUs for accelerating NN veriï¬cation are:
GPUPoly (MÂ¨uller et al., 2020), an extension of DeepPoly on CUDA, is still an incomplete veriï¬er.
Also, it is implemented in CUDA C++, requiring manual effort for customization and gradient com-
putation, so it is not easy to get the gradients for optimizing bounds as we have done in Section 3.1.
(2) Lagrangian Decomposition (Bunel et al., 2020a) is a GPU-accelerated BaB based complete ver-
iï¬er that iteratively tightens the bounds based on a Lagrangian decomposition optimization formu-
lation and does not reply on LP. However, it solves a much more complicated optimization problem
than LiRPA, and typically requires hundreds of iterations to converge for a single sub-domain.

Incomplete veriï¬ers Many incomplete veriï¬cation methods rely on convex relaxations of NN,
replacing nonlinear activations like ReLUs with linear constraints (Wong & Kolter, 2018; Wang
et al., 2018b; Zhang et al., 2018; Weng et al., 2018; Gehr et al., 2018; Singh et al., 2018a;b; 2019b;a)
or semideï¬nite constraints (Raghunathan et al., 2018; Dvijotham et al., 2020; Dathathri et al., 2020).
Tightening the relaxation for incomplete veriï¬cation was discussed in (Dvijotham et al., 2018; Singh
et al., 2019a; Lyu et al., 2019; Tjandraatmadja et al., 2020). Typically, tight relaxations require
more computation and memory in general. We refer the readers to (Salman et al., 2019) for a
comprehensive survey. Recently, Xu et al. (2020) categorized the family of linear relaxation based
incomplete veriï¬ers into LiRPA framework, allowing efï¬cient implementation on machine learning
accelerators. Our work uses LiRPA as the bounding procedure for complete veriï¬cation and exploits
its computational efï¬ciency to accelerate, and our main contribution is to show that we can use fast
but weak incomplete veriï¬ers as the main driver for complete veriï¬cation when strategically applied.

6 CONCLUSION

We use a LiRPA based incomplete NN veriï¬er to accelerate the bounding procedure in branch and
bound (BaB) for complete NN veriï¬cation on massively parallel accelerators. We use a fast gradient
based procedure to tighten LiRPA bounds. We study the completeness of BaB with LiRPA, and
show up to 5X speedup compared to state-of-the-art veriï¬ers across multiple models and properties.

ACKNOWLEDGMENTS

This work is supported by NSF grant CNS18-01426; an ARL Young Investigator (YIP) award; an
NSF CAREER award; a Google Faculty Fellowship; a Capital One Research Grant; and a J.P. Mor-

9

gan Faculty Award; Air Force Research Laboratory under FA8750-18-2-0058; NSF IIS-1901527,
NSF IIS-2008173 and NSF CAREER-2048280.

REFERENCES

Greg Anderson, Shankara Pailoor, Isil Dillig, and Swarat Chaudhuri. Optimization and abstraction:
In Proceedings of the 40th
A synergistic approach for analyzing neural network robustness.
ACM SIGPLAN Conference on Programming Language Design and Implementation, pp. 731â€“
744, 2019.

Alexander Bentkamp, Jasmin Christian Blanchette, Simon Cruanes, and Uwe Waldmann. Super-
In International Joint Conference on Automated

position for lambda-free higher-order logic.
Reasoning, pp. 28â€“46. Springer, 2018.

Rudy Bunel, Alessandro De Palma, Alban Desmaison, Krishnamurthy Dvijotham, Pushmeet Kohli,
Philip H. S. Torr, and M. Pawan Kumar. Lagrangian decomposition for neural network veriï¬ca-
tion. Conference on Uncertainty in Artiï¬cial Intelligence (UAI) 2020, 2020a.

Rudy Bunel, Jingyue Lu, Ilker Turkaslan, P Kohli, P Torr, and P Mudigonda. Branch and bound for
piecewise linear neural network veriï¬cation. Journal of Machine Learning Research, 21(2020),
2020b.

Rudy R Bunel, Ilker Turkaslan, Philip Torr, Pushmeet Kohli, and Pawan K Mudigonda. A uniï¬ed
view of piecewise linear neural network veriï¬cation. In Advances in Neural Information Process-
ing Systems, pp. 4790â€“4799, 2018.

Sumanth Dathathri, Krishnamurthy Dvijotham, Alexey Kurakin, Aditi Raghunathan, Jonathan Ue-
sato, Rudy R Bunel, Shreya Shankar, Jacob Steinhardt, Ian Goodfellow, Percy S Liang, et al.
Enabling certiï¬cation of veriï¬cation-agnostic networks via memory-efï¬cient semideï¬nite pro-
gramming. Advances in Neural Information Processing Systems, 33, 2020.

Souradeep Dutta, Susmit Jha, Sriram Sankaranarayanan, and Ashish Tiwari. Output range analy-
sis for deep feedforward neural networks. In NASA Formal Methods Symposium, pp. 121â€“138.
Springer, 2018.

Krishnamurthy Dvijotham, Sven Gowal, Robert Stanforth, Relja Arandjelovic, Brendan
Oâ€™Donoghue, Jonathan Uesato, and Pushmeet Kohli. Training veriï¬ed learners with learned ver-
iï¬ers. arXiv preprint arXiv:1805.10265, 2018.

Krishnamurthy Dj Dvijotham, Robert Stanforth, Sven Gowal, Chongli Qin, Soham De, and Push-
meet Kohli. Efï¬cient neural network veriï¬cation with exactness characterization. In Uncertainty
in Artiï¬cial Intelligence, pp. 497â€“507. PMLR, 2020.

Ruediger Ehlers. Formal veriï¬cation of piece-wise linear feed-forward neural networks. In Interna-
tional Symposium on Automated Technology for Veriï¬cation and Analysis, pp. 269â€“286. Springer,
2017.

Timon Gehr, Matthew Mirman, Dana Drachsler-Cohen, Petar Tsankov, Swarat Chaudhuri, and Mar-
tin Vechev. Ai2: Safety and robustness certiï¬cation of neural networks with abstract interpreta-
tion. In 2018 IEEE Symposium on Security and Privacy (SP), pp. 3â€“18. IEEE, 2018.

Xiaowei Huang, Marta Kwiatkowska, Sen Wang, and Min Wu. Safety veriï¬cation of deep neural
networks. In International Conference on Computer Aided Veriï¬cation, pp. 3â€“29. Springer, 2017.

Guy Katz, Clark Barrett, David L Dill, Kyle Julian, and Mykel J Kochenderfer. Reluplex: An
efï¬cient smt solver for verifying deep neural networks. In International Conference on Computer
Aided Veriï¬cation, pp. 97â€“117. Springer, 2017.

Jingyue Lu and M Pawan Kumar. Neural network branching for neural network veriï¬cation. Inter-

national Conference on Learning Representation (ICLR), 2020.

Zhaoyang Lyu, Ching-Yun Ko, Zhifeng Kong, Ngai Wong, Dahua Lin, and Luca Daniel. Fastened
crown: Tightened neural network robustness certiï¬cates. arXiv preprint arXiv:1912.00574, 2019.

10

Matthew Mirman, Timon Gehr, and Martin Vechev. Differentiable abstract interpretation for prov-
ably robust neural networks. In International Conference on Machine Learning, pp. 3575â€“3583,
2018.

Christoph MÂ¨uller, Gagandeep Singh, Markus PÂ¨uschel, and Martin Vechev. Neural network robust-

ness veriï¬cation on gpus. arXiv preprint arXiv:2007.10868, 2020.

Aditi Raghunathan, Jacob Steinhardt, and Percy S Liang. Semideï¬nite relaxations for certifying
robustness to adversarial examples. In Advances in Neural Information Processing Systems, pp.
10877â€“10887, 2018.

Vicenc Rubies Royo, Roberto Calandra, Dusan M Stipanovic, and Claire Tomlin. Fast neural net-

work veriï¬cation via shadow prices. arXiv preprint arXiv:1902.07247, 2019.

Hadi Salman, Greg Yang, Huan Zhang, Cho-Jui Hsieh, and Pengchuan Zhang. A convex relaxation
In Advances in Neural Information

barrier to tight robustness veriï¬cation of neural networks.
Processing Systems 32, pp. 9832â€“9842, 2019.

Gagandeep Singh, Timon Gehr, Matthew Mirman, Markus PÂ¨uschel, and Martin Vechev. Fast and
In Advances in Neural Information Processing Systems, pp.

effective robustness certiï¬cation.
10825â€“10836, 2018a.

Gagandeep Singh, Timon Gehr, Markus PÂ¨uschel, and Martin Vechev. Boosting robustness certiï¬ca-

tion of neural networks. In International Conference on Learning Representations, 2018b.

Gagandeep Singh, Rupanshu Ganvir, Markus PÂ¨uschel, and Martin Vechev. Beyond the single neuron
convex barrier for neural network certiï¬cation. In Advances in Neural Information Processing
Systems, pp. 15072â€“15083, 2019a.

Gagandeep Singh, Timon Gehr, Markus PÂ¨uschel, and Martin Vechev. An abstract domain for cer-
tifying neural networks. Proceedings of the ACM on Programming Languages, 3(POPL):41,
2019b.

Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow,

and Rob Fergus. Intriguing properties of neural networks. In ICLR, 2013.

Christian Tjandraatmadja, Ross Anderson, Joey Huchette, Will Ma, Krunal Patel, and Juan Pablo
Vielma. The convex relaxation barrier, revisited: Tightened single-neuron relaxations for neural
network veriï¬cation. arXiv preprint arXiv:2006.14076, 2020.

Vincent Tjeng, Kai Xiao, and Russ Tedrake. Evaluating robustness of neural networks with mixed

integer programming. ICLR, 2019a.

Vincent Tjeng, Kai Y. Xiao, and Russ Tedrake. Evaluating robustness of neural networks with mixed
integer programming. In 7th International Conference on Learning Representations, ICLR 2019,
New Orleans, LA, USA, May 6-9, 2019. OpenReview.net, 2019b. URL https://openreview.net/
forum?id=HyGIdiRqtm.

Shiqi Wang, Yizheng Chen, Ahmed Abdou, and Suman Jana. Mixtrain: Scalable training of formally

robust neural networks. arXiv preprint arXiv:1811.02625, 2018a.

Shiqi Wang, Kexin Pei, Justin Whitehouse, Junfeng Yang, and Suman Jana. Efï¬cient formal safety
analysis of neural networks. In Advances in Neural Information Processing Systems, pp. 6367â€“
6377, 2018b.

Shiqi Wang, Kexin Pei, Justin Whitehouse, Junfeng Yang, and Suman Jana. Formal security analysis
of neural networks using symbolic intervals. In 27th {USENIX} Security Symposium ({USENIX}
Security 18), pp. 1599â€“1614, 2018c.

Tsui-Wei Weng, Huan Zhang, Hongge Chen, Zhao Song, Cho-Jui Hsieh, Luca Daniel, Duane Bon-
ing, and Inderjit Dhillon. Towards fast computation of certiï¬ed robustness for relu networks. In
International Conference on Machine Learning, pp. 5273â€“5282, 2018.

11

Eric Wong and Zico Kolter. Provable defenses against adversarial examples via the convex outer
adversarial polytope. In International Conference on Machine Learning, pp. 5283â€“5292, 2018.

Eric Wong, Frank Schmidt, Jan Hendrik Metzen, and J Zico Kolter. Scaling provable adversarial

defenses. In NIPS, 2018.

Kaidi Xu, Zhouxing Shi, Huan Zhang, Yihan Wang, Kai-Wei Chang, Minlie Huang, Bhavya
Kailkhura, Xue Lin, and Cho-Jui Hsieh. Automatic perturbation analysis for scalable certiï¬ed
robustness and beyond. Advances in Neural Information Processing Systems, 33, 2020.

Huan Zhang, Tsui-Wei Weng, Pin-Yu Chen, Cho-Jui Hsieh, and Luca Daniel. Efï¬cient neural net-
work robustness certiï¬cation with general activation functions. In Advances in neural information
processing systems, pp. 4939â€“4948, 2018.

Huan Zhang, Hongge Chen, Chaowei Xiao, Bo Li, Duane Boning, and Cho-Jui Hsieh. Towards
stable and efï¬cient training of veriï¬ably robust neural networks. In International Conference on
Learning Representations, 2020.

12

A PROOFS

A.1 Proof of Theorem 3.1

1 = h(2)

1 ) and g(2)

1 = ReLU(h(2)

2 = ReLU(h(2)

We prove Theorem 3.1 by providing a simple counterexample, and we illustrate the necessity of
feasibility checking for the completeness of BaB based veriï¬cation. Consider an NN with only two
ReLU units g(2)
2 ) where they share the same one dimension
input h(2)
2 = x. The ï¬nal output function of NN is deï¬ned as f = g(2)
2 . As a
veriï¬cation problem, we want to verify the property f â‰¥ 0 where x = [âˆ’1, 1]. Since hidden nodes
h1 and h2 are exactly the same, the ground-truth output range is f âˆ—(x) âˆˆ [0, 0]. A complete BaB
based veriï¬er is expected to obtain that optimal bound and prove the property after splitting h1 and
h2 together while BaB with only LiPRA cannot guarantee that completeness. Speciï¬cally, BaB with
only LiRPA will split the original domain x âˆˆ [âˆ’1, 1] into four sub-domains and approximate the
bound with LiRPA respectively:

1 âˆ’ g(2)

(1) (feasible) sub-domain x âˆˆ [âˆ’1, 1], h(2)

(2) (feasible) sub-domain x âˆˆ [âˆ’1, 1], h(2)

2 < 0 with output f = [0, 0] âˆ’ [0, 0] âˆˆ [0, 0]

2 â‰¥ 0 with output f = [x, x] âˆ’ [x, x] âˆˆ [0, 0]

(3) (infeasible) sub-domain x âˆˆ [âˆ’1, 1], h(2)

(4) (infeasible) sub-domain x âˆˆ [âˆ’1, 1], h(2)

1 â‰¥ 0, h(2)
1 < 0, h(2)
1 < 0, h(2)
1 â‰¥ 0, h(2)
2 < 0 with output f = [x, x] âˆ’ [0, 0] âˆˆ [âˆ’1, 1]
Only the ï¬rst two split sub-domains are feasible and therefore the ground-truth lower bound 0 can be
obtained by taking the minimum of the estimated bounds from sub-domains (1) and (2). However,
pure LiRPA is not able to tell the infeasibility of sub-domains (3) and (4) and thus BaB with pure
LiRPA will report the minimum âˆ’1 got from all these four sub-domains as the global lower bound
for the original input domain, ending up not being able to verify the property, i.e., incomplete.

2 â‰¥ 0 with output f = [0, 0] âˆ’ [x, x] âˆˆ [âˆ’1, 1]

A.2 Proof of Theorem 3.2

We prove Theorem 3.2 by considering the worst case where all unstable ReLU neurons are split.

Given a neural network function f with input domain C, assume there are N unstable ReLU neurons
{gi = ReLU(hi)|i = 1, Â· Â· Â· , N } in total. In the worst case, we have 2N leaf sub-domains S =
{Ci|i = 1, Â· Â· Â· , 2N }, where each Ci corresponds to one assignment of unstable ReLU neuron splits.
For example, we can have

C1 = C âˆ© (h1 â‰¥ 0) âˆ© (h2 â‰¥ 0) âˆ© Â· Â· Â· âˆ© (hN â‰¥ 0)
C2 = C âˆ© (h1 < 0) âˆ© (h2 â‰¥ 0) âˆ© Â· Â· Â· âˆ© (hN â‰¥ 0)
C3 = C âˆ© (h1 â‰¥ 0) âˆ© (h2 < 0) âˆ© Â· Â· Â· âˆ© (hN â‰¥ 0)
C4 = C âˆ© (h1 < 0) âˆ© (h2 < 0) âˆ© Â· Â· Â· âˆ© (hN â‰¥ 0)

Â· Â· Â·

Note that by deï¬nition the original input domain C = âˆªC(cid:48)âˆˆS C(cid:48); in other words, all the 2N split
sub-domains combined will be the same as the original input domain.

Not all of the sub-domains are actually feasible, due to the consistency requirements between neu-
rons. For example, in our proof in Section A.1, h(2)
cannot be both â‰¥ 0 or both < 0.
1
We can divide the sub-domains S into two mutually exclusive sub-sets, S feas for all the feasible
sub-domains, and S infeas for all the infeasible sub-domains. We have C = âˆªC(cid:48)âˆˆS feasC(cid:48) since these
infeasible sub-domains are empty sets.

and h(2)
2

We ï¬rst show that linear programming (LP) can be used to effectively detect these infeasible sub-
domains. For some C(cid:48) âˆˆ S infeas, because all the ReLU neurons are ï¬xed to be positive or negative,
no relaxation is needed and the network is essentially linear; thus, the input value of every hidden
neuron hi can be written as a linear equation w.r.t. input x. We add all the Boolean predicates on hi
to a LP problem as linear constraints w.r.t x. If this LP is feasible, then we can ï¬nd some input x0
that assigns compatible values to all hi; otherwise, the LP is infeasible.

Due to the lack of feasibility checking in LiRPA, the computed global lower (or upper) bounds
from LiRPA is f
. With feasibility

= minC(cid:48)âˆˆS f

minC(cid:48)âˆˆS feas f

(cid:16)

(cid:17)

C(cid:48), minC(cid:48)âˆˆS infeas f

C(cid:48)

C(cid:48) = min

LiRPA

13

checking from LP, we can remove all infeasible sub-domains from this min such that they do not
contribute to the global lower bound: f = minC(cid:48)âˆˆS feas f

C(cid:48).

To prove the whole BaB veriï¬cation is complete, it is sufï¬cient to prove this lower bound f is the
exact minimum of f bounded in C. Since any sub-domain C(cid:48) âˆˆ S feas is a leaf sub-domain with
no unstable ReLU neurons, the neural network bounded within C(cid:48) is a linear function. LiRPA can
give an exact minimum of f within sub-domain C(cid:48) . Since C = âˆªC(cid:48)âˆˆS feasC(cid:48) (in other words, S feas
covers all the feasible sub-domains within C), the minimal value for all of them f = minC(cid:48)âˆˆS feas f
C(cid:48)
forms the exact minimum of f within the input domain C. Thus, BaB with LiRPA based bounding
procedure is complete when feasibility checking is applied.

B EXPERIMENTAL SETUP

We use the same set of models and benchmark examples used in the state-of-the-art veriï¬ers GNN-
ONLINE (Lu & Kumar, 2020) and BABSR (Bunel et al., 2020b). Speciï¬cally, we evaluate on the
most challenging CIFAR-10 dataset with the same standard robustly trained convolutional neural
networks: Base, Wide, and Deep. These model structures are also used in (Lu & Kumar, 2020;
Bunel et al., 2020a). The Base model contains 2 convolution layers with 8 and 16 ï¬lters as well
as two linear layers with 100 and 10 hidden units, respectively. In total, the Base model has 3,172
ReLU activation units. The Wide model contains 2 convolution layers with 16 and 32 ï¬lters and
two linear layers with 100 and 10 hidden units, respectively, which contains 6,244 ReLU activation
units in total. The Deep model contains 4 convolution layers and all of them have 8 ï¬lters and
two linear layers with 100 and 10 hidden units, respectively, with 3,756 ReLU activation units
in total. The source code of BABSR, MIPPLANET, GNN and GNN-ONLINE are available at
https://github.com/oval-group/GNN branching. The source code of BDD+ BABSR is available at
https://github.com/verivital/vnn-comp by replacing the dataset to the same one we used here.

Given an correctly classiï¬ed image x with label yc, and another wrong label yc(cid:48) (cid:54)= yc (pre-deï¬ned
in this benchmark) and (cid:15), the veriï¬er needs to prove:

(e(c) âˆ’ e(c(cid:48)))T f (x(cid:48)) > 0

(10)
where f (Â·) is the logit-layer output of a multi-class classiï¬er, e(c) and e(c(cid:48)) are one-hot encoding
vectors for labels yc and yc(cid:48). We want to verify that for a given (cid:15), the trained classiï¬er will not
predict wrong label yc(cid:48) for image x. All properties including x, (cid:15), and c(cid:48) are provided by (Lu &
Kumar, 2020). Speciï¬cally, they categorize veriï¬cation properties solved by BABSR within 800s
as easy, between 800s and 2400s as medium and more than 2400s as hard.

(cid:107)x âˆ’ x(cid:48)(cid:107)âˆ â‰¤ (cid:15)

s.t âˆ€x(cid:48)

Our experiments are conducted on one Intel I7-7700K CPU and one Nvidia GTX 1080 Ti GPU. The
parallel batch size n is set to 400, 200 and 200 for base, wide and deep model respectively and the
Î· is set to 12,000 due to GPU memory constraint. To make a fair comparison, we use one CPU core
for all methods. Also, we use one GPU for GNN, GNN-ONLINE, BDD+ BABSR and our method.
When optimizing the LiRPA bounds, we apply 100 steps gradient decent for obtaining the initial f
(Line 2 in Algorithm 1). After that, we use 10 steps gradient decent (Line 7) and early stop once
f > 0 or f has no improvement.

C ABLATION STUDY

Our efï¬cient framework leverages two powerful components: (1) optimized LiRPA bounds and
(2) batch splits on GPUs. In this section, we conduct breakdown experiments to show how each
individual technique can help with complete veriï¬cation. As we can see in Table 2, using batched
split with unoptimized LiRPA is not very successful and cannot beat BABSR. We observe that,
without optimized LiRPA, the bounds are very loose and cannot quickly improve the global lower
bound. In contrast, using optimized LiRPA bounds without batch splits (splitting a single node at
a time and running a batch size of 1 on GPU) can still signiï¬cantly speed up complete veriï¬cation,
around 2 âˆ¼ 10X compared to BABSR. Finally, combining batch splits and optimized LiRPA allows
us to gain up to 44X speedup compared to BABSR.

D COMPLETE VERIFICATION WITH LiRPA ON CPU VS GPU

For a fair comparison, we only use one CPU core and one GPU (the same as GNN and GNN-
ONLINE) in our experimental results in Section 4. In this section, we investigate the performance of

14

Table 2: Ablation study for different components of our algorithm. The speedup rate is computed based on
running time of BABSR baseline: speedup = Time of BaBSR/Time of our method.

Method

time(s)

speedup

time(s)

speedup

time(s)

speedup

time(s)

speedup

time(s)

speedup

Easy

Medium

Hard

Wide

Deep

BABSR baseline
Batch Splits (unoptimized LiRPA)
Optimized LiRPA (no batch splits)
Optimized LiRPA & Batch Splits

522.48
587.10
94.08
11.86

â€“
0.89
5.58
44.05

1335.40
1470.02
361.53
42.04

â€“
0.91
3.70
31.80

2875.16
3013.57
1384.22
633.85

â€“
0.95
2.07
4.53

3325.65
3457.30
736.56
375.23

â€“
0.96
4.51
8.86

2855.19
2998.50
287.33
81.55

â€“
0.95
9.94
35.01

our algorithm for the cases where one or multiple CPU cores are available without GPU accelera-
tion. Note that existing baselines such as BABSR and MIPPLANET can only effectively utilize one
CPU core subject to the Gurobi solver. GNN and GNN-ONLINE can utilize one GPU to run the
GNN during branching while the rest of the veriï¬cation processes all perform on one CPU core. In
contrast, our method is much more ï¬‚exible, and we are not limited by the number of CPU cores or
GPUs. When running on multi-core CPUs, LiRPA can be automatically accelerated by the underly-
ing linear algebra library (e.g., Intel MKL or OpenBLAS) since the main computation of LiRPA is
just matrix multiplications.

In Figure 5, we show the performance of our algorithm on a single CPU core and multiple CPU
cores (in blue), and compare it to our main results with one CPU core plus one GPU (in red). As
we can see, the running time decreases when the number of CPU cores increases, but the speedup
is not linear due to the limitation of the underlying linear algebra library and hardware. There is
a big gap between the running time on 8 CPU cores and the time on one CPU core + one GPU,
and the performance gap is more obvious on Wide and Deep models. Thus, the speedup of LiRPA
computation on GPUs is signiï¬cant. However, surprisingly, even when using only one CPU core,
we are still signiï¬cantly faster than baseline BABSR and also get very competitive performance
when compared to GNN-ONLINE which needs one GPU additionally. This shows the efï¬ciency of
LiRPA based veriï¬cation algorithms.

Base Model (easy instances)
(BABSR: 522.48s)

Wide Model
(BABSR: 3325.65s)

Deep Model
(BABSR: 2855.19s)

Figure 5: Running time of our method on the Base, Wide, and Deep networks when using 1, 2, 4
and 8 CPU cores without a GPU (blue), and our method using 1 CPU core + 1 GPU (red) and a
strong baseline method, GNN-ONLINE (green). We report the baseline BABSR veriï¬cation time in
captions because they are out of range on the ï¬gures.

15

1248number of CPU core255075100125150175200time(s)n CPU core(s)One CPU core + one GPUGNN Online1248number of CPU core4006008001000120014001600time(s)n CPU core(s)One CPU core + one GPUGNN Online1248number of CPU core02505007501000125015001750time(s)n CPU core(s)One CPU core + one GPUGNN Online