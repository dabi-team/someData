1
2
0
2

t
c
O
6
2

]

V
C
.
s
c
[

1
v
4
4
4
3
1
.
0
1
1
2
:
v
i
X
r
a

A time-weighted metric for sets of trajectories to
assess multi-object tracking algorithms

Ángel F. García-Fernández(cid:63), Abu Sajana Rahmathullah◦, Lennart Svensson†
(cid:63)Dept. of Electrical Engineering and Electronics, University of Liverpool, United Kingdom
(cid:63)ARIES Research Center, Universidad Antonio de Nebrija, Spain
◦Zenseact, Sweden
†Dept. of Electrical Engineering, Chalmers University of Technology, Sweden
Emails: angel.garcia-fernandez@liverpool.ac.uk, abusajana@gmail.com, lennart.svensson@chalmers.se

Abstract—This paper proposes a metric for sets of trajectories
to evaluate multi-object tracking algorithms that includes time-
weighted costs for localisation errors of properly detected targets,
for false targets, missed targets and track switches. The proposed
metric extends the metric in [1] by including weights to the
costs associated to different time steps. The time-weighted costs
increase the ﬂexibility of the metric [1] to ﬁt more applications
and user preferences. We ﬁrst introduce a metric based on
multi-dimensional assignments, and then its linear programming
relaxation, which is computable in polynomial time and is also a
metric. The metrics can also be extended to metrics on random
ﬁnite sets of trajectories to evaluate and rank algorithms across
different scenarios, each with a ground truth set of trajectories.

Index Terms—Multiple object tracking, metrics, performance

evaluation, sets of trajectories.

I. INTRODUCTION

Multiple object tracking (MOT) algorithms play a funda-
mental role in many applications, such as self-driving vehicles,
robotics and surveillance [2]. In MOT, there is an unknown and
time-varying number of objects that appear in the surveillance
area, move following a certain trajectory and disappear from
the surveillance area. This ground truth can therefore be
represented as a set of trajectories [3]. The objective of MOT
algorithms is to estimate this set of trajectories based on noisy
sensor data. An important task is then to rank the performances
of different algorithms by measuring how similar the estimated
set of trajectories is to the ground truth [4].

The quantiﬁcation of the error between the ground truth set
of trajectories and the estimate is usually based on a distance
function. For principled evaluation and an intuitive notion of
error, it is desirable that this distance function is a metric in
a mathematical sense1 [5]. In addition, we are interested in
metrics that penalise the following important aspects of MOT:
localisation errors for properly detected targets, the number of
missed and false targets, and track switches [6]–[8].

For the related problem of multi-object ﬁltering, in which
we aim to estimate the set of targets at the current time step,
the optimal subpattern assignment (OSPA) metric is widely
used [9], [10]. However, this metric does not penalise missed
and false targets, e.g., it can be insensitive to the addition

1While distance and metric usually refer to the same concept, in this paper,
a distance is a function that does not necessarily meet the metric properties.

of false targets, and it can promote algorithms with spooky
effect at a distance [11]. The generalised OSPA (GOSPA)
metric (with parameter α = 2) penalises localisation errors for
properly detected targets, and the number of missed and false
targets, as typically required in MOT performance evaluation
[12]. In the GOSPA metric, we look for an optimal assignment
between the targets in the ground truth and estimated targets,
leaving missed and false targets unassigned.

For sets of trajectories, apart from penalising the errors for
the estimated set of targets at each time step, we are usually
interested in penalising track switches [6, Sec. 13.6]. That is,
the optimal assignments between estimated trajectories and
real trajectories may change at different time steps giving
rise to undesired track switches. There are also a number of
distance functions for sets of trajectories that are not metrics
in the literature, for example, [13]–[19].

The OSPA(2) metric is a OSPA metric with a speciﬁc base
distance applied to sets of trajectories [20]. The OSPA(2)
metric establishes an assignment between real and estimated
trajectories that is not allowed to change with time. This
approach avoids track switching considerations and may not
rank different estimated sets as desired in standard MOT per-
formance evaluation, see Figure 1. As other metrics, OSPA(2)
can be applied by subsampling the set of trajectories at time
steps of relevance [20, Sec. V.B.2]. In addition, for a single
time step, OSPA(2) becomes the OSPA metric for targets,
which has the characteristics explained above.

Bento’s metrics [21] for sets of trajectories penalise track
switches by ﬁrst adding ∗-trajectories to the ground truth and
the estimate so that both sets have equal cardinality. The track
switches are penalised based on a track switching cost function
that penalises changes in the permutations that associate the
(augmented) estimated trajectories to the (augmented) true
trajectories. A metric that extends the GOSPA metric to sets of
trajectories and penalises the number of track switches based
on changes in assignments/unassignments, without using per-
mutations and ∗-trajectories, was proposed in [1]. The linear
programming (LP) relaxation of this metric is also a metric
and is computable in polynomial time [1]. We refer to these
two metrics as trajectory metrics. These trajectory metrics
penalise localisation errors for properly detected targets, and
the number of missed, false targets, and track switches.

 
 
 
 
 
 
X2

∆ = 0

δ

Y2

Y1

∆ = 0

X1

1

2

3

4

k
5

(a) No localisation error, one track switch

∆ = 0

∆ = 0

X2

Y2

Y1

X1

∆1 (cid:29) 0

∆1 (cid:29) 0

1

2

3

4

k
5

(b) 4 missed and 4 false targets

Figure 1: Estimated set of trajectories Y = {Y1, Y2} against the ground
truth X = {X1, X2}. In (a), Y has zero localisation errors and a track
switch. In (b), Y has zero localisation errors up to time step 3, but there
are 4 missed and false targets at time steps 4 and 5 (Distance ∆1 may
be arbitrarily large). OSPA(2) penalises these two cases equally. With
a low switching cost, according to the trajectory metrics [1], (a) has a
lower error than (b).

In this paper, we increase the ﬂexibility of the trajectory
metrics in [1] by adding time-weighted costs at each time
step. This can be useful, for instance,
in online tracking
where we generally want to place more weight on estimates
corresponding to recent time steps [18]. Time-weighted costs
can also be useful to measure the accuracy of a prediction of
the set of trajectories at future time steps, by placing more
weight to closer time steps, similarly to the use of discounted
costs in sensor management [22]. As in [1], the time-weighted
trajectory metrics can also be extended to metrics on random
ﬁnite sets (RFSs) of trajectories [3].

II. PROBLEM FORMULATION AND BACKGROUND

In the standard multi-object tracking model, there is an
unknown number of objects at each time step in the surveil-
is born at a certain time step,
lance area. Each object
moves following a certain sequence of states and dies [2].
trajectory is represented by a variable X =
An object
(cid:0)ω, x1:ν(cid:1) where ω is its initial
time step, ν is its length
and x1:ν = (cid:0)x1, ..., xν(cid:1) is its sequence of consecutive
states [3]. We consider trajectories from time step 1 to T ,
the variable (ω, ν) belongs to the set
which implies that
I(T ) = {(ω, ν) : 1 ≤ ω ≤ T and 1 ≤ ν ≤ T − ω + 1}, and
variable X ∈ T(T ) where T(T ) = (cid:93)(ω,ν)∈I(T ) {ω} × Rνnx
and (cid:93) stands for the union of sets that are mutually disjoint2.
The variable of interest in MOT is the (ground truth) set
of trajectories up to time step T , which is denoted by X =
(cid:1), which
{X1, ..., XnX}. The set X belongs to Υ = F (cid:0)T(T )
denotes the set of all ﬁnite subsets of T(T ).

Based on noisy sensor data, an MOT algorithm provides
an estimated set of trajectories Y = {Y1, ..., YnY }. We

2We consider trajectories from time step 1 to T , but it is trivial to consider

trajectories in a different time interval.

would like to measure the distance between Y and X to
evaluate estimation error. A mathematically principled way of
measuring distances is via metrics.

A metric on Υ is a function d (·, ·) : Υ × Υ → [0, ∞) such

that [5]

• d (X, Y) = 0 if and only if X = Y (identity),
• d (X, Y) = d (Y, X) (symmetry),
• d (X, Y) ≤ d (X, Z) + d (Z, Y) (triangle inequality).
The aim of this paper is to propose a metric on the space Υ.
While the metric is designed for the space Υ, which considers
trajectories without holes, the proposed metric can also be used
with trajectories with holes [1, Sec. II.A].

In most applications, the main aim of metrics is to rank
different algorithms (each with a different Y) against a ground
truth set of trajectories (a single X). The case in which we have
a data set with several scenarios (each with a different ground
truth) can be addressed via metrics on RFSs of trajectories,
and will be explained in Section V.

A. GOSPA metric

We review the GOSPA metric as it is a building block for
the metric for sets of trajectories. Let us consider the sets of
(cid:9). We denote
targets x = {x1, ..., xnx} and y = (cid:8)y1, ..., yny
the set of all possible assignment sets between sets {1, .., nx}
and {1, ..., ny} as Γx,y. That is, any set θ ∈ Γx,y is such
that θ ⊆ {1, .., nx} × {1, .., ny} and, (i, j) , (i, j(cid:48)) ∈ θ implies
j = j(cid:48) and, (i, j) , (i(cid:48), j) ∈ θ implies i = i(cid:48).
Deﬁnition 1. Given a base metric db (·, ·) on Rnx , a scalar
c > 0, and a scalar p with 1 ≤ p < ∞, the GOSPA metric
(α = 2) between sets of targets x and y is [12, Prop. 1]

dG (x, y)

= min
θ∈Γx,y





(cid:88)

db (xi, yj)p +

(i,j)∈θ

cp
2



1/p

(|x| + |y| − 2 |θ|)



.

(1)

where |x| denotes the number of elements in the set x.

The ﬁrst term in (1) corresponds to the localisation errors
(to the p-th power) for assigned targets (properly detected
targets), which meet (i, j) ∈ θ. The terms cp
2 (|x| − |θ|) and
cp
2 (|y| − |θ|) are the costs (to the p-th power) for missed
and false targets, respectively. We have also dropped the
dependence of dG (·, ·) on p and c for notational simplicity.

In particular, the trajectory metrics use GOSPA with sets
x and y with at most one element, such that |x| ≤ 1 and
|y| ≤ 1. In this case, (1) becomes



min (c, db (x, y)) x = {x} , y = {y}
0

dG (x, y) (cid:44)

(2)



c
21/p

x = y = ∅
otherwise.

III. TIME-WEIGHTED TRAJECTORY METRICS
This section presents the time-weighted trajectory metrics.
Preliminary notation is introduced in Section III-A. The time-
weighted multi-dimensional assignment and linear program-
ming relaxation metrics are proposed in Sections III-B and
III-C, respectively.

A. Notation

We introduce the following notation to deﬁne the metrics.
Given a single trajectory X = (cid:0)ω, x1:ν(cid:1), the set with the state
of the trajectory at time step k is

τ k (X) (cid:44)

(cid:40)

{xk+1−ω} ω ≤ k ≤ ω + ν − 1
∅

otherwise.

(3)

Similarly, given a set X of trajectories, the set τ k (X) of target
states at time k is

τ k (X) =

τ k (X) .

(cid:91)

X∈X

(4)

(cid:12) ≤ 1 and (cid:12)
(cid:12)

is assigned to a target set yk

i = τ k (Xi) and yk
(cid:12)xk
i

The sets of targets corresponding to trajectories Xi and Yj at
j = τ k (Yj),
time step k are denoted by xk
(cid:12)
respectively. These sets are such that (cid:12)
(cid:12)yk
(cid:12) ≤ 1.
i
In the trajectory metrics, there are assignments at a trajec-
tory level to determine track switches. That is, at each time
step, each target set xk
i or is
i
left unassigned. The set of all possible assignment vectors be-
tween sets {1, . . . , nX} and {0, . . . , nY} is denoted by ΠX,Y.
The assignment vector πk = [πk
] ∈ ΠX,Y meets
πk
i = πk
i ∈ {0, . . . , nX} with the constraint that πk
i(cid:48) = j > 0
implies i = i(cid:48). Here, πk
i = j (cid:54)= 0 implies that Xi is assigned
to Yj at time k and πk
i = 0 implies that Xi is unassigned at
time k. This deﬁnition of assignment vectors implies that, at a
speciﬁc time step, there can only be one trajectory Yj assigned
to a trajectory Xi, but multiple trajectories in X and Y can
be left unassigned.

1 , ..., πk
nX

B. Time-weighted multi-dimensional assignment metric

The proposed time-weighted metric based on multi-
dimensional assignment is given by the following deﬁnition.

Deﬁnition 2. For 1 ≤ p < ∞, cut-off parameter c > 0,
switching penalty γ > 0, base metric db (·, ·) in the single-
target space, localisation time weight wk
1 > 0 at time step
k and switching time weight wk
2 > 0 at time step k, the
time-weighted multi-dimensional assignment metric d (X, Y)
between two sets X and Y of trajectories is

d (X, Y) = min

πk∈ΠX,Y
k=1,...,T

(cid:32) T

(cid:88)

k=1

wk

1 dk

X,Y

(cid:0)X, Y, πk(cid:1)p

wk

2 sX,Y

(cid:0)πk, πk+1(cid:1)p

(cid:33)1/p

+

T −1
(cid:88)

k=1

(5)

where the costs (to the p-th power) for properly detected
targets, missed targets and false targets at time step k are

dk
X,Y

(cid:0)X, Y, πk(cid:1)p

=

(cid:88)

dG

(cid:0)xk

i , yk
j

(cid:1)p

(i,j)∈θk(πk)
cp
2

(cid:12)τ k (X)(cid:12)
(cid:0)(cid:12)

+

(cid:12) + (cid:12)

(cid:12)τ k (Y)(cid:12)

(cid:12) − 2 (cid:12)

(cid:12)θk (cid:0)πk(cid:1)(cid:12)
(cid:1)
(cid:12)
(6)

with

θk (cid:0)πk(cid:1) =

(cid:110)

(i, πk

i ) : i ∈ {1, . . . , nX},

(cid:12)
(cid:12)xk
i

(cid:12)
(cid:12) =

(cid:12)
(cid:12)yk
(cid:12)

πk
i

(cid:12)
(cid:12)
(cid:12) = 1, dG

(cid:16)

i , yk
xk
πk
i

(cid:17)

(cid:111)

< c

(7)

and the switching cost (to the p-th power) from time step k to
k + 1 is

sX,Y(πk, πk+1)p = γp

nX(cid:88)

i=1

s(cid:0)πk

i , πk+1
i

(cid:1)

(8)

s(cid:0)πk

i , πk+1
i

(cid:1) =






0 πk
1 πk
1
2

i = πk+1
i
i (cid:54)= πk+1
i
otherwise.

, πk

i (cid:54)= 0, πk+1

i

(cid:54)= 0

(cid:54)= πk+1
i

and both πk

In the metric (5), we have an assignment vector πk at a
trajectory level at time step k. The change from πk to πk+1
determines the switching cost (to the p-th power) in (8). If
i = πk+1
πk
, there is no switching cost for the i-th trajectory
i
i and πk+1
in the ground truth. If πk
i
are different from zero, which implies Xj is assigned to two
different trajectories in Y at time steps k and k + 1, the
i (cid:54)= πk+1
switching cost (to the p-th power) is γp. Finally, if πk
i
and either πk
is zero, which implies that Xj is
unassigned at either time step k or k + 1, and assigned to
a trajectory in Y at the other time step, the switching cost
(to the p-th power) is γp/2. This situation represents a half
track switch, in which the switching cost from assigned to
unassigned must be half the switching cost from assigned to
assigned. This is a necessary property of a trajectory metric
based on penalising switches with assignment vectors [1].

i or πk+1

i

i

Equation (6) corresponds to the GOSPA metric in (1)
without the minimisation over the target-level assignments.
Instead, the GOSPA assignment (target-level assignment) is
ﬁxed by the assignment vector at a trajectory level πk,
excluding assignments with targets whose distance is greater
than c, see (7). Then, (6) includes the localisation costs for
properly detected targets (those included in θk (cid:0)πk(cid:1)), and costs
for missed and false targets, each of them penalised with a cost
cp
2 , as in (1). The reason for using both trajectory and target
level assignments is explained in [1, Sec. III.B].

The proof that (5) is a metric is analogous to the proof of
the linear programming metric, which is given by Proposition
3 in Section III-C. Equation (5) coincides with the multi-
dimensional trajectory metric in [1] by setting wk
1 = 1 and
wk
2 = 1 for all k. It is also possible to have a time-dependent
base metric and keep the metric properties.

C. Time-weighted linear programming relaxation metric

The assignment vectors in Deﬁnition 2 can also be written in
terms of binary weight matrices [1]. We use WX,Y to denote
the set of all binary matrices of dimension (nX+1)×(nY +1),
representing assignments between X and Y. A matrix W k ∈
WX,Y satisﬁes the following properties:

nX+1
(cid:88)

i=1
nY+1
(cid:88)

j=1

W k(i, j) = 1, j = 1, . . . , nY

(9)

W k(i, j) = 1, i = 1, . . . , nX

(10)

W k(nX + 1, nY + 1) = 0,

W k(i, j) ∈ {0, 1}, ∀ i, j

(11)

(12)

where W k(i, j) represents the element
in the row i and
column j of matrix W k. We have W k(i, j) = 1 if xk
is
i
j , W k(i, nY + 1) = 1 if xk
associated to yk
i is unassigned, and
W k(nX +1, j) = 1 if yk
j is unassigned. The bijection between
the assignment vectors and the binary weight matrices is given
in [1, Sec. IV.A], and how to write Deﬁnition 2 in terms of
these matrices is direct from Lemma 1 in [1].

The binary constraint (12) can be relaxed to deﬁne the set
W X,Y of matrices. A matrix W k ∈ W X,Y meets (9)-(11) and
W k(i, j) ≥ 0, ∀i, j.

(13)

Proposition 3. For 1 ≤ p < ∞, cut-off c > 0, switching
penalty γ > 0, base metric db (·, ·) on the single-target space,
localisation time weight wk
1 > 0 at time step k and switching
time weight wk
2 > 0 at time step k, the LP relaxation d (X, Y)
of d (X, Y) is also a metric and is given by

d (X, Y) = min

W k∈W X,Y
k=1,...,T

(cid:32) T

(cid:88)

k=1

1 tr(cid:2)(cid:0)Dk
wk

X,Y

(cid:1)†

W k(cid:3)

+

γp
2

T −1
(cid:88)

wk
2

nX(cid:88)

nY(cid:88)

k=1

i=1

j=1

|W k(i, j) − W k+1(i, j)|

,

(cid:33) 1

p

(14)

where Dk
element is

X,Y is a (nX + 1) × (nY + 1) matrix whose (i, j)

Dk

X,Y(i, j) = dG

(cid:0)xk

i , yk
j

(cid:1)p

.

(15)

The proof of Proposition 3 is given in Appendix A. It should
be noted that if we use WX,Y instead of W X,Y in (14), we
recover the metric (5). How to write (14) as an LP is direct
from [1, App. B.B]. We can also use clustering to compute
the time-weighted metrics [1, Sec. IV.D].

IV. METRIC PROPERTIES
This section explains several properties of the metrics. We
discuss possible choices of weights for different applications
in Section IV-A. The decomposition of the metrics into the
different costs is explained in Section IV-B. We provide some
inequalities for the metrics in Section IV-C.

A. Choice of weights

We proceed to discuss several options to choose the weights

that may be useful in some applications.

1) Online trackers: In online MOT algorithms, at each time
step, we have an estimate of the set of trajectories, and a
ground truth set of trajectories. These sets of trajectories may
include all trajectories up to the current time or only the
ones that are present at the current time step [23]. In some
applications, we may want to place more emphasis on recent
time steps to evaluate the performance of different trackers,
as illustrated in Figure 2. We can achieve this using the time-
weighted trajectory metrics with an exponential weight

wk

1 = ρT −k

(16)

2 = wk+1

where ρ ∈ (0, 1) is a forgetting factor, and wk
for
k ∈ {1, ..., T − 1}. Then, the different costs at the current
time step T have weight 1 and, as we move backwards in
time, the different costs are dampened with an exponential
factor ρ. The lower ρ is, the more we disregard the accuracy
of the estimation of the trajectories in the past to determine
the error.

1

∆

Y

X

1

2

3

4

5

(a) One missed target at time step 6.

Y

X

1

2

3

4

5

k
6

k
6

∆

(b) One missed target at time step 1

Figure 2: Two estimated sets of trajectories against a ground truth (both
sets with a single trajectory), with ∆ (cid:28) c. In some applications, it may
be suitable to penalise missed targets at different time instants differently.
If we use the metric to compare the estimated sets of trajectories of
different trackers at the current time step, a missed target in the past
may be less important than a missed target at the current time step. In
this setting, (b) can be considered a better estimate than (a).

We may also want to normalise the weight (16) to sum to

one in the considered window such that

wk

1 =

ρT −k
j=1 ρT −j

(cid:80)T

=

1 − ρ
1 − ρT ρT −k

(17)

and wk

2 = wk+1

1

for k ∈ {1, ..., T − 1}.

2) Predictors: In some applications, we are interested in
predicting the set of trajectories in a future time window
[24], [25], for example, in collision avoidance systems. For
measuring the error of different predictors, we can choose a
time window starting at the following time step and a weight

wk

1 = ρk−1

(18)

2 = wk+1

where ρ ∈ (0, 1), wk
for k ∈ {1, ..., T − 1}, and
index k goes through the future time steps. In this case, costs
at the next time step have weight 1 and, as we move forward
in time, the costs decrease with an exponential factor ρ.

1

As in Section IV-A1, we may also want to normalise the

weight (18) such that

wk

1 =

ρk−1
j=1 ρk−1

(cid:80)T

=

1 − ρ
1 − ρT ρk−1

(19)

and wk

2 = wk+1

1

for k ∈ {1, ..., T − 1}.

3) Time-dependent sampling intervals: There are applica-
tions in which the time interval between measurements is not
constant. Let tk be the sampling time corresponding to the k-th
measurement such that the time interval between consecutive
measurements is ∆tk = tk −tk−1, with t0 = 0. In this setting,
the (sampled) set of trajectories is represented as in Section II,
and each trajectory contains state information at the sampled
time steps [26].

In this scenario, it may be useful to set weights equal or
proportional to the time interval between measurements, for

2 = wk+1

1 = ∆tk and wk

example, wk
for k ∈ {1, ..., T − 1}.
With this approach, we give more weight to the time steps in
which the sampling interval is large. It may also be desired
to normalise the weights and combine this approach with an
exponential factor as in Section IV-A1.

1

4) Other choices: In some applications, we may want to
put more emphasis on certain time steps in a different way
from the ones discussed above. For example, in a surveillance
situation, there may have been an incident at a certain time
step, around which tracking accuracy is of high importance,
being less relevant at other time steps.

B. Metric decomposition

Following [1, Eq.

(24)],

the

time-weighted multi-

dimensional assignment metric can be decomposed as

d(X, Y)

= min

W k∈WX,Y
k=1,...,T

(cid:32) T

(cid:88)

k=1

1 lk (cid:0)X, Y, W k(cid:1)p
wk

1 mk (cid:0)X, Y, W k(cid:1)p
wk

+

T
(cid:88)

k=1

1 f k (cid:0)X, Y, W k(cid:1)p
wk

2 sk (cid:0)W k, W k+1(cid:1)p
wk

(cid:33)1/p

(20)

+

+

T
(cid:88)

k=1

T −1
(cid:88)

k=1

where lk (·) is the localisation cost for properly detected targets
at time k, mk (·) is the missed target cost at time k, f k (·) is
the false target cost at time k and sk (·) is the switching cost
at time k. The deﬁnition of these costs is provided in [1, Sec.
IV.C] and is not repeated here. The LP metric (14) has the
same decomposition, but with soft assignments.

C. Metric inequalities

It is direct to see that if γ → 0, the metrics (5) and (14)
tend to the (p-th root) of the weighted sum of the GOSPA
costs (to the p-th power) across time

Figure 1. Then, for ﬁxed values of c, p and γ, the following
inequalities hold

d0 (X, Y) < d (X, Y) ≤ d (X, Y) ≤ d∞ (X, Y) .

(22)

V. METRICS ON RFSS: MOT EVALUATION ACROSS
MULTIPLE SCENARIOS

The time-weighted trajectory metrics can be directly ex-
tended to metrics on RFSs of trajectories by considering
expected values [1]. To be speciﬁc, Lemma 3 in [1] is also
valid for the time-weighted metrics, as well as for the OSPA(2)
metric, and it is reproduced next.

(cid:16)

E(cid:2)d(X, Y)p(cid:48)(cid:3)(cid:17)1/p(cid:48)

and

Lemma 4. Given 1 ≤ p(cid:48) < ∞,
E(cid:2)d(X, Y)p(cid:48)(cid:3)(cid:17)1/p(cid:48)
(cid:16)
sets of trajectories with ﬁnite moment E
denoting expected value.

are metrics on the space of random ﬁnite

(cid:104)

|·|p(cid:48)/p(cid:105)

, with E [·]

The metrics on RFSs are important to evaluate algorithms
when we consider a ﬁxed ground truth and we use Monte Carlo
simulation to draw different realisations of the measurements.
In this case, each algorithm returns a different estimate at each
Monte Carlo run. Metrics on RFSs are also important when we
have a dataset, either simulated or obtained via experiments,
with several scenarios, each with a different ground truth [27].
For each scenario, each algorithm provides an estimate, and we
look for a uniﬁed measure of performance across the different
scenarios.

Consider the task of comparing the average performance of
J MOT algorithms, and suppose we have a data set with N
scenarios with ground truth sets of trajectories X1, ..., XN ,
for which the j-th algorithm estimates Yj
1, ..., Yj
N . We can
interpret that X1, ..., XN and Yj
1, ..., Yj
N approximate the
joint distribution p (cid:0)X, Yj(cid:1) on the ground truth and the
estimate of the j-th algorithm such that

p (cid:0)X, Yj(cid:1) ≈

1
N

N
(cid:88)

i=1

δ(Xi,Yj
i )

(cid:0)X, Yj(cid:1) .

(23)

Then, the distance between RFSs X and Yj becomes

d0 (X, Y) =

wk

1 dG

(cid:0)τ k (X) , τ k (Y)(cid:1)p

(cid:33)1/p

(cid:32) T

(cid:88)

k=1

.

(21)

(cid:16)

E(cid:2)d(X, Yj)p(cid:48)(cid:3)(cid:17)1/p(cid:48)

≈

(cid:32)

1
N

N
(cid:88)

i=1

(cid:33)1/p(cid:48)

(cid:2)d(Xi, Yj

i )p(cid:48)(cid:3)

.

(24)

It is also direct to establish that d0 (·, ·) is a lower bound
on the trajectory metrics (5) and (14) (which require γ >
0). We can compute d0 (X, Y) by solving T 2-D assignment
problems, one for each GOSPA cost. Solving these T 2-D
assignment problems is considerably faster than solving the
multi-dimensional assignment problem or the LP problem in
(5) and (14). However, the distance d0 (X, Y) neglects track
switching costs and is not a metric.

If γ → ∞, both the multi-dimensional assignment metric
and the LP metric tend to the same metric, which we refer
to as d∞ (X, Y). The metric d∞ (X, Y) can be computed
with a single 2-D assignment problem [1, Sec. IV.D], which
is fast to compute, but it does not allow trajectories to change
assignments across time, which is usually undesirable, see

Equation (24) provides a metric-based ranking of performance
for the J algorithms across the N scenarios.

VI. EXAMPLE

We proceed to illustrate how the trajectory metric (TM), the
time-weighted trajectory metric (TW-TM)3 and OSPA(2) differ
in one example. We consider a single ground truth with two
one-dimensional trajectories, T = 800 steps, and 4 estimates,
each with two trajectories, as shown in Figure 3. Estimate 1
(E1) estimates each trajectory with a deviation of 3 meters

3Matlab code for the time weighted LP trajectory metric is available at

https://github.com/Agarciafernandez/MTT.

Figure 4: Decomposition of the error across time for the time-weighted
trajectory metric (left) and the trajectory metric (right) for Estimate 2 in
Figure 3. In the TW-TM, the (time-weighted) costs increase with time
due to the considered weighting, see (17).

Finally, we show the decomposition of the error across time,
see Section IV-B, for the TW-TM and the TM in Figure 4. This
decomposition provides useful information, for example, we
can locate when track switching occurs, and determine that
there are not any missed or false targets.

VII. CONCLUSIONS

This paper has extended the metric on sets of trajectories
in [1] to include weights to penalise the costs (localisation
error, number of missed/false targets, and track switches) at
different time steps unevenly. This extension adds ﬂexibility
to the trajectory metric [1] to suit more user preferences to
compute the error of multiple object tracking algorithms.

The metric can be computed solving a multi-dimensional
assignment problem, e.g., using the Viterbi algorithm. The LP
relaxation of the metric is also a metric and is computable in
polynomial time.

APPENDIX A

In this appendix, we prove Proposition 3. The non-
negativity, identity and symmetry properties of the metric in
(14) are straightforward. The proof of the triangle inequality
is analogous to the proof of the triangle inequality of the
trajectory metric [1, App. B], with some minor adaptations.

The proof in this section is done for the LP metric, where
the optimization is over W k ∈ W X,Y. The proof is similar
for the multi-dimensional assignment metric in (5), where the
optimisation is over W k ∈ WX,Y. We use d (cid:0)X, Y, W 1:T (cid:1) to
denote the objective function in (14) as a function of W 1:T =
(cid:0)W 1, ..., W T (cid:1).

The outline of the triangle inequality proof is as follows.
We assume that we have three sets of trajectories X, Y, Z.
Let W (cid:63),k
Z,Y be the weight matrices that minimise
d (cid:0)Y, Z, W 1:T (cid:1) and d (cid:0)Z, Y, W 1:T (cid:1). Based on W (cid:63),k
X,Z and
W (cid:63),k
X,Y ∈ W X,Y such that

Z,Y, we construct a matrix W k

X,Z and W (cid:63),k

W k

X,Y(i, j) =

nZ(cid:88)

l=1

W (cid:63),k

X,Z(i, l)W (cid:63),k

Z,Y(l, j)

(25)

for i ∈ {1, ..., nX} and j ∈ {1, ..., nY}, and the rest of the
elements of W k

X,Y are

W k

X,Y(i, j)

Figure 3: Scenario of the example. We have a ground truth set of
trajectories with two trajectories (blue), and four estimated sets of
trajectories (red), each with two trajectories. There is track switching
in Estimates 2 and 3.

at each time step. Estimate 2 (E2) and Estimate 3 (E3) are
like E1 but with track switching at time step 250 and 650,
respectively. Estimate 4 (E4) is like E1 but, from time step
550, one of the trajectories is not estimated properly.

Assuming that 3 meters is an acceptable localisation error,
E1 would be considered the best estimate and E4 the worst
one in most MOT applications. If we are assessing an online
tracking algorithm and we want to penalise errors at past time
steps less, E2 should be better than E3.

We use the TM with the Euclidean metric as the base
distance and parameters c = 5, p = 1, γ = 10, and we
normalise its result by the length of the time window T .
The TW-TM has the same parameters as the TM with the
normalised weights for online trackers in (17) with ρ = 0.995.
The OSPA(2) metric also uses the Euclidean metric, c = 5,
p = 1 and is applied on the same time interval. We have also
tested the trajectory metrics with γ = 108 to show the results
when assignments are not allowed to change in time, as in
OSPA(2).

The resulting errors and the decomposition into (time-
weighted) localisation cost for properly detected targets (Loc.),
cost for missed targets (Mis.), cost for false targets (Fal.) and
cost for track switches (Swi.) are shown in Table I, and the re-
sulting rankings in Table II. The TW-TM ranks the algorithms
according to what we would expect for an online tracker. The
TM ranks the algorithm well, but indicates that E2 and E3 have
the same error, as for this metric, it does not matter when the
track switches take place. The error decomposition provides
relevant
the estimates. On the contrary,
OSPA(2) does not rank the algorithms properly; E4 is ranked
as the second best algorithm despite the major errors in the
estimation of one trajectory. This type of localisation error is
typically penalised more than a track switch in most MOT
applications [6, Sec. 13.6]. Setting γ = ∞ or γ sufﬁciently
high in the trajectory metrics also has undesirable effects in
the ranking, due to the lack of change in the assignments [6].

information about

0200400600800Timestep-20020406080100120Targetstate(m)Estimate 10200400600800Timestep-20020406080100120Targetstate(m)Estimate 20200400600800Timestep-20020406080100120Targetstate(m)Estimate 30200400600800Timestep-1000100200300400500Targetstate(m)Estimate 40200400600800Timestep00.0050.010.0150.020.0250.030.035TW-TMdecompositionTime-weightedtotalTime-weighted localisationTime-weighted missedTime-weighted falseTime-weighted switch0200400600800Timestep00.0050.010.0150.020.0250.030.035TMdecompositionTotalLocalisationMissedFalseSwitchTable I: Errors and their decomposition for the estimates in Figure 3

Metric

E1
E2
E3
E4

TW-TM

Loc. Mis.

6
6.00
6.00
3.81

0
0
0
1.82

Fal.
0
0
0
1.82

Tot.
6
6.01
6.05
7.46

Swi.
0
0.01
0.05
0

Tot.
6
6.03
6.03
6.63

TM
Loc. Mis.

6
6.00
6.00
5.06

0
0
0
0.78

Fal.
0
0
0
0.78

Swi.
0
0.03
0.03
0

OSPA(2)
Tot.
3
3.62
3.38
3.31

TW-TM (γ = 108)
Tot.
6
6.18
7.84
7.46

TM (γ = 108)
Tot.
6
7.25
6.76
6.63

Table II: Ranking of the estimates for the different metrics

Metric
TW-TM

TM

OSPA(2)
TW-TM (γ = 108)
TM (γ = 108)

Ranking
E1-E2-E3-E4
E1-E2-E3-E4
E1-E3-E2-E4

E1-E4-E3-E2
E1-E2-E4-E3
E1-E4-E3-E2






=

j=1 W k
i=1 W k

X,Y(i, j)
X,Y(i, j)

1 − (cid:80)nY
1 − (cid:80)nX
0

i ∈ {1, ..., nX}, j = nY + 1
i = nX + 1, j ∈ {1, ..., nY}
i = nX + 1, j = nY + 1.

Then, we show that

d (cid:0)X, Y, W 1:T

X,Y

(cid:1) ≤ d (X, Z) + d (Z, Y) .

(26)

(27)

By deﬁnition, d (X, Y) ≤ d (cid:0)X, Y, W 1:T

X,Y

(cid:1), which yields

nY(cid:88)

nZ(cid:88)

+

(cid:0)dk

X,Z (nX + 1, l) + dk

Z,Y (l, j)(cid:1)p

X,Z (nX + 1, l) W k

Z,Y (l, j)

l=1

j=1
× W k
nX(cid:88)

+

Dk

X,Z (i, nZ + 1) W k

X,Z (i, nZ + 1)

i=1

nX(cid:88)

nZ(cid:88)

+

(cid:0)dk

X,Z (i, l) + dk

Z,Y (l, nY + 1)(cid:1)p

l=1

i=1
× W k

X,Z (i, l) W k
X,Y (i, j) = Dk

Z,Y (l, nY + 1)
X,Y(i, j)1/p.

where dk

Finally, for p ≥ 1, and am, bm ≥ 0,

(31)

the Minkowski

inequality [28, pp. 165] is

(cid:32)

(cid:88)

m

[am + bm]p

(cid:33)1/p

(cid:32)

(cid:88)

≤

ap
m

(cid:33)1/p

(cid:32)

(cid:88)

+

bp
m

(cid:33)1/p

.

m

m

(32)

d (X, Y) ≤ d (X, Z) + d (Z, Y)

(28)

B. Proof of (29)

and ﬁnishes the proof of the triangle inequality.
To prove (27), we show that for any W k
Z,Y ∈ W Z,Y, and W k

X,Z ∈ W X,Z and
X,Y obtained using (25) and (26). we

W k
have

d (cid:0)X, Y, W 1:T

X,Y

(cid:1) ≤ d (cid:0)X, Z, W 1:T

X,Z

(cid:1) + d (cid:0)Z, Y, W 1:T

Z,Y

(cid:1) .
(29)

We prove (29) in Section A-B. Before this, we provide three
preliminary inequalities in Section A-A.

A. Preliminary inequalities

The following switching cost inequality holds [1, App. B]

nX(cid:88)

nY(cid:88)

i=1

j=1

(cid:12)
(cid:12)W k
(cid:12)

X,Y (i, j) − W k+1

(cid:12)
(cid:12)
X,Y (i, j)
(cid:12)

≤

nX(cid:88)

i=1

nZ(cid:88)

l=1

(cid:12)
(cid:12)W k
(cid:12)
nZ(cid:88)

(cid:12)
(cid:12)W k
(cid:12)

nY(cid:88)

+

j=1

l=1

X,Z (i, l) − W k+1

X,Z (i, l)

(cid:12)
(cid:12)
(cid:12)

Z,Y (l, j) − W k+1

Z,Y (l, j)

(cid:12)
(cid:12)
(cid:12) .

(30)

The following inequality also holds [1, App. B],
tr(cid:2)(cid:0)Dk
nX(cid:88)

(cid:1)†
W k
nZ(cid:88)
nY(cid:88)

X,Y

X,Y

(cid:3)

X,Z (i, l) + dk

Z,Y (l, j)(cid:1)p

(cid:0)dk

≤

W k

X,Z (i, l) W k

Z,Y (l, j)

i=1

j=1

l=1

+

nY(cid:88)

j=1

Dk

Z,Y (nZ + 1, j) W k

Z,Y (nZ + 1, j)

From (31), we can write
1 tr(cid:2)(cid:0)Dk
wk
nY(cid:88)
nX(cid:88)

(cid:1)†
nZ(cid:88)

W k

X,Y

X,Y

(cid:3)

≤

(cid:0)ak

i,l,j + bk

i,l,j

i=1

j=1

l=1

(cid:1)p

+

nY(cid:88)

j=1

(cid:0)0 + bk

j

(cid:1)p

+

+

nY(cid:88)

nZ(cid:88)

j=1

l=1

nX(cid:88)

nZ(cid:88)

i=1

l=1

(cid:0)ak

l,j + bk
l,j

(cid:1)p

+

nX(cid:88)

i=1

(cid:0)ak

i + 0(cid:1)p

(cid:0)ak

i,l + bk
i,l

(cid:1)p

(33)

where we have multiplied the cost by wk
1 and it is direct to
identify the terms ak
i,l,j once wk
1 and the weight ma-
trices are included inside the parenthesis for each summation
in (31).

i,l,j and bk

Combining (30) and (31) with d (cid:0)X, Y, W 1:T
d (cid:0)X, Y, W 1:T
nX(cid:88)

nZ(cid:88)

nY(cid:88)

nY(cid:88)

T
(cid:88)

X,Y





(cid:1)

X,Y

(cid:0)ak

i,l,j + bk

i,l,j

(cid:1)p

+

≤





(cid:0)0 + bk

j

(cid:1)p

(cid:1), we obtain

k=1

i=1

j=1

l=1

j=1

+

+

nY(cid:88)

nZ(cid:88)

j=1

l=1

nX(cid:88)

nZ(cid:88)

i=1

l=1

(cid:0)ak

l,j + bk
l,j

(cid:1)p

+

(cid:33)

(cid:0)ak

i,l + bk
i,l

(cid:1)p

nX(cid:88)

i=1

(cid:0)ak

i + 0(cid:1)p

T −1
(cid:88)

nX(cid:88)

nZ(cid:88)

+

k=1

i=1

l=1

wk
2

γp
2
(cid:124)

(cid:12)
(cid:12)W k
(cid:12)

X,Z (i, l) − W k+1

(cid:12)
(cid:12)
X,Z (i, l)
(cid:12)
(cid:125)

(cid:123)(cid:122)
i,l +0)p
(ak,2



1/p

T −1
(cid:88)

nY(cid:88)

nZ(cid:88)

+

k=1

j=1

l=1

wk
2

γp
2
(cid:124)

(cid:12)
(cid:12)W k
(cid:12)

Z,Y (l, j) − W k+1

(cid:12)

(cid:12)

Z,Y (l, j)
(cid:12)


(cid:125)

(cid:123)(cid:122)
l,j )p
(0+bk,2

.

(34)

We make use of the Minkowski inequality (32) to obtain

(cid:1)

d (cid:0)X, Y, W 1:T
nX(cid:88)

T
(cid:88)





X,Y

≤





nY(cid:88)

nZ(cid:88)

(cid:0)ak

i,l,j

(cid:1)p

+

nY(cid:88)

nZ(cid:88)

(cid:0)ak

l,j

(cid:1)p

k=1

i=1

j=1

l=1

nX(cid:88)

i=1

(cid:0)ak

i + 0(cid:1)p

+

nX(cid:88)

nZ(cid:88)

i=1

l=1

(cid:0)ak

i,l

l=1

j=1
(cid:33)

(cid:1)p

γp
2

wk
2

(cid:12)
(cid:12)W k
(cid:12)

X,Z (i, l) − W k+1

X,Z (i, l)

(cid:35)1/p
(cid:12)
(cid:12)
(cid:12)

T −1
(cid:88)

nX(cid:88)

nZ(cid:88)

l=1

k=1


i=1


T
(cid:88)

+



nX(cid:88)

nY(cid:88)

nZ(cid:88)

(cid:0)bk

i,l,j

(cid:1)p

+



nY(cid:88)

j=1

(cid:0)0 + bk

j

(cid:1)p

k=1

i=1

j=1

l=1

nY(cid:88)

nZ(cid:88)

j=1

l=1

(cid:0)bk

l,j

(cid:1)p

+

nX(cid:88)

nZ(cid:88)

i=1

l=1

(cid:33)


(cid:1)p

(cid:0)bk

i,l

+

+

+

+

T −1
(cid:88)

nY(cid:88)

nZ(cid:88)

k=1

j=1

l=1

γp
2

wk
2

(cid:12)
(cid:12)W k
(cid:12)

Z,Y (l, j) − W k+1

(cid:12)
(cid:12)
Z,Y (l, j)
(cid:12)



1/p



.

(35)

By using (31) and (33), we proceed to write the terms that
i,l,j in terms of the distances. We have
nY(cid:88)

include a coefﬁcient ak
nZ(cid:88)
nX(cid:88)

nZ(cid:88)

nY(cid:88)

(cid:0)ak

i,l,j

(cid:1)p

+

(cid:0)ak

l,j

(cid:1)p

i=1

j=1

l=1

j=1

l=1

nX(cid:88)

i=1

(cid:0)ak

i + 0(cid:1)p

+

nX(cid:88)

nZ(cid:88)

i=1

l=1

(cid:0)ak

i,l

(cid:1)p

nX(cid:88)

nY(cid:88)

nZ(cid:88)

i=1

j=1

l=1

wk

1 dk

X,Z (i, l)p W k

X,Z (i, l) W k

Z,Y (l, j)

nY(cid:88)

nZ(cid:88)

j=1

l=1

wk

1 dk

X,Z (nX + 1, l)p W k

X,Z (nX + 1, l) W k

Z,Y (l, j)

nX(cid:88)

i=1

wk

1 Dk

X,Z (i, nZ + 1) W k

X,Z (i, nZ + 1)

nX(cid:88)

nZ(cid:88)

wk

1 dk

X,Z (i, l)p W k

X,Z (i, l) W k

Z,Y (l, nY + 1)

+

=

+

+

+

l=1

i=1
= wk

1 tr(cid:2)(cid:0)Dk

X,Z

(cid:1)†

(cid:3)

W k

X,Z

where the last equality follows from [1, Eq. (52)]. Sim-
the sums of the terms with coefﬁcient bk
ilarly,
i,l,j sum
(cid:3). Substituting these values into (35)
to wk
yields (29), which implies that the triangle inequality holds.

1 tr(cid:2)(cid:0)Dk

W k

Z,Y

Z,Y

(cid:1)†

REFERENCES

[1] A. F. García-Fernández, A. S. Rahmathullah, and L. Svensson, “A metric
on the space of ﬁnite sets of trajectories for evaluation of multi-target

tracking algorithms,” IEEE Transactions on Signal Processing, vol. 68,
pp. 3917–3928, 2020.

[2] R. P. S. Mahler, Advances in Statistical Multisource-Multitarget Infor-

mation Fusion. Artech House, 2014.

[3] A. F. García-Fernández, L. Svensson, and M. R. Morelande, “Multiple
target tracking based on sets of trajectories,” IEEE Transactions on
Aerospace and Electronic Systems, vol. 56, no. 3, pp. 1685–1707, Jun.
2020.

[4] A. Milan, L. Leal-Taixé,

I. Reid, S. Roth, and K. Schindler,
“MOT16: a benchmark for multi-object tracking.” [Online]. Available:
https://arxiv.org/abs/1603.00831

[5] T. M. Apostol, Mathematical Analysis. Addison Wesley, 1974.
[6] S. Blackman and R. Popoli, Design and Analysis of Modern Tracking

Systems. Artech House, 1999.

[7] B. E. Fridling and O. E. Drummond, “Performance evaluation methods
for multiple-target-tracking algorithms,” vol. 1481, 1991, pp. 371–383.
[8] O. E. Drummond and B. E. Fridling, “Ambiguities in evaluating per-
formance of multiple target tracking algorithms,” in Proceedings of the
SPIE conference, 1992, pp. 326–337.

[9] D. Schuhmacher and A. Xia, “A new metric between distributions of
point processes,” Advances in Applied Probability, vol. 40, no. 3, pp.
651–672, Sep. 2008.

[10] D. Schuhmacher, B.-T. Vo, and B.-N. Vo, “A consistent metric for
performance evaluation of multi-object ﬁlters,” IEEE Transactions on
Signal Processing, vol. 56, no. 8, pp. 3447–3457, Aug. 2008.

[11] A. F. García-Fernández and L. Svensson, “Spooky effect in optimal
OSPA estimation and how GOSPA solves it,” in Proceedings on the
22nd International Conference on Information Fusion, 2019.

[12] A. S. Rahmathullah, A. F. García-Fernández, and L. Svensson, “Gen-
eralized optimal sub-pattern assignment metric,” in 20th International
Conference on Information Fusion, 2017, pp. 1–8.

[13] K. Bernardin and R. Stiefelhagen, “Evaluating multiple object tracking
performance: The CLEAR MOT metrics,” EURASIP Journal on Image
and Video Processing, vol. 2008, pp. 1–10, 2008.

[14] E. Ristani, F. Solera, R. Zou, R. Cucchiara, and C. Tomasi, “Performance
measures and a data set for multi-target, multi-camera tracking,” in
ECCV 2016 Workshops, pp. 17–35.

[15] J. Luiten et al., “HOTA: A higher order metric for evaluating multi-
object tracking,” International Journal of Computer Vision, pp. 1–31,
2020.

[16] B. Ristic, B.-N. Vo, D. Clark, and B.-T. Vo, “A metric for performance
evaluation of multi-target tracking algorithms,” IEEE Transactions on
Signal Processing, vol. 59, no. 7, pp. 3452–3457, July 2011.

[17] R. Canavan, C. McCullough, and W. J. Farrell, “Track-centric metrics for
track fusion systems,” in 12th International Conference on Information
Fusion, 2009, pp. 1147–1154.

[18] M. Silbert, “A robust method for computing truth-to-track assignments,”
in 12th International Conference on Information Fusion, 2009, pp.
1658–1664.

[19] K. Manson and P. O’Kane, “Taxonomic performance evaluation for
multitarget tracking systems,” IEEE Transactions on Aerospace and
Electronic Systems, vol. 28, no. 3, pp. 775–787, July 1992.

[20] M. Beard, B. T. Vo, and B. Vo, “A solution for large-scale multi-object
tracking,” IEEE Transactions on Signal Processing, vol. 68, pp. 2754–
2769, 2020.

[21] J. Bento and J. J. Zhu, “A metric for sets of trajectories that

is
practical and mathematically consistent,” 2018. [Online]. Available:
https://arxiv.org/abs/1601.03094

[22] A. O. Hero III, D. A. Castañón, D. Cochran, and K. Kastella, Founda-
tions and Applications of Sensor Management. Springer, 2008.
[23] K. Granström, L. Svensson, Y. Xia, J. L. Williams, and A. F.
García-Fernández, “Poisson multi-Bernoulli mixture trackers: continuity
through random ﬁnite sets of trajectories,” in 21st International Confer-
ence on Information Fusion, 2018, pp. 973–981.

[24] K. Granström, L. Svensson, Y. Xia, J. Williams, and A. F. García-
Fernández, “Poisson multi-Bernoulli mixtures for sets of trajectories,”
2019. [Online]. Available: https://arxiv.org/abs/1912.08718

[25] Y. C. Tang and R. Salakhutdinov, “Multiple futures prediction,” in 33rd

Conference on Neural Information Processing Systems, 2019.

[26] A. F. García-Fernández and S. Maskell, “Continuous-discrete trajectory
PHD and CPHD ﬁlters,” in 23rd International Conference on Informa-
tion Fusion, 2020, pp. 1–8.

[27] H. Caesar et al., “nuScenes: A multimodal dataset for autonomous
driving,” in IEEE/CVF Conference on Computer Vision and Pattern
Recognition (CVPR), 2020, pp. 11 618–11 628.

[28] C. S. Kubrusly, The Elements of Operator Theory. Springer Science +

Business Media, 2011.

