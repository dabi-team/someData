Interactive Visualization of Protein RINs
using NetworKit in the Cloud

Eugenio Angriman∗†, Fabian Brandt-Tumescheit∗‡, Leon Franke§ Alexander van der Grinten∗¶
and Henning Meyerhenke∗(cid:107)
∗Department of Computer Science, Humboldt-Universit¨at zu Berlin, Germany
Email: †angrimae@hu-berlin.de, ‡brandtfa@hu-berlin.de, ¶avdgrinten@hu-berlin.de, (cid:107)meyerhenke@hu-berlin.de
§Department of Chemistry, Konstanz Research School Chemical Biology, University of Konstanz, Germany
Email: leon.franke@uni-konstanz.de

2
2
0
2

r
a

M
2

]
I
S
.
s
c
[

1
v
3
6
2
1
0
.
3
0
2
2
:
v
i
X
r
a

Abstract—Network analysis has been applied in diverse appli-
cation domains. In this paper, we consider an example from pro-
tein dynamics, speciﬁcally residue interaction networks (RINs).
In this context, we use NETWORKIT – an established package
for network analysis – to build a cloud-based environment
that enables domain scientists to run their visualization and
analysis workﬂows on large compute servers, without requiring
extensive programming and/or system administration knowledge.
To demonstrate the versatility of this approach, we use it to build
a custom Jupyter-based widget for RIN visualization. In contrast
to existing RIN visualization approaches, our widget can easily be
customized through simple modiﬁcations of Python code, while
both supporting a good feature set and providing near real-time
speed. It is also easily integrated into analysis pipelines (e.g., that
use Python to feed RIN data into downstream machine learning
tasks).

Index Terms—network analysis, cloud computing, graph vi-
sualization, residue interaction networks, molecular dynamics
simulations

I. INTRODUCTION

Graphs are essential to model various real-world phenomena
such as social networks, infrastructure networks, web graphs,
or the spread of epidemics, among other applications [1].
Network analysis (and graph mining) is an important tool to
extract data from these graphs [2]. To this end, various toolkits
for network analysis have been developed (see Section VI for
an overview). In this work, we focus on NETWORKIT, one of
the established toolkits in this area, with a focus on usability
(via a Python-based frontend) and multi-threaded performance
(powered by a C++ backend) [3]. The Python/C++ architec-
ture makes NETWORKIT well-suited for our use case: while
domain-scientists can use the Python frontend to build analysis
pipelines without extensive programming knowledge, the C++
core lets NETWORKIT surpass the performance bottlenecks
of pure Python implementations (however, we do note that
NETWORKIT is not unique in this regard, see Section VI).

NETWORKIT’s Python-based frontend allows rapid devel-
opment of solutions for domain-speciﬁc problems, while only
requiring a limited amount of programming expertise. In this
paper, we further lower this barrier of entry by presenting

The work by AvdG was supported by German Research Foundation (DFG)
grant GR 5745/1-1. The work by FBT and HM was supported by DFG
Collaborative Research Center (CRC) 1404 FONDA.

a cloud-based NETWORKIT installation that does not require
domain scientists to install any packages on their local ma-
chines anymore. This approach has two substantial advantages:
ﬁrst, it avoids the need of domain scientists to deal with
the installation of complicated scientiﬁc computing packages,
especially when multiple such packages (and not only NET-
WORKIT) are required. This task can instead be performed
by system administration experts. Secondly, a cloud-based ap-
proach enables domain scientists to run their analysis pipelines
on cloud-hosted servers that provide appropriate resources for
computationally intensive tasks (e.g., large numbers of CPU
cores and/or large amounts of RAM). A cloud-based approach
also fosters research to be collaborative and shareable.

Based on this cloud-based environment, we consider a
use case from the analysis of molecular dynamics (MD)
simulations, namely the investigation of protein dynamics via
residue interaction networks (RINs, see Section IV for a def-
inition). To this end, we extend NETWORKIT’s visualization
capabilities to take domain-speciﬁc requirements into account;
as a result, we present a Jupyter notebook widget that can be
used to visualize RINs interactively (see Section V). Since
expensive recomputations of the RIN layout are delegated to
a cloud server, our widget updates in real-time, even when
computationally expensive analytics (e.g., centrality measures
such as betweenness and closeness, or community detection)
are incorporated into the visualization.

Outline and contribution: We ﬁrst give an overview of
NETWORKIT, including recent changes to its ecosystem (in
Section II). Next, we present the setup of our NETWORKIT-
based cloud deployment (in Section III) and how we use it
to provide a low barrier of entry for non-experts in network
analysis. To the best our knowledge, there are no other Python-
programmable cloud environments available yet that explic-
itly support network analysis in domain-speciﬁc applications.
After an overview over a relevant domain-speciﬁc problem
concerning the analysis of RINs (in Section IV), we show how
NETWORKIT helps to solve application-speciﬁc questions in
this domain by providing customized visualization tools (in
Section V). In contrast to existing RIN visualization solutions,
our use of NETWORKIT on a cloud server enables domain
scientists to interactively explore entire simulation data sets

 
 
 
 
 
 
and their graph-based features in real time in a Python-based
cloud environment.

hub platform [9]–[12]) use conda as their main channel of
distribution.

II. NETWORKIT OVERVIEW

The network analysis package NETWORKIT was ﬁrst re-
leased in 2013. Its architecture was previously described
in Refs. [3] and [4]; here we only give a brief overview.
NETWORKIT offers numerous unique algorithms that focus on
handling large input graphs. These algorithms cover different
families of popular network analysis problems such as dis-
tance computations (in the distance module), community
detection (community), network centrality (centrality),
network generators (generators), connected components
(components), and others.

For many network analytic problems, approximation is often
the only feasible technique to obtain results in reasonable time.
Hence, many of NETWORKIT’s modules implement approxi-
mation algorithms. For example, most centrality measures can
be computed either exactly for small to medium networks or
approximated for larger networks.

We use Cython as a glue between C++ and Python code
(cython.org). Shared-memory parallelism (via OpenMP) is
used extensively throughout the C++ code base.

A. Improvements on Previous NETWORKIT Work

We brieﬂy report selected features that were added to
NETWORKIT since previous reports [3], [4].1 Additions to
the centrality module include a normalization strategy
for PageRank based on Ref. [5] that makes PageRank scores
comparable across different graphs. New community detection
algorithms include: a parallel version of the Leiden algorithm
[6], a parallel version of the Louvain algorithm based on
map equation [7], and the algorithm by McDaid et al. [8] to
compute the Normalized Mutual Information, a widely used
similarity measure to compare pairs of communities. These
community detection algorithms can easily be integrated into
the RIN visualization widget that we develop in Section V.
For a description of a new graph drawing module based on
Plotly (https://github.com/plotly), see Section V.

B. Ecosystem

NETWORKIT currently supports general-purpose environ-
ment managers conda (channel conda-forge, https://
conda-forge.org) and brew (for macOS, https://brew.sh) as
well as the HPC-focused manager spack (https://spack.io).
While brew and conda packages are provided as pre-built
binary packages per default, spack is useful for creating
optimized binaries for a complete toolchain. conda is one
of the more popular package managers for data scientists,
having the majority of analysis tools available while providing
a low entry barrier for setting up working environments.
Prominent frontends for creating analysis workﬂows like vari-
ants of Jupyter (such as the notebook server or the Jupyter

Besides supporting package managers, NETWORKIT is
available on all major platforms (Linux, macOS, and Windows
OS) as a pre-built wheel-package for x86 64 architectures,
Linux aarch64 and Apple arm64 via PyPi. Hard dependencies
in order provide easy
for NETWORKIT are kept minimal
integration into established toolchains. The binary version only
needs scipy and numpy [13], [14]. Every other dependency
is either bundled (like tlx) or optional (like pandas and
tabulate).

More complex data analysis workﬂows, often spanning
different ﬁelds of expertise, introduce additional requirements
and complexity. Furthermore, from the maintainer’s perspec-
tive, the ever-growing list of ecosystems makes it harder to
keep up. Often, a certain required package or version is only
available for a certain platform or manager tool, whereas
composing an environment with different tools is not always
possible. Hence, NETWORKIT is also available as a Docker
image providing a complete environment with all optional
and non-optional dependencies and software. The image is
based on a Jupyter base image, which itself is based on an
LTS version of Ubuntu Linux. It includes documentation and
interactive tutorials, accessible via a pre-conﬁgured Jupyter-
Lab instance.

III. NETWORKIT IN THE CLOUD

There are some use cases like multi-user setups or on-
demand services, which can be a complex endeavor itself
when starting with container images as the only tool. We
deal with this by using the Dockerﬁle of NETWORKIT as a
basis for providing an on-demand cloud service based on a
Kubernetes [15], [16] infrastructure. By having NETWORKIT
available as a cloud-based service, domain experts can try
out
the complex environments with a low barrier and in
a collaborative manner. An application hosted on the cloud
to interactively gain an
server enables the domain expert
intuitive understanding of the network analysis tools that
NETWORKIT offers and how they map onto the domain
problem under investigation. In contrast to public services
such as Binder (https://mybinder.org), hosting a pre-bundled
software environment leaves more ﬂexibility when dealing
with features such as multi-users or mounting external data
sets. For many use cases, publicly available services are also
not sufﬁcient regarding CPU and memory requirements. This
is especially true when – like in the use case presented in
this paper – interactivity or extensive software setups spanning
multiple scientiﬁc areas are part of the requirements. In the
following, we describe our approach of an on-premise state-
of-the-art Kubernetes infrastructure and how it can be utilized
for data science problems.

A. Infrastructure

1We remark that some of the features mentioned in this section were devel-
oped in a collaborative effort with contributors external to the NETWORKIT
project.

The cloud-based implementation of NETWORKIT is cur-
rently relying on a RedHat OpenShift 4.9 high-availability
cluster [17], embedded on-premise in a university network. For

2

Fig. 1. Setup for a high-availability Kubernetes cluster in a private virtual
network. Availability of control plane and storage is provided by three
identical master nodes, whereas external access is managed by a load balancer
on a service node, being part of both the private and a public routable network.
A gateway node handles outgoing packages.

the general infrastructure setup, we created the cluster based
on established rules2 for production environments embedded
in a private and isolated network. The three master and two
worker nodes span a high-availability Kubernetes cluster, pro-
viding several instances of etcd key-value stores, control-plane
instances and computing resources. An additional service node
acts as a reverse proxy and load balancer for the public
services, as a DNS for the private network spanned by all
participants and an entry point for the Kubernetes API. All
trafﬁc into the cluster is routed through this node. The gateway
node handles the reverse route from within the cluster to WAN,
equipped with an additional ACL-based ﬁrewall and ﬁlter
mechanism to monitor trafﬁc. This approach of embedding
a HA-cluster helps to secure the Kubernetes nodes, providing
good scalability in terms of adding more resources.

Hardware requirements for all except the worker nodes can
be kept at a moderate level. Master and service nodes need at
least 4 CPUs and 16 GB of memory in order to provide good
scalability, which are also the speciﬁcations used in our current
implementation. Worker nodes should always scale with the
desired use case, which for NETWORKIT means to deal with
data analysis workﬂows in one or several container instances.
The network stack involves at least a Jupyter instance for the
service endpoint and data is likely duplicated during the work-
ﬂow process. Hence, memory to manage data structures and
web frontends is the most important requirement, followed by
CPU cores for parallel processing. The benchmarks presented
in this paper were conducted with a limit of 10 vCores and
16 GB of memory for each instance, which has proven to work
well for our use case.

2https://kubernetes.io/docs/setup/production-environment/

Fig. 2. Kubernetes entities used to create a service for a typical data analysis
workﬂow based on Jupyter notebooks. A namespace contains all relevant
entities, including a central deployment and all necessary additions (secrets,
volume, service account). Exposing the deployment is done via a service +
ingress/route deﬁnition.

B. Service Deﬁnition

Setup of the public service for the end user is done by
deﬁning Kubernetes entities as shown in Figure 2. The process
is following state-of-the-art rules by creating a cluster internal
deployment resource and enabling external access via a ser-
vice and ingress/route resource. For the deployment resource,
a customized JupyterHub Docker container is built, adding
necessary authentication and instance spawner plugins. While
the authentication plugin can be chosen arbitrarily based on
the hosting infrastructure and use case, it is recommended
to use KubeSpawner for the spawner plugin. This allows
JupyterHub to start on-demand additional Kubernetes pods
hosting the user instances, with proxy access managed within
the original deployment. Realizing pod spawning from within
a running pod in a Kubernetes cluster is done via connect-
ing a service account (SA) to the JupyterHub deployment.
This SA has to be granted at
least view permissions for
Kubernetes events and permissions to spawn, list, and delete
pod resources. The JupyterHub instance is created in its own
namespace, so that different service endpoints cannot interfere
with each other. Therefore, also the permissions for the SA
can be local to that namespace in order to minimize to risks
in case of a security-related incident. Persistence concerning
conﬁguration and accounting is achieved by adding physical
volumes (PV) and physical volume claims (PVC), containing
a pre-conﬁgured jupyterhub_config.py ﬁle and user
database. The conﬁg contains information such as image name

3

Gateway NodeServices: DHCP, Firewall,GatewayPublic /  Enterprise Network Private NetworkWANLANWANLANMaster Nodes (1-3)Services: etcd Storage,Control Plane Worker Nodes (1-X)Services: ComputationalRessources Inbound TrafﬁcOutbound TrafﬁcService NodeServices: Proxy, DNS, API-Endpoint,  Load Balancer RIN-exploration (Namespace)JupyterHub-app  (Deployment)networkit-hub (Pod)                               hub-service (Service)Type: ClusterIP172.30.XXX.XXXhub-route (Route/Ingress)Host: https://nwk-service.domain.com Path: /service-pathhub-volume(PersistentVolume)jupyterhub_conﬁg.pyDBjupyterhub/ nativeauthenticatorjupyterhub/ kubespawnerhub-account(Service Account)view:  Eventsedit: PodsData Analysis Workﬂow(Pod)spawns 1 to Nhub-secret-vault  (Secret)Entries: Pull-Secrets, ...and pull secrets for user instances or cgroup limits.

Reaching the service in the private cluster is done by
attaching a domain/IP to the public interface of the service
node. The reverse proxy connects the public WAN interface
with the cluster network and forwards a service query on
http/https port to one of the worker nodes based on a source
balanced policy. Each node runs a replicated cluster-internal
second reverse proxy, which has a preﬁx-based routing. Based
on the URL deﬁned ingress/route entity, the reverse proxy
forwards the package to the pod on the appropriate worker
node.

In order to create a certain use case, there are two possi-
bilities. (i) The pod can be exchanged or (ii) another names-
pace with its own JupyterHub instance can be created. Both
strategies can be achieved easily, making this general approach
versatile and supported by all variants of cloud providers. A
generalized version of the service deﬁnition used in this paper
is available on Github3.

As mentioned in Section II-B, the underlying workﬂow
analysis pod for this use case is based on a NETWORKIT
container. For the use case of analyzing RINs, a custom
container is built; it provides a ready-to-use environment with
packages for network and data workloads, protein processing,
and visualization, tailored to be used in a Jupyterlab frontend.
Entry point for notebooks is an automatically activated conda
environment with over 200 packages, handling both setup and
Python APIs4.

IV. RESIDUE INTERACTION NETWORKS (RINS) FOR
MOLECULAR DYNAMICS SIMULATIONS OF PROTEINS

Here, we brieﬂy introduce the application domain of protein
MD simulations. We describe how network analysis can be
applied to better understand the structural dynamics of proteins
from large MD data sets. Proteins are complex and dynamic
systems made up of a linear sequence of amino acids. The
interactions between their residues – the side chains of the
amino acids – determine the three-dimensional structure of
the proteins [18]. How this structure changes over time deter-
mines the function of the protein. These structural dynamics
of proteins play a central role in biological processes like
protein folding [19], cellular signaling [20], or protein-protein
interactions [21].

tool

Molecular dynamics simulations offer an increasingly pow-
erful computational
to investigate these processes at
temporal and spatial resolutions that are hard or impossible
to attain experimentally [22]. In an MD simulation, a pro-
tein is simulated as it evolves under the forces of classical
mechanics. The data sets resulting from these simulations are
large, high-dimensional time series of protein structures called
trajectories. The individual frames of the trajectory contain
the Cartesian coordinates of all atoms in the system [23].
An MD simulation of a protein can have millions of frames
and thousands of dimensions. The handling and analysis of

3https://github.com/networkit/networkit-cloud
4A link to a playground for review purposes can be found at the end of

the paper.

MD data is commonly performed in analysis pipelines built in
Python, chieﬂy due to the large community working on and
with Python tools for data transformation, machine learning
applications, and visualizations [24]–[26].

However, extracting insights on the protein function from
these time series of atom coordinates is challenging. A pow-
erful approach to make the analysis of protein structural
dynamics more tractable is to describe the three-dimensional
structure of the protein as a graph. Graphs are a natural
formalism to capture protein structure [27] and they make it
possible to treat the protein system with a rigid, mathematical
formalism and apply an established set of algorithms to
better understand it. To analyze entire trajectories from MD
simulations, each frame of the simulation can be translated into
a graph representing the underlying protein structure. Such
a graph is referred to as an amino acid network, side-chain
network, or residue interaction network (RIN) [28]. In a RIN,
the nodes of the graph represent the amino acids and the edges
represent their interactions.

There is a host of methods to translate proteins into RINs.
A common way is based on the spatial distances between the
residues in the protein structure. Depending on the question,
the residue-residue distance can be determined in different
ways, such as the distance between the C-α atoms of each
residue, the centers of mass of the residues, or the distance
between whichever two atoms are closest to each other in
the respective residues (minimum distance). Commonly, the
residues (nodes) are considered to be interacting (connected
by an edge), if a residue-residue distance is within a given
cut-off distance. The cut-off usually varies between 4 ˚A to
8.5 ˚A, depending on the way the distance was calculated
and the scientiﬁc question [29], [30]. The resulting RINs are
commonly unweighted and undirected graphs representing the
protein structure. An example for a RIN constructed from the
fast folding protein α3D is shown in Figure 3 next to its three-
dimensional structure.

Once the protein structure is suitably translated into a graph,
many different network-analytic methods can be applied to
better understand the protein structure and how it changes over
time. The network analysis of RINs has been applied to answer
a plethora of questions on the relationship between protein
structure and function, e.g. analyzing the role of mutations in
the SARS-CoV-2 spike protein [31]. Various node centralities
have been used to identify functionally important residues
in protein structures, such as protein-protein interfaces and
active sites. Often several residue centralities are combined
with each other or with additional information on the residues,
such as surface accessibility, to improve the results [32]–[34].
Community detection algorithms have been applied to ﬁnd
structural modules in the protein [35], [36], to understand
regulatory mechanisms [37] and to investigate information
ﬂow within the protein [38].

it
When starting the analysis of a new protein system,
can be difﬁcult to decide which translation algorithm and
which network analysis algorithm is best suited to answer the
underlying biological question about it [28], [39]. There is

4

An application that makes it possible to interactively vary
all relevant parameters and visually follow changes in RIN
topology in real time can give an intuitive understanding of
the relationship between the protein system and the network
description. In addition not only the topology, but also the
geometric structure resembling the protein folding is of in-
terest, making a 3D representation more suitable than 2D.
To efﬁciently explore the parameter space outlined above, a
tool that can support such a visualization task has several
requirements.

[R1] It should include all network analysis tools of inter-
est, such as centralities and community detection algorithms.
[R2] It should seamlessly integrate into a Python analysis
workﬂow, such that
it can be integrated easily with any
upstream data transformation tasks (e.g. data ﬁltering and se-
lection) or further downstream analysis (e.g. applying machine
learning algorithms on the extracted network features). [R3] It
should calculate and visualize all network features fast enough
to facilitate at least near real-time, interactive exploration of
the parameter space. [R4] It should accommodate the simul-
taneous manipulation of the parameters of interest (cut-off for
graph translation, network metric and trajectory frame) and the
visualization of the resulting network features and topologies
in one user interface. [R5] It should be able to handle large,
high-dimensional data sets from MD trajectories.

A. Application Design

NETWORKIT does not directly implement any visualization
GUI (although it includes some graph drawing algorithms).
Instead, we rely on well-known and established tools to draw
the GUI of our visualization widgets. We provide adapters that
allow these tools to take NETWORKIT graphs as input. With
the release of version 3.2, a streaming client for GEPHI [45]
has been implemented. GEPHI is a well-known and powerful
tool for the visualization of networks providing an interface
for static and dynamic graphs and algorithms for graph
drawing such as Force Atlas 2 [45] or Fruchterman
Reingold [46]. However, it is written in Java using Swing
for its GUI. Even though techniques for converting classical
Swing frontends to web technologies (e.g. WebSwing)5 have
been developed over the past years, there is no straightfor-
ward solution to directly embed Java programs into Jupyter
Notebooks and therefore Python frontends. Another approach
is to use common plotting tools based on HTML5, SVG
and Javascript and create adapters to integrate them into
Jupyter notebooks. NETWORKIT implements two modules
csbridge (2D graphs) and plotlybridge (2D and 3D
graphs), which are based on ipywidget and act as such
an adapter for embedded graph visualization. These widgets
use external Python packages ipycytoscape and plotly,
which has previously been used to visualize RINs [47]. For the
scope of this paper and the requirements for RIN-exploration,
we will focus on the module plotlybridge, while in
principle csbridge follows a similar approach.

5https://www.webswing.org

5

Fig. 3. Left: 3D-plot of the RIN of α3D at a minimum distance cut-off of
4.5 ˚A, colored by communities found by PLM community detection. Right:
Protein structure of α3D. The secondary structure elements (α-helices) are
reﬂected in the community structure of the RIN.

not one unique recognized way to best use network analysis
for investigating a protein. And since each protein system
is different and has different underlying scientiﬁc questions,
it is vital to gain an understanding of the system and how
network-analytic tools capture it. For example, it has been
shown that the choice of the distance criterion can inﬂuence
which secondary structure features are emphasized [40] and
changes in the distance cut-off can drastically alter the RIN
topology, e.g. inﬂuencing the number of hubs and connected
components [41]. Different centralities can indicate different
roles for individual residues. A high betweenness centrality for
a residue could indicate that the residue plays an important
role in a protein-protein interface [32], in information ﬂow
through the protein [38], or in maintaining a speciﬁc fold [42].
A high closeness centrality, in turn, could indicate a role in
the protein’s active site or a ligand-binding site [33], [34],
[43]. There are many applications of community detection
algorithms on RINs to investigate various questions, and
different community detection algorithms can differ in the
structural features they capture [44].

V. VISUALIZING RINS WITH NETWORKIT
AND JUPYTER NOTEBOOKS

To get a good understanding of how the network-analytic
measures map onto the protein system of interest and how
they change with different cut-off values for translating the
protein structure into an RIN, it is crucial to be able to visually
explore the parameter space for the cut-off and the network
measures. Since proteins are dynamic structures that change
during the course of a simulation, it is also crucial to be
able to perform these analyses on all protein structures of
the simulation trajectory. This can convey an understanding
how the RIN topology and corresponding network measures
change over time and with different cut-off values.

containing the nodes represented by 2D-circle shapes and
the other containing the edges represented by 2D-lines. Pro-
jecting 2D-shaped nodes and edges correctly, while allowing
for change of perspective and zoom is done by Plotly
itself. The plotlybridge-widget is ﬁnalized by deﬁning
a layout, including axis, colors and 3D camera modiﬁcations.
Since generating a layout and creating the data is done in
Python/C++, most of the heavy computation is done on the
server side. This allows to draw graphs with up to 50k nodes
in a few seconds on commodity hardware (see Figure 4).

Using the Python API and the speed of NETWORKIT, the
code-snippet from the plotlybridge widget shows that
a few lines of code can already create an interactive visual
inspection tool for small and medium-sized graphs. Adding
information with respect
to different network metrics like
centrality measures or community structures is easily achieved
by node coloring and text-box displays. Since the widget is
implemented as an ipywidget, we achieve this by stacking
the basic version of the plotlybridge-widget into a more
complex GUI and adding functionality for transforming node
properties to color scales. In addition to the widget of the
use case in Section IV, we add more functionality tailored for
inspection of proteins represented by RINs.

B. Benchmarking Results

The ﬁnal software version6 fulﬁlling the requirements as
stated above is shown in Figure 5. The code is also available
on Github7. We add interactive sliders, which let the user
choose between different popular network measures on the ﬂy.
For smaller networks like RINs of proteins with around 100-
1000 nodes, computing centrality or community properties
only takes a sub-second time span in total. Two additional
sliders let the domain expert choose between different RIN
trajectory frames from the simulation of a protein and different
cut-off distances for translating the protein structure into an
graph. Both values do not change the number of nodes in
the network, but inﬂuence layouts and the number of edges.
These changes in the network topology also imply changes
to the node properties and therefore trigger an update of the
chosen network measure. Additional misc. components in the
GUI provide quality of life functions and let the domain expert
choose whether re-computation is done automatically or on
demand. By storing the most recent computed node property
within a buffer in the widget, it is also possible to visualize the
delta between different cut-off distances or trajectory frames.
On the upper half of the widget, two side-by-side 3D graph-
plots show the same RIN, but with different layouts. The
left plot shows the real conformation of the protein with
the node positions determined by the positions of the C-
α-atoms in the protein. The right plot shows the Maxent-
Stress layout, computed by NETWORKIT. Having the two
plots side-by-side adds an additional layer for decision making,
in particular on 1) how the chosen network metric matches the

6A link to a playground for review purposes can be found at the end of

the paper.

7https://github.com/hu-macsy/2022-paper-RIN-visualization

7

8

9

10

11

12

13

14

15

Fig. 4. 3D-plot generated by plotlybridge-module, showing a graph with
4941 nodes and 6594 edges. With a few lines of codes, the nodes display
overlay information like centrality measures by using color-palettes.

it

Like GEPHI, Plotly (https://plotly.com) is a well known
tool for visualization;
is, however, focused on plotting
charts and mappings in both 2D and 3D. As a consequence
there are no graph drawing algorithms available – the user
has to provide coordinates for available data points. For the
Python interface, each chart in Plotly is represented by
a plotly.graph_objects.FigureWidget, which is a
custom ipywidget usable for embedding in more complex
GUIs. One or more data sets can be added to the widget by
calling add_traces().

1 import networkit as nk
2 import plotly.graph_objs as go
3
4 # plotlyWidget-functionality (shortened)
5 def plotlyWidget(G, scores):
6

maxLayout = nk.viz.MaxentStress(G, 3, 3)
maxLayout.run()
coordinates = maxLayout.getCoordinates()

figWidget = go.FigureWidget()
nodeScatter, edgeScatter = go.Scatter3d(...), go
.Scatter3d(...)
figWidget.add_traces(nodeScatter, edgeScatter)
figWidget.layout = go.Layout(...)
...
return figWidget

16
17 # Graph init + score-computation
18 G = nk.readGraph("karate.graph", nk.Format.METIS)
19 betCen = nk.centrality.Betweenness(G)
20 betCen.run()
21 scores = betCen.scores()
22 plotlyWidget(G, scores)

Listing 1.

Initialization of plotlybridge-module (shortened).

NETWORKIT’s plotlybridge is implemented as a
Python function, called by handing over a graph object G
and an algorithm with the ability to compute node scores.
Before the visualization ﬁgure is created, 3D coordinates
have to be generated. For this, the Maxent-Stress algorithm
from NETWORKIT [48] is used. The main intention of this
algorithm is to solve an optimization problem that computes
the three-dimensional structure of biomolecules, which makes
it also suitable for computing the layout for our current use
case. Listing 1 shows an abstraction of how the function
works. In Line 11, two Scatter3D-objects are created, one

6

Zoom: 100%Zoom: 200%Zoom: 1000%Fig. 5. GUI for analyzing RIN using plotlybridge consisting of several ipywidgets. Top: Dual interactive 3D-graph with Protein-based layout (left)
and Maxent-Stress layout (right) for a snapshot/trajectory during simulation. Coloring of the nodes is done with a spectral color palette (blue - red), whereas
each color is deﬁned by Closeness-value of the node in the network. Bottom: Slider for selecting a trajectory frame, edge cut-off distance and network measure.

Fig. 6. Time (ms) it takes to recalculate popular centrality and community detection measures on different RIN-networks. (a) + (b) show computational time,
which NetworKit takes to update the underlying network for low and high cut-off values. Higher cut-off values increase the number of edges. (c) shows the
time for the whole update cycle as perceived on the client. This includes updating the underlying network, the widget data-handling and the Plotly-graph.

protein structure (e.g. whether putative or known functionally
important residues are identiﬁed) and 2) how the cut-off affects
the topology of the RIN (e.g. if it is far off from the actual
protein structure, the cut-off may be unsuited). The Maxent-
Stress layout can also help explain or highlight some network
features that may not be immediately obvious from the protein-
structure-based layout, such as community structure across or
within secondary structure elements.

Executing the widget is done inside the custom built con-
tainer on the cloud infrastructure (see section III) using the lab
interface from Jupyter. While all network data manipulation is
handled on the cloud infrastructure backend by NETWORKIT,
the protein to RIN conversion is done by MDtraj [49]; sup-
porting data structure and logic in Python use numpy. For
different simulations of protein folding, which are commonly

used by domain experts to assess algorithms for the analysis
of protein MD data [19], we can see in Figures 6 to 8 that
the whole computation pipeline takes sub-seconds, sometimes
even single-digit milliseconds time. Some of the results in-
clude updating the output of Jupyter notebooks,
therefore
client speciﬁcations also play a role here. All benchmarks
were carried out with Firefox 96.0 on a MacBook Pro M1
with 16GB of main memory. From Figure 6 (a) and (b)
we can see that calculating the network measures takes only
single-digit milliseconds, whereas a complete update of the
widget (subplot (c)) takes 10x more time. Depending on the
network measure, the result is suitable for ﬂuent animation or
video playback (24 fps to 60 fps). Most of the time is spent
in updating the visuals, which is natural given the necessary
update of the underlying DOM-elements. For switching be-

7

RecomputeAutomatic RecomputeID coloringFile: A3D-0-proteinNodes: 73Edges: 3890.4542Layout: Protein-basedLayout: Maxent-StressTrajectoryEdge Distance cut-off (Å)Graph MeasureCloseness CentralityA3D-0 (edges=245)2JOF-0 (edges=47)NTL9-0 (edges=111)RIN Graph Measure SwitchNetworKit update time (cut-off: 3.0 Å)012345Execution time in ms(a)Betweenness CentralityCloseness CentralityDegree CentralityEigenvector CentralityKatz CentralityPLM Community DetectionPLP Community DetectionA3D-0 (edges=989)2JOF-0 (edges=160)NTL9-0 (edges=485)RIN Graph Measure SwitchNetworKit update time (cut-off: 10.0 Å)0123456Execution time in ms(b)A3D-02JOF-0NTL9-0RIN Graph Measure SwitchTotal update time (cut-off: 10.0 Å)010203040506070Execution time in ms(c)Fig. 7. Time (ms) it takes to switch between different cut-off distances on different RIN-networks. Each switch consists of an edge update and an layout
generation phase. (d) shows the computation time NETWORKIT takes to update edges in the RIN network. (e) shows computation time NETWORKIT takes to
generate the Maxent-Stress layout. (f ) shows the time for the whole update cycle as perceived on the client. This includes updating the underlying network,
the widget data-handling and the Plotly-graph.

Fig. 8. Time (ms) it takes to switch between different trajectory frames on different RIN-networks. (g) + (h) show the computation time NETWORKIT takes
to update the underlying network for low and high cut-off values. Higher cut-off values increase the number of edges. (i) shows the time for the whole update
cycle as perceived on the client. This includes updating the underlying network, the widget data-handling and the Plotly-graph.

tween different cut-off distances (see Figure 7) and trajectory
frames (see Figure 8), the situation is somewhat reversed.
Most of the overall update time is spent during updating the
underlying network in NETWORKIT, whereas the functionality
for switching cut-off distances and trajectory frames is similar,
leading to nearly identical running times for equal cut-off
distances. Both routines consist of adding/removing edges and
recomputing the Maxent-Stress layout phase. From Figure 7
(d) and (e) we can see that recomputing the layout takes
the majority of the time with around 300 ms to 400 ms. The
complete update adds roughly 100 ms for a cut-off change
event (see Figure 7 (f )) and 200 ms for a frame change event
(see Figure 8 (h)). This is expected, since the number and
position of nodes for the protein layout remain equal between
different cut-off distances. Therefore for this event, the protein-
based layout graph only needs to update the DOM-elements
representing the edges. When a trajectory frame is changed,
though, the protein structure and therefore the position of
nodes in the RIN have changed – making a complete update
to all visualization-related DOM-elements necessary. Note
that the maximum amount of time it takes to update the
widget is occurring on changing the trajectory, while having
selected a network measure. The related update functions are
called subsequently, leading to a total loop time of up to
approx. 600 ms for networks with around 1000 edges (see
Figure 8 (i)). As long as the resource provisioning does not

create bottlenecks on the cloud infrastructure, the server-based
performance metrics are stable and provide real-time results.

VI. RELATED WORK

Other graph toolkits: Several network analysis tools
are publicly available and they offer a wide range of trade-
offs between performance, usability, and number of features.
NetworkX [50] is a popular Python package, can be installed
and used with very little effort, and offers a wide range of
algorithms and features. It is, however, written in pure Python,
and the performance is thus limited.

Similarly to NETWORKIT, packages

such as graph-
tool [51], igraph [52], or SNAP [53] implement performance-
aware algorithms in C++ (in the igraph case: C) and provide
bindings for Python. This architecture offers good usability
without sacriﬁcing performance – see Section II-B. However,
it requires to compile the C/C++ core, which is an additional
burden to be considered.

Other tools such as Ligra [54], Stinger [55], Hornet [56],
and others (see Ref. [57] for an exhaustive overview) are
available only as C++ libraries, and provide a collection
of high-performance algorithms – often much more limited
compared to the aforementioned packages.

Other tools for RIN analysis: There are numerous tools
available for constructing, analyzing and visualizing RINs (see
[28], [29], [58] for detailed overviews). There are plug-ins
for established visualization software, such as RINalyzer [59],

8

A3D-02JOF-0NTL9-0RIN Cut-off Distance SwitchNetworKit update time (edge update)0.00.20.40.60.81.01.21.4Execution time in ms(d)3.0 Å4.0 Å5.0 Å6.0 Å7.0 Å8.0 Å9.0 Å10.0 ÅA3D-02JOF-0NTL9-0RIN Cut-off Distance SwitchNetworKit update time (layout generation)0100200300400500Execution time in ms(e)A3D-02JOF-0NTL9-0RIN Cut-off Distance SwitchTotal update time (edge update + layout generation)0100200300400500Execution time in ms(f)A3D-0(avg. edges=248)2JOF-0(avg. edges=51)NTL9-0(avg. edges=121)RIN Trajectory Frame SwitchNetworKit update time (cut-off: 3.0 Å)0100200300400500600Execution time in ms(g)A3D-0(avg. edges=995)2JOF-0(avg. edges=159)NTL9-0(avg. edges=491)RIN Trajectory Frame SwitchNetworKit update time (cut-off: 10.0 Å)0100200300400500600Execution time in ms(h)A3D-0(avg. edges=995)2JOF-0(avg. edges=159)NTL9-0(avg. edges=491)RIN Trajectory Frame SwitchTotal update time (cut-off: 10.0 Å)0100200300400500600Execution time in ms(i)which ties in with structureViz [60] to link Cytoscape [61]
and the molecular structure viewer Chimera [62]. Standalone
software like gRINN [63] and Webservers like CMWeb [64]
offer GUI-based visualization tools with a varying number of
features. However, these tools offer limited capabilities when it
comes to handling large data sets of full simulation trajectories
with real-time responsiveness. They often require separate
installation or depend on other software. To our knowledge,
none of the existing tools can be integrated seamlessly into
python analysis workﬂows, limiting the possibilities to adapt
the network analysis to user-speciﬁc needs.

VII. CONCLUSIONS AND FUTURE WORK

With a cloud based solution based on NETWORKIT and
JupyterHub, it is possible for domain scientists to have a
low barrier entry into learning how to adapt functions from
network analysis to their speciﬁc problems. Having ready-to-
use environments on cloud-hosted servers enables the user to
claim resources on the ﬂy and perform collaborative and share-
able research. Based on the nature of the technology, most of
the expensive recomputation is delegated to the infrastructure,
leading to responsive applications without the need for setting
up toolchains or an expensive client workstation. Our approach
of creating a cloud service is using current established and
generalized techniques, which makes it easily transferable to
other cloud infrastructures like public hosters. One future
contribution could be a transition to automation tools such
as Helm or Terraform, which would increase portability and
enable resource provisioning based on a predeﬁned use-case
given by a single Dockerﬁle and data sets.

As shown with our visualization application for protein
RINs, a fast GUI-based frontend can be achieved without
considerable effort. It allows for ﬂexible and interactive ex-
ploration of large data sets. A well-maintained Python API
enables the adaptation to user-speciﬁc needs. With only few
additions, the application can be extended by user-deﬁned
residue features, which could be used to better capture the
structural features of the protein [32], [33]. The application
could serve to explore how community detection algorithms
can aid in coarse graining the protein structure,
to make
simulations of larger protein systems at reduced resolution
computationally tractable [28]. Finally, it is also possible to
integrate the application into Machine Learning workﬂows,
using tools from the Python data-science domain. Graph
embeddings, like node2vec [65] – which is already part of
NETWORKIT – or graph neural networks could be applied to
reduce the complexity of the protein simulation data and better
understand the role of individual residues in protein dynamics.

Playground for review purposes:

https://dev.networkit.informatik.hu-berlin.de/rin-vis-review/
(Username: reviewer, Password: BrotherDialectMonopoly?)

REFERENCES

[1] M. Newman, Networks. 2018.
[2] J. Leskovec, A. Rajaraman, and J. D. Ullman, Mining of Massive

Datasets, 2nd Ed. 2014.

[3] C. L. Staudt, A. Sazonovs, and H. Meyerhenke, “Networkit: A tool
suite for large-scale complex network analysis,” Netw. Sci., vol. 4, no. 4,
pp. 508–530, 2016.

[4] E. Angriman, A. van der Grinten, M. Hamann, H. Meyerhenke, and
M. Penschuck, “Algorithms for large-scale network analysis and the
networkit toolkit,” 2022.

[5] K. Berberich, S. J. Bedathur, G. Weikum, and M. Vazirgiannis, “Com-
paring apples and oranges: normalized pagerank for evolving graphs,”
in WWW, pp. 1145–1146, ACM, 2007.

[6] V. A. Traag, L. Waltman, and N. J. van Eck, “From louvain to leiden:
guaranteeing well-connected communities,” CoRR, vol. abs/1810.08473,
2018.

[7] L. Bohlin, D. Edler, A. Lancichinetti, and M. Rosvall, “Community de-
tection and visualization of networks with the map equation framework,”
in Measuring scholarly impact, pp. 3–34, Springer, 2014.

[8] A. F. McDaid, D. Greene, and N. J. Hurley, “Normalized mutual
information to evaluate overlapping community ﬁnding algorithms,”
CoRR, vol. abs/1110.2515, 2011.

[9] J. Stubbs, J. Looney, M. Poindexter, E. Chalhoub, G. J. Zynda, E. S.
Ferlanti, M. Vaughn, J. M. Fonner, and M. Dahan, “Integrating jupyter
into research computing ecosystems: Challenges and successes in archi-
tecting jupyterhub for collaborative research computing ecosystems,” in
PEARC, pp. 91–98, ACM, 2020.

[10] L. A. Barba, “The python/jupyter ecosystem: Today’s problem-solving
environment for computational science,” Comput. Sci. Eng., vol. 23,
no. 3, pp. 5–9, 2021.

[11] H. Fangohr, T. Kluyver, and M. DiPierro, “Jupyter in computational

science,” Comput. Sci. Eng., vol. 23, no. 2, pp. 5–6, 2021.

[12] J. F. Pimentel, L. Murta, V. Braganholo, and J. Freire, “A large-scale
study about quality and reproducibility of jupyter notebooks,” in MSR,
pp. 507–517, IEEE / ACM, 2019.

[13] C. R. Harris, K. J. Millman, S. van der Walt, R. Gommers, P. Virtanen,
D. Cournapeau, E. Wieser, J. Taylor, S. Berg, N. J. Smith, R. Kern,
M. Picus, S. Hoyer, M. H. van Kerkwijk, M. Brett, A. Haldane, J. F.
del R´ıo, M. Wiebe, P. Peterson, P. G´erard-Marchant, K. Sheppard,
T. Reddy, W. Weckesser, H. Abbasi, C. Gohlke, and T. E. Oliphant,
“Array programming with numpy,” Nat., vol. 585, pp. 357–362, 2020.
[14] P. Virtanen, R. Gommers, T. E. Oliphant, M. Haberland, T. Reddy,
D. Cournapeau, E. Burovski, P. Peterson, W. Weckesser, J. Bright,
S. van der Walt, M. Brett, J. Wilson, K. J. Millman, N. Mayorov,
A. R. J. Nelson, E. Jones, R. Kern, E. Larson, C. J. Carey, I. Polat,
Y. Feng, E. W. Moore, J. VanderPlas, D. Laxalde, J. Perktold, R. Cim-
rman, I. Henriksen, E. A. Quintero, C. R. Harris, A. M. Archibald,
A. H. Ribeiro, F. Pedregosa, P. van Mulbregt, and SciPy, “Scipy 1.0-
fundamental algorithms for scientiﬁc computing in python,” CoRR,
vol. abs/1907.10121, 2019.

[15] D. Bernstein, “Containers and cloud: From LXC to docker to kuber-

netes,” IEEE Cloud Comput., vol. 1, no. 3, pp. 81–84, 2014.

[16] B. Burns, J. Beda, and K. Hightower, Kubernetes: up and running: dive

into the future of infrastructure. 2019.

[17] B. Linzel, E. Zhu, G. Flores, J. Liu, and S. G. Dikaleh, “How can
openshift accelerate your kubernetes adoption: a workshop exploring
openshift features,” in CASCON, pp. 380–381, ACM, 2019.

[18] D. Shcherbinin and A. Veselovsky, “Analysis of Protein Structures
Using Residue Interaction Networks,” in Challenges and Advances in
Computational Chemistry and Physics, vol. 27, pp. 55–69, Springer,
2019.

[19] K. Lindorff-Larsen, S. Piana, R. O. Dror, and D. E. Shaw, “How fast-
folding proteins fold,” Science, vol. 334, no. 6055, pp. 517–520, 2011.
[20] A. Berg, L. Franke, M. Scheffner, and C. Peter, “Machine Learning
Driven Analysis of Large Scale Simulations Reveals Conformational
Characteristics of Ubiquitin Chains,” Journal of Chemical Theory and
Computation, vol. 16, no. 5, pp. 3205–3220, 2020.

[21] M. Sikora, S. von B¨ulow, F. E. Blanc, M. Gecht, R. Covino, and G. Hum-
mer, “Computational epitope map of SARS-CoV-2 spike protein,” PLoS
Computational Biology, vol. 17, pp. e1008790–e1008790, 4 2021.
[22] T. Schlick and S. Portillo-Ledesma, “Biomolecular modeling thrives in
the age of technology,” Nature Computational Science, vol. 1, pp. 321–
331, 5 2021.

[23] S. A. Hollingsworth and R. O. Dror, “Molecular dynamics simulation

for all,” Neuron, vol. 99, no. 6, pp. 1129–1143, 2018.

[24] F. No´e, A. Tkatchenko, K.-R. M¨uller, and C. Clementi, “Machine Learn-
ing for Molecular Simulation,” Annual Review of Physical Chemistry,
2020.

9

[44] L. Di Paola and A. Giuliani, “Protein contact network topology: a natural
language for allostery,” Current Opinion in Structural Biology, vol. 31,
pp. 43–48, 2015.

[45] M. Bastian, S. Heymann, and M. Jacomy, “Gephi: An open source
software for exploring and manipulating networks,” in ICWSM, The
AAAI Press, 2009.

[46] T. M. J. Fruchterman and E. M. Reingold, “Graph drawing by force-
directed placement,” Softw. Pract. Exp., vol. 21, no. 11, pp. 1129–1164,
1991.

[47] R. Saini, C. Globisch, L. Franke, C. Peter, and A. Debnath, “Interactions
Determining the Structural Integrity of the Trimer of Plant Light Har-
vesting Complex in Lipid Membranes,” Journal of Membrane Biology,
vol. 254, no. 2, pp. 157–173, 2021.

[48] M. Wegner, O. Taubert, A. Schug, and H. Meyerhenke, “Maxent-stress
optimization of 3d biomolecular models,” in ESA, pp. 70:1–70:15,
Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik, 2017.

[49] R. T. McGibbon, K. A. Beauchamp, M. P. Harrigan, C. Klein, J. M.
Swails, C. X. Hern´andez, C. R. Schwantes, L.-P. Wang, T. J. Lane,
and V. S. Pande, “Mdtraj: a modern open library for the analysis of
molecular dynamics trajectories,” Biophysical journal, vol. 109, no. 8,
pp. 1528–1532, 2015.

[50] A. Hagberg, P. Swart, and D. S Chult, “Exploring network structure, dy-
namics, and function using networkx,” tech. rep., Los Alamos National
Lab.(LANL), Los Alamos, NM (United States), 2008.
[51] T. P. Peixoto, “The graph-tool python library,” ﬁgshare, 2014.
[52] G. Csardi, T. Nepusz, et al., “The igraph software package for complex
network research,” InterJournal, complex systems, vol. 1695, no. 5,
pp. 1–9, 2006.

[53] J. Leskovec and R. Sosic, “SNAP: A general-purpose network analysis
and graph-mining library,” ACM Trans. Intell. Syst. Technol., vol. 8,
no. 1, pp. 1:1–1:20, 2016.

[54] J. Shun and G. E. Blelloch, “Ligra: a lightweight graph processing
framework for shared memory,” in PPOPP, pp. 135–146, ACM, 2013.
[55] D. Ediger, R. McColl, E. J. Riedy, and D. A. Bader, “STINGER: high
performance data structure for streaming graphs,” in HPEC, pp. 1–5,
IEEE, 2012.

[56] F. Busato, O. Green, N. Bombieri, and D. A. Bader, “Hornet: An efﬁcient
data structure for dynamic sparse graphs and matrices on gpus,” in
HPEC, pp. 1–7, IEEE, 2018.

[57] M. E. Coimbra, A. P. Francisco, and L. Veiga, “An analysis of the graph

processing landscape,” J. Big Data, vol. 8, no. 1, p. 55, 2021.

[58] B. Chakrabarty and N. Parekh, “NAPS : Network Analysis of Protein

Structures,” vol. 44, no. May, pp. 375–382, 2016.

[59] N. T. Doncheva, K. Klein, F. S. Domingues, and M. Albrecht, “Analyz-
ing and visualizing residue networks of protein structures,” 2011.
[60] J. H. Morris, C. C. Huang, P. C. Babbitt, and T. E. Ferrin, “structure-
Viz: linking Cytoscape and UCSF Chimera,” Bioinformatics, vol. 23,
pp. 2345–2347, 9 2007.

[61] P. Shannon, A. Markiel, O. Ozier, N. S. Baliga, J. T. Wang, D. Ramage,
N. Amin, B. Schwikowski, and T. Ideker, “Cytoscape: a software en-
vironment for integrated models of biomolecular interaction networks,”
Genome research, vol. 13, pp. 2498–2504, 11 2003.

[62] E. F. Pettersen, T. D. Goddard, C. C. Huang, G. S. Couch, D. M. Green-
blatt, E. C. Meng, and T. E. Ferrin, “UCSF Chimera—A visualization
system for exploratory research and analysis,” Journal of Computational
Chemistry, vol. 25, pp. 1605–1612, 10 2004.

[63] O. Serc¸ino˘glu and P. Ozbek, “gRINN: a tool for calculation of residue
interaction energies and protein energy network analysis of molecular
dynamics simulations,” Nucleic Acids Research, vol. 46, pp. W554–
W562, 7 2018.

[64] D. Kozma, I. Simon, and G. E. Tusnady, “CMWeb: an interactive on-
line tool for analysing residue-residue contacts and contact prediction
methods,” Nucleic Acids Research, vol. 40, pp. W329–W333, 7 2012.
[65] A. Grover and J. Leskovec, “node2vec: Scalable feature learning for

networks,” in KDD, pp. 855–864, ACM, 2016.

[25] M. Ceriotti, “Unsupervised machine learning in atomistic simulations,
between predictions and understanding,” Journal of Chemical Physics,
vol. 150, 4 2019.

[26] A. Glielmo, B. E. Husic, A. Rodriguez, C. Clementi, F. No´e, and
A. Laio, “Unsupervised Learning Methods for Molecular Simulation
Data,” 8 2021.

[27] L. Di Paola, M. De Ruvo, P. Paci, D. Santoni, and A. Giuliani, “Pro-
tein contact networks: An emerging paradigm in chemistry,” Chemical
Reviews, vol. 113, pp. 1598–1613, 3 2013.

[28] M. Foss´epr´e, L. Leherte, A. Laaksonen, and D. P. Vercauteren, “Under-
standing the Structure and Dynamics of Peptides and Proteins Through
the Lens of Network Science,” in Biomolecular Simulations in Structure-
Based Drug Discovery (L. Gervasio, Francesco and S. Vojtech, eds.),
ch. 6, pp. 105–161, Weinheim: Wiley-VC, 2018.

[29] W. Yan, J. Zhou, M. Sun, J. Chen, G. Hu, and B. Shen, “The construction
of an amino acid network for understanding protein structure and
function,” Amino acids, vol. 46, no. 6, pp. 1419–1439, 2014.

[30] R. K Grewal and S. Roy, “Modeling proteins as residue interaction
networks,” Protein and peptide letters, vol. 22, no. 10, pp. 923–933,
2015.

[31] G. M. Verkhivker and L. Di Paola, “Dynamic Network Modeling of
Allosteric Interactions and Communication Pathways in the SARS-
CoV-2 Spike Trimer Mutants: Differential Modulation of Conforma-
tional Landscapes and Signal Transmission via Cascades of Regulatory
Switches,” Journal of Physical Chemistry B, vol. 125, pp. 850–873, 1
2021.

[32] X. Jiao and S. Ranganathan, “Prediction of interface residue based on the
features of residue interaction network,” Journal of Theoretical Biology,
vol. 432, pp. 49 – 54, 2017.

[33] E. Chea and D. R. Livesay, “How accurate and statistically robust
are catalytic site predictions based on closeness centrality?,” BMC
Bioinform., vol. 8, 2007.

[34] G. Amitai, A. Shemesh, E. Sitbon, M. Shklar, D. Netanely, I. Venger,
and S. Pietrokovski, “Network analysis of protein structures identiﬁes
functional residues,” Journal of Molecular Biology, vol. 344, pp. 1135–
1146, 12 2004.

[35] W. P. Grant and S. E. Ahnert, “Modular decomposition of protein
structure using community detection,” Journal of Complex Networks,
vol. 7, pp. 101–113, 2 2019.

[36] S. Tasdighian, L. Di Paola, M. De Ruvo, P. Paci, D. Santoni, P. Palumbo,
G. Mei, A. Di Venere, and A. Giuliani, “Modules identiﬁcation in
protein structures: The topological and geometrical solutions,” Journal
of Chemical Information and Modeling, vol. 54, pp. 159–168, 1 2014.
[37] A. Del Sol, M. J. Ara´uzo-Bravo, D. Amoros, and R. Nussinov, “Modular
architecture of protein structures and allosteric communications: poten-
tial implications for signaling proteins and regulatory linkages,” Genome
biology, vol. 8, no. 5, p. R92, 2007.

[38] G. Stetz and G. M. Verkhivker, “Computational Analysis of Residue
Interaction Networks and Coevolutionary Relationships in the Hsp70
Chaperones: A Community-Hopping Model of Allosteric Regulation and
Communication,” PLOS Computational Biology, vol. 13, p. e1005299,
1 2017.

[39] A. Halder, A. Anto, V. Subramanyan, M. Bhattacharyya, S. Vishvesh-
wara, and S. Vishveshwara, “Surveying the Side-Chain Network Ap-
proach to Protein Structure and Dynamics: The SARS-CoV-2 Spike
Protein as an Illustrative Case,” 12 2020.

[40] C. H. Da Silveira, D. E. Pires, R. C. Minardi, C. Ribeiro, C. J. Veloso,
J. C. Lopes, W. Meira, G. Neshich, C. H. Ramos, R. Habesch, and
M. M. Santoro, “Protein cutoff scanning: A comparative analysis of
cutoff dependent and cutoff free methods for prospecting contacts in
proteins,” Proteins: Structure, Function and Bioinformatics, vol. 74,
pp. 727–743, 2 2009.

[41] J. S. Viloria, M. F. Allega, M. Lambrughi, and E. Papaleo, “An optimal
distance cutoff for contact-based Protein Structure Networks using side-
chain centers of mass,” Scientiﬁc Reports, vol. 7, no. 1, 2017.

[42] Z. Haratipour, H. Aldabagh, Y. Li, and L. H. Greene, “Network
Connectivity, Centrality and Fragmentation in the Greek-Key Protein
Topology,” Protein Journal, vol. 38, pp. 497–505, 10 2019.

[43] A. del Sol, H. Fujihashi, D. Amoros, and R. Nussinov, “Residue central-
ity, functionally important residues, and active site shape: Analysis of
enzyme and non-enzyme families,” Protein Science, vol. 15, pp. 2120–
2128, 9 2006.

10

