9
1
0
2

n
u
J

1
2

]

R
C
.
s
c
[

1
v
7
5
9
8
0
.
6
0
9
1
:
v
i
X
r
a

Quantitative Mitigation of Timing Side Channels

Saeid Tizpaz-Niari, Pavol ˇCern´y, and Ashutosh Trivedi

University of Colorado Boulder

Abstract. Timing side channels pose a signiﬁcant threat to the security
and privacy of software applications. We propose an approach for mitigat-
ing this problem by decreasing the strength of the side channels as mea-
sured by entropy-based objectives, such as min-guess entropy. Our goal
is to minimize the information leaks while guaranteeing a user-speciﬁed
maximal acceptable performance overhead. We dub the decision version
of this problem Shannon mitigation, and consider two variants, deter-
ministic and stochastic. First, we show that the deterministic variant is
NP-hard. However, we give a polynomial algorithm that ﬁnds an op-
timal solution from a restricted set. Second, for the stochastic variant,
we develop an approach that uses optimization techniques speciﬁc to
the entropy-based objective used. For instance, for min-guess entropy,
we used mixed integer-linear programming. We apply the algorithm to
a threat model where the attacker gets to make functional observations,
that is, where she observes the running time of the program for the same
secret value combined with diﬀerent public input values. Existing mitiga-
tion approaches do not give conﬁdentiality or performance guarantees for
this threat model. We evaluate our tool Schmit on a number of micro-
benchmarks and real-world applications with diﬀerent entropy-based ob-
jectives. In contrast to the existing mitigation approaches, we show that
in the functional-observation threat model, Schmit is scalable and able
to maximize conﬁdentiality under the performance overhead bound.

1

Introduction

Information leaks through timing side channels remain a challenging problem
[38,32,27,17,14,51,40]. A program leaks secret information through timing side
channels if an attacker can deduce secret values (or their properties) by observing
response times. We consider the problem of mitigating timing side channels. Un-
like elimination techniques [7,34,50] that aim to completely remove timing leaks
without considering the performance penalty, the goal of mitigation techniques
[29,10,52] is to weaken the leaks, while keeping the penalty low.

We deﬁne the Shannon mitigation problem that decides whether there is
a mitigation policy to achieve a lower bound on a given security entropy-based
measure while respecting an upper bound on the performance overhead. Consider
an example where the program-under-analysis has a secret variable with seven
possible values, and has three diﬀerent timing behaviors, each forming a cluster
of secret values. It takes 1 second if the secret value is 1, it takes 5 seconds if
the secret is between 2 and 5, and it takes 10 seconds if the secret value is 6

Consistent*Complete*WellDocumented*EasytoReuse**Evaluated*CAV*Artifact*AEC 
 
 
 
 
 
2

Tizpaz-Niari, ˇCern´y, and Trivedi

or 7. The entropy-based measure quantiﬁes the remaining uncertainty about the
secret after timing observations. Min-guess entropy [28,45,11] for this program is
1, because if the observed execution time is 1, the attacker guesses the secret in
one try. A mitigation policy involves merging some timing clusters by introducing
delays. A good solution might be to introduce a 9 second delay if the secret is 1,
which merges two timing clusters. But, this might be disallowed by the budget
on the performance overhead. Therefore, another solution must be found, such
as introducing a 4 seconds delay when the secret is one.

We develop two variants of the Shannon mitigation problem: deterministic
and stochastic. The mitigation policy of the deterministic variant requires us
to move all secret values associated to an observation to another observation,
while the policy of the stochastic variant allows us to move only a portion of
secret values in an observation to another one. We show that the deterministic
variant of the Shannon mitigation problem is intractable and propose a dynamic
programming algorithm to approximate the optimal solution for the problem
by searching through a restricted set of solutions. We develop an algorithm
that reduces the problem in the stochastic variant to a well-known optimization
problem that depends on the entropy-based measure. For instance, with min-
guess entropy, the optimization problem is mixed integer-linear programming.

We consider a threat model where an attacker knows the public inputs
(known-message attacks [29]), and furthermore, where the public input changes
much more often than the secret inputs (for instance, secrets such as bank ac-
count numbers do not change often). As a result, for each secret, the attacker
observes a timing function of the public inputs. We call this model functional
observations of timing side channels.

We develop our tool Schmit that has three components: side channel dis-
covery [49], search for the mitigation policy, and the policy enforcement. The
side channel discovery builds the functional observations [49] and measures the
entropy of secret set after the observations. The mitigation policy component
includes the implementation of the dynamic programming and optimization al-
gorithms. The enforcement component is a monitoring system that uses the
program internals and functional observations to enforce the policy at runtime.
To summarize, we make the following contributions:

– We formalize the Shannon mitigation problem with two variants and show
that the complexity of ﬁnding deterministic mitigation policy is NP-hard.
– We describe two algorithms for synthesizing the mitigation policy: one is
based on dynamic programming for the deterministic variant, that is in poly-
nomial time and results in an approximate solution, and the other one solves
the stochastic variant of the problem with optimization techniques.

– We consider a threat model that results in functional observations. On a set
of micro-benchmarks, we show that existing mitigation techniques are not
secure and eﬃcient for this threat model.

– We evaluate our approach on ﬁve real-world Java applications. We show that
Schmit is scalable in synthesizing mitigation policy within a few seconds and
signiﬁcantly improves the security (entropy) of the applications.

Quantitative Mitigation of Timing Side Channels

3

Example(int high, int low) {
int t_high = high, t_low = low;
while (t_high > 0) {
if (t_high % 2 == 1) {
while (t_low > 0) {
if (t_low % 2 == 1) {
res += compute(t_low,t_high);}
t_low = t_low >> 1;}}
t_high = t_high >> 1;}
return res;}

Fig. 1. (a) The example used in Section 2. (b) The timing functions for each secret
value of the program.

2 Overview

First, we describe the threat model considered in this paper. Second, we describe
our approach on a running example. Third, we compare the results of Schmit
with the existing mitigation techniques [29,10,52] and show that Schmit achieves
the highest entropy (i.e., best mitigation) for all three entropy objectives.
Threat Model. We assume that the attacker has access to the source code
and the mitigation model, and she can sample the run-time of the application
arbitrarily many times on her own machine. During an attack, she intends to
guess a ﬁxed secret of the target machine by observing the mitigated running
time. Since we consider the attack models where the attacker knows the public
inputs and the secret inputs are less volatile than public inputs, her observations
are functional observations, where for each secret value, she learns a function
from the public inputs to the running time.

Example 2.1. Consider the program shown in Fig 1(a). It takes secret and
public values as inputs. The running time depends on the number of set bits in
both secret and public inputs. We assume that secret and public inputs can be
between 1 and 1023. Fig 1(b) shows the running time of diﬀerent secret values
as timing functions, i.e., functions from the public inputs to the running time.

Side channel discovery. One can use existing tools to ﬁnd the initial functional
observations
[49,48]. In Example 9.1, functional observations are F = (cid:104)y, 2y,
. . . , 10y(cid:105) where y is a variable whose value is the number of set bits in the
=
public input. The corresponding secret classes after this observation is S
(cid:104)11, 12, 13, . . . , 110(cid:105) where 1n shows a set of secret values that have n set bits.
The sizes of classes are B = {10, 45, 120, 210, 252, 210, 120, 45, 10, 1}. We use L1-
norm as metric to calculate the distance between the functional observations
F. This distance (penalty) matrix speciﬁes extra performance overhead to move
from one functional observation to another. With the assumption of uniform
distributions over the secret input, Shannon entropy, guessing entropy, and the
min-guessing entropy are 7.3, 90.1, and 1.0, respectively. These entropies are

F

4

Tizpaz-Niari, ˇCern´y, and Trivedi

µ(10, 10) = 1.0

C10

µ(x2, 10) = 1.0

Cx2

µ(7, 10) = 1.0

C7

µ(6, 6) = 1.0

C6

µ(x1, 6) = 1.0

Cx1

µ(1, 6) = 1.0

C1

modExp bblock 16

<= 5.0 ∗ y

> 5.0 ∗ y

modExp bblock 16

modExp bblock 16

<= 4.0 ∗ y

> 4.0 ∗ y <= 6.0 ∗ y

> 6.0 ∗ y

modExp bblock 16

modExp bblock 16

Fig. 2. (a)Mitigation policy calculation with deterministic algorithm (left). The ob-
servations x1 and x2 stands for all observations from C2−C5 and from C8−C9, resp.;
(b) Leaned discriminant decision tree (center): it characterizes the functional clusters
of Fig. 1(b) with internals of the program in Fig. 1(a); and (c) observations (right)
after the mitigation by Schmit results in two classes of observations.

deﬁned in Section 3 and measure the remaining entropy of the secret set after
the observations. We aim to maximize the entropy measures, while keeping the
performance overhead below a threshold, say 60% for this example.
Mitigation with Schmit. We use our tool Schmit to mitigate timing leaks of
Example 9.1. The mitigation policy for the Shannon entropy objective is shown
in Fig 2(a). The policy results in two classes of observations. The policy requires
to move functional observations (cid:104)y, 2y, . . . , 5y(cid:105) to (cid:104)6y(cid:105) and all other observations
(cid:104)7y, 8y, 9y(cid:105) to (cid:104)10y(cid:105). To enforce this policy, we use a monitoring system at run-
time. The monitoring system uses a decision tree model of the initial functional
observations. The decision tree model characterizes each functional observation
with associated program internals such as method calls or basic block invoca-
tions [48,47]. The decision tree model for the Example 9.1 is shown in Fig 2(b).
The monitoring system records program internals and matches it with the deci-
sion tree model to detect the current functional observation. Then, it adds delays,
if necessary, to the execution time in order to enforce the mitigation policy. With
this method, the mitigated functional observation is G = (cid:104)6y, 10y(cid:105) and the secret
= (cid:104){11, 12, 13, 14, 15, 16}, {17, 18, 19, 110}(cid:105) as shown in Fig 2 (c). The
class is S
G
performance overhead of this mitigation is 43.1%. The Shannon, guessing, and
min-guess entropies have improved to 9.7, 459.6, and 193.5, respectively.
Comparison with state of the art. We compare our mitigation results to
black-box mitigation scheme [10] and bucketing [29]. Black-box double scheme
technique. We use the double scheme technique [10] to mitigate the leaks of Ex-
ample 9.1. This mitigation uses a prediction model to release events at scheduled
times. Let us consider the prediction for releasing the event i at N -th epoch with
S(N, i) = max(inpi, S(N, i−1))+p(N ), where inpi is the time arrival of the i-th
1
request, S(N, i − 1) is the prediction for the request i−1, and p(N ) = 2N
−
models the basis for the prediction scheme at N -th epoch. We assume that the
request are the same type and the sequence of public input requests for each se-

Quantitative Mitigation of Timing Side Channels

5

Fig. 3. (a) The execution time after mitigation using the double scheme technique [10].
There are four classes of functional observations after the mitigation. (b) Mitigation
with bucketing [29]. All observations require to move to the closet red line. (c) Func-
tional observations distinguish 7 classes of observations after mitigating with bucketing.

cret are received in the beginnig of epoch N = 1. Fig 3(a) shows the functional
observations after applying the predictive mitigation. With this mitigation, the
classes of observations are S
= (cid:104)11, {12, 13}, {14, 15, 16, 17}, {18, 19, 110}(cid:105). The
G
number of classes of observations is reduced from 10 to 4. The performance
overhead is 39.9%. The Shannon, guessing, and min-guess entropies have in-
creased to 9.00, 321.5, and 5.5, respectively. Bucketing. We consider the mit-
igation approach with buckets [29]. For Example 9.1, if the attacker does not
know the public input (unknown-message attacks [29]), the observations are
{1.1, 2.1, 3.3, · · · , 9.9, 10.9, · · · , 109.5} as shown in Fig 3(b). We apply the buck-
eting algorithm in [29] for this observations, and it ﬁnds two buckets {37.5, 109.5}
shown with the red lines in Fig 3(b). The bucketing mitigation requires to
move the observations to the closet bucket. Without functional observations,
there are 2 classes of observations. However, with functional observations, there
are more than 2 observations. Fig 3(c) shows how the pattern of observations
are leaking through functional side channels. There are 7 classes of observa-
tions: S
= (cid:104){11, 12, 13}, {14}, {15}, {16}, {17}, {18}, {19}, {110}(cid:105). The Shannon,
G
guessing, and min-guess entropies are 7.63, 102.3, and 1.0, respectively. Overall,
Schmit achieves the higher entropy measures for all three objectives under the
performance overhead of 60%.

3 Preliminaries

For a ﬁnite set Q, we use |Q| for its cardinality. A discrete probability distri-
bution, or just distribution, over a set Q is a function d : Q→[0, 1] such that
(cid:80)
Q d(q) = 1. Let D(Q) denote the set of all discrete distributions over Q.
q
We say a distribution d ∈ D(Q) is a point distribution if d(q)=1 for a q ∈ Q.
Similarly, a distribution d ∈ D(Q) is uniform if d(q)=1/|Q| for all q ∈ Q.

∈

Deﬁnition 1 (Timing Model). The timing model of a program P is a tuple
[[P]] = (X, Y, S, δ) where X = {x1, . . . , xn} is the set of secret-input variables,
Y = {y1, . . . , ym} is the set of public-input variables, S ⊆ Rn is a ﬁnite set of
secret-inputs, and δ : Rn × Rm → R
0 is the execution-time function of the
program over the secret and public inputs.

≥

6

Tizpaz-Niari, ˇCern´y, and Trivedi

We assume that the adversary knows the program and wishes to learn the
value of the secret input. To do so, for some ﬁxed secret value s ∈ S, the
adversary can invoke the program to estimate (to an arbitrary precision) the
execution time of the program. If the set of public inputs is empty, i.e. m = 0, the
adversary can only make scalar observations of the execution time corresponding
to a secret value. In the more general setting, however, the adversary can arrange
his observations in a functional form by estimating an approximation of the
timing function δ(s) : Rm → R
0 of the program.
A functional observation of the program P for a secret input s ∈ S is the
function δ(s) : Rm → R
0]
be the ﬁnite set of all functional observations of the program P. We deﬁne an
order ≺ over the functional observations F: for f, g ∈ F we say that f ≺ g if
f (y) ≤ g(y) for all y ∈ Rm.

0 deﬁned as y ∈ Rm (cid:55)→ δ(s, y). Let F ⊆ [Rm → R
≥

≥

≥

The set F characterizes an equivalence relation ≡

, namely secrets with
equivalent functional observations, over the set S, deﬁned as following: s ≡
s(cid:48)
if there is an f ∈ F such that δ(s) = δ(s(cid:48)) = f . Let S
= (cid:104)S1, S2, . . . , Sk(cid:105) be
the quotient space of S characterized by the observations F = (cid:104)f1, f2, . . . , fk(cid:105).
corresponding to the observations f ∈ F.
We write Sf for the secret set S ∈ S
Let B = (cid:104)B1, B2, . . . , Bk(cid:105) be the size of observational equivalence class in S
,
i.e. Bi = |Sfi| for fi ∈ F and let B = |S| = (cid:80)k

F

F

F

F

F

i=1 Bi.

Shannon entropy, guessing entropy, and min-guess entropy are three preva-
lent information metrics to quantify information leaks in programs. K¨opf and
Basin [28] characterize expressions for various information-theoretic measures on
information leaks when there is a uniform distribution on S given below.

Proposition 1 (K¨opf and Basin [28]). Let F = (cid:104)f1, . . . , fk(cid:105) be a set of ob-
servations and let S be the set of secret values. Let B = (cid:104)B1, . . . , Bk(cid:105) be the
corresponding size of secret set in each class of observation and B = (cid:80)k
i=1 Bi.
Assuming a uniform distribution on S, entropies can be characterized as:

B ) (cid:80)
1. Shannon Entropy: SE(S|F) def= ( 1
2B ) (cid:80)
2. Guessing Entropy: GE(S|F) def= ( 1
1
≤
3. Min-Guess Entropy: mGE(S|F) def= min1
≤

≤

1

i

k Bi log2(Bi),
≤
i + 1

k B2
2 , and
k {(Bi + 1)/2}.

i
≤
i
≤

4 Shannon Mitigation Problem

Our goal is to mitigate the information leakage due to the timing side channels
by adding synthetic delays to the program. An aggressive, but commonly-used,
mitigation strategy aims to eliminate the side channels by adding delays such
that every secret value yields a common functional observation. However, this
strategy may often be impractical as it may result in unacceptable performance
degradations of the response time. Assuming a well-known penalty function as-
sociated with the performance degradation, we study the problem of maximizing
entropy while respecting a bound on the performance degradation. We dub the
decision version of this problem Shannon mitigation.

Quantitative Mitigation of Timing Side Channels

7

Adding synthetic delays to execution-time of the program, so as to mask
the side-channel, can give rise to new functional observations that correspond
to upper-envelopes of various combinations of original observations. Let F =
(cid:104)f1, f2, . . . , fk(cid:105) be the set of functional observations. For I ⊆ 1, 2, . . . , k, let
fI = y ∈ Rm (cid:55)→ supi
I fi(y) be the functional observation corresponding
to upper-envelope of the functional observations in the set I. Let G(F) =
{fI : I (cid:54)= ∅ ⊆ {1, 2, . . . , k}} be the set of all possible functional observations
resulting from the upper-envelope calculations. To change the observation of a
secret value with functional observation fi to a new observation fI (we assume
that i ∈ I), we need to add delay function f i

I : y ∈ Rm (cid:55)→ fI (y) − fi(y).

∈

Mitigation Policies. Let G ⊆ G(F) be a set of admissible post-mitigation ob-
servations. A mitigation policy is a function µ : F → D(G) that for each secret
s ∈ Sf suggests the probability distribution µ(f ) over the functional observa-
tions. We say that a mitigation policy is deterministic if for all f ∈ F we have
that µ(f ) is a point distribution. Abusing notations, we represent a determin-
istic mitigation policy as a function µ : F → G. The semantics of a mitigation
policy recommends to a program analyst a probability µ(f )(g) to elevate a se-
cret input s ∈ Sf from the observational class f to the class g ∈ G by adding
max {0, g(p) − f (p)} units delay to the corresponding execution-time δ(s, p) for
all p ∈ Y . We assume that the mitigation policies respect the order, i.e. for ev-
ery mitigation policy µ and for all f ∈ F and g ∈ G, we have that µ(f )(g) > 0
) be the set of mitigation policies from the set of
implies that f ≺ g. Let M(
observational clusters F into the clusters G.

F→G

For the functional observations F = (cid:104)f1, . . . , fk(cid:105) and a mitigation policy

µ ∈ M(

F→G

), the resulting observation set F[µ] ⊆ G is deﬁned as:

F[µ] = {g ∈ G :

there exists f ∈ F such that µ(f )(g) > 0} .

Since the mitigation policy is stochastic, we use average sizes of resulting obser-
vations to represent ﬁtness of a mitigation policy. For F[µ] = (cid:104)g1, g2, . . . , g(cid:96)(cid:105), we
deﬁne their expected class sizes Bµ = (cid:104)C1, C2, . . . , C(cid:96)(cid:105) as Ci = (cid:80)i
j=1 µ(fj)(fi)·Bj
(observe that (cid:80)(cid:96)
i=1 Ci = B). Assuming a uniform distribution on S, various en-
tropies for the expected class size after applying a policy µ ∈ M(
) can be
characterized by the following expressions:

F→G

B ) (cid:80)
1. Shannon Entropy: SE(S|F, µ) def= ( 1
i
≤
2B ) (cid:80)
2. Guessing Entropy: GE(S|F, µ) def= ( 1
1
≤
3. Min-Guess Entropy: mGE(S|F, µ) def= min1
≤

1

≤
i

≤

(cid:96) Ci log2(Ci),
i + 1

(cid:96) C 2
2 , and
≤
(cid:96) {(Ci + 1)/2}.
i

We note that the above deﬁnitions do not represent the expected entropies,
but rather entropies corresponding to the expected cluster sizes. However, the
three quantities provide bounds on the expected entropies after applying µ.
Since Shannon and Min-Guess entropies are concave functions, from Jensen’s
inequality, we get that SE(S|F, µ) and mGE(S|F, µ) are upper bounds on ex-
pected Shannon and Min-Guess entropies. Similarly, GE(S|F, µ), being a convex
function, give a lower bound on expected guessing entropy.

8

Tizpaz-Niari, ˇCern´y, and Trivedi

We are interested in maximizing the entropy while respecting constraints on
the overall performance of the system. We formalize the notion of performance
by introducing performance penalties: there is a function π : F × G → R
0
≥
such that elevating from the observation f ∈ F to the functional observation
g ∈ G adds an extra π(f, g) performance overheads to the program. The expected
performance penalty associated with a policy µ, π(µ), is deﬁned as the proba-
bilistically weighted sum of the penalties, i.e. (cid:80)
g |Sf |·µ(f )(g)·π(f, g).
f
Now, we introduce our key decision problem.

∈F

∈G

,g

≺

:f

Deﬁnition 2 (Shannon Mitigation). Given a set of functional observations
F = (cid:104)f1, . . . , fk(cid:105), a set of admissible post-mitigation observations G ⊆ G(F),
set of secrets S, a penalty function π : F × G → R
0, a performance penalty
upper bound ∆ ∈ R
0, the Shannon
mitigation problem Shan
(F, G, S, π, E, ∆), for a given entropy measure E ∈
{SE, GE, mGE}, is to decide whether there exists a mitigation policy µ ∈ M(
)
F→G
such that E(S|F, µ) ≥ E and π(µ) ≤ ∆. We deﬁne the deterministic Shannon
mitigation variant where the goal is to ﬁnd a deterministic such policy.

0, and an entropy lower-bound E ∈ R

≥

≥

≥

E

5 Algorithms for Shannon Mitigation Problem

5.1 Deterministic Shannon Mitigation

We ﬁrst establish the intractability of the deterministic variant.

Theorem 1. Deterministic Shannon mitigation problem is NP-complete.

Proof. It is easy to see that the deterministic Shannon mitigation problem is in
NP: one can guess a certiﬁcate as a deterministic mitigation policy µ ∈ M(
)
F→G
and can verify in polynomial time that it satisﬁes the entropy and overhead con-
straints. Next, we sketch the hardness proof for the min-guess entropy measure
by providing a reduction from the two-way partitioning problem [31]. For the
Shannon entropy and guess entropy measures, a reduction can be established
from the Shannon capacity problem [19] and the Euclidean sum-of-squares clus-
tering problem [8], respectively.

a

∈

A1 a = (cid:80)

Given a set A = {a1, a2, . . . , ak} of integer values, the two-way partitioning
problem is to decide whether there is a partition A1(cid:93)A2 = A into two sets A1 and
A2 with equal sums, i.e. (cid:80)
A2 a. W.l.o.g assume that ai ≤ aj for
a
∈
i ≤ j. We reduce this problem to a deterministic Shannon mitigation problem
ShanmGE(FA, GA, SA, πA, EA, ∆A) with k clusters FA = GA = (cid:104)f1, f2, . . . , fk(cid:105)
with the secret set SA = (cid:104)S1, S2, . . . , Sk(cid:105) such that |Si| = ai. If (cid:80)
k ai
is odd then the solution to the two-way partitioning instance is trivially no.
Otherwise, let EA = (1/2) (cid:80)
k ai. Notice that any deterministic mitigation
strategy that achieves min-guess entropy larger than or equal to EA must have
at most two clusters. On the other hand, the best min-guess entropy value can
be achieved by having just a single cluster. To avoid this and force getting
two clusters corresponding to the two partitions of a solution to the two-way
partitions problem instance A, we introduce performance penalties such that

i
≤

≤

≤

≤

1

1

i

Quantitative Mitigation of Timing Side Channels

9

µ(4, 4)

C4

µ(3, 4)

µ(3, 3)

C3

µ(2, 3)

µ(2, 4)

µ(1, 4)

µ(4, 4) = 1.0

C4

µ(4, 4) = 1.0

C4

µ(3, 3) = 1.0

C3

µ(3, 3) = 1.0

C3

µ(2, 4) = 1.0

µ(2, 3) = 1.0

µ(2, 2)

C2

µ(1, 3)

C2

µ(1, 3) = 1.0

µ(1, 3) = 0.4

C2

µ(1, 2)

µ(1, 1)

C1

C1

µ(1, 1) = 0.6

C1

Fig. 4. (a). Example of Shannon mitigation problem with all possible mitigation poli-
cies for 4 classes of observations. (b,c) Two examples of the mitigation policies that
results in 2 and 3 classes of observations.

merging more than k − 2 clusters is disallowed by keeping performance penalty
πA(f, g) = 1 and performance overhead ∆A = k − 2. It is straightforward to
verify that an instance of the resulting min-guess entropy problem has a yes
answer if and only if the two-way partitioning instance does.

Since the deterministic Shannon mitigation problem is intractable, we design
an approximate solution for the problem. Note that the problem is hard even if we
only use existing functional observations for mitigation, i.e., G = F. Therefore,
we consider this case for the approximate solution. Furthermore, we assume
the following sequential dominance restriction on a deterministic policy µ: for
f, g ∈ F if f ≺ g then either µ(f ) ≺ g or µ(f ) = µ(g). In other words, for
any given f ≺ g, f can not be moved to a higher cluster than g without having
g be moved to that cluster. For example, Fig 4(a) shows Shannon mitigation
problem with four functional observations and all possible mitigation policies
(we represent µ(fi)(fj) with µ(i, j)). Fig 4(b) satisﬁes the sequential dominance
restriction, while Fig 4(c) does not.

The search for the deterministic policies satisfying the sequential dominance
restriction can be performed eﬃciently using dynamic programming by eﬀective
use of intermediate results’ memorizations.

Algorithm (1) provides a pseudocode for the dynamic programming solution
to ﬁnd a deterministic mitigation policy satisfying the sequential dominance.
The key idea is to start with considering policies that produce a single cluster
for subclasses Pi of the problem with the observation from (cid:104)f1, . . . , fi(cid:105), and
then compute policies producing one additional cluster in each step by utilizing
the previously computed sub-problems and keeping track of the performance
penalties. The algorithm terminates as soon as the solution of the current step
respects the performance bound. The complexity of the algorithm is O(k3).

5.2 Stochastic Shannon Mitigation Algorithm

Next, we solve the (stochastic) Shannon mitigation problem by posing it as
an optimization problem. Consider the stochastic Shannon mitigation problem
Shan
, π, E, ∆) with a stochastic policy µ : F → D(G) and

(F, G = F, S

E

F

10

Tizpaz-Niari, ˇCern´y, and Trivedi

Algorithm 1: Approximate Deterministic Shannon Mitigation

Input: The Shannon entropy problem ShanM GE(F, G = F, S
F
Output: The entropy table (T ).

, π, E, ∆)

1 for i = 1 to k do
i(cid:83)
j=1

2

T (i, 1) = E(
if (cid:80)
j
1
≤
≤

i
else Π(i, 1) = ∞

3

4

Sj)

π(j, i)(Bj/B) ≤ ∆ then Π(i, 1) = (cid:80)

π(j, i)(Bj/B)

1

≤

j

i
≤

5 if Π(k, 1) < ∞ then return T ;
6 for r = 2 to k do
7

for i = 1 to k do

Ω(i, r) = {j : 1 ≤ j < i and Π(j, r − 1) + (cid:80)

8

9

10

11

12

13

14

j<q

i

≤

(cid:16)

min (cid:0)T (j, r−1), E(

π(q, i)(Bq/B) ≤ ∆}
Sq)(cid:1)(cid:17)

i(cid:83)
q=j+1

π(q, i)(Bq/B)(cid:1)

if Ω(cid:54)=∅ then T (i, r)= max

j

Ω(i,r)

∈

else T (i, r)= − ∞
Let j be the index that maximizes T (i, r)
if Ω (cid:54)= ∅ then Π(i, r) = (cid:0)Π(j, r − 1) + (cid:80)

else Π(i, r) = ∞

if Π(k, r) < ∞ then return T ;

j<q

i

≤

15 return T ;

= (cid:104)S1, S2, . . . , Sk(cid:105). The following program characterizes the optimization

S
problem that solves the Shannon mitigation problem with stochastic policy.

F

Maximize E, subject to:

j

1. 0 ≤ µ(fi)(fj) ≤ 1 for 1 ≤ i ≤ j ≤ k
2. (cid:80)
k µ(fi)(fj) = 1 for all 1 ≤ i ≤ k.
i
≤
≤
3. (cid:80)k
(cid:80)k
i=1
4. Cj = (cid:80)j

j=i |Si| · µ(fi)(fj) · π(fi, fj) ≤ ∆.
i=1 |Si| · µ(fi)(fj) for 1 ≤ j ≤ k.

Here, the objective function E is one of the following functions:

1. Guessing Entropy EGE =

k(cid:80)
j=1

C 2
j

2. Min-Guess Entropy EM GE = min
k
≤
Cj · log2(Cj)

3. Shannon Entropy ESE =

≤

1

j

{Cj | Cj > 0}

k(cid:80)
j=1

Quantitative Mitigation of Timing Side Channels

11

The linear constraints for the problem are deﬁned as the following. The con-
dition (1) and (2) express that µ provides a probability distributions, condition
(3) provides restrictions regarding the performance constraint, and the condition
(4) is the entropy speciﬁc constraint. The objective function of the optimization
problem is deﬁned based on the entropy criteria from E. For the simplicity, we
omit the constant terms from the objective function deﬁnitions. For the guessing
entropy, the problem is an instance of linearly constrained quadratic optimization
problem [36]. The problem with Shannon entropy is a non-linear optimization
problem [12]. Finally, the optimization problem with min-guess entropy is an
instance of mixed integer programming [35]. We evaluate the scalability of these
solvers empirically in Section 6 and leave the exact complexity as an open prob-
lem. We show that the min-guess entropy objective function can be eﬃciently
solved with the branch and bound algorithms [39]. Fig 4(b,c) show two instanti-
ations of the mitigation policies that are possible for the stochastic mitigation.

6

Implementation Details

A. Environmental Setups. All timing measurements are conducted on an
Intel NUC5i5RYH. We switch oﬀ JIT Compilation and run each experiment
multiple times and use the mean running time. This helps to reduce the eﬀects
of environmental factors such as the Garbage Collections. All other analyses are
conducted on an Intel i5-2.7 GHz machine.
B. Implementation of Side Channel Discovery. We use the technique pre-
sented in [49] for the side channel discovery. The technique applies the functional
data analysis [41] to create B-spline basis and ﬁt functions to the vector of tim-
ing observations for each secret value. Then, the technique applies the functional
data clustering [23] to obtain K classes of observations. We use the number of se-
cret values in a cluster as the class size metric and the L1 distance norm between
the clusters as the penalty function.
C. Implementation of Mitigation Policy Algorithms. For the stochastic
optimization, we encode the Shannon entropy and guessing entropy with linear
constraints in Scipy [25]. Since the objective functions are non-linear (for the
Shannon entropy) and quadratic (for the guessing entropy), Scipy uses sequential
least square programming (SLSQP) [37] to maximize the objectives. For the
stochastic optimization with the min-guess entropy, we encode the problem in
Gurobi [21] as a mixed-integer programming (MIP) problem [35]. Gurobi solves
the problem eﬃciently with branch-and-bound algorithms [1]. We use Java to
implement the dynamic programming.
D. Implementation of Enforcement. The enforcement of mitigation pol-
icy is implemented in two steps. First, we use the initial timing functions and
characterize them with program internal properties such as basic block calls. To
do so, we use the decision tree learning approach presented in [49]. The decision
tree model characterizes each functional observations with properties of program
internals. Second, given the policy of mitigation, we enforce the mitigation pol-
icy with a monitoring system implemented on top of the Javassist [16] library.

12

Tizpaz-Niari, ˇCern´y, and Trivedi

The monitoring system uses the decision tree model and matches the properties
enabled during an execution with the tree model (detection of the current clus-
ter). Then, it adds extra delays, based on the mitigation policy, to the current
execution-time and enforces the mitigation policy. Note that the dynamic mon-
itoring can result in a few micro-second delays. For the programs with timing
diﬀerences in the order of micro-seconds, we transform source code using the
decision tree model. The transformation requires manual eﬀorts to modify and
compile the new program. But, it adds negligible delays.

E. Micro-benchmark Results. Our goal is to compare diﬀerent mitigation
methods in terms of their security and performance. We examine the computa-
tion time of our tool Schmit in calculating the mitigation policies. See appendix
for the relationships between performance bounds and entropy measures.

Applications: Mod Exp applications [33] are instances of square-and-multiply
modular exponentiation (R = yk mod n) used for secret key operations in
RSA [43]. Branch and Loop series consist of 6 applications where each appli-
cation has conditions over secret values and runs a linear loop over the public
values. The running time of the applications depend on the slope of the linear
loops determined by the secret input.

Computation time comparisons: Fig 5 shows the computation time for Branch and
Loop applications (the applications are ordered in x-axis based on the discov-
ered number of observational classes). For the min-guess entropy, we observe
that both stochastic and dynamic programming approaches are eﬃcient and
fast as shown in Fig 5(a). For the Shannon and guessing entropies, the dynamic
programming is scalable, while the stochastic mitigation is computationally ex-
pensive beyond 60 classes of observations as shown in Fig 5(b,c).

Mitigation Algorithm Comparisons: Tab 1 shows micro-benchmark results that
compare the four mitigation algorithms with the two program series. Double
scheme mitigation technique [10] does not provide guarantees on the perfor-
mance overhead, and we can see that it is increased by more than 75 times
for mod exp 6. Double scheme method reduces the number of classes of obser-
vations. However, we observe that this mitigation has diﬃculty improving the
min-guess entropy. Second, Bucketing algorithm [29] can guarantee the perfor-
mance overhead, but it is not an eﬀective method to improve the security of
functional observations, see the examples mod exp 6 and Branch and Loop 6.
Third, in the algorithms, Schmit guarantees the performance to be below a
certain bound, while it results in the highest entropy values. In most cases, the
stochastic optimization technique achieves the highest min-entropy value. Here,
we show the results with min-guess entropy measure. Also, we have strong ev-
idences to show that Schmit achieves higher Shannon and guessing entropies.
For example, in B L 5, the initial Shannon entropy has improved from 2.72 to
6.62, 4.1, 7.56, and 7.28 for the double scheme, the bucketing, the stochastic,
and the deterministic algorithms, respectively.

Quantitative Mitigation of Timing Side Channels

13

Table 1. Micro-benchmark results. M E and B L stand for Mod Exp and
Branch and Loop applications. Legend: #S: no. of secret values, #P: no. of public val-
ues, ∆: Upper bound over performance penalty, (cid:15): clustering parameter, #K: classes
of observations before mitigation, #KX : classes of observations after mitigation with
X technique, mGE: Min-guess entropy before mitigation, mGEX : Min-guess entropy
after mitigation with X, OX : Performance overhead added after mitigation with X.

Initial Characteristics

Double Scheme

Bucketing

Schmit (Determ.)

Schmit (Stoch.)

32
64
128
256
512

App(s) #S #P ∆ (cid:15) #K mGE #KDS mGEDS ODS(%) #KB mGEB OB(%) KD #mGED OD(%) #KS mGES OS(%)
1
32 0.5 1.0
0.0
M E 1
2
64 0.5 1.0
21.4
M E 2
2
128 0.5 2.0
22.7
M E 3
4
28.3
256 0.5 2.0
M E 4
23
30.3
512 0.5 5.0
M E 5
40
50.0
M E 6 1,024 1,024 0.5 8.0
4
34.9
50 0.5 10.0
B L 1
8
45.3
50 0.5 10.0
B L 2
16
50
50 0.5 20.0
B L 3
49.7
32
50 0.5 20.0
B L 4
50.0
50 0.5 20.0
B L 5
64
49.6
50 0.5 20.0 125
B L 6

16.5
32.5
64.5
128.5
128.5
1.0
3.0
3.0
3.0
3.0
3.0
3.0

16.5
32.5
64.5
128.5
256.5
27.5
5.5
10.5
20.5
48.0
65.5
133.0

16.5
32.5
64.5
128.5
256.5
512.5
3.0
3.0
8.0
3.0
3.0
8.0

0.0
5,221
5,407
6,679
7,294
7,822
73.0
61.3
42.4
36.9
35.4
37.8

16.5
32.5
64.5
128.5
253.0
85.5
6.5
13.0
21.5
50.5
100.5
200.5

0.0
27.6
33.9
30.7
50.0
34.5
17.5
21.9
33.4
28.7
27.2
52.5

0.0
21.4
22.7
28.3
31.0
46.7
26.1
45.3
48.3
48.7
32.0
34.6

16.5
16.5
32.5
10.5
1.0
1.0
3.0
3.0
3.0
3.0
3.0
3.0

1
1
1
1
2
20
3
5
8
16
32
29

1
1
1
1
1
1
3
4
4
6
8
12

25
50
100
200
400
800

1
1
1
1
1
5
2
2
2
2
2
2

1
1
1
1
1
2
2
2
2
2
3
3

Fig. 5. Computation time for synthesizing mitigation policy over Branch and Loop
applications. Computation time for min-guess entropy (a) takes only few seconds. Com-
putation time for the Shannon entropy (b) and guessing entropy (c) are expensive using
Stochastic optimization. We set time-out to be 10 hours.

7 Case Study

Research Question. Does Schmit scale well and improve the security of ap-
plications (entropy measures) within the given performance bounds?
Methodology. We use the deterministic and stochastic algorithms for mitigat-
ing the leaks. We show our results for the min-guess entropy, but other entropy
measures can be applied as well. Since the task is to mitigate existing leakages,
we assume that the secret and public inputs are given.
Objects of Study. We consider four real-world applications:

Application

Num. Num. Num.
Methods Secret Public

(cid:15)

Initial.
clusters Min-guess

Initial.

1,105 65
GabFeed
800
635
Jetty
2,000 10
Java Verbal Expressions
Password Checker
20
In the inset table, we show the basic characteristics of these benchmarks.

6.50
0.1
0.02
2,620 0.05

1.0
4.5
50.5
1.0

573
63
61
6

34
20
9
6

14

Tizpaz-Niari, ˇCern´y, and Trivedi

GabFeed is a chat server with 573 methods [4]. There is a side channel in the
authentication part of the application where the application takes users’ public
keys and its own private key, and generating a common key [15]. The vulnerabil-
ity leaks the number of set bits in the secret key. Initial functional observations
are shown in Fig 6a. There are 34 clusters and min-guess entropy is 1. We aim
to maximize the min-guess entropy under the performance overhead of 50%.
Jetty. We mitigate the side channels in util.security package of Eclipse Jetty
web server. The package has Credential class which had a timing side channel.
This vulnerability was analyzed in [15] and ﬁxed initially in [6]. Then, the devel-
opers noticed that the implementation in [6] can still leak information and ﬁxed
this issue with a new implementation in [5]. However, this new implementation
is still leaking information [49]. We apply Schmit to mitigate this timing side
channels. Initial functional observations is shown in Fig 6d. There are 20 classes
of observations and the initial min-guess entropy is 4.5. We aim to maximize the
min-guess entropy under the performance overhead of 50%.
Java Verbal Expressions is a library with 61 methods that construct regular ex-
pressions [2]. There is a timing side channel in the library similar to password
comparison vulnerability [3] if the library has secret inputs. In this case, start-
ing from the initial character of a candidate expression, if the character matches
with the regular expression, it slightly takes more time to respond the request
than otherwise. This vulnerability can leak all the regular expressions. We con-
sider regular expressions to have a maximum size of 9. There are 9 classes of
observations and the initial min-guess entropy is 50.5. We aim to maximize the
min-guess entropy under the performance overhead of 50%.
Password Checker. We consider the password matching example from loginBad
program [9]. The password stored in the server is secret, and the user’s guess is a
public input. We consider 20 secret (lengths at most 6) and 2,620 public inputs.
There are 6 diﬀerent clusters, and the initial min-guess entropy is 1.
Findings for GabFeed. With the stochastic algorithm, Schmit calculates the
mitigation policy that results in 4 clusters. This policy improves the min-guess
entropy from 1 to 138.5 and adds an overhead of 42.8%. With deterministic
algorithm, Schmit returns 3 clusters. The performance overhead is 49.7% and
the min-guess entropy improves from 1 to 106. The user chooses the deterministic
policy and enforces the mitigation. We apply CART decision tree learning and
characterizes the classes of observations with GabFeed method calls as shown in
Fig 6b. The monitoring system uses the decision tree model and automatically
detects the current class of observation. Then, it adds extra delays based on
the mitigation policy to enforce it. The results of the mitigation is shown in
Fig 6c. Answer for our research question. Scalability: It takes about 1 second
to calculate the stochastic and the deterministic policies. Security: Stochastic
and deterministic variants improve the min-guess entropy more than 100 times
under the given performance overhead of 50%, respectively.
Findings for Jetty. The stochastic algorithm and the deterministic algorithm
ﬁnd the same policy that results in 1 cluster with 39.6% performance overhead.
The min-guess entropy improves from 4.5 to 400.5. For the enforcement, Schmit

Quantitative Mitigation of Timing Side Channels

15

OptimizedMultiplier.standard
Multiply BasicBlock 18

= 3 ∗ y

(cid:54)= 3 ∗ y

OptimizedMultiplier.standard
Multiply BasicBlock 18

= 127 ∗ y

(cid:54)= 127 ∗ y

OptimizedMultiplier.standard
Multiply BasicBlock 18

= 251 ∗ y

(cid:54)= 251 ∗ y

(a) Classes of observations

(b) Decision Tree

(c) Mitigated Observations

jetty.util.security.
Credential.stringEquals bblock 106

= min(1, y)

(cid:54)= min(1, y)

jetty.util.security.
Credential.stringEquals bblock 106

= min(2, y)

(cid:54)= min(2, y)

jetty.util.security.
Credential.stringEquals bblock 106

= min(3, y)

(cid:54)= min(3, y)

(d) Classes of observations

(e) Decision Tree

(f) Mitigated Observations

verbalExp.example1
.main.bblock 1042

> 0

= 0

verbalExp.example1
.main.bblock 995

= 0

verbalExp.example1
.main.bblock 713

= 0

> 0

> 0

(g) Classes of observations

(h) Decision Tree

(i) Mitigated Observations

Fig. 6. Initial functional observations, decision tree, and the mitigated observations
from left to right for Gabfeed, Jetty, and Verbal Expressions from top to bottom.

ﬁrst uses the initial clusterings and speciﬁes their characteristics with program
internals that result in the decision tree model shown in Fig 6e. Since the re-
sponse time is in the order of micro-seconds, we transform the source code using
the decision tree model by adding extra counter variables. The results of the
mitigation is shown in Fig 6f. Scalability: It takes less than 1 second to calculate
the policies for both algorithms. Security: Stochastic and deterministic variants
improve the min-guess entropy 89 times under the given performance overhead.
Findings for Java Verbal Expressions. For the stochastic algorithm, the
policy results in 2 clusters, and the min-guess entropy has improved to 500.5. The
performance overhead is 36%. For the dynamic programming, the policy results
in 2 clusters. This adds 28% of performance overhead, while it improves the
min-guess entropy from 50.5 to 450.5. The user chooses to use the deterministic

16

Tizpaz-Niari, ˇCern´y, and Trivedi

policy for the mitigation. For the mitigation, we transform the source code using
the decision tree model and add the extra delays based on the mitigation policy.
Findings for Password Matching. Both the deterministic and the stochastic
algorithms result in ﬁnding a policy with 2 clusters where the min-guess entropy
has improved from 1 to 5.5 with the performance overhead of 19.6%. For the
mitigation, we transform the source code using the decision tree model and add
extra delays based on the mitigation policy if necessary.

8 Related Work

Quantitative theory of information have been widely used to measure how much
information is being leaked with side-channel observations [45,28,11,22]. Mitiga-
tion techniques increase the remaining entropy of secret sets leaked through the
side channels, while considering the performance [29,10,52,53,26,44].

K¨opf and D¨urmuth [29] use a bucketing algorithm to partition programs’
observations into intervals. With the unknown-message threat model, K¨opf and
D¨urmuth [29] propose a dynamic programming algorithm to ﬁnd the optimal
number of possible observations under a performance penalty. The works [10,52]
introduce diﬀerent black-box schemes to mitigate leaks. In particular, Askarov
et al. [10] show the quantizing time techniques, which permit events to release at
scheduled constant slots, have the worst case leakage if the slot is not ﬁlled with
events. Instead, they introduce the double scheme method that has a schedule of
predictions like the quantizing approach, but if the event source fails to deliver
events at the predicted time, the failure results in generating a new schedule in
which the interval between predictions is doubled. We compare our mitigation
technique with both algorithms throughout this paper.

Elimination of timing side channels is a common technique to guarantee the
conﬁdentiality of software [7,34,50,18,30,33]. The work [50] aims to eliminate
side channels using static analysis enhanced with various techniques to keep the
performance overheads low without guaranteeing the amounts of overhead. In
contrast, we use dynamic analysis and allow a small amount of information to
leak, but we guarantee an upper-bound on the performance overhead.

Machine learning techniques have been used for explaining timing diﬀerences
between traces [46,47,48]. Tizpaz-Niari et al. [48] consider performance issues in
softwares. They also cluster execution times of programs and then explain what
program properties distinguish the diﬀerent functional clusters. We adopt their
techniques for our security problem.

Acknowledgements. The authors would like to thank Mayur Naik for shepherding
our paper and providing useful suggestions. This research was supported by
DARPA under agreement FA8750-15-2-0096.

Quantitative Mitigation of Timing Side Channels

17

References

1. Branch and bound algorithm for mip problems, http://www.gurobi.com/

resources/getting-started/mip-basics

2. Verbal

expressions

library,

https://github.com/VerbalExpressions/

JavaVerbalExpressions

3. Timing attack in google keyczar library (2009), https://rdist.root.org/2009/

05/28/timing-attack-in-google-keyczar-library/

4. Gabfeed application (2016), https://github.com/Apogee-Research/STAC/tree/

master/Engagement_Challenges/Engagement_2/gabfeed_1
password

5. Timing
(May
2baa1abe4b1c380a30deacca1ed367466a1a62ea

side-channel
2017),

jetty
on
https://github.com/eclipse/jetty.project/commit/

eclipse

length

the

in

of

side-channel

6. Timing
2017),
f3751d70787fd8ab93932a51c60514c2eb37cb58

(May
in
https://github.com/eclipse/jetty.project/commit/

password

eclipse

jetty

the

on

7. Agat, J.: Transforming out timing leaks. In: Proceedings of the 27th ACM
SIGPLAN-SIGACT symposium on Principles of programming languages. pp. 40–
53. ACM (2000)

8. Aloise, D., Deshpande, A., Hansen, P., Popat, P.: Np-hardness of euclidean sum-

of-squares clustering. Machine Learning 75(2), 245–248 (May 2009)

9. Antonopoulos, T., Gazzillo, P., Hicks, M., Koskinen, E., Terauchi, T., Wei, S.: De-
composition instead of self-composition for proving the absence of timing channels.
In: PLDI. pp. 362–375. ACM (2017)

10. Askarov, A., Zhang, D., Myers, A.C.: Predictive black-box mitigation of timing
channels. In: Proceedings of the 17th ACM conference on Computer and commu-
nications security. pp. 297–307. ACM (2010)

11. Backes, M., K¨opf, B., Rybalchenko, A.: Automatic discovery and quantiﬁcation of
information leaks. In: Security and Privacy, 2009 30th IEEE Symposium on. pp.
141–153. IEEE (2009)

12. Bertsekas, D.P.: Nonlinear programming. athena scientiﬁc, 2016. Tech. rep., ISBN

978-1-886529-05-2

13. Breiman, L., Friedman, J., Olshen, R., Stone, C.: Classiﬁcation and regression

trees. Wadsworth: Belmont, CA (1984)

14. Brumley, D., Boneh, D.: Remote timing attacks are practical. Computer Networks

48(5), 701–716 (2005)

15. Chen, J., Feng, Y., Dillig, I.: Precise detection of side-channel vulnerabilities using

quantitative cartesian hoare logic. In: CCS. pp. 875–890 (2017)

16. Chiba, S.: Javassist - a reﬂection-based programming wizard for java. In: Pro-
ceedings of OOPSLA’98 Workshop on Reﬂective Programming in C++ and Java.
vol. 174 (1998)

17. Dhem, J.F., Koeune, F., Leroux, P.A., Mestr´e, P., Quisquater, J.J., Willems, J.L.:
A practical implementation of the timing attack. In: International Conference on
Smart Card Research and Advanced Applications. pp. 167–182. Springer (1998)

18. Eldib, H., Wang, C.: Synthesis of masking countermeasures against side channel
attacks. In: International Conference on Computer Aided Veriﬁcation. pp. 114–130.
Springer (2014)

19. Fallgren, M.: On the complexity of maximizing the minimum shannon capacity in
wireless networks by joint channel assignment and power allocation. In: 2010 IEEE
18th International Workshop on Quality of Service (IWQoS). pp. 1–7 (2010)

18

Tizpaz-Niari, ˇCern´y, and Trivedi

20. Ferraty, F., Vieu, P.: Nonparametric functional data analysis: theory and practice.

Springer Science & Business Media (2006)

21. Gurobi Optimization, L.: Gurobi optimizer reference manual (2018), http://www.

gurobi.com

22. Heusser, J., Malacaria, P.: Quantifying information leaks in software. In: Proceed-
ings of the 26th Annual Computer Security Applications Conference. pp. 261–269.
ACM (2010)

23. Jacques, J., Preda, C.: Functional data clustering: a survey. Advances in Data

Analysis and Classiﬁcation 8(3), 231–255 (2014)

24. Johnson, S.C.: Hierarchical clustering schemes. Psychometrika 32(3), 241–254

(1967)

25. Jones, E., Oliphant, T., Peterson, P., et al.: SciPy: Open source scientiﬁc tools for

Python (2001–), http://www.scipy.org/

26. Kadloor, S., Kiyavash, N., Venkitasubramaniam, P.: Mitigating timing based in-
formation leakage in shared schedulers. In: Infocom, 2012 Proceedings IEEE. pp.
1044–1052. IEEE (2012)

27. Kocher, P.C.: Timing attacks on implementations of Diﬃe-Hellman, RSA, DSS,
and other systems. In: Annual International Cryptology Conference. pp. 104–113.
Springer (1996)

28. K¨opf, B., Basin, D.: An information-theoretic model for adaptive side-channel at-
tacks. In: Proceedings of the 14th ACM Conference on Computer and Communi-
cations Security. pp. 286–296. CCS ’07, ACM, New York, NY, USA (2007)

29. K¨opf, B., D¨urmuth, M.: A provably secure and eﬃcient countermeasure against
timing attacks. In: Computer Security Foundations Symposium, 2009. CSF’09.
22nd IEEE. pp. 324–335. IEEE (2009)

30. K¨opf, B., Mantel, H.: Transformational typing and uniﬁcation for automatically
correcting insecure programs. International Journal of Information Security 6(2-3),
107–131 (2007)

31. Korf, R.E.: A complete anytime algorithm for number partitioning. AI 106, 181–

203 (1998)

32. Lampson, B.W.: A note on the conﬁnement problem. Communications of the ACM

16(10), 613–615 (1973)

33. Mantel, H., Starostin, A.: Transforming out timing leaks, more or less. In: European
Symposium on Research in Computer Security. pp. 447–467. Springer (2015)
34. Molnar, D., Piotrowski, M., Schultz, D., Wagner, D.: The program counter security
model: Automatic detection and removal of control-ﬂow side channel attacks. In:
International Conference on Information Security and Cryptology. pp. 156–168.
Springer (2005)

35. Nemhauser, G.L., Wolsey, L.A.: Integer programming and combinatorial optimiza-
tion. Wiley, Chichester. GL Nemhauser, MWP Savelsbergh, GS Sigismondi (1992).
Constraint Classiﬁcation for Mixed Integer Programming Formulations. COAL
Bulletin 20, 8–12 (1988)

36. Nocedal, J., Wright, S.J.: Numerical optimization 2nd (2006)
37. Nocedal, J., Wright, S.J.: Sequential quadratic programming. Springer (2006)
38. Padlipsky, M., Snow, D., Karger, P.: Limitations of end-to-end encryption in secure

computer networks. Tech. rep., MITRE CORP BEDFORD MA (1978)

39. Papadimitriou, C.H., Steiglitz, K.: Combinatorial optimization: algorithms and

complexity. Courier Corporation (1998)

40. Phan, Q.S., Bang, L., Pasareanu, C.S., Malacaria, P., Bultan, T.: Synthesis of adap-
tive side-channel attacks. In: Computer Security Foundations Symposium (CSF),
2017 IEEE 30th. pp. 328–342. IEEE (2017)

Quantitative Mitigation of Timing Side Channels

19

41. Ramsay, J., Hooker, G., Graves, S.: Functional data analysis with R and MATLAB.

Springer Science & Business Media (2009)

42. Ramsay, J.O.: Functional data analysis. Wiley Online Library (2006)
43. Rivest, R.L., Shamir, A., Adleman, L.: A method for obtaining digital signatures
and public-key cryptosystems. Communications of the ACM 21(2), 120–126 (1978)
44. Schinzel, S.: An eﬃcient mitigation method for timing side channels on the web.
In: 2nd International Workshop on Constructive Side-Channel Analysis and Secure
Design (COSADE) (2011)

45. Smith, G.: On the foundations of quantitative information ﬂow. In: International
Conference on Foundations of Software Science and Computational Structures. pp.
288–302. Springer (2009)

46. Song, L., Lu, S.: Statistical debugging for real-world performance problems. In:
Proceedings of the 2014 ACM International Conference on Object Oriented Pro-
gramming Systems Languages & Applications. pp. 561–578. OOPSLA ’14 (2014),
http://doi.acm.org/10.1145/2660193.2660234

47. Tizpaz-Niari, S., ˇCern´y, P., Chang, B.Y.E., Sankaranarayanan, S., Trivedi, A.: Dis-
criminating traces with time. In: International Conference on Tools and Algorithms
for the Construction and Analysis of Systems. pp. 21–37. Springer (2017)

48. Tizpaz-Niari, S., ˇCern´y, P., Chang, B.E., Trivedi, A.: Diﬀerential performance de-
bugging with discriminant regression trees. In: 32nd AAAI Conference on Artiﬁcial
Intelligence (AAAI). pp. 2468–2475 (2018)

49. Tizpaz-Niari, S., ˇCern´y, P., Trivedi, A.: Data-driven debugging for functional side

channels. arXiv preprint arXiv:1808.10502 (2018)

50. Wu, M., Guo, S., Schaumont, P., Wang, C.: Eliminating timing side-channel leaks
using program repair. In: Proceedings of the 27th ACM SIGSOFT International
Symposium on Software Testing and Analysis. pp. 15–26. ACM (2018)

51. Yarom, Y., Genkin, D., Heninger, N.: Cachebleed: a timing attack on openssl
constant-time rsa. Journal of Cryptographic Engineering 7(2), 99–112 (2017)
52. Zhang, D., Askarov, A., Myers, A.C.: Predictive mitigation of timing channels in
interactive systems. In: Proceedings of the 18th ACM conference on Computer and
communications security. pp. 563–574. ACM (2011)

53. Zhang, D., Askarov, A., Myers, A.C.: Language-based control and mitigation of

timing channels. PLDI 47(6), 99–110 (2012)

20

Tizpaz-Niari, ˇCern´y, and Trivedi

9 Appendix

9.1 Overview of Schmit

Schmit consists of three components:
1) Initial Security Analysis.
Inspired by [49], for each secret value, we use B-spline basis [42] in general to
model arbitrary timing functions of secret values in the domain of public inputs,
but we also allow simpler functional models such as polynomial functions. We
use the non-parametric functional clustering [20] with hierarchal algorithms [24]
to obtain the initial classes of observations or clusters. The clustering algorithm
groups timing functions that are (cid:15) close to each other in the same cluster. The
size of class is the number of secret values in the cluster. The l−norm distance
between clusters forms the penalty matrix.
Highlight. This step ﬁnds the classes of observations over secret values using
functional clustering and returns the label (cluster) of each secret value and the
distance (as a penalty) between the clusters.

Fig. 7. Schmit work-ﬂow. Schmit consists of three components.

2) Mitigation policy.
We uses the policy algorithms (Section 5) to calculate the mitigation policy
given the clusters, their sizes, and their distances. We use two types of algo-
rithms: deterministic and stochastic. The deterministic algorithm is an instance
of dynamic programming implemented in Java. The stochastic algorithms have
three variants for three types of information theory measure. The variant based
on Min-guess entropy is the main emphasis in this paper that implemented us-
ing Gurobi [21]. The two other variants (for Shannon and Guessing entropies)
are implemented in python using Scipy library [25]. See Section 6(C) for further
details.
Highlight. This step calculates the mitigation policy that shows how to merge
diﬀerent clusters to maximize an information theory criterion given an upper-
bound on the amount of performance overhead.
3) Enforcement of mitigation policy.
In the ﬁrst step, we characterize each class of observation with program inter-
nal properties. We use decision tree algorithms [13] to characterize each class of
observation with corresponding program internal features. Fig 2(b) in Section 2
is an example of decision tree model that characterizes each class of observation
of Fig 1(b) in Section 2 with the basic block invocations at line 16 of modExp

Quantitative Mitigation of Timing Side Channels

21

Fig. 8. (a) A program with three functional observations C1, C2 and C3. The dashed
curve C1,2,3 is the upper-envelope of functions C1, C2, and C3. (b) All possible resulting
combinations of functional observations resulting from adding delays to various clusters.

Fig. 9. Entropy values versus performance overhead bounds on Branch and loop 4. (a)
Min-guess entropy, (b) Shannon Entropy, (c) Guessing entropy.

method. In the second step, we enforce the mitigation policy. This step can be
done either with a monitoring system at run-time automatically or with a source
code transformation semi-automatically. The enforcement uses the decision tree
model and matches the properties enabled during an execution with the tree
model. Then, it adds extra delays, based on the mitigation policy, to the exe-
cution in order to enforce the mitigation policy. The result of mitigation can be
veriﬁed by applying the clustering algorithm on the mitigated execution times.
Highlight. This step uses the functional clusters and the decision tree model and
enforces the mitigation policy either with a monitoring system at run-time or
souce code transformations. The clustering algorithm over the mitigated execu-
tion times can be used to verify the mitigation model.

9.2 Exponential blow-up for functional mitigations.

Figure 9.2 shows possible observational classes CS for S (cid:54)= ∅ ⊆ {1, 2, 3} for
three observation classes C1, C2, and C3. The cluster CS corresponds to the
observation class with the execution-time equals to the upper-envelope of all
functions from the classes in S.

C1C2C3C{1,2,3}p0p1p2p3pMExecution timePublic inputsf1f2f3f1{1,2}f1{1,3}f1{1,2,3}f3{1,2,3}f3{1,3}f3{2,3}f2{2,3}f2{1,2}f2{1,2,3}C1C2C3C{1,2}C{1,3}C{2,3}C{1,2,3}22

Tizpaz-Niari, ˇCern´y, and Trivedi

9.3 Performance bounds versus entropy measures.

Fig 9 shows the relations between relaxing the performance bound and the en-
tropy values. For min-guess entropy, Fig 9(a) shows that the stochastic opti-
mization improves the entropy gradually from 95 to 186 by relaxing the bound.
However, the dynamic programming has only improved when the performance
bound exceeds 1.0. For the Shannon and guessing entropy, Fig 9(b) shows how
Schmit improves the entropy with relaxing the performance bounds.

