9
1
0
2

r
p
A
6
2

]

G
L
.
s
c
[

1
v
5
7
8
1
1
.
4
0
9
1
:
v
i
X
r
a

Learning to Prune: Speeding up Repeated Computations

Daniel Alabi
Harvard University
alabid@g.harvard.edu

Adam Tauman Kalai
Microsoft Research
noreply@microsoft.com

Katrina Ligett
Hebrew University
katrina@cs.huji.ac.il

Cameron Musco
Microsoft Research
camusco@microsoft.com

Christos Tzamos
University of Wisconsin-Madison
tzamos@wisc.edu

Ellen Vitercik
Carnegie Mellon University
vitercik@cs.cmu.edu

April 29, 2019

Abstract

It is common to encounter situations where one must solve a sequence of similar compu-
tational problems. Running a standard algorithm with worst-case runtime guarantees on each
instance will fail to take advantage of valuable structure shared across the problem instances.
For example, when a commuter drives from work to home, there are typically only a handful of
routes that will ever be the shortest path. A na¨ıve algorithm that does not exploit this common
structure may spend most of its time checking roads that will never be in the shortest path.
More generally, we can often ignore large swaths of the search space that will likely never contain
an optimal solution.

We present an algorithm that learns to maximally prune the search space on repeated com-
putations, thereby reducing runtime while provably outputting the correct solution each period
with high probability. Our algorithm employs a simple explore-exploit technique resembling
those used in online algorithms, though our setting is quite diﬀerent. We prove that, with re-
spect to our model of pruning search spaces, our approach is optimal up to constant factors.
Finally, we illustrate the applicability of our model and algorithm to three classic problems:
shortest-path routing, string search, and linear programming. We present experiments con-
ﬁrming that our simple algorithm is eﬀective at signiﬁcantly reducing the runtime of solving
repeated computations.

1 Introduction

Consider computing the shortest path from home to work every morning. The shortest path may
vary from day to day—sometimes side roads beat the highway; sometimes the bridge is closed due
to construction. However, although San Francisco and New York are contained in the same road
network, it is unlikely that a San Francisco-area commuter would ever ﬁnd New York along her
shortest path—the edge times in the graph do not change that dramatically from day to day.

With this motivation in mind, we study a learning problem where the goal is to speed up
repeated computations when the sequence of instances share common substructure. Examples
include repeatedly computing the shortest path between the same two nodes on a graph with varying
edge weights, repeatedly computing string matchings, and repeatedly solving linear programs with
mildly varying objectives. Our work is in the spirit of recent work in data-driven algorithm selection
[e.g., Gupta and Roughgarden, 2017, Balcan et al., 2017, 2018a,b] and online learning [e.g., Cesa-
Bianchi and Lugosi, 2006, although with some key diﬀerences, which we discuss below].

1

 
 
 
 
 
 
Figure 1: A standard algorithm computing the shortest path from the upper to the lower star will
explore many nodes (grey), even nodes in the opposite direction. Our algorithm learns to prune to
a subgraph (black) of nodes that have been included in prior shortest paths.

The basis of this work is the observation that for many realistic instances of repeated problems,
vast swaths of the search space may never contain an optimal solution—perhaps the shortest path
is always contained in a speciﬁc region of the road network; large portions of a DNA string may
never contain the patterns of interest; a few key linear programming constraints may be the only
ones that bind. Algorithms designed to satisfy worst-case guarantees may thus waste substantial
computation time on futile searching. For example, even if a single, ﬁxed path from home to work
were best every day, Dijkstra’s algorithm would consider all nodes within distance di from home
on day i, where di is the length of the optimal path on day i, as illustrated in Figure 1.

We develop a simple solution, inspired by online learning, that leverages this observation to
the maximal extent possible. On each problem, our algorithm typically searches over a small,
pruned subset of the solution space, which it learns over time. This pruning is the minimal subset
containing all previously returned solutions. These rounds are analogous to “exploit” rounds in
online learning. To learn a good subset, our algorithm occasionally deploys a worst-case-style
algorithm, which explores a large part of the solution space and guarantees correctness on any
instance. These rounds are analogous to “explore” rounds in online learning. If, for example, a
single ﬁxed path were always optimal, our algorithm would almost always immediately output that
path, as it would be the only one in its pruned search space. Occasionally, it would run a full
Dijkstra’s computation to check if it should expand the pruned set. Roughly speaking, we prove
that our algorithm’s solution is almost always correct, but its cumulative runtime is not much larger
than that of running an optimal algorithm on the maximally-pruned search space in hindsight. Our
results hold for worst-case sequences of problem instances, and we do not make any distributional
assumptions.

In a bit more detail, let f : X → Y be a function that takes as input a problem instance
x ∈ X and returns a solution y ∈ Y . Our algorithm receives a sequence of inputs from X. Our
high-level goal is to correctly compute f on almost every round while minimizing runtime. For
example, each x ∈ X might be a set of graph edge weights for some ﬁxed graph G = (V, E) and
f (x) might be the shortest s-t path for some vertices s and t. Given a sequence x1, . . . , xT ∈ X,
a worst-case algorithm would simply compute and return f (xi) for every instance xi. However, in
many application domains, we have access to other functions mapping X to Y , which are faster to
compute. These simpler functions are deﬁned by subsets S of a universe U that represents the entire
search space. We call each subset a “pruning” of the search space. For example, in the shortest
paths problem, U equals the set E of edges and a pruning S ⊂ E is a subset of the edges. The
function corresponding to S, which we denote fS : X → Y , also takes as input edge weights x, but

2

returns the shortest path from s to t using only edges from the set S. By deﬁnition, the function
that is correct on every input is f = fU . We assume that for every x, there is a set S∗(x) ⊆ U such
that fS(x) = f (x) if and only if S ⊇ S∗(x) – a mild assumption we discuss in more detail later on.
Given a sequence of inputs x1, . . . , xT , our algorithm returns the value fSi(xi) on round i, where
Si is chosen based on the ﬁrst i inputs x1, . . . , xi. Our goal is two fold: ﬁrst, we hope to minimize
the size of each Si (and thereby maximally prune the search space), since |Si| is often monotonically
related to the runtime of computing fSi(xi). For example, a shortest path computation will typically
run faster if we consider only paths that use a small subset of edges. To this end, we prove that if
S∗ is the smallest set such that fS∗(xi) = f (xi) for all i (or equivalently,1 S∗ = (cid:83)T
i=1 S∗(xi)), then

(cid:34)

E

1
T

T
(cid:88)

i=1

(cid:35)

|Si|

≤ |S∗| +

|U| − |S∗|
√
T

,

where the expectation is over the algorithm’s randomness. At the same time, we seek to minimize
the the number of mistakes the our algorithm makes (i.e., rounds i where f (xi) (cid:54)= fSi(xi)). We
prove that the expected fraction of rounds i where fSi(xi) (cid:54)= f (xi) is O(|S∗|/
T ). Finally, the
expected runtime2 of the algorithm is the expected time required to compute fSi(xi) for i ∈ [T ],
plus O(|S∗|

T ) expected time to determine the subsets S1, . . . , ST .

√

√

We instantiate our algorithm and corresponding theorem in three diverse settings—shortest-
path routing, linear programming, and string matching—to illustrate the ﬂexibility of our approach.
We present experiments on real-world maps and economically-motivated linear programs. In the
case of shortest-path routing, our algorithm’s performance is illustrated in Figure 1. Our algorithm
explores up to ﬁve times fewer nodes on average than Dijkstra’s algorithm, while sacriﬁcing accuracy
on only a small number of rounds. In the case of linear programming, when the objective function
is perturbed on each round but the constraints remain invariant, we show that it is possible to
signiﬁcantly prune the constraint matrix, allowing our algorithm to make fewer simplex iterations
to ﬁnd solutions that are nearly always optimal.

1.1 Related work

Our work advances a recent line of research studying the foundations of algorithm conﬁguration.
Many of these works study a distributional setting [Ailon et al., 2011, Clarkson et al., 2014, Gupta
and Roughgarden, 2017, Kleinberg et al., 2017, Balcan et al., 2017, 2018a,b, Weisz et al., 2018]: there
is a distribution over problem instances and the goal is to use a set of samples from this distribution
to determine an algorithm from some ﬁxed class with the best expected performance. In our setting,
there is no distribution over instances: they may be adversarially selected. Additionally, we focus
on quickly computing solutions for polynomial-time-tractable problems rather than on developing
algorithms for NP-hard problems, which have been the main focus of prior work.

Several works have also studied online algorithm conﬁguration without distributional assump-
tions from a theoretical perspective [Gupta and Roughgarden, 2017, Cohen-Addad and Kanade,
2017, Balcan et al., 2018b]. Before the arrival of any problem instance, the learning algorithm
ﬁxes a class of algorithms to learn over. The classes of algorithms that Gupta and Roughgarden
[2017], and Cohen-Addad and Kanade [2017], and Balcan et al. [2018b] study are inﬁnite, deﬁned
by real-valued parameters. The goal is to select parameters at each timestep while minimizing

1We explain this equivalence in Lemma 3.1.
2As we will formalize, when determining S1, . . . , ST , our algorithm must compute the smallest set S such that
fS(xi) = f (xi) on some of the inputs xi. In all of the applications we discuss, the total runtime required for these
computations is upper bounded by the total time required to compute fSi (xi) for i ∈ [T ].

3

regret. These works provide conditions under which it is possible to design algorithms achieving
sublinear regret. These are conditions on the cost functions mapping the real-valued parameters to
the algorithm’s performance on any input. In our setting, the choice of a pruning S can be viewed
as a parameter, but this parameter is combinatorial, not real-valued, so the prior analyses do not
apply.

Several works have studied how to take advantage of structure shared over a sequence of repeated
computations for speciﬁc applications, including linear programming [Banerjee and Roy, 2015] and
matching [Deb et al., 2006]. As in our work, these algorithms have full access to the problem
instances they are attempting to solve. These approaches are quite diﬀerent (e.g., using machine
classiﬁers) and highly tailored to the application domain, whereas we provide a general algorithmic
framework and instantiate it in several diﬀerent settings.

Since our algorithm receives input instances in an online fashion and makes no distributional
assumptions on these instances, our setting is reminiscent of online optimization. However, unlike
the typical online setting, we observe each input xi before choosing an output yi. Thus, if runtime
costs were not a concern, we could always return the best output for each input. We seek to trade
oﬀ correctness for lower runtime costs. In contrast, in online optimization, one must commit to
an output yi before seeing each input xi, in both the full information and bandit settings [see,
e.g., Kalai and Vempala, 2005, Awerbuch and Kleinberg, 2008].
In such a setting, one cannot
hope to return the best yi for each xi with signiﬁcant probability. Instead, the typical goal is that
the performance over all inputs should compete with the performance of the best ﬁxed output in
hindsight.

2 Model

We start by deﬁning our model of repeated computation. Let X be an abstract set of problem
instances and let Y be a set of possible solutions. We design an algorithm that operates over T
rounds: on round i, it receives an instance xi ∈ X and returns some element of Y .

Deﬁnition 2.1 (Repeated algorithm). Over T rounds, a repeated algorithm A encounters a se-
quence of inputs x1, x2, . . . , xT ∈ X. On round i, after receiving input xi, it outputs A(x1:i) ∈ Y ,
where x1:i denotes the sequence x1, . . . , xi. A repeated algorithm may maintain a state from period
to period, and thus A(x1:i) may potentially depend on all of x1, ..., xi.

We assume each problem instance x ∈ X has a unique correct solution (invoking tie-breaking
assumptions as necessary; in Section 6, we discuss how to handle problems that admit multiple
solutions). We denote the mapping from instances to correct solutions as f : X → Y . For example,
in the case of shortest paths, we ﬁx a graph G and a pair (s, t) of source and terminal nodes. Each
instance x ∈ X represents a weighting of the graph’s edges. The set Y consists of all paths from s
to t in G. Then f (x) returns the shortest path from s to t in G, given the edge weights x (breaking
ties according to some canonical ordering of the elements of Y , as discussed in Section 6). To
measure correctness, we use a mistake bound model [see, e.g., Littlestone, 1987].

Deﬁnition 2.2 (Repeated algorithm mistake bound). The mistake bound of the repeated algorithm
A given inputs x1, . . . , xT is

MT (A, x1:T ) = E

(cid:34) T

(cid:88)

(cid:35)
1[A(x1:i) (cid:54)= f (xi)]

,

i=1

where the expectation is over the algorithm’s random choices.

4

(a) Original unweighted graph G.

(b) Optimal pruning.

Figure 2: Repeated shortest paths and optimal pruning of a graph G. If the shortest path was
always s-b-e-t or s-b-d-t, it would be unnecessary to search the entire graph for each instance.

To minimize the number of mistakes, the na¨ıve algorithm would simply compute the function
f (xi) at every round i. However, in our applications, we will have the option of computing other
functions mapping the set X of inputs to the set Y of outputs that are faster to compute than f .
Broadly speaking, these simpler functions are deﬁned by subsets S of a universe U, or “prunings”
of U. For example, in the shortest paths problem, given a ﬁxed graph G = (V, E) as well as source
and terminal nodes s, t ∈ V , the universe is the set of edges, i.e., U = E. Each input x is a set of
edge weights and f (x) computes the shortest s-t path in G under the input weights. The simpler
function corresponding to a subset S ⊂ E of edges also takes as input weights x, but it returns the
shortest path from s to t using only edges from the set S (with fS(x) = ⊥ if no such path exists).
Intuitively, the universe U contains all the information necessary to compute the correct solution
f (x) to any input x, whereas the function corresponding to a subset S ⊂ U can only compute a
subproblem using information restricted to S.

Let fS : X → Y denote the function corresponding to the set S ⊆ U. We make two natural
assumptions on these functions. First, we assume the function corresponding to the universe U is
always correct. Second, we assume there is a unique smallest set S∗(x) ⊆ U that any pruning must
contain in order to correctly compute f (x). These assumptions are summarized below.

Assumption 2.1. For all x ∈ X, fU (x) = f (x). Also, there exists a unique smallest set S∗(x) ⊆ U
such that fU (x) = fS(x) if and only if S∗(x) ⊆ S.

Given a sequence of inputs x1, . . . , xT , our algorithm returns the value fSi(xi) on round i, where
the choice of Si depends on the ﬁrst i inputs x1, . . . , xi. In our applications, it is typically faster
to compute fS over fS(cid:48) if |S| < |S(cid:48)|. Thus, our goal is to minimize the number of mistakes the
algorithm makes while simultaneously minimizing E [(cid:80) |Si|]. Though we are agnostic to the speciﬁc
runtime of computing each function fSi, minimizing E [(cid:80) |Si|] roughly amounts to minimizing the
search space size and our algorithm’s runtime in the applications we consider.

We now describe how this model can be instantiated in three classic settings: shortest-path

routing, string search, and linear programming.

Shortest-path routing.
In the repeated shortest paths problem, we are given a graph G = (V, E)
(with static structure) and a ﬁxed pair s, t ∈ V of source and terminal nodes. In period i ∈ [T ], the
algorithm receives a nonnegative weight assignment xi : E → R≥0. Figure 2 illustrates the pruning
model applied to the repeated shortest paths problem.

For this problem, the universe is the edge set (i.e., U = E) and S is a subset of edges in the graph.
The set X consists of all possible weight assignments to edges in the graph G and Y ⊆ 2E ∪ {⊥} is

5

sadtbecfsbdtbethe set of all paths in the graph, with ⊥ indicating that no path exists. The function f (x) returns
the shortest s-t path in G given edge weights x. For any S ⊆ U, the function fS : X → Y computes
the shortest s-t path on the subgraph induced by the edges in S (breaking ties by a canonical edge
ordering). If S does not include any s-t path, we deﬁne fS(x) = ⊥. Part 1 of Assumption 2.1 holds
because U = E, so fU computes the shortest path on the entire graph. Part 2 of Assumption 2.1
also holds: since fS : X → Y computes the shortest s-t path on the subgraph induced by the edges
in S (breaking ties by some canonical edge ordering), we can see that fS(xi) = S∗(xi) if and only
if S∗(xi) ⊆ S. To “canonicalize” the algorithm so there is always a unique solution, we assume
there is a given ordering on edges and that ties are broken lexicographically according to the path
description. This is easily achieved by keeping the heap maintained by Dijkstra’s algorithm sorted
not only by distances but also lexicographically.

(cid:8)xT y : Ay ≤ b(cid:9), where we assume
Linear programming. We consider computing argmaxy∈Rn
that (A, b) ∈ Rm×n × Rm is ﬁxed across all times steps but the vector xi ∈ X ⊆ Rn deﬁning the
objective function xT
i y may diﬀer for each i ∈ [T ]. To instantiate our pruning model, the universe
U = [m] is the set of all constraint indices and each S ⊆ U indicates a subset of those constraints.
The set Y equals Rn ∪ {⊥}. For simplicity, we assume that the set X ⊆ Rn of objectives contains
only directions x such that there is a unique solution y ∈ Rn that is the intersection of exactly n
constraints in A. This avoids both dealing with solutions that are the intersection of more than n
constraints and directions that are under-determined and have inﬁnitely-many solutions forming a
facet. See Section 6 for a discussion of this issue in general.

Given x ∈ Rn, the function f computes the linear program’s optimal solution, i.e., f (x) =
(cid:8)xT y : Ay ≤ b(cid:9) . For a subset of constraints S ⊆ U, the function fS computes the
argmaxy∈Rn
optimal solution restricted to those constraints, i.e., fS(x) = argmaxy∈Rn{xT y : ASy ≤ bS},
where AS ∈ R|S|×n is the submatrix of A consisting of the rows indexed by elements of S and
bS ∈ R|S| is the vector b with indices restricted to elements of S. We further write fS(x) = ⊥
if there is no unique solution to the linear program (which may happen for small sets S even if
the whole LP does have a unique solution). Part 1 of Assumption 2.1 holds because AU = A and
bU = b, so it is indeed the case that fU = f . To see why part 2 of Assumption 2.1 also holds,
suppose that fS(x) = f (x). If f (x) (cid:54)= ⊥, the vector fS(x) must be the intersection of exactly n
constraints in AS, which by deﬁnition are indexed by elements of S. This means that S∗(x) ⊆ S.

String search.
In string search, the goal is to ﬁnd the location of a short pattern in a long
string. At timestep i, the algorithm receives a long string qi of some ﬁxed length n and a pat-
tern pi of some ﬁxed length m ≤ n. We denote the long string as qi =
and

, . . . , q(n)

(cid:16)

(cid:17)

q(1)
i

i

. The goal is to ﬁnd an index j ∈ [n − m + 1] such that

the pattern as pi =

(cid:16)

q(j)
i

, q(j+1)
i

(cid:17)

(cid:16)

p(1)
i
, . . . , q(j+m−1)
i

, . . . , p(m)
(cid:17)

i

pi =
. The function f returns the smallest such index j, or ⊥ if there is
no match. In this setting, the set X of inputs consists of all string pairs of length n and m (e.g.,
{A, T, G, C}n×m for DNA sequences) and the set Y = [n − m + 1] is the set of all possible match
indices. The universe U = [n − m + 1] also consists of all possible match indices. For any S ⊆ U,
(cid:17)
the function fS(qi, pi) returns the smallest index j ∈ S such that pi =
,
which we denote j∗
i . It returns ⊥ if there is no match. We can see that part 1 of Assumption 2.1
holds: fU (q, p) = f (q, p) for all (q, p) ∈ X, since fU checks every index in [n − m + 1] for a match.
Moreover, part 2 of Assumption 2.1 holds because fU (xi) = fS(xi) if and only if S∗(xi) = {j∗
i } ⊆ S.

, . . . , q(j+m−1)
i

, q(j+1)
i

q(j)
i

(cid:16)

6

3 The algorithm

We now present an algorithm (Algorithm 1), denoted A∗, that encounters a sequence of inputs
x1, . . . , xT one-by-one. At timestep i, it computes the value fSi(xi), where the choice of Si ⊆ U
depends on the ﬁrst i inputs x1, . . . , xi. We prove that, in expectation, the number of mistakes it
makes (i.e., rounds where fSi(xi) (cid:54)= f (xi)) is small, as is (cid:80)T

Our algorithm keeps track of a pruning of U, which we call ¯Si at timestep i. In the ﬁrst round,
the pruned set is empty ( ¯S1 = ∅). On round i, with some probability pi, the algorithm computes the
function fU (xi) and then computes S∗(xi), the unique smallest set that any pruning must contain
in order to correctly compute fU (xi). (As we discuss in Section 3.1, in all of the applications we
consider, computing S∗(xi) amounts to evaluating fU (xi).) The algorithm unions S∗(xi) with ¯Si
to create the set ¯Si+1. Otherwise, with probability 1 − pi, it outputs f ¯Si
(xi), and does not update
the set ¯Si (i.e., ¯Si+1 = ¯Si). It repeats in this fashion for all T rounds.

i=1 |Si|.

Algorithm 1 Our repeated algorithm A∗
1: ¯S1 ← ∅
2: for i ∈ {1, . . . , T } do
3:
4: With probability pi, output fU (xi). Compute S∗(xi) and set ¯Si+1 ← ¯Si ∪ S∗(xi).
5:

Otherwise (with probability 1 − pi), output f ¯Si

(xi) and set ¯Si+1 ← ¯Si.

Receive input xi ∈ X.

In the remainder of this section, we use the notation S∗ to denote the smallest set such that

fS∗(xi) = f (xi) for all i ∈ [T ]. To prove our guarantees, we use the following helpful lemma:
Lemma 3.1. For any x1, . . . , xT ∈ X, S∗ = (cid:83)T
Proof. First, we prove that S∗ ⊇ ∪T
i=1S∗(xi). For a contradiction, suppose that for some i ∈ [T ],
there exists an element j ∈ S∗(xi) such that j (cid:54)∈ S∗. This means that fS∗(xi) = f (xi), but
S∗ (cid:54)⊇ S∗(xi), which contradicts Assumption 2.1: S∗(xi) is the unique smallest subset of U such that
for any set S ⊆ U, f (xi) = fS(xi) if and only if S∗(xi) ⊆ S. Therefore, S∗ ⊇ ∪T
i=1S∗(xi). Next,
i=1S∗(xi). Since S∗(xi) ⊆ C, Assumption 2.1 implies that f (xi) = fC(xi) for all i ∈ [T ].
let C = ∪T
Based on the deﬁnition of S∗ and the fact that S∗ ⊇ C, we conclude that S∗ = C = ∪T

i=1 S∗(xi).

i=1S∗(xi).

We now provide a mistake bound for Algorithm 1.

Theorem 3.2. For any p ∈ (0, 1] such that pi ≥ p for all i ∈ [T ] and any inputs x1, . . . , xT ,
Algorithm 1 has a mistake bound of

MT (A∗, x1:T ) ≤

|S∗|(1 − p)(1 − (1 − p)T )
p

≤

|S∗|
p

.

Proof. Let S1, . . . , ST be the sets such that on round i, Algorithm 1 computes the function fSi.
Consider any element e ∈ S∗. Let NT (e) be the number of times e (cid:54)∈ Si but e ∈ S∗(xi) for some
In other words, NT (e) = |{i : e (cid:54)∈ Si, e ∈ S∗(xi)}|. Every time the algorithm makes a
i ∈ [T ].
mistake, the current set Si must not contain some e ∈ S∗(xi) (otherwise, Si ⊇ S∗(xi), so the
algorithm would not have made a mistake by Assumption 2.1). This means that every time the
i=1S∗(xi).
algorithm makes a mistake, NT (e) is incremented by 1 for at least one e ∈ S∗ = ∪T
Therefore,

MT (A∗, x1:T ) ≤

E[NT (e)],

(1)

(cid:88)

e∈S∗

7

where the expectation is over the random choices of Algorithm 1.

For any element e ∈ S∗, let i1, . . . , it be the iterations where for all (cid:96) ∈ [t], e ∈ S∗ (xi(cid:96)). By
deﬁnition, NT (e) will only be incremented on some subset of these rounds. Suppose NT (e) is
incremented by 1 on round ir. It must be that e (cid:54)∈ Sir , which means Sir (cid:54)= U, and thus Sir = ¯Sir .
Since e (cid:54)∈ ¯Sir , it must be that e (cid:54)∈ ¯Si(cid:96) for (cid:96) ≤ r since ¯Sir ⊇ ¯Sir−1 ⊇ · · · ⊇ ¯Si1. Therefore, in each
round i(cid:96) with (cid:96) < r, Algorithm 1 must not have computed S∗ (xi(cid:96)), because otherwise e would have
been added to the set ¯Si(cid:96)+1. We can bound the probability of these bad events as

P (cid:2)Sir = ¯Sir and Algorithm 1 does not compute S∗ (xi(cid:96)) for (cid:96) < r(cid:3) =

r
(cid:89)

(cid:96)=1

(1 − pi(cid:96)) ≤ (1 − p)r.

As a result,

E[NT (e)] ≤

t
(cid:88)

(1 − p)r ≤

T
(cid:88)

(1 − p)r =

r=1

r=1

(1 − p)(1 − (1 − p)T )
p

.

(2)

The theorem statement follows by combining Equations (1) and (2).

Corollary 3.3. Algorithm 1 with pi = 1√
i

has a mistake bound of MT (A∗, x1:T ) ≤ |S∗|

√

T .

In the following theorem, we prove that the mistake bound in Theorem 3.2 is nearly tight. In
particular, we show that for any k ∈ {1, . . . , T } there exists a random sequence of inputs x1, . . . , xT
such that E [|S∗|] ≈ k and MT (A∗, x1:T ) = k(1−p)(1−(1−p/k)T )
. This nearly matches the upper bound
from Theorem 3.2 of

|S∗|(1 − p)(1 − (1 − p)T )
p
The full proof is in Appendix A. In Section 4, we show that in fact, A∗ achieves a near optimal
tradeoﬀ between runtime and pruned subset size over all possible pruning-based repeated algo-
rithms.

p

.

Theorem 3.4. For any p ∈ (0, 1], any time horizon T , and any k ∈ {1, . . . , T }, there is a random
sequence of inputs to Algorithm 1 such that

E[|S∗|] = k

(cid:32)

(cid:18)

1 −

1 −

(cid:19)T (cid:33)

1
k

and its expected mistake bound with pi = p for all i ∈ [T ] is

E[MT (A∗, x1:T )] =

k(1 − p)(1 − (1 − p/k)T )
p

.

The expectation is over the sequence of inputs.

Proof sketch. We base this construction on shortest-path routing. There is a ﬁxed graph G = (V, E)
where V consists of two vertices labeled s and t and E consists of k edges labeled {1, . . . , k}, each
of which connects s and t. The set X = (cid:8)x(1), . . . , x(k)(cid:9) consists of k possible edge weightings.
Under the edge weights x(i), the edge i has a weight of 0 and all other edges j (cid:54)= i have a weight
of 1. We prove the theorem by choosing an input at each round uniformly at random from X.

8

In Theorem 3.2, we bounded the expected number of mistakes Algorithm 1 makes. Next, we
bound E (cid:2) 1
(cid:80) |Si|(cid:3), where Si is the set such that Algorithm 1 outputs fSi(xi) in round i (so either
T
Si = ¯Si or Si = U, depending on the algorithm’s random choice). In our applications, minimizing
E (cid:2) 1
(cid:80) |Si|(cid:3) means minimizing the search space size, which roughly amounts to minimizing the
T
average expected runtime of Algorithm 1.

Theorem 3.5. For any inputs x1, . . . , xT , let S1, . . . , ST be the sets such that on round i, Algo-
rithm 1 computes the function fSi. Then

(cid:34)

E

1
T

T
(cid:88)

i=1

(cid:35)

|Si|

≤ |S∗| +

1
T

T
(cid:88)

i=1

pi(|U| − |S∗|),

where the randomness is over the coin tosses of Algorithm 1.

Proof. We know that for all i, Si = U with probability pi and Si = ¯Si with probability 1 − pi.
Therefore,

(cid:35)

|Si|

=

(cid:34) T

(cid:88)

E

i=1

T
(cid:88)

i=1

E[|Si|] =

T
(cid:88)

i=1

pi|U| + (1 − pi)E[| ¯Si|] ≤

T
(cid:88)

i=1

pi|U| + (1 − pi)|S∗|,

where the ﬁnal inequality holds because ¯Si ⊆ S∗ for all i ∈ [T ].

If we set pi = 1/

√

i for all i, we have the following corollary, since (cid:80)T

√

i=1 pi ≤ 2

T .

Corollary 3.6. Given a set of inputs x1, . . . , xT , let S1, ..., ST be the sets such that on round i,
Algorithm 1 computes the function fSi. If pi = 1√
i

for all i ∈ [T ], then

(cid:34)

E

1
T

T
(cid:88)

i=1

(cid:35)

|Si|

≤ |S∗| +

2(|U| − |S∗|)
√
T

,

where the expectation is over the random choices of Algorithm 1.

3.1 Instantiations of Algorithm 1

We now revisit and discuss instantiations of Algorithm 1 for the three applications outlined in
Section 2: shortest-path routing, linear programming, and string search. For each problem, we
describe how one might compute the sets S∗(xi) for all i ∈ [T ].

In this setting, the algorithm computes the true shortest path f (x)
Shortest-path routing.
using, say, Dijkstra’s shortest-path algorithm, and the set S∗(x) is simply the union of edges in that
path. Since S∗ = ∪T
T given by Corollary 3.3 is particularly
strong when the shortest path does not vary much from day to day. Corollary 3.6 guarantees
that the average edge set size run through Dijkstra’s algorithm is at most |S∗| + 2(|E|−|S∗|)
. Since
the worst-case running time of Dijkstra’s algorithm on a graph G(cid:48) = (V (cid:48), E(cid:48)) is ˜O(|V (cid:48)| + |E(cid:48)|),
minimizing the average edge set size is a good proxy for minimizing runtime.

i=1S∗(xi), the mistake bound of |S∗|

√

√

T

9

√

In the context of linear programming, computing the set S∗(xi) is equiv-
Linear programming.
i=1S∗(xi), the
alent to computing f (x) and returning the set of tight constraints. Since S∗ = ∪T
mistake bound of |S∗|
T given by Corollary 3.3 is strongest when the same constraints are tight
across most timesteps. Corollary 3.6 guarantees that the average constraint set size considered in
each round is at most |S∗| + 2(m−|S∗|)
, where m is the total number of constraints. Since many
well-known solvers take time polynomial in |Si| to compute fSi, minimizing E [(cid:80) |Si|] is a close
proxy for minimizing runtime.

√

T

(cid:17)

, . . . , q(j+m−1)
i

, which we denote j∗

In this setting, the set S∗(qi, pi) consists of the smallest index j such that pi =
String search.
(cid:16)
q(j)
, q(j+1)
i . This means that computing S∗(qi, pi) is equivalent
i
i
√
to computing f (qi, pi). The mistake bound of |S∗|
T given by Corollary 3.3
is particularly strong when the matching indices are similar across string pairs. Corollary 3.6
guarantees that the average size of the searched index set in each round is at most |S∗| + 2(n−|S∗|)
.
Since the expected average running time of our algorithm using the na¨ıve string-matching algorithm
(cid:104) 1
to compute fSi is E
T

amounts to minimizing runtime.

(cid:105)
, minimizing E

(cid:105)
i=1 |Si|

T = (cid:12)

i=1 {j∗

i=1 |Si|

(cid:104) m
T

i }(cid:12)
(cid:12)

(cid:12)∪T

(cid:80)T

(cid:80)T

√

√

T

4 Lower bound on the tradeoﬀ between accuracy and runtime

We now prove a lower bound on the tradeoﬀ between runtime and the number of mistakes made
by any repeated algorithm. We analyze a shortest path problem with two nodes s and t connected
by m + 1 parallel edges (E = [m + 1]). Thus, all paths are single edges. For any m ≥ 1 and T > 1,
consider the following distribution µm,T over T -tuples of edge weights in R(m+1)×T :

• The weight on edge m + 1 is always 1/2.

• An edge e ∈ [m] and integer r ∈ [2T ] are chosen uniformly at random. The weight on edge e

is 1 on periods preceding r and 0 from periods r or later.

• The weight on every other edge in [m] \ {e} is 1 on every period.

Note that because r ∈ [2T ], with probability 1/2, r > T and edge m + 1 will be the unique shortest
path (S∗ = {m + 1}) for all T periods. Otherwise, S∗ = {e, m + 1}. We say that an algorithm A
inspects an edge e on period i if it examines the memory location associated with that edge.

Theorem 4.1. Fixing m ≥ 1 and any even integer T > 1, any repeated algorithm A must satisfy:

E[m + number of inspections made by A] · E[1 + number of mistakes made by A] ≥ mT /8,

where the expectation is over the random edge weights and the randomness of the algorithm.

The total number of inspections the algorithm A makes is clearly a lower bound on its total
runtime, so Theorem 4.1 demonstrates a tradeoﬀ between runtime and accuracy. This theorem is
tight up to constant factors, as can be seen by the trivial algorithm that inspects every edge until
it encounters a 0 on some edge e and then outputs that edge henceforth, which makes no mistakes
and runs in expected time Θ(mT ). Conversely, the algorithm that always outputs edge m + 1 does
not make any inspections and makes Θ(T ) expected mistakes.

Finally our algorithm, when run with ﬁxed p, achieves at most Θ(1/p) expected mistakes and
makes an expected Θ(pmT ) number of inspections and hence matches this tradeoﬀ, up to constant
factors. The proof of Theorem 4.1 is deferred until Appendix B.

10

the nodes
(a) Grey nodes:
visited by Dijkstra’s algorithm.
Black nodes: the nodes in our
algorithm’s pruned subgraph.

(b) Top line: average number
of nodes Dijkstra’s algorithm ex-
plores. Bottom line: average
number of nodes Algorithm 1 ex-
plores.

(c) Top line: average number
of simplex iterations the simplex
algorithm makes. Bottom line:
average number of simplex iter-
ations Algorithm 1 makes.

Figure 3: Empirical evaluation of Algorithm 1 applied to shortest-path routing in Pittsburgh
(Figures 3a and 3b) and linear programming (Figure 3c).

5 Experiments

In this section, we present experimental results for shortest-path routing and linear programming.

√

Shortest-path routing. We test Algorithm 1’s performance on real-world street maps, which
we access via Python’s OSMnx package [Boeing, 2017]. Each street is an edge in the graph and each
intersection is a node. The edge’s weight is the street’s distance. We run our algorithm for 30 rounds
(i.e., T = 30) with pi = 1/
i for all i ∈ [T ]. On each round, we randomly perturb each edge’s
weight via the following procedure. Let G = (V, E) be the original graph we access via Python’s
OSMnx package. Let x ∈ R|E| be a vector representing all edges’ weights. On the ith round, we
select a vector ri ∈ R|E| such that each component is drawn i.i.d. from the normal distribution with
a mean of 0 and a standard deviation of 1. We then deﬁne a new edge-weight vector xi such that
xi[j] = 1{x[j]+ri[j]>0} (x[j] + ri[j]) . In Appendix C, we experiment with alternative perturbation
methods.

In Figures 3a and 3b, we illustrate our algorithm’s performance in Pittsburgh. Figure 3a
illustrates the nodes explored by our algorithm over T = 30 rounds. The goal is to get from the
upper to the lower star. The nodes colored grey are the nodes Dijkstra’s algorithm would have
visited if we had run Dijkstra’s algorithm on all T rounds. The nodes colored black are the nodes in
the pruned subgraph after the T rounds. Figure 3b illustrates the results of running our algorithm
a total of 5000 times (T = 30 rounds each run). The top (orange) line shows the number of nodes
Dijkstra’s algorithm explored averaged over all 5000 runs. The bottom (blue) line shows the average
number of nodes our algorithm explored. Our algorithm returned the incorrect path on a 0.068
fraction of the 5000 · T = 150, 000 rounds. In Appendix C, we show a plot of the average pruned
set size as a function of the number of rounds.

Linear programming. We generate linear programming instances representing the linear relax-
ation of the combinatorial auction winner determination problem. See Appendix C for the speciﬁc
form of this linear relaxation. We use the Combinatorial Auction Test Suite (CATS) [Leyton-Brown
et al., 2000] to generate these instances. This test suite is meant to generate instances that are
realistic and economically well-motivated. We use the CATS generator to create an initial instance
with an objective function deﬁned by a vector x and constraints deﬁned by a matrix A and a vector
b. On each round, we perturb the objective vector as we describe in Appendix C.2.

11

√

From the CATS “Arbitrary” generator, we create an instance with 204 bids and 538 goods
which has 204 variables and 946 constraints. We run Algorithm 1 for 30 rounds (T = 30) with
pi = 1/
i for all i ∈ [T ], and we repeat this 5000 times. In Figure 3c, the top (orange) line shows
the number of simplex iterations the full simplex algorithm makes averaged over all 5000 runs. The
bottom (blue) line shows the number of simplex iterations our algorithm makes averaged over all
5000 runs. We solve the linear program on each round using the SciPy default linear programming
solver [Jones et al., 2001–], which implements the simplex algorithm [Dantzig, 2016]. Our algorithm
returned the incorrect solution on a 0.018 fraction of the 5000·T = 150, 000 rounds. In Appendix C,
we show a plot of the average pruned set size as a function of the number of rounds.

6 Multiple solutions and approximations

In this work, we have assumed that each problem has a unique solution, which we can enforce by
deﬁning a canonical ordering on solutions. For string matching, this could be the ﬁrst match in a
string as opposed to any match. For shortest-path routing, it is not diﬃcult to modify shortest-path
algorithms to ﬁnd, among the shortest paths, the one with lexicographically “smallest” description
given some ordering of edges. Alternatively, one might simply assume that there is exactly one
solution, e.g., no ties in a shortest-path problem with real-valued edge weights. This latter solution
is what we have chosen for the linear programming model, for simplicity.

It would be natural to try to extend our work to problems that have multiple solutions, or even
to approximate solutions. However, addressing multiple solutions in repeated computation rapidly
raises NP-hard challenges. To see this, consider a graph with two nodes, s and t, connected by m
parallel edges. Suppose the goal is to ﬁnd any shortest path and suppose that in each period, the
edge weights are all 0 or 1, with at least one edge having weight 0. If Zi is the set of edges with 0
weight on period i, ﬁnding the smallest pruning which includes a shortest path on each period is
trivially equivalent to set cover on the sets Zi. Hence, any repeated algorithm handling problems
with multiple solutions must address this computational hardness.

7 Conclusion

We propose an algorithm for quickly solving a series of related problems. Our algorithm learns
irrelevant regions of the solution space that may be pruned across instances. With high probability,
our algorithm makes few mistakes, and it may prune large swaths of the search space. For problems
where the solution can be checked much more quickly than found (such as linear programming),
one can also check each solution and re-run the worst-case algorithm on the few errors to ensure
zero mistakes. In other cases, there is a tradeoﬀ between the mistake probability and runtime.

Acknowledgments

This work was supported in part by Israel Science Foundation (ISF) grant #1044/16, a subcontract
on the DARPA Brandeis Project, and the Federmann Cyber Security Center in conjunction with
the Israel national cyber directorate.

12

References

Nir Ailon, Bernard Chazelle, Kenneth L. Clarkson, Ding Liu, Wolfgang Mulzer, and C. Seshadhri.

Self-improving algorithms. SIAM J. Comput., 40(2):350–375, 2011.

Baruch Awerbuch and Robert Kleinberg. Online linear optimization and adaptive routing. J.

Comput. Syst. Sci., 74(1):97–114, 2008.

Maria-Florina Balcan, Vaishnavh Nagarajan, Ellen Vitercik, and Colin White. Learning-theoretic
foundations of algorithm conﬁguration for combinatorial partitioning problems. Proceedings of
the Conference on Learning Theory (COLT), 2017.

Maria-Florina Balcan, Travis Dick, Tuomas Sandholm, and Ellen Vitercik. Learning to branch.

Proceedings of the International Conference on Machine Learning (ICML), 2018a.

Maria-Florina Balcan, Travis Dick, and Ellen Vitercik. Dispersion for data-driven algorithm design,
online learning, and private optimization. Proceedings of the IEEE Symposium on Foundations
of Computer Science (FOCS), 2018b.

Ashis Gopal Banerjee and Nicholas Roy. Eﬃciently solving repeated integer linear programming
problems by learning solutions of similar linear programming problems using boosting trees.
Technical Report MIT-CSAIL-TR-2015-00, MIT Computer Science and Artiﬁcial Intelligence
Laboratory, 2015.

Geoﬀ Boeing. OSMnx: New methods for acquiring, constructing, analyzing, and visualizing com-

plex street networks. Computers, Environment and Urban Systems, 65:126–139, 2017.

Nicolo Cesa-Bianchi and G´abor Lugosi. Prediction, learning, and games. Cambridge university

press, 2006.

Kenneth L. Clarkson, Wolfgang Mulzer, and C. Seshadhri. Self-improving algorithms for coordi-

natewise maxima and convex hulls. SIAM J. Comput., 43(2):617–653, 2014.

Vincent Cohen-Addad and Varun Kanade. Online Optimization of Smoothed Piecewise Constant
Functions. In Proceedings of the International Conference on Artiﬁcial Intelligence and Statistics
(AISTATS), 2017.

George Dantzig. Linear programming and extensions. Princeton University Press, 2016.

Supratim Deb, Devavrat Shah, and et al. Fast matching algorithms for repetitive optimization: An
application to switch scheduling. In Proceedings of the Conference on Information Sciences and
Systems (CISS), 2006.

Rishi Gupta and Tim Roughgarden. A PAC approach to application-speciﬁc algorithm selection.

SIAM J. Comput., 46(3):992–1017, 2017.

Eric Jones, Travis Oliphant, Pearu Peterson, et al. SciPy: Open source scientiﬁc tools for Python,

2001–. URL http://www.scipy.org/. [Online; accessed January 2019].

Adam Tauman Kalai and Santosh Vempala. Eﬃcient algorithms for online decision problems. J.

Comput. Syst. Sci., 71(3):291–307, 2005.

13

Robert Kleinberg, Kevin Leyton-Brown, and Brendan Lucier. Eﬃciency through procrastination:
Approximately optimal algorithm conﬁguration with runtime guarantees. In Proceedings of the
International Joint Conference on Artiﬁcial Intelligence (IJCAI), 2017.

Kevin Leyton-Brown, Mark Pearson, and Yoav Shoham. Towards a universal test suite for com-
binatorial auction algorithms. In Proceedings of the ACM Conference on Electronic Commerce
(ACM-EC), 2000.

Nick Littlestone. Learning quickly when irrelevant attributes abound: A new linear-threshold

algorithm. Machine Learning, 2(4):285–318, 1987.

Gell´ert Weisz, Andr´es Gy¨orgy, and Csaba Szepesv´ari. LEAPSANDBOUNDS: A method for ap-
proximately optimal algorithm conﬁguration. In Proceedings of the International Conference on
Machine Learning (ICML), 2018.

A Proofs from Section 3

Theorem 3.4. For any p ∈ (0, 1], any time horizon T , and any k ∈ {1, . . . , T }, there is a random
sequence of inputs to Algorithm 1 such that

E[|S∗|] = k

(cid:32)

(cid:18)

1 −

1 −

(cid:19)T (cid:33)

1
k

and its expected mistake bound with pi = p for all i ∈ [T ] is

E[MT (A∗, x1:T )] =

k(1 − p)(1 − (1 − p/k)T )
p

.

The expectation is over the sequence of inputs.

Proof. We base our construction on the shortest path problem. There is a ﬁxed graph G = (V, E)
where V = {s, t} consists of two vertices labeled s and t and E consists of k edges labeled {1, . . . , k},
each of which connects s and t. The set X = (cid:8)x(1), . . . , x(k)(cid:9) ⊂ {0, 1}k consists of k possible edge
weightings, where

x(i)[j] =

(cid:40)
0
1

if i = j
if i (cid:54)= j.

In other words, under the edge weights xi, the edge i has a weight of 0 and all other edges j (cid:54)= i
have a weight of 1. The shortest path from s to t under the edge weights x(i) consists of the edge i
and has a total weight of 0. Therefore, f (cid:0)x(i)(cid:1) = S∗ (cid:0)x(i)(cid:1) = {i}. Given any non-empty subset of
(cid:0)x(i)(cid:1) = {i} if i ∈ S, and otherwise breaks ties according to a ﬁxed but arbitrary
edges S ⊆ E, fS
tie-breaking rule.

To construct the random sequence of inputs from the theorem statement, in each round i we
i=1S∗(xi),
, because when throwing T balls uniformly at random into k bins, the

choose the input xi uniformly at random from the set X. Therefore, letting S∗ = ∪T
1 − (cid:0)1 − 1
E[|S∗|] = k
k
expected number of empty bins is k (cid:0)1 − 1
k

(cid:1)T (cid:17)

(cid:1)T .

(cid:16)

We now prove that

E[MT (A∗, x1:T )] =

k(1 − p)(1 − (1 − p/k)T )
p

,

14

where the expectation is over the sequence of inputs. To this end, let S1, . . . , ST be the sets such
that at round i, Algorithm 1 outputs fSi(xi).

E[MT (A∗, x1:T )]
T
(cid:88)

P[Mistake made at round i]

i=1
T
(cid:88)

k
(cid:88)

i=1

j=1

T
(cid:88)

k
(cid:88)

i=1

j=1

T
(cid:88)

k
(cid:88)

i=1

j=1

(1 − p)
k

P[Si = ¯Si, x(j) = xi, and j (cid:54)∈ ¯Si]

P[j (cid:54)∈ ¯Si | Si = ¯Si and x(j) = xi] · P[Si = ¯Si and x(j) = xi]

P[j (cid:54)∈ ¯Si | Si = ¯Si and x(j) = xi] · P[Si = ¯Si] · P[x(j) = xi]

T
(cid:88)

k
(cid:88)

i=1

j=1

P[j (cid:54)∈ ¯Si | Si = ¯Si and x(j) = xi].

=

=

=

=

=

Analyzing a single summand,

P[j (cid:54)∈ ¯Si | Si = ¯Si and x(j) = xi]
i−1
(cid:88)

Pr[xj is the input on exactly t rounds before round i and on those rounds, S(cid:96) = ¯S(cid:96)]

=

=

=

t=0
i−1
(cid:88)

t=0
(cid:16)

1 −

(cid:17)i−1

.

p
k

(cid:18)i − 1
t

(cid:19) (cid:18) 1 − p

k

(cid:19)t (cid:18)

1 −

1
k

(cid:19)i−1−t

Therefore,

E[MT (A∗, x1:T )] =

1 − p
k

T
(cid:88)

k
(cid:88)

(cid:16)

i=1

j=1

(cid:17)i−1

1 −

p
k

= (1 − p)

k(1 − p)

T
(cid:88)

i=1
(cid:16)

(cid:16)

1 −

(cid:17)i−1

p
k
1 − (1 − p/k)T (cid:17)

=

p

,

as claimed.

B Proof of lower bound

Theorem 4.1. Fixing m ≥ 1 and any even integer T > 1, any repeated algorithm A must satisfy:

E[m + number of inspections made by A] · E[1 + number of mistakes made by A] ≥ mT /8,

where the expectation is over the random edge weights and the randomness of the algorithm.

15

Proof. First, consider a deterministic algorithm A. We say that A inspects edge e on period i if it
examines the memory location for edge e’s weight on period i. Let n be the total number of edges
that would be inspected during the ﬁrst T periods if r > T , which is well deﬁned since when r > T ,
the weights are all ﬁxed and hence the choices of the deterministic algorithm on the ﬁrst T periods
are ﬁxed. In fact, since r > T with probability 1/2 the expected number of inspections is at least
n/2.

We next observe that before A has inspected an edge whose weight is 0, WLOG we may assume
that A chooses edge m + 1 – this minimizes its expected number of mistakes since edge m + 1 has
probability at least 1/2 of being the best conditional on any number of weight-1 inspections. (Once
it inspects a 0 on e, of course runtime and mistakes are minimized by simply choosing e henceforth
without any further inspections or calculations.)

Let B ⊆ [m] × [T ] be the set of edges and times that are not inspected by A (excluding edge
m + 1). We now bound the expected number of mistakes in terms of b = |B| = mT − n. We no
longer assume r > T , but we can still use n as it is well deﬁned. For each (e(cid:48), r(cid:48)) ∈ B, there will be
a mistake on r(cid:48) if e = e(cid:48) and r ≤ r(cid:48) and (e, r), (e, r + 1), . . . , (e, r(cid:48)) ∈ B. Hence, we divide B into a
collection I of maximal consecutive intervals, Iaij = {(a, i), (a, i + 1), . . . , (a, j)} ⊆ B, where either
i = 1 or (a, i − 1) (cid:54)∈ B and j = T or (a, j + 1) (cid:54)∈ B. Let b = |B| denote the total length of all such
intervals, which is b = mT − n. For any such interval I ∈ I, there is a probability of |I|/(2mT ) that
(e, r) ∈ I, because there is a 1/2 probability that r ≤ T and, conditional on this, (e, r) is uniform
from [m] × [T ]. Moreover, conditional on (e, r) ∈ I, the expected number of mistakes is (1 + |I|)/2
because this is the expected length of the part of the interval that is at or after r. Hence, the
expected number of mistakes is,

E[total mistakes] ≥

(1 + |I|)|I|
4mT

=

b
4mT

(cid:88)

I∈I

+

(cid:88)

I∈I

|I|2
4mT

.

(3)

The number of intervals is at most N = m + n because: (a) with no inspections, there are m
intervals, (b) each additional inspection can create at most 1 interval by splitting an interval into
two, and (c) there are n edge-period inspections. By the convexity of the function f (x) = x2 and
(3), the lower-bound on expected number of mistakes from above is at least,

E(e,r)[total mistakes] ≥

b
4mT

+ N

(b/N )2
4mT

=

b(N + b)
4mT N

=

(mT − n)(m + mT )
4(m + n)mT

≥

mT
4(m + n)

− 1.

using b = mT − n and simple arithmetic.

This gives the lower bound on,

E(e,r)[m + number of inspections] · E(e,r)[1 + total mistakes] ≥ (m + n/2)

mT
4(m + n)

≥

mT
8

,

as required for deterministic A. To complete the proof, we need to show that the above holds, in
expectation, for randomized A as well. For a given randomized algorithm Az with random bits z,
we can consider two quantities,

Vz = E(e,r)[m + number of inspections of Az] and Wz = E(e,r)[1 + total mistakes of Az].

Now, we know that for all speciﬁc z, Az is a deterministic algorithm and hence VzWz ≥ mT /8
for all z. Finally note that the set S = {(V, W ) ∈ R2
+ | V W ≥ mT /8} is a convex set and since
(Vz, Wz) ∈ S for all z, (Ez[Vz], Ez[Wz]) ∈ S by convexity.

16

(a) Average pruned set size for shortest-path rout-
ing.

(b) Average pruned set size for linear programming.

Figure 4: Average size of the pruned set ¯Si in Algorithm 1.

C Additional information about experiments

Figure 4 illustrates the average size of the pruned set ¯Si in Algorithm 1, which we ran a total of
5000 times, with T = 30 rounds each run. Figure 4a corresponds to shortest-path routing and
Figure 4b corresponds to linear programming, with the same setup as described in Section 5.

C.1 Shortest-path routing

√

In Figure 5, we present several additional experiments using varying perturbation methods. Fig-
ures 5a and 5b have the same experimental setup as in the main body except we employ a Gaus-
sian distribution with smaller variance. We run our algorithm for thirty rounds (i.e., T = 30)
with pi = 1/
i for all i ∈ [T ]. On each round, we randomly perturb each edge’s weight via
the following procedure. Let G = (V, E) be the original graph we access via Python’s OSMnx
package. Let x ∈ R|E| be a vector representing all edges’ weights. On the ith round, we select
a vector ri ∈ R|E| such that each component is drawn i.i.d. from the normal distribution with a
mean of 0 and a standard deviation of 1/2. We then deﬁne a new edge-weight vector xi such that
xi[j] = 1{x[j]+ri[j]>0} (x[j] + ri[j]) . Our algorithm returned the incorrect path on a 0.034 fraction
of the 5000 · T = 150, 000 rounds.

√

In the remaining panels of Figure 5, we employ the uniform distribution rather than the Gaussian
In Figures 5c and 5d, we run our algorithm for thirty rounds (i.e., T = 30) with
distribution.
pi = 1/
i for all i ∈ [T ]. On each round, we randomly perturb each edge’s weight via the following
procedure. Let G = (V, E) be the original graph we access via Python’s OSMnx package. Let
x ∈ R|E| be a vector representing all edges’ weights. Let wi = min{x[i], 1/2}. On the ith round,
we select a vector ri ∈ R|E| such that each component is drawn from the uniform distribution over
[−wi, wi]. We then deﬁne a new edge-weight vector xi such that xi[j] = x[j] + ri[j]. Our algorithm
returned the incorrect path on a 0.003 fraction of the 5000 · T = 150, 000 rounds.

In Figures 5e and 5f, we use the same procedure except wi = min{x[i], 1}. In that setting, our

algorithm returned the incorrect path on a 0.001 fraction of the 5000 · T = 150, 000 rounds.

17

(a) Gaussian perturbation with a standard devia-
tion of 1/2. Top line: average number of nodes
Dijkstra’s algorithm explores. Bottom line: aver-
age number of nodes Algorithm 1 explores.

(b) Gaussian perturbation with a standard devia-
tion of 1/2. Average pruned set size for shortest
path routing.

(c) Uniform perturbation with support [−1/2, 1/2].
Top line: average number of nodes Dijkstra’s algo-
rithm explores. Bottom line: average number of
nodes Algorithm 1 explores.

(d) Uniform perturbation with support [−1/2, 1/2].
Average pruned set size for shortest path routing.

(e) Uniform perturbation with support [−1, 1]. Top
line: average number of nodes Dijkstra’s algorithm
explores. Bottom line: average number of nodes
Algorithm 1 explores.

(f) Uniform perturbation with support [−1/2, 1/2].
Average pruned set size for shortest path routing.

Figure 5: Shortest path routing experiments using varying perturbation methods.

18

C.2 Linear programming

We use the CATS generator to create an initial instance with an objective function deﬁned by a
vector x and constraints deﬁned by a matrix A and a vector b. On the ith round, we select a
new objective vector xi such that each component xi[j] is drawn independently from the normal
distribution with a mean of x[j] and a standard deviation of 1. We run our algorithm for twenty
rounds (i.e., T = 30) with pi = 1√
i

for all i ∈ [T ].

Winner determination. Suppose there is a set {1, . . . , m} of items for sale and a set {1, . . . , n}
of buyers. In a combinatorial auction, each buyer i submits bids vi(b) for any number of bundles
b ⊆ {1, . . . , m}. The goal of the winner determination problem is to allocate the goods among the
bidders so as to maximize social welfare, which is the sum of the buyers’ values for the bundles
they are allocated. We can model this problem as a integer program by assigning a binary variable
xi,b for every buyer i and every bundle b they submit a bid vi(b) on. The variable xi,b is equal to 1
if and only if buyer i receives the bundle b. Let Bi be the set of all bundles b that buyer i submits
a bid on. An allocation is feasible if it allocates no item more than once ((cid:80)n
b∈Bi,j(cid:51)b xi,b ≤ 1
for all j ∈ {1, . . . , m}) and if each bidder receives at most one bundle ((cid:80)
xi,b ≤ 1 for all
i ∈ {1, . . . , n}). Therefore, the integer program is:

b∈Bi

(cid:80)

i=1

maximize (cid:80)n
(cid:80)n
s.t.
(cid:80)

i=1

i=1

(cid:80)
(cid:80)

vi(b)xi,b

b∈Bi
b∈Bi,j(cid:51)b xi,b ≤ 1 ∀j ∈ [m]
∀i ∈ [n]
xi,b ≤ 1
∀i ∈ [n], b ∈ Bi.

b∈Bi

xi,b ∈ {0, 1}

To transform this integer program into a linear program, we simply require that xi,b ∈ [0, 1] for

all i ∈ [n] and all b ∈ Bi.

19

