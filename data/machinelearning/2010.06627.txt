Video Game Level Repair via Mixed Integer Linear Programming

Hejia Zhang1*, Matthew C. Fontaine1*, Amy K. Hoover3,
Julian Togelius2, Bistra Dilkina1, Stefanos Nikolaidis1
1Viterbi School of Engineering, University of Southern California, {hejiazha,mfontain,dilkina,nikolaid}@usc.edu
2Tandon School of Engineering, New York University, julian@togelius.com
3Ying Wu College of Computing, New Jersey Institute of Technology, ahoover@njit.edu

0
2
0
2

t
c
O
3
1

]
I

A
.
s
c
[

1
v
7
2
6
6
0
.
0
1
0
2
:
v
i
X
r
a

Abstract

Recent advancements in procedural content generation via
machine learning enable the generation of video-game lev-
els that are aesthetically similar to human-authored examples.
However, the generated levels are often unplayable without
additional editing. We propose a “generate-then-repair” frame-
work for automatic generation of playable levels adhering to
speciﬁc styles. The framework constructs levels using a gener-
ative adversarial network (GAN) trained with human-authored
examples and repairs them using a mixed-integer linear pro-
gram (MIP) with playability constraints. A key component
of the framework is computing minimum cost edits between
the GAN generated level and the solution of the MIP solver,
which we cast as a minimum cost network ﬂow problem. Re-
sults show that the proposed framework generates a diverse
range of playable levels, that capture the spatial relationships
between objects exhibited in the human-authored levels.*

Introduction
We focus on the problem of automatically generating video
game levels that are aesthetically similar to human-authored
examples, while satisfying playability constraints. For exam-
ple, we would like to generate a variety of different Zelda
levels; on one hand, we require these levels to be playable;
they should include a character that the user can control, a
door to exit the level, and a key to open the door. At the same
time, the levels should have an aesthetic appeal; a level with
a character, a key, and a door next to each other is technically
playable, but does not have the appeal of a level created by a
human designer.

Addressing the research question of procedurally gener-
ating aesthetically appealing video game levels that satisfy
playability constraints is challenging. Using machine learn-
ing methods, level generators can be trained on existing levels
so as to learn to reproduce aspects of their style (Summerville
et al., 2018). In particular, recent advancements in generative
adversarial networks (GANs) enable the creation of levels
that are stylistically similar to human examples (Volz et al.,
2018; Giacomello, Lanzi, and Loiacono, 2018). At the same

*Denotes equal contribution.

Copyright © 2020, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

*Code of the experiments is available at: https://github.com/

icaros-usc/milp_constrained_gan

Figure 1: An overview of our framework for generating aes-
thetically pleasing, playable game levels by using a mixed-
integer linear program to repair GAN-generated levels.

time, many levels generated this way are not playable. Tor-
rado et al. (2020) demonstrated that GANs frequently fail to
encode playability criteria.

One approach to adhering to playability constraints is to
encode the search space of possible levels via constraint
programming (CP) (Smith, Whitehead, and Mateas, 2011) or
answer set programming (ASP) (Smith and Mateas, 2011)
and then use a search algorithm to ﬁnd a feasible solution.
It is not clear how to combine such methods with machine
learning to reproduce a given style.

Rather than encoding constraints in the level generation
process, we propose a generate-then-repair approach for ﬁrst
generating levels from models trained on human-authored
examples and then repairing them with minimum cost edits
to render them playable.
Our key insight is:

We can create playable levels that are aesthetically sim-
ilar to human-authored examples, by repairing GAN-
generated levels using a mixed-integer linear program
with encoded playability constraints.
Speciﬁcally, the framework ﬁrst generates levels using a
GAN trained with human-authored examples. The levels are
aesthetically similar to the training levels but may not be
playable. We then repair the levels using a mixed-integer
linear program with playability constraints, which minimizes
the number of edits required to render the level playable. A
key component of the framework is the edit distance metric,
which we cast as a minimum cost network ﬂow problem,

PlayabilityCriteriaGANMixed-Integer LinearProgram= 1= 1RandomNoise 
 
 
 
 
 
Human

GAN

GAN+MIP

MIP-random

Figure 2: Example generated Zelda levels of different techniques. The GAN+MIP framework repairs the GAN-generated levels
rendering them playable, while capturing the spatial relationships between tiles exhibited in the human-authored levels.

where we deﬁne a separate network for each object type in
the level and “ﬂows” represent changes between the GAN-
generated level and the level generated by the MIP solver.

Fig. 2 shows human-authored examples, as well as lev-
els generated by the GAN and the proposed framework
GAN+MIP, with 50 human-authored levels as training data.
We additionally include a baseline, MIP (random), where
instead of a GAN-generated level, we use as input to the MIP
solver a level generated by independently sampling an object
type for each tile. This results in levels that are playable, but
whose tiles do not exhibit the spatial relationships seen in the
human examples.

Our results show that we can generate a diverse range of
playable levels that have an aesthetic appeal from a small
number of human-authored examples.

A limitation of our approach is that aesthetic appeal is
subjective and we can only use proxy metrics, such as the
spatial relationship between tiles. However, we view this as
an exciting step towards procedurally generating aesthetically
pleasing levels that satisfy playability constraints.

Problem Description
We formulate the problem of procedural video game level
repair as a discrete optimization problem. We represent a
level as a space graph (Shaker, Togelius, and Nelson, 2016),
where each node in the graph is associated with a region
in the game and edges model connections between regions.
For instance, in The Legend of Zelda video game, the nodes
are grid cells representing an object, such as a wall, door or
empty space, and the edges connect adjacent cells.

We then formulate the procedural generation problem as a
matching problem, where each node is matched to an avail-
able object type. We note that the vast majority of random
matchings lead to unplayable levels. In Zelda, there is only
one player, who should reach a key and a door to exit the
level. Walls in the perimeter prevent the player from leaving
a conﬁned area. All such constraints need to be satisﬁed for
a level to be playable.

In addition to meeting criteria for playability, video game
levels need to be aesthetically pleasing. They must look in-
teresting or engaging to human players. Similarly to aesthet-
ically pleasing images, such considerations are not easily
formalized. Here, we formulate this problem as minimizing
the number of edits on levels that are sampled from a learned
distribution of human-authored training examples.

Domain
We use a simpliﬁed version of The Legend of Zelda video
game, implemented in the General Video Game Artiﬁcial In-
telligence (GVGAI) framework (Perez-Liebana et al., 2016;
Gaina et al., 2017; Perez-Liebana et al., 2019). Nintendo ﬁrst
introduced The Legend of Zelda in 1986 for the Nintendo En-
tertainment System (NES). The main character of the game,
Link, must explore dungeons and solve puzzles while simul-
taneously avoiding enemies within the level. In the GVGAI
version, Link must navigate the environment to obtain a key,
then proceed to the exit door while avoiding enemies.

Fig. 2 (top) shows example human-authored Zelda levels,
with Table 1 showing the different object types. Note that
all example human-authored levels are playable. In addition,

Wall Empty Key Exit door Enemy

Player

Table 1: The visualization for the tiles in Zelda.

Figure 3: DCGAN network for learning the distribution of
Zelda game levels.

we observe that the key is typically placed far away from the
door, requiring the player to navigate the level, encounter-
ing enemies in the way. This is an aesthetic quality that is
not a playability constraint, but we wish to replicate in the
procedurally generated levels.

Approach

Our framework implements a generate-then-repair approach.
For constructing levels adhering to an existing style, we train
a generative adversarial network (GAN) using a small num-
ber of human-authored examples. The generator network of
the GAN samples new levels using random noise as input.
The framework passes the GAN-generated level into the ob-
jective function of a mixed-integer linear program (MIP) that
encodes domain-speciﬁc playability constraints. The MIP
acts as an editor, minimizing the number of corrections re-
quired to transform the GAN generated level into a playable
level. This way, we combine the GAN’s capability to retain
the aesthetics of human-authored examples with the MIP’s
capability to guarantee formal constraints like those ensuring
playability.

Deep Convolutional GAN

We use a Deep Convolutional GAN (DCGAN) with an iden-
tical architecture to the DCGAN from Volz et al. (2018)
(Fig. 3), trained with the WGAN algorithm (Martin Arjovsky
and Bottou, 2017). This model, trained with WGAN, was
shown to successfully generate a variety of levels for Super
Mario Bros.

Mixed Integer Linear Program Formulation

To model reachability as a MIP, let G(V, E) be the space
graph, where V is a list of nodes and E is a list of edges. We
assume a set of O distinct object types. For each object type
o, we deﬁne a vector of binary variables, o ∈ {0, 1}|V |, with
each element ov indicating whether object type o occupies
vertex v. For example, in The Legend of Zelda there are eight
object types: wall w, empty space m, key k, door d, player p
and three types of enemies e1, e2, e3.
Node Uniqueness Constraint. We require that each node

contains exactly one type of object:
wv + mv + kv + dv + e1

v + e2

v + e3

v + pv = 1, ∀v ∈ V

(1)

Reachability Constraints. Playable levels need to satisfy
reachability constraints. For instance, the player needs to be
able to reach the key object. We cast the reachability problem
as a ﬂow problem (Goldberg and Tarjan, 2014). For each
edge (u, v) ∈ E we deﬁne a non-negative integer variable
f (u, v) ∈ Z≥0 representing ﬂow from u to v. We deﬁne a
target set T ∈ O of object types that need to be reachable
by a source set S ∈ O. In Zelda, the door and key need to
be reachable by the player, i.e., T = {k, d} and S = {p}.
Then, we introduce f s
v ∈ Z≥0 variables as supplies and
f t
v ∈ {0, 1} as demands for each node. We show the network
ﬂow equations below, where the equations apply for all nodes
v ∈ V :

|V | · xv

(cid:88)

f s
v ≤

x∈S
xv = f t
v

(cid:88)

f s
v +

(cid:88)

x∈T
f (u, v) = f t

v +

(cid:88)

f (v, u)

u:(v,u)∈E

u:(u,v)∈E
(cid:88)

f (u, v) +

|V | · xv ≤ |V | , ∀u : (u, v) ∈ E

xv∈B

f (u, v), f s
v ∈ Z≥0
f t
v ∈ {0, 1}

(2)

(3)

(4)

(5)

(6)

(7)

Eq. 2 limits supply ﬂow to vertices that have an object in
the source set S. For instance, in The Legend of Zelda we
let a node v be connected to the source when v contains the
player p. Based on Eq. 1, pv will be 1 and all the other object
type variables (e.g., wv, mv) will be 0. Since p ∈ S, the sum
in the right hand side is equal to |V | and f s
v for that node can
take values between 0 and |V |. On the other hand, if a node
is associated with a tile that contains a non-source node, e.g.,
a wall, pv for that node will be 0, forcing the sum on the right
side of Eq. 2 to be 0 and f s

v will be exactly 0.

Following a similar reasoning, Eq. 3 guarantees that node
v will generate a unit of demand if it belongs to the target set
T . Eq. 4 speciﬁes the ﬂow conservation constraints, which
propagate the demands from the target nodes back to the
source nodes. The constraints guarantee that all target nodes
will be reached by at least one source node. Finally, in Eq. 5
to ensure that no paths cross impassable objects (e.g., walls,
door), we deﬁne a set of impassable object types B and we
block ﬂow leaving nodes assigned to these object types.
Edit Distance Objective. Our goal is to minimize the num-
ber of edits, that is moving, adding or removing an object
type, that the MIP solver applies to the input level to make it
satisfy the playability constraints. We cast this problem as a
minimum cost network ﬂow problem, where we generate a
network for every object type. The key intuition is that if a
node contains an object in the input level, it is a source node
that supplies ﬂow; the supplied ﬂow can be absorbed either
by a node with an object of the same type in the MIP solution,

321RandomNoiseInput25641288641683283264161288256411which generates a unit of demand, or by a “waste” variable
that indicates deletion of an object in the original input level.
The objective is to minimize the cost of the ﬂow that satisﬁes
supplies and demands.

Similarly to the reachability constraints network, we spec-
ify demand variables f t
v ∈ {0, 1} for each node and ﬂow
variables f (u, v) for the edges. We additionally deﬁne waste
variables rt

v ∈ Z≥0.

We let cv be a constant that is equal to 1 if a node v
contained the object type of the network in the input (GAN-
generated) level and 0 otherwise. Eq. 8 speciﬁes the ﬂow
conservation constraints, while Eq. 9 limits demands to lo-
cations containing the object type o that the ﬂow network is
associated with. The equations apply for all nodes v ∈ V .
Eq. 10 ensures that supplies from initial object locations
match demands by the new object locations or by object
deletions.

Eq. 11 describes the MIP objective to minimize the sum
of the costs for the ﬂow network of each object type. The
ﬁnal objective value is computed by summing over all object
types (Eq. 11). rt
v and f (u, v) are different for each object
type since they represent ﬂows in different networks. Cd rep-
resents the cost for deleting an object and Cm represents the
cost for moving an object one tile. Note that we do not model
the cost for adding an object as an object must be deleted
for an addition to occur. In our experiments, we selected
Cd = 10 and Cm = 1, so that it is much cheaper to move an
object one cell than deleting it.

(cid:88)

cv +

u:(u,v)∈E

f (u, v) = rt

v + f t

v +

(cid:88)

f (v, u)

(8)

u:(v,u)∈E

f t
v ≤ ov
cv =

(cid:88)

v∈V

(cid:88)

v∈V

f t
v +

(cid:88)

v∈V

rt
v

(9)

(10)

(cid:88)





(cid:88)

Cdrt

v +

(cid:88)

Cmf (u, v)

 (minimize)



o∈O

v∈V

u,v:(u,v)∈E

(11)
Domain-speciﬁc Constraints. The above constraints and
edit distance objective can generalize across a variety of
platform games, such as The Legend of Zelda and Pac-Man.
However, each game has additional game-speciﬁc constraints,
which can be easily encoded in the MIP formulation. The
Legend of Zelda requires that exactly one key, one door, and
one player are present in the level, enemies cover less than
60% of the available space to ensure the level is not too difﬁ-
cult for the player, and the outer perimeter of the level needs
to be ﬁlled with wall objects. We include these additional
constraints in the MIP formulation.

Empirical Evaluation
To evaluate our method we train the GAN on a corpus of 50
human authored levels from Zelda for 24,000 epochs. We
then generate 1000 levels using the GAN+MIP framework
by sampling through Gaussian noise on the generator net-
work and compare against three baselines: levels generated

Figure 4: The distribution of the average hamming (left) and
edit (right) distance between levels from the same set.

by GAN without the MIP editing and levels generated by the
MIP solver by minimizing the edit distance to a randomly gen-
erated level and performance results from a recent study (Tor-
rado et al., 2020), which uses an adapted self-attention GAN,
named CESAGAN. For the randomly generated levels, we
sample an object for each tile from a multinomial distri-
bution, where the probabilities match the object frequency
counts in the human authored levels. CESAGAN captures
non-local dependency between game objects. It was trained
on 45 out of the same 50 human-authored levels as the pro-
posed GAN+MIP framework. Note that CESAGAN tries to
learn level constraints through bootstrapping and does not
require explicitly encoded constraints.
Diversity of Playable Levels. We evaluate the generated lev-
els by testing the playability criteria speciﬁed in Torrado et al.
(2020). Levels are also measured for duplicates by counting
the number of unique levels produced by the generator and re-
porting the percentage of additional levels that are duplicates
of the unique levels. Table 2 shows our results.

Results show that most of the GAN-generated levels are
not playable, while the proposed framework generates a large
number of unique levels that are all playable, since they sat-
isfy the constraints encoded in the MIP. Moreover, we notice
that from the duplicate levels generated by the proposed
framework, 77% were generated directly from the GAN. For
the remaining duplicate repair levels, each level was stylisti-
cally similar; for instance, two distinct levels had a missing
boundary tile in different locations, but they were repaired
to be identical by ﬁlling each missing boundary. On average
it took the MIP solver (IBM, 2019) 0.13 seconds to ﬁx gen-
erated levels, where each MIP program consisted of 6858
variables and 2777 constraints.

We further analyze the diversity of the generated levels
by using the average Hamming distance metric (Torrado
et al., 2020) (number of different tiles) between each gen-
erated level with all other playable levels, as well as the
proposed edit distance metric. We randomly selected 243
playable levels out of the 1000 generated ones for the pro-
posed framework, in order to match the number of playable
levels generated by the GAN. Fig. 4 shows that, while the
human-authored levels have higher diversity, the proposed
framework generates levels that are more diverse than the
GAN levels. GAN learns to generate levels from the distri-
bution of human examples, but the generated playable levels
are only a small part of the learned distribution. On the other
hand, GAN+MIP repairs all GAN-generated levels, capturing

2040Average Hamming Distance0.000.20Count200300Average Edit Distance0.000.04CountHumanGANGAN+MIPModel

Playable levels Duplicated levels

Playable and unique levels

GAN
MIP (random)
CESAGAN (Torrado et al., 2020)
GAN + MIP

24.3%
100%
58%
100%

46.9%
0%
37.6%
14.9%

12.9%
100%
not reported
85.1%

Table 2: Percentage of generated playable and unique levels with each technique.

(a)

(b)

(c)

(d)

Figure 5: (a-c) Distribution of different game tiles for the human examples, the levels generated by the GAN and the levels
generated by the GAN and edited with the MIP solver. (d) Distribution of minimum paths from key to door.

a larger part of the training distribution.

We note that the levels generated by MIP-random were all
unique and had higher diversity metrics (not shown in the
ﬁgures), because of the stochastic nature of the random level
generation process.
Aesthetic Appeal of Generated Levels. We assess whether
the generated levels are aesthetically similar to the human-
authored ones. Following previous work (Torrado et al.,
2020), we compute the distribution of different game tiles for
the human, the GAN and the GAN+MIP levels (Fig. 5a-5c).
We observe that the GAN+MIP matches closer the human dis-
tribution, since GAN+MIP repairs all GAN-generated levels,
capturing a larger part of the training distribution.†

We also compute the tile-pattern Kullback–Leibler (KL)
divergence (Lucas and Volz, 2019) between the distribution
of the tile patterns of the generated levels and the human-
authored levels. We ﬁrst extract a set of tile patterns by sliding
a 2x2 ﬁxed-size window over each level. We then empirically
estimate the probability of each pattern for each set of lev-
els and then compute the KL divergence between the two
distributions.

The value of the 243 GAN playable levels is 0.272. We
randomly selected 243 playable levels from the GAN+MIP
set, to match the number of the GAN levels. The value was
0.108, indicating higher similarity to the human examples.
Comparison with MIP (random). Since the MIP (random)
baseline generates unique, playable levels that follow the tile
distribution of the human-authored levels, what is the beneﬁt
of using a generative adversarial network?

GANs learn spatial relationships between objects in the
level. Speciﬁcally, inspection of the human-authored levels

†We exclude the baseline MIP (random) from the analysis, since
the objects in the input levels are sampled by the tile distribution
of the human-authored levels, therefore the levels follow closely,
albeit not exactly because of the editing, the human distribution.

Figure 6: Edit distance example. (Left) An unplayable gener-
ated level by the GAN network. (Center) The output of the
MIP solver that minimizes the Hamming distance to the input
level. (Right) The output of the MIP solver that minimizes
the edit distance.

in Fig. 2 shows that human designers tend to place the key far
away from the door, so that the player needs to explore the
level before exiting it. This aesthetic quality is lost in many
of the random generated levels.

We support this argument in Fig. 5d, which shows the
distribution of the length of the minimum paths, computed
with a standard A* algorithm (Russell and Norvig, 2002),
from the key to the door. We observe that the distribution is
shifted towards larger paths for the GAN+MIP levels, com-
pared to the MIP (random) levels. The average length of the
minimum path was 8.6 for GAN+MIP, compared to 7.8 for
MIP (random) and 12.5 for the human.

Edit Distance Objective
A simpler optimization objective for the MIP program would
be the Hamming distance (number of different tiles) rather
than the edit distance between the input and the generated
level. However, this metric does not capture the spatial rela-
tionships between tiles. For instance, in Fig. 6 minimizing
the Hamming distance results in replacing the enemy on the
left hand side with the wall. In the edit distance metric of
Eq. 11, the cost of deleting an enemy (Cd = 10) is larger

4070# Empty Tiles0.00.2CountGANHumanGAN+MIP4070# Walls0.00.3Count08# Enemies0.00.7Count040Minimum Path0.000.12CountHumanMIP(random)GAN+MIPleft side of the screen to enter the right. We modify the space
graph to have additional edges between the left column’s
nodes and the right column’s nodes. Similarly, we add edges
between the top row’s nodes and the bottom row’s nodes. Pac-
Man levels are required to have no dead ends. To model this
in the MIP, we require that all free space objects are adjacent
to at least two neighbors (in graph theory terms: the node is
not a leaf). Fig. 7 (left) shows an example level generated
by the DCGAN, trained over 45 human-edited examples.
The level has dead-ends and the wraparound on the edges
of the screen is incorrect. Fig. 7 (right) shows the repaired
level by a MIP program that minimizes the edit distance
to the previous level while satisfying the no-deadend and
wraparound constraints, in addition to requiring the player
to be able to reach all pellets and enemies in the level. We
note that the MIP solver (IBM, 2019) took 3.22 seconds on
average to ﬁx the generated levels. The repairs took longer
than the Zelda domain as the Pac-Man domain has more
constraints and a larger space graph. Each MIP program for
Pac-Man consisted of 65352 variables and 26252 constraints,
compared to 6858 variables and 2777 constraints for Zelda.

Generality and Limitations
In terms of expressive power, any satisﬁability (SAT) pro-
gram can be modelled as a MIP. However, not all constraint
programs (CP) can be modelled as a mixed integer linear pro-
gram due to the linearity requirements. What MIPs lack in
generality they make up in performance of the solver. Modern
MIP solvers can solve programs with millions of variables
and constraints, in general orders of magnitude larger than
general CP solvers. Moreover, problems like ﬂow have good
LP relaxations, allowing for the subprogram to be solved in
polynomial time.

While further research is needed in this direction, we argue
that many of the PCG methods currently being modelled as
CP can be modelled as MIPs, allowing for larger levels to
be solved by more efﬁcient solvers. For example, in Zelda
we may want to generate levels with two doors, where the
player must not be able to reach the second door without
passing through the ﬁrst door. The problem can be modelled
as an (s, t)-cut problem, which (like ﬂow) can be modelled
as a linear program. Our goal is to require a 0 cost cut be-
tween the player and second door. We link the player to the
source vertex and the second door to the sink vertex. Vari-
ables d(u, v) ∈ Z≥0 represent a decision variable marking
whether edge (u, v) should be in the cut. Then we add con-
straints that enforce d(u, v) to be zero for edges leaving free
space nodes forcing the cut to only cut edges leaving blocking
nodes (i.e. the walls or door one).

More complex reachability constraints can also be mod-
elled. Horswill and Foged (2012) demonstrated a constraint
programming method for modeling path constraints between
ﬁxed points in a level. The CP required that a player could
reach enough resources (e.g. ammo, armor) to complete the
level. To model this constraint as a MIP we could model
the reachability as ﬂow with costs rather than ﬂow, where
costs represent obtaining resources. Then we require that the
cost of the path from source to sink is constrained within a
speciﬁc range. Finally, aesthetic constraints like symmetry

Figure 7: GAN-generated Pac-Man level (left) and the same
level repaired by the MIP solver (right).

than the cost of moving it (Cm = 1), therefore the solver
chooses to move the enemy and a neighboring wall tile so that
they exchange positions. This preserves the level topology
by retaining the third enemy.

End-to-End Training
We explore integrating playability constraints as an additional
layer in the GAN network. Recent advances in differential
optimization (Wilder, Dilkina, and Tambe, 2019; Ferber et al.,
2019) have allowed integrating discrete optimization prob-
lems into deep learning models trained with gradient descent.
We include a differentiable MIP program (Ferber et al., 2019)
as an additional layer in the GAN network and train the GAN-
MIP in an end-to-end manner by passing to the discriminator
the levels generated by the generator after they are repaired
by the MIP solver.

Training the network with all playability constraints is
computationally expensive. On the other hand, we observed
that the main reason that GAN-generated levels are rendered
unplayable is the violation of numerical constraints, such as
number of players, doors and keys, which matches results
from previous work (Torrado et al., 2020). For computational
efﬁciency, we encoded only these constraints in the MIP
program, used the simpler Hamming distance objective and
applied LP-relaxation (Wilder, Dilkina, and Tambe, 2019),
which signiﬁcantly sped up the training process.

We trained the resulting network for 5000 epochs, which
lasted 55 hours on an Intel Core i7-8700K 3.7GHz processor.
The generator network generated 747 unique and playable
game levels out of 1000, which is a signiﬁcant improvement
to the initial GAN model. The average length of the minimum
path from the key to the door was 10.1, and the KL divergence
between the tile distribution of the generated levels and the
human-authored levels was 0.055. These preliminary results
indicate the promise of integrating MIP constraints in the
GAN training process.

Beyond Zelda Levels
The proposed framework applies also to other domains, such
as Pac-Man game levels. Modeling playability constraints in
Pac-Man required small modiﬁcations to the Zelda MIP. First,
the dynamics of Pac-Man allow for the character to leave the

can be modelled by adding constraints for each pair of nodes
on opposite sides of a level requiring each object assignment
variable ov equal it’s counterpart across the line of symmetry.
While MIPs can be used as powerful modeling tools, ap-
plying these techniques to level repair requires expertise in
MIP modeling. Common problems, such as reachability, can
be modelled from their graph-based representation and con-
verted to MIP constraints within our framework to ease the
burden of designers. Further research is needed to model
games with complex physics for character movement. Ex-
amples include platformer games like Mario and Sonic the
Hedgehog. For these games heuristic modeling, such as re-
quiring two platforms are close enough for the character to
jump between platforms, is needed.

Related Work
Volz et al. (2018) and Giacomello, Lanzi, and Loiacono
(2018) presented the ﬁrst works applying GANs to the prob-
lem of automatic video game level generation. To assure that
generated levels satisfy speciﬁc criteria, Volz et al. (2018)
adapted latent variable evolution (LVE) from Bontrager et al.
(2018) to search the generative space induced by the genera-
tor network with CMA-ES (Hansen and Ostermeier, 2001;
Hansen, 2016). Giacomello, Lanzi, and Loiacono (2018) as-
sured that levels met necessary criteria through generate-
and-test methodology. Later work by Torrado et al. (2020)
showed that GANs can fail to capture logical constraints of
the video game levels and invented a bootstrapping method
that incorporates generated playable levels back into a con-
tinually expanding training data set. Snodgrass and Ontanón
(2017) introduced a markov chain method for guaranteeing
aspects of the layout in Mario. A generate-and-test method
guaranteed reachability constraints by running A* agents on
generated levels. As an alternative to GANs, WaveFunction-
Collapse (Karth and Smith, 2017) generates levels that match
example data by compiling the data into constraints that can
be used to generate levels of similar visual style. However,
note that such approaches cannot model complex playability
constraints speciﬁed by a user.

Several authors present machine learning approaches to sat-
isfying level constraints. However, these approaches make no
guarantees about successfully generating or repairing levels
to satisfy all constraints. Karth and Smith (2019) proposed us-
ing discriminator networks, trained on positive and negative
examples, to guide WaveFunctionCollapse towards playable
levels. Jain et al. (2016) proposed using autoencoders as a re-
pair method for broken levels by passing broken components
through an autoencoder trained on valid levels. However,
each of these approaches assumes that the deep learning
model can capture complex logical constraints, which often
require specialized models (Wang et al., 2019).

As an alternative to procedural content generation via
machine learning (PCGML), there exist several methods
for declarative modeling of procedurally generated content.
Smith and Mateas (2011) presented a declarative method of
PCG allowing the generative space of possible levels to be
encoded as an answer set program. Smith, Whitehead, and
Mateas (2011) presented an interactive constraint program-
ming method for allowing humans to coauthor Mario levels

with the generative method. Horswill and Foged (2012) pre-
sented a constraint programming method for modeling path
constraints between two ﬁxed points in a space graph. Their
method modelled paths as a system of linear equations, which
we note is equivalent to ﬂow conservation constraints used in
our method (linear programming is a generalization of linear
systems of equations). Our method can therefore be thought
of as a generalization of their approach that allows for end-
points of the path to be placed dynamically and can model
reachability across a set of object types. Constraints can also
be encoded in a multi-objective evolutionary algorithm, ei-
ther as part of the objective function, or separately, e.g., by
dividing a population of solutions into feasible and infeasible
individuals (Kimbrough et al., 2008; Sorenson and Pasquier,
2010). The two-population constraint handling approach can
also be used together with quality diversity algorithms (Li-
apis, Yannakakis, and Togelius, 2015; Khalifa et al., 2018) to
generate a diverse range of levels.

Our work beneﬁts from recent advancements combining
machine learning with traditional optimization methods. Re-
cent works have introduced quadratic programming (Amos
and Kolter, 2017), linear programming (Wilder, Dilkina, and
Tambe, 2019), and satisﬁability (Wang et al., 2019) solvers as
layers of deep neural networks. Related methods incorporate
submodular optimization (Wilder, Dilkina, and Tambe, 2019)
as a layer in a neural network.

Conclusions
Limitations. Our work is limited in many ways. Ensuring
reachability constraints requires the agent dynamics be mod-
eled as a ﬁnite graph, with vertices representing discrete
regions in the level and edges indicating neighboring ver-
tices. Levels that satisfy playability constraints may still be
unplayable in practice, for instance if difﬁculty is too high.
Additionally, the objective metrics for aesthetic similarity to
human examples are only approximate metrics. Evaluating
playability and aesthetic appeal with user studies is a natural
extension of this work.
Implications. We have presented a generate-then-repair
framework for constructing levels using models trained over
human-authored examples and repairing the levels with a
mixed-integer linear program. Our editing method is agnostic
to how levels are generated; we are excited to explore the
limits of our approach by repairing different types of proce-
durally generated content (levels, objects, enemies) that need
to satisfy explicitly deﬁned constraints.

Acknowledgements
The authors would like to thank Per Josefsen and Nicola
Zaltron, who authored the 45 human-designed Zelda lev-
els, and Ahmed Khalifa for his helpful comments about the
CESAGAN approach.

References
Amos, B., and Kolter, J. Z. 2017. Optnet: Differentiable opti-
mization as a layer in neural networks. In Proceedings of the
34th International Conference on Machine Learning-Volume 70,
136–145. JMLR. org.

Perez-Liebana, D.; Liu, J.; Khalifa, A.; Gaina, R. D.; Togelius, J.;
and Lucas, S. M. 2019. General video game ai: A multitrack
framework for evaluating agents, games, and content generation
algorithms. IEEE Transactions on Games 11(3):195–214.

Russell, S., and Norvig, P. 2002. Artiﬁcial intelligence: a modern

approach.

Shaker, N.; Togelius, J.; and Nelson, M. J. 2016. Procedural Content
Generation in Games: A Textbook and an Overview of Current
Research. Springer.

Smith, A. M., and Mateas, M. 2011. Answer set programming for
procedural content generation: A design space approach. IEEE
Transactions on Computational Intelligence and AI in Games
3(3):187–200.

Smith, G.; Whitehead, J.; and Mateas, M. 2011. Tanagra: Reac-
tive planning and constraint solving for mixed-initiative level
design. IEEE Transactions on computational intelligence and AI
in games 3(3):201–215.

Snodgrass, S., and Ontanón, S. 2017. Player movement models
In Proceedings of the
for platformer game level generation.
26th International Joint Conference on Artiﬁcial Intelligence,
757–763. AAAI Press.

Sorenson, N., and Pasquier, P. 2010. Towards a generic framework
for automated video game level creation. In European confer-
ence on the applications of evolutionary computation, 131–140.
Springer.

Summerville, A.; Snodgrass, S.; Guzdial, M.; Holmgård, C.; Hoover,
A. K.; Isaksen, A.; Nealen, A.; and Togelius, J. 2018. Proce-
dural content generation via machine learning (pcgml). IEEE
Transactions on Games 10(3):257–270.

Torrado, R. R.; Khalifa, A.; Green, M. C.; Justesen, N.; Risi, S.;
and Togelius, J. 2020. Bootstrapping conditional gans for video
game level generation. In IEEE Conference on Games.

Volz, V.; Schrum, J.; Liu, J.; Lucas, S. M.; Smith, A.; and Risi,
S. 2018. Evolving mario levels in the latent space of a deep
convolutional generative adversarial network. In Proceedings
of the Genetic and Evolutionary Computation Conference, 221–
228.

Wang, P.-W.; Donti, P. L.; Wilder, B.; and Kolter, Z. 2019. Satnet:
Bridging deep learning and logical reasoning using a differen-
tiable satisﬁability solver.

Wilder, B.; Dilkina, B.; and Tambe, M. 2019. Melding the data-
decisions pipeline: Decision-focused learning for combinatorial
optimization. In Proceedings of the AAAI Conference on Artiﬁcial
Intelligence, volume 33, 1658–1665.

Bontrager, P.; Roy, A.; Togelius, J.; Memon, N.; and Ross, A. 2018.
Deepmasterprints: Generating masterprints for dictionary attacks
via latent variable evolution. In 2018 IEEE 9th International Con-
ference on Biometrics Theory, Applications and Systems (BTAS),
1–9. IEEE.

Ferber, A.; Wilder, B.; Dilina, B.; and Tambe, M. 2019. Mi-
arXiv preprint

paal: Mixed integer program as a layer.
arXiv:1907.05912.

Gaina, R. D.; Couëtoux, A.; Soemers, D. J.; Winands, M. H.;
Vodopivec, T.; Kirchgeßner, F.; Liu, J.; Lucas, S. M.; and Perez-
Liebana, D. 2017. The 2016 two-player gvgai competition. IEEE
Transactions on Games 10(2):209–220.

Giacomello, E.; Lanzi, P. L.; and Loiacono, D. 2018. Doom
level generation using generative adversarial networks. In 2018
IEEE Games, Entertainment, Media Conference (GEM), 316–
323. IEEE.

Goldberg, A. V., and Tarjan, R. E. 2014. Efﬁcient maximum ﬂow

algorithms. Communications of the ACM 57(8):82–89.

Hansen, N., and Ostermeier, A. 2001. Completely derandomized
self-adaptation in evolution strategies. Evolutionary computation
9(2):159–195.

Hansen, N. 2016. The cma evolution strategy: A tutorial. arXiv

preprint arXiv:1604.00772.

Horswill, I. D., and Foged, L. 2012. Fast procedural level population
with playability constraints. In Eighth Artiﬁcial Intelligence and
Interactive Digital Entertainment Conference.

IBM. 2019. Ibm ilog cplex optimization studio v12.10.0.

Jain, R.; Isaksen, A.; Holmgård, C.; and Togelius, J. 2016. Autoen-
coders for level generation, repair, and recognition. In Proceed-
ings of the ICCC Workshop on Computational Creativity and
Games.

Karth, I., and Smith, A. M. 2017. Wavefunctioncollapse is constraint
solving in the wild. In Proceedings of the 12th International
Conference on the Foundations of Digital Games, 1–10.

Karth, I., and Smith, A. M. 2019. Addressing the fundamental
tension of pcgml with discriminative learning. In Proceedings of
the 14th International Conference on the Foundations of Digital
Games, 1–9.

Khalifa, A.; Lee, S.; Nealen, A.; and Togelius, J. 2018. Talakat:
Bullet hell generation through constrained map-elites. In Proceed-
ings of The Genetic and Evolutionary Computation Conference,
1047–1054.

Kimbrough, S. O.; Koehler, G. J.; Lu, M.; and Wood, D. H. 2008. On
a feasible–infeasible two-population (ﬁ-2pop) genetic algorithm
for constrained optimization: Distance tracing and no free lunch.
European Journal of Operational Research 190(2):310–327.
Liapis, A.; Yannakakis, G. N.; and Togelius, J. 2015. Constrained
novelty search: A study on game content generation. Evolution-
ary computation 23(1):101–129.

Lucas, S. M., and Volz, V. 2019. Tile pattern kl-divergence for
analysing and evolving game levels. In Proceedings of the Ge-
netic and Evolutionary Computation Conference, 170–178.
Martin Arjovsky, S., and Bottou, L. 2017. Wasserstein generative
adversarial networks. In Proceedings of the 34 th International
Conference on Machine Learning, Sydney, Australia.

Perez-Liebana, D.; Samothrakis, S.; Togelius, J.; Schaul, T.; and Lu-
cas, S. M. 2016. General video game ai: Competition, challenges
and opportunities. In Thirtieth AAAI Conference on Artiﬁcial
Intelligence.

