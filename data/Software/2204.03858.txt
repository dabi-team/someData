2
2
0
2

r
p
A
8

]
E
S
.
s
c
[

1
v
8
5
8
3
0
.
4
0
2
2
:
v
i
X
r
a

eGEN: An Energy-saving Modeling Language and Code Generator for
Location-sensing of Mobile Apps

KOWNDINYA BOYALAKUNTLA, Indian Institute of Technology Tirupati, India
MARIMUTHU C, National Institute of Technology Karnataka, India
SRIDHAR CHIMALAKONDA, Indian Institute of Technology Tirupati, India
K. CHANDRASEKARAN, National Institute of Technology Karnataka, India

The demand for reducing the energy consumption of location-based applications has increased in recent years. The

abnormal battery-draining behavior of GPS makes it difficult for the developers to decide on battery optimization

during the development phase directly. It will reduce the burden on developers if battery-saving strategies are

considered early, and relevant battery-aware code is generated from the design phase artifacts. Therefore, we aim to

develop tool support, eGEN, to specify and create native location-based mobile apps. eGEN consists of Domain-specific

Modeling Language (DSML) and a code generator for location-sensing. It is developed using Xtext and Xtend as an

Eclipse plug-in, and currently, it supports native Android apps. eGEN is evaluated through controlled experiments by

instrumenting the generated code in five location-based open-source Android applications. The experimental results

show 4.35 minutes of average GPS reduction per hour and 188 mA of average reduction in battery consumption

while showing only 97 meters degrade in location accuracy over 3 kilometers of a cycling path. Hence, we believe

that code generated by eGEN would help developers to balance between energy and accuracy requirements of
location-based applications. The source code, documentation, tool demo video1, and tool installation video2are
available at https://github.com/Kowndinya2000/egen.

Keywords: domain-specific language, code generator, energy-saving location-sensing, modeling adaptive strategies,

mobile apps

1 INTRODUCTION

In recent years, software energy consumption is becoming a critical non-functional requirement for software

developers [11, 32, 44]. The investigations by Pinto and Castor [49], and Manotas et al. [35] highlight the

significance of reducing software energy consumption. Especially in the mobile application domain, reducing

the abnormal energy consumption is a concern for both users and developers. Cruz and Abreu [12] have

performed an empirical evaluation on six popular android applications namely Loop - Habit Tracker, GnuCash

and so on to find performance-related code smells that cause heavy battery depletion. They reported that

smartphoneâ€™s battery life can be extended upto an hour, if apps are developed by implementing energy-aware

practices. This motivates the need for further research towards making energy efficient mobile applications.

Research efforts were initially focused on energy measurement [19], energy profiling [23], and energy bugs

identification [33, 45]. Of late, the focus has been shifted to energy-saving solutions [37, 54], and automated

repairing of energy bugs [1, 13, 38]. Recently, the research community has provided several frameworks

1https://youtu.be/J-ZmzEBpC8Y
2Part1 of installation at https://youtu.be/wyDfAoAlP-c and part2 of installation at https://youtu.be/o65Fu-xlByI

Authorsâ€™ addresses: Kowndinya Boyalakuntla, Indian Institute of Technology Tirupati, Settipalli Post, Tirupati â€“ 517
506, India, cs17b032@iittp.ac.in; Marimuthu C, National Institute of Technology Karnataka, Surathkal, Mangalore, India,
cs15fv08.muthu@nitk.edu.in; Sridhar Chimalakonda, Indian Institute of Technology Tirupati, Settipalli Post, Tirupati â€“ 517
506, India, ch@iittp.ac.in; K. Chandrasekaran, National Institute of Technology Karnataka, Surathkal, Mangalore - 575 025,
India, kchnitk@ieee.org.

Manuscript submitted to ACM

1

 
 
 
 
 
 
2

Kowndinya and Marimuthu, et al.

[7, 32, 48] to reduce energy consumption of Android apps. Notably, the research work by Georgiou et al.

[18] highlights the list of techniques and tools to adopt in the software development life cycle to improve

energy efficiency.

The energy bugs are induced in the mobile domain by the usage of energy-hungry components such

as GPS, GPU, camera, gyroscope, and other smartphone sensors [46]. Notably, the energy consumed by

location-based apps may drain the mobile battery quickly if GPS is not appropriately handled by the

deveopers[6]. Huang et al. [24] discussed about the transformative evolution of location based services in

mobile applications ranging from navigation, health care and social networking to assistive technologies and

disaster management.

The ubiquitous presence of location-based apps makes the creation of GPS efficient patterns even more

challenging[8, 16]. To ease out developersâ€™ challenges in reducing GPS consumption, a potential strategy

is to consider energy-saving decisions during the design phase of software development. In addition, it is

important to enable provision for developers to consider energy-saving decisions independent of the location

sensing libraries and code patterns.

The existing approaches primarily consider energy-saving solutions at source code level [12, 14, 50, 51].

However, they do not consider energy-saving strategies during early stages of software development such as

design, which might help developers handle energy-related problems. Hence, an appropriate tool support

to consider energy-saving solutions at design time could help developers handle energy-related problems

more clearly. In addition, automatically generating suitable battery-aware code from design phase artifacts

might increase the developerâ€™s productivity. To the best of our knowledge, tool support for considering

energy bugs related to location-based apps at the design phase is not widely investigated in the literature.

Therefore, in this paper, we aim at investigating the possibility of having tool support for reducing the

battery consumption of location-based smartphone applications. Therefore, we aim to develop a tool, eGEN,

that consists of DSML and code generator for location-based Android applications. The contributions of

this paper are three-fold:

(1) A Textual Domain-specific Modeling Language (DSML) for creating battery-aware and self-adaptive

energy-saving location sensing-strategies.

(2) A code generator to generate the native battery-aware Java code from self-adaptive energy-saving

location sensing-strategies.

(3) Controlled experiment based evaluation of the eGEN generated code on five open-source location-based

Android applications, where eGENâ€™s adaptive code produced a savings of 188mA in battery and 4.35

minute reduction in GPS usage per hour at the expense of 97 meters degrade in accuracy over a

distance of 3060 meters. We have done evaluation through eGEN and non-eGEN versions.

eGEN is designed to consider the impact of different context information such as battery charging state,

battery level, foreground or background app execution, and sensing-interval on energy-saving. Further, the

code generator of eGEN generates the Java code that could be added to the existing Android repositories

to make them battery-aware. eGEN is developed using Xtext and Xtend as an Eclipse plugin. The Xtext

is used to define the language elements, and Xtend is used to define the code generator. eGEN currently

supports the Android platform and covers the battery manager API, fused location provider client, and

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 3

Android activity life cycle. In future, we aim to support the iOS platform as well. The source code of eGEN
is available on GitHub 3 as an open-source repository for others to use.

The efficacy of eGEN has been evaluated through controlled experiments. We have selected five open-

source Android applications that primarily use the location for its operation. We have used DSML of eGEN

to specify self-adaptive location-sensing for all subject applications. The code generated using eGEN has

been instrumented to the subject application to check the improvements in energy-saving.

The controlled experiments were conducted on eGEN and non-eGEN versions of the subject applications.

The Google Battery Historian was used to estimate the GPS active time and battery consumption.

The experiment results show that eGEN provides the ability to specify self-adaptive location-sensing

strategies. In addition, the code generator can generate Java code that can be instrumented to the existing

apps without affecting its existing functionalities. The subject applications were instrumented using the
generated code and executed on Nokia C34 smartphone running on Android 10 platform. Overall, the eGEN
version of the subject application shows reduction of 4.35 minutes in GPS active time and 188 mA in battery

consumption. As observed from the results, eGEN generated code show reduced battery usage and negligible

accuracy degradation, showing initial promise and the need for further research.

The rest of the paper is organized as follows: we provide the necessary background information about

location-based apps along with a motivating scenario in Section 2. Section 3 presents the complete description

of eGENâ€™s design, which is then followed by tool evaluation in Section 4. Threats to validity and related

work are discussed in Sections 5 and 6 respectively. Finally, with pointers to the future work, the paper is

concluded in Section 7.

2 BACKGROUND AND MOTIVATING EXAMPLE

This section presents the background information about the location-based application, the need for self-

adaptive location-sensing, and a motivating example.

2.1 Location-based Applications

User location is important context information [53] to provide location-based services to smartphone users.

Smartphone users widely use Location-Based Services (LBS) [15] for map navigation, discovering nearest

places of interest, activity or mobility tracking, trajectory monitoring, location-based social networking,

games, advertisement, and weather forecasting [24]. New generation smartphones can handle all types of

location-based services with their rich hardware and software capabilities [56]. The smartphones are equipped

with GPS, WiFi [10], Cell ID [25], accelerometer, magnetometer, barometer, gyroscope [58] to position the

usersâ€™ current location. Global Positioning System (GPS) [22] is widely used to locate the current location

of the user. GPS provides high accuracy of user location compared to other location-sensing techniques such

as WiFi positioning [10] and Cell ID based positioning [25]. One downside of GPS is its abnormal amount

of energy consumption for its operation [41]. Therefore, GPS usage must be reduced [42] to extend the

smartphoneâ€™s battery life. Unfortunately, GPS usage is a inevitable requirement in map navigation, activity

tracking, and trajectory monitoring applications.

3https://github.com/Kowndinya2000/egen
4https://www.nokia.com/phones/en_in/nokia-c-3?sku=SP01Z01Z2428Y

Manuscript submitted to ACM

4

Kowndinya and Marimuthu, et al.

The following strategies were found in the literature to address the abnormal battery draining issues

of GPS: (1) GPS Alternatives, (2) Movement Detection, (3) Collaborative Strategies, and (4) Adaptive

Strategies. GPS Alternatives related research efforts use the energy-efficient alternatives such as Cell-ID

sequencing matching [43], GSM positioning [25], and WiFi-based positioning [10, 36]. These approaches are

affected by poor location accuracy, which is not suitable for continuous location-sensing. The research efforts

under Movement Detection category includes approaches such as scheduling of location updates [28], turning

off GPS when not available [42], and postponing GPS updates [9]. These approaches either turn off the GPS

updates or delay them by combining inertial sensors like accelerometer, compass, gyroscope, barometer, etc.

In Collaborative Strategies, the location coordinates are fetched from the other location-based apps [34] or

neighboring devices [57]. In Adaptive Strategies several research efforts uses energy-accuracy requirements

[31, 59], indoor-outdoor detection [6], and context information [27] to dynamically switch between location

sources. These adaptive strategies dynamically select a suitable location strategy based on the dynamic

accuracy and energy requirements. Adaptive strategies are better approaches than other approaches as they

consider balancing energy and accuracy requirements of location-based services.

As reported in Fonseca et al. [17], dynamic adaptability could be one of the important practices to

improve software energy efficiency. Therefore, introducing dynamic adaptability in existing location-based

services would reduce the abnormal battery consumption while satisfying accuracy requirements. Nonetheless,

developing such self-adaptive behavior is a difficult task for the developers [29] as it has to deal with a

dynamically changing environment. In particular, identifying relevant context information for energy-saving

at run-time is not a straightforward task [5]. On the other hand, few researchers have proposed generic

solutions to address energy-efficiency issues of Android applications [7, 40] by combining self-adaptivity

and battery awareness. In this paper, we have investigated the impact of a concept called â€œself-adaptive

location-sensing" by combining dynamic adaptability and battery awareness. The fundamental idea of self-

adaptive location-sensing is to enforce energy-saving policies in the following situations: (1) when the battery

is discharging, and the battery level is critical, (2) when the app is in the background.

2.2 A Motivating Example

This subsection presents the need for self-adaptive location-sensing through an android application named
Speedometer5. It calculates the vehicle speed on a real-time basis using GPS. This application uses system
location service and requests for location updates for a specific sensing interval. As highlighted in Figure

2, the Speedometer app uses fixed sensing interval. The sensing interval (time gap between two location

calls) plays a significant role in the battery consumption by GPS. The lesser the sensing interval results

in higher location accuracy and more battery consumption. In the case of Speedometer app, the sensing

interval is maintained less and fixed for more accuracy. This usage scenario is suitable when the battery

level is high and connected to the charger. The fixed sensing interval might deplete the battery quickly

if the battery is discharging. The quick battery discharge problem could be addressed by increasing the

sensing interval. However, the location accuracy might degrade if the sensing interval is increased randomly.

Hence, the sensing interval must be made adaptive in response to the change in battery level to balance

location accuracy and battery consumption requirements. We have experimented with a speedometer app to

5https://github.com/iAhmedAwad/Speedometer

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 5

Fig. 1. Static location-sensing

Fig. 2. Self-adaptive location-sensing

calculate the GPS active time, battery consumption, and distance measured. As shown in Figure 3, the

original Speedometer app shows 2092838 ms of GPS active timehr, 718.46 mA battery consumption, and

2996 m estimated distance.

To illustrate the efficacy of self-adaptive location-sensing, we instrumented the Speedometer app source

code to make it battery-aware. In Figure 1, the lines of code inside the dashed red box represent the

self-adaptive code added to the original version of the Speedometer app. Predominantly, the function

ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ‘‡ â„ğ‘Ÿğ‘’ğ‘ â„ğ‘œğ‘™ğ‘‘ğ‘ƒ ğ‘œğ‘–ğ‘›ğ‘¡ğ‘  takes the battery thresholds as ğ»ğ¼ğºğ», ğ‘€ ğ¸ğ·ğ¼ğ‘ˆ ğ‘€, ğ¿ğ‘‚ğ‘Š , depending on the

remaining battery level. The functions ğ´ğ‘‘ğ‘ğ‘ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ƒ ğ‘œğ‘™ğ‘–ğ‘ğ‘¦_ğ»_ğ·_ğ¹ determine the dynamic sensing interval

by considering the base sensing interval and decreasing factor. Here, ğ» refers to the battery state HIGH, ğ·

refers to battery status Discharging, ğ¹ refers to the application state Foreground. In Figure 1, the arrow

points to the function ğ‘Ÿğ‘’ğ‘¡ğ‘¢ğ‘Ÿğ‘›ğ¿ğ‘’ğ‘£ğ‘’ğ‘™ calculates the dynamic location-sensing interval based on the context

values. We have also defined other functions ğ´ğ‘‘ğ‘ğ‘ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ƒ ğ‘œğ‘™ğ‘–ğ‘ğ‘¦_ğ‘€ _ğ·_ğ¹ and ğ´ğ‘‘ğ‘ğ‘ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ƒ ğ‘œğ‘™ğ‘–ğ‘ğ‘¦_ğ¿_ğ·_ğ¹

to calculate suitable sensing interval based on the current battery level and app state.

As shown in Figure 3, the self-adaptive location-sensing significantly reduces the battery consumption

(514.5 mA) compared to the original app with static sensing interval. On the other hand, it is observed that

the accuracy degrade only 35 meters which is a consequence of reduced GPS active time per hour. The results

show that the self-adaptive location-sensing might help developers reduce significant battery consumption by

increasing the sensing interval with lesser degrade in accuracy. We have carefully selected the self-adaptive

location-sensing policies as battery and location accuracy requirements are conflicting. Specifically, the

impact of battery level drop and sensing interval increasing rate for each battery drop plays a significant role

in determining energy-saving adaptation policies. Since this approach involves handling multiple context

information such as battery level, battery charging state, and sensing interval increasing factor, it might

be wiser to decide the sensing policies before the development phase. Hence, there is a need for a suitable

methodology and tool support to analyze application requirements and define appropriate energy-saving

location-sensing policies. Therefore, this paper aims to present domain-specific language support to define

location-sensing policies before development. In addition, we aim to provide a code generator that the

developers may use to introduce battery awareness.

Manuscript submitted to ACM

6

Kowndinya and Marimuthu, et al.

Fig. 3. Results of self-adaptive and non-self-adaptive versions

3 E GEN DESIGN AND DEVELOPMENT

With this paper, we would like to address the following questions:

â— What factors influence battery consumption and how to fine tune those factors?
â— How to make battery-aware decisions during design time?
â— How to plug battery-aware adaptation into an existing android application?

Our attempt towards answering all the above questions is the eGEN framework. This section presents the

overview, grammar definition, and language elements of DSML developed as part of eGEN.

3.1 Overview

The essential idea of energy-saving in location-sensing is to enforce energy-saving policies in the following

situations: (1) when the battery is discharging, and the battery level is critical, (2) when the app is in the

background. Therefore, eGEN is designed to assign values for critical battery level, and sensing-interval

based on the application requirements. eGEN consists of a domain-specific modeling language and automatic

code generator. It has been developed, with the help of Xtext and Xtend [3]. As shown in Figure 4, the

usage of eGEN consists of seven steps:

Step 1: The Eclipse editor is used to specify the energy-saving location-sensing policies using the textual

domain-specific modeling language.

Step 2: The editor creates the .ğ‘’ğ‘”ğ‘’ğ‘› model.

Step 3: The validator module of Xtext checks the .ğ‘’ğ‘”ğ‘’ğ‘› model whether it is following the eGEN DSML

grammar.

Step 4: The code generator takes the validated .ğ‘’ğ‘”ğ‘’ğ‘› model as the input.

Step 5: It then generates the Java code using model-to-text transformation.

Step 6: The generated code can be added to existing Android applications to make it energy-aware.

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 7

Fig. 4. eGEN eco-system

Step 7: The updated Android project can be built and installed on the Android device by the user.

3.1.1 Domain Model. As shown in Listing 1, the domain model contains the entities

ğ´ğ‘‘ğ‘ğ‘ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ƒ ğ‘œğ‘™ğ‘–ğ‘ğ‘¦, ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘¥ğ‘¡, ğ¹ ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’.

entity A d a p t a t i o n P o l i c y {
PolicyID

Context

A d a p t a t i o n
}
entity Context {

BatteryState = ( Charging | Discharging )

BatteryLevel = ( Low | Medium | High )

A p pl icationState ( ForeGround | Background )

}

entity Feature {

S en singInterval

D e cr easingFactor

B a t t e r y A w a r e F u n c t i o n

}

Listing 1. Domain Model for Modeling Location-sensing

The ğ´ğ‘‘ğ‘ğ‘ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ƒ ğ‘œğ‘™ğ‘–ğ‘ğ‘¦ refers to the self-adaptive energy-saving location-sensing strategies. It can be defined

with the combination of ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘¥ğ‘¡ and ğ¹ ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’. The entity ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘¥ğ‘¡ refers to the contextual situation suitable

for enabling energy-saving self-adaptation. The context information includes ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’, ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ¿ğ‘’ğ‘£ğ‘’ğ‘™,

and ğ´ğ‘ğ‘ğ‘™ğ‘–ğ‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’. The ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ¿ğ‘’ğ‘£ğ‘’ğ‘™ refers to the amount of battery (in %) left in the smartphone. The

ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ refers to the charging or discharging status of the smartphone. The ğ´ğ‘ğ‘ğ‘™ğ‘–ğ‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ refers to

the background or foreground execution of the application. The entity ğ¹ ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’ includes ğ‘†ğ‘’ğ‘›ğ‘ ğ‘–ğ‘›ğ‘”ğ¼ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘£ğ‘ğ‘™,

ğ·ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘ğ‘ ğ‘–ğ‘›ğ‘”ğ¹ ğ‘ğ‘ğ‘¡ğ‘œğ‘Ÿ, and ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ´ğ‘¤ğ‘ğ‘Ÿğ‘’ğ¹ ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›.

Manuscript submitted to ACM

8

Kowndinya and Marimuthu, et al.

The ğ‘†ğ‘’ğ‘›ğ‘ ğ‘–ğ‘›ğ‘”ğ¼ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘£ğ‘ğ‘™ refers to the time difference between two subsequent location-sensing requests. The

ğ·ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘ğ‘ ğ‘–ğ‘›ğ‘”ğ¹ ğ‘ğ‘ğ‘¡ğ‘œğ‘Ÿ refers to the numerical value that will be used to calculate the sensing interval for each

battery drop in the exponential battery-aware function. The ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ´ğ‘¤ğ‘ğ‘Ÿğ‘’ğ¹ ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘› refers to the type

of change (exponential or linear) in fixing the sensing interval. This domain model is used as a basis for

defining the grammar of the DSML, which is part of eGEN.

3.2 DSML Grammar

This subsection describes the eGEN grammar along with the structure of the language elements such as

ğ‘“ ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’ğ‘ , ğ‘ğ‘œğ‘›ğ‘¡ğ‘’ğ‘¥ğ‘¡, and ğ‘ğ‘‘ğ‘ğ‘ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ğ‘œğ‘™ğ‘–ğ‘ğ‘¦.

3.2.1 Allowed features. The ğ‘“ ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’ element of eGEN is used to define the application requirements that

affect the battery consumption of smartphone devices. Especially in location-based services, the features

like location-sensing interval and type of change in sensing interval play a significant role in deciding the

self-adaptive location-sensing strategies.

1
2

Features :

SensingInterval | De cre asi ng_ Fact o r | B a t t e r y A w a r e F u n c t i o n ;

Listing 2. Structure of the features values

As shown in Listing 2, eGEN allows following ğ¹ ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’ğ‘  for specifying energy-aware requirements:

â— ğ‘†ğ‘’ğ‘›ğ‘ ğ‘–ğ‘›ğ‘”ğ¼ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘£ğ‘ğ‘™ refers to the time difference between two subsequent location-sensing requests.
â— ğ·ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘ğ‘ ğ‘–ğ‘›ğ‘”ğ¹ ğ‘ğ‘ğ‘¡ğ‘œğ‘Ÿ refers to the numerical value that will be used to calculate the sensing interval for

each battery drop in the exponential battery-aware function.

â— ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ´ğ‘¤ğ‘ğ‘Ÿğ‘’ğ¹ ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘› refers to the type of change (exponential or linear) in fixing the sensing

interval.

3.2.2 Feature definition. Each ğ¹ ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’ can have their own rules for defining the corresponding values as

shown in Listing 3. The rules for defining feature values are given below:

â— The definition of location-sensing interval starts with the keyword "ğ‘†ğ‘’ğ‘›ğ‘ ğ‘–ğ‘›ğ‘”ğ¼ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘£ğ‘ğ‘™" and can be
assigned with an ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘”ğ‘’ğ‘Ÿ value (refer lines 1-2 in listing 3). Here, the "ğ‘†ğ‘’ğ‘›ğ‘ ğ‘–ğ‘›ğ‘”ğ¼ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘£ğ‘ğ‘™" must be

assigned in milliseconds.

â— The definition of decreasing factor starts with the keyword "ğ·ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘ğ‘ ğ‘–ğ‘›ğ‘”ğ¹ ğ‘ğ‘ğ‘¡ğ‘œğ‘Ÿ" and can be assigned

with the ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘”ğ‘’ğ‘Ÿ value (refer lines 3-4 in listing 3) as decided by the domain analyst.

â— The definition of a type of battery-aware function starts with defining the value for keyword
"ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ´ğ‘¤ğ‘ğ‘Ÿğ‘’ğ¹ ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›" and can be assigned with one of the following fixed values: ğ‘™ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ, ğ‘’ğ‘¥ğ‘ğ‘œğ‘›ğ‘’ğ‘›ğ‘¡ğ‘–ğ‘ğ‘™

(refer lines 5-6 in listing 3).

Manuscript submitted to ACM

1
2
3
4
5
6

1
2

1
2
3
4
5
6
7
8
9
10

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 9

Listing 3. Structure of feature definition

S en si ng I nt er val :

' SensingInterval ' '= ' ivalue = MYINT_T ;

D e cr e as i n g F a ctor :

' DecreasingFactor ' '= ' ivalue = MYINT_T ;

B a t t e r y A w a r e F u n c t i o n :

' BatteryAwareFunction ' '= ' value =( ' Exponential ' | ' Linear ') ;

3.2.3 Allowed context. The ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘¥ğ‘¡ element of eGEN is used to define the valid situations to enforce

self-adaptive energy-saving policies of smartphone applications. For location-based services, the following

context is considered in eGEN: remaining battery percentage, charging state of the device, and state of the

application.

Context :

Listing 4. Structure of the context values

BatteryState | BatteryLevel | AppState | Threshold_Medium | Threshold_High

As shown in Listing 4, eGEN allows following ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘¥ğ‘¡ for specifying energy-saving situations:

â— ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ refers to the charging or discharging status of the smartphone.
â— ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ¿ğ‘’ğ‘£ğ‘’ğ‘™ refers to the remaining battery percentage of the smartphone. Further, the context
ğ‘‡ â„ğ‘Ÿğ‘’ğ‘ â„ğ‘œğ‘™ğ‘‘_ğ»ğ‘–ğ‘”â„ and ğ‘‡ â„ğ‘Ÿğ‘’ğ‘ â„ğ‘œğ‘™ğ‘‘_ğ‘€ ğ‘’ğ‘‘ğ‘–ğ‘¢ğ‘š is used to define the high and medium battery percentage

for triggering self-adaptive behavior.

â— ğ´ğ‘ğ‘ğ‘™ğ‘–ğ‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ refers to the background or foreground execution status of the application.

3.2.4 Context definition. According to eGEN grammar, the definition of each allowed context can have its

pre-defined values, and domain analyst defined values.

Listing 5. Structure of the context constraints

BatteryState :

' BatteryState ' '= ' value =( ' Charging ' | ' Discharging ') ;

BatteryLevel :

' BatteryLevel ' '= ' value =( ' High ' | ' Medium ' | 'Low ') ;

Threshold_Hi gh :

' Threshold_High ' '= ' ivalue = MYINT_T ;

T h re s ho l d _ M e dium :

' Threshold_Medium ' '= ' ivalue = MYINT_T ;

AppState :

' AppState ' '= ' value =( ' Foreground ' | ' Background ')

As shown in Listing 5, the rules for specifying context values are given below:

â— The definition of charging state of the device starts with the keyword "ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’" and can have

one of the following values: ğ¶â„ğ‘ğ‘Ÿğ‘”ğ‘–ğ‘›ğ‘”, ğ·ğ‘–ğ‘ ğ‘â„ğ‘ğ‘Ÿğ‘”ğ‘–ğ‘›ğ‘” (refer lines 1-2 in listing 5).

â— The definition of remaining battery level starts with the keyword "ğµğ‘ğ‘¡ğ‘¡ğ‘’ğ‘Ÿğ‘¦ğ¿ğ‘’ğ‘£ğ‘’ğ‘™" and can have any
one of the following values: ğ»ğ‘–ğ‘”â„, ğ‘€ ğ‘’ğ‘‘ğ‘–ğ‘¢ğ‘š, ğ¿ğ‘œğ‘¤ (refer lines 3-4 in listing 5). The values for ğ»ğ‘–ğ‘”â„ and

ğ‘€ ğ‘’ğ‘‘ğ‘–ğ‘¢ğ‘š can be assigned with an integer value based on the application requirements (refer lines 5-8

in listing 5). The value ğ¿ğ‘œğ‘¤ will be inferred by the code generator script based on the range given for

ğ»ğ‘–ğ‘”â„ and ğ‘€ ğ‘’ğ‘‘ğ‘–ğ‘¢ğ‘š.

Manuscript submitted to ACM

10

Kowndinya and Marimuthu, et al.

â— The definition of application execution state starts with the keyword "ğ´ğ‘ğ‘ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’" and can have any

one of the following values: ğ¹ ğ‘œğ‘Ÿğ‘’ğ‘”ğ‘Ÿğ‘œğ‘¢ğ‘›ğ‘‘, ğµğ‘ğ‘ğ‘˜ğ‘”ğ‘Ÿğ‘œğ‘¢ğ‘›ğ‘‘ (refer lines 9-10 in listing 5).

Listing 6. Structure of the adaptation policy

Model :

eGEN += A d a p t a t i o n P o l i c y *;

A d a p t a t i o n P o l i c y :

' AdaptationPolicy ' ivalue = MYINT_T '{ ' ' Condition ' '{ ' Situation1 = Context ' AND ' value =(

Situation2 ) ;

Situation2 :

Block = Situation3 '} ' ' then ' ' Adaptation ' '{ ' FeatureBlock1 = Features ' AND ' value =(

FeatureBlock2 )

'} ' '} ';

Situation3 :

Context = Context ' AND ' value =( Situation4 ) ;

Situation4 :

Context = Context ' AND ' value =( Situation5 ) ;

Situation5 :

Context = Context ' AND ' value =( Context ) ;

FeatureBlock2 :

Feature2 = Features ' AND ' value =( Features ) ;

1
2
3
4

5
6

7
8
9
10
11
12
13
14

3.2.5 Adaptation policy. According to eGEN grammar, the definition of adaptation policy consists of

assigning five ğ‘ğ‘œğ‘›ğ‘¡ğ‘’ğ‘¥ğ‘¡ğ‘  and three ğ‘“ ğ‘’ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’ğ‘ . The specification of a self-adaptive location-sensing policy can

have one or more entries differentiated with a unique ID. As shown in Listing 6, a single adaptation policy

definition contains following parts:

â— starts with the keyword ğ´ğ‘‘ğ‘ğ‘ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ƒ ğ‘œğ‘™ğ‘–ğ‘ğ‘¦ to describe an adaptation policy followed by the unique

ID of type ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘”ğ‘’ğ‘Ÿ (refer lines 3-4 in listing 6).
â— an opening brace for adaptation policy definition
â— a keyword ğ¶ğ‘œğ‘›ğ‘‘ğ‘–ğ‘¡ğ‘–ğ‘œğ‘› to describe the allowed context changes that trigger the self-adaptation
â— an opening brace for context block definition
â— five condition definition, each consists of context assigned with allowed values. The description of
context values is given in Listing 5. Here, the context definition can be in any order. However, the

repetition of context information is not allowed inside the same context block.

â— multiple valid contexts can be separated by the keyword ğ¶ğ‘œğ‘›ğ‘‘ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›.
â— a closing brace for context block
â— a keyword ğ´ğ‘‘ğ‘ğ‘ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘› to describe the corresponding set of features to be executed at run-time for the

contextual changes described with the keyword ğ¶ğ‘œğ‘›ğ‘‘ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›.

â— an opening brace for a feature block
â— three feature definition, each consists of features assigned with allowed values. The description of
feature definition is given in Listing 3. Here, the feature definition can be in any order. However, the

repetition of feature information is not allowed inside the same feature block.

â— multiple adaptations can be separated by the keyword ğ¶ğ‘œğ‘›ğ‘‘ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›.
â— a closing brace for a feature block
â— Finally, a closing brace for adaptation policy

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 11

Fig. 5. A sample .egen model and the generated code

3.3 Code Generator

The code generator uses the following Android APIs to achieve self-adaptation: Battery Manager API, Fused

Location API, and Android Activity Life Cycle. The code generator is defined by mapping each element

in the eGEN DSML to a corresponding Android library. The BatteryManager class is used to fetch the

BatteryState, BatteryLevel of the Android device through variables ğµğ´ğ‘‡ ğ‘‡ ğ¸ğ‘…ğ‘Œ _ğ‘ƒ ğ‘…ğ‘‚ğ‘ƒ ğ¸ğ‘…ğ‘‡ ğ‘Œ _ğ¶ğ´ğ‘ƒ ğ´ğ¶ğ¼ğ‘‡ ğ‘Œ

, and ğµğ´ğ‘‡ ğ‘‡ ğ¸ğ‘…ğ‘Œ _ğ‘ƒ ğ‘…ğ‘‚ğ‘ƒ ğ¸ğ‘…ğ‘‡ ğ‘Œ _ğ‘†ğ‘‡ ğ´ğ‘‡ ğ‘ˆ ğ‘†. The applicationâ€™s status is identified using the Android ac-

tivity lifecycle onStart(), onResume(), onPause().

As shown in the Figure 5 the code generator creates Java files (MainActivity.Java, LocationUtility.Java,

BatteryAware.Java, and AdaptationUtility.java) that contains the artifacts for the self-adaptive location-

sensing. BatteryAware.java is the file that does the adaptive location-sensing activity. MainActivity extends

the BatteryAware activity and fetches the location coordinates from the function onLocationUpdate() defined

in the batteryAware class. The application developers can modify MainActivity.java to write their business

logic. The file AdaptationUtility.java contains the code that alters the sensing-interval based on the context

provided. The battery state defined in the egen model is verified against the charging status obtained from

the BatteryManager API. LocationUtility.java contains the code that does the location fetching activity as

per the sensing-interval interval captured in the AdaptationUtility.java. The generated code can be appended

to the existing Android projects to make their app self-adaptive for location-sensing.

4 EVALUATION OF E GEN

In this section, we evaluate the effectiveness of eGEN at reducing the battery consumption of open-source

location-based Android applications. The code generated by eGEN has been instrumented to the subject

applications to show its efficacy. We call our evaluation controlled experiments as the test smartphoneâ€™s

battery is only subjected to the application being monitored and some mandatory operating internal services

which will use battery all the time (eg. screen, operating system). All other apps or services that can be

Manuscript submitted to ACM

12

Kowndinya and Marimuthu, et al.

Table 1. List of Subject Applications

S.No App Name
1
2
3
4
5

GPS Logger
OSM Tracker
Runner Up
OpenTracks
KinetiE- Speedometer

Play Store
Available
Available
Available
Available
Available

F-Droid
Not Available
Not Available
Available
Available
Not Available

GitHub URL
https://github.com/BasicAirData/GPSLogger
https://github.com/labexp/osmtracker-android
https://github.com/jonasoreland/runnerup
https://github.com/OpenTracksApp/OpenTracks
https://github.com/xyz-relativity/KinetiE-Speedometer

uninstalled or stopped have been stopped. This experimental setup enabled us to avoid skewed results and

lead us to better investigate the effects of using eGENâ€™s adaptive code on battery and GPS consumption.

In literature, several studies have used controlled experiments [1, 38, 47] to evaluate the effectiveness of

tool support. Hence, we have designed a controlled experiments based empirical study to evaluate the

effectiveness of eGEN. Hence, we have designed a controlled experiments based empirical study to evaluate

the effectiveness of eGEN.

4.1 Study Design

The study was conducted to answer the following research questions:

â— RQ1: Does code generated by eGEN reduce GPS usage?
â— RQ2: How much battery consumption is reduced by code generated from eGEN?
â— RQ3: To what extent code generated by eGEN degrade location accuracy?

As the main objective of this study is to analyze the effectiveness of eGEN on balancing energy-accuracy

requirements, the relevant independent and dependant variables are selected as follows:

â— Independent variable: The Battery drain has been selected as a primary independent variable as

location-sensing reduces the battery over-time based on the GPS usage.

â— Dependent variables: In this study, we have selected the variables, sensing interval, GPS usage, battery
drop rate, and distance covered as dependent variables. These variables are directly affected by every

drop in battery percentage as specified in the adaptation policy.

4.1.1 Subject Application Selection. We have used F-Droid6 and Google Play Store7 to find out the subject
applications. Specifically, we have searched for relevant apps with keywords such as gps logging, distance

measurement, path tracker, location service, speed meter, location share, live location tracking, etc. Finally,

we have selected the android applications that primarily rely on GPS for their operation. We have considered
apps if it is open source and the source code is available on code sharing platforms like GitHub8.

The following inclusion criteria were applied to filter the relevant subject applications:

(1) If the app is written in Native Android code

(2) If GPS is primarily used for location sensing

(3) If the source code repository published with an open-source license

(4) If the recent most commit is published less than two years

(5) If the repository is well documented

6https://www.f-droid.org/
7https://play.google.com/store
8https://github.com/

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 13

Table 2. GitHub repository profile of Subject Applications

S.No
1
2
3
4
5

App Name
GPSLogger
OSMTracker
RunnerUp
OpenTracks
KinetiE-Speedometer

# Contributors # Stars # Forks

6
25
47
60
1

238
432
601
380
0

92
220
260
75
0

We found 11 candidate applications by applying the above-mentioned inclusion criteria. Further, the following

exclusion criteria were applied on the 11 candidate applications:

(1) If the appâ€™s android support plugin is incompatible with our IntelliJ IDEA version.

(2) If the app has missing dependencies or other build errors

(3) If it is not compatible with recent versions of Android (such as 10.0 or 9.0)

(4) If the app activity crashes while installing and using the Android application

We applied the exclusion criteria as mentioned above and removed the apps that satisfy at least one criteria.

Finally, we found five subject applications that are suitable for instrumentation and conducting controlled

experiments. Table 1, shows the list of subject applications and their availability on Google Play Store,

F-Droid, and GitHub. Table 2 shows the demographic data gathered from the source code repository like

GitHub. Each of the subject applications except KinetiE-Speedometer have at least 6 contributors, 238

stars, and 75 forks. We have chosen KinetiE-Speedometer to verify the usefulness of eGEN generated for

applications that do not rely on other position sensing sensors.

4.1.2 Investigation of Subject Applications and Writing Adaptation Polices. The first and second authors

have investigated the subject applicationâ€™s source code to identify the modules responsible for location

listeners. We have looked for the location API, sensing interval, and support for battery awareness. The

subject applications used static sensing intervals and became a candidate for introducing self-adaptive

location sensing. Apart from other utility files, each of the subject application contained location listeners

and files detailing track information to the user. These were the files involved in code instrumentation; while

apps used different location manager APIs, the relaxation time between two location updates was found to

be static and can be modified independently without disturbing the location fetching process. Hence, the

adaptation code being added to subject applications only derives GPS sensing interval based on battery

status and is independent of location manager API used in the subject application. Applications such as

RunnerUp, GPSLogger provision users to set the GPS sensing interval based on their preference, however

the sensing interval adjusted to userâ€™s preference is also static; since eGEN version of the app should contain

adaptive code and that of non-eGEN a fixed value, we have disabled the user control on changing the sensing

interval in the app and code has been instrumented accordingly. As shown in Listing 7 (partial), we have

defined three battery discharging situations to update the location sensing interval. The full adaptation
policies can be found in the readme9. The first situation is when the battery level is High (80 and above),
the second situation is when the battery level is Medium (between 50 to 80), and the third situation is when

the battery level is Low (below 50). We have defined an adaptation policy that assigns sensing intervals of 3

9https://github.com/Kowndinya2000/egen#exact-adaptation-policy-instrumented-for-subject-applications

Manuscript submitted to ACM

14

Kowndinya and Marimuthu, et al.

Listing 7. An excerpt of the instrumented Adap-
tation Policy

Adapta ti on Policy 01 {

Condition {

BatteryState = Discharging
BatteryLevel =
Threshold_High = 80 AND
Threshold_M edium = 50 AND
AppState = Foreground

High AND

AND

} then
Adaptation {

SensingInt erval = 3000 AND
De cr e as in g_F ac to r = 10 AND
B a t t e r y A w a r e F u n c t i o n = Linear

}

}

1
2
3
4
5
6
7
8
9
10
11
12
13
14

Fig. 6. Change in Sensing interval

seconds, 4 seconds, and 5 seconds respectively for High, Medium, and Low battery level when the battery

is discharging. In addition, the decreasing factor for High is set to 10 while 20 and 30 are set for Medium

and Low battery level, respectively. This will ensure that the sensing interval will increase based on the

decreasing factor for each battery drop. As shown in Figure 6, the sensing interval is increasing at a slower

pace along with each battery drop when the smartphoneâ€™s battery level is more than 80%. On the other

hand, the sensing interval is increasing at a comparatively faster pace when the battery level is Medium and

Low. Especially, the sensing interval is increasing at a faster rate when the device battery drops to Low to

reduce the number of GPS calls.

4.1.3

Instrumentation of Subject Applications. In this step, we aim at instrumenting the generated code to

the subject applications for battery awareness. For this purpose, we downloaded the source code of each

subject application from GitHub. We looked for variables that hold the sensing interval, functions that

handle location updates, and activities that address map features. We have extracted the generated code

from BatteryAware.java and instrumented it in the subject application. Overall, the instrumentation step

consists of following activities:

â— Instrumenting for battery-aware location-sensing: The subject applications are instrumented with
the generated code such that it will dynamically change the location sensing interval based on the

current battery level and charging status. We found that all the subject applications had static sensing

intervals. Therefore, we aim to make it dynamically adaptive in this step. The subject applications are

instrumented with the generated code for dynamically changing the location sensing interval based on

the current battery level and charging status. The instrumentation initialized the adaptation policies

and made a call to the functions described in the Adaptation Activity class. Apps such as GPSLogger,

OSMTracker provided users the option to decide the minimum distance between two location updates

and minimum location accuracy. In such situations, we disabled the original code and replaced it with

the generated code to make it consistent with other subject applications. The subject applications had

static GPS location update interval. We brought Battery level and status in context to determine the

sensing interval on demand for each location update. This is achieved by initializing the adaptation

policies and calling the functions described in the Adaptation Activity class.

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 15

â— Instrumenting for estimating distance covered: This phase aims to instrument the app to fetch the
location coordinates and calculate the distance covered in meters. As pointed earlier, in subject

applications such as GPSLogger, OSMTracker, the distance measurement is given by default. However,

other subject applications cannot measure distance and create a need for measuring distance. Hence,

we have added functions to collect latitude and longitude information from respective java classes

to measure the distance covered. Finally, the measured distance (meters) is annotated on the map

view of the subject applications. While some subject applications have distance measurement given by

default, others do not measure distance travelled. The activity that displays the user track/location

information might not calculate the location related events and use other java classes that do GPS

location sensing as function calls. Hence, we independently added additional functions that collect

latitude and longitude information from respective java classes and we annotated the map view with

the distance travelled in meters.

â— Rebuilding the application and install on the test device: After the instrumentation phase, the project
has been cleaned and re-built for conducting experiments. We created two versions of executables for

each subject application, namely, eGEN version and non-eGEN version. The eGEN version represents

the executable built from the instrumented project with battery-aware code. On the other hand, the

non-eGEN version represents the executable built from the source code downloaded from GitHub.

After we instrumented the app, we cleaned the project and re-built it. We then installed the modified

app on the test device and reviewed the app by checking all the UI components and we looked for any

activity crashes before doing the actual trail.

Finally, the executables were installed on the test device, and the UI components were verified to ensure

that the instrumentation did not affect the appâ€™s behavior. We also verified that the apps are not crashing

before doing the actual experiments.

4.1.4 Experiment Protocol. We have selected Nokia C3 as a test device for conducting the experiments.

Nokia C3 comes with a 5.99 inch display, and its hardware packs 3GB RAM and 32GB in-built storage with

a 3040 mAH battery. This smartphone runs on Android 10 and comes with a cleaner version of Android,

which helps us disable all the apps to create an isolated environment for conducting controlled experiments.

Each subject application has been given network/location-related permissions during the trial. Initially, we
had conducted cycling from the specified source to destination using Google Fit10 to measure the total
distance. The three trails of distance measurement with Google Fit is depicted in Figure 7. Figure 7[A]

shows the direction of travel from source to source(destination), Figure 7[B] and [C] show the duration of

the trail and distance covered. Three Google fit trials with the same source and the destination have been

conducted and found an average distance of 3060 meters. The average battery drop percentage was between

3% to 4%. The distance measured with Google Fit (3060 m) is considered a reference distance and used to

analyze the location accuracy of subject applications.

We have conducted three trails for both eGEN and non-eGEN versions of the five subject applications,

thus conducting 30 trails each of length 3 kilometers (approx.). For each trial, we followed steps mentioned

below:

10https://www.google.com/fit/

Manuscript submitted to ACM

16

Kowndinya and Marimuthu, et al.

Fig. 7. Distance Measured by Google Fit

â— Installing the instrumented App on testing device
â— Resetting the bug report using Android Device Bridge (adb)
â— Cycling from the defined source to destination
â— Exporting the bug report after reaching the destination
â— Uploading the bug report in Google Battery Historian to Measure the percentage of battery drop
â— Record the distance covered in Meters

On completing each controlled trial, we use adb to generate the android test deviceâ€™s bug report in .zip

format. The generated bug report has been uploaded to the Battery historian for further analysis.

4.2 Experimental Results

This subsection presents the experimental results and answers to research questions.

Answering RQ1: Does code generated by eGEN reduce GPS usage? The purpose of this research question is

to check whether the code generated by eGEN reduces the ğºğ‘ƒ ğ‘†ğ´ğ‘ğ‘¡ğ‘–ğ‘£ğ‘’ğ‘‡ ğ‘–ğ‘šğ‘’ğ‘ƒ ğ‘’ğ‘Ÿğ»ğ‘œğ‘¢ğ‘Ÿ compared to the non-

eGEN version of the subject application. For this purpose, the Google battery historian tool was used to fetch

the ğºğ‘ƒ ğ‘†ğ´ğ‘ğ‘¡ğ‘–ğ‘£ğ‘’ğ‘‡ ğ‘–ğ‘šğ‘’ğ‘ƒ ğ‘’ğ‘Ÿğ»ğ‘œğ‘¢ğ‘Ÿ for each subject application. The reduction in ğºğ‘ƒ ğ‘†ğ´ğ‘ğ‘¡ğ‘–ğ‘£ğ‘’ğ‘‡ ğ‘–ğ‘šğ‘’ğ‘ƒ ğ‘’ğ‘Ÿğ»ğ‘œğ‘¢ğ‘Ÿ is

calculated as the time difference between the GPS active time by non-eGEN version and eGEN version of

each subject application. A positive value indicates that eGEN version has managed to bring down the GPS

active duration per hour. As shown in Table 3, the experimental results show that eGEN generated code

reduces GPS active time by a minimum of 58 seconds and a maximum of 6m27s in an hour. Specifically, the

highest reduction in GPS active time was produced by the instrumented version of GPSLogger that reduced

the GPS active time by 6-7 minutes. On the other hand, the instrumented version of Open Tracks produced

the lowest reduction in GPS active time of 58 seconds. Overall, the experimental results show that eGEN

reduced the GPS active time by 4.35 minutes per hour on average.

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 17

Table 3. GPS Active Time Reduction of eGEN over Non-eGEN

S.No

Subject App

1
2
3
4
5

GPSLogger
RunnerUp
KinetiE-Speedometer
OSMTracker
Open Tracks

GPS Active Time per hour Reduction in GPS Active
Non-eGEN
50m40s
42m38s
46m28s
48m52s
46m7s

Time per hour
6m27s
6m2s
6m1s
2m15s
58s

eGEN
44m13s
43m36s
40m27s
46m37s
45m9s

We observed a significant reduction in GPS usage of 4.35 minutes by increasing the ğ‘†ğ‘’ğ‘›ğ‘ ğ‘–ğ‘›ğ‘”ğ¼ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘£ğ‘ğ‘™

with a suitable ğ·ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘ğ‘ ğ‘–ğ‘›ğ‘”_ğ¹ ğ‘ğ‘ğ‘¡ğ‘œğ‘Ÿ for each battery drop. The results show that adopting dynamic

location-sensing intervals might help developers reduce the GPS usage.

Answering RQ2: How much battery consumption is reduced by code generated from eGEN?. The purpose of this

research question is to identify the amount of battery saved by the instrumentation adaptation policies and

eGEN generated code. We had conducted the trials when the battery level was either low or transitioning

from medium to low or high to medium to cover all the possible battery-critical situations. The Google

battery historian was used to estimate the battery consumed by each subjection application. It displays

battery usage in a chart by taking the bug report as input. We have estimated the battery consumption in

mA by filtering the subject application in the battery usage chart with the help of the subject applicationâ€™s

package name. The battery consumed by non-eGEN and eGEN version was compared, and the difference

is reported in Table 4. The positive value of Energy Savings in mA implies that the significant amount of

battery consumption is reduced by eGEN version. Overall, eGEN generated code was able to reduce battery

consumption in five subject applications. The results from subject applications show that the eGEN version

shows energy savings ranged from 89 mA (approx) to 269 mA (approx). The calculated mean reduction in

battery consumption is 188 mA As shown in Table 4, the code generated by eGEN can bring a maximum of

268.76 mA (approx.) battery savings in OpenTracks.

Overall, the instrumented code shows considerable battery savings for the trails that last for 12-14

minutes. We believe that the eGEN generated code might show significant battery savings when the

apps are used for a longer time in real-world scenarios. Hence, writing a battery-aware code might

help developers to reduce unwanted battery consumption in location-based Android applications.

Answering RQ3: To what extent code generated by eGEN degrade location accuracy? The purpose of this

research question is to find out the extent to which location accuracy is degraded at the cost of reducing

battery consumption. We have considered the distance measured by Google Fit as the benchmark to measure

the deviation in location accuracy of subject applications. Initially, we have conducted three trials from the

same source to destination using Google Fit, and the averaged distance of 3.06 km has been considered for

Manuscript submitted to ACM

18

Kowndinya and Marimuthu, et al.

Table 4. Battery Saved by eGEN over Non-eGEN

S.No

Subject App

1
2
3
4
5

OpenTracks
KinetiE-Speedometer
RunnerUp
OSMTracker
GPSLogger

Battery Consumption
in mA
eGEN Non-eGEN
541.03
924.77
798.77
506.37
842.92

809.79
1173.78
983.49
656.31
931.80

Energy Savings
in mA

268.76
249.01
184.72
149.94
88.88

the comparison. We used Haversine formula11 for calculating the distance by collecting the coordinates of
the previous and current locations and cumulatively adding the distance between every two locations for the

entire trail.

In Table 5, the distance covered by eGEN and non-eGEN version of the subject applications is presented

along with the error in location accuracy compared to the distance measured by Google Fit. In addition, the

degraded location accuracy is reported in Table 5. The degrade is calculated by subtracting the location

error by non-eGEN version and eGEN. In Table 5, the negative degrade values mean less deviation, and

positive values signify more deviation in location accuracy. Overall, eGEN version interestingly reported a

thin margin of degradation in accuracy when compared to the non-eGEN version of the subject application.

Distinctly, the application KinetiE-Speedometer brought in a more accurate distance measurement of 80

meters while reducing the battery consumption. Similarly, OSMTracker showed equally reliable accuracy in

distance measurement when compared to that of Non-eGEN while results in battery savings of 149.94 mA.

The apps such as Open Tracks, RunnerUp, and GPSLogger showed degraded accuracy about 7, 10, and 54

meters, respectively. However, this degraded accuracy comes with significant battery savings, as reported in

Answer to RQ2.

Overall, the eGEN versions of the subject applications resulted in an average distance measurement

of 2968 meters which is 92 meters lesser than the distance measured by Google Fit. As discussed

in RQ2, the average battery consumption reduction of 188 mA might make the 97 meters degrade

inaccuracy negligible. Hence, writing a suitable self-adaptive location-sensing policy would help to

balance battery consumption and other conflicting requirements such as location accuracy.

4.3 Implications

We believe that the experimental results lay a promising foundation for adopting the energy-saving self-

adaptive location-sensing policies in open source applications in the future for balancing battery and location

accuracy requirements. This subsection presents some of our findings that may further assist domain analysts,

app developers, API developers, and researchers in handling self-adaptive location-sensing.

Domain Analysts and Domain Experts. This study shows the importance of considering energy-aware require-

ments in the early stages of software development. The self-adaptive location-sensing framework presented in

11https://www.movable-type.co.uk/scripts/latlong.html

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 19

Table 5. Distance covered by eGEN and Non-eGEN

S.No

Subject App

Distance
Covered in km

Error in
Location Accuracy
Non-eGEN eGEN Non-eGEN eGEN

Degrade in
Location Accuracy

1
2
4
5
6
7

KinetiE-Speedometer
OSMTracker
Open Tracks
RunnerUp
GPSLogger
Google Fit (Benchmark Application)

2.79
2.990
2983
2.99
3.05

2.87
2.990
2976
2.98
2.996

280
60
77
80
20
3.06 km

200
60
84
90
74

-80
0
7
10
54

this approach can balance battery consumption and location accuracy based on the remaining battery level.

Hence, we suggest domain analysts introduce self-adaptive behavior to manage conflicting requirements like

battery consumption and location accuracy. Therefore, in the future, the domain analyst and domain experts

may consider battery-aware self-adaptive solutions for other application domains. Significantly, the domain

analyst may develop domain-specific languages and code generators to address application domain-specific

energy bugs and corresponding energy-saving solutions for domains like games, social networks, and other

resource-intensive applications.

App Developers and API Developers. As shown in the results, the self-adaptive location sensing with battery-

awareness significantly impacts battery consumption and GPS active time. Hence, we suggest developers

write battery-aware code from the initial development itself to handle energy-hungry components. The

presented approach is about adding battery awareness in the application developer-written code. In addition,

we suggest API developers add support for battery awareness in the library to reduce amount development

efforts of application developers. For instance, prospective API developers may modify the existing location

APIs or create a new API with battery-aware self-adaptive location-sensing. In addition, API developers

from other application domains also introduce battery-awareness in the capabilities provided by their library.

Researchers. The DSML and code generator presented in this paper shows initial promise for considering

domain-specific energy bugs in the early stages. Hence, we suggest potential researchers identify and catalog

the domain-specific energy bugs and their possible solutions to help developers make energy-saving decisions

during the development phase. Further, researchers may provide suitable domain-specific tool support to

handle the most commonly occurring domain-specific energy bugs.

5 THREATS TO VALIDITY

In this section, the potential threats to the validity of the presented case study are discussed. The guidelines

given by Runeson and HÃ¶st [52] are followed to categorize and discuss the threats.

Construct Validity

Construct validity refers to the degree to which the analysis measures what we aim to study. In this study,

we aim to measure the GPS usage, Battery Consumption, and Location Accuracy. There is a high possibility

of error in measuring these variables as we do not have widely accepted tools. In literature, several studies

Manuscript submitted to ACM

20

Kowndinya and Marimuthu, et al.

use hardware tools to measure energy consumption and use older Android phones [1, 33, 38], which might

not suit recent Android devices. To address this issue, we have decided to use the recent tool developed

by Google developers, namely Google Battery Historian. The GPS usage is estimated as GPS active time

per hour and the Battery Consumption is estimated in ğ‘šğ´ by the Google Battery Historian tool. The

Location Accuracy was calculated in terms of distance covered in ğ‘šğ‘’ğ‘¡ğ‘’ğ‘Ÿğ‘ . Initially, we used the Google Fit

application to measure the distance. We have conducted three trials and considered the averaged value of

3.06 kilometers as the benchmark to compare the location accuracy given by the subject application. Of the

subject applications, OSMTracker cannot calculate the distance covered, hence, we have instrumented a

popularly known method to measure the distance covered using the location coordinates given by the subject

applications. The important validity threat in this category is an error in measuring the GPS usage, battery

consumption, and location accuracy. Therefore, we conducted three trials for each eGEN and non-eGEN

versions of subject applications. The averaged values of three trials have been considered to avoid the error

caused in single trials. In addition, the subject applications were executed in the controlled environment

by disabling all other user applications. Hence, we believe that the values measured are from the subject

applications and can answer the research questions.

Internal Validity

Internal validity is a concern when examining causal relationships. In this study, there is a possibility of

validity threats in deciding the factors affecting GPS usage, battery consumption, and location accuracy.

We have conducted preliminary controlled experiments with subject applications developed in our lab with

varying location-sensing intervals, battery level and battery charging state to mitigate this threat. We have

conducted random trials with the sample subject application and analyzed the relationship between variables.

The first two authors have conducted the experiments, and all the authors were involved while analyzing

the cause-effect relationship. Finally, we have selected battery drain as a primary independent variable as it

affects the location-sensing interval, GPS usage, Battery consumption and location accuracy. Consequently,

the affected variables such as sensing interval, GPS usage, battery consumption and distance covered are

selected as dependent variable. In addition, we have observed a relationship between the dependent variables.

For instance, the sensing interval is set to increase for each battery level drop. Consequently, we observed

a decrease in GPS usage, battery consumption, and accuracy of distance covered. Therefore, we verified

this causal relationship also in the trials we conducted for the subject application. The results show that

the mentioned causal relationship has been maintained between the variables. We believe that we have

considered all aspects of causal relationships in this domain which poses less threat to internal validity. The

other possibility of internal threat is in the selection of subject applications. Initially, we searched the apps

on F-Droid with keywords such as gps logging, distance measurement, path tracker, location service, speed

meter, location share, live location tracking, etc. We believe that the keywords chosen cover all location-based

applications such as map navigation, activity monitoring, etc. In addition, we also searched for open source

applications through the Google play store. After getting 49 candidate applications, we have carefully applied

inclusion and exclusion criteria. The first two authors have primarily worked on applying inclusion and

exclusion criteria. The third and fourth authors have been involved in resolving the conflicts in the selection

of subject applications. To the best of our knowledge, we believe that the selected subject applications are

more suitable representative subject applications for evaluating eGEN.

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 21

External Validity

The external validity refers to the generalizability of the results presented in this study. There is a possibility

of validity threats in terms of the application domain considered in this case study. In this study, location-

based applications have been selected for evaluating the eGEN. Hence, the results presented in this study

is only can be generalized for location-based applications. However, the results also can be generalized to

the smartphone apps if it uses location as one of the important contexts. The energy-saving opportunities

presented in this study can be applied to such applications if location-sensing drains a significant amount of

battery. The second possible external validity threat is the ability of DSL and code generator developed as

part of eGEN. The domain model of eGEN is specifically designed for location-based applications. Hence,

the capability of eGEN can be generalized only to location-based applications. The code generator presented

in this paper generated only Java code that can be used for Android applications. Hence, the generated

code cannot be used for iOS or Windows smartphone platforms. However, the support for iOS and Windows

platforms will be added in the future enhancements to eGEN.

Reliability

Reliability refers to the extent to which the presented case study is repeatable by other researchers. The

first repeatability issue would be possible in specifying self-adaptive location-sensing policies and generating
code. Therefore, to mitigate this threat, we have uploaded the eGEN source code to GitHub12, which can be
downloaded and used by other researchers. The second threat in this category is instrumenting the subject

applications. We have uploaded the instrumented subject applications in the replicable package to mitigate
this threat, which is available in the replication package13. The other researchers can build the shared source
code and conduct the experiments on their testing device. There may be situations where the source code

building might result in build errors and failure to compile the .apk files. To address this issue, we have

also shared the .apk for both eGEN and non-eGEN versions of the subject application. As we conducted

controlled experiments, there is a high possibility of getting deviated results when other researchers repeat
the same experiment. Therefore, to verify the results, we have shared the bug reports14 that contain the
GPS usage and Battery consumption data. The bug reports can be uploaded to the Google Battery Historian

tool, and presented results can be verified.

6 RELATED WORK

The related works are classified under two categories: (1) DSL for design-time specification of energy-related

properties, (2) Model-driven development of Android apps. In this section, the related works found from the

literature are summarized and compared with the eGEN.

6.1 DSL for Energy Specification

We found only one DSL-based approach, namely Energy Estimation Language (EEL) [4] that considered

explicit specification of energy-related properties at design time to the best of our knowledge. The authors

have used energy estimation formulas to annotate the xDSLs to predict their energy consumption. In this

12https://github.com/Kowndinya2000/egen
13https://github.com/Kowndinya2000/egen/tree/master/subject-applications
14https://github.com/Kowndinya2000/egen/tree/master/bug-reports

Manuscript submitted to ACM

22

Kowndinya and Marimuthu, et al.

approach, during design time itself energy specialists can define Energy Estimation Models (EEM) for xDSL

and predict how much energy it can consume at run-time for different run-time platforms. EEL is a textual

domain-specific language written using Xtext language development platform. The authors have conducted

a case study on AurdinoML models to evaluate this approach. The results show that the estimation model

produces an estimation error of 4.9%, between 0.4% and 17.1%. EEL is related to eGEN in terms of proposing

a textual domain-specific modeling language for explicit specification energy-related properties. However, it

is different from eGEN as it targets cyber-physical systems while eGEN target Android apps. eGEN comes

with a DSL and code generator for specifying energy-saving opportunities. In contrast, EEL comes with the

only DSL for specifying run-time energy consumption, and it doesnâ€™t have code generation support.

6.2 Model-driven development of Android apps
6.2.1 Existing Approaches. MD2 [21] is an approach for developing mobile apps with model-driven develop-
ment methods. It consists of a domain-specific language to specify the data-driven business apps. It also

contains a code generator for generating native Android and iOS code. The language and code generated by
MD2 follow the Model-View-Controller pattern. The Model component allows the developers to define the
applicationâ€™s data model. The View component helps in describing the user interface and its elements. The

Controller component aids to describe the user interaction and events associated with the apps. The DSL
was defined with Xtext15, and Xtend16 defines the code generator. The recent version of MD2 [20] includes
the following capabilities: device-specific layout, extended control structures, and offline computing.

Xmob [30] is a platform-independent DSL for creating mobile applications for multiple platforms. It is

developed with three sub-languages (Xmob-data, Xmob-ui, Xmob-event) to follow the MVC pattern. The

Xmob-data helps the developers to specify the way retrieving form database, web service, or other data

sources. The Xmob-ui helps the developers to describe the UI elements such as widgets, forms, buttons,

etc. The Xmob-event helps the developers to link the user interfaces and data sources. Xmob involves

model-to-model transformation and model-to-text transformation to generate the source code of the desired

platform. The model-to-model transformation converts the platform-independent model to a platform-specific

model. The model-to-text generates the source code corresponding to the elements in a platform-specific

model. Xmob uses Xtext for language definition, Kermeta for model-to-model transformation, and Xpand

for the code generator.

ADSML [26] is an adaptive domain-specific modeling language for native mobile app development. It

relies on meta-model extraction, meta-model elevation, meta-model alignment, and meta-model unification

to create target apps for the Android and iOS platforms. The meta-model extraction phase extracts the

platform-specific meta-models from the targeted platforms native APIs. The meta-model elevation phase

abstracts the platform-specific API models and select the sub-set for further analysis. The meta-model

alignment phase find out the similar meta-model elements among different platforms. Finally, the meta-model

unification phase creates the platform-independent DSL from the platform-specific models identified in the

previous phase. The current implementation of ADSML does not have the support for code generation.

DSL-Comet [55] is the active DSL that targets a smart city or IoT applications. It primarily runs on

mobile devices to tag the location and contextual information on the model elements created by DSL-Comet.

15https://www.eclipse.org/Xtext/
16https://www.eclipse.org/xtend/

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 23

Table 6. Comparison of model-driven development approaches for mobile app development

Approach

DSL Type

Targeted
Platforms

MD2 [21]

Textual

Android, iOS

Xmob [30]

Textual

Android, iOS
& Windows

ADSML [26]

Textual

Android, iOS

DSL-Comet [55]

Graphical

N/A

RAPPT [2]

Graphical
& Textual

Android

Domain

Data-driven
Business Apps
All Mobile
Apps
All Mobile
Apps
Smart City
Applications
All Mobile
Apps

MoWebA Mobile [39] Graphical

Android,
Windows

Offline
Business Apps

eGEN

Textual

Android

Location
based Apps

Modeling
Scope
Data, UI &
User Interaction
Data, UI &
Events

All aspects

Business
Functions

Views

Data Layer &
Network
Connectivity
Location
Sensing Interval

Context
Awareness

Battery
Awareness

No

No

No

Yes

No

No

Yes

No

No

No

Partial

No

No

Yes

The DSL-Comet includes Open, Geo, and Contextual DSLs to form an active DSL. The Open DSLs interact

with external APIs to retrieve the information related to model elements. The Geo DSLs render the models

on the map interface to tag the current location on the models associated with geo-services. The Contextual

DSLs are context-aware and helps to re-organize the model after encountering the contextual changes. It

has iOS and Eclipse-based editors that permits the users to model either on the mobile or desktop. The iOS

editor stores the models in JSON format, and the Eclipse-based editor stores the models in XML format.

The DSL-Comet does not have a code generator to generate source code for the targeted platform.

Rapid APPlication Tool (RAPPT) [2] aids the developers in specifying the characteristics of mobile

applications using domain-specific visual language and textual language. Initially, the developers can use visual

language to specify the high-level architecture and the number of screens with navigation. The developers

can then use textual language to add more specific information, such as data schema, authentication, web

service, etc., to define the app. The model-to-model transformation then takes place to convert the app

model to the Android model, where high-level specification will be transferred to Android-specific elements

such as classes, activities, fragments, etc. Finally, the RAPPT generates the source code from the Android

model that resembles the developerâ€™s written code. The generated code produces the working prototype,

and developers need to add the business logic to deliver the working application.

MoWebA Mobile [39] is a model-driven approach covering the mobile appsâ€™ data layer. This approach mainly

defines the data source of application to develop offline access to business applications in case of network

connectivity issues. This approach consists of three phases: (1) Problem Modeling, (2) Solution Modeling,

and (3) Source Code Definition. The problem modeling phase uses the Computational-independent Model

(CIM) and Platform-independent Model (PIM). The solution modeling phase uses the Architecture-specific

Model (ASM) to specify the architectural requirements. It uses UML profiles to create Platform-independent
models and EMF to convert the PIM to ASM. Finally, it uses Acceleo17 to transform models to generate
code for developing native applications for Android and Windows platforms.

17https://www.eclipse.org/acceleo/

Manuscript submitted to ACM

24

Kowndinya and Marimuthu, et al.

6.2.2 Comparing approaches. The comparison of the model-driven development of mobile apps is given

in Table 6. The approaches are compared based on the following criteria: DSL Type, Targeted Platform,

Domain, Modeling Scope, Support for Context-awareness, and Support for Energy-awareness. As shown

in Table 6, the considered approaches can be broadly classified into two categories, namely, Textual and
Graphical based on the DSL Type. The approaches such as MD2 [21] , Xmob [30], ADSML [26] uses the
textual DSL to specify the app functionalities. The graphical DSL is used in the approaches like DSL-Comet

[55], RAPPT [2], and MoWebA Mobile [39].

In this research work, eGEN framework adopts the textual DSL for modeling the energy-saving self-

adaptive requirements of smartphone applications. The Target Platform criteria refer to the mobile platform

for which the source code generated by the code generator associated with the discussed tools. Most of

the approaches generate code for multiple platforms such as Android, iOS, and Windows. The RAPPT

[2] approach considers only the Android platform for code generation. In this research work, the eGEN

framework covers only the Android platform, and other platforms will be considered in the future releases of

the framework. The Domain criteria refer to the application domain covered by the DSL and code generator.

As shown in Table 6, most of the approaches cover all the aspects of mobile apps. In contrast approaches
such as MD2 [21], DSL-Comet [55], and MoWebA Mobile [39] covers the specific application domains.
Specifically, the MD2 [21] is for data-driven business apps, DSL-Comet [55] is for smart city applications,
and MoWebA Mobile [39] is for business applications with offline access. As observed from the Table, none

of the approaches have considered location-based Android applications. Subsequently, in this approach,

family of location-based services has been considered as the application domain for DSL and code generator.

The modeling scope criteria refer to the elements that can be modeled with the DSL provided in the related

approaches. As shown in Table 6, most of the approaches cover the data and UI modeling of mobile apps.

None of the existing approaches have considered modeling the location-sensing of mobile apps. On the

contrary, this research workâ€™s modeling scope covers the location-sensing of mobile apps. Finally, the existing

approaches have been compared for self-adaptivity and energy-awareness support. As observed from Table 6,

none of the existing approaches has considered the self-adaptivity and energy-awareness of the mobile apps,

which is the essential non-functional requirements for the recent generation smartphones. Therefore, in this

research work, the modeling of energy-awareness and self-adaptivity has been considered for location-based

Android applications.

7 CONCLUSION AND FUTURE WORK

This paper presents the eGEN tool for modeling energy-aware self-adaptive behaviors of location-based

mobile applications. The domain analyst may use the textual DSML to specify the energy-saving adaptation

plans. The developer may use the generated battery-aware code in the existing repositories. The preliminary

evaluation presented in this paper shows that the instrumented code shows a considerable reduction in

battery consumption for the trials that last for 12-14 minutes. Hence, we believe that the eGEN generated

code might show significant battery savings when the apps are used for a longer time in real-world scenarios.

Therefore, writing battery-aware code might help developers to reduce unwanted battery consumption in

location-based Android applications.

Currently, eGEN grammar covers only GPS and does not cover other smartphone sensors for location-

sensing. We plan to cover accelerometer and magnetometer in the next version. We also intend to perform

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 25

controlled experiments at a large scale on greater number of android applications to device a catalog of

adaptation policies for different categories of android applications. This also would enable us to strengthen

the further versions of eGEN. The eGEN generated code cannot be used for iOS or Windows smartphone

platforms. However, the support for iOS and Windows platforms will be added in the future enhancements

to eGEN. eGEN has been evaluated by us through controlled experiments. In future, we have plans to

evaluate it with mobile app developers for its usability and completeness.

ACKNOWLEDGMENTS

This publication is an outcome of the R&D work undertaken project under the Visvesvaraya Ph.D. Scheme

of Ministry of Electronics & Information Technology, Government of India, being implemented by Digital

India Corporation.

REFERENCES

[1] Abhijeet Banerjee, Lee Kee Chong, ClÃ©ment Ballabriga, and Abhik Roychoudhury. 2018. Energypatch: Repairing
resource leaks to improve energy-efficiency of android apps. IEEE Transactions on Software Engineering 44, 5 (2018),
470â€“490.

[2] Scott Barnett, Iman Avazpour, Rajesh Vasa, and John Grundy. 2019. Supporting multi-view development for mobile

applications. Journal of Computer Languages 51 (2019), 88â€“96.

[3] Heiko Behrens, Michael Clay, Sven Efftinge, Moritz Eysholdt, Peter Friese, Jan KÃ¶hnlein, Knut Wannheden, and Sebastian
Zarnekow. 2008. Xtext user guide. DostupnÃ© z WWW: http://www. eclipse. org/Xtext/documentation/1_0_1/xtext.
html (2008), 7.

[4] Thibault BÃ©ziers la Fosse, Massimo Tisi, Jean-Marie Mottu, and Gerson SunyÃ©. 2020. Annotating executable DSLs
with energy estimation formulas. In Proceedings of the 13th ACM SIGPLAN International Conference on Software
Language Engineering. 22â€“38.

[5] Nicholas Capurso, Bo Mei, Tianyi Song, Xiuzhen Cheng, and Jiguo Yu. 2018. A survey on key fields of context awareness

for mobile devices. Journal of Network and Computer Applications 118 (2018), 44â€“60.

[6] Nicholas Capurso, Tianyi Song, Wei Cheng, Jiguo Yu, and Xiuzhen Cheng. 2017. An Android-Based Mechanism for
Energy Efficient Localization Depending on Indoor/Outdoor Context. IEEE Internet of Things Journal 4, 2 (2017),
299â€“307.

[7] Angel CaÃ±ete, Jose-Miguel Horcas, Inmaculada Ayala, and Lidia Fuentes. 2020. Energy efficient adaptation engines for
android applications. Information and Software Technology 118 (2020), 106220. https://doi.org/10.1016/j.infsof.2019.
106220

[8] Kongyang Chen, Guang Tan, Jiannong Cao, Mingming Lu, and Xiaopeng Fan. 2019. Modeling and improving the energy

performance of GPS receivers for location services. IEEE Sensors Journal 20, 8 (2019), 4512â€“4523.

[9] Dae-Ki Cho, Uichin Lee, Youngtae Noh, Taiwoo Park, and Junehwa Song. 2015. PlaceWalker: An energy-efficient place
logging method that considers kinematics of normal human walking. Pervasive and Mobile Computing 19 (2015),
24â€“36.

[10] Taehwa Choi, Yohan Chon, and Hojung Cha. 2017. Energy-efficient WiFi scanning for localization. Pervasive and

Mobile Computing 37 (2017), 124â€“138.

[11] Paolo Ciancarini, Shokhista Ergasheva, Zamira Kholmatova, Artem Kruglov, Giancarlo Succi, Xavier Vasquez, and
Evgeniy Zuev. 2020. Analysis of energy consumption of software development process entities. Electronics 9, 10 (2020),
1678.

[12] Luis Cruz and Rui Abreu. 2017. Performance-based guidelines for energy efficient mobile applications. In 2017
IEEE/ACM 4th International Conference on Mobile Software Engineering and Systems (MOBILESoft). IEEE,
46â€“57.

[13] Luis Cruz and Rui Abreu. 2018. Using Automatic Refactoring to Improve Energy Efficiency of Android Apps. arXiv

preprint arXiv:1803.05889 (2018).

[14] Luis Cruz, Rui Abreu, and Jean-NoÃ«l Rouvignac. 2017. Leafactor: Improving energy efficiency of android apps via
automatic refactoring. In 2017 IEEE/ACM 4th International Conference on Mobile Software Engineering and Systems
(MOBILESoft). IEEE, 205â€“206.

Manuscript submitted to ACM

26

Kowndinya and Marimuthu, et al.

[15] Anind Dey, Jeffrey Hightower, Eyal de Lara, and Nigel Davies. 2009. Location-based services. IEEE Pervasive

Computing 9, 1 (2009), 11â€“12.

[16] Joy Dutta, Pradip Pramanick, and Sarbani Roy. 2018. Energy-efficient GPS usage in location-based applications. In

Information and Decision Sciences. Springer, 345â€“353.

[17] Alcides Fonseca, Rick Kazman, and Patricia Lago. 2019. A manifesto for energy-aware software. IEEE Software 36, 6

(2019), 79â€“82.

[18] Stefanos Georgiou, Stamatia Rizou, and Diomidis Spinellis. 2019. Software Development Lifecycle for Energy Efficiency:
Techniques and Tools. ACM Comput. Surv. 52, 4, Article 81 (Aug. 2019), 33 pages. https://doi.org/10.1145/3337773
[19] Shuai Hao, Ding Li, William GJ Halfond, and Ramesh Govindan. 2013. Estimating mobile application energy consumption
using program analysis. In Proceedings of the 2013 International Conference on Software Engineering. IEEE Press,
92â€“101.

[20] Henning HeitkÃ¶tter, Herbert Kuchen, and Tim A Majchrzak. 2015. Extending a model-driven cross-platform development

approach for business apps. Science of Computer Programming 97 (2015), 31â€“36.

[21] Henning HeitkÃ¶tter, Tim A Majchrzak, and Herbert Kuchen. 2013. Cross-platform model-driven development of mobile

applications with md2. In Proceedings of the 28th Annual ACM Symposium on Applied Computing. 526â€“533.

[22] Bernhard Hofmann-Wellenhof, Herbert Lichtenegger, and James Collins. 2012. Global positioning system: theory and

practice. Springer Science & Business Media.

[23] Mohammad Ashraful Hoque, Matti Siekkinen, Kashif Nizam Khan, Yu Xiao, and Sasu Tarkoma. 2015. Modeling,
profiling, and debugging the energy consumption of mobile devices. ACM Computing Surveys (CSUR) 48, 3 (2015),
1â€“40.

[24] Haosheng Huang, Georg Gartner, Jukka M Krisp, Martin Raubal, and Nico Van de Weghe. 2018. Location based

services: ongoing evolution and research agenda. Journal of Location Based Services 12, 2 (2018), 63â€“93.

[25] Mohamed Ibrahim and Moustafa Youssef. 2012. CellSense: An accurate energy-efficient GSM positioning system. IEEE

Transactions on Vehicular Technology 61, 1 (2012), 286â€“296.

[26] Xiaoping Jia and Christopher Jones. 2015. An approach for the automatic adaptation of domain-specific modeling

languages for model-driven mobile application development. In ICSOFT. Springer, 365â€“379.

[27] Dohee Kim, Soyoon Lee, and Hyokyung Bahn. 2016. An Adaptive Location Detection scheme for energy-efficiency of

smartphones. Pervasive and Mobile Computing 31 (2016), 67â€“78.

[28] Mikkel Baun KjÃ¦rgaard, Jakob Langdal, Torben Godsk, and Thomas ToftkjÃ¦r. 2009. Entracked: energy-efficient robust
position tracking for mobile devices. In Proceedings of the 7th international conference on Mobile systems, applications,
and services. ACM, 221â€“234.

[29] Christian Krupitzer, Felix Maximilian Roth, Sebastian VanSyckel, Gregor Schiele, and Christian Becker. 2015. A survey

on engineering approaches for self-adaptive systems. Pervasive and Mobile Computing 17 (2015), 184â€“206.

[30] Olivier Le Goaer and Sacha Waltham. 2013. Yet another DSL for cross-platforms mobile development. In Proceedings

of the First Workshop on the globalization of domain specific languages. 28â€“33.

[31] Kaisen Lin, Aman Kansal, Dimitrios Lymberopoulos, and Feng Zhao. 2010. Energy-accuracy trade-off for continuous
mobile device location. In Proceedings of the 8th international conference on Mobile systems, applications, and
services. ACM, 285â€“298.

[32] Mario Linares-VÃ¡squez, Gabriele Bavota, Carlos Bernal-CÃ¡rdenas, Massimiliano Di Penta, Rocco Oliveto, and Denys
Poshyvanyk. 2018. Multi-objective optimization of energy consumption of guis in android apps. ACM Transactions on
Software Engineering and Methodology (TOSEM) 27, 3 (2018), 1â€“47.

[33] Yepang Liu, Chang Xu, Shing-Chi Cheung, and Jian Lu. 2014. Greendroid: Automated diagnosis of energy inefficiency

for smartphone applications. IEEE Transactions on Software Engineering 1 (2014), 1â€“1.

[34] Yemao Man and Edith C-H Ngai. 2014. Energy-efficient automatic location-triggered applications on smartphones.

Computer Communications 50 (2014), 29â€“40.

[35] Irene Manotas, Christian Bird, Rui Zhang, David Shepherd, Ciera Jaspan, Caitlin Sadowski, Lori Pollock, and James
Clause. 2016. An empirical study of practitionersâ€™ perspectives on green software engineering. In Software Engineering
(ICSE), 2016 IEEE/ACM 38th International Conference on. IEEE, 237â€“248.

[36] Alex T Mariakakis, Souvik Sen, Jeongkeun Lee, and Kyu-Han Kim. 2014. Sail: Single access point-based indoor
localization. In Proceedings of the 12th annual international conference on Mobile systems, applications, and services.
ACM, 315â€“328.

[37] Andrea McIntosh, Safwat Hassan, and Abram Hindle. 2019. What can Android mobile app developers do about the

energy consumption of machine learning? Empirical Software Engineering 24, 2 (2019), 562â€“601.

[38] Rodrigo Morales, RubÃ©n Saborido, Foutse Khomh, Francisco Chicano, and Giuliano Antoniol. 2018. Earmo: an energy-

aware refactoring approach for mobile apps. IEEE Transactions on Software Engineering 44, 12 (2018), 1176â€“1206.

Manuscript submitted to ACM

eGEN: An Energy-saving Modeling Language and Code Generator for Location-sensing of Mobile Apps 27

[39] Manuel NÃºÃ±ez, Daniel Bonhaure, MagalÃ­ GonzÃ¡lez, and Luca Cernuzzi. 2020. A model-driven approach for the
development of native mobile applications focusing on the data layer. Journal of Systems and Software 161 (2020),
110489.

[40] Guadalupe Ortiz, Alfonso GarcÃ­a-de Prado, Javier Berrocal, and Juan HernÃ¡ndez. 2019. Improving Resource Consumption

in Context-Aware Mobile Applications through Alternative Architectural Styles. IEEE Access (2019).

[41] Thomas Olutoyin Oshin, Stefan Poslad, and Athen Ma. 2012. Improving the energy-efficiency of GPS based location
sensing smartphone applications. In 2012 IEEE 11th International Conference on Trust, Security and Privacy in
Computing and Communications. IEEE, 1698â€“1705.

[42] Jeongyeup Paek, Joongheon Kim, and Ramesh Govindan. 2010. Energy-efficient rate-adaptive GPS-based positioning
for smartphones. In Proceedings of the 8th international conference on Mobile systems, applications, and services.
ACM, 299â€“314.

[43] Jeongyeup Paek, Kyu-Han Kim, Jatinder P Singh, and Ramesh Govindan. 2011. Energy-efficient positioning for
smartphones using cell-id sequence matching. In Proceedings of the 9th international conference on Mobile systems,
applications, and services. ACM, 293â€“306.

[44] Candy Pang, Abram Hindle, Bram Adams, and Ahmed E Hassan. 2016. What do programmers know about software

energy consumption? IEEE Software 33, 3 (2016), 83â€“89.

[45] Abhinav Pathak, Abhilash Jindal, Y. Charlie Hu, and Samuel P. Midkiff. 2012. What is Keeping My Phone Awake?:
Characterizing and Detecting No-sleep Energy Bugs in Smartphone Apps. In Proceedings of the 10th International
Conference on Mobile Systems, Applications, and Services (Low Wood Bay, Lake District, UK) (MobiSys â€™12). ACM,
New York, NY, USA, 267â€“280. https://doi.org/10.1145/2307636.2307661

[46] Abhinav Pathak, Abhilash Jindal, Y Charlie Hu, and Samuel P Midkiff. 2012. What is keeping my phone awake?:
characterizing and detecting no-sleep energy bugs in smartphone apps. In Proceedings of the 10th international
conference on Mobile systems, applications, and services. ACM, 267â€“280.

[47] Rui Pereira, Tiago CarÃ§Ã£o, Marco Couto, JÃ¡come Cunha, JoÃ£o Paulo Fernandes, and JoÃ£o Saraiva. 2020. SPELLing out

energy leaks: Aiding developers locate energy inefficient code. Journal of Systems and Software 161 (2020), 110463.

[48] Rui Pereira, Marco Couto, Francisco Ribeiro, Rui Rua, JÃ¡come Cunha, JoÃ£o Paulo Fernandes, and JoÃ£o Saraiva. 2021.

Ranking programming languages by energy efficiency. Science of Computer Programming 205 (2021), 102609.

[49] Gustavo Pinto and Fernando Castor. 2017. Energy Efficiency: A New Concern for Application Software Developers.

Commun. ACM 60, 12 (2017), 68â€“75.

[50] Gustavo Pinto and Fernando Castor. 2017. Energy efficiency: a new concern for application software developers. Commun.

ACM 60, 12 (2017), 68â€“75.

[51] Ana Ribeiro, Joao F Ferreira, and Alexandra Mendes. 2021. EcoAndroid: An Android Studio plugin for developing

energy-efficient Java mobile applications. (2021).

[52] Per Runeson and Martin HÃ¶st. 2009. Guidelines for conducting and reporting case study research in software engineering.

Empirical software engineering 14, 2 (2009), 131.

[53] Albrecht Schmidt, Michael Beigl, and Hans-W Gellersen. 1999. There is more to context than location. Computers &

Graphics 23, 6 (1999), 893â€“901.

[54] Andreas Schuler and Gabriele Anderst-Kotsis. 2020. Characterizing energy consumption of third-party API libraries
using API utilization profiles. In Proceedings of the 14th ACM/IEEE International Symposium on Empirical Software
Engineering and Measurement (ESEM). 1â€“11.

[55] Diego Vaquero-Melchor, Javier Palomares, Esther Guerra, and Juan de Lara. 2017. Active domain-specific languages:
Making every mobile user a modeller. In 2017 ACM/IEEE 20th International Conference on Model Driven Engineering
Languages and Systems (MODELS). IEEE, 75â€“82.

[56] Robert-Andrei Voicu, Ciprian Dobre, Lidia Bajenaru, and Radu-Ioan Ciobanu. 2019. Human physical activity recognition

using smartphone sensors. Sensors 19, 3 (2019), 458.

[57] Teng Xi, Wendong Wang, Edith C-H Ngai, Zheng Song, Ye Tian, and Xiangyang Gong. 2015. Energy-efficient collaborative
localization for participatory sensing system. In Global Communications Conference (GLOBECOM), 2015 IEEE.
IEEE, 1â€“6.

[58] Zheng Yang, Chenshu Wu, Zimu Zhou, Xinglin Zhang, Xu Wang, and Yunhao Liu. 2015. Mobility increases localizability:
A survey on wireless indoor localization using inertial sensors. ACM Computing Surveys (Csur) 47, 3 (2015), 54.
[59] Zhenyun Zhuang, Kyu-Han Kim, and Jatinder Pal Singh. 2010. Improving energy efficiency of location sensing on
smartphones. In Proceedings of the 8th international conference on Mobile systems, applications, and services. ACM,
315â€“330.

Manuscript submitted to ACM

