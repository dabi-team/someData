2
2
0
2

l
u
J

2
1

]

O
L
.
s
c
[

1
v
8
7
6
5
0
.
7
0
2
2
:
v
i
X
r
a

Symbolic Runtime Veriﬁcation for Monitoring
under Uncertainties and Assumptions

Hannes Kallwies1

, Martin Leucker1

, and César Sánchez2

1 University of Lübeck, Lübeck, Germany
2 IMDEA Software Institute, Madrid, Spain

Abstract. Runtime Veriﬁcation deals with the question of whether a run
of a system adheres to its speciﬁcation. This paper studies runtime veriﬁ-
cation in the presence of partial knowledge about the observed run, par-
ticularly where input values may not be precise or may not be observed at
all. We also allow declaring assumptions on the execution which permits
to obtain more precise verdicts also under imprecise inputs. To this end,
we show how to understand a given correctness property as a symbolic
formula and explain that monitoring boils down to solving this formula it-
eratively, whenever more and more observations of the run are given. We
base our framework on stream runtime veriﬁcation, which allows to express
temporal correctness properties not only in the Boolean but also in richer
logical theories. While in general our approach requires to consider larger
and larger sets of formulas, we identify domains (including Booleans and
Linear Algebra) for which pruning strategies exist, which allows to monitor
with constant memory (i.e. independent of the length of the observation)
while preserving the same inference power as the monitor that remembers
all observations. We empirically exhibit the power of our technique using a
prototype implementation under two important cases studies: software for
testing car emissions and heart-rate monitoring.

1

Introduction

In this paper we study runtime veriﬁcation (RV) for imprecise and erroneous inputs,
and describe a solution—called symbolic monitoring—that can exploit assumptions
about the input and the system under analysis. Runtime veriﬁcation is a dynamic
veriﬁcation technique in which a given run of a system is checked against a spec-
iﬁcation, typically a correctness property (see [13,22,1]). In online monitoring a
monitor is synthesized from the given correctness property, which attempts to pro-
duce a verdict incrementally from the input trace. Originally, variants of LTL [25]
tailored to ﬁnite runs have been employed in RV to formulate properties (see [3] for
a comparison on such logics). However, since RV requires to solve a variation of the
word problem and not the harder model-checking problem, richer logics than LTL
have been proposed that allow richer data and verdicts [10,14]. Lola [9] proposes
stream runtime veriﬁcation (SRV) where monitors are described declaratively and
compute output streams of verdicts from inputs streams (see also [20,12]). The
development of this paper is based on Lola.

 
 
 
 
 
 
2

Hannes Kallwies, Martin Leucker, and César Sánchez

In ld : Real
Def acc := acc[−1|0] + ld [now ] − ld [−3|0]
Def ok := (acc[now ] ≤ 15)

3

3

tt

4

7

tt

5

12

tt

7

16

ﬀ

(a) A Speciﬁcation

(b) Monitor run with perfect information

[1,5]

4

5

7

[1,5]

[5,9] [10,14] [12,20]

tt

tt

tt

?

(c) Interval abstraction

ld 0

ld 0

tt

4

5

ld 0+4

ld 0+9

tt

tt

7

16

ﬀ

(d) Symbolic Monitor

Fig. 1. An example speciﬁcation (a) and three monitors: (b) with perfect observability,
(c) with an interval abstract domain, (d) a symbolic monitor developed in this paper.
The symbolic monitor is enriched with the additional constraint that 1 ≤ ld 0 ≤ 5.

Example 1. Fig. 1(a) shows a Lola speciﬁcation with ld as input stream (the load of
a CPU), acc as an output stream that represents the accumulated load, computed
by adding the current value of ld and subtracting the third last value. Finally, ok
checks whether acc is below 15. The expression acc[−1|0] denotes the value of acc
in the previous time point and 0 as default value if no previous time point exists.
Such a speciﬁcation allows a direct evaluation strategy whenever values on the
input streams arrive. If, for example, ld = 3 in the ﬁrst instant, acc and ok evaluate
to 3 and tt, respectively. Reading subsequently 4, 5, 7 results in 7, 12, 16 for acc and
a violation is identiﬁed on stream ok . This is shown in Fig. 1(b).

A common obstacle in runtime veriﬁcation is that in practice sometimes input
values are not available or not given precisely, due to errors in the underlying
logging functionality or technical limitations of sensors. In Fig. 1(c) the ﬁrst value
on ld is not obtained (but we assume that all values of ld are between 1 and 5).
One approach is to use interval arithmetic, which can be easily encoded as a rich
domain in Lola, and continue the computation when obtaining 4, 5 and 7. However,
at time 4 the monitor cannot know for sure whether ok has been violated, as the
interval [12, 20] contains 15. This approach based on abstract interpretation [8]
was pursued in [21] and suﬀers from this limitation. If the unknown input on ld
is denoted symbolically by ld 0 we still deduce that ok holds at time points 1 to 3.
For time point 4, however, the symbolic representation acc4 = acc3 + 7 − ld 0 =
ld 0 + 9 + 7 − ld 0 = 16 allows to infer that ok is clearly violated! This is shown in
(cid:117)(cid:116)
Fig. 1(d).

Example 1 illustrates the ﬁrst insight pursued in this paper: that Symbolic moni-
toring is more precise than monitoring using abstract domains.

Clearly, an inﬁnite symbolic unfolding of a speciﬁcation and all the assumptions
with subsequent deduction is practically infeasible. Therefore, we perform online
monitoring unfolding the speciﬁcation as time increases. We show that a monitor
based on deducing verdicts using this partial symbolic unfolding is both sound and
perfect in the sense that the monitor only produces correct verdicts and these are
as precise verdicts as possible with the information provided. Symbolic monitoring

Symbolic Runtime Veriﬁcation under Uncertainties and Assumptions

3

done in this straightforward way, however, comes at a price: the unfolded speciﬁ-
cation grows as more unknowns and their inter-dependencies become part of the
symbolic unfolding. For example, in the run in Fig. 1(d) as more unknown ld values
are received, more variables ld i will be introduced, which may make the size of the
symbolic formula dependent on the trace length. We show that for certain logical
theories, the current verdict may be still be computed even after summarizing the
history into a compact symbolic representation, whose size is independent of the
trace length. For other theories, preserving the full precision of symbolic moni-
toring requires an amount of memory that can grow with the trace length. More
precisely, we show that for the theories of Booleans and of Linear Algebra, bounded
symbolic monitors exist while this is not the case for the combined theory, which
is the second insight presented in this paper.

We have evaluated our approach on two realistic cases studies, the Legal Driving
Cycle [18,5] and an ECG heartbeat analysis (following the Lola implementation
in [11], see also [24,26]) which empirically validate our symbolic monitoring ap-
proach, including constant monitoring on long traces. When intervals are given for
unknown values, our method provides precise answers more often than previous
approaches based on interval domains [21]. Especially in the ECG example, these
methods are unable to recover once the input is unknown for even a short time,
but our symbolic monitors recover and provide again precise results, even when
the input was unknown for a larger period.

Related Work. Monitoring LTL for traces with mutations (errors) is studied in [16]
where properties are classiﬁed according to whether monitors can be built that are
resilient against the mutation. However, [16] only considers Boolean verdicts and
does not consider assumptions. The work in [21] uses abstract interpretation to
soundly approximate the possible verdict values when inputs contain errors for the
SRV language TeSSLa [7].

Calculating and approximating the values that programs compute is central
to static analysis and program veriﬁcation. Two traditional approaches are sym-
bolic execution [17] and abstract interpretation [8] which frequently require over-
approximations to handle loops. In monitoring, a step typically does not contain
loops, but the set of input variables (unlike in program analysis) grows. Also, a
main concern of RV is to investigate monitoring algorithms that are guaranteed to
execute with constant resources. Works that incorporate assumptions when moni-
toring include [15,6,19] but uncertainty is not considered in these works, and ver-
dicts are typically Boolean. Note that bounded model checking [4] also considers
bounded unfoldings, but it does not solve the problem of building monitors of
constant memory for successive iterations.

In summary, our contributions are: (1) A symbolic monitoring algorithm that
dynamically unfolds the speciﬁcation, collects precise and imprecise input readings,
and instantiates assumptions generating a conjunction of formulas. This represen-
tation can be used to deduce verdicts even under uncertainty, to precisely recover
automatically for example under windows of uncertainty, and even to anticipate
verdicts. (2) A pruning method for certain theories (Booleans and Linear Algebra)

4

Hannes Kallwies, Martin Leucker, and César Sánchez

that guarantees bounded monitoring preserving the power to compute verdicts.
(3) A prototype implementation and empirical evaluation on realistic case studies.

All missing proofs appear in the appendix.

2 Preliminaries

We use Lola [9] to express our monitors. Lola uses ﬁrst-order sorted theories to
build expressions. These theories are interpreted in the sense that every symbol is
a both constructor to build expressions, and an evaluation function that produces
values from the domain of results from values from the domains of the arguments.
All sorts of all theories that we consider include the = predicate.

A synchronous stream s over a non-empty data domain D is a function s :
SD := T → D assigning a value of D to every element of T (timestamp). We
consider inﬁnite streams (T = N) or ﬁnite streams with a maximal timestamp tmax
(T = [0 . . . tmax]). For readability we denote streams as sequences, so s = (cid:104)1, 2, 4(cid:105)
stands for s : {1, 2, 3} → N with s(0) = 1, s(1) = 2, s(2) = 4. A Lola speciﬁcation
describes a transformation from a set of input streams to a set of output streams.

Syntax. A Lola speciﬁcation ϕ = (I, O, E) consists of a set I of typed variables
that denote the input streams, a set O of typed variables that denote the output
steams, and E which assigns to every output stream variable y ∈ O a deﬁning
expression Ey. The set of expressions over I ∪ O of type D is denoted by ED and is
recursively deﬁned as: ED = c | s[o|c] | f (ED1 , ..., EDn) | ite(EB, ED, ED), where c is
a constant of type D, s ∈ I ∪ O is a stream variable of type D, o ∈ Z is an oﬀset and
f a total function D1 × · · · × Dn → D (ite is a special function symbol to denote
if-then-else). The intended meaning of the oﬀset operator s[o|c] is to represent the
stream that has at time t the value of stream s at t+o, and value c used if t+o /∈ T.
A particular case is when the oﬀset is o = 0 in which case c is not needed, which we
shorten by s[now ]. Function symbols allow to build terms that represent complex
expressions. The intended meaning of the deﬁning equation Ey for output variable
y is to declaratively deﬁne the values of stream y in terms of the values of other
streams.

·
(cid:74)

(cid:75)

Semantics. The semantics of a Lola speciﬁcation ϕ is a mapping from input to
output streams. Given a tuple of concrete input streams (Σ = (σ1, . . . , σn) ∈ SD1 ×
· · · × SDn) corresponding to input stream identiﬁer s1, . . . , sn and a speciﬁcation ϕ
the semantics of an expression

Σ,ϕ : ED → SD is iteratively deﬁned as:

–

–

–

–

(cid:74)

(cid:74)

(cid:74)

(cid:74)

Σ,ϕ(t) = c

c
(cid:75)




(cid:75)



s[o|c]

Σ,ϕ(t + o)

Σ,ϕ(t) =
(cid:75)

σi(t + o)
e
(cid:74)
c
Σ,ϕ(t), . . . ,
e1
Σ,ϕ(t) = f (
(cid:40)
(cid:75)
(cid:74)
(cid:75)
if
Σ,ϕ(t)
e2
ite(e1, e2, e3)
(cid:75)
(cid:74)
if
Σ,ϕ(t)
e3
(cid:75)
(cid:75)
(cid:74)

if t + o ∈ T and s = si ∈ I (input stream)
if t + o ∈ T and Es = e (output stream)
otherwise
en
(cid:74)
e1
(cid:74)
e1
(cid:74)

Σ,ϕ(t))
(cid:75)
Σ,ϕ(t) = tt
(cid:75)
Σ,ϕ(t) = ﬀ
(cid:75)

f (e1, ..., en)

Σ,ϕ(t) =

Symbolic Runtime Veriﬁcation under Uncertainties and Assumptions

5

The semantics of ϕ is a map (
) deﬁned as
(cid:74)
Σ,ϕ is well-deﬁned
Σ,ϕ, . . . ,
(σ1, ..., σn) = (
ϕ
(cid:74)
(cid:75)
(cid:74)
(cid:75)
if the recursive evaluation above has no cycles. This acyclicity can be easily checked
statically (see [9]).

: (SD1 × · · · × SDn ) → (SD(cid:48)
ϕ
(cid:75)
e(cid:48)
m

Σ,ϕ). The evaluation map

× · · · × SD(cid:48)
m

e(cid:48)
1

(cid:75)

(cid:74)

(cid:74)

(cid:75)

·

1

In online monitoring monitors receive the values incrementally. The very eﬃ-
ciently monitorable fragment of Lola consists of speciﬁcations where all oﬀsets are
negative or 0 (without transitive 0 cycles). It is well-known that the very eﬃciently
monitorable speciﬁcations (under perfect information) can be monitored online in
a trace length independent manner. In the rest of the paper we also assume that all
Lola speciﬁcations come with −1 or 0 oﬀsets. Every speciﬁcation can be translated
into such a normal form by introducing additional streams (ﬂattening).

In this paper we investigate online monitoring under uncertainty for three spe-

cial fragments of Lola, depending on the data theories used:

– Propositional Logic (LolaB): The data domain of all streams is the Boolean

domain D = B = {tt, ﬀ } and available functions are ∧, ¬.

– Linear Algebra (LolaLA): The data domain of all streams are real numbers
D = R and every stream deﬁnition has the form c0 + c1 ∗ s0[o1|d1] + · · · + cn ∗
sn[on|dn] where ci are constants.

– Mixed (LolaB/LA): The data domain is B or R. Every stream deﬁnition is
either contained in the Propositional Logic fragment extended by the functions
<, ≤, = or in the Linear Algebra fragment.

3 A Framework for Symbolic Monitoring

In this section we introduce a general framework for monitoring using symbolic
computation, where the speciﬁcation and the information collected by the moni-
tor (including assumptions and precise and imprecise observations) are presented
symbolically.

3.1 Symbolic Expressions

Consider a speciﬁcation ϕ = (I, O, E). We will use symbolic expressions to capture
the relations between the diﬀerent streams at diﬀerent points in time. We introduce
the instant variables xt for a given stream variable x ∈ I ∪ O and instant t ∈ T.
The type of xt is that of x. Considering Example 1, ld 3 represents the real value
that corresponds to the input stream ld at instant 3 which is 7. The set of instant
variables is V = (I ∪ O) × T.

Deﬁnition 1 (Symbolic Expression). Let ϕ be a speciﬁcation and A a set of
variables that contains all instant variables (that is V ⊆ A), the set of symbolic
expressions D is the smallest set containing (1) all constants c and all symbols in
a ∈ A, (2) all expressions f (t1, . . . , tn) where f is a constructor symbol of type
D1 × · · · × Dn → D and ti are elements of D of type Di.

We use ExprD
when it is clear from the context).

ϕ(A) for the set of symbolic expressions of type D (and drop ϕ and A

6

Hannes Kallwies, Martin Leucker, and César Sánchez

Example 2. Consider again Example 1. The symbolic expression acc3 +ld 4, of type
R, represents the addition of the load at instant 4 and the accumulator at instant
3. Also, acc4 = acc3 + ld 4 is a predicate (that is, a B expression) that captures
the value of acc at instant 4. The symbolic expression ld 1 = 4 corresponds to the
reading of the value 4 for input stream ld at instant 1. Finally, 1 ≤ ld 0 ∧ ld 0 ≤ 5
(cid:117)(cid:116)
corresponds to the assumption at time 0 that ld has value between 1 and 5.

3.2 Symbolic Monitor Semantics

We deﬁne the symbolic semantics of a Lola speciﬁcation ϕ = (I, O, E) as the
expressions that result by instantiating the deﬁning equations E.

·
(cid:74)

ϕ : ED → T →
(cid:75)

sym : T → 2ExprB

ϕ deﬁned

Deﬁnition 2 (Symbolic Monitor Semantics). The map
ExprD
–
–

ϕ(t) = c for constants, and
ϕ(t))
ϕ(t), . . . ,
ϕ(t) = c otherwise.

c
(cid:75)
ϕ(t) = f (
ϕ(t) = st+o if t + o ∈ T, or

ϕ is deﬁned as
f (e1, . . . , en)
(cid:75)
s[o|c]
(cid:75)

en
(cid:75)
(cid:74)
s[o|c]
(cid:75)

The symbolic semantics of a speciﬁcation ϕ is the map
ϕ(t) |
as

for every y ∈ O}.

sym = {yt =
t

e1
(cid:74)

·
(cid:75)

(cid:74)

Ey

(cid:74)
(cid:74)

(cid:75)

(cid:74)

(cid:74)

ϕ
(cid:75)

(cid:74)
A slight modiﬁcation of the symbolic semantics allows to obtain equations whose

(cid:74)

(cid:75)

right hand sides only have input instant variables:
if t + o ∈ T and s ∈ I
(t + o) if t + o ∈ T and s ∈ O

ϕ(t) = st+o
es
ϕ(t) =
ϕ(t) = c otherwise

(cid:74)

(cid:75)

–
–
–

s[o|c]
(cid:75)
s[o|c]
(cid:75)
s[o|c]
(cid:75)

(cid:74)
(cid:74)
(cid:74)

We call this semantics the symbolic unrolled semantics, which corresponds to what
would be obtained by performing equational reasoning (by equational substitution)
in the symbolic semantics.

Example 3. Consider again the speciﬁcation ϕ in Example 1. The ﬁrst four ele-
ments of

sym are (after simpliﬁcations like 0 + x = x etc.):
ϕ
(cid:75)
0
acc0 = ld 0

acc1 = acc0 + ld 1 acc2 = acc1 + ld 2 acc3 = acc2 + ld 3 − ld 0

1

3

2

(cid:74)

ok 0 = acc0 ≤ 15 ok 1 = acc1 ≤ 15 ok 2 = acc2 ≤ 15

ok 3 = acc3 ≤ 15

Using the unrolled semantics the equations for ok would be, at time 0, ok 0 =
ld 0 ≤ 15, and at time 1, ok 1 = ld 0 + ld 1 ≤ 15. In the unrolled semantics all
(cid:117)(cid:116)
equations contain only instant variables that represent inputs.

Recall that the denotational semantics of Lola monitor speciﬁcations in Sec-
tion 2 maps every tuple of input streams into a tuple of output streams, that is
ϕ
. The symbolic semantics also has a
(cid:75)
(cid:74)
denotational meaning even without receiving the input stream, deﬁned as follows.

: SD1 × · · · × SDn → SD(cid:48)

× · · · × SD(cid:48)
m

1

Deﬁnition 3 (Denotational semantics). Let ϕ = (I, O, E) be a speciﬁcation
with I = (x1, . . . , xn) and O = (y1, . . . , ym). The denotational semantics of a set
of equations E ⊆ ExprB
den ⊆ SD1 × · · · × SDn × SD(cid:48)
ϕ

× · · · × SD(cid:48)
m

is:

E

1

E

(cid:74)

(cid:75)

(cid:74)

(cid:75)
1, . . . , σ(cid:48)
den = {(σ1, . . . , σn, σ(cid:48)
1 = σ1(t), . . . , xt
{xt

for every e ∈ E

m) |
n = σn(t), yt

1 = σ(cid:48)

1(t), . . . , yt

m = σ(cid:48)

m(t)} |= e}

Symbolic Runtime Veriﬁcation under Uncertainties and Assumptions

7

Using the previous deﬁnition,
(cid:74)
streams of inputs and outputs that satisfy the speciﬁcation ϕ up to time t.

den corresponds to all the tuples of
(cid:75)

ϕ
(cid:75)

i≤t

(cid:74)

i
sym

(cid:83)

A Symbolic Encoding of Inputs, Constraints and Assumptions. Input
readings can also be deﬁned symbolically as follows. Given an instant t, an input
stream variable x and a value v, the expression xt = v captures the precise reading
of v at t on x. Imprecise readings can also be encoded easily. For example, if at
instant 3 an input of value 7 for ld is received by a noisy sensor (consider a 1 unit
of tolerance), then 6 ≤ ld 3 ≤ 8 represents the imprecise reading.

Assumptions are relations between the variables that we assume to hold at all
positions, which can be encoded as stream expressions of type B. For example, the
assumption that the load is always between 1 and 10 is 1 ≤ ld [now ] ≤ 10. Another
example, ld [−1|0] + 1 ≥ ld [now ] which encodes that ld cannot increase more than
1 per unit of time. We use A for the set of assumptions associated with a Lola
speciﬁcation ϕ (which are a set of stream expressions of type B over I ∪ O).

3.3 A Symbolic Monitoring Algorithm

5

4

(cid:74)

(cid:75)

ϕ;

At
for inputs x};

Alg. 1: Online Symbolic Monitor for ϕ

1 t ← 0 and E ← ∅;
2 while t ∈ T do
ϕ
3
(cid:75)

Based on the previous deﬁnitions we develop our symbolic monitoring algorithm
shown in Alg. 1. Line 3 instantiates the new equations and assumptions from the
speciﬁcation for time t. Line 4 incorporates the readings (perfect or imperfect).
Line 5 performs evaluations and simpliﬁcations, which is dependent on the partic-
ular theory. In the case of past-speciﬁcations with perfect information this step boils
down to substitution and evaluation. Line 6 produces the output of the monitor.
Again, this is application depen-
dent. In the case of past speciﬁca-
tions with perfect information the
output value will be computed with-
out delay and emitted in this step.
In the case of B outputs with im-
perfect information, an SMT solver
can be used to discard a verdict. For
example, to determine the value of
ok at time t, the verdict tt can be
discarded if ∃ ∗ .okt is UNSAT, and
the verdict ﬀ can be discarded if ∃ ∗ .¬okt is UNSAT. For richer domains spe-
ciﬁc reasoning can be used, like emitting lower and upper bounds or the set of
constraints deduced. Finally, Line 7 eliminates constraints that will not be neces-
sary for future deductions and performs variable renaming and summarization to
restrict the memory usage of the monitor (see Section 4). For past speciﬁcations
with perfect information, after step 5 every equation will be evaluated to yt = v
and the pruning will remove from E all the values that will never be accessed
again. Example 3 in Appendix A illustrates how the algorithm handles imperfect
information and pruning for the speciﬁcation of Example 1.

t
sym ∪
E ← E ∪
(cid:74)
E ← E ∪ {xt = v |
Evaluate and Simplify;
Output;
Prune;
t ← t + 1 ;

7

8

6

The symbolic monitoring algorithm generalizes the concrete monitoring algo-
rithm by allowing to reason about uncertain values, while it still obtains the same

8

Hannes Kallwies, Martin Leucker, and César Sánchez

results and performance under certainty. Concrete monitoring allows to monitor
with constant amount of resources speciﬁcations with bounded future references
when inputs are known with perfect certainty.

Symbolic monitoring, additionally, allows to handle uncertainties and assump-
tions, because the monitor stores equations that include variables that capture the
unknown information, for example the unknown input values. We characterize a
symbolic monitor as a step function M : 2Expr
that transforms expres-
sions into expressions. At a given instant t the monitor collects readings ψt ∈ Exprϕ
about the input values and applies the step function to the previous information
and the new information. Given a sequence of input readings ψ1, ψ2 . . . we use
M 0 = M (ψ0) and M i+1 = M (M i ∪ ψi+1) for the sequence of monitor states
reached by the repeated applications of M . We use Φt = ∪i≤t(
ϕ ∪ ψi)
(cid:75)
(cid:74)
(cid:74)
for the formula that represents the unrolling of the speciﬁcation and the current
assumptions together with the knowledge about inputs collected up-to t.

ϕ → 2Expr

i
sym ∪

ϕ
(cid:75)

Ai

ϕ

Deﬁnition 4 (Sound and Perfect monitoring). Let ϕ be a speciﬁcation, M
a monitor for ϕ, ψ1, ψ2 . . . a sequence of input observations, and M 1, M 2 . . . the
monitor states reached after repeatedly applying M . Consider an arbitrary predicate
α involving only instant variables xt at time t.

– M t is sound if whenever M t |= α then Φt |= α.
– M t is perfect if it is sound and if Φt |= α then M t |= α.

Note that soundness and perfectness is deﬁned in terms of the ability to infer
predicates that only involve instant variables at time t, so the monitor is allowed
to eliminate, rename or summarize the rest of the variables. It is trivial to extend
this deﬁnition to expressions α that can use instant variables xt(cid:48)
with (t−d) ≤ t(cid:48) ≤ t
for some constant d. If a monitor is perfect in this extended deﬁnition it will be
able to answer questions for variables within the last d steps.

The version of the symbolic algorithm presented in Alg. 1 that never prunes
(removing line 7) and computes at all steps Φt is a sound and perfect monitor.
However, the memory that the monitor needs grows without bound if the number
of uncertain items also grows without bound. In the next section we show that
(1) trace length independent perfect monitoring under uncertainty is not possible
in general, even for past only speciﬁcations and (2) we identify concrete theories,
namely Booleans and Linear Algebra and show that these theories allow perfect
monitoring with constant resources under unbounded uncertainty.

4 Symbolic Monitoring at Work

Example 4. Consider the Lola speciﬁcation on the left, where the Real input
stream ld indicates the current CPU load and the Boolean input stream usra
indicates if the currently active user is user A. This speciﬁcation checks whether the
accumulated load of user A is at most 50% of the total accumulated load. Consider
the inputs ld = (cid:104)?, 10, 4, ?, ?, 1, 9, . . . (cid:105), usr a = (cid:104)ﬀ , ﬀ , ﬀ , tt, tt, tt, ﬀ , . . . (cid:105) from 0 to 6.

Symbolic Runtime Veriﬁcation under Uncertainties and Assumptions

9

acc := acc[−1|0] + ld[now ]
acca := acca[−1|0] + ite(usr a[now ],

ld [now ], 0)

ok := acca ≤ 0.5 ∗ acc

Also, assume that at every instant t,
0 ≤ ldt ≤ 10. At instant 6 our monitor-
ing algorithm would yield the symbolic
constraints (acc6 = 24 + ld0 + ld3 + ld4)
a = 1 + ld3 + ld4) for acc6 and
and (acc6
a, and the additional (0 ≤ ld0 ≤ 10 ∧ 0 ≤ ld3 ≤ 10 ∧ 0 ≤ ld4 ≤ 10). An
acc6
existential query to an SMT solver allows to conclude that ok 6 is true since acc6
a
is at most 21 but then acc6 is 44. However, every unknown variable from the input
will appear in one of the constraints stored and will remain there during the whole
(cid:117)(cid:116)
monitoring process.
When symbolic computation is used in static analysis, it is not a common
concern to deal with a growing number of unknowns as usually the number of
inputs is ﬁxed a-priori. In contrast, a goal in RV is to build online monitors that
are trace-length independent, which means that the calculation time and memory
consumption of a monitor stays below a constant bound and does not increase
with the received number of inputs. In Example 4 above this issue can be tackled
by rewriting the constraints as part of the monitor’s pruning step using n ← ld0,
m ← (ld3 + ld4) to obtain (acct = 24 + n + m), (acct
a = 1 + m) and (0 ≤ n ≤
10) ∧ (0 ≤ m ≤ 20). From the rewritten constraints it can still be deduced that
acc6
a ≤ 0.5 ∗ acc6. Note also that every instant variable in the speciﬁcation only
refers to previous instant variables. Thus for all t ≥ 7, there is no direct reference
to either ld3 or ld4. Variables ld3 and ld4 are, individually, no longer relevant for
the verdict and it does not harm to denote ld3 + ld4 by a single variable m. We
call this step of rewriting pruning (of non-relevant variables).

Let Ct ⊆ ExprB

ϕ be the set of constraints maintained by the monitor that encode
its knowledge about inputs and assumptions for the given speciﬁcation. In general,
pruning is a transformation of a set of constraints Ct into a new set C(cid:48)t requiring
less memory, but is still describing the same relations between the instant variables:
Deﬁnition 5 (Pruning strategy). Let C ⊆ ExprB be a set of propositions over
variables A and R = {r1, . . . , rn} ⊆ A the subset of relevant variables. We use
|C| for a measure on the size of C. A pruning strategy P : 2ExprB
is
a transformation such that for all C ∈ ExprB, |P(C)| ≤ |C|. A Pruning strategy
P : 2B → 2B is called
– sound, whenever for all C ⊆ ExprB,
R ⊆
C
– perfect, whenever for all C ⊆ ExprB,
(cid:75)
(cid:74)
R =
C
(cid:75)
(cid:74)
where
R = {(v1, . . . , vn)|(r1 = v1 ∧ · · · ∧ rn = vn) |= C} is the set of all value
tuples for R that entail the constraint set C. We say that the pruning strategy is
constant if for all C ⊆ ExprB : |P(C)| ≤ c for a constant c ∈ N.

R,
P(C)
(cid:75)
(cid:74)
R,
P(C)
(cid:75)
(cid:74)

→ 2ExprB

C

(cid:75)

(cid:74)

A monitor that exclusively stores a set Ct for every t ∈ T is called a constant-

memory monitor if there is a constant c ∈ N such that for all t, |Ct| ≤ c.

Previously we deﬁned an online monitor M as a function that iteratively maps
sets of expressions to sets of expressions. Clearly, the amount of information to
maintain grows unlimited if we allow the monitor to receive constraints that contain
information of an instant variable at time t at any other time t(cid:48). Consequently, we
ﬁrst restrict our attention to atemporal monitors, deﬁned as those which receive

10

Hannes Kallwies, Martin Leucker, and César Sánchez

proposition sets that only contain instant variables of the current instant of time.
Atemporal monitors cannot handle assumptions like ld[−1|0] ≤ 1.1 ∗ ld[now ]. At
the end of this section we will extend our technique to monitors that may refer n
instants to the past.

Theorem 1. Given a speciﬁcation ϕ and a constant pruning strategy P for ExprB
ϕ,
there is an atemporal constant-memory monitor Mϕ s.t.

– Mϕ is sound if the pruning strategy is sound.
– Mϕ is perfect if the pruning strategy is perfect.

Yet we have not given a complexity measure for our constraint sets. For our ap-
proach we use the number of variables and constants in the constraints, that is |C| =
(cid:80)
ϕ∈C |ϕ| and |c| = 1, |v| = 1, |f (e1, . . . , en)| = |e1| + · · · + |en|, |ite(e1, e2, e3)| =
|e1| + |e2| + |e3| for a constant c and an atomic proposition v.

4.1 Application to Lola fragments

We describe now perfect pruning strategies for LolaB and LolaLA. For LolaB/LA
we will show that no such perfect pruning strategy exists but present a sound and
constant pruning strategy.

LolaB: First we consider the fragment LolaB where all input and output streams,
constants and functions are of type Boolean. Consequently, constraints given to
the monitor only contain variables, constants and functions of type Boolean.

Example 5. Consider the following speciﬁcation (where all inputs are uncertain,
⊕ denotes exclusive or) shown on the left. The unrolled semantics, shown on the
right, indicates that ok is always true.

a := a[−1|ﬀ ] ⊕ x[now ]
b := b[−1|tt] ⊕ x[now ]

ok := a[now ] ⊕ b[now ]

2

0

1

x0 x0 ⊕ x1

. . .
x0 ⊕ x1 ⊕ x2 x0 ⊕ x1 ⊕ x2 ⊕ x3 . . .
¬x0 ¬x0 ⊕ x1 ¬x0 ⊕ x1 ⊕ x2 ¬x0 ⊕ x1 ⊕ x2 ⊕ x3 . . .
. . .
tt

tt

tt

tt

3

a1
b1
ok 1

(x0, x1) 00 01 10 11
ﬀ tt tt ﬀ
tt ﬀ ﬀ tt
tt tt tt tt

However, the Boolean formulas maintained internally by the monitor are contin-
uously increasing. Note that at time 1 the possible combinations of (a1, b1, ok 1)
are (ﬀ , tt, tt) and (tt, ﬀ , tt), as shown below (left). By eliminating duplicates from
this table we obtain another table with two
columns which can be expressed by formu-
las over a single, fresh variable v1 (as shown
on the right). From this table we can directly
infer the new formulas a1 = v1, b1 = ¬v1,
ok 1 = tt, which preserve the condensed infor-
mation that a1 and b1 are opposites. We can use these new formulas for further
calculation. At time 2, a2 = v1 ⊕ x2, b1 = ¬v1 ⊕ x2 which we rewrite as a2 = v2,
b1 = ¬v2 again concluding ok 1 = tt. This illustrates how the pruning guarantees
a constant-memory monitor. Note that this monitor will be able to infer at every
(cid:117)(cid:116)
step that ok is tt even without reading any input.

v1 0 1
a1 ﬀ tt
b1 tt ﬀ
ok 1 tt tt

Symbolic Runtime Veriﬁcation under Uncertainties and Assumptions

11

The strategy from the example above can be generalized to a pruning strategy.
Let R = {r1, . . . , rm} be the set of relevant variables (in our case the output
variables st
i) and V = {s1, . . . , sn} ∪ R all variables (in our case input variables and
fresh variables from previous pruning applications). Let C be a set of constraints
over r1, . . . , rm, s1, . . . , sm, which can be rewritten as a Boolean expression γ by
conjoining all constraints.

The method generates a value table T which includes as columns all value
combinations of (v1, . . . , vm) for (r1, . . . , rm) such that (r1 = v1)∧· · ·∧(rm = vm) |=
γ. Then it builds a new constraint set C(cid:48) with an expression ri = ψi(v1, . . . , vk)
for every 1 ≤ i ≤ m over k fresh variables, where the ψi are generated from the
rows of the value table. The number of variables is k = (cid:100)log(c)(cid:101) with c being the
number of columns in the table (i.e. combinations of ri satisfying γ). This method
is the LolaB pruning strategy which is perfect. By Theorem 1 this allows to build
a perfect atemporal constant-memory monitor for LolaB.

Lemma 1. The LolaB pruning strategy is perfect and constant.

LolaLA: The same idea used for LolaB can be adapted to Linear Algebra.

Example 6. Consider the speciﬁcation on the left. The main idea is that acca
accumulates the load of CPU A (as in-
dicated by ld a), and similarly accb accu-
mulates the load of CPU B (as indicated
by ld b). Then, total keeps the average of
ld a and ld b. The unrolled semantics is

acca := acca[−1|0] + ld a[now ]
accb := accb[−1|0] + ld b[now ]
total := total [−1|0] + 1

2 (ld a[now ]+
ld b[now ])

0
ld 0
a
ld 0
b
2 (ld 0
1

1
ld 0
ld 0
2 ((ld 0

a + ld 1
a
b + ld 1
b
a +ld 0

2
ld 0
ld 0
2 ((ld 0

a + ld 1
b + ld 1

a + ld 2
a
b + ld 2
b
b) + (ld 1

a + ld 0

a +ld 0

b) 1

b)+(ld 1

a +ld 1

b)) 1

a + ld 1

b) + (ld 2

a + ld 2

. . .
. . .
. . .
b)) . . .

a, acc1

Again, the formulas maintained during monitoring are increasing. The formulas
at 0 cannot be simpliﬁed, but at 1, ld 0
a have exactly the same inﬂuence
b, total 1) as matrix mul-
on acc1
tiplication shown below on the left. The matrix in the middle just contains two
linearly independent vectors. Hence the system of equations can be equally written
as shown in the right, over two fresh variables u1, v1:

b and total . To see this consider (acc1

a and ld 1

a, acc1





acc1
a
acc1
b
total 1





 =



1 0 1 0
0 1 0 1
1
1
1
1
2
2
2
2



 ∗













ld 0
a
ld 0
b
ld 1
a
ld 1
b





acc1
a
acc1
b
total 1





 =



1 0
0 1
1
1
2
2



 ∗

(cid:19)

(cid:18) u1
v1

The rewritten formulas then again follow directly from the matrix. Repeating the
application at all times yields:

12

Hannes Kallwies, Martin Leucker, and César Sánchez

0
ld 0
a
ld 0
b
a+ld 0
ld 0
2

b

1
ld 0
ld 0
(ld 0

a + ld 1
b + ld 1
a+ld 0

a ≡ u1
b ≡ v1
b )+(ld 1
2

a+ld 1
b )

≡ u1+v1
2

2
u1 + ld 2
v1 + ld 2
(u1+v1)+(ld 2

a ≡ u2
b ≡ v2

a+ld 2
b )

2

. . .
. . .
. . .
. . .

≡ u2+v2
2

which results in a constant monitor.

(cid:117)(cid:116)
This pruning strategy can be generalized as well. Let R = {r1, . . . , rm} be a set
of relevant variables (in our case the output variables st
i) and V = {s1, . . . , sn} ∪ R
be the other variables (in our case input variables or fresh variables from previous
pruning applications). Let C be a set of constraints which has to be fulﬁlled over
r1, . . . , rm, s1, . . . , sn, which contains equations of the form c = (cid:80)m
i=1 cri ∗ ri +
(cid:80)n

i=1 csi ∗ si + c(cid:48) where c, c(cid:48), csi , cri are constants.
If the equation system is unsolvable (which can easily be checked) we return
C(cid:48) = {0 = 1}, otherwise we can rewrite it as shown on the left. The matrix N of
this equation system has m rows and n columns. Let r be the rank of this matrix
which is limited by min{m, n}. Consequently an m × r matrix N (cid:48) with r ≤ m
exists with the same span as N and the system can be rewritten (without loosing
solutions to (r1, . . . , rm)). From this rewritten equation system a new constraint
set C(cid:48) can be generated which


contains the equations from the
system. We call this method the
LolaLA pruning strategy, which is
perfect and constant.

c1,1 . . . c1,n
...
cm,1 . . . cm,n

o1
...
om

r1
...
rm

s1
...
sn


 =


 +


 ∗




























Lemma 2. The LolaLA pruning strategy is perfect and constant.

LolaB/LA Consider the speciﬁcation below (left) where i, a and b are input streams
of type R. Consider a trace where the values of stream i are unknown until time
2, but that we have the assumption 0 ≤ i[now ] ≤ 1. The unpruned symbolic
expressions describing the values of x, y at time 2 would then be in matrix notation:

x := x[−1|0] + i[now ]
y := 2 ∗ y[−1|0] + i[now ]

ok := (a[now ] = x[now ]) ∧ (b[now ] = y[now ])

(cid:19)

(cid:18) x2
y2

(cid:19)

(cid:18) 1 1 1
4 2 1

=



∗







i0
i1
i2

x2
3

2

Since the assumption forces all ij to
be between 0 and 1 the possible set of
value combinations x and y can take
at time 2 is described by a polyhedron
with 6 edges depicted in Fig. 2. De-
scribing this polygon requires 3 vectors.
It is easy to see that each new unknown
input generates a new vector, which is
Fig. 2. Set of possible values of x2 and y2
not multiple of another. Hence for n
unknown inputs on stream i the set of possible value combinations for (xt, yt) is
described by a polygon with 2n edges for which a constraint set of size O(n) is re-
quired. This counterexample implies that for LolaB/LA there is no perfect pruning

3

4

6

8

1

1

7

0

5

0

2

y2

Symbolic Runtime Veriﬁcation under Uncertainties and Assumptions

13

strategy. However, one can apply the following approximation: Given a constraint
set C over V = {s1, . . . , sn} ∪ R with R = {r1, . . . , rm} the set of relevant variables.
1. Split the set of relevant variables into RB containing those of type Boolean and

RR containing those of type Real.

2. For RB do the rewriting as for LolaB obtaining C(cid:48)
B.
3. For RR do the rewriting as for LolaLA over CLE with CLE ⊆ C being the set of
all linear equations in C, obtaining C(cid:48)
R.

4. For all fresh variables vi with 1 ≤ i ≤ k in C(cid:48)

R calculate a minimum bound
li and maximum bound gi (may be over-approximating) over the constraints
C ∪ C(cid:48)
R ∪ {li ≤ vi ≤ gi|1 ≤ i ≤ k}.

5. Return C(cid:48) = C(cid:48)
We call this strategy the LolaB/LA pruning strategy, which allows to build an
atemporal (imperfect but sound) constant-memory monitor.

R = C(cid:48)
R and build C(cid:48)(cid:48)
B ∪ C(cid:48)(cid:48)
R

Lemma 3. The LolaB/LA pruning strategy is sound and constant.

Note that with the LolaB/LA fragment we can also support if-then-else expres-
sions. A deﬁnition s = ite(c, t, e) can be rewritten to handle s as an input stream
adding assumption (c ∧ s = t) ∨ (¬c ∧ s = e). After applying this strategy the
speciﬁcation is within the LolaB/LA fragment and as a consequence the sound (but
imperfect) pruning algorithms from there can be applied.

4.2 Temporal assumptions

We study now how to handle temporal assumptions. Consider again Example 4,
but instead of the assumption 0 ≤ ld[now ] ≤ 10 take 0.9 ∗ ld[−1, 0] ≤ ld[now ] ≤
1.1∗ld[−1, 100]. In this case it would not be possible to apply the presented pruning
algorithms. In the pruning process at time 1 we would rewrite our formulas in a
fashion that they do not contain ld1 anymore, but at time 2 we would receive the
constraint 0.9 ∗ ld1 ≤ ld2 ≤ 1.1 ∗ ld1 from the assumption.

Pruning strategies can be extended to consider variables which may be refer-
enced by input constraints at a later time as relevant variables, hence they will
not be pruned. A monitor which receives constraint sets over the last l instants
is called an l-lookback monitor. An atemporal monitor is therefore a 0-lookback
monitor. For an l-lookback monitor the number of variables that are referenced at
a later timestamp is constant, so our pruning strategies remain constant. Hence,
the following theorem is applicable to our pruning strategies and as a consequence
our solutions for atemporal monitors can be adapted to l-lookback monitors (for
constant l).

ϕ there is a constant-memory l-lookback monitor Mϕ such that

Theorem 2. Given a Lola speciﬁcation ϕ and a constant pruning strategy P for
ExprB
– Mϕ is sound if the pruning strategy is sound.
– Mϕ is perfect if the pruning strategy is perfect.

14

Hannes Kallwies, Martin Leucker, and César Sánchez

5

Implementation and Empirical Evaluation

We have developed a prototype implementation of the symbolic algorithm for past-
only Lola in Scala, using Z3 [23] as solver. Our tool supports Reals and Booleans
with their standard operations, ranges (e.g. [3, 10.5]) and ? for unknowns. Assump-
tions can be encoded using the keyword ASSUMPTION.3 Our tool performs pruning
(Section 4.1) at every instant, printing precise outputs when possible. If an output
value is uncertain the formula and a range of possible values is printed.

We evaluated two realistic case studies, a test drive data emission monitor-
ing [18] and an electrocardiogram (ECG) peak detector [11]. All measurements
were done on a 64-bit Linux machine with an Intel Core i7 and 8 GB RAM. We
measured the processing time of single events in our evaluation, for inputs from 0
up to 20% of uncertain values, resulting in average of 25 ms per event (emissions
case study) and 97 ms per event (ECG). In both cases the runtime per event did
not depend on the length of the trace (as predicted theoretically). The longer run-
time per event in the second case study is explained because of the window of size
100 which is unrolled to 100 streams, and using Z3 naively to deduce bounds of
unknown variables. We discuss the two case studies separately.

Case study #1: Emission Monitoring The ﬁrst example is a speciﬁcation that
receives test drive data from a car (including speed, altitude, NOx emissions,. . . )
from [18]. The Lola speciﬁcation is within LolaB/LA (with ite), and checks several
properties, including trip_valid which captures if the trip was a valid test ride.
The speciﬁcation contains around 50 stream deﬁnitions in total. We used two real
trips as inputs, one where the allowed NOx emission was violated and one where
the emission speciﬁcation was satisﬁed.

We injected uncertainty into the two traces by randomly selecting x% of the
events and modifying the value within an interval ±y%. The ﬁgure on the left
shows the result of executing this experiment for all integer combinations of x and y
between 1 and 20, for one trace. The green
space represents the cases for which the monitor
computed the valid answer and the red space
the cases where the monitor reported unknown.
In both traces, even with 20% of incorrect sam-
ples within an interval of ±7% around the cor-
rect value the monitor was able to compute the
correct answer. We also compared these results
to the value-range approach, using interval arithmetic. However, the ﬁnal verdicts
do not diﬀer here. Though the symbolic approach is able to calculate more precise
intermediate results, these do not diﬀer enough to obtain diﬀerent ﬁnal Boolean
verdicts.

As expected, for fully unknown values and no assumptions, neither the symbolic
nor the interval approaches could compute any certain verdict, because the input

3 Note that for our symbolic approach assumptions can indeed be considered as a stream

speciﬁcation of type Boolean which has to be true at every time instant.

1CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT2CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT3CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT4CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT5CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT6CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT7CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT8CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNCORRECTCORRECTUNKNOWN9CORRECTCORRECTCORRECTUNKNOWNCORRECTUNKNOWNCORRECTUNKNOWNCORRECTCORRECTCORRECTUNKNOWNCORRECTUNKNOWNCORRECTCORRECTCORRECTUNKNOWNCORRECTUNKNOWN10CORRECTCORRECTCORRECTCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNCORRECTCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNCORRECT11CORRECTUNKNOWNCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN12CORRECTCORRECTCORRECTUNKNOWNCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN13CORRECTUNKNOWNCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN14CORRECTCORRECTCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN15CORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN16UNKNOWNUNKNOWNCORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN17UNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN18UNKNOWNCORRECTCORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN19CORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN20CORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN1234567891011121314151617181920Number of uncertain events [%]Uncertain value range [%]Symbolic Runtime Veriﬁcation under Uncertainties and Assumptions

15

Fig. 3. ECG analysis. Left: Symbolic approach, Right: Value range approach. Green:
Certain heartbeats, Yellow: Potential heartbeats, Red: Bursts of unknown values.

values could be arbitrarily large. However, in opposite to the interval approach,
the symbolic approach allows adding assumptions (e.g. the speed or altitude does
not diﬀer much from the previous value). With this assumption, we received the
valid result for trip_valid when up to 4% of inputs are fully uncertain. In other
words, the capability of symbolic monitoring to encode physical dependencies as
assumptions often allows our technique to compute correct verdicts in the presence
of several unknown values.

Case Study #2: Heart Rate monitoring Our second case study concerns the
peak detection in electrocardiogram (ECG) signals [11]. The speciﬁcation calculates
a sliding average and stores the values of this convoluted stream in a window of
size 100. Then it checks if the central value is higher than the 50 previous and the
50 next values to identifying a peak.

We evaluated the speciﬁcation against a ECG trace with 2700 events corre-
sponding to 14 heartbeats. We integrated uncertainty into the data in two diﬀerent
ways. First, we modiﬁed x% percent of the events with deviations of ±y%. Even
if 20% of the values were modiﬁed with an error of ±20%, the symbolic approach
returned the perfect result, while the abstraction approach degraded over time be-
cause of accumulated uncertainties (many peaks were incorrectly “detected”, even
under 5% of unknown values with a ±20% error—see front part of traces in Fig. 3).
Second, we injected bursts of consecutive errors (? values) of diﬀerent lengths into
the input data. The interval domain approach lost track after the ﬁrst burst and
was unable to recover, while the symbolic approach returned some ? around the
area with the bursts and recovered when new values were received (see Fig. 3).

We exploited the ability of symbolic monitors to handle assumptions by encod-
ing that heartbeats must be apart from each other more than 160 steps (roughly
0.5 seconds), which increased the accuracy. In one example (Fig. C.8 in appendix
C) the monitor correctly detected a peak right after a burst of errors. The as-
sumption allows the monitor to infer that the unknown burst of values are below a
certain threshold, which enables the detection of the next heartbeat. If instead of
the assumption heartbeats that are not at least 160 steps apart were simply ﬁltered
out, future heartbeats could not be detected correctly (Fig. C.8(b) in appendix C),
because no ranges of the values of unknown events can be deduced.

16

Hannes Kallwies, Martin Leucker, and César Sánchez

6 Conclusion

We have introduced the concept of symbolic monitoring to monitor in the presence
of input uncertainties and assumptions on the system behavior. We showed theoret-
ically and empirically that symbolic monitoring is more precise than a straightfor-
ward abstract interpretation approach, and have identiﬁed logical theories in which
perfect symbolic approach can be implemented eﬃciently (constant monitoring).
Future work includes: (1) to identify other logical theories and their combinations
that guarantee perfect trace length independent monitoring; (2) to be able to an-
ticipate verdicts ahead of time for rich data domains by unfolding the symbolic
representation of the speciﬁcation beyond, along the lines of [2,19,27] for Booleans;
Finally, we envision that symbolic monitoring can become a general, founda-
tional approach for monitoring that will allow to explain many existing monitoring
approaches as instances of the general schema.

Symbolic Runtime Veriﬁcation under Uncertainties and Assumptions

17

References

1. Bartocci, E., Falcone, Y. (eds.): Lectures on Runtime Veriﬁcation - Introductory and Ad-

vanced Topics, LNCS, vol. 10457. Springer (2018)

2. Bauer, A., Leucker, M., Schallhart, C.: Monitoring of real-time properties. In: Proc. of

FSTTCS’06. LNCS, vol. 4337, pp. 260–272. Springer (2006)

3. Bauer, A., Leucker, M., Schallhart, C.: Comparing LTL semantics for runtime veriﬁcation. J.

Logic and Computation 20(3), 651–674 (2010)

4. Biere, A., Cimatti, A., Clarke, E.M., Strichman, O., Zhu, Y.: Bounded model checking. In:
Highly Dependable Soft., chap. 3, pp. 118–149. No. 58 in Adv. in Comp., Acad. Press (2003)
5. Biewer, S., Finkbeiner, B., Hermanns, H., Köhl, M.A., Schnitzer, Y., Schwenger, M.: RTLola
on board: Testing real driving emissions on your phone. In: Proc. TACAS’21, Part II. LNCS,
vol. 12652, pp. 365–372. Springer (2021)

6. Cimatti, A., Tian, C., Tonetta, S.: Assumption-based runtime veriﬁcation of inﬁnite-state

systems. In: Proc. of RV’21. LNCS, vol. 12974, pp. 207–227. Springer (2021)

7. Convent, L., Hungerecker, S., Leucker, M., Scheﬀel, T., Schmitz, M., Thoma, D.: TeSSLa:
Temporal stream-based speciﬁcation language. In: Proc. of SBMF’18. LNCS, vol. 11254, pp.
144–162. Springer (2018)

8. Cousot, P., Cousot, R.: Abstract interpretation: A uniﬁed lattice model for static analysis of
programs by construction or approximation of ﬁxpoints. In: POPL. pp. 238–252. ACM (1977)
9. D’Angelo, B., Sankaranarayanan, S., Sánchez, C., Robinson, W., Finkbeiner, B., Sipma, H.B.,
Mehrotra, S., Manna, Z.: LOLA: runtime monitoring of synchronous systems. In: Proc. of
TIME’05. pp. 166–174. IEEE Computer Society (2005)

10. Decker, N., Leucker, M., Thoma, D.: Monitoring mod. theories. STTT 18(2), 205–225 (2016)
11. Gorostiaga, F., Sánchez, C.: Nested monitors: Monitors as expressions to build monitors. In:

Proc. of RV’21. LNCS, vol. 12974, pp. 164–183. Springer (2021)

12. Gorostiaga, F., Sánchez, C.: Stream runtime veriﬁcation of real-time event streams with the

Striver language. STTT 23(2), 157–183 (2021)

13. Havelund, K., Goldberg, A.: Verify your runs. In: Proc. of VSTTE’05. pp. 374–383. LNCS

4171, Springer (2005)

14. Havelund, K., Peled, D.: An extension of ﬁrst-order LTL with rules with application to

runtime veriﬁcation. STTT 23(4), 547–563 (2021)

15. Henzinger, T.A., Saraç, N.E.: Monitorability under assumptions. In: Proc. of RV’20. LNCS,

vol. 12399, pp. 3–18. Springer (2020)

16. Kauﬀman, S., Havelund, K., Fischmeister, S.: What can we monitor over unreliable channels?

STTT pp. 1–24 (2020)

17. King, J.C.: Symbolic execution and program testing. CACM 19(7), 385–394 (1976)
18. Köhl, M.A., Hermanns, H., Biewer, S.: Eﬃcient monitoring of real driving emissions. In: Proc.

of RV’18. LNCS, vol. 11237, pp. 299–315. Springer (2018)

19. Leucker, M.: Sliding between model checking and runtime veriﬁcation. In: Proc. of RV’12.

LNCS, vol. 7687, pp. 82–87. Springer (2012)

20. Leucker, M., Sánchez, C., Scheﬀel, T., Schmitz, M., Schramm, A.: Tessla: runtime verif. of

non-synchronized real-time streams. In: SAC’18. pp. 1925–1933. ACM (2018)

21. Leucker, M., Sánchez, C., Scheﬀel, T., Schmitz, M., Thoma, D.: Runtime verif. for timed

event streams with partial info. In: RV’19. LNCS, vol. 11757, pp. 273–291. Springer (2019)

22. Leucker, M., Schallhart, C.: A brief account of runtime veriﬁcation. J. Log. Algebraic Methods

Program. 78(5), 293–303 (2009)

23. de Moura, L.M., Bjørner, N.: Z3: An eﬃcient SMT solver. In: Proc. of TACAS’08. LNCS,

vol. 4963, pp. 337–340. Springer (2008)

24. Pan, J., Tompkins, W.J.: A real-time QRS detection algorithm. IEEE Trans. on Biomedical

Engineering BME-32(3), 230–236 (1985)

25. Pnueli, A.: The temporal logic of programs. In: FOCS’77. pp. 46–57. IEEE (1977)
26. Sznajder, M., Łukowska, M.: Python Online and Oﬄine ECG QRS Detector based on the

Pan-Tomkins algorithm (Jul 2017)

27. Zhang, X., Leucker, M., Dong, W.: Runtime veriﬁcation with predictive semantics. In: Proc.

of NFM’12. LNCS, vol. 7226, pp. 418–432. Springer (2012)

18

Hannes Kallwies, Martin Leucker, and César Sánchez

A Further Examples

Example 7. Consider again ϕ in Example 1, with the prefect readings in Fig. 1(b).
We show for time steps 0, 1, 2 an 3 the equations before and after evaluation and
simpliﬁcation, in the upper and lower rows, resp.

2
ld 2 = 5

1
ld 1 = 4
acc1 = acc0 + ld 1 acc2 = acc1 + ld 2 acc3 = acc2 + ld 3 − ld 0

0
ld 0 = 3
acc0 = ld 0
ok 0 = acc0 ≤ 15 ok 1 = acc1 ≤ 15 ok 2 = acc2 ≤ 15 ok 3 = acc3 ≤ 15
ld 1 = 4, ld 2 = 5
ld 3 = 7
acc3 = 16
ok 3 = ﬀ

ld 0 = 3, ld 1 = 4
ld 2 = 5
acc2 = 12
ok 2 = tt

ld 0 = 3
ld 1 = 4
acc1 = 7
ok 1 = tt

ld 0 = 3
acc0 = 3
ok 0 = tt

3
ld 2 = 7

All equations are fully resolved at every step. Also, ld 0 is pruned at 3 because ld 0
will not be used in the future. Consider now the imperfect input in Fig.1(d):

1
0
ld 1 = 4
1 ≤ ld 0 ≤ 5
acc0 = ld 0
acc1 = acc0 + ld 1 acc2 = acc1 + ld 2
ok 0 = acc0 ≤ 15 ok 1 = acc1 ≤ 15 ok 2 = acc2 ≤ 15
1 ≤ ld 0 ≤ 5

2
ld 2 = 5

3
ld 2 = 7
acc3 = acc2 + ld 3 − ld 0
ok 3 = acc3 ≤ 15
ld 3 = 7

ld 1 = 4
1 ≤ ld 0 ≤ 5
acc1 = ld 0 + 4
ok 1 = tt

ld 2 = 5
1 ≤ ld 0 ≤ 5, ld 1 = 4 ld 1 = 4, ld 2 = 5
acc2 = ld 0 + 9
ok 2 = tt

acc3 = 16
ok 3 = ﬀ

acc0 = ld 0
ok 0 = tt

At time 2, ok 2 = tt is inferred from {1 ≤ ld 0 ≤ 5, ld 1 = 4, acc2 = ld 0 + 9, ok 2 =
acc2 ≤ 15}. At time 3 the dependency to the unknown value ld 0 is eliminated from
acc3 = acc2 + ld 2 − acc0 by symbolic manipulation.
(cid:117)(cid:116)

B Missing Proofs

Theorem 1. Given a speciﬁcation ϕ and a constant pruning strategy P for ExprB
ϕ,
there is an atemporal constant-memory monitor Mϕ s.t.

– Mϕ is sound if the pruning strategy is sound.
– Mϕ is perfect if the pruning strategy is perfect.

Proof. Let ϕ = (I, O, E) be the atemporal speciﬁcation.

We will show the theorem by constructing a monitor that generates expression
sets which satisfy the relation to Φi demanded in Deﬁnition 4.

Ri =

In general a monitor M is perfect with respect to ϕ, if it generates M i, s.t.
Φi
Ri with
(cid:74)
Ri = {xi|x ∈ I ∪ O}, the relevant variables for this timestamp. This follows
directly from Deﬁnition 4 and Deﬁnition 5.

Ri and sound, if it generates M (cid:48)i, s.t.
(cid:75)

Ri ⊆

M i

M i

Φi

(cid:75)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

(cid:74)

Symbolic Runtime Veriﬁcation under Uncertainties and Assumptions

19

We ﬁrst consider the case where the pruning strategy P (we write P i for the
pruning according to Ri) is sound:

By using P we can construct a sound monitor M which generates outputs M 0 =
P 0(
0
A(0)
sym ∪
(cid:74)
(cid:74)
We will now show
Ri ⊆
will argue M is also a constant-memory monitor.

ϕ ∪ ψ0) and M i = P i(M i−1 ∪
(cid:75)
Φi
(cid:74)

Ri for all i, i.e. that M is sound. Afterwards we

ϕ ∪ ψi) for i > 0.

i
sym ∪

ϕ
(cid:75)

ϕ
(cid:75)

M i

Ai

(cid:74)

(cid:74)

(cid:74)

(cid:75)

(cid:75)

(cid:75)

For i = 0:
By Deﬁnition 5:
And by Deﬁnition of Φ0:

R0 ⊆
(cid:75)

Φ0

(cid:74)

(cid:74)

P 0(Φ0)

(cid:74)
P 0(Φ0)
(cid:75)

R0.
(cid:75)
R0 =

P(
(cid:74)

ϕ
(cid:75)

(cid:74)

0
sym ∪

A(0)
(cid:74)

ϕ ∪ ψ0)
(cid:75)

R0 =
(cid:75)

(cid:74)

M 0

(cid:75)

R0.

(cid:74)

(cid:74)

(cid:74)

(cid:74)

(cid:75)

Ai

Ai

Ri.

ϕ
(cid:75)

i
sym ∪

i
sym ∪

M i−1 ∪

Ri =
(cid:75)

ϕ ∪ ψi
(cid:75)

ϕ ∪ ψi
(cid:75)

ϕ
(cid:75)
(cid:74)
i
sym ∪

Further, for i > 0:
Φi−1 ∪
Φi
Ri ⊆
(cid:74)
(cid:74)
(cid:74)
This is because of the atemporality of the monitor and the ﬂattened form of the
ϕ ∪ ψi are from Ri−1
Ai
speciﬁcation all common variables of Φi−1 and
(cid:74)
(cid:75)
Φi−1
M i−1
Ri−1. Hence if for any
Ri−1 is known to be a superset of
for which
(cid:75)
ϕ ∪ ψi and α |= Φi−1 then also α |= M i−1. Thus,
i
ϕ
sym ∪
α we have α |=
(cid:74)
(cid:75)
if α |= Φi−1 ∪
ϕ ∪ ψi. This
i
ϕ
sym ∪
ϕ
(cid:74)
(cid:75)
fact together with the deﬁnition of
Ri (Deﬁnition 5) implies the subset relation
above.
Φi
Furthermore
(cid:74)
deﬁnition of P i (Deﬁnition 5).
Hence, for all outputs of M we have

(cid:74)
(cid:75)
ϕ ∪ ψi then α |= M i−1 ∪

·
(cid:75)
ϕ
(cid:75)
Ri ⊆

(cid:74)
Ri for all i and thus M is sound.
(cid:75)

(cid:74)
P i(M i−1 ∪

(cid:75)
i
sym ∪
(cid:75)

ϕ ∪ ψi)
(cid:75)

Ri again by

(cid:74)
Φi
(cid:74)

(cid:74)
M i

i
sym ∪

Ai
(cid:74)

Ri =

Ri ⊆

ϕ
(cid:75)

M i

(cid:74)
Ai

Ai

Ai

(cid:74)

(cid:74)

(cid:75)

(cid:75)

(cid:75)

(cid:75)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

(cid:75)

(cid:74)

Note that for all M i we have |M i| ≤ c due to the constant pruning strategy.
However M only has to store the M i from the last step and as consequence it is
constant-memory monitor.

The case where the pruning strategy P is perfect is analogous.

(cid:117)(cid:116)

Lemma 1. The LolaB pruning strategy is perfect and constant.

Proof. Let C be any constraint set over V = {s1, . . . , sn}∪R with relevant variables
R = {r1, . . . , rm} and C(cid:48) the set obtained after pruning.

C(cid:48)

C

R =
(cid:75)

Clearly
R = {(v1, . . . , vn)|(r1 = v1)∧· · ·∧(rn =
C
(cid:74)
vn) |= C}. We only add value combinations to T which fulﬁll (r1 = v1) ∧ · · · ∧ (rm =
vm) |= γ and the ψi in C(cid:48) by deﬁnition just allow exactly these combinations.

R since by deﬁnition

(cid:75)

(cid:74)

(cid:75)

(cid:74)

Moreover, the value table from which C(cid:48) is created has m rows and c columns.
Hence C(cid:48) contains m formulas over at most (cid:100)log(c)(cid:101) variables.
According to our measure we have for every ri = ψi from C(cid:48) |ri = ψi| = 1 + |ψi| ≤
1 + (cid:100)log(c)(cid:101) ∗ 2(cid:100)log(c)(cid:101) ≤ c2 + 1 and consequently |C(cid:48)| ≤ m ∗ (c2 + 1).
Note that for c we have c ≤ 2m (number of columns in the table) and m is the
(cid:117)(cid:116)
number of streams in the ﬂattened speciﬁcation and hence constant.

20

Hannes Kallwies, Martin Leucker, and César Sánchez

Lemma 2. The LolaLA pruning strategy is perfect and constant.

Proof. Let C be any constraint set over V = {s1, . . . , sn}∪R with relevant variables
R = {r1, . . . , rm} and C(cid:48) the set obtained after pruning.

The strategy is clearly perfect. If C did not have solutions we return a C(cid:48) which
also has no solutions. If C has solutions we use equivalence transformations of
the system of equations preserving the solutions for (r1, . . . , rm), hence
R =
{(v1, . . . , vn)|(r1 = v1) ∧ · · · ∧ (rn = vn) |= C} =

R.

C(cid:48)

C

(cid:74)

(cid:75)

(cid:74)

(cid:75)

Note that N (cid:48) is an m × r matrix with r ≤ m. Hence in C(cid:48) there are m expressions
of the form ri = (cid:80)r
j=1 ci,jvj + ci| = 2r + 2 and hence
|C(cid:48)| = m ∗ (2r + 2) ≤ 2m2 + 2m. The value m is the number of streams in the
(cid:117)(cid:116)
ﬂattened speciﬁcation and hence constant.

j=1 ci,jvj + ci with |ri = (cid:80)r

Lemma 3. The LolaB/LA pruning strategy is sound and constant.

Proof. Let C be any constraint set over V = {s1, . . . , sn}∪R with relevant variables
R = {r1, . . . , rm} and C(cid:48) the set obtained after pruning.

B is a perfect pruning of C for RB and from Lemma 2

R is a perfect pruning of CLE for RR.

It follows from Lemma 1 that C(cid:48)
that C(cid:48)
Since C ∪ C(cid:48)
C(cid:48)
R =
(cid:75)

B ∪ C(cid:48)(cid:48)
C(cid:48)
R
(cid:74)

R =
(cid:75)

B ∪ C(cid:48)
C(cid:48)

R |= {li ≤ vi ≤ gi|1 ≤ i ≤ k} by deﬁnition of li, gi, we have:

R ∪ {li ≤ vi ≤ gi|1 ≤ i ≤ k}
(cid:75)

R ⊇

B ∪ C(cid:48)
C(cid:48)

R ∪ C

R.

(cid:74)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

C

C(cid:48)
B

(cid:74)
(cid:74)
We also have that, C(cid:48)
B and C only share the variables RB (because our pruning
strategy for LolaB pruned all others away and only introduced fresh variables).
RB =
RB. Thus it follows for all expressions α over R, that if
Furthermore
(cid:75)
α |= C then α |= C(cid:48)
B.
The same reasoning holds for C(cid:48)
α over R.
Hence, it follows:

R: The LolaB/LA pruning strategy is sound.

R and C, i.e. α |= C then α |= C(cid:48)

R for all expressions

(cid:75)
Moreover, the pruning strategy is also constant: From Lemmas 1 and 2 , C(cid:48)
B and
C(cid:48)
R have constant upper bounds. The number of ﬁxed-sized constraints added in
step 3 is bounded by the number of fresh variables in the LolaLA pruning strategy
which is bounded by m. The value m is the number of streams in the ﬂattened
speciﬁcation and hence constant. Thus the size of C(cid:48) has a constant upper bound
(cid:117)(cid:116)
as well.

R ⊇
(cid:75)

B ∪ C(cid:48)
C(cid:48)

R ∪ C

C

(cid:74)

(cid:74)

Symbolic Runtime Veriﬁcation under Uncertainties and Assumptions

21

C Graphs from evaluation runs

C.1 Emission Monitoring: Verdicts for uncertain inputs

Figure Monitoring trip_valid for two traces with 1% to 20% of values
uncertain (range of ±1% to ±20% around correct value). Green: certain result;
red: uncertain result.

C.2 ECG (symbolic), Full run for uncertain inputs

Figure ECG analysis 20% of the values uncertain (range of ±20% around
correct value). Symbolic approach. Green: heartbeat certainly detected; yellow:
heartbeat possibly detected.

C.3 ECG (intervals), Full run for uncertain inputs

Figure ECG analysis 5% of the values uncertain (range of ±20% around correct
value). Interval approach. Green: heartbeat certainly detected; yellow: heartbeat
possibly detected.

C.4 ECG (symbolic), Full run for 5 uncertainty bursts

Figure ECG analysis with 5 bursts of fully uncertain values(5 to 20 in a row).
Symbolic approach. Orange: Burst of uncertain values; green: heartbeat certainly
detected; yellow: heartbeat possibly detected.

1CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT2CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT3CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT4CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT5CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT6CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT7CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT8CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNCORRECTCORRECTUNKNOWN9CORRECTCORRECTCORRECTUNKNOWNCORRECTUNKNOWNCORRECTUNKNOWNCORRECTCORRECTCORRECTUNKNOWNCORRECTUNKNOWNCORRECTCORRECTCORRECTUNKNOWNCORRECTUNKNOWN10CORRECTCORRECTCORRECTCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNCORRECTCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNCORRECT11CORRECTUNKNOWNCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN12CORRECTCORRECTCORRECTUNKNOWNCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN13CORRECTUNKNOWNCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN14CORRECTCORRECTCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN15CORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN16UNKNOWNUNKNOWNCORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN17UNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN18UNKNOWNCORRECTCORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN19CORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN20CORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN1234567891011121314151617181920Number of uncertain events [%]Uncertain value range [%]1CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECT2CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNCORRECTCORRECTCORRECTCORRECTCORRECT3CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNCORRECTCORRECTUNKNOWNCORRECTUNKNOWNCORRECTCORRECTUNKNOWNUNKNOWN4CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNUNKNOWNCORRECTCORRECTUNKNOWNUNKNOWN5CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNCORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNCORRECT6CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNCORRECTCORRECTCORRECTCORRECTUNKNOWNCORRECTCORRECTCORRECTUNKNOWNCORRECTUNKNOWNCORRECTUNKNOWN7CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWN8CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN9CORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN10CORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN11CORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN12CORRECTCORRECTCORRECTCORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN13CORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN14CORRECTUNKNOWNUNKNOWNUNKNOWNCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN15CORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN16CORRECTCORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN17UNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN18UNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN19CORRECTUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN20UNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWNUNKNOWN1234567891011121314151617181920Number of uncertain events [%]Uncertain value range [%]22

Hannes Kallwies, Martin Leucker, and César Sánchez

C.5 ECG (intervals), Full run for 5 uncertainty bursts

Figure ECG analysis with 5 bursts of fully uncertain values(5 to 20 in a row).
Interval approach. Orange: Burst of uncertain values; green: heartbeat certainly
detected; yellow: heartbeat possibly detected.

C.6 ECG (symbolic), Full run for 5 uncertainty bursts (with

assumption)

Figure ECG analysis with 5 bursts of fully uncertain values(5 to 20 in a row).
Symbolic approach with assumption. Orange: Burst of uncertain values, green:
heartbeat certainly detected, yellow: heartbeat possibly detected.

C.7 ECG (symbolic), Full run for 5 uncertainty bursts (with ﬁlter)

Figure ECG analysis with 5 bursts of fully uncertain values(5 to 20 in a row).
Symbolic approach with ﬁlter. Orange: Burst of uncertain values; green:
heartbeat certainly detected; yellow: heartbeat possibly detected.

C.8 ECG (symbolic), Bursts: Comparison Assumptions and Filter

Figure ECG analysis with bursts. Left: Usage of assumption. Right: Additional
condition added to output stream. Orange: Burst of uncertain values; green:
heartbeat certainly detected; yellow: heartbeat possibly detected.

