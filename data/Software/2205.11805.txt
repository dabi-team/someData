Hybrid Manufacturing Process Planning for Arbitrary Part and Tool Shapes

George Harabin and Morad Behandish

Palo Alto Research Center (PARC), 3333 Coyote Hill Road, Palo Alto, California 94304

Abstract

Hybrid manufacturing (HM) technologies combine additive and subtractive manufacturing (AM/SM) capabilities in multi-
modal process plans that leverage the strengths of each. Despite the growing interest in HM technologies, software tools
for process planning have not caught up with advances in hardware and typically impose restrictions that limit the design
and manufacturing engineers’ ability to systematically explore the full design and process planning spaces. We present a
general framework for identifying AM/SM actions that make up an HM process plan based on accessibility and support
requirements, using morphological operations that allow for arbitrary part and tool geometries to be considered. To take
advantage of multi-modality, we deﬁne the actions to allow for temporary excessive material deposition or removal, with
an understanding that subsequent actions can correct for them, unlike the case in unimodal (AM-only or SM-only) process
plans that are monotonic. We use this framework to generate a combinatorial space of valid, potentially non-monotonic,
process plans for a given part of arbitrary shape, a collection of AM/SM tools of arbitrary shapes, and a set of relative
rotations (ﬁxed for each action) between them, representing build/ﬁxturing directions on 3−axis machines. Finally, we
deﬁne a simple objective function quantifying the cost of materials and operating time in terms of deposition/removal
volumes and use a search algorithm to explore the exponentially large space of valid process plans to ﬁnd “cost-optimal”
solutions. We demonstrate the eﬀectiveness of our method on 3D examples.

Keywords: Hybrid Manufacturing, Process Planning, Spatial Reasoning, Additive Manufacturing, Machining

1. Introduction

In recent years, additive-manufacturing (AM) technolo-
gies have enabled the manufacture of parts with unprece-
dented levels of geometric/material complexity and mass
customization. More recently, post-pandemic supply chain
challenges has led to a surge in investment in AM as a means
to produce on-demand spare parts at the point of need.
However, compared to subtractive manufactruing (SM) pro-
cesses (such as CNC machining), most AM processes suﬀer
from diminished surface quality and reduced dimensional
accuracy to varying degrees [1, 2], in a complex tradeoﬀ
with workspace size, build time, energy, and cost, among
other factors. On the other hand, SM processes cannot
provide the same levels of geometric complexity due to tool
accessibility constraints and result in more material waste
compared to additive processes [3]. Hybrid manufacturing
(HM) oﬀers tremendous potential to combine the relative
strengths of both AM and SM approaches in a multi-modal
sequence of manufacturing actions that leverage the best of
both worlds. Examples of HM use-cases consist of directed
energy deposition (DED) and powder bed fusion (PBF),
combined with CNC machining to perform coating and re-
pair [4]. See [5–7] for recent reviews of HM technologies.

While HM has overcome some of the limitations of uni-
modal (AM-only or SM-only) processes, its industrial use-
cases have remain limited to modifying parts with easily
separable features for AM/SM actions based on shape or
materials (Fig. 1). The true potential of HM in produc-
ing parts can be unlocked by HM-specialized computer-
aided process planning (CAPP) software tools. Current
approaches to HM process planning, however, rely on as-
sumptions about part geometry or use feature based de-
compositions that limit their extensibility to complex part
and tool geometries [3, 8–10].

As discussed in our earlier work [11], HM process planning
faces several theoretical and algorithmic challenges that are
not present in uni-modal (AM-only or SM-only) process
planning, such as a) non-monotonicity, e.g., material may
be removed only to be added back in at a later point in the
plan, and vice versa; and b) non-permutativity, i.e., chang-
ing the order of a pair of AM-SM actions with overlapping
regions of inﬂuence (ROI) in the 3D workspace aﬀects the
end result, unlike the case with AM-AM or SM-SM pairs.
As a result of such impediments to HM process planning,
currently practical HM use-cases are primarily restricted
to short (e.g., two-step) sequences. For example, a com-
mon scenario is an AM-then-SM sequence consisting of an
initial AM operation to deposit material into a “near-net”
shape, followed by an SM operation intended to remove ex-
cess material (e.g., sacriﬁcial support structures) and ﬁnish
functional surfaces down to desired error tolerance and qual-
ity [12, 13]. Another common scenario is an SM-then-AM
sequence consisting of an initial SM operation to carve out
cracked regions of a high-value part (e.g., a turbine blade),
followed by an AM operation intended to ﬁll in the removed
region with new material [14, 15].

Figure 1: Part produced with 3 distinct features added via AM-then-
SM pairs of actions on a Mazak INTEGREX i-400 AM [11, 16].

Preprint submitted to Computer-Aided Design

June 6, 2022

2
2
0
2

n
u
J

2

]

G
C
.
s
c
[

2
v
5
0
8
1
1
.
5
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
This paper presents a novel approach to HM process plan-
ning that can unlock the full potential of HM in produc-
ing complex geometries from scratch. We construct process
plans by iteratively adding AM/SM actions (when needed)
to get an initial state—e.g., a raw/bar stock, if the ﬁrst
action is SM, or an empty build plate, if the ﬁrst action
is AM—to a desired target state, while minimizing cost.
Our approach enables identifying cost-eﬀective HM process
plans to build complex geometries by strategic interleaving
of AM and SM actions. Such computational tools can ac-
celerate the industrial adoption of AM in concert with SM,
leveraging their complementary advantages.

1.1. Related Work

Commercial-strength software tools for HM processes
(e.g., CGTech VERICUT or Siemens NX) are mostly focused
on feature-based path planning and process simulation for
speciﬁc processes and motion controllers, extending tradi-
tional computer-aided manufacturing (CAM) for CNC tool-
ing. Higher-level CAPP activities such as identifying how to
break a given part’s interior/exterior to AM/SM volumes,
mapping them to proper AM/SM capabilities, and order-
ing the AM/SM actions for cost optimization, are still in
academic stage. Previous studies have aimed to address the
limitations of CAPP tools through various approaches such
as feature-based decomposition of the part or by making
simplifying assumptions about part and/or tool shapes.

Liu et al. [8] presented a decomposition-based approach
to sequence planning for multi-axis HM of geometrically
complex parts, incorporating tool accessibility through a
projection-based approach. Chen et al.
[9] examined the
problem of HM process planning for 2.5−axis AM, using
a sequential search algorithm to discover a minimal length
alternating HM process plan (switching AM/SM modalities
at each step) while accounting for tool accessibility con-
straints. The part geometries for both of these approaches,
however, were limited to columnar shapes.

Zheng et. al [10] proposed an approach to cost-driven
process planning formulated as mixed-integer programming,
relying on feature-based decomposition of the part in order
to build the cost model. Basinger et al.
[3] developed the
feature-based hybrid manufacturing process planning sys-
tem (FAH-PS) that utilized feature-speciﬁc geometric, tol-
erance, and material data in order to automatically generate
HM process plans that minimize tool and part orientation
changes. However, making simplifying assumptions about
geometry limits the HM search space, while feature-based
decomposition relies on engineering intent and limits exten-
sibility to parts and tools of complex shapes [11].

Several approaches have combined the development of
novel HM technologies with custom-designed process plan-
ning software targeted towards the process: Manogharan
[17] developed an integrated system (called AIMS)
et al.
to integrating direct metal AM techniques (e.g., EBM or
DMLS) with CNC machining (for creating critical surfaces
and dimensions) in order to produce an HM system which is
capable of manufacturing metal parts with complex shapes
while maintaining accuracy and good surface ﬁnish. The
AIMS system relied on a collection of tools used in pure
AM/SM process planning, including visibility analysis, ﬁx-
ture design and location, maximum deviation analysis, sur-
face overgrowth and tool-path analysis.

Karunakaran et al.

[12] developed the two-step layered
ArcHLM method, which consisted of weld-deposition of a

layer followed by a ﬁnish machining step, along with soft-
ware to generate weld and face milling paths. Process plan-
ning for ArcHLM, however, is limited to a repeated two-step
sequence of AM-then-SM steps which bring the part to a
near-net shape, followed by face-milling the deposited layer
to the required thickness in order to provide good surface
quality to facilitate the deposition of the next layer.

Newman et. al [18] developed the iAtractive HM pro-
cess, which is targeted at reuse and remanufacture of ex-
isting and legacy parts. The iAtractive process consists of
fused-ﬁlament AM combined with CNC machining and an
inspection step, along with a ten-step reactionary process
planning approach (RP2A). This process utilizes a combina-
tion of feature extraction, interpretation, and modiﬁcation
along with part decomposition in order to analyze machin-
ability and printability of a part and determine build direc-
tion, operation sequencing, and tool-path generation for the
optimal process plan [19, 20].

Due to their reliance on feature extraction or limiting
assumptions about the geometry and the process, many of
the previous approaches are restricted to relatively simple
part and/or tool shapes and do not allow for systematic
exploration of the entire process planning space [21].

Behandish et al. [11], inspired by earlier work in SM-only
process planning by Nelaturi et al. [22], aimed to lift these
restrictions by presenting a generic deﬁnition of an HM pro-
cess plan as an arbitrary sequence of AM/SM actions ab-
stracted using shape-agnostic logical and set-theoretic con-
structs. Each action was deﬁned by its ROI in the 3D
workspace, computed using concepts from mathematical
morphology [23, 24] and conﬁgurations space (C−space)
modeling [25]. The key advantage of this approach is its
ability to perform purely logical process planning in the ﬁ-
nite Boolean algebra (FBA) of precomputed ROIs (or their
point membership tests) and their canonical intersections
[26], decoupled from spatial reasoning that generate the ROI
shapes. The main limitations of the approach were its ne-
glection of the evolution of C−space obstacle, which may
aﬀect tool accessibility, and the use of conservative policies
for developing ROI candidates, which miss the opportunity
to realize the full potential of HM, as elaborated in Sec-
tion 2.1. In this paper, we overcome these limitations by
embedding spatial reasoning back into the process planning
and using conservative (under-ﬁll/over-cut) and aggressive
(over-ﬁll/under-cut) policies, detailed in Section 2.2.

1.2. Contributions & Outline

This paper presents a general methodology to automat-
ically generate HM process plans for a given part of ar-
bitrary target shape and given set of AM/SM capabilities
with 3−axis motion and arbitrary tool shapes. Our key
contributions are summarized as follows:

1. To deﬁne a discrete search space, we conceptualize
AM/SM actions as transformations of the workpiece
according to conservative and aggressive policies.

2. We use morphological operations and C−space reason-
ing to compute these transformations, subject to acces-
sibility (collision avoidance, for both AM and SM) and
support requirements (overhang avoidance, for AM).

3. We use an iterative deepening A* (IDA*) search algo-
rithm on this search space to identify cost-eﬀective pro-
cess plans with respect to a cost function that quantiﬁes

2

“wasted” (i.e., deposited and subsequently removed)
material throughout the process.

The conservative policy is deﬁned by “maximal” under-
ﬁlling (AM) and over-cutting (SM), i.e., getting as close as
possible to the target shape in a single greedy action, pre-
sented in [11] inspired by [22]. The aggressive policy, on the
other hand, aims to exploit the unique advantage of multi-
modal HM over uni-modal (AM-only or SM-only) process
plans; namely, over-ﬁlling (AM) and under-cutting (SM)
with “minimal” sacriﬁcial deviation from the target shape
to enable the action according to accessibility and support
requirements. The search space is thus constructed as a
tree, whose branching factor is determined by the number
of AM/SM capabilities, with two policy options per each.

To deﬁne workpiece transformations, we deﬁne AM/SM
actions as Boolean union/diﬀerence operations between the
intermediate workpiece shape and the actions’ material de-
position/removal ROIs, respectively:

• For SM, in the absence of an ordering on the motion
sets (e.g., a tool-path), we use rigorous set-theoretic
equations to implicitly deﬁne accessible regions in a
self-referencing manner. The removable region is de-
ﬁned as the ﬁxed point of a recursive deﬁnition, solved
iteratively until convergence is achieved.

• For AM, while accessibility is straightforward to com-
pute (without the need for iteration), the motion is
further constrained by overhang avoidance, deﬁned by
downward projection (i.e., ray tracing along gravity)

The set-theoretic formulations of accessibility (i.e., colli-
sion avoidance) and support (i.e., overhang avoidance) con-
straints are given in terms of Minkowski operations and
computed using fast Fourier transform (FFT) accelerated
convolutions on voxel representations.

Section 2 presents an overview of the approach, includ-
ing the groundwork from [11], its limitations, and how we
address them in this paper diﬀerently. Section 3 presents
the basic geometric operations for accessibility, collateral,
and support analysis. Section 4 presents the deﬁnition and
computation of AM/SM actions, using the said geometric
operations. In both of these sections, we present general set-
theoretic formulations that are independent of the choice of
representation scheme (e.g., B-reps or mesh). For compu-
tational purposes, we also present eﬃcient algorithms for
voxel-based representations. Section 5 presents the search
space, deﬁned in terms of actions, the cost function, and the
IDA* search algorithm for cost-eﬀective HM process plan-
ning. Section 7 presents a few examples in 3D that demon-
strate the eﬀectiveness of our approach. We conclude the
paper with ﬁnal remarks in Section 8.

2. Overview of the Approach

In this section, we review our earlier work in greater de-
tail along with its limitations (Section 2.1) and illustrate
how the new approach in this paper can overcome those
limitations (Section 2.2).

2.1. Background

In [11], we presented a set-theoretic formalism of HM pro-
cess plans with arbitrary part and tool shapes. The evolv-
ing state of a workpiece was modeled by a ﬁnite sequence

of 3D pointsets modiﬁed by AM/SM ‘actions’. Each ac-
tion was modeled by a set union/diﬀerence operation with
a corresponding AM/SM ‘primitive’, carried out by a sin-
gle AM/SM ‘capability’, respectively. An AM/SM capabil-
ity was deﬁned formally by the available machine degrees-
of-freedom (DOF) and minimum manufacturable neighbor-
hood (MMN). The corresponding AM/SM primitive could
be any region of space that is producible by sweeping an
MMN (e.g., solidiﬁed liquid droplets or melt-pools for cer-
tain AM and milling/turning tool inserts for certain SM)
along an available motion, restricted by DOF and colli-
sion avoidance (i.e., accessibility) constraints. The AM/SM
primitives could be viewed as overlapping volumes that
eventually make up the interior/exterior of the target shape,
respectively, as the workpiece evolves,
i.e., their proper
Boolean combination ultimately makes the ﬁnal shape.

Our formulation of HM actions and process plans in [11]
was inspired by (and extended) the ideas in [22], which ap-
plied to uni-modal machining process planning, and viewed
an SM process plan as a sequence of SM actions that took
out maximal removable volumes with given tools at diﬀerent
orientations. These volumes were computed for arbitrary
part and tool shapes using morphological operations [23],
which can be extended from Euclidean 3−space (e.g., for
3−axis milling) to higher-dimensional conﬁguration spaces
[25] (e.g., for high-axis turn-mill) using group morphology
[24, 27]. Due to the uni-modal nature of SM-only process
plans, the “maximality” is desirable as a greedy policy to
take out as much material as possible in a given ﬁxturing
setup for a given DOF and tool geometry. These process
plans are monotonic, meaning that a removed region by
one action cannot be brought back by a subsequent action,
which leads to a precise deﬁnition of maximality that must
constrain all SM actions. Moreover, these process plans are
permutative, meaning that the ﬁnal shape can be computed
by unifying all removable volumes, regardless of the order in
which they apply, and subtracting this union from the raw
stock. This realization enabled a neat separation of man-
ufacturability analysis (i.e., checking if the target shape is
achievable by order-agnostic Boolean operations) and pro-
cess planning (i.e., picking an order to optimize cost).

In [11], we deﬁned maximal depositable/removable re-
gion (MDR/MRR) for generalized HM capabilities deﬁned
by arbitrary motion DOF and MMN shapes, implemented
for 3−axis translational DOF. However, we encountered a
number of challenges to perform multi-modal manufactura-
bility analysis and process planning.

First, using MDR/MRR as AM/SM primitives for HM,
respectively, does not leverage the added freedom in non-
monotonic process plans, i.e., there is no reason to con-
strain the actions by maximality. In fact, the true power
of HM can be realized only if the actions are allowed to
over-ﬁll/under-cut with respect to the target shape, with
the ability to compensate by subsequent actions. Hence,
we need more sophisticated policies than the greedy ap-
proach, allowing for such actions.
In this paper, we de-
ﬁne two policies to choose from for every AM/SM action;
namely, a conservative policy that uses “maximal” under-
ﬁll/over-cut regions with respect to the target shape, as
before, and a new aggressive policy that allows for over-
ﬁll/under-cut with “minimal” sacriﬁcial deviation from the
target shape, assuming it can be compensated for by future
actions of opposite kind. We consider accessibility require-
ments for SM, by either avoiding collisions with the target

3

shape or incurring collateral damage to make the inacces-
sible regions accessible. We also consider accessibility re-
quirements for AM, by avoiding collisions with the current
workpiece shape, as well as support requirements for AM,
by either avoiding overhangs or adding sacriﬁcial support
material for AM.

Second, the loss of permutativity in multi-modal process
plans makes it diﬃcult to decouple manufacturability analy-
sis from process planning for HM. Unlike uni-modal process
plans, deﬁned by order-agnostic Boolean formulae, multi-
modal process plans are order-sensitive. In other words, the
ﬁnal shape cannot be determined from a given set of mixed
AM/SM primitives without specifying the order in which
they are applied. To mitigate this challenge in [11], we em-
ployed a canonical decomposition approach [26] to gener-
ate “atomic” regions of space from intersections of AM/SM
primitives and their complements. HM manufacturability
analysis was thus reduced to testing whether any subcollec-
tion of atoms, partitioning the 3D space, makes up the ﬁnal
shape (necessary condition) and if the disjunctive normal
form (DNF) implied by this subcollection is equivalent to
some Boolean formula in terms of AM/SM primitives that
represents valid process plans (suﬃcient condition). A key
advantage of this formulation was that all logical reasoning
occurred at a granularity determined by atoms rather than
much smaller geometric representation units (e.g., voxels).
It also enabled faster process planning via purely combina-
torial or logical manipulation of the ﬁnite Boolean formulae
(i.e., no geometric computations in the loop).

However, a major limitation of the above decoupling was
that it could not account for the evolution of C−space ob-
stacles. The C−space analysis used to precompute collision-
free AM/SM primitives that satisfy accessibility was based
on the target shape. Hence, the AM/SM actions deﬁned as
Boolean operations with such primitives may not be appli-
cable to the intermediate shapes of the workpiece, as the
C−space obstacle evolves as well. For example, for an SM
action to be applicable, there was an implicit assumption in
[11, 22] that the regions in an intermediate workpiece that
will not end up in the desired target shape—potentially in-
troducing additional accessibility constraints in the inter-
mediate actions—can be taken out by the same SM action
whose accessibility is being evaluated.

In this paper, we show that such an assumption is not
always valid and a proper analysis requires an iterative
process to solve a set-theoretic self-referencing deﬁnition.
Moreover, we embed such geometric computations within
the process planning to ensure accurate results with respect
to evolving accessibility conditions. Although this embed-
ding may result in a loss of computational eﬃciency (due
to geometric computations in the loop) compared to the
purely logical reasoning proposed in [11], the process plan-
ning can be sped up using iterative deepening techniques,
akin to what was originally used in [22].

2.2. Manufacturing Actions Revisited

Our approach to generating valid HM process plans
closely follows the deﬁnition of manufacturing primitives
given in [11] as “the best shot one can take using a single
(either AM or SM) capability, to transition from a given
state of the workpiece to a state that is closer to the tar-
get state, while respecting the manufacturing constraints
of that capability.” With this principal in mind, we seek

to generate process plans through a concatenation of valid
AM/SM actions, which are either conservative or aggressive
in their addition/removal of material, respectively.

For SM, ‘valid’ conservative and aggressive actions are

deﬁned, respectively, as follows:

• An over-cut (OC) action is a one-shot material removal
operation that removes as much excess material as pos-
sible from a given workpiece state without removing
any region that is inside the target state.

• An under-cut (UC) action is a one-shot material re-
moval operation that removes the entire excess material
from the given workpiece state, regardless of whether
it requires removal of additional regions that are inside
the target state.

The “excess” material in both deﬁnitions refers to material
that is inside the current state but outside the target state.
The removal of excess material and/or additional regions
are constrained by accessibility and MMN shape. More pre-
cisely, for a given target shape P ⊂ R3, current workpiece
shape (input state) Pi ⊂ R3, and tool shape T ⊂ R3, the
OC action removes as much of the excess material (i.e.,
maximal subset of Pi − P ) that is accessible by T , without
having to remove anything in P ∩ Pi. The UC action, on
the other hand, removes all material in Pi − P , including
the minimal amount of material (e.g., in volumetric terms)
in P ∩ Pi that enables the removability of Pi − P with T .
The next workpiece shape (output state) Po ⊂ R3 is con-
tained within the input state in both cases (i.e., Po ⊆ Pi),
however, the removed material is strictly outside the target
shape (i.e., (Pi − Po) ∩ P = ∅) in the case of OC—meaning
that there is no “collateral damage”—while minimal collat-
eral damage is tolerated in the case of UC such that all of
P c is removed (i.e., Po ⊆ P ).1

Similarly, for AM, ‘valid’ conservative and aggressive ac-

tions are deﬁned, respectively, as follows:

• An under-ﬁll (UF) action is a one-shot material deposi-
tion operation that deposits as much deﬁcit material as
possible onto the given workpiece state without adding
any region that is outside the target state.

• An over-ﬁll (OF) action is a one-shot material deposi-
tion operation that deposits the entire deﬁcit material
onto the given workpiece state, regardless of whether it
requires deposition of additional regions that are out-
side the target state.

The “deﬁcit” material in both deﬁnitions refers to material
that is inside the target state but outside the current state.
The deposition of deﬁcit material and/or additional regions
are constrained by accessibility and support requirements
(i.e., no overhang allowed). More precisely, for a given tar-
get shape P ⊂ R3, current part shape (input state) Pi ⊂ R3,
and tool shape T ⊂ R3, the UF action deposits as much of
the deﬁcit material (i.e., maximal subset of P − Pi) that is
accessible by T , as well as self-supporting for a given build
direction, without having to deposit anything in P c − Pi.
The OF action, on the other hand, deposits all material in
P − Pi, including as little material in P c as possible in order

1The superscript c means regularized set complement.

4

Figure 2: (a) The valid SM actions: OC and UC. (b) The valid AM actions: UF and OF. (c) An example (illustrative) process planning subtree.

to enable depositability of P − Pi with T . The next work-
piece shape (output state) Po ⊂ R3 contains the input state
in both cases (i.e., Pi ⊆ Po), however, the deposited mate-
rial is strictly inside the target shape (i.e., (Po − Pi) ⊆ P )
in the case of UF—meaning that there is no “sacriﬁcial
material”—while minimal sacriﬁcial material is tolerated in
the case of OF such that all of P is deposited (i.e., P ⊆ Po).
Figure 2 (a, b) illustrates the 4 types of actions for the
special case in which P is a raw stock in the case of SM and
nothing in the case of AM, leading to multiple branches in
the search tree, some of which are illustrated in Fig. 2 (c).
Despite the apparent duality between AM and SM ac-
tions, leading to a largely symmetric mathematical formu-
lation in terms of set union and diﬀerence (i.e., intersection
with complement), thanks to De Morgan’s laws, there are
a few symmetry breaking conditions.

First, the accessibility conditions imposed by the evolv-
ing part geometry are diﬀerent for AM and SM. Although
the addition of material during a given AM action gradually
enlarges the C−space obstacle and limits accessibility, it is
reasonable to assume that the motion for every AM action is
ordered in a layer-by-layer fashion along the build direction
and the print-head is always located above the previously
deposited layer in the same action. Hence, the accessibility
analysis based on the input state Pi of the workpiece remains
valid throughout the AM action. We can make similar as-
sumptions for SM motion ordering and the tool assembly so
the accessibility is improved gradually during the motions.
Hence, the C−space obstacle can be calculated based on the
outcome of the SM action, i.e., the output state Po of the
workpiece, which is unknown to begin with. Hence, the SM
action can only be deﬁned as a self-referencing set equation
that can be solved by ﬁxed point iteration.

Second, for AM technologies that are commonly used in
HM (e.g., DED laser cladding), there is an additional sup-
port constraint; namely, overhangs cannot be tolerated. For
every deposited point in the same AM action, every other

point beneath it must be present either in the input state
or deposited in the same action. For the latter, the layer-
by-layer ordering mentioned above ensures that the point
in question is supported.

3. Geometric Operations

In this section, after presenting the preliminary assump-
tions (Section 3.1), we discuss the geometric operations
to compute regions of 3D workspace that are accessi-
ble/inaccessible for both AM and SM (Section 3.2), make
the inaccessible regions accessible with minimal-collision
collateral damage for SM (Section 3.3), and represent self-
supporting min/max bounds for AM (Section 3.4).

3.1. Preliminaries

We consider the state space (which contains the initial,
intermediate, and target states) to be the collection of all
bounded solids or ‘r-sets’, i.e., compact regular semianalytic
sets in R3 [28]. For each action, Pi, Po ⊂ R3 represent the
input and output states, respectively, while the target state
is given by P ⊂ R3. The tool assemblies (hereafter referred
to as tools, for short) are also assumed to be solids. All
operations on solids will be assumed to be regularized [29].
Each AM or SM tool T = K ∪ H consists of two portion;
namely, a passive portion H that represents a large moving
object that must avoid collision with stationary objects (i.e.,
the part and ﬁxtures, if applicable); and an active portion K
that represents the unit of deposition/removal, i.e., a min-
imum manufacturable neighborhood (MMN) whose sweep
along the motion characterizes the deposited/removed ma-
terial for each AM/SM action, respectively. For SM tools,
the passive portion often consists of milling/turning tool
shank, holder, spindle, and other head components, while
the active portion is the sharp edge of a cutter or tool insert.

5

For AM tools, the passive portion can be a powder/wire-
feeder, droplet jetting nozzle, and other print-head compo-
nents, while the active portion may be deﬁned in terms of a
representative solidiﬁed droplet or melt-pool shape. Given
the recent advancements in the resolution of AM processes,
we ignore the minimum feature size requirement for the AM
actions and assume T ≈ H for accessibility analysis, while
the minimum feature size/shape for SM is encoded into the
accessibility analysis, as we note in Section 3.2.

Note that the motion is relative, hence we assume, with-
out loss of generality, that the workpiece is ﬁxed and the
tool moves, while in reality it might be the opposite or both
may move. To simplify the analyses, we assume that each
tool is oriented with respect to the workpiece by a ﬁxed
rotation R ∈ SO(3) and the motion DOF after that is re-
stricted to 3−axis translations t ∈ R3. Note that for AM,
assuming the print-head always faces downwards, the rela-
tive tool rotation by R implies changing the build direction
by applying an opposite rotation R−1 to the part (e.g., re-
ﬁxturing), hence the gravity direction changes from vertical
(0, 0, −1) to R−1(0, 0, −1) for support analysis. For SM, on
the other hand, it does not matter how we interpret the
rotation, i.e., as rotating the head, the workpiece, or a com-
bination of the two on a high-axis CNC machine, as long
as the rotation remains ﬁxed throughout each action. The
choice of an optimal direction for both AM and SM will be
incorporated into our search algorithm in section 5 by ex-
ploring a subset of the possible relative rotations of a given
workpiece at each step of the process plan.

In each section, in addition to the set-theoretic formu-
lation, we present the numerical algorithms to compute
a Cartesian volumetric enumeration (i.e., voxelization) of
the pointsets, although other representation schemes (e.g.,
B-reps or mesh) can be used as long as the Boolean and
Minkowski operations are supported. More speciﬁcally, we
present algorithms for computing discretized indicator func-
tions (i.e., 3D binary-valued voxel arrays) and will denote
such arrays using characteristic functions enclosed in brack-
ets (e.g., [1X ]); real-valued arrays resulting from discrete
convolutions will be denoted similarly, e.g., [1X ∗ 1Y ] =
Conv(cid:0)[1X ], [1Y ](cid:1), were Conv is FFT-based discrete con-
volution that can be GPU-accelerated.

3.2. Accessibility Analysis

For a given (AM or SM) tool T ⊂ R3 and an obstacle
pointset O ⊂ R3 with which it must avoid collisions,2 we
deﬁne the translational C-space obstacle (cid:79)(O, T, R) ⊆ R3
to be the set of translations t ∈ R3 of the rotated tool RT
that collide with the obstacle pointset O:

(cid:79)(O, T, R) (cid:44) (cid:8)t ∈ R3 | O ∩ (RT + t) (cid:54)= ∅(cid:9).

(1)

With this deﬁnition in place, the set of non-colliding (i.e.,
accessible) translations is (cid:79)(O, T, R)c. The translational
C−space can be computed via a Minkowski sum:3

(cid:79)(O, T, R) ae= O ⊕ (−RT ).

(2)

2To simplify the notation, we will assume that O := Pi (for AM)
or Po (for SM), but one can incorporate additional objects in the
environment (e.g., ﬁxtures) in the obstacle set.

3Some of these equalities do not strictly hold upon regularization
when the C−space obstacle has lower-dimensional features, but we
shall ignore such degenerate cases. The drawback is that the technique
may not be robust in such cases, e.g., when the target shape has a
cylindrical hole that has exactly the same diameter as a milling tool.

Figure 3: A depiction of the milling tool in its local coordinate system
(left) along with the target part shape (middle), the accessible region
A, and the inaccessible region I for identity rotation R := id.

Given a minimum manufacturable neighborhood (MMN)
K ⊂ R3, the set of points in the 3D workspace that can be
touched (i.e., deposited or removed) by sweeping the MMN
along an accessible motion is:

A(O, T, K, R) (cid:44) (cid:79)(O, T, R)c ⊕ (RK)

= (cid:0)O ⊕ (−RT )(cid:1)c
⊕ (RK)
= (cid:0)Oc (cid:9) (−RT )(cid:1) ⊕ (RK),

(3)

(4)

(5)

where the second equality results from the duality between
Minkowski sum ⊕ and diﬀerence (cid:9) as a result of De Mor-
gan’s laws [23]. We call this pointset “accessible” by the
rotated tool RT with respect to the obstacle pointset O.
The inaccessible region, on the other hand, is simply de-
ﬁned by the remaining portion of Oc:

I(O, T, K, R) (cid:44) Oc − A(O, T, K, R).

(6)

Figure 3 illustrates the accessible A and inaccessible I
regions for a target shape P , used (initially) as the obstacle
set O := P , and an SM tool T = H ∪ K in 2D.4

To compute the C−space obstacles eﬃciently, we note
the correspondence between Minkowski and convolution al-
gebras [27, 30]. If we represent a pointset X ⊆ R3 implicitly
via its indicator (i.e., characteristic) function:

1X (x) (cid:44)

(cid:26) 1
0

if x ∈ X,
otherwise,

(7)

then we may represent the Minkowski sum of two pointsets
implicitly as the convolution of their indicator functions:

1X⊕Y (x) > 0

ae(cid:10) (1X ∗ 1Y ) (x) > 0,

(8)

which can be computed eﬃciently via fast Fourier trans-
form (FFT) when the indicator functions are sampled over
a uniform Cartesian grid (i.e., the pointsets are voxelized).
The translational C−space obstacle in (2) is thus com-

putable as follows:

1(cid:79)(O,T,R)(x) ae= sign(1O ∗ ˜1RT )(x),

(9)

where ˜1X (x) = 1X (−x) represents a reﬂection with respect
to the origin. The accessible translations are computable by

4Throughout the paper, we use simple 2D examples for illustrative
purposes. The simplicity of such shapes (e.g., straight line boundaries)
is incidental, and does not imply any such limitations in practice, as
we show in Section 7 for 3D parts and tools of arbitrary shapes.

6

a logical negation: 1(cid:79)(O,T,R)c(x) = ¬1(cid:79)(O,T,R)(x). Hence,
the accessible region in (5) can be computed as:

1A(O,T,K,R)(x) ae= sign(¬1(cid:79)(O,T,R) ∗ 1RK)(x)

= sign

(cid:16)(cid:0)¬sign(1O ∗ ˜1RT )(cid:1) ∗ 1RK

(cid:17)

(x).

(10)

The inaccessible region in (6) is thus computed as:

1I(O,T,K,R) = ¬1O(x) − 1A(O,T,K,R)(x),

(11)

noting that 1A(O,T,K,R)(x) ≤ 1Oc(x) = ¬1O(x) because
A(O, T, K, R) ⊆ Oc.

Algorithms 1 and 2 describe how the accessible and inac-
cessible regions are computed, respectively, for a given (i.e.,
explicitly known) obstacle pointset. In Sections 4.1.1 and
4.1.2, we show how these algorithms can be used to compute
such regions when the obstacle pointsets are not explicitly
known, but are implicitly deﬁned through recursion.

Algorithm 1 Computing accessible region

procedure Accessible([1O], [1T ], [1K], R)

[1RK] ← Rotate(cid:0)[1K], R(cid:1)
[1RT ] ← Rotate(cid:0)[1T ], R(cid:1)
[˜1RT ] ← Reflect(cid:0)[1RT ](cid:1)
[1(cid:79)] ← Conv(cid:0)[1O], [˜1RT ](cid:1) > 0
[1A] ← Conv(cid:0)¬[1(cid:79)], [1K](cid:1) > 0
return [1A]
end procedure

(cid:46) Elementwise sign
(cid:46) Elementwise sign

Algorithm 2 Computing inaccessible region

procedure Inaccessible([1O], [1T ], [1K], R)

return ¬[1O] − Accessible(cid:0)[1O], [1T ], [1K], R(cid:1)

end procedure

3.3. Collateral Analysis

Let x ∈ I(O, T, K, R) be a point (called a ‘query’ point) in
the inaccessible region with respect to an obstacle pointset
O and an SM tool T = H ∪ K. Let us consider all possible
ways in which any point in the cutter k ∈ K that can remove
material (called a ‘sharp’ point [31]) can be brought into
contact with the query point. Our goal is to identify the
sharp point, using which the collision between the tool in
this conﬁguration and the obstacle set is minimized in some
way (e.g., in terms of volume). The union of such regions
over all inaccessible query points, intersected with the target
shape P , characterizes minimal “collateral damage” in the
sense that it is as little material as we need to remove inside
the target shape to make all those query points accessible.
This material has to be brought back later by an AM tool.
Let ρCMF(x, k; P, T, R) stand for the bi-variate collision
measure ﬁeld (CMF) between the target shape P and the
SM tool T rotated by R and translated in such a way the the
sharp point k ∈ K is brought into contact with the query
point x ∈ I(O, T, K, R). The CMF can thus be computed
as an intersection measure:

where µ3[·] denotes the Lebesgue 3−measure (i.e., volume).
The sharp point that results in minimal CMF for a given
query point x ∈ I(O, T, K, R) is thus given by:

kmin(x; P, T, K, R) (cid:44) arg min

k∈K

ρCMF(x, k; P, T, R),

(13)

It is possible that the result is not unique, i.e., more than
one sharp point exhibit the same minimal collision volume.
In that case, we may assume an arbitrary total ordering
(K, ≺) to prioritize between kmin ≺ k(cid:48)
min if both result in a
minimal CMF.

Note that R(T − k) + x in (12) indicates translating the
tool to bring the sharp point to the origin, applying a ro-
tation R, and translating the tool once again to take the
sharp point from the origin to the query point, where its
intersection with the target shape is measured. The total
translation is thus obtained as:

tmin(x; P, T, K, R) (cid:44) x − Rkmin(x; P, T, K, R).

(14)

The minimal-collision collateral damage for a single query
point can be obtained by intersecting the moved tool (using
the rotation R and the above translation) with the target
shape P . The union of all such intersections over all inac-
cessible query points yields:

C(O, P, T, K, R) = P ∩

(cid:91)

(cid:0)RT + tmin(x)(cid:1)

x∈I(O,T,K,R)
(cid:91)

= P ∩

R(cid:0)T − kmin(x)(cid:1) + x.

(15)

x∈I(O,T,K,R)

where the arguments in tmin(x) = tmin(x; P, T, K, R) are
dropped to simplify the notation, and the common inter-
section is factored out of the union.

For computational purposes, it is more practical to in-
vert the dictionary look-up from query points to the cor-
responding minimal-collision sharp points in (13). For a
given sharp point k ∈ K, let Q(k; O, P, T, K, R) stand for
the subset of all inaccessible points x ∈ I(O, T, K, R) for
which k = kmin(x; P, T, K, R). This condition can be re-
placed with the following equality test:

ρCMF(x, k; O, T, R) == min
k∈K

ρCMF(x, k; O, T, R),

(16)

only if the minimal-collision sharp point for every query
point is unique, which may not be the case. To mitigate
the non-uniqueness, the above condition can be conjuncted
with an additional condition that the query point was not
already accounted for in a higher-priority sharp point with
the same CMF, i.e., by excluding Q(k) from Q(k(cid:48)) if k ≺ k(cid:48),
to avoid double-counting.

Using the inverted deﬁnition, the pointset in (15) can be

alternatively computed as follows:

C(O, P, T, K, R) = P ∩

= P ∩

(cid:91)

(cid:16)

k∈K
(cid:16)
(cid:91)

k∈K

R(T − k) +

(cid:91)

x
x∈Q(k)

(cid:17)

R(T − k) ⊕ Q(k)

(cid:17)

,

(17)

ρCMF(x, k; P, T, R) (cid:44) µ3(cid:104)

P ∩ (cid:0)R(T − k) + x(cid:1)(cid:105)

,

(12)

where the arguments in Q(k) = Q(k; O, P, T, K, R) are once
again dropped to simplify the notation.

7

To compute the CMF deﬁned in (12) eﬃciently, we can

use the convolution operator as follows:

ρCMF(x, k; P, T, R) ae= (cid:0)1P ∗ 1R(T −k)

(cid:1)(x),

(18)

The Minkowski sum, union, and intersection in (17) can
also be implicitly computed as a convolution, summation,
and multiplication, respectively:

1C(x) ae= 1P (x) · sign

1R(T −k) ∗ 1Q(k)(x)

,

(19)

(cid:33)

(cid:32)

(cid:88)

k∈K

where we use C = C(O, P, T, K, R) to simplify notation.

Algorithm 3 describes the computation of the minimal-
collision collateral damage. The discretization of indicator
functions and CMF, denoted by the brackets [·], is with re-
spect to the query point x ∈ R3 indexed over a uniform
Cartesian grid, while the sharp points k ∈ (K, ≺) are sam-
pled and ordered for a sequential for-loop. For all practical
purposes, sampling only on the exposed sharp edges of the
boundary ∂K is suﬃcient. The algorithm uses the subrou-
tine Inaccessible([1O], [1T ], [1K], R) from Algorithm 2.

Algorithm 3 Calculating collateral region

procedure Collateral([1O], [1P ], [1T ], [1K], R)

[1C] ← [1∅]
[1RT ] ← Rotate(cid:0)[1T ], R(cid:1)
for k in K do

[1R(T −k)] ← Translate(cid:0)[1RT ], −Rk(cid:1)
[ρCMF(k)] ← Conv(cid:0)[1P ], [1R(T −k)](cid:1)

CMF] ← mink∈K[ρCMF(k)]

end for
[ρmin
[1I ] ← Inaccessible ([1O], [1T ], [1K], R)
for k ∈ K do
[1Q(k)] ←
(cid:16)

(cid:16)
[1C] + Conv(cid:0)[1Q(k)], [1R(T −k)](cid:1)(cid:17)

[ρCMF] == (cid:2)ρmin

· [1I ]

(cid:3) (cid:17)

CMF

[1C] ←
[1I ] ← [1I ] − [1Q(k)]

> 0

(cid:46) Avoids double-counting

end for
[1C] ← [1C] · [1P ]
return [1C]
end procedure

Figure 4 illustrates the pointsets A, I, and C for an ex-
ample target part P and SM tool T = H ∪ K in 2D, with a
sampling of sharp points over the boundary of K.

3.4. Support Analysis

To simplify the accessibility analysis, we assume that the
AM tool cannot tolerate overhangs, i.e., the slightest de-
viation from a vertical wall would create problems. While
many AM processes can handle overhang angles up to a
certain value (e.g., 45◦ is a commonly used threshold), the
ones that are most commonly used in HM scenarios (e.g.,
DED/DMD for laser-based cladding) require fairly straight
walls. This assumption makes it simpler and faster to
compute well-deﬁned self-supporting regions that are either
maximally contained within or minimally contain the target
shape, as depicted in Fig. 2 (b).5

5If overhangs below a certain nonzero angle are tolerated, there is

no straightforward way to deﬁne such max/min pointset uniquely.

8

Figure 4: A depiction of the various sharp points k ∈ K along the
cutter edge which may be brought in contact with the query point
x ∈ Oc, along with a depiction of the accessible A, inaccessible I, and
minimal-collision collateral regions C.

Let x ∈ R3 be a query point for which we aim to perform

support analysis against a target shape P .

Let us ﬁrst consider the set of self-supporting points
U (P, R) ⊂ R3 that are maximally contained within the tar-
get shape P .
If x ∈ P , then it can be printed without
extra support material (i.e., material outside P ) if and only
if a straight half-line drawn downwards (i.e., along gravity)
from the query point remains completely inside P before
reaching the build plate. This condition can be stated as:
x ∈ U (P, R) (cid:10) µ1(cid:2)P ∩ (x + RL)(cid:3) = (x − xB) · (Rez), (20)

where ez = (0, 0, 1) is the unit vector along the z−axis,
and the build direction is given by the rotation R of the
AM tool, i.e., rotation R−1 of the workpiece for an AM tool
facing downwards along the negative z−axis. If our frame of
reference is the workpiece, we can imagine the direction of
gravity changing to −Rez. L (cid:44) {αez | α ≤ 0} is an inﬁnite
half-line along the negative z−axis, xB ∈ R3 is any point
on the surface of the build plate, and µ1[·] is the Lebesgue
1−measure (i.e., length). The rotated and displaced half-
line x + RL stems out of the query point along the direction
of gravity.
If the length of its portion falling inside the
pointset P is the same as the height of the query point
above the build plate along the build direction, then the
query point is included in U (P, R). In fact, every point on
the line segment P ∩ (x + RL), including the query point,
can be printed without the need for extra support. On the
other hand, if any portion of the segment falls external to
the target shape, the length of the external segment P c −
(x+RL) will be smaller, hence the external segment must be
printed with excess material to support the internal segment
P ∩ (x + RL), including the query point.

Let us next consider the set of self-supporting points
V (P, R) ⊂ R3 that minimally contain the target shape P .
If x ∈ P c, then it must be printed as extra support material
(i.e., material outside P ), if and only if a straight half-line
drawn upwards (i.e., against gravity) from the query point
intersects P . This condition can be stated as:

x ∈ V (P, R) (cid:10) µ1(cid:2)P ∩ (x + (−RL))(cid:3) > 0,

(21)

meaning that there exists a segment of the half-line P ∩(x+
(−RL)), stemming out of the query point against the direc-
tion of gravity, that intersects the target shape. Hence, the
query point must be printed as excess material to support
the said segment. On the other hand, if the half-line does

not intersect with the target shape, the length of the seg-
ment P ∩ (x + (−RL)) will be zero, hence the query point
does not support anything and need not be printed. Note
that U (P, R) ⊆ P ⊆ V (P, R).

To compute the above max/min pointsets eﬃciently, we
can replace the half-line L with an inﬁnitesimally thin cylin-
der L(cid:15) (cid:44) L ⊕ [−(cid:15)/2, +(cid:15)/2]3 where (cid:15) → 0+, hence replace the
1−measure in the above equations with a 3−measure:

x ∈ U (P, R)

ae(cid:10) lim

(cid:15)→0+

1

(cid:15)2 µ3(cid:2)P ∩ (x + RL(cid:15))(cid:3) = h(x; R),

(22)

1

(cid:15)→0+

ae(cid:10) lim

x ∈ V (P, R)

(cid:15)2 µ3(cid:2)P ∩ (x + (−RL(cid:15)))(cid:3) > 0, (23)
where h(x; R) (cid:44) (x − xB) · (Rez) is the height ﬁeld for the
build direction speciﬁed by R. The intersection measures
can, once again, be computed via convolutions:
(cid:105)
1
(cid:15)2 (1P ∗ ˜1RL(cid:15))(x) == h(x; R)
(cid:105)
1
(cid:15)2 (1P ∗ 1RL(cid:15))(x) > 0

1V (P,R)(x) ae=

1U (P,R)(x) ae=

lim
(cid:15)→0+

lim
(cid:15)→0+

, (24)

(25)

(cid:104)

(cid:104)

.

For discretized shapes over a uniform Cartesian grid of
voxels of edge length (cid:15) > 0, the above formulae can be
approximated by discrete convolutions Conv(cid:0)[1P ], [˜1RL(cid:15)](cid:1)
(Algorithm 4) and Conv(cid:0)[1P ], [1RL(cid:15) ](cid:1) (Algorithm 5), re-
spectively, in which the arrays [1L(cid:15)] and [˜1L(cid:15)] represent
vertical half-columns of a single voxel thickness, extending
downwards and upwards from the origin, respectively.

Algorithm 4 Computing maximal self-supported region

procedure MaxSelfSupp([1P ], R, xB)

(cid:1) · (Rez)
[h] ← (cid:0)[x] − xB
[1L(cid:15) ] ← CreateDHC()
[1RL(cid:15)] ← Rotate(cid:0)[1L(cid:15)], R(cid:1)
[˜1RL(cid:15)] ← Reflect(cid:0)[1RL(cid:15)](cid:1)
return Conv(cid:0)[1P ], [˜1RL(cid:15) ](cid:1) == [h]

(cid:46) Discretized height ﬁeld
(cid:46) Downward half-column

(cid:46) Tested up to some numerical error tolerance

end procedure

Algorithm 5 Computing minimal self-supported region

procedure MinSelfSupp([1P ], R, xB)

[h] ← (cid:0)[x] − xB
(cid:1) · (Rez)
[1L(cid:15) ] ← CreateDHC()
[1RL(cid:15)] ← Rotate(cid:0)[1L(cid:15)], R(cid:1)
return Conv(cid:0)[1P ], [1RL(cid:15) ](cid:1) > 0

(cid:46) Discretized height ﬁeld
(cid:46) Downward half-column

end procedure

Figures 5 and 6 illustrate the max/min self-supporting
regions, respectively, for a simple example in 2D, for upward
build direction (i.e., R := id).

4. Manufacturing Actions

Having deﬁned and implemented the basic building blocks
(namely, accessibility, collateral, and support analyses) in
the previous section, we deﬁne the SM (OC/UC) (Section
4.1) and AM (UF/OF) (Section 4.2) actions precisely to
deﬁne the actions for the HM process planning search space.

9

Figure 5: A depiction of the maximal self-supporting region U con-
tained within a target shape P , starting from an empty build plate.

Figure 6: A depiction of the minimal self-supporting region V con-
taining a target shape P , starting from an empty build plate.

4.1. SM Actions

With the accessible, inaccessible, and collateral regions
deﬁned, we can precisely formulate the valid SM actions ac-
cording to our conservative and aggressive policies; namely,
under-cut (UC) and over-cut (OC), respectively.

While the accessibility analysis in Section 3.2 provides the
accessible translations for an SM tool T against a ﬁxed ob-
stacle pointset O, it cannot readily address the removability
of material from a given workspace state Pi, since it does
not account for the evolution of the workpiece geometry and
the resulting changes in accessibility throughout the con-
tinuous SM action. In other words, the resulting workpiece
state after taking out the removable region A(O, T, K, R),
deﬁned in (5) and (10) with respect to accessibility and
MMN, depends on the obstacle pointset O := Po, which, in
turn, depends on the resulting workpiece state, leading to
a self-referencing set equation. We will solve the equation
recursively by ﬁxed point iteration.

To gain some intuition about this process, consider a typi-
cal 3−axis milling process, the tool TSM mills away material
in multiple passes. At every pass, the accessibility changes
as the C−obstacle is shaved oﬀ. One possible solution is
to repeat the accessibility analysis at every pass to com-
pute the allowable conﬁgurations of the tool for the next
pass. Such computations would be prohibitively ineﬃcient,
because the depth of material removed in each pass cannot
exceed that of the MMN (e.g., cutter depth), which may
be quite small compared to the excess material region, as
depicted in Fig. 7. Alternatively, we take a “backward”
iteration approach, formalized by an iterative solution of
a self-referencing equation. This approach converges more
quickly since each pass removes material on the order of the
length of the entire tool. We elaborate how it works for the
OC and UC cases in detail below.

Algorithm 6 describes the recursive method used to com-
pute the OC output. The algorithm uses the subroutine
Accessible([1O], [1T ], [1K], R) from Algorithm 1.

Algorithm 6 Computing OC output

procedure OverCut([1P ], [1Pi], [1T ], [1K], R)

[1O] ← [1∅]
[1Po ] ← [1P ]
while [1O] (cid:54)= [1Po] do

[1O] ← [1Po ]
[1A] ← Accessible([1O], [1T ], [1K], R)
[1Po ] ← [1Pi] − [1A]

end while
return [1Po]
end procedure

4.1.2. Under-Cut Actions

As described at the beginning of section 2.2, a UC action
removes all of the material from the region Pi−P , while min-
imizing the collateral damage, i.e., material removed from
P to make all of Pi − P removable.

Let Po represent the output of the UC action whose inputs
are the target shape P , the current shape (before the action)
Pi, the SM tool T = H ∪ K with passive part H (e.g., the
holder) and active part K (e.g., the cutter), oriented with
a ﬁxed rotation R. The output pointset must satisfy the
following set equation:

Po = Po − C(Po, P, T, K, R).

(29)

This equation means that the output of the UC action is
itself treated as the obstacle pointset O := Po, against which
the collateral region C(O, P, T, K, R) is computed, whose
removal from the input state Pi results in the output state
Po. Once again, this equation can be solved recursively until
its ﬁxed point is found.

We begin the iterative process with an initial overesti-
mation of the obstacle pointset O0 := Pi ∩ P , noting that
the UC policy, by deﬁnition, will result in an outcome
O = Po that is contained in O0. However, in order for
O0 := Pi ∩ P to be accessible by the tool, the collateral
region C0 := C(O0, P, T, K, R) must ﬁrst be removed; the
UC output is thus overestimated as O1 := O0 − C0. Simi-
larly, in order for O1 to be accessible, the collateral region
C1 := C(O1, P, T, K, R) must be removed as well, yielding
a slightly better overestimation O2 := O1 − C1. Proceeding
with this iteration, one ends up with a monotonically de-
creasing sequence of obstacle pointsets overestimating the
UC output, lower-bounded by the true region:

O0 ⊇ O1 ⊇ · · · ⊇ O = UC(Pi, P, T, K, R),

(30)

where Po = UC(Pi, P, T, K, R) represents the converged so-
lution for the UC output. Note that by construction, the
ﬁxed point of recursion (i.e., the pointset to which the iter-
ation converges) obeys the identity in (29).

Algorithm 7 describes the recursive method used to com-
pute the UC output. The algorithm uses the subrou-
tine Collateral([1O], [1P ], [1T ], [1K], R) from Algorithm
3. Our experience shows that both iterative procedures con-
verge after a few iterations, as depicted in Fig. 8.

Figure 7: Given an ordering on the motion (e.g., a tool path), the
obstacle set evolution can be accounted for incrementally, e.g., the
obstacle for each vertical pass is the target shape minus the excess
material removed in the previous vertical passes, which is expensive.

4.1.1. Over-Cut Actions

As described at the beginning of section 2.2, an OC action
removes as much material from the region Pi −P as possible,
while avoiding any material removal from P ∩ Pi.

Let Po represent the output of the OC action whose inputs
are the target shape P , the current shape (before the action)
Pi, the SM tool T = H ∪ K with passive part H (e.g., the
holder) and active part K (e.g., the cutter), oriented with
a ﬁxed rotation R. The output pointset must satisfy the
following set equation:

Po = Pi − A(Po, T, K, R).

(26)

This equation means that the output of the OC action is it-
self treated as the obstacle pointset O := Po, against which
the accessible region A(O, T, K, R) is computed, whose re-
moval from the input state Pi results in the output state Po.
Obviously, due to the complex algebraic form of the formula
for A(Po, T, K, R) in terms of two embedded Minkowski
sums in (5) or convolutions in (10), the above equation can-
not be solved by algebraic manipulation. But it can be
solved recursively until its ﬁxed point is found.

We begin the iterative process by an initial underestima-
tion of the obstacle pointset O0 := Pi ∩ P , noting that the
OC policy, by deﬁnition, will result in an outcome O = Po
that contains O0. In other words, A0 := A(O0, T, K, R) is
an overestimation of the accessible region, as it does not ac-
count for tool collisions with the inaccessible region O − O0.
The OC output is thus underestimated as O1 := Pi − A0,
providing a slightly better overestimation of the accessible
region A1 := A(O1, T, K, R), hence a slightly better under-
estimation of the OC output O2 := Pi − A1, and so on.
Proceeding with this iteration, we obtain a monotonically
decreasing sequence of pointsets overestimating the accessi-
ble region, upper-bounded by the true region:

A0 ⊇ A1 ⊇ · · · ⊇ A = A(Po, T, K, R),

(27)

and a monotonically increasing sequence of pointsets un-
derestimating the OC output (and the true obstacle set),
lower-bounded by the true region:

O0 ⊆ O1 ⊆ · · · ⊆ O = OC(Pi, P, T, K, R),

(28)

where Po = OC(Pi, P, T, K, R) represents the converged so-
lution for the OC output. Note that by construction, the
ﬁxed point of recursion (i.e., the pointset to which the iter-
ation converges) obeys the identity in (26).

10

Figure 8: The iterative processes to determine OC and UC regions. Unlike the accessibility analysis in Fig. 3, one must use an iterative approach
to determine what parts of the excess material can be milled since the excess material itself may obstruct the tool from accessing deeper portions
of the excess material. The iterative process converges in two steps, in this particular case.

Algorithm 7 Computing UC output

procedure UnderCut([1P ], [1Pi], [1T ], [1K], R)

[1O] ← [1∅]
[1Po] ← [1P ]
while [1O] (cid:54)= [1Po ] do

[1O] ← [1Po]
[1C] ← Collateral([1O], [1P ], [1T ], [1K], R)
[1Po] ← [1Pi] − [1C]

end while
return [1Po ]
end procedure

4.2. AM Actions

With the accessible, inaccessible, and support regions de-
ﬁned, we can precisely formulate the valid AM actions ac-
cording to our conservative and aggressive policies; namely,
under-cut (UC) and over-cut (OC), respectively.

The accessibility constraint is easier to enforce in the case
of AM, assuming that the deposition occurs in a bottom-
up fashion and the print-head stays on the opposite half-
space of what it has deposited at any given time. Hence, it
suﬃces to use the input shape as the obstacle set O := Pi to
obtain the accessible region A(Pi, T, K, R) from (5) without
a need for iteration. As mentioned earlier, for an AM tool
T = H ∪ K, we can ignore collisions of previously deposited
layers with the incoming material (abstracted by K) in the
accessibility analysis, i.e., approximate the accessible region
with A(Pi, H, ∅, R) = (Pi ⊕ (RH))c = P c

i (cid:9) (RH).6

6A more general formula is A(Pi, H, {k}, R) = (P c

i (cid:9) (RH)) + k in
which the active portion is approximated by a single point where the
tool (e.g., nozzle) tip is located. We assume k := (0, 0, 0).

11

In addition to accessibility, we need to consider support
requirements (i.e., overhang avoidance) leading to conser-
vative (UF) and aggressive (OF) policies, explained below.
However, there is a nontrivial coupling between support
analysis and accessibility. Given a max/min self-supporting
pointset U (P, R) or V (P, R) for a build direction deﬁned
by R, and an accessible pointset A, one might think the
intersection of the two produces a pointset that is both ac-
cessible and max/min self-supporting. However, this is not
true, because the intersection may lose the self-supporting
property (i.e., have overhangs). To correct for this eﬀect,
we need to modify the accessible region as follows, to obtain
its maximal subset that is self-supporting:

A∗(O, T, K, R) (cid:44) U

(cid:16)

V (O, R)∪A(O, T, K, R), R

(cid:17)

−V (O, R).

(31)
Note that A∗ ⊆ A, therefore, any point x ∈ A∗ is not only
accessible (i.e., x ∈ A) but also supported by a line segment
(x + RL) ⊂ A∗. As a result, this is the maximal subset of A
whose intersection with max/min self-supporting pointsets
does not spoil their self-supported property. Accordingly,
the modiﬁed inaccessible region can be computed as:

I ∗(O, T, K, R) (cid:44) Oc − A∗(O, T, K, R).

(32)

4.2.1. Under-Fill Action

As described at the beginning of Section 2.2, a UF action
deposits as much material into the region P −Pi as possible,
while avoiding any material deposition into P c − Pi.

Let Po represent the output of the UF action whose inputs
are the target shape P , the current shape (before the action)
Pi, the AM tool T = H ∪ K with passive part H (e.g., the
nozzle) and active part K (e.g., the droplet), oriented with
a ﬁxed rotation R. For the special case in which Pi := ∅,

the output is given by Po = V (P, R). If Pi
modiﬁcations are necessary.

(cid:54)= ∅, two major

First, a nonempty Pi imposes an accessibility constraint.
We argued earlier that accessibility can be approximated via
A = P c
i (cid:9) (RH), which must be modiﬁed via (31) to A∗ =
U (V (Pi, R) ∪ A, R) − V (Pi, R). Hence, the ﬁrst argument
in Po = V (P, R) must be replaced with P ∩ A∗ to test the
half-line intersection measure in (20) against the accessible
and self-supporting subset P ∩ A∗ of the target shape P :

P (cid:48)
o

(cid:44) Pi ∪ U

(cid:16)

P ∩ A∗(Pi, H, ∅, R), R

(cid:17)

.

(33)

Second, the intersection measure test in (20) needs to be
modiﬁed. Assuming the input shape is solidiﬁed, there is
no need for the entire line segment x + (−RL) to fall inside
P ∩ A∗. It is suﬃcient to look only at the portion of the line
that is above the input shape Pi, i.e., the overhangs of the
input Pi can be ignored. This eﬀect can be easily achieved
by replacing P ∩A∗ with (P ∩A∗)∪V (Pi, R) in the argument
of the V function, and removing V (Pi, R) from the result:
(cid:16)(cid:0)P ∩A∗(Pi, H, ∅, R)(cid:1)∪V (Pi, R), R

(cid:20)
Po (cid:44) Pi∪

(cid:21)
.
−V (Pi, R)

U

(cid:17)

(34)
Figure 9 (a) illustrates how the U and V functions, alongside
original and modiﬁed accessible and inaccessible regions, are
used to compute the UF action’s output.

The implicit form of (34) is obtained by replacing the
Boolean union,
intersection, and diﬀerence with sign of
summation, multiplication, and multiplication with negated
value, respectively, of the indicator functions. The discrete
form (via 3D voxel arrays) is implemented in Algorithm 8.

Algorithm 8 Computing UF output

procedure UnderFill([1P ], [1Pi], [1H ], [1K], R, xB)

(cid:1)

[1A] ← Accessible(cid:0)[1Pi], [1H ], [1∅], R(cid:1)
[1A∗ ] ← MaxSelfSupp(cid:0)[1A], R, xB
[1P ∗ ] ← [1P ] · [1A∗ ]
[1V ] ← MinSelfSupp(cid:0)[1Pi], R, xB
[1E] ← sign(cid:0)[1P ∗ ] + [1V ](cid:1)
[1U ] ← MaxSelfSupp(cid:0)[1E], R, xB
(cid:1)
[1Pi] + (cid:0)[1U ] · ¬[1V ](cid:1)(cid:17)
return sign
end procedure

(cid:16)

(cid:1)

4.2.2. Over-Fill Action

As described at the beginning of section 2.2, an OF action
deposits all of the material into the region P − Pi, while
minimizing the sacriﬁcial support, i.e., material deposited
into P c to make all of P − Pi depositable.

Let Po represent the output of the OF action whose inputs
are the target shape P , the current shape (before the action)
Pi, the AM tool T = H ∪ K with passive part H (e.g., the
nozzle) and active part K (e.g., the droplet), oriented with
a ﬁxed rotation R. For the special case in which Pi := ∅,
the output is given by Po = U (P, R). If Pi
(cid:54)= ∅, two major
modiﬁcations are necessary.

First, a nonempty Pi imposes an accessibility constraint.
We argued earlier that accessibility can be approximated via
A = P c
i (cid:9) (RH), which must be modiﬁed via (31) to A∗ =
U (V (Pi, R) ∪ A, R) − V (Pi, R). Hence, the ﬁrst argument

12

Figure 9: The multi-step process to determine UF and OF regions.
Unlike the case of SM actions in Fig. 8, the accessibility for AM actions
can be computed in on shot based on the input shape. However, the
(in)accessible regions must be corrected by underﬁlling and the input
shape must be temporarily modiﬁed by overﬁlling.

in Po = U (P, R) must be replaced with P ∩ A∗ to test the
half-line intersection measure in (20) against the accessible
and self-supporting subset P ∩ A∗ of the target shape P :

P (cid:48)
o

(cid:44) Pi ∪ V

(cid:16)

P ∩ A∗(Pi, H, ∅, R), R

(cid:17)

.

(35)

Second, the intersection measure test in (20) needs to be
modiﬁed. Assuming the input shape is solidiﬁed, there is no
need for the entire line segment x+RL to fall inside P ∩A∗.
It is suﬃcient to look only at the portion of the line that
is above the input shape Pi, i.e., the overhangs of the input
Pi can be ignored. This eﬀect can be easily achieved by
replacing P ∩ A∗ with (P ∩ A∗) ∪ V (Pi, R) in the argument
of the U function, and removing V (Pi, R) from the result:
(cid:16)(cid:0)P ∩A∗(Pi, H, ∅, R)(cid:1)∪V (Pi, R), R

(cid:20)
Po (cid:44) Pi∪

(cid:21)
.
−V (Pi, R)

(cid:17)

V

(36)
Unlike the case with UF actions, the accessibility constraint
in this case often subsumes the intersection test with an
upward half-line x + (−RL) for query points underneath
the overhangs of Pi. More speciﬁcally, if x ∈ A∗ ⊆ A then
x+R(T −k) does not collide with Pi for all k ∈ K. Assuming
(−RL) ⊆ R(T − k) (i.e., the tool is thicker than a half-line),
the half-line does not collide with Pi either. Therefore, the
additional correction in (36) is redundant and the simpler
formula in (35) works (i.e., P (cid:48)

o = Po).

Figure 9 (b) illustrates how the U and V functions, along-
side original and modiﬁed accessible and inaccessible re-
gions, are used to compute the OF action’s output.

monotonicity of the process plan cannot be assumed; for
instance, it is possible that removing a feature from the
workpiece provides access for a diﬀerent tool to deposit or
remove material elsewhere and that the removed feature
may eventually be redeposited at a later stage. Addition-
ally, an inﬁnite number of ﬁxturing/build directions may be
possible, so it is necessary to restrict the relative rotations
for the search space to be tractable.

In order to simplify the search space, we assume that the
build platform is ﬁxed to be the xy−plane and that both
AM and SM tools are aligned with the z−axis, the part is
rotated for each action, and the rotation does not change
while the tool and part translate relatively on a 3−axis mo-
tion system. We also restrict the rotations to 90◦ cardinal
increments after any given action. Additionally, we assume
the tools to be axisymmetric along the z−axis, reducing the
possible rotation increments at each step to seven in total—
namely, the identity, the four ±90◦ rotations around the x−
or y−axes, and the two distinct compositions of these rota-
tions amounting to a single ±90◦ rotation around the x−
or y−axis followed by a ±90◦ rotation around the z−axis.
Finally, we impose the reasonable rule that if at any point
the workpiece shape happens to be a subset/superset of the
target shape, the next action must be AM/SM respectively.
This condition subsumes the special cases where the initial
part state is null, hence the ﬁrst step must be AM, and
where the initial state is a raw/bar stock containing the
target shape, hence the ﬁrst step must be SM.

With these restrictions, one can generate a search tree of
HM process plans and the resulting as-manufactured part
shapes through a sequence of valid AM and SM actions and
in-between ±90◦ cardinal rotations. Even with a single AM
and a single SM tool, the branching factor of the tree can be
as large as 28, corresponding to the seven potential cardinal
rotations and four manufacturing modalities (OC, UC, UF,
OF). Even with these restrictions, the search space quickly
becomes intractable, with almost 11,000 potential three-
step HM process plans. It should be noted that real-world
HM processes may involve choices between multiple diﬀer-
ent AM and/or SM tools at each step, which increases the
branching factor of the search space even further. There-
fore, it is crucial to utilize an eﬃcient search algorithm with
proper heuristics to manage exponential blowup.

6. Search Algorithm

Due to the large search space and the arbitrary geomet-
ric complexity of the workpiece at each node, we use an
iterative deepening A* (IDA*) search algorithm [32] to de-
termine a cost-optimal HM process plan for a given part.
The IDA* search performs a cost-limited depth-ﬁrst search
on the search tree, prioritizing “promising” paths (quanti-
ﬁed through a cost function) and increasing the maximum
allowed cost at each iteration until a solution is found. Com-
pared to a traditional A* search algorithm, The IDA* algo-
rithm (being a depth-ﬁrst search) is memory eﬃcient since
it only has to store nodes on the current stack. Similar
to an A* search algorithm, IDA* relies upon a cost func-
tion f = g + h, where f represents the total cost estimate
from the initial state to the goal state, g is the known cost
incurred along the current path thus far, and h is the esti-
mated cost from the current node to the goal node, using
reasonable heuristics. If the heuristic is admissible, meaning

Figure 10: The choice of conservative or aggressive, AM or SM actions
leads to a search tree whose paths are valid HM process plans.

The implicit form of (36) is obtained by replacing the
Boolean union,
intersection, and diﬀerence with sign of
summation, multiplication, and multiplication with negated
value, respectively, of the indicator functions. The discrete
form (via 3D voxel arrays) is implemented in Algorithm 8.

Algorithm 9 Computing OF output

procedure OverFill([1P ], [1Pi], [1H ], [1K], R, xB)

(cid:1)

[1A] ← Accessible(cid:0)[1Pi], [1H ], [1∅], R(cid:1)
[1A∗ ] ← MaxSelfSupp(cid:0)[1A], R, xB
[1P ∗ ] ← [1P ] · [1A∗ ]
[1V ] ← MinSelfSupp(cid:0)[1Pi], R, xB
[1E] ← sign(cid:0)[1P ∗ ] + [1V ](cid:1)
[1U ] ← MinSelfSupp(cid:0)[1E], R, xB
(cid:1)
[1Pi] + (cid:0)[1U ] · ¬[1V ](cid:1)(cid:17)
return sign
end procedure

(cid:16)

(cid:1)

5. Process Planning

Following [11], we deﬁne a ‘valid’ HM process plan as a
ﬁnite sequence of valid AM (UF/OF) and SM (OC/UC) ac-
tions ϕ1, ϕ2, ϕ3, . . . , ϕn, expressed as a composition of state
transitions from an initial part state P0 to a ﬁnal part state
Pn that must be interchangeable (e.g., with respect to a
tolerance speciﬁcation) with the target shape P :

P0

ϕ1−→ P1

ϕ2−→ P2

ϕ3−→ · · ·

ϕn−−→ Pn

∼= P.

(37)

Example of a valid HM process plans are the diﬀerent
branches of the tree depicted in Fig. 10.

There are a few diﬃculties in eﬃciently exploring the
space of potential process plans of arbitrary length n > 0.
Firstly, there is no easily formulated condition for decid-
ing which manufacturing modality (AM or SM) to use at
any given step. In purely AM or SM scenarios, the process
is monotonic with each step of the process plan bringing
the workpiece closer to the target part. In HM scenarios,

13

that it is guaranteed to underestimate the actual remaining
cost, A* will eventually ﬁnd the cost-optimal solution [32].
Our search algorithm terminates once it reaches a goal
state, which is deﬁned as arriving at any shape whose excess
and deﬁcit regions are small relative to the target shape. We
use a simple test for reaching a goal state:7

µ3[P − Pn] + µ3[Pn − P ]
µ3[P ]

< δ,

(38)

where δ > 0 is a predetermined small parameter, e.g.,
our examples use δ := 0.01 unless otherwise stated. This
relative error condition provides an adjustable parameter
to measure the discrepancy between the as-built and as-
designed parts, which allows for termination of the search
in case the target part is not manufacturable using any valid
combination of the AM/SM capabilities. We generally have
O(106) active voxels for our test parts, thus allowing for
O(104) active voxels to be occupied by excess and deﬁcit
material.
It is also important to note that admitting a
nonzero error in the stopping criterion allows for multiple
diﬀerent nodes to be considered terminal.

6.1. Cost Function

To construct appropriate cost and heuristic functions, we
consider a relatively simple expression for the manufactur-
ing cost of a given part. For a target shape P and an
intermediate workpiece state Pn (n = 0, 1, 2, . . .), we can
determine how much material (in volumetric terms) must
be added to or removed from the as-manufactured part in
an ideal scenario to produce the target part. The volume of
the deﬁcit material is given by µ3[P −Pn] and the volume of
the excess material is µ3[Pn − P ]. Note that these are the
minimum amount of material that must be moved to get
from Pn to P , although in reality, additional material may
be wasted (i.e., added then removed, or vice versa, in in-
termediate steps) depending on the geometry, as a result of
accessibility and support constraints. Hence, the following
formula provides an admissible heuristic:

h(Pn, P ) (cid:44) cAMµ3[P − Pn] + cSMµ3[Pn − P ],

(39)

where cAM and cSM represent the cost-per-unit-volume of
material addition and removal, respectively. One can use a
separate coeﬃcient for diﬀerent AM/SM capabilities, noting
the common tradeoﬀ between build/machining time, reso-
lution, roughness, and cost for both AM and SM. However,
we use a single pair here for simplicity. Note that, in this
case, the ordering imposed by the cost function on the plan-
ning space depends on the ratio λ (cid:44) cSM/cAM, rather than
both parameters at once.

The cost incurred so far, on the other hand, is the sum of
costs of all manufacturing actions over preceding workpiece
states P0, P1, P2, . . . , Pn−1:

g(P0, P1, P2, . . . , Pn) (cid:44)

n−1
(cid:88)

i=0

h(Pi, Pi+1).

(40)

7The proper way to do this would be to use interchangeability with
respect to form/ﬁt/function, e.g., to check if the excess and deﬁcit
regions are restricted to G&T tolerance zones.

14

in which case, although each action’s cost h(Pi, Pi+1) has
the same form as the heuristic function in (39), it is viewed
as the actual cost as opposed to an underestimation.

The total cost estimate to arrive from an intermediate
workpiece state Pn at a goal state that is close enough to
the target state P according to (38) is thus given by the
sum of (39) and (40).

It is easy to verify that the heuristic is consistent: a work-
ϕi+1−−−→ Pi+1 incurs a cost of at least
piece state transition Pi
h(Pi, Pi+1), so the heuristic always provides an underesti-
mate of the cost, and is thus automatically admissible. To
speed up convergence of the algorithm, however, we choose
a weighted cost function:

fw(P0, P1, P2, . . . , Pn, P ) (cid:44) g(P0, P1, P2, ..., Pn)

+ (1 + w)h(Pn, P ),

(41)

where w > 0 is a parameter determining the weighting of
the heuristic.

It is important to note that setting w > 0 spoils the ad-
missibility of the heuristic, thus no longer guarantees cost-
optimality of the process plan discovered by A*. However,
the cost of valid AM/SM actions applied to the workpiece
at diﬀerent directions are often close to each other and the
weighting helps distinguish the projected costs of diﬀer-
ent operations, which is especially critical during the initial
stages of the search process. Additionally, the weight pa-
rameter may be used in addition to λ to control the search
strategy (e.g., OF-then-OC or repeated UF).

Appendix A provides an analysis of the cost function

based on the weighting and relative AM/SM cost factors.

6.2. Implementation

We prototyped the IDA* algorithm for HM process plan-
ning in Python.
In this context, nodes contain informa-
tion about the workpiece state (including excess and deﬁcit
material), manufacturing history including the parent node
and all previous operations, and methods to calculate cost
incurred so far, heuristic, and total cost-to-goal estimate.
The pseudo-code is given in Algorithm 10, in which the sub-
routines Heuristic, TotalCostEst, and Interchange-
able compute the formulae in (39), (41), and (38), respec-
tively. The Sort function uses the total cost estimate func-
tion to sort the children in ascending order.

7. Results

In this section, we provide examples of HM process plans
generated by our algorithm for a support bracket (Section
7.1), the GE bracket (Section 7.2), a helical screw-thread
(Section 7.3), and a helical staircase (Section 7.4), obtained
from GrabCAD and Thingiverse.

7.1. Support Bracket

We consider a support bracket as depicted in Fig. 11
along with an SM tool (ball-end mill) and an AM tool (3D
printer nozzle). The target part geometry is voxelized at
a resolution of 251×315×243 and has around 4.7 million
active voxels. All running times are reported for generating
the process plans on a Dell Precision 5820 workstation with
and Intel Xeon W-2275 processor, 64 GB DDR4 2933MHz
RAM, and an Nvidia Quadro RTX6000 GPU.

Algorithm 10 IDA* Search for HM Process Planning

procedure IDA*(start, goal)

found, cost ← FALSE, Heuristic(cid:0)start(cid:1)
while not found do

found, cost, end ← Search(cid:0)start, goal, cost(cid:1)

end while
return cost, end

end procedure

procedure Search(start, goal, maxCost)

nodeStack ← [start]
minCost ← ∞
while nodeStack (cid:54)= ∅ do

current ← nodeStack.pop()
if TotalCostEst(cid:0)current(cid:1) ≤ maxCost then

if Interchangeable(cid:0)current, goal(cid:1) then

cost ← TotalCostEst(cid:0)current(cid:1)
return TRUE, cost, current

else

children ← GetChildren(cid:0)current(cid:1)
Sort(cid:0)children, TotalCostEst(cid:1)
nodeStack.push(children)

end if

else

if TotalCostEst(cid:0)current(cid:1) < minCost then
minCost ← TotalCostEst(cid:0)current(cid:1)

end if

end if
end while
return FALSE, minCost, null

end procedure

The 4-step process plan identiﬁed by our approach is
shown in Fig. 12a. For this result, we set the heuristic
weight to w := 1 and AM-to-SM cost ratio to λ := 0.1. The
relative volumetric error of the as-manufactured shape with
respect to the target as-designed shape is < 0.7%, which
amounts to an excess of ∼ 3.0 × 104 voxels out of the total
4.7 × 106 active voxels in the target shape. The actual cost
is ∼ 48% larger than the cost lower-bound, calculated by
assuming no (additive or subtractive) material waste. The
extra cost is owing to the initial OF action, which deposits
excess material that must subsequently be removed. The
search process took 1 minute and 41 seconds to complete.

Additionally, we ran our search algorithm with λ := 1
to better understand how the cost ratio aﬀects the process
planning and obtained the 4-step process plan depicted in
Fig. 12b. Compared to the previous process plan, this strat-
egy builds the part through a series of UF actions; however,
inaccessibility of the AM tool prevents the part from being
completely manufacturable through AM alone. No material
is wasted in this case, and the cost is ∼ 82% of the total
material cost of the target part. The relative error of the as-
manufactured shape is ∼ 18%, which translates to a deﬁcit
of approximately 8.5 × 105 voxels. This process plan took 4
minutes and 57 seconds to generate.

15

Figure 11: Milling and Additive Manufacturing tools next to support
bracket geometry

7.2. GE Bracket

Next, we test our algorithm on a topology optimized ver-
sion of the GE bracket shown in Fig. 12c. The target part
geometry was voxelized at a resolution of 251×93×154 vox-
els, resulting in around 500K active voxels.

The 4-step process plan identiﬁed by our approach is de-
picted in Fig. 12d. Again, we set the heuristic weight to
w := 1, and AM-to-SM cost ratio to λ := 0.1. The relative
error of the as-manufactured part is < 0.2%, which amounts
to an excess of approximately ∼ 103 voxels. The actual cost
is ∼ 45% larger than the cost lower-bound, owing to the ex-
cess material produced by the initial OF action. The search
took 21 seconds to complete.

7.3. Helical Thread

The next example is a helical threaded geometry depicted
in Fig. 12d. We voxelized this part at a resolution of
201×141×140, resulting in 2M active voxels, and set w := 1
and λ := 0. For this part, our process planner was able
to identify a plan to manufacture the target part in 5 UF
steps, with a ﬁnal error of almost zero. Although the cost
ratio was set to zero, the cost of support material for an
initial OF operation is large enough that the process plan-
ner selects a purely additive strategy. The search took 40
seconds to complete.

7.4. Helical Staircase

The last example is a helical staircase geometry depicted
in Fig.
12e. We voxelized this part at a resolution of
201×163×163, resulting in 460K active voxels, and set
w := 1, and λ := 0.1. For this part, we start from a raw
stock, and our process planner was able to ﬁnd a plan to
manufacture the target part in 5 OC steps, with a ﬁnal error
of < 0.9%. The search took 30 seconds to complete.

8. Conclusion

We presented an approach to deﬁne and compute AM/SM
actions for arbitrary part and tool geometries and synthesize
cost-optimal HM process plans. We proposed conservative
and aggressive policies to deﬁne AM/SM actions that mod-
ify a given workpiece in its intermediate state to generate
the closest shape to the given target shape, deﬁned in some
sense (e.g., volumetric diﬀerence). The conservative (i.e.,
under-ﬁll AM and over-cut SM) actions do so without pro-
ducing any excess or deﬁcit regions that require an action

(a) A four-step HM process plan for the support bracket geometry, using w = 1 and λ := 0.1.

(b) A four-step HM process plan for the support bracket geometry, using w = 1 and λ := 1.

(c) A four-step HM process plan for the optimized GE bracket geometry, using w = 1 and λ := 0.1.

(d) A ﬁve-step AM process plan for the helical threaded geometry, using w = 1 and λ := 0.

(e) A four-step SM process plan for the helical staircase geometry, using w = 1 and λ := 0.1.

Figure 12: Various HM process plans for the support bracket, topology optimized GE bracket, helical threaded, and helical staircase geometries.

16

of the opposite kind to undo, i.e., get the workpiece closer
to the target while assuming the remaining job will require
an action of the same kind. The aggressive (i.e., over-ﬁll
AM and under-cut SM) actions do so with producing mini-
mal excess or deﬁcit regions, while assuming the remaining
job will require an action of the opposite kind to undo their
undesired eﬀects. These eﬀects include collateral damage
(in the case of under-cut SM), i.e., removing regions that
belong to the target shape temporarily to make all regions
outside the target shape accessible, and sacriﬁcial material
(in the case of over-ﬁll AM), i.e., support structure outside
the target shape to carry the weight of all regions inside the
target shape. Our approach to deﬁne these notions is based
on morphological operations on 3D pointsets, and does not
make any assumption on the shape, feature-based heuris-
tics, or parametrizations.

The valid AM/SM actions are used to enumerate the
space of HM process plans in a tree, which we explore
through an IDA* search algorithm to assess manufactura-
bility and generate a cost-eﬀective HM process plan. Even
with a fairly crude search heuristic, based on a snapshot of
excess and deﬁcit materials, our search algorithm can pro-
duce process plans for a variety of complex part geometries.
Our cost function provides a crude volumetric measure that
may represent material cost and/or machine usage time. In
real-world scenarios, however, it may be desirable to select
better cost functions which measure other relevant aspects
of the manufacturing process including re-ﬁxturing, rough-
ing vs. ﬁnishing, etc.

Currently, we do not control error in a spatially lo-
calized manner, nor does our stopping criterion con-
sider as-manufactured part performance; however,
it is
quite natural to desire more reﬁned controls on the
form/ﬁt/function or physics-based performance of the as-
manufactured part (e.g., based on GD&T tolerance speciﬁ-
cations and simulation-informed performance criteria). Fu-
ture work may focus on incorporating these considerations
into the error measure.

Acknowledgments

The authors are thankful to John T. Maxwell for his in-
sights on hybrid manufacturing and Saigopal Nelaturi for
his support of this project under the Design for Manufac-
turing research program at PARC.

References

[1] M. Rifat, S. Basu, E. De Meter, G. Manogharan, Eﬀect of prior
surface textures on the resulting roughness and residual stress
during bead-blasting of electron beam melted ti-6al-4v, Crystals
12 (3). doi:10.3390/cryst12030374.

[2] Machining Behavior and Material Properties in Additive Man-
ufacturing Ti-6Al-4V Parts, Vol. 1 of International Manufac-
turing Science and Engineering Conference.
doi:10.1115/
MSEC2020-8487.

[3] K. Basinger, C. Keough, C. Webster, R. Wysk, T. Martin,
O. Harrysson, Development of a modular computer-aided pro-
cess planning (capp) system for additive-subtractive hybrid man-
ufacturing of pockets, holes, and ﬂat surfaces, The International
Journal of Advanced Manufacturing Technology 96 (5) (2018)
2407–2420. doi:10.1007/s00170-018-1674-x.

[4] M. Cortina, J. Arrizubieta, J. Ruiz, E. Ukar, A. Lamikiz, Latest
developments in industrial hybrid machine tools that combine ad-
ditive and subtractive operations, Materials 11 (12) (2018) 2583.
doi:10.3390/ma11122583.

[5] M. Sealy, G. Madireddy, R. Williams, P. Rao, M. Toursangsaraki,
Hybrid processes in additive manufacturing, Journal of Manufac-
turing Science and Engineering 140 (6). doi:10.1115/1.4038644.
[6] V. Popov, A. Fleisher, Hybrid additive manufacturing of steels
and alloys, Manufacturing Reviews 7 (2020) 6. doi:10.1051/
mfreview/2020005.

[7] J. P. M. Pragana, R. F. V. Sampaio, I. M. F. Bragan¸ca, C. M. A.
Silva, P. A. F. Martins, Hybrid metal additive manufacturing:
A state-of-the-art review, Advances in Industrial and Manufac-
turing Engineering 2 (2021) 100032. doi:10.1016/j.aime.2021.
100032.

[8] C. Liu, Y. Li, S. Jiang, Z. Li, K. Xu, A sequence planning method
for ﬁve-axis hybrid manufacturing of complex structural parts,
Proceedings of the Institution of Mechanical Engineers, Part B:
Journal of Engineering Manufacture 234 (3) (2019) 421–430. doi:
10.1177/0954405419883052.

[9] L. Chen, T. Lau, K. Tang, Manufacturability analysis and process
planning for additive and subtractive hybrid manufacturing of
quasi-rotational parts with columnar features, Computer-Aided
Design 118 (2019) 102759. doi:10.1016/j.cad.2019.102759.
[10] Y. Zheng, J. Liu, R. Ahmad, A cost-driven process planning
method for hybrid additive–subtractive remanufacturing, Jour-
nal of Manufacturing Systems 55 (2020) 248–263. doi:https:
//doi.org/10.1016/j.jmsy.2020.03.006.

[11] M. Behandish, S. Nelaturi, J. Kleer, Automated process planning
for hybrid manufacturing, Computer-Aided Design 102 (2018)
115–127. doi:10.1016/j.cad.2018.04.022.

[12] K. P. Karunakaran, S. Suryakumar, V. Pushpa, S. Akula, Low
cost integration of additive and subtractive processes for hybrid
layered manufacturing, Robotics and Computer-Integrated Man-
ufacturing 26 (5) (2010) 490–499. doi:10.1016/j.rcim.2010.03.
008.

[13] W. Zhang, Development of an additive & subtractive hybrid
manufacturing process planning strategy of planar surface for
productivity and geometric accuracy, International Journal of
Advanced Manufacturing Technology 109 (5) (2020) 1479–1491.
doi:10.1007/s00170-020-05733-9.

[14] Part Repairing Using a Hybrid Manufacturing System, Interna-
tional Manufacturing Science and Engineering Conference. doi:
10.1115/MSEC2007-31003.

[15] J. Wilson, C. Piya, Y. Shin, F. Zhao, K. Ramani, Remanufactur-
ing of turbine blades by laser direct deposition with its energy and
environmental impact analysis, Journal of Cleaner Production 80
(2014) 170–178. doi:10.1016/j.jclepro.2014.05.084.

[16] T. Yamazaki, Development of a hybrid multi-tasking machine
tool: Integration of additive manufacturing technology with cnc
machining, Procedia CIRP 42 (2016) 81–86, 18th CIRP Confer-
ence on Electro Physical and Chemical Machining (ISEM XVIII).
doi:10.1016/j.procir.2016.02.193.

[17] G. Manogharan, R. Wysk, O. Harrysson, R. Aman, AIMS–a
metal additive-hybrid manufacturing system: System architec-
ture and attributes, Procedia Manufacturing 1 (2015) 273–286.
doi:10.1016/j.promfg.2015.09.021.

[18] Z. Zhu, V. Dhokia, S. T. Newman, A novel process planning
approach for hybrid manufacturing consisting of additive, sub-
tractive and inspection processes, in: 2012 IEEE International
Conference on Industrial Engineering and Engineering Manage-
ment, Institute of Electrical and Electronics Engineers (IEEE),
2012, pp. 1617–1621. doi:10.1109/IEEM.2012.6838020.

[19] Z. Zhu, V. Dhokia, S. Newman, The development of a novel
process planning algorithm for an unconstrained hybrid manu-
facturing process, Journal of Manufacturing Processes 15 (2013)
404–413. doi:10.1016/j.jmapro.2013.06.006.

[20] S. Newman, Z. Zhu, V. Dhokia, A. Shokrani, Process planning
for additive and subtractive manufacturing technologies, CIRP
Annals - Manufacturing Technology 64 (1) (2015) 467–470. doi:
10.1016/j.cirp.2015.04.109.

[21] A. M. Mirzendehdel, M. Behandish, S. Nelaturi, Exploring feasi-
ble design spaces for heterogeneous constraints, Computer-Aided
Design 115 (2019) 323–347. doi:10.1016/j.cad.2019.06.005.

[22] S. Nelaturi, G. Burton, C. Fritz, T. Kurtoglu, Automatic spa-
tial planning for machining operations, in: Proceedings of the
2015 IEEE International Conference on Automation Science and
Engineering (CASE’2015), Institute of Electrical and Electronics

17

Engineers (IEEE), 2015, pp. 677–682. doi:10.1109/CoASE.2015.
7294158.

[23] J. Serra, Image Analysis and Mathematical Morphology, Aca-

demic Press, Inc., 1983.

[24] J. B. T. M. Roerdink, Group morphology, Pattern Recognition

33 (6) (2000) 877–895. doi:10.1016/S0031-3203(99)00152-1.

[25] T. Lozano-Perez, Spatial planning: A conﬁguration space ap-
proach, IEEE Transactions on Computers C-32 (2) (1983) 108–
120. doi:10.1109/TC.1983.1676196.

[26] V. Shapiro, Maintenance of geometric representations through
space decompositions, International Journal of Computational
Geometry & Applications 7 (1997) 383–418.
doi:10.1142/
S0218195997000247.

[27] M. Lysenko, S. Nelaturi, V. Shapiro, Group morphology with
convolution algebras, in: Proceedings of the 14th ACM Sym-
posium on Solid and Physical Modeling (SPM’2010), Associa-
tion of Computing Machinery (ACM), 2010, pp. 11–22. doi:
10.1145/1839778.1839781.

[28] A. A. G. Requicha, Representations for rigid solids: Theory,
methods, and systems, ACM Computing Surveys 12 (4) (1980)
437–464. doi:10.1145/356827.356833.

[29] A. A. G. Requicha, R. B. Tilove, Mathematical foundations of
constructive solid geometry: General topology of closed regular
sets, Production automation project, technical memo., University
of Rochester (June 1978).

[30] L. Guibas, L. Ramshaw, J. Stolﬁ, A kinetic framework for com-
putational geometry, in: The 24th Annual Symposium on Foun-
dations of Computer Science (SFCS’1983), 1983, pp. 100–111.
doi:10.1109/SFCS.1983.1.

[31] A. M. Mirzendehdel, M. Behandish, S. Nelaturi, Topology op-
timization with accessibility constraint for multi-axis machining,
Computer-Aided Design 122 (2020) 102825. doi:10.1016/j.cad.
2020.102825.

[32] R. E. Korf, Depth-ﬁrst iterative-deepening: An optimal admis-
sible tree search, Artiﬁcial Intelligence 27 (1) (1985) 97–109.
doi:10.1016/0004-3702(85)90084-0.

Appendix A. Cost Function Analysis

It is instructive to analyze the cost function in order to
understand the search algorithm’s behavior. Considering
ϕn−−→ Pn, resulting from
a workpiece state transition Pn−1
either an AM or SM action, we may consider the change in
the cost function resulting from this action:

∆f = f (P0, P1, ..., Pn−1, Pn, P ) − f (P0, P1, ..., Pn−1, P ),

which may be expressed in the following form:

∆f =cAM
(cid:16)

+cSM

(cid:16)

µ3[S2] + (1 + w)µ3[S3] − wµ[S1]

(cid:17)

µ3[S3] + (1 + w)µ3[S2] − wµ3[S4]

(cid:17)

,

(A.1)

(A.2)

where:

S1 (cid:44) (Pn − Pn−1) ∩ P,
S2 (cid:44) (Pn − Pn−1) ∩ P c,
S3 (cid:44) (Pn−1 − Pn) ∩ P,
S4 (cid:44) (Pn−1 − Pn) ∩ P c.

S1 represents the decrease in deﬁcit material, S2 represents
the increase in excess material, S3 represents the increase
in deﬁcit material, and S4 represents the decrease in excess
material, due to the action. Note that for AM actions, S3 =
S4 = ∅, whereas for SM actions S1 = S2 = ∅. Note also that
for the conservative AM (i.e., UF) actions, S2 = ∅, too (i.e.,

18

only S1 is nonempty), while for the conservative SM (i.e.,
OC) actions, S3 = ∅, too (i.e., only S4 is nonempty).

Since the cost function is symmetric with respect to excess
and deﬁcit materials, we may consider the case in which
cSM (cid:28) cAM, without loss of generality.
In this case, the
change in the cost function may be approximated as:

∆f ≈ cAM

(cid:16)

(cid:17)
µ3[S2] + (1 + w)µ3[S3]
− wcAMµ3[S1] − wcSMµ3[S4].

(A.3)

(A.4)

For AM actions (i.e., S3 = S4 = ∅), (A.4) reduces to :

∆fAM ≈ cAM

(cid:0)µ3[S2] − wµ3[S1](cid:1),

(A.5)

and for subtractive actions (i.e., A = B = ∅) it reduces to:

∆fSM ≈ (1 + w)cAMµ3[S3] − wcSMµ3[S4].

(A.6)

Notice that if the initial part state is empty (i.e. P0 = ∅),
then ∆f = 0 for all SM actions, hence the search algorithm
will attempt to minimize ∆f through one of the AM actions:
UF or OF. While UF actions always produce a ∆fAM < 0,
they may be advantageous over OF actions if the cost of de-
positing support material is less than the weighted reduction
in deﬁcit material. Depending upon the part geometry, a
larger weighting parameter will prefer an initial OF action,
whereas a smaller weighting parameter will prefer an initial
UF action.

In the case that the weighting parameter w is large
enough to produce an initial OF action, ∆f = 0 for any
subsequent AM action, hence the following action must be
SM. The search will be biased towards choosing the second
action as OC, since ∆fSM < 0 is guaranteed for OC actions,
but wcSM (cid:28) (1 + w)cAM, hence any increase in deﬁcit ma-
terial will be penalized heavily. However, if the weighted
increase in deﬁcit material is small relative to the weighted
reduction in excess material, the search may choose a UC
action, which will require an AM action at a later step to
repair the incurred material deﬁcit. Repeating this line of
reasoning for subsequent actions results in an OF then OC
strategy, leading to an HM process plan with alternating
AM and SM actions.

In the case that the weighting parameter w is small
enough to produce an initial UF action, ∆f = 0 for any sub-
sequent SM action, hence the following action must be AM.
By a similar reasoning as the initial action, if the weight-
ing parameter is small, the search will be biased towards
repeating UF actions. However, if the weighted increase in
excess material is small relative to the weighted reduction
in deﬁcit material, the search may choose an OF action,
which will require an SM action at a later step to clear the
incurred material excess, leading to a monotonic AM pro-
cess plan. Additionally, in the case that cAM (cid:28) cSM, one
may repeat the above analysis to show that the search will
be biased towards monotonic AM process plans in all cases.
Thus two natural HM strategies emerge from choices of
the search parameters: a large weight w and a small λ ratio
will tend to produce an AM-then-SM (OF-then-OC) strat-
egy, while a small weight w and a large λ ratio will tend to
produce a monotonic AM strategy. For our experiments, we
ﬁx w = 1 in order to explore how the variation in λ aﬀects
the HM process planning strategy.

