2
2
0
2

g
u
A
4
2

]
S
M

.
s
c
[

1
v
6
7
6
1
1
.
8
0
2
2
:
v
i
X
r
a

SOniCS: Develop intuition on biomechanical
systems through interactive error controlled
simulations

Arnaud Mazier*1, Sidaty El Hadramy*2, Jean-Nicolas Brunet3,
Jack S. Hale1, St´ephane Cotin2, and St´ephane P.A. Bordas1

1Institute of Computational Engineering and Sciences, Department of Engineering,
Universit´e du Luxembourg, 6, Avenue de la Fonte, 4364, Esch-sur-Alzette,
Luxembourg
2MIMESIS team, Inria, 1 Place de l’Hopital, 67000 Strasbourg, France
3jnbrunet@pm.me
*Arnaud Mazier and Sidaty El Hadramy contributed equally to this work

August 25, 2022

Abstract

This new approach allows the user to experiment with model choices
easily and quickly without requiring in-depth expertise, as constitutive
models can be modiﬁed by one line of code only. This ease in building
new models makes SOniCS ideal to develop surrogate, reduced order mod-
els and to train machine learning algorithms for uncertainty quantiﬁcation
or to enable patient-speciﬁc simulations. SOniCS is thus not only a tool
that facilitates the development of surgical training simulations but also,
and perhaps more importantly, paves the way to increase the intuition
of users or otherwise non-intuitive behaviors of (bio)mechanical systems.
The plugin uses new developments of the FEniCSx project enabling au-
tomatic generation with FFCx of ﬁnite element tensors such as the local
residual vector and Jacobian matrix. We validate our approach with nu-
merical simulations such as manufactured solutions, cantilever beams, and
benchmarks provided by FEBio. We reach machine precision accuracy and
demonstrate the use of the plugin for a real-time haptic simulation involv-
ing a surgical tool controlled by the user in contact with a hyperelastic
liver. We include complete examples showing the use of our plugin for sim-
ulations involving Saint Venant-Kirchhoﬀ, Neo-Hookean, Mooney-Rivlin,
and Holzapfel Ogden anisotropic models as supplementary material.

1

Introduction

SOniCS is an ideal tool to develop more intuitive understanding of biome-
It enables the development of accelerated surrogate mod-
chanics systems.

1

 
 
 
 
 
 
els for parameter identiﬁcation and uncertainty quantiﬁcation, model selec-
tion through machine learning [Deshpande et al., 2022] or model order reduc-
tion [Goury et al., 2016]. It also enables fast and hypothesis testing possibil-
ities to non-experts. Designing eﬃcient ﬁnite element (FE) simulation soft-
Indeed, as FEM is a vast ﬁeld, numerous pieces
ware is a challenging task.
of software emerged to ﬁll diﬀerent gaps. For instance, commercial software
such as Abaqus [Smith, 2009] or Ansys [DeSalvo and Swanson, 1985] focus on
proposing a user-friendly GUI (Graphical User Interface) guiding the user from
pre-processing to post-processing. This has the advantage of allowing users
to perform complex simulations with a relatively basic theoretical knowledge
of FE. Meanwhile, other pieces of software focused on speciﬁc domains such as
Gmsh [Geuzaine and Remacle, 2009] for FE meshing, Paraview [Ahrens et al., 2005]
for FE visualization, OpenFoam [Jasak et al., 2007] for CFD (Computational
Fluid Dynamic) simulations, OpenXFEM [Bordas et al., 2006] for extended ﬁ-
nite elements [Jansari et al., 2019], collocation methods [Jacquemin and Bordas, 2021],
meshfree methods [Nguyen et al., 2008], multiscale problems [Talebi et al., 2013],
or material point methods (MPM) [Sinaie et al., 2017]. This historical perspec-
tive explains the countless FE solvers which makes an exhaustive state-of-the-
art review quasi-impossible. Before selecting one piece of FE software, an user
should consider the beneﬁts and disadvantages associated with each (i.e., mesh-
ing, parallel support, solvers, coding language, and visualization). However,
generally, simplicity of use and the ability to easily test modelling hypotheses
appears like the most important considerations in selecting such a computational
tool.

In the medical simulation context, several aspects have to be considered.

• The material model complexity. Conversely to engineering materials such
as steel or copper, the mechanical properties of living organs were only
recently quantiﬁed [Gibbons, 1934, Payan and Ohayon, 2017] (early 90s
against 1700 for copper) and show immense variability [Mihai et al., 2017].
Various models have been proposed, e.g., anisotropic [Zhou and Fung, 1997,
Picinbono et al., 2003, Flynn et al., 2011, Boyer et al., 2013, Elouneg et al., 2021],
hyperelastic [Martins et al., 2006, Itskov, 2001, Mihai et al., 2015, Chagnon et al., 2014,
Zeraatpisheh et al., 2021], viscoelastic [Ehlers and Markert, 2001, Haj-Ali and Muliana, 2004,
Marchesseau et al., 2010, Urcun et al., 2021b], or poroelastic [Simon, 1992,
Cowin, 1999, Stokes et al., 2010, Richardson et al., 2021, Barrera, 2021,
Bulle et al., 2021, Lavigne et al., 2022] to accurately depict their com-
plex mechanical behaviors.
Indeed, predicting the deformations of bio-
materials can only be achieved through complex material models (some-
times even multi-scale), which are rarely implemented in commercial soft-
ware. One major diﬃculty of this implementation remains the diﬀerenti-
ation of highly nonlinear equations. Indeed, predicting the deformations
of such materials can only be achieved through complex material mod-
els, rarely implemented in commercial software. One major diﬃculty of
this implementation remains the derivation of highly nonlinear equations.
For instance, hyperelasticity equations can be written as a minimization

2

of a tensorial function. In most cases, this minimization is solved using
gradient-descent algorithms requiring the ﬁrst and second derivatives of
the functional. Therefore, obtaining such high-order nonlinear derivatives
is not straightforward and can be prone to manual errors.

• The complexity of the simulation. In addition to the complexity of the ma-
terial model, the simulation setup itself can be problematic. For instance,
the material parameters are patient-speciﬁc and require data-driven or in-
ference methods [Han et al., 2011, Urcun et al., 2021a]. The simulations
can also (partially) involve unknown boundary conditions [Tagliabue et al., 2021],
contact with other organs [Courtecuisse et al., 2014, Miguez Pacheco et al., 2014],
or surgical tools [Cotin et al., 1999, Lim et al., 2006]. The problem can
also require multi-physics models (such as FSI [Borazjani, 2013, Bianchi et al., 2017]
(Fluid-Structure Interactions)) or incompressibility [Weiss et al., 1996, Mazier et al., 2022],
where classical displacement-based ﬁnite elements are prone to locking.

• The error control and uncertainty of the solution. When dealing with
biomechanical simulations, several uncertainties always arise from the ma-
terial parameters, loads, geometry, or boundary conditions. This is mainly
due to the diﬃculty in estimating the mechanical properties through ex-
vivo methods or the topology of biological tissues using medical imaging.
Similarly, error control and mesh adaptivity are necessary to ensure homo-
geneous convergence of the solution over the domain and that the mesh is
optimal given a quantity of interest [Allard et al., 2012]. Therefore, quan-
tifying the uncertainty or controlling the error on quantities of interests of-
ten requires making a very large number of simulations [Rappel et al., 2019a,
Rappel et al., 2019b] which is incompatible with surgical timing [Hauseux et al., 2017,
Hauseux et al., 2018]. Meanwhile, those approaches could be functional in
clinical settings by using accelerated simulations [Bui et al., 2018] to build
surrogate models or/and machine learning models for faster solutions of
those highly non-linear parametric problems.

• The real-time aspect. In addition to the previous point, for clinical envi-
ronments, the running time of the numerical simulation is crucial. When
performing an operation, the surgeon cannot, in general, spend minutes
waiting for the model predictions. Eventually, this aspect is also applica-
ble to artiﬁcial intelligence. Indeed, in order to build an eﬃcient machine
learning model, a signiﬁcant amount of data is necessary. Using numerical
simulations to create synthetic data is now standard and directly depen-
dent on the simulation time [Odot et al., 2022, Deshpande et al., 2022].
Consequently, the run-time of the simulation can be considered a principal
feature of biomechanics simulations, and indeed, of any non-intuitive non-
linear problems subject to signiﬁcant uncertainties in loading, boundary
and initial conditions, and parameters. Nowadays, gaming engines such as
Unity3D [Menard, 2011] or Unreal Engine [Sanders, 2016] oﬀer real-time
animation where physics-based algorithms can be included [Comas et al., 2008,
Verschoor et al., 2018, Turini et al., 2019].

3

• The interaction with the user.

In a surgical simulation setting, exter-
nal variables can impact the simulation during the execution. For ex-
ample, the exact movement of the surgeon’s tool inﬂuences the simula-
tion during run-time. Thus, the parameters of the simulation must be
tuned, ”live”, to integrate interactions between the user and the simula-
tion [Niroomandi et al., 2013, Wu et al., 2014].

• The visual rendering. Depending on the research ﬁeld, visualization can
play a critical role in the understanding of the results. For instance, in
the computer graphics community, photo-realistic visualization is one of
the main objectives [Gilles et al., 2011, Malgat et al., 2015]. Contrast-
ingly, in the mechanical engineering culture, visualization is a manner
of extracting and understanding quantitatively a solution or data set
(i.e., stress or displacement ﬁelds). For medical simulations, an opti-
mal solution must combine both the accuracy of the results and photo-
realistic rendering reﬂecting the clinical ground truth all within clinical
time frames [Guo et al., 2021].

According to the state-of-the-art, SOFA [Faure et al., 2012] (Simulation Open
Framework Architecture) appears to be a suitable compromise. Indeed, SOFA
employs eﬃcient rendering while providing the possibility to interact in real-
time with the running simulation. One can note that real-time computing is
only possible depending on the complexity of the problem. Indeed, using ex-
cessive numbers of degrees of freedom (DOFs) or solving a highly nonlinear
problem cannot result in a real-time simulation (without using model order re-
duction [Chinesta et al., 2014, Goury et al., 2016, Goury and Duriez, 2018] or
machine learning [Deshpande et al., 2022]). SOFA can also manage complex
simulations through an eﬃcient implementation of contact, for example, or en-
abling multi-physics coupling. Therefore, only a few material models and el-
ements are available. A similar issue is observed for material models where
numerous implementations only focused on a 3-dimensional isotropic behavior.
Therefore, coding a new material model or element in SOFA requires advanced
C++ skills that may discourage individuals from using the software.

To alleviate the problem of complex material models, FEniCS [Alnaes et al., 2015]

Indeed, FEniCS may not possess all of
seems like an appropriate solution.
SOFA’s features, but deﬁnitely overcomes SOFA’s capabilities for material model
complexity. With FEniCS, the user can generate a large number of material
models, regardless of the element’s geometry or interpolation. Plus, it autho-
rizes an export of the pertinent ﬁnite element tensors in C code to be eﬃciently
plugged into SOFA. The beneﬁts of the synergy are considerable. By using
SOFA’s interactivity and real-time features, the user can easily prototype a
real-time simulation.
Indeed, by modifying, in ”live”, various boundary con-
ditions, geometries, or topologies, the user can eﬀortlessly and rapidly verify
modeling hypotheses of a speciﬁc problem. Combined with the speciﬁcities of
FEniCS, the user can additionally smoothly prototype complex material models
for modeling elaborate scenarios. Such feature has already been used by cou-
pling FEniCS and Acegen but with diﬀerent objectives [Lengiewicz et al., 2021].

4

To the authors’ knowledge, this paper is the ﬁrst to use FEniCS code generation
capabilities for such an endeavor and is the ﬁrst coupling between FEniCS and
SOFA.

This paper has the following outline. We will ﬁrst brieﬂy introduce SOFA
and FEniCS, highlighting the relative advantages and design choices in each.
Section 2 will detail the plugin functionalities and a short tutorial for importing
a Saint Venant-Kirchhoﬀ model from FEniCS in SOFA. Then, section 3 will
focus on conﬁrming our implementation for various numerical tests. We will
use a manufactured solution in 3.1 as validation and compare our solutions for
a cantilever beam problem with SOFA in 3.2. The last test consists in imple-
menting a new material model (Mooney-Rivlin) in SOFA and benchmarking it
with FEBio [Maas et al., 2012] in 3.3. Finally, in the last section 4, we will
use our plugin in a complex haptic simulation that cannot be implemented in
FEniCS, using a custom material model inexistent in SOFA.

1.1 SOFA

SOFA was created in 2007 by a joint eﬀort from Inria, CNRS, USTL, UJF, and
MGH. Such piece of software aims to provide an eﬃcient framework dedicated
to research, prototyping, and the development of physics-based simulations. It
is an open-source library distributed under the LGPL license, hosted on GitHub
at https://github.com/sofa-framework/sofa, and developed by an interna-
tional community. SOFA is modular. Users can create public or private plugins
to include additional features.

SOFA is a C++ library, including Python wrappers for a user-friendly pro-
totyping interface.
It was originally designed for deformable solid mechanics
but has been extended to various domains such as robotics, registration, ﬂuid
simulations, model-order reduction, and haptic simulations [Duriez et al., 2006,
Duriez, 2013]. SOFA exhibits many attractive features, but among them, the
combination of multi-model representations and mappings diﬀerentiate it from
other software.

Multi-model representation: Most classical FE software uses an identical
discretization for the whole model. Consequently, if one user wants to reﬁne the
mesh along a contact surface, the FE mesh will undergo the same reﬁnement
in the contact region. It can induce slow simulations for solving the FE sys-
tem while the user was initially only interested in the contact part. Conversely,
utilizing a multi-model representation approach, users can split the principal
model into three distinct sub-models: deformation, collision, and visual. Thus,
the user can decide to have high ﬁdelity deformations with ﬂawed contact de-
tection while maintaining a ﬁne rendering, or vice-versa. Similarly, an object
can be made of several deformation models. For example, one can model a
muscle by the interaction of FE 3D tetrahedra for the volume and 1D beams

5

for modeling ligaments, using 2 diﬀerent solvers.

Mappings: In SOFA, the ”mappings” are responsible for the communication
between the diﬀerent models. The models have parent-child relationships con-
structing a hierarchy (and a DOF hierarchy by extension).
It enables prop-
agating the positions, velocities, accelerations, and forces across the diﬀerent
models. For example, if the contact model calculates a force, it is mapped on
the deformation model that will communicate back the computed displacement.
Finally, by combining the multi-model representation with the mappings,
SOFA can build complex real-time simulations with high ﬁdelity rendering. In
addition to a scenegraph structure and visitors (responsible for going through
the model hierarchy) implementation, it can account for interactivity with the
users.

Despite the advantages provided by SOFA, some drawbacks have to be ac-
knowledged. First, in terms of solid mechanics simulations, only a few elements
and material models are available. Indeed, SOFA only proposes Lagrange linear
elements, and the geometries are limited to segments, triangles, quadrangles,
tetrahedra, and hexahedra. The following material models are coded: Boyce
and Aruda [Arruda and Boyce, 1993], Costa [Costa et al., 2001], isotropic and
anisotropic Hookean, Mooney Rivlin (2 invariants) [Mooney, 1940], classical
and stabilized Neo-Hookean, Ogden [Ogden, 1972], Saint Venant-Kirchhoﬀ, and
Veronda Westman [Veronda and Westmann, 1970]. Despite a reasonable num-
ber of mechanical models, a few of them are actually implemented for each
element type. Secondly, the beneﬁts provided by the mappings can also turn
out to be a disadvantage when it comes to implementation. Indeed, the struc-
ture of the mappings is usually complex for unexperimented C++ users, and
the mechanical tensors such as the Cauchy-Green or Piola-Kirchhoﬀ are rarely
computed. The two previous drawbacks are associated to the same ﬂaw: the
strong coupling between the material models and the topology of the element
assumed within SOFA’s architecture. This coupling implies that changing an
element’s topology or interpolation will involve a new mapping or the rewriting
of the material model, even in the case of a similar material model.

1.2 The modular mechanics plugin (Caribou)

The initial goal of the plugin (called Caribou at the time of writing, https:
//github.com/mimesis-inria/caribou) was to quickly implement new shape
functions and their derivatives for diﬀerent Immersed-Boundary and meshless
domain discretization while keeping the compatibility with the existing SOFA
surgical simulations [Brunet, 2020]. Besides, the plugin enabled to eﬀortlessly
implement diﬀerent volumetric quadrature schemes and several hyperelastic ma-
terial models. Hence, the software design had to be generic enough to combine
all the previous requirements. It also had to be eﬃcient enough to avoid the cre-
ation of a bottleneck that would prevent the biomechanical model from meeting
its computational speed requirement. Hence, the plugin was made as an exten-
sion to SOFA, bringing a redesigned software architecture.

6

In the plugin, the authors implemented a compile-time polymorphism de-
sign using generic C++ template programming. The idea is to write the code
as close as possible to equations found in traditional FE books. Then, the
C++ compiler optimizes the set of operations executed during the simulation
while keeping an object-oriented code. In this design, the ”Element” concept
was created as a generic computational class that would be inherited by all
element types. Similarly to OpenXFEM++ [Bordas et al., 2006], it provides a
ﬂexible implementation to add interpolation and quadrature numerical proce-
dures quickly. Since standard isoparametric elements have a number of nodes,
quadrature points, and shape functions already known at compile-time, most
modern compilers will be able to aggressively inline the code to optimize the
computation.

Finally, the plugin allows the creation of additional material models by sim-
ply deﬁning three methods per material: the strain energy density function,
the second Piola-Kirchhoﬀ stress tensor function, and its derivative functions.
These three functions are evaluated at a given integration point automatically
provided by the plugin. This design delivers an undeniable advantage: writing a
new material model is now independent of the topology and integration scheme.
However, it comes with a non-negligible cost. The author of the new material
model has to manually diﬀerentiate the strain energy twice and write it in C++.
This manual intervention is error prone and can quickly become a substantial
drawback for complex materials.

1.3 FEniCS

The FEniCS Project (FEniCS) [Alnaes et al., 2015] is a collection of tools for
the automated solution of partial diﬀerential equations using the ﬁnite element
method. Like SOFA, the FEniCS components are distributed under open-source
licenses (LGPL v3 or later, and MIT) and development is hosted on GitHub at
https://github.com/fenics.

A distinguishing feature of FEniCS is the ability to allow the user to write
variational of weak formulations of ﬁnite element methods in a high-level Python-
based domain speciﬁc language (DSL), the Uniﬁed Form Language (UFL) [Alnæs et al., 2014].
Subsequently, that high-level description can be compiled/transformed using the
FEniCS Form Compiler (FFC) [Kirby and Logg, 2006] into low-level and high-
performance kernels. These kernels can calculate the corresponding local ﬁnite
element tensor for a given cell in the mesh. UFL is also used by other ﬁnite ele-
ment solvers with independently developed automatic code generation capabili-
ties, notably Firedrake [Rathgeber et al., 2016] and Dune [Bastian et al., 2021].
Compared with SOFA, FEniCS is limited in scope; its primary focus is the
speciﬁcation and solution of partial diﬀerential equations via the ﬁnite element
method, leaving diﬃcult problems like mesh generation, post-processing and vi-
sualisation to leading third-party packages such as Gmsh [Geuzaine and Remacle, 2009]
and Paraview [Ahrens et al., 2005].

In the context of implementing ﬁnite element models of hyperelastic mate-
rials, this automatic approach has a number of advantages over the traditional

7

route used by most ﬁnite element codes (including, to some extent, SOFA); dif-
ferentiating analytical expressions for the residual (ﬁrst derivative) and Jacobian
(second derivative) of the energy functional for the hyperelastic model, picking
a suitable ﬁnite element basis and then hand-coding the corresponding ﬁnite
element kernels in a low-level language (C, Fortran, C++) for performance.
Speciﬁcally:

1. The symbolic residual and Jacobian can be derived automatically using
the symbolic diﬀerentiation capabilities of UFL. By contrast taking these
derivatives by hand can be tedious and error-prone.

2. The compilation of the UFL description of the problem by FFC into the
associated low level kernels is entirely automated. Again, this step is often
time consuming and diﬃcult to perform manually.

3. Because of the high-level description of the problem it is possible to exper-
iment quickly with diﬀerent concrete ﬁnite element formulations (material
models, basis functions, element topology etc.) without manually modify-
ing low-level kernel code.

The potential of this high-level approach for solid mechanics were recognised
early on in the development of FEniCS, with two chapters in the FEniCS
Book [Ølgaard and Wells, 2012, Narayanan, 2012] promoting this direction. Since
then, FEniCS has been used in a large number of publications on the topic of hy-
perelastic large-deformation elasticity e.g. [Baroli et al., 2012, Phunpeng and Baiz, 2015,
Weis et al., 2017, Nguyen-Thanh et al., 2019, Patte et al., 2022].

Recently the FEniCS Project has undergone a major redevelopment, result-
ing in the new FEniCSx components; DOLFINx (the ﬁnite element problem
solving environment, replacing DOLFIN), FFCx (the FEniCSx Form Compiler,
replacing FFC) and Basix [Scroggs et al., 2022] (a ﬁnite element basis function
tabulator, replacing FIAT [Kirby, 2004]). UFL is largely unchanged from the
version used in the old FEniCS components and Firedrake.

In this work we do not use DOLFINx. DOLFINx contains the basic ﬁnite
element data structures and algorithms (e.g. meshes, function spaces, assembly,
interfacing with linear algebra data structures in e.g. PETSc []) and there-
fore there is a signiﬁcant overlap with the functionality already available in
SOFA. Directly interfacing DOLFINx and SOFA at the Application Program-
ming Interface (API) level would be a signiﬁcant technical challenge due to the
substantial diﬀerences in their internal data structures. Dedicated weak cou-
pling libraries such as PreCICE [Rodenberg et al., 2021] could be an interesting
alternative to API coupling, but it is not a path that we explore in this work.
Instead, the approach taken by SOniCS is to only use UFL and FFCx (which
in turn depends on Basix) to convert the high-level description of the ﬁnite
element problem into low-level C code, which are then called using SOFA’s
existing C++ ﬁnite element data structures and algorithms. Compared with
coupling DOLFINx and SOFA directly, our approach creates a relatively light
compile-time coupling between FEniCS (speciﬁcally, the generated C code) and

8

SOFA (a large complex C++ code with many dependencies). Consequently, no
additional runtime dependencies required for SOFA. This methodology will be
familiar to users of the DOLFINx C++ inteface where C ﬁnite element kernels
are generated in a ﬁrst step using UFL and FFCx and are then integrated into
the DOLFINx solver in a second step through a standard compile/include/link
approach. Without going into excessive detail, two changes in the redeveloped
FEniCSx components have made SOniCS signiﬁcantly easier to realise:

1. Basix and FFCx have full support for Serendipity ﬁnite elements of arbi-

trary polynomial order following the construction of Arnold and Awanou [Arnold and Awanou, 2011].
Serendipity elements are used in SOFA and there was a desire to continue
supporting Serendipity basis function due to their lower number of degrees
of freedom per cell and generally lower number of local computations com-
pared with standard tensor-product Lagrange elements. We remark that
despite the widespread use of Serendipity elements in many solvers, they
can only obtain optimal order convergence on aﬃnely-mapped meshes, see
e.g. [Arbogast et al., 2022] for more details.

2. FFCx outputs C99 compliant code according to the UFCx interface, which
is speciﬁed as a C header ﬁle included with FFCx. This is in contrast with
FFC, which outputs C++03 compliant code conforming to an interface
speciﬁed with a C++ header ﬁle. This switch makes it signiﬁcantly easier
to call FFCx generated kernels from libraries with a C Foreign Function
Interface (FFI) such as Python and Julia, or any language which can easily
call functions with a C ABI (e.g. Fortran). Although SOFA is a C++
libraries and could certainly call C++ generated kernels, the C interface
is simpler to use, consisting only of structs containing basic native data
types and functions.

2 SOniCS

In this section, we present more in-depth the SOniCS (SOFA + FEniCS) plugin.
We ﬁrst introduce the procedure for deﬁning the material model, the element
geometry, and the quadrature rule or degree using the UFL (Python) syntax.
For simplicity, we only focused on a Saint Venant-Kirchhoﬀ model. But the
method can be generalized to all element types following the pipeline shown in
ﬁgure 1. Secondly, we explain the methodology for converting the UFL script
into eﬃcient C kernels. Finally, we show the interface between the SOniCS
plugin and SOFA, stating the conceptual and coding diﬀerences. For simplicity
and as the modular mechanics plugin’s name (Caribou) might change, we use
the name SOFA to denote the combination of SOFA and the modular mechanics
plugin.

9

Figure 1: Description of the SOniCS pipeline (on the right) and diﬀerences with
SOFA(on the left). In SOFA, each element has to be deﬁned, embedding its ge-
ometry, shape functions (including derivatives), and the quadrature scheme and
degree. In SOniCS, it has been replaced by two Python lines of code for de-
scribing the element and its quadrature. The same beneﬁt goes for the material
model description. In SOFA, each material has to be created in a separated ﬁle
stating its strain energy, derivating by the hand the second Piola Kirchhoﬀ ten-
sor (S) and its Jacobian. It was replaced in SOniCS by only deﬁning the strain
energy of the desired material model in UFL. The derivative of the strain en-
ergy will then be automatically calculated using the ﬀcx module. Finally, both
plugins share the same Forceﬁeld methods for assembling the global residual
vector (R) and stiﬀness matrix (K).

10

2.1 UFL: from FE model to Python code

The ﬁrst step is to deﬁne the FE model using the UFL syntax in a Python
script. As an example, in listing 1, we describe the 3D simplest hyperelastic
model and element: Saint Venant-Kirchhoﬀ with linear Lagrange ﬁnite elements
on tetrahedra. In the context of hyperelastic simulations, we will exclusively
describe features that users could be interested in customizing.

# Test function

# Incremental displacement

1 # material . py
2 from ufl import ( Coefficient , Constant , Identity ,
3 TestFunction , TrialFunction , inner , ds ,
4 VectorElement , derivative , dx , grad ,
5 tetrahedron , tr , variable )
6
7 # Function spaces
8 cell = tetrahedron
9 d = cell . g e o m e t r i c_ d i m e n s i o n ()
10 element = VectorElement ( " Lagrange " , cell , 1)
11
12 # Trial and test functions
13 du = TrialFunction ( element )
14 v = TestFunction ( element )
15
16 # Functions
17 u = Coefficient ( element )
18 B = Coefficient ( element )
19 B = Coefficient ( element )
20
21 # Kinematics
22 I = Identity ( d )
23 F = variable ( I + grad ( u ) )
24 C = variable ( F . T * F )
25 E = variable (0.5 * ( C - I ) )
26
27 # Elasticity parameters
28 young = Constant ( cell )
29 poisson = Constant ( cell )
30 mu = young / (2 * (1 + poisson ) )
31 lmbda = young * poisson / ((1 + poisson ) * (1 - 2 * poisson ) )
32
33 # Stored strain energy density ( compressible Neo - Hookean model )
34 psi = ( lmbda / 2) * tr ( E ) ** 2 + mu * tr ( E * E )
35
36 # Total potential energy
37 Pi = psi * dx ( degree =1) - inner (B , u ) * dx ( degree =1) - inner (T , u )

# Displacement from previous iteration

# Body forces
# Traction forces

# Right Cauchy - Green tensor

# Green - Lagrange tensor

# Deformation gradient

# Identity tensor

* ds ( degree =1)

38
39 # First variation of Pi ( directional derivative about u in the

direction of v )
40 F = derivative ( Pi , u , v )
41
42 # Compute Jacobian of F
43 J = derivative (F , u , du )
44
45 # Export forms

11

46 forms = [F , J , Pi ]

Listing 1: Python code example (material.py) of a Saint Venant-Kirchhoﬀ
material model using Lagrange linear tetrahedron.

Element: After importing the necessary packages, we can deﬁne the element
geometry. In listing 1, on line 10, we used a linear Lagrange tetrahedron. The
user can easily modify diﬀerent parameters of the element, such as the geometry,
the family type, or the interpolation degree. For example, by only changing line
10 to

element = VectorElement (" Serendipity " , hexahedron , 2)

the element is now a quadratic Serendipity hexahedron. Note that VectorElement
creates by default a function space of vector ﬁeld equal to the spatial di-
mension. A complete list of the element available in the Basix documenta-
tion [Scroggs et al., 2022].

Material model: By deﬁnition, boundary value problems for hyperelastic
media can be expressed as minimization problems. For a domain Ω ⊂ R3, the
goal is to ﬁnd the displacement ﬁeld u : Ω → R3 that minimizes the total
potential energy Π. The potential energy is given by

Π(u) =

(cid:90)

Ω

ψ(u) dx −

(cid:90)

Ω

B · u dx −

(cid:90)

∂Ω

T · u ds,

(1)

where ψ is the elastic stored energy density, B is a body force (per unit reference
volume), and T is a traction force (per unit reference area) prescribed on a
boundary ∂Ω (of measure ds) of the domain Ω (of measure dx).

In listing 1, at line 37, we deﬁne the strain energy of a Saint Venant-Kirchhoﬀ

material model as:

ψ =

λ
2

tr(E)2 + µtr(E2),

(2)

where λ and µ are Lam´e material constants while E is the Green Lagrange
strain tensor. Therefore, we observe that tensor E is expressed with respect to
the displacement u, which is the unknown displacement ﬁeld. Moreover, λ and
µ are a function of the Young’s modulus and of Poisson’s ratio that are assumed
to be known constants.

If the user would like to change the material model for Neo-Hookean with

the strain energy density

ψ =

µ
2

(IC − 3) − µln(J) +

λ
2

ln(J)2.

(3)

It would only require in replacing line 31 with:

psi = ( mu / 2) * ( Ic - 3) - mu * ln ( J ) + ( lmbda / 2) * ( ln ( J ) ) ** 2

in addition to previously deﬁning the corresponding kinematics variables J =
det(F ) and IC = tr(C).

J = det ( F )
I_C = tr ( C )

12

Quadrature rule: In listing 1, at line 37, when calculating the total po-
tential energy it is also possible to choose the quadrature rule and the de-
gree. In our example, we selected a quadrature degree of 1, triggering by de-
fault the Zienkiewicz and Taylor scheme [Zienkiewicz et al., 2014] for tetrahe-
dra. Hence, the user could also choose to use a Gauss-Jacobi quadrature of
degree 2 [Ralston and Rabinowitz, 2001] by replacing line 37 with:

Pi = psi * dx ( degree =2 , scheme =" Gauss - Jacobi ")

- inner (B , u ) * dx (

degree =2 , scheme =" Gauss - Jacobi ") - inner (T , u ) * ds ( degree =2 ,
scheme =" Gauss - Jacobi ")

.

2.2 FFCx: from Python code to eﬃcient C kernels

In the particular case of static hyperelastic simulations, we solve the following
non-linear system of equation

K(u) · du = R(u) − f (u).

(4)

The R tensor is called the residual vector and is deﬁned as the Gˆateaux deriva-
tive of the total potential energy Π with respect to change in the displacement
u in direction v

dΠ(u + (cid:15)v)
d(cid:15)
The tensor K is the Jacobian (also called stiﬀness in the context of mechanics)
matrix and corresponds to the derivative of R

|(cid:15)=0.

R =

(5)

K =

dR(u + (cid:15)du)
d(cid:15)

|(cid:15)=0.

(6)

Solving the non linear system in equation 4 can be achieved using the
Newton-Raphson algorithm that will iteratively solve a set of linear systems,
assuming an initial guess un

un+1 = un − du.

(7)

The two tensors can be derived symbolically and exported using the UFL
syntax with the function derivative, as shown at lines 40 and 43 in listing 1. A
simple call to ffcx will create a .c and .h ﬁles containing the code for generating
the local R and K tensors.
$ ffcx material . py

2.3

Integration in SOniCS

In SOFA, the deﬁnitions of the residual and stiﬀness tensors are carried out
within a C++ ﬁle, HyperelasticForcefield.cpp. Each material model is in a sep-
arate ﬁle. So far, only Saint Venant-Kirchhoﬀ and Neo-Hookean models have
been implemented. The users can easily access those functionalities through
Python wrappers:

13

node . addObject ( " S a i n t V e n a n t K i r c h h o f f M a t e r i a l " , young_modulus =E ,

poisson_ratio = nu )

node . addObject ( ’ H y p e r e l a s t i c F o r c e f i e l d ’)

Listing 2: Python deﬁnition of a hyperealstic forceﬁeld in SOFA using a Saint
Venant-Kirchhoﬀ material model.

The HyperelasticForcefield contains several functions, but we are particularly
focusing on two of them. The addForce and assemble_stiffness functions are
assembling the global residual and stiﬀness tensors respectively. Algorithm 1
details the addForce function, while algorithm 2 presents our reimplementation
of the procedure. We did not detail the assemble_stiffness as it involves the
exact same diﬀerences between the two implementations.

Algorithm 1 SOFA addForce function. The addForce function is in charge of
assembling the global residual vector.

1: for element in elements do
2:
3:
4:

X ← element.positions (cid:46) return the current positions of the element
(cid:46) zero the global residual vector of dimension (DOFs ×3)
Rglobal ← 0
Rlocal ← 0 (cid:46) zero the local residual vector of dimension (element DOFs

5:

6:

7:

8:

9:
10:
11:
12:

13:

14:
15:

16:
17:
18:

19:

×3)

for quadrature in quadratures do
detJ ← det(quadrature.nodes)

quadrature nodes

(cid:46) return the Jacobian of the

dN ← quadrature.nodes.shape functions derivatives (cid:46) return

the derivatives of the shape functions of the quadrature nodes

w ← quadrature.nodes.weights

(cid:46) return the weights of the

quadrature nodes

F ← X T · dN
J ← det(F )
C ← F T · F
S ← f(C, MaterialParameters) (cid:46) return the second Piola-Kirchhoﬀ

depending on the material parameters and kinematics tensors

for i in range(0, NumberOfNodesPerElement) do

dx ← dN [i]T
Rlocal[i] ← (detJ · w) · F · S · dx (cid:46) allocate the result in the local

residual vector
end for

end for
for i in range(0, NumberOfNodesPerElement) do
Rglobal[global(i)] ← Rglobal[global(i)] − Rlocal[i]

(cid:46) i indicates the

element node index while global(i) denotes the global node index

end for

20:
21: end for

The structure is similar but we can still observe a few diﬀerences.

14

Algorithm 2 SOniCS addForce function. The addForce function is in charge
of assembling the global residual vector.

1: for element in elements do
2:
3:

X ← element.positions (cid:46) return the current positions of the element
X0 ← element.rest positions
(cid:46) return the initial positions of the

element

4:
5:

6:
7:

8:

9:

10:

11:
12:
13:
14:

B ← gravity
T ← element.forces

(cid:46) return the body forces
(cid:46) return the traction forces applied on the

element

u ← X − X0
Rglobal ← 0
Rlocal ← 0

(cid:46) zero the global residual vector of dimension (DOFs ×3)
(cid:46) zero the local boundary conditions residual vector of

dimension (element DOFs ×3)

Rbc

local ← 0 (cid:46) zero the local residual vector of dimension (element DOFs

×3)

constants ← MaterialParameters
Rlocal ← tabulate tensor(Rlocal, u, B, constants, X0)
Rbc
local ← tabulate tensor(Rlocal, u, T, constants, X0)
for i in range(0, NumberOfNodesPerElement) do

(cid:46) return the material parameters

Rglobal[global(i)] ← Rglobal[global(i)] − (Rlocal[i] + Rbc

(cid:46)
i indicates the element node index while global(i) denotes the global node
index

local[i])

end for

15:
16: end for

15

• The new implementation of algorithm 2 is more concise and involves less
visible tensorial operations because all those operations are eﬃciently hard
coded in the C ﬁle provided by FFCx. For example, in algorithm 1, lines
5 to 17 were replaced in the new algorithm 2 by solely line 11.

• Algorithm 2 needs to have access to the initial position of the object and
to the displacement vector. This was indeed not needed in the previous
implementation since the modular mechanics plugin takes advantage of
writing the deformation gradient only based on the current nodal coordi-
nates x:

F = I + ∇Ω0u = I + ∇Ω0(x − x0) = ∇Ω0x.

(8)

∇Ω0 and x0 respectively denote the gradient and the nodal coordinates
in the initial conﬁguration, thus saving one extra vector operation.

• In the SOFA implementation, the boundary conditions and body forces
are treated in separate ﬁles. In the new implementation of the Forceﬁeld
1, the boundary conditions and body forces are now directly carried out
It avoids calling another function
in the Forceﬁeld on lines 11 and 12.
to loop again through every element of the object, thus speeding up the
assembly of the residual vector.

Based on this new implementation, we created a new forceﬁeld HyperelasticForcefield_FEniCS

as close as possible to the existing syntax of HyperelasticForcefield. We also
needed to tune the existing material deﬁnition to replace unnecessary calcula-
tions and allow us to read the corresponding .c ﬁle.

node . addObject ( " FEniCS_Materia l " , material = " S a i n t V e n a n t K i r c h h o f f " ,

young_modulus =E , poisson_ratio = nu )

node . addObject ( ’ H y p e r e l a s t i c F o r c e f i e l d _ F E n i C S ’)

Listing 3: Python deﬁnition of a hyperelastic forceﬁeld in SOniCS using a Saint
Venant-Kirchhoﬀ material model.

Finally, the last hurdle was the element deﬁnitions.

Indeed, SOFA and
FEniCS do not use the same vertices, edges, and facets ordering (as shown in
ﬁgure 2). To avoid any conﬂict with the existing users of SOFA and solve the
ordering issue, we proposed rearranging the topology indices, edges, and vertices
and create new elements. It ensured an accurate integration over the elements
(especially for quadratic Serendipity integrating over the edges) and preserved
an appropriate visualization. Those elements have been interfaced with the
existing topology named CaribouTopology.

node . addObject ( ’ CaribouTopol og y ’ , name = ’ topology ’ , template = "

Hexahedron " , indices = mesh . cells_dict [ ’ hexahedron ’ ])

node . addObject ( ’ CaribouTopol og y ’ , name = ’ topology ’ , template = "

He xah edr on_F Eni CS " , indices = mesh . cells_dict [ ’ hexahedron ’ ][: ,
[4 , 5 , 0 , 1 , 7 , 6 , 3 , 2]])

Listing 4: Python deﬁnition of hexahedron topology in SOFA and SOniCS.

16

(a) FFCx/Basix.

(b) SOFA.

Figure 2: Local numbering of element vertices and edges in both FEniCS and
SOFA

(a) Hexahedral elements.

(b) Tetrahedral elements.

Figure 3: Cantilever beam domain discretization and displacement ﬁeld. Ω is a
domain represented by a squared-section beam of dimensions 80 × 15 × 15m3,
considered ﬁxed on the right side (u = 0 on ΓD) while Neumann boundary
conditions are applied on the left side (ΓN ).

3 Numerical examples

In this section we describe three numerical examples used for the validation
of our SOniCS implementation. We use the same domain description for each
example while varying the boundary conditions and material parameters of each
simulation.

Let Ω be a domain represented by a squared-section beam of dimensions
80×15×15m3, considered ﬁxed on the right side (u = 0 on ΓD) while Neumann
boundary conditions are applied on the left side (ΓN ), as shown in ﬁgure 3a and
3b.

Ω was discretized using two diﬀerent geometrical elements using linear and
quadratic interpolations. P1 and P2 elements stand for linear or quadratic
tetrahedra, while Q1 and Q2 denote linear and quadratic hexahedra.

To solve each hyperlastic formulation described in equation 4 we used an
identical implementation of the classical Newton Raphson (NR) solver for SOn-
iCS, SOFA and FEBio. The solver had the following parameters: a maximum
of 25 iterations with a residual and displacement tolerance of 10−10. In order to
compare the running time of the two implementations, we, therefore, introduced

17

the mean NR iteration time. We deﬁned the NR iteration time as the duration
for assembling and factorizing the system matrix, solving and propagating the
unknown increment, updating, and computing the force and displacement resid-
ual. After checking that the same number of iterations have been achieved, we
averaged the total time over the number of iterations needed for the solver con-
vergence. All calculations were performed using an Intel® Core™ i5-6300HQ
CPU @ 2.30GHz × 4 processor with a 16GiB memory and a NV117 / Mesa
Intel® HD Graphics 530 (SKL GT2) graphics card.

We evaluated the soundness of the SOniCS solution using SOFA, FEBio or
a manufactured solution as the reference solution and computed the Euclidean
relative L2 error (e(u, v)) [Odot et al., 2022].

e(u, v) =

||u − v||
||v||

,

(9)

where u and v are the calculated displacements for SOniCS and the reference
implementation, respectively.

In this section, we ﬁrst compare our solution with an analytical one: the
manufactured solution. Then, we consider a clamped cantilever beam subject
to Neumann boundary conditions and compare its deformation with the SOFA
solution. Finally, using the same cantilever beam, we implemented a Mooney
Rivlin model (uncoded in SOFA) using SOniCS and compared the solution with
FEBio.

3.1 Manufactured solution

Aiming at code veriﬁcation, the method of the manufactured solution con-
sists in choosing an exact solution to the problem as an analytical expres-
sion [Chamberland et al., 2010]. The chosen analytical expression is then in-
serted into the Partial Diﬀerential Equation (PDE) under consideration to ﬁnd
the conditions that lead to this solution. In general, the manufactured chosen
solution is expressed in simple primitive functions like sin(), exp(), tanh(), etc...
In the context of hyperelastic equations, we considered the following manufac-
tured solution for the displacement

u(x, y, z) =





10−2 · z · ex
10−2 · z · ey
10−2 · z · ez



 on Ω.

(10)

Starting from the above chosen displacement and using continuum mechanics
laws, the relative analytical forces are applied as Neumann boundary conditions
and deduced as follows

F = Id + grad(u),

P =

∂W
∂F

,

f = −∇ · P on ΓN .

18

(11)

(12)

(13)

Where F is the deformation gradient, Id is the identity matrix of dimension
d, P is the ﬁrst Piola-Kirchhoﬀ stress tensor and W is the strain energy density
depending on the material model constitutive law. We used a Saint Venant-
Kirchhoﬀ material (2) with a Young’s Modulus of 3 kPa and a Poisson’s ratio
of 0.3, the computation of this solution was performed using Python Sympy
package [Meurer et al., 2017].

In this experiment, we generated 8 and 6 discretizations of P1 and P2 el-
ements, respectively, with a decreasing element size in both scenarios. For
each discretization, we applied the relative analytical forces deduced from the
manufactured solution (10) and used SOniCS Saint Venant-Kirchhoﬀ material
implementation with the same parameters as Sympy’s to ﬁll the domain. The
displacements obtained were compared to the chosen analytical solution in equa-
tion (10) for each discretization. The results are presented in ﬁgure 4, the error
metric is the relative mean error in equation (9).

Figure 4: Plot of the mesh convergence analysis of the manufactured solution.
The L2 error between the analytical and the SOniCS simulation is calculated
for diﬀerent mesh reﬁnement with ﬁxed parameters (E=3 kPa and ν=0.3) for
P1 linear tetrahedra (blue) and P2 quadratic tetrahedra (red) elements.

3.2 Benchmark with SOFA

The cantilever beam deﬂection is a classical mechanical test case, as you can
smoothly reﬁne the mesh due to the simplicity of the geometry or modify its
In this context, the beam
boundary conditions to ﬁt real-life experiments.
was still clamped on the right side (natural Dirichlet condition on ΓD) while
Neumann boundary conditions were applied on the left side (ΓN ). To compare
our SOniCS implementation, we model the deformation of the beam with two

19

hyperelastic material models: Saint Venant-Kirchhoﬀ and Neo-Hookean. We
ﬁxed the mechanical parameters and the Neumann boundary conditions equal
to −10 Pa in the y direction, until reaching suﬃcient large deformations with
the same parameters as before: E = 3 kPa and ν = 0.3.

This study aims at comparing the ﬁnite element solutions provided by SOn-
iCS and SOFA under the same constraints in terms of computational and run-
ning time performances. To do so, we computed the mean relative L2 error
(e(uSOniCS, uSOFA)) between the SOniCS solution using SOFA as the reference
solution.

The results obtained are presented in tables 1 and 2 for Saint Venant-

Kirchhoﬀ and Neo-Hookean materials, respectively.

Element

P1
P2
Q1
Q2

Saint Venant-Kirchhoﬀ material model

Number
DOFs
351
1875
351
1143

of

SOniCS mean NR
iteration time (ms)
2.00
8.16
2.00
15.66

SOFA mean NR it-
eration time (ms)
4.4
13.33
7.16
16.33

e

5.87e-14
7.14e-14
1.53e-13
1.66e-13

Table 1: Mean relative error (e(uSOniCS, uSOFA) deﬁned in equation 9) and mean
NR (Newton-Raphson) iteration time between SOniCS and SOFA for diﬀerent
element geometries and interpolation schemes using Saint Venant-Kirchhoﬀ ma-
terial model. P1 and P2 elements stand for linear or quadratic tetrahedra, while
Q1 and Q2 denote linear and quadratic hexahedra.

Neo-Hookean material model

Element

P1
P2
Q1
Q2

Number
DOFs
351
1875
351
1143

of

SOniCS mean NR
iteration time (ms)
1.17
21.16
2.16
17.14

SOFA mean NR it-
eration time (ms)
1.8
29.16
7.3
20.42

e

2.17e-14
7.53e-14
1.89e-13
1.64e-13

Table 2: Mean relative error (e(uSOniCS, uSOFA) deﬁned in equation 9) and mean
NR (Newton-Raphson) iteration time between SOniCS and SOFA for diﬀer-
ent element geometries and interpolation schemes using Neo-Hookean material
model. P1 and P2 elements stand for linear or quadratic tetrahedra, while Q1
and Q2 denote linear and quadratic hexahedra.

3.3 Benchmark with FEBio

FEBio is a open-source ﬁnite element package speciﬁcally designed for biome-
chanical applications. It oﬀers modeling scenarios, a wide range of constitutive

20

material models, and boundary conditions relevant to numerous research areas
in biomechanics. In this section, FEBio was used to compute the same scenarios
as in section 3.2 to evaluate the trustworthiness of SOniCS. A more advanced
constitutive material model, Mooney Rivlin, was introduced for this purpose

ψ = C01

(cid:0)IC − 3(cid:1) + C10

(cid:0)IIC − 3(cid:1) +

K
2

ln(J).

(14)

Where C01, C10, and K are the material constants in addition to the modiﬁed
invariants IC = J − 2
3 IIC deﬁned based on the classic invariants
(cid:0)(tr(C))2 − tr (cid:0)C2(cid:1)(cid:1). In order to obtain suﬃciently large
IC = tr(C), IIC = 1
2
deformations, we chose the following material parameters: C01 = 2000 Pa, C10 =
100 Pa, and K = 1000 Pa.

3 IC, IIC = J − 4

Tables 3, 4, 5 show the results obtained for Saint Venant-Kirchhoﬀ, Neo-
Hookean and Mooney Rivlin material models and considering the four discretiza-
tions implemented so far in SOniCS. The error evaluation is still based on the
mean relative error deﬁned in equation 9 using FEBio as the reference while
using a Newton Raphson solver with the same characteristics in both cases.

Element

P1
P2
Q1
Q2

Saint Venant-Kirchhoﬀ material model

Number
DOFs
351
1875
351
1143

of

SOniCS mean NR
iteration time (ms)
1.6
18.25
4.60
16.75

FEBio mean NR it-
eration time (ms)
9.11
20.95
5.66
30.7

e

6.01e-10
0.08
4.19e-10
0.13

Table 3: Mean relative error (e(uSOniCS, uFEBio) deﬁned in equation 9) and mean
NR (Newton-Raphson) iteration time between SOniCS and FEBio for diﬀer-
ent element geometries and interpolation schemes using Saint Venant-Kirchhoﬀ
material model. P1 and P2 elements stand for linear or quadratic tetrahedra,
while Q1 and Q2 denote linear and quadratic hexahedra.

4 Hozapfel and Ogden anisotropic material model

coupled with haptic simulation

In the context of numerical surgical simulations, a robot haptic feedback has
been shown to be a consistent tool for drastically improving user-interactions
and opening up countless applications. Among them, haptic devices have mainly
been used as a training tool for surgeons. Indeed prior to surgery, under the
assumption of known geometry and mechanical properties of the patient’s or-
gan, a surgeon would be able to plan and better choose between speciﬁc sur-
gical paths/approaches. In this paper, we used the 3D Systems Touch Haptic
Device robot coupled with the SOFA plugin Geomagic to allow interactions

21

Neo-Hookean material model

Element

P1
P2
Q1
Q2

Number
DOFs
351
1875
351
1143

of

SOniCS mean NR
iteration time (ms)
5.20
14.30
4.83
18.00

FEBio mean NR it-
eration time (ms)
8.78
19.10
5.41
28.10

e

6.53e-10
1.5e-2
8.08e-10
0.09

Table 4: Mean relative error (e(uSOniCS, uFEBio) deﬁned in equation 9) and mean
NR (Newton-Raphson) iteration time between SOniCS and FEBio for diﬀer-
ent element geometries and interpolation schemes using Neo-Hookean material
model. P1 and P2 elements stand for linear or quadratic tetrahedra, while Q1
and Q2 denote linear and quadratic hexahedra.

Element

P1
P2
Q1
Q2

Mooney Rivlin material model

Number
DOFs
351
1875
351
1143

of

SOniCS mean NR
iteration time (ms)
3.75
15.81
4.00
22.28

FEBio mean NR it-
eration time (ms)
8.53
16.85
5.76
23.61

e

2.49e-9
9.97e-3
10.92
4.23e-2

Table 5: Mean relative error (e(uSOniCS, uFEBio) deﬁned in equation 9) and mean
NR (Newton-Raphson) iteration time between SOniCS and FEBio for diﬀerent
element geometries and interpolation schemes using Mooney Rivlin material
model. P1 and P2 elements stand for linear or quadratic tetrahedra, while Q1
and Q2 denote linear and quadratic hexahedra.

between the instrument and the simulations. For this hypothetical simula-
tion, we virtually simulate the contact between a surgical tool and a liver
during surgery. The liver was described by an anisotropic Holzapfel Ogden
model [Holzapfel and Ogden, 2009, Pezzuto et al., 2014], with an existing FEn-
iCS implementation [Hauseux et al., 2018].

ψ = ψiso (F ) + ψvol(J).

(15)

ψiso and ψvol are the isochoric and volumetric part of the strain energy
density function respectively. The volumetric part can be evaluated as a function
of the bulk modulus κ of the material and J

ψvol (J) =

κ
4

(J 2 − 1 − 2ln(J)),

ψiso (F ) =

a
2b

exp [b (I1 − 3)] +

(cid:88)

bi (I4i − 1)2(cid:105)
(cid:104)

+

exp

ai
2bi

(cid:0)exp (cid:2)bfsI2

8fs

(cid:3) − 1(cid:1) ,

i=f,s
afs
2bfs

22

(16)

(17)

with

I4f = f0 · C · f0, I4s = s0 · C · s0, and I8fs = f0 · C · s0.

(18)

The transversely isotropic behavior can be obtained by removing the param-
eters af s, bf s, as and bs, while the isotropic behavior is obtained by also sup-
pressing the two parameters af and bf . This kind of model is frequently used to
model orthotropic materials (e.g. muscle with ﬁbers or tendons). Vectors f0, s0
are the unit base vectors normal to the planes of symmetry. For our application,
we selected the same material properties as chosen in [Hauseux et al., 2018].

The instrument is assumed to be a rigid body kinematically constrained
by the haptic device position at each time step. The contact forces gener-
ated by the collision between the instrument and the liver are calculated us-
ing frictional contact and an implicit Euler scheme to solve the dynamic sys-
tem [Courtecuisse et al., 2013]. Finally, the contact forces are transmitted back
to the user’s hand through the haptic device. The result is a simulation run-
ning at 100 FPS (Frames Per Seconds) on average displayed in ﬁgure 5. A full
video of the interaction with the haptic device is available in the Supplemen-
tary Materials. The real-time performance has been obtained by using a small
number of DOFs (543). A higher number of DOFs could be used once a GPU
implementation is available.

Figure 5: Numerical simulation of a liver in contact with a surgical tool con-
nected to a haptic device. On the right, the 3D Systems Touch Haptic Device
is controlled by the user. On the left, the liver is modeled using a Holzapfel
Ogden anisotropic material in contact with the surgical tool (in red) guided by
In case of contact detection, the contact forces are transmitted to
the user.
the user through the haptic device. A video of the simulation is available as
supplementary materials.

23

5 Discussion

We shows that the SOniCS plugin is an eﬃcient implementation of material
models for hyperelastic simulations and enables the user to develop an intu-
itive understanding of the impact of modelling choices on accuracy reliability of
the predictions. We ﬁrst demonstrated a convergence study for Saint Venant-
Kirchhoﬀ material using P1 and P2 elements with the manufactured solution
in section 3.1. Indeed, as expected, by reﬁning the mesh, the L2 relative error
almost linearly decreases when increasing the number of DOFs (on a log-log
plot), showing the stability of our method.

Then, from section 3.2, two main results are noteworthy from tables 1 and
2. First, the relative error of the displacement between SOniCS and SOFA,
for both material models, is close to machine precision for P1, P2, Q1, and
Q2 discretizations. Finally, the last comment concerns the mean NR iteration
time. We observe that the SOniCS implementation is slightly faster than SOFA.
The diﬀerence increases when using more DOFs, e.g., 2.40 ms diﬀerence for
P1 against 5.17 ms diﬀerence for P2 elements for the Saint Venant-Kirchhoﬀ
model. The reason for this diﬀerence is the need for SOFA to compute the
shape functions and derivatives, then calculate the local residual and Jacobian
using multiple tensor operations. Conversely, SOniCS has all those operations
eﬃciently hard-coded in C kernels, thus performing faster than SOFA.

We compared the SOniCS and FEBio simulations for several material mod-
els: Saint Venant-Kirchhoﬀ, Neo-Hookean, and Mooney-Rivlin in section 3.3.
For P1 elements, the errors are close to machine precision for all 3 models. For
P2 and Q2 elements, the 3 models display similar errors that still represent a
minor error (less than 0.08 and 0.1, respectively) which is of same magnitude
between SOFA and FEBio, as well as FEniCS and FEBio. The reasons for those
minor errors could be the diﬀerence in the implementation of the elements or in
the choice of solver parameters. For Q1 elements, we reached an accuracy near
machine precision for Saint Venant-Kirchhoﬀ and Neo-Hookean. However, the
relative error rose close to 11 for the Mooney-Rivlin model. To further under-
stand this divergence, we used a third open-source software AceGen. AceGen
also uses an automatic code generation package for the symbolic generation of
new ﬁnite elements. The cantilever beam scenario presented in section 3.3 was
reproduced using AceGen under the same conditions and with a Q1 discretiza-
tion of the domain. Using the same metric as deﬁned in equation 9, the results
are the following: e(uSOniCS, uAcegen) = 3.33 and e(uFEBio, uAcegen) = 14.19. Even
if SOniCS and Acegen showed similar results, a more in-depth study would be
needed to conﬁrm the soundness of our solution. Despite using a ﬁner mesh, the
error was getting slightly lower but was still noticeable. Eventually, FEBio has
shown diﬃculty in converging with trivial parameter sets or when increasing
the number of DOFs. Thus, as shown in tables 3,4, and 5, on average, SOn-
iCS is solving the equation system faster than FEBio. Several reasons could
explain those diﬀerences, such as the number of quadrature points used, the
implementation of the Newton-Raphson scheme, or the solver parameters.

Finally, we showed the capabilities of the SOniCS plugin in simulating com-

24

plex material models such as the Holzapfel Ogden anisotropic model coupled
with a haptic device in section 4. The material model was eﬀortlessly imple-
mented for several elements (P1, P2, Q1, and Q2) without needing any manual
derivation or coding. The result is a real-time simulator functional for surgeons’
training or any other biomechanics simulation replicating the behavior of a liver
in contact with a surgical tool. It was not possible to verify our simulation as
we did not ﬁnd any similar implementation of such material in any open-source
software.

6 Conclusion and outlook

We performed several numerical experiments to develop intuitive understanding
of new material models in SOFA using the SOniCS plugin. First, we validated
the most common hyperelastic material models: Saint Venant-Kirchhoﬀ and
Neo-Hookean using a manufactured solution. Then, utilizing FEBio as a refer-
ence, we validated our implementation of a Mooney-Rivlin material model using
P1, P2, Q1, and Q2 elements. The ﬁnal application employed a haptic device
to interact with an anisotropic Holzapfel Ogden liver model in real-time.

The study used our SOniCS plugin to generate optimized C code for com-
plex material models compatible with SOFA. On one side, we beneﬁted from
FEniCS automatic diﬀerentiation and code generation capabilities to bypass the
diﬃculties of deriving and implementing the consistent Jacobian in SOFA. On
the user side, we implemented compatible and user-friendly SOFA forceﬁelds to
use the FEniCS C kernels. A SOFA user can now easily deﬁne a new material
model by specifying its strain energy function, element geometry or family and
the quadrature scheme and degree only in Python. We made the open-source
code and all data and test cases available as the supplementary material.

In future work, we intend to apply the SOniCS plugin for solving more
complex mechanical phenomena. For example, mixed formulations for solving
incompressible materials, viscous or plastic eﬀects, and multi-material systems.
In this paper, we only utilized the plugin for solving hyperelasticity equations,
but it would be interesting to tackle multi-physics problems such as thermome-
chanics or magnetomechanics. We only used Lagrangian P1, P2, Q1, and Q2
elements while more geometries such as prisms could be relevant for the SOFA
and FEniCS community. Finally, our validation only focused on the deforma-
tion ﬁeld of the structures, while a more in-depth study would also enable us to
validate an analytical stress ﬁeld.

Some work remains to improve user-friendliness of our package.

Indeed,
even if writing the Python ﬁle describing the material model and generating the
associated C ﬁle is mostly eﬀortless and automated, some steps are still manual.
Indeed, the FEniCS_Material C++ class must have knowledge of every new C ﬁle
created at compile time. Hence, for the moment, the user still has to manually
specify two C++ functions in the code and recompile the whole plugin. Even
if this step is manageable, it still requires diving into the C++ code, which can
discourage a few users. Meanwhile, to mitigate this eﬀect, actions have been

25

taken by providing detailed documentation and tutorials for this crucial step.
In addition, future works aim at improving this stage by directly providing the
path of the C ﬁle in the Python code to trigger just-in-time compilation for new
materials.

Acknowledgements

This project has received funding from the European Union’s Horizon 2020
research and innovation programme under the Marie Sklodowska-Curie grant
agreement No. 764644. This abstract only contains the RAINBOW consor-
tium’s views and the Research Executive Agency and the Commission are not
responsible for any use that may be made of the information it contains. This
publication has been prepared in the framework of the DRIVEN project funded
by the European Union’s Horizon 2020 Research and Innovation programme
under Grant Agreement No. 811099. This study is supported by the Na-
tional Research Fund, Luxembourg, and cofunded under the Marie Curie Ac-
tions of the European Commission (FP7-COFUND) Grant No. 6693582. This
project is supported by the ”IHU Strasbourg - Institut de chirurgie guid´ee par
l’image” Strasbourg, France. The authors would like to acknowledge Thomas
Lavigne for providing the Acegen simulation, editing Figure 5, and reviewing
the manuscript. The authors would also like to thank Dr. Michal Habera and
Dr. Matthew Scroggs for their help with the quadratic hexahedron Serendipity
elements.

References

[Ahrens et al., 2005] Ahrens, J., Geveci, B., and Law, C. (2005). Paraview: An

end-user tool for large data visualization. Visualization Handbook.

[Allard et al., 2012] Allard, J., Courtecuisse, H., and Faure, F. (2012). Chapter
21 - implicit fem solver on gpu for interactive deformation simulation. In mei
W. Hwu, W., editor, GPU Computing Gems Jade Edition, Applications of
GPU Computing Series, pages 281–294. Morgan Kaufmann, Boston.

[Alnaes et al., 2015] Alnaes, M. S., Blechta, J., Hake, J., Johansson, A., Kehlet,
B., A. Logg, C. R., Ring, J., Rognes, M. E., and Wells, G. N. (2015). The
FEniCS project version 1.5. Archive of Numerical Software, 3.

[Alnæs et al., 2014] Alnæs, M. S., Logg, A., Ølgaard, K. B., Rognes, M. E., and
Wells, G. N. (2014). Uniﬁed Form Language: A Domain-speciﬁc Language
for Weak Formulations of Partial Diﬀerential Equations. ACM Trans. Math.
Softw., 40(2):9:1–9:37.

[Arbogast et al., 2022] Arbogast, T., Tao, Z., and Wang, C. (2022). Direct
serendipity and mixed ﬁnite elements on convex quadrilaterals. Numerische
Mathematik, 150(4):929–974.

26

[Arnold and Awanou, 2011] Arnold, D. N. and Awanou, G. (2011). The
Serendipity Family of Finite Elements. Foundations of Computational Math-
ematics, 11(3):337–344.

[Arruda and Boyce, 1993] Arruda, E. M. and Boyce, M. C. (1993). A three-
dimensional constitutive model for the large stretch behavior of rubber elastic
materials. Journal of the Mechanics and Physics of Solids, 41(2):389–412.

[Baroli et al., 2012] Baroli, D., Quarteroni, A., and Ruiz-Baier, R. (2012). Con-
vergence of a stabilized discontinuous galerkin method for incompressible non-
linear elasticity. Advances in Computational Mathematics, 39(2):425–443.

[Barrera, 2021] Barrera, O. (2021). A uniﬁed modelling and simulation for cou-
pled anomalous transport in porous media and its ﬁnite element implemen-
tation. Computational Mechanics, 68.

[Bastian et al., 2021] Bastian, P., Blatt, M., Dedner, A., Dreier, N.-A., Engwer,
C., Fritze, R., Gr¨aser, C., Gr¨uninger, C., Kempf, D., Kl¨ofkorn, R., Ohlberger,
M., and Sander, O. (2021). The Dune framework: Basic concepts and recent
developments. Computers & Mathematics with Applications, 81:75–112.

[Bianchi et al., 2017] Bianchi, D., Monaldo, E., Gizzi, A., Marino, M., Filippi,
S., and Vairo, G. (2017). A fsi computational framework for vascular phys-
iopathology: A novel ﬂow-tissue multiscale strategy. Medical Engineering &
Physics, 47:25–37.

[Borazjani, 2013] Borazjani, I. (2013). Fluid–structure interaction, immersed
boundary-ﬁnite element method simulations of bio-prosthetic heart valves.
Computer Methods in Applied Mechanics and Engineering, 257:103–116.

[Bordas et al., 2006] Bordas, S., Nguyen, V. P., Dunant, C., Nguyen Dang, H.,
and Guidoum, A. (2006). An extended ﬁnite element library. International
Journal for Numerical Methods in Engineering, 2:1–33.

[Boyer et al., 2013] Boyer, G., Molimard, J., Ben Tkaya, M., Zahouani, H.,
Pericoi, M., and Avril, S. (2013). Assessment of the in-plane biomechanical
properties of human skin using a ﬁnite element model updating approach
combined with an optical full-ﬁeld measurement on a new tensile device.
Journal of the Mechanical Behavior of Biomedical Materials, 27:273–282.

[Brunet, 2020] Brunet, J.-N. (2020). Exploring new numerical methods for the
simulation of soft tissue deformations in surgery assistance. Theses, Univer-
sit´e de Strasbourg, 4 Rue Blaise Pascal.

[Bui et al., 2018] Bui, H. P., Tomar, S., Courtecuisse, H., Cotin, S., and Bor-
das, S. P. A. (2018). Real-time error control for surgical simulation. IEEE
Transactions on Biomedical Engineering, 65(3):596–607.

27

[Bulle et al., 2021] Bulle, R., Alotta, G., Marchiori, G., Berni, M., Lopomo,
N. F., Zaﬀagnini, S., Bordas, S., and Barrera, O. (2021). The human meniscus
behaves as a functionally graded fractional porous medium under conﬁned
compression conditions. Applied Sciences, 11:9405.

[Chagnon et al., 2014] Chagnon, G., Rebouah, M., and Favier, D. (2014). Hy-
perelastic energy densities for soft biological tissues: A review. Journal of
Elasticity, 120.

[Chamberland et al., 2010] Chamberland, ´E., Fortin, A., and Fortin, M. (2010).
Comparison of the performance of some ﬁnite element discretizations for large
deformation elasticity problems. Computers & Structures, 88(11-12):664–673.

[Chinesta et al., 2014] Chinesta, F., Keunings, R., and Leygue, A. (2014).
The proper generalized decomposition for advanced numerical simulations. A
primer.

[Comas et al., 2008] Comas, O., Taylor, Z., Allard, J., Ourselin, S., Cotin, S.,
and Passenger, J. (2008). Eﬃcient nonlinear fem for soft tissue modelling and
its gpu implementation within the open source framework sofa. pages 28–39.
Springer.

[Costa et al., 2001] Costa, K. D., Holmes, J. W., and Mcculloch, A. D. (2001).
Modelling cardiac mechanical properties in three dimensions. Philosophical
Transactions of the Royal Society of London. Series A: Mathematical, Phys-
ical and Engineering Sciences, 359(1783):1233–1250.

[Cotin et al., 1999] Cotin, S., Delingette, H., and Ayache, N. (1999). Real-time
elastic deformations of soft tissues for surgery simulation. IEEE Transactions
on Visualization and Computer Graphics, 5(1):62–73.

[Courtecuisse et al., 2013] Courtecuisse, H., Allard, J., Kerfriden, P., Bordas,
S., Cotin, S., and Duriez, C. (2013). Real-time simulation of contact and
cutting of heterogeneous soft-tissues. Medical image analysis, 18:394–410.

[Courtecuisse et al., 2014] Courtecuisse, H., Allard, J., Kerfriden, P., Bordas,
S. P., Cotin, S., and Duriez, C. (2014). Real-time simulation of contact and
cutting of heterogeneous soft-tissues. Medical Image Analysis, 18(2):394–410.

[Cowin, 1999] Cowin, S. C. (1999). Bone poroelasticity. Journal of Biomechan-

ics, 32(3):217–238.

[DeSalvo and Swanson, 1985] DeSalvo, G. J. and Swanson, J. A. (1985). AN-
SYS engineering analysis system users manual. Swanson Analysis Systems,
Houston, Pa.

[Deshpande et al., 2022] Deshpande, S., Lengiewicz, J., and Bordas, S. P.
(2022). Probabilistic deep learning for real-time large deformation simula-
tions. Computer Methods in Applied Mechanics and Engineering, 398:115307.

28

[Duriez, 2013] Duriez, C. (2013). Control of elastic soft robots based on real-
time ﬁnite element method.
In 2013 IEEE International Conference on
Robotics and Automation, pages 3982–3987. 2013 IEEE International Con-
ference on Robotics and Automation.

[Duriez et al., 2006] Duriez, C., Dubois, F., Kheddar, A., and Andriot, C.
(2006). Realistic haptic rendering of interacting deformable objects in virtual
environments. IEEE Transactions on Visualization and Computer Graphics,
12(1):36–47.

[Ehlers and Markert, 2001] Ehlers, W. and Markert, B. (2001). A linear vis-
coelastic biphasic model for soft tissues based on the theory of porous media.
Journal of biomechanical engineering, 123:418–24.

[Elouneg et al., 2021] Elouneg, A., Sutula, D., Chambert, J., Lejeune, A., Bor-
das, S., and Jacquet, E. (2021). An open-source fenics-based framework for
hyperelastic parameter estimation from noisy full-ﬁeld data: Application to
heterogeneous soft tissues. Computers & Structures, 255:106620.

[Faure et al., 2012] Faure, F., Duriez, C., Delingette, H., Allard, J., Gilles, B.,
Marchesseau, S., Talbot, H., Courtecuisse, H., Bousquet, G., Peterlik, I., and
Cotin, S. (2012). SOFA: A Multi-Model Framework for Interactive Physical
In Payan, Y., editor, Soft Tissue Biomechanical Modeling for
Simulation.
Computer Assisted Surgery, volume 11 of Studies in Mechanobiology, Tissue
Engineering and Biomaterials, pages 283–321. Springer.

[Flynn et al., 2011] Flynn, C., Taberner, A., and Nielsen, P. (2011). Mechanical
characterisation of in vivo human skin using a 3d force-sensitive micro-robot
and ﬁnite element analysis. Biomechanics and modeling in mechanobiology,
10:27–38.

[Geuzaine and Remacle, 2009] Geuzaine, C. and Remacle, J.-F. (2009). Gmsh:
a three-dimensional ﬁnite element mesh generator with built-in pre- and post-
processing facilities. International Journal for Numerical Methods in Engi-
neering, 79:1309–1331.

[Gibbons, 1934] Gibbons, C. H. (1934). History of testing machines for mate-

rials. Transactions of the Newcomen Society, 15(1):169–184.

[Gilles et al., 2011] Gilles, B., Bousquet, G., Faure, F., and Pai, D. K. (2011).

Frame-based elastic models. ACM Trans. Graph., 30(2).

[Goury et al., 2016] Goury, O., Amsallem, D., Bordas, S., Liu, W., and Ker-
friden, P. (2016). Automatised selection of load paths to construct reduced-
order models in computational damage micromechanics:
from dissipation-
driven random selection to bayesian optimization. Computational Mechanics,
58.

29

[Goury and Duriez, 2018] Goury, O. and Duriez, C. (2018). Fast, generic, and
reliable control and simulation of soft robots using model order reduction.
IEEE Transactions on Robotics, 34(6):1565–1576.

[Guo et al., 2021] Guo, G., Zou, Y., and Liu, P. X. (2021). A new rendering
algorithm based on multi-space for living soft tissue. Computers & Graphics,
98:242–254.

[Haj-Ali and Muliana, 2004] Haj-Ali, R. M. and Muliana, A. H. (2004). Nu-
merical ﬁnite element formulation of the schapery non-linear viscoelastic ma-
terial model. International Journal for Numerical Methods in Engineering,
59(1):25–45.

[Han et al., 2011] Han, L., Hipwell, J., Tanner, C., Taylor, Z., Mertzanidou, T.,
Cardoso, M. J., Ourselin, S., and Hawkes, D. (2011). Development of patient-
speciﬁc biomechanical models for predicting large breast deformation. Physics
in medicine and biology, 57:455–72.

[Hauseux et al., 2017] Hauseux, P., Hale, J. S., and Bordas, S. P. (2017). Ac-
celerating monte carlo estimation with derivatives of high-level ﬁnite element
models. Computer Methods in Applied Mechanics and Engineering, 318:917–
936.

[Hauseux et al., 2018] Hauseux, P., Hale, J. S., Cotin, S., and Bordas, S. P.
(2018). Quantifying the uncertainty in a hyperelastic soft tissue model with
stochastic parameters. Applied Mathematical Modelling, 62:86–102.

[Holzapfel and Ogden, 2009] Holzapfel, G. A. and Ogden, R. W. (2009). Con-
stitutive modelling of passive myocardium: a structurally based framework
for material characterization. Philosophical Transactions of the Royal Society
A: Mathematical, Physical and Engineering Sciences, 367(1902):3445–3475.

[Itskov, 2001] Itskov, M. (2001). A generalized orthotropic hyperelastic material
model with application to incompressible shells. International Journal for
Numerical Methods in Engineering, 50(8):1777–1799.

[Jacquemin and Bordas, 2021] Jacquemin, T. and Bordas, S. P. A. (2021). A
uniﬁed algorithm for the selection of collocation stencils for convex, concave,
and singular problems. International Journal for Numerical Methods in En-
gineering, 122(16):4292–4312.

[Jansari et al., 2019] Jansari, C., Natarajan, S., Beex, L., and Kannan, K.
(2019). Adaptive smoothed stable extended ﬁnite element method for weak
discontinuities for ﬁnite elasticity. European Journal of Mechanics - A/Solids,
78:103824.

[Jasak et al., 2007] Jasak, H., Jemcov, A., and Kingdom, U. (2007). Openfoam:
A c++ library for complex physics simulations. International Workshop on
Coupled Methods in Numerical Dynamics, IUC, pages 1–20.

30

[Kirby, 2004] Kirby, R. C. (2004). Algorithm 839: FIAT, a New Paradigm
for Computing Finite Element Basis Functions. ACM Trans. Math. Softw.,
30(4):502–516.

[Kirby and Logg, 2006] Kirby, R. C. and Logg, A. (2006). A Compiler for Vari-

ational Forms. ACM Trans. Math. Softw., 32(3):417–444.

[Lavigne et al., 2022] Lavigne, T., Scium`e, G., Laporte, S., Pillet, H., Urcun,
S., Wheatley, B., and Rohan, P.-Y. (2022). Soci´et´e de biom´ecanique young
investigation of the time-dependent
investigator award 2021: Numerical
stress–strain mechanical behaviour of skeletal muscle tissue in the context
of pressure ulcer prevention. Clinical Biomechanics, 93:105592.

[Lengiewicz et al., 2021] Lengiewicz, J., Habera, M., Zilian, A., and Bordas,
S. (2021).
Interfacing acegen and fenics for advanced constitutive models.
In Baratta, I., Dokken, J. S., Richarson, C., and Scroggs, M. W., editors,
Proceedings of FEniCS 2021, online, 22–26 March, page 474.

[Lim et al., 2006] Lim, Y.-J., Hu, J., Chang, C.-Y., and Tardella, N. (2006).
Soft tissue deformation and cutting simulation for the multimodal surgery
training.
In 19th IEEE Symposium on Computer-Based Medical Systems
(CBMS’06), pages 635–640. 19th IEEE Symposium on Computer-Based Med-
ical Systems.

[Maas et al., 2012] Maas, S., Ellis, B., Ateshian, G., and Weiss, J. (2012).
Febio: Finite elements for biomechanics. Journal of biomechanical engineer-
ing, 134:011005.

[Malgat et al., 2015] Malgat, R., Gilles, B., Levin, D. I. W., Nesme, M., and
Faure, F. (2015). Multifarious hierarchies of mechanical models for artist
assigned levels-of-detail. In Proceedings of the 14th ACM SIGGRAPH / Eu-
rographics Symposium on Computer Animation, SCA ’15, page 27–36, New
York, NY, USA. Association for Computing Machinery.

[Marchesseau et al., 2010] Marchesseau, S., Heimann, T., Chatelin, S., Will-
inger, R., and Delingette, H. (2010). Fast porous visco-hyperelastic soft tis-
sue model for surgery simulation: Application to liver surgery. Progress in
Biophysics and Molecular Biology, 103(2):185–196. Special Issue on Biome-
chanical Modelling of Soft Tissue Motion.

[Martins et al., 2006] Martins, P. A. L. S., Natal Jorge, R. M., and Ferreira, A.
J. M. (2006). A comparative study of several material models for prediction
of hyperelastic properties: Application to silicone-rubber and soft tissues.
Strain, 42(3):135–147.

[Mazier et al., 2022] Mazier, A., Bilger, A., Forte, A., Peterlik, I., Hale, J.,
and Bordas, S. (2022). Inverse deformation analysis: an experimental and
numerical assessment using the fenics project. Engineering with Computers.

31

[Menard, 2011] Menard, M. (2011). Game Development with Unity. Course

Technology Press, Boston, MA, USA, 1st edition.

[Meurer et al., 2017] Meurer, A., Smith, C. P., Paprocki, M., ˇCert´ık, O., Kir-
pichev, S. B., Rocklin, M., Kumar, A., Ivanov, S., Moore, J. K., Singh, S.,
Rathnayake, T., Vig, S., Granger, B. E., Muller, R. P., Bonazzi, F., Gupta,
H., Vats, S., Johansson, F., Pedregosa, F., Curry, M. J., Terrel, A. R., Rouˇcka,
v., Saboo, A., Fernando, I., Kulal, S., Cimrman, R., and Scopatz, A. (2017).
Sympy: symbolic computing in python. PeerJ Computer Science, 3:e103.

[Miguez Pacheco et al., 2014] Miguez Pacheco, V., Hench, L., and Boccaccini,
A. (2014). Bioactive glasses beyond bone and teeth: Emerging applications
in contact with soft tissues. Acta Biomaterialia, 13.

[Mihai et al., 2017] Mihai, L. A., Budday, S., Holzapfel, G. A., Kuhl, E., and
Goriely, A. (2017). A family of hyperelastic models for human brain tissue.
Journal of the Mechanics and Physics of Solids, 106:60–79.

[Mihai et al., 2015] Mihai, L. A., Chin, L., Janmey, P., and Goriely, A. (2015).
A comparison of hyperelastic constitutive models applicable to brain and fat
tissues. Journal of The Royal Society Interface, 12:1–12.

[Mooney, 1940] Mooney, M. (1940). A theory of large elastic deformation. Jour-

nal of Applied Physics, 11(9):582–592.

[Narayanan, 2012] Narayanan, H. (2012). A computational framework for non-
linear elasticity. In Logg, A., Mardal, K.-A., and Wells, G., editors, Automated
Solution of Diﬀerential Equations by the Finite Element Method, number 84
in Lecture Notes in Computational Science and Engineering, pages 525–541.
Springer Berlin Heidelberg.

[Nguyen et al., 2008] Nguyen, V. P., Rabczuk, T., Bordas, S., and Duﬂot, M.
(2008). Meshless methods: A review and computer implementation aspects.
Mathematics and Computers in Simulation, 79(3):763–813.

[Nguyen-Thanh et al., 2019] Nguyen-Thanh, V. M., Zhuang, X., and Rabczuk,
T. (2019). A deep energy method for ﬁnite deformation hyperelasticity. Eu-
ropean Journal of Mechanics - A/Solids, page 103874.

[Niroomandi et al., 2013] Niroomandi, S., Gonz´alez, D., Alfaro, I., Bordeu, F.,
Leygue, A., Cueto, E., and Chinesta, F. (2013). Real time simulation of
biological soft tissues : A pgd approach. International journal for numerical
methods in biomedical engineering, 29.

[Odot et al., 2022] Odot, A., Haferssas, R., and Cotin, S. (2022). Deepphysics:
A physics aware deep learning framework for real-time simulation. Interna-
tional Journal for Numerical Methods in Engineering, 123(10):2381–2398.

32

[Ogden, 1972] Ogden, R. (1972). Large deformation isotropic elasticity – on
the correlation of theory and experiment for incompressible rubberlike solids.
Proceedings of the Royal Society of London. A. Mathematical and Physical
Sciences, 326(1567):565–584.

[Patte et al., 2022] Patte, C., Genet, M., and Chapelle, D. (2022). A quasi-
static poromechanical model of the lungs. Biomechanics and Modeling in
Mechanobiology, 21(2):527–551.

[Payan and Ohayon, 2017] Payan, Y. and Ohayon, J. (2017). Preface. In Payan,
Y. and Ohayon, J., editors, Biomechanics of Living Organs, volume 1 of
Translational Epigenetics, pages xxv–xxvi. Academic Press, Oxford.

[Pezzuto et al., 2014] Pezzuto, S., Ambrosi, D., and Quarteroni, A. (2014). An
orthotropic active–strain model for the myocardium mechanics and its nu-
merical approximation. European Journal of Mechanics - A/Solids, 48:83–96.

[Phunpeng and Baiz, 2015] Phunpeng, V. and Baiz, P. (2015). Mixed ﬁnite
element formulations for strain-gradient elasticity problems using the fenics
environment. Finite Elements in Analysis and Design, 96:23–40.

[Picinbono et al., 2003] Picinbono, G., Delingette, H., and Ayache, N. (2003).
Non-linear anisotropic elasticity for real-time surgery simulation. Graphical
Models, 65(5):305–321. Special Issue on SMI 2002.

[Ralston and Rabinowitz, 2001] Ralston, A. and Rabinowitz, P. (2001). A ﬁrst
course in numerical analysis (2nd ed.). In A First Course in Numerical Anal-
ysis (Second Edition), page i. Dover Publications, New York, second edition
edition.

[Rappel et al., 2019a] Rappel, H., Beex, L., Hale, J., Noels, L., and Bordas, S.
(2019a). A tutorial on bayesian inference to identify material parameters in
solid mechanics. Archives of Computational Methods in Engineering, 27.

[Rappel et al., 2019b] Rappel, H., Beex, L., Noels, L., and Bordas, S. (2019b).
Identifying elastoplastic parameters with bayes’ theorem considering output
error, input error and model uncertainty. Probabilistic Engineering Mechan-
ics, 55:28–41.

[Rathgeber et al., 2016] Rathgeber, F., Ham, D. A., Mitchell, L., Lange, M.,
Luporini, F., Mcrae, A. T. T., Bercea, G.-T., Markall, G. R., and Kelly, P.
H. J. (2016). Firedrake: Automating the Finite Element Method by Com-
posing Abstractions. ACM Transactions on Mathematical Software (TOMS),
43(3):24:1–24:27.

[Richardson et al., 2021] Richardson, S. I. H., Gao, H., Cox, J., Janiczek, R.,
Griﬃth, B. E., Berry, C., and Luo, X. (2021). A poroelastic immersed ﬁ-
nite element framework for modelling cardiac perfusion and ﬂuid–structure
interaction. International Journal for Numerical Methods in Biomedical En-
gineering, 37(5):e3446.

33

[Rodenberg et al., 2021] Rodenberg, B., Desai, I., Hertrich, R., Jaust, A., and
Uekermann, B. (2021). FEniCS–preCICE: Coupling FEniCS to other simu-
lation software. SoftwareX, 16:100807.

[Sanders, 2016] Sanders, A. (2016). An Introduction to Unreal Engine 4. A. K.

Peters, Ltd., USA.

[Scroggs et al., 2022] Scroggs, M. W., Baratta, I. A., Richardson, C. N., , and
Wells, G. N. (2022). Basix: a runtime ﬁnite element basis evaluation library.
submitted to Journal of Open Source Software.

[Simon, 1992] Simon, B. R. (1992). Multiphase Poroelastic Finite Element Mod-
els for Soft Tissue Structures. Applied Mechanics Reviews, 45(6):191–218.

[Sinaie et al., 2017] Sinaie, S., Nguyen, V. P., Thanh Nguyen, C., and Bordas,
S. (2017). Programming the material point method in julia. Advances in
Engineering Software, 105.

[Smith, 2009] Smith, M. (2009). ABAQUS/Standard User’s Manual, Version

6.9. Dassault Syst`emes Simulia Corp, United States.

[Stokes et al., 2010] Stokes, I., Chegini, S., Ferguson, S., Gardner-Morse, M.,
Iatridis, J., and Laible, J. (2010). Limitation of ﬁnite element analysis of
poroelastic behavior of biological tissues undergoing rapid loading. Annals of
biomedical engineering, 38:1780–8.

[Tagliabue et al., 2021] Tagliabue, E., Piccinelli, M., Dall’Alba, D., Verde, J.,
Pfeiﬀer, M., Marin, R., Speidel, S., Fiorini, P., and Cotin, S. (2021). Intra-
operative update of boundary conditions for patient-speciﬁc surgical simula-
tion. Medical Image Computing and Computer Assisted Intervention – MIC-
CAI 2021, pages 373–382.

[Talebi et al., 2013] Talebi, H., Silani, M., Bordas, S. P. A., Kerfriden, P., and
Rabczuk, T. (2013). A computational library for multiscale modeling of ma-
terial failure. Computational Mechanics, 53(5):1047–1071.

[Turini et al., 2019] Turini, G., Condino, S., Fontana, U., Piazza, R., Howard,
J., Celi, S., Positano, V., Ferrari, M., and Ferrari, V. (2019). Software frame-
work for vr-enabled transcatheter valve implantation in unity. pages 376–384.
nternational Conference on Augmented Reality, Virtual Reality and Com-
puter Graphics.

[Urcun et al., 2021a] Urcun, S., Rohan, P.-Y., Scium`e, G., and Bordas, S.
(2021a). Cortex tissue relaxation and slow to medium load rates depen-
dency can be captured by a two-phase ﬂow poroelastic model. Journal of the
Mechanical Behavior of Biomedical Materials, 126:104952.

[Urcun et al., 2021b] Urcun, S., Rohan, P.-Y., Skalli, W., Nassoy, P., Bordas, S.
P. A., and Scium`e, G. (2021b). Digital twinning of cellular capsule technology:
Emerging outcomes from the perspective of porous media mechanics. PLOS
ONE, 16(7):1–30.

34

[Veronda and Westmann, 1970] Veronda, D. and Westmann, R. (1970). Me-
chanical characterization of skin—ﬁnite deformations. Journal of Biome-
chanics, 3(1):111–124.

[Verschoor et al., 2018] Verschoor, M., Lobo, D., and Otaduy, M. A. (2018).
Soft hand simulation for smooth and robust natural interaction.
In 2018
IEEE Conference on Virtual Reality and 3D User Interfaces (VR), pages
183–190. IEEE Conference on Virtual Reality and 3D User Interfaces (VR).

[Weis et al., 2017] Weis, J. A., Miga, M. I., and Yankeelov, T. E. (2017). Three-
dimensional image-based mechanical modeling for predicting the response of
breast cancer to neoadjuvant therapy. Computer Methods in Applied Me-
chanics and Engineering, 314:494–512. Special Issue on Biological Systems
Dedicated to William S. Klug.

[Weiss et al., 1996] Weiss, J. A., Maker, B. N., and Govindjee, S. (1996). Finite
element implementation of incompressible, transversely isotropic hyperelas-
ticity. Computer Methods in Applied Mechanics and Engineering, 135(1):107–
128.

[Wu et al., 2014] Wu, J., Westermann, R., and Dick, C. (2014). Real-time hap-
tic cutting of high-resolution soft tissues. Studies in health technology and
informatics, 196:469–75.

[Zeraatpisheh et al., 2021] Zeraatpisheh, M., Bordas, S. P., and Beex, L. A.
(2021). Bayesian model uncertainty quantiﬁcation for hyperelastic soft tissue
models. Data-Centric Engineering, 2:e9.

[Zhou and Fung, 1997] Zhou, J. and Fung, Y. C. (1997). The degree of nonlin-
earity and anisotropy of blood vessel&#x2009;elasticity. Proceedings of the
National Academy of Sciences, 94(26):14255–14260.

[Zienkiewicz et al., 2014] Zienkiewicz, O., Taylor, R., and Fox, D. (2014). The
ﬁnite element method for solid and structural mechanics. In The Finite El-
ement Method for Solid and Structural Mechanics (Seventh Edition), page i.
Butterworth-Heinemann, Oxford, seventh edition edition.

[Ølgaard and Wells, 2012] Ølgaard, K. B. and Wells, G. N. (2012). Applica-
tions in solid mechanics. In Logg, A., Mardal, K.-A., and Wells, G., editors,
Automated Solution of Diﬀerential Equations by the Finite Element Method:
The FEniCS Book, Lecture Notes in Computational Science and Engineering,
pages 505–524. Springer, Berlin, Heidelberg.

35

