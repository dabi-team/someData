If you cite this paper, please use the EWSN reference: L. Boeckmann, P. Kietzmann, L. Lanzieri, T. C. Schmidt, M. Wählisch. Usable Security for an
IoT OS: Integrating the Zoo of Embedded Crypto Components Below a Common API. In Proc. of EWSN, ACM, 2022.

Usable Security for an IoT OS: Integrating the Zoo of Embedded
Crypto Components Below a Common API

Lena Boeckmann1, Peter Kietzmann1, Leandro Lanzieri1, Thomas C. Schmidt1, Matthias Wählisch2

1HAW Hamburg, 2Freie Universität Berlin
{lena.boeckmann, peter.kietzmann, leandro.lanzieri, t.schmidt}@haw-hamburg.de,
m.waehlisch@fu-berlin.de

2
2
0
2

g
u
A
4
2

]

R
C
.
s
c
[

2
v
1
8
2
9
0
.
8
0
2
2
:
v
i
X
r
a

Abstract

IoT devices differ widely in crypto-supporting hardware,
ranging from no hardware support to powerful accelerators
supporting numerous of operations including protected key
storage. An operating system should provide uniform access
to these heterogeneous hardware features, which is a partic-
ular challenge in the resource constrained IoT. Effective se-
curity is tied to the usability of cryptographic interfaces. A
thoughtful API design is challenging, and it is beneﬁcial to
re-use such an interface and to share the knowledge of pro-
gramming embedded security widely.

In this paper, we integrate an emerging cryptographic in-
terface into usable system-level calls for the IoT operating
system RIOT, which runs on more than 240 platforms. This
interface supports ID-based key handling to access key ma-
terial in protected storage without exposing it to anyone. Our
design foresees hardware acceleration on all available vari-
ants; our implementation integrates diverse cryptographic
hardware and software backends via the uniform interface.
Our performance measurements show that the overhead of
the uniform API with integrated key management is negli-
gible compared to the individual crypto operation. Our ap-
proach enhances the usability, portability, and ﬂexibility of
cryptographic support in the IoT.

Categories and Subject Descriptors

D.4.6 [Operating Systems]: Security and Protection;
B.8.2 [Performance and Reliability]: Performance Anal-
ysis and Design Aids; D.2.8 [Software Engineering]: Met-
rics—complexity measures, performance measures

General Terms

Design, Security, Experimentation

Keywords. Internet of Things, Embedded Security, Crypto
Hardware

Figure 1: Variety of backends covered by the uniﬁed
cryptographic API.

1

Introduction

The number of devices connected to the Internet of
Things (IoT) is rapidly growing and so is its threat poten-
tial [3, 20, 25]. It is an urgent demand to harden the security
of the IoT ecosystem. An important part of securing the IoT
is the deployment of cryptographic operations, which often
strain resources and do not comply with device constraints.
Optimized libraries and crypto-supporting hardware help in
mitigating resource conﬂicts. A proper use, however, re-
quires specialized knowledge in selecting and programming
these crypto components.

In this paper, we follow the goal of integrating an OS-
level cryptographic API with interchangeable hardware and
software backends in the IoT operating system RIOT. Kiet-
zmann et al. [22] proposed a solution that uses the system
level APIs of the cipher and hash modules that already exist
in RIOT. We argue that a common, well-known crypto API
is a better choice, as it increases usability, portability, and
provides interfaces for operations that are difﬁcult to support
in software on the OS level for constrained, low-end devices.
There is a need for a new architecture to support all the
different hardware features optimally, while hiding its com-
plexity at the lowest possible overhead. In our solution, the
choice of crypto backends is transparent and the API ab-
stracts speciﬁc libraries and vendor drivers away. We use
semi-automatic compile time conﬁgurations to provision the
available backends for each board. This enables develop-
ers to program security without the concern about the actual
support.

CryptoAPIVendorDriversRIOTCoreLibThirdPartyLibsPeripheralHWCryptoPeripheralHWCrypto&KeyStorageExternalHWCrypto&KeyStorageCryptoSoftware 
 
 
 
 
 
The remainder of this paper is structured as follows. Sec-
tion 1 discusses basic aspects of crypto-support on embedded
devices together with related work and describes RIOT and
its features. Section 3 discusses our requirements for a cryp-
tographic API and explains our choice. Section 4 presents
our implementation design and architecture. In Section 5, we
evaluate the memory and runtime overhead of our implemen-
tation. Finally, we conclude with an outlook in Section 6.
2 Background and Related Work
2.1 Cryptographic Backends

Different IoT devices provide various options to perform
cryptographic operations as visualized in Figure 1. Our goal
is to select accelerating hardware backends whenever they
are available and fall back to software otherwise.
Peripheral Hardware Accelerators. Cryptographic co-
processors implement selected operations in hardware. They
are faster and consume less energy than software implemen-
tations [22]. Some offer support for full crypto schemes, oth-
ers only provide crypto primitives and require software as-
sistance to perform compound operations. Vendors provide
drivers with proprietary APIs to access hardware crypto op-
erations. They usually accept plain text key material, which
needs to be supplied by the caller.
Peripheral Hardware Accelerators with Key Storage.
Some platforms offer protected key storage in addition to
hardware acceleration. Key material is stored in dedicated
key slots, which are only accessible by the crypto processor.
Driver APIs cannot input plain text keys, but identiﬁers or
slot numbers that indirectly reference keys. The processor
then operates with the key stored in the speciﬁed slot.
External Crypto Devices. External devices (e.g., Secure
Elements) offer tamper proof key storage and cryptographic
processors to perform operations on protected key material.
They connect to a chosen platform via a serial bus. Like ac-
celerators with protected key storage they store key material
in memory slots, which can only be accessed by the device
processor. Different from on-chip accelerators these devices
are not necessarily more efﬁcient than software [22].
Software Implementations.
Applications running on
MCUs without cryptographic hardware features require full
software implementations to execute the crypto operations.
Optimized libraries for constrained devices offer resource
efﬁcient implementations of varying degrees. Except for
Mbed TLS, which implements the ARM PSA Crypto API [7]
and accesses key material through identiﬁer based key man-
agement, APIs of software libraries commonly accept plain
text key material, which is passed to crypto functions by the
caller.
Driver Classiﬁcation. Based on the storage of key ma-
terial two classes of driver or library APIs can be identi-
ﬁed. Transparent Drivers operate on plain text key mate-
rial, which is passed to the implementation via input param-
eters. Backends with transparent driver APIs can be easily
substituted by any other transparent backend, as well as by
most pure software implementations. Opaque Drivers inter-
face platforms, which store their keys in protected memory.
They accept identiﬁers or slot numbers as input, with which

the crypto processor can locate the previously stored internal
keys. To invoke an opaque driver, the location of a key must
be known. We further distinguish between opaque drivers
for external devices and opaque drivers for on-chip hardware
accelerators with key storage.
2.2 RIOT

RIOT [13] is an open source operating system for low-
end IoT devices that runs on architectures ranging from 8-bit
to 32-bit processors. At the time of writing, RIOT supports
240 boards, some of which offer hardware cryptography to
varying extent. A range of symmetric ciphers and hashes
are available from system level software. The package sys-
tem can be used to add cryptographic functionality by in-
cluding external libraries designed for constrained embed-
ded devices. RIOT also integrates the secure element Mi-
crochip ATECC, for which a vendor driver is available as a
package. Overall, RIOT provides heterogeneous backends
of all classes, so that we can demonstrate integration below
the cryptographic interface covering its full complexity.

For conﬁguration, RIOT is currently adopting Kcon-
ﬁg [38], a selection-based conﬁguration system. This fea-
ture is used to select and parametrize modules and packages,
which we leverage for conﬁguring cryptographic backends.
2.3 Related Work
2.3.1 Crypto-Performance w/o OS Level Integration
The performance of plain crypto-backends without OS
level integration on IoT devices has been analyzed repeat-
edly. Pearson et al. [36] compare peripheral- and exter-
nal crypto hardware performance, deploying Espressif and
Arduino libraries. A vendor speciﬁc SDK was used by
Munoz et al. [30] and Lachner et al. [26] to quantify time
and energy requirements of block ciphers running software
and crypto-hardware. Gerez et al. [17] use the same SDK
to measure power consumption of security protocols, de-
ploying crypto-hardware. Similarly, Mades et al. [28] and
Schläpfer et al. [37] compare the (D)TLS overhead on com-
mon IoT boards with and without secure elements and uti-
lize yet another vendor SDK which includes Mbed TLS [6]
as a software library. Noseda et al. [31] show that secure
elements can increase battery life by measuring the perfor-
mance of multiple SEs when performing cryptographic op-
erations and a DTLS handshake over secure CoAP.
2.3.2 Cryptographic Integration at OS Level

Mbed OS [5] is an operating system with OS level crypto.
It integrates the Mbed TLS [6] implementation of the cryp-
tographic API speciﬁed by the ARM Platform Security Ar-
chitecture (PSA) [7,8]. Currently, hardware crypto backends
can be included by providing alternative implementations of
the Mbed TLS cryptographic functions.

Zephyr, FreeRTOS, and Mynewt [4] do not provide uni-
ﬁed system level crypto interfaces. TinyCrypt [21] and Mbed
TLS are ported to Zephyr and Mynewt. Zephyr offers a sys-
tem level cipher API with access to hardware. FreeRTOS
ports WolfSSL [41] and Mbed TLS, and implements the
PKCS#11 [33] interface for hardware crypto support. For
TLS other third-party libraries can be accessed through a
TLS abstraction layer.

Security on ARM devices can be enhanced further by se-
cure ﬁrmware (Trusted Firmware M and A (TF-M, TF-A)
[10, 11]), which are also speciﬁed by PSA and allow for se-
cure execution of cryptographic operations in isolated mem-
ory areas. TF-M is supported by the IoT operating systems
Mbed OS, Zephyr [43] and FreeRTOS [2], among others.

2.3.3 Crypto API Design and Usability

Green and Smith [18] develop ten principles for crypto-
graphic API design. They recommend high-level operations
that are easy to use without cryptographic expertise and with-
out documentation. They should visibly handle errors, use
safe defaults, and be easy to read. Patnaik et al. [35] validate
Green and Smith by analysing several crypto libraries with
regard to their principles. They add that APIs should pro-
vide clear documentation containing guidelines on how to
correctly perform operations and clearly mark insecure algo-
rithms. Mindermann et al. [29] analyze cryptographic APIs
in the Rust programming language and point out the need
for secure, up-to-date example code with high-level inter-
faces and secure defaults. Acar et al. [1] study the usability
and security of Python crypto APIs concluding that security
and usability are inherently linked. In addition, they point
out that protecting and handling key material should not be a
user responsibility. Ukrop and Matyas [39] suggest improve-
ments to the usability of the OpenSSL library. Whytten and
Tygar [40] describe common problems with security in PGP
5.0 and deﬁne a usability standard.

Our subsequent process of selecting a suitable API for
RIOT OS will be guided by the results of these studies and
aims at following their insights.

3 The Search for a Suitable Interface
3.1 Requirements for a Cryptographic API

The objective of this work is to foster usable security for
the IoT by integrating a versatile and effective programming
interface on the OS-level. Hence, we base our requirements
for such a cryptographic API on the principles and recom-
mendations made by existing research, as well as the charac-
teristic constraints of the IoT.
Hardware Platform Portability. Applications using the
interface should run on all hardware platforms supported
by the OS, independent of whether speciﬁc crypto features
are available in hardware. To make this possible the inter-
face should support implementation-agnostic development.
It should abstract library and vendor speciﬁc APIs to enable
easy exchange of backends that perform operations.
Application & OS Portability.
Applications shall be
portable to other OSes that provision the same API without
changing the crypto-related code. Thus, the API should be
widely accepted and supported by other software systems.
Extensiveness. A consistent cryptographic API should sup-
port all available choices of algorithms supported in hard-
ware or software.
It should allow for any combination of
drivers and libraries depending on hardware capabilities. To
be compatible with platforms that offer protected key stor-
age, the API should allow for indirect key access via identi-
ﬁers as well as provide the possibility of importing and using

plain text key material.
Usability. The API shall guide programmers in writing se-
cure applications, even if they are inexperienced in cryptog-
raphy. Therefore, it should have a simple, usable interface.
Calls and defaults shall be designed to avoid traps and acci-
dental misuse. It must be well documented and widely sup-
ported, as to facilitate the search for code examples and help.
The API should provide a way to securely handle keys
and prevent their misuse. It must be possible to restrict usage
of and access to keys by enforcing policies which cannot be
easily overwritten. The interface should produce meaningful
and comprehensible error messages for fault resistance and
easy debugging.
3.2 The PSA Crypto API

PSA Crypto is a cryptographic API speciﬁed by the ARM
Platform Security Architecture (PSA) Framework [7, 8]. The
framework provides a set of standardized resources and
guidelines to facilitate the development of secure IoT sys-
tems. It includes speciﬁcations of functional APIs for cryp-
tography, secure storage, attestation and ﬁrmware updates.
These APIs aim to be platform independent and enable de-
velopers to utilize PSA services. The speciﬁcations are com-
plemented by the PSA test suite [12], which is open source,
implemented in C language and available on GitHub. These
tests can be used to verify the correct implementation of the
functional APIs. Additionally, systems developed using the
PSA guidelines can be certiﬁed on multiple levels by the
PSA Certiﬁed Framework [9].

The IoT OSes Mbed OS, Zephyr and FreeRTOS are al-
ready PSA certiﬁed and recently the library wolfSSL [41]
added a wrapper to utilize PSA Crypto APIs as a backend
for cryptographic operations. These are indicators that PSA
is already widely supported in the IoT industry and will be
further developed and maintained in the future.
Usability. PSA Crypto comes with an extensive and read-
able documentation, which also provides guidelines on how
to correctly perform cryptographic operations and which al-
gorithms and key types are permitted for operations. It marks
insecure legacy algorithms and deﬁnes a broad range of com-
prehensible error values for common usage mistakes. To pre-
vent misuse, the speciﬁcation describes numerous macros to
calculate correct buffer and key sizes. It also provides single-
part operations, which reduce complexity.

The API makes compromises to comply with IoT con-
straints and requirements. Previous research in API usability
recommends the use of high-level protocol APIs (e.g., estab-
lishing an SSL/TLS session), and removing the responsibil-
ity for the choice of appropriate algorithms and parameters
from the user. PSA Crypto is a mid-level API for crypto-
graphic operations utilized by protocols. Developers utiliz-
ing this API still need to choose secure algorithms and pa-
rameters. This has been a concious design decision to enable
applications to implement standard and custom IoT proto-
cols on constrained devices.
It is possible to build higher
level APIs on top of PSA Crypto.
Key Management. The identiﬁer based key management
takes care of storing and handling key material. Keys can
be stored either in volatile or non-volatile memory or in pro-

tected memory slots on physical devices, without exposing
them to the user. Each key is stored together with attributes.
Those contain metadata, such as extensive usage policies to
protect keys from misuse and compromisation, as well as
the location of the key. To access key material, an applica-
tion needs to provide an identiﬁer, which maps to a stored
key. The actual dispatch to a transparent or opaque driver
is handled by the API implementation depending on the key
location. This way PSA supports all types of backends and
drivers described in Section 2.1.
Secure Element Handling. Microcontrollers without hard-
ware crypto and key storage can be extended by secure el-
ements (SE), which provide tamper proof key storage and
selected cryptographic operations. To extend storage capaci-
ties and functionality, it may be desirable to connect multiple
SEs to a platform. From the PSA Crypto reference imple-
mentation in the Mbed TLS Library [6] we can adopt an in-
terface for SEs which makes it possible to manage multiple
external crypto devices at runtime.
Testing. Part of the PSA framework is the PSA Architecture
test suite, which provides extensive tests to verify the imple-
mentations of all PSA functional APIs with and without TEE
integration. These tests can be integrated in RIOT using the
package system.
3.3 Potential Alternatives to PSA

Competing approaches of other libraries also aim to spec-

ify generic interfaces for security services.

The PKCS#11 Cryptographic Token Interface (also called
Cryptoki) [32, 33] is a platform-independent, standard pro-
gramming interface for cryptographic tokens. Tokens can be
hardware security modules or software implementations and
multiple tokens can be connected and accessed at runtime.
Other than PSA, PKCS#11 is not optimized for constrained
IoT systems and was not intended to be a generic crypto-
graphic interface [14].

The Generic Security Service API (GSS API) [27, 42] is
an IETF standard for interfacing between applications and
security devices. It is mainly used by Kerberos 5 and not
optimized for the IoT.
4 Integrating PSA Crypto in RIOT

PSA Crypto enhances RIOT with a consistent system
level crypto API, adding a number of features which were
previously missing.
It integrates the individual software
modules and libraries below a uniﬁed interface, making a
full set of crypto primitives available at the OS level. It en-
ables transparent access to hardware accelerators and secure
elements, while being highly conﬁgurable and ﬂexible and
allowing developers to tailor their application to ﬁt the IoT
constraints. Additionally, it enhances usability and security
by providing a key management module, which removes the
responsibility of securely handling and storing key material
from users.
4.1 Architecture of the Crypto Subsystem

The implementation of PSA Crypto in RIOT is structured
in layers, which arrange as visualized in Figure 2. The up-
per layer 1 comprises the user facing Crypto API. It will be
directly accessed by applications for utilizing cryptographic

operations. The second layer 2 consists of the key man-
agement and location dispatcher. Keys are stored either in
local memory or in protected hardware slots on a device. To
access keys in crypto operations, a key identiﬁer is passed
to the implementation and the key management unit will use
that ID to get key metadata from memory. The location dis-
patcher will check the metadata for the storage location.

If the key is stored on a secure element (SE), it will dis-
patch the call to the SE driver dispatcher 3a . SE drivers
implement the generic SE interface 4a adopted from Mbed
TLS. The SE driver dispatcher will invoke the driver as-
signed to the key storing device, which will trigger the oper-
ation on the underlying secure element.

If the key is stored on-chip in hardware or in local mem-
ory, the location dispatcher will pass the call on to an al-
gorithm dispatcher 3b . This will then check which algo-
rithm should be performed and invoke an algorithm speciﬁc
API 4b , which will be implemented by an opaque or a trans-
parent driver.

Glue code maps the vendor-speciﬁc drivers and library

APIs 5 to the SE API and the algorithmic APIs.
4.2 Key Management

When using PSA Crypto, key material is handled inter-
nally underneath the API, preventing misuse and insecure
storage by inexperienced users. The key management sup-
ports functions for key creation, destruction, and export. A
key will either be created by generation, import, or copy-
ing. Upon creation, the user speciﬁes a set of key attributes,
which include the information about the key location and us-
age policy. The policy determines, in which kind of oper-
ations the key can be used.
It cannot be changed without
destroying the key. This increases security and prevents mis-
use of key material. The location encodes the actual memory
location of the key. This can be either volatile or local per-
sistent memory, or protected storage in hardware.

When generating a key, it will be stored directly in the
location speciﬁed in the attributes. If copying is permitted by
the key policy, an existing key in memory can be duplicated
and stored in another slot. In both cases, the key material is
not exposed to the user. Whenever a user wants to perform
operations on a key that is not stored in memory, the key
must be imported ﬁrst.

In all cases, an identiﬁer is assigned to the newly created
key. For volatile keys, an identiﬁer will be generated and re-
turned to the user. When creating persistent keys, users can
specify their own identiﬁer. Export functions can be used to
extract existing key material from memory, if the key policy
permits it, or to extract the public key of an asymmetric key
pair. A key destruction operation removes unused or com-
promised keys from memory.
Key Storage. To store key attributes, key material and ref-
erences to protected keys, we deﬁne an internal key slot data
structure. A global list contains a conﬁgurable number of
key slot structures. Key sizes can range from as small as 16
bytes for AES-128 keys up to several hundred bytes for RSA
keys. For memory efﬁciency, our implementation requires
ﬂexible key slot sizes.

Our solution (shown in Figure 3) deﬁnes three different

Figure 2: Layered design of cryptographic components
including software and hardware implementations. The
selection of features and instances is performed by a cas-
cade of dispatchers.

Figure 3: The three key slots types are structured differ-
ently depending on the keys they contain. They are stored
in three separate arrays and abstracted by a linked key
slot list.

key slot types, which are stored in three separate memory
arrays 2 . The arrays are abstracted by a linked list 1 . The
ﬁrst three elements of all slots are equal 3 : a list node is
used to link the slot to the global list, the lock count keeps
track of how many applications are currently reading the key
and the key attributes contain the metadata of the stored key.
The structure of the actual key depends on the type of key
that needs to be stored. We differentiate between single keys,
key pairs, and protected keys.
keys

called
psa_key_slot_t 4a .
They store a single plain key
and its size in bytes. They are large enough to store the
largest key required by an application, e.g., 16 bytes for an
AES 128 key or 65 bytes for an ECC P256 public key (when
importing public keys from other entities, we count them as
single keys).

Single

basic

type

the

are

The type psa_key_pair_slot_t 4b always stores an
asymmetric private and public key pair and both key sizes
in bytes.

The third type psa_prot_key_slot_t 4c contains a ref-
erence to a key in protected memory. When creating asym-
metric key pairs on a secure element, often only the private
key is stored on the device and the public key is returned by
the driver. This is why this slot type can also store a public
key, if speciﬁed in the build conﬁguration.

Using the RIOT build system conﬁguration Kconﬁg (see
Section 4.4) we ensure that key slot types are only available if
needed (e.g., slots for key pairs only exist when asymmetric
cryptography is used).

The build conﬁguration scheme can also specify how
many key slots should be allocated for each key type depend-
ing on the application requirements. If no key slot count is
speciﬁed, the application will build with a default value.

Internally we use a linked list to handle the three key
slot types, which allows for transparent access to slots. At

startup, an empty list is created for each of the three arrays,
containing nodes pointing to individual array slots. For ex-
ample, when creating an asymmetric key pair, a node is re-
moved from the empty key pair list and added to the global
key slot list. When destroying a key, the node is removed
from the global list and returned to the empty list for later
reuse.
4.3 Dispatching Operations to a Backend
Secure Element Handling. When utilizing secure elements,
a static location value is assigned to each external device
connected to a platform. Each device driver must imple-
ment all supported methods of the generic SE interface and
provide a structure with pointers to the available functions.
When booting RIOT, the OS startup function auto_init ini-
tializes and registers all devices with the SE management
module. This module stores the function pointers for each
device along with the location and driver context data in a
global driver list. During runtime the location value can be
used to retrieve the associated driver from that list and in-
voke operations on the corresponding device. This way our
implementation can handle multiple SEs at the same time.
Dispatching Unit. To invoke a cryptographic operation on
a stored key, the user selects the desired algorithm with the
key identiﬁer, as shown in the control ﬂow example in Fig-
ure 4. The key management retrieves a pointer to the key slot
from local memory and passes it to the location dispatcher.
The dispatcher will access the key attributes in the slot and
check the location value stored in the attributes, distinguish-
ing between secure elements and all other backends. If the
key location points to a secure element, the key slot is a pro-
tected slot and contains the key reference.

The dispatcher uses the location to retrieve the corre-
sponding driver instance from the list of registered drivers
and passes the call and the key reference to the SE.

IoTProtocols,Applications&TestsPSACryptoAPI1KeyManagement&LocationDispatch2SEDriverDispatch3aAlgorithmDispatch3bSEAPISEAPI4aVendorAPIVendorAPISEDriverSEDriverSpec.AlgorithmAPI4bVendorAPIVendorAPIVendorAPI5opaq.Drivertrans.DriverSoftw.Driver2KeySlotList1ListNodeLockCountKeyAttributesKeyDataKeyBytespsa_key_slot_t34aListNodeLockCountKeyAttributesPrivKeyDataPrivKeyBytesPubKeyDataPubKeyBytespsa_key_pair_slot_t4bListNodeLockCountKeyAttributesKeySlotNoPubKeyDataPubKeyBytespsa_prot_key_slot_t4ccould be implemented by a hardware backend, while
psa_cipher_cbc_aes_256_encrypt could
imple-
mented by a software library.
4.4 Backend Conﬁguration with Kconﬁg

be

The conﬁguration of backends for PSA Crypto is done at
build-time following the speciﬁc system conﬁguration. The
Kconﬁg facility, which has originally been developed for
Linux kernel conﬁgurations, provides user-friendly access to
system conﬁgurations. It can be used to select build-time op-
tions and enable and disable features via a conﬁguration ﬁle
or a graphical interface called menuconﬁg. Modules in RIOT
provide Kconﬁg ﬁles, which deﬁne menus and conﬁguration
symbols shown by the menuconﬁg interface. Users can se-
lect options and features, which are then used in the build
process. Kconﬁg options have dependencies, which deter-
mine whether an option will be visible and selectable. Also
options can be speciﬁed as default selections or be automat-
ically selected if a certain condition is met.

We exploit these features for plugging hardware back-
ends into PSA Crypto transparently following the capabili-
ties of a platform. CPUs and boards in RIOT provide their
own conﬁguration, in which they deﬁne symbols for their
capabilities.
If, for example, a CPU has a crypto periph-
eral that supports hardware cipher operations with AES keys
of the size 128 bits in CBC mode, it deﬁnes the symbol
HAS_PERIPH_CIPHER_AES_128_CBC.

The PSA Crypto module provides its own Kconﬁg ﬁle,
which speciﬁes that if a symbol for hardware crypto is
present at build-time, it is chosen as the default backend for
the application build. The PSA Crypto Kconﬁg ﬁle may also
specify default software backends, which will be built in case
there is no symbol for hardware crypto deﬁned.

If developers do not wish to use the default backend for
an operation, they can use menuconﬁg to select other avail-
able software libraries instead. The options differ depending
on the desired backend and its capabilities. Further Kconﬁg
can be used to optimize memory usage to the use case and
the board constraints. For example, when conﬁguring the
use of an AES 128 cipher operation, key slots will only at-
tain the size to contain the required key. Dedicated symbols
also can be used to deﬁne the required number of key slots
for each type (e.g., PSA_ASYMMETRIC_KEYPAIR_COUNT=12),
and to build only the desired features.
If a user does not
specify a key slot count or backend, default values are used.
5 Evaluation

In this section, we assess the costs and the beneﬁts of
our uniﬁed crypto systems. While costs are mainly due to
memory and processing overhead from the new PSA Crypto
API layer, beneﬁts derive from reduced complexity and code
duplication, but in particular from an enhanced usability of
crypto operations in RIOT. We begin with quantifying the
overheads.
5.1 Measurement Setup

The cost for additional software layers on constrained
embedded devices is critical. We want to quantify these
overheads for a broad range of hardware-software conﬁgu-
rations and use cases. We chose the Nordic nrf52840dk as
our platform base, since it provides an ARM CryptoCell 310

Figure 4: Flow chart of an example PSA cipher encryp-
tion using and AES 128 key in CBC mode.

If

the location does not belong to an SE, but

the call
This dispatcher maps

to
is passed to our al-
some other backend,
the key
gorithm dispatcher.
type, size, and algorithm to an algorithm-speciﬁc API
(e.g., psa_cipher_cbc_aes_128_encrypt for an AES-128
operation in Cipher Block Chaining (CBC) mode). If this
API is implemented by a software library or driver, the con-
tents of the key slot are passed to the corresponding backend.
Mapping the call to its algorithm-speciﬁc API allows
us to combine multiple backends for different algo-
rithms. For example, psa_cipher_cbc_aes_128_encrypt

ApplicationPSACryptoKeyManagementLocationDispatchSEDispatchAlgorithmDispatchDriverStartKeyIDAlgorithmPlaintextPSACipherEncryptGetKeySlotwithKeyIDSlotKeyPolicypermitsAlgorithm?ErrorNotPermittedFalseTrySETryAlgorithmDispatchLocationTrueDriverwithLocationexists?SESlotNoTrueFalseAlgImplement-ationexists?Locationislocalmemory?ErrorNotSupportedKeyDataProtectedSlotNo.FalseTrueTrueFalseSECipherEncryptTrans.CipherEncryptOpaq.CipherEncryptCiphertextEnd(CC310) peripheral accelerator and has been designed as a
general purpose platform. CryptoCell implements a large
set of cryptographic operations, which can be utilized via
a closed source library shipped by Nordic. We integrate this
library in RIOT and implement glue code, to map its API
to our algorithm speciﬁc API, to use it as one backend for
our API integration. This approach extends transparently to
other platforms.

We demonstrate the use of secure elements with PSA
Crypto by connecting two external crypto-chips (Microchip
ATECC608A) via I2C buses to the nrf52840dk. The ATE-
CCX08A device family is commonly used in the IoT and has
been widely evaluated [22, 28, 31, 36, 37]. The ATECC608A
offers tamper proof key storage in the shape of 16 individ-
ually conﬁgurable key slots as well as a set of operations to
perform on the keys. Microchip provides the open source
CryptoAuth library, which is included as a driver in PSA
Crypto using the RIOT package system. The vendor driver
API is abstracted by the PSA SE interface.

We further use the HMAC and cipher operations im-
plemented in RIOT as software backends. Even though
the nrf52840dk provides a true random number generator
(TRNG), we included the RIOT random module with a de-
terministic SHA-256 pseudo random number generator. This
ensures constant processing time values when measuring the
time overhead.

With all these components in place, our experimentation
system comprises a rich variety of peripheral crypto hard-
ware, multiple external secure elements, as well as MCU-
based crypto software to assess all features of our API inte-
gration.
5.2 Resource Metrics and Measurements
Processing Time. We measure processing time with a logic
analyzer sampling at 16 MS/s and calculate the mean value
over 1000 iterations. To minimize measurement overhead we
toggle I/O pins via direct register access on the nrf52840dk.
To evaluate the actual overhead of PSA Crypto, we measure
the complete processing time of API functions as well as the
internal driver calls. We derive the PSA overhead as the dif-
ference between the external and internal measurements. It
is important to note that the symmetric operations require
importing of a key prior to use. Without PSA Crypto this
would only be needed when using a secure element. We add
the key import to the PSA overhead, but display it separately
in Figures 5 and 6.
Memory Overhead. To evaluate memory usage we analyze
the compiled application ELF ﬁles and accumulate all linked
objects that are associated with a crypto-implementation or
are part of PSA Crypto operations. Hereby we ignore the
memory overhead of the operating system. We analyze the
sizes of individual crypto backends in ROM and RAM as
well as the memory added by the API implementation.
Measurement Applications. For measuring the overhead
of PSA Crypto, we build applications which perform a set
of symmetric and asymmetric cryptographic operations and
combine multiple backends.

The HMAC SHA256 application imports a 32 byte key
to PSA and computes a MAC of a 32 byte message. We

Figure 5: PSA Crypto API overhead compared to back-
end runtime for a secure element, a peripheral hardware
accelerator and a software implementation of AES-128
CBC and HMAC SHA256.

Figure 6: PSA Crypto API overhead compared to back-
end runtime for a secure element, a peripheral hardware
accelerator and a software implementation of an ECDSA
key generation, signature and veriﬁcation.

010203040Time[µs]RIOTSoftwareAESCBCHMACSHA256400200010203040Time[µs]CryptoCellAESCBCHMACSHA256400200010203040Time[µs]ATECC608AAESCBCHMACSHA2564000020000010203040Time[µs]MultipleATECC608AAESCBCHMACSHA25640000200000102030Time[µs]ATECC608AGenerateKeySignVerify100000500000102030Time[µs]MultipleATECC608AGenerateKeySignVerify100000500000102030Time[µs]CryptoCellGenerateKeySignVerify10000050000Figure 7: Memory overhead of PSA Crypto compared to various cryptographic backends in ROM and RAM.

measure the processing time of the key import and the mac
computation. As backends, we use the RIOT hash module
(software), the CryptoCell peripheral and the ATECC608A.
The AES 128 CBC cipher application imports a 16 byte
key and performs the encryption on a 32 byte plaintext. It
allocates one single key slot, which can contain a 16 byte
key. We measure the processing time of the key import and
the cipher encryption. The backends used are the RIOT ci-
pher module (software), the CryptoCell peripheral and the
ATECC608A.

The ECDSA application generates an ECC key pair using
a NIST P-256 elliptic curve and uses the private key to sign a
127 byte message. It then imports the public key to PSA and
uses it to perform a veriﬁcation of the signature generated
before. We measure the processing time of the key genera-
tion, the signature, the public key import and the veriﬁcation
procedure. The backends used are the CryptoCell peripheral
and the ATECC608A.
5.3 Cost Results
Processing Time.
Figure 5 shows the processing time
overhead of PSA Crypto in symmetric operations. On the
ATECC608A, our PSA implementation and the key import
function add an overhead of less than 40 µs, which falls four
orders of magnitude shorter than the actual operational pro-
cessing time.

When using the RIOT software implementation, the pro-
cessing time increases by ≈ 22 µs for both the HMAC and
AES operations, which is one order of magnitude less than
the basic operation.

ation remains constant. For the AES operation, the overhead
increases by almost 30 µs. This is due to the initialization
of the driver-speciﬁc operation context. The PSA speciﬁca-
tion requires that all contexts are initially set to zero. The
operation context used by the CryptoCell driver is approxi-
mately three times larger than the contexts used by the RIOT
software implementation and the ATECC608A driver, which
accounts for a longer initialization time.

for

The overhead added to the key import

the
ATECC608A is almost twice as large as for the other back-
ends. To perform an AES or HMAC operation using an im-
ported key on the ATECC608A, the key data needs import
into the device TempKey register, which temporarily stores
the data or intermediate values during computations. The im-
plementation of the device driver requires input to TempKey
of length either 32 or 64 bytes. To ensure this, PSA copies
the AES key and the HMAC key into a 32 byte buffer with
padding before sending them to the device. This accounts
for an increase in processing time.

When using two SEs for AES and HMAC operations, the
PSA overhead increases for the key import and the actual op-
erations, since the appropriate driver must be retrieved ﬁrst.
Figure 6 shows the processing time of the ECDSA key
generation, signing, and verifying. The overhead of the PSA
implementation and the key import remain nearly constant
for both backends. On the ATECC608A, the overhead for the
key generation and the public key import are ≈ 1 µs larger.
When using two SEs, the processing time increases by less
than 1 µs for all operations.

When using CryptoCell, the overhead of the HMAC oper-

When using CryptoCell, the PSA overhead of the key

202468ROM[KiB]0.200.20.40.60.8RAM[KiB]AESCryptoCellAESRIOTCipherHMACSHA-256ATECC608AHMACSHA-256CryptoCellECDSAATECC608AECDSACryptoCellCombinedBackends4824AESCryptoCellAESRIOTCipherHMACSHA-256ATECC608AHMACSHA-256CryptoCellECDSAATECC608AECDSACryptoCellCombinedBackends6PSACryptoAPISecureElementManagementKeySlotManagementLocation/AlgorithmDispatcherGlueCodeBackendFigure 8: Example of a secure ﬁrmware conﬁguration in
RIOT when using multiple packages and modules, each
of which come with their own crypto implementations.

Figure 9: Reduction of code redundancy by conﬁguring
packages and modules to use the same crypto implemen-
tations through an OS level interface.

generation, signature, and veriﬁcation increases, which is
due to our implementation of the algorithm dispatcher. To
dispatch calls to algorithm speciﬁc interfaces, the key type,
key size and algorithm need to be mapped to the appropriate
APIs, which takes ≈ 2 µs.
Memory Size. Figure 7 shows the memory consumption
of PSA Crypto compared to the ROM and RAM used by
drivers in the backend, omitting the memory usage of the
operating system. We built all our applications either with
the CryptoCell Library, the ATECC608A driver, or the RIOT
cipher module. The rightmost bars show the memory sizes
for a combination of all three backends.

The ROM used by the crypto module depends on the
backend, the amount of functions required for the opera-
tions, and the amount of glue code required to map the ven-
dor driver APIs to the PSA APIs. For example, when build-
ing an application for AES encryption, the PSA Crypto API,
the key slot management and the dispatcher require the same
amount of memory for the CryptoCell backend as well as
the RIOT software implementation. By comparison, the use
of the ATECC608A almost doubles the amount of glue code
and adds code for the secure element management. Overall
our PSA implementation does not exceed a size of ≈ 30%
of the crypto backend, while adding helpful features like the
internal key management.

When combining all three backends, our implementation
only requires less than 8 KB of ROM compared to over 49
KB required by the backends alone. This overhead is accept-
able, comparing the provided functionality and the beneﬁt of
unifying multiple drivers and libraries with specialized ven-
dor APIs below a consistent user interface.

In RAM, the amount of allocated memory mostly depends
on the size and amount of keys used. Operations that use
small key sizes (AES and HMAC) require much less mem-
ory than asymmetric keys. Due to our ﬂexible key manage-
ment and our individually conﬁgurable key slot sizes, we can
allocate appropriate RAM efﬁciently at compile time.

cated to store SE driver instances and pointers to all available
driver functions. The application that includes a combination
of all backends uses two SEs and therefore needs to store two
driver instances. This is reﬂected by the increase of memory
consumed by the secure element management.

In summary, our cost evaluation revealed only negligible
runtime overhead of our PSA Crypto integration. Memory
overheads remain noticeable, but should be outweighed by
(i) additional functionality such as key slot management and
(ii) code consolidation, the latter we assess in the following
section.
5.4 Code Deduplication

A secure ﬁrmware conﬁguration in RIOT consists of mul-
tiple protocol implementations, which in many cases are pro-
vided by third party libraries. Figure 8 shows an exam-
ple protocol stack built from various packages and modules,
some of which bring their own implementations of crypto-
graphic primitives. At the transport and application layer
the library tinyDTLS [16] provides an implementation for
Datagram Transport Layer Security (DTLS) and brings its
own AES and ECDSA modules. LibCOSE [24] implements
the CBOR Object Signing and Encryption (COSE) stan-
dard optimized for constrained devices and can use different
crypto backends for AES and ECDSA operations, (e.g., tiny-
Crypt [15, 21]). EDHOC-C [34] provides a lightweight
Difﬁe-Hellman key exchange over COSE and supports dif-
ferent crypto backends. In this example the package is built
with wolfSSL, utilizing the AES, ECDSA and SHA-256 im-
plementations.

At the MAC layer the IEEE 802.15.4 security module is
able to use hardware acceleration for some radio modules.
When using radios without access to hardware crypto, it falls
back to the RIOT cipher software implementation, which is
also used by the GNRC LoRaWAN implementation.

None of those modules and packages provides key man-
agement and storage functions, the implementation of which
are pushed to application developers.

When using secure elements, additional RAM is allo-

As apparent from Figure 8, deploying all the modules to-

tinyDTLS(DTLS)EDHOC-C(EDHOC)libCOSE(COSE)SUITlibOSCORE(OSCORE)Transport/Appl.SecuritySHA256AESECDSAAESECDSASHA256AESECDSAIEEE802.15.4SecurityGNRCLoRaWANAESAESMACLayerSecurityHardwareImpl.tinyDTLSImpl.RIOTImpl.tinyCryptImpl.wolfCryptImpl.c25519Impl.tinyDTLS(DTLS)EDHOC-C(EDHOC)libCOSE(COSE)SUITlibOSCORE(OSCORE)PSACryptoIEEE802.15.4SecurityGNRCLoRaWANPSACryptoAESSHA256ECDSATransport/Appl.SecurityMACLayerSecurityBackend

tinyDTLS
EDHOC-C
libCOSE
IEEE 802.15.4
Security
GNRC

Sum

Modules

ROM Usage [kB]

RIOT SHA-256, own ECDSA
wolfCrypt (AES, ECDSA, SHA-256)
tinyCrypt AES, c25519 ECDSA

AES Hardware Accelerator

RIOT Cipher AES

Deduplicated Backends

PSA Crypto

Sum

AES HW Accelerator,
wolfCrypt ECDSA, RIOT SHA-256
integrated

14
22
8

1

5

50

7

8

15

Table 1: Combined ROM usage of all crypto modules of
our sample conﬁguration (cf. Figure 8) compared with
the PSA Crypto integration.

gether results in ﬁve different AES implementations, two
hash implementations, and three ECDSA implementations,
with a combined ∼ 50 kB of ROM usage (see Table 1). Ad-
ditional mechanisms for key management are also needed.
Multiple implementations require higher maintenance effort
and may be prone to errors. In the IoT, memory is a con-
strained resource, making the reduction of code redundancy
a primary goal.

Figure 9 shows how the different crypto backends can be
consolidated by providing a consistent OS level crypto in-
terface that only uses one backend per algorithm. Thanks
to the internal key storage, additional key management be-
comes obsolete. By modifying the packages and modules
to use PSA Crypto instead of their own crypto implementa-
tions or additional libraries, code duplication can be largely
avoided. We can reduce the ∼ 50 kB of ROM usage to
∼ 7 kB by employing only the hardware accelerator, the
RIOT Hash implementation and the wolfCrypt ECDSA im-
plementation. As already shown, PSA adds less than 8 kB of
ROM when combining multiple backends, while providing
additional features like key management. In this ﬁrmware
example we demonstrate that using PSA Crypto with only
one backend per operation can reduce ROM usage by 70%.
5.5 Usability

We ﬁnally want to discuss how the integration of PSA
Crypto in RIOT decreases code complexity and thereby en-
hances usability for security. Figure 10 displays a code ex-
ample which is required to perform an AES-128 CBC oper-
ation on a previously generated key, when using the driver
of the CryptoCell hardware accelerator directly. First, the
developer needs to take care of key storage and to provide
access to the key material (line 1). CryptoCell does not de-
termine, whether this particular key is permitted for this op-
eration, so the user has to keep track of the permissions. She
needs to know that a randomly generated initialization vector
(IV) is required for this operation along with its required size.
She must generate the IV using some random number gener-
ator (RNG), such as the RIOT random module (line 22) [23].
Now she needs to initialize an operation context (line 23),
set the key (line 28), and set the previously generated IV
(line 33). She can then perform the cipher operation on the
plaintext. To do this, she must keep track of how many bytes
the AES block function (line 35 - 50) can compute, in case

0x00 , 0x01 , 0x02 , 0x03 ,
0x04 , 0x05 , 0x06 , 0x07 ,
0x08 , 0x09 , 0x0A , 0x0B ,
0x0C , 0x0D , 0x0E , 0 x0F };

& ctx ,
S A S I _ A E S _ E N C R Y P T ,
S A S I _ A E S _ M O D E _ C B C ,
S A S I _ A E S _ P A D D I N G _ N O N E );

1 e x t e r n u i n t 8 _ t * key ;
2 e x t e r n s i z e _ t key_size ;
3
4 i n t status ;
5 u i n t 8 _ t plaintext [] = {
6
7
8
9
10 u i n t 8 _ t iv [16];
11 u i n t 8 _ t output [32];
12 s i z e _ t output_length ;
13 s i z e _ t size ;
14 s i z e _ t offset = 0;
15 s i z e _ t length = s i z e o f ( plaintext );
16
17 S a S i A e s U s e r C o n t e x t _ t ctx ;
18 S a S i A e s U s e r K e y D a t a _ t user_key ;
19 user_key . pKey = key ;
20 user_key . keySize = key_size ;
21
22 r a n d o m _ b y t e s (iv , s i z e o f ( iv ));
23 status = S a S i _ A e s I n i t (
24
25
26
27
28 status = S a S i _ A e s S e t K e y (
29
30
31
32
33 status = S a S i _ A e s S e t I v ( & ctx , iv );
34
35 do {
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50 } w h i l e (( length > 0));
51
52 status = S a S i _ A e s F i n i s h (
53
54
55
56
57

& ctx , length ,
plaintext ,
s i z e o f ( plaintext ),
output ,
& output_length );

if ( length > MAX_AES_BLOCK ) {
size = MAX_AES_BLOCK ;
length -= MAX_AES_BLOCK ;

& ctx ,
S A S I _ A E S _ U S E R _ K E Y ,
& user_key ,
s i z e o f ( user_key ));

}
status = S a S i _ A e s B l o c k (

size = length ;
length = 0;

offset += size ;

}
e l s e {

& ctx ,
( plaintext + offset ),
size ,
( output + offset ));

Figure 10: Example for an AES-128 CBC operation us-
ing the CryptoCell driver directly. The key is stored ex-
ternally in RAM.

P S A _ A L G _ C B C _ N O _ P A D D I N G ;

0x00 , 0x01 , 0x02 , 0x03 ,
0x04 , 0x05 , 0x06 , 0x07 ,
0x08 , 0x09 , 0x0A , 0x0B ,
0x0C , 0x0D , 0x0E , 0 x0F };

1 e x t e r n p s a _ k e y _ i d _ t id ;
2
3 p s a _ s t a t u s _ t status ;
4 p s a _ a l g o r i t h m _ t algorithm =
5
6
7 u i n t 8 _ t plaintext [] = {
8
9
10
11
12
13 s i z e _ t output_size =
14
15
16
17
18 u i n t 8 _ t cipher_out [ output_size ];
19 s i z e _ t output_len ;
20
21 status = p s a _ c i p h e r _ e n c r y p t (
22
23
24
25
26
27

id , algorithm ,
plaintext ,
s i z e o f ( plaintext ),
cipher_out ,
output_size ,
& output_len );

P S A _ K E Y _ T Y P E _ A E S ,
P S A _ A L G _ C B C _ N O _ P A D D I N G ,
s i z e o f ( plaintext ))

P S A _ C I P H E R _ E N C R Y P T _ O U T P U T _ S I Z E (

Figure 11: Example for an AES-128 CBC operation us-
ing PSA. The key has been previously imported and can
be accessed by an ID.

she needs to perform the operation more than once. Finally,
she can ﬁnalize the operation (line 52) to obtain the cipher
text.

When performing a cipher operation using PSA Crypto
with the CryptoCell backend (Figure 11), the driver speciﬁc
functionality is hidden from the developer. Also, critical re-
quirements like storing the key and checking its permissions,
as well as generating and setting an IV are handled internally.
The extensive documentation describes the correct ﬂows for
operations and guides developers in writing their applica-
tions. This way misuse and errors can be prevented.

The user needs to provide the desired algorithm and the
identiﬁer of a previously generated or imported key (lines
1 and 4). The key is stored within the PSA implementa-
tion along with its type, size and usage policy, which deter-
mines the algorithms of its use. If there is no permission to
use this key in a symmetric encryption in CBC mode with-
out padding, an error will be returned. A macro deﬁned by
the PSA speciﬁcation can be used to determine the correct
size of the output buffer (line 13), reducing errors on the
developer side. The user can then perform the encryption
(line 21), which internally retrieves the key material, checks
the usage policy and generates a randomized IV with a pre-
viously conﬁgured RNG. Due to our conﬁguration system,
suited implementations are chosen for the RNG, e.g., hard-

ware implementations, if available. When building the appli-
cation, the user must specify, what algorithms should be sup-
ported by the build, resulting in a binary that only includes
the needed functionality and nothing more.

When the user wants to switch to another backend, she
does not have to familiarize herself with another vendor API
or change her code. She can simply rebuild the application
with a different conﬁguration.
6 Conclusion and Outlook

Security must be usable for embedded application pro-
grammers to ensure common standards throughout the IoT.
For heterogeneous and constrained embedded systems, secu-
rity can be enhanced by hardware accelerated cryptography,
optimized libraries, and secure key storage. An IoT operat-
ing system should support the use of all available implemen-
tations while increasing usability for developers. This is of
particular importance for increasingly popular solutions on
the application layer such as content object security [19].

In this work, we motivated the use of PSA Crypto as a
system level API, because it established as a versatile and
easy-to-use interface for the IoT. We integrated PSA Crypto
to enhance the cryptographic services of RIOT with features
that have been previously missing at the OS level, and to
add an identiﬁer based key management, which allows for
the integration of cryptographic backends with and without
protected key storage. We demonstrated that our architecture
and implementation of PSA Crypto provides transparent ac-
cess to hardware and software backends with low overhead
in processing time and memory. Furthermore, we showed
that the new API simpliﬁes the use of cryptographic opera-
tions for the user. Targeting a typical RIOT ﬁrmware conﬁg-
uration, we identiﬁed that the use of PSA Crypto can reduce
ROM overhead by 70%.

Our current

implementation supports key storage in
volatile memory, only. In future work, we will extend it with
secure key storage in persistent memory. Additionally, we
plan on integrating trusted execution environments (TEE) in
RIOT as possible backends for PSA Crypto. This will en-
able an easy support for hardware-based memory isolation
and code execution in protected environments. It will further
enhance the security features of RIOT OS.

For reproducibility our code is available on https://
github.com/inetrg/EWSN-PSA-CRYPTO-22. The imple-
mentation will be gradually integrated into RIOT.
Acknowledgements

We would like to thank our anonymous reviewers for their
valuable feedback. Also we thank the developers at ARM
and mbedTLS, who kindly answered our questions about the
API design and their reference implementation. This work
was partly supported by the German Federal Ministry of Ed-
ucation and Research BMBF within the project PIVOT.

7 References
[1] Y. Acar, M. Backes, S. Fahl, S. Garﬁnkel, D. Kim, M. L. Mazurek,
and C. Stransky. Comparing the Usability of Cryptographic APIs. In
Proc. of the IEEE Symposium on Security and Privacy (SP ’17), pages
154–171, Los Alamitos, CA, USA, 2017. IEEE Computer Society.
[2] Amazon Web Services. FreeRTOS Real-time operating system for
microcontrollers. https://www.freertos.org/, last accessed 30-
11-2020, 2020.

[3] M. Antonakakis et al.. Understanding the Mirai Botnet.

In 26th
USENIX Security Symposium (USENIX Security 17), pages 1093–
1110, Vancouver, BC, Aug. 2017. USENIX Association.

[4] Apache Software Foundation. Apache Mynewt. https://mynewt.

apache.org, last accessed 07-17-2020, 2020.

[5] ARM Ltd. Mbed OS. https://www.mbed.com, last accessed 07-17-

2020, 2020.

[6] ARM Ltd. Mbed TLS. https://tls.mbed.org, last accessed 07-

17-2020, 2020.

[7] ARM Ltd.

PSA Cryptography API 1.0.

https://armmbed.
github.io/mbed-crypto/html/index.html, last accessed 09-28-
2021, 2020.

[8] ARM Ltd.

ARM Platform

Architec-
https://developer.arm.com/architectures/

Security

ture.
architecture-security-features/platform-security,
last accessed 09-28-2021, 2021.

[9] ARM Ltd. ARM PSA Certiﬁed. https://www.psacertified.org,

last accessed 09-28-2021, 2021.

[10] ARM Ltd.

https://
ARM Trusted Firmware A.
trustedfirmware-a.readthedocs.io/en/latest/, last accessed
10-07-2021, 2021.

[11] ARM Ltd.

tf-m-user-guide.trustedfirmware.org,
28-2021, 2021.

ARM Trusted Firmware M.
last

https://
09-

accessed

[12] ARM Ltd.

PSA Functional APIs Architecture Test Suite.

https://github.com/ARM-software/psa-arch-tests/tree/
master/api-tests/dev_apis, last accessed 10-07-2021, 2021.
[13] E. Baccelli, C. Gündogan, O. Hahm, P. Kietzmann, M. Lenders, H. Pe-
tersen, K. Schleiser, T. C. Schmidt, and M. Wählisch. RIOT: an Open
Source Operating System for Low-end Embedded Devices in the IoT.
IEEE Internet of Things Journal, 5(6):4428–4440, December 2018.

[14] J. Clulow. On the Security of PKCS #11. In Cryptographic Hardware
and Embedded Systems (CHES ’03), pages 411–425, Berlin, Heidel-
berg, 2003. Springer-Verlag.

[15] Daniel Beer. Curve25519 and Ed25519 for low-memory systems.
https://www.dlbeer.co.nz/oss/c25519.html, last accessed 07-
28-2022, 2014.

[16] Eclipse Foundation. Eclipse tinyDTLS.

https://github.com/

eclipse/tinydtls, last accessed 05-10-2022, 2017.

[17] A. H. Gerez, K. Kamaraj, R. Nofal, Y. Liu, and B. Dezfouli. En-
ergy and Processing Demand Analysis of TLS Protocol in Internet of
Things Applications. In International Workshop on Signal Processing
Systems (SiPS ’18), pages 312–317, NJ, USA, 2018. IEEE.

[18] M. Green and M. Smith. Developers are Not the Enemy!: The Need
for Usable Security APIs. IEEE Security and Privacy, 14(5):40–46,
2016.

[19] C. Gündogan, C. Amsüss, T. C. Schmidt, and M. Wählisch. Con-
tent Object Security in the Internet of Things: Challenges, Prospects,
and Emerging Solutions. IEEE Transactions on Network and Service
Management (TNSM), 19(1):538–553, March 2022.

[20] R. Hiesgen, M. Nawrocki, A. King, A. Dainotti, T. C. Schmidt, and
M. Wählisch. Spoki: Unveiling a New Wave of Scanners through a
Reactive Network Telescope. In Proc. of 31st USENIX Security Sym-
posium, Berkeley, CA, USA, August 2022. USENIX Association.

[21] Intel Corporation. TinyCrypt Cryptographic Library.

https://

github.com/intel/tinycrypt, last accessed 07-17-2020, 2017.
[22] P. Kietzmann, L. Boeckmann, L. Lanzieri, T. C. Schmidt, and
M. Wählisch. A Performance Study of Crypto-Hardware in the Low-
end IoT. In International Conference on Embedded Wireless Systems

and Networks (EWSN’21), New York, USA, February 2021. ACM.

[23] P. Kietzmann, T. C. Schmidt, and M. Wählisch. A Guideline on Pseu-
dorandom Number Generation (PRNG) in the IoT. ACM Comput.
Surv., 54(6):112:1–112:38, July 2021.

[24] Koen Bergzand.

libCOSE.

https://github.com/bergzand/

libcose, last accessed 05-10-2022, 2018.

[25] D. Kumar et al.. All Things Considered: An Analysis of IoT Devices
on Home Networks. In 28th USENIX Security Symposium (USENIX
Security 19), pages 1169–1185, Santa Clara, CA, Aug. 2019. USENIX
Association.

[26] C. Lachner and S. Dustdar. A Performance Evaluation of Data Pro-
In In-
tection Mechanisms for Resource Constrained IoT Devices.
ternational Conference on Fog Computing (ICFC ’19), pages 47–52,
Piscataway, NJ, USA, 2019. IEEE.

[27] J. Linn. Generic Security Service Application Program Interface Ver-

sion 2, Update 1. RFC 2743, IETF, January 2000.

[28] J. Mades, G. Ebelt, B. Janjic, F. Lauer, C. C. Rheinländer, and
N. Wehn. TLS-Level Security for Low Power Industrial IoT Network
Infrastructures. In Design, Automation Test in Europe Conference Ex-
hibition (DATE ’20), pages 1720–1721, NJ, USA, 2020. IEEE.
[29] K. Mindermann, P. Keck, and S. Wagner. How Usable Are Rust Cryp-
tography APIs? In International Conference on Software Quality, Re-
liability and Security (QRS ’18), pages 143–.154, Los Alamitos, CA,
USA, 2018. IEEE Computer Society.

[30] P. S. Munoz, N. Tran, B. Craig, B. Dezfouli, and Y. Liu. Analyzing
the Resource Utilization of AES Encryption on IoT Devices. In Asia-
Paciﬁc Signal and Information Processing Association Annual Summit
and Conference (APSIPA ASC’18), pages 1200–1207, 2018. IEEE.

[31] M. Noseda, L. Zimmerli, T. Schläpfer, and A. Rüst. Performance

Analysis of Secure Elements for IoT. IoT, 3(1):1–28, 2022.

[32] OASIS Open.

Guide Version 2.40.
pkcs11-ug/v2.40/cn02/pkcs11-ug-v2.40-cn02.html,
cessed 10-06-2021, 2014.

PKCS #11 Cryptographic Token Interface Usage
https://docs.oasis-open.org/pkcs11/
last ac-

[33] OASIS Open.

PKCS #11 Cryptographic Token Interface Base
https://docs.oasis-open.org/

Speciﬁcation Version 3.0.
pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html,
last accessed 10-06-2021, 2020.

[34] OpenWSN.

EDHOC-C.

https://github.com/

openwsn-berkeley/EDHOC-C, last accessed 05-10-2022, 2020.
[35] N. Patnaik, J. Hallett, and A. Rashid. Usability Smells: An Analysis
of Developers’ Struggle With Crypto Libraries. In Fifteenth Sympo-
sium on Usable Privacy and Security (SOUPS 2019), pages 245–257,
Washington, D.C., Aug. 2019. USENIX Association.

[36] B. Pearson, L. Luo, Y. Zhang, R. Dey, Z. Ling, M. Bassiouni, and
X. Fu. On Misconception of Hardware and Cost in IoT Security and
Privacy. In 53rd International Conference on Communications (ICC
’19), pages 1–7, Piscataway, NJ, USA, 2019. IEEE.

[37] T. Schläpfer and A. Rüst. Security on IoT Devices with Secure Ele-

ments. Technical report, WEKA, 2019.

[38] The Linux Kernel Development Community.

Kconﬁg Lan-
https://www.kernel.org/doc/html/latest/kbuild/

guage.
kconfig-language.html, last accessed 28-09-2020, 2020.

[39] M. Ukrop and V. Matyas. Why Johnny the Developer Can’t Work
with Public Key Certiﬁcates: An Experimental Study of OpenSSL
Usability. In Topics in Cryptology – CT-RSA 2018: The Cryptogra-
phers’ Track at the RSA Conference 2018, pages 45–64, Cham, 2018.
Springer International Publishing.

[40] A. Whitten and J. D. Tygar. Why Johnny Can’t Encrypt: A Usability
Evaluation of PGP 5.0. In 8th USENIX Security Symposium (USENIX
Security 99), Washington, D.C., Aug. 1999. USENIX Association.

[41] wolfSSL Inc. wolfSSL Embedded TLS Library. https://www.

wolfssl.com/, last accessed 10-20-2021, 2021.

[42] J. Wray. Generic Security Service API Version 2 : C-bindings. RFC

2744, IETF, January 2000.

[43] Zephyr Project. Zephyr. https://www.zephyrproject.org, last

accessed 07-17-2020, 2020.

