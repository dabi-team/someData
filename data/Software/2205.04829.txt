Software tool-set for automated quantum system
identiﬁcation and device bring up

Anurag Saha Roy1, 2, 3, Kevin Pack1, 2, Nicolas Wittler1, 2, and Shai Machnes1, 3

1Peter Gr¨unberg Institute – Quantum Computing Analytics (PGI 12), Forschungszentrum J¨ulich, D-52425 J¨ulich, Germany
2Theoretical Physics, Saarland University, 66123 Saarbr¨ucken, Germany
3Qruise GmbH, 66113, Saarbr¨ucken, Germany

2
2
0
2

y
a
M
0
1

]
h
p
-
t
n
a
u
q
[

1
v
9
2
8
4
0
.
5
0
2
2
:
v
i
X
r
a

Abstract—We present a software tool-set which combines the
theoretical, optimal control view of quantum devices with the
practical operation and characterization tasks required for quan-
tum computing. In the same framework, we perform model-based
simulations to create control schemes, calibrate these controls in
a closed-loop with the device (or in this demo - by emulating
the experimental process) and ﬁnally improve the system model
through minimization of the mismatch between simulation and
experiment, resulting in a digital twin of the device. The model
based simulator is implemented using TensorFlow, for numeric
efﬁciency, scalability and to make use of automatic differenti-
ation, which enables gradient-based optimization for arbitrary
models and control schemes. Optimizations are carried out with
a collection of state-of-the-art algorithms originated in the ﬁeld
of machine learning. All of this comes with a user-friendly Qiskit
interface, which allows end-users to easily simulate their quantum
circuits on a high-ﬁdelity differentiable physics simulator.

Index Terms—Quantum Optimal Control, Machine Learning,
Quantum Computing, Superconducting Qubits, Benchmarking,
Calibration, System Identiﬁcation

I. INTRODUCTION

Development of quantum technology devices, in particular
quantum computers is an enormously difﬁcult task. Focusing
for the moment on quantum computation, one can estimate
NISQ (Near-term Intermediate-Scale Quantum Computers,
[1]) devices become generally useful as we approach 100
qubits (for comparison, in 2022 classical compute clusters
exist with an exabyte of storage, which is roughly on the
scale of 60 qubits). But to be able to use this number of
qubits in a meaningful way, a quantum circuit must also have
sufﬁcient depth, i.e. the coherence properties and gate ﬁdelities
allow for the execution of numerous gates. And while quantum
advantage is possible in some speciﬁc cases for depth O (1)
circuits [2], many quantum algorithms, such as Shor’s require
depth O (n) [3], and general BQP (Bounded-error Quantum
Polynomial time) require depth O (poly (n)) [4]. Therefore,
as a rough estimate, an entangling gate error of 10−4 is
an important step towards useful quantum computers, and
progress towards that goal has been slow.

Whether aiming at error-corrected quantum computation or
applications on NISQ devices, we posit one must signiﬁcantly
improve the methods by which we characterize quantum de-
vices, and how we optimize and calibration quantum controls.
One common approach, known as ad-hoc [5], consists of
deriving controls in simulation and subsequent ﬁne-tuning in

experiment. This scenario leaves a lot to be desired: The
need for calibration proves the model we have of the system
is inaccurate, and the ﬁnal calibrated pulses may perform
well, but we do not know why, as we have no model which
explains the changes in controls which have occurred during
calibration. To make matters worse, we have not
learned
anything about the system in the process, and we are not in a
better position to improve system design in the next hardware
iteration.

To resolve this unsatisfactory situation, the authors have
developed a novel methodology, C3 – Control, Calibration and
Characterization [6], which tightly integrates the calibration
and characterization processes, to achieve better modeling of
the system and hence better optimal control. This manuscript
details the open-source (Apache 2.0) software implementation
of this new methodology.

And while there are several open-source software packages
which perform either model-based optimal control, control
calibration or limited system characterization [7], [8], [9], [10],
[11], to our knowledge C3 is the ﬁrst which combines all three
in an integrated fashion. Therefore, providing better insights
into the sources of limitations in ﬁdelities, and hence hints as
to what should be addressed in the next hardware iteration.

The manuscript is organized as follows: We present the
optimal control task of realizing a quantum computing gate-
set on a single qubit in Section II. To demonstrate the full C3
procedure, we will consider two similar models, the simulation
model,
to which we have full descriptive access, and the
blackbox model, which stands-in for a real experiment and thus
only provides limited access by measurement. We also discuss
the implementation of the underlying quantum simulation. In
Section III we simulate the procedure of calibrating the gate-
set by taking measurements on the blackbox. On the basis of
the data taken during calibration, we perform model learning
in Section IV, by simulating the calibration experiments on
the simulation model to bring the two to agreement. Finally,
we discuss the Qiskit [12] interface in Section V and give an
overview of the software architecture in Section VI.

As a companion piece, an example Jupyter notebook that
contains the code and reproduces the plots in this manuscript
is accessible through this link - bit.ly/c3-full-example. This is
released as part of the source code on Github at q-optimize/c3.

 
 
 
 
 
 
II. OPTIMAL CONTROL

When employing optimal control techniques in the practical
operation of quantum devices, it is desirable to have access to a
model of the device for analysis and the derivation of advanced
control schemes. From a numerical perspective, optimal solu-
tions can be difﬁcult to obtain due to a feature rich control
landscape. It has been established to derive complex control
schemes on model descriptions in simulation before turning to
the real experiment for ﬁne-tuning [5]. Numerical algorithms
that make use of the gradient of the goal function, e.g. L-BFGS
[13], can speed up such optimizations signiﬁcantly compared
to gradient-free algorithms [14]. Access to gradients of a quan-
tum dynamics simulation is not trivial and thus procedures
such as Krotov [15], GRAPE [16] and GOAT [14] require a
speciﬁc formulation of the control problem in goal function
and system descriptions. In the approach presented here, we
make use of the numerics package Tensorﬂow, developed for
machine learning applications, to provide both high compute
performance and the access to automatic differentiation which
lifts most limitations in formulating the problem.

A. The problem statement

For demonstration purposes, we will concern ourselves in
this paper with the realization of a gate-set of π/2 rotations
around the x and y axis of the Bloch sphere of a single qubit.
[better words] This system is described by the Hamiltonian

H(t)/¯h = ωb†b −

δ
2

(cid:0)b†b − 1(cid:1)b†b + c(t)(cid:0)b + b†(cid:1) ,

(1)

where b and b† are the bosonic ladder operators, ω and δ
the qubit frequency and anharmonicity and c(t) the time-
dependent control ﬁeld.

The following snipped creates the qubit as an object in the

C3 package.

q1 = Qubit(

name="Q1",
desc="Qubit 1",
freq=Quantity(
value=freq,
min_val=4.995e9,
max_val=5.005e9,
unit="Hz 2pi",

),
anhar=Quantity(
value=anhar,
min_val=-380e6,
max_val=-120e6,
unit="Hz 2pi",

),

)

Properties that will be optimized are instantiated from the
Quantity class, which handles physical units and limits.
Similarly, the drive is created by

drive = Drive(
name="d1",
desc="Drive 1",
comment="Drive line 1 on qubit 1",
connected=["Q1"],
hamiltonian_func=hamiltonians.x_drive,

)

where the connected parameter indicates this drive acts
on the qubit created above. When the model
is created
with model = Model([q1], [drive]), the matrix rep-
resentation of the operators in (1) are created and stored for
later use. In this example, the matrices for b†b = n |n(cid:105)(cid:104)n| and
(b†b − 1)b†b = (n − 1)n |n(cid:105)(cid:104)n|, where |n(cid:105) is the Fock basis,
are stored. When evaluating H(t) these are multiplied with the
parameters of the qubit, freq and anhar. A recomputation
of the matrices would only be required when performing frame
transformations, e.g. going to the interaction picture.

The operation U on the qubit, affected by the control ﬁeld
is obtained by the formal solution of the Schr¨odinger equation

(cid:32)

U (T ) = exp

−

(cid:33)

H(t)dt

.

i
¯h

(cid:90) T

0

(2)

The default implementation of the solution is to precompute
the time-dependent Hamiltonian as a three-dimensional tensor
of shape [t_N, n, n] where t_N is the number of time-
slices that are to be simulated and n is the Hilbert space
dimension. This way, the time dimension can be used to batch
compute the exponentials with the Tensorﬂow matrix exponen-
tial tf.linalg.expm(-1.0j * h * dt). The result is
again a 3D tensor containing the inﬁnitesimal propagators dU .
By multiplying these in a binary tree, we effectively obtain
the ﬁnal unitary U = (cid:81)0
dUj. Since this approach is
only strictly correct if the Hamiltonian commutes with itself at
different times, the time-slices have to be chosen ﬁne enough
such that the introduced error O([dUj−1, dUj]) is below a
desired threshold.

j=tN

The control task now consists of ﬁnding the control ﬁelds

c(t) which implement the gate-set

G = (cid:8)Xπ/2, Yπ/2, X−π/2, Y−π/2

(cid:9) ,

(3)

of rotations of the qubit spin around the axis of the Bloch
sphere. To determine the ﬁdelity of a single operation, we use
the overlap

F[U (t)] =

(cid:12)
(cid:12)
(cid:12)
(cid:12)

1
dim U

Tr(cid:8)U †(t)Uideal

(cid:9)

2

(cid:12)
(cid:12)
(cid:12)
(cid:12)

which we average over all operations of the gate-set
compute the goal function value.

(4)

to

B. Signal generation

The control ﬁeld c(t), as seen by the qubit and written in
the Hamiltonian, is typically different from the programmed
ﬁeld in signal generators of an experimental setting. The
mathematical background is described in [6]. The process is
implemented as a generator using a number of devices to
realize the signal chain.

generator = Generator(

devices={

"LO": ...,
"AWG":...,
"DigitalToAnalog" ...,
"Mixer": ...,
"VoltsToHertz": ...,

},
chains={

ε(t)

{pi}

AWG sampling

u(t)

readout

transfer

function

time evolution

c(t)

|ψ(t)(cid:105) = U (t) |ψ(0)(cid:105)

Fig. 1. Figure and caption adapted from [6]: The process of simulating exper-
imental procedure for signal processing and readout. The control function is
speciﬁed by some function ε and speciﬁes the line voltage u(t) by an arbitrary
waveform generator (AWG) with limited bandwidth. Electrical properties of
the setup, such as impedances, are expressed as a line transfer function ϕ,
resulting in a control ﬁeld c(t) = ϕ[u(t)], as in Eq. (1).

"d1": {

"LO": [],
"AWG": [],
"DigitalToAnalog": ["AWG"],
"Mixer": ["LO", "DigitalToAnalog"],
"VoltsToHertz": ["Mixer"],}},)

In the generator, a number of devices arranged into signal
chains by specifying their inputs. This is processed into a
directed, acyclic graph that can be executed to compute a
realistic control signal by generating a low-resolution envelope
on an AWG that is then interpolated to simulation resolution
and mixed with a cosine signal from a rf-source. Finally, these
voltage signals are converted to energy (or frequency) scale to
be put into the Hamiltonian.

essential function is to provide a linear vector of parameters to
interface with an optimization algorithm that also rescales all
parameters to values in [−1, 1], which most algorithms handle
well.

the amplitude of the pulse,

In the example, we parametrize the control function with
three parameters,
the DRAG
parameter delta, the frequency offset which modulates
the resonance and framechange, a phase which allows ﬁne-
tuning of the rotation. For the calibration of the gateset, we
demand that all four gates share the same three parameters and
only differ in their phase which determines the rotation axis
and orientation. The following opt_map implements this,
indicating that there are 16 parameters where four share the
numerical value.
gateset_opt_map =

[

("rx90p[0]", "d1", "gauss", "amp"),
("ry90p[0]", "d1", "gauss", "amp"),
("rx90m[0]", "d1", "gauss", "amp"),
("ry90m[0]", "d1", "gauss", "amp")

("rx90p[0]", "d1", "gauss", "delta"),
("ry90p[0]", "d1", "gauss", "delta"),
("rx90m[0]", "d1", "gauss", "delta"),
("ry90m[0]", "d1", "gauss", "delta")

("rx90p[0]", "d1", "gauss", "freq_offset"),
("ry90p[0]", "d1", "gauss", "freq_offset"),
("rx90m[0]", "d1", "gauss", "freq_offset"),
("ry90m[0]", "d1", "gauss", "freq_offset")

("rx90p[0]", "d1", "gauss", "framechange"),
("ry90p[0]", "d1", "gauss", "framechange"),
("rx90m[0]", "d1", "gauss", "framechange"),
("ry90m[0]", "d1", "gauss", "framechange")

[

],
[

],
[

],
[

],

]

C. Simulating quantum dynamics

parameter_map.set_opt_map(gateset_opt_map)

The simulation of quantum dynamics is at the core of both
the optimal control and model learning applications. In an ex-
perimental context, such as the calibration step, quantum gates
are used in sequences rather than individually. To efﬁciently
simulate a sequence of gates in the gate-set in a Markovian
context, it makes sense to compute the Unitary representations
of the gate-set only once and multiply them as needed to create
the sequence. During this, some subtleties present themselves.
When not simulating in the interaction frame, the qubit rotates
around its z-axis with its eigenfrequency, such that what
constitutes a rotation around the desired x or y axis looks
different in the lab frame, depending on the time at which the
operation occurs. In experimental practice, this is known as
the virtual Z [17] phenomenon and is used to convert between
x and y rotations by applying a phase to the control signal.
We employ a similar technique by multiplying the unitary
representations of each gate by exp(cid:0)ωdT b†b(cid:1) which realigns
the x, y axis of the qubit and the drive ﬁeld.

D. Optimization

To manipulate

the
ParameterMap that contains methods to collect optimizable
parameters from both model and control components. The

control parameters, we use

the

The optimization is then carried out by the module

opt = OptimalControl(
dir_path=log_dir,
fid_func=unitary_infid_set,
fid_subspace=["Q1"],
pmap=parameter_map,
algorithm=lbfgs,
options={"maxfun" : 150},
run_name="better_X90"

)

by specifying a ﬁdelity function, including the subspace in the
case of larger Hilbert space. Both the ﬁdelity and the algorithm
can be chosen from a library included in the package or from
a custom user implementation with the same signature.

III. CALIBRATION
Having created an initial starting pulse through the usage
of the tools in the optimization phase, we now continue with
the reﬁnement of said pulse in a closed feedback loop, the
calibration step.

The process of calibration or tune-up utilizes in real life
the direct feedback of the experimental setup to determine the
optimal parameters of the desired controls through a variety
of different experiments. In this setting, the simulation of the
model will take the place of the real-life experiment.

A. Automated Calibration

In traditional calibration, a portfolio of experiments is used
to gain knowledge of the different parameters of the quantum
mechanical system and control pulse necessary to implement
a desired control. Often times these experiments need to be
executed in a hierarchical order as the precise knowledge of
a parameter might be needed as a requirement to determine
the next parameter. This methodology, while working and
successfully used for single- and two-qubit gate tune up, has
proven to be time-consuming and inefﬁcient for devices of the
NISQ era [18]. Additionally, this problem might be ampliﬁed,
given that recent ﬁndings have shown that more complex pulse
shapes could help to improve the overall ﬁdelity of operations
[19]. This added complexity of pulse shapes potentially results
in even more parameters to ﬁne tune, further increasing the
already complicated task of manual calibration.

Henceforth, we advocate an automated approach to calibra-
tion. In this process, we try to minimize a loss function or
goal function, which acts as a ﬁgure of merit for the desired
operation. The loss function ideally incorporates all important
characteristics of the operation and gives feedback about the
quality of the executed operation in regard to the applied
pulse. This approach is by no means new, and has been used
successfully in the past to ﬁne tune control pulses as can be
seen in [19].

In this case we decided to use ORBIT [20] as a loss function
to minimize, and in the following chapter it will be shown how
an ORBIT experiment can be set up in the C3 code.

The task of calibration can be regarded as a black box
optimization, since we have to assume that our initial model
of the system is not accurate. This assumption furthermore
implies that we do not have access to a gradient to make
usage of during the calibration. As such, we will utilize the
Covariance matrix adaptation evolution strategy algorithm or
short CMA-ES algorithm in the calibration phase. CMA-ES
is an advanced gradient free optimization algorithm used as a
state-of-the-art algorithm in the ﬁeld of machine learning.

The following sections will show in depth how to set up
a calibration task in, C3 starting with the creation of an
ORBIT loss function, followed by the preparation of the
CMA-ES optimizer implementation and ﬁnally how to run the
calibration using the provided code interface.

B. ORBIT as Loss Function

We begin by setting up ORBIT as a loss function for
the purpose of automated calibration. An ORBIT sequence
consists of a randomly chosen sequence of Clifford gates,
followed up by a single Clifford gate which reverses the
previous Clifford gates, ensuring that the collective sequence
of gates implements the identity operation.

The creation of the ORBIT sequence in C3 is done through
a helper function, namely single_length_RB, contained
in the qt_utils module.

qt_utils.single_length_RB(

RB_number=1, RB_length=5, target=0

)

The function has access to an internal list of decompositions
of Clifford gates made up of available elemental operations.
In this case, these elemental operations are the gates speciﬁed
in G given in Eq. 3. Which elemental operations are available
usually depends on the experimental hardware and may vary,
this might result in the need of updating the list of decompo-
sitions of Clifford gates.

The single_length_RB function takes as input
the
desired length of the ORBIT sequence labeled as RB_length
as well as the desired targeted qubit we wish to address
as target. Additionally, the function requires as input the
number of desired ORBIT sequences RB_number to create.
The function then returns a list of instruction names cor-
responding to the previously deﬁned available instructions,
which together make up Clifford gates and thereby the full
ORBIT sequence. Following up, we create Qiskit circuits
based on the ORBIT sequences the single_length_RB
function returned. We also supply the new set of parameters
and the corresponding opt_map while invoking the run()
function from the Qiskit backend object. We use the mean
over the population probabilities of the desired ﬁnal state —as
obtained through the Qiskit result object —of all ORBIT
sequences as the ﬁnal result. This concludes the evaluation of
the ORBIT sequences for the simulation.

This evaluation of the ORBIT result is usually provided
by a real life experiment executed on experimental hardware,
and hence the preparation and setup of the above simulation
steps would not be needed when integrated with an actual
experiment.

C. Setup of The Optimization Algorithm

After the preparation of the loss function, we continue with
the setup of the optimizer algorithm. We rely for the minimiza-
tion of the loss function on the covariance matrix adaptation
evolution strategy or CMA-ES algorithm. The implementation
of CMA-ES is hereby provided by the python package pycma
[21].

The optimizer algorithm will later be imported and used
by the calibration object class, which will be created in the
next section. As a preparation for the successful initialization
of said class, we deﬁne some required hyperparameters for
the optimization step. These hyperparameters contain in this
case the maximum allowed number of function evaluations
maxfevals, the minimum required change in the loss func-
tion per function evaluation tolfun for the optimization
to continue, and for the CMA-ES algorithm speciﬁc the
popsize which controls the number of points in each gener-
ation of the algorithm. Speciﬁc for the C3 implementation
is the ﬂag spread which is used to control
the spread
of the initial population. Hereby, a value of 1 is equal to
a spread of the population over the whole area deﬁned in
the min and max values of the Quantity objects. Lastly,
we set the ﬂag init_point to "True" as this will tell
the optimizer class to explicitly add the best values of the
previous C1 step contained in the ParameterMap to the ﬁrst
generation of points to evaluate for CMA-ES, which otherwise

might just sample around it. The init_point ﬂag is another
modiﬁcation to the default behavior of the CMA-ES algorithm
for our purposes.

alg_options = {

"popsize" : 10,
"maxfevals" : 300,
"init_point" : "True",
"tolfun" : 0.01,
"spread" : 0.1

}

D. The Calibration Class

After all preparations are done, we can ﬁnally continue by
setting up the actual calibration object, which takes the pre-
viously created ORBIT loss function and the hyperparameters
of the optimizer as input.

# Create a temporary directory to store logfiles, modify

(cid:44)→ as needed

log_dir = "c3example_calibration"

opt = Calibration(

dir_path=log_dir,
run_name="ORBIT_cal",
eval_func=ORBIT_wrapper,
pmap=parameter_map,
exp_right=simulation,
algorithm=cmaes,
options=alg_options

)

In the above code, the ORBIT loss function is supplied over
the function argument eval_func, while the hyperparame-
ters of the CMA-ES algorithm are provided over the options
argument. It is also in this step in which we specify which
optimizer algorithm the calibration is supposed to use in the
algorithm parameter. The dir_path variable points to
the location the C2 step will save all experimental data in,
which will be used later on in the C3 part for model learning.
Internally, the interaction between the optimizer algorithm
and the loss function is handled by an ask-tell-interface. The
advantage of this interface is, that it is straightforward to
interact with a real life experimental setup in this way, as
new settings provided by the optimizer algorithm only have
to be transferred to the hardware, in an exemplary way shown
below in a pseudocode manner.

# this function is passed as ’eval_func’
# to the calibration object
def exp_communication(params):

# Send parameters to experiment controller
# and receive a measurement result.
return measurement_result

# exemplary usage of ask-tell-interface
while not converged:

# we begin by requesting a new set
# of parameter settings
new_params = optimizer.ask()

# use the defined helper function to
# relay the new settings to the experiment
meas_result = exp_communication(new_params)

in a real life experimental setup by calling the ask function
multiple times.

With the ﬁnal preparations completed, we can now be-
gin the calibration process simply by calling the method
optimize_controls of the calibration class:

opt.optimize_controls()

Fig. 2 shows the ﬁnal result of the calibration step. We can see
how the values of the loss function decrease with an increased
number of iterations of the CMA-ES algorithm, indicating a
successful calibration, which results in an improvement in the
ﬁnal gate ﬁdelity. It is noteworthy that the return value of

Fig. 2. The results of the ORBIT evaluation as function of the iterations of the
CMA-ES algorithm. The light blue diamond markers represent the function
value of each point in a generation, while the red diamond marker is used to
emphasize the best set of parameters in each generation. The number of blue
and red markers together for each iteration add up to the 10 points in each
generation. One can see how in the beginning of the calibration the spread
of the population is wide compared to the spread of populations of the ﬁnal
iterations. This indicates the convergence of the optimizer. Looking at the
evolution of the red markers, we can see the loss function values decreasing.

the ORBIT loss function is not a gate ﬁdelity or inﬁdelity.
This means, that any improvement of the goal function cannot
be directly expressed as improvement in gate ﬁdelity. Hence,
even small improvements in the goal function can lead to big
improvements in the gate ﬁdelity.

IV. MODEL LEARNING

Model based Optimal Control can only be as good as
the model, which means there is always scope for further
reﬁning the parameters of your model and also enriching
your existing model with additional components. An intuitive
approach to solving the former challenge (of tuning your
model parameters to better represent reality) is to use Machine
Learning techniques for extracting the model parameters from
experimental data.

# inform optimizer over measurment results
optimizer.tell(meas_result)

A. The Dataset

Depending on the optimizer used in this step, the ask-tell-
interface also allows for a simple implementation of batching

The dataset for learning model parameters can be generated
from any experiment that can be reproduced in simulation.
For this example, we consider the data from the ORBIT

Calibration step, during which we obtained pairs of gate
sequences and corresponding measurement results. The data
is stored as key-value pairs in the format shown in Table I.
Except the params column, all others have as many entries
as the number of sequences in the ORBIT calibration run, with
each sequence consisting of a series of gates.

TABLE I
DATASET FOR MODEL LEARNING

params

[376.655 mV,
-954.644 m,
-50.333 MHz 2pi,
-1.479 mrad]

seqs
[[rx90p. . . ],
[ry90p. . . ],
..
.
[rx90m. . . ]]

results
[0.1421,
0.1606,
..
.
0.2507]

results std
[0.0137,
0.0129,
..
.
0.0108]

shots
[1000,
1000,
..
.
1000]

In Table I, params is the parameters of the pulse during
that speciﬁc run and seqs stores the exact ORBIT sequence
that was used; while results, results_std and shots
tell us about the measurement outcome, standard deviation and
number of shots respectively. The dataset also has the required
metadata, such as the opt_map which contains information
about the speciﬁc pulse parameters being optimized during
that calibration run.

B. Model and Loss Function

We use the same model as described in the Optimal Control
section since the goal of this step is to ﬁne tune the model
parameters by learning from the calibration data. We simulate
the ORBIT sequence as contained in the dataset using this
model and then compare the measurement outcomes of the
simulation and the experiment. This comparison takes place
in the form of a loss function which is outlined in Eq. 5:

f3(β) = fLL(D|β) =

1
2N

N
(cid:88)

n=1

(cid:34)(cid:18) mn − (cid:101)mn
(cid:101)σn

(cid:19)2

(cid:35)

− 1

(5)

that captures how well the model prediction (cid:101)mn, with standard
deviation (cid:101)σn, agrees with the recorded values mn, in the
dataset D for the model parameter values β = (ωi, δi, ...).
More details on the choice of the loss function is available in
[6]. This loss function is what gets minimized in every step
as the model learns from the data.

C. Algorithms & Optimization

For the purpose of learning, we choose a subset of the
entire data since simulating the whole dataset would be a
signiﬁcant computational challenge. We then deﬁne a few
variables necessary to parameterize the learning process, as
shown in the code snippet with accompanying explanatory
comments.

datafiles = {"orbit": DATAFILE_PATH} # path to the dataset
run_name = "simple_model_learning" # name of the

(cid:44)→ optimization run

dir_path = "ml_logs" # path to save the learning logs
algorithm = "cma_pre_lbfgs" # algorithm for learning
options = {

"cmaes": {

"popsize": 12,
"init_point": "True",
"stop_at_convergence": 10,
"ftarget": 4,
"spread": 0.05,
"stop_at_sigma": 0.01,

},
"lbfgs": {"maxfun": 50, "disp": 0},

} # options for the algorithms
sampling = "high_std" # how data points are chosen from

(cid:44)→ the total dataset

batch_sizes = {"orbit": 2} # how many data points are

(cid:44)→ chosen for learning

state_labels = {

"orbit": [[1,],[2,],]

} # the excited states of the qubit model, in this case it

(cid:44)→ is 3-level

To start

the Model Learning process, an object of the
relevant class is instantiated with the parameters deﬁned in
the previous code snippet, followed by invoking the canonical
run() function on this object.

opt = ModelLearning(

datafiles=datafiles,
run_name=run_name,
dir_path=dir_path,
algorithm=algorithm,
options=options,
sampling=sampling,
batch_sizes=batch_sizes,
state_labels=state_labels,
pmap=parameter_map,

)
opt.set_exp(simulation)
opt.run()

An interesting aspect
to note here is the choice of the
cma_pre_lbfgs algorithm for optimization. This algorithm
is a mix of gradient-free (blackbox) global optimization and
gradient-based local optimization. The CMA-ES undertakes
a global optimization run and once it is approximately close
to the global minima region, it switches over to a gradient
based L-BFGS run to identify the ﬁnal minima. This switching
is controlled by the two stop_at_* criteria as shown in
the code snippet. The stop_at_convergence will switch
to L-BFGS if the CMA-ES cloud has shrunk for this many
number of generations while the stop_at_sigma does the
same if the cloud has shrunk to this standard deviation. This
is largely heuristics based and we do not yet have a clear
explanation to predict the optimal stage for this switch from
gradient-free to gradient-based optimization.

V. QISKIT INTERFACE

An important aspect of this software library is its usability
and universality. This translates to providing an intuitive and
ﬂexible interface which allows end-users to run quantum
circuits on a high-ﬁdelity physics simulator without worrying
about the elaborate setup of the model, but also having access
to the underlying parameters of the model if they so desire.
This is achieved with the help of the Qiskit interface, the
implementation of which is discussed below.

A. The Qiskit backend in c3-toolset

This library includes a c3.qiskit submodule which
allows users to have a drop-in replacement for running their
existing Qiskit circuits on the high-ﬁdelity c3-toolset

such as pulse-level noise mitigation or replicate complete
calibration runs on the digital twin. This pulse level access
is provided through two different interfaces. Firstly, the user
can supply additional options to the Qiskit backend.run()
call, which allows them to deﬁne various pulse parameters,
such as the amplitude, frequency, detuning etc speciﬁc to
this particular circuit. Otherwise, users can also provide a
completely arbitrary piece-wise constant waveform as pairs
of In-phase and Quadrature values; as a parameter for custom
user-deﬁned gates.

VI. SOFTWARE ARCHITECTURE
The c3-toolset software is based on three main building
blocks (Model, Generator, Instructions) that form
the foundation of all
the modelling and calibration tasks,
and depending on the use-case, some or all of these blocks
might be useful, together with the tools necessary to perform
optimization tasks.

A. Model

A theoretical Physics-based model of the Quantum Pro-
cessing Unit. This is encapsulated by the Model class which
consists of objects from the chip and tasks library. chip
contains Hamiltonian models of different kinds of qubit re-
alisations, along with their couplings while tasks let you
perform common operations such as qubit initialisation or
readout. A typical Model object would contain objects en-
capsulating qubits along with their interactions as drive lines
and tasks, if any.

B. Generator

A digital twin of the electronic control stack associated
with the Quantum Processing Unit. The Generator class
contains the required encapsulation in the form of devices
which help model
the behaviour of the classical control
electronics taking account of their imperfections and physical
realisations. The devices e.g, an LO or an AWG or a Mixer are
wired together in the Generator object to form a complete
representation of accessory electronics.

C. Instruction

Once there is a software model for the QPU and the control
electronics, one would need to deﬁne Instructions or operations
to be perform on this device. For gate-based quantum com-
puting , this is in the form of gates and their underlying pulse
operations. Pulse shapes are described through a Envelope
along with a Carrier, which are then wrapped up in the
form of Instruction objects. The sequence in which these
gates are applied are not deﬁned at this stage.

D. Parameter Map

The ParameterMap helps to obtain an optimizable vector
of parameters from the various theoretical models previously
deﬁned. This allows for a simple interface to the optimization
algorithms which are tasked with optimizing different sets of
variables used to deﬁne some entity, e.g, optimizing pulse
parameters by calibrating on hardware or providing an optimal
gate-set through model-based quantum control.

Fig. 3. The Model Learning process for the Qubit Frequency (Q1-freq)
—showing the initial search with CMA-ES followed by L-BFGS —as it
converges to the true value of 5.001 GHz after starting from the assumed
value of 5 GHz in approximately 200 iterations of the learning step.

physics simulator. This is achieved by implementing a Qiskit
backend class that can accept qasm circuits and create the
necessary c3-toolset objects to simulate them and return
the result populations. A minimum example for this is below:

qc = QuantumCircuit(1)
qc.append(RX90pGate(), [0])
c3_provider = C3Provider()
c3_backend =

(cid:44)→ c3_provider.get_backend("c3_qasm_physics_simulator")

c3_backend.set_c3_experiment(simulation)
c3_job_unopt = c3_backend.run(qc)
result_unopt = c3_job_unopt.result()
res_pops_unopt = result_unopt.data()["state_pops"]

The histograms obtained from running this circuit, as shown
in Fig. 4 reﬂect the un-optimized nature of the gates, along
with some leakage to higher levels of the Transmon. The same
circuit when run after the Optimal Control step, returns result
populations much closer to ideally expected values.

Fig. 4. Results of running a Qiskit circuit on the c3-toolset physics
simulator with an unoptimized gateset.

B. Pulse Level Control

The Qiskit interface also gives more advanced users com-
plete pulse level control, allowing them to execute routines

E. Experiment

With the building blocks in place, we can bring them all
together through an Experiment object that encapsulates
the device model, the control signals, the instructions and the
parameter map. Note that depending on the use only some of
the blocks are essential when building the experiment.

F. Optimizers

At its core, c3-toolset is an optimization framework
and all of the three steps - Open-Loop, Calibration and
Model Learning can be deﬁned as a optimization task. The
optimizers contain classes that provide helpful encap-
sulation for these steps. These objects take as arguments
the previously deﬁned Experiment and ParameterMap
objects along with an algorithm e.g, CMA-ES or L-BFGS
which performs the iterative optimization steps.

G. Libraries

The c3/libraries sub-module includes various helpful
library of components that are used somewhat like lego pieces
when building the bigger blocks, e.g, hamiltonians for the
chip present in the Model or envelopes deﬁning a control
pulse. More details about these components are available in
the c3.libraries section.

VII. OUTLOOK
We have described C3, an open-source software package
for the characterization, control planning and calibration for
quantum computers and other quantum technology devices.

Since publishing the initial paper [6], signiﬁcant develop-
ments have been undertaken by a number of contributors on
github.com/q-optimize/c3 to facilitate application in several
projects and physical platforms. Development
is ongoing,
focusing on improving performance and ﬂexibility. In the near
future we are planning on adding support for NV-centers,
Rydberg atoms and trapped ion systems. C3 will also be
the basis on which additional capabilities will be constructed.
Co-design will allow one to simultaneously optimize model
and control parameters, to ﬁnd the model which will, when
fabricated, provide the best performance. Sensitivity analysis
can report on the distance between the model and the data in
terms of standard deviations, and how this distance changes as
a function of varying values of model parameters. Experiment
Design will allow us to plan which data must be taken, i.e.
which experiments must be performed. in order to efﬁciently
reduce error bars of a speciﬁed model parameter. Finally,
we note that much of what has been described in the C3
methodology is not actually speciﬁc to quantum systems, and
may be adapted to other realms of physics using the suitable
digital twin.

The C3 software will be commercialized by qruise.eu.

ACKNOWLEDGEMENTS

This work was supported by the European Commission
through the OpenSuperQ project (Grant Nr. 820363), by the
Germany Ministry of Science and Education (BMBF) through

projects VERTICONS and DAQC (Grant Nr. 13N14872
and 13N15688) and the Helmholtz Validation Fund project
”Qruise” (HVF-00096).

REFERENCES

[1] J. Preskill, “Quantum computing in the NISQ era and beyond,”
[Online]. Available: https:

Quantum, vol. 2, p. 79, aug 2018.
//doi.org/10.22331%2Fq-2018-08-06-79

[2] S. Bravyi, D. Gosset, and R. K¨onig, “Quantum advantage with shallow

circuits,” Science, vol. 362, no. 6412, pp. 308–311, 2018.

[3] S. Beauregard, “Circuit for shor’s algorithm using 2n+ 3 qubits,” arXiv

preprint quant-ph/0205095, 2002.

[4] R. Suzuki, K. Mitarai, and K. Fujii, “Computational power of one-and
two-dimensional dual-unitary quantum circuits,” Quantum, vol. 6, p.
631, 2022.

[5] D. J. Egger and F. K. Wilhelm, “Adaptive hybrid optimal quantum
control for imprecisely characterized systems,” Physical review letters,
vol. 112, no. 24, p. 240503, 2014.

[6] N. Wittler, F. Roy et al., “Integrated tool set for control, calibration, and
characterization of quantum devices applied to superconducting qubits,”
Physical Review Applied, vol. 15, no. 3, p. 034080, 2021.

[7] T. Alexander, N. Kanazawa et al., “Qiskit pulse: programming quantum
computers through the cloud with pulses,” Quantum Science and
Technology, vol. 5, no. 4, p. 044006, Aug 2020. [Online]. Available:
http://dx.doi.org/10.1088/2058-9565/aba404

[8] H. Ball, M. J. Biercuk et al., “Software tools for quantum control:
Improving quantum computer performance through noise and error
suppression,” 2020.

[9] S. Bade, G. Winer et al., “qua-platform/qua-libs: Open sourced
[Online]. Available: https://doi.org/10.5281/

libraries,” May 2021.
zenodo.4769470

[10] B. Li, S. Ahmed et al., “Pulse-level noisy quantum circuits with qutip,”

arXiv preprint arXiv:2105.09902, 2021.

[11] M. M. M¨uller, R. S. Said et al., “One decade of quantum optimal control
in the chopped random basis,” arXiv preprint arXiv:2104.07687, 2021.
[12] M. S. ANIS, Abby-Mitchell et al., “Qiskit: An open-source framework

for quantum computing,” 2021.

[13] J. Nocedal,

“Updating

limited
storage,” Mathematics of Computation, vol. 35, no. 151, pp.
773–773,
[Online]. Available: https://doi.org/10.1090/
s0025-5718-1980-0572855-7

quasi-newton matrices with

sep 1980.

[14] S. Machnes, E. Ass´emat et al., “Tunable, ﬂexible, and efﬁcient
for practical qubits,” Phys. Rev.
[Online]. Available: https:

optimization of control pulses
Lett., vol. 120, p. 150401, Apr 2018.
//link.aps.org/doi/10.1103/PhysRevLett.120.150401

[15] D. M. Reich, M. Ndong, and C. P. Koch, “Monotonically convergent
optimization in quantum control using krotov’s method,” The Journal
of Chemical Physics, vol. 136, no. 10, p. 104103, 2012. [Online].
Available: http://dx.doi.org/10.1063/1.3691827

[16] N. Khaneja, T. Reiss et al., “Optimal control of coupled spin dynamics:
design of nmr pulse sequences by gradient ascent algorithms,”
Journal of Magnetic Resonance, vol. 172, no. 2, pp. 296 – 305,
2005. [Online]. Available: http://www.sciencedirect.com/science/article/
pii/S1090780704003696

[18] F. Arute, K. Arya

[17] D. C. McKay, C. J. Wood et al., “Efﬁcient z gates for quantum
computing,” Physical Review A, vol. 96, no. 2, p. 022330, 2017.
al.,
superconducting
505–510,

a
574,
[Online]. Available:

programmable
no.
2019.
https://doi.org/10.1038%2Fs41586-019-1666-5

“Quantum supremacy
processor,” Nature,

7779,

using

vol.

pp.

oct

et

[19] M. Werninghaus, D. J. Egger et al., “Leakage reduction in fast
superconducting qubit gates via optimal control,” npj Quantum
Information, vol. 7, no. 1,
[Online]. Available: https:
jan 2021.
//doi.org/10.1038%2Fs41534-020-00346-2

[20] J. Kelly, R. Barends et al., “Optimal Quantum Control Using
Randomized Benchmarking,” Phys. Rev. Lett., vol. 112, p. 240504, Jun
2014. [Online]. Available: https://link.aps.org/doi/10.1103/PhysRevLett.
112.240504

[21] N. Hansen, Y. Akimoto, and P. Baudis, “CMA-ES/pycma on Github,”
Zenodo, DOI:10.5281/zenodo.2559634, Feb. 2019. [Online]. Available:
https://doi.org/10.5281/zenodo.2559634

