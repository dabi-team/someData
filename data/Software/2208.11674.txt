2
2
0
2

g
u
A
4
2

]
E
S
.
s
c
[

1
v
4
7
6
1
1
.
8
0
2
2
:
v
i
X
r
a

On the Dependency Heaviness of
CRAN/Bioconductor Ecosystem

A Preprint

Zuguang Gu
National Center for Tumor Diseases (NCT)
Heidelberg, Germany
z.gu@dkfz.de

August 25, 2022

Abstract

The R package ecosystem is expanding fast and dependencies among packages in the
ecosystem are becoming more complex. In this study, we explored the package dependencies
from a new aspect. We applied a new metric named “dependency heaviness” which measures
the number of additional strong dependencies that a package uniquely contributes to its child
or downstream packages. It also measures the total reduced dependencies in the ecosystem
when the role of a package is changed from a strong parent to a weak parent. We systematically
studied how the dependency heaviness spreads from parent to child packages, and how it
further spreads to remote downstream packages in the CRAN/Bioconductor ecosystem.
We extracted top packages and key paths that majorly transmit heavy dependencies in
the ecosystem. Additionally, the dependency heaviness analysis on the ecosystem has
been implemented as a web-based database that provides comprehensive tools for querying
dependencies of individual R packages.

K eywords R · CRAN · Bioconductor · Dependency graph · Dependency heaviness · Software ecosystem ·
Software engineering

1 Introduction

R has become a major programming language applied in many ﬁelds, such as statistics, bioinformatics,
geoinformatics, economics or general data science, where it is widely used for data processing (Grolemund
and Wickham 2016), visualization (Wilke 2019), statistical modeling (Venables and Ripley 2002), interactive
web application development (Wickham 2021), and reproducible reporting (Xie 2015). The reusable and
extensible code implemented by developers are formatted as R packages and distributed on public repositories
such as the Comprehensive R Archive Network (CRAN) and Bioconductor (Huber et al. 2015). The number
of packages in the two repositories increases almost exponentially by year (Hornik, Ligges, and Zeileis 2021).
In the R package ecosystem, a package may inherit functionalities from other packages, which forms the
dependencies between packages. The expanding of the R package ecosystem makes the dependency relations
among packages even more complex. By 2022-06-08, there are in total 22,076 CRAN/Bioconductor packages,
including 194,351 direct dependency relations.

It is important to explore the dependency structure in the R package ecosystem from the aspect of software
engineering, which helps to understand the structure of the ecosystem, to reveal the top packages having major
impacts, and to study the vulnerability of the ecosystem. Currently there are a few studies on the dependencies
of the R package ecosystem. In (Korkmaz et al. 2019), the authors studied the impacts of packages measured
by the numbers of downloads, and they studied how the impacts correlated to various centrality measures in
the global dependency graph. They found packages with higher closeness and page-rank centralities tended to
have higher impacts. In (Decan, Mens, and Claes 2016), the authors compared dependency graphs in R and

 
 
 
 
 
 
A preprint - August 25, 2022

other two programming languages of JavaScript and Python, and they found programming language speciﬁc
patterns. In (Decan et al. 2016), the authors studied the inter-repository package dependencies between two
repositories of CRAN and Github. In (Mora-Cantallops, Sánchez-Alonso, and García-Barriocanal 2020), the
authors applied the complex network analysis approach to study various network statistics of the dependency
graph. They extracted a list of network modules where each one corresponded to a speciﬁc analysis task.
In a very recent paper (Vidoni 2021), the author proposed to call more software engineering studies on R
programming language to study the language itself as well as the package ecosystem on the system level.

The dependency relations between R packages can be put into two categories: strong dependency and weak
dependency. For a package denoted as P, its strong dependency packages provide classes or methods directly
used in P. Thus, strong dependency packages are mandatory to be installed when installing P. The weak
dependency packages are optionally used in P, such as in vignettes, in examples, or in functions where they
are required only when the functions are called. Thus, they are not installed by default when installing P.
Handling dependencies for packages is an important task for R package developers. In our previous study
(Gu and Hübschmann 2022), we proposed a new metric named “dependency heaviness” that measures the
number of dependencies that a parent uniquely brings to its child package and are not brought by any other
parent. In practice, the heaviness also measures the number of reduced dependencies if changing the role of a
parent package from strong to weak. We have implemented the heaviness metric in an R package named
pkgndep (Gu and Hübschmann 2022), which additionally provides an intuitive visualization to reveal which
parent packages contribute heavy dependencies. The heaviness metric as well as the pkgndep package can
help R package developers to properly handle the dependency complexity of their packages and to build more
robust and reliable packages.

In our previous study (Gu and Hübschmann 2022), we applied dependency heaviness analysis on individual
packages to reveal their heavy parents and we proposed solutions for optimizing the dependencies. In this
study, we extended the deﬁnition of dependency heaviness and we applied software engineering approach
to systematically study how the dependency heaviness spreads from parent to child packages, and how it
further spreads to remote downstream packages in the CRAN/Bioconductor ecosystem. We studied the
distributions of various heaviness metrics and we extracted top packages and key paths that majorly transmit
heavy dependencies in the ecosystem. Additionally, the dependency heaviness analysis on the ecosystem has
been implemented as a web-based database which provides comprehensive tools for analyzing dependencies of
individual R packages.

2 Methods

The dependency relations are listed in an R package’s DESCRIPTION ﬁle, in the ﬁelds of “Depends”,
“Imports”, “LinkingTo”, “Suggests” and “Enhances”. Denote a package as P, dependency packages in its
“Depends” are expected to be directly used by users if P is to be used, where they provide base functionalities
for P. For example, it might be a good idea to set the package ggplot2 as a “Depends” package for its
extension packages. Dependency packages in “Depends” are attached to the search path in the R session
ahead of P with the command library(P), and all their public functions are visible to users. Dependency
packages listed in “Imports” are internally used by P where speciﬁc functions, methods or classes from
there are imported into P’s namespace based on the rules deﬁned in P’s NAMESPACE ﬁle. The “Imports”
packages are also loaded in the R session, but they are not attached to the search path, thus not visible to
users. Dependency packages listed in “LinkingTo” contain header ﬁles to compile P’s C/C++ code. Packages
listed in “Depends”, “Imports” and “LinkingTo” are necessary for using P and they must be installed before
installing P. Fields “Suggests” and “Enhances” are similar. They contain dependency packages that are
not necessary for using P, e.g., only used in examples or vignettes, or in the code that provides optional
functionalities of P. Thus, these two types of dependencies are not mandatory to be installed when installing
P. However, dependencies in “Suggests” are by default required for a complete R CMD check. “Enhances”
ﬁeld is more ﬂexible and the packages listed are never checked. Readers please refer to the oﬃcial R manual
“Writing R Extensions” (R Core Team, 2022) for more details. In the CRAN/Bioconductor ecosystem, the
proportions of the ﬁve types of dependency relations are 8.8% for “Depends”, 54.4% for “Imports”, 2.8% for
LinkingTo, 33.7% for “Suggests”, and 0.4% for “Enhances” from 194,351 relations in 22,076 packages (data
collected on 2022-06-08).

2.1 Dependency categories

We ﬁrst deﬁned the following dependency categories for package P.

2

A preprint - August 25, 2022

Figure 1: Demonstration of dependency relations between R packages.

Strong parent packages: Dependency packages listed in the “Depends”, “Imports”, and “LinkingTo” of P
(red box in Figure 1). They are also called the strong direct dependency packages of P. Strong parent
packages are mandatory to be installed when installing P. To make it easy to discuss, we always referred to
them as parent packages in the text.

Weak parent packages: Dependency packages listed in the “Suggests” and “Enhances” of P (green box in
Figure 1). They are optionally required when installing P.

Strong dependency packages: Total dependency packages by recursively looking for parent packages
(category A, B, as well as packages in red box in Figure 1). They are also called the upstream packages.
Note strong dependency packages include parent packages. Strong dependency packages are mandatory to
be installed when installing P.

All dependency packages: Total dependencies by recursively looking for parent packages, but on the level
of P, its weak parents are also included (package category A, B, C and D, plus all packages listed in the
red and green boxes in Figure 1). It simulates when the full functionality of P is required, or when all weak
parents become strong parents, the total number of strong dependency packages that P requires. In this
paper, we did not discuss packages in this category, but for completeness, its deﬁnition is still given here.

Child packages: Packages whose parents include P (category E in Figure 1). They are the packages on
which P has a direct impact of dependencies.

Downstream packages: Total packages by recursively looking for child packages (category E and F in
Figure 1). P is required for the installation of any of its downstream packages. Note downstream packages
include child packages.

Indirect downstream packages: Downstream packages excluding child packages (category F in Figure
1), i.e., these with distance to P of at least two in the global dependency graph. These are the packages on
which P has an indirect inﬂuence of dependencies. Note in some of the current studies, they are also called
transitive packages.

2.2 Deﬁnitions of dependency heaviness

Depends on diﬀerent dependency categories, there are the following heaviness metrics.

Heaviness from a parent. If package A is a strong parent of P, the heaviness of A on P denoted as h is
calculated as

where n1 is the number of strong dependencies of P (Figure 2A), and n2 is the number of strong dependencies
of P after changing A from a strong parent to a weak parent, i.e., by moving A to “Suggests” of P (Figure

h = n1 − n2

3

Package PPackage C, ...Depends: package, ... Imports: package, ... LinkingTo: package, ...Category CPackage A, ...Depends: package, ... Imports: package, ... LinkingTo: package, ...Category APackage B, ...Depends: package, ... Imports: package, ... LinkingTo: package, ...Category BPackage D, ...Depends: package, ... Imports: package, ... LinkingTo: package, ...Category DPackage E, ...Depends: package, ... Imports: package, ... LinkingTo: package, ...Category EPackage F, ...Depends: package, ... Imports: package, ... LinkingTo: package, ...Category FDepends: package, ... Imports: package, ... LinkingTo: package, ...Suggests: package, ... Enhances: package, ... A preprint - August 25, 2022

Figure 2: Demonstration of the heaviness deﬁnitions. A) Fragment of the DESCRIPTION ﬁle of package P
where package A is a strong parent. B) Change A to a weak parent of P, i.e., by moving A to P’s “Suggests”.
C) The dependency graph of all upstream packages of P. Note the graph only contains the strong dependency
relations. D) Remove the relation between A and P from the dependency graph to simulate A has become a
weak parent of P. E) Fragment of the DESCRIPTION ﬁle of package P where package B is a weak parent.
F) Change B to a strong parent of P, i.e., by moving B to P’s “Imports”. G) The dependency graph of all
upstream packages of P. Note since B is a weak parent of P, there is no connection between B and P. H)
Add a new connection between B and P to simulate B has become a strong parent of P.

2B). Thus, the heaviness measures the number of additionally required strong dependencies that A brings to
P and are not brought by any other parent. In some discussions in the paper, we explicitly denoted it as
hA→P to indicate the parent-child relation.

If package B is a weak parent of P, n2 is deﬁned as the number of strong dependencies of P after changing B
to a strong parent of P, i.e., by moving B to “Imports” of P (Figure 2E-F). In this scenario, the heaviness of
the weak parent is calculated as n2 − n1.

From the aspect of dependency graph denoted as a directed graph G = (V, E) where V are all packages in
the ecosystem and E are the strong parent-child dependency relations in the graph, the heaviness of A on P
is a score associated with an edge eA→P ∈ E. Now n1 is the number of upstream packages of P (n1 = 9 in
Figure 2C) and n2 is the number of upstream package of P after removing the connection of A→P from G
(n2 = 6 in Figure 2D), thus the heaviness of A on P is n1 − n2 = 3. When B is a weak parent of P, n2 is
calculated as the number of upstream packages after adding a new connection of B→P to G (Figure 2G-H).

Since weak parents are not necessarily required for P, in this paper, we only discussed the heaviness from
strong parents.

Max heaviness from parents. Normally, a package has multiple parents. Max heaviness from parents
helps to reveal the parent that dominantly brings extra dependencies to package P. Assume P has Kp parents,
the heaviness denoted as hmax is deﬁned as

hmax = max

hk

k∈{1..Kp}

where hk is the heaviness of the kth parent on P.

4

PAP1P2P3PAP1P2P3XPBP1P2P3PBP1P2P3YPackage: PType: PackageTitle: titleVersion: 0.99.0Date: 2022-06-08Authors:ZuguangGuImports: A, parent1, parent2,parent3Suggests: parent4 parent5...Package: PType: PackageTitle: titleVersion: 0.99.0Date: 2022-06-08Authors:ZuguangGuImports: parent1, parent2, parent3Suggests: A, parent4, parent5...Package: PType: PackageTitle: titleVersion: 0.99.0Date: 2022-06-08Authors: Zuguang GuImports: parent1, parent2,parent3Suggests: B, parent4, parent5...Package: PType: PackageTitle: titleVersion: 0.99.0Date: 2022-06-08Authors: Zuguang GuImports: B, parent1, parent2, parent3Suggests: parent4, parent5...AEFGHBCDA preprint - August 25, 2022

Heaviness from an upstream package. If package C is an upstream package of P in the global dependency
graph, denote n1 as the number of strong parents of P, and n2 as the number of strong parents of P after
changing C to a weak parent of all C ’s child packages, then the heaviness of C on P denoted as hu is
calculated as

hu = n1 − n2.

From the aspect of the dependency graph, n2 is the number of upstream packages of P after removing all
edges which start from C. When C is only a parent of P (i.e., distance from C to P is one), hu is not always
identical to h. Assume C is a parent of P and P has another parent A where C is also a parent of A, i.e., with
the relations of C →P and C →A→P. h just measures the local dependency eﬀect which only removes C →P,
while hu is a global dependency eﬀect which removes all links from C, i.e., both C →P and C →A, which
makes in general hu ≥ h. In some discussions in the paper, we denoted it explicitly as hC→P
to indicate the
upstream-downstream relation.
Heaviness on child packages. Assume P has Kc child packages and the kth child is denoted as Ak. Denote
the number of strong dependencies of Ak as n1k, and denote the number of strong dependencies of Ak after
changing P to a weak parent of Ak as n2k, the heaviness of P on its child packages denoted as hc is calculated
as

u

hc =

1
Kc

KcX

k=1

(n1k − n2k).

The heaviness measures the average number of additional dependencies that P brings to its child packages.

Heaviness on downstream packages. The deﬁnition is similar to the heaviness on child packages. Assume
P has Kd downstream packages and the kth downstream package is denoted as Bk. Denote the number of
strong dependencies of Bk as n1k, and denote the number of strong parents of Bk after changing P to a weak
parent of all P’s child packages as n2k. The heaviness of P on its downstream packages denoted as hd is
calculated as

hd =

1
Kd

KdX

k=1

(n1k − n2k).

From the aspect of the dependency graph, n2k is the number of upstream packages of Bk in a reduced graph
where P is removed. Similar to the diﬀerence between heaviness from a parent and from an upstream package,
when a package’s downstream packages are only composed of its child packages, i.e., the maximal distance
from P to its downstream packages is one, hc and hd are not always identical. hc is a local measure while hd
is a global measure. They have the relation of hd ≥ hc.

Heaviness on indirect downstream packages. The calculation is the same as hd except here child
packages are excluded from downstream packages. Denote the heaviness as hid and denote the set of P’s
child packages as Sc, hid is deﬁned as

hid =

1
Kd − Kc

KdX

k=1

(n1k − n2k) · I(Bk /∈ Sc)

where Kc and Kd are the numbers of child and downstream packages respectively, and I() is an indicator
function. hid is set to 0 if Kc = Kd, i.e., P has no indirect downstream packages. hid measures the contribution
of dependencies of P to the ecosystem in an indirect way.

2.3 Adjusted heaviness

In the “Results” section, we performed dependency heaviness analysis on the CRAN/Bioconductor ecosystem.
One of the aims is to prioritize packages which are signiﬁcantly aﬀected by upstream packages or aﬀect their
downstream packages in the ecosystem. If grouping packages by K which can be the number of parent, child
or downstream packages depending on the type of the heaviness metrics, the distributions of heaviness values

5

A preprint - August 25, 2022

always have long tails, and the tails are especially longer for smaller K (Figure 4 and 7). Thus, if simply
ranking packages based on the original heaviness values, top packages are preferably associated with small
K. In general, packages with small K are of less interest because they only have very small impacts to the
ecosystem. To prioritize packages with broader impacts to the ecosystem, the original deﬁnitions of various
heaviness metrics are adjusted to decrease the weights of packages with smaller K. Please note, the designs of
the adjusted heaviness metrics are empirical and the absolute values of adjusted heaviness are meaningless,
which are only used for ranking packages.

Adjusted max heaviness from parents: When a package has more parents, dependencies from individual
parents would have more overlap (i.e., dependencies from parent A overlap to the dependencies from parent
B). Since heaviness only measures the number of unique dependencies that a single parent brings in, or in
other words, the number of dependencies that are mutually exclusive to those brought by all other parents,
with more parents, the max heaviness from parents would decrease. For a package indexed as k in the
ecosystem, the original max heaviness from parent denoted as hmax,k is adjusted to hadj
max,k, by multiplying a
zooming factor denoted as ak:

And ak is deﬁned as

hadj
max,k = ak · hmax,k.

ak = (nk + 30)/nmax

where nk is the number of parents of the kˆth package, and nmax is the maximal number of parents of all
packages in the ecosystem. The value of 30 was selected empirically to balance the zooming rate on diﬀerent
nk.

Adjusted heaviness on child packages: Generally, the heaviness on child packages has a trend that the
distribution tails are shortened when the numbers of child packages increase (Figure 7). This is mainly
because if package P has more child packages, its child packages may have more other parents which dilute
the heaviness from P. To decrease the weights of packages with small numbers of child packages, a positive
penalty term denoted as a is added to Kc as in the following equation where Kc is the number of child
packages and hadj
is the adjusted heaviness for a package on its child packages. Note a is set to the same
value for all packages.

c

hadj
c =

1
Kc + a

KcX

k

(n1k − n2k) =

Kc
Kc + a

· hc

It is easy to see that a decreases hc faster for smaller Kc than larger Kc. To select an optimized value for a,
we took a as integers in the set {1, 2, . . . , 29, 30}; and for a speciﬁc package indexed as k and a value of a,
we calculated the adjusted heaviness on its child packages denoted as hadj
c,k,a, and the vector for all packages is
denoted as hadj
c,a . a is selected as the value by which the ranking of adjusted heaviness of all packages becomes
c,a compared to hadj
stable. To measure the stability of the ranking of hadj
c,a−1, we calculated the stability score
denoted as sa as

sa =

1
N

N
X

k

I(|Rk,a − Rk,a−1| ≤ 50)

where N is the total number of packages in the ecosystem, Rk,a and Rk,a−1 are the ranks of package k’s
adjusted heaviness in hadj

c,a−1 respectively, and I() is the indicator function.

c,a and hadj

sa, or its general denotation s, measures the fraction of packages whose ranking diﬀerences of adjusted
heaviness are no larger than 50 in the two neighboring values of a (50 is a small value compared to the total
number of R packages in the ecosystem, which is 22,076 in this study). When s becomes stable with a, we
could conclude increasing a won’t greatly change the ranking of s. Thus, based on the “knee” rule, a was
selected to 10 (Figure 3A).

6

A preprint - August 25, 2022

Figure 3: Select a proper penalty value for adjusting heaviness values. A) Adjust heaviness on child packages.
B) Adjust heaviness on indirect downstream packages. Vertical dashed lines are the ﬁnal selections of the
penalty values.

Adjusted heaviness on indirect downstream packages: The deﬁnition is the same as the adjusted
heaviness on child packages. For a package P, the adjusted heaviness denoted as hadj

id is calculated as:

hadj
id =

Kid
Kid + a

· hid

where Kid is the number of indirect downstream packages, i.e., Kid = Kd − Kc. The penalty a was selected
in a similar way as for child packages. It was selected as a = 6 (Figure 3B).

The heaviness on all downstream packages can be adjusted in the same way, however, in this study, we
only looked at the heaviness on indirect downstream packages instead of all downstream packages (see more
discussions in the “Results” section). Thus, here we omitted the deﬁnition of adjustment of heaviness on all
downstream packages.

2.4 Co-heaviness from parent pairs

Heaviness from parent A on P only measures the number of additional dependencies that A uniquely brings
to P. However, there are scenarios where multiple parents import a similar set of dependencies, which results
in heaviness for individual parents being very small. Here we deﬁned the co-heaviness that measures the
number of additional dependency packages simultaneously brought by two parent packages. Let A and B be
two parents of P, denote SA as the set of reduced dependency packages when only changing A to a weak
parent of P, denote SB as the set of reduced dependency packages when only changing B to a weak parent of
P, and denote SAB as the set of reduced dependency packages when changing both A and B to weak parents
of P, then the co-heaviness of A and B on P denoted as hco is deﬁned as

hco = |SAB \ ∪(SA, SB)|

where the symbol X \ Y corresponds to the set of elements in X but not in Y , and |X| is the number of
elements in set X. The co-heaviness measures the number of reduced packages only caused by co-action of A
and B. In some discussions in the paper, we denote it explicitly as h(A,B)→P

to indicate the relations.

co

With the previous denotations, there are

7

0.800.850.900.951.000102030Value of aStability of ranks of all heavinesses compared to previous aA) Adjust heaviness on child packages0.9250.9500.9751.0000102030Value of aStability of ranks of all heavinesses compared to previous aB) Adjust heaviness on indirect downstream packagesA preprint - August 25, 2022

hA = |SA|
hB = |SB|
SA ∩ SB = ∅

where hA is the heaviness of A on P, and hB is the heaviness of B on P. Then there is the following relation

Thus, the number of reduced dependencies by moving both A and B to P’s weak parents is the sum of
heaviness of A and B on P individually and the co-heaviness of A and B on P.

|SAB| = hco + hA + hB.

3 Results

We systematically studied the dependency heaviness in the CRAN/Bioconductor ecosystem. 18,638 R
packages from CRAN and 3,438 packages from Bioconductor (bioc version 3.15) were retrieved on 2022-06-08.
Two main questions on the package dependencies were asked: 1. How does the dependency heaviness spread
locally from parent to child packages? 2. How do packages contribute the dependency heaviness to their
remote downstream packages?

3.1 Heaviness from parent packages

Max heaviness from parents (abbreviated as MHP) measures the number of unique dependencies that a
package maximally inherits from its parents. In general, MHP has a long-tail distribution where 82.4% of all
packages have a heaviest parent contributing heaviness < 30, whereas there are only 4.0% of them having a
heaviest parent contributing heaviness ≥ 60. Therefore, only a small fraction of packages have heavy parents
in the ecosystem. For 878 packages with extremely heavy parents (MHP ≥ 60), 785 (89.4%) of them only
have less than 15 parents, which indicates packages with small numbers of parents are more likely to have
heavy parents. Also interestingly, 720 (82.0%) of them do not have child packages, which indicates when
packages have heavier parents, they are more likely to be leaf packages in the dependency graph and no other
package depends on them.

Distribution tails of MHP are shortened when the numbers of parents increase (Figure 4A). As has been
explained in the “Methods” section, MHP measures the number of unique dependencies that a single parent
maximally brings in. Thus, with more parents, dependencies from multiple parents would have more chances
to overlap, which results in decreasing MHP. In Figure 4A, it can be straightforwardly observed that, on the
top edge of the point clouds, there is a clear trend that MHP drops as the numbers of parents increase.

Packages with smaller numbers of parents have longer distribution tails of MHP. To capture top packages
with the heaviest parents but not biased by the small numbers of parents, the original MHP was adjusted.
Top packages that have extremely heavy parents are ﬁltered by adjusted MHP ≥ 60 and they are marked in
red in Figure 4A. We found there are 8 CRAN packages and 24 Bioconductor packages that have extremely
heavy parents. This indicates Bioconductor packages may suﬀer more from heavy parents. Among them,
the package MinBAR has the heaviest parent named ecospat in the CRAN/Bioconductor ecosystem where
ecospat uniquely contributes 206 additional dependencies to MinBAR. Interestingly, ecospat also inherits
dependencies from a heavy parent bimod2 which contributes a heaviness of 117 to ecospat, and in turn bimod2
inherits 88 unique dependencies from its heavy parent ENMeval. This indicates the heavy dependencies may
be transmitted from upstream packages via chain actions. The long-range transmission of heaviness will be
further discussed in later sections.

Globally, Bioconductor packages have heavier parents than CRAN packages. The mean MHP for all
Bioconductor packages is 25 while it is only 13 for all CRAN packages (the median values are 16 verse 6).
Nevertheless, the diﬀerence of MHP becomes smaller when the number of parents increases. E.g., when only
considering packages with parents > 20 (580 packages left), the mean values are 27 verse 23 for CRAN and
Bioconductor packages, and the median values are 23 verse 19.

A package may have multiple parents. We observed it is a general pattern that only a small number of parents
contribute large heaviness while the majority of other parents only contribute very small heaviness to their
child packages. Then Gini index was used to quantitatively measure the dispersion of the heaviness distribution
from a package’s parents. When the Gini index is close to 1, there is a uniquely high heaviness value; and

8

A preprint - August 25, 2022

Figure 4: Heaviness from parent packages. A) Max heaviness from parent packages. B) Gini index of the
heaviness from parents. In Figure A, since points may overlap, we visualized the two-dimensional distribution
densities where numbers of neighbor points were based on circular areas with radius of 1% of ranges on x-axis
and y-axis respectively. The packages highlighted in red in Figure A are the same as in Figure B, which are
the top packages ﬁltered by adjusted MHP ≥ 60. MHP: max heaviness from parents.

when the Gini index is close to zero, the heaviness values approximately follow a uniform distribution. Figure
4B shows that there is a clear trend that when MHP increases, i.e., when the parents get heavier, the Gini
indices increase as well. For the top packages with extreme MHP, the corresponding Gini indices are very
close to 1. This indicates these heaviest parents play unique and dominant roles in contributing dependencies
to their child packages.

3.2 Co-heaviness from two parent packages

Heaviness discussed in the previous section only measures the number of dependencies that a single parent
uniquely brings in. However, there are scenarios when multiple parents import similar sets of dependencies,
which results in heaviness from individual parents being very small. In this section, we studied the dependency
heaviness simultaneously imported by two strong parents, i.e., the co-heaviness. In the analysis, for a package,
we only looked at the maximal co-heaviness from all its parent pairs (abbreviated as MCoHP), because
empirically MCoHP is dramatically higher than the co-heaviness from other pairs if a package really has
a heavy parent pair. For the ease of discussion, we named the parent pair which contributes the highest
co-heaviness as the MCoHP parents.

9

biomod2DUBStepRecospatitsdmMinBARRcmdrPlugin.temisspmspm2AgiMicroRnaarrayMvoutbandlecenscytdiffcytDinoiCheckMetaCytomethylPipemiRSMmiRspongeRpRolocGUIProstarRNAmodR.MLscCB2segmenterSTANtreekoRffpeExampleDataMethylAidDatalumiBarnesMAQCsubsetMAQCsubsetILMmvoutDataCRANBioconductor020406080020406080050100150200Number of parent packagesMax heaviness from parents110100Number ofneighbor pointsHeaviness categoryhighA) Max heaviness from parentsCRANBioconductor0501001502000501001502000.000.250.500.751.00Max heaviness from parentsGini indexHeaviness categoryhighB) Gini index of heaviness from strong parentsA preprint - August 25, 2022

Figure 5: Relations of the MCoHP parents of the 533 packages with MCoHP ≥ 40. MCoHP: max co-heaviness
from parents.

In the CRAN/Bioconductor ecosystem, we found 92.6% of all packages have MCoHP < 20, and only 533
(2.4%) of them (143 from CRAN and 390 from Bioconductor) have MCoHP ≥ 40, which indicates the
proportion of packages whose dependencies are simultaneously inherited from two parents are very small in
the ecosystem. Denote two parents of package P as A and B, the relations of parent pairs can be summarized
into the following four categories:

1. Parent-child. E.g., A is a parent of B where B inherits all dependencies from A.
2. Upstream-downstream. E.g., A is an indirect upstream package of B where B also inherits all

dependencies from A.

3. Common-upstream. There exists a common upstream package C of A and B where C contributes
> 0.75h(A,B)→P
.
co

heavy dependencies to both A and B, deﬁned as hC→A
This means the co-heaviness of A and B mainly comes from C.

> 0.75h(A,B)→P
co

and hC→B
u

u

4. No clear relation. The dependencies of A and B are accumulated from their upstream packages
independently, or A and B may have common upstream, but the upstream packages do not contribute
signiﬁcantly high heaviness on them.

For the 533 packages with MCoHP ≥ 40, in 486 (91.2%) packages, the MCoHP parents are in parent-child
relation; in 4 (0.75%) packages, the MCoHP parents are in upstream-downstream relation; in 13 (2.4%)
packages, the MCoHP parents are in common-upstream relation; and in 30 (5.6%) packages, the MCoHP
parents have no clear relation (Figure 5).

Since most MCoHP parents are in parent-child relation, we next studied whether there is preference of selecting
parents as a member of the MCoHP parents. Again only in the 533 packages with MCoHP ≥ 40, we found in
the Bioconductor ecosystem, the package AnnotationDbi dominantly contributes high co-heaviness to its child
packages as a MCoHP parent (Figure 6A-B). Top four companion packages co-working with AnnotationDbi
are org.Hs.eg.db (aﬀecting 79 child packages), org.Mm.eg.db (aﬀecting 51 child packages), GenomicFeatures
(aﬀecting 48 child packages) and org.Rn.eg.db (aﬀecting 35 child packages) (Figure 6A). AnnotationDbi is a
base Bioconductor package which deﬁnes the database interface, and a large number of other packages storing
speciﬁc biological annotation data are implemented with that interface. To use a speciﬁc annotation package

10

0100200300400500Parent−childUpstream−downstreamCommon−upstreamNo clear relationRelations of the MCoHP parentsCountA preprint - August 25, 2022

Figure 6: Co-heaviness in the R/Bioconductor ecosystem. A, C, E) Number of child packages for each
MCoHP parent pair. Figure A: all 390 top Bioconductor packages; Figure C: the top Bioconductor packages
of which MCoHP parents do not include the annotation packages listed in Figure B; Figure E: all 143 top
CRAN packages. In Figure A, C, E, numbers in the parenthese are the average co-heaviness. B, D, F)
Number of child packages for packages as a member of MCoHP parents. In Figure B, D, F, numbers in the
parenthese are the average co-heaviness and numbers of companion packages. All analyses are restricted to
533 packages with MCoHP ≥ 40. MCoHP: max co-heaviness from parents.

11

AnnotationDbi,org.Hs.eg.db (44)AnnotationDbi,org.Mm.eg.db (44)AnnotationDbi,GenomicFeatures (45)AnnotationDbi,org.Rn.eg.db (44)AnnotationHub,ExperimentHub (67)0204060800255075100125MCoHP parentsNumber of child packages having the parent pairA) 390 Bioconductor packagesAnnotationDbi (44, 18 companions)org.Hs.eg.db (44, 1 companions)GenomicFeatures (47, 9 companions)org.Mm.eg.db (44, 1 companions)AnnotationHub (64, 7 companions)ExperimentHub (65, 6 companions)org.Rn.eg.db (44, 1 companions)BSgenome (46, 30 companions)050100150200050100150Members in the MCoHP parentsNumber of child packages having the co−parentB) 390 Bioconductor packagesCAMERA,xcms (77)01234502040MCoHP parentsNumber of child packages having the parent pairC) 67 Bioconductor packages,where 8 annotation−related parent packages are removed.xcms (71, 4 companions)biomaRt (48, 5 companions)Gviz (88, 4 companions)VariantAnnotation (54, 4 companions)CAMERA (77, 1 companions)024680255075Members in the MCoHP parentsNumber of child packages having the co−parentD) 67 Bioconductor packages,where 8 annotation−related parent packages are removed.Hmisc,rms (57)forecast,nnfor (49)FactoMineR,factoextra (53)Hmisc,weights (60)car,lme4 (45)024680255075100MCoHP parentsNumber of child packages having the parent pairE) 143 CRAN packagesHmisc (57, 9 companions)car (57, 11 companions)lme4 (45, 7 companions)forecast (48, 5 companions)rms (59, 3 companions)05101520050100150Members in the MCoHP parentsNumber of child packages having the co−parentF) 143 CRAN packagesA preprint - August 25, 2022

from Bioconductor, methods from AnnotationDbi should also be used for extracting corresponding data.
Therefore, the data packages (e.g., org.Hs.eg.db for human, org.Mm.eg.db for mouse and org.Rn.eg.db for
rat) and AnnotationDbi are normally used together. Similarly, AnnotationHub and ExperimentHub provide
similar functionalities for storing external annotation and experimental data where ExperimentHub inherits
the same set of function interface from AnnotationHub, thus any package depending on ExperimentHub
would also depend on AnnotationHub. The two “hub” packages are becoming standard ways for handling
external data and they are used more and more frequently in the Bioconductor system. Figure 6B shows the
number of child packages of the MCoHP parent packages. Besides the aforementioned three “org.*.eg.db”
packages, AnnotationDbi co-works with in total 18 other packages in Bioconductor and it aﬀects 235 child
packages with mean co-heaviness of 44. There are other examples of heavy MCoHP parents (Figure 6B).
The package GenomicFeatures co-works with 9 other packages where GenomicFeatures provides tools for
manipulating gene/transcript annotations and the companion packages are organism-speciﬁc annotation
packages. The package BSgenome co-works with 30 other packages where BSgenome provides class and
method deﬁnitions for dealing with genome sequences, and the companion packages are also organism-speciﬁc
annotation packages.

As has been demonstrated previously, top packages contributing strong co-heaviness in the Bioconductor
ecosystem are all annotation-related packages. We next explored Bioconductor excluding the eight top
annotation-related packages listed in Figure 6B, and we aimed to study the co-heavines patterns for the
“software packages” in Bioconductor. Figure 6C shows now there is no dominant parent pair contributing
strong co-heaviness, except the pair CAMERA and xcms which are both for mass spectrometry data analysis
and they contribute mean co-heaviness of 77 to their 5 child packages. Figure 6D lists top Bioconductor
software packages as heavy co-parents. Notably, the package Gviz aﬀects 6 child packages as a co-parent
with other 4 comparison packages, and it contributes on average a co-heaviness of 88 which is much higher
than other co-parent packages.

For CRAN packages, there are less package pairs that contribute strong co-heaviness to their child packages.
There is only one parent pair Hmisc and rms that contribute strong co-heaviness on their 9 child packages
with average co-heaviness of 57 (Figure 6E). Also, Hmisc aﬀects 20 child packages as a co-parent with other
9 companion packages (Figure 6F) where Hmisc is a parent package of all its companion packages.

3.3 Heaviness on child and downstream packages

We studied how a package P contributes dependency heaviness to its child and downstream packages by
looking at the average numbers of dependencies solely brought by P. Figure 7A illustrates the distribution of
heaviness on child packages (abbreviated as HC) for packages with at least one child. In general, distributions
of HC have very long tails for packages with small numbers of children, and the distribution tails are shortened
dramatically as the numbers of children increase. This is mainly because when P has more child packages,
the heaviness on child packages may be diluted by their other parents.

From the aspect of R package developers, HC is especially important because it also measures the expected
number of additional dependencies if P is added as a new strong parent of their packages, thus it is important
to list the top packages that contribute high heaviness in the ecosystem. Similarly, we also adjusted the
original HC and we set the adjusted HC ≥ 30 to extract top packages that also broadly aﬀect a large number
of child packages (Figure 7A and Table 1). Not surprisingly, these top packages already inherit large numbers
of dependencies from their parents (the second column in Table 1), and most of these dependencies are
transmitted to their child packages uniquely (the fourth column in Table 1). To list a few, the package lumi
has 162 dependencies from its parents, and on average 114 (70.4%) of them are uniquely contributed to its
child packages; the package RTCGA has 127 dependencies from its parents, and all of them uniquely go
to its child packages. Also as listed in Table 1, there are several packages transmitting large heaviness to
broader sets of child packages, such as the package caret contributing on average 41 additional dependencies
to its 180 child packages, the package car contributing on average 40.6 additional dependencies to its 183
child packages, and the package ggpubr contributing on average 37.0 additional dependencies to its 125 child
packages. These packages play major roles in contributing heavy dependencies to their child packages in the
ecosystem.

Package P may have multiple child packages. We explored the distribution of individual heaviness values
of P on its child packages. In Figure 7B, when packages have high adjusted HC values, i.e., ranked as top
packages aﬀecting their child packages, the Gini indices of the heaviness values get close to 0.25. It indicates
that top heavy packages contribute dependencies almost evenly to their child packages.

12

A preprint - August 25, 2022

Table 1: Top packages with the adjusted HC ≥ 30. Nstrong: number of strong dependencies from parents;
Nchild: number of child packages; HC: heaviness on child packages; Bioc: Bioconductor.

Package

ecospat
RTCGA
lumi
Rcmdr
Deducer

Seurat
taxize
TraMineR
smacof
brms

MESS
minﬁ
survminer

Nstrong Nchild
3
9
13
45
5

232
127
162
135
107

HC Repo

Package

151.0 CRAN GenomicScores
128.0 Bioc
114.2 Bioc
101.2 CRAN drc

AER
WGCNA

94.6 CRAN tidyverse

Nstrong Nchild
26
22
33
17
89

98
92
108
96
107

145
127
100
122
123

84
141
115

38
12
7
8
13

9
38
27

85.3 CRAN devtools
77.4 CRAN Gviz
77.1 CRAN FactoMineR
75.2 CRAN caret
65.1 CRAN car

63.8 CRAN ggpubr
62.4 Bioc
rms
58.2 CRAN fda

76
142
104
81
87

96
78
60

80
37
52
180
183

125
54
78

HC Repo

56.0 Bioc
52.6 CRAN
52.3 CRAN
51.1 CRAN
48.4 CRAN

47.0 CRAN
43.5 Bioc
41.2 CRAN
41.0 CRAN
40.6 CRAN

37.0 CRAN
36.8 CRAN
33.9 CRAN

Table 2: Top packages with adjusted HC ≥ 30 or HID ≥ 20. Additionally the packages listed in the table
have numbers of downstream packages (i.e., numbers of child packages + numbers of indirect downstream
packages) ≥ 30. Nchild: number of child packages; HC: heaviness on child packages; Nid: number of indirect
downstream packages; HID: heaviness on indirect downstream packages.

Package

car
recipes
rstatix
caret
ggpubr

AnnotationHub
rainbow
fds
fda
devtools

tidyverse
FactoMineR
rms
minﬁ
RcmdrMisc

Gviz
Rcmdr
Seurat
survminer
WGCNA

weights

Nchild
183
26
10
180
125

HC Nid HID Is top HC?
31.9
40.6
20.6
9.9
26.0
12.1
28.4
41.0
24.4
37.0

435
227
203
29
80

y
y

y

97
5
2
78
80

89
52
54
38
7

37
45
38
27
33

12

16.7
21.0
37.0
33.9
47.0

48.4
41.2
36.8
62.4
19.3

43.5
101.2
85.3
58.2
52.3

101
125
126
46
15

5
37
30
22
43

9
1
2
9
2

30.6

21

23.4
27.5
29.3
22.7
36.3

38.0
18.5
30.3
35.2
34.6

35.7
81.0
54.0
60.0
24.5

35.4

13

y
y

y
y
y
y

y
y
y
y
y

Is top HID?

y
y
y
y
y

y
y
y
y
y

y
y
y

y

y

y

A preprint - August 25, 2022

Figure 7: Heaviness analysis on child and indirect downstream packages. A) Heaviness on child packages. B)
Gini indices of individual heaviness of child packages. C) Compare top 500 packages with the highest HC,
HD and HID values. In each plot, packages are sorted by two metrics, e.g., HC and HD in the left plot. Top
500 packages by either of the two metrics are highlighted by segments that connect the same packages in the
two sorted lists. At the bottom is a Venn diagram showing the overlap of the top 500 packages from the two
metrics. D) Heaviness on indirect downstream packages. HC: heaviness on child packages; HD: heaviness on
downstream packages; HID: heaviness on indirect downstream packages.

14

AERbrmscarcaretDeducerdevtoolsdrcecospatFactoMineRfdaggpubrMESSRcmdrrmsSeuratsmacofsurvminertaxizetidyverseTraMineRWGCNAGenomicScoresGvizlumiminfiRTCGACRANBioconductor11010010001101001000050100150Number of child packages (in log scale)Heaviness on child packages110100Number ofneighbor pointsHeaviness categoryhighA) Heaviness on child packages0.000.250.500.751.00020406080Adjusted HCGini indexHeaviness categoryhighB) Gini index of heaviness on child packagesC) Compare top packages with the higest HC, HC and HID valuesHCHDtop 500/22076HCHIDtop 500/22076biomod2carcaretdevtoolsEcfunENMevalfdafdsggpubrklaRlogistfpecquestionrrainbowrangeModelMetadataRcmdrMiscrecipesrmsrstatixshinystansurvminersystemfitweightsWikidataRwikitaxaAnnotationHubCNErFlowSOMGvizmethylumiminfiTFBSToolsCRANBioconductor1101001000100001101001000100000306090Number of indirect downstream packages (in log scale)Heaviness on indirect downstream packages110100Number ofneighbor pointsHeaviness categoryhighD) Heaviness on indirect downstream packagesA preprint - August 25, 2022

Figure 8: Three examples of dependency graphs of how packages transmit dependencies to their downstream
packages. A) The package car. B) The package rstatix. C) The package tidyverse. The three packages are
colored in orange in the graphs. In Figure A, to reduce the size of the graph for visualization, leaf nodes
sharing the same parent are grouped and colored in green.

15

ABCA preprint - August 25, 2022

HC is a metric of local relation, i.e., the direct parent-child relation. We next studied how the heaviness is
uniquely transmitted to the downstream of the global dependency graph. We observed that, for top packages
with the highest heaviness on downstream packages (abbreviated as HD), they tend also to have high HC
values. In the left panel of Figure 7C, 478 packages are common in the top 500 packages with the highest
HC values and the top 500 packages with the highest HD values. This implies, for these 478 packages,
the downstream packages are mainly composed of child packages. For this reason, to study the long-range
dependency transmission, we removed child packages from downstream packages, i.e., we only studied the
heaviness on indirect downstream packages (abbreviated as HID). In the right panel of Figure 7C, now there
are only 129 packages common in the top 500 packages from both metrics, and these 129 packages contribute
strong heaviness to both their direct child packages and remote downstream packages.

Similarly, the distributions of HID also have long tails, which indicates only a small fraction of packages
spread large dependencies to the ecosystem in the long ranges. In Figure 7D, we highlighted the packages
with adjusted HID ≥ 20. Compared to Figure 7A, the list of top packages changes. Table 2 lists top packages
with adjusted HC ≥ 30 or HID ≥ 20. To reduce the length of the table, we additionally set the numbers of
downstream packages (i.e., numbers of child packages + numbers of indirect downstream packages) ≥ 30.
In the 21 packages listed in Table 2, they can be summarized into three categories: i) having both top HC
and HID values (9 packages); ii) only having top HID values (7 packages); iii) only having top HC values (5
packages). In the ﬁrst category, packages not only aﬀect their direct child packages but also aﬀect indirect
downstream packages. An example is the package car which directly aﬀects 183 child packages (with HC
of 40.6) and additionally 435 indirect downstream packages (with HID of 31.9, Figure 8A). In the second
category, packages have very few direct child packages, but the child packages play as hub packages and
they transmit the heaviness to a great number of indirect downstream packages. One typical example is the
package rstatix, which only has 10 child packages, but aﬀects 203 indirect downstream packages. Figure 8B
demonstrates the heaviness is mainly transmitted from rstatix via a hub child packaged ggpubr which spreads
the dependency ﬂow to 96.2% of downstream packages of rstatix. In the third category, packages mainly
contribute heaviness only till their child packages and majority of the eﬀects do not go further deep in the
dependency graph, e.g., the package tidyverse (Figure 8C).

CRAN has more top packages ranked by HC or HID than Bioconductor. There are 21 verse 5 top packages
measured by HC, and 25 verse 7 top packages measured by HID. This indicates these top CRAN packages
have more impacts on the ecosystem. It makes sense because Bioconductor packages are speciﬁcally for
biological data analysis while CRAN packages are for more general purposes, thus there are more “hub”
packages in CRAN that play a central role in contributing dependencies.

3.4 Dependency graph analysis

In previous sections, the analysis was focused on diﬀerent heaviness metrics on individual packages. In
this section, we studied the dependency relations from the aspect of the global dependency graph by using
the complex network analysis approach. The following two questions were asked: 1. What are the general
patterns of heaviness spreads in the dependency graph? 2. What are the top packages and key paths that
transmit major dependency heaviness?

Denote the global dependency graph as G(V, E), where V is the set of all packages in the CRAN/Bioconductor
ecosystem and E is the set of the strong dependency relations, then the heaviness from a parent on a child is
a score associated to an edge in the graph. Figure 9A illustrates the distribution of heaviness which can be
approximated as a stretched exponential distribution (Elton, 2018) ﬁtted as

Pr(H = h) = 0.46 · exp(−1.66h0.37)

where H is the random variable of the heaviness. The model implies in the ecosystem, only a small fraction
of parents contribute high heaviness to their child packages. The 95th percentile of all heaviness values is 20.

In the section of “Heaviness on child and downstream packages”, we studied the average heaviness on child
packages and indirect downstream packages. Here we looked at the total heaviness that a package contributes
to the whole ecosystem, i.e., to all its downstream packages. The total heaviness also measures if moving
package P out of the dependency graph, the number of reduced dependencies in the ecosystem. Since this is a
total eﬀect, a package with small HD value may have a large global eﬀect simply because it has a huge number
of downstream packages. For example, the package stringr only has a small HD of 2.3, but it aﬀects 5,276
downstream packages, which makes it a top package contributing dependencies in the ecosystem. Therefore,
we only looked at packages with HD ≥ 10 (1,247 packages left). Figure 9B illustrates ggplot2 is the most

16

A preprint - August 25, 2022

Figure 9: Heaviness analysis on the global dependency graph. A) Distribution of heaviness from a parent on
a child package. The line is the ﬁt from a stretched exponential distribution (R2 = 0.952). B) Total heaviness
on downstream packages for the packages with HD ≥ 10. Packages in red have total heaviness ≥ 5,000.
Values in the parentheses are the numbers of downstream packages. C) MHP distribution at each depth in
the dependency graph. D) Number of packages at each depth. In Figure C and D, packages with depth = 0
(709 packages) and depth ≥ 11 (1 package) are removed for the plot. HD: heaviness on downstream packages;
MHP: max heaviness from parents.

17

1e−051e−040.0010.010.10.5010100200Heaviness from a parent on a child package (in h0.37 scale)Pr(H = h) (in log scale)A) Heaviness distributionAnnotationDbi(1444)AnnotationHub(198)biomaRt(484)BSgenome(409)GenomicFeatures(406)rtracklayer(691)car(618)caret(209)fields(277)ggplot2(5622)ggpubr(205)Hmisc(631)lme4(1036)nloptr(1156)pbkrtest(643)plotly(407)recipes(253)rstatix(213)shiny(1305)testthat(1434)0200004000060000800001030100Heaviness on downstream packages (in log scale)Total heaviness on downstream packagesB) 1247 packages with HD >= 1005010015020012345678910DepthMax heaviness from parentsC) Distribution of MHP at each depth02000400012345678910DepthNumber of packagesD) Number of packages at each depthA preprint - August 25, 2022

Figure 10: Analysis on the core dependency graph. A) The network visualization of the core graph. Node
size is mapped to out-degree. Edge width is mapped to betweenness and edges with betweenness ≥ 20 are
highlighted in red. B) Distribution of graph component sizes. The line is the ﬁt of the power-law distribution
(R2 = 0.845). The largest ﬁve data points are removed for the ﬁtting. C) The subgraph that only contains
high betweenness edges from Figure A. Node size is mapped to the out-degree calculated from the core graph.
D) Distribution of distances to leaf packages in the core graph.

18

A) The core dependency graph0.010.10.5101001000Graph components size (X)Pr(X = x)B) Distribution of graph component sizesC) Sub−graph with edge betweenness >= 20361211425831513412601000200030001234567Distance to the leaf packagesCountD) Distribution of distance to leaf packagesA preprint - August 25, 2022

inﬂuential package that aﬀects 5,622 downstream packages with a HD value of 14.7, and it contributes in total
82,830 unique dependency relations to the ecosystem. Another example is the package car which aﬀects 618
downstream packages but with a higher HD value of 35.6, contributing in total 20,001 unique dependencies.
All of the top 20 packages (ﬁltered by total heaviness on downstream ≥ 5,000) listed in Figure 9B aﬀect a
large number of downstream packages, with an average number of 882. The top 20 packages (0.1% of all
packages) contribute 18.9% unique dependencies to the whole ecosystem.

Dependency heaviness from a parent on a child is a local eﬀect and we observed such heaviness is accumulated
from the remote upstream of the dependency graph. For each package, we calculated its depth in the graph
as the maximal distance to all other packages where the distance between two package nodes is the length of
shortest path in the directed graph. Figure 9C illustrates the distribution of MHP and Figure 9D illustrates
the number of packages at each depth. It shows clearly, when a package locates more downstream in the
graph, it inherits larger dependency heaviness from its parent.

To study how the dependency heaviness is transmitted in the global graph, we constructed a core graph
where heaviness from a parent on a child is ≥ 30. The core graph has 4,302 packages (19.5%) and 3,950
strong dependency relations (3.2%). It includes 44.2% heaviness ﬂows of the complete graph (measured as the
fraction of total heaviness in the core graph and in the global graph). As mentioned previously, the heaviness
from a parent on a child is a local metric; however, a validation analysis demonstrated that in the core graph,
if a package A is an upstream package of package B, it always ensures A contributes a heaviness ≥ 30 on B.

The core graph is visualized in Figure 10A. There are several hub packages that transmit large heaviness to
their direct child packages, mapped by node sizes which are proportional to the out-degrees of the packages
in the core graph. Labels of hub packages with out-degree ≥ 30 are added to Figure 10A and the top two
packages are ggplot2 and AnnotationDbi which contribute heavy dependencies to their 442 and 273 child
packages directly. We also observed there are a huge number of isolated and small graph components where
heaviness is only transmitted locally. Out of the total 379 graph components, 352 components only have size ≤
10; however, the other 27 components include 77.0% of packages in the core graph and the largest component
includes 2,082 packages (48.4% of all packages in the core graph). The size of the graph components can be
approximated as from a power-law distribution (Figure 10B).

The betweenness of an edge measures the number of shortest paths in the graph that pass through the
edge. Under the context of the dependency graph, the edge betweenness measures the heaviness ﬂows. In
Figure 10A, edges with betweenness ≥ 20 are highlighted in red and a subgraph that only contains these high
betweenness edges is induced in Figure 10C. We named them “the core dependency paths” and they transmit
25.2% of the total heaviness ﬂows (measured as the fraction of total betweenness in the core paths and in
the core graph) while only including 0.8% edges and 1.0% packages from the core graph. In most cases, in
the core paths the heaviness is transmitted between hub packages with top out-degrees; however there are
exceptions such as rstatix which behaves as a bridge that connects two hub packages car and ggpubr, or
viridis as a bridge connecting ggplot2 and ﬁelds, to continue the dependency transmission (Figure 10C). We
also found there are long paths such as from testthat to MBESS with length of 6, and from car to diﬀcyt or
RTCGA with length of 5, where the heavy dependencies can be continually transmitted through.

Last we studied how deep a package can transmit the heavy dependencies in the core graph. Figure 10D
illustrates the distribution of dependency transmission length measured as the maximal distance of a package
to leaf packages (out-degree = 0) in the graph. It shows the majority of the transmission only has a length of
1, which can be easily conﬁrmed by Figure 10A. But there also exist long paths where heavy dependencies
can be continually transmitted (examples in Figure 10C).

3.5 The web-based database

We have integrated the dependency heaviness analysis for the CRAN/Bioconductor ecosystem in the package
pkgndep (https://CRAN.R-project.org/package=pkgndep), which provides detailed analysis reports for
the dependencies from direct parent-child relations and remote upstream-downstream relations. The results
are represented as a web-based database illustrated in Figure 11. It can be simply accessed with the function
pkgndep::dependency_website().

Figure 11A illustrates the global table of the heaviness analysis of all packages where columns are separated
into two groups highlighted in yellow and blue, which correspond to metrics from upstream (e.g., MHP)
and on downstream packages (e.g., HC, HD and HID). In the table, packages with adjusted HC ≥ 30 are
highlighted in red. If a package only imports a limited number of functions from the heaviest parent, the
package is marked as ‘reducible’ in purple, which implies possibility to optimize its upstream dependencies

19

A preprint - August 25, 2022

Figure 11: Web-based database of dependency heaviness analysis for all R packages in CRAN/Bioconductor.
A) The global heaviness table of all packages. B) Upstream packages of a package. Dependency paths from
all upsteam packages are listed as a table and visualized as a graph. C) Downstream packages of a package.
Users can select the range of depths of the dependency relations. D) A graph of the downstream dependency
graph. Green nodes represent groups of leaf packages that connect to the same parent package. Edges with
high betweenness are highlighted in red. The cutoﬀ of betweenness is selected as the ‘elbow’ of the curve of
sorted betweenness of all edges in the graph.

20

ABDCA preprint - August 25, 2022

(see our suggestions in (Gu and Hübschmann 2022)). The global heaviness table is by default ordered by
adjusted HC, which is a more important metric because it reﬂects the expected number of additional required
packages if the package is included as a new parent of a package.

The database contains detailed dependency heaviness analysis for individual packages. The web page for an
individual package includes basic statistics of the package, as well as the dependency heatmap which visualizes
the parent-child relations. Additionally, it includes detailed information for the parent and child dependencies,
as well as for the upstream and downstream dependencies. In the parent and child dependency results, there
are tables showing heaviness-related metrics. It also lists the “Imports” information (i.e., how the classes and
methods are imported from parent packages) which is automatically parsed from the NAMESPACE ﬁles
of corresponding packages. In the upstream dependency results, the dependency path for each upstream
package to the package is listed, which is the shortest path from the upstream package to the package in the
global dependency graph (Figure 11B). There is also an interactive graph of upstream packages (heaviness
> 5) that shows how the heaviness is accumulated (Figure 11B). Similarly, in the downstream dependency
results, the dependency path from the package to every downstream package is listed, which can be further
ﬁltered by the depth to the downstream packages (Figure 11C). The downstream dependency graph is also
visualized as an interactive graph (Figure 11D). Normally, the downstream dependency graph is larger than
the upstream dependency graph. When the downstream dependency graph is large, leaf packages are grouped
if they have the same parent to reduce the graph size for visualization (Figure 11D). Additionally, edges with
high betweenness in the downstream dependency graph are highlighted in red, which correspond to the key
paths that majorly transmit the dependency heaviness.

4 Discussion

Dependency is an important topic for studying software ecosystems with large complexities. Current
studies applied complex network analysis approaches to the R package dependency graph assuming edges
as unweighted. In this study, we analyzed R package dependencies from a diﬀerent aspect. We applied a
new metric named “dependency heaviness” which measures the number of unique additional dependencies a
parent contributes to a child or downstream packages, which actually answers the question: which parents are
heavier for the contribution of dependencies? In practice, this metric is also useful because it quantitatively
measures the number of reduced dependencies if changing the role of a parent from strong to weak. In this
study, we systematically explored how dependency heaviness transmits in the ecosystem both locally and
remotely. We also performed complex network analysis by taking the heaviness as the edge weight of the
global dependency graph, and we extracted top packages and key paths that majorly transmit dependencies
in the ecosystem. Our study can generate diﬀerent results from current published studies. For example, the
package Rcpp has 2,795 child packages (It is the package with the third most child packages in the ecosystem)
but it only has a HC value of 0.58. It was treated as a hub package in current studies (Mora-Cantallops,
Sánchez-Alonso, and García-Barriocanal 2020), but in the context of dependency heaviness, it is an extremely
light package in the ecosystem. Thus, our dependency heaviness analysis can provide new insights on studying
the ecosystem.

We studied the dependency heaviness inherited from the parent packages. We found Bioconductor packages
suﬀer heavier parents than CRAN packages. The reason might be that Bioconductor packages are mainly for
biological data analysis and they integrate various analyses and annotation resources from upstream packages
(average numbers of parents are 8.4 and 5.1 for Bioconductor and CRAN), thus heaviness might be easier
to be accumulated from upstream which results in heavy dependencies (average MHP values are 24.6 and
13.3 for Bioconductor and CRAN). For example, the package miRspongeR listed as a top package in Figure
4A has an upstream package SPONGE which integrates analysis from a list of heavy parents (tidyverse
for data processing, ggpubr for visualization, biomaRt for obtaining biological annotation data, caret for
statistical modeling). We also studied the co-heaviness from two parents, which measures the number of
unique dependencies simultaneously brought by two parent packages. We revealed that in the ecosystem,
AnnotationDbi contributes to the major co-heaviness together with its companion Bioconductor annotation
packages. We found, for parent pairs that contribute high co-heaviness, in most cases one package in the pair
is the parent of the other package, which results in that the dependencies brought by the two parents are
similar.

We studied the dependency heaviness transmitted to child and downstream packages. Top packages in
this category are especially important for developers in practice, because they would dramatically increase
dependencies if they are added as new parents of developers’ packages. Expectedly, many of the top packages
listed in Table 1 are popular and widely applied in various ﬁelds such as general statistical modeling (car,

21

A preprint - August 25, 2022

caret, fda, rms and FactoMineR), speciﬁc analysis approaches on biological data (WGCNA and Seurat), data
visualization (ggpubr, Gviz and survminer) and infrastructure-related applications (devtools and tidyverse),
thus they are used by a great number of child packages. We also studied the long-range heaviness transmission
on downstream packages, and we revealed three diﬀerent modes in the ecosystem: i) Dependency heaviness is
broadly transmitted to both direct child packages and remote downstream packages; ii) Dependency heaviness
is transmitted to remote downstream via hub child packages; iii) Dependency heaviness is mainly transmitted
locally where their child packages are the ends of the dependency transmission.

We applied the complex network analysis approach to the dependency graph by taking heaviness as the
weight of edges. We found the distribution of heaviness from a parent on a child package approximately
follows a stretched exponential distribution, which implies only a small fraction of parents contributes high
dependency heaviness to their child packages in the ecosystem. We then constructed a core graph which only
includes heavy dependencies between parent and child packages, also between upstream and downstream
packages. We found in the core graph, many dependency relations are isolated, which implies these heaviness
relations are local. Nevertheless, there are also huge graph components that connect to a large number of
packages. We extracted the key paths in the core graph that transmit the major heaviness in the ecosystem.
We also found, in the core graph, the heavy dependency transmission is mainly local that it is only till the
child packages, but there are also a few of them transmitting the heaviness in long ranges.

In this study, we analyzed R packages on CRAN and Bioconductor repositories. There are also a great number
of R packages hosted only on GitHub and it would be more comprehensive to include these packages into the
analysis. However, GitHub R packages are more like self-maintained and there is no central management
system for all R packages listed on GitHub, thus it is diﬃcult to obtain the full list of them. What’s more, R
packages on GitHub are in general experimental and are expected to be less used by the community.

We have implemented the complete analysis as a web-based database that can be easily accessed from the
pkgndep package. The database provides detailed statistics for various heaviness metrics both for upstream
packages and downstream packages. It also provides comprehensive dependency analysis for individual
packages. Additionally, it provides network analysis and interactive visualizations for a package’s upstream
packages and downstream packages, which helps to understand how the dependency heaviness transmits in
the global dependency graph. The database is planned to be updated at least twice per year (shortly after
each Bioconductor release).

5 Conclusion

We performed a systematic analysis on the dependency heaviness landscape of the R package ecosystem.
We revealed the general patterns of the dependency transmission from parent to child packages, also from
upstream to downstream packages in the long range. Using network analysis approaches, we revealed top
packages and key paths that play signiﬁcant roles in transmitting dependencies in the ecosystem. The
complete analysis has been implemented as a web-based database and we believe it will facilitate researchers
as well as R package developers to better understand the R package ecosystem and to build more robust
software.

References

Decan, Alexandre, Tom Mens, and Maelick Claes. 2016. “On the Topology of Package Dependency Networks:
A Comparison of Three Programming Language Ecosystems.” In Proccedings of the 10th European
Conference on Software Architecture Workshops. ECSAW ’16. New York, NY, USA: Association for
Computing Machinery. https://doi.org/10.1145/2993412.3003382.

Decan, Alexandre, Tom Mens, Maëlick Claes, and Philippe Grosjean. 2016. “When GitHub Meets CRAN: An
Analysis of Inter-Repository Package Dependency Problems.” In 2016 IEEE 23rd International Conference
on Software Analysis, Evolution, and Reengineering (SANER), 1:493–504. https://doi.org/10.1109/
SANER.2016.12.

Grolemund, Garrett, and Hadley Wickham. 2016. R for Data Science. Sebastopol, CA: O’Reilly Media, Inc.
Gu, Zuguang, and Daniel Hübschmann. 2022. “Pkgndep: a tool for analyzing dependency heaviness of R

packages.” Bioinformatics, July. https://doi.org/10.1093/bioinformatics/btac449.

Hornik, Kurt, Uwe Ligges, and Achim Zeileis. 2021. “Changes on CRAN 2021-07-01 to 2021-12-31.” The R

Journal 13 (2).

22

A preprint - August 25, 2022

Huber, Wolfgang, Vincent J. Carey, Robert Gentleman, Simon Anders, Marc Carlson, Benilton S. Carvalho,
Hector Corrada Bravo, et al. 2015. “Orchestrating High-Throughput Genomic Analysis with Bioconductor.”
Nature Methods 12 (2): 115–21. https://doi.org/10.1038/nmeth.3252.

Korkmaz, Gizem, Claire Kelling, Carol Robbins, and Sallie Keller. 2019. “Modeling the Impact of Python
and r Packages Using Dependency and Contributor Networks.” Social Network Analysis and Mining 10
(1): 7. https://doi.org/10.1007/s13278-019-0619-1.

Mora-Cantallops, Marçal, Salvador Sánchez-Alonso, and Elena García-Barriocanal. 2020. “A Complex
Network Analysis of the Comprehensive r Archive Network (CRAN) Package Ecosystem.” Journal of
Systems and Software 170: 110744. https://doi.org/https://doi.org/10.1016/j.jss.2020.110744.
Venables, W. N., and B. D. Ripley. 2002. Modern Applied Statistics with s. New York: Springer New York,

NY.

Vidoni, Melina. 2021. “Software Engineering and R Programming: A Call for Research.” The R Journal 13

(2): 6–14. https://doi.org/10.32614/RJ-2021-108.

Wickham, Hadley. 2021. Mastering Shiny: Build Interactive Apps, Reports, and Dashboards Powered by r.

Sebastopol, CA: O’Reilly Media, Inc.

Wilke, Claus O. 2019. Fundamentals of Data Visualization. Sebastopol, CA: O’Reilly Media, Inc.
Xie, Yihui. 2015. Dynamic Documents with r and Knitr. Boca Raton, Florida: Chapman; Hall/CRC.

References

23

