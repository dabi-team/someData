PR-SZZ: How pull requests can support the tracing
of defects in software repositories

Peter Bludau
fortiss GmbH - Research Institute of
the Free State of Bavaria
Munich, Germany
bludau@fortiss.org

Alexander Pretschner
Technical University of Munich
Munich, Germany
alexander.pretschner@tum.de

2
2
0
2

n
u
J

0
2

]
E
S
.
s
c
[

1
v
7
6
9
9
0
.
6
0
2
2
:
v
i
X
r
a

Abstract—The SZZ algorithm represents a standard way to
identify bug ﬁxing commits as well as inducing counterparts. It
forms the basis for data sets used in numerous empirical studies.
Since its creation, multiple extensions have been proposed to
enhance its performance. For historical reasons, related work
relies on commit messages to map bug tickets to possibly related
code with no additional data used to trace inducing commits
from these ﬁxes. Therefore, we present an updated version of
SZZ utilizing pull requests, which are widely adopted today. We
evaluate our approach in comparison to existing SZZ variants by
conducting experiments and analyzing the usage of pull requests,
inner commits, and merge strategies. We base our results on 6
open-source projects with more than 50k commits and 35k pull
requests. With respect to bug ﬁxing commits, on average 18%
of bug tickets can be additionally mapped to a ﬁxing commit,
resulting in an overall F-score of 0.75, an improvement of 40
percentage points. By selecting an inducing commit, we manage
to reduce the false-positives and increase precision by on average
16 percentage points in comparison to existing approaches.

Index Terms—SZZ, defect data set, bug ﬁxing changes, bug

inducing changes, mining software repositories

I. INTRODUCTION

Bug introducing changes in software repositories are an
important asset to empirical software engineering research.
Many studies rely on defect data sets to either analyze defects
and investigate the characteristics of bug inducing activities
[1]–[3] or evaluate defect prediction approaches [4]–[6]. The
standard algorithm used to extract information about bug ﬁxing
and inducing commits from the version control system (VCS)
is called SZZ, proposed by ´Sliwersky, Zimmermann and Zeller
[7] in 2005. The algorithm can be described as a two-step
process. The ﬁrst part maps commits from the version control
system to resolved tickets from an issue tracking system (ITS).
Commits that contain speciﬁc information about resolved bug
labeled tickets are identiﬁed as ”bug ﬁxing commits”. The
second part searches for changes that potentially introduced
the bug. The algorithm ﬁnds modiﬁed lines for the ﬁxing
commits and traces them in the VCS history to reveal a version
that last changed these lines. This reveals the ”bug inducing
commits”. Especially, the second part of the algorithm was
subject to many studies [8]–[13] to cope with inaccuracies
of the original version. These studies propose additions to
the tracing of inducing commits by ﬁltering false-positives
(commits that are falsely labeled bug inducing). As shown in
existing studies, there are still open issues regarding mapping

a bug ticket to a ﬁxing commit (e.g., [14]–[16]) and ﬁnding
the correct inducing commits (e.g., [11], [17], [18]).

The ﬁrst part of the algorithm relies on matching a commit
to a bug ticket and thereby reveals the bug ﬁxing commit.
Multiple problems may arise in this process. Due to commits
that do not mention the related issue number or do not
have well-deﬁned commit messages some bug ﬁxing commits
cannot be mapped to their respective bug ticket. These are
missing in the resulting data set which may lead to highly
imbalanced bug data sets containing a fraction of all bug
ﬁxing commits (false-negatives). Moreover, commits can be
wrongly selected as bug ﬁxing commits for a bug ticket (false-
positives). Among other circumstances, this is caused by links
between bug tickets and commits that are wrongly inferred by
the algorithm due to incorrect commit message parsing. This
has also an impact on the second step of the algorithm since
wrong bug ﬁxing commits are used to trace inducing commits.
With already proposed enhancements to the second part of
the algorithm, some open issues remain. Bug ﬁxes that only
add new code, for instance adding a missing null-check to ﬁx a
null pointer exception, are not found by the algorithm because
they cannot be blamed onto existing changes. If this code is
added together with other changes in a commit, correct but
unrelated code is possibly labeled as bug inducing. Moreover,
since large ﬁx commits are potentially reporting many induc-
ing commits, they also tend to introduce many false-positives
[11]. With too many commits blamed as bug inducing for
such large ﬁxing commits and on average 43% of defective
commits being indeed only partially defective (containing not
only defective ﬁles) [6], results of SZZ may be too coarse.
To the best of our knowledge existing SZZ variants propose
additions to reduce false-positive bug inducing commits, but
use the same information from VCS history and issue tracking
systems proposed more than 15 years ago to ﬁnd ﬁxing and
inducing changes for a certain bug ticket on the commit level.
This study is meant to address aforementioned issues by
proposing an extension to existing SZZ variants utilizing
additional data from open-source development. In modern
software development, integrated information is available that
more thoroughly describes the relationships between existing
code, bug tickets, and contributed changes. For instance, on
code management platforms (CMP), e.g., GitHub, developers
can propose changes in a pull-based development workﬂow

 
 
 
 
 
 
[19] that incorporates reviews and discussions regarding new
and changed code. Thereby, actions taken to ﬁx a bug are
collected in pull requests. Such pull requests are already used
as sources for additional bug reports and patches [20]–[22].
However, we are not aware of any existing research that
uses data from pull requests and inner feature development
to support the SZZ algorithm in a systematic way to retrieve
additional ﬁxing and more ﬁne-grained inducing commits.
Like the original algorithm, our work can be divided into two
parts. First, we extract links between pull requests, ITS tickets
and commits from various platforms to ﬁnd ﬁxing commits
even when the issue is not directly referenced in the commit.
Secondly, to ﬁnd inducing commits our approach analyses the
development activities inside a pull request to ﬁlter unrelated
changes and propose more ﬁne-grained results. We conclude
our work by creating data sets not only on commit, but also
on ﬁle and method level, since data sets on a commit level
can be too coarse to ﬁlter partially inducing commits.
Our contributions can be summarized as follows:
• We design a new version of the SZZ algorithm that
relies on the usage of pull requests and associated data.
Thereby, we aim at ﬁnding more correct bug ﬁxing
commits from the bug tickets, as well as, retrieving more
correct sets of bug inducing commits.

• We contribute to both parts of the algorithm. Searching
for ﬁxing commits, our approach increases the number of
found ﬁxes while obtaining high performance values on
a manually validated data set. Tracing inducing commits
using our approach, the precision is increased for all
investigated projects.

• We publish defect data sets containing bug ﬁxing and
inducing commits for 6 well-known open-source projects
on commit, ﬁle, and method level
to enable further
research.

II. BACKGROUND

In the ﬁrst part of this section, we describe the inner
functioning of the original SZZ approach as well as summarize
the adjustments and improvements already proposed by other
studies. Our approach is based on the incorporation of data
generated in open-source development workﬂows. Therefore,
we discuss modern software development activities and pro-
cesses in the second part.

A. The SZZ Algorithm

To refer to each of the following presented variants of the
SZZ algorithm we use the short notation introduced by Costa
et al. [11] and extended by Rosa et al. [23]. Table I shows the
SZZ variants proposed in existing literature.

The original SZZ algorithm (B-SZZ) [7] uses an ITS, e.g.,
Jira, and a VCS, e.g., git, to ﬁnd bug ﬁxing and inducing
commits in the commit history. B-SZZ works in two phases
with the ﬁrst part searching the ﬁx commit for a given bug
ticket. Each bug ticket from the ITS is collected. Matching
ﬁxing commits are searched by applying two conﬁdence
checks to the commits. The ﬁrst check veriﬁes the syntactic

Table I
PROPOSED VARIANTS OF THE SZZ ALGORITHM IN LITERATURE.

Variant
B-SZZ
AG-SZZ
DJ-SZZ
L-SZZ & R-SZZ
MA-SZZ
A-SZZ
RA-SZZ

Authors
Sliwersky et al. [7] in 2005
Kim et al. [8] in 2006
Williams and Spacco [9] in 2008
Davies et al. [10] in 2014
Da Costa et. al. [11] in 2017
Sahal and Tosun. [24] in 2018
Neto et. al. [12], [13] in 2018, 2019

conformity. Parsing the commit message it looks for a link
to a bug number and/or keyword (e.g., ’ﬁx’). The second
check veriﬁes the semantic association by comparing char-
acteristics of the syntactically linked bug ticket and commit.
For example, the description of the bug should be contained in
the commit message or the assignee to the bug ticket should
also be the one that authored the commit. Depending on the
number of met criteria, a commit is either discarded or added
to potentially ﬁxing commits. The newest potentially ﬁxing
commit is selected as the ﬁxing commit. In the second part,
B-SZZ traces bug inducing commits. The algorithm computes
the differences for each ﬁxing commit compared to its direct
parent. Thus,
the lines changed in the ﬁxing commit are
obtained. The last commit from the VCS history that changed
said lines is retrieved by using the VCS annotate feature.
All found commits form the list of bug-inducing suspects. To
reduce false-positives, the algorithm rejects changes that are
commited to the VCS after the bug ticket was created.

The variants of B-SZZ shown in Table I do focus on
improving the second part of the algorithm. Kim et al. [8]
found that cosmetic changes to the code can have an effect
on found bug inducing commits. The proposed AG-SZZ uses
the annotation graph of the VCS to trace changes in the
version history while ignoring changes to comments and white
spaces. They further propose to discard changes to code style
and formatting and remove outlier ﬁx revisions, commits that
change disproportionately many ﬁles,
to reduce the false-
positive rate. Willams and Spacco [9] pointed out that the
results of the annotation graph described by Kim et al. [8] can
be imprecise considering large change hunks in a ﬁle. They
propose DJ-SZZ, a line-number mapping approach, to track
each uniquely changed line across the revisions in the VCS
history. In addition, they extend the notion that non-semantic
changes should be neglected by the algorithm. They use DiffJ
[25] to ignore changes to lines containing comments, imports,
or method signatures. As stated by Da Costa et al. [11],
ﬁltering meta-changes – changes that are not related to source
code and cannot introduce bugs – results in more accurate
bug inducing commits. Their version, denoted as MA-SZZ,
discards git meta changes, for instance merge commits and
ﬁle meta changes, such as ﬁle property or permission updates.
Lines that are only added to a commit without an associated
removed line cannot be tracked by SZZ because there is
no line in the VCS history responsible for its introduction.

Sahal and Tosun [24] describe another variation that takes the
surrounding code block into account. They trace the changes
for all lines from the code block with an addition to ﬁnd
potentially inducing commits. Neto et al. [12], [13] introduced
a refactoring aware version of the SZZ algorithm (RA-SZZ).
They propose to restrict changed lines from the ﬁxing commits
by ignoring changes that are ﬂagged as refactorings. First, they
apply the tool RefDiff [26] to ﬁlter refactorings in Java code.
Later, they enhance their previous results by replacing RefDiff
with RefactoringMiner [27].

Since SZZ versions select multiple commits as bug in-
ducing, Davies et al. [10] proposed two adjusted selection
mechanisms to reduce the number of bug inducing suspects.
Their ﬁrst mechanism, L-SZZ, considers only the largest
commit among all suspected commits as bug inducing. The
second one (R-SZZ) selects the most recent commit from the
list of suspects as the defective commit.

B. Collaborative Software Development

In order to support collaborative software development,
pull-based development [19] is well established. It promotes a
synchronisation mechanisms to incorporate change proposals
from a developer into a central code repository by asking for
permission to pull changes into it. Typically, a pull request
is created for a single feature development or bug ﬁx and
therefore is valid in its own context. It includes all information
that is needed to discuss, review and resolve the proposed
changes. The decision if a pull request is either accepted or
rejected is taken by the core developers of a repository [28].
They resolve due discussions and assign reviewers to respec-
tive pull requests. The available information on code changes
paired with the remarks expressed by contributors, reviewers
and core developers represents a valuable asset to research on
the code integration process. When a pull request is accepted,
different projects use various merge strategies to integrate the
changes [29]. For instance, changes can be merged creating
integrates two development strands
a merge commit
into one, without changing the actual development history.
Contrary, they can also be rebased, rewriting the VCS history
and generating new commits. Squashing pull request when
integrating changes is a common technique to reduce the
number of commits created in a pull request to the VCS.
However, information about development activities is lost in
the process.

that

III. A PULL REQUEST AWARE SZZ VARIANT

Unlike existing variants of the SZZ algorithm which solely
rely on data from VCS and issue management systems, our
approach utilizes additional information about the software
development workﬂow of a project. Information contained in
pull requests is utilized to propose additions to both steps
of the algorithm adding new labeling, ﬁltering and selection
mechanisms. The general premise and structure of SZZ is
not changed. The remainder of this section is composed as
follows. We ﬁrst describe the data used by our approach,
its characteristics and how it is processed to extract needed

information. Thereafter, we describe the improvements, ﬁrst
for ﬁnding a ﬁxing commit and second for tracing the inducing
commit for a bug ticket.

A. Reconstructing pull-based development data

Data from pull-based development

includes information
about purpose, approach and resolution of a feature. In the
best case scenario each pull request concerns a single feature
regardless of whether it is an enhancement, evolution or an
attempt to ﬁx a bug. In this study, only accepted pull requests
are considered, as only those related changes were merged
and can ﬁx and induce bugs. Each pull request consists of
a title, a description, referenced commits, and collaborative
data such as comments and code reviews. Dependent on the
merge strategy, the commits related to a pull request may
not be present in the VCS history even if the pull request
is accepted. For instance, when a pull request is accepted
and integrated by rebasing the commits, new commits are
generated with new hashes. When a pull request is squashed at
merge, a single new commit is created incorporating all change
information. However, the meta-information (e.g., timestamps,
portions of change) and progression of the original commits
are shadowed. We denote commits referenced in pull requests
as inner commits. We reconstruct the merge strategy from
available data and assign inner commits to its VCS equivalents.
In case of squashed or re-based pull requests, we restore the
relationship of inner commits to VCS commits by comparing
hashes and commit messages. For squashed pull requests, we
extract a list of inner commits mapped to one VCS commit,
while otherwise maintaining a one-to-one mapping between
commits. Furthermore, for each pull request the last commit
before, ﬁrst commit after and the resolving commit (the
commit with which the pull request is accepted) is obtained.
The processed and reconstructed data is used in both steps of
the pull request aware SZZ (PR-SZZ) implementation.

B. Handling duplicate bug information

Our approach considers bug tickets from multiple ITS as
well as pull requests that can contain bug information by
describing problem and resolution in one place. Moreover,
projects may use multiple ITS. In order to determine if an
issue describes a bug, we ﬁrst check the issue label provided
by the systems. Only if an issue ticket contains a bug label and
is already marked resolved, it is considered in this study. In
accordance with existing work, we assume that all bug labeled
items from the CMP and ITS are valid.

The same bug can then be reported in multiple systems
with different identiﬁers. We automatically join bug tickets
recorded in several systems that describe the same issue and
reduce the chance of confusing identiﬁers of separate systems.
We analyze links between bug tickets and combine all affected
instances into one by considering all separate identiﬁers to
point to the same problem. We argue that this might also
improve existing approaches by providing additional
issue
references for combined duplicate bugs.

(a) Previous process

(b) Pull requests based approach

Figure 1. Schematic representation for searching ﬁxing commits. Commits in
the VCS are shown as circles and denoted with a lowercase c, inner commits
of pull requests are shown as triangles. Tickets from the ITS are depicted as
squares.

C. Matching Bug Fixing Commits

Existing approaches rely on linking commit message and
ticket identiﬁer to match ﬁxing commits to bug tickets. This
requires a well-formed and strict policy to mention issue
identiﬁers in a certain way so that parsing the issue reference
can succeed. However, the applied contribution guidelines and
commit message structures may vary from project to project.
Thus, the quality depends on the investigated project and the
compliance to standards when committing changes.

We describe the steps to apply implicitly available data
from pull requests to support the ﬁrst step of SZZ. Since pull
requests are used to incorporate changes into an existing code
base, they often include information about resolved issues. So
far, bug ﬁxing commits are retrieved by mapping commits and
bug tickets as depicted in Figure 1a. The mappings rely solely
on message parsing and can only ﬁnd directly mentioned
commits (c2). If such references are not present, no ticket
can be mapped to the ﬁxing commit. Instead, bug tickets
are often linked to pull requests as they are more closely
related in the workﬂow. Pull requests contain all performed
development activities to ﬁx a problem, and the ﬁxing commit
can be retrieved from the inner pull request commits (c4), as
abstracted in Figure 1b. Applying additional data from pull
requests, a ﬁxing pull request can be assigned to the issue. The
commit contained in said pull request can be linked directly
to the correct ﬁx commit from the VCS history.

Our approach starts with extracting all links between pull
requests and issue tickets. Links generated by the domain
model of the ITS and CMP are leveraged to get secured links
between the systems. In general, we extract three kinds of
integrated links. First, we utilize the integrated link-section of
the ITS ticket view to extract mentions of related items. For
instance, in Jira those links are called ”Issue Links”, in GitHub
they are referred to as ”Linked pull requests” or ”Linked is-
sues”. The elements linked here contain a short description and

hyperlink to the referenced information. Secondly, we retrieve
links created by the platforms based on user interaction and
bot integration. For example, if a GitHub issue is mentioned
on a different issue or pull request, the platform creates a
mention in the original issue. Last, we collect automatically
generated links provided by the platforms if a speciﬁc syntactic
structure is applied in a text. To illustrate, typing a # followed
by a number in GitHub creates a reference to the issue with the
speciﬁed number. Apart from these integrated cross-references,
we extract links from the title, description, comments, and
reviews that mention other pull requests or issues. A regular
expression is applied to obtain these supplementary links from
text. To cope with different ITS, adjusted expressions are
crafted for the different systems and applied accordingly. For
GitHub, we use an expression according to the issue linking
syntax described above.1 In line with results from Herbold et
al. [16], for Jira bug tickets the project identiﬁer as well as
the issue identiﬁer (e.g., KAFKA-91762) is used.3

Using the extracted links, a directed graph can be created
mapping related elements form the various systems. Subse-
quently, we analyze transitive relations and add inferred edges
to the mapping.

Searching for ﬁxing commits, PR-SZZ processes all re-
ported bugs and checks if a link to any pull request is present in
the constructed mapping. If exactly one pull request is mapped,
it is directly considered as the ﬁxing pull request. If more than
one pull request is linked to a bug, we apply a syntactic and
semantic check to retrieve the correct ﬁxing pull request. We
use a conﬁdence level approach similar to the original study
[7]. We start with a conﬁdence level of 0 and increment it every
time a condition is met. To check the syntactic validity a link
analysis is performed where the conﬁdence level is increased
if the pull request has a link to the issue and if the issue has
a reference to the pull request. When applying the semantic
checks we evaluate if the assignee of the pull request matches
the assignee of the issue and if the creation and closing of
the pull request is closest to respective issue events. The pull
request with the highest conﬁdence is selected as the most
probable option to ﬁx the bug. If no pull request for a given
bug ticket is found, we use the approach from the original
paper [7] to map commits directly to the bug ticket using the
same adjusted regular expressions described above.

Multiple commits can be suspects to ﬁxing a bug, either by
selecting a pull request with multiple commits or by mapping
multiple commits through commit message parsing. If more
than one commit of the VCS is mapped, we apply a second set
of conditions to obtain the correct ﬁxing commit. Therefore,
PR-SZZ applies similar conditions as proposed in the original
SZZ on all suspect commits. The selected commit is marked
as the ﬁxing commit for the investigated bug ticket. A data
set of bug tickets with their corresponding ﬁxing commit is
created and leveraged in the second step of the algorithm.

1 ((close[s|d]?|ﬁx[es|ed]?|resolve[s|d]?)+[\s|:]*\#number\D)|(\(\#number\)\D)
2 https://issues.apache.org/jira/browse/KAFKA-9176
3 [\s|:|\[|\(]*(identiﬁer-number)[\]|\)|,|;|:|\b]*

VCSITS#1 ABC#2 XYZFix issue #1Fix bugc1c2c3c4VCSITS#1 ABC#2 XYZFix bugCMPLinked issue: #2c1c2c3c4Figure 2. A schematic representation for tracing bug inducing commits utilizing pull requests. Commits in the VCS are shown as circles and denoted with a
lowercase ci, inner commits of pull requests are shown as triangles, denoted as prj. Tickets from the ITS are depicted as squares. Identiﬁed ﬁxing commits
are colored white; bug inducing commits are depicted black; all other elements are grayed. Files changed in a commit are shown next to it.

D. Tracing Bug Inducing Commits

We build on the approaches described in Section II to
trace bug inducing commits. We propose extensions to ﬁlter
changes of the ﬁx commit (f1-3) as well as selection mecha-
nisms (s1-3) based on pull request information to reduce the
number of incorrectly inferred inducing commits. The ﬁxing
commit as well as the suspected inducing commits can be
part of developments originated in a pull request. The pull
request for the ﬁxing commit is deﬁned as prﬁx, the one
integrating the suspected bug inducing commit is denoted as
prsus. A schematic representation of VCS, ITS and CMP for
an exemplary use case is shown in Figure 2.

For each ﬁxing commit SZZ traces inducing commits that
changed the ﬁxed lines. In all existing approaches, the bug
ﬁxing commit is compared to the previous commit in the
VCS history to compute the changes. However, this may also
include lines that are itself part of prﬁx. These changes are
most probably not part of the problem but shadow the actual
problem solution. We calculate the commit difference not with
its parent, but with the ﬁrst parent in the VCS history that is
not part of prﬁx (f1). Thereby, all changes contained in prﬁx
prior to the ﬁxing commit are ignored. In Figure 2, this has
no effect since squashed pull requests are always represented
by a single commit in the VCS. Therefore, commit c7 is
compared to c6. In other cases this may span several commits.
As shown in Figure 2, prﬁx could be squashed so the ﬁxing
commit may have several inner commits assigned (pr1
ﬁx).
We obtain all inner commits of prﬁx and neglect changed ﬁles
of the selected ﬁxing commit that were not part of any inner
commit (f2). This may occur when the ﬁxing commit integrates
multiple pull requests at once. Thus, changes to File D of
c7 are ignored. Furthermore, with the same conﬁdence level
approach as described for ﬁnding bug ﬁxing commits, PR-SZZ
tries to select the actual ﬁxing commit from the inner commits
(f3). It neglects all ﬁles that were not part of this commit.
Therefore, File C in commit c7 is ignored since the inner ﬁx
commit (pr1
ﬁx) does not change the ﬁle. As too large changes
tend to generate false-positive inducing commits, a threshold
for maximum changed ﬁles and lines is applied. Only the ﬁles
remaining after applying f1-f3 are processed further.

ﬁx, pr2

For each remaining ﬁle, the changed lines are ﬁltered. In
accordance with Kim et al. [8] and Willams and Spacco [9],

we neglect line changes concerning only whitespaces, imports
or comments. To detect such changes we build a tool to
extract language constructs from code using ANTLR [30].
This approach is chosen as it is easily extendable for additional
grammars and does not depend on language speciﬁc tooling.
Resembling MA-SZZ [11], we ignore meta changes. Assumed
that c4 changes only permissions to File A,
is ignored
and the next commit in the history is blamed. We consider
removed as well as added lines when tracing the bug inducing
commits. Since solely added lines cannot be traced, we resort
to considering changes to the whole method body, as ﬁxes are
mostly co-located with their induction [31] (e.g., a missing null
check). We blame the commits that last changed the computed
lines. Each line change is tracked in a line mapping approach
to better trace large chunks of changed lines [9]. We do not
apply refactoring detection tools to be more language agnostic.
The entirety of blamed commits contained in the mappings,
form the set of suspicious bug inducing changes.

it

In order to reduce the list of suspicious inducing commits,
we design selection mechanisms based on pull request infor-
mation. We extend R-SZZ to not only select the most recent
commit before the issue was reported, but also before prﬁx
was created (s1). In some cases the pull request is provided
ﬁrst and subsequently a matching ticket is created in the ITS.
In the example case, c5 is ignored. We further propose two
new selection mechanisms based on pull requests. Each prsus
for every bug inducing commit is retrieved. We obtain links
between prsus and prﬁx. If such link exists, we consider the prsus
and the associated commits as secured bug inducing commits
(s2). In our example c3, changing File B, would be marked
as secured inducing commit if the pull requests are linked.
Defect data sets generated by PR-SZZ are contain on commit,
ﬁle and method level to enable more ﬁne-grained analyses. The
last selection mechanism (s3), subsequently, analyzes prsus in
more detail. For each changed ﬁle and method in a ﬁx commit,
the matching inducing ﬁle and method is retrieved from the
list of suspects. We select commits that concern the changed
lines and ignore changes to different ﬁles. In the case described
in Figure 2, only pr2
sus change File B. However, the
blamed lines are only touched by pr2
sus. Consequently, changes
of c3 are marked as inducing, but only changes in pr2
sus are
considered for the ﬁne-grained data set.

sus and pr3

VCSITS#2 XYZCMPFile AFile BFile CFile AFile CFile BFile AFile BFile CFile BFile CFile BFile CFile BFile AFile BFile Cprfixprsusc1c2c3c4c5c6c7prsusprsusprfix1212File D3Table II
OVERVIEW OF PROJECTS ANALYZED IN THIS STUDY. TOTAL NUMBER OF
COMMITS, PULL REQUESTS AND TICKETS IS SHOWN ALONGSIDE NUMBER
OF DISTINCT BUGS.

Project
angular/angular[2]
apache/airﬂow[1,2]
apache/calcite[1]
apache/kafka[1]
apache/pulsar[1,2]
jenkinsci/jenkins[1]

#Commits
19399
11042
3156
7251
5790
10623

#Pull Requests
11645
8645
1642
8036
5557
2812

#Tickets
19282
7169
2910
6712
1989
3054

#Bugs
4855
2938
1805
3726
1750
2357

[1]: Project uses Jira as ITS
[2]: Project uses Github Issues as ITS

IV. STUDY DESIGN

We evaluate the additions of PR-SZZ and compare the
results to existing approaches by conducting experiments for
a selection of open-source projects. First, we describe the
studied projects and their overall characteristics. Second, the
process of data collection and preparation is described. Finally,
we present the evaluation setup for the experiments to address
the following research questions:

• RQ1: To which degree can pull request data increase the

performance of ﬁnding bug ﬁxing commits?

• RQ2: To which degree can pull request data increase the

performance of tracing bug inducing commits?

A. Studied Projects

In this paper, we investigate pull requests on GitHub as
well as bug tickets from Jira and the GitHub issue tracking
solution (from here on called GitHub Issues). We collected
data from 20 popular open-source repositories, with a focus on
projects from the Apache Software Foundation since these are
oftentimes used in other studies concerning SZZ evaluations
(e.g., [11], [16], [32]). Statistics for all 20 projects can be
found in the supplementary material provided alongside this
paper. This study is restricted to projects with at least 1000
stars on GitHub showing community interest, at least 1000
commits to ensure a sufﬁcient development history, a issue-
commit ratio of at least 20% to guarantee ITS usage and a 20%
pull request-commit ratio to ensure the usage of pull requests
for integrating changes. Six projects that meet these criteria
are selected as shown in Table II. One of the projects solely
uses GitHub Issues, three use Jira while two project use a
hybrid workﬂow with both Jira and GitHub Issues conﬁgured.
Since our approach relies on a pull-based workﬂow, the
observation period is restricted to a time frame where mostly
pull requests are used to integrate changes in the studied
projects. Therefore, for each studied project, we evaluate six
years of historical data from January 2015 to January 2021.

B. Study Process

In this section, we describe our approach to execute the
study. First, all repositories are cloned and commits from all
branches are extracted. We use the GitHub API to get all pull
request information and reconstruct the development activities

as described in Section III-A. For each project, based on the
used ITS, we utilize the Jira or GitHub API to get resolved
tickets. Bug labels can be assigned to Jira tickets, GitHub
tickets and pull requests. By analyzing the links between all
systems, we ﬁnd that up to 458 duplicate bugs exist with
a mean of 144 duplicates per project. Hence, we resolve
duplicated tickets as described in Section III-B and show the
number of distinct bug tickets in Table II. Similar to existing
research, it is assumed that the labels assigned to tickets are
correct. However, it should be noted that this assumption does
not always hold according to other studies (e.g., [16], [17]).
We execute PR-SZZ to map bug ﬁxing commits to their
corresponding bug ticket as described in Section III-C. To
evaluate its performance, multiple existing implementations
are also executed. First, we execute OpenSZZ [33],
that
implements the original version described in B-SZZ and relies
on the same regular expressions as proposed by ´Sliwersky
et al. [7] for ﬁnding the ﬁxing commits. Second, we re-
implemented B-SZZ (B-SZZ*), to adjust the commit message
parsing for nowadays established commit message rules. We
apply the same regular expressions as described in Section
III-C. Additionally, another open-source implementation called
SZZUnleashed [34] is executed using the same regular expres-
sions. All algorithms are adjusted to handle Jira, GitHub Issue
and pull request bug descriptions as well as duplicated bug
tickets.

Using the bug ﬁxing commits obtained by the ﬁrst algorithm
step, we execute the second step of PR-SZZ to obtain the
corresponding bug inducing commits as described in Section
III-D. In order to compare results from PR-SZZ to already
existing approaches, we utilize PySZZ [23], an open-source
tool which implements the bug inducing part of B-, AG-, MA-,
L-, R-, and RA-SZZ. RA-SZZ is omitted in our experiments,
as the current implementation only supports Java projects.

C. Evaluation Setup

With the described study process, we obtain results for
mapped bug ﬁxing commits and traced bug inducing commits
for all executed SZZ variants. For both research questions,
we evaluate the performance of each executed variant. Due
to the lack of established ground truth for the investigated
projects, we evaluate the results ﬁrst on a quantitative basis
followed by an evaluation performed on a manually collected
and validated data set. The performance evaluation is based
on precision, recall and F-score.

For the manual evaluation of mapped bug ﬁxing commits
(RQ1), we select and validate a subset of all bug tickets.
When all algorithms report the same ﬁxing commit for a
bug ticket we excluded those from further evaluation since
a consensus exists and no alternative result could be extracted
by any current implementation. Among the remaining bug
tickets, we randomly select 50 samples per project and search
manually for their corresponding ﬁxing commit. To identify
the correct ﬁxing commit, we use the ticket description on Jira
or GitHub, pull request information and the commit message
of all commits. If we cannot ﬁnd any ﬁxing commit, for

Table III
PERCENTAGE OF BUG TICKETS FOR WHICH A FIXING COMMIT WAS FOUND
ACROSS ALL STUDIED PROJECTS. TOTAL NUMBER OF BUG TICKETS IN
BRACKETS.

Table IV
PERFORMANCE EVALUATION OF FINDING BUG FIXING COMMITS FOR THE
EXECUTED SZZ VARIANTS AVERAGED OVER ALL PROJECTS.

Algorithm

Combined

B-SZZ*
OpenSZZ
SZZUnleashed
PR-SZZ

(n=17431)

34.68%
16.46%
43.34%
61.71%

Pull
Requests
(n=2797)

GitHub
Issues
(n=5333)

86.56%
4.61%
65.61%
98.78%

14.06%
1.84%
12.30%
49.43%

Jira Issues

(n=10155)

35.31%
27.18%
56.18%
61.00%

example when the bug ticket was not resolved but closed,
we put a null value. This results in a total of 300 manually
validated bug tickets. When evaluating the performance for
PR-SZZ, B-SZZ*, OpenSZZ and SZZUnleashed we collect
all identiﬁed bug ﬁxing commits for each respective variant,
compare it to the correct ﬁxing commits from the validated
data set and calculate the performance metrics. We report the
results in Section V-A.

For the manual evaluation of tracing the correct bug induc-
ing commits (RQ2), we again neglect the samples where there
is unison among all variants and take a random set of 50 ﬁxing
commits for each project. Furthermore, we remove samples
which are not code related (e.g., ﬁxes for documentation)
and replace them by additional random samples. To trace
the correct inducing commits manually, we use the change
patches from the ﬁxing commits, corresponding pull requests
and the git blame feature. We observed that developers often
linked to the inducing commit in the discussion of the bug
ticket and used them whenever possible. A single bug can be
introduced by multiple commits, therefore we search for the
list of inducing commits. In total, 300 bug ﬁxing commits
were randomly selected and manually validated using this
approach. All identiﬁed inducing commits from each executed
SZZ variant are compared to the correct inducing commits in
this data set. We compute the performance metrics and analyze
the results in Section V-B.

V. RESULTS

This section is organized based on the formulated research
questions and discusses them accordingly. We provide all data
sets, necessary source code and detailed evaluation results in
our supplementary material.4

A. RQ1: To which degree can pull request data increase the
performance of ﬁnding bug ﬁxing commits?

To answer RQ1, we ﬁrst analyze the results of retrieving bug
ﬁxing commits on a quantitative basis. Table III contains the
percentage of bug tickets with an assigned bug ﬁxing commit
across all projects. PR-SZZ retrieves most ﬁxing commits in
all of the investigated projects. Since not all ﬁxing commits
reference the ﬁxed bug ticket in the commit message, at least
18.37% of them can be additionally mapped using PR-SZZ.

4https://doi.org/10.6084/m9.ﬁgshare.16831492

Algorithm
B-SZZ*
OpenSZZ
SZZUnleashed
PR-SZZ

Precision
0.74
0.34
0.75
0.79

Recall
0.24
0.12
0.26
0.72

F-score
0.35
0.16
0.34
0.75

We ﬁnd that for 55.69% of the bug tickets PR-SZZ would map
a ﬁxing commit using links to pull requests, meaning that in
6.02% of the cases no pull request could be found and PR-
SZZ did fall back on searching the commit messages for the
corresponding ticket number. All executed SZZ variants ﬁnd
the same result for 41.04% of all bug tickets, with no variant
being able to retrieve a ﬁxing commit for 36.05%. We see
that there are still many bug tickets with no assigned ﬁxing
commit. However, this is not necessarily wrong since not all
resolved bug tickets are ﬁxed by a commit but may be closed
due to irrelevance or because they were ﬁxed outside of the
project scope.

PR-SZZ ﬁnds a ﬁxing commit for a bug ticket in most
cases compared to the other algorithms regardless of where
the bug ticket originates. When comparing the results for the
different ITS, we observe some variations in the gain PR-SZZ
provides compared to existing solutions. It becomes apparent
that PR-SZZ outperforms alternatives when GitHub Issues is
used. It ﬁnds a ﬁxing commit for another 35.37% of bug tickets
compared to the most ﬁnding alternative (i.e., B-SZZ*). When
looking at bug tickets from Jira the difference to the best
alternative (i.e., SZZUnleashed) is smaller with additionally
found ﬁxing commits for 4.82% of bug tickets. On the project
level, this is a recurring theme. The fact that projects using
GitHub Issues can map extensively more ﬁxing commits to
bug tickets may be due to the better integration of tickets
and pull requests in the platforms ecosystem. Using Jira it is
evident that links between bug tickets and pull requests are
present less often, however ticket identiﬁers are more often
added to the commit message by the developers. It seems
that the automation in GitHub reduces manual issue tracking
effort for the developers. Therefore, with more open-source
projects using GitHub Issues, new data such as pull requests
is needed to retrieve ﬁxing commits. An evaluation for each
project separately can be found in the supplementary material
provided with this paper.

That said, the number of found ﬁxing commits does not
reﬂect on the quality of the inferred mappings. Therefore, we
continue with evaluating the performance of PR-SZZ com-
pared to existing open-source implementations on a manually
validated subset of bug tickets, as described in Section IV-C.
The results are shown in Table IV. With the correct ﬁxing
commit found in 71.67% of the sampled bug tickets, PR-
SZZ is the most reliable algorithm among the variants. On
average, PR-SZZ increases precision as well as recall for

the manually validated data sets. For the individual projects
precision is increased for three, while recall is highest for
all of the projects. The especially high recall on all projects
shows that additional ﬁxing commits can be correctly mapped
to the sampled bug tickets and the high precision states that
the found bug ﬁxing commits are mainly correct resulting in
an higher F-score on average and for every distinct project
under investigation. Looking at the performance in regard to
the different ITS no apparent difference can be noticed. We
conclude that the quality of the identiﬁed bug ﬁxing commits
is not determined by the use of ITS for any algorithm.

Using PR-SZZ, 18% of bug tickets can be additionally
mapped to a ﬁxing commit. On average, precision as well as
recall is increased, resulting in an F-score of 0.75 compared
to 0.35 for the best performing existing alternative. We
conclude that using pull request data contributes to the
completeness and performance of the ﬁrst step of the SZZ
algorithm.

B. RQ2: To which degree can pull request data increase the
performance of tracing bug inducing commits?

The second part of SZZ uses mapped ﬁxing commits as
input and traces the inducing code. We use the data set created
by the ﬁrst step of PR-SZZ from above as input for this
evaluation. In this data set the ﬁxing commit has a reference
to a pull request in 91.37% of cases. Inducing commits are
found for 63.76% of all bug tickets for PR-SZZ and using
existing approaches for between 54.08% (e.g., MA-SZZ) and
67.97% (e.g., B-SZZ) of the cases.

Hereafter, we evaluate the number of cases where our
proposed ﬁlter (f1-f3) and selection (s1-s3) mechanisms from
Section III are applicable for the investigated projects. Com-
paring a ﬁxing commit to its direct parent inside the pull
request instead of the latest not feature related commit (f1),
the traced inducing commits can be part of the bug ﬁx. In case
of B-SZZ, results show that a total of 205 selected inducing
commits are part of the ﬁxing pull request. The inducing
commit for a bug ticket, however, cannot be created within the
pull request to ﬁx the actual bug. Files from the ﬁxing commit
that are not modiﬁed by the ﬁxing pull request are found in
83 cases (f2). For squashed ﬁxing commits, we ﬁnd that an
inner commit can be selected as real ﬁxing commit in 2571
cases (f3). In total, the number of traced ﬁles can be reduced
in 718 cases. The ﬁxing pull request is created before the
bug ticket (s1) in 467 cases, which enables PR-SZZ to ignore
suspicious inducing commits that can not be responsible for
the introduction of the bug. Additionally, a suspect inducing
commit is mentioned in the ﬁxing pull requests (s2) a total
of 237 times, providing additional context for the selection
of a inducing commit. The selected suspect is squashed in
1069 cases, allowing further ﬁltering and selection for ﬁle
and method level data sets (s3). This shows that the proposed
additions can have an impact on the results of SZZ and may
improve the performance in terms of correctly traced and
selected bug inducing commits for the corresponding cases.

Table V
PERFORMANCE EVALUATION OF TRACING BUG INDUCING COMMITS. THE
RESULTS FOR PR-SZZ ARE REPORTED FOR ALL SUSPECTS (PR-SZZ) AND
AFTER THE SELECTION MECHANISM IS APPLIED (PR-SZZ SELECTED).

Algorithm

Selection Applied?

Precision

Recall

F-score

B-SZZ
AG-SZZ
MA-SZZ
PR-SZZ
L-SZZ
R-SZZ
PR-SZZ selected

(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:51)
(cid:51)
(cid:51)

0.34
0.26
0.19
0.30
0.32
0.29
0.50

0.62
0.21
0.26
0.68
0.19
0.17
0.39

0.44
0.23
0.22
0.41
0.23
0.22
0.44

PR-SZZ reports an average of 4.19 inducing suspects
ranging from 1 to 108 inducing commits per bug ﬁxing
commit. Existing approaches do report more inducing commits
(maximum 463 for MA-SZZ), with an average between 1.61
(e.g., AG-SZZ) and 4.34 (e.g., B-SZZ) per bug ﬁx. However,
only 14 of the 300 manually validated bug ﬁxing commits
had multiple inducing commits (maximum 4 suspects). With
many suspects found for a single bug ﬁx many false-positives
are introduced in the result set. We argue that it is important
to reduce the number of false-positives since the data sets are
used as input for research on bug characteristics and defect
prediction, where wrongly labeled bug inducing commits may
have implications. With the selection of one commit per bug
ﬁx the number of wrongly labeled inducing commits can be
reduced. When selecting a single commit the results of all
selecting variants (L-, R- and PR-SZZ select) do overlap. On
average, 28.56% (min: Kafka with 20.85%; max: Airﬂow with
36.42%) of selected inducing commits from PR-SZZ are also
selected by either L- or R-SZZ. This shows that PR-SZZ does
select new inducing commits for the majority of cases.

In order to evaluate the added value of proposed adjust-
ments, a manual evaluation is conducted as described in
Section IV-C. The results are shown in Table V. On average,
B-SZZ and PR-SZZ report a signiﬁcantly higher F-score
compared to all other variants. Looking at each single project,
a more diverse distribution becomes apparent. B-SZZ has the
higher precision in 5 projects, with PR-SZZ in the other project
(mean difference of 0.03). While PR-SZZ has the higher recall
on average and in 5 projects, with B-SZZ in the other project
(mean difference of 0.07). Please refer to the supplementary
material for a in depth comparison. This states that PR-SZZ
can ﬁnd more correct suspects than all other variants. However,
it also ﬂags more commits that are indeed not inducing bugs
into the code base. With the high number of suspects for
PR-SZZ and B-SZZ, described in the quantitative analysis,
they show by far the highest and second highest recall value.
The higher recall value, however comes with a trade-off in
precision. Looking at the executed selecting variants, PR-SZZ
reports the highest precision among all variants, outperforming
the next best approach (L-SZZ) by 18.41 percentage points.
The F-score of 0.44 is comparable to the one reported by
B-SZZ showing clearly the trade-off between precision and
recall. This also shows that the proposed ﬁltering and selection

mechanisms work, lead to more correct suspects, selecting the
correct ones more often. Looking at each project, we see that
the PR-SZZ selection mechanism has the highest precision
value for all projects. Moreover, it states the highest F-score
in three of the projects.

We conclude that PR-SZZ needs speciﬁc workﬂow attributes
to be fully applicable. For instance, in projects with a primarily
squashed workﬂow, inner commits of pull requests can be used
to ﬁlter the list of suspicious ﬁles, which in non-squashed
workﬂows mitigates the effect size. Applying PR-SZZ with
the precision of found inducing
its selection mechanisms,
commits on our manual evaluation data set is increased. As
already mentioned, this is especially important as data sets
created by SZZ are used in other research.

Evaluating the proposed ﬁltering and selection mechanisms
the performance of existing SZZ variants is highly depen-
dant on the project characteristics. If selection mechanisms
are applied PR-SZZ reports the highest precision for all
investigated projects, outperforming all other variants by on
average 16 percentage points, leading to higher quality data
sets.

VI. DISCUSSION

In this section, we discuss characteristics of both steps
of the algorithm that inﬂuence the performance of SZZ in
general and PR-SZZ in speciﬁc. Especially, the inﬂuence on
the investigated projects that vary in size and development
workﬂow is discussed. Variations in performance are evident
in both steps of the algorithm depending on the project and
applied SZZ variant. Analyzing the merge strategies of all
projects, we ﬁnd considerable differences. Half of the projects
use a preliminary rebase-based workﬂow, while the others
use a merge-based workﬂow. Furthermore, 3 projects use an
predominately squashed integration mechanism. Exemplary,
this leads to 4823 out of 8036 pull requests with shadowed
commits for Apache Kafka. With different integration strate-
gies, SZZ may compute results of varying quality.

A. Finding Bug Fixing Commits

An determining factor for the performance of ﬁnding the
bug ﬁxing commit is the quality of links between tickets
and commits for existing SZZ variants and for PR-SZZ also
between tickets and pull request. On average, 51.96% of bug
tickets are linked to a pull request with differences between
the projects (min: 35.36%, max: 64.56%). Furthermore, on av-
erage, only 7.26% (min 0.00%; max 17.71%) of pull requests
were labeled as bugs. With existing variants relying on match-
ing commit message with bug tickets, additional attention.
As shown by the results of OpenSZZ the initially suggested
regular expressions are not applicable with nowadays commit
message rules. Therefore, the matching regular expression for
bug ticket references in the commit message needs to be
adjusted to the project workﬂow. With the implicit link used
in PR-SZZ, no string matching is needed, which mitigates this
problem. In cases where the issue identiﬁer is not referenced in

the commit message, information from pull requests is needed
to ﬁnd the ﬁxing commit.

In the VCS, multiple commits can reference the same
bug ticket. Determining the correct commit from multiple
ﬁx-, test-, or refactoring-commits is not possible for existing
SZZ variants since no additional information is used. Projects
that squash commits on integration, so that a branch is only
represented as one commit in the VCS history, resolve this
problem for the ﬁrst step of the algorithm. Nonetheless, it
creates a new problem for tracing the inducing commit, since
the squashed commit contains multiple inner changes, while
most of the times only one of the inner changes ﬁxes the
problem. PR-SZZ handles these special cases by using the
linked pull request and selects an inner commit from the
gained context.

B. Tracing Bug Inducing Commits

Tracing inducing commits, the project characteristics and
especially the merge strategy inﬂuence the results of SZZ
and the applicability of PR-SZZ. The investigated projects use
different merge strategies as well as vary in size and program-
ming language. Therefore, the applicability of ﬁltering and
selection mechanisms varies between projects. For instance,
f3 can be applied in many instances of the Apache Airﬂow
project but has only little effect on projects such as Jenkins.
Many validated bug ﬁxes are partial ﬁxes (182 out of 300)
with on average 2.47 ﬁles in the ﬁxing commit and the
validated inducing commits are often partially inducing (275
out of 300) with on average 102 ﬁles in the inducing commits,
with a small fraction of these ﬁles ﬁxing or introducing the
problem. With PR-SZZ we apply ﬁlter for inner ﬁle changes
and create data sets on the ﬁle and method level to reduce the
error rate inside the selected commits. An evaluation of these
data sets is contained in the supplementary material.

Interestingly, B-SZZ was the best baseline approach for the
investigated projects, with comparable results to PR-SZZ. We
see that, existing extensions to SZZ did not perform better in
most instances. Most of the additions proposed by AG- or MA-
SZZ are only applicable in special cases and do not necessarily
increase the performance on the validated data set. We ﬁnd that
oftentimes the performance is worse. This is in line with the
results of Rosa et al. [23]. Although B-SZZ performs well in
terms of F-score in our study, it reports many false-positives.
A high number of false-positives introduces noise in the data
set, which may poses a threat to validity for studies that use
the data sets. For example applying low quality data sets in
just-in-time defect prediction can inﬂuence the performance
of such models [35]. However, the SZZ variant used to create
these data sets should be selected based on the speciﬁc use
case. If it is more important to obtain all possible inducing
commits, selection mechanisms can be ignored leading to a
high recall. On average, PR-SZZ has the highest recall in
our evaluation (+0.06 to B-SZZ). If high quality is more
important, the mechanisms proposed in this paper increase
precision compared to existing variants (+0.16 to B-SZZ).

VII. RELATED WORK

Improvements and related approaches to the SZZ algorithm
are described in detail in Section II of this study. In this
section, we distinguish ourselves from existing literature.

Prior studies concentrate on one issue management tool
when evaluating their approach. For
instance, Jira [34],
Bugzilla [7] or GitHub Issues [24] is used. We show results for
different project workﬂows and ITS and analyze their inﬂuence
on SZZ implementations. Sahal et al.’s [24] SZZ enhancement
tracks solely added lines by extending the blamed change to
the surrounding code block in Java. We extend their approach
to other languages and to a broader context.

In order to identify bug ﬁxing commits, other techniques
using heuristics on bug reports and commits in cases where no
explicit link is given were proposed in the literature [36], [37].
However, they do also ﬁrst apply a search for secured direct
links. We propose using data from pull requests to uncover
new direct links between bug reports and their ﬁxes. For bug
reports without a ﬁxing commit after applying our approach,
these heuristics may be a good fallback option.

In order to make SZZ comparable multiple studies focus
on evaluating the results. Da Costa et al. [11] propose several
universal evaluation criteria. We do not use their framework
since we focus on beneﬁts from pull requests in general. Rosa
et al. [23] craft an oracle using natural language processing on
the commit message and infer mentions to inducing commits.
Due to this selection process it is not used in our study.

To the best of our knowledge, no existing SZZ variant
uses data apart from the VCS history and bug tickets. This
has foremost historical reasons where proposed enhancements
concentrate on code characteristics to boost the algorithms
performance. Our approach uses pull requests to improve the
SZZ algorithm. Regarding pull requests, data generated by
pull-based workﬂows is already used by researchers to support
decision making (e.g., [38], [39]) and to study pull request
characteristics (e.g., [40]–[42]). For example, they ﬁnd that
the acceptance of pull requests is not directly inﬂuenced by
the quality of the proposed code [40]. Furthermore, Gousios
[42] found that squashed commits are hidden in VCS. We
apply their ﬁndings to propose enhancements to SZZ. Lastly,
Huq et al. [43] analyse pull requests in the context of inducing
commits. They perform a sentiment analysis on pull request
artifacts and ﬁnd that bug inducing changes show a more
negative sentiment compared to regular commits. In future our
approach may be extended to apply and evaluate their ﬁndings.

VIII. THREATS TO VALIDITY

A. Internal Validity

Since no ground truth is available for the investigated
projects, we construct the data sets for evaluating our approach
manually. The samples were labeled by one of the authors
following a strict process. However, it is still possible that
bias was introduced or samples were wrongly labeled. We
cross-referenced our ﬁndings with related literature to verify
plausibility. We assume that all bug labeled items from the

collaborative and issue management platforms are valid. While
manually validating bug tickets, we found that many of them
do not describe bugs but rather improvements. Furthermore,
bug tickets are often concerning changes in documentation
or conﬁguration ﬁles, with no real commit
inducing the
problem. We circumvent this in the manual evaluation by
neglecting samples that were no bug description. Last, the
manual evaluation is based on a random subset of bug ﬁxes
and inducing commits. Thereby, not all data is validated. We
release all data for other researchers to reproduce our results.

B. External Validity

We selected 6 projects from GitHub to perform our evalua-
tion of different background, languages and with different ITS.
Nonetheless, we cannot be sure that our results can be gen-
eralized, as we already report differences in the performance
of PR-SSZ with regard to project setups. We predominantly
used Apache Foundation projects to mitigate the problem. In
the future, we plan to evaluate PR-SZZ on a bigger and more
diverse set of projects.

IX. CONCLUSION AND FUTURE WORK
The SZZ algorithm is the standard way to retrieve defect
data sets from the version control system using the issue
tracking system. However, not all bug ﬁxing commits for
all bug tickets can be found, while large ﬁxing commits
produce a large list of potentially bug inducing commits. Given
SZZ forms the basis for many empirical software engineering
studies, we aim to increase its completeness, performance and
granularity. We propose additions to the SZZ algorithm by
using pull-based data as they describe development activities
in more detail. We apply the pull-request-aware SZZ (PR-SZZ)
to open-source repositories and found that our additions can
support the search for bug ﬁxing and inducing commits.

When searching the bug ﬁxing commit, existing SZZ vari-
ants report high precision but low recall, meaning that many
true positive bug ﬁxing commits are missed. Due to links
between bug tickets and pull requests, PR-SZZ is able to ﬁnd
additional bug ﬁxing commits. We report increased precision
and recall, elevating the F-score on average by 40 percentage
points. When tracing the bug inducing commits, overall low
precision values are obtained by all existing variants. With
SZZ building the foundation for subsequent research, precision
should be considered more valuable than recall and be the
focus of future improvements. Applying our proposed mech-
anisms, the highest precision is observed for all projects with
a gain of on average 16 percentage points.

In order to enable further research, we publish data sets
for 6 open-source projects on commit, ﬁle and method level.
Future work should focus on the in depth analysis of project
environments and workﬂows to investigate the characteristics
determining the performance of SZZ.

ACKNOWLEDGMENT
This study is based upon work supported by the Bavarian
Ministry of Economic Affairs, Regional Development and
Energy under the Center for Code Excellence project.

REFERENCES

[1] J. Eyolfson, L. Tan, and P. Lam, “Do time of day and developer
experience affect commit bugginess?” in Proceedings of the 8th Working
Conference on Mining Software Repositories, ser. MSR ’11. New York,
NY, USA: Association for Computing Machinery, 2011, p. 153–162.
[2] O. Kononenko, O. Baysal, L. Guerrouj, Y. Cao, and M. W. Godfrey,
“Investigating code review quality: Do people and participation matter?”
in 2015 IEEE International Conference on Software Maintenance and
Evolution (ICSME), 2015, pp. 111–120.

[3] B. Chen and Z. M. Jiang, “Extracting and studying the logging-
code-issue- introducing changes in java-based large-scale open source
software systems,” Empirical Softw. Engg., vol. 24, no. 4, p. 2285–2322,
Aug. 2019.

[4] Y. Kamei, E. Shihab, B. Adams, A. E. Hassan, A. Mockus, A. Sinha,
and N. Ubayashi, “A large-scale empirical study of just-in-time quality
assurance,” IEEE Transactions on Software Engineering, vol. 39, no. 6,
pp. 757–773, 2013.

[5] G. Catolino, “Just-in-time bug prediction in mobile applications: The
domain matters!” in 2017 IEEE/ACM 4th International Conference on
Mobile Software Engineering and Systems (MOBILESoft), 2017, pp.
201–202.

[6] L. Pascarella, F. Palomba, and A. Bacchelli, “Fine-grained just-in-time
defect prediction,” Journal of Systems and Software, vol. 150, pp. 22–36,
2019.

[7] J. ´Sliwerski, T. Zimmermann, and A. Zeller, “When do changes induce
ﬁxes?” in Proceedings of the 2005 International Workshop on Mining
Software Repositories, ser. MSR ’05. New York, NY, USA: Association
for Computing Machinery, 2005, p. 1–5.

[8] S. Kim, T. Zimmermann, K. Pan, and E. J. Jr. Whitehead, “Automatic
identiﬁcation of bug-introducing changes,” in 21st IEEE/ACM Interna-
tional Conference on Automated Software Engineering (ASE’06), 2006,
pp. 81–90.

[9] C. Williams and J. Spacco, “Szz revisited: Verifying when changes
induce ﬁxes,” in Proceedings of
the 2008 Workshop on Defects in
Large Software Systems, ser. DEFECTS ’08. New York, NY, USA:
Association for Computing Machinery, 2008, p. 32–36.

[10] S. Davies, M. Roper, and M. Wood, “Comparing text-based and
dependence-based approaches for determining the origins of bugs,”
Journal of Software: Evolution and Process, vol. 26, no. 1, pp. 107–
139, 2014.

[11] D. A. da Costa, S. McIntosh, W. Shang, U. Kulesza, R. Coelho, and A. E.
Hassan, “A framework for evaluating the results of the szz approach for
identifying bug-introducing changes,” IEEE Transactions on Software
Engineering, vol. 43, no. 7, pp. 641–657, 2017.

[12] E. C. Neto, D. A. da Costa, and U. Kulesza, “The impact of refactoring
changes on the szz algorithm: An empirical study,” in 2018 IEEE
25th International Conference on Software Analysis, Evolution and
Reengineering (SANER), 2018, pp. 380–390.

[13] E. C. Neto, D. A. d. Costa, and U. Kulesza, “Revisiting and improving
szz implementations,” in 2019 ACM/IEEE International Symposium on
Empirical Software Engineering and Measurement (ESEM), 2019, pp.
1–12.

[14] C. Bird, A. Bachmann, E. Aune, J. Duffy, A. Bernstein, V. Filkov, and
P. Devanbu, “Fair and balanced? bias in bug-ﬁx datasets,” in Proceed-
ings of the 7th Joint Meeting of the European Software Engineering
Conference and the ACM SIGSOFT Symposium on The Foundations
of Software Engineering, ser. ESEC/FSE ’09. New York, NY, USA:
Association for Computing Machinery, 2009, p. 121–130.

[15] T. F. Bissyand´e, F. Thung, S. Wang, D. Lo, L. Jiang, and L. R´eveill`ere,
“Empirical evaluation of bug linking,” in 2013 17th European Confer-
ence on Software Maintenance and Reengineering, 2013, pp. 89–98.

[16] S. Herbold, A. Trautsch, and F. Trautsch, “Issues with SZZ: an
empirical assessment of the state of practice of defect prediction
data collection,” CoRR, vol. abs/1911.08938, 2019. [Online]. Available:
http://arxiv.org/abs/1911.08938

[17] K. Herzig, S. Just, and A. Zeller, “It’s not a bug, it’s a feature: How
misclassiﬁcation impacts bug prediction,” in 2013 35th International
Conference on Software Engineering (ICSE), 2013, pp. 392–401.
[18] C. Mills, J. Pantiuchina, E. Parra, G. Bavota, and S. Haiduc, “Are
bug reports enough for text retrieval-based bug localization?” in 2018
IEEE International Conference on Software Maintenance and Evolution
(ICSME), 2018, pp. 381–392.

[19] G. Gousios, M. Pinzger, and A. v. Deursen, “An exploratory study
of the pull-based software development model,” in Proceedings of the
36th International Conference on Software Engineering, ser. ICSE 2014.
New York, NY, USA: Association for Computing Machinery, 2014, p.
345–355.

[20] A. Di Franco, H. Guo, and C. Rubio-Gonz´alez, “A comprehensive
study of real-world numerical bug characteristics,” in Proceedings of
the 32nd IEEE/ACM International Conference on Automated Software
Engineering, ser. ASE 2017.

IEEE Press, 2017, p. 509–519.

“A comprehensive

[21] J. Garcia, Y. Feng, J. Shen, S. Almanee, Y. Xia, and Q. A.
Chen,
autonomous vehicle bugs,”
study of
in Proceedings of the ACM/IEEE 42nd International Conference on
Software Engineering,
New York, NY, USA:
ICSE ’20.
Association for Computing Machinery, 2020, p. 385–396. [Online].
Available: https://doi.org/10.1145/3377811.3380397

ser.

[22] Z. Wan, D. Lo, X. Xia, and L. Cai, “Bug characteristics

in
blockchain systems: A large-scale empirical study,” in Proceedings
of the 14th International Conference on Mining Software Repositories,
ser. MSR ’17.
IEEE Press, 2017, p. 413–424. [Online]. Available:
https://doi.org/10.1109/MSR.2017.59

[23] G. Rosa, L. Pascarella, S. Scalabrino, R. Tufano, G. Bavota, M. Lanza,
and R. Oliveto, “Evaluating szz implementations through a developer-
informed oracle,” in 2021 IEEE/ACM 43rd International Conference on
Software Engineering (ICSE), 2021, pp. 436–447.

[24] E. Sahal and A. Tosun, “Identifying bug-inducing changes for code addi-
tions,” in Proceedings of the 12th ACM/IEEE International Symposium
on Empirical Software Engineering and Measurement, ser. ESEM ’18.
New York, NY, USA: Association for Computing Machinery, 2018, pp.
1–2.

[25] J. Pace, “A tool which compares java ﬁles based on content,” 2007.

[Online]. Available: http://www.incava.org/projects/java/diff

[26] D. Silva and M. T. Valente, “Refdiff: Detecting refactorings in version
histories,” in 2017 IEEE/ACM 14th International Conference on Mining
Software Repositories (MSR), 2017, pp. 269–279.

[27] N. Tsantalis, M. Mansouri, L. M. Eshkevari, D. Mazinanian, and D. Dig,
“Accurate and efﬁcient refactoring detection in commit history,” in Pro-
ceedings of the 40th International Conference on Software Engineering,
ser. ICSE ’18.
New York, NY, USA: Association for Computing
Machinery, 2018, p. 483–494.

[28] G. Gousios, A. Zaidman, M.-A. Storey, and A. v. Deursen, “Work
practices and challenges in pull-based development: The integrator’s
perspective,” in 2015 IEEE/ACM 37th IEEE International Conference
on Software Engineering, vol. 1, 2015, pp. 358–368.

[29] V. Cosentino, J. L. C´anovas Izquierdo, and J. Cabot, “A systematic
mapping study of software development with github,” IEEE Access,
vol. 5, pp. 7173–7192, 2017.

[30] T. Parr, The Deﬁnitive ANTLR 4 Reference, 2nd ed.

Pragmatic

Bookshelf, 2013.

[31] M. Wen, R. Wu, Y. Liu, Y. Tian, X. Xie, S.-C. Cheung, and
Z. Su, “Exploring and exploiting the correlations between bug-inducing
and bug-ﬁxing commits,” in Proceedings of the 2019 27th ACM Joint
Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering, ser. ESEC/FSE 2019.
New York, NY, USA: Association for Computing Machinery, 2019, p.
326–337. [Online]. Available: https://doi.org/10.1145/3338906.3338962
[32] G. Fan, X. Diao, H. Yu, K. Yang, L. Chen, and A. Vitiello, “Software
defect prediction via attention-based recurrent neural network,” Sci.
Program., vol. 2019, pp. 1–14, Jan. 2019.

[33] V. Lenarduzzi, F. Palomba, D. Taibi, and D. A. Tamburri, “Openszz:
A free, open-source, web-accessible implementation of the szz algo-
rithm,” in Proceedings of the 28th International Conference on Program
Comprehension, ser. ICPC ’20. New York, NY, USA: Association for
Computing Machinery, 2020, p. 446–450.

[34] M. Borg, O. Svensson, K. Berg, and D. Hansson, “Szz unleashed: An
open implementation of the szz algorithm - featuring example usage
in a study of just-in-time bug prediction for the jenkins project,” in
Proceedings of
the 3rd ACM SIGSOFT International Workshop on
Machine Learning Techniques for Software Quality Evaluation, ser.
MaLTeSQuE 2019. New York, NY, USA: Association for Computing
Machinery, 2019, p. 7–12.

[35] Y. Fan, X. Xia, D. A. da Costa, D. Lo, A. E. Hassan, and S. Li, “The
impact of mislabeled changes by szz on just-in-time defect prediction,”
IEEE Transactions on Software Engineering, vol. 47, no. 8, pp. 1559–
1586, 2021.

[36] R. Wu, H. Zhang, S. Kim,

and S.-C. Cheung,

“Relink:
Recovering links between bugs and changes,” in Proceedings of
the 19th ACM SIGSOFT Symposium and the 13th European Conference
on Foundations of Software Engineering, ser. ESEC/FSE ’11. New
York, NY, USA: Association for Computing Machinery, 2011, p.
15–25. [Online]. Available: https://doi.org/10.1145/2025113.2025120

[37] A. T. Nguyen, T. T. Nguyen, H. A. Nguyen, and T. N. Nguyen,
“Multi-layered approach for recovering links between bug reports
and ﬁxes,” in Proceedings of the ACM SIGSOFT 20th International
Symposium on the Foundations of Software Engineering, ser. FSE ’12.
New York, NY, USA: Association for Computing Machinery, 2012, pp.
1–11. [Online]. Available: https://doi.org/10.1145/2393596.2393671
[38] X. Ye, Y. Zheng, W. Aljedaani, and M. W. Mkaouer, “Recommending
pull request reviewers based on code changes,” Soft Computing, vol. 25,
no. 7, pp. 5619–5632, apr 2021.

[39] G. Zhao, D. Costa, and Y. Zou, “Improving the pull requests review
process using learning-to-rank algorithms,” Empirical Software Engi-
neering, vol. 24, 08 2019.

[40] V. Lenarduzzi, V. Nikkola, N. Saarim¨aki, and D. Taibi, “Does code
quality affect pull request acceptance? an empirical study,” Journal of
Systems and Software, vol. 171, p. 110806, 2021.

[41] R. Nadri, G. Rodriguez-Perez, and M. Nagappan, “Insights into non-
merged pull requests in github: Is there evidence of bias based on
perceptible race?” IEEE Software, vol. 38, no. 2, pp. 51–57, 2021.
[42] G. Gousios, “The ghtorent dataset and tool suite,” in Proceedings of the
10th Working Conference on Mining Software Repositories, ser. MSR
’13.

IEEE Press, 2013, p. 233–236.

[43] S. F. Huq, A. Z. Sadiq, and K. Sakib, “Understanding the effect of
developer sentiment on ﬁx-inducing changes: An exploratory study on
github pull requests,” in 2019 26th Asia-Paciﬁc Software Engineering
Conference (APSEC), 2019, pp. 514–521.

