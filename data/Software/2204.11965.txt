Noname manuscript No.
(will be inserted by the editor)

Bug Characteristics in Quantum Software Ecosystem

Mohamed Raed El Aoun · Heng Li ·
Foutse Khomh · Lionel Tidjon

2
2
0
2

r
p
A
5
2

]
E
S
.
s
c
[

1
v
5
6
9
1
1
.
4
0
2
2
:
v
i
X
r
a

Received: date / Accepted: date

Abstract With the advance in quantum computing (e.g., IBM’s quantum
computers) in recent years, quantum software becomes vital for exploring the
full potential of quantum computing systems. Quantum programming is dif-
ferent from classical programming in many diﬀerent ways, for example, the
state of a quantum program is probabilistic in nature, and a quantum com-
puter is error-prone due to the instability of quantum mechanisms. Therefore,
the characteristics of bugs in quantum software projects may be very diﬀer-
ent from that of classical software projects. This work aims to understand the
characteristics of bugs occurring in quantum software projects, in order to pro-
vide insights that can help devise eﬀective testing and debugging mechanisms
for quantum software projects. To achieve this goal, we conduct an empirical
study on the bug reports (in the forms of pull requests and issue reports) of
125 quantum software projects hosted on GitHub. We observe that quantum
software projects are more buggy than comparable classical software projects
and that quantum project bugs are more costly to ﬁx (in terms of the code
changed) than classical project bugs.

We also identify the types of these bugs and the quantum programming
components (e.g., state preparation) where they occurred. Our study shows
that the bugs are spread across diﬀerent components, but quantum-speciﬁc
bugs particularly appear in the compiler, gate operation, and state prepara-
tion components. The three most occurring types of bugs are Program anomaly
bugs, Conﬁguration bugs, and Data type and structure bugs. Our study high-
lights some particularly challenging areas in quantum software development
that are diﬀerent from that of traditional software development, such as the
lack of scientiﬁc quantum computation libraries that implement comprehen-

Mohamed Raed El Aoun, Heng Li, Foutse Khomh, Lionel Tidjon
Department of Computer Engineering and Software Engineering
Polytechnique Montreal
Montreal, QC, Canada
E-mail: {mohamed-raed.el-aoun, heng.li, foutse.khomh, lionel.tidjon}@polymtl.ca

 
 
 
 
 
 
2

Mohamed Raed El Aoun et al.

sive mathematical functions for quantum computing algorithms and quantum
gate operation deﬁnitions. Quantum developers also seek specialized data ma-
nipulation (e.g, array manipulation) libraries dedicated to quantum software
engineering such as Numpy for quantum computing. Our ﬁndings also provide
insights for future work to advance the quantum program development, test-
ing, and debugging of quantum software, such as providing tooling support for
debugging low-level circuits.

Keywords Quantum computing, quantum programming, quantum software
engineering, issue reports, quantum program bug.

1 Introduction

Quantum computing has achieved a series of important milestones in recent
years. For example, D-Wave claimed the ﬁrst commercial quantum computer in
2011 [31]. Tech giants such as IBM, Amazon, Google, and Microsoft are racing
to build their quantum computers. Quantum computers are expected to make
revolutionary computation improvements over modern classical computers in
certain areas, such as optimization, simulation, and machine learning [28, 35].
The rapid development of quantum computers has driven the development
of quantum programming languages and quantum software [43], with many of
them released as open source [15]. A variety of quantum programming frame-
works and languages have been introduced, such as Qiskit [1], Cirq [10], and
Q# [21]. IBM’s Qiskit is a Python-based software development toolkit for de-
veloping quantum applications that can run on quantum simulators or real
quantum computers (e.g., IBM Quantum Cloud).

Quantum software, by its nature, is drastically diﬀerent from classical soft-
ware. For example, a classical software system is executed sequentially and the
status of the system is typically deterministic. However, a quantum software
system is intrinsically parallel and can have multiple possible states at the
same time [27]. In addition, as quantum computers are error-prone due to
the instability of quantum mechanisms, the output of a quantum software
system is often noisy [29]. Thus, the bugs of quantum software may possess
characteristics that are very diﬀerent from those in classical software.

In this paper, we perform an empirical study on 125 open-source quantum
software projects hosted on GitHub. These quantum software projects cover
a variety of categories, such as quantum programming frameworks, quantum
circuit simulators, or quantum algorithms. An analysis of the development ac-
tivity of these selected projects show a level of development activities similar
to that of classical projects hosted on GitHub. To understand the characteris-
tics of bugs occurring in quantum software projects, we examined the following
two research questions.

RQ1: How buggy are quantum software projects and how do developers ad-
dress them? In this research question, we compare the distribution of bugs
in quantum software projects and classical software projects, as well as de-
velopers’ eﬀorts in addressing these bugs. We observe that quantum soft-

Bug Characteristics in Quantum Software Ecosystem

3

ware projects are more buggy than comparable classical software projects.
In addition, ﬁxing quantum software bugs is more costly than ﬁxing their
classical counterparts. Our results indicate the need for eﬀorts to help
developers identify quantum bugs in the early development phase (e.g.,
through static analysis), to reduce bug reports occurrence and bug ﬁxing
eﬀorts.

RQ2: What are the characteristics of quantum software bugs? We qualita-
tively studied a statistically representative sample of quantum software
bugs to understand their characteristics. In particular, we analyzed the
quantum software components (e.g., quantum measurement) where these
bugs occurred and examined the nature of these bugs (e.g., performance
bugs). We observed that both quantum computing-related bugs and clas-
sical bugs occur in quantum computing components. The gate operation
component is the most buggy. We identiﬁed a total of 13 diﬀerent types of
bugs occurring in quantum components. The three most occurring types of
bugs are Program anomaly bugs, Configuration bugs, and Data type
and structure bugs. These bugs are often caused by the wrong logi-
cal organization of the quantum circuit, state preparation, gate operation,
measurement, and state probability expectation computation.

Our work is important to guide future works that aim to develop method-
ology and tooling to support the identiﬁcation and diagnosis of quantum soft-
ware bugs. Some of our bug results emphasize a quantum-speciﬁc approach to
identifying bugs not detected by traditional techniques. Our ﬁndings can be
beneﬁcial to quantum computing developers. They can learn from the most
occurring bug types and avoid them in future work. Our results on which com-
ponent is more buggy can help guide developers’ testing eﬀorts. As quantum
computing frameworks are still in their early days and not yet widely used,
our study of bug types can have a beneﬁcial impact on the future releases of
the quantum frameworks.

Because quantum computing is still in its early stages, there have been
very few empirical studies on quantum computing bugs. In 2021, Campos
and Souto [7] highlighted the need to study quantum computing bugs. In the
same year, Zhao et al [44] studied 36 bugs from a single quantum computing
framework (Qiskit). In 2022, Matteo and Michael [30] identiﬁed the patterns of
223 real-world bugs in 18 quantum software projects. In this paper, we study
a larger set of bugs from a larger number of projects and perform a deeper
analysis of the characteristics and types of quantum bugs.
In essence, this work makes the following contributions:

– A preliminary study of the status and a categorization of quantum software

projects.

– A quantitative study of the bugs of 125 quantum software projects with

comparison to bugs of classical software projects.

– An in-depth qualitative study of 333 real-world bugs in 125 quantum soft-

ware projects.

4

Mohamed Raed El Aoun et al.

– An investigation of the types of quantum bugs, and their distribution across

the quantum components.

– Insights about the challenges and the complexity to ﬁx the bugs.

Paper organization. The rest of the paper is organized as follows. In Sec-
tion 2, we discuss key concepts of quantum software engineering. In Section 3,
we introduce the experimental setup of our study. A preliminary study on
the characteristics of quantum software projects is presented in Section 4. In
Section 5, we present the answers to our research questions. Section 6 reviews
the related literature, while Section 7 discusses threats to the validity of our
ﬁndings. Finally, Section 8 concludes the paper and discusses future works.

2 Background

In this section, we provide background knowledge about quantum computing,
quantum software development, and the current quantum computing ecosys-
tem.

2.1 Quantum Computing

While classical computers use bits in the form of electrical pulses to represent
1s and 0s, quantum computers use quantum bits (or qubits) in the form of
subatomic particles such as electrons or photons to represent 1s and 0s. A
qubit, unlike a classical bit, can be 0 or 1 with a certain probability, which
is known as the superposition principle [23]. In simple words, a qubit can
have two states at the same time. Thus, a quantum computer consisting of
multiple qubits is in many diﬀerent states at the same time. When a qubit is
measured, it collapses into a deterministic classical state. The status of two or
more qubits can be correlated (or entangled) in the sense that changing the
status of one qubit will change the status of the other(s) in a predictable way,
which is known as the entanglement phenomenon [23]. The superposition and
entanglement phenomenons give quantum computers advantages over classical
computers in performing large-scale parallel computation [23].

Similar to classical logic gates (e.g., AND, OR, NOT), quantum logic gates
(or quantum gates) alter the states (the probability of being 0 or 1) of the
input qubits. Like classical digit circuits, quantum circuits are collections of
quantum logic gates interconnected by quantum wires. Figure 1 illustrates an
example quantum circuit with two qubits (q0 and q1 ). Below, we describe the
three parts of the circuit:

1. Reset and initialization: The states of the two qubits are initialized as 0s.
2. Quantum gate: A Hadamard (H ) gate denoted by a blue square is applied
on the qubit q0. The gate H generates a superposition state with equal
probabilities for the states of 1 and 0. Then, a controlled-NOT CX gate
represented by a blue circle is applied on qubits q0 and q1 : the state of

Bug Characteristics in Quantum Software Ecosystem

5

qubit q1 is ﬂipped if and only if the state of qubit q0 is 1. Thus, the CX
gate creates entanglement between the pair of qubits q0 and q1 (i.e., the
state of one qubit is predictable from the state of the other).

3. Measurement: The measurement collapses the state of a qubit from a su-
perposition state into a deterministic single state. The output of this step
is a qubit with the most probable state.

Fig. 1: An example quantum circuit.

2.2 Quantum Software Development

Quantum software development typically follows the quantum gate-model to
accomplish a certain task [13]. In this model, the problem is expressed in terms
of quantum gates (described in Section 2.1). In Figure 2, we illustrate an ex-
ample of a quantum algorithm workﬂow using the gate model. The ﬁrst step
is to deﬁne the problem. In this example, we deﬁne the Travelling Salesman
Problem (TSP). Secondly, based on the nature of the problem we need to
choose the most suitable algorithm to ﬁnd a solution. In our example, we can
consider the quantum approximation algorithm [11]. This algorithm was pro-
posed to ﬁnd the optimal solutions using the gate model. Next, the quantum
algorithm has to be implemented in quantum code which is then compiled into
a quantum circuit consisting of quantum gates. Finally, the quantum circuit
will be executed on a quantum computer or a simulator running on a classical
computer.

1 import qiskit as q
2 # create register to store bits
3 qr = q . Qu antumRegister (2)
4 cr = q . Cla s sic alR egi ste r (2)
5 # create the circuit
6 circuit = q . QuantumCircuit ( qr , cr )
7 # 0 th index on the quantum register
8 circuit . h ( qr [0])
9 # apply CX gate ( control_bit , target_bit )
10 circuit . cx ( qr [0] , qr [1])
11 # measure quantum bit into cassical bit
12 circuit . measure ( qr , cr )

Listing 1: Quantum code example based on Qiskit that produces the quantum
circuit shown in Figure 1

6

Mohamed Raed El Aoun et al.

Fig. 2: Quantum software workﬂow on a gate-model quantum computer [13]
.

Listing 1 shows a code snippet based on the Qiskit python library that
produces the quantum circuit shown in Figure 1. First, we import the Qiskit
library (line 1). Then, lines 3 and 4 create 2 qubits and 2 classical bits which
form a quantum circuit in line 6. Line 8 applies the Hadamard (H ) gate on
the ﬁrst qubit, which generates a superposition of the qubit with equal prob-
abilities of being 1 and 0. Then, line 10 applies a controlled-NOT (CX ) gate
on the output of the Hadamard gate and the second qubit, which generates
entanglement between the two qubits. Finally, line 12 measures the ﬁnal states
of the two qubits and maps the measurement results to the two classical bits.

2.3 Quantum computing ecosystem

Fig. 3: Quantum computing ecosystem overview.

Bug Characteristics in Quantum Software Ecosystem

7

Quantum computing aims to solve problems that are challenging for a clas-
sical computer using principles of quantum mechanics. The Quantum comput-
ing ecosystem is starting to take shape, coalescing around hardware (quantum
computers), software such as quantum programming frameworks, quantum
programming languages, utility tools, and libraries (i.e., testing, error mitiga-
tion). In Figure 3, we present an overview of the state of the quantum ecosys-
tem nowadays. This overview was inspired by Qiskit [1], IBM-Q [20], and an
online article [12]. From Figure 3, we can see that the quantum ecosystem has
two diﬀerent layers. A physical layer that includes both quantum and classi-
cal hardware, as well as a logical layer that covers the quantum computing
software. The physical layer contains:

– Physical quantum processor: A quantum circuit on a chip with a size of
hundreds of nanometers of quantum elements such as atoms and molecules
known as qubit [14].

– Microwave pulse: Device used to generate pulses to control and measure

qubits fabricated on superconducting circuits [16].

– Quantum gates: Physical quantum gates and building blocks of quantum

circuits [4]

– Quantum limited ampliﬁer: Ampliﬁcation of the quantum signals (pulse)
while adding the minimum amount of noise tolerated by quantum mechan-
ics [37].

– Quantum error correction: Encode the logical qubits into multiple
physical qubits while protecting the quantum states and actively correcting
the errors [9].

– Classical computer: Traditional computer stores information in classical

bits that are represented logically by either a 0 (oﬀ) or a 1 (on) [40].

The logical layer contains:

– Simulator: Libraries and software to simulate the quantum computer be-

havior on a classical computer.

– Compiler: Tools and software used to compile and optimize the quantum

circuits.

– Programming language: Quantum programming languages (e.g., Q# [21])
are implemented in development kits to support the development of quan-
tum algorithms.

– Gate operation: A set of unitary operations that are used to control the

state of qubits.

– Error mitigation: Libraries and algorithms for software-based quantum

error correction.

– Utility tools: Libraries that are used to support quantum software devel-

opment activities, such as testing and debugging.

– Quantum algorithms: A collection of quantum algorithms that runs on

top of a quantum computer or a simulator.

8

Mohamed Raed El Aoun et al.

3 Study Deﬁnition and Data Extraction Methodology

The goal of this study is to understand the characteristics of bugs occurring
in quantum software projects. The perspective is that of researchers and tool
builders interested in developing methodologies and tools to support the iden-
tiﬁcation and diagnosis of quantum software bugs. The context of the study
is 125 open-source quantum software projects hosted on GitHub. To achieve
the study’s goal, we proceed in three steps. First, in a preliminary study, we
examine the nature of quantum projects, comparing them to classical projects.
This preliminary study is important to identify the speciﬁc characteristics of
quantum projects that could aﬀect the bugs. Next, we conduct a quantitative
study, comparing the distribution of bugs in quantum software projects and
classical software projects, as well as developers’ eﬀorts in addressing these
bugs. Finally, we qualitatively studied a statistically representative sample of
quantum software bugs and build a taxonomy of quantum software bugs. Fig-
ure 4 depicts the methodology of our study. First, we collect quantum and
classical projects from GitHub. Then, we collect the pull requests and issues
of these projects using GitHub issues API. Next, we apply a set of heuristics
to identify quantum software project bugs and classical project bugs. Finally,
we perform open coding and apply statistical analysis to answer our research
questions. The following sections elaborate in detail on each of these steps.

Fig. 4: Overview of our study.

3.1 Quantum software projects collection

We followed two steps to collect quantum software projects.
Step 1: Searching candidate projects. To select representative projects
from the quantum ecosystem, we searched through the GitHub search API.
We used two ways to search for quantum software projects.

Bug Characteristics in Quantum Software Ecosystem

9

Fig. 5: Distribution of the number of
commits in quantum software projects
in the past year

Fig. 6: Distribution of the number of
commits in quantum software projects

– First, we conduct a keyword search using the GitHub search API. To
identify the quantum software projects in GitHub, we reduce our search
scope and select the projects with a description or a topic that contains the
word “quantum computing” (the word quantum computing is case sensitive
to not miss relevant projects).

– Next, we search for code that imported quantum programming libraries.
Our code search items Qcode contain import statements from popular quan-
tum computing libraries such as Qiskit and Cirq developed by pioneers
like Google and IBM. Using the search code feature, we search for Qcode
in the quantum projects source code to identify the quantum software
projects. Our searched items Qcode include: import qiskit, import cirq,
from cirq import, from qiskit import, import tensorflo-
w quantum, from tensorflow quantum import, from braket.circuits
import, import braket.circuits.

In addition, we limit our search results based on the following criteria:

– To allow us to better understand the issues and content of the projects,

the description of the project must be in English.

– Since we are looking to characterize the bugs in the quantum software

projects, the projects must have issues.

At the end of this step, we obtained QP −initial containing a total of 2,105

unique quantum project.
Step 2: Filtering collected projects. We ﬁlter QP −initial, the collected set
of quantum software projects following guidelines proposed by Kalliamvakou et
al [22]. Speciﬁcally, we selected projects based on their number of commits in
2021, their total number of commits, and their number of contributors.
These 3 criteria ensure that we identify the most active projects, remove the
abandoned projects, and ﬁlter out the quantum computing projects related to
documentation, lecture notes, and student assignments [22].

1. We keep projects with at least 51 commits to ensure that they have suﬃ-
cient development activity and to avoid student assignment [5] [6]. Figure
6 show the distribution of the total number of commits in QP −initial.

10

Mohamed Raed El Aoun et al.

Since the third quantile is 51, we used it as our threshold to ﬁlter the set
of projects QP −initial.

2. We select the projects with at least 17 commits in the past year (i.e.,
2021) to remove the abandoned and inactive projects. Figure 5 shows the
distribution of the number of commits in the past years in QP −initial. We
observe that 75% of the projects have less than 17 commits in the past
year, therefore we use this value as a threshold to ﬁlter the set of projects
QP −initial.

3. We retain projects with more than one contributor to avoid selecting toy

projects.

After applying these ﬁltering criteria, we manually inspected the remain-
ing projects’ descriptions and removed non-quantum projects (e.g,, projects
related to quantum physics, documentation, or lecture notes).

Finally, we ended up with a total of 125 projects (QP −f inal) that are

directly related to quantum computing.

3.2 Classical projects collection

To understand the quantum software projects’ characteristics, we need a base-
line for our analysis. Hence, we collected a set of classical software projects
comparable to the quantum software projects. From GitHub, we selected classi-
cal projects that have the range of number of stars, programming language,
number of watcher, similar to our quantum repositories and the repository
must have issues. As the number of projects in the extracted list of classical
software projects is very large, to have a representative baseline, we collected
a random sample of 324 projects using a 95% conﬁdence interval level and a
5% margin of error.

3.3 GitHub issues and pull requests collection

To identify the bugs and to uncover the cost to ﬁx a bug in the quantum soft-
ware projects, we collected the pull requests and issue reports for each of the
studied projects, using GitHub issues API which considers every pull request
as an issue. We collected the following ﬁelds: issue number, state, title,
repository url, issue url, pull request url, body, creation date,
close date, and merge date. Using GitHub issue API [18] for each project,
we extracted Binitial a total of 59,249 issues and pull requests from QP −f inal.
In the rest of the paper, refer to the issue reports and the pull requests as issue
reports or issues.

3.4 Identiﬁcation of quantum software projects bugs

To identify the bugs in GitHub issue reports, we ﬁrst map each issue with its
corresponding commit. For each project, we collect the related commits of each

Bug Characteristics in Quantum Software Ecosystem

11

issue report using the GitHub API. To identify the commit or list of commits
of an issue report, we look into the list of events of the issue report. If an issue
is referenced in a commit, the commit url will appear in the list of events with
the tag referenced. Therefore we collect the list of commit url that appears
in the issues event. We collect the commits of the issues report for each project
using the GitHub commit API and collect the following ﬁelds of each commit:
the commit message, the URL, the number of added, deleted or changed
ﬁles, and the contributor identification. The next step is to classify if
an issue in Binitial describes a bug or not. For this purpose, we proceed as
follows:

1. In GitHub, developers tag the issues using the Label ﬁeld. To identify
bugs, we select the issues that has the tag Label=bug or defect and ﬂag
the issues as a bug.

2. Following previous work [39], we deﬁne a set of keywords Kinitial ﬁx, er-

ror, crash, wrong, bug, issue, fail, correct to detect bugs.

3. For each issue report b ∈ Binitial, if b’s title or body or commit message
contains at least a word k ∈ Kinitial, b is ﬂagged as a bug. We ended up
with a set B1 of 18,084 bug reports at the end of this step .

4. To extend the set Kinitial and identify further potential bugs ∈ Binitial, we
select a random sample with 95% conﬁdence interval level and 5% marge
of error of the issues not ﬂagged as bugs, i.e., ∈ B1.

5. One author manually inspected the commits of the random sample of issue
reports and deﬁned an extended set of Kinitial. Then, during a meeting,
three authors discussed the validity of the new set of keywords. Finally, all
authors agreed on the ﬁnal set Kf inal ﬁx, error, crash, wrong, bug,
issue, fail, correct, exception, log, inf, insuﬃcientResource, broke,
resolve, abort, leak.

6. For each issue reports b ∈ B1, if b’s title, body or commit message contains
at least a word k ∈ Kf inal, b is ﬂagged as a bug. We obtained a set Bf inal
containing 19,564 bug reports.

As a result of the process, we ended up with a total of 19,564 bug reports
Bf inal that are related to quantum computing.

3.5 Classical projects bug extraction

We follow the same processes as described in Section 3.3 and Section 3.4 to
extract the bugs of the selected classical software projects. In the 324 classical
projects, we had a total of 60,779 issue reports in which we identiﬁed 13,165
bugs.

4 Preliminary study: Characteristics of quantum software projects

In order the understand quantum programming challenges, we ﬁrst want to
understand the nature of the quantum software projects. In particular, we want

12

Mohamed Raed El Aoun et al.

to understand the types of the projects and compare their characteristics (e.g.,
developer activities) with classical software projects.

4.1 Approach

Categorization of quantum software projects. To identify the categories
of quantum projects in GitHub, we manually analyzed the descriptions and
the documentation of all the projects. No prior taxonomy was used. For each
project, we assigned one label. In case a project is associated with more than
one categories, which occurred in a few cases, we chose the most representative
one. Two authors of the paper jointly performed the manual labeling. Each
project is labeled by both authors. We describe our labeling process below.

1. Initial labeling. Each author labels all the projects independently.
2. Discussion. To have a consistent labeling strategy, we scheduled a meeting
after the initial labeling and reached a consensus on the set of labels. A
third author of the paper is involved in the meeting.

3. Revising labels. Each author updated their labeling results after the

meeting.

4. Resolving disagreement. We had a ﬁnal meeting to resolve the dis-
agreement in the labeling results and reached a consensus for the label of
each project. For each mismatched label, the three authors discussed and
resolved the conﬂict.

Analyzing the characteristics of quantum software projects. We study
the characteristics of the quantum software projects as follows:

1. In order to understand the maturity of quantum software projects, we look
into the duration (i.e., from the creation date of the project until the
date of our data extraction), and to study the the activity in the quantum
projects, we look into the number of releases, number of commits, and
number of contributors. We used GitHub API [18] to collect these met-
rics for each studied project.

2. In order to understand the proﬁle of the developers of quantum software
projects, for each project we retrieve the user name of the contributors,
then for each contributor, with the help of the GitHub events API [18],
we look into its created events since the contributor joined GitHub. Fol-
lowing GitHub documentation [18], we select the events that describe the
activity of the developers. Speciﬁcally, we focus on the following events:
CommitCommentEvent, IssueEvent, IssueCommentEvent, PullRequestEvent,
and PushEvent.

Steps 1 and 2 are repeated on the sample of the classical software projects.

The results of the classical software projects are used as our baseline.

Bug Characteristics in Quantum Software Ecosystem

13

Fig. 7: Cumulative distribution
function of the quantum software
ecosystem projects over time (days)

Fig. 8: Comparison of the GitHub
activities of the developers of classical
and quantum projects

Table 1: Characteristics of the studied quantum projects.

Program Category

nbr of
projects
26

# of
releases
6.5

# of
commits
113.0

22

10.0

163.5

Quantum circuit simulators
Quantum programming
framework
Quantum algorithms
Quantum utility tools
Quantum compilers
Quantum machine learning
Quantum circuit simulator
Experimental quantum
computing
Quantum-based simulation
Quantum fun
Quantum projects
Classical projects
# all values are median values in the projects in that category

7.0
7.0
3.0
2.0
19.0

16.5
15.0
8.0
12.0

2
1
125
324

19
19
9
8
7

129.0
126.0
179.0
217.0
29.0

459.0
88.0
131.0
268.0

147.0

10.0

7

# of
contributors
5.0

24.0

9.0
6.0
10.0
9.0
15.0

15.0

84.5
3.0
8.0
2.0

LOC

19,145

49,981

26,530
27,830
175,364
33,705
87,316

66,088

92,819
3,938
34,188.0
15,357.0

# of
languages
9.0

12.0

9.0
9.0
16.0
10.0
13.0

13.0

14.5
8.0
10
7

4.2 Results

Quantum software projects have been steadily increasing in recent
years. Figure 7 shows the number of quantum software projects over time.
We observe a signiﬁcant increase in the number of projects after 2016. The
increase may be explained by the rapid development of quantum computing
technologies in recent years. In 2017, IBM announced a working quantum com-
puter with 50 qubits, that can maintain its quantum state for 60 microseconds
[24]. Microsoft released its Q sharp programming language [21] in the same
year. In 2018, IonQ released its ﬁrst commercial trapped-ion quantum com-
puter [32]. In 2019, IBM released its ﬁrst commercial quantum computer, the
IBM Q System One [2].

We derived 9 categories of projects in the quantum comput-
ing software ecosystem covering quantum programming frameworks,
simulators, tools, implementations of quantum algorithms, and ap-
plications such as machine learning. Table 1 shows the characteristics of
these quantum software projects by category. Below, we describe each category
of projects.

Quantum circuit simulator: Libraries that are used to simulate quantum
computation on a classical computer.

14

Mohamed Raed El Aoun et al.

Quantum programming framework: A set of development kits, languages and
libraries such as Q# [21], Qiskit [1] and pyEPR 1 for quantum programming
and quantum circuits design.
Quantum algorithms: Projects that provide one or more implemented quan-
tum algorithms (i.e., grove2).
Quantum machine learning: A set of libraries for implementing hybrid quantum-
classical machine learning models. For example, TensorFlow Quantum (TFQ)3
is a quantum machine learning library for prototyping hybrid quantum-classical
ML models.
Quantum compilers: Tools used for the synthesis, compilation, and optimiza-
tion of quantum circuits (i.e., QGL2 Compiler4).
Quantum utility tools: Libraries and tools used to support quantum pro-
gram development such as monitoring the load in quantum computers, API
interface used to connect with quantum devices, or libraries dedicated for
speciﬁc task development in the quantum programming workﬂow (i.e, state
preparation, circuit visualization).
Experimental quantum computing: Libraries used for research and experi-
mental calculation (i.e., artiq Compiler5).
Quantum games: Games developed using quantum programming that run on
simulators or quantum computers.
Quantum based-simulation: Libraries used for simulating quantum physics
experiments on a quantum computer.

Table 1 shows diﬀerent metrics about the 125 studied projects and their
distribution, along with the deﬁned quantum ecosystem categories; including
the number of releases, number of contributors, number of commits, number
of lines of code (LOC), and number of programming languages used in the last
release of the project.

As shown in Table 1, the largest number of projects fall into the quantum
circuit simulators category with 26 projects. As quantum computers are
still not conveniently accessible to the public, simulators are widely used to
execute quantum programs. Moreover, quantum programming frameworks is
the second most frequent project category with 22 projects. As quantum
computing is getting more popular, programming frameworks are starting to
emerge. Quantum algorithms and quantum utility tools are the third
most occurring categories with 19 projects for each. Quantum programming
frameworks and utility tools are important to unlock the full potential of
quantum computing systems. In Table 1, we observe that quantum software
projects have a lower level of maturity (in terms of development activities)

1 https://pyepr\protect\discretionary{\char\hyphenchar\font}{}{}docs.

readthedocs.io/en/latest/

2 https://github.com/Seeed\protect\discretionary{\char\hyphenchar\

font}{}{}Studio/grove.py

3 https://www.tensorflow.org/quantum
4 https://github.com/BBN\protect\discretionary{\char\hyphenchar\font}{}{}Q/

pyqgl2

5 https://m-labs.hk/experiment-control/artiq/

Bug Characteristics in Quantum Software Ecosystem

15

with a respective median number of commits and releases of 131 and 8, in
comparison to classical projects which have a 268 median number of commits
and 12 median number of releases.

Quantum software project developers show a similar level of
activities as that of classical software developers. In order to under-
stand the activities of quantum project developers, in Figure 8 we compare
the activities of quantum software projects and classical projects contribu-
tors by studying the developer’s activities on GitHub since their registra-
tion in GitHub. Note that the quantum software projects and classical soft-
ware projects are selected using the same criterion. We select ﬁve dimen-
sions of activities from the GitHub event API : commit on the commits,
issues comments, created issues, created pull requests, push event
(i.e., commit and pull request). We chose these ﬁve dimensions because they
describe how active a developer is in GitHub since joining. We observe some
similarities between classical program developers and quantum program devel-
opers across the ﬁve dimensions. For example, quantum software developers
and classical software developers have the same number of issue event with
a median value of 3. However, quantum program developers are more active
in other GitHub activities. From Figure 8, we observe that quantum develop-
ers have a slightly higher number of issues comments event, pull request
event, and push event. These results show that developers of quantum soft-
ware projects put more eﬀort and face more issues. This observation motivated
our investigation of the bug-proneness of quantum software projects. We also
investigate how developers address bugs in quantum programs, as well as the
types and location of bugs in these programs.

Quantum software projects become increasingly popular on GitHub.
We observe a diverse range of quantum software projects, including
quantum programming frameworks, tools, algorithms, and applica-
tions. We also observe that developers of quantum software projects
are more active and face more issues in quantum programs.

5 Characteristics of Bugs in Quantum Programs

In this section, we report and discuss the results of our two research questions.
For each research question, we present the motivation, the analysis approach,
and the obtained results.

5.1 How buggy are quantum software projects and how do developers
address them?

5.1.1 Motivation

In order to understand the characteristics of quantum software bugs, we ﬁrst
want to understand the extent to which quantum software projects are buggy,

16

Mohamed Raed El Aoun et al.

as well as how eﬀectively developers address these bugs and their eﬀorts in
such activities.

5.1.2 Approach

Following the process described in Section 3, we identiﬁed the bugs in the
selected quantum software projects and classical software projects. To under-
stand how developers address them, we further identify the ﬁxed bugs, as well
as the ﬁxing time and the associated eﬀorts.
Identifying ﬁxed bugs. A bug report is a GitHub issue report describing a
bug. In GitHub, not all closed bug reports are solved. In some cases, a bug
report can be closed while the problem persists. Thus, we had to identify the
ﬁxed and non-ﬁxed bugs. We followed 3 steps to classify the bug reports.
1. Filtering the open issue reports. Using the state ﬁeld in the issues

reports, we kept only the closed issues.

2. Identifying ﬁxed bugs. Following previous work [8] [39], we looked for
the set of keywords Ff ix in the GitHub issue report message and its
corresponding commits: closes, close, closed, resolve, resolves,
resolved, fix, fixes, fixed. To identify the ﬁxed bugs, for each closed
GitHub issue report, in the commit message, we look if it contains f ∈ Ff ix.
If the commit message contains at least one of the keywords we ﬂag it as
Fixed.

3. Manual veriﬁcation. One author inspected a sample of 382 ﬁxed bugs
with a 95% conﬁdence level and 5% marge of error. We found that our
identiﬁcation of ﬁxed/non-ﬁxed bugs has a precision of 1 and a recall equal
to 0.97.

Bug ﬁxing rate. For each quantum or classical project, we calculate the bug
ﬁxing rate by dividing the number of ﬁxed bugs by the total number of closed
bugs (including ﬁxed bugs and bugs closed without a ﬁx) in that project.
Bug ﬁxing duration. For each ﬁxed bug, we measure the bug ﬁxing duration
by calculating the diﬀerence between the bug ﬁxing time and the bug creation
time.
Bug ﬁxing eﬀort. To measure the eﬀort involved in a bug ﬁx, we collected
the code changes of the commits that contributed to the bug ﬁx. A change in a
commit is an added or deleted code line. We also collected information about
the number of changed ﬁles in the commits, which can be an added, modified,
renamed or deleted ﬁle. For each bug ﬁx, we measured two metrics:
– Number of changed ﬁles: the added, modified, renamed, and deleted

ﬁles in the commits that contribute to a bug ﬁx.

– Number of changed lines of code: The number of added and deleted

code lines in the commits that contribute to a bug ﬁx.

5.1.3 Results

Quantum software projects show more bugs (with a median number
of 28 bugs) than classical software projects (with a median number

Bug Characteristics in Quantum Software Ecosystem

17

Table 2: Distributions of bugs and bug ﬁx ratio in quantum software projects

Project category

# of bugs

# Bug ﬁx
ratio

Hours
to ﬁx a bug

# ﬁle changed
in a commit

# LOC changed
in a commit

104.0

168.5

406.0

0.628

0.500

Quantum-based
simulation
Experimental quantum
computing
Quantum Machine
learning
Quantum programming
framework
Quantum algorithms
Quantum compilers
Quantum circuit
simulators
Quantum utility tools
Quantum projects
Classical projects
# all values are median values in the projects in that category

0.689
0.725
0.789

21.0
28.0
13.0

0.657
0.572

72.0
36.0

0.736

0.523

0.513

88.0

26.0

33.94

27.98

66.05

34.60

25.01
20.72

20.61

15.40
23.5
21.1

2.00

2.00

2.00

2.00

1.50
2.00

2.00

2.00
2.00
2.00

63.00

12.00

38.0

30.00

15.00
28.00

20.00

11.00
19.00
14.00

of 13 bugs). Table 2 provides a summary of the bugs in quantum software
projects and the distribution of the bugs along with the project categories. A
median of 28.0 bugs per project was detected in the studied quantum soft-
ware projects, which is two times higher than the median number of bugs
in the classical software projects. In light of these values, quantum programs
are more buggy than classical programs. The higher number of bugs in a
quantum project may be explained by the fact that quantum computers are
error-prone and the output of quantum software is often noisy. In particular,
the quantum projects (e.g., projects in the categories of quantum-based simu-
lation, experimental quantum computing, and quantum machine learning) are
the most buggy projects. This observation may be explained by the fact that
these quantum projects categories rely more on quantum computing theories.
Since there are no prior collection of mathematical algorithms for quantum
theories and convenience functions that developers can leverage, the develop-
ers of quantum programs may be prioritizing the correct implementation of
these complex theories over the quality of their code.

The median value of the bug ﬁx ratio in Table 2 shows that 27.5% of the
quantum software bugs are closed but not ﬁxed, compared to 21.1% of classical
software bugs which are closed without a ﬁx. One author manually inspected
a statistically representative sample of 382 closed-but-not-ﬁxed bugs, repre-
senting a 95% conﬁdence level and 5% conﬁdence interval, to understand why
these bugs are closed without a ﬁx. We noticed that in some cases developers
don’t follow the best practices of GitHub and mention the issue number in
the commit message with the ﬁxing keywords, which makes detecting the bug
ﬁxes from commit messages diﬃcult. As an example, we present issue number
5148 in Qiskit6. Besides, in some issue reports, enhancements were labeled as
bugs for future releases and closed by developers without notice in commit
messages. For example, the issue id 20 in the qutip7. Finally, we detected bugs
that were closed because developers could not provide a ﬁx, or it is diﬃcult to
reproduce the bug. For example the issue number 402 in Cirq8.

6 https://github.com/Qiskit/qiskit-terra/issues/5148
7 https://github.com/qutip/qutip/issues/20
8 https://github.com/quantumlib/Cirq/issues/402

18

Mohamed Raed El Aoun et al.

Developers of quantum software projects are actively addressing
the bugs in their projects. Figure 9 show a comparison of the empirical
distribution function of the duration to ﬁx a bug in days. The ﬁgure shows that
bugs in quantum software projects are ﬁxed at a similar speed as in classical
software projects, with 50% of bugs ﬁxed in less than 1 day and 90% of bugs
ﬁxed within 48 days, indicating that developers of quantum software projects
are actively maintaining their projects.

Quantum machine learning, Quantum based-simulation, and Experi-
mental quantum computing are more buggy than other categories. Ta-
ble 2 shows the median number of bugs across quantum software projects cate-
gories and the cost to ﬁx them. We observe that quantum based-simulation
projects have the highest median ﬁxed bugs with the value of 406.0, how-
ever, we also observe a low median bug ﬁx ratio compared to other categories
even though this category has a high median number of contributors as ob-
served in Section 4. Quantum machine learning, quantum algorithms and
application, and Experimental quantum computing categories have the
highest bug ﬁxing rate with respectively a median bug ﬁx proportion (ratio)
of 0.736, 0.657, and 0.628, meaning that those two categories are the least dif-
ﬁcult for developers to ﬁx. The highest number of bugs is for quantum-based
simulation projects. There are almost two times more bugs in this category of
quantum programs in comparison to the other projects, indicating that these
projects need more support from the community for testing and debugging.
In the quantum-based simulation category, programs are trying to simulate
quantum mechanics and physics in a quantum computer, for this purpose de-
velopers have to implement mathematical equations, which may be complex
for developers; inducing more bugs.

As quantum programming is still low-level, bug ﬁxing is costly
in terms of code changes compared to classical programming. Fixing
a bug in a quantum program requires larger code changes than ﬁxing bugs in
classical programs. Table 2 shows that quantum programs have a median code
line change of 19, while classical programs have a median code line change
of 14.00. We attribute this situation to the low-level programming language
used in quantum programming. Quantum software engineers write their code
at the gate level which is similar to the logic gate for classical software. This
produces more coupling between the elements in the code which can lead to
more changes. Since quantum programming is probabilistic in nature, classic
assertions and testing techniques can’t be used; resulting in a lack of support
for testing and debugging.

Bugs in Quantum machine learning, Quantum programming framework,
Quantum-based simulation are the most challenging to ﬁx. Duration is
the time diﬀerence between when an issue report was created and closed.
In Table 2, we observe that the projects from Quantum machine learning,
Quantum programming frameworks, and Quantum-based simulation cate-
gories appear to take the longest time to ﬁx with the respective median number
of hours to ﬁx the bug of 66.05, 34,90, and 33,94. Also, the category Quantum
based-simulation has the highest median number of lines of code changed in

Bug Characteristics in Quantum Software Ecosystem

19

Fig. 9: Cumulative distribution function of duration to ﬁx a
bug through time (days).

a commit with 63.00 median code line changed. Moreover, Quantum machine
learning and Quantum programming frameworks show a high median num-
ber of lines of code changed to ﬁx a bug.

The quantum software projects are more buggy than classical software
projects. While developers of quantum software projects are actively
addressing their bugs, ﬁxing quantum software bugs is more costly than
ﬁxing classical software bugs. Our results indicate the need for eﬀorts
to help developers identify quantum bugs in the early development
phase (e.g., through static analysis), to reduce bug reports and the cost
of bug ﬁxing. Projects in the quantum machine learning, quantum
programming framework, and quantum-based simulation categories
are the most buggy and have the most diﬃcult bugs to ﬁx.

5.2 What are the characteristics of quantum software bugs?

5.2.1 Motivation

Quantum programs’ execution ﬂow is diﬀerent from that of classical programs.
To understand the challenges in the quantum computing ecosystem, it is im-
portant to understand how bugs are distributed among the diﬀerent compo-
nents of the programs.

5.2.2 Approach

To identify the diﬀerent types of bugs occurring in quantum programs and
the principal components of the quantum program execution ﬂow where the
bugs occurred, we performed a manual analysis of a statistically representative
sample of bugs detected in RQ1. We performed a stratiﬁed sampling over

20

Mohamed Raed El Aoun et al.

Fig. 10: General components in a hybrid quantum program application

the quantum program categories, to ensure covering a wide range of bugs.
Speciﬁcally, 1) we compute the sample size from the number of ﬁxed bugs
with a 95% conﬁdence level and 5% interval which result in a sample size of
376. 2) We calculate the log number of issues per category. 3) We compute the
project category weight: the normalized log number of bugs of the category
divided by the log of the total number of ﬁxed bugs. 4) Finally, we compute the
sample size from each project category: the total sample size (376) multiplied
by the corresponding weight.

After creating the sample, for each bug report, we examine the title, body,
and comments to understand the bug reported by the user. We used the hybrid-
card sorting approach to perform the manual analysis and assign labels (i.e.,
type of bug and quantum program component) to each sampled bug. To assign
the bug type, we based our manual analysis on an existing taxonomy of the
type of bugs reported on GitHub [8] and added new types when needed. For
each bug report, we assigned one label, in case a bug is associated with two or
more labels, which we found only in a few cases, we choose the most relevant
one.

We performed the labeling through two rounds as follows:

1. First-round labeling. One coder labels the bugs independently.
2. First-round discussion. In order to have a consistent labeling strategy,
the ﬁrst three authors of the paper had a meeting to discuss the labeling
results in the ﬁrst round and reached an agreed-upon set of labels.

3. Revising ﬁrst-round labels. The coder updated the ﬁrst round labeling

results based on the meeting.

4. Second-round discussion. The ﬁrst three authors of the paper had an-
other meeting to discuss the revised labels, validate the updated labels and
verify the consistency of the labels.

5. Revising second-round labels. Based on the second-round discussion,

the coder revised the labels.

Bug Characteristics in Quantum Software Ecosystem

21

Table 3: Distribution of the quantum component bugs across the quantum
software categories. (In the 376 analyzed bug reports, 43 reports were not
identiﬁed as bugs.)

VIS

SP

GO

Post-P

Pre-P

EM

CP

MS

PC

SM

MN

QCA

O

# bugs

Quantum programming
framework
Experimental quantum
computing
Quantum algorithms
Quantum circuit
simulators
Quantum compilers
Quantum utility
tools
Quantum-based
simulation
Quantum Machine
learning

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

Total Bugs

15

40

56

17

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

9

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

15

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

68

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

19

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

58

47

34

43

37

41

38

35

17

10

2

25

40

333

5.2.3 Results

We identiﬁed bugs in 12 quantum computing components. Figure 10
shows the 12 quantum computing computing components where bugs were
identiﬁed which are mapped to a quantum-classical hybrid computing struc-
ture. Prior work [38] identiﬁed ﬁve components : pre-processing, post-pro-
cessing, gate operation, state preparation, and measurement. In Fig-
ure 10, we extended the component set to ﬁnally have 12 components. In Table
4, we show the distribution of the bug type across the quantum components.
In the following, we discuss each quantum component in more details.

– Compiler (CP) translates the quantum program circuit into device-level
language. From Table 3, we observe that compiler component issues are
present in all the quantum ecosystem software categories with a total of
68 bugs. From table 4, we observe that the four most occurring bug types
are program anomaly (23 bugs), test-code related (12 bugs), data type and
structures (11 bugs), and conﬁguration (11 bugs).

– Gate operation (GO) is a set of reversible operations that alter the state
of the qubit and generate superposition. These reversible gates can be rep-
resented as a matrix. Gate operations are based on complex mathematical
operations using imaginary numbers. Translating the maths into code is
challenging for developers which increases the chances of errors. Table 3
shows that gate operations component is the second most buggy with
56 bugs detected in our sample. Table 4 illustrate that in this compo-
nent, we have the two occurring bug types which are program anomaly
and data-type and data structure. They respectively occur 27 and 7
times.

– Simulator (SM) simulates the execution of a circuit on a quantum com-
puter. Since quantum computers are still not conveniently accessible by the
public, simulators are widely used by quantum developers. We identify 10
bugs spread across the quantum programming framework, experimental
quantum computing, quantum circuit simulators, and quantum uti-
lity tools. We observe that the bugs are characterized mostly by missing

22

Mohamed Raed El Aoun et al.

Error handling and performance bugs with 2 bugs at each type as
shown in table 4.

– State preparation (SP) is an operation to generate an arbitrary state
of the qubit. As can be seen in Table 3, state preparation has the third-
highest number of bugs with 40 bugs. The bugs appear in all the project
categories except quantum compilers and quantum utility tools cate-
gories. During the state preparation phase, one tries to give the qubit an
arbitrary state of 0 or 1. For this purpose, one tries to rotate or control
the qubit into the desired state. As an example, one can use gate decom-
position as a technique for state preparation. In Table 4, we observe that
program anomaly is the most dominant bug type with 21 bugs, while data
type and structure come second with only 5 bugs. However, we detected a
rare bug of missing error handling type. Quantum states are mathematical
entity that provide a probability distribution for each outcome of a state
measurement. Since a qubit can have multiple states, mathematically they
are represented as matrices. To initialize the state of a qubit, one has to
manipulate that matrix. The number of state preparation bugs indicates
the diﬃculty that developers are having with implementing the quantum
algorithms. These bugs can be addressed with the help of data reﬁnement
and veriﬁcation tools. Also, missing error handling bugs can be avoided by
encouraging quantum developers to test their code.

– Measurement (MS) measures the ﬁnal state of a qubit after superposition.
We identiﬁed 19 bugs present in six of the quantum software categories as
presented in Table 3. Six bug types were detected in our sample. From table
4 Program anomaly bugs are the most occurring with 12 bugs. Also, we
identiﬁed 3 configuration bugs and 2 data type and structure bugs.
– Post-processing (Post-P) translates the quantum information (i.e., mea-
surement probability) to classical computer bits. We detected 17 bugs re-
lated to post-processing distributed among all the quantum software cat-
egories except experimental quantum computing and quantum compi-
lers as highlighted in the table 3. In table 4 we observe 9 program anomaly
bug and 3 gui related bugs.

– Pre-processing (Pre-P) generates the state preparation circuit and ini-
tializes the register of the quantum computer. This component is executed
on classical computer. We detected 17 bugs related to post-processing
distributed among all the quantum software categories except experimen-
tal quantum computing and quantum compilers as highlighted in Table
3. In Table 4, we observe 9 program anomaly bugs and 3 GUI related
bugs.

– Pulse control (PC) generates and controls signals to create custom gates
and calibrate the qubits. From Table 3, the pulse control component reg-
istered 17 bugs during the manual analysis. Pulse control bugs generally
appear when a developer would like to deﬁne a custom gate and manually
calibrate the qubits. For this purpose, developers need to generate a pulse
(signal) and a scheduler to calibrate the qubit. From Table 4, it appears

Bug Characteristics in Quantum Software Ecosystem

23

that the two most occurring bug types in pulse control components are
program anomaly and test-code related.

– Error mitigation (EM) corrects the measurement error when computing
the qubit state probability. From Table 3 we identiﬁed 15 error mitigation
bugs distributed along 5 quantum software categories. Among the identiﬁed
bugs we have detected 5 program anomaly bugs and 4 test-code related
bugs as shown in Table 4.

– Quantum cloud access (QCA) is a client interface to connect to a quan-
tum cloud service provider. Cloud service providers like Amazon, Microsoft,
and IBM provide access to quantum computers. We have detected 25 bugs
related to the access to these quantum resources. Configuration bugs are
the most occurring bug type with 8 bugs and program anomaly bugs are
the second most frequent bug type in this category, with 5 bugs as shown
in Table4.

– Visualisation (VIS) creates plots and visualisations. Quantum devel-
opers use visualization to represent qubit states graphically and examine
quantum state vectors and the transformation actions. Drawing the circuit
is the last step when building a quantum program. We identiﬁed 15 bugs
in the visualization component, that appear in all the quantum programs
categories except the quantum compilers. Among the detected bugs, 8
belong to the GUI related bugs category as shown in Table 4.

– Monitoring (MN) controls the good execution of the program and the per-
formance of the execution environment. Only 2 bugs were assigned to the
monitoring component, which appears in two quantum software categories
(Quantum circuit simulation and Quantum-based simulation).

– Other (O): Every bug that occurred elsewhere other than the deﬁned com-

ponents.

The result of our qualitative analysis for identifying the bugs in the quan-
tum program software component is presented in the Table 3. Among the 376
analyzed bug reports, 43 questions reported bugs were not real bugs.

We identify 147 bugs in 5 components that are directly related to quantum

computing including gate operation, state preparation, measurement,
pulse control, and error mitigation, ordered by their number of bugs.
Moreover, the simulator shows a slightly high number of bugs (classical and
quantum bugs), this can be explained by the complexity of the operation that
has to be simulated since they are trying to simulate quantum physic phe-
nomena using very complex linear algebra calculation. Finally, the compilers
appear to be the most buggy with 63 bugs identiﬁed.

We identiﬁed a variety of 12 quantum computing components in
including both quantum computing-
which bugs were discovered,
related bugs and classical-related bugs. We identiﬁed quantum-related
bugs in ﬁve components (gate operation, state preparation,
measurement, pulse control, and error mitigation.), among which
gate operation is the most buggy component.

24

Mohamed Raed El Aoun et al.

Table 4: Distribution of bug types across the quantum component

Configuration bugs
Data types and structures bugs
Missing Error handling
Performance bugs
Permission/deprecation bugs
Program anomaly bugs
Test code-related bugs
DataBase related bugs
Documentation
Gui related bugs
Misuse
Network bugs
Monitoring

VIS
3
3
-
-
-
2
-
-
-
8
-
-
1

SP
3
5
1
-
-
20
2
-
1
3
2
-
-

GO
4
10
-
3
2
30
4
-
3
1
1
-
-

Post-P
-
1
-
1
1
9
-
-
-
3
-
-
-

Pre-P
-
3
-
1
-
4
-
-
-
-
-
-
-

EM
2
-
1
3
-
5
4
-
-
-
-
-
-

CP
11
12
4
3
1
26
12
-
-
-
-
-
-

MS
3
2
-
1
-
12
1
-
-
-
1
-
-

PC
1
2
3
1
-
6
4
-
-
-
-
-
-

SM
2
1
2
2
-
1
-
-
1
-
-
-
-

MN
-
-
-
-
-
-
1
-
-
-
-
-
-

QCA
8
2
2
1
1
5
-
-
1
-
1
1
-

O
10
5
-
3
2
2
5
1
11
-
-
-
-

# bugs
47
46
12
19
7
123
33
1
17
15
2
1
1

We identiﬁed 13 bug types in the quantum software ecosystem.
Table 4 shows the distribution of these bugs across quantum components. In
the following, we discuss each type of bugs in more details. In our replication
package [36], we provided more details and examples of diﬀerent types of bugs
in diﬀerent quantum computing components.

Program anomaly bugs are introduced when enhancing existing code or
caused by prior bad implementations. The manifestation of these bugs can be
a bad return value or unexpected crashes due to logical issues in the code. For
example in the Pre-processing component, to execute quantum programs
eﬃciently, data is embedded into quantum bits. Speciﬁcally, the classical data
is mapped into n-qubit quantum states by transforming data into a new space
where it is linear. For example, AmplitudeEmbedding is a mapping technique
in PennyLaneAI in which a bug9 was reported and it took 6 days to ﬁx. In
the code from Listing 2(a), the normalization in the embedding function is
breaking the diﬀerentiability for any data that is encoded as a TensorFlow or
Pytorch tensor which triggers the error shown in Listing 2(b). Developers have
tried pre-implemented normalization techniques in NumPy and TensorFlow but
the bug persisted. The only solution left was to hand-code the normalization
as illustrated in the bug ﬁx code from Listing 2(c). Providing the quantum
computing community with libraries dedicated to linear algebra computation
in quantum will support the progress of quantum programming.

Test-code related bugs are happening in the test code. Problem re-
ported due to adding or updating test cases and intermittently executed tests.
For example, in the pulse control component, Test code-related bug is the
second most occurring bug type. In Qiskit bug report number 252710, a
unitest is failing because of a wrong parameter type. The expected input vari-
able type in this test should be int, ﬂoat, or complex. Therefore to ﬁx the bug,
a developer changed the parameter type from String to Integer as shown in
Listing 3.

Data type and structure bugs are related to data type problems such
as undeﬁned or mismatch type and data structure bugs like bad shape bugs
or the use of wrong data structures. For example, in qibo, we identiﬁed a
bug that states : “Probabilities do not sum to 111” when running a cir-
cuit with more than 25 qubits. Listing 4(a) presents the buggy code along

9 https://github.com/PennyLaneAI/pennylane/issues/365
10 https://github.com/Qiskit/qiskit-terra/issues/2527
11 https://github.com/qiboteam/qibo/issues/517

Bug Characteristics in Quantum Software Ecosystem

25

1 import numpy as np
2 import pennylane as qml
3 from pennylane . templates . embeddings import A m p li t ud eE m be d di ng
4
5 dev = qml . device ( ’ default . qubit ’ , wires =3)
6 @qml . qnode ( dev )
7 def circuit ( data ) :
8 # Amplitude embedding normalization function not behaving as

expected ( Bug trigger )
A mp l i t u d e Em be d di n g ( data , wires =[0 , 1 , 2])
return qml . expval . PauliZ (0)

9

10

11
12 data = np . ones ( shape =(8 ,) ) / np . sqrt (8)
13 circuit ( data )

(a) Trigger of the bug ”PennyLaneAI (issue id 365)”

1 TypeError : unsupported operand type ( s ) for +: ’ Variable ’ and ’

Variable ’

1 # Repository : PennyLaneAI / pennylane
2 # Fix file : pennylane / templates / embeddings . py , method :

AngleEmbedding , line : 118

(b) Error message

features = features * (1/ np . linalg . norm ( features , 2) )

3 - if normalize and np . linalg . norm ( features , 2) != 1:
4 -
5 + norm = 0
6 + for f in features :
7 + if type ( f ) is Variable :
8
9 + else :
10

+ norm += np . conj ( f . val ) * f . val

+ norm += np . conj ( f ) * f

(c) Proposed bug ﬁx
Listing 2: The execution of the code snippet (shown in (a)) triggers a message
error (shown in (b)) because Amplitude embedding normalization in NumPy
is too strict and does not allow small tolerance. The bug ﬁx was to redeﬁne
the normalization function (as shown in (c))

with the error message and the proposed bug ﬁx. As can be seen, the prob-
lem has occurred because the sum() function does not return a normalized
set of probabilities distribution. To ﬁx the problem, a developer proposed to
cast the tensor into type tf.complex128. This bug was caused by a data
type and structure bug in the measurement component. Quantum software
programs algorithms are based on probability and linear algebra which makes
the implementation of quantum algorithms complex for developers. Therefore,
providing libraries with array and data manipulation for quantum and data
validation tools can help the quantum software engineering community.

Missing error handling occur when exceptions are not handled by the
program. Improper error handling can lead to serious consequences for any
system, and the quantum software systems are not an exception. For example,
in qutip, we detect the absence of error handling in the simulator. An issue

26

Mohamed Raed El Aoun et al.

# Repository : Qiskit / qiskit - terra
# Fix File : qiskit - terra / test / python / pulse / test_cmd_def . py
# Class : TestCmdDef , method : test_parameterized_schedule , line :
86
# Bug triggered in line 4 and 8
- sched = cmd_def . get ( ’ pv_test ’ , 0 , ’0 ’ , P2 = -1)
+ sched = cmd_def . get ( ’ pv_test ’ , 0 , 0 , P2 = -1)
self . assertEqual ( sched . instructions [0][ -1]. command . value , -1)
with self . assertRaises ( PulseError ) :

- cmd_def . get ( ’ pv_test ’ , 0 , ’0 ’ , P1 = -1)
+ cmd_def . get ( ’ pv_test ’ , 0 , 0 , P1 = -1)

1

2

3

4

5

6

7

8

9

10

11

Listing 3: The execution of the test building parameterized schedule fails
because of the wrong parameter type (as shown in code snippet line 1 and 5).
The bug ﬁx was to change the parameter type from string to integer “qiskit
(issue id 2527)”

that led to the bug report id 396 12. The application crashed during the cre-
ation of a device object if the methods or attributes of this object contained an
error. This issue was ﬁxed by adding an exception block as shown in Listing 5.
This bug ﬁx occurred quickly (1 day) and not much code change was required.
Improper error handling can be costly and lead to data leaks and many other
exploits in the code. Therefore, developers must be careful regarding when,
where, and how to correctly handle errors in the code. Code analysis tools for
error handling and logging recommendation can support the quantum program
development and help avoid missing error handling bugs.

Configuration bugs are related to conﬁguration ﬁles building. The bug
can be caused by the external library that must be updated or incorrect
ﬁles paths or directories. For example, in the Quantum cloud access compo-
nent, The bug in the code from Listing 6 happened in DWave cloud access
service when trying to obtain the list of solvers. However, the list of solvers
is ﬁltered by the client type. To locate and ﬁx the bug, developers spent 14
days 13. Their proposed ﬁx is shown in Listing 6.

GUI related bugs are related to graphical elements such as layout, text
box, and button layout. Quantum circuits are the main focus when building a
quantum program. It can be challenging to debug and–or validate the structure
of a quantum circuit by only reading the code. Libraries like Cirq and Qiskit
oﬀer visualization features to draw the architecture of circuits. The drawing
is meant to depict the physical arrangement of gates, wires, and components.
The visualization functions in Qiskit are basic support modules and can come
with bugs. For example, the bug report14 in Qiskit is stating misaligned
barriers in the circuit, which change the interpretation of the circuit. In the
code presented in Listing 7, we show a bug in Qiskit that occurred when a user

12 https://github.com/m-labs/artiq/issues/396
13 https://github.com/dwavesystems/dwave-cloud-client/issues/457
14 https://github.com/Qiskit/qiskit-terra/issues/3107

Bug Characteristics in Quantum Software Ecosystem

27

1 NQUBITS = 26
2 c = Circuit ( NQUBITS )
3 for i in range ( NQUBITS ) :
4
5 output = c . add ( gates . M ( TARGET , collapse = True ) )
6 for i in range ( NQUBITS ) :
7
8 # Running the circuit with more than 25 qubit return sum of qubit

c . add ( gates . H ( i ) )

c . add ( gates . H ( i ) )

states probabilities =! 1 ( Bug triggered )

9 result = c ()

(a) Trigger of the bug ”qibo (issue id 517)”

1 File " mtrand . pyx " , line 933 , in numpy . random . mtrand . RandomState .

choice

2 ValueError : probabilities do not sum to 1

(b) Error message

1 # Repository : qiboteam / qibo
2 # Fix file : qibo / src / qibo / core / states . py
3 # Class : VectorState , method : probabilities () , line : 95
4 def probabilities ( self , qubits = None , me a sur e men t _ga te = None ) :
5

un m ea s ur ed_q ubi ts = tuple ( i for i in range ( self . nqubits ) if i
not in qubits )

6 -

7 +

8

state = K . reshape ( K . square ( K . abs ( K . cast ( self . tensor ) ) ) , self .

nqubits * (2 ,) )

state = K . reshape ( K . square ( K . abs ( K . cast ( self . tensor , dtype = "

complex128 " ) ) ) , self . nqubits * (2 ,) )
return K . sum ( state , axis = u n me a su r ed _ qu b it s )

(c) Bug ﬁx

Listing 4: The execution of the code snippet (shown in (a)) triggers the message
error (shown in (b)) because the sum of ﬁnal state probabilities is diﬀerent
from 1. The bug ﬁx was to cast the array value to complex type (as shown in
(c))

wanted to draw a circuit, alongside with its proposed ﬁx. Libraries dedicated
to quantum circuit visualization such us Matplotlib and Seaborn in python
help developers to analyze and debug the circuits.

Performance bugs are related to the stability, speed, or response time of
software resources. This category covers memory overuse, endless loops, and
energy consumption. For example, in the Qiskit simulator, we found a bug
that caused a huge performance regression in the simulation due to a large
increase in serialization overhead when loading noise models from Python into
C++. Even though the bug ﬁx consisted only in one line of code, developers
spent 4 days to locate and ﬁx this bug. Quantum developers make a high use of
quantum simulators, therefore, it is important to ensure that these simulators
maintain a good performance. Creating a performance benchmark for quantum
simulators can help the community to select the most appropriate simulators
and encourage providers to improve the performance of their simulators.

28

Mohamed Raed El Aoun et al.

1 # Repository : m - labs / artiq
2 # Fix file : artiq / master / worker_db . py
3 # Class : DeviceManager , method : get , line : 144
4 - dev = _ create_device ( self . get_desc ( name ) , self )
5 + try :
6 +
7 + except Exception as e :
8 +

desc = self . get_desc ( name )

raise DeviceError ( " Failed to get description of device ’{} ’ " .

format ( name ) ) from e

9 + try :
10 +
11 + except Exception as e :
12 +

dev = _create_device ( desc , self )

raise DeviceError ( " Failed to create device ’{} ’ " . format ( name )

) from e

Listing 5: Calling the device description causes the program to crash with
inappropriate error message hard to understand.The bug ﬁx was adding
exception block in the get method with descriptive error message ”artiq (issue
id 396)”.

1 # Repository : dwavesystems / dwave - cloud - client
2 # Fix file : dwave / cloud / cli . py , method : solvers , line :346
3 + @click . option ( ’ -- client ’ , ’ client_type ’ , default = None ,
4

type = click . Choice ([ ’ base ’ , ’ qpu ’ , ’ sw ’ , ’ hybrid ’] ,

case_sensitive = False ) ,

5
6 - def solvers ( config_file , profile , solver_def , list_solvers ,

help = ’ Client type used ( default : from config ) ’)

list_all ) :

7 + def solvers ( config_file , profile , client_type , solver_def ,

list_solvers , list_all ) :
if list_all :

client_type = ’ base ’

with Client . from_config (

config_file = config_file , profile = profile , solver =

solver_def ) as client :

config_file = config_file , profile = profile ,
client = client_type , solver = solver_def ) as client :

8
9 +
10
11 -

12 +
13 +

Listing 6: Dwave solver is sensitive to the client type and does not return all
the solvers with option -all because developers missed the client type argument
in the solvers function. The bug ﬁx was passing the client type as argument
”dwave-cloud-client( issue id 457)

Permission/deprecation bugs. This category covers two type of bugs:
(1) bugs related to the removal or modiﬁcation of deprecated calls or APIs,
and (2) bugs related to missing or incorrect API permission.

Database related bugs are related to the connection between the database

and the main application.

Documentation issues are related to documentation typos, not up to date

documentations and misleading function in documentation.

Monitoring bugs are related to bad logging practices such as wrong log-
ging levels, too much logging, or missing log statement. Only 2 bugs were

Bug Characteristics in Quantum Software Ecosystem

29

1 qc = qk . QuantumCircuit (2)
2 # The circuit draw in latex places barrier in the wrong place
3 qc . draw ( output = ’ latex ’)

(a) Trigger of the bug qiskit (issue id 3107)

1 # Repository : Qiskit / qiskit - terra
2 # Fix file :
3 # Class : QCircuitImage , method : _build_latex_array , line :772
4 - self . _latex [ start ][ column ] = " \\ qw \\ barrier { " + str ( span ) + " } "
5 + self . _latex [ start ][ column - 1] += " \\ barrier [0 em ]{ " + str ( span )

qiskit / visualization / latex . py

+ " } "

6 + self . _latex [ start ][ column ] = " \\ qw "

(b) Trigger of the bug

Listing 7: The execution of the code snippet (shown in (a)) plots a circuit with
a barrier not aligned correctly. The bug ﬁx was to adjust the barrier column
index (shown in (b))

1 # qiskit / qiskit - aer
2 # Fix file :

qiskit / providers / aer / noise / errors / quantum_error . py ,

method : to_dict , line : 462

3 - instructions = [ exp . to_dict () [ ’ instructions ’] for exp in qobj .

experiments ]

4 + instructions : [[ op [0]. assemble () . to_dict () for op in circ . data ]
5

for circ in self . _circs ]

Listing 8: Calling qiskit.assemble causes a huge performance regression in noisy
simulator ”qiskit-aer (issue id 1398)”

assigned to the monitoring component. For example, the bug report id 10015
in quisp describes a problem of overlogging and misplaced log statements. The
overloaded text has been making debugging diﬃcult. Even though, logging is
a known practice in software engineering, its eﬀectiveness requires adequate
logging statements at appropriate locations in the code. Tools for logging and
log level recommendations can help support quantum developers and improve
the quality of their applications.

A Misuse is a wrong usage of a function that leads to a bug in the code.
Misuses appeared in gate operation, state preparation components. For
example, in the Listing 9, we present a Misuse bug that occurred during the
state preparation of the qubit. This bug occurred because the developer wrote
the program in the wrong order. The purpose of the circuit presented in this
example is to measure the state of qubit 0 and map the state into a classical bit.
However, the program of this circuit raised a CircuitError as shown in Listing
9(b). This error is due to line QuantumCircuit() which is not doing anything
since it is immediately over-ridden by statepreparation(). Moreover, the
measurement is not mapped to the register (classical bit) because of the misuse

15 https://github.com/sfc-aqua/quisp/issues/100

30

Mohamed Raed El Aoun et al.

of the measure() function. A developer proposed the following ﬁx to correct
the issue (Listing 9(c)).

1 q = Q uantum Register (4)
2 c = Cl a ssi c al Regi ste r (1)
3 circuit = QuantumCircuit (q , c )
4 ang = feature_train [3]
5 # Applying state preparation after quantum Circuit initialization

triggers the bug

6 circuit = s tatepreparation ( ang , circuit , [0 ,1 ,2 ,3])
7 circuit . measure (0 , c )

(a) Trigger of the bug ”qiskit (issue Id 5837)”

1 CircuitError : ’ register not in this circuit ’

(b) Code to reproduce the bug

1 # Fix file : In the code snipped ( shown in ( a ) ) , line 3 and 7
2 - circuit = QuantumCircuit (q , c )
3 - circuit . measure (0 , c )
4 + circuit . measure (0 , 0)

(c) Code to reproduce the bug

Listing 9: The execution of the code snipped (shown in (a)) triggers the mes-
sage error (shown in (b)) because the quantum circuit (line 3 in code snipped
(a)) is immediately overridden by the state preparation (line 6 in a code
snipped (a)). The bug ﬁx was to map the 0th measured qubit into the 0th
classical bit and remove the circuit initialization (as shown in (c).

Network bugs are related to connection or server issues. Network bug type
is the rarest bug Where we identify one bug in the quantum cloud access
component from table 4.

We identiﬁed 5 dominant bug type while doing the manual analysis: program

anomaly, data type and structure, configuration issues, test-code
related and enhancement and feature request. Program anomaly is the
most dominant bug type with 123 bugs. While inspecting the bug reports and
their commit message, we notice that most program anomaly bugs come from
bad implementation in the quantum algorithm or mathematical formulation
of the problem. In fact, gate operation and state preparation components are
based on complex mathematics, and this may be challenging for developers.
Configuration issues is the second most frequent bug type with 45 bugs.
Most of the quantum concepts are based on linear algebra and use complex
data type; this makes the implementation challenging for developers. Data
type and structure is the third most frequent category with 40 bugs. Again,
this may be caused by the complexity of quantum operations.

Bug Characteristics in Quantum Software Ecosystem

31

We identiﬁed 13 diﬀerent types of quantum bugs. The most frequent
types of bugs occurring in quantum components are: program anomaly
bugs with 123 bugs, conﬁguration bugs with 47 bugs, and data type and
structure bugs with 46 occurrences. Program anomaly bugs is the most
spread bug type (it occurs in all components). Data type and structure
bugs are mostly located in the components State preparation (10
occurrences) and Compiler (12 occurrences).

Discussion on quantum bug categories. We have seen in the analysis that
most of the bugs in the quantum software ecosystem are program anomalies,
conﬁguration bugs, and data type and structure bugs. These bugs can have a
serious impact, causing the program to crash and leading to poor software qual-
ity. We observe that quantum programmers have limited or no access to data,
matrix, and array manipulation libraries. It is often diﬃcult for them to im-
plement quantum algorithms, linear algebra routines, error mitigation models,
and unitary transformation with existing libraries such as Numpy. This ﬁnding
suggests that developing data manipulation (e.g., array manipulation)
libraries dedicated to quantum programming along with a collection of
mathematical algorithms for quantum computing and convenience fun-
ctions can help prevent some of the observed program anomalies and data
type and structure bugs. Our analysis also revealed the diﬃculty of designing
quantum circuits. Automatic pattern recommendation tools could be devel-
oped to support this task. This can be done for example by mining a large set
of expert-written quantum code to extract common code patterns that can be
recommended to developers designing quantum circuits.

Because quantum programs are diﬃcult to debug and quantum components
are strongly coupled, circuit visualization and analysis approaches are
needed to help developers examine the logical structure of their circuits and
ﬁx bugs early on.

Researchers and tool builders should consider contributing spe-
cialized data manipulation (e.g., array manipulation) libraries
and libraries providing mathematical algorithms for quantum
computing and convenience functions to support quantum soft-
ware development, to help reduce the occurrence of program anomaly
bugs and data type and structure bugs. Circuit visualization and
analysis techniques and tools are also needed to help developers debug
and ﬁx bugs in quantum circuits.

32

Mohamed Raed El Aoun et al.

6 Related Work

We discuss prior work related to our study; organizing them in three categories:
quantum software engineering, topic analysis of technical Q&A data, and topic
analysis of issue reports.

6.1 Quantum Software Engineering

Quantum software engineering (QSE) is still in its infancy. As the result of
the ﬁrst International Workshop on Quantum Software Engineering & Pro-
gramming (QANSWER), researchers and practitioners proposed the “Talav-
era Manifesto” for quantum software engineering and programming, which de-
ﬁnes a set of principles about QSE (e.g.,“QSE is agnostic regarding quantum
programming languages and technologies”) [34]. Zhao [43] performed a com-
prehensive survey of the existing technology in various phases of the quantum
software life cycle, including requirement analysis, design, implementation,
testing, and maintenance. Prior work [27, 33, 3, 35] also discussed challenges
and potential directions in QSE research, such as modeling [3] and quantum
software processes & methodologies [27], and the design of quantum hybrid
systems [35]. In addition, prior work conducted extensive exploration along
the lines of quantum software programming [17] and quantum software devel-
opment environments [25]. The survey [43] provides a comprehensive overview
of the work along these lines. Diﬀerent from prior work, this work examines
the characteristics of bugs occurring in the quantum software ecosystem.

6.2 Quantum Bugs Characteristics

In their 2021 position paper, Campos and Souto [7] argued for the creation
of a benchmark dataset of quantum bugs. In the same year, Zhao et al. [44]
provided a data set of 36 bugs identiﬁed in the quantum computing framework
Qiskit. In 2022, Matteo and Michael [30] examined 283 bugs from 18 open-
source quantum computing platforms to identify bug patterns. In this paper,
we study a larger set of bugs from a larger number of quantum projects. We
perform quantitative and qualitative analysis on the characteristics and types
of the quantum bugs occurring in diﬀerent quantum components.

6.3 Quantum Programs Testing

Quantum programs are more diﬃcult to test and debug than a classical pro-
gram because of the impossibility to copy the quantum information in the
qubits [41], and the probabilistic nature of the measurement. To face these
challenges, Huang and Martonosi [19] introduced statistical assertions that
can be used to validate patterns and detect bugs in quantum programs. Li et
al. [26] proposed Proq, a project-based runtime analysis tool for testing and

Bug Characteristics in Quantum Software Ecosystem

33

debugging quantum programs. The evaluation of the tool shows that it can ef-
fectively help locate bugs in quantum programs. Yu and Palsberg [42] proposed
an abstract interpretation of quantum programs and use it to automatically
verify assertions in polynomial time. Similar to our work, these previous works
on quantum program testing contribute to improving our understanding of the
nature of quantum bugs.

7 Threats to Validity

We now discuss threats to the validity of our study.

External validity. In this work, we analyze the bugs of 125 quantum software
projects on GitHub. Our studied projects may not represent the characteristics
of other quantum software projects that are not public on GitHub. In addi-
tion, our studied projects may not represent all quantum software projects
on GitHub. However, we followed a systematic approach to search for quan-
tum software projects and focus on projects with relatively rich development
activities.
Internal validity. In RQ1, we analyze the bug ﬁxing eﬀorts using the bug
ﬁx duration and the code changes in the bug ﬁxes as proxies. However, the
duration and code changes may not accurately capture the eﬀort of developers
in ﬁxing these bugs. Future works that accurately monitor developers’ devel-
opment activities in ﬁxing quantum software bugs can improve our analysis.
Construct validity. In our preliminary study and RQ2, we manually analyze
the categories of the quantum software projects and the characteristics of the
quantum software bugs. Our results may be subjective and depend on the
judgment of the researchers who conducted the manual analysis. To mitigate
this threat, two authors of the paper collectively conducted a manual analysis
and reached a substantial agreement, indicating the reliability of the analysis
results. To resolve disagreements, the third author joined them and each case
was discussed until reaching a consensus.
Conclusion validity. This threat concerns the extent to which the analyzed
issues can be considered exhaustive enough. We have followed a systematic
approach to identify the studied quantum projects. To identify the bug types
and the components of the quantum program execution ﬂow in which they
occurred, we have manually analyzed a statistical representative sample of the
detected bugs. Although it is possible that we may have missed some types of
bugs, we have mitigated this threat by following a stratiﬁed sampling strategy
that allowed us to cover projects from all quantum computing categories.
Reliability validity. This threat concerns the possibility to replicate this
study. We have attempted to provide all the necessary details needed to repli-
cate our study. We share our full replication package in [36].

34

8 Conclusions

Mohamed Raed El Aoun et al.

This work performs an empirical study on 125 open-source quantum software
projects hosted on GitHub. These quantum software projects cover a vari-
ety of categories, such as quantum programming frameworks, quantum circuit
simulators, or quantum algorithms. An analysis of the development activity of
these selected projects show a level of development activities similar to that
of classical projects hosted on GitHub. We compared the distribution of bugs
in quantum software projects and classical software projects, as well as devel-
opers’ eﬀorts in addressing these bugs and observed that quantum software
projects are more buggy than comparable classical software projects. Besides,
quantum software project bugs are more costly to ﬁx (in terms of the code
changed) than classical software project bugs. We qualitatively studied a sta-
tistically representative sample of quantum software bugs to understand their
characteristics. We identiﬁed a total of 13 diﬀerent types of bugs occurring in
12 quantum components. The three most occurring types of bugs are Program
anomaly bugs, Conﬁguration bugs, and Data type and structure bugs. These
bugs are often caused by the wrong logical organization of the quantum circuit,
state preparation, gate operation, measurement, and state probability expec-
tation computation. Our study also highlighted the need for specialized data
manipulation (e.g., array manipulation) libraries, libraries providing mathe-
matical algorithms for quantum computing and convenience functions, as well
as circuit visualization and analysis techniques and tools to support quantum
software development.

References

1. Aleksandrowicz G, Alexander T, Barkoutsos P, Bello L, al (2019)
for Quantum Computing.

Qiskit: An Open-source Framework
https://doi.org/10.5281/zenodo.2562111, Accessed 2022-04-18

J

(2019)
computer.

2. Aron
tum
2189909-ibm-unveils-its-first-commercial-quantum-computer/,
accessed: 2022-01-16

quan-
https://www.newscientist.com/article/

Ibm unveils

commercial

ﬁrst

its

3. Barbosa LS (2020) Software engineering for ’quantum advantage’. In: Pro-
ceedings of the IEEE/ACM 42nd International Conference on Software
Engineering Workshops, pp 427–429

4. Brandl MF (2017) A quantum von neumann architecture for large-scale

quantum computing. arXiv preprint arXiv:170202583

5. Businge J, Openja M, Nadi S, Bainomugisha E, Berger T (2018) Clone-
based variability management in the android ecosystem. 2018 IEEE Inter-
national Conference on Software Maintenance and Evolution (ICSME) pp
625–634

6. Businge J, Openja M, Kavaler D, Bainomugisha E, Khomh F, Filkov V
(2019) Studying android app popularity by cross-linking github and google

Bug Characteristics in Quantum Software Ecosystem

35

play store. 2019 IEEE 26th International Conference on Software Analysis,
Evolution and Reengineering (SANER) pp 287–297

7. Campos J, Souto A (2021) Qbugs: A collection of reproducible bugs in
quantum algorithms and a supporting infrastructure to enable controlled
quantum software testing and debugging experiments. 2021 IEEE/ACM
2nd International Workshop on Quantum Software Engineering (Q-SE)
pp 28–32

8. Catolino G, Palomba F, Zaidman A, Ferrucci F (2019) Not all bugs are the
same: Understanding, characterizing, and classifying bug types. Journal of
Systems and Software 152:165–181

9. Cramer J, Kalb N, Rol MA, Hensen B, Blok MS, Markham M, Twitchen
DJ, Hanson R, Taminiau TH (2016) Repeated quantum error correction
on a continuously encoded qubit by real-time feedback. Nature communi-
cations 7(1):1–7

10. Developers C (2021) Cirq. DOI 10.5281/zenodo.4586899, URL https://
doi.org/10.5281/zenodo.4586899, See full list of authors on Github:
https://github .com/quantumlib/Cirq/graphs/contributors

11. Farhi E, Goldstone J, Gutmann S (2014) A quantum approximate opti-

mization algorithm. arXiv preprint arXiv:14114028

12. Fein

R

(2021)
ecosystem.

ing
the-evolving-quantum-computing-ecosystem-bed1805007f8,
cessed: 2022-04-15

evolving
comput-
quantum
https://medium.com/@russfein/
ac-

The

13. Fingerhuth M, Babej T, Wittek P (2018) Open source software in quantum

computing. PloS one 13(12):e0208561

14. Forn-Diaz P (2010) Superconducting qubits and quantum resonators. PhD

thesis, Delft University of Technology

15. Foundation QOS (2021) List of open quantum projects. https://qosf.

org/project_list/, Accessed: 2022-01-10

16. Gao Y, Jin S, Zhang Y, Ian H (2020) Pulse-qubit interaction in a super-
conducting circuit under frictively dissipative environment. arXiv preprint
arXiv:200206553

17. Garhwal S, Ghorani M, Ahmad A (2019) Quantum programming lan-
guage: A systematic review of research topic and top cited languages.
Archives of Computational Methods in Engineering pp 1–22

18. GitHub (2021) REST API. https://developer.github.com/v3/, Last

accessed 2021-05-04

19. Huang Y, Martonosi M (2019) Statistical assertions for validating patterns
and ﬁnding bugs in quantum programs. In: Proceedings of the 46th Inter-
national Symposium on Computer Architecture, Association for Comput-
ing Machinery, New York, NY, USA, ISCA ’19, p 541–553

20. IBM (2021) Survey of

install
qiskit locally and get started with tutorials. http://www.web.uvic.ca/
~rdesousa/teaching/P280/L15_280.pdf, accessed: 2021-10-20

ibm-q, circuit composer, backends.

21. IonQ (2018) MS Windows NT kernel description. https://ionq.com/,

accessed: 2021-10-20

36

Mohamed Raed El Aoun et al.

22. Kalliamvakou E, Gousios G, Blincoe K, Singer L, Germ´an DM, Damian
DE (2016) An in-depth study of the promises and perils of mining github.
Empirical Software Engineering 21:2035–2071

23. Kaye P, Laﬂamme R, Mosca M, et al. (2007) An introduction to quantum

computing. Oxford University Press on Demand
NT

24. Knight W (2017) MS Windows

kernel

description.

https://www.technologyreview.com/2017/11/10/147728/
ibm-raises-the-bar-with-a-50-qubit-quantum-computer/,
cessed: 2021-10-20

ac-

25. LaRose R (2019) Overview and comparison of gate level quantum software

platforms. Quantum 3:130

26. Li G, Zhou L, Yu N, Ding Y, Ying M, Xie Y (2020) Projection-based run-
time assertions for testing and debugging quantum programs. Proceedings
of the ACM on Programming Languages 4(OOPSLA):1–29

27. Moguel E, Berrocal J, Garc´ıa-Alonso J, Murillo JM (2020) A roadmap
for quantum software engineering: Applying the lessons learned from the
classics. In: Q-SET@ QCE, pp 5–13

28. Mueck L (2017) Quantum software. Nature 549(171)
29. Nachman B, Urbanek M, de Jong WA, Bauer CW (2020) Unfolding quan-

tum computer readout noise. npj Quantum Information 6(1):1–7

30. Paltenghi M, Pradel M (2021) Bugs in quantum computing platforms: An

empirical study. CoRR abs/2110.14560

31. Physicsworldcom (2011) Quantum-computing

the
https://web.archive.org/web/20110515083848/http:
2022-01-

box.
//physicsworld.com/cws/article/news/45960, Accessed:
10

ﬁrm opens

32. Physicsworldcom
the

(2011)
opens
box.
ion-based-commercial-quantum-computer-is-a-first/,
2022-01-10

Quantum-computing
ﬁrm
https://physicsworld.com/a/
Accessed:

33. Piattini M, Peterssen G, P´erez-Castillo R (2020) Quantum computing: A
new software engineering golden age. ACM SIGSOFT Software Engineer-
ing Notes 45(3):12–14

34. Piattini M, Peterssen G, P´erez-Castillo R, Hevia JL, Serrano MA,
Hern´andez G, de Guzm´an IGR, Paradela CA, Polo M, Murina E, et al.
(2020) The talavera manifesto for quantum software engineering and pro-
gramming. In: The First International Workshop on the Quantum Soft-
ware Engineering & Programming, QANSWER ’20, pp 1–5

35. Piattini M, Serrano M, Perez-Castillo R, Petersen G, Hevia JL (2021)
Toward a quantum software engineering. IT Professional 23(1):62–66
36. Replication Package (2022) Study of the bug charateristics in the quantum
ecosystem. https://github.com/raed1337/Quantum-bug-study/tree/
master, accessed: 2022-04-20

37. Roy A, Devoret M (2018) Quantum-limited parametric ampliﬁcation with
josephson circuits in the regime of pump depletion. Physical Review B
98(4):045405

Bug Characteristics in Quantum Software Ecosystem

37

38. Sodhi B (2018) Quality attributes on quantum computing platforms. arXiv

preprint arXiv:180307407

39. Tan L, Liu C, Li Z, Wang X, Zhou Y, Zhai C (2013) Bug characteristics
in open source software. Empirical Software Engineering 19:1665–1705
40. TechTarget (2018) classical computing. https://www.techtarget.com/
whatis/definition/classical-computing, Accessed: 2022-04-18
41. Wootters WK, Zurek W (1982) A single quantum cannot be cloned. Nature

299:802–803

42. Yu N, Palsberg J (2021) Quantum abstract interpretation. In: Association
for Computing Machinery, Association for Computing Machinery, New
York, NY, USA, PLDI 2021, p 542–558

43. Zhao J (2020) Quantum software engineering: Landscapes and horizons.

arXiv preprint arXiv:200707047

44. Zhao P, Zhao J, Ma L (2021) Identifying bug patterns in quantum pro-
grams. In: 2021 IEEE/ACM 2nd International Workshop on Quantum
Software Engineering (Q-SE), IEEE, pp 16–21

