PMUSpill: The Counters in Performance Monitor Unit that
Leak SGX-Protected Secrets

2
2
0
2

l
u
J

4
2

]

R
C
.
s
c
[

1
v
9
8
6
1
1
.
7
0
2
2
:
v
i
X
r
a

Pengfei Qiu, Yongqiang Lyu, Haixia Wang, Dongsheng Wang, Chang Liu
Tsinghua University, Beijing, China.
qpf15@tsinghua.org.cn, {luyq, hx-wang, wds}@tsinghua.edu.cn, cliu21@mails.tsinghua.edu.cn

Qiang Gao, Chunlu Wang
Beijing University of Posts and Telecommunications, Beijing, China.
{2020140851, wangcl}@bupt.edu.cn

Rihui Sun
Harbin Institute of Technology, Harbin, China.
srh@stu.hit.edu.cn

Gang Qu
University of Maryland, College Park, USA.
gangqu@umd.edu

ABSTRACT

Performance Monitor Unit (PMU) is a signiﬁcant hardware
module on the current processors, which counts the events
launched by processor into a set of PMU counters. Ideally,
the events triggered by instructions that are executed but the
results are not successfully committed (transient execution)
should not be recorded. However, in this study, we discover
that some PMU events triggered by the transient execution
instructions will actually be recorded by PMU. Based on this,
we propose the PMUSpill attack, which enables attackers to
maliciously leak the secret data that are loaded during tran-
sient executions. The biggest challenge is how to encode the
secret data into PMU events. We construct an instruction gad-
get to solve this challenge, whose execution path that can be
identiﬁed by PMU counters represents what values the secret
data are. We successfully implement the PMUSpill attack
to leak the secret data stored in Intel Software Guard Exten-
sions (SGX) (a Trusted Execution Environment (TEE) in the
Intel’s processors) through real experiments. Besides, we
locate the vulnerable PMU counters and their trigger instruc-
tions by iterating all the valid PMU counters and instructions.
The experiment results demonstrate that there are up to 20
PMU counters available to implement the PMUSpill attack.
We also provide some possible hardware and software-based
countermeasures for addressing the PMUSpill attack, which
can be utilized to enhance the security of processors in fu-
ture.

1.

INTRODUCTION

Performance Monitor Unit (PMU) [10, 24, 32] is a widely
enabled hardware module on processors nowadays including
those by Intel, ARM, and AMD, which contains a set of coun-
ters to count the events triggered during run-time of the core
and its memory system such as cache hit/miss, write-back
transaction, streaming store request, machine clear, etc. It
is essentially designed as a tool to collect the activities of
processor for software developers to analyze and optimize

their codes. However, PMU provides plentiful information
about the behaviors of processor, which provides opportuni-
ties for researchers to reverse engineering the design details
of black-box processors [34, 42, 45, 49] or speculate the keys
of encryption algorithms such as Advanced Encryption Stan-
dard (AES) [16], Rivest-Shamir-Adleman (RSA) [5], and
Elliptic Curves Cryptography (ECC) [4]. While this study
shows a new security issue caused by PMU that is not studied
before as we know: leaking the secret data that are loaded
during transient executions.

Processor designers have integrated several high-performance

technologies (e.g. out-of-order execution, speculative execu-
tion, Micro-architectural Data Sampling (MDS) [24], et al.)
into current processors to enhance the instruction throughput.
Those technologies enable processors to perform later instruc-
tions even when previous instructions have not retired. Such
execution of “invisible” instructions is referred to the transient
execution, whose execution results will be roll backed if an
exception handling delay on out-of-order execution [31, 48],
a misprediction on speculation [28], or a microcode-assist
event on MDS [8,45] happens. However, in this study, we dis-
cover that some events happened in the transient executions
will also be recorded by PMU counters. In other words, the
processor will not roll back those PMU counters regardless of
the executed instructions retire or not. This is not studied by
the prior PMU-based attacks as their attacks are conducted by
measuring the events triggered by retired instructions. Based
on the discovery, we propose the PMUSpill attack, a new
kind of PMU-based side channel attack that is available to
achieve transient execution attacks. In PMUSpill attack, the
secret data are encoded into the events that will be recorded
by PMU during the transient executions, which are recovered
by monitoring whether the corresponding PMU counters are
changed after the transient executions.

Finding a way to encode the secret data into PMU events
during transient executions is the biggest challenge when im-
plementing PMUSpill attack. Directly using the secret data
as instruction operands is not a good choice, this is because

1

 
 
 
 
 
 
that PMU events are usually determined by the instruction
opcodes instead of operands. In this study, we design an in-
struction gadget to fully solve this challenge. The instruction
gadget contains a transient execution in which a controllable
variable is compared to the secret data. The execution path
when the variable equals to the secret data is different from
that when they are unequal. Besides, the instructions of the
two execution paths are carefully selected so that the events
triggered by them are different. As a result, the events trig-
gered by the execution of the instruction gadget reﬂect which
execution path is taken and therefore reveal whether the con-
trollable variable and secret data are the same to attackers.

In order to locate the vulnerable PMU counters that are
available to implement PMUSpill attack and which instruc-
tions can trigger their corresponding events (called trigger
instructions in this study), we feed the two execution paths of
the instruction gadget with the instruction iterated through the
uops.info data set [1] (an instruction data set for the Intel X86
architecture) and test all the valid PMU counters after the ex-
ecution of the instruction gadget. The PMU counters whose
increments when the variable equals to the secret data are dif-
ferent from that when they are diverse are vulnerable counters
and the corresponding instructions are the trigger instructions.
With our investigation, there are up to 20 vulnerable PMU
counters in our experiment devices whose processor is Intel(cid:114)
CoreTM i7-6700 (the total number of valid PMU counters is
217). We successfully utilize them to leak the secret data
protected by the Intel Software Guard Extensions (SGX) (a
Trusted Execution Environment (TEE) in the Intel’s proces-
sors), which illustrates that the PMUSpill attack is a real
threaten to the computer system. Besides, our experiment
results demonstrate that the throughput of PMUSpill attack
can up to 575.3 byte per second (Bps) with an error rate of
less than 2% on average.

Disabling the vulnerable PMU counters is an efﬁcient so-
lution to defend against PMUSpill attack, however, this will
take ineluctable side effects that software developers can-
not use those PMU counters to analyze the performance of
their codes. Moreover, even we test all the valid PMU coun-
ters in our experiment devices and all the instructions in the
uops.info data set [1], we cannot guarantee that we ﬁnd out
all of the vulnerable PMU counters especially the PMU coun-
ters that are private for some processors. PMUSpill attack
is implemented by monitoring the events happened in the
transient executions, which proves that it is not a good design
to expose the transient activities of the processor to the users
even the privileged users. Besides, the attack targets of the
PMUSpill attack are the procedures that are performed in the
TEE. Therefore, in this work, we propose two methods to mit-
igate PMUSpill attack: 1) renaming the PMU counters when
transient executions are performing and only updating the
real PMU counters when transient instructions successfully
retire. This is a hardware-based solution and cannot provide
protections to the existing devices. 2) similar to the meth-
ods that are designed by Intel to mitigate the vulnerability
CVE-2019-11157 [39, 40], ensuring that the PMU and SGX
cannot be simultaneously enabled by the microcode update
is a useful software-based countermeasure. This method can
be deployed on the existing systems.

In sum, we make the following contributions in this work.

• We discover that some events triggered by transient
executions will also be recorded by PMU, which will
unintentionally leak the behaviors of the transient ex-
ecutions and cause secret data leakages. We therefore
propose PMUSpill attack, a new kind of side channel
attack that is able to infer the transiently loaded secret
data with the help of PMU.

• We design an instruction gadget to encode secret data
into transient execution events, in which a controllable
variable is compared to the secret data and the execution
path after the comparison that can be identiﬁed by PMU
counters represents which the secret data are.

• We go through all the PMU counters in Intel(cid:114) CoreTM
i7-6700 processor with all valid instructions, and ﬁnd
that there are up to 20 vulnerable PMU counters avail-
able to implement PMUSpill attack. The applications
of PMUSpill attack is veriﬁed by obtaining the Intel
SGX-protected secret data through real experiments.

2. PRELIMINARIES AND RELATED WORK

2.1 Side Channel Attack

Side channel attack is a kind of widely studied attack
method in the ﬁeld of hardware security, which leaks se-
cret data from a victim process to the attacker process by
monitoring the information (e.g. instruction execution time,
power consumption, electromagnetic, branch prediction, et
al.) from the implementation of hardware system rather than
using software vulnerabilities in the implemented algorithms.
The monitored information is usually unintentionally leaked
by the hardware, which results that it is difﬁcult to address
the side channel attack. Side channel attack have been widely
used to infer the keys of encryption algorithms that are not
easy to break with brute force attacks such as Data Encryp-
tion Standard (DES) [22], AES [25, 27], RSA [17, 18, 30],
EdDSA [18, 52], and ECC [2].

There are several types of side channel attacks proposed
such as cache side channel attack [33], timing side channel
attack [23], power side channel attack [51], electromagnetic
side channel attack [55], acoustic side channel attack [12],
branch prediction side channel attack [13], et al. The cache
side channel attack is the most investigated attack method,
which is implemented based on the fact that the execution
time for a data load operation that misses the cache is obvi-
ously higher than that when hits the cache. Prime+Probe [46],
Evict+Time [38,50], Flush+Flush [19], and Flush+Reload [54]
are the four famous cache side channel attacks. Among those
attacks, Flush+Reload attack [54] is very easy to implement
and widely utilized in recovering the secret data obtained by
transient execution vulnerabilities.

Randomization, partition, and sensitive data differentiat-
ing technologies have become momentous countermeasures
against side channel attacks [20] by randomizing the data ac-
cess, isolating the attacker and victim processes, and allowing
ﬁne-grained control of the secret data. Besides, some secure
technologies have also been proposed to address side channel
attacks such as kernel separation [7], virtualization [15], and
trusted computing like Intel Trusted Execution Technology
(TXT) [14], SGX [11], and ARM TrustZone [3].

2

2.2 Performance Monitor Unit (PMU)

PMU is a widely-enabled on-chip hardware that measures
the processor’s various architectural and micro-architectural
events into several special registers (PMU counters). With
PMU, we can gain insight into the processor’s behaviors such
as the number of instructions that are assigned to a particular
port, the number of cache misses/hits at different levels in the
memory hierarchy, the number of mis-predicted branches, et
al. It is initially designed for software developers to analyze
the code execution efﬁciency and therefore help them to
optimize their applications. However, because it is capable to
disclose the impacts of an instruction on the processor in a
ﬁne-grained manner, the researchers have also try to utilize
the PMU to achieve other aims such as reverse engineering
the black-box processors [42, 45, 49], and inferring the keys
of encryption algorithms [4, 5, 16].

Reverse engineering the black-box processors. Most of the
commercial processors nowadays are black-box processors,
it is very difﬁcult for researchers to analyze their security
with the limited public information. The PMU provides an
opportunity for researchers to pry into the inner designs of
the black-box processors for vulnerability analysis and min-
ing. For example, Van et al. and Schwarz et al. ﬁnd the
RIDL [49] and ZombieLoad [45] vulnerabilities, respectively,
but how to ﬁnd the leakage source become a challenge. In
their work, they successfully locate the leakage source us-
ing PMU; Ragab et al. [42] ﬁnd a micro-architectural unit
(named staging buffer) that is not published in the ofﬁcial
documents by reverse engineering the Intel processors. They
then verify that the staging buffer can cause secret data leak-
age (the vulnerability’s name is CrossTalk); Ragab et al. use
the machine clear-related PMU counters to recover the pro-
cessor’s behaviors when machine clear events happen [41],
they ﬁnd that some mechanisms that will trigger the machine
clear are unsafe (the attacks are called Floating Point Value In-
jection (FPVI) and Speculative Code Store Bypass (SCSB));
Mambretti et al. [34] utilize PMU to reverse engineering the
processor’s activities in order to build a deeper understanding
of speculative executions.

Inferring the keys of encryption algorithms. PMU provides
a lot of information about the execution processes of instruc-
tions, which have been veriﬁed useful to achieve side channel
attacks for inferring the keys of encryption algorithms. For
example, Uhsadel et al. [47] and Götzfried et al. [16] use
the PMU counters that measure the number of L1-cache hits
or misses to implement the access-driven cache-timing at-
tack on the AES implementation in the OpenSSL library;
Bhattacharya et al. [5] propose to use the PMU counters that
measure the number of branch misses to compromise keys of
RSA; Asvija et al. [4] propose to attack the ECC by using the
power-related counters to implement the template attack.

However, the current PMU-based side channel attacks only
utilize some special PMU counters to speculate the keys of en-
cryption algorithms. Besides, they measure the PMU events
for retired instructions to achieve the attacks and do not study
whether PMU can record the events activated by instructions
that does not successfully retire. Moreover, they do not study
whether the PMU counters can be utilized in other malicious
attacks such as implementing the transient execution attacks.
In this study, we ﬁnd that PMU has the ability to measure the

events happened during transient executions and therefore
can be treated as the side channel signals to leak secret data
processed by the transient executions, which is a new kind of
side channel attack and is innovative compared to the existing
PMU-based side channel attacks.

2.3 Transient Execution Vulnerabilities

Modern processors have introduced several technologies to
optimize the instruction pipeline and data access for gaining a
high performance such as speculative execution, out-of-order
execution, and Micro-architecture Data Sampling (MDS), et
al. [24]. Although the instructions may not be executed se-
quentially, the reorder buffer [43] ensures that the instructions
are committed in order. Because of the processor’s exception
delay processing mechanism, if a misprediction on specula-
tion [28], an exception on out-of-order execution [31, 48], or
a microcode-assisted event on MDS [8, 45] happens during
the execution of an instruction, the subsequent instructions
may be executed but the results may not be submitted, and the
processor will roll back to eliminate the instruction’s impacts
on the processor’s architecture layer. These instructions are
called transient instructions, and the execution process of the
transient instructions is called transient execution.

However, even the transient executions do not affect the
processor’s architecture layer, they may affect the processor’s
micro-architecture layer, which leaves a set of transient ex-
ecution vulnerabilities that can be deliberately utilized by
attackers to maliciously leak the secret data. For example,
the attackers can utilize the transient instructions to change
the layouts of processor’s micro-architecture modules such
as cache [31], Translation Look-aside Buffer (TLB) [18],
branch predictor [13, 28], etc. based on the secret data, and
then recover the secret data using side channel attacks.

Currently, the transient execution attacks can be classiﬁed
into three types according to the technologies that cause the
vulnerabilities: out-of-order execution-based attacks, specu-
lative execution-based attacks, and MDS-based attacks. In
the ﬁrst type, the attacker triggers an exception and then en-
codes the secret data into the processor’s micro-architecture
layer during the following transient execution instructions
enabled by the out-of-order execution mechanism. The rep-
resented attacks of this type include Meltdown [31], Fore-
shadow [48], and so on. In the second type, the attacker ﬁrst
induces some speculative executions to poison the branch
predictor and then changes the layouts of the processor’s
micro-architecture layer by causing a misprediction. The rep-
resented attacks of this type include Spcetre V1 [28], Spcetre
V2 [21], and Spectre RSB [29]. In the third type, the at-
tacker ﬁrst triggers a microcode-assist data access event and
then put the secret data-based information into the proces-
sor’s micro-architecture layer. The represented attacks of this
type include Zombieload [45], RIDL [49], Fallout [8], and
Medusa [36]. The leakage sources of this type of attacks
are Line Fill Buffers (LFB) [45, 49], Store Buffer (SB) [8],
and Read Buffer (RB), et al. Besides, this type of exploits
sample the required data from some in-ﬂight data instead of
specifying a full physical or virtual address.

2.4 Trusted Execution Environment

3

TEE [44] is a technology that helps manufacturers, service
providers, and consumers protect their devices and sensitive
data from disclosure or modiﬁcation by providing a secure
isolated execution environment. The Trusted Computing
Base (TCB) of the TEE only includes the processor package,
therefore, its private codes and data cannot be viewed or mod-
iﬁed by the malicious codes outside the TEE even the codes
has a full privileges on the same processor. The most famous
TEEs are ARM TrustZone [3] and Intel SGX [11]. The at-
tack targets of this study are the data owned by Intel SGX.
Therefore, we mainly overview Intel SGX in this section.

Intel SGX is a set of instruction set extensions for Intel pro-
cessors that provide security of integrity and conﬁdentiality
for trusted codes executed on a malicious machine [11, 35].
The trusted codes are executed in the enclave of SGX. SGX
has a strict isolation mechanism for the physical memory
of the enclave to ensure that the data and codes of the en-
clave cannot be monitored and modiﬁed by applications or
advanced system software in an untrusted environment (the
rich execution environment), such as Operating System (OS),
hypervisor, Basic Input Output System (BIOS), System Man-
agement Mode (SMM), etc.

SGX and the rich execution environment [26] share a large
amount of processor resources, such as Cache, TLB, LFB,
etc., which provide attackers with the possibility of attacks.
Over the past few years, researchers have found that SGX’s
security still needs to be improved. It has always been chal-
lenged by side channel attacks [4,5,6,16], but transient execu-
tion attacks have also been found shortcomings of Intel SGX’s
security in recent years. For example, the Spectre-like attack
proposed by Chen et al. [9] can poison the Branch Target
Buffer (BTB) in the enclave and uses the processor’s branch
prediction mechanism to leak trusted data; ZombieLoad at-
tack [45] uses the LFB to leak the SGX-protected data; Fore-
shadow attack [48] maps the physical address of the enclave
to an inaccessible virtual address, whose access will gen-
erate a faulting load. Taking advantage of the processor’s
out-of-order execution mechanism, Foreshadow can recover
the enclave’s secret data.

3. OVERVIEW OF PMUSpill ATTACK

As mentioned in the Section 2.3, the transient execution at-
tacks are a combination of transient execution vulnerabilities
and side channel attacks. The transient execution vulnerabili-
ties put the secret data into the processor’s micro-architecture
layer, and side channel attacks leak the secret data to the
processor architecture layer. Therefore, the side channel at-
tack is also a key link of transient execution attacks, and the
availability of side channel attacks will also directly affect
the availability of transient execution attacks. In this study,
we propose the PMUSpill attack, which is a new kind of
side channel attack that is capable of bringing the secret data
obtained by transient execution vulnerabilities to attackers.
In this section, we ﬁrst present the motivation and threat
model of this work. Next, we demonstrate the attack targets
of PMUSpill attack and how it works. Finally, we show the
challenges that should be addressed when implementing the
attack.

3.1 Motivation

Generally, the executed results of transient executions will
be abandoned and the statuses of some processor’s hardware
modules (e.g. registers and pipeline) will be roll backed to
ensure the correctness of the processor. However, in this
study, we discover that some events triggered in the transient
executions will be recorded by PMU counters whose values
are not be roll backed as other processor modules, which will
unintentionally leverage the interaction between the transient
execution instructions and hardware activities. This discovery
gives the attackers chances to recover the secret data by mon-
itoring the behaviours of the transient execution instructions
through PMU counters. Two nature questions are “how to
utilize such a ﬁnding to leak the data processed by transient
executions?” and “how serious of the data leakage?”. In this
work, we propose the PMUSpill attack to answer the two
questions, which is a new kind of side channel attack method
that builds a bridge between attackers and the secret data that
is acquired in transient executions.

3.2 Assumption and Threat Model

In the PMUSpill attack, we have three assumptions:

• PMU is enabled by the target processor and some of
them can record the events occurred during transient
executions. As far as we know, all of the modern Intel,
ARM, and AMD processors provide PMU as a per-
formance proﬁling technology for software developers.
This work demonstrates that several PMU counters in
Intel processors can count the events triggered by tran-
sient executions. Besides, we have veriﬁed that some
PMU counters in ARM processors are also able to mon-
itor the events triggered by the transient executions.
Therefore, this assumption is true for a range of the
current processors.

• The secret data can be acquired in the transient execu-
tions. This has been veriﬁed by a lot of reported tran-
sient execution attacks such as Meltdown [31], Spec-
tre [28], Foreshadow [48], RIDL [49], Fallout [8], Zom-
bieLoad [45], Medusa [36], CrossTalk [42], FPVI [41],
and SCSB [41] et al. Although those attacks have been
addressed by some countermeasures including software
updates or hardware redesign, we can not guarantee that
our processors do not have the undisclosed transient ex-
ecution vulnerabilities. The new transient execution
attacks are continually reported in the recent years is an
evidence to prove that we may not discover all of the
transient execution vulnerabilities.

• The attackers have a root privilege. This assumption
gives the attackers ability to read the PMU counters.
As presented in the Section 2.4, the root privilege is
out of the TCB of TEE. Therefore, assuming attackers
have the root privilege is permissible when the victim
procedures are in TEE. Besides, there are many legal or
illegal ways for attackers to gain such privilege [37, 53].

Under such assumptions, we make the threat model of this
study as: the attackers try to recover the secret data that is
acquired in the transient executions by measuring the PMU
events and therefore achieve the transient execution attacks.

4

3.3 Attack Targets

3.5 Challenges

PMUSpill attack is a side channel attack, whose ability is
to recover the secret data accessed in transient executions.
Because that reading PMU counters requires a root privilege
and this does not violate the TCB of TEE, the secret data
stored in TEE are the appropriate attack targets of PMUSpill
attack. The processor utilized in our experiment device is
an Intel processor, whose TEE is SGX. As presented in the
Section 2.4, although SGX enables a lot of security mech-
anisms to guarantee that its private data cannot be attacked
by a lot of software-based vulnerabilities [11], it cannot pre-
vent the data leakage from the processor hardware vulner-
abilities such as transient execution vulnerabilities. In fact,
several transient execution attacks have been veriﬁed feasible
to attack the SGX-private data including Foreshadow [48],
ZombieLoad [45], and Spectre [9]. In this study, we utilize
PMUSpill attack to implement the Foreshadow attack through
real attacks, which demonstrates the efﬁciency of PMUSpill
on leaking the secret data of SGX.

3.4 Attack Steps of PMUSpill Attack

Figure 1 depicts the overview and attack steps of PMUSpill
attack, where PMU plays a role to expose the secret data that
is maliciously acquired in transient executions to attackers.
The attacker procedure is performed in the rich execution
environment. It cannot directly read the secret data stored
in TEE but can access them transiently through transient
executions. There are four steps in the attacker procedure to
achieve the PMUSpill attack: 1) reading the PMU counter
to get its initial value; 2) accessing the secret data in the
transient executions and encoding them into the PMU event
by executing some special instructions (trigger instructions)
based on the secret data; 3) reading the PMU counter to get its
new value; 4) inferring the secret data based on whether the
PMU counter is changed or its change ranges. What should
be mentioned is that all the PMU counters that are updated in
the transient executions may be available to implement the
PMUSpill attack.

Figure 1: The overview and attack steps of PMUSpill at-
1(cid:13) getting the initial value of the PMU counter;
tack.
2(cid:13) acquiring the secret data and encoding them into the
PMU event using the transient execution instructions; 3(cid:13)
re-accessing the PMU counter to get its new value; 4(cid:13) in-
ferring the secret data based on the change of the PMU
counter’s value.

5

3.5.1 Encoding the Secret Data into PMU Events

This is the biggest challenge that should be addressed.
Generally, it is not a good choice to encode the secret data
into PMU events by directly treating them as the instruc-
tion operands (operation data of the instruction) because that
the triggered PMU events are mainly decided by the instruc-
tion opcodes instead of operands. Of course, the instruction
operands may also have inﬂuences on the PMU events that
are triggered such as the data access address, the target ad-
dress of the jump instructions, or the operation data of some
vector operation instructions. However, those PMU events
are usually triggered by some special operation data and
therefore requires to carefully analyze the functions of every
instruction to decide how to manipulate the operation data.
For example, the operation data of a memory-access instruc-
tion may inﬂuence the event of L1 cache miss, but this event
only happens when the data referenced by the operation data
of the instruction are not in the L1 cache. Besides, directly
treating the secret data as the instruction operands has little
inﬂuence on this study as our aim is to verify the efﬁciency
of the PMUSpill attack and ﬁnd out the vulnerable PMU
counters as well as their possible trigger instructions.

In this study, we design an instruction gadget to solve
this challenge, where the secret data are encoded into the
execution path (can be measured by the PMU counters) of
the instruction gadget. The details of the instruction gadget
will be described in the Section 4,

3.5.2

Searching for the Vulnerable PMU Events
Accessing the secret data in the attacker procedure will
trigger an exception because that the attacker procedure has
no privilege to access them, therefore, the secret data is tran-
siently owned by the attacker procedure. Different from
the retired executions whose behaviours will be naturally
recorded by the corresponding PMU counters, not all of the
PMU events will be recorded by their PMU counters in the
transient executions. In other words, we cannot encode the
secret data into the PMU events that are only updated when
the instructions successfully retire.

In this study, we give the different execution paths of the
instruction gadget different instructions (those instructions
are selected from the uops.info data set [1]) and measure all
of the valid PMU counters before and after the instruction
gadget is executed. The PMU counters whose values are
prospectively changed are the available PMU counters to im-
plement PMUSpill attack and the corresponding instructions
are the trigger instructions. Section 5.3 and Section 5.4 shows
our experiment settings and results about the vulnerable PMU
counters and their trigger instructions, respectively.

3.5.3 Reducing the Noises

PMU is shared by all of the procedures executed on the
same core, therefore, there may be some noises from other
procedures that are scheduled onto the attacker core (the core
that performs the attacker procedure) by the OS. In this study,
we mitigate those noises by setting the attacker core as an
isolated core. Through this, the OS cannot schedule other
procedures onto the attacker core, but we can still bind the
attacker procedure to the attacker core. This does not violate

②Transient Execution①Read  PMUAttacker Procedure③Read PMUVictim ProcedureLFBL1D CacheOther Components②EnclaveNormalSecureLoad Secret DataLoad Secret DataEncode to EventPMUProcessor……④Speculate Secret Dataour assumption as owning the root privilege is enough to
achieve this setting. In our experiments, when we do not
isolate the attacker core, we get an error rate of 5.17% with
the same attack parameters described in the Section 5.

Using the software codes to capture and handle the ex-
ceptions caused by the operation of accessing the secret
data in the attacker procedure will also take some noises
because that the exception handling codes may also trig-
ger some PMU events. Therefore, it is a better choice to
utilize the Intel Transactional Synchronization Extensions
(TSX) [24,31,45,48] to suppress those noises. The Intel TSX
is a hardware feature of the Intel processors who treats the
executed instructions as an atomic operation and will automat-
ically handle the exceptions. TSX has been widely utilized
to handle the exceptions in the existing transient execution
attacks including Meltdown [31], ZombieLoad [45], Fore-
shadow [48], et al. According to our investigations, the error
rate when using software codes to suppress the exceptions
is also acceptable (the experiment results are shown in the
Table 1) because that the events triggered by the exception
handling codes are certainly ﬁxed. Therefore, for the target
processors that do not enable the TSX, we can still achieve
an efﬁcient PMUSpill attack.

(cid:4)

value [5] = j ;
for ( m = 0; m < 6; m ++){

pmu_start = read_pmu ( pmu_number );
pmu_end = read_pmu ( pmu_number );

}
address [5] = secret_data_address ;
for ( j = 0; j < 256; j ++){

char temp = ‘a ’ , address [6] , value [6]
for ( m = 0; m < 5; m ++){
address [ m ] = & temp ;
value [ m ] = ‘b ’;

4. ENCODING SECRET DATA INTO PMU
EVENTS IN TRANSIENT EXECUTIONS
In this study, we construct an instruction gadget to encode
the secret data into PMU events in transient executions, which
is presented in the Listing 1 (written in the C language).
(cid:7)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
}(cid:6)

}
value [5] = j ;
for ( m = 0; m < 6; m ++){

}
value [5] = j ;
for ( m = 0; m < 6; m ++){

}
value [5] = j ;
for ( m = 0; m < 6; m ++){

pmu_start = read_pmu ( pmu_number );
pmu_end = read_pmu ( pmu_number );

pmu_start = read_pmu ( pmu_number );
pmu_end = read_pmu ( pmu_number );

pmu_start = read_pmu ( pmu_number );
pmu_end = read_pmu ( pmu_number );

pmu_start = read_pmu ( pmu_number );
pmu_end = read_pmu ( pmu_number );

}
for ( m = 0; m < 6; m ++){

}

(cid:5)

Listing 1: The constructed instruction gadget

6

4.1 The Core Instructions

The instructions at line 12-28 are the core instructions of
the instruction gadget. The other instructions play a role to
help readers understand how to apply the PMUSpill attack to
recover the secret data in the transient execution attacks. The
instruction at line 14 loads secret data into the rbx register,
which will trigger an exception as the attacker procedure
does not have the privilege to directly load the secret data.
Therefore, instructions at line 15-22 are executed but the
execution results are not committed (those eight instructions
are transient execution instructions in the attacks).

The instruction at line 15 compares the rbx register (stores
the secret data whose length of bits is 8 in this example listing
codes) with the rdx register (stores the controllable compari-
son variable j whose range is 0-255 in this example listing
codes). If the rbx register equals to the rdx register, the
instruction at line 20 (ins2, we utilize the mov (rcx), rax
as an example in the Listing 1) will be executed, otherwise,
the instruction at line 17 (ins1, we utilize the mov (rax),
rax as an example in the Listing 1) will be executed. The in-
struction at line 18 ensures that the ins1 will not be executed
if the rbx register does not euqal to the rdx register.

As explained before, this instruction gadget can ensure
that the execution path when the secret data equals to the
comparison variable (the instruction that is executed is ins1)
is different from the execution path when they are different
values (the instruction that is executed is ins2) . If the ins1
and ins2 trigger different PMU events, we can judge whether
ins1 is executed or the ins2 is executed by measuring the
PMU events from their corresponding PMU counters. If we
ﬁnd that the ins1 is executed, we can make a conclusion that
the comparison variable equals to the secret data.

4.2 Dealing with the Speculative Execution

Because of the processor’s speculative execution mecha-
nism, if the branch predictor for the jump instruction at line
16 are not prepensely trained, the ins2 may be speculatively
executed even when the rbx register and the rdx register are
unequal. This may disturb the precision of the recognition
for the transient execution path.

In order to avoid this situation, the instruction gadget ﬁrstly
executes the core instructions for 5 times with the condition
of the rbx register does not equal to the rdx register to train
the branch predictor to predict that the next condition for
the comparison instruction is false. In the training process,
there is no exception triggered because that the value stored
in the rbx register are completely controlled by the attacker
procedure. In the sixth execution of the core instructions,
the rbx register will holds the secret data. and the executed
instructions will be highly corresponded to the result of the
comparison instruction at line 15.

4.3

Identifying the Memory-Related Events
Identifying the memory-related events is one of the most
important aims of PMU. Actually, in our experiment device
(the architecture of the processor is Skylake), Intel provides
about 89 PMU counters (the number of the total available
PMU counters is 217) to count the memory-related events,
54 of them are the cache hit/miss-corresponded counters.
Therefore, in the instruction gadget, we also provide support

for identifying some memory-related events, especially the
cache hit/miss-related events.

In the instruction gadget, the ins1 and ins2 are designed
to use different registers for the indirect addressing (in our im-
plementations, ins1 use the rax register for indirect address-
ing and ins2 use the rcx register for indirect addressing).
Before executing the core instructions, the value referred
by the rax register is ﬂushed from the cache and the value
referred by the rcx register is accessed so that it is cached.
With this mechanism, the memory access will miss the cache
(loading data from the main memory) when the secret data
equals to the comparison variable, otherwise, the memory
access will hit the cache (directly loading data from the cache
memory). Consequently, the instruction gadget is able to
recognize some of the memory-related events especially the
cache hit/miss-related events that are triggered during the
execution of the core instruction of the instruction gadget.

5.

IMPLEMENTATION AND EXPERIMENT
RESULTS

We verify the usability of PMUSpill attack by implement-
ing the Foreshadow attack to leak the data protected by SGX
through real experiments. This section shows our experiment
details and results.

5.1 The Experiment Setup

The victim device utilized in our demonstration experi-
ments is Dell Optiplex 7040 desktop featuring an Intel(cid:114)
CoreTM Skylake quad-core i7-6700 processor with a 32 KiB,
8-way L1 data cache. Van et al. [48] have veriﬁed that this
processor is vulnerable to the Foreshadow attack. Besides,
SGX and TSX are enabled by the processor. The operating
system is Ubuntu 18.04 and the kernel version is 5.4.0-96.
We refer to the public exploit codes1 of the Foreshadow attack
to achieve the data leakage from SGX.

The main modiﬁcations that we do to the public exploit
codes of the Foreshadow attack is to replace the instructions
that encode the secret data into the cache layout with our
proposed instruction gadget (presented in Listing 1) and the
secret data recovery mechanism. Those two parts are also the
most important elements in the transient execution attacks.
Because PMU events are the side signals to recover the secret
data instead of the cache layout in the PMUSpill attack, we
should design a new secret data recovery mechanism. How
to mitigate the uncontrollable noises and perturbations to the
PMU counters is the main challenge that we should address
when designing the secret data recovery mechanism.

5.2 Secret Data Recovery Mechanism

The basic idea to infer the secret data is to recognize
whether the expected PMU events are triggered from their
related PMU counters. If a PMU event is triggered, its PMU
counter will be increased. Therefore, ﬁnding an appropriate
threshold for a PMU counter is a natural solution to judge
whether its related PMU event is triggered. This method is
utilized in our inchoate experiments, however, we ﬁnd that it
has three disadvantages:

1https://github.com/jovanbulck/sgx-
step/tree/master/app/foreshadow

• We ﬁnd that the increments of some PMU counters
during the execution of an instruction are not always 1.
Besides, the increments of some PMU counters are not
0 even when the executed instruction is nop. Therefore,
it is impracticable to simply set the threshold as 0 for
all the PMU counters.

• There are a set of PMU counters for each architecture,
ﬁnding the threshold for all the PMU counters and all
the architectures is a tough task.

• Even we can make a pre-test to automatically decide the
threshold by measuring the PMU counters when their
events are triggered and not triggered, the difference
of the execution environment will make the test results
imprecise in the real attacks.

In this study, we design a simple but efﬁcient secret data
recovery mechanism based on the instruction gadget shown
in the Listing 1. The secret data that we recover once a time
has 8 bits, therefore, the secret data have 256 possibilities.
For recovering one byte of the secret data, we iterate the
comparison variable from 0 to 255 to execute the instruction
gadget. The PMU counter’s value is stored for every iteration.
The value whose occurrence number is 1 among the 256
values of the PMU counter means that the expected PMU
event is triggered. We can therefore recover the secret data
by looking for which measurement results in this value. The
principle behind our design is that the value of the PMU
counter when its event is triggered is different from that when
the event is not triggered and each byte of the secret data
must be a value from 0 to 255. Of course, for each byte of
the secret data, executing the instruction gadget several times
and inferring the secret data based on the majority voting will
increase the recovery accuracy for the secret data.

5.3

Instructions and PMU Events Iteration
The PMUSpill attack depends on the PMU events that
can be captured during the transient executions. Therefore,
not all of the PMU events and their trigger instructions can
be utilized to implement PMUSpill attack.
In this study,
we iterate all the valid PMU counters and instructions [1]
to search for the vulnerable PMU events and their trigger
instructions that are available to achieve PMUSpill attack.

5.3.1 Valid PMU Events on the Experiment Device

In order to locate the vulnerable PMU events, we should
ﬁrst obtain all the valid PMU events on the target proces-
sor. Reviewing the Intel’s Software Development Manual
(SDM) [24] is a doable method, but is time-expensive. In
this study, we utilize a PMU tool2 to output the valid PMU
events on our experiment device. The output is a json ﬁle,
which contains the information of every PMU event. Based
on the output ﬁle, we extract the umask and EventCode (in-
formation to recognize the PMU event) of each PMU event.
Through this, we get 214 valid PMU events.

We verify that our obtained PMU events are included in
the Intel SDM. However, from the Intel SDM, we ﬁnd three
PMU events (the ﬁrst three PMU events in the Table 1) that
are not included in the target processors but are available on

2https://github.com/andikleen/pmu-tools

7

other architectures also work on the target processor. This is
an additional ﬁnding that the implementation of the processor
does not strictly equals to the SDM. Therefore, we extend the
number of the valid PMU events from 214 to 217.

5.3.2 Valid Instructions on the Experiment Device

The uops.info data set [1] provides the information of the
Intel X86 Instruction Set Architecture (ISA) in the format of
XML ﬁle, which contains 14546 instructions. However, not
all of the instructions can be successfully executed on our
experiment devices. We ﬁrst extract the assembly instructions
from the data set and then convert them to the inline assembly
instructions that ﬁt the Linux system. Finally, we integrate
those instructions into a ﬁle written in the C language one by
one, the instructions that can be successfully compiled and
executed are treated as the valid instructions in the experiment
device. What should be mentioned is that the instructions
that will raise exceptions will also be selected as they will be
executed transiently in the real attacks. In our experiments,
we get 3069 valid instructions.

5.3.3 PMU Events and Instructions Iteration

Based on the valid PMU events and instructions obtained
aforementioned, we iterate them to get the vulnerable PMU
events and their trigger instructions to implement the PMUS-
pill attack. The ins1 and ins2 in the instruction gadget
shown in Listing 1 are the instructions that we should replace
with the valid instructions. Therefore, a trigger instruction in
this study is deﬁned as a combination of ins1 and ins2. The-
oretically, for each combination of ins1 and ins2, we should
test all the 217 PMU events. Besides, in order to reduce the
inﬂuence of the noises, we execute the instruction gadget 10
times for each PMU event and each combination of ins1 and
ins2. There are total 3069 ∗ 3069 combinations of the ins1
and ins2, which means that test all the PMU events and all
the combinations of the ins1 and ins2 needs to execute the
instruction gadget 3069 ∗ 3069 ∗ 217 ∗ 10 ≈ 2.04 ∗ 1010 times,
which will cost a lot of time.

In order to speed up the iteration, we do not test all the
combinations of ins1 and ins2 in this study. Instead, we
test two scenarios: (1) setting ins2 as nop and iterating
ins1 with the valid instructions (Scenario 1, S1); (2) setting
ins1 as nop and iterating ins2 with the valid instructions
(Scenario 2, S2). We call the instruction in the trigger in-
struction that is not nop as the efﬁcient instruction. Through
this, the execution times of the instruction gadget are reduced
to (3069 + 3069) ∗ 217 ∗ 10 ≈ 1.33 ∗ 107, which can be done
in acceptable time. This will reduce the number of trigger
instructions for the vulnerable PMU events but will have neg-
ligible inﬂuences in this study as our most signiﬁcant goal
is to ﬁnd out the vulnerable PMU events as much as we can
instead of obtaining all the trigger instructions. This will be
discussed in the Section 5.6.

5.4 Vulnerable PMU Events and Their Trig-

ger Instructions

We show our experiment results about the available PMU
events and the number of their corresponding trigger instruc-
tions to implement the PMUSpill attack in Table 1. There are
up to 20 vulnerable PMU events, 8 of them do not rely on the
special trigger instructions (those PMU events are activated

by the shared modules of the processor instead of the private
modules assigned to the executed instructions), but the others
(marked by ∗) rely on some special trigger instructions (those
PMU events only can be activated by their related trigger
instructions).

5.5 Throughput and Error Rate

The throughput and error rate are two major factors to eval-
uate a side channel attack. For every scenario described in the
Section 5.3.3, the number of instructions that are executed is
the same. Besides, the trigger instructions (ins1 and ins2)
are executed transiently, they have negligible effects on the
throughput. Moreover, the time cost by reading the PMU
counters and recovering the secret data from the values of
the PMU counters is similar for different PMU events and
different trigger instructions. Therefore, the throughput of
PMUSpill attack is not mainly decided by the PMU events
and their trigger instructions. It is mainly decided by the
execution rounds of the instruction gadget for recovering one
byte of the secret data and the execution time of the instruc-
tion gadget once a time. In our experiments, the instruction
gadget is executed 10 rounds to recover one byte of the se-
cret data and the throughput of the PMUSpill attack is about
575.3 byte per second (Bps) when leaking 10000 random
bytes according to our experiments.

Different from the throughput, the error rate of PMUSpill
attack is decided by the individual PMU events. This is be-
cause that the efforts for triggering the different PMU events
are different. Some PMU events are easy to trigger but some
is hard to trigger. Besides, according to our experiments, a
PMU event is not always activated by their trigger instruc-
tions. We measure the average error rate of the PMUSpill
attack on leaking the secret data who has 10000 random bytes
with different PMU counters and different trigger instructions
(for the PMU events whose the number of trigger instructions
in every scenario is larger than 200, it will cost several time
to evaluate the error rate for all of trigger instructions. There-
fore, we randomly select 200 trigger instructions to calculate
the average error rate). The experiment results are shown in
the Table 1, which illustrate that the average error rate in the
S1 is 2.07% and it is 1.91% in the S2.

5.6 Experiment Results Analysis

In this study, we through real attacks to verify the avail-
ability of PMUSpill attack on stealing the SGX-private data
combined the Foreshadow attack. Besides, our experiment
results demonstrate that the vulnerable PMU events and their
trigger instructions are numerous, which should be noticed
when designing the PMU module of the processor. More-
over, the throughput and error rate of the PMUSpill attack
are measured. Even the error rate is not fully evaluated for
the PMU events whose the number of trigger instructions
in every scenario is larger than 200, it does not inﬂuence
the conclusion that there are a lot of ways to implement the
PMUSpill attack.

We consider two scenarios of ins1 and ins2 (shown in
the Section 5.3.3), this may reduce our experiment results
about the number of trigger instructions for PMU events
because we do not test all the combinations of ins1 and
ins2, but the PMU events that we obtain will be similar

8

Table 1: Vulnerable PMU events and the average error rate when leaking 10000 random bytes with PMUSpill attack.

Event’s category

Serial
number

PMU event

Event description

#Trigger instr.

Error rate (%)

S1

S2

With TSX
S2
S1

Without TSX
S1

S2

BR_MISP_EXEC

BR_INST_EXEC

INT_MISC

ICACHE_64B

RESOURCE_
STALLS
PARTIAL_
RAT_STALLS

CYCLE_ACTIVITY

RS_EVENTS

ITLB_MISSES

ILD_STALL

EXE_
ACTIVITY

IDQ

DTLB_LOAD_
MISSES

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

ALL_
BRANCHES
ALL_
CONDITIONAL
NONTAKEN_
CONDITIONAL
RECOVERY_
CYCLES
CLEAR_RESTEER_
CYCLES

IFTAG_HIT

IFTAG_STALL

All near executed branches (not necessarily retired)

3069

3069

1.3

0.9

3.2

Speculative and retired mispredicted macro conditional
branches

3069

3069

0.5

0.4

2.4

1.7

1.8

Not taken macro-conditional branches

3069

3069

0.6

0.5

0.9

3.1

Core cycles the allocator was stalled due to recovery
from earlier clear event for this thread
Cycles the issue-stage is waiting for front-end to fetch
from resteered path
Instruction fetch tag lookups that hit in the instruction
cache (L1I)
Cycles where a code fetch is stalled due to L1 instruction
cache tag miss

3069

3069

1.6

2.1

2.8

3069

3069

1.7

1.9

7.0

3069

3069

1.2

1.3

3.6

3069

3069

2.4

2.7

8.3

2.6

5.9

6.3

7.6

ANY

Resource-related stall cycles

3069

3069

0.6

0.5

3.8

4.3

SCOREBOARD∗

STALLS_
MEM_ANY∗
CYCLES_
MEM_ANY∗
CYCLES_
L1D_MISS∗

Cycles where the pipeline is stalled due to serializing
operations
Execution stalls while memory subsystem has an
outstanding load

Cycles while memory subsystem has an outstanding load

1199

Cycles while L1 cache miss demand load is outstanding

1

EMPTY_CYCLES∗

WALK_PENDING∗

MISS_CAUSES_
A_WALK∗

Cycles when Reservation Station (RS) is empty for the
thread
Page Miss Handler (PMH) is busy with a page walk for an
instruction fetch request
Misses at all Instruction TLB (ITLB) levels that cause
page walks

LCP∗

Stalls caused by changing preﬁx length of the instruction

EXE_BOUND_
0_PORTS∗

MS_CYCLES∗

MS_MITE_UOPS∗

MISS_CAUSES_
A_WALK∗

Cycles where no uops were executed

Cycles when uops are being delivered to Instruction
Decode Queue (IDQ)
Uops initiated by MITE and delivered to IDQ while
Microcode Sequenser (MS) is busy
Load misses in all Data TLB (DTLB) levels that cause
page walks

3068

3069

1

0.5

4.9

6.3

1241

1136

0

6

0

6

1.1

-

5.2

-

1.3

2.2

6.5

8.4

2.4

-

7.6

-

2.1

3.3

5.5

8.7

462

444

6.2

4.7

9.4

42

0

16

3

3

3

37

21

0

0

0

0

7.3

4.9

9.1

-

0.8

-

1.7

2.2

3.4

0.8

-

-

-

-

4.3

6.6

5.0

4.2

5.3

7.8

8.4

2.9

-

-

-

-

5.4

Average

1586

1406

2.07

1.91

to the situation that we test all the combinations of ins1
and ins2 because that all the valid instructions are tested
for every PMU event. Besides, ﬁnding part of the trigger
instructions for a PMU event is enough and acceptable in
this study as our most important aim is to ﬁnd the vulnerable
PMU events. Moreover, for every trigger instruction, we may
directly construct a new trigger instruction by replacing its
nop instruction with any of valid instructions except for the
instruction that equals to the efﬁcient instruction in the trigger
instruction. This is because that the efﬁcient instruction is
enough to trigger the PMU events, the nop instruction is
just to be an assistant instruction. We have partly veriﬁed
this judgment through real experiments. Therefore, only
considering the two scenarios is acceptable in this study.

6. MITIGATION TO PMUSpill ATTACK

In this section, we present some possible solutions to miti-
gate PMUSpill attack from both hardware and software sides.
Compared to the hardware-based solutions, the software-
based solutions are easier-to-deploy but may take more per-
formance overhead, the hardware-based solutions can take
less performance overhead but are not very easy to be de-
ployed on the existing devices. Since the PMUSpill attack is
a hardware vulnerability, it will be more efﬁcient to mitigate
it with the hardware-based solutions.

6.1 Hardware-based Countermeasures

PMUSpill attack is caused by the PMU module of proces-
sor, redesigning the PMU module is a fundamental solution
to address it. What should be mentioned is that it is not a
good choice to disable the PMU module because that it is a
very signiﬁcant hardware module for the software developers
to optimize their applications.

The root cause of PMUSpill attack is that some PMU

9

events triggered during the transient executions will be recorded
by the corresponding PMU counters. Therefore, we propose
to mitigate the PMUSpill attack by disabling the vulnera-
ble PMU counters that record the transient execution events.
This may prevent the researchers from reverse engineering
the micro-architecture designs of block-box processors, but
has negligible effects on the clients. Actually, reverse en-
gineering the block-box processors is not one of the aims
of PMU. In the transitional designs of PMU, if the out-of-
order or speculative executions are successfully committed,
the changed PMU counters will not be roll-backed, which
can improve the PMU’s performance on recording the events.
Therefore, the drawback of this design is that the performance
of the PMU module may be reduced.

Enabling PMU to record the events that are activated by
the out-of-order or speculative executions but roll-backing
them if those executions are not successfully committed is
an improved implementation of the proposed method. In
this design, the changed PMU counters will be kept if the
executions are successfully committed, which can take a
small performance overhead but still is able to address the
PMUSpill attack. Like the current hardware modules that will
be roll-backed when needed, this design can be implemented
by renaming the PMU counters and putting the monitored
results into the reorder buffer. The actual PMU counters only
will be updated when the instructions successfully retire.

6.2 Software-based Countermeasures

In the software side, we can mitigate PMUSpill attack by
disabling the PMU through microcode updates. However,
similar to the method of removing the hardware PMU mod-
ule that is described in the aforementioned hardware-based
countermeasures, this will be bad for the software developers.
Because the attack targets of the PMUSpill attack are the
procedures and data owned by TEE, ensuring that the TEE
is not vulnerable to PMUSpill attack is a good measurement
(removing PMU from the TCB of TEE). For example, the
processor vendors can make a microcode update to provide
an interface for the clients to disable PMU through the Basic
Input Output System (BIOS). If the clients need to use TEE,
it should ﬁrst disable the PMU. Otherwise, the PMU can still
be enabled. At the launch step of TEE, the veriﬁcation codes
check whether PMU is disabled (whether the PMU’s statuses
violate the TCB of TEE). If PMU is enabled, it will stop
to launch the TEE-private procedures and data. If not, the
TEE will sequentially perform following procedures. This
software-based countermeasure has been utilized by the In-
tel to mitigate the Dynamic Voltage and Frequency scaling
(DVFS)-based vulnerabilities [39].

7. DISCUSSION AND FUTURE WORK

In this section, we discuss the limitation and possible ex-

tensions of the proposed PMUSpill attack.

7.1 Limitation

Although we have veriﬁed the effectiveness of PMUSpill
attack through real experiments, there are some limitations
that should be discussed.

7.1.1 Transient Execution Vulnerabilities

PMUSpill attack is a kind of side channel attack, in which
the PMU events that are recorded by the hardware PMU mod-
ule in transient executions are the side channel signals. Like
most of the traditional side channel attacks, it depends on
other vulnerabilities (transient execution vulnerabilities in
this study) to achieve the information leakage. Therefore,
if the transient execution vulnerabilities are addressed, the
PMUSpill attack may not become a real threat to the computer
system. Fortunately, we cannot ensure that our processors
are fully resistant to the transient execution attacks. Even
a set of transient execution vulnerabilities are reported and
mitigated, they may be just the tip of the iceberg of the pro-
cessor’s transient execution vulnerabilities. The undisclosed
transient execution vulnerabilities can utilize the PMUSpill
attack to implement the information leakage especially on
the processors whose cache memory are resistant to the side
channel attacks.

7.1.2 Throughput

The throughput of PMUSpill attack is lower than some of
the traditional side channel attacks especially the cache side
channel attacks, for example, the throughput of Foreshadow
attack that depends on the Flush+Reload cache side channel
attack is 27693Bps. This is because that reading the PMU
counters are more time-expensive than accessing the cache
memory. Besides, for every byte of the secret data, the in-
struction gadget is executed 10 rounds to reduce the error
rate, which results in that the core instruction gadget will be
executed 10 ∗ 256 ∗ 6 = 15360 times for every byte. However,
as shown in our real experiments, the PMUSpill attack can
successfully recover the secret data of the Intel SGX com-
bined the Foreshadow attack and the throughput is acceptable.
Of course, we can improve the throughput by reducing the
number of executions of the instruction gadget for recover-
ing one byte of the secret data, but this will inﬂuence the
error rate. Table 2 and Figure 2 shows our experiment results
about the throughput and error rate with different execution
rounds of the instruction gadget when recovering once byte,
respectively. Reducing the execution round will increase the
throughput but also increase the error rate and vice versa.

Table 2: The throughput with different execution rounds
of the instruction gadget for recovering one byte.
4

10

3

6

9

7

5

8

1

2

5.5

2.7

1.8

1,4

1.1

0.93

0.78

0.66

0.61

0.58

Rounds
Throug.
(KBps)

7.1.3 Exception Suppression

In the Listing 1 and our aforementioned experiments, we
utilize the Intel TSX to suppress the exception triggered by
the secret data load instructions as it has no additional inﬂu-
ence on the PMU events. However, not all of the processors
enable Intel TSX. Using the software-based exception han-
dling interface provided by the OS is an alternative exception
suppression method. However, this will introduce some addi-
tional instructions that may also trigger the monitored PMU
events, which may increase the error rate. Luckily, the excep-
tion triggered by the secret data load instructions is ﬁxed and
the exception handling instructions are the same. Therefore,
the PMU events triggered by the exception handling instruc-

10

execution attacks. The future transient execution attacks that
are able to break the TEE may also utilize PMUSpill attack
to complete the information leakage.

7.2.2 Leaking other Information

The experiments utilize PMUSpill attack to leak the data
accessed during transient execution attacks by judging which
execution path of the instruction gadget is taken. In the future
work, we can capture the execution processes of the victim
procedures by measuring the PMU events happened during
the executions and therefore to rebuild their execution ﬂow.
Based on which, we can speculate the functions of the victim
procedures or the secret data of the procedures such as the
key of AES, RSA, ECC, et al.

7.2.3 Detecting the Transient Execution Attacks

The transient execution attacks cannot leak the secret data
directly as the secret data is accessed transiently. They usually
place the secret data-related information into the layouts of
the processor’s micro-architecture modules (cache is the most
utilized module) and recover the secret data by detecting
whether the layouts of the modules are changed (e.g. which
element of the probe array is cached). This step may activate
some special events. We can detect the transient execution
attacks by judging whether the special events-corresponding
counters are increased after the transient executions.

7.2.4 Attacking other Processors

The processor’s architecture of the experiment device is
Skylake in this study. However, PMU is widely enabled
by most of the current processors including those by Intel,
ARM, and AMD. Therefore, we can extend the PMUSpill
attack to the processors that allow PMU to record the events
happened during transient executions. In this extension, the
attack target needs to be the data stored in the TEE of the
victim processor such as Intel SGX, ARM TrustZone, or
AMD Secure Encrypted Virtualization (SEV).

7.2.5 Feeding More Instructions to ins1 and ins2

In our experiments, we only replace the ins1 and ins2 of
the instruction gadget with a single instruction, respectively.
This is enough to ﬁnd out the vulnerable PMU events and
their part of trigger instructions. However, the ins1 and
ins2 are not limited into a single instruction, they can be
fed with multiple instructions. By doing this, we can achieve
more goals. Firstly, we may get more trigger instructions.
Secondly, the increment of the PMU event also can be in-
creased, especially when the trigger instruction is repeated
several times in the ins1 or ins2. Finally, we may ﬁnd more
vulnerable PMU events as some PMU events may relay on a
instruction sequence instead of a single instruction. However,
this will take an explosion of the search space.

8. CONCLUSION

PMU is an important hardware module for software de-
velopers to proﬁle the performance of their applications. In
this study, we ﬁnd that some events triggered by the instruc-
tions that do not successfully retire will also be recorded by
the PMU counters, which will take unexpected data leakage.
Based on this ﬁnding, we propose the PMUSpill attack, a
kind of side channel attack that utilizes PMU events as side

(a) The error rate (%) in the S1.

(b) The error rate (%) in the S2.

Figure 2: The error rate with different execution rounds
of the instruction gadget for recovering one byte.

tions can be treated as an invariant. We measure the average
error rate of the PMUSpill attack for each PMU event when
using the OS-provided interface to suppress the exceptions.
The experiment results are shown in the Table 1. The average
error rate in the two scenarios when handling the exception
with the software is 5.35%, which is about 2.69X than that
when using the Intel TSX to suppress the exception. The
experiment result indicates that using the software to handle
the exception is actually an alternative method to achieve the
PMUSpill attack.

7.2 Future Work

In this study, we utilize PMUSpill attack to speculate the
secret data stored in the Intel SGX by achieving the Fore-
shadow attack, more studies may be conducted based on the
PMUSpill attack.

7.2.1 Achieving other Transient Execution Attacks

The Foreshadow attack is utilized as a demonstration to
verify the availability of PMUSpill attack in leaking the secret
data of SGX. However, the applications of the PMUSpill
attack may not be limited to implement the existing transient

11

1234567891011121314151617181920The serial number of vulnerable PMU events12345678910The execution round of the instruction gadget0.0-0.60.6-1.31.3-1.91.9-2.52.5-3.13.1-3.83.8-4.44.4-5.05.0-5.65.6-6.36.3-6.96.9-7.57.5-8.18.1-8.88.8-9.49.4-10.012345678910111213141516The serial number of vulnerable PMU events12345678910The execution round of the instruction gadget0.0-0.60.6-1.31.3-1.91.9-2.52.5-3.13.1-3.83.8-4.44.4-5.05.0-5.65.6-6.36.3-6.96.9-7.57.5-8.18.1-8.88.8-9.4channel signals to recover the secret data that are accessed
during transient executions. In order to achieve the PMUSpill
attack, we design an instruction gadget to encode the secret
data into its execution path that can be identiﬁed by the PMU
counters. We verify the usability of the PMUSpill attack by
implementing the Foreshadow attack to steal the secret data
stored in the Intel SGX. Our experiments suggest that several
PMU events are vulnerable. We also provide some possible
hardware and software-based solutions for addressing the
PMUSpill attack. At the end of the paper, we analyze the
limitation and possible extensions of this study.

REFERENCES

[1] A. Abel and J. Reineke, “uops. info: Characterizing latency,

throughput, and port usage of instructions on intel microarchitectures,”
in Proceedings of the Twenty-Fourth International Conference on
Architectural Support for Programming Languages and Operating
Systems. Providence, RI, USA: ACM, 2019, pp. 673–686.

[2] M. Alam, B. Yilmaz, F. Werner, N. Samwel, A. Zajic, D. Genkin,

Y. Yarom, and M. Prvulovic, “Nonce@ once: A single-trace em side
channel attack on several constant-time elliptic curve implementations
in mobile platforms,” in 2021 IEEE European Symposium on Security
and Privacy (EuroS&P).
507–522.

IEEE Computer Society, 2021, pp.

[3] A. ARM, “Security technology building a secure system using
trustzone technology (white paper),” ARM Limited, 2009.

[4] B. Asvija, R. Eswari, and M. Bijoy, “Template attacks on ecc

implementations using performance counters in cpu,” Microelectronics
Journal, vol. 106, p. 104935, 2020.

[5] S. Bhattacharya and D. Mukhopadhyay, “Who watches the watchmen?:
Utilizing performance monitors for compromising keys of rsa on intel
platforms,” in Cryptographic Hardware and Embedded Systems –
CHES 2015. Berlin, Heidelberg: Springer, 2015, pp. 248–266.

[6] F. Brasser, U. Müller, A. Dmitrienko, K. Kostiainen, S. Capkun, and
A.-R. Sadeghi, “Software grand exposure:{SGX} cache attacks are
practical,” in 11th USENIX Workshop on Offensive Technologies
(WOOT 17), 2017.

[7] R. Buerki and A.-K. Rueegsegger, “Muen-an x86/64 separation kernel
for high assurance,” University of Applied Sciences Rapperswil (HSR),
Tech. Rep, 2013.

[8] C. Canella, D. Genkin, L. Giner, D. Gruss, M. Lipp, M. Minkin,
D. Moghimi, F. Piessens, M. Schwarz, B. Sunar et al., “Fallout:
Leaking data on meltdown-resistant cpus,” in ACM SIGSAC
Conference on Computer and Communications Security. London,
UK: ACM, 2019, pp. 769–784.

[9] G. Chen, S. Chen, Y. Xiao, Y. Zhang, Z. Lin, and T. H. Lai,

“Sgxpectre: Stealing intel secrets from sgx enclaves via speculative
execution,” in 2019 IEEE European Symposium on Security and
Privacy (EuroS&P).

IEEE, 2019, pp. 142–157.

[10] J. Cho, T. Kim, S. Kim, M. Im, T. Kim, and Y. Shin, “Real-time

detection for cache side channel attack using performance counter
monitor,” Applied Sciences, vol. 10, no. 3, p. 984, 2020.

[11] V. Costan and S. Devadas, “Intel sgx explained,” Cryptology ePrint

Archive, 2016.

[12] G. Deepa, G. SriTeja, and S. Venkateswarlu, “An overview of acoustic

side-channel attack,” International Journal of Computer Science &
Communication Networks, vol. 3, no. 1, p. 15, 2013.

[13] D. Evtyushkin, R. Riley, N. C. Abu-Ghazaleh, ECE, and

D. Ponomarev, “Branchscope: A new side-channel attack on
directional branch predictor,” ACM SIGPLAN Notices, vol. 53, no. 2,
pp. 693–707, 2018.

[14] W. Futral and J. Greene, Intel Trusted Execution Technology for Server

Platforms: A Guide to More Secure Datacenters. Springer Nature,
2013.

[15] M. Godfrey and M. Zulkernine, “Preventing cache-based side-channel

attacks in a cloud environment,” IEEE transactions on cloud
computing, vol. 2, no. 4, pp. 395–408, 2014.

[16] J. Götzfried, M. Eckert, S. Schinzel, and T. Müller, “Cache attacks on
intel sgx,” in Proceedings of the European Workshop on Systems
Security, ser. EuroSec’17. New York, NY, USA: Association for
Computing Machinery, 2017. [Online]. Available:
https://doi.org/10.1145/3065913.3065915

[17] B. Gras, C. Giuffrida, M. Kurth, H. Bos, and K. Razavi, “Absynthe:

Automatic blackbox side-channel synthesis on commodity
microarchitectures.” in NDSS, 2020.

[18] B. Gras, K. Razavi, H. Bos, and C. Giuffrida, “Translation leak-aside
buffer: Defeating cache side-channel protections with {TLB} attacks,”
in 27th USENIX Security Symposium (USENIX Security 18), 2018, pp.
955–972.

[19] D. Gruss, C. Maurice, K. Wagner, and S. Mangard, “Flush+ ﬂush: a
fast and stealthy cache attack,” in International Conference on
Detection of Intrusions and Malware, and Vulnerability Assessment.
Springer, 2016, pp. 279–299.

[20] A. Gundu, G. Sreekumar, A. Shaﬁee, S. Pugsley, H. Jain,

R. Balasubramonian, and M. Tiwari, “Memory bandwidth reservation
in the cloud to avoid information leakage in the memory controller,” in
Proceedings of the Third Workshop on Hardware and Architectural
Support for Security and Privacy, 2014, pp. 1–5.

[21] M. D. Hill, J. Masters, P. Ranganathan, P. Turner, and J. L. Hennessy,
“On the spectre and meltdown processor security vulnerabilities,” IEEE
Micro, vol. 39, no. 2, pp. 9–19, 2019.

[22] Q. Hu, X. Fan, and Q. Zhang, “An effective differential power attack
method for advanced encryption standard,” in 2019 International
Conference on Cyber-Enabled Distributed Computing and Knowledge
Discovery (CyberC).
IEEE, 2019, pp. 58–61.

[23] R. Hund, C. Willems, and T. Holz, “Practical timing side channel

attacks against kernel space aslr,” in 2013 IEEE Symposium on
Security and Privacy.

IEEE, 2013, pp. 191–205.

[24] Intel, Intel 64 and IA-32 architectures software developer’s manual,

2015. [Online]. Available: http://www-ssl.intel.com/content/www/us/
en/processors/architectures-software-developer-manuals.html

[25] M. Jadid, M. Esfehani, and E. Mohammadgholi, “Survey of cache side
channel attacks on the aes encryption algorithm implementation,”
Journal of Information and Communication Technology in Policing
(JICTP), vol. 1, no. 4, pp. 27–38, 2021.

[26] J. S. Jang, S. Kong, M. Kim, D. Kim, and B. B. Kang, “Secret: Secure

channel between rich execution environment and trusted execution
environment.” in NDSS, 2015, pp. 1–15.

[27] M. Kayaalp, N. Abu-Ghazaleh, D. Ponomarev, and A. Jaleel, “A
high-resolution side-channel attack on last-level cache,” in
Proceedings of the 53rd Annual Design Automation Conference, 2016,
pp. 1–6.

[28] P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas,

M. Hamburg, M. Lipp, S. Mangard, T. Prescher et al., “Spectre
attacks: Exploiting speculative execution,” in 2019 IEEE Symposium
on Security and Privacy (SP), IEEE. San Francisco, CA, USA: IEEE,
2019, pp. 1–19.

[29] E. M. Koruyeh, K. N. Khasawneh, C. Song, and N. Abu-Ghazaleh,

“Spectre returns! speculation attacks using the return stack buffer,” in
12th USENIX Workshop on Offensive Technologies (WOOT 18), 2018.

[30] M. Lipp, A. Kogler, D. Oswald, M. Schwarz, C. Easdon, C. Canella,
and D. Gruss, “Platypus: software-based power side-channel attacks
on x86,” in 2021 IEEE Symposium on Security and Privacy (SP).
IEEE, 2021, pp. 355–371.

[31] M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas, A. Fogh,

J. Horn, S. Mangard, P. Kocher, D. Genkin et al., “Meltdown: Reading
kernel memory from user space,” in 27th USENIX Security Symposium
(USENIX Security 18). Baltimore, MD: USENIX Association, 2018,
pp. 973–990.

[32] F. Liu, Q. Ge, Y. Yarom, F. Mckeen, C. Rozas, G. Heiser, and R. B.

Lee, “Catalyst: Defeating last-level cache side channel attacks in
cloud computing,” in 2016 IEEE international symposium on high
performance computer architecture (HPCA).
406–418.

IEEE, 2016, pp.

[33] F. Liu, Y. Yarom, Q. Ge, G. Heiser, and R. B. Lee, “Last-level cache
side-channel attacks are practical,” in 2015 IEEE symposium on
security and privacy.

IEEE, 2015, pp. 605–622.

[34] A. Mambretti, M. Neugschwandtner, A. Sorniotti, E. Kirda,

12

W. Robertson, and A. Kurmus, “Speculator: a tool to analyze
speculative execution attacks and mitigations,” in Proceedings of the
35th Annual Computer Security Applications Conference, 2019, pp.
747–761.

T. Prescher, and D. Gruss, “Zombieload: Cross-privilege-boundary
data sampling,” in Proceedings of the 2019 ACM SIGSAC Conference
on Computer and Communications Security. London, UK: ACM,
2019, pp. 753–768.

[46] E. Tromer, D. A. Osvik, and A. Shamir, “Efﬁcient cache attacks on

aes, and countermeasures,” Journal of Cryptology, vol. 23, no. 1, pp.
37–71, 2010.

[47] L. Uhsadel, A. Georges, and I. Verbauwhede, “Exploiting hardware

performance counters,” in 2008 5th Workshop on Fault Diagnosis and
Tolerance in Cryptography.

IEEE, 2008, pp. 59–67.

[48] J. Van Bulck, M. Minkin, O. Weisse, D. Genkin, B. Kasikci,

F. Piessens, M. Silberstein, T. F. Wenisch, Y. Yarom, and R. Strackx,
“Foreshadow: Extracting the keys to the intel {SGX} kingdom with
transient out-of-order execution,” in 27th {USENIX} Security
Symposium. Baltimore, MD: USENIX Association, 2018, pp.
991–1008.

[49] S. Van Schaik, A. Milburn, S. Österlund, P. Frigo, G. Maisuradze,

K. Razavi, H. Bos, and C. Giuffrida, “Ridl: Rogue in-ﬂight data load,”
in IEEE Symposium on Security and Privacy (SP). Fukuoka, Japan:
IEEE, 2019, pp. 88–105.

[50] S. van Schaik, M. Minkin, A. Kwong, D. Genkin, and Y. Yarom,

“Cacheout: Leaking data on intel cpus via cache evictions,” in 2021
IEEE Symposium on Security and Privacy (SP).
IEEE, 2021, pp.
339–354.

[51] L. Wei, B. Luo, Y. Li, Y. Liu, and Q. Xu, “I know what you see: Power
side-channel attack on convolutional neural network accelerators,” in
Proceedings of the 34th Annual Computer Security Applications
Conference, 2018, pp. 393–406.

[52] L. Weissbart, S. Picek, and L. Batina, “One trace is all it takes:
Machine learning-based side-channel attack on eddsa,” in
International Conference on Security, Privacy, and Applied
Cryptography Engineering. Springer, 2019, pp. 86–105.

[53] Y. Xiao, X. Zhang, Y. Zhang, and R. Teodorescu, “One bit ﬂips, one

cloud ﬂops:{Cross-VM} row hammer attacks and privilege escalation,”
in 25th USENIX Security Symposium (USENIX Security 16), 2016, pp.
19–35.

[54] Y. Yarom and K. Falkner, “Flush+ reload: A high resolution, low

noise, l3 cache side-channel attack,” in USENIX Security Symposium.
San Diego, CA: USENIX Association, 2014, pp. 719–732.

[55] B. B. Yilmaz, M. Prvulovic, and A. Zaji´c, “Electromagnetic side
channel information leakage created by execution of series of
instructions in a computer processor,” IEEE Transactions on
Information Forensics and Security, vol. 15, pp. 776–789, 2019.

[35] F. McKeen, I. Alexandrovich, I. Anati, D. Caspi, S. Johnson,

R. Leslie-Hurd, and C. Rozas, “Intel® software guard extensions
(intel® sgx) support for dynamic memory management inside an
enclave,” in Proceedings of the Hardware and Architectural Support
for Security and Privacy 2016, 2016, pp. 1–9.

[36] D. Moghimi, M. Lipp, B. Sunar, and M. Schwarz, “Medusa:

Microarchitectural data leakage via automated attack synthesis,” in
29th USENIX Security Symposium (USENIX Security 20), 2020, pp.
1427–1444.

[37] S. Niu, J. Mo, Z. Zhang, and Z. Lv, “Overview of linux vulnerabilities,”
in 2nd International Conference on Soft Computing in Information
Communication Technology. Atlantis Press, 2014, pp. 225–228.

[38] D. A. Osvik, A. Shamir, and E. Tromer, “Cache attacks and

countermeasures: the case of aes,” in Cryptographers’ track at the
RSA conference. Springer, 2006, pp. 1–20.

[39] P. Qiu, D. Wang, Y. Lyu, and G. Qu, “Voltjockey: Breaking sgx by

software-controlled voltage-induced hardware faults,” in 2019 Asian
Hardware Oriented Security and Trust Symposium (AsianHOST).
IEEE, 2019, pp. 1–6.

[40] P. Qiu, D. Wang, Y. Lyu, R. Tian, C. Wang, and G. Qu, “Voltjockey: A
new dynamic voltage scaling-based fault injection attack on intel sgx,”
IEEE Transactions on Computer-Aided Design of Integrated Circuits
and Systems, vol. 40, no. 6, pp. 1130–1143, 2020.

[41] H. Ragab, E. Barberis, H. Bos, and C. Giuffrida, “Rage against the

machine clear: A systematic analysis of machine clears and their
implications for transient execution attacks,” in 30th USENIX Security
Symposium (USENIX Security 21), 2021, pp. 1451–1468.

[42] H. Ragab, A. Milburn, K. Razavi, H. Bos, and C. Giuffrida, “Crosstalk:

Speculative data leaks across cores are real,” in IEEE Symposium on
Security and Privacy, Institute of Electrical and Electronics Engineers
Inc. San Francisco, CA, USA: IEEE, 2021, pp. 1852–1867.

[43] M. Rosière, J.-l. Desbarbieux, N. Drach, and F. Wajsbürt, “An

out-of-order superscalar processor on fpga: The reorder buffer design,”
in 2012 Design, Automation & Test in Europe Conference &
Exhibition (DATE).

IEEE, 2012, pp. 1549–1554.

[44] M. Sabt, M. Achemlal, and A. Bouabdallah, “Trusted execution
environment: what it is, and what it is not,” in 2015 IEEE
Trustcom/BigDataSE/ISPA, vol. 1.

IEEE, 2015, pp. 57–64.

[45] M. Schwarz, M. Lipp, D. Moghimi, J. Van Bulck, J. Stecklina,

13

