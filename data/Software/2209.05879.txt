2
2
0
2

p
e
S
3
1

]

O
L
.
s
c
[

1
v
9
7
8
5
0
.
9
0
2
2
:
v
i
X
r
a

Bounded Model Checking for Unbounded
Client-Server Systems

Ramchandra Phawade1, Tephilla Prince1, and S. Sheerazuddin2

1 Indian Institute of Technology Dharwad, India
prb@iitdh.ac.in, tephilla.prince.18@iitdh.ac.in
2 National Institute of Technology Calicut, India
sheeraz@nitc.ac.in

Abstract. Bounded model checking (BMC) is an eﬃcient formal veriﬁ-
cation technique which allows for desired properties of a software system
to be checked on bounded runs of an abstract model of the system. The
properties are frequently described in some temporal logic and the sys-
tem is modeled as a state transition system. In this paper we propose a
novel counting logic, LC, to describe the temporal properties of client-
server systems with an unbounded number of clients. We also propose
two dimensional bounded model checking (2D-BMC) strategy that uses
two distinguishable parameters, one for execution steps and another for
the number of tokens in the net representing a client-server system, and
these two evolve separately, which is diﬀerent from the standard BMC
techniques in the Petri Nets formalism. This 2D-BMC strategy is imple-
mented in a tool called DCModelChecker which leverages the 2D-BMC
technique with a state-of-the-art satisﬁability modulo theories (SMT)
solver Z3. The system is given as a Petri Net and properties speciﬁed
using LC are encoded into formulas that are checked by the solver. Our
tool can also work on industrial benchmarks from the Model Checking
Contest (MCC). We report on these experiments to illustrate the appli-
cability of the 2D-BMC strategy.

Keywords: Bounded Model Checking · SAT solvers · Petri Nets · Counting
Logics · Temporal Logics

1

Introduction

Model checking [3] is a formal veriﬁcation technique that allows for desired be-
havioral properties of a given system to be veriﬁed based on a suitable model of
the system through systematic inspection of all states of the model. The major
challenge of model checking is that the state space of systems might be inﬁnite.
In bounded model checking, this challenge is overcome by assuming a predeter-
mined bound on the runs, and all possible paths are explored. This technique
uses a single parameter for execution steps, to unfold the system behaviour.
Bounded Model Checking [5,10,4] is widely used in the industry by restricting

 
 
 
 
 
 
2

R. Phawade et al.

the model checking problem to a bounded problem and verifying properties on
bounded runs of the system.

We consider the case of a client-server system with an unbounded number
of agents, which we model as unbounded Petri Nets. In this work, we propose a
novel extension to standard bounded model checking technique, the two dimen-
sional bounded model checking (2D-BMC) strategy for unbounded client-server
systems, that uses two distinguishable parameters, one for execution steps and
another for the number of tokens in the net and these two evolve separately,
which is diﬀerent from the standard BMC techniques for Petri Nets.

Typically, in standard BMC, temporal logic is used to specify the properties
of the system. In this setting of unbounded client-server systems, we would also
like to express additional counting properties of the client and the server. We
propose a novel counting logic with temporal operators, LC .

To illustrate the usefulness of the newly introduced 2D-BMC strategy and
counting logic LC , we implemented them in our new tool DCModelChecker. 3
BMC for Petri Nets while expressing properties using linear temporal logic while
leveraging the power of SMT Solvers remains unexplored. DCModelChecker at-
tempts to bridge this gap. We have considered benchmark models from the Model
Checking Contest [17], and translated a subset of the properties into LC and have
obtained the satisfaction or counterexample trace in each case. Details of the tool
and experiments are discussed in Section 5.1 and Section 6 respectively.

This paper makes the following contributions:

– We introduce a novel technique - 2D-BMC to verify the properties of the

system.

– We introduce a counting logic language, LC for describing the counting prop-

erties of the system as well as temporal properties of the system.

– We build a tool, DCModelChecker, that uses 2D-BMC and the designed

counting logic language for veriﬁcation.

– We perform an experimental evaluation of our tool, with academic and in-
dustrial models from the Model Checking Contest (MCC) [17], and compare
the results against the state of the art tool ITS-Tools [26]. To the best of
our knowledge, ours is the only tool that can perform 2D-BMC and provide
the counterexample as well.

Organization of our paper: We begin with the preliminaries on Petri Nets and
their encoding in the next section. We introduce counting logic LC in Section 3.
In Section 4, we discuss the novel 2D-BMC strategy and give its encoding and
demonstrate the unfolding of formulas in this technique. The rest of the paper
discusses the details of the tool DCModelChecker, elaborating on its architecture
in Section 5.1, and the workﬂow of the tool in Section 5.2. Experiments using
DCModelChecker are in Section 6, followed by the related work in Section 7,
and future work in Section 8.

3 https://doi.org/10.6084/m9.ﬁgshare.19611477.v3

2D-BMC

3

2 Preliminaries

The bounded model checking problem can be described as follows. Given a sys-
tem S and a speciﬁcation or property α on bounded runs of the system, decide
whether system S satisﬁes speciﬁcation α. This consists of checking that all runs
of S constitute models for α. It suﬃces to show that no run of S is a model for
¬α, which is the same as checking that the intersection of the language accepted
by S and the language deﬁned by ¬α is empty.

We illustrate how client-server systems with unbounded agents can be math-
ematically encoded as nets in Section 2.1 and in Section 3 we explore a suitable
logic to express its properties.

It is to be noted that theoretically, there may be an unbounded number of
clients in the unbounded client-server system at any instant. Practically, factors
such as environment limitations and hardware design may limit the number of
clients that are present in an instant.

2.1 Petri Nets

A Petri Net structure is a tuple N = (P, T, F, W ) where P is a ﬁnite set of places,
T is a ﬁnite set of transitions, F ⊆ (P × T ) ∪ (T × P ) is the ﬂow relation and
W : F → ℵ0 is a weight function, where ℵ0 is the set of non-negative integers.
For any place (resp. transition) z of the set P ∪ T , the set {x | (x, z) ∈ F } is
called pre-transitions (resp. pre-places) of z, and the set {x | (z, x) ∈ F } is called
post-transitions (resp. post-places) of z.

A marking M of a Petri Net is a fuction M : P → ℵ0. A Petri Net (system)
is a tuple P N = (N, M0) where N is a Petri Net structure and M0 is an initial
marking. A transition t is enabled at marking M , if for each pre-place p of t we
have M (p) ≥ W (p, t). A new marking is obtained when an enabled transition is
ﬁred, and is obtained by removing W (p, t) tokens from each pre-place p of t, and
adding W (t, p) tokens to each post-place p of t, leaving tokens in the remaining
places as it is.

Encoding of Petri Nets For the purpose of BMC we need to ﬁrst encode a
Petri Net system in propositional logic. A similar encoding can be found in [1,2].
Let N = (P, T, F, W ) be a Petri Net structure. Let T = {t1, . . . , tn} and P =
{p0, . . . , pl}. The variables used in the encoding are as follows. For each transition
ti ∈ T , there is a copy of the variable that is used in the encoding. For each
place pi ∈ P , we have two variables pxi and pyi in the encoding – pxi denotes
the number of tokens in pi before ﬁring of some transition and pyi denotes the
number of tokens in the same place after the ﬁring. We have a vector of variables
M that keep track of the marking. The propositional encoding of N is deﬁned
by the formula T = Tenabled ∧ Tf irability ∧ Tnext, where:

– the formula Tenabled states that more than one transition can be enabled at
a time. i.e, it is an or over the preconditions of all enabled transitions and
is given by Tenabled = pret0 ∨ pret1 ∨ · · · ∨ pretn ;

4

R. Phawade et al.

– the formula Tnext gives us the next transition that will be ﬁred, and is ex-
pressed as an or expression over each transition and its postcondition and
all other transitions and postconditions are negated.
Tnext =

(t0 ∧ ¬t1 ∧ · · · ∧ ¬tn ∧ postt0 ∧ ¬postt1 ∧ · · · ∧ ¬posttn )∨
(¬t0 ∧ t1 ∧ · · · ∧ ¬tn ∧ ¬postt0 ∧ postt1 ∧ · · · ∧ ¬posttn ) ∨ · · · ∨
(¬t0 ∧ ¬t1 ∧ · · · ∧ tn ∧ ¬postt0 ∧ ¬postt1 ∧ · · · ∧ posttn );

– the formula Tf irability relates the pre condition of a transition with its distinct

postcondition and is given as

Tf irability = (postt0 → pret0 ) ∧ (postt1 → pret1 ) ∧ · · · ∧ (posttn → pretn );
where for each ti, preti is a propositional formula deﬁned over place variables
encoding that the precondition of ﬁring ti is satisﬁed and postti is a formula
deﬁned over place variables encoding the update in tokens after ﬁring ti is
satisﬁed.

We denote the encoding of Petri Net system P N = (N, M0) by M = (T , M0)
where M0 is the initial assignment of the marking vector M .

3 Counting Logic

Our next objective is to identify a suitable logical language for describing proper-
ties of the unbounded client-server system. Linear Temporal Logic (LT L) [22,28]
is a natural choice to describe temporal properties of systems.

While LT L is useful to us, we cannot express any counting properties, hence,
we propose the counting logic language to specify and verify the unbounded
client-server system. Logic LC is an extension of LT L with a few diﬀerences.
In the case of LT L, atomic formulas are propositional constants which have no
further structure. A monodic formula is a well formed formula with at most
one free variable in the scope of a temporal modality. In LC , there are three
types of atomic formulas: (1) describing basic server properties, Ps which are
propositional constants (2) counting sentences of the kinds (#x > c)α and
(#x ≤ c)α over client properties and c is a non-negative integer, denoting the
number of clients in α, and (3) comparing sentences of the kinds (#x)α ≤ β
and (#x)α > β.

Formally, the set of client formulas ∆ is given by:

α, β ∈ ∆ ::= (#x > c)p(x) | (#x ≤ c)p(x) | (#x)p(x) ≤ q(x) | (#x)p(x) > q(x) | α∨β | α∧β

where p, q ∈ Pc and c is a non-negative integer, as noted above. While ∆ does
not contain an explicit = operator, it is natural to express equality of p(x) and
q(x) as follows: (#x)p(x) > q(x) ∧ (#x)q(x) > p(x).

The server formulas are deﬁned as follows:

ψ ∈ Ψ ::= q ∈ Ps | ϕ ∈ ∆ | ¬ψ | ψ ∨ ψ | ψ ∧ ψ | Xψ | F ψ | Gψ | ψ1U ψ2

Modalities X, F, G and U are the usual modal operators: Next, Eventually,
Globally and Until respectively.

2D-BMC

5

Semantics The logic is interpreted over model sequences. Formally, a model is
a sequence ̺ = m0, m1, . . ., where for all i ≥ 0 we have a triple mi = (νi, Vi, ξi)
such that:

1. νi ⊂f in Ps, gives the local properties of the server at instant i.
2. Vi ⊂f in CN gives the clients alive at instant i, where CN is a countable set
of client names that can be assigned to the processes in the system. Further,
for all i ≥ 0, Vi+1 ⊆ Vi or Vi ⊆ Vi+1.

3. ξi : Vi → 2Pc gives the properties satisﬁed by each live agent at the ith

instant.

The truth of a formula at an instant in the model is given by the relations
|= and |=∆ deﬁned by induction over the structure of ψ and α respectively as
follows:

1. ̺, i |= q iﬀ q ∈ νi. Note that q’s denote atomic local server propositions.

Therefore, a q holds in the model ̺ at instance i if q is in the set νi.

2. ̺, i |= ϕ iﬀ ̺, i |=∆ ϕ. Recall that ϕ is a sentence from the set of client
formulae ∆. In order to deﬁne the satisﬁability of ϕ, we need to use the rules
deﬁned for the relation |=∆.

3. ̺, i |= ¬ψ iﬀ ̺, i 6|= ψ.
4. ̺, i |= ψ ∨ ψ′ iﬀ ̺, i |= ψ or ̺, i |= ψ′.
5. ̺, i |= ψ ∧ ψ′ iﬀ ̺, i |= ψ and ̺, i |= ψ′.
6. ̺, i |= Xψ iﬀ ̺, i + 1 |= ψ.
7. ̺, i |= F ψ iﬀ ∃j ≥ i, ̺, j |= ψ.
8. ̺, i |= Gψ iﬀ ∀j ≥ i, ̺, j |= ψ.
9. ̺, i |= ψ1U ψ2 iﬀ ∃j ≥ i, ̺, j |= ψ2 and for all i ≤ j′ < j : ̺, j′ |= ψ1.
10. ̺, i |=∆ (#x > c)p(x) iﬀ |{a ∈ Vi | p ∈ ξi(a)}| > c. The client formula
(#x > c)p(x) holds in model ̺ at instance i if there are strictly more than
c clients that satisfy the property p at instance i.

11. ̺, i |=∆ (#x)p(x) ≤ q(x) iﬀ |{a ∈ Vi | p ∈ ξi(a)}| ≤ |{b ∈ Vi | q ∈ ξi(b)}|.
The client formula (#x)p(x) ≤ q(x) holds in the model ̺ at instance i if
the number of clients satisfying property p is less than the number of clients
satisfying the property q, at the same instance i.

12. ̺, i |=∆ (#x ≤ c)p(x) iﬀ |{a ∈ Vi | p ∈ ξi(a)}| ≤ c. The client formula
(#x ≤ c)p(x) holds in model ̺ at instance i if there are less than c clients
that satisfy the property p at instance i.

13. ̺, i |=∆ (#x)p(x) > q(x) iﬀ |{a ∈ Vi | p ∈ ξi(a)}| > |{b ∈ Vi | q ∈ ξi(b)}|.
The client formula (#x)p(x) > q(x) holds in the model ̺ at instance i if the
number of clients satisfying property p is strictly more than the number of
clients satisfying the property q, at the same instance i.

14. ̺, i |=∆ α ∨ β iﬀ ̺, i |=∆ α or ̺, π, i |=∆ β.
15. ̺, i |=∆ α ∧ β iﬀ ̺, i |=∆ α and ̺, π, i |=∆ β.

To illustrate the expressibility of the counting logic, consider the property
of an inﬁnite state system, such that at some time in the future, the number of
tokens at place p1 is greater than the number of tokens in place p0, is written as
F (#x)p1(x) > p0(x). Details of expressing the properties with respect to case
studies are discussed in Appendix A.2 and Appendix B.2.

6

R. Phawade et al.

4 The Two Dimensional Bounded Model Checking

Strategy

In this section, we set out to enunciate the novel two dimensional bounded
model checking strategy that we have devised and implemented to check LC
speciﬁcations against Petri Net models. To quote Biere et al. [6], “The basic
idea behind bounded model checking (BMC) is to restrict the general model
checking problem to a bounded problem. Instead of asking whether the system M
violates the property Ψ , we ask whether the system M has any counterexample
of length k to Ψ . This bounded problem is encoded into SAT.” In 2D-BMC, we
ask whether the system M has any counterexample of length λ and number of
clients κ to Ψ , in the unbounded client-server setting, and encode this bounded
problem into SMT.

First, we describe the notation that we have used. Let M be the propositional
encoding of the Petri Net model of the system. Also, let φ be the LC property
that we want to verify. As usual we negate the property φ and let ψ = ¬φ. We
also assume that ψ is used in its negation normal form.

The 2D-BMC encoding of M against ψ for the bound k = λ + κ (where

k ≥ 0) is denoted by [M, ψ]hλ,κi and deﬁned as follows:

[M, ψ]hλ,κi = [M]hλ,κi ∧

¬Lhλ,κi ∧ [ψ]0

hλ,κi

∨

k

(cid:16)(cid:0)

l=0
_

(cid:1)

(lLhλ,κi ∧ l[ψ]0

hλ,κi)
(cid:17)

The bound k has two parts λ and κ: λ gives the bound for time instances and
κ gives the bound for number of clients. [M]hλ,κi is the propositional formula
encoding the runs of M of bound k = λ + κ. The formulae [M]hλ,κi, for 0 ≤
λ, κ ≤ k are deﬁned later in this section.

The formulas lLhλ,κi (0 ≤ l ≤ λ) and Lhλ,κi are loop conditions that are
mentioned in the encoding above. For any 0 ≤ l ≤ λ, lLhλ,κi = T (sλ, sl) where
sl is the lth state in the run of M and sλ is the λth state. Note, here state is
deﬁned in terms of value of the marking vector M . So, for any instance i, si
corresponds to the state of vector M at i. Clearly, when lLhλ,κi holds it means
there is a transition from sλ to sl which denotes a back loop to the lth state. The
lLhλ,κi. When Lhλ,κi
other loop condition is deﬁned as follows: Lhλ,κi =

0≤l≤λ
W

holds, it means there is a back loop to some state in the bounded run of M.

Formula [ψ]0

hλ,κi is the propositional encoding of ψ for the bound k = λ + κ
when ψ is asserted at initial instance i = 0 and there is no loop in the run of
M. On the other hand, l[ψ]0
hλ,κi is the propositional encoding of ψ for the bound
k = λ + κ when ψ is asserted at initial instance i = 0 and there is a back loop
to the lth state in the run of M. Formulas [ψ]i
hλ,κi, for any i, are
extensions of similar mappings deﬁned in [5].

hλ,κi and l[ψ]i

The bound k = λ + κ starts from 0 and is incremented by 1 in each (macro-
)step. For a ﬁxed k, λ may start from 0, incremented by 1 in each (micro-)step
till k. Simultaneously, κ may move from k to 0 and decrement by 1 in each

2D-BMC

7

(micro-)step. We look at each (micro-)step. Let the variables being used in the
Boolean encoding of Petri Net be:

Transitions: t0, t1, . . . , tnt and Places: p0, p1, . . . , pnp.
We use copies of transition variables t0i, . . . , tnti, place variables p0j, . . . , pnpi,

where 0 ≤ i ≤ λ, in [M]hλ,κi. For any κ ≥ 0, we deﬁne

[M]h0,κi = I(s0) ∧ (

pj0 ≤ κ).

^0≤j≤np

Inductively, for any λ > 0,

[M]hλ,κi = [M]hλ−1,κi ∧ (T (sλ−1, sλ) ∧ (

pjλ ≤ κ)).

^0≤j≤np

Now that we have formally described the notations for encoding of M, we

give the propositional encoding of LC for M in the subsequent section.

4.1 Propositional encoding of the logic LC

We need to introduce counter variables for each place p in the input Petri Net
in order to deﬁne the propositional encodings of the property ψ. These extra
variables are as follows: {ci
p | i ≥ 0, and p is a place in the Petri Net}. Now
hλ,κi and [ψ]i
we are ready to deﬁne l[ψ]i
hλ,κi inductively as
follows:

hλ,κi. We deﬁne l[ψ]i

hλ,κi ≡ ¬qi

hλ,κi ≡ qi

1. l[q]i
2. l[¬q]i
3. l[ψ1 ∨ ψ2]i
4. l[ψ1 ∧ ψ2]i

5. l[Xψ1]i

hλ,κi ≡

6. l[F ψ1]i

hλ,κi ≡

7. l[Gψ1]i

hλ,κi ≡

hλ,κi ≡ l[ψ1]i
hλ,κi ≡ l[ψ1]i
l[ψ1]i+1
hλ,κi
l[ψ1]l
κ

hλ,κi ∨ l[ψ2]i
hλ,κi ∧ l[ψ2]i
if i < κ
if i = κ

hλ,κi

(

hλ,κi

hλ,κi

l[ψ1]j

hλ,κi

l[ψ1]j

hλ,κi

j=min(l,i)
κ
W

j=min(l,i)
V
κ

j=i
W

8. l[ψ1U ψ2]i

hλ,κi ≡

(l[ψ2]j

hλ,κi ∧

j−1

n=l
V

hλ,κi)

l[ψ1]n
9. l[(#x > c)p(x)]i
10. l[(#x ≤ c)p(x)]i
11. l[(#x)p(x) > q(x)]i
12. l[(#x)p(x) ≤ q(x)]i
13. l[α1 ∨ α2]i

hλ,κi ≡ ci
hλ,κi ≡ ci

p > c
p ≤ c
hλ,κi ≡ ci
hλ,κi ≡ ci

p > ci
q
p ≤ ci
q
hλ,κi ∨ l[α2]i

hλ,κi ≡ l[α1]i

hλ,κi

l[ψ1]n

hλ,κi) ∨

j−1

n=i
V

(l[ψ2]j

hλ,κi ∧

i−1

j=l
W

l[ψ1]n

hλ,κi ∧

κ

n=i
V

8

R. Phawade et al.

14. l[α1 ∧ α2]i

hλ,κi ≡ l[α1]i

hλ,κi ∧ l[α2]i

hλ,κi

We deﬁne [ψ]i

hλ,κi inductively as follows:

hλ,κi ≡ ¬qi

hλ,κi ≡ qi

1. [q]i
2. [¬q]i
3. [ψ1 ∨ ψ2]i
4. [ψ1 ∧ ψ2]i

5. [Xψ1]i

hλ,κi ≡

6. [F ψ1]i

hλ,κi ≡

7. [Gψ1]i

hλ,κi ≡

hλ,κi ≡ [ψ1]i
hλ,κi ≡ [ψ1]i
[ψ1]i+1
hλ,κi
[ψ1]l
κ

hλ,κi ∨ [ψ2]i
hλ,κi ∧ [ψ2]i
if i < κ
if i = κ

hλ,κi

(

hλ,κi

hλ,κi

l[ψ1]j

hλ,κi

[ψ1]j

hλ,κi

j=min(l,i)
κ
W

j=min(l,i)
V
κ

j−1

n=i
V

([ψ2]j

8. [ψ1U ψ2]i

hλ,κi ≡
9. [(#x > c)p(x)]i
10. [(#x ≤ c)p(x)]i
11. [(#x)p(x) > q(x)]i
12. [(#x)p(x) ≤ q(x)]i
13. [α1 ∨ α2]i
14. [α1 ∧ α2]i

hλ,κi ≡ [α1]i
hλ,κi ≡ [α1]i

j=i
hλ,κi ≡ ci
W
hλ,κi ≡ ci

hλ,κi ∧
p > c
p ≤ c
hλ,κi ≡ ci
hλ,κi ≡ ci

p > ci
q
p ≤ ci
q
hλ,κi ∨ [α2]i
hλ,κi ∧ [α2]i

hλ,κi

hλ,κi

[ψ1]n

hλ,κi)

To determine the encoding of [M]h0,κi, we need to perform and operation
on the initial state and the place constraints. The place constraints are due to
the κ variable, for each of the places.

[M]h0,κi = I(s0) ∧ (

pj0 ≤ κ).

^0≤j≤np

Similarly, to determine [M]hλ,κi, we can make use of the previously encoded
[M]hλ−1,κi and unfold the transition relation by one length, and and it with the
place constraints to obtain the following relation:

[M]hλ,κi = [M]hλ−1,κi ∧ (T (sλ−1, sλ) ∧ (

pjλ ≤ κ)).

^0≤j≤np

The encoding of the ¬, ∧, ∨ operators are straightforward. We also deﬁne
the encoding using the temporal operators. Notice that [(#x > k)p(x)]i
hλ,κi is
encoded using the counter cp at the place p, and this is translated as cp > κ.
Similarly, we have [(#x > k)p(x)]i
hλ,κi ≡ cp > κ.

2D-BMC

9

·

·

·

(M, ψ)(2,0)

·

·

·

λ

(M, ψ)(1,0)

(M, ψ)(1,1)

· · ·

(M, ψ)(0,0)

(M, ψ)(0,1)

(M, ψ)(0,2)

· · ·

κ

Fig. 1. Unfolding of the formula (M, ψ)(λ,κ) with respect to λ (time instance), κ (num-
ber of clients)

Unfolding the encoded formula The unfolding of the formula (M, ψ)(λ,κ) for
each k, upto k = 2 is depicted pictorially in Fig. 1. Initially, when k = λ + κ = 0,
k = 0 (bound), λ = 0 (time instance), κ = 0 (number of clients), the formula
(M, ψ)(0,0) is evaluated. If this is found to be satisﬁable, then, a witness is
obtained, and we are done. If not, in the next macro-step of the unfolding, where
k = λ + κ = 1, there are possibly two micro-steps to be explored hλ, κi = h0, 1i
and hλ, κi = h1, 0i. Firstly, κ is incremented and the formula (M, ψ)(0,1) is
evaluated. If this found to be unsatisﬁable, λ is incremented and the formula
(M, ψ)(1,0) is evaluated. In each micro-step of the unfolding, either λ or κ are
incremented, and the resulting formula is veriﬁed. Details of the unfolding with
respect to the tool are in Section 5.2.

5 The 2D-BMC Model Checker Tool: DCModelChecker

DCModelchecker is an easy-to-use tool for performing two dimensional bounded
model checking of Petri Nets using the logic LC . We give the architecture and the
overview of the tool in Section 5.1. We describe the workﬂow in Section 5.2, and
in Section 6, we report the experiments. The experiments are easily reproducible
by directly executing the scripts in our artifact. It is a self-contained virtual
machine image —additional installations or tools are unnecessary for replicating
our results.

10

R. Phawade et al.

5.1 Architecture

We introduce a tool to perform two dimensional bounded model checking, DC-
ModelChecker. While several tools perform bounded model checking, ours is
unique in the model checking strategy as well as displaying the counterexample.
We describe the details of related work in the Section 7.

Property Formula

System Description

Pre-Processing
Module

2D- BMC
Module

r
e
v
l
o
S

3
Z

sat + trace

unsat

Fig. 2. DCModelChecker architecture

The general architecture of the tool is shown in Fig. 2. Our tool has two
primary inputs- system description in standard PNML format and the property
to be tested expressed in counting logic LC . The system description using Petri
Nets in PNML format can be obtained from the vast collection of industrial and
academic benchmarks available at MCC [17] or created using a Petri Net Edi-
tor [30]. We make use of MCC benchmarks, for comparative testing. Currently,
we have translated a subset of the MCC properties into LC .

Firstly, the two inputs are fed to the pre-processing module and consequently
to the DCModelChecker tool. The objective of the pre-processing Module is to
read and validate the two inputs. We make use of ANTLR [20] to achieve this. We
give the grammar of the nets and properties to the tool so that it can recognize
it against its respective grammar as shown in Fig. 3. ANTLR generates a parser
for that language that can automatically build parse trees representing how a
grammar matches the input. The parse trees can be walked to construct the data
structures that our tool requires. We have manually written the grammars for
the PNML format of both types and the grammar of LC , to be used by ANTLR.
Our tool reads the output of the pre-processing module and checks if the
model satisﬁes the property or not. We make use of the Z3 SAT/SMT Solver [19],
to solve the encoded formula and give us unsat, or sat with a counterexample
trace. If unsat, the tool can increment the bound and look further, until the
external termination bound is hit. We picked Z3, for its wide industrial applica-
tions, developer community support, and ease of use. The detailed workﬂow is
discussed in the subsequent section.

5.2 Workﬂow

The system description M , the property formula φ, and external termination
bound k are given to us. First, we negate the property, ψ = ¬φ. Note that the
negation normal form of ψ is always used in the BMC process. For the bound

2D-BMC

11

Input

Grammar

Input
expression

Language Recognizer

ANTLR
tool

Lexer +
Parser

Pre-Processing Module

Output

parse tree

Listener
Walker

output
tree

y
r
a
r
b
i
L

e
m

i
t
n
u
R
R
L
T
N
A

Fig. 3. Pre-Processing the model and formula using ANTLR

k = 0 and the corresponding micro-step hλ, κi = h0, 0i, we construct the formula
[M, ψ]h0,0i and feed it to the solver.

If the above formula is satisﬁable, the property φ is violated in the initial
state and we have a witness at k = 0 and we can stop our search. If the base
case is unsatisﬁable, we consider the next micro-step hλ, κi – with the bound
k = λ + κ = 1 – and construct the formula [M, ψ]hλ,κi and feed it to the solver.
If this formula is satisﬁable, the property φ is violated for k = λ + κ and we have
a witness for this k and we can stop our search. Otherwise, we may continue
with the next micro-step hλ′, κ′i and so on. The order in which the micro-steps
are considered is illustrated in Fig. 1. We shall continue until we have considered
all micro-steps for the termination bound k.

6 Experiments

To illustrate the expressibility of LC and the applicability of 2D-BMC, we per-
formed two phases of experiments, their results are described in this section.
Firstly, we considered benchmarks models from the Model Checking Contest [17]
and expressed the properties in LC . We considered the following property cat-
egories and translated them to LC —LTLFireability, LTLCardinality, Reacha-
bilityFireability, ReachabilityCardinality. In particular, the results of verifying a
subset of properties are consolidated in Table 1. The table shows the number of
sat and unsat properties in each property category (consisting of 16 properties
each per category), and the time taken to execute (in ms) for DCModelChecker

12

R. Phawade et al.

as well as the state-of-the-art model checking tool, ITS-Tools [26]. Our tool DC-
ModelChecker was executed with the bound 1. ITS-Tools was executed with
a timeout of 600 seconds. It can be observed that the DCModelChecker per-
forms well in some property categories. While some properties were unsat for
the above bound and timeout period constraints, they may have become sat, on
incrementing the bound. Hence there is a diﬀerence in the number of sat and
unsat properties found by DCModelChecker versus ITS-Tools. For LTL Fireabil-
ity and LTL Cardinality properties, DCModelChecker takes comparatively less
execution time than ITS-Tools. However, the number of sat and unsat proper-
ties diﬀer slightly. As part of future work, we would like to identify the property
types where DCModelChecker has an advantage. Our tool DCModelChecker is
available online [21] and the results in this section can be easily reproduced.

Model Name

Dekker-PT-010

ITS-Tools

Property Category

LTL Cardinality
LTL Fireability

DCModelChecker
sat unsat time(s) sat unsat time(s)
3
2
Reachability Cardinality 0
Reachability Fireability 0

11.219
10.353
10.497
11.628
Table 1. Results of comparative testing

15.7
18.372
3.45
6.061

13
14
16
16

12
14
11
12

4
2
5
4

Secondly, we considered two inﬁnite-state systems —ﬁrstly, the Autonomous
Parking System (APS) and secondly, the Unbounded Process Scheduler (UPS),
modeled as a net, primarily to take a closer look at how exactly the 2D-BMC
strategy works, given that UPS is an extensively researched system [18] and
has a much smaller net representation. The APS and UPS case studies are
discussed in Appendix A and Appendix B respectively. Some of the properties
of the Autonomous Parking System veriﬁed using DCModelChecker are given in
Table 2. A sample of the properties that were written using the counting logic
LC for the UPS to demonstrate its expressibility are in Table 3. It is natural to
see that we can expand this to more complex properties.

With respect to the UPS, consider the property F (#x)p1(x) > p0(x), written
in LC . It is a counting property with a ﬁnally operator at the root. Hence, this
property gets violated when there is an instance where the number of processes
at place p1 is less than the number of processes/tokens at place p0. In the model,
this happens at time instant λ = 3, when the number of processes κ = 1, and a
counterexample trace is obtained as well.

To the best of our knowledge, ours is the only tool that uses 2D-BMC in the
Petri Net setting, for an extension of linear temporal logic while making use of
an SMT solver and gives a counterexample trace. In Section 7 we discuss the
contributions of other tools that verify the properties of Petri Nets.

2D-BMC

13

S.No APS Property
1
2
3
4
5

G((#x)p2(x) > p3(x)|(#x)p3(x) > p2(x))
F ((#x)p2(x) <= p3(x)&(#x)p3(x) <= p2(x)) External Termination Bound reached. UNSAT.
G((#x > 0)p1(x)|(#x > 0)p7(x)|(#x > 0)p8(x)) External Termination Bound reached. UNSAT.
F ((#x)p6(x) > p2(x))
((#x > 0)p1(x)|(#x > 0)p7(x)|(#x > 0)p8(x))U
((#x)p2(x) <= p3(x)&(#x)p3(x) <= p2(x))

External Termination Bound reached. UNSAT.

k = 4, κ = 1, λ = 3 .SAT.

Result
k = 1, κ = 1, λ = 0. SAT.

Table 2. Results of testing APS using DCModelChecker

S.No UPS Property
1
2
3
4
5

Result
k = 4, κ = 1, λ = 3, SAT.
F (#x)p1(x) > p0(x)
k = 3, κ = 1, λ = 2, SAT.
G(#x)p2(x) <= p1(x) <= p0(x)
k = 0, κ = 0, λ = 0, SAT
G(t0&t1&t7)
F (t0&t1&t7)
External Termination Bound reached. UNSAT.
F (#x <= 1)p2(x)&(#x <= 3)p1(x) External Termination Bound reached. UNSAT.
&(#x <= 2)p0(x)

Table 3. Results of testing UPS using DCModelChecker

7 Related Work

Recently, there have been several practical implementations of tools verifying
speciﬁc properties of Petri Nets. KREACH [12] is a recent implementation of
Kosaraju’s algorithm for deciding reachability in Petri Nets (and equivalently
Vector Addition Systems with States). QCOVER [7] decides the coverability of
Petri Nets leveraging the SMT solver. ICOVER [14] decides coverability using
inductive invariants. In [23] SMT-based reachability of timed Petri Nets and
in [8] CTL∗ model checking for time Petri Nets are explored. Petrinizer [13]
implements an SMT-based approach for coverability.

BMC using SMT Solvers has been an active area of research [24]. In par-
ticular, while applying BMC in the Petri Net setting, techniques such as net
reductions, and structural reductions [27] are applied. Recently, in [1,2] the gen-
eralized reachability of Petri Net is encoded into a BMC problem and solved
using SMT solvers.

However, BMC for Petri Nets while expressing properties using LTL and its
extensions while leveraging the power of SMT Solvers remains unexplored. DC-
ModelChecker attempts to bridge this gap while preserving the original Petri Net
structure. In Section 4.1 we provide the propositional encoding of the counting
logic LC which distinguishes our work. In [25] a similar counting linear tem-
poral logic for specifying properties of multi-robot applications is proposed. In
contrast, LC uniquely supports specifying properties of client-server systems.

The Model Checking Contest (MCC) [17] has attracted many tools for for-
mal veriﬁcation of concurrent systems, and also industrial and academic bench-
marks. Tools participating in MCC, use portfolio approach and give answers
in binary, based on the requirement of the contest. In particular, we looked at

14

R. Phawade et al.

ITS-Tools [26] which has 99.99% tool conﬁdence across categories in the contest
and makes use of structural reduction techniques [27] to arrive at the solution
quickly. ITS-Tools uses a layer of SMT when solving LTL, however, it does not
perform BMC.

While ITS-Tools is much faster than our tool, it gives only binary answers
(sat or unsat), as this conforms with the expectations of the MCC unlike our
tool which gives a counterexample trace, if the property is not satisﬁed. The
counterexample trace is quite useful for property veriﬁcation. To the best of
our knowledge, DCModelChecker is the only tool that performs bounded model
checking for Petri Nets using an extension of linear temporal logic using SMT
solvers and provides a counterexample trace, that can be easily interpreted.
Currently, the goal of this tool is to demonstrate the usefulness of the 2D- BMC
strategy and the logic LC . To ensure the correctness of the results, we executed
the same benchmarks on ITS-Tools as well. The results of comparative testing
are in Section 6. These experiments can be replicated using the scripts available
in our artifact [21].

8 Conclusion and Future Work

We have successfully explored the reachability, ﬁreability, and cardinality prop-
erties of the unbounded client-server systems using the proposed counting logic
LC . We have also proposed a novel bounded model checking strategy 2D-BMC
applicable for Petri Nets. We have implemented a tool DCModelChecker that
uses the proposed counting logic and the 2D-BMC strategy and demonstrated
its usefulness concerning benchmarks from MCC. To the best of our knowledge,
DCModelChecker is the only tool that uses 2D-BMC for Petri Nets, specifying
properties in an extension of linear temporal logic while utilizing an SMT solver
and additionally providing a counterexample trace. Future research directions
include optimizing our tool by implementing an eﬃcient linear size encoding in
the bound k for the logic [6]. The BMC technique only provides the counterexam-
ples when the property is unsatisﬁable. It would be worth the eﬀort to leverage
inductive reasoning to have a full decision procedure, for when the property is
satisﬁable. QCOVER [7] and ICOVER [14] already have implemented such a
procedure for a speciﬁc set of properties of Petri Nets. As part of future work,
we would like to establish the completeness thresholds of BMC [11]. Another
work in progress is an extension of LC to account for identiﬁable clients, which
will enable us to verify richer inﬁnite-state systems.

Acknowledgement

We thank R. Ramanujam for insights on the logic and numerous fruitful discus-
sions at various phases of this work.

2D-BMC

15

References

1. Amat, N., Berthomieu, B., Dal-Zilio, S.: On the combination of polyhedral abstrac-
tion and smt-based model checking for petri nets. In: PETRI NETS. pp. 164–185.
LNCS, Springer (2021). https://doi.org/10.1007/978-3-030-76983-3 9

2. Amat, N., Dal-Zilio, S., Hujsa, T.: Property directed reachability for gen-
(2022).

In: TACAS. pp. 505–523. LNCS, Springer

eralized petri nets.
https://doi.org/10.1007/978-3-030-99524-9 28

3. Baier, C., Katoen, J.: Principles of model checking. MIT Press (2008)
4. Biere, A., Cimatti, A., Clarke, E.M.,

Strichman, O.,

Bounded model
https://doi.org/10.1016/S0065-2458(03)58003-2

checking.

Adv.

Comput.

pp.

117–148

Zhu, Y.:
(2003).

5. Biere, A., Cimatti, A., Clarke, E.M., Zhu, Y.: Symbolic model check-
(1999).

In: TACAS. pp. 193–207. LNCS, Springer

ing without bdds.
https://doi.org/10.1007/3-540-49059-0 14

6. Biere, A., Heljanko, K., Junttila, T.A., Latvala, T., Schuppan, V.: Linear en-
codings of bounded LTL model checking. Log. Methods Comput. Sci. (2006).
https://doi.org/10.2168/LMCS-2(5:5)2006

7. Blondin, M., Finkel, A., Haase, C., Haddad, S.: Approaching the coverabil-
ity problem continuously. In: TACAS. pp. 480–496. LNCS, Springer (2016).
https://doi.org/10.1007/978-3-662-49674-9 28

8. Boucheneb, H., Hadjidj, R.: CTL* model checking for time petri nets. Theor.

Comput. Sci. pp. 208–227 (2006). https://doi.org/10.1016/j.tcs.2005.11.002

9. Cai, Z., Zhou, Y., Qi, Y., Zhuang, W., Deng, L.: A millimeter wave dual-lens
antenna for iot-based smart parking radar system. IEEE Internet Things J. pp.
418–427 (2021). https://doi.org/10.1109/JIOT.2020.3004403

10. Clarke, E.M., Biere, A., Raimi, R., Zhu, Y.: Bounded model checking
using satisﬁability solving. Formal Methods Syst. Des. pp. 7–34 (2001).
https://doi.org/10.1023/A:1011276507260

11. Clarke, E.M., Kroening, D., Ouaknine, J., Strichman, O.: Computational chal-
lenges in bounded model checking. Int. J. Softw. Tools Technol. Transf. pp. 174–183
(2005). https://doi.org/10.1007/s10009-004-0182-5

12. Dixon, A., Lazic, R.: Kreach: A tool for reachability in petri nets. In: TACAS. pp.
405–412. LNCS, Springer (2020). https://doi.org/10.1007/978-3-030-45190-5 22
13. Esparza, J., Ledesma-Garza, R., Majumdar, R., Meyer, P.J., Niksic, F.: An smt-
based approach to coverability analysis. In: CAV. pp. 603–619. LNCS, Springer
(2014). https://doi.org/10.1007/978-3-319-08867-9 40

14. Geﬀroy, T., Leroux, J., Sutre, G.: Occam’s razor applied to the petri net coverabil-
ity problem. Theor. Comput. Sci. (2018). https://doi.org/10.1016/j.tcs.2018.04.014
15. Hillah, L., Kordon, F., Petrucci, L., Tr`eves, N.: PNML framework: An extendable
reference implementation of the petri net markup language. In: PETRI NETS. pp.
318–327. LNCS, Springer (2010). https://doi.org/10.1007/978-3-642-13675-7 20
16. Hsu, C., Shih, M.H., Huang, H.Y., Shiue, Y.C., Huang, S.: Veriﬁcation of smart
guiding system to search for parking space via DSRC communication. In: ITST.
pp. 77–81. IEEE (2012). https://doi.org/10.1109/ITST.2012.6425287

17. Kordon, F., Bouvier, P., Garavel, H., Hillah, L.M., Hulin-Hubard, F., Amat., N.,
Amparore, E., Berthomieu, B., Biswal, S., Donatelli, D., Galla, F., , Dal Zilio, S.,
Jensen, P., He, C., Le Botlan, D., Li, S., , Srba, J., Thierry-Mieg, ., Walner, A.,
Wolf, K.: Complete Results for the 2020 Edition of the Model Checking Contest.
http://mcc.lip6.fr/2021/results.php (June 2021)

16

R. Phawade et al.

18. Mazur, T., Lowe, G.: Counter abstraction in the CSP/FDR setting. Electron. Notes

Theor. Comput. Sci. (2009). https://doi.org/10.1016/j.entcs.2009.08.012

19. de Moura, L.M., Bjørner, N.S.: Z3: an eﬃcient SMT solver. In: TACAS. pp. 337–

340. LNCS, Springer (2008). https://doi.org/10.1007/978-3-540-78800-3 24

20. Parr, T., Fisher, K.: Ll(*): the foundation of the ANTLR parser generator. In:

PLDI. pp. 425–436 (2011). https://doi.org/10.1145/1993498.1993548

21. Phawade, R., Prince, T., Sheerazuddin, S.: Artifact and instructions to generate
experimental results for two dimensional bounded model checking of unbounded
client-server systems (2022). https://doi.org/10.6084/m9.ﬁgshare.19611477.v3

22. Pnueli, A.: The temporal

logic of programs. In: FOCS. pp. 46–57 (1977).

https://doi.org/10.1109/SFCS.1977.32

23. P´olrola, A., Cybula, P., Meski, A.:
nets.

ing
https://doi.org/10.3233/FI-2014-1135

bounded

petri

time

for

Smt-based
Fundam.

reachability
Informaticae

check-
(2014).

24. Prasad, M.R., Biere, A., Gupta, A.: A survey of recent advances in sat-based
formal veriﬁcation. Int. J. Softw. Tools Technol. Transf. pp. 156–173 (2005).
https://doi.org/10.1007/s10009-004-0183-4

25. Sahin, Y.E., Nilsson, P., Ozay, N.: Multirobot coordination with count-
(2020).

IEEE Trans. Robotics 36(4),

1189–1206

temporal

logics.

ing
https://doi.org/10.1109/TRO.2019.2957669

26. Thierry-Mieg, Y.: Symbolic model-checking using its-tools. In: TACAS. pp. 231–

237. LNCS, Springer (2015). https://doi.org/10.1007/978-3-662-46681-0 20

27. Thierry-Mieg, Y.: Structural reductions revisited. In: PETRI NETS. pp. 303–323.

LNCS, Springer (2020). https://doi.org/10.1007/978-3-030-51831-8 15

28. Vardi, M.Y., Wolper, P.: An automata-theoretic approach to automatic program

veriﬁcation. In: LICS. pp. 322–331 (1986)

29. Yan, G., Yang, W., Rawat, D.B., Olariu, S.: Smartparking: A secure and in-
telligent parking system. IEEE Intell. Transp. Syst. Mag. pp. 18–30 (2011).
https://doi.org/10.1109/MITS.2011.940473

30. Zahoransky, R.M., Holderer, J., Lange, A., Brenig, C.: Process analysis as ﬁrst
step towards automated business security. In: ECIS. p. Research Paper 46 (2016),
http://aisel.aisnet.org/ecis2016_rp/46

2D-BMC

17

A Case Study : Autonomous Parking System

In crowded urban spaces, parking one’s vehicle can be a hassle, given that there
is no guarantee of ﬁnding an available parking lot in a reasonable amount of time.
There have been various approaches to resolve this, from the industry as well
as academia [29,9]. The automobile industry has implemented quite successfully,
the autonomous parking system, wherein the idea is that the vehicle can be
guided into a parking lot, without the need for a valet through communication
between the vehicle and the parking space environment. This is especially useful
in smart city projects, and futuristically, the driverless vehicle eco system [16].
In this section, we explore how to verify an Autonomous Parking System
(AP S) where the number of parking requests is unbounded. This is an example
from client-server paradigm, more speciﬁcally, a single server multiple client sys-
tem —the parking system is a server whereas the vehicles (say, cars) requesting
parking lots are clients. This can be represented by a state-transition system as
given Fig. 4 and Fig. 5, and consequently, as a Petri Net as in Fig. 6.

In any conﬁguration (marking) of the Petri Net execution, the number of
tokens in any place corresponds to those many clients (cars) in that state. We
will now look at the formal description of the AP S as a net and express its
properties using LC .

A.1 Introduction to Autonomous Parking System

Typically, any parking space in a busy area, such as the city square, or the
airport, services hundreds of vehicles. It may employ valets to assist the drivers.
It is often the case, that the parking space may not be available, and navigating
to a parking lot can be cumbersome. Finding a parking lot and arriving at it, is
a process that can be autonomous. The system itself can be made autonomous,
by using technology to track the vehicles and respond to requests for parking. In
this case study, the autonomous parking system is the server, and the vehicles
making requests for parking are the clients. Theoretically, there could be an
unbounded number of clients. We assume that there is enough parking space
available, to demonstrate this unbounded client-server system.

Modeling of Autonomous Parking System using Petri Nets. We will now
model the interactions between the parking system and the vehicle requesting
parking space as in Fig. 4 and Fig. 5. Initially, the system is ready to service the
requests, which is the server ready state. We assume a steady inﬂow of requests
for parking, to keep the system suﬃciently occupied. When a vehicle inquires for
parking space, the vehicle is in the parking requested state. Now, the system may
non-deterministically choose to either grant or reject the parking request based
on local information such as space availability, the priority of incoming requests,
and the like. We assume two disjoint workﬂows for each scenario. Firstly, if the
system accepts the request, the system is in request granted state and simulta-
neously, the vehicle goes to occupy parking lot state. At some point, the vehicle

18

R. Phawade et al.

gives up its allocated parking space, is in exit parking lot successfully and simul-
taneously the system is in deallocate parking lot state. This marks the successful
exit of the vehicle from the system. Secondly, if the system rejects the request,
the vehicle is in parking unavailable state and the system is in request rejected
state. The only option is for the vehicle to exit. At any point, the system can
either accept or reject the request, after granting the request, the server can
go to server busy state. Theoretically, this description allows for an unbounded
number of vehicle requests to be processed by the system, albeit there may be
limitations on the availability of the parking space. We assume that the au-
tonomous parking system can reasonably guide the vehicle manoeuvres within
the parking lot. It is not diﬃcult to observe that the combined interactions be-
tween the system and vehicles described above can be interleaved and modeled
as a single Petri Net as in Fig. 6. In this Petri Net, the successful scenario
is marked with a green rectangle, and the places p0, p2 and p4 correspond to
the vehicle states parking requested, occupy parking lot and exit parking lot, the
places p1, p7, p3 and p5 correspond to the server states server ready, server busy,
request granted and deallocate parking lot, transitions t1, t2, t3 represent the re-
quest, entry and exit of the vehicle respectively. The ﬁring of transition t0 acts
as the source, where an unbounded number of vehicle requests can be spawned.
The ﬁring of transition t6 represents the server completing the processing of a
request and returning to its ready state. In the unsuccessful scenario, marked
with a red rectangle, the transition t4 is ﬁred when the server rejects the request,
which brings the vehicle to parking unavailable represented by place p6, and the
server goes to request rejected represented by place p8. The ﬁring of transition
t7 ensures that the rejected request is processed by the server, and it is ready to
take on more vehicle requests. Notice that the initial marking of the system is
given as follows, assuming an ordering on the places M0 = (0, 1, 0, 0, 0, 0, 0, 0, 0),
where there is exactly one token in place p1 indicating the availability of the
server. In any marking of the net, there is exactly one token in either of the
server places p1, p7, or p8 due to the structure of the net.

completed processing

server busy

server ready

processing

vehicle exits

accept

reject

request granted

request rejected

vehicle exits successfully

deallocate parking lot

Fig. 4. State diagram of autonomous parking system (server)

2D-BMC

19

parking requested

APS accepts

APS rejects

occupy parking lot

parking unavailable

successful exit

exit parking lot

exit parking

unsuccessful exit

Fig. 5. State diagram of vehicle in APS (client)

t6

p7

t0

p0

p1

p3

p5

t1

t2

t3

p2

p4

t7

p8

t4

p6

t5

Fig. 6. Petri Net depicting client-server interactions in APS

The standard representation of the Petri Net is the PNML format [15]. We
made use of Wolfgang Tool [30], a Petri Net editor to draw and visualize the
conﬁgurations of the net. The PNML ﬁle for APS and the executable (jar ﬁle)
for the tool are available in the artifact.

A.2 Expressing properties in LC and the results of 2D-BMC

1. Consider the property of the AP S where there are equal number of accept
responses by the server to the number of accepted parking requests by the
clients. This can be paraphrased as always the number of tokens in place p2

20

R. Phawade et al.

equals the number of tokens in p3. Consider the following property written
in LC :
G((#x)p2(x) > p3(x)|(#x)p3(x) > p2(x))
Our algorithm looks for a counterexample trace. This is satisﬁable initially,
at k = 0 where κ = 1 (number of tokens) and λ = 0 (time instance).

2. F ((#x)p2(x) <= p3(x)&(#x)p3(x) <= p2(x))

We expect that this formula will be true for all bounds. Hence while having
bound k = 5 or k = 100, we get the same output on reaching the bound,
without any counterexample.

3. Consider the property, where there is atleast one token in either place p1
or p7 or p8. From the net, p1 + p7 + p8 = 1 is an invariant. These places
represent the server being available, busy and server rejecting the request.
G((#x > 0)p1(x)|(#x > 0)p7(x)|(#x > 0)p8(x)).
On verifying with our tool, we do not ﬁnd any counterexample for this prop-
erty for bound k = 5.

4. Comparison between the number of rejected requests and accepted requests.

F ((#x)p6(x) > p2(x)).
At k = 4, κ = 1, λ = 3 we encounter a loop, and the property is unsatisﬁable
for all paths of length k = 4.

5. Consider this property using the Until operator, essentially this is true U p2 =

p3.
((#x > 0)p1(x)|(#x > 0)p7(x)|(#x > 0)p8(x))U ((#x)p2(x) <= p3(x)&(#x)p3(x) <=
p2(x)). As expected, this property holds true for bound k = 5, and no coun-
terexample is found.

2D-BMC

21

B A Case Study : Unbounded Process Scheduler

In this section, we explore how to verify a process scheduler with unbounded
processes in an operating system. This is an example from the client-server
paradigm: the scheduler is a server whereas the processes requesting CPU time
are clients. Each process has a behaviour that can be represented by a state-
transition system [18] as given in the Fig. 7.

Unbounded Process Scheduler (UPS), that we have considered in our paper, is
a kind of single server multiple client system, where one server and an unbounded
number of clients collaborate. In the process model we map each state from
{new, runnable, running, blocked, terminated} to a place in the Petri Net. In
any conﬁguration (marking) of the Petri Net execution, the number of tokens in
any place corresponds to as many UPS clients in that state. We will now look at
the formal description of the UPS as a net and express its properties using LC .

new

load

runnable

deschedule

interrupt

running

run

block

terminate

terminated

blocked

Fig. 7. State diagram of the basic model for processes within an operating system

B.1 Introduction to Unbounded Process Scheduler

Processes are programs in execution. Typically, a
process changes its state dynamically based on in-
ternal and external inputs. When a process is cre-
ated, it is in the new state. When it is waiting to
be assigned a processor, it is in ready state, alterna-
tively called as runnable state. When instructions
are being executed in the process, it is running.
The running process may be interrupted by exter-
nal events such as waiting for keyboard input when

t1

p1

t2

p2

t6

p0

t3

p4

p3

t0

t5

t4

t7

Fig. 8. Petri net for UPS

22

R. Phawade et al.

it gets blocked. On event completion, blocked pro-
cess goes to runnable, and waits for its turn to run.
A running process may complete its execution and
terminate. This is usually known as the lifecycle of
a process in a process scheduler given in Fig. 7.

Modeling of Unbounded Process Scheduler using Petri Nets. It is not
diﬃcult to observe that the unbounded process scheduler described above can
be modeled as a Petri Net as in Fig. 8. The initial marking here is given as
follows, assuming an ordering on the places M0 = (0, 0, 0, 0, 0). Here each token
corresponds to a process. Transition t0 is used to spawn new processes, while
transition t7 is used to take out the processes, terminated by transition t6. Tran-
sition t1 is used to load the new processes, transition t2 is to used to run, while
t3 is used to deschedule it. Transition t4 corresponds to blocking a process, while
t5 corresponds to interrupt. The standard representation of the Petri Net is the
PNML format [15]. A Petri Net Editor such as Wolfgang Tool [30] can be used
to view existing PNML ﬁles as a graphical representation as well as execute the
enabled transitions and view the run of the Petri Net. Additionally, Wolfgang
allows us to draw a Petri Net of our own. We drew our own Petri Net, using
Wolfgang [30] for the UPS case study.

B.2 Expressing properties in LC and the results of 2D-BMC

The following are the descriptions of the properties of the UPS described above,
along with the results from Table. 3.

1. Consider the property of the UPS, F (#x)p1(x) > p0(x) which expresses
that at some time, the number of runnable processes at place p1 is greater
than the number of newly created processes at place p0. This is satisﬁable
at time instance λ = 3, when there is exactly one runnable process in place
p1 leading to κ = 1 and place p0 does not contain any processes.

2. Consider the property G(#x)p2(x) <= p1(x) <= p0(x) which states that it
is always the case that the number of running processes is less than or equal
to the number of runnable processes and the number of runnable processes
is less than or equal to created processes. This is satisﬁable at time instance
λ = 2 and κ = 1.

3. Consider the property G(t0&t1&t7) which states that it is always the case
that process creation, process loading into memory, and process scheduled
to run occur simultaneously. This is satisﬁable at κ = 0, λ = 0.

4. Consider the property F (t0&t1&t7) which states that at some time process
creation, process loading into memory, and process scheduled to run occur
simultaneously. This is unsatisﬁable up to bound k = 5 and the external
termination bound is reached. This indicates that such a scenario is not
possible up to the given bound.

2D-BMC

23

5. Consider the property F (#x <= 1)p2(x)&(#x <= 3)p1(x)&(#x <= 2)p0(x)
which states that at some time there is at most 1 running process and there
are at most 3 runnable processes and there are at most 2 newly created pro-
cesses in the scheduler. This is not satisﬁable up to the bound k = 5, hence
the program exits, saying that the external termination bound is reached.

