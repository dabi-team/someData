Identifying and Characterizing Silently-Evolved
Methods in the Android API

Pei Liu∗, Li Li∗α, Yichun Yan†, Mattia Fazzini†, John Grundy∗
∗Monash University, Melbourne, Australia
{pei.liu,li.li,john.grundy}@monash.edu
†University of Minnesota, Minneapolis, USA
{yan00104,mfazzini}@umn.edu

2
2
0
2

y
a
M
1
3

]
E
S
.
s
c
[

1
v
6
4
5
5
1
.
5
0
2
2
:
v
i
X
r
a

Abstract—With over 500,000 commits and more than 700
contributors, the Android platform is undoubtedly one of the
largest industrial-scale software projects. This project provides
the Android API, and developers heavily rely on this API to
develop their Android apps. Unfortunately, because the Android
platform and its API evolve at an extremely rapid pace, app
developers need to continually monitor API changes to avoid
compatibility issues in their apps (i.e., issues that prevent apps
from working as expected when running on newer versions of
the API). Despite a large number of studies on compatibility
issues in the Android API, the research community has not yet
investigated issues related to silently-evolved methods (SEMs).
These methods are functions whose behavior might have changed
but the corresponding documentation did not change accordingly.
Because app developers rely on the provided documentation to
evolve their apps, changes to methods that are not suitably
documented may lead to unexpected failures in the apps using
these methods.

To shed light on this type of issue, we conducted a large-
scale empirical study in which we identiﬁed and characterized
SEMs across ten versions of the Android API. In the study,
we identiﬁed SEMs, characterized the nature of the changes,
and analyzed the impact of SEMs on a set of 1,000 real-world
Android apps. Our experimental results show that SEMs do exist
in the Android API, and that 957 of the apps we considered
use at least one SEM. Based on these results, we argue that
the Android platform developers should take actions to avoid
introducing SEMs, especially those involving semantic changes.
This situation highlights the need for automated techniques and
tools to help Android practitioners in this task.

I. INTRODUCTION

Mobile applications (or simply apps) are becoming increas-
ingly prevalent in our lives. For instance, in 2017, US-based
users spent an average of two hours and 25 minutes per day
using mobile apps. This time accounts for more than 80% of
the total time spent by the users on their mobile devices [1].
Android apps, which run on the Android operating system
(OS), are the most widely used type of mobile apps and
account for over 70% of the mobile OS market share [2].
Android apps are not only extremely popular, but their number
is also growing at a staggering speed, with about 35,000 new
apps released on Google Play every month [3].

One common trait of Android apps is that they rely heavily
on the underlying Android OS, as the OS offers access to
a large number of popular and essential app services. Apps

αCorresponding author

can access these services using the application programming
interface (API) of the OS. On average, 25% of all methods and
ﬁeld references in the apps are uses of the Android API [4].
This characteristic facilitates app development [5], but it also
creates a tight coupling between the apps and the version of
the API used by the apps.

Unfortunately,

the Android OS and its API evolve
rapidly [4], [6]–[10], and when a new version of the API
is released, app developers need to carefully understand the
changes to the API so that they can suitably adapt their apps to
also run on the new version of the API. To help app developers
in this task, Android provides a curated documentation that app
developers can access using the platform website [11]. This
documentation is based on the comments associated with the
source code of the API, and the comments are created and
maintained by the API developers.

When API developers are working on a new version of the
API, they not only should create comments that describe newly
added API components but they should also update existing
comments to report changes in existing API components
(e.g., [12]). In the latter task, developers should document both
syntactic and behavioral changes introduced in the new version
of the API. Although it is important to document both types
of changes, it is imperative to document the second class of
changes as app developers would otherwise not easily know
how to update their apps, and users might experience ﬁeld
failures due to compatibility issues.

Although related work investigated a number of aspects
associated with the evolution of the Android API [4], [7], [13]–
[16], to the best of our knowledge, no work has systematically
analyzed whether there are issues in the documentation of
the behavioral changes in the platform API. Additionally, no
study identiﬁed the extent to which these issues might affect
Android apps. A study on these topics would provide insights
for building automated techniques that detect the issues and
highlight mitigation strategies against the issues.

To ﬁll this gap, we present an extensive empirical study that
identiﬁes and characterizes silently-evolved methods (SEMs) in
the Android API. A SEM is a method whose implementation
is different across two subsequent versions of the Android
API, while the method’s documentation (i.e., the method’s
comment) is not changed. In the study, we (i) identify SEMs
across different versions of the Android API, (ii) report the

 
 
 
 
 
 
characteristics of these methods, and (iii) analyze the impact
that SEMs might have on real-world apps. Speciﬁcally, we
analyzed method updates across ten API releases and manually
classiﬁed updates to methods whose documentation did not
change. In the study, we identiﬁed 4,769 SEMs, which include
2,271 publicly-accessible methods. After manually analyzing
a statistically signiﬁcant sample containing 562 SEMs, we
found that 363 of the methods include semantic changes.
Furthermore, we also analyzed the use of SEMs in a sample
of 1,000 real-world Android apps and observed that 957 of
these apps use at least one SEM. Interestingly, a number of
such usages have been manually mitigated by app developers
through API version checks1, indicating that SEMs could in-
deed introduce compatibility issues in Android apps. Overall,
we believe that our results highlight that Android developers
do not always thoroughly document semantic changes in the
platform API and that these changes can extensively affect
real-world Android apps.

In summary, the main contributions of this paper are:
• A characterization of SEMs across the ten most used
versions (at the time we started our study) of the Android
API. We analyzed method updates across ten versions
of the Android API and manually conﬁrmed that 363
methods out of a sample of 562 publicly-accessible
methods contain semantic changes. We also characterized
the nature of SEMs and found that developers might have
accidentally introduced the majority of them as most of
them are evolved only once.

• A study of how SEMs impact Android apps. We inves-
tigated whether and how Android apps use SEMs in a
sample of 1,000 real-world Android apps. We found that
SEMs are commonly used by Android apps, and such
usages could indeed lead to compatibility issues as app
developers have added checks to prevent the execution of
SEMs on certain versions of the Android API.

• A tool

to identify SEMs and the experimental data
containing the ﬁndings of our study. To identify and char-
acterize SEMs, we designed a technique and implemented
the approach in a prototype tool called ANDROSEA.
ANDROSEA identiﬁes methods across two versions of
the Android API that have same signature, same method
comment, but different method body. The tool and the
experimental data are publicly available at https://github.
com/MobileSE/AndroSea.

The remainder of this paper is organized as follows. Sec-
tion II deﬁnes relevant terminology. Section III presents our
study methodology. Section IV details the results of the study.
We discuss implications for researchers and practitioners in

1Version checks are recommended by Google to tackle API-induced com-
patibility issues. A typical check conforms to the following structure: if
SDK INT < n, call a method of the older API, otherwise, do something
else. SDK INT is the short version for android.os.Build.SDK INT and this
value, at runtime, provides the version of the API on which a certain app is
running. This check ensures that the method of the API, which may introduce
compatibility issues in the app when the app is running on newer versions of
the API, will only be invoked if the app is running on API versions that are
older than the one where the change was introduced.

Section V. Section VI outlines related work. Finally, Sec-
tion VII provides concluding remarks.

II. TERMINOLOGY AND MOTIVATION

This sections introduces the relevant terminology we will
use in the rest of this paper. Consider two API versions (or
1 , ..., m (cid:48)
levels): old API = [m1 , ..., mk ] and new API = [m (cid:48)
l ].
A method mi from the old API is a silently-evolved method
(SEM) if there is a method m(cid:48)
i in the new API that shares
the same signature and the same comment with mi, but has
a different method body with respect to mi. Among SEMs,
we deﬁne those methods that are publicly accessible (i.e.,
methods that are declared as public) as publicly-accessible
silently-evolved methods (PASEMs). In this paper, we focus
on both SEMs and PASEMs as both classes might affect the
execution of an android app.

Listing 1 provides an example of a PASEM, which shows
the evolution of the method getSqlStatementType between
API level 27 and 28. In the example, the two versions of the
method have the same signature (line 7) and the same method
comment (lines 1-6), but different method body, as Android
developers added new statements to the method in the API
level 28 (lines starting with +). In both API versions, the
method returns the type of the SQL statement provided as in-
put. However, from API level 28, part of the method behavior
is changed. In fact, instead of returning STATEMENT_ABORT
for any SQL rollback statement as deﬁned in API level 27, the
method returns a different value (i.e., STATEMENT_OTHER) if
the SQL statement aims at rollbacking to a savepoint [17].

1 /**
2 * Returns one of the following which represent the

type of the given SQL statement.

3 * ...
4 * @param sql the SQL statement whose type is

returned by this method

5 * @return one of the values listed above
6 */
7 public static int getSqlStatementType(String sql) {
8 String prefixSql = sql.substring(0,

3).toUpperCase(Locale.ROOT);

9 else if (prefixSql.equals("ROL")) {
10 + boolean isRollbackToSavepoint =

sql.toUpperCase(Locale.ROOT).contains(" TO ");

...
return STATEMENT_OTHER;

11 + if (isRollbackToSavepoint) {
12 +
13 +
14 + }
15
16 }
17 return STATEMENT_OTHER;
18 }}

return STATEMENT_ABORT;

Listing 1.
getSqlStatementType between Android API level 27 and 28.

Code snippet extracted by comparing the method

Unfortunately, due to this behavioral change, apps that use
the method could exhibit compatibility issues. Speciﬁcally, an
app that relies on the method’s behavior as implemented in
API level 27 might encounter a failure when running on newer
versions of the API. Because API developers did not suitably
document the change, app developers might not be aware of
the change and hence have a low chance of avoiding such
compatibility issue. In the rest of this paper, we present a

TABLE I
ANDROID FRAMEWORK REVISIONS USED IN THE STUDY. WE DID NOT
CONSIDER API LEVEL 20 AS THIS VERSION WAS FOCUSING ON CHANGES
FOR SUPPORTING ANDROID WEAR.

API Level
29
28
27
26
25
24
23
22
21
19

Code Name
Android10
Pie
Oreo
Oreo
Nougat
Nougat
Marshmallow
Lollipop
Lollipop
KitKat

Release Tag
android-10.0.0 r1
android-9.0.0 r1
android-8.1.0 r1
android-8.0.0 r1
android-7.1.0 r1
android-7.0.0 r1
android-6.0.0 r1
android-5.1.0 r1
android-5.0.0 r1
android-4.4 r1

Distribution
8.2%
10.4%
15.4%
12.9%
7.8%
11.4%
16.9%
11.5%
3.0%
6.9%

implementation of the Android API, the source code of various
command-line tools (such as the Android Asset Packaging
Tool), the source code of unit tests, and other types of ﬁles.
Because not all of these ﬁles are part of the Android API,
the repository prepocessing module analyzes the codebase to
identify and select the ﬁles that relate to the Android API. The
repository preprocessing module performs this task by using a
whitelist that we manually constructed, and performs this step
for each framework version provided as input to ANDROSEA.
By performing this operation, ANDROSEA reports only the
SEMs that are related to the Android API. ANDROSEA pro-
vides the list of relevant ﬁles to the method extraction module
for further analysis.

B. Method Extraction Module

This module locates and extracts relevant information about
the Java methods in the source code ﬁles of the Android API.
Speciﬁcally, for each version of the API, the module creates
a set of tuples (apiInfo) where each tuple (mInfo) represents
a method in the API and contains the signature (signature),
the comment (comment), and the body (body) of the method.
The module uses a Java parser to build the abstract syntax
tree (AST) for each of the source code ﬁles and identiﬁes the
API methods in a ﬁle by navigating the AST. After locating a
method, the module stores the method signature, the method
comment, and the method body in apiInfo. ANDROSEA only
saves the comments declared through the Javadoc notation
(i.e., /**...*/) since only these comments will appear in
the documentation of the API. The output of this module are
the sets of tuples that are associated with the versions of the
API considered.

C. SEM Identiﬁcation Module

The SEM identiﬁcation module identiﬁes SEMs by com-
paring the relevant methods in the version pairs provided as
input to ANDROSEA. Algorithm 1 describes how the module
identiﬁes SEMs. Given the methods’ information from two
subsequent versions of the Android API (apiInfo1 and apInfo2
in Algorithm 1), the module iterates over the methods in the
versions and compares them (lines 1-15). When the algorithm
ﬁnds methods with matching signatures (i.e., they are the same
method in different versions of the API), ANDROSEA ﬁrst
checks whether the methods have a comment associated with

Fig. 1. High-level overview of the ANDROSEA workﬂow.

systematic study that carefully analyzes this family of changes
across multiple versions of the Android API and investigates
to what extent these changes might affect Android apps.

III. METHODOLOGY
Our analysis is based on the Android framework codebase.
This codebase is one of the largest repository made available
on Github and contains over 440,000 commits and nearly one
thousand release tags. In this study, we focus our analysis on
the ten most recent2 major version releases of the Android
framework, as these versions are the ones that are widely
used on user devices. (Older releases were less popular and
their distribution accounted for less than 3% of the total
distribution.) When selecting a revision for analyzing a major
version release, we chose the ﬁrst release tag associated with
each version considered. Table I reports the details of the
versions and revisions we considered. Using the versions listed
in Table I, we built nine subsequent version pairs (e.g., version
19 and 21 constitute a version pair), and use these pairs to
identify SEMs.

To the best of our knowledge, no readily-available tool
exists to detect SEMs. For this reason, we implemented a
prototype tool called ANDROSEA, which identiﬁes SEMs
across different version of the Android framework. At a high-
level, the tool takes as inputs the repository containing the
codebase of the Android framework and the list of framework
version pairs that ANDROSEA should compare. Given this
information, the tool analyzes the version control history of
the repository to compare methods across different versions of
the Android API. In this step, the tool categorizes a method
as a SEM if the method has the same signature, the same
method comment, but different method body. The output of
ANDROSEA is a list of SEMs for each version pair analyzed.
Fig. 1 presents a high-level overview of the ANDROSEA
workﬂow. As the ﬁgure highlights, ANDROSEA uses three
modules to identify SEMs. The three modules are the repos-
the method extraction
itory preprocessing module (RPM),
module (MEM), and the SEM identiﬁcation module (SIM).
We now present the three modules in detail.

A. Repository Prepocessing Module

Each release of the Android framework codebase contains
a large variety of ﬁles. In fact, the codebase includes the core

2When we started the study in March 2020.

MEMMethod ExtractionModuleSilently-EvolvingMethods (SEMs) AndroidFrameworkCodebaseSIMSEM IdentiﬁcationModuleRPMRepository PreprocessingModuleAlgorithm 1: Detecting Silently-Evolved Methods.
Input

: apiInfo1 and apiInfo2: method information from

two API versions

Output: sems: set of silently-evolved methods between the

two Android versions considered

1 for mInfo1 ∈ apiInfo1 do
2

for mInfo2 ∈ apiInfo2 do

3

4

5

6

7

8

9

10

11

12

13

if mInfo1.signature (cid:54)= mInfo2.signature then

continue

end
if mInfo1.comment.isEmpty ||

mInfo2.comment.isEmpty then

continue

end
if mInfo1.comment == mInfo2.comment then
if mInfo1.body (cid:54)= mInfo2.body then
sems.add(mInfo1, mInfo2)

end

end

end

14
15 end
16 return sems

them. If either one of the methods does not have a comment,
ANDROSEA will not consider the methods for further analysis
(line 7). The rationale behind this decision is that we believe
that such methods might not be intended for use by app
developers as they often resort to the ofﬁcial documentation
to learn how to use the API methods. If both methods have
a comment, ANDROSEA checks whether the comments are
the same or not by comparing their text. If the comments
have the same text, ANDROSEA moves forward and compares
their method bodies. For simplicity, ANDROSEA compares the
method bodies using the text of their bodies. If the bodies are
different, ANDROSEA categorizes the method as a SEM and
adds the method information to the set of SEMs computed for
the API versions pair under analysis.

IV. EXPERIMENTAL STUDY

This section discusses our empirical study. In the study, we

investigated the following research questions

• RQ1: To what extent do SEMs appear in the Android

API?

• RQ2: What are the characteristics of SEMs?
• RQ3: How do SEMs evolve during the development of

the Android API?

• RQ4: To what extent are PASEMs used in Android apps?
In the rest of this section, we answer the research questions

by presenting our experimental ﬁndings.

A. RQ1: SEMs in the Android API

With the ﬁrst

research question, we are interested in
quantifying the number of SEMs in the Android API. To
this end, we ran ANDROSEA on the source code of the
Android framework codebase using the list of release tags
shown in Table I. ANDROSEA extracted all the methods in
each release and conducted a pairwise comparison between
each subsequent version pair (e.g., between android-4.4 r1

and android-5.0.0 r1). Since our study considered ten major
version releases of the Android API, ANDROSEA conducted
nine pairwise comparisons. In total, ANDROSEA was able to
identify 4,769 SEMs and 2,271 of these SEMs are PASEMs.

After identifying SEMs, we also analyzed the modiﬁers
and annotations associated with the methods to determine
the potential impact of the methods on client apps. Table II
reports the number of SEMs identiﬁed by ANDROSEA and
categorizes them by their modiﬁers and annotations. The table
is divided into ﬁve sections. The ﬁrst section (API Level)
reports the information of the version pair considered in the
study. The other four sections group methods according to
their Java access modiﬁer. In Table II, the columns labeled
with the symbol ‘-’ report the number of SEMs that have the
Java access modiﬁer as their only modiﬁer. Furthermore, if a
method has the Java access modiﬁer and multiple additional
modiﬁers or annotations, we counted the method in all the
columns that apply. For example the SEM getInstance
from the ConnectivityManager class in API level 23 is a
private method that has both the static modiﬁer and the
hide annotation. In this case, we counted the method both in
the “static” and the “hide” columns of the “private” section.

The majority of SEMs are declared as public (i.e., they are
PASEMs) and these methods can be directly accessed by of
Android apps. Based on the update types of PASEMs, these
apps may be subject to compatibility issues, which can lead to
ﬁeld failures if the update has changed the method’s semantics
(e.g., the API method presented in our motivating example and
reported in Listing 1). We believe that API developers should
pay particular attention to updating these method comments
so that app developers can suitably account for the semantic
changes affecting their apps.

Although the number of version pairs considered is on the
low side (and this might affect the validity of the results), we
performed a correlation analysis on the SEMs we identiﬁed.
Speciﬁcally, Fig. 2 presents the correlation (obtained via
Pearson’s correlation coefﬁcient) between the total number
of SEMs and the difference between the number of commits
(Fig. 2 (a)), the number of methods including updated methods
(Fig. 2 (b)), and the number of updated methods (Fig. 2 (c))
in each version pair considered. These correlation results (i.e.,
Pearson’s correlation coefﬁcient R and p − value) show that
the introduction of SEMs is not strongly correlated with the
number of Github commits (which do not necessarily lead to
method changes) but strongly correlated with the difference in
the number of methods, especially the difference in the number
of updated methods, in two subsequent releases.

TABLE II
SEMS IDENTIFIED IN OUR STUDY CATEGORIZED BY THEIR MODIFIERS AND ANNOTATIONS.

API Level

19→21
21→22
22→23
23→24
24→25
25→26
26→27
27→28
28→29

-
502
112
279
436
26
233
64
145
166

static
92
18
75
80
9
60
25
111
63

public

abstract
1
125
0
0
0
0
0
0
0

ﬁnal
33
4
49
28
5
14
3
15
11

hide
142
80
171
336
37
200
193
151
263

native
0
0
9
0
0
0
0
0
0

-
38
16
15
16
4
19
5
9
4

static
6
2
9
9
0
4
2
3
1

default

abstract
0
0
0
0
0
0
0
0
0

ﬁnal
1
1
1
2
0
5
0
0
0

hide
6
1
4
5
1
24
5
4
14

native
0
0
0
0
0
0
0
0
0

protected

-
16
1
7
5
0
3
0
0
2

static
0
0
0
0
0
0
0
0
0

ﬁnal
1
1
0
0
0
0
0
0
0

abstract
0
4
0
0
0
0
0
0
0

hide
24
7
4
4
3
7
0
4
6

native
0
0
0
0
0
0
0
0
0

-
52
28
63
44
3
32
7
19
29

static
5
4
10
13
3
9
2
1
4

private

abstract
0
0
0
0
0
0
0
0
0

ﬁnal
3
1
1
0
0
2
0
0
0

hide
39
14
28
15
2
13
2
3
6

native
0
0
0
0
0
0
0
0
0

(a)

(b)

(c)

Fig. 2. Correlations between the number of SEMs and the differences of the number of commits, total methods, and updated methods in two subsequent
releases, respectively.

Answer to RQ1

Based on our empirical results, we can conﬁrm that SEMs
are present in the Android API. Considering ten major
version releases of the API, we were able to identify 4,769
SEMs, including 2,271 PASEMs. These PASEMs could
lead to compatibility issues in their client Android apps.
Furthermore, the more methods are updated in a version
release, the more SEMs can be introduced in the API.

B. RQ2: Understanding SEMs

In the second research question, we are interested in un-
derstanding the main purposes behind the updates of SEMs.
Speciﬁcally, we would like to check whether the updates are
related to simple code refactorings that would introduce no
harm to the system or involved in semantic changes that could
break the execution of existing Android apps. Ideally, we
would expect that SEMs should only involve code refactorings
such as renaming variables and attributes. They should not
include semantic changes as those changes could break the ex-
ecution of client apps. The comments, especially the Javadocs,
of the corresponding methods should have subsequently been
updated to properly advise app developers to update their apps
so as to be aligned with the changed APIs’ new semantics.

1 // Between android-8.1.0_r1 and android-9.0.0_r1
2 public CharSequence[] getTextArray(@StyleableRes int

index) {

final TypedValue value = mValue;

3
4 - if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES,

value)) {

5 + if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {

Listing 2. An example of PASEM ﬂagged as code refactoring.

Unfortunately, to the best of our knowledge, our community
has not yet made available tools for effectively determining
whether an update of method code (i.e., method diff) is related
to semantic change or not. To this end, in this work, we resort
to manual efforts to classify the purposes behind the updates
of PASEMs (i.e., the nature of the changes). We choose to
classify PASEMs instead of SEMs because only PASEMs
could directly impact the execution of client apps available
in the wild. Since manual efforts are known to be time-
intensive, it becomes impractical for us to manually classify
all the PASEMs identiﬁed previously. To that end, we resort
to randomly sample a set of PASEMs to fulﬁll the purpose.
To ensure that the sampled PASEMs are representative, we
turn to the well-known online Sample Size Calculator3 to
determine the number of PASEMs for manual classiﬁcation
(with a conﬁdence level of 95% and margin of error of 10%).
The second column in Table III enumerates the number of
samples randomly selected from each framework iteration. For
each method, two of the authors of the paper independently
categorized the method as either refactoring or semantic
change. If the authors cannot make a decision in 10 minutes,
the corresponding PASEM will be ﬂagged as uncertain. After
completing the independent manual classiﬁcation,
the two
authors then set up meetings to discuss their decisions until
consensuses reached. The ﬁnal results are summarized in the
last four columns in Table III. In the manual classiﬁcation,
only 97 out of 562 are classiﬁed as different types by the
two different authors achieving a high inter-rater reliability
of 82.74%. After the meeting, 41 out of 97 are concluded
as semantic changes accounting for 42.27% while the refac-

3https://www.surveysystem.com/sscalc.htm

lllllllllR = 0.26, p = 0.525050075010001250300006000090000Difference between the number of commitsThe number of SEMslllllllllR = 0.7, p = 0.036030060090012000250050007500Difference between the number of total methodsThe number of SEMslllllllllR = 0.95, p = 0.0001103006009001200100020003000Difference between the number of updated methodsThe number of SEMsTABLE III
MANUAL CLASSIFICATION ON SELECTED SAMPLE PASEMS.

API Level

Sample

19→21
21→22
22→23
23→24
24→25
25→26
26→27
27→28
28→29
Total

83
54
76
81
25
71
42
65
65
562

Added
16
17
23
29
8
15
13
9
13
143

Update type

Removed
2
1
1
1
1
2
0
0
2
25

Changed
34
14
27
35
11
24
15
21
29
199

Sum
52 (62.65%)
32 (59.26%)
51 (67.10%)
65 (80.25%)
20 (80.00%)
41 (57.75%)
28 (66.67%)
30 (46.15%)
44 (67.69%)
363 (64.59%)

Refactoring

Uncertain

Disagreement

22 (26.51%)
19 (35.19%)
21 (27.63%)
13 (16.05%)
2 (8.00%)
23 (32.39%)
14 (33.33%)
24 (36.92%)
10 (15.38%)
148 (26.33%)

9 (10.84%)
3 (5.56%)
4 (5.26%)
3 (3.70%)
3 (12.00%)
7 (9.83%)
0 (0.00%)
11 (16.92%)
11 (16.92%)
51 (9.07%)

22 (26.51%)
1 (1.85%)
21 (27.63%)
9 (11.11%)
5 (20.00%)
11 (15.49%)
2 (4.76%)
12 (18.46%)
14 (21.53%)
97 (17.26%)

torings and uncertains are made up of 23.71% and 34.02%
in all, slightly more than a
respectively. Surprisingly, all
quarter of the randomly selected PASEMs are related to code
refactorings (Listing 2 presents such an example), and around
two-thirds of the randomly selected PASEMs are related to
semantic changes (e.g., logic added, removed, or changed
that is complicated update including statements added and
removed). This result shows that SEMs are a severe problem
in the Android framework. The framework maintainers should
pay special attention to carefully handle these methods, i.e.,
avoid introducing SEMs in future releases and document the
semantically changed methods.

1 // Between android-9.0.0_r1 and android-10.0.0_r1
2 public void setVolumeTo(int value, int flags) {
3
4 - mSessionBinder.setVolumeTo( mContext.getPackageName(),

try {

mCbStub, value, flags);

5 + // Note: Need both package name and OP package name.

Package name is used for

6 + // RemoteUserInfo, and OP package name is used for

AudioService’s internal

7 + // AppOpsManager usages.
8 + mSessionBinder.setVolumeTo( mContext.getPackageName(),
mContext.getOpPackageName(), mCbStub, value, flags);

9

} catch (RemoteException e) {

Listing 3. An example of PASEM ﬂagged as uncertain.

As shown in Table III (the ﬁfth column), around 10%
of PASEMs are ﬂagged as uncertain. The majority of those
methods are related to updates of callee methods, which may
further involve complicated changes. Listing 3 presents such
an example. The original callee method setVolumeTo() called
by mSessionBinder has been replaced by a new one that
involves a new parameter, which is not needed by the original
version. The callee method is only deﬁned in a Java interface
called ISessionController, which is non-trivial for the authors
to manually identify its dynamically bound object (in a short
time), considering that the Android framework is one of the
most complicated open-source projects. Therefore, this update
is ﬂagged as uncertain.

Answer to RQ2

the majority of
Our manual classiﬁcation reveals that
PASEMs (over 64.59%) do involve semantic changes, and
such changes may involve complicated updates of the code.

(a) SEMs

(b) PASEMs

Fig. 3. Distribution of update times of SEMs from level 19 to 29.

C. RQ3: Evolution of PASEMs

In this research question, we are interested in exploring
the evolution of SEMs under the evolution of the Android
framework codebase. To this end, we ﬁrst look at the number
of times a given method is silently changed. Fig. 3 illus-
trates the distribution of such times for all
the identiﬁed
4,769 SEMs and 2,271 PASEMs. Expectedly, the majority
of methods (61.12%) that are ﬂagged as SEMs are only
silently evolved once, in the meanwhile, 79.03% of PASEMs
are silently evolved once, suggesting that SEMs might not
be intentionally introduced by the framework developers.
Nevertheless, there are several methods that have indeed been
repeatedly changed silently. For example, method loop of
ﬁle core/java/android/os/Looper.java has been
silently updated six times, among the nine considered iter-
ations. The class Looper is used to run a message loop for a
thread. For the speciﬁc method, it is actually a static public
method that is used to run the message queue in this thread.
Among the 4,769 SEMs, interestingly, only 80 of them
have their comments updated along with the update of the
implementation in the following up revisions of the Android
framework. This experimental result suggests that framework

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll12345678llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll123456break the compilation rules for Android apps, resulting in
explicit compatibility issues. Interestingly,
the majority of
modiﬁer changes are related to altering non-abstract methods
to abstract methods or exchanging native methods with non-
native methods. Listing 5 represents an example of modi-
ﬁers update from public to public abstract extracted between
android-5.0.0 r1 and android-5.1.0 r1. The class, the method
belongs to, is actually an abstract class. The body of the
method is to provide the default behavior, which is to throw
MustOverrideException if the subclass extends the
WebSettings but does not explicitly override the method. The
update of the method reinforces the need to override the
method by declaring it as abstract, which utilizes the compile-
time check to ensure that the method will be overridden in
the subclass. Although this type of change is trivial, it will
theoretically cause compatibility issues for existing Android
apps. Indeed, previously, even if developers do not override
the API method setBuiltInZoomControls() when extending
the WebSettings class, grammatically speaking, there will be
no compile error. However, with the latest SDK version,
the accessibility of setBuiltInZoomControls() has changed to
public abstract, there will be a compile error if the method
is not explicitly overridden. Therefore, ideally, this type of
change should be avoided by framework maintainers, and sub-
sequently should be considered by software analyzers aiming
at detecting compatibility issues in Android apps.

1 // This is an abstract base class: concrete

WebViewProviders must

2 // create a class derived from this, and return an

instance of it in the

3 // WebViewProvider.getWebSettingsProvider() method

implementation.

4 public abstract class WebSettings {
5 - public void setBuiltInZoomControls(boolean

enabled) {

throw new MustOverrideException();

6 -
7 - }
8 + public abstract void

setBuiltInZoomControls(boolean enabled);

Listing 5. An example of modiﬁer update from public to public abstract.

Fig. 4. The update of modiﬁers. The line in clockwise shows the direction
of the update and the weight on the line shows the number of SEMs having
such updates.

maintainers might not yet be made aware of SEMs or at
least are not well-motivated to mitigate the introduction of
SEMs. Listing 4 illustrates one of such updated comments.
The implementation of the method has been updated in the
release android-5.0.0 r1 while its comments are only updated
at the revision android-6.0.0 r1. Nevertheless, although rare,
the fact that some of the SEMs are indeed resolved by the
framework maintainers shows that SEMs are indeed a problem
that should be carefully addressed.

1 //android.widget.CheckedTextView.setCheckMarkDrawable
2 /**
3 - * Set the checkmark to a given Drawable. This will

be drawn when {@link #isChecked()} is true.

4 - * @param d The Drawable to use for the checkmark.
5 + * Set the check mark to the specified drawable.
6 + * <p>
7 + * When this view is checked, the drawable’s state

set will include

8 + * {@link android.R.attr#state_checked}.
9 + * @param d the drawable to use for the check mark
10 + * @attr ref

android.R.styleable#CheckedTextView_checkMark

* @see #setCheckMarkDrawable(int)
* @see #getCheckMarkDrawable()

11
12
13 - * @attr ref

android.R.styleable#CheckedTextView_checkMark

14

*/

Listing 4. The comment of SEM setCheckMarkDrawable is updated
in a future release while its body is not changed.

We further look at the evolution of method modiﬁers for
all the identiﬁed SEMs. Fig. 4 summarizes such results in
a directed graph. Each node represents a distinct modiﬁer
type, while each arrowed edge represents an evolution, e.g.,
from a src modiﬁer to the dest modiﬁer. The weight of
each edge subsequently represents the number of times the
corresponding evolution happens during the evolution of the
Android framework codebase.

In total, we have observed 204 times of modiﬁer changes.
Expectedly, none of the changes are made from public to
other low-level accessibilities (except one from public static
hidden to private static hidden4) as such changes would

4Hidden APIs cannot be directly accessed by Android apps.

The majority of the updates related to native methods share
the same change pattern, which is to provide a wrapper method
with the same name while calling the native method to provide
the same behavior (cf. (Listing 6). Even though the modiﬁers
were updated from public native to public, the signatures of
the APIs provided to developers are not changed. Practitioners
hence can still use the same method signature to implement
their intentions. Therefore, this type of update will unlikely to
introduce compatibility issues into running Android apps.

1 // Code snippet from android-4.4_r1
2 94 public native int getHeight();
3 // Code snippet from android-5.0.0_r1
4 107 public int getHeight() {
5 108
6 109 }

return nativeGetHeight(mNativePicture);

Listing 6. An example of modiﬁer update from public native to public.

protected hiddenprotected abstract hiddenpublic static finalpublic staticpublic static nativepublic nativepublicpublic finalpublic final nativeprivatepublic hiddenpublic abstractprotectedprivate staticprotected abstractprivate hiddenpublic final hiddenpublic static hiddenpublic abstract hiddendefault hiddendefault abstractpublic native hiddendefaultprivate static hiddenpublic static native hiddenpublic static final hiddendefault static hidden21120195521131112111221312431111411Answer to RQ3

The majority of SEMs is only introduced into the frame-
work once, without following up updates. Moreover, SEMs
may involve updating the method’s modiﬁers that could
further introduce runtime issues to client Android apps.

D. RQ4: PASEMs in Android apps

Since PASEMs may involve semantic changes, their client
apps may suffer from incompatible issues (because of those
silent semantic changes) when they are running on devices
with different SDK versions. Therefore, in this last research
question, we are interested in knowing if PASEMs are used
by Android apps. If so, to what extent are they accessed,
and what are the potential impacts such usages could bring
to Android app developers? To answer these questions, we
introduce a simple app scanner to the community, which takes
as input an Android APK and the list of PASEMs identiﬁed
in this work and outputs the list of PASEMs that are actually
accessed by the APK. The app scanner is implemented on top
of the famous Soot analysis framework [18]. The APIs are
identiﬁed at the Jimple level, which is one of the intermediate
representation types provided by Soot to ease the analysis of
Android apps.

Speciﬁcally, to fulﬁll our experiments, we randomly select
1,000 apps published in 2020 from the ofﬁcial Google Play
store. All of the selected apps are then sent to the afore-
mentioned app scanner to check whether they have leveraged
PASEMs or not. Interestingly and surprisingly, among the
1,000 apps, 957 of them have accessed PASEMs. Moreover, in
total, 44.25% PASEMs are accessed. Fig. 5(a) further presents
the distribution of the number of PASEMs accessed by these
apps, giving a median and average number of PASEMs at
107 and 126, respectively. This experimental result shows
that PASEMs have been signiﬁcantly accessed by Android
apps, which could subsequently suffer from “hidden” incom-
patible issues. This result strongly suggests that the Android
framework maintainers should pay special attention to avoid
introducing PASEMs. This ﬁnding is further backed up by the
fact that semantically updated PASEMs are also signiﬁcantly
accessed by Android apps, as illustrated in Fig. 5(b), for which
only the 363 manually conﬁrmed PASEMs (involving semantic
changes) are considered.

Previous studies, such as the one proposed by He et al. [14],
shows that the convention to address the evolution-induced
API compatibility issue is to add additional conditions to
check the practical running API level of the device (e.g.,
through the default constant value of VERSION.SDK_INT)
before invoking the corresponding APIs. In this work, we try
to detect how many different PASEMs are called after the
API level condition check, where the PASEMs are referred to
as protected PASEMs. Interestingly, 469 out of 1,000 Apps
indeed contain protected PASEMs, for which there are 134
PASEMs called under protection. Table IV presents the top-
10 PASEMs ranked by their protection times. The fact that
the top-ranked PASEMs are protected more than 800 times

(a) Total PASEMs.

Semantically

(b)
PASEMs.

updated

Fig. 5. The distribution of the number of PASEMs used in a set of randomly
selected 1,000 APKs published on 2020.

TABLE IV
THE TOP TEN PROTECTED PASEMS IN 1,000 APKS

PASEM
android.content.res.TypedArray: void recycle()
android.os.Bundle: void putParcelable(String,Parcelable)
android.os.Bundle: void putCharSequence(String,CharSequence)
android.text.TextUtils: void writeToParcel(CharSequence,Parcel,int)
android.app.AlarmManager: void setExact(int,long,PendingIntent)
android.app.AlarmManager: void setExactAndAllowWhileIdle(int,long,PendingIntent)
android.app.Activity: boolean navigateUpTo(Intent)
android.app.Activity: void startIntentSenderForResult(IntentSender,int,Intent,int,int,int,Bundle)
android.view.ViewGroup: void removeView(View)
android.os.Bundle: void putAll(Bundle)

times
848
788
623
384
359
289
286
285
283
273

shows that PASEMs could be protectively accessed many
times within the same app.

Moreover, we go one step deeper to check the actual API
levels leveraged for protecting the invocation of PASEMs. Our
experimental results reveal that a large portion of PASEMs
(i.e., 45 or 33.58%) are protected by different API levels,
indicating possible errors of app developers, although they
have attempted to protect the accessed PASEMs. The possible
reasons behind these disagreements between developers could
be that PASEMs are silently (hence hiddenly) introduced to the
framework. There is hence no documentation for developers
to correctly use these PASEMs. Subsequently, developers have
to independently identify the API levels suitable for protecting
PASEMs independently, based on their empirical evidence.
The fact that developers have attempted to protect the access of
PASEMs (although may incorrectly do so because of lacking
documentation) indicates that PASEMs can indeed introduce
runtime issues to Android apps. Therefore, we argue that
PASEMs should be totally avoided by framework maintainers.
There is also a need to introduce automated tools to regulate
that. Our approach ANDROSEA could be leveraged to achieve
such a purpose.

0100200300050100150200250300350Answer to RQ4

PASEMs have indeed commonly been accessed by real-
world Android apps. Some of them are even accessed with
protections (by checking the running API level), indicating
that practitioners have realized that those PASEMs could
introduce runtime issues to their apps, although they are
not documenting.

V. DISCUSSION

We now discuss the potential implications of this study for
both practitioners and our fellow researchers, as well as some
promising future research directions that could be built on the
ﬁndings of our research (cf. V-A). After that, we present the
potential threats to the validity of this study (cf. Section V-B).

is an artifact of the complexity associated with the manual
analysis performed in the study. To mitigate this threat, we
considered all the widely-used major version releases of the
Android framework. In relation to external threats to validity,
the results presented for answering RQ4 might not generalize
to other apps. We mitigated this threat by randomly selecting
apps from AndroZoo, one of the most comprehensive app
datasets made available to the research community. Finally,
an additional threat to validity could be posed by the fact that
our study involves manual tasks, which could have introduced
errors in the results we presented. For example, in our study,
we had to manually inspect and summarize the code associated
with SEMs. To mitigate this threat, two authors cross-validated
and inspected the results.

VI. RELATED WORK

A. Implication for Practitioners and Researchers

A. API evolution

As shown in Figure 5, the usages of PASEMs are common
in real-world Android Apps, and over 60% of the PASEMs
involve truly semantic changes, as demonstrated in Table III.
As semantic changes could introduce potential crashes (or
security, efﬁciency issues) in daily use of the Android Apps,
we argue that framework maintainers should try their best
to avoid introducing PASEMs. This should also apply to the
maintenance of any other third-party frameworks or libraries
that provide APIs to facilitate the development of client apps.
Subsequently, the client app developers should pay special
attention to those silently evolved methods when developing
their apps.

As shown in Table III, slightly more than a quarter of SEMs
do not involve semantic changes but are simply related to
code refactorings. When performing compatibility analyses,
these methods could be ignored as they will not introduce
runtime issues to their users (i.e., client apps). However, to
the best of our knowledge, our community has not introduced
promising tools to automatically decide if a given code diff
involves semantic changes. State-of-the-art refactoring detec-
tion tools [19], [20] are not capable of accurately achieving
that. Therefore, we argue that there is a strong need to invent
an automated approach to locate semantic changes during the
evolution of software systems. With the help of this tool, SEMs
with semantic changes could be automatically identiﬁed and
thereby mitigated by codebase maintainers.

the
Besides the implementation update of the methods,
methods’ modiﬁers might also be updated along with. The
update of the modiﬁers also could bring in big problems, such
as the example in listing 5. Therefore, we argue that our fellow
practitioners should pay attention to the updates of methods’
modiﬁers when updating their software systems.

B. Threats to Validity

As it is the case of most empirical evaluations, there are
threats to validity associated with the results we presented. In
terms of external validity, our results might not generalize to
other version pairs in the Android framework. In particular, we
identiﬁed SEMs in only nine versions pairs. This limitation

to adopt

While API evolves to meet new feature requirements, to ﬁx
bugs etc., developers need to update their implementation of
the Application and publish the newer version to provide a
stable running environment for their customers. McDonnell
et al. [4] conducted an extensive empirical study on the
stability and adoption of Android APIs while focusing on the
relationship between the API evolution and client adoption.
The authors in the paper conﬁrm that the Android API evolves
more frequently than the client adoption and what’s more,
the more frequent update of the APIs the longer time for
the ones. Bavota et al. [7] and Linares-
client
V´asquez [6] studied the relationship between the popularity of
the Android Applications and the stability of the SDK APIs.
Their empirical study reveal that the more enjoyable Android
Apps are prone to call the less updated APIs. Works [13]
and [14] investigate the API-related compatibility issues. Li et
al. [13] present an approach CiD to highlight the API usage
that can lead to potential compatibility issues by analysing the
framework release history and identifying the methods without
API level checking. He et al. [14] investigate the evolution-
induced compatibility issues in Android Applications. Their
research shows that the Android Support library only provides
limited support for the new APIs in each release and the
majority of the Applications need to handle the evolution-
induced compatibility issues in their own implementation.
Different from the existing work focusing on the general APIs,
what we do is to disclose the silently evolved methods that
always ignored by developers and researchers.

B. API pattern

In addition, researchers propose many different approaches
to detect Android malware to address the security problems
of remote control, privilege escalation, and privacy leakage
etc. Chan et al. [21] proposed a static approach for Android
malware detection via extracting permissions and API usage.
They conﬁrm that the integration between the feature of per-
mission and API calls can achieve a better precision than just
the only feature of permission. Karbab et al. [22] introduced
an automatic and effective Android malware detection system,

MalDozer, that depends on deep learning techniques and raw
sequences of API method calls. Arp et al. [23] proposed a tool
DREBIN that builds a SVM based detection model utilizing
APIs and other related information. While Ma et al. [24] de-
compile the Android Apps and construct three different system
API data sets: API usage, API frequency, and API sequence
to detect malware. To be speciﬁc, Linares-V´asquez et al. [25]
attempted to reveal the APIs and usage patterns related to
energy consumption, and to provide potential guidance for
developers to decrease energy consumption.

C. Special APIs

Android APIs typically follow the general deprecated-
replace-remove evolution cycle. Work [15] introduced proto-
type tool called CDA to characterize deprecated APIs from
different revisions. Their extensive investigation shows that
the deprecated APIs are not continuously annotated and doc-
umented and over a half of these APIs are commented to pro-
vide alternatives but these alternatives are rarely replaced by
the developers. Besides the aforementioned general publicly
accessible APIs, there exists another type of API referred
to as inaccessible API that can be recognized as internal
or hidden. Internal APIs are resolved ones for system apps
located in the package com.android.internal while
hidden APIs are methods annotated by the javadoc @hide. Li
et al. [16] did an extensive investigation to reveal the usability
of these APIs. They demonstrate that these inaccessible APIs
are continuously implemented in the Android framework and
used to access a speciﬁc set of features while without any
promise of forward compatibility. They also reveal that there
exist a plenty of apps are indeed calling these inaccessible
APIs and the patterns of usage are quite different between
each other.

VII. CONCLUSION

In this paper, we presented an empirical study that inves-
tigates silently-evolved methods (or SEMs in short) in nine
version pairs of the Android API. To perform the study, we
built a prototype tool called ANDROSEA. This tool, given the
Android framework codebase as an input, is able to identify
SEMs in the Android API. Using ANDROSEA, we found that
SEMs are indeed present in the Android API, and a large
number of them can be publicly accessed by app developers.
Additionally, we empirically found that (i) the majority of
publicly-accessible silently-evolved methods (or PASEMs in
short) involve semantic changes and these changes could lead
to ﬁeld failures in their client apps, (ii) the majority of SEMs
is only introduced into the framework once, indicating that
framework maintainers may not have been aware of this
situation, and (iii) PASEMs are frequently used by real-world
Android apps, even without suitably using API version checks.
We foresee a number of venues for future work. First, we
plan to run a user study in which we investigate how devel-
opers react to changes in the Android API and their related
documentation. We believe that such a study would provide
a better understanding on how to best document semantic

changes in the Android API. Second, we plan to study how
SEMs are related to bug reports by mining and analyzing
issues on GitHub. Finally, we plan to investigate whether
Android developers follow different development practices in
minor and major version updates of the Android framework
and how these practices relate to SEMs.

ACKNOWLEDGMENTS

This work was partially supported by the Australian
Research Council
(ARC) under a Laureate Fellowship
project FL190100035, a Discovery Early Career Researcher
Award (DECRA) project DE200100016, a Discovery project
DP200100020, and a gift from Facebook.

REFERENCES

[1] eMarketer,

eMarketer

Unveils

App

bile
eMarketer-Unveils-New-Estimates-Mobile-App-Usage/1015611,
2020, Last updated: 11-Apr-2017.

Usage.

New

for Mo-
https://www.emarketer.com/Article/

Estimates

[2] Mobile operating systems’ market share worldwide from January
https://www.statista.com/statistics/272698/

2012
global-market-share-held-by-mobile-operating-systems-since-2009,
2020, Last updated: 17-Aug-2020.

2020.

July

to

[3] Number of available applications in the Google Play Store from De-
cember 2009 to June 2020. https://www.statista.com/statistics/266210/
number-of-available-applications-in-the-google-play-store, 2020, Last
updated: 17-Aug-2020.

[4] T. McDonnell, B. Ray, and M. Kim, “An empirical study of api stability
and adoption in the android ecosystem,” in ICSM, 2013, pp. 70–79.
[5] M. D. Syer, M. Nagappan, B. Adams, and A. E. Hassan, “Studying
the relationship between source code quality and mobile platform
dependence,” Software Quality Journal, p. 485–508, 2015.

[6] M. Linares-V´asquez, G. Bavota, C. Bernal-C´ardenas, M. Di Penta,
R. Oliveto, and D. Poshyvanyk, “Api change and fault proneness: a
threat to the success of android apps,” in FSE, 2013, pp. 477–487.
[7] G. Bavota, M. Linares-Vasquez, C. E. Bernal-Cardenas, M. Di Penta,
R. Oliveto, and D. Poshyvanyk, “The impact of api change-and fault-
proneness on the user ratings of android apps,” TSE, vol. 41, no. 4, pp.
384–407, 2014.

[8] G. Yang, J. Jones, A. Moninger, and M. Che, “How do android operating
system updates impact apps?” in MobileSoft. New York, NY, USA:
ACM, 2018, pp. 156–160.

[9] L. Li, T. Bissyand´e, and J. Klein, “Moonlightbox: Mining android api
IEEE,

histories for uncovering release-time inconsistencies,” in ISSRE.
2018, pp. 212–223.

[10] L. Li, J. Gao, T. F. Bissyand´e, L. Ma, X. Xia, and J. Klein, “Character-

ising deprecated android apis,” in MSR, 2018.

[11] API reference. https://developer.android.com/reference, 2020, Last up-

dated: 15-Sep-2020.

[12] ConnectivityManager. https://developer.android.com/reference/android/
net/ConnectivityManager#getAllNetworkInfo(), 2020, Last updated: 29-
Sep-2020.

[13] L. Li, T. F. Bissyand´e, H. Wang, and J. Klein, “Cid: Automating the
detection of api-related compatibility issues in android apps,” in ISSTA,
2018.

[14] D. He, L. Li, L. Wang, H. Zheng, G. Li, and J. Xue, “Understanding
and detecting evolution-induced compatibility issues in android apps,” in
2018 33rd IEEE/ACM International Conference on Automated Software
Engineering (ASE).
IEEE, 2018, pp. 167–177.

[15] L. Li, J. Gao, T. F. Bissyand´e, L. Ma, X. Xia, and J. Klein, “Cda:
Characterising deprecated android apis,” Empirical Software Engineer-
ing (EMSE), 2020.

[16] L. Li, T. F. Bissyand´e, Y. Le Traon, and J. Klein, “Accessing inaccessible
android apis: An empirical study,” in ICSME. IEEE, 2016, pp. 411–422.
[17] SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVE-
POINT Statements. https://dev.mysql.com/doc/refman/8.0/en/savepoint.
html, 2020, Last updated: 29-Sep-2020.

[18] P. Lam, E. Bodden, O. Lhot´ak, and L. Hendren, “The soot framework

for java program analysis: a retrospective,” in CETUS, 2011.

[19] N. Tsantalis, A. Ketkar, and D. Dig, “Refactoringminer 2.0,” IEEE

Transactions on Software Engineering, 2020.

[20] J.-R. Falleri, F. Morandat, X. Blanc, M. Martinez, and M. Monperrus,

“Fine-grained and accurate source code differencing,” in ASE, 2014.

[21] P. P. Chan and W.-K. Song, “Static detection of android malware by

using permissions and api calls,” in ICMLC, 2014.

C. Siemens, “Drebin: Effective and explainable detection of android
malware in your pocket.” in Ndss, vol. 14, 2014, pp. 23–26.

[24] Z. Ma, H. Ge, Y. Liu, M. Zhao, and J. Ma, “A combination method for
android malware detection based on control ﬂow graphs and machine
learning algorithms,” IEEE access, vol. 7, pp. 21 235–21 245, 2019.

[22] E. B. Karbab, M. Debbabi, A. Derhab, and D. Mouheb, “Android
malware detection using deep learning on api method sequences,” arXiv
preprint arXiv:1712.08996, 2017.

[23] D. Arp, M. Spreitzenbarth, M. Hubner, H. Gascon, K. Rieck, and

[25] M. Linares-V´asquez, G. Bavota, C. Bernal-C´ardenas, R. Oliveto,
M. Di Penta, and D. Poshyvanyk, “Mining energy-greedy api usage
patterns in android apps: an empirical study,” in Proceedings of the 11th
working conference on mining software repositories, 2014, pp. 2–11.

