2
2
0
2

y
a
M
0
2

]
E
S
.
s
c
[

2
v
3
9
4
9
0
.
3
0
2
2
:
v
i
X
r
a

M. Riebisch, M. Tropmann-Frick (Hrsg.): Modellierung 2022,
Bonn: Gesellschaft fÃ¼r Informatik e.V. 1

Modellieren mit Heraklit

Prinzipien und Fallstudie

Peter Fettke1, Wolfgang Reisig2

Abstract: Heraklit ist ein laufendes Forschungsprogramm und Entwicklungsprojekt mit dem
Ziel der Schaffung einer Infrastruktur zur Modellierung groÃŸer, rechnerintegrierter Systeme. Wir
diskutieren die zentralen Anforderungen an solche Modelle (Hierarchien, Nutzersicht, ÃœberfÃ¼hrung
informaler in formale Ideen, schematische Modelle, gleichrangiger Umgang mit digitalisierten und
personengebundenen Prozessen) und erlÃ¤utern, wie Heraklit diese Anforderungen unterstÃ¼tzt. Eine
Fallstudie zeigt die Nutzbarkeit von Heraklit in der Praxis.

Keywords: systems composition; data modelling; behaviour modelling; composition calculus;
algebraic specification; systems mining

1 Einleitung

Informatik hat zwei Gesichter: einerseits die technischen Grundlagen mit den formalen
Konzepten zu ihrer Nutzung, andererseits die Anwendung. DÄ³kstra hat vielfach vorgeschla-
gen, die formale und informelle Sicht zu trennen und zwischen ihnen eine Mauer (engl.
â€firewallâ€œ) zu errichten [Di89]. BegrÃ¼ndung: Das â€correctness problemâ€œ des Informatikers
verlangt ganz andere Herangehensweisen als das â€pleasantness problemâ€œ des Anwenders.
Modellierung findet in diesem Bild auf der einen oder anderen Seite dieser Mauer statt.

DemgegenÃ¼ber schlagen wir hier vor, Modellierung als eine TÃ¤tigkeit zu verstehen, die
einen mÃ¶glichst bruchlosen Ãœbergang zwischen formal formulierten und lebensweltlichen
Sachverhalten erlaubt. Modelle verknÃ¼pfen Anwendung und Technik und beruhen auf
denselben Grundlagen.

In diesem Beitrag beschreiben und motivieren wir zunÃ¤chst im zweiten Abschnitt Anforde-
rungen, die heutzutage an die Modellierung rechnerintegrierter Systeme gestellt werden.
Kapitel 3 stellt dann die Konzepte vor, mit denen Heraklit [FR21a, FR21b] diese Anforde-
rungen bewÃ¤ltigt. Eine umfangreiche Fallstudie zeigt im vierten Kapitel, dass die ErfÃ¼llung
aller Anforderungen in einem integrierten Framework tatsÃ¤chlich gelingt. SchlieÃŸlich wird

1 Saarland University, SaarbrÃ¼cken, Germany, und German Research Center for Artificial Intelligence (DFKI),

SaarbrÃ¼cken, Germany, peter.fettke@dfki.de

2 Humboldt-UniversitÃ¤t zu Berlin, Berlin, Germany, reisig@informatik.hu-berlin.de

cba

 
 
 
 
 
 
2 Peter Fettke, Wolfgang Reisig

im fÃ¼nften Kapitel diskutiert, in welchem Umfang andere Frameworks die Anforderungen
aus Kapitel 2 entsprechen.

2 Anforderungen an die Modellierung rechnerintegrierter Systeme

Der Herstellung eines komplexen rechnerintegrierten Systems ist immer ein Planungs-
prozess vorgeschaltet, in dem die Architektur, Funktionsweise, beabsichtigten Effekte etc.
des Produktes formuliert werden. Zentrales Werkzeug und Hilfsmittel dafÃ¼r sind Modelle.
Auch ein gegebenes komplexes System kann man besser verstehen und analysieren, indem
man es modelliert. Ein Modell betont einige Aspekte des Systems, oft mit graphischen,
standardisierten Darstellungen. Ein gutes Modell ist nicht nur anschaulicher und besser ver-
stÃ¤ndlich als eine umgangssprachliche Darstellung; es lÃ¤sst sich auch vielfÃ¤ltig nutzen: man
kann FunktionalitÃ¤t und Performanz-EngpÃ¤sse erkennen, Kosten abschÃ¤tzen, Korrektheit
gegenÃ¼ber einer Spezifikation nachweisen, Parameter optimieren und vieles andere mehr.

Moderne und zukÃ¼nftige digitale Systeme, cyber-physikalische Systeme, digitale infor-
mationsbasierte Infrastrukturen, das Internet of people, things and services etc., werden
zunehmend komplexer und wachsen immer mehr zusammen. Folglich sind bei der Gestal-
tung rechnerintegrierter Systeme vielfÃ¤ltige Herausforderungen zu Ã¼berwinden. NÃ¶tig sind
dafÃ¼r Frameworks, die insbesondere fÃ¼r groÃŸe Systeme wirklich Nutzen bringen. DafÃ¼r ist
eine Reihe von Aspekten besonders wichtig:

Komposition und hierarchische Verfeinerung lokaler Komponenten: Was bedeutet es
konzeptuell, dass rechnerintegrierte Systeme â€groÃŸâ€œ sind? Es bedeutet zunÃ¤chst einmal, dass
einige Konzepte, die fÃ¼r kleine Systeme durchaus verwendet werden kÃ¶nnen, nun nicht mehr
praktikabel sind. Am augenfÃ¤lligsten gilt das fÃ¼r globale ZustÃ¤nde und globale Schritte. Und
es bedeutet, dass ein groÃŸes System im Allgemeinen nicht amorph, gleichfÃ¶rmig gestaltet ist,
sondern in irgendeiner Form komponiert ist aus kleineren, mehr oder weniger selbstÃ¤ndig
agierenden Systemen. Komposition und Verfeinerung sind also fundamentale Konzepte zur
Modellierung groÃŸer Systeme.

Modelle aus Sicht der Anwender: Es gibt mehrere Weisen, Informatik im Allgemeinen
und Modellierung in der Informatik im Besonderen zu fassen. HÃ¤ufig wird der Zugang
Ã¼ber die theoretische Informatik gewÃ¤hlt, mit der Betrachtung von Zeichenketten und
ihrer Transformation. Beliebt ist auch der Zugang von der technischen Seite mit digitalen
Schaltungen und ihrer Abstraktion, hin zu Software, Datenbanken, etc. Zum VerstÃ¤ndnis
groÃŸer Systeme besonders nÃ¼tzlich erscheint aber der Zugang aus der Sicht der Anwender,
Nutzer, Betreiber und der Zwecke, fÃ¼r die groÃŸe Systeme betrieben werden.

Systematische ÃœberfÃ¼hrung informeller, intuitiver Ideen zu einem gegebenen oder inten-
dierten System in ein formales Modell: DafÃ¼r bietet die Informatik strukturierte Konzepte.
Allerdings mÃ¼nden sie zumeist in Programme, nicht in formale Modelle.

Modellieren mit Heraklit 3

Parametrisierte, schematische Modellierung: Oft soll nicht nur ein einziges System mo-
delliert werden, sondern eine Menge gleichartig strukturierter und verhaltensÃ¤hnlicher
Modelle.

Integrierter, einheitlicher, gleichrangiger Umgang mit digitalisierten und lebensweltlichen
Prozessen: Ein Beispiel ist in einem Betrieb die automatisierte digitale Personalverwaltung,
zusammen mit der Belehrung eines Arbeitnehmers Ã¼ber gefÃ¤hrliche GÃ¼ter und dessen
BestÃ¤tigung durch seine Unterschrift. Neben symbolischen, implementierten Konzepten
muss ein Modell also auch pragmatische, nicht zur Implementierung vorgesehene Schritte
darstellen kÃ¶nnen.

3 Von Heraklit verwendete Konzepte

Informatik wird Ã¼blicherweise von der Rechentechnik her oder vom Symbolischen her
aufgefasst, also aus der Sicht der technischen Informatik, oder der klassischen theoretischen
Informatik. DemgegenÃ¼ber betrachtet Heraklit die Informatik aus einer dritten Sicht, der
Sicht der Anwender. FÃ¼r Heraklit zentral ist die holistische Auffassung von Systemen
und ihren Modellen: Es reicht nicht, einzelne Anforderungen an das Systemverhalten, Ver-
fahrensanleitungen fÃ¼r Anwender, Datensammlungen, Algorithmen, Softwarekomponenten,
Hardwarekonzepte etc. isoliert zu betrachten, zu verstehen und zu verwenden. Vielmehr
muss ihr Zusammenspiel verstanden werden. DafÃ¼r braucht man ein Modell, das alle diese
Aspekte integriert. Heraklit ist auf diese Anforderungen an Modelle zugeschnitten.

3.1 Konzeptionelle Sicht

Heraklit unterstÃ¼tzt die Modellierung von Systemen, die aus Teilsystemen zusammenge-
setzt sind, und die Hierarchien bilden, in denen konkrete Produkte, Maschinen, Menschen,
Dokumente, Datenspeicher etc. kombiniert, separiert, transformiert, berechnet, bearbeitet,
transportiert, erzeugt, vernichtet werden. Heraklit-Modelle kÃ¶nnen abstrakt, detailliert,
schematisch sein; Daten, GegenstÃ¤nde, Schritte zur Beschreibung dynamischen Verhaltens
sind kleinteilig, aber auch umfassend formulierbar. Konkrete und abstrakte Datenstrukturen,
sowie die Beschreibung von Verhalten werden integriert und aufeinander bezogen modelliert.
Heraklit bietet dafÃ¼r aufeinander abgestimmte Ausdrucksmittel, die den Modellierer bei
der Formulierung seiner Ideen unterstÃ¼tzen. Der Modellierer wird nicht eingeschrÃ¤nkt; bei
der Wahl des Abstraktionsgrades und der Art der Komposition von Modulen hat er inhaltlich
alle Freiheiten; Heraklit schlÃ¤gt aber konzeptionell vereinheitlichende Darstellungen
vor. Heraklit integriert neue Konzepte mit bewÃ¤hrten, tiefliegend motivierten Konzepten
der Modellierung von Software, GeschÃ¤ftsprozessen und anderen Systemen. Zudem bietet
Heraklit ein Konzept zur Abstraktion konkreter Daten, und damit die symbolische
Modellierung groÃŸer Klassen von Systemen, die Ã¤hnlich aufgebaut sind und sich Ã¤hnlich
verhalten.

4 Peter Fettke, Wolfgang Reisig

Mit seinen wenigen, aber ausdrucksstarken Konzepten sind Heraklit-Modelle:

â€¢

â€¢

â€¢

â€¢

â€¢

fÃ¼r den Entwickler besser beherrschbar,

fÃ¼r den Nutzer leicht verstÃ¤ndlich,

weniger fehleranfÃ¤llig und leichter verifizierbar,

einfacher Ã¤nderbar, sowie

schneller herstellbar und kostengÃ¼nstiger als andere Methoden, insbesondere auch fÃ¼r
wirklich groÃŸe Systeme.

3.2 Technische Sicht

Technisch und formal neu ist die Integration von Architektur, statischen und dynamischen
Konzepten. DafÃ¼r kombiniert Heraklit bewÃ¤hrte mathematisch basierte und intuitiv leicht
verstÃ¤ndliche Konzepte wie PrÃ¤dikatenlogik, abstrakte Datentypen und Petrinetze, die auch
bisher schon zur Spezifikation von Systemen verwendet werden; Heraklit kombiniert sie
neu und ergÃ¤nzt sie um den KompositionskalkÃ¼l. Das Heraklit-Framework

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

â€¢

unterstÃ¼tzt die hierarchische Partitionierung eines groÃŸen Systems in Module;

kann technisch einfach, aber inhaltlich flexibel und ausdrucksstark Module zu groÃŸen
Systemen komponieren;

beschreibt diskrete Schritte in groÃŸen Systemen lokal konzentriert in einzelnen
Modulen in frei gewÃ¤hltem Detaillierungsgrad;

stellt alle Arten von Modulen integriert mit den gleichen Konzepten dar, egal ob sie
zur Implementierung vorgesehen sind oder nicht;

reprÃ¤sentiert Daten auf frei gewÃ¤hlter Abstraktionsstufe;

berÃ¼cksichtig DatenabhÃ¤ngigkeiten im Kontrollfluss;

kann von konkreten Daten abstrahieren, um verhaltensgleiche Instanziierungen in
einem Schema zu fassen;

kann Modelle generieren, die skalierbar, systematisch, Ã¤nderbar und erweiterbar sind;

unterstÃ¼tzt den Nachweis, dass ein Modell gewÃ¼nschte Eigenschaften hat.

Mit den beschriebenen technischen Konzepten kÃ¶nnen Aspekte diskreter Systeme modelliert
werden, wie es keine andere Modellierungstechnik ermÃ¶glicht:

Module unterschiedlicher Hierarchiestufen kÃ¶nnen komponiert werden. Beispielsweise kann
in einem Heraklit-Modell ein Modul eine Systemkomponente auf feinster, operationeller

Modellieren mit Heraklit 5

Stufe modellieren; zugleich werden seine benachbarten Module nur mit ihrer Schnittstelle,
ihrem Namen und ggf. Teilen ihrer inneren Struktur reprÃ¤sentiert.

Lebensweltliche und abstrakte Objekte sind gleichrangige Elemente formaler Argumentation.
Heraklit folgt der PrÃ¤dikatenlogik, und fasst lebensweltliche und formale Objekte
gleichrangig als Interpretationen von Termen einer Signatur (eines Alphabetes mit getypten
Symbolen) auf.

Verhaltensmodelle kÃ¶nnen parametrisiert werden. Jede Interpretation der symbolischen
Beschriftungen eines schematischen Heraklit-Moduls generiert ein eigenes Systemmodell.
Beispiel: Ein schematisches Modul beschreibt die Prinzipien der GeschÃ¤ftsprozesse aller
Filialen eines Bekleidungsunternehmens; jede Interpretation beschreibt eine konkrete Filiale.

Der Umfang von Modellen wÃ¤chst linear in der GrÃ¶ÃŸe des modellierten Systems. Das gilt
insbesondere auch bei der Modellierung dynamischen Verhaltens. Erreicht wird dies mit
dem konsequenten Verzicht auf globale Konstruktionen (beispielsweise globale ZustÃ¤nde)
bei der Bildung einzelner AblÃ¤ufe, mit einem lokal beschrÃ¤nkten Kompositionsoperator, etc.

BewÃ¤hrte Verifikationstechniken werden Ã¼bernommen. Petrinetze bieten eine Vielzahl
effizienter rechnergestÃ¼tzter Verifikationstechniken. Die wichtigsten, insbesondere Platz-
und Transitions-Invarianten von Petrinetzen, funktionieren auch auf symbolischer (Signa-
tur-) Ebene und â€“ entsprechend ausdrucksstÃ¤rker â€“ fÃ¼r die einzelnen Interpretationen einer
Signatur. Eine Verifikation auf der Basis des model checking ist fÃ¼r einzelne Interpretationen
einer Signatur mÃ¶glich; dafÃ¼r gibt es effiziente Verfahren. Ein groÃŸes, offenes Feld ist
die kompositionale Verifikation: Eigenschaften eines komponierten Systems werden aus
Eigenschaften der komponierten Module abgeleitet.

Ein einzelner Ablauf kann verteilt sein. In einem Ablauf eines groÃŸen Systems treten
Ereignisse oft unabhÃ¤ngig voneinander ein. Beispiel: In einer Verkaufsfiliale interagieren
die Mitarbeiter unabhÃ¤ngig voneinander mit einzelnen Kunden; sie werden nur gelegentlich
synchronisiert beim Zugang zu knappen Ressourcen, beispielsweise beim Bezahlen an der
Registrierkasse. Viele Frameworks verstehen UnabhÃ¤ngigkeit als â€beliebige Reihenfolgeâ€œ;
das fÃ¼hrt zu exponentiell vielen vermeintlich verschiedenen â€sequentiellenâ€œ AblÃ¤ufen.
Heraklit modelliert UnabhÃ¤ngigkeit von Ereignissen in AblÃ¤ufen explizit. Das fÃ¼hrt zu
einem klaren Begriff von Nichtdeterminismus und zu einem Theorem, nachdem die AblÃ¤ufe
eines komponierten Systems aus den AblÃ¤ufen der Komponenten ableitbar sind.

H e r a k l i t ist intuitiv einfach. Heraklit verwendet intuitiv einfache Basis-Konzepte:
PrÃ¤dikatenlogik ist vielen Anwendern aus anderen Kontexten ohnehin gelÃ¤ufig. Auch
Petrinetze sind weit verbreitet. Der KompositionskalkÃ¼l ist an kleinen Beispielen unmittelbar
einsichtig. Die graphischen Ausdrucksmittel von Petrinetzen und des composition calculus
ergÃ¤nzen sich harmonisch.

6 Peter Fettke, Wolfgang Reisig

3.3 Die drei Dimensionen von Heraklit

Heraklit unterscheidet drei Dimensionen, die drei unterschiedliche, aber integrierte
Aspekte der Modellierung kennzeichnen:

Architektur: Ein Heraklit-Modell besteht aus Modulen. Jedes Modul hat ein beliebig
gestaltetes Inneres; insbesondere ist die Abstraktionsebene der Darstellung frei wÃ¤hlbar. Die
Schnittstelle eines Moduls enthÃ¤lt beliebige gelabelte Elemente. Komposition von Modulen
ist technisch einfach und immer assoziativ. Formale Grundlage dieses Architekturprinzips
ist der KompositionskalkÃ¼l aus [Re19].

Statische Aspekte: FÃ¼r den Umgang mit Daten und Datenstrukturen greift Heraklit auf
abstrakte Datentypen und algebraische Spezifikationen zurÃ¼ck, wie sie sich in der Informatik
von Anfang an bewÃ¤hrt haben und in Spezifikationssprachen wie VDM [Jo91] und Z [Bo01]
seit langem verwendet werden [ST12]. Symbolische Darstellungen (Terme einer Signatur)
werden wie in der PrÃ¤dikatenlogik verwendet. Zu jedem Modul gehÃ¶rt eine Signatur, also
eine Menge von Symbolen fÃ¼r Mengen, Konstanten und Funktionen, aus denen zusammen
mit Variablen dann Terme gebildet werden. Eine Signatur, und damit ihre Terme, kÃ¶nnen in
ganz unterschiedlichen Lebenswelten instanziiert werden.

Dynamische Aspekte: Ein Modul zur Beschreibung von Verhalten enthÃ¤lt in seinem Inneren
ein Petrinetz [Pe77]. Dabei ist jeder Platz des Petrinetzes ein prÃ¤dikatenlogisches PrÃ¤dikat,
jeder Pfeil ist mit einem Term der Signatur des Moduls beschriftet, und jede Transition mit
einer Bedingung. FÃ¼r eine gegebene Instanziierung der Signatur kann die Menge der Objekte,
auf die das PrÃ¤dikat zutrifft, durch den Eintritt eines Ereignisses wachsen oder schrumpfen.
Im Einzelnen wird das durch Terme an den Pfeilen des Petrinetzes beschrieben. Damit
kann Verhalten abstrakt auf schematischer Ebene, aber auch konkret fÃ¼r eine â€gemeinteâ€œ
Instanziierung dargestellt werden.

4 Fallstudie

Gegeben sei ein Restaurant-Betrieb mit mehreren Filialen. Alle Filialen sind nach demselben
Schema aufgebaut und verhalten sich nach demselben Muster; sie unterscheiden sich aber
in einigen Einzelheiten. Modelliert wird das Schema aller Filialen, ein Beispiel einer Filiale,
und ein konkreter Ablauf in dieser Filiale.

4.1 Die Architektur der Filialen

Grundlegendes Konzept der Architektur der Filialen sind Module, wie sie in Abschnitt
3.2 generell fÃ¼r Heraklit-Modelle skizziert wurden. Im Inneren der hier verwendeten
Module liegen Petrinetze in verschiedenen AusprÃ¤gungen. Generell hat ein Modul ğ‘€ zwei

Modellieren mit Heraklit 7

Abb. 1: abstrakte Sicht auf eine Filiale

Abb. 2: eine Filiale, bestehend aus drei Modulen

Schnittstellen, die linke Schnittstelle âˆ— ğ‘€ und die rechte Schnittstelle ğ‘€ âˆ—. Eine Schnittstelle
kann Petrinetz-PlÃ¤tze und -Transitionen enthalten. Graphisch wird ein Modul rechteckig
dargestellt, mit den Elementen der linken Schnittstelle auf dem linken oder oberen Rand des
Rechtecks und den Elementen der rechten Schnittstelle auf dem rechten oder unteren Rand.

Abb. 1 zeigt das Schema fÃ¼r die Filialen in grÃ¶ÃŸtmÃ¶glicher Abstraktion als ein Heraklit-
Modul, branch. Modelliert werden zwei AktivitÃ¤ten der Restaurant-GÃ¤ste: das Betreten und
das Verlassen einer Filiale; technisch als Petrinetz-Transitionen in âˆ—branch und branchâˆ— mit
den Beschriftungen enter bzw. leave.

Abb. 2 zeigt, dass jede Filiale drei Komponenten hat: den Eingang, den Gastraum und
die KÃ¼che. Diese Komponenten werden wiederum als Module modelliert. Die linke
Schnittstelle des Eingangs ist leer, die rechte Schnittstelle enthÃ¤lt zwei Petrinetz-PlÃ¤tze.
Die Beschriftungen dieser beiden PlÃ¤tze stimmen mit den Beschriftungen der PlÃ¤tze der
linken Schnittstelle des Gastraums Ã¼berein; gleich beschriftete PlÃ¤tze werden spÃ¤ter beim
Komponieren der beiden Module miteinander verschmolzen. Die beiden Transitionen der
Schnittstellen des branch-Moduls liegen auch in den Schnittstellen des Gastraums. Die
rechte Schnittstelle des Gastraums enthÃ¤lt einen Platz und eine Transition; entsprechend
beschriftete Elemente enthÃ¤lt die linke Schnittstelle des KÃ¼chen-Moduls.

Die Beschriftungen der Schnittstellen-Elemente weisen auf das Verhalten und die Funktiona-
litÃ¤t der Module hin: am Eingang wird jedem Gast ein freier Tisch zugewiesen. Im Gastraum
kann der Gast seine Bestellung aufgeben, spÃ¤ter das bestellte Gericht entgegennehmen und
an seinem Tisch verspeisen.

4.2 Statische Komponenten der Filialen

In jeder Filiale spielen vier Mengen eine zentrale Rolle: die Tische, die GÃ¤ste, die Speisekarte
mit ihren einzelnen EintrÃ¤gen und die zubereiteten Gerichte. In jeder Filiale kann jede dieser

8 Peter Fettke, Wolfgang Reisig

Abb. 3: Signatur Î£0

Abb. 4: Î£-Struktur ğ‘†0

Mengen jeweils aus anderen Elementen bestehen. Beispielsweise arbeitet eine kleine Filiale
mit weniger Tischen und einer anderen Auswahl auf der Speisekarte als eine groÃŸe Filiale.

Um dennoch fÃ¼r alle Filialen die AblÃ¤ufe gleich zu formulieren, verwenden wir eine Signatur,
Î£0, die Abb. 3 zeigt. Sie enthÃ¤lt die vier Symbole Clients, Tables, Menu, Meal items fÃ¼r die
vier oben beschriebenen Mengen, dazu zwei Symbole (Orders und Meals) fÃ¼r Teilmengen
und zwei Symbole ( ğ‘“ und ğ‘”) fÃ¼r Funktionen. Orders steht fÃ¼r Bestellungen (eine Bestellung
ist eine Teilmenge der EintrÃ¤ge in die Speisekarte), und Meals steht fÃ¼r Gerichte (ein
Gericht ist eine Teilmenge zubereiteter Speisen). Die Funktion ğ‘“ ordnet jeder Speise den
entsprechenden Eintrag in der Speisekarte zu; ğ‘” ordnet jedem Gericht seine Bestellung zu.

In Abschnitt 3.2 wurde diskutiert, wie eine Signatur auf vielfÃ¤ltige Weise instanziiert
werden kann. Jede konkrete Filiale ist durch eine solche Instanziierung der Signatur Î£0
charakterisiert. In der Fallstudie diskutieren wir die Instanziierung ğ‘†0 der Abb. 4.

4.3 Das Verhalten der drei Module auf Schema-Ebene

ZunÃ¤chst modellieren wir das Verhalten jedes einzelnen der drei Module aus Abb. 2. Abb. 5
zeigt das Verhalten der einzelnen Module auf der Schema-Ebene, also auf Basis der Signatur
Î£0, und nicht einer einzelnen Instanziierung. Als mathematisches Konzept reprÃ¤sentiert ein
Platz ein PrÃ¤dikat, das auf eine Menge von Objekten zutrifft. Diese Menge kann durch den
Eintritt von Transitionen wachsen und schrumpfen.

Das entry-Modul in Abb. 5 verwaltet die Tische. ZunÃ¤chst stellt sich hier die Frage nach einer
angemessenen Anfangsmarkierung: FÃ¼r eine gegebene Instanziierung, also eine konkrete
Filiale, enthÃ¤lt der Platz free tables anfangs alle Tische als Marken. Im Beispiel der Struktur
ğ‘†0 aus Abb. 4 sind das die vier Marken ğ‘¡1, ğ‘¡2, ğ‘¡3, ğ‘¡4. Auf der schematischen Ebene kennen
wir nur das Symbol Tables, fÃ¼r das jede Instanziierung eine Belegung mit einer Menge von
Tischen frei wÃ¤hlen kann. Die zunÃ¤chst naheliegende Idee, den Platz free tables anfangs
mit dem Symbol Tables zu beschriften, greift allerdings zu kurz: Bei einer Instanziierung
des Symbols Tables mit einer Menge, beispielsweise {ğ‘¡1, ğ‘¡2, ğ‘¡3, ğ‘¡4}, wÃ¼rde anfangs diese
Menge als eine einzige Marke entstehen. Wir wollen aber die vier Elemente dieser Menge
als einzelne Marken. Das wird mit elm(Tables) notiert.

Modellieren mit Heraklit 9

Abb. 5: Verhalten der Module auf der Schema-Ebene

Mathematisch steckt dahinter, dass ein Platz ein PrÃ¤dikat darstellt, das aktuell auf die
Elemente im Platz zutrifft. Der Platz free tables mit der Inschrift elm(Tables) steht also fÃ¼r
den logischen Ausdruck:

âˆ€ğ‘¡ âˆˆ Tables : free tables(t)
(1)
Die Instanziierung ğ‘†0 erzeugt damit in der Anfangsmarkierung den logischen Ausdruck
â€âˆ€ğ‘¡ âˆˆ {ğ‘¡1, ğ‘¡2, ğ‘¡3, ğ‘¡4} : free tables(t)â€œ. Damit liegen auf dem Platz free tables anfangs die vier
Marken ğ‘¡1, ğ‘¡2, ğ‘¡3, ğ‘¡4.

In einer gegebenen Instanziierung ğ‘† kann im Gastraum-Modul die Transition enter eintreten,
sobald eine Marke auf offered tables vorliegt, indem die Variable ğ‘¡ mit dieser Marke belegt
wird. Die Belegung der Variablen ğ‘ kann frei gewÃ¤hlt werden aus der Menge, mit der die
Instanziierung ğ‘† das Mengensymbol Clients instanziiert. Die Idee dahinter: Das Modul kann
mit einem anderen Modul aus seiner Umgebung komponiert werden, indem die Belegung
von ğ‘ mit einem Gast einen inhaltlichen Sinn hat.

Bei der Transition select ist das VerhÃ¤ltnis zwischen dem Symbol Menu und der Variablen ğ‘‹
interessant: Eine Instanziierung ğ‘† des Gastraum-Moduls legt Menu als eine Speisekarte, also
eine Menge einzelner EintrÃ¤ge fest. Hingegen wird beim Eintreten von select die Variable ğ‘‹
jedes mal neu belegt. Die Bedingung ğ‘‹ âŠ† Menu der Inschrift von select garantiert, dass die
Belegung von ğ‘‹ (â€Bestellungâ€œ) nur EintrÃ¤ge enthÃ¤lt, die in der Speisekarte aufgefÃ¼hrt sind.

10 Peter Fettke, Wolfgang Reisig

Eine order besteht aus einem Tisch und einer Bestellung. Jede Marke auf dem Platz waiting
besteht aus einem Kunden ğ‘, seinem Tisch ğ‘¡, und seiner Bestellung ğ‘‹. Mit der Transition
hand over wird dem Gast das bestellte Gericht ausgehÃ¤ndigt.

Im kitchen-Modul zerlegt die Transition unfold jede eingehende Bestellung in ihre einzelnen
EintrÃ¤ge, formuliert mit Hilfe des elm-Operators, analog zur Verwendung im entry-Modul.
FÃ¼r jeden dieser EintrÃ¤ge ğ‘“ (ğ‘¦), also jede Benennung einer Speise, wird die Speise ğ‘¦ gekocht
(Transition cook). Entsprechend einer vorliegenden Bestellung auf dem Platz pending orders
werden dann Speisen als ğ‘Œ zusammengestellt und als Gericht an den Kunden Ã¼bergeben.

4.4 Die Instanziierung ğ‘†0 und ihre Verhalten

Abb. 6 zeigt ein Modul, ğ‘†0, das aus den Modulen von Abb. 5 in zwei Schritten entsteht:
erstens werden die drei Module aus Abb. 5 zu einem einzigen Modul, System ğ‘†0, komponiert;
zweitens wird die Signatur Î£0 von Abb. 5 mit der Struktur ğ‘†0 instanziiert. Insbesondere
enthÃ¤lt der Platz free tables jetzt vier Marken, und der Platz menu drei Marken.

In der Instanziierung ğ‘†0 kann man nun den Eintritt einzelner Transitionen dokumentieren.
Im Anfangszustand kann beispielsweise die Transition offer table mit der Belegung ğ‘¡ = ğ‘¡1
eintreten und dabei die Marke ğ‘¡1 auf den Platz offered tables verschieben. Danach kann enter
mit der Belegung ğ‘¡ = ğ‘¡1 und einem frei gewÃ¤hlten Kunden fÃ¼r ğ‘ eintreten. UnabhÃ¤ngig davon
kann offer table auch mit ğ‘¡ = ğ‘¡2 eintreten, etc. So kann beispielsweise ein Ablauf entstehen, in
dem der Gast Alice aus der Speisekarte eine Bestellung fÃ¼r Reis und Fleisch zusammenstellt,
fÃ¼r die in der KÃ¼che die entsprechenden Speisen gekocht und an Alice Ã¼bergeben werden.
Daneben kann Bob ein Gericht mit Reis und Salat bestellen und ausgehÃ¤ndigt bekommen.
Solches einzelnes Verhalten wird Ã¼blicherweise als Sequenz aus globalen ZustÃ¤nden und
eintretenden Transitionen beschrieben, beginnend mit der Anfangsmarkierung.

Heraklit modelliert ein einzelnes Verhalten als verteilten Ablauf (vgl. Abschnitt 3.3);
formal gefasst als ein Modul. Damit kÃ¶nnen verteilte AblÃ¤ufe einfach komponiert werden.
Am laufenden Beispiel wird zudem deutlich, dass verteilte AblÃ¤ufe Einzelheiten der
ZusammenhÃ¤nge innerhalb eines Ablaufs sehr viel expliziter zeigen als es mit sequentiellen
AblÃ¤ufen mÃ¶glich ist.

Abb. 7 zeigt einen verteilten Ablauf, ğ´0, des Systems ğ‘†0 in Abb. 6. Zur besseren Lesbarkeit
komponieren wir diesen Ablauf aus drei Teilen: Das Modul Anfang von ğ´0 in Abb. 8
besteht aus zwei StrÃ¤ngen. Der obere beginnt mit dem Eintritt der Transition offer table aus
Abb. 6 im Modus ğ‘¡ = ğ‘¡1. Dadurch enthÃ¤lt der Platz offered tables die Marke ğ‘¡1. Diese Marke
wiederum aktiviert die Transition enter mit der Belegung ğ‘¡ = ğ‘¡1, und einer frei wÃ¤hlbaren
Belegung von ğ‘. Der Ablauf ğ´0 wÃ¤hlt ğ‘ = Alice und erzeugt damit die Marke (Alice, ğ‘¡1)
auf dem Platz clients ready to order. UnabhÃ¤ngig von diesem Strang beschreibt der untere
Strang Schritte der Marke ğ‘¡2 und das Entstehen der Marke (Bob, ğ‘¡2) auf dem Platz clients
ready to order.

Modellieren mit Heraklit 11

Abb. 6: System ğ‘†0

Das Modul Mitte von ğ´0 in Abb. 10 ergÃ¤nzt in seiner linken Schnittstelle die rechte
Schnittstelle von Anfang von ğ´0 um den Platz menu mit der Marke {rice, meat, salad}.
Diese Marke reprÃ¤sentiert das einzige verfÃ¼gbare Exemplar der Speisekarte. Alice und
Bob schauen sie nacheinander an, und erzeugen jeweils eine order, (ğ‘¡1, {ğ‘Ÿğ‘–ğ‘ğ‘’, ğ‘šğ‘’ğ‘ğ‘¡}) und
(ğ‘¡2, {rice, salad}). An der Transition unfold beginnt im Modul System ğ‘†0 ein Pfeil mit der
Inschrift elm(ğ‘‹). Mit ğ‘¡ = ğ‘¡1 und ğ‘‹ = {rice, meat} zerlegt elm(ğ‘‹) im Modul den Anteil
{rice, meat} der Marke (ğ‘¡1, {ğ‘Ÿğ‘–ğ‘ğ‘’, ğ‘šğ‘’ğ‘ğ‘¡}) in die Bestandteile rice und meat, analog zur
Inschrift des Platzes free tables im Schema von Abb. 5. Die entsprechenden Speisen rice
und meat werden einzeln gekocht. Mit der Bestellung des Tisches ğ‘¡2 wird entsprechend
verfahren. In beiden FÃ¤llen wird rice bestellt. Da die Bestellungen nebenlÃ¤ufig vorliegen,
kÃ¶nnen die beiden gekochten rice-Portionen nicht eindeutig den Bestellungen zugeordnet
werden. Im Ablauf ğ´0 werden sie vertauscht.

Das Modul Ende von Ablauf ğ´0 in Abb. 9 beendet nun die beiden Ablauf-Teile in offensicht-
licher Weise. Die Komposition Anfang von Ablauf ğ´0 â€¢ Mitte von ğ´0 â€¢ Ende von Ablauf ğ´0
der drei Module liefert genau das Modul Ablauf Ablauf ğ´0 in Abb. 7.

12 Peter Fettke, Wolfgang Reisig

Abb. 7: Ablauf ğ´0

Abb. 8: AnfangsstÃ¼ck des Ablaufs ğ´0

Abb. 9: EndstÃ¼ck des Ablaufs ğ´0

5 Bezug von Heraklit zu anderen Modellierungsinfrastrukturen

Ein Framework zur Modellierung beschreibt wesentliche Konzepte zur Modellierung. Darauf
aufbauend bietet eine Modellierungsinfrastruktur korrespondierende Modelle, Methoden,
Techniken und Werkzeugen. Im Vergleich mit anderen Disziplinen wird generell in der
Praxis der (Wirtschafts-) Informatik wenig mit Modellen gearbeitet. Es sind zahlreiche
Frameworks vorgeschlagen worden, aber keines hat sich bisher wirklich durchgesetzt.

Ein Beispiel sind Diagramme der Unified Modeling Language (UML, [Ob17]) fÃ¼r Software-
Systeme. Die verschiedenen Diagrammtypen veranschaulichen einige Aspekte eines Soft-
waresystems, aber unterstÃ¼tzen Analysefragen nur wenig. Ein anderes Beispiel sind die in
der Wirtschaftsinformatik beliebten Diagramme der Business Process Model and Notation
(BPMN, [Ob14]) oder ereignisgesteuerte ProzeÃŸketten (EPK, [KNS92]). Solche Diagram-
me beschrÃ¤nken sich auf die Identifikation abstrakter AktivitÃ¤ten und die Darstellung des
Kontrollflusses. Sie unterstÃ¼tzen Abstraktion und Komposition, helfen aber wenig beim
Umgang mit konkreten oder abstrakten Daten und GegenstÃ¤nden bei der Beschreibung des

Modellieren mit Heraklit 13

Abb. 10: MittelstÃ¼ck des Ablaufs ğ´0

Verhaltens und beim Nachweis der Korrektheit von Verhaltensmodellen gegenÃ¼ber einer
Spezifikation. Die Architektur integrierter Informationssysteme (ARIS, [Sc01]) erlaubt zwar
eine integrierte Beschreibung von Daten, Funktionen und AblÃ¤ufen. Allerdings fehlen leis-
tungsfÃ¤hige Modularisierungskonzepte. Auch sind ARIS-Modelle nur bedingt formalisiert.
Weit verbreitet sind Petrinetze; in ihrer klassischen Form modellieren sie allerdings lediglich
verteilten Kontrollfluss. Zahlreiche Varianten und Verallgemeinerungen (insbesondere
Coloured Petri Nets (CPN, [JK09])) integrieren konkrete Daten (in der Sprechweise von
Heraklit: einzelne Strukturen). Typische VorschlÃ¤ge fÃ¼r hierarchische Petrinetze ersetzen
einzelne Transition durch ganze Netze. Statecharts [Ha87] verwenden eigenstÃ¤ndige Modul-
und Kompositionskonzepte; dabei werden gleich gelablete ÃœbergÃ¤nge endlicher Automaten
verschmolzen. [Gr20] schlagen die statecart-basierte Sprache Gamma vor und diskutieren
eine Vielzahl von Kompositionsoperatoren.

SchlieÃŸlich gibt es noch eine Reihe von Frameworks, die letztlich als Strukturen einer
Signatur, oder als eine Signatur auffassbar sind. Dazu gehÃ¶ren Abstract State Machines
(ASM, [Gu00]), event-B [Ab05] und Z [Sp92]. Andere Frameworks orientieren sich an der
PrÃ¤dikatenlogik, beispielsweise TLA [La02], FOCUS [Br97, BS01] und Aloy [Ja87].

Alle diese Frameworks werden zur Analyse und Simulation von Softwarewerkzeugen

14 Peter Fettke, Wolfgang Reisig

unterstÃ¼tzt und wurden in grÃ¶ÃŸeren Software-Entwicklungsprojekten eingesetzt. Allerdings
hat sich keine wirklich durchgesetzt. Das liegt vorwiegend daran, dass bisher aus Modellen
nicht besonders viel Nutzen gezogen werden kann. Derzeitige Frameworks fokussieren
jeweils nur spezielle Bereiche eines Systems. FÃ¼r kleine und mittelgroÃŸe Systeme sind die
genannten Frameworks mehr oder weniger hilfreich. Aber da, wo man es besonders braucht,
bei wirklich groÃŸen Systemen, fehlen systematische, strukturierende und abstrahierende
Prinzipien zur Modellierung. Komplexe Systeme werden bestenfalls in Teilen modelliert,
oft mit ganz unterschiedlichen Frameworks, die nur mÃ¼hsam zusammenpassen. Es gibt
keine umfassenden Modellsichten, in die dann ganz unterschiedliche Teilmodelle integriert
werden kÃ¶nnen.

Im Vergleich mit den genannten Frameworks ist Heraklit breiter aufgestellt, indem
Petrinetze, Konzepte algebraischer Spezifikation, und ein universeller Kompositionsoperator
miteinander integriert sind. Keine der erwÃ¤hnten Frameworks erreicht die Ausdruckskraft
von Heraklit. Mit keiner der erwÃ¤hnten Frameworks kÃ¶nnen alle Aspekte der Fallstudie
des vierten Abschnitts modelliert werden.

Mit dem in der Logik grundlegenden und in der algebraischen Spezifikation bewÃ¤hrten
Konzept einer Signatur und ihren unterschiedlichen Instanziierungen beschreibt Heraklit
auch dynamisches Verhalten, sowohl auf der schematischen Ebene als auch fÃ¼r einzelne
Instanziierungen. Das war auch die Intention von PrÃ¤dikat-Transitionsnetzen [GL81].

Heraklit legt Wert auf Ausdrucksmittel fÃ¼r eine integrierte Modellierung lebenswelt-
licher und formaler Sachverhalte. Dazu nutzt Heraklit die wissenschaftstheoretischen
Diskussionen um den Bezug zwischen der Welt und ihrer formalen Fassung, seit Aristoteles,
die dann in die PrÃ¤dikatenlogik eingeflossen ist [Su57]. Heraklit schlÃ¤gt vor, dynamische
Aspekte in die PrÃ¤dikatenlogik einzubauen.

Wie bereits in der Einleitung erwÃ¤hnt, hat DÄ³kstra vorgeschlagen, informelle und formale
Argumentationen strikt zu trennen und zwischen ihnen eine â€Firewallâ€œ zu errichten. Diese
Mauer ist nicht hilfreich zum VerstÃ¤ndnis Informatik-basierter Systeme. Vielmehr braucht
es eine BrÃ¼cke, um zwischen der informellen Lebenswelt der Anwendung und der formalen
Welt der Technik zu vermitteln. Heraklit bietet hierzu ein passendes Framework.

6 Ausblick

Die formalen Grundlagen und die Prinzipien des Einsatzes von Heraklit liegen vor;
zahlreiche Fallstudien zeigen den Nutzen des umfassenden Ansatzes von Heraklit.
FÃ¼r die Verwendung im industriellen MaÃŸstab und als bessere Alternative zu derzeit
verwendeten Frameworks zur Modellierung fehlen insbesondere noch Softwarewerkzeuge
zur UnterstÃ¼tzung des Entwurfs groÃŸer Modelle, und auf Heraklit zugeschnittene
Analyseverfahren. FÃ¼r spezielle Anwendungsbereiche werden im Lauf der Zeit AusprÃ¤gungen
mit verfeinerten Konzepten gebildet. In einigen Anwendungen ist auch die automatische
Erzeugung von Programmcode fÃ¼r einige Module wÃ¼nschenswert.

Modellieren mit Heraklit 15

Literaturverzeichnis

[Ab05] Abrial, J.-R.: The B-Book â€“ Assigning Programs to Meanings. Cambridge University, 2005.

[Bo01] Bowen, Jonathan P: Z: A formal specification notation. In: Software specification methods,

S. 3â€“19. Springer, 2001.

[Br97] Broy, Manfred: Compositional Refinement of Interactive Systems. Journal of the ACM,

44(6):850â€“891, 1997.

[BS01] Broy, Manfred; Stolen, Ketil: Specification and Development of Interactive Systems: Focus

on Streams, Interfaces, and Refinement. Springer, 2001.

[Di89] DÄ³kstra, E. W.: Reply to comments. Commun. ACM, 32(12):1414, 1989.

[FR21a] Fettke, Peter; Reisig, Wolfgang: Handbook of Heraklit. Heraklit working paper, v1.1,

September 20, 2021, http://www.heraklit.org, 2021.

[FR21b] Fettke, Peter; Reisig, Wolfgang: Modelling Service-Oriented Systems and Cloud Services
with Heraklit. In (Zirpins, Christian; Paraskakis, Iraklis; Andrikopoulos, Vasilios; Kratzke,
Nane; Pahl, Claus; El Ioini, Nabil; Andreou, Andreas S.; Feuerlicht, George; Lamersdorf,
Winfried; Ortiz, Guadalupe; Van den Heuvel, Willem-Jan; Soldani, Jacopo; Villari, Massimo;
Casale, Giuliano; Plebani, Pierluigi, Hrsg.): Advances in Service-Oriented and Cloud
Computing. Springer International Publishing, Cham, S. 77â€“89, 2021.

[GL81] Genrich, Hartmann J.; Lautenbach, Kurt: System modelling with high-level Petri nets.

Theoretical Computer Science, 13:109â€“135, 1981.

[Gr20] Graics, Bence; MolnÃ¡r, Vince; VÃ¶rÃ¶s, AndrÃ¡s; Majzik, IstvÃ¡n; VarrÃ³, DÃ¡niel: Mixed-Semantics
Composition of Statecharts for the Component-Based Design of Reactive Systems. Softwware
and Systems Modeling, 19(6):1483â€“1517, 2020.

[Gu00] Gurevich, Yuri: Sequential abstract-state machines capture sequential algorithms. ACM

Transactions on Computational Logic, 1:77â€“111, 2000.

[Ha87] Harel, David: Statecharts: A Visual Formalism for Complex Systems. Science of Computer

Programming, 8(3):231â€“274, 1987.

[Ja87]

Jackson, Daniel: Alloy: A Language and Tool for Exploring Software Designs. Communica-
tions of the ACM, 62(9):66â€“76, 1987.

[JK09] Jensen, Kurt; Kristensen, Lars M.: Coloured Petri Nets: Modelling and Validation of

Concurrent Systems. Springer, 2009.

[Jo91]

Jones, Clifford B.: Systematic software development using VDM. Prentice Hall, 2. Auflage,
1991.

[KNS92] Keller, Gerhard; NÃ¼ttgens, Markus; Scheer, August-Wilhelm: Semantische ProzeÃŸmodel-
lierung auf der Grundlage â€Ereignisgesteuerter ProzeÃŸketten (EPK)â€œ. Bericht 89, VerÃ¶ffent-
lichungen des Instituts fÃ¼r Wirtschaftsinformatik (IWi) an der UniversitÃ¤t des Saarlandes,
1992.

[La02] Lamport, Leslie: Specifying Systems: The TLA+ Language and Tools for Hardware and

Software Engineers. Adison-Wesley, 2002.

16 Peter Fettke, Wolfgang Reisig

[Ob14] Object Management Group: Business Process Model and Notation (BPMN): Version 2.0.2.

Bericht formal/2013-12-09, Object Management Group, 2014.

[Ob17] Object Management Group: OMG Unified Modeling Language (OMG UML): Version 2.5.1.

Bericht formal/2017-12-05, Object Management Group, 2017.

[Pe77] Petri, C. A.: Non-Sequential Processes. Bericht ISF-77-5, Gesellschaft fÃ¼r Mathematik und

Datenverarbeitung, St. Augustin, Federal Republic of Germany, 1977.

[Re19] Reisig, Wolfgang: Associative composition of components with double-sided interfaces.

Acta Informatica, 56(3):229â€“253, 2019.

[Sc01] Scheer, August-Wilhelm: ARIS: Modellierungsmethoden, Metamodelle, Anwendungen.

Springer, 4. Auflage, 2001.

[Sp92] Spivey, John Michael: The Z Notation: A reference manual. Prentice Hall, 2. Auflage, 1992.

[ST12] Sanella, Donald; Tarlecki, Andrzej: Foundations of Algebraic Specification and Formal

Software Development. Springer, 2012.

[Su57] Suppes, Patrick: Introduction to Logic. Van Nostrand Reinhold, 1957.

