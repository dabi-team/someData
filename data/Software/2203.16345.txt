2
2
0
2

y
a
M
7

]
L
P
.
s
c
[

3
v
5
4
3
6
1
.
3
0
2
2
:
v
i
X
r
a

An Algebraic Framework for Structured Epidemic Modeling

Sophie Libkind, Andrew Baas, Micah Halter, Evan Patterson, and James Fairbanks

May 10, 2022

Abstract

Pandemic management requires that scientists rapidly formulate and analyze epidemiological models
in order to forecast the spread of disease and the eﬀects of mitigation strategies. Scientists must modify
existing models and create novel ones in light of new biological data and policy changes such as social
distancing and vaccination. Traditional scientiﬁc modeling workﬂows detach the structure of a model—its
submodels and their interactions—from its implementation in software. Consequently, incorporating local
changes to model components may require global edits to the code-base through a manual, time-intensive,
and error-prone process. We propose a compositional modeling framework that uses high-level algebraic
structures to capture domain-speciﬁc scientiﬁc knowledge and bridge the gap between how scientists
think about models and the code that implements them. These algebraic structures, grounded in applied
category theory, simplify and expedite modeling tasks such as model speciﬁcation, stratiﬁcation, analysis,
and calibration. With their structure made explicit, models also become easier to communicate, criticize,
and reﬁne in light of stakeholder feedback.

1 Introduction

The basic principles of epidemics originate with the Kermack-McKendrick model, which established the
paradigm of compartmental models to predict how an infectious disease spreads through a population over
time. Yet, the COVID-19 pandemic has created a pressing need to expedite the development of new and
customized epidemiological models. For instance, the Institute for Health Metrics and Evaluation (IHME), an
independent global health research center at the University of Washington, has been collecting data, running
simulations, and publishing ﬁndings throughout the COVID-19 pandemic. In April of 2020, just two months
after the ﬁrst conﬁrmed US cases of COVID-19, the IHME was comparing diﬀerent epidemiological models
according to the accuracy of their forecasts [10]. The models were summarized in natural language and
compared mathematically via model outcomes derived by simulation. Such summaries do not permit a
precise comparison of model structure, which is essential to understanding how modeling assumptions aﬀect
model outcomes. Inadequate model representations limit the speed and precision with which organizations
like the IHME can respond to emerging pandemics.

We present and exemplify an approach to developing scientiﬁc modeling software in which the high-
level structure of a model is visible and manipulable in its software implementation. Mathematical models
of scientiﬁc systems involve rich, structured knowledge that scientists leverage to communicate, iterate,
and validate their models. However, this knowledge is obscured from computer systems when models are
implemented using low-level computational primitives rather than by software tools that mirror the scientiﬁc
concepts. Our approach has two phases: (1) formalizing the mathematics of high-level structures that
recur in scientiﬁc models and (2) implementing these mathematical formalisms directly in software. Our
approach contrasts with the traditional implementation of scientiﬁc models, because it treats the structure
of scientiﬁc models as primary which in turn prioritizes the expertise of domain scientists and modelers
during the development, adjustment, and analysis of models. As an example of our approach, we formalize
the speciﬁcation of a compositional or stratiﬁed epidemiological model using the mathematics of applied
category theory, and we demonstrate its implementation in software.1

1Code that demonstrates our software system and reproduces the examples in this manuscript is available on GitHub at

https://github.com/AlgebraicJulia/Structured-Epidemic-Modeling/.

1

 
 
 
 
 
 
Many aspects of model structure can be formalized as algebraic structure using mathematics from cate-
gory theory. For example, we present a generalized addition and a generalized product for composing models.
These operators are grounded in category theoretic concepts including copresheaves, structured cospans, and
pullbacks. These concepts underlie our software design which automates the implementation of these oper-
ations. When specifying a composite model, a sharp distinction is drawn between the syntax of composition
dictating how the subsystems interact and the semantics of composition assigning concrete mathematical
models to the subsystems. This separation promotes generality and ﬂexibility in modeling as the same syn-
tax can have several diﬀerent semantics. In this paper, we will see that Petri nets with mass action kinetics
and, more generally, ordinary diﬀerential and delay diﬀerential equations, can all serve as semantics for the
same syntax. Furthermore, translations between these and other types of models can be formalized using
concepts from category theory. Unlike the textual syntax of conventional programming languages and data
formats, our syntax is algebraic and diagrammatic in nature. This language makes the informal diagrams
used by scientists and engineers mathematically rigorous and directly computable. Furthermore, the syntax
itself becomes a combinatorial data structure that can be algorithmically manipulated. Undirected wiring
diagrams, which form an algebraic structure called an operad, are the main syntax treated in this paper,
although other syntaxes, such as directed wiring diagrams, can be similarly applied [23], [16].

Although all scientists intuitively understand that complex models are assembled from simpler ones,
such decompositions are rarely made explicit in modeling practice. Our operadic approach to compositional
modeling makes the modular structure transparent and rigorous. As a result, experts in distinct ﬁelds
can develop submodels in parallel, particular submodels can easily be replaced without aﬀecting others,
and programming errors are reduced because the software handles the bookkeeping needed to assemble the
composite model. All of this serves to accelerate the modeling process, which is critical in emerging scenarios
where existing models must be rapidly adapted to new scientiﬁc contexts.

Because programming simulators is labor intensive and error-prone, many existing software systems
present higher-level interfaces for modelers to formulate and analyze models. They are often speciﬁc to a
particular scientiﬁc domain or theoretical class of models. For example, Stan is used for analyzing data with
probabilistic models [7], Kappa for rule-based modeling of biochemical systems [6], Copasi for simulating
mechanistic models in systems biology [12], pomp for partially observed Markov processes [14], NetLogo for
agent-based modeling [24], and Berkeley Madonna for the graphical construction of complex mathematical
models. When several scientiﬁc tools evolve in the same domain, they may undergo a process of standard-
ization leading to new interchange formats, such as the Systems Biology Markup Language [13], that can be
consumed by many tools. While such tools and formats might enable rapid model formulation and analysis
at a certain scale, they often lack features like hierarchical composition needed to reliably specify large-scale
models. For example, in the absence of other organizing abstractions, Petri net models rapidly devolve into
an incomprehensible web of criss-crossing transitions. Existing software is also typically bespoke, designed
for a speciﬁc ﬁeld and not around common abstractions that recur throughout mathematics. Building soft-
ware around such abstractions facilitates the construction of models that cross disciplinary boundaries while
allowing for greater generality and code reuse.

Our software system encompasses a range of tasks in the scientiﬁc modeling workﬂow including model
formulation, simulation, analysis, and comparison. The paper is organized along these lines. Section 2
presents the compositional approach to model speciﬁcation, explaining how undirected wiring diagrams are
a syntax for composing open Petri nets as well as more general diﬀerential equation models. Subsection 2.4
highlights the computational and theoretical advantages of this approach. Section 3 demonstrates how maps
between Petri nets can encode domain-speciﬁc type systems, which are useful for building stratiﬁed models
and verifying that models do not violate established theory. Finally, Section 4 discusses calibration and
sensitivity analysis via interoperation with other tools, emphasizing visualization and the tight feedback
loop enabled by high-level model speciﬁcations.

2 Compositional methods of model speciﬁcation

2.1 Structured multicospans of Petri nets for compartmental models

In this section, we exemplify the categorical approach to compositional modeling by giving the three compo-
nents of such a framework: (1) a model semantics, for specifying concrete mathematical models of systems,

2

Figure 1: (a) An informal visualization of a compartmental SIR model. The horizontal arrows represent
processes in which susceptible people become infected and infected people recover. The single feedback arrow
indicates that the rate of infection depends on the size of the infected population. (b) The formalization
It has three species (depicted as labeled
of the comparmental model in (a) as a whole-grain Petri net.
blue circles) representing a susceptible, infected, and recovered population and two transitions (depicted
as orange squares) representing an infection process and a recovery process. The transition representing
infection has two input arcs and two output arcs. These indicate that infection takes one susceptible and
one infected individual and returns two infected individuals. The transition representing recovery has one
input arc and one output arc. These indicate that recovery takes one infected individual and returns one
recovered individual. (c) The diagram of ﬁnite sets and functions which deﬁne a whole-grain Petri net. S
is a ﬁnite set of species, T is a ﬁnite set of transitions, I is a ﬁnite set of input arcs, and O is a ﬁnite set of
output arcs. (d) The database view of the whole-grain Petri net depicted in (b). The database view gives
a table for each ﬁnite set in the diagram. Table rows represent the elements of the set and when applicable
table columns represent the functions out of the set.

(2) a composition syntax, for specifying interactions between systems, and (3) a composition rule, for speci-
fying how to compose chosen concrete models according to a given syntactic term. We emphasize that the
composition syntax is a logical syntax, in that the composition syntax axiomatizes the rules of well-formed
expressions that deﬁne a composition of models. In contrast, the model semantics is a denotational semantics
which assigns meaning to the models in a composition. We do not mean semantics in the sense of observed,
real-world phenomena and such an interpretation is outside of the scope of this work.

For the model semantics, we use Petri nets in a form called whole-grain Petri nets [15], deﬁned by
the diagram of ﬁnite sets and functions shown in Figure 1(c). Thus, a whole-grain Petri net consists of a
ﬁnite set of places or species S, a ﬁnite set of transitions T , and spans S is
T
←−
deﬁning the input and output arcs between states and transitions. A span is similar to a “multirelation”
in that pairs of elements may be related with multiplicity. Multiplicity is important for transitions that
input or output multiple tokens of the same species, such as an infection transition that yields two infected
individuals as output. As an example, consider the SIR model in Figure 1(b). This Petri net has three
places S =
corresponding to susceptible, infected, and recovered populations and two transitions
corresponding to infection and recovery. The infection transition is the target of two input arcs — one whose

T and S os
←−

S, I, R
{

O ot
−→

I it
−→

}

3

<latexit sha1_base64="5XuZvZUWaaySEa22IKpYUgNPjmY=">AAADSXicdZLdjtJAFMen4MeKH8vqpTcTyKIXC7SsWY0JcRV3IxtQDCyQ0IZMpwNM6BczU7tAeBSfxkv1AXwM74zeOKU1YRf3JO3595zfzJmeOaZvUy5U9YeSSt+4eev2zp3M3Xv3H+xm9x52uRcwTM6xZ3usbyJObOqSc0GFTfo+I8gxbdIzp7Uo3/tEGKee2xFznxgOGrt0RDESMjTcU4724UQIn78sl2elgEq2hHy//GpW7S1e8/e1C7PZDsNG7axTt1XeW5zwJg1pt3ZmNU552Hh7wuvTKe23JUfDC8m1Yq7Om6eJ70a+mXxL39WsjD7QTTKm7lLQ6QJbqwyEBdiGui5FHRYK8EOsC7Aj3zpizAsHI+Y51UpRO4DCq2rFygHMUZ4zrgEOY0DknmwThxtbePx6It7DE7KITlzr32l1Y5jNqyV1bXBbaInIg8Raw+wf3fJw4BBXYBtxPtBUXxhLxATFNlll9IATH+EpGpOBlC5yCDeW6wtewX0ZseDIY/JxBVxHN1cskcP53DEl6SAx4VdzUfB/uUEgRi+MJXX9QBAXx4VGgS1/HUbTAi3KCBb2XAqEGZVnhXiCGMJCztSlKlFnitFFbgZn64FaZWS3tKu92RbdSkk7Kj37WMkfv0n6tgMegxx4CjTwHByDd6AFzgFWPitflG/K99TX1M/Ur9TvGE0pyZpH4JKl038BgnP/jw==</latexit>SIOTisitosot321211𝐢𝐭𝐢𝐬𝐈𝐧𝐩𝐮𝐭311𝐨𝐭𝐨𝐬𝐎𝐮𝐭𝐩𝐮𝐭321𝐒𝐭𝐚𝐭𝐞1𝐓𝐫𝐚𝐧𝐬𝐢𝐭𝐢𝐨𝐧c)d)<latexit sha1_base64="5XuZvZUWaaySEa22IKpYUgNPjmY=">AAADSXicdZLdjtJAFMen4MeKH8vqpTcTyKIXC7SsWY0JcRV3IxtQDCyQ0IZMpwNM6BczU7tAeBSfxkv1AXwM74zeOKU1YRf3JO3595zfzJmeOaZvUy5U9YeSSt+4eev2zp3M3Xv3H+xm9x52uRcwTM6xZ3usbyJObOqSc0GFTfo+I8gxbdIzp7Uo3/tEGKee2xFznxgOGrt0RDESMjTcU4724UQIn78sl2elgEq2hHy//GpW7S1e8/e1C7PZDsNG7axTt1XeW5zwJg1pt3ZmNU552Hh7wuvTKe23JUfDC8m1Yq7Om6eJ70a+mXxL39WsjD7QTTKm7lLQ6QJbqwyEBdiGui5FHRYK8EOsC7Aj3zpizAsHI+Y51UpRO4DCq2rFygHMUZ4zrgEOY0DknmwThxtbePx6It7DE7KITlzr32l1Y5jNqyV1bXBbaInIg8Raw+wf3fJw4BBXYBtxPtBUXxhLxATFNlll9IATH+EpGpOBlC5yCDeW6wtewX0ZseDIY/JxBVxHN1cskcP53DEl6SAx4VdzUfB/uUEgRi+MJXX9QBAXx4VGgS1/HUbTAi3KCBb2XAqEGZVnhXiCGMJCztSlKlFnitFFbgZn64FaZWS3tKu92RbdSkk7Kj37WMkfv0n6tgMegxx4CjTwHByDd6AFzgFWPitflG/K99TX1M/Ur9TvGE0pyZpH4JKl038BgnP/jw==</latexit>SIOTisitosot221111𝐢𝐭𝐢𝐬𝐈𝐧𝐩𝐮𝐭211𝐨𝐭𝐨𝐬𝐎𝐮𝐭𝐩𝐮𝐭SIR321𝐒𝐭𝐚𝐭𝐞RIS𝐍𝐚𝐦𝐞2321𝐓𝐫𝐚𝐧𝐬𝐢𝐭𝐢𝐨𝐧2infection𝐍𝐚𝐦𝐞recovery221332a)SIR<latexit sha1_base64="04sqyVg/jxl/YEJbMTjjha1g4B8=">AAACBHicbVDLSgNBEJyNr7i+oh69DAbBU9iVoB6DXvQW0TwgWcLspDcZMvtwplcIIVc/wKt+gjfx6n/4Bf6Gk2QPJrGgoajqprvLT6TQ6DjfVm5ldW19I79pb23v7O4V9g/qOk4VhxqPZayaPtMgRQQ1FCihmShgoS+h4Q+uJ37jCZQWcfSAwwS8kPUiEQjO0EjNtg/I6P1tp1B0Ss4UdJm4GSmSDNVO4afdjXkaQoRcMq1brpOgN2IKBZcwttuphoTxAetBy9CIhaC90fTeMT0xSpcGsTIVIZ2qfydGLNR6GPqmM2TY14veRPzPa6UYXHojESUpQsRni4JUUozp5HnaFQo4yqEhjCthbqW8zxTjaCKa2/KYChPb2LZNMu5iDsukflZyz0vlu3KxcpVllCdH5JicEpdckAq5IVVSI5xI8kJeyZv1bL1bH9bnrDVnZTOHZA7W1y88t5gi</latexit> SI<latexit sha1_base64="6jTpjiYWpVpdYRtpujzqXkaHcSY=">AAACBHicbVDLSgNBEJyNr7i+oh69DAbBU9gVUY9BL3qLYB6QLKF3MpsMmZldZ2aFsOTqB3jVT/AmXv0Pv8DfcJLswSQWNBRV3XR3hQln2njet1NYWV1b3yhuulvbO7t7pf2Dho5TRWidxDxWrRA05UzSumGG01aiKIiQ02Y4vJn4zSeqNIvlgxklNBDQlyxiBIyVWp0+CAH4rlsqexVvCrxM/JyUUY5at/TT6cUkFVQawkHrtu8lJshAGUY4HbudVNMEyBD6tG2pBEF1kE3vHeMTq/RwFCtb0uCp+nciA6H1SIS2U4AZ6EVvIv7ntVMTXQUZk0lqqCSzRVHKsYnx5HncY4oSw0eWAFHM3orJABQQYyOa2/KYMhvb2HVtMv5iDsukcVbxLyrn9+fl6nWeUREdoWN0inx0iaroFtVQHRHE0Qt6RW/Os/PufDifs9aCk88cojk4X79dDJg2</latexit> Ib)source is the place S and one whose source is the place I — and the source of two output arcs — both whose
target is the place I. The recovery transition is the target of a single input arc and the source of a single
output arc.

Petri nets are closed systems, meaning that they are isolated from interaction with other systems. Non-
compositional modeling approaches focus on explicitly deﬁning and implementing closed systems. However,
Petri nets arising in practice can comprise hundreds [5] or thousands [25] of states and transitions, making
them unwieldy both to conceptualize and to implement. In contrast, our compositional modeling approach
capitalizes on the tendency of real-world systems to coexist in richly-structured ecosystems and enables the
development and assembly of open-system models.

Structured cospans [1] and decorated cospans [9] are formalisms for turning closed model semantics into
open model semantics, in which systems can interact along speciﬁed interfaces. Although structured cospans
are applicable to a variety of systems, mathematically and in our implementation, we restrict our discussion
to the important case of Petri nets. A structured multicospan of Petri nets, or open Petri net (cf. [2]), is a
S.
whole-grain Petri net [15] together with a list of ﬁnite sets A1, . . . , An and functions A1
The sets Ai, called the feet of the structured multicospan, deﬁne an interface for the open Petri net. The
S, called the legs of the structured multicospan, select the places of the Petri net which are
functions Ai →
exposed through the interface. The more standard notion of structured cospan is the special case of n = 2
legs. The extra ﬂexibility aﬀorded by multicospans is useful in practice. In particular, open Petri nets with
arbitrary numbers of legs can be composed using the graphical syntax of undirected wiring diagrams (UWDs)
[21], which are a generic graphical syntax for composing relations, database tables, structured multicospans,
and other undirected systems. An UWD consists of a set of boxes, a set of ports, and a set of junctions. Each
port is assigned to a box and wired to a junction. Figure 2(a) depicts a UWD with three boxes, ten ports,
and ﬁve junctions. A port assigned to the SIR box and a port assigned to the VIvR box are both wired to
the top-most junction. Likewise, two junctions connect two ports assigned to the SIR box with two ports
assigned to the cross exposure box, and two junctions connect two ports assigned to the VIvR box with two
ports assigned to the cross exposure box.

S, . . . , An →

→

In Figure 2, we present a compartmental model for viral dynamics that accounts for vaccination as
the composition of three concrete submodels corresponding to (1) a disease spread model for unvaccinated
people, (2) a disease spread model for vaccinated people, and (3) a cross exposure model of the interactions
between the two populations. The open Petri nets for these three primitive subsystems are shown in Figure 2
(b). The composition syntax is given by the UWD in Figure 2(a), which has three boxes, ten ports, and
ﬁve junctions. The systems compose by identifying places that are connected in the UWD. For example, the
recovered populations, labeled R, in the SIR and VIvR models are identiﬁed in the composite model. The
resulting composite model is shown in Figure 2 (c).

In mathematical terms, UWDs form an operad constituting the composition syntax, and the structured
multicospans of Petri nets (strictly speaking, their isomorphism classes) form an operad algebra of the UWD
syntax. This operadic framework has many advantages.
In addition to the modular model speciﬁcation
strategy exempliﬁed in Figure 2, the algebra enables a hierarchical model speciﬁcation strategy in which a
submodel may itself be the composite of still more primitive submodels. A syntax for hierarchical modeling is
given later in Figure 3(f). The operadic framework also enables a mathematically rigorous divide-and-conquer
workﬂow by designating subsystems that can be developed and reﬁned in parallel. Updates to submodels do
not aﬀect others except through explicitly represented changes to the composition syntax. Furthermore, the
syntax provides an opportunity to build assumptions and domain-speciﬁc knowledge directly into models
and can be used to identify properties or appropriate sampling algorithms of the composite model. These
advantages are discussed further in Section 2.4.

The Julia packages AlgebraicPetri and AlgebraicDynamics directly implement the operadic approach de-
scribed in this section and its extensions in Section 2.3. These packages enable modelers to create executable
code for composite models that reﬂect the modular and hierarchical structure of real-world systems [16].

2.2 Mass action kinetics for open Petri nets

A Petri net is a combinatorial description of a dynamical process. The graphical representation and network
topology of Petri nets can be analyzed to infer structural properties of the system. However, behavioral
analyses often require explicit model simulations. These simulations can be computed using discrete sampling

4

Figure 2: An example of a Petri net for a compartmental model speciﬁed as a composite of submodels.
(a) The syntax for composition is given by an undirected wiring diagram which represents the high level
design of the subsystems and their interactions.
(b) The component submodels are given as open Petri
nets. Starting with the submodel in blue and moving clockwise they are a submodel isomorphic to the
classic susceptible-infected-recovered (SIR) disease spread model for unvaccinated people; a submodel with
presumably lower transmission rates isomorphic to the SIR disease spread model for vaccinated people; and
a submodel specifying the interactions between the two populations, namely the vaccination process itself
and transmission between vaccinated and unvaccinated people. While in this example the variable names
for the places are aligned between the submodels, this need not be the case in generic compositions. The
wires in the UWD (represented in (b) by the dashed lines) explicitly allow for component submodels to apply
diﬀerent naming conventions and preserve the independence of submodels. (c) The AlgebraicJulia software
computes the composite model from the high-level design and the speciﬁcation of components.

5

SIRCross ExposureVIvRSRIβ γVRIvβv γvSSIβVIvβvSνVRIvβv γvSRIβ γSIβVIvβvSνa)b)c)algorithms, such as Gillespie’s direct method or tau-leaping, or by interpreting a Petri net as an ordinary
diﬀerential equation (ODE) and applying standard numerical integration techniques. In this section we focus
on the latter method, which allows for integration with the calibration and analysis toolkits described in
Section 4.

Following Baez and Pollard [3, Deﬁnition 13], we associate an ODE to a Petri net by applying the law
of mass action, which states that transitions consume inputs and produce outputs at rates proportional to
NT so that p(s) is the
the product of their input concentrations. To illustrate, deﬁne the function p : S
NS so that r(t) is the multiset of
multiset of transitions producing the species s. Likewise, deﬁne r : T
NT maps a species s to the
species that are inputs to the transition t. Its weighted preimage r−1 : S
multiset of transitions for which it is an input. Each species s in the Petri net is assigned a variable us in
the ODE. The transitions deﬁne the following vector ﬁeld on the state space RS:

→

→

→

˙us =

(cid:88)

t∈p(s)

φt −

(cid:88)

t∈r−1(s)

φt,

where

φt := βt

(cid:89)

us

s∈r(t)

(1)

and βt is the rate constant associated with transition t. These equations deﬁne the standard interpretation
of Petri nets as systems of ODEs governing chemical reaction networks. Note that the multiset multiplicities
represent the stoichiometric coeﬃcients in the chemical reaction interpretation of the Petri net.

When applicable, deﬁning ODEs by Petri nets or composites of Petri nets has signiﬁcant software advan-
tages. Meaningful, local changes to a Petri net, such as substituting submodels in a composition or adding
a single species or transition, often lead to nontrivial, global changes to the corresponding ODE that aﬀect
many variables and terms. For example, analysis tools that observe, report, and calculate properties of
state variables throughout a simulation often refer to a single variable in many places. Therefore, adding
or removing a state variable to the system requires making many coordinated changes to the code. This
design pattern results in software where local changes to the mathematical model require global changes to
the software implementation. In contrast, local changes to a Petri net model requires only local changes
to its software implementation in AlgebraicPetri. The transformation of a Petri net into an ODE via the
law of mass action automatically and accurately translates these local changes to the Petri net model into
global changes to the corresponding ODE. This automation can accelerate the modeling cycle—such as for
making modiﬁcations in response to new information or testing for policy robustness—which is critical when
responding to urgent situations.

2.3 Composition of general diﬀerential equation models

Mass action kinetics are often insuﬃcient to simulate complex dynamical processes like those found in biology,
ecology, and epidemiology. In this section, we show how the composition method for Petri nets generalizes
to composition methods for models of diﬀerent types, in particular to models explicitly deﬁned by ordinary
diﬀerential equations (ODEs) or delay diﬀerential equations (DDEs).

The composition of Petri nets described in Section 2.1 is an example of the categorical formalism of
operads and operad algebras, which equip visual grammars with the rigor of algebraic equations. The
theme of the operadic approach is to explicitly and independently describe the syntax of composition—
how subsystems interact—and the semantics of composition—particular choices of component models for
each subsystem. The example of composing Petri nets, in which the syntax is given by an undirected wiring
diagram and the semantics by open Petri nets, is one of many examples of the operadic approach to modeling.
Modeling vector-borne pathogens, such as malaria, is an exemplar context for the operadic approach
because the pathogen dynamics naturally decompose into distinct scientiﬁc domains such as epidemiology
and entomology. The Ross-Macdonald class of equational models highlights the decomposition of a vector-
borne pathogen epidemic into three subsystems: pathogen dynamics in the vector (mosquito) population,
pathogen dynamics in the host (human) population, and the dynamics of pathogen transference in the
bloodmeal [20]. Syntactically, this composition is deﬁned by a UWD with three boxes corresponding to the
three subsystems and with junctions corresponding to populations involved in multiple processes. Figure 3(a)
deﬁnes this UWD. To this composition pattern, we apply submodels of increasing complexity and of diﬀerent
types, namely Petri nets in Figure 3(b), ODEs in Figure 3(c,d), and DDEs in Figure 3(e). The composition
for Petri nets was deﬁned in Section 2.1. The ODE and DDE submodels compose by identifying variables

6

Figure 3: The UWDs in (a) and (f) deﬁne syntaxes for composing submodels so that the result is a model for
the spread of a vector-borne pathogen. In (a) the junctions represent a shared population of infected hosts
(IH ) and a shared population of infected vectors (IV ). In (f) there are additional junctions for the shared
populations of susceptible hosts (SH ), susceptible vectors (SV ), and infected but not yet infectious vectors
(EV ). The syntax in (f) corresponds to several of the modules presented in [25]. For the syntax in (a),
diﬀerent choices of concrete submodels produce diﬀerent composite models of varying types and complexity.
Several such choices are depicted in (b-e). (b) presents the components as Petri nets and (c) gives ODEs
which are the law of mass action applied to the components in (b). (d) represents a Ross-Macdonald ODE
model while (e) incorporates a delay which accounts for the incubation period for the pathogen in vectors.
In (d) and (e) the parameter a is the biting rate, b is the infection eﬃcacy for hosts, c is the infection eﬃcacy
for vectors, H is the total host population and V is the total vector population.

7

HostBloodmealAdult EpidemicAquatic Stages<latexit sha1_base64="A6R+kMFgZtXiOwghbKmZdI/UHLA=">AAAB6nicbVBNS8NAEJ3Ur1q/qh69LBbBU0lE1GPRi94q2g9oQ9lsN+3SzSbsToQS+hO8eFDEq7/Im//GbZuDtj4YeLw3w8y8IJHCoOt+O4WV1bX1jeJmaWt7Z3evvH/QNHGqGW+wWMa6HVDDpVC8gQIlbyea0yiQvBWMbqZ+64lrI2L1iOOE+xEdKBEKRtFKD3e9Zq9ccavuDGSZeDmpQI56r/zV7ccsjbhCJqkxHc9N0M+oRsEkn5S6qeEJZSM64B1LFY248bPZqRNyYpU+CWNtSyGZqb8nMhoZM44C2xlRHJpFbyr+53VSDK/8TKgkRa7YfFGYSoIxmf5N+kJzhnJsCWVa2FsJG1JNGdp0SjYEb/HlZdI8q3oX1fP780rtOo+jCEdwDKfgwSXU4Bbq0AAGA3iGV3hzpPPivDsf89aCk88cwh84nz//CY2f</latexit>IV<latexit sha1_base64="aMBNLDPeHdkFrGjfGfjFNcv+KNg=">AAAB6nicbVDLSgNBEOyNrxhfUY9eBoPgKexKUI9BL/EW0TwgWcLspDcZMju7zMwKIeQTvHhQxKtf5M2/cZLsQRMLGoqqbrq7gkRwbVz328mtrW9sbuW3Czu7e/sHxcOjpo5TxbDBYhGrdkA1Ci6xYbgR2E4U0igQ2ApGtzO/9YRK81g+mnGCfkQHkoecUWOlh7terVcsuWV3DrJKvIyUIEO9V/zq9mOWRigNE1Trjucmxp9QZTgTOC10U40JZSM6wI6lkkao/cn81Ck5s0qfhLGyJQ2Zq78nJjTSehwFtjOiZqiXvZn4n9dJTXjtT7hMUoOSLRaFqSAmJrO/SZ8rZEaMLaFMcXsrYUOqKDM2nYINwVt+eZU0L8reZblyXylVb7I48nACp3AOHlxBFWpQhwYwGMAzvMKbI5wX5935WLTmnGzmGP7A+fwB6dGNkQ==</latexit>IH<latexit sha1_base64="wro45jjZ8bU/AB/Ot5xt8k3kuqk=">AAAB+XicbVDLSgMxFL1TX7W+Rl26CRbBjWVGiroRim7qroJ9QDsMmTTThmYyQ5IplKF/4saFIm79E3f+jWk7C209EHI4596bmxMknCntON9WYW19Y3OruF3a2d3bP7APj1oqTiWhTRLzWHYCrChngjY105x2EklxFHDaDkb3M789plKxWDzpSUK9CA8ECxnB2ki+bff6sUYPfh3dogtpbt8uOxVnDrRK3JyUIUfDt7/MCJJGVGjCsVJd10m0l2GpGeF0WuqliiaYjPCAdg0VOKLKy+abT9GZUfoojKU5QqO5+rsjw5FSkygwlRHWQ7XszcT/vG6qwxsvYyJJNRVk8VCYcqRjNIsB9ZmkRPOJIZhIZnZFZIglJtqEVTIhuMtfXiWty4p7Vak+Vsu1uzyOIpzAKZyDC9dQgzo0oAkExvAMr/BmZdaL9W59LEoLVt5zDH9gff4ALQSSEw==</latexit>˙IH= rIH<latexit sha1_base64="uBRMnkRqFlQhJ4ymhehqkS0ND9c=">AAAB+XicbVDLSgMxFL3js9bXqEs3wSK4scxIUTdC0Y3uKtgHtMOQSdM2NPMguVMoQ//EjQtF3Pon7vwb03YW2nog5HDOvTc3J0ik0Og439bK6tr6xmZhq7i9s7u3bx8cNnScKsbrLJaxagVUcykiXkeBkrcSxWkYSN4MhndTvzniSos4esJxwr2Q9iPRE4yikXzb7nRjJA9+g9yQ8765fbvklJ0ZyDJxc1KCHDXf/jIjWBryCJmkWrddJ0EvowoFk3xS7KSaJ5QNaZ+3DY1oyLWXzTafkFOjdEkvVuZESGbq746MhlqPw8BUhhQHetGbiv957RR7114moiRFHrH5Q71UEozJNAbSFYozlGNDKFPC7ErYgCrK0IRVNCG4i19eJo2LsntZrjxWStXbPI4CHMMJnIELV1CFe6hBHRiM4Ble4c3KrBfr3fqYl65Yec8R/IH1+QNHF5Ik</latexit>˙IV= gIV<latexit sha1_base64="A6R+kMFgZtXiOwghbKmZdI/UHLA=">AAAB6nicbVBNS8NAEJ3Ur1q/qh69LBbBU0lE1GPRi94q2g9oQ9lsN+3SzSbsToQS+hO8eFDEq7/Im//GbZuDtj4YeLw3w8y8IJHCoOt+O4WV1bX1jeJmaWt7Z3evvH/QNHGqGW+wWMa6HVDDpVC8gQIlbyea0yiQvBWMbqZ+64lrI2L1iOOE+xEdKBEKRtFKD3e9Zq9ccavuDGSZeDmpQI56r/zV7ccsjbhCJqkxHc9N0M+oRsEkn5S6qeEJZSM64B1LFY248bPZqRNyYpU+CWNtSyGZqb8nMhoZM44C2xlRHJpFbyr+53VSDK/8TKgkRa7YfFGYSoIxmf5N+kJzhnJsCWVa2FsJG1JNGdp0SjYEb/HlZdI8q3oX1fP780rtOo+jCEdwDKfgwSXU4Bbq0AAGA3iGV3hzpPPivDsf89aCk88cwh84nz//CY2f</latexit>IV<latexit sha1_base64="aMBNLDPeHdkFrGjfGfjFNcv+KNg=">AAAB6nicbVDLSgNBEOyNrxhfUY9eBoPgKexKUI9BL/EW0TwgWcLspDcZMju7zMwKIeQTvHhQxKtf5M2/cZLsQRMLGoqqbrq7gkRwbVz328mtrW9sbuW3Czu7e/sHxcOjpo5TxbDBYhGrdkA1Ci6xYbgR2E4U0igQ2ApGtzO/9YRK81g+mnGCfkQHkoecUWOlh7terVcsuWV3DrJKvIyUIEO9V/zq9mOWRigNE1Trjucmxp9QZTgTOC10U40JZSM6wI6lkkao/cn81Ck5s0qfhLGyJQ2Zq78nJjTSehwFtjOiZqiXvZn4n9dJTXjtT7hMUoOSLRaFqSAmJrO/SZ8rZEaMLaFMcXsrYUOqKDM2nYINwVt+eZU0L8reZblyXylVb7I48nACp3AOHlxBFWpQhwYwGMAzvMKbI5wX5935WLTmnGzmGP7A+fwB6dGNkQ==</latexit>IH<latexit sha1_base64="wro45jjZ8bU/AB/Ot5xt8k3kuqk=">AAAB+XicbVDLSgMxFL1TX7W+Rl26CRbBjWVGiroRim7qroJ9QDsMmTTThmYyQ5IplKF/4saFIm79E3f+jWk7C209EHI4596bmxMknCntON9WYW19Y3OruF3a2d3bP7APj1oqTiWhTRLzWHYCrChngjY105x2EklxFHDaDkb3M789plKxWDzpSUK9CA8ECxnB2ki+bff6sUYPfh3dogtpbt8uOxVnDrRK3JyUIUfDt7/MCJJGVGjCsVJd10m0l2GpGeF0WuqliiaYjPCAdg0VOKLKy+abT9GZUfoojKU5QqO5+rsjw5FSkygwlRHWQ7XszcT/vG6qwxsvYyJJNRVk8VCYcqRjNIsB9ZmkRPOJIZhIZnZFZIglJtqEVTIhuMtfXiWty4p7Vak+Vsu1uzyOIpzAKZyDC9dQgzo0oAkExvAMr/BmZdaL9W59LEoLVt5zDH9gff4ALQSSEw==</latexit>˙IH= rIH<latexit sha1_base64="uBRMnkRqFlQhJ4ymhehqkS0ND9c=">AAAB+XicbVDLSgMxFL3js9bXqEs3wSK4scxIUTdC0Y3uKtgHtMOQSdM2NPMguVMoQ//EjQtF3Pon7vwb03YW2nog5HDOvTc3J0ik0Og439bK6tr6xmZhq7i9s7u3bx8cNnScKsbrLJaxagVUcykiXkeBkrcSxWkYSN4MhndTvzniSos4esJxwr2Q9iPRE4yikXzb7nRjJA9+g9yQ8765fbvklJ0ZyDJxc1KCHDXf/jIjWBryCJmkWrddJ0EvowoFk3xS7KSaJ5QNaZ+3DY1oyLWXzTafkFOjdEkvVuZESGbq746MhlqPw8BUhhQHetGbiv957RR7114moiRFHrH5Q71UEozJNAbSFYozlGNDKFPC7ErYgCrK0IRVNCG4i19eJo2LsntZrjxWStXbPI4CHMMJnIELV1CFe6hBHRiM4Ble4c3KrBfr3fqYl65Yec8R/IH1+QNHF5Ik</latexit>˙IV= gIV<latexit sha1_base64="A6R+kMFgZtXiOwghbKmZdI/UHLA=">AAAB6nicbVBNS8NAEJ3Ur1q/qh69LBbBU0lE1GPRi94q2g9oQ9lsN+3SzSbsToQS+hO8eFDEq7/Im//GbZuDtj4YeLw3w8y8IJHCoOt+O4WV1bX1jeJmaWt7Z3evvH/QNHGqGW+wWMa6HVDDpVC8gQIlbyea0yiQvBWMbqZ+64lrI2L1iOOE+xEdKBEKRtFKD3e9Zq9ccavuDGSZeDmpQI56r/zV7ccsjbhCJqkxHc9N0M+oRsEkn5S6qeEJZSM64B1LFY248bPZqRNyYpU+CWNtSyGZqb8nMhoZM44C2xlRHJpFbyr+53VSDK/8TKgkRa7YfFGYSoIxmf5N+kJzhnJsCWVa2FsJG1JNGdp0SjYEb/HlZdI8q3oX1fP780rtOo+jCEdwDKfgwSXU4Bbq0AAGA3iGV3hzpPPivDsf89aCk88cwh84nz//CY2f</latexit>IV<latexit sha1_base64="aMBNLDPeHdkFrGjfGfjFNcv+KNg=">AAAB6nicbVDLSgNBEOyNrxhfUY9eBoPgKexKUI9BL/EW0TwgWcLspDcZMju7zMwKIeQTvHhQxKtf5M2/cZLsQRMLGoqqbrq7gkRwbVz328mtrW9sbuW3Czu7e/sHxcOjpo5TxbDBYhGrdkA1Ci6xYbgR2E4U0igQ2ApGtzO/9YRK81g+mnGCfkQHkoecUWOlh7terVcsuWV3DrJKvIyUIEO9V/zq9mOWRigNE1Trjucmxp9QZTgTOC10U40JZSM6wI6lkkao/cn81Ck5s0qfhLGyJQ2Zq78nJjTSehwFtjOiZqiXvZn4n9dJTXjtT7hMUoOSLRaFqSAmJrO/SZ8rZEaMLaFMcXsrYUOqKDM2nYINwVt+eZU0L8reZblyXylVb7I48nACp3AOHlxBFWpQhwYwGMAzvMKbI5wX5935WLTmnGzmGP7A+fwB6dGNkQ==</latexit>IH<latexit sha1_base64="wro45jjZ8bU/AB/Ot5xt8k3kuqk=">AAAB+XicbVDLSgMxFL1TX7W+Rl26CRbBjWVGiroRim7qroJ9QDsMmTTThmYyQ5IplKF/4saFIm79E3f+jWk7C209EHI4596bmxMknCntON9WYW19Y3OruF3a2d3bP7APj1oqTiWhTRLzWHYCrChngjY105x2EklxFHDaDkb3M789plKxWDzpSUK9CA8ECxnB2ki+bff6sUYPfh3dogtpbt8uOxVnDrRK3JyUIUfDt7/MCJJGVGjCsVJd10m0l2GpGeF0WuqliiaYjPCAdg0VOKLKy+abT9GZUfoojKU5QqO5+rsjw5FSkygwlRHWQ7XszcT/vG6qwxsvYyJJNRVk8VCYcqRjNIsB9ZmkRPOJIZhIZnZFZIglJtqEVTIhuMtfXiWty4p7Vak+Vsu1uzyOIpzAKZyDC9dQgzo0oAkExvAMr/BmZdaL9W59LEoLVt5zDH9gff4ALQSSEw==</latexit>˙IH= rIH<latexit sha1_base64="uBRMnkRqFlQhJ4ymhehqkS0ND9c=">AAAB+XicbVDLSgMxFL3js9bXqEs3wSK4scxIUTdC0Y3uKtgHtMOQSdM2NPMguVMoQ//EjQtF3Pon7vwb03YW2nog5HDOvTc3J0ik0Og439bK6tr6xmZhq7i9s7u3bx8cNnScKsbrLJaxagVUcykiXkeBkrcSxWkYSN4MhndTvzniSos4esJxwr2Q9iPRE4yikXzb7nRjJA9+g9yQ8765fbvklJ0ZyDJxc1KCHDXf/jIjWBryCJmkWrddJ0EvowoFk3xS7KSaJ5QNaZ+3DY1oyLWXzTafkFOjdEkvVuZESGbq746MhlqPw8BUhhQHetGbiv957RR7114moiRFHrH5Q71UEozJNAbSFYozlGNDKFPC7ErYgCrK0IRVNCG4i19eJo2LsntZrjxWStXbPI4CHMMJnIELV1CFe6hBHRiM4Ble4c3KrBfr3fqYl65Yec8R/IH1+QNHF5Ik</latexit>˙IV= gIVHostVectorBloodmeal<latexit sha1_base64="A6R+kMFgZtXiOwghbKmZdI/UHLA=">AAAB6nicbVBNS8NAEJ3Ur1q/qh69LBbBU0lE1GPRi94q2g9oQ9lsN+3SzSbsToQS+hO8eFDEq7/Im//GbZuDtj4YeLw3w8y8IJHCoOt+O4WV1bX1jeJmaWt7Z3evvH/QNHGqGW+wWMa6HVDDpVC8gQIlbyea0yiQvBWMbqZ+64lrI2L1iOOE+xEdKBEKRtFKD3e9Zq9ccavuDGSZeDmpQI56r/zV7ccsjbhCJqkxHc9N0M+oRsEkn5S6qeEJZSM64B1LFY248bPZqRNyYpU+CWNtSyGZqb8nMhoZM44C2xlRHJpFbyr+53VSDK/8TKgkRa7YfFGYSoIxmf5N+kJzhnJsCWVa2FsJG1JNGdp0SjYEb/HlZdI8q3oX1fP780rtOo+jCEdwDKfgwSXU4Bbq0AAGA3iGV3hzpPPivDsf89aCk88cwh84nz//CY2f</latexit>IV<latexit sha1_base64="aMBNLDPeHdkFrGjfGfjFNcv+KNg=">AAAB6nicbVDLSgNBEOyNrxhfUY9eBoPgKexKUI9BL/EW0TwgWcLspDcZMju7zMwKIeQTvHhQxKtf5M2/cZLsQRMLGoqqbrq7gkRwbVz328mtrW9sbuW3Czu7e/sHxcOjpo5TxbDBYhGrdkA1Ci6xYbgR2E4U0igQ2ApGtzO/9YRK81g+mnGCfkQHkoecUWOlh7terVcsuWV3DrJKvIyUIEO9V/zq9mOWRigNE1Trjucmxp9QZTgTOC10U40JZSM6wI6lkkao/cn81Ck5s0qfhLGyJQ2Zq78nJjTSehwFtjOiZqiXvZn4n9dJTXjtT7hMUoOSLRaFqSAmJrO/SZ8rZEaMLaFMcXsrYUOqKDM2nYINwVt+eZU0L8reZblyXylVb7I48nACp3AOHlxBFWpQhwYwGMAzvMKbI5wX5935WLTmnGzmGP7A+fwB6dGNkQ==</latexit>IH<latexit sha1_base64="VFcZM2tFySfh6pWLMtSnVfC2bWo=">AAACAXicbVDLSgMxFL1TX7W+Rt0IboJFcFVmpKgboeim3VWwD2iHIZPJtKGZB0lGKEPd+CtuXCji1r9w59+YtrPQ1gOBwzn3JLnHSziTyrK+jcLK6tr6RnGztLW9s7tn7h+0ZZwKQlsk5rHoelhSziLaUkxx2k0ExaHHaccb3U79zgMVksXRvRon1AnxIGIBI1hpyTWP+n6sUMOto2vU5zrnY80bbts1y1bFmgEtEzsnZcjRdM0vfRVJQxopwrGUPdtKlJNhoRjhdFLqp5ImmIzwgPY0jXBIpZPNNpigU634KIiFPpFCM/V3IsOhlOPQ05MhVkO56E3F/7xeqoIrJ2NRkioakflDQcqRitG0DuQzQYniY00wEUz/FZEhFpgoXVpJl2AvrrxM2ucV+6JSvauWazd5HUU4hhM4AxsuoQZ1aEILCDzCM7zCm/FkvBjvxsd8tGDkmUP4A+PzBwJglVY=</latexit>˙IH= HIV<latexit sha1_base64="7sUQfwS1MU3hSi7W2w3TgtwIhks=">AAACAXicbVDLSgMxFL1TX7W+Rt0IboJFcFVmpKgboeim3VWwD2iHIZPJtKGZB0lGKEPd+CtuXCji1r9w59+YtrPQ1gOBwzn3JLnHSziTyrK+jcLK6tr6RnGztLW9s7tn7h+0ZZwKQlsk5rHoelhSziLaUkxx2k0ExaHHaccb3U79zgMVksXRvRon1AnxIGIBI1hpyTWP+n6sUMNto2vU5zrnY80bbt01y1bFmgEtEzsnZcjRdM0vfRVJQxopwrGUPdtKlJNhoRjhdFLqp5ImmIzwgPY0jXBIpZPNNpigU634KIiFPpFCM/V3IsOhlOPQ05MhVkO56E3F/7xeqoIrJ2NRkioakflDQcqRitG0DuQzQYniY00wEUz/FZEhFpgoXVpJl2AvrrxM2ucV+6JSvauWazd5HUU4hhM4AxsuoQZ1aEILCDzCM7zCm/FkvBjvxsd8tGDkmUP4A+PzBxiwlWQ=</latexit>˙IV= VIH<latexit sha1_base64="A6R+kMFgZtXiOwghbKmZdI/UHLA=">AAAB6nicbVBNS8NAEJ3Ur1q/qh69LBbBU0lE1GPRi94q2g9oQ9lsN+3SzSbsToQS+hO8eFDEq7/Im//GbZuDtj4YeLw3w8y8IJHCoOt+O4WV1bX1jeJmaWt7Z3evvH/QNHGqGW+wWMa6HVDDpVC8gQIlbyea0yiQvBWMbqZ+64lrI2L1iOOE+xEdKBEKRtFKD3e9Zq9ccavuDGSZeDmpQI56r/zV7ccsjbhCJqkxHc9N0M+oRsEkn5S6qeEJZSM64B1LFY248bPZqRNyYpU+CWNtSyGZqb8nMhoZM44C2xlRHJpFbyr+53VSDK/8TKgkRa7YfFGYSoIxmf5N+kJzhnJsCWVa2FsJG1JNGdp0SjYEb/HlZdI8q3oX1fP780rtOo+jCEdwDKfgwSXU4Bbq0AAGA3iGV3hzpPPivDsf89aCk88cwh84nz//CY2f</latexit>IV<latexit sha1_base64="aMBNLDPeHdkFrGjfGfjFNcv+KNg=">AAAB6nicbVDLSgNBEOyNrxhfUY9eBoPgKexKUI9BL/EW0TwgWcLspDcZMju7zMwKIeQTvHhQxKtf5M2/cZLsQRMLGoqqbrq7gkRwbVz328mtrW9sbuW3Czu7e/sHxcOjpo5TxbDBYhGrdkA1Ci6xYbgR2E4U0igQ2ApGtzO/9YRK81g+mnGCfkQHkoecUWOlh7terVcsuWV3DrJKvIyUIEO9V/zq9mOWRigNE1Trjucmxp9QZTgTOC10U40JZSM6wI6lkkao/cn81Ck5s0qfhLGyJQ2Zq78nJjTSehwFtjOiZqiXvZn4n9dJTXjtT7hMUoOSLRaFqSAmJrO/SZ8rZEaMLaFMcXsrYUOqKDM2nYINwVt+eZU0L8reZblyXylVb7I48nACp3AOHlxBFWpQhwYwGMAzvMKbI5wX5935WLTmnGzmGP7A+fwB6dGNkQ==</latexit>IH<latexit sha1_base64="aMBNLDPeHdkFrGjfGfjFNcv+KNg=">AAAB6nicbVDLSgNBEOyNrxhfUY9eBoPgKexKUI9BL/EW0TwgWcLspDcZMju7zMwKIeQTvHhQxKtf5M2/cZLsQRMLGoqqbrq7gkRwbVz328mtrW9sbuW3Czu7e/sHxcOjpo5TxbDBYhGrdkA1Ci6xYbgR2E4U0igQ2ApGtzO/9YRK81g+mnGCfkQHkoecUWOlh7terVcsuWV3DrJKvIyUIEO9V/zq9mOWRigNE1Trjucmxp9QZTgTOC10U40JZSM6wI6lkkao/cn81Ck5s0qfhLGyJQ2Zq78nJjTSehwFtjOiZqiXvZn4n9dJTXjtT7hMUoOSLRaFqSAmJrO/SZ8rZEaMLaFMcXsrYUOqKDM2nYINwVt+eZU0L8reZblyXylVb7I48nACp3AOHlxBFWpQhwYwGMAzvMKbI5wX5935WLTmnGzmGP7A+fwB6dGNkQ==</latexit>IH<latexit sha1_base64="dNaRbtHUcByh+nWByrC7ShFQ0BQ=">AAAB6HicbVBNS8NAEJ3Ur1q/qh69LBbBU0mkqMeiF48t2FpoQ9lsJ+3azSbsboQS+gu8eFDEqz/Jm//GbZuDtj4YeLw3w8y8IBFcG9f9dgpr6xubW8Xt0s7u3v5B+fCoreNUMWyxWMSqE1CNgktsGW4EdhKFNAoEPgTj25n/8IRK81jem0mCfkSHkoecUWOlpuqXK27VnYOsEi8nFcjR6Je/eoOYpRFKwwTVuuu5ifEzqgxnAqelXqoxoWxMh9i1VNIItZ/ND52SM6sMSBgrW9KQufp7IqOR1pMosJ0RNSO97M3E/7xuasJrP+MySQ1KtlgUpoKYmMy+JgOukBkxsYQyxe2thI2ooszYbEo2BG/55VXSvqh6l9Vas1ap3+RxFOEETuEcPLiCOtxBA1rAAOEZXuHNeXRenHfnY9FacPKZY/gD5/MH4A+M/w==</latexit>r<latexit sha1_base64="4UV3jjiIgEdJXxcPtLEmPObgQHI=">AAAB8HicbVDLSgMxFL1TX7W+qi7dBIvgqsxIUZdFNy4r2Ie0Q8lkMm1okhmSjFCGfoUbF4q49XPc+Tem01lo64HA4Zxzyb0nSDjTxnW/ndLa+sbmVnm7srO7t39QPTzq6DhVhLZJzGPVC7CmnEnaNsxw2ksUxSLgtBtMbud+94kqzWL5YKYJ9QUeSRYxgo2VHgfcRkM87AyrNbfu5kCrxCtIDQq0htWvQRiTVFBpCMda9z03MX6GlWGE01llkGqaYDLBI9q3VGJBtZ/lC8/QmVVCFMXKPmlQrv6eyLDQeioCmxTYjPWyNxf/8/qpia79jMkkNVSSxUdRypGJ0fx6FDJFieFTSzBRzO6KyBgrTIztqGJL8JZPXiWdi7p3WW/cN2rNm6KOMpzAKZyDB1fQhDtoQRsICHiGV3hzlPPivDsfi2jJKWaO4Q+czx+h0ZBP</latexit> V<latexit sha1_base64="yus2kLzy4nvU5V9WorES3MROO14=">AAAB8HicbVDLSgMxFL1TX7W+qi7dBIvgqsxIqS6LbrqsYB/SDiWTybShSWZIMkIZ+hVuXCji1s9x59+YtrPQ1gOBwznnkntPkHCmjet+O4WNza3tneJuaW//4PCofHzS0XGqCG2TmMeqF2BNOZO0bZjhtJcoikXAaTeY3M397hNVmsXywUwT6gs8kixiBBsrPQ64jYZ42ByWK27VXQCtEy8nFcjRGpa/BmFMUkGlIRxr3ffcxPgZVoYRTmelQappgskEj2jfUokF1X62WHiGLqwSoihW9kmDFurviQwLracisEmBzVivenPxP6+fmujGz5hMUkMlWX4UpRyZGM2vRyFTlBg+tQQTxeyuiIyxwsTYjkq2BG/15HXSuap69WrtvlZp3OZ1FOEMzuESPLiGBjShBW0gIOAZXuHNUc6L8+58LKMFJ585hT9wPn8AjJmQQQ==</latexit> H<latexit sha1_base64="uSW0H71JUat1zrUvRTNUif2jrkk=">AAAB6HicbVBNS8NAEJ3Ur1q/qh69LBbBU0mkqMeiF48t2FpoQ9lsJ+3azSbsboQS+gu8eFDEqz/Jm//GbZuDtj4YeLw3w8y8IBFcG9f9dgpr6xubW8Xt0s7u3v5B+fCoreNUMWyxWMSqE1CNgktsGW4EdhKFNAoEPgTj25n/8IRK81jem0mCfkSHkoecUWOl5rBfrrhVdw6ySrycVCBHo1/+6g1ilkYoDRNU667nJsbPqDKcCZyWeqnGhLIxHWLXUkkj1H42P3RKzqwyIGGsbElD5urviYxGWk+iwHZG1Iz0sjcT//O6qQmv/YzLJDUo2WJRmApiYjL7mgy4QmbExBLKFLe3EjaiijJjsynZELzll1dJ+6LqXVZrzVqlfpPHUYQTOIVz8OAK6nAHDWgBA4RneIU359F5cd6dj0VrwclnjuEPnM8fz2OM9A==</latexit>g<latexit sha1_base64="aMBNLDPeHdkFrGjfGfjFNcv+KNg=">AAAB6nicbVDLSgNBEOyNrxhfUY9eBoPgKexKUI9BL/EW0TwgWcLspDcZMju7zMwKIeQTvHhQxKtf5M2/cZLsQRMLGoqqbrq7gkRwbVz328mtrW9sbuW3Czu7e/sHxcOjpo5TxbDBYhGrdkA1Ci6xYbgR2E4U0igQ2ApGtzO/9YRK81g+mnGCfkQHkoecUWOlh7terVcsuWV3DrJKvIyUIEO9V/zq9mOWRigNE1Trjucmxp9QZTgTOC10U40JZSM6wI6lkkao/cn81Ck5s0qfhLGyJQ2Zq78nJjTSehwFtjOiZqiXvZn4n9dJTXjtT7hMUoOSLRaFqSAmJrO/SZ8rZEaMLaFMcXsrYUOqKDM2nYINwVt+eZU0L8reZblyXylVb7I48nACp3AOHlxBFWpQhwYwGMAzvMKbI5wX5935WLTmnGzmGP7A+fwB6dGNkQ==</latexit>IH<latexit sha1_base64="A6R+kMFgZtXiOwghbKmZdI/UHLA=">AAAB6nicbVBNS8NAEJ3Ur1q/qh69LBbBU0lE1GPRi94q2g9oQ9lsN+3SzSbsToQS+hO8eFDEq7/Im//GbZuDtj4YeLw3w8y8IJHCoOt+O4WV1bX1jeJmaWt7Z3evvH/QNHGqGW+wWMa6HVDDpVC8gQIlbyea0yiQvBWMbqZ+64lrI2L1iOOE+xEdKBEKRtFKD3e9Zq9ccavuDGSZeDmpQI56r/zV7ccsjbhCJqkxHc9N0M+oRsEkn5S6qeEJZSM64B1LFY248bPZqRNyYpU+CWNtSyGZqb8nMhoZM44C2xlRHJpFbyr+53VSDK/8TKgkRa7YfFGYSoIxmf5N+kJzhnJsCWVa2FsJG1JNGdp0SjYEb/HlZdI8q3oX1fP780rtOo+jCEdwDKfgwSXU4Bbq0AAGA3iGV3hzpPPivDsf89aCk88cwh84nz//CY2f</latexit>IV<latexit sha1_base64="A6R+kMFgZtXiOwghbKmZdI/UHLA=">AAAB6nicbVBNS8NAEJ3Ur1q/qh69LBbBU0lE1GPRi94q2g9oQ9lsN+3SzSbsToQS+hO8eFDEq7/Im//GbZuDtj4YeLw3w8y8IJHCoOt+O4WV1bX1jeJmaWt7Z3evvH/QNHGqGW+wWMa6HVDDpVC8gQIlbyea0yiQvBWMbqZ+64lrI2L1iOOE+xEdKBEKRtFKD3e9Zq9ccavuDGSZeDmpQI56r/zV7ccsjbhCJqkxHc9N0M+oRsEkn5S6qeEJZSM64B1LFY248bPZqRNyYpU+CWNtSyGZqb8nMhoZM44C2xlRHJpFbyr+53VSDK/8TKgkRa7YfFGYSoIxmf5N+kJzhnJsCWVa2FsJG1JNGdp0SjYEb/HlZdI8q3oX1fP780rtOo+jCEdwDKfgwSXU4Bbq0AAGA3iGV3hzpPPivDsf89aCk88cwh84nz//CY2f</latexit>IV<latexit sha1_base64="iS5w1sktBRnazi+aaTMcYFomZ1Y=">AAAB6nicbVDLTgJBEOzFF+IL9ehlIjHxRHYNUY9ELxwxyCOBDZkdGpgwO7uZmTUhGz7BiweN8eoXefNvHGAPClbSSaWqO91dQSy4Nq777eQ2Nre2d/K7hb39g8Oj4vFJS0eJYthkkYhUJ6AaBZfYNNwI7MQKaRgIbAeT+7nffkKleSQfzTRGP6QjyYecUWOlRqNf6xdLbtldgKwTLyMlyFDvF796g4glIUrDBNW667mx8VOqDGcCZ4VeojGmbEJH2LVU0hC1ny5OnZELqwzIMFK2pCEL9fdESkOtp2FgO0NqxnrVm4v/ed3EDG/9lMs4MSjZctEwEcREZP43GXCFzIipJZQpbm8lbEwVZcamU7AheKsvr5PWVdm7LlceKqXqXRZHHs7gHC7BgxuoQg3q0AQGI3iGV3hzhPPivDsfy9ack82cwh84nz/5DY2b</latexit>SH<latexit sha1_base64="A6R+kMFgZtXiOwghbKmZdI/UHLA=">AAAB6nicbVBNS8NAEJ3Ur1q/qh69LBbBU0lE1GPRi94q2g9oQ9lsN+3SzSbsToQS+hO8eFDEq7/Im//GbZuDtj4YeLw3w8y8IJHCoOt+O4WV1bX1jeJmaWt7Z3evvH/QNHGqGW+wWMa6HVDDpVC8gQIlbyea0yiQvBWMbqZ+64lrI2L1iOOE+xEdKBEKRtFKD3e9Zq9ccavuDGSZeDmpQI56r/zV7ccsjbhCJqkxHc9N0M+oRsEkn5S6qeEJZSM64B1LFY248bPZqRNyYpU+CWNtSyGZqb8nMhoZM44C2xlRHJpFbyr+53VSDK/8TKgkRa7YfFGYSoIxmf5N+kJzhnJsCWVa2FsJG1JNGdp0SjYEb/HlZdI8q3oX1fP780rtOo+jCEdwDKfgwSXU4Bbq0AAGA3iGV3hzpPPivDsf89aCk88cwh84nz//CY2f</latexit>IV<latexit sha1_base64="Jo4HjOlLZcfkzaesjTAb/7Ht0ms=">AAAB6nicbVBNS8NAEJ3Ur1q/qh69LBbBU0lE1GNRBI8V7Qe0oWy2m3bpZhN2J0IJ/QlePCji1V/kzX/jts1BWx8MPN6bYWZekEhh0HW/ncLK6tr6RnGztLW9s7tX3j9omjjVjDdYLGPdDqjhUijeQIGStxPNaRRI3gpGN1O/9cS1EbF6xHHC/YgOlAgFo2ilh9tes1euuFV3BrJMvJxUIEe9V/7q9mOWRlwhk9SYjucm6GdUo2CST0rd1PCEshEd8I6likbc+Nns1Ak5sUqfhLG2pZDM1N8TGY2MGUeB7YwoDs2iNxX/8zophld+JlSSIldsvihMJcGYTP8mfaE5Qzm2hDIt7K2EDammDG06JRuCt/jyMmmeVb2L6vn9eaV2ncdRhCM4hlPw4BJqcAd1aACDATzDK7w50nlx3p2PeWvByWcO4Q+czx/48Y2b</latexit>EV<latexit sha1_base64="9mqm6xJxj7Yfza39WOagvjsLvRg=">AAAB6nicbVBNS8NAEJ3Ur1q/qh69LBbBU0lE1GPRi8dK7Qe0oWy2k3bpZhN2N0IJ/QlePCji1V/kzX/jts1BWx8MPN6bYWZekAiujet+O4W19Y3NreJ2aWd3b/+gfHjU0nGqGDZZLGLVCahGwSU2DTcCO4lCGgUC28H4bua3n1BpHstHM0nQj+hQ8pAzaqzUaPRb/XLFrbpzkFXi5aQCOer98ldvELM0QmmYoFp3PTcxfkaV4UzgtNRLNSaUjekQu5ZKGqH2s/mpU3JmlQEJY2VLGjJXf09kNNJ6EgW2M6JmpJe9mfif101NeONnXCapQckWi8JUEBOT2d9kwBUyIyaWUKa4vZWwEVWUGZtOyYbgLb+8SloXVe+qevlwWand5nEU4QRO4Rw8uIYa3EMdmsBgCM/wCm+OcF6cd+dj0Vpw8plj+APn8wcOVI2p</latexit>SVa)b)c)d)e)f)<latexit sha1_base64="aMBNLDPeHdkFrGjfGfjFNcv+KNg=">AAAB6nicbVDLSgNBEOyNrxhfUY9eBoPgKexKUI9BL/EW0TwgWcLspDcZMju7zMwKIeQTvHhQxKtf5M2/cZLsQRMLGoqqbrq7gkRwbVz328mtrW9sbuW3Czu7e/sHxcOjpo5TxbDBYhGrdkA1Ci6xYbgR2E4U0igQ2ApGtzO/9YRK81g+mnGCfkQHkoecUWOlh7terVcsuWV3DrJKvIyUIEO9V/zq9mOWRigNE1Trjucmxp9QZTgTOC10U40JZSM6wI6lkkao/cn81Ck5s0qfhLGyJQ2Zq78nJjTSehwFtjOiZqiXvZn4n9dJTXjtT7hMUoOSLRaFqSAmJrO/SZ8rZEaMLaFMcXsrYUOqKDM2nYINwVt+eZU0L8reZblyXylVb7I48nACp3AOHlxBFWpQhwYwGMAzvMKbI5wX5935WLTmnGzmGP7A+fwB6dGNkQ==</latexit>IH<latexit sha1_base64="7GzIswgPtdVIExZWk92TD0j1hhA=">AAACNXicbVDNS8MwHE39nPNr6tFLcCjbwdHKUC/C0MsGHia4brCOkmbpFpZ+kKTCKP2nvPh/eNKDB0W8+i+Ydj3o5oPA4733S/J7TsiokLr+qi0tr6yurRc2iptb2zu7pb19UwQRx6SDAxbwnoMEYdQnHUklI72QE+Q5jHSdyU3qdx8IFzTw7+U0JAMPjXzqUoykkuzSrTUMJGzZTXhyBS2XIxwbSdxMkNOyzUoTnqZe1bKKec5McwjPkspKsxUzi5lVu1TWa3oGuEiMnJRBjrZdelbX4sgjvsQMCdE39FAOYsQlxYwkRSsSJER4gkakr6iPPCIGcbZ1Ao+VMoRuwNXxJczU3xMx8oSYeo5KekiOxbyXiv95/Ui6l4OY+mEkiY9nD7kRgzKAaYVwSDnBkk0VQZhT9VeIx0gVIlXRRVWCMb/yIjHPasZ5rX5XLzeu8zoK4BAcgQowwAVogCZogw7A4BG8gHfwoT1pb9qn9jWLLmn5zAH4A+37B8S1pzY=</latexit>˙IH=1HabIV(H IH)˙IV=acIHH(V IV)<latexit sha1_base64="uOgAdYgVA6MwmGhpLIfCK1VQ6oE=">AAACYHicbVFNT9swGHbC2EppR4EbXKxVTO2BKpkQ7DIJwaW9MWkNSE0XvXGdYuF8yH6zqYryJ7lx4MIvwQmRYHSvZOnR86HXfhxmUmh0nAfL3viw+fFTa6u93el+3unt7nk6zRXjU5bKVN2EoLkUCZ+iQMlvMsUhDiW/Du8uK/36D1dapMkvXGV8HsMyEZFggIYKen/9RYp0EowHOKRff1A/UsAKtyzGJYSTwDP0YEyPG8fQ99tNwGsCwJpM7TBOHyEfVvmBV+e8V3bIfxcVoMsy6PWdkVMPXQduA/qkmaugd28WszzmCTIJWs9cJ8N5AQoFk7xs+7nmGbA7WPKZgQnEXM+LuqCSHhlmQaNUmZMgrdm3iQJirVdxaJwx4K1+r1Xk/7RZjtH3eSGSLEeesJdFUS4pprRqmy6E4gzlygBgSpi7UnYLpi40f9I2Jbjvn7wOvG8j93R08vOkf37R1NEih+QLGRCXnJFzMiZXZEoYebQ2rI7VtZ7slr1j775YbavJ7JN/xj54BmHhrrc=</latexit>˙IH(t)=1HabIV(t)(H IH(t))˙IV(t)=acIH(t ⌧)H(V IV(t ⌧))e⌧gconnected in the UWD and summing the rates of change for identiﬁed variables. For example, the result of
composing the three ODE submodels in Figure 3(d) according to the given composition pattern is

˙IH = ab

IV
H

(H

−

IH )

−

rIH ,

˙IV = ac

IH
H

(V

IV )

−

−

gIV .

Just as the law of mass action deﬁnes a transformation from Petri nets to ODEs, there is also a trans-
formation from ODEs to DDEs giving a trivial dependence on the history. These transformations allow
modelers to use diﬀerent model types to specify the submodels of a composite. For example, in Figure 3(e)
the submodels for the pathogen dynamics in hosts and vectors are given by ODEs and in contrast the blood-
meal model is given by a DDE. The composite model is derived by translating the ODE submodels into
DDE models and then composing the DDE models with the result being akin to the Sharpe-Lotka model
[19]. This formal process gives domain experts the freedom to choose model classes that best ﬁt their ﬁeld.

2.4 Discussion of compositional model speciﬁcation

In this section, we have presented a compositional approach to modeling that is grounded in the mathematics
of applied category theory and implemented directly in software. We conclude with a discussion of this
framework.

Advantages to the engineering process. Engineering is a process that involves taking a theoretical
description of a model and developing software that can simulate, calibrate, and analyze the model. A
model description is often informally compositional and in traditional software this structure is implicit in
the code. In contrast, software packages based on the operadic approach to modeling make this structure
explicit and disambiguate the process of turning the mathematical speciﬁcation of a model into the code
that implements it. As a result, engineers have a mathematically grounded divide-and-conquer approach
to select, implement, and iteratively develop submodels. This process is also hierarchical as the categorical
formalism implies that a submodel may itself be the composition of still more primitive models. Furthermore,
as discussed in Section 2.2, the implementation of the categorical framework can reduce code complexity
and errors, since local changes to models correspond to local changes in the code base.

Advantages to the scientiﬁc process. The scientiﬁc process relies on transparent communication
and critique of models, and a common problem is that the shortest description of a model is the code
itself rather than the theoretical model description. While the code is precise, it is often not easily or
eﬃciently understood, even by proﬁcient programmers. Strategies such as the Overview, Design Concepts,
and Details (ODD) Protocol alleviate these strains on the scientiﬁc process by establishing documentation
conventions and encouraging the assumptions and theoretical underpinnings of a model to be made rigorous
and communicable [11]. Our framework takes this strategy a step further by grounding the model description
in an algebraic structure. The visual diagrams used to communicate models, such as those in Figures 2 and 3,
then become rigorous enough to be unambiguously translated into code. By making a model’s theoretical
formulation more visible and more tightly bound to its software implementation, the compositional approach
helps modelers identify components or interactions that are unnecessarily complicated, do not properly reﬂect
domain knowledge, or depend upon unreasonably strong assumptions.

The compositional framework for modeling also streamlines the scientiﬁc process by prioritizing the
independence of submodels. Submodels can be eﬃciently tested and substituted without aﬀecting other
submodels in a composite. For example, Figure 3(c-e) exempliﬁes updating the bloodmeal submodel without
aﬀecting the host and vector submodels. This feature is practical for (1) model formulation, in which
parsimonious but empirically adequate models are found by testing diﬀerent combinations and complexities
of submodels, and (2) policy making, where it is important that policies be robust to variations in submodels
and other modeling assumptions. Works such as [8] and [25] demonstrate the importance of testing multiple
combinations of submodels. The categorical approach and its implementation in software disambiguates and
assists this process.

Theoretical advantages. The compositional framework also provides theoretical advantages to scien-
tiﬁc modeling. Because the syntax and semantics of composition are explicitly and independently repre-
sented, the composition syntax is a venue for exchanging expert knowledge, while the choice of submodels
can be left to speciﬁc domain experts or a model selection process. For example, the syntax proposed in
Figure 3(f) asserts that the submodels for the vector dynamics must include a susceptible, an infected but

8

not yet infectious, and an infectious population. It also speciﬁes that the model of vector dynamics is broken
down into submodels for the aquatic stages and for the epidemic in adults. Additionally, the composition
syntax can be analyzed for mechanistic or causal dependencies. For instance, the syntax given in Figure 3(f)
expresses that the host and vector population can only aﬀect each other through the bloodmeal.

Finally, mathematical properties of these compositional modeling frameworks translate directly into im-
portant consistency properties for model construction. The associativity and symmetry properties of operads
and their algebras imply that the order of composing submodels does not aﬀect the ﬁnal model. Similarly,
the functoriality of reinterpretation rules, such as the law of mass action, implies that reinterpretation and
composition can be done in any order, which again does not aﬀect the ﬁnal result.

3 Type systems for open Petri nets

3.1 Typed Petri nets

Category theory emphasizes the importance of morphisms or maps between mathematical objects. In this
section, we demonstrate how morphisms between Petri nets can be used to deﬁne typed Petri nets.

Petri nets can represent domain-speciﬁc type systems. For example, the Petri net Pinfectious in Figure 4(a)
deﬁnes a type system for an infectious disease model. It consists of a single species type and three transi-
tion types corresponding to (1) spontaneous changes in infection status; (2) spontaneous changes between
non-infection-related strata, such as movement between patches or changes in quarantine status; and (3)
interactions between a pair of individuals.
In contrast, the Petri net Pvector-borne depicted in Figure 4(c)
represents a type system for a vector-borne disease model and has two species types corresponding to the
vector and host populations.

A morphism between Petri nets is a map of places, transitions, input arcs, and output arcs that preserves
the arities of the arcs and respects the sources and targets of the arcs.2 For example, the source of an input
arc i in the domain Petri net must map to the source of the arc to which i is mapped. Given a Petri net
Ptype deﬁning the type system, a typed Petri net is a Petri net P together with a morphism φ : P
Ptype.
Figure 4(b) and Figure 5 give examples of Petri nets typed by Pinfectious.

→

All of the Petri nets typed by a given type system form a slice category of the category of whole-grain
Petri nets. The mathematical features of slice categories guarantee important modeling features. First,
typed Petri nets are practical for model checking. A Petri net typed by Pinfectious assigns each transition
to be a spontaneous change in infection, a spontaneous change in strata, or an interaction. The type of a
transition must be consistent with the number of input and output arcs connected to it. For example, a
typing by Pinfectious ensures that a transition with interaction type has two inputs and two outputs. Second,
typed Petri nets facilitate high-level critiques of a model. For example, a model typed by Pvector-borne cannot
incorporate vertical transmission from parents to oﬀspring or sexual transmission in either hosts or vectors.
This property may contradict known transmission pathways for a speciﬁc disease and thus motivate a revision
of the model and the type system. Third, features of the type system may also directly translate into features
of the typed Petri net. For example, because each transition in Pinfectious has the same number of inputs and
outputs, any Petri net typed by Pinfectious conserves the total population over time.

Typed Petri nets also provide guardrails for composing models. A Petri net typed by Pvector-borne must
assign each species to be of either vector-type or of host-type thereby separating the vector and host pop-
ulations. The type system also ensures that interactions only occur between vectors and hosts and that no
SV
vectors spontaneously become hosts and vice versa. For example in Figure 4(d), the transition SH →
which turns susceptible hosts into susceptible vectors is forbidden by the type-system. When composing open
Petri nets typed by the same type system via the process described in Section 2.1, we can add a constraint
that identiﬁed species must have the same type. With this check in place, a host subpopulation will not be
identiﬁed with a vector subpopulation during model composition. Furthermore, under this constraint, the
composition of typed Petri nets retains a typing.

Ultimately, a domain-speciﬁc typing can guarantee meaningful properties of a model and prevent novice

users or automated systems from generating models that contradict common sense or domain expertise.

2Such morphisms of Petri nets, also called etale maps, are deﬁned in [15, Section 2.2].

9

Figure 4: (a) A type system, Pinfectious, representing Petri nets for infectious diseases. It has a single place
type and three transition types corresponding to changes in infection status (yellow), changes between strata
(blue), and interactions (purple). (b) An SIR disease model typed by Pinfectious. Colors indicate the type of
each place and each transition. For example, the transition mediating the infected and recovered population
is of type “change in disease status” while the three transitions from each species to itself is of type “change
in strata,” since a change in strata does not aﬀect an individual’s infection status.
(c) A type system,
Pvector-borne, representing Petri nets for vector-borne diseases. It has two place types corresponding to the
vector and host populations and speciﬁes that interactions can only occur between vectors and hosts. (d)
An SIS disease model typed by Pvector-borne. There are two places typed by the host population representing
a susceptible host population and an infected host population. Likewise for the vector population. The
transitions indicated in red have no valid typing and thus are forbidden by the type system. The transition
2IV would allow vectors
SH →
to infect each other. Both of these transitions violate established scientiﬁc knowledge, and the type-system
provides guardrails to prevent such modeling errors.

SV would change the species of an individual, while the transition IV + SV →

10

SIRPopHostVectSHSVIHIVSIRa)b)c)d)𝐋𝐞𝐠𝐞𝐧𝐝Host PopulationVector  PopulationChange of Disease State Host/VectorChange of Strata State Host/VectorInteraction EffectForbidden Transition(b) A palette of stratiﬁcation schemes typed by Pinfectious.

Figure 5: (a) A palette of disease models typed by Pinfectious including (a.i) a SIS model and (a.ii) a SVIIvR
(b.i)
model which incorporates vaccination.
Interactions cannot occur between individuals in the place
Stratiﬁcation by quarantine/isolation status.
representing the quarantining/isolating population.
Interactions can occur
between children and adults. Although not pictured here, the map on arcs speciﬁes if adults infect children
or vice versa. Note that there are no transitions with type “change in strata,” representing that in this model
children do not spontaneously become adults and vice versa. (b.iii) The ﬂux model for spatial dynamics.
Each place represents a diﬀerent patch. Individuals can move between patches, and interactions only occur
(b.iv) The simple trip model of spatial dynamics. Pij represents a
between people in the same patch.
Individuals can travel between
population that is currently in patch i and whose residence is patch j.
patches but not change their residence. Interactions only occur between people currently in the same patch.
In both (a) and (b), transitions are colored to indicate the typing by Pinfectious, the typed system depicted in
Figure 4(a).

(b.ii) Stratiﬁcation by age.

11

SIi)VRIvSRISIVIvSa)Q~Qb)ii)i)P1P2iii)CAii)iv)P11P12P21P22Figure 6: (a) A stratiﬁed model over Pinfectious is the pullback of a typed epidemiological model Pdisease →
Pinfectious. (b) The stratiﬁed model of the SIR model
Pinfectious and a typed stratiﬁcation scheme Pstrata →
depicted in Figure 4(b) and the quarantining model depicted in Figure 5(b.i).

3.2 Stratiﬁed compartmental models

A recurring theme in scientiﬁc modeling is the importance of stratiﬁed models, in which local dynamics are
reproduced in multiple strata and strata interact according to a speciﬁed scheme. For example, Citron et
al [8] compare stratiﬁed models deﬁned by a choice of local epidemiological dynamics (SIR, SIS, or Ross-
Macdonald) and a choice of stratiﬁcation by location (the ﬂux or simple trip models of metapopulation
dynamics). Typed Petri nets oﬀer a general methodology for stratifying models, which contrasts with the
by-hand approach taken in [8].

→

→

Consider two typed Petri nets, the unstratiﬁed disease model φ : P

Ptype and a stratiﬁcation scheme
φ(cid:48) : P (cid:48)
Ptype. The stratiﬁcation of P by P (cid:48) is deﬁned to be the Petri net with places (resp. transitions,
input arcs, and output arcs) consisting of pairs of places (resp. transitions, input arcs, and output arcs) in
P and P (cid:48) which have the same type. Because the morphisms φ and φ(cid:48) respect the source and target maps
from arcs to species and transitions, the source and target maps in the stratiﬁed model are well-deﬁned.
Figure 6(b) gives an example of stratifying the SIR model by a model of quarantine/isolation status. In
the stratiﬁed model, the place (S, Q) represents the susceptible and quarantining population while (S,
Q)
∼
represents the susceptible and not quarantining population. The transition mediating the places (S,
Q) and
Q) represents the infection transition in the SIR model and the interaction between non-quarantining
(I,
people in the stratiﬁcation scheme. Because these transitions are both of interaction type and mediate
species of the same type, they are paired in the stratiﬁed model. Figure 5 gives a palette of additional
epidemiological models (SIS and SVIIvR) and stratiﬁcation schemes (quarantine status, age, the ﬂux model
of spatial dynamics, and the simple trip model of spatial dynamics).

∼

∼

The categorical abstraction standardizes the deﬁnition of model stratiﬁcation, and its implementation in
AlgebraicPetri automates the construction of stratiﬁed models under the constraints of the expert-chosen
type system. Because the size of stratiﬁed models grows quadratically with respect to the sizes of the
component models, this framework streamlines the accurate implementation of stratiﬁed models as well as
the clear communication and critique of stratiﬁed models via their components. Many of the advantages
described in Section 2.4 also apply to the categorical representation of model stratiﬁcation.

Comparison with [8] highlights the clarity and eﬃciency that our approach brings to the modeling work-
ﬂow. The authors of [8] investigate the choice of applying candidate models of movement between subpop-
ulations to disease models when calibrated to real-world data sets. They combine three standard disease
models (SIR, SIS, and Ross-Macdonald) with two choices of movement dynamics (ﬂux and simple trip).
In the ﬂux model, people relocate to diﬀerent patches at ﬁxed rates. In the simple trip model, people are
assigned a home patch and temporarily visit other patches. The ﬂux and simple trip models on two patches
are expressed as Petri nets in Figure 5(b.iii, b.iv). In [8] the adjustments to the disease models are done
manually and do not express a formal relationship between the adjusted models and their component disease
and movement models. By contrast, our approach to model stratiﬁcation formalizes this construction. In
particular, the stratiﬁcation of the Petri nets for the SIR and SIS disease models (Figure 4(b) and Fig-
ure 5(a.i)) by the Petri nets for the ﬂux and simple trip movement models mirror the diﬀerential equation
models deﬁned in [8, Equations 6, 7, 9, 10]. Our software implementation of the mathematical ideas pre-
sented in this section can then be applied to automatically generate the stratiﬁed models from the palette of
component models. As shown in the Supplementary Material, this implementation greatly reduces the size

12

S,QI,QR,QS,~QI,~QR,~Qa)b)<latexit sha1_base64="/EJXIRXbqU+q3B90Akfz5KRnYbE=">AAAEi3iclVPbbtNAEHWTAG2g0MIT4sVKVMRDmtrpBVoR0TQ0iaO0FEIubRxF6/W6WWKv3d11c5P/gB/kC/gAfoCNm9ImQUKMZO1ozjkz6zNaw7Mx44ryYykSjT14+Gh5Jf74yerTZ2vrz+vM9SlENejaLm0agCEbE1TjmNuo6VEEHMNGDaOXn+CNa0QZdslXPvRQ2wGXBFsYAi5KnfXId3lD7nLusYOtrau0jwU5DTxv68NVtjHKsdP8wDjJ9/uVfPlzUx1As1jfMUt8ZJbKXbNoO6BR71nVslkpsEHlY45pdg43q6FmMNGUh7fYscCOrGZhoFw0uwra/rILi/V9zVZYY3TMTtTJqU3PHDvBfazh/rBSYhgKrlGs4U+E4XNnv4eq2h4alv3zhmpr31x8USyMQLHe04i6b9Wn+mGoH8zrDafAL4Rec06vobNrQ1y+01RDTf//Z6pmXG/FdQNdYjLmuDeCZhBfGZ91dAfwLrPGjFNhuIWRGQTya3kOAIGs6zN8EzMkthqS75UxsRAUi/NZIPrrgFK337Ko62TVzUxK5m42s5lpzyKZTXURMQHrIjMlT7W3DPWOkdBtCl1KEE2MAYFdl2YhIhzRlOy5LKuk1cxukJJNCvpZ4hK00Otf09QJQ0fE/GOY3u6sJZW0Eoa8mKjTJClN46yz9lM3Xeg74mbQBoy1VMXj7TGgHEMbiZY+Qx6APXCJWiIlwEGsPQ6fTSBviIopWy4VH+FyWL2vGAOHsaFjCGbo/zw2Kf4Na/ncetcWy/J8jgi8GWT5tvhrefIGZRNTsUZ7KBIAKRZ3lWEXUACFvbNTrsIHGcTjwhl13ofFpJ5Jq3vpnc+Z5OHR1KNl6ZWUkN5IqvRWOpRK0plUk2DkV/RlNBFNxlZj27GD2PsbamRpqnkhzUTs+Ddnh3M4</latexit>PstratiﬁedPstrataPdiseasePinfectiousyof the Petri nets that must be encoded by hand. Additionally, this approach makes it easier to extend the
methods of [8], since new stratiﬁcation schemes, once deﬁned and typed, can be seamlessly integrated into
the model construction, calibration, and analysis pipeline, instead of requiring experts to manually adjust
each candidate disease model by each candidate movement model.

Mathematically, a stratiﬁed model is a pullback of whole-grain Petri nets, or equivalently a product
in the slice category over the given type system. Properties of these well-studied categorical formalisms
immediately verify useful properties of stratiﬁed Petri nets. For example, consider stratifying a disease
model by quarantine status and by spatial dynamics. Since pullback is an associative and commutative
binary operation, the order of stratiﬁcation does not aﬀect the ﬁnal model. That is, the following procedures
are equivalent: stratifying the disease model by spatial dynamics and then by quarantine status, stratifying
the disease model by quarantine status and then by spatial dynamics, and stratifying the disease model by
the stratiﬁcation of spatial dynamics by quarantine status (or vice versa).

4 Calibrating and analyzing models

The purpose of epidemiological modeling during an unfolding pandemic is to transform sparse data into
eﬀective policy decisions. The robustness of this process depends on understanding how adjusting a model
aﬀects its accuracy in representing the data (model calibration) and the policy outcomes it evidences (model
analysis). In Section 2, we described the mathematics and implementation of specifying models by composing
open Petri nets and other diﬀerential equation models. In this section, we show how this modeling framework
streamlines the iterative loop of model speciﬁcation, calibration, and analysis in the context of composing
Petri nets, clarifying several of the advantages sketched in Section 2.4.

Since our approach decouples disease models based on Petri nets from the implementation of simulators
in code, analysis tools can be deﬁned directly on the combinatorial data structures representing the Petri
nets. A tool deﬁned once can thus be applied with equal ease to explicitly deﬁned Petri nets, compositions of
Petri nets, hierarchically deﬁned Petri nets, and stratiﬁed Petri nets. One class of analysis tools comes from
integrating AlgebraicPetri with the SciML suite, which provides procedures for parameter estimation and
sensitivity analysis. We illustrate how this integration tightens the modeling workﬂow using the example of
the SVIIvR Petri net model deﬁned in Figure 2.

AlgebraicPetri includes a method that converts generic Petri nets into the reaction network format sup-
ported by Catalyst, a library in the SciML ecosystem which uses symbolic algebra from the ModelingToolkit
framework to represent chemical reaction networks [17]. This method can be applied independently of how
the Petri net was constructed. For example, we can apply it to the modularly constructed SVIIvR model
from Section 2.1 and use Catalyst to ﬁt the parameters according to COVID-19 infection data gathered from
the US state Georgia over a ﬁve month period [22]. In this case, there is an order of magnitude diﬀerence
between the estimated initial population and the true initial population. This mismatch may trigger an
adjustment to the underlying model such as by a parallel reﬁnement of one or more of the submodels. The
adjusted models can be fed into the same calibration pipeline with no modiﬁcations to the analysis code.

Following calibration, a model can be analyzed to suggest policy decisions and predict policy outcomes.
A seamless process for analyzing models as they evolve is critical to test the robustness of these decisions
and outcomes. As an example analysis, we integrate the proportion of the non-infectious population over a
simulation of the SVIIvR model. We also compute the sensitivity of this outcome to the transition rates of the
Petri net using the tools in ForwardDiﬀ [18]. In Figure 8, the sensitivity results are visualized by a heatmap
which explicitly connects the results of the analysis and the underlying Petri net model. Adjustments to the
underlying model—such as adding or removing transitions, changing transition rates, or substituting one
submodel for another—are immediately reﬂected in the analysis. This tight feedback loop gives practical
and visual tools for determining which policy decisions or outcomes are robust to model changes. In these
examples, the analysis is treated externally to the model with the analysis being run directly on the ODE
derived from the Petri net. However, in future work we intend to incorporate explicit representations of
behavioral analyses into the compositional framework and those which are informed by the structure of
composition. These analyses may be purely observational, actively control submodels in the composite, or
check satisfaction of contracts as formalized in [4].

13

(a) Result from ﬁtting to Georgia infection data

(b) Petri net trajectory using the ﬁt parameters

Figure 7: Plots demonstrating the parameter estimation provided by integration with Catalyst. This example
assumes a universal recovery rate of 1
14 and an initial vaccinated population of zero. The remaining rates
and initial populations are estimated.

Transition

γU
ν
γV
βV V
βU V
βV U
βU U

Sensitivity
10−2
10−3
10−6

5.27
4.29
2.10

×
×
×
2.18
5.89
4.61
8.49

−
−
−
−

10−10
10−7
10−6
10−2

×
×
×
×

(a) Table of transition sensitivities

(b) Petri net heatmap of sensitivities

Figure 8: In this example, the model outcome is the integral of the non-infectious populations over the course
of the pandemic, and the sensitivities are measured for the parameters ﬁt in Figure 7. The sensitivities are
tabulated in (a) and visualized as a heatmap in (b). In the Petri net heatmap, red and blue colors correspond
to positive and negative sensitivities, respectively.

14

Sβ_{UU}1β_{UV}1ν1Vβ_{VU}1β_{VV}1I_U11γ_U1I_V11γ_V1R2111121115 Conclusion

Scientiﬁc modeling is an iterative process of proposing, implementing, simulating, calibrating, analyzing,
and comparing models. We presented a mathematical framework and software tools to accelerate the mod-
eling process for compartmental models of infectious disease, in an eﬀort to reduce the response time to
emerging pandemics. Our framework is grounded in applied category theory and captures the algebraic and
compositional structure of scientiﬁc models in a way that can be easily conveyed to both human scientists
and computer systems. As a result, complex models can be speciﬁed compositionally using the syntax of
wiring diagrams and algebraic operations or through the stratiﬁcation of typed models. Our approach makes
model structure a readily computable resource, which streamlines numerous downstream analyses, such as
parameter estimation and sensitivity analysis. Together, the mathematical and computational features of
our approach simplify and accelerate the iterative modeling process.

The structuralist approach to epidemiological modeling suggests many directions for future work. It can
be extended to incorporate additional model semantics, such as stock-and-ﬂow diagrams as an alternative
to Petri nets, or stochastic and jump diﬀerential equations as complements to ODEs and DDEs. As demon-
strated, the compositional structure simpliﬁes the speciﬁcation and visibility of multi-faceted models. A
natural next step would be to investigate how compositional structure can be exploited in the mathematical
and computational analysis of the models. For instance, parallel computations could be organized using the
hierarchical decomposition already inherent in the model speciﬁcation.

Funding The authors were supported by the following DARPA Awards W911NF2110323 (Fairbanks),
HR00112090067 (Libkind and Patterson), and HR00111990008 (Baas and Halter) along with AFOSR Award
FA9550-20-1-0348 (Patterson).

Acknowledgements The authors thank Xiaoyan Li, Nathaniel Osgood, David Smith, and Sean Wu for
valuable insights into the methods and workﬂows of professional epidemiological modelers. We are also
grateful to John Baez for insights into categories and pullbacks of Petri nets. We thank Alexandra Trani
and Sean Wu for thorough reviews of the manuscript.

References

[1] John C. Baez and Kenny Courser. Structured cospans. Theory and Applications of Categories,

35(48):1771–1822, 2020.

[2] John C. Baez and Jade Master. Open Petri nets. Mathematical Structures in Computer Science,

30(3):314–341, 2020.

[3] John C. Baez and Blake S. Pollard. A Compositional Framework for Reaction Networks. Reviews in

Mathematical Physics, 29(09):1750028, 2017.

[4] Georgios Bakirtzis, Cody H. Fleming, and Christina Vasilakopoulou. Categorical semantics of cyber-

physical systems theory. ACM Transactions on Cyber-Physical Systems, 5(3):1–32, Jul 2021.

[5] Gergo Bohner, Gaurav Venkataraman, and Harrison Wilde. COEXI(S)T: Modelling COVID-19 exit
strategies for policy makers in the United Kingdom. https://github.com/gbohner/coexist/, 2020.

[6] P. Boutillier, J. Feret, J. Krivine, and W. Fontana. The Kappa language and tools.

https:

//kappalanguage.org/, 2021.

[7] Bob Carpenter, Andrew Gelman, Matthew D. Hoﬀman, Daniel Lee, Ben Goodrich, Michael Betan-
court, Marcus Brubaker, Jiqiang Guo, Peter Li, and Allen Riddell. Stan: A probabilistic programming
language. Journal of statistical software, 76(1):1–32, 2017.

[8] Daniel T. Citron, Carlos A. Guerra, Andrew J. Dolgert, Sean L. Wu, John M. Henry, David L. Smith,
et al. Comparing metapopulation dynamics of infectious diseases under diﬀerent models of human
movement. Proceedings of the National Academy of Sciences, 118(18), 2021.

15

[9] Brendan Fong. Decorated cospans. Theory and Applications of Categories, 30(33):1096–1120, 2015.

[10] Joseph Friedman, Patrick Liu, Christopher E. Troeger, Austin Carter, Robert C. Reiner, Ryan M.
Barber, James Collins, Stephen S. Lim, David M. Pigott, Theo Vos, Simon I. Hay, Christopher J. L.
Murray, and Emmanuela Gakidou. Predictive performance of international COVID-19 mortality fore-
casting models. Nature Communications, 12(1):2609, 2021.

[11] Volker Grimm, Uta Berger, Donald L. DeAngelis, J. Gary Polhill, Jarl Giske, and Steven F. Railsback.
The ODD protocol: A review and ﬁrst update. Ecological Modelling, 221(23):2760–2768, Nov 2010.

[12] Stefan Hoops, Sven Sahle, Ralph Gauges, Christine Lee, J¨urgen Pahle, Natalia Simus, Mudita Singhal,
Liang Xu, Pedro Mendes, and Ursula Kummer. COPASI: a complex pathway simulator. Bioinformatics,
22(24):3067–3074, 2006.

[13] Michael Hucka, Andrew Finney, Herbert M. Sauro, Hamid Bolouri, John C. Doyle, Hiroaki Kitano,
Adam P. Arkin, Benjamin J. Bornstein, Dennis Bray, Athel Cornish-Bowden, et al. The Systems
Biology Markup Language (SBML): a medium for representation and exchange of biochemical network
models. Bioinformatics, 19(4):524–531, 2003.

[14] Aaron A. King, Dao Nguyen, and Edward L. Ionides. Statistical inference for partially observed Markov

processes via the R package pomp. Journal of Statistical Software, 69(12), 2016.

[15] Joachim Kock. Elements of Petri nets and processes. In Applied Category Theory 2020, 2020.

[16] Sophie Libkind, Andrew Baas, Evan Patterson, and James Fairbanks. Operadic modeling of dynamical

systems: Mathematics and computation. In Applied Category Theory 2021, 2021.

[17] Yingbo Ma, Shashi Gowda, Ranjan Anantharaman, Chris Laughman, Viral Shah, and Chris Rackauckas.
ModelingToolkit: A composable graph transformation system for equation-based modeling, 2021.

[18] J. Revels, M. Lubin, and T. Papamarkou.

Forward-mode automatic diﬀerentiation in Julia.

arXiv:1607.07892, 2016.

[19] F.R. Sharpe and Alfred J. Lotka. Contribution to the analysis of malaria epidemiology. IV. Incubation

lag. In The Golden Age of Theoretical Ecology: 1923–1940, pages 348–368. Springer, 1978.

[20] D. L. Smith, T. A. Perkins, R. C. Reiner, C. M. Barker, T. Niu, L. F. Chaves, A. M. Ellis, D. B.
George, A. Le Menach, J. R. C. Pulliam, D. Bisanzio, C. Buckee, C. Chiyaka, D. A. T. Cummings,
A. J. Garcia, M. L. Gatton, P. W. Gething, D. M. Hartley, G. Johnston, E. Y. Klein, E. Michael, A. L.
Lloyd, D. M. Pigott, W. K. Reisen, N. Ruktanonchai, B. K. Singh, J. Stoller, A. J. Tatem, U. Kitron,
H. C. J. Godfray, J. M. Cohen, S. I. Hay, and T. W. Scott. Recasting the theory of mosquito-borne
pathogen transmission dynamics and control. Transactions of the Royal Society of Tropical Medicine
and Hygiene, 108(4):185–197, 2014.

[21] David I. Spivak. The operad of wiring diagrams:

formalizing a graphical language for databases,

recursion, and plug-and-play circuits. arXiv:1305.0297, 2013.

[22] The New York Times. Coronavirus (COVID-19) data in the United States. https://github.com/

nytimes/covid-19-data, 2021. Retrieved September 3, 2021.

[23] Dmitry Vagner, David I. Spivak, and Eugene Lerman. Algebras of open dynamical systems on the

operad of wiring diagrams. Theory and Applications of Categories, 30(51):1793–1822, 2015.

[24] U. Wilensky. Netlogo. http://ccl.northwestern.edu/netlogo/, 1999.

[25] Sean L. Wu, Jared B. Bennett, H´ector M. S´anchez C., Andrew J. Dolgert, Tom´as M. Le´on, and John M.
Marshall. MGDrivE 2: A simulation framework for gene drive systems incorporating seasonality and
epidemiological dynamics. PLOS Computational Biology, 17(5):e1009030, May 2021.

16

Supplementary Material

We include the output of two Jupyter notebooks which reproduce the examples in this paper. The ﬁrst
notebook Compositional methods of model speciﬁcation implements the examples from Section 2. The second
notebook Type systems for open Petri nets implements the examples from Section 3. These notebooks along
with the code for the calibration and analysis pipeline discussed in Section 4 are available on GitHub at
https://github.com/AlgebraicJulia/Structured-Epidemic-Modeling/.

17

18

Compositional methods of model specificationThis notebook develops compositional models in the style of structured multicospans and undirected wiring diagrams. Itreproduces the examples in Section 2 of An Algebraic Framework for Structured Epidemic Modeling.Structured Multicospans of Petri netsIn this section we specify a SVIIvR disease model as the composition of three submodels:An SIR model for unvaccinated individuals.An SIR model for vaccinated individuals (which we call the VIvR model).A cross-exposure model which dictates the interactions between unvaccinated and vaccinated individuals.This construction follows the figure:First we specify the composition pattern which dictates the interactions between the three submodels. In particular the SIRand VIvR models share the recovered population (R), the SIR and cross-exposure models share the susceptible and infectedunvaccinated populations (S, I), and the VIvR and cross-exposure models share the susceptible and infected vaccinatedpopulations (V, Iv).In [2]:using Catlab, Catlab.CategoricalAlgebra, Catlab.Programs, Catlab.WiringDiagrams, Catlab.Graphics using AlgebraicPetri using AlgebraicDynamics.UWDDynam using LabelledArrays using OrdinaryDiffEq, DelayDiffEq using Plots In [3]:SVIIvR_composition_pattern = @relation (S, V, I, Iv, R) where (S, V, I, Iv, R) begin   SIR(S, I, R)   VIvR(V, Iv, R)   cross_exposure(S, I, V, Iv) end  to_graphviz(SVIIvR_composition_pattern,     box_labels = :name, junction_labels = :variable, edge_attrs=Dict(:len => "1")) Out[3]:19

SIRSIRVIvRVIvcross_exposureNext we define the Petri nets for the component submodels.Sinf_uu1I1rec_u1R21Vinf_vv1Iv1rec_v1R21In [4]:SIR = Open(LabelledPetriNet([:S, :I, :R],   :inf_uu => ((:S, :I) => (:I, :I)),   :rec_u => (:I => :R) ))  Graph(SIR) Out[4]:In [5]:VIvR = Open(LabelledPetriNet([:V, :Iv, :R],   :inf_vv => ((:V, :Iv) => (:Iv, :Iv)),   :rec_v => (:Iv => :R) ))  Graph(VIvR) Out[5]:In [6]:cross_exposure = Open(LabelledPetriNet([:S, :I, :V, :Iv],   :inf_uv => ((:S, :Iv) => (:I, :Iv)),   :inf_vu => ((:V, :I) => (:Iv, :I)),   :vax => (:S => :V) ))  Graph(cross_exposure) Out[6]:20

Sinf_uv1vax1Iinf_vu1V1Iv111111Finally, we compose the component submodels according to the interaction pattern defined by SVIIvR_composition_pattern using the oapply method. The result is the SVIIvR model of disease dynamics whichaccounts for vaccination.Sinf_uu1inf_uv1vax1I1rec_u1inf_vu1RVinf_vv11Iv1rec_v11212111111We additionally calibrate the parameters of this model with Catalyst.jl in the following:https://github.com/AlgebraicJulia/Structured-Epidemic-Modeling/tree/main/param_est.Composite disease model for vector borne diseasesIn this section, we demonstrate composition of general differential equation models for vector-borne diseases. Thiscomposite has three components: disease dynamics in the host population, disease dynamics in the vector population, andthe bloodmeal.As in the previous example, we begin by specifying the composition pattern which specifies the interaction between thethree components. In particular, the host dynamics and the bloodmeal share the infected host population (Ih), while thevector dynamics and the bloodmeal share the infected vector population (Iv). We visualize this composition pattern below.Notice that the disease dynamics in hosts and the disease dynamics in vectors only relate through the bloodmeal.In [7]:SVIIvR = oapply(SVIIvR_composition_pattern, Dict(   :SIR => SIR,   :VIvR => VIvR,   :cross_exposure => cross_exposure )) |> apex  Graph(SVIIvR) Out[7]:21

hostIhbloodmealIvvectorNext, we define the component models as ODEs. For each of the disease dynamics in hosts and vectors we specify a singlemodel which represents the recovery of infected individuals at rates  and  respsectively.For the bloodmeal, we define three model choices for this component. The first bloodmeal model is the law of mass actionapplied to the Petri net in (b) below. (c) gives the ODE interpretation of the Petri net.This model is given by the ODESo the density of infected hosts grows at a rate  proportional to the density of infected vectors. Likewise, the density ofinfected vectors grows at a rate  proportional to the density of infected hosts.The second bloodmeal model is a Ross-Macdonald model given by the ODEwhere  is the biting rate,  is the transmission efficiency from infectious vectors to susceptible hosts,  is the transmissionefficiency from infectious hosts to susceptible vectors,  is the total host population, and  is the total vector population.In [8]:bloodmeal_composition_pattern = @relation (Ih, Iv) where (Ih, Iv) begin   host(Ih)   bloodmeal(Ih, Iv)   vector(Iv) end  to_graphviz(bloodmeal_composition_pattern,  box_labels = :name, junction_labels = :variable) Out[8]:rgIn [9]:host_dynamics = ContinuousResourceSharer{Float64}(1, 1, (u,p,t) -> -p.r*u, [1]); vector_dynamics = ContinuousResourceSharer{Float64}(1, 1, (u,p,t) -> -p.g*u, [1]); ˙IH=λHIV,˙IV=λVIH.λHλVIn [10]:bloodmeal_mass_action = ContinuousResourceSharer{Float64}(2, 2, (u,p,t) -> [p.λₕ*u[2], p.λₕ*u[1]], [1,2])˙IH=abIV(H−IH),˙IV=ac(V−IV)1HIHHabcHV22

In the third bloodmeal model, we extend the Ross-Macdonald model above by using delay differential equations to representthe incubation period for the disease in the mosquito population.Lastly, we compose the component models according to the composition pattern bloodmeal_composition_pattern tospecify three composite models for vector-borne disease dynamics.To illustrate the effect of substituting different choices for the bloodmeal component model, we solve and plot solutions forthe composite models.In [11]:function dudt(u,p,t)    Ih, Iv = u   return [(p.a*p.b/p.H)*Iv*(p.H - Ih), (p.a*p.c)*(Ih/p.H)*(p.V - Iv)] end bloodmeal_RossMacdonald = ContinuousResourceSharer{Float64}(2, 2, dudt, [1,2]); In [12]:function dudt_delay(u,h,p,t)   Ih, Iv = u   Ih_delay, Iv_delay = h(p, t - p.n)   return [(p.a*p.b/p.H)*Iv*(p.H - Ih), (p.a*p.c)*(Ih_delay/p.H)*(p.V - Iv_delay)] end  bloodmeal_delay = DelayResourceSharer{Float64}(2, 2, dudt_delay, [1,2]);  host_delay   = DelayResourceSharer{Float64}(1, 1, (u,h,p,t) -> -p.r*u, [1]); vector_delay = DelayResourceSharer{Float64}(1, 1, (u,h,p,t) -> -p.g*u, [1]); In [13]:malaria_mass_action = oapply(bloodmeal_composition_pattern, Dict(   :host => host_dynamics,   :vector => vector_dynamics,   :bloodmeal => bloodmeal_mass_action ));  malaria_RossMacdonald = oapply(bloodmeal_composition_pattern, Dict(   :host => host_dynamics,   :vector => vector_dynamics,   :bloodmeal => bloodmeal_RossMacdonald ));  malaria_delay = oapply(bloodmeal_composition_pattern, Dict(   :host => host_delay,    :vector => vector_delay,    :bloodmeal => bloodmeal_delay )); In [14]:params = LVector(a = 0.3, b = 0.55, c = 0.15,     g = 0.1, r = 1.0/200, V = 1000.0, H = 2000.0,     n = 10.0,     λₕ = 0., λᵥ = 0.) params[:λₕ] = params.a * params.b / params.H params[:λᵥ] = params.a * params.c / params.H  u0 = [10.0, 100.0] tspan = (0., 365.); In [15]:prob = ODEProblem(malaria_mass_action, u0, tspan, params) 23

sol = solve(prob, Tsit5()) plot(sol,   lw = 2,   label = ["infected hosts" "infected vectors"],   ylabel = "population density", xlabel = "time",    title = "Mass Action Composite Model" ) Out[15]:In [16]:prob_ODE = ODEProblem(malaria_RossMacdonald, u0, tspan, params) sol_ODE = solve(prob_ODE, Tsit5())  plot(sol_ODE,   lw = 2,   label = ["infected hosts - ODE model" "infected vectors - ODE model"],   ylabel = "population density", xlabel = "time",    title = "Ross-Macdonald Composite Models" )   hist(p, t) = u0 alg = MethodOfSteps(Tsit5()) prob_DDE = DDEProblem(malaria_delay, u0, hist, tspan, params) sol_DDE = solve(prob_DDE, alg,abstol=1e-12,reltol=1e-12)  plot!(sol_DDE,   lw = 2,   linestyle = :dash,   label = ["infected hosts - DDE model" "infected vectors - DDE model"], ) Out[16]:24

The plots demonstrate that the mass action bloodmeal model causes the density of infected hosts and infected vectors tovanish, whereas in the Ross Macdonald models the densities stabilize. These observations suggest that the Ross-Macdonaldmodels are better suited to this modeling problem. On the other hand, the ordinary and delay differential equation Ross-Macdonald models reach the same equilibrium, although they exhibit different transient behavior before settling down.This structured approach to model composition benefits the modeling workflow by providing tools to rapidly explorevariations on model strucure in order to evaluate the cost-benefit tradeoffs for different models. In this case, we determinedthat the assumption of mass action is inconsitent with observed phenomena and that the ordinary and delay differentialequation Ross-Macdonald models have equivalent equilibrium behavior. Modelers can thus consider their purpose instudying either transient or equilibrium behavior when deciding if the additional computational requirements of a DDE modelare worth the improved fidelity to the transient phenomena.This interactive model exploration environment where changes in a model's behavior can be tied back to changes in themodel strucure, enables scientists to spend more time on their domain science and less time building, running, and analyzingsoftware systems.25

Graph_typed (generic function with 2 methods)Type systems for open Petri netsThis notebook showcases typed Petri nets and their application in generating stratified models. It reproduces the examplesin Section 3 of An Algebraic Framework for Structured Epidemic Modeling.Typed Petri netsWe establish two Petri nets which are domain-specific type systems for epidemiological modeling. represents a type system for infectious diseases. It has one place representing a single population and threetransitions: . interact representing an interaction between two individuals. . t_disease representing a spontaneous change in disease status. . t_strata representing a spontaneous change in strata.In [2]:using Catlab, Catlab.CategoricalAlgebra, Catlab.Programs, Catlab.WiringDiagrams, Catlab.Graphics.Graphviusing Catlab.Graphics.Graphviz: Html using AlgebraicPetri In [3]:# Helper for graphing typed Petri nets colors = ["#a08eae","#ffeec6", "#a8dcd9", "#ffeec6", "#a8dcd9"]  function def_trans(typed_petri::ACSetTransformation, colors; labels = true)   (p, t; pos = "") -> ("t$t", Attributes(              :label => labels ? Html(flatten(tname(p,t))) : "" ,              :shape=>"square",              :color=>colors[typed_petri[:T](t)],              :pos=>pos)) end  function def_trans(colors = colors; labels = true)   (p, t; pos = "") -> ("t$t", Attributes(              :label => labels ? "$(tname(p, t))" : "" ,              :shape=>"square",              :color=>colors[t],              :pos=>pos)) end  flatten(tname::Symbol) = "$tname"  function flatten(tname::Tuple)     names = split(replace(string(tname), "("=>"", ")"=>"", ":"=>""), ",")     for i in 1:length(names)         name = strip(names[i])         if name[1:2] == "id"             continue         end         return name     end     return "id" end  def_states(p, s; pos="") = ("s$s", Attributes(         :label => sname(p,s) isa Tuple where T ? Html(replace(string(sname(p,s)), ":"=>"", "," => "<BR/>        :shape=>"circle",         :color=>"#6C9AC3",         :pos=>pos ))  Graph_typed(typed_petri::ACSetTransformation, colors = colors; labels = true) = Graph(dom(typed_petri),     make_trans = def_trans(typed_petri, colors; labels = labels),     make_states = def_states ) Out[3]:Pinfectious26

Popinteract2t_disease1t_strata1211On the other hand,  respresents a types sytem for vector-borne diseases. It has two places representing a hostand a vector population. The transitions t_disease and t_strata represent spontaneous changes in disease and stratastatus for hosts and vectors. The single interact transition represents an interaction between a host and a vector.Hostinteract1t_disease1t_strata1Vector1t_disease1t_strata1111111A Petri net typed by  is a Petri net  along with an etale map , which is captured by the data of anACSetTransformation.To make these ACSetTransformations easier to define, we begin by extracting data from the type system .In [4]:infectious_type = LabelledPetriNet([:Pop],   :interact=>((:Pop, :Pop)=>(:Pop, :Pop)),    :t_disease=>(:Pop=>:Pop),   :t_strata=>(:Pop=>:Pop) )  Graph_typed(id(infectious_type)) Out[4]:Pvector−borneIn [5]:vector_borne_type = LabelledPetriNet([:Host, :Vector],   :interact=>((:Host, :Vector)=>(:Host, :Vector)),   :t_disease=>(:Host=>:Host),   :t_strata=>(:Host=>:Host),   :t_disease=>(:Vector=>:Vector),   :t_strata=>(:Vector=>:Vector) )  Graph(vector_borne_type; make_trans = def_trans()) Out[5]:PinfectiousPP→PinfectiousPinfectious27

Our first example of a typed Petri net is the classic SIR model of disease infection. There are three places that are all typedby the single place type Pop, and five transitions. The transition labeled inf represents an infection between asusceptible and an infected individual. The transition labeled rec represents recovery of an infected individual. Thetransitions labeled id represent identity transformations or no change in disease status. However, they are importantbecause in a stratification they may be paired with transitions that represent spontaneous change in strata.Sinf1id1I1rec1id1Rid121111Our second example is of a stratification scheme for stratification by quarantine status. It contains a population of individualsin quarantine/isolation  and a population of individuals not in quarantine/isolation . Individuals can move between thesestrata and also undergo a spontaneous change in their infection status. However, interaction-type transformations can onlyoccur between two individuals in the non-quarantining population.In [6]:s, = parts(infectious_type, :S) t_interact, t_disease, t_strata = parts(infectious_type, :T) i_interact1, i_interact2, i_disease, i_strata = parts(infectious_type, :I) o_interact1, o_interact2, o_disease, o_strata = parts(infectious_type, :O);  infectious_type = map(infectious_type, Name=name->nothing); # remove names to allow for the loose ACSet In [7]:SIR = LabelledPetriNet([:S, :I, :R],   :inf => ((:S, :I)=>(:I, :I)),   :rec => (:I=>:R),   :id => (:S => :S),   :id => (:I => :I),   :id => (:R => :R) )  typed_SIR = ACSetTransformation(SIR, infectious_type,   S = [s, s, s],   T = [t_interact, t_disease, t_strata, t_strata, t_strata],   I = [i_interact1, i_interact2, i_disease, i_strata, i_strata, i_strata],   O = [o_interact1, o_interact2, o_disease, o_strata, o_strata, o_strata],   Name = name -> nothing # specify the mapping for the loose ACSet transform );   @assert is_natural(typed_SIR)  Graph_typed(typed_SIR) Out[7]:QQfIn [8]:quarantine = LabelledPetriNet([:Q, :NotQ],     :id => (:Q => :Q),     :id => (:NotQ => :NotQ),     :enter_q => (:NotQ => :Q),     :exit_q => (:Q => :NotQ),     :interact => ((:NotQ, :NotQ) => (:NotQ, :NotQ)) )  typed_quarantine = ACSetTransformation(quarantine, infectious_type,     S = [s, s],     T = [t_disease, t_disease, t_strata, t_strata, t_interact],     I = [i_disease, i_disease, i_strata, i_strata, i_interact1, i_interact2],     O = [o_disease, o_disease, o_strata, o_strata, o_interact1, o_interact2],     Name = name -> nothing )  @assert is_natural(typed_quarantine) 28

Qid1exit_q1NotQid1enter_q1interact211112Model stratificationThis section presents examples of stratifying one typed model by another to build multi-faceted models.First exampleFirst, we give methods to produce the stratified model of two typed Petri nets. stratify returns the stratified model while typed_stratify returns the stratified model along with a typing of it.Mathematically, these operations correspond to pullbacks, and the pullback method is implemented by Catlab.jl.Graphically, you can see a pullback as shown in the following figure:We apply this method to the SIR and quarantining models. Note that the labels of the places and transitions are pairs with thefirst element in the pair representing information from the disease model and the second element in the pair representinginformation from the stratification scheme. For example, the place labeled (:S, :Q) represents the population ofsusceptible individuals who are in quarantine. The transitions labeled (:id, :exit_q) represents no change (i.e. identitytransformation) in disease status and a change in strata from quarantining to not quarantining. The transition labeled (:inf, :interaction) represents the infection interaction between two individuals who are not quarantining. Graph_typed(typed_quarantine) Out[8]:In [9]:stratify(typed_model1, typed_model2) = ob(pullback(typed_model1, typed_model2))  typed_stratify(typed_model1, typed_model2) =   compose(proj1(pullback(typed_model1, typed_model2)), typed_model1); In [10]:typed_stratified_model = typed_stratify(typed_SIR, typed_quarantine) Graph_typed(typed_stratified_model) Out[10]:29

SQexit_q1IQrec1exit_q1RQexit_q1SNotQenter_q1inf1INotQrec1enter_q11RNotQenter_q1111111112The layout engine used by Graphviz doesn't know about the pullback structure, so it doesn't generate a nice symmetriclayout. Future work could explore algorithms for Petri net layout that use this structure. Below is the same Petri net but with amore systematic layout.Example playgroundNext we give a palette of disease models and a palette of stratification schemes. These can be used to derive a number ofstratified models as well as multiply-stratified modelsPalette of disease modelsOur palette of disease models includes the SIR model implemented above along with the SIS and SVIIvR model picturedbelow:Next, we describe and implement these additional disease models.Our second disease model is the Susceptible-Infected-Susceptible (SIS) model of disease infection, in which there is nolong-lasting immunity and a recovered indivdual is susceptible to reinfection.In [11]:SIS = LabelledPetriNet([:S, :I],   :inf => ((:S, :I)=>(:I, :I)),   :rec => (:I=>:S),   :id => (:S => :S),   :id => (:I => :I), 30

Sinf1id1I1rec1id12111The third disease model is the SVIIvR model defined compositionally and discussed in detail in composition.ipynb. To thismodel we add identity transformations between each place that are typed by spontaneous change in strata.)  typed_SIS = ACSetTransformation(SIS, infectious_type,   S = [s, s],   T = [t_interact, t_disease, t_strata, t_strata],   I = [i_interact1, i_interact2, i_disease, i_strata, i_strata],   O = [o_interact1, o_interact2, o_disease, o_strata, o_strata],   Name = name -> nothing );  @assert is_natural(typed_SIS)  Graph_typed(typed_SIS) Out[11]:In [12]:SVIIvR_composition_pattern = @relation (S, V, I, Iv, R) where (S, V, I, Iv, R) begin   SIR(S, I, R)   VIvR(V, Iv, R)   cross_exposure(S, I, V, Iv) end  SIR = Open(LabelledPetriNet([:S, :I, :R],   :inf_uu => ((:S, :I) => (:I, :I)),   :rec_u => (:I => :R) ))  VIvR = Open(LabelledPetriNet([:V, :Iv, :R],   :inf_vv => ((:V, :Iv) => (:Iv, :Iv)),   :rec_v => (:Iv => :R) ))  cross_exposure = Open(LabelledPetriNet([:S, :I, :V, :Iv],   :inf_uv => ((:S, :Iv) => (:I, :Iv)),   :inf_vu => ((:V, :I) => (:Iv, :I)),   :vax => (:S => :V) ))  SVIIvR = oapply(SVIIvR_composition_pattern, Dict(   :SIR => SIR,   :VIvR => VIvR,   :cross_exposure => cross_exposure )) |> apex;  ts = add_transitions!(SVIIvR, ns(SVIIvR), tname = :id) add_inputs!(SVIIvR, ns(SVIIvR), ts, 1:ns(SVIIvR)) add_outputs!(SVIIvR, ns(SVIIvR), ts, 1:ns(SVIIvR));  typed_SVIIvR = ACSetTransformation(SVIIvR, infectious_type,   S = [s, s, s, s, s],   T = vcat([t_interact, t_disease, t_interact, t_disease,  t_interact, t_interact, t_disease], repeat([t  I = vcat([i_interact1, i_interact2, i_disease, i_interact1, i_interact2, i_disease, i_interact1, i_int  O = vcat([o_interact1, o_interact2, o_disease, o_interact1, o_interact2, o_disease, o_interact1, o_int  Name = name -> nothing );  @assert is_natural(typed_SVIIvR)  Graph_typed(typed_SVIIvR) Out[12]:31

Sinf_uu1inf_uv1vax1id1I1rec_u1inf_vu1id1Rid1Vinf_vv11id1Iv1rec_v11id121211111111111Finally, we define our palette of disease models.We can stratify each of these disease models by the model of quarantining. Note that we omit the labels on the transition toreduce the size of the Petri net. Recall that blue transitions correspond to spontaneous changes in strata, yellow transitionscorrespond to spontaneous changes in disease status, and purple transitions correspond to interactions.SQexit_q1IQrec1exit_q1SNotQenter_q1inf1INotQrec1enter_q111111112In [13]:disease_models = Dict(   :SIR => typed_SIR,   :SIS => typed_SIS,   :SVIIvR => typed_SVIIvR, ); In [14]:typed_model = typed_stratify(disease_models[:SIS], typed_quarantine) Graph_typed(typed_model) Out[14]:In [15]:typed_model = typed_stratify(disease_models[:SVIIvR], typed_quarantine) Graph_typed(typed_model) Out[15]:32

SQvax1exit_q1IQrec_u1exit_q1RQexit_q1VQexit_q1IvQrec_v1exit_q1SNotQvax1enter_q1inf_uu1inf_uv1INotQrec_u1enter_q11inf_vu1RNotQenter_q1VNotQenter_q1inf_vv11IvNotQrec_v1enter_q1111111111111111111221111Palette of stratification schemesOur palette of stratification schemes includes the model of quarantine status (i) already implemented along with a model ofage stratification (ii), and two movement models (iii and iv).Next, we describe and implement these additional stratification schemes.Our second stratification scheme is a stratification by age. In this model, individuals cannot move between strata. Individualscan undergo a spontaneous change in their infection status as well as interact with other individuals in their strata. Adultsand children can also interact. However, the mapping of the input arcs asserts that children infect adults and not vice versa.In [16]:age_stratification = LabelledPetriNet([:Child, :Adult],     :id => (:Child => :Child),     :id => (:Adult => :Adult),     :interact => ((:Child, :Child) => (:Child, :Child)),     :interact => ((:Adult, :Adult) => (:Adult, :Adult)),     :interact => ((:Child, :Adult) => (:Child, :Adult)) )  typed_age = ACSetTransformation(age_stratification, infectious_type,   S = [s, s],   T = [t_disease, t_disease, t_interact, t_interact, t_interact],   I = [i_disease, i_disease, i_interact1, i_interact2, i_interact1, i_interact2, i_interact2, i_interact  O = [o_disease, o_disease, o_interact1, o_interact2, o_interact1, o_interact2, o_interact2, o_interact  Name = name -> nothing # specify the mapping for the loose ACSet transform ); 33

Childid1interact2interact1Adultid1interact21112211Our final two stratification schemes are spatial stratifications with population dynamics, which were studied in Citron et. al,2021. In the flux model of spatial dynamics individuals move between patches and only individuals in the same patch caninteract.Visit1travel1id1interact2Visit2travel1id1interact2111122In the simple trip model of spatial dynamics, individuals are associated to two patches: a "residence" patch and a "currentlyvisiting" patch. Individuals can spontaneously move between visiting a patch and returning home, but they cannot changewhich patch they live in. Only individuals visiting the same patch can interact. This model involves  places and transitions where  is the number of patches. To reduce the complexity of building this model, we build it as the model ofwhere individuals live stratified by the flux model already implemented above. This example highlights that stratified modelscan be built hierarchically, meaning that a stratification scheme can itself be a stratified model. Graph_typed(typed_age) Out[16]:In [17]:flux_metapopulation = LabelledPetriNet([:Visit1, :Visit2],     :travel => (:Visit1 => :Visit2),     :travel => (:Visit2 => :Visit1),     :id => (:Visit1 => :Visit1),     :id => (:Visit2 => :Visit2),     :interact => ((:Visit1, :Visit1) => (:Visit1, :Visit1)),     :interact => ((:Visit2, :Visit2) => (:Visit2, :Visit2)) )  typed_flux = ACSetTransformation(flux_metapopulation, infectious_type,   S = [s, s],   T = [t_strata, t_strata, t_disease, t_disease, t_interact, t_interact],   I = [i_strata, i_strata, i_disease, i_disease, i_interact1, i_interact2, i_interact1, i_interact2],   O = [o_strata, o_strata, o_disease, o_disease, o_interact1, o_interact2, o_interact1, o_interact2],   Name = name -> nothing # specify the mapping for the loose ACSet transform );  Graph_typed(typed_flux) Out[17]:N2O(N2)N34

Live1id_disease1id_strata1interact2interact1interact1Live2id_disease1id_strata1interact2111111221111In [18]:living_model = LabelledPetriNet([:Live1, :Live2],     :id_disease => (:Live1, :Live1),     :id_disease => (:Live2, :Live2),     :id_strata => (:Live1, :Live1),     :id_strata => (:Live2, :Live2),     :interact => ((:Live1, :Live1) => (:Live1, :Live1)),     :interact => ((:Live2, :Live2) => (:Live2, :Live2)),     :interact => ((:Live1, :Live2) => (:Live1, :Live2)),     :interact => ((:Live2, :Live1) => (:Live2, :Live1)) )  typed_living = ACSetTransformation(living_model, infectious_type,   S = [s, s],   T = [t_disease, t_disease, t_strata, t_strata, t_interact, t_interact, t_interact, t_interact],   I = [i_disease, i_disease, i_strata, i_strata, i_interact1, i_interact2, i_interact1, i_interact2, i_i  O = [o_disease, o_disease, o_strata, o_strata, o_interact1, o_interact2, o_interact1, o_interact2, o_i  Name = name -> nothing # specify the mapping for the loose ACSet transform );  Graph_typed(typed_living) Out[18]:In [19]:typed_simple_trip = typed_stratify(typed_flux, typed_living)  simple_trip = stratify(typed_flux, typed_living)  Graph_typed(typed_simple_trip) Out[19]:35

Visit1Live1id1travel1interact2interact1interact1Visit2Live1id1travel1interact2interact1interact1Visit1Live2id1travel1interact211Visit2Live2id1travel1interact21111111111222211111111Finally, we define our palette of stratification schemes.Stratified modelsNow we can stratify any disease model by any stratification scheme. For example, we can stratify the SVIIvR disease modelby the age stratification scheme.In [20]:stratification_scheme = Dict(   :quarantine => typed_quarantine,   :age => typed_age,   :flux => typed_flux,   :simple_trip => typed_simple_trip, ); In [21]:typed_model = typed_stratify(disease_models[:SVIIvR], stratification_scheme[:age]) Graph_typed(typed_model) Out[21]:36

SChildvax1inf_uu1inf_uv1IChildrec_u11inf_vu1inf_uu1inf_vu1RChildVChildinf_vv11IvChildrec_v111inf_vv1inf_uv1SAdultvax1inf_uu1inf_uv111IAdultrec_u11inf_vu1RAdultVAdultinf_vv1111IvAdultrec_v11111111122111122111111111111The process of model stratification automates the labor intensive approach taken in Citron et. al, 2021 for combiningcandidate disease models with candidate movement models in order to test against real-world data.Below we show how the Petri nets for SIR and SIS disease dynamics stratified by the flux and simple trip movement modelsare automatically generated by our approach. When the law of mass action is applied to these Petri nets, we recover theODEs in Equations 6, 7, 9, and 10 of Citron et. al, 2021 modulo the treatment of total vs. proportional populations.SVisit1travel1inf1IVisit1travel1rec11RVisit1travel1SVisit2travel1inf1IVisit2travel1rec11RVisit2travel11111111122SVisit1travel1inf1IVisit1travel1rec11SVisit2travel1inf1IVisit2travel1rec1111111122In [22]:typed_SIR_flux = typed_stratify(disease_models[:SIR], stratification_scheme[:flux])  Graph_typed(typed_SIR_flux) Out[22]:In [23]:typed_SIS_flux = typed_stratify(disease_models[:SIS], stratification_scheme[:flux])  Graph_typed(typed_SIS_flux) Out[23]:In [24]:typed_SIR_simple_trip = typed_stratify(disease_models[:SIR], stratification_scheme[:simple_trip])  Graph_typed(typed_SIR_simple_trip) 37

SVisit1Live1travel1inf1inf1IVisit1Live1rec1travel11inf1RVisit1Live1travel1SVisit2Live1travel1inf1inf1IVisit2Live1rec1travel11inf1RVisit2Live1travel1SVisit1Live2travel1inf11IVisit1Live2rec1travel111RVisit1Live2travel1SVisit2Live2travel1inf11IVisit2Live2rec1travel111RVisit2Live2travel11111111111111111222211111111SVisit1Live1travel1inf1inf1IVisit1Live1rec1travel11inf1SVisit2Live1travel1inf1inf1IVisit2Live1rec1travel11inf1SVisit1Live2travel1inf11IVisit1Live2rec1travel111SVisit2Live2travel1inf11IVisit2Live2rec1travel111111111111111222211111111The SIR and SIS simple trip models are called multiply-stratified or hierarchically-stratified models because the simple tripmodel is itself a stratified model. Fully decomposed, the SIS simple trip model is a 3-way stratification of the SIS diseasemodel, the flux model, and a model of where individuals live. An important property guaranteed by the categorical formalismis that the order of stratification does not affect the final model. For example, the typed Petri net below is isomorphic to thetyped Petri net given in typed_SIS_simple_trip above.Out[24]:In [25]:typed_SIS_simple_trip = typed_stratify(disease_models[:SIS], stratification_scheme[:simple_trip])  Graph_typed(typed_SIS_simple_trip) Out[25]:In [26]:typed_SIS_simple_trip2 = typed_stratify(   typed_stratify(disease_models[:SIS], stratification_scheme[:flux]),    typed_living ) Graph_typed(typed_SIS_simple_trip2) Out[26]:38

SVisit1Live1travel1inf1inf1IVisit1Live1rec1travel11inf1SVisit2Live1travel1inf1inf1IVisit2Live1rec1travel11inf1SVisit1Live2travel1inf11IVisit1Live2rec1travel111SVisit2Live2travel1inf11IVisit2Live2rec1travel111111111111111222211111111ReferencesCitron, Daniel T., et al. "Comparing metapopulation dynamics of infectious diseases under different models of humanmovement." Proceedings of the National Academy of Sciences 118.18 (2021).