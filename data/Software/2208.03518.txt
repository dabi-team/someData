Noname manuscript No.
(will be inserted by the editor)

A Set-Theoretic Decision Procedure for Quantiﬁer-Free,
Decidable Languages Extended with Restricted Quantiﬁers

Maximiliano Cristi´a · Gianfranco Rossi

2
2
0
2

g
u
A
6

]

O
L
.
s
c
[

1
v
8
1
5
3
0
.
8
0
2
2
:
v
i
X
r
a

the date of receipt and acceptance should be inserted later

Abstract Let LX be the language of ﬁrst-order, decidable theory X . Consider
the language, LRQ(X ), that extends LX with formulas of the form ∀ x ∈ A :
φ (restricted universal quantiﬁer, RUQ) and ∃ x ∈ A : φ (restricted existential
quantiﬁer, REQ), where A is a ﬁnite set and φ is a formula made of X -formulas,
RUQ and REQ. That is, LRQ(X ) admits nested restricted quantiﬁers. In this
paper we present a decision procedure for LRQ(X ) based on the decision procedure
already deﬁned for the Boolean algebra of ﬁnite sets extended with restricted
intensional sets (LRIS). The implementation of the decision procedure as part of
the {log} (‘setlog’) tool is also introduced. The usefulness of the approach is shown
through a number of examples drawn from several real-world case studies.

1 Introduction

Restricted quantiﬁers (RQ) are formulas of the following forms:

∀ x ∈ A : φ(x )

∃ x ∈ A : φ(x )

(1)

(2)

where A is a set called quantiﬁcation domain. The ﬁrst form is called restricted
universal quantiﬁer (RUQ), while the second is called restricted existential quantiﬁer
(REQ). The semantics of such formulas is, respectively:

∀ x (x ∈ A ⇒ φ(x ))

∃ x (x ∈ A ∧ φ(x ))

(3)

(4)

RQ are present in formal notations such as B [47], TLA+ [36] and Z [48] making
it important to be able to automatically reason about RQ. In fact, RQ allow to

M. Cristi´a — corresponding author
Universidad Nacional de Rosario and CIFASIS, Rosario, Argentina – E-mail: cristia@cifasis-
conicet.gov.ar

G. Rossi
Universit`a di Parma, Parma, Italy – E-mail: gianfranco.rossi@unipr.it

 
 
 
 
 
 
2

Maximiliano Cristi´a, Gianfranco Rossi

express important program or system properties. For example, one may need to
express that some property, φ, holds for all the users (U ) of a system. Then, it can
be expressed by means of a RUQ:

I

= ∀ u ∈ U : φ(u)
b

Later, one might need to prove that I is a state invariant of that system by
discharging proofs of the form:

I ∧ T ⇒ I

′

(5)

where T is a state transition and I ′ is the result of substituting every state variable
v in I by v ′—i.e., the next-state variable. In this scenario it would be important
if many (or all) of those proofs can be performed automatically.

In a recent article [18] we have presented a decision procedure for a language
based on extensional and intensional sets called LRIS (X ), where X is a ﬁrst-order,
decidable theory. LRIS can express RQ where the inner formula does not contain
other RQ. Then, LRIS can automatically discharge a proof such as (5). However,
in general, LRIS does not allow for nested RQ. For example, if ψ is a formula
depending on a user and a process, the following:

(6)

I2

= ∀ u ∈ U : (∀ p ∈ P : ψ(u, p))
b

where P is the set of processes of the system, is a LRIS formula only if U is
not part of ψ. Consequently, the decision procedure deﬁned for LRIS is unable to
automatically reason about all formulas such as (5) where I is substituted by I2.
Therefore, ﬁnding a decision procedure for formulas of the form (5) but involving
predicates such as I2 would be a valuable contribution to the formal veriﬁcation
community.

In this paper we depart from LRIS (X ) to deﬁne a new language, LRQ(X ),
admitting ﬁnitely nested RQ at any level, when LX is a quantiﬁer-free, ﬁrst-
order, decidable language1. Then, departing from the decision procedure deﬁned
for LRIS we deﬁne a decision procedure for LRQ. In particular, we provide a
precise condition deﬁning the class of decidable formulas where RUQ and REQ
can be arbitrarily nested. The implementation of these results as part of the {log}
(‘setlog’) tool [46] is also brieﬂy discussed. More space is committed to show that
the implementation works in practice by providing several examples of non trivial
properties and veriﬁcation conditions, drawn from real-world case studies, that
{log} is able to deal with.

The paper is structured as follows. Section 2 introduces LRQ by ﬁrst giving
an informal presentation (2.1) and then its formal syntax (2.2) and semantics
(2.3). The solver for LRQ is presented in Section 3. In Section 4 soundness and
completeness (4.1) and termination (4.2) of the solver are proved. Some extensions
to LRQ, helping to avoid the introduction of existential variables, are introduced
in Section 5. The implementation of LRQ and its solver as part of {log} is shown in
Section 6. In that section we also comment on three case studies carried out with
{log} involving RQ. Our results are discussed and compared with similar works in
Section 7. Section 8 gives our conclusions.

1 Although in LRIS (X ), LX can be a quantiﬁed language it make little sense to extend
such a language with RQ. Hence, in this paper we focus on quantiﬁer-free languages that need
to be extended to support at least a restricted form of quantiﬁcation.

A Decision Procedure for Restricted Quantiﬁers

3

2 Formal Syntax and Semantics

This section describes the syntax and semantics of the set-theoretic language of
Restricted Quantiﬁers, LRQ. In other words, LRQ builds RQ from fundamental
concepts drawn from set theory. A gentle, informal introduction is provided in
Section 2.1, followed by the formal presentation of the language.

LRQ is a ﬁrst-order predicate language with terms of sort set and terms des-
ignating ur-elements2. The latter are provided by an external ﬁrst-order theory
X (i.e., LRQ is parametric with respect to X ). X must include: a class ΦX of ad-
missible X -formulas based on a set of function symbols FX and a set of predicate
symbols ΠX (providing at least equality); an interpretation structure IX with do-
IX ; and a decision procedure SATX for
main DX and interpretation function (·)
X -formulas. LRQ(X ) denotes the instance of LRQ based on theory X .

LRQ provides special set constructors, and a handful of basic predicate sym-
bols endowed with a pre-designated set-theoretic meaning. Set constructors are
used to construct both restricted intensional sets (RIS) and extensional sets. Set
elements are the objects provided by X , which are manipulated through the prim-
itive operators that X oﬀers. Hence, LRQ sets represent untyped unbounded ﬁnite
hybrid sets, i.e., unbounded ﬁnite sets whose elements are of arbitrary sorts. LRQ
formulas are built in the usual way by using conjunction and disjunction of atomic
formulas.

2.1 LRQ in a Nutshell

LRQ provides three kinds of set terms: ∅, the empty set; {x ⊔ A}, called extensional
set whose interpretation is {x } ∪ A; and {c : D | φ}, called restricted intensional set
(RIS) whose interpretation is {c : c ∈ D ∧ φ(c)}, where D is called domain and φ is
called ﬁlter. At the same time, LRQ is a parametric language w.r.t. the language
of some theory X . The elements of sets are X elements and the ﬁlters of RIS can
be either X formulas or a very speciﬁc kind of LRQ formulas. X is expected to be
a decidable theory providing at least equality. For example, if X is the theory of
linear integer arithmetic (LIA) then LRQ(X ) will allow to reason about formulas
combining RQ over integer formulas.

In LRQ formulas are conjunctions and disjunctions of LRQ and X constraints.
In turn, LRQ provides the set equality (=), membership (∈) and subset (⊆) rela-
tions, as constraints.

Example 1 If X is the theory of LIA then the following is a LRQ(X ) formula:

min ∈ {y ⊔ S } ∧ {y ⊔ S } ⊆ {x : {y ⊔ S } | min ≤ x }

where min ≤ x is a X constraint.

⊓⊔

LRQ allows the deﬁnition of RUQ in set-theoretic terms by exploiting the

following identity:

∀ x ∈ A : φ(x ) ⇔ A ⊆ {x : x ∈ A ∧ φ(x )}

(7)

2 Ur-elements (also known as atoms or individuals) are objects which contain no elements

but are distinct from the empty set.

4

Maximiliano Cristi´a, Gianfranco Rossi

In this way, in LRQ we can deﬁne a constraint for RUQ as follows:

foreach(x ∈ A, φ)

= A ⊆ {x : A | φ}
b

(8)

Then, the formula of Example 1 can be written more compactly as follows:

min ∈ {y ⊔ S } ∧ foreach(x ∈ {y ⊔ S }, min ≤ x )

Likewise, REQ can also be deﬁned as constraints:

exists(x ∈ A, φ)

= n ∈ A ∧ φ(n)
b

where n is a new variable.

Furthermore, in LRQ, the ﬁlter of a RIS can be a conjunction of X , foreach
and exists constraints. This is an important diﬀerence w.r.t. LRIS [18] because
there, RIS ﬁlters can only be X formulas. The possibility of including foreach and
exists constraints in RIS ﬁlters allows for the deﬁnition of nested RQ (what is not
possible in LRIS ). For example:

∀ x ∈ X : (∀ y ∈ Y : φ(x , y))) ⇔ X ⊆ {x : x ∈ X ∧ (∀ y ∈ Y : φ(x , y))}

⇔ X ⊆ {x : x ∈ X ∧ (Y ⊆ {y : (y ∈ Y : φ(x , y))})}

The latter being equivalent to the following LRQ formula:

foreach(x ∈ X , foreach(y ∈ Y , φ(x , y)))

which can be further simpliﬁed by introducing some syntactic sugar:

foreach([x ∈ X , y ∈ Y ], φ(x , y))

In the next two subsections a formal presentation of LRQ is made and in later

sections its decidability is analyzed.

2.2 Syntax

The LRQ syntax is deﬁned primarily by giving the signature upon which terms
and formulas of the language are built.

Deﬁnition 1 (Signature) The signature ΣRQ of LRQ is a triple hF, Π, Vi where:

– F is the set of function symbols, partitioned as F = FS ∪FX , where FS contains
∅, {· ⊔ ·} and {· : · | ·}, while FX contains the function symbols provided by
the theory X (at least, a constant and the binary function symbol (·, ·)).

– Π is the set of primitive predicate symbols, partitioned as Π = ΠS ∪ ΠT ∪ ΠX
= {set, isX}, while ΠX contains the predicate
b

where ΠS
symbols provided by the theory X (at least =X ).

= {=S , ∈, ⊆} and ΠT
b

– V is a denumerable set of variables, partitioned as V = VS ∪ VX .

⊓⊔

A Decision Procedure for Restricted Quantiﬁers

5

Intuitively, ∅, {· ⊔ ·} and {· : · | ·} are interpreted as outlined at the beginning
of Section 2.1. =X is interpreted as the identity in DX, while (·, ·) will be used to
represent ordered pairs.

Sorts of function and predicate symbols are speciﬁed as follows: if f (resp., π)
is a function (resp., a predicate) symbol of arity n, then its sort is an n + 1-tuple
hs1, . . . , sn+1i (resp., an n-tuple hs1, . . . , sn i) of non-empty subsets of the set {Set, X}
: hs1, . . . , sn+1i (resp., by π : hs1, . . . , sn i).
of sorts. This notion is denoted by f
Speciﬁcally, the sorts of the elements of F and V are the following.

Deﬁnition 2 (Sorts of function symbols and variables) The sorts of the sym-
bols in F are as follows:

∅ : h{Set}i
{· ⊔ ·} : h{X}, {Set}, {Set}i
{· : · | ·} : h{X}, {Set},{ΦRQ}, {Set}i
f : h{X}, . . . , {X}

, {X}i, if f ∈ FX is of arity n ≥ 0.

|

n
{z

}

where ΦRQ represents the set of RQ-formulas deﬁned in Deﬁnition 6. The sorts
of variables are as follows:

v : h{Set}i, if v ∈ VS
v : h{X}i, if v ∈ VX

⊓⊔

Deﬁnition 3 (Sorts of predicate symbols) The sorts of the predicate symbols
in Π are as follows:

=S : h{Set}, {Set}i
=X : h{X}, {X}i
∈: h{X}, {Set}i
⊆: h{Set}, {Set}i
set, isX : h{Set, X}i

⊓⊔

Whenever it is clear from context we will write = instead of =S or =X .

RQ be the set of terms generated by the following

Set

Deﬁnition 4 (RQ-terms) Let T 0
grammar:
T 0
RQ ::= Elem |
Elem ::= TX
Ctrl ::= VX | ´(´ Ctrl ´, ´ Ctrl ´)´
Ext ::= ´∅´
Ris ::= ´{´ Ctrl ´ : ´ Ext ´|´ ΦRQ ´}´
Set ::= Ris

| Ext

VX

VS

|

|

|

´{´ Elem ´⊔´ Ext ´}´

where TX represents the set of non-variable X -terms; ΦRQ is the set of RQ-
formulas deﬁned in Deﬁnition 6; and variables occurring in a Ctrl -term must all
be distinct from each other.

The set of RQ-terms, denoted by TRQ, is the maximal subset of T 0

with the sorts as given in Deﬁnition 2.

RQ complying
⊓⊔

6

Maximiliano Cristi´a, Gianfranco Rossi

If t is a term f (t1, . . . , tn ), f ∈ F, n ≥ 0, and hs1, . . . , sn+1i is the sort of f , then
we say that t is of sort hsn+1i. The sort of any RQ-term t is always h{Set}i or h{X}i.
For the sake of simplicity, we simply say that t is of sort Set or X, respectively. In
particular, we say that a RQ-term of sort Set is a set term, that set terms of the
form {t1 ⊔ t2} are extensional set terms, and that terms of the form {t1 : t2 | φ}
are RIS terms. The ﬁrst argument of an extensional set term is called element part
and the second is called set part. In turn, the ﬁrst argument of a RIS term is called
control term, the second is the domain and the third one is the ﬁlter.

As can be seen in Deﬁnition 4, control terms can be either variables or nested
ordered pairs. The utility of the latter will be precisely motivated and discussed in
Section 5. Note that the domain of a RIS term can be the empty set, a set variable
or an extensional set.

Hereafter, we will use the following notation for extensional set terms: {t1, t2, . . . , tn ⊔

t}, n ≥ 1, is a shorthand for {t1 ⊔ {t2 ⊔ · · · {tn ⊔ t} · · · }}, while {t1, t2, . . . , tn } is a
shorthand for {t1, t2, . . . , tn ⊔ ∅}.

Deﬁnition 5 (RQ-constraints) If π ∈ Π is a predicate symbol of sort hs1, . . . , sn i,
and for each i = 1, . . . , n, ti is a RQ-term of sort hs′

i ⊆ si , then:

i i with s′

1. If π is ⊆, then π(t1, t2) is a RQ-constraint if t2 ≡ {Ctrl : t1 | ΦRQ}, where Ctrl

and ΦRQ are as in Deﬁnition 4.

2. If π is ∈, then π(t1, t2) is a RQ-constraint if t2 is an Ext term as in Deﬁnition

4.

3. If π is =S , then π(t1, t2) is a RQ-constraint if t1 and t2 are Ext terms as in

Deﬁnition 4.

4. If π is any other element of Π, then π(t1, . . . , tn ) a RQ-constraint.

The set of RQ-constraints is denoted by CRQ.

⊓⊔

The RQ-constraints based on symbols in ΠS will be called set constraints. Note

that the conditions on ⊆-constraints forces them to be RUQ as in (7).

Finally, we deﬁne the set of RQ-formulas as follows.

Deﬁnition 6 (RQ-formulas) The set of RQ-formulas, denoted by ΦRQ, is given
by the following grammar:

ΦRQ ::= true | false | ΦX | CRQ | ΦRQ ∧ ΦRQ | ΦRQ ∨ ΦRQ

where ΦX and CRQ represent any element belonging to the class of X -formulas
and RQ-constraints, respectively.
⊓⊔

As can be seen, LRQ is based solely on fundamental concepts of set theory.

Remark 1 (Notation) We will use the following naming conventions, unless stated
diﬀerently: A, B , C , D stand for terms of sort Set; a, b, c, d , x , y, z stand for terms
of sort X; and t, u, v stand for terms of any of the two sorts. A symbol such as ˙A
states that A ∈ V. Finally, n, ni stand for new variables of sort X; and N , Ni for
new variables of sort Set; no dot above them will be used.
⊓⊔

Remark 2 (LRQ vs. LRIS ) As we have pointed out in Section 1, LRQ departs
from LRIS [18]. LRQ is a sublanguage of LRIS except for one modiﬁcation which
extends LRIS. Indeed, LRIS admits the same function and predicate symbols

A Decision Procedure for Restricted Quantiﬁers

7

than LRQ, plus some other or more complex versions of them. For example, in
LRIS RIS terms have a more complex structure and union, intersection, etc. of
RIS terms are available.

However, in LRIS ﬁlters can only be LX formulas. In LRQ ﬁlters can be nested
RQ ending in an LX formula. This extension is crucial to extend the expressiveness
of the language (cf. formula (6)). The restriction on ﬁlters to LX formulas in LRIS
is key to deﬁne a decision procedure for it. If this restriction is lifted, termination
of the decision algorithm is compromised. As we will shown in Section 4, there are
subclasses of formulas admitting nested RQ that do not compromise termination.
⊓⊔

2.3 Semantics

Sorts and symbols in ΣRQ are interpreted according to the interpretation structure
R

= hD, (·)Ri, where D and (·)R are deﬁned as follows.
b

Deﬁnition 7 (Interpretation domain) The interpretation domain D is parti-
tioned as D

= DSet ∪ DX where:
b

– DSet is the set of all hereditarily ﬁnite hybrid sets built from elements in D.
Hereditarily ﬁnite sets are those sets that admit (hereditarily ﬁnite) sets as
their elements, that is sets of sets.
– DX is a collection of other objects.

⊓⊔

Deﬁnition 8 (Interpretation function) The interpretation function (·)R is de-
ﬁned as follows:

– Each sort S ∈ {Set, X} is mapped to the domain DS.
– For each sort S, each variable x of sort S is mapped to an element x R in DS.
– The constant and function symbols in FS are mapped to elements in DS as

follows:
– ∅ is interpreted as the empty set, namely ∅R = ∅
– {x ⊔ A} is interpreted as the set {x R} ∪ AR.
– Let ~x be a vector of variables occurring in c and ~v a vector of other variables,

then the set {c(~x ) : X | φ(~x , ~v)} is interpreted as the set:

{y : ∃ ~x (c(~x ) ∈X X ∧ φ(~x , ~v))}

Note that in RIS terms, ~x are “local” variables whose scope is the RIS itself,
while ~v are “non-local” variables whose scope is the formula where the RIS
is participating in.

– The predicate symbols in Π are interpreted as follows:

– A =S B is interpreted as AR = B R, where = is the identity relation in DSet
– x =X y is interpreted as x R = y R, where = is the identity relation in DX
– x ∈ A is interpreted as x R ∈ AR
– A ⊆ B is interpreted as AR ⊆ B R
– isX(t) is interpreted as t R ∈ DX
– set(t) is interpreted as t R ∈ DSet.

⊓⊔

8

Maximiliano Cristi´a, Gianfranco Rossi

The interpretation structure R is used to map each RQ-formula Φ to a truth
value ΦR = {true, false} in the following way: set constraints (resp., X constraints)
are evaluated by (·)R according to the meaning of the corresponding predicates
in set theory (resp., in theory X ) as deﬁned above; RQ-formulas are evaluated by
(·)R according to the rules of propositional logic. A LRQ-formula Φ is satisﬁable iﬀ
there exists an assignment σ of values from D to the free variables of Φ, respecting
the sorts of the variables, such that Φ[σ] is true in R, i.e., R |= Φ[σ]. In this case,
we say that σ is a successful valuation (or, simply, a solution) of Φ.

3 A Solver for LRQ

In this section we present a constraint solver for LRQ, called SATRQ. The solver
provides a collection of rewrite rules for rewriting LRQ formulas that are proved
to be a decision procedure for some subclasses of LRQ formulas (see Section 4).
As already observed, however, checking the satisﬁability of RQ-formulas depends
on the existence of a decision procedure for X -formulas (i.e., formulas over LX ).

3.1 The Solver

SATRQ is a rewriting system whose global organization is shown in Algorithm 1,
where STEP is the core of the algorithm.

sort infer is used to automatically add ΠT -constraints to the input formula Φ
to force arguments of RQ-constraints in Φ to be of the proper sorts (see Remark
3 below). sort infer is called twice in Algorithm 1: ﬁrst, at the beginning of the
algorithm, and second, within procedure STEP for the constraints that are gener-
ated during constraint processing. sort check checks ΠT -constraints occurring in
Φ: if they are satisﬁable, then Φ is returned unchanged; otherwise, Φ is rewritten
to false.

Algorithm 1 The SATRQ solver. Φ is the input formula.

procedure STEP(Φ)

for all π ∈ ΠS ∪ ΠT : Φ ← rwπ (Φ);
Φ ← sort check(sort infer(Φ))

return Φ
procedure rwπ(Φ)

if Φ = · · · ∧ false ∧ · · · then

return false

else

repeat

let Φ be c1 ∧ · · · ∧ cm
select a π-constraint ci in Φ
apply any applicable rule to ci

until no rule applies to any π-constraint

return Φ

procedure SATRQ(Φ)
Φ ← sort infer(Φ)
repeat

Φ′ ← Φ
Φ ← STEP(Φ)

until Φ = Φ′
Φ is ΦS ∧ ΦX
Φ ← ΦS ∧ SATX (ΦX )

return Φ

STEP applies specialized rewriting procedures to the current formula Φ and
returns either false or the modiﬁed formula. Each rewriting procedure applies a

A Decision Procedure for Restricted Quantiﬁers

9

few non-deterministic rewrite rules which reduce the syntactic complexity of RQ-
constraints of one kind. Procedure rwπ in Algorithm 1 represents the rewriting
procedure for (ΠS ∪ ΠT )-constraints. The execution of STEP is iterated until a
ﬁxpoint is reached—i.e., the formula cannot be simpliﬁed any further. STEP re-
turns false whenever (at least) one of the procedures in it rewrites Φ to false. In
this case, a ﬁxpoint is immediately detected, since STEP(false) returns false.

SATX is the constraint solver for X -formulas. The formula Φ can be seen,
without loss of generality, as ΦS ∧ ΦX , where ΦS is a pure RQ-formula (basically,
a RQ-formula with with no X -formula in it—see Deﬁnition 12) and ΦX is an X -
formula. SATX is applied only to the ΦX conjunct of Φ. Note that, conversely,
STEP rewrites only RQ-constraints, while it leaves all other atoms unchanged.
Nonetheless, as the rewrite rules show, SATRQ generates X -formulas that are
conjoined to ΦX so they are later solved by SATX .

As we will show in Section 4, when all the non-deterministic computations of
SATRQ(Φ) return false, then we can conclude that Φ is unsatisﬁable; otherwise,
we can conclude that Φ is satisﬁable and each solution of the formulas returned
by SATRQ is a solution of Φ, and vice versa.

Remark 3 LRQ does not provide variable declarations. The sort of variables are
enforced by adding suitable sort constraints to the formula to be processed. Sort
constraints are automatically added by the solver. Speciﬁcally, a constraint set(y)
(resp., isX(y)) is added for each variable y which is required to be of sort set (resp.,
X). For example, given B = {y ⊔ A}, sort infer conjoins the sort constraints set(B ),
isX(y) and set(A). If the set of function and predicate symbols of LRQ and LX
are disjoint, there is a unique sort constraint for each variable in the formula. ⊓⊔

3.2 Rewrite Rules

The rewrite rules used by SATRQ are deﬁned as follows.

Deﬁnition 9 (Rewrite rules) If π is a symbol in ΠS ∪ ΠT and p is a RQ-
constraint based on π, then a rewrite rule for π-constraints is a rule of the form
p −→ Φ1 ∨ · · · ∨ Φn , where Φi , i ≥ 1, are RQ-formulas. Each atom matching
p is non-deterministically rewritten to one of the Φi . Variables appearing in the
right-hand side but not in the left-hand side are assumed to be fresh variables,
implicitly existentially quantiﬁed over each Φi . Conjunction has higher precedence
than disjunction.
⊓⊔

A rewriting procedure for π-constraints consists of the collection of all the rewrite
rules for π-constraints. For each rewriting procedure, STEP selects rules in the order
they are listed in Figure 1. The ﬁrst rule whose left-hand side matches the input
π-constraint is used to rewrite it.

Rules whose right-hand side is irreducible indicate that the constraint at the
left-hand side is not rewritten and will remain as it is all the way to the ﬁnal
answer returned by Algorithm 1. In Figure 1, we have made explicit equality in
LX by means of =X . All other instances of = correspond to equality in LRQ (i.e.,
set equality).

As shown in Figure 1, there are rewriting procedures for ⊆-constraints (Subset),
∈-constraints (Membership) and =-constraints (Equality). The Membership and

10

Maximiliano Cristi´a, Gianfranco Rossi

Subset
∅ ⊆ {x : A | φ(x )} −→ true

{a ⊔ A} ⊆ {x : {a ⊔ A} | φ(x )} −→ φ(a) ∧ A ⊆ {x : A | φ(x )}

˙A ⊆ {x : ˙A | φ(x )} −→ irreducible

Membership
a ∈ ∅ −→ false

a ∈ {b ⊔ A} −→ a =X b ∨ a ∈ A

a ∈ ˙A −→ ˙A = {a ⊔ N }

Equality
∅ = ∅ −→ true

˙A = ˙A −→ true

B = ˙A −→ ˙A = B , if B /∈ V

˙A = B −→ ˙A = B , and substitute A by B in the rest of the formula

{a ⊔ A} = ∅ −→ false

∅ = {a ⊔ A} −→ false

{a ⊔ A} = {b ⊔ B } −→

a =X b ∧ A = B
∨ a =X b ∧ {a ⊔ A} = B ∨ a =X b ∧ A = {b ⊔ B } ∨ A = {b ⊔ N } ∧ B = {a ⊔ N }

˙A = B −→ irreducible, if ˙A does not occur elsewhere in the formula

Fig. 1 Rewrite rules for RQ-constraints

(9)

(10)

(11)

(12)

(13)

(14)

(15)

(16)

(17)

(18)

(19)

(20)

(21)

(22)

Equality rules deal only with extensional sets due to the restrictions given in Def-
inition 5. Observe that all other constraints generated by the rules of Figure 1 are
X -constraints which are dealt with by SATX . All the rules in the ﬁgure are bor-
rowed from the LRIS solver [18]. This is important because it simpliﬁes the proof
of some important properties of SATRQ (Section 4).

As can be seen, most of the rules are straightforward. Rule (21) is the main
rule of set uniﬁcation [29]. Set uniﬁcation is pervasive in other logics developed by
the authors [16, 18]. This rule states when two non-empty, non-variable sets are
equal by non-deterministically and recursively computing four cases. These cases
implement the Absorption and Commutativity on the left properties of set theory
[28]. As an example, by applying rule (21) to {1} = {1, 1} we get: (1 = 1 ∧ ∅ =
{1}) ∨ (1 = 1 ∧ {1} = {1}) ∨ (1 = 1 ∧ ∅ = {1, 1}) ∨ (∅ = {1 ⊔ ˙N } ∧ {1 ⊔ ˙N } = {1}),
which turns out to be true (due to the second disjunct).

Rules (9)-(11) process RUQ by implementing (7). Rule (10) iterates over all
the elements of the domain of the RIS until it becomes the empty set or a variable.
In each iteration one of the elements of the domain is proved to verify the ﬁlter
(if not, the rule fails), and a new iteration is ﬁred. If the domain becomes a

A Decision Procedure for Restricted Quantiﬁers

11

variable the constraint is not processed any more. Note that a constraint such as
˙A ⊆ {x : ˙A | φ(x )} is trivially satisﬁed by substituting ˙A by the empty set.
As LRQ, SATRQ is based solely on fundamental concepts of set theory.

Remark 4 Observe that when ⊆ are rewritten only the following are generated:

– φ ∈ ΦX
– A ⊆ {x : A | φ(x )}

3.3 Irreducible Constraints

⊓⊔

When no rewrite rule is applicable to the current RQ-formula Φ and Φ is not false,
the main loop of SATRQ terminates returning Φ as its result. This formula can be
seen, without loss of generality, as ΦS ∧ ΦX , where ΦX contains all (and only) X
constraints and ΦS contains all other constraints occurring in Φ.

The following deﬁnition precisely characterizes the form of atomic constraints

in ΦS .

Deﬁnition 10 (Irreducible formula) Let Φ and φ be RQ-formulas, A ∈ VS , x a
control term (thus it is a term of sort X) and t a term of sort Set. A RQ-constraint
p occurring in Φ is irreducible if it has one of the following forms:

1. A = t, and neither t nor Φ \ {A = t} contain A
2. A ⊆ {x : A | φ(x )}

A RQ-formula Φ is irreducible if it is true or if all of its RQ-constraints are irre-
ducible.
⊓⊔

ΦS , as returned by SATRQ’s main loop, is an irreducible formula. This fact can
be checked by inspecting the rewrite rules presented in Figure 1. This inspection
is straightforward as there are no rules rewriting irreducible constraints and all
non-irreducible form constraints are rewritten by some rule.

It is important to observe that the atomic constraints occurring in ΦS are
indeed quite simple. In particular, all non-variable set terms occurring in the in-
put formula have been removed, except those occurring as right-hand side of =
constraints.

4 Decidability of LRQ Formulas

In this section we analyze the soundness, completeness and termination properties
of SATRQ for diﬀerent subclasses of RQ-formulas.

As we have explained in Remark 2, LRQ is a sublanguage of LRIS except for
the fact that LRQ admits RQ in ﬁlters. We also pointed out that accepting RQ in
ﬁlters poses termination problems; soundness and completeness are not aﬀected.
Actually, as noted in Section 3, all the rules of Figure 1 are rules borrowed from
the LRIS solver. Hence, we will brieﬂy analyze soundness and completeness of
SATRQ and will spend more time analyzing its termination.

As RUQ and REQ play a central role in this work, we provide some syntactic

sugar for them.

(23)

(24)

12

Maximiliano Cristi´a, Gianfranco Rossi

Deﬁnition 11 (Restricted Quantiﬁers) Given a control term x , an extensional
set term A and a formula φ, a restricted universal quantiﬁer (RUQ), noted foreach(x ∈
A, φ), is deﬁned as:

foreach(x ∈ A, φ)

= A ⊆ {x : A | φ(x )}
b

Under the same terms, a restricted existential quantiﬁer (REQ), noted exists(x ∈
A, φ), is deﬁned as:

exists(x ∈ A, φ)

= n ∈ A ∧ φ(n)
b

where all variables occurring in n are fresh variables not occurring elsewhere in
the formula of which the REQ is a part.
⊓⊔

In a RQ: x is called control term or quantiﬁed variable, A is called domain and
φ is called ﬁlter (following the vocabulary of RIS terms). Note that in both RUQ
and REQ, φ must depend on x .

Deﬁnition 12 (Subclasses of ΦRQ) The following are the subclasses of ΦRQ-
formulas for which decidability will be analyzed:

– Φnrq is the subclass of ΦRQ whose elements are nested RQ. The subclasses of

formulas to be analyzed will be subclasses of Φnrq .

ΦX
∀ ::= foreach(Ctrl ∈ Ext, ΦX )
ΦX
∃ ::= exists(Ctrl ∈ Ext, ΦX )
Φmix ::= ΦX
∀ | ΦX
Φnrq ::= true | false | ΦX | Φmix | ΦRQ ∧ ΦRQ | ΦRQ ∨ ΦRQ

∃ | foreach(Ctrl ∈ Ext, Φmix ) | exists(Ctrl ∈ Ext, Φmix )

– Φ∀ is the subclass of Φnrq whose elements are built from ΦX and nested RUQ.

∀ ::= ΦX
Φp
Φ∀ ::= ΦX | Φp

∀ | foreach(Ctrl ∈ Ext, Φp
∀)
∀ | Φ∀ ∧ Φ∀ | Φ∀ ∨ Φ∀

– Φ∃ is the subclass of Φnrq whose elements are built from ΦX and nested REQ.

∃ ::= ΦX
Φp
Φ∃ ::= ΦX | Φp

∃ | exists(Ctrl ∈ Ext, Φp
∃)
∃ | Φ∃ ∧ Φ∃ | Φ∃ ∨ Φ∃

– Φ∃∀ is the subclass of Φnrq whose elements are built from ΦX and nested RQ

where all REQ are before all RUQ (if any).

Φ∃∀ ::= ΦX | exists(Ctrl ∈ Ext, Filter) | Φ∃∀ ∧ Φ∃∀ | Φ∃∀ ∨ Φ∃∀
Filter ::= Φp

∀ | Φp

∃∀

– Φp

RQ is the subclass of Φnrq whose elements are pure RQ-formulas.

Φp
RQ ::= true | false | Φmix | Φp

RQ ∧ Φp

RQ | Φp

RQ ∨ Φp

RQ

Similar deﬁnitions can be given for pure Φ∀, Φ∃ and Φ∃∀ formulas.

⊓⊔

A Decision Procedure for Restricted Quantiﬁers

Example 2 Diﬀerent classes of formulas.

– foreach(x ∈ A, foreach(y ∈ B , x = y)) is a Φ∀ formula.
– exists(x ∈ A, exists(y ∈ B , ¬ x = y)) is a Φ∃ formula.
– exists(x ∈ A, foreach(y ∈ B , x = y)) is a Φ∃∀ formula.
– foreach(x ∈ A, exists(y ∈ B , x = y)) is a Φp
RQ formula.

13

⊓⊔

As can be seen, formulas in Φnrq are conjunctions and disjunctions of X -
formulas and nested RQ; the ﬁlter of the innermost RQ is an X -formula. Note
that not every RQ-constraint can be part of a formula in Φnrq ; the idea is to re-
strict them to be RQ. Hence, basically, we analyze the decidability of RQ-formulas
strictly encoding RQ. However, note that when SATRQ processes a Φnrq -formula it
may generate a formula outside Φnrq . For example, exists(x ∈ ˙A, φ(x )) is rewritten
into n ∈ ˙A ∧ φ(n) which then is rewritten into A = {n ⊔ N } ∧ φ(n), which is not a
Φnrq -formula due to the presence of A = {n ⊔ N }.

Remark 5 (Notation) From now on, we will write foreach([x ∈ A, y ∈ B ], φ) as
a shorthand for foreach(x ∈ A, foreach(y ∈ B , φ)), and exists([x ∈ A, y ∈ B ], φ)
as a shorthand for exists(x ∈ A, exists(y ∈ B , φ)). Besides, foreach(~xn ∈ ~An , φ)
denotes foreach([x1 ∈ A1, . . . xn ∈ An ], φ) and exists(~xn ∈ ~An , φ) denotes exists([x1 ∈
A1, . . . xn ∈ An ], φ), 0 ≤ n (if n = 0 we take φ as the resulting formula).
⊓⊔

With this notation it is easy to see that: in pure Φp

∀ formulas there are only
constraints of the form foreach(~xn ∈ ~An , φ) for some X -formula φ; in pure Φp
∃ for-
mulas there are only constraints of the form exists(~xn ∈ ~An , φ) for some X -formula
φ; and in pure Φp
∃∀ formulas there are only constraints of the form exists(~xn ∈
~An , foreach(~ym ∈ ~Bm , φ)) for some X -formula φ (0 < n, 0 ≤ m).

4.1 Soundness and Completeness

The following theorem ensures that, after termination, the rewriting process im-
plemented by SATRQ preserves the set of solutions of the input formula.
Theorem 1 (Equisatisﬁability) Let Φ be a Φnrq -formula and Φ1, Φ2, . . . , Φn be the
collection of RQ-formulas returned by SATRQ(Φ). Then Φ1 ∨ Φ2 ∨ · · · ∨ Φn is
equisatisﬁable to Φ, that is, every possible solution3 of Φ is a solution of one of the Φi s
and, vice versa, every solution of one of these formulas is a solution for Φ.

Proof The proof rests on a series of lemmas each showing that the set of solutions
of left and right-hand sides of each rewrite rule are the same. Given that the
rewrite rules of Figure 1 are those used to deﬁne the solver for LRIS, then the
lemmas proved for LRIS still apply [18, Appendix C.4]. The only concern with
those lemmas might be the fact that they were proved under the assumption that
RIS ﬁlters do not admit RQ. However, it is trivial to see that all the Membership
and Equality rules and rules (9) and (11) are unaﬀected by the fact that ﬁlters
admit RQ. For the remaining rule, i.e. (10), we reproduce in Appendix A the proof
made for LRIS so readers can check that it do not depend on any limitation over
RIS ﬁlters.
⊓⊔

3 More precisely, each solution of Φ expanded to the variables occurring in Φi but not in Φ,

so as to account for the possible fresh variables introduced into Φi .

14

Maximiliano Cristi´a, Gianfranco Rossi

Theorem 2 (Satisﬁability of the output formula) Any RQ-formula diﬀerent from
false returned by SATRQ is satisﬁable w.r.t. the underlying interpretation structure R.

Proof As we have explained, each disjunct of the formula returned by SATRQ can
be written as ΦS ∧ ΦX , where ΦS is a pure RQ-formula and ΦX is an X -formula.
Since SATX is called on ΦX we know that it is satisﬁable (under the assumption

that SATRQ has not returned false).

Now we prove that ΦS is satisﬁable, too. We know that ΦS is an irreducible
formula (Deﬁnition 10). Then, we have to prove that an irreducible formula is
always satisﬁable. Given that an irreducible formula is a conjunction of irreducible
constraints, we have to prove that all these constraints can be simultaneously
satisﬁed. Constraints of the form ˙A = t are satisﬁed by binding ˙A to t (recall
from Deﬁnition 10 that ˙A does not occur 3in the rest of an irreducible formula);
constraints of the form ˙A ⊆ {x : ˙A | φ(x )} are satisﬁed by substituting the domain
of the RIS by the empty set. Hence, there is always a solution for an irreducible
RQ-formula.

Finally, we prove that ΦS ∧ ΦX can be satisﬁed. Indeed, observe that the
solution for ΦS do not bind variables of sort X and that ΦX do not contain variables
of sort Set. So the values of the solution for ΦX do no conﬂict with the values of
the solution for ΦS .
⊓⊔

The following example shows how Theorem 2 works in practice.

Example 3 Consider the following nested RUQ where φ is an X -formula:

foreach([x ∈ {a ⊔ ˙A}, y ∈ {b ⊔ ˙B }], φ(x , y))

(25)

SATRQ applies (23) and rule (10) twice yielding:

φ(a, b) ∧ foreach(y ∈ ˙B , φ(a, y)) ∧ foreach([x ∈ ˙A, y ∈ {b ⊔ ˙B}], φ(x , y))

Now, it calls SATX (φ(a, b)) because both foreach constraints are irreducible. Thus,
determining the satisﬁability of (25) is reduced to determining the satisﬁability
of φ(a, b) because satisﬁability of the two foreach constraints is guaranteed by
Theorem 2 (with A ← ∅, B ← ∅).
⊓⊔

Thanks to Theorems 1 and 2 we can conclude that, given a Φnrq -formula Φ,
then Φ is satisﬁable with respect to the intended interpretation structure R if
and only if there is a non-deterministic choice in SATRQ(Φ) that returns a RQ-
formula diﬀerent from false. Conversely, if all the non-deterministic computations
of SATRQ(Φ) terminate with false, then Φ is surely unsatisﬁable. Note that these
theorems have been proved for any Φnrq -formula.

4.2 Termination

The problem is that termination of SATRQ cannot be proved for every Φnrq -
formula, as shown by the following example.

A Decision Procedure for Restricted Quantiﬁers

15

Example 4 The following nested RQ where φ is an X -formula, is rewritten as in-
dicated.

foreach(x ∈ {a ⊔ A}, exists(y ∈ {b ⊔ A}, φ(x , y)))

[by rule (10)]

−→ exists(y ∈ {b ⊔ A}, φ(a, y))

∧ foreach(x ∈ A, exists(y ∈ {b ⊔ A} : φ(x , y)))

[by Def. 11, (24)]

−→ n ∈ {b ⊔ A} ∧ φ(a, n) ∧ foreach(x ∈ A, exists(y ∈ {b ⊔ A} : φ(x , y)))

Now there are two cases from n ∈ {b ⊔ A}: n = b and n ∈ A (rule (13)). Let us see
the second one:

n ∈ A ∧ φ(a, n) ∧ foreach(x ∈ A, exists(y ∈ {b ⊔ A} : φ(x , y)))

[by rule (14)]

−→ A = {n ⊔ N } ∧ φ(a, n)

∧ foreach(x ∈ A, exists(y ∈ {b ⊔ A} : φ(x , y)))

[by rule (18)]

−→ A = {n ⊔ N } ∧ φ(a, n) ∧ foreach(x ∈ {n ⊔ N }, exists(y ∈ {b, n ⊔ N } : φ(x , y)))

It is clear that the last foreach is structurally equal to the initial formula. Without
more information about φ this could potentially cause an inﬁnite loop making
SATRQ not to terminate.
⊓⊔

Before presenting the theorems stating termination on diﬀerent subclasses of
Φnrq -formulas, consider the following analysis. Let φ be a Φnrq -formula. If φ = φ1 ∨
φ2, then we prove SATRQ terminates on φ1 and then on φ2. Hence, as concerns
termination, we can consider φ to be a conjunction of Φnrq -formulas. In this case φ
can be written as φS ∧ φX where φS is a pure Φnrq -formula and φX is a X -formula.
We need to prove termination of SATRQ on φS , as termination of SATX on φX is
guaranteed by the assumption that SATX is a decision procedure for LX . Now, if
φS is a disjunction, we prove termination for each disjunct. Hence, in the following
theorems we prove termination of SATRQ on conjunctions of pure RQ-constraints
belonging to diﬀerent subclasses of formulas.

Theorem 3 (Termination on Φ∀ formulas) The SATRQ procedure can be imple-
mented as to ensure termination for every conjunction of pure Φ∀ constraints.

Proof Recall that the only constraint in pure Φ∀ formulas is of the form foreach(~xn ∈
~An , φ), 0 < n and φ ∈ ΦX . First we will prove that SATRQ terminates on these
constraints. The proof is by induction on n.

– Base case. Let φ be a LX formula. We will show that SATRQ terminates on

the following RUQ:

foreach(x ∈ A, φ(x ))

(26)

– A = ∅, this case is trivial as rule (9) terminates immediately.
– A ∈ VS , this case is trivial as rule (11) terminates immediately.
– A = {b ⊔ B }, rule (10) is applied to (26) yielding:

φ(b) ∧ foreach(x ∈ B , φ(x ))

The recursive call to foreach is made with a domain strictly smaller than A.
This is so because the call is made with B and because φ(b) cannot bind a

16

Maximiliano Cristi´a, Gianfranco Rossi

value to B since φ is X -formula and B is of sort Set (the only way of binding
a value to B is by means of t ∈ B or B = t, for some term t, which are not
generated during Φ∀ processing, Remark 4). Then, SATRQ will terminate
when the ‘end’ of B is reached (i.e., when a variable or the empty set is
found).

– Induction hypothesis. SATRQ terminates on every constraint of the form foreach(~xk ∈

~Ak , φ) with k ≤ n, for any X -formula φ.

– Induction step. Let φ be any X -formula. We will prove that SATRQ terminates

on the following constraint:

foreach(x ∈ A, foreach(~xn ∈ ~An , φ(x , ~x )))

(27)

– A = ∅, this case is trivial as rule (9) terminates immediately.
– A ∈ VS , this case is trivial as rule (11) terminates immediately.
– A = {b ⊔ B }, rule (10) is applied to (27) yielding:

foreach(~xn ∈ ~An , φ(b, ~x )) ∧ foreach(x ∈ B , foreach(~xn ∈ ~An , φ(x , ~x )))

SATRQ terminates on the ﬁrst conjunct by the induction hypothesis. Be-
sides, the recursive call in the second conjunct is made with a domain
strictly smaller than A. This is so because the call is made with B and
because the ﬁrst conjunct cannot bind a value to B since it is a RUQ or
an X -formula and B is of sort Set. Then, SATRQ will terminate when the
‘end’ of B is reached (i.e., when a variable or the empty set are found).

Observe that termination depends solely on the size of the domain of the
RUQ. If φS is a conjunction of RUQ, then termination of SATRQ on each RUQ
implies termination of SATRQ for the whole formula. Indeed, when a given RUQ
is processed it can only generate a shorter RUQ or a LX formula. In either case,
nothing is generated that can bind a value to a domain. Then, the domain of a
RUQ in φS is not aﬀected by the processing of the other RUQ in the formula. ⊓⊔

Before proving termination of SATRQ on Φ∃ formulas we need the following

lemma.

Lemma 1 SATRQ terminates on any RQ-formula without RQ.

Proof Let φ be a RQ-formula without RQ. Write φ as φS ∧ φX . Hence, φS is
comprised solely of membership and equality constraints. Then, only the Mem-
bership and Equality rules of Figure 1 will be used by SATRQ. These rules have
been proved to constitute a terminating rewriting system elsewhere [28, Theorem
10.10].
⊓⊔

Theorem 4 (Termination on Φ∃ formulas) The SATRQ procedure can be imple-
mented as to ensure termination for every conjunction of pure Φ∃ constraints.

Proof Let φ be an X -formula. Consider the following rewriting:

exists([x ∈ A, y ∈ B ], φ(x , y))

−→ n1 ∈ A ∧ exists(y ∈ B , φ(n1, y))

−→ n1 ∈ A ∧ n2 ∈ B ∧ φ(n1, n2)

[by Def. 11, (24)]

[by Def. 11, (24)]

A Decision Procedure for Restricted Quantiﬁers

17

Then, all REQ are quickly eliminated from the formula. This can be easily general-
ized to exists(xn ∈ An , φ) for any X -formula φ and any 0 < n. The resulting non-X
subformula is a RQ-formula without RQ. Hence, by Lemma 1, SATRQ terminates
on that formula. Given that conjunctions of REQ are rewritten into conjunctions
of formulas such as the last one above, SATRQ terminates on every conjunction
of pure Φ∃ formulas.
⊓⊔

Theorem 5 (Termination on Φ∃∀ formulas) The SATRQ procedure can be imple-
mented as to ensure termination for every conjunction of pure Φ∃∀ constraints.

Proof Recall that the only constraints in pure Φ∃∀ formulas are of the form:

exists(~xk ∈ ~Ak , foreach(~ym ∈ ~Bm , φ))

(28)

for some X -formula φ, 0 < k and 0 ≤ m (if m = 0, then φ is the innermost ﬁlter).
First we prove termination on such a constraint. By using the same reasoning

of Theorem 4, (28) is rewritten into:

n1 ∈ A1 ∧ · · · ∧ nk ∈ Ak ∧ foreach(~ym ∈ ~Bm , φ)

(29)

Then, SATRQ process n1 ∈ A1 ∧ · · · ∧ nk ∈ Ak . By Lemma 1, SATRQ termi-
nates on that conjunction. The processing of this conjunction either terminates in
false, and so SATRQ stops, or it yields a conjunction of the form:

v

(

^
i=1

Xi = ti ) ∧ (

w

^
i=1

Yi = ui )

(30)

where Xi ∈ VS , Yi ∈ VX , ti are set terms and ui are X terms.

If some Bj in ~B is either Xi or {· · · ⊔ Xi }, then Xi is substituted by ti . This
m , φ). Then we have the following

rewrites foreach(~ym ∈ ~Bm , φ) into foreach(~ym ∈ ~B ′
formula:

v

(

^
i=1

Xi = ti ) ∧ (

w

^
i=1

Yi = ui ) ∧ foreach(~ym ∈ ~B

′
m , φ)

(31)

By Theorem 3 SATRQ terminates on foreach(~ym ∈ ~B ′

m , φ). While process-
ing the RUQ, SATRQ can only generate either RUQ or X -formulas (Remark 4).
Then, the main loop of SATRQ terminates. It only remains to call SATX on the
X -subformula, which will terminate under the assumption that it is a decision
procedure. Hence, SATRQ terminates on (28).

Now we prove that SATRQ terminates on a conjunction of constraints such as
(28). We can think that SATRQ will process each such constraint by going through
formulas (29)-(31). Processing each ﬁnal RUQ can only generate either RUQ or
X -formulas. Then, the main loop of SATRQ terminates.
⊓⊔

Now we consider a more general subclass of Φnrq -formulas which, however,
must obey a restriction concerning the domains of REQ that go after RUQ in
mixed RQ (some times called alternating quantiﬁers [31]).

We say that an RQ has a variable domain if its domain is either a variable or
an extensional set whose set part is a variable. Moreover, we say that the variable

18

Maximiliano Cristi´a, Gianfranco Rossi

of the domain is the domain itself (if it is a variable) or its set part. For example,
in:

foreach(x ∈ {h ⊔ ˙A}, exists(y ∈ ˙B, φ(x , y)))

(32)

{h ⊔ ˙A} is a variable domain whose variable is A, and ˙B is variable domain whose
variable is B .

The class of formulas we are about to deﬁne will avoid formulas such as the one
in Example 4. The problem with that formula is that there is an exists constraint
after a foreach constraint with the same domain variable (A). In this situation
when the foreach constraint picks an element (a) of its domain the exists constraint
hypothesizes the existence of a new element (n) in A as to satisfy φ. As now n ∈ A,
the foreach constraint must pick n making the exists constraint to hypothesize the
existence of another new element in A. This behavior may produce an inﬁnite
rewriting loop. In a sense, the exists constraint feeds back the foreach constraint
with new elements if they have the same domain variable. This problem can be
generalized to conjunctions of RQ.

Example 5 The following formula:

foreach(x ∈ {h ⊔ ˙A}, exists(y ∈ ˙B, φ(x , y)))
∧ foreach(z ∈ ˙B , exists(w ∈ {b ⊔ ˙A}, ψ(z , w )))

may produce an inﬁnite loop even though the foreach and exists constraints sharing
the same domain variable (A) are in diﬀerent RUQ. Still, in a sense, the exists
constraint with domain variable A is after the foreach constraint with the same
domain variable: from the A in the foreach we go to the B in the exists, from this
we go to the B in the foreach which leads us to the A in the exists.
⊓⊔

Therefore, the mathematics we are going to deﬁne are meant to characterize

formulas such as those in Examples 4 and 5.

Let φ1 ∧ · · · ∧ φn be a conjunction of nested RQ. Each RQ in a nested RQ is
indexed by its position in the chain. For instance, in (32) the foreach constraint
has index 1 while the exists constraint has index 2. For each φi build the function,
called domain function of φi , whose ordered pairs are of the form ((i , j ), (Qi
j ))
where:

j , D i

– A pair with ﬁrst component (i , j ) is in the domain function of φi iﬀ the RQ

with index j in φi has a variable domain.

j is the domain variable of the RQ with index j in φi .

– D i
– Qi
j

is ∀ if the j RQ is a foreach constraint and is ∃ if the RQ is an exists

constraint, in φi .

Hence, the domain function of the formula of Example 5 is:

{((1, 1), (∀, A)), ((1, 2), (∃, B )), ((2, 1), (∀, B )), ((2, 2), (∃, A))}

From the domain functions build a directed graph, called domain graph, whose
nodes are the ordered pairs of the domain functions. The edges are built as follows:
1. If ((i , j ), (∀, D i
((i , j ), (∀, D i

k )), with j < k, are in a domain function, then

k )) is an edge of the domain graph.

j )) and ((i , k), (∃, D i

j )) → ((i , k), (∃, D i

A Decision Procedure for Restricted Quantiﬁers

19

2. If ((i , j ), (∃, D)) and ((b, a), (∀, D)) are in domain functions with i 6= b, then

((i , j ), (∃, D)) → ((b, a), (∀, D)) is an edge of the domain graph.

Hence, the domain graph of the formula of Example 5 is:

((1, 1), (∀, A)) → ((1, 2), (∃, B )), ((2, 1), (∀, B )) → ((2, 2), (∃, A)),

((1, 2), (∃, B )) → ((2, 1), (∀, B )), ((2, 2), (∃, A)) → ((1, 1), (∀, A))

Consider the domain graph of a conjunction of pure RQ-constraints. A path

in the graph such as:

((i1, j11), (∀, D)) → ((i1, j12), (∃, D1)) →

((i2, j21), (∀, D1)) → ((i2, j22), (∃, D2)) →

· · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · →

((in , jn1), (∀, Dn−1)) → ((in , jn2), (∃, D))

where ia 6= ib if a 6= b for all a, b ∈ [1, n], is called a ∀∃ loop. Note that the ﬁrst
and last domain variables in a ∀∃ loop are the same (D).

We say that a conjunction of RQ is free of ∀∃ loops if there are no ∀∃ loop in
its domain graph. Φ∀∃ is the set of conjunctions of RQ free of ∀∃ loops. Note that
Φ∀∃ includes all the Φnrq -formulas where there are no variable domains.

Theorem 6 (Termination on Φ∀∃ formulas) The SATRQ procedure can be imple-
mented as to ensure termination for every formula in Φ∀∃.

Proof First we prove that SATRQ terminates on an atomic formula, ψ. It starts
by removing from ψ all the leading exists constraints (if any) and then proceeding
as in Theorem 5. Hence, we get a formula such as (31):

v

(

^
i=1

Xi = ti ) ∧ (

w

^
i=1

Yi = ui ) ∧ foreach(~ym ∈ ~B

′
m , Φ)

but where Φ is a mixed RQ (eventually ending in a X -formula) whose domains
might have been changed during the substitution step (see proof of Theorem 5).
Now, SATRQ processes the foreach constraint as in Theorem 3. Here, though,
we cannot easily conclude that RUQ processing cannot bind a value to ~B ′ because
after the leading RUQ there might be some REQ. The problem with REQ is that
they generate constraints of the form n ∈ A, for some domain A. Then, if the
variable of A happens to be a variable in ~B ′ (or in some RUQ in Φ) we will have
an inﬁnite loop as in Examples 4 and 5. However, since ψ belongs to Φ∀∃, we know
that there is no domain variable shared between a RUQ and a REQ ahead of it
because ψ is free from ∀∃ loops. Hence, we can arrive at the same conclusion of
Theorem 3 meaning that SATRQ terminates on ψ.

Now we prove that SATRQ terminates on a conjunction of constraints such as
ψ. Again, all the leading exists constraints (if any) are removed from each ψi thus
generating a formula such as (31) but with a conjunction of foreach constraints4:

v

(

^
i=1

Xi = ti ) ∧ (

w

^
i=1

Yi = ui ) ∧ (

q

^
i=1

foreachi (~ym ∈ ~B

′
m , Φ))

4 foreachi means that all its elements are renamed accordingly: ~yi,mi , ~B ′

i,mi

, Φi .

20

Maximiliano Cristi´a, Gianfranco Rossi

with 0 ≤ v , w , q.

As above, SATRQ processes all the foreachi (as in Theorem 3) and, again, the
problem are the n ∈ A constraints (A a variable domain) that might be generated
by the possible REQ present in each Φi . Diﬀerently from the base case, here
a n ∈ A constraint generated when foreacha is processed might aﬀect a domain
variable of a foreach constraint present in foreachb with a 6= b, as shown in Example
5. However, since the formula belongs to Φ∀∃ we know is free from ∀∃ loops. This
includes loops starting with a foreach domain variable in foreacha and ending with
the same domain variable in an exists constraint present in foreachb . Then, no n ∈ A
constraint can aﬀect a foreach domain variable. Therefore, SATRQ terminates. ⊓⊔

We close this section with the following two observations.

Remark 6 SATRQ terminates for some formulas in Φnrq \ Φ∀∃. For example, the
following is a slight variation of the formula of Example 4:

foreach(x ∈ ˙A, exists(y ∈ {b ⊔ ˙A}, φ(x , y)))

for which SATRQ trivially terminates because the formula is irreducible given that
the domain is a variable (rule (11) applies). We could have tighten the deﬁnition of
Φ∀∃ as to include this kind of formulas. However, we consider that these formulas
do not constitute a proper subclass as termination depends on whether or not
some RUQ remain irreducible throughout the constraint solving procedure.
⊓⊔

Remark 7 LRQ has been designed by imposing some restrictions on its fundamen-
tal elements, namely: VS ∩ VX = ∅ and ΠS ∩ ΠX = ∅. These restrictions are used
to prove Theorems 2-6. However, they can be relaxed to some extent as to accept
a wider class of theories as the parameter for LRQ.

It is possible to accept an LX such that VS ∩ VX 6= ∅ and ΠS ∩ ΠX 6= ∅ pro-
vided the solutions returned by SATX are compatible with the irreducible form
of Deﬁnition 3.3. That is, if SATX returns, as part of its solutions, a conjunction
of constraints including set variables, this conjunction must be satisﬁable by sub-
stituting all set variables by the empty set. This would be enough as to prove
Theorem 2.

Along the same lines, if ΠX contains ∈ then termination of SATRQ might
be compromised as SATX might generate ∈-constraints where the right term is
the domain of a foreach (much as when an exists is after a foreach). This can be
generalized to any predicate symbol in ΠX that can bind values to set terms. In
this case Theorems 3-6 can be proved if foreach domains are not aﬀected by the
constraints generated by SATX .

As we will shown in Section 6 there are expressive LX such that VS ∩ VX 6= ∅
⊓⊔

and ΠS ∩ ΠX 6= ∅ for which SATRQ is still an eﬀective solver.

5 Avoiding Existential Variables Inside RQ

All the considerations made in this section concerning RUQ apply equally to REQ.
The concepts introduced here are adapted from those developed by us for RIS [18,
Section 6].

A Decision Procedure for Restricted Quantiﬁers

21

Assume R is a set of ordered pairs. We can try to write a formula stating that

R is the identity relation:

foreach(x ∈ R, x = (e, e))

(33)

where e is intended to be a variable existentially quantiﬁed inside the RUQ. As
deﬁned in Section 2, LRQ does not allow to introduce these variables and so (33)
would not be one of its formulas. Besides, it is not clear what a quantiﬁcation
domain could be for e. However, the following is an RQ-formula stating the same
property:

foreach((x , y) ∈ R, x = y)

Note that we use an ordered pair as the control term (see Deﬁnition 4). Precisely,
allowing (nested) ordered pairs as control terms makes it possible to avoid many
existential variables inside RUQ. As binary relations are a fundamental concept
in Computer Science [35, 6], the introduction of ordered pairs as control terms
is sensible as it enables to quantify over binary relations, without introducing
existential variables.

Even if we allow (unrestricted) existential variables inside RQ, it is important
to avoid them because the negation of such a RQ would not be a LRQ formula.
Indeed, if there are existential variables inside the RQ the negation will introduce a
universally quantiﬁed formula, which is not a LRQ formula. For instance, assuming
R is a set of numeric ordered pairs, the following is a predicate stating that the
sum of any of its elements is greater than z :

foreach((x , y) ∈ R, sum(x , y, n) ∧ z < n)

(34)

where sum(x , y, n) is interpreted as n = x + y, and n is intended to be a variable
existentially quantiﬁed inside the RUQ. Here, control terms do not help and, again,
we do not have a quantiﬁcation domain for n. Then, the negation of this formula
would inevitably introduce a universal quantiﬁcation. Furthermore, it would negate
sum(x , y, n) for all n which would mean that there is no result for x + y.

Hence, the language is extended by introducing a foreach constraint of arity 4:

foreach(x ∈ A, [e1, . . . , en ], φ(x , e1, . . . , en ), ψ(x , e1, . . . , en ))

(35)

where e1, . . . , en are variables implicitly existentially quantiﬁed inside the RUQ
and ψ is a conjunction of so-called functional predicates. A predicate p of artity
n + 1 (0 < n) is a functional predicate iﬀ for each x1, . . . , xn there exists exactly
one y such that p(x1, . . . , xn , y) holds; y is called the result of p. For instance, sum
is a functional predicate. In an extended RUQ, e1, . . . , en must be the results of
the functional predicates in ψ.
The semantics of (35) is:

∀ x (x ∈ A ⇒ (∃ e1, . . . , en (ψ(x , e1, . . . , en ) ∧ φ(x , e1, . . . , en ))))

whereas its negation is:

∃ x (x ∈ A ∧ (∃ e1, . . . , en (ψ(x , e1, . . . , en ) ∧ ¬ φ(x , e1, . . . , en ))))

given the functional character of ψ [18, Section 6.2]. By means of functional pred-
icates the introduction of existential variables inside RUQ is harmless while the
expressiveness of the language is widened.

22

Maximiliano Cristi´a, Gianfranco Rossi

Example 6 Formula (34) should be written by means of an extended RUQ:

foreach((x , y) ∈ R, [n], z < n, sum(x , y, n))

Note that n is the result of sum. The negation of the above formula is:

exists((x , y) ∈ R, [n], z ≥ n, sum(x , y, n))

which is consistent with the intended meaning of the original formula.

⊓⊔

6 LRQ in Practice

LRQ and SATRQ have been implemented as part of the {log} (‘setlog’) tool [46].
{log} is a constraint logic programming (CLP) language implemented in Prolog. It
also works as a satisﬁability solver (and thus as an automated theorem prover) for
a few theories rooted in the theory of ﬁnite sets. {log} and the theories underly-
ing it have been thoroughly described elsewhere [28, 25, 16, 18, 22, 23, 21]. Empirical
evidence of the practical capabilities of {log} has been provided as well [24, 17, 20,
15, 19].

Theory X in {log} is the combination between the theories known as LIA and
BR. LIA stands for linear integer arithmetic and implements a decision procedure
for systems of linear equations and disequations over the integer numbers. BR
stands for binary relations and implements a decision procedure for an expressive
fragment of ﬁnite set relation algebra (RA) [16]. In BR, binary relations are sets
of ordered pairs and all the RA operators are available as constraints, namely:
union (C = A ∪ B → un(A,B,C)), intersection (C = A ∩ B → inters(A,B,C)),
identity relation over a set (id(A) = R →id(A,R)), converse of a binary relation
(R⌣ = S → inv(R,S)) and composition (T = R ◦ S → comp(R,S,T)). These
operators can be combined in BR-formulas to deﬁne many other operators such as:
domain (dom R = A → dom(R,A)) and range (ran R = A → ran(R,A)) of a binary
relation, a predicate constraining a binary relation to be a function (pfun(R)),
function application (F (X ) = Y → applyTo(F,X,Y)), etc.

LIA satisﬁes all the restrictions discussed in Remark 7, but BR does not.
However, the solutions returned by {log} when solving BR-formulas are compatible
with the irreducible form of Deﬁnition 10 [16, Deﬁnition 15 and Theorem 3]. That
is, irreducible formulas in BR are satisﬁed by substituting all the set and relational
variables by the empty set. However, when a BR-formula is processed, RQ domains
may be aﬀected. As discussed in Remark 7 this may compromise termination;
LRQ(LIA + BR) decidability is discussed more deeply in Section 7. Nevertheless,
as the following case studies show, {log} is still an eﬀective and eﬃcient tool to
automatically reason about LRQ(LIA+BR) formulas. Termination do not seem to
be an issue for many classes of practical problems expressible in LRQ(LIA + BR).
{log}’s concrete syntax is a slight variation of the syntax used in this paper:
{ ⊔ } is {_/_}; ( , ) is [_,_]; ∈ is in; ∧ is &; A ⊆ B is subset(A,B); variables
begin with a capital letter.

The following simple example shows {log} syntax and how to use it to prove

invariance lemmas.

A Decision Procedure for Restricted Quantiﬁers

23

Example 7 Let Usr and Admin be the sets of users and administrators of some
system. Let us say that the security policy requires these sets to be disjoint. We
can express that in {log} as follows5:

inv(Usr,Adm) :- foreach([U in Usr,A in Adm], U neq A).

We can model the operation adding user X to Usr yielding Usr_ as the new set:

addUsr(Usr,Adm,X,Usr_,Adm_) :- Usr_ = {X / Usr} & Adm_ = Adm.

We would like to know if addUsr preserves inv, so we run the following query6:

neg(inv(Usr,Adm) & addUsr(Usr,Adm,X,Usr_,Adm_) implies inv(Usr_,Adm_)).

As addUsr fails to preserve inv, {log} provides a counterexample (N new variable):

Admin = {X / N}, Usr_ = {X / Usr}, Admin_ = {X / N}

So we can ﬁx addUsr by adding a pre-condition:

addUsr(Usr,Adm,X,Usr_,Adm_) :- X nin Usr & Usr_ = {X / Usr} & Adm_ = Adm.

Now the answer to the query is no meaning that the formula is unsatisﬁable.

⊓⊔

The next three subsections present real-world case studies where {log} is used
as a CLP language and as an automated veriﬁer. The focus in on how RQ are
used.

6.1 The Landing Gear System

In the fourth edition of the ABZ Conference held in Toulouse (France) in 2014,
Boniol and Wiels proposed a real-life, industrial-strength case study, known as the
Landing Gear System (LGS) [9]. Mammar and Laleau [39] developed an Event-
B [1] speciﬁcation of the LGS, formally veriﬁed using Rodin [2], ProB [37] and
AnimB7. Basically, we encoded in {log} the Event-B speciﬁcation and used {log}
to automatically discharge all the proof obligations generated by Rodin. This work
is thoroughly described elsewhere [19]8.

This is the simplest model in terms of RQ as it does not require nested RQ. A

typical use of RQ in the LGS is the following9:

ta_inv5(Positions,DULDC) :-

pfun(DULDC) &
dompf(DULDC,Positions) &
foreach([X,Y] in DULDC, 0 =< Y).

5 Other encodings are possible; we deliberately choose to use a RUQ.
6 Given that {log} is a satisﬁability solver we call it on the negation of the lemma waiting

for a no (i.e., false) answer.
7 http://www.animb.org
8 {log} code of the LGS: http://www.clpset.unipr.it/SETLOG/APPLICATIONS/lgs.zip.
9 Some variable names are changed to save some space.

24

Maximiliano Cristi´a, Gianfranco Rossi

That is, ta_inv5 deﬁnes a state invariant corresponding to the Event-B machine
named TimedAspects. In mathematical notation the invariant states DULDC ∈
Positions 7→ N. As in {log} we cannot express N we use a RUQ to ascertain that the
second component of each element in DULDC is non-negative. Then, invariance
lemmas such as:

neg(di_inv1(Positions,Dcp) &

ta_inv1(CT) &
ta_inv5(Positions,DULDC) &
ta_make_DoorClosed(...,Dcp,...,CT,...,DULDC,...,Dcp_,...,DULDC_)
implies

ta_inv5(Positions,DULDC_)).

are automatically discharged by {log}. di_inv1(Positions,Dcp) and ta_inv1(CT)
are other invariants that are needed as hypothesis and ta_make_DoorClosed is one
of the state transitions of the LGS model (ellipses stand for variables). Hence,
ta_make_DoorClosed changes the value of DULDC during the state transition and so
we need to check that ta_inv5 is still valid in the new state.

{log} discharges all the 465 proof obligations in less than 5 minutes.

6.2 The Bell-LaPadula Security Model

Around 1973 D.E. Bell and L. LaPadula published the ﬁrst formal model of a
secure operating system [3, 4]. Today this model is known as the Bell-LaPadula
model, abbreviated as BLP. BLP is described as a state machine by means of ﬁrst-
order logic and set theory. The model also formalizes two state invariants known
as security condition and *-property. We encoded BLP and its properties in {log}
and used it to automatically discharge all the invariance lemmas. This work is
presented with detail elsewhere [17]10.

The following is the {log} encoding of the *-property:

starProp(State) :-

State = [[br,Br],[bw,Bw],[fo,Fo],[fs,Fs],[m,M]] &
foreach([[S1,O1] in Br, [S2,O2] in Bw], [Sco1,Sco2],

S1 = S2 implies dominates(Sco1,Sco2),
applyTo(Fo,O1,Sco1) & applyTo(Fo,O2,Sco2)).

As can be seen it requires the use of the extended version of nested RUQ (Section
5). That is, it declares two existential variables inside the RUQ (Sco1 and Sco2)
and uses the functional predicate section (applyTo(Fo,O1,Sco1) & ...). Extended
RUQ are also used in the state transitions, for instance:

getRead(State,S,O,State_) :-

State = [[br,Br],[bw,Bw],[fo,Fo],[fs,Fs],[m,M]] &
[O,[S,read]] in M & [S,O] nin Br &
applyTo(Fo,O,Sco) & applyTo(Fs,S,Scs) &
dominates(Sco,Scs) &
foreach([Si,Oi] in Bw,[Scoi],

Si = S implies dominates(Sco,Scoi),applyTo(Fo,Oi,Scoi)) &

Br_ = {[S,O]/Br} &
State_ = [[br,Br_],[bw,Bw],[fo,Fo],[fs,Fs],[m,M]].

10 {log} code of BLP: http://www.clpset.unipr.it/SETLOG/APPLICATIONS/blp2.zip.

A Decision Procedure for Restricted Quantiﬁers

25

getRead grants read permission to subject S on object O in which case changes the
value of variable Br. Then, the following invariance lemma must be proved:

neg(starProp(State) & getRead(State,S,O,State_) implies starProp(State_)).

Due to an optimization introduced since our ﬁrst experiments with BLP, now
{log} proves all the 60 invariance lemmas in less than 2 seconds instead of the 11.5
seconds reported previously [17].

6.3 Android’s Permission System

In a series of articles a group of Uruguayan and Argentinian researchers and stu-
dents developed a certiﬁed Coq model and implementation of Android’s permis-
sion system [8, 7, 38, 26]. They model the system as a state machine, then propose
a number of properties and use Coq to verify them against the model. Properties
are classiﬁed in two classes: valid state properties and security properties. The
ﬁrst class ensures the state machine preserves some well-formedness properties of
the state variables, while the second ensures Android behaves as expected in some
security-related scenarios. As with the previous case studies, we translated the
Coq model into {log} and used it to automatically prove properties11.

This is the most challenging case study we have developed so far. It takes
{log} to its limits concerning reasonable computing times to discharge proof obli-
gations12. It also uses the most complex nested RQ we have used so far, as the
following one which formalizes one of the valid state properties13.

notDupPerm(DP) :-

foreach([[A1,SP1] in DP, [A2,SP2] in DP],

foreach([P1 in SP1, P2 in SP2],[IP1,IP2],
IP1 = IP2 implies P1 = P2 & A1 = A2,
idP(P1,IP1) & idP(P2,IP2))).

Note that there is one nested RUQ whose ﬁlter is an extended nested RUQ. Fur-
thermore, in the innermost RUQ SP1 and SP2 are domains whereas they are part
of the outermost control term. That is, ﬁrst [A1,SP1] quantiﬁes over DP and then
P1 quantiﬁes over SP1.

The following is another state consistency property ﬁtting in the Φ∀∃ subclass.

permsDom(PR,Apps,SS) :-
foreach([A,P] in PR,

A in Apps or exists(SI in SS, [IA], IA = A, idSI(SI,IA))).

As can be seen, the domain of the RUQ does not appear inside the REQ, thus
making the formula free of ∀∃ loops. The REQ uses a functional predicate.

{log} automatically discharges 801 proof obligations in around 22 minutes.

11 {log} code of Android 10’s permission system: http://www.clpset.unipr.it/SETLOG/
APPLICATIONS/android.zip
12 Actually, {log} is unable to prove only three of the properties proposed in the Coq model.
13 In the following formulas some simpliﬁcations are introduced to save some space.

26

Maximiliano Cristi´a, Gianfranco Rossi

7 Discussion and Related Work

The problem of deciding the satisﬁability of quantiﬁed formulas is obviously unde-
cidable. Hence, we can only hope to ﬁnd expressive fragments that are decidable.
A possible path for this is to restrict the form of the quantiﬁers and another is
to allow only certain quantiﬁer-free formulas. A class of quantiﬁed formulas that
has been studied for many years is that of restricted quantiﬁers. However, the full
fragment of restricted quantiﬁers as well as some of its sub-fragments are unde-
cidable (e.g. [10, 43, 31]). Hence, further restrictions must be imposed. One of such
restrictions is to deal with formulas where RUQ are after REQ. This fragment has
been proved to be decidable in diﬀerent contexts [10, 42, 31]. We started by working
with quantiﬁer-free formulas that do not aﬀect quantiﬁcation domains (Deﬁnition
1, Remark 7). We have not seen other works taking this path. Then, we relaxed
that restriction loosing termination but nonetheless gaining expressiveness. This
combination seems to be useful in practice (Section 6).

We identify Computable Set Theory (CST) [11, 14] as the main and closest
source of works related to the one presented in this paper. However, there are
works outside CST dealing with similar problems, specially in the realm of STM
solvers. We start with the latter.

The STM solving community deals with unrestricted quantiﬁers. The usual
practical technique employed in SMT solvers to deal with quantiﬁed formulas is
heuristics-based quantiﬁer instantiation [32, 30, 40, 33]. In particular, Simplify’s E-
matching algorithm [27] is used by some of these tools. Heuristic instantiation
manages to solve problems of software veriﬁcation. However, it suﬀers from some
shortcomings as stated by Ge and de Moura [34]. For this reason, Ge and de
Moura propose some decidable fragments of ﬁrst order logic modulo theories. The
proposed decision procedures can solve complex quantiﬁed array properties. The
authors show how to construct models for satisﬁable quantiﬁed formulas in these
fragments.

∗

∗
∀

In a more recent work, Feldman et al. [31] study the problem of discharging
inductive invariants with quantiﬁer alternation using SMT solvers. They depart
from formulas belonging to the Eﬀectively Propositional logic (EPR), also known
as the Bernays-Sch¨onﬁnkel-Ramsey class. In this logic, formulas are of the form
(δ), where δ is a quantiﬁer-free formula over some ﬁrst-order vocabulary. This
∃
logic has been proved to be decidable and useful in automatically discharging
veriﬁcation conditions of software involving linked-lists, distributed protocols, etc.
Feldman and his colleagues then go to extend EPR with formulas of the form
(δ). The ﬁrst conclusion they get is that this fragment is undecidable. However,
∀
a second conclusion is that some techniques can be put to work as to solve many
interesting problems in that fragment. The main technique is instantiations that
are bounded in the depth of terms. However, bounded instantiations guarantee
termination a-priori even when the invariant is not correct. In these cases the
algorithm returns an approximated counterexample. The invariants approached
by Feldman at al. are of the same form of most of the proof obligations present in
our case studies.

∗
∃

∗

As can bee seen, the SMT solving community approaches the problem of ﬁnding
decision procedures for quantiﬁed fragments of logic languages in a quite diﬀerent
way as we do. They do not use RQ nor a theory of sets. RQ have an interesting
property: ∀ x ∈ A : φ, with A a variable, is satisﬁed with A = ∅. If this is combined

A Decision Procedure for Restricted Quantiﬁers

27

with a set constructor such as {· ⊔ ·}, it is possible to iterate over the elements of
the quantiﬁcation domain until the ‘end’ is reached: if it is ∅, then the quantiﬁer
can be eliminated; it if is a variable, then the iteration can be stopped because
we know that we have a good candidate solution for the quantiﬁcation domain.
Quantiﬁcation domains are crucial to ﬁnd out a decision procedure for formulas
where REQ are after RUQ. As we have shown in Theorem 6, REQ with the same
domain variable than a preceding RUQ, in general, generate inﬁnite feedback loops.
These loops can be easily detected by following the ﬂow of hypothesized elements
through quantiﬁcation domains. We believe all this is harder to see when the
language admits general quantiﬁers and is not based on a theory of sets. At the
same time, RQ do not pose a threat on expressiveness when it comes to software
veriﬁcation. Finally, concerning counterexample generation, within the decidable
fragments presented in this paper, {log} is not only always able to generate a
counterexample of any given satisﬁable formula but it (interactively) generates a
ﬁnite representation of all its solutions (Theorem 1).

Our work is closer to CST. CST has been looking for decidability results on
quantiﬁed fragments of set theory since at least forty years ago. In many cases,
CST is interested in proving decidability results (in the form of satisﬁability tests)
but not so much in providing eﬃcient algorithms or in implementing them in some
software tool. Brevan et al [10] present a semi-decision algorithm for a wide class
of quantiﬁed formulas where the quantiﬁer-free theory is decidable. In this work,
quantiﬁers are RQ but no quantiﬁed variable can be a quantiﬁed domain of a
deeper RQ (see (†) below). For some theories the algorithm becomes complete. In
general, the quantiﬁer-free theories are sub-languages of set theory. In particular
they consider a language based on {=, ∈}. The resulting quantiﬁed language allows
to express many set-theoretic operators (e.g. union). From that article, several
researchers of the CST community have found a number of (un)decidability results
about diﬀerent fragments of quantiﬁed languages of set theory [45, 43, 41, 5, 42].

As can be seen, the decidability results represented by Theorems 1-5 have
already been proved. On the contrary, we believe the result of Theorem 6 is new.
Besides, as far as we understand, all of our results are new in terms of the algorithm
we use and in particular the set of rewrite rules we use, not to mention the fact
that we put these results to work in a software tool that is able to solve real-world
problems (Section 6).

π
More recently, Cantone and Longo [12, 13] worked on the language ∀
0,2, part of
π
0,2 helps to analyze the decidability and expressive-
Cantone’s long work on CST. ∀
π
ness of LRQ(LIA + BR)14. ∀
0,2 is a two-sorted quantiﬁed fragment of set theory
allowing the following literals: x ∈ y, (x , y) ∈ R, x = y and R = S , where x and
y are set variables and R and S are variables ranging over binary relations. Note
that in ∀π
0,2 sets are pure meaning that their elements are sets where the empty
set is the base element (semantics of ∀π
0,2 is given in terms of the von Neumann
standard cumulative hierarchy of sets). Formulas in ∀π
0,2 are Boolean combinations
of expressions of the following two forms: ∀ x1 ∈ z1 : . . . ∀ xh ∈ zh : ∀(xh+1, yh+1) ∈
Rh+1 : . . . ∀(xn , yn ) ∈ Rn : δ, and the same expression where ∀ is replaced by ∃. In
π
0,2-literals; xi , yi , zi are set
these expressions: δ is a propositional combination of ∀
variables; Ri are binary relation variables; and (†) no xi or yi can also occur as

14 The same could be achieved by using as a reference the work on CST by Breban et al.
[10]. We opted by Cantone’s because is newer. Nonetheless, Breban’s is also duly referenced.

28

Maximiliano Cristi´a, Gianfranco Rossi

a zj (i.e., no quantiﬁed variable can occur also as a domain variable in the same
π
quantiﬁer preﬁx). Note that in ∀
0,2 RUQ and REQ cannot be mixed in the same
expression.
π
0,2 is a decidable language which allows to express all the operators of RA
∀
π
with the exception of composition. Indeed, ∀
0,2 only allows to express R ◦ S ⊆ T
but the other inclusion cannot be written. The impossibility to express the other
inclusion comes from the fact that RUQ and REQ cannot be mixed in the same
expression, which is tantamount to preserve decidability of ∀π
0,2. In eﬀect, T ⊆ R◦S
is equivalent to:

∀(x , z ) ∈ T : (∃(x1, y1) ∈ R : (∃(y2, z1) ∈ S : x1 = x ∧ y1 = y2 ∧ z1 = z ))

(36)

which is not a ∀π

0,2 formula (as it mixes RUQ and REQ).

Now we analyze the decidability and expressiveness of LRQ(LIA + BR) in

terms of ∀π

0,2:

1. ∀π

2. ∀π

3. ∀π

0,2 sets are not necessarily ﬁnite; LRQ(LIA + BR) sets are ﬁnite. However,
since we are interested in software veriﬁcation this is not a real restriction.
0,2 is not a parametric language as LRQ, although other works on CST provide
π
0,2 [10]. Parametrization of LRQ enables
parametric languages in the line of ∀
hybrid sets.
0,2 sets are pure, while LRQ(LIA + BR) sets are hybrid. Pure sets allow to
encode ordered pairs, natural numbers, etc. However, these encodings tend to
reduce the eﬃciency of solvers. Working directly with hybrid sets facilitates the
integration with eﬃcient solvers for other theories, such as LIA. For instance,
the formula in Example 1 encodes the minimum of a set which would require
π
0,2 formula.
a complex ∀

4. LRQ(LIA + BR) extends the decidability result of ∀

π
0,2
π
almost expresses RA so if in LRQ(LIA+BR) composition is used as in ∀
0,2, the
former is a fragment of the latter in what concerns to RA. On the other hand,
LRQ(LIA + BR) allows to fully express composition by a suitable encoding of
formula (36):

π
0,2. On one hand, ∀

foreach((x , z ) ∈ T , exists([(x1, y1) ∈ R, (x2, z1) ∈ S ], x1 = x ∧ y1 = y2 ∧ z1 = z ))

As can be seen, this formula is free of ∀∃ loops as long as the variable of T is
diﬀerent from the variables of R and S . Hence, Cantone and Longo go to far
π
in restricting ∀
0,2 as the real problem with composition comes with formulas
such as R ⊆ R ◦ S or S ⊆ R ◦ S . This is aligned with our results concerning the
decidability of LBR [16, Section 5.3, Deﬁnition 16]. Finding larger decidable
fragments of RA is important as it is a fundamental theory in Computer Science
due to its expressiveness [35, last paragraph Section 1]. Besides, as shown in
Section 6.3 with formula permsDom, allowing Φ∀∃ formulas is useful in practice.
5. LRQ(LIA + BR) allows quantiﬁed variables to occur as domains in the same
quantiﬁer preﬁx (cf. (†) above). Recall, for instance, formula notDupPerm in
π
Section 6.3. These formulas are ruled out from ∀
0,2 because they compromise
completeness, not soundness [10, Sections 2 and 4]. The problem is that there
are formulas not adhering to (†) that are satisﬁed only by inﬁnite sets when
∈ is part of the quantiﬁer-free theory [44]. So if we allow these formulas in
{log} its answers are correct because the tool is still sound, although it will not

A Decision Procedure for Restricted Quantiﬁers

29

6. ∀π

terminate for those formulas that are satisﬁed only by inﬁnite sets. As shown
in Section 6.3, allowing formulas not adhering to (†) is useful in practical cases.
0,2 is proved to be decidable by encoding each of its formulas as a ∀π
0 -formula.
π
In turn, ∀
0 is shown to be decidable by means of the notions of skeletal represen-
tation and of its realization [13]. The authors do not provide an algorithm with
an obvious operative semantics for the decidability problem of ∀π
0,2 formulas.
Conversely, by adapting our results on RIS, we provide a simple and concrete
solver for LRQ (i.e., SATRQ) with CLP properties easily implementable as part
of {log}. In turn, we provide empirical evidence of its practical capabilities. The
algorithms presented by Breban [10] are closer to SATRQ.

8 Final Remarks

We have presented a decision procedure for quantiﬁer-free, decidable languages
extended with restricted quantiﬁers. The decision procedure is based on a small
collection of rewrite rules for primitive set-theoretic operators (⊆, ∈, =). Although
all but one of the decidability results underlying our decision procedure are not
new, as far as we understand, the decision procedure and its rewrite rules are
novel. The new decidability result concerns quantiﬁed formulas where a restricted
existential quantiﬁer comes after a restricted universal quantiﬁer. The result is
based on building a graph linking the universally quantiﬁed domains with those
existentially quantiﬁed. Then, a path analysis is performed to ﬁnd out whether
or not there is a path from a universally quantiﬁed domain to the same domain
but making part of an existential quantiﬁer. Finally, the implementation of the
decision procedure as part of a software tool ({log}) and its successful application
to real-world, industrial-strength case studies as an automated software veriﬁer
provide empirical evidence of the usefulness of the approach.

Our strongest decidability results are possible by imposing some restrictions
on the quantiﬁer-free language—namely, that it does not include terms denoting
sets. Although non-trivial languages fulﬁll these restrictions (e.g., linear integer
arithmetic), the greatest expressiveness is reached when some of these restrictions
are lifted at the expense of termination. Hence, as a future work we plan to study
what quantiﬁer-free languages preserve termination even though they support sets
to some extent. In particular, the long and fruitful work on CST should help us
in ﬁnding those languages.

References

1. Abrial, J.R.: Modeling in Event-B: System and Software Engineering. Cambridge Univer-

sity Press, New York, NY, USA, 1st edn. (2010)

2. Abrial, J., Butler, M.J., Hallerstede, S., Hoang, T.S., Mehta, F., Voisin, L.: Rodin: an
open toolset for modelling and reasoning in Event-B. Int. J. Softw. Tools Technol. Transf.
12(6), 447–466 (2010), https://doi.org/10.1007/s10009-010-0145-y

3. Bell, D.E., LaPadula, L.: Secure computer systems: Mathematical foundations. MTR 2547,

The MITRE Corporation (May 1973)

4. Bell, D.E., LaPadula, L.: Secure computer systems: Mathematical model. ESD-TR 73-278,

The MITRE Corporation (Nov 1973)

5. Bell`e, D., Parlamento, F.: Truth in V for ∃*∀∀-sentences is decidable. J. Symb. Log. 71(4),

1200–1222 (2006), https://doi.org/10.2178/jsl/1164060452

30

Maximiliano Cristi´a, Gianfranco Rossi

6. Berghammer, R., H¨ofner, P., Stucke, I.: Automated veriﬁcation of relational while-
programs. In: H¨ofner, P., Jipsen, P., Kahl, W., M¨uller, M.E. (eds.) Relational and Al-
gebraic Methods in Computer Science - 14th International Conference, RAMiCS 2014,
Marienstatt, Germany, April 28-May 1, 2014. Proceedings. Lecture Notes in Com-
puter Science, vol. 8428, pp. 173–190. Springer (2014), http://dx.doi.org/10.1007/
978-3-319-06251-8_11

7. Betarte, G., Campo, J.D., Luna, C., Romano, A.: Formal analysis of Android’s permission-
based security model,. Sci. Ann. Comp. Sci. 26(1), 27–68 (2016), https://doi.org/10.
7561/SACS.2016.1.27

8. Betarte, G., Campo, J.D., Luna, C.D., Romano, A.: Verifying Android’s permission model.
In: Leucker, M., Rueda, C., Valencia, F.D. (eds.) Theoretical Aspects of Computing -
ICTAC 2015 - 12th International Colloquium Cali, Colombia, October 29-31, 2015, Pro-
ceedings. Lecture Notes in Computer Science, vol. 9399, pp. 485–504. Springer (2015),
https://doi.org/10.1007/978-3-319-25150-9_28

9. Boniol, F., Wiels, V.: The landing gear system case study. In: Boniol, F., Wiels, V.,
Ameur, Y.A., Schewe, K. (eds.) ABZ 2014: The Landing Gear Case Study - Case Study
Track, Held at the 4th International Conference on Abstract State Machines, Alloy, B,
TLA, VDM, and Z, Toulouse, France, June 2-6, 2014. Proceedings. Communications in
Computer and Information Science, vol. 433, pp. 1–18. Springer (2014), https://doi.org/
10.1007/978-3-319-07512-9_1

10. Breban, M., Ferro, A., Omodeo, E.G., Schwartz, J.T.: Decision procedures for elementary
sublanguages of set theory. II. Formulas involving restricted quantiﬁers, together with
ordinal, integer, map, and domain notions. Communications on Pure and Applied Mathe-
matics 34(2), 177–195 (1981), https://onlinelibrary.wiley.com/doi/abs/10.1002/cpa.
3160340203

11. Cantone, D., Ferro, A., Omodeo, E.: Computable Set Theory. Clarendon Press, USA (1989)
12. Cantone, D., Longo, C.: A decidable two-sorted quantiﬁed fragment of set theory with
ordered pairs and some undecidable extensions. Theor. Comput. Sci. 560, 307–325 (2014),
http://dx.doi.org/10.1016/j.tcs.2014.03.021

13. Cantone, D., Longo, C., Asmundo, M.N.: A decidable quantiﬁed fragment of set theory in-
volving ordered pairs with applications to description logics. In: Bezem, M. (ed.) Computer
Science Logic, 25th International Workshop / 20th Annual Conference of the EACSL, CSL
2011, September 12-15, 2011, Bergen, Norway, Proceedings. LIPIcs, vol. 12, pp. 129–143.
Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik

14. Cantone, D., Omodeo, E.G., Policriti, A.: Set Theory for Computing - From Decision
Procedures to Declarative Programming with Sets. Monographs in Computer Science,
Springer (2001), http://dx.doi.org/10.1007/978-1-4757-3452-2

15. Cristi´a, M., Katz, R.D., Rossi, G.: Proof Automation in the Theory of Finite Sets and
Finite Set Relation Algebra. The Computer Journal (05 2021), https://doi.org/10.1093/
comjnl/bxab030, bxab030

16. Cristi´a, M., Rossi, G.: Solving quantiﬁer-free ﬁrst-order constraints over ﬁnite sets and
binary relations. J. Autom. Reason. 64(2), 295–330 (2020), https://doi.org/10.1007/
s10817-019-09520-4

17. Cristi´a, M., Rossi, G.: Automated proof of Bell-LaPadula security properties. J. Autom.

Reason. 65(4), 463–478 (2021), https://doi.org/10.1007/s10817-020-09577-6

18. Cristi´a, M., Rossi, G.: Automated reasoning with restricted intensional sets. J. Autom.

Reason. 65(6), 809–890 (2021), https://doi.org/10.1007/s10817-021-09589-w

19. Cristi´a, M., Rossi, G.: An automatically veriﬁed prototype of a landing gear system. CoRR

abs/2112.15147 (2021), https://arxiv.org/abs/2112.15147

20. Cristi´a, M., Rossi, G.: An automatically veriﬁed prototype of the Tokeneer ID station
speciﬁcation. J. Autom. Reason. 65(8), 1125–1151 (2021), https://doi.org/10.1007/
s10817-021-09602-2

21. Cristi´a, M., Rossi, G.: A decision procedure for a theory of ﬁnite sets with ﬁnite inte-
ger intervals. CoRR abs/2105.03005 (2021), https://arxiv.org/abs/2105.03005, under
consideration in Theoretical Computer Science

22. Cristi´a, M., Rossi, G.: Integrating cardinality constraints into constraint logic program-
ming with sets. Theory and Practice of Logic Programming pp. 1–33 (2021), https:
//doi.org/10.1017/S1471068421000521

23. Cristi´a, M., Rossi, G.: {log}: set formulas as programs. Rend. Ist. Mat. Univ. Trieste 53,

24 (2021), id/No 23

A Decision Procedure for Restricted Quantiﬁers

31

24. Cristi´a, M., Rossi, G., Frydman, C.S.: {log} as a test case generator for the Test Template
Framework. In: Hierons, R.M., Merayo, M.G., Bravetti, M. (eds.) SEFM. Lecture Notes
in Computer Science, vol. 8137, pp. 229–243. Springer (2013)

25. Cristi´a, M., Rossi, G., Frydman, C.S.: Adding partial functions to constraint logic pro-
gramming with sets. Theory Pract. Log. Program. 15(4-5), 651–665 (2015), https:
//doi.org/10.1017/S1471068415000290

26. De Luca, G., Luna, C.: Towards a certiﬁed reference monitor of the Android 10 permission
system. In: de’Liguoro, U., Berardi, S., Altenkirch, T. (eds.) 26th International Conference
on Types for Proofs and Programs, TYPES 2020, March 2-5, 2020, University of Turin,
Italy. LIPIcs, vol. 188, pp. 3:1–3:18. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik
(2020), https://doi.org/10.4230/LIPIcs.TYPES.2020.3

27. Detlefs, D., Nelson, G., Saxe, J.B.: Simplify: a theorem prover for program checking 52(3),

365–473

28. Dovier, A., Piazza, C., Pontelli, E., Rossi, G.: Sets and constraint logic programming.

ACM Trans. Program. Lang. Syst. 22(5), 861–931 (2000)

29. Dovier, A., Pontelli, E., Rossi, G.: Set uniﬁcation. Theory Pract. Log. Program. 6(6),

645–701 (2006)

30. Dutertre, B., de Moura, L.M.: A fast linear-arithmetic solver for DPLL(T). In: Ball, T.,
Jones, R.B. (eds.) CAV. Lecture Notes in Computer Science, vol. 4144, pp. 81–94. Springer
(2006)

31. Feldman, Y.M.Y., Padon, O., Immerman, N., Sagiv, M., Shoham, S.: Bounded quantiﬁer
instantiation for checking inductive invariants. Log. Methods Comput. Sci. 15(3) (2019),
https://doi.org/10.23638/LMCS-15(3:18)2019

32. Flanagan, C., Joshi, R., Ou, X., Saxe, J.B.: Theorem proving using lazy proof expli-
cation. In: Jr., W.A.H., Somenzi, F. (eds.) Computer Aided Veriﬁcation, 15th Interna-
tional Conference, CAV 2003, Boulder, CO, USA, July 8-12, 2003, Proceedings. Lecture
Notes in Computer Science, vol. 2725, pp. 355–367. Springer, https://doi.org/10.1007/
978-3-540-45069-6_34

33. Ge, Y., Barrett, C.W., Tinelli, C.: Solving quantiﬁed veriﬁcation conditions using satisﬁ-

ability modulo theories 55(1-2), 101–122

34. Ge, Y., de Moura, L.M.: Complete instantiation for quantiﬁed formulas in satisﬁabiliby
modulo theories. In: Bouajjani, A., Maler, O. (eds.) Computer Aided Veriﬁcation, 21st
International Conference, CAV 2009, Grenoble, France, June 26 - July 2, 2009. Pro-
ceedings. Lecture Notes in Computer Science, vol. 5643, pp. 306–320. Springer (2009),
http://dx.doi.org/10.1007/978-3-642-02658-4_25

35. Givant, S.: The calculus of relations as a foundation for mathematics. J. Autom. Reasoning

37(4), 277–322 (2006), http://dx.doi.org/10.1007/s10817-006-9062-x

36. Lamport, L.: Specifying Systems, The TLA+ Language and Tools for Hardware and
Software Engineers. Addison-Wesley (2002), http://research.microsoft.com/users/
lamport/tla/book.html

37. Leuschel, M., Butler, M.: ProB: A model checker for B. In: Keijiro, A., Gnesi, S., Mandrioli,
D. (eds.) FME. Lecture Notes in Computer Science, vol. 2805, pp. 855–874. Springer-Verlag
(2003)

38. Luna, C., Betarte, G., Campo, J.D., Sanz, C., Cristi´a, M., Gorostiaga, F.: A formal ap-
proach for the veriﬁcation of the permission-based security model of Android. CLEI Elec-
tron. J. 21(2) (2018), https://doi.org/10.19153/cleiej.21.2.3

39. Mammar, A., Laleau, R.: Modeling a landing gear system in Event-B. In: Boniol, F., Wiels,
V., Ameur, Y.A., Schewe, K. (eds.) ABZ 2014: The Landing Gear Case Study - Case
Study Track, Held at the 4th International Conference on Abstract State Machines, Alloy,
B, TLA, VDM, and Z, Toulouse, France, June 2-6, 2014. Proceedings. Communications
in Computer and Information Science, vol. 433, pp. 80–94. Springer (2014), https://doi.
org/10.1007/978-3-319-07512-9_6

40. de Moura, L.M., Bjørner, N.: Eﬃcient e-matching for SMT solvers. In: Pfenning, F. (ed.)
Automated Deduction - CADE-21, 21st International Conference on Automated Deduc-
tion, Bremen, Germany, July 17-20, 2007, Proceedings. Lecture Notes in Computer Sci-
ence, vol. 4603, pp. 183–198. Springer, https://doi.org/10.1007/978-3-540-73595-3_13
41. Omodeo, E.G., Parlamento, F., Policriti, A.: Decidability of ∃*∀-sentences in membership
theories. Math. Log. Q. 42, 41–58 (1996), https://doi.org/10.1002/malq.19960420105

42. Omodeo, E.G., Policriti, A.: The Bernays - Sch¨onﬁnkel - Ramsey class for set theory: decid-
ability. J. Symb. Log. 77(3), 896–918 (2012), https://doi.org/10.2178/jsl/1344862166

32

Maximiliano Cristi´a, Gianfranco Rossi

43. Parlamento, F., Policriti, A.: Undecidability results for restricted universally quantiﬁed
formulae of set theory. Communications on Pure and Applied Mathematics 46(1), 57–73
(1993), https://onlinelibrary.wiley.com/doi/abs/10.1002/cpa.3160460104

44. Parlamento, F., Policriti, A.: The logically simplest form of the inﬁnity axiom 103(1),

274–276

45. Parlamento, F., Policriti, A.: The decision problem for restricted universal quantiﬁcation
in set theory and the axiom of foundation. Math. Log. Q. 38(1), 143–156 (1992), https:
//doi.org/10.1002/malq.19920380110

46. Rossi, G.: {log}. http://www.clpset.unipr.it/setlog.Home.html (2008), last access 2022
47. Schneider, S.: The B-method: An Introduction. Cornerstones of computing, Palgrave

(2001), http://books.google.com.ar/books?id=Krs0OQAACAAJ

48. Woodcock, J., Davies, J.: Using Z: speciﬁcation, reﬁnement, and proof. Prentice-Hall, Inc.,

Upper Saddle River, NJ, USA (1996)

A Proofs

In the following, a set of the form {P (x ) : F (x )} (where pattern and ﬁlter are separated
by a colon (:), instead of a bar (|), and the pattern is before the colon) is a shorthand for
{y : ∃ x (P (x ) = y ∧ F (x ))}. That is, the set is written in the classic notation for intensional
sets used in mathematics.

Proposition 1

∀ d,D :

{x : {d ⊔ D} | φ • u} = {u(d) : φ(d)} ∪ {u(x ) : x ∈ D ∧ φ(x )}

Proof Taking any d and D we have:

{x : {d ⊔ D} | φ • u}
= {u(x ) : x ∈ {d ⊔ D} ∧ φ(x )}
= {u(x ) : (x = d ∨ x ∈ D) ∧ φ(x )}
= {u(x ) : (x = d ∧ φ(x )) ∨ (x ∈ D ∧ φ(x ))}
= {u(x ) : x = d ∧ φ(x )} ∪ {u(x ) : x ∈ D ∧ φ(x )}
= {u(d) : φ(d)} ∪ {u(x ) : x ∈ D ∧ φ(x )}

Lemma 2 (Equivalence of rule (10))

∀ t, A : t /∈ A ⇒

{t ⊔ A} ∪ {x : {t ⊔ A} | φ} = {x : {t ⊔ A} | φ} ⇔ φ(t) ∧ A ∪ {x : A | φ} = {x : A | φ}

Proof First note that

t /∈ A ⇒ {t} k A ∧ {t} k {A | φ}

and

{x : {t} | φ} ⊆ {t}

and

{x : {t} | φ} = {t} ⇔ φ(t)

⊓⊔

(37)

(38)

(39)

{t ⊔ A} ∪ {x : {t ⊔ A} | φ} = {x : {t ⊔ A} | φ}
⇔ {t} ∪ A ∪ {x : {t} | φ} ∪ {x : A | φ} = {x : {t} | φ} ∪ {x : A | φ} [by Prop. 1; semantics ⊔]
⇔ {t} ∪ A ∪ {x : A | φ} = {x : {t} | φ} ∪ {x : A | φ}
[by (38); {t} in left-hand side]
⇔ φ(t) ∧ {t} ∪ A ∪ {x : A | φ} = {t} ∪ {x : A | φ}
⇔ φ(t) ∧ A ∪ {x : A | φ} = {x : A | φ}

[by (37); basic property of k and ∪]

[by (39)]

