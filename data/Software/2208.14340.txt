Solving the One-Dimensional Time-Independent

Schr¨odinger Equation with High Accuracy:
The LagrangeMesh Mathematica(cid:114) Package

J.C. del Valle∗

Faculty of Mathematics, Physics, and Informatics,

University of Gda´nsk, 80-308 Gda´nsk, Poland

Abstract

In order to ﬁnd the spectrum associated with the one-dimensional Schr¨odinger equation, we dis-

cuss the Lagrange Mesh method (LMM) and its numerical implementation for bound states. After

presenting a general overview of the theory behind the LMM, we introduce the LagrangeMesh
package: the numerical implementation of the LMM in Mathematica(cid:114). Using few lines of code,

the package enables a quick home-computer computation of the spectrum and provides a practical

tool to study a large class of systems in quantum mechanics. The main properties of the package

are (i) the input is basically the potential function and the interval on which is deﬁned; and (ii)

the accuracy in calculations and ﬁnal results is controllable by the user. As illustration, a highly

accurate spectrum of some relevant quantum systems is obtained by employing the commands

that the package oﬀers. In fact, the present work can be regarded as a user guide based on worked

examples.

2
2
0
2

g
u
A
0
3

]
h
p
-
t
n
a
u
q
[

1
v
0
4
3
4
1
.
8
0
2
2
:
v
i
X
r
a

∗ juan.delvalle@ug.edu.pl

1

 
 
 
 
 
 
CONTENTS

I. Introduction

II. The one-dimensional Lagrange Mesh Method

A. Gauss Quadrature

B. Lagrange Functions

C. The Secular Equations and Lagrange Mesh Equations

III. Formulas for Lagrange Functions and Kinetic Elements

A. Finite Domain

B. Semi-Finite Domain

C. Inﬁnite Domain

IV. Discretization, Scaling, and Mapping

A. Discretization of the Eigenfunctions

B. Scaling

C. Mapping

V. The LagrangeMesh Mathematica(cid:114) package

A. Installation

B. Commands

1. BuildMesh

2. AvailableMeshQ

3. LagMeshEigenvalues

4. LagMeshEigenfunctions

5. LagMeshEigensystem

C. Worked Examples

1. Exactly Solvable Potentials

2. Some Non-Solvable Potentials

3. Possible Issues

VI. Conclusions

Acknowledgments

References

2

3

6

6

8

8

11

11

12

13

13

14

14

15

16

16

17

17

18

19

21

23

23

24

27

36

38

39

39

I.

INTRODUCTION

Solutions to the time-independent Schr¨odinger equation [1] are crucial for our current

understanding of quantum mechanics. However, only a handful of systems described by

this equation admit exact solutions. Since the early days of quantum mechanics, the lack

of exact solutions has stimulated the development of methods to ﬁnd them in approximate

form. In this paper, we describe and implement computationally one of such methods: the

Lagrange Mesh, see [2].

In general terms, the Lagrange Mesh Method (LMM) is an approximate variational ap-

proach in which a linear combination of Lagrange functions approximates the exact eigen-

functions. These functions are related to a set of mesh points and the Gauss quadrature

associated with this mesh. The outcome of the method is the lowest eigenvalues and eigen-

functions in approximate form.

Even though the LMM has been extensively used to study the spectrum of quantum

systems1 with few degrees of freedom (three at most), we focus on the situation when

there is only one. Therefore, the main object of the present work is the one-dimensional

Schr¨odinger equation,

(cid:126)2

−

2m

∂2
xψ(x) + V (x)ψ(x) = E ψ(x) ,

∂x

≡

d
dx

,

(I.1)

deﬁned on some interval (a, b). We assume that the potential V (x) is conﬁning and that

any eigenfunction vanishes at the endpoints. For equation (I.1), we describe and implement

the LMM computationally for all possible one-dimensional domains: ﬁnite, semi-ﬁnite, and

inﬁnite. Under certain conditions described in this paper, our implementation of the LMM

leads to a highly accurate spectrum obtained in short CPU times.

The aim of the present paper is two-fold. From one side, we give a concrete discussion

of the LMM, which can serve as a pedagogical introduction to the method itself. From

the other, we introduce the LagrangeMesh package: a numerical implementation of the
LMM written in Mathematica(cid:114) 13. Once installed, it will provide the user with ﬁve com-

1 See, for example, [3], [4], and [5].

3

mands to realize the LMM on equation (I.1). We chose this widely used programming

language due to its clearness and compactness while coding, as well as for its forward com-

patibility with newer versions. Furthermore, we exploit the arbitrary precision arithmetic
that Mathematica(cid:114) provides specifying the option WorkingPrecision. In fact, the com-

mands supplied by the LagrangeMesh are equipped with this option to control the loss

of accuracy during calculations. It allows the user to reach and overcome benchmarks for

eigenvalues and eigenfunctions in a few lines of code using a standard nowadays computer.

Therefore, the package is user-friendly. Compared with previous implementations2, these

characteristics make the LagrangeMesh package superior in terms of accuracy control. It
is important to mention that Mathematica(cid:114) already counts with default commands to solve

spectral problems3, particularly those of the Schr¨odinger type. However, they are limited to

machine precision. Therefore, the LagrangeMesh package is unique in this aspect. On the
other hand, to the best of the author’s knowledge, there is only one package in Mathematica(cid:114)

4 devoted to solve (I.1), see [6]. It is based on a high-order Numerov scheme that requires

short CPU times. However, it has some limitations: (i) long input data needed, (ii) it is

mainly focused on obtaining eigenvalues; (iii) limited accuracy to machine precision. As we

will show, the LagrangeMesh package does not have these drawbacks.

In recent years, Mathematica(cid:114) notebooks, codes, and packages have been designed to

implement diﬀerent tools frequently used in quantum mechanics. Now we mention some of

them. High-order corrections in perturbation theory can be calculated via the BenderWu

package for locally one-dimensional harmonic potentials [7]. The notebook M-CHIPR.nb

constructs potential energy functions for triatomic molecules [8]. The package GroupMath

is oriented to Lie algebras [9]. For tight-binding calculations, we can use the MathemaTB

package [10]. In this way, the LagrangeMesh will complement such tools.

The present work is organized as follows:

in Sections II, III, and IV, we present a de-

scription of the LMM. The discussion is aimed to give the user the fundamental concepts

behind the package. Undoubtedly, knowing the niceties and limitations of the method may

lead to better performance during calculations.

In Section V, we introduce the LagrangeMesh package with a detailed description of

2 Most of them written in FORTRAN working with double and, sometimes, quadruple precision. See [2]

and references therein.

3 See built-in commands NDEigensystem and NDEigenvalues.

4

the usage. Actually, this Section can be regarded as a user guide based on worked exam-

ples. Speciﬁcally, we complement the discussion with concrete applications. First, we show

how commands are used for obtaining the spectrum of exactly solvable potentials. These

examples set the ground for the study of relevant quantum-mechanical systems/potentials:

quartic anharmonic oscillator, quartic double-well with degenerate minima, shell-conﬁned

hydrogen atom,

-symmetric cubic oscillator, quasi-exactly solvable sextic anharmonic

potential, and Rydberg atoms.

PT

Those worked examples allow us to study diﬀerent phenomena that appear in the quantum

spectrum and glimpse the scope of the package. For instance, for the quartic double well, we

can calculate the exponentially small gap between the two lowest states and study the partial

sums of the semi-classical resurgent expansion [11]. In general, the results obtained by the

package are shown in worked examples are compared with those found in the literature.

To simplify Section V, we present blocks of codes that show concrete numerical imple-
mentations. They display the input and output in the same way Mathematica(cid:114) does. In
addition, we show some plots generated in Mathematica(cid:114) and their corresponding codes

from which they were generated. We have avoided labeling the axis of plots to keep blocks

as simple and compact as possible. All calculations displayed on such blocks were performed

using a Mac Mini (2014) with 2.7 GHz Intel Core i5 and 8GB RAM.

5

II. THE ONE-DIMENSIONAL LAGRANGE MESH METHOD

Three basic ingredients are the building blocks of the LMM: the Gauss quadrature ap-

proximation, the Lagrange functions, and the secular equations. In the following Sections,

we give an overview of each one. Full details can be found in [2] and references therein.

A. Gauss Quadrature

Consider the one-dimensional integral over a smooth function f (x) on the interval4 [a, b],

namely,

where w(x)

≥

(cid:90) b

a

f (x) w(x) dx ,

(II.1)

0 is a given weight function. Frequently this integral can not be computed an-

alytically. Nevertheless, numerical integration methods can circumvent this inconvenience.

Among those methods, the Gauss quadrature approximation stands alone due to its sim-

plicity, eﬃciency, and high accuracy. The basic idea of this approach is to approximate the

integral (II.1) by a particular ﬁnite sum:

(cid:90) b

a

f (x) w(x) dx

N
(cid:88)

k=1

≈

wkf (xk) .

(II.2)

xk

The set

N
k=1 the (positive) weights. The expres-
}
sion shown on the right-hand side of (II.2) is the so-called Gauss quadrature approximation.

N
k=1 contains the mesh points, while
}

wk
{

{

To determine

}
be exact when the function f (x) is a polynomial of the degree (2N

N
k=1, we demand the Gauss quadrature approximation to
1). As a result, it can

N
k=1 and

xk
{

wk

}

{

be shown that

N
k=1 are real and they may be obtained by solving algebraic
equations. However, there is a more eﬃcient way to ﬁnd mesh points and weights in practice.

N
k=1 and

xk
{

wk

{

}

}

−

It can be demonstrated [12] that the N mesh points

of the N -degree orthogonal polynomial

N (x) associated with the weight function5 .

N
k=1 are nothing but the N zeroes
In

xk
{

}

addition, any wk is basically given in terms of xk,

N −1(xk), and

(cid:48)
N (xk), see [2]. However,

P

P

4 The interval of integration can be ﬁnite [a, b], semi-inﬁnite [a,
5 For a given weight function w(x), one can always construct a set of orthogonal polynomials

,
−∞

) or (

−∞

∞

∞

).

P
, b], or inﬁnite (

N
k=1using the Gram-Schmidt w(x) process.
k(x)
}

{P

6

the well-known explicit form of the weights is irrelevant for the LMM, so we omit to present

it.

Once we choose [a, b] and w(x),

xk
{
taking w(x) = 1 and the interval [

N
k=1 and

N
k=1 are completely deﬁned. For example,
}
1, 1], the mesh points are the N zeroes of the Legendre

wk

{

}

−

polynomial of order N . The name of the mesh is usually given according to the name of

the polynomials involved. Therefore, in the above example

mesh of N -points.

N
k=1 constitutes a Legendre

xk
{

}

It is worth noting that, by construction, the accuracy of the Gauss quadrature approxi-

mation (II.2) depends on how well f (x) is approximated by a polynomial of degree (2N

in [a, b]. If f (x) is 2N -times diﬀerentiable, the error estimate is given by

1)

−

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:90) b

a

f (x)w(x) dx

N
(cid:88)

k=1

−

wkf (xk)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12) ≤

(cid:82) b
a P

N (x)2 dx
(2N )!

f (2N )(ξ)

sup
ξ∈[a,b]{

,

}

(II.3)

see [12] for details and derivation. Consequently, if the function f (x) is suﬃciently smooth,

the accuracy of the Gauss quadrature approximation usually increases as N does. However,

it may fail if f (x) has singularities, discontinuities, or it is not diﬀerentiable at some points

of (a, b).

In practice, the appearance of the weight function w(x) in the integrand of (II.1) can be

omitted by deﬁning an auxiliary function

g(x) = f (x) w(x) .

(II.4)

In this way, the Gauss quadrature approximation (II.1) now takes the form

(cid:90) b

a

g(x) dx

N
(cid:88)

k=1

≈

λkg(xk) ,

λk =

wk
w(xk)

,

k = 1, 2, ..., N .

(II.5)

Now

λk
{

N
k=1 play the role of weights. Throughout this paper, we will work with the Gauss
}
quadrature approximation deﬁned according to (II.4) and (II.5). In addition, for the pur-

poses of the present work, only meshes and weights associated with Legendre, Laguerre, and

Hermite classical orthogonal polynomials are relevant.

7

B. Lagrange Functions

The second ingredient of the LMM is a special set of N smooth (inﬁnitely diﬀerentiable)

real functions

{
need to choose a particular mesh

fi(x)
}

N
i=1, which are called Lagrange functions. To deﬁne them, ﬁrst we
N
k=1. By
}

N
k=1 and know the corresponding weights
}

λk

xk

{

{

deﬁnition, a Lagrange function should satisfy two requirements:

1. The Lagrange condition, which is

fi(xj) = λ−1/2

i

δij

,

i, j = 1, 2, ..., N .

(II.6)

2. Lagrange functions are orthonormal in the Gauss quadrature approximation (GQA),

namely

(cid:90) b

a

fi(x)fj(x) dx GQA= δij .

(II.7)

There are well-known prescriptions to construct Lagrange functions based on orthogonal

polynomials. They can be found explicitly in [2], so we skip details. For the cases of our

interest (Legendre, Laguerre, Hermite), explicit formulas of Lagrange functions are presented

further down. Since the explicit form of the weights

wk
{

}

N
k=1 can be extracted from them

using the Lagrange condition (II.6), we avoid presenting such expressions.

C. The Secular Equations and Lagrange Mesh Equations

The third ingredient of the LMM is the set of the so-called secular equations. These equa-

tions are useful for ﬁnding in approximate form the spectrum of a given time-independent

Schr¨odinger equation,

ˆHψ = E ψ ,

8

(II.8)

where ψ is the wavefunction (eigenfunction), E the energy (eigenvalue), and ˆH the Hamil-

tonian.6 In particular, we are interested in the one-dimensional Hamiltonian of the form

ˆH =

(cid:126)2

−

2m

∂2
x + V (x) ,

(II.9)

where m is the mass of the particle, V (x) a conﬁning potential, and (cid:126) the reduced Planck
constant. We assume that ˆH is deﬁned in (a, b), and the boundary conditions imposed tor

eigenfunctions are

ψ(a) = ψ(b) = 0 .

(II.10)

Under the above-mentioned conditions, the spectrum of the Hamiltonian (II.9) is real and

discrete for the so-called bound states. These states are characterized by a squared-integrable

eigenfunction, such that

(cid:90) b

2 dx = 1 .
ψ(x)
|

a |

(II.11)

As we previously mentioned, frequently the spectral problem deﬁned by (II.8) cannot be

solved in exact form. To ﬁnd an approximate solution, let us suppose that any wavefunction

can be approximated by means of the linear combination

ψ(x)

≈

N
(cid:88)

k=1

ck φk(x) .

(II.12)

Here

φk
{

N
k=1 is a set of N orthonormal functions which are chosen in such a way that
boundary conditions (II.10) are fulﬁlled. In turn, coeﬃcients ck are unknown for the moment.

}

In fact, using the variational principle, one can easily show that ck are determined by the

equations

where

N
(cid:88)

j=1

(cid:18) (cid:126)2
2m

(cid:19)

Tij + Vij

cj = E ci ,

i = 1, 2, ...N ,

(II.13)

Tij =

(cid:90) b

−

a

φi(x) ∂2

xφj(x) dx ,

Vij =

(cid:90) b

−

a

φi(x)V (x)φj(x) dx .

(II.14)

6 The terms eigenvalue and energy will be used indistinctly, a similar situation with eigenfunction and

wavefunction.

9

Equations (II.13) are the so-called secular equations, see [13] for details. They establish that,

in order to ﬁnd ck, we have to diagonalize the matrix representation of the Hamiltonian

constructed with the functions

N
k=1. As a result, eigenvalues of this matrix correspond
to approximations of the exact energies; meanwhile, eigenvectors contain coeﬃcients ck that

φk

}

{

ultimately determines the approximate wavefunctions.

Note that Tij and Vij in (II.14) play the usual role of kinetic and potential matrix ele-

ments, respectively. In the LMM, those matrix elements are calculated by taking φk(x) as

Lagrange functions fk(x) and using the Gauss quadrature to compute the integrals involved

in matrix elements. This approach connects the three ingredients discussed above. Under

these considerations, the secular equations (II.13) now read

N
(cid:88)

j=1

(cid:18) (cid:126)2
2m

(cid:19)

ij + V (G)
T (G)

ij

cj = E ci ,

(II.15)

where the super-index (G) indicates that we are using the Gauss quadrature when integrating

(II.14). In this sense, due to the Gauss quadrature approximation, the LMM is an approxi-

mate variational method. Equations presented in (II.15) are called Lagrange equations. As

a consequence of using Lagrange functions and the Gauss quadrature approximation, the

potential matrix elements are diagonal,

V (G)
ij = V (xi) δij .

(II.16)

Hence, its computation is straightforward: the potential is evaluated at the mesh points.

This property makes the LMM a versatile approach to study, in principle, any conﬁning

potential. The only requirement is that (II.16) approximates with high accuracy the exact
potential elements shown in (II.14). On the other hand, the kinetic matrix elements T (G)

ac-

ij

quire simple and compact expressions written in terms of

and N . Explicit formulas

xi, xj

{

}

for relevant cases (Legendre, Laguerre, and Hermite) are presented below.

To conclude this Section, let us indicate an important remark concerning the calculation
of the expectation value of a given scalar operator ˆO = O(x). In the context of the LMM,

10

the expectation value of ˆO,

ˆO
(cid:104)

(cid:105)

=

(cid:90) b

a

ψ∗(x)O(x)ψ(x) dx ,

(II.17)

is calculated taking into account the Gauss quadrature approximation when integrating.

Since ψ(x) is a linear combination of Lagrange functions, it is easy to see that

ˆO
(cid:104)

(G)

(cid:105)

=

N
(cid:88)

k=1

ck
|

2O(xk) ,
|

(II.18)

where the super-index (G) indicates the usage of the Gauss quadrature. Equation (II.18)

is a direct consequence of the properties (II.6) and (II.7). In summary, the calculation of

expectation values of scalar operators is reduced to calculate the sum (II.18).

III. FORMULAS FOR LAGRANGE FUNCTIONS AND KINETIC ELEMENTS

Now we present three Lagrange functions deﬁned for ﬁnite, semi-ﬁnite, and inﬁnite in-

tervals. They all are based on the following classical orthogonal polynomials: Legendre,

Laguerre, and Hermite, respectively. For completeness, explicit formulas of the kinetic ma-
trix elements in the Gauss quadrature approximation T (G)

are shown. As we will see, they

ij

are written in compact expressions. Details concerning their derivation can be found in [2]

and references therein.

A. Finite Domain

For the ﬁnite interval [

Lagrange functions read

1, 1], it is natural to use a Legendre mesh. The corresponding

−

fi(x) =

(
−

1)N +i+1(x + 1)(1
(cid:112)2(xi + 1)(1

−
xi)

−

x)

PN (x)
xi
x

−

,

i = 1, 2, ..., N .

(III.1)

Here PN (x) denotes the N -th Legendre polynomial. By construction, any Lagrange function

fi(x) satisﬁes fi(

−

1) = fi(1) = 0. Thus, boundary condition (II.10) is fulﬁlled for a =

1

−

11

and b = 1. The kinetic matrix elements T (G)

ij

are given by

1)i+j+1(xixj + 1)

T (G)
i(cid:54)=j =

(

−

(xi

−
xj)2

(cid:113)

(1

x2
i )(1

x2
j )

−

−

,

T (G)
ii =

N (N + 1)(1

x2
i ) + 4
−
x2
i )2

3(1

−

.

(III.2)

Functions shown in (III.1) are building blocks to consider arbitrary but ﬁnite, intervals of

the form [a, b]. This can be achieved via a monotonic mapping t : [

1, 1]

→

[a, b], see below

−

for discussion.

B. Semi-Finite Domain

Now we consider [0,

). In this case, the natural mesh is a Laguerre one. The corre-

sponding Lagrange functions are

∞

fi(x) = (

1)N +i x
√xi

−

LN (x)
xi
x

−

e−x/2 ,

i = 1, 2, ...N .

(III.3)

Here LN (x) denotes the N -th Laguerre polynomial. From (III.3), it is clear that any La-

grange function fi(x) satisﬁes fi(0) = fi(

) = 0. Therefore, boundary condition (II.10) is

fulﬁlled for a = 0 and b =

. Explicit formulas for kinetic matrix elements T (G)

are

ij

∞

∞

T (G)
i(cid:54)=j =

(
−
√xi xj(xi

1)i−j(xi + xj)
xj)2 ,

−

T (G)
ii =

(4N + 2)xi

−
12 x2
i

x2
i + 4

.

(III.4)

Note that with a global translation of mesh points and Lagrange functions (III.3), we can

tackle domains of the form [a,

).

∞

Another important remark concerning functions (III.3) must be emphasized. For now,

consider the reduced three-dimensional radial Schr¨odinger Hamiltonian

ˆH =

(cid:126)2

−

2m

∂2
r +

(cid:126)2(cid:96)((cid:96) + 1)

2mr2 + V (r) ,

0

r <

,

∞

≤

(cid:96) = 0, 1, ...

(III.5)

where r denotes the radial variable in the standard spherical coordinate system, and (cid:96) the

angular momentum quantum number. If the radial potential V (r) is conﬁning, the boundary

12

conditions

ψ(0) = 0 ,

ψ(

) = 0

∞

(III.6)

are usually imposed when solving the reduced radial Schr¨odinger equation ˆHψ(r) = Eψ(r).

Hence, Lagrange functions (III.3) are adequate to approximate three-dimensional radial

eigenfunctions in the form of (II.12). A similar situation occurs with Lagrange functions

based on Legendre polynomials (III.1): they are useful to study radial potentials when the

particle is conﬁned to a spherical core-shell or shell type cavity. Explicit examples will be

presented further in the text.

C.

Inﬁnite Domain

For the one-dimensional case in (

∞
The corresponding Lagrange functions, read

−∞

,

), it is natural to consider the Hermite mesh.

fi(x) =

1)N −i
(
−
(2 hN )1/2

HN (x)
xi
x

−

e−x2/2 ,

hN = 2N N !√π ,

i = 1, 2, ..., N ,

(III.7)

where HN (x) denotes the N -th Hermite polynomial.

It is clear that any fi(x) satisﬁes

fi(

) = fi(

−∞

∞

) = 0, since it decays exponentially at large

condition (II.10) is fulﬁlled for a =

and b =

−∞

∞

. Therefore, boundary
x
|
|
. Kinetic matrix elements T (G)

are

ij

T (G)
i(cid:54)=j = (

1)i−j

−

(xi

2

−

xj)2 ,

T (G)
ii =

1
3

(2N + 1

x2
i ) .

−

(III.8)

IV. DISCRETIZATION, SCALING, AND MAPPING

Before introducing the LagrangeMesh package, there are some aspects of the method

that have to be discussed. In particular, they play an essential role when performing a highly

accurate calculation of the spectrum.

13

A. Discretization of the Eigenfunctions

In the framework of the LMM, the approximate wavefunction has the representation

ψ(x) =

N
(cid:88)

k=1

ck fk(x) ,

x

a

≤

≤

b ,

(IV.1)

where fk(x) is the k-th Lagrange function. Note that if N is large, the number of arithmetic

operations involved when evaluating (IV.1) numerically at some arbitrary point x can be

huge. Therefore, the accumulation of error can play an important role and it might lead to

wrong results for ψ(x). There is a way to avoid such situation, but we have to abandon the

idea of constructing a continuous wavefunction like (IV.1). Through the Lagrange condition

(II.6), a N -point discrete version of ψ(x) deﬁned at the non-uniform mesh points

can be obtained by noting that

xk

N
k=1
}

{

ψ(xk) =

ck
λ1/2
k

,

k = 1, 2, ..., N .

(IV.2)

This discrete representation usually leads to better approximations of ψ(xk) than evaluating

directly via (IV.1).

B. Scaling

Higher accuracy in results predicted by the LMM can be obtained if the mesh points

lie inside the region where the wavefunction is not too small. A global scaling of the mesh

points in the form

xk

→

h xk ,

h > 0 ,

k = 1, 2, ..., N ,

(IV.3)

may move them to such region. We have denoted the global scaling parameter by h. If it

is chosen appropriately, it can increase accuracy and improve the performance of the LMM

reducing CPU times. In addition, Lagrange functions should be modiﬁed accordingly,

fi(x)

→

1
h1/2 fi(x/h) .

14

(IV.4)

The factor h1/2 is introduced to fulﬁll the Lagrange condition (II.6). The usage of h not only

modiﬁes the mesh points and the Lagrange functions, it also aﬀects the Lagrange equations.

They now read

N
(cid:88)

j=1

(cid:18) (cid:126)2
2mh2 T (G)

ij + V (hxi)δij

(cid:19)

cj = E ci .

(IV.5)

Sometimes h can be used as a variational parameter, especially if N is large. However, the

Gauss quadrature approximation used in (IV.5) may lead to a fake minimum in energy with

respect to h.

C. Mapping

The above-mentioned global scaling transformation of a mesh is one of the simplest

mappings that can be implemented to move the mesh points. Let us focus on the Legendre

mesh and the corresponding Lagrange functions. This mesh is originally deﬁned in [

1, 1]

−

by construction, but it can be easily mapped into [a, b] using the following linear function

[14],

t(x) =

a

b

−
2

x +

a + b
2

,

t(

−

1) = a ,

t(1) = b .

(IV.6)

This simple function allows us to scale, translate, reﬂect, and map the mesh points. In this

way, we can realize the LMM in an arbitrary ﬁnite domain apart from [

1, 1]. Lagrange

−

functions are modiﬁed as well according to

fi(x)

→

(cid:114) 2
b

−

a

fi(t−1(x)) .

(IV.7)

Similar considerations can be made for the Laguerre mesh.

Instead of providing further

details, which can be found in [2], we point out that all necessary transformations are

implemented in the LagrangeMesh package internally and automatically.

In this way,

the user can study spectral problems deﬁned in any one-dimensional interval: [a, b], [a,

(
−∞

, b), and (

−∞

,

).

∞

15

),

∞

V. THE LAGRANGEMESH MATHEMATICA(cid:114) PACKAGE

The LagrangeMesh package7 implements the LMM for solving the one-dimensional

Schr¨odinger equation in diﬀerent domains for an arbitrary potential.

While presenting the main characteristics of the package, we focus on working out par-

ticular examples to show the usage. As we mentioned previously, we use blocks of codes

that display input/output to show the usage of each command. All worked examples can

be found in the supplemental ﬁle called Examples.nb. The reader without previous expe-

rience with the LMM is encouraged to refer to it. Throughout rest of this text, the value of
the reduced Planck constant (cid:126) is set to the unity ((cid:126) = 1).

A.

Installation

The ﬁle called LagrangeMesh.wl contains the package. Once downloaded, there are

two ways to use it, let us describe both options.

1. Full installation of the package. This can be achieved via the Install option located

at the menu of Mathematica(cid:114): File

Install. The procedure is straightforward, so

→

we omit details that can be found in [15]. Once the installation was successful, the

package is loaded evaluating Needs["LagrangeMesh‘"] in the notebook we want

to use. Each time the kernel is restarted, we need to load the package as indicated.

2. Loading the package temporarily. This is a simple alternative that not requires in-

stallation. This option only works if the package and the notebook (in which we will

perform calculations) are contained in same directory. Loading the package is achieved

by evaluating <<"path/LagrangeMesh.wl" in the notebook ﬁle we want to work

with. The explicit form of path is found evaluating NotebookDirectory[]. Each

time the kernel is restarted, we need to load the package as indicated.

7 Designed in Mathematica(cid:114) 13, and tested in versions 12 and 13.

16

B. Commands

Once installed or loaded, the LagrangeMesh package will provide the user ﬁve new

commands. Two related to the construction of meshes and weights: BuildMesh and

AvailableMeshQ; and three additional for realizing the LMM: LagMeshEigenvalues,

LagMeshEigenfunctions, and LagMeshEigensystem. These commands are de-
signed with the standard Mathematica(cid:114) style (coloring, syntax, etc.).

In addition, each

command counts with several alert messages that can guide the user on how to correct

syntax errors. Below, we describe the general use and syntax of each command.

1. BuildMesh

This command constructs mesh points (zeroes) and weights for a given type of classical

orthogonal polynomial. The syntax of this command is the following:

BuildMesh[Type,Dimension,Options]

•

•

•

Type speciﬁes the classical polynomial, it can only take the value of the following strings

"Legendre", "Laguerre", or "Hermite".

Dimension deﬁnes the number of mesh points. Therefore, its value must be a positive

integer number.

There are two Options that can be speciﬁed for the command BuildMesh. They allow

the user to compute of the Gaussian weights and to control the accuracy of calculations.

Each option is described in Table I

In In[1], we show how to calculate a Laguerre mesh of N = 50 points together with the

corresponding weights using 100-digits arithmetic.

17

In[1]:=BuildMesh["Laguerre",50,Weights→True,WorkingPrecision→100]Out[1]:=Laguerre50WP100.datLaguerre50WP100Weights.datTable I: Options for the command BuildMesh.

Option

Weights

WorkingPrecision

Description

Default Value

If the value is set to True, the weights asso-
ciated to the mesh will be calculated.

False

It speciﬁes how many digits of precision
should be maintained in internal computa-
tions. Thus, it controls the accuracy of mesh
points and weights.

MachinePrecision

As output, shown in Out[1], the program prints on screen the name of two ﬁles that were

generated and stored. They contain the mesh points and weights, respectively. The param-

eters that characterize the calculation are speciﬁed in the name given. Once created, ﬁles

will be automatically stored in speciﬁc directories, so they can be used in future calculations

without calculating them again. The location of those ﬁles is shown in the tree diagram

in Fig. 1. Using the command BuildMesh once, sub-directories inside Meshes will be

automatically created.

2. AvailableMeshQ

Once several meshes are constructed and stored, we can generate an ordered table that

shows them on screen. The latter is the primary purpose of the command. The secondary

is to check if a specif mesh exists: it delivers on screen True in the case it does, and False

otherwise. The syntax for this command is the following:

AvailableMeshQ[Type,Options]

•

•

Type speciﬁes the classical polynomial, it can only take the value of the following strings

"Legendre", "Laguerre", or "Hermite".

There are three Options that can be speciﬁed for the command AvailableMeshQ.

They control the output printed on screen. Each option is described in Table II.

18

Figure 1: Tree diagram that shows the location of the stored mesh points and weights.
The presence of the ﬁle LagrangeMesh.wl at the level of MyWorkNotebook.nb is
optional, it is only required if we are loading the package temporarily, see text. Otherwise,
it can be removed from MyDirectory. All directories inside MyDirectory will be
automatically created on the ﬁrst use of the command BuildMesh.

As an example, below we present a typical block of code with output Out[2] generated by

the command AvailableMeshQ. It consists of all meshes stored with Dimension

20.

→

3. LagMeshEigenvalues

This command calculates the desired number of eigenvalues of the Schr¨odinger equation

(II.8) deﬁned in (a, b) for a given potential function V (x). For a given domain, if the

19

MyDirectoryLagrangeMesh.wlMyWorkNotebook.nbMeshesHermiteLaguerreMeshPointsLaguerre50WP100.datWeightsLaguerre50WP100Weights.datLegendreIn[2]:=AvailableMeshQ["Laguerre",Dimension→20]Out[2]:=DimensionWorkingPrecisionWeights2010No2020Yes2050No20100Yes20200Yes20300Yes20MachinePrecisionNoTable II: Options for the command AvailableMeshQ.

Option

Description

Default Value

Dimension

PrintDomain

PrintMesh

If we are interested in displaying meshes of
a particular dimension, this option may be
useful. If there is no mesh with such dimen-
sion, the output will be False.

DefaultPrecision

If Dimension and WorkingPrecision
are speciﬁed, the corresponding smallest and
greatest mesh points will be displayed on
screen.

False

If Dimension and WorkingPrecision
are speciﬁed, the corresponding mesh will be
displayed on screen.

False

WorkingPrecision

It speciﬁes to look for meshes with a given
number of digits in accuracy. If only this op-
tion and Dimension are speciﬁed, the out-
put will be True or False.

DefaultPrecision

corresponding mesh was not previously constructed, LagMeshEigenvalues will build it

automatically calling BuildMesh internally. Therefore, the manual usage of BuildMesh

can be avoided by the user. After calculations, an ordered list8 with the ﬁrst approximate

eigenvalues will be printed on screen. The syntax of the command LagMeshEigenvalues

is the following:

LagMeshEigenvalues[V[x],

x,a,b

{

,NLevels,Dimension,Options]

}

where

•

V[x] speciﬁes the potential V (x) of the Schr¨odinger equation (II.8). It must be a numer-

ical expression with one degree of freedom, in this case denoted by x.

• {

x,a,b

deﬁnes the domain in the variable x that appears in the potential. The program

}

automatically will select, construct, and map the appropriate mesh for the given domain.

8 In ascending order, starting from the lowest eigenvalue.

20

For a ﬁnite interval, semi-ﬁnite and inﬁnite, the Legendre, Laguerre, and Hermite are

used, respectively.

•

•

•

NLevels represents the number of the lowest eigenvalues that we desire to calculate.

Naturally, its value should be a positive integer number.

Dimension deﬁnes the size of the mesh, i.e., the number of mesh points.

There are seven Options that can be set by the user. They are presented in Table III

together with a brief description. In addition, all available options of the build-in com-

mand Eigenvalues are incorporated into LagMeshEigenvalues. In general terms,
they can be useful to reduce CPU times. Details can be found in the Mathematica(cid:114)

documentation.

There is one important point that we would like to stress.

In practical applications,

the CPU time and accuracy in approximate eigenvalues are mainly9 controlled by three

parameters: Dimension, WorkingPrecision, and Scaling. These options make

LagMeshEigenvalues a versatile command when the user requires fast but highly accu-

rate calculations. Therefore, choosing appropriate values for those options is crucial for the

performance of the LMM. Explicit examples presented in the next Section will show which

considerations must be taken into account when choosing the value of such options.

4. LagMeshEigenfunctions

This command delivers as output a list that contains the lowest approximate eigenfunc-

tions of the Schr¨odinger equation (II.8) deﬁned in (a, b) for a given potential function V (x).

By default, they are presented normalized and in the form (IV.1).

If the corresponding

mesh used for calculations was not previously constructed, LagMeshEigenfunctions

will build it automatically calling BuildMesh internally. Therefore, the manual usage of
BuildMesh can be avoided by the user. After calculations, an ordered list10 with the ﬁrst

approximate eigenfunctions will be printed on screen. The syntax of the command is the

following:

9 The option Method will play an important role in applications, see text.
10 In ascending order, starting from the eigenfunction associated to the lowest eigenvalue.

21

Table III: Options for (i) LagMeshEigenvalues, (ii) LagMeshEigenfunctions, and
(iii) LagMeshEigensystem. Options marked by † are only available for commands (ii)
and (iii).

Option

Description

DiscreteFunction†

If it is set to True, the output will be a
list that contains a discrete version of the
wavefunctions according to (IV.2).

Default Value

False

ExpectationValue†

Function for which the expectation value is
calculated via the approximation (II.18).

None

Mass

It ﬁxes the value of the mass (m), see (II.9).
Its value must be a positive number.

1

CoefficientsOnly†

If it is set to True, the output will be the
coeﬃcients ck that solve the Lagrange equa-
tions (II.15).

False

PotentialShift

Scaling

WorkingPrecision

Shifts the potential V (x) by a real constant.
Final results for the spectrum do not de-
pend on the value of this option, see text.

Its value corresponds to the positive scaling
parameter h, deﬁned in (IV.3).

It speciﬁes how many digits of precision
should be maintained in internal computa-
tions. Thus, it controls the numeric accu-
racy of the approximate spectrum.

0

1

MachinePrecision

LagMeshEigenfunctions[V[x],

x,a,b

{

,NLevels,Dimension,Options]

}

The description of each element written above was already presented above when dis-

cussing the usage of LagMeshEigenvalues. Therefore, the reader is referred to that

Section for discussion. The available Options for this command are shown in Table III. In

addition, all available options of the built-in command Eigenvectors are incorporated

into LagMeshEigenfunctions.

As a general heuristic remark, once we have found appropriate values for the op-

tions WorkingPrecision, Dimension, and Scaling for LagMeshEigenvalues,

they are frequently suitable for the command LagMeshEigenfunctions. In this way,

22

the calculation of eigenvalues serves as guidance. As we will see, this argument goes

both ways: appropriate values for LagMeshEigenfunctions are also appropriate for

LagMeshEigenvalues.

5. LagMeshEigensystem

This command delivers simultaneously the desired number of eigenvalues and eigenfunc-

tions of the Schr¨odinger equation (II.8) deﬁned in (a, b) for a given potential function V (x).

The syntax is the same as for LagMeshEigenfunctions, namely

LagMeshEigensystem[V[x],

x,a,b

{

,NLevels,Dimension,Options]

}

In general terms, LagMeshEigensystem can be regarded as the combination of the pre-

vious two. Therefore, it contains all available options for LagMeshEigenvalues and

LagMeshEigenfunctions, see Table III. In addition, all available options of the built-in

command Eigensystem are incorporated into LagMeshEigensystem.

C. Worked Examples

In this Section, we present diﬀerent applications of the package for some well-known and

relevant systems. The following examples will illustrate and explore how the values of the

options can be crucial to obtain accurate eigenvalues and eigenfunctions. A comparison

with results from literature is made for some examples. Finally, we encourage the reader

to check the supplementary material (Examples.nb) to reproduce some of the following

calculations. Throughout the rest of this work, unless we specify otherwise, the mass is set

to m = 1.

23

1. Exactly Solvable Potentials

We present approximate eigenvalues and eigenfunctions obtained by the LagrangeMesh

package and compare them with the exact spectrum. We have chosen three potentials that

are representative of each possible domain: ﬁnite, semi-ﬁnite, and inﬁnite. The following

examples are helpful to become familiar with the commands and basic options of the package.

a. Particle in a Box. Let us begin with the simplest one-dimensional potential that

holds inﬁnitely many bound states: a particle conﬁned to a rigid box of length L. This

potential is described by

V (x) =






0,

0

x

≤ |
| ≤
, otherwise

∞

L

(V.1)

The exact solution of the Schr¨odinger equation leads to the following expression for the

eigenvalues

En =

π2n2
2L2 ,

n = 1, 2, ...,

(V.2)

On the other hand, using LagMeshEigenvalues let us calculate the ﬁrst 3 lowest eigen-

values using 50 mesh points. To do so, we take L = 1 without loss of generality. In this

case, the syntax looks like

When comparing with the exact spectrum (V.2), one will note that the error in approx-

imate eigenvalues is of order 10−15.

In this case, the error can be reduced (at least)

up to 10−90 by increasing the value of WorkingPrecision

200, but keeping the

→

number of mesh points ﬁxed to N = 50. For the present example, we conclude that

WorkingPrecision

of the LMM.

20 is insuﬃcient to avoid numerical errors and see the true scope

→

b. Harmonic Oscillator. This elementary system is described by the potential

V (x) =

1
2

x2 ,

< x <

.

∞

−∞

(V.3)

24

In[3]:=LagMeshEigenvalues[0,{x,0,1},3,50,WorkingPrecision→20]Out[3]:={4.934802200544679,19.73920880217872,44.41321980490211}The corresponding Schr¨odinger equation is exactly solvable, which means that the spectrum

can be found exactly. In particular, eigenvalues and (normalized) eigenfunctions are

En = n +

1
2

,

ψn(x) =

1
π1/4√2nn!

Hn(x)e−x2/2

n = 0, 1, 2, ... ,

(V.4)

where Hn(x) is the n-th Hermite polynomial. First, let us compute the ﬁrst three eigenvalues

using the input In[4].

We can immediately see the excellent agreement between the formula (V.4) and the

output of LagMeshEigenvalues: it is consistent with the requested accuracy. Although

we used WorkingPrecision

50, the output Out[4] gives energies with 47-48 exact

→

digits. Therefore, some numerical errors were accumulated during internal computations.

Once again, they can be reduced by increasing WorkingPrecision.

Now, we focus on calculating the approximate ﬁrst three eigenfunctions and the expec-

tation value of the potential (V.3). To do so, we have input In[5].

Output Out[5] of the program delivers a list with normalized eigenfunctions and the

expectation value of V (x). Note that we have dropped digits in order to simplify the

presentation. For the harmonic oscillator, the Lagrange Mesh Method leads to the exact

eigenvalues and eigenfunctions within the desired accuracy11. This is not a surprise, looking

at the (III.7), it is clear that the ﬁrst N

1 eigenfunctions of the harmonic oscillator can be

written as a linear combination of Lagrange functions

fi(x)

i=1. The expectation values12
N
}

{

of V (x) are accurate with the same accuracy obtained for the energy: 47-48 exact digits.

−

11 For further details, see [2].
12 The expectation value of the potential results in En/2 according to the Virial theorem, see [16].

25

In[4]:=LagMeshEigenvalues[12x2,{x,-∞,∞},3,50,WorkingPrecision→50]Out[4]:={0.50000000000000000000000000000000000000000000000,1.50000000000000000000000000000000000000000000000,2.5000000000000000000000000000000000000000000000}In[5]:=LagMeshEigenfunctions[12x2,{x,-∞,∞},3,50,WorkingPrecision→50,ExpectationValue→12x2]Out[5]:={{0.751125544464942482...Exp[-x2/2],0.250000000000000000...},{-1.062251932027196914...xExp[-x2/2],0.750000000000000000...},{(0.5311259660...-1.0622519320...x2)Exp[-x2/2],1.2500000000...}}c. Hydrogen Atom. As mentioned above, the (reduced) 3-dimensional radial Schr¨odinger

equation can be solved using a Laguerre mesh and the corresponding Lagrange functions

(III.3). Let us consider the Coulomb potential,

V (r) =

1
r

,

−

0

≤

r <

.

∞

(V.5)

In spherical coordinates, it is well known that eigenfunctions can be labeled by three quantum

numbers (n, (cid:96), m). However, the eigenvalues only depend on the principal quantum number

n, namely

En =

1
2n2 ,

−

n = 0, 1, 2, ... .

(V.6)

Using input In[6], we calculate the ﬁrst ten eigenvalues with angular momentum (cid:96) = 0. For

completeness, we have introduced the centrifugal potential despite the fact it vanishes.

There is one important remark in the code shown above. Only for unbounded from

below potentials deﬁned in [a, b], it is mandatory to use a non-zero value of the option

PotentialShift to obtain correct results. This value should be chosen in such a way

that the shifted potential

V (x) + PS ,

PS = OptionValue[PotentialShift]

(V.7)

has a positive spectrum. In the present case, any value of PS > 1/2 does the work. This is
merely a technical issue related to Mathematica(cid:114) and not with the LMM. Naturally, ﬁnal

results are independent of the value of PotentialShift.

Within the requested accuracy, we note in output In[6] an excellent agreement between

the exact energies of the ﬁrst three levels and those predicted by the LMM. Certainly, the

26

In[6]:=l=0;LagMeshEigenvalues[-1r+l(l+1)2r2,{r,0,∞},6,50,WorkingPrecision→50,PotentialShift→1]Out[6]:={-0.500000000000000000000000000000000000000000000,-0.125000000000000000000000000000000000000000000,-0.055555555555555555555555555555555555555555556,-0.0312499999999999999999999999999999949791258787,-0.0199999999999999999999940337493300623040218808,-0.0138888888888886863739094344591442446301784173}remaining eigenvalues are close to the exact ones, but numerical errors are evident. In this

case, increasing the value of WorkingPrecision is not the solution. However, there are

two ways to reduce the errors in this case: (i) increase the dimension of the mesh considering

N > 50; (ii) choose an appropriate value for Scaling. We will postpone the discussion of

these two approaches to the following Section.

2. Some Non-Solvable Potentials

In this Section, we consider some representative non-solvable potentials and show how

to tackle them with the LagrangeMesh package. In what follows, we explore the diﬀerent

options and show how some of them play a fundamental role to obtain highly accurate results

for either eigenvalues or eigenfunctions, despite the fact that exact solutions are unknown.

a. Quartic Anharmonic Oscillator. The ﬁrst example we consider is one of the most

studied systems in quantum mechanics: the celebrated quartic anharmonic potential13.

V (x) =

1
2

x2 +

1
4

x4 ,

< x <

.

∞

−∞

(V.8)

The discussion is focused on the lowest eigenvalue: the ground state energy denoted by E0.

In particular, we study the accuracy of the method as a function of the number of mesh points

N keeping ﬁxed WorkingPrecision

300. As we will see, when considering a suﬃciently

→

large value for WorkingPrecision, we can ensure that our results are not contaminated

by a loss of accuracy due to internal arithmetic manipulations. Then convergence of the

approximate E0 will occur as N

.
→ ∞

We take some representative dimensions from N = 25 to N = 2000. For the smallest

mesh N = 25, the block of code looks like

We have dropped a considerable number of decimal digits in the output Out[7] to sim-

13 The present discussion is based on [17].

27

In[7]:=LagMeshEigenvalues[12x2+14x4,{x,-∞,∞},1,25,WorkingPrecision→300]Out[7]:=0.620927028625317638613539173751...plify presentation. The modiﬁcation of the previous block to consider diﬀerent larger

meshes is trivial. For large a large number of mesh points, naturally calculations re-

quire more CPU time.

In fact, the most time-demanding calculation corresponds to the

mesh points.14 For example, calculating the largest Hermite mesh with N = 2000 and

WorkingPrecision

300 takes one whole day. Meanwhile, the realization of the LMM

→

only takes 40 minutes. More details about CPU times can be found in [17]. Results for all

considered meshes are shown in (V.10). There, we have used the following notation,

: X = Digit , N = Number of mesh points , Z = Decimal place of X .

(V.9)

X
NZ

Digit X indicates the maximal digit in energy which is reproduced with a given number of

mesh points N . For example, with N = 50 the ground state energy is obtained with 14

exact decimal digits. The maximal accuracy is reached with N = 2000 mesh points and

conﬁrmed with N = 2020.

E0 = 0.620 927 02
258

9 825 74
5014

8 660 85
7520

8 035 7

32 987 120

698 200 017 25

3 619 13

8 982 542 36

7 325

10025

15033

20044

25050

30059

062 962 748

188 768 883 979 391

351 303 479 456 083 601 618 760 073 476 624 891 085

40072

50087

768 308 099 065 938 402 5

80 084 530 397 024 737 474 347 663 406 954 493 075 566 093

1000145

052 396 859 302 472 486 392 601 975 136 357 293 108 871 529 439

117 092 275

1900237

2000246

(V.10)

In this case, the rate of convergence is about 10-11 correct digits with respect to an increment

of the number of mesh points in 100. Smaller meshes can reach the maximal accuracy if

an appropriate value of Scaling is used. Consequently, CPU times are reduced. We will

discuss this aspect based on another example, see below.

b. Quartic Double Well Potential. Now we consider the potential

V (x) =

1
2

x2(1

−

gx)2 ,

< x <

,

∞

−∞

(V.11)

14 Assuming that all meshes are already determined, the CPU time needed by the LMM scales as N 3.

28

which is a double well with two degenerate minima located at x = 0 and x = 1/g. When g is

small, it is well-known that there is an exponentially small separation between the energies

of the ground (E−) and ﬁrst excited (E−) states [13]. Let us deﬁne and denote this energy

gap as

By means of semi-classical analysis [11], we know the ﬁrst terms of the asymptotic expansion

∆E = E+

E− .

−

(V.12)

of ∆E, namely

∆ESC =

e− 1

6g2

(cid:18)

1

2
√πg

−

71
12

−

g2 +

O

(cid:19)

(g2)

+

O

(cid:16)

e− 1

3g2

(cid:17)

,

(V.13)

where the sub-index SC stands for semi-classical. Let us investigate if the LMM can capture

the exponentially small contribution in the energy gap for g = 1/30. Let us point out that

the degenerate minima are x = 0 and x = 30. Therefore, the mesh that we need to consider

must cover these two points. It turns out that N = 1000 is appropriate, as shown in the

following input where we print on screen the smaller and largest mesh points, see In[8] and

Out[8].

Now we calculate the ﬁrst two eigenvalues using the Hermite mesh, see In[9] below.

We have introduced the built-in option Method

"Arnoldi" to reduce CPU times:

→

from 1.2 hrs to 5 min. In addition, the last digits of the output were removed. From the

two ﬁrst eigenvalues, we can estimate the energy gap and compare with (V.13):

∆ELM M = 2.4129

10−64 ,

×

∆ESC = 2.4128

10−64 .

×

(V.14)

29

In[8]:=AvailableMeshQ["Hermite",Dimension→1000,WorkingPrecision→300,PrintMesh→True]Out[8]:={-44.2092,44.2092}In[9]:=g=130;LagMeshEigenvalues[12x2(1-gx)2,{x,-∞,∞},2,1000,WorkingPrecision→300,Method→"Arnoldi"]Out[9]:={0.498883271316609786728219605658571743939794419539193419407486112020...,0.498883271316609786728219605658571743939794419539193419407486112262...}We can see that there is an excellent agreement between both estimates15. Let us now

investigate how the wavefunctions look like with respect to x. Since the dimension of the

basis is quite large (N = 1000), it is convenient to use the discrete version of the wavefunction

to avoid loss of accuracy. To do so, we use input In[10] shown below.

In the previous block of code, we have stored the discretized wavefunctions in a list called

LDW. Then, the plots of the ﬁrst two wavefunctions can be easily obtained using the built-in

command ListPlot,

The output of the previous block In[11] corresponds to the plot of the ground state

eigenfunction shown in Fig. 2. With minimal modiﬁcations, the same block can be used to

plot the ﬁrst excited wavefunction, see Fig. 3.

There is one point that should be emphasized about the Hermite mesh used in this

example. By construction, it always will be symmetrical with respect to the vertical axis

(x = 0). As a consequence, the discrete version of the wavefunction will be deﬁned for

mesh points inside

xN

−

x

≤

≤

xN . However, it can be seen from Figs. 2 and 3 that the

wavefunction do not share the same symmetry of the domain. Furthermore, wavefunctions

are negligibly for x <

10. To improve the performance of the LMM, it is natural to

shift/translate the potential V (x)

V (x + 1/2g) to make it symmetrical under x

x.

→ −

Naturally, ﬁnal results for the spectrum do not depend on the shift. For instance, N = 500

−

→

can provide the same accuracy for the energy gap in comparison with previous calculations

with N = 1000. In this case, CPU time was reduced from 20 min to 50 s.

c. Shell-Conﬁned Hydrogen Atom. This system is described by the Schr¨odinger equa-

tion (II.8) with the usual Coulomb potential V (r) =

1/r. The diﬀerence comes from the

−

15 SC-estimate was calculated neglecting terms of

(g2) and

O

O

(e−1/3g2

) in (V.13)

30

In[10]:=g=130;LDW=LagMeshEigenfunctions[12x2(1-gx)2,{x,-∞,∞},2,1000,WorkingPrecision→300,Method→"Arnoldi",DiscreteFunction→True];In[11]:=ListPlot[LDW[[1]],PlotRange→All,Joined→True]Figure 2: Approximate wavefunction of the ground state in the double-well potential
(V.11). Plot generated by In[10] and In[11].

Figure 3: Approximate wavefunction of the ﬁrst excited state in the double-well potential
(V.11). Plot generated via In[10] and minimal modiﬁcations of In[11].

boundary conditions which guarantee the shell-type conﬁguration:

ψ(r1) = ψ(r2) = 0 ,

r1 < r2 .

0

≤

(V.15)

Let us take as an example the particular core-shell conﬁguration

r1 = 10 ,

r2 = 100 ,

(V.16)

31

-40-202040-0.5-0.4-0.3-0.2-0.1-40-202040-0.4-0.20.20.4and calculate the ﬁrst three energies for angular momentum (cid:96) = 2. To do so, we use In[12].

In this way, we conﬁrmed the results provided in Ref.

[18]. However, further calculations

can easily overcome those benchmarks by increasing the number of mesh points and using

higher WorkingPrecision. We note that the ﬁrst eigenvalue in the list is very similar to

the energy of the familiar states16 of the free hydrogen atom with principal quantum number

n = 4, which is E4 =

1/32. This is not a coincidence, the usual wavefunction for the state

−

4d has a node at r1 = 12 and another one at r2 =

. In this example r2 = 100 is suﬃcient

to mimic ”

”. This phenomenon will be explained below.

∞

∞

PT

d.

-symmetric cubic oscillator For some systems deﬁned on a semi-ﬁnite or inﬁnite

interval, it is enough to conﬁne them in a suﬃciently large box. We explore such situation

based on a particular example. Let us take,

V (x) = i x3 ,

−∞

< x <

.

∞

(V.17)

This potential is invariant under the simultaneous transformations17 x

x and i

i as

→ −

→ −

well as the kinetic term in the Hamiltonian. It is well-known that the spectrum associated

with this potential is positive and discrete [19]. Using the package, we can easily obtain the

ﬁrst eigenvalues with unprecedented accuracy. For this purpose, we use the following block

of code.

Eigenvalues in In[13]. are essentially real, with a small imaginary part. In particular,

16 Associated with the potential (V.5).
17
arity and

-symmetry stands for

PT

P

ime reversal.

T

32

In[12]:=l=2;LagMeshEigenvalues[-1r+l(l+1)2r2,{r,12,100},3,100,WorkingPrecision→30,PotentialShift→1]Out[12]:={-0.0312499999998759365128795,-0.0191184570787652150378327,-0.0131200561664748472136198}In[13]:=LagMeshEigenvalues[Ix3,{x,-∞,∞},5,200,WorkingPrecision→100]Out[13]:={0.76285177422726354...+1.82697736694870898...×10-113I,2.71107992325388461...+8.06725746334795611...×10-106I,4.98924008753779726...+7.36353994216817421...×10-103I,7.46473454878490666...+1.50123757767888490...×10-73I,10.0886630708259331...+1.69712257011508907...×10-47I}the ﬁrst three are consistent with the requested accuracy of 100 exact digits in arithmetic.

Since the potential (V.17) is deﬁned in the whole real line, it was natural to specify the

domain

x,-

,

{

∞

∞}

inside LagMeshEigenvalues. However, with a suﬃciently large

ﬁnite domain18, it is possible to reproduce exactly those results as shown below.

The real part of numerical eigenvalues in Out[14] is conﬁrmed, meanwhile the imaginary

part is diﬀerent but still small. Previous results obtained by the LMM overcome benchmarks

found in literature, see [19].

e. Quasi-Exactly Solvable Double Well. From [20], we extract the one-dimensional po-

tential19:

V (x) = x6 + 2x4

18x2

1 ,

−

−

< x <

.

∞

∞

(V.18)

Degenerate minima are located approximately at x =

1.368. For this potential, only the

ﬁve lowest eigenfunctions20 of even parity can be found in exact form. They can be written

±

as

ψn(x) = Pn(x2)e− 1

2 x2− 1

4 x4 ,

n = 0, 1, ..., 4 ,

(V.19)

where Pn(x) is a real polynomial of degree n. Correspondingly, eigenvalues and eigenfunc-

tions can be computed via simple algebra. In particular, eigenvalues read

E0 =

−

14.044 499 331 ,

E1 = 3.247 407 444 ,

E2 = 4.623 648 530 ,

E3 = 17.853 104 881 ,

E4 = 34.815 153 363 .

(V.20)

In this example, we now study the eﬀect of Scaling on the accuracy of the method keeping

the number of mesh points ﬁxed (N = 30). First, Let us calculate the ﬁrst nine eigenvalues

using LagMeshEigenvalues, and then extract those which correspond to even parity.

18 A similar phenomenon occurred in the previous Section for the shell-conﬁned hydrogen atom.
19 In [20], equation (2.1), a = b = 1, k = 0, and n = 4.
20 In the Hamiltonian operator (II.9) the mass must be taken as m = 1/2.

33

In[14]:=LagMeshEigenvalues[Ix3,{x,-10,10},5,200,WorkingPrecision→100]Out[14]:={0.76285177422726354...+6.60062084477509384...×10-108I,2.71107992325388461...+1.53860672832849900...×10-100I,4.98924008753779726...+1.28045707882104121...×10-96I,7.46473454878490666...+2.47157825497472030...×10-75I,10.0886630708259331...+1.40906101716468556...×10-47I}The input In[15], shown below, works for this purpose.

Since we are interested in even parity states, we have replaced the energies of odd states

with dots in the output Out[15]. Compared with (V.20), we note that numerical results

are not very accurate, especially for excited states. The performance of the method can be

improved if we choose an adequate scaling parameter. For this purpose, it is suﬃcient to

calculate and plot the discrete version of the ground state wavefunction. For this purpose

we use In[16]. The corresponding output is the plot is presented in Fig. 4. From this plot,

we note that the wavefunction is small (

10−4) for

∼

scale the mesh to move all mesh points to the region

x
|

| ≥
x
|

| ≤

3.5. Therefore, it is convenient to

3.5, where the function is not too

small. This can be done by means of Scaling. For this particular case, Scaling

1/2

→

seems to be suitable. Recalculating the spectrum with this scaling, we obtain more accurate

approximate energies, especially for excited states. This can be check in the block of code

for In[17].

f. Rydberg Atoms. As ﬁnal example, we show how LagMeshEigensystem works.

Let us consider the following radial potential

where

where

{

V (r) =

Z(cid:96)(r)
r

−

−

(cid:104)
1

ac
2r4

−

e−(r/rc)6(cid:105)

+

(cid:96)((cid:96) + 1)
2r2

Z(cid:96)(r) = 1 + (Z

1)e−a1r

−

−

r(a3 + a4r)e−a2r

(V.21)

(V.22)

a1, a2, a3, a4, rc, ac

are parameters with dependence on the value of (cid:96) (angular mo-

}

mentum) and the atomic number Z. Potential (V.21), written in a.u, is useful to study the

so-called Rydberg atoms. It describes a highly excited electron of valence through a radial

potential [21] . The spin-orbit interaction has been dropped for simplicity. For concreteness,

34

In[15]:=LagMeshEigenvalues[x6+2x4-18x2-1,{x,-∞,∞},9,30,WorkingPrecision→20,Mass→1/2]Out[15]:={-14.08077227171645238,...,-3.2475575741665341,...,4.8786311954474445,...,18.5854712028856120,...,29.1878679181253049}In[16]:=LGS=LagMeshEigenfunctions[x6+2x4-18x2-1,{x,-∞,∞},1,30,Mass→1/2,WorkingPrecision→20,DiscreteFunction→True];ListPlot[LGS,Joined→True,Mesh→All]Figure 4: Approximate discrete ground state wavefunction of the quasi-exactly solvable
7 < x < 7 .
potential (V.18). For N = 30, mesh points are distributed in the domain

Plot generated via In[16].

−

we focus on the p-states associated to the valence electron of the Rubidium (Rb) atom, thus,

we take Z = 37 and (cid:96) = 1. The values of the parameters in a.u. that characterize (V.21)

and (V.22) are the following21

ac = 9.0760 ,

rc = 1.501 951 24 ,

a1 = 4.440 889 78 ,

a2 = 1.928 288 31,

a3 =

16.795 977 70 ,

−

a4 =

−

0.816 333 14 .

(V.23)

To calculate eigenvalues and eigenfunctions simultaneously, we use the block of code shown

below, see In[18].

A Laguerre mesh with N = 20 is more than suﬃcient to obtain the ﬁrst two eigenvalues

and eigenfunctions with accuracy consistent with the number of digits in the parameters

(V.23). In the previous calculation, Scaling is crucial to obtain a good performance of

the command LagMeshEigensystem as we now explain. First, note that the potential

21 See reference [21].

35

-6-4-2246-0.8-0.6-0.4-0.2In[17]:=LagMeshEigenvalues[x6+2x4-18x2-1,{x,-∞,∞},9,30,WorkingPrecision→20,Mass→1/2,Scaling→1/2]Out[17]:={-14.04449918094238512,...,-3.2474090114716549,...,4.6236364005060602,...,17.8529954304045896,...,34.8150945730654724}(V.21) develops a deep well (depth

216 a.u.) of small width

0.5 a.u. Therefore, the

∼ −

∼

wave function is localized in a very small spatial region. Via Scaling we can move all

mesh points to such region. This increases the accuracy in results and reduces CPU times

from minutes to a couple of seconds.

Before concluding, there is a technical issue that should be mentioned concerning potential

(V.21). Since exponential functions are involved, the evaluation of potential matrix elements

(II.16) can lead to extremely small numbers. This might lead to a loss of accuracy in

calculations and to an increment in CPU times. This situation has to be avoided as much as

possible. For the particular previous case, Scaling

1/30 solves the situation. Usually,

→

if the energy calculated by using a given mesh is accurate, the corresponding eigenfunctions

will be as well. The reader is referred to the supplementary material to check this statement

for the two lowest states of the Rydberg atom considered above.

3. Possible Issues

We give a brief review of common situations that the user may face.

a. Loss of Accuracy.

In order to use arbitrary precision arithmetic oﬀered by Mathematica(cid:114),

speciﬁed basically by the option WorkingPrecision, it is mandatory to deﬁne all input

parameters (V[x], Dimension, Mass, Scaling, etc.) with the same accuracy chosen for

36

In[18]:=l=1;z=37;tol=10-20;ac=Rationalize[9.0760,tol];rc=Rationalize[1.50195124,tol];a1=Rationalize[4.44088978,tol];a2=Rationalize[1.92828831,tol];a3=Rationalize[-16.79597770,tol];a4=Rationalize[-0.8163314,tol];Zl[r]:=1+(z-1)Exp[-a1r]-r(a3+a4r)Exp[-a2r];V[r]:=-Zl[r]r-ac2r4(1-Exp[-(r/rc)6])+l(l+1)2r2;LagMeshEigensystem[V[r],{r,0,∞},2,20,WorkingPrecision→20,Scaling→1/30]Out[18]:={{-64.333486...,2×51/2Exp[-10r](-3.960999...×10-6r+...)},{-6.307591...,2×51/2Exp[-10r](-7.242503...×10-7r+...)}}WorkingPrecision. In general, deﬁning all of them with absolute accuracy is more than

enough. For example, instead of taking 1.5, use 3/2. Otherwise, accuracy in arithmetic

will drop to MachinePrecision. Avoiding extremely small/large numbers can help the

performance as well. For example, considering Mass

9.1093837015

10-31 (kg), which

→

×

is the mass of the electron, will lead to a poor performance of the method. Therefore, it is

advisable to use the natural scales of the system.

Another situation that leads to a limited accuracy in the spectrum occurs when the

wavefunctions are very extended in the domain. This is typical for weakly bound states

deﬁned on semi-inﬁnite22 or inﬁnite domains.

b. CPU times and RAM. Computation time may become signiﬁcant in diﬀerent situ-

ations. Usually, either large values of Dimension or WorkingPrecision require more

CPU time. In particular, constructing accurate and large meshes via BuildMesh can take

days of calculations. Choosing an appropriate value of Scaling, instead of increasing

the size of the mesh, can lead not only to an improvement of results, but also to a re-

duction of CPU times. When few eigenvalues or eigenfunctions are of interest, the option

Method

"Arnoldi" usually reduces CPU times drastically. Let us point out that an

→

increase in WorkingPrecision will certainly increase the arithmetic accuracy. However,

the RAM needed to manipulate and store those numbers during calculations will become

larger. It is highly recommendable to keep track of RAM consume from the terminal.

c. Limitations. Any approximate method to solve the Schr¨odinger-type equations has

its own domain of applicability. The LMM is not the exception. One limitation comes

from the Gauss quadrature approximation. When the potential is not smooth, the Gauss
quadrature fails and, as a result, matrix elements V (G)

i,j may be inaccurate. Certainly, this will
lead to a poor accuracy in the spectrum. A simple representative example of this situation

occurs for the one-dimensional potential

V (x) =

,

x
|

|

< x <

,

∞

−∞

(V.24)

which is not smooth at x = 0. Using LagMeshEigenvalues, even with a large number

of mesh points, eigenvalues are inaccurate, see In[19] and Out[19].

22 The usage of the LMM in this situation has already been investigated in [22].

37

If we compare it with the exact lowest eigenvalue E0 = 0.808 616 ..., we can immediately

note the poor performance of the LagrangeMesh package.

VI. CONCLUSIONS

Through the years, many eﬀorts have been put into developing numerical methods to solve

the time-independent one-dimensional Schr¨odinger equation. In this work, we focused on one

of these methods to study bound states: the Lagrange Mesh method (LMM). Speciﬁcally, the

LMM is an approximate variational method simpliﬁed by a Gauss quadrature associated with

a given mesh. The method is based on three ingredients: Gauss quadrature approximation,

Lagrange functions, and secular equations. The non-existent ideal numerical method would

be characterized by (i) short CPU times; (ii) high accuracy; (iii) applicable to any potential.

Under some conditions, the LMM fulﬁlls these three characteristics.

After presenting a comprehensive and detailed discussion of the LMM, we introduced the
LagrangeMesh Mathematica(cid:114) package. It provides the user three commands that imple-

ment the LMM numerically: LagMeshEigenvalues, LagMeshEigenfunctions, and

LagMeshEigensystem. The output of each one is the following: eigenvalues, eigenfunc-

tions, and eigenvalues and eigenfunctions, respectively. All of them are delivered on screen in

such a way that they are ready-to-use. Therefore, we have a powerful tool to ﬁnd the quan-

tum spectrum of an arbitrary potential deﬁned on a given interval (which can be ﬁnite, semi-

ﬁnite, or inﬁnite). Two complementary commands, BuildMesh and AvailableMeshQ,

are available to the user to construct and check meshes and weights. All ﬁve commands are

user-friendly and none of them requires more than a couple of lines to specify the input.

The main properties of the commands oﬀered by the package are (i) eﬃciency; (ii) control of

the accuracy in arithmetic manipulations and ﬁnal results. These properties are controlled

by three options Dimension, Scaling, and WorkingPrecision.

Based on diﬀerent relevant physical systems (worked examples), we discussed in detail

38

In[19]:=LagMeshEigenvalues[Abs[x],{x,-∞,∞},1,1000,WorkingPrecision→300]Out[19]:=0.808632...the usage, scope, and limitations of the package. In particular, for some of those systems, we

showed explicitly how benchmarks in eigenvalues are established in few lines of code in short

CPU times. For example, we established the most accurate results for the ﬁrst energies of

the

-symmetric cubic potential. The collection of worked examples presented in the text

PT

can be regarded as a user guide of the package.

Finally, the LagrangeMesh package may serve as a tool for educational and research

purposes. In particular, it can be used to test other highly accurate methods of diﬀerent

nature.

ACKNOWLEDGMENTS

I am very grateful to H. Olivares-Pil´on for the outstanding and comprehensive lectures

about the LMM. I thank A.V. Turbiner for the constant encouragement in developing the

package, many useful discussions, comments, and suggestions. I thank S. C´ardenas-L´opez

for useful remarks and tests of the package. Finally, I would like to thank K. Kropielnicka

for valuable suggestions and careful reading of the text. This work is partially supported

by the Simons Foundation Award No. 663281 granted to the Institute of Mathematics of

the Polish Academy of Sciences for the years 2021-2023. Additional ﬁnancial support was

provided by the SONATA BIS-10 grant no. 2019/34/E/ST1/00390.

[1] E. Schr¨odinger, Ann. Phys. 385, 437 (1926).

[2] D. Baye, Phys. Rep. 565, 1 (2015).

[3] M. Hesse and D. Baye, J. Phys. B 32, 5605 (1999).

[4] M. Hesse and D. Baye, J. Phys. B 37, 3937 (2004).

[5] H. Olivares Pil´on and D. Baye, Phys. Rev. A 88, 032502 (2013).

[6] Z. Wang, Y. Ge, Y. Dai, and D. Zhao, Comput. Phys. Commun. 160, 23 (2004).

[7] T. Sulejmanpasic and M. ¨Unsal, Comput. Phys. Commun. 228, 273 (2018).

[8] G. D. Xavier, Comput. Phys. Commun. 278, 108419 (2022).

[9] R. M. Fonseca, Comput. Phys. Commun. 267, 108085 (2021).

39

[10] P. H. Jacobse, Computer Physics Communications 244, 392 (2019).

[11] J. Zinn-Justin and U. D. Jentschura, Ann. Phys. 313, 197 (2004).

[12] K. E. Atkinson, An introduction to numerical analysis (John wiley & sons, 2008).

[13] L. D. Landau and L. M. Lifshitz, Quantum Mechanics Non-Relativistic Theory, Third Edition:

Volume 3, 3rd ed. (Butterworth-Heinem, 1981).

[14] J. D. Casta˜no-Yepes, O. Franca, C. Ramirez-Gutierrez, and J. C. del Valle, Phys. E: Low-

Dimens. Syst. Nanostructures 123, 114202 (2020).

[15] Wolfram Support Quick Answers, “https://support.wolfram.com/5648?src=mathematica,”.

[16] J. J. Sakurai, Modern quantum mechanics; rev. ed. (Addison-Wesley, Reading, MA, 1994).

[17] A. V. Turbiner and J. C. del Valle, Int. J. Quantum Chem. 121, e26766 (2021).

[18] K. D. Sen, J. Chem. Phys. 122, 194324 (2005).

[19] C. M. Bender and S. Boettcher, Phys. Rev. Lett. 80, 5243 (1998).

[20] A. V. Turbiner, Phys. Rep. 642, 1 (2016).

[21] M. Marinescu, H. R. Sadeghpour, and A. Dalgarno, Phys. Rev. A 49, 982 (1994).

[22] J. C. del Valle and D. J. Nader, J. Math. Phys. 59, 102103 (2018).

40

