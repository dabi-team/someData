Session Fidelity for ElixirST:
A Session-Based Type System for Elixir Modules

Gerard Tabone

Adrian Francalanza

Computer Science Department
University of Malta
Msida, Malta

gerard.tabone.17@um.edu.mt

adrian.francalanza@um.edu.mt

This paper builds on prior work investigating the adaptation of session types to provide behavioural
information about Elixir modules. A type system called ElixirST has been constructed to statically
determine whether functions in an Elixir module observe their endpoint speciﬁcations, expressed as
session types; a corresponding tool automating this typechecking has also been constructed. In this
paper we formally validate this type system. An LTS-based operational semantics for the language
fragment supported by the type system is developed, modelling its runtime behaviour when invoked
by the module client. This operational semantics is then used to prove session ﬁdelity for ElixirST.

1 Introduction

In order to better utilise recent advances in microprocessor design and architecture distribution, modern
programming languages offer a variety of abstractions for the construction of concurrent programs. In the
case of message-passing programs, concurrency manifests itself as spawned computation that exhibits
communication as a side-effect, potentially inﬂuencing the execution of other (concurrent) computation.
Such side-effects inevitably increase the complexity of the programs produced and lead to new sources
of errors. As a consequence, program correctness becomes harder to verify and language support for
detecting errors at the development stage can substantially decrease the number of concurrency errors.

Elixir [34], based on the actor model [1, 14], is one such example of a modern programming language
for concurrency. As depicted in Figure 1, Elixir programs are structured as a collection of modules that
contain functions, the basic unit of code decomposition in the language. A module only exposes a subset
of these functions to external invocations by deﬁning them as public; these functions act as the only entry
points to the functionality encapsulated by a module. Internally, the bodies of these public functions may
then invoke other functions, which can either be the public ones already exposed or the private functions
that can only be invoked from within the same module. For instance, Figure 1 depicts a module m which
contains several public functions (i.e., f1, . . . , fn) and private functions (i.e., g1, . . . , g j). For example, the
public function f1 delegates part of its computation by calling the private functions g1 and g j, whereas
the body of the public function fn invokes the other public function f1 when executed. Internally, the
body of the private function g1 calls the other private function g2 whereas the private function g j can
recursively call itself.

A prevalent Elixir design pattern is that of a server listening for client requests. For each request, the
server spawns a (public) function to execute independently and act as a dedicated client handler: after the
respective process IDs of the client and the spawned handler are made known to each other, a session of
interaction commences between the two concurrent entities (via message-passing). For instance, in Fig-
ure 1, a handler process running public function f1 is assigned to the session with client client1 whereas

C. Aubert, C. Di Giusto, L. Saﬁna & A. Scalas (Eds.):
15th Interaction and Concurrency Experience (ICE 2022)
EPTCS 365, 2022, pp. 17–36, doi:10.4204/EPTCS.365.2

© G. Tabone & A. Francalanza
This work is licensed under the
Creative Commons Attribution License.

18

Session Fidelity for ElixirST

Module m

g1

g2

...

g j

f1

...

fn

S1

Sn

S1

client1

...

Sn

clientk

private

public

Figure 1: An Elixir module consisting of public and private functions, interacting with client processes

the request from clientk is assigned a dedicated handler running function fn. Although traditional inter-
face elements such as function parameters (used to instantiate the executing function body with values
such as the client process ID) and the function return value (reporting the eventual outcome of handled
request) are important, the messages exchanged between the two concurrent parties within a session are
equally important for software correctness. More speciﬁcally, communication incompatibilities between
the interacting parties could lead to various runtime errors. For example, if in a session a message is
sent with an unexpected payload, it could cause the receiver’s subsequent computation depending on it
to crash (e.g. multiplying by a string when a number should have been received instead). Also, if mes-
sages are exchanged in an incorrect order, they may cause deadlocks (e.g. two processes waiting forever
for one another to send messages of a particular kind when a message of a different kind has been sent
instead).

In many cases, the expected protocol of interactions within a session can be statically determined
from the respective endpoint implementations, namely the function bodies; for simplicity, our discussion
assumes that endpoint interaction protocols are dual, e.g. S1 and S1 in Figure 1. Although Elixir provides
mechanisms for specifying (and checking) the parameters and return values of a function within a mod-
ule, it does not provide any support for describing (and verifying) the interaction protocol of a function in
terms of its communication side-effects. To this end, in earlier work [32] we devised the tool1 ElixirST,
assisting module construction in two ways: (a) it allows module designers to formalise the session end-
point protocol as a session type, and ascribe it to a public function; (b) it implements a type-checker that
veriﬁes whether the body of a function respects the ascribed session type protocol speciﬁcation.

Contribution. This paper validates the underlying type system on which the ElixirST type-checker is
built. More concretely, in Section 3 we formalise the runtime semantics of the Elixir language fragment
supported by ElixirST as a labelled transition system (LTS), modelling the execution of a spawned han-
dler interacting with a client within a session. This operational semantics then allows us to prove session
ﬁdelity for the ElixirST type system in Section 4. In Section 2 we provide the necessary background on
the existing session type system from [32] to make the paper self-contained.

1ElixirST is available on GitHub: https://github.com/gertab/ElixirST

G. Tabone & A. Francalanza

2 Preliminaries

19

We introduce a core Elixir subset and review the main typing rules for the ElixirST type system [32].

2.1 The Actor Model

Elixir uses the actor concurrency model [1, 14].
It describes computation as a group of concurrent
processes, called actors, which do not share any memory and interact exclusively via asynchronous
messages. Every actor is identiﬁed via a unique process identiﬁer (pid) which is used as the address
when sending messages to a speciﬁc actor. Messages are communicated asynchronously, and stored in
the mailbox of the addressee actor. An actor is the only entity that can fetch messages from its mailbox,
using mechanisms such as pattern matching. Apart from sending and reading messages, an actor can
also spawn other actors and obtain their fresh pid as a result; this pid can be communicated as a value to
other actors via messaging.

2.2 Session Types

The ElixirST type system [32] assumes the standard expression types, including basic types, such as
boolean, number, atom and pid, and inductively deﬁned types, such as tuples ({T1, . . . , Tn}) and lists
([ T ] ); these already exist in the Elixir language and they are dynamically checked. It extends these with
(binary) session types, which are used to statically check the message-passing interactions.

Expression types

T ::= boolean | number | atom | pid | {T1, . . . , Tn} | [ T ]

Session types

(cid:1).Si
S ::= &(cid:8)?li
(cid:0)
(cid:9)
(cid:101)Ti
(cid:1).Si
(cid:0)
| ⊕ (cid:8)!li
(cid:101)Ti
| end

i∈I
(cid:9)

i∈I

Branch

Choice

Termination

| rec X . S

Recursion

| X

Variable

(cid:0)
(cid:101)Ti

(cid:1).Si

(cid:9)
The branching construct, &(cid:8)?li
i∈I, requires the code to be able to receive a message that is
labelled by any one of the labels li, with the respective list of values of type (cid:101)Ti (where (cid:101)T stands for
T 1, . . . , T k for some k ≥ 0), and then adhere to the continuation session type Si. The choice construct
is its dual and describes the range and format of outputs the code is allowed to perform. In both cases,
the labels need to be pairwise distinct. Recursive types are treated equi-recursively [27], and used inter-
changeably with their unfolded counterparts. For brevity, the symbols & and ⊕ are occasionally omitted
for singleton options, e.g., ⊕(cid:8)!l(number).S1
(cid:9) is written as !l(number).S1; similarly end may be omit-
ted as well, e.g., ?l() stands for ?l().end. The dual of a session type S is denoted as S.

2.3 Elixir Syntax

Elixir programs are organised as modules, i.e., defmodule m do (cid:101)P (cid:101)D end. Modules are deﬁned by
their name, m, and contain two sets of public (cid:101)D and private (cid:101)P functions, declared as sequences. Public
functions, def f (y, (cid:101)x) do t end, are deﬁned by the def keyword, and can be called from any module. In
contrast, private functions, defp f (y, (cid:101)x) do t end, can only be called from within the deﬁning module.
Functions are deﬁned by their name, f , and their body, t, and parametrised by a sequence of distinct
variables, y, (cid:101)x, the length of which, |y, (cid:101)x|, is called the arity. As an extension to [32], the ﬁrst parameter

20

Session Fidelity for ElixirST

Module M ::= defmodule m do (cid:101)P (cid:101)D end
Public fun. D ::= K B def f (y, (cid:101)x) do t end
Private fun. P ::= B defp f (y, (cid:101)x) do t end
Type ann. B ::= @spec f (cid:0)

(cid:101)T (cid:1) :: T
Session ann. K ::= @session “X = S”

| @dual “X”

Basic val.

b ::= boolean | number | atom | pid

| [ ]

Values

v ::= b | [ v1 | v2 ] | {v1, . . . , vn}

Identiﬁers w ::= b | x

Patterns

Terms

p ::= w | [ w1 | w2 ] | {w1, . . . , wn}
t ::= e

Expressions

e ::= w

Operators

| not e | e1 (cid:5) e2
| [ e1 | e2 ] | {e1, . . . , en}
(cid:5) ::= < | > | <= | >= | ==

| ! = | + | − | ∗ | / | and | or

Figure 2: Elixir syntax

| x = t1; t2
| send (w, {:l, e1, . . . , en})
| receive do
(cid:0)(cid:8):li, p1

i , . . . , pn
i
| f (w, e1, . . . , en)
| case e do (pi → ti)i∈Iend

(cid:9) → ti

(cid:1)
i∈Iend

(y), is reserved for the pid of the dual process. Although a module may contain functions with the same
name, their arity must be different.

In our formalisation, Elixir function parameters and return values are assigned a type using the @spec
annotation, f ( (cid:101)T ) :: T , describing the parameter types, (cid:101)T , and the return type, T . This annotation is
already used by Dialyzer for success typing [21]. In addition to this, we decorate public functions with
session types, deﬁned in Section 2.2, to describe their side-effect protocol. Public functions can be
annotated directly using @session “X = S”, or indirectly using the dual session type, @dual “X”, where
X = S is shorthand for rec X . S.

The body of a function consists of a term, t, which can take the form of an expression, a let state-
ment, a send or receive construct, a case statement or a function call; see Figure 2. In the case of the let
construct, x = t1; t2, the variable x is a binder for the variables in t2 acting as a placeholder for the value
that the subterm t1 evaluates to. We write t1;t2, as syntactic sugar for x = t1; t2 whenever x is not used in
t2. The send statement, send (x, {:l, e1, . . . , en}), allows a process to send a message to the pid stored
in the variable x, containing a message {:l, e1, . . . , en}, where :l is the label. The receive construct,
receive do (cid:0)(cid:8):li, p1
(cid:1)
i∈Iend, allows a process to receive a message tagged with a label
that matches one of the labels :li and a list of payloads that match the patterns p1
i , branching to
continue executing as ti. Patterns, p, deﬁned in Figure 2, can take the form of a variable, a basic value,
a tuple or a list (e.g. [ x | y ], where x is the head and y is the tail of the list). The remaining constructs
are fairly standard. Variables in patterns p1
i employed by the receive and case statements are
binders for the respective continuation branches ti. We assume standard notions of open (i.e., fv(t) (cid:54)= /0)
and closed (i.e., fv(t) = /0) terms and work up to alpha-conversion of bound variables.

i , . . . , pn
i

i , . . . , pn

i , . . . , pn

(cid:9) → ti

G. Tabone & A. Francalanza

2.4 Type System

21

The session type system from [32] statically veriﬁes that public functions within a module observe the
communication protocols ascribed to them. It uses three environments:

Variable binding env.

Session typing env.

Γ ::= /0 | Γ , x : T
∆ ::= /0 | ∆ , f/n : S
(cid:40)

Function inf. env.

Σ ::= /0 | Σ , f/n :

params = (cid:101)x, param_types = (cid:101)T ,
body = t, return_type = T, dual = y

(cid:41)

The variable binding environment, Γ , maps (data) variables to basic types (x : T ). We write Γ , x : T
to extend Γ with the new mapping x : T , where x /∈ dom(Γ ). The session typing environment, ∆ , maps
function names and arity pairs to their session type ( f/n : S). If a function f/n has a known session type,
then it can be found in ∆ , i.e., ∆ ( f/n) = S. Each module has a static function information environment,
Σ , that holds information related to the function deﬁnitions. For a function f , with arity n, Σ ( f/n) returns
the tail list of parameters (params) and their types (param_types), the function’s body (body), and its
return type (return_type). In contrast to the original type system from [32], Σ ( f/n) also returns the
variable name that represents the interacting process’ pid, i.e., the option dual. We assume that func-
tion information environments, Σ , are well-formed, meaning that all functions mapped ( f/n ∈ dom(Σ ))
observe the following condition requiring that the body of function f/n is closed:

fv(cid:0)Σ ( f/n).body(cid:1) \ (cid:0)Σ ( f/n).params ∪ Σ ( f/n).dual(cid:1) = /0

Session typechecking is initiated by analysing an Elixir module, rule [TMODULE]. A module is type-
checked by inspecting each of its public functions, ascertaining that they correspond and fully consume
the session types ascribed to them. The rule uses three helper functions. The function functions( (cid:101)D)
returns a list of all function names (and arity) of the public functions ( (cid:101)D) to be checked individually. The
function sessions( (cid:101)D) obtains a mapping of all the public functions to their expected session types stored
in ∆ . This ensures that when a function f with arity n executes, it adheres to the session type associated
with it using either the @session or @dual annotations. The helper function details populates the func-
tion information environment (Σ ) with details about all the public ( (cid:101)D) and private functions ( (cid:101)P) within
the module.

∀ f/n ∈ functions( (cid:101)D) ·



∆ = sessions( (cid:101)D)
∆ ( f/n) = S

Ω .params = (cid:101)x
Ω .body = t

∆ · (cid:0)y : pid, (cid:101)x : (cid:101)T (cid:1) (cid:96)y

Σ = details( (cid:101)P (cid:101)D)
Σ ( f/n) = Ω

Ω .param_types = (cid:101)T

Ω .return_type = T
Σ S (cid:66) t : T (cid:67) end

(cid:96) defmodule m do (cid:101)P (cid:101)D end

Ω .dual = y

[TMODULE]

For every public function f/n in functions( (cid:101)D), [TMODULE] checks that its body adheres to it session

type using the highlighted term typing judgement detailed below:

22

Session Fidelity for ElixirST

dual pid

initial

&

residual

session types

w
∆ · Γ (cid:96)
Σ

S (cid:66) t : T (cid:67) S(cid:48)

session typing

&

variable binding

environments

term

expression type

This judgement states that “the term t can produce a value of type T after following an interaction pro-
tocol starting from the initial session type S up to the residual session type S(cid:48), while interacting with a
dual process with pid identiﬁer w. This typing is valid under some session typing environment ∆ , vari-
able binding environment Γ and function information environment Σ .” Since the function information
environment Σ is static for the whole module (and by extension, for all sub-terms), it is left implicit in
the term typing rules. We consider four main rules, and relegate the rest to Appendix B.1.
pat p j
(cid:96)w
(cid:9)
(cid:1).Si

∀ j ∈ 1..n
∆ · Γ (cid:96)w &(cid:8)?li

(cid:66) receive do ({:li, (cid:101)pi} → ti)i∈Iend : T (cid:67) S(cid:48)

(cid:1) (cid:96)w Si (cid:66) ti : T (cid:67) S(cid:48)

∆ · (cid:0)Γ ,Γ 1

i , . . . , Γ n
i

[TBRANCH]

(cid:66) Γ j
i

i : T j

∀i ∈ I

(cid:0)
(cid:101)Ti

i∈I

i

The receive construct is typechecked using the [TBRANCH] rule. It expects an (external) branching
session type &(cid:8) . . . (cid:9), where each branch in the session type must match with a corresponding branch in
the receive construct, where both the labels (li) and payload types ( (cid:101)Ti) correspond. The types within
pat p : T (cid:66) Γ , which assigns
each receive branch are computed using the pattern typing judgement, (cid:96)w
types to variables present in patterns (see Appendix B.3). Each receive branch is then checked w.r.t.
the common type T and a common residual session type S(cid:48).

[TCHOICE]

∆ · Γ (cid:96)w ⊕(cid:8)!li

∃i ∈ I
(cid:1).Si
(cid:0)
(cid:101)Ti

(cid:9)

i∈I

Γ (cid:96)exp e j : T j
l = li
i
(cid:66) send (w, {:l, e1, . . . , en}) : (cid:8)atom, T 1

∀ j ∈ 1..n

i , . . . , T n
i

(cid:9) (cid:67) Si

The rule [TCHOICE] typechecks the sending of messages. This rule requires an internal choice session
type ⊕(cid:8) . . . (cid:9), where the label tagging the message to be sent must match with one of the labels (li)
offered by the session choice. The message payloads must also match with the corresponding types
associated with the label ( (cid:101)Ti of li) stated via the expression typing judgement Γ (cid:96)exp e : T (see Ap-
pendix B.2). The typing rule also checks the pid of the addressee of the send statement which must
match with the dual pid (w) states in the judgment itself to ensure that messages are only sent to the
correct addressee.

∆ ( f/n) = S

∀i ∈ 2..n · (cid:8)Γ (cid:96)exp ei : Ti

(cid:9)

[TRECKNOWNCALL]

Σ ( f/n) = Ω

Ω .return_type = T

Ω .param_types = (cid:101)T

∆ · Γ (cid:96)w S (cid:66) f (w, e2, . . . , en) : T (cid:67) end

they are listed in dom(∆ ).

Since public functions are decorated with a session type explicitly using the @session (or @dual) anno-
Calls to public functions are typechecked using the
tation,
[TRECKNOWNCALL] rule, which veriﬁes that the expected initial session type is equivalent to the func-
tion’s known session type (S) obtained from the session typing environment, i.e., ∆ ( f/n) = S. With-
out typechecking the function’s body, which is done in rule [TMODULE], this rule ensures that the
parameters have the correct types (using the expression typing rules). From the check performed in
rule [TMODULE], it can also safely assume that this session type S is fully consumed, thus the resid-
ual type becomes end. Rule [TRECKNOWNCALL] also ensures that the pid (w) is preserved during a
function call, by requiring it to be passed as a parameter and comparing it to the expected dual pid (i.e.,
∆ · Γ (cid:96) w S (cid:66) f ( w , . . .) : T (cid:67) end).

G. Tabone & A. Francalanza

23

Σ ( f/n) = Ω

f/n /∈ dom(∆ )
Ω .params = (cid:101)x Ω .param_type = (cid:101)T Ω .body = t Ω .return_type = T
(cid:9)
(∆ , f/n : S) · (cid:0)Γ , y : pid, (cid:101)x : (cid:101)T (cid:1) (cid:96)y S (cid:66) t : T (cid:67) S(cid:48)

∀i ∈ 2..n · (cid:8)Γ (cid:96)exp ei : Ti

Ω .dual = y

∆ · Γ (cid:96)w S (cid:66) f (w, e2, . . . , en) : T (cid:67) S(cid:48)

[TRECUNKNOWNCALL]

Contrastingly, a call to a (private) function, f/n, with an unknown session type associated to it is type-
checked using the [TRECUNKNOWNCALL] rule. As in the other rule, it ensures that parameters have
the correct types (Γ (cid:96)exp ei : Ti). However, it also analyses the function’s body t (obtained from Σ ) with
respect to the session type S inherited from the initial session type of the call, Furthermore, this session
type is appended to the session typing environment ∆ for future reference, i.e., ∆ (cid:48) = (∆ , f/n : S) which
allows it to handle recursive calls to itself; should the function be called again, rule [TRECKNOWNCALL]
is used thus bypassing the need to re-analyse its body.

2.5 Elixir System

The ElixirST provides a bespoke spawning function called session/4 which allows the initiation of two
concurrent processes executing in tandem as part of a session. This session/4 function takes two pairs
of arguments: two references of function names (that will be spawned), along with their list of arguments.
Its participant creation ﬂow is shown in Figure 3. Initially the actor (pre-server) is spawned, passing its
pid (ιserver) to the second spawned actor (pre-client). Then, pre-client relays back its pid (ιclient) to pre-
server. In this way, both actors participating in a session become aware of each other’s pids. From
this point onwards, the two actors execute their respective function to behave as the participants in the
binary session; the ﬁrst argument of each running function is initiated to the respective pid of the other
participant. Figure 3 shows that the server process executes the body t, where it has access to the mailbox
M . As it executes, messages may be sent or received (shown by the action α) and stored in the mailbox
M (cid:48). The speciﬁc working of these transitions is explained in the following section.

pre-client

ιserver

ιclient

pre-server

c l i e n t F n (ιserver ,
arg2 ,
arg3 ,

serverFn (ιclient ,

arg2 ,
arg3 ,

. . . )

. . . )

[. . . ]ιclient

[t (cid:67) M ]ιserver

. . .

α

[t(cid:48) (cid:67) M (cid:48)]ιserver

α (cid:48)

. . .

Figure 3: Spawning two processes (green boxes represent spawned concurrent processes)

3 Operational Semantics

We describe the operational semantics of the Elixir language subset of Figure 2 as a labelled transition
system (LTS) [18] describing how a handler process within a session executes while interacting with the
session client, as outlined in Figure 1. The transitions t α−→ t(cid:48) describes the fact that a handler process
in state t performs an execution step to transition to the new state t(cid:48) while producing action α as a side-
effect. External actions are visible by, and bear an effect on the client, whereas internal actions do not.
In our case, an action α can take the following forms:

24

Session Fidelity for ElixirST

α ∈ ACT ::= ι! {:l, (cid:101)v}
| ? {:l, (cid:101)v}
f/n
|
| τ

Output message to ι tagged as :l with payload (cid:101)v
Input message tagged as :l with payload (cid:101)v
Call function f with arity n

Internal reduction step

external action

internal action

Both output and input actions constitute external actions that affect either party in a session; the type
Internal actions, include silent transition
system from Section 2.4 disciplines these external actions.
(τ) and function calls ( f/n); although the latter may be formalised as a silent action, the decoration
facilitates our technical development. We note that, function calls can only transition subject to a well-
formed function information environment (Σ ), which contains details about all the functions available in
the module. Since Σ remains static during transitions, we leave it implicit in the transitions rules.

The transitions are deﬁned by the term transition rules listed in Figure 4. Rules [RLET1] and [RLET2]
deal with the evaluation of a let statement, x = t1; t2 modelling a call-by-value semantic, where the ﬁrst
term t1 has to transition fully to a value before being substituted for x in t2 denoted as [v/x] (or [v1, v2/x1, x2] for
multiple substitutions). The send statement, send (ι, {:l, e1, . . . , en}), evaluates by ﬁrst reducing each

t α−→
Σ

t(cid:48)

[RCHOICE1]

[RLET1]

t1

x = t1; t2

α−→ t(cid:48)
1
α−→ x = t(cid:48)

1; t2

[RLET2]

x = v; t τ−→ t [v/x]

send (ι, {:l, v1, . . . , vk−1, ek, . . . , en}) τ−→ send (cid:0)ι, (cid:8):l, v1, . . . , vk−1, e(cid:48)

k, . . . , en

(cid:9)(cid:1)

ek → e(cid:48)
k

[RCHOICE2]

send (ι, {:l, v1, . . . , vn})

ι!{:l, v1, ..., vn}
−−−−−−−−−→ {:l, v1, . . . , vn}

[RBRANCH]

∃ j ∈ I

l j = l

receive do ({:li, (cid:101)pi} → ti)i∈Iend

match( (cid:101)p j, v1, . . . , vn) = σ
?{:l, v1, ..., vn}
−−−−−−−−→ t jσ

[RCALL1]

f (v1, . . . , vk−1, ek, . . . , en) τ−→ f (cid:0)v1, . . . , vk−1, e(cid:48)

k, . . . , en

(cid:1)

ek → e(cid:48)
k

[RCALL2]

Σ ( f/n) = Ω

Ω .body = t

f (ι, v2, . . . , vn)

Ω .params = x2, . . . , xn
f/n
−→ t [ι/y] [v2, . . . , vn/x2, . . . , xn]

Ω .dual = y

[RCASE1]

e → e(cid:48)
case e do (pi → ti)i∈Iend τ−→ case e(cid:48) do (pi → ti)i∈Iend

[RCASE2]

∃ j ∈ I
match(p j, v) = σ
case v do (pi → ti)i∈Iend τ−→ t jσ

[REXPRESSION]

e → e(cid:48)
e τ−→ e(cid:48)

Figure 4: Term transition semantic rules

G. Tabone & A. Francalanza

25

e → e(cid:48)

[REOPERATION1]

e1 → e(cid:48)
1
e1 (cid:5) e2 → e(cid:48)
1 (cid:5) e2

[REOPERATION2]

e2 → e(cid:48)
2
v1 (cid:5) e2 → v1 (cid:5) e(cid:48)
2

v = v1 (cid:5) v2
[REOPERATION3] v1 (cid:5) v2 → v

[RENOT1]

e → e(cid:48)
not e → e(cid:48)

[RENOT2]

v(cid:48) = ¬v
not v → v(cid:48)

[RELIST1]

e1 → e(cid:48)
1
[ e1 | e2 ] → [ e(cid:48)

1 | e2 ]

[RELIST2]

e2 → e(cid:48)
2
[ v1 | e2 ] → [ v1 | e2 ]

[RETUPLE]

{v1, . . . , vk−1, ek, . . . , en} → {v1, . . . , , vk−1, e(cid:48)

k, . . . , en}

ek → e(cid:48)
k

Figure 5: Expression reduction rules

part of the message to a value from left to right. This is carried out via rule [RCHOICE1] which produces
no observable side-effects. When the whole message is reduced to a tuple of values {:l, v1, . . . , vn},
rule [RCHOICE2] performs the actual message sending operation. This transition produces an action
ι! {:l, v1, . . . , vn}, where the message {:l, v1, . . . , vn} is sent to the interacting process, which has a
pid value of ι. The operational semantics of the receive construct, receive do ({:li, (cid:101)pi} → ti)i∈Iend,
is deﬁned by rule [RBRANCH]. When a message is received (i.e., α = ? {:l, (cid:101)v}), it is matched with a
valid branch from the receive construct, using the label :l. Should one of the labels match (∃ j ∈ I such
that :l j = :l), the payload of the message ((cid:101)v) is compared to the corresponding patterns in the selected
branch ( (cid:101)p j) using match( (cid:101)p j, (cid:101)v). If the values match with the pattern, the match function (Deﬁnition 3.1)
produces the substitutions σ , mapping the matched variables in the pattern (cid:101)p j to values from (cid:101)v. This
substitution σ is then used to instantiate the free variables in continuation branch t j.

Deﬁnition 3.1 (Pattern Matching). The match function pairs patterns with a corresponding value, result-
ing in a sequence of substitutions (called σ ), e.g., match(p, v) = [v1/x1] [v2/x2] = [v1, v2/x1, x2]. Note that, a
sequence of match outputs are combined together, where the empty substitutions (i.e., [ ]) are ignored.
The match function builds a meta-list of substitutions, which is a different form of lists deﬁned by the
Elixir syntax in Figure 2.

match( (cid:101)p, (cid:101)v) def= match(p1, v1), . . . , match(pn, vn)

where (cid:101)p = p1, . . . , pn and (cid:101)v = v1, . . . , vn

match(p, v) def=






[ ]
[v/x]
match(w1, v1), match(w2, v2)
match(w1, v1), . . . , match(wn, vn)

p = b, v = b and p = v
p = x
p = [ w1 | w2 ] , v = [ v1 | v2 ]
p = {w1, . . . , wn} and

v = {v1, . . . , vn}

(cid:4)

Example 3.1. For the pattern p1 = {x, 2, y} and the value tuple v1 = {8, 2, true}, match(p1, v1) = σ
where σ = [8/x] [true/y] (written also as σ = [8, true/x, y]). However for pattern p2 = {x, 2, false}, the operation

26

Session Fidelity for ElixirST

match(p2, v1) fails, since p2 expects a false value as the third element, but ﬁnds a true value instead. (cid:4)

Using rule [RCALL1] from Figure 4, a function call is evaluated by ﬁrst reducing all of its parameters
to a value, using the expression reduction rules in Figure 5; again this models a call-by-value seman-
tics. Once all arguments have been fully reduced, [RCALL2], the implicit environment Σ is queried for
function f with arity n to fetch the function’s parameter names and body. This results in a transition to
the function body with its parameters instantiated accordingly, t [ι/y] [v2, . . . , vn/x2, . . . , xn], decorated by the
function name, i.e., α = f/n. Along the same lines a case construct ﬁrst reduces the expression which
is being matched using rule [RCASE1]. Then, rule [RCASE2] matches the value with the correct branch,
using the match function, akin to [RBRANCH]. Whenever a term consists solely of an expression, it
silently reduces using [REXPRESSION] using the expression reduction rules e → e(cid:48) of Figure 5. These
are fairly standard.

4 Session Fidelity

We validate the static properties imposed by the ElixirST type system [32], overviewed in Section 2.4, by
establishing a relation with the runtime behaviour of a typechecked Elixir program, using the transition
semantics deﬁned in Section 3. Broadly, we establish a form of type preservation, which states that if a
well-typed term transitions, the resulting term then remains well-typed [27]. However, our notion of type
preservation, needs to be stronger to also take into account (i) the side-effects produced by the execution;
and (ii) the progression of the execution with respect to protocol expressed as a session type. Following
the long-standing tradition in the session type community, these two aspects are captured by the reﬁned
preservation property called session ﬁdelity. This property ensures that: (i) the communication action
produced as a result of the execution of the typed process is one of the actions allowed by the current
stage of the protocol; and that (ii) the resultant process following the transition is still well-typed w.r.t.
the remaining part of the protocol that is still outstanding.

Before embarking on the proof for session ﬁdelity, we prove an auxiliary proposition that acts as a
sanity check for our operational semantics. We note that the operational semantics of Section 3 assumes
that only closed programs are executed; an open program (i.e., a program containing free variables) is
seen as an incomplete program that cannot execute correctly due to missing information. To this end,
Proposition 1 ensures that a closed term remains closed even after transitioning.

Proposition 1 (Closed Term). If fv(t) = /0 and t α−→ t(cid:48), then fv(t(cid:48)) = /0

Proof. By induction on the structure of t.

The statement of the session ﬁdelity property relies on the deﬁnition of a partial function called after
(Deﬁnition 4.1), which takes a session type and an action as arguments and returns another session type
as a result. This function serves two purposes: (a) the function after(S, α) is only deﬁned for actions α
that are (immediately) permitted by the protocol S, which allows us to verify whether a term transition
step violated a protocol or not; and (b) since S describes the current stage of the protocol to be followed,
we need a way to evolve this protocol to the next stage should α be a permitted action, and this is
precisely S(cid:48), the continuation session type returned where after(S, α) = S(cid:48).

G. Tabone & A. Francalanza

27

Deﬁnition 4.1 (After Function). The after function is partial function deﬁned for the following cases:

after(S, τ) def= S
after(S, f/n) def= S
i∈I, ι! (cid:8)l j, (cid:101)v(cid:9)) def= S j where j ∈ I
(cid:9)
i∈I, ? (cid:8)l j, (cid:101)v(cid:9)) def= S j where j ∈ I
(cid:9)

after(⊕(cid:8)!li
after(&(cid:8)?li

(cid:1).Si
(cid:0)
(cid:101)Ti
(cid:1).Si
(cid:0)
(cid:101)Ti

This function is undeﬁned for all other cases. The after function is overloaded to range over session
typing environments (∆ ) in order to compute a new session typing environment given some action α and
session type S:

after(∆ , f/n, S) def= ∆ , f/n : S
after(∆ , α, S) def= ∆

if α (cid:54)= f/n

Intuitively, when the action produced by the transition is f/n, the session typing environment is extended
by the new mapping f/n : S. For all other actions, the session typing environment remains unchanged. (cid:4)

Recall that module typechecking using rule [TMODULE] entails typechecking the bodies of all the
public functions w.r.t. their ascribed session type, ∆ · (cid:0)y : pid, (cid:101)x : (cid:101)T (cid:1) (cid:96)y
Σ S (cid:66) t : T (cid:67) S(cid:48) (where S(cid:48) = end
for this speciﬁc case). At runtime, a spawned client handler process in a session starts running the
function body term t where the parameter variables y, (cid:101)x are instantiated with the PID of the client, say
ι, and the function parameter values, say (cid:101)v, respectively, t [ι/y] [(cid:101)v/(cid:101)x], as modelled in rule [RCALL2] from
Figure 4. The instantiated function body is thus closed and can be typed w.r.t. an empty variable binding
environment, Γ = /0. Session ﬁdelity thus states that if a closed term t is well-typed, i.e.,

∆ · /0 (cid:96)w S (cid:66) t : T (cid:67) S(cid:48)

(1)

(where S and S(cid:48) are initial and residual session types, respectively, and T is the basic expression type)
and this term t transitions to a new term t(cid:48) with action α, i.e.,

the new term t(cid:48) remains well-typed, i.e.,

t α−→ t(cid:48)

∆ (cid:48) · /0 (cid:96)w S(cid:48)(cid:48) (cid:66) t(cid:48) : T (cid:67) S(cid:48)

(2)

(3)

where the evolved S(cid:48)(cid:48) and ∆ (cid:48) are computed as after(S, α) = S(cid:48)(cid:48) and after(∆ , α, S) = ∆ (cid:48). This ensures
that the base type of the term is preserved (note the constant type T in eqs. (1) and (3)). Furthermore, it
ascertains that the term t follows an interaction protocol starting from the initial session type S up to the
residual session type S(cid:48) (eq. (1)), since the updated session type S(cid:48)(cid:48) is deﬁned for after(S, α).

Theorem 2 (Session Fidelity). If ∆ · /0 (cid:96)w
that ∆ (cid:48) · /0 (cid:96)w

Σ S(cid:48)(cid:48) (cid:66) t(cid:48) : T (cid:67) S(cid:48) for after(S, α) = S(cid:48)(cid:48) and after(∆ , α, S) = ∆ (cid:48)

Σ S (cid:66)t : T (cid:67) S(cid:48) and t α−→

Σ

t(cid:48), then there exists some S(cid:48)(cid:48) and ∆ (cid:48), such

Proof. By induction on the typing derivation ∆ · /0 (cid:96)w

Σ S (cid:66) t : T (cid:67) S(cid:48).

28

Session Fidelity for ElixirST

t1

S1

α1

t2

α2

. . .

αn

v

\

after(S1, α1) = S2

after(Sn, αn) = end

Figure 6: Repeated applications of session ﬁdelity

As shown in Figure 6, by repeatedly applying Theorem 2, we can therefore conclude that all the
(external) actions generated as a result of a computation (i.e., sequence of transition steps) must all be
actions that follow the protocol described by the initial session type. Since public functions are always
typed with a residual session type end, certain executions could reach the case where the outstanding
session is updated to end as well, i.e., after(Sn, αn) = end. In such a case, we are guaranteed that the
term will not produce further side-effects, as in the case of Figure 6 where the term is reduced all the
way down to some value, v.

Example 4.1. We consider a concrete example to show the importance of session ﬁdelity. The function
called pinger/1 is able to send ping and receive pong repeatedly.

1
2
3
4
5
6
7
8
9

@session "X = !ping().?pong().X"
def pinger(pid) do

x = send(pid, {:ping})

receive do

{:pong} -> IO.puts("Received pong.")

end
pinger(pid)

end

This function adheres to the following protocol:

X = !ping().?pong().X

A process evaluating the function pinger executes by ﬁrst sending a message containing a ping

label to the interacting processes’ pid (ιpong), as shown below.

t

α = ιauct ! {ping}

t(cid:48)

x = send(ιpong, {:ping})

receive do # ...

x = {:ping}

receive do # ...

As the process evaluates, the initial term t transitions to t(cid:48), where it sends a message as a side-effect.
This side-effect is denoted as an action α, where α = ιpong! {ping}. By the After Function Deﬁnition,
X evolves to a new session type X’:

X’ = after(!ping().?pong().X, α) = ?pong().X

For t(cid:48) to remain well-typed, it must now match with the evolved session type X’, where it has to
be able to receive a message labelled pong, before recursing. Although the process keeps executing

G. Tabone & A. Francalanza

29

indeﬁnitely, by the session ﬁdelity property, we know that each step of execution will be in line with the
(cid:4)
original protocol.

5 Related Work

In this section, we compare ElixirST with other type systems and implementations.

Type Systems for Elixir Cassola et al. [4, 5] presented a gradual type system for Elixir. It statically
typechecks the functional part of Elixir modules, using a gradual approach, where some terms may be left
with an unknown expression type. In contrast to ElixirST, Cassola et al. analyse directly the unexpanded
Elixir code which results in more explicit typechecking rules. Also, they focus on the static type system
without formulating the operational semantics.

Another static type-checker for Elixir is Gradient [8]. It is a wrapper for its Erlang counterpart tool
and takes a similar approach to [5], where gradual types are used. Another project, TypeCheck [35], adds
dynamic type validations to Elixir programs. TypeCheck performs runtime typechecking by wrapping
checks around existing functions. Gradient and TypeCheck are provided as an implementation only,
without any formal analysis. In contrast to ElixirST, the discussed type-checkers [5, 8, 35] analyse the
sequential part of the Elixir language omitting any checks related to message-passing between processes.
Some implementations aim to check issues related to message-passing. Harrison [11] statically
checks Core Erlang for such issues. For instance, it detects orphan messages (i.e., messages that will
never be received) and unreachable receive branches. Harrison [12] extends [11] to add analyse Er-
lang/OTP behaviours (e.g., gen_server, which structures processes in a hierarchical manner) by in-
jecting runtime checks in the code. Compared to our work, [11, 12] perform automatic analysis of the
implementation, however they do not verify communication with respect to a general protocol (e.g.,
session types).

Another type system for Erlang was presented Svensson et al. [31]. Their body of work covers a
larger subset of Erlang to what would be its equivalent in Elixir covered by our work. Moreover, its
multi-tiered semantics captures an LTS deﬁned over systems of concurrent actors. Although we opted
for a smaller subset, we go beyond the pattern matching described by Svensson et al. since we perform
a degree of typechecking for base types (e.g. in the premise of [TBRANCH]).

Session Type Systems. Closest to our work is [23], where Mostrous and Vasconcelos introduced ses-
sion types to a fragment of Core Erlang, a dynamically typed language linked to Elixir. Their type system
tags each message exchanged with a unique reference. This allows multiple sessions to coexist, since
different messages could be matched to the corresponding session, using correlation sets. Mostrous and
Vasconcelos take a more theoretic approach, so there is no implementation for [23]. Their type system
guarantees session ﬁdelity by inspecting the processes’ mailboxes where, at termination, no messages
should be left unprocessed in their mailboxes. Our work takes a more limited but pragmatic approach,
where we introduce session types for functions within a module. Furthermore, we offer additional fea-
tures, including variable binding (e.g., in let statements), expressions (e.g., addition operation), inductive
types (e.g., tuples and lists), inﬁnite computation via recursion and explicit protocol deﬁnition.

A session-based runtime monitoring tool for python was initially presented by Neykova and
Yoshida [24, 25]. They use the Scribble [15] language to write multiparty session type (MPST) [16]
protocols, which are then used to monitor the processes’ actions. Different processes are ascribed a

30

Session Fidelity for ElixirST

role (deﬁned in the MPST protocol) using function decorators (akin to our function annotations). Sim-
ilar to [24, 25], Fowler [9] presented an MPST implementation for Erlang. This implementation uses
Erlang/OTP behaviours (e.g., gen_server), which take into account Erlang’s let it crash philosophy,
where processes may fail while executing. In contrast, although our work accepts a more limited lan-
guage, ElixirST provides static guarantees where issues are ﬂagged at pre-deployment stages, rather than
ﬂagging them at runtime.

Scalas and Yoshida [29] applied binary session types to the Scala language, where session types
are abstracted as Scala classes. Session ﬁdelity is ensured using Scala’s compiler, which complains if
an implementation does not follow its ascribed protocol. Linearity checks are performed at runtime,
which ensure that an implementation fully exhausts its protocol exactly once. Bartolo Burl`o et al. [3]
extended the aforementioned work [29], to monitor one side of an interaction statically and the other side
dynamically using runtime monitors.

Harvey et al. [13] presented a new actor-based language, called EnsembleS, which offers session
types as a native feature of the language. EnsembleS statically veriﬁes implementations with respect to
session types, while still allowing for adaptation of new actors at runtime, given that the actors obey a
known protocol. Thus, actors can be terminated and discovered at runtime, while still maintaining static
correctness.

There have been several binary [17, 19] and multiparty [6, 20] session type implementations for Rust.
These implementations exploit Rust’s afﬁne type system to guarantee that channels mirror the actions
prescribed by a session type. Padovani [26] created a binary session type library for OCaml to provide
static communication guarantees. This project was extended [22] to include dynamic contract monitoring
which ﬂags violations at runtime. The approaches used in the Rust and OCaml implementations rely
heavily on type-level features of the language, which do not readily translate to the dynamically typed
Elixir language.

6 Conclusion

In this work we established a correspondence between the ElixirST type system [32] and the runtime
behaviour of a client handler running an Elixir module function that has been typechecked w.r.t.
its
session type protocol. In particular, we showed that this session-based type system observes the standard
session ﬁdelity property, meaning that processes executing a typed function always follow their ascribed
protocols at runtime. This property provides the necessary underlying guarantees to attain various forms
of communication safety, whereby should two processes following mutually compatible protocols (e.g. S
and its dual ¯S), they avoid certain communication errors (e.g., a send statement without a corresponding
receive construct). An extended version of this work can be found in the technical report [33].

Future work. There are a number of avenues we intend to pursue. One line of investigation is the
augmentation of protocols that talk about multiple entry points to a module perhaps from the point of
view of a client that is engaged in multiple sessions at one time, possibly involving multiple modules. The
obvious starting points to look at here are the well-established notions of multiparty session types [16, 30]
or the body of work on intuitionistic session types organising processes hierarchically [2, 28]. Another
natural extension to our work would be to augment our session type protocol in such a way to account
for process failure and supervisors, which is a core part of the Elixir programming model. For this, we
will look at previous work on session type extensions that account for failure [13]. Finally, we also plan
to augment our session typed protocols to account for resource usage and cost, along the lines of [7, 10].

G. Tabone & A. Francalanza

31

Acknowledgements. We thank Simon Fowler and Matthew Alan Le Brun for their encouragement
and suggestions for improvement on earlier versions of the work. This work has been supported by the
MoVeMnt project (No: 217987) of the Icelandic Research Fund and the BehAPI project funded by the
EU H2020 RISE of the Marie Skłodowska-Curie action (No: 778233).

References

[1] Gul A. Agha (1990): ACTORS - a model of concurrent computation in distributed systems. MIT

Press series in artiﬁcial intelligence, MIT Press.

[2] Stephanie Balzer & Frank Pfenning (2017): Manifest sharing with session types. Proc. ACM

Program. Lang. 1(ICFP), pp. 37:1–37:29, doi:10.1145/3110281.

[3] Christian Bartolo Burl`o, Adrian Francalanza & Alceste Scalas (2021): On the Monitorability of
Session Types, in Theory and Practice. In Anders Møller & Manu Sridharan, editors: 35th European
Conference on Object-Oriented Programming, ECOOP 2021, July 11-17, 2021, Aarhus, Denmark
(Virtual Conference), LIPIcs 194, Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik, pp. 20:1–
20:30, doi:10.4230/LIPIcs.ECOOP.2021.20.

[4] Mauricio Cassola, Agust´ın Talagorria, Alberto Pardo & Marcos Viera (2020): A Gradual Type
System for Elixir. Proceedings of the 24th Brazilian Symposium on Context-Oriented Programming
and Advanced Modularity, doi:10.1145/3427081.3427084.

[5] Mauricio Cassola, Agust´ın Talagorria, Alberto Pardo & Marcos Viera (2022): A gradual type sys-
tem for Elixir. Journal of Computer Languages 68, p. 101077, doi:10.1016/j.cola.2021.101077.

[6] Zak Cutner & Nobuko Yoshida (2021): Safe Session-Based Asynchronous Coordination in Rust.
In Ferruccio Damiani & Ornela Dardha, editors: Coordination Models and Languages - 23rd
IFIP WG 6.1 International Conference, COORDINATION 2021, Held as Part of the 16th Inter-
national Federated Conference on Distributed Computing Techniques, DisCoTec 2021, Valletta,
Malta, June 14-18, 2021, Proceedings, Lecture Notes in Computer Science 12717, Springer, pp.
80–89, doi:10.1007/978-3-030-78142-2 5.

[7] Ankush Das, Jan Hoffmann & Frank Pfenning (2018): Work Analysis with Resource-Aware Ses-
sion Types. In Anuj Dawar & Erich Gr¨adel, editors: Proceedings of the 33rd Annual ACM/IEEE
Symposium on Logic in Computer Science, LICS 2018, Oxford, UK, July 09-12, 2018, ACM, pp.
305–314, doi:10.1145/3209108.3209146.

[8] Erlang Solutions: Gradient. Available at https://github.com/esl/gradient.

[9] Simon Fowler (2016): An Erlang Implementation of Multiparty Session Actors. In Massimo Bar-
toletti, Ludovic Henrio, Sophia Knight & Hugo Torres Vieira, editors: Proceedings 9th Interaction
and Concurrency Experience, ICE 2016, Heraklion, Greece, 8-9 June 2016, EPTCS 223, pp. 36–50,
doi:10.4204/EPTCS.223.3.

[10] Adrian Francalanza, Edsko de Vries & Matthew Hennessy (2014): Compositional Reasoning for
Explicit Resource Management in Channel-Based Concurrency. Log. Methods Comput. Sci. 10(2),
doi:10.2168/LMCS-10(2:15)2014.

[11] Joseph Harrison (2018): Automatic detection of Core Erlang message passing errors. In Natalia
Chechina & Adrian Francalanza, editors: Proceedings of the 17th ACM SIGPLAN International
Workshop on Erlang, ICFP 2018, St. Louis, MO, USA, September 23-29, 2018, ACM, pp. 37–48,
doi:10.1145/3239332.3242765.

32

Session Fidelity for ElixirST

[12] Joseph Harrison (2019): Runtime Type Safety for Erlang/OTP Behaviours.

In Adrian Fran-
calanza & Vikt´oria F¨ord´os, editors: Proceedings of the 18th ACM SIGPLAN International Work-
shop on Erlang, Erlang@ICFP 2019, Berlin, Germany, August 18, 2019, ACM, pp. 36–47,
doi:10.1145/3331542.3342571.

[13] Paul Harvey, Simon Fowler, Ornela Dardha & Simon J. Gay (2021): Multiparty Session Types for
Safe Runtime Adaptation in an Actor Language. In Anders Møller & Manu Sridharan, editors: 35th
European Conference on Object-Oriented Programming, ECOOP 2021, July 11-17, 2021, Aarhus,
Denmark (Virtual Conference), LIPIcs 194, Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik,
pp. 10:1–10:30, doi:10.4230/LIPIcs.ECOOP.2021.10.

[14] Carl Hewitt, Peter Boehler Bishop & Richard Steiger (1973): A Universal Modular ACTOR For-
malism for Artiﬁcial Intelligence. In Nils J. Nilsson, editor: Proceedings of the 3rd International
Joint Conference on Artiﬁcial Intelligence. Standford, CA, USA, August 20-23, 1973, William
Kaufmann, pp. 235–245.

[15] Kohei Honda, Aybek Mukhamedov, Gary Brown, Tzu-Chun Chen & Nobuko Yoshida (2011):
Scribbling Interactions with a Formal Foundation. In Raja Natarajan & Adegboyega K. Ojo, edi-
tors: Distributed Computing and Internet Technology - 7th International Conference, ICDCIT 2011,
Bhubaneshwar, India, February 9-12, 2011. Proceedings, Lecture Notes in Computer Science 6536,
Springer, pp. 55–75, doi:10.1007/978-3-642-19056-8 4.

[16] Kohei Honda, Nobuko Yoshida & Marco Carbone (2016): Multiparty Asynchronous Session Types.

J. ACM 63(1), pp. 9:1–9:67, doi:10.1145/2827695.

[17] Thomas Bracht Laumann Jespersen, Philip Munksgaard & Ken Friis Larsen (2015): Session types
for Rust. In Patrick Bahr & Sebastian Erdweg, editors: Proceedings of the 11th ACM SIGPLAN
Workshop on Generic Programming, WGP@ICFP 2015, Vancouver, BC, Canada, August 30, 2015,
ACM, pp. 13–22, doi:10.1145/2808098.2808100.

[18] Robert M. Keller (1976): Formal Veriﬁcation of Parallel Programs. Commun. ACM 19(7), pp.

371–384, doi:10.1145/360248.360251.

[19] Wen Kokke (2019): Rusty Variation: Deadlock-free Sessions with Failure in Rust.

In Massimo
Bartoletti, Ludovic Henrio, Anastasia Mavridou & Alceste Scalas, editors: Proceedings 12th Inter-
action and Concurrency Experience, ICE 2019, Copenhagen, Denmark, 20-21 June 2019, EPTCS
304, pp. 48–60, doi:10.4204/EPTCS.304.4.

[20] Nicolas Lagaillardie, Rumyana Neykova & Nobuko Yoshida (2020): Implementing Multiparty Ses-
sion Types in Rust. In Simon Bliudze & Laura Bocchi, editors: Coordination Models and Languages
- 22nd IFIP WG 6.1 International Conference, COORDINATION 2020, Held as Part of the 15th
International Federated Conference on Distributed Computing Techniques, DisCoTec 2020, Val-
letta, Malta, June 15-19, 2020, Proceedings, Lecture Notes in Computer Science 12134, Springer,
pp. 127–136, doi:10.1007/978-3-030-50029-0 8.

[21] Tobias Lindahl & Konstantinos Sagonas (2006): Practical type inference based on success typ-
ings. In Annalisa Bossi & Michael J. Maher, editors: Proceedings of the 8th International ACM
SIGPLAN Conference on Principles and Practice of Declarative Programming, July 10-12, 2006,
Venice, Italy, ACM, pp. 167–178, doi:10.1145/1140335.1140356.

[22] Hern´an C. Melgratti & Luca Padovani (2017): Chaperone Contracts for Higher-Order Sessions.

Proc. ACM Program. Lang. 1(ICFP), pp. 35:1–35:29, doi:10.1145/3110279.

G. Tabone & A. Francalanza

33

[23] Dimitris Mostrous & Vasco Thudichum Vasconcelos (2011): Session Typing for a Feather-
weight Erlang.
In Wolfgang De Meuter & Gruia-Catalin Roman, editors: Coordination Mod-
els and Languages - 13th International Conference, COORDINATION 2011, Reykjavik, Iceland,
June 6-9, 2011. Proceedings, Lecture Notes in Computer Science 6721, Springer, pp. 95–109,
doi:10.1007/978-3-642-21464-6 7.

[24] Rumyana Neykova & Nobuko Yoshida (2014): Multiparty Session Actors. In Alastair F. Donald-
son & Vasco T. Vasconcelos, editors: Proceedings 7th Workshop on Programming Language Ap-
proaches to Concurrency and Communication-cEntric Software, PLACES 2014, Grenoble, France,
12 April 2014, EPTCS 155, pp. 32–37, doi:10.4204/EPTCS.155.5.

[25] Rumyana Neykova & Nobuko Yoshida (2017): Multiparty Session Actors. Log. Methods Comput.

Sci. 13(1), doi:10.23638/LMCS-13(1:17)2017.

[26] Luca Padovani (2017): A Simple Library Implementation of Binary Sessions. J. Funct. Program.

27, p. e4, doi:10.1017/S0956796816000289.

[27] Benjamin C. Pierce (2002): Types and Programming Languages. MIT Press.

[28] Klaas Pruiksma & Frank Pfenning (2022): Back to futures. Journal of Functional Programming 32,

p. e6, doi:10.1017/S0956796822000016.

[29] Alceste Scalas & Nobuko Yoshida (2016): Lightweight Session Programming in Scala. In Shri-
ram Krishnamurthi & Benjamin S. Lerner, editors: 30th European Conference on Object-Oriented
Programming, ECOOP 2016, July 18-22, 2016, Rome, Italy, LIPIcs 56, Schloss Dagstuhl - Leibniz-
Zentrum f¨ur Informatik, pp. 21:1–21:28, doi:10.4230/LIPIcs.ECOOP.2016.21.

[30] Alceste Scalas, Nobuko Yoshida & Elias Benussi (2019): Verifying message-passing pro-
grams with dependent behavioural types.
In Kathryn S. McKinley & Kathleen Fisher, edi-
tors: Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design
and Implementation, PLDI 2019, Phoenix, AZ, USA, June 22-26, 2019, ACM, pp. 502–516,
doi:10.1145/3314221.3322484.

[31] Hans Svensson, Lars- ˚Ake Fredlund & Clara Benac Earle (2010): A uniﬁed semantics for future
Erlang. In Scott Lystig Fritchie & Konstantinos Sagonas, editors: Proceedings of the 9th ACM
SIGPLAN workshop on Erlang, Baltimore, Maryland, USA, September 30, 2010, ACM, pp. 23–
32, doi:10.1145/1863509.1863514.

[32] Gerard Tabone & Adrian Francalanza (2021): Session Types in Elixir. In Elias Castegren, Joeri De
Koster & Simon Fowler, editors: Proceedings of the 11th ACM SIGPLAN International Workshop
on Programming Based on Actors, Agents, and Decentralized Control, AGERE 2021, Virtual Event
/ Chicago, IL, USA, 17 October 2021, ACM, pp. 12–23, doi:10.1145/3486601.3486708.

[33] Gerard Tabone & Adrian Francalanza (2022): Static Checking of Concurrent Programs in Elixir
Using Session Types. Technical Report, University of Malta, Msida, Malta. Available at https:
//gtabone.page.link/V9Hh.

[34] Dave Thomas (2018): Programming Elixir: Functional, Concurrent, Pragmatic, Fun. Pragmatic

Bookshelf.

[35] Wiebe-Marten Wijnja: TypeCheck: Fast and ﬂexible runtime type-checking for your Elixir projects.

Available at https://github.com/Qqwy/elixir-type_check.

34

Appendix

A Additional Deﬁnitions

Session Fidelity for ElixirST

In this appendix, we formalise some auxiliary deﬁnitions that were used in Sections 2–4.

Deﬁnition A.1 (Type).

type(boolean) def= boolean
type(atom) def= atom

type(number) def= number

type(ι) def= pid, where ι is a pid instance

(cid:4)

Deﬁnition A.2 (Function Details). We can extract function details (i.e., params, body, param_types,
return_type, dual) from a list of functions ( (cid:101)Q) and build a mapping, using set-comprehension, as
follows. The list of functions ( (cid:101)Q) may consist of public (D) and private (P) functions.

details( (cid:101)Q) def=





f/n :


dual = y, params = (cid:101)x,

param_types = (cid:101)T ,

return_type = T, body = t






(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)



[@session “S”]

(cid:17)

(cid:16)

pid, (cid:101)T

@spec f




def[p] f (y, (cid:101)x) do t end

:: T







∈ (cid:101)Q





(cid:4)

Deﬁnition A.3 (Functions Names and Arity). This deﬁnition takes the set of all public function ( (cid:101)D) as
input, and returns a set of all public function names and their arity.

(cid:40)

functions( (cid:101)D) def=

f/n

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:34)

@session . . . ; @spec . . .
def f (y, x2, . . . , xn) do t end

(cid:35)

(cid:41)

∈ (cid:101)D

(cid:4)

Deﬁnition A.4 (All Session Types). The function sessions( (cid:101)D), returns the session type corresponding to
each annotated public function.

(cid:40)

sessions( (cid:101)D) def=

f/n : S

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:34)

@session “S”; @spec . . .
def f (y, x2, . . . , xn) do t end

(cid:35)

(cid:41)

∈ (cid:101)D

In case the @dual annotation is used instead of @session , the dual session type is computed automati-
(cid:4)
cally.

G. Tabone & A. Francalanza

B Type System Rules

35

In this appendix, we present the full typing rules of the type system, adapted from [32], which were
omitted from the Preliminaries Section.

B.1 Term Typing

In Section 2.4, we explained a few term typing rules, including [TBRANCH] and [TCHOICE]. In Figure 7,
we present the full list of term typing rules.

∆ · Γ (cid:96)w

Σ S (cid:66) t : T (cid:67) S(cid:48)

[TEXPRESSION]

Γ (cid:96)exp e : T
∆ · Γ (cid:96)w S (cid:66) e : T (cid:67) S

[TLET]

∆ · Γ (cid:96)w S (cid:66) t1 : T (cid:48) (cid:67) S(cid:48)(cid:48)

∆ · (Γ , x : T (cid:48)) (cid:96)w S(cid:48)(cid:48) (cid:66) t2 : T (cid:67) S(cid:48)

x (cid:54)= w

∆ · Γ (cid:96)w S (cid:66) x = t1; t2 : T (cid:67) S(cid:48)

[TBRANCH]

∆ · Γ (cid:96)w &(cid:8)?li

(cid:0)
(cid:101)Ti

(cid:1).Si

(cid:40)

∀i ∈ I ·

(cid:110)

(cid:111)

∀ j ∈ 1..n ·
∆ · (cid:0)Γ ,Γ 1
(cid:9)

pat p j
(cid:96)w
i , . . . , Γ n
i

i : T j
(cid:66) Γ j
i
(cid:1) (cid:96)w Si (cid:66) ti : T (cid:67) S(cid:48)
(cid:66) receive do ({:li, (cid:101)pi} → ti)i∈Iend : T (cid:67) S(cid:48)

i∈I

i

[TCHOICE]

∆ · Γ (cid:96)w ⊕(cid:8)!li

∃i ∈ I
(cid:1).Si

(cid:0)
(cid:101)Ti

(cid:9)

i∈I

∀ j ∈ 1..n ·

l = li
(cid:66) send (w, {:l, e1, . . . , en}) : (cid:8)atom, T 1

(cid:110)
Γ (cid:96)exp e j : T j
i

(cid:111)

i , . . . , T n
i

(cid:9) (cid:67) Si

∆ ( f/n) = S

∀i ∈ 2..n · (cid:8)Γ (cid:96)exp ei : Ti

(cid:9)

[TRECKNOWNCALL]

Σ ( f/n) = Ω

Ω .return_type = T

Ω .param_types = (cid:101)T

∆ · Γ (cid:96)w S (cid:66) f (w, e2, . . . , en) : T (cid:67) end

Σ ( f/n) = Ω

f/n /∈ dom(∆ )
Ω .params = (cid:101)x Ω .param_type = (cid:101)T Ω .body = t Ω .return_type = T
(cid:9)
(∆ , f/n : S) · (cid:0)Γ , y : pid, (cid:101)x : (cid:101)T (cid:1) (cid:96)y S (cid:66) t : T (cid:67) S(cid:48)

∀i ∈ 2..n · (cid:8)Γ (cid:96)exp ei : Ti

Ω .dual = y

∆ · Γ (cid:96)w S (cid:66) f (w, e2, . . . , en) : T (cid:67) S(cid:48)

[TRECUNKNOWNCALL]

[TCASE]

∀i ∈ I

pat pi : U (cid:66) Γ (cid:48)
(cid:96)w
i

∆ · (Γ ,Γ (cid:48)

i ) (cid:96)w S (cid:66) ti : T (cid:67) S(cid:48)

∆ · Γ (cid:96)w S (cid:66) case e do (pi → ti)i∈Iend : T (cid:67) S(cid:48)

Γ (cid:96)exp e : U

Figure 7: Term typing rules

36

Session Fidelity for ElixirST

B.2 Expression Typing

Expression are typechecked using the Γ (cid:96)exp e : T judgement, which states that “an expression e has type
T , subject to the variable binding environment Γ .” The expression typing rules are listed in Figure 8.

Γ (cid:96)exp e : T

[TTUPLE]

∀i ∈ 1..n

Γ (cid:96)exp ei : Ti

Γ (cid:96)exp {e1, . . . , en} : {T1, , . . . , Tn}

[TLITERAL]

type(b) = T

b (cid:54)= [ ]

Γ (cid:96)exp b : T

[TVARIABLE]

Γ (x) = T
Γ (cid:96)exp x : T

[TLIST]

Γ (cid:96)exp e1 : T

Γ (cid:96)exp e2 : [ T ]

Γ (cid:96)exp [ e1 | e2 ] : [ T ]

[TELIST]

Γ (cid:96)exp [ ] : [ T ]

[TARITHMETIC]

Γ (cid:96)exp e1 : number

Γ (cid:96)exp e2 : number
Γ (cid:96)exp e1 (cid:5) e2 : number

(cid:5) ∈ {+, −, ∗, /}

[TBOOLEAN]

Γ (cid:96)exp e1 : boolean

Γ (cid:96)exp e2 : boolean
Γ (cid:96)exp e1 (cid:5) e2 : boolean

(cid:5) ∈ {and, or}

[TCOMPARISONS]

(cid:5) ∈ {<, >, <=, >=, ==, ! =}
Γ (cid:96)exp e2 : T
Γ (cid:96)exp e1 : T

Γ (cid:96)exp e1 (cid:5) e2 : boolean

[TNOT]

Γ (cid:96)exp e : boolean
Γ (cid:96)exp not e : boolean

Figure 8: Expression typing rules

B.3 Pattern Typing

New variables may be created using patterns in the [TBRANCH] and [TCASE] rules. These variables are
pat p : T (cid:66) Γ . This judgement states that “a pattern p is matched
matched to a type using the judgement, (cid:96)w
to type T , where it produces new variables and their types are collected Γ ; under the assumption that the
variable containing the dual pid, w, remains unchanged.” The pattern typing rules are found in Figure 9.

pat p : T (cid:66) Γ
(cid:96)w

[TPLITERAL]

/0 (cid:96)exp b : T
pat b : T (cid:66) /0
(cid:96)w

b (cid:54)= [ ]

[TPVARIABLE]

x (cid:54)= w
pat x : T (cid:66) x : T
(cid:96)w

[TPTUPLE]

∀i ∈ 1..n

pat wi : Ti (cid:66) Γi
(cid:96)w
pat {w1, . . . , wn} : {T1, . . . , Tn} (cid:66) Γ1, . . . , Γn
(cid:96)w

[TPLIST]

pat w1 : T (cid:66) Γ1
(cid:96)w
pat [ w1 | w2 ] : [ T ] (cid:66) Γ1,Γ2
(cid:96)w

pat w2 : [ T ] (cid:66) Γ2
(cid:96)w

[TPELIST]

pat [ ] : [ T ] (cid:66) /0
(cid:96)w

Figure 9: Pattern typing rules

