2
2
0
2

l
u
J

5

]

R
C
.
s
c
[

1
v
7
3
8
1
0
.
7
0
2
2
:
v
i
X
r
a

iLibScope: Reliable Third-Party Library Detection for iOS
Mobile Apps

Jingyi Guo
allblues020201@gmail.com

Haoyu Wang
Huazhong University of Science and
Technology

Min Zheng
Alibaba

Lei Wu
Zhejiang University

Kui Ren
Zhejiang University

Yajin Zhou
Zhejiang University

Xiapu Luo
The Hong Kong Polytechnic
University

ABSTRACT
Vetting the security impacts introduced by third-party libraries in
iOS mobile apps requires a reliable library detection technique. Es-
pecially when a new vulnerability (or a privacy-invasive behavior)
was discovered in a third-party library, there is a practical need to
precisely identify the existence of third-party libraries and their
versions for iOS apps. However, few studies have been proposed to
tackle this problem, and they all suffer from the code duplication
problem in different libraries.

In this paper, we focus on third-party library detection in iOS mo-
bile apps. Given an app, we aim to identify the integrated libraries
and pinpoint their versions (or the version range). To this end, we
first conduct an in-depth study on iOS third-party libraries to re-
veal the relationship between them to demystify code duplication.
By doing so, we have the following two key observations: 1) even
though two libraries can share some classes, however, the shared
classes cannot be integrated into an app at the same time without
causing a class name conflict; and 2) code duplication between mul-
tiple versions of two libraries can vary. Based on these observations,
we propose a novel profile-based similarity comparison approach
to perform the detection. Specifically, we build a library database
consists of original library binaries with distinct versions. After
extracting profiles for each library version and the target app, we
conduct a similarity comparison to find the best matches.

We implemented this approach in iLibScope. We also built a
benchmark consists of 5,807 apps with 10,495 library integrations
and applied our tool to it. Our evaluation shows that iLibScope
achieves a recall exceeds 99% and a precision exceeds 97%. We also
applied iLibScope to detect the presence of well-known vulnerable
third-party libraries in real-world iOS mobile apps to show the
promising usage of our tool. It successfully identified 405 vulnerable
library usage from 4, 249 apps.

KEYWORDS
iOS, third-party library detection, security

1 INTRODUCTION
Third-party libraries play an important role in iOS application (app
in short) ecosystem. They facilitate the development process by
providing commonly useful functions and additional services like
app analytics or app monetization (e.g., ad libraries). A previous

study [39] aggregated a dataset of 43, 404 iOS apps and found that
third-party libraries (developed by Objective-C) have occupied over
60% of classes in iOS apps on average.

Such a large amount of third-party libraries in apps can introduce
security issues [3]. First, they may leak the user‚Äôs private data on
behalf of the host app that uses them. For instance, Egele et al. [29]
found 55% of tested apps include either advertisement or tracking
libraries. All these libraries transmitted the unique device ID to
third parties. Second, in a cross-platform analysis of potentially
harmful libraries, Chen et al. [25] discovered that most Android-side
harmful behaviors were preserved on their iOS counterparts, such
as reading from the keychain, stealthily recording audio and video,
and attempting to make phone calls. Third, the vulnerability exist-
ing in libraries can bring risks to host apps. Some popular libraries
have been reported to have vulnerabilities, like AFNetworking [6],
SSZipArchive [18], and GCDWebServer [7]. Besides, in a recent
work, Tang et al. [41] found that the use of certain third-party li-
braries listening for remote connections is a common source of
vulnerable network services.

Obviously, vetting the security impacts introduced by third-party
libraries requires a reliable library detection technique for iOS apps.
Especially when a new vulnerability (or a privacy-invasive behav-
ior) was detected in a third-party library, we need a tool to quickly
scan the app to report whether the vulnerable (or aggressive) ver-
sion of the library is in apps. Namely, this requires a generic solution
to precisely identify the existence of third-party libraries and their
versions 1 for iOS apps.

Unfortunately, few works have been proposed to tackle this prob-
lem, while previous systems cannot satisfy this requirement. Early
work [29, 32] applies a whitelist-based method to identify third-
party classes in apps, and the subsequent studies [25, 39] resort to
code dependency to recover library instances from apps. Recently,
Tang et al. [41] identify third-party libraries from apps based on a
call stack similarity analysis. But only a small portion of network
service libraries are focused. However, based on our investigation
(see Section 2), these systems all suffer from a technical challenge,
i.e., code duplication in different libraries. Due to the complex rela-
tionships between libraries, such as a dependency relationship or
sharing code in a workgroup, libraries can have duplicated code.
On the one hand, matching an app against original libraries can

1Or the range of possible versions if the exact versions cannot be determined.

1

 
 
 
 
 
 
Conference‚Äô17, July 2017, Washington, DC, USA

J. Guo, M. Zheng, Y. Zhou, H. Wang, L. Wu, X. Luo, K. Ren

lead to false positives due to the duplicated region of distinct li-
braries. On the other hand, a library instance recovered by code
dependency may include classes from more than one library due to
the inter-library relationships.

Alternatively, though the library detection for the Android plat-
form has been well explored in recent years [21, 22, 24, 27, 30, 31,
34, 35, 37, 38, 42, 44‚Äì46], the proposed methods cannot be applied
to iOS. Most of them build their methods based on the Java pack-
age structure and code dependency, which are used to identify (or
recover) library candidates from apps. While for iOS apps, first, app
code is organized in a flat space, thus there is no structural informa-
tion to help group code into potential library candidates. Second,
the semantic gaps between the Dalvik VM bytecode (Android app)
and the native ARM binary (iOS app) make it challenging to apply
the methods that work for Android apps on iOS apps.

Our approach In this paper, we propose a novel profile-based
similarity comparison approach to perform the detection. Specifi-
cally, we first construct a library database consists of libraries of
different versions. Then, for each version of the library, we build
profiles (or signatures) for the classes and methods inside the li-
brary. Here two types of profiles, i.e., the class-level profile and the
method-level (code-level) profile, are extracted from a given library.
As a result, after building the profiles for the target app, we can con-
duct a similarity comparison to determine the best matches. Note
that, we perform the library detection and a coarse-grained version
identification based on class-level profiles only, and a fine-grained
version pinpointing based on code-level profiles.

To overcome the code duplication issue, we propose our solution
based on two observations (see Section 2). First, even though two
libraries can share some classes, however, the shared classes cannot
be integrated into an app at the same time without causing a class
name conflict. Second, code duplication between multiple versions
of two libraries can vary. For instance, a particular version of library
A that shares code with a version of library B, does not necessarily
share code with another version of library B.

Accordingly, if some classes inside the app once were seen in
both ùê¥ and ùêµ, we need to determine which library introduces them
exactly. To this end, we try to find a version pair (ùë•, ùë¶) that ùê¥ùë• and
ùêµùë¶ have no common classes so that they can be integrated into
the app at the same time. To make this idea a general solution, we
propose an algorithm to identify the provenance of such duplicated
code when we find them inside the app.

We implemented this approach in iLibScope, a reliable and scal-
able third-party library detection tool for iOS apps with the capac-
ity of pinpointing library versions. We build a database consists
of profiles for 5, 768 library versions from 319 distinct libraries,
and a benchmark consists of apps with known version informa-
tion. According to our evaluation, our two-level profile has a good
uniqueness. 87.9% of our class-level profiles can limit the candidate
versions to 5 (‚â§ 5), and 96.5% of code-level profiles can achieve the
same result. We applied our tool to 5,807 apps with 10,495 libraries.
Our evaluation shows that it achieves a recall exceeds 99% and a
precision exceeds 97%. We also applied iLibScope to detect the pres-
ence of vulnerable third-party libraries in real-world iOS mobile
apps to show the usage of our system. It successfully identified 405
vulnerable library usage from 4, 249 apps.

2

Contributions In summary, this paper makes the following main
contributions:

‚Ä¢ We have studied the code duplication issues in iOS third-
party libraries, which obstacles the library detection. We
performed an empirical study on a dataset of of 319 distinct
libraries with 5, 768 versions and reported our observations.
These observations guide the design of our solution.

‚Ä¢ To the best of our knowledge, iLibScope is the first effective
approach of third-party library detection in iOS apps with the
capability of identifying library versions (or version range).
‚Ä¢ The evaluation result suggested that iLibScope can achieve
a recall exceeds 99% and a precision exceeds 97%. We have
also applied iLibScope to detect the presence of vulnerable
third-party libraries in real-world iOS mobile apps, with a
result of identifying 405 vulnerable library usage from 4, 249
iOS apps.

2 BACKGROUND AND TECHNIQUE

CHALLENGE

In this section, we first summarize different ways to integrate third-
party libraries. After that, we reveal the relationship between li-
braries to demystify code duplication based on our collected libraries,
and measure the impact of code duplication. Finally, we present
our solution accordingly.

Although two main languages are used to develop iOS apps (i.e.,
Objective-C and Swift), in this paper, we focus on apps and libraries
written in Objective-C. Objective-C has a longer history than Swift,
which results in a more abundant third-party library repository for
study. Besides, we choose the binary files of apps and libraries as
targets to research considering that the source code is not always
available. We automatically compile a library released in source
code into binaries during the collection process (see Section 4.1.1).

2.1 Library integration
For app developers, there are mainly two ways to integrate third-
party libraries into their apps. The first is via third-party library
management tools such as CocoaPods [26] and Carthage [23], and
the second is copy-paste. When there is a heavy requirement for
code customization, copy-paste manner is of great flexibility; oth-
erwise, integrating libraries by tools is much more convenient,
especially if there are complex dependency requirements.

Meanwhile, this rule also applies to library developers. However,
different from apps (i.e., the library code will be integrated into
the app regardless of the manners), adopting different integration
methods can result in distinct library composition. For example,
when library ùê¥ includes ùêµ through copy-paste, ùê¥ takes over this ùêµ
copy and is shipped with it during distribution. In contrast, inte-
grating ùê∂ through management tools results in a loose relationship.
First of all, ùê¥ does not need to include ùê∂ into its repository. ùê∂ will
be integrated into the app automatically during the integration of
ùê¥. Second, ùê¥ can use flexible strategies to integrate a dynamic copy
of ùê∂, for instance, the newest patched version. It is important to
note that we do not take a loosely integrated ùê∂ as part of ùê¥ during
the library collection as well as the profile extraction process, con-
sidering the space consumption and the profile (signature) stability.
While for the copy-paste inclusion, in most cases, the integration

iLibScope: Reliable Third-Party Library Detection for iOS Mobile Apps

Conference‚Äô17, July 2017, Washington, DC, USA

Figure 1: Three typical cases of code duplication (yellow re-
gion) between libraries.

is obscure unless we conduct a library detection on libraries them-
selves. Besides, the pasted code can be customized. Therefore, we
take the tightly integrated ùêµ copy as part of ùê¥.

2.2 Code duplication
To understand code duplication between libraries, we first conduct
an empirical study to characterize the relationship between libraries
by investigating collected libraries 2. Then, we show the statistics
of code duplication among our library database. At last, we present
our solution based on a case study.

Inter-library relationships. By inspecting our collected li-
2.2.1
braries, we summarize the inter-library relationships into two cate-
gories, i.e., the library dependency relationship, and the code sharing
relationship.

As described in Section 2.1, libraries can integrate dependency
libraries as apps do. We denote this kind of relationship as library
dependency and present three typical cases in Figure 1. The dif-
ferences locate in the inclusion degree (a complete inclusion like
case 1, or a partial inclusion like case 2) and count of participants
(two participants like case 1 and 2, or more participants like case 3).
Partial inclusion is possible when the library is customized or only
sub-modules are integrated.

The other relationship code sharing refers to the existence of
similar or identical code snippets between libraries. Significantly,
these snippets do not exist as an independent library. We can also
use Figure 1(3) to illustrate a code sharing case. Here the ùê∫ node
represents a shared code snippet instead of a library. Some typical
cases are summarized in the following:
‚Ä¢ Sub-module packaging When a sub-module is packaged as an
individual library, there is duplicated code between it and the mas-
ter library. For example, the early Facebook-iOS-SDK was com-
posed of sub-modules (CoreKit, LoginKit, and ShareKit) which
were later encapsulated as libraries (FBSDKCoreKit, FBLoginKit,
and FBShareKit). We collect multiple versions of them all and
find a complex duplication situation among their binaries.
‚Ä¢ Library substitute To some extent, the deprecated library and
its substitute can be regarded as one library‚Äôs different versions.
For example, GoogleMobileAds is deprecated in favor of Google-
Mobile-Ads-SDK. There was no difference between the two when
the handover just started. As the latter keeps updating, the gap

2Totally 319 unique libraries with 5,768 versions, see Section 4.1.1

3

Figure 2: Library pairs with overlap regions.

gradually widens. But even so, there is still a lot of identical code
between the two libraries.

‚Ä¢ Different releases The different releases are towards different
developers. They have almost the same functionalities, and even
the version updates are consistent. For example, the difference
between AMapFoundation-NO-IDFA and AMapFoundation is
whether the IDFA (identifier for advertising) is introduced.
Since Objective-C does not support namespaces, all classes in
a binary (an app or a library) are organized and accessed in a flat
space. Therefore, we use scattered dots to represent classes inside a
library to show the code layout, as presented in Figure 1. For each
library pair, when the app includes one of them, it seems similar to
the other.

2.2.2 Code duplication statistics. To measure the code duplication
in our collected library database, we calculate the overlaps between
each library pair as follows:

ùëúùë£ùëíùëüùëôùëéùëù (ùê¥, ùêµ) = max

‚àÄùëé ‚ààùê¥,‚àÄùëè ‚ààùêµ

# ùëêùëôùëéùë†ùë†ùëíùë† ùëëùëí ùëì ùëñùëõùëíùëë ùëñùëõ ùëé ùëéùëõùëë ùëè
# ùëêùëôùëéùë†ùë†ùëíùë† ùëëùëí ùëì ùëñùëõùëíùëë ùëñùëõ ùëé

,

(1)

ùëé/ùëè is any collected version of library ùê¥/ùêµ. We regard the classes
of the same name in ùëé and ùëè as their overlap region. If there is
an overlap between ùê¥ and ùêµ, we keep both ùëúùë£ùëíùëüùëôùëéùëù (ùê¥, ùêµ) and
ùëúùë£ùëíùëüùëôùëéùëù (ùêµ, ùê¥) since they have different meanings. For example,
ùëúùë£ùëíùëüùëôùëéùëù (ùëåùëå ùêæùëñùë°, ùëåùëåùëá ùëíùë•ùë°) equals 0.34 means that if an app includes
the library ùëåùëåùëá ùëíùë•ùë°, we can also consider that the app includes 34%
of ùëåùëå ùêæùëñùë°; on the other hand, the ùëúùë£ùëíùëüùëôùëéùëù (ùëåùëåùëá ùëíùë•ùë°, ùëåùëå ùêæùëñùë°) equals
0.87 means that when the app includes ùëåùëå ùêæùëñùë°, we can consider the
app includes 87% of ùëåùëåùëá ùëíùë•ùë°.

We present the distribution of overlap ratio among the collected
319 libraries in Figure 2. The result shows that 84 libraries have code
duplication with others. A caution here is that a library pair whose
overlap ratio equals 1.0 does not mean they are identical since the
granularity of overlap is very rough. Nevertheless, it does mean that
they are highly similar (the measurement of library uniqueness is
presented in Section 4). Besides, the causes of overlaps we counted
(i.e., overlaps in our database) are mainly copy-paste integration
and code sharing. According to our collection strategy, when a
target library integrates dependency libraries through management
tools, we do not take these dependencies as part of it.

As such, when conducting a similarity comparison between
the target app and libraries, an app code snippet can match with

Conference‚Äô17, July 2017, Washington, DC, USA

J. Guo, M. Zheng, Y. Zhou, H. Wang, L. Wu, X. Luo, K. Ren

library versions changes (implication two), there can be one version
pair of ùê∂ and ùê∑ that do not share classes. A more general algorithm
is detailed in Section 3.4.

3 SYSTEM DESIGN AND IMPLEMENTATION
3.1 Overview
Given an iOS app, our system aims at detecting the existence and
version information of libraries included in it. Accordingly, the
system works in the following four steps, as shown in Figure 4.

First, we build a profile for each library version we collected as
well as the target app. Second, with all the profiles of libraries, we
build an index for them to facilitate searching. Third, we recover
library instances from the app based on its profile. We handle the
code duplication challenge in this step (Section 3.4). At last, we find
out the best-matched version (or version set) for each recovered
library instance. It is worth noting that we devised a two-level
profile structure, i.e., the class-level profile and the code-level profile.
The class-level profile is easy to build but less informative, while
the code-level profile captures more variation between versions but
takes time to construct. We recover library instances and infer their
coarse version ranges with class-level profiles, and shrink the range
using code-level profiles. To make a trade-off between detection
efficiency and version precision, we leave the code-level profile
construction and fine-grained version detection for the target app
as an optional task. In the remaining part of this section, we will
elaborate on each step in order.
3.2 Profile Extraction
3.2.1 Profile structure. We design the profile structure against the
following observations.
‚Ä¢ Obfuscation is not encouraged in iOS app. Apple does not
encourage symbol obfuscation for iOS apps, which it believes
will obstacle the review process [1]. Generally, an app that con-
tains obfuscated code will be declined by the reviewer, and the
developer will be asked to explain the reason for the obfuscation.
Therefore, app developers rarely take the initiative to obfuscate
third-party libraries.

‚Ä¢ Class-level analysis of an iOS app is efficient. Due to the
dynamic features of Objective-C, an iOS app written in this lan-
guage needs to retain the metadata of all classes to support the
Objective-C runtime. This metadata contains plenty of informa-
tion and can be extracted easily by tools such as class-dump [12].
‚Ä¢ Code-level analysis of an iOS app is time-consuming. An-
alyzing an iOS app is time-consuming. It usually takes IDA [9]
tens of minutes or even hours to only finish the initial auto
analysis of an iOS app binary.
Take both efficiency and accuracy into consideration, we design
the profile with a two-level structure, as shown in Figure 5. Specifi-
cally, we construct the class-level profile with class metadata and the
code-level profile with semantic features extracted from the assembly
after IDA‚Äôs initial analysis.

3.2.2 Class-level profile. We define a virtual root node to help
organize all classes included in a binary, and each class node has
its defined methods as child nodes. Due to the lack of namespaces,
Objective-C classes must have unique names across an entire binary
to avoid the name conflict, and so do methods [4]. Therefore, each

Figure 3: A partial map of the overlap ratio between
FirebaseAnalytics and FirebaseCore in different version
pairs. The color of each tile presents the extent of
ùëúùë£ùëíùëüùëôùëéùëù (ùêπùëñùëüùëíùëèùëéùë†ùëíùê¥ùëõùëéùëôùë¶ùë°ùëñùëêùë†ùë¶, ùêπùëñùëüùëíùëèùëéùë†ùëíùê∂ùëúùëüùëíùë• ), y/x is the specific
releases of FirebaseAnalytics/FirebaseCore. The overlap ra-
tio is 0.6875 at point A, and 0 at point B and C.

snippets of different libraries. We have to identify its provenance
correctly to achieve accurate library detection.

2.3 Our solution

Figure 3 shows the overlap ratio be-
A motivating example
tween two libraries, i.e., FirebaseAnalytics (ùêπùê¥) and FirebaseCore
(ùêπùê∂) in different version pairs. For a fixed version of ùêπùê¥, the over-
lap between it and different versions of ùêπùê∂ varied, since the later
changes during updates. For instance, at point ùê¥, ùêπùê¥ùë¶1 has an over-
lap with the ùêπùê∂ùë•1. While at point ùê∂, the same ùë¶1 has no overlap
with the updated ùë•2 version of ùêπùê∂, which means ùë•2 dropped the
code that causes overlap at point ùê¥. This explanation also applies to
point ùê¥ and point ùêµ. The duplicated (overlapped) code is removed
from ùêπùê¥ after upgrading to a new version. Since Objective-C does
not have built-in support for namespaces, an app can only inte-
grate a ùêπùê¥ as well as a ùêπùê∂ smoothly when this version pair has no
overlaps.

Therefore, our solution to solve the challenge is based on two
implications. First, even though two libraries can share classes, the
shared classes cannot be integrated into an app at the same time
without causing a class name conflict. Second, code duplication
between multiple versions of two libraries can vary.

We take the library pair in Figure 1(2) to illustrate our idea.
For a given app, we first divide its classes into three groups, the
ùê∂ùëúùëöùëöùëúùëõùê∂ùëôùëéùë†ùë†ùëíùë†, ùê∂ùê∂ùëôùëéùë†ùë†ùëíùë†, and ùê∑ùê∂ùëôùëéùë†ùë†ùëíùë†. For an app class ùëêùëôùë†, re-
siding in ùê∂ùê∂ùëôùëéùë†ùë†ùëíùë† (ùê∑ùê∂ùëôùëéùë†ùë†ùëíùë†) means it appears and only appears in
some versions of library ùê∂ (ùê∑) while in ùê∂ùëúùëöùëöùëúùëõùê∂ùëôùëéùë†ùë†ùëíùë† means it
appears in some versions of library ùê∂ as well as some versions of ùê∑.
We assume that none of these three sets are empty. We then use the
union{ùê∂ùê∂ùëôùëéùë†ùë†ùëíùë†, ùê∂ùëúùëöùëöùëúùëõùê∂ùëôùëéùë†ùë†ùëíùë†} and union{ùê∑ùê∂ùëôùëéùë†ùë†ùëíùë†,ùê∂ùëúùëöùëöùëúùëõùê∂ùëôùëéùë†ùë†ùëíùë†}
to match with different versions of ùê∂ and ùê∑ to find a best match.
Note that, since each class in ùê∂ùëúùëöùëöùëúùëõùê∂ùëôùëéùë†ùë†ùëíùë† can only belong to
library ùê∂ or ùê∑ (implication one), we propose a strategy to decide
which library (i.e., the ùê∂ùê∂ùëôùëéùë†ùë†ùëíùë† or ùê∑ùê∂ùëôùëéùë†ùë†ùëíùë†) has priority to con-
duct the matching process. If there is a match, then the library
(and its version) is found. Since code duplication between different

4

iLibScope: Reliable Third-Party Library Detection for iOS Mobile Apps

Conference‚Äô17, July 2017, Washington, DC, USA

Figure 4: Overall architecture of iLibScope.

there are mainly four kinds of constant data that can help decide
the identity of a callee‚Äîthe class references (used to reference a
class), the selector references (reference a selector), the constant
strings (always used as parameters), and external symbols (mainly
the data in __stubs and __got segments, including function symbols
and data symbols). We record all these data usages in a method as
its features list.

3.3 Indexing
To quickly retrieve classes, we unfold all class nodes contained in
library profiles and index them by name. Given a name string, we
can locate library classes of this name and access each class node‚Äôs
information defined in its profile, such as which library version
it belongs to and what methods it defines. Such information are
indexed and saved into database for efficient querying.

3.4 Library Instance Recovery
According to Section 2, an app profile can match with several li-
brary profiles at the same time due to the code duplication between
libraries. Given the situation, we perform the match process at the
class level instead of the library level. Even so, an app class can
match multiple classes from distinct libraries or different versions.
Therefore, to facilitate processing, we arrange app classes into a
graph as shown in Figure 6. We put an app class to the floating
region if it matches distinct classes of different libraries, otherwise,
to the settled region. For instance, a class locates in node ùê¥ùêµ means
it may be either library ùê¥ or library ùêµ who introduces it into the
app. Suppose each node in the settled region is a library candidate,
the floating classes can influence the judgments of candidates in
two aspects.
‚Ä¢ The validness. If we award all classes of ùê¥ùêµ to candidate ùê¥, then

the candidate ùêµ is spurious.

‚Ä¢ The version. For a class in ùê∂ùê∑ that is introduced by ùê∑, awarding
it to the wrong provenance ùê∂ may mislead the version judgment
of candidate ùê∂.
As a conclusion, identifying the correct provenance for floating
classes is the critical point to recover accurate library instances.
To achieve the goal, we recover library instances in two steps. We
first arrange app classes by their possible provenance and construct
an initial graph like Figure 6. Then we transfer classes in floating
region to its best-matched candidate in the settled region.

Figure 5: The universal profile structure for iOS apps and
libraries.

node in a profile has a unique label. During the extraction process,
we tackle the following issues.

‚Ä¢ Dump class metadata inside static libraries.

Since the class-
dump tool cannot directly act on static libraries, we obtain a
library‚Äôs class metadata with the aid of an app containing it.
(Specifically, the Container app we obtained in the collection
process. Check 4.1.1 for more details.) We first dump the app‚Äôs
class metadata and then filter it with exported symbols of the
target library if necessary. We use the nm [11] tool to dump the
symbol table.

‚Ä¢ Deal with the class category.

In Objective-C, the category
is a structure to add methods to existing classes [5]. Different
libraries and library versions can have separate extensions to an
existing class, like NSData(GMSCrypto) and NSData(FIRBase64)
are two categories of the class NSData. When building profiles,
we deal with categories in the same way as classes, i.e., we will
set NSData(GMSCrypto) and NSData(FIRBase64) as two distinct
class nodes in a profile if they occur in one binary.

3.2.3 Code-level profile. In this paper, we use the callee informa-
tion in a method body as its code-level features. As a dynamic
language, Objective-C resolves method invocations (the messages)
at runtime. Specifically, each message is first delivered to the the
dispatch function _objc_msgSend [13, 14], then the dispatch func-
tion resolves the message and pass it to the real handler. As such,
a message is consists of three parts: the ùëüùëíùëêùëíùëñùë£ùëíùëü ‚Äôs pointer, the
ùë†ùëíùëôùëíùëêùë°ùëúùëü for selecting the handler out from the ùëüùëíùëêùëíùëñùë£ùëíùëü ‚Äôs methods,
and argument list for the handler. Obviously, all those parts can
be constructed dynamically at runtime, which complicates the call
analysis. Therefore, we directly pick the explicit data that helps
decide the callee at runtime as code-level features.

We retrieve the features using the state-of-the-art tool IDA [9].
After the IDA‚Äôs initial automated analysis, we build a data reference
graph through the interface provided by IDAPython to resolve the
constant data usages in each method. Based on our observation,

5

Conference‚Äô17, July 2017, Washington, DC, USA

J. Guo, M. Zheng, Y. Zhou, H. Wang, L. Wu, X. Luo, K. Ren

Figure 6: Arrange the app‚Äôs classes by their possible third-
party provenance. The gray-scale of a node represents the
number of classes it contains.

Identifying library candidates. For each class ùëéùëê in the app,
3.4.1
we compare it with all library classes with the same name to decide
whether it belongs to some third-party libraries or not.
‚Ä¢ STEP 1: Locate library classes with the same name. To avoid
naming conflicts with other libraries or app-authored code, li-
brary developers try their best to assign special prefixes to their
classes. Therefore, we use the class name to locate library classes
that may be similar to ùëéùëê and denote them as set ùëÜùë° .

‚Ä¢ STEP 2: Find classes similar to ùëéùëê. For each library class ùëôùëê in ùëÜùë° ,
we calculate the similarity score between ùëéùëê and ùëôùëê as follows:

ùë†ùëñùëö(ùëéùëê, ùëôùëê) =

# ùëöùëíùë°‚Ñéùëúùëëùë† ùëëùëí ùëì ùëñùëõùëíùëë ùëñùëõ ùëéùëê ùëéùëõùëë ùëôùëê
# ùëöùëíùë°‚Ñéùëúùëëùë† ùëëùëí ùëì ùëñùëõùëíùëë ùëñùëõ ùëéùëê ùëúùëü ùëôùëê

.

(2)

We regard all ùëôùëês whose ùë†ùëñùëö(ùëéùëê, ùëôùëê) is greater than 0 as the coun-
terparts of ùëéùëê and denote them as ùëêùëù (ùëéùëê).

‚Ä¢ STEP 3: Award ùëéùëê to the appropriate node in the class layout
graph. Suppose ùëéùëê and its counterparts are as follows (the digit
is the similarity score):

ùëéùëê : ùëôùëê1 (0.8), ùëôùëê2 (0.8), ùëôùëê3 (0.7), ...

If all these counterparts are from library ùê¥ (but different versions),
award it to node ùê¥; if part of them are from ùê¥ and others are
from ùêµ, then award it to node ùê¥ùêµ.

Filtering library candidates. In this step, we move each float-
3.4.2
ing class to the library candidate that it most likely belongs to. We
present the detailed transfer strategy in Algorithm 1. Before that,
we first introduce the assumptions our strategy based on, and then
detail the indicators that help us make decisions later.

Assumptions

The first assumption we make is that the library candidate with
more classes has priority to match against floating classes. For
example, for a candidate pair like ùê¥ and ùêµ in Figure 6, the app could
include ùê¥ and ùêµ both, or include ùê¥ only. This all depends on the
provenance of floating classes in ùê¥ùêµ. Since ùê¥ contains more classes
than ùêµ, which means it contains more information to help decide
if a floating class in ùê¥ùêµ belongs to it, we start from ùê¥ to match it
against each floating class in ùê¥ùêµ.

The second assumption is that when a floating class can co-
exist with a library candidate, we consider this floating class is
compatible with the candidate and should be part of it. Specifically,
for a class ùëêùëôùë†ùëì in ùê¥ùêµ, to decide whether it belongs to ùê¥ or not, we
calculate the version range for current ùê¥ based on classes in it and
the version range for ùëêùëôùë†ùëì . If the two ranges have an intersection,
we consider they can coexist in one binary (version) and move ùëêùëôùë†ùëì
to candidate ùê¥.

6

However, these two assumptions can not handle all cases. For
instance, for candidate pair ùëÉ and ùëÑ who does not carry any in-
formation to match against classes in ùëÉùëÑ, or a floating class in ùê¥ùêµ
failed to match with ùê¥ while ùêµ carries no information, or a floating
class in ùê∂ùê∑ failed to match with both ùê∂ and ùê∑, we take a trial and
error. We give each candidate a try to own such floating classes
and calculate a ùëÜùëêùëúùëüùëí based on the current state, and then award
the floating classes to the candidate with a higher score. The ùëÜùëêùëúùëüùëí
is version sensitive, thus awarding fake classes to a candidate can
make the candidate abnormal and results in a low score. We denote
this as assumption 3.

For a library candidate ùê∂, ùêø is its corresponding li-
Indicators
brary, ùëâ is a set of collected versions of ùêø and ùëâùë• is one of them, we
define the following indicators.
‚Ä¢ ùëÄ (ùê∂, ùëâùë• ) = {ùëéùëê | ùëéùëê ‚àà ùê∂, ùëêùëù (ùëéùëê) ‚à© ùëâùë• ‚â† ‚àÖ}, the matched classes
between ùê∂ and ùëâùë• . Classes in ùê∂ are detected to belong to ùêø, but
they do not necessarily exist in ùëâùë• . In the worst case, there is
no ùëâùë• contains all these classes‚Äîif the integrated ùêø is a missed
version, or ùê∂ includes some wrong classes by mistake.

‚Ä¢ ùëÜùëñùëöùë† (ùê∂, ùëâùë• ) = (cid:205)ùëéùëê ‚ààùëÄ (ùê∂,ùëâùë• ) ùë†ùëñùëö(ùëéùëê, ùëôùëêùë£), the aggregate similarity
score between ùê∂ and ùëâùë• . For each ùëéùëê in ùëÄ (ùê∂, ùëâùë• ), ùëôùëêùë£ is its coun-
terpart in ùëâùë• , and ùë†ùëñùëö(ùëéùëê, ùëôùëêùë£) is the similarity score between
them, which we have calculated before when finding library
classes similar to ùëéùëê.

‚Ä¢ ùëÜùëñùëöùëé (ùê∂, ùëâùë• ) = ùëÜùëñùëöùë† (ùê∂, ùëâùë• )/# ùëÄ (ùê∂, ùëâùë• ), the average similarity

of the matched classes between ùê∂ and ùëâùë• .

‚Ä¢ ùëÉùëüùëúùëù (ùê∂, ùëâùë• ) = # ùëÄ (ùê∂, ùëâùë• )/# ùëâùë• , the matched proportion in the

original library version.

Based on these objective indicators, we introduce three subjective
attributes defined by ourselves.
‚Ä¢ ùê∂ùëúùëöùëù (ùê∂, ùëâùë• ) = # ùëö(ùê∂, ùëâùë• )/# ùê∂, the compatibility between ùê∂
and ùëâùë• . As we explained in the definition of ùëÄ (ùê∂, ùëâùë• ), this value
can be smaller than 1. In this case, the more classes there are in
ùëÄ (ùê∂, ùëâùë• ), the more compatible the ùê∂ is in ùëâùë• .

‚Ä¢ ùëâùëù = argmaxùëâùë• ‚ààùëâ ùëÜùëñùëöùë† (ùê∂, ùëâùë• ), the best matched version set.
Since there may be class additions and deletions between ver-
sions, we use the aggregate similarity to decide ùëâùëù instead of the
average. Besides, we do not consider ùëÉùëüùëúùëù when deciding ùëâùëù due
to the possibility of partial inclusions.

‚Ä¢ ùëÜùëêùëúùëüùëí (ùê∂) = maxùëâùë• ‚ààùëâùëù ùëÜùëñùëöùëé (ùê∂, ùëâùëã ) ‚àóùëÉùëüùëúùëù (ùê∂, ùëâùë• ) ‚àóùê∂ùëúùëöùëù (ùê∂, ùëâùë• ),
the final score we assign to candidate ùê∂. The similarity score
and matched proportion are the two general factors to measure
whether an app and a library match. Here we use an additional
ùê∂ùëúùëöùëù to magnify the impact of placing a class into a candidate
by mistake.

The algorithm According to assumption 1, we start with non-
empty candidates and rank them by size (i.e., the count of classes
in it). Then, for a candidate, we check each floating class in its
descendants to see whether this class is compatible with it based on
assumption 2. Specifically, we consider a candidate and a floating
class as compatible if their ùëâùëù s have an intersection. When calcu-
lating ùëâùëù for a single class, we regard it as a candidate that has
only one class in it. As a result, we transfer the floating class to
the candidate if they match, or we leave it in the floating region
waiting for its next turn. Since awarding a class to a candidate may

iLibScope: Reliable Third-Party Library Detection for iOS Mobile Apps

Conference‚Äô17, July 2017, Washington, DC, USA

Algorithm 1: Filter library candidates.

Input: G: the region graph.
Output: R: valid library instances

1 ùëÖ ‚Üê ‚àÖ
2 ùëÅ ‚Üê Non-empty nodes in settled region
3 for ùëôùëñùëè ùëñùëõ ùë†ùëúùëüùë°ùëíùëë (ùëÅ , ùëòùëíùë¶ = ùë†ùëñùëßùëí, ùëüùëíùë£ùëíùëüùë†ùëí = ùëá ùëüùë¢ùëí) do
4

for ùëì ùëõùëúùëëùëí ùëñùëõ ùëôùëñùëè‚Ä≤ùë† ùë†ùë¢ùëêùëêùëíùë†ùë†ùëúùëüùë† do

5

6

7

for ùëéùëê ùëñùëõ ùëì ùëõùëúùëëùëí do

if ùëéùëê ùëñùë† ùëêùëúùëöùëùùëéùë°ùëñùëèùëôùëí ùë§ùëñùë°‚Ñé ùëôùëñùëè then
move ac from fnode to lib

8
9 ùëÅ ‚Üê All nodes in settled region
10 for ùëôùëñùëè ùëñùëõ ùëÅ do

11

12

ùëíùë•ùë°ùëíùëõùëëùëíùëë_ùëôùëñùëè ‚Üê ùëôùëñùëè + ùëôùëñùëè‚Ä≤ùë† ùë†ùë¢ùëêùëêùëíùë†ùë†ùëúùëüùë†
ùëôùëñùëè.ùë†ùëêùëúùëüùëí ‚Üê ùëíùë•ùë°ùëíùëõùëëùëíùëë_ùëôùëñùëè.ùë†ùëêùëúùëüùëí

13 while N is not empty do

14

15

16

17

18

19

20

21

22

ùëôùëñùëè ‚Üê ùë†ùëúùëüùë°ùëíùëë (ùëÅ , ùëòùëíùë¶ = ùë†ùëêùëúùëüùëí, ùëüùëíùë£ùëíùëüùë†ùëí = ùëá ùëüùë¢ùëí) [0]
N.remove(lib)
if ùëôùëñùëè.ùë†ùëêùëúùëüùëí > 0 then
ùëÖ.ùëéùëëùëë (ùëôùëñùëè)
for ùëì ùëõùëúùëëùëí ùëñùëõ ùëôùëñùëè‚Ä≤ùë† ùë†ùë¢ùëêùëêùëíùë†ùë†ùëúùëüùë† do

move all classes contained in fnode to lib
ùëëùëíùëô ‚ü®ùëôùëñùëè, ùëì ùëõùëúùëëùëí ‚ü© ùëñùëõ ùê∫
for ùëüùëôùëñùëè ùëñùëõ ùëì ùëõùëúùëëùëí‚Ä≤ùë† ùëùùëüùëíùëëùëíùëêùëíùë†ùë†ùëúùëüùë† do

ùë¢ùëùùëëùëéùë°ùëí ùëüùëôùëñùëè‚Ä≤ùë† ùë†ùëêùëúùëüùëí

23 return R

change the latter‚Äôs ùëâùëù , we keep updating ùëâùëù for each compatibility
test. We present this part in lines 3-7 of Algorithm 1.

After the first round transfer, some floating classes may have
settled down, while some may remain floating. As such, we make a
trial and error‚Äîlet each candidate try owning all possible classes
and check how do they fit. As presented in lines 9-12, we assume
every candidate owns all classes in its descendants and calculate
the ùëÜùëêùëúùëüùëí for the extended one. According to assumption 3, we rank
candidates by their extended ùëÜùëêùëúùëüùëí and award floating classes to
the candidate with a higher ùëÜùëêùëúùëüùëí. We present the detailed logic in
lines 13-22. It‚Äôs worth noting that, when we confirm the provenance
of a floating class, we have to remove it from some other candidates
that own it for the moment and update their scores, as presented in
lines 21-22. In the end, we regard each returned library candidate
as valid library instance and recalculate indicators for it, which will
be output as part of the report.

3.5 Version Detection
Since we have calculated ùëâùëù for each library instance in the previous
step, we take it as the class-level version detection result. If ùëâùëù is
not as precise as expected, we regard it as candidates and conduct
a further detection based on code-level profiles. Considering that
differences between neighboring versions are usually small, and
the candidate versions are often successive, the code involved in
differences between candidates is limited. Focusing on these code
snippets, we can find the best-matched versions efficiently.

Since we extract code features on method granularity, we first
find methods that are not consistent among candidates. To be pre-
cise, the methods exist in all candidates but inconsistent among
them, and methods that exist in part of candidate versions. We
denote these methods as set ùëÄ. Meanwhile, we denote the inter-
section set between the library instance and ùëÄ as ùëÅ (ùëÅ ‚äÜ ùëÄ). We
define function ùëì (ùëö, ùêµ) to obtain the code features of method ùëö
in binary ùêµ, where ùêµ can be a library instance or any candidate
version. When there is no ùëö available in ùêµ, an empty feature list is
returned. Therefore, the similarity score between a library instance
ùêø and a candidate version ùê∂ùëñ can be expressed as:

ùë†ùëñùëö(ùêø, ùê∂ùëñ ) =

‚àëÔ∏Å

ùëö ‚ààùëÅ

ùë†ùëñùëö(ùëì (ùëö, ùêø), ùëì (ùëö, ùê∂ùëñ )).

We use a variant of Manhattan distance to measure the similarity
of two feature lists. This method is used for clone detection in
Wukong [42]. For feature lists A and B, with n kinds of features in
total, their similarity score is represented as:

ùë†ùëñùëö(ùê¥, ùêµ) = 1 ‚àí ùëëùëñùë†ùë°ùëéùëõùëêùëí (ùê¥, ùêµ) = 1 ‚àí

(cid:205)ùëõ
ùëñ=0|ùê¥ùëñ ‚àí ùêµùëñ |
(cid:205)ùëõ
ùëñ=0 (ùê¥ùëñ + ùêµùëñ )

.

(3)

Finally, the candidates with the highest similarity score are given
as the final result.

4 EVALUATION
Our evaluation is driven by the following three research questions:
RQ1 Can the profiles we extracted distinguish different libraries

and library versions?

RQ2 Can iLibScope recover library instances from apps and iden-
tify their versions correctly? Does it handle the code dupli-
cation between libraries well?

RQ3 Can iLibScope facilitate the detection of vulnerable library

versions?

To answer RQ1, we measure the profile uniqueness across the
collected libraries. To answer RQ2, in the absence of established
benchmarks for iOS third-party library detection in the research
community, we propose to collect open-source apps with known
library usage as a benchmark. To answer RQ3, we focus on three
well-known vulnerable libraries and perform a large-scale detection
in the wild. We intend to make our data publicly, including the
iLibScope project and the dataset.

4.1 Dataset
4.1.1 Library collection. To automate the collection process, we
download library repositories via CocoaPods [26] and then compile
them using Xcode [20]. To make our collected libraries represen-
tative, we use Specs Repo [2] to obtain the popularity of libraries.
Specs Repo is a repository that maintains records of each library
hosted on CocoaPods, including the name, version, source, license,
summary, dependencies, etc. Therefore, we can measure a library‚Äôs
popularity by the frequency of being cited as a dependency. After
confirming the target library list, we try to collect as many versions
as possible for each target. Significantly, when a target library has
dependencies, we add the dependency libraries to the target list
also. Each library version is collected as follows.
1) Create an empty Xcode project (the Container app) for integra-

tion.

7

Conference‚Äô17, July 2017, Washington, DC, USA

J. Guo, M. Zheng, Y. Zhou, H. Wang, L. Wu, X. Luo, K. Ren

Table 1: Results of library instance recovery.

App Set
Containers
Real-world apps

Precision Recall
0.998
0.998

0.991
0.977

# Library Uses
9994
501

# TP
9978
500

Table 2: Results of library version detection. Suppose the de-
tected version set is ùëÜùëë and the correct version is ùë£, C, S, I,
refers to Correct (ùëÜùëë = {ùë£ }), Sound ({ùë£ } ‚äÇ ùëÜùëë ), and Incorrect
(ùë£ ‚àâ ùëÜùëë ).

App Set

# Total

After Class-level

After Code-level

C(%)

S(%)

I(%) C(%)

S(%)

I(%)

Containers

9247

Real-world apps

461

38.8

43.4

60.6

54.4

0.5

2.2

73.6

70.5

25.2

23.4

1.3

6.1

can limit the candidate versions to 5 (‚â§ 5), and 96.5% (5470/5668)
of code-level profiles can achieve the same result.

In most cases, profiles distinguish between libraries well, except
for three cases. We inspect their binaries and list the reasons below.
‚Ä¢ WechatOpenSDK v1.8.6 and TMWechatOpenSDK v0.0.1, v0.0.2. We
find their binaries are consistent by diffing them. According to the
latter‚Äôs self-description on CocoaPods, it is an encapsulation of
the former library; and according to the profile signatures, we can
infer that the two TMWechatOpenSDK versions encapsulated
WechatOpenSDK v1.8.6 exactly.

‚Ä¢ AMapLocation and AMapLocation-NO-IDFA. Although we can
infer that there must be a difference between them according to
names, binaries of the same version of the two libraries are con-
sistent. They are different because they rely on different libraries,
the former integrates AMapFoundation while the latter includes
AMapFoundation-NO-IDFA.

‚Ä¢ Google-Mobile-Ads-SDK and GoogleMobileAds. The latter is dep-
recated in favor of the former. The latter stop release since v7.8.0,
but the former has been released for some time before v7.8.0.
During the period of joint release, the libraries of their corre-
sponding versions may be highly similar, at least the v7.7.1 of
the two libraries are consistent at the binary-level.
Taking both the general update content and the profile struc-
ture into consideration, our profiles cannot distinguish between
versions when the updates all located in the following regions: 1)
files without valid codes, such as README, comments, resources,
test codes, etc.; 2) valid code region but beyond our profiles, such
as variables, C/C++ functions, swift methods, NSConcrete*Blocks;
3) and changes related to control flow in Objective-C methods.

Answer to RQ1: Except for a few exceptions, the extracted
profiles distinguish between different libraries well, even at the
class-level. Regarding the discernibility between versions, 87.9%
of class-level profiles can limit the candidate versions to 5 (‚â§ 5),
and 96.5% of code-level profiles can achieve the same result.

Figure 7: The uniqueness of library profiles. Versions in a
group have the same profiles.

2) Specify the target library‚Äôs name and version in a Podfile. Co-
coaPods will first analyze its dependency graph, and then inte-
grate all of them into the Container app. Meanwhile, a tracking
file (the Podfile.lock) will be generated to record the dependency
graph between libraries as well as each installed library‚Äôs name
and version.

3) Use the Xcode toolchain to build the Container project.
4) Dump library data and clean the Container project. For each
library version, we collect three items: binaries of the target library
(the released original binaries or the compiled static library), the
Container app, and the Podfile.lock file. We will use them in later
tasks.
In total, we collect 319 unique libraries, with 5,768 versions.

4.1.2 Benchmark. As aforementioned, when an app integrates
third-party libraries through CocoaPods, the CocoaPods will gen-
erate a Podfile.lock file to record all details of this integration, in-
cluding each library‚Äôs name and version. Therefore, we collect apps
that carry Podfile.lock files to build the benchmark for testing.

The whole benchmark consists of two app sets. The first is con-
tainer apps obtained during library collection. As a side product
of library collection, each container app includes a target library
and its dependency libraries (if any). The second is real-world apps
selected from the open-source-ios-apps project [15], since we can
only obtain Podfile.lock files from open-source repositories. This set
contains 39 real-world iOS apps with 501 valid library integrations
through CocoaPods.

4.2 RQ1: Profile Uniqueness
Among the 5,768 versions of 319 libraries, we find 100 library ver-
sions whose profile is empty. Most of them carry no code snippets
and provide functions by integrating dependency libraries; the oth-
ers contain valid code regions, but our extraction process failed due
to their unexpected code organizations. As a result, we have 5,668
versions of 318 libraries to support the uniqueness evaluation.

To facilitate the evaluation, we calculate two signatures for each
profile. One is calculated based on its class-level content, and the
other on the code-level. We group all those 5,668 profiles by their
signatures so that each group contains profiles with the same class-
level or code-level signature. The grouping results are presented in
Figure 7. When an app integrates any library version inside a group,
iLibScope will identify the whole group as candidate versions.
According to Figure 7, 87.9% (4985/5668) of our class-level profiles

8

iLibScope: Reliable Third-Party Library Detection for iOS Mobile Apps

Conference‚Äô17, July 2017, Washington, DC, USA

4.3 RQ2: Library Instance Recovery and

Version Detection

To evaluate our approach, we first labeled 9, 994 library uses in
5,768 container apps and 501 in 39 real-world apps. Each library use
has a record in its corresponding Podfile.lock file. Besides, we can
find proofs of this integration, such as a partially matched class, to
ensure the library use is genuine and detectable. Then, we applied
iLibScope to recover library instances from apps. We denote a
recovered instance as a ùëá ùëÉ (true positive) if we have labeled it, an
ùêπ ùëÉ (false positive) if not. All library uses that iLibScope missed are
denoted as ùêπ ùëÅ s (false negatives). Next, we conducted a class-level
version detection for each ùëá ùëÉ whose correct version (ùëâùëê ) we have
collected. To facilitate evaluation, we mark a detection result (a
version set) as ùëêùëúùëüùëüùëíùëêùë° if it contains ùëâùëê only, ùë†ùëúùë¢ùëõùëë if it contains more
than ùëâùëê and ùëñùëõùëêùëúùëüùëüùëíùëêùë° if it does not include ùëâùëê . Last, we conducted
code-level version detection for each ùëá ùëÉ whose class-level output is
ùë†ùëúùë¢ùëõùëë. Notably, we accept the case a WechatOpenSDK v1.8.6 library
use was detected as a TMWechatOpenSDK v0.0.1 since they have
identical profiles (see Section 4.2).

We present the results of instance recovery and version detection
in Table 1 and Table 2 respectively. According to Table 1, iLibScope
achieves a good precision and recall in library recovery for both the
two datasets. A precision of 99.1% and a recall of 99.8% indicate that
iLibScope rarely moves classes from real candidates to spurious
ones, and our transfer strategy is effective. While for real-world
apps, the recall remains 99.8%, but the precision drops to 97.7%. We
inspected the failed cases and speculate that the majority is due
to copy-paste integrations or unacquainted integrations. It is hard
to distinguish whether the app includes a partial library that we
have collected or an uncollected library that overlaps with some
collected ones. In any case, this is the best result we can give based
on the current database.

The accuracy of version detection is reasonable when consider-
ing the inherent uniqueness of library profiles. In addition to the
reason that library profiles are not sufficient to distinguish between
versions, the reason for those ùë†ùëúùë¢ùëõùëë results may also be partial
inclusions, and the included part is consistent between the out-
put versions. Besides, there is a sharp increase of ùëñùëõùëêùëúùëüùëüùëíùëêùë° results
for real-world apps. By inspecting those ùëñùëõùëêùëúùëüùëüùëíùëêùë° cases, we found
that most of them have been customized before integration, which
interferes with the version detection process.

Next, we discuss some reasons why iLibScope cannot work as
expected. We inspected the ùëñùëõùëêùëúùëüùëüùëíùëêùë° version detection results at
code-level and found most of them are due to compilation or decom-
pilation diversity. Thus, we mainly analyze the reasons for mistakes
in class-level phases, including recovering library instances and
detecting versions at class-level.
‚Ä¢ The app integrates an uncollected library ùê¥, and we collected a
library ùêµ that overlaps with it. If the app does not integrate ùêµ,
there will be an FP (we identify out ùêµ); if the app integrates ùêµ
but not all versions of ùêµ overlap with ùê¥, then there could be a
ùëñùëõùëêùëúùëüùëüùëíùëêùë° result in version detection for ùêµ since we regard the
ùê¥ code as part of the recovered ùêµ instance. A similar case is we
did not collect a library in its entirety. Some libraries may have
sub-modules or extensions but require additionally specify them

in the Podfile to integrate them. We may collect only the modules
installed by default when collecting a library.

‚Ä¢ We do not generate a complete profile for some library versions.
According to Section 3.2, we filter class metadata by exported
symbols of library binaries. If version ùëé‚Äôs symbols are partially
stripped while ùëè keeps them all, then we get a broken profile for
ùëé and a complete for ùëè. When an app integrates ùëé, we identify it
as ùëè since the recovered library instance is more similar to ùëè.
‚Ä¢ Compilation diversity. The diversity occurs in dealing with cate-
gories (see Section 3.2). The compiler may merge the contents of
multiple categories of the same class into one category during
linkage. However, moving the content in ùê∂ùëéùë°ùëé to ùê∂ùëéùë°ùëè will make
ùê∂ùëéùë°ùëé seem to disappear in the binary, and ùê∂ùëéùë°ùëè to contain more
methods. Since this difference not only occurs between apps
and libraries but also between collected versions, it can affect
deciding the provenance of an app class, as well as judging the
version of a recovered library instance.

Answer to RQ2: From the evaluation results of library instance
recovery and version detection, iLibScope handles the code du-
plication well. It achieves a recall exceeds 99%, and a precision
exceeds 97% in library instance recovery. The version detection
result is also reasonable according to the intrinsic uniqueness of
library profiles.

4.4 RQ3: Vulnerable Library Detection
To demonstrate potential usages, we apply iLibScope to detect vul-
nerable libraries in iOS apps. We select three Objective-C libraries as
targets, AFNetworking, SSZipArchive, and GCDWebServer. These
three libraries all have had defective versions and then patched
them. Specifically, the v2.5.1 and v2.5.2 of AFNetworking are at
risk of man-in-the-middle (MITM) attack [6, 19], and the last two
libraries are suffering from a directory traversal vulnerability in
some early versions [18] [7, 17]. For each library, we have collected
both the vulnerable and safe versions.

We tested 4, 249 real-world apps in total and obtained a result as
shown in Table 3 (only class-level version detection was applied). A
detected library was marked as ùë£ùë¢ùëôùëõùëíùëüùëéùëèùëôùëí if the detected version
range contains vulnerable versions only, ùë†ùëéùëì ùëí if it contains safe
versions only, and ùëüùëñùë†ùëòùë¶ if both vulnerable and safe versions are
covered. Regarding the ùëüùëñùë†ùëòùë¶ results, there are mainly two reasons.
First, the recovered library instance is a partial library, and the recov-
ered part is consistent among a broad range of versions‚Äîincluding
the vulnerable ones and the safe ones. Second, the recovered li-
brary instance is a complete library, but the class-level profiles of
vulnerable versions are consistent with some nearby safe ones.

Since we conducted class-level version detection only, it takes
seconds to finish testing an app, which proves our tool is adaptive
for extensive testing. Besides, in addition to those three libraries,
we can combine iLibScope with some dependency-check tools to
check whether the target app contains publicly disclosed vulnera-
bilities. For example, the CocoaPods Analyzer under the OWASP
Dependency-Check project takes a Podfile.lock file as input and
check the security of library dependencies contained in it [8, 16].
With iLibScope, we can reconstruct the Podfile.lock file for an app

9

Conference‚Äô17, July 2017, Washington, DC, USA

J. Guo, M. Zheng, Y. Zhou, H. Wang, L. Wu, X. Luo, K. Ren

Table 3: The results of vulnerable library detection in 4,249
apps.

Library

Vulnerable versions

Detected libraries in apps
safe3
vulnerable1 risky2
1446
88
11

AFNetworking
SSZipArchive
GCDWebServer

8
79
62
1 The output version range contains vulnerable versions only.
2 The output version range contains both vulnerable and safe versions.
3 The output version range contains safe versions only.

2.5.1, 2.5.2
‚â§ 2.1.3
‚â§ 3.5.1

20
324
61

based on the detection result and feed it to the analyzer. Although
this analyzer is considered experimental for the moment, there is
an application prospect.

Answer to RQ3: Our tool can quickly identify third-party
libraries included in apps and give its version range. Combining
the answers of RQ1 and RQ2, the auxiliary ability and practi-
cality in security tasks are promising.

5 DISCUSSION
The first limitation of our method is that we use version information
to deal with code duplication, which in turn places high demands
on the library collection. In theory, the more libraries and library
versions we collect, the more accurate our method is. That‚Äôs because
when judging the provenance of code through compatibility, a large
number of compatible cases are required as prior knowledge. This
also provides us with another idea. We can judge the compatibility
between a code fragment and a library through machine learning
once we have an exhaustive database.

The second limitation is the profile content. As presented in the
evaluation part there is still room for improvement in the soundness
of profiles. Our future interest mainly lies in two aspects. The first
is the diversity of iOS third-party libraries. Except for Objective-C,
there are also Swift and C/C++ developed libraries. The second is
supplementing Block [10] into code features, which is a critical
structure to achieve GCD in iOS and takes a considerable portion
in the __text section. The version updates may occur in the Blocks.
The challenge is a Block exists as an anonymous function in binaries,
it has to be associated with non-anonymous functions to identify
its identity.

Third, we want to discuss the transfer strategy, although in most
cases it works well in the light of evaluation. First of all, according
to assumption 1, library candidates with more classes have priority
to match against floating classes. However, when the classes in it
are weak in version distinguishment, a wrong floating class can
pass the compatibility test easily. The second is the granularity of
processing floating classes. In the first round, the processing unit is
class; while in the second round, the unit is the class group. A single
class may contain too little information thus results in a broad ùëâùëù ,
while a class group may be too large since the provenance of classes
in it can be different theoretically. It will be better if we can first
group floating classes inside a node into several small clusters by
their internal compatibility.

10

6 RELATED WORK
6.1 Third-Party Library Identification
Although detecting third-party libraries has been a common task
in security research on iOS apps [25, 29, 32, 41, 43], there are rare
systematic studies targeting detecting iOS third-party libraries. As
the only one, CRiOS [39] excavates third-party classes from a mas-
sive app set and group them into clusters (libraries). CRiOS first
group classes by class name prefix, which is a weak alternative to
namespaces in iOS development, then merge these clusters by class
cohesion. Due to the intra-library relationships, the second step
can make the obtained library cluster contains classes from more
than one library.

As another major mobile operating system, third-party library
detection techniques targeting the Android platform continue to
emerge [21, 22, 24, 27, 30, 31, 34, 35, 37, 38, 42, 44‚Äì46]. Not only
for the market demand but also for the resilience to the growing
obfuscation techniques. However, due to the inherent differences
between platforms, these methods are not well applicable to iOS.
Another line is identifying third-party packages in binaries [28,
33, 40], mainly targeting binaries developed by C/C++. These meth-
ods extract string literals from binaries to characterize a package
and conduct detection based on a large-scale database. However,
this will result in huge duplicated features due to the string con-
stants repeated in multiple libraries. Meanwhile, since code dupli-
cation is a common issue in open source projects [36], they face
the same code duplication challenge. To address this challenge,
OSSPolice [28] utilizes the structurally rich tree-like layout of OSS
sources to deal with internal code clones (i.e., nested third-party
OSS clones). However, we do not assume a library is organized as
expected, and the duplicated code is in a typical nested relationship
with master libraries. On the other hand, LibDX [40] categorizes
the code clone into parent-child nodes and library variants but
misses the case that libraries sharing code snippets but outside
the two relationships. Besides, it does not collect multiple versions
for a single library, thus faces a less complicated code duplication
problem as us.

6.2 Security of iOS third-party libraries
iOS third-party libraries play a critical role in many iOS security
studies. During the research of privacy leakage in iOS apps, Egele
et al. [29] found 55% of tested apps include either advertisement
or tracking libraries. Moreover, all these libraries triggered PiOS‚Äô
privacy leak detection since they transmit the unique device ID to
third parties. By the time of Chen et al. [25]‚Äôs research on PhaLibs,
there was still no available techniques to recover libraries in iOS
apps, and also no available public anti-virus (AV) systems to analyze
iOS third-party libraries. They utilize the associations between iOS
libraries and their counterparts of the Android platform to find and
analyze iOS PhaLibs. As a result, they found that most Android-side
harmful behaviors were preserved on their iOS counterparts. In a
recent work of vetting and analyzing network services of iOS apps,
Tang et al. [41] identified the third-party network service libraries
from apps based on a call stack similarity analysis and found that the
use of certain third-party libraries listening for remote connections
is a common source of vulnerable network services.

iLibScope: Reliable Third-Party Library Detection for iOS Mobile Apps

Conference‚Äô17, July 2017, Washington, DC, USA

7 CONCLUSION
In this paper, we work towards the detection of third-party libraries
in iOS apps. We propose and implement a system with two-level pro-
files to detect the existence of libraries and their versions (or range
of versions.) We solve the challenge of code duplication between
libraries and implement a prototype system. The evaluation result
shows the accuracy of our system and practical usage scenarios.

REFERENCES
[1] [n.d.]. App Store Review Guidelines - Apple Developer. https://developer.apple.

com/app-store/review/guidelines/. (Accessed on 07/02/2020).

[2] [n.d.]. CocoaPods/Specs: The CocoaPods Master Repo. https://github.com/

CocoaPods/Specs. (Accessed on 06/30/2020).

[3] [n.d.]. Code Quality and Build Settings for iOS Apps - Mobile Security Test-
ing Guide. https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-
testing-guide/0x06i-testing-code-quality-and-build-settings.
(Accessed on
10/12/2020).

[4] [n.d.]. Conventions. https://developer.apple.com/library/archive/documentation/
Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.
html. (Accessed on 06/24/2020).

[5] [n.d.]. Customizing Existing Classes. https://developer.apple.com/library/
archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/
CustomizingExistingClasses/CustomizingExistingClasses.html.
08/28/2020).

(Accessed on

[6] [n.d.]. CVE - CVE-2015-3996. https://cve.mitre.org/cgi-bin/cvename.cgi?name=

CVE-2015-3996. (Accessed on 07/09/2020).

[7] [n.d.]. CVE - CVE-2019-14924. https://cve.mitre.org/cgi-bin/cvename.cgi?name=

CVE-2019-14924. (Accessed on 07/09/2020).

[8] [n.d.]. dependency-check ‚Äì CocoaPods Analyzer. https://jeremylong.github.io/
DependencyCheck/analyzers/cocoapods.html. (Accessed on 10/12/2020).
[9] [n.d.]. IDA Pro ‚Äì Hex Rays. https://www.hex-rays.com/products/ida/. (Accessed

on 06/24/2020).

[10] [n.d.]. Introduction. https://developer.apple.com/library/archive/documentation/
(Accessed on

Cocoa/Conceptual/Blocks/Articles/00_Introduction.html.
08/29/2020).

[11] [n.d.]. llvm-nm - list LLVM bitcode and object file‚Äôs symbol table ‚Äî LLVM 12
documentation. https://llvm.org/docs/CommandGuide/llvm-nm.html. (Accessed
on 08/28/2020).

[12] [n.d.]. nygard/class-dump: Generate Objective-C headers from Mach-O files.

https://github.com/nygard/class-dump. (Accessed on 06/24/2020).

[13] [n.d.]. objc_msgSend | Apple Developer Documentation. https://developer.
apple.com/documentation/objectivec/1456712-objc_msgsend?language=occ. (Ac-
cessed on 07/24/2020).

[14] [n.d.].

Objects, Classes, and Messaging.

https://developer.apple.com/

library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/
ocObjectsClasses.html. (Accessed on 07/24/2020).

[15] [n.d.]. open-source-ios-apps/APPSTORE.md at master ¬∑ dkhamsing/open-source-
ios-apps. https://github.com/dkhamsing/open-source-ios-apps/blob/master/
APPSTORE.md. (Accessed on 04/30/2020).

[16] [n.d.]. OWASP Dependency-Check Project | OWASP. https://owasp.org/www-

project-dependency-check/. (Accessed on 10/12/2020).

[17] [n.d.]. Release 3.5.1 ¬∑ swisspol/GCDWebServer. https://github.com/swisspol/

GCDWebServer/releases/tag/3.5.1. (Accessed on 07/09/2020).

[18] [n.d.]. Release v2.1.3 ¬∑ ZipArchive/ZipArchive. https://github.com/ZipArchive/

ZipArchive/releases/tag/v2.1.3. (Accessed on 07/09/2020).

[19] [n.d.].

A response to recent concerns about security vulnerabilities
https://gist.github.com/AlamofireSoftwareFoundation/

in AFNetworking.
f784f18f949b95ab733a. (Accessed on 07/09/2020).

[20] [n.d.]. Xcode 12 - Apple Developer. https://developer.apple.com/xcode/. (Accessed

on 10/17/2020).

[21] Michael Backes, Sven Bugiel, and Erik Derr. 2016. Reliable third-party library
detection in android and its security applications. In Proceedings of the 2016 ACM
SIGSAC Conference on Computer and Communications Security. 356‚Äì367.
[22] Theodore Book, Adam Pridgen, and Dan S Wallach. 2013. Longitudinal analysis
of android ad library permissions. arXiv preprint arXiv:1303.0857 (2013).
[23] Carthage. 06/23/20. Carthage. Website. https://github.com/Carthage/Carthage.
[24] Kai Chen, Peng Liu, and Yingjun Zhang. 2014. Achieving accuracy and scal-
ability simultaneously in detecting application clones on android markets. In
Proceedings of the 36th International Conference on Software Engineering. 175‚Äì
186.

[25] Kai Chen, Xueqiang Wang, Yi Chen, Peng Wang, Yeonjoon Lee, XiaoFeng Wang,
Bin Ma, Aohui Wang, Yingjun Zhang, and Wei Zou. 2016. Following devil‚Äôs
footprints: Cross-platform analysis of potentially harmful libraries on android
and ios. In 2016 IEEE Symposium on Security and Privacy (SP). IEEE, 357‚Äì376.

11

[26] CocoaPods. 2020. CocoaPods. Website. https://cocoapods.org/.
[27] Jonathan Crussell, Clint Gibler, and Hao Chen. 2014. Andarwin: Scalable detection
of android application clones based on semantics. IEEE Transactions on Mobile
Computing 14, 10 (2014), 2007‚Äì2019.

[28] Ruian Duan, Ashish Bijlani, Meng Xu, Taesoo Kim, and Wenke Lee. 2017.
Identifying open-source license violation and 1-day security risk at large
scale. In Proceedings of the 2017 ACM SIGSAC Conference on computer and
communications security. 2169‚Äì2185.

[29] Manuel Egele, Christopher Kruegel, Engin Kirda, and Giovanni Vigna. 2011. PiOS:

Detecting Privacy Leaks in iOS Applications.. In NDSS. 177‚Äì183.

[30] Leonid Glanz, Sven Amann, Michael Eichberg, Michael Reif, Ben Hermann, Jo-
hannes Lerch, and Mira Mezini. 2017. CodeMatch: obfuscation won‚Äôt conceal your
repackaged app. In Proceedings of the 2017 11th Joint Meeting on Foundations
of Software Engineering. 638‚Äì648.

[31] Michael C Grace, Wu Zhou, Xuxian Jiang, and Ahmad-Reza Sadeghi. 2012. Unsafe
exposure analysis of mobile in-app advertisements. In Proceedings of the fifth
ACM conference on Security and Privacy in Wireless and Mobile Networks. 101‚Äì
112.

[32] Jin Han, Qiang Yan, Debin Gao, Jianying Zhou, and Huijie Robert DENG. 2014.

Android or ios for better privacy protection? (2014).

[33] Armijn Hemel, Karl Trygve Kalleberg, Rob Vermaas, and Eelco Dolstra. 2011.
Finding software license violations through binary code clone detection. In
Proceedings of the 8th Working Conference on Mining Software Repositories.
63‚Äì72.

[34] Menghao Li, Wei Wang, Pei Wang, Shuai Wang, Dinghao Wu, Jian Liu, Rui Xue,
and Wei Huo. 2017. LibD: scalable and precise third-party library detection in
android markets. In 2017 IEEE/ACM 39th International Conference on Software
Engineering (ICSE). IEEE, 335‚Äì346.

[35] Bin Liu, Bin Liu, Hongxia Jin, and Ramesh Govindan. 2015. Efficient privilege
de-escalation for ad libraries in mobile apps. In Proceedings of the 13th annual
international conference on mobile systems, applications, and services. 89‚Äì103.
[36] Cristina V Lopes, Petr Maj, Pedro Martins, Vaibhav Saini, Di Yang, Jakub Zitny,
Hitesh Sajnani, and Jan Vitek. 2017. D√©j√†Vu: a map of code duplicates on GitHub.
Proceedings of the ACM on Programming Languages 1, OOPSLA (2017), 1‚Äì28.
[37] Ziang Ma, Haoyu Wang, Yao Guo, and Xiangqun Chen. 2016. LibRadar: fast and
accurate detection of third-party libraries in Android apps. In Proceedings of the
38th international conference on software engineering companion. 653‚Äì656.
[38] Annamalai Narayanan, Lihui Chen, and Chee Keong Chan. 2014. Addetect:
Automated detection of android ad libraries using semantic analysis. In 2014
IEEE Ninth International Conference on Intelligent Sensors, Sensor Networks
and Information Processing (ISSNIP). IEEE, 1‚Äì6.

[39] Damilola Orikogbo, Matthias B√ºchler, and Manuel Egele. 2016. CRiOS: Toward
large-scale iOS application analysis. In Proceedings of the 6th Workshop on
Security and Privacy in Smartphones and Mobile Devices. 33‚Äì42.

[40] Wei Tang, Ping Luo, Jialiang Fu, and Dan Zhang. 2020. LibDX: A Cross-
Platform and Accurate System to Detect Third-Party Libraries in Binary Code. In
2020 IEEE 27th International Conference on Software Analysis, Evolution and
Reengineering (SANER). IEEE, 104‚Äì115.

[41] Zhushou Tang, Ke Tang1 Minhui Xue2 Yuan Tian, Sen Chen4 Muhammad
iOS, Your OS, Everybody‚Äôs OS:

Ikram5 Tielei Wang, and Haojin Zhu. [n.d.].
Vetting and Analyzing Network Services of iOS Applications. ([n. d.]).

[42] Haoyu Wang, Yao Guo, Ziang Ma, and Xiangqun Chen. 2015. Wukong: A scalable
and accurate two-phase approach to android app clone detection. In Proceedings
of the 2015 International Symposium on Software Testing and Analysis. 71‚Äì82.
[43] Pei Wang, Qinkun Bao, Li Wang, Shuai Wang, Zhaofeng Chen, Tao Wei, and
Dinghao Wu. 2018. Software protection on the go: A large-scale empirical study
on mobile app obfuscation. In 2018 IEEE/ACM 40th International Conference on
Software Engineering (ICSE). IEEE, 26‚Äì36.

[44] Yan Wang, Haowei Wu, Hailong Zhang, and Atanas Rountev. 2018. Orlis:
Obfuscation-resilient
In 2018 IEEE/ACM
library detection for Android.
5th International Conference on Mobile Software Engineering and Systems
(MOBILESoft). IEEE, 13‚Äì23.

[45] Jiexin Zhang, Alastair R Beresford, and Stephan A Kollmann. 2019. LibID: reliable
identification of obfuscated third-party Android libraries. In Proceedings of the
28th ACM SIGSOFT International Symposium on Software Testing and Analysis.
55‚Äì65.

[46] Yuan Zhang, Jiarun Dai, Xiaohan Zhang, Sirong Huang, Zhemin Yang, Min Yang,
and Hao Chen. 2018. Detecting third-party libraries in Android applications
with high precision and recall. In 2018 IEEE 25th International Conference on
Software Analysis, Evolution and Reengineering (SANER). IEEE, 141‚Äì152.

