2
2
0
2

p
e
S
5
1

]
E
S
.
s
c
[

1
v
5
6
3
7
0
.
9
0
2
2
:
v
i
X
r
a

Do Cloud Developers Prefer CLIs or Web Consoles?

CLIs Mostly, Though It Varies by Task

CORA COLEMAN, University of California, San Diego, USA
WILLIAM G. GRISWOLD, University of California, San Diego, USA
NICK MITCHELL, IBM T.J. Watson Research Center, USA

Despite the increased importance of Cloud tooling, and many large-scale studies of Cloud users, research has yet to answer what tool

modalities (e.g. CLI or web console) developers prefer. In formulating our studies, we quickly found that preference varies heavily based

on the programming task at hand. To address this gap, we conducted a two-part research study that quantifies modality preference as a

function of programming task. Part one surveys how preference for three tool modalities (CLI, IDE, web console) varies across three

classes of task (CRUD, debugging, monitoring). The survey shows, among 60 respondents, developers most prefer the CLI modality,

especially for CRUD tasks. Monitoring tasks are the exception for which developers prefer the web console. Part two observes how

four participants complete a task using the kubectl CLI and the OpenShift web console. All four participants prefer using the CLI to

accomplish the task.

Additional Key Words and Phrases: Cloud development, CLI, IDE, web console, Kubernetes, tool modality

1 INTRODUCTION

Developing for the Cloud can be arduous[3, 11]. The set of APIs is large and constantly changing. The Cloud is inherently

asynchronous and distributed. Tools can help, but are often presented as rigidly separated modalities. These tools

employ either low-level and flexible conversational interfaces, or high-level and limited direct-manipulation interfaces

[21, 23]. This rigid separation can harm productivity, requiring one either to cope with low-level tools, dance around

the limitations of the high-level tools, or pay the cognitive burden of frequent context switches between the two [1, 26].

This paper aims to foster constructive dialog around better tools and to understand the important reasons and

contextual factors that motivate developer tool preference [6]. Cloud tools run the gamut of modalities. Every major

Cloud provider offers command line interfaces (CLIs), Integrated Development Environment (IDE) plugins, and browser-

based (web) consoles [3]. These tools belong to categories of modalities that drive different user interactions. Industry

developers are on-boarded to use a certain set of Cloud technologies and tools, however research has yet to answer

what modalities of tools developers prefer to use.

The goal of all of these tools is help to developers interface with a set of Cloud APIs. This paper focuses on one

popular family of APIs known as Kubernetes. The Kubernetes framework is an open-source system for automating the

deployment, scaling, and management of containerized applications [14]. When using Kubernetes, Cloud developers

must choose a development tool to support their “inner loop”, i.e. coding, deployment of prototypes, and debugging

any problems that arise. Cloud-based environments support these development tasks and also offer access to APIs,
microservices, and DevOps [31]. Commonly used Kubernetes development tools include the kubectl CLI [22], the
VSCode IDE [8], and a variety of web consoles (such as the Kubernetes Dashboard or the OpenShift Console) [2, 9].

There are few research studies on developer tools and tools for novices that examine tool preference in the context of

the types of programming tasks that developers commonly iterate on or within the user population of Cloud developers

Authors’ addresses: Cora Coleman, ccoleman@eng.ucsd.edu, University of California, San Diego, 9500 Gilman Drive, La Jolla, California, USA, 92093;
William G. Griswold, wgg@eng.ucsd.edu, University of California, San Diego, 9500 Gilman Drive, La Jolla, California, USA, 92093; Nick Mitchell,
nickm@us.ibm.com, IBM T.J. Watson Research Center, 1101 Kitchawan Road, Yorktown Heights, New York, USA, 10598.

1

 
 
 
 
 
 
2

Cora Coleman, William G. Griswold, and Nick Mitchell

[1, 36]. This paper contributes to filling this research gap with two user studies. First, it presents survey findings from

60 Cloud developers. The survey allows us to pivot our analysis along three categorical dimensions:

(1) Task being performed: CRUD, debugging, monitoring.

(2) Modality of tool used: CLI, IDE, web console.

(3) Expertise in Kubernetes: beginner through advanced.

In discussions with industrial designers, the implicit (and largely informal) assumption seems to be that beginners

will always prefer web consoles, and experts will prefer CLIs [7]. In the studies presented in this paper, we have found

that this is not the case, that modality preference is not primarily a function of one’s level of expertise. Rather, this paper

shows that a primary factor influencing preference is the task being performed [1, 36]. Furthermore, the frequency and

types of tasks of Cloud developers is not answered in prior research. We have found that multiple types of tasks are

performed each day, supporting prior research that developers are often interrupted and start one task and move on to

another before finishing the first, known as multitasking or interruption [1, 19, 34].

Our survey of Cloud developers shows that, regardless of their level of experience, developers prefer the CLI. The

exception for which developers prefer a different tool modality was found to be a web console for monitoring tasks. To

dig deeper and uncover the reasons that motivate developer preferences, we observed developers using different tool

modalities to complete a programming task. The second contribution of the paper presents findings from a comparative

user study of four participants that each completed a task using the kubectl CLI and the OpenShift web console. The

observational study corroborates the findings from the survey in that all four participants preferred to use the CLI

when performing a task.

2 AN EXAMPLE CLOUD DEVELOPER SCENARIO

A Cloud developer’s day typically involves multiplexing their time between several categories of tasks: CRUD1,
debugging, and monitoring. Cloud applications are complex enough, with multi-process distribution and scale to the

point that blurs the classical lines between development and operations. Developing with this complexity can no longer

be done in silos [37]. Thus, it is important to capture this cross-task nature when evaluating tool preference.

To further illustrate the challenges that exist in Cloud development, consider the following scenario that involves a

simple monitoring task. This scenario is one based on the results presented later in this paper, and typical of a daily

driving experience in Cloud development:

Star is an experienced Java developer with less than one month of experience developing for the Cloud and considers

herself a beginner. Star learned the basics by referencing tutorials in blog posts, and by browsing platform documentation

such as is available on the Kubernetes web site (kubernetes.io). This documentation is focused on teaching by rote: it

gives examples of CLI commands that users can copy and paste into their terminal in order to accomplish common

tasks. In this way, she learned how to start a development cluster on her laptop, and then how to deploy and manage
applications through use of the kubectl CLI. See Figure 1a for an example of this CLI experience.

Many times each day, Star needs to update her deployed application with her latest changes (a CRUD task). She may

need to inspect the logs, if the update causes the application to misbehave (a debugging task). Threaded through each of

these tasks, she will routinely be checking the status of her deployed resources. For example, after pushing an update,

she may need to wait for the resources to be "green", meaning that the deployment is complete, and the distributed

1CRUD: Create Read Update Delete, i.e. tasks that inspect or modify an application resource.

Do Cloud Developers Prefer CLIs or Web Consoles?

3

(a) The kubectl CLI uses a conversational interface. It al-
lows copy/paste of commands. Switching between tasks can
leverage custom scripts and command history navigation.

(b) The OpenShift console uses a direct-manipulation interface. It
requires clicks to perform navigation, and is presented as a series
of modal pages. This view shows the details page for a Deployment
resource. Switching between views often requires multiple clicks.

Fig. 1. Using two Cloud tools to list and view the details of Deployment resources in a Kubernetes cluster.

set of application resources are responsive to pings. Or, if there is a problem, she may need to identify which of the

resources are "red". These are monitoring tasks.

Let us focus on a monitoring task. Star has just deployed an update, and needs to wait for them to be ready. Using

the CLI, Star issues a command to query the status of her Deployment resource; this Kubernetes resource type roughly
corresponds to an application. She repeats this command until she sees that the resources are ready. 2 Figure 2 shows a
screenshot of such a session.

Star notices that another developer on her team uses the OpenShift (OS) web console for monitoring application

progress and that it provides a clear visualization throughout the application creation process; see Figure 1b. Star

decides to use both the kubectl CLI and the OS web console to create and monitor her applications, respectively. Star

finds that while OS is great for monitoring, it can be cumbersome to switch contexts between the CLI and web console.

For example, the user interactions are completely different in each interface. Star must switch between the keyboard

and the mouse instead of sticking to one input method to navigate through the CLI commands and console menus.

The main takeaways from this example are that conversational and direct-manipulation interfaces found in CLIs and

web consoles, respectively, help developers to accomplish different types of tasks. Additionally, developers often work

on multiple types of tasks each day and look to optimize their performance by using tools with modalities that suit

the task at hand. This can lead to cognitive burden from context switching between different programming tasks and

2You may be surprised that Star is manually repeating the command, rather than using the watch capability of the kubectl CLI. None of our comparative
user study participants employed this feature.

4

Cora Coleman, William G. Griswold, and Nick Mitchell

Fig. 2. Our participant "Star" uses the kubectl CLI. First she updates her application via kubectl apply, then polls via kubectl
get until it is ready — as indicated by the "READY 2/2" cell. Note from the AGE column how she waited 17 seconds.

development environments. Seems like a perfect candidate example for graphics, however we have found that this is

not always the case.

3 RELATED WORK

There have been few studies focused on understanding Cloud developer tooling perspectives in the context of the types

of programming tasks developers complete. The most relevant work in understanding how Cloud developers use tools

evaluates how developers complete common programming task types in an IDE [36]. Developer surveys such as the
CNCF 3 report on the increased usage of Cloud tooling and don’t clarify which tools developers prefer to use or the
types of programming tasks that developers are working on [27]. Other developer surveys from open source special

interest groups (SIGs) don’t ask about the programming task context in which the tool is used aside from what tools are

used for CI/CD [16].

3.1 Systems Administrators and Monitoring

Research in understanding developer tooling outside of the Cloud has focused on the user population of system

administrators, specifically for monitoring tasks such as intrusion detection [4, 30, 35]. Research on graphical and

textual tool modalities for intrusion detection have revealed some of the relative strengths and weaknesses of each and

led to recommendations for a hybrid tool [30]. The textual tool was found to allow users to better analyze data through

flexible and efficient commands while the graphical tool was found to better support the discovery of new attacks by

providing a system overview of the current state of the network.

3CNCF: Cloud Native Computing Foundation, an open-source consortium that manages many projects, including Kubernetes. https://www.cncf.io/

Do Cloud Developers Prefer CLIs or Web Consoles?

5

A field study of systems administrators revealed how automation and scripting are crucial to their work [4]. While

CLIs offer more support on this end than graphical user interfaces (GUIs), they do so with a higher learning curve, less

ease of use, and provide less insight to the system interactions. A survey of systems administrators identified that most

prefer GUIs over CLIs for managing firewalls [35]. The CLI’s most reported strength was its flexibility and efficiency

and the GUIs most reported strength was its usability.

3.2 Tool Modalities for Learning

Investigating software tools and specifically, CLIs and their accessibility have revealed some reasons for inefficiency that

are universally experienced, though with a steeper learning curve for novice programmers [18, 26, 29]. CLIs were found

to challenge users to remember strings of commands without context, issue terse commands with limited readability

for future comprehension, and reduce their editing space to a single statement prone to error [18]. The unstructured

nature of text within a CLI also makes them inefficient to use with screen readers [29]. While a lesser learning curve

has been observed with GUIs, transitioning to learning using a CLI resulted in more frustration and less success in

completing programming tasks than transitioning from learning using a CLI to a GUI [10, 32].

3.3 Hybrid Tool Modalities

Hybrid tools have been found to help with learning how to program by reducing cognitive load and leading to increased

programming success [32]. CLIs were improved to provide customized GUIs that combine the flexibility and efficiency

of commands with the usability and discoverability of graphics [33]. The customized GUI benefited novice programmers

by only exposing the most relevant subset of options required for their specific goal [33]. Similarly, transforming any

web page into an example-centric IDE eliminated the complexities that impede novice programmers in desktop-based

environments such as software installation and configuration, data file management, data parsing, and Unix-like

command-line interfaces [39].

CLIs were improved to provide customized GUIs that combine the flexibility and efficiency of commands with the

usability and discoverability of graphics [33]. The customized GUI benefited novice programmers by only exposing

the most relevant subset of options required for their specific goal. Similarly, transforming any web page into an

example-centric IDE eliminated the complexities that impede novice programmers in desktop-based environments such

as software installation and configuration, data file management, data parsing, and Unix-like command-line interfaces

[39].

4 METHODOLOGY

This paper evaluates the following research questions in a two-part study that includes a survey of 60 Cloud developers

and comparative user study with four Cloud research developers:

(1) How do different levels of Kubernetes experience (beginner, intermediate, and expert) impact developer tool

preferences?

(2) How does the type of programming task at hand (CRUD, debugging, and monitoring) impact developer tool

preferences?

(3) How does the tool modality (textual, graphical, and hybrid) impact developer tool preferences?

A Google Forms survey was used to collect 60 responses from within the IBM Hybrid Cloud research group and

Kubernetes open source special interest groups (SIGs). Participants indicated their level of experience with Kubernetes,

6

Cora Coleman, William G. Griswold, and Nick Mitchell

self-selecting from either beginner, intermediate, or expert. We also asked participants to indicate how frequently they

use Kubernetes, selecting from either many times each day, once a day, weekly, monthly or even more rarely, or never.

We then conducted a remotely moderated, within-subjects user study of four participants with an average of 20 years

of programming experience between them. All four user study participants belonged to the IBM Hybrid Cloud research

group and regularly used Kubernetes in their work.

Survey participants were recruited from within the IBM Hybrid Cloud research group and from Kubernetes Special

Interest Groups (SIGs) known as sig-cli and sig-usability. Furthermore, the survey link was publicly included in a post

on LinkedIn made by a sig-usability leader and on the GitHub readme file of an open source Kubernetes project, Kui.

The survey asked Kubernetes developers questions about their level of experience (beginner, intermediate, expert),

frequency of working on different programming task types (CRUD, debugging, monitoring), and preferred tool modality

for different programming task types (CLI, Web console, IDE).

The results of the developer survey were used to inform the design of the second part of our study, a comparative

user study to observe differences in how participants use the kubectl CLI and the OpenShift console to complete the

same programming task. We employed a classic “Think Aloud” user evaluation method in which participants were

asked to think aloud while completing the task and given a prompt to continue if they fell silent for more than 15

seconds [15, 17, 24]. Video and audio from the sessions were recorded using WebEx for later transcription and analysis.

Participants filled out a background survey to provide information about their programming experience, use of

Kubernetes, and familiarity with the two tools. Participants downloaded the kubectl CLI and the OpenShift Console onto

their machines and were given access to an OpenShift cluster to run Kubernetes. After completing the observational

study, participants filled out a follow up survey and ranked the tools based on their preference. In the follow up survey,

participants were also asked to rate the tools based on their perceived cognitive load using the NASA-TLX scale [20].

To give us a better understanding of preference, participants also rated the quality of each tool and were asked to

give reasons for why they either liked or did not like using each tool. Participants were also asked to share their

recommendations for how each tool could be improved.

During the study sessions, participants completed a task using the kubectl CLI and the OpenShift console. The goal
of the task was to create an application in a Kubernetes namespace 4, find the deployment pods that have the string
“magic key” in their logs, delete the application, and then delete the namespace. Participants were given a GitHub

repository with the application files and task instructions. No time limit was set to complete the task. If participants

got stuck while completing the task, hints specific to each tool interface were provided in hyperlinks below the task

instructions. The participants were randomly assigned such that half of them used the kubectl CLI first and the other

half used the OpenShift console first.

5 RESULTS

5.1 Part One: Developer Survey

A majority of survey respondents (53%) said that they have an expert level of experience with Kubernetes and even

more (80%) said that they use Kubernetes many times each day. In total, 32 respondents said that they have an expert

level of experience, 23 respondents said that they have an intermediate level of experience and five respondents (8%)

said that they have a beginner level of experience.

4A Kubernetes namespace can be used to isolate applications from each other.

Do Cloud Developers Prefer CLIs or Web Consoles?

7

(a) CRUD tasks are most frequently com-
pleted on a daily basis by intermedi-
ates and experts. No beginners indicated
that they complete CRUD tasks more fre-
quently than on a weekly basis.

(b) Debugging tasks are most frequently
completed on a weekly basis by beginners,
intermediates, and experts.

(c) Monitoring tasks are most frequently
completed on a daily basis by begin-
ners, intermediates, and experts. The same
amount of experts also said that they com-
plete monitoring tasks on a weekly basis.

Fig. 3. Task frequency from survey participants. The numbers inside each bar represent the fraction of all participants. The height of
each bar represents the fraction of that class of users.

5.1.1

Frequency of Tasks. 28 survey respondents (47%) said that they work on CRUD tasks many times each day, 19

(32%) said that they work on debugging tasks many times each day, and 17 (28%) said that they work on monitoring

tasks many times each day. 15 respondents (25%) said that they work on CRUD tasks weekly, 24 (40%) said that they

work on debugging tasks weekly, and 16 (27%) said that they work on monitoring tasks weekly. One respondent said

that they never worked on any of these programming task types, so the task types could have been better explained or

we could have included more task types. See Figure 3.

5.1.2 Tool Modality Preference Across Tasks. We asked survey participants what kind of tool (CLI, IDE, web console, or

other) they prefer to use when working on CRUD, debugging, and monitoring tasks. While a majority of participants

said that they prefer to use a CLI when working on CRUD (80%) and debugging (77%) tasks, a majority of participants

said that they preferred to use a web console to work on monitoring tasks (57%). See Figure 4.

Overall, we found that the most preferred tool for Kubernetes beginners performing CRUD, debugging, and monitoring

tasks is a CLI. Intermediate and expert Kubernetes developers prefer to use a CLI for CRUD and debugging tasks, and

a web console for monitoring tasks. One survey respondent said that they preferred to use a combination of a CLI

and web console for CRUD and the same for monitoring tasks. Two of the respondents said that they preferred this

combination for debugging tasks as well. Lists of the other tools mentioned in survey responses and the tasks for which

they are most frequently used can be seen in Table 1.

5.2 Part Two: Comparative User Study

The four participants of the comparative user study had an average of 20 years of programming experience and spend

on average 17 hours a week programming. The participants work in the IBM Hybrid Cloud research group as software

engineers.

8

Cora Coleman, William G. Griswold, and Nick Mitchell

(a) CLIs are preferred by the majority of
developers for CRUD tasks, regardless of
experience.

(b) CLIs are preferred by the majority of
developers for debugging tasks, regardless
of experience.

(c) Web consoles are preferred by the major-
ity of intermediate and expert developers,
while CLIs are preferred by a majority of
beginners for monitoring tasks.

Fig. 4. Modality preference from survey respondents. The numbers inside each bar represent the fraction of all participants. The
height of each bar represents the fraction of that class of users.

Table 1. When survey respondents answered "Other" for their tool preference, the selection of tools they specified also varied by task.

(a) "Other tool" for CRUD tasks.

(b) "Other tool" for debugging tasks.

(c) "Other tool" for monitoring tasks.

Participant response

Votes

Participant response

Votes

Participant response

Votes

CLI and scripts for testing,
setup, and verification
kubectl, Grafana, loki
Kui
Purpose built tools (e.g. trou-
bleshoot.sh)
CLI and web console
k9s

1

1
1
1

2
4

CLI and web console
CLI and scripts for testing,
setup, verification, and data
collection for analysis and
comparisons
Custom application monitor-
ing
kubectl, Grafana, loki
Kui
k9s

1
1

1

1
1
3

CLI and others (e.g. IDE, de-
pends on specific case)
CLI and web console
CLI, scripting, and automa-
tion
Console for browsing multi-
ple objects, CLI for applies
and deletes, or piping into
other tools
flux and GitHub
Helm charts
infra
kubectl, Grafana, and VS-
Code plugins
Kui
k9s

1

1
1

1

1
1
1
1

1
2

5.2.1

Frequency of and Reasons for Tool Modality Use. We asked participants how often they use a CLI when program-

ming. Two said often and two said always. When asked to list the CLI they most prefer, the most frequently mentioned

were kubectl (three of the four) and git (two of the four). Participants shared reasons for why they like or don’t like

using a CLI, as listed in Table 2a. We asked study participants how often they use an IDE when programming. Three

Do Cloud Developers Prefer CLIs or Web Consoles?

9

Table 2. Four user study participants (P1–P4) were asked to reflect on their reasons for preferring a tool modality.

(a) Reasons for CLI preference.

(b) Reasons for IDE preference.

(c) Reasons for web console preference.

Participant responses

Participant responses

Participant responses

Succinct, fast

P1
P2 Easier
P3 Can accelerate tasks but some-
times has limitations and re-
quire lot of customization and
configuring
It’s hard to remember all possi-
ble command/flag combination.
Overwhelming number of com-
mands

P4

P1 Code highlights,

integrated
project management features,
debugger
Fewer number of steps to write
and test code

P2

P3 Can accelerate tasks but some-
times has limitations and re-
quire lot of customization and
configuring
Focus on coding and do less
grinding work like code navi-
gation, compilation, etc.

P4

P1

P2

Sometimes it is quicker to use
CLI
Prefer the terminal for more
control

P3 Too limiting + leaky abstrac-

tions

P4 Not on par with local IDE in
term of features and perfor-
mance

said that they always use an IDE and one said that they sometimes use an IDE. All of the participants said Visual Studio

Code (VS Code) was their preferred IDE, with two additionally stating Eclipse and IntelliJ IDE.

Participants shared reasons for why they like or don’t like using an IDE, listed in Table 2b. Participants were asked

how often they use a web console when programming. Three said that they rarely use a web console and one said

that they never use a web console. Participants were asked to specify which web console they prefer to use and one

respondent indicated the OpenShift console. Participants shared reasons for why they like or don’t like using a web

console, listed in Table 2c.

5.2.2 Concurrent Tasks. Participants shared how they organize their work space when completing concurrent tasks

using a web console or CLI, choosing all that apply from the following options: one window, multiple tabs, multiple

windows. When performing concurrent tasks using a web console, participants indicated that they use either one

window (mentioned by one), multiple windows (mentioned by one), and/or multiple tabs (mentioned by three). One

participant indicated that they do not perform concurrent tasks using a web console. When performing concurrent tasks

using a CLI, participants indicated that they use either one window (mentioned by two), multiple windows (mentioned

by two), and/or multiple tabs (mentioned by four). More windows and tabs are employed when using a CLI to perform

concurrent tasks than when using a web console.

5.2.3

Likert-Scale Evaluation. All four user study participants ranked the kubectl CLI as the tool interface they preferred

to use to complete the task. Participants shared their recommendations for how either interface could be improved

See Table 3. Three of the four participants also gave NASA-TLX ratings on a seven-point Likert-Scale from 1 (very low)

to 7 (very high) for the kubectl CLI and the OpenShift console to indicate how successful they felt in accomplishing what

they were asked to do, how hard they had to work (mentally and physically) to accomplish their level of performance,

and how insecure, discouraged, irritated, stressed, and annoyed they were.

Regarding their success in accomplishing the task using the kubectl CLI, all three gave a rating of 2, and regarding

their success using the OpenShift console, one gave a rating of 1, another a rating of 2, and one gave a rating of 4.

Regarding how hard they had to work using the kubectl CLI and the OpenShift console, participants gave ratings of

2, 4, and 5, and 3, 4, and 6, respectively. Regarding how insecure, discouraged, irritated, stressed, and annoyed they

10

Cora Coleman, William G. Griswold, and Nick Mitchell

Table 3. The recommendations of four user study participants (P1–P4) for improving the kubectl CLI and OpenShift Console.
Participant P2 chose not to answer to these questions in the follow-up interview.

kubectl CLI

OpenShift Console

P1 Cryptic syntax for many commands, hard to do easy

More developer focused tools

things like switch contexts

P2 –
P3

Seems to be doing what it is supposed to do. Minor
problems can be super annoying though like this one:
https://github.com/kubernetes/kubernetes/issues/42552

–
More scripting and automation? Plugins?

P4 Better documentation

NA (not using it)

were completing the task using the CLI and console, all participates gave ratings of 2 for the CLI while two participants

rated the console a 3 and one participant rated the console a 4. Therefore, participants found the CLI to have less of an

impact on the effort required to perform the task and overall felt more successful using the CLI.

6 DISCUSSION AND DESIGN IMPLICATIONS

This paper investigates user preference and productivity in Cloud tooling, with an eye towards finding gaps and

opportunities in the way these tools are designed. The level of design commitment seems to vary widely across these

modalities. Consoles are heavy with design intent, rich with functionality across the provider’s Cloud offerings, and are

often backed by large design and development teams. CLIs are typically quite low level and supported by small teams.

However, is this the best balance? From a design perspective, there are a variety of consoles being maintained and

developed to benefit “low/no-code” [25, 28]. It is uncertain whether this high investment is returning a set of tools that

developers prefer to use. In order to more deeply understand the impact that these tool modalities have on productivity

when interacting with the Cloud, we must consult the developers that use these tools in their everyday work. The

number of other tools that were mentioned among survey respondent preferences indicates the prevalent diversity of

Cloud tooling. See Table 1.

A vital part of the developer’s user experience today is how knowledge can be captured, shared, and more effectively

communicated. Research has shown that using CLIs is the most effective way for developers to learn and gain experience.

The external resources that exist to teach people how to use a CLI generally don’t make as much use of screenshots in

their tutorials and therefore don’t require as much maintenance effort as documentation for other tool modalities such

as IDEs [8, 9, 12, 13, 22]. A steeper learning curve remains associated with CLIs, despite their consistent and necessary

role in development. During the observational user study, when participants completed the task using the CLI they

would often repeatedly execute commands due to spelling errors. Only two of the participants made use of keyboard

shortcuts when using the CLI. Furthermore, study participants would remark that they could not remember specific

command combinations to efficiently execute several steps of the task at once.

Changes to design focus are needed to impart the level of productivity that daily use of tooling requires. Initially, we

thought beginners would prefer graphical over textual tool modalities and while three beginner survey respondent

preferences deviated from CLIs, none indicated they preferred an IDE over a CLI or web console. Only three survey

respondents indicated they preferred an IDE, all intermediate developers. Based on the findings presented in this paper

that show developers prefer CLIs to accomplish CRUD and debugging, and web consoles to perform monitoring, and

given the daily frequency that developers accomplish multiple types of tasks, we recommend exploring the impact of

Do Cloud Developers Prefer CLIs or Web Consoles?

11

more integrated, hybrid tool modalities to avoid the cost of context switching. We have conducted some preliminary

research for a follow-up to this study to further explore comparable measures of productivity across these disparate

tool modalities. By quantifying the interactions required to use each tool, we seek to be able to compare the manual

effort required to complete a task.

7 THREATS TO VALIDITY

In light of the ongoing push towards automation, a challenge to this study is against our focus on tasks that users

perform manually. This is despite an ongoing push for developers to employ automation in favor of manual tasks; e.g.

GitOps [5] and CI/CD [38] more generally. This is a reasonable critique, however, as Figure 3 shows, people are still

heavily reliant on manual tools to accomplish their routine tasks.

A challenge we faced was in deciding what metrics to use to compare these tools in our user study. We assume that

these tools are already well designed and instead seek to study the limits that exist within the steady state of design and

learning. These modalities will have certain limits and we seek to understand what are they as is in order to determine

how we can improve them. We found that wall clock time is not the best comparison because of the user variance we

observed when participants completed a task in preliminary pilot testing. User preference is a better metric, however, it

may be too subjective. For example, knowing people prefer a CLI for certain tasks does not help to improve the web

console for those tasks.

One person from the open source community gave us feedback on our survey questions and said that OpenShift

is a distribution and not a Cloud provider. Perhaps not including OpenShift as an option would have encouraged

more specific responses for other Cloud providers not listed as popular options. Furthermore, we only collected five

responses from beginners and require more representation from this user group in future work as they are not as

equally represented in our participant pool.

8 CONCLUSION AND FUTURE WORK

CLIs have been with us since the dawn of modern computing and they continue to use comparatively primitive

presentation methods. Recall from Section 2 the low-level and tedious CLI interface Star used for her monitoring task.

This scenario illuminates the opportunity for a grand re-imagining of the Cloud user experience, employing modern

and sleek graphical toolkits. Large companies such as RedHat have clearly thrown considerable resources into this

effort, in developing their OpenShift console. However, we have found that most developers only prefer to use the web

console for monitoring tasks. In general, most developers prefer to use the CLI to accomplish CRUD and debugging

tasks.

We as a community have yet to find something truly better than a CLI. Hybrid interfaces are a promising direction for

future work in this area. We hope to explore the impact of hybrid interfaces on developer tool preference in the context

of different types of programming tasks. We began preliminary pilot testing of a user study with two participants that

used Kui, a hybrid tool to accomplish the same task that our user study participants carried out using the kubectl CLI

and the OpenShift console. Furthermore, we hope to study means for improving the quantification of user preference

with the goal of constructively informing the design of Cloud tools. We identified a set of comparable metrics from

screen recordings of the comparative user study task sessions to better quantify participant exhaustion and disruption

and reinforce self-reported NASA-TLX scale ratings.

12

Cora Coleman, William G. Griswold, and Nick Mitchell

9 ACKNOWLEDGMENTS

This research was conducted as part of a summer internship with the IBM T.J. Watson Research Center.

REFERENCES

[1] Zahra Shakeri Hossein Abad, Oliver Karras, Kurt Schneider, Ken Barker, and Mike Bauer. 2018. Task interruption in software development projects:
What makes some interruptions more disruptive than others?. In Proceedings of the 22nd International Conference on Evaluation and Assessment in
Software Engineering 2018. 122–132.

[2] The Kubernetes Dashboard Authors. 2019. Kubernetes Dashboard. Retrieved February 18, 2022 from https://github.com/kubernetes/dashboard
[3] Maricela-Georgiana Avram. 2014. Advantages and challenges of adopting cloud computing from an enterprise perspective. Procedia Technology 12

(2014), 529–534.

[4] Rob Barrett, Eser Kandogan, Paul P Maglio, Eben M Haber, Leila A Takayama, and Madhu Prabaker. 2004. Field studies of computer system
administrators: analysis of system management tools and practices. In Proceedings of the 2004 ACM conference on Computer supported cooperative
work. 388–395.

[5] Florian Beetz and Simon Harrer. 2021. GitOps: The Evolution of DevOps? IEEE Software (2021), 0–0. https://doi.org/10.1109/MS.2021.3119106
[6] Gaston R Cangiano and James D Hollan. 2009. Capturing and restoring the context of everyday work: A case study at a law office. In International

Conference on Human Centered Design. Springer, 945–954.

[7] Jung-Wei Chen and Jiajie Zhang. 2007. Comparing text-based and graphic user interfaces for novice and expert users. In AMIA annual symposium

proceedings, Vol. 2007. American Medical Informatics Association, 125.

[8] Visual Studio Code. 2022. VS Code. Retrieved February 18, 2022 from https://code.visualstudio.com
[9] OpenShift Web Console. 2022. Web Console Walkthrough. Retrieved February 18, 2022 from https://docs.openshift.com/container-platform/3.11/

getting_started/developers_console.html

[10] Edward Dillon, Monica Anderson, and Marcus Brown. 2012. Comparing mental models of novice programmers when using visual and command

line environments. In Proceedings of the 50th Annual Southeast Regional Conference. 142–147.

[11] Tharam Dillon, Chen Wu, and Elizabeth Chang. 2010. Cloud computing: issues and challenges. In 2010 24th IEEE international conference on advanced

information networking and applications. Ieee, 27–33.

[12] Git Documentation. 2022. Create your first Java application. Retrieved February 18, 2022 from https://www.jetbrains.com/help/idea/creating-and-

running-your-first-java-application.html#get-started

[13] Git Documentation. 2022. Start Using Git. Retrieved February 18, 2022 from https://docs.gitlab.com/ee/gitlab-basics/start-using-git.html
[14] Kubernetes Documentation. 2021. What is Kubernetes? Retrieved February 18, 2022 from https://kubernetes.io/docs/concepts/overview/what-is-

kubernetes/

[15] K Anders Ericsson and Herbert A Simon. 1984. Protocol analysis: Verbal reports as data. the MIT Press.
[16] Matt Farnia. 2018. Kubernetes Application Survey 2018 Results. Retrieved April 24, 2018 from https://kubernetes.io/blog/2018/04/24/kubernetes-

application-survey-results-2018/

[17] Mark C Fox, K Anders Ericsson, and Ryan Best. 2011. Do procedures for verbal reporting of thinking have to be reactive? A meta-analysis and

recommendations for best reporting methods. Psychological bulletin 137, 2 (2011), 316.

[18] Ishaan Gandhi and Anshula Gandhi. 2020. Lightening the Cognitive Load of Shell Programming. (2020).
[19] Victor M González and Gloria Mark. 2004. " Constant, constant, multi-tasking craziness" managing multiple working spheres. In Proceedings of the

SIGCHI conference on Human factors in computing systems. 113–120.

[20] Sandra G Hart and Lowell E Staveland. 1988. Development of NASA-TLX (Task Load Index): Results of empirical and theoretical research. In

Advances in psychology. Vol. 52. Elsevier, 139–183.

[21] Edwin L Hutchins, James D Hollan, and Donald A Norman. 1985. Direct manipulation interfaces. Human–computer interaction 1, 4 (1985), 311–338.
[22] kubectl CLI Documentation. 2021. kubectl. Retrieved February 18, 2022 from https://kubernetes.io/docs/reference/kubectl
[23] Toby Jia-Jun Li, Jingya Chen, Haijun Xia, Tom M Mitchell, and Brad A Myers. 2020. Multi-modal repairs of conversational breakdowns in

task-oriented dialogs. In Proceedings of the 33rd Annual ACM Symposium on User Interface Software and Technology. 1094–1107.

[24] Sharon Mcdonald, Gilbert Cockton, and Alastair Irons. 2020. The impact of Thinking-Aloud on usability inspection. Proceedings of the ACM on

Human-Computer Interaction 4, EICS (2020), 1–22.

[25] Allen McLean. 2021. Software development trends 2021. Canadian Journal of Nursing Informatics 16, 1 (2021).
[26] Brad Myers, Scott E Hudson, and Randy Pausch. 2000. Past, present, and future of user interface software tools. ACM Transactions on Computer-Human

Interaction (TOCHI) 7, 1 (2000), 3–28.

[27] CNCF Staff Blog Post. 2021. CNCF Cloud Native Survey 2021: Part 2 is open now! Retrieved August 11, 2021 from https://www.cncf.io/blog/2021/08/

11/cncf-cloud-native-survey-2021-part-2-is-open-now/

[28] Clay Richardson and John R Rymer. 2016. Vendor landscape: The fractured, fertile terrain of low-code application platforms. FORRESTER, Janeiro

(2016).

Do Cloud Developers Prefer CLIs or Web Consoles?

13

[29] Harini Sampath, Alice Merrick, and Andrew Macvean. 2021. Accessibility of Command Line Interfaces. In Proceedings of the 2021 CHI Conference on

Human Factors in Computing Systems. 1–10.

[30] Ramona Su Thompson, Esa M Rantanen, William Yurcik, and Brian P Bailey. 2007. Command line or pretty lines? Comparing textual and visual

interfaces for intrusion detection. In Proceedings of the SIGCHI conference on Human factors in computing systems. 1205.

[31] IBM Cloud Topics. 2021. What is software development? Retrieved February 18, 2022 from https://www.ibm.com/topics/software-development
[32] Alper Unal and Fatma Burcu Topu. 2021. Effects of teaching a computer programming language via hybrid interface on anxiety, cognitive load level

and achievement of high school students. Education and Information Technologies (2021), 1–19.

[33] Priyan Vaithilingam and Philip J Guo. 2019. Bespoke: Interactively synthesizing custom GUIs from command-line applications by demonstration. In

Proceedings of the 32nd annual ACM symposium on user interface software and technology. 563–576.

[34] Bogdan Vasilescu, Kelly Blincoe, Qi Xuan, Casey Casalnuovo, Daniela Damian, Premkumar Devanbu, and Vladimir Filkov. 2016. The sky is not the

limit: multitasking across GitHub projects. In Proceedings of the 38th International Conference on Software Engineering. 994–1005.

[35] Artem Voronkov, Leonardo A Martucci, and Stefan Lindskog. 2019. System administrators prefer command line interfaces, don’t they? an exploratory

study of firewall interfaces. In Fifteenth Symposium on Usable Privacy and Security ({SOUPS} 2019). 259–271.

[36] Yi Wang. 2017. Characterizing developer behavior in cloud based IDEs. In 2017 ACM/IEEE International Symposium on Empirical Software Engineering

and Measurement (ESEM). IEEE, 48–57.

[37] Coburn Watson. 2015. Netflix RaaS: Reliability as a Service. USENIX Association, Santa Clara, CA.
[38] Fiorella Zampetti, Salvatore Geremia, Gabriele Bavota, and Massimiliano Di Penta. 2021. CI/CD Pipelines Evolution and Restructuring: A
https:

Qualitative and Quantitative Study. In 2021 IEEE International Conference on Software Maintenance and Evolution (ICSME). 471–482.
//doi.org/10.1109/ICSME52107.2021.00048

[39] Xiong Zhang and Philip J Guo. 2017. Ds. js: Turn any webpage into an example-centric live programming environment for learning data science. In

Proceedings of the 30th Annual ACM Symposium on User Interface Software and Technology. 691–702.

