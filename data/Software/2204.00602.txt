2
2
0
2

r
p
A
1

]
h
p
-
t
n
a
u
q
[

1
v
2
0
6
0
0
.
4
0
2
2
:
v
i
X
r
a

Perceval: A Software Platform for Discrete Variable
Photonic Quantum Computing

Nicolas Heurtel1, Andreas Fyrillas1,2, Grégoire de Gliniasty1, Raphaël Le Bihan1,
Sébastien Malherbe3, Marceau Pailhas1, Boris Bourdoncle1,
Pierre-Emmanuel Emeriau1, Rawad Mezher1, Luka Music1, Nadia Belabas2,
Benoît Valiron4, Pascale Senellart2, Shane Mansﬁeld1, and Jean Senellart1

1Quandela, 7 Rue Léonard de Vinci, 91300 Massy, France
2Centre for Nanosciences and Nanotechnology, CNRS, Université Paris-Saclay, UMR 9001, 10 Boulevard Thomas
Gobert, 91120, Palaiseau, France
3Département de Physique de l’Ecole Normale Supérieure - PSL, 45 rue d’Ulm, 75230, Paris Cedex 05, France
4Université Paris-Saclay, Inria, CNRS, ENS Paris-Saclay, CentraleSupélec, LMF, 91190, 15 Gif-sur-Yvette, France

We introduce Perceval , an evolutive open-source software platform for simu-
lating and interfacing with discrete-variable photonic quantum computers, and
describe its main features and components. Its Python front-end allows pho-
tonic circuits to be composed from basic photonic building blocks like photon
sources, beam-splitters, phase-shifters and detectors. A variety of computa-
tional back-ends are available and optimised for diﬀerent use-cases. These
use state-of-the-art simulation techniques covering both weak simulation, or
sampling, and strong simulation. We give examples of Perceval in action by
reproducing a variety of photonic experiments and simulating photonic imple-
mentations of a range of quantum algorithms, from Grover’s and Shor’s to
examples of quantum machine learning. Perceval is intended to be a useful
toolkit both for experimentalists wishing to easily model, design, simulate, or
optimise a discrete-variable photonic experiment, and for theoreticians wishing
to design algorithms and applications for discrete-variable photonic quantum
computing platforms.

1 Introduction

Quantum computing has gained huge interest and momentum in recent decades because
of its promise to deliver computational advantages and speedups compared to the classical
computing paradigm. The essential idea is that information processing takes place on
physical devices, and if the components of those devices behave according to the laws of
quantum rather than classical physics then it opens the door to exploiting quantum eﬀects
to process information in radically diﬀerent and potentially advantageous ways.

Quantum algorithms like Shor’s factorisation algorithm [1], which gives an exponential
speedup over its best known classical counterpart, or Grover’s search algorithm [2], which

nicolas.heurtel@quandela.com

shane.mansﬁeld@quandela.com

jean.senellart@quandela.com

1

 
 
 
 
 
 
gives a quadratic speedup over its classical counterparts, are often cited, and have captured
the imagination and provided motivation for the rapid developments that have taken place
in quantum technologies. However, for such algorithms to have practical signiﬁcance will
require large-scale fault-tolerant quantum computers. Yet the quantum devices that are
available commercially or in research laboratories today are somewhat more limited and
belong, for now at least, to the so-called noisy-intermediate scale quantum (NISQ) regime
[3].

Of course NISQ devices are a necessary step on the path to large-scale fault-tolerant
quantum computers, but in principle they could already enable quantum computational
advantages [4] – in which they could outperform even the most powerful classical super-
computers available today – for tasks with practical relevance. Several experiments have
already claimed to demonstrate quantum computational advantage in sampling tasks [5–8].
The practical signiﬁcance of these is still being explored [9–11], but meanwhile many other
promising proposals for quantum algorithms that may deliver practical advantages in this
regime are also being pursued. Among others, these include the quantum variational eigen-
solver [12], universal function approximators like that of [13] (both of which we will return
to later in this paper), the quantum approximate optimisation algorithm [14], as well as
a host of other algorithms [15] with applications that range from chemistry [16, 17] and
many-body physics [18, 19] to combinatorial optimisation [20, 21] and machine learning
[22, 23].

In fact, a number of technological routes to building quantum computers are being
actively pursued, in which quantum information is encoded in very diﬀerent kinds of phys-
ical systems. These include matter-based approaches that rely on superconducting circuits,
cold atoms, or trapped ions, but also light-based approaches in which photons are the ba-
sic information-carrying systems. Among these, photons have a privileged status, as they
are the natural and indeed only viable support for communicating quantum information,
which will eventually be required for networking quantum processors and devices. As such
they will necessarily be a part of any longer-term developments in quantum computational
hardware and infrastructure. More than this, photons provide viable routes to both NISQ
[24] and large-scale fault-tolerant quantum computing through measurement-based models
[25, 26] in their own right.

Perceval is the most complete and eﬃcient software platform for the discrete variable
(DV) model for photonic quantum computing1. It especially uses Fock state descriptions
of photons generated by sources, evolving through linear optical networks – composed for
example of beam splitters, phase shifters, waveplates or other linear optical components –
and then being detected. The familiar qubit and measurement-based models for quantum
computing can be encoded within the DV model (see e.g. [24, 25]). However, the DV model
is also of signiﬁcant interest in its own right — not least because it has led to some of the
ﬁrst proposals [27] for quantum computational advantage to be demonstrated with NISQ
devices. This concerns a computational problem known as Boson Sampling, discussed in
detail in Section 4.2, which essentially consists of sampling from the output distribution
of photons that interfere in a generic interferometer. We will also demonstrate direct DV
photonic approaches to quantum machine learning in Section 4.6.

Perceval ’s features can be useful for designing, optimising, simulating, and eventually
running DV linear optical circuits.
It allows users to work at a level that is closer to
the photonic hardware than regular gate-based qubit quantum circuit model, which is

1Perceval does not aim to treat the continuous variable (CV) model of photonic quantum computing,
which is concerned with inﬁnite dimensional observables of the electromagnetic ﬁeld, and which is the
natural realm of the Strawberry Fields platform [28].

2

already the focus of a number of other software platforms [29], and it is more ﬂexible
and supports many more functionalities than existing packages for linear optical quantum
systems [30]. The ﬁner-grained control of the physical hardware can be valuable both for
the NISQ regime, where it is crucial to achieve the maximum performance from the speciﬁc
hardware resources available, and for optimising the building block photonic modules in
schemes for reaching the large-scale fault-tolerant regime.

It is intended to be useful for experimentalists wishing to design photonic experiments,
including allowing for realistic modelling of noise and imperfections, and for computer
scientists and theoreticians seeking to develop algorithms and applications for photonic
quantum computers. It is an evolutive, open source platform that is intended for commu-
nity development via GitHub2 and the project forum website3.

Perceval integrates several state-of-the-art algorithms for running simulations optimised
with low-level single instruction, multiple data (SIMD) implementations, allowing users to
push close to the limits of classical simulability with desktop computers. Extensions to the
framework are also intended for high-performance computing (HPC) cluster deployment
which can permit simulation to scale slightly further.

The remainder of this white paper is structured as follows. We provide some brief
background on photonic quantum computing in Section 2, before outlining the structure
and key features of Perceval in Section 3, and then go on to give a number of illustrative
examples of Perceval in action in Section 4.

2 Photonic Quantum Computing

Similar to the qubit quantum circuit model, the DV photonic model can be presented as
a gate-based model, in which states are prepared, transformed as they are acted upon by
gates, and measured.

We consider a number m ∈ N of spatial modes. Physically these could correspond
to waveguides in an integrated circuit, optical ﬁbres, or paths in free space, to give some
examples. Photon sources prepare initial states in these spatial modes. These are number
states |ni, where n is the number of photons in the mode, or superpositions of number
states. We use the shorthand notation |0, 1i for a two-mode system with state |0i in
the ﬁrst and |1i in the second, etc. Unless otherwise speciﬁed, photons are assumed
to be indistinguishable. Sometimes we will wish to keep track of the polarisation of the
photons, which can be achieved by further splitting each spatial mode into two polarisation
modes, e.g. horizontal (denoted by |Hi) and vertical (denoted by |V i), and recording the
(superpositions of) number states for each. Perceval also allows the possibility of tracking
other attributes of photons.

Transformations are performed on the states by evolving them through linear optical
networks. The simplest linear optical operations (gates) are: phase shifters, which act
on a single spatial mode, and beam splitters, which act on pairs of spatial modes. These
operations preserve photon number and are best described as unitary matrices that act on
the creation operator of each mode (see, e.g., [31, 32] for a more detailed treatment). A
creation operator is deﬁned by its action a† |ni =
n + 1 |n + 1i. The unitary associated
with a phase shifter Pφ with phase parameter φ ∈ [0, 2π] is simply the scalar eiφ, while
under a given convention the unitary matrix associated with a beam splitter Bθ,φ is (we
have included for clarity the basis on which the matrix acts in gray above and on the left):

√

2https://github.com/Quandela/Perceval

3https://perceval.quandela.net/forum

3

bUBS(θ, φ) =

|1, 0i
cos (θ)
ieiφ sin (θ)

|0, 1i
ie−iφ sin (θ)
cos (θ)

!

,

h1, 0|
h0, 1|

(1)

where the parameter θ relates to the reﬂectivity, the parameter φ corresponds to a relative
phase between the modes and |1, 0i denotes the state in which the photon travels in the
ﬁrst spatial mode. If the phase parameter is omitted it is assumed to be zero. Perceval
introduces all theoretically equivalent beam splitter matrix notations as further explained
in Section 3. The action of any linear optical circuit is thus given by the unitary ma-
trix obtained by composing and multiplying the matrices associated with its elementary
components. Interestingly, it can be shown that conversely any unitary evolution can be
decomposed into a combination of beam splitters and phase shifters, e.g. in a ‘triangular’
[33] or ‘square’ [34] array.

We also allow for swaps or permutations of spatial modes, and can include operations
like waveplates, which act on polarisation modes of a single spatial mode and are described
by the following unitary [35]:

bUWP(δ, ξ) =

|Hi
i sin (δ) cos (2ξ) + cos (δ)
i sin (δ) sin (2ξ)

|V i
i sin (δ) sin (2ξ)
−i sin (δ) cos (2ξ) + cos (δ)

!

.

hH|
hV |

(2)

Here δ is a parameter proportional to the thickness of the waveplate and ξ represents
the angle of the waveplate’s optical axis in the {|Hi , |V i} plane. Especially important is
the case that δ = π/2, known as a half-wave plate, which rotates linear polarisations in the
{|Hi , |V i} plane. Quarter-wave plates (δ = π/4) convert circular polarisations to linear
ones (e.g. |Li = (|Hi + i |V i)/

2) and vice-versa.

√

Polarising beam splitters will convert a superposition of polarisation modes in a single
spatial mode to the corresponding equal-polarisation superposition of two spatial modes,
and vice versa, and so in this sense allow us to translate between polarisation and spatial
modes. The unitary matrix associated to a polarising beam splitter acting on the tensor
product of the spatial mode and the polarisation mode is








hH, 0|
hV, 0|
h0, H|
h0, V |

|H, 0i
0
0
1
0

|V, 0i
0
1
0
0

|0, Hi
1
0
0
0

|0, V i
0
0
0
1





,



(3)

bUPBS =

where |H, 0i denotes the single-photon state in which the photon travels in the ﬁrst spatial
mode with a horizontal polarisation.

Similarly then, any unitary evolution on spatial and polarisation modes can be decom-

posed into an array of polarising beam splitters, beam splitters and phase shifters.

Finally measurement, or readout, is made by single photon detectors (these may be
partially or fully number resolving). Both photon generation and measurement are non-
In particular, measurements can be used to induce probabilistic or
linear operations.
post-selected non-linearities in linear optical circuits. We could further add feedforward,
whereby measurement events condition parameters further along in a circuit.

The basic post-selection-, feedforward- and polarisation-free (without polarisation mo-
des or operations) fragment of the DV model described above is precisely the model con-
sidered by Aaronson and Arkhipov in [27]. For classical computers, simulating this simple

4

 
 
model, straightforward though its description may be, is known to be #P -hard, and up
to complexity-theoretic assumptions the same is true for approximate classical simula-
tion. The reason for this essentially comes down to the fact that calculating the detection
statistics requires evaluating the permanents of unitary matrices, a problem which itself is
known to be #P-hard [36]. We describe this in a little more detail when we look at Boson
Sampling in Section 4.2.

Similarly the polarisation-free fragment was shown by Knill, Laﬂamme and Milburn
to be quantum computationally universal [24]. In particular, it can be used to represent
qubits and qubit logic gates.

Just as the bit — any classical two level system — is generally taken as the basic
informational unit in classical computer science, the qubit — any two level quantum system
— is most usually taken as the basic informational unit in quantum computer science.
Photons have many degrees of freedom and oﬀer a rich variety of ways to encode qubits.
One of the most common approaches is to use the dual-rail path encoding of [24]. Each
qubit is encoded by one photon which may be in superposition over two spatial modes,
which correspond to the qubit’s computational basis states:

|0iqubit := |1, 0i ,

|1iqubit := |0, 1i .

(4)

Single-qubit unitary gates are particularly straightforward to implement in this encoding,
requiring only a fully parametrisable beam splitter, as in Equation 1 and a phase shifter.
An example of an entangling two-qubit gate (CNOT), which uses heralding, or in other
words post-selection over auxiliary modes, will be presented in Section 3.

Another common qubit encoding is the polarisation encoding, and indeed versions
of the KLM scheme also exist for this encoding [37]. Here each qubit is encoded in the
polarisation degree of freedom of a single photon. This encoding will be used in the example
of Section 4.3. In practice, encodings may be chosen based on the availability or ease of
implementation of diﬀerent linear optical elements in laboratory settings. For instance
path-encoding is at present more accessible than polarisation encoding in integrated optics,
where linear optical circuits are implemented ‘on-chip’. Although we have discussed ways
of encoding qubit quantum circuits into the DV model, it should be reiterated that the
DV model has interesting features in its own right, and the examples of Boson Sampling
in Section 4.2 and quantum machine learning in Section 4.6 give some illustrations of
interesting applications that bypass qubit descriptions.

We have presented the idealised DV model, but it is important to note that in real-
istic implementations various noise, imperfections, and errors will arise. Perceval is also
intended as a tool for designing, modelling, simulating and optimising realistic DV lin-
ear optical circuits and experiments, and to incorporate realistic noise-models. We brieﬂy
demonstrate how Perceval handles imperfect photon purity at source and distinguishabil-
ity due to imperfect synchronisation in Section 4.1. Other relevant factors are losses at
all stages from source to detection, imperfect or imperfectly characterised linear optical
components, cross-talk eﬀects, detector dark-counts, etc. Future versions of Perceval will
contain increasingly sophisticated and parametrised modelling of such factors.

3 Presentation of Perceval

3.1 Global Architecture

Perceval is a linear optical circuit development framework whose design is based on the
following core ideas:

5

• It is simple to use, both for theoretical and experimental physicists and for computer

scientists;

• It does not constrain the user to any framework-speciﬁc conventions that are theoret-
ically equivalent (for example it was noticed early on that many diﬀerent conventions
for beam splitters can be found in the literature);

• It provides state-of-the-art optimised algorithms – practically benchmarked on spe-

ciﬁc use cases;

• It provides – when possible and pertinent – access to symbolic calculations for ﬁnding

analytical solutions;

• It provides companion tools, like a unitary matrix toolkit, and LATEXor HTML ren-

dering of algorithms;

• It incorporates realistic, parametrisable error and noise modelling;

• It enables a simple transition from simulators to actual photonic processors.

Perceval is a modular object-oriented Python code, with optimised functions written
in C making use of SIMD vectorisation. In the following section, we give an overview of
the main classes available to the user. A full documentation is maintained on GitHub and
available online through the project website.

3.2 Main Classes

3.2.1 States

Information in a linear optical circuit is encoded in the state of photons in certain “modes”
that are deﬁned by the circuit designer. States are implemented in Perceval by the following
three classes:

• BasicState is used to describe Fock states of n indistinguishable photons over m

modes;

• AnnotatedBasicState extends BasicState and describes states of n annotated pho-
tons over m modes. The annotation is a way to associate additional information to
each photon and can thus represent additional degrees of freedom — for instance,
polarisation is represented as a photon annotation;

• StateVector extends AnnotatedBasicState to represent superpositions of states.

3.2.2 Circuits

The Circuit class provides a practical way to assemble a linear optical circuit from pre-
deﬁned elementary components, other circuits, or unitary matrices. It can also compute
the unitary matrix associated to a given circuit, or conversely decompose a unitary into
a linear optical circuit consisting of user-deﬁned components. Two libraries of predeﬁned
elementary components are provided (see Table 1) and an example of code using this class
can be found on Page 9.

6

Name

Unitary Matrix

Representation





eiφa cos (θ)

iei(φa−φb+φd) sin (θ)

ieiφb sin (θ)

eiφd cos (θ)





eiφi
h





0 1

1 0





i sin (δ) sin (2ξ)





i sin (δ) cos (2ξ) + cos (δ)





i sin (δ) sin (2ξ)

−i sin (δ) cos (2ξ) + cos (δ)











0 0 1 0

0 1 0 0

1 0 0 0

0 0 0 1











cos (δ)

sin (δ)

− sin (δ)

cos (δ)









Beam Splitter

Phase Shifter

Mode Permutation

Wave Plate

Polarising

Beam Splitter

Polarising Rotator

Time Delay

Table 1: Components available in the Phys library. Note that the beam splitter diﬀers from the one
given in Equation 1. The extra parameters allow the user to ﬁx their own preferred convention for
the beam splitter. Perceval includes a library which allows the user to deﬁne their own personal set of
components, each with its own visual representation and unitary matrix.

3.2.3 Back-ends

Finally, the last key component of Perceval are its four back-ends – Naive, SLOS, Stepper
and CliffordClifford2017 – each one taking a diﬀerent computational approach to cir-
cuit simulation. They perform the following tasks:

• Sample individual single output states;

• Compute the probability, or probability amplitude, of obtaining a given output state

from a given input state;

• Describe the exact complete output state.

The CliffordClifford2017 Back-end. This back-end is the implementation of the
algorithm introduced in [38]. The algorithm, applied to Boson Sampling, aims to “produce
provably correct random samples from a particular quantum mechanical distribution”. Its
time and space complexity are respectively O(cid:0)n2n + mn2(cid:1) and O(m). The algorithm
has been implemented in C++, and uses an adapted Glynn algorithm [39] to eﬃciently
compute n simultaneous “sub-permanents”.

7

Recently, the same authors have proposed a faster algorithm in [40] with an average
θ ) for a number of modes m = θn which is linear in the number

time complexity of O(nρn
of photons n, where:

ρθ =

(2θ + 1)2θ+1
(4θ)4θ(θ + 1)θ+1
To give an example, with θ = 2, which would be a starting point if we were to work
with dual rail path encoding ignoring for now the number of auxiliary modes required, the
average performance of this algorithm would be O
≈ O(n1.8n) as opposed to
O(n2n) for the original algorithm of [38].

8233 )n(cid:17)

n( 55

(5)

(cid:16)

The SLOS Back-end. The Strong Linear Optical Simulation SLOS algorithm developed
by a subset of the present authors is introduced in [41]. It unfolds the full computation
(cid:1)(cid:17) for computing
path in memory, leading to a remarkable time complexity of O
the full distribution. The current implementation also allows restrictive sets of outputs,
with average computing time in O(nρn
θ ) for single output computation. As discussed in
[41], it is possible to use the SLOS algorithm in a hybrid manner that can combine both
weak and strong simulation, though it has not yet been implemented in the current version
(cid:1)(cid:17)
of Perceval . The tradeoﬀ in the SLOS algorithm is a huge memory usage of O
that limits usage to circuits with ≈ 20 photons on personal computers and with ≈ 24
photons on super-computers.

n(cid:0)m+n−1
n

n(cid:0)m+n−1
n

(cid:16)

(cid:16)

The Naive Back-end. This back-end implements direct permanent calculation and is
therefore suited for single output probability computation with small memory cost. Both
Ryser’s [42] and Glynn’s [39] algorithms have been implemented. Extra-care has been taken
on the implementation of these algorithms, with usage of diﬀerent optimisation techniques
including native multithreading and SIMD vectorisation primitives. Benchmarking of these
algorithms and comparison with the implementation present in the The Walrus library4 is
provided in Figure 1.

The Stepper Back-end. This back-end takes a compltely diﬀerent approach. Without
computing the circuit’s overall unitary matrix ﬁrst, it applies the unitary matrix associated
with the components (see Table 1) in each layer of the circuit one-by-one, simulating the
evolution of the statevector. The complexity of this back-end is therefore proportional to
the number of components. It has the nice features that:

• it supports non linear optical components like Time Delay;

• it is very ﬂexible with simulating noise in the circuit, like photon loss;

• it enables simpler debugging of circuits by exposing intermediate states.

The main practical limitation of the Stepper back-end is that it is really meant for

circuit simulation and does not have any interest in a simulation on a random unitary.

Theoretical performance and speciﬁc features of the diﬀerent back-ends are summarised

in Table 2.

4https://github.com/XanaduAI/thewalrus

5Following the methodology presented at https://the-walrus.readthedocs.io/en/latest/gallery/

permanent_tutorial.html.

8

Figure 1: Comparison of the average time to calculate a permanent5of an n × n Haar random matrix.
The processor is a 32 core, 3.1GHz Intel Haswell. For The Walrus, version 0.19 is used and installed
from pypi. The Ryser implementation is run on 4 or 32 threads. The Glynn implementation is run
on a single thread. What is interesting to note is that all implementations have convergence to the
theoretical performance but the factor between optimised and less optimised implementation still makes
a perceptible time diﬀerence for the end-user. Based on diﬀerent behaviour between Ryser and Glynn
with n and potential multi-threading, Perceval has some built-in logic to switch between the two
algorithms.

3.2.4 Step-by-Step Example

The following code implements a simple linear optical circuit corresponding to a path-
encoded CNOT gate (after post-selection in the coincidence basis) [43].

cnot = ( phys . Circuit (6 , name = " Ralph CNOT " )

. add (0 , phys . BS ( R = 2 /3 , phi_b = sp . pi , phi_d = 0 ) )
. add (3 , phys . BS ( R = 1 / 2 ) )
. add (2 , phys . BS ( R = 2 /3 , phi_b = sp . pi , phi_d = 0 ) )
. add (4 , phys . BS ( R = 2 / 3 ) )
. add (3 , phys . BS ( R = 1 / 2 ) ) )

pcvl . pdisplay ( cnot )
pcvl . pdisplay ( cnot . compute_unitary ( use_symbolic = True ) ,

output_format = " latex " )

Let us explain how it works. We remind that the CNOT gate is a two-qubit gate that acts
in the following way:

CNOT(|x, yi) = |x, x ⊕ yi ,

(6)

i.e. it’s a controlled-not gate where the ﬁrst qubit acts as control and the second qubit is
the target. We use dual-rail encoding (see Equation 4) and thus need four spatial modes
to represent the target and the control. We additionally need two auxiliary empty modes
to implement this post-selected linear optical CNOT.The circuit is made of 3 central beam
splitters of reﬂectivity 2/3, whereas the two to the left and right of the central ones have
a reﬂectivity of 1/2. The corresponding circuit displayed by Perceval is depicted in Figure
2.

The ﬁrst and last spatial modes correspond to the auxiliary empty modes, the second
and third to the control qubit, and the fourth and ﬁfth to the target qubit. The associated
unitary matrix acting on the six spatial modes computed with Perceval is displayed in
Figure 3.

9

Feature

Sampling
Eﬃciency

CC2017

O(cid:0)n2n + p(m, n2)(cid:1)(∗)

Single Output
Eﬃciency

Full Distribution
Eﬃciency

Probability
Amplitude

Supports Symbolic
Computation

Supports
Time-Circuit

Practical
Limits (***)

N/A

N/A

No

No

No

SLOS

(**)

(**)

Naive

Stepper

(cid:16)

O

n2n(cid:0)m+n−1

n

(cid:1)(cid:17)

O(n2n)

(cid:16)

o

Nc

(cid:0)m+n−1
n

(cid:1)(cid:17)

(cid:16)

O

n(cid:0)m+n−1
n

(cid:1)(cid:17)

(cid:16)

O

n2n(cid:0)m+n−1

n

(cid:1)(cid:17)

(cid:16)

o

Nc

(cid:0)m+n−1
n

(cid:1)(cid:17)

Yes

No

No

Yes

Yes

No

Yes

Yes

Yes

n ≈ 30

n, m < 20

n ≈ 30

Table 2: Theoretical performance and speciﬁc features of Perceval back-ends. (*) An implementation
based on “Faster Classical Boson Sampling” [40] is in progress; p is a polynomial function. (**) An
implementation of SLOS Sampling and single output eﬃciency is in progress. (***) Practical limits
are subjective and corresponding to a memory usage < 16Gb, and a usage time for a given function
of less than a few seconds. For Stepper, it is hard to evaluate exactly the complexity since it is
really proportional to the number of “components” (Nc) and the size of the output space that are
circuit-speciﬁc.

We then need to post-select on measuring two (dual-rail encoded) qubits in the modes
corresponding to the target and the control, i.e. on measuring exactly one photon in the
second or third spatial modes and exactly one photon in the fourth or ﬁfth spatial modes.
One can check that this measurement event happens with probability 1/9 — we call this
number the ‘performance’ of a post-selected gate. We say that the error rate is 0 if the
implementation of the gate is perfect (after post-selection). This computation can be done
with Perceval : we deﬁne a simulator, using the SLOS back-end, and perform a full output
distribution and performance analysis, as illustrated in Figure 4.

simulator_cnot = pcvl . BackendFactory () . get_backend ( " SLOS " ) ( cnot . U )

states = {

pcvl . BasicState ( [0 , 1 , 0 , 1 , 0 , 0 ] ) : " 00 " ,
pcvl . BasicState ( [0 , 1 , 0 , 0 , 1 , 0 ] ) : " 01 " ,
pcvl . BasicState ( [0 , 0 , 1 , 1 , 0 , 0 ] ) : " 10 " ,
pcvl . BasicState ( [0 , 0 , 1 , 0 , 1 , 0 ] ) : " 11 "

}

ca = pcvl . CircuitAnalyser ( simulator_cnot , states )
ca . compute ( expected = { " 00 " : " 00 " , " 01 " : " 01 " , " 10 " : " 11 " , " 11 " : " 10 " } )
pcvl . pdisplay ( ca , output_format = " latex " )
print ( " = > performance = %s , error rate = % . 3f % % " %

( pcvl . simple_float ( ca . performance ) [ 1 ] , ca . error_rate ) )

10

Figure 2: The circuit generated by Perceval corresponding to the CNOT circuit deﬁned in 3.2.4.



−












√

3
3
√

6i
3
0
0
0
0

−
√

√

6i
3
3
3
0
0
0
0

0
0
√
3
3
√

−
−

3i
3
√
3i
3
0

−
√

0
0
√

0
0
√
3i
3 −
3
3
0
√
3
3

−

3i
3
0
√
3
−
3
√
3
3 −














0
0
0
√
3
3
√

3
3
√
3
3

Figure 3: The unitary matrix of the CNOT circuit deﬁned in 3.2.4 computed symbolically by Perceval.

4 Perceval in Action

In this section we look at some examples of the Perceval software being used to reproduce
several photonic experiments that implement important quantum algorithms and then to
demonstrate a photonic quantum machine learning algorithm on a simulated photonic
quantum processor.

4.1 The Hong-Ou-Mandel Eﬀect

4.1.1

Introduction

The Hong-Ou-Mandel (HOM) eﬀect [44] is an interference eﬀect between pairs of indis-
tinguishable photons, which, when incident on a balanced beam splitter via the respective
input modes, will bunch and emerge together in either of the output modes with equal
probability. In 2002, Santori et al. demonstrated the HOM eﬀect with a unique source of
single photons [45], evidencing the indistinguishability of consecutive photons and paving
the way to many developments in experimental quantum optics.

In this experiment, “two pulses separated by 2 ns and containing 0 or 1 photons, arrive
through a single-mode ﬁbre. The pulses are interfered with each other using a Michelson-
[. . . ] The interferometer
type interferometer with a (2 ns+∆t) path-length diﬀerence.
outputs are collected by photon counters, and the resulting electronic signals are correlated

11

00
01
10
11

00
0.999991
0
0
0

01
0
0.999991
0
0
=> performance=1/9, error rate=0.000%

10
0
0
0
0.999991

11
0
0
0.999991
0

Figure 4: The result of the simulation of the CNOT circuit deﬁned in 3.2.4

using a time-to-amplitude converter followed by a multi-channel analyser card, which gen-
erates a histogram of the relative delay time τ = t2 − t1 between a photon detection at one
counter (t1) and the other (t2)” [45]. An equivalent experiment was carried out in [46]
with similar results, presented in Figure 5.

Figure 5: Measured correlation histogram between the HOM outputs in linear scale [46]. The red line
shows the theoretical histogram for a perfect two-photon interference.

4.1.2 Perceval Implementation

The implementation on Perceval uses a simple circuit composed of a beam splitter (corre-
sponding to the main beam splitter of [45, Figure 3(a)]), the lower output mode of which
then passes through a 1-period time-delay, and then a second beam splitter on the modes
where the interference happens.

The circuit and result are presented in Figure 6. The resolution is less ﬁne-grained than
the original experiments due to the absence of modelling of photon length in the current
implementation of Perceval . However, we clearly recognise the same distinctive peaks in
the relative amplitude. The very small coincidence rate at τ = 0 is the signature of photon
interference.

12

(a)

(b)

Figure 6: Reproduction of the experiments of [45] and [46] in Perceval. (a) The circuit as constructed
in Perceval. (b) Time simulation is run with Perceval and the diﬀerence between two consecutive
detections on both arms is plotted. An imperfect source with probability 1% of generating two photons
at each cycle has been simulated, and it is this slight imperfection that explains the nonzero value at
τ = 0.

4.2 Boson Sampling

4.2.1

Introduction

Boson Sampling6 is a sampling problem originally proposed by Aaronson and Arkhipov
[27]. We give a detailed description of the problem below. It essentially consists of sampling
from the probability distribution of outcome detection coincidences when single photons
are introduced into a random linear optical circuit.

Let m, n ∈ N∗ be positive integers with m ≥ n. Let Sm,n be the set of all possible tuples
(s1, . . . , sm) of m non-negative integers si ∈ N, with Pm
i=1 si = n. Let U be an m × m
Haar-random unitary matrix. From U we construct an n × n matrix UT,S as follows. For
a given S = (s1, . . . , sm) ∈ Sm,n, ﬁrst construct an n × m matrix US by copying si times
the ith row of U . Then, for a given (ﬁxed) T = (t1, . . . , tm) ∈ Sm,n, construct UT,S from
US by taking tj copies of the jth column of US. Let Perm(UT,S) be the permanent [48,
Chapter 7] of UT,S, and let

P (S) =

|Perm(UT,S)|2
s1! . . . sm!t1! . . . tm!

.

(7)

It can be shown that P (S) ∈ [0, 1], and that the set DU = {P (S) | S ∈ Sm,n} is a
probability distribution over outcomes S [27].

Let ε ∈ [0, 1] be a given precision. Approximate Boson Sampling can then be deﬁned

as the problem of sampling outcomes S from a probability distribution ˜D such that

k ˜D − DU k ≤ ε,

(8)

where k.k denotes the total variational distance between two probability distributions.
Exact Boson Sampling corresponds to the case in which ε = 0.

For m (cid:29) n2, it was shown in [27] that:

• No classical algorithm can solve Exact Boson Sampling in time poly(n),

6The technical introduction to the problem here draws heavily on a previous work by a subset of the

authors of this paper [47].

13

• No classical algorithm can solve Approximate Boson Sampling in time poly(n, 1
ε ),
unless some widely accepted complexity theoretic conjectures turn out to be false.

These hardness results are closely related to the hardness of computing the permanent of
matrices [27, 36].

On the other hand, Boson Sampling can be solved eﬃciently in the exact case on
a photonic quantum device which is noiseless [27], while the approximate version only
requires suﬃciently low noise levels [49–51]. This is done by passing n identical single
photons through a lossless m-mode universal linear optical circuit [33, 34] conﬁgured in such
a way that it implements the desired Haar-random unitary transformation U . Universal
here is meant in the sense of photonic unitaries and refers to the ability of the circuit
to generate any arbitrary unitary evolution on the creation operators of the modes. A
universal linear optical circuit can be conﬁgured to implement any m × m unitary chosen
from the Haar measure, for example using the recipe of [52]. The input conﬁguration of
single photons corresponds to a tuple T . We then measure the output modes of the circuit
using perfect single photon detectors, and will obtain the output conﬁguration tuple S
according to the distribution DU [27]. The detectors should be photon-number resolving
in general, but not necessarily when working in the no-collision regime (n2 << m) [27].

4.2.2 Perceval Implementation7

Boson Sampling with single photons in a 60 mode linear optical circuit with up to 14-
photon coincidences at the outputs was reported in [53]. In this Section, we report the
results of a noiseless Boson Sampling simulation performed with Perceval for n = 14 single
photons and m = 60 modes. For this Boson Sampling, the total number of possible output
states is M = (cid:0)m+n−1

(cid:1) ≈ 1014 [27].

For an input state of 14 photons in 14 arbitrarily chosen modes k1, ..., k14 ∈ {0, ..., 59},
we generated 300 Haar random 60 × 60 unitaries, and performed for each of these unitaries
5 × 106 runs of Boson Sampling, where each run consists of sampling a single output. In
total, we collected 1.5 × 109 samples.

(cid:1) = (cid:0)73
14

n

The classical algorithm for Boson Sampling integrated into Perceval and which was
used for this simulation is that of Cliﬀord and Cliﬀord [38]. Note that faster versions of
this algorithm have been found by the same authors in the case where m is proportional
to n [40]. Integration of the algorithm of [40] into Perceval is a subject of on-going work.
The simulations were performed on a 32-core 3.1GHz Intel Haswell processor, at the rate
of 8547 runs (samples) per second. It took roughly 2 days to collect 1.5 × 109 samples.

Brute-force certiﬁcation that our simulation has correctly implemented Boson Sampling
would require, for each of the 300 Haar random unitaries, calculation of approximately 1014
permanents (to get the ideal probability distribution of the Boson Sampler), then perform-
ing ≈ 1014 runs of Boson Sampling using our simulation, in order to get the distribution
of the simulated Boson Sampler to within the desired accuracy. Clearly, this task is com-
putationally intractable. In order to get around this issue, while still having some level
of conﬁdence that our Boson Sampling simulation has indeed been implemented correctly,
we have appealed to computing partial certiﬁcates [47, 54]. These certiﬁcates are usually
eﬃciently computable, but nevertheless can be used to rule out some common adverserial
strategies designed to spoof Boson Sampling [55, 56], although they cannot provably rule
out every possible adverserial spooﬁng strategy [47, 54–56].

7This implementation is accompanied by a notebook, which can be found in the Perceval documentation

at https://perceval.quandela.net/docs/notebooks/Boson%20Sampling.html.

14

The partial certiﬁcate we used here is the probability P (K) that all n input photons

are measured in the ﬁrst K output modes of the Boson Sampler [54], where K ≤ m.

P (K) := P (0K+1, . . . , 0m) =

X

P (S),

{S|sK+1=···=sm=0}

(9)

where, for a given m × m unitary U , P (S) is computed as in Equation 7. The aver-
age hP (K)i of P (K) over the Haar measure of m × m unitaries U has been computed
analytically in [54]:

hP (K)i =

K(K + 1) . . . (K + n − 1)
m(m + 1) . . . (m + n − 1)

.

(10)

We computed an estimate h ˜P (K)i of hP (K)i by computing an estimate ˜P (K) of P (K)
using 5×106 samples for each of the 300 Haar random unitaries, then performing a uniform
average over all these 300 unitaries. Our calculations for various values of K, together with
the standard deviation of the distribution of ˜P (K) are presented in Table 3.

K
h ˜P (K)i
hP (K)i

30

0.015%

0.021%

40

50

55

57

0.54%

9.30% 32.03% 50.89%

0.65% 10.11% 33.33% 52.20%

Std. Dev.

0.00005% 0.0014% 0.015% 0.035% 0.045%

Table 3: Analytical values (hP (K)i, and values computed with Perceval (h ˜P (K)i) of the probability
that all 14 photons gather in the ﬁrst K out of 60 output modes, for various values of K.

We observe a good agreement between the analytical values and the values computed
with Perceval , in particular when the value of K is close to 60. This is to be expected,
since these values of K are closest to the regime in which n(m−K) (cid:28) m, where it has been
shown [54] that hP (K)i is polynomially close to one in n and m, and therefore a poly(n, m)
number of samples from the Boson Sampler is enough to compute ˜P (K) to good precision
so as to allow a reliable certiﬁcation.

As a ﬁnal remark, note that Perceval can also simulate imperfect Boson Sampling,
where the imperfections integrated so far include photon loss and the possibility of multi-
photon emissions. For further details we refer the reader to the documentation.8

4.3 Grover’s Algorithm

4.3.1

Introduction

(cid:16)√

(cid:17)-runtime quantum algorithm for searching an unstruc-
Grover’s algorithm [2] is an O
tured database of size N . It is remarkable for providing a polynomial speedup over the
best known classical algorithm for this task, which runs in time O(N ). We now provide
an intuitive explanation of how this algorithm works, similar to that which can be found
in the Qiskit documentation9 or in [57].

N

We work in the n-qubit Hilbert space (C2)⊗n, which allows us to treat a database
In its standard formulation, the goal of Grover’s algorithm is to look
of size N = 2n.
for an unknown computational basis state |T i, which we will call the target state, with
T ∈ {0, 1}n.

8https://perceval.quandela.net/docs/

9https://qiskit.org/textbook/ch-algorithms/grover.html

15

Let |Ri be the (normalised) uniform superposition of all the N − 1 computational basis
states other than |T i, which is orthogonal to |T i. The uniform superposition |Si of all N
computational basis states can then be written as

|Si :=

1
√
N

|T i +

√

N − 1
√
N

|Ri.

(11)

Describing the problem setting in this way allows us to describe Grover’s algorithm in a
geometric picture. Indeed, we can now think of the states |T i, |Ri, and |Si as lying in a 2-
dimensional plane with a basis {|Ri, |T i}. For example, |Si forms an angle θ = arcsin( 1√
)
N
with respect to |Ri (or π

2 − θ with respect to |T i).

Grover’s algorithm relies on the application of two unitaries noted UO and Ud. The

former is an oracle unitary10 deﬁned on computational basis states |xi as

UO|xi :=

(−|xi
|xi

if x = T
otherwise

;

while the latter is the diﬀusion unitary Ud is deﬁned as

Ud := 2|SihS| − 1n ,

(12)

(13)

where 1n the n-qubit identity matrix. On the uniform superposition, the unitary UO acts
as

√

UO|Si := −

1
√
N

|T i +

N − 1
√
N

|Ri .

(14)

Geometrically, UO reﬂects the state |Si through the vector |Ri. Let’s call the resulting
reﬂected state |S0i. Then, Ud performs a reﬂection of |S0i through the vector |Si. Let the
resulting reﬂected state be denoted |SO,di. One can see that these transformations keep
the states in the same 2D-plane, and that |SO,di forms an angle of 2θ with respect to |Ri
2 − 2θ with respect to |T i). The state after applying UdUO is thus closer to |T i than
(or π
the initial state |Si was.

The reﬂections that we described correspond to one iteration of Grover’s algorithm.
The full algorithm ﬁrst creates the state |Si by applying n Hadamard gates H⊗n to an
input state |0i⊗n. It then transforms the state |Si into |T i by applying k times the unitary
UdUO to |Si. Following the geometric reasoning above, the required number of iterations
k is given by:



k ≈

(cid:25)

(cid:24) π

2 − θ
2θ

π
4arcsin( 1√
N

)

−

1
2

=











(cid:16)√

N

(cid:17)

,

≈ O

(15)

where d·e is the ceiling function.

As a closing remark, let us mention that the original version of Grover’s algorithm
presented here is non-deterministic, albeit with a probability of success approaching one
exponentially quickly with increasing N [2]. Fully deterministic versions of Grover’s algo-
rithm can be obtained, for example by using diﬀerent oracles and diﬀusion unitaries than
those used here [58], or by using two diﬀerent types of diﬀusion unitaries while keeping the
same UO [57].

10An oracle is a unitary which the algorithm can apply without having knowledge about its internal

implementation.

16

4.3.2 Perceval Implementation11

Here we reproduce the photonic demonstration of Grover’s algorithm of [59].
It uses
the spatial and polarisation degrees of freedom to implement a mode realisation of the
algorithm with two spatial modes. We spell out the correspondence between the marked
database element and the associated quantum state in Table 4.

Marked database element Quantum state

00
01
10
11

|0, P : Hi
|0, P : V i
|P : H, 0i
|P : V, 0i

Table 4: Equivalence between database elements and states in Perceval.

Quantum Circuit. Figure 7 represents the quantum circuit that implements Grover’s
algorithm on two qubits, encoded over two spatial modes and their polarisation modes as
described in Table 4. It features a state initialisation stage creating a uniform quantum
superposition over all states, an oracle stage, and a diﬀusion stage. Replacing N = 4 in
Equation 15 gives k ≈ π
2 = 1. Thus, one application of the oracle and diﬀusion gates
4. π
6
suﬃces.

− 1

|0is

|0ip

H

H

Oracle

H

H

|0is |0ip h0|s h0|p − 12

H

H

Figure 7: Quantum circuit implementing Grover’s algorithm using the spatial (s) and polarisation (p)
degrees of freedom. H denotes a Hadamard gate. The ﬁrst set of Hadamard gates creates a uniform
superposition over all states. Subsequently, the oracle is applied on the superposition, followed by a
Grover diﬀusion operation coupled to detection devices.

Linear Optical Circuit. The linear optical circuit we will use in our simulation is shown
in Figure 8. This circuit was experimentally realised by Kwiat et al. [59], by using bulk
optics components, and compiled to limit the number of optical elements introduced in the
experimental setup, by moving and combining operations like phase shifts.

Simulation. Here, we simulate in Perceval the linear optical circuit of [59] (see Figure
8), a photonic realisation of the quantum circuit in Figure 7, which implements Grover’s
algorithm for marked elements 00, 01, 10 and 11. The results are displayed in Figure 9,
along with the experimental results of Kwiat et al. [59].

4.4 Shor’s Algorithm

4.4.1

Introduction

The problem of factoring an integer is NP-intermediate and the best known classical algo-
rithms only achieve sub-exponential running times. Its classical complexity is well studied

11This implementation is accompanied by a notebook, which can be found in the Perceval documentation

at https://perceval.quandela.net/docs/notebooks/2-mode%20Grover%20algorithm.html.

17

Figure 8: Linear optical circuit implementing Grover’s algorithm. The oracle is set here to mark
the element ’00’, which encodes the state |0, P : Hi. Because the circuit has been compiled, the
initialisation, oracle and inversion stages do not strictly apply the expected operation. The half-wave
plates in this ﬁgure are followed by a −π/2 phase shift to match the half-wave plate deﬁnition of Kwiat
et al. The ﬁgure has been generated using Perceval.

Figure 9: Left: experimental results from Kwiat et al. [59]. Right: results of the simulation in Perceval.
The simulated results are as expected and thus match the results obtained in the experiment (up to
experimental error).

since it has been used as the basis of the most widely adopted encryption scheme, Rivest-
Shamir-Adleman (RSA) [60], where the secret key consists in two large primes p and q,
while their product N = pq is the corresponding public key. In this context, Shor’s algo-
rithm [1] greatly boosted interest in quantum algorithms by showing that such composite
numbers can in fact be factored in polynomial time on a quantum computer.

From Period-Finding to Factoring (Classically). We start by assuming that there
exists a period-ﬁnding algorithm for functions over integers given as a black-box. This
algorithm is used to ﬁnd the order of integers a in the ring ZN , i.e. the smallest value r
such that ar ≡ 1 (mod N ). In particular, the values of a are sampled at random until the
associated r is even.

r

Once such an a has been found,12 we have that ar − 1 = (a

2 − 1 (otherwise the period would be r/2). We test whether a

2 + 1) is a multiple
of N but not a
2 + 1 is a
multiple of N and if so restart the procedure.13 Otherwise, we have found a multiple of
2 + 1 divides a multiple of N . Taking the greatest
one of the prime factors p, q since a
2 + 1 and N easily yields this prime factor. Indeed, the GCD
common divisor (GCD) of a

r

r

r

r
2 − 1)(a

r

12Values of a that verify this property are common in ZN .

13It can be proven that the probability of not restarting at this step is high, and on average the algorithm

needs to be repeated only once.

18

can be found eﬃciently classically for example by using Euclid’s algorithm.

In summary, all the steps described are basic arithmetic operations, simple to imple-
ment on a classical machine, and most of the complexity is hidden in the period-ﬁnding
algorithm.

Shor’s Quantum Period-Finding Algorithm. The key contribution of Shor’s work
was to show that the period-ﬁnding algorithm can be done in polynomial time on a quantum
computer.

Indeed, ﬁnding the order for a value a can be reduced to a problem of phase estimation
for the unitary Ua implementing the Modular Exponentiation Function (MEF) x → ax
It can be shown that all eigenvalues of these
(mod N ) on computational basis states.
operators are of the form e
for an integer k and the value of interest r. The phase
estimation algorithm uses as basis the Quantum Fourier Transform and its inverse, along
with controlled versions of unitaries of the type Ua2p up to 2p ≈ N 2.14 This part of the
circuit is speciﬁc to the value of a and N and can therefore be optimised once they have
been chosen. Although the most costly part of the algorithm in terms of gates, the unitaries
C-Ua2p (controlled Ua2p gates) can still be implemented in polynomial time on a quantum
computer, making the overall procedure eﬃcient as well.

2iπk
r

4.4.2 Perceval Implementation15

Here we reproduce the photonic realisation of Shor’s algorithm from [61].

•

QFT−1

H

H

H

•

|0ix0

|0ix1

|0ix2

|0if1
|1if2

Figure 10: Quantum circuit implementing Shor’s algorithm for N = 15 and a = 2.

Quantum Circuit. The quantum circuit shown in Figure 10 for factoring N = 15 using
parameter a = 2, whose order is r = 4. It acts on 5 qubits labelled x0, x1, x2 (for the top
three) and f1, f2 (for the bottom two). The CNOT gates apply a version of the MEF which
has been optimised for this speciﬁc value of a to the qubits xi in superposition, storing the
outcome in qubits fi. The outcome is given by measuring the qubits x1, x2, followed by
classical post-processing.

Linear Optical Circuit. Since qubit x0 remains unentangled from the other qubits it
can be removed from the optical implementation of this circuit. Furthermore, the CNOT

14Using this family of unitaries reduces the precision required of the phase estimation procedure from

1/N 2 to constant.

15This implementation is accompanied by a notebook, which can be found in the Perceval documentation

at https://perceval.quandela.net/docs/notebooks/Shor%20Implementation.html.

19

gates on xi, fi can be realised as

CNOT1,2 = H2 ◦ CZ1,2 ◦ H2,

(16)

where the indices denote the qubits to which the gate is applied (in the case of CNOT,
the ﬁrst qubit is the control). Finally, the inverse Quantum Fourier Transform can be
performed via classical post-processing, and so does not need to be implemented as a
quantum gate in the circuit. The circuit after these simpliﬁcations is given in Figure 11.

|0ix1

|0ix2

|0if1

|1if2

H

•

H •

H

• H

H •

H

Figure 11: Simpliﬁed Shor quantum circuit.

The expected output state of the circuit above is

1
2

(|0ix1|0if1 + |1ix1|1if1) ⊗ (|0ix2|1if2 + |1ix2|0if2) .

(17)

We work with path encoded qubits, as in [61]. With path encoding, each H gate in the
quantum circuit is implemented with a beam splitter with reﬂectivity R = 1/2 between the
two paths corresponding to the qubit. In our implementation in Perceval , phase shifters
are added to properly tune the phase between each path.

CZ gates are implemented with 3 beam splitters with reﬂectivity R = 2/3 acting on
6 modes: one inner beam splitter creates interference between the two qubits, and two
outer beam splitter balance detection probability using auxiliary modes. This optical
implementation succesfully yields the output state produced by a CZ gate with probability
1/9; otherwise it creates a dummy state, which can be removed by post-selection.

The circuit implemented in Perceval is illustrated in Figure 12.
The matrix associated to the optical circuit, giving the probability amplitude of each

combination of input and output modes, is given in Figure 13.

Simulation. After entering the initial Fock state associated to the input qubit state
|0ix1|0ix2|0if1|1if2, we plot the probability amplitudes of the output state, post-selected
on Fock states corresponding to a qubit state with path encoding. The results are given
in Figure 14.

After re-normalisation we ﬁnd that the output amplitudes computed with Perceval

match the expected output state described in Equation 17 up to numerical precision.

When decomposing the expected output state in the qubit basis, the qubit states
with non-zero amplitude are |0001i, |0100i, |1011i and |1110i for qubits x1, x2, f1, f2.
We plot the output distribution of the circuit, post-selected on these states, without re-
normalisation; the result is presented in Table 5.

The distribution obtained with Perceval is uniform over each outcome, which matches

the expected distribution in [61].

20

Figure 12: Linear optical circuit implementing Shor’s algorithm. The 12 modes are ordered from 0 to
11, from top to bottom. Modes (1, 2), (3, 4), (7, 8), (9, 10) encode qubits x1, x2, f1, f2 respectively.
Modes 0, 5, 6, 11 are the auxiliary modes for CZ gates.

Figure 13: Unitary matrix associated with the optical circuit from Figure 12.

Outcome Distribution Interpretation. For each outcome, the values of qubits x2, x1,
x0 (with x0 = 0) represent a binary number between 0 and 7, here corresponding to 0, 4, 2, 6
in the order of Table 5. After sampling the circuit, obtaining outcomes 2 or 6 allows to
successfully compute the order r = 4 [61]. Obtaining outcome 0 is an expected failure of
the quantum circuit, inherent to Shor’s algorithm. Outcome 4 is an expected failure as
well, as it only allows to compute the trivial factors 1 and 15.

Since the distribution from Figure 5 is uniform the circuit successfully yields a successful
outcome with probability 1/2. This probability can be ampliﬁed exponentially close to 1
by sampling the circuit multiple times [61].

4.5 Variational Quantum Eigensolver

4.5.1

Introduction

The Variational Quantum Eigensolver (VQE) introduced by [12] is an algorithm for ﬁnding
eigenvalues of an operator. Applications range from ﬁnding ground state energies and

21

Figure 14: The output state amplitudes computed with Perceval, j2 = −1.

|0, 0, 0, 1i

|0, 1, 0, 0i

|1, 0, 1, 1i

|1, 1, 1, 0i

|0, 0, 0, 1i

0.003086

0.003086

0.003086

0.003086

Table 5: The output distribution for qubits x1, x2, f1, f2.

properties of atoms and molecules to various combinatorial optimisation problems.

Since the eigenvector |ψ∗i associated to the smallest eigenvalue of H minimises the

Rayleigh-Ritz quotient

,

(18)

hψ∗|H|ψ∗i
hψ∗|ψ∗i
the eigenvalue problem can be rephrased as a variational problem on this quantity. The
VQE algorithm uses as a sub-routine the Quantum Expectation Estimation (QEE) algo-
rithm, developed in the same paper, whose task is precisely to compute the expectation
value hHi := hψ|H|ψi of Hamiltonian H for an input state |ψi (here assumed to be nor-
malised). Given an ansatz represented by tunable experimental parameters {θi}, set to
i }, the VQE algorithm works by iterating a loop which ﬁrst applies
some initial values {θinit
the QEE algorithm on a state generated using the initial parameters {θinit
i }. Then, based
on the outcome, it tunes these parameters using a classical minimisation algorithm. This
process is repeated until a termination condition speciﬁed by the classical minimisation
algorithm is satisﬁed.

Let n be the number of qubits of our system, σx, σy, and σz the single qubit Pauli X,

Y, and Z matrices, and 1 the single qubit identity matrix.
Any n-qubit Hamiltonian H can be decomposed as

H = X
σ

hσσ,

(19)

where σ = ⊗n

i=1σi, σi ∈ {σx, σy, σz, 1}, and hσ ∈ R.

The expectation value hψ|σ|ψi of an n-qubit Pauli operator σ with respect to a state
|ψi can be estimated eﬃciently by performing local measurements on |ψi [12]. Thus, if
the number of terms in the sum in Equation 19 is poly(n), then computing hHi can be
performed eﬃciently on a quantum device, as it reduces to computing poly(n) expectations
of the form hψ|σ|ψi, each of which can be done eﬃciently.

22

4.5.2 Perceval Implementation16

Here we use Perceval to reproduce the original photonic implementation of the VQE from
[12]. For small enough instances of the problem, Perceval is able to compute explicitly the
complete state vector |ψi. This allows us to skip the QEE subroutine and directly compute
the mean value hHi.

Linear Optical Circuit. We use the linear optical circuit of the original paper [12]
which was ﬁrst introduced in [62]. The circuit has 6 optical modes, consists of 13 beam
splitters, 8 tunable phase shifters and 4 single-photon detectors, and is shown in Figure
15. This circuit is essentially a 2-qubit circuit where qubits 1 and 2 are path encoded
respectively in mode pairs (1, 2) and (3, 4) (here mode numbering is from 0 to 5, from
top to bottom). Modes 0 and 5 are auxiliary modes. The circuit consists of two parts.
The ﬁrst part being the 3 central beam splitters in Figure 15, together with the 2 beam
splitters to the left and right of these central beam splitters, and which act on modes 3
and 4. The 3 central beam splitters have reﬂectivity 1/3, whereas the two to the left and
right of the central ones have reﬂectivity 1/2. These 5 beam splitters are used, together
with modes 0 and 5, to apply a CNOT gate to qubits 1 and 2 [43]. This CNOT is successful
with probability 1/9 under post-selection. The second part of the circuit consists of the
remaining 8 beam splitters and phase shifters, and is used to implement arbitrary single
qubit rotations on qubits 1 and 2. All 8 phase shifters have tunable phase shifts, and all 8
beam splitters have reﬂectivity 1/2.

Figure 15: Linear optical circuit implementing the VQE algorithm. The 6 modes are ordered from
0 to 5. Modes (1, 2) and (3, 4) encode the 2 qubits. Modes 0 and 5 are the auxiliary modes for the
CNOT.

Simulation. Our strategy for the simulation of the VQE is as follows. We ﬁrst compute
the output state vector |ψi of the linear optical circuit, which depends on the phase shifters
parameters (φi)i∈{1,...,8} [12], for some random initial conﬁguration of these parameters.
This enables the evaluation of the Rayleigh-Ritz quotient in Equation 18. Then, we proceed
to minimise this quantity by using the Nelder-Mead minimisation algorithm [63].

Using these techniques, we computed the ground-state molecular energies for the Hamil-
tonians of three diﬀerent experiments [12] [64] [65]. To test the validity of our techniques,
we computed the theoretical ground-state molecular energies of the Hamiltonians of each
of the 3 experiments. This was done with the NumPy linear algebra package. A plot of
these energies computed both theoretically and with Perceval is shown in Figure 16.

16This implementation is accompanied by a notebook, which can be found in the Perceval documentation

at https://perceval.quandela.net/docs/notebooks/Variational%20Quantum%20Eigensolver.html.

23

(a) Perceval simulation of
the Hamiltonian given in [12].

(b) Perceval simulation of
the Hamiltonian given in [64].

(c) Perceval simulation of
the Hamiltonian given in [65].

Figure 16: Simulations of ground-state molecular energies.

We observe a very good overlap between the energies computed theoretically and with

Perceval , thereby indicating that our VQE simulations were successful.

4.6 Quantum Machine Learning

4.6.1

Introduction

Linear optics has proven to be a fascinating playground for exploring the advantages oﬀered
by quantum devices over their classical counterparts. For example, as discussed in Section
4.2, Boson Sampling [27], shows how a quantum device composed only of single photons,
linear optical circuits, and single-photon detectors, can perform a computational task which
quickly becomes unfeasible for the most powerful classical computers.

In [13], the authors show how linear optical circuits, similar to those used in Boson
Sampling, can be used to solve other problems of more practical use than sampling. The
basic idea is, following the work of [66, 67] for qubit-based quantum circuits, to encode
data points x ∈ R onto the angles of phase shifters of a universal linear optical circuit. Ef-
fectively, this allows a non-linear manipulation of these data points. Indeed, this encoding
of the data points x allows to express the expectation value of some observable, computed
using the linear optical circuit, as a Fourier series

f (x) = X
ω∈Ω

cωeiwx ,

(20)

of the data points x [13]. The Fourier series, being a well known universal (periodic)
function approximator, can be used for a variety of tasks, including approximating the
solution of diﬀerential equations, which we will study here.

Interestingly, Ω = {−n, . . . , n} where n is the number of photons inputted into the
linear optical circuit [13]; meaning that the expressivity of the Fourier series – how well it
can approximate a given function – depends (among other things) on the number of input
photons of the linear optical circuit.

In the coming sections, we give an example of a quantum machine learning algorithm,

using the above encoding, which solves a diﬀerential equation.

4.6.2 Expression of Photonic Quantum Circuit Expectation Values as Fourier Series

We focus on constructing a universal function approximator of a one-dimensional function
f (x) with a photonic quantum device of n photons and m modes. This device consists of
the following components: n sources of single photons, m-mode universal linear optical
circuits, and m number-resolving single-photon detectors [68]. Linear optical circuits can

24

5075100125150175200225250Atomic separation R (pm)5.755.705.655.605.555.50Energy (MJ/mol)Theoretical eigenvaluesEigenvalues computed with Perceval0.51.01.52.0Atomic separation R (Å)1.21.11.00.90.80.70.6Energy (MJ/mol)Theoretical eigenvaluesEigenvalues computed with Perceval0.51.01.52.02.5Atomic separation R (Å)1.21.11.00.90.80.70.6Energy (Hartree)Theoretical eigenvaluesEigenvalues computed with Percevalbe conﬁgured to implement m × m unitary matrices U . A linear optical circuit is called
universal if it can implement any such unitary U [33]. The n single photon sources produce
input Fock states of the form |n1, ..., nmi, where ni is the number of photons in mode i,
and P
i=1,..,m ni = n. The Fock space of n photons in m modes is isomorphic to the Hilbert
space CM , with M = (cid:0)m+n−1
(cid:1) [27]. This isomorphism, together with a homomorphism
from U(m) to U(M ) (the m and M -dimensional unitary groups) detailed in [27], allows to
understand the action of the m × m unitary U implemented by the linear optical circuit as
an M × M unitary U acting on the input Fock state. In the rest of this section, as in [13],
we will work with these M × M unitary matrices when computing the universal function
approximator.

n

The circuit architecture of [13] implements the M × M unitary transformation

U(x, θ) := W (2) (θ2) S(x)W (1) (θ1) .

(21)

The phase shift operator S(x) incorporates the x dependency of the function we wish to
approximate. It is sandwiched between two universal linear optical circuits W (1)(θ1) and
W (2)(θ2). The parameters (angles of beam splitters and phase shifters of the linear optical
circuits) θ1 and θ2 are tunable to enable training of the circuit, θ := {θ1, θ2}.

Let |n(i)i = |n(i)

1 , n(i)

2 , . . . , n(i)

m i be the input state consisting of n photons where n(i)
j

the number of photons in input mode j. Consider the operator M(λ), given by

is

M(λ) = X
|n(f )i

λ|n(f )i|n(f )ihn(f )| ,

(22)

where the sum is taken over all M possible Fock states |n(f )i of n photons in m modes,
and {λ|n(f )i} some tunable set of parameters. The expectation value
(cid:12) n(i)E

n(i) (cid:12)
D
(cid:12)U †(x, θ)M(λ)U(x, θ)
(cid:12)

f (n)(x, θ, λ) :=

(23)

(cid:12)
(cid:12)

,

of M(λ) with respect to the output state U(x, θ)|n(i)i of the linear optical circuit can be
computed by measuring the output modes of this circuit using number-resolving detectors.

f (n)(x, θ, λ) can be rewritten as the following Fourier series [13]

f (n)(x, θ, λ) = X
ω∈Ωn

cω(θ, λ)eiωx ,

(24)

where Ωn =
is the frequency spectrum one can reach with n incoming photons
and {cω(θ, λ)} are the Fourier coeﬃcients. Hence this speciﬁc architecture can be used as
a universal function approximator.

−n, n
(cid:75)
(cid:74)

4.6.3 Application to Diﬀerential Equation Solving

The most general form of a diﬀerential equation veriﬁed by a function f (x) is

F [{dmf /dxm}m , f, x] = 0 ,

(25)

F [.] being an operator acting on f (x), its derivatives and x.

Given such an expression, we wish to optimise the parameters θ such that f (n)(x, θ, λ)
is a good approximation to a solution f (x). More precisely, in this Quantum Machine
Learning task, we aim at minimising a loss function L(θ) whose value is related to the

25

closeness of our approximator to a solution. This is done via a classical optimisation of
the quantum free parameters θ, yielding ideally in the end

θ∗ := arg min

θ

L(θ) .

(26)

For the solving of diﬀerential equations, the loss function described in [69] consists of two
terms

Lθ [{dmg/dxm}m , f, x] := L(diﬀ)

θ

[{dmg/dxm}m , g, x] + L(boundary)

θ

[g, x] .

(27)

The ﬁrst term L(diﬀ)
been discretised over a set of M points {xi}:

θ

[{dmg/dxm}m , g, x] corresponds to the diﬀerential equation which has

L(diﬀ)
θ

[{dmg/dxm}m , g, x] :=

1
M

M
X

i=1

L (F [dm

x g (xi) , g (xi) , xi] , 0) ,

(28)

where L(a, b) := (a − b)2 for a, b ∈ R. The second term L(boundary)
θ
the initial conditions of our desired solution. It is deﬁned as

[g, x] is associated to

L(boundary)

θ

[g, x] := ηL (g(x0), f0) ,

(29)

where η is the weight granted to the boundary condition and f0 is given by f (x0) = f0, for
some initial data point x0. These functions will be applied to the iterated approximations
f (n)(x, θ, λ).

4.6.4 Perceval Implementation17

Our aim is to reproduce some of the results of [69], where the authors use so-called diﬀer-
entiable quantum circuits, together with classical optimisation algorithms, to provide an
approximation to the solution of the nonlinear diﬀerential equation

df
dx

+ λf (x)(κ + tan(λx)) = 0,

(30)

with λ, κ ∈ R, and boundary condition f (0) = f0 ∈ R. The analytical solution of this
diﬀerential equation is

f (x) = exp(−κλx) cos(λx) + f0 − 1.

(31)

Here, we solve this diﬀerential equation using the linear optical circuit architectures of
Section 4.6.2 simulated in Perceval , together with classical optimisation. Note that the
authors of [69] use Chebyshev polynomials as universal function approximators, whereas
here we will use the Fourier series.

In our Perceval implementation, η is chosen empirically as η = 5, granting suﬃcient
weight to the boundary condition. Concerning the λ parameters, each one of them is
sampled uniformly randomly in the interval {−200, . . . , 200}, which is also empirically
chosen. One could tune these λ parameters as well for greater accuracy, at the cost of
a considerably slower minimisation procedure. The number of modes m is taken to be
equal to the number of photons n. Diﬀerentiation is numerically conducted, df
, ∆x

dx ’ ∆f

∆x

17This implementation is accompanied by a notebook, which can be found in the Perceval documentation

at https://perceval.quandela.net/docs/notebooks/Differential%20equation%20solving.html.

26

taken as 10−3. The discretised version of the loss function is taken on a grid of 50 points,
uniformly spaced between 0 and 1.

Results are shown for various photon numbers in Figure 17a, demonstrating the in-
crease in expressivity of the quantum circuit with growing n. The converged solution for 6
input photons provides a convincing approximation to the analytical solution. Increasing
the number of photons further should yield even more accurate results, allowing for the
realisation of more complex Quantum Machine Learning tasks.

A common indicator of the performance of a machine learning algorithm is the conver-
gence of its loss function [70]. Conﬁrming the results from Figure 17a, additional photons
allow us to reach lower values of the loss function, as shown in Figure 17b. However this
results in a longer convergence time due to an increased number of tunable parameters.
Further details concerning the simulation in Perceval can be found in the documentation.

(a) Comparison of the analytical solution to the
considered diﬀerential equation to converged solu-
tions of the discretised quantum loss function in
terms of input photon number. Parameters of the
diﬀerential equation are taken as λ = 8, κ = 0.1,
f0 = 1 matching that of [69].

(b) Loss evolution as a function of the number of
epochs for various input photon numbers.

Figure 17: Results of QML simulation using Perceval.

To summarise, we have used Perceval to simulate linear optical circuits providing uni-
versal function approximators [13], and shown that these can be used together with tech-
niques from Quantum Machine Learning to accurately compute the solutions of diﬀerential
equations. The accuracy of these function approximators depends, among other things, on
the number of input photons of the linear optical circuits. An interesting future direction
we aim to pursue is using Perceval and our developed techniques to solve other types of
diﬀerential equations of signiﬁcant practical interest [71, 72].

5 Conclusion

Perceval is a unique framework dedicated to linear optics and photonic quantum comput-
ing. This white paper has aimed to provide an overview of the platform, the motivations
for its development, it’s structure and main features, and to give a variety of examples of
Perceval in action. These examples are intended to be illustrative of some of the immediate
uses of the platform.

Perceval ’s simulation back-ends are optimised to run on local desktop devices, with
extensions for HPC clusters. They can be used to run computational experiments to ﬁne-

27

0.00.20.40.60.81.0x0.50.00.51.0yAnalytical solution3 photons4 photons5 photons6 photons0100200300Number of epochs101101103105107Loss function value3 photons4 photons5 photons6 photonstune algorithms, compare with experimental data from actual experiments and photonic
quantum computing platforms, and can reproduce published articles in few lines of code.
Perceval is intended to be accessible to physicists, both experimental and theoretical,
and computer scientists alike, with a goal of providing a bridge between these communi-
ties. With the intention of keeping a strong connection between software and hardware for
photonic quantum computing, a major focus of future development will be on the contin-
ued development of realistic noise-models, that can describe with increasing accuracy the
functioning of speciﬁc hardware components.

Perceval allows users to design algorithms and linear optical circuits through a large
collection of predeﬁned components. The collection of algorithms described here are avail-
able and presented as tutorials in the documentation. This is an open source project, with
a modular architecture, and is welcoming of contributions from the community.

Acknowledgements

The authors wish to thank Mario Valdiva for invaluable technical support, Arno Ricou for
code and discussions on variational algorithms, and Jeanne Bourgeois, William Howard,
Rayen Mahjoub, and Bechara Nasr, whose internships nourished early developments on
the way to this paper.

References

[1] Shor, P., “Algorithms for quantum computation: discrete logarithms and factoring,”

in Proceedings 35th Annual Symposium on Foundations of Computer Science,
pp. 124–134. IEEE, Nov., 1994.

[2] Grover, L.K., “A fast quantum mechanical algorithm for database search,” in

Proceedings of the twenty-eighth annual ACM symposium on Theory of Computing,
STOC ’96, pp. 212–219. Association for Computing Machinery, July, 1996.
[3] Preskill, J., “Quantum computing in the NISQ era and beyond,” Quantum 2, 79

(2018).

[4] Preskill, J., “Quantum computing and the entanglement frontier,” arXiv:1203.5813

[quant-ph] (2011).

[5] Arute, F., Arya, K., Babbush, R., Bacon, D. et al, “Quantum supremacy using a

programmable superconducting processor,” Nature 574, 505–510 (2019).

[6] Zhong, H.S., Wang, H., Deng, Y.H., Chen, M.C. et al, “Quantum computational

advantage using photons,” Science 370, 1460–1463 (2020).

[7] Wu, Y., Bao, W.S., Cao, S., Chen, F. et al, “Strong quantum computational

advantage using a superconducting quantum processor,” Physical Review Letters
127, 180501 (2021).

[8] Zhong, H.S., Deng, Y.H., Qin, J., Wang, H. et al, “Phase-programmable Gaussian
Boson Sampling using stimulated squeezed light,” Physical Review Letters 127,
180502 (2021). Publisher: American Physical Society.

[9] Nikolopoulos, G.M. and Brougham, T., “Decision and function problems based on

Boson Sampling,” Physical Review A 94, 012315 (2016).

[10] Nikolopoulos, G.M., “Cryptographic One-Way Function based on Boson Sampling,”

Quantum Information Processing 18, 259 (2019).

[11] Banchi, L., Fingerhuth, M., Babej, T., Ing, C. and Arrazola, J.M., “Molecular

docking with Gaussian Boson Sampling,” Science Advances 6, eaax1950 (2020).

28

[12] Peruzzo, A., McClean, J., Shadbolt, P., Yung, M.H. et al, “A variational eigenvalue
solver on a photonic quantum processor,” Nature Communications 5, 4213 (2014).
[13] Gan, B.Y., Leykam, D. and Angelakis, D.G., “Fock State-enhanced expressivity of
Quantum Machine Learning models,” in Conference on Lasers and Electro-Optics,
p. JW1A.73. Optica Publishing Group, 2021.

[14] Farhi, E., Goldstone, J. and Gutmann, S., “A Quantum Approximate Optimization

Algorithm,” arXiv:1411.4028 [quant-ph] (2014).

[15] Bharti, K., Cervera-Lierta, A., Kyaw, T.H., Haug, T. et al, “Noisy intermediate-scale

quantum algorithms,” Rev. Mod. Phys. 94, 015004 (2022).

[16] Cao, Y., Romero, J., Olson, J.P., Degroote, M. et al, “Quantum chemistry in the age

of quantum computing,” Chemical Reviews 119, 10856–10915 (2019).

[17] McArdle, S., Endo, S., Aspuru-Guzik, A., Benjamin, S.C. and Yuan, X., “Quantum

computational chemistry,” Rev. Mod. Phys. 92, 015003 (2020).

[18] Jiang, Z., Sung, K.J., Kechedzhi, K., Smelyanskiy, V.N. and Boixo, S., “Quantum
algorithms to simulate many-body physics of correlated fermions,” Phys. Rev.
Applied 9, 044036 (2018).

[19] Davoudi, Z., Hafezi, M., Monroe, C., Pagano, G. et al, “Towards analog quantum

simulations of lattice gauge theories with trapped ions,” Phys. Rev. Research 2,
023015 (2020).

[20] Vikstål, P., Grönkvist, M., Svensson, M., Andersson, M. et al, “Applying the

Quantum Approximate Optimization Algorithm to the tail-assignment problem,”
Phys. Rev. Applied 14, 034009 (2020).

[21] Zhu, L., Tang, H.L., Barron, G.S., Calderon-Vargas, F.A. et al, “An adaptive

quantum approximate optimization algorithm for solving combinatorial problems on
a quantum computer,” arXiv.2005.10258 [quant-ph] (2020).

[22] Schuld, M., Brádler, K., Israel, R., Su, D. and Gupt, B., “Measuring the similarity of

graphs with a Gaussian Boson sampler,” Phys. Rev. A 101, 032314 (2020).
[23] Huang, H.Y., Broughton, M., Cotler, J., Chen, S. et al, “Quantum advantage in

learning from experiments,” arXiv.2112.00778 [quant-ph] (2021).

[24] Knill, E., Laﬂamme, R. and Milburn, G.J., “A scheme for eﬃcient quantum

computation with linear optics,” Nature 409, 46–52 (2001).

[25] Kieling, K., Rudolph, T. and Eisert, J., “Percolation, renormalization, and quantum
computing with nondeterministic gates,” Physical Review Letters 99, 130501 (2007).

[26] Bartolucci, S., Birchall, P., Bombin, H., Cable, H. et al, “Fusion-based quantum

computation,” arXiv:2101.09310 [quant-ph] (2021).

[27] Aaronson, S. and Arkhipov, A., “The computational complexity of linear optics,” in
Proceedings of the forty-third annual ACM symposium on Theory of computing,
STOC ’11, pp. 333–342. Association for Computing Machinery, June, 2011.
[28] Killoran, N., Izaac, J., Quesada, N., Bergholm, V. et al, “Strawberry Fields: A
software platform for photonic quantum computing,” Quantum 3, 129 (2019).
[29] Fingerhuth, M., Babej, T. and Wittek, P., “Open source software in quantum

computing,” PLOS ONE 13, e0208561 (2018).

[30] Aguado, D.G., Gimeno, V., Moyano-Fernández, J.J. and Garcia-Escartin, J.C.,

“QOptCraft: A Python package for the design and study of linear optical quantum
systems,” arXiv.2108.06186 [quant-ph] (2021).

[31] Kok, P., Munro, W.J., Nemoto, K., Ralph, T.C. et al, “Linear optical quantum

computing with photonic qubits,” Rev. Mod. Phys. 79, 135–174 (2007).

[32] Kok, P. and Lovett, B.W., “Introduction to optical quantum information

processing,”. Cambridge University Press, 2010.

29

[33] Reck, M., Zeilinger, A., Bernstein, H.J. and Bertani, P., “Experimental realization of

any discrete unitary operator,” Phys. Rev. Lett. 73, 58–61 (1994).

[34] Clements, W.R., Humphreys, P.C., Metcalf, B.J., Kolthammer, W.S. and Walmsley,

I.A., “Optimal design for universal multiport interferometers,” Optica 3, 1460–1465
(2016).

[35] Chekhova, M. and Banzer, P., “Polarization of Light: In Classical, Quantum, and

Nonlinear Optics,”. De Gruyter, 2021.

[36] Valiant, L.G., “The complexity of computing the permanent,” Theoretical Computer

Science 8, 189–201 (1979).

[37] Spedalieri, F., Lee, H., Lee, H., Dowling, J. and Dowling, J., “Linear optical

quantum computing with polarization encoding,” in Frontiers in Optics (2005),
paper LMB4, p. LMB4. Optica Publishing Group, Oct., 2005.

[38] Cliﬀord, P. and Cliﬀord, R., “The classical complexity of Boson Sampling,” in

Proceedings of the 2018 Annual ACM-SIAM Symposium on Discrete Algorithms
(SODA), Proceedings, pp. 146–155. Society for Industrial and Applied Mathematics,
Jan., 2018.

[39] Glynn, D.G., “The permanent of a square matrix,” European Journal of

Combinatorics 31, 1887–1891 (2010).

[40] Cliﬀord, P. and Cliﬀord, R., “Faster classical Boson Sampling,” arXiv:2005.04214

[quant-ph] (2020).

[41] Heurtel, N., Mansﬁeld, S., Senellart, J. and Valiron, B., “Strong Simulation of Linear

Optical Processes,”. In preparation.

[42] Ryser, H.J., “Combinatorial mathematics,”, vol. 14. American Mathematical Society,

1963.

[43] Ralph, T.C., Langford, N.K., Bell, T.B. and White, A.G., “Linear optical

controlled-NOT gate in the coincidence basis,” Physical Review A 65, 062324 (2002).
[44] Hong, C.K., Ou, Z.Y. and Mandel, L., “Measurement of subpicosecond time intervals
between two photons by interference,” Physical Review Letters 59, 2044–2046 (1987).
Publisher: American Physical Society.

[45] Santori, C., Fattal, D., Vučković, J., Solomon, G.S. and Yamamoto, Y.,

“Indistinguishable photons from a single-photon device,” Nature 419, 594–597 (2002).

[46] Giesz, V., Cavity-enhanced photon-photon interactions with bright quantum dot

sources. Theses, Université Paris Saclay (COmUE), Dec., 2015.

[47] Mezher, R. and Mansﬁeld, S., “Assessing the quality of near-term photonic quantum

devices,” arXiv:2202.04735 [quant-ph] (2022).

[48] Brualdi, R.A. and Ryser, H.J., “Combinatorial Matrix Theory,”. Encyclopedia of

Mathematics and its Applications. Cambridge University Press, 1991.

[49] Aaronson, S. and Brod, D.J., “BosonSampling with lost photons,” Phys. Rev. A 93,

012335 (2016).

[50] Arkhipov, A., “BosonSampling is robust against small errors in the network matrix,”

Phys. Rev. A 92, 062326 (2015).

[51] Kalai, G. and Kindler, G., “Gaussian noise sensitivity and Boson Sampling,”

arXiv:1409.3093 [quant-ph] (2014).

[52] Russell, N.J., Chakhmakhchyan, L., O’Brien, J.L. and Laing, A., “Direct dialling of

Haar random unitary matrices,” New Journal of Physics 19, 033007 (2017).
[53] Wang, H., Qin, J., Ding, X., Chen, M.C. et al, “Boson Sampling with 20 input

photons and a 60-mode interferometer in a 1014-dimensional Hilbert space,” Physical
Review Letters 123, 250503 (2019).

30

[54] Shchesnovich, V.S., “Universality of generalized bunching and eﬃcient assessment of

Boson Sampling,” Phys. Rev. Lett. 116, 123601 (2016).

[55] Tichy, M.C., Mayer, K., Buchleitner, A. and Mølmer, K., “Stringent and eﬃcient
assessment of Boson-Sampling devices,” Phys. Rev. Lett. 113, 020502 (2014).
[56] Walschaers, M., Kuipers, J., Urbina, J.D., Mayer, K. et al, “Statistical benchmark

for BosonSampling,” New Journal of Physics 18, 032001 (2016).

[57] Roy, T., Jiang, L. and Schuster, D.I., “Deterministic Grover search with a restricted

oracle,” arXiv:2201.00091 [quant-ph] (2022).

[58] Long, G.L., “Grover algorithm with zero theoretical failure rate,” Phys. Rev. A 64,

022307 (2001).

[59] Kwiat, P.G., Mitchell, J.R., Schwindt, P.D.D. and White, A.G., “Grover’s search
algorithm: An optical approach,” Journal of Modern Optics 47, 257–266 (2000).

[60] Rivest, R.L., Shamir, A. and Adleman, L., “A Method for Obtaining Digital

Signatures and Public-Key Cryptosystems,” Commun. ACM 21, 120–126 (1978).
[61] Politi, A., Matthews, J.C.F. and O’Brien, J.L., “Shor’s quantum factoring algorithm

on a photonic chip,” Science 325, 1221–1221 (2009).

[62] Shadbolt, P.J., Verde, M.R., Peruzzo, A., Politi, A. et al, “Generating, manipulating
and measuring entanglement and mixture with a reconﬁgurable photonic circuit,”
Nature Photonics 6, 45–49 (2012).

[63] Nelder, J.A. and Mead, R., “A Simplex Method for Function Minimization,” The

Computer Journal 7, 308–313 (1965).

[64] O’Malley, P.J.J., Babbush, R., Kivlichan, I.D., Romero, J. et al, “Scalable quantum

simulation of molecular energies,” Phys. Rev. X 6, 031007 (2016).

[65] Colless, J.I., Ramasesh, V.V., Dahlen, D., Blok, M.S. et al, “Computation of

molecular spectra on a quantum processor with an error-resilient algorithm,” Phys.
Rev. X 8, 011021 (2018).

[66] Pérez-Salinas, A., Cervera-Lierta, A., Gil-Fuster, E. and Latorre, J.I., “Data
re-uploading for a universal quantum classiﬁer,” Quantum 4, 226 (2020).

[67] Schuld, M., Sweke, R. and Meyer, J.J., “Eﬀect of data encoding on the expressive
power of variational quantum-machine-learning models,” Phys. Rev. A 103, 032430
(2021).

[68] Hadﬁeld, R.H., “Single-photon detectors for optical quantum information

applications,” Nature Photonics 3, 696–705 (2009).

[69] Kyriienko, O., Paine, A.E. and Elfving, V.E., “Solving nonlinear diﬀerential

equations with diﬀerentiable quantum circuits,” Physical Review A 103, 052416
(2021).

[70] Raschka, S. and Mirjalili, V., “Python machine learning: Machine learning and deep
learning with Python, scikit-learn, and TensorFlow 2,”. Packt Publishing Ltd, 2019.

[71] Widder, D.V., “The heat equation,”, vol. 67. Academic Press, 1976.
[72] Constantin, P. and Foias, C., “Navier-stokes equations,”. University of Chicago

Press, 2020.

31

