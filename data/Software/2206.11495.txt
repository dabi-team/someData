Camera-ready version of this paper is published in Formal Aspects of Computing, 2022

2
2
0
2

n
u
J

3
2

]

O
L
.
s
c
[

1
v
5
9
4
1
1
.
6
0
2
2
:
v
i
X
r
a

Algebra-Based Reasoning for Loop
Synthesis
Andreas Humenberger1, Daneshvar Amrollahi1, Nikolaj Bjørner2 and Laura Kov´acs1
1TU Wien, Austria
2Microsoft Research

Abstract. Provably correct software is one of the key challenges of our software-driven society. Program synthesis –
the task of constructing a program satisfying a given speciﬁcation – is one strategy for achieving this. The result of
this task is then a program which is correct by design. As in the domain of program veriﬁcation, handling loops is one
of the main ingredients to a successful synthesis procedure.

We present an algorithm for synthesizing loops satisfying a given polynomial loop invariant. The class of loops
we are considering can be modeled by a system of algebraic recurrence equations with constant coefﬁcients, encoding
thus program loops with afﬁne operations among program variables. We turn the task of loop synthesis into a poly-
nomial constraint problem, by precisely characterizing the set of all loops satisfying the given invariant. We prove
soundness of our approach, as well as its completeness with respect to an a priori ﬁxed upper bound on the number of
program variables. Our work has applications towards synthesizing loops satisfying a given polynomial loop invariant,
program veriﬁcation, as well as generating number sequences from algebraic relations. To understand viability of the
methodology and heuristics for synthesizing loops, we implement and evaluate the method using the Absynth tool.

This paper is an extended version of the “Algebra-Based Loop Synthesis” manuscript published at iFM 2020.

Keywords: Symbolic Computation; Linear Recurrences; Program Synthesis; Loop Invariants; SMT Solving

1. Introduction

The two most rigorous approaches for providing correct software are given by formal program veriﬁcation and program
synthesis [SGF10]. The task of formal veriﬁcation is to prove correctness of a given program with respect to a given
(logical) speciﬁcation. On the other hand, program synthesis aims at generating programs which adhere to a given
speciﬁcation. The result of a synthesis problem is therefore a program which is correct by construction. While formal
veriﬁcation has received considerable attention with impressive results, for example, in ensuring safety of device
drivers [BLR11] and security of web services [Coo18], program synthesis turns out to be an algorithmically much
more difﬁcult challenge [KMPS12].

The classical setting of program synthesis has been to synthesize programs from proofs of logical speciﬁcations
that relate the inputs and the outputs, in short inputs-outputs, of the program [MW80]. Thanks to recent successful

Correspondence and offprint requests to: Laura Ko´acs, TU Wien, e-mail: laura.kovacs@tuwien.ac.at

 
 
 
 
 
 
2

Humenberger et al

trends in formal veriﬁcation based on automated reasoning [DMB08, Dut14, KV13], this traditional view of pro-
gram synthesis has been reﬁned to the setting of syntax-guided synthesis (SyGuS) [ABD+15]. In addition to logical
speciﬁcations, SyGuS approaches consider further constraints on the program templates to be synthesized, thus lim-
iting the search space of possible solutions. A wide range of efﬁcient applications of SyGuS have so far emerged,
for example programming by examples [Gul16], component-based synthesis [JGST10] with learning [FMBD18] and
sketching [NHTSL19].

Yet, both in the setting of veriﬁcation and synthesis, one of the main challenges is to verify and/or synthesize
loops/recursion. In veriﬁcation, solving this challenge requires generating additional program assertions in the form
of loop invariants [RK07, HJK17, KCBR18]. Intuitively, a loop invariant is a formal description of the behavior
of the loop, expressing loop properties that hold before and after each loop iteration. In synthesis, the challenge of
reasoning with loops comes by answering the question whether there exists a loop satisfying a given loop invariant and
constructively synthesizing a loop with respect to a given invariant. We refer to this task of synthesis as loop synthesis.
Note that loop synthesis can be considered as the reverse problem of loop invariant generation: rather than generating
invariants summarizing a given loop, we synthesize loops whose summaries are captured by a given invariant property.
In this paper, we present an algorithmic approach to loop synthesis, by relying on the theory of algebraic recur-
rence equations [KP11]. We synthesize and optimize loops whose functional behavior is captured by a given invariant
p(x) = 0, such that the synthesized loops use only afﬁne computations among x. We deﬁne our loop synthesis task as
follows:

LOOP SYNTHESIS

Given a polynomial property p(x) over a set x of variables,
generate a loop

with afﬁne operations over variables x, such that p(x) = 0 is an invariant of the loop.

L

While our loop synthesis problem is formulated such that only one loop satisfying a given polynomial invariant
p(x) = 0 is captured, we note that in our work we ﬁrst characterize all loops for which p(x) = 0 is an invariant
(Section 4) and then extract one loop by optimizing the set of all loop solutions (Section 5). One such optimization
criteria comes, for example, with avoiding trivial solutions, that is avoiding loops whose afﬁne updates do not change
values of loop variables.

We believe our work is the ﬁrst complete technique for synthesizing loops from (non-linear) polynomial invariants.
The key ingredient of our work comes with the reduction of loop synthesis to the problem of solving algebraic recur-
rences among loop variables. The inner algorithmic magic of our approach is an SMT-based solution towards solving
non-linear algebraic constraints, allowing us to test existential properties of bounded degree polynomials (invariants)
to derive universal (loop) relations.

Motivating Example. Let us ﬁrst motivate loop synthesis using Figure 1a. The loop is based on an online tutorial1
of the Dafny veriﬁcation framework [Lei17]: Figure 1a uses only afﬁne updates among its variables, and the task is
0 and post-condition
to revise/repair Figure 1a into a partially correct program with respect to the precondition N
≥
c = N 3 such that the polynomial loop invariant n
m = 6n + 6 holds. We
∧
note that our focus in on partially correct programs [Hoa69], and thus we do not consider total correctness, that is loop
termination.

k = 3n2 + 3n + 1

c = n3

N

≤

∧

∧

In this paper we introduce an algorithmic approach to loop synthesis by relying on algebraic recurrence equa-
tions and constraint solving over polynomials. In particular, we automatically synthesize Figures 1b-1c by using the
given non-linear polynomial equalities c = n3
m = 6n + 6 as input invariant to our
loop synthesis task. Both synthesized programs, with the loop guard n < N as in Figure 1a, are partially correct
program with respect to the given requirements. Moreover, Figures 1b-1c precisely capture the solution space of
c = n3
m = 6n + 6, by implementing only afﬁne operations.

k = 3n2 + 3n + 1

k = 3n2 + 3n + 1

∧

∧

∧

∧

Algebra-based Loop Synthesis. Inspired by syntax-guided synthesis – SyGuS [ABD+15], we consider our loop syn-
thesis task with additional requirements on the loop to be synthesized: we impose syntactic requirements on the form
of loop expressions and guards to be synthesized. The imposed requirements allow us to reduce the loop synthesis task
to the problem of generating linear/afﬁne recurrences with constant coefﬁcients, called C-ﬁnite recurrences [KP11].

1 https://rise4fun.com/Dafny/

Algebra-Based Reasoning for Loop Synthesis

3

(0, 0, 0, 0)

←

(c, k, m, n)
while n < N do
c + k
k + m
m + 9
n + 1

c
k
m
n
end

←
←
←
←

(0, 1 , 6 , 0)

←

(c, k, m, n)
while n < N do
c + k
k + m
m + 6
n + 1

c
k
m
n
end

←
←
←
←

(0, 1 , 6 , 0)

←

(c, k, m, n)
while n < N do
c + k
k + 6n + 6
m + 6
n + 1

c
k
m
n
end

←
←
←
←

(a) Faulty loop

(b) Synthesized loop

(c) Synthesized loop

Fig. 1. Examples of loop synthesis. Figures 1b-1c are revised versions of Figure 1a such that the expression
c = n3

m = 6n + 6 is an invariant of Figures 1b-1c.

k = 3n2 + 3n + 1

∧

∧

As such, loop synthesis provides an algorithmic solution to the following loop reasoning challenge: Given a polyno-
mial p(x) over loop variables x, how can the entire solution space of p(x) = 0 be iteratively computed using only
afﬁne operations inducing C-ﬁnite number sequences among x?

∧

∧

Our approach to synthesis is however conceptually different from other SyGuS-based methods, such as [Gul16,
FMBD18, NHTSL19]: rather than iteratively reﬁning both the input and the solution space of synthesized programs,
we take polynomial relations describing a potentially inﬁnite set of input values and precisely capture not just one
loop, but the set of all loops (i) whose invariant is given by our input polynomial and (ii) whose variables induce
C-ﬁnite number sequences. Any instance of this set therefore yields a loop that is partially correct by construction and
only implements afﬁne computations. Figures 1b-1c depict two solutions of our loop synthesis task for the invariant
c = n3

k = 3n2 + 3n + 1

m = 6n + 6.

The main steps of our approach are as follows. (i) Let p(x) be a polynomial over variables x and let s

0 be
an upper bound on the number of program variables to be used in the loop. If not speciﬁed, s is considered to be the
number of variables from x. (ii) We use syntactic constraints over the loop body to be synthesized and deﬁne a loop
template, as given by our programming model (8). Our programming model imposes that the functional behavior of the
synthesized loops can be modeled by a system of C-ﬁnite recurrences (Section 3). (iii) By using the invariant property
of p(x) = 0 for the loops to the synthesized, we construct a polynomial constraint problem (PCP) characterizing
the set of all loops satisfying the constraints of (8) for which p(x) = 0 is a loop invariant (Section 4). Our approach
combines symbolic computation techniques over algebraic recurrence equations with polynomial constraint solving.
We prove that our approach to loop synthesis is both sound and complete. By completeness we mean that if there is
with at most s variables satisfying the invariant p(x) = 0 such that the loop body meets our C-ﬁnite/afﬁne
a loop
is synthesized by our method (Theorem 4.2). Moving beyond s, that is, deriving an
syntactic requirements, then
L
upper bound on the number of program variables from the invariant, is interesting further work, with connections to
the inverse problem of difference Galois theory [VdPS97].

≥

L

We ﬁnally note that our work is not restricted to speciﬁcations given by a single polynomial equality invariant.
Rather, the invariant given as input to our synthesis approach can be conjunctions of polynomial equalities – as also
shown in Figure 1.

Beyond Loop Synthesis. Our work has applications beyond loop synthesis – such as in generating number sequences
from algebraic relations and program/compiler optimizations.

Generating number sequences. Our approach provides a partial solution to an open mathematical problem: given
a polynomial relation among number sequences, e.g.

•

f (n)4 + 2f (n)3f (n + 1)

f (n)2f (n + 1)2

−

−

2f (n)f (n + 1)3 + f (n + 1)4 = 1,

(1)

synthesize algebraic recurrences deﬁning these sequences. There exists no complete method for solving this chal-
lenge, but we give a complete approach in the C-ﬁnite setting parameterized by an a priori bound s on the order of
the recurrences. For the given relation (1) among f (n) and f (n + 1), our work generates the C-ﬁnite recurrence
equation f (n + 2) = f (n + 1) + f (n) which induces the Fibonacci sequence.
Program optimizations. Given a polynomial invariant, our approach generates a PCP such that any solution to
this PCP yields a loop satisfying the given invariant. By using additional constraints encoding a cost function on
the loops to be synthesized, our method can be extended to synthesize loops that are optimal with respect to the
considered costs, for example synthesizing loops that use only addition in variable updates. Consider for example

•

4

•

•

•

Humenberger et al

Figures 1b-1c: the loop body of Figure 1b uses only addition, whereas Figure 1c implements also multiplications
by constants.

Compiler optimizations. To reduce execution time spent within loops, compiler optimization techniques, such as
strength reduction, aim at replacing expensive loop operations with semantically equivalent but less expensive
operations [CSV01]. One such optimization within strength reduction replaces “strong” loop multiplications by
additions among program variables. The burden of strength reductions comes however with identifying inductive
loop variables and invariants to be used for loop optimization. Our loop synthesis method therefore serves as
a foundation for strength reduction optimization, by converting polynomial (loop) expressions into incremental
afﬁne (loop) computations.

Invariant generation and loop equivalence. Our approach may improve the state-of-the-art in polynomial invariant
generation, as follows. By considering a loop L, let I denote the polynomial loop invariant of L generated by
existing invariant generation approaches, such as [RK07, HJK17, KCBR18, HOPW18]. By using I as our input,
our technique synthesizes a loop L′ that is (relational) equivalent to L in the sense that both L and L′ have the
same invariant I. We showcase such use case of our synthesis approach in Section 7.1. We further note, that our
loop synthesis task can also be used to check soundness/completeness of existing invariant generation techniques:
apply invariant generation approaches on L′ with the goal of deriving the invariant I.
Teaching formal methods. Finally, our work can also be used in solving formal veriﬁcation challenges, as follows.
By considering examples that are not partially correct with respect to a given invariant, the task is to revise these
programs into correct ones. By using the given invariants as inputs to our approach, we automatically infer partially
correct programs, thus allowing users/teachers/practitioners of formal methods to repair programs in a fully auto-
mated manner. This use-case of loop synthesis has been deployed in our “Formal Methods in Computer Science”
master course at the TU Wien, in particular in generating and correcting course assignments on deductive program
veriﬁcation, as discussed in Section 7.2.

Contributions. This paper brings integrated approaches to formal modelling and analysis of software, by combining
symbolic computation, program analysis and SMT reasoning. In summary, we make the following contributions.

We propose an automated procedure for synthesizing loops that are partially correct with respect to a given polyno-
mial loop invariant (Section 4). By exploiting properties of C-ﬁnite sequences, we construct a PCP which precisely
captures all solutions of our loop synthesis task. We are not aware of previous approaches synthesizing loops from
(non-linear) polynomial invariants.

We also synthesize the initial values of the loop variables, that is, the values before executing the loop. We ﬁrst
consider loops with concrete initial values, so-called non-parameterized loops (Section 4.2). We then reﬁne our
technique towards the synthesis of parameterized loops, that is, loops with symbolic initial values (Section 4.3).

We prove that our approach to loop synthesis is sound and complete (Theorem 4.2). That is, if there is a loop
whose invariant is captured by our given speciﬁcation, our approach synthesizes this loop. To this end, we consider
completeness modulo an a priori ﬁxed upper bound s on the number of loop variables.
We extend our task of loop synthesis with additional constraints, for optimizing the solution space of our PCP
(Section 5). These optimizations are essential in automating loop synthesis.

We implemented our approach in the new open-source framework Absynth. We ﬁrst evaluated our work on a
number of academic examples on loop analysis as well as on generating number sequences in algorithmic combi-
natorics (Section 6).

We further used our work in the context of loop equivalence and report on our experience in using loop synthesis
as a work-horse for teaching formal methods at the TU Wien (Section 7).

•

•

•

•

•

•

Relation to our previous work [HBK20]. This paper extends our previous work [HBK20] in a number of ways, as
summarized below. In Section 2, we provide additional algebraic results and insights needed for translating the task
of loop into a recurrence solving problem in Section 4.3. Soundness and completeness proofs of our key results are
given in Section 4, together with illustrative examples showcasing the main steps of loop synthesis. Further and most
importantly, Section 4.3 extends [HBK20] with loop synthesis for parametrized loops. Section 6.3 presents illustrative
examples from our loop synthesis experiments and Section 7 reports on using loop synthesis for loop equivalence and
teaching formal methods.

Algebra-Based Reasoning for Loop Synthesis

5

2. Preliminaries

Let K be a computable ﬁeld with characteristic zero. We also assume K to be algebraically closed, that is, every non-
constant polynomial in K[x] has at least one root in K. The algebraic closure ¯Q of the ﬁeld of rational numbers Q is
such a ﬁeld; ¯Q is called the ﬁeld of algebraic numbers.

We denote by K[x1, . . . , xn] the multivariate polynomial ring with indeterminates x1, . . . , xn. For a list x1, . . . , xn,
we write x if the number of variables is known from the context or irrelevant. As K is algebraically closed, every
polynomial p

K[x] of degree r has exactly r roots. Therefore, the following theorem follows immediately:

∈

Theorem 2.1. The zero polynomial is the only polynomial in K[x] having inﬁnitely many roots.

2.1. Polynomial Constraint Problem (PCP)

A polynomial constraint F is of the form p ⊲⊳ 0 where p is a polynomial in K[x] and ⊲⊳
clause is then a disjunction C = F1
of a single disjunct (i.e. m = 1). A polynomial constraint problem (PCP) is then given by a set of clauses
that a variable assignment σ :
x1, . . . , xn
holds. Furthermore, σ satisﬁes a clause F1
– and is therefore a solution of the PCP – if every clause within the set is satisﬁed by σ. We write
that all polynomials in the clause set
clause set cstr(M ) to be

. A
≥
}
Fm of polynomial constraints. A unit clause is a special clause consisting
. We say
K satisﬁes a polynomial constraint p ⊲⊳ 0 if p(σ(x1), . . . , σ(xn)) ⊲⊳ 0
Fm if for some i, Fi is satisﬁed by σ. Finally, σ satisﬁes a clause set
⊏ K[x] to indicate
are contained in K[x]. For a matrix M with entries m1, . . . , ms we deﬁne the

C
m1 = 0, . . . , ms = 0

} →
∨ · · · ∨

∨ · · · ∨

∈ {

, =,

, >

<,

=,

≤

C

C

{

.

{

2.2. Number Sequences and Recurrence Relations

A number sequence (x(n))∞
as C-ﬁnite recurrence [KP11]. Let c0, . . . , cr−1

K and c0

= 0, then

n=0 is called C-ﬁnite if it satisﬁes a linear recurrence with constant coefﬁcients, also known

x(n + r) + cr−1x(n + r

1) +

+ c1x(n + 1) + c0x(n) = 0

−

· · ·

(2)

is a C-ﬁnite recurrence of order r. The order of a sequence is deﬁned by the order of the recurrence it satisﬁes. We
refer to a recurrence of order r also as an r-order recurrence, for example as a ﬁrst-order recurrence when r = 1 or
a second-order recurrence when r = 2. A recurrence of order r and r initial values deﬁne a sequence, and different
initial values lead to different sequences. For simplicity, we write (x(n))∞

n=0 = 0 for (x(n))∞

n=0 = (0)∞

n=0.

Example 2.1. Let a
with x(0) = a. The geometric sequence (an)∞
satisﬁes a second-order recurrence x(n + 2) = 2x(n + 1)

K. The constant sequence (a)∞

∈

n=0 satisﬁes a ﬁrst-order recurrence equation x(n + 1) = x(n)
n=0 satisﬁes x(n + 1) = ax(n) with x(0) = 1. The sequence (n)∞
n=0

x(n) with x(0) = 0 and x(1) = 1.

−
From the closure properties of C-ﬁnite sequences [KP11], the product and the sum of C-ﬁnite sequences are also

}

∈

n=0 be C-ﬁnite sequences of order r and s, respectively. Then:

C-ﬁnite. Moreover, we also have the following properties:
Theorem 2.2 ([KP11]). Let (u(n))∞
1. (u(n) + v(n))∞
v(n))∞
2. (u(n)

n=0 is C-ﬁnite of order at most r + s, and
n=0 is C-ﬁnite of order at most rs.

n=0 and (v(n))∞

·

Theorem 2.3 ([KP11]). Let ω1, . . . , ωt
(p1(n)ωn
zero.

+ pt(n)ωn

t )∞

1 +

· · ·

n=0 is the zero sequence if and only if the sequences (p1(n))∞

∈

∈

K be pairwise distinct and p1, . . . , pt

K[x]. The number sequence
n=0 , . . . , (pt(n))∞
n=0 are

Theorem 2.4 ([KP11]). Let p = c0 +c1x+
Theorem 2.5 ([KP11]). Let (u)∞
N if and only if u(n) = 0 for n
n

∈

0, . . . , r

1

.

}

−

∈ {

+ckxk

· · ·

∈

K[x]. Then (p(n))∞

n=0 = 0 if and only if c0 =

= ck = 0.

· · ·

n=0 be a sequence satisfying a C-ﬁnite recurrence of order r. Then, u(n) = 0 for all

We deﬁne a system of C-ﬁnite recurrences of order r and size s to be of the form

Xn+r + Cr−1Xn+r−1 +

· · ·

+ C1Xn+1 + C0Xn = 0

6
6
6

Humenberger et al

xs(n))⊺ and Ci
where Xn = (x1(n)
ﬁrst-order system of recurrences by increasing the size such that we get

· · ·

∈

Ks×s. Every C-ﬁnite recurrence system can be transformed into a

Xn+1 = BXn

where B is invertible.

(3)

The closed form solution of a C-ﬁnite recurrence system (3) is determined by the roots ω1, . . . , ωt of the characteristic
polynomial of B, or equivalently by the eigenvalues ω1, . . . , ωt of B. We recall that the characteristic polynomial χB
of the matrix B is deﬁned as

χB(ω) = det(ωI

B),

(4)

where det denotes the (matrix) determinant and I the identity matrix. Let m1, . . . , mt respectively denote the multi-
plicities of the roots ω1, . . . , ωt of χB. The closed form of (3) is then given by

−

t

mi

Xn =

Cij ωn

i nj−1

i=1
X

j=1
X

with Cij

Ks×1.

∈

(5)

However, not every choice of the Cij gives rise to a solution. For obtaining a solution, we substitute the general
form (5) into the original system (3) and compare coefﬁcients. The following example illustrates the procedure for
computing closed form solutions.

Example 2.2. The most well-known C-ﬁnite sequence is the Fibonacci sequence satisfying a recurrence of order 2
which corresponds to the following ﬁrst-order recurrence system:

f (n + 1)
g(n + 1)

=

1 1
1 0

f (n)
g(n)

(cid:19)

(cid:18)

(cid:19) (cid:18)

(cid:19)

(cid:18)

The eigenvalues of B are given by ω1,2 = 1
2 (1
solution for the recurrence system is of the form

√5) with multiplicities m1 = m2 = 1. Therefore, the general

±

(6)

f (n)
g(n)

=

c1
c2

d1
d2

(cid:18)

(cid:19)

(cid:18)

(cid:19)

(cid:18)

(cid:19)

ωn

1 +

ωn
2 .

(7)

By substituting (7) into (6), we get the following constraints over the coefﬁcients:

c1
c2

ωn+1
1 +

ωn+1
2 =

d1
d2

1 1
1 0

(cid:18)

(cid:18)
Bringing everything to one side yields:

(cid:18)

(cid:19)

(cid:19)

(cid:19) (cid:18)(cid:18)

c1ω1

−
c2ω1

c2

−
c1

c1

−

(cid:19)

(cid:18)

ωn

1 +

d1ω2

−
d2ω2

d2

−
d1

d1

−

(cid:19)

(cid:18)

For the above equation to hold, the coefﬁcients of the ωn
c1, c2 and d1, d2:

c1
c2

ωn

1 +

d1
d2

(cid:18)

ωn
2

(cid:19)

(cid:19)

(cid:19)

ωn

2 = 0

i have to be 0. That is, the following linear system determines

ω1

1

−
1
−
0
0

0
0

1
−
ω1
0 ω2
0

−
1

−

1






0
0

1
−
ω2

c1
c2
d1
d2












= 0



The solution space is generated by (ω1, 1, 0, 0) and (0, 0, ω2, 1). The solution space of the C-ﬁnite recurrence system
hence consists of linear combinations of

ω1
1

(cid:18)

(cid:19)

ωn
1

and

ω2
1

(cid:18)

(cid:19)

ωn
2 .

That is, by solving the linear system

(cid:18)

f (0)
g(0)

f (0)
g(0)

(cid:19)

(cid:19)

= E

= E

ω1
1

ω1
1

(cid:18)

(cid:18)

ω0
1 + F

ω1
1 + F

(cid:19)

(cid:19)

ω2
1

ω2
1

(cid:18)

(cid:18)

ω0
2

ω1
2

(cid:19)

(cid:19)

f (1)
g(1)

=

1 1
1 0

(cid:18)

(cid:19)

(cid:18)

(cid:19) (cid:18)

Algebra-Based Reasoning for Loop Synthesis

7

for E, F

∈

K2×1 with f (0) = 1 and g(0) = 0, we get closed forms for (6):

f (n) =

5 + √5
5(1 + √5)

ωn+1
1 −

1
√5

ωn+1
2

and g(n) =

1
√5

ωn
1 −

1
√5

ωn
2

Then f (n) represents the Fibonacci sequence starting at 1 and g(n) starts at 0. Solving for E and F with symbolic
f (0) and g(0) yields a parameterized closed form, where the entries of E and F are linear functions in the symbolic
initial values.

3. Our Programming Model

Given a polynomial relation p(x1, . . . , xs) = 0, our loop synthesis procedure generates a ﬁrst-order C-ﬁnite/afﬁne
N. It is
recurrence system (3) with Xn = (x1(n)
not hard to argue that every ﬁrst-order C-ﬁnite recurrence system corresponds to a loop with simultaneous variable
assignments of the following form

xs(n))⊺, such that p(x1(n), . . . , xs(n)) = 0 holds for all n

· · ·

∈

(a1, . . . , as)

(x1, . . . , xs)
←
while true do
(x1, . . . , xs)

end

←

(p1(x1, . . . , xs), . . . , ps(x1, . . . , xs))

(8)

where the program variables x1, . . . , xs are numeric, a1, . . . , as are (symbolic) constants in K and p1, . . . , ps are
polynomials in K[x1, . . . , xs]. For a loop variable xi, we denote by xi(n) the value of xi at the nth loop iteration. That
is, we view loop variables xi as sequences (xi(n))∞
n=0. We call a loop of the form (8) parameterized if at least one of
a1, . . . , as is symbolic, and non-parameterized otherwise.

Remark 3.1. Our synthesized loops of the form (8) are non-deterministic, with loop guards being true. We synthesize
loops such that the given invariant holds for an arbitrary/unbounded number of loop iterations - for example, also for
loop guards n < N as in Figure 1.

Remark 3.2. While the output of our synthesis procedure is basically an afﬁne program, note that C-ﬁnite recurrences
capture a larger class of programs. E.g. the program:

(x, y)

←

(0, 0); while true do (x, y)

(x + y2, y + 1) end

←

can be modeled by a C-ﬁnite recurrence system of order 4, which can be turned into an equivalent ﬁrst-order system
of size 6. Thus, to synthesize loops inducing the sequences (x(n))∞
n=0, we have to consider recurrence
systems of size 6.

n=0 and (y(n))∞

Example 3.1. The Fibonacci recurrence system (6) in Example 2.2 corresponds to the following loop:

(f, g)

←

(1, 0); while true do (f, g)

(f + g, f ) end

←

Algebraic relations and loop invariants. Let p be a polynomial in K[z1, . . . , zs] and let (x1(n))∞
n=0
be number sequences. We call p an algebraic relation for the given sequences if p(x1(n), . . . , xs(n)) = 0 for all
N. Moreover, p is an algebraic relation for a system of recurrences if it is an algebraic relation for the correspond-
n
ing sequences. It is immediate that for every algebraic relation p of a recurrence system, p = 0 is a loop invariant for
the corresponding loop of the form (8); that is, p = 0 holds before and after every loop iteration.

n=0, . . . , (xs(n))∞

∈

4. Algebra-based Loop Synthesis

We now present our approach for synthesizing loops satisfying a given polynomial property (invariant), by using afﬁne
loop assignments. We transform the loop synthesis problem into a PCP as described in Section 4.1. In Section 4.2, we
introduce the clause sets of our PCP which precisely describe the solutions for the synthesis of loops, in particular to
non-parameterized loops. We extend this approach in Section 4.3 to parameterized loops.

8

Humenberger et al

Polynomial
invariant

alg

C

Closed form
system

C

roots,

C
init

C

coeﬀ

Recurrence
system

Loop

Fig. 2. Overview of the PCP describing loop synthesis

4.1. Setting and Overview of Our Method

K[x1, . . . , xs, y1, . . . , ys], we aim to synthesize a system of C-ﬁnite recurrences
Given a constraint p = 0 with p
such that p is an algebraic relation thereof. Intuitively, the values of loop variables x1, . . . , xs are described by the
sequences x1(n), . . . , xs(n) for arbitrary n, and y1, . . . , ys correspond to the initial values x1(0), . . . , xs(0). That is,
we have a polynomial relation p among loop variables xi and their initial values yi, for which we synthesize a loop of
the form (8) such that p = 0 is a loop invariant of a loop deﬁned in (8).

∈

Remark 4.1. Our approach is not limited to invariants describing relationship between program variables from a sin-
gle loop iteration. Instead, it naturally extends to relations among different loop iterations. For instance, by considering
the relation in equation (1), we synthesize a loop computing the Fibonacci sequence.

roots,

The key step in our work comes with precisely capturing the solution space for our loop synthesis problem as a
PCP. Our PCP is divided into the clause sets
alg, as illustrated in Figure 2 and explained next.
C
Our PCP implicitly describes a ﬁrst-order C-ﬁnite recurrence system and its corresponding closed form system. The
init. Intuitively,
one-to-one correspondence between these two systems is captured by the clause sets
these constraints mimic the procedure for computing the closed form of a recurrence system (see [KP11]). The clause
set
alg interacts between the closed form system and the polynomial constraint p = 0, and ensures that p is an algebraic
relation of the system. Furthermore, the recurrence system is represented by the matrix B and the vector A of initial
values where both consist of symbolic entries. Then a solution of our PCP – which assigns values to those symbolic
entries – yields a desired synthesized loop.

coeﬀ and

init and

roots,

coeﬀ ,

C

C

C

C

C

C

C

In what follows we only consider a unit constraint p = 0 as input to our loop synthesis procedure. However, our

approach naturally extends to conjunctions of polynomial equality constraints.

4.2. Synthesizing Non-Parameterized Loops

We now present our work for synthesizing loops, in particular non-parameterized loops of the form (8). That is, we
aim at computing concrete initial values for all program variables. Our implicit representation of the recurrence system
is thus of the form

Xn+1 = BXn,

X0 = A

(9)

∈

∈

where B

Ks×s is invertible and A

Ks×1, both containing symbolic entries.
As described in Section 2.2, the closed form of (9) is determined by the roots of the characteristic polynomial
χB(ω) deﬁned in (4). Using the closed form representation (5), we conclude that the eigenvalues of the coefﬁcient
matrix B in (9) determine the closed form of (9), implying thus the need of synthesizing the (symbolic) eigenvalues
of B. Note that B may contain both symbolic and concrete values (where concrete values may come from user-given
initial values or additional user-given values for the symbolic parameters of the loop given in equation (8)). Let us
denote the symbolic entries of B by b. Since K is algebraically closed, we know that B has s (not necessarily dis-
tinct) eigenvalues. We therefore ﬁx a set of distinct symbolic eigenvalues ω1, . . . , ωt together with their multiplicities
t
i=1 mi = s. We call m1, . . . , mt an integer partition of s. We
m1, . . . , mt with mi > 0 for i = 1, . . . , t such that
next deﬁne the clause sets of our PCP.

P

C

roots. The clause set

Root constraints
roots ensures that B is invertible and that ω1, . . . , ωt are distinct symbolic
eigenvalues with multiplicities m1, . . . , mt. Note that B is invertible if and only if all eigenvalues ωi are non-zero.
Furthermore, since K is algebraically closed, every polynomial f (z) can be written as the product of linear factors of
K, such that f (ω) = 0. Let us recall that the characteristic polynomial χB of the matrix B
the form z
B), where det denotes the (matrix) determinant and I the identity matrix. Then, the
is deﬁned as χB(ω) = det(ωI
equation

ω, with ω

−

−

∈

C

χB(z) = (z

ω1)m1

(z

−

· · ·

ωt)mt

−

(10)

Algebra-Based Reasoning for Loop Synthesis

9

holds for all z
monomials in z, we get

∈

K, where χB(z)

K[ω, b, z]. Bringing everything to one side and regrouping terms based on the

∈

q0 + q1z +

+ qdzd = 0,

· · ·
implying that the qi
the equation (10); as such, qi are polynomials in ω, b. The clause set characterizing the eigenvalues ωi of B is then

K[ω, b] have to be zero. Note that qi are the coefﬁcients of the monomials in z resulting from

∈

roots =

C

{

q0 = 0, . . . , qd = 0

} ∪

{
i,j=1,...,t
[
i6=j

ωi

= ωj

ωi

= 0

.

}

} ∪

{
i=1,...,t
[

Coefﬁcient constraints
duce the general closed form solution

C

coeﬀ . The ﬁxed symbolic roots/eigenvalues ω1, . . . , ωt with multiplicities m1, . . . , mt in-

t

mi

Xn =

Cij ωn

i nj−1

(11)

j=1
X

i=1
X
Ks×1 are column vectors containing symbolic entries. As stated in Section 2.2, not every choice of
where the Cij
the Cij gives rise to a valid solution. Instead, Cij have to obey certain conditions which are determined by substituting
into the original recurrence system of (9):

∈

t

mi

Xn+1 =

Cij ωn+1
i

(n + 1)j−1 =

i=1
X

j=1
X
t

mi

t

mi

mi

i=1
X

j=1 
X


k=j (cid:18)
X

k
j

−
−

1
1

(cid:19)

Cikωi





i nj−1
ωn

= B



Cij ωn

i nj−1

= BXn



j=1
X
Bringing everything to one side yields Xn+1

i=1
X





BXn = 0 and thus

−

t

mi

mi

i=1
X

j=1 
X






k=j (cid:18)
X

k
j

1
1

−
−

(cid:19)

Cikωi

Dij

i nj−1 = 0.
ωn



−



BCij





(12)

Equation (12) holds for all n

|

t

mi

{z
∈

N. By Theorem 2.4 we then have Dij = 0 for all i, j and deﬁne

}

coeﬀ =

cstr(Dij ).

j=1
[

i=1
[
Initial values constraints
that (11) equals BnX0, for n = 0, . . . , d

C

init = cstr(M0)

cstr(Md−1)

∪ · · · ∪

C

C

−

init. The constraints

init describe properties of initial values x1(0), . . . , xs(0). We enforce

1, where d is the degree of the characteristic polynomial χB of B, by

C

−

where Mi = Xi

BiX0, with X0 = A as in (9) and Xi being the right-hand side of (11) where n is replaced by i.

Algebraic relation constraints
C
the xi(n). Using (11), the closed forms of the xi(n) are expressed as

alg. The constraints

C

alg are deﬁned to ensure that p is an algebraic relation among

xi(n) = pi,1ωn

1 +

+ pi,tωn
t

· · ·

where the pi,j are polynomials in K[n, c]. By substituting the closed forms and the initial values into the polynomial
p, we get

p′ = p(x1(n), . . . , xs(n), x1(0), . . . , xs(0)) = q0 + nq1 + n2q2 +

where the qi are of the form

wn

i,1ui,1 +

+ wn

i,ℓui,ℓ

· · ·

+ nkqk

· · ·

(13)

(14)

6
6
10

Humenberger et al

∈

K[a, c] and wi,1, . . . , wi,ℓ being monomials in K[ω].

with ui,1, . . . , ui,ℓ
Proposition 4.1. Let p be of the form (13). Then (p(n))∞
n=0 = 0 for i = 0, . . . , k.
+pℓ(n)wn
Proof. One direction is obvious and for the other assume p(n) = 0. By rearranging p we get p1(n)wn
ℓ .
1 +
ℓ = 0 with ˜wi = wi(˜ω). Note that the ˜wi are not
Let ˜ω1, . . . , ˜ωt
1 +
necessarily distinct. However, consider v1, . . . , vr to be the pairwise distinct elements of the ˜wi. Then we can write ˜p
+ nkpi,k). By Theorems 2.3 and 2.4 we get that the pi,j have to be 0. Therefore, also
as
i pi,j = 0 for all i, j. Then, for each j = 0, . . . , k, we have vn
vn
P
As p is an algebraic relation, we have that p′ should be 0 for all n

N. Proposition 4.1 then implies that the qi

K be such that ˜p = p1(n) ˜wn

n=0 = 0 iff (qi(n))∞

i (pi,0 + npi,1 +

r p1,j = 0 = qj.

+ pℓ(n) ˜wn

r
i=1 vn

1 p1,j +

+ vn

· · ·

· · ·

· · ·

· · ·

∈

have to be 0 for all n

N.

∈

Lemma 4.1. Let q be of the form (14). Then q = 0 for all n

∈

N if and only if q = 0 for n

0, . . . , ℓ

∈ {

1

.
}

−

∈

Proof. The proof follows from Theorem 2.5 and from the fact that q satisﬁes a C-ﬁnite recurrence of order l. To be
more precise, the ui,j and wn
i,j satisfy a ﬁrst-order C-ﬁnite recurrence: as ui,j is constant it satisﬁes a recurrence of the
form x(n + 1) = x(n), and wn
i,j ui,j is C-ﬁnite
of order at most 1, and q is C-ﬁnite of order at most ℓ.

i,j satisﬁes x(n + 1) = wix(n). Then, by Theorem 2.2 we get that wn

Even though the qi contain exponential terms in n, it follows from Lemma 4.1 that the solutions for the qi being 0
i be the polynomial constraint
be the associated clause set. Then

N can be described as a ﬁnite set of polynomial equality constraints: Let Qj

for all n
wj
Q0
the clause set ensuring that p is indeed an algebraic relation is given by

i,ℓui,ℓ = 0 for qi of the form (14), and let

i , . . . , Qℓ−1

∈
i,1ui,1 +

+ wj

i =

· · ·

C

{

}

i

alg =

C

0

C

∪ · · · ∪ C

k.

Remark 4.2. Observe that Theorem 2.5 can be applied to formula (13) directly, as p′ satisﬁes a C-ﬁnite recurrence.
Then by the closure properties of C-ﬁnite recurrences, the upper bound on the order of the recurrence which p′ satisﬁes
k
i=0 2iℓ. That is, by Theorem 2.5, we would need to consider p′ with n = 0, . . . , r
is given by r =
1, which yields
a non-linear system with a degree of at least r
n=0
satisﬁes a recurrence of order 2, and ni satisﬁes therefore a recurrence of order at most 2i. Thankfully, Proposition 4.1
allows us to only consider the coefﬁcients of the ni and therefore lower the size of our constraints.

1. Note that r depends on 2i, which stems from the fact that (n)∞

P

−

−

Having deﬁned the clause sets

alg, we deﬁne our PCP as the union of these four clause sets.
C
Note that the matrix B, the vector A, the polynomial p and the multiplicities of the symbolic roots m = m1, . . . , mt
uniquely deﬁne the clauses discussed above. We deﬁne our PCP to be the clause set

init and

roots,

coeﬀ ,

p
AB(m) as follows:

C

C

C

C

alg

init

p
AB(m) =
C
Recall that a and b are the symbolic entries in the matrices A and B given in (9), c are the symbolic entries in the

(15)

∪ C

∪ C

∪ C

roots

coeﬀ

Cij in the general form (11), and ω are the symbolic eigenvalues of B. We then have

It is not difﬁcult to see that the constraints in

C
alg determine the size of our PCP. As such, the degree and the
number of terms in the invariant have a direct impact on the size and the maximum degree of the polynomials in our
PCP. Which might not be obvious is that the number of distinct symbolic roots inﬂuences the size and the maximum
degree of our PCP. The more distinct roots are considered the higher is the number of terms in (14), and therefore
more instances of (14) have to be added to our PCP.

AB(m) ⊏ K[ω, a, b, c].

C

p

C

Ks×s and A

Ks×1, and let m1, . . . , mt be an integer partition of

Consider p

K[x1, . . . , xs, y1, . . . , ys], B

degω(χB(ω)). We then get the following theorem:

∈

∈

∈

p
K is a solution of
AB(m) if and only if p(x, x1(0), . . . , xs(0)) is
Theorem 4.1. The mapping σ :
an algebraic relation for Xn+1 = σ(B)Xn with X0 = σ(A), and the eigenvalues of σ(B) are σ(ω1), . . . , σ(ωt) with
multiplicities m1, . . . , mt.

ω, a, b, c

} →

C

{

From Theorem 4.1, we then get Algorithm 1 for synthesizing the C-ﬁnite recurrence representation of a non-
parameterized loop of the form (8): IntPartitions(s) returns the set of all integer partitions of an integer s; and
p
AB in
Solve(
Algorithm 1 refers to our PCP problem deﬁned in equation (15). We further note that the growth of the number of
integer partitions is subexponential, and so is the complexity Algorithm 1. A more precise complexity analysis of
Algorithm 1 is the subject of future investigations.

is satisﬁable and a model σ if so. To this end, the clause set

) returns whether the clause set

C

C

C

Algebra-Based Reasoning for Loop Synthesis

11

: A polynomial p

Input
Output: A vector A

K[x1, . . . , xs, y1, . . . , ys].

∈

Ks×1 and a matrix B

X0 = A, if such A and B exist.

∈

∈

Ks×s s.t. p is an algebraic relation of Xn+1 = BXn and

(ai)
(bij)

1 A
←
2 B
←
3 for m1, . . . , mt
sat, σ
4
if sat then return σ(A), σ(B)

Ks×1 // symbolic vector
Ks×s // symbolic matrix
IntPartitions(s) do
p
AB(m1, . . . , mt))

∈
Solve(

∈
∈

←

C

5
6 end

Algorithm 1: Synthesis of a non-parameterized C-ﬁnite recurrence system

Finally, based on Theorem 4.1 and on the property that the number of integer partitions of a given integer is ﬁnite,

we obtain the following result:

Theorem 4.2. Algorithm 1 is sound, and complete w.r.t. recurrence systems of size s.

The precise characterization of non-parameterized loops by non-parameterized C-ﬁnite recurrence systems implies
soundness and completeness of our approach for non-parameterized loops from Theorem 4.2. In fact, a recurrence
system of size s generated by Algorithm 1 gives rise to a non-parameterized loop with s variables and at most s
1
auxiliary variables where the auxiliary variables capture the values of the program variables of previous loop iterations.

−

Example 4.1. We showcase Algorithm 1 by synthesizing a loop from the loop invariant x = 2y. That is, the polyno-
mial is given by p = x

K[x, y], and we want to ﬁnd a recurrence system of the following form

2y

x(n + 1)
y(n + 1)

=

−

∈
b11 b12
b21 b22

x(n)
y(n)

(cid:18)

(cid:18)
The characteristic polynomial of B is then given by

(cid:19) (cid:18)

(cid:19)

(cid:19)

(cid:18)

x(0)
y(0)

=

a1
a2

(cid:18)

(cid:19)

(cid:19)

(16)

χB(ω) = ω2

b11ω

b22ω

−

−

−

b12b21 + b11b22

where its roots deﬁne the closed form system. Since we cannot determine the actual roots of χB(ω), we have to ﬁx a
set of symbolic roots. The characteristic polynomial has two – not necessarily distinct – roots: Either χB(ω) has two
distinct roots ω1, ω2 with multiplicities m1 = m2 = 1, or a single root ω1 with multiplicity m1 = 2. Let us consider
roots for ensuring that B is invertible (i.e. ω1 is nonzero), and that ω1
the latter case. The ﬁrst clause set we deﬁne is
ω1)2 has to hold for all
is indeed a root of the characteristic polynomial with multiplicity 2. That is, χB(ω) = (ω
ω

−

C

∈

K, and bringing everything to one side yields
b11b22 + ω2

2ω1)ω + b12b21

(b11 + b22

1 = 0

−
We then get the following clause set:

−

roots =

C

{

b11 + b22

−

2ω1 = 0, b12b21

−

b11b22 + ω2

1 = 0, ω1

= 0

}

As we ﬁxed the symbolic roots, the general closed form system is of the form

x(n)
y(n)

(cid:18)

=

c1
c2

(cid:18)

(cid:19)

(cid:19)

ωn

1 +

d1
d2

(cid:18)

(cid:19)

ωn

1 n

By substituting into the recurrence system we get:

ωn+1
1 +

c1
c2

(cid:18)

(cid:19)

d1
d2

(cid:18)

(cid:19)

ωn+1
1

(n + 1) =

b11 b12
b21 b22

(cid:18)

c1
c2

(cid:19) (cid:18)(cid:18)

ωn

1 +

d1
d2

(cid:18)

ωn

1 n

(cid:19)

(cid:19)

(cid:19)

By further simpliﬁcations and re-ordering of terms we then obtain:

0 =

c1ω1 + d1ω1
c2ω1 + d2ω1

(cid:18)

b11c1
b21c1

−
−

−
−

b12c2
b22c2

(cid:19)

ωn

1 +

d1ω1
d2ω1

(cid:18)

b11d1
b21d1

b12d2
b22d2

−
−

(cid:19)

−
−

ωn

1 n

(17)

6
12

Humenberger et al

Since this equation has to hold for n

N we get the following clause set:

coeﬀ =

C

c1ω1 + d1ω1
{
b11d1
d1ω1

b11c1
b12d2 = 0, d2ω1

−

−
−

−

b21d1

−

−

−
b22d2 = 0

}

b21c1

b22c2 = 0,

−

∈
b12c2 = 0, c2ω1 + d2ω1

For deﬁning the relationship between the closed forms and the initial values, we set the formula (17) with n = i to be
equal to the ith unrolling of formula (16) for i = 0, 1:

c1
c2

(cid:18)

(cid:19)

=

a1
a2

(cid:18)

(cid:19)

c1
c2

(cid:18)

(cid:19)

ω1 +

d1
d2

(cid:18)

(cid:19)

ω1 =

b11 b12
b21 b22

(cid:18)

a1
a2

(cid:19)

(cid:19) (cid:18)

The resulting constraints for deﬁning the initial values are then given by

init =

C

c1
{
c2

−
−

a1 = 0, c1ω1 + d1ω1
a2 = 0, c2ω1 + d2ω1

b11a1
b21a1

−
−

−
−

b12a2 = 0,
b22a2 = 0

}

.

Eventually, we want to restrict the solutions such that x
That is, by substituting the closed forms into the expression x(n)

−

2y = 0 is an algebraic relation for our recurrence system.

2y(n) = 0 we get

−

0 = x(n)
= (c1

2y(n) = c1ωn
+ ((d1

−
2c2) ωn
1

1 + d1ωn
1 n
2d2) ωn
1 )

−
n

−

−

2(c2ωn

1 + d2ωn

1 n)

q0

q1

|

where q0 and q1 have to be 0 since the above equation has to hold for all n
and q1, we get the following clauses:

{z

}

|

{z

}

N. Then, by applying Lemma 4.1 to q0

∈

alg =

c1

2c2 = 0, d1

2d2 = 0

{

C

−
−
Our PCP is then the union of
init and
synthesis problem, are given by the following loops:

}
coeﬀ,

roots,

C

C

C

alg. Two possible solutions for our PCP, and therefore of the

C

(x, y)
(2, 1)
←
while true do
(x, y)

end

←

(x + 2, y + 1)

(x, y)
(2, 1)
←
while true do
(x, y)

end

←

(2x, 2y)

Note that both loops above have mutually independent afﬁne updates. Yet, the second one induces geometric sequences
and requires handling exponentials of 2n.

The completeness in Theorem 4.2 is relative to systems of size s which is a consequence of the fact that we
synthesize ﬁrst-order recurrence systems. That is, there exists a system of recurrence equations of order > 1 and size
K[x1, . . . , xs], but there exists no ﬁrst-order system of size s where p is an algebraic
s with an algebraic relation p
relation. Therefore, in order to be able to synthesize a system satisfying p as an algebraic relation, we have to look for
recurrence systems of size > s. Example 4.2 next discusses an instance of such a higher-order recurrence system. In
order to gain completeness in Theorem 4.2 independent of the size s of the recurrence system, we would need to be
able to derive an upper bound on s. Obtaining such a bound from p seems to be highly non-trivial with connections to
the inverse problem of difference Galois theory [VdPS97], and is subject of future work.

∈

Example 4.2. Consider the loop given in Remark 3.2. This loop has 2y3
inferred for example by [HBK20].

−

3y2 + y

−

6x = 0 as a loop invariant, as

Even though the loop assignment for x in the example from Remark 3.2 is nonlinear, the number sequences induced

by x and y respectively satisfy the C-ﬁnite recurrence equations

x(n + 4)

−

4x(n + 3) + 6x(n + 2)
y(n + 2)

4x(n + 1) + x(n) = 0
2y(n + 1) + y(n) = 0

−
−

Algebra-Based Reasoning for Loop Synthesis

13

with the following initial values of the loop variables x and y:

= 0
x(0) =
x(1) = x(0) + y(0)2 = 0
x(2) = x(1) + y(1)2 = 1
x(3) = x(2) + y(2)2 = 5

y(0) =

= 0

y(1) = y(0) + 1 = 1

We therefore have a C-ﬁnite recurrence system of order 4 which is equivalent to the ﬁrst-order system of recurrence
equations

u0(n + 1)
u1(n + 1)
u2(n + 1)
u3(n + 1)

0 1 0 0
0 0 1 0
= 

0 0 0 1
4
4 6
1





−

−






u0(n)
u1(n)
u2(n)
u3(n)
















v0(n + 1)
v1(n + 1)

=

0 1
2
1
(cid:19) (cid:18)
(cid:18)

−

v0(n)
v1(n)

(cid:19)

(cid:19)

(cid:18)

with initial values ui(0) = x(i) and vi(0) = y(i). Then u0 and v0 induce the sequences x and y respectively. However,
if we want to synthesize a loop that induces these number sequences x and y and has 2y3
6x = 0 as a
loop invariant, we have to consider ﬁrst-order recurrence systems of size 6 and not only of order 4.

3y2 + y

−

−

4.3. Synthesizing Parameterized Loops

We now extend the loop synthesis approach from Section 4.2 to an algorithmic approach synthesizing parameterized
loops, that is, loops which satisfy a loop invariant for arbitrary input values. Let us ﬁrst consider the following example
motivating the synthesis problem of parameterized loops.

K. Following
Example 4.3. We are interested to synthesize a loop implementing Euclidean division over x, y
the problem speciﬁcation of [Knu97]2, a synthesized loop performing Euclidean division satisﬁes the polynomial
invariant p = ¯x
r = 0, where ¯x and ¯y denote the initial values of x and y before the loop. It is clear, that the
synthesized loop should be parameterized with respect to ¯x and ¯y. With this setting, input to our synthesis approach
is the invariant p = ¯x
r = 0. A recurrence system performing Euclidean division and therefore satisfying the
−
algebraic relation ¯x
r is then given by Xn+1 = BXn and X0 = A with a corresponding closed form system
−
Xn = A + Cn where:

−
¯yq

¯yq

¯yq

−

−

−

∈

x(n)
r(n)
q(n)
y(n)
t(n)



Xn = 







¯x
¯x
0
¯y
1

A = 





B = 





1 0 0 0 0
0 1 0
1 0
0 0 1 0 1
0 0 0 1 0
0 0 0 0 1

−



0
¯y
−
1
0
0



C = 














Here, the auxiliary variable t plays the role of the constant 1, and x and y induce constant sequences. When compared
to non-parameterized C-ﬁnite systems/loops, note that the coefﬁcients in the above closed forms, as well as the initial
values of variables, are functions in the parameters ¯x and ¯y.











Example 4.3 illustrates that the parameterization has the effect that we have to consider parameterized closed forms
and initial values. For non-parameterized loops we have that the coefﬁcients in the closed forms are constants, whereas
for parameterized systems we have that the coefﬁcients are functions in the parameters – the symbolic initial values
of the sequences. In fact, we have linear functions since the coefﬁcients are obtained by solving a linear system (see
Example 2.2).

As already mentioned, the parameters are a subset of the symbolic initial values of the sequences. Therefore, let
⊺ where ¯xk1 , . . . , ¯xkr

. We then deﬁne ¯X = (¯xk1

be a subset of the indices

k1, . . . , kr

¯xkr 1)

1, . . . , s

I =
denote the parameters. Then, instead of (9), we get

{

}

{

}

· · ·

Xn+1 = BXn

X0 = A ¯X

(18)

2 for x, y ∈ K we want to compute q, r ∈ K such that x = yq + r holds

14

Humenberger et al

as the implicit representation of our recurrence system where the entries of A

Ks×r+1 are deﬁned as

∈

aij =

1
aij symbolic

0


i = kj
i /
I
∈
otherwise

Ks×s. Intuitively, the complex looking construction of A makes sure that we have



and, as before, we have B
xi(0) = ¯xi for i
Example 4.4. For the vector X0 = (x1(0) x2(0) x3(0))⊺, the set I =
get the following matrix:

I.

∈

∈

and therefore ¯X = (¯x1 ¯x3 1)⊺, we

1, 3

{

}

A =

0
0
1
a21 a22 a23
1
0

0 !

Thus, x1(0) and x3(0) are set to ¯x1 and ¯x3 respectively, and x2(0) is a linear function in ¯x1 and ¯x3.

In addition to the change in the representation of the initial values, we also have a change in the closed forms. That is,
instead of (11) we get

Xn =

t

mi

i=1
X

j=1
X

Cij ¯Xωn

i nj−1

alg are deﬁned
as the general form for the closed form system with Cij
C
C
p
AB(m, ¯x) as the union of those
analogously to Section 4.2, and similar to the non-parameterized case we deﬁne
K satisfying
clause sets. The polynomials in
the clause set for all ¯x
problem.
However, since all constraints containing ¯x are polynomial equality constraints, we (repeatedly) apply Theorem 2.1
K[¯x] and
K[ω, a, b, c, ¯x] be a polynomial such that p = p1q1 +
and get the following: Let p
qi monomials in K[ω, a, b, c]. Then, Theorem 2.1 implies that the qi have to be 0.

∈
K gives rise to the desired parameterized loop, that is, we have to solve an

AB(m, ¯x) are then in K[ω, a, b, c, ¯x]. Then, for each ω, a, b, c

+ pkqk with pi

coeﬀ and

roots,

init,

· · ·

∃∀

∈

∈

∈

∈

C

C

C

C

p

Ks×r+1. Then

We therefore deﬁne the following operator splitx(p) for collecting the coefﬁcients of all monomials in x in the

polynomial p: Let p be of the form q0 + q1x +

· · ·

+ qkxk, P a clause and let

be a clause set, then:

C

splity,x(p) =

splity(P ) =

splity(
C

) =

q0 = 0, . . . , qk = 0
{
splity(q0)
(cid:26)

}

splity(qk)
∪ · · · ∪
if P is a unit clause p = 0
otherwise

if y is empty
otherwise

splity(p)
P

}
splity(P )

(cid:26)
{

P ∈C
[

Example 4.5. Applying the operator splitx to the clause set

yzx3 + y3x2 + (z2
{
x
z

−
= y

1 = 0

−

∨

y

−
1 = 0

3)x = 0,
z

∨

−

1 = 0,

}

=

C

yields

splitx(
C

) =

{

yz = 0, y3 = 0, z2
x
z

1 = 0
.

−
= y

−

∨

y

3 = 0,
z

−
1 = 0

∨

−

}

1 = 0,

Note that the polynomials occurring in the constraint problem split¯x(
C
AB(m, ¯x)) ⊏ K[ω, a, b, c]. Moreover, for p

That is, split¯x(
C
in (18), and an integer partition m1, . . . , mt of degω(χB(ω)) we get the following theorem:

AB(m, ¯x)) are elements of K[ω, a, b, c].
K[x1, . . . , xs, y1, . . . , ys], matrices A,B and ¯X as

∈

p

p

 
6
6
Algebra-Based Reasoning for Loop Synthesis

15

AB(m, ¯x)) if and only if p(x, x1(0), . . . , xs(0))
Theorem 4.3. The map σ :
is an algebraic relation for Xn+1 = σ(B)Xn with X0 = σ(A) ¯X, and σ(ω1), . . . , σ(ωt) are the eigenvalues of σ(B)
with multiplicities m1, . . . , mt.

K is a solution of split¯x(
C

ω, a, b, c

} →

{

p

Theorem 4.3 gives rise to an algorithm analogous to Algorithm 1. Furthermore, we get an analogous soundness

and completeness result as in Theorem 4.2 which implies soundness and completeness for parameterized loops.

Example 4.6. We illustrate the construction of the constraint problem for Example 4.3. For reasons of brevity, we
consider a simpliﬁed system where the variables r and x are merged. The new invariant is then ¯r = ¯yq + r and the
parameters are given by ¯r and ¯y. That is, we consider a recurrence system of size 4 with sequences y, q and r, and t for
the constant 1. As a consequence we have that the characteristic polynomial B is of degree 4, and we ﬁx the symbolic
root ω1 with multiplicity 4. For simplicity, we only show how to construct the clause set

alg.

With the symbolic roots ﬁxed, we get the following template for the system of closed form solutions: Let

C

⊺
Xn = (r(n) q(n) y(n) t(n))

and

V = (¯r ¯y 1)

⊺

,

and let C, D, E, F

K4×3 be symbolic matrices. Then the closed form is given by

Xn =

CV + DV n + EV n2 + F V n3

∈

ωn
1

(cid:1)

y(0)q(n)

r(n) = 0 and rearranging we get:

−

and for the initial values we get

(cid:0)

X0 = 

1
0
0
a21 a22 a23
0
0
1
a41 a42 a43

V.





By substituting the closed forms into the invariant r(0)




0 = ¯r

−

−

−

−

−

c22 ¯y2
c23 ¯y
c21¯r ¯y
d21¯r¯y + d22 ¯y2 + d23 ¯y
(cid:0)
e21¯r¯y + e22 ¯y2 + e23 ¯y
(cid:0)
f21¯r¯y + f22 ¯y2 + f23 ¯y
(cid:0)

−

−

−

c11¯r

c12 ¯y

−

−

−

d11¯r

d12 ¯y

e11¯r

e12 ¯y

f11¯r

f12 ¯y

−
Since the above equation should hold for all n

−

−

(cid:0)

−
c13

−

−

d13
(cid:1)
e13

−

ωn
1
ωn
1 n
1 n2
ωn
(cid:1)
1 n3
ωn

(¯r) 1n

−

−

−

c22 ¯y2
c23 ¯y
c21¯r ¯y
d21 ¯r¯y + d22 ¯y2 + d23 ¯y
(cid:0)
e21¯r¯y + e22 ¯y2 + e23 ¯y
f21¯r¯y + f22 ¯y2 + f23 ¯y
(cid:0)

−

−

−

(cid:0)

−
Then, by applying Lemma 4.1, we get:

(cid:0)

c13

f13
(cid:1)
−
N we get:
(cid:1)
ωn
ωn
ωn
ωn

d13

f13

e13

−

−

−

(cid:1)

(cid:1)

(cid:1)

−

∈
c12 ¯y

c11¯r

d11 ¯r

d12 ¯y

e11¯r

e12 ¯y

f11¯r

f12 ¯y

−

−

−

−

1 = 0
1 = 0
1 = 0
1 = 0

(cid:1)

c13

= 0

¯r

¯r

−

c21¯r¯y

c22 ¯y2

(cid:0)

−

−

−
c23 ¯y

−
c22 ¯y2

−
c21¯r ¯y
(cid:0)
−
d21¯r ¯y + d22 ¯y2 + d23 ¯y
e21¯r ¯y + e22 ¯y2 + e23 ¯y
f21¯r ¯y + f22 ¯y2 + f23 ¯y

c23 ¯y

c11¯r

c12 ¯y

−
c11¯r

−
c12 ¯y

−
c13

−
d11¯r

e11¯r

f11¯r

−

−

−

−

−

−

−
d12 ¯y

e12 ¯y

f12 ¯y

−

−

ω1 = 0

(cid:1)
d13 = 0
(cid:1)
−
e13 = 0

f13 = 0

c21 = 1

−

ω1c21 = 1
d21 =
e21 =
f21 =

c11 = c22 =

c23 + c12 = c13 = 0
−
ω1c11 = ω1c22 = ω1 (c23 + c12) = ω1c13 = 0
d23 + d12 = d13 = 0
e23 + e12 = e13 = 0
f23 + f12 = f13 = 0

d11 = d22 =
e11 = e22 =
f11 = f22 =

Finally, by applying the operator split¯y,¯r, we get the following constraints for

alg:

C

16

Humenberger et al

5. Automating Algebra-based Loop Synthesis

For automating Algorithm 1 for loop synthesis, the challenging task is to ﬁnd solutions for our PCPs describing
large systems of polynomial constraints with many variables and high polynomial degrees (see the PCP problem
given in (15)). We propose the following (partial) solutions for optimizing and exploring the PCP solution space. For
handling recurrence templates of large size, we utilize the ﬂexibility of our approach by trying to ﬁnd loops of a speciﬁc
shape ﬁrst, and then generalize if needed. Moreover, for dealing with PCPs containing polynomials of high degree,
we leverage properties of the constraints generated by our procedure. We will see in our experimental evaluation in
Section 6 that the former is useful in loop synthesis and the latter is necessary for the synthesis of number sequences
in a mathematical setting.

Handling large recurrence templates. It is obvious that the higher the number of program variables in the loop to be
synthesized is, the higher is the number of variables in the PCP of Algorithm 1. To face this increase of complexity we
implemented an iterative search for PCP solutions in the sense that we preset certain values of the coefﬁcient matrix
B in (9). In particular, we start by looking for PCP solutions where the coefﬁcient matrix B is unit upper triangular.
If no such solution is found, we consider B to be an upper triangular matrix and further to be full symbolic matrix
without preset values. This way we ﬁrst construct simpler PCPs (in terms of the number of variables) and generalize
step by step, if needed. This iterative approach can also be used to the search for only integer PCP solutions by
imposing/presetting B to contain only integer-valued.

Synthesizing a (unit) upper triangular coefﬁcient matrix B yields a loop where its loop variables are not mutually
dependent on each other. We note that such a pattern is a very common programming paradigm – all benchmarks from
Table 1 satisfy such a pattern. Yet, as a consequence of restricting the shape of B, the order of the variables in the
recurrence system matters. That is, we have to consider all possible variable permutations for ensuring completeness
w.r.t. (unit) upper triangular matrices.

Handling large polynomial degrees. The main source of polynomials with high degrees in the PCP of Algorithm 1
. For any PCP solution σ in line 4
stems from the clause set
C
of Algorithm 1, we have σ(w1)nσ(u1) +
, which yields the following
}
system of linear equations:

alg, i.e. constraints of the form (14) for n

∈ {
+ σ(wℓ)nσ(uℓ) = 0 for n

1
−
}
0, . . . , ℓ

0, . . . , ℓ

∈ {

· · ·

−

1

W u =



1
σ(w1)
σ(w1)2
...

1
σ(w2)
σ(w2)2
...
σ(w1)ℓ−1 σ(w2)ℓ−1 σ(w3)ℓ−1

1
σ(w3)
σ(w3)2
...

· · ·
· · ·
· · ·
. . .

1
σ(wℓ)
σ(wℓ)2
...
σ(wℓ)ℓ−1







σ(u1)
σ(u2)
σ(u3)
...
σ(uℓ)






Kℓ. Suppose our assignment σ in line 4 of Algorithm 1 is such
Kℓ×ℓ is a Vandermonde matrix and u
where W
∈
= j; if this is not the case we can always create a smaller system of the form (19) by
that σ(wi)
= σ(wj ) for i
= j, we derive that W is invertible. Then, it follows by Cramer’s rule, that
= σ(wj ) for i
collecting terms. As σ(wi)
σ(ui) = 0 for all i
. Based on this observation, we propose Algorithm 2 for solving constraints of the
form (14). For simplicity, we only present the case where we have a single constraint of the form (14); Algorithm 2
however naturally extends to multiple such constraints.

1, . . . , ℓ



















∈ {

· · ·

∈

}

= 0

(19)

Intuitively, Step 1 of Algorithm 2 ﬁnds a model σ such that each ui becomes zero, which makes the values of
the wi irrelevant. To this end, we compute maximum satisﬁability of our constraints C using the MaxSAT approach
. Then
of [NB14]. If this is not possible, we continue with a partition
{
induces a system of linear equations of the form (19) of size ℓ which is speciﬁed in Step 2 of the algorithm. If the
I
and the system of
PCP is satisﬁable (Step 3 of Algorithm 2), then we have found an assignment σ which satisﬁes
the form (19) for C. If the given PCP is unsatisﬁable, then we learn a new partition by making use of the unsatisﬁable
core and go back to Step 2 of Algorithm 2.

of the set of indices

I1, . . . , Iℓ

1, . . . , ℓ

=

P

I

}

{

}

6
6
6
6
Algebra-Based Reasoning for Loop Synthesis

17

: An arbitrary satisﬁable PCP

Input
Output: A model σ for the polynomial constraint problem
1. Call MaxSAT to compute maximum satisﬁability with soft constraints u1 = 0, . . . , uℓ = 0 and hard constraints

and a constraint C of the form (14).

P ∪ {

C

P

}

.

, and let σ be the resulting assignment. If all soft constraints are satisﬁed, then return σ. Otherwise, let

from
be the partition such that for every set of indices I

P

I

we have σ(wi) = σ(wj ) for i, j

I.

∈

∈ I

2. Construct a constraint problem

as follows:

Q

, add constraints wi = wj for i, j

(a) For each I
(b) For each distinct pair I, J
(c) For each I

∈ I

, add a constraint

∈ I

∈
, add a constraint wi
i∈I ui = 0.

∈ I

I.
= wj for some i

I and j

J.

∈

∈

3. If

P ∪ Q

is satisﬁable with model σ, then return σ. Otherwise, learn a new partition

P

and go to Step 2.

I

Algorithm 2: Solving C-ﬁnite constraints

Instance

S I D

C

5 1
add1*
5 1
add2*
5 3
cubes
3 1
double1
3 1
double2
eucliddiv* 5 1
intcbrt*
intsqrt1
intsqrt2*
petter1
square
dblsquare
sum1
sum2

5 173
5 173
94
6
29
4
3
24
5 185
5 2 12 262
6
4 2
53
6 104
4 1
29
4
3 1
29
4
3 1
30
4
3 1
53
6
4 2
82
6
5 3

Yices

Z3

Z3*

Z3* + Alg2

UN

UP

FU

UN UP

FU

UN UP

FU

UN

UP

FU

921
861
-

932
959
-
114
110
213
-
-

-
-
-
112 3882
106 1665
537
-
-
-
-
-
105 1164
-
116
112
-
112
112
-
105
109
-
617
-
-
-
-
-

117
-
-
115
-
-
116 114
-
113 111 113
115 106 115
114 115
-
117 116
-
113 108 114
113 111 115
114 113 113
112 114 117
105 105 110
108 112 113
220 112
-

22 726
-
22 109
-
18 496 575
63
21
13
40
18
13
73
19
-
83 469
22
19
15
-
37
27
15
32
18
15
26
17
13
26
17
12
99
17
24
20 516
-

87
3
2

7 2416
7 2323
-
5
5
10 2554
89
-
81
35
3
9
15
10
14
39
60

-
-
-
120
21
-
-
-
-
32 3629
592
29
31
-
250
-
-
-

S size of the recurrence system
I number of polynomial invariants
D maximum monomial degree of constraints
C number of constraints

* parameterized system
timeout (60 seconds)
-

Table 1. Absynth results for loop synthesis (results in milliseconds), by reverse engineering examples from the state-
of-the-art in polynomial invariant generation

6. Implementation and Experiments

6.1. Absynth: Algebra-Based Loop Synthesis

Our approach to algebra-based loop synthesis is implemented in the tool Absynth, which consists of about 1800
lines of Julia code and is available at https://github.com/ahumenberger/Absynth.jl. Inputs to Absynth are
conjunctions of polynomial equality constraints, representing a loop invariant. As a default result, Absynth derives a
program that is partially correct with respect to the given invariant (see e.g. Table 1). In addition, Absynth can also be
used to derive number sequences for which the given invariant is an algebraic relation (Table 2).

As described in Section 4, loop synthesis in Absynth is reduced to solving PCPs. These PCPs are currently
expressed in the quantiﬁer-free fragment of non-linear real arithmetic (QF NRA). We used Absynth in conjunction with
the SMT solvers Yices [Dut14] (version 2.6.1) and Z3 [DMB08] (version 4.8.6) for solving the PCPs and therefore
synthesizing loops. For instance, Figures 1b-1c and Example 4.1 are synthesized automatically using Absynth.

As PCPs in Absynth are restricted to QF NRA, the implementation of Algorithm 1 within Absynth does not yet
ﬁnd solutions containing non-real algebraic numbers. In our loop synthesis experiments we did not encounter instances
where non-real algebraic numbers are necessary. The synthesis of recurrences, however, often requires reasoning about
non-real algebraic numbers such as the so-called Perrin numbers p(n) deﬁned via p(n + 3) = p(n + 1) + p(n) and
satisfying the relation p(n)3
3p(n)p(2n) + 2p(3n) = 6. Going beyond the QF NRA fragment, as well as considering
ﬁnite domains (bitvectors/bounded integers) within Absynth is a next step to investigate.

−

6
18

Humenberger et al

Instance

fibonacci1
fibonacci2
example28
ex1
ex2
ex3

O

2
2
2
2
2
2

Yices Z3 Z3* Z3* + Alg2

-
-
-
-
-
-

-
-
-
-
-
-

-
-
-
-
-
-

324
22
41
27
20
451

O order of recurrence

-

timeout (60 seconds)

Table 2. Absynth results for recurrence synthesis (results in milliseconds)

6.2. Experimental Results with Synthesizing Loops and Recurrences

Our experiments in this paper were performed on a machine with a 2.9 GHz Intel Core i5 and 16 GB LPDDR3 RAM,
and for each benchmark a timeout of 60 seconds was set.

Tables 1-2 summarize our initial experiments using academic benchmarks from the invariant generation litera-
ture [HBK20] and recurrence solving [KP11]. The columns Yices and Z3 correspond to the results where the respec-
tive solver is called as an external program with and SMTLIB 2.0 ﬁle as input; as such, Yices and Z3 are used as
black-box solvers, with additional external calls on the PCP problems generated by Absynth as SMTLIB constraints.
To reduced the overhead with external calls on solving PCP constraints, as well as to implement our PCP optimiza-
tions measures from Section 5 as guiding technologies for SMT solving over PCPs, we extended Absynth with SMT
solving approaches tailored towards PCP reasoning. To this end, we implemented the optimizations from Section 5
as part of Absynth, by extending and integrating Z3 within Absynth. Column Z3* refers to the use of Absynth with
Z3 integrated, by directly integrating Absynth with the (C++ API) interface of Z3. Finally, column Z3* + Alg2 de-
picts the results for Algorithm 2 with Z3* as backend solver. The results in Tables 1-2 are given in milliseconds, and
only include the time needed for solving the constraint problem as the time needed for constructing the constraints is
neglectable.

Loop Synthesis. Our ﬁrst benchmark set for loop synthesis consists of invariants for loops from the invariant genera-
tion literature [HBK20], and is reported in Table 1. Note that the benchmarks cubes and double2 in Table 1 are those
from Figure 1 and Example 4.1, respectively. A further presentation of a selected set of our benchmarks from Table 1
is given in Section 6.3, using the Absynth input language.

The columns UN and UP in Table 1 show the results where the coefﬁcient matrix B is restricted to be unit upper
triangular and upper triangular respectively. FU indicates that no restriction on B was set. Note that the running time of
Algorithm 1 heavily depends on the order of which the integer partitions and the variable permutations are traversed.
Therefore, in order to get comparable results, we ﬁxed the integer partition and the variable permutation. That is,
for each instance, we enforced that B in formula (9) has just a single eigenvalue, and we ﬁxed a variable ordering
where we know that there exists a solution with an unitriangular matrix B. Hence, there exists at least one solution
which all cases – UN, UP and FU – have in common. Furthermore, for each instance we added constraints for avoiding
trivial solutions, i.e. loops inducing constant sequences, and used Algorithm 2 to further reduce our search space.
Table 1 shows that with these considerations on top of our optimizations from Section 5, Z3* outperforms Yices.
That is, our tailored use of Z3 directly integrated within Absynth brings the best performance in loop synthesis. A
similar experimental conclusion can be drawn also from our experiments in using Absynth for synthesizing number
sequences, as detailed next.

Recurrence Synthesis. In addition to loop synthesis, we also conducted experiments with respect to synthesizing
recurrence equations (Table 2). We took algebraic relations from [KZ08] and synthesized recurrence equations sat-
isfying the given relations. None of the instances could be solved by Yices or Z3, but only by Z3* + Alg2. Based
on our results from Tables 1-2, we conclude that using Z3 as an integrated backend solver of Absynth, that is Z3*
in Absynth, is the right approach to take for further applications of synthesizing loops with non-linear polynomial
invariants. We discuss further use cases of loop synthesis based on Absynth with Z3* in Section 7.

In contrast to loop synthesis, we note that the synthesis of recurrence equations often requires reasoning about
non-real algebraic numbers which does not fall into the fragment of non-linear real arithmetic. Hence, for synthesizing
recurrence equations we plan to further extend Absynth with a dedicate solver to reason about the whole set of
algebraic numbers; such reasoning is not yet supported by Z3*.

Algebra-Based Reasoning for Loop Synthesis

19

# eucliddiv
# Original loop

r, q, y = x0, 0, y0
while true
r = r - y
q = q + 1

end

# eucliddiv
# Absynth loop
# Solver: Yices
r, q, y = x0, 0, y0
while true

r = r - q - y
q = q + 1
y = y - 1

end

(a) Example eucliddiv with loop invariant x0 == y0*q+r

# square
# Original loop

a, b = 0, 0
while true

a = a + 2b + 1
b = b + 1

end

# square
# Absynth loop
# Solver: Yices
a, b = 0, 0
while true

a = a - 2b + 1
b = b - 1

end

# eucliddiv
# Absynth loop
# Solver: Z3
r, q, y = x0 - 1/2 y0, 1/2, y0
while true

r = r - q - 1/2 y + 1/2
q = q + 1/2
y = y - 1

end

# square
# Absynth loop
# Solver: Z3
a, b = 1/16, -1/4
while true

a = a + 2b + 1
b = b + 1

end

(b) Example square with loop invariant a == b^2

# sum1
# Original loop

a, b, c = 0, 0, 1
while true
a = a + 1
b = b + c
c = c + 2

end

# sum1
# Absynth loop
# Solver: Yices
a, b, c = 1/2, 1/4, 2
while true

a = a - 1/2
b = b - 1/2 c + 3/4
c = c - 1

end

# sum1
# Absynth loop
# Solver: Z3
a, b, c = -5/8, 25/64, -1/4
while true
a = a + 1
b = b + c
c = c + 2

end

(c) Example sum1 with input 1+2a == c && 4b == (c-1)^2

# intsqrt2
# Original loop

y, r = 1/2 a0, 0
while true

y = y - r
r = r + 1

end

# intsqrt2
# Absynth loop
# Solver: Yices
y, r = 1/2 a0, 0
while true

y = y + r - 1
r = r - 1

end
(d) Example intsqrt2 with loop invariant a0+r == r^2+2y

# intsqrt2
# Absynth loop
# Solver: Z3
y, r = 1/2 a0 - 5/32, -1/4
while true

y = y - r
r = r + 1

end

# intcbrt
# Original loop

x, r, s = a0, 1, 13/4
while true
x = x - s
s = s + 6r + 3
r = r + 1

end

# intcbrt
# Absynth loop
# Solver: Z3
x, s, r = 34/64 + a0, 7/16, -1/4
while true
x = x - s
s = s + 6r + 3
r = r + 1

end

(e) Example intcbrt with loop invariant 1+4a0+6r^2==3r+4r^3+4x && 1/4+3r^2==s

Fig. 3. Loops synthesized by Absynth, by reverse engineering examples from the state-of-the-art in polynomial in-
variant generation.

6.3. Examples of Synthesized Loops by Absynth

In Figure 3, we show a few illustrative examples used in our experiments from Table 1, using the Absynth input
language. As mentioned in Section 6.2, we considered loops annotated with their invariants from the invariant gener-
ation literature [RK07, HJK17]. For each example in Figures 3a-3e, we ﬁrst list such a loop (Original loop). We
then give the ﬁrst loop synthesized by our work (Absynth loop) in combination with Yices and Z3, respectively3.
That is, the synthesized loops of Figures 3a-3e are generated by Absynth from the loop invariants of [RK07, HJK17].
Observe that in most cases Absynth work was able to derive the loop as [RK07, HJK17].

3 In Figure 3e, Absynth with Yices failed to synthesize a loop, as indicated in Table 1.

20

Humenberger et al

(0, 0, 0)

←
←

(x, y, z)
←
while true do
if cond(x, y)
x + 1
y + 2

x
y
else
x
←
y
←
end if
z + 3
z
end
add

x + 2
y + 1

←

(a) Multi-path loop with invariant z = x + y

1/2)

−
7/32
11/32

1/2, 0,

(c, a, b)
(
−
←
while true do
c + (1/2)b
a + (1/2)b
b + 1/8

←
←
←

c
a
b
end
add

−
−

(b) Single-path loop with invariant c = a + b

Fig. 4. Examples of equivalent loops modulo invariants

7. Beyond Loop Synthesis

As argued in in Section 1, our work has potential applications in other areas related to synthesis. In this section we
report on our experience in using to loop synthesis (i) in the context of deriving loops that are equivalent based on some
metric and (ii) in the setting of teaching formal methods. We note that former use case (i) has applications towards
program/compiler optimization, as discussed below. Our experimental results from these use cases are summarized in
Table 3 and detailed next. Based on our initial experiments from Section 6 showcasing the clear beneﬁts of using Z3*
in Absynth, in this section, as well as in further applications of loop synthesis, we only deployed Absynth with Z3 as
an integrated backend solver.

7.1. Synthesizing Equivalent Loops modulo Invariants

Given a (potentially arbitrary) loop L with loop variables x, our work can be used to simplify L while maintaining the
polynomial invariants of L. That is, for a loop L with a polynomial relation p(x) = 0 as its invariant, our approach
can be used to synthesize a loop L′ such that L′ implements only afﬁne operations over x and p(x) = 0 is an invariant
of L′. In this case, we say that L and L′ are equivalent modulo the invariant p(x) = 0. More generally, we deﬁne this
form of equivalence between program loops as follows.

Deﬁnition 7.1 (Loop Equivalence modulo Invariants). Let L and L′ be two program loops, with variable sets re-
spectively denoted by xL and xL′. Let I(xL) be an invariant property of L. We say that the loops L and L′ are
equivalent modulo I if I(f (xL)) is an invariant property of L′ for some bijective function f : xL

xL′.

We write L

I L′ to denote that L and L′ are equivalent modulo I.

≡

→

Note that we deﬁne loop equivalence modulo an invariant I for arbitrary loops and arbitrary invariants. That is,
Deﬁnition 7.1 is not restricted to polynomial invariants, nor to program loops deﬁned by our programming model (8).
We next argue that our loop synthesis approach can be used to generate loops that are equivalent modulo an

invariant I, as follows:

1. Given a loop L with variables xL and a polynomial relation p(xL) = 0 as an invariant I(xL) of L;
2. Synthesize a loop L′ with variables xL′ such that I(xL′) is an invariant of L′.
Note that in our approach to infer L′ as an equivalent loop of L modulo I, (i) we restrict our invariants I to be
polynomial relations among loop variables, but (ii) we do not impose our programming model constraints (8) over
L. That is, our loop synthesis approach can be used to synthesize loops L′ that are “simpler” than an arbitrary (not
necessarily single-path afﬁne) loop L. For example, while a loop L with invariant I may contain arbitrary polynomial
assignments and nested conditionals, our loop synthesis approach can be used to derive a single-path loop L′ with
only afﬁne updates such that L′ is equivalent to L modulo I. Example 7.1 showcases such a use case of our loop
synthesis approach: we simplify a multi-path loop into a single-path loop, while maintaining loop equivalence modulo
an invariant. Such a simpliﬁcation can be seen as an instance of program/compiler optimizations, for example in the
generic setting of strength reduction, as argued in Section 1.

Algebra-Based Reasoning for Loop Synthesis

21

Instance

S I D C

5 2 3 90
cube conj
squared varied1 4 1 2 47
4 2 2 54
square conj
4 1 3 60
cube square
5 1 2 92
sum of square
squared varied2 4 1 2 50
3 1 2 32
fmi1
4 2 2 54
fmi2
4 2 2 55
fmi3
3 1 2 32
fmi4
3 1 2 32
fmi5

Z3*

Z3* + Alg2

UN UP FU

UN UP

FU

11
13

-
-
8 22
10
-
46
-
31 69

-
-
-
-
-
-
7 13 22
-
-
8 16 22
7 14 19

10 19
12 19

174
1906
2161
2316
65

-
-
68
-
-
295 155

-
-
-
-
-
-
21 267
86
-
-
-
84
34
7 217
-

1619
21
1840
13

S size of the recurrence system
I number of polynomial invariants
D maximum monomial degree of constraints
C number of constraints

- timeout (60 seconds)

Table 3. Absynth results for using loop synthesis for (i) the loop equivalence benchmarks of Figure 6 and in (ii) the
teaching efforts of formal methods from Figure 5 (results in milliseconds)

Example 7.1. Consider the multi-path loop of Figure 4a, for which z
y = 0 is an invariant. We write I(x, y, z) to
denote the polynomial invariant z
(z, c), (x, a), (y, b)
}
and use our loop synthesis approach to derive the single-path loop of Figure 4b from the invariant I(f (x), f (y), f (z)).
By soundness of our loop synthesis approach (Theorem 4.2), the invariant I(f (x), f (y), f (z)) denoting c
b = 0
is an invariant of Figure 4b. Hence, the loops of Figure 4a and Figure 4b are equivalent modulo z

y = 0 of Figure 4a. We choose the bijective function f =

a
−
−
y = 0.

−

−

−

−

x

x

x

{

In Figure 5 we give further examples of loops synthesized by our work such that the resulting loops are equivalent
modulo an invariant. The examples in Figure 5 have been constructed by us to showcase the non-linear arithmetic
reasoning features of Absynth. Further, the loops in Figure 5 are listed using the Absynth input languages, report-
ing further experiments made with Absynth. We note that our approach to loop equivalence exploits also the setting
of parametrized loop synthesis (Section 4.3): the initial values of loop variables of the respective equivalent loops
may differ, as illustrated in the examples of Figure 5. While our loop synthesis generates only afﬁne loops of the
form (8), Figure 5 illustrates that such loops can implement a wide range of afﬁne updates over loop variables, in-
cluding dependencies among updates, while maintaining loop equivalence modulo an invariant. We ﬁnally note that,
similarly to loop synthesis, loop equivalence modulo an invariant can be used in Absynth with invariants representing
arbitrary Boolean combinations of polynomial invariants; for example, conjunctive polynomial invariants as given in
Figure 5(a).

−

−

7.2. Loop Synthesis in Teaching Formal Methods

By further exploiting loop synthesis and its applications towards loop equivalence modulo invariant, we now detail
our setting for using loop synthesis in automating some of our efforts in teaching deductive veriﬁcation at the TU
Wien. Amid online lecturing and examinations during the COVID-19 epidemic, coming up with best practices to
assess course performance was far from trivial. We faced this challenge, for example, during our “Formal Methods
in Computer Science – FMI” course in the computer science master curriculum at TU Wien. In particular, we had
to provide plausible solutions towards online examinations on topics of deductive veriﬁcation, where students are
asked to formally prove partial/total correctness assertions using Hoare logic. As such, our online exam sheets were
designed by requiring solutions on (i) generating loop invariants and variants, and (ii) using invariants and variants to
conduct inductive proofs about program correctness. Yet, to minimize collaborative approaches towards solving online
exam solutions, we also had to design an online exam setting that (i) provided individual exam sheets for each student
enrolled in our course (about 350 enrolled students per study semester), while (ii) requiring the same solving workload
on each participant during our online exam. By taking into account all these constraints, we used our loop synthesis
approach to generate online exam problems on proving partial correctness, as follows:

1. We ﬁxed a small set x of program variables, typically using at most 3 variables;
2. We ﬁxed a few polynomial equalities among x by considering polynomials of degree at most 3. In particular, we
used at most 3 such polynomial relations, that is p1(x) = 0, p2(x) = 0, and p3(x) = 0, with each pi of degree at
most 3;

22

Humenberger et al

# cube conj
# Absynth loop
# Solver: Z3
a, b, c, d = 0, 1/8, -1/16,

1/4

while true

a = a + b - (1/2)d
b = b - 1/2
c = c + 2d - 1
d = d - 1

end

# cube conj
# Absynth loop
# Solver: Z3
a, b, c, d = 1/4, 1/8,
-15/64, 1/2

while true

a = a - b + (1/2)d - 1/8
b = b - 1/4
c = c + d - 1/4
d = d - 1/2

end

(a) Example cube conj with loop invariant a + 2b == d && d^2 + c == a^3

# squared varied1
# Absynth loop
# Solver: Z3
a, b, c = 7, 4, -1/2
while true

# squared varied1
# Absynth loop
# Solver: Z3
b, a, c = 2, 9/2, 0
while true

a = -15/32 + a + (1/2)c
b = -7/32 + b + (1/2)c
c = 1/8 + c

end

end

b = b - 1/4
a = -15/32 + a + (1/2)c
c = c + 1/8

(b) Example squared varied1 with loop invariant a(b + 2c) == b^2 + 5

# square conj
# Absynth loop
# Solver: Z3
b, c, a = -1/4, 1/16, -1/4
while true

# square conj
# Absynth loop
# Solver: Z3
b, c, a = 0, 1/4, 1/2
while true

b = -2/3 - (8/3)a + b
c = 1 + 2a + c
a = 1 + a

end

b = 1/16 - (1/3)a + b
c = 1/64 + (1/4)a + c
a = 1/8 + a

end

(c) Example square conj with loop invariant 2a == 3b + 4c && c == a^2

# cube square
# Absynth loop
# Solver: Z3
a, b, c = 31/512, -1/4, -1/8
while true

a = a + 2b + 1
b = b + 15/16 - (1/2)c

end

# cube square
# Absynth loop
# Solver: Z3
a, b, c = 1/8, 1/2, -1/2
while true

a = 1/64 + a + (1/4)b
b = -1/8 + b - (1/2)c

end

(d) Example cube square with loop invariant a == b^2 + c^3

# sum of square
# Absynth loop
# Solver: Z3
a, d, b, c = -1/8, 81/64,

-1/2, 1

while true

a = -5/4 + a - b + c
d = -49/32 + d - (1/8)b +

(13/8)c
b = 1/8 + b
c = 1/8 + c

end

# sum of square
# Absynth loop
# Solver: Z3
d, a, b, c = 9/8, -1, -1/4, 1/4
while true

d = -1 - 1/4 a - (1/8)b +

(17/4)c + d

a = -1/4 + a + (1/2)b + 2c
b = -1/2 + b
c = 1/8 + c

end

(e) Example sum of square with loop invariant a^2 + b^2 + c^2 == d

# squared varied2
# Absynth loop
# Solver: Z3
a, b, c = 1/8, 1/2, 7/8
while true

a = -31/68 + a - b +

(4/17)c
b = -1/2 + b
c = -17/8 + c

end

# squared varied2
# Absynth loop
# Solver: Z3
a, b, c = 3/16, 1/8, 3/8
while true

a = 1/2 + a - (1/2)b + (1/6)c
b = b + 1/3
c = c + 1

end

(f) Example squared varied2 with loop invariant 2a + 3b^2 - ab == c + ab

Fig. 5. Examples of loops generated by Absynth that are equivalent modulo an invariant

Algebra-Based Reasoning for Loop Synthesis

23

3. We constructed a polynomial property I(x) as a conjunctive formula among (some of) the ﬁxed polynomial rela-

tions pi(x) = 0;

4. We used loop synthesis in Absynth to generate different loops L that are equivalent modulo I. In the process of
generating these loops, we only considered loops whose coefﬁcients are given by relatively small integer/rational
numbers;

5. We formulated exam problems by reverse engineering instances of our loop synthesis task, using the loops gener-
ated by Absynth. That is, our exam problems on proving partial correctness were generated using the following
simpliﬁed template: “ Given the loop L, prove that I is an inductive invariant of L”, where we set L to be a loop
generated by Absynth using the invariant I.

Figure 6 showcases some loops generated by Absynth that have been used in the deductive veriﬁcation exam

problems of our FMI master course during 2020/2021.

We note that, depending on the invariants I we deployed for loop synthesis, as well as on the loop bodies of
the loops L generated by Absynth, we also considered exam problems where: (i) we used simple linear inequalities
as loop conditions bounding the number of loop iterations by a symbolic constant N (as shown in our motivating
examples from Figure 1); (ii) stated pre-conditions A and post-conditions B on L; and (iii) asked for proving partial
correctness of the Hoare triple

, by requiring students to also generate the necessary invariants I.

B

L

Based on the students’ performances during our online exams, we believe that the exam problems generated by
Absynth were fair challenges for students, reducing collusion among them. Moreover, despite the fact that our FMI
exams were conducted online since 2020, the overall FMI grade distributions on solved online exam sheets were very
similar to previous, in-class examinations.

A
}

{

{

}

8. Related Work

We now compare our loop synthesis work in relation to the state-of-the-art in program synthesis and algebraic reason-
ing about program loops.

Synthesis. To the best of our knowledge, existing synthesis approaches are restricted to linear invariants, see for in-
stance [SGF10], whereas our work supports loop synthesis from non-linear polynomial properties. Existing approaches
to SyGuS-based synthesis [ASFS18] differ in the (a) logical expressiveness of input speciﬁcations, (b) restrictions of
the solutions space of programs to be synthesized and (c) search strategies for solutions during synthesis. The key
difference between our work and the state-of-the-art in synthesis is three-fold: (i) we consider logical speciﬁcations
as (non-linear) polynomial invariant relations, (ii) synthesize loops with non-linear behaviour, and (iii) precisely char-
acterize the set of all such loops to be synthesized. To the best of our knowledge, existing approaches are restricted
to linear invariants, see e.g. [SGF10], and no other approach can automatically synthesize loops from polynomial in-
variants. In what follows, we discuss approaches that are mostly related to our work. focusing only on works handling
loops and/or recursion.

Counterexample-guided synthesis (CEGIS) [ASFS18, Sol09, FMBD18, NHTSL19] reﬁnes the deductive syn-
thesis approach of [MW80] and restricts the search space of programs by using templates and/or sketches [Sol09].
CEGIS provides an automated approach for synthesizing programs P from a given speciﬁcation S [ASFS18, Sol09,
NHTSL19]. For doing so, CEGIS uses input-output examples satisfying a speciﬁcation S to synthesize a candidate
program P that is consistent with the given inputs. Correctness of the candidate program P with respect to S is then
checked using veriﬁcation approaches, in particular using SMT-based reasoning. If veriﬁcation fails, a counterexam-
ple is generated as an input to P that violates S. This counterexample is then used in conjunction with the previous
set of input-outputs to revise synthesis and generate a new candidate program P . CEGIS-based approaches have
been extended with machine/active learning to control the selection of (counter-) examples satisfying S and guide
the synthesis of P [FMBD18]. Unlike these methods, input speciﬁcations to our approach are relational (invariant)
properties describing all, potentially inﬁnite input-output examples of interest. Hence, we do not rely on interactive
reﬁnement of our input but work with a precise characterization of the set of input-output values of the program to
be synthesized. Similarly to sketches [Sol09, NHTSL19], we consider loop templates restricting the search for solu-
tions to synthesis. Yet, our templates support non-linear arithmetic (and hence multiplication), which is not yet the
case in [NHTSL19, FMBD18]. We rely on ﬁxed point reasoning and properties of algebraic recurrences to encode the
synthesis problem as a constraint solving task in the theory of non-linear real arithmetic. We precisely characterize
the set of all programs satisfying our input speciﬁcation, and as such, our approach does not exploit learning to reﬁne

24

# fmi1
# Original loop

y, x = 0, 0
while true

y = 3x + y
x = x + 1

end

# fmi1
# Absynth loop
# Solver: Z3
y, x = 15/32, -1/4
while true

y = 3x + y
x = x + 1

end

(a) Example fmi1 with loop invariant 2y == 3x(x - 1)

# fmi2
# Original loop

x, y, z = 0, 0, 0
while true

x = x + z + 1
z = z + 2
y = y + 1

end

# fmi2
# Absynth loop
# Solver: Z3
z, x, y = 1/4, 1/64, 1/8
while true

z = z - 1
x = x - y + 1/4
y = y - 1/2

end

Humenberger et al

# fmi1
# Absynth loop
# Solver: Z3
y, x = -3/8, 1/2
while true

y = y + (3/8)x - 21/128
x = x + 1/8

end

# fmi2
# Absynth loop
# Solver: Z3
z, x, y = 1, 1/4, 1/2
while true

z = 1/8 + z
x = (1/8)y + x + 1/256
y = y + 1/16

end

(b) Example fmi2 with loop invariant z == 2y && x == y^2

# fmi3
# Original loop

x, y, z = 0, 0, 1
while true

x = x + 2
y = y + 6x
z = z + 1

end

# fmi3
# Absynth loop
# Solver: Z3
y, x, z = 27/32, -9/4, -1/8
while true

y = (-1/4)x + y - 1/2 +

(25/2)z

x = x + 2
z = 1 + z

end

# fmi3
# Absynth loop
# Solver: Z3
y, x, z = 9/2, -3, -1/2
while true

y = y + (1/2)x + 11/32 + (1/2)z
x = x + 1/4
z = 1/8 + z

end

(c) Example fmi3 with loop invariant y == 3xz && x == 2(z - 1)

# fmi4
# Original loop

x, y = 2, 1
while true

x = x + 4y + 2
y = y + 1

end

# fmi4
# Absynth loop
# Solver: Z3
x, y = 1/8, -1/4
while true

x = x + 4y + 2
y = y + 1

end

(d) Example fmi4 with loop invariant x == 2y^2

# fmi5
# Original loop

x, y = 0, 0
while true

x = x + 1
y = y - 10x + 5

end

# fmi5
# Absynth loop
# Solver: Z3
y, x = -5/16, -1/4
while true

y = -10x + y - 5
x = x + 1

end

# fmi4
# Absynth loop
# Solver: Z3
x, y = 1/2, 1/2
while true

x = (1/2)y + x + 1/32
y = y + 1/8

end

# fmi5
# Absynth loop
# Solver: Z3
y, x = -5/4, 1/2
while true

y = y - (5/4)x - 5/64
x = x + 1/8

end

(e) Example fmi5 with loop invariant y + 5x^2 == 0

Fig. 6. Loops synthesized by Absynth for online exam problems within the ”Formal Methods in Computer Science –
FMI” master course at TU Wien.

program candidates. On the other hand, our programming model is more restricted than [NHTSL19, FMBD18] in
various aspects: we only handle simple loops and only consider numeric data types and operations.

The programming by example approach of [Gul11] learns programs from input-output examples and relies on
lightweight interaction to reﬁne the speciﬁcation of programs to be speciﬁed. The approach has further been extended
in [KMP+18] with machine learning, allowing to learn programs from just one (or even none) input-output example
by using a simple supervised learning setup. Program synthesis from input-output examples is shown to be successful
for recursive programs [AGK13], yet synthesizing loops and handling non-linear arithmetic is not yet supported by
this line of research. Our work does not learn programs from observed input-output examples, but uses loop invariants
to fully characterize the intended behavior of the program to be synthesized. We precisely characterize the solution
space of loops to be synthesized by a system of algebraic recurrences, without using statistical models supporting

Algebra-Based Reasoning for Loop Synthesis

25

machine learning. Thanks to its precision, our method is however computationally more expensive and does not yet
scale to large programs/data sets.

A related approach to our work is given in [DKMS13], where a ﬁxed-point implementation for an approximated
real-valued polynomial speciﬁcation is presented. For doing so, the method of [DKMS13] uses genetic program-
ming [PLM08] to guide the search for synthesized programs and combines heuristic search with with abstract inter-
pretation [CC77] to estimate and reﬁne the (ﬂoating-point) error bound of the inferred ﬁxed-point implementation.
While the underlying abstract interpreter is precise for linear expressions, precision of the synthesis is lost for non-
linear arithmetic. Unlike [DKMS13], we consider polynomial speciﬁcation in the abstract algebra of real-closed ﬁelds
and do not address challenges rising from machine reals. As a consequence, we precisely synthesize loops from poly-
nomial invariants, by inherently relying on non-linear reasoning.

Algebraic Reasoning. Compared to works on invariant generation [RK07, HJK17, KCBR18, HOPW18], the only
common aspect between these works and our synthesis method is the use of linear recurrences to capture the functional
behavior of program loops. Yet, our work is conceptually different from [RK07, HJK17, KCBR18, HOPW18], as we
reverse engineer invariant generation and do not rely on the ideal structure/Zariski closure of polynomial invariants.
We do not use ideal theory nor Gr¨obner bases computation to generate invariants from loops; rather, we generate loops
from invariants by formulating and solving PCPs.

9. Conclusions

We proposed a syntax-guided synthesis procedure for synthesizing loops over afﬁne assignments from polynomial
invariants. We consider loop templates and use reasoning over recurrence equations modeling the loop behavior. The
key ingredient of our work comes with translating the loop synthesis problem into a polynomial constraint problem
and showing that this constraint problem precisely captures all solutions to the loop synthesis problem. Additional
heuristics for solving our constraints have been also implemented in our new tool Absynth for loop synthesis.

Directions for future work include a complexity analysis of our algorithm; further investigating the properties of
our constraint problems for improving the scalability of our procedure; generalizing our approach to multi-path loops
and inequality invariants; restricting the solution space to integers or bounded domains; extending Absynth with
reasoning support for arbitrary algebraic numbers; and understanding and encoding the best optimization measures
for loop synthesis in the context of program/compiler optimization approaches.

Acknowledgments

We thank Sumit Gulwani and Manuel Kauers for valuable discussions on ideas leading to this work. We acknowledge
funding from the ERC Consolidator Grant ARTIST 101002685, the ERC Starting Grant SYMCAR 639270, the ERC
Proof of Concept Grant SYMELS 842066, the Wallenberg Academy Fellowship TheProSE, the FWF research project
LogiCS W1255-N23, and the WWTF grant ProbInG ICT19-018.

References

[ABD+15]

[AGK13]
[ASFS18]

[BLR11]

[CC77]

[Coo18]

[CSV01]

Rajeev Alur, Rastislav Bod´ık, Eric Dallal, Dana Fisman, Pranav Garg, Garvit Juniwal, Hadas Kress-Gazit, P. Madhusudan, Milo
M. K. Martin, Mukund Raghothaman, Shambwaditya Saha, Sanjit A. Seshia, Rishabh Singh, Armando Solar-Lezama, Emina Torlak,
and Abhishek Udupa. Syntax-Guided Synthesis. In Dependable Software Systems Engineering, volume 40, pages 1–25. IOS Press,
2015.
Aws Albarghouthi, Sumit Gulwani, and Zachary Kincaid. Recursive Program Synthesis. In CAV, pages 934–950, 2013.
Rajeev Alur, Rishabh Singh, Dana Fisman, and Armando Solar-Lezama. Search-Based Program Synthesis. Commun. ACM,
61(12):84–93, 2018.
Thomas Ball, Vladimir Levin, and Sriram K. Rajamani. A decade of software model checking with SLAM. Commun. ACM,
54(7):68–76, 2011.
Patrick Cousot and Radhia Cousot. Abstract Interpretation: A Uniﬁed Lattice Model for Static Analysis of Programs by Construction
or Approximation of Fixpoints. In POPL, pages 238–252, 1977.
Byron Cook. Formal reasoning about the security of amazon web services. In CAV (1), volume 10981 of Lecture Notes in Computer
Science, pages 38–47. Springer, 2018.
Keith D. Cooper, L. Taylor Simpson, and Christopher A. Vick. Operator Strength Reduction. ACM Trans. Program. Lang. Syst.,
23(5):603–625, 2001.

Humenberger et al

26

[DKMS13]

[Gul11]
[Gul16]
[HBK20]

[HJK17]

[Hoa69]
[HOPW18]

[JGST10]

[KCBR18]

Eva Darulova, Viktor Kuncak, Rupak Majumdar, and Indranil Saha. Synthesis of ﬁxed-point programs. In EMSOFT, pages 22:1–
22:10, 2013.
Leonardo De Moura and Nikolaj Bjørner. Z3: An efﬁcient SMT solver. In TACAS, pages 337–340, 2008.
Bruno Dutertre. Yices 2.2. In CAV, pages 737–744, 2014.

[DMB08]
[Dut14]
[FMBD18] Yu Feng, Ruben Martins, Osbert Bastani, and Isil Dillig. Program Synthesis Using Conﬂict-Driven Learning.

In PLDI, pages

420–435, 2018.
Sumit Gulwani. Automating String Processing in Spreadsheets using Input-Output Examples. In POPL, pages 317–330, 2011.
Sumit Gulwani. Programming by examples: Applications, algorithms, and ambiguity resolution. In IJCAR, pages 9–14, 2016.
Andreas Humenberger, Nikolaj Bjørner, and Laura Kov´acs. Algebra-Based Loop Synthesis. In Brijesh Dongol and Elena Troubit-
syna, editors, iFM, volume 12546 of Lecture Notes in Computer Science, pages 440–459. Springer, 2020.
Andreas Humenberger, Maximilian Jaroschek, and Laura Kov´acs. Automated Generation of Non-Linear Loop Invariants Utilizing
Hypergeometric Sequences. In ISSAC, pages 221–228. ACM, 2017.
C. A. R. Hoare. An Axiomatic Basis for Computer Programming. Commun. ACM, 12(10):576–580, 1969.
Ehud Hrushovski, Jo¨el Ouaknine, Amaury Pouly, and James Worrell. Polynomial Invariants for Afﬁne Programs. In LICS, pages
530–539. ACM, 2018.
Susmit Jha, Sumit Gulwani, Sanjit A. Seshia, and Ashish Tiwari. Oracle-Guided Component-Based Program Synthesis. In ICSE,
pages 215–224, 2010.
Zachary Kincaid, John Cyphert, Jason Breck, and Thomas W. Reps. Non-Linear Reasoning for Invariant Synthesis. PACMPL,
2(POPL):54:1–54:33, 2018.

[KMP+18] Ashwin Kalyan, Abhishek Mohta, Oleksandr Polozov, Dhruv Batra, Prateek Jain, and Sumit Gulwani. Neural-Guided Deductive

[KMPS12]

[Knu97]
[KP11]

[KV13]

[KZ08]

[Lei17]
[MW80]

[NB14]

Search for Real-Time Program Synthesis from Examples. In ICLR, 2018.
Viktor Kuncak, Mika¨el Mayer, Ruzica Piskac, and Philippe Suter. Software Synthesis Procedures. Commun. ACM, 55(2):103–111,
2012.
Donald Ervin Knuth. The art of computer programming. Addison-Wesley, 1997.
Manuel Kauers and Peter Paule. The Concrete Tetrahedron - Symbolic Sums, Recurrence Equations, Generating Functions, Asymp-
totic Estimates. Texts & Monographs in Symbolic Computation. Springer, 2011.
Laura Kov´acs and Andrei Voronkov. First-order theorem proving and vampire. In CAV, volume 8044 of Lecture Notes in Computer
Science, pages 1–35. Springer, 2013.
Manuel Kauers and Burkhard Zimmermann. Computing the algebraic relations of C-ﬁnite sequences and multisequences. J. Symb.
Comput., 43(11):787–803, 2008.
K. Rustan M. Leino. Accessible Software Veriﬁcation with Dafny. IEEE Software, 34(6):94–97, 2017.
Zohar Manna and Richard J. Waldinger. A Deductive Approach to Program Synthesis. ACM Trans. Program. Lang. Syst., 2(1):90–
121, 1980.
Nina Narodytska and Fahiem Bacchus. Maximum Satisﬁability using Core-Guided MaxSat Resolution. In AAAI, pages 2717–2723,
2014.

[NHTSL19] Maxwell Nye, Luke Hewitt, Joshua Tenenbaum, and Armando Solar-Lezama. Learning to Infer Program Sketches. In ICML, pages

[PLM08]
[RK07]

[SGF10]

[Sol09]
[VdPS97]

4861–4870, 2019.
Riccardo Poli, William B. Langdon, and Nicholas Freitag McPhee. A Field Guide to Genetic Programming. lulu.com, 2008.
Enric Rodr´ıguez-Carbonell and Deepak Kapur. Generating All Polynomial Invariants in Simple Loops. J. Symb. Comput., 42(4):443–
476, 2007.
Saurabh Srivastava, Sumit Gulwani, and Jeffrey S. Foster. From Program Veriﬁcation to Program Synthesis. In POPL, pages 313–
326, 2010.
Armando Solar-Lezama. The Sketching Approach to Program Synthesis. In APLAS, pages 4–13, 2009.
Marius Van der Put and Michael F Singer. Galois Theory of Difference Equations. Springer, 1997.

