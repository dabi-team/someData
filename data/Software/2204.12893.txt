Beyond Duplicates: Towards Understanding and Predicting Link
Types in Issue Tracking Systems

Clara Marie Lüders
clara.marie.lueders@uni-hamburg.de
University of Hamburg
Hamburg, Germany

Abir Bouraffa
abir.bouraffa@uni-hamburg.de
University of Hamburg
Hamburg, Germany

Walid Maalej
walid.maalej@uni-hamburg.de
University of Hamburg
Hamburg, Germany

2
2
0
2

r
p
A
7
2

]
E
S
.
s
c
[

1
v
3
9
8
2
1
.
4
0
2
2
:
v
i
X
r
a

ABSTRACT
Software projects use Issue Tracking Systems (ITS) like JIRA to
track issues and organize the workflows around them. Issues are of-
ten inter-connected via different links such as the default JIRA link
types Duplicate, Relate, Block, or Subtask. While previous research
has mostly focused on analyzing and predicting duplication links,
this work aims at understanding the various other link types, their
prevalence, and characteristics towards a more reliable link type
prediction. For this, we studied 607,208 links connecting 698,790
issues in 15 public JIRA repositories. Besides the default types, the
custom types Depend, Incorporate, Split, and Cause were also com-
mon. We manually grouped all 75 link types used in the repositories
into five general categories: General Relation, Duplication, Composi-
tion, Temporal / Causal, and Workflow. Comparing the structures of
the corresponding graphs, we observed several trends. For instance,
Duplication links tend to represent simpler issue graphs often with
two components and Composition links present the highest amount
of hierarchical tree structures (97.7%). Surprisingly, General Relation
links have a significantly higher transitivity score than Duplication
and Temporal / Causal links.

Motivated by the differences between the link types and by
their popularity, we evaluated the robustness of two state-of-the-
art duplicate detection approaches from the literature on the JIRA
dataset. We found that current deep-learning approaches confuse
between Duplication and other links in almost all repositories. On
average, the classification accuracy dropped by 6% for one approach
and 12% for the other. Extending the training sets with other link
types seems to partly solve this issue. We discuss our findings and
their implications for research and practice.

ACM Reference Format:
Clara Marie Lüders, Abir Bouraffa, and Walid Maalej. 2022. Beyond Dupli-
cates: Towards Understanding and Predicting Link Types in Issue Tracking
Systems. In 19th International Conference on Mining Software Repositories
(MSR ’22), May 23–24, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA,
13 pages. https://doi.org/10.1145/3524842.3528457

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA
© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9303-4/22/05. . . $15.00
https://doi.org/10.1145/3524842.3528457

1 INTRODUCTION
Development teams use Issue Tracking Systems (ITS) such as Bugzilla,
Github Issues, or JIRA to track issues, including bugs to be fixed or
features to be implemented. Over the years ITS have emerged as a
central tool for planning and organizing development work [42],
and for communicating with users and other stakeholders [4]. How-
ever, a considerable pain point for stakeholders using ITS, as high-
lighted in the work of Fucci et al. [14], is the identification of depen-
dencies between issues. Research found that linking issues can help
reduce issue resolution time [22] and prevent software defects [30].
Missing or incorrect links are problematic for requirements anal-
ysis and release planning [35]. For instance, missing Depend or
Block links of an issue might be crucial for the assigned release.
Missing Duplicate links might lead to missing information relevant
for testing. A project might easily get thousands of issues. Each
new issue might thus have hundreds of thousands of potentially
relevant links. Correctly identifying and connecting issues quickly
becomes difficult, time-consuming, and error-prone [14, 23].

Most ITS allow the creation of different links between the is-
sues to indicate technical or workflow dependencies. For instance,
Bugzilla allows to set properties such as “depends on”, “blocks”, and
“See also” for bug reports as well as to set the resolution status as
“duplicate” with link to a duplicate report [1]. Similarly, JIRA users
can choose between four possible default types in the Issue Links
1. Additionally, Subtasks
section: Relate, Duplicate, Block, and Clone
and Epics can be linked in separate sections. Organizations can
create and use additional link types to meet their specific needs. For
instance, Qt2 uses 6 link types including Split and Replace. Apache3
uses as many as 21 including the custom link types Container or
Breaks. Each link type usually has an explicit definition in the ITS.
Over time, stakeholders might also develop an “implicit” under-
standing of the connection represented by the link type. This might
be either indeed unique to the community or simply a different
name denoting the same connection labeled differently in another
community. For instance, Apache uses both the link type Depend
and Block, while all other repositories only use one of these types
predominantly. In Bugzilla these two link types are equivalent4.

Studying the various link types and their usage patterns across
the communities is essential for supporting issue linking and tight-
ening automated tool support particularly predicting missing links
[24, 39] to alleviate the burden of dependency identification for
stakeholders [14]. In recent years, research has intensively studied
the specific type Duplicate. Detecting those links would reduce the

1JIRA users can clone an issue. A Clone link is then automatically created.
2https://bugreports.qt.io/secure/Dashboard.jspa
3https://issues.apache.org/jira/secure/Dashboard.jspa
4https://bugzilla.readthedocs.io/en/latest/using/understanding.html

 
 
 
 
 
 
MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

Clara Marie Lüders, Abir Bouraffa, and Walid Maalej

resolution time of duplicated issues and might reveal additional in-
formation included in one but not the other issue [5, 8]. Based on a
Bugzilla dataset by Lazar et al. [21], researchers recently presented
duplicate prediction approaches using state-of-the-art machine
learning models with top performances of up to 97% [10, 16].

This work takes a holistic view on issue link types. We report on a
study comparing the various types and their usage in 15 well-known
public JIRA repositories [27]. By studying link types in JIRA, a
widely used ITS in practice, we hope to create awareness about how
the other types beyond duplicates are used and to inform a more
generalizable and reliable link type predictions. Our work has three
specific contributions. First, we manually reviewed and analyzed all
types found in the ITS and categorized them into five general link
categories to ease comparison. We report on the types, categories,
and usage frequencies across the studied repositories. Second, we
apply techniques from the field of graph theory to compare the
complexity, shape, transitivity [32], and assortativity [28] of the
different issue graphs corresponding to each link category. Our
comparison reveal structural similarities across the repositories
and several expected and unexpected trends. Third, we show that
current link prediction models seem to rather learn the existence of
the links instead of the specific link types. We discuss how future
research should deal with this to improve prediction reliability. We
also share our analysis code and the labeled data to ease replication.5
The remainder of the paper is structured as follows. Section 2
outlines our research questions, method, and data. Section 3 reports
on the link types and how they are used across the repositories . Sec-
tion 4 presents the results of our link prediction experiments based
on state-of-the-art duplicate detection approaches. In Section 5, we
discuss how our results can be used by practitioners to monitor and
tune their link usage and by researchers to develop and evaluate
more precise link prediction approaches. Finally, we discuss related
work in Section 6 and conclude the paper in Section 7.

2 RESEARCH SETTING
We briefly introduce our research questions and how we answered
them. Then, we describe the dataset used in our research.

2.1 Research Questions and Method
Our work takes the first step toward extending issue duplication
research to other link types in Issue Tracking Systems. We aim at
understanding the various link types and how current duplicate
prediction approaches can deal with them. In particular, we focus
on the following research questions:

• RQ1. Usage: How are various link types used in practice,
particularly in term of prevalence and structural properties?
• RQ2. Detection: Are state-of-the-art models for duplicate
detection able to distinguish between Duplicate and other
links?

Studying the prevalence in RQ1 means analyzing how frequent
certain link types are used in practice. By comparing the frequen-
cies between different repositories, we hope to identify common
trends. Moreover, structural properties refer to the structures of
the different issue graphs that consist of certain link types. The

5https://github.com/RegenKordel/LYNX-BeyondDuplicates

idea here is that different “graph types” corresponding to differ-
ent link types might exhibit different properties. These properties
could be leveraged for prediction or to find problematic areas by
investigating substructures that exhibit outlying values.

To answer RQ1, we first searched for a large ITS dataset, possi-
bly of an issue tracker that allow customized link types and that
is widely used in software development. The public JIRA dataset
recently shared by Montgomery et al. [27] meets this requirement.
JIRA offers various default link types and allow their customization,
e.g., to support different workflows. We manually analyzed all 75
link types in the dataset, their names, descriptions, and hundreds
of random issue examples linked by the types. To reduce the com-
parison dimensions, we grouped link types that denote a similar
connection to a link category. We set the categories based on the
information a stakeholder would gain from viewing a link with a
certain type as well as potential use cases of the link types. This step
included multiple iterations between the first and second author
and two main sessions with all authors to review and consolidate
the categories and decide about five ambivalent types by discussing
example links. The link types, categories, corresponding examples,
and our notes are included in the replication package. We analyzed
the general characteristics of the link categories. For this, we stud-
ied the issue graphs, where the vertices are the issues and the edges
are the links that exist between these issues. We then compared the
graphs spanned by a certain link type and a certain category.

RQ2 aims at re-evaluating state-of-the-art duplicate prediction
models by feeding them with other link types which are common in
practice. The link type Duplicate has been the focal point of research
and has been rather viewed in isolation in previous work. We aim
to evaluate duplicate detection model’s applicability in practice by
using data that contains a more realistic distribution of link types.
Many duplicate link detection approaches use the Bugzilla datasets
of Lazar et al. [21]. These approaches are based on the assumption
that Duplicate are more similar than any other pair of issues. The
machine learning models in previous works are trained on datasets
consisting of Duplicate and randomly created Non-Links, which are
highly dissimilar in comparison. Other link types are usually neither
included in the training nor in the evaluation. We assume that linked
pairs of issues should have a higher similarity than Non-Links and
thus, can be harder to distinguish by the machine learning models.
Current research does not evaluate if the prediction reliably predicts
actual Duplicate or whether other link types in the ITS confuse the
prediction. Thus, we evaluate how well current duplicate prediction
models work on our dataset which include issue pairs that are linked
but are not duplicates.

2.2 Research Data
We used a dataset of 15 public JIRA repositories [27]. Table 1 sum-
marizes the analyzed repositories in terms of the number of issues,
links, and link types. The table also shows the coverage, which
represents the number of issues having at least one link as well as
the share of cross-project links (within the same repository). The
minimum and maximum for each metric across all repositories are
indicated in bold.

The investigated repositories have different sizes ranging from
1,865 to 960,929 reported issues. The repositories also vary in terms

Beyond Duplicates: Towards Understanding and Predicting Link Types in Issue Tracking Systems

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

Table 1: Overview of studied JIRA repos (alphabetical order).

Columns: Documented Link Types (#Types);
percentage of issues with a link (%Cov.);
percentage of links for issues from two different projects. (%CP)

#Issues #Links #Types %Cov. %CP
Repository
21 28.3% 5.3%
Apache
970929 242823
8 55.1% 4.6%
16225
Hyperledger
27914
10 55.5%
3222
-
IntelDAOS
5557
11 29.8% 8.2%
3206
JFrog
14769
19 47.7% 43.9%
98122
265343
Jira
18 32.8% 6.8%
10911
JiraEcosystem 40602
8 44.5% 2.5%
14618
31229
MariaDB
4.0% 4.6%
Mindville
4
44
2134
13 42.6% 11.3%
37545
90629
MongoDB
8 28.9% 7.2%
140237
Qt
35855
18 38.9% 23.4%
315797 106200
RedHat
7 42.2% 1.4%
19057
49204
Sakai
11
4289
77837
Sonatype
7.5% 1.5%
9 25.6% 10.0%
14461
69100
Spring
6 39.8% 2.4%
SecondLife
630
1865
171
2103146 607208
-
-
Total
11.4 34.8% 9.5%
-
-
Average

of link types and number of existing links: ranging from 4 link
types and 44 links for Mindville up to 21 link types and 242,823
links in the case of Apache. The average coverage is about 35%
meaning that only 35% of all issues are linked. However, this varies
too: Mindville has the lowest coverage of 4.0% and Hyperledger
the highest coverage of 55.5%. The table shows that links rarely
cross project boundaries as the majority (90% average) of links are
between issues of the same project, apart from Jira and RedHat.
The Jira repositories, corresponding to the development of the JIRA
issue tracker itself, shows the second highest coverage among all
repositories (55%) as well as one of the highest number of link
types (19) after Apache (21).

JIRA offers a general section for setting the links. We encountered
two additional link types that are bound to specific issue properties
in our analysis: the Epic and Subtask link types. These types are not
displayed in the general links section and require users to set the
issue type accordingly. Apache, Qt, Secondlife, and Spring include
rare cases where the Subtask links are not linked to a subtask issue.
When mining the data for the links, we observed that a link can
contain a private issue, for which we have no further information.
We thus excluded from the analysis links where one of the linked
issues is private. Most linked issue pairs (97.6%) had only one link
type. The remaining multi-links often seemed conflicting, such as
Duplicate and Block. Thus we also removed them from the dataset
for the subsequent analysis.

To simplify the analysis, we consider all connections as undi-

rected.

3 USAGE OF ISSUE LINKS TYPES (RQ1)
We first present the various link types, the categories emerging from
the manual analysis as well as the corresponding usage frequencies.
Then, we report on the structural properties observed for the types.

Table 2: Overview of cleaned link types, their descriptions,
number of using projects, and the mapped categories.

Link type
Relate

Duplicate

Subtask
Clone

Depend

Epic

Block

Incorporate

Split

Cause

Description
Two issues are related to each other in a gen-
eral way or stakeholders are unsure about
the nature of the connection.
An issue is already in the system and some-
one added the same issue by accident.
An issue is a part of a larger issue/task.
An issue was duplicated intentionally by
the users, e.g., when an old bug resurfaces
in a newer version.
An issue cannot be resolved until another
issue is resolved.
A link that consists of higher-level issue
which has multiple low-level issues at-
tached to it, similar to Parent-Child or In-
corporate.
An issue cannot be resolved until another
issue is resolved.
An issue is included or contained in another
issue. E.g., an issue is used to collect multi-
ple other issues, similar to Parent-Child.
An issue is split into multiple issues to re-
duce the size or complexity.
Issue A describes a problem that is at least
a partial root cause for Issue B.

Projects Cat.

15

Rel

14

14
12

Dup

Com
Dup

10

T/C

9

Com

8

8

8

7

T/C

Com

Com

T/C

Bonfire Testing An issue was discovered while testing an-

6 WFl

Finish-finish

Supercede

Finish-Start

Fix

Follow

other issue.
Two issues must be finished at the same
time or patch.
An issue was refined based on existing is-
sues.
An issue must be finished after another is-
sue.
An issue resolution fixes another issue as
well.
An issue should be done after another issue,
a temporal dependency.

Parent-Child A parent issue has multiple children issues.

Breaks

The children are parts of the parent.
An issue breaks the solution of another is-
sue.

4

T/C

4 WFl

3

T/C

3 WFl

3

3

T/C

Com

2 WFl

Documented An issue provides the documentation or log

2 WFl

Implement
Start-Start
Test
Backport

Derive
Detail

Precede
Replace

Require

Start-Finish

Trigger

files for another issue or its fix.
An issue implements another issue.
Two issues must be started at the same time.
An issue is testing the fix of another issue.
The same issue was fixed in an older version
as part of the maintenance process.
An issue is derived from another issue.
An issue is detailed by another issue with
more fine-granular description.
Issue A should be resolved before Issue B.
An issue was created in order to replace an
old one, often resolution is “Duplicate”.
An issue cannot be resolved until another
issue is resolved.
The completion of an issue sets off the start
of another.
While working on an issue, another issue
was triggered.

2 WFl
2
T/C
2 WFl
1 WFl

1 WFl
1 WFl

1
1

1

1

T/C
Dup

T/C

T/C

1 WFl

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

Clara Marie Lüders, Abir Bouraffa, and Walid Maalej

3.1 Link Categories and their Prevalence
We recorded a total of 75 different link type names in the origi-
nal data. We first manually grouped together link types with sim-
ilar word stems (e.g. “finish-finish [gantt]”, “gantt: finish-finish”
or “Depend”, “Dependency”, “Dependent”, “Depends”). Then, we
compared the meaning of the types by reviewing their textual de-
scriptions in the repositories and checking random examples of
linked issues. For instance, 9 repositories used synonym names for
Incorporate, such as “includes”, “contains” or “incorporates”. This
step led to 30 distinct link types, which are listed in Table 2 with
brief descriptions, and the count of repositories where they are
used.

Unsurprisingly, link types provided by default in the JIRA ITS are
among the most popular. Moreover, the custom link types Depend,
Incorporate, Split, and Cause are common. Table 3 shows the shares
of the common link types, appearing in 7 or more repositories. Our
analysis shows that Relate is overall predominant with 35% of all
links. In five repositories, namely Jira, MariaDB, MongoDB, Sakai,
and Spring even >47% of the links are Relate. On average, Subtask
has a share of 21%, Epic 19%, and Duplicate 13% of all links. All other
types have a share of less than 10%. We also observe that Depend
and Block are complementary in most cases. The only ITS that uses
both with a similar frequency is Apache. The same pattern is also
visible in Incorporate and Split except for JiraEcosystem.

After a close inspection of multiple examples for each of the
30 cleaned link types in the corresponding ITS, we identified the
following five overarching link categories:

General Relation (Rel): Links that indicate a general relationship
between issues, which is not specific, but offers relevant or
useful information to implement, fix, reproduce, or plan an
issue. E.g., one java class is the origin of two bugs.
Duplication (Dup): Links to indicate that two issues describe the
same bug, feature, or task. A duplication issue can be added
intentionally (Clone, Replace) or unintentionally (Duplicate).
E.g., two users find and report the same bug without being
aware that the bug was already documented in the ITS.
Temporal / Causal (T/C): Indicate that an issue depends on the
resolution of another. This can be due to causal or temporal
reasons. E.g., One feature is part of a release. A second feature
that builds on the first can only be released later.

Composition (Com): Links that indicate a structural relationship
between two issues. This link is created when an issue is
split into multiple sub-issues, when user stories are added to
an epic, or a parent issue gets split to sub-tasks or children
issues. E.g., a stakeholder creates a ticket for a feature and
splits it into multiple tasks that need to be completed.
Workflow (WFl): Links that indicate that an issue was discovered,
reported, fixed, refined, or documented while working on a
certain development activity on another issue, like testing,
reviewing, or implementing it. E.g., while testing a feature,
a developer finds an unknown bug and documents it.

Table 2 shows the mapping of the link types to the categories.
A few link types might seem harder to categorize as the names
show a potential overlap with another category. For instance, we
categorized “Supercede” as Workflow as it reports the refinement
or evolution of an issue over time and is created while working on

Figure 1: Share of link categories across studied repositories.
the issue. Similarly, the link type “Break” can be misleading at first,
since it does not denote a work breakdown but a regression. For
such cases, we determined the final categorization based how the
example links were actually used in the studied repositories. An
interesting case are Clone and Duplicate types. On the first glance
they seem to describe the same type, but on closer inspection we
found that Clone links are created automatically, when an issue is
cloned with the corresponding JIRA feature. A stakeholder creates
the same issue again and changes either the properties or the title
based on the issue to be cloned. In contrast, Duplicate links are
created unintentionally when two different stakeholders submit the
same issue without being aware of the other. Both Clone and Du-
plicate are thus part of Duplication, but they should not be merged
as classes in a more fine-grained link type detection system.

Figure 1 depicts the prevalence of the link categories in each
repository. All categories are used with different frequencies across
all repositories, except that Composition was not used by Mindville
and Workflow was not used by MariaDB, Mindville, and SecondLife.
Furthermore, we observe three popularity levels. First, Composition
and General Relation were fairly pervasive: on average 36.6% of all
links were Composition closely followed by General Relation which
accounts for 35.3% of all links. Then, Duplication and Temporal /
Causal account on average for 16.8% and 11.4% of all links in the
repositories respectively. Duplication has one outlier, Mindville,
which only has 46 links. Finally, Workflow is least used link cate-
gory averaging about 3.0% of all links. Workflow has one outlier,
Sontatype, which uses this category for about 13.1% of the links.

In summary, the results confirms the heterogeneity of link
types in practice and that Duplicate links are by far not the most
frequent links. The fact that there are, on average, ∼11 link types per
repository suggests either an overwhelming semantic complexity,
an unnecessarily bloated complexity with potential type mismatch,
or ineffective issue linking.

3.2 Comparison of Link Types Structures
Next we explore and compare the graph structures formed by the
different link categories. For this, we use metrics which are fairly
popular and describe basic graph properties in the field of graph
theory. We chose these metrics as they can tell us how the issue

RepositoryApacheHyperledgerIntelDAOSJFrogJiraJiraEco.MariaDBMindvilleMongoDBQtRedHatSakaiSecondLifeSonatypeSpring0%25%50%75%100%CompositionGeneral RelationDuplicationTemporal/CausalWorkflowBeyond Duplicates: Towards Understanding and Predicting Link Types in Issue Tracking Systems

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

Table 3: Popularity of the link types across the studied JIRA repositories (usage shares in %).

5.2% 4.9%

-
- 39.7% 0.5%
-
- 65.7%
-
-
8.0%
0.1%
- 0.2%
1.1% 23.3% 1.2%

Repository Relate Subtask Duplicate Clone Depend Epic Split Block Incorporate Cause Coverage Other types
28.5%
Apache
17.1%
Hyperledger
12.1%
IntelDAOS
27.2%
JFrog
Jira
64.0%
JiraEcosystem 23.3%
51.1%
MariaDB
43.2%
Mindville
49.1%
MongoDB
22.4%
Qt
26.6%
RedHat
48.7%
Sakai
29.4%
SecondLife
38.8%
Sonatype

6.2%
8.3%
6.6%
-
1.0%
5.9%
6.4% 0.2% 13.0%
2.3%
-
-
18.5% 6.3% 0.4%
-
16.4% 13.2% 6.4%
- 0.1% 15.3%
-
-
-
-
12.9%
-
4.4%
-
-
-
3.7% 0.2% 0.1%

94.4% -
99.9% -
98.4% -
93.4% Trigger
96.4% -
98.2% -
100.0% -
100.0% -
95.2% -
92.8% Replace
95.0% Follow
99.99% -
93.5% Parent-Child
86.9% Bonfire Testing, Fix,

10.2%
1.7%
3.9%
2.9%
3.6%
4.5%
19.9%
0.6%
21.8%
2.8%
15.8%
1.8%
-
9.4%
38.6% 15.9%
0.2%
17.4%
10.7%
-
5.1% 15.6%
4.8%
9.5%
7.6%
-
-
7.9%

32.5%
27.6%
5.8%
36.3%
2.5%
20.4%
6.1%
-
1.6%
23.8%
20.4%
17.6%
49.8%
31.0%

1.0%
-
-
-
1.8%
3.8%
6.0%
-
1.7%
-
2.8%
-
-
5.3%

4.1%
-
-
1.3%
2.5%
1.8%
7.9%
-
-
-
9.1%
6.7%
2.2%
-

-
-

-

Spring
Mean
Stand. Dev.

47.7%
35.3%
14.8%

13.4%
20.6%
14.1%

12.1%
13.3%
9.2%

0.1%
4.9%
5.5%

-
12.1% 11.3%
8.2% 19.0% 1.1%
6.4% 21.2% 2.2%

-
7.3%
4.9%

-
4.5%
3.0%

-
3.2%
1.9%

Supercede
96.7% Supercede
96.1% -
3.6% -

graphs generally look like without visualizing them completely.
First Complexity describes how large the graph components are,
revealed by four metrics:

• %Isolated: The share of issues without links. A high number
of isolated issues shows that most issues are without links.
• %2Comp: The amount of graph components with exactly
two or more issues. A high number of 2-issues-components
shows that the graph is fairly simple.

• %3Comp+: The amount of components in the graph with
exactly three or more issues. A high number of 3-or-more-
issue-components shows that the graph is rather complex.
• Average Density: The average number of links in a com-
ponent divided by the number of possible links (only for
components with three or more issues). A high value indi-
cates that the graph components are highly inter-connected.

The graph Shape is, characterized by two metrics:

• %Trees: Number of tree-graph components. If the graph
components mostly consist of tree graphs, the issues are
ordered hierarchically.

• %Stars: Number of star-graph components, a subtype of
trees. A high percentage of stars indicate central issues, con-
nected to many other issues which do not have connections
to each other.

Figure 2 shows example structures found in the issue graphs: star
shape for Composition links in Apache and a tree shape for Temporal
/ Causal links in Qt. We analyze only the connected components. As
isolated issues and 2-issues-components are simple structures, we
exclude them in the shape analysis and focus on larger structures
including 3 or more components.

Assortativity is the Pearson correlation between the degree of
nodes at both ends of each edge in the graph. This value is between
−1 and 1. While social networks are usually more assortative (posi-
tive values), technological and biological networks tend to be more

disassortative (negative values). Assortative networks are more ro-
bust to vertex removal. Disassortative networks often have strong
hierarchical configurations with large nodes connecting smaller
nodes [28].

Finally, Transitivity is 3 times the number of triangles divided
by number of triads (two links that share one issue) [32]. This value
is between 0 and 1. Transitivity measures the frequency of triangles.
A value near 0 means the graph has low transitivity and a value
near 1 means the graph has high transitivity. E.g., if a link type has
high transitivity, then if issue A is linked with issue B which is in
turn linked to issue C, that stakeholders also put the same link type
between A and C in the ITS.

We first analyze the structure of the whole repositories based on
all links (without distinguishing between categories). Table 4 shows
the metrics for the complete issue graph (except for transitivity
which is rather meaningless without referring to the concrete link
semantic). We highlight the min and max values for each metric
and also present the mean and standard deviation. Overall the val-
ues seem rather homogeneous only with a few exceptions. Most
repositories have a high number of isolated issues, which shows

(a) Star graph of Composition
category in Apache.

(b) Tree graph of Temporal /
Causal category in Qt.

Figure 2: Example graph structures for different link cate-
gories.

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

Clara Marie Lüders, Abir Bouraffa, and Walid Maalej

Table 4: Metrics for the entire issue graph in a repository. All
values in percent except assortativity.

Columns: Assortativity (Asso.); Average Density (Den.); Isolated (%Iso.);
2-Components (%2C); 3-or-more-Components (%3C+)
Complexity

3C+ Shape

Repo.

Apache
Hyperledger
IntelDAOS
JFrog
Jira
JiraEco.
MariaDB
Mindville
MongoDB
Qt
RedHat
Sakai
SecondLife
Sonatype
Spring

Mean
Std. Dev.

Asso.

%Iso. %2C %3mC Den. % Tree % Star
-.061
61.8
37.0 .500
63.0
71.7
-.112
62.2
52.7 .428
44.9
47.3
-.233
62.9
60.1 .374
44.5 39.9
-.148
33.8 .556
66.2
70.2
66.3
.003
52.3 78.7
.534
47.6
21.3
-.148
63.4
40.4 .495
59.6
67.2
-.061
57.1
39.7 .543
60.3
55.5
-.055
100.0
4.9 .583
95.1
96.0
54.8
38.2 .524
61.8
57.4
.005
-.157
65.8
36.2 .522
63.8
71.1
-.054
58.0
38.2 .523
61.8
61.1
52.5
39.3 .514
60.7
57.8
-.079
66.2 -.282
47.2 .450
52.8
60.2
-.129
61.8
31.9 .502
68.1
92.5
-.099
62.6
37.4 .520
62.6
74.4
-.107
62.9
37.2 .505
62.8
65.1
.079
11.6
12.6 .052
12.6
15.0

82.5
78.4
75.7
87.1
65.2
83.0
75.1
100.0
80.0
85.6
78.4
74.4
77.9
84.2
81.2
80.6
7.6

overall a very disconnected repository structure. Furthermore, the
repositories seem to share almost a 2/3-1/3 split concerning their
simple 2-issue components to the more complex components con-
sisting of at least 3 issues. The outliers here are Jira, which seems
to have a relatively high number of 2-issue components – despite
having the second highest number of coverage. Hyperledger and
IntelDAOS both have a low number of simple components and
boast more complex structures.

Assortativity is around -0.1 on average. SecondLife is the most
dissortative issue graph (-0.282) which could indicate a very hier-
archical structure whereas MongoDB has the highest assortativty
(0.005). It seems that ITS repositories tend towards hierarchical
structures. Additionally, the average density of the three or more
issue components is around 0.505, which means that about half of
the theoretically possible edges are indeed set as issue links. On
average, 80.6% of the more complex components are trees, which
indicates that transitive edges might not be explicitly contained in
the studied ITS. Furthermore around 62.9% of these components
are star shaped.

In the next step, we calculated and compared the metrics for each
subgraph spanned by one link category. Table 5 shows the results.
We observe that General Relation differs from the other categories

Table 5: Metrics comparison of link categories.

Columns: Assortativity (Asso.); Transitivity (Tran.);
Average Density(Den.); Isolated (%Iso.);
2-Components (%2C); 3-or-more-Components (%3C+)

Category

Rel.
Dup.
T/C.
Com.
WFl

Complexity

3C+ Shape
%Iso. %2C %3C+ Den. #Links %Tree %Star
29.3 .562 218833
85.6 70.7
98178
17.2 .558
92.6 82.8
84236
26.5 .496
94.7 73.5
85.0 41.2 58.8 .394 190913
15048
98.9 84.5 15.5 .490

.025
81.9 62.8
.003
76.4
88.5
-.049
63.7
84.4
97.7 90.1 -.260
-.098
75.6
82.5

.121
.050
.048
.002
.003

Asso. Tran.

with the highest transitivity score. This is rather surprising since
we expected “stronger” links such as temporal, causal or composi-
tion links to be more transitive than general relation. Duplications
tend to be simpler, only having 17.5% complex components. These
complex components are often star-shaped (76.4%), which means
there exists one original issue, which is connected to its duplicates,
which by themselves do not share a link. As expected, Composition
have the most tree-like structures with 90.1% of their components
being cycle-free. This also means 9.9% of the complex issue compo-
sition components contain a cycle, which is rather surprising given
the meaning of these links and might reveal wrong link usages.
Composition also has the lowest assortativity with -0.260, which
indicates that this category is very hierarchical in nature compared
to the others. Temporal / Causal links are less star-shaped than
other categories, which suggests some "string-like" substructures
as the link category is rather tree-like. Workflow’s metrics are in
between the other metrics.

We observe that the percentage of isolated issues is negatively
correlated with the number of links. A high number of isolated
issues coupled with a high number of links reveals that the con-
nected components of the graph are very clustered. From the lower
isolated issues and higher amount of links, we conclude that these
links are rather scattered. The 0.5 average density confirms this.

In summary, the repositories are overall structurally similar,
while the link categories differ from each other. The differences
seem not strong enough to inform a link type prediction. These
metrics also give us a starting point for baselines that represent the
structural and complexity characteristics of ITS.

4 LINK VS LINK TYPE PREDICTION (RQ2)
Due to the considerable variety of link types in JIRA, it is important
that duplicate detection approaches (representing a well-researched
and mature area) are also able to differentiate Duplication links from
other link types. Thus, this section aims to explore how well current
duplicate detection models perform on our dataset.

4.1 Experimental Setting
4.1.1 Models. We used the Dual-Channel CNN (DCCNN) approach
by He et al. [16] and a Single-Channel CNN (SCCNN) approach
following recent work by Deshmukh et al. [10] and Budhiraja et
al. [7] . A DCCNN takes two issues and embeds them together, thus
modeling a link in the embedding. In contrast, a SCCNN only em-
beds one issue and then takes two issue embeddings and uses them
to predict if these issues form a duplicate link. To the best of our
knowledge, the Dual-Channel approach by He et al. has the highest
performance in the duplicate prediction literature. All other recent
top-performing models use a Single-Channel approach tuned with
varying layers and CNN or LSTM layers [10][7].

All published DCCNN and SCCNN models, which we are aware
of, use the same training and evaluation set-up: use duplicates in-
stance for the positive class and randomly created non-links for
the negative class. To evaluate current models on our dataset, we
asked the authors for the source code. We were only able to receive
the original code of the DCCNN approach from one of the authors,
which we used in our experiment. For the SCCNN, the researchers

Beyond Duplicates: Towards Understanding and Predicting Link Types in Issue Tracking Systems

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

could not share their original code. Thus, we implemented a SC-
CNN architecture with the same layers as the DCCNN model. This
bears the advantage that the results between both approaches are
comparable and we can isolate the effect of evaluating a more re-
alistic dataset with various link types, which is a common case in
practice.

We used the title and description of the issues as input to predict
if these are connected via Duplication links or not. The evaluated
DCCNN model stacks both issues of a link resulting in a tensor
of dimensions (300, 20, 2) and uses this as inputs for the CNN
layers. The SCCNN model has a (300, 20, 1) input. It uses the same
CNN layered architecture as the DCCNN model. Both issues are
processed by the model and then concatenated and fed into a dense
neural network.

For the data preprocessing we followed the same steps as He et
al. [16] to generate comparable results. We also used the same hyper-
parameter configurations as He et al., which are also recommended
by Zhang and Wallace [40]. We removed stopwords, lowercased,
and stemmed the textual data from description and title to train
a Word2Vec model. This is usually done for all state-of-the-art
models. Currently, BERT models achieve higher performance and
are favored for these tasks, but since the original research uses
Word2Vec, we chose to also use Word2Vec.

We carried out these steps for each repository. The initial dataset
crawled from the JIRA repositories contain Duplication links and
Other-Links. We also generated Non-Links, by randomly choos-
ing from all closed issues without the resolution “Duplicate”. Our
replication package include all source code details, data, and con-
figuration files.

4.1.2 Data. We trained the two models on 14 repositories. We
excluded Mindville, as it only has 46 links in total. Additionally, this
repository has only one data point with the type Block. Technically,
the models could be able to learn on this small dataset. However,
the test set only contains 9 data points, which is too small to draw
any significant conclusions. Furthermore, if a model only predicted
one class for all samples in the test data or had an infinite loss, we
labeled it as unable to learn on the training data. We excluded the
repository from this model’s result in this case. For the SCCNN
model this was only SecondLife. For the DCCNN model these were
IntelDAOS, JFrog, SecondLife, and Sonatype: all repositories with
less than 5,000 links. Essentially, we distinguish between 3 different
classes: Duplication, Other-Links (links of a different type), and Non-
Links, while state of the art duplicate detection models are trained
on Duplication vs. Non-Links and the Other-Links are disregarded.
We split the data once randomly in an 80/20 training-test-split.
The test set is balanced in the three classes Duplication, Other-Links,
and Non-Links. We report the results on this “new” test set, which
includes Other-Links as well as the “traditional” test set, which only
consists of Duplication and Non-Links. This way we can evaluate
how the models will perform on a realistic dataset.

4.1.3 Training Sets. For the training set we used 3 different config-
urations to analyze what learning task the models perform best on.
Specifically, we wanted to find out if the models are able to differ-
entiate Duplication from other link types or if they simply learn if
two issues are linked. The training set has always two labels.

We experimented with three different training set configurations.
The first two training sets aim at distinguishing Duplication from
[Other-Links and Non-Links], with Duplication having label 1 and
the other two classes having label 0. The third training set aims
at distinguishing links from the Non-Links. Thus Duplication and
Other-Links have label 1 and Non-Links has label 0. For reporting
the results we used the abbreviations explained in the following:

DvsNL Duplication vs. Non-Links. This correspond to the common
evaluation setting from the literature (e.g. [16],[10],[7]). We
check if the models are robust and still able to correctly
classify Other-Links and how the performance changes in
comparison to the “traditional” test set.

DvsOLNL Duplication vs. [Other-Links & Non-Links]. We use Du-
plication links as one class and Non-Links and Other-Links
together as the second class. We check if the models are able
to differentiate Duplication from Non-Links and Other-Links
when trained on all classes.

DOLvsNL [Duplication & Other-Links] vs. Non-Links. We check
how well the models perform when tasked with distinguish-
ing linked issues from non-linked issues.

Each training set is balanced including approximately the same
amount of instances for each class. This means we did not include all
possible Non-Links and Other-Links, as this would heavily imbalance
the dataset and possible skew the performance.

4.1.4 Metrics. We report on the precision, recall, and F1-score of
each class, and on the accuracy for the SCCNN and DCCNN models.
We also calculated the macro averages for precision, recall, and F1-
score of the classes as we do not want to give one class more weight
than the others. We did this for both test sets and also report the
changes of the model performance from the “traditional” to the
“new” set.

4.2 Experiment Results
Table 6 shows the results when trained on the common settings from
the literature, i.e. the models learn from a training set consisting
of Duplication and Non-Links. We observe, as expected, that the
performance on the traditional test set is high, with a Macro F1-
score of 0.80 (SCCNN) and 0.74 (DCCNN). Once the models were
presented with Other-Links data, the performance drops with 9%
lower F1-score for the SCCNN and 7% for the DCCNN.

On average, 57.5% (SCCNN) and 44.2% (DCCNN) of the Other-
Links were classified as Duplication. We see that the DCCNN archi-
tecture is slightly better at distinguishing Duplication from Non-
Links, but neither architecture is particularly good at this. We also
observe that the model performance regarding Other-Links varies a
lot between the repositories, ranging from 17% up to 85% (SCCNN)
and 32% up to 77% (DCCNN).

There were also differences depending on the link categories.
Composition links were mistaken as Duplication in 34% of cases,
General Relation in 52% of cases, Temporal / Causal in 40%, Workflow
in 45% for the DCCNN model. For the SCCNN model, Composition
links were mistaken as Duplication in 40% of cases, General Relation
in 47% of cases, Temporal / Causal in 49%, Workflow in 49%. The
hypothesis underlying current approaches is that Duplication text
descriptions are highly similar while Non-Links which are highly

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

Clara Marie Lüders, Abir Bouraffa, and Walid Maalej

Table 6: Single Channel CNN and Dual Channel CNN model
results averaged over the repositories for the case DvsNL.

Table 8: Single Channel CNN and Dual Channel CNN model
results averaged over projects for the case DOLsNL.

Class

Pre.

Rec.

F1

Acc.

Class

Pre.

Rec.

F1

Acc.

On traditional test set only with Duplication and Non-Links

On traditional Duplication and Non-Links test set

N Duplication
N
C
C
S

Non-Links
Macro avg

N Duplication
N
C
C
D

Non-Links
Macro avg

N Duplication
N
Non-Dup.
C
C
Macro avg
S

N Duplication
N
Non-Dup.
C
C
Macro avg
D

.78
.83
.81
.76
.72
.74

.85
.75
.80
.70
.78
.74

.81
.78
.80
.72
.75
.74

On new test set including Other-Links

.52 (-.26)
.89 (+.06)
.70 (-.11)
.51 (-.25)
.82 (+.10)
.67 (-.07)

.85 (+/-0)
.59 (-.16)
.72 (-.08)
.70 (+/-0)
.67 (-.11)
.68 (-.06)

.64 (-.17)
.70 (-.08)
.71 (-.09)
.59 (-.13)
.73 (-.02)
.67 (-.07)

.80

.74

.68 (-.12)

.68 (-.06)

N Duplication
N
C
C
S

Non-Links
Macro avg

N Duplication
N
C
C
D

Non-Links
Macro avg

N Linked
N
C
C
S

Non-Links
Macro avg

N Linked
N
C
C
D

Non-Links
Macro avg

.79
.75
.77
.71
.69
.70

.72
.81
.76
.66
.73
.70

.74
.77
.77
.68
.71
.70

On test set with Other-Links

.88 (+.09)
.75 (-.15)
.76 (-.01)
.83 (+.12)
.52 (-.17)
.68 (-.01)

.70 (-.02)
.81 (+/-0)
.74 (-.02)
.65 (-.01)
.73 (+/-)
.69 (-.01)

0.77 (+.03)
.68 (-.09)
.75 (-.02)
.73 (+.05)
.61 (-.10)
.69 (-.01)

.76

.70

.74 (-.02)

.68 (-.02)

dissimilar. The prediction models work thus well when only evalu-
ated on these two classes – even if not as precise as for the Bugzilla
dataset. It seems that Other-Links have varying degrees of similarity
across the different repositories.

Overall, the models are not able to distinguish Other-Links from
Duplication. This suggests we should include the Other-Links in
the training set to enable the models to differentiate them from
Duplication. For this we have two options, 1) train the model to
differentiate Duplication from Other-Links and Non-Links and 2)
train the models to differentiate Duplication and Other-Links (linked)
from Non-Links.

Table 7 presents the results of the first option, while Table 8 re-
ports on the second. We observe in Table 7 that the model performs
worse on the traditional test set compared to Table 6, but becomes
better on the new test set. Overall, on this training set configuration
DvNLOL the performance also worsens slightly on the new test
data, decreasing only 0.02 (SCCNN) and 0.01 (DCCNN).

For the second option (trained on DOLvsNL shown on Table 8)
the best macro F1-score, on average, is 0.75 for the SCCNN model.
Both settings can perform rather well, as we observed differences in
classification for the traditional setting between the repositories, we

Table 7: Single Channel CNN and Dual Channel CNN model
results averaged over the repositories for the case DvsNLOL.

Class

Pre.

Rec.

F1

Acc.

On traditional test set only with Duplication and Non-Links

N Duplication
N
C
C
S

Non-Links
Macro avg

N Duplication
N
C
C
D

Non-Links
Macro avg

N Duplication
N
Non-Dup.
C
C
Macro avg
S

N Duplication
N
Non-Dup.
C
C
Macro avg
D

.73
.78
.76
.70
.70
.70

.81
.68
.75
.70
.70
.70

.77
.72
.75
.70
.69
.70

On new test set including Other-Links

.55 (-.18)
.88 (-.10)
.71 (-.05)
.54 (-.16)
.82 (+.12)
.68 (-.02)

.81 (+/-0)
.66 (-.02)
.74 (-.01)
.70 (+/-0)
.70 (+/-0)
.70 (+/-)

.66 (-.11)
.75 (-.03)
.73 (-.02)
.61 (-.08)
.75 (+.06)
.69 (-.01)

.75

.70

.71 (-.04)

.70 (+/-0)

compared the F1-scores of the second and third setting in Table 9
for each repository. We observe that the SCCNN model trained
for the “linked” settings often performs best. Although there are
cases, namely Hyperledger, IntelDAOS, JFrog, and Spring where
peformance for Duplication detection is better or equal.

Table 9: Comparison of performance between DvsNLOL and
DOLvsNL across the studied JIRA repositories.

Repository

Apache
Hyperledger
IntelDAOS
JFrog
Jira
JiraEcosystem
MariaDB
MongoDB
Qt
RedHat
Sakai
Sonatype
Spring

SCCNN

DCCNN

DvsNLOL DOLvsNL DvsNLOL DOLvsNL

.77
.71
.65
.66
.81
.64
.69
.70
.77
.81
.71
.75
.65

.85
.67
.61
.64
.92
.66
.70
.80
.81
.86
.74
.85
.62

.69
.71
/
/
.76
.69
.65
.63
.69
.80
.66
/
.62

.73
.67
/
/
.84
.62
.65
.65
.69
.73
.65

.62

Overall, we see that the DOLvsNL setting, which predicts if a
mere link exists between two issues, performs the best for the SC-
CNN model, and overall achieves amost of the best performances
across the repositories. It seems that either the SCCNN models for
duplicate detection are rather link detection models or the stake-
holders’ usage of links is not clear and there exist a substantial
amount of mislabeling and undiscovered links. On average, we also
observe that the DCCNN model works similar for the DvsOLNL
and DOLvsNL setting. It is particularly robust, but the performance
is lower in comparison to the SCCNN setting DOLvsNL. We suspect
that a Dual-Channel architecture might be better at distinguishing
link types from each other. Additionally, the performance varies
strongly with the repository, which suggests that we might need to
adapt detection approaches to the characteristics of the repository.

Beyond Duplicates: Towards Understanding and Predicting Link Types in Issue Tracking Systems

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

Overall, none of the settings on the JIRA datasets achieved a
similarly high accuracy in comparison to the Bugzilla datasets [16],
which was above 0.94 for Open Office, Eclipse, and NetBeans.

5 DISCUSSION
We summarize the main findings and potential implications for re-
search and practice. Then we briefly highlight potential limitations
and threats to validity.

5.1 Summary of Findings
Bugzilla has three default link types and users can also link issues
via comments. In GitHub referencing another issues or pull requests
in the comments is the main way to establish an issue link. In
contrast, JIRA dedicates specific sections for creating default and
custom link types. The flexibility of issue link creation in JIRA
seems to allow stakeholders create a plethora of link types and
customize the ITS to the specific needs of their projects.

Our manual analysis of the different link types has resulted in a
link categorisation including General Relation, Duplication, Com-
position, Temporal / Causal, and Workflow – a first step towards a
universal taxonomy of linking in ITS. General Relation links are used
to point to useful information included in other issues. This link
category could be used as a reminder to specify another concrete
link type, which could be investigated by looking at the history
of issues. An example is issue ZOOKEEPER-3920 in Apache. A
General Relation link connects this issue to ZOOKEEPER-3466 and
ZOOKEEPER-3828, while the comments discuss if this should be
a Duplication link. Composition links are used to manage issues
and the corresponding workload as they are used to create a work
breakdown. Duplication links are used to indicate duplicate issues,
which are important to identify to prevent duplication of effort.
Finding duplicate issues can provide additional context information
which is useful to resolve the issue [42]. Temporal / Causal links
are useful for planning releases as they indicate the dependencies
between issues. Workflow links are perhaps useful for quality as-
surance, validation, and testing. These categories were regularly
used in all analyzed JIRA repositories except for 4 cases out of 75
usages (5 categories x 15 repositories).

Looking at the structural differences and similarities of the graphs
from the different link categories, we observed that the category
General Relation makes up the most transitive graphs among all link
type categories, while Duplication and Temporal / Causal should be
transitive by definition. One possible reason could be that Stake-
holders favor more efficient representations of the issue graph.
Inferrable transitive links of a link type category tend not to be
included explicitly. For example, if issue A is a component of issue
B, which is again a component of issue C, then the Composition
link between issues A and C tends not to be explicitly created by
stakeholders. One possible explanation is that stakeholders aim to
avoid an information overload on the single issue pages. In gen-
eral, we think that the analysis of structural differences and graph
metrics can be leveraged to find inconsistencies in the issue graph
or could be refined to track the health of an ITS. A high number
of isolated issues could, for instance, indicate a lot of unknown or
undocumented links.

Lastly, the results of RQ2 show that current duplicate detection
techniques are, not only significantly less accurate when applied
on JIRA, but are also unable to correctly distinguish between dupli-
cate and other link types. This limits their applicability in practice.
The DCCNN approach by He et al. [16] was more robust than the
SCCNN approach. We also found that the SCCNN approach per-
forms the best when used as a general link detection with a few
exceptions. This should be further investigated. Generally, there is a
significant room for improving link prediction models applied on a
realistic dataset with heterogeneous link types: both for predicting
duplicates and other links.

5.2 Implications for Practitioners
Mining the issue links in an issue tracker and evaluating fitting
metrics on the underlying issue graph could help overviewing
the issue repository and potentially monitoring ”ITS health” for
supporting project management and release planning activities.
Stakeholders could decide about the characteristics of ”healthy issue
graph” and their priorities. A healthy issue graph could, e.g., contain
only minimal needed edges with no transitivity to avoid information
overload, correct direction of issue links, correct link types, and no
sets of issues where the links are conflicting to each other (as issues
which create a directed cycle with Depend edges) [36]. Another
unwanted structure in an issue graph could be a set of issues with
many (unnecessary) links and a single link leading to another set of
issues with many (unnecessary) links. The single link that connects
these issue clusters can be missed due to information overload.

We showcased a few possible metrics and their interpretations.
For instance, Composition showed a hierarchical, tree-like structure,
but not in all cases. These exceptions could be analyzed to find
common errors or interesting insights for the corresponding reposi-
tory. Duplication components that are not star-shaped might not be
optimal, as one original bug should exist. Duplicates of duplicates
might contain important information, which is not visible to the
developer when they view the original issue. By looking in which
circumstances a transitive link was deemed important enough to
be made explicit, these could point to issues that have higher im-
portance. A dashboard calculating such metrics per individual link
type could make it easier to identify outliers issue clusters which
then can be investigated and if necessary, cleaned.

As link types and definitions of custom types can change over
time, it might also be useful to monitor the usage frequency over
time. Unused link types can be rechecked and eventually removed
in order to avoid confusing users with too many possible link types.
Information overload can also be reduced by analyzing and poten-
tially consolidating certain link types of the same category. Our
categorization scheme and the overall prevalence and complemen-
tary usage across the repositories can provide a concrete guidance
for practitioners. Issues with many links or multiple link types
might also indicate that an issue is too big and need to be broken
down into multiple parts [29].

5.3 Implications for Researchers
It is important for software engineering research to be applicable
in real-world scenarios as one of its main aims is to support the

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

Clara Marie Lüders, Abir Bouraffa, and Walid Maalej

work of software practitioners. Better understanding how stake-
holders use links to organize project issues should thus improve
the applicability of research on issue tracking, particularly machine
learning models to predict related – e.g. duplicated – issues. Our
experimental results show that state-of-the-art deep learning ap-
proaches for duplicate prediction are unable to precisely classify
Other-Links as Non-Duplicates in most JIRA repositories. Future re-
search should further evaluate this across other datasets, as Bugzilla
also includes other link types besides Duplicate.

Indeed, we think that our model evaluation strategy could
also inspire researchers to test other machine learning models (par-
ticularly binary classifiers) on more realistic settings, by trying to
confuse them. The idea is simple: negative classes should explicitly
include similar items to the positive class, which are still negative
though. This enables checking to what extent a model gets confused
even when the "new" negative class is represented in the training
data. In our research we included instances of Other-Links in the
negative class Non-Links.

Our results suggest that Dual-Channel approaches (which embed
both linked issues and thus the links itself) seems more robust when
presented with Other-Links. Single-Channel approaches seem able
to detect links instead of duplicates as this model performed the best
for this task on our dataset. A two-step approach, first detecting
the existence of a link and then the specific link type, might be
a reasonable and effective trade-off for detecting other link types
besides duplicates.

We also observed significant differences in the prediction perfor-
mance between the various JIRA repositories. This suggests that the
characteristics of the underlying repository should be taken into ac-
count: including for instance the exact link semantic shared across
a project members as well as the quality of the linking (i.e. probabil-
ity of human mistakes when setting links and link types). Another
interesting finding is that link transitivity is barely explicitly doc-
umented in JIRA. Stakeholders seem to rely on implicit transitive
links – a potentially useful information to down-prioritizing implicit
links in link recommendations. Cases where stakeholders make
implicit transitivity explicit are worth researching to understand
specific issue context or particular preferences of the stakeholders.
Overall, our results call for more intensive replication studies
with known duplicate detection models on different ITS and repos-
itories. Such studies should inform what type of link detection and
what model architecture work robustly on what ITS and what links.
Furthermore, redoing the analysis on link types instead of the cat-
egories can reveal more fine-grained differences. More complex
graph metrics can be designed or ”borrowed” from social network
research to find more insights into link usage in ITS [15].

5.4 Threats to Validity
During link type categorization, we observed that not all link types
are unequivocally categorizable and that interviews with key stake-
holders would be needed to exactly understand the link usage
within the repository. We tried to reduce this threat by looking at
and discussing multiple examples for each link type and repository.
The data is manually created and labeled by stakeholders. There-
fore we cannot rule out the possibility of undiscovered and missing
links as well as stakeholders not always agreeing on the way to

use the link types. For instance, issue CONJ-740 in MariaDB is
documented as the cause for issue CONJ-664, but a comment on
this issue states that it is a duplicate and the issue is closed as such.
Furthermore, we were not able to access private issues from
the investigated repositories. As a result, our dataset might not
be representative of the complete population of issues and their
links within each repository. Additionally, some repositories (e.g.:
RedHat) tend to create custom fields for links instead of a custom
link type, which are usually in the format “customfield_number”.
We looked through many issues from different repositories to find
and identify all such fields that link different issues together.

We used a single-channel approach to represent the other SotA
models and replicated the exact dual-channel approach as it was
reported to work best for duplicate detection. All duplicate detection
models leverage that duplicate issues should be very similar and
non-linked issues very dissimilar and only differ in their layers to
detect similarity. But, in practice, issues can have other types of
links and have varying degrees of similarity. All models that only
leverage similarity will then struggle to correctly asses Other-Links
as Non-Duplicates. Some approaches, as the dual-channel approach,
can be more robust to this problem. Furthermore, we did not test
the models on Bugzilla and GitHub issues, but we report results on
multiple JIRA. Thus, generalizability to other ITS might be limited.

6 RELATED WORK
Issue tracking systems have originally been geared toward collabo-
rative bug fixing. Early research such as the work by Zimmermann
et al. [42] closely analyzed ITS from the perspective of bug report
quality. They showed that duplicate bug reports are one of the most
common problems in ITS, after bug reports containing missing
or erroneous information. With the expansion of ITS to include
issue types other than bug reports, further works emerged focusing
on issue type classification. Herzig et al. [17] for instance found
that a substantial percentage of bug reports (33.8%) from a sam-
ple of 7000 were misclassified as bugs instead of feature requests.
The authors argue that such misclassifications introduce bias to
bug prediction models. Subsequent works have since used infor-
mation retrieval and machine learning techniques leveraging issue
description text and metadata to solve the bug report classification
problem [34] [41]. In requirements engineering research, on the
other hand, focus has been more directed towards the detection of
feature requests [25][12].

As ITS platforms mature, they face challenges related to repos-
itory growth and evolution. A case study conducted by Fucci et
al. [14] among stakeholders of a software company using JIRA to
document requirements found that information overload is one of
the biggest challenges faced by stakeholders. Interviewees of the
study expressed the need for a requirements dependency identi-
fication functionality to reduce the overhead of discovering and
documenting dependencies manually. Other challenges concern
ITS platforms being historically driven by bug reports and focusing
less on features and requirements.

Furthermore, the usage of ITS requires continuous maintenance
and cleanup of the issues. Projects that use ITS often undertake
triaging [2], whereby issues are revised, prioritized, and duplicate
issues are identified. Several works have proposed approaches to

Beyond Duplicates: Towards Understanding and Predicting Link Types in Issue Tracking Systems

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

facilitate triaging. Lamkanfi et al. focused on mining and predict-
ing the severity of Bugzilla issues [19][20], which directly influ-
ences their prioritization. Xuan et al. [38] leveraged developer so-
cial networks to understand developer prioritization and used the
results for triaging, severity prediction and reopening detection,
which greatly facilitates processes such as release planning. Jeong
et al. [18] used Markov chains to capture the bug tossing history in
developer networks and team structures to improve triaging.

Duplicate issue detection in particular is a tedious task when
manually curating a repository’s ITS. However, the problem lends
itself perfectly to automation using machine learning due to the
high assumed similarity of duplicate pairs. The overwhelming ma-
jority of scientific studies have therefore focused on duplicate link
detection [37][5][21] relegating the more general problem of link
type detection away from the center of attention. Deshmukh et
al. [10] proposed a single-channel siamese network approach with
triplet loss using a combination of CNNs and LSTMs to detect du-
plicate bug reports. They report an accuracy close to 90% and recall
rate close to 80%. He et al. [16] proposed a dual-channel approach
and achieved an accuracy of up to 97%. Rocha et al. [31] created a
model using all “Duplicate” issues as different descriptions of the
same issue and split the training and test along cluster boundaries.
All three works [10, 16, 31] use the dataset provided by Lazar et
al. [21], containing data mined from the four open source Bugzilla
systems: Eclipse, Mozilla, NetBeans, and OpenOffice.

Despite Duplication being the most widely researched link type,
other link types have also been considered for analysis although
much less extensively. For instance, Thompson et al. [35] studied
three open source systems and analyzed how software developers
use work breakdown relationships between issues in JIRA. They ob-
served little consistency in the types and naming of the supported
relationships. Merten et al. [26] studied links from the traceability
perspective and reported a poor applicability of traceability ap-
proaches in ITS due to poor quality. This represents an important
motivation for the use of metrics in our work to help identify link
inconsistencies for better predictions. Tomova et al. [35] studied
seven open source systems and reported that the rationale behind
the choice of a specific link type is not always obvious. The authors
found that while the Clone link is indicative of textual similarity,
issues linked through a Relate link presented varying degrees of
textual similarity and thus require further contextual information
to be accurately identified. Li et al. [22] examined the issue linking
practices in GitHub and extracted emerging linking patterns. In
their work, the authors categorized the link types into 6 link type
categories, namely: “Dependent”, “Duplicate”, “Relevant”, “Refer-
enced”, “Fixed”, “Enhanced”, all the rarer link types were assigned
the category “Other”. They furthermore found patterns facilitating
the automatic classification of the link types. For instance, they dis-
covered that “Referenced” links usually refer to historic comments
with important knowledge and that “Duplicate” links are usually
marked within the day.

Deshpande et al. [11] examined “Requires” and “Refines” links.
The authors extracted dependencies by integrating an active learn-
ing approach with ontology-based retrieval on two industrial datasets
achieving an F1-score of at least 75% in both training sets. Cheng et
al. [9] examined Block links. They used the repositories mined by

Lazar et al. [21] and predicted the Block link type with an F1-Score
of 81% and AUC of 97.5%.

As observed by Bertram et al.[4], ITS serve as a focal point
for communication, especially through the use of issue comments.
Linking issues to each other is also a form of communication, as
it serves to link two discussion threads. Additionally, stakeholders
often refer to other issues in issue discussions, as reported by Arya
et al. [3]. The authors categorized and predicted the issue comments
to improve communication and collaboration processes in GitHub
Issues. Communication gaps in large scale software development
lead to failure to meet customers’ expectations, quality issues, and
wasted effort [6]. Issue link research can improve other areas such
as Requirements Engineering through early failure prediction of
feature requests [13] as linked issues provide more context to be
leveraged by a classifier. Seiler et al. [33] found that insufficient
traceability and fragmentation of feature knowledge are major
practical problems. Link detection can help address these problems.
Qiang et al. [12] found that issue report classification based on
text mining is difficult to adopt as contributors only write short
texts. Other information such as structural data as well as context
provided by links can help addressing this challenge.

7 CONCLUSION
We studied 30 distinct link types in 15 large open source organi-
zations and identified an overarching categorization to help the
semantic clutter of issue linking. We reported on several expected
and unexpected trends concerning how the link types and the cate-
gories are used in practice: particularly in term of prevalence and the
structural properties of the underlying issue graphs. Furthermore,
we examined how Single-Channel and Dual-Channel deep-learning
approaches to detect the specific duplication links perform with
different training data. Both approaches seem unable to correctly
recognize Other-Links as non-duplicates. Future duplicate detection
models needs to consider other link types for a higher prediction
reliability and thus better applicability in practice.

On one hand, link detection approaches can create two-step
models that are able to distinguish the different link types. First, the
existence of a link is predicted and then, with a second model, its
type. Conducting a more detailed error analysis of existing duplicate
detection models on various datasets from different ITS will lead
to a better understanding of how to reduce the models uncertainty.
On the other hand, our observations of the usage of link types
can inform how to further enhance the outputs. For instance, by
analyzing the transitivity of a link type in a specific repository, we
can remove transitive links which are already implicitly contained
in the system. Our link analysis metrics can be used to monitor ITS
usage and explain the performance of a specific model architecture.
Overall, our results open up a new avenue for link type analysis
and detection beyond duplicates.

ACKNOWLEDGMENT
We thank Lloyd Montgomery for collecting the dataset. This work
has been partly conducted within the Horizon 2020 project Open-
Req, which is supported by the European Union under the Grant
Nr. 732463. The second author is funded by the German Science
Foundation DFG (MA 6149).

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

Clara Marie Lüders, Abir Bouraffa, and Walid Maalej

REFERENCES
[1] Mehdi Amoui, Nilam Kaushik, Abraham Al-Dabbagh, Ladan Tahvildari, Shimin
Li, and Weining Liu. 2013. Search-based duplicate defect detection: An industrial
experience. In 2013 10th Working Conference on Mining Software Repositories
(MSR). IEEE, USA, 173–182. https://doi.org/10.1109/MSR.2013.6624025

[2] John Anvik, Lyndon Hiew, and Gail C. Murphy. 2006. Who Should Fix This
Bug? Association for Computing Machinery, New York, NY, USA, 361–370.
https://doi.org/10.1145/1134285.1134336

[3] Deeksha Arya, Wenting Wang, Jin L. C. Guo, and Jinghui Cheng. 2019. Analysis
and Detection of Information Types of Open Source Software Issue Discussions.
In Proceedings of the 41st International Conference on Software Engineering (ICSE
’19). IEEE Press, Piscataway, NJ, USA, 454–464. https://doi.org/10.1109/ICSE.
2019.00058

[4] Dane Bertram, Amy Voida, Saul Greenberg, and Robert Walker. 2010. Com-
munication, Collaboration, and Bugs: The Social Nature of Issue Tracking in
Small, Collocated Teams. In Proceedings of the 2010 ACM Conference on Computer
Supported Cooperative Work (CSCW ’10). ACM, New York, NY, USA, 291–300.
https://doi.org/10.1145/1718918.1718972

[5] Nicolas Bettenburg, Rahul Premraj, Thomas Zimmermann, and 3 Sunghun Kim.
2008. Duplicate bug reports considered harmful . . . really?. In 2008 IEEE In-
ternational Conference on Software Maintenance. IEEE, USA, 337–345. https:
//doi.org/10.1109/ICSM.2008.4658082

[6] Elizabeth Bjarnason, Krzysztof Wnuk, and Björn Regnell. 2011. Requirements
are slipping through the gaps — A case study on causes & effects of com-
munication gaps in large-scale software development. In 2011 IEEE 19th In-
ternational Requirements Engineering Conference. IEEE, USA, 37–46.
https:
//doi.org/10.1109/RE.2011.6051639

[7] Amar Budhiraja, Kartik Dutta, Raghu Reddy, and Manish Shrivastava. 2018.
DWEN: Deep Word Embedding Network for Duplicate Bug Report Detection
in Software Repositories. In Proceedings of the 40th International Conference
on Software Engineering: Companion Proceeedings (ICSE ’18). Association for
Computing Machinery, New York, NY, USA, 193–194. https://doi.org/10.1145/
3183440.3195092

[8] Yguarata Cerqueira Cavalcanti, Eduardo Santana de Almeida, Carlos Eduardo
Albuquerque da Cunha, Daniel Lucrédio, and Silvio Romero de Lemos Meira.
2010. An Initial Study on the Bug Report Duplication Problem. In 2010 14th
European Conference on Software Maintenance and Reengineering. ICSE, USA,
264–267. https://doi.org/10.1109/CSMR.2010.52

[9] Xiaoyun Cheng, Naming Liu, Lin Guo, Zhou Xu, and Tao Zhang. 2020. Blocking
Bug Prediction Based on XGBoost with Enhanced Features. In 2020 IEEE 44th
Annual Computers, Software, and Applications Conference (COMPSAC). IEEE, USA,
902–911. https://doi.org/10.1109/COMPSAC48688.2020.0-152

[10] Jayati Deshmukh, K. M. Annervaz, Sanjay Podder, Shubhashis Sengupta, and
Neville Dubash. 2017. Towards Accurate Duplicate Bug Retrieval Using Deep
Learning Techniques. In 2017 IEEE International Conference on Software Main-
tenance and Evolution (ICSME). IEEE, USA, 115–124. https://doi.org/10.1109/
ICSME.2017.69

[11] Gouri Deshpande, Quim Motger, Cristina Palomares, Ikagarjot Kamra, Katarzyna
Biesialska, Xavier Franch, Guenther Ruhe, and Jason Ho. 2020. Requirements
Dependency Extraction by Integrating Active Learning with Ontology-Based
Retrieval. In 2020 IEEE 28th International Requirements Engineering Conference
(RE). IEEE, USA, 78–89. https://doi.org/10.1109/RE48521.2020.00020

[12] Qiang Fan, Yue Yu, Gang Yin, Tao Wang, and Huaimin Wang. 2017. Where Is the
Road for Issue Reports Classification Based on Text Mining?. In 2017 ACM/IEEE
International Symposium on Empirical Software Engineering and Measurement
(ESEM). IEEE, USA, 121–130. https://doi.org/10.1109/ESEM.2017.19

[13] Camilo Fitzgerald, Emmanuel Letier, and Anthony Finkelstein. 2011. Early failure
prediction in feature request management systems. In 2011 IEEE 19th International
Requirements Engineering Conference. IEEE, USA, 229–238. https://doi.org/10.
1109/RE.2011.6051658

[14] Davide Fucci, Cristina Palomares, Xavier Franch, Dolors Costal, Mikko
Raatikainen, Martin Stettinger, Zijad Kurtanovic, Tero Kojo, Lars Koenig, Andreas
Falkner, Gottfried Schenner, Fabrizio Brasca, Tomi Männistö, Alexander Felfer-
nig, and Walid Maalej. 2018. Needs and Challenges for a Platform to Support
Large-Scale Requirements Engineering: A Multiple-Case Study. In Proceedings of
the 12th ACM/IEEE International Symposium on Empirical Software Engineering
and Measurement (ESEM ’18). Association for Computing Machinery, New York,
NY, USA, Article 19, 10 pages. https://doi.org/10.1145/3239235.3240498

[15] Derek L. Hansen, Ben Shneiderman, Marc A. Smith, and Itai Himelboim (Eds.).
(second edition ed.). Morgan Kaufmann, USA. 31–51 pages. https:

2020.
//doi.org/10.1016/B978-0-12-817756-3.00003-0

[16] Jianjun He, Ling Xu, Meng Yan, Xin Xia, and Yan Lei. 2020. Duplicate Bug Report
Detection Using Dual-Channel Convolutional Neural Networks. Association for
Computing Machinery, New York, NY, USA, 117–127. https://doi.org/10.1145/
3387904.3389263

[17] Kim Herzig, Sascha Just, and Andreas Zeller. 2013.

It’s not a bug, it’s a
feature: How misclassification impacts bug prediction. In 2013 35th Interna-
tional Conference on Software Engineering (ICSE). IEEE, USA, 392–401. https:
//doi.org/10.1109/ICSE.2013.6606585

[18] Gaeul Jeong, Sunghun Kim, and Thomas Zimmermann. 2009. Improving Bug
Triage with Bug Tossing Graphs. In Proceedings of the 7th joint meeting of the Eu-
ropean software engineering conference and the ACM SIGSOFT symposium on The
foundations of software engineering (ESEC/FSE ’09). Association for Computing Ma-
chinery, New York, NY, USA, 111–120. https://doi.org/10.1145/1595696.1595715
[19] Ahmed Lamkanfi, Serge Demeyer, Emanuel Giger, and Bart Goethals. 2010.
Predicting the severity of a reported bug. In 2010 7th IEEE Working Confer-
ence on Mining Software Repositories (MSR 2010). IEEE, USA, 1–10.
https:
//doi.org/10.1109/MSR.2010.5463284

[20] Ahmed Lamkanfi, Serge Demeyer, Quinten David Soetens, and Tim Verdonck.
2011. Comparing mining algorithms for predicting the severity of a reported bug.
In 2011 15th European Conference on Software Maintenance and Reengineering.
IEEE, IEEE, USA, 249–258.

[21] Alina Lazar, Sarah Ritchey, and Bonita Sharif. 2014. Generating Duplicate Bug
Datasets. In Proceedings of the 11th Working Conference on Mining Software Repos-
itories (MSR 2014). Association for Computing Machinery, New York, NY, USA,
392–395. https://doi.org/10.1145/2597073.2597128

[22] Lisha Li, Zhilei Ren, Xiaochen Li, Weiqin Zou, and He Jiang. 2018. How Are
Issue Units Linked? Empirical Study on the Linking Behavior in GitHub. In 2018
25th Asia-Pacific Software Engineering Conference (APSEC). IEEE, USA, 386–395.
https://doi.org/10.1109/APSEC.2018.00053

[23] Garm Lucassen, Fabiano Dalpiaz, Jan Martijn E.M. van der Werf, Sjaak Brinkkem-
per, and Didar Zowghi. 2017. Behavior-Driven Requirements Traceability via
Automated Acceptance Tests. In 2017 IEEE 25th International Requirements Engi-
neering Conference Workshops (REW). IEEE, USA, 431–434. https://doi.org/10.
1109/REW.2017.84

[24] Robert J. Walker Martin P. Robillard, Walid Maalej and Thomas Zimmermann
(Eds.). 2014. . Springer, Berlin Heidelberg. https://doi.org/10.1007/978-3-642-
45135-5

[25] Thorsten Merten, Matúš Falis, Paul Hübner, Thomas Quirchmayr, Simone Bürsner,
and Barbara Paech. 2016. Software Feature Request Detection in Issue Tracking
Systems. In 2016 IEEE 24th International Requirements Engineering Conference
(RE). IEEE, USA, 166–175. https://doi.org/10.1109/RE.2016.8

[26] Thorsten Merten, Daniel Krämer, Bastian Mager, Paul Schell, Simone Bürsner,
and Barbara Paech. 2016. Do information retrieval algorithms for automated
traceability perform effectively on issue tracking system data?. In International
Working Conference on Requirements Engineering: Foundation for Software Quality.
Springer International Publishing, Cham, 45–62.

[27] Lloyd Montgomery, Clara Lüders, and Walid Maalej. 2022. An Alternative Issue
Tracking Dataset of Public Jira Repositories. In 2022 IEEE/ACM 18th International
Conference on Mining Software Repositories (MSR). IEEE, USA.

[28] M. E. J. Newman. 2002. Assortative Mixing in Networks. Phys. Rev. Lett. 89 (Oct

2002), 208701. Issue 20. https://doi.org/10.1103/PhysRevLett.89.208701

[29] Alexander Nicholson, Deeksha M. Arya, and Jin L.C. Guo. 2020. Traceability
Network Analysis: A Case Study of Links in Issue Tracking Systems. In 2020
IEEE Seventh International Workshop on Artificial Intelligence for Requirements
Engineering (AIRE). IEEE, USA, 39–47. https://doi.org/10.1109/AIRE51212.2020.
00013

[30] Patrick Rempel and Parick Mäder. 2017. Preventing Defects: The Impact of
Requirements Traceability Completeness on Software Quality. IEEE Transactions
on Software Engineering 43, 8 (2017), 777–797. https://doi.org/10.1109/TSE.2016.
2622264

[31] Thiago Marques Rocha and André Luiz Da Costa Carvalho. 2021. SiameseQAT:
A Semantic Context-Based Duplicate Bug Report Detection Using Replicated
Cluster Information. IEEE Access 9 (2021), 44610–44630. https://doi.org/10.1109/
ACCESS.2021.3066283

[32] Thomas Schank and Dorothea Wagner. 2005. Finding, Counting and Listing
All Triangles in Large Graphs, an Experimental Study. In Experimental and Effi-
cient Algorithms, Sotiris E. Nikoletseas (Ed.). Springer Berlin Heidelberg, Berlin,
Heidelberg, 606–609.

[33] Marcus Seiler and Barbara Paech. 2017. Using tags to support feature manage-
ment across issue tracking systems and version control systems. In International
Working Conference on Requirements Engineering: Foundation for Software Quality.
Springer International Publishing, Cham, 174–180.

[34] Pannavat Terdchanakul, Hideaki Hata, Passakorn Phannachitta, and Kenichi
Matsumoto. 2017. Bug or Not? Bug Report Classification Using N-Gram IDF.
In 2017 IEEE International Conference on Software Maintenance and Evolution
(ICSME). IEEE, USA, 534–538. https://doi.org/10.1109/ICSME.2017.14

[35] C Albert Thompson, Gail C Murphy, Marc Palyart, and Marko Gašparic. 2016.
How software developers use work breakdown relationships in issue repositories.
In 2016 IEEE/ACM 13th Working Conference on Mining Software Repositories (MSR).
IEEE, IEEE, USA, 281–285.

[36] Juha Tiihonen, Mikko Raatikainen, Lalli Myllyaho, Clara Marie Lüders, Tomi
Männistö, et al. 2019. Coping with Inconsistent Models of Requirements. In

Beyond Duplicates: Towards Understanding and Predicting Link Types in Issue Tracking Systems

MSR ’22, May 23–24, 2022, Pittsburgh, PA, USA

Proceedings of the 21st Configuration Workshop Hamburg, Germany, September 19th
to 20th, 2019. Rheinisch-Westfaelische Technische Hochschule Aachen, Aachen,
Germany, 1–8.

[37] Xiaoyin Wang, Lu Zhang, Tao Xie, John Anvik, and Jiasu Sun. 2008. An Approach
to Detecting Duplicate Bug Reports Using Natural Language and Execution Infor-
mation. In Proceedings of the 30th International Conference on Software Engineering
(ICSE ’08). Association for Computing Machinery, New York, NY, USA, 461–470.
https://doi.org/10.1145/1368088.1368151

[38] Jifeng Xuan, He Jiang, Zhilei Ren, and Weiqin Zou. 2012. Developer prioritization
in bug repositories. In 2012 34th International Conference on Software Engineering
(ICSE). IEEE, USA, 25–35. https://doi.org/10.1109/ICSE.2012.6227209

[39] Tao Zhang, He Jiang, Xiapu Luo, and Alvin T.S. Chan. 2016. A Literature Review
of Research in Bug Resolution: Tasks, Challenges and Future Directions. Comput.

J. 59, 5 (2016), 741–773. https://doi.org/10.1093/comjnl/bxv114

[40] Ye Zhang and Byron Wallace. 2017. A Sensitivity Analysis of (and Practitioners’
Guide to) Convolutional Neural Networks for Sentence Classification. In Proceed-
ings of the Eighth International Joint Conference on Natural Language Processing
(Volume 1: Long Papers). Asian Federation of Natural Language Processing, Taipei,
Taiwan, 253–263. https://aclanthology.org/I17-1026

[41] Yu Zhou, Yanxiang Tong, Ruihang Gu, and Harald Gall. 2016. Combining text min-
ing and data mining for bug report classification. Journal of Software: Evolution
and Process 28, 3 (2016), 150–176.

[42] Thomas Zimmermann, Rahul Premraj, Nicolas Bettenburg, Sascha Just, Adrian
Schröter, and Cathrin Weiss. 2010. What Makes a Good Bug Report? IEEE
Transactions on Software Engineering 36, 5 (2010), 618–643. https://doi.org/10.
1109/TSE.2010.63

