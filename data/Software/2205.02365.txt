Evaluation of the relative performance of the subﬂattenings

method for phylogenetic inference

Joshua Stevenson, Barbara Holland, Michael Charleston, Jeremy Sumner

May 6, 2022

Abstract

The algebraic properties of ﬂattenings and subﬂattenings provide direct methods for
identifying edges in the true phylogeny—and by extension the complete tree—using pat-
tern counts from a sequence alignment. The relatively small number of possible internal
edges among a set of taxa (compared to the number of binary trees) makes these methods
attractive, however more could be done to evaluate their eﬀectiveness for inferring phyloge-
netic trees. This is the case particularly for subﬂattenings, and our work makes progress in
this area. We introduce software for constructing and evaluating subﬂattenings for splits,
utilising a number of methods to make computing subﬂattenings more tractable. We then
present the results of simulations we have performed in order to compare the eﬀectiveness of
subﬂattenings to that of ﬂattenings in terms of split score distributions, and susceptibility
to possible biases. We ﬁnd that subﬂattenings perform similarly to ﬂattenings in terms of
the distribution of split scores on the trees we examined, but may be less aﬀected by bias
arising from both split size/balance and long branch attraction. These insights are useful for
developing eﬀective algorithms to utilise these tools for the purpose of inferring phylogenetic
trees.

Contents

1 Introduction
2 Background
3 Code and computational considerations

3.1 Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2
Sparsity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 The Singular Value Decomposition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Subﬂattening transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4
3.5 Number of splits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4 Analysis

2
4
7

7
7
8
8
9
10

4.1 Distribution of split scores on a 6-taxon tree . . . . . . . . . . . . . . . . . . . . . . . . . 10
Sliding window analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4.2
4.3
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
Split balance bias analysis
4.4 LBA bias analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
12

5 Results

2
2
0
2

y
a
M
4

]
E
P
.
o
i
b
-
q
[

1
v
5
6
3
2
0
.
5
0
2
2
:
v
i
X
r
a

Sliding window analysis
Split balance bias analysis

5.1 Distribution of split scores on a 6-taxon tree . . . . . . . . . . . . . . . . . . . . . . . . . 12
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
5.2
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
5.3
5.4 LBA bias analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
18
19

6 Discussion
References

1

 
 
 
 
 
 
1

Introduction

The accurate inference of species trees from aligned sequence data is a key task that underpins

much of evolutionary biology. However, it is a very challenging statistical problem. Much of

this diﬃculty is because sequence evolution is a highly heterogeneous process. The substitution

process can vary in diﬀerent parts of the evolutionary tree, and also in diﬀerent parts of the

genome. In addition to this, the local gene tree along which sequences evolve may vary across

the alignment.

There have been two broad approaches in trying to cope with this complexity. The ﬁrst

approach is to model it; likelihood-based and Bayesian approaches have become increasingly

parameter rich as they use partitions and/or mixtures to account for heterogeneity. The second

approach has been to develop methods that are robust to this kind of complexity and avoid

having to estimate what are essentially large numbers of nuisance parameters. For example, the
logDet method (see Lockhart et al. [22]) allows for consistent inference under the General Markov
Model (GMM) without having to ﬁt any parameters. Methods based on phylogenetic invariants
also fall into this class of approaches. While invariant methods were not initially competitive

compared to maximum likelihood [19], there has been a renaissance in their use over the last

decade or so. Explicit use of algebraic methods in phylogenetics started in the late 1980s with
both the Hadamard conjugation ideas of Hendy and Penny [16] and the discovery of phylogenetic
invariants by Cavender, Felsenstein and Lake [5, 21]. These initial ideas exploited the underlying
symmetries inherent in both the relevant molecular substitution models, e.g, the Kimura 3ST

model [20], and the phylogenetic tree itself (leaf permutation symmetries). Importantly, the

theory of phylogenetic invariants eventually led to the comprehensive application of methods

from algebraic geometry, beginning with the work of Allman and Rhodes [1, 2]. A breakthrough

paper by Allman and Rhodes in 2008 [3] described a new class of invariants based on the idea
of a (tensor) ﬂattening and the rank properties of matrices of site pattern probabilities.

The ﬂattening construction is quite natural to phylogenetics as it corresponds to identifying
evolutionary splits (partitions of the set of taxa into two parts, akin to an edge in a tree) by

reinterpreting a multiple sequence alignment to consist of two sequences of expanded characters

B
(one sequence for each side of the split). For a split A
|
|
4|B| matrix with entry
sequences), the sequence alignment can be summarised into a 4|A|
I, J being the count of alignment locations with subpattern I on the left side of the split and

B (on a DNA alignment of N =

A
|

+

×

|

|

subpattern J on the right. The biological intuition: if one takes a split corresponding to an edge

in the true tree, the probability mass contained in the ﬂattening matrix will be concentrated

on certain oﬀ-diagonal entries, with the converse holding for splits not corresponding to edges

in the tree. This information can then be detected by measuring the (approximate) algebraic

rank of the ﬂattening matrix, which, in particular, is typically done using the singular value de-

composition (Section 2). Thus, the ﬂattening matrices provide a very direct means of detecting

phylogenetic signal and identifying edges in the tree.

Subsequent papers by Chifman and Kubatko [8] and Gaither and Kubatko [13] observed the

ﬂattening rank properties in practice, using sequence data generated under the multi-species

coalescent and with a distribution of rates across sites.

Using a diﬀerent perspective and starting point, the work by Sumner and Jarvis [30, 31]

2

on Markov invariants has also taken an algebraic approach to phylogenetics but has instead
concentrated on the time evolution of the underlying Markov process. In particular, Sumner
and Jarvis [30] detail a particular set of Markov invariants, the squangles, which can be used
for quartet reconstruction. We use squangles as a point of comparison alongside ﬂattening and

subﬂattening methods in Section 4 following the process suggested by Holland et al. [18]. We

direct the reader to the two aforementioned papers for background on squangles and how they

may be used to evaluate splits.

The general philosophy followed here is that, under standard phylogenetic models, evolu-

tionary divergence events are modelled as discrete instantaneous branching of lineages, whereas

the subsequent evolution occurs as a continuous time random process of nucleotide substitu-

tions. Thus, if one views the primary diﬃculty of phylogenetic inference to be the correct

identiﬁcation of branching events (i.e., the inference of the phylogenetic tree), the random nu-

cleotide substitutions that occur on the pendant edges of the tree contribute nothing and make

the inference more diﬃcult. Indeed, the above stated properties of the ﬂattening matrix are

contingent on a particular edge being identiﬁable with evolutionary divergence events occurring

some ﬁnite time prior. Thus it is valuable to understand the theoretical behaviour of the ﬂat-

tening matrix as time passes under the given Markov model of sequence evolution. The relevant

matrix transformation rule is well understood (and was presented in Allman Rhodes [3]), and

is crucial to the the theoretical derivation of the rules for the rank of the ﬂattening matrices.

Exploring these ideas further, Sumner [29] showed analogous transformation rules are obtain-

able from ‘subﬂattenings’, which are particular submatrices of the ﬂattening matrices. These

{

}

submatrices have signiﬁcantly smaller dimensions than the ﬂattenings, reducing the dimension
from k|A|
state space (for example k = 4 for the state space of DNA nucleotides κ :=

B, where k is the size of the
|

k|B| to (
A
|

1) + 1) for a split A

A, C, G, T

). Thus

1) + 1)

(k
|

(k
|

(
|

×

−

×

−

B

the subﬂattening has the advantage of having dimensions which are linear in the size of each

split, and Sumner showed that the rank conditions on the subﬂattenings matrices can also be

used to (theoretically) identify splits corresponding to edges in the true phylogenetic tree [29].

The purpose of the present work is to show the relative performance of these methods—in

terms of their ability to identify edges in the true tree—under a simple simulation framework. In

particular, we focus on simulating under the Jukes Cantor model with varying sequence length

and branch lengths. Throughout, ‘branch length’ refers to the expected number of substitutions

per site. We also do not consider complications arising under the coalescent, in order to keep

the presentation and comparisons as clean and clear as possible. First, we provide the relevant

background deﬁnitions and theorems, including the ﬂattening and subﬂattening rank theorems.

In Section 3, we identify some important considerations in the implementation of ﬂattenings

and subﬂattenings, and describe the software we have developed to construct such matrices and

identify true splits. In Section 4, we detail the simulations we performed in order to evaluate the

performance of subﬂattening matrices in comparison to ﬂattenings and squangles. The results

of the simulations are discussed in Section 5, and we conclude with a discussion in Section 6

including suggestions for future work.

3

2 Background

}

and B =

B (or equivalently B

For a given set of taxa X, a split is deﬁned as partition of X into two sets A and B and is
A). We may also omit set notation. For example, if X =
written A
|
|
1, 3, 4
, A =
}

1, 2, 3, 4
{
bipartitions, we can also omit one side of the split when X is clear. In this case, we might write
2 as 134 or simply 2. We deﬁne the size of a split to be the smallest subset (for example,
|
2 is 1) and note that the size of a split can be thought of as its balance; this is
|
because for a ﬁxed number of taxa, the larger the size of a split, the more balanced the taxa

B can be written 134
|

2. Since splits are

, then the split A

the size of 134

2
}

134

{

{

|

are across the two subsets. Splits are a natural idea in phylogenetics, because each edge in a

phylogenetic tree can be identiﬁed with a split. To see this, notice that removing an edge from

a tree creates two smaller trees and hence a partition of the taxa into two sets; the induced

partition can be represented as a split. Of course, not all splits will represent edges in a given

tree. For example, if a tree displays two taxa as a cherry, then any split with size more than

1 which separates these two taxa will not correspond to any edge in the tree. Splits with size
equal to 1 will always correspond to leaf edges, and for this reason they are referred to as trivial
splits. Given a tree, we say that splits which correspond to edges are displayed by the tree, and
refer to them as true splits. For example, trivial splits are always true splits. Splits which are
not displayed by the tree are referred to as false splits. Splits are compatible if there exists some
13 are not compatible
tree which can display both splits. For example, the splits 01
|

on any tree. Due to the correspondence between true splits and edges, the complete set of true

23 and 02
|

splits uniquely deﬁnes the tree [27, Proposition 2.4].

Fundamentally, inference of phylogenetic trees amounts to the identiﬁcation of true splits.

Importantly, there are far fewer splits on n taxa than there are trees on n taxa. The number
of splits is given by 2(n−1)
5)!! =
2(k−2)(k−2)! (which grows like 2kk!). It is also worth noting that a tree without branch lengths (or
with branch lengths which are all equal) may have a number of splits which are symmetrically

1 whereas the number of unrooted trees is given by (2n

(2(k−2))!

−

−

equivalent (that is, they are invariant under an action of the automorphism group of the tree

under vertex permutations). For example, for a balanced four-taxon unweighted tree with leaf

labels

0, 1, 2, 3
}

{

and cherries

0, 1

and

{

}

2, 3
{

, we can say that the (false) splits 02
|

}

13 and 03

12

|

are symmetrically equivalent. A true split on a tree induces two sub-trees which are disjoint

(that is, they share no edges in the original tree). A false split, however, will always give rise to

two sub-trees which share one or more internal edges in the tree. The number of shared edges

between the two sub-trees may be taken as a measure of ‘how false’ a given false split is on a

tree, and is a statistic which explains some of the results displayed in the next section.

In practice, we can obtain a measure of how likely it is (in a colloquial sense) for a split to

be true, using the rank properties of ﬂattening and subﬂattening matrices. The ﬂattening rank

properties are presented in the following theorem.

, the ﬂattening matrix
Theorem 2.1. Given a phylogenetic tree T and state space κ =
B is displayed
FlatA|B(P ) computed from a split A
|
by T , and has rank(FlatA|B(P )) = kpA|B otherwise, where pA|B is the parsimony score of the
split A

B has rank(FlatA|B(P )) = k if the split A
|

1, ..., k
{

}

B on the tree T .
|

4

Proof. A proof is provided by Snyman et al. [26], strengthening a previous result by Eriksson
(cid:4)
[10] and Fern´andez-S´anchez and Casanellas [12].

We will discuss shortly how the rank of these matrices can be evaluated in practice, but ﬁrst

we note that these matrices are exceedingly large. The subﬂattening is a similar construction

which is much smaller in dimension [29]. To understand the theoretical origin of subﬂattenings,

we give an illustrative explanation using the simplest possible scenario: binary sequence data

(k = 2) and a split A

=

B

= 2. The general case is presented in [29].

B with
|

A
|

|

|

|

For the binary states, one can express a general 2

2 Markov matrix as

×

M =

(cid:32)
1

a

−
b

(cid:33)

.

b

a

−

1

Following the well-known Hadamard conjugation [17], we consider what happens to this matrix

under conjugation by a Hadamard matrix H:

HM H −1 =

(cid:32)
1

1

(cid:33) (cid:32)
1

1

1
−

a

−
b

a

−

1

1
2

(cid:33) (cid:32) 1
2
1
2 −

b

(cid:33)

=

1
2

(cid:32)

1

0 1

b

−

−
a

a

−

(cid:33)

(cid:32)

1 v

(cid:33)

b

≡

0 z

,

say. Note that the constraint 0 < a, b < 1 is converted to

two matrices of the above form gives

1 < v, z < 1 and Now, multiplying

−

(cid:32)

1 v

0 z

(cid:33) (cid:32)

1 v(cid:48)
0 z(cid:48)

(cid:33)

=

or, directly in terms of parameters, we have:

(cid:32)

1 vz(cid:48) + v(cid:48)
0

zz(cid:48)

(cid:33)

,

(v, z)

∗

(v(cid:48), z(cid:48)) := (vz(cid:48) + v(cid:48), zz(cid:48)).

This transformation rule tells us algebraically exactly what is happening to the substitution

parameters on a single branch of a phylogenetic tree as time passes.

More generally, if we consider a phylogenetic tree and concentrate on the two lineages and
substitutions between the the 22 = 4 pairs of binary states as time passes, algebraically the
independence of substitutions on the two lineages can be incorporated by taking the tensor
product of two Markov matrices M1
M2. Working with the Hadamard conjugated matrices,
this gives us (via the rules for Kronecker products):

⊗

M1

M2

⊗

(cid:55)→

(HM1H −1)

⊗

(HM2H −1) =

(cid:32)

1 v1
0 z1

(cid:33)

(cid:32)

⊗

(cid:33)

=

1 v2
0 z2



1 v2 v1 v1v2

v1z2
0
0 z2



z1v2
z1
0
0

z1z2
0
0

0









.

It is then a tedious exercise (left to the reader) to verify that multiplying two such 4

4 matrices

×

5

×

×

×

produces the following transformation rule stated in terms of the substitution parameters:

(v1, z1)

(v2, z2)

(v(cid:48)
(v(cid:48)

1, z(cid:48)
1)
2, z(cid:48)
2)

∗

∗

(cid:55)→

(cid:55)→

(v1z(cid:48)
(v2z(cid:48)

1 + v(cid:48)
2 + v(cid:48)

1, z1z(cid:48)
2, z2z(cid:48)

2).

1), and

The key idea presented in [29] was that the same information is contained in upper-left 3

submatrix






1 v2 v1
0
0 z2
z1
0
0




 ,

3

×

as, again, the reader can verify by multiplying two matrices of this type. The subﬂattening

itself is then obtained by (i) considering a four taxon alignment of binary pattern counts, (ii)

forming the corresponding 2

2

2

2 array of binary state pattern counts, (iii) implementing

the Hadamard conjugation on this array, (iv) choosing a split and ﬂattening the array of pattern

counts into the corresponding 4

×

4 matrix, and (v) taking upper-left 3

3 submatrix.

×

Theorem 2.2. Let T be a tree with site pattern probability distribution P . Let A
A subﬂattening matrix SubﬂatA|B(P ) has rank k if A
otherwise, where r is the parsimony score of the split A

B is displayed by T , and rank r(k
|

B be a split.
|
1)+1

−

B.
|

Proof. See Sumner [29].

(cid:4)

Generalising to an arbitrary number of lineages leads directly to the subﬂattening matrices,

but the above gives the basic underlying idea. Note that for the remainder of this paper, we will

assume that k = 4, referring to the size of our state-space of DNA nucleotides κ :=

}
As stated above, the dimensions of subﬂattenings is greatly reduced in comparison to the

A, C, G, T
{

.

ﬂattenings (exponential to linear). However, this comes at the price of the Hadamard trans-

formation which means that the entries of the subﬂattenings are not directly obtainable from

counting patterns in the sequence alignment. That is, entries do not correspond to single site-

patterns, as they do for ﬂattenings. Despite this, the subﬂattenings can still be computed

eﬃciently, as described in Section 3.

After ﬂattenings and subﬂattenings have been constructed using observed pattern frequen-

cies from a sequence alignment, extracting information from them involves evaluating how ‘close’

the given matrix is to having rank k. Singular value decomposition has often been suggested in

the literature as a way to evaluate this [4, 10], due to the connection between singular values

and low-rank matrix approximation [9]. Put brieﬂy, the sum of the singular values—excluding

the m largest—of a matrix F , is the distance between F and the closest rank-m matrix to F

under the Frobenius norm. We are interested in the case where m is set to the number of states,

k. Allman et al. [4] deﬁne the ‘split score’:

Deﬁnition 2.3. For ﬂattening (or subﬂattening) matrix FA|B arising from a split A
sequence alignment with k possible states, deﬁne the split score,

B and a
|

SplitScore(cid:0)FA|B

(cid:1) =

(cid:32)

1

−

(cid:80)k
i=1 σ2
i
2
FA|B(cid:107)

(cid:107)

(cid:33) 1
2

,

6

where σ1
≥ · · · ≥
≥
Frobenius norm of FA|B.

σ2

σmin(m,n) ≥

0 are the singular values of FA|B, and

FA|B(cid:107)

(cid:107)

is the
(cid:78)

The split score is a normalised measure of the distance to the nearest rank-k matrix and

requires only the largest k singular values to be computed. This saves time on computation.

The code we provide to evaluate splits using ﬂattenings and subﬂattenings utilises this deﬁnition

of the split score.

3 Code and computational considerations

3.1 Code

Two separate programs were developed for constructing subﬂattenings, computing split scores

and performing the simulations and analysis detailed in Section 4. The ﬁrst implementation,
Flatbush was written in C++ by Charleston [6]. Flatbush is a command-line program that
accepts either FASTA or NEXUS format sequence alignment data, currently limited to the

nucleotide alphabet of characters, κ =

If the NEXUS format is used then a

A, G, C, T
{

.
}

“FLATBUSH” block may be included, which may include instead of an alignment a set of

splits with weights (which would otherwise be calculated from an alignment). Splits may be

input either as taxon names or in a compact binary encoding, and can be entered explicitly

or by opting to do all possible non-trivial splits, subject to the number of taxa not being too
large (in this case 16, however note that in principle Flatbush can accept any number of taxa
Input arguments may also include an input tree in simple Newick
and sequences as input).

format, or a set of splits of interest. Alternatively, a tree or set of splits may be provided as

command-line arguments. Please see the supplementary material for additional information.

A second implementation, SplitP is a python package developed by Stevenson [28]. As
SplitP was written independently of Flatbush, we were able to verify our calculations by
comparing outputs of both programs with the same inputs. While SplitP is generally slower
than the Flatbush implementation, it still includes the optimisations detailed in the remainder
of this section, and can also compute and evaluate scores for ﬂattening matrices and squangles.
For this reason, we use SplitP for the analyses in Section 4. As input, SplitP accepts FASTA
formatted sequence alignments or a table of site-pattern counts. Alternatively, SplitP also
accepts trees with up to 36 taxa in the Newick format. SplitP can compute ﬂattenings and
subﬂattenings using exact site-pattern probabilities, or can generate sequence alignments of a

given length, making it useful for simulations detailed in Section 4. Any sub-model of the general

Markov model is supported, as the user can reassign any Markov matrix to each edge in the tree.
SplitP is available on PyPI as well as on GitHub (at https://github.com/js51/SplitP) as
open source software, as is Flatbush (at https://github.com/mcharleston/Flatbush) and
we encourage code contributions.

3.2 Sparsity

Na¨ıve approaches to problems involving very large matrices quickly lead to memory problems.
For example, with just 8 taxa, the number of entries in a ﬂattening matrix is 416

4.2 billion.

≈

7

Assuming the entries are 4 bytes each, this leads to over 17 gigabytes of RAM required just

to store the ﬂattening in memory. Adding just one more taxon increases this number to more

than 4.3 terabytes. Fortunately, ﬂattening matrices are sparse. That is, the number of non-

zero entries is typically in the order of the number of rows or columns. There exist a number

of computational techniques for dealing with large sparse matrices, including techniques for

computing the singular value decomposition, for example. These techniques are implemented

in most major scientiﬁc computing packages, for example SciPy [32] for Python or Eigen [15]

for C++.

Subﬂattenings on the other hand are never sparse, but have dimensions which are quadratic
in the number of taxa rather than exponential, and can therefore oﬀer an even greater beneﬁt

than sparse matrix methods in certain situations. In a ‘worst case’ scenario, in which each site

pattern is equally likely to be observed, the expected number of non-zero entries in a ﬂattening

(L

1)LL1−L, where L is the sequence length.

In comparison, the expected
matrix is L
number of non-zero entries in the subﬂattening is (3t + 1)2, where t is the number of taxa.
We can therefore determine under this worst-case scenario, the sequence length required to

−

−

beneﬁt (in terms of memory use) from subﬂattenings for a given number of taxa. For example,

given a 6-taxon tree, a sequence length of around 570 is required, whereas for a 15-taxon tree, a

sequence length of over 3000 is required in order to derive beneﬁt from subﬂattenings. Of course,

site-pattern probability distributions are never uniform, and so in practice these thresholds are

much higher.

3.3 The Singular Value Decomposition

Due to the ubiquity of the singular value decomposition in numerical methods, packages for

computing singular values are heavily optimised. This is true even for the sparse matrix SVD
packages, which Allman et al. [4] employ in order to compute split scores for ﬂattenings. SplitP
utilises SciPy’s sparse matrix methods to compute singular values for ﬂattenings, and standard
methods for subﬂattenings. Flatbush utilises the C++ package Eigen [15]. Importantly, the
deﬁnition of the split score means that only the k largest singular values are needed, leading to

signiﬁcant performance improvements for both methods.

3.4 Subﬂattening transformation

The bulk of the computation time for constructing the subﬂattenings from site pattern counts

comes from the application of the following transformation of the (theoretical or observed)

site-pattern distribution P on the set of taxa X, with

= t.

X

|

|

P

H
(cid:124)

⊗

→

H

. . .

H
(cid:125)

P.
·

⊗

⊗
(cid:123)(cid:122)
t times

This transformation is equivalent to the one described in Section 2. Speciﬁcally, the entries of

the subﬂattening all come as sums of site-pattern probabilities,

(cid:88)

j1,j2...,jt∈κ

Hi1j1Hi2j2 . . . Hitjtpj1j2...jt,

8

as presented by Sumner [29]. Fortunately, the products of H matrix entries in the above

expression can be stored in a dictionary and re-used when computing subﬂattenings for other

splits, and even for other sequence alignments. This technique, known as ‘memoisation’, leads

to a signiﬁcant speed improvement, and allows us to perform the simulations we describe in

Section 4.

3.5 Number of splits

As we have discussed, sparse matrix methods and the reduced size of subﬂattenings help to

overcome memory constraints for computing split scores.

In terms of time constraints, the

sequence length is of little concern, as the time taken to construct a subﬂattening matrix,

for example, increases only linearly as the sequence length increases. The real computational

challenge which limits the usefulness of rank-based methods as a tool for inference is the number
of splits, given by 2(n−1)
the ﬂattening or subﬂattening split scores is to compute a split score for every possible split,

1, where n is the number of taxa. A na¨ıve way to infer a tree using

−

order them from smallest to largest, and select compatible splits from the top of the list until

the tree is complete. There are of course other methods to obtain a tree by constructing fewer

matrices and computing fewer singular values. An example of one such algorithm is presented

1)2

3

−

−

by Eriksson [10]. Eriksson’s SVD algorithm requires the computation of only (n

split scores to produce an unrooted tree, and builds the tree from the bottom-up, beginning

by selecting cherries. In practice, Eriksson’s SVD algorithm performs poorly [4]. A possible

explanation is that the algorithm compares split scores for splits of diﬀerent sizes, which are

known to be incomparable due to the bias of the ﬂattening split score towards less balanced

splits [4]. While to our knowledge, no other methods for inferring trees based on on ﬂattening

rank for species tree splits have been proposed, is it easy to see how other algorithms can be

adapted to use the split scores, for example quartet methods [14, 23, 24, 25, 34]. Such methods
may also avoid the split size bias. One example of this is the software is SVDQuartets, which
was developed by Chifman and Kubatko [7, 8] and used to reconstruct trees based on the split

scores for samples of possible quartets under the coalescent model.

Figure 1: The 6 taxon tree used to simulate site-pattern probabilities and compute
split scores for Figure 5. All non-zero branch lengths are 0.1

9

01 2 3 4 5 0 1 2 4 5 3Iπ4 Analysis

4.1 Distribution of split scores on a 6-taxon tree

We simulated site-pattern frequencies on the six-taxon tree shown in Figure 1—the balanced,

unrooted 6-taxon tree, under the Jukes Cantor model. For the ﬁrst simulation, we set all

branch lengths equal to 0.1. We ﬁrst computed exact site-pattern probabilities and then simu-

lated 1000 sequence alignments by drawing from the appropriate multinomial distribution. Split

scores were then computed from these empirical site pattern probability distributions. Since

all the branch lengths are the same, we can avoid computing split-scores unnecessarily by only

computing scores for 9 inequivalent splits. That is, the chosen splits were representatives from

the 9 orbits of the action of the tree automorphism group on the set of all splits. The auto-

morphism group consists of all permutations of the leaf nodes which leave the tree unchanged.

For example, on a quartet tree with cherries (1,2) and (3,4), the automorphism group is the
4, consisting of permutations which swap nodes within each cherry, (12) and
(34), the permutations which swaps the two cherries (13)(24) and (14)(23), as well as products

dihedral group

D

of these. The interested reader can verify that the balanced 6-taxon tree shown in Figure 1 also

has automorphism group

4, and the orbits of the group action are as follows:

D

012

,
345
}
|
2345, 0123
01
|
014

,

134, 034

45
|
}
234, 045
235, 015
123, 023
|
|
|
135, 025
125, 035
|
|
|
12, 0125
1345, 0345
|
|
13, 0134
1245, 0245
|
|
1234, 0235
1235, 05
|
|

145
|
124
|
34, 0124

}
35
|
}
24
}
|
15
}
|

14, 0234

25, 0135

}

,

,

,

,

,

{

{

{

345] =
[012
|
2345] =

[01
|
235] =
[014
|
135] =
[024
|
1345] =

[02
|
[03
|
[04
|
[0145

1245] =

1235] =

23] =
|
245] =
[013
|

024
{
02
{
|
03
|
{
04
{
|
0145
|
{
245
013
|
{

,
23
}
.
}

As an example, the two splits 014
|

234 are in the same class, since we can obtain
235 and 015
|
one from the other by swapping the labels of the nodes 4 and 5, and this swap leaves the tree

unchanged because these nodes form a cherry and have equal branch lengths.

Histograms were generated from split scores computed from simulated sequence lengths of

1,000bp and 10,000bp for both ﬂattenings and subﬂattenings. In each case, 1,000 trials were

conducted. That is, we performed 1,000 draws from the multinomial distribution in each case,

and for each draw computed split scores for each of the splits shown. The entire simulation

was then repeated with the same tree, but with every edge length changed from 0.1 to 0.8,

emulating a tree which is much more diﬃcult to infer. Results are displayed and discussed in

Section 5.1.

10

Figure 2: The 20-taxon tree used for split balance analysis described in Section 4.3
and by Allman et al. in their 2017 paper [4].

4.2 Sliding window analysis

The next analysis we conducted was a repeat of the sliding window analysis described in [4]

but for subﬂattenings. We also repeated the analysis using a third method for quartet recon-

struction, the squangles (see work by Sumner and Jarvis and Holland et al. [18] for background

on this particular method). The sliding window analysis computes the best split (out of three

possible) according to ﬂattenings, subﬂattenings and squangles for each window in a four-taxon

mosquito data set (Wen et al. [33]). Windows are 10,000bp long and at each step slide forwards

1,000bp in the alignment. The complete alignment is over 37 million bp, giving approximately

3,700 windows in total, as described by Allman et al.. This allows us to see how similar results

were between the three methods across the length of the genome.

4.3 Split balance bias analysis

In their 2017 paper, Allman et al. [4] discuss the bias of ﬂattenings towards less ‘balanced’ splits.

Here more ‘balanced’ splits are splits A

B where

A

is closer to

|

|

|

B

. For brevity, we refer to
|

|

splits of size m as m-splits. According to Allman et al. [4], this bias is due to the dimension of

the space of all matrices of a given shape compared to the subset of these matrices with rank k.

Due to this bias, Allman et al. [4] recommends to the reader that splits of diﬀerent balance not

be compared by means of the split score. We hypothesised that due to their reduced dimensions,

subﬂattenings may exhibit this bias to a lesser extent. To evaluate this, we evaluated a random

selection of 190 m-split scores for each size m on the 20 taxon tree shown in Figure 2. This is

the same tree used by Allman et al. [4] to show the existence of split-balance bias in ﬂattening

matrices. If the subﬂattenings are indeed less impacted by split-balance bias, we would expect

the average split score to increase less dramatically for increasing split balance, when compared

to split scores for ﬂattenings.

11

Figure 3: Quartet trees used for the simulations performed in Section 4.4. Branch
lengths are not to scale.

4.4 LBA bias analysis

The next set of simulations we performed were on quartet trees with short and long branches

(see Figure 3). The short and long branch lengths chosen were 0.05 and 0.5 respectively. The

simulation was then repeated with short and long branch lengths of 0.1 and 1.0 (maintaining the

ratio of short to long branch length). In both cases, the internal branch was assigned the shorter

branch length. We computed site pattern probabilities on each of these trees and drew from

the corresponding multinomial distributions, simulating sequence lengths in intervals of 100bp

from 100bp to 1,000bp. In each case, we perform 100 iterations and determine the number of

times ﬂattenings, subﬂattenings and squangles choose the true split. These simulations were
designed to give an indication of how susceptible each method is to long branch attraction: an
important bias aﬀecting some tree construction methods, ﬁrst described by Felsenstein in 1978
[11]. We also performed an additional simulation on a star tree—that is, a quartet tree with
an internal branch length of zero—with two long branches and two short branches. A method

which is completely unbiased to long branch attraction would theoretically choose each of the

three possible splits a third of the time. A biased method would choose the split which pairs

the two long edges more or less often than the other two splits. Finally, we performed a similar

simulation, but instead ﬁxed the sequence length at 1000bp and allowed the long branch lengths

to vary from 0.1 to 1.0 substitutions per site with the two other branch lengths ﬁxed at 0.1.

Results of these simulations are provided in Section 5.4.

5 Results

5.1 Distribution of split scores on a 6-taxon tree

Results of our initial simulations are shown in Figure 5. We saw that split score distributions

appeared to be similar between ﬂattenings and subﬂattenings, and were aﬀected similarly by

increasing the sequence length. Split scores appeared to fall into four distinct groups, which

we know are not a result of tree symmetries due to the chosen splits all being symmetrically
distinct. Split scores appeared to be grouped by the number of shared edges for the split on the
tree. That is, the number of edges in the tree that are shared between the two subtrees induced

by the two subsets of taxa. For example, the split 014
|

235 on the unrooted 6-taxon caterpillar

12

tree induces the following two subtrees (represented by the solid and dashed lines), which share

two edges:

235.
Figure 4: Shared edges example for the split 014
|

In our simulations, we commonly saw that the number of shared edges between subtrees

induced by a split appeared to explain the ordering and grouping of split scores. In fact, despite

the connection between the ﬂattening/subﬂattening rank and the parsimony score for a split, the

number of shared edges is a much better predictor of the split score than the parsimony score.

As a simple test, we took the tree in Figure 1 and drew each edge length uniformly between

0.1 and 1 (Jukes-Cantor), and computed exact site-pattern probabilities and split scores for

subﬂattenings corresponding to each split. Repeating this 20 times and compiling the scores,

we ﬁtted a linear model to predict split score based on shared edges, parsimony score and split
balance. The best model (according to adjusted R2) used only the number of shared edges, and
explained approximately 61% of the variability in the split score. This outcome was similar for
ﬂattenings, and increasing the lower bound on the edge lengths to 0.5 increased the R2 value
to approximately 89%.

Figure 5: Distribution of split scores for ﬂattenings and subﬂattenings on simu-
lated pattern frequencies on the 6-taxon tree shown in Figure 1. Branch lengths
are all set to 0.1. The distributions are clearly separated by the number of shared
edges.

While, like the split parsimony score, the number of shared edges is unhelpful in discovering

true splits (since the true tree must be known in order to compute it), the measure may be

13

453210helpful in determining exactly which properties of the tree most eﬀect the split score, and should

be investigated further.

Figure 6: Distribution of split scores for ﬂattenings and subﬂattenings on simu-
lated pattern frequencies on the 6-taxon tree shown in Figure 1. Branch lengths
are all set to 0.8.

For the second simulation, the Jukes Cantor branch length for every branch in the tree

were changed from 0.1 to 0.8. This change should make the tree more diﬃcult to infer, since

nucleotide substitutions are much more likely to occur along each edge. The results are shown

in Figure 6. We will discuss the ﬂattening scores ﬁrst. We see that for the more diﬃcult tree

and a sequence length of 1,000, the ﬂattening split scores are grouped by the split size, and then

ordered by the number of shared edges. This seems to suggest that split score bias worsens with

a weaker phylogenetic signal. Increasing the sequence length to 10,000, we see that the eﬀect of

345 of size
|

split size has a lesser impact on the distribution of scores, however the true split 012

3 still produced scores which were higher than three false splits of size 2. The subﬂattenings

with a sequence length of 1,000bp seemed to perform similarly to the ﬂattenings with sequence

length 10,000bp, but with scores packed more closely together. Increasing the sequence length

to 10,000, the subﬂattenings produced scores which looked much more similar to the results

from Figure 5, with splits grouped by the number of shared edges, and minimal impact of split

size bias.

5.2 Sliding window analysis

As expected, subﬂattenings and squangles were able to pick up the chromosomal inversion in

the genome, just as ﬂattenings did in the sliding window analysis completed by Allman et al.

[4]. The three methods agreed upon the most likely phylogeny for the majority of windows.

Interestingly, the most common case involving some disagreement between the three methods

was that in which squangles and ﬂattenings chose a diﬀerent split to the subﬂattenings. Further,

the least common case was when squangles and subﬂattenings were in agreement with each

other, but not with the ﬂattenings. This is visible in Figure 7 and more clearly in Figure 8.

14

This was not expected because of the sense that squangles and subﬂattenings have more in

common—they both involve the same transformation of site-pattern probabilities detailed in

Section 2.

Figure 7: Results of the sliding window analysis detailed in Section 4.2. Each
vertical line represents a window, and the colour represents the split which was
chosen by each method for that particular window.

Figure 8: A summary of the results shown in Figure 7 in the form of a Venn
diagram. We can see that the three methods were in agreement for the majority
of windows, and of the cases where there was a disagreement between two methods
and a third, ﬂattenings and squangles agreed most often.

5.3 Split balance bias analysis

From our simulations on the 20-taxon tree, both ﬂattenings and subﬂattenings appeared to be

biased towards less balanced splits, but as predicted, subﬂattenings appeared to be slightly less

biased. Figure 9 shows that, compared to split scores for ﬂattenings, split scores for subﬂatten-

ings rose more slowly as split size increased. While Allman et al. suggest that correction to this

bias exists theoretically, they deemed it to be of little use in practice [4]. In our view, the link

between the rank properties of ﬂattening/subﬂattening matrices and the split parsimony score

suggests that a practical correction allowing comparison between splits of diﬀerent sizes does

not exist.

15

FlatteningsSubﬂatteningsSquangles01|2302|1303|1200501606152179621334FlatteningsSubﬂatteningsSquanglesTotal:37556Undecided:3258Figure 9: Split scores computed for a sample of 190 splits for each split size on
the 20-taxon tree shown in Figure 2, with branch lengths all set to 0.05, and
sequence length set to 500bp. The plot on the right is the same as the left, but
with all subﬂattening scores scaled so that the ﬁrst points overlap. Error bars
indicate sample standard deviation.

While we only simulated a single sequence alignment, repeated simulations yielded results

which seemed to be stable. Future investigation into the eﬀect of split balance could include

a similar simulation study, but with a systematic variation of sequence length, branch lengths

and/or tree topology.

5.4 LBA bias analysis

The results of our simulations on quartet trees are shown in Figure 10. As expected, we observe

ﬂattenings, subﬂattenings and squangles performing similarly on the trees in which all branches

were either short or long, with worse over-all performance in latter case. Flattenings showed

signiﬁcantly worse performance on the top-right quartet—an indication that ﬂattenings were

incorrectly pairing the long edges together far more often than subﬂattenings were. Further,

ﬂattenings performed slightly better for the bottom left quartet, indicating that the ﬂattenings

are more conﬁdent in correctly joining the two long branches. These results might indicate that

subﬂattenings and squangles are less impacted by long branch attraction bias when compared to

ﬂattenings. Comparing subﬂattenings to squangles, we saw the squangles correctly reconstruct

more trees for the top-right quartet, and fewer trees for the bottom-left quartet.

We repeated the simulations on the top-right and bottom-left quartets but with longer

branches (short branch length set to 0.1 and long branch length set to 1.0), and the results

are shown in Figure 11. We see that the diﬀerence between the ﬂattening and subﬂattening

performance when presented with two long branches was even more pronounced. We note that

the long branch length of 1.0 means that substitutions along the long branches are more likely

to occur than not, making these trees much more diﬃcult to infer.

Figure 12 shows the percentage of times ﬂattenings and subﬂattenings correctly recon-

structed the star tree with two long branches and an internal branch length of zero. While

ﬂattenings paired the two long edges almost every time, subﬂattenings did so less often. This

may further indicate that subﬂattenings are less biased to long branch attraction, though not

16

246810Splitsize0.050.100.150.200.250.300.35MeansplitscoreFlatteningSubﬂattening246810Splitsize0.200.250.300.35MeansplitscoreFlatteningSubﬂattening(scaledby2.39)Figure 10: The percentages of times each method was able to choose the correct
split from the simulated pattern counts. For each sequence length, we generated
100 diﬀerent sequence alignments. For each of the four quartet trees, short edges
have Jukes-Cantor length 0.05 and long edges have length 0.5.

Figure 11: The percentages of times each method was able to choose the correct
split from the simulated pattern counts. For each sequence length, we generated
100 diﬀerent sequence alignments. For each of the four quartet trees, short edges
have Jukes-Cantor length 0.05 and long edges have length 0.5.

completely unbiased, since a totally unbiased method would pair the long edges approximately

a third of the time. Increasing all four branch lengths (see the right plot in Figure 12) seemed to

increase the performance of the subﬂattenings, and Figure 13 seems to suggest that this eﬀect

is due to the increased length of the short branches.

17

Figure 12: The percentages of times each method chose the split ac
bd on the star
|
with an internal edge length of zero, a branch length of
tree on leaves
0.1 for leaves b and d and longer edges for leaves a and c. For each sequence
length, 100 sequence alignments were generated. Branch lengths are as shown.

a, b, c, d
}

{

Figure 13: The percentages of times each method chose the split ac
bd on the star
|
tree on leaves
with an internal edge length of zero, two short branches
of length 0.1 for leaves b and d, and varying branch lengths for leaves a and c.
For each increase of the long branch length, 100 sequence alignments of length
1000 were generated.

a, b, c, d
}
{

Interestingly, the squangles method appeared to be the least aﬀected by long branch attrac-

tion bias in these simulations. A theoretical investigation is recommended in order to conﬁrm

and make sense of these observations.

6 Discussion

Flattenings and subﬂattenings, and more generally split and rank based tools, encompass some

interesting algebraic and statistical ideas, and motivate methods for phylogenetic inference. We

have presented results which show that split scores computed from subﬂattenings are comparable

to those computed using ﬂattenings, supporting the use of subﬂattenings as an alternative tool

to ﬂattenings for phylogenetic inference. We also give some evidence that subﬂattenings may

be less impacted by certain biases, namely those arising from split size/balance and long branch

18

.5.05.11attraction. We think this is worth exploring further, but note that some split size bias is likely

unavoidable with methods relating to ﬂattenings, due to the relationship between the ﬂattening

matrix rank and the parsimony score.

It is our hope that this work will contribute to an

improved understanding of rank-based methods for constructing phylogenetic trees. There are

a number of other avenues available for further research in this area. While we have looked

at reconstructing quartet trees in this paper, algorithms that utilise ﬂattenings to reconstruct

larger trees have been developed [10] and can instead utilise subﬂattenings without needing to

be adapted in any way. It would be beneﬁcial to systematically compare tree reconstruction

methods involving ﬂattenings and subﬂattenings to various other approaches.

References

[1] E. S. Allman and J. A. Rhodes. Quartets and parameter recovery for the general Markov model
of sequence mutation. Applied Mathematics Research eXpress, 2004(4):107–131, July 2004. ISSN
1687-1200. doi: 10.1155/S1687120004020283.

[2] E. S. Allman and J. A. Rhodes. Phylogenetic invariants.

In O. Gascuel and M. Steel, editors,
Reconstructing Evolution: New Mathematical and Computational Advances, chapter 19, pages 108–
147. Oxford University Press, 2007.

[3] E. S. Allman and J. A. Rhodes. Phylogenetic ideals and varieties for the general Markov model.
Advances in Applied Mathematics, 40(2):127–148, 2008. ISSN 0196-8858. doi: 10.1016/j.aam.2006.
10.002. URL http://www.sciencedirect.com/science/article/pii/S0196885806002077.

[4] E. S. Allman, L. S. Kubatko, and J. A. Rhodes. Split Scores: A Tool to Quantify Phylogenetic
Signal in Genome-Scale Data. Systematic Biology, 66(4):620–636, Jan. 2017. ISSN 1063-5157. doi:
10.1093/sysbio/syw103.

[5] J. A. Cavender and J. Felsenstein. Invariants of phylogenies in a simple case with discrete states.
Journal of Classiﬁcation, 4(1):57–71, Mar. 1987. ISSN 1432-1343. doi: 10.1007/BF01890075.

[6] M. Charleston. Flatbush, 2022. URL https://github.com/mcharleston/Flatbush.

[7] J. Chifman and L. Kubatko. Quartet Inference from SNP Data Under the Coalescent Model.
Bioinformatics, 30(23):3317–3324, Aug. 2014. ISSN 1367-4803. doi: 10.1093/bioinformatics/btu530.

[8] J. Chifman and L. Kubatko.

Identiﬁability of the unrooted species tree topology under the
coalescent model with time-reversible substitution processes, site-speciﬁc rate variation, and in-
variable sites.
ISSN 0022-5193. URL
https://www.sciencedirect.com/science/article/pii/S0022519315001095.

Journal of Theoretical Biology, 374:35–47,

jun 2015.

[9] C. Eckart and G. Young. The approximation of one matrix by another of lower rank. Psychometrika,

1(3):211–218, Sept. 1936. ISSN 1860-0980. doi: 10.1007/BF02288367.

[10] N. Eriksson. Tree Construction Using Singular Value Decomposition. In L. Pachter and B. Sturm-
fels, editors, Algebraic Statistics for Computational Biology, chapter 19, pages 360–368. Berkeley,
California, 2005.

[11] J. Felsenstein. Cases in which Parsimony or Compatibility Methods Will be Positively Misleading.
Systematic Zoology, 27(4):401–410, 1978. ISSN 0039-7989. URL http://www.jstor.org/stable/
2412923.

[12] J. Fern´andez-S´anchez and M. Casanellas. Invariant Versus Classical Quartet Inference When Evo-

19

lution is Heterogeneous Across Sites and Lineages. Systematic Biology, 65(2):280–291, Nov. 2015.
ISSN 1063-5157. doi: 10.1093/sysbio/syv086.

[13] J. Gaither and L. Kubatko. Hypothesis tests for phylogenetic quartets, with applications to
coalescent-based species tree inference. Journal of Theoretical Biology, 408:179–186, nov 2016. ISSN
0022-5193. doi: https://doi.org/10.1016/j.jtbi.2016.08.013. URL https://www.sciencedirect.
com/science/article/pii/S0022519316302508.

[14] S. Grunewald, K. Forslund, A. Dress, and V. Moulton. QNet: An agglomerative method for the
construction of phylogenetic networks from weighted quartets. Molecular Biology and Evolution, 24
(2):532–538, Nov. 2006. doi: 10.1093/molbev/msl180.

[15] G. Guennebaud, B. Jacob, et al. Eigen v3. http://eigen.tuxfamily.org, 2010.

[16] M. D. Hendy and D. Penny. A Framework for the Quantitative Study of Evolutionary Trees.

Systematic Biology, 38(4):297–309, Dec. 1989. ISSN 1063-5157. doi: 10.2307/2992396.

[17] M. D. Hendy, D. Penny, and M. A. Steel. A discrete fourier analysis for evolutionary trees. Pro-

ceedings of the National Academy of Sciences, 91(8):3339–3343, 1994.

[18] B. R. Holland, P. D. Jarvis, and J. G. Sumner. Low-Parameter Phylogenetic Inference Under
ISSN 1063-5157. doi:

the General Markov Model. Systematic Biology, 62(1):78–92, 11 2012.
10.1093/sysbio/sys072. URL https://doi.org/10.1093/sysbio/sys072.

[19] J. P. Huelsenbeck and D. M. Hillis. Success of phylogenetic methods in the four-taxon case. Sys-

tematic Biology, 42(3):247–264, Sept. 1993. doi: 10.1093/sysbio/42.3.247.

[20] M. Kimura. Estimation of evolutionary distances between homologous nucleotide sequences. Pro-

ceedings of the National Academy of Sciences, 78(1):454–458, 1981.

[21] J. A. Lake. A rate-independent technique for analysis of nucleic acid sequences: evolutionary
ISSN 0737-4038. doi:

parsimony. Molecular Biology and Evolution, 4(2):167–191, Mar. 1987.
10.1093/oxfordjournals.molbev.a040433.

[22] P. J. Lockhart, M. A. Steel, M. D. Hendy, and D. Penny. Recovering evolutionary trees under
a more realistic model of sequence evolution. Molecular Biology and Evolution, July 1994. doi:
10.1093/oxfordjournals.molbev.a040136.

[23] V. Ranwez and O. Gascuel. Quartet-Based Phylogenetic Inference:
Molecular Biology and Evolution, 18(6):1103–1116, June 2001.
oxfordjournals.molbev.a003881.

Improvements and Limits.
ISSN 0737-4038. doi: 10.1093/

[24] R. Reaz, M. S. Bayzid, and M. S. Rahman. Accurate phylogenetic tree reconstruction from quartets:
A heuristic approach. PLOS ONE, 9(8):1–13, Aug. 2014. doi: 10.1371/journal.pone.0104008.

[25] S. Snir and S. Rao. Quartet MaxCut: A fast algorithm for amalgamating quartet trees. Molecular

Phylogenetics and Evolution, 62(1):1–8, Jan. 2012. doi: 10.1016/j.ympev.2011.06.021.

[26] J. Snyman, C. Fox, and D. Bryant. Parsimony and the rank of a ﬂattening matrix. 2021.

[27] M. Steel. Phylogeny—Discrete and Random Processes in Evolution. David Marshal, 2016. ISBN

978-1-611974-47-8.

[28] J. Stevenson. SplitP, March 2022. URL https://github.com/js51/SplitP.

[29] J. G. Sumner. Dimensional Reduction for the General Markov Model on Phylogenetic Trees.
ISSN 1522-9602. doi: 10.1007/

Bulletin of Mathematical Biology, 79(3):619–634, Mar. 2017.
s11538-017-0249-6.

20

[30] J. G. Sumner and P. D. Jarvis. Entanglement invariants and phylogenetic branching. Journal of

mathematical biology, 51(1):18–36, 2005.

[31] J. G. Sumner, M. A. Charleston, L. S. Jermiin, and P. D. Jarvis. Markov invariants, plethysms,

and phylogenetics. Journal of theoretical biology, 253(3):601–615, 2008.

[32] P. Virtanen, R. Gommers, T. E. Oliphant, M. Haberland, T. Reddy, D. Cournapeau, E. Burovski,
P. Peterson, W. Weckesser, J. Bright, S. J. van der Walt, M. Brett, J. Wilson, K. J. Millman,
N. Mayorov, A. R. J. Nelson, E. Jones, R. Kern, E. Larson, C. J. Carey, ˙I. Polat, Y. Feng, E. W.
Moore, J. VanderPlas, D. Laxalde, J. Perktold, R. Cimrman, I. Henriksen, E. A. Quintero, C. R.
Harris, A. M. Archibald, A. H. Ribeiro, F. Pedregosa, P. van Mulbregt, and S. . Contributors.
SciPy 1.0: Fundamental Algorithms for Scientiﬁc Computing in Python. Nature Methods, 17:261–
272, 2020. doi: 10.1038/s41592-019-0686-2.

[33] D. Wen, Y. Yu, M. W. Hahn, and L. Nakhleh. Data from: Reticulate evolutionary history and
extensive introgression in mosquito species revealed by phylogenetic network analysis. 2016. doi:
https://doi.org/10.5061/dryad.tn47c.

[34] S. J. Willson. Building phylogenetic trees from quartets by using local inconsistency measures.
Molecular Biology and Evolution, 16(5):685–693, May 1999. doi: 10.1093/oxfordjournals.molbev.
a026151.

21

