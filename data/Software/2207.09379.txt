To what extent can we analyze Kotlin programs
using existing Java taint analysis tools?
(Extended Version)

Ranjith Krishnamurthy
Fraunhofer IEM
ranjith.krishnamurthy@iem.fraunhofer.de

Goran Piskachev
Fraunhofer IEM
goran.piskachev@iem.fraunhofer.de

Eric Bodden
Paderborn University & Fraunhofer IEM
eric.bodden@uni-paderborn.de

2
2
0
2

l
u
J

9
2

]
L
P
.
s
c
[

2
v
9
7
3
9
0
.
7
0
2
2
:
v
i
X
r
a

Abstract—As an alternative to Java, Kotlin has gained rapid
popularity since its introduction and has become the default
choice for developing Android apps. However, due to its inter-
operability with Java, Kotlin programs may contain almost the
same security vulnerabilities as their Java counterparts. Hence,
we question: to what extent can one use an existing Java static
taint analysis on Kotlin code? In this paper, we investigate the
challenges in implementing a taint analysis for Kotlin compared
to Java. To answer this question, we performed an exploratory
study where each Kotlin construct was examined and compared
to its Java equivalent. We identiﬁed 18 engineering challenges
that static-analysis writers need to handle differently due to
Kotlin’s unique constructs or the differences in the generated
bytecode between the Kotlin and Java compilers. For eight of
them, we provide a conceptual solution, while six of those we
implemented as part of SECUCHECK-KOTLIN, an extension to
the existing Java taint analysis SECUCHECK.

Index Terms—static analysis, security, kotlin, taint analysis

I. INTRODUCTION

Ten years since its introduction, Kotlin has been one of
the fastest-growing programming languages (PLs). As of June
2022, it is the twelfth most popular PL by the PYPL index1.
Additionally, over 60% of the Android apps are written in
Kotlin, earning it the title of the default PL for the Android
framework2. One of the Kotlin advantages as a JVM-based PL
is its interoperability with Java and its unique constructs like
data classes, coroutines, null safety, extensions, etc.

Like Java, Kotlin code may be vulnerable to security vul-
nerabilities, such as SQL injection [1]. Therefore, statically
analyzing Kotlin code can be a helpful method for detecting
bugs and security vulnerabilities as early as possible. Despite
its popularity, very few static-analysis tools can analyze Kotlin
code, such as KtLint [2], Detekt [3], Diktat [4], and Sonar-
Qube [5]. These tools only perform pattern-based analyses
using simple rules, such as the rules of SonarQube [6]. We are
not aware of any tool that performs deep data-ﬂow analyses on
Kotlin code. For example, taint analysis has proven to be very
useful for detecting many prevalent security vulnerabilities [7]
such as injections [1], [8], [9] and XSS [10]. This versatility
of the taint analysis is due to its capacity to set various inputs
in the form of rules. At its core, the analysis follows the path

1https://pypl.github.io/PYPL.html
2http://surl.li/cfrcc

between so-called sources, where the taint is created, until so-
called sinks, where the taint is reported. The information for
the sources and sinks is often encoded in a rule via a domain-
speciﬁc language (DSL).

For Java,

there are many existing taint analyses [11],
[12] that can be used to detect many taint-style security
vulnerabilities. Since Kotlin compiles to the Java bytecode,
theoretically, one can use existing Java taint analyses on Kotlin
code. However, the Kotlin compiler generates the bytecode
differently than that of Java. This leads to the question: can
one use taint analysis tools intended for Java to analyze Kotlin
programs, or must one reinvent the wheel?

In this paper, we report the result of an exploratory study
that we conducted to address this question. We analyzed the
Kotlin-generated bytecode for each language construct and
compared it to the Java equivalent. We used the Jimple inter-
mediate representation generated by the Soot framework [13]
for this comparison. For completeness, we used the ofﬁcial
Kotlin documentation [14] and created a micro benchmark
with 294 simple Kotlin programs and 135 simple Java pro-
grams, where each program demonstrates a single language
construct. When considering taint analysis, we found that
most Kotlin constructs can be analyzed the same way as
the Java equivalents. However, we also found 18 engineering
challenges that require a different approach. For example,
functions declared as top-level elements do not have a parent
class in the source code. However, the compiler generates a
parent class in the Java bytecode, which the taint analysis
should be aware of to locate the function correctly. We
propose solutions for eight of these challenges that analysis
writers can implement. As a proof of concept, we extended
an existing Java taint analysis tool, SECUCHECK [12], by
implementing six of our eight solutions, creating a taint
analysis tool SECUCHECK-KOTLIN that supports the standard
language constructs. Finally, we evaluated the applicability of
SECUCHECK-KOTLIN with the Kotlin version of the PetClinic
application3.

We present the details of our methodology in Section II.
Then, in Section III, we report on our ﬁndings from the
study. Next, we present details of our implementation of

3https://github.com/spring-petclinic/spring-petclinic-kotlin

 
 
 
 
 
 
SECUCHECK-KOTLIN in Section IV. Finally, we conclude and
present our future work in Section V.

helps to identify the challenges easily and quickly. For deeper
examination, we then examine the IR and Java bytecode.

II. METHODOLOGY

A. Micro benchmark

We examined the intermediate representation (IR) of the
Kotlin code and—if existing—the equivalent Java code. Our
methodology consists of automatic IR generation with meta-
data useful for our examination, which is a manual step
that follows. We examined the following: (1) whether the
generated IR for Kotlin is valid and can be analyzed the
same way as the IR from equivalent Java code, (2) whether
there are difﬁculties due to the deﬁnition of sources and sinks,
and (3) whether there are language constructs in Kotlin that
the analysis needs to handle in a new unique way when
compared to Java. We did not consider challenges that can
occur due to the callgraph-generation algorithms or computing
alias information algorithms.

We used Kotlin’s ofﬁcial documentation [14] to examine
each language construct. During the examination, we covered
all constructs from the “Concepts” section and a few from
the “Standard library” section (Collections, Iterators, Ranges,
and Progressions). We did not consider constructs that were
in the experimental stage at the time of this study. Table I
summarizes Kotlin’s constructs discussed in the ofﬁcial docu-
mentation and the those we manually examined.

Constructs

#Sub-
constructs

Supported

Types, Control ﬂow, Packages & imports, Null safety,
Equality, This expression, Destructuring declarations,
Ranges and Progressions
Classes and objects (except for Delegated properties)
Functions (except for Builders)
Asynchronous programming techniques, Coroutines,
Annotations, and Reﬂections
Collections and Iterators

11

17
5

4

2

Legend
✔: examined all constructs in the category.
✔: examined only the basic constructs.
✘: did not examine in this study.

✔

✔
✔

✘

✔

Using real-world projects for the manual examination is
infeasible because a real-world project has a complex mix of
many constructs, making it hard to identify them clearly in
Jimple. Therefore, we built a micro benchmark suite classiﬁed
into two groups—Kotlin suite and Java suite. The Kotlin
suite consists of small Kotlin programs, each focusing on one
particular Kotlin construct. If a corresponding feature exists in
Java, then an equivalent program is present in the Java suite.
The suits contain six main categories: basics (43 Kotlin & 36
Java ﬁles), classes and objects (118 Kotlin & 80 Java ﬁles),
functions (27 Kotlin & 4 Java ﬁles), generics (8 Kotlin & 10
Java ﬁles), unique to Kotlin (87 Kotlin ﬁles), and collection
(11 Kotlin & 5 Java ﬁles). Table II provides the overview of
the Kotlin suite and the important features in the six categories.

Categories in
Kotlin suite

basics

classesAndObjects

functions

generics

uniqueToKotlin

collection

Major features

data types, control ﬂow, package, import,
exceptions, equality, operators, variables
classes, enum class, inline class, sealed class,
nested / inner class, interface, functional
interface (SAM), object expression, object
declaration, delegation, qualiﬁed this, type
aliases, visibility modiﬁers
simple functions, default arguments, local
functions, inﬁx notations. tail recursive function,
varargs
simple generic type, generic functions, raw
types, upper bounds,
data class, destructuring declaration, extensions,
higher-order functions, inline functions, null
safety, operator overloading, primary
constructor, properties, ranges, progressions,
smart cast, string template, declaration site
variance, type projection
collection and iterators

#Kotlin
ﬁles

41

118

27

8

87

11

Table II: Overview of Kotlin suite.

Table I: List of Kotlin’s features discussed in Kotlin’s ofﬁcial
documentation.

B. Manual examination

Kotlin targets most Java Development Kit (JDK) versions.
However, the annual developer ecosystem survey conducted
by JetBrains in 2020 shows that 73% of Kotlin developers
target JDK 8 [15]. Furthermore, Kotlin targets JDK 8 by
default. Therefore, we consider JDK 8 for this exploratory
study. Additionally, we consider the Kotlin version 1.5.10.

The Kotlin compiler has various options and annotations for
modifying the compilation process, which alters the output of
the compiler, Java bytecode. For this study, we used the default
conﬁguration of the compiler.

For the IR generation, we built a tool that generates Jimple
IR using the Soot framework [13]—JIMPLEPROVIDER. The
Jimple code is organized based on the package name. Further-
more, for each class, JIMPLEPROVIDER generates metadata in
a JSON ﬁle that contains information such as class name, super
class, implemented interfaces, method count, method signa-
tures, local variables, invoke expressions, etc. This metadata

The manual examination of the Jimple code was performed
by the ﬁrst author, who has more than 4.5 years of soft-
ware development experience and is a Ph.D. student focusing
on programming languages and static analysis. The more
complex constructs, especially those speciﬁc to Kotlin or
with differences from Java, were discussed with the second
author, a Ph.D. student in the last year with expertise in the
static analysis, and an external researcher with professional
experience in Kotlin development. The examiners used the
JIMPLEPROVIDER to generate the IR for the entire micro
benchmark. Then, each construct was inspected manually.
First, the generated metadata that provides information related
to taint analysis is studied. Next, the generated IR is checked
for a deeper examination. If more information is needed, then
the generated bytecode is examined. Based on this, the exam-
iner concluded whether a construct requires special handling
in Kotlin taint analysis compared to Java taint analysis.

C. Threats to Validity

Our study involves a manual step, making it possible that
some of the ﬁndings are incomplete or incorrect. Furthermore,
the programs written in the micro benchmark suite are based
on personal experience. Therefore, some advanced use cases
may be missing. As discussed earlier in this section, we
considered the Kotlin version 1.5.10 and the target JDK 8.
However, there is a risk that for some of the constructs, the
Kotlin compiler may generate the bytecode differently for
different versions. Also, for some constructs, the compiler may
generate bytecode differently if some compiler options are
used. As stated earlier, we only used the default conﬁguration.

III. FINDINGS

In Sub-Section III-A, we present the engineering challenges
we identiﬁed and to which we have proposed a solution. Then,
in Sub-Section III-B, we present the engineering challenges,
which we leave as open issues. Then, in Sub-Section III-C,
we answer two research questions for the exploratory study.

A. Engineering challenges with proposed solution

1) Data type mapping: On the bytecode level, some data
types in Kotlin are mapped to Java data types. For example, the
non-nullable kotlin.Int is mapped to Java’s int. Table
IV summarizes the data type mapping from Kotlin source
code to the Java bytecode. Similarly, the compiler maps the
function type to kotlin.jvm.functions.Function*
in the Java bytecode as described in Table III. This mapping
is only affected by the number of parameters taken by the
function type. The type of the parameters or return type will
not affect the mapping. Note: the mapping described in Table
III is also valid for the respective nullable function types.
Due to this data type mapping, the users must provide valid
method signatures based on the Java bytecode to specify the
source, sink, and other relevant method calls. However, it is
cumbersome for the users to ﬁnd the valid method signatures
in big projects, making the tool not usable.

KOTLIN FUNCTION TYPE
Function type with 0 parameter,
e.g. () → Int
Function type with 1 parameter,
e.g. (Byte) → Unit
Function type with 2 parameters,
e.g. (Int, Int) → Int

Function type with 22 parameters
Function type with more than 22
parameters

TYPE IN JAVA BYTECODE
kotlin.jvm.functions.Function0

kotlin.jvm.functions.Function1

kotlin.jvm.functions.Function2

...

kotlin.jvm.functions.Function22
kotlin.jvm.functions.FunctionN

Table III: Kotlin function type mapping.

Proposed solution:

To handle this challenge, static-
analysis developers can implement a data type transformer,
which takes a method signature provided by the users as input.
Then, the transformer checks for the parameters and return
type in the given method signature. If the parameters type and
return type are valid Kotlin data types, the transformer replaces
the Kotlin data type with the respective Java data type.

2) Type alias: A type alias allows developers to give a
new name to the existing type. For example, in the Kotlin
standard library, ArrayList is deﬁned as a type alias
to java.util.ArrayList. Therefore, ArrayList does
not exist in the bytecode. However, the experts in the Kotlin
programming language know which types are deﬁned as type
alias in Kotlin standard libraries. Furthermore, domain experts
in custom libraries such as cryptographic APIs know what type
aliases are deﬁned in their libraries. On the other hand, users
of the existing Java taint analysis tools may not know such
type aliases and may give invalid method signatures.
Proposed solution: Static-analysis developers can implement
a feature as part of the DSL that allows domain experts
to specify type aliases—type alias speciﬁcations. The DSL
semantics replaces all the type aliases found in the given
method signatures with the original type speciﬁed in the given
type alias speciﬁcations.

3) Property:

In Kotlin, a property is a ﬁeld with an
accessor. By default, Kotlin provides a getter and setter for
mutable properties; for immutable properties, the getter only.
Whenever there is access to a property in Kotlin source code,
the Kotlin compiler uses the respective accessor method in
the Java bytecode. Similar to variables, properties can be
tainted. Therefore, the getter and setter of properties can be
the source, sink, or propagator methods. Thus, the user needs
to be aware of these signatures.
Proposed solution: Static-analysis developers can provide a
feature in the DSL that enables users to specify a property by
providing the fully qualiﬁed class name in which the property
is deﬁned, the property name, and the property’s type. Then,
the valid accessor method signature can be built automatically.
the getter method is <given fully
The pattern for
qualified class name>: <given property’s
type> get<given property name with first
letter caps>(). Similarly, the setter method’s pattern
is <given fully qualified class name>: void
set<given property name with first letter
caps>(<given property’s type>).

4) Top-level members: In Kotlin, top-level members are
deﬁned in a Kotlin ﬁle under a package. Kotlin functions and
properties can be top-level members. These members are not
declared in any class, object, or interface. Therefore, in Kotlin
source code, top-level members can be accessed directly with-
out creating any object or using a class to access it. However,
the Kotlin compiler generates a class in the Java bytecode
and declares those top-level members as static members in
the generated class. Suppose a novice user wants to specify
top-level members as the source, sanitizer, propagator, or sink
methods. In that case, the user must identify the valid class
name in the method signature of top-level members.
Proposed solution: To identify a valid class name of top-
level members, one needs the ﬁlename and the package name
in which top-level members are deﬁned. Therefore, static-
analysis developers can provide a feature in the DSL that
enables users to specify a function or a property as a top-
level member by providing the package name and the ﬁle

KOTLIN DATA TYPE

TYPE IN JAVA BYTECODE

KOTLIN DATA TYPE

TYPE IN JAVA BYTECODE

Nothing
Unit

Byte
Short
Int
Long
Char
Float
Double
Boolean

Any
Cloneable
Comparable
Enum
Annotation
CharSequence
String
Number
Throwable

Array<Byte>
Array<Short>
Array<Int>
Array<Long>
Array<Char>
Array<Float>
Array<Double>
Array<Boolean>
Array<Any>
Array<*>

ByteArray
ShortArray
IntArray
LongArray
CharArray
FloatArray
DoubleArray
BooleanArray

Collection<T>
List<T>
Set<T>
Map<K, V>
Map.Entry<K, V>
Iterator<T>
Iterable<T>
ListIterator<T>

SPECIAL RETURN TYPES

java.lang.Void
void

BASIC TYPES

byte
short
int
long
char
float
double
boolean

Nothing?
Unit?

Byte?
Short?
Int?
Long?
Char?
Float?
Double?
Boolean?

SPECIAL RETURN TYPES

java.lang.Void
Unit

BASIC TYPES

java.lang.Byte
java.lang.Short
java.lang.Integer
java.lang.Long
java.lang.Character
java.lang.Float
java.lang.Double
java.lang.Boolean

FEW BUILT-IN CLASS

FEW BUILT-IN CLASS

java.lang.Object
java.lang.Cloneable
java.lang.Comparable
java.lang.Enum
java.lang.Annotation
java.lang.CharSequence
java.lang.String
java.lang.Number
java.lang.Throwable

Any?
Cloneable?
Comparable?
Enum?
Annotation?
CharSequence?
String?
Number?
Throwable?

java.lang.Object
java.lang.Cloneable
java.lang.Comparable
java.lang.Enum
java.lang.Annotation
java.lang.CharSequence
java.lang.String
java.lang.Number
java.lang.Throwable

ARRAY TYPES

ARRAY TYPES

java.lang.Byte[]
java.lang.Short[]
java.lang.Integer[]
java.lang.Long[]
java.lang.Character[]
java.lang.Float[]
java.lang.Double[]
java.lang.Boolean[]
java.lang.Object[]
*[]

BASIC TYPES ARRAY
byte[]
short[]
int[]
long[]
char[]
float[]
double[]
boolean[]

IMMUTABLE COLLECTIONS

java.util.Collection<T>
java.util.List<T>
java.util.Set<T>
java.util.Map<K, V>
java.util.Map.Entry<K, V>
java.util.Iterator<T>
java.lang.Iterable<T>
java.util.ListIterator<T>

Array<Byte>?
Array<Short>?
Array<Int>?
Array<Long>?
Array<Char>?
Array<Float>?
Array<Double>?
Array<Boolean>?
Array<Any>?
Array<*>?

ByteArray?
ShortArray?
IntArray?
LongArray?
CharArray?
FloatArray?
DoubleArray?
BooleanArray?

Collection<T>?
List<T>?
Set<T>?
Map<K, V>?
Map.Entry<K, V>?
Iterator<T>?
Iterable<T>?
ListIterator<T>?

java.lang.Byte[]
java.lang.Short[]
java.lang.Integer[]
java.lang.Long[]
java.lang.Character[]
java.lang.Float[]
java.lang.Double[]
java.lang.Boolean[]
java.lang.Object[]
*[]

BASIC TYPES ARRAY
byte[]
short[]
int[]
long[]
char[]
float[]
double[]
boolean[]

IMMUTABLE COLLECTIONS

java.util.Collection<T>
java.util.List<T>
java.util.Set<T>
java.util.Map<K, V>
java.util.Map.Entry<K, V>
java.util.Iterator<T>
java.lang.Iterable<T>
java.util.ListIterator<T>

MUTABLE COLLECTIONS

MUTABLE COLLECTIONS

MutableCollection<T>
MutableList<T>
MutableSet<T>
MutableMap<K, V>
MutableMap.Entry<K, V>
MutableIterator<T>
MutableIterable<T>
MutableListIterator<T>

java.util.Collection<T>
java.util.List<T>
java.util.Set<T>
java.util.Map<K, V>
java.util.Map.Entry<K, V>
java.util.Iterator<T>
java.lang.Iterable<T>
java.util.ListIterator<T>

MutableCollection<T>?
MutableList<T>?
MutableSet<T>?
MutableMap<K, V>?
MutableMap.Entry<K, V>?
MutableIterator<T>?
MutableIterable<T>?
MutableListIterator<T>?

java.util.Collection<T>
java.util.List<T>
java.util.Set<T>
java.util.Map<K, V>
java.util.Map.Entry<K, V>
java.util.Iterator<T>
java.lang.Iterable<T>
java.util.ListIterator<T>

(a) Mapping for non-nullable types

(b) Mapping for nullable types

Table IV: Data types mapping from Kotlin source code to the Java bytecode

name in which a top-level member is deﬁned. Then, the DSL
component can build a valid class name for a top-level function
or accessors of a top-level property. The rule to build the valid
class name is <given package name>.<given file
name>Kt.

5) Default arguments: In Java, the overload feature can
achieve a default value to function or constructor arguments.
However,
this increases the number of overloads. Kotlin
avoids this problem by providing a default argument feature
in a constructor or function. For a function or constructor
with default arguments, the Kotlin compiler generates two
implementations in the Java bytecode. First, the actual im-
plementation with all the parameters as deﬁned in source
code. Second implementation generated by the compiler with
additional arguments that determines the default arguments’
value and calls the actual implementation. For constructor, the
compiler adds two additional arguments at the end—int and
kotlin.jvm.internal.DefaultConstructorMar-
ker. Similarly, for a function, the compiler adds int and
java.lang.Object at the end. Additionally, if the func-
tion is a member function, the compiler adds a ﬁrst argument
of type in which the function is deﬁned. This added ﬁrst argu-
ment is the this-object of the member function. Furthermore,
for a default argument in a top-level function or member func-
tion, the compiler adds the sufﬁx $default to the function
name for the second implementation. If a developer does not
pass value to default arguments, then the compiler calls the
second implementation. Suppose users of taint analysis tools
specify a default argument constructor or function as a source
method. In that case, the analysis component should identify
the second implementation generated by the compiler as a
source method and track the variables correctly.
Proposed solution:
If the analysis fails to identify a method
call as a source, sink, or other relevant method as speciﬁed
in taint-ﬂow speciﬁcations, then the analysis checks for the
second implementation of the default argument feature. For
each function or constructor in taint-ﬂow speciﬁcations, add
the additional arguments and modify the function name as
described in Sub-Section III-A5. Subsequently, if the method
signature matches with the method call’s signature, track the
respective variables. For constructor and top-level function,
track the variables based on the speciﬁed rules for the matched
method in taint-ﬂow speciﬁcations. However, for member
functions, since the compiler adds a parameter at the begin-
ning, the analysis should consider this added ﬁrst argument
while tracking the variables. For example, if the this-object
is speciﬁed to track, then track the ﬁrst argument in the Java
bytecode. Likewise, track the second argument in the Java
bytecode if the ﬁrst argument is speciﬁed to track and so forth.
the extension feature allows
extending an existing class with new members without using
inheritance. However, extensions will not modify and add a
new member to an existing class; instead, the new member
is made accessible using the dot-notation on variables of
the type (receiver type) for which the extension member
is deﬁned. In the Java bytecode for a top-level extension

6) Extensions:

In Kotlin,

function, the Kotlin compiler adds the receiver type as the
ﬁrst argument, followed by the actual parameters deﬁned in
the source code. Similarly, the compiler adds the receiver
type as the ﬁrst argument to the getter method of a top-
level extension property. Note: The compiler generates only
the getter method for an extension property. Furthermore, for
top-level companion object extension members, the compiler
also adds the receiver type as the ﬁrst argument, followed
by the actual argument deﬁned in the source code. However,
the added ﬁrst argument type is the wrapper class generated
for a companion object. The companion object is discussed
in detail in Section III-B1. Like top-level extension members,
the compiler also adds the receiver type as the ﬁrst argument
for an extension deﬁned as a class member. Furthermore,
Kotlin supports qualiﬁed this-object to access the outer
class’s this-object. For this, the compiler considers the actual
this-object (outer class’s this) in the Java bytecode as a
qualiﬁed outer class’s this-object in the source code and the
ﬁrst argument in the Java bytecode as a receiver this-object
in the source code. Suppose users want to specify an extension
member as a source or sink method, then users might give
an invalid method signature since users might not be aware
of the ﬁrst argument of receiver type added by the compiler.
Furthermore, if users specify to track the this-object in an
extension member, then the analysis should track the ﬁrst
argument. Likewise, the analysis should track the actual this-
object in the Java bytecode if the outer class this-object is
speciﬁed to track. Similarly, if users specify to track the ﬁrst
argument in an extension function, then the analysis should
track the second argument and so forth.
Proposed solution: To handle extension functions and exten-
sion properties, static-analysis developers should make their
taint-ﬂow speciﬁations aware of these. If this is done through
the DSL for taint-ﬂow speciﬁcations, the DSL can build the
valid method signature by adding the given fully qualiﬁed class
name as the ﬁrst argument. Furthermore, the users should not
be able to obtain a setter method from an extension property
since an extension property can not have a setter method.

To handle companion object extensions, static-analysis de-
velopers can provide a feature in the DSL. This feature
enables the users to specify a function or property as a
companion object extension member by providing the fully
qualiﬁed class name and the name of the companion ob-
ject for which the extension is deﬁned. If the name of the
companion object is not given, then by default, the name is
Companion. From these inputs, the generated wrapper class
for the companion object can be built as <given fully
qualified class name>$<given companion ob-
ject name>. Then, the valid method signature can be built
by adding this wrapper class as a ﬁrst argument.

To handle the qualiﬁed this-object in extensions as mem-
bers, the DSL should be able to track the this-object as
extension receiver or dispatch receiver (outer class’s this-
object). If users specify to track this-object as an extension
receiver, modify the taint-ﬂow speciﬁcation to track the ﬁrst
parameter in the Java bytecode. Similarly, if users specify

BUILT-IN OPERATOR

MAPPED TO A FUNCTION

BUILT-IN OPERATOR

MAPPED TO A FUNCTION

+obj
-obj
!obj
++obj
--obj
obj++
obj--

obj1 + obj2
obj1 - obj2
obj1 * obj2
obj1 / obj2
obj1 % obj2
obj1..obj2

obj1 += obj2
obj1 -= obj2
obj1 *= obj2
obj1 /= obj2
obj1 %= obj2

obj1 == obj2
obj1 != obj2

UNARY OPERATORS

obj.unaryPlus()
obj.unaryMinus()
obj.not()
obj.inc()
obj.dec()
obj.inc()
obj.dec()

ARITHMETIC OPERATORS

obj.plus(obj2)
obj.minus(obj2)
obj.times(obj2)
obj.div(obj2)
obj.rem(obj2)
obj.rangeTo(obj2)

AUGMENTED ASSIGNMENT OPERATORS

obj.plusAssign(obj2)
obj.minusAssign(obj2)
obj.timesAssign(obj2)
obj.divAssign(obj2)
obj.remAssign(obj2)

EQUALITY CHECK OPERATOR

obj.equals(obj2)
!(obj.equals(obj2))

obj1 in obj2
obj1 !in obj2

IN OPERATOR

obj.contains(obj2)
!(obj.contains(obj2))

INDEX OPERATORS

obj[i]
obj[i, j]
obj[i, j, k]
obj[i1, ..., in]
obj[i] = obj2
obj[i, j] = obj2
obj[i, j, k] = obj2
obj[i1, ..., in] = obj2

obj.get(i)
obj.get(i, j)
obj.get(i, j, k)
obj.get(i1, ..., in)
obj.set(i, obj2)
obj.set(i, j, obj2)
obj.set(i, j, k, obj2)
obj.set(i1, ..., in, obj2)

INVOKE OPERATORS

obj()
obj(i)
obj(i, j)
obj(i, j, k)
obj(i1, i2, ..., in)

obj.invoke()
obj.invoke(i)
obj.invoke(i, j)
obj.invoke(i, j, k)
obj.invoke(i1, i2, ..., in)

obj1 > obj2
obj1 < obj2
obj1 >= obj2
obj1 <= obj2

COMPARISON OPERATORS

obj.compareTo(obj2)
obj.compareTo(obj2)
obj.compareTo(obj2)
obj.compareTo(obj2)

Table V: Built-in operators and its corresponding functions in Kotlin.

to track this-object as dispatch receiver, modify the taint-
ﬂow speciﬁcation to track the actual this-object in the Java
bytecode. Similarly, for an extension function, if user specify
to track the ﬁrst parameter, then analysis should track the
second parameter and so forth.

In Kotlin,

7) Inﬁx function:

inﬁx functions are called
using the inﬁx notation, i.e., without the dot notation and the
parentheses. The inﬁx function must be a member function or
extension function and must have a single parameter without a
default value. Similar to a standard function, an inﬁx function
can be a source, sink, and other relevant methods. However, a
novice user of taint analysis tools may not know how the inﬁx
function works in the Java bytecode and may provide invalid
method signatures.
Proposed solution: Static-analysis developers can provide a
DSL feature that enables users of taint analysis tools to specify
a function as an inﬁx function by providing a function name,
receiver type, parameter type, and return type. Then, DSL
can build a valid method signature as <given receiver
type>: <given return type> <given function
name>(<given parameter type>).

8) Operator overloading: Operator overloading redeﬁnes
the implementation of the built-in operators with speciﬁc
types. For example, one can overload the ++ operator by
deﬁning the function inc on a custom class. The compiler
calls the implemented inc function in the Java bytecode.
Table V provides the mapping between the built-in operator
and the function name. An overloaded operator function can
be a sanitizer or propagator method. However, the novice users
of taint analysis tools may not know the mapping of the built-
in operators to the function name and may provide invalid
method signatures.

Proposed solution: Static-analysis developers can provide a
feature in DSL that enables users to specify an overloaded
operator by providing the symbol of an operator, type of the
receiver, return type, and the parameter(s) type based on an
operator. Then, DSL can build the valid method signature
by mapping the given operator symbol to the function as
described in Table V.

B. Engineering challenges without solution (open issues)

1) Companion object:

In Kotlin, a companion object
than the instance of
binds members to a class rather
to Java’s
is similar
a class. Kotlin’s companion object
the Kotlin compiler generates
static members. However,
a wrapper class for each companion object
in the Java
bytecode. The naming scheme for that wrapper class is
<class name in which the companion object
is defined>$<companion object name>.
the
companion object name is not provided in Kotlin source code,
then by default the name is Companion. The compiler places
the implementation of that companion object’s members in
the generated wrapper class.

If

Furthermore, to allow that wrapper class to access the
private members of the actual class and vice versa, the com-
piler generates additional functions for each private member.
For a private function, the naming scheme for the generated
function is access$<actual name of the private
function>. Similarly, the naming scheme for the accessors
of a private property is access$<accessor’s method
name of a property>$cp. The accessors’ method name
is discussed in Sub-Section III-A3.

Due to such implementation of companion objects in the
Java bytecode, users of taint analysis tools might ﬁnd it

difﬁcult to identify valid method signatures. Additionally, for
the function that takes a companion object as a parameter,
users must give that parameter type as a generated wrapper
class in the method signature, which is not visible in the
source code. Furthermore, the analysis should be aware of
the generated functions for private members, which might be
a possible source, sink, or propagator.

2) Destructuring declaration: In Kotlin, an object can be
destructured into multiple variables in a single statement using
the destructuring declaration. To allow a class to destructure,
that class must have the componentN functions with the
operator keyword. These component functions return the
properties of a class. The widely used convention for the order
of componentN functions is the order of properties deﬁned
in a class. However, it is not mandatory, and developers can
make component functions return any properties of a class.
Suppose the function component1 returns the ﬁrst property
and the users of taint analysis tools specify the getter method
of the ﬁrst property as a source method. In that case, the
analysis should be able to identify the component1 function
as a source method. Therefore, the analysis must know the
mapping between the componentN functions and properties
of a class to identify a taint-ﬂow in a destructuring declaration.
3) Internal modiﬁer: In Kotlin, a member declared with
an internal modiﬁer is only visible inside the module in
which the member is deﬁned. Kotlin deﬁnes a module as a
group of Kotlin ﬁles that are compiled together. In the Java
bytecode, the Kotlin compiler appends the symbol hyphen
followed by the module name for the accessors of an internal
property and to an internal member function. However, we
did not observe this behavior for classes,
top-
level functions, or accessors of top-level properties, which are
declared as internal. Suppose users of taint analysis tools
specify an internal member function or accessors of internal
property as a sink method. In that case, the analysis component
should identify the modiﬁed name with the appended module
name as a sink method. Otherwise, the analysis component
fails to detect taint-ﬂow in internal member functions and
properties. Note: if there is a symbol hyphen in the module
name, the Kotlin compiler replaces it with the underscore
before appending it to the internal member functions and
accessors of internal property in the Java bytecode.

interfaces,

4) Inline class: Kotlin’s inline class wraps an existing
class with improved performance compared to a manually
created wrapper class. In the Java bytecode, the Kotlin com-
piler generates some of the member functions for an inline
class—constructor, accessor for a property (wrapped class),
toString, hashCode, and equality check. These func-
tions are generated to support the interoperability with Java.
However, the compiler generates the alternative version of
these functions to improve the performance by inlining the
wrapped class in place of wrapper class usage. In addition, the
compiler adds the sufﬁx -impl to the improved version of
these functions and to the overridden function of an interface.
Additionally, the compiler generates box-impl and unbox-
impl function for boxing and unboxing the wrapped class.

The Kotlin compiler calls the -impl version of member
functions wherever it is possible to improve the performance.
Suppose users of taint analysis tools specify the member
functions of an inline class as a source. In that case, along
with the actual implementation, the analysis should identify
its -impl version as a source. Otherwise, the existing Java
taint analysis tools fail to detect taint-ﬂows in an inline class.
5) Function returning anonymous object: In Kotlin, ob-
ject expressions create objects of an anonymous class. Every
object expression has at
least one base class. The Kotlin
compiler generates a wrapper class for each instance of object
expression in the Java bytecode similar to Java. However, in
contrast to Java, the return type in Kotlin’s function is not
mandatory to specify, and the compiler can infer the type.
Suppose a function is private and returns an anonymous object.
In that case, the compiler infers the return type as the generated
wrapper class, which is not visible in the source code. This
makes it challenging for the users to identify the valid method
signature of a private function that returns anonymous object.
6) Local functions: Kotlin supports local functions, which
are functions inside other functions. These local functions
can access the outer functions local variables. For a local
function, the Kotlin compiler generates a static function in the
Java bytecode. The naming scheme and the parameters of this
static function are <outer function name>$<local
function name><-digits starting from 0 if
there are multiple local function with th-
e same name>(<outer functions local varia-
bles if accessed by local function>, <this
object if the outer function is a member
function>, <actual parameter as defined f-
or the local function in Kotlin source co-
de>). Additionally, if a local function accesses an mutable
local variable of an outer function, then the compiler passes
the reference type to reﬂect the changes in the outer function.
function access mutable Int
For example,
type, then in the Java bytecode the Kotlin compiler passes
the kotlin.jvm.internal.Ref$IntRef type
to
the generated static function as a parameter. Due to such
implementation of local function in the Java bytecode, it is
challenging for the user to identify the valid method signature
of a local function. Furthermore, the analysis must handle the
accessed local variables of the outer functions to track the
tainted variable.

the local

if

7) Higher-order functions: Kotlin provides a function type
that enables higher-order function in Kotlin. These function
types are mapped to kotlin.jvm.functions.Functi-
on* types in the Java bytecode as described in Table III.
Furthermore, there are ﬁve ways to create an instance of
a function type in Kotlin—lambda expression, anonymous
function, function literal with a receiver, callable reference,
and instances of a custom class that implements a function
type. The Kotlin compiler generates a wrapper class for each
instance of a function type in Kotlin source code. The naming
scheme for this wrapper class is <class name in which
the lambda is declared>$<function name in

which the lambda is declared>$<variable n-
ame in which the lambda expression is sto-
red if any otherwise this is optional>$<d-
igits starting from 1>. This wrapper class overrides
the interface function invoke, in which the Kotlin compiler
places the implementation of a lambda expression.

Similar to the local functions accessing the outer function’s
local variables as discussed in Sub-Section III-B6, lambda
expressions can also access the outer function’s local variables.
All the accessed variables are passed to the constructor of
the wrapper class. Then, the constructor stores these val-
ues in its ﬁelds, which can be accessed in the invoke
method. Furthermore, if the outer function’s local variable
is immutable, the compiler passes the reference type, e.g.
kotlin.jvm.internal.Ref$IntRef. For an anony-
the compiler generates the Java bytecode
mous function,
similar to the lambda expression. Similarly, for a class im-
plementing a function type,
the compiler implements the
kotlin.jvm.functions.Function* in the Java byte-
code and implements the interface method invoke.

For a function literal with a receiver, the compiler generates
the Java bytecode similar to the lambda expression, except
that the receiver object is passed as the ﬁrst argument to
the invoke method. For callable reference, the compiler
generates the Java bytecode similar to a lambda expression.
However, the receiver of a callable reference is passed to
the constructor of the generated wrapper class, which stores
the receiver in the superclass’ ﬁeld called receiver. Later,
the function invoke access the ﬁeld receiver to call the
respective member function.

Java uses invokedynamic instruction for lambda ex-
the existing Java taint analysis tools
pression. Therefore,
detect
taint-ﬂows in lambda expressions in Java by han-
dling the invokedynamic instruction in the Java byte-
code. However, by default, the Kotlin compiler does not use
invokedynamic instruction for an instance of a function
type, which leads to the existing Java taint analysis tools fail-
ing to detect taint-ﬂows in higher-order functions. Therefore,
the analysis must handle the generated wrapper class for an
instance of a function type to track the tainted information.
Furthermore, the analysis should handle the receiver property
to track the tainted receiver object for a callable reference.
Furthermore, similar to local functions (III-B6), the analysis
should handle the accessed local variables of the outer func-
tions to track the tainted variable.

Note: for a functional interface or a Single Abstract Method
the Kotlin compiler generates the Java bytecode
i.e.,
to the Java’s lambda expression by default,

(SAM),
similar
invokedynamic instruction in the Java bytecode.

8) Inline function: As discussed in Sub-Section III-B7,
the Kotlin compiler generates a wrapper class for each in-
stance of a function type, captures the outer function’s local
variables, which leads to extra memory allocations, and extra
virtual method call introduces runtime overhead. However,
in some scenarios, such runtime overhead can be eliminated
by inlining the lambda expression rather than creating an

instance of a function type. For this purpose, Kotlin provides
the println function in
inline functions. For example,
Kotlin is declared as inline, which calls the Java’s function
System.out.println. Therefore, in the Java bytecode,
we ﬁnd the System.out.println function call in place
of Kotlin’s println call site. Similarly, custom higher-order
functions can also be declared as inline in Kotlin. Suppose
users of taint analysis tools specify an inline function as a sink
method. In that case, taint analysis tools fail to detect taint-ﬂow
that reaches this sink method since there is no actual method
call of an inline function in the Java bytecode. Therefore,
taint analysis tools must know the propagation rule for all the
method calls in the body of that inline function. Otherwise, it
fails to detect taint-ﬂows in inline functions.

9) Sealed class: A sealed class restricts users from in-
the derived classes
heriting a class or interface, and all
are known at compile time. To achieve this,
the Kotlin
compiler makes the constructor private and overloads the
constructor with an additional parameter at
the end—
kotlin.jvm.internal.DefaultConsructorMark-
er. This allows the compiler to call the overloaded constructor
for the known derived class and restricts developers from
creating a new derived class. Suppose users of taint analysis
tools specify the constructor of a sealed class as a propagator
method. In that case, the analysis must identify the overloaded
constructor as a propagator. Otherwise, taint analysis tools fail
to detect taint-ﬂows in a sealed class’s constructor.

10) Package: In Java, the package name must match the
path of that Java ﬁle. However, in Kotlin, the package name
can be different than the path of that Kotlin ﬁle. Once the
analysis component completes and returns the found results,
some existing Java taint analysis tools use the package name
to build the path of the Java ﬁle to display the errors in an IDE.
However, if the Kotlin ﬁle’s path is different from its package,
then taint analysis tools fail to display the found taint-ﬂows
in an IDE.

C. Research Questions

In the previous two sub-sections, Sub-Section III-A and
Sub-Section III-B, we discussed the various engineering chal-
lenges that must be handled in the existing Java taint analysis
tools to support taint analysis on Kotlin code. In this sub-
section, we answer two research questions (RQ1 and RQ2),
which evaluates our exploratory study.

To answer this research question, we list

RQ1: Which Kotlin’s features can be analyzed by the existing
Java taint analysis tools without any engineering challenge?
the Kotlin’s
features for which the Kotlin compiler generates the Java
bytecode similarly to the Java compiler. The existing Java
taint analysis tools can analyze Kotlin programs containing
these features without any engineering challenges. For all the
features listed under this research question, Soot generates
the valid Jimple code. Furthermore, the analysis component
can perform taint analysis on these features and requires no
additional constructs in the DSL component to handle these
features.

Kotlin’s features

Explicit conversion

Arithmetic operators, Bitwise operators, Comparison operators, assignment
operators, unary operators, logical operators, equality check, Literal constants,
varargs
is operator, unsafe cast operator, safe cast operator

when construct

for construct
while, do-while, if construct
return, break, continue, labeled break and labeled continue, and qualiﬁed this
in nested / inner class
labeled return (non-local return)
try-catch, ﬁnally, throw
import, named arguments
Open class
Abstract class, inheritance, overriding methods, calling super class implemen-
tations, multiple inheritance
Functional interface (SAM)
Generics
Nested class, inner class, enum class
Object expression
Object declaration
Delegation (in inheritance)
varargs
Tail-recursive function

String template

Smart cast

lateinit

Null safety
Default implementation in interface

Similarity
level
✔*

similar to

typecasting and Java’s methods like intValue,
byteValue etc.

✔

✔*
✔*
✔*
✔

✔

✔*
✔
✔
✔

✔

✔*
✔
✔
✔
✔*
✔*
✔
✔

✔*
✔*
✔*
✔*
✔

instance check (instanceof), typecasting
lookupswitch, tableswitch, comparison,
goto and label
Java’s for, iterators

goto and label statements

non-ﬁnal class

Java’s lambda expression (invokedynamic)

instance of anonymous class
singleton pattern
Delegation pattern

normal function and loops
Java’s StringBuilder append, Kotlin’s
stringPlus methods
Typecasting after instance check
uninitialized ﬁeld, null check, Null pointer
exception (NPE)
null check, goto and label statements, NPE

Legend
✔: similar to the respective feature in Java.
✔: similar to Java, but the naming scheme of the generated wrapper class is different compared to Java.
✔: completely different to Java, but there is no challenge concerning taint analysis in DSL, analysis or IR generator components.
*: similar to Java’s features, some of them are not visible in the source code.

Table VI: List of Kotlin’s features, for which the existing Java taint analysis tools can analyze without any challenge.

Table VI summarizes the features of Kotlin that can be
analyzed by the existing Java taint analysis tools. ✔ represents
Kotlin’s features, for which the Kotlin compiler generates the
Java bytecode similar to the respective features in Java. *
represents Kotlin’s features, for which the Kotlin compiler gen-
erates the Java bytecode similar to some features (third column
in the table) in Java, which are not visible in Kotlin source
code. For example, the explicit conversion from the Number
type to the Int in Kotlin is performed using the method
toInt. However, in some scenarios, the Kotlin compiler uses
the intValue method in the Java bytecode. Furthermore,
the Kotlin compiler uses the StringBuilder append
method for the String template, and in some scenarios, it uses
Kotlin’s stringPlus method. Therefore, we recommend us-
ing Java’s general propagator methods while analyzing Kotlin
programs. ✔ represents Kotlin’s features, for which the Kotlin
compiler generates the Java bytecode similar to the respective
features in Java. However, the naming scheme of the generated

wrapper class by the Kotlin compiler is different compared to
that of the Java compiler. For the default implementation in
an interface, the Kotlin compiler generates the Java bytecode
differently from Java ✔. The Java compiler keeps the default
implementation in the interface. However, the Kotlin compiler
keeps only the abstract methods in the interface, and the
default implementation is placed in the generated wrapper
class. For example, suppose a developer uses the default
implementation method in a class, which implements that
interface. In that case,
the Kotlin compiler overrides that
method automatically and calls the default implementation
present in the wrapper class. Whenever that default method
is called, the Kotlin compiler calls the virtual method from
the object of the derived class or interface similar to the Java
compiler. Therefore, there is no engineering challenge with
this feature in the DSL, analysis, and IR generator component.
However, there may be some challenges with this feature in
other components such as the call graph generator component.

Kotlin’s features

Data types

Exception types and type alias

Top-level functions and top-level properties

Package

Constructor with default arguments and function with default
arguments
Internal visibility modiﬁer
Sealed class
Inline class
Function returning anonymous object
Companion object
Inﬁx function
Local functions

Qualiﬁed this object

Engineering challenges

Data type mapping (III-A1)

Type alias (III-A2)

Top-level members (III-A4)

Package (III-B10)

Default argument (III-A5)

Internal modiﬁer (III-B3)
Sealed class (III-B9)
Inline class (III-B4)
Function returning anonymous object (III-B5)
Companion object (III-B1)
Inﬁx function (III-A7)
Local functions (III-B6)

qualiﬁed this object in extensions as members (III-A6),
qualiﬁed this object in function with receiver type (III-B7)

Destructuring declaration
Properties accessors
Extension function, extension property, companion object ex-
tension and extensions as members

Destructuring declaration (III-B2)
Properties accessors (III-A3)

Extensions (III-A6)

Data class

Destructuring declaration (III-B2), default argument (III-A5)

✪, ★

lambda expression, anonymous function, function literal with a
receiver, callable reference, class implementing function types
inline function
Operator overloading

Higher-order function (III-B7), function type (III-A1)

Inline function (III-B8)
Operator overloading (III-A8)

Top-level members (III-A4), inﬁx function (III-A7), extensions
(III-A6)

Ranges and Progressions

Collections and Iterators

Data type mapping (III-A1), Top-level members (III-A4),
extensions (III-A6) and destructuring declarations (III-B2)

● and ✪

can be solved
in
●

Note

●

●

✪

★

✪
✪
✪
✪
✪
●
✪

✪

✪
●

✪

✪

✪
●

●

Kotlin’s exception types are deﬁned as type aliases to
Java’s exception types.

This challenge can also be solved in the component that
integrates the analysis with the IDE.

qualiﬁed this object in nested / inner class is same as
Java’s qualiﬁed this in nested / inner class. Therefore,
there is no challenge in this scenario

For a data class, the Kotlin compiler automatically gen-
erates the componentN function for the destructuring
declaration ✪. Additionally, it also generates the copy
function with the default value. Therefore, this feature
also has the challenge of default argument for the copy
function ★.

the methods until,
In Ranges and Progressions,
downto, and step are deﬁned as top-level, extension,
inﬁx function.
Kotlin uses other features such as extensions, destruc-
turing declaration, etc., to deﬁne the members of collec-
tions and iterators. In addition, some of the collection
types are mapped to Java’s collection types, and some
collection types are deﬁned as type aliases to Java’s
collection types.

Legend
●: Engineering challenge(s) can be solved in the DSL component.
★: Engineering challenge(s) can be solved in the analysis component.
✪: Engineering challenge(s) can be solved either in the DSL or analysis component (depends on the analysis designer decision).

Table VII: List of Kotlin’s features that requires an extension in the DSL or analysis components of the existing Java taint
analysis tools to support taint analysis for Kotlin programs.

RQ2: For which Kotlin’s features, the existing Java taint
analysis tools need an extension to support taint analysis for
Kotlin programs?

To answer this research question, we list

the Kotlin’s
features for which the Kotlin compiler generates the Java
bytecode differently from the Java compiler. Such differences
makes an engineering challenges in the existing Java taint anal-
ysis tools analyzing Kotlin programs, as discussed in Section
III. Static analysis developers must handle these challegens in
the DSL, analysis, or IR generator components.

Table VII summarizes the features of Kotlin that require an
extension in the existing Java taint analysis tools to support
taint analysis for Kotlin. The engineering challenges associated
with Kotlin’s features are given in the second column. If a
Kotlin’s feature can be handled in the DSL component, then
we categorize that feature into ●. Furthermore, suppose a
challenge can be solved in the analysis component without
any input from the users of taint analysis tools. In that
case, we categorize that feature into ★. For instance, we
can solve the default argument challenge (Sub-Section III-A5)
in the analysis component without implementing additional
constructs in the DSL component.

We did not propose a solution for the challenges discussed
in Section III-B. However, we can handle these challenges
in the DSL or analysis component based on the solution and

the analysis designer’s decision. Kotlin’s features associated
with these challenges are categorized into ✪. Additionally, for
all the features of Kotlin that we manually examined in this
exploratory research, Soot generates the valid Jimple code.

IV. SECUCHECK-KOTLIN

As a proof of concept, we extended an existing Java taint
analysis tool called SECUCHECK [12] by implementing the
solution for six of the engineering challenges discussed in Sub-
Section III-A. For the taint analysis, SECUCHECK uses Jimple
IR [16] generated by SOOT [17]. Furthermore, SECUCHECK
provides a DSL called ﬂuentTQL [7] for specifying taint
ﬂows. First, we discuss the implementation of SECUCHECK-
KOTLIN in Sub-Section IV-A. Then, we evaluate the applica-
bility of SECUCHECK-KOTLIN in Sub-Section IV-B.

A. Implementation

Table VIII summarizes the list of challenges that we handled
in SECUCHECK-KOTLIN. We implemented the solutions for
these challenges without modifying the existing architecture
of SECUCHECK.

For handling the data type mapping discussed in Sub-
Section III-A1, we implemented a data type transformer
module in ﬂuentTQL ●*. This transformer checks whether
the given type in a method signature is a valid Kotlin type

Challenges
Data type mapping
(III-A1)

Type alias
(III-A2)

Property
(III-A3)
Top-level members
(III-A4)

Extensions
(III-A6)

Default
(III-A5)

argument

Solved in

Newly added constructs in ﬂuentTQL

●*

●

●

●

●

★

-

TypeAliases class for experts in Kotlin and domain-experts
in custom libraries. The object of TypeAliases are
accepted in MethodSignatureBuilder,
MethodSelector, and MethodConfigurator.

property, getter, and setter methods

topLevelMember method

extensionFunction and extensionProperty
methods. For handling qualiﬁed this object challenge,
provides constants
QualifiedThis.DISPATCH_RECEIVER and
QualifiedThis.EXTENSION_RECEIVER

-

Legend
●: solved in ﬂuentTQL DSL.
●*: solved in ﬂuentTQL without implementing new construct in ﬂuentTQL DSL.
★: solved in the analysis component.

Table VIII: List of found engineering challenges handled in
SECUCHECK-KOTLIN.

or function type, as described in Tables III and IV, and
transforms the given type into respective Java data type. This
allows users to provide Kotlin types such as kotlin.Int,
kotlin.Int?, etc., in a method signature. In addition, users
can also provide short type names such as Int, Int?, etc.
Furthermore, for a function type, users can provide a regular
expression such as “() → ”, or a function type itself
such as “() → String”. The transformer looks for the
function type expression and transforms it into a valid data
type, as summarized in Table III. The limitation of this current
implementation is that users can not provide complex function
types such as (Int) → (Int, Int) → String. For
such function types, users must use regular expressions, e.g.,
( ) → . Additionally, suppose users want to specify to
track a parameter of function type in ﬂuentTQL. In that case,
users must explicitly specify the propagation rules for the
invoke method of the Function* class as discussed in
Sub-Section III-B7.

For handling type alias (III-A2), property (III-A3), top-
level members (III-A4), and extensions (III-A6), we imple-
mented new constructs in ﬂuentTQL that helps the users
to specify the respective features ●. Listing 1 demon-
strates the way of specifying type aliases and extension
property in ﬂuentTQL of SECUCHECK-KOTLIN. For the
type alias challenge, we implemented the TypeAliases
class in ﬂuentTQL, which experts in Kotlin programming
language or the domain experts in custom libraries can use
to specify type aliases. For instance, experts in the Kotlin
programming language can specify the type aliases deﬁned
in the Kotlin standard library as shown in Lines 2-6. Then,
the users of ﬂuentTQL can use the speciﬁed type aliases
in MethodConfigurator (Line 14), MethodSelector,
or MethodSignatureBuilder, which replaces the given
type alias with the original type as speciﬁed by the experts.
Note: SECUCHECK provides MethodSignatureBuilder
for novice users to build a method signature with ﬂuent
interface. Similarly, it provides MethodConfigurator and
MethodSelector for conﬁguring methods with taint infor-

mation using ﬂuent interface.

For handling the property,

top-level members, and ex-
interface
tensions, we provide the methods in the ﬂuent
of MethodSignatureBuilder. For example, for proper-
ties, the methods are property, getter (Line 12), and
setter. If a property is an extension,
then the method
is extensionProperty (Line 11). This function takes
three arguments—receiver type, property name, and prop-
erty type. From these inputs, ﬂuentTQL builds the valid
method signature. Similarly, extensionFunction method
for specifying extension functions and the topLevelMem-
ber method for specifying top-level members. For han-
dling the qualiﬁed this-object
in extensions, we pro-
vide two constants—Qualified.DISPATCH_RECEIVER
and Qualified.EXTENSION_RECEIVER, which can
be used in the method thisObject (Line 15) of
MethodConfigurator to track the respective this
object. The limitation for
that
these methods are only available in the method chain
of MethodSignatureBuilder and not available for
MethodConfigurator and MethodSelector. Simi-
the qualiﬁed this constants are only available
larly,
for MethodConfigurator, and it
is not available for
MethodSelector. Finally, we handled the challenge of
default argument in the analysis component ★, as proposed
in Sub-Section III-A5.

implementation is

this

B. Evaluation

To evaluate the applicability of SECUCHECK-KOTLIN, we
found a vulnerable version of the Spring PetClinic application
written in Kotlin4. This project contains 27 Kotlin ﬁles with
six known hibernate injections as summarized in Table IX.

s
e
l
ﬁ
-
n
i
l
t
o
K
#

s
w
o
ﬂ
-
t
n
i
a
T
#

s
e
i
r
e
u
Q
#

s
w
o
ﬂ
-
d
n
u
o
F
#

)
s
(
e
m
i
t
n
u
R
#

?
s
e
g
a
s
s
e
m
r
o
r
r
e

y
a
l
p
s
i
D

?
s
r
e
b
m
u
n
e
n
i
l

y
a
l
p
s
i
D

?
s
n
o
i
t
a
c
o
l
e
l
ﬁ

y
a
l
p
s
i
D

27

6

5

6

11.05

✔

✔

✔

Project Name
spring-petclinic-kotlin
(vulnerable)

#Kotlin-ﬁles: Number of Kotlin ﬁles in the project
#Taint-ﬂows: Number of known taint-ﬂows in the project
#Queries: Number of speciﬁed taint-ﬂow queries in ﬂuentTQL of SECUCHECK-KOTLIN
#Found-ﬂows: Number of found taint-ﬂows by SECUCHECK-KOTLIN
#Runtime (s): Runtime in seconds (average of 10 runs)

Table IX: Overview of SECUCHECK-KOTLIN analysis results.

SECUCHECK-KOTLIN found all the six taint-ﬂows with the
run time of 11.05 seconds (average of 10 runs). SECUCHECK-
KOTLIN successfully displayed the valid line numbers of
the source and sink methods. It also displayed the cus-
tomized error message as well as the descriptive messages
from the ﬂuentTQL2ENGLISH translator [12]. Additionally,
SECUCHECK-KOTLIN displayed the ﬁle locations of
the
source and sink methods. However, SECUCHECK through the
command prompt displays the ﬁle location of the classes

4https://shorturl.at/hvyRS

1 // Specified by Kotlin programming language experts.
2 static TypeAliases typeAliases = new TypeAliases(){{
3

add("ArrayList", "java.util.ArrayList");
add("HashSet", "java.util.HashSet");
...

4

5
6 }};
7
8 // Specified by the users of fluentTQL
9 public MethodSignature signature = new MethodSignatureBuilder()
.atClass("de.fraunhofer.iem.EmployeePrinter")
10
.extensionProperty("de.fraunhofer.iem.Employee", "nameLength", "Int")
.getter();

12

11

13
14 public Method source1 = new MethodConfigurator(signature, typeAliases)
15

.in().thisObject(QualifiedThis.DISPATCH_RECEIVER)
.out().returnValue()
.configure();

16

17

Listing 1: Example of type alias, extension property in ﬂuentTQL of SECUCHECK-KOTLIN.

Ele-
Neutralization
[8] “CWE-77:
ments
Injection’),”
Command
https://cwe.mitre.org/data/deﬁnitions/77.html, accessed: 2021-October-
25.

of
(’Command

Improper
a
in

Special

used

[9] “CWE-476:

Dereference,”
https://cwe.mitre.org/data/deﬁnitions/476.html, accessed: 2021-June-18.
[10] D. Endler, “The evolution of cross site scripting attacks,” Technical

Pointer

NULL

report, iDEFENSE Labs, Tech. Rep., 2002.

[11] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y. Le Traon, D. Octeau, and P. McDaniel, “Flowdroid: Precise context,
ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint analysis for android
apps,” Acm Sigplan Notices, vol. 49, no. 6, pp. 259–269, 2014.
[12] G. Piskachev, R. Krishnamurthy, and E. Bodden, “Secucheck: Engineer-
ing conﬁgurable taint analysis for software developers,” in 2021 IEEE
21st International Working Conference on Source Code Analysis and
Manipulation (SCAM), 2021, pp. 24–29.

[13] P. Lam, E. Bodden, O. Lhot´ak, and L. Hendren, “The Soot framework
for Java program analysis: a retrospective,” in Cetus Users and Compiler
Infastructure Workshop (CETUS 2011), vol. 15, no. 35, 2011.

[14] “Kotlin’s ofﬁcial documentation,” https://kotlinlang.org/docs/home.html,

accessed: 2021-November-21.
State

of

[15] “The

Developer

Ecosystem

https://www.jetbrains.com/lp/devecosystem-2020/kotlin/,
2021-October-27.

2020,”
accessed:

[16] R. Vallee-Rai and L. J. Hendren, “Jimple: Simplifying Java bytecode

for analyses and transformations,” 1998.

[17] R. Vall´ee-Rai, P. Co, E. Gagnon, L. Hendren, P. Lam, and
V. Sundaresan, “Soot: A java bytecode optimization framework,”
in CASCON First Decade High Impact Papers, ser. CASCON ’10.
Riverton, NJ, USA: IBM Corp., 2010, pp. 214–224. [Online]. Available:
https://doi.org/10.1145/1925805.1925818

[18] S. Kummita and G. Piskachev, “Integration of the static analysis results
interchange format in cognicrypt,” arXiv preprint arXiv:1907.02558,
2019.

instead of the Java ﬁles in the Static Analysis Results Inter-
change Format (SARIF) [18] output. Therefore, SECUCHECK-
KOTLIN has no problem in displaying the valid ﬁle locations.
However, suppose developers want to display the ﬁle location
of the Kotlin ﬁles instead of the class ﬁles in the SARIF output.
In that case, ﬁle location of the Kotlin ﬁles has to be identiﬁed
based on the challenge we discussed in Section III.

V. CONCLUSION AND FUTURE WORK

In this paper, we presented our exploratory study for Kotlin
taint analysis, which shows that most of the Kotlin constructs
can be analyzed by an existing Java taint analysis tool.
However, we found 18 engineering challenges that must be
handled differently than the Java taint analysis. For eight
of these challenges, we proposed solutions. Finally, as a
proof of concept, we extended an existing Java taint analysis,
SECUCHECK, by implementing six of these solutions, which
led to SECUCHECK-KOTLIN. We evaluated the applicability
of SECUCHECK-KOTLIN, which found all the six expected
taint-ﬂows. In the future, we plan to work on the open issues
from Sub-Section III-B and extend the implementation of
SECUCHECK-KOTLIN, after which a thorough evaluation with
real-world applications can be performed.

REFERENCES

[1] “CWE-89:

Improper Neutralization of Special Elements used in
an SQL Command,” https://cwe.mitre.org/data/deﬁnitions/89.html, ac-
cessed: 2021-June-22.

[2] “KTLINT: An anti-bikeshedding Kotlin linter with built-in formatter,”

https://github.com/pinterest/ktlint, accessed: 2021-December-14.

[3] “DETEKT: static analysis for Kotlin,” https://github.com/detekt/detekt,

accessed: 2021-December-14.

[4] “DIKTAT: Strict coding standard for Kotlin and a custom set of
for detecting code smells, code style issues and bugs,”
2021-

rules
https://github.com/diktat-static-analysis/diKTat,
December-14.

accessed:

[5] “SONARQUBE: automatic code review tool to detect bugs, vulnerabili-
ties, and code smells,” https://docs.sonarqube.org/latest/, accessed: 2021-
December-14.

[6] “SONARQUBE:

rules for Kotlin.” https://rules.sonarsource.com/kotlin ,

accessed: 2021-December-14.

J. Sp¨ath,

[7] G. Piskachev,
specifying
Eng.,
no.
https://doi.org/10.1007/s10664-022-10165-y

I. Budde,
taint-ﬂow queries with
104,
5,
27,

vol.

p.

and E. Bodden,

“Fluently
Softw.
[Online]. Available:

Empir.

ﬂuenttql,”

2022.

